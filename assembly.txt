
build/zephyr/zephyr.elf:	file format elf32-littlearm

Disassembly of section rom_start:

08000000 <_vector_start>:
 8000000: 48 2d 00 20  	.word	0x20002d48
 8000004: 71 33 00 08  	.word	0x08003371
 8000008: f9 25 00 08  	.word	0x080025f9
 800000c: 5d 33 00 08  	.word	0x0800335d
 8000010: 5d 33 00 08  	.word	0x0800335d
 8000014: 5d 33 00 08  	.word	0x0800335d
 8000018: 5d 33 00 08  	.word	0x0800335d
 800001c: 00 00 00 00  	.word	0x00000000
 8000020: 00 00 00 00  	.word	0x00000000
 8000024: 00 00 00 00  	.word	0x00000000
 8000028: 00 00 00 00  	.word	0x00000000
 800002c: dd 34 00 08  	.word	0x080034dd
 8000030: 5d 33 00 08  	.word	0x0800335d
 8000034: 00 00 00 00  	.word	0x00000000
 8000038: 6d 34 00 08  	.word	0x0800346d
 800003c: dd a1 00 08  	.word	0x0800a1dd

08000040 <$d>:
 8000040: 31 37 00 08  	.word	0x08003731
 8000044: 31 37 00 08  	.word	0x08003731
 8000048: 31 37 00 08  	.word	0x08003731
 800004c: 31 37 00 08  	.word	0x08003731
 8000050: 31 37 00 08  	.word	0x08003731
 8000054: 31 37 00 08  	.word	0x08003731
 8000058: 31 37 00 08  	.word	0x08003731
 800005c: 31 37 00 08  	.word	0x08003731
 8000060: 31 37 00 08  	.word	0x08003731
 8000064: 31 37 00 08  	.word	0x08003731
 8000068: 31 37 00 08  	.word	0x08003731
 800006c: 31 37 00 08  	.word	0x08003731
 8000070: 31 37 00 08  	.word	0x08003731
 8000074: 31 37 00 08  	.word	0x08003731
 8000078: 31 37 00 08  	.word	0x08003731
 800007c: 31 37 00 08  	.word	0x08003731
 8000080: 31 37 00 08  	.word	0x08003731
 8000084: 31 37 00 08  	.word	0x08003731
 8000088: 31 37 00 08  	.word	0x08003731
 800008c: 31 37 00 08  	.word	0x08003731
 8000090: 31 37 00 08  	.word	0x08003731
 8000094: 31 37 00 08  	.word	0x08003731
 8000098: 31 37 00 08  	.word	0x08003731
 800009c: 31 37 00 08  	.word	0x08003731
 80000a0: 31 37 00 08  	.word	0x08003731
 80000a4: 31 37 00 08  	.word	0x08003731
 80000a8: 31 37 00 08  	.word	0x08003731
 80000ac: 31 37 00 08  	.word	0x08003731
 80000b0: 31 37 00 08  	.word	0x08003731
 80000b4: 31 37 00 08  	.word	0x08003731
 80000b8: 31 37 00 08  	.word	0x08003731
 80000bc: 31 37 00 08  	.word	0x08003731
 80000c0: 31 37 00 08  	.word	0x08003731
 80000c4: 31 37 00 08  	.word	0x08003731
 80000c8: 31 37 00 08  	.word	0x08003731
 80000cc: 31 37 00 08  	.word	0x08003731
 80000d0: 31 37 00 08  	.word	0x08003731
 80000d4: 31 37 00 08  	.word	0x08003731
 80000d8: 31 37 00 08  	.word	0x08003731
 80000dc: 31 37 00 08  	.word	0x08003731
 80000e0: 31 37 00 08  	.word	0x08003731
 80000e4: 31 37 00 08  	.word	0x08003731
 80000e8: 31 37 00 08  	.word	0x08003731
 80000ec: 31 37 00 08  	.word	0x08003731
 80000f0: 31 37 00 08  	.word	0x08003731
 80000f4: 31 37 00 08  	.word	0x08003731
 80000f8: 31 37 00 08  	.word	0x08003731
 80000fc: 31 37 00 08  	.word	0x08003731
 8000100: 31 37 00 08  	.word	0x08003731
 8000104: 31 37 00 08  	.word	0x08003731
 8000108: 31 37 00 08  	.word	0x08003731
 800010c: 31 37 00 08  	.word	0x08003731
 8000110: 31 37 00 08  	.word	0x08003731
 8000114: 31 37 00 08  	.word	0x08003731
 8000118: 31 37 00 08  	.word	0x08003731
 800011c: 31 37 00 08  	.word	0x08003731
 8000120: 31 37 00 08  	.word	0x08003731
 8000124: 31 37 00 08  	.word	0x08003731
 8000128: 31 37 00 08  	.word	0x08003731
 800012c: 31 37 00 08  	.word	0x08003731
 8000130: 31 37 00 08  	.word	0x08003731
 8000134: 31 37 00 08  	.word	0x08003731
 8000138: 31 37 00 08  	.word	0x08003731
 800013c: 31 37 00 08  	.word	0x08003731
 8000140: 31 37 00 08  	.word	0x08003731
 8000144: 31 37 00 08  	.word	0x08003731
 8000148: 31 37 00 08  	.word	0x08003731
 800014c: 31 37 00 08  	.word	0x08003731
 8000150: 31 37 00 08  	.word	0x08003731
 8000154: 31 37 00 08  	.word	0x08003731
 8000158: 31 37 00 08  	.word	0x08003731
 800015c: 31 37 00 08  	.word	0x08003731
 8000160: 31 37 00 08  	.word	0x08003731
 8000164: 31 37 00 08  	.word	0x08003731
 8000168: 31 37 00 08  	.word	0x08003731
 800016c: 31 37 00 08  	.word	0x08003731
 8000170: 31 37 00 08  	.word	0x08003731
 8000174: 31 37 00 08  	.word	0x08003731
 8000178: 31 37 00 08  	.word	0x08003731
 800017c: 31 37 00 08  	.word	0x08003731
 8000180: 31 37 00 08  	.word	0x08003731
 8000184: 31 37 00 08  	.word	0x08003731

Disassembly of section text:

08000188 <__text_region_start>:
 8000188: f081 4100    	eor	r1, r1, #0x80000000
 800018c: e002         	b	0x8000194 <__aeabi_dadd> @ imm = #0x4
 800018e: bf00         	nop

08000190 <__subdf3>:
 8000190: f083 4300    	eor	r3, r3, #0x80000000

08000194 <__aeabi_dadd>:
 8000194: b530         	push	{r4, r5, lr}
 8000196: ea4f 0441    	lsl.w	r4, r1, #0x1
 800019a: ea4f 0543    	lsl.w	r5, r3, #0x1
 800019e: ea94 0f05    	teq.w	r4, r5
 80001a2: bf08         	it	eq
 80001a4: ea90 0f02    	teqeq.w	r0, r2
 80001a8: bf1f         	itttt	ne
 80001aa: ea54 0c00    	orrsne.w	r12, r4, r0
 80001ae: ea55 0c02    	orrsne.w	r12, r5, r2
 80001b2: ea7f 5c64    	mvnsne.w	r12, r4, asr #21
 80001b6: ea7f 5c65    	mvnsne.w	r12, r5, asr #21
 80001ba: f000 80e2    	beq.w	0x8000382 <__aeabi_dadd+0x1ee> @ imm = #0x1c4
 80001be: ea4f 5454    	lsr.w	r4, r4, #0x15
 80001c2: ebd4 5555    	rsbs	r5, r4, r5, lsr #21
 80001c6: bfb8         	it	lt
 80001c8: 426d         	rsblt	r5, r5, #0
 80001ca: dd0c         	ble	0x80001e6 <__aeabi_dadd+0x52> @ imm = #0x18
 80001cc: 442c         	add	r4, r5
 80001ce: ea80 0202    	eor.w	r2, r0, r2
 80001d2: ea81 0303    	eor.w	r3, r1, r3
 80001d6: ea82 0000    	eor.w	r0, r2, r0
 80001da: ea83 0101    	eor.w	r1, r3, r1
 80001de: ea80 0202    	eor.w	r2, r0, r2
 80001e2: ea81 0303    	eor.w	r3, r1, r3
 80001e6: 2d36         	cmp	r5, #0x36
 80001e8: bf88         	it	hi
 80001ea: bd30         	pophi	{r4, r5, pc}
 80001ec: f011 4f00    	tst.w	r1, #0x80000000
 80001f0: ea4f 3101    	lsl.w	r1, r1, #0xc
 80001f4: f44f 1c80    	mov.w	r12, #0x100000
 80001f8: ea4c 3111    	orr.w	r1, r12, r1, lsr #12
 80001fc: d002         	beq	0x8000204 <__aeabi_dadd+0x70> @ imm = #0x4
 80001fe: 4240         	rsbs	r0, r0, #0
 8000200: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8000204: f013 4f00    	tst.w	r3, #0x80000000
 8000208: ea4f 3303    	lsl.w	r3, r3, #0xc
 800020c: ea4c 3313    	orr.w	r3, r12, r3, lsr #12
 8000210: d002         	beq	0x8000218 <__aeabi_dadd+0x84> @ imm = #0x4
 8000212: 4252         	rsbs	r2, r2, #0
 8000214: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 8000218: ea94 0f05    	teq.w	r4, r5
 800021c: f000 80a7    	beq.w	0x800036e <__aeabi_dadd+0x1da> @ imm = #0x14e
 8000220: f1a4 0401    	sub.w	r4, r4, #0x1
 8000224: f1d5 0e20    	rsbs.w	lr, r5, #0x20
 8000228: db0d         	blt	0x8000246 <__aeabi_dadd+0xb2> @ imm = #0x1a
 800022a: fa02 fc0e    	lsl.w	r12, r2, lr
 800022e: fa22 f205    	lsr.w	r2, r2, r5
 8000232: 1880         	adds	r0, r0, r2
 8000234: f141 0100    	adc	r1, r1, #0x0
 8000238: fa03 f20e    	lsl.w	r2, r3, lr
 800023c: 1880         	adds	r0, r0, r2
 800023e: fa43 f305    	asr.w	r3, r3, r5
 8000242: 4159         	adcs	r1, r3
 8000244: e00e         	b	0x8000264 <__aeabi_dadd+0xd0> @ imm = #0x1c
 8000246: f1a5 0520    	sub.w	r5, r5, #0x20
 800024a: f10e 0e20    	add.w	lr, lr, #0x20
 800024e: 2a01         	cmp	r2, #0x1
 8000250: fa03 fc0e    	lsl.w	r12, r3, lr
 8000254: bf28         	it	hs
 8000256: f04c 0c02    	orrhs	r12, r12, #0x2
 800025a: fa43 f305    	asr.w	r3, r3, r5
 800025e: 18c0         	adds	r0, r0, r3
 8000260: eb51 71e3    	adcs.w	r1, r1, r3, asr #31
 8000264: f001 4500    	and	r5, r1, #0x80000000
 8000268: d507         	bpl	0x800027a <__aeabi_dadd+0xe6> @ imm = #0xe
 800026a: f04f 0e00    	mov.w	lr, #0x0
 800026e: f1dc 0c00    	rsbs.w	r12, r12, #0x0
 8000272: eb7e 0000    	sbcs.w	r0, lr, r0
 8000276: eb6e 0101    	sbc.w	r1, lr, r1
 800027a: f5b1 1f80    	cmp.w	r1, #0x100000
 800027e: d31b         	blo	0x80002b8 <__aeabi_dadd+0x124> @ imm = #0x36
 8000280: f5b1 1f00    	cmp.w	r1, #0x200000
 8000284: d30c         	blo	0x80002a0 <__aeabi_dadd+0x10c> @ imm = #0x18
 8000286: 0849         	lsrs	r1, r1, #0x1
 8000288: ea5f 0030    	rrxs	r0, r0
 800028c: ea4f 0c3c    	rrx	r12, r12
 8000290: f104 0401    	add.w	r4, r4, #0x1
 8000294: ea4f 5244    	lsl.w	r2, r4, #0x15
 8000298: f512 0f80    	cmn.w	r2, #0x400000
 800029c: f080 809a    	bhs.w	0x80003d4 <__aeabi_dadd+0x240> @ imm = #0x134
 80002a0: f1bc 4f00    	cmp.w	r12, #0x80000000
 80002a4: bf08         	it	eq
 80002a6: ea5f 0c50    	lsrseq.w	r12, r0, #0x1
 80002aa: f150 0000    	adcs	r0, r0, #0x0
 80002ae: eb41 5104    	adc.w	r1, r1, r4, lsl #20
 80002b2: ea41 0105    	orr.w	r1, r1, r5
 80002b6: bd30         	pop	{r4, r5, pc}
 80002b8: ea5f 0c4c    	lsls.w	r12, r12, #0x1
 80002bc: 4140         	adcs	r0, r0
 80002be: eb41 0101    	adc.w	r1, r1, r1
 80002c2: 3c01         	subs	r4, #0x1
 80002c4: bf28         	it	hs
 80002c6: f5b1 1f80    	cmphs.w	r1, #0x100000
 80002ca: d2e9         	bhs	0x80002a0 <__aeabi_dadd+0x10c> @ imm = #-0x2e
 80002cc: f091 0f00    	teq.w	r1, #0x0
 80002d0: bf04         	itt	eq
 80002d2: 4601         	moveq	r1, r0
 80002d4: 2000         	moveq	r0, #0x0
 80002d6: fab1 f381    	clz	r3, r1
 80002da: bf08         	it	eq
 80002dc: 3320         	addeq	r3, #0x20
 80002de: f1a3 030b    	sub.w	r3, r3, #0xb
 80002e2: f1b3 0220    	subs.w	r2, r3, #0x20
 80002e6: da0c         	bge	0x8000302 <__aeabi_dadd+0x16e> @ imm = #0x18
 80002e8: 320c         	adds	r2, #0xc
 80002ea: dd08         	ble	0x80002fe <__aeabi_dadd+0x16a> @ imm = #0x10
 80002ec: f102 0c14    	add.w	r12, r2, #0x14
 80002f0: f1c2 020c    	rsb.w	r2, r2, #0xc
 80002f4: fa01 f00c    	lsl.w	r0, r1, r12
 80002f8: fa21 f102    	lsr.w	r1, r1, r2
 80002fc: e00c         	b	0x8000318 <__aeabi_dadd+0x184> @ imm = #0x18
 80002fe: f102 0214    	add.w	r2, r2, #0x14
 8000302: bfd8         	it	le
 8000304: f1c2 0c20    	rsble.w	r12, r2, #0x20
 8000308: fa01 f102    	lsl.w	r1, r1, r2
 800030c: fa20 fc0c    	lsr.w	r12, r0, r12
 8000310: bfdc         	itt	le
 8000312: ea41 010c    	orrle.w	r1, r1, r12
 8000316: 4090         	lslle	r0, r2
 8000318: 1ae4         	subs	r4, r4, r3
 800031a: bfa2         	ittt	ge
 800031c: eb01 5104    	addge.w	r1, r1, r4, lsl #20
 8000320: 4329         	orrge	r1, r5
 8000322: bd30         	popge	{r4, r5, pc}
 8000324: ea6f 0404    	mvn.w	r4, r4
 8000328: 3c1f         	subs	r4, #0x1f
 800032a: da1c         	bge	0x8000366 <__aeabi_dadd+0x1d2> @ imm = #0x38
 800032c: 340c         	adds	r4, #0xc
 800032e: dc0e         	bgt	0x800034e <__aeabi_dadd+0x1ba> @ imm = #0x1c
 8000330: f104 0414    	add.w	r4, r4, #0x14
 8000334: f1c4 0220    	rsb.w	r2, r4, #0x20
 8000338: fa20 f004    	lsr.w	r0, r0, r4
 800033c: fa01 f302    	lsl.w	r3, r1, r2
 8000340: ea40 0003    	orr.w	r0, r0, r3
 8000344: fa21 f304    	lsr.w	r3, r1, r4
 8000348: ea45 0103    	orr.w	r1, r5, r3
 800034c: bd30         	pop	{r4, r5, pc}
 800034e: f1c4 040c    	rsb.w	r4, r4, #0xc
 8000352: f1c4 0220    	rsb.w	r2, r4, #0x20
 8000356: fa20 f002    	lsr.w	r0, r0, r2
 800035a: fa01 f304    	lsl.w	r3, r1, r4
 800035e: ea40 0003    	orr.w	r0, r0, r3
 8000362: 4629         	mov	r1, r5
 8000364: bd30         	pop	{r4, r5, pc}
 8000366: fa21 f004    	lsr.w	r0, r1, r4
 800036a: 4629         	mov	r1, r5
 800036c: bd30         	pop	{r4, r5, pc}
 800036e: f094 0f00    	teq.w	r4, #0x0
 8000372: f483 1380    	eor	r3, r3, #0x100000
 8000376: bf06         	itte	eq
 8000378: f481 1180    	eoreq	r1, r1, #0x100000
 800037c: 3401         	addeq	r4, #0x1
 800037e: 3d01         	subne	r5, #0x1
 8000380: e74e         	b	0x8000220 <__aeabi_dadd+0x8c> @ imm = #-0x164
 8000382: ea7f 5c64    	mvns.w	r12, r4, asr #21
 8000386: bf18         	it	ne
 8000388: ea7f 5c65    	mvnsne.w	r12, r5, asr #21
 800038c: d029         	beq	0x80003e2 <__aeabi_dadd+0x24e> @ imm = #0x52
 800038e: ea94 0f05    	teq.w	r4, r5
 8000392: bf08         	it	eq
 8000394: ea90 0f02    	teqeq.w	r0, r2
 8000398: d005         	beq	0x80003a6 <__aeabi_dadd+0x212> @ imm = #0xa
 800039a: ea54 0c00    	orrs.w	r12, r4, r0
 800039e: bf04         	itt	eq
 80003a0: 4619         	moveq	r1, r3
 80003a2: 4610         	moveq	r0, r2
 80003a4: bd30         	pop	{r4, r5, pc}
 80003a6: ea91 0f03    	teq.w	r1, r3
 80003aa: bf1e         	ittt	ne
 80003ac: 2100         	movne	r1, #0x0
 80003ae: 2000         	movne	r0, #0x0
 80003b0: bd30         	popne	{r4, r5, pc}
 80003b2: ea5f 5c54    	lsrs.w	r12, r4, #0x15
 80003b6: d105         	bne	0x80003c4 <__aeabi_dadd+0x230> @ imm = #0xa
 80003b8: 0040         	lsls	r0, r0, #0x1
 80003ba: 4149         	adcs	r1, r1
 80003bc: bf28         	it	hs
 80003be: f041 4100    	orrhs	r1, r1, #0x80000000
 80003c2: bd30         	pop	{r4, r5, pc}
 80003c4: f514 0480    	adds.w	r4, r4, #0x400000
 80003c8: bf3c         	itt	lo
 80003ca: f501 1180    	addlo.w	r1, r1, #0x100000
 80003ce: bd30         	poplo	{r4, r5, pc}
 80003d0: f001 4500    	and	r5, r1, #0x80000000
 80003d4: f045 41fe    	orr	r1, r5, #0x7f000000
 80003d8: f441 0170    	orr	r1, r1, #0xf00000
 80003dc: f04f 0000    	mov.w	r0, #0x0
 80003e0: bd30         	pop	{r4, r5, pc}
 80003e2: ea7f 5c64    	mvns.w	r12, r4, asr #21
 80003e6: bf1a         	itte	ne
 80003e8: 4619         	movne	r1, r3
 80003ea: 4610         	movne	r0, r2
 80003ec: ea7f 5c65    	mvnseq.w	r12, r5, asr #21
 80003f0: bf1c         	itt	ne
 80003f2: 460b         	movne	r3, r1
 80003f4: 4602         	movne	r2, r0
 80003f6: ea50 3401    	orrs.w	r4, r0, r1, lsl #12
 80003fa: bf06         	itte	eq
 80003fc: ea52 3503    	orrseq.w	r5, r2, r3, lsl #12
 8000400: ea91 0f03    	teqeq.w	r1, r3
 8000404: f441 2100    	orrne	r1, r1, #0x80000
 8000408: bd30         	pop	{r4, r5, pc}
 800040a: bf00         	nop

0800040c <__floatunsidf>:
 800040c: f090 0f00    	teq.w	r0, #0x0
 8000410: bf04         	itt	eq
 8000412: 2100         	moveq	r1, #0x0
 8000414: 4770         	bxeq	lr
 8000416: b530         	push	{r4, r5, lr}
 8000418: f44f 6480    	mov.w	r4, #0x400
 800041c: f104 0432    	add.w	r4, r4, #0x32
 8000420: f04f 0500    	mov.w	r5, #0x0
 8000424: f04f 0100    	mov.w	r1, #0x0
 8000428: e750         	b	0x80002cc <__aeabi_dadd+0x138> @ imm = #-0x160
 800042a: bf00         	nop

0800042c <__floatsidf>:
 800042c: f090 0f00    	teq.w	r0, #0x0
 8000430: bf04         	itt	eq
 8000432: 2100         	moveq	r1, #0x0
 8000434: 4770         	bxeq	lr
 8000436: b530         	push	{r4, r5, lr}
 8000438: f44f 6480    	mov.w	r4, #0x400
 800043c: f104 0432    	add.w	r4, r4, #0x32
 8000440: f010 4500    	ands	r5, r0, #0x80000000
 8000444: bf48         	it	mi
 8000446: 4240         	rsbmi	r0, r0, #0
 8000448: f04f 0100    	mov.w	r1, #0x0
 800044c: e73e         	b	0x80002cc <__aeabi_dadd+0x138> @ imm = #-0x184
 800044e: bf00         	nop

08000450 <__extendsfdf2>:
 8000450: 0042         	lsls	r2, r0, #0x1
 8000452: ea4f 01e2    	asr.w	r1, r2, #0x3
 8000456: ea4f 0131    	rrx	r1, r1
 800045a: ea4f 7002    	lsl.w	r0, r2, #0x1c
 800045e: bf1f         	itttt	ne
 8000460: f012 437f    	andsne	r3, r2, #0xff000000
 8000464: f093 4f7f    	teqne.w	r3, #0xff000000
 8000468: f081 5160    	eorne	r1, r1, #0x38000000
 800046c: 4770         	bxne	lr
 800046e: f032 427f    	bics	r2, r2, #0xff000000
 8000472: bf08         	it	eq
 8000474: 4770         	bxeq	lr
 8000476: f093 4f7f    	teq.w	r3, #0xff000000
 800047a: bf04         	itt	eq
 800047c: f441 2100    	orreq	r1, r1, #0x80000
 8000480: 4770         	bxeq	lr
 8000482: b530         	push	{r4, r5, lr}
 8000484: f44f 7460    	mov.w	r4, #0x380
 8000488: f001 4500    	and	r5, r1, #0x80000000
 800048c: f021 4100    	bic	r1, r1, #0x80000000
 8000490: e71c         	b	0x80002cc <__aeabi_dadd+0x138> @ imm = #-0x1c8
 8000492: bf00         	nop

08000494 <__floatundidf>:
 8000494: ea50 0201    	orrs.w	r2, r0, r1
 8000498: bf08         	it	eq
 800049a: 4770         	bxeq	lr
 800049c: b530         	push	{r4, r5, lr}
 800049e: f04f 0500    	mov.w	r5, #0x0
 80004a2: e00a         	b	0x80004ba <__floatdidf+0x16> @ imm = #0x14

080004a4 <__floatdidf>:
 80004a4: ea50 0201    	orrs.w	r2, r0, r1
 80004a8: bf08         	it	eq
 80004aa: 4770         	bxeq	lr
 80004ac: b530         	push	{r4, r5, lr}
 80004ae: f011 4500    	ands	r5, r1, #0x80000000
 80004b2: d502         	bpl	0x80004ba <__floatdidf+0x16> @ imm = #0x4
 80004b4: 4240         	rsbs	r0, r0, #0
 80004b6: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80004ba: f44f 6480    	mov.w	r4, #0x400
 80004be: f104 0432    	add.w	r4, r4, #0x32
 80004c2: ea5f 5c91    	lsrs.w	r12, r1, #0x16
 80004c6: f43f aed8    	beq.w	0x800027a <__aeabi_dadd+0xe6> @ imm = #-0x250
 80004ca: f04f 0203    	mov.w	r2, #0x3
 80004ce: ea5f 0cdc    	lsrs.w	r12, r12, #0x3
 80004d2: bf18         	it	ne
 80004d4: 3203         	addne	r2, #0x3
 80004d6: ea5f 0cdc    	lsrs.w	r12, r12, #0x3
 80004da: bf18         	it	ne
 80004dc: 3203         	addne	r2, #0x3
 80004de: eb02 02dc    	add.w	r2, r2, r12, lsr #3
 80004e2: f1c2 0320    	rsb.w	r3, r2, #0x20
 80004e6: fa00 fc03    	lsl.w	r12, r0, r3
 80004ea: fa20 f002    	lsr.w	r0, r0, r2
 80004ee: fa01 fe03    	lsl.w	lr, r1, r3
 80004f2: ea40 000e    	orr.w	r0, r0, lr
 80004f6: fa21 f102    	lsr.w	r1, r1, r2
 80004fa: 4414         	add	r4, r2
 80004fc: e6bd         	b	0x800027a <__aeabi_dadd+0xe6> @ imm = #-0x286
 80004fe: bf00         	nop

08000500 <__aeabi_frsub>:
 8000500: f080 4000    	eor	r0, r0, #0x80000000
 8000504: e002         	b	0x800050c <__aeabi_fadd> @ imm = #0x4
 8000506: bf00         	nop

08000508 <__subsf3>:
 8000508: f081 4100    	eor	r1, r1, #0x80000000

0800050c <__aeabi_fadd>:
 800050c: 0042         	lsls	r2, r0, #0x1
 800050e: bf1f         	itttt	ne
 8000510: ea5f 0341    	lslsne.w	r3, r1, #0x1
 8000514: ea92 0f03    	teqne.w	r2, r3
 8000518: ea7f 6c22    	mvnsne.w	r12, r2, asr #24
 800051c: ea7f 6c23    	mvnsne.w	r12, r3, asr #24
 8000520: d06a         	beq	0x80005f8 <__aeabi_fadd+0xec> @ imm = #0xd4
 8000522: ea4f 6212    	lsr.w	r2, r2, #0x18
 8000526: ebd2 6313    	rsbs	r3, r2, r3, lsr #24
 800052a: bfc1         	itttt	gt
 800052c: 18d2         	addgt	r2, r2, r3
 800052e: 4041         	eorgt	r1, r0
 8000530: 4048         	eorgt	r0, r1
 8000532: 4041         	eorgt	r1, r0
 8000534: bfb8         	it	lt
 8000536: 425b         	rsblt	r3, r3, #0
 8000538: 2b19         	cmp	r3, #0x19
 800053a: bf88         	it	hi
 800053c: 4770         	bxhi	lr
 800053e: f010 4f00    	tst.w	r0, #0x80000000
 8000542: f440 0000    	orr	r0, r0, #0x800000
 8000546: f020 407f    	bic	r0, r0, #0xff000000
 800054a: bf18         	it	ne
 800054c: 4240         	rsbne	r0, r0, #0
 800054e: f011 4f00    	tst.w	r1, #0x80000000
 8000552: f441 0100    	orr	r1, r1, #0x800000
 8000556: f021 417f    	bic	r1, r1, #0xff000000
 800055a: bf18         	it	ne
 800055c: 4249         	rsbne	r1, r1, #0
 800055e: ea92 0f03    	teq.w	r2, r3
 8000562: d03f         	beq	0x80005e4 <__aeabi_fadd+0xd8> @ imm = #0x7e
 8000564: f1a2 0201    	sub.w	r2, r2, #0x1
 8000568: fa41 fc03    	asr.w	r12, r1, r3
 800056c: eb10 000c    	adds.w	r0, r0, r12
 8000570: f1c3 0320    	rsb.w	r3, r3, #0x20
 8000574: fa01 f103    	lsl.w	r1, r1, r3
 8000578: f000 4300    	and	r3, r0, #0x80000000
 800057c: d502         	bpl	0x8000584 <__aeabi_fadd+0x78> @ imm = #0x4
 800057e: 4249         	rsbs	r1, r1, #0
 8000580: eb60 0040    	sbc.w	r0, r0, r0, lsl #1
 8000584: f5b0 0f00    	cmp.w	r0, #0x800000
 8000588: d313         	blo	0x80005b2 <__aeabi_fadd+0xa6> @ imm = #0x26
 800058a: f1b0 7f80    	cmp.w	r0, #0x1000000
 800058e: d306         	blo	0x800059e <__aeabi_fadd+0x92> @ imm = #0xc
 8000590: 0840         	lsrs	r0, r0, #0x1
 8000592: ea4f 0131    	rrx	r1, r1
 8000596: f102 0201    	add.w	r2, r2, #0x1
 800059a: 2afe         	cmp	r2, #0xfe
 800059c: d251         	bhs	0x8000642 <__aeabi_fadd+0x136> @ imm = #0xa2
 800059e: f1b1 4f00    	cmp.w	r1, #0x80000000
 80005a2: eb40 50c2    	adc.w	r0, r0, r2, lsl #23
 80005a6: bf08         	it	eq
 80005a8: f020 0001    	biceq	r0, r0, #0x1
 80005ac: ea40 0003    	orr.w	r0, r0, r3
 80005b0: 4770         	bx	lr
 80005b2: 0049         	lsls	r1, r1, #0x1
 80005b4: eb40 0000    	adc.w	r0, r0, r0
 80005b8: 3a01         	subs	r2, #0x1
 80005ba: bf28         	it	hs
 80005bc: f5b0 0f00    	cmphs.w	r0, #0x800000
 80005c0: d2ed         	bhs	0x800059e <__aeabi_fadd+0x92> @ imm = #-0x26
 80005c2: fab0 fc80    	clz	r12, r0
 80005c6: f1ac 0c08    	sub.w	r12, r12, #0x8
 80005ca: ebb2 020c    	subs.w	r2, r2, r12
 80005ce: fa00 f00c    	lsl.w	r0, r0, r12
 80005d2: bfaa         	itet	ge
 80005d4: eb00 50c2    	addge.w	r0, r0, r2, lsl #23
 80005d8: 4252         	rsblt	r2, r2, #0
 80005da: 4318         	orrge	r0, r3
 80005dc: bfbc         	itt	lt
 80005de: 40d0         	lsrlt	r0, r2
 80005e0: 4318         	orrlt	r0, r3
 80005e2: 4770         	bx	lr
 80005e4: f092 0f00    	teq.w	r2, #0x0
 80005e8: f481 0100    	eor	r1, r1, #0x800000
 80005ec: bf06         	itte	eq
 80005ee: f480 0000    	eoreq	r0, r0, #0x800000
 80005f2: 3201         	addeq	r2, #0x1
 80005f4: 3b01         	subne	r3, #0x1
 80005f6: e7b5         	b	0x8000564 <__aeabi_fadd+0x58> @ imm = #-0x96
 80005f8: ea4f 0341    	lsl.w	r3, r1, #0x1
 80005fc: ea7f 6c22    	mvns.w	r12, r2, asr #24
 8000600: bf18         	it	ne
 8000602: ea7f 6c23    	mvnsne.w	r12, r3, asr #24
 8000606: d021         	beq	0x800064c <__aeabi_fadd+0x140> @ imm = #0x42
 8000608: ea92 0f03    	teq.w	r2, r3
 800060c: d004         	beq	0x8000618 <__aeabi_fadd+0x10c> @ imm = #0x8
 800060e: f092 0f00    	teq.w	r2, #0x0
 8000612: bf08         	it	eq
 8000614: 4608         	moveq	r0, r1
 8000616: 4770         	bx	lr
 8000618: ea90 0f01    	teq.w	r0, r1
 800061c: bf1c         	itt	ne
 800061e: 2000         	movne	r0, #0x0
 8000620: 4770         	bxne	lr
 8000622: f012 4f7f    	tst.w	r2, #0xff000000
 8000626: d104         	bne	0x8000632 <__aeabi_fadd+0x126> @ imm = #0x8
 8000628: 0040         	lsls	r0, r0, #0x1
 800062a: bf28         	it	hs
 800062c: f040 4000    	orrhs	r0, r0, #0x80000000
 8000630: 4770         	bx	lr
 8000632: f112 7200    	adds.w	r2, r2, #0x2000000
 8000636: bf3c         	itt	lo
 8000638: f500 0000    	addlo.w	r0, r0, #0x800000
 800063c: 4770         	bxlo	lr
 800063e: f000 4300    	and	r3, r0, #0x80000000
 8000642: f043 40fe    	orr	r0, r3, #0x7f000000
 8000646: f440 0000    	orr	r0, r0, #0x800000
 800064a: 4770         	bx	lr
 800064c: ea7f 6222    	mvns.w	r2, r2, asr #24
 8000650: bf16         	itet	ne
 8000652: 4608         	movne	r0, r1
 8000654: ea7f 6323    	mvnseq.w	r3, r3, asr #24
 8000658: 4601         	movne	r1, r0
 800065a: 0242         	lsls	r2, r0, #0x9
 800065c: bf06         	itte	eq
 800065e: ea5f 2341    	lslseq.w	r3, r1, #0x9
 8000662: ea90 0f01    	teqeq.w	r0, r1
 8000666: f440 0080    	orrne	r0, r0, #0x400000
 800066a: 4770         	bx	lr

0800066c <__floatunsisf>:
 800066c: f04f 0300    	mov.w	r3, #0x0
 8000670: e004         	b	0x800067c <__floatsisf+0x8> @ imm = #0x8
 8000672: bf00         	nop

08000674 <__floatsisf>:
 8000674: f010 4300    	ands	r3, r0, #0x80000000
 8000678: bf48         	it	mi
 800067a: 4240         	rsbmi	r0, r0, #0
 800067c: ea5f 0c00    	movs.w	r12, r0
 8000680: bf08         	it	eq
 8000682: 4770         	bxeq	lr
 8000684: f043 4396    	orr	r3, r3, #0x4b000000
 8000688: 4601         	mov	r1, r0
 800068a: f04f 0000    	mov.w	r0, #0x0
 800068e: e01c         	b	0x80006ca <__floatdisf+0x2a> @ imm = #0x38

08000690 <__floatundisf>:
 8000690: ea50 0201    	orrs.w	r2, r0, r1
 8000694: bf08         	it	eq
 8000696: 4770         	bxeq	lr
 8000698: f04f 0300    	mov.w	r3, #0x0
 800069c: e00a         	b	0x80006b4 <__floatdisf+0x14> @ imm = #0x14
 800069e: bf00         	nop

080006a0 <__floatdisf>:
 80006a0: ea50 0201    	orrs.w	r2, r0, r1
 80006a4: bf08         	it	eq
 80006a6: 4770         	bxeq	lr
 80006a8: f011 4300    	ands	r3, r1, #0x80000000
 80006ac: d502         	bpl	0x80006b4 <__floatdisf+0x14> @ imm = #0x4
 80006ae: 4240         	rsbs	r0, r0, #0
 80006b0: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80006b4: ea5f 0c01    	movs.w	r12, r1
 80006b8: bf02         	ittt	eq
 80006ba: 4684         	moveq	r12, r0
 80006bc: 4601         	moveq	r1, r0
 80006be: 2000         	moveq	r0, #0x0
 80006c0: f043 43b6    	orr	r3, r3, #0x5b000000
 80006c4: bf08         	it	eq
 80006c6: f1a3 5380    	subeq.w	r3, r3, #0x10000000
 80006ca: f5a3 0300    	sub.w	r3, r3, #0x800000
 80006ce: fabc f28c    	clz	r2, r12
 80006d2: 3a08         	subs	r2, #0x8
 80006d4: eba3 53c2    	sub.w	r3, r3, r2, lsl #23
 80006d8: db10         	blt	0x80006fc <__floatdisf+0x5c> @ imm = #0x20
 80006da: fa01 fc02    	lsl.w	r12, r1, r2
 80006de: 4463         	add	r3, r12
 80006e0: fa00 fc02    	lsl.w	r12, r0, r2
 80006e4: f1c2 0220    	rsb.w	r2, r2, #0x20
 80006e8: f1bc 4f00    	cmp.w	r12, #0x80000000
 80006ec: fa20 f202    	lsr.w	r2, r0, r2
 80006f0: eb43 0002    	adc.w	r0, r3, r2
 80006f4: bf08         	it	eq
 80006f6: f020 0001    	biceq	r0, r0, #0x1
 80006fa: 4770         	bx	lr
 80006fc: f102 0220    	add.w	r2, r2, #0x20
 8000700: fa01 fc02    	lsl.w	r12, r1, r2
 8000704: f1c2 0220    	rsb.w	r2, r2, #0x20
 8000708: ea50 004c    	orrs.w	r0, r0, r12, lsl #1
 800070c: fa21 f202    	lsr.w	r2, r1, r2
 8000710: eb43 0002    	adc.w	r0, r3, r2
 8000714: bf08         	it	eq
 8000716: ea20 70dc    	biceq.w	r0, r0, r12, lsr #31
 800071a: 4770         	bx	lr

0800071c <__mulsf3>:
 800071c: f04f 0cff    	mov.w	r12, #0xff
 8000720: ea1c 52d0    	ands.w	r2, r12, r0, lsr #23
 8000724: bf1e         	ittt	ne
 8000726: ea1c 53d1    	andsne.w	r3, r12, r1, lsr #23
 800072a: ea92 0f0c    	teqne.w	r2, r12
 800072e: ea93 0f0c    	teqne.w	r3, r12
 8000732: d06f         	beq	0x8000814 <__mulsf3+0xf8> @ imm = #0xde
 8000734: 441a         	add	r2, r3
 8000736: ea80 0c01    	eor.w	r12, r0, r1
 800073a: 0240         	lsls	r0, r0, #0x9
 800073c: bf18         	it	ne
 800073e: ea5f 2141    	lslsne.w	r1, r1, #0x9
 8000742: d01e         	beq	0x8000782 <__mulsf3+0x66> @ imm = #0x3c
 8000744: f04f 6300    	mov.w	r3, #0x8000000
 8000748: ea43 1050    	orr.w	r0, r3, r0, lsr #5
 800074c: ea43 1151    	orr.w	r1, r3, r1, lsr #5
 8000750: fba0 3101    	umull	r3, r1, r0, r1
 8000754: f00c 4000    	and	r0, r12, #0x80000000
 8000758: f5b1 0f00    	cmp.w	r1, #0x800000
 800075c: bf3e         	ittt	lo
 800075e: 0049         	lsllo	r1, r1, #0x1
 8000760: ea41 71d3    	orrlo.w	r1, r1, r3, lsr #31
 8000764: 005b         	lsllo	r3, r3, #0x1
 8000766: ea40 0001    	orr.w	r0, r0, r1
 800076a: f162 027f    	sbc	r2, r2, #0x7f
 800076e: 2afd         	cmp	r2, #0xfd
 8000770: d81d         	bhi	0x80007ae <__mulsf3+0x92> @ imm = #0x3a
 8000772: f1b3 4f00    	cmp.w	r3, #0x80000000
 8000776: eb40 50c2    	adc.w	r0, r0, r2, lsl #23
 800077a: bf08         	it	eq
 800077c: f020 0001    	biceq	r0, r0, #0x1
 8000780: 4770         	bx	lr
 8000782: f090 0f00    	teq.w	r0, #0x0
 8000786: f00c 4c00    	and	r12, r12, #0x80000000
 800078a: bf08         	it	eq
 800078c: 0249         	lsleq	r1, r1, #0x9
 800078e: ea4c 2050    	orr.w	r0, r12, r0, lsr #9
 8000792: ea40 2051    	orr.w	r0, r0, r1, lsr #9
 8000796: 3a7f         	subs	r2, #0x7f
 8000798: bfc2         	ittt	gt
 800079a: f1d2 03ff    	rsbsgt.w	r3, r2, #0xff
 800079e: ea40 50c2    	orrgt.w	r0, r0, r2, lsl #23
 80007a2: 4770         	bxgt	lr
 80007a4: f440 0000    	orr	r0, r0, #0x800000
 80007a8: f04f 0300    	mov.w	r3, #0x0
 80007ac: 3a01         	subs	r2, #0x1
 80007ae: dc5d         	bgt	0x800086c <__mulsf3+0x150> @ imm = #0xba
 80007b0: f112 0f19    	cmn.w	r2, #0x19
 80007b4: bfdc         	itt	le
 80007b6: f000 4000    	andle	r0, r0, #0x80000000
 80007ba: 4770         	bxle	lr
 80007bc: f1c2 0200    	rsb.w	r2, r2, #0x0
 80007c0: 0041         	lsls	r1, r0, #0x1
 80007c2: fa21 f102    	lsr.w	r1, r1, r2
 80007c6: f1c2 0220    	rsb.w	r2, r2, #0x20
 80007ca: fa00 fc02    	lsl.w	r12, r0, r2
 80007ce: ea5f 0031    	rrxs	r0, r1
 80007d2: f140 0000    	adc	r0, r0, #0x0
 80007d6: ea53 034c    	orrs.w	r3, r3, r12, lsl #1
 80007da: bf08         	it	eq
 80007dc: ea20 70dc    	biceq.w	r0, r0, r12, lsr #31
 80007e0: 4770         	bx	lr
 80007e2: f092 0f00    	teq.w	r2, #0x0
 80007e6: f000 4c00    	and	r12, r0, #0x80000000
 80007ea: bf02         	ittt	eq
 80007ec: 0040         	lsleq	r0, r0, #0x1
 80007ee: f410 0f00    	tsteq.w	r0, #0x800000
 80007f2: 3a01         	subeq	r2, #0x1
 80007f4: d0f9         	beq	0x80007ea <__mulsf3+0xce> @ imm = #-0xe
 80007f6: ea40 000c    	orr.w	r0, r0, r12
 80007fa: f093 0f00    	teq.w	r3, #0x0
 80007fe: f001 4c00    	and	r12, r1, #0x80000000
 8000802: bf02         	ittt	eq
 8000804: 0049         	lsleq	r1, r1, #0x1
 8000806: f411 0f00    	tsteq.w	r1, #0x800000
 800080a: 3b01         	subeq	r3, #0x1
 800080c: d0f9         	beq	0x8000802 <__mulsf3+0xe6> @ imm = #-0xe
 800080e: ea41 010c    	orr.w	r1, r1, r12
 8000812: e78f         	b	0x8000734 <__mulsf3+0x18> @ imm = #-0xe2
 8000814: ea0c 53d1    	and.w	r3, r12, r1, lsr #23
 8000818: ea92 0f0c    	teq.w	r2, r12
 800081c: bf18         	it	ne
 800081e: ea93 0f0c    	teqne.w	r3, r12
 8000822: d00a         	beq	0x800083a <__mulsf3+0x11e> @ imm = #0x14
 8000824: f030 4c00    	bics	r12, r0, #0x80000000
 8000828: bf18         	it	ne
 800082a: f031 4c00    	bicsne	r12, r1, #0x80000000
 800082e: d1d8         	bne	0x80007e2 <__mulsf3+0xc6> @ imm = #-0x50
 8000830: ea80 0001    	eor.w	r0, r0, r1
 8000834: f000 4000    	and	r0, r0, #0x80000000
 8000838: 4770         	bx	lr
 800083a: f090 0f00    	teq.w	r0, #0x0
 800083e: bf17         	itett	ne
 8000840: f090 4f00    	teqne.w	r0, #0x80000000
 8000844: 4608         	moveq	r0, r1
 8000846: f091 0f00    	teqne.w	r1, #0x0
 800084a: f091 4f00    	teqne.w	r1, #0x80000000
 800084e: d014         	beq	0x800087a <__mulsf3+0x15e> @ imm = #0x28
 8000850: ea92 0f0c    	teq.w	r2, r12
 8000854: d101         	bne	0x800085a <__mulsf3+0x13e> @ imm = #0x2
 8000856: 0242         	lsls	r2, r0, #0x9
 8000858: d10f         	bne	0x800087a <__mulsf3+0x15e> @ imm = #0x1e
 800085a: ea93 0f0c    	teq.w	r3, r12
 800085e: d103         	bne	0x8000868 <__mulsf3+0x14c> @ imm = #0x6
 8000860: 024b         	lsls	r3, r1, #0x9
 8000862: bf18         	it	ne
 8000864: 4608         	movne	r0, r1
 8000866: d108         	bne	0x800087a <__mulsf3+0x15e> @ imm = #0x10
 8000868: ea80 0001    	eor.w	r0, r0, r1
 800086c: f000 4000    	and	r0, r0, #0x80000000
 8000870: f040 40fe    	orr	r0, r0, #0x7f000000
 8000874: f440 0000    	orr	r0, r0, #0x800000
 8000878: 4770         	bx	lr
 800087a: f040 40fe    	orr	r0, r0, #0x7f000000
 800087e: f440 0040    	orr	r0, r0, #0xc00000
 8000882: 4770         	bx	lr

08000884 <__divsf3>:
 8000884: f04f 0cff    	mov.w	r12, #0xff
 8000888: ea1c 52d0    	ands.w	r2, r12, r0, lsr #23
 800088c: bf1e         	ittt	ne
 800088e: ea1c 53d1    	andsne.w	r3, r12, r1, lsr #23
 8000892: ea92 0f0c    	teqne.w	r2, r12
 8000896: ea93 0f0c    	teqne.w	r3, r12
 800089a: d069         	beq	0x8000970 <__divsf3+0xec> @ imm = #0xd2
 800089c: eba2 0203    	sub.w	r2, r2, r3
 80008a0: ea80 0c01    	eor.w	r12, r0, r1
 80008a4: 0249         	lsls	r1, r1, #0x9
 80008a6: ea4f 2040    	lsl.w	r0, r0, #0x9
 80008aa: d037         	beq	0x800091c <__divsf3+0x98> @ imm = #0x6e
 80008ac: f04f 5380    	mov.w	r3, #0x10000000
 80008b0: ea43 1111    	orr.w	r1, r3, r1, lsr #4
 80008b4: ea43 1310    	orr.w	r3, r3, r0, lsr #4
 80008b8: f00c 4000    	and	r0, r12, #0x80000000
 80008bc: 428b         	cmp	r3, r1
 80008be: bf38         	it	lo
 80008c0: 005b         	lsllo	r3, r3, #0x1
 80008c2: f142 027d    	adc	r2, r2, #0x7d
 80008c6: f44f 0c00    	mov.w	r12, #0x800000
 80008ca: 428b         	cmp	r3, r1
 80008cc: bf24         	itt	hs
 80008ce: 1a5b         	subhs	r3, r3, r1
 80008d0: ea40 000c    	orrhs.w	r0, r0, r12
 80008d4: ebb3 0f51    	cmp.w	r3, r1, lsr #1
 80008d8: bf24         	itt	hs
 80008da: eba3 0351    	subhs.w	r3, r3, r1, lsr #1
 80008de: ea40 005c    	orrhs.w	r0, r0, r12, lsr #1
 80008e2: ebb3 0f91    	cmp.w	r3, r1, lsr #2
 80008e6: bf24         	itt	hs
 80008e8: eba3 0391    	subhs.w	r3, r3, r1, lsr #2
 80008ec: ea40 009c    	orrhs.w	r0, r0, r12, lsr #2
 80008f0: ebb3 0fd1    	cmp.w	r3, r1, lsr #3
 80008f4: bf24         	itt	hs
 80008f6: eba3 03d1    	subhs.w	r3, r3, r1, lsr #3
 80008fa: ea40 00dc    	orrhs.w	r0, r0, r12, lsr #3
 80008fe: 011b         	lsls	r3, r3, #0x4
 8000900: bf18         	it	ne
 8000902: ea5f 1c1c    	lsrsne.w	r12, r12, #0x4
 8000906: d1e0         	bne	0x80008ca <__divsf3+0x46> @ imm = #-0x40
 8000908: 2afd         	cmp	r2, #0xfd
 800090a: f63f af50    	bhi.w	0x80007ae <__mulsf3+0x92> @ imm = #-0x160
 800090e: 428b         	cmp	r3, r1
 8000910: eb40 50c2    	adc.w	r0, r0, r2, lsl #23
 8000914: bf08         	it	eq
 8000916: f020 0001    	biceq	r0, r0, #0x1
 800091a: 4770         	bx	lr
 800091c: f00c 4c00    	and	r12, r12, #0x80000000
 8000920: ea4c 2050    	orr.w	r0, r12, r0, lsr #9
 8000924: 327f         	adds	r2, #0x7f
 8000926: bfc2         	ittt	gt
 8000928: f1d2 03ff    	rsbsgt.w	r3, r2, #0xff
 800092c: ea40 50c2    	orrgt.w	r0, r0, r2, lsl #23
 8000930: 4770         	bxgt	lr
 8000932: f440 0000    	orr	r0, r0, #0x800000
 8000936: f04f 0300    	mov.w	r3, #0x0
 800093a: 3a01         	subs	r2, #0x1
 800093c: e737         	b	0x80007ae <__mulsf3+0x92> @ imm = #-0x192
 800093e: f092 0f00    	teq.w	r2, #0x0
 8000942: f000 4c00    	and	r12, r0, #0x80000000
 8000946: bf02         	ittt	eq
 8000948: 0040         	lsleq	r0, r0, #0x1
 800094a: f410 0f00    	tsteq.w	r0, #0x800000
 800094e: 3a01         	subeq	r2, #0x1
 8000950: d0f9         	beq	0x8000946 <__divsf3+0xc2> @ imm = #-0xe
 8000952: ea40 000c    	orr.w	r0, r0, r12
 8000956: f093 0f00    	teq.w	r3, #0x0
 800095a: f001 4c00    	and	r12, r1, #0x80000000
 800095e: bf02         	ittt	eq
 8000960: 0049         	lsleq	r1, r1, #0x1
 8000962: f411 0f00    	tsteq.w	r1, #0x800000
 8000966: 3b01         	subeq	r3, #0x1
 8000968: d0f9         	beq	0x800095e <__divsf3+0xda> @ imm = #-0xe
 800096a: ea41 010c    	orr.w	r1, r1, r12
 800096e: e795         	b	0x800089c <__divsf3+0x18> @ imm = #-0xd6
 8000970: ea0c 53d1    	and.w	r3, r12, r1, lsr #23
 8000974: ea92 0f0c    	teq.w	r2, r12
 8000978: d108         	bne	0x800098c <__divsf3+0x108> @ imm = #0x10
 800097a: 0242         	lsls	r2, r0, #0x9
 800097c: f47f af7d    	bne.w	0x800087a <__mulsf3+0x15e> @ imm = #-0x106
 8000980: ea93 0f0c    	teq.w	r3, r12
 8000984: f47f af70    	bne.w	0x8000868 <__mulsf3+0x14c> @ imm = #-0x120
 8000988: 4608         	mov	r0, r1
 800098a: e776         	b	0x800087a <__mulsf3+0x15e> @ imm = #-0x114
 800098c: ea93 0f0c    	teq.w	r3, r12
 8000990: d104         	bne	0x800099c <__divsf3+0x118> @ imm = #0x8
 8000992: 024b         	lsls	r3, r1, #0x9
 8000994: f43f af4c    	beq.w	0x8000830 <__mulsf3+0x114> @ imm = #-0x168
 8000998: 4608         	mov	r0, r1
 800099a: e76e         	b	0x800087a <__mulsf3+0x15e> @ imm = #-0x124
 800099c: f030 4c00    	bics	r12, r0, #0x80000000
 80009a0: bf18         	it	ne
 80009a2: f031 4c00    	bicsne	r12, r1, #0x80000000
 80009a6: d1ca         	bne	0x800093e <__divsf3+0xba> @ imm = #-0x6c
 80009a8: f030 4200    	bics	r2, r0, #0x80000000
 80009ac: f47f af5c    	bne.w	0x8000868 <__mulsf3+0x14c> @ imm = #-0x148
 80009b0: f031 4300    	bics	r3, r1, #0x80000000
 80009b4: f47f af3c    	bne.w	0x8000830 <__mulsf3+0x114> @ imm = #-0x188
 80009b8: e75f         	b	0x800087a <__mulsf3+0x15e> @ imm = #-0x142
 80009ba: bf00         	nop

080009bc <__gtsf2>:
 80009bc: f04f 3cff    	mov.w	r12, #0xffffffff
 80009c0: e006         	b	0x80009d0 <__nesf2+0x4> @ imm = #0xc
 80009c2: bf00         	nop

080009c4 <__ltsf2>:
 80009c4: f04f 0c01    	mov.w	r12, #0x1
 80009c8: e002         	b	0x80009d0 <__nesf2+0x4> @ imm = #0x4
 80009ca: bf00         	nop

080009cc <__nesf2>:
 80009cc: f04f 0c01    	mov.w	r12, #0x1
 80009d0: f84d cd04    	str	r12, [sp, #-4]!
 80009d4: ea4f 0240    	lsl.w	r2, r0, #0x1
 80009d8: ea4f 0341    	lsl.w	r3, r1, #0x1
 80009dc: ea7f 6c22    	mvns.w	r12, r2, asr #24
 80009e0: bf18         	it	ne
 80009e2: ea7f 6c23    	mvnsne.w	r12, r3, asr #24
 80009e6: d011         	beq	0x8000a0c <__nesf2+0x40> @ imm = #0x22
 80009e8: b001         	add	sp, #0x4
 80009ea: ea52 0c53    	orrs.w	r12, r2, r3, lsr #1
 80009ee: bf18         	it	ne
 80009f0: ea90 0f01    	teqne.w	r0, r1
 80009f4: bf58         	it	pl
 80009f6: ebb2 0003    	subspl.w	r0, r2, r3
 80009fa: bf88         	it	hi
 80009fc: 17c8         	asrhi	r0, r1, #0x1f
 80009fe: bf38         	it	lo
 8000a00: ea6f 70e1    	mvnlo.w	r0, r1, asr #31
 8000a04: bf18         	it	ne
 8000a06: f040 0001    	orrne	r0, r0, #0x1
 8000a0a: 4770         	bx	lr
 8000a0c: ea7f 6c22    	mvns.w	r12, r2, asr #24
 8000a10: d102         	bne	0x8000a18 <__nesf2+0x4c> @ imm = #0x4
 8000a12: ea5f 2c40    	lsls.w	r12, r0, #0x9
 8000a16: d105         	bne	0x8000a24 <__nesf2+0x58> @ imm = #0xa
 8000a18: ea7f 6c23    	mvns.w	r12, r3, asr #24
 8000a1c: d1e4         	bne	0x80009e8 <__nesf2+0x1c> @ imm = #-0x38
 8000a1e: ea5f 2c41    	lsls.w	r12, r1, #0x9
 8000a22: d0e1         	beq	0x80009e8 <__nesf2+0x1c> @ imm = #-0x3e
 8000a24: f85d 0b04    	ldr	r0, [sp], #4
 8000a28: 4770         	bx	lr
 8000a2a: bf00         	nop

08000a2c <__aeabi_cfrcmple>:
 8000a2c: 4684         	mov	r12, r0
 8000a2e: 4608         	mov	r0, r1
 8000a30: 4661         	mov	r1, r12
 8000a32: e7ff         	b	0x8000a34 <__aeabi_cfcmple> @ imm = #-0x2

08000a34 <__aeabi_cfcmple>:
 8000a34: b50f         	push	{r0, r1, r2, r3, lr}
 8000a36: f7ff ffc9    	bl	0x80009cc <__nesf2>     @ imm = #-0x6e
 8000a3a: 2800         	cmp	r0, #0x0
 8000a3c: bf48         	it	mi
 8000a3e: f110 0f00    	cmnmi.w	r0, #0x0
 8000a42: bd0f         	pop	{r0, r1, r2, r3, pc}

08000a44 <__aeabi_fcmpeq>:
 8000a44: f84d ed08    	str	lr, [sp, #-8]!
 8000a48: f7ff fff4    	bl	0x8000a34 <__aeabi_cfcmple> @ imm = #-0x18
 8000a4c: bf0c         	ite	eq
 8000a4e: 2001         	moveq	r0, #0x1
 8000a50: 2000         	movne	r0, #0x0
 8000a52: f85d fb08    	ldr	pc, [sp], #8
 8000a56: bf00         	nop

08000a58 <__aeabi_fcmplt>:
 8000a58: f84d ed08    	str	lr, [sp, #-8]!
 8000a5c: f7ff ffea    	bl	0x8000a34 <__aeabi_cfcmple> @ imm = #-0x2c
 8000a60: bf34         	ite	lo
 8000a62: 2001         	movlo	r0, #0x1
 8000a64: 2000         	movhs	r0, #0x0
 8000a66: f85d fb08    	ldr	pc, [sp], #8
 8000a6a: bf00         	nop

08000a6c <__aeabi_fcmple>:
 8000a6c: f84d ed08    	str	lr, [sp, #-8]!
 8000a70: f7ff ffe0    	bl	0x8000a34 <__aeabi_cfcmple> @ imm = #-0x40
 8000a74: bf94         	ite	ls
 8000a76: 2001         	movls	r0, #0x1
 8000a78: 2000         	movhi	r0, #0x0
 8000a7a: f85d fb08    	ldr	pc, [sp], #8
 8000a7e: bf00         	nop

08000a80 <__aeabi_fcmpge>:
 8000a80: f84d ed08    	str	lr, [sp, #-8]!
 8000a84: f7ff ffd2    	bl	0x8000a2c <__aeabi_cfrcmple> @ imm = #-0x5c
 8000a88: bf94         	ite	ls
 8000a8a: 2001         	movls	r0, #0x1
 8000a8c: 2000         	movhi	r0, #0x0
 8000a8e: f85d fb08    	ldr	pc, [sp], #8
 8000a92: bf00         	nop

08000a94 <__aeabi_fcmpgt>:
 8000a94: f84d ed08    	str	lr, [sp, #-8]!
 8000a98: f7ff ffc8    	bl	0x8000a2c <__aeabi_cfrcmple> @ imm = #-0x70
 8000a9c: bf34         	ite	lo
 8000a9e: 2001         	movlo	r0, #0x1
 8000aa0: 2000         	movhs	r0, #0x0
 8000aa2: f85d fb08    	ldr	pc, [sp], #8
 8000aa6: bf00         	nop

08000aa8 <__fixsfsi>:
 8000aa8: ea4f 0240    	lsl.w	r2, r0, #0x1
 8000aac: f1b2 4ffe    	cmp.w	r2, #0x7f000000
 8000ab0: d30f         	blo	0x8000ad2 <__fixsfsi+0x2a> @ imm = #0x1e
 8000ab2: f04f 039e    	mov.w	r3, #0x9e
 8000ab6: ebb3 6212    	subs.w	r2, r3, r2, lsr #24
 8000aba: d90d         	bls	0x8000ad8 <__fixsfsi+0x30> @ imm = #0x1a
 8000abc: ea4f 2300    	lsl.w	r3, r0, #0x8
 8000ac0: f043 4300    	orr	r3, r3, #0x80000000
 8000ac4: f010 4f00    	tst.w	r0, #0x80000000
 8000ac8: fa23 f002    	lsr.w	r0, r3, r2
 8000acc: bf18         	it	ne
 8000ace: 4240         	rsbne	r0, r0, #0
 8000ad0: 4770         	bx	lr
 8000ad2: f04f 0000    	mov.w	r0, #0x0
 8000ad6: 4770         	bx	lr
 8000ad8: f112 0f61    	cmn.w	r2, #0x61
 8000adc: d101         	bne	0x8000ae2 <__fixsfsi+0x3a> @ imm = #0x2
 8000ade: 0242         	lsls	r2, r0, #0x9
 8000ae0: d105         	bne	0x8000aee <__fixsfsi+0x46> @ imm = #0xa
 8000ae2: f010 4000    	ands	r0, r0, #0x80000000
 8000ae6: bf08         	it	eq
 8000ae8: f06f 4000    	mvneq	r0, #0x80000000
 8000aec: 4770         	bx	lr
 8000aee: f04f 0000    	mov.w	r0, #0x0
 8000af2: 4770         	bx	lr

08000af4 <__aeabi_uldivmod>:
 8000af4: b953         	cbnz	r3, 0x8000b0c <__aeabi_uldivmod+0x18> @ imm = #0x14
 8000af6: b94a         	cbnz	r2, 0x8000b0c <__aeabi_uldivmod+0x18> @ imm = #0x12
 8000af8: 2900         	cmp	r1, #0x0
 8000afa: bf08         	it	eq
 8000afc: 2800         	cmpeq	r0, #0x0
 8000afe: bf1c         	itt	ne
 8000b00: f04f 31ff    	movne.w	r1, #0xffffffff
 8000b04: f04f 30ff    	movne.w	r0, #0xffffffff
 8000b08: f000 b80c    	b.w	0x8000b24 <__aeabi_ldiv0> @ imm = #0x18
 8000b0c: f1ad 0c08    	sub.w	r12, sp, #0x8
 8000b10: e96d ce04    	strd	r12, lr, [sp, #-16]!
 8000b14: f000 f81a    	bl	0x8000b4c <__udivmoddi4> @ imm = #0x34
 8000b18: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000b1c: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 8000b20: b004         	add	sp, #0x10
 8000b22: 4770         	bx	lr

08000b24 <__aeabi_ldiv0>:
 8000b24: 4770         	bx	lr
 8000b26: bf00         	nop

08000b28 <strcmp>:
 8000b28: f810 2b01    	ldrb	r2, [r0], #1
 8000b2c: f811 3b01    	ldrb	r3, [r1], #1
 8000b30: 2a01         	cmp	r2, #0x1
 8000b32: bf28         	it	hs
 8000b34: 429a         	cmphs	r2, r3
 8000b36: d0f7         	beq	0x8000b28 <strcmp>      @ imm = #-0x12
 8000b38: 1ad0         	subs	r0, r2, r3
 8000b3a: 4770         	bx	lr

08000b3c <strlen>:
 8000b3c: 4603         	mov	r3, r0
 8000b3e: f813 2b01    	ldrb	r2, [r3], #1
 8000b42: 2a00         	cmp	r2, #0x0
 8000b44: d1fb         	bne	0x8000b3e <strlen+0x2>  @ imm = #-0xa
 8000b46: 1a18         	subs	r0, r3, r0
 8000b48: 3801         	subs	r0, #0x1
 8000b4a: 4770         	bx	lr

08000b4c <__udivmoddi4>:
 8000b4c: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 8000b50: 4686         	mov	lr, r0
 8000b52: 468c         	mov	r12, r1
 8000b54: 4608         	mov	r0, r1
 8000b56: 9e08         	ldr	r6, [sp, #0x20]
 8000b58: 4615         	mov	r5, r2
 8000b5a: 4674         	mov	r4, lr
 8000b5c: 4619         	mov	r1, r3
 8000b5e: 2b00         	cmp	r3, #0x0
 8000b60: f040 80c2    	bne.w	0x8000ce8 <__udivmoddi4+0x19c> @ imm = #0x184
 8000b64: 4285         	cmp	r5, r0
 8000b66: fab2 f282    	clz	r2, r2
 8000b6a: d945         	bls	0x8000bf8 <__udivmoddi4+0xac> @ imm = #0x8a
 8000b6c: b14a         	cbz	r2, 0x8000b82 <__udivmoddi4+0x36> @ imm = #0x12
 8000b6e: f1c2 0320    	rsb.w	r3, r2, #0x20
 8000b72: fa00 fc02    	lsl.w	r12, r0, r2
 8000b76: fa2e f303    	lsr.w	r3, lr, r3
 8000b7a: 4095         	lsls	r5, r2
 8000b7c: ea43 0c0c    	orr.w	r12, r3, r12
 8000b80: 4094         	lsls	r4, r2
 8000b82: ea4f 4e15    	lsr.w	lr, r5, #0x10
 8000b86: b2a8         	uxth	r0, r5
 8000b88: fbbc f8fe    	udiv	r8, r12, lr
 8000b8c: 0c23         	lsrs	r3, r4, #0x10
 8000b8e: fb0e cc18    	mls	r12, lr, r8, r12
 8000b92: fb08 f900    	mul	r9, r8, r0
 8000b96: ea43 430c    	orr.w	r3, r3, r12, lsl #16
 8000b9a: 4599         	cmp	r9, r3
 8000b9c: d928         	bls	0x8000bf0 <__udivmoddi4+0xa4> @ imm = #0x50
 8000b9e: 18eb         	adds	r3, r5, r3
 8000ba0: f108 37ff    	add.w	r7, r8, #0xffffffff
 8000ba4: d204         	bhs	0x8000bb0 <__udivmoddi4+0x64> @ imm = #0x8
 8000ba6: 4599         	cmp	r9, r3
 8000ba8: d902         	bls	0x8000bb0 <__udivmoddi4+0x64> @ imm = #0x4
 8000baa: f1a8 0702    	sub.w	r7, r8, #0x2
 8000bae: 442b         	add	r3, r5
 8000bb0: eba3 0309    	sub.w	r3, r3, r9
 8000bb4: b2a4         	uxth	r4, r4
 8000bb6: fbb3 fcfe    	udiv	r12, r3, lr
 8000bba: fb0e 331c    	mls	r3, lr, r12, r3
 8000bbe: fb0c f000    	mul	r0, r12, r0
 8000bc2: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 8000bc6: 42a0         	cmp	r0, r4
 8000bc8: d914         	bls	0x8000bf4 <__udivmoddi4+0xa8> @ imm = #0x28
 8000bca: 192c         	adds	r4, r5, r4
 8000bcc: f10c 33ff    	add.w	r3, r12, #0xffffffff
 8000bd0: d204         	bhs	0x8000bdc <__udivmoddi4+0x90> @ imm = #0x8
 8000bd2: 42a0         	cmp	r0, r4
 8000bd4: d902         	bls	0x8000bdc <__udivmoddi4+0x90> @ imm = #0x4
 8000bd6: f1ac 0302    	sub.w	r3, r12, #0x2
 8000bda: 442c         	add	r4, r5
 8000bdc: 1a24         	subs	r4, r4, r0
 8000bde: ea43 4007    	orr.w	r0, r3, r7, lsl #16
 8000be2: b11e         	cbz	r6, 0x8000bec <__udivmoddi4+0xa0> @ imm = #0x6
 8000be4: 40d4         	lsrs	r4, r2
 8000be6: 2300         	movs	r3, #0x0
 8000be8: 6034         	str	r4, [r6]
 8000bea: 6073         	str	r3, [r6, #0x4]
 8000bec: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}
 8000bf0: 4647         	mov	r7, r8
 8000bf2: e7dd         	b	0x8000bb0 <__udivmoddi4+0x64> @ imm = #-0x46
 8000bf4: 4663         	mov	r3, r12
 8000bf6: e7f1         	b	0x8000bdc <__udivmoddi4+0x90> @ imm = #-0x1e
 8000bf8: bb92         	cbnz	r2, 0x8000c60 <__udivmoddi4+0x114> @ imm = #0x64
 8000bfa: 1b43         	subs	r3, r0, r5
 8000bfc: 2101         	movs	r1, #0x1
 8000bfe: ea4f 4e15    	lsr.w	lr, r5, #0x10
 8000c02: b2af         	uxth	r7, r5
 8000c04: fbb3 fcfe    	udiv	r12, r3, lr
 8000c08: 0c20         	lsrs	r0, r4, #0x10
 8000c0a: fb0e 331c    	mls	r3, lr, r12, r3
 8000c0e: fb0c f807    	mul	r8, r12, r7
 8000c12: ea40 4303    	orr.w	r3, r0, r3, lsl #16
 8000c16: 4598         	cmp	r8, r3
 8000c18: d962         	bls	0x8000ce0 <__udivmoddi4+0x194> @ imm = #0xc4
 8000c1a: 18eb         	adds	r3, r5, r3
 8000c1c: f10c 30ff    	add.w	r0, r12, #0xffffffff
 8000c20: d204         	bhs	0x8000c2c <__udivmoddi4+0xe0> @ imm = #0x8
 8000c22: 4598         	cmp	r8, r3
 8000c24: d902         	bls	0x8000c2c <__udivmoddi4+0xe0> @ imm = #0x4
 8000c26: f1ac 0002    	sub.w	r0, r12, #0x2
 8000c2a: 442b         	add	r3, r5
 8000c2c: eba3 0308    	sub.w	r3, r3, r8
 8000c30: b2a4         	uxth	r4, r4
 8000c32: fbb3 fcfe    	udiv	r12, r3, lr
 8000c36: fb0e 331c    	mls	r3, lr, r12, r3
 8000c3a: fb0c f707    	mul	r7, r12, r7
 8000c3e: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 8000c42: 42a7         	cmp	r7, r4
 8000c44: d94e         	bls	0x8000ce4 <__udivmoddi4+0x198> @ imm = #0x9c
 8000c46: 192c         	adds	r4, r5, r4
 8000c48: f10c 33ff    	add.w	r3, r12, #0xffffffff
 8000c4c: d204         	bhs	0x8000c58 <__udivmoddi4+0x10c> @ imm = #0x8
 8000c4e: 42a7         	cmp	r7, r4
 8000c50: d902         	bls	0x8000c58 <__udivmoddi4+0x10c> @ imm = #0x4
 8000c52: f1ac 0302    	sub.w	r3, r12, #0x2
 8000c56: 442c         	add	r4, r5
 8000c58: 1be4         	subs	r4, r4, r7
 8000c5a: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 8000c5e: e7c0         	b	0x8000be2 <__udivmoddi4+0x96> @ imm = #-0x80
 8000c60: f1c2 0320    	rsb.w	r3, r2, #0x20
 8000c64: fa20 f103    	lsr.w	r1, r0, r3
 8000c68: 4095         	lsls	r5, r2
 8000c6a: 4090         	lsls	r0, r2
 8000c6c: fa2e f303    	lsr.w	r3, lr, r3
 8000c70: 4303         	orrs	r3, r0
 8000c72: ea4f 4e15    	lsr.w	lr, r5, #0x10
 8000c76: b2af         	uxth	r7, r5
 8000c78: fbb1 fcfe    	udiv	r12, r1, lr
 8000c7c: fb0e 101c    	mls	r0, lr, r12, r1
 8000c80: 0c19         	lsrs	r1, r3, #0x10
 8000c82: fb0c f807    	mul	r8, r12, r7
 8000c86: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 8000c8a: 4588         	cmp	r8, r1
 8000c8c: fa04 f402    	lsl.w	r4, r4, r2
 8000c90: d922         	bls	0x8000cd8 <__udivmoddi4+0x18c> @ imm = #0x44
 8000c92: 1869         	adds	r1, r5, r1
 8000c94: f10c 30ff    	add.w	r0, r12, #0xffffffff
 8000c98: d204         	bhs	0x8000ca4 <__udivmoddi4+0x158> @ imm = #0x8
 8000c9a: 4588         	cmp	r8, r1
 8000c9c: d902         	bls	0x8000ca4 <__udivmoddi4+0x158> @ imm = #0x4
 8000c9e: f1ac 0002    	sub.w	r0, r12, #0x2
 8000ca2: 4429         	add	r1, r5
 8000ca4: eba1 0108    	sub.w	r1, r1, r8
 8000ca8: b29b         	uxth	r3, r3
 8000caa: fbb1 fcfe    	udiv	r12, r1, lr
 8000cae: fb0e 111c    	mls	r1, lr, r12, r1
 8000cb2: fb0c f707    	mul	r7, r12, r7
 8000cb6: ea43 4301    	orr.w	r3, r3, r1, lsl #16
 8000cba: 429f         	cmp	r7, r3
 8000cbc: d90e         	bls	0x8000cdc <__udivmoddi4+0x190> @ imm = #0x1c
 8000cbe: 18eb         	adds	r3, r5, r3
 8000cc0: f10c 31ff    	add.w	r1, r12, #0xffffffff
 8000cc4: d204         	bhs	0x8000cd0 <__udivmoddi4+0x184> @ imm = #0x8
 8000cc6: 429f         	cmp	r7, r3
 8000cc8: d902         	bls	0x8000cd0 <__udivmoddi4+0x184> @ imm = #0x4
 8000cca: f1ac 0102    	sub.w	r1, r12, #0x2
 8000cce: 442b         	add	r3, r5
 8000cd0: 1bdb         	subs	r3, r3, r7
 8000cd2: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 8000cd6: e792         	b	0x8000bfe <__udivmoddi4+0xb2> @ imm = #-0xdc
 8000cd8: 4660         	mov	r0, r12
 8000cda: e7e3         	b	0x8000ca4 <__udivmoddi4+0x158> @ imm = #-0x3a
 8000cdc: 4661         	mov	r1, r12
 8000cde: e7f7         	b	0x8000cd0 <__udivmoddi4+0x184> @ imm = #-0x12
 8000ce0: 4660         	mov	r0, r12
 8000ce2: e7a3         	b	0x8000c2c <__udivmoddi4+0xe0> @ imm = #-0xba
 8000ce4: 4663         	mov	r3, r12
 8000ce6: e7b7         	b	0x8000c58 <__udivmoddi4+0x10c> @ imm = #-0x92
 8000ce8: 4283         	cmp	r3, r0
 8000cea: d906         	bls	0x8000cfa <__udivmoddi4+0x1ae> @ imm = #0xc
 8000cec: b916         	cbnz	r6, 0x8000cf4 <__udivmoddi4+0x1a8> @ imm = #0x4
 8000cee: 2100         	movs	r1, #0x0
 8000cf0: 4608         	mov	r0, r1
 8000cf2: e77b         	b	0x8000bec <__udivmoddi4+0xa0> @ imm = #-0x10a
 8000cf4: e9c6 e000    	strd	lr, r0, [r6]
 8000cf8: e7f9         	b	0x8000cee <__udivmoddi4+0x1a2> @ imm = #-0xe
 8000cfa: fab3 f783    	clz	r7, r3
 8000cfe: b98f         	cbnz	r7, 0x8000d24 <__udivmoddi4+0x1d8> @ imm = #0x22
 8000d00: 4283         	cmp	r3, r0
 8000d02: d301         	blo	0x8000d08 <__udivmoddi4+0x1bc> @ imm = #0x2
 8000d04: 4572         	cmp	r2, lr
 8000d06: d808         	bhi	0x8000d1a <__udivmoddi4+0x1ce> @ imm = #0x10
 8000d08: ebbe 0402    	subs.w	r4, lr, r2
 8000d0c: eb60 0303    	sbc.w	r3, r0, r3
 8000d10: 2001         	movs	r0, #0x1
 8000d12: 469c         	mov	r12, r3
 8000d14: b91e         	cbnz	r6, 0x8000d1e <__udivmoddi4+0x1d2> @ imm = #0x6
 8000d16: 2100         	movs	r1, #0x0
 8000d18: e768         	b	0x8000bec <__udivmoddi4+0xa0> @ imm = #-0x130
 8000d1a: 4638         	mov	r0, r7
 8000d1c: e7fa         	b	0x8000d14 <__udivmoddi4+0x1c8> @ imm = #-0xc
 8000d1e: e9c6 4c00    	strd	r4, r12, [r6]
 8000d22: e7f8         	b	0x8000d16 <__udivmoddi4+0x1ca> @ imm = #-0x10
 8000d24: f1c7 0c20    	rsb.w	r12, r7, #0x20
 8000d28: 40bb         	lsls	r3, r7
 8000d2a: fa22 f40c    	lsr.w	r4, r2, r12
 8000d2e: 431c         	orrs	r4, r3
 8000d30: fa2e f10c    	lsr.w	r1, lr, r12
 8000d34: fa20 f30c    	lsr.w	r3, r0, r12
 8000d38: 40b8         	lsls	r0, r7
 8000d3a: 4301         	orrs	r1, r0
 8000d3c: ea4f 4914    	lsr.w	r9, r4, #0x10
 8000d40: fa0e f507    	lsl.w	r5, lr, r7
 8000d44: fbb3 f8f9    	udiv	r8, r3, r9
 8000d48: fa1f fe84    	uxth.w	lr, r4
 8000d4c: fb09 3018    	mls	r0, r9, r8, r3
 8000d50: 0c0b         	lsrs	r3, r1, #0x10
 8000d52: fb08 fa0e    	mul	r10, r8, lr
 8000d56: ea43 4300    	orr.w	r3, r3, r0, lsl #16
 8000d5a: 459a         	cmp	r10, r3
 8000d5c: fa02 f207    	lsl.w	r2, r2, r7
 8000d60: d940         	bls	0x8000de4 <__udivmoddi4+0x298> @ imm = #0x80
 8000d62: 18e3         	adds	r3, r4, r3
 8000d64: f108 30ff    	add.w	r0, r8, #0xffffffff
 8000d68: d204         	bhs	0x8000d74 <__udivmoddi4+0x228> @ imm = #0x8
 8000d6a: 459a         	cmp	r10, r3
 8000d6c: d902         	bls	0x8000d74 <__udivmoddi4+0x228> @ imm = #0x4
 8000d6e: f1a8 0002    	sub.w	r0, r8, #0x2
 8000d72: 4423         	add	r3, r4
 8000d74: eba3 030a    	sub.w	r3, r3, r10
 8000d78: b289         	uxth	r1, r1
 8000d7a: fbb3 f8f9    	udiv	r8, r3, r9
 8000d7e: fb09 3318    	mls	r3, r9, r8, r3
 8000d82: fb08 fe0e    	mul	lr, r8, lr
 8000d86: ea41 4103    	orr.w	r1, r1, r3, lsl #16
 8000d8a: 458e         	cmp	lr, r1
 8000d8c: d92c         	bls	0x8000de8 <__udivmoddi4+0x29c> @ imm = #0x58
 8000d8e: 1861         	adds	r1, r4, r1
 8000d90: f108 33ff    	add.w	r3, r8, #0xffffffff
 8000d94: d204         	bhs	0x8000da0 <__udivmoddi4+0x254> @ imm = #0x8
 8000d96: 458e         	cmp	lr, r1
 8000d98: d902         	bls	0x8000da0 <__udivmoddi4+0x254> @ imm = #0x4
 8000d9a: f1a8 0302    	sub.w	r3, r8, #0x2
 8000d9e: 4421         	add	r1, r4
 8000da0: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 8000da4: fba0 9802    	umull	r9, r8, r0, r2
 8000da8: eba1 010e    	sub.w	r1, r1, lr
 8000dac: 4541         	cmp	r1, r8
 8000dae: 46ce         	mov	lr, r9
 8000db0: 4643         	mov	r3, r8
 8000db2: d302         	blo	0x8000dba <__udivmoddi4+0x26e> @ imm = #0x4
 8000db4: d106         	bne	0x8000dc4 <__udivmoddi4+0x278> @ imm = #0xc
 8000db6: 454d         	cmp	r5, r9
 8000db8: d204         	bhs	0x8000dc4 <__udivmoddi4+0x278> @ imm = #0x8
 8000dba: ebb9 0e02    	subs.w	lr, r9, r2
 8000dbe: eb68 0304    	sbc.w	r3, r8, r4
 8000dc2: 3801         	subs	r0, #0x1
 8000dc4: 2e00         	cmp	r6, #0x0
 8000dc6: d0a6         	beq	0x8000d16 <__udivmoddi4+0x1ca> @ imm = #-0xb4
 8000dc8: ebb5 020e    	subs.w	r2, r5, lr
 8000dcc: eb61 0103    	sbc.w	r1, r1, r3
 8000dd0: fa01 fc0c    	lsl.w	r12, r1, r12
 8000dd4: fa22 f307    	lsr.w	r3, r2, r7
 8000dd8: ea4c 0303    	orr.w	r3, r12, r3
 8000ddc: 40f9         	lsrs	r1, r7
 8000dde: e9c6 3100    	strd	r3, r1, [r6]
 8000de2: e798         	b	0x8000d16 <__udivmoddi4+0x1ca> @ imm = #-0xd0
 8000de4: 4640         	mov	r0, r8
 8000de6: e7c5         	b	0x8000d74 <__udivmoddi4+0x228> @ imm = #-0x76
 8000de8: 4643         	mov	r3, r8
 8000dea: e7d9         	b	0x8000da0 <__udivmoddi4+0x254> @ imm = #-0x4e

08000dec <z_impl_motor_get_speed>:
; static inline float z_impl_motor_get_speed(const struct device *dev) {
 8000dec: b580         	push	{r7, lr}
 8000dee: b084         	sub	sp, #0x10
 8000df0: af00         	add	r7, sp, #0x0
 8000df2: 6078         	str	r0, [r7, #0x4]
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 8000df4: 687b         	ldr	r3, [r7, #0x4]
 8000df6: 689b         	ldr	r3, [r3, #0x8]
 8000df8: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_get_speed == NULL) {
 8000dfa: 68fb         	ldr	r3, [r7, #0xc]
 8000dfc: 681b         	ldr	r3, [r3]
 8000dfe: 2b00         	cmp	r3, #0x0
 8000e00: d101         	bne	0x8000e06 <z_impl_motor_get_speed+0x1a> @ imm = #0x2
;         return -ENOSYS;
 8000e02: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8000e18 <z_impl_motor_get_speed+0x2c>
 8000e04: e004         	b	0x8000e10 <z_impl_motor_get_speed+0x24> @ imm = #0x8
;     return api->motor_get_speed(dev);
 8000e06: 68fb         	ldr	r3, [r7, #0xc]
 8000e08: 681b         	ldr	r3, [r3]
 8000e0a: 6878         	ldr	r0, [r7, #0x4]
 8000e0c: 4798         	blx	r3
 8000e0e: 4603         	mov	r3, r0
; }
 8000e10: 4618         	mov	r0, r3
 8000e12: 3710         	adds	r7, #0x10
 8000e14: 46bd         	mov	sp, r7
 8000e16: bd80         	pop	{r7, pc}

08000e18 <$d>:
 8000e18: 00 00 b0 c2  	.word	0xc2b00000

08000e1c <console_feedback>:
; {
 8000e1c: b590         	push	{r4, r7, lr}
 8000e1e: b08d         	sub	sp, #0x34
 8000e20: af06         	add	r7, sp, #0x18
 8000e22: 60f8         	str	r0, [r7, #0xc]
 8000e24: 60b9         	str	r1, [r7, #0x8]
 8000e26: 607a         	str	r2, [r7, #0x4]
; 		LOG_INF("rpm: motor1: %.2f\n", (double)motor_get_speed(motor1));
 8000e28: 2304         	movs	r3, #0x4
 8000e2a: 2b02         	cmp	r3, #0x2
 8000e2c: d924         	bls	0x8000e78 <console_feedback+0x5c> @ imm = #0x48
 8000e2e: 2301         	movs	r3, #0x1
 8000e30: 75fb         	strb	r3, [r7, #0x17]
 8000e32: 7dfb         	ldrb	r3, [r7, #0x17]
 8000e34: f083 0301    	eor	r3, r3, #0x1
 8000e38: b2db         	uxtb	r3, r3
 8000e3a: 2b00         	cmp	r3, #0x0
 8000e3c: d11c         	bne	0x8000e78 <console_feedback+0x5c> @ imm = #0x38
 8000e3e: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8000e84 <console_feedback+0x68>
 8000e40: 681c         	ldr	r4, [r3]
 8000e42: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8000e88 <console_feedback+0x6c>
 8000e44: 681b         	ldr	r3, [r3]
 8000e46: 4618         	mov	r0, r3
 8000e48: f010 fb68    	bl	0x801151c <motor_get_speed> @ imm = #0x106d0
 8000e4c: 4603         	mov	r3, r0
 8000e4e: 4618         	mov	r0, r3
 8000e50: f7ff fafe    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xa04
 8000e54: 4602         	mov	r2, r0
 8000e56: 460b         	mov	r3, r1
 8000e58: e9cd 2304    	strd	r2, r3, [sp, #16]
 8000e5c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8000e8c <console_feedback+0x70>
 8000e5e: 9302         	str	r3, [sp, #0x8]
 8000e60: 2300         	movs	r3, #0x0
 8000e62: 9301         	str	r3, [sp, #0x4]
 8000e64: 2300         	movs	r3, #0x0
 8000e66: 9300         	str	r3, [sp]
 8000e68: 2300         	movs	r3, #0x0
 8000e6a: 2203         	movs	r2, #0x3
 8000e6c: 4621         	mov	r1, r4
 8000e6e: 2000         	movs	r0, #0x0
 8000e70: f010 fa90    	bl	0x8011394 <z_log_msg_runtime_create> @ imm = #0x10520
 8000e74: 2300         	movs	r3, #0x0
 8000e76: 613b         	str	r3, [r7, #0x10]
; 		k_msleep(500);
 8000e78: f44f 70fa    	mov.w	r0, #0x1f4
 8000e7c: f010 faa8    	bl	0x80113d0 <k_msleep>    @ imm = #0x10550
; 		LOG_INF("rpm: motor1: %.2f\n", (double)motor_get_speed(motor1));
 8000e80: e7d2         	b	0x8000e28 <console_feedback+0xc> @ imm = #-0x5c
 8000e82: bf00         	nop

08000e84 <$d>:
 8000e84: 08 04 00 20  	.word	0x20000408
 8000e88: 0c 04 00 20  	.word	0x2000040c
 8000e8c: c0 b2 01 08  	.word	0x0801b2c0

08000e90 <main>:
; {
 8000e90: b580         	push	{r7, lr}
 8000e92: b0bc         	sub	sp, #0xf0
 8000e94: af08         	add	r7, sp, #0x20
; 	k_sleep(K_MSEC(5000));
 8000e96: f24c 3250    	movw	r2, #0xc350
 8000e9a: f04f 0300    	mov.w	r3, #0x0
 8000e9e: 4610         	mov	r0, r2
 8000ea0: 4619         	mov	r1, r3
 8000ea2: f010 fae1    	bl	0x8011468 <k_sleep>     @ imm = #0x105c2
; 	motor_set_mode(motor1, MIT);
 8000ea6: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8000f08 <main+0x78>
 8000ea8: 681b         	ldr	r3, [r3]
 8000eaa: 2100         	movs	r1, #0x0
 8000eac: 4618         	mov	r0, r3
 8000eae: f010 fb5e    	bl	0x801156e <motor_set_mode> @ imm = #0x106bc
; 	motor_control(motor1, ENABLE_MOTOR);
 8000eb2: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8000f08 <main+0x78>
 8000eb4: 681b         	ldr	r3, [r3]
 8000eb6: 2100         	movs	r1, #0x0
 8000eb8: 4618         	mov	r0, r3
 8000eba: f010 fb49    	bl	0x8011550 <motor_control> @ imm = #0x10692
; 	motor_set_speed(motor1, 2);
 8000ebe: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8000f08 <main+0x78>
 8000ec0: 681b         	ldr	r3, [r3]
 8000ec2: f04f 4180    	mov.w	r1, #0x40000000
 8000ec6: 4618         	mov	r0, r3
 8000ec8: f010 fb34    	bl	0x8011534 <motor_set_speed> @ imm = #0x10668
; 	k_thread_create(&feedback_thread_data,
 8000ecc: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8000f08 <main+0x78>
 8000ece: 6819         	ldr	r1, [r3]
; 			(void *)motor1, NULL, NULL, 0, 0, K_MSEC(300));
 8000ed0: f640 32b8    	movw	r2, #0xbb8
 8000ed4: f04f 0300    	mov.w	r3, #0x0
; 	k_thread_create(&feedback_thread_data,
 8000ed8: 4638         	mov	r0, r7
 8000eda: e9cd 2306    	strd	r2, r3, [sp, #24]
 8000ede: 2300         	movs	r3, #0x0
 8000ee0: 9304         	str	r3, [sp, #0x10]
 8000ee2: 2300         	movs	r3, #0x0
 8000ee4: 9303         	str	r3, [sp, #0xc]
 8000ee6: 2300         	movs	r3, #0x0
 8000ee8: 9302         	str	r3, [sp, #0x8]
 8000eea: 2300         	movs	r3, #0x0
 8000eec: 9301         	str	r3, [sp, #0x4]
 8000eee: 9100         	str	r1, [sp]
 8000ef0: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8000f0c <main+0x7c>
 8000ef2: f44f 5280    	mov.w	r2, #0x1000
 8000ef6: 4906         	ldr	r1, [pc, #0x18]         @ 0x8000f10 <main+0x80>
 8000ef8: f010 fa96    	bl	0x8011428 <k_thread_create> @ imm = #0x1052c
; 		k_msleep(500);
 8000efc: f44f 70fa    	mov.w	r0, #0x1f4
 8000f00: f010 fa66    	bl	0x80113d0 <k_msleep>    @ imm = #0x104cc
 8000f04: e7fa         	b	0x8000efc <main+0x6c>   @ imm = #-0xc
 8000f06: bf00         	nop

08000f08 <$d>:
 8000f08: 0c 04 00 20  	.word	0x2000040c
 8000f0c: 1d 0e 00 08  	.word	0x08000e1d
 8000f10: 48 11 00 20  	.word	0x20001148

08000f14 <linker_is_in_rodata>:
; {
 8000f14: b480         	push	{r7}
 8000f16: b083         	sub	sp, #0xc
 8000f18: af00         	add	r7, sp, #0x0
 8000f1a: 6078         	str	r0, [r7, #0x4]
; 	return (((const char *)addr >= (const char *)RO_START) &&
 8000f1c: 687b         	ldr	r3, [r7, #0x4]
 8000f1e: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8000f44 <linker_is_in_rodata+0x30>
 8000f20: 4293         	cmp	r3, r2
 8000f22: d305         	blo	0x8000f30 <linker_is_in_rodata+0x1c> @ imm = #0xa
 8000f24: 687b         	ldr	r3, [r7, #0x4]
 8000f26: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8000f48 <linker_is_in_rodata+0x34>
 8000f28: 4293         	cmp	r3, r2
 8000f2a: d201         	bhs	0x8000f30 <linker_is_in_rodata+0x1c> @ imm = #0x2
 8000f2c: 2301         	movs	r3, #0x1
 8000f2e: e000         	b	0x8000f32 <linker_is_in_rodata+0x1e> @ imm = #0x0
 8000f30: 2300         	movs	r3, #0x0
 8000f32: f003 0301    	and	r3, r3, #0x1
 8000f36: b2db         	uxtb	r3, r3
; }
 8000f38: 4618         	mov	r0, r3
 8000f3a: 370c         	adds	r7, #0xc
 8000f3c: 46bd         	mov	sp, r7
 8000f3e: bc80         	pop	{r7}
 8000f40: 4770         	bx	lr
 8000f42: bf00         	nop

08000f44 <$d>:
 8000f44: f0 ab 01 08  	.word	0x0801abf0
 8000f48: c0 da 01 08  	.word	0x0801dac0

08000f4c <cbvprintf_package>:
; {
 8000f4c: b580         	push	{r7, lr}
 8000f4e: b0a4         	sub	sp, #0x90
 8000f50: af00         	add	r7, sp, #0x0
 8000f52: 60f8         	str	r0, [r7, #0xc]
 8000f54: 60b9         	str	r1, [r7, #0x8]
 8000f56: 607a         	str	r2, [r7, #0x4]
 8000f58: 603b         	str	r3, [r7]
; 	uint8_t *buf0 = packaged;  /* buffer start (may be NULL) */
 8000f5a: 68fb         	ldr	r3, [r7, #0xc]
 8000f5c: 65fb         	str	r3, [r7, #0x5c]
; 	uintptr_t buf = (uintptr_t)buf0; /* current buffer position */
 8000f5e: 6dfb         	ldr	r3, [r7, #0x5c]
 8000f60: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
 8000f64: 2300         	movs	r3, #0x0
 8000f66: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	unsigned int s_rw_cnt = 0; /* number of rw strings */
 8000f6a: 2300         	movs	r3, #0x0
 8000f6c: 67fb         	str	r3, [r7, #0x7c]
; 	unsigned int s_ro_cnt = 0; /* number of ro strings */
 8000f6e: 2300         	movs	r3, #0x0
 8000f70: 67bb         	str	r3, [r7, #0x78]
; 	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
 8000f72: f04f 33ff    	mov.w	r3, #0xffffffff
 8000f76: 677b         	str	r3, [r7, #0x74]
; 	bool parsing = false;
 8000f78: 2300         	movs	r3, #0x0
 8000f7a: f887 306b    	strb.w	r3, [r7, #0x6b]
; 	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
 8000f7e: 687b         	ldr	r3, [r7, #0x4]
 8000f80: f003 0304    	and	r3, r3, #0x4
 8000f84: 2b00         	cmp	r3, #0x0
 8000f86: bf14         	ite	ne
 8000f88: 2301         	movne	r3, #0x1
 8000f8a: 2300         	moveq	r3, #0x0
 8000f8c: f887 305b    	strb.w	r3, [r7, #0x5b]
; 	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
 8000f90: 687b         	ldr	r3, [r7, #0x4]
 8000f92: 08db         	lsrs	r3, r3, #0x3
 8000f94: f003 0307    	and	r3, r3, #0x7
 8000f98: 3301         	adds	r3, #0x1
 8000f9a: 667b         	str	r3, [r7, #0x64]
; 	bool is_str_arg = false;
 8000f9c: 2300         	movs	r3, #0x0
 8000f9e: f887 3063    	strb.w	r3, [r7, #0x63]
; 	union cbprintf_package_hdr *pkg_hdr = packaged;
 8000fa2: 68fb         	ldr	r3, [r7, #0xc]
 8000fa4: 657b         	str	r3, [r7, #0x54]
; 	if ((uintptr_t)packaged % sizeof(void *)) {
 8000fa6: 68fb         	ldr	r3, [r7, #0xc]
 8000fa8: f003 0303    	and	r3, r3, #0x3
 8000fac: 2b00         	cmp	r3, #0x0
 8000fae: d002         	beq	0x8000fb6 <cbvprintf_package+0x6a> @ imm = #0x4
; 		return -EFAULT;
 8000fb0: f06f 030d    	mvn	r3, #0xd
 8000fb4: e3a2         	b	0x80016fc <cbvprintf_package+0x7b0> @ imm = #0x744
; 	buf += sizeof(*pkg_hdr);
 8000fb6: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8000fba: 3304         	adds	r3, #0x4
 8000fbc: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	if (buf0 == NULL) {
 8000fc0: 6dfb         	ldr	r3, [r7, #0x5c]
 8000fc2: 2b00         	cmp	r3, #0x0
 8000fc4: d10d         	bne	0x8000fe2 <cbvprintf_package+0x96> @ imm = #0x1a
; 		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
 8000fc6: 68bb         	ldr	r3, [r7, #0x8]
 8000fc8: f003 0307    	and	r3, r3, #0x7
 8000fcc: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8000fd0: 4413         	add	r3, r2
 8000fd2: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
 8000fd6: 68bb         	ldr	r3, [r7, #0x8]
 8000fd8: f003 0307    	and	r3, r3, #0x7
 8000fdc: f1c3 0308    	rsb.w	r3, r3, #0x8
 8000fe0: 60bb         	str	r3, [r7, #0x8]
; 	if ((buf0 != NULL) && (BUF_OFFSET + sizeof(char *)) > len) {
 8000fe2: 6dfb         	ldr	r3, [r7, #0x5c]
 8000fe4: 2b00         	cmp	r3, #0x0
 8000fe6: d00a         	beq	0x8000ffe <cbvprintf_package+0xb2> @ imm = #0x14
 8000fe8: 6dfb         	ldr	r3, [r7, #0x5c]
 8000fea: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8000fee: 1ad3         	subs	r3, r2, r3
 8000ff0: 3304         	adds	r3, #0x4
 8000ff2: 68ba         	ldr	r2, [r7, #0x8]
 8000ff4: 429a         	cmp	r2, r3
 8000ff6: d202         	bhs	0x8000ffe <cbvprintf_package+0xb2> @ imm = #0x4
; 		return -ENOSPC;
 8000ff8: f06f 031b    	mvn	r3, #0x1b
 8000ffc: e37e         	b	0x80016fc <cbvprintf_package+0x7b0> @ imm = #0x6fc
; 	s = fmt;
 8000ffe: 683b         	ldr	r3, [r7]
 8001000: 66fb         	str	r3, [r7, #0x6c]
; 	--fmt;
 8001002: 683b         	ldr	r3, [r7]
 8001004: 3b01         	subs	r3, #0x1
 8001006: 603b         	str	r3, [r7]
; 	align = VA_STACK_ALIGN(char *);
 8001008: 2304         	movs	r3, #0x4
 800100a: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	size = sizeof(char *);
 800100e: 2304         	movs	r3, #0x4
 8001010: f8c7 3088    	str.w	r3, [r7, #0x88]
; 	goto process_string;
 8001014: e197         	b	0x8001346 <cbvprintf_package+0x3fa> @ imm = #0x32e
; 			if (!parsing) {
 8001016: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 800101a: f083 0301    	eor	r3, r3, #0x1
 800101e: b2db         	uxtb	r3, r3
 8001020: 2b00         	cmp	r3, #0x0
 8001022: d011         	beq	0x8001048 <cbvprintf_package+0xfc> @ imm = #0x22
; 				if (*fmt == '%') {
 8001024: 683b         	ldr	r3, [r7]
 8001026: 781b         	ldrb	r3, [r3]
 8001028: 2b25         	cmp	r3, #0x25
 800102a: f040 8278    	bne.w	0x800151e <cbvprintf_package+0x5d2> @ imm = #0x4f0
; 					parsing = true;
 800102e: 2301         	movs	r3, #0x1
 8001030: f887 306b    	strb.w	r3, [r7, #0x6b]
; 					arg_idx++;
 8001034: 6f7b         	ldr	r3, [r7, #0x74]
 8001036: 3301         	adds	r3, #0x1
 8001038: 677b         	str	r3, [r7, #0x74]
; 					align = VA_STACK_ALIGN(int);
 800103a: 2304         	movs	r3, #0x4
 800103c: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(int);
 8001040: 2304         	movs	r3, #0x4
 8001042: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8001046: e26a         	b	0x800151e <cbvprintf_package+0x5d2> @ imm = #0x4d4
; 			switch (*fmt) {
 8001048: 683b         	ldr	r3, [r7]
 800104a: 781b         	ldrb	r3, [r3]
 800104c: 2b7a         	cmp	r3, #0x7a
 800104e: f300 8149    	bgt.w	0x80012e4 <cbvprintf_package+0x398> @ imm = #0x292
 8001052: 2b4c         	cmp	r3, #0x4c
 8001054: da11         	bge	0x800107a <cbvprintf_package+0x12e> @ imm = #0x22
 8001056: 2b47         	cmp	r3, #0x47
 8001058: f300 8144    	bgt.w	0x80012e4 <cbvprintf_package+0x398> @ imm = #0x288
 800105c: 2b2a         	cmp	r3, #0x2a
 800105e: da71         	bge	0x8001144 <cbvprintf_package+0x1f8> @ imm = #0xe2
 8001060: 2b25         	cmp	r3, #0x25
 8001062: f000 8092    	beq.w	0x800118a <cbvprintf_package+0x23e> @ imm = #0x124
 8001066: 2b25         	cmp	r3, #0x25
 8001068: f300 813c    	bgt.w	0x80012e4 <cbvprintf_package+0x398> @ imm = #0x278
 800106c: 2b20         	cmp	r3, #0x20
 800106e: f000 8258    	beq.w	0x8001522 <cbvprintf_package+0x5d6> @ imm = #0x4b0
 8001072: 2b23         	cmp	r3, #0x23
 8001074: f000 8255    	beq.w	0x8001522 <cbvprintf_package+0x5d6> @ imm = #0x4aa
 8001078: e134         	b	0x80012e4 <cbvprintf_package+0x398> @ imm = #0x268
 800107a: 3b4c         	subs	r3, #0x4c
 800107c: 2b2e         	cmp	r3, #0x2e
 800107e: f200 8131    	bhi.w	0x80012e4 <cbvprintf_package+0x398> @ imm = #0x262
 8001082: a201         	adr	r2, #4 <cbvprintf_package+0x13b>
 8001084: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08001088 <$d>:
 8001088: 23 15 00 08  	.word	0x08001523
 800108c: e5 12 00 08  	.word	0x080012e5
 8001090: e5 12 00 08  	.word	0x080012e5
 8001094: e5 12 00 08  	.word	0x080012e5
 8001098: e5 12 00 08  	.word	0x080012e5
 800109c: e5 12 00 08  	.word	0x080012e5
 80010a0: e5 12 00 08  	.word	0x080012e5
 80010a4: e5 12 00 08  	.word	0x080012e5
 80010a8: e5 12 00 08  	.word	0x080012e5
 80010ac: e5 12 00 08  	.word	0x080012e5
 80010b0: e5 12 00 08  	.word	0x080012e5
 80010b4: e5 12 00 08  	.word	0x080012e5
 80010b8: c3 11 00 08  	.word	0x080011c3
 80010bc: e5 12 00 08  	.word	0x080012e5
 80010c0: e5 12 00 08  	.word	0x080012e5
 80010c4: e5 12 00 08  	.word	0x080012e5
 80010c8: e5 12 00 08  	.word	0x080012e5
 80010cc: e5 12 00 08  	.word	0x080012e5
 80010d0: e5 12 00 08  	.word	0x080012e5
 80010d4: e5 12 00 08  	.word	0x080012e5
 80010d8: e5 12 00 08  	.word	0x080012e5
 80010dc: 13 12 00 08  	.word	0x08001213
 80010e0: e5 12 00 08  	.word	0x080012e5
 80010e4: c3 11 00 08  	.word	0x080011c3
 80010e8: c3 11 00 08  	.word	0x080011c3
 80010ec: 13 12 00 08  	.word	0x08001213
 80010f0: 13 12 00 08  	.word	0x08001213
 80010f4: 13 12 00 08  	.word	0x08001213
 80010f8: 23 15 00 08  	.word	0x08001523
 80010fc: c3 11 00 08  	.word	0x080011c3
 8001100: 99 11 00 08  	.word	0x08001199
 8001104: e5 12 00 08  	.word	0x080012e5
 8001108: 23 15 00 08  	.word	0x08001523
 800110c: e5 12 00 08  	.word	0x080012e5
 8001110: ff 11 00 08  	.word	0x080011ff
 8001114: c3 11 00 08  	.word	0x080011c3
 8001118: ff 11 00 08  	.word	0x080011ff
 800111c: e5 12 00 08  	.word	0x080012e5
 8001120: e5 12 00 08  	.word	0x080012e5
 8001124: f9 11 00 08  	.word	0x080011f9
 8001128: b5 11 00 08  	.word	0x080011b5
 800112c: c3 11 00 08  	.word	0x080011c3
 8001130: e5 12 00 08  	.word	0x080012e5
 8001134: e5 12 00 08  	.word	0x080012e5
 8001138: c3 11 00 08  	.word	0x080011c3
 800113c: e5 12 00 08  	.word	0x080012e5
 8001140: a7 11 00 08  	.word	0x080011a7

08001144 <$t>:
 8001144: 3b2a         	subs	r3, #0x2a
 8001146: 2201         	movs	r2, #0x1
 8001148: fa02 f303    	lsl.w	r3, r2, r3
 800114c: f64f 72da    	movw	r2, #0xffda
 8001150: 401a         	ands	r2, r3
 8001152: 2a00         	cmp	r2, #0x0
 8001154: bf14         	ite	ne
 8001156: 2201         	movne	r2, #0x1
 8001158: 2200         	moveq	r2, #0x0
 800115a: b2d2         	uxtb	r2, r2
 800115c: 2a00         	cmp	r2, #0x0
 800115e: f040 81e0    	bne.w	0x8001522 <cbvprintf_package+0x5d6> @ imm = #0x3c0
 8001162: f003 5262    	and	r2, r3, #0x38800000
 8001166: 2a00         	cmp	r2, #0x0
 8001168: bf14         	ite	ne
 800116a: 2201         	movne	r2, #0x1
 800116c: 2200         	moveq	r2, #0x0
 800116e: b2d2         	uxtb	r2, r2
 8001170: 2a00         	cmp	r2, #0x0
 8001172: d14e         	bne	0x8001212 <cbvprintf_package+0x2c6> @ imm = #0x9c
 8001174: f003 0301    	and	r3, r3, #0x1
 8001178: 2b00         	cmp	r3, #0x0
 800117a: bf14         	ite	ne
 800117c: 2301         	movne	r3, #0x1
 800117e: 2300         	moveq	r3, #0x0
 8001180: b2db         	uxtb	r3, r3
 8001182: 2b00         	cmp	r3, #0x0
 8001184: f040 80b2    	bne.w	0x80012ec <cbvprintf_package+0x3a0> @ imm = #0x164
 8001188: e0ac         	b	0x80012e4 <cbvprintf_package+0x398> @ imm = #0x158
; 				parsing = false;
 800118a: 2300         	movs	r3, #0x0
 800118c: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				arg_idx--;
 8001190: 6f7b         	ldr	r3, [r7, #0x74]
 8001192: 3b01         	subs	r3, #0x1
 8001194: 677b         	str	r3, [r7, #0x74]
; 				continue;
 8001196: e1c5         	b	0x8001524 <cbvprintf_package+0x5d8> @ imm = #0x38a
; 				align = VA_STACK_ALIGN(intmax_t);
 8001198: 2308         	movs	r3, #0x8
 800119a: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(intmax_t);
 800119e: 2308         	movs	r3, #0x8
 80011a0: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 80011a4: e1be         	b	0x8001524 <cbvprintf_package+0x5d8> @ imm = #0x37c
; 				align = VA_STACK_ALIGN(size_t);
 80011a6: 2304         	movs	r3, #0x4
 80011a8: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(size_t);
 80011ac: 2304         	movs	r3, #0x4
 80011ae: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 80011b2: e1b7         	b	0x8001524 <cbvprintf_package+0x5d8> @ imm = #0x36e
; 				align = VA_STACK_ALIGN(ptrdiff_t);
 80011b4: 2304         	movs	r3, #0x4
 80011b6: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(ptrdiff_t);
 80011ba: 2304         	movs	r3, #0x4
 80011bc: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 80011c0: e1b0         	b	0x8001524 <cbvprintf_package+0x5d8> @ imm = #0x360
; 				if (fmt[-1] == 'l') {
 80011c2: 683b         	ldr	r3, [r7]
 80011c4: 3b01         	subs	r3, #0x1
 80011c6: 781b         	ldrb	r3, [r3]
 80011c8: 2b6c         	cmp	r3, #0x6c
 80011ca: d111         	bne	0x80011f0 <cbvprintf_package+0x2a4> @ imm = #0x22
; 					if (fmt[-2] == 'l') {
 80011cc: 683b         	ldr	r3, [r7]
 80011ce: 3b02         	subs	r3, #0x2
 80011d0: 781b         	ldrb	r3, [r3]
 80011d2: 2b6c         	cmp	r3, #0x6c
 80011d4: d106         	bne	0x80011e4 <cbvprintf_package+0x298> @ imm = #0xc
; 						align = VA_STACK_ALIGN(long long);
 80011d6: 2308         	movs	r3, #0x8
 80011d8: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long long);
 80011dc: 2308         	movs	r3, #0x8
 80011de: f8c7 3088    	str.w	r3, [r7, #0x88]
 80011e2: e005         	b	0x80011f0 <cbvprintf_package+0x2a4> @ imm = #0xa
; 						align = VA_STACK_ALIGN(long);
 80011e4: 2304         	movs	r3, #0x4
 80011e6: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long);
 80011ea: 2304         	movs	r3, #0x4
 80011ec: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 80011f0: 2300         	movs	r3, #0x0
 80011f2: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 80011f6: e07a         	b	0x80012ee <cbvprintf_package+0x3a2> @ imm = #0xf4
; 				is_str_arg = true;
 80011f8: 2301         	movs	r3, #0x1
 80011fa: f887 3063    	strb.w	r3, [r7, #0x63]
; 				align = VA_STACK_ALIGN(void *);
 80011fe: 2304         	movs	r3, #0x4
 8001200: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(void *);
 8001204: 2304         	movs	r3, #0x4
 8001206: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 800120a: 2300         	movs	r3, #0x0
 800120c: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 8001210: e06d         	b	0x80012ee <cbvprintf_package+0x3a2> @ imm = #0xda
; 				if (fmt[-1] == 'L') {
 8001212: 683b         	ldr	r3, [r7]
 8001214: 3b01         	subs	r3, #0x1
 8001216: 781b         	ldrb	r3, [r3]
 8001218: 2b4c         	cmp	r3, #0x4c
 800121a: d113         	bne	0x8001244 <cbvprintf_package+0x2f8> @ imm = #0x26
; 					v.ld = va_arg(ap, long double);
 800121c: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8001220: 3307         	adds	r3, #0x7
 8001222: f023 0307    	bic	r3, r3, #0x7
 8001226: f103 0208    	add.w	r2, r3, #0x8
 800122a: f8c7 2098    	str.w	r2, [r7, #0x98]
 800122e: e9d3 2300    	ldrd	r2, r3, [r3]
 8001232: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(long double);
 8001236: 2308         	movs	r3, #0x8
 8001238: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(long double);
 800123c: 2308         	movs	r3, #0x8
 800123e: f8c7 3088    	str.w	r3, [r7, #0x88]
 8001242: e012         	b	0x800126a <cbvprintf_package+0x31e> @ imm = #0x24
; 					v.d = va_arg(ap, double);
 8001244: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8001248: 3307         	adds	r3, #0x7
 800124a: f023 0307    	bic	r3, r3, #0x7
 800124e: f103 0208    	add.w	r2, r3, #0x8
 8001252: f8c7 2098    	str.w	r2, [r7, #0x98]
 8001256: e9d3 2300    	ldrd	r2, r3, [r3]
 800125a: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(double);
 800125e: 2308         	movs	r3, #0x8
 8001260: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(double);
 8001264: 2308         	movs	r3, #0x8
 8001266: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				buf = ROUND_UP(buf, align);
 800126a: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 800126e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001272: 4413         	add	r3, r2
 8001274: 1e5a         	subs	r2, r3, #0x1
 8001276: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800127a: fbb2 f2f3    	udiv	r2, r2, r3
 800127e: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8001282: fb02 f303    	mul	r3, r2, r3
 8001286: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				if (buf0 != NULL) {
 800128a: 6dfb         	ldr	r3, [r7, #0x5c]
 800128c: 2b00         	cmp	r3, #0x0
 800128e: d01e         	beq	0x80012ce <cbvprintf_package+0x382> @ imm = #0x3c
; 					if (BUF_OFFSET + size > len) {
 8001290: 6dfb         	ldr	r3, [r7, #0x5c]
 8001292: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001296: 1ad2         	subs	r2, r2, r3
 8001298: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800129c: 4413         	add	r3, r2
 800129e: 68ba         	ldr	r2, [r7, #0x8]
 80012a0: 429a         	cmp	r2, r3
 80012a2: d202         	bhs	0x80012aa <cbvprintf_package+0x35e> @ imm = #0x4
; 						return -ENOSPC;
 80012a4: f06f 031b    	mvn	r3, #0x1b
 80012a8: e228         	b	0x80016fc <cbvprintf_package+0x7b0> @ imm = #0x450
; 					} else if (fmt[-1] == 'L') {
 80012aa: 683b         	ldr	r3, [r7]
 80012ac: 3b01         	subs	r3, #0x1
 80012ae: 781b         	ldrb	r3, [r3]
 80012b0: 2b4c         	cmp	r3, #0x4c
 80012b2: d106         	bne	0x80012c2 <cbvprintf_package+0x376> @ imm = #0xc
; 						*(long double *)buf = v.ld;
 80012b4: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 80012b8: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 80012bc: e9c1 2300    	strd	r2, r3, [r1]
 80012c0: e005         	b	0x80012ce <cbvprintf_package+0x382> @ imm = #0xa
; 						*(double *)buf = v.d;
 80012c2: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 80012c6: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 80012ca: e9c1 2300    	strd	r2, r3, [r1]
; 				buf += size;
 80012ce: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80012d2: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80012d6: 4413         	add	r3, r2
 80012d8: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				parsing = false;
 80012dc: 2300         	movs	r3, #0x0
 80012de: f887 306b    	strb.w	r3, [r7, #0x6b]
 80012e2: e11f         	b	0x8001524 <cbvprintf_package+0x5d8> @ imm = #0x23e
; 				parsing = false;
 80012e4: 2300         	movs	r3, #0x0
 80012e6: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				continue;
 80012ea: e11b         	b	0x8001524 <cbvprintf_package+0x5d8> @ imm = #0x236
; 				break;
 80012ec: bf00         	nop
; 		buf = ROUND_UP(buf, align);
 80012ee: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 80012f2: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80012f6: 4413         	add	r3, r2
 80012f8: 1e5a         	subs	r2, r3, #0x1
 80012fa: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 80012fe: fbb2 f2f3    	udiv	r2, r2, r3
 8001302: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8001306: fb02 f303    	mul	r3, r2, r3
 800130a: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		if ((buf0 != NULL) && (BUF_OFFSET + size) > len) {
 800130e: 6dfb         	ldr	r3, [r7, #0x5c]
 8001310: 2b00         	cmp	r3, #0x0
 8001312: d00c         	beq	0x800132e <cbvprintf_package+0x3e2> @ imm = #0x18
 8001314: 6dfb         	ldr	r3, [r7, #0x5c]
 8001316: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 800131a: 1ad2         	subs	r2, r2, r3
 800131c: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8001320: 4413         	add	r3, r2
 8001322: 68ba         	ldr	r2, [r7, #0x8]
 8001324: 429a         	cmp	r2, r3
 8001326: d202         	bhs	0x800132e <cbvprintf_package+0x3e2> @ imm = #0x4
; 			return -ENOSPC;
 8001328: f06f 031b    	mvn	r3, #0x1b
 800132c: e1e6         	b	0x80016fc <cbvprintf_package+0x7b0> @ imm = #0x3cc
; 		if (is_str_arg) {
 800132e: f897 3063    	ldrb.w	r3, [r7, #0x63]
 8001332: 2b00         	cmp	r3, #0x0
 8001334: f000 80a0    	beq.w	0x8001478 <cbvprintf_package+0x52c> @ imm = #0x140
; 			s = va_arg(ap, char *);
 8001338: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 800133c: 1d1a         	adds	r2, r3, #0x4
 800133e: f8c7 2098    	str.w	r2, [r7, #0x98]
 8001342: 681b         	ldr	r3, [r3]
 8001344: 66fb         	str	r3, [r7, #0x6c]
; 			if (buf0 != NULL) {
 8001346: 6dfb         	ldr	r3, [r7, #0x5c]
 8001348: 2b00         	cmp	r3, #0x0
 800134a: d003         	beq	0x8001354 <cbvprintf_package+0x408> @ imm = #0x6
; 				*(const char **)buf = s;
 800134c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001350: 6efa         	ldr	r2, [r7, #0x6c]
 8001352: 601a         	str	r2, [r3]
; 			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 8001354: 6e7b         	ldr	r3, [r7, #0x64]
 8001356: 1e5a         	subs	r2, r3, #0x1
 8001358: 667a         	str	r2, [r7, #0x64]
 800135a: 2b00         	cmp	r3, #0x0
 800135c: dc05         	bgt	0x800136a <cbvprintf_package+0x41e> @ imm = #0xa
 800135e: 6ef8         	ldr	r0, [r7, #0x6c]
 8001360: f010 fb9d    	bl	0x8011a9e <ptr_in_rodata> @ imm = #0x1073a
 8001364: 4603         	mov	r3, r0
 8001366: 2b00         	cmp	r3, #0x0
 8001368: d001         	beq	0x800136e <cbvprintf_package+0x422> @ imm = #0x2
 800136a: 2301         	movs	r3, #0x1
 800136c: e000         	b	0x8001370 <cbvprintf_package+0x424> @ imm = #0x0
 800136e: 2300         	movs	r3, #0x0
 8001370: f887 3053    	strb.w	r3, [r7, #0x53]
; 			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);
 8001374: 687b         	ldr	r3, [r7, #0x4]
 8001376: f003 0302    	and	r3, r3, #0x2
 800137a: 2b00         	cmp	r3, #0x0
 800137c: bf14         	ite	ne
 800137e: 2301         	movne	r3, #0x1
 8001380: 2300         	moveq	r3, #0x0
 8001382: f887 3052    	strb.w	r3, [r7, #0x52]
; 			if (is_ro && !do_ro) {
 8001386: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800138a: 2b00         	cmp	r3, #0x0
 800138c: d006         	beq	0x800139c <cbvprintf_package+0x450> @ imm = #0xc
 800138e: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8001392: f083 0301    	eor	r3, r3, #0x1
 8001396: b2db         	uxtb	r3, r3
 8001398: 2b00         	cmp	r3, #0x0
 800139a: d164         	bne	0x8001466 <cbvprintf_package+0x51a> @ imm = #0xc8
; 				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
 800139c: 6dfb         	ldr	r3, [r7, #0x5c]
 800139e: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80013a2: 1ad3         	subs	r3, r2, r3
 80013a4: 089b         	lsrs	r3, r3, #0x2
 80013a6: 64fb         	str	r3, [r7, #0x4c]
; 				if (do_ro && s_ptr_idx > STR_POS_MASK) {
 80013a8: f897 3052    	ldrb.w	r3, [r7, #0x52]
 80013ac: 2b00         	cmp	r3, #0x0
 80013ae: d005         	beq	0x80013bc <cbvprintf_package+0x470> @ imm = #0xa
 80013b0: 6cfb         	ldr	r3, [r7, #0x4c]
 80013b2: 2b7f         	cmp	r3, #0x7f
 80013b4: d902         	bls	0x80013bc <cbvprintf_package+0x470> @ imm = #0x4
; 					return -EINVAL;
 80013b6: f06f 0315    	mvn	r3, #0x15
 80013ba: e19f         	b	0x80016fc <cbvprintf_package+0x7b0> @ imm = #0x33e
; 				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
 80013bc: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80013c0: 2b0f         	cmp	r3, #0xf
 80013c2: d902         	bls	0x80013ca <cbvprintf_package+0x47e> @ imm = #0x4
; 					return -EINVAL;
 80013c4: f06f 0315    	mvn	r3, #0x15
 80013c8: e198         	b	0x80016fc <cbvprintf_package+0x7b0> @ imm = #0x330
; 				if (buf0 != NULL) {
 80013ca: 6dfb         	ldr	r3, [r7, #0x5c]
 80013cc: 2b00         	cmp	r3, #0x0
 80013ce: d02d         	beq	0x800142c <cbvprintf_package+0x4e0> @ imm = #0x5a
; 					str_ptr_pos[s_idx] = s_ptr_idx;
 80013d0: 6cfb         	ldr	r3, [r7, #0x4c]
 80013d2: b2d9         	uxtb	r1, r3
 80013d4: f107 0230    	add.w	r2, r7, #0x30
 80013d8: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80013dc: 4413         	add	r3, r2
 80013de: 460a         	mov	r2, r1
 80013e0: 701a         	strb	r2, [r3]
; 					str_ptr_arg[s_idx] = arg_idx;
 80013e2: 6f7b         	ldr	r3, [r7, #0x74]
 80013e4: b2d9         	uxtb	r1, r3
 80013e6: f107 0220    	add.w	r2, r7, #0x20
 80013ea: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80013ee: 4413         	add	r3, r2
 80013f0: 460a         	mov	r2, r1
 80013f2: 701a         	strb	r2, [r3]
; 					if (is_ro) {
 80013f4: f897 3053    	ldrb.w	r3, [r7, #0x53]
 80013f8: 2b00         	cmp	r3, #0x0
 80013fa: d013         	beq	0x8001424 <cbvprintf_package+0x4d8> @ imm = #0x26
; 						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
 80013fc: f107 0230    	add.w	r2, r7, #0x30
 8001400: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8001404: 4413         	add	r3, r2
 8001406: 781b         	ldrb	r3, [r3]
 8001408: f063 037f    	orn	r3, r3, #0x7f
 800140c: b2d9         	uxtb	r1, r3
 800140e: f107 0230    	add.w	r2, r7, #0x30
 8001412: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8001416: 4413         	add	r3, r2
 8001418: 460a         	mov	r2, r1
 800141a: 701a         	strb	r2, [r3]
; 						s_ro_cnt++;
 800141c: 6fbb         	ldr	r3, [r7, #0x78]
 800141e: 3301         	adds	r3, #0x1
 8001420: 67bb         	str	r3, [r7, #0x78]
 8001422: e01b         	b	0x800145c <cbvprintf_package+0x510> @ imm = #0x36
; 						s_rw_cnt++;
 8001424: 6ffb         	ldr	r3, [r7, #0x7c]
 8001426: 3301         	adds	r3, #0x1
 8001428: 67fb         	str	r3, [r7, #0x7c]
 800142a: e017         	b	0x800145c <cbvprintf_package+0x510> @ imm = #0x2e
; 				} else if (is_ro) {
 800142c: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8001430: 2b00         	cmp	r3, #0x0
 8001432: d003         	beq	0x800143c <cbvprintf_package+0x4f0> @ imm = #0x6
; 					len += 1;
 8001434: 68bb         	ldr	r3, [r7, #0x8]
 8001436: 3301         	adds	r3, #0x1
 8001438: 60bb         	str	r3, [r7, #0x8]
 800143a: e00f         	b	0x800145c <cbvprintf_package+0x510> @ imm = #0x1e
; 				} else if (rws_pos_en) {
 800143c: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8001440: 2b00         	cmp	r3, #0x0
 8001442: d003         	beq	0x800144c <cbvprintf_package+0x500> @ imm = #0x6
; 					len += 2;
 8001444: 68bb         	ldr	r3, [r7, #0x8]
 8001446: 3302         	adds	r3, #0x2
 8001448: 60bb         	str	r3, [r7, #0x8]
 800144a: e007         	b	0x800145c <cbvprintf_package+0x510> @ imm = #0xe
; 					len += strlen(s) + 1 + 1;
 800144c: 6ef8         	ldr	r0, [r7, #0x6c]
 800144e: f7ff fb75    	bl	0x8000b3c <strlen>      @ imm = #-0x916
 8001452: 4602         	mov	r2, r0
 8001454: 68bb         	ldr	r3, [r7, #0x8]
 8001456: 4413         	add	r3, r2
 8001458: 3302         	adds	r3, #0x2
 800145a: 60bb         	str	r3, [r7, #0x8]
; 				s_idx++;
 800145c: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8001460: 3301         	adds	r3, #0x1
 8001462: f8c7 3080    	str.w	r3, [r7, #0x80]
; 			buf += sizeof(char *);
 8001466: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800146a: 3304         	adds	r3, #0x4
 800146c: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 			is_str_arg = false;
 8001470: 2300         	movs	r3, #0x0
 8001472: f887 3063    	strb.w	r3, [r7, #0x63]
 8001476: e055         	b	0x8001524 <cbvprintf_package+0x5d8> @ imm = #0xaa
; 		} else if (size == sizeof(int)) {
 8001478: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800147c: 2b04         	cmp	r3, #0x4
 800147e: d113         	bne	0x80014a8 <cbvprintf_package+0x55c> @ imm = #0x26
; 			int v = va_arg(ap, int);
 8001480: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8001484: 1d1a         	adds	r2, r3, #0x4
 8001486: f8c7 2098    	str.w	r2, [r7, #0x98]
 800148a: 681b         	ldr	r3, [r3]
 800148c: 647b         	str	r3, [r7, #0x44]
; 			if (buf0 != NULL) {
 800148e: 6dfb         	ldr	r3, [r7, #0x5c]
 8001490: 2b00         	cmp	r3, #0x0
 8001492: d003         	beq	0x800149c <cbvprintf_package+0x550> @ imm = #0x6
; 				*(int *)buf = v;
 8001494: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001498: 6c7a         	ldr	r2, [r7, #0x44]
 800149a: 601a         	str	r2, [r3]
; 			buf += sizeof(int);
 800149c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80014a0: 3304         	adds	r3, #0x4
 80014a2: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80014a6: e03d         	b	0x8001524 <cbvprintf_package+0x5d8> @ imm = #0x7a
; 		} else if (size == sizeof(long)) {
 80014a8: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80014ac: 2b04         	cmp	r3, #0x4
 80014ae: d113         	bne	0x80014d8 <cbvprintf_package+0x58c> @ imm = #0x26
; 			long v = va_arg(ap, long);
 80014b0: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 80014b4: 1d1a         	adds	r2, r3, #0x4
 80014b6: f8c7 2098    	str.w	r2, [r7, #0x98]
 80014ba: 681b         	ldr	r3, [r3]
 80014bc: 64bb         	str	r3, [r7, #0x48]
; 			if (buf0 != NULL) {
 80014be: 6dfb         	ldr	r3, [r7, #0x5c]
 80014c0: 2b00         	cmp	r3, #0x0
 80014c2: d003         	beq	0x80014cc <cbvprintf_package+0x580> @ imm = #0x6
; 				*(long *)buf = v;
 80014c4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80014c8: 6cba         	ldr	r2, [r7, #0x48]
 80014ca: 601a         	str	r2, [r3]
; 			buf += sizeof(long);
 80014cc: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80014d0: 3304         	adds	r3, #0x4
 80014d2: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80014d6: e025         	b	0x8001524 <cbvprintf_package+0x5d8> @ imm = #0x4a
; 		} else if (size == sizeof(long long)) {
 80014d8: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80014dc: 2b08         	cmp	r3, #0x8
 80014de: d11b         	bne	0x8001518 <cbvprintf_package+0x5cc> @ imm = #0x36
; 			long long v = va_arg(ap, long long);
 80014e0: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 80014e4: 3307         	adds	r3, #0x7
 80014e6: f023 0307    	bic	r3, r3, #0x7
 80014ea: f103 0208    	add.w	r2, r3, #0x8
 80014ee: f8c7 2098    	str.w	r2, [r7, #0x98]
 80014f2: e9d3 2300    	ldrd	r2, r3, [r3]
 80014f6: e9c7 2304    	strd	r2, r3, [r7, #16]
; 			if (buf0 != NULL) {
 80014fa: 6dfb         	ldr	r3, [r7, #0x5c]
 80014fc: 2b00         	cmp	r3, #0x0
 80014fe: d005         	beq	0x800150c <cbvprintf_package+0x5c0> @ imm = #0xa
; 					*(long long *)buf = v;
 8001500: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8001504: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8001508: e9c1 2300    	strd	r2, r3, [r1]
; 			buf += sizeof(long long);
 800150c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001510: 3308         	adds	r3, #0x8
 8001512: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8001516: e005         	b	0x8001524 <cbvprintf_package+0x5d8> @ imm = #0xa
; 			return -EINVAL;
 8001518: f06f 0315    	mvn	r3, #0x15
 800151c: e0ee         	b	0x80016fc <cbvprintf_package+0x7b0> @ imm = #0x1dc
; 				continue;
 800151e: bf00         	nop
 8001520: e000         	b	0x8001524 <cbvprintf_package+0x5d8> @ imm = #0x0
; 				continue;
 8001522: bf00         	nop
; 			if (*++fmt == '\0') {
 8001524: 683b         	ldr	r3, [r7]
 8001526: 3301         	adds	r3, #0x1
 8001528: 603b         	str	r3, [r7]
 800152a: 683b         	ldr	r3, [r7]
 800152c: 781b         	ldrb	r3, [r3]
 800152e: 2b00         	cmp	r3, #0x0
 8001530: f47f ad71    	bne.w	0x8001016 <cbvprintf_package+0xca> @ imm = #-0x51e
; 				break;
 8001534: bf00         	nop
; 	if ((BUF_OFFSET / sizeof(int)) > 255) {
 8001536: 6dfb         	ldr	r3, [r7, #0x5c]
 8001538: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 800153c: 1ad3         	subs	r3, r2, r3
 800153e: f5b3 6f80    	cmp.w	r3, #0x400
 8001542: d302         	blo	0x800154a <cbvprintf_package+0x5fe> @ imm = #0x4
; 		return -EINVAL;
 8001544: f06f 0315    	mvn	r3, #0x15
 8001548: e0d8         	b	0x80016fc <cbvprintf_package+0x7b0> @ imm = #0x1b0
; 	if (buf0 == NULL) {
 800154a: 6dfb         	ldr	r3, [r7, #0x5c]
 800154c: 2b00         	cmp	r3, #0x0
 800154e: d107         	bne	0x8001560 <cbvprintf_package+0x614> @ imm = #0xe
; 		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
 8001550: 6dfb         	ldr	r3, [r7, #0x5c]
 8001552: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001556: 1ad2         	subs	r2, r2, r3
 8001558: 68bb         	ldr	r3, [r7, #0x8]
 800155a: 4413         	add	r3, r2
 800155c: 3b08         	subs	r3, #0x8
 800155e: e0cd         	b	0x80016fc <cbvprintf_package+0x7b0> @ imm = #0x19a
; 	*(char **)buf0 = NULL;
 8001560: 6dfb         	ldr	r3, [r7, #0x5c]
 8001562: 2200         	movs	r2, #0x0
 8001564: 601a         	str	r2, [r3]
; 	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
 8001566: 6dfb         	ldr	r3, [r7, #0x5c]
 8001568: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 800156c: 1ad3         	subs	r3, r2, r3
 800156e: 089b         	lsrs	r3, r3, #0x2
 8001570: b2da         	uxtb	r2, r3
 8001572: 6d7b         	ldr	r3, [r7, #0x54]
 8001574: 701a         	strb	r2, [r3]
; 	if (rws_pos_en) {
 8001576: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 800157a: 2b00         	cmp	r3, #0x0
 800157c: d007         	beq	0x800158e <cbvprintf_package+0x642> @ imm = #0xe
; 		pkg_hdr->desc.str_cnt = 0;
 800157e: 6d7b         	ldr	r3, [r7, #0x54]
 8001580: 2200         	movs	r2, #0x0
 8001582: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
 8001584: 6ffb         	ldr	r3, [r7, #0x7c]
 8001586: b2da         	uxtb	r2, r3
 8001588: 6d7b         	ldr	r3, [r7, #0x54]
 800158a: 70da         	strb	r2, [r3, #0x3]
 800158c: e006         	b	0x800159c <cbvprintf_package+0x650> @ imm = #0xc
; 		pkg_hdr->desc.str_cnt = s_rw_cnt;
 800158e: 6ffb         	ldr	r3, [r7, #0x7c]
 8001590: b2da         	uxtb	r2, r3
 8001592: 6d7b         	ldr	r3, [r7, #0x54]
 8001594: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = 0;
 8001596: 6d7b         	ldr	r3, [r7, #0x54]
 8001598: 2200         	movs	r2, #0x0
 800159a: 70da         	strb	r2, [r3, #0x3]
; 	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
 800159c: 6fbb         	ldr	r3, [r7, #0x78]
 800159e: b2da         	uxtb	r2, r3
 80015a0: 6d7b         	ldr	r3, [r7, #0x54]
 80015a2: 709a         	strb	r2, [r3, #0x2]
; 	if (s_ro_cnt != 0U) {
 80015a4: 6fbb         	ldr	r3, [r7, #0x78]
 80015a6: 2b00         	cmp	r3, #0x0
 80015a8: d032         	beq	0x8001610 <cbvprintf_package+0x6c4> @ imm = #0x64
; 		for (i = 0; i < s_idx; i++) {
 80015aa: 2300         	movs	r3, #0x0
 80015ac: 673b         	str	r3, [r7, #0x70]
 80015ae: e02a         	b	0x8001606 <cbvprintf_package+0x6ba> @ imm = #0x54
; 			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
 80015b0: f107 0230    	add.w	r2, r7, #0x30
 80015b4: 6f3b         	ldr	r3, [r7, #0x70]
 80015b6: 4413         	add	r3, r2
 80015b8: 781b         	ldrb	r3, [r3]
 80015ba: b25b         	sxtb	r3, r3
 80015bc: 2b00         	cmp	r3, #0x0
 80015be: da1e         	bge	0x80015fe <cbvprintf_package+0x6b2> @ imm = #0x3c
; 			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
 80015c0: f107 0230    	add.w	r2, r7, #0x30
 80015c4: 6f3b         	ldr	r3, [r7, #0x70]
 80015c6: 4413         	add	r3, r2
 80015c8: 781b         	ldrb	r3, [r3]
 80015ca: f003 037f    	and	r3, r3, #0x7f
 80015ce: f887 3043    	strb.w	r3, [r7, #0x43]
; 			if ((BUF_OFFSET + 1) > len) {
 80015d2: 6dfb         	ldr	r3, [r7, #0x5c]
 80015d4: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80015d8: 1ad3         	subs	r3, r2, r3
 80015da: 3301         	adds	r3, #0x1
 80015dc: 68ba         	ldr	r2, [r7, #0x8]
 80015de: 429a         	cmp	r2, r3
 80015e0: d202         	bhs	0x80015e8 <cbvprintf_package+0x69c> @ imm = #0x4
; 				return -ENOSPC;
 80015e2: f06f 031b    	mvn	r3, #0x1b
 80015e6: e089         	b	0x80016fc <cbvprintf_package+0x7b0> @ imm = #0x112
; 			*(uint8_t *)buf = pos;
 80015e8: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80015ec: f897 2043    	ldrb.w	r2, [r7, #0x43]
 80015f0: 701a         	strb	r2, [r3]
; 			++buf;
 80015f2: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80015f6: 3301         	adds	r3, #0x1
 80015f8: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80015fc: e000         	b	0x8001600 <cbvprintf_package+0x6b4> @ imm = #0x0
; 				continue;
 80015fe: bf00         	nop
; 		for (i = 0; i < s_idx; i++) {
 8001600: 6f3b         	ldr	r3, [r7, #0x70]
 8001602: 3301         	adds	r3, #0x1
 8001604: 673b         	str	r3, [r7, #0x70]
 8001606: 6f3a         	ldr	r2, [r7, #0x70]
 8001608: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800160c: 429a         	cmp	r2, r3
 800160e: d3cf         	blo	0x80015b0 <cbvprintf_package+0x664> @ imm = #-0x62
; 	for (i = 0; i < s_idx; i++) {
 8001610: 2300         	movs	r3, #0x0
 8001612: 673b         	str	r3, [r7, #0x70]
 8001614: e069         	b	0x80016ea <cbvprintf_package+0x79e> @ imm = #0xd2
; 		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
 8001616: 6fbb         	ldr	r3, [r7, #0x78]
 8001618: 2b00         	cmp	r3, #0x0
 800161a: d007         	beq	0x800162c <cbvprintf_package+0x6e0> @ imm = #0xe
 800161c: f107 0230    	add.w	r2, r7, #0x30
 8001620: 6f3b         	ldr	r3, [r7, #0x70]
 8001622: 4413         	add	r3, r2
 8001624: 781b         	ldrb	r3, [r3]
 8001626: b25b         	sxtb	r3, r3
 8001628: 2b00         	cmp	r3, #0x0
 800162a: db5a         	blt	0x80016e2 <cbvprintf_package+0x796> @ imm = #0xb4
; 		if (rws_pos_en) {
 800162c: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8001630: 2b00         	cmp	r3, #0x0
 8001632: d010         	beq	0x8001656 <cbvprintf_package+0x70a> @ imm = #0x20
; 			size = 0;
 8001634: 2300         	movs	r3, #0x0
 8001636: f8c7 3088    	str.w	r3, [r7, #0x88]
; 			*(uint8_t *)buf = str_ptr_arg[i];
 800163a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800163e: f107 0120    	add.w	r1, r7, #0x20
 8001642: 6f3a         	ldr	r2, [r7, #0x70]
 8001644: 440a         	add	r2, r1
 8001646: 7812         	ldrb	r2, [r2]
 8001648: 701a         	strb	r2, [r3]
; 			++buf;
 800164a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800164e: 3301         	adds	r3, #0x1
 8001650: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8001654: e01a         	b	0x800168c <cbvprintf_package+0x740> @ imm = #0x34
; 			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
 8001656: f107 0230    	add.w	r2, r7, #0x30
 800165a: 6f3b         	ldr	r3, [r7, #0x70]
 800165c: 4413         	add	r3, r2
 800165e: 781b         	ldrb	r3, [r3]
 8001660: 009b         	lsls	r3, r3, #0x2
 8001662: 6dfa         	ldr	r2, [r7, #0x5c]
 8001664: 4413         	add	r3, r2
 8001666: 681b         	ldr	r3, [r3]
 8001668: 66fb         	str	r3, [r7, #0x6c]
; 			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
 800166a: f107 0230    	add.w	r2, r7, #0x30
 800166e: 6f3b         	ldr	r3, [r7, #0x70]
 8001670: 4413         	add	r3, r2
 8001672: 781b         	ldrb	r3, [r3]
 8001674: 009b         	lsls	r3, r3, #0x2
 8001676: 6dfa         	ldr	r2, [r7, #0x5c]
 8001678: 4413         	add	r3, r2
 800167a: 2200         	movs	r2, #0x0
 800167c: 601a         	str	r2, [r3]
; 			size = strlen(s) + 1;
 800167e: 6ef8         	ldr	r0, [r7, #0x6c]
 8001680: f7ff fa5c    	bl	0x8000b3c <strlen>      @ imm = #-0xb48
 8001684: 4603         	mov	r3, r0
 8001686: 3301         	adds	r3, #0x1
 8001688: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		if ((BUF_OFFSET + 1 + size) > len) {
 800168c: 6dfb         	ldr	r3, [r7, #0x5c]
 800168e: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001692: 1ad2         	subs	r2, r2, r3
 8001694: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8001698: 4413         	add	r3, r2
 800169a: 3301         	adds	r3, #0x1
 800169c: 68ba         	ldr	r2, [r7, #0x8]
 800169e: 429a         	cmp	r2, r3
 80016a0: d202         	bhs	0x80016a8 <cbvprintf_package+0x75c> @ imm = #0x4
; 			return -ENOSPC;
 80016a2: f06f 031b    	mvn	r3, #0x1b
 80016a6: e029         	b	0x80016fc <cbvprintf_package+0x7b0> @ imm = #0x52
; 		*(uint8_t *)buf = str_ptr_pos[i];
 80016a8: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80016ac: f107 0130    	add.w	r1, r7, #0x30
 80016b0: 6f3a         	ldr	r2, [r7, #0x70]
 80016b2: 440a         	add	r2, r1
 80016b4: 7812         	ldrb	r2, [r2]
 80016b6: 701a         	strb	r2, [r3]
; 		++buf;
 80016b8: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80016bc: 3301         	adds	r3, #0x1
 80016be: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		memcpy((void *)buf, (uint8_t *)s, size);
 80016c2: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80016c6: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 80016ca: 6ef9         	ldr	r1, [r7, #0x6c]
 80016cc: 4618         	mov	r0, r3
 80016ce: f019 f8a1    	bl	0x801a814 <memcpy>      @ imm = #0x19142
; 		buf += size;
 80016d2: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80016d6: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80016da: 4413         	add	r3, r2
 80016dc: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80016e0: e000         	b	0x80016e4 <cbvprintf_package+0x798> @ imm = #0x0
; 			continue;
 80016e2: bf00         	nop
; 	for (i = 0; i < s_idx; i++) {
 80016e4: 6f3b         	ldr	r3, [r7, #0x70]
 80016e6: 3301         	adds	r3, #0x1
 80016e8: 673b         	str	r3, [r7, #0x70]
 80016ea: 6f3a         	ldr	r2, [r7, #0x70]
 80016ec: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80016f0: 429a         	cmp	r2, r3
 80016f2: d390         	blo	0x8001616 <cbvprintf_package+0x6ca> @ imm = #-0xe0
; 	return BUF_OFFSET;
 80016f4: 6dfb         	ldr	r3, [r7, #0x5c]
 80016f6: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80016fa: 1ad3         	subs	r3, r2, r3
; }
 80016fc: 4618         	mov	r0, r3
 80016fe: 3790         	adds	r7, #0x90
 8001700: 46bd         	mov	sp, r7
 8001702: bd80         	pop	{r7, pc}

08001704 <__printk_hook_install>:
; {
 8001704: b480         	push	{r7}
 8001706: b083         	sub	sp, #0xc
 8001708: af00         	add	r7, sp, #0x0
 800170a: 6078         	str	r0, [r7, #0x4]
; 	_char_out = fn;
 800170c: 4a03         	ldr	r2, [pc, #0xc]          @ 0x800171c <__printk_hook_install+0x18>
 800170e: 687b         	ldr	r3, [r7, #0x4]
 8001710: 6013         	str	r3, [r2]
; }
 8001712: bf00         	nop
 8001714: 370c         	adds	r7, #0xc
 8001716: 46bd         	mov	sp, r7
 8001718: bc80         	pop	{r7}
 800171a: 4770         	bx	lr

0800171c <$d>:
 800171c: 10 04 00 20  	.word	0x20000410

08001720 <k_current_get>:
; {
 8001720: b580         	push	{r7, lr}
 8001722: af00         	add	r7, sp, #0x0
; 	return z_tls_current;
 8001724: f019 fa5a    	bl	0x801abdc <__aeabi_read_tp> @ imm = #0x194b4
 8001728: 4603         	mov	r3, r0
 800172a: 4a02         	ldr	r2, [pc, #0x8]          @ 0x8001734 <k_current_get+0x14>
 800172c: 589b         	ldr	r3, [r3, r2]
; }
 800172e: 4618         	mov	r0, r3
 8001730: bd80         	pop	{r7, pc}
 8001732: bf00         	nop

08001734 <$d>:
 8001734: 08 00 00 00  	.word	0x00000008

08001738 <z_thread_entry>:
; {
 8001738: b580         	push	{r7, lr}
 800173a: b084         	sub	sp, #0x10
 800173c: af00         	add	r7, sp, #0x0
 800173e: 60f8         	str	r0, [r7, #0xc]
 8001740: 60b9         	str	r1, [r7, #0x8]
 8001742: 607a         	str	r2, [r7, #0x4]
 8001744: 603b         	str	r3, [r7]
; 	z_tls_current = k_sched_current_thread_query();
 8001746: f010 fa4c    	bl	0x8011be2 <k_sched_current_thread_query> @ imm = #0x10498
 800174a: 4602         	mov	r2, r0
 800174c: f019 fa46    	bl	0x801abdc <__aeabi_read_tp> @ imm = #0x1948c
 8001750: 4603         	mov	r3, r0
 8001752: 4906         	ldr	r1, [pc, #0x18]         @ 0x800176c <z_thread_entry+0x34>
 8001754: 505a         	str	r2, [r3, r1]
; 	entry(p1, p2, p3);
 8001756: 68fb         	ldr	r3, [r7, #0xc]
 8001758: 683a         	ldr	r2, [r7]
 800175a: 6879         	ldr	r1, [r7, #0x4]
 800175c: 68b8         	ldr	r0, [r7, #0x8]
 800175e: 4798         	blx	r3
; 	k_thread_abort(k_current_get());
 8001760: f7ff ffde    	bl	0x8001720 <k_current_get> @ imm = #-0x44
 8001764: 4603         	mov	r3, r0
 8001766: 4618         	mov	r0, r3
 8001768: f010 fa42    	bl	0x8011bf0 <k_thread_abort> @ imm = #0x10484

0800176c <$d>:
 800176c: 08 00 00 00  	.word	0x00000008

08001770 <LL_DBGMCU_DisableDBGStopMode>:
; {
 8001770: b480         	push	{r7}
 8001772: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8001774: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8001788 <LL_DBGMCU_DisableDBGStopMode+0x18>
 8001776: 685b         	ldr	r3, [r3, #0x4]
 8001778: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8001788 <LL_DBGMCU_DisableDBGStopMode+0x18>
 800177a: f023 0302    	bic	r3, r3, #0x2
 800177e: 6053         	str	r3, [r2, #0x4]
; }
 8001780: bf00         	nop
 8001782: 46bd         	mov	sp, r7
 8001784: bc80         	pop	{r7}
 8001786: 4770         	bx	lr

08001788 <$d>:
 8001788: 00 20 04 e0  	.word	0xe0042000

0800178c <LL_FLASH_EnablePrefetch>:
; {
 800178c: b480         	push	{r7}
 800178e: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_PRFTEN);
 8001790: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80017a4 <LL_FLASH_EnablePrefetch+0x18>
 8001792: 681b         	ldr	r3, [r3]
 8001794: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80017a4 <LL_FLASH_EnablePrefetch+0x18>
 8001796: f443 7380    	orr	r3, r3, #0x100
 800179a: 6013         	str	r3, [r2]
; }
 800179c: bf00         	nop
 800179e: 46bd         	mov	sp, r7
 80017a0: bc80         	pop	{r7}
 80017a2: 4770         	bx	lr

080017a4 <$d>:
 80017a4: 00 3c 02 40  	.word	0x40023c00

080017a8 <LL_FLASH_EnableInstCache>:
; {
 80017a8: b480         	push	{r7}
 80017aa: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_ICEN);
 80017ac: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80017c0 <LL_FLASH_EnableInstCache+0x18>
 80017ae: 681b         	ldr	r3, [r3]
 80017b0: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80017c0 <LL_FLASH_EnableInstCache+0x18>
 80017b2: f443 7300    	orr	r3, r3, #0x200
 80017b6: 6013         	str	r3, [r2]
; }
 80017b8: bf00         	nop
 80017ba: 46bd         	mov	sp, r7
 80017bc: bc80         	pop	{r7}
 80017be: 4770         	bx	lr

080017c0 <$d>:
 80017c0: 00 3c 02 40  	.word	0x40023c00

080017c4 <LL_FLASH_EnableDataCache>:
; {
 80017c4: b480         	push	{r7}
 80017c6: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_DCEN);
 80017c8: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80017dc <LL_FLASH_EnableDataCache+0x18>
 80017ca: 681b         	ldr	r3, [r3]
 80017cc: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80017dc <LL_FLASH_EnableDataCache+0x18>
 80017ce: f443 6380    	orr	r3, r3, #0x400
 80017d2: 6013         	str	r3, [r2]
; }
 80017d4: bf00         	nop
 80017d6: 46bd         	mov	sp, r7
 80017d8: bc80         	pop	{r7}
 80017da: 4770         	bx	lr

080017dc <$d>:
 80017dc: 00 3c 02 40  	.word	0x40023c00

080017e0 <soc_early_init_hook>:
; {
 80017e0: b580         	push	{r7, lr}
 80017e2: af00         	add	r7, sp, #0x0
; 	LL_FLASH_EnablePrefetch();
 80017e4: f7ff ffd2    	bl	0x800178c <LL_FLASH_EnablePrefetch> @ imm = #-0x5c
; 	LL_FLASH_EnableInstCache();
 80017e8: f7ff ffde    	bl	0x80017a8 <LL_FLASH_EnableInstCache> @ imm = #-0x44
; 	LL_FLASH_EnableDataCache();
 80017ec: f7ff ffea    	bl	0x80017c4 <LL_FLASH_EnableDataCache> @ imm = #-0x2c
; 	SystemCoreClock = 16000000;
 80017f0: 4b02         	ldr	r3, [pc, #0x8]          @ 0x80017fc <soc_early_init_hook+0x1c>
 80017f2: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8001800 <soc_early_init_hook+0x20>
 80017f4: 601a         	str	r2, [r3]
; }
 80017f6: bf00         	nop
 80017f8: bd80         	pop	{r7, pc}
 80017fa: bf00         	nop

080017fc <$d>:
 80017fc: 34 05 00 20  	.word	0x20000534
 8001800: 00 24 f4 00  	.word	0x00f42400

08001804 <log_backend_get>:
; {
 8001804: b480         	push	{r7}
 8001806: b085         	sub	sp, #0x14
 8001808: af00         	add	r7, sp, #0x0
 800180a: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 800180c: 687b         	ldr	r3, [r7, #0x4]
 800180e: 011b         	lsls	r3, r3, #0x4
 8001810: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8001824 <log_backend_get+0x20>
 8001812: 4413         	add	r3, r2
 8001814: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 8001816: 68fb         	ldr	r3, [r7, #0xc]
; }
 8001818: 4618         	mov	r0, r3
 800181a: 3714         	adds	r7, #0x14
 800181c: 46bd         	mov	sp, r7
 800181e: bc80         	pop	{r7}
 8001820: 4770         	bx	lr
 8001822: bf00         	nop

08001824 <$d>:
 8001824: a8 b2 01 08  	.word	0x0801b2a8

08001828 <log_format_func_t_get>:
; {
 8001828: b480         	push	{r7}
 800182a: b083         	sub	sp, #0xc
 800182c: af00         	add	r7, sp, #0x0
 800182e: 6078         	str	r0, [r7, #0x4]
; 	return format_table[log_type];
 8001830: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8001844 <log_format_func_t_get+0x1c>
 8001832: 687b         	ldr	r3, [r7, #0x4]
 8001834: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 8001838: 4618         	mov	r0, r3
 800183a: 370c         	adds	r7, #0xc
 800183c: 46bd         	mov	sp, r7
 800183e: bc80         	pop	{r7}
 8001840: 4770         	bx	lr
 8001842: bf00         	nop

08001844 <$d>:
 8001844: 00 d0 01 08  	.word	0x0801d000

08001848 <log_core_init>:
; {
 8001848: b580         	push	{r7, lr}
 800184a: af00         	add	r7, sp, #0x0
; 	panic_mode = false;
 800184c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800186c <log_core_init+0x24>
 800184e: 2200         	movs	r2, #0x0
 8001850: 701a         	strb	r2, [r3]
; 	dropped_cnt = 0;
 8001852: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8001870 <log_core_init+0x28>
 8001854: 2200         	movs	r2, #0x0
 8001856: 601a         	str	r2, [r3]
; 	buffered_cnt = 0;
 8001858: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8001874 <log_core_init+0x2c>
 800185a: 2200         	movs	r2, #0x0
 800185c: 601a         	str	r2, [r3]
; 		log_set_timestamp_func(default_lf_get_timestamp, 1000U);
 800185e: f44f 717a    	mov.w	r1, #0x3e8
 8001862: 4805         	ldr	r0, [pc, #0x14]         @ 0x8001878 <log_core_init+0x30>
 8001864: f000 f86a    	bl	0x800193c <log_set_timestamp_func> @ imm = #0xd4
; }
 8001868: bd80         	pop	{r7, pc}
 800186a: bf00         	nop

0800186c <$d>:
 800186c: 40 11 00 20  	.word	0x20001140
 8001870: f8 0a 00 20  	.word	0x20000af8
 8001874: f4 0a 00 20  	.word	0x20000af4
 8001878: 75 1e 01 08  	.word	0x08011e75

0800187c <z_log_init>:
; {
 800187c: b580         	push	{r7, lr}
 800187e: b086         	sub	sp, #0x18
 8001880: af00         	add	r7, sp, #0x0
 8001882: 4603         	mov	r3, r0
 8001884: 460a         	mov	r2, r1
 8001886: 71fb         	strb	r3, [r7, #0x7]
 8001888: 4613         	mov	r3, r2
 800188a: 71bb         	strb	r3, [r7, #0x6]
; 	uint32_t mask = 0;
 800188c: 2300         	movs	r3, #0x0
 800188e: 617b         	str	r3, [r7, #0x14]
; 	if (atomic_inc(&initialized) != 0) {
 8001890: 4827         	ldr	r0, [pc, #0x9c]         @ 0x8001930 <z_log_init+0xb4>
 8001892: f010 f9f7    	bl	0x8011c84 <atomic_inc>  @ imm = #0x103ee
 8001896: 4603         	mov	r3, r0
 8001898: 2b00         	cmp	r3, #0x0
 800189a: d001         	beq	0x80018a0 <z_log_init+0x24> @ imm = #0x2
; 		return 0;
 800189c: 2300         	movs	r3, #0x0
 800189e: e042         	b	0x8001926 <z_log_init+0xaa> @ imm = #0x84
; 	int backend_index = 0;
 80018a0: 2300         	movs	r3, #0x0
 80018a2: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80018a4: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8001934 <z_log_init+0xb8>
 80018a6: 60fb         	str	r3, [r7, #0xc]
 80018a8: e022         	b	0x80018f0 <z_log_init+0x74> @ imm = #0x44
; 		if (backend->autostart) {
 80018aa: 68fb         	ldr	r3, [r7, #0xc]
 80018ac: 7b1b         	ldrb	r3, [r3, #0xc]
 80018ae: 2b00         	cmp	r3, #0x0
 80018b0: d018         	beq	0x80018e4 <z_log_init+0x68> @ imm = #0x30
; 			log_backend_init(backend);
 80018b2: 68f8         	ldr	r0, [r7, #0xc]
 80018b4: f010 fa72    	bl	0x8011d9c <log_backend_init> @ imm = #0x104e4
; 			if (log_backend_is_ready(backend) == 0) {
 80018b8: 68f8         	ldr	r0, [r7, #0xc]
 80018ba: f010 fa81    	bl	0x8011dc0 <log_backend_is_ready> @ imm = #0x10502
 80018be: 4603         	mov	r3, r0
 80018c0: 2b00         	cmp	r3, #0x0
 80018c2: d108         	bne	0x80018d6 <z_log_init+0x5a> @ imm = #0x10
; 						   backend->cb->ctx,
 80018c4: 68fb         	ldr	r3, [r7, #0xc]
 80018c6: 685b         	ldr	r3, [r3, #0x4]
; 				log_backend_enable(backend,
 80018c8: 681b         	ldr	r3, [r3]
 80018ca: 2204         	movs	r2, #0x4
 80018cc: 4619         	mov	r1, r3
 80018ce: 68f8         	ldr	r0, [r7, #0xc]
 80018d0: f010 fbd2    	bl	0x8012078 <log_backend_enable> @ imm = #0x107a4
 80018d4: e006         	b	0x80018e4 <z_log_init+0x68> @ imm = #0xc
; 				mask |= BIT(backend_index);
 80018d6: 2201         	movs	r2, #0x1
 80018d8: 693b         	ldr	r3, [r7, #0x10]
 80018da: fa02 f303    	lsl.w	r3, r2, r3
 80018de: 697a         	ldr	r2, [r7, #0x14]
 80018e0: 4313         	orrs	r3, r2
 80018e2: 617b         	str	r3, [r7, #0x14]
; 		++backend_index;
 80018e4: 693b         	ldr	r3, [r7, #0x10]
 80018e6: 3301         	adds	r3, #0x1
 80018e8: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80018ea: 68fb         	ldr	r3, [r7, #0xc]
 80018ec: 3310         	adds	r3, #0x10
 80018ee: 60fb         	str	r3, [r7, #0xc]
 80018f0: 68fb         	ldr	r3, [r7, #0xc]
 80018f2: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8001938 <z_log_init+0xbc>
 80018f4: 4293         	cmp	r3, r2
 80018f6: bf34         	ite	lo
 80018f8: 2301         	movlo	r3, #0x1
 80018fa: 2300         	movhs	r3, #0x0
 80018fc: b2db         	uxtb	r3, r3
 80018fe: 2b00         	cmp	r3, #0x0
 8001900: d1d3         	bne	0x80018aa <z_log_init+0x2e> @ imm = #-0x5a
; 	if (blocking) {
 8001902: 79fb         	ldrb	r3, [r7, #0x7]
 8001904: 2b00         	cmp	r3, #0x0
 8001906: d00d         	beq	0x8001924 <z_log_init+0xa8> @ imm = #0x1a
; 		while (mask) {
 8001908: e009         	b	0x800191e <z_log_init+0xa2> @ imm = #0x12
; 			mask = activate_foreach_backend(mask);
 800190a: 6978         	ldr	r0, [r7, #0x14]
 800190c: f010 fab9    	bl	0x8011e82 <activate_foreach_backend> @ imm = #0x10572
 8001910: 6178         	str	r0, [r7, #0x14]
; 			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
 8001912: 79bb         	ldrb	r3, [r7, #0x6]
 8001914: 2b00         	cmp	r3, #0x0
 8001916: d002         	beq	0x800191e <z_log_init+0xa2> @ imm = #0x4
; 				k_msleep(10);
 8001918: 200a         	movs	r0, #0xa
 800191a: f010 f9e0    	bl	0x8011cde <k_msleep>    @ imm = #0x103c0
; 		while (mask) {
 800191e: 697b         	ldr	r3, [r7, #0x14]
 8001920: 2b00         	cmp	r3, #0x0
 8001922: d1f2         	bne	0x800190a <z_log_init+0x8e> @ imm = #-0x1c
; 	return mask;
 8001924: 697b         	ldr	r3, [r7, #0x14]
; }
 8001926: 4618         	mov	r0, r3
 8001928: 3718         	adds	r7, #0x18
 800192a: 46bd         	mov	sp, r7
 800192c: bd80         	pop	{r7, pc}
 800192e: bf00         	nop

08001930 <$d>:
 8001930: f0 0a 00 20  	.word	0x20000af0
 8001934: a8 b2 01 08  	.word	0x0801b2a8
 8001938: b8 b2 01 08  	.word	0x0801b2b8

0800193c <log_set_timestamp_func>:
; {
 800193c: b580         	push	{r7, lr}
 800193e: b082         	sub	sp, #0x8
 8001940: af00         	add	r7, sp, #0x0
 8001942: 6078         	str	r0, [r7, #0x4]
 8001944: 6039         	str	r1, [r7]
; 	if (timestamp_getter == NULL) {
 8001946: 687b         	ldr	r3, [r7, #0x4]
 8001948: 2b00         	cmp	r3, #0x0
 800194a: d102         	bne	0x8001952 <log_set_timestamp_func+0x16> @ imm = #0x4
; 		return -EINVAL;
 800194c: f06f 0315    	mvn	r3, #0x15
 8001950: e009         	b	0x8001966 <log_set_timestamp_func+0x2a> @ imm = #0x12
; 	timestamp_func = timestamp_getter;
 8001952: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8001970 <log_set_timestamp_func+0x34>
 8001954: 687b         	ldr	r3, [r7, #0x4]
 8001956: 6013         	str	r3, [r2]
; 	timestamp_freq = freq;
 8001958: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8001974 <log_set_timestamp_func+0x38>
 800195a: 683b         	ldr	r3, [r7]
 800195c: 6013         	str	r3, [r2]
; 		log_output_timestamp_freq_set(freq);
 800195e: 6838         	ldr	r0, [r7]
 8001960: f000 fcea    	bl	0x8002338 <log_output_timestamp_freq_set> @ imm = #0x9d4
; 	return 0;
 8001964: 2300         	movs	r3, #0x0
; }
 8001966: 4618         	mov	r0, r3
 8001968: 3708         	adds	r7, #0x8
 800196a: 46bd         	mov	sp, r7
 800196c: bd80         	pop	{r7, pc}
 800196e: bf00         	nop

08001970 <$d>:
 8001970: 14 04 00 20  	.word	0x20000414
 8001974: fc 0a 00 20  	.word	0x20000afc

08001978 <z_impl_log_panic>:
; {
 8001978: b580         	push	{r7, lr}
 800197a: b082         	sub	sp, #0x8
 800197c: af00         	add	r7, sp, #0x0
; 	if (panic_mode) {
 800197e: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80019d0 <z_impl_log_panic+0x58>
 8001980: 781b         	ldrb	r3, [r3]
 8001982: 2b00         	cmp	r3, #0x0
 8001984: d120         	bne	0x80019c8 <z_impl_log_panic+0x50> @ imm = #0x40
; 	(void)z_log_init(true, false);
 8001986: 2100         	movs	r1, #0x0
 8001988: 2001         	movs	r0, #0x1
 800198a: f7ff ff77    	bl	0x800187c <z_log_init>  @ imm = #-0x112
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 800198e: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80019d4 <z_impl_log_panic+0x5c>
 8001990: 607b         	str	r3, [r7, #0x4]
 8001992: e00b         	b	0x80019ac <z_impl_log_panic+0x34> @ imm = #0x16
; 		if (log_backend_is_active(backend)) {
 8001994: 6878         	ldr	r0, [r7, #0x4]
 8001996: f010 fa44    	bl	0x8011e22 <log_backend_is_active> @ imm = #0x10488
 800199a: 4603         	mov	r3, r0
 800199c: 2b00         	cmp	r3, #0x0
 800199e: d002         	beq	0x80019a6 <z_impl_log_panic+0x2e> @ imm = #0x4
; 			log_backend_panic(backend);
 80019a0: 6878         	ldr	r0, [r7, #0x4]
 80019a2: f010 fa31    	bl	0x8011e08 <log_backend_panic> @ imm = #0x10462
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80019a6: 687b         	ldr	r3, [r7, #0x4]
 80019a8: 3310         	adds	r3, #0x10
 80019aa: 607b         	str	r3, [r7, #0x4]
 80019ac: 687b         	ldr	r3, [r7, #0x4]
 80019ae: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80019d8 <z_impl_log_panic+0x60>
 80019b0: 4293         	cmp	r3, r2
 80019b2: bf34         	ite	lo
 80019b4: 2301         	movlo	r3, #0x1
 80019b6: 2300         	movhs	r3, #0x0
 80019b8: b2db         	uxtb	r3, r3
 80019ba: 2b00         	cmp	r3, #0x0
 80019bc: d1ea         	bne	0x8001994 <z_impl_log_panic+0x1c> @ imm = #-0x2c
; out:
 80019be: bf00         	nop
; 	panic_mode = true;
 80019c0: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80019d0 <z_impl_log_panic+0x58>
 80019c2: 2201         	movs	r2, #0x1
 80019c4: 701a         	strb	r2, [r3]
 80019c6: e000         	b	0x80019ca <z_impl_log_panic+0x52> @ imm = #0x0
; 		return;
 80019c8: bf00         	nop
; }
 80019ca: 3708         	adds	r7, #0x8
 80019cc: 46bd         	mov	sp, r7
 80019ce: bd80         	pop	{r7, pc}

080019d0 <$d>:
 80019d0: 40 11 00 20  	.word	0x20001140
 80019d4: a8 b2 01 08  	.word	0x0801b2a8
 80019d8: b8 b2 01 08  	.word	0x0801b2b8

080019dc <msg_process>:
; {
 80019dc: b580         	push	{r7, lr}
 80019de: b084         	sub	sp, #0x10
 80019e0: af00         	add	r7, sp, #0x0
 80019e2: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80019e4: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8001a30 <msg_process+0x54>
 80019e6: 60fb         	str	r3, [r7, #0xc]
 80019e8: e013         	b	0x8001a12 <msg_process+0x36> @ imm = #0x26
; 		if (log_backend_is_active(backend) &&
 80019ea: 68f8         	ldr	r0, [r7, #0xc]
 80019ec: f010 fa19    	bl	0x8011e22 <log_backend_is_active> @ imm = #0x10432
 80019f0: 4603         	mov	r3, r0
 80019f2: 2b00         	cmp	r3, #0x0
 80019f4: d00a         	beq	0x8001a0c <msg_process+0x30> @ imm = #0x14
; 		    msg_filter_check(backend, msg)) {
 80019f6: 6879         	ldr	r1, [r7, #0x4]
 80019f8: 68f8         	ldr	r0, [r7, #0xc]
 80019fa: f010 fa7d    	bl	0x8011ef8 <msg_filter_check> @ imm = #0x104fa
 80019fe: 4603         	mov	r3, r0
; 		if (log_backend_is_active(backend) &&
 8001a00: 2b00         	cmp	r3, #0x0
 8001a02: d003         	beq	0x8001a0c <msg_process+0x30> @ imm = #0x6
; 			log_backend_msg_process(backend, msg);
 8001a04: 6879         	ldr	r1, [r7, #0x4]
 8001a06: 68f8         	ldr	r0, [r7, #0xc]
 8001a08: f010 f9ef    	bl	0x8011dea <log_backend_msg_process> @ imm = #0x103de
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8001a0c: 68fb         	ldr	r3, [r7, #0xc]
 8001a0e: 3310         	adds	r3, #0x10
 8001a10: 60fb         	str	r3, [r7, #0xc]
 8001a12: 68fb         	ldr	r3, [r7, #0xc]
 8001a14: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8001a34 <msg_process+0x58>
 8001a16: 4293         	cmp	r3, r2
 8001a18: bf34         	ite	lo
 8001a1a: 2301         	movlo	r3, #0x1
 8001a1c: 2300         	movhs	r3, #0x0
 8001a1e: b2db         	uxtb	r3, r3
 8001a20: 2b00         	cmp	r3, #0x0
 8001a22: d1e2         	bne	0x80019ea <msg_process+0xe> @ imm = #-0x3c
; }
 8001a24: bf00         	nop
 8001a26: bf00         	nop
 8001a28: 3710         	adds	r7, #0x10
 8001a2a: 46bd         	mov	sp, r7
 8001a2c: bd80         	pop	{r7, pc}
 8001a2e: bf00         	nop

08001a30 <$d>:
 8001a30: a8 b2 01 08  	.word	0x0801b2a8
 8001a34: b8 b2 01 08  	.word	0x0801b2b8

08001a38 <z_log_notify_backend_enabled>:
; {
 8001a38: b480         	push	{r7}
 8001a3a: af00         	add	r7, sp, #0x0
; 	backend_attached = true;
 8001a3c: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8001a4c <z_log_notify_backend_enabled+0x14>
 8001a3e: 2201         	movs	r2, #0x1
 8001a40: 701a         	strb	r2, [r3]
; }
 8001a42: bf00         	nop
 8001a44: 46bd         	mov	sp, r7
 8001a46: bc80         	pop	{r7}
 8001a48: 4770         	bx	lr
 8001a4a: bf00         	nop

08001a4c <$d>:
 8001a4c: 41 11 00 20  	.word	0x20001141

08001a50 <z_log_dropped>:
; {
 8001a50: b580         	push	{r7, lr}
 8001a52: b082         	sub	sp, #0x8
 8001a54: af00         	add	r7, sp, #0x0
 8001a56: 4603         	mov	r3, r0
 8001a58: 71fb         	strb	r3, [r7, #0x7]
; 	atomic_inc(&dropped_cnt);
 8001a5a: 4806         	ldr	r0, [pc, #0x18]         @ 0x8001a74 <z_log_dropped+0x24>
 8001a5c: f010 f912    	bl	0x8011c84 <atomic_inc>  @ imm = #0x10224
; 	if (buffered) {
 8001a60: 79fb         	ldrb	r3, [r7, #0x7]
 8001a62: 2b00         	cmp	r3, #0x0
 8001a64: d002         	beq	0x8001a6c <z_log_dropped+0x1c> @ imm = #0x4
; 		atomic_dec(&buffered_cnt);
 8001a66: 4804         	ldr	r0, [pc, #0x10]         @ 0x8001a78 <z_log_dropped+0x28>
 8001a68: f010 f919    	bl	0x8011c9e <atomic_dec>  @ imm = #0x10232
; }
 8001a6c: bf00         	nop
 8001a6e: 3708         	adds	r7, #0x8
 8001a70: 46bd         	mov	sp, r7
 8001a72: bd80         	pop	{r7, pc}

08001a74 <$d>:
 8001a74: f8 0a 00 20  	.word	0x20000af8
 8001a78: f4 0a 00 20  	.word	0x20000af4

08001a7c <z_log_msg_commit>:
; {
 8001a7c: b580         	push	{r7, lr}
 8001a7e: b082         	sub	sp, #0x8
 8001a80: af00         	add	r7, sp, #0x0
 8001a82: 6078         	str	r0, [r7, #0x4]
; 	msg->hdr.timestamp = timestamp_func();
 8001a84: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8001aa0 <z_log_msg_commit+0x24>
 8001a86: 681b         	ldr	r3, [r3]
 8001a88: 4798         	blx	r3
 8001a8a: 4602         	mov	r2, r0
 8001a8c: 687b         	ldr	r3, [r7, #0x4]
 8001a8e: 609a         	str	r2, [r3, #0x8]
; 	msg_commit(&log_buffer, msg);
 8001a90: 6879         	ldr	r1, [r7, #0x4]
 8001a92: 4804         	ldr	r0, [pc, #0x10]         @ 0x8001aa4 <z_log_msg_commit+0x28>
 8001a94: f010 fa45    	bl	0x8011f22 <msg_commit>  @ imm = #0x1048a
; }
 8001a98: bf00         	nop
 8001a9a: 3708         	adds	r7, #0x8
 8001a9c: 46bd         	mov	sp, r7
 8001a9e: bd80         	pop	{r7, pc}

08001aa0 <$d>:
 8001aa0: 14 04 00 20  	.word	0x20000414
 8001aa4: 94 05 00 20  	.word	0x20000594

08001aa8 <log_const_source_id>:
; {
 8001aa8: b480         	push	{r7}
 8001aaa: b083         	sub	sp, #0xc
 8001aac: af00         	add	r7, sp, #0x0
 8001aae: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 8001ab0: 687b         	ldr	r3, [r7, #0x4]
 8001ab2: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8001ac4 <log_const_source_id+0x1c>
 8001ab4: 1a9b         	subs	r3, r3, r2
 8001ab6: 08db         	lsrs	r3, r3, #0x3
; }
 8001ab8: 4618         	mov	r0, r3
 8001aba: 370c         	adds	r7, #0xc
 8001abc: 46bd         	mov	sp, r7
 8001abe: bc80         	pop	{r7}
 8001ac0: 4770         	bx	lr
 8001ac2: bf00         	nop

08001ac4 <$d>:
 8001ac4: 20 b2 01 08  	.word	0x0801b220

08001ac8 <z_log_sources_count>:
; {
 8001ac8: b580         	push	{r7, lr}
 8001aca: af00         	add	r7, sp, #0x0
; 	return log_const_source_id(TYPE_SECTION_END(log_const));
 8001acc: 4802         	ldr	r0, [pc, #0x8]          @ 0x8001ad8 <z_log_sources_count+0x10>
 8001ace: f7ff ffeb    	bl	0x8001aa8 <log_const_source_id> @ imm = #-0x2a
 8001ad2: 4603         	mov	r3, r0
; }
 8001ad4: 4618         	mov	r0, r3
 8001ad6: bd80         	pop	{r7, pc}

08001ad8 <$d>:
 8001ad8: a8 b2 01 08  	.word	0x0801b2a8

08001adc <log_backend_get>:
; {
 8001adc: b480         	push	{r7}
 8001ade: b085         	sub	sp, #0x14
 8001ae0: af00         	add	r7, sp, #0x0
 8001ae2: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 8001ae4: 687b         	ldr	r3, [r7, #0x4]
 8001ae6: 011b         	lsls	r3, r3, #0x4
 8001ae8: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8001afc <log_backend_get+0x20>
 8001aea: 4413         	add	r3, r2
 8001aec: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 8001aee: 68fb         	ldr	r3, [r7, #0xc]
; }
 8001af0: 4618         	mov	r0, r3
 8001af2: 3714         	adds	r7, #0x14
 8001af4: 46bd         	mov	sp, r7
 8001af6: bc80         	pop	{r7}
 8001af8: 4770         	bx	lr
 8001afa: bf00         	nop

08001afc <$d>:
 8001afc: a8 b2 01 08  	.word	0x0801b2a8

08001b00 <get_link_domain>:
; {
 8001b00: b480         	push	{r7}
 8001b02: b085         	sub	sp, #0x14
 8001b04: af00         	add	r7, sp, #0x0
 8001b06: 4603         	mov	r3, r0
 8001b08: 6039         	str	r1, [r7]
 8001b0a: 71fb         	strb	r3, [r7, #0x7]
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 8001b0c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8001b70 <get_link_domain+0x70>
 8001b0e: 60fb         	str	r3, [r7, #0xc]
 8001b10: e01b         	b	0x8001b4a <get_link_domain+0x4a> @ imm = #0x36
; 		domain_max = link->ctrl_blk->domain_offset +
 8001b12: 68fb         	ldr	r3, [r7, #0xc]
 8001b14: 689b         	ldr	r3, [r3, #0x8]
 8001b16: 689b         	ldr	r3, [r3, #0x8]
 8001b18: b2da         	uxtb	r2, r3
; 				link->ctrl_blk->domain_cnt;
 8001b1a: 68fb         	ldr	r3, [r7, #0xc]
 8001b1c: 689b         	ldr	r3, [r3, #0x8]
 8001b1e: 681b         	ldr	r3, [r3]
; 		domain_max = link->ctrl_blk->domain_offset +
 8001b20: b2db         	uxtb	r3, r3
 8001b22: 4413         	add	r3, r2
 8001b24: 72fb         	strb	r3, [r7, #0xb]
; 		if (domain_id < domain_max) {
 8001b26: 79fa         	ldrb	r2, [r7, #0x7]
 8001b28: 7afb         	ldrb	r3, [r7, #0xb]
 8001b2a: 429a         	cmp	r2, r3
 8001b2c: d20a         	bhs	0x8001b44 <get_link_domain+0x44> @ imm = #0x14
; 			*rel_domain_id = domain_id - link->ctrl_blk->domain_offset;
 8001b2e: 68fb         	ldr	r3, [r7, #0xc]
 8001b30: 689b         	ldr	r3, [r3, #0x8]
 8001b32: 689b         	ldr	r3, [r3, #0x8]
 8001b34: b2db         	uxtb	r3, r3
 8001b36: 79fa         	ldrb	r2, [r7, #0x7]
 8001b38: 1ad3         	subs	r3, r2, r3
 8001b3a: b2da         	uxtb	r2, r3
 8001b3c: 683b         	ldr	r3, [r7]
 8001b3e: 701a         	strb	r2, [r3]
; 			return link;
 8001b40: 68fb         	ldr	r3, [r7, #0xc]
 8001b42: e00f         	b	0x8001b64 <get_link_domain+0x64> @ imm = #0x1e
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 8001b44: 68fb         	ldr	r3, [r7, #0xc]
 8001b46: 3318         	adds	r3, #0x18
 8001b48: 60fb         	str	r3, [r7, #0xc]
 8001b4a: 68fb         	ldr	r3, [r7, #0xc]
 8001b4c: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8001b74 <get_link_domain+0x74>
 8001b4e: 4293         	cmp	r3, r2
 8001b50: bf34         	ite	lo
 8001b52: 2301         	movlo	r3, #0x1
 8001b54: 2300         	movhs	r3, #0x0
 8001b56: b2db         	uxtb	r3, r3
 8001b58: 2b00         	cmp	r3, #0x0
 8001b5a: d1da         	bne	0x8001b12 <get_link_domain+0x12> @ imm = #-0x4c
; 	*rel_domain_id = 0;
 8001b5c: 683b         	ldr	r3, [r7]
 8001b5e: 2200         	movs	r2, #0x0
 8001b60: 701a         	strb	r2, [r3]
; 	return NULL;
 8001b62: 2300         	movs	r3, #0x0
; }
 8001b64: 4618         	mov	r0, r3
 8001b66: 3714         	adds	r7, #0x14
 8001b68: 46bd         	mov	sp, r7
 8001b6a: bc80         	pop	{r7}
 8001b6c: 4770         	bx	lr
 8001b6e: bf00         	nop

08001b70 <$d>:
 8001b70: b8 b2 01 08  	.word	0x0801b2b8
 8001b74: b8 b2 01 08  	.word	0x0801b2b8

08001b78 <link_source_name_get>:
; {
 8001b78: b580         	push	{r7, lr}
 8001b7a: b08a         	sub	sp, #0x28
 8001b7c: af02         	add	r7, sp, #0x8
 8001b7e: 4603         	mov	r3, r0
 8001b80: 6039         	str	r1, [r7]
 8001b82: 71fb         	strb	r3, [r7, #0x7]
; 	size_t cache_size = sname_cache.item_size;
 8001b84: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8001bf8 <link_source_name_get+0x80>
 8001b86: 69db         	ldr	r3, [r3, #0x1c]
 8001b88: 613b         	str	r3, [r7, #0x10]
; 	union log_source_ids id = {
 8001b8a: 79fb         	ldrb	r3, [r7, #0x7]
 8001b8c: 733b         	strb	r3, [r7, #0xc]
 8001b8e: 683b         	ldr	r3, [r7]
 8001b90: b29b         	uxth	r3, r3
 8001b92: 81fb         	strh	r3, [r7, #0xe]
; 	if (!log_cache_get(&sname_cache, id.raw, &cached)) {
 8001b94: 68fb         	ldr	r3, [r7, #0xc]
 8001b96: f107 0214    	add.w	r2, r7, #0x14
 8001b9a: 4619         	mov	r1, r3
 8001b9c: 4816         	ldr	r0, [pc, #0x58]         @ 0x8001bf8 <link_source_name_get+0x80>
 8001b9e: f010 fba2    	bl	0x80122e6 <log_cache_get> @ imm = #0x10744
 8001ba2: 4603         	mov	r3, r0
 8001ba4: f083 0301    	eor	r3, r3, #0x1
 8001ba8: b2db         	uxtb	r3, r3
 8001baa: 2b00         	cmp	r3, #0x0
 8001bac: d01f         	beq	0x8001bee <link_source_name_get+0x76> @ imm = #0x3e
; 		const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 8001bae: f107 020b    	add.w	r2, r7, #0xb
 8001bb2: 79fb         	ldrb	r3, [r7, #0x7]
 8001bb4: 4611         	mov	r1, r2
 8001bb6: 4618         	mov	r0, r3
 8001bb8: f7ff ffa2    	bl	0x8001b00 <get_link_domain> @ imm = #-0xbc
 8001bbc: 61f8         	str	r0, [r7, #0x1c]
; 		err = log_link_get_source_name(link, rel_domain_id, source_id,
 8001bbe: 7afb         	ldrb	r3, [r7, #0xb]
 8001bc0: 4618         	mov	r0, r3
 8001bc2: 683b         	ldr	r3, [r7]
 8001bc4: b29a         	uxth	r2, r3
 8001bc6: 6979         	ldr	r1, [r7, #0x14]
 8001bc8: f107 0310    	add.w	r3, r7, #0x10
 8001bcc: 9300         	str	r3, [sp]
 8001bce: 460b         	mov	r3, r1
 8001bd0: 4601         	mov	r1, r0
 8001bd2: 69f8         	ldr	r0, [r7, #0x1c]
 8001bd4: f010 f9fe    	bl	0x8011fd4 <log_link_get_source_name> @ imm = #0x103fc
 8001bd8: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 8001bda: 69bb         	ldr	r3, [r7, #0x18]
 8001bdc: 2b00         	cmp	r3, #0x0
 8001bde: da01         	bge	0x8001be4 <link_source_name_get+0x6c> @ imm = #0x2
; 			return NULL;
 8001be0: 2300         	movs	r3, #0x0
 8001be2: e005         	b	0x8001bf0 <link_source_name_get+0x78> @ imm = #0xa
; 		log_cache_put(&sname_cache, cached);
 8001be4: 697b         	ldr	r3, [r7, #0x14]
 8001be6: 4619         	mov	r1, r3
 8001be8: 4803         	ldr	r0, [pc, #0xc]          @ 0x8001bf8 <link_source_name_get+0x80>
 8001bea: f010 fbff    	bl	0x80123ec <log_cache_put> @ imm = #0x107fe
; 	return (const char *)cached;
 8001bee: 697b         	ldr	r3, [r7, #0x14]
; }
 8001bf0: 4618         	mov	r0, r3
 8001bf2: 3720         	adds	r7, #0x20
 8001bf4: 46bd         	mov	sp, r7
 8001bf6: bd80         	pop	{r7, pc}

08001bf8 <$d>:
 8001bf8: 00 0b 00 20  	.word	0x20000b00

08001bfc <log_source_name_get>:
; {
 8001bfc: b580         	push	{r7, lr}
 8001bfe: b082         	sub	sp, #0x8
 8001c00: af00         	add	r7, sp, #0x0
 8001c02: 6078         	str	r0, [r7, #0x4]
 8001c04: 6039         	str	r1, [r7]
; 	if (z_log_is_local_domain(domain_id)) {
 8001c06: 687b         	ldr	r3, [r7, #0x4]
 8001c08: b2db         	uxtb	r3, r3
 8001c0a: 4618         	mov	r0, r3
 8001c0c: f010 f9a6    	bl	0x8011f5c <z_log_is_local_domain> @ imm = #0x1034c
 8001c10: 4603         	mov	r3, r0
 8001c12: 2b00         	cmp	r3, #0x0
 8001c14: d00d         	beq	0x8001c32 <log_source_name_get+0x36> @ imm = #0x1a
; 		if (source_id < log_src_cnt_get(domain_id)) {
 8001c16: 6878         	ldr	r0, [r7, #0x4]
 8001c18: f010 fa0a    	bl	0x8012030 <log_src_cnt_get> @ imm = #0x10414
 8001c1c: 4602         	mov	r2, r0
 8001c1e: 683b         	ldr	r3, [r7]
 8001c20: 4293         	cmp	r3, r2
 8001c22: d204         	bhs	0x8001c2e <log_source_name_get+0x32> @ imm = #0x8
; 			return TYPE_SECTION_START(log_const)[source_id].name;
 8001c24: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8001c48 <log_source_name_get+0x4c>
 8001c26: 683b         	ldr	r3, [r7]
 8001c28: f852 3033    	ldr.w	r3, [r2, r3, lsl #3]
 8001c2c: e008         	b	0x8001c40 <log_source_name_get+0x44> @ imm = #0x10
; 			return NULL;
 8001c2e: 2300         	movs	r3, #0x0
 8001c30: e006         	b	0x8001c40 <log_source_name_get+0x44> @ imm = #0xc
; 	return link_source_name_get(domain_id, source_id);
 8001c32: 687b         	ldr	r3, [r7, #0x4]
 8001c34: b2db         	uxtb	r3, r3
 8001c36: 6839         	ldr	r1, [r7]
 8001c38: 4618         	mov	r0, r3
 8001c3a: f7ff ff9d    	bl	0x8001b78 <link_source_name_get> @ imm = #-0xc6
 8001c3e: 4603         	mov	r3, r0
; }
 8001c40: 4618         	mov	r0, r3
 8001c42: 3708         	adds	r7, #0x8
 8001c44: 46bd         	mov	sp, r7
 8001c46: bd80         	pop	{r7, pc}

08001c48 <$d>:
 8001c48: 20 b2 01 08  	.word	0x0801b220

08001c4c <log_const_source_id>:
; {
 8001c4c: b480         	push	{r7}
 8001c4e: b083         	sub	sp, #0xc
 8001c50: af00         	add	r7, sp, #0x0
 8001c52: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 8001c54: 687b         	ldr	r3, [r7, #0x4]
 8001c56: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8001c68 <log_const_source_id+0x1c>
 8001c58: 1a9b         	subs	r3, r3, r2
 8001c5a: 08db         	lsrs	r3, r3, #0x3
; }
 8001c5c: 4618         	mov	r0, r3
 8001c5e: 370c         	adds	r7, #0xc
 8001c60: 46bd         	mov	sp, r7
 8001c62: bc80         	pop	{r7}
 8001c64: 4770         	bx	lr
 8001c66: bf00         	nop

08001c68 <$d>:
 8001c68: 20 b2 01 08  	.word	0x0801b220

08001c6c <z_log_msg_runtime_vcreate>:
; {
 8001c6c: b580         	push	{r7, lr}
 8001c6e: b090         	sub	sp, #0x40
 8001c70: af04         	add	r7, sp, #0x10
 8001c72: 60b9         	str	r1, [r7, #0x8]
 8001c74: 607b         	str	r3, [r7, #0x4]
 8001c76: 4603         	mov	r3, r0
 8001c78: 73fb         	strb	r3, [r7, #0xf]
 8001c7a: 4613         	mov	r3, r2
 8001c7c: 73bb         	strb	r3, [r7, #0xe]
; 	if (fmt) {
 8001c7e: 6c3b         	ldr	r3, [r7, #0x40]
 8001c80: 2b00         	cmp	r3, #0x0
 8001c82: d00b         	beq	0x8001c9c <z_log_msg_runtime_vcreate+0x30> @ imm = #0x16
; 		va_copy(ap2, ap);
 8001c84: 6c7b         	ldr	r3, [r7, #0x44]
 8001c86: 613b         	str	r3, [r7, #0x10]
; 		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
 8001c88: 693b         	ldr	r3, [r7, #0x10]
 8001c8a: 9300         	str	r3, [sp]
 8001c8c: 6c3b         	ldr	r3, [r7, #0x40]
 8001c8e: 6bfa         	ldr	r2, [r7, #0x3c]
 8001c90: 2110         	movs	r1, #0x10
 8001c92: 2000         	movs	r0, #0x0
 8001c94: f7ff f95a    	bl	0x8000f4c <cbvprintf_package> @ imm = #-0xd4c
 8001c98: 62f8         	str	r0, [r7, #0x2c]
 8001c9a: e001         	b	0x8001ca0 <z_log_msg_runtime_vcreate+0x34> @ imm = #0x2
; 		plen = 0;
 8001c9c: 2300         	movs	r3, #0x0
 8001c9e: 62fb         	str	r3, [r7, #0x2c]
; 	if (plen > Z_LOG_MSG_MAX_PACKAGE) {
 8001ca0: 6afb         	ldr	r3, [r7, #0x2c]
 8001ca2: f5b3 6f00    	cmp.w	r3, #0x800
 8001ca6: d31d         	blo	0x8001ce4 <z_log_msg_runtime_vcreate+0x78> @ imm = #0x3a
; 		LOG_WRN("Message dropped because it exceeds size limitation (%u)",
 8001ca8: 2303         	movs	r3, #0x3
 8001caa: 2b01         	cmp	r3, #0x1
 8001cac: d973         	bls	0x8001d96 <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xe6
 8001cae: 2301         	movs	r3, #0x1
 8001cb0: 77fb         	strb	r3, [r7, #0x1f]
 8001cb2: 7ffb         	ldrb	r3, [r7, #0x1f]
 8001cb4: f083 0301    	eor	r3, r3, #0x1
 8001cb8: b2db         	uxtb	r3, r3
 8001cba: 2b00         	cmp	r3, #0x0
 8001cbc: d16b         	bne	0x8001d96 <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xd6
 8001cbe: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8001d9c <z_log_msg_runtime_vcreate+0x130>
 8001cc0: 6819         	ldr	r1, [r3]
 8001cc2: f240 73ff    	movw	r3, #0x7ff
 8001cc6: 9303         	str	r3, [sp, #0xc]
 8001cc8: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8001da0 <z_log_msg_runtime_vcreate+0x134>
 8001cca: 9302         	str	r3, [sp, #0x8]
 8001ccc: 2300         	movs	r3, #0x0
 8001cce: 9301         	str	r3, [sp, #0x4]
 8001cd0: 2300         	movs	r3, #0x0
 8001cd2: 9300         	str	r3, [sp]
 8001cd4: 2300         	movs	r3, #0x0
 8001cd6: 2202         	movs	r2, #0x2
 8001cd8: 2000         	movs	r0, #0x0
 8001cda: f010 fb99    	bl	0x8012410 <z_log_msg_runtime_create> @ imm = #0x10732
 8001cde: 2300         	movs	r3, #0x0
 8001ce0: 61bb         	str	r3, [r7, #0x18]
; 		return;
 8001ce2: e058         	b	0x8001d96 <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xb0
; 	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
 8001ce4: 6afa         	ldr	r2, [r7, #0x2c]
 8001ce6: 6bbb         	ldr	r3, [r7, #0x38]
 8001ce8: 4413         	add	r3, r2
 8001cea: 3317         	adds	r3, #0x17
 8001cec: f023 0307    	bic	r3, r3, #0x7
 8001cf0: 3303         	adds	r3, #0x3
 8001cf2: 089b         	lsrs	r3, r3, #0x2
 8001cf4: 62bb         	str	r3, [r7, #0x28]
; 	struct log_msg_desc desc =
 8001cf6: 7d3b         	ldrb	r3, [r7, #0x14]
 8001cf8: f36f 0300    	bfc	r3, #0, #1
 8001cfc: 753b         	strb	r3, [r7, #0x14]
 8001cfe: 7d3b         	ldrb	r3, [r7, #0x14]
 8001d00: f36f 0341    	bfc	r3, #1, #1
 8001d04: 753b         	strb	r3, [r7, #0x14]
 8001d06: 7d3b         	ldrb	r3, [r7, #0x14]
 8001d08: f36f 0382    	bfc	r3, #2, #1
 8001d0c: 753b         	strb	r3, [r7, #0x14]
 8001d0e: 7bfb         	ldrb	r3, [r7, #0xf]
 8001d10: f003 0307    	and	r3, r3, #0x7
 8001d14: b2da         	uxtb	r2, r3
 8001d16: 7d3b         	ldrb	r3, [r7, #0x14]
 8001d18: f362 03c5    	bfi	r3, r2, #3, #3
 8001d1c: 753b         	strb	r3, [r7, #0x14]
 8001d1e: 7bbb         	ldrb	r3, [r7, #0xe]
 8001d20: f003 0307    	and	r3, r3, #0x7
 8001d24: b2da         	uxtb	r2, r3
 8001d26: 8abb         	ldrh	r3, [r7, #0x14]
 8001d28: f362 1388    	bfi	r3, r2, #6, #3
 8001d2c: 82bb         	strh	r3, [r7, #0x14]
 8001d2e: 6afb         	ldr	r3, [r7, #0x2c]
 8001d30: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8001d34: b29a         	uxth	r2, r3
 8001d36: 697b         	ldr	r3, [r7, #0x14]
 8001d38: f362 2353    	bfi	r3, r2, #9, #11
 8001d3c: 617b         	str	r3, [r7, #0x14]
 8001d3e: 6bbb         	ldr	r3, [r7, #0x38]
 8001d40: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8001d44: b29a         	uxth	r2, r3
 8001d46: 8afb         	ldrh	r3, [r7, #0x16]
 8001d48: f362 130f    	bfi	r3, r2, #4, #12
 8001d4c: 82fb         	strh	r3, [r7, #0x16]
; 		msg = alloca(msg_wlen * sizeof(int));
 8001d4e: 6abb         	ldr	r3, [r7, #0x28]
 8001d50: 009b         	lsls	r3, r3, #0x2
 8001d52: 3307         	adds	r3, #0x7
 8001d54: 08db         	lsrs	r3, r3, #0x3
 8001d56: 00db         	lsls	r3, r3, #0x3
 8001d58: ebad 0d03    	sub.w	sp, sp, r3
 8001d5c: ab04         	add	r3, sp, #0x10
 8001d5e: 3307         	adds	r3, #0x7
 8001d60: 08db         	lsrs	r3, r3, #0x3
 8001d62: 00db         	lsls	r3, r3, #0x3
 8001d64: 627b         	str	r3, [r7, #0x24]
; 		pkg = msg->data;
 8001d66: 6a7b         	ldr	r3, [r7, #0x24]
 8001d68: 3310         	adds	r3, #0x10
 8001d6a: 623b         	str	r3, [r7, #0x20]
; 	if (pkg && fmt) {
 8001d6c: 6a3b         	ldr	r3, [r7, #0x20]
 8001d6e: 2b00         	cmp	r3, #0x0
 8001d70: d00b         	beq	0x8001d8a <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x16
 8001d72: 6c3b         	ldr	r3, [r7, #0x40]
 8001d74: 2b00         	cmp	r3, #0x0
 8001d76: d008         	beq	0x8001d8a <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x10
; 		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
 8001d78: 6af9         	ldr	r1, [r7, #0x2c]
 8001d7a: 6c7b         	ldr	r3, [r7, #0x44]
 8001d7c: 9300         	str	r3, [sp]
 8001d7e: 6c3b         	ldr	r3, [r7, #0x40]
 8001d80: 6bfa         	ldr	r2, [r7, #0x3c]
 8001d82: 6a38         	ldr	r0, [r7, #0x20]
 8001d84: f7ff f8e2    	bl	0x8000f4c <cbvprintf_package> @ imm = #-0xe3c
 8001d88: 62f8         	str	r0, [r7, #0x2c]
; 		z_log_msg_finalize(msg, source, desc, data);
 8001d8a: 687b         	ldr	r3, [r7, #0x4]
 8001d8c: 697a         	ldr	r2, [r7, #0x14]
 8001d8e: 68b9         	ldr	r1, [r7, #0x8]
 8001d90: 6a78         	ldr	r0, [r7, #0x24]
 8001d92: f010 fb8b    	bl	0x80124ac <z_log_msg_finalize> @ imm = #0x10716
; }
 8001d96: 3730         	adds	r7, #0x30
 8001d98: 46bd         	mov	sp, r7
 8001d9a: bd80         	pop	{r7, pc}

08001d9c <$d>:
 8001d9c: 18 04 00 20  	.word	0x20000418
 8001da0: 00 b5 01 08  	.word	0x0801b500

08001da4 <cbpprintf>:
; {
 8001da4: b580         	push	{r7, lr}
 8001da6: b084         	sub	sp, #0x10
 8001da8: af00         	add	r7, sp, #0x0
 8001daa: 60f8         	str	r0, [r7, #0xc]
 8001dac: 60b9         	str	r1, [r7, #0x8]
 8001dae: 607a         	str	r2, [r7, #0x4]
; 	return cbpprintf_external(out, cbvprintf, ctx, packaged);
 8001db0: 687b         	ldr	r3, [r7, #0x4]
 8001db2: 68ba         	ldr	r2, [r7, #0x8]
 8001db4: 4904         	ldr	r1, [pc, #0x10]         @ 0x8001dc8 <cbpprintf+0x24>
 8001db6: 68f8         	ldr	r0, [r7, #0xc]
 8001db8: f00f fe91    	bl	0x8011ade <cbpprintf_external> @ imm = #0xfd22
 8001dbc: 4603         	mov	r3, r0
; }
 8001dbe: 4618         	mov	r0, r3
 8001dc0: 3710         	adds	r7, #0x10
 8001dc2: 46bd         	mov	sp, r7
 8001dc4: bd80         	pop	{r7, pc}
 8001dc6: bf00         	nop

08001dc8 <$d>:
 8001dc8: 6d 37 00 08  	.word	0x0800376d

08001dcc <__ctype_lookup>:
; static __inline char __ctype_lookup(int c) { return (__CTYPE_PTR + 1)[c]; }
 8001dcc: b480         	push	{r7}
 8001dce: b083         	sub	sp, #0xc
 8001dd0: af00         	add	r7, sp, #0x0
 8001dd2: 6078         	str	r0, [r7, #0x4]
 8001dd4: 687b         	ldr	r3, [r7, #0x4]
 8001dd6: 3301         	adds	r3, #0x1
 8001dd8: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8001de8 <__ctype_lookup+0x1c>
 8001dda: 4413         	add	r3, r2
 8001ddc: 781b         	ldrb	r3, [r3]
 8001dde: 4618         	mov	r0, r3
 8001de0: 370c         	adds	r7, #0xc
 8001de2: 46bd         	mov	sp, r7
 8001de4: bc80         	pop	{r7}
 8001de6: 4770         	bx	lr

08001de8 <$d>:
 8001de8: b0 d9 01 08  	.word	0x0801d9b0

08001dec <print_formatted>:
; {
 8001dec: b40e         	push	{r1, r2, r3}
 8001dee: b580         	push	{r7, lr}
 8001df0: b085         	sub	sp, #0x14
 8001df2: af00         	add	r7, sp, #0x0
 8001df4: 6078         	str	r0, [r7, #0x4]
; 	int length = 0;
 8001df6: 2300         	movs	r3, #0x0
 8001df8: 60fb         	str	r3, [r7, #0xc]
; 	va_start(args, fmt);
 8001dfa: f107 0320    	add.w	r3, r7, #0x20
 8001dfe: 60bb         	str	r3, [r7, #0x8]
; 	length = cbvprintf(out_func, (void *)output, fmt, args);
 8001e00: 68bb         	ldr	r3, [r7, #0x8]
 8001e02: 69fa         	ldr	r2, [r7, #0x1c]
 8001e04: 6879         	ldr	r1, [r7, #0x4]
 8001e06: 4806         	ldr	r0, [pc, #0x18]         @ 0x8001e20 <print_formatted+0x34>
 8001e08: f001 fcb0    	bl	0x800376c <cbvprintf>   @ imm = #0x1960
 8001e0c: 60f8         	str	r0, [r7, #0xc]
; 	return length;
 8001e0e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8001e10: 4618         	mov	r0, r3
 8001e12: 3714         	adds	r7, #0x14
 8001e14: 46bd         	mov	sp, r7
 8001e16: e8bd 4080    	pop.w	{r7, lr}
 8001e1a: b003         	add	sp, #0xc
 8001e1c: 4770         	bx	lr
 8001e1e: bf00         	nop

08001e20 <$d>:
 8001e20: 89 26 01 08  	.word	0x08012689

08001e24 <timestamp_print>:
; {
 8001e24: b580         	push	{r7, lr}
 8001e26: b09a         	sub	sp, #0x68
 8001e28: af04         	add	r7, sp, #0x10
 8001e2a: 60f8         	str	r0, [r7, #0xc]
 8001e2c: 60b9         	str	r1, [r7, #0x8]
 8001e2e: 607a         	str	r2, [r7, #0x4]
; 		IS_ENABLED(CONFIG_LOG_OUTPUT_FORMAT_LINUX_TIMESTAMP) |
 8001e30: 68bb         	ldr	r3, [r7, #0x8]
 8001e32: f003 0344    	and	r3, r3, #0x44
; 	bool format =
 8001e36: 2b00         	cmp	r3, #0x0
 8001e38: bf14         	ite	ne
 8001e3a: 2301         	movne	r3, #0x1
 8001e3c: 2300         	moveq	r3, #0x0
 8001e3e: f887 3037    	strb.w	r3, [r7, #0x37]
; 	if (!format) {
 8001e42: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8001e46: f083 0301    	eor	r3, r3, #0x1
 8001e4a: b2db         	uxtb	r3, r3
 8001e4c: 2b00         	cmp	r3, #0x0
 8001e4e: d006         	beq	0x8001e5e <timestamp_print+0x3a> @ imm = #0xc
; 		length = print_formatted(output, "[%08lu] ", timestamp);
 8001e50: 687a         	ldr	r2, [r7, #0x4]
 8001e52: 4938         	ldr	r1, [pc, #0xe0]         @ 0x8001f34 <timestamp_print+0x110>
 8001e54: 68f8         	ldr	r0, [r7, #0xc]
 8001e56: f7ff ffc9    	bl	0x8001dec <print_formatted> @ imm = #-0x6e
 8001e5a: 63b8         	str	r0, [r7, #0x38]
 8001e5c: e065         	b	0x8001f2a <timestamp_print+0x106> @ imm = #0xca
; 	} else if (freq != 0U) {
 8001e5e: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8001f38 <timestamp_print+0x114>
 8001e60: 681b         	ldr	r3, [r3]
 8001e62: 2b00         	cmp	r3, #0x0
 8001e64: d05f         	beq	0x8001f26 <timestamp_print+0x102> @ imm = #0xbe
; 		timestamp /= timestamp_div;
 8001e66: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8001f3c <timestamp_print+0x118>
 8001e68: 681b         	ldr	r3, [r3]
 8001e6a: 687a         	ldr	r2, [r7, #0x4]
 8001e6c: fbb2 f3f3    	udiv	r3, r2, r3
 8001e70: 607b         	str	r3, [r7, #0x4]
; 		total_seconds = timestamp / freq;
 8001e72: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8001f38 <timestamp_print+0x114>
 8001e74: 681b         	ldr	r3, [r3]
 8001e76: 687a         	ldr	r2, [r7, #0x4]
 8001e78: fbb2 f3f3    	udiv	r3, r2, r3
 8001e7c: 63fb         	str	r3, [r7, #0x3c]
; 		seconds = total_seconds;
 8001e7e: 6bfb         	ldr	r3, [r7, #0x3c]
 8001e80: 653b         	str	r3, [r7, #0x50]
; 		hours = seconds / 3600U;
 8001e82: 6d3b         	ldr	r3, [r7, #0x50]
 8001e84: 4a2e         	ldr	r2, [pc, #0xb8]         @ 0x8001f40 <timestamp_print+0x11c>
 8001e86: fba2 2303    	umull	r2, r3, r2, r3
 8001e8a: 0adb         	lsrs	r3, r3, #0xb
 8001e8c: 643b         	str	r3, [r7, #0x40]
; 		seconds -= hours * 3600U;
 8001e8e: 6c3b         	ldr	r3, [r7, #0x40]
 8001e90: f44f 6261    	mov.w	r2, #0xe10
 8001e94: fb02 f303    	mul	r3, r2, r3
 8001e98: 6d3a         	ldr	r2, [r7, #0x50]
 8001e9a: 1ad3         	subs	r3, r2, r3
 8001e9c: 653b         	str	r3, [r7, #0x50]
; 		mins = seconds / 60U;
 8001e9e: 6d3b         	ldr	r3, [r7, #0x50]
 8001ea0: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x8001f44 <timestamp_print+0x120>
 8001ea2: fba2 2303    	umull	r2, r3, r2, r3
 8001ea6: 095b         	lsrs	r3, r3, #0x5
 8001ea8: 657b         	str	r3, [r7, #0x54]
; 		seconds -= mins * 60U;
 8001eaa: 6d7a         	ldr	r2, [r7, #0x54]
 8001eac: 4613         	mov	r3, r2
 8001eae: 011b         	lsls	r3, r3, #0x4
 8001eb0: 1a9b         	subs	r3, r3, r2
 8001eb2: 009b         	lsls	r3, r3, #0x2
 8001eb4: 461a         	mov	r2, r3
 8001eb6: 6d3b         	ldr	r3, [r7, #0x50]
 8001eb8: 1a9b         	subs	r3, r3, r2
 8001eba: 653b         	str	r3, [r7, #0x50]
; 		remainder = timestamp % freq;
 8001ebc: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8001f38 <timestamp_print+0x114>
 8001ebe: 681a         	ldr	r2, [r3]
 8001ec0: 687b         	ldr	r3, [r7, #0x4]
 8001ec2: fbb3 f1f2    	udiv	r1, r3, r2
 8001ec6: fb01 f202    	mul	r2, r1, r2
 8001eca: 1a9b         	subs	r3, r3, r2
 8001ecc: 64fb         	str	r3, [r7, #0x4c]
; 		ms = (remainder * 1000U) / freq;
 8001ece: 6cfb         	ldr	r3, [r7, #0x4c]
 8001ed0: f44f 727a    	mov.w	r2, #0x3e8
 8001ed4: fb03 f202    	mul	r2, r3, r2
 8001ed8: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8001f38 <timestamp_print+0x114>
 8001eda: 681b         	ldr	r3, [r3]
 8001edc: fbb2 f3f3    	udiv	r3, r2, r3
 8001ee0: 64bb         	str	r3, [r7, #0x48]
; 		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 8001ee2: 6cfb         	ldr	r3, [r7, #0x4c]
 8001ee4: f44f 727a    	mov.w	r2, #0x3e8
 8001ee8: fb03 f202    	mul	r2, r3, r2
 8001eec: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8001f38 <timestamp_print+0x114>
 8001eee: 681b         	ldr	r3, [r3]
 8001ef0: 6cb9         	ldr	r1, [r7, #0x48]
 8001ef2: fb01 f303    	mul	r3, r1, r3
 8001ef6: 1ad3         	subs	r3, r2, r3
 8001ef8: f44f 727a    	mov.w	r2, #0x3e8
 8001efc: fb03 f202    	mul	r2, r3, r2
 8001f00: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8001f38 <timestamp_print+0x114>
 8001f02: 681b         	ldr	r3, [r3]
 8001f04: fbb2 f3f3    	udiv	r3, r2, r3
 8001f08: 647b         	str	r3, [r7, #0x44]
; 				length = print_formatted(output,
 8001f0a: 6c7b         	ldr	r3, [r7, #0x44]
 8001f0c: 9302         	str	r3, [sp, #0x8]
 8001f0e: 6cbb         	ldr	r3, [r7, #0x48]
 8001f10: 9301         	str	r3, [sp, #0x4]
 8001f12: 6d3b         	ldr	r3, [r7, #0x50]
 8001f14: 9300         	str	r3, [sp]
 8001f16: 6d7b         	ldr	r3, [r7, #0x54]
 8001f18: 6c3a         	ldr	r2, [r7, #0x40]
 8001f1a: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8001f48 <timestamp_print+0x124>
 8001f1c: 68f8         	ldr	r0, [r7, #0xc]
 8001f1e: f7ff ff65    	bl	0x8001dec <print_formatted> @ imm = #-0x136
 8001f22: 63b8         	str	r0, [r7, #0x38]
 8001f24: e001         	b	0x8001f2a <timestamp_print+0x106> @ imm = #0x2
; 		length = 0;
 8001f26: 2300         	movs	r3, #0x0
 8001f28: 63bb         	str	r3, [r7, #0x38]
; 	return length;
 8001f2a: 6bbb         	ldr	r3, [r7, #0x38]
; }
 8001f2c: 4618         	mov	r0, r3
 8001f2e: 3758         	adds	r7, #0x58
 8001f30: 46bd         	mov	sp, r7
 8001f32: bd80         	pop	{r7, pc}

08001f34 <$d>:
 8001f34: 58 b5 01 08  	.word	0x0801b558
 8001f38: 20 0b 00 20  	.word	0x20000b20
 8001f3c: 24 0b 00 20  	.word	0x20000b24
 8001f40: c5 b3 a2 91  	.word	0x91a2b3c5
 8001f44: 89 88 88 88  	.word	0x88888889
 8001f48: 64 b5 01 08  	.word	0x0801b564

08001f4c <color_print>:
; {
 8001f4c: b580         	push	{r7, lr}
 8001f4e: b086         	sub	sp, #0x18
 8001f50: af00         	add	r7, sp, #0x0
 8001f52: 60f8         	str	r0, [r7, #0xc]
 8001f54: 607b         	str	r3, [r7, #0x4]
 8001f56: 460b         	mov	r3, r1
 8001f58: 72fb         	strb	r3, [r7, #0xb]
 8001f5a: 4613         	mov	r3, r2
 8001f5c: 72bb         	strb	r3, [r7, #0xa]
; 	if (color) {
 8001f5e: 7afb         	ldrb	r3, [r7, #0xb]
 8001f60: 2b00         	cmp	r3, #0x0
 8001f62: d014         	beq	0x8001f8e <color_print+0x42> @ imm = #0x28
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8001f64: 7abb         	ldrb	r3, [r7, #0xa]
 8001f66: 2b00         	cmp	r3, #0x0
 8001f68: d00a         	beq	0x8001f80 <color_print+0x34> @ imm = #0x14
; 		const char *log_color = start && (colors[level] != NULL) ?
 8001f6a: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8001f98 <color_print+0x4c>
 8001f6c: 687b         	ldr	r3, [r7, #0x4]
 8001f6e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8001f72: 2b00         	cmp	r3, #0x0
 8001f74: d004         	beq	0x8001f80 <color_print+0x34> @ imm = #0x8
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8001f76: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8001f98 <color_print+0x4c>
 8001f78: 687b         	ldr	r3, [r7, #0x4]
 8001f7a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8001f7e: e000         	b	0x8001f82 <color_print+0x36> @ imm = #0x0
 8001f80: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8001f9c <color_print+0x50>
; 		const char *log_color = start && (colors[level] != NULL) ?
 8001f82: 617b         	str	r3, [r7, #0x14]
; 		print_formatted(output, "%s", log_color);
 8001f84: 697a         	ldr	r2, [r7, #0x14]
 8001f86: 4906         	ldr	r1, [pc, #0x18]         @ 0x8001fa0 <color_print+0x54>
 8001f88: 68f8         	ldr	r0, [r7, #0xc]
 8001f8a: f7ff ff2f    	bl	0x8001dec <print_formatted> @ imm = #-0x1a2
; }
 8001f8e: bf00         	nop
 8001f90: 3718         	adds	r7, #0x18
 8001f92: 46bd         	mov	sp, r7
 8001f94: bd80         	pop	{r7, pc}
 8001f96: bf00         	nop

08001f98 <$d>:
 8001f98: 24 d0 01 08  	.word	0x0801d024
 8001f9c: 80 b5 01 08  	.word	0x0801b580
 8001fa0: 88 b5 01 08  	.word	0x0801b588

08001fa4 <ids_print>:
; {
 8001fa4: b580         	push	{r7, lr}
 8001fa6: b084         	sub	sp, #0x10
 8001fa8: af00         	add	r7, sp, #0x0
 8001faa: 6078         	str	r0, [r7, #0x4]
 8001fac: 4608         	mov	r0, r1
 8001fae: 4611         	mov	r1, r2
 8001fb0: 461a         	mov	r2, r3
 8001fb2: 4603         	mov	r3, r0
 8001fb4: 70fb         	strb	r3, [r7, #0x3]
 8001fb6: 460b         	mov	r3, r1
 8001fb8: 70bb         	strb	r3, [r7, #0x2]
 8001fba: 4613         	mov	r3, r2
 8001fbc: 707b         	strb	r3, [r7, #0x1]
; 	int total = 0;
 8001fbe: 2300         	movs	r3, #0x0
 8001fc0: 60fb         	str	r3, [r7, #0xc]
; 	if (level_on) {
 8001fc2: 78fb         	ldrb	r3, [r7, #0x3]
 8001fc4: 2b00         	cmp	r3, #0x0
 8001fc6: d00c         	beq	0x8001fe2 <ids_print+0x3e> @ imm = #0x18
; 		total += print_formatted(output, "<%s> ", severity[level]);
 8001fc8: 4a19         	ldr	r2, [pc, #0x64]         @ 0x8002030 <ids_print+0x8c>
 8001fca: 6a7b         	ldr	r3, [r7, #0x24]
 8001fcc: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8001fd0: 461a         	mov	r2, r3
 8001fd2: 4918         	ldr	r1, [pc, #0x60]         @ 0x8002034 <ids_print+0x90>
 8001fd4: 6878         	ldr	r0, [r7, #0x4]
 8001fd6: f7ff ff09    	bl	0x8001dec <print_formatted> @ imm = #-0x1ee
 8001fda: 4602         	mov	r2, r0
 8001fdc: 68fb         	ldr	r3, [r7, #0xc]
 8001fde: 4413         	add	r3, r2
 8001fe0: 60fb         	str	r3, [r7, #0xc]
; 	if (domain) {
 8001fe2: 69bb         	ldr	r3, [r7, #0x18]
 8001fe4: 2b00         	cmp	r3, #0x0
 8001fe6: d008         	beq	0x8001ffa <ids_print+0x56> @ imm = #0x10
; 		total += print_formatted(output, "%s/", domain);
 8001fe8: 69ba         	ldr	r2, [r7, #0x18]
 8001fea: 4913         	ldr	r1, [pc, #0x4c]         @ 0x8002038 <ids_print+0x94>
 8001fec: 6878         	ldr	r0, [r7, #0x4]
 8001fee: f7ff fefd    	bl	0x8001dec <print_formatted> @ imm = #-0x206
 8001ff2: 4602         	mov	r2, r0
 8001ff4: 68fb         	ldr	r3, [r7, #0xc]
 8001ff6: 4413         	add	r3, r2
 8001ff8: 60fb         	str	r3, [r7, #0xc]
; 	if (source) {
 8001ffa: 69fb         	ldr	r3, [r7, #0x1c]
 8001ffc: 2b00         	cmp	r3, #0x0
 8001ffe: d011         	beq	0x8002024 <ids_print+0x80> @ imm = #0x22
; 		total += print_formatted(output,
 8002000: 78bb         	ldrb	r3, [r7, #0x2]
 8002002: 2b00         	cmp	r3, #0x0
 8002004: d004         	beq	0x8002010 <ids_print+0x6c> @ imm = #0x8
; 				(func_on &&
 8002006: 6a7b         	ldr	r3, [r7, #0x24]
 8002008: 2b04         	cmp	r3, #0x4
 800200a: d101         	bne	0x8002010 <ids_print+0x6c> @ imm = #0x2
; 		total += print_formatted(output,
 800200c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800203c <ids_print+0x98>
 800200e: e000         	b	0x8002012 <ids_print+0x6e> @ imm = #0x0
 8002010: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002040 <ids_print+0x9c>
 8002012: 69fa         	ldr	r2, [r7, #0x1c]
 8002014: 4619         	mov	r1, r3
 8002016: 6878         	ldr	r0, [r7, #0x4]
 8002018: f7ff fee8    	bl	0x8001dec <print_formatted> @ imm = #-0x230
 800201c: 4602         	mov	r2, r0
 800201e: 68fb         	ldr	r3, [r7, #0xc]
 8002020: 4413         	add	r3, r2
 8002022: 60fb         	str	r3, [r7, #0xc]
; 	return total;
 8002024: 68fb         	ldr	r3, [r7, #0xc]
; }
 8002026: 4618         	mov	r0, r3
 8002028: 3710         	adds	r7, #0x10
 800202a: 46bd         	mov	sp, r7
 800202c: bd80         	pop	{r7, pc}
 800202e: bf00         	nop

08002030 <$d>:
 8002030: 10 d0 01 08  	.word	0x0801d010
 8002034: 8c b5 01 08  	.word	0x0801b58c
 8002038: 94 b5 01 08  	.word	0x0801b594
 800203c: 98 b5 01 08  	.word	0x0801b598
 8002040: 9c b5 01 08  	.word	0x0801b59c

08002044 <newline_print>:
; {
 8002044: b580         	push	{r7, lr}
 8002046: b082         	sub	sp, #0x8
 8002048: af00         	add	r7, sp, #0x0
 800204a: 6078         	str	r0, [r7, #0x4]
 800204c: 6039         	str	r1, [r7]
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 800204e: 683b         	ldr	r3, [r7]
 8002050: f003 0310    	and	r3, r3, #0x10
 8002054: 2b00         	cmp	r3, #0x0
 8002056: d10e         	bne	0x8002076 <newline_print+0x32> @ imm = #0x1c
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 8002058: 683b         	ldr	r3, [r7]
 800205a: f003 0320    	and	r3, r3, #0x20
 800205e: 2b00         	cmp	r3, #0x0
 8002060: d004         	beq	0x800206c <newline_print+0x28> @ imm = #0x8
; 		print_formatted(ctx, "\n");
 8002062: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8002080 <newline_print+0x3c>
 8002064: 6878         	ldr	r0, [r7, #0x4]
 8002066: f7ff fec1    	bl	0x8001dec <print_formatted> @ imm = #-0x27e
 800206a: e005         	b	0x8002078 <newline_print+0x34> @ imm = #0xa
; 		print_formatted(ctx, "\r\n");
 800206c: 4905         	ldr	r1, [pc, #0x14]         @ 0x8002084 <newline_print+0x40>
 800206e: 6878         	ldr	r0, [r7, #0x4]
 8002070: f7ff febc    	bl	0x8001dec <print_formatted> @ imm = #-0x288
 8002074: e000         	b	0x8002078 <newline_print+0x34> @ imm = #0x0
; 		return;
 8002076: bf00         	nop
; }
 8002078: 3708         	adds	r7, #0x8
 800207a: 46bd         	mov	sp, r7
 800207c: bd80         	pop	{r7, pc}
 800207e: bf00         	nop

08002080 <$d>:
 8002080: a4 b5 01 08  	.word	0x0801b5a4
 8002084: a8 b5 01 08  	.word	0x0801b5a8

08002088 <hexdump_line_print>:
; {
 8002088: b580         	push	{r7, lr}
 800208a: b088         	sub	sp, #0x20
 800208c: af00         	add	r7, sp, #0x0
 800208e: 60f8         	str	r0, [r7, #0xc]
 8002090: 60b9         	str	r1, [r7, #0x8]
 8002092: 607a         	str	r2, [r7, #0x4]
 8002094: 603b         	str	r3, [r7]
; 	newline_print(output, flags);
 8002096: 6ab9         	ldr	r1, [r7, #0x28]
 8002098: 68f8         	ldr	r0, [r7, #0xc]
 800209a: f7ff ffd3    	bl	0x8002044 <newline_print> @ imm = #-0x5a
; 	for (int i = 0; i < prefix_offset; i++) {
 800209e: 2300         	movs	r3, #0x0
 80020a0: 61fb         	str	r3, [r7, #0x1c]
 80020a2: e006         	b	0x80020b2 <hexdump_line_print+0x2a> @ imm = #0xc
; 		print_formatted(output, " ");
 80020a4: 4937         	ldr	r1, [pc, #0xdc]         @ 0x8002184 <hexdump_line_print+0xfc>
 80020a6: 68f8         	ldr	r0, [r7, #0xc]
 80020a8: f7ff fea0    	bl	0x8001dec <print_formatted> @ imm = #-0x2c0
; 	for (int i = 0; i < prefix_offset; i++) {
 80020ac: 69fb         	ldr	r3, [r7, #0x1c]
 80020ae: 3301         	adds	r3, #0x1
 80020b0: 61fb         	str	r3, [r7, #0x1c]
 80020b2: 69fa         	ldr	r2, [r7, #0x1c]
 80020b4: 683b         	ldr	r3, [r7]
 80020b6: 429a         	cmp	r2, r3
 80020b8: dbf4         	blt	0x80020a4 <hexdump_line_print+0x1c> @ imm = #-0x18
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 80020ba: 2300         	movs	r3, #0x0
 80020bc: 61bb         	str	r3, [r7, #0x18]
 80020be: e020         	b	0x8002102 <hexdump_line_print+0x7a> @ imm = #0x40
; 		if (i > 0 && !(i % 8)) {
 80020c0: 69bb         	ldr	r3, [r7, #0x18]
 80020c2: 2b00         	cmp	r3, #0x0
 80020c4: dd08         	ble	0x80020d8 <hexdump_line_print+0x50> @ imm = #0x10
 80020c6: 69bb         	ldr	r3, [r7, #0x18]
 80020c8: f003 0307    	and	r3, r3, #0x7
 80020cc: 2b00         	cmp	r3, #0x0
 80020ce: d103         	bne	0x80020d8 <hexdump_line_print+0x50> @ imm = #0x6
; 			print_formatted(output, " ");
 80020d0: 492c         	ldr	r1, [pc, #0xb0]         @ 0x8002184 <hexdump_line_print+0xfc>
 80020d2: 68f8         	ldr	r0, [r7, #0xc]
 80020d4: f7ff fe8a    	bl	0x8001dec <print_formatted> @ imm = #-0x2ec
; 		if (i < length) {
 80020d8: 69bb         	ldr	r3, [r7, #0x18]
 80020da: 687a         	ldr	r2, [r7, #0x4]
 80020dc: 429a         	cmp	r2, r3
 80020de: d909         	bls	0x80020f4 <hexdump_line_print+0x6c> @ imm = #0x12
; 			print_formatted(output, "%02x ", data[i]);
 80020e0: 69bb         	ldr	r3, [r7, #0x18]
 80020e2: 68ba         	ldr	r2, [r7, #0x8]
 80020e4: 4413         	add	r3, r2
 80020e6: 781b         	ldrb	r3, [r3]
 80020e8: 461a         	mov	r2, r3
 80020ea: 4927         	ldr	r1, [pc, #0x9c]         @ 0x8002188 <hexdump_line_print+0x100>
 80020ec: 68f8         	ldr	r0, [r7, #0xc]
 80020ee: f7ff fe7d    	bl	0x8001dec <print_formatted> @ imm = #-0x306
 80020f2: e003         	b	0x80020fc <hexdump_line_print+0x74> @ imm = #0x6
; 			print_formatted(output, "   ");
 80020f4: 4925         	ldr	r1, [pc, #0x94]         @ 0x800218c <hexdump_line_print+0x104>
 80020f6: 68f8         	ldr	r0, [r7, #0xc]
 80020f8: f7ff fe78    	bl	0x8001dec <print_formatted> @ imm = #-0x310
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 80020fc: 69bb         	ldr	r3, [r7, #0x18]
 80020fe: 3301         	adds	r3, #0x1
 8002100: 61bb         	str	r3, [r7, #0x18]
 8002102: 69bb         	ldr	r3, [r7, #0x18]
 8002104: 2b0f         	cmp	r3, #0xf
 8002106: dddb         	ble	0x80020c0 <hexdump_line_print+0x38> @ imm = #-0x4a
; 	print_formatted(output, "|");
 8002108: 4921         	ldr	r1, [pc, #0x84]         @ 0x8002190 <hexdump_line_print+0x108>
 800210a: 68f8         	ldr	r0, [r7, #0xc]
 800210c: f7ff fe6e    	bl	0x8001dec <print_formatted> @ imm = #-0x324
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8002110: 2300         	movs	r3, #0x0
 8002112: 617b         	str	r3, [r7, #0x14]
 8002114: e02d         	b	0x8002172 <hexdump_line_print+0xea> @ imm = #0x5a
; 		if (i > 0 && !(i % 8)) {
 8002116: 697b         	ldr	r3, [r7, #0x14]
 8002118: 2b00         	cmp	r3, #0x0
 800211a: dd08         	ble	0x800212e <hexdump_line_print+0xa6> @ imm = #0x10
 800211c: 697b         	ldr	r3, [r7, #0x14]
 800211e: f003 0307    	and	r3, r3, #0x7
 8002122: 2b00         	cmp	r3, #0x0
 8002124: d103         	bne	0x800212e <hexdump_line_print+0xa6> @ imm = #0x6
; 			print_formatted(output, " ");
 8002126: 4917         	ldr	r1, [pc, #0x5c]         @ 0x8002184 <hexdump_line_print+0xfc>
 8002128: 68f8         	ldr	r0, [r7, #0xc]
 800212a: f7ff fe5f    	bl	0x8001dec <print_formatted> @ imm = #-0x342
; 		if (i < length) {
 800212e: 697b         	ldr	r3, [r7, #0x14]
 8002130: 687a         	ldr	r2, [r7, #0x4]
 8002132: 429a         	cmp	r2, r3
 8002134: d916         	bls	0x8002164 <hexdump_line_print+0xdc> @ imm = #0x2c
; 			unsigned char c = (unsigned char)data[i];
 8002136: 697b         	ldr	r3, [r7, #0x14]
 8002138: 68ba         	ldr	r2, [r7, #0x8]
 800213a: 4413         	add	r3, r2
 800213c: 781b         	ldrb	r3, [r3]
 800213e: 74fb         	strb	r3, [r7, #0x13]
; 			      isprint((int)c) != 0 ? c : '.');
 8002140: 7cfb         	ldrb	r3, [r7, #0x13]
 8002142: 4618         	mov	r0, r3
 8002144: f7ff fe42    	bl	0x8001dcc <__ctype_lookup> @ imm = #-0x37c
 8002148: 4603         	mov	r3, r0
 800214a: f003 0397    	and	r3, r3, #0x97
; 			print_formatted(output, "%c",
 800214e: 2b00         	cmp	r3, #0x0
 8002150: d001         	beq	0x8002156 <hexdump_line_print+0xce> @ imm = #0x2
 8002152: 7cfb         	ldrb	r3, [r7, #0x13]
 8002154: e000         	b	0x8002158 <hexdump_line_print+0xd0> @ imm = #0x0
 8002156: 232e         	movs	r3, #0x2e
 8002158: 461a         	mov	r2, r3
 800215a: 490e         	ldr	r1, [pc, #0x38]         @ 0x8002194 <hexdump_line_print+0x10c>
 800215c: 68f8         	ldr	r0, [r7, #0xc]
 800215e: f7ff fe45    	bl	0x8001dec <print_formatted> @ imm = #-0x376
 8002162: e003         	b	0x800216c <hexdump_line_print+0xe4> @ imm = #0x6
; 			print_formatted(output, " ");
 8002164: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8002184 <hexdump_line_print+0xfc>
 8002166: 68f8         	ldr	r0, [r7, #0xc]
 8002168: f7ff fe40    	bl	0x8001dec <print_formatted> @ imm = #-0x380
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 800216c: 697b         	ldr	r3, [r7, #0x14]
 800216e: 3301         	adds	r3, #0x1
 8002170: 617b         	str	r3, [r7, #0x14]
 8002172: 697b         	ldr	r3, [r7, #0x14]
 8002174: 2b0f         	cmp	r3, #0xf
 8002176: ddce         	ble	0x8002116 <hexdump_line_print+0x8e> @ imm = #-0x64
; }
 8002178: bf00         	nop
 800217a: bf00         	nop
 800217c: 3720         	adds	r7, #0x20
 800217e: 46bd         	mov	sp, r7
 8002180: bd80         	pop	{r7, pc}
 8002182: bf00         	nop

08002184 <$d>:
 8002184: ac b5 01 08  	.word	0x0801b5ac
 8002188: b0 b5 01 08  	.word	0x0801b5b0
 800218c: b8 b5 01 08  	.word	0x0801b5b8
 8002190: bc b5 01 08  	.word	0x0801b5bc
 8002194: c0 b5 01 08  	.word	0x0801b5c0

08002198 <prefix_print>:
; {
 8002198: b590         	push	{r4, r7, lr}
 800219a: b08d         	sub	sp, #0x34
 800219c: af04         	add	r7, sp, #0x10
 800219e: 60f8         	str	r0, [r7, #0xc]
 80021a0: 60b9         	str	r1, [r7, #0x8]
 80021a2: 603b         	str	r3, [r7]
 80021a4: 4613         	mov	r3, r2
 80021a6: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t length = 0U;
 80021a8: 2300         	movs	r3, #0x0
 80021aa: 61fb         	str	r3, [r7, #0x1c]
; 	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
 80021ac: 68bb         	ldr	r3, [r7, #0x8]
 80021ae: f003 0302    	and	r3, r3, #0x2
 80021b2: 2b00         	cmp	r3, #0x0
 80021b4: bf14         	ite	ne
 80021b6: 2301         	movne	r3, #0x1
 80021b8: 2300         	moveq	r3, #0x0
 80021ba: 76fb         	strb	r3, [r7, #0x1b]
; 	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
 80021bc: 68bb         	ldr	r3, [r7, #0x8]
 80021be: f003 0301    	and	r3, r3, #0x1
 80021c2: 2b00         	cmp	r3, #0x0
 80021c4: bf14         	ite	ne
 80021c6: 2301         	movne	r3, #0x1
 80021c8: 2300         	moveq	r3, #0x0
 80021ca: 76bb         	strb	r3, [r7, #0x1a]
; 	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
 80021cc: 68bb         	ldr	r3, [r7, #0x8]
 80021ce: f003 0308    	and	r3, r3, #0x8
 80021d2: 2b00         	cmp	r3, #0x0
 80021d4: bf14         	ite	ne
 80021d6: 2301         	movne	r3, #0x1
 80021d8: 2300         	moveq	r3, #0x0
 80021da: 767b         	strb	r3, [r7, #0x19]
; 	bool thread_on = IS_ENABLED(CONFIG_LOG_THREAD_ID_PREFIX) &&
 80021dc: 2300         	movs	r3, #0x0
 80021de: 74fb         	strb	r3, [r7, #0x13]
; 	bool source_off = flags & LOG_OUTPUT_FLAG_SKIP_SOURCE;
 80021e0: 68bb         	ldr	r3, [r7, #0x8]
 80021e2: f403 7380    	and	r3, r3, #0x100
 80021e6: 2b00         	cmp	r3, #0x0
 80021e8: bf14         	ite	ne
 80021ea: 2301         	movne	r3, #0x1
 80021ec: 2300         	moveq	r3, #0x0
 80021ee: 763b         	strb	r3, [r7, #0x18]
; 	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
 80021f0: f00f fea4    	bl	0x8011f3c <z_log_get_tag> @ imm = #0xfd48
 80021f4: 6178         	str	r0, [r7, #0x14]
; 	if (tag) {
 80021f6: 697b         	ldr	r3, [r7, #0x14]
 80021f8: 2b00         	cmp	r3, #0x0
 80021fa: d009         	beq	0x8002210 <prefix_print+0x78> @ imm = #0x12
; 		length += print_formatted(output, "%s ", tag);
 80021fc: 697a         	ldr	r2, [r7, #0x14]
 80021fe: 491e         	ldr	r1, [pc, #0x78]         @ 0x8002278 <prefix_print+0xe0>
 8002200: 68f8         	ldr	r0, [r7, #0xc]
 8002202: f7ff fdf3    	bl	0x8001dec <print_formatted> @ imm = #-0x41a
 8002206: 4603         	mov	r3, r0
 8002208: 461a         	mov	r2, r3
 800220a: 69fb         	ldr	r3, [r7, #0x1c]
 800220c: 4413         	add	r3, r2
 800220e: 61fb         	str	r3, [r7, #0x1c]
; 	if (stamp) {
 8002210: 7efb         	ldrb	r3, [r7, #0x1b]
 8002212: 2b00         	cmp	r3, #0x0
 8002214: d009         	beq	0x800222a <prefix_print+0x92> @ imm = #0x12
; 		length += timestamp_print(output, flags, timestamp);
 8002216: 683a         	ldr	r2, [r7]
 8002218: 68b9         	ldr	r1, [r7, #0x8]
 800221a: 68f8         	ldr	r0, [r7, #0xc]
 800221c: f7ff fe02    	bl	0x8001e24 <timestamp_print> @ imm = #-0x3fc
 8002220: 4603         	mov	r3, r0
 8002222: 461a         	mov	r2, r3
 8002224: 69fb         	ldr	r3, [r7, #0x1c]
 8002226: 4413         	add	r3, r2
 8002228: 61fb         	str	r3, [r7, #0x1c]
; 		color_prefix(output, colors_on, level);
 800222a: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 800222e: 7ebb         	ldrb	r3, [r7, #0x1a]
 8002230: 4619         	mov	r1, r3
 8002232: 68f8         	ldr	r0, [r7, #0xc]
 8002234: f010 fa55    	bl	0x80126e2 <color_prefix> @ imm = #0x104aa
; 	length += ids_print(output, level_on, func_on, thread_on, domain,
 8002238: 7cfc         	ldrb	r4, [r7, #0x13]
 800223a: 7e3b         	ldrb	r3, [r7, #0x18]
 800223c: 2b00         	cmp	r3, #0x0
 800223e: d001         	beq	0x8002244 <prefix_print+0xac> @ imm = #0x2
 8002240: 2300         	movs	r3, #0x0
 8002242: e000         	b	0x8002246 <prefix_print+0xae> @ imm = #0x0
 8002244: 6b7b         	ldr	r3, [r7, #0x34]
 8002246: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 800224a: 79f8         	ldrb	r0, [r7, #0x7]
 800224c: 7e79         	ldrb	r1, [r7, #0x19]
 800224e: 9203         	str	r2, [sp, #0xc]
 8002250: 6bba         	ldr	r2, [r7, #0x38]
 8002252: 9202         	str	r2, [sp, #0x8]
 8002254: 9301         	str	r3, [sp, #0x4]
 8002256: 6b3b         	ldr	r3, [r7, #0x30]
 8002258: 9300         	str	r3, [sp]
 800225a: 4623         	mov	r3, r4
 800225c: 4602         	mov	r2, r0
 800225e: 68f8         	ldr	r0, [r7, #0xc]
 8002260: f7ff fea0    	bl	0x8001fa4 <ids_print>   @ imm = #-0x2c0
 8002264: 4603         	mov	r3, r0
 8002266: 461a         	mov	r2, r3
 8002268: 69fb         	ldr	r3, [r7, #0x1c]
 800226a: 4413         	add	r3, r2
 800226c: 61fb         	str	r3, [r7, #0x1c]
; 	return length;
 800226e: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8002270: 4618         	mov	r0, r3
 8002272: 3724         	adds	r7, #0x24
 8002274: 46bd         	mov	sp, r7
 8002276: bd90         	pop	{r4, r7, pc}

08002278 <$d>:
 8002278: cc b5 01 08  	.word	0x0801b5cc

0800227c <log_output_process>:
; {
 800227c: b580         	push	{r7, lr}
 800227e: b08c         	sub	sp, #0x30
 8002280: af04         	add	r7, sp, #0x10
 8002282: 60f8         	str	r0, [r7, #0xc]
 8002284: 60b9         	str	r1, [r7, #0x8]
 8002286: 607a         	str	r2, [r7, #0x4]
 8002288: 603b         	str	r3, [r7]
; 	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
 800228a: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 800228e: 2b00         	cmp	r3, #0x0
 8002290: bf0c         	ite	eq
 8002292: 2301         	moveq	r3, #0x1
 8002294: 2300         	movne	r3, #0x0
 8002296: 75fb         	strb	r3, [r7, #0x17]
; 	if (!raw_string) {
 8002298: 7dfb         	ldrb	r3, [r7, #0x17]
 800229a: f083 0301    	eor	r3, r3, #0x1
 800229e: b2db         	uxtb	r3, r3
 80022a0: 2b00         	cmp	r3, #0x0
 80022a2: d012         	beq	0x80022ca <log_output_process+0x4e> @ imm = #0x24
; 		prefix_offset = prefix_print(output, flags, 0, timestamp,
 80022a4: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 80022a8: 9303         	str	r3, [sp, #0xc]
 80022aa: 6abb         	ldr	r3, [r7, #0x28]
 80022ac: 9302         	str	r3, [sp, #0x8]
 80022ae: 683b         	ldr	r3, [r7]
 80022b0: 9301         	str	r3, [sp, #0x4]
 80022b2: 687b         	ldr	r3, [r7, #0x4]
 80022b4: 9300         	str	r3, [sp]
 80022b6: 68bb         	ldr	r3, [r7, #0x8]
 80022b8: 2200         	movs	r2, #0x0
 80022ba: 6bf9         	ldr	r1, [r7, #0x3c]
 80022bc: 68f8         	ldr	r0, [r7, #0xc]
 80022be: f7ff ff6b    	bl	0x8002198 <prefix_print> @ imm = #-0x12a
 80022c2: 61f8         	str	r0, [r7, #0x1c]
; 		cb = out_func;
 80022c4: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8002330 <log_output_process+0xb4>
 80022c6: 61bb         	str	r3, [r7, #0x18]
 80022c8: e008         	b	0x80022dc <log_output_process+0x60> @ imm = #0x10
; 		prefix_offset = 0;
 80022ca: 2300         	movs	r3, #0x0
 80022cc: 61fb         	str	r3, [r7, #0x1c]
; 		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
 80022ce: 683b         	ldr	r3, [r7]
 80022d0: 2b01         	cmp	r3, #0x1
 80022d2: d101         	bne	0x80022d8 <log_output_process+0x5c> @ imm = #0x2
 80022d4: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8002330 <log_output_process+0xb4>
 80022d6: e000         	b	0x80022da <log_output_process+0x5e> @ imm = #0x0
 80022d8: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8002334 <log_output_process+0xb8>
 80022da: 61bb         	str	r3, [r7, #0x18]
; 	if (package) {
 80022dc: 6b3b         	ldr	r3, [r7, #0x30]
 80022de: 2b00         	cmp	r3, #0x0
 80022e0: d005         	beq	0x80022ee <log_output_process+0x72> @ imm = #0xa
; 		int err = cbpprintf(cb, (void *)output, (void *)package);
 80022e2: 6b3a         	ldr	r2, [r7, #0x30]
 80022e4: 68f9         	ldr	r1, [r7, #0xc]
 80022e6: 69b8         	ldr	r0, [r7, #0x18]
 80022e8: f7ff fd5c    	bl	0x8001da4 <cbpprintf>   @ imm = #-0x548
 80022ec: 6138         	str	r0, [r7, #0x10]
; 	if (data_len) {
 80022ee: 6bbb         	ldr	r3, [r7, #0x38]
 80022f0: 2b00         	cmp	r3, #0x0
 80022f2: d008         	beq	0x8002306 <log_output_process+0x8a> @ imm = #0x10
; 		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
 80022f4: 69fa         	ldr	r2, [r7, #0x1c]
 80022f6: 6bfb         	ldr	r3, [r7, #0x3c]
 80022f8: 9300         	str	r3, [sp]
 80022fa: 4613         	mov	r3, r2
 80022fc: 6bba         	ldr	r2, [r7, #0x38]
 80022fe: 6b79         	ldr	r1, [r7, #0x34]
 8002300: 68f8         	ldr	r0, [r7, #0xc]
 8002302: f010 fa10    	bl	0x8012726 <log_msg_hexdump> @ imm = #0x10420
; 	if (!raw_string) {
 8002306: 7dfb         	ldrb	r3, [r7, #0x17]
 8002308: f083 0301    	eor	r3, r3, #0x1
 800230c: b2db         	uxtb	r3, r3
 800230e: 2b00         	cmp	r3, #0x0
 8002310: d006         	beq	0x8002320 <log_output_process+0xa4> @ imm = #0xc
; 		postfix_print(output, flags, level);
 8002312: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8002316: 461a         	mov	r2, r3
 8002318: 6bf9         	ldr	r1, [r7, #0x3c]
 800231a: 68f8         	ldr	r0, [r7, #0xc]
 800231c: f010 fa27    	bl	0x801276e <postfix_print> @ imm = #0x1044e
; 	log_output_flush(output);
 8002320: 68f8         	ldr	r0, [r7, #0xc]
 8002322: f010 f998    	bl	0x8012656 <log_output_flush> @ imm = #0x10330
; }
 8002326: bf00         	nop
 8002328: 3720         	adds	r7, #0x20
 800232a: 46bd         	mov	sp, r7
 800232c: bd80         	pop	{r7, pc}
 800232e: bf00         	nop

08002330 <$d>:
 8002330: 89 26 01 08  	.word	0x08012689
 8002334: b9 26 01 08  	.word	0x080126b9

08002338 <log_output_timestamp_freq_set>:
; {
 8002338: b480         	push	{r7}
 800233a: b083         	sub	sp, #0xc
 800233c: af00         	add	r7, sp, #0x0
 800233e: 6078         	str	r0, [r7, #0x4]
; 	timestamp_div = 1U;
 8002340: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002370 <log_output_timestamp_freq_set+0x38>
 8002342: 2201         	movs	r2, #0x1
 8002344: 601a         	str	r2, [r3]
; 	while (frequency > 1000000) {
 8002346: e007         	b	0x8002358 <log_output_timestamp_freq_set+0x20> @ imm = #0xe
; 		frequency /= 2U;
 8002348: 687b         	ldr	r3, [r7, #0x4]
 800234a: 085b         	lsrs	r3, r3, #0x1
 800234c: 607b         	str	r3, [r7, #0x4]
; 		timestamp_div *= 2U;
 800234e: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8002370 <log_output_timestamp_freq_set+0x38>
 8002350: 681b         	ldr	r3, [r3]
 8002352: 005b         	lsls	r3, r3, #0x1
 8002354: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8002370 <log_output_timestamp_freq_set+0x38>
 8002356: 6013         	str	r3, [r2]
; 	while (frequency > 1000000) {
 8002358: 687b         	ldr	r3, [r7, #0x4]
 800235a: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8002374 <log_output_timestamp_freq_set+0x3c>
 800235c: 4293         	cmp	r3, r2
 800235e: d8f3         	bhi	0x8002348 <log_output_timestamp_freq_set+0x10> @ imm = #-0x1a
; 	freq = frequency;
 8002360: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8002378 <log_output_timestamp_freq_set+0x40>
 8002362: 687b         	ldr	r3, [r7, #0x4]
 8002364: 6013         	str	r3, [r2]
; }
 8002366: bf00         	nop
 8002368: 370c         	adds	r7, #0xc
 800236a: 46bd         	mov	sp, r7
 800236c: bc80         	pop	{r7}
 800236e: 4770         	bx	lr

08002370 <$d>:
 8002370: 24 0b 00 20  	.word	0x20000b24
 8002374: 40 42 0f 00  	.word	0x000f4240
 8002378: 20 0b 00 20  	.word	0x20000b20

0800237c <char_out>:
; {
 800237c: b580         	push	{r7, lr}
 800237e: b088         	sub	sp, #0x20
 8002380: af00         	add	r7, sp, #0x0
 8002382: 60f8         	str	r0, [r7, #0xc]
 8002384: 60b9         	str	r1, [r7, #0x8]
 8002386: 607a         	str	r2, [r7, #0x4]
; 	const struct lbu_cb_ctx *cb_ctx = ctx;
 8002388: 687b         	ldr	r3, [r7, #0x4]
 800238a: 61bb         	str	r3, [r7, #0x18]
; 	struct lbu_data *lb_data = cb_ctx->data;
 800238c: 69bb         	ldr	r3, [r7, #0x18]
 800238e: 685b         	ldr	r3, [r3, #0x4]
 8002390: 617b         	str	r3, [r7, #0x14]
; 	const struct device *uart_dev = LBU_UART_DEV(cb_ctx);
 8002392: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80023e8 <char_out+0x6c>
 8002394: 613b         	str	r3, [r7, #0x10]
; 	if (pm_device_runtime_get(uart_dev) < 0) {
 8002396: 6938         	ldr	r0, [r7, #0x10]
 8002398: f010 fae1    	bl	0x801295e <pm_device_runtime_get> @ imm = #0x105c2
 800239c: 4603         	mov	r3, r0
 800239e: 2b00         	cmp	r3, #0x0
 80023a0: da01         	bge	0x80023a6 <char_out+0x2a> @ imm = #0x2
; 		return length;
 80023a2: 68b9         	ldr	r1, [r7, #0x8]
 80023a4: e01a         	b	0x80023dc <char_out+0x60> @ imm = #0x34
; 		for (size_t i = 0; i < length; i++) {
 80023a6: 2300         	movs	r3, #0x0
 80023a8: 61fb         	str	r3, [r7, #0x1c]
 80023aa: e00a         	b	0x80023c2 <char_out+0x46> @ imm = #0x14
; 			uart_poll_out(uart_dev, data[i]);
 80023ac: 68fa         	ldr	r2, [r7, #0xc]
 80023ae: 69fb         	ldr	r3, [r7, #0x1c]
 80023b0: 4413         	add	r3, r2
 80023b2: 781b         	ldrb	r3, [r3]
 80023b4: 4619         	mov	r1, r3
 80023b6: 6938         	ldr	r0, [r7, #0x10]
 80023b8: f010 fac2    	bl	0x8012940 <uart_poll_out> @ imm = #0x10584
; 		for (size_t i = 0; i < length; i++) {
 80023bc: 69fb         	ldr	r3, [r7, #0x1c]
 80023be: 3301         	adds	r3, #0x1
 80023c0: 61fb         	str	r3, [r7, #0x1c]
 80023c2: 69fa         	ldr	r2, [r7, #0x1c]
 80023c4: 68bb         	ldr	r3, [r7, #0x8]
 80023c6: 429a         	cmp	r2, r3
 80023c8: d3f0         	blo	0x80023ac <char_out+0x30> @ imm = #-0x20
; 		goto cleanup;
 80023ca: bf00         	nop
; 	(void)pm_device_runtime_put_async(uart_dev, K_MSEC(1));
 80023cc: f04f 020a    	mov.w	r2, #0xa
 80023d0: f04f 0300    	mov.w	r3, #0x0
 80023d4: 6938         	ldr	r0, [r7, #0x10]
 80023d6: f010 facc    	bl	0x8012972 <pm_device_runtime_put_async> @ imm = #0x10598
; 	return length;
 80023da: 68b9         	ldr	r1, [r7, #0x8]
; }
 80023dc: 460b         	mov	r3, r1
 80023de: 4618         	mov	r0, r3
 80023e0: 3720         	adds	r7, #0x20
 80023e2: 46bd         	mov	sp, r7
 80023e4: bd80         	pop	{r7, pc}
 80023e6: bf00         	nop

080023e8 <$d>:
 80023e8: f0 ad 01 08  	.word	0x0801adf0

080023ec <log_backend_uart_init>:
; {
 80023ec: b580         	push	{r7, lr}
 80023ee: b086         	sub	sp, #0x18
 80023f0: af00         	add	r7, sp, #0x0
 80023f2: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 80023f4: 687b         	ldr	r3, [r7, #0x4]
 80023f6: 685b         	ldr	r3, [r3, #0x4]
 80023f8: 681b         	ldr	r3, [r3]
 80023fa: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 80023fc: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8002418 <log_backend_uart_init+0x2c>
 80023fe: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 8002400: 693b         	ldr	r3, [r7, #0x10]
 8002402: 685b         	ldr	r3, [r3, #0x4]
 8002404: 617b         	str	r3, [r7, #0x14]
; 	log_output_ctx_set(ctx->output, (void *)ctx);
 8002406: 693b         	ldr	r3, [r7, #0x10]
 8002408: 681b         	ldr	r3, [r3]
 800240a: 6939         	ldr	r1, [r7, #0x10]
 800240c: 4618         	mov	r0, r3
 800240e: f010 fa58    	bl	0x80128c2 <log_output_ctx_set> @ imm = #0x104b0
; }
 8002412: 3718         	adds	r7, #0x18
 8002414: 46bd         	mov	sp, r7
 8002416: bd80         	pop	{r7, pc}

08002418 <$d>:
 8002418: f0 ad 01 08  	.word	0x0801adf0

0800241c <panic>:
; {
 800241c: b580         	push	{r7, lr}
 800241e: b086         	sub	sp, #0x18
 8002420: af00         	add	r7, sp, #0x0
 8002422: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8002424: 687b         	ldr	r3, [r7, #0x4]
 8002426: 685b         	ldr	r3, [r3, #0x4]
 8002428: 681b         	ldr	r3, [r3]
 800242a: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 800242c: 697b         	ldr	r3, [r7, #0x14]
 800242e: 685b         	ldr	r3, [r3, #0x4]
 8002430: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 8002432: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8002450 <panic+0x34>
 8002434: 60fb         	str	r3, [r7, #0xc]
; 	data->in_panic = true;
 8002436: 693b         	ldr	r3, [r7, #0x10]
 8002438: 2201         	movs	r2, #0x1
 800243a: 751a         	strb	r2, [r3, #0x14]
; 	log_backend_std_panic(ctx->output);
 800243c: 697b         	ldr	r3, [r7, #0x14]
 800243e: 681b         	ldr	r3, [r3]
 8002440: 4618         	mov	r0, r3
 8002442: f010 fa5f    	bl	0x8012904 <log_backend_std_panic> @ imm = #0x104be
; }
 8002446: bf00         	nop
 8002448: 3718         	adds	r7, #0x18
 800244a: 46bd         	mov	sp, r7
 800244c: bd80         	pop	{r7, pc}
 800244e: bf00         	nop

08002450 <$d>:
 8002450: f0 ad 01 08  	.word	0x0801adf0

08002454 <esf_dump>:
; {
 8002454: b580         	push	{r7, lr}
 8002456: b090         	sub	sp, #0x40
 8002458: af06         	add	r7, sp, #0x18
 800245a: 6078         	str	r0, [r7, #0x4]
; 	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
 800245c: 2303         	movs	r3, #0x3
 800245e: 2b00         	cmp	r3, #0x0
 8002460: d020         	beq	0x80024a4 <esf_dump+0x50> @ imm = #0x40
 8002462: 2301         	movs	r3, #0x1
 8002464: 73bb         	strb	r3, [r7, #0xe]
 8002466: 7bbb         	ldrb	r3, [r7, #0xe]
 8002468: f083 0301    	eor	r3, r3, #0x1
 800246c: b2db         	uxtb	r3, r3
 800246e: 2b00         	cmp	r3, #0x0
 8002470: d118         	bne	0x80024a4 <esf_dump+0x50> @ imm = #0x30
 8002472: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800256c <esf_dump+0x118>
 8002474: 6818         	ldr	r0, [r3]
 8002476: 687b         	ldr	r3, [r7, #0x4]
 8002478: 681b         	ldr	r3, [r3]
 800247a: 687a         	ldr	r2, [r7, #0x4]
 800247c: 6852         	ldr	r2, [r2, #0x4]
 800247e: 6879         	ldr	r1, [r7, #0x4]
 8002480: 6889         	ldr	r1, [r1, #0x8]
 8002482: 9105         	str	r1, [sp, #0x14]
 8002484: 9204         	str	r2, [sp, #0x10]
 8002486: 9303         	str	r3, [sp, #0xc]
 8002488: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8002570 <esf_dump+0x11c>
 800248a: 9302         	str	r3, [sp, #0x8]
 800248c: 2300         	movs	r3, #0x0
 800248e: 9301         	str	r3, [sp, #0x4]
 8002490: 2300         	movs	r3, #0x0
 8002492: 9300         	str	r3, [sp]
 8002494: 2300         	movs	r3, #0x0
 8002496: 2201         	movs	r2, #0x1
 8002498: 4601         	mov	r1, r0
 800249a: 2000         	movs	r0, #0x0
 800249c: f010 faa9    	bl	0x80129f2 <z_log_msg_runtime_create> @ imm = #0x10552
 80024a0: 2300         	movs	r3, #0x0
 80024a2: 613b         	str	r3, [r7, #0x10]
; 	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
 80024a4: 2303         	movs	r3, #0x3
 80024a6: 2b00         	cmp	r3, #0x0
 80024a8: d020         	beq	0x80024ec <esf_dump+0x98> @ imm = #0x40
 80024aa: 2301         	movs	r3, #0x1
 80024ac: 73fb         	strb	r3, [r7, #0xf]
 80024ae: 7bfb         	ldrb	r3, [r7, #0xf]
 80024b0: f083 0301    	eor	r3, r3, #0x1
 80024b4: b2db         	uxtb	r3, r3
 80024b6: 2b00         	cmp	r3, #0x0
 80024b8: d118         	bne	0x80024ec <esf_dump+0x98> @ imm = #0x30
 80024ba: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800256c <esf_dump+0x118>
 80024bc: 6818         	ldr	r0, [r3]
 80024be: 687b         	ldr	r3, [r7, #0x4]
 80024c0: 68db         	ldr	r3, [r3, #0xc]
 80024c2: 687a         	ldr	r2, [r7, #0x4]
 80024c4: 6912         	ldr	r2, [r2, #0x10]
 80024c6: 6879         	ldr	r1, [r7, #0x4]
 80024c8: 6949         	ldr	r1, [r1, #0x14]
 80024ca: 9105         	str	r1, [sp, #0x14]
 80024cc: 9204         	str	r2, [sp, #0x10]
 80024ce: 9303         	str	r3, [sp, #0xc]
 80024d0: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8002574 <esf_dump+0x120>
 80024d2: 9302         	str	r3, [sp, #0x8]
 80024d4: 2300         	movs	r3, #0x0
 80024d6: 9301         	str	r3, [sp, #0x4]
 80024d8: 2300         	movs	r3, #0x0
 80024da: 9300         	str	r3, [sp]
 80024dc: 2300         	movs	r3, #0x0
 80024de: 2201         	movs	r2, #0x1
 80024e0: 4601         	mov	r1, r0
 80024e2: 2000         	movs	r0, #0x0
 80024e4: f010 fa85    	bl	0x80129f2 <z_log_msg_runtime_create> @ imm = #0x1050a
 80024e8: 2300         	movs	r3, #0x0
 80024ea: 623b         	str	r3, [r7, #0x20]
; 	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
 80024ec: 2303         	movs	r3, #0x3
 80024ee: 2b00         	cmp	r3, #0x0
 80024f0: d019         	beq	0x8002526 <esf_dump+0xd2> @ imm = #0x32
 80024f2: 2301         	movs	r3, #0x1
 80024f4: 77fb         	strb	r3, [r7, #0x1f]
 80024f6: 7ffb         	ldrb	r3, [r7, #0x1f]
 80024f8: f083 0301    	eor	r3, r3, #0x1
 80024fc: b2db         	uxtb	r3, r3
 80024fe: 2b00         	cmp	r3, #0x0
 8002500: d111         	bne	0x8002526 <esf_dump+0xd2> @ imm = #0x22
 8002502: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800256c <esf_dump+0x118>
 8002504: 6819         	ldr	r1, [r3]
 8002506: 687b         	ldr	r3, [r7, #0x4]
 8002508: 69db         	ldr	r3, [r3, #0x1c]
 800250a: 9303         	str	r3, [sp, #0xc]
 800250c: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8002578 <esf_dump+0x124>
 800250e: 9302         	str	r3, [sp, #0x8]
 8002510: 2300         	movs	r3, #0x0
 8002512: 9301         	str	r3, [sp, #0x4]
 8002514: 2300         	movs	r3, #0x0
 8002516: 9300         	str	r3, [sp]
 8002518: 2300         	movs	r3, #0x0
 800251a: 2201         	movs	r2, #0x1
 800251c: 2000         	movs	r0, #0x0
 800251e: f010 fa68    	bl	0x80129f2 <z_log_msg_runtime_create> @ imm = #0x104d0
 8002522: 2300         	movs	r3, #0x0
 8002524: 61bb         	str	r3, [r7, #0x18]
; 	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
 8002526: 2303         	movs	r3, #0x3
 8002528: 2b00         	cmp	r3, #0x0
 800252a: d01a         	beq	0x8002562 <esf_dump+0x10e> @ imm = #0x34
 800252c: 2301         	movs	r3, #0x1
 800252e: 75fb         	strb	r3, [r7, #0x17]
 8002530: 7dfb         	ldrb	r3, [r7, #0x17]
 8002532: f083 0301    	eor	r3, r3, #0x1
 8002536: b2db         	uxtb	r3, r3
 8002538: 2b00         	cmp	r3, #0x0
 800253a: d112         	bne	0x8002562 <esf_dump+0x10e> @ imm = #0x24
 800253c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800256c <esf_dump+0x118>
 800253e: 6819         	ldr	r1, [r3]
 8002540: 687b         	ldr	r3, [r7, #0x4]
 8002542: 699b         	ldr	r3, [r3, #0x18]
 8002544: 9303         	str	r3, [sp, #0xc]
 8002546: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800257c <esf_dump+0x128>
 8002548: 9302         	str	r3, [sp, #0x8]
 800254a: 2300         	movs	r3, #0x0
 800254c: 9301         	str	r3, [sp, #0x4]
 800254e: 2300         	movs	r3, #0x0
 8002550: 9300         	str	r3, [sp]
 8002552: 2300         	movs	r3, #0x0
 8002554: 2201         	movs	r2, #0x1
 8002556: 2000         	movs	r0, #0x0
 8002558: f010 fa4b    	bl	0x80129f2 <z_log_msg_runtime_create> @ imm = #0x10496
 800255c: 2300         	movs	r3, #0x0
 800255e: 627b         	str	r3, [r7, #0x24]
; }
 8002560: bf00         	nop
 8002562: bf00         	nop
 8002564: 3728         	adds	r7, #0x28
 8002566: 46bd         	mov	sp, r7
 8002568: bd80         	pop	{r7, pc}
 800256a: bf00         	nop

0800256c <$d>:
 800256c: 24 04 00 20  	.word	0x20000424
 8002570: 08 b6 01 08  	.word	0x0801b608
 8002574: 38 b6 01 08  	.word	0x0801b638
 8002578: 68 b6 01 08  	.word	0x0801b668
 800257c: 78 b6 01 08  	.word	0x0801b678

08002580 <z_arm_fatal_error>:
; {
 8002580: b580         	push	{r7, lr}
 8002582: b08a         	sub	sp, #0x28
 8002584: af04         	add	r7, sp, #0x10
 8002586: 6078         	str	r0, [r7, #0x4]
 8002588: 6039         	str	r1, [r7]
; 	if (esf != NULL) {
 800258a: 683b         	ldr	r3, [r7]
 800258c: 2b00         	cmp	r3, #0x0
 800258e: d002         	beq	0x8002596 <z_arm_fatal_error+0x16> @ imm = #0x4
; 		esf_dump(esf);
 8002590: 6838         	ldr	r0, [r7]
 8002592: f7ff ff5f    	bl	0x8002454 <esf_dump>    @ imm = #-0x142
; 	if (reason == K_ERR_SPURIOUS_IRQ) {
 8002596: 687b         	ldr	r3, [r7, #0x4]
 8002598: 2b01         	cmp	r3, #0x1
 800259a: d121         	bne	0x80025e0 <z_arm_fatal_error+0x60> @ imm = #0x42
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800259c: f3ef 8305    	mrs	r3, ipsr
 80025a0: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 80025a2: 68bb         	ldr	r3, [r7, #0x8]
; 		uint32_t irqn = __get_IPSR() - 16;
 80025a4: 3b10         	subs	r3, #0x10
 80025a6: 617b         	str	r3, [r7, #0x14]
; 		LOG_ERR("Unhandled IRQn: %d", irqn);
 80025a8: 2303         	movs	r3, #0x3
 80025aa: 2b00         	cmp	r3, #0x0
 80025ac: d018         	beq	0x80025e0 <z_arm_fatal_error+0x60> @ imm = #0x30
 80025ae: 2301         	movs	r3, #0x1
 80025b0: 74fb         	strb	r3, [r7, #0x13]
 80025b2: 7cfb         	ldrb	r3, [r7, #0x13]
 80025b4: f083 0301    	eor	r3, r3, #0x1
 80025b8: b2db         	uxtb	r3, r3
 80025ba: 2b00         	cmp	r3, #0x0
 80025bc: d110         	bne	0x80025e0 <z_arm_fatal_error+0x60> @ imm = #0x20
 80025be: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80025f0 <z_arm_fatal_error+0x70>
 80025c0: 6819         	ldr	r1, [r3]
 80025c2: 697b         	ldr	r3, [r7, #0x14]
 80025c4: 9303         	str	r3, [sp, #0xc]
 80025c6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80025f4 <z_arm_fatal_error+0x74>
 80025c8: 9302         	str	r3, [sp, #0x8]
 80025ca: 2300         	movs	r3, #0x0
 80025cc: 9301         	str	r3, [sp, #0x4]
 80025ce: 2300         	movs	r3, #0x0
 80025d0: 9300         	str	r3, [sp]
 80025d2: 2300         	movs	r3, #0x0
 80025d4: 2201         	movs	r2, #0x1
 80025d6: 2000         	movs	r0, #0x0
 80025d8: f010 fa0b    	bl	0x80129f2 <z_log_msg_runtime_create> @ imm = #0x10416
 80025dc: 2300         	movs	r3, #0x0
 80025de: 60fb         	str	r3, [r7, #0xc]
; 	z_fatal_error(reason, esf);
 80025e0: 6839         	ldr	r1, [r7]
 80025e2: 6878         	ldr	r0, [r7, #0x4]
 80025e4: f009 fb7a    	bl	0x800bcdc <z_fatal_error> @ imm = #0x96f4
; }
 80025e8: bf00         	nop
 80025ea: 3718         	adds	r7, #0x18
 80025ec: 46bd         	mov	sp, r7
 80025ee: bd80         	pop	{r7, pc}

080025f0 <$d>:
 80025f0: 24 04 00 20  	.word	0x20000424
 80025f4: a8 b6 01 08  	.word	0x0801b6a8

080025f8 <z_arm_nmi>:
; {
 80025f8: b580         	push	{r7, lr}
 80025fa: af00         	add	r7, sp, #0x0
; 	handler();
 80025fc: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800260c <z_arm_nmi+0x14>
 80025fe: 681b         	ldr	r3, [r3]
 8002600: 4798         	blx	r3
; 	z_arm_int_exit();
 8002602: f000 f835    	bl	0x8002670 <z_arm_int_exit> @ imm = #0x6a
; }
 8002606: bf00         	nop
 8002608: bd80         	pop	{r7, pc}
 800260a: bf00         	nop

0800260c <$d>:
 800260c: 28 04 00 20  	.word	0x20000428

08002610 <z_SysNmiOnReset>:
;     wfi
 8002610: bf30         	wfi
;     b z_SysNmiOnReset
 8002612: f7ff bffd    	b.w	0x8002610 <z_SysNmiOnReset> @ imm = #-0x6
 8002616: bf00         	nop

08002618 <z_tls_data_size>:
; {
 8002618: b480         	push	{r7}
 800261a: af00         	add	r7, sp, #0x0
; 	return (size_t)(uintptr_t)__tdata_size +
 800261c: 4a03         	ldr	r2, [pc, #0xc]          @ 0x800262c <z_tls_data_size+0x14>
; 	       (size_t)(uintptr_t)__tbss_size;
 800261e: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8002630 <z_tls_data_size+0x18>
; 	return (size_t)(uintptr_t)__tdata_size +
 8002620: 4413         	add	r3, r2
; }
 8002622: 4618         	mov	r0, r3
 8002624: 46bd         	mov	sp, r7
 8002626: bc80         	pop	{r7}
 8002628: 4770         	bx	lr
 800262a: bf00         	nop

0800262c <$d>:
 800262c: 00 00 00 00  	.word	0x00000000
 8002630: 04 00 00 00  	.word	0x00000004

08002634 <z_tls_copy>:
; {
 8002634: b580         	push	{r7, lr}
 8002636: b082         	sub	sp, #0x8
 8002638: af00         	add	r7, sp, #0x0
 800263a: 6078         	str	r0, [r7, #0x4]
; 	memcpy(dest, __tdata_start, (size_t)(uintptr_t)__tdata_size);
 800263c: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8002664 <z_tls_copy+0x30>
 800263e: 461a         	mov	r2, r3
 8002640: 4909         	ldr	r1, [pc, #0x24]         @ 0x8002668 <z_tls_copy+0x34>
 8002642: 6878         	ldr	r0, [r7, #0x4]
 8002644: f018 f8e6    	bl	0x801a814 <memcpy>      @ imm = #0x181cc
; 	dest += (size_t)(uintptr_t)__tdata_size;
 8002648: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8002664 <z_tls_copy+0x30>
 800264a: 687b         	ldr	r3, [r7, #0x4]
 800264c: 4413         	add	r3, r2
 800264e: 607b         	str	r3, [r7, #0x4]
; 	memset(dest, 0, (size_t)(uintptr_t)__tbss_size);
 8002650: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800266c <z_tls_copy+0x38>
 8002652: 461a         	mov	r2, r3
 8002654: 2100         	movs	r1, #0x0
 8002656: 6878         	ldr	r0, [r7, #0x4]
 8002658: f018 f8ea    	bl	0x801a830 <memset>      @ imm = #0x181d4
; }
 800265c: bf00         	nop
 800265e: 3708         	adds	r7, #0x8
 8002660: 46bd         	mov	sp, r7
 8002662: bd80         	pop	{r7, pc}

08002664 <$d>:
 8002664: 00 00 00 00  	.word	0x00000000
 8002668: b8 b2 01 08  	.word	0x0801b2b8
 800266c: 04 00 00 00  	.word	0x00000004

08002670 <z_arm_int_exit>:
; {
 8002670: b480         	push	{r7}
 8002672: af00         	add	r7, sp, #0x0
; 	if (_kernel.cpus->current->base.prio >= 0) {
 8002674: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80026a0 <z_arm_int_exit+0x30>
 8002676: 689b         	ldr	r3, [r3, #0x8]
 8002678: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800267c: 2b00         	cmp	r3, #0x0
 800267e: db0b         	blt	0x8002698 <z_arm_int_exit+0x28> @ imm = #0x16
; 		if (_kernel.ready_q.cache != _kernel.cpus->current) {
 8002680: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80026a0 <z_arm_int_exit+0x30>
 8002682: 69da         	ldr	r2, [r3, #0x1c]
 8002684: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80026a0 <z_arm_int_exit+0x30>
 8002686: 689b         	ldr	r3, [r3, #0x8]
 8002688: 429a         	cmp	r2, r3
 800268a: d005         	beq	0x8002698 <z_arm_int_exit+0x28> @ imm = #0xa
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 800268c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80026a4 <z_arm_int_exit+0x34>
 800268e: 685b         	ldr	r3, [r3, #0x4]
 8002690: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80026a4 <z_arm_int_exit+0x34>
 8002692: f043 5380    	orr	r3, r3, #0x10000000
 8002696: 6053         	str	r3, [r2, #0x4]
; }
 8002698: bf00         	nop
 800269a: 46bd         	mov	sp, r7
 800269c: bc80         	pop	{r7}
 800269e: 4770         	bx	lr

080026a0 <$d>:
 80026a0: 30 07 00 20  	.word	0x20000730
 80026a4: 00 ed 00 e0  	.word	0xe000ed00

080026a8 <mem_manage_fault>:
; {
 80026a8: b580         	push	{r7, lr}
 80026aa: b09a         	sub	sp, #0x68
 80026ac: af04         	add	r7, sp, #0x10
 80026ae: 60f8         	str	r0, [r7, #0xc]
 80026b0: 60b9         	str	r1, [r7, #0x8]
 80026b2: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
 80026b4: 2310         	movs	r3, #0x10
 80026b6: 657b         	str	r3, [r7, #0x54]
; 	uint32_t mmfar = -EINVAL;
 80026b8: f06f 0315    	mvn	r3, #0x15
 80026bc: 653b         	str	r3, [r7, #0x50]
; 	PR_FAULT_INFO("***** MPU FAULT *****");
 80026be: 2303         	movs	r3, #0x3
 80026c0: 2b00         	cmp	r3, #0x0
 80026c2: d018         	beq	0x80026f6 <mem_manage_fault+0x4e> @ imm = #0x30
 80026c4: 2301         	movs	r3, #0x1
 80026c6: f887 304f    	strb.w	r3, [r7, #0x4f]
 80026ca: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 80026ce: f083 0301    	eor	r3, r3, #0x1
 80026d2: b2db         	uxtb	r3, r3
 80026d4: 2b00         	cmp	r3, #0x0
 80026d6: d10e         	bne	0x80026f6 <mem_manage_fault+0x4e> @ imm = #0x1c
 80026d8: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x800290c <mem_manage_fault+0x264>
 80026da: 6819         	ldr	r1, [r3]
 80026dc: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x8002910 <mem_manage_fault+0x268>
 80026de: 9302         	str	r3, [sp, #0x8]
 80026e0: 2300         	movs	r3, #0x0
 80026e2: 9301         	str	r3, [sp, #0x4]
 80026e4: 2300         	movs	r3, #0x0
 80026e6: 9300         	str	r3, [sp]
 80026e8: 2300         	movs	r3, #0x0
 80026ea: 2201         	movs	r2, #0x1
 80026ec: 2000         	movs	r0, #0x0
 80026ee: f010 f9d2    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0x103a4
 80026f2: 2300         	movs	r3, #0x0
 80026f4: 64bb         	str	r3, [r7, #0x48]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 80026f6: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8002914 <mem_manage_fault+0x26c>
 80026f8: 6a9b         	ldr	r3, [r3, #0x28]
 80026fa: f003 0310    	and	r3, r3, #0x10
 80026fe: 2b00         	cmp	r3, #0x0
 8002700: d01d         	beq	0x800273e <mem_manage_fault+0x96> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_STACKING;
 8002702: 2311         	movs	r3, #0x11
 8002704: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error (context area might be"
 8002706: 2303         	movs	r3, #0x3
 8002708: 2b00         	cmp	r3, #0x0
 800270a: d018         	beq	0x800273e <mem_manage_fault+0x96> @ imm = #0x30
 800270c: 2301         	movs	r3, #0x1
 800270e: f887 3047    	strb.w	r3, [r7, #0x47]
 8002712: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8002716: f083 0301    	eor	r3, r3, #0x1
 800271a: b2db         	uxtb	r3, r3
 800271c: 2b00         	cmp	r3, #0x0
 800271e: d10e         	bne	0x800273e <mem_manage_fault+0x96> @ imm = #0x1c
 8002720: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x800290c <mem_manage_fault+0x264>
 8002722: 6819         	ldr	r1, [r3]
 8002724: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x8002918 <mem_manage_fault+0x270>
 8002726: 9302         	str	r3, [sp, #0x8]
 8002728: 2300         	movs	r3, #0x0
 800272a: 9301         	str	r3, [sp, #0x4]
 800272c: 2300         	movs	r3, #0x0
 800272e: 9300         	str	r3, [sp]
 8002730: 2300         	movs	r3, #0x0
 8002732: 2201         	movs	r2, #0x1
 8002734: 2000         	movs	r0, #0x0
 8002736: f010 f9ae    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0x1035c
 800273a: 2300         	movs	r3, #0x0
 800273c: 643b         	str	r3, [r7, #0x40]
; 	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 800273e: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8002914 <mem_manage_fault+0x26c>
 8002740: 6a9b         	ldr	r3, [r3, #0x28]
 8002742: f003 0308    	and	r3, r3, #0x8
 8002746: 2b00         	cmp	r3, #0x0
 8002748: d01d         	beq	0x8002786 <mem_manage_fault+0xde> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_UNSTACKING;
 800274a: 2312         	movs	r3, #0x12
 800274c: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 800274e: 2303         	movs	r3, #0x3
 8002750: 2b00         	cmp	r3, #0x0
 8002752: d018         	beq	0x8002786 <mem_manage_fault+0xde> @ imm = #0x30
 8002754: 2301         	movs	r3, #0x1
 8002756: f887 303f    	strb.w	r3, [r7, #0x3f]
 800275a: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800275e: f083 0301    	eor	r3, r3, #0x1
 8002762: b2db         	uxtb	r3, r3
 8002764: 2b00         	cmp	r3, #0x0
 8002766: d10e         	bne	0x8002786 <mem_manage_fault+0xde> @ imm = #0x1c
 8002768: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x800290c <mem_manage_fault+0x264>
 800276a: 6819         	ldr	r1, [r3]
 800276c: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x800291c <mem_manage_fault+0x274>
 800276e: 9302         	str	r3, [sp, #0x8]
 8002770: 2300         	movs	r3, #0x0
 8002772: 9301         	str	r3, [sp, #0x4]
 8002774: 2300         	movs	r3, #0x0
 8002776: 9300         	str	r3, [sp]
 8002778: 2300         	movs	r3, #0x0
 800277a: 2201         	movs	r2, #0x1
 800277c: 2000         	movs	r0, #0x0
 800277e: f010 f98a    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0x10314
 8002782: 2300         	movs	r3, #0x0
 8002784: 63bb         	str	r3, [r7, #0x38]
; 	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 8002786: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8002914 <mem_manage_fault+0x26c>
 8002788: 6a9b         	ldr	r3, [r3, #0x28]
 800278a: f003 0302    	and	r3, r3, #0x2
 800278e: 2b00         	cmp	r3, #0x0
 8002790: d04f         	beq	0x8002832 <mem_manage_fault+0x18a> @ imm = #0x9e
; 		reason = K_ERR_ARM_MEM_DATA_ACCESS;
 8002792: 2313         	movs	r3, #0x13
 8002794: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Data Access Violation");
 8002796: 2303         	movs	r3, #0x3
 8002798: 2b00         	cmp	r3, #0x0
 800279a: d018         	beq	0x80027ce <mem_manage_fault+0x126> @ imm = #0x30
 800279c: 2301         	movs	r3, #0x1
 800279e: f887 3037    	strb.w	r3, [r7, #0x37]
 80027a2: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80027a6: f083 0301    	eor	r3, r3, #0x1
 80027aa: b2db         	uxtb	r3, r3
 80027ac: 2b00         	cmp	r3, #0x0
 80027ae: d10e         	bne	0x80027ce <mem_manage_fault+0x126> @ imm = #0x1c
 80027b0: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800290c <mem_manage_fault+0x264>
 80027b2: 6819         	ldr	r1, [r3]
 80027b4: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x8002920 <mem_manage_fault+0x278>
 80027b6: 9302         	str	r3, [sp, #0x8]
 80027b8: 2300         	movs	r3, #0x0
 80027ba: 9301         	str	r3, [sp, #0x4]
 80027bc: 2300         	movs	r3, #0x0
 80027be: 9300         	str	r3, [sp]
 80027c0: 2300         	movs	r3, #0x0
 80027c2: 2201         	movs	r2, #0x1
 80027c4: 2000         	movs	r0, #0x0
 80027c6: f010 f966    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0x102cc
 80027ca: 2300         	movs	r3, #0x0
 80027cc: 633b         	str	r3, [r7, #0x30]
; 		uint32_t temp = SCB->MMFAR;
 80027ce: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8002914 <mem_manage_fault+0x26c>
 80027d0: 6b5b         	ldr	r3, [r3, #0x34]
 80027d2: 62fb         	str	r3, [r7, #0x2c]
; 		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 80027d4: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8002914 <mem_manage_fault+0x26c>
 80027d6: 6a9b         	ldr	r3, [r3, #0x28]
 80027d8: f003 0380    	and	r3, r3, #0x80
 80027dc: 2b00         	cmp	r3, #0x0
 80027de: d028         	beq	0x8002832 <mem_manage_fault+0x18a> @ imm = #0x50
; 			mmfar = temp;
 80027e0: 6afb         	ldr	r3, [r7, #0x2c]
 80027e2: 653b         	str	r3, [r7, #0x50]
; 			PR_EXC("  MMFAR Address: 0x%x", mmfar);
 80027e4: 2303         	movs	r3, #0x3
 80027e6: 2b00         	cmp	r3, #0x0
 80027e8: d01a         	beq	0x8002820 <mem_manage_fault+0x178> @ imm = #0x34
 80027ea: 2301         	movs	r3, #0x1
 80027ec: f887 302b    	strb.w	r3, [r7, #0x2b]
 80027f0: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80027f4: f083 0301    	eor	r3, r3, #0x1
 80027f8: b2db         	uxtb	r3, r3
 80027fa: 2b00         	cmp	r3, #0x0
 80027fc: d110         	bne	0x8002820 <mem_manage_fault+0x178> @ imm = #0x20
 80027fe: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800290c <mem_manage_fault+0x264>
 8002800: 6819         	ldr	r1, [r3]
 8002802: 6d3b         	ldr	r3, [r7, #0x50]
 8002804: 9303         	str	r3, [sp, #0xc]
 8002806: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x8002924 <mem_manage_fault+0x27c>
 8002808: 9302         	str	r3, [sp, #0x8]
 800280a: 2300         	movs	r3, #0x0
 800280c: 9301         	str	r3, [sp, #0x4]
 800280e: 2300         	movs	r3, #0x0
 8002810: 9300         	str	r3, [sp]
 8002812: 2300         	movs	r3, #0x0
 8002814: 2201         	movs	r2, #0x1
 8002816: 2000         	movs	r0, #0x0
 8002818: f010 f93d    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0x1027a
 800281c: 2300         	movs	r3, #0x0
 800281e: 627b         	str	r3, [r7, #0x24]
; 			if (from_hard_fault != 0) {
 8002820: 68bb         	ldr	r3, [r7, #0x8]
 8002822: 2b00         	cmp	r3, #0x0
 8002824: d005         	beq	0x8002832 <mem_manage_fault+0x18a> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 8002826: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8002914 <mem_manage_fault+0x26c>
 8002828: 6a9b         	ldr	r3, [r3, #0x28]
 800282a: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x8002914 <mem_manage_fault+0x26c>
 800282c: f023 0380    	bic	r3, r3, #0x80
 8002830: 6293         	str	r3, [r2, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 8002832: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8002914 <mem_manage_fault+0x26c>
 8002834: 6a9b         	ldr	r3, [r3, #0x28]
 8002836: f003 0301    	and	r3, r3, #0x1
 800283a: 2b00         	cmp	r3, #0x0
 800283c: d01d         	beq	0x800287a <mem_manage_fault+0x1d2> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
 800283e: 2314         	movs	r3, #0x14
 8002840: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction Access Violation");
 8002842: 2303         	movs	r3, #0x3
 8002844: 2b00         	cmp	r3, #0x0
 8002846: d018         	beq	0x800287a <mem_manage_fault+0x1d2> @ imm = #0x30
 8002848: 2301         	movs	r3, #0x1
 800284a: f887 3023    	strb.w	r3, [r7, #0x23]
 800284e: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8002852: f083 0301    	eor	r3, r3, #0x1
 8002856: b2db         	uxtb	r3, r3
 8002858: 2b00         	cmp	r3, #0x0
 800285a: d10e         	bne	0x800287a <mem_manage_fault+0x1d2> @ imm = #0x1c
 800285c: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800290c <mem_manage_fault+0x264>
 800285e: 6819         	ldr	r1, [r3]
 8002860: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8002928 <mem_manage_fault+0x280>
 8002862: 9302         	str	r3, [sp, #0x8]
 8002864: 2300         	movs	r3, #0x0
 8002866: 9301         	str	r3, [sp, #0x4]
 8002868: 2300         	movs	r3, #0x0
 800286a: 9300         	str	r3, [sp]
 800286c: 2300         	movs	r3, #0x0
 800286e: 2201         	movs	r2, #0x1
 8002870: 2000         	movs	r0, #0x0
 8002872: f010 f910    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0x10220
 8002876: 2300         	movs	r3, #0x0
 8002878: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 800287a: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8002914 <mem_manage_fault+0x26c>
 800287c: 6a9b         	ldr	r3, [r3, #0x28]
 800287e: f003 0320    	and	r3, r3, #0x20
 8002882: 2b00         	cmp	r3, #0x0
 8002884: d01b         	beq	0x80028be <mem_manage_fault+0x216> @ imm = #0x36
; 		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
 8002886: 2315         	movs	r3, #0x15
 8002888: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO(
 800288a: 2303         	movs	r3, #0x3
 800288c: 2b00         	cmp	r3, #0x0
 800288e: d016         	beq	0x80028be <mem_manage_fault+0x216> @ imm = #0x2c
 8002890: 2301         	movs	r3, #0x1
 8002892: 76fb         	strb	r3, [r7, #0x1b]
 8002894: 7efb         	ldrb	r3, [r7, #0x1b]
 8002896: f083 0301    	eor	r3, r3, #0x1
 800289a: b2db         	uxtb	r3, r3
 800289c: 2b00         	cmp	r3, #0x0
 800289e: d10e         	bne	0x80028be <mem_manage_fault+0x216> @ imm = #0x1c
 80028a0: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800290c <mem_manage_fault+0x264>
 80028a2: 6819         	ldr	r1, [r3]
 80028a4: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800292c <mem_manage_fault+0x284>
 80028a6: 9302         	str	r3, [sp, #0x8]
 80028a8: 2300         	movs	r3, #0x0
 80028aa: 9301         	str	r3, [sp, #0x4]
 80028ac: 2300         	movs	r3, #0x0
 80028ae: 9300         	str	r3, [sp]
 80028b0: 2300         	movs	r3, #0x0
 80028b2: 2201         	movs	r2, #0x1
 80028b4: 2000         	movs	r0, #0x0
 80028b6: f010 f8ee    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0x101dc
 80028ba: 2300         	movs	r3, #0x0
 80028bc: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 80028be: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8002914 <mem_manage_fault+0x26c>
 80028c0: 6a9b         	ldr	r3, [r3, #0x28]
 80028c2: f003 0310    	and	r3, r3, #0x10
 80028c6: 2b00         	cmp	r3, #0x0
 80028c8: d101         	bne	0x80028ce <mem_manage_fault+0x226> @ imm = #0x2
; 		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
 80028ca: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8002914 <mem_manage_fault+0x26c>
 80028cc: 6a9b         	ldr	r3, [r3, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 80028ce: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8002914 <mem_manage_fault+0x26c>
 80028d0: 6a9b         	ldr	r3, [r3, #0x28]
 80028d2: f003 0320    	and	r3, r3, #0x20
 80028d6: 2b00         	cmp	r3, #0x0
 80028d8: d005         	beq	0x80028e6 <mem_manage_fault+0x23e> @ imm = #0xa
; 		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
 80028da: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8002914 <mem_manage_fault+0x26c>
 80028dc: 6a5b         	ldr	r3, [r3, #0x24]
 80028de: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8002914 <mem_manage_fault+0x26c>
 80028e0: f423 5300    	bic	r3, r3, #0x2000
 80028e4: 6253         	str	r3, [r2, #0x24]
; 	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 80028e6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002914 <mem_manage_fault+0x26c>
 80028e8: 6a9b         	ldr	r3, [r3, #0x28]
 80028ea: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8002914 <mem_manage_fault+0x26c>
 80028ec: f043 03ff    	orr	r3, r3, #0xff
 80028f0: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 80028f2: 2101         	movs	r1, #0x1
 80028f4: 68f8         	ldr	r0, [r7, #0xc]
 80028f6: f010 f8f6    	bl	0x8012ae6 <memory_fault_recoverable> @ imm = #0x101ec
 80028fa: 4603         	mov	r3, r0
 80028fc: 461a         	mov	r2, r3
 80028fe: 687b         	ldr	r3, [r7, #0x4]
 8002900: 701a         	strb	r2, [r3]
; 	return reason;
 8002902: 6d7b         	ldr	r3, [r7, #0x54]
; }
 8002904: 4618         	mov	r0, r3
 8002906: 3758         	adds	r7, #0x58
 8002908: 46bd         	mov	sp, r7
 800290a: bd80         	pop	{r7, pc}

0800290c <$d>:
 800290c: 2c 04 00 20  	.word	0x2000042c
 8002910: bc b6 01 08  	.word	0x0801b6bc
 8002914: 00 ed 00 e0  	.word	0xe000ed00
 8002918: d4 b6 01 08  	.word	0x0801b6d4
 800291c: 08 b7 01 08  	.word	0x0801b708
 8002920: 1c b7 01 08  	.word	0x0801b71c
 8002924: 34 b7 01 08  	.word	0x0801b734
 8002928: 4c b7 01 08  	.word	0x0801b74c
 800292c: 6c b7 01 08  	.word	0x0801b76c

08002930 <bus_fault>:
; {
 8002930: b580         	push	{r7, lr}
 8002932: b09a         	sub	sp, #0x68
 8002934: af04         	add	r7, sp, #0x10
 8002936: 60f8         	str	r0, [r7, #0xc]
 8002938: 60b9         	str	r1, [r7, #0x8]
 800293a: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
 800293c: 2316         	movs	r3, #0x16
 800293e: 657b         	str	r3, [r7, #0x54]
; 	PR_FAULT_INFO("***** BUS FAULT *****");
 8002940: 2303         	movs	r3, #0x3
 8002942: 2b00         	cmp	r3, #0x0
 8002944: d018         	beq	0x8002978 <bus_fault+0x48> @ imm = #0x30
 8002946: 2301         	movs	r3, #0x1
 8002948: f887 3053    	strb.w	r3, [r7, #0x53]
 800294c: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8002950: f083 0301    	eor	r3, r3, #0x1
 8002954: b2db         	uxtb	r3, r3
 8002956: 2b00         	cmp	r3, #0x0
 8002958: d10e         	bne	0x8002978 <bus_fault+0x48> @ imm = #0x1c
 800295a: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8002ba8 <bus_fault+0x278>
 800295c: 6819         	ldr	r1, [r3]
 800295e: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8002bac <bus_fault+0x27c>
 8002960: 9302         	str	r3, [sp, #0x8]
 8002962: 2300         	movs	r3, #0x0
 8002964: 9301         	str	r3, [sp, #0x4]
 8002966: 2300         	movs	r3, #0x0
 8002968: 9300         	str	r3, [sp]
 800296a: 2300         	movs	r3, #0x0
 800296c: 2201         	movs	r2, #0x1
 800296e: 2000         	movs	r0, #0x0
 8002970: f010 f891    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0x10122
 8002974: 2300         	movs	r3, #0x0
 8002976: 64fb         	str	r3, [r7, #0x4c]
; 	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 8002978: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8002bb0 <bus_fault+0x280>
 800297a: 6a9b         	ldr	r3, [r3, #0x28]
 800297c: f403 5380    	and	r3, r3, #0x1000
 8002980: 2b00         	cmp	r3, #0x0
 8002982: d01d         	beq	0x80029c0 <bus_fault+0x90> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_STACKING;
 8002984: 2317         	movs	r3, #0x17
 8002986: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error");
 8002988: 2303         	movs	r3, #0x3
 800298a: 2b00         	cmp	r3, #0x0
 800298c: d018         	beq	0x80029c0 <bus_fault+0x90> @ imm = #0x30
 800298e: 2301         	movs	r3, #0x1
 8002990: f887 304b    	strb.w	r3, [r7, #0x4b]
 8002994: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8002998: f083 0301    	eor	r3, r3, #0x1
 800299c: b2db         	uxtb	r3, r3
 800299e: 2b00         	cmp	r3, #0x0
 80029a0: d10e         	bne	0x80029c0 <bus_fault+0x90> @ imm = #0x1c
 80029a2: 4b81         	ldr	r3, [pc, #0x204]        @ 0x8002ba8 <bus_fault+0x278>
 80029a4: 6819         	ldr	r1, [r3]
 80029a6: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x8002bb4 <bus_fault+0x284>
 80029a8: 9302         	str	r3, [sp, #0x8]
 80029aa: 2300         	movs	r3, #0x0
 80029ac: 9301         	str	r3, [sp, #0x4]
 80029ae: 2300         	movs	r3, #0x0
 80029b0: 9300         	str	r3, [sp]
 80029b2: 2300         	movs	r3, #0x0
 80029b4: 2201         	movs	r2, #0x1
 80029b6: 2000         	movs	r0, #0x0
 80029b8: f010 f86d    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0x100da
 80029bc: 2300         	movs	r3, #0x0
 80029be: 647b         	str	r3, [r7, #0x44]
; 	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 80029c0: 4b7b         	ldr	r3, [pc, #0x1ec]        @ 0x8002bb0 <bus_fault+0x280>
 80029c2: 6a9b         	ldr	r3, [r3, #0x28]
 80029c4: f403 6300    	and	r3, r3, #0x800
 80029c8: 2b00         	cmp	r3, #0x0
 80029ca: d01d         	beq	0x8002a08 <bus_fault+0xd8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_UNSTACKING;
 80029cc: 2318         	movs	r3, #0x18
 80029ce: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 80029d0: 2303         	movs	r3, #0x3
 80029d2: 2b00         	cmp	r3, #0x0
 80029d4: d018         	beq	0x8002a08 <bus_fault+0xd8> @ imm = #0x30
 80029d6: 2301         	movs	r3, #0x1
 80029d8: f887 3043    	strb.w	r3, [r7, #0x43]
 80029dc: f897 3043    	ldrb.w	r3, [r7, #0x43]
 80029e0: f083 0301    	eor	r3, r3, #0x1
 80029e4: b2db         	uxtb	r3, r3
 80029e6: 2b00         	cmp	r3, #0x0
 80029e8: d10e         	bne	0x8002a08 <bus_fault+0xd8> @ imm = #0x1c
 80029ea: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x8002ba8 <bus_fault+0x278>
 80029ec: 6819         	ldr	r1, [r3]
 80029ee: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8002bb8 <bus_fault+0x288>
 80029f0: 9302         	str	r3, [sp, #0x8]
 80029f2: 2300         	movs	r3, #0x0
 80029f4: 9301         	str	r3, [sp, #0x4]
 80029f6: 2300         	movs	r3, #0x0
 80029f8: 9300         	str	r3, [sp]
 80029fa: 2300         	movs	r3, #0x0
 80029fc: 2201         	movs	r2, #0x1
 80029fe: 2000         	movs	r0, #0x0
 8002a00: f010 f849    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0x10092
 8002a04: 2300         	movs	r3, #0x0
 8002a06: 63fb         	str	r3, [r7, #0x3c]
; 	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 8002a08: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8002bb0 <bus_fault+0x280>
 8002a0a: 6a9b         	ldr	r3, [r3, #0x28]
 8002a0c: f403 7300    	and	r3, r3, #0x200
 8002a10: 2b00         	cmp	r3, #0x0
 8002a12: d04d         	beq	0x8002ab0 <bus_fault+0x180> @ imm = #0x9a
; 		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
 8002a14: 2319         	movs	r3, #0x19
 8002a16: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Precise data bus error");
 8002a18: 2303         	movs	r3, #0x3
 8002a1a: 2b00         	cmp	r3, #0x0
 8002a1c: d018         	beq	0x8002a50 <bus_fault+0x120> @ imm = #0x30
 8002a1e: 2301         	movs	r3, #0x1
 8002a20: f887 303b    	strb.w	r3, [r7, #0x3b]
 8002a24: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8002a28: f083 0301    	eor	r3, r3, #0x1
 8002a2c: b2db         	uxtb	r3, r3
 8002a2e: 2b00         	cmp	r3, #0x0
 8002a30: d10e         	bne	0x8002a50 <bus_fault+0x120> @ imm = #0x1c
 8002a32: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8002ba8 <bus_fault+0x278>
 8002a34: 6819         	ldr	r1, [r3]
 8002a36: 4b61         	ldr	r3, [pc, #0x184]        @ 0x8002bbc <bus_fault+0x28c>
 8002a38: 9302         	str	r3, [sp, #0x8]
 8002a3a: 2300         	movs	r3, #0x0
 8002a3c: 9301         	str	r3, [sp, #0x4]
 8002a3e: 2300         	movs	r3, #0x0
 8002a40: 9300         	str	r3, [sp]
 8002a42: 2300         	movs	r3, #0x0
 8002a44: 2201         	movs	r2, #0x1
 8002a46: 2000         	movs	r0, #0x0
 8002a48: f010 f825    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0x1004a
 8002a4c: 2300         	movs	r3, #0x0
 8002a4e: 637b         	str	r3, [r7, #0x34]
; 		STORE_xFAR(bfar, SCB->BFAR);
 8002a50: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8002bb0 <bus_fault+0x280>
 8002a52: 6b9b         	ldr	r3, [r3, #0x38]
 8002a54: 633b         	str	r3, [r7, #0x30]
; 		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 8002a56: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8002bb0 <bus_fault+0x280>
 8002a58: 6a9b         	ldr	r3, [r3, #0x28]
 8002a5a: f403 4300    	and	r3, r3, #0x8000
 8002a5e: 2b00         	cmp	r3, #0x0
 8002a60: d026         	beq	0x8002ab0 <bus_fault+0x180> @ imm = #0x4c
; 			PR_EXC("  BFAR Address: 0x%x", bfar);
 8002a62: 2303         	movs	r3, #0x3
 8002a64: 2b00         	cmp	r3, #0x0
 8002a66: d01a         	beq	0x8002a9e <bus_fault+0x16e> @ imm = #0x34
 8002a68: 2301         	movs	r3, #0x1
 8002a6a: f887 302f    	strb.w	r3, [r7, #0x2f]
 8002a6e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8002a72: f083 0301    	eor	r3, r3, #0x1
 8002a76: b2db         	uxtb	r3, r3
 8002a78: 2b00         	cmp	r3, #0x0
 8002a7a: d110         	bne	0x8002a9e <bus_fault+0x16e> @ imm = #0x20
 8002a7c: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x8002ba8 <bus_fault+0x278>
 8002a7e: 6819         	ldr	r1, [r3]
 8002a80: 6b3b         	ldr	r3, [r7, #0x30]
 8002a82: 9303         	str	r3, [sp, #0xc]
 8002a84: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8002bc0 <bus_fault+0x290>
 8002a86: 9302         	str	r3, [sp, #0x8]
 8002a88: 2300         	movs	r3, #0x0
 8002a8a: 9301         	str	r3, [sp, #0x4]
 8002a8c: 2300         	movs	r3, #0x0
 8002a8e: 9300         	str	r3, [sp]
 8002a90: 2300         	movs	r3, #0x0
 8002a92: 2201         	movs	r2, #0x1
 8002a94: 2000         	movs	r0, #0x0
 8002a96: f00f fffe    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfffc
 8002a9a: 2300         	movs	r3, #0x0
 8002a9c: 62bb         	str	r3, [r7, #0x28]
; 			if (from_hard_fault != 0) {
 8002a9e: 68bb         	ldr	r3, [r7, #0x8]
 8002aa0: 2b00         	cmp	r3, #0x0
 8002aa2: d005         	beq	0x8002ab0 <bus_fault+0x180> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 8002aa4: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8002bb0 <bus_fault+0x280>
 8002aa6: 6a9b         	ldr	r3, [r3, #0x28]
 8002aa8: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8002bb0 <bus_fault+0x280>
 8002aaa: f423 4300    	bic	r3, r3, #0x8000
 8002aae: 6293         	str	r3, [r2, #0x28]
; 	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 8002ab0: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x8002bb0 <bus_fault+0x280>
 8002ab2: 6a9b         	ldr	r3, [r3, #0x28]
 8002ab4: f403 6380    	and	r3, r3, #0x400
 8002ab8: 2b00         	cmp	r3, #0x0
 8002aba: d01d         	beq	0x8002af8 <bus_fault+0x1c8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
 8002abc: 231a         	movs	r3, #0x1a
 8002abe: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Imprecise data bus error");
 8002ac0: 2303         	movs	r3, #0x3
 8002ac2: 2b00         	cmp	r3, #0x0
 8002ac4: d018         	beq	0x8002af8 <bus_fault+0x1c8> @ imm = #0x30
 8002ac6: 2301         	movs	r3, #0x1
 8002ac8: f887 3027    	strb.w	r3, [r7, #0x27]
 8002acc: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8002ad0: f083 0301    	eor	r3, r3, #0x1
 8002ad4: b2db         	uxtb	r3, r3
 8002ad6: 2b00         	cmp	r3, #0x0
 8002ad8: d10e         	bne	0x8002af8 <bus_fault+0x1c8> @ imm = #0x1c
 8002ada: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8002ba8 <bus_fault+0x278>
 8002adc: 6819         	ldr	r1, [r3]
 8002ade: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8002bc4 <bus_fault+0x294>
 8002ae0: 9302         	str	r3, [sp, #0x8]
 8002ae2: 2300         	movs	r3, #0x0
 8002ae4: 9301         	str	r3, [sp, #0x4]
 8002ae6: 2300         	movs	r3, #0x0
 8002ae8: 9300         	str	r3, [sp]
 8002aea: 2300         	movs	r3, #0x0
 8002aec: 2201         	movs	r2, #0x1
 8002aee: 2000         	movs	r0, #0x0
 8002af0: f00f ffd1    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xffa2
 8002af4: 2300         	movs	r3, #0x0
 8002af6: 623b         	str	r3, [r7, #0x20]
; 	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 8002af8: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8002bb0 <bus_fault+0x280>
 8002afa: 6a9b         	ldr	r3, [r3, #0x28]
 8002afc: f403 7380    	and	r3, r3, #0x100
 8002b00: 2b00         	cmp	r3, #0x0
 8002b02: d01c         	beq	0x8002b3e <bus_fault+0x20e> @ imm = #0x38
; 		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
 8002b04: 231b         	movs	r3, #0x1b
 8002b06: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction bus error");
 8002b08: 2303         	movs	r3, #0x3
 8002b0a: 2b00         	cmp	r3, #0x0
 8002b0c: d039         	beq	0x8002b82 <bus_fault+0x252> @ imm = #0x72
 8002b0e: 2301         	movs	r3, #0x1
 8002b10: 75fb         	strb	r3, [r7, #0x17]
 8002b12: 7dfb         	ldrb	r3, [r7, #0x17]
 8002b14: f083 0301    	eor	r3, r3, #0x1
 8002b18: b2db         	uxtb	r3, r3
 8002b1a: 2b00         	cmp	r3, #0x0
 8002b1c: d131         	bne	0x8002b82 <bus_fault+0x252> @ imm = #0x62
 8002b1e: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8002ba8 <bus_fault+0x278>
 8002b20: 6819         	ldr	r1, [r3]
 8002b22: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8002bc8 <bus_fault+0x298>
 8002b24: 9302         	str	r3, [sp, #0x8]
 8002b26: 2300         	movs	r3, #0x0
 8002b28: 9301         	str	r3, [sp, #0x4]
 8002b2a: 2300         	movs	r3, #0x0
 8002b2c: 9300         	str	r3, [sp]
 8002b2e: 2300         	movs	r3, #0x0
 8002b30: 2201         	movs	r2, #0x1
 8002b32: 2000         	movs	r0, #0x0
 8002b34: f00f ffaf    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xff5e
 8002b38: 2300         	movs	r3, #0x0
 8002b3a: 613b         	str	r3, [r7, #0x10]
 8002b3c: e021         	b	0x8002b82 <bus_fault+0x252> @ imm = #0x42
; 	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
 8002b3e: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8002bb0 <bus_fault+0x280>
 8002b40: 6a9b         	ldr	r3, [r3, #0x28]
 8002b42: f403 5300    	and	r3, r3, #0x2000
 8002b46: 2b00         	cmp	r3, #0x0
 8002b48: d01b         	beq	0x8002b82 <bus_fault+0x252> @ imm = #0x36
; 		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
 8002b4a: 231c         	movs	r3, #0x1c
 8002b4c: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Floating-point lazy state preservation error");
 8002b4e: 2303         	movs	r3, #0x3
 8002b50: 2b00         	cmp	r3, #0x0
 8002b52: d016         	beq	0x8002b82 <bus_fault+0x252> @ imm = #0x2c
 8002b54: 2301         	movs	r3, #0x1
 8002b56: 77fb         	strb	r3, [r7, #0x1f]
 8002b58: 7ffb         	ldrb	r3, [r7, #0x1f]
 8002b5a: f083 0301    	eor	r3, r3, #0x1
 8002b5e: b2db         	uxtb	r3, r3
 8002b60: 2b00         	cmp	r3, #0x0
 8002b62: d10e         	bne	0x8002b82 <bus_fault+0x252> @ imm = #0x1c
 8002b64: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8002ba8 <bus_fault+0x278>
 8002b66: 6819         	ldr	r1, [r3]
 8002b68: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8002bcc <bus_fault+0x29c>
 8002b6a: 9302         	str	r3, [sp, #0x8]
 8002b6c: 2300         	movs	r3, #0x0
 8002b6e: 9301         	str	r3, [sp, #0x4]
 8002b70: 2300         	movs	r3, #0x0
 8002b72: 9300         	str	r3, [sp]
 8002b74: 2300         	movs	r3, #0x0
 8002b76: 2201         	movs	r2, #0x1
 8002b78: 2000         	movs	r0, #0x0
 8002b7a: f00f ff8c    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xff18
 8002b7e: 2300         	movs	r3, #0x0
 8002b80: 61bb         	str	r3, [r7, #0x18]
; 	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 8002b82: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002bb0 <bus_fault+0x280>
 8002b84: 6a9b         	ldr	r3, [r3, #0x28]
 8002b86: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8002bb0 <bus_fault+0x280>
 8002b88: f443 437f    	orr	r3, r3, #0xff00
 8002b8c: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 8002b8e: 2101         	movs	r1, #0x1
 8002b90: 68f8         	ldr	r0, [r7, #0xc]
 8002b92: f00f ffa8    	bl	0x8012ae6 <memory_fault_recoverable> @ imm = #0xff50
 8002b96: 4603         	mov	r3, r0
 8002b98: 461a         	mov	r2, r3
 8002b9a: 687b         	ldr	r3, [r7, #0x4]
 8002b9c: 701a         	strb	r2, [r3]
; 	return reason;
 8002b9e: 6d7b         	ldr	r3, [r7, #0x54]
; }
 8002ba0: 4618         	mov	r0, r3
 8002ba2: 3758         	adds	r7, #0x58
 8002ba4: 46bd         	mov	sp, r7
 8002ba6: bd80         	pop	{r7, pc}

08002ba8 <$d>:
 8002ba8: 2c 04 00 20  	.word	0x2000042c
 8002bac: 9c b7 01 08  	.word	0x0801b79c
 8002bb0: 00 ed 00 e0  	.word	0xe000ed00
 8002bb4: b4 b7 01 08  	.word	0x0801b7b4
 8002bb8: 08 b7 01 08  	.word	0x0801b708
 8002bbc: c8 b7 01 08  	.word	0x0801b7c8
 8002bc0: e4 b7 01 08  	.word	0x0801b7e4
 8002bc4: fc b7 01 08  	.word	0x0801b7fc
 8002bc8: 18 b8 01 08  	.word	0x0801b818
 8002bcc: 6c b7 01 08  	.word	0x0801b76c

08002bd0 <usage_fault>:
; {
 8002bd0: b580         	push	{r7, lr}
 8002bd2: b096         	sub	sp, #0x58
 8002bd4: af04         	add	r7, sp, #0x10
 8002bd6: 6078         	str	r0, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
 8002bd8: 231d         	movs	r3, #0x1d
 8002bda: 647b         	str	r3, [r7, #0x44]
; 	PR_FAULT_INFO("***** USAGE FAULT *****");
 8002bdc: 2303         	movs	r3, #0x3
 8002bde: 2b00         	cmp	r3, #0x0
 8002be0: d018         	beq	0x8002c14 <usage_fault+0x44> @ imm = #0x30
 8002be2: 2301         	movs	r3, #0x1
 8002be4: f887 3043    	strb.w	r3, [r7, #0x43]
 8002be8: f897 3043    	ldrb.w	r3, [r7, #0x43]
 8002bec: f083 0301    	eor	r3, r3, #0x1
 8002bf0: b2db         	uxtb	r3, r3
 8002bf2: 2b00         	cmp	r3, #0x0
 8002bf4: d10e         	bne	0x8002c14 <usage_fault+0x44> @ imm = #0x1c
 8002bf6: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8002dd8 <usage_fault+0x208>
 8002bf8: 6819         	ldr	r1, [r3]
 8002bfa: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8002ddc <usage_fault+0x20c>
 8002bfc: 9302         	str	r3, [sp, #0x8]
 8002bfe: 2300         	movs	r3, #0x0
 8002c00: 9301         	str	r3, [sp, #0x4]
 8002c02: 2300         	movs	r3, #0x0
 8002c04: 9300         	str	r3, [sp]
 8002c06: 2300         	movs	r3, #0x0
 8002c08: 2201         	movs	r2, #0x1
 8002c0a: 2000         	movs	r0, #0x0
 8002c0c: f00f ff43    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfe86
 8002c10: 2300         	movs	r3, #0x0
 8002c12: 63fb         	str	r3, [r7, #0x3c]
; 	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 8002c14: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8002de0 <usage_fault+0x210>
 8002c16: 6a9b         	ldr	r3, [r3, #0x28]
 8002c18: f003 7300    	and	r3, r3, #0x2000000
 8002c1c: 2b00         	cmp	r3, #0x0
 8002c1e: d01d         	beq	0x8002c5c <usage_fault+0x8c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_DIV_0;
 8002c20: 231e         	movs	r3, #0x1e
 8002c22: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Division by zero");
 8002c24: 2303         	movs	r3, #0x3
 8002c26: 2b00         	cmp	r3, #0x0
 8002c28: d018         	beq	0x8002c5c <usage_fault+0x8c> @ imm = #0x30
 8002c2a: 2301         	movs	r3, #0x1
 8002c2c: f887 303b    	strb.w	r3, [r7, #0x3b]
 8002c30: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8002c34: f083 0301    	eor	r3, r3, #0x1
 8002c38: b2db         	uxtb	r3, r3
 8002c3a: 2b00         	cmp	r3, #0x0
 8002c3c: d10e         	bne	0x8002c5c <usage_fault+0x8c> @ imm = #0x1c
 8002c3e: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8002dd8 <usage_fault+0x208>
 8002c40: 6819         	ldr	r1, [r3]
 8002c42: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8002de4 <usage_fault+0x214>
 8002c44: 9302         	str	r3, [sp, #0x8]
 8002c46: 2300         	movs	r3, #0x0
 8002c48: 9301         	str	r3, [sp, #0x4]
 8002c4a: 2300         	movs	r3, #0x0
 8002c4c: 9300         	str	r3, [sp]
 8002c4e: 2300         	movs	r3, #0x0
 8002c50: 2201         	movs	r2, #0x1
 8002c52: 2000         	movs	r0, #0x0
 8002c54: f00f ff1f    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfe3e
 8002c58: 2300         	movs	r3, #0x0
 8002c5a: 637b         	str	r3, [r7, #0x34]
; 	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 8002c5c: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8002de0 <usage_fault+0x210>
 8002c5e: 6a9b         	ldr	r3, [r3, #0x28]
 8002c60: f003 7380    	and	r3, r3, #0x1000000
 8002c64: 2b00         	cmp	r3, #0x0
 8002c66: d01d         	beq	0x8002ca4 <usage_fault+0xd4> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
 8002c68: 231f         	movs	r3, #0x1f
 8002c6a: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Unaligned memory access");
 8002c6c: 2303         	movs	r3, #0x3
 8002c6e: 2b00         	cmp	r3, #0x0
 8002c70: d018         	beq	0x8002ca4 <usage_fault+0xd4> @ imm = #0x30
 8002c72: 2301         	movs	r3, #0x1
 8002c74: f887 3033    	strb.w	r3, [r7, #0x33]
 8002c78: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8002c7c: f083 0301    	eor	r3, r3, #0x1
 8002c80: b2db         	uxtb	r3, r3
 8002c82: 2b00         	cmp	r3, #0x0
 8002c84: d10e         	bne	0x8002ca4 <usage_fault+0xd4> @ imm = #0x1c
 8002c86: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8002dd8 <usage_fault+0x208>
 8002c88: 6819         	ldr	r1, [r3]
 8002c8a: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8002de8 <usage_fault+0x218>
 8002c8c: 9302         	str	r3, [sp, #0x8]
 8002c8e: 2300         	movs	r3, #0x0
 8002c90: 9301         	str	r3, [sp, #0x4]
 8002c92: 2300         	movs	r3, #0x0
 8002c94: 9300         	str	r3, [sp]
 8002c96: 2300         	movs	r3, #0x0
 8002c98: 2201         	movs	r2, #0x1
 8002c9a: 2000         	movs	r0, #0x0
 8002c9c: f00f fefb    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfdf6
 8002ca0: 2300         	movs	r3, #0x0
 8002ca2: 62fb         	str	r3, [r7, #0x2c]
; 	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 8002ca4: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8002de0 <usage_fault+0x210>
 8002ca6: 6a9b         	ldr	r3, [r3, #0x28]
 8002ca8: f403 2300    	and	r3, r3, #0x80000
 8002cac: 2b00         	cmp	r3, #0x0
 8002cae: d01d         	beq	0x8002cec <usage_fault+0x11c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
 8002cb0: 2321         	movs	r3, #0x21
 8002cb2: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  No coprocessor instructions");
 8002cb4: 2303         	movs	r3, #0x3
 8002cb6: 2b00         	cmp	r3, #0x0
 8002cb8: d018         	beq	0x8002cec <usage_fault+0x11c> @ imm = #0x30
 8002cba: 2301         	movs	r3, #0x1
 8002cbc: f887 302b    	strb.w	r3, [r7, #0x2b]
 8002cc0: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8002cc4: f083 0301    	eor	r3, r3, #0x1
 8002cc8: b2db         	uxtb	r3, r3
 8002cca: 2b00         	cmp	r3, #0x0
 8002ccc: d10e         	bne	0x8002cec <usage_fault+0x11c> @ imm = #0x1c
 8002cce: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8002dd8 <usage_fault+0x208>
 8002cd0: 6819         	ldr	r1, [r3]
 8002cd2: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8002dec <usage_fault+0x21c>
 8002cd4: 9302         	str	r3, [sp, #0x8]
 8002cd6: 2300         	movs	r3, #0x0
 8002cd8: 9301         	str	r3, [sp, #0x4]
 8002cda: 2300         	movs	r3, #0x0
 8002cdc: 9300         	str	r3, [sp]
 8002cde: 2300         	movs	r3, #0x0
 8002ce0: 2201         	movs	r2, #0x1
 8002ce2: 2000         	movs	r0, #0x0
 8002ce4: f00f fed7    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfdae
 8002ce8: 2300         	movs	r3, #0x0
 8002cea: 627b         	str	r3, [r7, #0x24]
; 	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 8002cec: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8002de0 <usage_fault+0x210>
 8002cee: 6a9b         	ldr	r3, [r3, #0x28]
 8002cf0: f403 2380    	and	r3, r3, #0x40000
 8002cf4: 2b00         	cmp	r3, #0x0
 8002cf6: d01d         	beq	0x8002d34 <usage_fault+0x164> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
 8002cf8: 2322         	movs	r3, #0x22
 8002cfa: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
 8002cfc: 2303         	movs	r3, #0x3
 8002cfe: 2b00         	cmp	r3, #0x0
 8002d00: d018         	beq	0x8002d34 <usage_fault+0x164> @ imm = #0x30
 8002d02: 2301         	movs	r3, #0x1
 8002d04: f887 3023    	strb.w	r3, [r7, #0x23]
 8002d08: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8002d0c: f083 0301    	eor	r3, r3, #0x1
 8002d10: b2db         	uxtb	r3, r3
 8002d12: 2b00         	cmp	r3, #0x0
 8002d14: d10e         	bne	0x8002d34 <usage_fault+0x164> @ imm = #0x1c
 8002d16: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8002dd8 <usage_fault+0x208>
 8002d18: 6819         	ldr	r1, [r3]
 8002d1a: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8002df0 <usage_fault+0x220>
 8002d1c: 9302         	str	r3, [sp, #0x8]
 8002d1e: 2300         	movs	r3, #0x0
 8002d20: 9301         	str	r3, [sp, #0x4]
 8002d22: 2300         	movs	r3, #0x0
 8002d24: 9300         	str	r3, [sp]
 8002d26: 2300         	movs	r3, #0x0
 8002d28: 2201         	movs	r2, #0x1
 8002d2a: 2000         	movs	r0, #0x0
 8002d2c: f00f feb3    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfd66
 8002d30: 2300         	movs	r3, #0x0
 8002d32: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 8002d34: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8002de0 <usage_fault+0x210>
 8002d36: 6a9b         	ldr	r3, [r3, #0x28]
 8002d38: f403 3300    	and	r3, r3, #0x20000
 8002d3c: 2b00         	cmp	r3, #0x0
 8002d3e: d01b         	beq	0x8002d78 <usage_fault+0x1a8> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
 8002d40: 2323         	movs	r3, #0x23
 8002d42: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal use of the EPSR");
 8002d44: 2303         	movs	r3, #0x3
 8002d46: 2b00         	cmp	r3, #0x0
 8002d48: d016         	beq	0x8002d78 <usage_fault+0x1a8> @ imm = #0x2c
 8002d4a: 2301         	movs	r3, #0x1
 8002d4c: 76fb         	strb	r3, [r7, #0x1b]
 8002d4e: 7efb         	ldrb	r3, [r7, #0x1b]
 8002d50: f083 0301    	eor	r3, r3, #0x1
 8002d54: b2db         	uxtb	r3, r3
 8002d56: 2b00         	cmp	r3, #0x0
 8002d58: d10e         	bne	0x8002d78 <usage_fault+0x1a8> @ imm = #0x1c
 8002d5a: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8002dd8 <usage_fault+0x208>
 8002d5c: 6819         	ldr	r1, [r3]
 8002d5e: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8002df4 <usage_fault+0x224>
 8002d60: 9302         	str	r3, [sp, #0x8]
 8002d62: 2300         	movs	r3, #0x0
 8002d64: 9301         	str	r3, [sp, #0x4]
 8002d66: 2300         	movs	r3, #0x0
 8002d68: 9300         	str	r3, [sp]
 8002d6a: 2300         	movs	r3, #0x0
 8002d6c: 2201         	movs	r2, #0x1
 8002d6e: 2000         	movs	r0, #0x0
 8002d70: f00f fe91    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfd22
 8002d74: 2300         	movs	r3, #0x0
 8002d76: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 8002d78: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8002de0 <usage_fault+0x210>
 8002d7a: 6a9b         	ldr	r3, [r3, #0x28]
 8002d7c: f403 3380    	and	r3, r3, #0x10000
 8002d80: 2b00         	cmp	r3, #0x0
 8002d82: d01b         	beq	0x8002dbc <usage_fault+0x1ec> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
 8002d84: 2324         	movs	r3, #0x24
 8002d86: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Attempt to execute undefined instruction");
 8002d88: 2303         	movs	r3, #0x3
 8002d8a: 2b00         	cmp	r3, #0x0
 8002d8c: d016         	beq	0x8002dbc <usage_fault+0x1ec> @ imm = #0x2c
 8002d8e: 2301         	movs	r3, #0x1
 8002d90: 74fb         	strb	r3, [r7, #0x13]
 8002d92: 7cfb         	ldrb	r3, [r7, #0x13]
 8002d94: f083 0301    	eor	r3, r3, #0x1
 8002d98: b2db         	uxtb	r3, r3
 8002d9a: 2b00         	cmp	r3, #0x0
 8002d9c: d10e         	bne	0x8002dbc <usage_fault+0x1ec> @ imm = #0x1c
 8002d9e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8002dd8 <usage_fault+0x208>
 8002da0: 6819         	ldr	r1, [r3]
 8002da2: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8002df8 <usage_fault+0x228>
 8002da4: 9302         	str	r3, [sp, #0x8]
 8002da6: 2300         	movs	r3, #0x0
 8002da8: 9301         	str	r3, [sp, #0x4]
 8002daa: 2300         	movs	r3, #0x0
 8002dac: 9300         	str	r3, [sp]
 8002dae: 2300         	movs	r3, #0x0
 8002db0: 2201         	movs	r2, #0x1
 8002db2: 2000         	movs	r0, #0x0
 8002db4: f00f fe6f    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfcde
 8002db8: 2300         	movs	r3, #0x0
 8002dba: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 8002dbc: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8002de0 <usage_fault+0x210>
 8002dbe: 6a9b         	ldr	r3, [r3, #0x28]
 8002dc0: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8002de0 <usage_fault+0x210>
 8002dc2: ea6f 4303    	mvn.w	r3, r3, lsl #16
 8002dc6: ea6f 4313    	mvn.w	r3, r3, lsr #16
 8002dca: 6293         	str	r3, [r2, #0x28]
; 	return reason;
 8002dcc: 6c7b         	ldr	r3, [r7, #0x44]
; }
 8002dce: 4618         	mov	r0, r3
 8002dd0: 3748         	adds	r7, #0x48
 8002dd2: 46bd         	mov	sp, r7
 8002dd4: bd80         	pop	{r7, pc}
 8002dd6: bf00         	nop

08002dd8 <$d>:
 8002dd8: 2c 04 00 20  	.word	0x2000042c
 8002ddc: 30 b8 01 08  	.word	0x0801b830
 8002de0: 00 ed 00 e0  	.word	0xe000ed00
 8002de4: 48 b8 01 08  	.word	0x0801b848
 8002de8: 5c b8 01 08  	.word	0x0801b85c
 8002dec: 78 b8 01 08  	.word	0x0801b878
 8002df0: 98 b8 01 08  	.word	0x0801b898
 8002df4: c0 b8 01 08  	.word	0x0801b8c0
 8002df8: dc b8 01 08  	.word	0x0801b8dc

08002dfc <debug_monitor>:
; {
 8002dfc: b580         	push	{r7, lr}
 8002dfe: b088         	sub	sp, #0x20
 8002e00: af04         	add	r7, sp, #0x10
 8002e02: 6078         	str	r0, [r7, #0x4]
 8002e04: 6039         	str	r1, [r7]
; 	*recoverable = false;
 8002e06: 683b         	ldr	r3, [r7]
 8002e08: 2200         	movs	r2, #0x0
 8002e0a: 701a         	strb	r2, [r3]
; 	PR_FAULT_INFO(
 8002e0c: 2303         	movs	r3, #0x3
 8002e0e: 2b00         	cmp	r3, #0x0
 8002e10: d017         	beq	0x8002e42 <debug_monitor+0x46> @ imm = #0x2e
 8002e12: 2301         	movs	r3, #0x1
 8002e14: 73fb         	strb	r3, [r7, #0xf]
 8002e16: 7bfb         	ldrb	r3, [r7, #0xf]
 8002e18: f083 0301    	eor	r3, r3, #0x1
 8002e1c: b2db         	uxtb	r3, r3
 8002e1e: 2b00         	cmp	r3, #0x0
 8002e20: d10f         	bne	0x8002e42 <debug_monitor+0x46> @ imm = #0x1e
 8002e22: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8002e4c <debug_monitor+0x50>
 8002e24: 6819         	ldr	r1, [r3]
 8002e26: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8002e50 <debug_monitor+0x54>
 8002e28: 9302         	str	r3, [sp, #0x8]
 8002e2a: 2300         	movs	r3, #0x0
 8002e2c: 9301         	str	r3, [sp, #0x4]
 8002e2e: 2300         	movs	r3, #0x0
 8002e30: 9300         	str	r3, [sp]
 8002e32: 2300         	movs	r3, #0x0
 8002e34: 2201         	movs	r2, #0x1
 8002e36: 2000         	movs	r0, #0x0
 8002e38: f00f fe2d    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfc5a
 8002e3c: 2300         	movs	r3, #0x0
 8002e3e: 60bb         	str	r3, [r7, #0x8]
; }
 8002e40: bf00         	nop
 8002e42: bf00         	nop
 8002e44: 3710         	adds	r7, #0x10
 8002e46: 46bd         	mov	sp, r7
 8002e48: bd80         	pop	{r7, pc}
 8002e4a: bf00         	nop

08002e4c <$d>:
 8002e4c: 2c 04 00 20  	.word	0x2000042c
 8002e50: 08 b9 01 08  	.word	0x0801b908

08002e54 <z_arm_is_synchronous_svc>:
; {
 8002e54: b480         	push	{r7}
 8002e56: b085         	sub	sp, #0x14
 8002e58: af00         	add	r7, sp, #0x0
 8002e5a: 6078         	str	r0, [r7, #0x4]
; 	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
 8002e5c: 687b         	ldr	r3, [r7, #0x4]
 8002e5e: 699b         	ldr	r3, [r3, #0x18]
 8002e60: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
 8002e62: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8002ed0 <z_arm_is_synchronous_svc+0x7c>
 8002e64: 695b         	ldr	r3, [r3, #0x14]
 8002e66: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x8002ed0 <z_arm_is_synchronous_svc+0x7c>
 8002e68: f443 7380    	orr	r3, r3, #0x100
 8002e6c: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 8002e6e: f3bf 8f4f    	dsb	sy
; }
 8002e72: bf00         	nop
; }
 8002e74: bf00         	nop
; }
 8002e76: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8002e78: f3bf 8f6f    	isb	sy
; }
 8002e7c: bf00         	nop
; }
 8002e7e: bf00         	nop
; }
 8002e80: bf00         	nop
; 	uint16_t fault_insn = *(ret_addr - 1);
 8002e82: 68fb         	ldr	r3, [r7, #0xc]
 8002e84: f833 3c02    	ldrh	r3, [r3, #-2]
 8002e88: 817b         	strh	r3, [r7, #0xa]
; 	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
 8002e8a: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8002ed0 <z_arm_is_synchronous_svc+0x7c>
 8002e8c: 695b         	ldr	r3, [r3, #0x14]
 8002e8e: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8002ed0 <z_arm_is_synchronous_svc+0x7c>
 8002e90: f423 7380    	bic	r3, r3, #0x100
 8002e94: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 8002e96: f3bf 8f4f    	dsb	sy
; }
 8002e9a: bf00         	nop
; }
 8002e9c: bf00         	nop
; }
 8002e9e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8002ea0: f3bf 8f6f    	isb	sy
; }
 8002ea4: bf00         	nop
; }
 8002ea6: bf00         	nop
; }
 8002ea8: bf00         	nop
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 8002eaa: 897b         	ldrh	r3, [r7, #0xa]
 8002eac: f403 437f    	and	r3, r3, #0xff00
 8002eb0: f5b3 4f5f    	cmp.w	r3, #0xdf00
 8002eb4: d105         	bne	0x8002ec2 <z_arm_is_synchronous_svc+0x6e> @ imm = #0xa
; 		((fault_insn & 0x00ff) == _SVC_CALL_RUNTIME_EXCEPT)) {
 8002eb6: 897b         	ldrh	r3, [r7, #0xa]
 8002eb8: b2db         	uxtb	r3, r3
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 8002eba: 2b02         	cmp	r3, #0x2
 8002ebc: d101         	bne	0x8002ec2 <z_arm_is_synchronous_svc+0x6e> @ imm = #0x2
; 		return true;
 8002ebe: 2301         	movs	r3, #0x1
 8002ec0: e000         	b	0x8002ec4 <z_arm_is_synchronous_svc+0x70> @ imm = #0x0
; 	return false;
 8002ec2: 2300         	movs	r3, #0x0
; }
 8002ec4: 4618         	mov	r0, r3
 8002ec6: 3714         	adds	r7, #0x14
 8002ec8: 46bd         	mov	sp, r7
 8002eca: bc80         	pop	{r7}
 8002ecc: 4770         	bx	lr
 8002ece: bf00         	nop

08002ed0 <$d>:
 8002ed0: 00 ed 00 e0  	.word	0xe000ed00

08002ed4 <hard_fault>:
; {
 8002ed4: b580         	push	{r7, lr}
 8002ed6: b092         	sub	sp, #0x48
 8002ed8: af04         	add	r7, sp, #0x10
 8002eda: 6078         	str	r0, [r7, #0x4]
 8002edc: 6039         	str	r1, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8002ede: 2300         	movs	r3, #0x0
 8002ee0: 62fb         	str	r3, [r7, #0x2c]
; 	PR_FAULT_INFO("***** HARD FAULT *****");
 8002ee2: 2303         	movs	r3, #0x3
 8002ee4: 2b00         	cmp	r3, #0x0
 8002ee6: d018         	beq	0x8002f1a <hard_fault+0x46> @ imm = #0x30
 8002ee8: 2301         	movs	r3, #0x1
 8002eea: f887 3033    	strb.w	r3, [r7, #0x33]
 8002eee: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8002ef2: f083 0301    	eor	r3, r3, #0x1
 8002ef6: b2db         	uxtb	r3, r3
 8002ef8: 2b00         	cmp	r3, #0x0
 8002efa: d10e         	bne	0x8002f1a <hard_fault+0x46> @ imm = #0x1c
 8002efc: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x800308c <hard_fault+0x1b8>
 8002efe: 6819         	ldr	r1, [r3]
 8002f00: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8003090 <hard_fault+0x1bc>
 8002f02: 9302         	str	r3, [sp, #0x8]
 8002f04: 2300         	movs	r3, #0x0
 8002f06: 9301         	str	r3, [sp, #0x4]
 8002f08: 2300         	movs	r3, #0x0
 8002f0a: 9300         	str	r3, [sp]
 8002f0c: 2300         	movs	r3, #0x0
 8002f0e: 2201         	movs	r2, #0x1
 8002f10: 2000         	movs	r0, #0x0
 8002f12: f00f fdc0    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfb80
 8002f16: 2300         	movs	r3, #0x0
 8002f18: 637b         	str	r3, [r7, #0x34]
; 	*recoverable = false;
 8002f1a: 683b         	ldr	r3, [r7]
 8002f1c: 2200         	movs	r2, #0x0
 8002f1e: 701a         	strb	r2, [r3]
; 	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 8002f20: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8003094 <hard_fault+0x1c0>
 8002f22: 6adb         	ldr	r3, [r3, #0x2c]
 8002f24: f003 0302    	and	r3, r3, #0x2
 8002f28: 2b00         	cmp	r3, #0x0
 8002f2a: d01c         	beq	0x8002f66 <hard_fault+0x92> @ imm = #0x38
; 		PR_EXC("  Bus fault on vector table read");
 8002f2c: 2303         	movs	r3, #0x3
 8002f2e: 2b00         	cmp	r3, #0x0
 8002f30: f000 80a7    	beq.w	0x8003082 <hard_fault+0x1ae> @ imm = #0x14e
 8002f34: 2301         	movs	r3, #0x1
 8002f36: 74fb         	strb	r3, [r7, #0x13]
 8002f38: 7cfb         	ldrb	r3, [r7, #0x13]
 8002f3a: f083 0301    	eor	r3, r3, #0x1
 8002f3e: b2db         	uxtb	r3, r3
 8002f40: 2b00         	cmp	r3, #0x0
 8002f42: f040 809e    	bne.w	0x8003082 <hard_fault+0x1ae> @ imm = #0x13c
 8002f46: 4b51         	ldr	r3, [pc, #0x144]        @ 0x800308c <hard_fault+0x1b8>
 8002f48: 6819         	ldr	r1, [r3]
 8002f4a: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8003098 <hard_fault+0x1c4>
 8002f4c: 9302         	str	r3, [sp, #0x8]
 8002f4e: 2300         	movs	r3, #0x0
 8002f50: 9301         	str	r3, [sp, #0x4]
 8002f52: 2300         	movs	r3, #0x0
 8002f54: 9300         	str	r3, [sp]
 8002f56: 2300         	movs	r3, #0x0
 8002f58: 2201         	movs	r2, #0x1
 8002f5a: 2000         	movs	r0, #0x0
 8002f5c: f00f fd9b    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfb36
 8002f60: 2300         	movs	r3, #0x0
 8002f62: 60fb         	str	r3, [r7, #0xc]
 8002f64: e08d         	b	0x8003082 <hard_fault+0x1ae> @ imm = #0x11a
; 	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
 8002f66: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8003094 <hard_fault+0x1c0>
 8002f68: 6adb         	ldr	r3, [r3, #0x2c]
 8002f6a: 2b00         	cmp	r3, #0x0
 8002f6c: da1b         	bge	0x8002fa6 <hard_fault+0xd2> @ imm = #0x36
; 		PR_EXC("  Debug event");
 8002f6e: 2303         	movs	r3, #0x3
 8002f70: 2b00         	cmp	r3, #0x0
 8002f72: f000 8086    	beq.w	0x8003082 <hard_fault+0x1ae> @ imm = #0x10c
 8002f76: 2301         	movs	r3, #0x1
 8002f78: 76fb         	strb	r3, [r7, #0x1b]
 8002f7a: 7efb         	ldrb	r3, [r7, #0x1b]
 8002f7c: f083 0301    	eor	r3, r3, #0x1
 8002f80: b2db         	uxtb	r3, r3
 8002f82: 2b00         	cmp	r3, #0x0
 8002f84: d17d         	bne	0x8003082 <hard_fault+0x1ae> @ imm = #0xfa
 8002f86: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800308c <hard_fault+0x1b8>
 8002f88: 6819         	ldr	r1, [r3]
 8002f8a: 4b44         	ldr	r3, [pc, #0x110]        @ 0x800309c <hard_fault+0x1c8>
 8002f8c: 9302         	str	r3, [sp, #0x8]
 8002f8e: 2300         	movs	r3, #0x0
 8002f90: 9301         	str	r3, [sp, #0x4]
 8002f92: 2300         	movs	r3, #0x0
 8002f94: 9300         	str	r3, [sp]
 8002f96: 2300         	movs	r3, #0x0
 8002f98: 2201         	movs	r2, #0x1
 8002f9a: 2000         	movs	r0, #0x0
 8002f9c: f00f fd7b    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfaf6
 8002fa0: 2300         	movs	r3, #0x0
 8002fa2: 617b         	str	r3, [r7, #0x14]
 8002fa4: e06d         	b	0x8003082 <hard_fault+0x1ae> @ imm = #0xda
; 	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 8002fa6: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8003094 <hard_fault+0x1c0>
 8002fa8: 6adb         	ldr	r3, [r3, #0x2c]
 8002faa: f003 4380    	and	r3, r3, #0x40000000
 8002fae: 2b00         	cmp	r3, #0x0
 8002fb0: d067         	beq	0x8003082 <hard_fault+0x1ae> @ imm = #0xce
; 		PR_EXC("  Fault escalation (see below)");
 8002fb2: 2303         	movs	r3, #0x3
 8002fb4: 2b00         	cmp	r3, #0x0
 8002fb6: d018         	beq	0x8002fea <hard_fault+0x116> @ imm = #0x30
 8002fb8: 2301         	movs	r3, #0x1
 8002fba: f887 302b    	strb.w	r3, [r7, #0x2b]
 8002fbe: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8002fc2: f083 0301    	eor	r3, r3, #0x1
 8002fc6: b2db         	uxtb	r3, r3
 8002fc8: 2b00         	cmp	r3, #0x0
 8002fca: d10e         	bne	0x8002fea <hard_fault+0x116> @ imm = #0x1c
 8002fcc: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800308c <hard_fault+0x1b8>
 8002fce: 6819         	ldr	r1, [r3]
 8002fd0: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80030a0 <hard_fault+0x1cc>
 8002fd2: 9302         	str	r3, [sp, #0x8]
 8002fd4: 2300         	movs	r3, #0x0
 8002fd6: 9301         	str	r3, [sp, #0x4]
 8002fd8: 2300         	movs	r3, #0x0
 8002fda: 9300         	str	r3, [sp]
 8002fdc: 2300         	movs	r3, #0x0
 8002fde: 2201         	movs	r2, #0x1
 8002fe0: 2000         	movs	r0, #0x0
 8002fe2: f00f fd58    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfab0
 8002fe6: 2300         	movs	r3, #0x0
 8002fe8: 627b         	str	r3, [r7, #0x24]
; 		if (z_arm_is_synchronous_svc(esf)) {
 8002fea: 6878         	ldr	r0, [r7, #0x4]
 8002fec: f7ff ff32    	bl	0x8002e54 <z_arm_is_synchronous_svc> @ imm = #-0x19c
 8002ff0: 4603         	mov	r3, r0
 8002ff2: 2b00         	cmp	r3, #0x0
 8002ff4: d022         	beq	0x800303c <hard_fault+0x168> @ imm = #0x44
; 			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
 8002ff6: 2303         	movs	r3, #0x3
 8002ff8: 2b00         	cmp	r3, #0x0
 8002ffa: d01b         	beq	0x8003034 <hard_fault+0x160> @ imm = #0x36
 8002ffc: 2301         	movs	r3, #0x1
 8002ffe: f887 3023    	strb.w	r3, [r7, #0x23]
 8003002: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8003006: f083 0301    	eor	r3, r3, #0x1
 800300a: b2db         	uxtb	r3, r3
 800300c: 2b00         	cmp	r3, #0x0
 800300e: d111         	bne	0x8003034 <hard_fault+0x160> @ imm = #0x22
 8003010: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800308c <hard_fault+0x1b8>
 8003012: 6819         	ldr	r1, [r3]
 8003014: 687b         	ldr	r3, [r7, #0x4]
 8003016: 681b         	ldr	r3, [r3]
 8003018: 9303         	str	r3, [sp, #0xc]
 800301a: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80030a4 <hard_fault+0x1d0>
 800301c: 9302         	str	r3, [sp, #0x8]
 800301e: 2300         	movs	r3, #0x0
 8003020: 9301         	str	r3, [sp, #0x4]
 8003022: 2300         	movs	r3, #0x0
 8003024: 9300         	str	r3, [sp]
 8003026: 2300         	movs	r3, #0x0
 8003028: 2201         	movs	r2, #0x1
 800302a: 2000         	movs	r0, #0x0
 800302c: f00f fd33    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xfa66
 8003030: 2300         	movs	r3, #0x0
 8003032: 61fb         	str	r3, [r7, #0x1c]
; 			reason = esf->basic.r0;
 8003034: 687b         	ldr	r3, [r7, #0x4]
 8003036: 681b         	ldr	r3, [r3]
 8003038: 62fb         	str	r3, [r7, #0x2c]
 800303a: e022         	b	0x8003082 <hard_fault+0x1ae> @ imm = #0x44
; 		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
 800303c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8003094 <hard_fault+0x1c0>
 800303e: 6a9b         	ldr	r3, [r3, #0x28]
 8003040: b2db         	uxtb	r3, r3
 8003042: 2b00         	cmp	r3, #0x0
 8003044: d006         	beq	0x8003054 <hard_fault+0x180> @ imm = #0xc
; 			reason = mem_manage_fault(esf, 1, recoverable);
 8003046: 683a         	ldr	r2, [r7]
 8003048: 2101         	movs	r1, #0x1
 800304a: 6878         	ldr	r0, [r7, #0x4]
 800304c: f7ff fb2c    	bl	0x80026a8 <mem_manage_fault> @ imm = #-0x9a8
 8003050: 62f8         	str	r0, [r7, #0x2c]
 8003052: e016         	b	0x8003082 <hard_fault+0x1ae> @ imm = #0x2c
; 		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
 8003054: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8003094 <hard_fault+0x1c0>
 8003056: 6a9b         	ldr	r3, [r3, #0x28]
 8003058: f403 437f    	and	r3, r3, #0xff00
 800305c: 2b00         	cmp	r3, #0x0
 800305e: d007         	beq	0x8003070 <hard_fault+0x19c> @ imm = #0xe
; 			reason = bus_fault(esf, 1, recoverable);
 8003060: 683a         	ldr	r2, [r7]
 8003062: 2101         	movs	r1, #0x1
 8003064: 6878         	ldr	r0, [r7, #0x4]
 8003066: f7ff fc63    	bl	0x8002930 <bus_fault>   @ imm = #-0x73a
 800306a: 4603         	mov	r3, r0
 800306c: 62fb         	str	r3, [r7, #0x2c]
 800306e: e008         	b	0x8003082 <hard_fault+0x1ae> @ imm = #0x10
; 		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
 8003070: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8003094 <hard_fault+0x1c0>
 8003072: 6a9b         	ldr	r3, [r3, #0x28]
 8003074: f5b3 3f80    	cmp.w	r3, #0x10000
 8003078: d303         	blo	0x8003082 <hard_fault+0x1ae> @ imm = #0x6
; 			reason = usage_fault(esf);
 800307a: 6878         	ldr	r0, [r7, #0x4]
 800307c: f7ff fda8    	bl	0x8002bd0 <usage_fault> @ imm = #-0x4b0
 8003080: 62f8         	str	r0, [r7, #0x2c]
; 	return reason;
 8003082: 6afb         	ldr	r3, [r7, #0x2c]
; }
 8003084: 4618         	mov	r0, r3
 8003086: 3738         	adds	r7, #0x38
 8003088: 46bd         	mov	sp, r7
 800308a: bd80         	pop	{r7, pc}

0800308c <$d>:
 800308c: 2c 04 00 20  	.word	0x2000042c
 8003090: 2c b9 01 08  	.word	0x0801b92c
 8003094: 00 ed 00 e0  	.word	0xe000ed00
 8003098: 44 b9 01 08  	.word	0x0801b944
 800309c: 68 b9 01 08  	.word	0x0801b968
 80030a0: 78 b9 01 08  	.word	0x0801b978
 80030a4: 98 b9 01 08  	.word	0x0801b998

080030a8 <reserved_exception>:
; {
 80030a8: b580         	push	{r7, lr}
 80030aa: b08a         	sub	sp, #0x28
 80030ac: af06         	add	r7, sp, #0x18
 80030ae: 6078         	str	r0, [r7, #0x4]
 80030b0: 6039         	str	r1, [r7]
; 	PR_FAULT_INFO("***** %s %d) *****",
 80030b2: 2303         	movs	r3, #0x3
 80030b4: 2b00         	cmp	r3, #0x0
 80030b6: d021         	beq	0x80030fc <reserved_exception+0x54> @ imm = #0x42
 80030b8: 2301         	movs	r3, #0x1
 80030ba: 73fb         	strb	r3, [r7, #0xf]
 80030bc: 7bfb         	ldrb	r3, [r7, #0xf]
 80030be: f083 0301    	eor	r3, r3, #0x1
 80030c2: b2db         	uxtb	r3, r3
 80030c4: 2b00         	cmp	r3, #0x0
 80030c6: d119         	bne	0x80030fc <reserved_exception+0x54> @ imm = #0x32
 80030c8: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8003104 <reserved_exception+0x5c>
 80030ca: 6819         	ldr	r1, [r3]
 80030cc: 683b         	ldr	r3, [r7]
 80030ce: 2b0f         	cmp	r3, #0xf
 80030d0: dc01         	bgt	0x80030d6 <reserved_exception+0x2e> @ imm = #0x2
 80030d2: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8003108 <reserved_exception+0x60>
 80030d4: e000         	b	0x80030d8 <reserved_exception+0x30> @ imm = #0x0
 80030d6: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800310c <reserved_exception+0x64>
 80030d8: 683a         	ldr	r2, [r7]
 80030da: 3a10         	subs	r2, #0x10
 80030dc: 9204         	str	r2, [sp, #0x10]
 80030de: 9303         	str	r3, [sp, #0xc]
 80030e0: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8003110 <reserved_exception+0x68>
 80030e2: 9302         	str	r3, [sp, #0x8]
 80030e4: 2300         	movs	r3, #0x0
 80030e6: 9301         	str	r3, [sp, #0x4]
 80030e8: 2300         	movs	r3, #0x0
 80030ea: 9300         	str	r3, [sp]
 80030ec: 2300         	movs	r3, #0x0
 80030ee: 2201         	movs	r2, #0x1
 80030f0: 2000         	movs	r0, #0x0
 80030f2: f00f fcd0    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xf9a0
 80030f6: 2300         	movs	r3, #0x0
 80030f8: 60bb         	str	r3, [r7, #0x8]
; }
 80030fa: bf00         	nop
 80030fc: bf00         	nop
 80030fe: 3710         	adds	r7, #0x10
 8003100: 46bd         	mov	sp, r7
 8003102: bd80         	pop	{r7, pc}

08003104 <$d>:
 8003104: 2c 04 00 20  	.word	0x2000042c
 8003108: b4 b9 01 08  	.word	0x0801b9b4
 800310c: cc b9 01 08  	.word	0x0801b9cc
 8003110: e8 b9 01 08  	.word	0x0801b9e8

08003114 <fault_handle>:
; {
 8003114: b580         	push	{r7, lr}
 8003116: b086         	sub	sp, #0x18
 8003118: af00         	add	r7, sp, #0x0
 800311a: 60f8         	str	r0, [r7, #0xc]
 800311c: 60b9         	str	r1, [r7, #0x8]
 800311e: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8003120: 2300         	movs	r3, #0x0
 8003122: 617b         	str	r3, [r7, #0x14]
; 	*recoverable = false;
 8003124: 687b         	ldr	r3, [r7, #0x4]
 8003126: 2200         	movs	r2, #0x0
 8003128: 701a         	strb	r2, [r3]
; 	switch (fault) {
 800312a: 68bb         	ldr	r3, [r7, #0x8]
 800312c: 3b03         	subs	r3, #0x3
 800312e: 2b09         	cmp	r3, #0x9
 8003130: d835         	bhi	0x800319e <fault_handle+0x8a> @ imm = #0x6a
 8003132: a201         	adr	r2, #4 <fault_handle+0x23>
 8003134: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08003138 <$d>:
 8003138: 61 31 00 08  	.word	0x08003161
 800313c: 6d 31 00 08  	.word	0x0800316d
 8003140: 7b 31 00 08  	.word	0x0800317b
 8003144: 8b 31 00 08  	.word	0x0800318b
 8003148: 9f 31 00 08  	.word	0x0800319f
 800314c: 9f 31 00 08  	.word	0x0800319f
 8003150: 9f 31 00 08  	.word	0x0800319f
 8003154: 9f 31 00 08  	.word	0x0800319f
 8003158: 9f 31 00 08  	.word	0x0800319f
 800315c: 95 31 00 08  	.word	0x08003195

08003160 <$t>:
; 		reason = hard_fault(esf, recoverable);
 8003160: 6879         	ldr	r1, [r7, #0x4]
 8003162: 68f8         	ldr	r0, [r7, #0xc]
 8003164: f7ff feb6    	bl	0x8002ed4 <hard_fault>  @ imm = #-0x294
 8003168: 6178         	str	r0, [r7, #0x14]
; 		break;
 800316a: e01d         	b	0x80031a8 <fault_handle+0x94> @ imm = #0x3a
; 		reason = mem_manage_fault(esf, 0, recoverable);
 800316c: 687a         	ldr	r2, [r7, #0x4]
 800316e: 2100         	movs	r1, #0x0
 8003170: 68f8         	ldr	r0, [r7, #0xc]
 8003172: f7ff fa99    	bl	0x80026a8 <mem_manage_fault> @ imm = #-0xace
 8003176: 6178         	str	r0, [r7, #0x14]
; 		break;
 8003178: e016         	b	0x80031a8 <fault_handle+0x94> @ imm = #0x2c
; 		reason = bus_fault(esf, 0, recoverable);
 800317a: 687a         	ldr	r2, [r7, #0x4]
 800317c: 2100         	movs	r1, #0x0
 800317e: 68f8         	ldr	r0, [r7, #0xc]
 8003180: f7ff fbd6    	bl	0x8002930 <bus_fault>   @ imm = #-0x854
 8003184: 4603         	mov	r3, r0
 8003186: 617b         	str	r3, [r7, #0x14]
; 		break;
 8003188: e00e         	b	0x80031a8 <fault_handle+0x94> @ imm = #0x1c
; 		reason = usage_fault(esf);
 800318a: 68f8         	ldr	r0, [r7, #0xc]
 800318c: f7ff fd20    	bl	0x8002bd0 <usage_fault> @ imm = #-0x5c0
 8003190: 6178         	str	r0, [r7, #0x14]
; 		break;
 8003192: e009         	b	0x80031a8 <fault_handle+0x94> @ imm = #0x12
; 		debug_monitor(esf, recoverable);
 8003194: 6879         	ldr	r1, [r7, #0x4]
 8003196: 68f8         	ldr	r0, [r7, #0xc]
 8003198: f7ff fe30    	bl	0x8002dfc <debug_monitor> @ imm = #-0x3a0
; 		break;
 800319c: e004         	b	0x80031a8 <fault_handle+0x94> @ imm = #0x8
; 		reserved_exception(esf, fault);
 800319e: 68b9         	ldr	r1, [r7, #0x8]
 80031a0: 68f8         	ldr	r0, [r7, #0xc]
 80031a2: f7ff ff81    	bl	0x80030a8 <reserved_exception> @ imm = #-0xfe
; 		break;
 80031a6: bf00         	nop
; 	if ((*recoverable) == false) {
 80031a8: 687b         	ldr	r3, [r7, #0x4]
 80031aa: 781b         	ldrb	r3, [r3]
 80031ac: f083 0301    	eor	r3, r3, #0x1
 80031b0: b2db         	uxtb	r3, r3
 80031b2: 2b00         	cmp	r3, #0x0
 80031b4: d003         	beq	0x80031be <fault_handle+0xaa> @ imm = #0x6
; 		fault_show(esf, fault);
 80031b6: 68b9         	ldr	r1, [r7, #0x8]
 80031b8: 68f8         	ldr	r0, [r7, #0xc]
 80031ba: f00f fc8a    	bl	0x8012ad2 <fault_show>  @ imm = #0xf914
; 	return reason;
 80031be: 697b         	ldr	r3, [r7, #0x14]
; }
 80031c0: 4618         	mov	r0, r3
 80031c2: 3718         	adds	r7, #0x18
 80031c4: 46bd         	mov	sp, r7
 80031c6: bd80         	pop	{r7, pc}

080031c8 <get_esf>:
; {
 80031c8: b580         	push	{r7, lr}
 80031ca: b08c         	sub	sp, #0x30
 80031cc: af04         	add	r7, sp, #0x10
 80031ce: 60f8         	str	r0, [r7, #0xc]
 80031d0: 60b9         	str	r1, [r7, #0x8]
 80031d2: 607a         	str	r2, [r7, #0x4]
 80031d4: 603b         	str	r3, [r7]
; 	bool alternative_state_exc = false;
 80031d6: 2300         	movs	r3, #0x0
 80031d8: 76fb         	strb	r3, [r7, #0x1b]
; 	struct arch_esf *ptr_esf = NULL;
 80031da: 2300         	movs	r3, #0x0
 80031dc: 61fb         	str	r3, [r7, #0x1c]
; 	*nested_exc = false;
 80031de: 683b         	ldr	r3, [r7]
 80031e0: 2200         	movs	r2, #0x0
 80031e2: 701a         	strb	r2, [r3]
; 	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
 80031e4: 687b         	ldr	r3, [r7, #0x4]
 80031e6: f003 437f    	and	r3, r3, #0xff000000
 80031ea: f1b3 4f7f    	cmp.w	r3, #0xff000000
 80031ee: d001         	beq	0x80031f4 <get_esf+0x2c> @ imm = #0x2
; 		return NULL;
 80031f0: 2300         	movs	r3, #0x0
 80031f2: e039         	b	0x8003268 <get_esf+0xa0> @ imm = #0x72
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 80031f4: 687b         	ldr	r3, [r7, #0x4]
 80031f6: f003 0308    	and	r3, r3, #0x8
 80031fa: 2b00         	cmp	r3, #0x0
 80031fc: d020         	beq	0x8003240 <get_esf+0x78> @ imm = #0x40
; 		(!(exc_return & EXC_RETURN_SPSEL_PROCESS))) {
 80031fe: 687b         	ldr	r3, [r7, #0x4]
 8003200: f003 0304    	and	r3, r3, #0x4
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 8003204: 2b00         	cmp	r3, #0x0
 8003206: d11b         	bne	0x8003240 <get_esf+0x78> @ imm = #0x36
; 		PR_EXC("SPSEL in thread mode does not indicate PSP");
 8003208: 2303         	movs	r3, #0x3
 800320a: 2b00         	cmp	r3, #0x0
 800320c: d016         	beq	0x800323c <get_esf+0x74> @ imm = #0x2c
 800320e: 2301         	movs	r3, #0x1
 8003210: 76bb         	strb	r3, [r7, #0x1a]
 8003212: 7ebb         	ldrb	r3, [r7, #0x1a]
 8003214: f083 0301    	eor	r3, r3, #0x1
 8003218: b2db         	uxtb	r3, r3
 800321a: 2b00         	cmp	r3, #0x0
 800321c: d10e         	bne	0x800323c <get_esf+0x74> @ imm = #0x1c
 800321e: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8003270 <get_esf+0xa8>
 8003220: 6819         	ldr	r1, [r3]
 8003222: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8003274 <get_esf+0xac>
 8003224: 9302         	str	r3, [sp, #0x8]
 8003226: 2300         	movs	r3, #0x0
 8003228: 9301         	str	r3, [sp, #0x4]
 800322a: 2300         	movs	r3, #0x0
 800322c: 9300         	str	r3, [sp]
 800322e: 2300         	movs	r3, #0x0
 8003230: 2201         	movs	r2, #0x1
 8003232: 2000         	movs	r0, #0x0
 8003234: f00f fc2f    	bl	0x8012a96 <z_log_msg_runtime_create> @ imm = #0xf85e
 8003238: 2300         	movs	r3, #0x0
 800323a: 617b         	str	r3, [r7, #0x14]
; 		return NULL;
 800323c: 2300         	movs	r3, #0x0
 800323e: e013         	b	0x8003268 <get_esf+0xa0> @ imm = #0x26
; 	if (!alternative_state_exc) {
 8003240: 7efb         	ldrb	r3, [r7, #0x1b]
 8003242: f083 0301    	eor	r3, r3, #0x1
 8003246: b2db         	uxtb	r3, r3
 8003248: 2b00         	cmp	r3, #0x0
 800324a: d00c         	beq	0x8003266 <get_esf+0x9e> @ imm = #0x18
; 		if (exc_return & EXC_RETURN_MODE_THREAD) {
 800324c: 687b         	ldr	r3, [r7, #0x4]
 800324e: f003 0308    	and	r3, r3, #0x8
 8003252: 2b00         	cmp	r3, #0x0
 8003254: d002         	beq	0x800325c <get_esf+0x94> @ imm = #0x4
; 			ptr_esf =  (struct arch_esf *)psp;
 8003256: 68bb         	ldr	r3, [r7, #0x8]
 8003258: 61fb         	str	r3, [r7, #0x1c]
 800325a: e004         	b	0x8003266 <get_esf+0x9e> @ imm = #0x8
; 			ptr_esf = (struct arch_esf *)msp;
 800325c: 68fb         	ldr	r3, [r7, #0xc]
 800325e: 61fb         	str	r3, [r7, #0x1c]
; 			*nested_exc = true;
 8003260: 683b         	ldr	r3, [r7]
 8003262: 2201         	movs	r2, #0x1
 8003264: 701a         	strb	r2, [r3]
; 	return ptr_esf;
 8003266: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8003268: 4618         	mov	r0, r3
 800326a: 3720         	adds	r7, #0x20
 800326c: 46bd         	mov	sp, r7
 800326e: bd80         	pop	{r7, pc}

08003270 <$d>:
 8003270: 2c 04 00 20  	.word	0x2000042c
 8003274: fc b9 01 08  	.word	0x0801b9fc

08003278 <z_arm_fault>:
; {
 8003278: b580         	push	{r7, lr}
 800327a: b094         	sub	sp, #0x50
 800327c: af00         	add	r7, sp, #0x0
 800327e: 60f8         	str	r0, [r7, #0xc]
 8003280: 60b9         	str	r1, [r7, #0x8]
 8003282: 607a         	str	r2, [r7, #0x4]
 8003284: 603b         	str	r3, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8003286: 2300         	movs	r3, #0x0
 8003288: 64fb         	str	r3, [r7, #0x4c]
; 	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 800328a: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8003330 <z_arm_fault+0xb8>
 800328c: 685b         	ldr	r3, [r3, #0x4]
 800328e: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8003292: 64bb         	str	r3, [r7, #0x48]
 8003294: 2300         	movs	r3, #0x0
 8003296: 63bb         	str	r3, [r7, #0x38]
 8003298: 6bbb         	ldr	r3, [r7, #0x38]
 800329a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800329c: 6b7b         	ldr	r3, [r7, #0x34]
 800329e: f383 8811    	msr	basepri, r3
; }
 80032a2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80032a4: f3bf 8f6f    	isb	sy
; }
 80032a8: bf00         	nop
; }
 80032aa: bf00         	nop
; 	 esf = get_esf(msp, psp, exc_return, &nested_exc);
 80032ac: f107 0332    	add.w	r3, r7, #0x32
 80032b0: 687a         	ldr	r2, [r7, #0x4]
 80032b2: 68b9         	ldr	r1, [r7, #0x8]
 80032b4: 68f8         	ldr	r0, [r7, #0xc]
 80032b6: f7ff ff87    	bl	0x80031c8 <get_esf>     @ imm = #-0xf2
 80032ba: 6478         	str	r0, [r7, #0x44]
 80032bc: 6c7b         	ldr	r3, [r7, #0x44]
 80032be: 643b         	str	r3, [r7, #0x40]
 80032c0: 687b         	ldr	r3, [r7, #0x4]
 80032c2: 63fb         	str	r3, [r7, #0x3c]
; }
 80032c4: bf00         	nop
; 	reason = fault_handle(esf, fault, &recoverable);
 80032c6: f107 0333    	add.w	r3, r7, #0x33
 80032ca: 461a         	mov	r2, r3
 80032cc: 6cb9         	ldr	r1, [r7, #0x48]
 80032ce: 6c78         	ldr	r0, [r7, #0x44]
 80032d0: f7ff ff20    	bl	0x8003114 <fault_handle> @ imm = #-0x1c0
 80032d4: 64f8         	str	r0, [r7, #0x4c]
; 	if (recoverable) {
 80032d6: f897 3033    	ldrb.w	r3, [r7, #0x33]
 80032da: 2b00         	cmp	r3, #0x0
 80032dc: d123         	bne	0x8003326 <z_arm_fault+0xae> @ imm = #0x46
; 	memcpy(&esf_copy, esf, sizeof(struct arch_esf));
 80032de: f107 0310    	add.w	r3, r7, #0x10
 80032e2: 2220         	movs	r2, #0x20
 80032e4: 6c79         	ldr	r1, [r7, #0x44]
 80032e6: 4618         	mov	r0, r3
 80032e8: f017 fa94    	bl	0x801a814 <memcpy>      @ imm = #0x17528
; 	if (nested_exc) {
 80032ec: f897 3032    	ldrb.w	r3, [r7, #0x32]
 80032f0: 2b00         	cmp	r3, #0x0
 80032f2: d00b         	beq	0x800330c <z_arm_fault+0x94> @ imm = #0x16
; 		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
 80032f4: 6afb         	ldr	r3, [r7, #0x2c]
 80032f6: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 80032fa: 2b00         	cmp	r3, #0x0
 80032fc: d10c         	bne	0x8003318 <z_arm_fault+0xa0> @ imm = #0x18
; 			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
 80032fe: 6afb         	ldr	r3, [r7, #0x2c]
 8003300: ea6f 2353    	mvn.w	r3, r3, lsr #9
 8003304: ea6f 2343    	mvn.w	r3, r3, lsl #9
 8003308: 62fb         	str	r3, [r7, #0x2c]
 800330a: e005         	b	0x8003318 <z_arm_fault+0xa0> @ imm = #0xa
; 		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 800330c: 6afb         	ldr	r3, [r7, #0x2c]
 800330e: f423 73ff    	bic	r3, r3, #0x1fe
 8003312: f023 0301    	bic	r3, r3, #0x1
 8003316: 62fb         	str	r3, [r7, #0x2c]
; 	z_arm_fatal_error(reason, &esf_copy);
 8003318: f107 0310    	add.w	r3, r7, #0x10
 800331c: 4619         	mov	r1, r3
 800331e: 6cf8         	ldr	r0, [r7, #0x4c]
 8003320: f7ff f92e    	bl	0x8002580 <z_arm_fatal_error> @ imm = #-0xda4
 8003324: e000         	b	0x8003328 <z_arm_fault+0xb0> @ imm = #0x0
; 		return;
 8003326: bf00         	nop
; }
 8003328: 3750         	adds	r7, #0x50
 800332a: 46bd         	mov	sp, r7
 800332c: bd80         	pop	{r7, pc}
 800332e: bf00         	nop

08003330 <$d>:
 8003330: 00 ed 00 e0  	.word	0xe000ed00

08003334 <z_arm_fault_init>:
; {
 8003334: b480         	push	{r7}
 8003336: af00         	add	r7, sp, #0x0
; 	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 8003338: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8003358 <z_arm_fault_init+0x24>
 800333a: 695b         	ldr	r3, [r3, #0x14]
 800333c: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8003358 <z_arm_fault_init+0x24>
 800333e: f043 0310    	orr	r3, r3, #0x10
 8003342: 6153         	str	r3, [r2, #0x14]
; 	SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk;
 8003344: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8003358 <z_arm_fault_init+0x24>
 8003346: 695b         	ldr	r3, [r3, #0x14]
 8003348: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8003358 <z_arm_fault_init+0x24>
 800334a: f023 0308    	bic	r3, r3, #0x8
 800334e: 6153         	str	r3, [r2, #0x14]
; }
 8003350: bf00         	nop
 8003352: 46bd         	mov	sp, r7
 8003354: bc80         	pop	{r7}
 8003356: 4770         	bx	lr

08003358 <$d>:
 8003358: 00 ed 00 e0  	.word	0xe000ed00

0800335c <z_arm_usage_fault>:
; 	mrs r0, MSP
 800335c: f3ef 8008    	mrs	r0, msp
; 	mrs r1, PSP
 8003360: f3ef 8109    	mrs	r1, psp
; 	push {r0, lr}
 8003364: b501         	push	{r0, lr}
; 	mov r2, lr /* EXC_RETURN */
 8003366: 4672         	mov	r2, lr
; 	bl z_arm_fault
 8003368: f7ff ff86    	bl	0x8003278 <z_arm_fault> @ imm = #-0xf4
; 	pop {r0, pc}
 800336c: bd01         	pop	{r0, pc}
 800336e: bf00         	nop

08003370 <z_arm_reset>:
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8003370: 2010         	movs	r0, #0x10
;     msr BASEPRI, r0
 8003372: f380 8811    	msr	basepri, r0
;     ldr r0, =z_interrupt_stacks
 8003376: 480b         	ldr	r0, [pc, #0x2c]         @ 0x80033a4 <z_arm_reset+0x34>
;     ldr r1, =0xaa
 8003378: f04f 01aa    	mov.w	r1, #0xaa
;     ldr r2, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 800337c: f44f 6200    	mov.w	r2, #0x800
;     bl z_early_memset
 8003380: f015 fb35    	bl	0x80189ee <z_early_memset> @ imm = #0x1566a
;     ldr r0, =z_interrupt_stacks
 8003384: 4807         	ldr	r0, [pc, #0x1c]         @ 0x80033a4 <z_arm_reset+0x34>
;     ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 8003386: f44f 6100    	mov.w	r1, #0x800
;     adds r0, r0, r1
 800338a: 1840         	adds	r0, r0, r1
;     msr PSP, r0
 800338c: f380 8809    	msr	psp, r0
;     mrs r0, CONTROL
 8003390: f3ef 8014    	mrs	r0, control
;     movs r1, #2
 8003394: 2102         	movs	r1, #0x2
;     orrs r0, r1 /* CONTROL_SPSEL_Msk */
 8003396: 4308         	orrs	r0, r1
;     msr CONTROL, r0
 8003398: f380 8814    	msr	control, r0
;     isb
 800339c: f3bf 8f6f    	isb	sy
;     bl z_prep_c
 80033a0: f00f fbd9    	bl	0x8012b56 <z_prep_c>    @ imm = #0xf7b2

080033a4 <$d>:
 80033a4: 88 2e 00 20  	.word	0x20002e88

080033a8 <z_impl_k_thread_abort>:
; {
 80033a8: b580         	push	{r7, lr}
 80033aa: b084         	sub	sp, #0x10
 80033ac: af00         	add	r7, sp, #0x0
 80033ae: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80033b0: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80033fc <z_impl_k_thread_abort+0x54>
 80033b2: 689b         	ldr	r3, [r3, #0x8]
 80033b4: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 80033b6: 68fb         	ldr	r3, [r7, #0xc]
; 	if (arch_current_thread() == thread) {
 80033b8: 687a         	ldr	r2, [r7, #0x4]
 80033ba: 429a         	cmp	r2, r3
 80033bc: d116         	bne	0x80033ec <z_impl_k_thread_abort+0x44> @ imm = #0x2c
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80033be: f3ef 8305    	mrs	r3, ipsr
 80033c2: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 80033c4: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 80033c6: 2b00         	cmp	r3, #0x0
 80033c8: bf14         	ite	ne
 80033ca: 2301         	movne	r3, #0x1
 80033cc: 2300         	moveq	r3, #0x0
 80033ce: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 80033d0: 2b00         	cmp	r3, #0x0
 80033d2: d00b         	beq	0x80033ec <z_impl_k_thread_abort+0x44> @ imm = #0x16
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 80033d4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8003400 <z_impl_k_thread_abort+0x58>
 80033d6: 685b         	ldr	r3, [r3, #0x4]
 80033d8: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8003400 <z_impl_k_thread_abort+0x58>
 80033da: f043 5380    	orr	r3, r3, #0x10000000
 80033de: 6053         	str	r3, [r2, #0x4]
; 			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
 80033e0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8003400 <z_impl_k_thread_abort+0x58>
 80033e2: 6a5b         	ldr	r3, [r3, #0x24]
 80033e4: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8003400 <z_impl_k_thread_abort+0x58>
 80033e6: f423 4300    	bic	r3, r3, #0x8000
 80033ea: 6253         	str	r3, [r2, #0x24]
; 	z_thread_abort(thread);
 80033ec: 6878         	ldr	r0, [r7, #0x4]
 80033ee: f00b fed7    	bl	0x800f1a0 <z_thread_abort> @ imm = #0xbdae
; }
 80033f2: bf00         	nop
 80033f4: 3710         	adds	r7, #0x10
 80033f6: 46bd         	mov	sp, r7
 80033f8: bd80         	pop	{r7, pc}
 80033fa: bf00         	nop

080033fc <$d>:
 80033fc: 30 07 00 20  	.word	0x20000730
 8003400: 00 ed 00 e0  	.word	0xe000ed00

08003404 <arch_swap>:
; {
 8003404: b480         	push	{r7}
 8003406: b089         	sub	sp, #0x24
 8003408: af00         	add	r7, sp, #0x0
 800340a: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800340c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8003464 <arch_swap+0x60>
 800340e: 689b         	ldr	r3, [r3, #0x8]
 8003410: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8003412: 68fb         	ldr	r3, [r7, #0xc]
; 	arch_current_thread()->arch.basepri = key;
 8003414: 687a         	ldr	r2, [r7, #0x4]
 8003416: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800341a: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8003464 <arch_swap+0x60>
 800341c: 689b         	ldr	r3, [r3, #0x8]
 800341e: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 8003420: 693b         	ldr	r3, [r7, #0x10]
; 	arch_current_thread()->arch.swap_return_value = -EAGAIN;
 8003422: f06f 020a    	mvn	r2, #0xa
 8003426: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; 	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 800342a: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8003468 <arch_swap+0x64>
 800342c: 685b         	ldr	r3, [r3, #0x4]
 800342e: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8003468 <arch_swap+0x64>
 8003430: f043 5380    	orr	r3, r3, #0x10000000
 8003434: 6053         	str	r3, [r2, #0x4]
 8003436: 2300         	movs	r3, #0x0
 8003438: 61bb         	str	r3, [r7, #0x18]
 800343a: 69bb         	ldr	r3, [r7, #0x18]
 800343c: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800343e: 697b         	ldr	r3, [r7, #0x14]
 8003440: f383 8811    	msr	basepri, r3
; }
 8003444: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8003446: f3bf 8f6f    	isb	sy
; }
 800344a: bf00         	nop
; }
 800344c: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800344e: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8003464 <arch_swap+0x60>
 8003450: 689b         	ldr	r3, [r3, #0x8]
 8003452: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 8003454: 69fb         	ldr	r3, [r7, #0x1c]
; 	return arch_current_thread()->arch.swap_return_value;
 8003456: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
; }
 800345a: 4618         	mov	r0, r3
 800345c: 3724         	adds	r7, #0x24
 800345e: 46bd         	mov	sp, r7
 8003460: bc80         	pop	{r7}
 8003462: 4770         	bx	lr

08003464 <$d>:
 8003464: 30 07 00 20  	.word	0x20000730
 8003468: 00 ed 00 e0  	.word	0xe000ed00

0800346c <z_arm_pendsv>:
;     push {r0, lr}
 800346c: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_out
 800346e: f016 fb8a    	bl	0x8019b86 <z_thread_mark_switched_out> @ imm = #0x16714
;     pop {r0, lr}
 8003472: e8bd 4001    	pop.w	{r0, lr}
;     ldr r1, =_kernel
 8003476: 4916         	ldr	r1, [pc, #0x58]         @ 0x80034d0 <z_arm_pendsv+0x64>
;     ldr r2, [r1, #_kernel_offset_to_current]
 8003478: 688a         	ldr	r2, [r1, #0x8]
;     ldr r0, =_thread_offset_to_callee_saved
 800347a: f04f 0040    	mov.w	r0, #0x40
;     add r0, r2
 800347e: 4410         	add	r0, r2
;     mrs ip, PSP
 8003480: f3ef 8c09    	mrs	r12, psp
;     stmia r0, {r4-r11, ip}
 8003484: e880 1ff0    	stm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8003488: 2010         	movs	r0, #0x10
;     msr BASEPRI_MAX, r0
 800348a: f380 8812    	msr	basepri_max, r0
;     isb /* Make the effect of disabling interrupts be realized immediately */
 800348e: f3bf 8f6f    	isb	sy
;     ldr r7, =_SCS_ICSR
 8003492: 4f10         	ldr	r7, [pc, #0x40]         @ 0x80034d4 <z_arm_pendsv+0x68>
;     ldr r6, =_SCS_ICSR_UNPENDSV
 8003494: f04f 6600    	mov.w	r6, #0x8000000
;     ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
 8003498: 69ca         	ldr	r2, [r1, #0x1c]
;     str r2, [r1, #_kernel_offset_to_current]
 800349a: 608a         	str	r2, [r1, #0x8]
;     str r6, [r7, #0]
 800349c: 603e         	str	r6, [r7]
;     ldr r4, =_thread_offset_to_tls
 800349e: f04f 04c4    	mov.w	r4, #0xc4
;     adds r4, r2, r4
 80034a2: 1914         	adds	r4, r2, r4
;     ldr r0, [r4]
 80034a4: 6820         	ldr	r0, [r4]
;     ldr r4, =z_arm_tls_ptr
 80034a6: 4c0c         	ldr	r4, [pc, #0x30]         @ 0x80034d8 <z_arm_pendsv+0x6c>
;     str r0, [r4]
 80034a8: 6020         	str	r0, [r4]
;     ldr r0, [r2, #_thread_offset_to_basepri]
 80034aa: f8d2 00c8    	ldr.w	r0, [r2, #0xc8]
;     movs r3, #0
 80034ae: 2300         	movs	r3, #0x0
;     str r3, [r2, #_thread_offset_to_basepri]
 80034b0: f8c2 30c8    	str.w	r3, [r2, #0xc8]
;     msr BASEPRI, r0
 80034b4: f380 8811    	msr	basepri, r0
;     add r0, r2, #_thread_offset_to_callee_saved
 80034b8: f102 0040    	add.w	r0, r2, #0x40
;     ldmia r0, {r4-r11, ip}
 80034bc: e890 1ff0    	ldm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     msr PSP, ip
 80034c0: f38c 8809    	msr	psp, r12
;     push {r0, lr}
 80034c4: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_in
 80034c6: f00a fa83    	bl	0x800d9d0 <z_thread_mark_switched_in> @ imm = #0xa506
;     pop {r0, lr}
 80034ca: e8bd 4001    	pop.w	{r0, lr}
;     bx lr
 80034ce: 4770         	bx	lr

080034d0 <$d>:
 80034d0: 30 07 00 20  	.word	0x20000730
 80034d4: 04 ed 00 e0  	.word	0xe000ed04
 80034d8: 50 0b 00 20  	.word	0x20000b50

080034dc <z_arm_svc>:
;     tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
 80034dc: f01e 0f04    	tst.w	lr, #0x4
;     ite eq  /* if zero (equal), came from handler mode */
 80034e0: bf0c         	ite	eq
;         mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 80034e2: f3ef 8008    	mrseq	r0, msp
;         mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 80034e6: f3ef 8009    	mrsne	r0, psp
;     ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 80034ea: 6981         	ldr	r1, [r0, #0x18]
;     ldrb r1, [r1, #-2]
 80034ec: f811 1c02    	ldrb	r1, [r1, #-2]
;     cmp r1, #2
 80034f0: 2902         	cmp	r1, #0x2
;     beq _oops
 80034f2: d0ff         	beq	0x80034f4 <_oops>       @ imm = #-0x2

080034f4 <_oops>:
;     push {r0, lr}
 80034f4: b501         	push	{r0, lr}
;     mov r2, lr /* EXC_RETURN */
 80034f6: 4672         	mov	r2, lr
;     bl z_do_kernel_oops
 80034f8: f00f fa99    	bl	0x8012a2e <z_do_kernel_oops> @ imm = #0xf532
;     pop {r0, pc}
 80034fc: bd01         	pop	{r0, pc}
 80034fe: bf00         	nop

08003500 <__NVIC_EnableIRQ>:
; {
 8003500: b480         	push	{r7}
 8003502: b083         	sub	sp, #0xc
 8003504: af00         	add	r7, sp, #0x0
 8003506: 4603         	mov	r3, r0
 8003508: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 800350a: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800350e: 2b00         	cmp	r3, #0x0
 8003510: db0b         	blt	0x800352a <__NVIC_EnableIRQ+0x2a> @ imm = #0x16
;     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8003512: 79fb         	ldrb	r3, [r7, #0x7]
 8003514: f003 021f    	and	r2, r3, #0x1f
 8003518: 4906         	ldr	r1, [pc, #0x18]         @ 0x8003534 <__NVIC_EnableIRQ+0x34>
 800351a: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800351e: 095b         	lsrs	r3, r3, #0x5
 8003520: 2001         	movs	r0, #0x1
 8003522: fa00 f202    	lsl.w	r2, r0, r2
 8003526: f841 2023    	str.w	r2, [r1, r3, lsl #2]
; }
 800352a: bf00         	nop
 800352c: 370c         	adds	r7, #0xc
 800352e: 46bd         	mov	sp, r7
 8003530: bc80         	pop	{r7}
 8003532: 4770         	bx	lr

08003534 <$d>:
 8003534: 00 e1 00 e0  	.word	0xe000e100

08003538 <__NVIC_SetPriority>:
; {
 8003538: b480         	push	{r7}
 800353a: b083         	sub	sp, #0xc
 800353c: af00         	add	r7, sp, #0x0
 800353e: 4603         	mov	r3, r0
 8003540: 6039         	str	r1, [r7]
 8003542: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8003544: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8003548: 2b00         	cmp	r3, #0x0
 800354a: db0a         	blt	0x8003562 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800354c: 683b         	ldr	r3, [r7]
 800354e: b2da         	uxtb	r2, r3
 8003550: 490c         	ldr	r1, [pc, #0x30]         @ 0x8003584 <__NVIC_SetPriority+0x4c>
 8003552: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8003556: 0112         	lsls	r2, r2, #0x4
 8003558: b2d2         	uxtb	r2, r2
 800355a: 440b         	add	r3, r1
 800355c: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8003560: e00a         	b	0x8003578 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003562: 683b         	ldr	r3, [r7]
 8003564: b2da         	uxtb	r2, r3
 8003566: 4908         	ldr	r1, [pc, #0x20]         @ 0x8003588 <__NVIC_SetPriority+0x50>
 8003568: 79fb         	ldrb	r3, [r7, #0x7]
 800356a: f003 030f    	and	r3, r3, #0xf
 800356e: 3b04         	subs	r3, #0x4
 8003570: 0112         	lsls	r2, r2, #0x4
 8003572: b2d2         	uxtb	r2, r2
 8003574: 440b         	add	r3, r1
 8003576: 761a         	strb	r2, [r3, #0x18]
; }
 8003578: bf00         	nop
 800357a: 370c         	adds	r7, #0xc
 800357c: 46bd         	mov	sp, r7
 800357e: bc80         	pop	{r7}
 8003580: 4770         	bx	lr
 8003582: bf00         	nop

08003584 <$d>:
 8003584: 00 e1 00 e0  	.word	0xe000e100
 8003588: 00 ed 00 e0  	.word	0xe000ed00

0800358c <relocate_vector_table>:
; {
 800358c: b480         	push	{r7}
 800358e: af00         	add	r7, sp, #0x0
; 	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 8003590: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80035b8 <relocate_vector_table+0x2c>
 8003592: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80035bc <relocate_vector_table+0x30>
 8003594: f023 037f    	bic	r3, r3, #0x7f
 8003598: 6093         	str	r3, [r2, #0x8]
;   __ASM volatile ("dsb 0xF":::"memory");
 800359a: f3bf 8f4f    	dsb	sy
; }
 800359e: bf00         	nop
; }
 80035a0: bf00         	nop
; }
 80035a2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80035a4: f3bf 8f6f    	isb	sy
; }
 80035a8: bf00         	nop
; }
 80035aa: bf00         	nop
; }
 80035ac: bf00         	nop
; }
 80035ae: bf00         	nop
 80035b0: 46bd         	mov	sp, r7
 80035b2: bc80         	pop	{r7}
 80035b4: 4770         	bx	lr
 80035b6: bf00         	nop

080035b8 <$d>:
 80035b8: 00 00 00 08  	.word	0x08000000
 80035bc: 00 ed 00 e0  	.word	0xe000ed00

080035c0 <z_arm_floating_point_init>:
; {
 80035c0: b480         	push	{r7}
 80035c2: b083         	sub	sp, #0xc
 80035c4: af00         	add	r7, sp, #0x0
; 	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
 80035c6: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80035fc <z_arm_floating_point_init+0x3c>
 80035c8: f8d3 3088    	ldr.w	r3, [r3, #0x88]
 80035cc: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80035fc <z_arm_floating_point_init+0x3c>
 80035ce: f423 0370    	bic	r3, r3, #0xf00000
 80035d2: f8c2 3088    	str.w	r3, [r2, #0x88]
;   __ASM volatile ("MRS %0, control" : "=r" (result) );
 80035d6: f3ef 8314    	mrs	r3, control
 80035da: 603b         	str	r3, [r7]
;   return(result);
 80035dc: 683b         	ldr	r3, [r7]
; 	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
 80035de: f023 0304    	bic	r3, r3, #0x4
 80035e2: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 80035e4: 687b         	ldr	r3, [r7, #0x4]
 80035e6: f383 8814    	msr	control, r3
;   __ASM volatile ("isb 0xF":::"memory");
 80035ea: f3bf 8f6f    	isb	sy
; }
 80035ee: bf00         	nop
; }
 80035f0: bf00         	nop
; }
 80035f2: bf00         	nop
 80035f4: 370c         	adds	r7, #0xc
 80035f6: 46bd         	mov	sp, r7
 80035f8: bc80         	pop	{r7}
 80035fa: 4770         	bx	lr

080035fc <$d>:
 80035fc: 00 ed 00 e0  	.word	0xe000ed00

08003600 <arch_new_thread>:
; {
 8003600: b480         	push	{r7}
 8003602: b087         	sub	sp, #0x1c
 8003604: af00         	add	r7, sp, #0x0
 8003606: 60f8         	str	r0, [r7, #0xc]
 8003608: 60b9         	str	r1, [r7, #0x8]
 800360a: 607a         	str	r2, [r7, #0x4]
 800360c: 603b         	str	r3, [r7]
; 	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
 800360e: 687b         	ldr	r3, [r7, #0x4]
 8003610: 3b20         	subs	r3, #0x20
 8003612: 617b         	str	r3, [r7, #0x14]
; 	iframe->pc = (uint32_t)z_thread_entry;
 8003614: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8003660 <arch_new_thread+0x60>
 8003616: 697b         	ldr	r3, [r7, #0x14]
 8003618: 619a         	str	r2, [r3, #0x18]
; 	iframe->pc &= 0xfffffffe;
 800361a: 697b         	ldr	r3, [r7, #0x14]
 800361c: 699b         	ldr	r3, [r3, #0x18]
 800361e: f023 0201    	bic	r2, r3, #0x1
 8003622: 697b         	ldr	r3, [r7, #0x14]
 8003624: 619a         	str	r2, [r3, #0x18]
; 	iframe->a1 = (uint32_t)entry;
 8003626: 683a         	ldr	r2, [r7]
 8003628: 697b         	ldr	r3, [r7, #0x14]
 800362a: 601a         	str	r2, [r3]
; 	iframe->a2 = (uint32_t)p1;
 800362c: 6a3a         	ldr	r2, [r7, #0x20]
 800362e: 697b         	ldr	r3, [r7, #0x14]
 8003630: 605a         	str	r2, [r3, #0x4]
; 	iframe->a3 = (uint32_t)p2;
 8003632: 6a7a         	ldr	r2, [r7, #0x24]
 8003634: 697b         	ldr	r3, [r7, #0x14]
 8003636: 609a         	str	r2, [r3, #0x8]
; 	iframe->a4 = (uint32_t)p3;
 8003638: 6aba         	ldr	r2, [r7, #0x28]
 800363a: 697b         	ldr	r3, [r7, #0x14]
 800363c: 60da         	str	r2, [r3, #0xc]
; 	iframe->xpsr =
 800363e: 697b         	ldr	r3, [r7, #0x14]
 8003640: f04f 7280    	mov.w	r2, #0x1000000
 8003644: 61da         	str	r2, [r3, #0x1c]
; 	thread->callee_saved.psp = (uint32_t)iframe;
 8003646: 697a         	ldr	r2, [r7, #0x14]
 8003648: 68fb         	ldr	r3, [r7, #0xc]
 800364a: 661a         	str	r2, [r3, #0x60]
; 	thread->arch.basepri = 0;
 800364c: 68fb         	ldr	r3, [r7, #0xc]
 800364e: 2200         	movs	r2, #0x0
 8003650: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; }
 8003654: bf00         	nop
 8003656: 371c         	adds	r7, #0x1c
 8003658: 46bd         	mov	sp, r7
 800365a: bc80         	pop	{r7}
 800365c: 4770         	bx	lr
 800365e: bf00         	nop

08003660 <$d>:
 8003660: 39 17 00 08  	.word	0x08001739

08003664 <arch_switch_to_main_thread>:
; {
 8003664: b5f0         	push	{r4, r5, r6, r7, lr}
 8003666: b087         	sub	sp, #0x1c
 8003668: af00         	add	r7, sp, #0x0
 800366a: 60f8         	str	r0, [r7, #0xc]
 800366c: 60b9         	str	r1, [r7, #0x8]
 800366e: 607a         	str	r2, [r7, #0x4]
; 	z_arm_prepare_switch_to_main();
 8003670: f00f fa7f    	bl	0x8012b72 <z_arm_prepare_switch_to_main> @ imm = #0xf4fe
 8003674: 68fb         	ldr	r3, [r7, #0xc]
 8003676: 617b         	str	r3, [r7, #0x14]
; 	_current_cpu->current = thread;
 8003678: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x80036b4 <arch_switch_to_main_thread+0x50>
 800367a: 697b         	ldr	r3, [r7, #0x14]
 800367c: 6093         	str	r3, [r2, #0x8]
; }
 800367e: bf00         	nop
; 	z_arm_tls_ptr = main_thread->tls;
 8003680: 68fb         	ldr	r3, [r7, #0xc]
 8003682: f8d3 30c4    	ldr.w	r3, [r3, #0xc4]
 8003686: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80036b8 <arch_switch_to_main_thread+0x54>
 8003688: 6013         	str	r3, [r2]
; 	z_thread_mark_switched_in();
 800368a: f00a f9a1    	bl	0x800d9d0 <z_thread_mark_switched_in> @ imm = #0xa342
; 	__asm__ volatile (
 800368e: 687d         	ldr	r5, [r7, #0x4]
 8003690: 68be         	ldr	r6, [r7, #0x8]
 8003692: 462c         	mov	r4, r5
 8003694: f386 8809    	msr	psp, r6
 8003698: f04f 0000    	mov.w	r0, #0x0
 800369c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80036bc <arch_switch_to_main_thread+0x58>
 800369e: 4798         	blx	r3
 80036a0: 4620         	mov	r0, r4
 80036a2: f04f 0100    	mov.w	r1, #0x0
 80036a6: f04f 0200    	mov.w	r2, #0x0
 80036aa: f04f 0300    	mov.w	r3, #0x0
 80036ae: 4c04         	ldr	r4, [pc, #0x10]         @ 0x80036c0 <arch_switch_to_main_thread+0x5c>
 80036b0: 4720         	bx	r4
 80036b2: bf00         	nop

080036b4 <$d>:
 80036b4: 30 07 00 20  	.word	0x20000730
 80036b8: 50 0b 00 20  	.word	0x20000b50

080036bc <$d>:
 80036bc: 7f 2b 01 08  	.word	0x08012b7f
 80036c0: 39 17 00 08  	.word	0x08001739

080036c4 <z_arm_cpu_idle_init>:
; {
 80036c4: b480         	push	{r7}
 80036c6: af00         	add	r7, sp, #0x0
; 	SCB->SCR = SCB_SCR_SEVONPEND_Msk;
 80036c8: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80036d8 <z_arm_cpu_idle_init+0x14>
 80036ca: 2210         	movs	r2, #0x10
 80036cc: 611a         	str	r2, [r3, #0x10]
; }
 80036ce: bf00         	nop
 80036d0: 46bd         	mov	sp, r7
 80036d2: bc80         	pop	{r7}
 80036d4: 4770         	bx	lr
 80036d6: bf00         	nop

080036d8 <$d>:
 80036d8: 00 ed 00 e0  	.word	0xe000ed00

080036dc <__NVIC_SetPriority>:
; {
 80036dc: b480         	push	{r7}
 80036de: b083         	sub	sp, #0xc
 80036e0: af00         	add	r7, sp, #0x0
 80036e2: 4603         	mov	r3, r0
 80036e4: 6039         	str	r1, [r7]
 80036e6: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 80036e8: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80036ec: 2b00         	cmp	r3, #0x0
 80036ee: db0a         	blt	0x8003706 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80036f0: 683b         	ldr	r3, [r7]
 80036f2: b2da         	uxtb	r2, r3
 80036f4: 490c         	ldr	r1, [pc, #0x30]         @ 0x8003728 <__NVIC_SetPriority+0x4c>
 80036f6: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80036fa: 0112         	lsls	r2, r2, #0x4
 80036fc: b2d2         	uxtb	r2, r2
 80036fe: 440b         	add	r3, r1
 8003700: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8003704: e00a         	b	0x800371c <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003706: 683b         	ldr	r3, [r7]
 8003708: b2da         	uxtb	r2, r3
 800370a: 4908         	ldr	r1, [pc, #0x20]         @ 0x800372c <__NVIC_SetPriority+0x50>
 800370c: 79fb         	ldrb	r3, [r7, #0x7]
 800370e: f003 030f    	and	r3, r3, #0xf
 8003712: 3b04         	subs	r3, #0x4
 8003714: 0112         	lsls	r2, r2, #0x4
 8003716: b2d2         	uxtb	r2, r2
 8003718: 440b         	add	r3, r1
 800371a: 761a         	strb	r2, [r3, #0x18]
; }
 800371c: bf00         	nop
 800371e: 370c         	adds	r7, #0xc
 8003720: 46bd         	mov	sp, r7
 8003722: bc80         	pop	{r7}
 8003724: 4770         	bx	lr
 8003726: bf00         	nop

08003728 <$d>:
 8003728: 00 e1 00 e0  	.word	0xe000e100
 800372c: 00 ed 00 e0  	.word	0xe000ed00

08003730 <_isr_wrapper>:
; {
 8003730: b580         	push	{r7, lr}
 8003732: b084         	sub	sp, #0x10
 8003734: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8003736: f3ef 8305    	mrs	r3, ipsr
 800373a: 607b         	str	r3, [r7, #0x4]
;   return(result);
 800373c: 687b         	ldr	r3, [r7, #0x4]
; 	int32_t irq_number = __get_IPSR();
 800373e: 60fb         	str	r3, [r7, #0xc]
; 	irq_number -= 16;
 8003740: 68fb         	ldr	r3, [r7, #0xc]
 8003742: 3b10         	subs	r3, #0x10
 8003744: 60fb         	str	r3, [r7, #0xc]
; 	struct _isr_table_entry *entry = &_sw_isr_table[irq_number];
 8003746: 68fb         	ldr	r3, [r7, #0xc]
 8003748: 00db         	lsls	r3, r3, #0x3
 800374a: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8003768 <_isr_wrapper+0x38>
 800374c: 4413         	add	r3, r2
 800374e: 60bb         	str	r3, [r7, #0x8]
; 	(entry->isr)(entry->arg);
 8003750: 68bb         	ldr	r3, [r7, #0x8]
 8003752: 685b         	ldr	r3, [r3, #0x4]
 8003754: 68ba         	ldr	r2, [r7, #0x8]
 8003756: 6812         	ldr	r2, [r2]
 8003758: 4610         	mov	r0, r2
 800375a: 4798         	blx	r3
; 	z_arm_exc_exit();
 800375c: f7fe ff88    	bl	0x8002670 <z_arm_int_exit> @ imm = #-0x10f0
; }
 8003760: bf00         	nop
 8003762: 3710         	adds	r7, #0x10
 8003764: 46bd         	mov	sp, r7
 8003766: bd80         	pop	{r7, pc}

08003768 <$d>:
 8003768: 90 ae 01 08  	.word	0x0801ae90

0800376c <cbvprintf>:
; {
 800376c: b580         	push	{r7, lr}
 800376e: b08a         	sub	sp, #0x28
 8003770: af00         	add	r7, sp, #0x0
 8003772: 60f8         	str	r0, [r7, #0xc]
 8003774: 60b9         	str	r1, [r7, #0x8]
 8003776: 607a         	str	r2, [r7, #0x4]
 8003778: 603b         	str	r3, [r7]
; 	struct cb_bits	s = {
 800377a: f107 0310    	add.w	r3, r7, #0x10
 800377e: 2200         	movs	r2, #0x0
 8003780: 601a         	str	r2, [r3]
 8003782: 605a         	str	r2, [r3, #0x4]
 8003784: 609a         	str	r2, [r3, #0x8]
 8003786: 60da         	str	r2, [r3, #0xc]
 8003788: 611a         	str	r2, [r3, #0x10]
 800378a: 615a         	str	r2, [r3, #0x14]
 800378c: 2302         	movs	r3, #0x2
 800378e: 74bb         	strb	r3, [r7, #0x12]
 8003790: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80037b4 <cbvprintf+0x48>
 8003792: 617b         	str	r3, [r7, #0x14]
 8003794: 68fb         	ldr	r3, [r7, #0xc]
 8003796: 623b         	str	r3, [r7, #0x20]
 8003798: 68bb         	ldr	r3, [r7, #0x8]
 800379a: 627b         	str	r3, [r7, #0x24]
; 	return vfprintf(&s.f, fp, ap);
 800379c: f107 0310    	add.w	r3, r7, #0x10
 80037a0: 683a         	ldr	r2, [r7]
 80037a2: 6879         	ldr	r1, [r7, #0x4]
 80037a4: 4618         	mov	r0, r3
 80037a6: f00c fd8f    	bl	0x80102c8 <vfprintf>    @ imm = #0xcb1e
 80037aa: 4603         	mov	r3, r0
; }
 80037ac: 4618         	mov	r0, r3
 80037ae: 3728         	adds	r7, #0x28
 80037b0: 46bd         	mov	sp, r7
 80037b2: bd80         	pop	{r7, pc}

080037b4 <$d>:
 80037b4: 17 2c 01 08  	.word	0x08012c17

080037b8 <z_impl_zephyr_fputc>:
; {
 80037b8: b580         	push	{r7, lr}
 80037ba: b082         	sub	sp, #0x8
 80037bc: af00         	add	r7, sp, #0x0
 80037be: 6078         	str	r0, [r7, #0x4]
 80037c0: 6039         	str	r1, [r7]
; 	(*_stdout_hook)(a);
 80037c2: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80037d4 <z_impl_zephyr_fputc+0x1c>
 80037c4: 681b         	ldr	r3, [r3]
 80037c6: 6878         	ldr	r0, [r7, #0x4]
 80037c8: 4798         	blx	r3
; 	return 0;
 80037ca: 2300         	movs	r3, #0x0
; }
 80037cc: 4618         	mov	r0, r3
 80037ce: 3708         	adds	r7, #0x8
 80037d0: 46bd         	mov	sp, r7
 80037d2: bd80         	pop	{r7, pc}

080037d4 <$d>:
 80037d4: 54 0b 00 20  	.word	0x20000b54

080037d8 <__stdout_hook_install>:
; {
 80037d8: b480         	push	{r7}
 80037da: b083         	sub	sp, #0xc
 80037dc: af00         	add	r7, sp, #0x0
 80037de: 6078         	str	r0, [r7, #0x4]
; 	_stdout_hook = hook;
 80037e0: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8003800 <__stdout_hook_install+0x28>
 80037e2: 687b         	ldr	r3, [r7, #0x4]
 80037e4: 6013         	str	r3, [r2]
; 	__stdout.flags |= _FDEV_SETUP_WRITE;
 80037e6: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8003804 <__stdout_hook_install+0x2c>
 80037e8: 789b         	ldrb	r3, [r3, #0x2]
 80037ea: f043 0302    	orr	r3, r3, #0x2
 80037ee: b2da         	uxtb	r2, r3
 80037f0: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8003804 <__stdout_hook_install+0x2c>
 80037f2: 709a         	strb	r2, [r3, #0x2]
; }
 80037f4: bf00         	nop
 80037f6: 370c         	adds	r7, #0xc
 80037f8: 46bd         	mov	sp, r7
 80037fa: bc80         	pop	{r7}
 80037fc: 4770         	bx	lr
 80037fe: bf00         	nop

08003800 <$d>:
 8003800: 54 0b 00 20  	.word	0x20000b54
 8003804: 30 04 00 20  	.word	0x20000430

08003808 <malloc_prepare>:
; {
 8003808: b580         	push	{r7, lr}
 800380a: b082         	sub	sp, #0x8
 800380c: af00         	add	r7, sp, #0x0
; 	void *heap_base = NULL;
 800380e: 2300         	movs	r3, #0x0
 8003810: 607b         	str	r3, [r7, #0x4]
; 	heap_base = UINT_TO_POINTER(HEAP_BASE);
 8003812: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8003844 <malloc_prepare+0x3c>
 8003814: 3307         	adds	r3, #0x7
 8003816: f023 0307    	bic	r3, r3, #0x7
 800381a: 607b         	str	r3, [r7, #0x4]
; 	heap_size = HEAP_SIZE;
 800381c: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8003844 <malloc_prepare+0x3c>
 800381e: 3307         	adds	r3, #0x7
 8003820: f023 0307    	bic	r3, r3, #0x7
 8003824: f1c3 5300    	rsb.w	r3, r3, #0x20000000
 8003828: f503 3300    	add.w	r3, r3, #0x20000
 800382c: 603b         	str	r3, [r7]
; 	sys_heap_init(&z_malloc_heap, heap_base, heap_size);
 800382e: 683a         	ldr	r2, [r7]
 8003830: 6879         	ldr	r1, [r7, #0x4]
 8003832: 4805         	ldr	r0, [pc, #0x14]         @ 0x8003848 <malloc_prepare+0x40>
 8003834: f00e f8b7    	bl	0x80119a6 <sys_heap_init> @ imm = #0xe16e
; 	return 0;
 8003838: 2300         	movs	r3, #0x0
; }
 800383a: 4618         	mov	r0, r3
 800383c: 3708         	adds	r7, #0x8
 800383e: 46bd         	mov	sp, r7
 8003840: bd80         	pop	{r7, pc}
 8003842: bf00         	nop

08003844 <$d>:
 8003844: a0 3a 00 20  	.word	0x20003aa0
 8003848: 58 0b 00 20  	.word	0x20000b58

0800384c <LL_EXTI_EnableIT_0_31>:
; {
 800384c: b480         	push	{r7}
 800384e: b083         	sub	sp, #0xc
 8003850: af00         	add	r7, sp, #0x0
 8003852: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->IMR, ExtiLine);
 8003854: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800386c <LL_EXTI_EnableIT_0_31+0x20>
 8003856: 681a         	ldr	r2, [r3]
 8003858: 4904         	ldr	r1, [pc, #0x10]         @ 0x800386c <LL_EXTI_EnableIT_0_31+0x20>
 800385a: 687b         	ldr	r3, [r7, #0x4]
 800385c: 4313         	orrs	r3, r2
 800385e: 600b         	str	r3, [r1]
; }
 8003860: bf00         	nop
 8003862: 370c         	adds	r7, #0xc
 8003864: 46bd         	mov	sp, r7
 8003866: bc80         	pop	{r7}
 8003868: 4770         	bx	lr
 800386a: bf00         	nop

0800386c <$d>:
 800386c: 00 3c 01 40  	.word	0x40013c00

08003870 <LL_EXTI_DisableIT_0_31>:
; {
 8003870: b480         	push	{r7}
 8003872: b083         	sub	sp, #0xc
 8003874: af00         	add	r7, sp, #0x0
 8003876: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->IMR, ExtiLine);
 8003878: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8003890 <LL_EXTI_DisableIT_0_31+0x20>
 800387a: 681a         	ldr	r2, [r3]
 800387c: 687b         	ldr	r3, [r7, #0x4]
 800387e: 43db         	mvns	r3, r3
 8003880: 4903         	ldr	r1, [pc, #0xc]          @ 0x8003890 <LL_EXTI_DisableIT_0_31+0x20>
 8003882: 4013         	ands	r3, r2
 8003884: 600b         	str	r3, [r1]
; }
 8003886: bf00         	nop
 8003888: 370c         	adds	r7, #0xc
 800388a: 46bd         	mov	sp, r7
 800388c: bc80         	pop	{r7}
 800388e: 4770         	bx	lr

08003890 <$d>:
 8003890: 00 3c 01 40  	.word	0x40013c00

08003894 <LL_EXTI_EnableRisingTrig_0_31>:
; {
 8003894: b480         	push	{r7}
 8003896: b083         	sub	sp, #0xc
 8003898: af00         	add	r7, sp, #0x0
 800389a: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->RTSR, ExtiLine);
 800389c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80038b4 <LL_EXTI_EnableRisingTrig_0_31+0x20>
 800389e: 689a         	ldr	r2, [r3, #0x8]
 80038a0: 4904         	ldr	r1, [pc, #0x10]         @ 0x80038b4 <LL_EXTI_EnableRisingTrig_0_31+0x20>
 80038a2: 687b         	ldr	r3, [r7, #0x4]
 80038a4: 4313         	orrs	r3, r2
 80038a6: 608b         	str	r3, [r1, #0x8]
; }
 80038a8: bf00         	nop
 80038aa: 370c         	adds	r7, #0xc
 80038ac: 46bd         	mov	sp, r7
 80038ae: bc80         	pop	{r7}
 80038b0: 4770         	bx	lr
 80038b2: bf00         	nop

080038b4 <$d>:
 80038b4: 00 3c 01 40  	.word	0x40013c00

080038b8 <LL_EXTI_DisableRisingTrig_0_31>:
; {
 80038b8: b480         	push	{r7}
 80038ba: b083         	sub	sp, #0xc
 80038bc: af00         	add	r7, sp, #0x0
 80038be: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->RTSR, ExtiLine);
 80038c0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80038d8 <LL_EXTI_DisableRisingTrig_0_31+0x20>
 80038c2: 689a         	ldr	r2, [r3, #0x8]
 80038c4: 687b         	ldr	r3, [r7, #0x4]
 80038c6: 43db         	mvns	r3, r3
 80038c8: 4903         	ldr	r1, [pc, #0xc]          @ 0x80038d8 <LL_EXTI_DisableRisingTrig_0_31+0x20>
 80038ca: 4013         	ands	r3, r2
 80038cc: 608b         	str	r3, [r1, #0x8]
; }
 80038ce: bf00         	nop
 80038d0: 370c         	adds	r7, #0xc
 80038d2: 46bd         	mov	sp, r7
 80038d4: bc80         	pop	{r7}
 80038d6: 4770         	bx	lr

080038d8 <$d>:
 80038d8: 00 3c 01 40  	.word	0x40013c00

080038dc <LL_EXTI_EnableFallingTrig_0_31>:
; {
 80038dc: b480         	push	{r7}
 80038de: b083         	sub	sp, #0xc
 80038e0: af00         	add	r7, sp, #0x0
 80038e2: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->FTSR, ExtiLine);
 80038e4: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80038fc <LL_EXTI_EnableFallingTrig_0_31+0x20>
 80038e6: 68da         	ldr	r2, [r3, #0xc]
 80038e8: 4904         	ldr	r1, [pc, #0x10]         @ 0x80038fc <LL_EXTI_EnableFallingTrig_0_31+0x20>
 80038ea: 687b         	ldr	r3, [r7, #0x4]
 80038ec: 4313         	orrs	r3, r2
 80038ee: 60cb         	str	r3, [r1, #0xc]
; }
 80038f0: bf00         	nop
 80038f2: 370c         	adds	r7, #0xc
 80038f4: 46bd         	mov	sp, r7
 80038f6: bc80         	pop	{r7}
 80038f8: 4770         	bx	lr
 80038fa: bf00         	nop

080038fc <$d>:
 80038fc: 00 3c 01 40  	.word	0x40013c00

08003900 <LL_EXTI_DisableFallingTrig_0_31>:
; {
 8003900: b480         	push	{r7}
 8003902: b083         	sub	sp, #0xc
 8003904: af00         	add	r7, sp, #0x0
 8003906: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->FTSR, ExtiLine);
 8003908: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8003920 <LL_EXTI_DisableFallingTrig_0_31+0x20>
 800390a: 68da         	ldr	r2, [r3, #0xc]
 800390c: 687b         	ldr	r3, [r7, #0x4]
 800390e: 43db         	mvns	r3, r3
 8003910: 4903         	ldr	r1, [pc, #0xc]          @ 0x8003920 <LL_EXTI_DisableFallingTrig_0_31+0x20>
 8003912: 4013         	ands	r3, r2
 8003914: 60cb         	str	r3, [r1, #0xc]
; }
 8003916: bf00         	nop
 8003918: 370c         	adds	r7, #0xc
 800391a: 46bd         	mov	sp, r7
 800391c: bc80         	pop	{r7}
 800391e: 4770         	bx	lr

08003920 <$d>:
 8003920: 00 3c 01 40  	.word	0x40013c00

08003924 <LL_EXTI_IsActiveFlag_0_31>:
; {
 8003924: b480         	push	{r7}
 8003926: b083         	sub	sp, #0xc
 8003928: af00         	add	r7, sp, #0x0
 800392a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(EXTI->PR, ExtiLine) == (ExtiLine));
 800392c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800394c <LL_EXTI_IsActiveFlag_0_31+0x28>
 800392e: 695a         	ldr	r2, [r3, #0x14]
 8003930: 687b         	ldr	r3, [r7, #0x4]
 8003932: 4013         	ands	r3, r2
 8003934: 687a         	ldr	r2, [r7, #0x4]
 8003936: 429a         	cmp	r2, r3
 8003938: bf0c         	ite	eq
 800393a: 2301         	moveq	r3, #0x1
 800393c: 2300         	movne	r3, #0x0
 800393e: b2db         	uxtb	r3, r3
; }
 8003940: 4618         	mov	r0, r3
 8003942: 370c         	adds	r7, #0xc
 8003944: 46bd         	mov	sp, r7
 8003946: bc80         	pop	{r7}
 8003948: 4770         	bx	lr
 800394a: bf00         	nop

0800394c <$d>:
 800394c: 00 3c 01 40  	.word	0x40013c00

08003950 <LL_EXTI_ClearFlag_0_31>:
; {
 8003950: b480         	push	{r7}
 8003952: b083         	sub	sp, #0xc
 8003954: af00         	add	r7, sp, #0x0
 8003956: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(EXTI->PR, ExtiLine);
 8003958: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8003968 <LL_EXTI_ClearFlag_0_31+0x18>
 800395a: 687b         	ldr	r3, [r7, #0x4]
 800395c: 6153         	str	r3, [r2, #0x14]
; }
 800395e: bf00         	nop
 8003960: 370c         	adds	r7, #0xc
 8003962: 46bd         	mov	sp, r7
 8003964: bc80         	pop	{r7}
 8003966: 4770         	bx	lr

08003968 <$d>:
 8003968: 00 3c 01 40  	.word	0x40013c00

0800396c <LL_SYSCFG_SetEXTISource>:
; {
 800396c: b480         	push	{r7}
 800396e: b087         	sub	sp, #0x1c
 8003970: af00         	add	r7, sp, #0x0
 8003972: 6078         	str	r0, [r7, #0x4]
 8003974: 6039         	str	r1, [r7]
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16), Port << POSITION_VAL((Line >> 16)));
 8003976: 4a16         	ldr	r2, [pc, #0x58]         @ 0x80039d0 <LL_SYSCFG_SetEXTISource+0x64>
 8003978: 683b         	ldr	r3, [r7]
 800397a: b2db         	uxtb	r3, r3
 800397c: 3302         	adds	r3, #0x2
 800397e: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 8003982: 683b         	ldr	r3, [r7]
 8003984: 0c1b         	lsrs	r3, r3, #0x10
 8003986: 43db         	mvns	r3, r3
 8003988: ea02 0103    	and.w	r1, r2, r3
 800398c: 683b         	ldr	r3, [r7]
 800398e: 0c1b         	lsrs	r3, r3, #0x10
 8003990: 613b         	str	r3, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8003992: 693b         	ldr	r3, [r7, #0x10]
 8003994: fa93 f3a3    	rbit	r3, r3
 8003998: 60fb         	str	r3, [r7, #0xc]
;   return result;
 800399a: 68fb         	ldr	r3, [r7, #0xc]
 800399c: 617b         	str	r3, [r7, #0x14]
;   if (value == 0U)
 800399e: 697b         	ldr	r3, [r7, #0x14]
 80039a0: 2b00         	cmp	r3, #0x0
 80039a2: d101         	bne	0x80039a8 <LL_SYSCFG_SetEXTISource+0x3c> @ imm = #0x2
;     return 32U;
 80039a4: 2320         	movs	r3, #0x20
 80039a6: e003         	b	0x80039b0 <LL_SYSCFG_SetEXTISource+0x44> @ imm = #0x6
;   return __builtin_clz(value);
 80039a8: 697b         	ldr	r3, [r7, #0x14]
 80039aa: fab3 f383    	clz	r3, r3
 80039ae: b2db         	uxtb	r3, r3
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16), Port << POSITION_VAL((Line >> 16)));
 80039b0: 461a         	mov	r2, r3
 80039b2: 687b         	ldr	r3, [r7, #0x4]
 80039b4: fa03 f202    	lsl.w	r2, r3, r2
 80039b8: 4805         	ldr	r0, [pc, #0x14]         @ 0x80039d0 <LL_SYSCFG_SetEXTISource+0x64>
 80039ba: 683b         	ldr	r3, [r7]
 80039bc: b2db         	uxtb	r3, r3
 80039be: 430a         	orrs	r2, r1
 80039c0: 3302         	adds	r3, #0x2
 80039c2: f840 2023    	str.w	r2, [r0, r3, lsl #2]
; }
 80039c6: bf00         	nop
 80039c8: 371c         	adds	r7, #0x1c
 80039ca: 46bd         	mov	sp, r7
 80039cc: bc80         	pop	{r7}
 80039ce: 4770         	bx	lr

080039d0 <$d>:
 80039d0: 00 38 01 40  	.word	0x40013800

080039d4 <LL_SYSCFG_GetEXTISource>:
; {
 80039d4: b480         	push	{r7}
 80039d6: b087         	sub	sp, #0x1c
 80039d8: af00         	add	r7, sp, #0x0
 80039da: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16)) >> POSITION_VAL(Line >> 16));
 80039dc: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8003a20 <LL_SYSCFG_GetEXTISource+0x4c>
 80039de: 687b         	ldr	r3, [r7, #0x4]
 80039e0: b2db         	uxtb	r3, r3
 80039e2: 3302         	adds	r3, #0x2
 80039e4: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 80039e8: 687b         	ldr	r3, [r7, #0x4]
 80039ea: 0c1b         	lsrs	r3, r3, #0x10
 80039ec: 4013         	ands	r3, r2
 80039ee: 687a         	ldr	r2, [r7, #0x4]
 80039f0: 0c12         	lsrs	r2, r2, #0x10
 80039f2: 613a         	str	r2, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80039f4: 693a         	ldr	r2, [r7, #0x10]
 80039f6: fa92 f2a2    	rbit	r2, r2
 80039fa: 60fa         	str	r2, [r7, #0xc]
;   return result;
 80039fc: 68fa         	ldr	r2, [r7, #0xc]
 80039fe: 617a         	str	r2, [r7, #0x14]
;   if (value == 0U)
 8003a00: 697a         	ldr	r2, [r7, #0x14]
 8003a02: 2a00         	cmp	r2, #0x0
 8003a04: d101         	bne	0x8003a0a <LL_SYSCFG_GetEXTISource+0x36> @ imm = #0x2
;     return 32U;
 8003a06: 2220         	movs	r2, #0x20
 8003a08: e003         	b	0x8003a12 <LL_SYSCFG_GetEXTISource+0x3e> @ imm = #0x6
;   return __builtin_clz(value);
 8003a0a: 697a         	ldr	r2, [r7, #0x14]
 8003a0c: fab2 f282    	clz	r2, r2
 8003a10: b2d2         	uxtb	r2, r2
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16)) >> POSITION_VAL(Line >> 16));
 8003a12: 40d3         	lsrs	r3, r2
; }
 8003a14: 4618         	mov	r0, r3
 8003a16: 371c         	adds	r7, #0x1c
 8003a18: 46bd         	mov	sp, r7
 8003a1a: bc80         	pop	{r7}
 8003a1c: 4770         	bx	lr
 8003a1e: bf00         	nop

08003a20 <$d>:
 8003a20: 00 38 01 40  	.word	0x40013800

08003a24 <stm32_exti_isr>:
; {
 8003a24: b580         	push	{r7, lr}
 8003a26: b088         	sub	sp, #0x20
 8003a28: af00         	add	r7, sp, #0x0
 8003a2a: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = DEVICE_DT_GET(EXTI_NODE);
 8003a2c: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8003aac <stm32_exti_isr+0x88>
 8003a2e: 61bb         	str	r3, [r7, #0x18]
; 	struct stm32_exti_data *data = dev->data;
 8003a30: 69bb         	ldr	r3, [r7, #0x18]
 8003a32: 691b         	ldr	r3, [r3, #0x10]
 8003a34: 617b         	str	r3, [r7, #0x14]
; 	const struct stm32_exti_range *range = exti_range;
 8003a36: 687b         	ldr	r3, [r7, #0x4]
 8003a38: 613b         	str	r3, [r7, #0x10]
; 	for (uint8_t i = 0; i <= range->len; i++) {
 8003a3a: 2300         	movs	r3, #0x0
 8003a3c: 77fb         	strb	r3, [r7, #0x1f]
 8003a3e: e02b         	b	0x8003a98 <stm32_exti_isr+0x74> @ imm = #0x56
; 		line_num = range->start + i;
 8003a40: 693b         	ldr	r3, [r7, #0x10]
 8003a42: 781b         	ldrb	r3, [r3]
 8003a44: 461a         	mov	r2, r3
 8003a46: 7ffb         	ldrb	r3, [r7, #0x1f]
 8003a48: 4413         	add	r3, r2
 8003a4a: 60fb         	str	r3, [r7, #0xc]
; 		line = linenum_to_ll_exti_line(line_num);
 8003a4c: 68fb         	ldr	r3, [r7, #0xc]
 8003a4e: b2db         	uxtb	r3, r3
 8003a50: 4618         	mov	r0, r3
 8003a52: f00f f964    	bl	0x8012d1e <linenum_to_ll_exti_line> @ imm = #0xf2c8
 8003a56: 60b8         	str	r0, [r7, #0x8]
; 		if (stm32_exti_is_pending(line) != 0) {
 8003a58: 68b8         	ldr	r0, [r7, #0x8]
 8003a5a: f00f f949    	bl	0x8012cf0 <stm32_exti_is_pending> @ imm = #0xf292
 8003a5e: 4603         	mov	r3, r0
 8003a60: 2b00         	cmp	r3, #0x0
 8003a62: d016         	beq	0x8003a92 <stm32_exti_isr+0x6e> @ imm = #0x2c
; 			stm32_exti_clear_pending(line);
 8003a64: 68b8         	ldr	r0, [r7, #0x8]
 8003a66: f00f f94f    	bl	0x8012d08 <stm32_exti_clear_pending> @ imm = #0xf29e
; 			if (!data->cb[line_num].cb) {
 8003a6a: 697b         	ldr	r3, [r7, #0x14]
 8003a6c: 68fa         	ldr	r2, [r7, #0xc]
 8003a6e: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 8003a72: 2b00         	cmp	r3, #0x0
 8003a74: d00c         	beq	0x8003a90 <stm32_exti_isr+0x6c> @ imm = #0x18
; 			data->cb[line_num].cb(line, data->cb[line_num].data);
 8003a76: 697b         	ldr	r3, [r7, #0x14]
 8003a78: 68fa         	ldr	r2, [r7, #0xc]
 8003a7a: f853 2032    	ldr.w	r2, [r3, r2, lsl #3]
 8003a7e: 6979         	ldr	r1, [r7, #0x14]
 8003a80: 68fb         	ldr	r3, [r7, #0xc]
 8003a82: 00db         	lsls	r3, r3, #0x3
 8003a84: 440b         	add	r3, r1
 8003a86: 685b         	ldr	r3, [r3, #0x4]
 8003a88: 4619         	mov	r1, r3
 8003a8a: 68b8         	ldr	r0, [r7, #0x8]
 8003a8c: 4790         	blx	r2
 8003a8e: e000         	b	0x8003a92 <stm32_exti_isr+0x6e> @ imm = #0x0
; 				continue;
 8003a90: bf00         	nop
; 	for (uint8_t i = 0; i <= range->len; i++) {
 8003a92: 7ffb         	ldrb	r3, [r7, #0x1f]
 8003a94: 3301         	adds	r3, #0x1
 8003a96: 77fb         	strb	r3, [r7, #0x1f]
 8003a98: 693b         	ldr	r3, [r7, #0x10]
 8003a9a: 785b         	ldrb	r3, [r3, #0x1]
 8003a9c: 7ffa         	ldrb	r2, [r7, #0x1f]
 8003a9e: 429a         	cmp	r2, r3
 8003aa0: d9ce         	bls	0x8003a40 <stm32_exti_isr+0x1c> @ imm = #-0x64
; }
 8003aa2: bf00         	nop
 8003aa4: bf00         	nop
 8003aa6: 3720         	adds	r7, #0x20
 8003aa8: 46bd         	mov	sp, r7
 8003aaa: bd80         	pop	{r7, pc}

08003aac <$d>:
 8003aac: 00 ad 01 08  	.word	0x0801ad00

08003ab0 <stm32_exti_enable_registers>:
; {
 8003ab0: b580         	push	{r7, lr}
 8003ab2: b084         	sub	sp, #0x10
 8003ab4: af00         	add	r7, sp, #0x0
; 	int ret = 0;
 8003ab6: 2300         	movs	r3, #0x0
 8003ab8: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8003aba: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8003ae0 <stm32_exti_enable_registers+0x30>
 8003abc: 60bb         	str	r3, [r7, #0x8]
; 	struct stm32_pclken pclken = {
 8003abe: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8003ae4 <stm32_exti_enable_registers+0x34>
 8003ac0: 463b         	mov	r3, r7
 8003ac2: e892 0003    	ldm.w	r2, {r0, r1}
 8003ac6: e883 0003    	stm.w	r3, {r0, r1}
; 	ret = clock_control_on(clk, (clock_control_subsys_t) &pclken);
 8003aca: 463b         	mov	r3, r7
 8003acc: 4619         	mov	r1, r3
 8003ace: 68b8         	ldr	r0, [r7, #0x8]
 8003ad0: f00f f8d3    	bl	0x8012c7a <clock_control_on> @ imm = #0xf1a6
 8003ad4: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 8003ad6: 68fb         	ldr	r3, [r7, #0xc]
; }
 8003ad8: 4618         	mov	r0, r3
 8003ada: 3710         	adds	r7, #0x10
 8003adc: 46bd         	mov	sp, r7
 8003ade: bd80         	pop	{r7, pc}

08003ae0 <$d>:
 8003ae0: d8 ac 01 08  	.word	0x0801acd8
 8003ae4: 28 ba 01 08  	.word	0x0801ba28

08003ae8 <stm32_fill_irq_table>:
; {
 8003ae8: b480         	push	{r7}
 8003aea: b085         	sub	sp, #0x14
 8003aec: af00         	add	r7, sp, #0x0
 8003aee: 4603         	mov	r3, r0
 8003af0: 603a         	str	r2, [r7]
 8003af2: 71fb         	strb	r3, [r7, #0x7]
 8003af4: 460b         	mov	r3, r1
 8003af6: 71bb         	strb	r3, [r7, #0x6]
; 	for (int i = 0; i < len; i++) {
 8003af8: 2300         	movs	r3, #0x0
 8003afa: 60fb         	str	r3, [r7, #0xc]
 8003afc: e00a         	b	0x8003b14 <stm32_fill_irq_table+0x2c> @ imm = #0x14
; 		exti_irq_table[start + i] = irqn;
 8003afe: f997 2007    	ldrsb.w	r2, [r7, #0x7]
 8003b02: 68fb         	ldr	r3, [r7, #0xc]
 8003b04: 4413         	add	r3, r2
 8003b06: 683a         	ldr	r2, [r7]
 8003b08: b251         	sxtb	r1, r2
 8003b0a: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8003b2c <stm32_fill_irq_table+0x44>
 8003b0c: 54d1         	strb	r1, [r2, r3]
; 	for (int i = 0; i < len; i++) {
 8003b0e: 68fb         	ldr	r3, [r7, #0xc]
 8003b10: 3301         	adds	r3, #0x1
 8003b12: 60fb         	str	r3, [r7, #0xc]
 8003b14: f997 3006    	ldrsb.w	r3, [r7, #0x6]
 8003b18: 68fa         	ldr	r2, [r7, #0xc]
 8003b1a: 429a         	cmp	r2, r3
 8003b1c: dbef         	blt	0x8003afe <stm32_fill_irq_table+0x16> @ imm = #-0x22
; }
 8003b1e: bf00         	nop
 8003b20: bf00         	nop
 8003b22: 3714         	adds	r7, #0x14
 8003b24: 46bd         	mov	sp, r7
 8003b26: bc80         	pop	{r7}
 8003b28: 4770         	bx	lr
 8003b2a: bf00         	nop

08003b2c <$d>:
 8003b2c: 40 04 00 20  	.word	0x20000440

08003b30 <stm32_exti_init>:
; {
 8003b30: b580         	push	{r7, lr}
 8003b32: b082         	sub	sp, #0x8
 8003b34: af00         	add	r7, sp, #0x0
 8003b36: 6078         	str	r0, [r7, #0x4]
; 	DT_FOREACH_PROP_ELEM(DT_NODELABEL(exti),
 8003b38: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8003c18 <stm32_exti_init+0xe8>
 8003b3a: 781b         	ldrb	r3, [r3]
 8003b3c: b25b         	sxtb	r3, r3
 8003b3e: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x8003c18 <stm32_exti_init+0xe8>
 8003b40: 7852         	ldrb	r2, [r2, #0x1]
 8003b42: b251         	sxtb	r1, r2
 8003b44: 2206         	movs	r2, #0x6
 8003b46: 4618         	mov	r0, r3
 8003b48: f7ff ffce    	bl	0x8003ae8 <stm32_fill_irq_table> @ imm = #-0x64
 8003b4c: 2200         	movs	r2, #0x0
 8003b4e: 2100         	movs	r1, #0x0
 8003b50: 2006         	movs	r0, #0x6
 8003b52: f00e ffe1    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #0xefc2
 8003b56: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8003c1c <stm32_exti_init+0xec>
 8003b58: 781b         	ldrb	r3, [r3]
 8003b5a: b25b         	sxtb	r3, r3
 8003b5c: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x8003c1c <stm32_exti_init+0xec>
 8003b5e: 7852         	ldrb	r2, [r2, #0x1]
 8003b60: b251         	sxtb	r1, r2
 8003b62: 2207         	movs	r2, #0x7
 8003b64: 4618         	mov	r0, r3
 8003b66: f7ff ffbf    	bl	0x8003ae8 <stm32_fill_irq_table> @ imm = #-0x82
 8003b6a: 2200         	movs	r2, #0x0
 8003b6c: 2100         	movs	r1, #0x0
 8003b6e: 2007         	movs	r0, #0x7
 8003b70: f00e ffd2    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #0xefa4
 8003b74: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8003c20 <stm32_exti_init+0xf0>
 8003b76: 781b         	ldrb	r3, [r3]
 8003b78: b25b         	sxtb	r3, r3
 8003b7a: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x8003c20 <stm32_exti_init+0xf0>
 8003b7c: 7852         	ldrb	r2, [r2, #0x1]
 8003b7e: b251         	sxtb	r1, r2
 8003b80: 2208         	movs	r2, #0x8
 8003b82: 4618         	mov	r0, r3
 8003b84: f7ff ffb0    	bl	0x8003ae8 <stm32_fill_irq_table> @ imm = #-0xa0
 8003b88: 2200         	movs	r2, #0x0
 8003b8a: 2100         	movs	r1, #0x0
 8003b8c: 2008         	movs	r0, #0x8
 8003b8e: f00e ffc3    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #0xef86
 8003b92: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8003c24 <stm32_exti_init+0xf4>
 8003b94: 781b         	ldrb	r3, [r3]
 8003b96: b25b         	sxtb	r3, r3
 8003b98: 4a22         	ldr	r2, [pc, #0x88]         @ 0x8003c24 <stm32_exti_init+0xf4>
 8003b9a: 7852         	ldrb	r2, [r2, #0x1]
 8003b9c: b251         	sxtb	r1, r2
 8003b9e: 2209         	movs	r2, #0x9
 8003ba0: 4618         	mov	r0, r3
 8003ba2: f7ff ffa1    	bl	0x8003ae8 <stm32_fill_irq_table> @ imm = #-0xbe
 8003ba6: 2200         	movs	r2, #0x0
 8003ba8: 2100         	movs	r1, #0x0
 8003baa: 2009         	movs	r0, #0x9
 8003bac: f00e ffb4    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #0xef68
 8003bb0: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8003c28 <stm32_exti_init+0xf8>
 8003bb2: 781b         	ldrb	r3, [r3]
 8003bb4: b25b         	sxtb	r3, r3
 8003bb6: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x8003c28 <stm32_exti_init+0xf8>
 8003bb8: 7852         	ldrb	r2, [r2, #0x1]
 8003bba: b251         	sxtb	r1, r2
 8003bbc: 220a         	movs	r2, #0xa
 8003bbe: 4618         	mov	r0, r3
 8003bc0: f7ff ff92    	bl	0x8003ae8 <stm32_fill_irq_table> @ imm = #-0xdc
 8003bc4: 2200         	movs	r2, #0x0
 8003bc6: 2100         	movs	r1, #0x0
 8003bc8: 200a         	movs	r0, #0xa
 8003bca: f00e ffa5    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #0xef4a
 8003bce: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8003c2c <stm32_exti_init+0xfc>
 8003bd0: 781b         	ldrb	r3, [r3]
 8003bd2: b25b         	sxtb	r3, r3
 8003bd4: 4a15         	ldr	r2, [pc, #0x54]         @ 0x8003c2c <stm32_exti_init+0xfc>
 8003bd6: 7852         	ldrb	r2, [r2, #0x1]
 8003bd8: b251         	sxtb	r1, r2
 8003bda: 2217         	movs	r2, #0x17
 8003bdc: 4618         	mov	r0, r3
 8003bde: f7ff ff83    	bl	0x8003ae8 <stm32_fill_irq_table> @ imm = #-0xfa
 8003be2: 2200         	movs	r2, #0x0
 8003be4: 2100         	movs	r1, #0x0
 8003be6: 2017         	movs	r0, #0x17
 8003be8: f00e ff96    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #0xef2c
 8003bec: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8003c30 <stm32_exti_init+0x100>
 8003bee: 781b         	ldrb	r3, [r3]
 8003bf0: b25b         	sxtb	r3, r3
 8003bf2: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8003c30 <stm32_exti_init+0x100>
 8003bf4: 7852         	ldrb	r2, [r2, #0x1]
 8003bf6: b251         	sxtb	r1, r2
 8003bf8: 2228         	movs	r2, #0x28
 8003bfa: 4618         	mov	r0, r3
 8003bfc: f7ff ff74    	bl	0x8003ae8 <stm32_fill_irq_table> @ imm = #-0x118
 8003c00: 2200         	movs	r2, #0x0
 8003c02: 2100         	movs	r1, #0x0
 8003c04: 2028         	movs	r0, #0x28
 8003c06: f00e ff87    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #0xef0e
; 	return stm32_exti_enable_registers();
 8003c0a: f7ff ff51    	bl	0x8003ab0 <stm32_exti_enable_registers> @ imm = #-0x15e
 8003c0e: 4603         	mov	r3, r0
; }
 8003c10: 4618         	mov	r0, r3
 8003c12: 3708         	adds	r7, #0x8
 8003c14: 46bd         	mov	sp, r7
 8003c16: bd80         	pop	{r7, pc}

08003c18 <$d>:
 8003c18: 6c d0 01 08  	.word	0x0801d06c
 8003c1c: 70 d0 01 08  	.word	0x0801d070
 8003c20: 74 d0 01 08  	.word	0x0801d074
 8003c24: 78 d0 01 08  	.word	0x0801d078
 8003c28: 7c d0 01 08  	.word	0x0801d07c
 8003c2c: 80 d0 01 08  	.word	0x0801d080
 8003c30: 84 d0 01 08  	.word	0x0801d084

08003c34 <stm32_gpio_intc_enable_line>:
; {
 8003c34: b580         	push	{r7, lr}
 8003c36: b084         	sub	sp, #0x10
 8003c38: af00         	add	r7, sp, #0x0
 8003c3a: 6078         	str	r0, [r7, #0x4]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 8003c3c: 6878         	ldr	r0, [r7, #0x4]
 8003c3e: f00f f87c    	bl	0x8012d3a <ll_exti_line_to_linenum> @ imm = #0xf0f8
 8003c42: 4603         	mov	r3, r0
 8003c44: 60fb         	str	r3, [r7, #0xc]
; 	irqnum = exti_irq_table[line_num];
 8003c46: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8003c68 <stm32_gpio_intc_enable_line+0x34>
 8003c48: 68fb         	ldr	r3, [r7, #0xc]
 8003c4a: 4413         	add	r3, r2
 8003c4c: f993 3000    	ldrsb.w	r3, [r3]
 8003c50: 60bb         	str	r3, [r7, #0x8]
; 	LL_EXTI_EnableIT_0_31(line);
 8003c52: 6878         	ldr	r0, [r7, #0x4]
 8003c54: f7ff fdfa    	bl	0x800384c <LL_EXTI_EnableIT_0_31> @ imm = #-0x40c
; 	irq_enable(irqnum);
 8003c58: 68b8         	ldr	r0, [r7, #0x8]
 8003c5a: f00e ff50    	bl	0x8012afe <arch_irq_enable> @ imm = #0xeea0
; }
 8003c5e: bf00         	nop
 8003c60: 3710         	adds	r7, #0x10
 8003c62: 46bd         	mov	sp, r7
 8003c64: bd80         	pop	{r7, pc}
 8003c66: bf00         	nop

08003c68 <$d>:
 8003c68: 40 04 00 20  	.word	0x20000440

08003c6c <stm32_gpio_intc_select_line_trigger>:
; {
 8003c6c: b580         	push	{r7, lr}
 8003c6e: b082         	sub	sp, #0x8
 8003c70: af00         	add	r7, sp, #0x0
 8003c72: 6078         	str	r0, [r7, #0x4]
 8003c74: 6039         	str	r1, [r7]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8003c76: f44f 1180    	mov.w	r1, #0x100000
 8003c7a: 2000         	movs	r0, #0x0
 8003c7c: f00f f80f    	bl	0x8012c9e <z_stm32_hsem_lock> @ imm = #0xf01e
; 	switch (trg) {
 8003c80: 683b         	ldr	r3, [r7]
 8003c82: 2b03         	cmp	r3, #0x3
 8003c84: d826         	bhi	0x8003cd4 <stm32_gpio_intc_select_line_trigger+0x68> @ imm = #0x4c
 8003c86: a201         	adr	r2, #4 <stm32_gpio_intc_select_line_trigger+0x1f>
 8003c88: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08003c8c <$d>:
 8003c8c: 9d 3c 00 08  	.word	0x08003c9d
 8003c90: ab 3c 00 08  	.word	0x08003cab
 8003c94: b9 3c 00 08  	.word	0x08003cb9
 8003c98: c7 3c 00 08  	.word	0x08003cc7

08003c9c <$t>:
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 8003c9c: 6878         	ldr	r0, [r7, #0x4]
 8003c9e: f7ff fe0b    	bl	0x80038b8 <LL_EXTI_DisableRisingTrig_0_31> @ imm = #-0x3ea
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 8003ca2: 6878         	ldr	r0, [r7, #0x4]
 8003ca4: f7ff fe2c    	bl	0x8003900 <LL_EXTI_DisableFallingTrig_0_31> @ imm = #-0x3a8
; 		break;
 8003ca8: e015         	b	0x8003cd6 <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x2a
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 8003caa: 6878         	ldr	r0, [r7, #0x4]
 8003cac: f7ff fdf2    	bl	0x8003894 <LL_EXTI_EnableRisingTrig_0_31> @ imm = #-0x41c
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 8003cb0: 6878         	ldr	r0, [r7, #0x4]
 8003cb2: f7ff fe25    	bl	0x8003900 <LL_EXTI_DisableFallingTrig_0_31> @ imm = #-0x3b6
; 		break;
 8003cb6: e00e         	b	0x8003cd6 <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x1c
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 8003cb8: 6878         	ldr	r0, [r7, #0x4]
 8003cba: f7ff fe0f    	bl	0x80038dc <LL_EXTI_EnableFallingTrig_0_31> @ imm = #-0x3e2
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 8003cbe: 6878         	ldr	r0, [r7, #0x4]
 8003cc0: f7ff fdfa    	bl	0x80038b8 <LL_EXTI_DisableRisingTrig_0_31> @ imm = #-0x40c
; 		break;
 8003cc4: e007         	b	0x8003cd6 <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0xe
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 8003cc6: 6878         	ldr	r0, [r7, #0x4]
 8003cc8: f7ff fde4    	bl	0x8003894 <LL_EXTI_EnableRisingTrig_0_31> @ imm = #-0x438
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 8003ccc: 6878         	ldr	r0, [r7, #0x4]
 8003cce: f7ff fe05    	bl	0x80038dc <LL_EXTI_EnableFallingTrig_0_31> @ imm = #-0x3f6
; 		break;
 8003cd2: e000         	b	0x8003cd6 <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x0
; 		break;
 8003cd4: bf00         	nop
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 8003cd6: 2000         	movs	r0, #0x0
 8003cd8: f00e ffeb    	bl	0x8012cb2 <z_stm32_hsem_unlock> @ imm = #0xefd6
; }
 8003cdc: bf00         	nop
 8003cde: 3708         	adds	r7, #0x8
 8003ce0: 46bd         	mov	sp, r7
 8003ce2: bd80         	pop	{r7, pc}

08003ce4 <stm32_gpio_intc_set_irq_callback>:
; {
 8003ce4: b580         	push	{r7, lr}
 8003ce6: b088         	sub	sp, #0x20
 8003ce8: af00         	add	r7, sp, #0x0
 8003cea: 60f8         	str	r0, [r7, #0xc]
 8003cec: 60b9         	str	r1, [r7, #0x8]
 8003cee: 607a         	str	r2, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 8003cf0: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8003d58 <stm32_gpio_intc_set_irq_callback+0x74>
 8003cf2: 61fb         	str	r3, [r7, #0x1c]
; 	struct stm32_exti_data *data = dev->data;
 8003cf4: 69fb         	ldr	r3, [r7, #0x1c]
 8003cf6: 691b         	ldr	r3, [r3, #0x10]
 8003cf8: 61bb         	str	r3, [r7, #0x18]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 8003cfa: 68f8         	ldr	r0, [r7, #0xc]
 8003cfc: f00f f81d    	bl	0x8012d3a <ll_exti_line_to_linenum> @ imm = #0xf03a
 8003d00: 4603         	mov	r3, r0
 8003d02: 617b         	str	r3, [r7, #0x14]
; 	if ((data->cb[line_num].cb == cb) && (data->cb[line_num].data == user)) {
 8003d04: 69bb         	ldr	r3, [r7, #0x18]
 8003d06: 697a         	ldr	r2, [r7, #0x14]
 8003d08: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 8003d0c: 68ba         	ldr	r2, [r7, #0x8]
 8003d0e: 429a         	cmp	r2, r3
 8003d10: d109         	bne	0x8003d26 <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x12
 8003d12: 69ba         	ldr	r2, [r7, #0x18]
 8003d14: 697b         	ldr	r3, [r7, #0x14]
 8003d16: 00db         	lsls	r3, r3, #0x3
 8003d18: 4413         	add	r3, r2
 8003d1a: 685b         	ldr	r3, [r3, #0x4]
 8003d1c: 687a         	ldr	r2, [r7, #0x4]
 8003d1e: 429a         	cmp	r2, r3
 8003d20: d101         	bne	0x8003d26 <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x2
; 		return 0;
 8003d22: 2300         	movs	r3, #0x0
 8003d24: e014         	b	0x8003d50 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x28
; 	if (data->cb[line_num].cb != NULL) {
 8003d26: 69bb         	ldr	r3, [r7, #0x18]
 8003d28: 697a         	ldr	r2, [r7, #0x14]
 8003d2a: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 8003d2e: 2b00         	cmp	r3, #0x0
 8003d30: d002         	beq	0x8003d38 <stm32_gpio_intc_set_irq_callback+0x54> @ imm = #0x4
; 		return -EBUSY;
 8003d32: f06f 030f    	mvn	r3, #0xf
 8003d36: e00b         	b	0x8003d50 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x16
; 	data->cb[line_num].cb = cb;
 8003d38: 69bb         	ldr	r3, [r7, #0x18]
 8003d3a: 697a         	ldr	r2, [r7, #0x14]
 8003d3c: 68b9         	ldr	r1, [r7, #0x8]
 8003d3e: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = user;
 8003d42: 69ba         	ldr	r2, [r7, #0x18]
 8003d44: 697b         	ldr	r3, [r7, #0x14]
 8003d46: 00db         	lsls	r3, r3, #0x3
 8003d48: 4413         	add	r3, r2
 8003d4a: 687a         	ldr	r2, [r7, #0x4]
 8003d4c: 605a         	str	r2, [r3, #0x4]
; 	return 0;
 8003d4e: 2300         	movs	r3, #0x0
; }
 8003d50: 4618         	mov	r0, r3
 8003d52: 3720         	adds	r7, #0x20
 8003d54: 46bd         	mov	sp, r7
 8003d56: bd80         	pop	{r7, pc}

08003d58 <$d>:
 8003d58: 00 ad 01 08  	.word	0x0801ad00

08003d5c <stm32_gpio_intc_remove_irq_callback>:
; {
 8003d5c: b580         	push	{r7, lr}
 8003d5e: b086         	sub	sp, #0x18
 8003d60: af00         	add	r7, sp, #0x0
 8003d62: 6078         	str	r0, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 8003d64: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8003d98 <stm32_gpio_intc_remove_irq_callback+0x3c>
 8003d66: 617b         	str	r3, [r7, #0x14]
; 	struct stm32_exti_data *data = dev->data;
 8003d68: 697b         	ldr	r3, [r7, #0x14]
 8003d6a: 691b         	ldr	r3, [r3, #0x10]
 8003d6c: 613b         	str	r3, [r7, #0x10]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 8003d6e: 6878         	ldr	r0, [r7, #0x4]
 8003d70: f00e ffe3    	bl	0x8012d3a <ll_exti_line_to_linenum> @ imm = #0xefc6
 8003d74: 4603         	mov	r3, r0
 8003d76: 60fb         	str	r3, [r7, #0xc]
; 	data->cb[line_num].cb = NULL;
 8003d78: 693b         	ldr	r3, [r7, #0x10]
 8003d7a: 68fa         	ldr	r2, [r7, #0xc]
 8003d7c: 2100         	movs	r1, #0x0
 8003d7e: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = NULL;
 8003d82: 693a         	ldr	r2, [r7, #0x10]
 8003d84: 68fb         	ldr	r3, [r7, #0xc]
 8003d86: 00db         	lsls	r3, r3, #0x3
 8003d88: 4413         	add	r3, r2
 8003d8a: 2200         	movs	r2, #0x0
 8003d8c: 605a         	str	r2, [r3, #0x4]
; }
 8003d8e: bf00         	nop
 8003d90: 3718         	adds	r7, #0x18
 8003d92: 46bd         	mov	sp, r7
 8003d94: bd80         	pop	{r7, pc}
 8003d96: bf00         	nop

08003d98 <$d>:
 8003d98: 00 ad 01 08  	.word	0x0801ad00

08003d9c <z_impl_can_send>:
; {
 8003d9c: b590         	push	{r4, r7, lr}
 8003d9e: b097         	sub	sp, #0x5c
 8003da0: af08         	add	r7, sp, #0x20
 8003da2: 60f8         	str	r0, [r7, #0xc]
 8003da4: 60b9         	str	r1, [r7, #0x8]
 8003da6: e9c7 2300    	strd	r2, r3, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8003daa: 68fb         	ldr	r3, [r7, #0xc]
 8003dac: 689b         	ldr	r3, [r3, #0x8]
 8003dae: 62fb         	str	r3, [r7, #0x2c]
; 	CHECKIF(frame == NULL) {
 8003db0: 68bb         	ldr	r3, [r7, #0x8]
 8003db2: 2b00         	cmp	r3, #0x0
 8003db4: d102         	bne	0x8003dbc <z_impl_can_send+0x20> @ imm = #0x4
; 		return -EINVAL;
 8003db6: f06f 0315    	mvn	r3, #0x15
 8003dba: e089         	b	0x8003ed0 <z_impl_can_send+0x134> @ imm = #0x112
; 	if ((frame->flags & CAN_FRAME_IDE) != 0U) {
 8003dbc: 68bb         	ldr	r3, [r7, #0x8]
 8003dbe: 795b         	ldrb	r3, [r3, #0x5]
 8003dc0: f003 0301    	and	r3, r3, #0x1
 8003dc4: 2b00         	cmp	r3, #0x0
 8003dc6: d003         	beq	0x8003dd0 <z_impl_can_send+0x34> @ imm = #0x6
; 		id_mask = CAN_EXT_ID_MASK;
 8003dc8: f06f 4360    	mvn	r3, #0xe0000000
 8003dcc: 633b         	str	r3, [r7, #0x30]
 8003dce: e002         	b	0x8003dd6 <z_impl_can_send+0x3a> @ imm = #0x4
; 		id_mask = CAN_STD_ID_MASK;
 8003dd0: f240 73ff    	movw	r3, #0x7ff
 8003dd4: 633b         	str	r3, [r7, #0x30]
; 	CHECKIF((frame->id & ~(id_mask)) != 0U) {
 8003dd6: 68bb         	ldr	r3, [r7, #0x8]
 8003dd8: 681a         	ldr	r2, [r3]
 8003dda: 6b3b         	ldr	r3, [r7, #0x30]
 8003ddc: 43db         	mvns	r3, r3
 8003dde: 4013         	ands	r3, r2
 8003de0: 2b00         	cmp	r3, #0x0
 8003de2: d040         	beq	0x8003e66 <z_impl_can_send+0xca> @ imm = #0x80
; 		LOG_ERR("invalid frame with %s (%d-bit) CAN ID 0x%0*x",
 8003de4: 2303         	movs	r3, #0x3
 8003de6: 2b00         	cmp	r3, #0x0
 8003de8: d03a         	beq	0x8003e60 <z_impl_can_send+0xc4> @ imm = #0x74
 8003dea: 2301         	movs	r3, #0x1
 8003dec: f887 302b    	strb.w	r3, [r7, #0x2b]
 8003df0: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8003df4: f083 0301    	eor	r3, r3, #0x1
 8003df8: b2db         	uxtb	r3, r3
 8003dfa: 2b00         	cmp	r3, #0x0
 8003dfc: d130         	bne	0x8003e60 <z_impl_can_send+0xc4> @ imm = #0x60
 8003dfe: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8003ed8 <z_impl_can_send+0x13c>
 8003e00: 681c         	ldr	r4, [r3]
 8003e02: 68bb         	ldr	r3, [r7, #0x8]
 8003e04: 795b         	ldrb	r3, [r3, #0x5]
 8003e06: f003 0301    	and	r3, r3, #0x1
 8003e0a: 2b00         	cmp	r3, #0x0
 8003e0c: d001         	beq	0x8003e12 <z_impl_can_send+0x76> @ imm = #0x2
 8003e0e: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8003edc <z_impl_can_send+0x140>
 8003e10: e000         	b	0x8003e14 <z_impl_can_send+0x78> @ imm = #0x0
 8003e12: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8003ee0 <z_impl_can_send+0x144>
 8003e14: 68ba         	ldr	r2, [r7, #0x8]
 8003e16: 7952         	ldrb	r2, [r2, #0x5]
 8003e18: f002 0201    	and	r2, r2, #0x1
 8003e1c: 2a00         	cmp	r2, #0x0
 8003e1e: d001         	beq	0x8003e24 <z_impl_can_send+0x88> @ imm = #0x2
 8003e20: 221d         	movs	r2, #0x1d
 8003e22: e000         	b	0x8003e26 <z_impl_can_send+0x8a> @ imm = #0x0
 8003e24: 220b         	movs	r2, #0xb
 8003e26: 68b9         	ldr	r1, [r7, #0x8]
 8003e28: 7949         	ldrb	r1, [r1, #0x5]
 8003e2a: f001 0101    	and	r1, r1, #0x1
 8003e2e: 2900         	cmp	r1, #0x0
 8003e30: d001         	beq	0x8003e36 <z_impl_can_send+0x9a> @ imm = #0x2
 8003e32: 2108         	movs	r1, #0x8
 8003e34: e000         	b	0x8003e38 <z_impl_can_send+0x9c> @ imm = #0x0
 8003e36: 2103         	movs	r1, #0x3
 8003e38: 68b8         	ldr	r0, [r7, #0x8]
 8003e3a: 6800         	ldr	r0, [r0]
 8003e3c: 9006         	str	r0, [sp, #0x18]
 8003e3e: 9105         	str	r1, [sp, #0x14]
 8003e40: 9204         	str	r2, [sp, #0x10]
 8003e42: 9303         	str	r3, [sp, #0xc]
 8003e44: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8003ee4 <z_impl_can_send+0x148>
 8003e46: 9302         	str	r3, [sp, #0x8]
 8003e48: 2300         	movs	r3, #0x0
 8003e4a: 9301         	str	r3, [sp, #0x4]
 8003e4c: 2300         	movs	r3, #0x0
 8003e4e: 9300         	str	r3, [sp]
 8003e50: 2300         	movs	r3, #0x0
 8003e52: 2201         	movs	r2, #0x1
 8003e54: 4621         	mov	r1, r4
 8003e56: 2000         	movs	r0, #0x0
 8003e58: f00f f84b    	bl	0x8012ef2 <z_log_msg_runtime_create> @ imm = #0xf096
 8003e5c: 2300         	movs	r3, #0x0
 8003e5e: 627b         	str	r3, [r7, #0x24]
; 		return -EINVAL;
 8003e60: f06f 0315    	mvn	r3, #0x15
 8003e64: e034         	b	0x8003ed0 <z_impl_can_send+0x134> @ imm = #0x68
; 	if (callback == NULL) {
 8003e66: 6cbb         	ldr	r3, [r7, #0x48]
 8003e68: 2b00         	cmp	r3, #0x0
 8003e6a: d125         	bne	0x8003eb8 <z_impl_can_send+0x11c> @ imm = #0x4a
; 		k_sem_init(&ctx.done, 0, 1);
 8003e6c: f107 0310    	add.w	r3, r7, #0x10
 8003e70: 2201         	movs	r2, #0x1
 8003e72: 2100         	movs	r1, #0x0
 8003e74: 4618         	mov	r0, r3
 8003e76: f00e ffbd    	bl	0x8012df4 <k_sem_init>  @ imm = #0xef7a
; 		err = api->send(dev, frame, timeout, can_tx_default_cb, &ctx);
 8003e7a: 6afb         	ldr	r3, [r7, #0x2c]
 8003e7c: 695c         	ldr	r4, [r3, #0x14]
 8003e7e: f107 0310    	add.w	r3, r7, #0x10
 8003e82: 9301         	str	r3, [sp, #0x4]
 8003e84: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8003ee8 <z_impl_can_send+0x14c>
 8003e86: 9300         	str	r3, [sp]
 8003e88: e9d7 2300    	ldrd	r2, r3, [r7]
 8003e8c: 68b9         	ldr	r1, [r7, #0x8]
 8003e8e: 68f8         	ldr	r0, [r7, #0xc]
 8003e90: 47a0         	blx	r4
 8003e92: 6378         	str	r0, [r7, #0x34]
; 		if (err != 0) {
 8003e94: 6b7b         	ldr	r3, [r7, #0x34]
 8003e96: 2b00         	cmp	r3, #0x0
 8003e98: d001         	beq	0x8003e9e <z_impl_can_send+0x102> @ imm = #0x2
; 			return err;
 8003e9a: 6b7b         	ldr	r3, [r7, #0x34]
 8003e9c: e018         	b	0x8003ed0 <z_impl_can_send+0x134> @ imm = #0x30
; 		k_sem_take(&ctx.done, K_FOREVER);
 8003e9e: f04f 30ff    	mov.w	r0, #0xffffffff
 8003ea2: f04f 31ff    	mov.w	r1, #0xffffffff
 8003ea6: f107 0410    	add.w	r4, r7, #0x10
 8003eaa: 4602         	mov	r2, r0
 8003eac: 460b         	mov	r3, r1
 8003eae: 4620         	mov	r0, r4
 8003eb0: f00e ffb0    	bl	0x8012e14 <k_sem_take>  @ imm = #0xef60
; 		return ctx.status;
 8003eb4: 6a3b         	ldr	r3, [r7, #0x20]
 8003eb6: e00b         	b	0x8003ed0 <z_impl_can_send+0x134> @ imm = #0x16
; 	return api->send(dev, frame, timeout, callback, user_data);
 8003eb8: 6afb         	ldr	r3, [r7, #0x2c]
 8003eba: 695c         	ldr	r4, [r3, #0x14]
 8003ebc: 6cfb         	ldr	r3, [r7, #0x4c]
 8003ebe: 9301         	str	r3, [sp, #0x4]
 8003ec0: 6cbb         	ldr	r3, [r7, #0x48]
 8003ec2: 9300         	str	r3, [sp]
 8003ec4: e9d7 2300    	ldrd	r2, r3, [r7]
 8003ec8: 68b9         	ldr	r1, [r7, #0x8]
 8003eca: 68f8         	ldr	r0, [r7, #0xc]
 8003ecc: 47a0         	blx	r4
 8003ece: 4603         	mov	r3, r0
; }
 8003ed0: 4618         	mov	r0, r3
 8003ed2: 373c         	adds	r7, #0x3c
 8003ed4: 46bd         	mov	sp, r7
 8003ed6: bd90         	pop	{r4, r7, pc}

08003ed8 <$d>:
 8003ed8: 50 04 00 20  	.word	0x20000450
 8003edc: 5c ba 01 08  	.word	0x0801ba5c
 8003ee0: 68 ba 01 08  	.word	0x0801ba68
 8003ee4: 74 ba 01 08  	.word	0x0801ba74
 8003ee8: 2f 2f 01 08  	.word	0x08012f2f

08003eec <can_add_rx_filter>:
; {
 8003eec: b5f0         	push	{r4, r5, r6, r7, lr}
 8003eee: b093         	sub	sp, #0x4c
 8003ef0: af0a         	add	r7, sp, #0x28
 8003ef2: 60f8         	str	r0, [r7, #0xc]
 8003ef4: 60b9         	str	r1, [r7, #0x8]
 8003ef6: 607a         	str	r2, [r7, #0x4]
 8003ef8: 603b         	str	r3, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8003efa: 68fb         	ldr	r3, [r7, #0xc]
 8003efc: 689b         	ldr	r3, [r3, #0x8]
 8003efe: 613b         	str	r3, [r7, #0x10]
; 	CHECKIF(callback == NULL || filter == NULL) {
 8003f00: 68bb         	ldr	r3, [r7, #0x8]
 8003f02: 2b00         	cmp	r3, #0x0
 8003f04: d002         	beq	0x8003f0c <can_add_rx_filter+0x20> @ imm = #0x4
 8003f06: 683b         	ldr	r3, [r7]
 8003f08: 2b00         	cmp	r3, #0x0
 8003f0a: d102         	bne	0x8003f12 <can_add_rx_filter+0x26> @ imm = #0x4
; 		return -EINVAL;
 8003f0c: f06f 0315    	mvn	r3, #0x15
 8003f10: e06e         	b	0x8003ff0 <can_add_rx_filter+0x104> @ imm = #0xdc
; 	if ((filter->flags & CAN_FILTER_IDE) != 0U) {
 8003f12: 683b         	ldr	r3, [r7]
 8003f14: 7a1b         	ldrb	r3, [r3, #0x8]
 8003f16: f003 0301    	and	r3, r3, #0x1
 8003f1a: 2b00         	cmp	r3, #0x0
 8003f1c: d003         	beq	0x8003f26 <can_add_rx_filter+0x3a> @ imm = #0x6
; 		id_mask = CAN_EXT_ID_MASK;
 8003f1e: f06f 4360    	mvn	r3, #0xe0000000
 8003f22: 617b         	str	r3, [r7, #0x14]
 8003f24: e002         	b	0x8003f2c <can_add_rx_filter+0x40> @ imm = #0x4
; 		id_mask = CAN_STD_ID_MASK;
 8003f26: f240 73ff    	movw	r3, #0x7ff
 8003f2a: 617b         	str	r3, [r7, #0x14]
; 	CHECKIF(((filter->id & ~(id_mask)) != 0U) || ((filter->mask & ~(id_mask)) != 0U)) {
 8003f2c: 683b         	ldr	r3, [r7]
 8003f2e: 681a         	ldr	r2, [r3]
 8003f30: 697b         	ldr	r3, [r7, #0x14]
 8003f32: 43db         	mvns	r3, r3
 8003f34: 4013         	ands	r3, r2
 8003f36: 2b00         	cmp	r3, #0x0
 8003f38: d106         	bne	0x8003f48 <can_add_rx_filter+0x5c> @ imm = #0xc
 8003f3a: 683b         	ldr	r3, [r7]
 8003f3c: 685a         	ldr	r2, [r3, #0x4]
 8003f3e: 697b         	ldr	r3, [r7, #0x14]
 8003f40: 43db         	mvns	r3, r3
 8003f42: 4013         	ands	r3, r2
 8003f44: 2b00         	cmp	r3, #0x0
 8003f46: d04b         	beq	0x8003fe0 <can_add_rx_filter+0xf4> @ imm = #0x96
; 		LOG_ERR("invalid filter with %s (%d-bit) CAN ID 0x%0*x, CAN ID mask 0x%0*x",
 8003f48: 2303         	movs	r3, #0x3
 8003f4a: 2b00         	cmp	r3, #0x0
 8003f4c: d045         	beq	0x8003fda <can_add_rx_filter+0xee> @ imm = #0x8a
 8003f4e: 2301         	movs	r3, #0x1
 8003f50: 76fb         	strb	r3, [r7, #0x1b]
 8003f52: 7efb         	ldrb	r3, [r7, #0x1b]
 8003f54: f083 0301    	eor	r3, r3, #0x1
 8003f58: b2db         	uxtb	r3, r3
 8003f5a: 2b00         	cmp	r3, #0x0
 8003f5c: d13d         	bne	0x8003fda <can_add_rx_filter+0xee> @ imm = #0x7a
 8003f5e: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8003ff8 <can_add_rx_filter+0x10c>
 8003f60: 681e         	ldr	r6, [r3]
 8003f62: 683b         	ldr	r3, [r7]
 8003f64: 7a1b         	ldrb	r3, [r3, #0x8]
 8003f66: f003 0301    	and	r3, r3, #0x1
 8003f6a: 2b00         	cmp	r3, #0x0
 8003f6c: d001         	beq	0x8003f72 <can_add_rx_filter+0x86> @ imm = #0x2
 8003f6e: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8003ffc <can_add_rx_filter+0x110>
 8003f70: e000         	b	0x8003f74 <can_add_rx_filter+0x88> @ imm = #0x0
 8003f72: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8004000 <can_add_rx_filter+0x114>
 8003f74: 683a         	ldr	r2, [r7]
 8003f76: 7a12         	ldrb	r2, [r2, #0x8]
 8003f78: f002 0201    	and	r2, r2, #0x1
 8003f7c: 2a00         	cmp	r2, #0x0
 8003f7e: d001         	beq	0x8003f84 <can_add_rx_filter+0x98> @ imm = #0x2
 8003f80: 221d         	movs	r2, #0x1d
 8003f82: e000         	b	0x8003f86 <can_add_rx_filter+0x9a> @ imm = #0x0
 8003f84: 220b         	movs	r2, #0xb
 8003f86: 6839         	ldr	r1, [r7]
 8003f88: 7a09         	ldrb	r1, [r1, #0x8]
 8003f8a: f001 0101    	and	r1, r1, #0x1
 8003f8e: 2900         	cmp	r1, #0x0
 8003f90: d001         	beq	0x8003f96 <can_add_rx_filter+0xaa> @ imm = #0x2
 8003f92: 2108         	movs	r1, #0x8
 8003f94: e000         	b	0x8003f98 <can_add_rx_filter+0xac> @ imm = #0x0
 8003f96: 2103         	movs	r1, #0x3
 8003f98: 6838         	ldr	r0, [r7]
 8003f9a: 6800         	ldr	r0, [r0]
 8003f9c: 683c         	ldr	r4, [r7]
 8003f9e: 7a24         	ldrb	r4, [r4, #0x8]
 8003fa0: f004 0401    	and	r4, r4, #0x1
 8003fa4: 2c00         	cmp	r4, #0x0
 8003fa6: d001         	beq	0x8003fac <can_add_rx_filter+0xc0> @ imm = #0x2
 8003fa8: 2408         	movs	r4, #0x8
 8003faa: e000         	b	0x8003fae <can_add_rx_filter+0xc2> @ imm = #0x0
 8003fac: 2403         	movs	r4, #0x3
 8003fae: 683d         	ldr	r5, [r7]
 8003fb0: 686d         	ldr	r5, [r5, #0x4]
 8003fb2: 9508         	str	r5, [sp, #0x20]
 8003fb4: 9407         	str	r4, [sp, #0x1c]
 8003fb6: 9006         	str	r0, [sp, #0x18]
 8003fb8: 9105         	str	r1, [sp, #0x14]
 8003fba: 9204         	str	r2, [sp, #0x10]
 8003fbc: 9303         	str	r3, [sp, #0xc]
 8003fbe: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8004004 <can_add_rx_filter+0x118>
 8003fc0: 9302         	str	r3, [sp, #0x8]
 8003fc2: 2300         	movs	r3, #0x0
 8003fc4: 9301         	str	r3, [sp, #0x4]
 8003fc6: 2300         	movs	r3, #0x0
 8003fc8: 9300         	str	r3, [sp]
 8003fca: 2300         	movs	r3, #0x0
 8003fcc: 2201         	movs	r2, #0x1
 8003fce: 4631         	mov	r1, r6
 8003fd0: 2000         	movs	r0, #0x0
 8003fd2: f00e ff8e    	bl	0x8012ef2 <z_log_msg_runtime_create> @ imm = #0xef1c
 8003fd6: 2300         	movs	r3, #0x0
 8003fd8: 61fb         	str	r3, [r7, #0x1c]
; 		return -EINVAL;
 8003fda: f06f 0315    	mvn	r3, #0x15
 8003fde: e007         	b	0x8003ff0 <can_add_rx_filter+0x104> @ imm = #0xe
; 	return api->add_rx_filter(dev, callback, user_data, filter);
 8003fe0: 693b         	ldr	r3, [r7, #0x10]
 8003fe2: 699c         	ldr	r4, [r3, #0x18]
 8003fe4: 683b         	ldr	r3, [r7]
 8003fe6: 687a         	ldr	r2, [r7, #0x4]
 8003fe8: 68b9         	ldr	r1, [r7, #0x8]
 8003fea: 68f8         	ldr	r0, [r7, #0xc]
 8003fec: 47a0         	blx	r4
 8003fee: 4603         	mov	r3, r0
; }
 8003ff0: 4618         	mov	r0, r3
 8003ff2: 3724         	adds	r7, #0x24
 8003ff4: 46bd         	mov	sp, r7
 8003ff6: bdf0         	pop	{r4, r5, r6, r7, pc}

08003ff8 <$d>:
 8003ff8: 50 04 00 20  	.word	0x20000450
 8003ffc: 5c ba 01 08  	.word	0x0801ba5c
 8004000: 68 ba 01 08  	.word	0x0801ba68
 8004004: a4 ba 01 08  	.word	0x0801baa4

08004008 <update_sample_pnt>:
; {
 8004008: b480         	push	{r7}
 800400a: b089         	sub	sp, #0x24
 800400c: af00         	add	r7, sp, #0x0
 800400e: 60f8         	str	r0, [r7, #0xc]
 8004010: 60b9         	str	r1, [r7, #0x8]
 8004012: 607a         	str	r2, [r7, #0x4]
 8004014: 603b         	str	r3, [r7]
; 	uint16_t tseg1_max = max->phase_seg1 + max->prop_seg;
 8004016: 6abb         	ldr	r3, [r7, #0x28]
 8004018: 889a         	ldrh	r2, [r3, #0x4]
 800401a: 6abb         	ldr	r3, [r7, #0x28]
 800401c: 885b         	ldrh	r3, [r3, #0x2]
 800401e: 4413         	add	r3, r2
 8004020: 837b         	strh	r3, [r7, #0x1a]
; 	uint16_t tseg1_min = min->phase_seg1 + min->prop_seg;
 8004022: 683b         	ldr	r3, [r7]
 8004024: 889a         	ldrh	r2, [r3, #0x4]
 8004026: 683b         	ldr	r3, [r7]
 8004028: 885b         	ldrh	r3, [r3, #0x2]
 800402a: 4413         	add	r3, r2
 800402c: 833b         	strh	r3, [r7, #0x18]
; 	tseg2 = total_tq - (total_tq * sample_pnt) / 1000;
 800402e: 68fb         	ldr	r3, [r7, #0xc]
 8004030: b29a         	uxth	r2, r3
 8004032: 68fb         	ldr	r3, [r7, #0xc]
 8004034: 68b9         	ldr	r1, [r7, #0x8]
 8004036: fb01 f303    	mul	r3, r1, r3
 800403a: 4952         	ldr	r1, [pc, #0x148]        @ 0x8004184 <update_sample_pnt+0x17c>
 800403c: fba1 1303    	umull	r1, r3, r1, r3
 8004040: 099b         	lsrs	r3, r3, #0x6
 8004042: b29b         	uxth	r3, r3
 8004044: 1ad3         	subs	r3, r2, r3
 8004046: 83bb         	strh	r3, [r7, #0x1c]
; 	tseg2 = CLAMP(tseg2, min->phase_seg2, max->phase_seg2);
 8004048: 683b         	ldr	r3, [r7]
 800404a: 88db         	ldrh	r3, [r3, #0x6]
 800404c: 8bba         	ldrh	r2, [r7, #0x1c]
 800404e: 429a         	cmp	r2, r3
 8004050: d802         	bhi	0x8004058 <update_sample_pnt+0x50> @ imm = #0x4
 8004052: 683b         	ldr	r3, [r7]
 8004054: 88db         	ldrh	r3, [r3, #0x6]
 8004056: e006         	b	0x8004066 <update_sample_pnt+0x5e> @ imm = #0xc
 8004058: 6abb         	ldr	r3, [r7, #0x28]
 800405a: 88db         	ldrh	r3, [r3, #0x6]
 800405c: 8bba         	ldrh	r2, [r7, #0x1c]
 800405e: 4293         	cmp	r3, r2
 8004060: bf28         	it	hs
 8004062: 4613         	movhs	r3, r2
 8004064: b29b         	uxth	r3, r3
 8004066: 83bb         	strh	r3, [r7, #0x1c]
; 	tseg1 = total_tq - CAN_SYNC_SEG - tseg2;
 8004068: 68fb         	ldr	r3, [r7, #0xc]
 800406a: b29a         	uxth	r2, r3
 800406c: 8bbb         	ldrh	r3, [r7, #0x1c]
 800406e: 1ad3         	subs	r3, r2, r3
 8004070: b29b         	uxth	r3, r3
 8004072: 3b01         	subs	r3, #0x1
 8004074: 83fb         	strh	r3, [r7, #0x1e]
; 	if (tseg1 > tseg1_max) {
 8004076: 8bfa         	ldrh	r2, [r7, #0x1e]
 8004078: 8b7b         	ldrh	r3, [r7, #0x1a]
 800407a: 429a         	cmp	r2, r3
 800407c: d910         	bls	0x80040a0 <update_sample_pnt+0x98> @ imm = #0x20
; 		tseg1 = tseg1_max;
 800407e: 8b7b         	ldrh	r3, [r7, #0x1a]
 8004080: 83fb         	strh	r3, [r7, #0x1e]
; 		tseg2 = total_tq - CAN_SYNC_SEG - tseg1;
 8004082: 68fb         	ldr	r3, [r7, #0xc]
 8004084: b29a         	uxth	r2, r3
 8004086: 8bfb         	ldrh	r3, [r7, #0x1e]
 8004088: 1ad3         	subs	r3, r2, r3
 800408a: b29b         	uxth	r3, r3
 800408c: 3b01         	subs	r3, #0x1
 800408e: 83bb         	strh	r3, [r7, #0x1c]
; 		if (tseg2 > max->phase_seg2) {
 8004090: 6abb         	ldr	r3, [r7, #0x28]
 8004092: 88db         	ldrh	r3, [r3, #0x6]
 8004094: 8bba         	ldrh	r2, [r7, #0x1c]
 8004096: 429a         	cmp	r2, r3
 8004098: d917         	bls	0x80040ca <update_sample_pnt+0xc2> @ imm = #0x2e
; 			return -ENOTSUP;
 800409a: f06f 0385    	mvn	r3, #0x85
 800409e: e06c         	b	0x800417a <update_sample_pnt+0x172> @ imm = #0xd8
; 	} else if (tseg1 < tseg1_min) {
 80040a0: 8bfa         	ldrh	r2, [r7, #0x1e]
 80040a2: 8b3b         	ldrh	r3, [r7, #0x18]
 80040a4: 429a         	cmp	r2, r3
 80040a6: d210         	bhs	0x80040ca <update_sample_pnt+0xc2> @ imm = #0x20
; 		tseg1 = tseg1_min;
 80040a8: 8b3b         	ldrh	r3, [r7, #0x18]
 80040aa: 83fb         	strh	r3, [r7, #0x1e]
; 		tseg2 = total_tq - CAN_SYNC_SEG - tseg1;
 80040ac: 68fb         	ldr	r3, [r7, #0xc]
 80040ae: b29a         	uxth	r2, r3
 80040b0: 8bfb         	ldrh	r3, [r7, #0x1e]
 80040b2: 1ad3         	subs	r3, r2, r3
 80040b4: b29b         	uxth	r3, r3
 80040b6: 3b01         	subs	r3, #0x1
 80040b8: 83bb         	strh	r3, [r7, #0x1c]
; 		if (tseg2 < min->phase_seg2) {
 80040ba: 683b         	ldr	r3, [r7]
 80040bc: 88db         	ldrh	r3, [r3, #0x6]
 80040be: 8bba         	ldrh	r2, [r7, #0x1c]
 80040c0: 429a         	cmp	r2, r3
 80040c2: d202         	bhs	0x80040ca <update_sample_pnt+0xc2> @ imm = #0x4
; 			return -ENOTSUP;
 80040c4: f06f 0385    	mvn	r3, #0x85
 80040c8: e057         	b	0x800417a <update_sample_pnt+0x172> @ imm = #0xae
; 	res->phase_seg2 = tseg2;
 80040ca: 687b         	ldr	r3, [r7, #0x4]
 80040cc: 8bba         	ldrh	r2, [r7, #0x1c]
 80040ce: 80da         	strh	r2, [r3, #0x6]
; 	res->prop_seg = CLAMP(tseg1 / 2, min->prop_seg, max->prop_seg);
 80040d0: 8bfb         	ldrh	r3, [r7, #0x1e]
 80040d2: 085b         	lsrs	r3, r3, #0x1
 80040d4: b29a         	uxth	r2, r3
 80040d6: 683b         	ldr	r3, [r7]
 80040d8: 885b         	ldrh	r3, [r3, #0x2]
 80040da: 429a         	cmp	r2, r3
 80040dc: d802         	bhi	0x80040e4 <update_sample_pnt+0xdc> @ imm = #0x4
 80040de: 683b         	ldr	r3, [r7]
 80040e0: 885b         	ldrh	r3, [r3, #0x2]
 80040e2: e008         	b	0x80040f6 <update_sample_pnt+0xee> @ imm = #0x10
 80040e4: 6abb         	ldr	r3, [r7, #0x28]
 80040e6: 885a         	ldrh	r2, [r3, #0x2]
 80040e8: 8bfb         	ldrh	r3, [r7, #0x1e]
 80040ea: 085b         	lsrs	r3, r3, #0x1
 80040ec: b29b         	uxth	r3, r3
 80040ee: 4293         	cmp	r3, r2
 80040f0: bf28         	it	hs
 80040f2: 4613         	movhs	r3, r2
 80040f4: b29b         	uxth	r3, r3
 80040f6: 687a         	ldr	r2, [r7, #0x4]
 80040f8: 8053         	strh	r3, [r2, #0x2]
; 	res->phase_seg1 = tseg1 - res->prop_seg;
 80040fa: 687b         	ldr	r3, [r7, #0x4]
 80040fc: 885b         	ldrh	r3, [r3, #0x2]
 80040fe: 8bfa         	ldrh	r2, [r7, #0x1e]
 8004100: 1ad3         	subs	r3, r2, r3
 8004102: b29a         	uxth	r2, r3
 8004104: 687b         	ldr	r3, [r7, #0x4]
 8004106: 809a         	strh	r2, [r3, #0x4]
; 	if (res->phase_seg1 > max->phase_seg1) {
 8004108: 687b         	ldr	r3, [r7, #0x4]
 800410a: 889a         	ldrh	r2, [r3, #0x4]
 800410c: 6abb         	ldr	r3, [r7, #0x28]
 800410e: 889b         	ldrh	r3, [r3, #0x4]
 8004110: 429a         	cmp	r2, r3
 8004112: d90b         	bls	0x800412c <update_sample_pnt+0x124> @ imm = #0x16
; 		res->phase_seg1 = max->phase_seg1;
 8004114: 6abb         	ldr	r3, [r7, #0x28]
 8004116: 889a         	ldrh	r2, [r3, #0x4]
 8004118: 687b         	ldr	r3, [r7, #0x4]
 800411a: 809a         	strh	r2, [r3, #0x4]
; 		res->prop_seg = tseg1 - res->phase_seg1;
 800411c: 687b         	ldr	r3, [r7, #0x4]
 800411e: 889b         	ldrh	r3, [r3, #0x4]
 8004120: 8bfa         	ldrh	r2, [r7, #0x1e]
 8004122: 1ad3         	subs	r3, r2, r3
 8004124: b29a         	uxth	r2, r3
 8004126: 687b         	ldr	r3, [r7, #0x4]
 8004128: 805a         	strh	r2, [r3, #0x2]
 800412a: e010         	b	0x800414e <update_sample_pnt+0x146> @ imm = #0x20
; 	} else if (res->phase_seg1 < min->phase_seg1) {
 800412c: 687b         	ldr	r3, [r7, #0x4]
 800412e: 889a         	ldrh	r2, [r3, #0x4]
 8004130: 683b         	ldr	r3, [r7]
 8004132: 889b         	ldrh	r3, [r3, #0x4]
 8004134: 429a         	cmp	r2, r3
 8004136: d20a         	bhs	0x800414e <update_sample_pnt+0x146> @ imm = #0x14
; 		res->phase_seg1 = min->phase_seg1;
 8004138: 683b         	ldr	r3, [r7]
 800413a: 889a         	ldrh	r2, [r3, #0x4]
 800413c: 687b         	ldr	r3, [r7, #0x4]
 800413e: 809a         	strh	r2, [r3, #0x4]
; 		res->prop_seg = tseg1 - res->phase_seg1;
 8004140: 687b         	ldr	r3, [r7, #0x4]
 8004142: 889b         	ldrh	r3, [r3, #0x4]
 8004144: 8bfa         	ldrh	r2, [r7, #0x1e]
 8004146: 1ad3         	subs	r3, r2, r3
 8004148: b29a         	uxth	r2, r3
 800414a: 687b         	ldr	r3, [r7, #0x4]
 800414c: 805a         	strh	r2, [r3, #0x2]
; 	sample_pnt_res = (CAN_SYNC_SEG + tseg1) * 1000 / total_tq;
 800414e: 8bfb         	ldrh	r3, [r7, #0x1e]
 8004150: 3301         	adds	r3, #0x1
 8004152: f44f 727a    	mov.w	r2, #0x3e8
 8004156: fb02 f303    	mul	r3, r2, r3
 800415a: 461a         	mov	r2, r3
 800415c: 68fb         	ldr	r3, [r7, #0xc]
 800415e: fbb2 f3f3    	udiv	r3, r2, r3
 8004162: 617b         	str	r3, [r7, #0x14]
; 		sample_pnt_res - sample_pnt :
 8004164: 697a         	ldr	r2, [r7, #0x14]
 8004166: 68bb         	ldr	r3, [r7, #0x8]
 8004168: 429a         	cmp	r2, r3
 800416a: d903         	bls	0x8004174 <update_sample_pnt+0x16c> @ imm = #0x6
 800416c: 697a         	ldr	r2, [r7, #0x14]
 800416e: 68bb         	ldr	r3, [r7, #0x8]
 8004170: 1ad3         	subs	r3, r2, r3
 8004172: e002         	b	0x800417a <update_sample_pnt+0x172> @ imm = #0x4
; 		sample_pnt - sample_pnt_res;
 8004174: 68ba         	ldr	r2, [r7, #0x8]
 8004176: 697b         	ldr	r3, [r7, #0x14]
 8004178: 1ad3         	subs	r3, r2, r3
; }
 800417a: 4618         	mov	r0, r3
 800417c: 3724         	adds	r7, #0x24
 800417e: 46bd         	mov	sp, r7
 8004180: bc80         	pop	{r7}
 8004182: 4770         	bx	lr

08004184 <$d>:
 8004184: d3 4d 62 10  	.word	0x10624dd3

08004188 <sample_point_for_bitrate>:
; {
 8004188: b480         	push	{r7}
 800418a: b085         	sub	sp, #0x14
 800418c: af00         	add	r7, sp, #0x0
 800418e: 6078         	str	r0, [r7, #0x4]
; 	if (bitrate > 800000) {
 8004190: 687b         	ldr	r3, [r7, #0x4]
 8004192: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80041c4 <sample_point_for_bitrate+0x3c>
 8004194: 4293         	cmp	r3, r2
 8004196: d903         	bls	0x80041a0 <sample_point_for_bitrate+0x18> @ imm = #0x6
; 		sample_pnt = 750;
 8004198: f240 23ee    	movw	r3, #0x2ee
 800419c: 81fb         	strh	r3, [r7, #0xe]
 800419e: e00a         	b	0x80041b6 <sample_point_for_bitrate+0x2e> @ imm = #0x14
; 	} else if (bitrate > 500000) {
 80041a0: 687b         	ldr	r3, [r7, #0x4]
 80041a2: 4a09         	ldr	r2, [pc, #0x24]         @ 0x80041c8 <sample_point_for_bitrate+0x40>
 80041a4: 4293         	cmp	r3, r2
 80041a6: d903         	bls	0x80041b0 <sample_point_for_bitrate+0x28> @ imm = #0x6
; 		sample_pnt = 800;
 80041a8: f44f 7348    	mov.w	r3, #0x320
 80041ac: 81fb         	strh	r3, [r7, #0xe]
 80041ae: e002         	b	0x80041b6 <sample_point_for_bitrate+0x2e> @ imm = #0x4
; 		sample_pnt = 875;
 80041b0: f240 336b    	movw	r3, #0x36b
 80041b4: 81fb         	strh	r3, [r7, #0xe]
; 	return sample_pnt;
 80041b6: 89fb         	ldrh	r3, [r7, #0xe]
; }
 80041b8: 4618         	mov	r0, r3
 80041ba: 3714         	adds	r7, #0x14
 80041bc: 46bd         	mov	sp, r7
 80041be: bc80         	pop	{r7}
 80041c0: 4770         	bx	lr
 80041c2: bf00         	nop

080041c4 <$d>:
 80041c4: 00 35 0c 00  	.word	0x000c3500
 80041c8: 20 a1 07 00  	.word	0x0007a120

080041cc <can_calc_timing_internal>:
; {
 80041cc: b580         	push	{r7, lr}
 80041ce: b094         	sub	sp, #0x50
 80041d0: af06         	add	r7, sp, #0x18
 80041d2: 60f8         	str	r0, [r7, #0xc]
 80041d4: 60b9         	str	r1, [r7, #0x8]
 80041d6: 607a         	str	r2, [r7, #0x4]
 80041d8: 603b         	str	r3, [r7]
; 	uint32_t total_tq = CAN_SYNC_SEG + max->prop_seg + max->phase_seg1 + max->phase_seg2;
 80041da: 683b         	ldr	r3, [r7]
 80041dc: 885b         	ldrh	r3, [r3, #0x2]
 80041de: 3301         	adds	r3, #0x1
 80041e0: 683a         	ldr	r2, [r7]
 80041e2: 8892         	ldrh	r2, [r2, #0x4]
 80041e4: 4413         	add	r3, r2
 80041e6: 683a         	ldr	r2, [r7]
 80041e8: 88d2         	ldrh	r2, [r2, #0x6]
 80041ea: 4413         	add	r3, r2
 80041ec: 62fb         	str	r3, [r7, #0x2c]
; 	struct can_timing tmp_res = { 0 };
 80041ee: f107 0314    	add.w	r3, r7, #0x14
 80041f2: 2200         	movs	r2, #0x0
 80041f4: 601a         	str	r2, [r3]
 80041f6: 605a         	str	r2, [r3, #0x4]
 80041f8: 811a         	strh	r2, [r3, #0x8]
; 	int err_min = INT_MAX;
 80041fa: f06f 4300    	mvn	r3, #0x80000000
 80041fe: 637b         	str	r3, [r7, #0x34]
; 	if (bitrate == 0 || sample_pnt >= 1000) {
 8004200: 6c3b         	ldr	r3, [r7, #0x40]
 8004202: 2b00         	cmp	r3, #0x0
 8004204: d004         	beq	0x8004210 <can_calc_timing_internal+0x44> @ imm = #0x8
 8004206: f8b7 3044    	ldrh.w	r3, [r7, #0x44]
 800420a: f5b3 7f7a    	cmp.w	r3, #0x3e8
 800420e: d302         	blo	0x8004216 <can_calc_timing_internal+0x4a> @ imm = #0x4
; 		return -EINVAL;
 8004210: f06f 0315    	mvn	r3, #0x15
 8004214: e0b7         	b	0x8004386 <can_calc_timing_internal+0x1ba> @ imm = #0x16e
; 	err = can_get_core_clock(dev, &core_clock);
 8004216: f107 0310    	add.w	r3, r7, #0x10
 800421a: 4619         	mov	r1, r3
 800421c: 68f8         	ldr	r0, [r7, #0xc]
 800421e: f00e fe42    	bl	0x8012ea6 <can_get_core_clock> @ imm = #0xec84
 8004222: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 8004224: 6abb         	ldr	r3, [r7, #0x28]
 8004226: 2b00         	cmp	r3, #0x0
 8004228: d002         	beq	0x8004230 <can_calc_timing_internal+0x64> @ imm = #0x4
; 		return -EIO;
 800422a: f06f 0304    	mvn	r3, #0x4
 800422e: e0aa         	b	0x8004386 <can_calc_timing_internal+0x1ba> @ imm = #0x154
; 	if (sample_pnt == 0U) {
 8004230: f8b7 3044    	ldrh.w	r3, [r7, #0x44]
 8004234: 2b00         	cmp	r3, #0x0
 8004236: d105         	bne	0x8004244 <can_calc_timing_internal+0x78> @ imm = #0xa
; 		sample_pnt = sample_point_for_bitrate(bitrate);
 8004238: 6c38         	ldr	r0, [r7, #0x40]
 800423a: f7ff ffa5    	bl	0x8004188 <sample_point_for_bitrate> @ imm = #-0xb6
 800423e: 4603         	mov	r3, r0
 8004240: f8a7 3044    	strh.w	r3, [r7, #0x44]
; 	for (prescaler = MAX(core_clock / (total_tq * bitrate), min->prescaler);
 8004244: 687b         	ldr	r3, [r7, #0x4]
 8004246: 891b         	ldrh	r3, [r3, #0x8]
 8004248: 4618         	mov	r0, r3
 800424a: 693a         	ldr	r2, [r7, #0x10]
 800424c: 6afb         	ldr	r3, [r7, #0x2c]
 800424e: 6c39         	ldr	r1, [r7, #0x40]
 8004250: fb01 f303    	mul	r3, r1, r3
 8004254: fbb2 f3f3    	udiv	r3, r2, r3
 8004258: 4283         	cmp	r3, r0
 800425a: bf38         	it	lo
 800425c: 4603         	movlo	r3, r0
 800425e: 633b         	str	r3, [r7, #0x30]
 8004260: e03e         	b	0x80042e0 <can_calc_timing_internal+0x114> @ imm = #0x7c
; 		if (core_clock % (prescaler * bitrate)) {
 8004262: 693b         	ldr	r3, [r7, #0x10]
 8004264: 6b3a         	ldr	r2, [r7, #0x30]
 8004266: 6c39         	ldr	r1, [r7, #0x40]
 8004268: fb01 f202    	mul	r2, r1, r2
 800426c: fbb3 f1f2    	udiv	r1, r3, r2
 8004270: fb01 f202    	mul	r2, r1, r2
 8004274: 1a9b         	subs	r3, r3, r2
 8004276: 2b00         	cmp	r3, #0x0
 8004278: d12c         	bne	0x80042d4 <can_calc_timing_internal+0x108> @ imm = #0x58
; 		total_tq = core_clock / (prescaler * bitrate);
 800427a: 693a         	ldr	r2, [r7, #0x10]
 800427c: 6b3b         	ldr	r3, [r7, #0x30]
 800427e: 6c39         	ldr	r1, [r7, #0x40]
 8004280: fb01 f303    	mul	r3, r1, r3
 8004284: fbb2 f3f3    	udiv	r3, r2, r3
 8004288: 62fb         	str	r3, [r7, #0x2c]
; 		err = update_sample_pnt(total_tq, sample_pnt, &tmp_res, min, max);
 800428a: f8b7 1044    	ldrh.w	r1, [r7, #0x44]
 800428e: f107 0214    	add.w	r2, r7, #0x14
 8004292: 683b         	ldr	r3, [r7]
 8004294: 9300         	str	r3, [sp]
 8004296: 687b         	ldr	r3, [r7, #0x4]
 8004298: 6af8         	ldr	r0, [r7, #0x2c]
 800429a: f7ff feb5    	bl	0x8004008 <update_sample_pnt> @ imm = #-0x296
 800429e: 62b8         	str	r0, [r7, #0x28]
; 		if (err < 0) {
 80042a0: 6abb         	ldr	r3, [r7, #0x28]
 80042a2: 2b00         	cmp	r3, #0x0
 80042a4: db18         	blt	0x80042d8 <can_calc_timing_internal+0x10c> @ imm = #0x30
; 		if (err < err_min) {
 80042a6: 6aba         	ldr	r2, [r7, #0x28]
 80042a8: 6b7b         	ldr	r3, [r7, #0x34]
 80042aa: 429a         	cmp	r2, r3
 80042ac: da15         	bge	0x80042da <can_calc_timing_internal+0x10e> @ imm = #0x2a
; 			err_min = err;
 80042ae: 6abb         	ldr	r3, [r7, #0x28]
 80042b0: 637b         	str	r3, [r7, #0x34]
; 			res->prop_seg = tmp_res.prop_seg;
 80042b2: 8afa         	ldrh	r2, [r7, #0x16]
 80042b4: 68bb         	ldr	r3, [r7, #0x8]
 80042b6: 805a         	strh	r2, [r3, #0x2]
; 			res->phase_seg1 = tmp_res.phase_seg1;
 80042b8: 8b3a         	ldrh	r2, [r7, #0x18]
 80042ba: 68bb         	ldr	r3, [r7, #0x8]
 80042bc: 809a         	strh	r2, [r3, #0x4]
; 			res->phase_seg2 = tmp_res.phase_seg2;
 80042be: 8b7a         	ldrh	r2, [r7, #0x1a]
 80042c0: 68bb         	ldr	r3, [r7, #0x8]
 80042c2: 80da         	strh	r2, [r3, #0x6]
; 			res->prescaler = (uint16_t)prescaler;
 80042c4: 6b3b         	ldr	r3, [r7, #0x30]
 80042c6: b29a         	uxth	r2, r3
 80042c8: 68bb         	ldr	r3, [r7, #0x8]
 80042ca: 811a         	strh	r2, [r3, #0x8]
; 			if (err == 0) {
 80042cc: 6abb         	ldr	r3, [r7, #0x28]
 80042ce: 2b00         	cmp	r3, #0x0
 80042d0: d00d         	beq	0x80042ee <can_calc_timing_internal+0x122> @ imm = #0x1a
 80042d2: e002         	b	0x80042da <can_calc_timing_internal+0x10e> @ imm = #0x4
; 			continue;
 80042d4: bf00         	nop
 80042d6: e000         	b	0x80042da <can_calc_timing_internal+0x10e> @ imm = #0x0
; 			continue;
 80042d8: bf00         	nop
; 	     prescaler++) {
 80042da: 6b3b         	ldr	r3, [r7, #0x30]
 80042dc: 3301         	adds	r3, #0x1
 80042de: 633b         	str	r3, [r7, #0x30]
; 	     prescaler <= max->prescaler;
 80042e0: 683b         	ldr	r3, [r7]
 80042e2: 891b         	ldrh	r3, [r3, #0x8]
 80042e4: 461a         	mov	r2, r3
 80042e6: 6b3b         	ldr	r3, [r7, #0x30]
 80042e8: 4293         	cmp	r3, r2
 80042ea: ddba         	ble	0x8004262 <can_calc_timing_internal+0x96> @ imm = #-0x8c
 80042ec: e000         	b	0x80042f0 <can_calc_timing_internal+0x124> @ imm = #0x0
; 				break;
 80042ee: bf00         	nop
; 	if (err_min != 0U) {
 80042f0: 6b7b         	ldr	r3, [r7, #0x34]
 80042f2: 2b00         	cmp	r3, #0x0
 80042f4: d01f         	beq	0x8004336 <can_calc_timing_internal+0x16a> @ imm = #0x3e
; 		LOG_DBG("Sample point error: %d 1/1000", err_min);
 80042f6: 2303         	movs	r3, #0x3
 80042f8: 2b03         	cmp	r3, #0x3
 80042fa: d91c         	bls	0x8004336 <can_calc_timing_internal+0x16a> @ imm = #0x38
 80042fc: 2301         	movs	r3, #0x1
 80042fe: f887 3027    	strb.w	r3, [r7, #0x27]
 8004302: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8004306: f083 0301    	eor	r3, r3, #0x1
 800430a: b2db         	uxtb	r3, r3
 800430c: 2b00         	cmp	r3, #0x0
 800430e: d112         	bne	0x8004336 <can_calc_timing_internal+0x16a> @ imm = #0x24
 8004310: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8004390 <can_calc_timing_internal+0x1c4>
 8004312: 6819         	ldr	r1, [r3]
 8004314: 6b7b         	ldr	r3, [r7, #0x34]
 8004316: 9304         	str	r3, [sp, #0x10]
 8004318: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8004394 <can_calc_timing_internal+0x1c8>
 800431a: 9303         	str	r3, [sp, #0xc]
 800431c: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8004398 <can_calc_timing_internal+0x1cc>
 800431e: 9302         	str	r3, [sp, #0x8]
 8004320: 2308         	movs	r3, #0x8
 8004322: 9301         	str	r3, [sp, #0x4]
 8004324: 2300         	movs	r3, #0x0
 8004326: 9300         	str	r3, [sp]
 8004328: 2300         	movs	r3, #0x0
 800432a: 2204         	movs	r2, #0x4
 800432c: 2000         	movs	r0, #0x0
 800432e: f00e fde0    	bl	0x8012ef2 <z_log_msg_runtime_create> @ imm = #0xebc0
 8004332: 2300         	movs	r3, #0x0
 8004334: 623b         	str	r3, [r7, #0x20]
; 	res->sjw = MIN(res->phase_seg1, res->phase_seg2 / 2);
 8004336: 68bb         	ldr	r3, [r7, #0x8]
 8004338: 88db         	ldrh	r3, [r3, #0x6]
 800433a: 085b         	lsrs	r3, r3, #0x1
 800433c: b29a         	uxth	r2, r3
 800433e: 68bb         	ldr	r3, [r7, #0x8]
 8004340: 889b         	ldrh	r3, [r3, #0x4]
 8004342: 4293         	cmp	r3, r2
 8004344: bf28         	it	hs
 8004346: 4613         	movhs	r3, r2
 8004348: b29a         	uxth	r2, r3
 800434a: 68bb         	ldr	r3, [r7, #0x8]
 800434c: 801a         	strh	r2, [r3]
; 	res->sjw = CLAMP(res->sjw, min->sjw, max->sjw);
 800434e: 68bb         	ldr	r3, [r7, #0x8]
 8004350: 881a         	ldrh	r2, [r3]
 8004352: 687b         	ldr	r3, [r7, #0x4]
 8004354: 881b         	ldrh	r3, [r3]
 8004356: 429a         	cmp	r2, r3
 8004358: d802         	bhi	0x8004360 <can_calc_timing_internal+0x194> @ imm = #0x4
 800435a: 687b         	ldr	r3, [r7, #0x4]
 800435c: 881b         	ldrh	r3, [r3]
 800435e: e007         	b	0x8004370 <can_calc_timing_internal+0x1a4> @ imm = #0xe
 8004360: 683b         	ldr	r3, [r7]
 8004362: 881a         	ldrh	r2, [r3]
 8004364: 68bb         	ldr	r3, [r7, #0x8]
 8004366: 881b         	ldrh	r3, [r3]
 8004368: 4293         	cmp	r3, r2
 800436a: bf28         	it	hs
 800436c: 4613         	movhs	r3, r2
 800436e: b29b         	uxth	r3, r3
 8004370: 68ba         	ldr	r2, [r7, #0x8]
 8004372: 8013         	strh	r3, [r2]
; 	return err_min == INT_MAX ? -ENOTSUP : err_min;
 8004374: 6b7b         	ldr	r3, [r7, #0x34]
 8004376: f06f 4200    	mvn	r2, #0x80000000
 800437a: 4293         	cmp	r3, r2
 800437c: d001         	beq	0x8004382 <can_calc_timing_internal+0x1b6> @ imm = #0x2
 800437e: 6b7b         	ldr	r3, [r7, #0x34]
 8004380: e001         	b	0x8004386 <can_calc_timing_internal+0x1ba> @ imm = #0x2
 8004382: f06f 0385    	mvn	r3, #0x85
; }
 8004386: 4618         	mov	r0, r3
 8004388: 3738         	adds	r7, #0x38
 800438a: 46bd         	mov	sp, r7
 800438c: bd80         	pop	{r7, pc}
 800438e: bf00         	nop

08004390 <$d>:
 8004390: 50 04 00 20  	.word	0x20000450
 8004394: 88 d0 01 08  	.word	0x0801d088
 8004398: 0c bb 01 08  	.word	0x0801bb0c

0800439c <z_impl_can_calc_timing>:
; {
 800439c: b580         	push	{r7, lr}
 800439e: b088         	sub	sp, #0x20
 80043a0: af02         	add	r7, sp, #0x8
 80043a2: 60f8         	str	r0, [r7, #0xc]
 80043a4: 60b9         	str	r1, [r7, #0x8]
 80043a6: 607a         	str	r2, [r7, #0x4]
 80043a8: 807b         	strh	r3, [r7, #0x2]
; 	const struct can_timing *min = can_get_timing_min(dev);
 80043aa: 68f8         	ldr	r0, [r7, #0xc]
 80043ac: f00e fd89    	bl	0x8012ec2 <can_get_timing_min> @ imm = #0xeb12
 80043b0: 6178         	str	r0, [r7, #0x14]
; 	const struct can_timing *max = can_get_timing_max(dev);
 80043b2: 68f8         	ldr	r0, [r7, #0xc]
 80043b4: f00e fd91    	bl	0x8012eda <can_get_timing_max> @ imm = #0xeb22
 80043b8: 6138         	str	r0, [r7, #0x10]
; 	if (bitrate > 1000000) {
 80043ba: 687b         	ldr	r3, [r7, #0x4]
 80043bc: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80043e8 <z_impl_can_calc_timing+0x4c>
 80043be: 4293         	cmp	r3, r2
 80043c0: d902         	bls	0x80043c8 <z_impl_can_calc_timing+0x2c> @ imm = #0x4
; 		return -EINVAL;
 80043c2: f06f 0315    	mvn	r3, #0x15
 80043c6: e00a         	b	0x80043de <z_impl_can_calc_timing+0x42> @ imm = #0x14
; 	return can_calc_timing_internal(dev, res, min, max, bitrate, sample_pnt);
 80043c8: 887b         	ldrh	r3, [r7, #0x2]
 80043ca: 9301         	str	r3, [sp, #0x4]
 80043cc: 687b         	ldr	r3, [r7, #0x4]
 80043ce: 9300         	str	r3, [sp]
 80043d0: 693b         	ldr	r3, [r7, #0x10]
 80043d2: 697a         	ldr	r2, [r7, #0x14]
 80043d4: 68b9         	ldr	r1, [r7, #0x8]
 80043d6: 68f8         	ldr	r0, [r7, #0xc]
 80043d8: f7ff fef8    	bl	0x80041cc <can_calc_timing_internal> @ imm = #-0x210
 80043dc: 4603         	mov	r3, r0
; }
 80043de: 4618         	mov	r0, r3
 80043e0: 3718         	adds	r7, #0x18
 80043e2: 46bd         	mov	sp, r7
 80043e4: bd80         	pop	{r7, pc}
 80043e6: bf00         	nop

080043e8 <$d>:
 80043e8: 40 42 0f 00  	.word	0x000f4240

080043ec <can_stm32_rx_isr_handler>:
; {
 80043ec: b580         	push	{r7, lr}
 80043ee: b098         	sub	sp, #0x60
 80043f0: af06         	add	r7, sp, #0x18
 80043f2: 6078         	str	r0, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 80043f4: 687b         	ldr	r3, [r7, #0x4]
 80043f6: 691b         	ldr	r3, [r3, #0x10]
 80043f8: 63fb         	str	r3, [r7, #0x3c]
; 	const struct can_stm32_config *cfg = dev->config;
 80043fa: 687b         	ldr	r3, [r7, #0x4]
 80043fc: 685b         	ldr	r3, [r3, #0x4]
 80043fe: 63bb         	str	r3, [r7, #0x38]
; 	CAN_TypeDef *can = cfg->can;
 8004400: 6bbb         	ldr	r3, [r7, #0x38]
 8004402: 695b         	ldr	r3, [r3, #0x14]
 8004404: 637b         	str	r3, [r7, #0x34]
; 	can_rx_callback_t callback = NULL;
 8004406: 2300         	movs	r3, #0x0
 8004408: 643b         	str	r3, [r7, #0x40]
; 	while (can->RF0R & CAN_RF0R_FMP0) {
 800440a: e061         	b	0x80044d0 <can_stm32_rx_isr_handler+0xe4> @ imm = #0xc2
; 		mbox = &can->sFIFOMailBox[0];
 800440c: 6b7b         	ldr	r3, [r7, #0x34]
 800440e: f503 73d8    	add.w	r3, r3, #0x1b0
 8004412: 62bb         	str	r3, [r7, #0x28]
; 		filter_id = ((mbox->RDTR & CAN_RDT0R_FMI) >> CAN_RDT0R_FMI_Pos);
 8004414: 6abb         	ldr	r3, [r7, #0x28]
 8004416: 685b         	ldr	r3, [r3, #0x4]
 8004418: 0a1b         	lsrs	r3, r3, #0x8
 800441a: b2db         	uxtb	r3, r3
 800441c: 627b         	str	r3, [r7, #0x24]
; 		LOG_DBG("Message on filter_id %d", filter_id);
 800441e: 2303         	movs	r3, #0x3
 8004420: 2b03         	cmp	r3, #0x3
 8004422: d91c         	bls	0x800445e <can_stm32_rx_isr_handler+0x72> @ imm = #0x38
 8004424: 2301         	movs	r3, #0x1
 8004426: f887 3023    	strb.w	r3, [r7, #0x23]
 800442a: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800442e: f083 0301    	eor	r3, r3, #0x1
 8004432: b2db         	uxtb	r3, r3
 8004434: 2b00         	cmp	r3, #0x0
 8004436: d112         	bne	0x800445e <can_stm32_rx_isr_handler+0x72> @ imm = #0x24
 8004438: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x800452c <can_stm32_rx_isr_handler+0x140>
 800443a: 6819         	ldr	r1, [r3]
 800443c: 6a7b         	ldr	r3, [r7, #0x24]
 800443e: 9304         	str	r3, [sp, #0x10]
 8004440: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8004530 <can_stm32_rx_isr_handler+0x144>
 8004442: 9303         	str	r3, [sp, #0xc]
 8004444: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8004534 <can_stm32_rx_isr_handler+0x148>
 8004446: 9302         	str	r3, [sp, #0x8]
 8004448: 2308         	movs	r3, #0x8
 800444a: 9301         	str	r3, [sp, #0x4]
 800444c: 2300         	movs	r3, #0x0
 800444e: 9300         	str	r3, [sp]
 8004450: 2300         	movs	r3, #0x0
 8004452: 2204         	movs	r2, #0x4
 8004454: 2000         	movs	r0, #0x0
 8004456: f00e ff05    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xee0a
 800445a: 2300         	movs	r3, #0x0
 800445c: 61fb         	str	r3, [r7, #0x1c]
; 		can_stm32_rx_fifo_pop(mbox, &frame);
 800445e: f107 0308    	add.w	r3, r7, #0x8
 8004462: 4619         	mov	r1, r3
 8004464: 6ab8         	ldr	r0, [r7, #0x28]
 8004466: f00e ff34    	bl	0x80132d2 <can_stm32_rx_fifo_pop> @ imm = #0xee68
; 		if (filter_id < CONFIG_CAN_MAX_EXT_ID_FILTER) {
 800446a: 6a7b         	ldr	r3, [r7, #0x24]
 800446c: 2b06         	cmp	r3, #0x6
 800446e: dc0d         	bgt	0x800448c <can_stm32_rx_isr_handler+0xa0> @ imm = #0x1a
; 			callback = data->rx_cb_ext[filter_id];
 8004470: 6bfa         	ldr	r2, [r7, #0x3c]
 8004472: 6a7b         	ldr	r3, [r7, #0x24]
 8004474: 3320         	adds	r3, #0x20
 8004476: 009b         	lsls	r3, r3, #0x2
 8004478: 4413         	add	r3, r2
 800447a: 685b         	ldr	r3, [r3, #0x4]
 800447c: 643b         	str	r3, [r7, #0x40]
; 			cb_arg = data->cb_arg_ext[filter_id];
 800447e: 6bfb         	ldr	r3, [r7, #0x3c]
 8004480: 6a7a         	ldr	r2, [r7, #0x24]
 8004482: 3236         	adds	r2, #0x36
 8004484: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8004488: 647b         	str	r3, [r7, #0x44]
 800448a: e012         	b	0x80044b2 <can_stm32_rx_isr_handler+0xc6> @ imm = #0x24
; 		} else if (filter_id < CAN_STM32_MAX_FILTER_ID) {
 800448c: 6a7b         	ldr	r3, [r7, #0x24]
 800448e: 2b22         	cmp	r3, #0x22
 8004490: dc0f         	bgt	0x80044b2 <can_stm32_rx_isr_handler+0xc6> @ imm = #0x1e
; 			index = filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER;
 8004492: 6a7b         	ldr	r3, [r7, #0x24]
 8004494: 3b07         	subs	r3, #0x7
 8004496: 61bb         	str	r3, [r7, #0x18]
; 			callback = data->rx_cb_std[index];
 8004498: 6bfa         	ldr	r2, [r7, #0x3c]
 800449a: 69bb         	ldr	r3, [r7, #0x18]
 800449c: 3312         	adds	r3, #0x12
 800449e: 009b         	lsls	r3, r3, #0x2
 80044a0: 4413         	add	r3, r2
 80044a2: 685b         	ldr	r3, [r3, #0x4]
 80044a4: 643b         	str	r3, [r7, #0x40]
; 			cb_arg = data->cb_arg_std[index];
 80044a6: 6bfb         	ldr	r3, [r7, #0x3c]
 80044a8: 69ba         	ldr	r2, [r7, #0x18]
 80044aa: 3228         	adds	r2, #0x28
 80044ac: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 80044b0: 647b         	str	r3, [r7, #0x44]
; 		if (callback) {
 80044b2: 6c3b         	ldr	r3, [r7, #0x40]
 80044b4: 2b00         	cmp	r3, #0x0
 80044b6: d005         	beq	0x80044c4 <can_stm32_rx_isr_handler+0xd8> @ imm = #0xa
; 			callback(dev, &frame, cb_arg);
 80044b8: f107 0108    	add.w	r1, r7, #0x8
 80044bc: 6c3b         	ldr	r3, [r7, #0x40]
 80044be: 6c7a         	ldr	r2, [r7, #0x44]
 80044c0: 6878         	ldr	r0, [r7, #0x4]
 80044c2: 4798         	blx	r3
; 		can->RF0R |= CAN_RF0R_RFOM0;
 80044c4: 6b7b         	ldr	r3, [r7, #0x34]
 80044c6: 68db         	ldr	r3, [r3, #0xc]
 80044c8: f043 0220    	orr	r2, r3, #0x20
 80044cc: 6b7b         	ldr	r3, [r7, #0x34]
 80044ce: 60da         	str	r2, [r3, #0xc]
; 	while (can->RF0R & CAN_RF0R_FMP0) {
 80044d0: 6b7b         	ldr	r3, [r7, #0x34]
 80044d2: 68db         	ldr	r3, [r3, #0xc]
 80044d4: f003 0303    	and	r3, r3, #0x3
 80044d8: 2b00         	cmp	r3, #0x0
 80044da: d197         	bne	0x800440c <can_stm32_rx_isr_handler+0x20> @ imm = #-0xd2
; 	if (can->RF0R & CAN_RF0R_FOVR0) {
 80044dc: 6b7b         	ldr	r3, [r7, #0x34]
 80044de: 68db         	ldr	r3, [r3, #0xc]
 80044e0: f003 0310    	and	r3, r3, #0x10
 80044e4: 2b00         	cmp	r3, #0x0
 80044e6: d01c         	beq	0x8004522 <can_stm32_rx_isr_handler+0x136> @ imm = #0x38
; 		LOG_ERR("RX FIFO Overflow");
 80044e8: 2303         	movs	r3, #0x3
 80044ea: 2b00         	cmp	r3, #0x0
 80044ec: d019         	beq	0x8004522 <can_stm32_rx_isr_handler+0x136> @ imm = #0x32
 80044ee: 2301         	movs	r3, #0x1
 80044f0: f887 3033    	strb.w	r3, [r7, #0x33]
 80044f4: f897 3033    	ldrb.w	r3, [r7, #0x33]
 80044f8: f083 0301    	eor	r3, r3, #0x1
 80044fc: b2db         	uxtb	r3, r3
 80044fe: 2b00         	cmp	r3, #0x0
 8004500: d10f         	bne	0x8004522 <can_stm32_rx_isr_handler+0x136> @ imm = #0x1e
 8004502: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800452c <can_stm32_rx_isr_handler+0x140>
 8004504: 6819         	ldr	r1, [r3]
 8004506: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004538 <can_stm32_rx_isr_handler+0x14c>
 8004508: 9302         	str	r3, [sp, #0x8]
 800450a: 2300         	movs	r3, #0x0
 800450c: 9301         	str	r3, [sp, #0x4]
 800450e: 2300         	movs	r3, #0x0
 8004510: 9300         	str	r3, [sp]
 8004512: 2300         	movs	r3, #0x0
 8004514: 2201         	movs	r2, #0x1
 8004516: 2000         	movs	r0, #0x0
 8004518: f00e fea4    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xed48
 800451c: 2300         	movs	r3, #0x0
 800451e: 62fb         	str	r3, [r7, #0x2c]
; }
 8004520: e7ff         	b	0x8004522 <can_stm32_rx_isr_handler+0x136> @ imm = #-0x2
 8004522: bf00         	nop
 8004524: 3748         	adds	r7, #0x48
 8004526: 46bd         	mov	sp, r7
 8004528: bd80         	pop	{r7, pc}
 800452a: bf00         	nop

0800452c <$d>:
 800452c: 54 04 00 20  	.word	0x20000454
 8004530: 3c d1 01 08  	.word	0x0801d13c
 8004534: 3c bb 01 08  	.word	0x0801bb3c
 8004538: 58 bb 01 08  	.word	0x0801bb58

0800453c <can_stm32_enter_init_mode>:
; {
 800453c: b580         	push	{r7, lr}
 800453e: b084         	sub	sp, #0x10
 8004540: af00         	add	r7, sp, #0x0
 8004542: 6078         	str	r0, [r7, #0x4]
; 	can->MCR |= CAN_MCR_INRQ;
 8004544: 687b         	ldr	r3, [r7, #0x4]
 8004546: 681b         	ldr	r3, [r3]
 8004548: f043 0201    	orr	r2, r3, #0x1
 800454c: 687b         	ldr	r3, [r7, #0x4]
 800454e: 601a         	str	r2, [r3]
; 	start_time = k_cycle_get_32();
 8004550: f00e fd92    	bl	0x8013078 <k_cycle_get_32> @ imm = #0xeb24
 8004554: 60f8         	str	r0, [r7, #0xc]
; 	while ((can->MSR & CAN_MSR_INAK) == 0U) {
 8004556: e010         	b	0x800457a <can_stm32_enter_init_mode+0x3e> @ imm = #0x20
; 		if (k_cycle_get_32() - start_time > CAN_INIT_TIMEOUT) {
 8004558: f00e fd8e    	bl	0x8013078 <k_cycle_get_32> @ imm = #0xeb1c
 800455c: 4602         	mov	r2, r0
 800455e: 68fb         	ldr	r3, [r7, #0xc]
 8004560: 1ad3         	subs	r3, r2, r3
 8004562: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8004590 <can_stm32_enter_init_mode+0x54>
 8004564: 4293         	cmp	r3, r2
 8004566: d908         	bls	0x800457a <can_stm32_enter_init_mode+0x3e> @ imm = #0x10
; 			can->MCR &= ~CAN_MCR_INRQ;
 8004568: 687b         	ldr	r3, [r7, #0x4]
 800456a: 681b         	ldr	r3, [r3]
 800456c: f023 0201    	bic	r2, r3, #0x1
 8004570: 687b         	ldr	r3, [r7, #0x4]
 8004572: 601a         	str	r2, [r3]
; 			return -EAGAIN;
 8004574: f06f 030a    	mvn	r3, #0xa
 8004578: e006         	b	0x8004588 <can_stm32_enter_init_mode+0x4c> @ imm = #0xc
; 	while ((can->MSR & CAN_MSR_INAK) == 0U) {
 800457a: 687b         	ldr	r3, [r7, #0x4]
 800457c: 685b         	ldr	r3, [r3, #0x4]
 800457e: f003 0301    	and	r3, r3, #0x1
 8004582: 2b00         	cmp	r3, #0x0
 8004584: d0e8         	beq	0x8004558 <can_stm32_enter_init_mode+0x1c> @ imm = #-0x30
; 	return 0;
 8004586: 2300         	movs	r3, #0x0
; }
 8004588: 4618         	mov	r0, r3
 800458a: 3710         	adds	r7, #0x10
 800458c: 46bd         	mov	sp, r7
 800458e: bd80         	pop	{r7, pc}

08004590 <$d>:
 8004590: 80 a2 19 00  	.word	0x0019a280

08004594 <can_stm32_leave_init_mode>:
; {
 8004594: b580         	push	{r7, lr}
 8004596: b084         	sub	sp, #0x10
 8004598: af00         	add	r7, sp, #0x0
 800459a: 6078         	str	r0, [r7, #0x4]
; 	can->MCR &= ~CAN_MCR_INRQ;
 800459c: 687b         	ldr	r3, [r7, #0x4]
 800459e: 681b         	ldr	r3, [r3]
 80045a0: f023 0201    	bic	r2, r3, #0x1
 80045a4: 687b         	ldr	r3, [r7, #0x4]
 80045a6: 601a         	str	r2, [r3]
; 	start_time = k_cycle_get_32();
 80045a8: f00e fd66    	bl	0x8013078 <k_cycle_get_32> @ imm = #0xeacc
 80045ac: 60f8         	str	r0, [r7, #0xc]
; 	while ((can->MSR & CAN_MSR_INAK) != 0U) {
 80045ae: e00a         	b	0x80045c6 <can_stm32_leave_init_mode+0x32> @ imm = #0x14
; 		if (k_cycle_get_32() - start_time > CAN_INIT_TIMEOUT) {
 80045b0: f00e fd62    	bl	0x8013078 <k_cycle_get_32> @ imm = #0xeac4
 80045b4: 4602         	mov	r2, r0
 80045b6: 68fb         	ldr	r3, [r7, #0xc]
 80045b8: 1ad3         	subs	r3, r2, r3
 80045ba: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80045dc <can_stm32_leave_init_mode+0x48>
 80045bc: 4293         	cmp	r3, r2
 80045be: d902         	bls	0x80045c6 <can_stm32_leave_init_mode+0x32> @ imm = #0x4
; 			return -EAGAIN;
 80045c0: f06f 030a    	mvn	r3, #0xa
 80045c4: e006         	b	0x80045d4 <can_stm32_leave_init_mode+0x40> @ imm = #0xc
; 	while ((can->MSR & CAN_MSR_INAK) != 0U) {
 80045c6: 687b         	ldr	r3, [r7, #0x4]
 80045c8: 685b         	ldr	r3, [r3, #0x4]
 80045ca: f003 0301    	and	r3, r3, #0x1
 80045ce: 2b00         	cmp	r3, #0x0
 80045d0: d1ee         	bne	0x80045b0 <can_stm32_leave_init_mode+0x1c> @ imm = #-0x24
; 	return 0;
 80045d2: 2300         	movs	r3, #0x0
; }
 80045d4: 4618         	mov	r0, r3
 80045d6: 3710         	adds	r7, #0x10
 80045d8: 46bd         	mov	sp, r7
 80045da: bd80         	pop	{r7, pc}

080045dc <$d>:
 80045dc: 80 a2 19 00  	.word	0x0019a280

080045e0 <can_stm32_leave_sleep_mode>:
; {
 80045e0: b580         	push	{r7, lr}
 80045e2: b084         	sub	sp, #0x10
 80045e4: af00         	add	r7, sp, #0x0
 80045e6: 6078         	str	r0, [r7, #0x4]
; 	can->MCR &= ~CAN_MCR_SLEEP;
 80045e8: 687b         	ldr	r3, [r7, #0x4]
 80045ea: 681b         	ldr	r3, [r3]
 80045ec: f023 0202    	bic	r2, r3, #0x2
 80045f0: 687b         	ldr	r3, [r7, #0x4]
 80045f2: 601a         	str	r2, [r3]
; 	start_time = k_cycle_get_32();
 80045f4: f00e fd40    	bl	0x8013078 <k_cycle_get_32> @ imm = #0xea80
 80045f8: 60f8         	str	r0, [r7, #0xc]
; 	while ((can->MSR & CAN_MSR_SLAK) != 0) {
 80045fa: e00a         	b	0x8004612 <can_stm32_leave_sleep_mode+0x32> @ imm = #0x14
; 		if (k_cycle_get_32() - start_time > CAN_INIT_TIMEOUT) {
 80045fc: f00e fd3c    	bl	0x8013078 <k_cycle_get_32> @ imm = #0xea78
 8004600: 4602         	mov	r2, r0
 8004602: 68fb         	ldr	r3, [r7, #0xc]
 8004604: 1ad3         	subs	r3, r2, r3
 8004606: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8004628 <can_stm32_leave_sleep_mode+0x48>
 8004608: 4293         	cmp	r3, r2
 800460a: d902         	bls	0x8004612 <can_stm32_leave_sleep_mode+0x32> @ imm = #0x4
; 			return -EAGAIN;
 800460c: f06f 030a    	mvn	r3, #0xa
 8004610: e006         	b	0x8004620 <can_stm32_leave_sleep_mode+0x40> @ imm = #0xc
; 	while ((can->MSR & CAN_MSR_SLAK) != 0) {
 8004612: 687b         	ldr	r3, [r7, #0x4]
 8004614: 685b         	ldr	r3, [r3, #0x4]
 8004616: f003 0302    	and	r3, r3, #0x2
 800461a: 2b00         	cmp	r3, #0x0
 800461c: d1ee         	bne	0x80045fc <can_stm32_leave_sleep_mode+0x1c> @ imm = #-0x24
; 	return 0;
 800461e: 2300         	movs	r3, #0x0
; }
 8004620: 4618         	mov	r0, r3
 8004622: 3710         	adds	r7, #0x10
 8004624: 46bd         	mov	sp, r7
 8004626: bd80         	pop	{r7, pc}

08004628 <$d>:
 8004628: 80 a2 19 00  	.word	0x0019a280

0800462c <can_stm32_start>:
; {
 800462c: b580         	push	{r7, lr}
 800462e: b08e         	sub	sp, #0x38
 8004630: af04         	add	r7, sp, #0x10
 8004632: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8004634: 687b         	ldr	r3, [r7, #0x4]
 8004636: 685b         	ldr	r3, [r3, #0x4]
 8004638: 623b         	str	r3, [r7, #0x20]
; 	struct can_stm32_data *data = dev->data;
 800463a: 687b         	ldr	r3, [r7, #0x4]
 800463c: 691b         	ldr	r3, [r3, #0x10]
 800463e: 61fb         	str	r3, [r7, #0x1c]
; 	CAN_TypeDef *can = cfg->can;
 8004640: 6a3b         	ldr	r3, [r7, #0x20]
 8004642: 695b         	ldr	r3, [r3, #0x14]
 8004644: 61bb         	str	r3, [r7, #0x18]
; 	int ret = 0;
 8004646: 2300         	movs	r3, #0x0
 8004648: 627b         	str	r3, [r7, #0x24]
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 800464a: 69fb         	ldr	r3, [r7, #0x1c]
 800464c: f103 0110    	add.w	r1, r3, #0x10
 8004650: f04f 32ff    	mov.w	r2, #0xffffffff
 8004654: f04f 33ff    	mov.w	r3, #0xffffffff
 8004658: 4608         	mov	r0, r1
 800465a: f00e fd20    	bl	0x801309e <k_mutex_lock> @ imm = #0xea40
; 	if (data->common.started) {
 800465e: 69fb         	ldr	r3, [r7, #0x1c]
 8004660: 791b         	ldrb	r3, [r3, #0x4]
 8004662: 2b00         	cmp	r3, #0x0
 8004664: d003         	beq	0x800466e <can_stm32_start+0x42> @ imm = #0x6
; 		ret = -EALREADY;
 8004666: f06f 0377    	mvn	r3, #0x77
 800466a: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 800466c: e05e         	b	0x800472c <can_stm32_start+0x100> @ imm = #0xbc
; 	if (cfg->common.phy != NULL) {
 800466e: 6a3b         	ldr	r3, [r7, #0x20]
 8004670: 681b         	ldr	r3, [r3]
 8004672: 2b00         	cmp	r3, #0x0
 8004674: d029         	beq	0x80046ca <can_stm32_start+0x9e> @ imm = #0x52
; 		ret = can_transceiver_enable(cfg->common.phy, data->common.mode);
 8004676: 6a3b         	ldr	r3, [r7, #0x20]
 8004678: 681a         	ldr	r2, [r3]
 800467a: 69fb         	ldr	r3, [r7, #0x1c]
 800467c: 681b         	ldr	r3, [r3]
 800467e: 4619         	mov	r1, r3
 8004680: 4610         	mov	r0, r2
 8004682: f00e fd73    	bl	0x801316c <can_transceiver_enable> @ imm = #0xeae6
 8004686: 6278         	str	r0, [r7, #0x24]
; 		if (ret != 0) {
 8004688: 6a7b         	ldr	r3, [r7, #0x24]
 800468a: 2b00         	cmp	r3, #0x0
 800468c: d01d         	beq	0x80046ca <can_stm32_start+0x9e> @ imm = #0x3a
; 			LOG_ERR("failed to enable CAN transceiver (err %d)", ret);
 800468e: 2303         	movs	r3, #0x3
 8004690: 2b00         	cmp	r3, #0x0
 8004692: d019         	beq	0x80046c8 <can_stm32_start+0x9c> @ imm = #0x32
 8004694: 2301         	movs	r3, #0x1
 8004696: 75fb         	strb	r3, [r7, #0x17]
 8004698: 7dfb         	ldrb	r3, [r7, #0x17]
 800469a: f083 0301    	eor	r3, r3, #0x1
 800469e: b2db         	uxtb	r3, r3
 80046a0: 2b00         	cmp	r3, #0x0
 80046a2: d111         	bne	0x80046c8 <can_stm32_start+0x9c> @ imm = #0x22
 80046a4: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8004744 <can_stm32_start+0x118>
 80046a6: 6819         	ldr	r1, [r3]
 80046a8: 6a7b         	ldr	r3, [r7, #0x24]
 80046aa: 9303         	str	r3, [sp, #0xc]
 80046ac: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8004748 <can_stm32_start+0x11c>
 80046ae: 9302         	str	r3, [sp, #0x8]
 80046b0: 2300         	movs	r3, #0x0
 80046b2: 9301         	str	r3, [sp, #0x4]
 80046b4: 2300         	movs	r3, #0x0
 80046b6: 9300         	str	r3, [sp]
 80046b8: 2300         	movs	r3, #0x0
 80046ba: 2201         	movs	r2, #0x1
 80046bc: 2000         	movs	r0, #0x0
 80046be: f00e fdd1    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xeba2
 80046c2: 2300         	movs	r3, #0x0
 80046c4: 613b         	str	r3, [r7, #0x10]
; 			goto unlock;
 80046c6: e031         	b	0x800472c <can_stm32_start+0x100> @ imm = #0x62
 80046c8: e030         	b	0x800472c <can_stm32_start+0x100> @ imm = #0x60
; 	ret = can_stm32_leave_init_mode(can);
 80046ca: 69b8         	ldr	r0, [r7, #0x18]
 80046cc: f7ff ff62    	bl	0x8004594 <can_stm32_leave_init_mode> @ imm = #-0x13c
 80046d0: 6278         	str	r0, [r7, #0x24]
; 	if (ret < 0) {
 80046d2: 6a7b         	ldr	r3, [r7, #0x24]
 80046d4: 2b00         	cmp	r3, #0x0
 80046d6: da26         	bge	0x8004726 <can_stm32_start+0xfa> @ imm = #0x4c
; 		LOG_ERR("Failed to leave init mode");
 80046d8: 2303         	movs	r3, #0x3
 80046da: 2b00         	cmp	r3, #0x0
 80046dc: d016         	beq	0x800470c <can_stm32_start+0xe0> @ imm = #0x2c
 80046de: 2301         	movs	r3, #0x1
 80046e0: 73fb         	strb	r3, [r7, #0xf]
 80046e2: 7bfb         	ldrb	r3, [r7, #0xf]
 80046e4: f083 0301    	eor	r3, r3, #0x1
 80046e8: b2db         	uxtb	r3, r3
 80046ea: 2b00         	cmp	r3, #0x0
 80046ec: d10e         	bne	0x800470c <can_stm32_start+0xe0> @ imm = #0x1c
 80046ee: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8004744 <can_stm32_start+0x118>
 80046f0: 6819         	ldr	r1, [r3]
 80046f2: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800474c <can_stm32_start+0x120>
 80046f4: 9302         	str	r3, [sp, #0x8]
 80046f6: 2300         	movs	r3, #0x0
 80046f8: 9301         	str	r3, [sp, #0x4]
 80046fa: 2300         	movs	r3, #0x0
 80046fc: 9300         	str	r3, [sp]
 80046fe: 2300         	movs	r3, #0x0
 8004700: 2201         	movs	r2, #0x1
 8004702: 2000         	movs	r0, #0x0
 8004704: f00e fdae    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xeb5c
 8004708: 2300         	movs	r3, #0x0
 800470a: 60bb         	str	r3, [r7, #0x8]
; 		if (cfg->common.phy != NULL) {
 800470c: 6a3b         	ldr	r3, [r7, #0x20]
 800470e: 681b         	ldr	r3, [r3]
 8004710: 2b00         	cmp	r3, #0x0
 8004712: d004         	beq	0x800471e <can_stm32_start+0xf2> @ imm = #0x8
; 			(void)can_transceiver_disable(cfg->common.phy);
 8004714: 6a3b         	ldr	r3, [r7, #0x20]
 8004716: 681b         	ldr	r3, [r3]
 8004718: 4618         	mov	r0, r3
 800471a: f00e fd37    	bl	0x801318c <can_transceiver_disable> @ imm = #0xea6e
; 		ret = -EIO;
 800471e: f06f 0304    	mvn	r3, #0x4
 8004722: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 8004724: e002         	b	0x800472c <can_stm32_start+0x100> @ imm = #0x4
; 	data->common.started = true;
 8004726: 69fb         	ldr	r3, [r7, #0x1c]
 8004728: 2201         	movs	r2, #0x1
 800472a: 711a         	strb	r2, [r3, #0x4]
; 	k_mutex_unlock(&data->inst_mutex);
 800472c: 69fb         	ldr	r3, [r7, #0x1c]
 800472e: 3310         	adds	r3, #0x10
 8004730: 4618         	mov	r0, r3
 8004732: f00e fcc4    	bl	0x80130be <k_mutex_unlock> @ imm = #0xe988
; 	return ret;
 8004736: 6a79         	ldr	r1, [r7, #0x24]
 8004738: 460b         	mov	r3, r1
; }
 800473a: 4618         	mov	r0, r3
 800473c: 3728         	adds	r7, #0x28
 800473e: 46bd         	mov	sp, r7
 8004740: bd80         	pop	{r7, pc}
 8004742: bf00         	nop

08004744 <$d>:
 8004744: 54 04 00 20  	.word	0x20000454
 8004748: 6c bb 01 08  	.word	0x0801bb6c
 800474c: 98 bb 01 08  	.word	0x0801bb98

08004750 <can_stm32_stop>:
; {
 8004750: b580         	push	{r7, lr}
 8004752: b08e         	sub	sp, #0x38
 8004754: af04         	add	r7, sp, #0x10
 8004756: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8004758: 687b         	ldr	r3, [r7, #0x4]
 800475a: 685b         	ldr	r3, [r3, #0x4]
 800475c: 623b         	str	r3, [r7, #0x20]
; 	struct can_stm32_data *data = dev->data;
 800475e: 687b         	ldr	r3, [r7, #0x4]
 8004760: 691b         	ldr	r3, [r3, #0x10]
 8004762: 61fb         	str	r3, [r7, #0x1c]
; 	CAN_TypeDef *can = cfg->can;
 8004764: 6a3b         	ldr	r3, [r7, #0x20]
 8004766: 695b         	ldr	r3, [r3, #0x14]
 8004768: 61bb         	str	r3, [r7, #0x18]
; 	int ret = 0;
 800476a: 2300         	movs	r3, #0x0
 800476c: 627b         	str	r3, [r7, #0x24]
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 800476e: 69fb         	ldr	r3, [r7, #0x1c]
 8004770: f103 0110    	add.w	r1, r3, #0x10
 8004774: f04f 32ff    	mov.w	r2, #0xffffffff
 8004778: f04f 33ff    	mov.w	r3, #0xffffffff
 800477c: 4608         	mov	r0, r1
 800477e: f00e fc8e    	bl	0x801309e <k_mutex_lock> @ imm = #0xe91c
; 	if (!data->common.started) {
 8004782: 69fb         	ldr	r3, [r7, #0x1c]
 8004784: 791b         	ldrb	r3, [r3, #0x4]
 8004786: f083 0301    	eor	r3, r3, #0x1
 800478a: b2db         	uxtb	r3, r3
 800478c: 2b00         	cmp	r3, #0x0
 800478e: d003         	beq	0x8004798 <can_stm32_stop+0x48> @ imm = #0x6
; 		ret = -EALREADY;
 8004790: f06f 0377    	mvn	r3, #0x77
 8004794: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 8004796: e072         	b	0x800487e <can_stm32_stop+0x12e> @ imm = #0xe4
; 	ret = can_stm32_enter_init_mode(can);
 8004798: 69b8         	ldr	r0, [r7, #0x18]
 800479a: f7ff fecf    	bl	0x800453c <can_stm32_enter_init_mode> @ imm = #-0x262
 800479e: 6278         	str	r0, [r7, #0x24]
; 	if (ret < 0) {
 80047a0: 6a7b         	ldr	r3, [r7, #0x24]
 80047a2: 2b00         	cmp	r3, #0x0
 80047a4: da1d         	bge	0x80047e2 <can_stm32_stop+0x92> @ imm = #0x3a
; 		LOG_ERR("Failed to enter init mode");
 80047a6: 2303         	movs	r3, #0x3
 80047a8: 2b00         	cmp	r3, #0x0
 80047aa: d016         	beq	0x80047da <can_stm32_stop+0x8a> @ imm = #0x2c
 80047ac: 2301         	movs	r3, #0x1
 80047ae: 73fb         	strb	r3, [r7, #0xf]
 80047b0: 7bfb         	ldrb	r3, [r7, #0xf]
 80047b2: f083 0301    	eor	r3, r3, #0x1
 80047b6: b2db         	uxtb	r3, r3
 80047b8: 2b00         	cmp	r3, #0x0
 80047ba: d10e         	bne	0x80047da <can_stm32_stop+0x8a> @ imm = #0x1c
 80047bc: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8004894 <can_stm32_stop+0x144>
 80047be: 6819         	ldr	r1, [r3]
 80047c0: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8004898 <can_stm32_stop+0x148>
 80047c2: 9302         	str	r3, [sp, #0x8]
 80047c4: 2300         	movs	r3, #0x0
 80047c6: 9301         	str	r3, [sp, #0x4]
 80047c8: 2300         	movs	r3, #0x0
 80047ca: 9300         	str	r3, [sp]
 80047cc: 2300         	movs	r3, #0x0
 80047ce: 2201         	movs	r2, #0x1
 80047d0: 2000         	movs	r0, #0x0
 80047d2: f00e fd47    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xea8e
 80047d6: 2300         	movs	r3, #0x0
 80047d8: 60bb         	str	r3, [r7, #0x8]
; 		ret = -EIO;
 80047da: f06f 0304    	mvn	r3, #0x4
 80047de: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 80047e0: e04d         	b	0x800487e <can_stm32_stop+0x12e> @ imm = #0x9a
; 	can_stm32_signal_tx_complete(dev, &data->mb0, -ENETDOWN);
 80047e2: 69fb         	ldr	r3, [r7, #0x1c]
 80047e4: 3334         	adds	r3, #0x34
 80047e6: f06f 0272    	mvn	r2, #0x72
 80047ea: 4619         	mov	r1, r3
 80047ec: 6878         	ldr	r0, [r7, #0x4]
 80047ee: f00e fd57    	bl	0x80132a0 <can_stm32_signal_tx_complete> @ imm = #0xeaae
; 	can_stm32_signal_tx_complete(dev, &data->mb1, -ENETDOWN);
 80047f2: 69fb         	ldr	r3, [r7, #0x1c]
 80047f4: 333c         	adds	r3, #0x3c
 80047f6: f06f 0272    	mvn	r2, #0x72
 80047fa: 4619         	mov	r1, r3
 80047fc: 6878         	ldr	r0, [r7, #0x4]
 80047fe: f00e fd4f    	bl	0x80132a0 <can_stm32_signal_tx_complete> @ imm = #0xea9e
; 	can_stm32_signal_tx_complete(dev, &data->mb2, -ENETDOWN);
 8004802: 69fb         	ldr	r3, [r7, #0x1c]
 8004804: 3344         	adds	r3, #0x44
 8004806: f06f 0272    	mvn	r2, #0x72
 800480a: 4619         	mov	r1, r3
 800480c: 6878         	ldr	r0, [r7, #0x4]
 800480e: f00e fd47    	bl	0x80132a0 <can_stm32_signal_tx_complete> @ imm = #0xea8e
; 	can->TSR |= CAN_TSR_ABRQ2 | CAN_TSR_ABRQ1 | CAN_TSR_ABRQ0;
 8004812: 69bb         	ldr	r3, [r7, #0x18]
 8004814: 689b         	ldr	r3, [r3, #0x8]
 8004816: f043 1380    	orr	r3, r3, #0x800080
 800481a: f443 4300    	orr	r3, r3, #0x8000
 800481e: 69ba         	ldr	r2, [r7, #0x18]
 8004820: 6093         	str	r3, [r2, #0x8]
; 	if (cfg->common.phy != NULL) {
 8004822: 6a3b         	ldr	r3, [r7, #0x20]
 8004824: 681b         	ldr	r3, [r3]
 8004826: 2b00         	cmp	r3, #0x0
 8004828: d026         	beq	0x8004878 <can_stm32_stop+0x128> @ imm = #0x4c
; 		ret = can_transceiver_disable(cfg->common.phy);
 800482a: 6a3b         	ldr	r3, [r7, #0x20]
 800482c: 681b         	ldr	r3, [r3]
 800482e: 4618         	mov	r0, r3
 8004830: f00e fcac    	bl	0x801318c <can_transceiver_disable> @ imm = #0xe958
 8004834: 6278         	str	r0, [r7, #0x24]
; 		if (ret != 0) {
 8004836: 6a7b         	ldr	r3, [r7, #0x24]
 8004838: 2b00         	cmp	r3, #0x0
 800483a: d01d         	beq	0x8004878 <can_stm32_stop+0x128> @ imm = #0x3a
; 			LOG_ERR("failed to enable CAN transceiver (err %d)", ret);
 800483c: 2303         	movs	r3, #0x3
 800483e: 2b00         	cmp	r3, #0x0
 8004840: d019         	beq	0x8004876 <can_stm32_stop+0x126> @ imm = #0x32
 8004842: 2301         	movs	r3, #0x1
 8004844: 75fb         	strb	r3, [r7, #0x17]
 8004846: 7dfb         	ldrb	r3, [r7, #0x17]
 8004848: f083 0301    	eor	r3, r3, #0x1
 800484c: b2db         	uxtb	r3, r3
 800484e: 2b00         	cmp	r3, #0x0
 8004850: d111         	bne	0x8004876 <can_stm32_stop+0x126> @ imm = #0x22
 8004852: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8004894 <can_stm32_stop+0x144>
 8004854: 6819         	ldr	r1, [r3]
 8004856: 6a7b         	ldr	r3, [r7, #0x24]
 8004858: 9303         	str	r3, [sp, #0xc]
 800485a: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800489c <can_stm32_stop+0x14c>
 800485c: 9302         	str	r3, [sp, #0x8]
 800485e: 2300         	movs	r3, #0x0
 8004860: 9301         	str	r3, [sp, #0x4]
 8004862: 2300         	movs	r3, #0x0
 8004864: 9300         	str	r3, [sp]
 8004866: 2300         	movs	r3, #0x0
 8004868: 2201         	movs	r2, #0x1
 800486a: 2000         	movs	r0, #0x0
 800486c: f00e fcfa    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe9f4
 8004870: 2300         	movs	r3, #0x0
 8004872: 613b         	str	r3, [r7, #0x10]
; 			goto unlock;
 8004874: e003         	b	0x800487e <can_stm32_stop+0x12e> @ imm = #0x6
 8004876: e002         	b	0x800487e <can_stm32_stop+0x12e> @ imm = #0x4
; 	data->common.started = false;
 8004878: 69fb         	ldr	r3, [r7, #0x1c]
 800487a: 2200         	movs	r2, #0x0
 800487c: 711a         	strb	r2, [r3, #0x4]
; 	k_mutex_unlock(&data->inst_mutex);
 800487e: 69fb         	ldr	r3, [r7, #0x1c]
 8004880: 3310         	adds	r3, #0x10
 8004882: 4618         	mov	r0, r3
 8004884: f00e fc1b    	bl	0x80130be <k_mutex_unlock> @ imm = #0xe836
; 	return ret;
 8004888: 6a79         	ldr	r1, [r7, #0x24]
 800488a: 460b         	mov	r3, r1
; }
 800488c: 4618         	mov	r0, r3
 800488e: 3728         	adds	r7, #0x28
 8004890: 46bd         	mov	sp, r7
 8004892: bd80         	pop	{r7, pc}

08004894 <$d>:
 8004894: 54 04 00 20  	.word	0x20000454
 8004898: b4 bb 01 08  	.word	0x0801bbb4
 800489c: 6c bb 01 08  	.word	0x0801bb6c

080048a0 <can_stm32_set_mode>:
; {
 80048a0: b580         	push	{r7, lr}
 80048a2: b090         	sub	sp, #0x40
 80048a4: af06         	add	r7, sp, #0x18
 80048a6: 6078         	str	r0, [r7, #0x4]
 80048a8: 6039         	str	r1, [r7]
; 	can_mode_t supported = CAN_MODE_LOOPBACK | CAN_MODE_LISTENONLY | CAN_MODE_ONE_SHOT;
 80048aa: 230b         	movs	r3, #0xb
 80048ac: 627b         	str	r3, [r7, #0x24]
; 	const struct can_stm32_config *cfg = dev->config;
 80048ae: 687b         	ldr	r3, [r7, #0x4]
 80048b0: 685b         	ldr	r3, [r3, #0x4]
 80048b2: 623b         	str	r3, [r7, #0x20]
; 	CAN_TypeDef *can = cfg->can;
 80048b4: 6a3b         	ldr	r3, [r7, #0x20]
 80048b6: 695b         	ldr	r3, [r3, #0x14]
 80048b8: 61fb         	str	r3, [r7, #0x1c]
; 	struct can_stm32_data *data = dev->data;
 80048ba: 687b         	ldr	r3, [r7, #0x4]
 80048bc: 691b         	ldr	r3, [r3, #0x10]
 80048be: 61bb         	str	r3, [r7, #0x18]
; 	LOG_DBG("Set mode %d", mode);
 80048c0: 2303         	movs	r3, #0x3
 80048c2: 2b03         	cmp	r3, #0x3
 80048c4: d91a         	bls	0x80048fc <can_stm32_set_mode+0x5c> @ imm = #0x34
 80048c6: 2301         	movs	r3, #0x1
 80048c8: 75fb         	strb	r3, [r7, #0x17]
 80048ca: 7dfb         	ldrb	r3, [r7, #0x17]
 80048cc: f083 0301    	eor	r3, r3, #0x1
 80048d0: b2db         	uxtb	r3, r3
 80048d2: 2b00         	cmp	r3, #0x0
 80048d4: d112         	bne	0x80048fc <can_stm32_set_mode+0x5c> @ imm = #0x24
 80048d6: 4b46         	ldr	r3, [pc, #0x118]        @ 0x80049f0 <can_stm32_set_mode+0x150>
 80048d8: 6819         	ldr	r1, [r3]
 80048da: 683b         	ldr	r3, [r7]
 80048dc: 9304         	str	r3, [sp, #0x10]
 80048de: 4b45         	ldr	r3, [pc, #0x114]        @ 0x80049f4 <can_stm32_set_mode+0x154>
 80048e0: 9303         	str	r3, [sp, #0xc]
 80048e2: 4b45         	ldr	r3, [pc, #0x114]        @ 0x80049f8 <can_stm32_set_mode+0x158>
 80048e4: 9302         	str	r3, [sp, #0x8]
 80048e6: 2308         	movs	r3, #0x8
 80048e8: 9301         	str	r3, [sp, #0x4]
 80048ea: 2300         	movs	r3, #0x0
 80048ec: 9300         	str	r3, [sp]
 80048ee: 2300         	movs	r3, #0x0
 80048f0: 2204         	movs	r2, #0x4
 80048f2: 2000         	movs	r0, #0x0
 80048f4: f00e fcb6    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe96c
 80048f8: 2300         	movs	r3, #0x0
 80048fa: 613b         	str	r3, [r7, #0x10]
; 	if ((mode & ~(supported)) != 0) {
 80048fc: 6a7b         	ldr	r3, [r7, #0x24]
 80048fe: 43da         	mvns	r2, r3
 8004900: 683b         	ldr	r3, [r7]
 8004902: 4013         	ands	r3, r2
 8004904: 2b00         	cmp	r3, #0x0
 8004906: d01e         	beq	0x8004946 <can_stm32_set_mode+0xa6> @ imm = #0x3c
; 		LOG_ERR("unsupported mode: 0x%08x", mode);
 8004908: 2303         	movs	r3, #0x3
 800490a: 2b00         	cmp	r3, #0x0
 800490c: d018         	beq	0x8004940 <can_stm32_set_mode+0xa0> @ imm = #0x30
 800490e: 2301         	movs	r3, #0x1
 8004910: 73fb         	strb	r3, [r7, #0xf]
 8004912: 7bfb         	ldrb	r3, [r7, #0xf]
 8004914: f083 0301    	eor	r3, r3, #0x1
 8004918: b2db         	uxtb	r3, r3
 800491a: 2b00         	cmp	r3, #0x0
 800491c: d110         	bne	0x8004940 <can_stm32_set_mode+0xa0> @ imm = #0x20
 800491e: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x80049f0 <can_stm32_set_mode+0x150>
 8004920: 6819         	ldr	r1, [r3]
 8004922: 683b         	ldr	r3, [r7]
 8004924: 9303         	str	r3, [sp, #0xc]
 8004926: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80049fc <can_stm32_set_mode+0x15c>
 8004928: 9302         	str	r3, [sp, #0x8]
 800492a: 2300         	movs	r3, #0x0
 800492c: 9301         	str	r3, [sp, #0x4]
 800492e: 2300         	movs	r3, #0x0
 8004930: 9300         	str	r3, [sp]
 8004932: 2300         	movs	r3, #0x0
 8004934: 2201         	movs	r2, #0x1
 8004936: 2000         	movs	r0, #0x0
 8004938: f00e fc94    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe928
 800493c: 2300         	movs	r3, #0x0
 800493e: 60bb         	str	r3, [r7, #0x8]
; 		return -ENOTSUP;
 8004940: f06f 0185    	mvn	r1, #0x85
 8004944: e04f         	b	0x80049e6 <can_stm32_set_mode+0x146> @ imm = #0x9e
; 	if (data->common.started) {
 8004946: 69bb         	ldr	r3, [r7, #0x18]
 8004948: 791b         	ldrb	r3, [r3, #0x4]
 800494a: 2b00         	cmp	r3, #0x0
 800494c: d002         	beq	0x8004954 <can_stm32_set_mode+0xb4> @ imm = #0x4
; 		return -EBUSY;
 800494e: f06f 010f    	mvn	r1, #0xf
 8004952: e048         	b	0x80049e6 <can_stm32_set_mode+0x146> @ imm = #0x90
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8004954: 69bb         	ldr	r3, [r7, #0x18]
 8004956: f103 0110    	add.w	r1, r3, #0x10
 800495a: f04f 32ff    	mov.w	r2, #0xffffffff
 800495e: f04f 33ff    	mov.w	r3, #0xffffffff
 8004962: 4608         	mov	r0, r1
 8004964: f00e fb9b    	bl	0x801309e <k_mutex_lock> @ imm = #0xe736
; 	if ((mode & CAN_MODE_LOOPBACK) != 0) {
 8004968: 683b         	ldr	r3, [r7]
 800496a: f003 0301    	and	r3, r3, #0x1
 800496e: 2b00         	cmp	r3, #0x0
 8004970: d006         	beq	0x8004980 <can_stm32_set_mode+0xe0> @ imm = #0xc
; 		can->BTR |= CAN_BTR_LBKM;
 8004972: 69fb         	ldr	r3, [r7, #0x1c]
 8004974: 69db         	ldr	r3, [r3, #0x1c]
 8004976: f043 4280    	orr	r2, r3, #0x40000000
 800497a: 69fb         	ldr	r3, [r7, #0x1c]
 800497c: 61da         	str	r2, [r3, #0x1c]
 800497e: e005         	b	0x800498c <can_stm32_set_mode+0xec> @ imm = #0xa
; 		can->BTR &= ~CAN_BTR_LBKM;
 8004980: 69fb         	ldr	r3, [r7, #0x1c]
 8004982: 69db         	ldr	r3, [r3, #0x1c]
 8004984: f023 4280    	bic	r2, r3, #0x40000000
 8004988: 69fb         	ldr	r3, [r7, #0x1c]
 800498a: 61da         	str	r2, [r3, #0x1c]
; 	if ((mode & CAN_MODE_LISTENONLY) != 0) {
 800498c: 683b         	ldr	r3, [r7]
 800498e: f003 0302    	and	r3, r3, #0x2
 8004992: 2b00         	cmp	r3, #0x0
 8004994: d006         	beq	0x80049a4 <can_stm32_set_mode+0x104> @ imm = #0xc
; 		can->BTR |= CAN_BTR_SILM;
 8004996: 69fb         	ldr	r3, [r7, #0x1c]
 8004998: 69db         	ldr	r3, [r3, #0x1c]
 800499a: f043 4200    	orr	r2, r3, #0x80000000
 800499e: 69fb         	ldr	r3, [r7, #0x1c]
 80049a0: 61da         	str	r2, [r3, #0x1c]
 80049a2: e005         	b	0x80049b0 <can_stm32_set_mode+0x110> @ imm = #0xa
; 		can->BTR &= ~CAN_BTR_SILM;
 80049a4: 69fb         	ldr	r3, [r7, #0x1c]
 80049a6: 69db         	ldr	r3, [r3, #0x1c]
 80049a8: f023 4200    	bic	r2, r3, #0x80000000
 80049ac: 69fb         	ldr	r3, [r7, #0x1c]
 80049ae: 61da         	str	r2, [r3, #0x1c]
; 	if ((mode & CAN_MODE_ONE_SHOT) != 0) {
 80049b0: 683b         	ldr	r3, [r7]
 80049b2: f003 0308    	and	r3, r3, #0x8
 80049b6: 2b00         	cmp	r3, #0x0
 80049b8: d006         	beq	0x80049c8 <can_stm32_set_mode+0x128> @ imm = #0xc
; 		can->MCR |= CAN_MCR_NART;
 80049ba: 69fb         	ldr	r3, [r7, #0x1c]
 80049bc: 681b         	ldr	r3, [r3]
 80049be: f043 0210    	orr	r2, r3, #0x10
 80049c2: 69fb         	ldr	r3, [r7, #0x1c]
 80049c4: 601a         	str	r2, [r3]
 80049c6: e005         	b	0x80049d4 <can_stm32_set_mode+0x134> @ imm = #0xa
; 		can->MCR &= ~CAN_MCR_NART;
 80049c8: 69fb         	ldr	r3, [r7, #0x1c]
 80049ca: 681b         	ldr	r3, [r3]
 80049cc: f023 0210    	bic	r2, r3, #0x10
 80049d0: 69fb         	ldr	r3, [r7, #0x1c]
 80049d2: 601a         	str	r2, [r3]
; 	data->common.mode = mode;
 80049d4: 69bb         	ldr	r3, [r7, #0x18]
 80049d6: 683a         	ldr	r2, [r7]
 80049d8: 601a         	str	r2, [r3]
; 	k_mutex_unlock(&data->inst_mutex);
 80049da: 69bb         	ldr	r3, [r7, #0x18]
 80049dc: 3310         	adds	r3, #0x10
 80049de: 4618         	mov	r0, r3
 80049e0: f00e fb6d    	bl	0x80130be <k_mutex_unlock> @ imm = #0xe6da
; 	return 0;
 80049e4: 2100         	movs	r1, #0x0
; }
 80049e6: 460b         	mov	r3, r1
 80049e8: 4618         	mov	r0, r3
 80049ea: 3728         	adds	r7, #0x28
 80049ec: 46bd         	mov	sp, r7
 80049ee: bd80         	pop	{r7, pc}

080049f0 <$d>:
 80049f0: 54 04 00 20  	.word	0x20000454
 80049f4: 58 d1 01 08  	.word	0x0801d158
 80049f8: d0 bb 01 08  	.word	0x0801bbd0
 80049fc: e0 bb 01 08  	.word	0x0801bbe0

08004a00 <can_stm32_set_timing>:
; {
 8004a00: b580         	push	{r7, lr}
 8004a02: b086         	sub	sp, #0x18
 8004a04: af00         	add	r7, sp, #0x0
 8004a06: 6078         	str	r0, [r7, #0x4]
 8004a08: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8004a0a: 687b         	ldr	r3, [r7, #0x4]
 8004a0c: 685b         	ldr	r3, [r3, #0x4]
 8004a0e: 617b         	str	r3, [r7, #0x14]
; 	CAN_TypeDef *can = cfg->can;
 8004a10: 697b         	ldr	r3, [r7, #0x14]
 8004a12: 695b         	ldr	r3, [r3, #0x14]
 8004a14: 613b         	str	r3, [r7, #0x10]
; 	struct can_stm32_data *data = dev->data;
 8004a16: 687b         	ldr	r3, [r7, #0x4]
 8004a18: 691b         	ldr	r3, [r3, #0x10]
 8004a1a: 60fb         	str	r3, [r7, #0xc]
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8004a1c: 68fb         	ldr	r3, [r7, #0xc]
 8004a1e: f103 0110    	add.w	r1, r3, #0x10
 8004a22: f04f 32ff    	mov.w	r2, #0xffffffff
 8004a26: f04f 33ff    	mov.w	r3, #0xffffffff
 8004a2a: 4608         	mov	r0, r1
 8004a2c: f00e fb37    	bl	0x801309e <k_mutex_lock> @ imm = #0xe66e
; 	if (data->common.started) {
 8004a30: 68fb         	ldr	r3, [r7, #0xc]
 8004a32: 791b         	ldrb	r3, [r3, #0x4]
 8004a34: 2b00         	cmp	r3, #0x0
 8004a36: d007         	beq	0x8004a48 <can_stm32_set_timing+0x48> @ imm = #0xe
; 		k_mutex_unlock(&data->inst_mutex);
 8004a38: 68fb         	ldr	r3, [r7, #0xc]
 8004a3a: 3310         	adds	r3, #0x10
 8004a3c: 4618         	mov	r0, r3
 8004a3e: f00e fb3e    	bl	0x80130be <k_mutex_unlock> @ imm = #0xe67c
; 		return -EBUSY;
 8004a42: f06f 010f    	mvn	r1, #0xf
 8004a46: e026         	b	0x8004a96 <can_stm32_set_timing+0x96> @ imm = #0x4c
; 	can->BTR = (can->BTR & ~(CAN_BTR_SJW_Msk | CAN_BTR_BRP_Msk |
 8004a48: 693b         	ldr	r3, [r7, #0x10]
 8004a4a: 69da         	ldr	r2, [r3, #0x1c]
 8004a4c: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8004aa0 <can_stm32_set_timing+0xa0>
 8004a4e: 4013         	ands	r3, r2
; 	     (((timing->sjw        - 1) << CAN_BTR_SJW_Pos) & CAN_BTR_SJW_Msk) |
 8004a50: 683a         	ldr	r2, [r7]
 8004a52: 8812         	ldrh	r2, [r2]
 8004a54: 3a01         	subs	r2, #0x1
 8004a56: 0612         	lsls	r2, r2, #0x18
 8004a58: f002 7240    	and	r2, r2, #0x3000000
; 				 CAN_BTR_TS1_Msk | CAN_BTR_TS2_Msk)) |
 8004a5c: 431a         	orrs	r2, r3
; 	     (((timing->phase_seg1 - 1) << CAN_BTR_TS1_Pos) & CAN_BTR_TS1_Msk) |
 8004a5e: 683b         	ldr	r3, [r7]
 8004a60: 889b         	ldrh	r3, [r3, #0x4]
 8004a62: 3b01         	subs	r3, #0x1
 8004a64: 041b         	lsls	r3, r3, #0x10
 8004a66: f403 2370    	and	r3, r3, #0xf0000
; 	     (((timing->sjw        - 1) << CAN_BTR_SJW_Pos) & CAN_BTR_SJW_Msk) |
 8004a6a: 431a         	orrs	r2, r3
; 	     (((timing->phase_seg2 - 1) << CAN_BTR_TS2_Pos) & CAN_BTR_TS2_Msk) |
 8004a6c: 683b         	ldr	r3, [r7]
 8004a6e: 88db         	ldrh	r3, [r3, #0x6]
 8004a70: 3b01         	subs	r3, #0x1
 8004a72: 051b         	lsls	r3, r3, #0x14
 8004a74: f403 03e0    	and	r3, r3, #0x700000
; 	     (((timing->phase_seg1 - 1) << CAN_BTR_TS1_Pos) & CAN_BTR_TS1_Msk) |
 8004a78: 431a         	orrs	r2, r3
; 	     (((timing->prescaler  - 1) << CAN_BTR_BRP_Pos) & CAN_BTR_BRP_Msk);
 8004a7a: 683b         	ldr	r3, [r7]
 8004a7c: 891b         	ldrh	r3, [r3, #0x8]
 8004a7e: 3b01         	subs	r3, #0x1
 8004a80: f3c3 0309    	ubfx	r3, r3, #0x0, #0xa
; 	     (((timing->phase_seg2 - 1) << CAN_BTR_TS2_Pos) & CAN_BTR_TS2_Msk) |
 8004a84: 431a         	orrs	r2, r3
; 	can->BTR = (can->BTR & ~(CAN_BTR_SJW_Msk | CAN_BTR_BRP_Msk |
 8004a86: 693b         	ldr	r3, [r7, #0x10]
 8004a88: 61da         	str	r2, [r3, #0x1c]
; 	k_mutex_unlock(&data->inst_mutex);
 8004a8a: 68fb         	ldr	r3, [r7, #0xc]
 8004a8c: 3310         	adds	r3, #0x10
 8004a8e: 4618         	mov	r0, r3
 8004a90: f00e fb15    	bl	0x80130be <k_mutex_unlock> @ imm = #0xe62a
; 	return 0;
 8004a94: 2100         	movs	r1, #0x0
; }
 8004a96: 460b         	mov	r3, r1
 8004a98: 4618         	mov	r0, r3
 8004a9a: 3718         	adds	r7, #0x18
 8004a9c: 46bd         	mov	sp, r7
 8004a9e: bd80         	pop	{r7, pc}

08004aa0 <$d>:
 8004aa0: 00 fc 80 fc  	.word	0xfc80fc00

08004aa4 <can_stm32_get_core_clock>:
; {
 8004aa4: b580         	push	{r7, lr}
 8004aa6: b08c         	sub	sp, #0x30
 8004aa8: af04         	add	r7, sp, #0x10
 8004aaa: 6078         	str	r0, [r7, #0x4]
 8004aac: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8004aae: 687b         	ldr	r3, [r7, #0x4]
 8004ab0: 685b         	ldr	r3, [r3, #0x4]
 8004ab2: 61fb         	str	r3, [r7, #0x1c]
; 	clock = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8004ab4: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8004b18 <can_stm32_get_core_clock+0x74>
 8004ab6: 61bb         	str	r3, [r7, #0x18]
; 				     (clock_control_subsys_t) &cfg->pclken,
 8004ab8: 69fb         	ldr	r3, [r7, #0x1c]
 8004aba: 331c         	adds	r3, #0x1c
; 	ret = clock_control_get_rate(clock,
 8004abc: 683a         	ldr	r2, [r7]
 8004abe: 4619         	mov	r1, r3
 8004ac0: 69b8         	ldr	r0, [r7, #0x18]
 8004ac2: f00e fb83    	bl	0x80131cc <clock_control_get_rate> @ imm = #0xe706
 8004ac6: 6178         	str	r0, [r7, #0x14]
; 	if (ret != 0) {
 8004ac8: 697b         	ldr	r3, [r7, #0x14]
 8004aca: 2b00         	cmp	r3, #0x0
 8004acc: d01e         	beq	0x8004b0c <can_stm32_get_core_clock+0x68> @ imm = #0x3c
; 		LOG_ERR("Failed call clock_control_get_rate: return [%d]", ret);
 8004ace: 2303         	movs	r3, #0x3
 8004ad0: 2b00         	cmp	r3, #0x0
 8004ad2: d018         	beq	0x8004b06 <can_stm32_get_core_clock+0x62> @ imm = #0x30
 8004ad4: 2301         	movs	r3, #0x1
 8004ad6: 74fb         	strb	r3, [r7, #0x13]
 8004ad8: 7cfb         	ldrb	r3, [r7, #0x13]
 8004ada: f083 0301    	eor	r3, r3, #0x1
 8004ade: b2db         	uxtb	r3, r3
 8004ae0: 2b00         	cmp	r3, #0x0
 8004ae2: d110         	bne	0x8004b06 <can_stm32_get_core_clock+0x62> @ imm = #0x20
 8004ae4: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8004b1c <can_stm32_get_core_clock+0x78>
 8004ae6: 6819         	ldr	r1, [r3]
 8004ae8: 697b         	ldr	r3, [r7, #0x14]
 8004aea: 9303         	str	r3, [sp, #0xc]
 8004aec: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004b20 <can_stm32_get_core_clock+0x7c>
 8004aee: 9302         	str	r3, [sp, #0x8]
 8004af0: 2300         	movs	r3, #0x0
 8004af2: 9301         	str	r3, [sp, #0x4]
 8004af4: 2300         	movs	r3, #0x0
 8004af6: 9300         	str	r3, [sp]
 8004af8: 2300         	movs	r3, #0x0
 8004afa: 2201         	movs	r2, #0x1
 8004afc: 2000         	movs	r0, #0x0
 8004afe: f00e fbb1    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe762
 8004b02: 2300         	movs	r3, #0x0
 8004b04: 60fb         	str	r3, [r7, #0xc]
; 		return -EIO;
 8004b06: f06f 0304    	mvn	r3, #0x4
 8004b0a: e000         	b	0x8004b0e <can_stm32_get_core_clock+0x6a> @ imm = #0x0
; 	return 0;
 8004b0c: 2300         	movs	r3, #0x0
; }
 8004b0e: 4618         	mov	r0, r3
 8004b10: 3720         	adds	r7, #0x20
 8004b12: 46bd         	mov	sp, r7
 8004b14: bd80         	pop	{r7, pc}
 8004b16: bf00         	nop

08004b18 <$d>:
 8004b18: d8 ac 01 08  	.word	0x0801acd8
 8004b1c: 54 04 00 20  	.word	0x20000454
 8004b20: fc bb 01 08  	.word	0x0801bbfc

08004b24 <can_stm32_init>:
; {
 8004b24: b580         	push	{r7, lr}
 8004b26: b0a6         	sub	sp, #0x98
 8004b28: af08         	add	r7, sp, #0x20
 8004b2a: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8004b2c: 687b         	ldr	r3, [r7, #0x4]
 8004b2e: 685b         	ldr	r3, [r3, #0x4]
 8004b30: 663b         	str	r3, [r7, #0x60]
; 	struct can_stm32_data *data = dev->data;
 8004b32: 687b         	ldr	r3, [r7, #0x4]
 8004b34: 691b         	ldr	r3, [r3, #0x10]
 8004b36: 66bb         	str	r3, [r7, #0x68]
; 	CAN_TypeDef *can = cfg->can;
 8004b38: 6e3b         	ldr	r3, [r7, #0x60]
 8004b3a: 695b         	ldr	r3, [r3, #0x14]
 8004b3c: 667b         	str	r3, [r7, #0x64]
; 	struct can_timing timing = { 0 };
 8004b3e: f107 030c    	add.w	r3, r7, #0xc
 8004b42: 2200         	movs	r2, #0x0
 8004b44: 601a         	str	r2, [r3]
 8004b46: 605a         	str	r2, [r3, #0x4]
 8004b48: 811a         	strh	r2, [r3, #0x8]
; 	k_mutex_init(&filter_mutex);
 8004b4a: 4886         	ldr	r0, [pc, #0x218]        @ 0x8004d64 <can_stm32_init+0x240>
 8004b4c: f00e fa9b    	bl	0x8013086 <k_mutex_init> @ imm = #0xe536
; 	k_mutex_init(&data->inst_mutex);
 8004b50: 6ebb         	ldr	r3, [r7, #0x68]
 8004b52: 3310         	adds	r3, #0x10
 8004b54: 4618         	mov	r0, r3
 8004b56: f00e fa96    	bl	0x8013086 <k_mutex_init> @ imm = #0xe52c
; 	k_sem_init(&data->tx_int_sem, 0, 1);
 8004b5a: 6ebb         	ldr	r3, [r7, #0x68]
 8004b5c: 3324         	adds	r3, #0x24
 8004b5e: 2201         	movs	r2, #0x1
 8004b60: 2100         	movs	r1, #0x0
 8004b62: 4618         	mov	r0, r3
 8004b64: f00e fab7    	bl	0x80130d6 <k_sem_init>  @ imm = #0xe56e
; 	if (cfg->common.phy != NULL) {
 8004b68: 6e3b         	ldr	r3, [r7, #0x60]
 8004b6a: 681b         	ldr	r3, [r3]
 8004b6c: 2b00         	cmp	r3, #0x0
 8004b6e: d029         	beq	0x8004bc4 <can_stm32_init+0xa0> @ imm = #0x52
; 		if (!device_is_ready(cfg->common.phy)) {
 8004b70: 6e3b         	ldr	r3, [r7, #0x60]
 8004b72: 681b         	ldr	r3, [r3]
 8004b74: 4618         	mov	r0, r3
 8004b76: f00e fa6c    	bl	0x8013052 <device_is_ready> @ imm = #0xe4d8
 8004b7a: 4603         	mov	r3, r0
 8004b7c: f083 0301    	eor	r3, r3, #0x1
 8004b80: b2db         	uxtb	r3, r3
 8004b82: 2b00         	cmp	r3, #0x0
 8004b84: d01e         	beq	0x8004bc4 <can_stm32_init+0xa0> @ imm = #0x3c
; 			LOG_ERR("CAN transceiver not ready");
 8004b86: 2303         	movs	r3, #0x3
 8004b88: 2b00         	cmp	r3, #0x0
 8004b8a: d018         	beq	0x8004bbe <can_stm32_init+0x9a> @ imm = #0x30
 8004b8c: 2301         	movs	r3, #0x1
 8004b8e: f887 306f    	strb.w	r3, [r7, #0x6f]
 8004b92: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 8004b96: f083 0301    	eor	r3, r3, #0x1
 8004b9a: b2db         	uxtb	r3, r3
 8004b9c: 2b00         	cmp	r3, #0x0
 8004b9e: d10e         	bne	0x8004bbe <can_stm32_init+0x9a> @ imm = #0x1c
 8004ba0: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8004d68 <can_stm32_init+0x244>
 8004ba2: 6819         	ldr	r1, [r3]
 8004ba4: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8004d6c <can_stm32_init+0x248>
 8004ba6: 9302         	str	r3, [sp, #0x8]
 8004ba8: 2300         	movs	r3, #0x0
 8004baa: 9301         	str	r3, [sp, #0x4]
 8004bac: 2300         	movs	r3, #0x0
 8004bae: 9300         	str	r3, [sp]
 8004bb0: 2300         	movs	r3, #0x0
 8004bb2: 2201         	movs	r2, #0x1
 8004bb4: 2000         	movs	r0, #0x0
 8004bb6: f00e fb55    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe6aa
 8004bba: 2300         	movs	r3, #0x0
 8004bbc: 673b         	str	r3, [r7, #0x70]
; 			return -ENODEV;
 8004bbe: f06f 0312    	mvn	r3, #0x12
 8004bc2: e1a8         	b	0x8004f16 <can_stm32_init+0x3f2> @ imm = #0x350
; 	clock = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8004bc4: 4b6a         	ldr	r3, [pc, #0x1a8]        @ 0x8004d70 <can_stm32_init+0x24c>
 8004bc6: 677b         	str	r3, [r7, #0x74]
; 	if (!device_is_ready(clock)) {
 8004bc8: 6f78         	ldr	r0, [r7, #0x74]
 8004bca: f00e fa42    	bl	0x8013052 <device_is_ready> @ imm = #0xe484
 8004bce: 4603         	mov	r3, r0
 8004bd0: f083 0301    	eor	r3, r3, #0x1
 8004bd4: b2db         	uxtb	r3, r3
 8004bd6: 2b00         	cmp	r3, #0x0
 8004bd8: d01c         	beq	0x8004c14 <can_stm32_init+0xf0> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 8004bda: 2303         	movs	r3, #0x3
 8004bdc: 2b00         	cmp	r3, #0x0
 8004bde: d016         	beq	0x8004c0e <can_stm32_init+0xea> @ imm = #0x2c
 8004be0: 2301         	movs	r3, #0x1
 8004be2: 77fb         	strb	r3, [r7, #0x1f]
 8004be4: 7ffb         	ldrb	r3, [r7, #0x1f]
 8004be6: f083 0301    	eor	r3, r3, #0x1
 8004bea: b2db         	uxtb	r3, r3
 8004bec: 2b00         	cmp	r3, #0x0
 8004bee: d10e         	bne	0x8004c0e <can_stm32_init+0xea> @ imm = #0x1c
 8004bf0: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8004d68 <can_stm32_init+0x244>
 8004bf2: 6819         	ldr	r1, [r3]
 8004bf4: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x8004d74 <can_stm32_init+0x250>
 8004bf6: 9302         	str	r3, [sp, #0x8]
 8004bf8: 2300         	movs	r3, #0x0
 8004bfa: 9301         	str	r3, [sp, #0x4]
 8004bfc: 2300         	movs	r3, #0x0
 8004bfe: 9300         	str	r3, [sp]
 8004c00: 2300         	movs	r3, #0x0
 8004c02: 2201         	movs	r2, #0x1
 8004c04: 2000         	movs	r0, #0x0
 8004c06: f00e fb2d    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe65a
 8004c0a: 2300         	movs	r3, #0x0
 8004c0c: 61bb         	str	r3, [r7, #0x18]
; 		return -ENODEV;
 8004c0e: f06f 0312    	mvn	r3, #0x12
 8004c12: e180         	b	0x8004f16 <can_stm32_init+0x3f2> @ imm = #0x300
; 	ret = clock_control_on(clock, (clock_control_subsys_t) &cfg->pclken);
 8004c14: 6e3b         	ldr	r3, [r7, #0x60]
 8004c16: 331c         	adds	r3, #0x1c
 8004c18: 4619         	mov	r1, r3
 8004c1a: 6f78         	ldr	r0, [r7, #0x74]
 8004c1c: f00e fac4    	bl	0x80131a8 <clock_control_on> @ imm = #0xe588
 8004c20: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret != 0) {
 8004c22: 6dfb         	ldr	r3, [r7, #0x5c]
 8004c24: 2b00         	cmp	r3, #0x0
 8004c26: d020         	beq	0x8004c6a <can_stm32_init+0x146> @ imm = #0x40
; 		LOG_ERR("HAL_CAN_Init clock control on failed: %d", ret);
 8004c28: 2303         	movs	r3, #0x3
 8004c2a: 2b00         	cmp	r3, #0x0
 8004c2c: d01a         	beq	0x8004c64 <can_stm32_init+0x140> @ imm = #0x34
 8004c2e: 2301         	movs	r3, #0x1
 8004c30: f887 3027    	strb.w	r3, [r7, #0x27]
 8004c34: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8004c38: f083 0301    	eor	r3, r3, #0x1
 8004c3c: b2db         	uxtb	r3, r3
 8004c3e: 2b00         	cmp	r3, #0x0
 8004c40: d110         	bne	0x8004c64 <can_stm32_init+0x140> @ imm = #0x20
 8004c42: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8004d68 <can_stm32_init+0x244>
 8004c44: 6819         	ldr	r1, [r3]
 8004c46: 6dfb         	ldr	r3, [r7, #0x5c]
 8004c48: 9303         	str	r3, [sp, #0xc]
 8004c4a: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8004d78 <can_stm32_init+0x254>
 8004c4c: 9302         	str	r3, [sp, #0x8]
 8004c4e: 2300         	movs	r3, #0x0
 8004c50: 9301         	str	r3, [sp, #0x4]
 8004c52: 2300         	movs	r3, #0x0
 8004c54: 9300         	str	r3, [sp]
 8004c56: 2300         	movs	r3, #0x0
 8004c58: 2201         	movs	r2, #0x1
 8004c5a: 2000         	movs	r0, #0x0
 8004c5c: f00e fb02    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe604
 8004c60: 2300         	movs	r3, #0x0
 8004c62: 623b         	str	r3, [r7, #0x20]
; 		return -EIO;
 8004c64: f06f 0304    	mvn	r3, #0x4
 8004c68: e155         	b	0x8004f16 <can_stm32_init+0x3f2> @ imm = #0x2aa
; 	ret = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
 8004c6a: 6e3b         	ldr	r3, [r7, #0x60]
 8004c6c: 6a9b         	ldr	r3, [r3, #0x28]
 8004c6e: 2100         	movs	r1, #0x0
 8004c70: 4618         	mov	r0, r3
 8004c72: f00e fada    	bl	0x801322a <pinctrl_apply_state> @ imm = #0xe5b4
 8004c76: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret < 0) {
 8004c78: 6dfb         	ldr	r3, [r7, #0x5c]
 8004c7a: 2b00         	cmp	r3, #0x0
 8004c7c: da1f         	bge	0x8004cbe <can_stm32_init+0x19a> @ imm = #0x3e
; 		LOG_ERR("CAN pinctrl setup failed (%d)", ret);
 8004c7e: 2303         	movs	r3, #0x3
 8004c80: 2b00         	cmp	r3, #0x0
 8004c82: d01a         	beq	0x8004cba <can_stm32_init+0x196> @ imm = #0x34
 8004c84: 2301         	movs	r3, #0x1
 8004c86: f887 302f    	strb.w	r3, [r7, #0x2f]
 8004c8a: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8004c8e: f083 0301    	eor	r3, r3, #0x1
 8004c92: b2db         	uxtb	r3, r3
 8004c94: 2b00         	cmp	r3, #0x0
 8004c96: d110         	bne	0x8004cba <can_stm32_init+0x196> @ imm = #0x20
 8004c98: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8004d68 <can_stm32_init+0x244>
 8004c9a: 6819         	ldr	r1, [r3]
 8004c9c: 6dfb         	ldr	r3, [r7, #0x5c]
 8004c9e: 9303         	str	r3, [sp, #0xc]
 8004ca0: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8004d7c <can_stm32_init+0x258>
 8004ca2: 9302         	str	r3, [sp, #0x8]
 8004ca4: 2300         	movs	r3, #0x0
 8004ca6: 9301         	str	r3, [sp, #0x4]
 8004ca8: 2300         	movs	r3, #0x0
 8004caa: 9300         	str	r3, [sp]
 8004cac: 2300         	movs	r3, #0x0
 8004cae: 2201         	movs	r2, #0x1
 8004cb0: 2000         	movs	r0, #0x0
 8004cb2: f00e fad7    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe5ae
 8004cb6: 2300         	movs	r3, #0x0
 8004cb8: 62bb         	str	r3, [r7, #0x28]
; 		return ret;
 8004cba: 6dfb         	ldr	r3, [r7, #0x5c]
 8004cbc: e12b         	b	0x8004f16 <can_stm32_init+0x3f2> @ imm = #0x256
; 	ret = can_stm32_enter_init_mode(can);
 8004cbe: 6e78         	ldr	r0, [r7, #0x64]
 8004cc0: f7ff fc3c    	bl	0x800453c <can_stm32_enter_init_mode> @ imm = #-0x788
 8004cc4: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 8004cc6: 6dfb         	ldr	r3, [r7, #0x5c]
 8004cc8: 2b00         	cmp	r3, #0x0
 8004cca: d01d         	beq	0x8004d08 <can_stm32_init+0x1e4> @ imm = #0x3a
; 		LOG_ERR("Failed to enter init mode");
 8004ccc: 2303         	movs	r3, #0x3
 8004cce: 2b00         	cmp	r3, #0x0
 8004cd0: d018         	beq	0x8004d04 <can_stm32_init+0x1e0> @ imm = #0x30
 8004cd2: 2301         	movs	r3, #0x1
 8004cd4: f887 3037    	strb.w	r3, [r7, #0x37]
 8004cd8: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8004cdc: f083 0301    	eor	r3, r3, #0x1
 8004ce0: b2db         	uxtb	r3, r3
 8004ce2: 2b00         	cmp	r3, #0x0
 8004ce4: d10e         	bne	0x8004d04 <can_stm32_init+0x1e0> @ imm = #0x1c
 8004ce6: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8004d68 <can_stm32_init+0x244>
 8004ce8: 6819         	ldr	r1, [r3]
 8004cea: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8004d80 <can_stm32_init+0x25c>
 8004cec: 9302         	str	r3, [sp, #0x8]
 8004cee: 2300         	movs	r3, #0x0
 8004cf0: 9301         	str	r3, [sp, #0x4]
 8004cf2: 2300         	movs	r3, #0x0
 8004cf4: 9300         	str	r3, [sp]
 8004cf6: 2300         	movs	r3, #0x0
 8004cf8: 2201         	movs	r2, #0x1
 8004cfa: 2000         	movs	r0, #0x0
 8004cfc: f00e fab2    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe564
 8004d00: 2300         	movs	r3, #0x0
 8004d02: 633b         	str	r3, [r7, #0x30]
; 		return ret;
 8004d04: 6dfb         	ldr	r3, [r7, #0x5c]
 8004d06: e106         	b	0x8004f16 <can_stm32_init+0x3f2> @ imm = #0x20c
; 	ret = can_stm32_leave_sleep_mode(can);
 8004d08: 6e78         	ldr	r0, [r7, #0x64]
 8004d0a: f7ff fc69    	bl	0x80045e0 <can_stm32_leave_sleep_mode> @ imm = #-0x72e
 8004d0e: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 8004d10: 6dfb         	ldr	r3, [r7, #0x5c]
 8004d12: 2b00         	cmp	r3, #0x0
 8004d14: d01d         	beq	0x8004d52 <can_stm32_init+0x22e> @ imm = #0x3a
; 		LOG_ERR("Failed to exit sleep mode");
 8004d16: 2303         	movs	r3, #0x3
 8004d18: 2b00         	cmp	r3, #0x0
 8004d1a: d018         	beq	0x8004d4e <can_stm32_init+0x22a> @ imm = #0x30
 8004d1c: 2301         	movs	r3, #0x1
 8004d1e: f887 303f    	strb.w	r3, [r7, #0x3f]
 8004d22: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8004d26: f083 0301    	eor	r3, r3, #0x1
 8004d2a: b2db         	uxtb	r3, r3
 8004d2c: 2b00         	cmp	r3, #0x0
 8004d2e: d10e         	bne	0x8004d4e <can_stm32_init+0x22a> @ imm = #0x1c
 8004d30: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8004d68 <can_stm32_init+0x244>
 8004d32: 6819         	ldr	r1, [r3]
 8004d34: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8004d84 <can_stm32_init+0x260>
 8004d36: 9302         	str	r3, [sp, #0x8]
 8004d38: 2300         	movs	r3, #0x0
 8004d3a: 9301         	str	r3, [sp, #0x4]
 8004d3c: 2300         	movs	r3, #0x0
 8004d3e: 9300         	str	r3, [sp]
 8004d40: 2300         	movs	r3, #0x0
 8004d42: 2201         	movs	r2, #0x1
 8004d44: 2000         	movs	r0, #0x0
 8004d46: f00e fa8d    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe51a
 8004d4a: 2300         	movs	r3, #0x0
 8004d4c: 63bb         	str	r3, [r7, #0x38]
; 		return ret;
 8004d4e: 6dfb         	ldr	r3, [r7, #0x5c]
 8004d50: e0e1         	b	0x8004f16 <can_stm32_init+0x3f2> @ imm = #0x1c2
; 	bank_offset = (cfg->can == cfg->master_can) ? 0 : CAN_STM32_NUM_FILTER_BANKS;
 8004d52: 6e3b         	ldr	r3, [r7, #0x60]
 8004d54: 695a         	ldr	r2, [r3, #0x14]
 8004d56: 6e3b         	ldr	r3, [r7, #0x60]
 8004d58: 699b         	ldr	r3, [r3, #0x18]
 8004d5a: 429a         	cmp	r2, r3
 8004d5c: d114         	bne	0x8004d88 <can_stm32_init+0x264> @ imm = #0x28
 8004d5e: 2300         	movs	r3, #0x0
 8004d60: e013         	b	0x8004d8a <can_stm32_init+0x266> @ imm = #0x26
 8004d62: bf00         	nop

08004d64 <$d>:
 8004d64: e4 0b 00 20  	.word	0x20000be4
 8004d68: 54 04 00 20  	.word	0x20000454
 8004d6c: 2c bc 01 08  	.word	0x0801bc2c
 8004d70: d8 ac 01 08  	.word	0x0801acd8
 8004d74: 48 bc 01 08  	.word	0x0801bc48
 8004d78: 68 bc 01 08  	.word	0x0801bc68
 8004d7c: 94 bc 01 08  	.word	0x0801bc94
 8004d80: b4 bb 01 08  	.word	0x0801bbb4
 8004d84: b4 bc 01 08  	.word	0x0801bcb4

08004d88 <$t>:
 8004d88: 230e         	movs	r3, #0xe
 8004d8a: 65bb         	str	r3, [r7, #0x58]
; 	cfg->master_can->FMR |= CAN_FMR_FINIT;
 8004d8c: 6e3b         	ldr	r3, [r7, #0x60]
 8004d8e: 699b         	ldr	r3, [r3, #0x18]
 8004d90: f8d3 2200    	ldr.w	r2, [r3, #0x200]
 8004d94: 6e3b         	ldr	r3, [r7, #0x60]
 8004d96: 699b         	ldr	r3, [r3, #0x18]
 8004d98: f042 0201    	orr	r2, r2, #0x1
 8004d9c: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	cfg->master_can->FS1R |= ((1U << CONFIG_CAN_MAX_EXT_ID_FILTER) - 1) << bank_offset;
 8004da0: 6e3b         	ldr	r3, [r7, #0x60]
 8004da2: 699b         	ldr	r3, [r3, #0x18]
 8004da4: f8d3 120c    	ldr.w	r1, [r3, #0x20c]
 8004da8: 227f         	movs	r2, #0x7f
 8004daa: 6dbb         	ldr	r3, [r7, #0x58]
 8004dac: 409a         	lsls	r2, r3
 8004dae: 6e3b         	ldr	r3, [r7, #0x60]
 8004db0: 699b         	ldr	r3, [r3, #0x18]
 8004db2: 430a         	orrs	r2, r1
 8004db4: f8c3 220c    	str.w	r2, [r3, #0x20c]
; 	cfg->master_can->FMR &= ~CAN_FMR_FINIT;
 8004db8: 6e3b         	ldr	r3, [r7, #0x60]
 8004dba: 699b         	ldr	r3, [r3, #0x18]
 8004dbc: f8d3 2200    	ldr.w	r2, [r3, #0x200]
 8004dc0: 6e3b         	ldr	r3, [r7, #0x60]
 8004dc2: 699b         	ldr	r3, [r3, #0x18]
 8004dc4: f022 0201    	bic	r2, r2, #0x1
 8004dc8: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	can->MCR &= ~CAN_MCR_TTCM & ~CAN_MCR_ABOM & ~CAN_MCR_AWUM &
 8004dcc: 6e7b         	ldr	r3, [r7, #0x64]
 8004dce: 681b         	ldr	r3, [r3]
 8004dd0: f023 02fc    	bic	r2, r3, #0xfc
 8004dd4: 6e7b         	ldr	r3, [r7, #0x64]
 8004dd6: 601a         	str	r2, [r3]
; 	can->MCR |= CAN_MCR_ABOM;
 8004dd8: 6e7b         	ldr	r3, [r7, #0x64]
 8004dda: 681b         	ldr	r3, [r3]
 8004ddc: f043 0240    	orr	r2, r3, #0x40
 8004de0: 6e7b         	ldr	r3, [r7, #0x64]
 8004de2: 601a         	str	r2, [r3]
; 	ret = can_calc_timing(dev, &timing, cfg->common.bitrate,
 8004de4: 6e3b         	ldr	r3, [r7, #0x60]
 8004de6: 68da         	ldr	r2, [r3, #0xc]
; 			      cfg->common.sample_point);
 8004de8: 6e3b         	ldr	r3, [r7, #0x60]
 8004dea: 8a1b         	ldrh	r3, [r3, #0x10]
; 	ret = can_calc_timing(dev, &timing, cfg->common.bitrate,
 8004dec: f107 010c    	add.w	r1, r7, #0xc
 8004df0: 6878         	ldr	r0, [r7, #0x4]
 8004df2: f00e f99b    	bl	0x801312c <can_calc_timing> @ imm = #0xe336
 8004df6: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret == -EINVAL) {
 8004df8: 6dfb         	ldr	r3, [r7, #0x5c]
 8004dfa: f113 0f16    	cmn.w	r3, #0x16
 8004dfe: d11e         	bne	0x8004e3e <can_stm32_init+0x31a> @ imm = #0x3c
; 		LOG_ERR("Can't find timing for given param");
 8004e00: 2303         	movs	r3, #0x3
 8004e02: 2b00         	cmp	r3, #0x0
 8004e04: d018         	beq	0x8004e38 <can_stm32_init+0x314> @ imm = #0x30
 8004e06: 2301         	movs	r3, #0x1
 8004e08: f887 3047    	strb.w	r3, [r7, #0x47]
 8004e0c: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8004e10: f083 0301    	eor	r3, r3, #0x1
 8004e14: b2db         	uxtb	r3, r3
 8004e16: 2b00         	cmp	r3, #0x0
 8004e18: d10e         	bne	0x8004e38 <can_stm32_init+0x314> @ imm = #0x1c
 8004e1a: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8004f20 <can_stm32_init+0x3fc>
 8004e1c: 6819         	ldr	r1, [r3]
 8004e1e: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8004f24 <can_stm32_init+0x400>
 8004e20: 9302         	str	r3, [sp, #0x8]
 8004e22: 2300         	movs	r3, #0x0
 8004e24: 9301         	str	r3, [sp, #0x4]
 8004e26: 2300         	movs	r3, #0x0
 8004e28: 9300         	str	r3, [sp]
 8004e2a: 2300         	movs	r3, #0x0
 8004e2c: 2201         	movs	r2, #0x1
 8004e2e: 2000         	movs	r0, #0x0
 8004e30: f00e fa18    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe430
 8004e34: 2300         	movs	r3, #0x0
 8004e36: 643b         	str	r3, [r7, #0x40]
; 		return -EIO;
 8004e38: f06f 0304    	mvn	r3, #0x4
 8004e3c: e06b         	b	0x8004f16 <can_stm32_init+0x3f2> @ imm = #0xd6
; 	LOG_DBG("Presc: %d, TS1: %d, TS2: %d",
 8004e3e: 2303         	movs	r3, #0x3
 8004e40: 2b03         	cmp	r3, #0x3
 8004e42: d920         	bls	0x8004e86 <can_stm32_init+0x362> @ imm = #0x40
 8004e44: 2301         	movs	r3, #0x1
 8004e46: f887 3057    	strb.w	r3, [r7, #0x57]
 8004e4a: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8004e4e: f083 0301    	eor	r3, r3, #0x1
 8004e52: b2db         	uxtb	r3, r3
 8004e54: 2b00         	cmp	r3, #0x0
 8004e56: d116         	bne	0x8004e86 <can_stm32_init+0x362> @ imm = #0x2c
 8004e58: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8004f20 <can_stm32_init+0x3fc>
 8004e5a: 6819         	ldr	r1, [r3]
 8004e5c: 8abb         	ldrh	r3, [r7, #0x14]
 8004e5e: 8a3a         	ldrh	r2, [r7, #0x10]
 8004e60: 8a78         	ldrh	r0, [r7, #0x12]
 8004e62: 9006         	str	r0, [sp, #0x18]
 8004e64: 9205         	str	r2, [sp, #0x14]
 8004e66: 9304         	str	r3, [sp, #0x10]
 8004e68: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8004f28 <can_stm32_init+0x404>
 8004e6a: 9303         	str	r3, [sp, #0xc]
 8004e6c: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8004f2c <can_stm32_init+0x408>
 8004e6e: 9302         	str	r3, [sp, #0x8]
 8004e70: 2308         	movs	r3, #0x8
 8004e72: 9301         	str	r3, [sp, #0x4]
 8004e74: 2300         	movs	r3, #0x0
 8004e76: 9300         	str	r3, [sp]
 8004e78: 2300         	movs	r3, #0x0
 8004e7a: 2204         	movs	r2, #0x4
 8004e7c: 2000         	movs	r0, #0x0
 8004e7e: f00e f9f1    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe3e2
 8004e82: 2300         	movs	r3, #0x0
 8004e84: 653b         	str	r3, [r7, #0x50]
; 	LOG_DBG("Sample-point err : %d", ret);
 8004e86: 2303         	movs	r3, #0x3
 8004e88: 2b03         	cmp	r3, #0x3
 8004e8a: d91c         	bls	0x8004ec6 <can_stm32_init+0x3a2> @ imm = #0x38
 8004e8c: 2301         	movs	r3, #0x1
 8004e8e: f887 304f    	strb.w	r3, [r7, #0x4f]
 8004e92: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 8004e96: f083 0301    	eor	r3, r3, #0x1
 8004e9a: b2db         	uxtb	r3, r3
 8004e9c: 2b00         	cmp	r3, #0x0
 8004e9e: d112         	bne	0x8004ec6 <can_stm32_init+0x3a2> @ imm = #0x24
 8004ea0: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8004f20 <can_stm32_init+0x3fc>
 8004ea2: 6819         	ldr	r1, [r3]
 8004ea4: 6dfb         	ldr	r3, [r7, #0x5c]
 8004ea6: 9304         	str	r3, [sp, #0x10]
 8004ea8: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8004f28 <can_stm32_init+0x404>
 8004eaa: 9303         	str	r3, [sp, #0xc]
 8004eac: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8004f30 <can_stm32_init+0x40c>
 8004eae: 9302         	str	r3, [sp, #0x8]
 8004eb0: 2308         	movs	r3, #0x8
 8004eb2: 9301         	str	r3, [sp, #0x4]
 8004eb4: 2300         	movs	r3, #0x0
 8004eb6: 9300         	str	r3, [sp]
 8004eb8: 2300         	movs	r3, #0x0
 8004eba: 2204         	movs	r2, #0x4
 8004ebc: 2000         	movs	r0, #0x0
 8004ebe: f00e f9d1    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe3a2
 8004ec2: 2300         	movs	r3, #0x0
 8004ec4: 64bb         	str	r3, [r7, #0x48]
; 	ret = can_set_timing(dev, &timing);
 8004ec6: f107 030c    	add.w	r3, r7, #0xc
 8004eca: 4619         	mov	r1, r3
 8004ecc: 6878         	ldr	r0, [r7, #0x4]
 8004ece: f00e f93f    	bl	0x8013150 <can_set_timing> @ imm = #0xe27e
 8004ed2: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 8004ed4: 6dfb         	ldr	r3, [r7, #0x5c]
 8004ed6: 2b00         	cmp	r3, #0x0
 8004ed8: d001         	beq	0x8004ede <can_stm32_init+0x3ba> @ imm = #0x2
; 		return ret;
 8004eda: 6dfb         	ldr	r3, [r7, #0x5c]
 8004edc: e01b         	b	0x8004f16 <can_stm32_init+0x3f2> @ imm = #0x36
; 	ret = can_stm32_set_mode(dev, CAN_MODE_NORMAL);
 8004ede: 2100         	movs	r1, #0x0
 8004ee0: 6878         	ldr	r0, [r7, #0x4]
 8004ee2: f7ff fcdd    	bl	0x80048a0 <can_stm32_set_mode> @ imm = #-0x646
 8004ee6: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 8004ee8: 6dfb         	ldr	r3, [r7, #0x5c]
 8004eea: 2b00         	cmp	r3, #0x0
 8004eec: d001         	beq	0x8004ef2 <can_stm32_init+0x3ce> @ imm = #0x2
; 		return ret;
 8004eee: 6dfb         	ldr	r3, [r7, #0x5c]
 8004ef0: e011         	b	0x8004f16 <can_stm32_init+0x3f2> @ imm = #0x22
; 	(void)can_stm32_get_state(dev, &data->state, NULL);
 8004ef2: 6ebb         	ldr	r3, [r7, #0x68]
 8004ef4: 33f4         	adds	r3, #0xf4
 8004ef6: 2200         	movs	r2, #0x0
 8004ef8: 4619         	mov	r1, r3
 8004efa: 6878         	ldr	r0, [r7, #0x4]
 8004efc: f00e fa2d    	bl	0x801335a <can_stm32_get_state> @ imm = #0xe45a
; 	cfg->config_irq(can);
 8004f00: 6e3b         	ldr	r3, [r7, #0x60]
 8004f02: 6a5b         	ldr	r3, [r3, #0x24]
 8004f04: 6e78         	ldr	r0, [r7, #0x64]
 8004f06: 4798         	blx	r3
; 	can->IER |= CAN_IER_TMEIE;
 8004f08: 6e7b         	ldr	r3, [r7, #0x64]
 8004f0a: 695b         	ldr	r3, [r3, #0x14]
 8004f0c: f043 0201    	orr	r2, r3, #0x1
 8004f10: 6e7b         	ldr	r3, [r7, #0x64]
 8004f12: 615a         	str	r2, [r3, #0x14]
; 	return 0;
 8004f14: 2300         	movs	r3, #0x0
; }
 8004f16: 4618         	mov	r0, r3
 8004f18: 3778         	adds	r7, #0x78
 8004f1a: 46bd         	mov	sp, r7
 8004f1c: bd80         	pop	{r7, pc}
 8004f1e: bf00         	nop

08004f20 <$d>:
 8004f20: 54 04 00 20  	.word	0x20000454
 8004f24: d0 bc 01 08  	.word	0x0801bcd0
 8004f28: 6c d1 01 08  	.word	0x0801d16c
 8004f2c: f4 bc 01 08  	.word	0x0801bcf4
 8004f30: 14 bd 01 08  	.word	0x0801bd14

08004f34 <can_stm32_send>:
; {
 8004f34: b5b0         	push	{r4, r5, r7, lr}
 8004f36: b0a2         	sub	sp, #0x88
 8004f38: af0a         	add	r7, sp, #0x28
 8004f3a: 60f8         	str	r0, [r7, #0xc]
 8004f3c: 60b9         	str	r1, [r7, #0x8]
 8004f3e: e9c7 2300    	strd	r2, r3, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8004f42: 68fb         	ldr	r3, [r7, #0xc]
 8004f44: 685b         	ldr	r3, [r3, #0x4]
 8004f46: 643b         	str	r3, [r7, #0x40]
; 	struct can_stm32_data *data = dev->data;
 8004f48: 68fb         	ldr	r3, [r7, #0xc]
 8004f4a: 691b         	ldr	r3, [r3, #0x10]
 8004f4c: 63fb         	str	r3, [r7, #0x3c]
; 	CAN_TypeDef *can = cfg->can;
 8004f4e: 6c3b         	ldr	r3, [r7, #0x40]
 8004f50: 695b         	ldr	r3, [r3, #0x14]
 8004f52: 63bb         	str	r3, [r7, #0x38]
; 	uint32_t transmit_status_register = 0;
 8004f54: 2300         	movs	r3, #0x0
 8004f56: 65bb         	str	r3, [r7, #0x58]
; 	CAN_TxMailBox_TypeDef *mailbox = NULL;
 8004f58: 2300         	movs	r3, #0x0
 8004f5a: 64fb         	str	r3, [r7, #0x4c]
; 	struct can_stm32_mailbox *mb = NULL;
 8004f5c: 2300         	movs	r3, #0x0
 8004f5e: 64bb         	str	r3, [r7, #0x48]
; 	LOG_DBG("Sending %d bytes on %s. "
 8004f60: 2303         	movs	r3, #0x3
 8004f62: 2b03         	cmp	r3, #0x3
 8004f64: d939         	bls	0x8004fda <can_stm32_send+0xa6> @ imm = #0x72
 8004f66: 2301         	movs	r3, #0x1
 8004f68: f887 3047    	strb.w	r3, [r7, #0x47]
 8004f6c: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8004f70: f083 0301    	eor	r3, r3, #0x1
 8004f74: b2db         	uxtb	r3, r3
 8004f76: 2b00         	cmp	r3, #0x0
 8004f78: d12f         	bne	0x8004fda <can_stm32_send+0xa6> @ imm = #0x5e
 8004f7a: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x80051ec <can_stm32_send+0x2b8>
 8004f7c: 681c         	ldr	r4, [r3]
 8004f7e: 68bb         	ldr	r3, [r7, #0x8]
 8004f80: 791b         	ldrb	r3, [r3, #0x4]
 8004f82: 461d         	mov	r5, r3
 8004f84: 68fb         	ldr	r3, [r7, #0xc]
 8004f86: 681b         	ldr	r3, [r3]
 8004f88: 68ba         	ldr	r2, [r7, #0x8]
 8004f8a: 6812         	ldr	r2, [r2]
 8004f8c: 68b9         	ldr	r1, [r7, #0x8]
 8004f8e: 7949         	ldrb	r1, [r1, #0x5]
 8004f90: f001 0101    	and	r1, r1, #0x1
 8004f94: 2900         	cmp	r1, #0x0
 8004f96: d001         	beq	0x8004f9c <can_stm32_send+0x68> @ imm = #0x2
 8004f98: 4995         	ldr	r1, [pc, #0x254]        @ 0x80051f0 <can_stm32_send+0x2bc>
 8004f9a: e000         	b	0x8004f9e <can_stm32_send+0x6a> @ imm = #0x0
 8004f9c: 4995         	ldr	r1, [pc, #0x254]        @ 0x80051f4 <can_stm32_send+0x2c0>
 8004f9e: 68b8         	ldr	r0, [r7, #0x8]
 8004fa0: 7940         	ldrb	r0, [r0, #0x5]
 8004fa2: f000 0002    	and	r0, r0, #0x2
 8004fa6: 2800         	cmp	r0, #0x0
 8004fa8: d001         	beq	0x8004fae <can_stm32_send+0x7a> @ imm = #0x2
 8004faa: 4893         	ldr	r0, [pc, #0x24c]        @ 0x80051f8 <can_stm32_send+0x2c4>
 8004fac: e000         	b	0x8004fb0 <can_stm32_send+0x7c> @ imm = #0x0
 8004fae: 4893         	ldr	r0, [pc, #0x24c]        @ 0x80051fc <can_stm32_send+0x2c8>
 8004fb0: 9008         	str	r0, [sp, #0x20]
 8004fb2: 9107         	str	r1, [sp, #0x1c]
 8004fb4: 9206         	str	r2, [sp, #0x18]
 8004fb6: 9305         	str	r3, [sp, #0x14]
 8004fb8: 9504         	str	r5, [sp, #0x10]
 8004fba: 4b91         	ldr	r3, [pc, #0x244]        @ 0x8005200 <can_stm32_send+0x2cc>
 8004fbc: 9303         	str	r3, [sp, #0xc]
 8004fbe: 4b91         	ldr	r3, [pc, #0x244]        @ 0x8005204 <can_stm32_send+0x2d0>
 8004fc0: 9302         	str	r3, [sp, #0x8]
 8004fc2: 2308         	movs	r3, #0x8
 8004fc4: 9301         	str	r3, [sp, #0x4]
 8004fc6: 2300         	movs	r3, #0x0
 8004fc8: 9300         	str	r3, [sp]
 8004fca: 2300         	movs	r3, #0x0
 8004fcc: 2204         	movs	r2, #0x4
 8004fce: 4621         	mov	r1, r4
 8004fd0: 2000         	movs	r0, #0x0
 8004fd2: f00e f947    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe28e
 8004fd6: 2300         	movs	r3, #0x0
 8004fd8: 65fb         	str	r3, [r7, #0x5c]
; 	if (frame->dlc > CAN_MAX_DLC) {
 8004fda: 68bb         	ldr	r3, [r7, #0x8]
 8004fdc: 791b         	ldrb	r3, [r3, #0x4]
 8004fde: 2b08         	cmp	r3, #0x8
 8004fe0: d922         	bls	0x8005028 <can_stm32_send+0xf4> @ imm = #0x44
; 		LOG_ERR("DLC of %d exceeds maximum (%d)", frame->dlc, CAN_MAX_DLC);
 8004fe2: 2303         	movs	r3, #0x3
 8004fe4: 2b00         	cmp	r3, #0x0
 8004fe6: d01c         	beq	0x8005022 <can_stm32_send+0xee> @ imm = #0x38
 8004fe8: 2301         	movs	r3, #0x1
 8004fea: 75fb         	strb	r3, [r7, #0x17]
 8004fec: 7dfb         	ldrb	r3, [r7, #0x17]
 8004fee: f083 0301    	eor	r3, r3, #0x1
 8004ff2: b2db         	uxtb	r3, r3
 8004ff4: 2b00         	cmp	r3, #0x0
 8004ff6: d114         	bne	0x8005022 <can_stm32_send+0xee> @ imm = #0x28
 8004ff8: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x80051ec <can_stm32_send+0x2b8>
 8004ffa: 6819         	ldr	r1, [r3]
 8004ffc: 68bb         	ldr	r3, [r7, #0x8]
 8004ffe: 791b         	ldrb	r3, [r3, #0x4]
 8005000: 461a         	mov	r2, r3
 8005002: 2308         	movs	r3, #0x8
 8005004: 9304         	str	r3, [sp, #0x10]
 8005006: 9203         	str	r2, [sp, #0xc]
 8005008: 4b7f         	ldr	r3, [pc, #0x1fc]        @ 0x8005208 <can_stm32_send+0x2d4>
 800500a: 9302         	str	r3, [sp, #0x8]
 800500c: 2300         	movs	r3, #0x0
 800500e: 9301         	str	r3, [sp, #0x4]
 8005010: 2300         	movs	r3, #0x0
 8005012: 9300         	str	r3, [sp]
 8005014: 2300         	movs	r3, #0x0
 8005016: 2201         	movs	r2, #0x1
 8005018: 2000         	movs	r0, #0x0
 800501a: f00e f923    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe246
 800501e: 2300         	movs	r3, #0x0
 8005020: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 8005022: f06f 0315    	mvn	r3, #0x15
 8005026: e174         	b	0x8005312 <can_stm32_send+0x3de> @ imm = #0x2e8
; 	if ((frame->flags & ~(CAN_FRAME_IDE | CAN_FRAME_RTR)) != 0) {
 8005028: 68bb         	ldr	r3, [r7, #0x8]
 800502a: 795b         	ldrb	r3, [r3, #0x5]
 800502c: 2b03         	cmp	r3, #0x3
 800502e: d91f         	bls	0x8005070 <can_stm32_send+0x13c> @ imm = #0x3e
; 		LOG_ERR("unsupported CAN frame flags 0x%02x", frame->flags);
 8005030: 2303         	movs	r3, #0x3
 8005032: 2b00         	cmp	r3, #0x0
 8005034: d019         	beq	0x800506a <can_stm32_send+0x136> @ imm = #0x32
 8005036: 2301         	movs	r3, #0x1
 8005038: 77fb         	strb	r3, [r7, #0x1f]
 800503a: 7ffb         	ldrb	r3, [r7, #0x1f]
 800503c: f083 0301    	eor	r3, r3, #0x1
 8005040: b2db         	uxtb	r3, r3
 8005042: 2b00         	cmp	r3, #0x0
 8005044: d111         	bne	0x800506a <can_stm32_send+0x136> @ imm = #0x22
 8005046: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x80051ec <can_stm32_send+0x2b8>
 8005048: 6819         	ldr	r1, [r3]
 800504a: 68bb         	ldr	r3, [r7, #0x8]
 800504c: 795b         	ldrb	r3, [r3, #0x5]
 800504e: 9303         	str	r3, [sp, #0xc]
 8005050: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x800520c <can_stm32_send+0x2d8>
 8005052: 9302         	str	r3, [sp, #0x8]
 8005054: 2300         	movs	r3, #0x0
 8005056: 9301         	str	r3, [sp, #0x4]
 8005058: 2300         	movs	r3, #0x0
 800505a: 9300         	str	r3, [sp]
 800505c: 2300         	movs	r3, #0x0
 800505e: 2201         	movs	r2, #0x1
 8005060: 2000         	movs	r0, #0x0
 8005062: f00e f8ff    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe1fe
 8005066: 2300         	movs	r3, #0x0
 8005068: 61bb         	str	r3, [r7, #0x18]
; 		return -ENOTSUP;
 800506a: f06f 0385    	mvn	r3, #0x85
 800506e: e150         	b	0x8005312 <can_stm32_send+0x3de> @ imm = #0x2a0
; 	if (!data->common.started) {
 8005070: 6bfb         	ldr	r3, [r7, #0x3c]
 8005072: 791b         	ldrb	r3, [r3, #0x4]
 8005074: f083 0301    	eor	r3, r3, #0x1
 8005078: b2db         	uxtb	r3, r3
 800507a: 2b00         	cmp	r3, #0x0
 800507c: d002         	beq	0x8005084 <can_stm32_send+0x150> @ imm = #0x4
; 		return -ENETDOWN;
 800507e: f06f 0372    	mvn	r3, #0x72
 8005082: e146         	b	0x8005312 <can_stm32_send+0x3de> @ imm = #0x28c
; 	if (can->ESR & CAN_ESR_BOFF) {
 8005084: 6bbb         	ldr	r3, [r7, #0x38]
 8005086: 699b         	ldr	r3, [r3, #0x18]
 8005088: f003 0304    	and	r3, r3, #0x4
 800508c: 2b00         	cmp	r3, #0x0
 800508e: d002         	beq	0x8005096 <can_stm32_send+0x162> @ imm = #0x4
; 		return -ENETUNREACH;
 8005090: f06f 0371    	mvn	r3, #0x71
 8005094: e13d         	b	0x8005312 <can_stm32_send+0x3de> @ imm = #0x27a
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8005096: 6bfb         	ldr	r3, [r7, #0x3c]
 8005098: f103 0410    	add.w	r4, r3, #0x10
 800509c: f04f 30ff    	mov.w	r0, #0xffffffff
 80050a0: f04f 31ff    	mov.w	r1, #0xffffffff
 80050a4: 4602         	mov	r2, r0
 80050a6: 460b         	mov	r3, r1
 80050a8: 4620         	mov	r0, r4
 80050aa: f00d fff8    	bl	0x801309e <k_mutex_lock> @ imm = #0xdff0
; 	transmit_status_register = can->TSR;
 80050ae: 6bbb         	ldr	r3, [r7, #0x38]
 80050b0: 689b         	ldr	r3, [r3, #0x8]
 80050b2: 65bb         	str	r3, [r7, #0x58]
; 	while (!(transmit_status_register & CAN_TSR_TME)) {
 80050b4: e03f         	b	0x8005136 <can_stm32_send+0x202> @ imm = #0x7e
; 		k_mutex_unlock(&data->inst_mutex);
 80050b6: 6bfb         	ldr	r3, [r7, #0x3c]
 80050b8: 3310         	adds	r3, #0x10
 80050ba: 4618         	mov	r0, r3
 80050bc: f00d ffff    	bl	0x80130be <k_mutex_unlock> @ imm = #0xdffe
; 		LOG_DBG("Transmit buffer full");
 80050c0: 2303         	movs	r3, #0x3
 80050c2: 2b03         	cmp	r3, #0x3
 80050c4: d91a         	bls	0x80050fc <can_stm32_send+0x1c8> @ imm = #0x34
 80050c6: 2301         	movs	r3, #0x1
 80050c8: f887 3027    	strb.w	r3, [r7, #0x27]
 80050cc: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80050d0: f083 0301    	eor	r3, r3, #0x1
 80050d4: b2db         	uxtb	r3, r3
 80050d6: 2b00         	cmp	r3, #0x0
 80050d8: d110         	bne	0x80050fc <can_stm32_send+0x1c8> @ imm = #0x20
 80050da: 4b44         	ldr	r3, [pc, #0x110]        @ 0x80051ec <can_stm32_send+0x2b8>
 80050dc: 6819         	ldr	r1, [r3]
 80050de: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8005200 <can_stm32_send+0x2cc>
 80050e0: 9303         	str	r3, [sp, #0xc]
 80050e2: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8005210 <can_stm32_send+0x2dc>
 80050e4: 9302         	str	r3, [sp, #0x8]
 80050e6: 2308         	movs	r3, #0x8
 80050e8: 9301         	str	r3, [sp, #0x4]
 80050ea: 2300         	movs	r3, #0x0
 80050ec: 9300         	str	r3, [sp]
 80050ee: 2300         	movs	r3, #0x0
 80050f0: 2204         	movs	r2, #0x4
 80050f2: 2000         	movs	r0, #0x0
 80050f4: f00e f8b6    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe16c
 80050f8: 2300         	movs	r3, #0x0
 80050fa: 623b         	str	r3, [r7, #0x20]
; 		if (k_sem_take(&data->tx_int_sem, timeout)) {
 80050fc: 6bfb         	ldr	r3, [r7, #0x3c]
 80050fe: f103 0124    	add.w	r1, r3, #0x24
 8005102: e9d7 2300    	ldrd	r2, r3, [r7]
 8005106: 4608         	mov	r0, r1
 8005108: f00d fff5    	bl	0x80130f6 <k_sem_take>  @ imm = #0xdfea
 800510c: 4603         	mov	r3, r0
 800510e: 2b00         	cmp	r3, #0x0
 8005110: d002         	beq	0x8005118 <can_stm32_send+0x1e4> @ imm = #0x4
; 			return -EAGAIN;
 8005112: f06f 030a    	mvn	r3, #0xa
 8005116: e0fc         	b	0x8005312 <can_stm32_send+0x3de> @ imm = #0x1f8
; 		k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8005118: 6bfb         	ldr	r3, [r7, #0x3c]
 800511a: f103 0410    	add.w	r4, r3, #0x10
 800511e: f04f 30ff    	mov.w	r0, #0xffffffff
 8005122: f04f 31ff    	mov.w	r1, #0xffffffff
 8005126: 4602         	mov	r2, r0
 8005128: 460b         	mov	r3, r1
 800512a: 4620         	mov	r0, r4
 800512c: f00d ffb7    	bl	0x801309e <k_mutex_lock> @ imm = #0xdf6e
; 		transmit_status_register = can->TSR;
 8005130: 6bbb         	ldr	r3, [r7, #0x38]
 8005132: 689b         	ldr	r3, [r3, #0x8]
 8005134: 65bb         	str	r3, [r7, #0x58]
; 	while (!(transmit_status_register & CAN_TSR_TME)) {
 8005136: 6dbb         	ldr	r3, [r7, #0x58]
 8005138: f003 53e0    	and	r3, r3, #0x1c000000
 800513c: 2b00         	cmp	r3, #0x0
 800513e: d0ba         	beq	0x80050b6 <can_stm32_send+0x182> @ imm = #-0x8c
; 	if (transmit_status_register & CAN_TSR_TME0) {
 8005140: 6dbb         	ldr	r3, [r7, #0x58]
 8005142: f003 6380    	and	r3, r3, #0x4000000
 8005146: 2b00         	cmp	r3, #0x0
 8005148: d025         	beq	0x8005196 <can_stm32_send+0x262> @ imm = #0x4a
; 		LOG_DBG("Using TX mailbox 0");
 800514a: 2303         	movs	r3, #0x3
 800514c: 2b03         	cmp	r3, #0x3
 800514e: d91a         	bls	0x8005186 <can_stm32_send+0x252> @ imm = #0x34
 8005150: 2301         	movs	r3, #0x1
 8005152: f887 302f    	strb.w	r3, [r7, #0x2f]
 8005156: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800515a: f083 0301    	eor	r3, r3, #0x1
 800515e: b2db         	uxtb	r3, r3
 8005160: 2b00         	cmp	r3, #0x0
 8005162: d110         	bne	0x8005186 <can_stm32_send+0x252> @ imm = #0x20
 8005164: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80051ec <can_stm32_send+0x2b8>
 8005166: 6819         	ldr	r1, [r3]
 8005168: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8005200 <can_stm32_send+0x2cc>
 800516a: 9303         	str	r3, [sp, #0xc]
 800516c: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8005214 <can_stm32_send+0x2e0>
 800516e: 9302         	str	r3, [sp, #0x8]
 8005170: 2308         	movs	r3, #0x8
 8005172: 9301         	str	r3, [sp, #0x4]
 8005174: 2300         	movs	r3, #0x0
 8005176: 9300         	str	r3, [sp]
 8005178: 2300         	movs	r3, #0x0
 800517a: 2204         	movs	r2, #0x4
 800517c: 2000         	movs	r0, #0x0
 800517e: f00e f871    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe0e2
 8005182: 2300         	movs	r3, #0x0
 8005184: 62bb         	str	r3, [r7, #0x28]
; 		mailbox = &can->sTxMailBox[0];
 8005186: 6bbb         	ldr	r3, [r7, #0x38]
 8005188: f503 73c0    	add.w	r3, r3, #0x180
 800518c: 64fb         	str	r3, [r7, #0x4c]
; 		mb = &(data->mb0);
 800518e: 6bfb         	ldr	r3, [r7, #0x3c]
 8005190: 3334         	adds	r3, #0x34
 8005192: 64bb         	str	r3, [r7, #0x48]
 8005194: e06c         	b	0x8005270 <can_stm32_send+0x33c> @ imm = #0xd8
; 	} else if (transmit_status_register & CAN_TSR_TME1) {
 8005196: 6dbb         	ldr	r3, [r7, #0x58]
 8005198: f003 6300    	and	r3, r3, #0x8000000
 800519c: 2b00         	cmp	r3, #0x0
 800519e: d03d         	beq	0x800521c <can_stm32_send+0x2e8> @ imm = #0x7a
; 		LOG_DBG("Using TX mailbox 1");
 80051a0: 2303         	movs	r3, #0x3
 80051a2: 2b03         	cmp	r3, #0x3
 80051a4: d91a         	bls	0x80051dc <can_stm32_send+0x2a8> @ imm = #0x34
 80051a6: 2301         	movs	r3, #0x1
 80051a8: f887 3037    	strb.w	r3, [r7, #0x37]
 80051ac: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80051b0: f083 0301    	eor	r3, r3, #0x1
 80051b4: b2db         	uxtb	r3, r3
 80051b6: 2b00         	cmp	r3, #0x0
 80051b8: d110         	bne	0x80051dc <can_stm32_send+0x2a8> @ imm = #0x20
 80051ba: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80051ec <can_stm32_send+0x2b8>
 80051bc: 6819         	ldr	r1, [r3]
 80051be: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8005200 <can_stm32_send+0x2cc>
 80051c0: 9303         	str	r3, [sp, #0xc]
 80051c2: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8005218 <can_stm32_send+0x2e4>
 80051c4: 9302         	str	r3, [sp, #0x8]
 80051c6: 2308         	movs	r3, #0x8
 80051c8: 9301         	str	r3, [sp, #0x4]
 80051ca: 2300         	movs	r3, #0x0
 80051cc: 9300         	str	r3, [sp]
 80051ce: 2300         	movs	r3, #0x0
 80051d0: 2204         	movs	r2, #0x4
 80051d2: 2000         	movs	r0, #0x0
 80051d4: f00e f846    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe08c
 80051d8: 2300         	movs	r3, #0x0
 80051da: 633b         	str	r3, [r7, #0x30]
; 		mailbox = &can->sTxMailBox[1];
 80051dc: 6bbb         	ldr	r3, [r7, #0x38]
 80051de: f503 73c8    	add.w	r3, r3, #0x190
 80051e2: 64fb         	str	r3, [r7, #0x4c]
; 		mb = &data->mb1;
 80051e4: 6bfb         	ldr	r3, [r7, #0x3c]
 80051e6: 333c         	adds	r3, #0x3c
 80051e8: 64bb         	str	r3, [r7, #0x48]
 80051ea: e041         	b	0x8005270 <can_stm32_send+0x33c> @ imm = #0x82

080051ec <$d>:
 80051ec: 54 04 00 20  	.word	0x20000454
 80051f0: 30 bd 01 08  	.word	0x0801bd30
 80051f4: 3c bd 01 08  	.word	0x0801bd3c
 80051f8: 48 bd 01 08  	.word	0x0801bd48
 80051fc: 4c bd 01 08  	.word	0x0801bd4c
 8005200: 7c d1 01 08  	.word	0x0801d17c
 8005204: 50 bd 01 08  	.word	0x0801bd50
 8005208: 94 bd 01 08  	.word	0x0801bd94
 800520c: b4 bd 01 08  	.word	0x0801bdb4
 8005210: d8 bd 01 08  	.word	0x0801bdd8
 8005214: f4 bd 01 08  	.word	0x0801bdf4
 8005218: 0c be 01 08  	.word	0x0801be0c

0800521c <$t>:
; 	} else if (transmit_status_register & CAN_TSR_TME2) {
 800521c: 6dbb         	ldr	r3, [r7, #0x58]
 800521e: f003 5380    	and	r3, r3, #0x10000000
 8005222: 2b00         	cmp	r3, #0x0
 8005224: d024         	beq	0x8005270 <can_stm32_send+0x33c> @ imm = #0x48
; 		LOG_DBG("Using TX mailbox 2");
 8005226: 2303         	movs	r3, #0x3
 8005228: 2b03         	cmp	r3, #0x3
 800522a: d91a         	bls	0x8005262 <can_stm32_send+0x32e> @ imm = #0x34
 800522c: 2301         	movs	r3, #0x1
 800522e: f887 3057    	strb.w	r3, [r7, #0x57]
 8005232: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8005236: f083 0301    	eor	r3, r3, #0x1
 800523a: b2db         	uxtb	r3, r3
 800523c: 2b00         	cmp	r3, #0x0
 800523e: d110         	bne	0x8005262 <can_stm32_send+0x32e> @ imm = #0x20
 8005240: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800531c <can_stm32_send+0x3e8>
 8005242: 6819         	ldr	r1, [r3]
 8005244: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8005320 <can_stm32_send+0x3ec>
 8005246: 9303         	str	r3, [sp, #0xc]
 8005248: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8005324 <can_stm32_send+0x3f0>
 800524a: 9302         	str	r3, [sp, #0x8]
 800524c: 2308         	movs	r3, #0x8
 800524e: 9301         	str	r3, [sp, #0x4]
 8005250: 2300         	movs	r3, #0x0
 8005252: 9300         	str	r3, [sp]
 8005254: 2300         	movs	r3, #0x0
 8005256: 2204         	movs	r2, #0x4
 8005258: 2000         	movs	r0, #0x0
 800525a: f00e f803    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xe006
 800525e: 2300         	movs	r3, #0x0
 8005260: 653b         	str	r3, [r7, #0x50]
; 		mailbox = &can->sTxMailBox[2];
 8005262: 6bbb         	ldr	r3, [r7, #0x38]
 8005264: f503 73d0    	add.w	r3, r3, #0x1a0
 8005268: 64fb         	str	r3, [r7, #0x4c]
; 		mb = &data->mb2;
 800526a: 6bfb         	ldr	r3, [r7, #0x3c]
 800526c: 3344         	adds	r3, #0x44
 800526e: 64bb         	str	r3, [r7, #0x48]
; 	mb->tx_callback = callback;
 8005270: 6cbb         	ldr	r3, [r7, #0x48]
 8005272: 6f3a         	ldr	r2, [r7, #0x70]
 8005274: 601a         	str	r2, [r3]
; 	mb->callback_arg = user_data;
 8005276: 6cbb         	ldr	r3, [r7, #0x48]
 8005278: 6f7a         	ldr	r2, [r7, #0x74]
 800527a: 605a         	str	r2, [r3, #0x4]
; 	mailbox->TIR &= CAN_TI0R_TXRQ;
 800527c: 6cfb         	ldr	r3, [r7, #0x4c]
 800527e: 681b         	ldr	r3, [r3]
 8005280: f003 0201    	and	r2, r3, #0x1
 8005284: 6cfb         	ldr	r3, [r7, #0x4c]
 8005286: 601a         	str	r2, [r3]
; 	if ((frame->flags & CAN_FRAME_IDE) != 0) {
 8005288: 68bb         	ldr	r3, [r7, #0x8]
 800528a: 795b         	ldrb	r3, [r3, #0x5]
 800528c: f003 0301    	and	r3, r3, #0x1
 8005290: 2b00         	cmp	r3, #0x0
 8005292: d00a         	beq	0x80052aa <can_stm32_send+0x376> @ imm = #0x14
; 		mailbox->TIR |= (frame->id << CAN_TI0R_EXID_Pos)
 8005294: 6cfb         	ldr	r3, [r7, #0x4c]
 8005296: 681a         	ldr	r2, [r3]
 8005298: 68bb         	ldr	r3, [r7, #0x8]
 800529a: 681b         	ldr	r3, [r3]
 800529c: 00db         	lsls	r3, r3, #0x3
 800529e: 4313         	orrs	r3, r2
 80052a0: f043 0204    	orr	r2, r3, #0x4
 80052a4: 6cfb         	ldr	r3, [r7, #0x4c]
 80052a6: 601a         	str	r2, [r3]
 80052a8: e007         	b	0x80052ba <can_stm32_send+0x386> @ imm = #0xe
; 		mailbox->TIR |= (frame->id << CAN_TI0R_STID_Pos);
 80052aa: 6cfb         	ldr	r3, [r7, #0x4c]
 80052ac: 681a         	ldr	r2, [r3]
 80052ae: 68bb         	ldr	r3, [r7, #0x8]
 80052b0: 681b         	ldr	r3, [r3]
 80052b2: 055b         	lsls	r3, r3, #0x15
 80052b4: 431a         	orrs	r2, r3
 80052b6: 6cfb         	ldr	r3, [r7, #0x4c]
 80052b8: 601a         	str	r2, [r3]
; 	if ((frame->flags & CAN_FRAME_RTR) != 0) {
 80052ba: 68bb         	ldr	r3, [r7, #0x8]
 80052bc: 795b         	ldrb	r3, [r3, #0x5]
 80052be: f003 0302    	and	r3, r3, #0x2
 80052c2: 2b00         	cmp	r3, #0x0
 80052c4: d006         	beq	0x80052d4 <can_stm32_send+0x3a0> @ imm = #0xc
; 		mailbox->TIR |= CAN_TI1R_RTR;
 80052c6: 6cfb         	ldr	r3, [r7, #0x4c]
 80052c8: 681b         	ldr	r3, [r3]
 80052ca: f043 0202    	orr	r2, r3, #0x2
 80052ce: 6cfb         	ldr	r3, [r7, #0x4c]
 80052d0: 601a         	str	r2, [r3]
 80052d2: e007         	b	0x80052e4 <can_stm32_send+0x3b0> @ imm = #0xe
; 		mailbox->TDLR = frame->data_32[0];
 80052d4: 68bb         	ldr	r3, [r7, #0x8]
 80052d6: 689a         	ldr	r2, [r3, #0x8]
 80052d8: 6cfb         	ldr	r3, [r7, #0x4c]
 80052da: 609a         	str	r2, [r3, #0x8]
; 		mailbox->TDHR = frame->data_32[1];
 80052dc: 68bb         	ldr	r3, [r7, #0x8]
 80052de: 68da         	ldr	r2, [r3, #0xc]
 80052e0: 6cfb         	ldr	r3, [r7, #0x4c]
 80052e2: 60da         	str	r2, [r3, #0xc]
; 	mailbox->TDTR = (mailbox->TDTR & ~CAN_TDT1R_DLC) |
 80052e4: 6cfb         	ldr	r3, [r7, #0x4c]
 80052e6: 685b         	ldr	r3, [r3, #0x4]
 80052e8: f023 020f    	bic	r2, r3, #0xf
; 			((frame->dlc & 0xF) << CAN_TDT1R_DLC_Pos);
 80052ec: 68bb         	ldr	r3, [r7, #0x8]
 80052ee: 791b         	ldrb	r3, [r3, #0x4]
 80052f0: f003 030f    	and	r3, r3, #0xf
; 	mailbox->TDTR = (mailbox->TDTR & ~CAN_TDT1R_DLC) |
 80052f4: 431a         	orrs	r2, r3
 80052f6: 6cfb         	ldr	r3, [r7, #0x4c]
 80052f8: 605a         	str	r2, [r3, #0x4]
; 	mailbox->TIR |= CAN_TI0R_TXRQ;
 80052fa: 6cfb         	ldr	r3, [r7, #0x4c]
 80052fc: 681b         	ldr	r3, [r3]
 80052fe: f043 0201    	orr	r2, r3, #0x1
 8005302: 6cfb         	ldr	r3, [r7, #0x4c]
 8005304: 601a         	str	r2, [r3]
; 	k_mutex_unlock(&data->inst_mutex);
 8005306: 6bfb         	ldr	r3, [r7, #0x3c]
 8005308: 3310         	adds	r3, #0x10
 800530a: 4618         	mov	r0, r3
 800530c: f00d fed7    	bl	0x80130be <k_mutex_unlock> @ imm = #0xddae
; 	return 0;
 8005310: 2300         	movs	r3, #0x0
; }
 8005312: 4618         	mov	r0, r3
 8005314: 3760         	adds	r7, #0x60
 8005316: 46bd         	mov	sp, r7
 8005318: bdb0         	pop	{r4, r5, r7, pc}
 800531a: bf00         	nop

0800531c <$d>:
 800531c: 54 04 00 20  	.word	0x20000454
 8005320: 7c d1 01 08  	.word	0x0801d17c
 8005324: 24 be 01 08  	.word	0x0801be24

08005328 <can_stm32_set_filter>:
; {
 8005328: b580         	push	{r7, lr}
 800532a: b098         	sub	sp, #0x60
 800532c: af08         	add	r7, sp, #0x20
 800532e: 6078         	str	r0, [r7, #0x4]
 8005330: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8005332: 687b         	ldr	r3, [r7, #0x4]
 8005334: 685b         	ldr	r3, [r3, #0x4]
 8005336: 623b         	str	r3, [r7, #0x20]
; 	struct can_stm32_data *data = dev->data;
 8005338: 687b         	ldr	r3, [r7, #0x4]
 800533a: 691b         	ldr	r3, [r3, #0x10]
 800533c: 61fb         	str	r3, [r7, #0x1c]
; 	CAN_TypeDef *can = cfg->master_can;
 800533e: 6a3b         	ldr	r3, [r7, #0x20]
 8005340: 699b         	ldr	r3, [r3, #0x18]
 8005342: 61bb         	str	r3, [r7, #0x18]
; 	uint32_t mask = 0U;
 8005344: 2300         	movs	r3, #0x0
 8005346: 62fb         	str	r3, [r7, #0x2c]
; 	uint32_t id = 0U;
 8005348: 2300         	movs	r3, #0x0
 800534a: 633b         	str	r3, [r7, #0x30]
; 	int filter_id = -ENOSPC;
 800534c: f06f 031b    	mvn	r3, #0x1b
 8005350: 63fb         	str	r3, [r7, #0x3c]
; 	int bank_offset = 0;
 8005352: 2300         	movs	r3, #0x0
 8005354: 63bb         	str	r3, [r7, #0x38]
; 	if (cfg->can != cfg->master_can) {
 8005356: 6a3b         	ldr	r3, [r7, #0x20]
 8005358: 695a         	ldr	r2, [r3, #0x14]
 800535a: 6a3b         	ldr	r3, [r7, #0x20]
 800535c: 699b         	ldr	r3, [r3, #0x18]
 800535e: 429a         	cmp	r2, r3
 8005360: d001         	beq	0x8005366 <can_stm32_set_filter+0x3e> @ imm = #0x2
; 		bank_offset = CAN_STM32_NUM_FILTER_BANKS;
 8005362: 230e         	movs	r3, #0xe
 8005364: 63bb         	str	r3, [r7, #0x38]
; 	if ((filter->flags & CAN_FILTER_IDE) != 0) {
 8005366: 683b         	ldr	r3, [r7]
 8005368: 7a1b         	ldrb	r3, [r3, #0x8]
 800536a: f003 0301    	and	r3, r3, #0x1
 800536e: 2b00         	cmp	r3, #0x0
 8005370: d020         	beq	0x80053b4 <can_stm32_set_filter+0x8c> @ imm = #0x40
; 		for (int i = 0; i < CONFIG_CAN_MAX_EXT_ID_FILTER; i++) {
 8005372: 2300         	movs	r3, #0x0
 8005374: 62bb         	str	r3, [r7, #0x28]
 8005376: e019         	b	0x80053ac <can_stm32_set_filter+0x84> @ imm = #0x32
; 			if (data->rx_cb_ext[i] == NULL) {
 8005378: 69fa         	ldr	r2, [r7, #0x1c]
 800537a: 6abb         	ldr	r3, [r7, #0x28]
 800537c: 3320         	adds	r3, #0x20
 800537e: 009b         	lsls	r3, r3, #0x2
 8005380: 4413         	add	r3, r2
 8005382: 685b         	ldr	r3, [r3, #0x4]
 8005384: 2b00         	cmp	r3, #0x0
 8005386: d10e         	bne	0x80053a6 <can_stm32_set_filter+0x7e> @ imm = #0x1c
; 				id = can_stm32_filter_to_ext_id(filter);
 8005388: 6838         	ldr	r0, [r7]
 800538a: f00e fa09    	bl	0x80137a0 <can_stm32_filter_to_ext_id> @ imm = #0xe412
 800538e: 6338         	str	r0, [r7, #0x30]
; 				mask = can_stm32_filter_to_ext_mask(filter);
 8005390: 6838         	ldr	r0, [r7]
 8005392: f00e f9e6    	bl	0x8013762 <can_stm32_filter_to_ext_mask> @ imm = #0xe3cc
 8005396: 62f8         	str	r0, [r7, #0x2c]
; 				filter_id = i;
 8005398: 6abb         	ldr	r3, [r7, #0x28]
 800539a: 63fb         	str	r3, [r7, #0x3c]
; 				bank_num = bank_offset + i;
 800539c: 6bba         	ldr	r2, [r7, #0x38]
 800539e: 6abb         	ldr	r3, [r7, #0x28]
 80053a0: 4413         	add	r3, r2
 80053a2: 637b         	str	r3, [r7, #0x34]
; 				break;
 80053a4: e02b         	b	0x80053fe <can_stm32_set_filter+0xd6> @ imm = #0x56
; 		for (int i = 0; i < CONFIG_CAN_MAX_EXT_ID_FILTER; i++) {
 80053a6: 6abb         	ldr	r3, [r7, #0x28]
 80053a8: 3301         	adds	r3, #0x1
 80053aa: 62bb         	str	r3, [r7, #0x28]
 80053ac: 6abb         	ldr	r3, [r7, #0x28]
 80053ae: 2b06         	cmp	r3, #0x6
 80053b0: dde2         	ble	0x8005378 <can_stm32_set_filter+0x50> @ imm = #-0x3c
 80053b2: e024         	b	0x80053fe <can_stm32_set_filter+0xd6> @ imm = #0x48
; 		for (int i = 0; i < CONFIG_CAN_MAX_STD_ID_FILTER; i++) {
 80053b4: 2300         	movs	r3, #0x0
 80053b6: 627b         	str	r3, [r7, #0x24]
 80053b8: e01e         	b	0x80053f8 <can_stm32_set_filter+0xd0> @ imm = #0x3c
; 			if (data->rx_cb_std[i] == NULL) {
 80053ba: 69fa         	ldr	r2, [r7, #0x1c]
 80053bc: 6a7b         	ldr	r3, [r7, #0x24]
 80053be: 3312         	adds	r3, #0x12
 80053c0: 009b         	lsls	r3, r3, #0x2
 80053c2: 4413         	add	r3, r2
 80053c4: 685b         	ldr	r3, [r3, #0x4]
 80053c6: 2b00         	cmp	r3, #0x0
 80053c8: d113         	bne	0x80053f2 <can_stm32_set_filter+0xca> @ imm = #0x26
; 				id = can_stm32_filter_to_std_id(filter);
 80053ca: 6838         	ldr	r0, [r7]
 80053cc: f00e f9dc    	bl	0x8013788 <can_stm32_filter_to_std_id> @ imm = #0xe3b8
 80053d0: 6338         	str	r0, [r7, #0x30]
; 				mask = can_stm32_filter_to_std_mask(filter);
 80053d2: 6838         	ldr	r0, [r7]
 80053d4: f00e f9b2    	bl	0x801373c <can_stm32_filter_to_std_mask> @ imm = #0xe364
 80053d8: 62f8         	str	r0, [r7, #0x2c]
; 				filter_id = CONFIG_CAN_MAX_EXT_ID_FILTER + i;
 80053da: 6a7b         	ldr	r3, [r7, #0x24]
 80053dc: 3307         	adds	r3, #0x7
 80053de: 63fb         	str	r3, [r7, #0x3c]
; 				bank_num = bank_offset + CONFIG_CAN_MAX_EXT_ID_FILTER + i / 2;
 80053e0: 6bbb         	ldr	r3, [r7, #0x38]
 80053e2: 1dda         	adds	r2, r3, #0x7
 80053e4: 6a7b         	ldr	r3, [r7, #0x24]
 80053e6: 0fd9         	lsrs	r1, r3, #0x1f
 80053e8: 440b         	add	r3, r1
 80053ea: 105b         	asrs	r3, r3, #0x1
 80053ec: 4413         	add	r3, r2
 80053ee: 637b         	str	r3, [r7, #0x34]
; 				break;
 80053f0: e005         	b	0x80053fe <can_stm32_set_filter+0xd6> @ imm = #0xa
; 		for (int i = 0; i < CONFIG_CAN_MAX_STD_ID_FILTER; i++) {
 80053f2: 6a7b         	ldr	r3, [r7, #0x24]
 80053f4: 3301         	adds	r3, #0x1
 80053f6: 627b         	str	r3, [r7, #0x24]
 80053f8: 6a7b         	ldr	r3, [r7, #0x24]
 80053fa: 2b0d         	cmp	r3, #0xd
 80053fc: dddd         	ble	0x80053ba <can_stm32_set_filter+0x92> @ imm = #-0x46
; 	if (filter_id != -ENOSPC) {
 80053fe: 6bfb         	ldr	r3, [r7, #0x3c]
 8005400: f113 0f1c    	cmn.w	r3, #0x1c
 8005404: d053         	beq	0x80054ae <can_stm32_set_filter+0x186> @ imm = #0xa6
; 		LOG_DBG("Adding filter_id %d, CAN ID: 0x%x, mask: 0x%x",
 8005406: 2303         	movs	r3, #0x3
 8005408: 2b03         	cmp	r3, #0x3
 800540a: d920         	bls	0x800544e <can_stm32_set_filter+0x126> @ imm = #0x40
 800540c: 2301         	movs	r3, #0x1
 800540e: 73fb         	strb	r3, [r7, #0xf]
 8005410: 7bfb         	ldrb	r3, [r7, #0xf]
 8005412: f083 0301    	eor	r3, r3, #0x1
 8005416: b2db         	uxtb	r3, r3
 8005418: 2b00         	cmp	r3, #0x0
 800541a: d118         	bne	0x800544e <can_stm32_set_filter+0x126> @ imm = #0x30
 800541c: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80054ec <can_stm32_set_filter+0x1c4>
 800541e: 6819         	ldr	r1, [r3]
 8005420: 683b         	ldr	r3, [r7]
 8005422: 681b         	ldr	r3, [r3]
 8005424: 683a         	ldr	r2, [r7]
 8005426: 6852         	ldr	r2, [r2, #0x4]
 8005428: 9206         	str	r2, [sp, #0x18]
 800542a: 9305         	str	r3, [sp, #0x14]
 800542c: 6bfb         	ldr	r3, [r7, #0x3c]
 800542e: 9304         	str	r3, [sp, #0x10]
 8005430: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x80054f0 <can_stm32_set_filter+0x1c8>
 8005432: 9303         	str	r3, [sp, #0xc]
 8005434: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x80054f4 <can_stm32_set_filter+0x1cc>
 8005436: 9302         	str	r3, [sp, #0x8]
 8005438: 2308         	movs	r3, #0x8
 800543a: 9301         	str	r3, [sp, #0x4]
 800543c: 2300         	movs	r3, #0x0
 800543e: 9300         	str	r3, [sp]
 8005440: 2300         	movs	r3, #0x0
 8005442: 2204         	movs	r2, #0x4
 8005444: 2000         	movs	r0, #0x0
 8005446: f00d ff0d    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xde1a
 800544a: 2300         	movs	r3, #0x0
 800544c: 60bb         	str	r3, [r7, #0x8]
; 		can->FMR |= CAN_FMR_FINIT;
 800544e: 69bb         	ldr	r3, [r7, #0x18]
 8005450: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 8005454: f043 0201    	orr	r2, r3, #0x1
 8005458: 69bb         	ldr	r3, [r7, #0x18]
 800545a: f8c3 2200    	str.w	r2, [r3, #0x200]
; 		can_stm32_set_filter_bank(filter_id, &can->sFilterRegister[bank_num],
 800545e: 6b7b         	ldr	r3, [r7, #0x34]
 8005460: 3348         	adds	r3, #0x48
 8005462: 00db         	lsls	r3, r3, #0x3
 8005464: 69ba         	ldr	r2, [r7, #0x18]
 8005466: 18d1         	adds	r1, r2, r3
; 					  (filter->flags & CAN_FILTER_IDE) != 0,
 8005468: 683b         	ldr	r3, [r7]
 800546a: 7a1b         	ldrb	r3, [r3, #0x8]
 800546c: f003 0301    	and	r3, r3, #0x1
; 		can_stm32_set_filter_bank(filter_id, &can->sFilterRegister[bank_num],
 8005470: 2b00         	cmp	r3, #0x0
 8005472: bf14         	ite	ne
 8005474: 2301         	movne	r3, #0x1
 8005476: 2300         	moveq	r3, #0x0
 8005478: b2da         	uxtb	r2, r3
 800547a: 6afb         	ldr	r3, [r7, #0x2c]
 800547c: 9300         	str	r3, [sp]
 800547e: 6b3b         	ldr	r3, [r7, #0x30]
 8005480: 6bf8         	ldr	r0, [r7, #0x3c]
 8005482: f00e f931    	bl	0x80136e8 <can_stm32_set_filter_bank> @ imm = #0xe262
; 		can->FA1R |= 1U << bank_num;
 8005486: 69bb         	ldr	r3, [r7, #0x18]
 8005488: f8d3 221c    	ldr.w	r2, [r3, #0x21c]
 800548c: 2101         	movs	r1, #0x1
 800548e: 6b7b         	ldr	r3, [r7, #0x34]
 8005490: fa01 f303    	lsl.w	r3, r1, r3
 8005494: 431a         	orrs	r2, r3
 8005496: 69bb         	ldr	r3, [r7, #0x18]
 8005498: f8c3 221c    	str.w	r2, [r3, #0x21c]
; 		can->FMR &= ~(CAN_FMR_FINIT);
 800549c: 69bb         	ldr	r3, [r7, #0x18]
 800549e: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 80054a2: f023 0201    	bic	r2, r3, #0x1
 80054a6: 69bb         	ldr	r3, [r7, #0x18]
 80054a8: f8c3 2200    	str.w	r2, [r3, #0x200]
 80054ac: e019         	b	0x80054e2 <can_stm32_set_filter+0x1ba> @ imm = #0x32
; 		LOG_WRN("No free filter left");
 80054ae: 2303         	movs	r3, #0x3
 80054b0: 2b01         	cmp	r3, #0x1
 80054b2: d916         	bls	0x80054e2 <can_stm32_set_filter+0x1ba> @ imm = #0x2c
 80054b4: 2301         	movs	r3, #0x1
 80054b6: 75fb         	strb	r3, [r7, #0x17]
 80054b8: 7dfb         	ldrb	r3, [r7, #0x17]
 80054ba: f083 0301    	eor	r3, r3, #0x1
 80054be: b2db         	uxtb	r3, r3
 80054c0: 2b00         	cmp	r3, #0x0
 80054c2: d10e         	bne	0x80054e2 <can_stm32_set_filter+0x1ba> @ imm = #0x1c
 80054c4: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80054ec <can_stm32_set_filter+0x1c4>
 80054c6: 6819         	ldr	r1, [r3]
 80054c8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80054f8 <can_stm32_set_filter+0x1d0>
 80054ca: 9302         	str	r3, [sp, #0x8]
 80054cc: 2300         	movs	r3, #0x0
 80054ce: 9301         	str	r3, [sp, #0x4]
 80054d0: 2300         	movs	r3, #0x0
 80054d2: 9300         	str	r3, [sp]
 80054d4: 2300         	movs	r3, #0x0
 80054d6: 2202         	movs	r2, #0x2
 80054d8: 2000         	movs	r0, #0x0
 80054da: f00d fec3    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xdd86
 80054de: 2300         	movs	r3, #0x0
 80054e0: 613b         	str	r3, [r7, #0x10]
; 	return filter_id;
 80054e2: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 80054e4: 4618         	mov	r0, r3
 80054e6: 3740         	adds	r7, #0x40
 80054e8: 46bd         	mov	sp, r7
 80054ea: bd80         	pop	{r7, pc}

080054ec <$d>:
 80054ec: 54 04 00 20  	.word	0x20000454
 80054f0: 8c d1 01 08  	.word	0x0801d18c
 80054f4: 3c be 01 08  	.word	0x0801be3c
 80054f8: 70 be 01 08  	.word	0x0801be70

080054fc <can_stm32_add_rx_filter>:
; {
 80054fc: b580         	push	{r7, lr}
 80054fe: b08c         	sub	sp, #0x30
 8005500: af04         	add	r7, sp, #0x10
 8005502: 60f8         	str	r0, [r7, #0xc]
 8005504: 60b9         	str	r1, [r7, #0x8]
 8005506: 607a         	str	r2, [r7, #0x4]
 8005508: 603b         	str	r3, [r7]
; 	struct can_stm32_data *data = dev->data;
 800550a: 68fb         	ldr	r3, [r7, #0xc]
 800550c: 691b         	ldr	r3, [r3, #0x10]
 800550e: 61fb         	str	r3, [r7, #0x1c]
; 	if ((filter->flags & ~(CAN_FILTER_IDE)) != 0) {
 8005510: 683b         	ldr	r3, [r7]
 8005512: 7a1b         	ldrb	r3, [r3, #0x8]
 8005514: 2b01         	cmp	r3, #0x1
 8005516: d91f         	bls	0x8005558 <can_stm32_add_rx_filter+0x5c> @ imm = #0x3e
; 		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
 8005518: 2303         	movs	r3, #0x3
 800551a: 2b00         	cmp	r3, #0x0
 800551c: d019         	beq	0x8005552 <can_stm32_add_rx_filter+0x56> @ imm = #0x32
 800551e: 2301         	movs	r3, #0x1
 8005520: 75fb         	strb	r3, [r7, #0x17]
 8005522: 7dfb         	ldrb	r3, [r7, #0x17]
 8005524: f083 0301    	eor	r3, r3, #0x1
 8005528: b2db         	uxtb	r3, r3
 800552a: 2b00         	cmp	r3, #0x0
 800552c: d111         	bne	0x8005552 <can_stm32_add_rx_filter+0x56> @ imm = #0x22
 800552e: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x80055ec <can_stm32_add_rx_filter+0xf0>
 8005530: 6819         	ldr	r1, [r3]
 8005532: 683b         	ldr	r3, [r7]
 8005534: 7a1b         	ldrb	r3, [r3, #0x8]
 8005536: 9303         	str	r3, [sp, #0xc]
 8005538: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x80055f0 <can_stm32_add_rx_filter+0xf4>
 800553a: 9302         	str	r3, [sp, #0x8]
 800553c: 2300         	movs	r3, #0x0
 800553e: 9301         	str	r3, [sp, #0x4]
 8005540: 2300         	movs	r3, #0x0
 8005542: 9300         	str	r3, [sp]
 8005544: 2300         	movs	r3, #0x0
 8005546: 2201         	movs	r2, #0x1
 8005548: 2000         	movs	r0, #0x0
 800554a: f00d fe8b    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xdd16
 800554e: 2300         	movs	r3, #0x0
 8005550: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 8005552: f06f 0185    	mvn	r1, #0x85
 8005556: e044         	b	0x80055e2 <can_stm32_add_rx_filter+0xe6> @ imm = #0x88
; 	k_mutex_lock(&filter_mutex, K_FOREVER);
 8005558: f04f 32ff    	mov.w	r2, #0xffffffff
 800555c: f04f 33ff    	mov.w	r3, #0xffffffff
 8005560: 4824         	ldr	r0, [pc, #0x90]         @ 0x80055f4 <can_stm32_add_rx_filter+0xf8>
 8005562: f00d fd9c    	bl	0x801309e <k_mutex_lock> @ imm = #0xdb38
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8005566: 69fb         	ldr	r3, [r7, #0x1c]
 8005568: f103 0110    	add.w	r1, r3, #0x10
 800556c: f04f 32ff    	mov.w	r2, #0xffffffff
 8005570: f04f 33ff    	mov.w	r3, #0xffffffff
 8005574: 4608         	mov	r0, r1
 8005576: f00d fd92    	bl	0x801309e <k_mutex_lock> @ imm = #0xdb24
; 	filter_id = can_stm32_set_filter(dev, filter);
 800557a: 6839         	ldr	r1, [r7]
 800557c: 68f8         	ldr	r0, [r7, #0xc]
 800557e: f7ff fed3    	bl	0x8005328 <can_stm32_set_filter> @ imm = #-0x25a
 8005582: 61b8         	str	r0, [r7, #0x18]
; 	if (filter_id >= 0) {
 8005584: 69bb         	ldr	r3, [r7, #0x18]
 8005586: 2b00         	cmp	r3, #0x0
 8005588: db22         	blt	0x80055d0 <can_stm32_add_rx_filter+0xd4> @ imm = #0x44
; 		if ((filter->flags & CAN_FILTER_IDE) != 0) {
 800558a: 683b         	ldr	r3, [r7]
 800558c: 7a1b         	ldrb	r3, [r3, #0x8]
 800558e: f003 0301    	and	r3, r3, #0x1
 8005592: 2b00         	cmp	r3, #0x0
 8005594: d00d         	beq	0x80055b2 <can_stm32_add_rx_filter+0xb6> @ imm = #0x1a
; 			data->rx_cb_ext[filter_id] = cb;
 8005596: 69fa         	ldr	r2, [r7, #0x1c]
 8005598: 69bb         	ldr	r3, [r7, #0x18]
 800559a: 3320         	adds	r3, #0x20
 800559c: 009b         	lsls	r3, r3, #0x2
 800559e: 4413         	add	r3, r2
 80055a0: 68ba         	ldr	r2, [r7, #0x8]
 80055a2: 605a         	str	r2, [r3, #0x4]
; 			data->cb_arg_ext[filter_id] = cb_arg;
 80055a4: 69fb         	ldr	r3, [r7, #0x1c]
 80055a6: 69ba         	ldr	r2, [r7, #0x18]
 80055a8: 3236         	adds	r2, #0x36
 80055aa: 6879         	ldr	r1, [r7, #0x4]
 80055ac: f843 1022    	str.w	r1, [r3, r2, lsl #2]
 80055b0: e00e         	b	0x80055d0 <can_stm32_add_rx_filter+0xd4> @ imm = #0x1c
; 			data->rx_cb_std[filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER] = cb;
 80055b2: 69bb         	ldr	r3, [r7, #0x18]
 80055b4: 3b07         	subs	r3, #0x7
 80055b6: 69fa         	ldr	r2, [r7, #0x1c]
 80055b8: 3312         	adds	r3, #0x12
 80055ba: 009b         	lsls	r3, r3, #0x2
 80055bc: 4413         	add	r3, r2
 80055be: 68ba         	ldr	r2, [r7, #0x8]
 80055c0: 605a         	str	r2, [r3, #0x4]
; 			data->cb_arg_std[filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER] = cb_arg;
 80055c2: 69bb         	ldr	r3, [r7, #0x18]
 80055c4: 1fda         	subs	r2, r3, #0x7
 80055c6: 69fb         	ldr	r3, [r7, #0x1c]
 80055c8: 3228         	adds	r2, #0x28
 80055ca: 6879         	ldr	r1, [r7, #0x4]
 80055cc: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 	k_mutex_unlock(&data->inst_mutex);
 80055d0: 69fb         	ldr	r3, [r7, #0x1c]
 80055d2: 3310         	adds	r3, #0x10
 80055d4: 4618         	mov	r0, r3
 80055d6: f00d fd72    	bl	0x80130be <k_mutex_unlock> @ imm = #0xdae4
; 	k_mutex_unlock(&filter_mutex);
 80055da: 4806         	ldr	r0, [pc, #0x18]         @ 0x80055f4 <can_stm32_add_rx_filter+0xf8>
 80055dc: f00d fd6f    	bl	0x80130be <k_mutex_unlock> @ imm = #0xdade
; 	return filter_id;
 80055e0: 69b9         	ldr	r1, [r7, #0x18]
; }
 80055e2: 460b         	mov	r3, r1
 80055e4: 4618         	mov	r0, r3
 80055e6: 3720         	adds	r7, #0x20
 80055e8: 46bd         	mov	sp, r7
 80055ea: bd80         	pop	{r7, pc}

080055ec <$d>:
 80055ec: 54 04 00 20  	.word	0x20000454
 80055f0: 84 be 01 08  	.word	0x0801be84
 80055f4: e4 0b 00 20  	.word	0x20000be4

080055f8 <can_stm32_remove_rx_filter>:
; {
 80055f8: b580         	push	{r7, lr}
 80055fa: b096         	sub	sp, #0x58
 80055fc: af06         	add	r7, sp, #0x18
 80055fe: 6078         	str	r0, [r7, #0x4]
 8005600: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8005602: 687b         	ldr	r3, [r7, #0x4]
 8005604: 685b         	ldr	r3, [r3, #0x4]
 8005606: 62fb         	str	r3, [r7, #0x2c]
; 	struct can_stm32_data *data = dev->data;
 8005608: 687b         	ldr	r3, [r7, #0x4]
 800560a: 691b         	ldr	r3, [r3, #0x10]
 800560c: 62bb         	str	r3, [r7, #0x28]
; 	CAN_TypeDef *can = cfg->master_can;
 800560e: 6afb         	ldr	r3, [r7, #0x2c]
 8005610: 699b         	ldr	r3, [r3, #0x18]
 8005612: 627b         	str	r3, [r7, #0x24]
; 	int bank_offset = 0;
 8005614: 2300         	movs	r3, #0x0
 8005616: 633b         	str	r3, [r7, #0x30]
; 	if (filter_id < 0 || filter_id >= CAN_STM32_MAX_FILTER_ID) {
 8005618: 683b         	ldr	r3, [r7]
 800561a: 2b00         	cmp	r3, #0x0
 800561c: db02         	blt	0x8005624 <can_stm32_remove_rx_filter+0x2c> @ imm = #0x4
 800561e: 683b         	ldr	r3, [r7]
 8005620: 2b22         	cmp	r3, #0x22
 8005622: dd1e         	ble	0x8005662 <can_stm32_remove_rx_filter+0x6a> @ imm = #0x3c
; 		LOG_ERR("filter ID %d out of bounds", filter_id);
 8005624: 2303         	movs	r3, #0x3
 8005626: 2b00         	cmp	r3, #0x0
 8005628: f000 810a    	beq.w	0x8005840 <can_stm32_remove_rx_filter+0x248> @ imm = #0x214
 800562c: 2301         	movs	r3, #0x1
 800562e: 73fb         	strb	r3, [r7, #0xf]
 8005630: 7bfb         	ldrb	r3, [r7, #0xf]
 8005632: f083 0301    	eor	r3, r3, #0x1
 8005636: b2db         	uxtb	r3, r3
 8005638: 2b00         	cmp	r3, #0x0
 800563a: f040 8101    	bne.w	0x8005840 <can_stm32_remove_rx_filter+0x248> @ imm = #0x202
 800563e: 4b82         	ldr	r3, [pc, #0x208]        @ 0x8005848 <can_stm32_remove_rx_filter+0x250>
 8005640: 6819         	ldr	r1, [r3]
 8005642: 683b         	ldr	r3, [r7]
 8005644: 9303         	str	r3, [sp, #0xc]
 8005646: 4b81         	ldr	r3, [pc, #0x204]        @ 0x800584c <can_stm32_remove_rx_filter+0x254>
 8005648: 9302         	str	r3, [sp, #0x8]
 800564a: 2300         	movs	r3, #0x0
 800564c: 9301         	str	r3, [sp, #0x4]
 800564e: 2300         	movs	r3, #0x0
 8005650: 9300         	str	r3, [sp]
 8005652: 2300         	movs	r3, #0x0
 8005654: 2201         	movs	r2, #0x1
 8005656: 2000         	movs	r0, #0x0
 8005658: f00d fe04    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xdc08
 800565c: 2300         	movs	r3, #0x0
 800565e: 60bb         	str	r3, [r7, #0x8]
 8005660: e0ee         	b	0x8005840 <can_stm32_remove_rx_filter+0x248> @ imm = #0x1dc
; 	k_mutex_lock(&filter_mutex, K_FOREVER);
 8005662: f04f 32ff    	mov.w	r2, #0xffffffff
 8005666: f04f 33ff    	mov.w	r3, #0xffffffff
 800566a: 4879         	ldr	r0, [pc, #0x1e4]        @ 0x8005850 <can_stm32_remove_rx_filter+0x258>
 800566c: f00d fd17    	bl	0x801309e <k_mutex_lock> @ imm = #0xda2e
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8005670: 6abb         	ldr	r3, [r7, #0x28]
 8005672: f103 0110    	add.w	r1, r3, #0x10
 8005676: f04f 32ff    	mov.w	r2, #0xffffffff
 800567a: f04f 33ff    	mov.w	r3, #0xffffffff
 800567e: 4608         	mov	r0, r1
 8005680: f00d fd0d    	bl	0x801309e <k_mutex_lock> @ imm = #0xda1a
; 	if (cfg->can != cfg->master_can) {
 8005684: 6afb         	ldr	r3, [r7, #0x2c]
 8005686: 695a         	ldr	r2, [r3, #0x14]
 8005688: 6afb         	ldr	r3, [r7, #0x2c]
 800568a: 699b         	ldr	r3, [r3, #0x18]
 800568c: 429a         	cmp	r2, r3
 800568e: d001         	beq	0x8005694 <can_stm32_remove_rx_filter+0x9c> @ imm = #0x2
; 		bank_offset = CAN_STM32_NUM_FILTER_BANKS;
 8005690: 230e         	movs	r3, #0xe
 8005692: 633b         	str	r3, [r7, #0x30]
; 	if (filter_id < CONFIG_CAN_MAX_EXT_ID_FILTER) {
 8005694: 683b         	ldr	r3, [r7]
 8005696: 2b06         	cmp	r3, #0x6
 8005698: dc17         	bgt	0x80056ca <can_stm32_remove_rx_filter+0xd2> @ imm = #0x2e
; 		ide = true;
 800569a: 2301         	movs	r3, #0x1
 800569c: f887 3037    	strb.w	r3, [r7, #0x37]
; 		bank_num = bank_offset + filter_id;
 80056a0: 6b3a         	ldr	r2, [r7, #0x30]
 80056a2: 683b         	ldr	r3, [r7]
 80056a4: 4413         	add	r3, r2
 80056a6: 63bb         	str	r3, [r7, #0x38]
; 		data->rx_cb_ext[filter_id] = NULL;
 80056a8: 6aba         	ldr	r2, [r7, #0x28]
 80056aa: 683b         	ldr	r3, [r7]
 80056ac: 3320         	adds	r3, #0x20
 80056ae: 009b         	lsls	r3, r3, #0x2
 80056b0: 4413         	add	r3, r2
 80056b2: 2200         	movs	r2, #0x0
 80056b4: 605a         	str	r2, [r3, #0x4]
; 		data->cb_arg_ext[filter_id] = NULL;
 80056b6: 6abb         	ldr	r3, [r7, #0x28]
 80056b8: 683a         	ldr	r2, [r7]
 80056ba: 3236         	adds	r2, #0x36
 80056bc: 2100         	movs	r1, #0x0
 80056be: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 		bank_unused = true;
 80056c2: 2301         	movs	r3, #0x1
 80056c4: f887 303f    	strb.w	r3, [r7, #0x3f]
 80056c8: e045         	b	0x8005756 <can_stm32_remove_rx_filter+0x15e> @ imm = #0x8a
; 		int filter_index = filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER;
 80056ca: 683b         	ldr	r3, [r7]
 80056cc: 3b07         	subs	r3, #0x7
 80056ce: 623b         	str	r3, [r7, #0x20]
; 		ide = false;
 80056d0: 2300         	movs	r3, #0x0
 80056d2: f887 3037    	strb.w	r3, [r7, #0x37]
; 		bank_num = bank_offset + CONFIG_CAN_MAX_EXT_ID_FILTER +
 80056d6: 6b3b         	ldr	r3, [r7, #0x30]
 80056d8: 1dda         	adds	r2, r3, #0x7
; 			  (filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER) / 2;
 80056da: 683b         	ldr	r3, [r7]
 80056dc: 3b07         	subs	r3, #0x7
 80056de: 0fd9         	lsrs	r1, r3, #0x1f
 80056e0: 440b         	add	r3, r1
 80056e2: 105b         	asrs	r3, r3, #0x1
; 		bank_num = bank_offset + CONFIG_CAN_MAX_EXT_ID_FILTER +
 80056e4: 4413         	add	r3, r2
 80056e6: 63bb         	str	r3, [r7, #0x38]
; 		data->rx_cb_std[filter_index] = NULL;
 80056e8: 6aba         	ldr	r2, [r7, #0x28]
 80056ea: 6a3b         	ldr	r3, [r7, #0x20]
 80056ec: 3312         	adds	r3, #0x12
 80056ee: 009b         	lsls	r3, r3, #0x2
 80056f0: 4413         	add	r3, r2
 80056f2: 2200         	movs	r2, #0x0
 80056f4: 605a         	str	r2, [r3, #0x4]
; 		data->cb_arg_std[filter_index] = NULL;
 80056f6: 6abb         	ldr	r3, [r7, #0x28]
 80056f8: 6a3a         	ldr	r2, [r7, #0x20]
 80056fa: 3228         	adds	r2, #0x28
 80056fc: 2100         	movs	r1, #0x0
 80056fe: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 		if (filter_index % 2 == 1) {
 8005702: 6a3b         	ldr	r3, [r7, #0x20]
 8005704: 2b00         	cmp	r3, #0x0
 8005706: f003 0301    	and	r3, r3, #0x1
 800570a: bfb8         	it	lt
 800570c: 425b         	rsblt	r3, r3, #0
 800570e: 2b01         	cmp	r3, #0x1
 8005710: d10d         	bne	0x800572e <can_stm32_remove_rx_filter+0x136> @ imm = #0x1a
; 			bank_unused = data->rx_cb_std[filter_index - 1] == NULL;
 8005712: 6a3b         	ldr	r3, [r7, #0x20]
 8005714: 3b01         	subs	r3, #0x1
 8005716: 6aba         	ldr	r2, [r7, #0x28]
 8005718: 3312         	adds	r3, #0x12
 800571a: 009b         	lsls	r3, r3, #0x2
 800571c: 4413         	add	r3, r2
 800571e: 685b         	ldr	r3, [r3, #0x4]
 8005720: 2b00         	cmp	r3, #0x0
 8005722: bf0c         	ite	eq
 8005724: 2301         	moveq	r3, #0x1
 8005726: 2300         	movne	r3, #0x0
 8005728: f887 303f    	strb.w	r3, [r7, #0x3f]
 800572c: e013         	b	0x8005756 <can_stm32_remove_rx_filter+0x15e> @ imm = #0x26
; 		} else if (filter_index + 1 < CONFIG_CAN_MAX_STD_ID_FILTER) {
 800572e: 6a3b         	ldr	r3, [r7, #0x20]
 8005730: 2b0c         	cmp	r3, #0xc
 8005732: dc0d         	bgt	0x8005750 <can_stm32_remove_rx_filter+0x158> @ imm = #0x1a
; 			bank_unused = data->rx_cb_std[filter_index + 1] == NULL;
 8005734: 6a3b         	ldr	r3, [r7, #0x20]
 8005736: 3301         	adds	r3, #0x1
 8005738: 6aba         	ldr	r2, [r7, #0x28]
 800573a: 3312         	adds	r3, #0x12
 800573c: 009b         	lsls	r3, r3, #0x2
 800573e: 4413         	add	r3, r2
 8005740: 685b         	ldr	r3, [r3, #0x4]
 8005742: 2b00         	cmp	r3, #0x0
 8005744: bf0c         	ite	eq
 8005746: 2301         	moveq	r3, #0x1
 8005748: 2300         	movne	r3, #0x0
 800574a: f887 303f    	strb.w	r3, [r7, #0x3f]
 800574e: e002         	b	0x8005756 <can_stm32_remove_rx_filter+0x15e> @ imm = #0x4
; 			bank_unused = true;
 8005750: 2301         	movs	r3, #0x1
 8005752: f887 303f    	strb.w	r3, [r7, #0x3f]
; 	LOG_DBG("Removing filter_id %d, ide %d", filter_id, ide);
 8005756: 2303         	movs	r3, #0x3
 8005758: 2b03         	cmp	r3, #0x3
 800575a: d91d         	bls	0x8005798 <can_stm32_remove_rx_filter+0x1a0> @ imm = #0x3a
 800575c: 2301         	movs	r3, #0x1
 800575e: 77fb         	strb	r3, [r7, #0x1f]
 8005760: 7ffb         	ldrb	r3, [r7, #0x1f]
 8005762: f083 0301    	eor	r3, r3, #0x1
 8005766: b2db         	uxtb	r3, r3
 8005768: 2b00         	cmp	r3, #0x0
 800576a: d115         	bne	0x8005798 <can_stm32_remove_rx_filter+0x1a0> @ imm = #0x2a
 800576c: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8005848 <can_stm32_remove_rx_filter+0x250>
 800576e: 6819         	ldr	r1, [r3]
 8005770: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8005774: 9305         	str	r3, [sp, #0x14]
 8005776: 683b         	ldr	r3, [r7]
 8005778: 9304         	str	r3, [sp, #0x10]
 800577a: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8005854 <can_stm32_remove_rx_filter+0x25c>
 800577c: 9303         	str	r3, [sp, #0xc]
 800577e: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8005858 <can_stm32_remove_rx_filter+0x260>
 8005780: 9302         	str	r3, [sp, #0x8]
 8005782: 2308         	movs	r3, #0x8
 8005784: 9301         	str	r3, [sp, #0x4]
 8005786: 2300         	movs	r3, #0x0
 8005788: 9300         	str	r3, [sp]
 800578a: 2300         	movs	r3, #0x0
 800578c: 2204         	movs	r2, #0x4
 800578e: 2000         	movs	r0, #0x0
 8005790: f00d fd68    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xdad0
 8005794: 2300         	movs	r3, #0x0
 8005796: 61bb         	str	r3, [r7, #0x18]
; 	can->FMR |= CAN_FMR_FINIT;
 8005798: 6a7b         	ldr	r3, [r7, #0x24]
 800579a: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 800579e: f043 0201    	orr	r2, r3, #0x1
 80057a2: 6a7b         	ldr	r3, [r7, #0x24]
 80057a4: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	can_stm32_set_filter_bank(filter_id, &can->sFilterRegister[bank_num],
 80057a8: 6bbb         	ldr	r3, [r7, #0x38]
 80057aa: 3348         	adds	r3, #0x48
 80057ac: 00db         	lsls	r3, r3, #0x3
 80057ae: 6a7a         	ldr	r2, [r7, #0x24]
 80057b0: 18d1         	adds	r1, r2, r3
 80057b2: f897 2037    	ldrb.w	r2, [r7, #0x37]
 80057b6: f04f 33ff    	mov.w	r3, #0xffffffff
 80057ba: 9300         	str	r3, [sp]
 80057bc: 2300         	movs	r3, #0x0
 80057be: 6838         	ldr	r0, [r7]
 80057c0: f00d ff92    	bl	0x80136e8 <can_stm32_set_filter_bank> @ imm = #0xdf24
; 	if (bank_unused) {
 80057c4: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 80057c8: 2b00         	cmp	r3, #0x0
 80057ca: d029         	beq	0x8005820 <can_stm32_remove_rx_filter+0x228> @ imm = #0x52
; 		can->FA1R &= ~(1U << bank_num);
 80057cc: 6a7b         	ldr	r3, [r7, #0x24]
 80057ce: f8d3 221c    	ldr.w	r2, [r3, #0x21c]
 80057d2: 2101         	movs	r1, #0x1
 80057d4: 6bbb         	ldr	r3, [r7, #0x38]
 80057d6: fa01 f303    	lsl.w	r3, r1, r3
 80057da: 43db         	mvns	r3, r3
 80057dc: 401a         	ands	r2, r3
 80057de: 6a7b         	ldr	r3, [r7, #0x24]
 80057e0: f8c3 221c    	str.w	r2, [r3, #0x21c]
; 		LOG_DBG("Filter bank %d is unused -> deactivate", bank_num);
 80057e4: 2303         	movs	r3, #0x3
 80057e6: 2b03         	cmp	r3, #0x3
 80057e8: d91a         	bls	0x8005820 <can_stm32_remove_rx_filter+0x228> @ imm = #0x34
 80057ea: 2301         	movs	r3, #0x1
 80057ec: 75fb         	strb	r3, [r7, #0x17]
 80057ee: 7dfb         	ldrb	r3, [r7, #0x17]
 80057f0: f083 0301    	eor	r3, r3, #0x1
 80057f4: b2db         	uxtb	r3, r3
 80057f6: 2b00         	cmp	r3, #0x0
 80057f8: d112         	bne	0x8005820 <can_stm32_remove_rx_filter+0x228> @ imm = #0x24
 80057fa: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8005848 <can_stm32_remove_rx_filter+0x250>
 80057fc: 6819         	ldr	r1, [r3]
 80057fe: 6bbb         	ldr	r3, [r7, #0x38]
 8005800: 9304         	str	r3, [sp, #0x10]
 8005802: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8005854 <can_stm32_remove_rx_filter+0x25c>
 8005804: 9303         	str	r3, [sp, #0xc]
 8005806: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800585c <can_stm32_remove_rx_filter+0x264>
 8005808: 9302         	str	r3, [sp, #0x8]
 800580a: 2308         	movs	r3, #0x8
 800580c: 9301         	str	r3, [sp, #0x4]
 800580e: 2300         	movs	r3, #0x0
 8005810: 9300         	str	r3, [sp]
 8005812: 2300         	movs	r3, #0x0
 8005814: 2204         	movs	r2, #0x4
 8005816: 2000         	movs	r0, #0x0
 8005818: f00d fd24    	bl	0x8013264 <z_log_msg_runtime_create> @ imm = #0xda48
 800581c: 2300         	movs	r3, #0x0
 800581e: 613b         	str	r3, [r7, #0x10]
; 	can->FMR &= ~(CAN_FMR_FINIT);
 8005820: 6a7b         	ldr	r3, [r7, #0x24]
 8005822: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 8005826: f023 0201    	bic	r2, r3, #0x1
 800582a: 6a7b         	ldr	r3, [r7, #0x24]
 800582c: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	k_mutex_unlock(&data->inst_mutex);
 8005830: 6abb         	ldr	r3, [r7, #0x28]
 8005832: 3310         	adds	r3, #0x10
 8005834: 4618         	mov	r0, r3
 8005836: f00d fc42    	bl	0x80130be <k_mutex_unlock> @ imm = #0xd884
; 	k_mutex_unlock(&filter_mutex);
 800583a: 4805         	ldr	r0, [pc, #0x14]         @ 0x8005850 <can_stm32_remove_rx_filter+0x258>
 800583c: f00d fc3f    	bl	0x80130be <k_mutex_unlock> @ imm = #0xd87e
; }
 8005840: 3740         	adds	r7, #0x40
 8005842: 46bd         	mov	sp, r7
 8005844: bd80         	pop	{r7, pc}
 8005846: bf00         	nop

08005848 <$d>:
 8005848: 54 04 00 20  	.word	0x20000454
 800584c: a8 be 01 08  	.word	0x0801bea8
 8005850: e4 0b 00 20  	.word	0x20000be4
 8005854: a4 d1 01 08  	.word	0x0801d1a4
 8005858: c4 be 01 08  	.word	0x0801bec4
 800585c: e8 be 01 08  	.word	0x0801bee8

08005860 <LL_RCC_HSE_DisableBypass>:
; {
 8005860: b480         	push	{r7}
 8005862: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 8005864: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005878 <LL_RCC_HSE_DisableBypass+0x18>
 8005866: 681b         	ldr	r3, [r3]
 8005868: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005878 <LL_RCC_HSE_DisableBypass+0x18>
 800586a: f423 2380    	bic	r3, r3, #0x40000
 800586e: 6013         	str	r3, [r2]
; }
 8005870: bf00         	nop
 8005872: 46bd         	mov	sp, r7
 8005874: bc80         	pop	{r7}
 8005876: 4770         	bx	lr

08005878 <$d>:
 8005878: 00 38 02 40  	.word	0x40023800

0800587c <LL_RCC_HSE_Enable>:
; {
 800587c: b480         	push	{r7}
 800587e: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSEON);
 8005880: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005894 <LL_RCC_HSE_Enable+0x18>
 8005882: 681b         	ldr	r3, [r3]
 8005884: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005894 <LL_RCC_HSE_Enable+0x18>
 8005886: f443 3380    	orr	r3, r3, #0x10000
 800588a: 6013         	str	r3, [r2]
; }
 800588c: bf00         	nop
 800588e: 46bd         	mov	sp, r7
 8005890: bc80         	pop	{r7}
 8005892: 4770         	bx	lr

08005894 <$d>:
 8005894: 00 38 02 40  	.word	0x40023800

08005898 <LL_RCC_HSE_IsReady>:
; {
 8005898: b480         	push	{r7}
 800589a: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
 800589c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80058b8 <LL_RCC_HSE_IsReady+0x20>
 800589e: 681b         	ldr	r3, [r3]
 80058a0: f403 3300    	and	r3, r3, #0x20000
 80058a4: f5b3 3f00    	cmp.w	r3, #0x20000
 80058a8: bf0c         	ite	eq
 80058aa: 2301         	moveq	r3, #0x1
 80058ac: 2300         	movne	r3, #0x0
 80058ae: b2db         	uxtb	r3, r3
; }
 80058b0: 4618         	mov	r0, r3
 80058b2: 46bd         	mov	sp, r7
 80058b4: bc80         	pop	{r7}
 80058b6: 4770         	bx	lr

080058b8 <$d>:
 80058b8: 00 38 02 40  	.word	0x40023800

080058bc <LL_RCC_HSI_Enable>:
; {
 80058bc: b480         	push	{r7}
 80058be: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSION);
 80058c0: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80058d4 <LL_RCC_HSI_Enable+0x18>
 80058c2: 681b         	ldr	r3, [r3]
 80058c4: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80058d4 <LL_RCC_HSI_Enable+0x18>
 80058c6: f043 0301    	orr	r3, r3, #0x1
 80058ca: 6013         	str	r3, [r2]
; }
 80058cc: bf00         	nop
 80058ce: 46bd         	mov	sp, r7
 80058d0: bc80         	pop	{r7}
 80058d2: 4770         	bx	lr

080058d4 <$d>:
 80058d4: 00 38 02 40  	.word	0x40023800

080058d8 <LL_RCC_HSI_IsReady>:
; {
 80058d8: b480         	push	{r7}
 80058da: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
 80058dc: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80058f8 <LL_RCC_HSI_IsReady+0x20>
 80058de: 681b         	ldr	r3, [r3]
 80058e0: f003 0302    	and	r3, r3, #0x2
 80058e4: 2b02         	cmp	r3, #0x2
 80058e6: bf0c         	ite	eq
 80058e8: 2301         	moveq	r3, #0x1
 80058ea: 2300         	movne	r3, #0x0
 80058ec: b2db         	uxtb	r3, r3
; }
 80058ee: 4618         	mov	r0, r3
 80058f0: 46bd         	mov	sp, r7
 80058f2: bc80         	pop	{r7}
 80058f4: 4770         	bx	lr
 80058f6: bf00         	nop

080058f8 <$d>:
 80058f8: 00 38 02 40  	.word	0x40023800

080058fc <LL_RCC_LSI_Enable>:
; {
 80058fc: b480         	push	{r7}
 80058fe: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CSR, RCC_CSR_LSION);
 8005900: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005914 <LL_RCC_LSI_Enable+0x18>
 8005902: 6f5b         	ldr	r3, [r3, #0x74]
 8005904: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005914 <LL_RCC_LSI_Enable+0x18>
 8005906: f043 0301    	orr	r3, r3, #0x1
 800590a: 6753         	str	r3, [r2, #0x74]
; }
 800590c: bf00         	nop
 800590e: 46bd         	mov	sp, r7
 8005910: bc80         	pop	{r7}
 8005912: 4770         	bx	lr

08005914 <$d>:
 8005914: 00 38 02 40  	.word	0x40023800

08005918 <LL_RCC_LSI_IsReady>:
; {
 8005918: b480         	push	{r7}
 800591a: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY));
 800591c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005938 <LL_RCC_LSI_IsReady+0x20>
 800591e: 6f5b         	ldr	r3, [r3, #0x74]
 8005920: f003 0302    	and	r3, r3, #0x2
 8005924: 2b02         	cmp	r3, #0x2
 8005926: bf0c         	ite	eq
 8005928: 2301         	moveq	r3, #0x1
 800592a: 2300         	movne	r3, #0x0
 800592c: b2db         	uxtb	r3, r3
; }
 800592e: 4618         	mov	r0, r3
 8005930: 46bd         	mov	sp, r7
 8005932: bc80         	pop	{r7}
 8005934: 4770         	bx	lr
 8005936: bf00         	nop

08005938 <$d>:
 8005938: 00 38 02 40  	.word	0x40023800

0800593c <LL_RCC_SetSysClkSource>:
; {
 800593c: b480         	push	{r7}
 800593e: b083         	sub	sp, #0xc
 8005940: af00         	add	r7, sp, #0x0
 8005942: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8005944: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005960 <LL_RCC_SetSysClkSource+0x24>
 8005946: 689b         	ldr	r3, [r3, #0x8]
 8005948: f023 0203    	bic	r2, r3, #0x3
 800594c: 4904         	ldr	r1, [pc, #0x10]         @ 0x8005960 <LL_RCC_SetSysClkSource+0x24>
 800594e: 687b         	ldr	r3, [r7, #0x4]
 8005950: 4313         	orrs	r3, r2
 8005952: 608b         	str	r3, [r1, #0x8]
; }
 8005954: bf00         	nop
 8005956: 370c         	adds	r7, #0xc
 8005958: 46bd         	mov	sp, r7
 800595a: bc80         	pop	{r7}
 800595c: 4770         	bx	lr
 800595e: bf00         	nop

08005960 <$d>:
 8005960: 00 38 02 40  	.word	0x40023800

08005964 <LL_RCC_GetSysClkSource>:
; {
 8005964: b480         	push	{r7}
 8005966: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8005968: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8005978 <LL_RCC_GetSysClkSource+0x14>
 800596a: 689b         	ldr	r3, [r3, #0x8]
 800596c: f003 030c    	and	r3, r3, #0xc
; }
 8005970: 4618         	mov	r0, r3
 8005972: 46bd         	mov	sp, r7
 8005974: bc80         	pop	{r7}
 8005976: 4770         	bx	lr

08005978 <$d>:
 8005978: 00 38 02 40  	.word	0x40023800

0800597c <LL_RCC_SetAHBPrescaler>:
; {
 800597c: b480         	push	{r7}
 800597e: b083         	sub	sp, #0xc
 8005980: af00         	add	r7, sp, #0x0
 8005982: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8005984: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80059a0 <LL_RCC_SetAHBPrescaler+0x24>
 8005986: 689b         	ldr	r3, [r3, #0x8]
 8005988: f023 02f0    	bic	r2, r3, #0xf0
 800598c: 4904         	ldr	r1, [pc, #0x10]         @ 0x80059a0 <LL_RCC_SetAHBPrescaler+0x24>
 800598e: 687b         	ldr	r3, [r7, #0x4]
 8005990: 4313         	orrs	r3, r2
 8005992: 608b         	str	r3, [r1, #0x8]
; }
 8005994: bf00         	nop
 8005996: 370c         	adds	r7, #0xc
 8005998: 46bd         	mov	sp, r7
 800599a: bc80         	pop	{r7}
 800599c: 4770         	bx	lr
 800599e: bf00         	nop

080059a0 <$d>:
 80059a0: 00 38 02 40  	.word	0x40023800

080059a4 <LL_RCC_SetAPB1Prescaler>:
; {
 80059a4: b480         	push	{r7}
 80059a6: b083         	sub	sp, #0xc
 80059a8: af00         	add	r7, sp, #0x0
 80059aa: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 80059ac: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80059c8 <LL_RCC_SetAPB1Prescaler+0x24>
 80059ae: 689b         	ldr	r3, [r3, #0x8]
 80059b0: f423 52e0    	bic	r2, r3, #0x1c00
 80059b4: 4904         	ldr	r1, [pc, #0x10]         @ 0x80059c8 <LL_RCC_SetAPB1Prescaler+0x24>
 80059b6: 687b         	ldr	r3, [r7, #0x4]
 80059b8: 4313         	orrs	r3, r2
 80059ba: 608b         	str	r3, [r1, #0x8]
; }
 80059bc: bf00         	nop
 80059be: 370c         	adds	r7, #0xc
 80059c0: 46bd         	mov	sp, r7
 80059c2: bc80         	pop	{r7}
 80059c4: 4770         	bx	lr
 80059c6: bf00         	nop

080059c8 <$d>:
 80059c8: 00 38 02 40  	.word	0x40023800

080059cc <LL_RCC_SetAPB2Prescaler>:
; {
 80059cc: b480         	push	{r7}
 80059ce: b083         	sub	sp, #0xc
 80059d0: af00         	add	r7, sp, #0x0
 80059d2: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 80059d4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80059f0 <LL_RCC_SetAPB2Prescaler+0x24>
 80059d6: 689b         	ldr	r3, [r3, #0x8]
 80059d8: f423 4260    	bic	r2, r3, #0xe000
 80059dc: 4904         	ldr	r1, [pc, #0x10]         @ 0x80059f0 <LL_RCC_SetAPB2Prescaler+0x24>
 80059de: 687b         	ldr	r3, [r7, #0x4]
 80059e0: 4313         	orrs	r3, r2
 80059e2: 608b         	str	r3, [r1, #0x8]
; }
 80059e4: bf00         	nop
 80059e6: 370c         	adds	r7, #0xc
 80059e8: 46bd         	mov	sp, r7
 80059ea: bc80         	pop	{r7}
 80059ec: 4770         	bx	lr
 80059ee: bf00         	nop

080059f0 <$d>:
 80059f0: 00 38 02 40  	.word	0x40023800

080059f4 <LL_RCC_GetAHBPrescaler>:
; {
 80059f4: b480         	push	{r7}
 80059f6: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 80059f8: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8005a08 <LL_RCC_GetAHBPrescaler+0x14>
 80059fa: 689b         	ldr	r3, [r3, #0x8]
 80059fc: f003 03f0    	and	r3, r3, #0xf0
; }
 8005a00: 4618         	mov	r0, r3
 8005a02: 46bd         	mov	sp, r7
 8005a04: bc80         	pop	{r7}
 8005a06: 4770         	bx	lr

08005a08 <$d>:
 8005a08: 00 38 02 40  	.word	0x40023800

08005a0c <LL_RCC_PLL_Enable>:
; {
 8005a0c: b480         	push	{r7}
 8005a0e: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_PLLON);
 8005a10: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005a24 <LL_RCC_PLL_Enable+0x18>
 8005a12: 681b         	ldr	r3, [r3]
 8005a14: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005a24 <LL_RCC_PLL_Enable+0x18>
 8005a16: f043 7380    	orr	r3, r3, #0x1000000
 8005a1a: 6013         	str	r3, [r2]
; }
 8005a1c: bf00         	nop
 8005a1e: 46bd         	mov	sp, r7
 8005a20: bc80         	pop	{r7}
 8005a22: 4770         	bx	lr

08005a24 <$d>:
 8005a24: 00 38 02 40  	.word	0x40023800

08005a28 <LL_RCC_PLL_Disable>:
; {
 8005a28: b480         	push	{r7}
 8005a2a: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8005a2c: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005a40 <LL_RCC_PLL_Disable+0x18>
 8005a2e: 681b         	ldr	r3, [r3]
 8005a30: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005a40 <LL_RCC_PLL_Disable+0x18>
 8005a32: f023 7380    	bic	r3, r3, #0x1000000
 8005a36: 6013         	str	r3, [r2]
; }
 8005a38: bf00         	nop
 8005a3a: 46bd         	mov	sp, r7
 8005a3c: bc80         	pop	{r7}
 8005a3e: 4770         	bx	lr

08005a40 <$d>:
 8005a40: 00 38 02 40  	.word	0x40023800

08005a44 <LL_RCC_PLL_IsReady>:
; {
 8005a44: b480         	push	{r7}
 8005a46: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 8005a48: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005a64 <LL_RCC_PLL_IsReady+0x20>
 8005a4a: 681b         	ldr	r3, [r3]
 8005a4c: f003 7300    	and	r3, r3, #0x2000000
 8005a50: f1b3 7f00    	cmp.w	r3, #0x2000000
 8005a54: bf0c         	ite	eq
 8005a56: 2301         	moveq	r3, #0x1
 8005a58: 2300         	movne	r3, #0x0
 8005a5a: b2db         	uxtb	r3, r3
; }
 8005a5c: 4618         	mov	r0, r3
 8005a5e: 46bd         	mov	sp, r7
 8005a60: bc80         	pop	{r7}
 8005a62: 4770         	bx	lr

08005a64 <$d>:
 8005a64: 00 38 02 40  	.word	0x40023800

08005a68 <enabled_clock>:
; {
 8005a68: b480         	push	{r7}
 8005a6a: b085         	sub	sp, #0x14
 8005a6c: af00         	add	r7, sp, #0x0
 8005a6e: 6078         	str	r0, [r7, #0x4]
; 	int r = 0;
 8005a70: 2300         	movs	r3, #0x0
 8005a72: 60fb         	str	r3, [r7, #0xc]
; 	switch (src_clk) {
 8005a74: 687b         	ldr	r3, [r7, #0x4]
 8005a76: 3b01         	subs	r3, #0x1
 8005a78: 2b08         	cmp	r3, #0x8
 8005a7a: d825         	bhi	0x8005ac8 <enabled_clock+0x60> @ imm = #0x4a
 8005a7c: a201         	adr	r2, #4 <enabled_clock+0x19>
 8005a7e: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8005a82: bf00         	nop

08005a84 <$d>:
 8005a84: cf 5a 00 08  	.word	0x08005acf
 8005a88: b1 5a 00 08  	.word	0x08005ab1
 8005a8c: cf 5a 00 08  	.word	0x08005acf
 8005a90: a9 5a 00 08  	.word	0x08005aa9
 8005a94: cf 5a 00 08  	.word	0x08005acf
 8005a98: cf 5a 00 08  	.word	0x08005acf
 8005a9c: cf 5a 00 08  	.word	0x08005acf
 8005aa0: b9 5a 00 08  	.word	0x08005ab9
 8005aa4: c1 5a 00 08  	.word	0x08005ac1

08005aa8 <$t>:
; 			r = -ENOTSUP;
 8005aa8: f06f 0385    	mvn	r3, #0x85
 8005aac: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8005aae: e00f         	b	0x8005ad0 <enabled_clock+0x68> @ imm = #0x1e
; 			r = -ENOTSUP;
 8005ab0: f06f 0385    	mvn	r3, #0x85
 8005ab4: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8005ab6: e00b         	b	0x8005ad0 <enabled_clock+0x68> @ imm = #0x16
; 			r = -ENOTSUP;
 8005ab8: f06f 0385    	mvn	r3, #0x85
 8005abc: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8005abe: e007         	b	0x8005ad0 <enabled_clock+0x68> @ imm = #0xe
; 			r = -ENOTSUP;
 8005ac0: f06f 0385    	mvn	r3, #0x85
 8005ac4: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8005ac6: e003         	b	0x8005ad0 <enabled_clock+0x68> @ imm = #0x6
; 		return -ENOTSUP;
 8005ac8: f06f 0385    	mvn	r3, #0x85
 8005acc: e001         	b	0x8005ad2 <enabled_clock+0x6a> @ imm = #0x2
; 		break;
 8005ace: bf00         	nop
; 	return r;
 8005ad0: 68fb         	ldr	r3, [r7, #0xc]
; }
 8005ad2: 4618         	mov	r0, r3
 8005ad4: 3714         	adds	r7, #0x14
 8005ad6: 46bd         	mov	sp, r7
 8005ad8: bc80         	pop	{r7}
 8005ada: 4770         	bx	lr

08005adc <stm32_clock_control_get_subsys_rate>:
; {
 8005adc: b580         	push	{r7, lr}
 8005ade: b08a         	sub	sp, #0x28
 8005ae0: af00         	add	r7, sp, #0x0
 8005ae2: 60f8         	str	r0, [r7, #0xc]
 8005ae4: 60b9         	str	r1, [r7, #0x8]
 8005ae6: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 8005ae8: 68bb         	ldr	r3, [r7, #0x8]
 8005aea: 627b         	str	r3, [r7, #0x24]
; 	uint32_t ahb_clock = SystemCoreClock;
 8005aec: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8005cd0 <stm32_clock_control_get_subsys_rate+0x1f4>
 8005aee: 681b         	ldr	r3, [r3]
 8005af0: 623b         	str	r3, [r7, #0x20]
; 	uint32_t apb1_clock = get_bus_clock(ahb_clock, STM32_APB1_PRESCALER);
 8005af2: 2104         	movs	r1, #0x4
 8005af4: 6a38         	ldr	r0, [r7, #0x20]
 8005af6: f00d fecb    	bl	0x8013890 <get_bus_clock> @ imm = #0xdd96
 8005afa: 61f8         	str	r0, [r7, #0x1c]
; 	uint32_t apb2_clock = get_bus_clock(ahb_clock, STM32_APB2_PRESCALER);
 8005afc: 2102         	movs	r1, #0x2
 8005afe: 6a38         	ldr	r0, [r7, #0x20]
 8005b00: f00d fec6    	bl	0x8013890 <get_bus_clock> @ imm = #0xdd8c
 8005b04: 61b8         	str	r0, [r7, #0x18]
; 	uint32_t ahb3_clock = ahb_clock;
 8005b06: 6a3b         	ldr	r3, [r7, #0x20]
 8005b08: 617b         	str	r3, [r7, #0x14]
; 	switch (pclken->bus) {
 8005b0a: 6a7b         	ldr	r3, [r7, #0x24]
 8005b0c: 681b         	ldr	r3, [r3]
 8005b0e: 2b44         	cmp	r3, #0x44
 8005b10: f200 8092    	bhi.w	0x8005c38 <stm32_clock_control_get_subsys_rate+0x15c> @ imm = #0x124
 8005b14: 2b00         	cmp	r3, #0x0
 8005b16: f000 80d2    	beq.w	0x8005cbe <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x1a4
 8005b1a: 3b01         	subs	r3, #0x1
 8005b1c: 2b43         	cmp	r3, #0x43
 8005b1e: f200 80ce    	bhi.w	0x8005cbe <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x19c
 8005b22: a201         	adr	r2, #4 <stm32_clock_control_get_subsys_rate+0x4b>
 8005b24: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08005b28 <$d>:
 8005b28: 67 5c 00 08  	.word	0x08005c67
 8005b2c: 9d 5c 00 08  	.word	0x08005c9d
 8005b30: a5 5c 00 08  	.word	0x08005ca5
 8005b34: af 5c 00 08  	.word	0x08005caf
 8005b38: b7 5c 00 08  	.word	0x08005cb7
 8005b3c: 71 5c 00 08  	.word	0x08005c71
 8005b40: 87 5c 00 08  	.word	0x08005c87
 8005b44: bf 5c 00 08  	.word	0x08005cbf
 8005b48: bf 5c 00 08  	.word	0x08005cbf
 8005b4c: bf 5c 00 08  	.word	0x08005cbf
 8005b50: bf 5c 00 08  	.word	0x08005cbf
 8005b54: bf 5c 00 08  	.word	0x08005cbf
 8005b58: bf 5c 00 08  	.word	0x08005cbf
 8005b5c: bf 5c 00 08  	.word	0x08005cbf
 8005b60: bf 5c 00 08  	.word	0x08005cbf
 8005b64: bf 5c 00 08  	.word	0x08005cbf
 8005b68: bf 5c 00 08  	.word	0x08005cbf
 8005b6c: bf 5c 00 08  	.word	0x08005cbf
 8005b70: bf 5c 00 08  	.word	0x08005cbf
 8005b74: bf 5c 00 08  	.word	0x08005cbf
 8005b78: bf 5c 00 08  	.word	0x08005cbf
 8005b7c: bf 5c 00 08  	.word	0x08005cbf
 8005b80: bf 5c 00 08  	.word	0x08005cbf
 8005b84: bf 5c 00 08  	.word	0x08005cbf
 8005b88: bf 5c 00 08  	.word	0x08005cbf
 8005b8c: bf 5c 00 08  	.word	0x08005cbf
 8005b90: bf 5c 00 08  	.word	0x08005cbf
 8005b94: bf 5c 00 08  	.word	0x08005cbf
 8005b98: bf 5c 00 08  	.word	0x08005cbf
 8005b9c: bf 5c 00 08  	.word	0x08005cbf
 8005ba0: bf 5c 00 08  	.word	0x08005cbf
 8005ba4: bf 5c 00 08  	.word	0x08005cbf
 8005ba8: bf 5c 00 08  	.word	0x08005cbf
 8005bac: bf 5c 00 08  	.word	0x08005cbf
 8005bb0: bf 5c 00 08  	.word	0x08005cbf
 8005bb4: bf 5c 00 08  	.word	0x08005cbf
 8005bb8: bf 5c 00 08  	.word	0x08005cbf
 8005bbc: bf 5c 00 08  	.word	0x08005cbf
 8005bc0: bf 5c 00 08  	.word	0x08005cbf
 8005bc4: bf 5c 00 08  	.word	0x08005cbf
 8005bc8: bf 5c 00 08  	.word	0x08005cbf
 8005bcc: bf 5c 00 08  	.word	0x08005cbf
 8005bd0: bf 5c 00 08  	.word	0x08005cbf
 8005bd4: bf 5c 00 08  	.word	0x08005cbf
 8005bd8: bf 5c 00 08  	.word	0x08005cbf
 8005bdc: bf 5c 00 08  	.word	0x08005cbf
 8005be0: bf 5c 00 08  	.word	0x08005cbf
 8005be4: 3f 5c 00 08  	.word	0x08005c3f
 8005be8: bf 5c 00 08  	.word	0x08005cbf
 8005bec: bf 5c 00 08  	.word	0x08005cbf
 8005bf0: bf 5c 00 08  	.word	0x08005cbf
 8005bf4: 3f 5c 00 08  	.word	0x08005c3f
 8005bf8: bf 5c 00 08  	.word	0x08005cbf
 8005bfc: bf 5c 00 08  	.word	0x08005cbf
 8005c00: bf 5c 00 08  	.word	0x08005cbf
 8005c04: 47 5c 00 08  	.word	0x08005c47
 8005c08: bf 5c 00 08  	.word	0x08005cbf
 8005c0c: bf 5c 00 08  	.word	0x08005cbf
 8005c10: bf 5c 00 08  	.word	0x08005cbf
 8005c14: bf 5c 00 08  	.word	0x08005cbf
 8005c18: bf 5c 00 08  	.word	0x08005cbf
 8005c1c: bf 5c 00 08  	.word	0x08005cbf
 8005c20: bf 5c 00 08  	.word	0x08005cbf
 8005c24: 4f 5c 00 08  	.word	0x08005c4f
 8005c28: bf 5c 00 08  	.word	0x08005cbf
 8005c2c: bf 5c 00 08  	.word	0x08005cbf
 8005c30: bf 5c 00 08  	.word	0x08005cbf
 8005c34: 57 5c 00 08  	.word	0x08005c57

08005c38 <$t>:
 8005c38: 2ba8         	cmp	r3, #0xa8
 8005c3a: d010         	beq	0x8005c5e <stm32_clock_control_get_subsys_rate+0x182> @ imm = #0x20
 8005c3c: e03f         	b	0x8005cbe <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x7e
; 		*rate = ahb_clock;
 8005c3e: 687b         	ldr	r3, [r7, #0x4]
 8005c40: 6a3a         	ldr	r2, [r7, #0x20]
 8005c42: 601a         	str	r2, [r3]
; 		break;
 8005c44: e03e         	b	0x8005cc4 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x7c
; 		*rate = ahb3_clock;
 8005c46: 687b         	ldr	r3, [r7, #0x4]
 8005c48: 697a         	ldr	r2, [r7, #0x14]
 8005c4a: 601a         	str	r2, [r3]
; 		break;
 8005c4c: e03a         	b	0x8005cc4 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x74
; 		*rate = apb1_clock;
 8005c4e: 687b         	ldr	r3, [r7, #0x4]
 8005c50: 69fa         	ldr	r2, [r7, #0x1c]
 8005c52: 601a         	str	r2, [r3]
; 		break;
 8005c54: e036         	b	0x8005cc4 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x6c
; 		*rate = apb2_clock;
 8005c56: 687b         	ldr	r3, [r7, #0x4]
 8005c58: 69ba         	ldr	r2, [r7, #0x18]
 8005c5a: 601a         	str	r2, [r3]
; 		break;
 8005c5c: e032         	b	0x8005cc4 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x64
; 		*rate = ahb3_clock;
 8005c5e: 687b         	ldr	r3, [r7, #0x4]
 8005c60: 697a         	ldr	r2, [r7, #0x14]
 8005c62: 601a         	str	r2, [r3]
; 		break;
 8005c64: e02e         	b	0x8005cc4 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x5c
; 		*rate = SystemCoreClock * STM32_CORE_PRESCALER;
 8005c66: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8005cd0 <stm32_clock_control_get_subsys_rate+0x1f4>
 8005c68: 681a         	ldr	r2, [r3]
 8005c6a: 687b         	ldr	r3, [r7, #0x4]
 8005c6c: 601a         	str	r2, [r3]
; 		break;
 8005c6e: e029         	b	0x8005cc4 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x52
; 		*rate = get_pll_div_frequency(get_pllsrc_frequency(),
 8005c70: f000 f8f0    	bl	0x8005e54 <get_pllsrc_frequency> @ imm = #0x1e0
 8005c74: 2302         	movs	r3, #0x2
 8005c76: 22a8         	movs	r2, #0xa8
 8005c78: 2106         	movs	r1, #0x6
 8005c7a: f00d fdf3    	bl	0x8013864 <get_pll_div_frequency> @ imm = #0xdbe6
 8005c7e: 4602         	mov	r2, r0
 8005c80: 687b         	ldr	r3, [r7, #0x4]
 8005c82: 601a         	str	r2, [r3]
; 		break;
 8005c84: e01e         	b	0x8005cc4 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x3c
; 		*rate = get_pll_div_frequency(get_pllsrc_frequency(),
 8005c86: f000 f8e5    	bl	0x8005e54 <get_pllsrc_frequency> @ imm = #0x1ca
 8005c8a: 2304         	movs	r3, #0x4
 8005c8c: 22a8         	movs	r2, #0xa8
 8005c8e: 2106         	movs	r1, #0x6
 8005c90: f00d fde8    	bl	0x8013864 <get_pll_div_frequency> @ imm = #0xdbd0
 8005c94: 4602         	mov	r2, r0
 8005c96: 687b         	ldr	r3, [r7, #0x4]
 8005c98: 601a         	str	r2, [r3]
; 		break;
 8005c9a: e013         	b	0x8005cc4 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x26
; 		*rate = STM32_LSE_FREQ;
 8005c9c: 687b         	ldr	r3, [r7, #0x4]
 8005c9e: 2200         	movs	r2, #0x0
 8005ca0: 601a         	str	r2, [r3]
; 		break;
 8005ca2: e00f         	b	0x8005cc4 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x1e
; 		*rate = STM32_LSI_FREQ;
 8005ca4: 687b         	ldr	r3, [r7, #0x4]
 8005ca6: f44f 42fa    	mov.w	r2, #0x7d00
 8005caa: 601a         	str	r2, [r3]
; 		break;
 8005cac: e00a         	b	0x8005cc4 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x14
; 		*rate = STM32_HSI_FREQ;
 8005cae: 687b         	ldr	r3, [r7, #0x4]
 8005cb0: 2200         	movs	r2, #0x0
 8005cb2: 601a         	str	r2, [r3]
; 		break;
 8005cb4: e006         	b	0x8005cc4 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0xc
; 		*rate = STM32_HSE_FREQ;
 8005cb6: 687b         	ldr	r3, [r7, #0x4]
 8005cb8: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8005cd4 <stm32_clock_control_get_subsys_rate+0x1f8>
 8005cba: 601a         	str	r2, [r3]
; 		break;
 8005cbc: e002         	b	0x8005cc4 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x4
; 		return -ENOTSUP;
 8005cbe: f06f 0385    	mvn	r3, #0x85
 8005cc2: e000         	b	0x8005cc6 <stm32_clock_control_get_subsys_rate+0x1ea> @ imm = #0x0
; 	return 0;
 8005cc4: 2300         	movs	r3, #0x0
; }
 8005cc6: 4618         	mov	r0, r3
 8005cc8: 3728         	adds	r7, #0x28
 8005cca: 46bd         	mov	sp, r7
 8005ccc: bd80         	pop	{r7, pc}
 8005cce: bf00         	nop

08005cd0 <$d>:
 8005cd0: 34 05 00 20  	.word	0x20000534
 8005cd4: 00 1b b7 00  	.word	0x00b71b00

08005cd8 <set_up_plls>:
; {
 8005cd8: b580         	push	{r7, lr}
 8005cda: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_GetSysClkSource() == LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
 8005cdc: f7ff fe42    	bl	0x8005964 <LL_RCC_GetSysClkSource> @ imm = #-0x37c
 8005ce0: 4603         	mov	r3, r0
 8005ce2: 2b08         	cmp	r3, #0x8
 8005ce4: d104         	bne	0x8005cf0 <set_up_plls+0x18> @ imm = #0x8
; 		stm32_clock_switch_to_hsi();
 8005ce6: f00d fedf    	bl	0x8013aa8 <stm32_clock_switch_to_hsi> @ imm = #0xddbe
; 		LL_RCC_SetAHBPrescaler(ahb_prescaler(1));
 8005cea: 2000         	movs	r0, #0x0
 8005cec: f7ff fe46    	bl	0x800597c <LL_RCC_SetAHBPrescaler> @ imm = #-0x374
; 	LL_RCC_PLL_Disable();
 8005cf0: f7ff fe9a    	bl	0x8005a28 <LL_RCC_PLL_Disable> @ imm = #-0x2cc
; 	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, pllp(STM32_PLL_P_DIVISOR));
 8005cf4: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8005d2c <set_up_plls+0x54>
 8005cf6: 685b         	ldr	r3, [r3, #0x4]
 8005cf8: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8005d2c <set_up_plls+0x54>
 8005cfa: f423 3340    	bic	r3, r3, #0x30000
 8005cfe: 6053         	str	r3, [r2, #0x4]
; 	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ, pllq(STM32_PLL_Q_DIVISOR));
 8005d00: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8005d2c <set_up_plls+0x54>
 8005d02: 685b         	ldr	r3, [r3, #0x4]
 8005d04: f023 6370    	bic	r3, r3, #0xf000000
 8005d08: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8005d2c <set_up_plls+0x54>
 8005d0a: f043 6380    	orr	r3, r3, #0x4000000
 8005d0e: 6053         	str	r3, [r2, #0x4]
; 	config_pll_sysclock();
 8005d10: f00d ff0d    	bl	0x8013b2e <config_pll_sysclock> @ imm = #0xde1a
; 	LL_RCC_PLL_Enable();
 8005d14: f7ff fe7a    	bl	0x8005a0c <LL_RCC_PLL_Enable> @ imm = #-0x30c
; 	while (LL_RCC_PLL_IsReady() != 1U) {
 8005d18: bf00         	nop
 8005d1a: f7ff fe93    	bl	0x8005a44 <LL_RCC_PLL_IsReady> @ imm = #-0x2da
 8005d1e: 4603         	mov	r3, r0
 8005d20: 2b01         	cmp	r3, #0x1
 8005d22: d1fa         	bne	0x8005d1a <set_up_plls+0x42> @ imm = #-0xc
; }
 8005d24: bf00         	nop
 8005d26: bf00         	nop
 8005d28: bd80         	pop	{r7, pc}
 8005d2a: bf00         	nop

08005d2c <$d>:
 8005d2c: 00 38 02 40  	.word	0x40023800

08005d30 <stm32_clock_control_init>:
; {
 8005d30: b590         	push	{r4, r7, lr}
 8005d32: b085         	sub	sp, #0x14
 8005d34: af00         	add	r7, sp, #0x0
 8005d36: 6078         	str	r0, [r7, #0x4]
; 	config_enable_default_clocks();
 8005d38: f00d ff04    	bl	0x8013b44 <config_enable_default_clocks> @ imm = #0xde08
; 	config_regulator_voltage(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC);
 8005d3c: 4823         	ldr	r0, [pc, #0x8c]         @ 0x8005dcc <stm32_clock_control_init+0x9c>
 8005d3e: f00d fee5    	bl	0x8013b0c <config_regulator_voltage> @ imm = #0xddca
; 	old_flash_freq = RCC_CALC_FLASH_FREQ(HAL_RCC_GetSysClockFreq(),
 8005d42: f005 fcaf    	bl	0x800b6a4 <HAL_RCC_GetSysClockFreq> @ imm = #0x595e
 8005d46: 4604         	mov	r4, r0
 8005d48: f7ff fe54    	bl	0x80059f4 <LL_RCC_GetAHBPrescaler> @ imm = #-0x358
 8005d4c: 4603         	mov	r3, r0
 8005d4e: 091b         	lsrs	r3, r3, #0x4
 8005d50: f003 030f    	and	r3, r3, #0xf
 8005d54: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x8005dd0 <stm32_clock_control_init+0xa0>
 8005d56: 5cd3         	ldrb	r3, [r2, r3]
 8005d58: fa24 f303    	lsr.w	r3, r4, r3
 8005d5c: 60fb         	str	r3, [r7, #0xc]
; 	new_flash_freq = RCC_CALC_FLASH_FREQ(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC,
 8005d5e: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8005dd0 <stm32_clock_control_init+0xa0>
 8005d60: 781b         	ldrb	r3, [r3]
 8005d62: 461a         	mov	r2, r3
 8005d64: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8005dcc <stm32_clock_control_init+0x9c>
 8005d66: 4113         	asrs	r3, r2
 8005d68: 60bb         	str	r3, [r7, #0x8]
; 	if (old_flash_freq < new_flash_freq) {
 8005d6a: 68fa         	ldr	r2, [r7, #0xc]
 8005d6c: 68bb         	ldr	r3, [r7, #0x8]
 8005d6e: 429a         	cmp	r2, r3
 8005d70: d202         	bhs	0x8005d78 <stm32_clock_control_init+0x48> @ imm = #0x4
; 		LL_SetFlashLatency(new_flash_freq);
 8005d72: 68b8         	ldr	r0, [r7, #0x8]
 8005d74: f005 fe88    	bl	0x800ba88 <LL_SetFlashLatency> @ imm = #0x5d10
; 	set_up_fixed_clock_sources();
 8005d78: f00d feb1    	bl	0x8013ade <set_up_fixed_clock_sources> @ imm = #0xdd62
; 	set_up_plls();
 8005d7c: f7ff ffac    	bl	0x8005cd8 <set_up_plls> @ imm = #-0xa8
; 		LL_RCC_SetAHBPrescaler(ahb_prescaler(STM32_CORE_PRESCALER));
 8005d80: 2000         	movs	r0, #0x0
 8005d82: f7ff fdfb    	bl	0x800597c <LL_RCC_SetAHBPrescaler> @ imm = #-0x40a
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
 8005d86: 2002         	movs	r0, #0x2
 8005d88: f7ff fdd8    	bl	0x800593c <LL_RCC_SetSysClkSource> @ imm = #-0x450
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
 8005d8c: bf00         	nop
 8005d8e: f7ff fde9    	bl	0x8005964 <LL_RCC_GetSysClkSource> @ imm = #-0x42e
 8005d92: 4603         	mov	r3, r0
 8005d94: 2b08         	cmp	r3, #0x8
 8005d96: d1fa         	bne	0x8005d8e <stm32_clock_control_init+0x5e> @ imm = #-0xc
; 	if (old_flash_freq >= new_flash_freq) {
 8005d98: 68fa         	ldr	r2, [r7, #0xc]
 8005d9a: 68bb         	ldr	r3, [r7, #0x8]
 8005d9c: 429a         	cmp	r2, r3
 8005d9e: d302         	blo	0x8005da6 <stm32_clock_control_init+0x76> @ imm = #0x4
; 		LL_SetFlashLatency(new_flash_freq);
 8005da0: 68b8         	ldr	r0, [r7, #0x8]
 8005da2: f005 fe71    	bl	0x800ba88 <LL_SetFlashLatency> @ imm = #0x5ce2
; 	SystemCoreClock = CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC;
 8005da6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8005dd4 <stm32_clock_control_init+0xa4>
 8005da8: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8005dcc <stm32_clock_control_init+0x9c>
 8005daa: 601a         	str	r2, [r3]
; 	LL_RCC_SetAPB1Prescaler(apb1_prescaler(STM32_APB1_PRESCALER));
 8005dac: f44f 50a0    	mov.w	r0, #0x1400
 8005db0: f7ff fdf8    	bl	0x80059a4 <LL_RCC_SetAPB1Prescaler> @ imm = #-0x410
; 	LL_RCC_SetAPB2Prescaler(apb2_prescaler(STM32_APB2_PRESCALER));
 8005db4: f44f 4000    	mov.w	r0, #0x8000
 8005db8: f7ff fe08    	bl	0x80059cc <LL_RCC_SetAPB2Prescaler> @ imm = #-0x3f0
; 	stm32_clock_control_mco_init();
 8005dbc: f00d fd4c    	bl	0x8013858 <stm32_clock_control_mco_init> @ imm = #0xda98
; 	return 0;
 8005dc0: 2300         	movs	r3, #0x0
; }
 8005dc2: 4618         	mov	r0, r3
 8005dc4: 3714         	adds	r7, #0x14
 8005dc6: 46bd         	mov	sp, r7
 8005dc8: bd90         	pop	{r4, r7, pc}
 8005dca: bf00         	nop

08005dcc <$d>:
 8005dcc: 00 7a 03 0a  	.word	0x0a037a00
 8005dd0: 7c d8 01 08  	.word	0x0801d87c
 8005dd4: 34 05 00 20  	.word	0x20000534

08005dd8 <LL_APB1_GRP1_EnableClock>:
; {
 8005dd8: b480         	push	{r7}
 8005dda: b085         	sub	sp, #0x14
 8005ddc: af00         	add	r7, sp, #0x0
 8005dde: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(RCC->APB1ENR, Periphs);
 8005de0: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8005e04 <LL_APB1_GRP1_EnableClock+0x2c>
 8005de2: 6c1a         	ldr	r2, [r3, #0x40]
 8005de4: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8005e04 <LL_APB1_GRP1_EnableClock+0x2c>
 8005de6: 687b         	ldr	r3, [r7, #0x4]
 8005de8: 4313         	orrs	r3, r2
 8005dea: 640b         	str	r3, [r1, #0x40]
;   tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 8005dec: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8005e04 <LL_APB1_GRP1_EnableClock+0x2c>
 8005dee: 6c1a         	ldr	r2, [r3, #0x40]
 8005df0: 687b         	ldr	r3, [r7, #0x4]
 8005df2: 4013         	ands	r3, r2
 8005df4: 60fb         	str	r3, [r7, #0xc]
;   (void)tmpreg;
 8005df6: 68fb         	ldr	r3, [r7, #0xc]
; }
 8005df8: bf00         	nop
 8005dfa: 3714         	adds	r7, #0x14
 8005dfc: 46bd         	mov	sp, r7
 8005dfe: bc80         	pop	{r7}
 8005e00: 4770         	bx	lr
 8005e02: bf00         	nop

08005e04 <$d>:
 8005e04: 00 38 02 40  	.word	0x40023800

08005e08 <LL_RCC_PLL_ConfigDomain_SYS>:
; {
 8005e08: b480         	push	{r7}
 8005e0a: b085         	sub	sp, #0x14
 8005e0c: af00         	add	r7, sp, #0x0
 8005e0e: 60f8         	str	r0, [r7, #0xc]
 8005e10: 60b9         	str	r1, [r7, #0x8]
 8005e12: 607a         	str	r2, [r7, #0x4]
 8005e14: 603b         	str	r3, [r7]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN,
 8005e16: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8005e4c <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8005e18: 685a         	ldr	r2, [r3, #0x4]
 8005e1a: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8005e50 <LL_RCC_PLL_ConfigDomain_SYS+0x48>
 8005e1c: 4013         	ands	r3, r2
 8005e1e: 68f9         	ldr	r1, [r7, #0xc]
 8005e20: 68ba         	ldr	r2, [r7, #0x8]
 8005e22: 4311         	orrs	r1, r2
 8005e24: 687a         	ldr	r2, [r7, #0x4]
 8005e26: 0192         	lsls	r2, r2, #0x6
 8005e28: 430a         	orrs	r2, r1
 8005e2a: 4908         	ldr	r1, [pc, #0x20]         @ 0x8005e4c <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8005e2c: 4313         	orrs	r3, r2
 8005e2e: 604b         	str	r3, [r1, #0x4]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, PLLP_R);
 8005e30: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005e4c <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8005e32: 685b         	ldr	r3, [r3, #0x4]
 8005e34: f423 3240    	bic	r2, r3, #0x30000
 8005e38: 4904         	ldr	r1, [pc, #0x10]         @ 0x8005e4c <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8005e3a: 683b         	ldr	r3, [r7]
 8005e3c: 4313         	orrs	r3, r2
 8005e3e: 604b         	str	r3, [r1, #0x4]
; }
 8005e40: bf00         	nop
 8005e42: 3714         	adds	r7, #0x14
 8005e44: 46bd         	mov	sp, r7
 8005e46: bc80         	pop	{r7}
 8005e48: 4770         	bx	lr
 8005e4a: bf00         	nop

08005e4c <$d>:
 8005e4c: 00 38 02 40  	.word	0x40023800
 8005e50: 00 80 bf ff  	.word	0xffbf8000

08005e54 <get_pllsrc_frequency>:
; {
 8005e54: b480         	push	{r7}
 8005e56: af00         	add	r7, sp, #0x0
; 		return STM32_HSE_FREQ;
 8005e58: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8005e64 <get_pllsrc_frequency+0x10>
; }
 8005e5a: 4618         	mov	r0, r3
 8005e5c: 46bd         	mov	sp, r7
 8005e5e: bc80         	pop	{r7}
 8005e60: 4770         	bx	lr
 8005e62: bf00         	nop

08005e64 <$d>:
 8005e64: 00 1b b7 00  	.word	0x00b71b00

08005e68 <console_out>:
; {
 8005e68: b580         	push	{r7, lr}
 8005e6a: b082         	sub	sp, #0x8
 8005e6c: af00         	add	r7, sp, #0x0
 8005e6e: 6078         	str	r0, [r7, #0x4]
; 	if (pm_device_runtime_get(uart_console_dev) < 0) {
 8005e70: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8005ebc <console_out+0x54>
 8005e72: 4618         	mov	r0, r3
 8005e74: f00d fe9c    	bl	0x8013bb0 <pm_device_runtime_get> @ imm = #0xdd38
 8005e78: 4603         	mov	r3, r0
 8005e7a: 2b00         	cmp	r3, #0x0
 8005e7c: da01         	bge	0x8005e82 <console_out+0x1a> @ imm = #0x2
; 		return c;
 8005e7e: 6879         	ldr	r1, [r7, #0x4]
 8005e80: e017         	b	0x8005eb2 <console_out+0x4a> @ imm = #0x2e
; 	if ('\n' == c) {
 8005e82: 687b         	ldr	r3, [r7, #0x4]
 8005e84: 2b0a         	cmp	r3, #0xa
 8005e86: d104         	bne	0x8005e92 <console_out+0x2a> @ imm = #0x8
; 		uart_poll_out(uart_console_dev, '\r');
 8005e88: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8005ebc <console_out+0x54>
 8005e8a: 210d         	movs	r1, #0xd
 8005e8c: 4618         	mov	r0, r3
 8005e8e: f00d fe80    	bl	0x8013b92 <uart_poll_out> @ imm = #0xdd00
; 	uart_poll_out(uart_console_dev, c);
 8005e92: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8005ebc <console_out+0x54>
 8005e94: 687b         	ldr	r3, [r7, #0x4]
 8005e96: b2db         	uxtb	r3, r3
 8005e98: 4619         	mov	r1, r3
 8005e9a: 4610         	mov	r0, r2
 8005e9c: f00d fe79    	bl	0x8013b92 <uart_poll_out> @ imm = #0xdcf2
; 	(void)pm_device_runtime_put_async(uart_console_dev, K_MSEC(1));
 8005ea0: 4906         	ldr	r1, [pc, #0x18]         @ 0x8005ebc <console_out+0x54>
 8005ea2: f04f 020a    	mov.w	r2, #0xa
 8005ea6: f04f 0300    	mov.w	r3, #0x0
 8005eaa: 4608         	mov	r0, r1
 8005eac: f00d fe8a    	bl	0x8013bc4 <pm_device_runtime_put_async> @ imm = #0xdd14
; 	return c;
 8005eb0: 6879         	ldr	r1, [r7, #0x4]
; }
 8005eb2: 460b         	mov	r3, r1
 8005eb4: 4618         	mov	r0, r3
 8005eb6: 3708         	adds	r7, #0x8
 8005eb8: 46bd         	mov	sp, r7
 8005eba: bd80         	pop	{r7, pc}

08005ebc <$d>:
 8005ebc: f0 ad 01 08  	.word	0x0801adf0

08005ec0 <uart_console_hook_install>:
; {
 8005ec0: b580         	push	{r7, lr}
 8005ec2: af00         	add	r7, sp, #0x0
; 	__stdout_hook_install(console_out);
 8005ec4: 4803         	ldr	r0, [pc, #0xc]          @ 0x8005ed4 <uart_console_hook_install+0x14>
 8005ec6: f7fd fc87    	bl	0x80037d8 <__stdout_hook_install> @ imm = #-0x26f2
; 	__printk_hook_install(console_out);
 8005eca: 4802         	ldr	r0, [pc, #0x8]          @ 0x8005ed4 <uart_console_hook_install+0x14>
 8005ecc: f7fb fc1a    	bl	0x8001704 <__printk_hook_install> @ imm = #-0x47cc
; }
 8005ed0: bf00         	nop
 8005ed2: bd80         	pop	{r7, pc}

08005ed4 <$d>:
 8005ed4: 69 5e 00 08  	.word	0x08005e69

08005ed8 <uart_console_init>:
; {
 8005ed8: b580         	push	{r7, lr}
 8005eda: af00         	add	r7, sp, #0x0
; 	if (!device_is_ready(uart_console_dev)) {
 8005edc: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8005f00 <uart_console_init+0x28>
 8005ede: 4618         	mov	r0, r3
 8005ee0: f00d fe38    	bl	0x8013b54 <device_is_ready> @ imm = #0xdc70
 8005ee4: 4603         	mov	r3, r0
 8005ee6: f083 0301    	eor	r3, r3, #0x1
 8005eea: b2db         	uxtb	r3, r3
 8005eec: 2b00         	cmp	r3, #0x0
 8005eee: d002         	beq	0x8005ef6 <uart_console_init+0x1e> @ imm = #0x4
; 		return -ENODEV;
 8005ef0: f06f 0312    	mvn	r3, #0x12
 8005ef4: e002         	b	0x8005efc <uart_console_init+0x24> @ imm = #0x4
; 	uart_console_hook_install();
 8005ef6: f7ff ffe3    	bl	0x8005ec0 <uart_console_hook_install> @ imm = #-0x3a
; 	return 0;
 8005efa: 2300         	movs	r3, #0x0
; }
 8005efc: 4618         	mov	r0, r3
 8005efe: bd80         	pop	{r7, pc}

08005f00 <$d>:
 8005f00: f0 ad 01 08  	.word	0x0801adf0

08005f04 <LL_DMA_SetDataLength>:
; {
 8005f04: b480         	push	{r7}
 8005f06: b085         	sub	sp, #0x14
 8005f08: af00         	add	r7, sp, #0x0
 8005f0a: 60f8         	str	r0, [r7, #0xc]
 8005f0c: 60b9         	str	r1, [r7, #0x8]
 8005f0e: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT, NbData);
 8005f10: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8005f44 <LL_DMA_SetDataLength+0x40>
 8005f12: 68bb         	ldr	r3, [r7, #0x8]
 8005f14: 4413         	add	r3, r2
 8005f16: 781b         	ldrb	r3, [r3]
 8005f18: 461a         	mov	r2, r3
 8005f1a: 68fb         	ldr	r3, [r7, #0xc]
 8005f1c: 4413         	add	r3, r2
 8005f1e: 685b         	ldr	r3, [r3, #0x4]
 8005f20: 0c1b         	lsrs	r3, r3, #0x10
 8005f22: 041b         	lsls	r3, r3, #0x10
 8005f24: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8005f44 <LL_DMA_SetDataLength+0x40>
 8005f26: 68ba         	ldr	r2, [r7, #0x8]
 8005f28: 440a         	add	r2, r1
 8005f2a: 7812         	ldrb	r2, [r2]
 8005f2c: 4611         	mov	r1, r2
 8005f2e: 68fa         	ldr	r2, [r7, #0xc]
 8005f30: 440a         	add	r2, r1
 8005f32: 4611         	mov	r1, r2
 8005f34: 687a         	ldr	r2, [r7, #0x4]
 8005f36: 4313         	orrs	r3, r2
 8005f38: 604b         	str	r3, [r1, #0x4]
; }
 8005f3a: bf00         	nop
 8005f3c: 3714         	adds	r7, #0x14
 8005f3e: 46bd         	mov	sp, r7
 8005f40: bc80         	pop	{r7}
 8005f42: 4770         	bx	lr

08005f44 <$d>:
 8005f44: c0 d1 01 08  	.word	0x0801d1c0

08005f48 <LL_DMA_GetDataLength>:
; {
 8005f48: b480         	push	{r7}
 8005f4a: b083         	sub	sp, #0xc
 8005f4c: af00         	add	r7, sp, #0x0
 8005f4e: 6078         	str	r0, [r7, #0x4]
 8005f50: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT));
 8005f52: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8005f70 <LL_DMA_GetDataLength+0x28>
 8005f54: 683b         	ldr	r3, [r7]
 8005f56: 4413         	add	r3, r2
 8005f58: 781b         	ldrb	r3, [r3]
 8005f5a: 461a         	mov	r2, r3
 8005f5c: 687b         	ldr	r3, [r7, #0x4]
 8005f5e: 4413         	add	r3, r2
 8005f60: 685b         	ldr	r3, [r3, #0x4]
 8005f62: b29b         	uxth	r3, r3
; }
 8005f64: 4618         	mov	r0, r3
 8005f66: 370c         	adds	r7, #0xc
 8005f68: 46bd         	mov	sp, r7
 8005f6a: bc80         	pop	{r7}
 8005f6c: 4770         	bx	lr
 8005f6e: bf00         	nop

08005f70 <$d>:
 8005f70: c0 d1 01 08  	.word	0x0801d1c0

08005f74 <LL_DMA_DisableFifoMode>:
; {
 8005f74: b480         	push	{r7}
 8005f76: b083         	sub	sp, #0xc
 8005f78: af00         	add	r7, sp, #0x0
 8005f7a: 6078         	str	r0, [r7, #0x4]
 8005f7c: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_DMDIS);
 8005f7e: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8005fac <LL_DMA_DisableFifoMode+0x38>
 8005f80: 683b         	ldr	r3, [r7]
 8005f82: 4413         	add	r3, r2
 8005f84: 781b         	ldrb	r3, [r3]
 8005f86: 461a         	mov	r2, r3
 8005f88: 687b         	ldr	r3, [r7, #0x4]
 8005f8a: 4413         	add	r3, r2
 8005f8c: 695b         	ldr	r3, [r3, #0x14]
 8005f8e: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8005fac <LL_DMA_DisableFifoMode+0x38>
 8005f90: 683a         	ldr	r2, [r7]
 8005f92: 440a         	add	r2, r1
 8005f94: 7812         	ldrb	r2, [r2]
 8005f96: 4611         	mov	r1, r2
 8005f98: 687a         	ldr	r2, [r7, #0x4]
 8005f9a: 440a         	add	r2, r1
 8005f9c: f023 0304    	bic	r3, r3, #0x4
 8005fa0: 6153         	str	r3, [r2, #0x14]
; }
 8005fa2: bf00         	nop
 8005fa4: 370c         	adds	r7, #0xc
 8005fa6: 46bd         	mov	sp, r7
 8005fa8: bc80         	pop	{r7}
 8005faa: 4770         	bx	lr

08005fac <$d>:
 8005fac: c0 d1 01 08  	.word	0x0801d1c0

08005fb0 <LL_DMA_EnableFifoMode>:
; {
 8005fb0: b480         	push	{r7}
 8005fb2: b083         	sub	sp, #0xc
 8005fb4: af00         	add	r7, sp, #0x0
 8005fb6: 6078         	str	r0, [r7, #0x4]
 8005fb8: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_DMDIS);
 8005fba: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8005fe8 <LL_DMA_EnableFifoMode+0x38>
 8005fbc: 683b         	ldr	r3, [r7]
 8005fbe: 4413         	add	r3, r2
 8005fc0: 781b         	ldrb	r3, [r3]
 8005fc2: 461a         	mov	r2, r3
 8005fc4: 687b         	ldr	r3, [r7, #0x4]
 8005fc6: 4413         	add	r3, r2
 8005fc8: 695b         	ldr	r3, [r3, #0x14]
 8005fca: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8005fe8 <LL_DMA_EnableFifoMode+0x38>
 8005fcc: 683a         	ldr	r2, [r7]
 8005fce: 440a         	add	r2, r1
 8005fd0: 7812         	ldrb	r2, [r2]
 8005fd2: 4611         	mov	r1, r2
 8005fd4: 687a         	ldr	r2, [r7, #0x4]
 8005fd6: 440a         	add	r2, r1
 8005fd8: f043 0304    	orr	r3, r3, #0x4
 8005fdc: 6153         	str	r3, [r2, #0x14]
; }
 8005fde: bf00         	nop
 8005fe0: 370c         	adds	r7, #0xc
 8005fe2: 46bd         	mov	sp, r7
 8005fe4: bc80         	pop	{r7}
 8005fe6: 4770         	bx	lr

08005fe8 <$d>:
 8005fe8: c0 d1 01 08  	.word	0x0801d1c0

08005fec <LL_DMA_SetMemoryAddress>:
; {
 8005fec: b480         	push	{r7}
 8005fee: b085         	sub	sp, #0x14
 8005ff0: af00         	add	r7, sp, #0x0
 8005ff2: 60f8         	str	r0, [r7, #0xc]
 8005ff4: 60b9         	str	r1, [r7, #0x8]
 8005ff6: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->M0AR, MemoryAddress);
 8005ff8: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8006018 <LL_DMA_SetMemoryAddress+0x2c>
 8005ffa: 68bb         	ldr	r3, [r7, #0x8]
 8005ffc: 4413         	add	r3, r2
 8005ffe: 781b         	ldrb	r3, [r3]
 8006000: 461a         	mov	r2, r3
 8006002: 68fb         	ldr	r3, [r7, #0xc]
 8006004: 4413         	add	r3, r2
 8006006: 461a         	mov	r2, r3
 8006008: 687b         	ldr	r3, [r7, #0x4]
 800600a: 60d3         	str	r3, [r2, #0xc]
; }
 800600c: bf00         	nop
 800600e: 3714         	adds	r7, #0x14
 8006010: 46bd         	mov	sp, r7
 8006012: bc80         	pop	{r7}
 8006014: 4770         	bx	lr
 8006016: bf00         	nop

08006018 <$d>:
 8006018: c0 d1 01 08  	.word	0x0801d1c0

0800601c <LL_DMA_SetPeriphAddress>:
; {
 800601c: b480         	push	{r7}
 800601e: b085         	sub	sp, #0x14
 8006020: af00         	add	r7, sp, #0x0
 8006022: 60f8         	str	r0, [r7, #0xc]
 8006024: 60b9         	str	r1, [r7, #0x8]
 8006026: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->PAR, PeriphAddress);
 8006028: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8006048 <LL_DMA_SetPeriphAddress+0x2c>
 800602a: 68bb         	ldr	r3, [r7, #0x8]
 800602c: 4413         	add	r3, r2
 800602e: 781b         	ldrb	r3, [r3]
 8006030: 461a         	mov	r2, r3
 8006032: 68fb         	ldr	r3, [r7, #0xc]
 8006034: 4413         	add	r3, r2
 8006036: 461a         	mov	r2, r3
 8006038: 687b         	ldr	r3, [r7, #0x4]
 800603a: 6093         	str	r3, [r2, #0x8]
; }
 800603c: bf00         	nop
 800603e: 3714         	adds	r7, #0x14
 8006040: 46bd         	mov	sp, r7
 8006042: bc80         	pop	{r7}
 8006044: 4770         	bx	lr
 8006046: bf00         	nop

08006048 <$d>:
 8006048: c0 d1 01 08  	.word	0x0801d1c0

0800604c <LL_DMA_EnableIT_HT>:
; {
 800604c: b480         	push	{r7}
 800604e: b083         	sub	sp, #0xc
 8006050: af00         	add	r7, sp, #0x0
 8006052: 6078         	str	r0, [r7, #0x4]
 8006054: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_HTIE);
 8006056: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006084 <LL_DMA_EnableIT_HT+0x38>
 8006058: 683b         	ldr	r3, [r7]
 800605a: 4413         	add	r3, r2
 800605c: 781b         	ldrb	r3, [r3]
 800605e: 461a         	mov	r2, r3
 8006060: 687b         	ldr	r3, [r7, #0x4]
 8006062: 4413         	add	r3, r2
 8006064: 681b         	ldr	r3, [r3]
 8006066: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006084 <LL_DMA_EnableIT_HT+0x38>
 8006068: 683a         	ldr	r2, [r7]
 800606a: 440a         	add	r2, r1
 800606c: 7812         	ldrb	r2, [r2]
 800606e: 4611         	mov	r1, r2
 8006070: 687a         	ldr	r2, [r7, #0x4]
 8006072: 440a         	add	r2, r1
 8006074: f043 0308    	orr	r3, r3, #0x8
 8006078: 6013         	str	r3, [r2]
; }
 800607a: bf00         	nop
 800607c: 370c         	adds	r7, #0xc
 800607e: 46bd         	mov	sp, r7
 8006080: bc80         	pop	{r7}
 8006082: 4770         	bx	lr

08006084 <$d>:
 8006084: c0 d1 01 08  	.word	0x0801d1c0

08006088 <LL_DMA_EnableIT_TC>:
; {
 8006088: b480         	push	{r7}
 800608a: b083         	sub	sp, #0xc
 800608c: af00         	add	r7, sp, #0x0
 800608e: 6078         	str	r0, [r7, #0x4]
 8006090: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE);
 8006092: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80060c0 <LL_DMA_EnableIT_TC+0x38>
 8006094: 683b         	ldr	r3, [r7]
 8006096: 4413         	add	r3, r2
 8006098: 781b         	ldrb	r3, [r3]
 800609a: 461a         	mov	r2, r3
 800609c: 687b         	ldr	r3, [r7, #0x4]
 800609e: 4413         	add	r3, r2
 80060a0: 681b         	ldr	r3, [r3]
 80060a2: 4907         	ldr	r1, [pc, #0x1c]         @ 0x80060c0 <LL_DMA_EnableIT_TC+0x38>
 80060a4: 683a         	ldr	r2, [r7]
 80060a6: 440a         	add	r2, r1
 80060a8: 7812         	ldrb	r2, [r2]
 80060aa: 4611         	mov	r1, r2
 80060ac: 687a         	ldr	r2, [r7, #0x4]
 80060ae: 440a         	add	r2, r1
 80060b0: f043 0310    	orr	r3, r3, #0x10
 80060b4: 6013         	str	r3, [r2]
; }
 80060b6: bf00         	nop
 80060b8: 370c         	adds	r7, #0xc
 80060ba: 46bd         	mov	sp, r7
 80060bc: bc80         	pop	{r7}
 80060be: 4770         	bx	lr

080060c0 <$d>:
 80060c0: c0 d1 01 08  	.word	0x0801d1c0

080060c4 <LL_DMA_EnableIT_FE>:
; {
 80060c4: b480         	push	{r7}
 80060c6: b083         	sub	sp, #0xc
 80060c8: af00         	add	r7, sp, #0x0
 80060ca: 6078         	str	r0, [r7, #0x4]
 80060cc: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 80060ce: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80060fc <LL_DMA_EnableIT_FE+0x38>
 80060d0: 683b         	ldr	r3, [r7]
 80060d2: 4413         	add	r3, r2
 80060d4: 781b         	ldrb	r3, [r3]
 80060d6: 461a         	mov	r2, r3
 80060d8: 687b         	ldr	r3, [r7, #0x4]
 80060da: 4413         	add	r3, r2
 80060dc: 695b         	ldr	r3, [r3, #0x14]
 80060de: 4907         	ldr	r1, [pc, #0x1c]         @ 0x80060fc <LL_DMA_EnableIT_FE+0x38>
 80060e0: 683a         	ldr	r2, [r7]
 80060e2: 440a         	add	r2, r1
 80060e4: 7812         	ldrb	r2, [r2]
 80060e6: 4611         	mov	r1, r2
 80060e8: 687a         	ldr	r2, [r7, #0x4]
 80060ea: 440a         	add	r2, r1
 80060ec: f043 0380    	orr	r3, r3, #0x80
 80060f0: 6153         	str	r3, [r2, #0x14]
; }
 80060f2: bf00         	nop
 80060f4: 370c         	adds	r7, #0xc
 80060f6: 46bd         	mov	sp, r7
 80060f8: bc80         	pop	{r7}
 80060fa: 4770         	bx	lr

080060fc <$d>:
 80060fc: c0 d1 01 08  	.word	0x0801d1c0

08006100 <LL_DMA_DisableIT_TC>:
; {
 8006100: b480         	push	{r7}
 8006102: b083         	sub	sp, #0xc
 8006104: af00         	add	r7, sp, #0x0
 8006106: 6078         	str	r0, [r7, #0x4]
 8006108: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE);
 800610a: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006138 <LL_DMA_DisableIT_TC+0x38>
 800610c: 683b         	ldr	r3, [r7]
 800610e: 4413         	add	r3, r2
 8006110: 781b         	ldrb	r3, [r3]
 8006112: 461a         	mov	r2, r3
 8006114: 687b         	ldr	r3, [r7, #0x4]
 8006116: 4413         	add	r3, r2
 8006118: 681b         	ldr	r3, [r3]
 800611a: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006138 <LL_DMA_DisableIT_TC+0x38>
 800611c: 683a         	ldr	r2, [r7]
 800611e: 440a         	add	r2, r1
 8006120: 7812         	ldrb	r2, [r2]
 8006122: 4611         	mov	r1, r2
 8006124: 687a         	ldr	r2, [r7, #0x4]
 8006126: 440a         	add	r2, r1
 8006128: f023 0310    	bic	r3, r3, #0x10
 800612c: 6013         	str	r3, [r2]
; }
 800612e: bf00         	nop
 8006130: 370c         	adds	r7, #0xc
 8006132: 46bd         	mov	sp, r7
 8006134: bc80         	pop	{r7}
 8006136: 4770         	bx	lr

08006138 <$d>:
 8006138: c0 d1 01 08  	.word	0x0801d1c0

0800613c <LL_DMA_DisableIT_FE>:
; {
 800613c: b480         	push	{r7}
 800613e: b083         	sub	sp, #0xc
 8006140: af00         	add	r7, sp, #0x0
 8006142: 6078         	str	r0, [r7, #0x4]
 8006144: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 8006146: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006174 <LL_DMA_DisableIT_FE+0x38>
 8006148: 683b         	ldr	r3, [r7]
 800614a: 4413         	add	r3, r2
 800614c: 781b         	ldrb	r3, [r3]
 800614e: 461a         	mov	r2, r3
 8006150: 687b         	ldr	r3, [r7, #0x4]
 8006152: 4413         	add	r3, r2
 8006154: 695b         	ldr	r3, [r3, #0x14]
 8006156: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006174 <LL_DMA_DisableIT_FE+0x38>
 8006158: 683a         	ldr	r2, [r7]
 800615a: 440a         	add	r2, r1
 800615c: 7812         	ldrb	r2, [r2]
 800615e: 4611         	mov	r1, r2
 8006160: 687a         	ldr	r2, [r7, #0x4]
 8006162: 440a         	add	r2, r1
 8006164: f023 0380    	bic	r3, r3, #0x80
 8006168: 6153         	str	r3, [r2, #0x14]
; }
 800616a: bf00         	nop
 800616c: 370c         	adds	r7, #0xc
 800616e: 46bd         	mov	sp, r7
 8006170: bc80         	pop	{r7}
 8006172: 4770         	bx	lr

08006174 <$d>:
 8006174: c0 d1 01 08  	.word	0x0801d1c0

08006178 <dma_stm32_irq_handler>:
; {
 8006178: b590         	push	{r4, r7, lr}
 800617a: b08f         	sub	sp, #0x3c
 800617c: af04         	add	r7, sp, #0x10
 800617e: 6078         	str	r0, [r7, #0x4]
 8006180: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8006182: 687b         	ldr	r3, [r7, #0x4]
 8006184: 685b         	ldr	r3, [r3, #0x4]
 8006186: 627b         	str	r3, [r7, #0x24]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8006188: 6a7b         	ldr	r3, [r7, #0x24]
 800618a: 691b         	ldr	r3, [r3, #0x10]
 800618c: 623b         	str	r3, [r7, #0x20]
; 	stream = &config->streams[id];
 800618e: 6a7b         	ldr	r3, [r7, #0x24]
 8006190: 6999         	ldr	r1, [r3, #0x18]
 8006192: 683a         	ldr	r2, [r7]
 8006194: 4613         	mov	r3, r2
 8006196: 00db         	lsls	r3, r3, #0x3
 8006198: 1a9b         	subs	r3, r3, r2
 800619a: 009b         	lsls	r3, r3, #0x2
 800619c: 440b         	add	r3, r1
 800619e: 61fb         	str	r3, [r7, #0x1c]
; 	if ((stream->hal_override != true) && (stream->busy == false)) {
 80061a0: 69fb         	ldr	r3, [r7, #0x1c]
 80061a2: 795b         	ldrb	r3, [r3, #0x5]
 80061a4: f083 0301    	eor	r3, r3, #0x1
 80061a8: b2db         	uxtb	r3, r3
 80061aa: 2b00         	cmp	r3, #0x0
 80061ac: d00c         	beq	0x80061c8 <dma_stm32_irq_handler+0x50> @ imm = #0x18
 80061ae: 69fb         	ldr	r3, [r7, #0x1c]
 80061b0: 799b         	ldrb	r3, [r3, #0x6]
 80061b2: b2db         	uxtb	r3, r3
 80061b4: f083 0301    	eor	r3, r3, #0x1
 80061b8: b2db         	uxtb	r3, r3
 80061ba: 2b00         	cmp	r3, #0x0
 80061bc: d004         	beq	0x80061c8 <dma_stm32_irq_handler+0x50> @ imm = #0x8
; 		dma_stm32_clear_stream_irq(dev, id);
 80061be: 6839         	ldr	r1, [r7]
 80061c0: 6878         	ldr	r0, [r7, #0x4]
 80061c2: f00d fd68    	bl	0x8013c96 <dma_stm32_clear_stream_irq> @ imm = #0xdad0
; 		return;
 80061c6: e09a         	b	0x80062fe <dma_stm32_irq_handler+0x186> @ imm = #0x134
; 	callback_arg = id + STM32_DMA_STREAM_OFFSET;
 80061c8: 683b         	ldr	r3, [r7]
 80061ca: 61bb         	str	r3, [r7, #0x18]
; 	if (stm32_dma_is_ht_irq_active(dma, id)) {
 80061cc: 6839         	ldr	r1, [r7]
 80061ce: 6a38         	ldr	r0, [r7, #0x20]
 80061d0: f00e fd4a    	bl	0x8014c68 <stm32_dma_is_ht_irq_active> @ imm = #0xea94
 80061d4: 4603         	mov	r3, r0
 80061d6: 2b00         	cmp	r3, #0x0
 80061d8: d013         	beq	0x8006202 <dma_stm32_irq_handler+0x8a> @ imm = #0x26
; 		if (!stream->hal_override) {
 80061da: 69fb         	ldr	r3, [r7, #0x1c]
 80061dc: 795b         	ldrb	r3, [r3, #0x5]
 80061de: f083 0301    	eor	r3, r3, #0x1
 80061e2: b2db         	uxtb	r3, r3
 80061e4: 2b00         	cmp	r3, #0x0
 80061e6: d003         	beq	0x80061f0 <dma_stm32_irq_handler+0x78> @ imm = #0x6
; 			dma_stm32_clear_ht(dma, id);
 80061e8: 6839         	ldr	r1, [r7]
 80061ea: 6a38         	ldr	r0, [r7, #0x20]
 80061ec: f000 ff86    	bl	0x80070fc <dma_stm32_clear_ht> @ imm = #0xf0c
; 		stream->dma_callback(dev, stream->user_data, callback_arg, DMA_STATUS_BLOCK);
 80061f0: 69fb         	ldr	r3, [r7, #0x1c]
 80061f2: 695c         	ldr	r4, [r3, #0x14]
 80061f4: 69fb         	ldr	r3, [r7, #0x1c]
 80061f6: 6919         	ldr	r1, [r3, #0x10]
 80061f8: 2301         	movs	r3, #0x1
 80061fa: 69ba         	ldr	r2, [r7, #0x18]
 80061fc: 6878         	ldr	r0, [r7, #0x4]
 80061fe: 47a0         	blx	r4
 8006200: e07d         	b	0x80062fe <dma_stm32_irq_handler+0x186> @ imm = #0xfa
; 	} else if (stm32_dma_is_tc_irq_active(dma, id)) {
 8006202: 6839         	ldr	r1, [r7]
 8006204: 6a38         	ldr	r0, [r7, #0x20]
 8006206: f00e fd0e    	bl	0x8014c26 <stm32_dma_is_tc_irq_active> @ imm = #0xea1c
 800620a: 4603         	mov	r3, r0
 800620c: 2b00         	cmp	r3, #0x0
 800620e: d01d         	beq	0x800624c <dma_stm32_irq_handler+0xd4> @ imm = #0x3a
; 		if (!stream->cyclic) {
 8006210: 69fb         	ldr	r3, [r7, #0x1c]
 8006212: 7e1b         	ldrb	r3, [r3, #0x18]
 8006214: f083 0301    	eor	r3, r3, #0x1
 8006218: b2db         	uxtb	r3, r3
 800621a: 2b00         	cmp	r3, #0x0
 800621c: d002         	beq	0x8006224 <dma_stm32_irq_handler+0xac> @ imm = #0x4
; 			stream->busy = false;
 800621e: 69fb         	ldr	r3, [r7, #0x1c]
 8006220: 2200         	movs	r2, #0x0
 8006222: 719a         	strb	r2, [r3, #0x6]
; 		if (!stream->hal_override) {
 8006224: 69fb         	ldr	r3, [r7, #0x1c]
 8006226: 795b         	ldrb	r3, [r3, #0x5]
 8006228: f083 0301    	eor	r3, r3, #0x1
 800622c: b2db         	uxtb	r3, r3
 800622e: 2b00         	cmp	r3, #0x0
 8006230: d003         	beq	0x800623a <dma_stm32_irq_handler+0xc2> @ imm = #0x6
; 			dma_stm32_clear_tc(dma, id);
 8006232: 6839         	ldr	r1, [r7]
 8006234: 6a38         	ldr	r0, [r7, #0x20]
 8006236: f000 ff73    	bl	0x8007120 <dma_stm32_clear_tc> @ imm = #0xee6
; 		stream->dma_callback(dev, stream->user_data, callback_arg, DMA_STATUS_COMPLETE);
 800623a: 69fb         	ldr	r3, [r7, #0x1c]
 800623c: 695c         	ldr	r4, [r3, #0x14]
 800623e: 69fb         	ldr	r3, [r7, #0x1c]
 8006240: 6919         	ldr	r1, [r3, #0x10]
 8006242: 2300         	movs	r3, #0x0
 8006244: 69ba         	ldr	r2, [r7, #0x18]
 8006246: 6878         	ldr	r0, [r7, #0x4]
 8006248: 47a0         	blx	r4
 800624a: e058         	b	0x80062fe <dma_stm32_irq_handler+0x186> @ imm = #0xb0
; 	} else if (stm32_dma_is_unexpected_irq_happened(dma, id)) {
 800624c: 6839         	ldr	r1, [r7]
 800624e: 6a38         	ldr	r0, [r7, #0x20]
 8006250: f001 f874    	bl	0x800733c <stm32_dma_is_unexpected_irq_happened> @ imm = #0x10e8
 8006254: 4603         	mov	r3, r0
 8006256: 2b00         	cmp	r3, #0x0
 8006258: d023         	beq	0x80062a2 <dma_stm32_irq_handler+0x12a> @ imm = #0x46
; 		LOG_ERR("Unexpected irq happened.");
 800625a: 2303         	movs	r3, #0x3
 800625c: 2b00         	cmp	r3, #0x0
 800625e: d016         	beq	0x800628e <dma_stm32_irq_handler+0x116> @ imm = #0x2c
 8006260: 2301         	movs	r3, #0x1
 8006262: 73fb         	strb	r3, [r7, #0xf]
 8006264: 7bfb         	ldrb	r3, [r7, #0xf]
 8006266: f083 0301    	eor	r3, r3, #0x1
 800626a: b2db         	uxtb	r3, r3
 800626c: 2b00         	cmp	r3, #0x0
 800626e: d10e         	bne	0x800628e <dma_stm32_irq_handler+0x116> @ imm = #0x1c
 8006270: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8006304 <dma_stm32_irq_handler+0x18c>
 8006272: 6819         	ldr	r1, [r3]
 8006274: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8006308 <dma_stm32_irq_handler+0x190>
 8006276: 9302         	str	r3, [sp, #0x8]
 8006278: 2300         	movs	r3, #0x0
 800627a: 9301         	str	r3, [sp, #0x4]
 800627c: 2300         	movs	r3, #0x0
 800627e: 9300         	str	r3, [sp]
 8006280: 2300         	movs	r3, #0x0
 8006282: 2201         	movs	r2, #0x1
 8006284: 2000         	movs	r0, #0x0
 8006286: f00d fcd5    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd9aa
 800628a: 2300         	movs	r3, #0x0
 800628c: 60bb         	str	r3, [r7, #0x8]
; 		stream->dma_callback(dev, stream->user_data,
 800628e: 69fb         	ldr	r3, [r7, #0x1c]
 8006290: 695c         	ldr	r4, [r3, #0x14]
 8006292: 69fb         	ldr	r3, [r7, #0x1c]
 8006294: 6919         	ldr	r1, [r3, #0x10]
 8006296: f06f 0304    	mvn	r3, #0x4
 800629a: 69ba         	ldr	r2, [r7, #0x18]
 800629c: 6878         	ldr	r0, [r7, #0x4]
 800629e: 47a0         	blx	r4
 80062a0: e02d         	b	0x80062fe <dma_stm32_irq_handler+0x186> @ imm = #0x5a
; 		LOG_ERR("Transfer Error.");
 80062a2: 2303         	movs	r3, #0x3
 80062a4: 2b00         	cmp	r3, #0x0
 80062a6: d016         	beq	0x80062d6 <dma_stm32_irq_handler+0x15e> @ imm = #0x2c
 80062a8: 2301         	movs	r3, #0x1
 80062aa: 75fb         	strb	r3, [r7, #0x17]
 80062ac: 7dfb         	ldrb	r3, [r7, #0x17]
 80062ae: f083 0301    	eor	r3, r3, #0x1
 80062b2: b2db         	uxtb	r3, r3
 80062b4: 2b00         	cmp	r3, #0x0
 80062b6: d10e         	bne	0x80062d6 <dma_stm32_irq_handler+0x15e> @ imm = #0x1c
 80062b8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8006304 <dma_stm32_irq_handler+0x18c>
 80062ba: 6819         	ldr	r1, [r3]
 80062bc: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800630c <dma_stm32_irq_handler+0x194>
 80062be: 9302         	str	r3, [sp, #0x8]
 80062c0: 2300         	movs	r3, #0x0
 80062c2: 9301         	str	r3, [sp, #0x4]
 80062c4: 2300         	movs	r3, #0x0
 80062c6: 9300         	str	r3, [sp]
 80062c8: 2300         	movs	r3, #0x0
 80062ca: 2201         	movs	r2, #0x1
 80062cc: 2000         	movs	r0, #0x0
 80062ce: f00d fcb1    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd962
 80062d2: 2300         	movs	r3, #0x0
 80062d4: 613b         	str	r3, [r7, #0x10]
; 		stream->busy = false;
 80062d6: 69fb         	ldr	r3, [r7, #0x1c]
 80062d8: 2200         	movs	r2, #0x0
 80062da: 719a         	strb	r2, [r3, #0x6]
; 		dma_stm32_dump_stream_irq(dev, id);
 80062dc: 6839         	ldr	r1, [r7]
 80062de: 6878         	ldr	r0, [r7, #0x4]
 80062e0: f00d fcc6    	bl	0x8013c70 <dma_stm32_dump_stream_irq> @ imm = #0xd98c
; 		dma_stm32_clear_stream_irq(dev, id);
 80062e4: 6839         	ldr	r1, [r7]
 80062e6: 6878         	ldr	r0, [r7, #0x4]
 80062e8: f00d fcd5    	bl	0x8013c96 <dma_stm32_clear_stream_irq> @ imm = #0xd9aa
; 		stream->dma_callback(dev, stream->user_data,
 80062ec: 69fb         	ldr	r3, [r7, #0x1c]
 80062ee: 695c         	ldr	r4, [r3, #0x14]
 80062f0: 69fb         	ldr	r3, [r7, #0x1c]
 80062f2: 6919         	ldr	r1, [r3, #0x10]
 80062f4: f06f 0304    	mvn	r3, #0x4
 80062f8: 69ba         	ldr	r2, [r7, #0x18]
 80062fa: 6878         	ldr	r0, [r7, #0x4]
 80062fc: 47a0         	blx	r4
; }
 80062fe: 372c         	adds	r7, #0x2c
 8006300: 46bd         	mov	sp, r7
 8006302: bd90         	pop	{r4, r7, pc}

08006304 <$d>:
 8006304: 58 04 00 20  	.word	0x20000458
 8006308: 50 bf 01 08  	.word	0x0801bf50
 800630c: 6c bf 01 08  	.word	0x0801bf6c

08006310 <dma_stm32_get_priority>:
; {
 8006310: b580         	push	{r7, lr}
 8006312: b088         	sub	sp, #0x20
 8006314: af04         	add	r7, sp, #0x10
 8006316: 4603         	mov	r3, r0
 8006318: 6039         	str	r1, [r7]
 800631a: 71fb         	strb	r3, [r7, #0x7]
; 	switch (priority) {
 800631c: 79fb         	ldrb	r3, [r7, #0x7]
 800631e: 2b03         	cmp	r3, #0x3
 8006320: d81d         	bhi	0x800635e <dma_stm32_get_priority+0x4e> @ imm = #0x3a
 8006322: a201         	adr	r2, #4 <dma_stm32_get_priority+0x17>
 8006324: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08006328 <$d>:
 8006328: 39 63 00 08  	.word	0x08006339
 800632c: 41 63 00 08  	.word	0x08006341
 8006330: 4b 63 00 08  	.word	0x0800634b
 8006334: 55 63 00 08  	.word	0x08006355

08006338 <$t>:
; 		*ll_priority = LL_DMA_PRIORITY_LOW;
 8006338: 683b         	ldr	r3, [r7]
 800633a: 2200         	movs	r2, #0x0
 800633c: 601a         	str	r2, [r3]
; 		break;
 800633e: e02d         	b	0x800639c <dma_stm32_get_priority+0x8c> @ imm = #0x5a
; 		*ll_priority = LL_DMA_PRIORITY_MEDIUM;
 8006340: 683b         	ldr	r3, [r7]
 8006342: f44f 3280    	mov.w	r2, #0x10000
 8006346: 601a         	str	r2, [r3]
; 		break;
 8006348: e028         	b	0x800639c <dma_stm32_get_priority+0x8c> @ imm = #0x50
; 		*ll_priority = LL_DMA_PRIORITY_HIGH;
 800634a: 683b         	ldr	r3, [r7]
 800634c: f44f 3200    	mov.w	r2, #0x20000
 8006350: 601a         	str	r2, [r3]
; 		break;
 8006352: e023         	b	0x800639c <dma_stm32_get_priority+0x8c> @ imm = #0x46
; 		*ll_priority = LL_DMA_PRIORITY_VERYHIGH;
 8006354: 683b         	ldr	r3, [r7]
 8006356: f44f 3240    	mov.w	r2, #0x30000
 800635a: 601a         	str	r2, [r3]
; 		break;
 800635c: e01e         	b	0x800639c <dma_stm32_get_priority+0x8c> @ imm = #0x3c
; 		LOG_ERR("Priority error. %d", priority);
 800635e: 2303         	movs	r3, #0x3
 8006360: 2b00         	cmp	r3, #0x0
 8006362: d018         	beq	0x8006396 <dma_stm32_get_priority+0x86> @ imm = #0x30
 8006364: 2301         	movs	r3, #0x1
 8006366: 73fb         	strb	r3, [r7, #0xf]
 8006368: 7bfb         	ldrb	r3, [r7, #0xf]
 800636a: f083 0301    	eor	r3, r3, #0x1
 800636e: b2db         	uxtb	r3, r3
 8006370: 2b00         	cmp	r3, #0x0
 8006372: d110         	bne	0x8006396 <dma_stm32_get_priority+0x86> @ imm = #0x20
 8006374: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80063a8 <dma_stm32_get_priority+0x98>
 8006376: 6819         	ldr	r1, [r3]
 8006378: 79fb         	ldrb	r3, [r7, #0x7]
 800637a: 9303         	str	r3, [sp, #0xc]
 800637c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80063ac <dma_stm32_get_priority+0x9c>
 800637e: 9302         	str	r3, [sp, #0x8]
 8006380: 2300         	movs	r3, #0x0
 8006382: 9301         	str	r3, [sp, #0x4]
 8006384: 2300         	movs	r3, #0x0
 8006386: 9300         	str	r3, [sp]
 8006388: 2300         	movs	r3, #0x0
 800638a: 2201         	movs	r2, #0x1
 800638c: 2000         	movs	r0, #0x0
 800638e: f00d fc51    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd8a2
 8006392: 2300         	movs	r3, #0x0
 8006394: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 8006396: f06f 0315    	mvn	r3, #0x15
 800639a: e000         	b	0x800639e <dma_stm32_get_priority+0x8e> @ imm = #0x0
; 	return 0;
 800639c: 2300         	movs	r3, #0x0
; }
 800639e: 4618         	mov	r0, r3
 80063a0: 3710         	adds	r7, #0x10
 80063a2: 46bd         	mov	sp, r7
 80063a4: bd80         	pop	{r7, pc}
 80063a6: bf00         	nop

080063a8 <$d>:
 80063a8: 58 04 00 20  	.word	0x20000458
 80063ac: 7c bf 01 08  	.word	0x0801bf7c

080063b0 <dma_stm32_get_direction>:
; {
 80063b0: b580         	push	{r7, lr}
 80063b2: b088         	sub	sp, #0x20
 80063b4: af04         	add	r7, sp, #0x10
 80063b6: 4603         	mov	r3, r0
 80063b8: 6039         	str	r1, [r7]
 80063ba: 71fb         	strb	r3, [r7, #0x7]
; 	switch (direction) {
 80063bc: 79fb         	ldrb	r3, [r7, #0x7]
 80063be: 2b02         	cmp	r3, #0x2
 80063c0: d00e         	beq	0x80063e0 <dma_stm32_get_direction+0x30> @ imm = #0x1c
 80063c2: 2b02         	cmp	r3, #0x2
 80063c4: dc10         	bgt	0x80063e8 <dma_stm32_get_direction+0x38> @ imm = #0x20
 80063c6: 2b00         	cmp	r3, #0x0
 80063c8: d002         	beq	0x80063d0 <dma_stm32_get_direction+0x20> @ imm = #0x4
 80063ca: 2b01         	cmp	r3, #0x1
 80063cc: d004         	beq	0x80063d8 <dma_stm32_get_direction+0x28> @ imm = #0x8
 80063ce: e00b         	b	0x80063e8 <dma_stm32_get_direction+0x38> @ imm = #0x16
; 		*ll_direction = LL_DMA_DIRECTION_MEMORY_TO_MEMORY;
 80063d0: 683b         	ldr	r3, [r7]
 80063d2: 2280         	movs	r2, #0x80
 80063d4: 601a         	str	r2, [r3]
; 		break;
 80063d6: e026         	b	0x8006426 <dma_stm32_get_direction+0x76> @ imm = #0x4c
; 		*ll_direction = LL_DMA_DIRECTION_MEMORY_TO_PERIPH;
 80063d8: 683b         	ldr	r3, [r7]
 80063da: 2240         	movs	r2, #0x40
 80063dc: 601a         	str	r2, [r3]
; 		break;
 80063de: e022         	b	0x8006426 <dma_stm32_get_direction+0x76> @ imm = #0x44
; 		*ll_direction = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
 80063e0: 683b         	ldr	r3, [r7]
 80063e2: 2200         	movs	r2, #0x0
 80063e4: 601a         	str	r2, [r3]
; 		break;
 80063e6: e01e         	b	0x8006426 <dma_stm32_get_direction+0x76> @ imm = #0x3c
; 		LOG_ERR("Direction error. %d", direction);
 80063e8: 2303         	movs	r3, #0x3
 80063ea: 2b00         	cmp	r3, #0x0
 80063ec: d018         	beq	0x8006420 <dma_stm32_get_direction+0x70> @ imm = #0x30
 80063ee: 2301         	movs	r3, #0x1
 80063f0: 73fb         	strb	r3, [r7, #0xf]
 80063f2: 7bfb         	ldrb	r3, [r7, #0xf]
 80063f4: f083 0301    	eor	r3, r3, #0x1
 80063f8: b2db         	uxtb	r3, r3
 80063fa: 2b00         	cmp	r3, #0x0
 80063fc: d110         	bne	0x8006420 <dma_stm32_get_direction+0x70> @ imm = #0x20
 80063fe: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8006430 <dma_stm32_get_direction+0x80>
 8006400: 6819         	ldr	r1, [r3]
 8006402: 79fb         	ldrb	r3, [r7, #0x7]
 8006404: 9303         	str	r3, [sp, #0xc]
 8006406: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8006434 <dma_stm32_get_direction+0x84>
 8006408: 9302         	str	r3, [sp, #0x8]
 800640a: 2300         	movs	r3, #0x0
 800640c: 9301         	str	r3, [sp, #0x4]
 800640e: 2300         	movs	r3, #0x0
 8006410: 9300         	str	r3, [sp]
 8006412: 2300         	movs	r3, #0x0
 8006414: 2201         	movs	r2, #0x1
 8006416: 2000         	movs	r0, #0x0
 8006418: f00d fc0c    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd818
 800641c: 2300         	movs	r3, #0x0
 800641e: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 8006420: f06f 0315    	mvn	r3, #0x15
 8006424: e000         	b	0x8006428 <dma_stm32_get_direction+0x78> @ imm = #0x0
; 	return 0;
 8006426: 2300         	movs	r3, #0x0
; }
 8006428: 4618         	mov	r0, r3
 800642a: 3710         	adds	r7, #0x10
 800642c: 46bd         	mov	sp, r7
 800642e: bd80         	pop	{r7, pc}

08006430 <$d>:
 8006430: 58 04 00 20  	.word	0x20000458
 8006434: 90 bf 01 08  	.word	0x0801bf90

08006438 <dma_stm32_get_memory_increment>:
; {
 8006438: b580         	push	{r7, lr}
 800643a: b088         	sub	sp, #0x20
 800643c: af04         	add	r7, sp, #0x10
 800643e: 4603         	mov	r3, r0
 8006440: 6039         	str	r1, [r7]
 8006442: 71fb         	strb	r3, [r7, #0x7]
; 	switch (increment) {
 8006444: 79fb         	ldrb	r3, [r7, #0x7]
 8006446: 2b02         	cmp	r3, #0x2
 8006448: d00b         	beq	0x8006462 <dma_stm32_get_memory_increment+0x2a> @ imm = #0x16
 800644a: 2b02         	cmp	r3, #0x2
 800644c: dc10         	bgt	0x8006470 <dma_stm32_get_memory_increment+0x38> @ imm = #0x20
 800644e: 2b00         	cmp	r3, #0x0
 8006450: d002         	beq	0x8006458 <dma_stm32_get_memory_increment+0x20> @ imm = #0x4
 8006452: 2b01         	cmp	r3, #0x1
 8006454: d009         	beq	0x800646a <dma_stm32_get_memory_increment+0x32> @ imm = #0x12
 8006456: e00b         	b	0x8006470 <dma_stm32_get_memory_increment+0x38> @ imm = #0x16
; 		*ll_increment = LL_DMA_MEMORY_INCREMENT;
 8006458: 683b         	ldr	r3, [r7]
 800645a: f44f 6280    	mov.w	r2, #0x400
 800645e: 601a         	str	r2, [r3]
; 		break;
 8006460: e025         	b	0x80064ae <dma_stm32_get_memory_increment+0x76> @ imm = #0x4a
; 		*ll_increment = LL_DMA_MEMORY_NOINCREMENT;
 8006462: 683b         	ldr	r3, [r7]
 8006464: 2200         	movs	r2, #0x0
 8006466: 601a         	str	r2, [r3]
; 		break;
 8006468: e021         	b	0x80064ae <dma_stm32_get_memory_increment+0x76> @ imm = #0x42
; 		return -ENOTSUP;
 800646a: f06f 0385    	mvn	r3, #0x85
 800646e: e01f         	b	0x80064b0 <dma_stm32_get_memory_increment+0x78> @ imm = #0x3e
; 		LOG_ERR("Memory increment error. %d", increment);
 8006470: 2303         	movs	r3, #0x3
 8006472: 2b00         	cmp	r3, #0x0
 8006474: d018         	beq	0x80064a8 <dma_stm32_get_memory_increment+0x70> @ imm = #0x30
 8006476: 2301         	movs	r3, #0x1
 8006478: 73fb         	strb	r3, [r7, #0xf]
 800647a: 7bfb         	ldrb	r3, [r7, #0xf]
 800647c: f083 0301    	eor	r3, r3, #0x1
 8006480: b2db         	uxtb	r3, r3
 8006482: 2b00         	cmp	r3, #0x0
 8006484: d110         	bne	0x80064a8 <dma_stm32_get_memory_increment+0x70> @ imm = #0x20
 8006486: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80064b8 <dma_stm32_get_memory_increment+0x80>
 8006488: 6819         	ldr	r1, [r3]
 800648a: 79fb         	ldrb	r3, [r7, #0x7]
 800648c: 9303         	str	r3, [sp, #0xc]
 800648e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80064bc <dma_stm32_get_memory_increment+0x84>
 8006490: 9302         	str	r3, [sp, #0x8]
 8006492: 2300         	movs	r3, #0x0
 8006494: 9301         	str	r3, [sp, #0x4]
 8006496: 2300         	movs	r3, #0x0
 8006498: 9300         	str	r3, [sp]
 800649a: 2300         	movs	r3, #0x0
 800649c: 2201         	movs	r2, #0x1
 800649e: 2000         	movs	r0, #0x0
 80064a0: f00d fbc8    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd790
 80064a4: 2300         	movs	r3, #0x0
 80064a6: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 80064a8: f06f 0315    	mvn	r3, #0x15
 80064ac: e000         	b	0x80064b0 <dma_stm32_get_memory_increment+0x78> @ imm = #0x0
; 	return 0;
 80064ae: 2300         	movs	r3, #0x0
; }
 80064b0: 4618         	mov	r0, r3
 80064b2: 3710         	adds	r7, #0x10
 80064b4: 46bd         	mov	sp, r7
 80064b6: bd80         	pop	{r7, pc}

080064b8 <$d>:
 80064b8: 58 04 00 20  	.word	0x20000458
 80064bc: a4 bf 01 08  	.word	0x0801bfa4

080064c0 <dma_stm32_get_periph_increment>:
; {
 80064c0: b580         	push	{r7, lr}
 80064c2: b088         	sub	sp, #0x20
 80064c4: af04         	add	r7, sp, #0x10
 80064c6: 4603         	mov	r3, r0
 80064c8: 6039         	str	r1, [r7]
 80064ca: 71fb         	strb	r3, [r7, #0x7]
; 	switch (increment) {
 80064cc: 79fb         	ldrb	r3, [r7, #0x7]
 80064ce: 2b02         	cmp	r3, #0x2
 80064d0: d00b         	beq	0x80064ea <dma_stm32_get_periph_increment+0x2a> @ imm = #0x16
 80064d2: 2b02         	cmp	r3, #0x2
 80064d4: dc10         	bgt	0x80064f8 <dma_stm32_get_periph_increment+0x38> @ imm = #0x20
 80064d6: 2b00         	cmp	r3, #0x0
 80064d8: d002         	beq	0x80064e0 <dma_stm32_get_periph_increment+0x20> @ imm = #0x4
 80064da: 2b01         	cmp	r3, #0x1
 80064dc: d009         	beq	0x80064f2 <dma_stm32_get_periph_increment+0x32> @ imm = #0x12
 80064de: e00b         	b	0x80064f8 <dma_stm32_get_periph_increment+0x38> @ imm = #0x16
; 		*ll_increment = LL_DMA_PERIPH_INCREMENT;
 80064e0: 683b         	ldr	r3, [r7]
 80064e2: f44f 7200    	mov.w	r2, #0x200
 80064e6: 601a         	str	r2, [r3]
; 		break;
 80064e8: e025         	b	0x8006536 <dma_stm32_get_periph_increment+0x76> @ imm = #0x4a
; 		*ll_increment = LL_DMA_PERIPH_NOINCREMENT;
 80064ea: 683b         	ldr	r3, [r7]
 80064ec: 2200         	movs	r2, #0x0
 80064ee: 601a         	str	r2, [r3]
; 		break;
 80064f0: e021         	b	0x8006536 <dma_stm32_get_periph_increment+0x76> @ imm = #0x42
; 		return -ENOTSUP;
 80064f2: f06f 0385    	mvn	r3, #0x85
 80064f6: e01f         	b	0x8006538 <dma_stm32_get_periph_increment+0x78> @ imm = #0x3e
; 		LOG_ERR("Periph increment error. %d", increment);
 80064f8: 2303         	movs	r3, #0x3
 80064fa: 2b00         	cmp	r3, #0x0
 80064fc: d018         	beq	0x8006530 <dma_stm32_get_periph_increment+0x70> @ imm = #0x30
 80064fe: 2301         	movs	r3, #0x1
 8006500: 73fb         	strb	r3, [r7, #0xf]
 8006502: 7bfb         	ldrb	r3, [r7, #0xf]
 8006504: f083 0301    	eor	r3, r3, #0x1
 8006508: b2db         	uxtb	r3, r3
 800650a: 2b00         	cmp	r3, #0x0
 800650c: d110         	bne	0x8006530 <dma_stm32_get_periph_increment+0x70> @ imm = #0x20
 800650e: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8006540 <dma_stm32_get_periph_increment+0x80>
 8006510: 6819         	ldr	r1, [r3]
 8006512: 79fb         	ldrb	r3, [r7, #0x7]
 8006514: 9303         	str	r3, [sp, #0xc]
 8006516: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8006544 <dma_stm32_get_periph_increment+0x84>
 8006518: 9302         	str	r3, [sp, #0x8]
 800651a: 2300         	movs	r3, #0x0
 800651c: 9301         	str	r3, [sp, #0x4]
 800651e: 2300         	movs	r3, #0x0
 8006520: 9300         	str	r3, [sp]
 8006522: 2300         	movs	r3, #0x0
 8006524: 2201         	movs	r2, #0x1
 8006526: 2000         	movs	r0, #0x0
 8006528: f00d fb84    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd708
 800652c: 2300         	movs	r3, #0x0
 800652e: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 8006530: f06f 0315    	mvn	r3, #0x15
 8006534: e000         	b	0x8006538 <dma_stm32_get_periph_increment+0x78> @ imm = #0x0
; 	return 0;
 8006536: 2300         	movs	r3, #0x0
; }
 8006538: 4618         	mov	r0, r3
 800653a: 3710         	adds	r7, #0x10
 800653c: 46bd         	mov	sp, r7
 800653e: bd80         	pop	{r7, pc}

08006540 <$d>:
 8006540: 58 04 00 20  	.word	0x20000458
 8006544: c0 bf 01 08  	.word	0x0801bfc0

08006548 <dma_stm32_configure>:
; {
 8006548: b580         	push	{r7, lr}
 800654a: b0be         	sub	sp, #0xf8
 800654c: af06         	add	r7, sp, #0x18
 800654e: 60f8         	str	r0, [r7, #0xc]
 8006550: 60b9         	str	r1, [r7, #0x8]
 8006552: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_stm32_config *dev_config = dev->config;
 8006554: 68fb         	ldr	r3, [r7, #0xc]
 8006556: 685b         	ldr	r3, [r3, #0x4]
 8006558: f8c7 30c8    	str.w	r3, [r7, #0xc8]
; 				&dev_config->streams[id - STM32_DMA_STREAM_OFFSET];
 800655c: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8006560: 6999         	ldr	r1, [r3, #0x18]
 8006562: 68ba         	ldr	r2, [r7, #0x8]
 8006564: 4613         	mov	r3, r2
 8006566: 00db         	lsls	r3, r3, #0x3
 8006568: 1a9b         	subs	r3, r3, r2
 800656a: 009b         	lsls	r3, r3, #0x2
; 	struct dma_stm32_stream *stream =
 800656c: 440b         	add	r3, r1
 800656e: f8c7 30d0    	str.w	r3, [r7, #0xd0]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)dev_config->base;
 8006572: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8006576: 691b         	ldr	r3, [r3, #0x10]
 8006578: f8c7 30cc    	str.w	r3, [r7, #0xcc]
; 	LL_DMA_StructInit(&DMA_InitStruct);
 800657c: f107 0310    	add.w	r3, r7, #0x10
 8006580: 4618         	mov	r0, r3
 8006582: f012 f8ec    	bl	0x801875e <LL_DMA_StructInit> @ imm = #0x121d8
; 	if (id >= dev_config->max_streams) {
 8006586: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 800658a: 695b         	ldr	r3, [r3, #0x14]
 800658c: 68ba         	ldr	r2, [r7, #0x8]
 800658e: 429a         	cmp	r2, r3
 8006590: d321         	blo	0x80065d6 <dma_stm32_configure+0x8e> @ imm = #0x42
; 		LOG_ERR("cannot configure the dma stream %d.", id);
 8006592: 2303         	movs	r3, #0x3
 8006594: 2b00         	cmp	r3, #0x0
 8006596: d01a         	beq	0x80065ce <dma_stm32_configure+0x86> @ imm = #0x34
 8006598: 2301         	movs	r3, #0x1
 800659a: f887 305b    	strb.w	r3, [r7, #0x5b]
 800659e: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 80065a2: f083 0301    	eor	r3, r3, #0x1
 80065a6: b2db         	uxtb	r3, r3
 80065a8: 2b00         	cmp	r3, #0x0
 80065aa: d110         	bne	0x80065ce <dma_stm32_configure+0x86> @ imm = #0x20
 80065ac: 4b9b         	ldr	r3, [pc, #0x26c]        @ 0x800681c <dma_stm32_configure+0x2d4>
 80065ae: 6819         	ldr	r1, [r3]
 80065b0: 68bb         	ldr	r3, [r7, #0x8]
 80065b2: 9303         	str	r3, [sp, #0xc]
 80065b4: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x8006820 <dma_stm32_configure+0x2d8>
 80065b6: 9302         	str	r3, [sp, #0x8]
 80065b8: 2300         	movs	r3, #0x0
 80065ba: 9301         	str	r3, [sp, #0x4]
 80065bc: 2300         	movs	r3, #0x0
 80065be: 9300         	str	r3, [sp]
 80065c0: 2300         	movs	r3, #0x0
 80065c2: 2201         	movs	r2, #0x1
 80065c4: 2000         	movs	r0, #0x0
 80065c6: f00d fb35    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd66a
 80065ca: 2300         	movs	r3, #0x0
 80065cc: 657b         	str	r3, [r7, #0x54]
; 		return -EINVAL;
 80065ce: f06f 0315    	mvn	r3, #0x15
 80065d2: f000 bc1f    	b.w	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x83e
; 	if (stream->busy) {
 80065d6: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80065da: 799b         	ldrb	r3, [r3, #0x6]
 80065dc: b2db         	uxtb	r3, r3
 80065de: 2b00         	cmp	r3, #0x0
 80065e0: d020         	beq	0x8006624 <dma_stm32_configure+0xdc> @ imm = #0x40
; 		LOG_ERR("dma stream %d is busy.", id);
 80065e2: 2303         	movs	r3, #0x3
 80065e4: 2b00         	cmp	r3, #0x0
 80065e6: d01a         	beq	0x800661e <dma_stm32_configure+0xd6> @ imm = #0x34
 80065e8: 2301         	movs	r3, #0x1
 80065ea: f887 3063    	strb.w	r3, [r7, #0x63]
 80065ee: f897 3063    	ldrb.w	r3, [r7, #0x63]
 80065f2: f083 0301    	eor	r3, r3, #0x1
 80065f6: b2db         	uxtb	r3, r3
 80065f8: 2b00         	cmp	r3, #0x0
 80065fa: d110         	bne	0x800661e <dma_stm32_configure+0xd6> @ imm = #0x20
 80065fc: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x800681c <dma_stm32_configure+0x2d4>
 80065fe: 6819         	ldr	r1, [r3]
 8006600: 68bb         	ldr	r3, [r7, #0x8]
 8006602: 9303         	str	r3, [sp, #0xc]
 8006604: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8006824 <dma_stm32_configure+0x2dc>
 8006606: 9302         	str	r3, [sp, #0x8]
 8006608: 2300         	movs	r3, #0x0
 800660a: 9301         	str	r3, [sp, #0x4]
 800660c: 2300         	movs	r3, #0x0
 800660e: 9300         	str	r3, [sp]
 8006610: 2300         	movs	r3, #0x0
 8006612: 2201         	movs	r2, #0x1
 8006614: 2000         	movs	r0, #0x0
 8006616: f00d fb0d    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd61a
 800661a: 2300         	movs	r3, #0x0
 800661c: 65fb         	str	r3, [r7, #0x5c]
; 		return -EBUSY;
 800661e: f06f 030f    	mvn	r3, #0xf
 8006622: e3f7         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x7ee
; 	if (dma_stm32_disable_stream(dma, id) != 0) {
 8006624: 68b9         	ldr	r1, [r7, #0x8]
 8006626: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 800662a: f00d fb4f    	bl	0x8013ccc <dma_stm32_disable_stream> @ imm = #0xd69e
 800662e: 4603         	mov	r3, r0
 8006630: 2b00         	cmp	r3, #0x0
 8006632: d020         	beq	0x8006676 <dma_stm32_configure+0x12e> @ imm = #0x40
; 		LOG_ERR("could not disable dma stream %d.", id);
 8006634: 2303         	movs	r3, #0x3
 8006636: 2b00         	cmp	r3, #0x0
 8006638: d01a         	beq	0x8006670 <dma_stm32_configure+0x128> @ imm = #0x34
 800663a: 2301         	movs	r3, #0x1
 800663c: f887 306b    	strb.w	r3, [r7, #0x6b]
 8006640: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 8006644: f083 0301    	eor	r3, r3, #0x1
 8006648: b2db         	uxtb	r3, r3
 800664a: 2b00         	cmp	r3, #0x0
 800664c: d110         	bne	0x8006670 <dma_stm32_configure+0x128> @ imm = #0x20
 800664e: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x800681c <dma_stm32_configure+0x2d4>
 8006650: 6819         	ldr	r1, [r3]
 8006652: 68bb         	ldr	r3, [r7, #0x8]
 8006654: 9303         	str	r3, [sp, #0xc]
 8006656: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8006828 <dma_stm32_configure+0x2e0>
 8006658: 9302         	str	r3, [sp, #0x8]
 800665a: 2300         	movs	r3, #0x0
 800665c: 9301         	str	r3, [sp, #0x4]
 800665e: 2300         	movs	r3, #0x0
 8006660: 9300         	str	r3, [sp]
 8006662: 2300         	movs	r3, #0x0
 8006664: 2201         	movs	r2, #0x1
 8006666: 2000         	movs	r0, #0x0
 8006668: f00d fae4    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd5c8
 800666c: 2300         	movs	r3, #0x0
 800666e: 667b         	str	r3, [r7, #0x64]
; 		return -EBUSY;
 8006670: f06f 030f    	mvn	r3, #0xf
 8006674: e3ce         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x79c
; 	dma_stm32_clear_stream_irq(dev, id);
 8006676: 68b9         	ldr	r1, [r7, #0x8]
 8006678: 68f8         	ldr	r0, [r7, #0xc]
 800667a: f00d fb0c    	bl	0x8013c96 <dma_stm32_clear_stream_irq> @ imm = #0xd618
; 	if (config->linked_channel == STM32_DMA_HAL_OVERRIDE) {
 800667e: 687b         	ldr	r3, [r7, #0x4]
 8006680: 885b         	ldrh	r3, [r3, #0x2]
 8006682: f403 637e    	and	r3, r3, #0xfe0
 8006686: b29b         	uxth	r3, r3
 8006688: f5b3 6f7e    	cmp.w	r3, #0xfe0
 800668c: d117         	bne	0x80066be <dma_stm32_configure+0x176> @ imm = #0x2e
; 		stream->busy = true;
 800668e: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006692: 2201         	movs	r2, #0x1
 8006694: 719a         	strb	r2, [r3, #0x6]
; 		stream->hal_override = true;
 8006696: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800669a: 2201         	movs	r2, #0x1
 800669c: 715a         	strb	r2, [r3, #0x5]
; 		stream->dma_callback = config->dma_callback;
 800669e: 687b         	ldr	r3, [r7, #0x4]
 80066a0: 699a         	ldr	r2, [r3, #0x18]
 80066a2: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80066a6: 615a         	str	r2, [r3, #0x14]
; 		stream->user_data = config->user_data;
 80066a8: 687b         	ldr	r3, [r7, #0x4]
 80066aa: 695a         	ldr	r2, [r3, #0x14]
 80066ac: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80066b0: 611a         	str	r2, [r3, #0x10]
; 		stream->cyclic = false;
 80066b2: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80066b6: 2200         	movs	r2, #0x0
 80066b8: 761a         	strb	r2, [r3, #0x18]
; 		return 0;
 80066ba: 2300         	movs	r3, #0x0
 80066bc: e3aa         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x754
; 	if (config->head_block->block_size > DMA_STM32_MAX_DATA_ITEMS) {
 80066be: 687b         	ldr	r3, [r7, #0x4]
 80066c0: 691b         	ldr	r3, [r3, #0x10]
 80066c2: 695b         	ldr	r3, [r3, #0x14]
 80066c4: f5b3 3f80    	cmp.w	r3, #0x10000
 80066c8: d322         	blo	0x8006710 <dma_stm32_configure+0x1c8> @ imm = #0x44
; 		LOG_ERR("Data size too big: %d\n",
 80066ca: 2303         	movs	r3, #0x3
 80066cc: 2b00         	cmp	r3, #0x0
 80066ce: d01c         	beq	0x800670a <dma_stm32_configure+0x1c2> @ imm = #0x38
 80066d0: 2301         	movs	r3, #0x1
 80066d2: f887 3073    	strb.w	r3, [r7, #0x73]
 80066d6: f897 3073    	ldrb.w	r3, [r7, #0x73]
 80066da: f083 0301    	eor	r3, r3, #0x1
 80066de: b2db         	uxtb	r3, r3
 80066e0: 2b00         	cmp	r3, #0x0
 80066e2: d112         	bne	0x800670a <dma_stm32_configure+0x1c2> @ imm = #0x24
 80066e4: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800681c <dma_stm32_configure+0x2d4>
 80066e6: 6819         	ldr	r1, [r3]
 80066e8: 687b         	ldr	r3, [r7, #0x4]
 80066ea: 691b         	ldr	r3, [r3, #0x10]
 80066ec: 695b         	ldr	r3, [r3, #0x14]
 80066ee: 9303         	str	r3, [sp, #0xc]
 80066f0: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x800682c <dma_stm32_configure+0x2e4>
 80066f2: 9302         	str	r3, [sp, #0x8]
 80066f4: 2300         	movs	r3, #0x0
 80066f6: 9301         	str	r3, [sp, #0x4]
 80066f8: 2300         	movs	r3, #0x0
 80066fa: 9300         	str	r3, [sp]
 80066fc: 2300         	movs	r3, #0x0
 80066fe: 2201         	movs	r2, #0x1
 8006700: 2000         	movs	r0, #0x0
 8006702: f00d fa97    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd52e
 8006706: 2300         	movs	r3, #0x0
 8006708: 66fb         	str	r3, [r7, #0x6c]
; 		return -EINVAL;
 800670a: f06f 0315    	mvn	r3, #0x15
 800670e: e381         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x702
; 	if ((config->channel_direction == MEMORY_TO_MEMORY) &&
 8006710: 687b         	ldr	r3, [r7, #0x4]
 8006712: 785b         	ldrb	r3, [r3, #0x1]
 8006714: f003 0307    	and	r3, r3, #0x7
 8006718: b2db         	uxtb	r3, r3
 800671a: 2b00         	cmp	r3, #0x0
 800671c: d12a         	bne	0x8006774 <dma_stm32_configure+0x22c> @ imm = #0x54
; 		(!dev_config->support_m2m)) {
 800671e: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8006722: 7b1b         	ldrb	r3, [r3, #0xc]
 8006724: f083 0301    	eor	r3, r3, #0x1
 8006728: b2db         	uxtb	r3, r3
; 	if ((config->channel_direction == MEMORY_TO_MEMORY) &&
 800672a: 2b00         	cmp	r3, #0x0
 800672c: d022         	beq	0x8006774 <dma_stm32_configure+0x22c> @ imm = #0x44
; 		LOG_ERR("Memcopy not supported for device %s",
 800672e: 2303         	movs	r3, #0x3
 8006730: 2b00         	cmp	r3, #0x0
 8006732: d01c         	beq	0x800676e <dma_stm32_configure+0x226> @ imm = #0x38
 8006734: 2301         	movs	r3, #0x1
 8006736: f887 30d6    	strb.w	r3, [r7, #0xd6]
 800673a: f897 30d6    	ldrb.w	r3, [r7, #0xd6]
 800673e: f083 0301    	eor	r3, r3, #0x1
 8006742: b2db         	uxtb	r3, r3
 8006744: 2b00         	cmp	r3, #0x0
 8006746: d112         	bne	0x800676e <dma_stm32_configure+0x226> @ imm = #0x24
 8006748: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x800681c <dma_stm32_configure+0x2d4>
 800674a: 6819         	ldr	r1, [r3]
 800674c: 68fb         	ldr	r3, [r7, #0xc]
 800674e: 681b         	ldr	r3, [r3]
 8006750: 9303         	str	r3, [sp, #0xc]
 8006752: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8006830 <dma_stm32_configure+0x2e8>
 8006754: 9302         	str	r3, [sp, #0x8]
 8006756: 2300         	movs	r3, #0x0
 8006758: 9301         	str	r3, [sp, #0x4]
 800675a: 2300         	movs	r3, #0x0
 800675c: 9300         	str	r3, [sp]
 800675e: 2300         	movs	r3, #0x0
 8006760: 2201         	movs	r2, #0x1
 8006762: 2000         	movs	r0, #0x0
 8006764: f00d fa66    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd4cc
 8006768: 2300         	movs	r3, #0x0
 800676a: f8c7 30d8    	str.w	r3, [r7, #0xd8]
; 		return -ENOTSUP;
 800676e: f06f 0385    	mvn	r3, #0x85
 8006772: e34f         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x69e
; 	if ((config->dest_data_size != config->source_data_size)) {
 8006774: 687b         	ldr	r3, [r7, #0x4]
 8006776: 88da         	ldrh	r2, [r3, #0x6]
 8006778: 687b         	ldr	r3, [r7, #0x4]
 800677a: 889b         	ldrh	r3, [r3, #0x4]
 800677c: 429a         	cmp	r2, r3
 800677e: d01e         	beq	0x80067be <dma_stm32_configure+0x276> @ imm = #0x3c
; 		LOG_ERR("source and dest data size differ.");
 8006780: 2303         	movs	r3, #0x3
 8006782: 2b00         	cmp	r3, #0x0
 8006784: d018         	beq	0x80067b8 <dma_stm32_configure+0x270> @ imm = #0x30
 8006786: 2301         	movs	r3, #0x1
 8006788: f887 307b    	strb.w	r3, [r7, #0x7b]
 800678c: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 8006790: f083 0301    	eor	r3, r3, #0x1
 8006794: b2db         	uxtb	r3, r3
 8006796: 2b00         	cmp	r3, #0x0
 8006798: d10e         	bne	0x80067b8 <dma_stm32_configure+0x270> @ imm = #0x1c
 800679a: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800681c <dma_stm32_configure+0x2d4>
 800679c: 6819         	ldr	r1, [r3]
 800679e: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8006834 <dma_stm32_configure+0x2ec>
 80067a0: 9302         	str	r3, [sp, #0x8]
 80067a2: 2300         	movs	r3, #0x0
 80067a4: 9301         	str	r3, [sp, #0x4]
 80067a6: 2300         	movs	r3, #0x0
 80067a8: 9300         	str	r3, [sp]
 80067aa: 2300         	movs	r3, #0x0
 80067ac: 2201         	movs	r2, #0x1
 80067ae: 2000         	movs	r0, #0x0
 80067b0: f00d fa40    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd480
 80067b4: 2300         	movs	r3, #0x0
 80067b6: 677b         	str	r3, [r7, #0x74]
; 		return -EINVAL;
 80067b8: f06f 0315    	mvn	r3, #0x15
 80067bc: e32a         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x654
; 	if (config->source_data_size != 4U &&
 80067be: 687b         	ldr	r3, [r7, #0x4]
 80067c0: 889b         	ldrh	r3, [r3, #0x4]
 80067c2: 2b04         	cmp	r3, #0x4
 80067c4: d03a         	beq	0x800683c <dma_stm32_configure+0x2f4> @ imm = #0x74
; 	    config->source_data_size != 2U &&
 80067c6: 687b         	ldr	r3, [r7, #0x4]
 80067c8: 889b         	ldrh	r3, [r3, #0x4]
; 	if (config->source_data_size != 4U &&
 80067ca: 2b02         	cmp	r3, #0x2
 80067cc: d036         	beq	0x800683c <dma_stm32_configure+0x2f4> @ imm = #0x6c
; 	    config->source_data_size != 1U) {
 80067ce: 687b         	ldr	r3, [r7, #0x4]
 80067d0: 889b         	ldrh	r3, [r3, #0x4]
; 	    config->source_data_size != 2U &&
 80067d2: 2b01         	cmp	r3, #0x1
 80067d4: d032         	beq	0x800683c <dma_stm32_configure+0x2f4> @ imm = #0x64
; 		LOG_ERR("source and dest unit size error, %d",
 80067d6: 2303         	movs	r3, #0x3
 80067d8: 2b00         	cmp	r3, #0x0
 80067da: d01c         	beq	0x8006816 <dma_stm32_configure+0x2ce> @ imm = #0x38
 80067dc: 2301         	movs	r3, #0x1
 80067de: f887 30d7    	strb.w	r3, [r7, #0xd7]
 80067e2: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 80067e6: f083 0301    	eor	r3, r3, #0x1
 80067ea: b2db         	uxtb	r3, r3
 80067ec: 2b00         	cmp	r3, #0x0
 80067ee: d112         	bne	0x8006816 <dma_stm32_configure+0x2ce> @ imm = #0x24
 80067f0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800681c <dma_stm32_configure+0x2d4>
 80067f2: 6819         	ldr	r1, [r3]
 80067f4: 687b         	ldr	r3, [r7, #0x4]
 80067f6: 889b         	ldrh	r3, [r3, #0x4]
 80067f8: 9303         	str	r3, [sp, #0xc]
 80067fa: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8006838 <dma_stm32_configure+0x2f0>
 80067fc: 9302         	str	r3, [sp, #0x8]
 80067fe: 2300         	movs	r3, #0x0
 8006800: 9301         	str	r3, [sp, #0x4]
 8006802: 2300         	movs	r3, #0x0
 8006804: 9300         	str	r3, [sp]
 8006806: 2300         	movs	r3, #0x0
 8006808: 2201         	movs	r2, #0x1
 800680a: 2000         	movs	r0, #0x0
 800680c: f00d fa12    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd424
 8006810: 2300         	movs	r3, #0x0
 8006812: f8c7 30dc    	str.w	r3, [r7, #0xdc]
; 		return -EINVAL;
 8006816: f06f 0315    	mvn	r3, #0x15
 800681a: e2fb         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x5f6

0800681c <$d>:
 800681c: 58 04 00 20  	.word	0x20000458
 8006820: dc bf 01 08  	.word	0x0801bfdc
 8006824: 00 c0 01 08  	.word	0x0801c000
 8006828: 18 c0 01 08  	.word	0x0801c018
 800682c: 3c c0 01 08  	.word	0x0801c03c
 8006830: 54 c0 01 08  	.word	0x0801c054
 8006834: 78 c0 01 08  	.word	0x0801c078
 8006838: 9c c0 01 08  	.word	0x0801c09c

0800683c <$t>:
; 	if (config->head_block->source_reload_en !=
 800683c: 687b         	ldr	r3, [r7, #0x4]
 800683e: 691b         	ldr	r3, [r3, #0x10]
 8006840: 7f1b         	ldrb	r3, [r3, #0x1c]
 8006842: f3c3 1380    	ubfx	r3, r3, #0x6, #0x1
 8006846: b2da         	uxtb	r2, r3
; 		config->head_block->dest_reload_en) {
 8006848: 687b         	ldr	r3, [r7, #0x4]
 800684a: 691b         	ldr	r3, [r3, #0x10]
 800684c: 7f1b         	ldrb	r3, [r3, #0x1c]
 800684e: f3c3 13c0    	ubfx	r3, r3, #0x7, #0x1
 8006852: b2db         	uxtb	r3, r3
; 	if (config->head_block->source_reload_en !=
 8006854: 429a         	cmp	r2, r3
 8006856: d01e         	beq	0x8006896 <dma_stm32_configure+0x34e> @ imm = #0x3c
; 		LOG_ERR("source_reload_en and dest_reload_en must "
 8006858: 2303         	movs	r3, #0x3
 800685a: 2b00         	cmp	r3, #0x0
 800685c: d018         	beq	0x8006890 <dma_stm32_configure+0x348> @ imm = #0x30
 800685e: 2301         	movs	r3, #0x1
 8006860: f887 3083    	strb.w	r3, [r7, #0x83]
 8006864: f897 3083    	ldrb.w	r3, [r7, #0x83]
 8006868: f083 0301    	eor	r3, r3, #0x1
 800686c: b2db         	uxtb	r3, r3
 800686e: 2b00         	cmp	r3, #0x0
 8006870: d10e         	bne	0x8006890 <dma_stm32_configure+0x348> @ imm = #0x1c
 8006872: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8006ae4 <dma_stm32_configure+0x59c>
 8006874: 6819         	ldr	r1, [r3]
 8006876: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8006ae8 <dma_stm32_configure+0x5a0>
 8006878: 9302         	str	r3, [sp, #0x8]
 800687a: 2300         	movs	r3, #0x0
 800687c: 9301         	str	r3, [sp, #0x4]
 800687e: 2300         	movs	r3, #0x0
 8006880: 9300         	str	r3, [sp]
 8006882: 2300         	movs	r3, #0x0
 8006884: 2201         	movs	r2, #0x1
 8006886: 2000         	movs	r0, #0x0
 8006888: f00d f9d4    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd3a8
 800688c: 2300         	movs	r3, #0x0
 800688e: 67fb         	str	r3, [r7, #0x7c]
; 		return -EINVAL;
 8006890: f06f 0315    	mvn	r3, #0x15
 8006894: e2be         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x57c
; 	stream->busy		= true;
 8006896: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800689a: 2201         	movs	r2, #0x1
 800689c: 719a         	strb	r2, [r3, #0x6]
; 	stream->dma_callback	= config->dma_callback;
 800689e: 687b         	ldr	r3, [r7, #0x4]
 80068a0: 699a         	ldr	r2, [r3, #0x18]
 80068a2: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80068a6: 615a         	str	r2, [r3, #0x14]
; 	stream->direction	= config->channel_direction;
 80068a8: 687b         	ldr	r3, [r7, #0x4]
 80068aa: 785b         	ldrb	r3, [r3, #0x1]
 80068ac: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 80068b0: b2db         	uxtb	r3, r3
 80068b2: 461a         	mov	r2, r3
 80068b4: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80068b8: 601a         	str	r2, [r3]
; 	stream->user_data       = config->user_data;
 80068ba: 687b         	ldr	r3, [r7, #0x4]
 80068bc: 695a         	ldr	r2, [r3, #0x14]
 80068be: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80068c2: 611a         	str	r2, [r3, #0x10]
; 	stream->src_size	= config->source_data_size;
 80068c4: 687b         	ldr	r3, [r7, #0x4]
 80068c6: 889b         	ldrh	r3, [r3, #0x4]
 80068c8: 461a         	mov	r2, r3
 80068ca: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80068ce: 609a         	str	r2, [r3, #0x8]
; 	stream->dst_size	= config->dest_data_size;
 80068d0: 687b         	ldr	r3, [r7, #0x4]
 80068d2: 88db         	ldrh	r3, [r3, #0x6]
 80068d4: 461a         	mov	r2, r3
 80068d6: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80068da: 60da         	str	r2, [r3, #0xc]
; 	stream->cyclic		= config->head_block->source_reload_en;
 80068dc: 687b         	ldr	r3, [r7, #0x4]
 80068de: 691b         	ldr	r3, [r3, #0x10]
 80068e0: 7f1b         	ldrb	r3, [r3, #0x1c]
 80068e2: f3c3 1380    	ubfx	r3, r3, #0x6, #0x1
 80068e6: b2db         	uxtb	r3, r3
 80068e8: 2b00         	cmp	r3, #0x0
 80068ea: bf14         	ite	ne
 80068ec: 2301         	movne	r3, #0x1
 80068ee: 2300         	moveq	r3, #0x0
 80068f0: b2da         	uxtb	r2, r3
 80068f2: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80068f6: 761a         	strb	r2, [r3, #0x18]
; 	if (config->head_block->source_address == 0) {
 80068f8: 687b         	ldr	r3, [r7, #0x4]
 80068fa: 691b         	ldr	r3, [r3, #0x10]
 80068fc: 681b         	ldr	r3, [r3]
 80068fe: 2b00         	cmp	r3, #0x0
 8006900: d11c         	bne	0x800693c <dma_stm32_configure+0x3f4> @ imm = #0x38
; 		LOG_WRN("source_buffer address is null.");
 8006902: 2303         	movs	r3, #0x3
 8006904: 2b01         	cmp	r3, #0x1
 8006906: d919         	bls	0x800693c <dma_stm32_configure+0x3f4> @ imm = #0x32
 8006908: 2301         	movs	r3, #0x1
 800690a: f887 30c3    	strb.w	r3, [r7, #0xc3]
 800690e: f897 30c3    	ldrb.w	r3, [r7, #0xc3]
 8006912: f083 0301    	eor	r3, r3, #0x1
 8006916: b2db         	uxtb	r3, r3
 8006918: 2b00         	cmp	r3, #0x0
 800691a: d10f         	bne	0x800693c <dma_stm32_configure+0x3f4> @ imm = #0x1e
 800691c: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8006ae4 <dma_stm32_configure+0x59c>
 800691e: 6819         	ldr	r1, [r3]
 8006920: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8006aec <dma_stm32_configure+0x5a4>
 8006922: 9302         	str	r3, [sp, #0x8]
 8006924: 2300         	movs	r3, #0x0
 8006926: 9301         	str	r3, [sp, #0x4]
 8006928: 2300         	movs	r3, #0x0
 800692a: 9300         	str	r3, [sp]
 800692c: 2300         	movs	r3, #0x0
 800692e: 2202         	movs	r2, #0x2
 8006930: 2000         	movs	r0, #0x0
 8006932: f00d f97f    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd2fe
 8006936: 2300         	movs	r3, #0x0
 8006938: f8c7 30bc    	str.w	r3, [r7, #0xbc]
; 	if (config->head_block->dest_address == 0) {
 800693c: 687b         	ldr	r3, [r7, #0x4]
 800693e: 691b         	ldr	r3, [r3, #0x10]
 8006940: 685b         	ldr	r3, [r3, #0x4]
 8006942: 2b00         	cmp	r3, #0x0
 8006944: d11c         	bne	0x8006980 <dma_stm32_configure+0x438> @ imm = #0x38
; 		LOG_WRN("dest_buffer address is null.");
 8006946: 2303         	movs	r3, #0x3
 8006948: 2b01         	cmp	r3, #0x1
 800694a: d919         	bls	0x8006980 <dma_stm32_configure+0x438> @ imm = #0x32
 800694c: 2301         	movs	r3, #0x1
 800694e: f887 30bb    	strb.w	r3, [r7, #0xbb]
 8006952: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 8006956: f083 0301    	eor	r3, r3, #0x1
 800695a: b2db         	uxtb	r3, r3
 800695c: 2b00         	cmp	r3, #0x0
 800695e: d10f         	bne	0x8006980 <dma_stm32_configure+0x438> @ imm = #0x1e
 8006960: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8006ae4 <dma_stm32_configure+0x59c>
 8006962: 6819         	ldr	r1, [r3]
 8006964: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8006af0 <dma_stm32_configure+0x5a8>
 8006966: 9302         	str	r3, [sp, #0x8]
 8006968: 2300         	movs	r3, #0x0
 800696a: 9301         	str	r3, [sp, #0x4]
 800696c: 2300         	movs	r3, #0x0
 800696e: 9300         	str	r3, [sp]
 8006970: 2300         	movs	r3, #0x0
 8006972: 2202         	movs	r2, #0x2
 8006974: 2000         	movs	r0, #0x0
 8006976: f00d f95d    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd2ba
 800697a: 2300         	movs	r3, #0x0
 800697c: f8c7 30b4    	str.w	r3, [r7, #0xb4]
; 	if (stream->direction == MEMORY_TO_PERIPHERAL) {
 8006980: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006984: 681b         	ldr	r3, [r3]
 8006986: 2b01         	cmp	r3, #0x1
 8006988: d108         	bne	0x800699c <dma_stm32_configure+0x454> @ imm = #0x10
; 					config->head_block->source_address;
 800698a: 687b         	ldr	r3, [r7, #0x4]
 800698c: 691b         	ldr	r3, [r3, #0x10]
 800698e: 681b         	ldr	r3, [r3]
; 		DMA_InitStruct.MemoryOrM2MDstAddress =
 8006990: 617b         	str	r3, [r7, #0x14]
; 					config->head_block->dest_address;
 8006992: 687b         	ldr	r3, [r7, #0x4]
 8006994: 691b         	ldr	r3, [r3, #0x10]
 8006996: 685b         	ldr	r3, [r3, #0x4]
; 		DMA_InitStruct.PeriphOrM2MSrcAddress =
 8006998: 613b         	str	r3, [r7, #0x10]
 800699a: e007         	b	0x80069ac <dma_stm32_configure+0x464> @ imm = #0xe
; 					config->head_block->source_address;
 800699c: 687b         	ldr	r3, [r7, #0x4]
 800699e: 691b         	ldr	r3, [r3, #0x10]
 80069a0: 681b         	ldr	r3, [r3]
; 		DMA_InitStruct.PeriphOrM2MSrcAddress =
 80069a2: 613b         	str	r3, [r7, #0x10]
; 					config->head_block->dest_address;
 80069a4: 687b         	ldr	r3, [r7, #0x4]
 80069a6: 691b         	ldr	r3, [r3, #0x10]
 80069a8: 685b         	ldr	r3, [r3, #0x4]
; 		DMA_InitStruct.MemoryOrM2MDstAddress =
 80069aa: 617b         	str	r3, [r7, #0x14]
; 	uint16_t memory_addr_adj = 0, periph_addr_adj = 0;
 80069ac: 2300         	movs	r3, #0x0
 80069ae: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
 80069b2: 2300         	movs	r3, #0x0
 80069b4: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 	ret = dma_stm32_get_priority(config->channel_priority,
 80069b8: 687b         	ldr	r3, [r7, #0x4]
 80069ba: 681b         	ldr	r3, [r3]
 80069bc: f3c3 33c3    	ubfx	r3, r3, #0xf, #0x4
 80069c0: b2db         	uxtb	r3, r3
 80069c2: 461a         	mov	r2, r3
 80069c4: f107 0310    	add.w	r3, r7, #0x10
 80069c8: 3328         	adds	r3, #0x28
 80069ca: 4619         	mov	r1, r3
 80069cc: 4610         	mov	r0, r2
 80069ce: f7ff fc9f    	bl	0x8006310 <dma_stm32_get_priority> @ imm = #-0x6c2
 80069d2: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 80069d6: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 80069da: 2b00         	cmp	r3, #0x0
 80069dc: da02         	bge	0x80069e4 <dma_stm32_configure+0x49c> @ imm = #0x4
; 		return ret;
 80069de: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 80069e2: e217         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x42e
; 	ret = dma_stm32_get_direction(config->channel_direction,
 80069e4: 687b         	ldr	r3, [r7, #0x4]
 80069e6: 785b         	ldrb	r3, [r3, #0x1]
 80069e8: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 80069ec: b2db         	uxtb	r3, r3
 80069ee: 461a         	mov	r2, r3
 80069f0: f107 0310    	add.w	r3, r7, #0x10
 80069f4: 3308         	adds	r3, #0x8
 80069f6: 4619         	mov	r1, r3
 80069f8: 4610         	mov	r0, r2
 80069fa: f7ff fcd9    	bl	0x80063b0 <dma_stm32_get_direction> @ imm = #-0x64e
 80069fe: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8006a02: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006a06: 2b00         	cmp	r3, #0x0
 8006a08: da02         	bge	0x8006a10 <dma_stm32_configure+0x4c8> @ imm = #0x4
; 		return ret;
 8006a0a: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006a0e: e201         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x402
; 	switch (config->channel_direction) {
 8006a10: 687b         	ldr	r3, [r7, #0x4]
 8006a12: 785b         	ldrb	r3, [r3, #0x1]
 8006a14: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 8006a18: b2db         	uxtb	r3, r3
 8006a1a: 2b02         	cmp	r3, #0x2
 8006a1c: d006         	beq	0x8006a2c <dma_stm32_configure+0x4e4> @ imm = #0xc
 8006a1e: 2b02         	cmp	r3, #0x2
 8006a20: dc26         	bgt	0x8006a70 <dma_stm32_configure+0x528> @ imm = #0x4c
 8006a22: 2b00         	cmp	r3, #0x0
 8006a24: d002         	beq	0x8006a2c <dma_stm32_configure+0x4e4> @ imm = #0x4
 8006a26: 2b01         	cmp	r3, #0x1
 8006a28: d011         	beq	0x8006a4e <dma_stm32_configure+0x506> @ imm = #0x22
 8006a2a: e021         	b	0x8006a70 <dma_stm32_configure+0x528> @ imm = #0x42
; 		memory_addr_adj = config->head_block->dest_addr_adj;
 8006a2c: 687b         	ldr	r3, [r7, #0x4]
 8006a2e: 691b         	ldr	r3, [r3, #0x10]
 8006a30: 7f1b         	ldrb	r3, [r3, #0x1c]
 8006a32: f3c3 1301    	ubfx	r3, r3, #0x4, #0x2
 8006a36: b2db         	uxtb	r3, r3
 8006a38: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
; 		periph_addr_adj = config->head_block->source_addr_adj;
 8006a3c: 687b         	ldr	r3, [r7, #0x4]
 8006a3e: 691b         	ldr	r3, [r3, #0x10]
 8006a40: 7f1b         	ldrb	r3, [r3, #0x1c]
 8006a42: f3c3 0381    	ubfx	r3, r3, #0x2, #0x2
 8006a46: b2db         	uxtb	r3, r3
 8006a48: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 		break;
 8006a4c: e036         	b	0x8006abc <dma_stm32_configure+0x574> @ imm = #0x6c
; 		memory_addr_adj = config->head_block->source_addr_adj;
 8006a4e: 687b         	ldr	r3, [r7, #0x4]
 8006a50: 691b         	ldr	r3, [r3, #0x10]
 8006a52: 7f1b         	ldrb	r3, [r3, #0x1c]
 8006a54: f3c3 0381    	ubfx	r3, r3, #0x2, #0x2
 8006a58: b2db         	uxtb	r3, r3
 8006a5a: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
; 		periph_addr_adj = config->head_block->dest_addr_adj;
 8006a5e: 687b         	ldr	r3, [r7, #0x4]
 8006a60: 691b         	ldr	r3, [r3, #0x10]
 8006a62: 7f1b         	ldrb	r3, [r3, #0x1c]
 8006a64: f3c3 1301    	ubfx	r3, r3, #0x4, #0x2
 8006a68: b2db         	uxtb	r3, r3
 8006a6a: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 		break;
 8006a6e: e025         	b	0x8006abc <dma_stm32_configure+0x574> @ imm = #0x4a
; 		LOG_ERR("Channel direction error (%d).",
 8006a70: 2303         	movs	r3, #0x3
 8006a72: 2b00         	cmp	r3, #0x0
 8006a74: d01f         	beq	0x8006ab6 <dma_stm32_configure+0x56e> @ imm = #0x3e
 8006a76: 2301         	movs	r3, #0x1
 8006a78: f887 308b    	strb.w	r3, [r7, #0x8b]
 8006a7c: f897 308b    	ldrb.w	r3, [r7, #0x8b]
 8006a80: f083 0301    	eor	r3, r3, #0x1
 8006a84: b2db         	uxtb	r3, r3
 8006a86: 2b00         	cmp	r3, #0x0
 8006a88: d115         	bne	0x8006ab6 <dma_stm32_configure+0x56e> @ imm = #0x2a
 8006a8a: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8006ae4 <dma_stm32_configure+0x59c>
 8006a8c: 6819         	ldr	r1, [r3]
 8006a8e: 687b         	ldr	r3, [r7, #0x4]
 8006a90: 785b         	ldrb	r3, [r3, #0x1]
 8006a92: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 8006a96: b2db         	uxtb	r3, r3
 8006a98: 9303         	str	r3, [sp, #0xc]
 8006a9a: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8006af4 <dma_stm32_configure+0x5ac>
 8006a9c: 9302         	str	r3, [sp, #0x8]
 8006a9e: 2300         	movs	r3, #0x0
 8006aa0: 9301         	str	r3, [sp, #0x4]
 8006aa2: 2300         	movs	r3, #0x0
 8006aa4: 9300         	str	r3, [sp]
 8006aa6: 2300         	movs	r3, #0x0
 8006aa8: 2201         	movs	r2, #0x1
 8006aaa: 2000         	movs	r0, #0x0
 8006aac: f00d f8c2    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd184
 8006ab0: 2300         	movs	r3, #0x0
 8006ab2: f8c7 3084    	str.w	r3, [r7, #0x84]
; 		return -EINVAL;
 8006ab6: f06f 0315    	mvn	r3, #0x15
 8006aba: e1ab         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x356
; 	ret = dma_stm32_get_memory_increment(memory_addr_adj,
 8006abc: f8b7 30c6    	ldrh.w	r3, [r7, #0xc6]
 8006ac0: b2da         	uxtb	r2, r3
 8006ac2: f107 0310    	add.w	r3, r7, #0x10
 8006ac6: 3314         	adds	r3, #0x14
 8006ac8: 4619         	mov	r1, r3
 8006aca: 4610         	mov	r0, r2
 8006acc: f7ff fcb4    	bl	0x8006438 <dma_stm32_get_memory_increment> @ imm = #-0x698
 8006ad0: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8006ad4: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006ad8: 2b00         	cmp	r3, #0x0
 8006ada: da0d         	bge	0x8006af8 <dma_stm32_configure+0x5b0> @ imm = #0x1a
; 		return ret;
 8006adc: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006ae0: e198         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x330
 8006ae2: bf00         	nop

08006ae4 <$d>:
 8006ae4: 58 04 00 20  	.word	0x20000458
 8006ae8: c0 c0 01 08  	.word	0x0801c0c0
 8006aec: f8 c0 01 08  	.word	0x0801c0f8
 8006af0: 18 c1 01 08  	.word	0x0801c118
 8006af4: 38 c1 01 08  	.word	0x0801c138

08006af8 <$t>:
; 	LOG_DBG("Channel (%d) memory inc (%x).",
 8006af8: 2303         	movs	r3, #0x3
 8006afa: 2b03         	cmp	r3, #0x3
 8006afc: d91f         	bls	0x8006b3e <dma_stm32_configure+0x5f6> @ imm = #0x3e
 8006afe: 2301         	movs	r3, #0x1
 8006b00: f887 30af    	strb.w	r3, [r7, #0xaf]
 8006b04: f897 30af    	ldrb.w	r3, [r7, #0xaf]
 8006b08: f083 0301    	eor	r3, r3, #0x1
 8006b0c: b2db         	uxtb	r3, r3
 8006b0e: 2b00         	cmp	r3, #0x0
 8006b10: d115         	bne	0x8006b3e <dma_stm32_configure+0x5f6> @ imm = #0x2a
 8006b12: 4bae         	ldr	r3, [pc, #0x2b8]        @ 0x8006dcc <dma_stm32_configure+0x884>
 8006b14: 6819         	ldr	r1, [r3]
 8006b16: 6a7b         	ldr	r3, [r7, #0x24]
 8006b18: 9305         	str	r3, [sp, #0x14]
 8006b1a: 68bb         	ldr	r3, [r7, #0x8]
 8006b1c: 9304         	str	r3, [sp, #0x10]
 8006b1e: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8006dd0 <dma_stm32_configure+0x888>
 8006b20: 9303         	str	r3, [sp, #0xc]
 8006b22: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8006dd4 <dma_stm32_configure+0x88c>
 8006b24: 9302         	str	r3, [sp, #0x8]
 8006b26: 2308         	movs	r3, #0x8
 8006b28: 9301         	str	r3, [sp, #0x4]
 8006b2a: 2300         	movs	r3, #0x0
 8006b2c: 9300         	str	r3, [sp]
 8006b2e: 2300         	movs	r3, #0x0
 8006b30: 2204         	movs	r2, #0x4
 8006b32: 2000         	movs	r0, #0x0
 8006b34: f00d f87e    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd0fc
 8006b38: 2300         	movs	r3, #0x0
 8006b3a: f8c7 30a8    	str.w	r3, [r7, #0xa8]
; 	ret = dma_stm32_get_periph_increment(periph_addr_adj,
 8006b3e: f8b7 30c4    	ldrh.w	r3, [r7, #0xc4]
 8006b42: b2da         	uxtb	r2, r3
 8006b44: f107 0310    	add.w	r3, r7, #0x10
 8006b48: 3310         	adds	r3, #0x10
 8006b4a: 4619         	mov	r1, r3
 8006b4c: 4610         	mov	r0, r2
 8006b4e: f7ff fcb7    	bl	0x80064c0 <dma_stm32_get_periph_increment> @ imm = #-0x692
 8006b52: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8006b56: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006b5a: 2b00         	cmp	r3, #0x0
 8006b5c: da02         	bge	0x8006b64 <dma_stm32_configure+0x61c> @ imm = #0x4
; 		return ret;
 8006b5e: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006b62: e157         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x2ae
; 	LOG_DBG("Channel (%d) peripheral inc (%x).",
 8006b64: 2303         	movs	r3, #0x3
 8006b66: 2b03         	cmp	r3, #0x3
 8006b68: d91f         	bls	0x8006baa <dma_stm32_configure+0x662> @ imm = #0x3e
 8006b6a: 2301         	movs	r3, #0x1
 8006b6c: f887 30a7    	strb.w	r3, [r7, #0xa7]
 8006b70: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 8006b74: f083 0301    	eor	r3, r3, #0x1
 8006b78: b2db         	uxtb	r3, r3
 8006b7a: 2b00         	cmp	r3, #0x0
 8006b7c: d115         	bne	0x8006baa <dma_stm32_configure+0x662> @ imm = #0x2a
 8006b7e: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8006dcc <dma_stm32_configure+0x884>
 8006b80: 6819         	ldr	r1, [r3]
 8006b82: 6a3b         	ldr	r3, [r7, #0x20]
 8006b84: 9305         	str	r3, [sp, #0x14]
 8006b86: 68bb         	ldr	r3, [r7, #0x8]
 8006b88: 9304         	str	r3, [sp, #0x10]
 8006b8a: 4b91         	ldr	r3, [pc, #0x244]        @ 0x8006dd0 <dma_stm32_configure+0x888>
 8006b8c: 9303         	str	r3, [sp, #0xc]
 8006b8e: 4b92         	ldr	r3, [pc, #0x248]        @ 0x8006dd8 <dma_stm32_configure+0x890>
 8006b90: 9302         	str	r3, [sp, #0x8]
 8006b92: 2308         	movs	r3, #0x8
 8006b94: 9301         	str	r3, [sp, #0x4]
 8006b96: 2300         	movs	r3, #0x0
 8006b98: 9300         	str	r3, [sp]
 8006b9a: 2300         	movs	r3, #0x0
 8006b9c: 2204         	movs	r2, #0x4
 8006b9e: 2000         	movs	r0, #0x0
 8006ba0: f00d f848    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xd090
 8006ba4: 2300         	movs	r3, #0x0
 8006ba6: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; 	if (stream->cyclic) {
 8006baa: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006bae: 7e1b         	ldrb	r3, [r3, #0x18]
 8006bb0: 2b00         	cmp	r3, #0x0
 8006bb2: d003         	beq	0x8006bbc <dma_stm32_configure+0x674> @ imm = #0x6
; 		DMA_InitStruct.Mode = LL_DMA_MODE_CIRCULAR;
 8006bb4: f44f 7380    	mov.w	r3, #0x100
 8006bb8: 61fb         	str	r3, [r7, #0x1c]
 8006bba: e001         	b	0x8006bc0 <dma_stm32_configure+0x678> @ imm = #0x2
; 		DMA_InitStruct.Mode = LL_DMA_MODE_NORMAL;
 8006bbc: 2300         	movs	r3, #0x0
 8006bbe: 61fb         	str	r3, [r7, #0x1c]
; 	stream->source_periph = (stream->direction == PERIPHERAL_TO_MEMORY);
 8006bc0: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006bc4: 681b         	ldr	r3, [r3]
 8006bc6: 2b02         	cmp	r3, #0x2
 8006bc8: bf0c         	ite	eq
 8006bca: 2301         	moveq	r3, #0x1
 8006bcc: 2300         	movne	r3, #0x0
 8006bce: b2da         	uxtb	r2, r3
 8006bd0: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006bd4: 711a         	strb	r2, [r3, #0x4]
; 	int index = find_lsb_set(config->source_data_size) - 1;
 8006bd6: 687b         	ldr	r3, [r7, #0x4]
 8006bd8: 889b         	ldrh	r3, [r3, #0x4]
 8006bda: 64fb         	str	r3, [r7, #0x4c]
; 	return __builtin_ffs(op);
 8006bdc: 6cfb         	ldr	r3, [r7, #0x4c]
 8006bde: fa93 f2a3    	rbit	r2, r3
 8006be2: fab2 f282    	clz	r2, r2
 8006be6: 2b00         	cmp	r3, #0x0
 8006be8: d101         	bne	0x8006bee <dma_stm32_configure+0x6a6> @ imm = #0x2
 8006bea: f04f 32ff    	mov.w	r2, #0xffffffff
 8006bee: 1c53         	adds	r3, r2, #0x1
; 	int index = find_lsb_set(config->source_data_size) - 1;
 8006bf0: 3b01         	subs	r3, #0x1
 8006bf2: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	DMA_InitStruct.PeriphOrM2MSrcDataSize = table_p_size[index];
 8006bf6: 4a79         	ldr	r2, [pc, #0x1e4]        @ 0x8006ddc <dma_stm32_configure+0x894>
 8006bf8: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 8006bfc: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8006c00: 62bb         	str	r3, [r7, #0x28]
; 	index = find_lsb_set(config->dest_data_size) - 1;
 8006c02: 687b         	ldr	r3, [r7, #0x4]
 8006c04: 88db         	ldrh	r3, [r3, #0x6]
 8006c06: 653b         	str	r3, [r7, #0x50]
; 	return __builtin_ffs(op);
 8006c08: 6d3b         	ldr	r3, [r7, #0x50]
 8006c0a: fa93 f2a3    	rbit	r2, r3
 8006c0e: fab2 f282    	clz	r2, r2
 8006c12: 2b00         	cmp	r3, #0x0
 8006c14: d101         	bne	0x8006c1a <dma_stm32_configure+0x6d2> @ imm = #0x2
 8006c16: f04f 32ff    	mov.w	r2, #0xffffffff
 8006c1a: 1c53         	adds	r3, r2, #0x1
; 	index = find_lsb_set(config->dest_data_size) - 1;
 8006c1c: 3b01         	subs	r3, #0x1
 8006c1e: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	DMA_InitStruct.MemoryOrM2MDstDataSize = table_m_size[index];
 8006c22: 4a6f         	ldr	r2, [pc, #0x1bc]        @ 0x8006de0 <dma_stm32_configure+0x898>
 8006c24: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 8006c28: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8006c2c: 62fb         	str	r3, [r7, #0x2c]
; 	DMA_InitStruct.MemBurst = stm32_dma_get_mburst(config,
 8006c2e: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006c32: 791b         	ldrb	r3, [r3, #0x4]
 8006c34: 4619         	mov	r1, r3
 8006c36: 6878         	ldr	r0, [r7, #0x4]
 8006c38: f000 fbc4    	bl	0x80073c4 <stm32_dma_get_mburst> @ imm = #0x788
 8006c3c: 4603         	mov	r3, r0
 8006c3e: 647b         	str	r3, [r7, #0x44]
; 	DMA_InitStruct.PeriphBurst = stm32_dma_get_pburst(config,
 8006c40: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006c44: 791b         	ldrb	r3, [r3, #0x4]
 8006c46: 4619         	mov	r1, r3
 8006c48: 6878         	ldr	r0, [r7, #0x4]
 8006c4a: f000 fc21    	bl	0x8007490 <stm32_dma_get_pburst> @ imm = #0x842
 8006c4e: 4603         	mov	r3, r0
 8006c50: 64bb         	str	r3, [r7, #0x48]
; 	if (config->channel_direction != MEMORY_TO_MEMORY) {
 8006c52: 687b         	ldr	r3, [r7, #0x4]
 8006c54: 785b         	ldrb	r3, [r3, #0x1]
 8006c56: f003 0307    	and	r3, r3, #0x7
 8006c5a: b2db         	uxtb	r3, r3
 8006c5c: 2b00         	cmp	r3, #0x0
 8006c5e: d023         	beq	0x8006ca8 <dma_stm32_configure+0x760> @ imm = #0x46
; 		if (config->dma_slot >= 8) {
 8006c60: 687b         	ldr	r3, [r7, #0x4]
 8006c62: 781b         	ldrb	r3, [r3]
 8006c64: 2b07         	cmp	r3, #0x7
 8006c66: d943         	bls	0x8006cf0 <dma_stm32_configure+0x7a8> @ imm = #0x86
; 			LOG_ERR("dma slot error.");
 8006c68: 2303         	movs	r3, #0x3
 8006c6a: 2b00         	cmp	r3, #0x0
 8006c6c: d019         	beq	0x8006ca2 <dma_stm32_configure+0x75a> @ imm = #0x32
 8006c6e: 2301         	movs	r3, #0x1
 8006c70: f887 3093    	strb.w	r3, [r7, #0x93]
 8006c74: f897 3093    	ldrb.w	r3, [r7, #0x93]
 8006c78: f083 0301    	eor	r3, r3, #0x1
 8006c7c: b2db         	uxtb	r3, r3
 8006c7e: 2b00         	cmp	r3, #0x0
 8006c80: d10f         	bne	0x8006ca2 <dma_stm32_configure+0x75a> @ imm = #0x1e
 8006c82: 4b52         	ldr	r3, [pc, #0x148]        @ 0x8006dcc <dma_stm32_configure+0x884>
 8006c84: 6819         	ldr	r1, [r3]
 8006c86: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8006de4 <dma_stm32_configure+0x89c>
 8006c88: 9302         	str	r3, [sp, #0x8]
 8006c8a: 2300         	movs	r3, #0x0
 8006c8c: 9301         	str	r3, [sp, #0x4]
 8006c8e: 2300         	movs	r3, #0x0
 8006c90: 9300         	str	r3, [sp]
 8006c92: 2300         	movs	r3, #0x0
 8006c94: 2201         	movs	r2, #0x1
 8006c96: 2000         	movs	r0, #0x0
 8006c98: f00c ffcc    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xcf98
 8006c9c: 2300         	movs	r3, #0x0
 8006c9e: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 			return -EINVAL;
 8006ca2: f06f 0315    	mvn	r3, #0x15
 8006ca6: e0b5         	b	0x8006e14 <dma_stm32_configure+0x8cc> @ imm = #0x16a
; 		if (config->dma_slot >= 8) {
 8006ca8: 687b         	ldr	r3, [r7, #0x4]
 8006caa: 781b         	ldrb	r3, [r3]
 8006cac: 2b07         	cmp	r3, #0x7
 8006cae: d91f         	bls	0x8006cf0 <dma_stm32_configure+0x7a8> @ imm = #0x3e
; 			LOG_ERR("dma slot is too big, using 0 as default.");
 8006cb0: 2303         	movs	r3, #0x3
 8006cb2: 2b00         	cmp	r3, #0x0
 8006cb4: d019         	beq	0x8006cea <dma_stm32_configure+0x7a2> @ imm = #0x32
 8006cb6: 2301         	movs	r3, #0x1
 8006cb8: f887 309b    	strb.w	r3, [r7, #0x9b]
 8006cbc: f897 309b    	ldrb.w	r3, [r7, #0x9b]
 8006cc0: f083 0301    	eor	r3, r3, #0x1
 8006cc4: b2db         	uxtb	r3, r3
 8006cc6: 2b00         	cmp	r3, #0x0
 8006cc8: d10f         	bne	0x8006cea <dma_stm32_configure+0x7a2> @ imm = #0x1e
 8006cca: 4b40         	ldr	r3, [pc, #0x100]        @ 0x8006dcc <dma_stm32_configure+0x884>
 8006ccc: 6819         	ldr	r1, [r3]
 8006cce: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8006de8 <dma_stm32_configure+0x8a0>
 8006cd0: 9302         	str	r3, [sp, #0x8]
 8006cd2: 2300         	movs	r3, #0x0
 8006cd4: 9301         	str	r3, [sp, #0x4]
 8006cd6: 2300         	movs	r3, #0x0
 8006cd8: 9300         	str	r3, [sp]
 8006cda: 2300         	movs	r3, #0x0
 8006cdc: 2201         	movs	r2, #0x1
 8006cde: 2000         	movs	r0, #0x0
 8006ce0: f00c ffa8    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xcf50
 8006ce4: 2300         	movs	r3, #0x0
 8006ce6: f8c7 3094    	str.w	r3, [r7, #0x94]
; 			config->dma_slot = 0;
 8006cea: 687b         	ldr	r3, [r7, #0x4]
 8006cec: 2200         	movs	r2, #0x0
 8006cee: 701a         	strb	r2, [r3]
; 	DMA_InitStruct.Channel = dma_stm32_slot_to_channel(config->dma_slot);
 8006cf0: 687b         	ldr	r3, [r7, #0x4]
 8006cf2: 781b         	ldrb	r3, [r3]
 8006cf4: 4618         	mov	r0, r3
 8006cf6: f000 f9f1    	bl	0x80070dc <dma_stm32_slot_to_channel> @ imm = #0x3e2
 8006cfa: 4603         	mov	r3, r0
 8006cfc: 637b         	str	r3, [r7, #0x34]
; 					config->head_block->fifo_mode_control);
 8006cfe: 687b         	ldr	r3, [r7, #0x4]
 8006d00: 691b         	ldr	r3, [r3, #0x10]
 8006d02: 7f5b         	ldrb	r3, [r3, #0x1d]
 8006d04: f3c3 0303    	ubfx	r3, r3, #0x0, #0x4
 8006d08: b2db         	uxtb	r3, r3
; 	DMA_InitStruct.FIFOThreshold = stm32_dma_get_fifo_threshold(
 8006d0a: 4618         	mov	r0, r3
 8006d0c: f000 fc26    	bl	0x800755c <stm32_dma_get_fifo_threshold> @ imm = #0x84c
 8006d10: 4603         	mov	r3, r0
 8006d12: 643b         	str	r3, [r7, #0x40]
; 	if (stm32_dma_check_fifo_mburst(&DMA_InitStruct)) {
 8006d14: f107 0310    	add.w	r3, r7, #0x10
 8006d18: 4618         	mov	r0, r3
 8006d1a: f00e f832    	bl	0x8014d82 <stm32_dma_check_fifo_mburst> @ imm = #0xe064
 8006d1e: 4603         	mov	r3, r0
 8006d20: 2b00         	cmp	r3, #0x0
 8006d22: d002         	beq	0x8006d2a <dma_stm32_configure+0x7e2> @ imm = #0x4
; 		DMA_InitStruct.FIFOMode = LL_DMA_FIFOMODE_ENABLE;
 8006d24: 2304         	movs	r3, #0x4
 8006d26: 63fb         	str	r3, [r7, #0x3c]
 8006d28: e001         	b	0x8006d2e <dma_stm32_configure+0x7e6> @ imm = #0x2
; 		DMA_InitStruct.FIFOMode = LL_DMA_FIFOMODE_DISABLE;
 8006d2a: 2300         	movs	r3, #0x0
 8006d2c: 63fb         	str	r3, [r7, #0x3c]
; 	if (stream->source_periph) {
 8006d2e: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006d32: 791b         	ldrb	r3, [r3, #0x4]
 8006d34: 2b00         	cmp	r3, #0x0
 8006d36: d008         	beq	0x8006d4a <dma_stm32_configure+0x802> @ imm = #0x10
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 8006d38: 687b         	ldr	r3, [r7, #0x4]
 8006d3a: 691b         	ldr	r3, [r3, #0x10]
 8006d3c: 695b         	ldr	r3, [r3, #0x14]
; 					config->source_data_size;
 8006d3e: 687a         	ldr	r2, [r7, #0x4]
 8006d40: 8892         	ldrh	r2, [r2, #0x4]
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 8006d42: fbb3 f3f2    	udiv	r3, r3, r2
 8006d46: 633b         	str	r3, [r7, #0x30]
 8006d48: e007         	b	0x8006d5a <dma_stm32_configure+0x812> @ imm = #0xe
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 8006d4a: 687b         	ldr	r3, [r7, #0x4]
 8006d4c: 691b         	ldr	r3, [r3, #0x10]
 8006d4e: 695b         	ldr	r3, [r3, #0x14]
; 					config->dest_data_size;
 8006d50: 687a         	ldr	r2, [r7, #0x4]
 8006d52: 88d2         	ldrh	r2, [r2, #0x6]
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 8006d54: fbb3 f3f2    	udiv	r3, r3, r2
 8006d58: 633b         	str	r3, [r7, #0x30]
; 	LL_DMA_Init(dma, dma_stm32_id_to_stream(id), &DMA_InitStruct);
 8006d5a: 68b8         	ldr	r0, [r7, #0x8]
 8006d5c: f000 f9ae    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #0x35c
 8006d60: 4601         	mov	r1, r0
 8006d62: f107 0310    	add.w	r3, r7, #0x10
 8006d66: 461a         	mov	r2, r3
 8006d68: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8006d6c: f011 fc9d    	bl	0x80186aa <LL_DMA_Init> @ imm = #0x1193a
; 	LL_DMA_EnableIT_TC(dma, dma_stm32_id_to_stream(id));
 8006d70: 68b8         	ldr	r0, [r7, #0x8]
 8006d72: f000 f9a3    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #0x346
 8006d76: 4603         	mov	r3, r0
 8006d78: 4619         	mov	r1, r3
 8006d7a: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8006d7e: f7ff f983    	bl	0x8006088 <LL_DMA_EnableIT_TC> @ imm = #-0xcfa
; 	if (stream->cyclic) {
 8006d82: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006d86: 7e1b         	ldrb	r3, [r3, #0x18]
 8006d88: 2b00         	cmp	r3, #0x0
 8006d8a: d008         	beq	0x8006d9e <dma_stm32_configure+0x856> @ imm = #0x10
; 		LL_DMA_EnableIT_HT(dma, dma_stm32_id_to_stream(id));
 8006d8c: 68b8         	ldr	r0, [r7, #0x8]
 8006d8e: f000 f995    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #0x32a
 8006d92: 4603         	mov	r3, r0
 8006d94: 4619         	mov	r1, r3
 8006d96: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8006d9a: f7ff f957    	bl	0x800604c <LL_DMA_EnableIT_HT> @ imm = #-0xd52
; 	if (DMA_InitStruct.FIFOMode == LL_DMA_FIFOMODE_ENABLE) {
 8006d9e: 6bfb         	ldr	r3, [r7, #0x3c]
 8006da0: 2b04         	cmp	r3, #0x4
 8006da2: d123         	bne	0x8006dec <dma_stm32_configure+0x8a4> @ imm = #0x46
; 		LL_DMA_EnableFifoMode(dma, dma_stm32_id_to_stream(id));
 8006da4: 68b8         	ldr	r0, [r7, #0x8]
 8006da6: f000 f989    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #0x312
 8006daa: 4603         	mov	r3, r0
 8006dac: 4619         	mov	r1, r3
 8006dae: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8006db2: f7ff f8fd    	bl	0x8005fb0 <LL_DMA_EnableFifoMode> @ imm = #-0xe06
; 		LL_DMA_EnableIT_FE(dma, dma_stm32_id_to_stream(id));
 8006db6: 68b8         	ldr	r0, [r7, #0x8]
 8006db8: f000 f980    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #0x300
 8006dbc: 4603         	mov	r3, r0
 8006dbe: 4619         	mov	r1, r3
 8006dc0: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8006dc4: f7ff f97e    	bl	0x80060c4 <LL_DMA_EnableIT_FE> @ imm = #-0xd04
 8006dc8: e022         	b	0x8006e10 <dma_stm32_configure+0x8c8> @ imm = #0x44
 8006dca: bf00         	nop

08006dcc <$d>:
 8006dcc: 58 04 00 20  	.word	0x20000458
 8006dd0: 40 d2 01 08  	.word	0x0801d240
 8006dd4: 58 c1 01 08  	.word	0x0801c158
 8006dd8: 7c c1 01 08  	.word	0x0801c17c
 8006ddc: d4 d1 01 08  	.word	0x0801d1d4
 8006de0: c8 d1 01 08  	.word	0x0801d1c8
 8006de4: a4 c1 01 08  	.word	0x0801c1a4
 8006de8: b4 c1 01 08  	.word	0x0801c1b4

08006dec <$t>:
; 		LL_DMA_DisableFifoMode(dma, dma_stm32_id_to_stream(id));
 8006dec: 68b8         	ldr	r0, [r7, #0x8]
 8006dee: f000 f965    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #0x2ca
 8006df2: 4603         	mov	r3, r0
 8006df4: 4619         	mov	r1, r3
 8006df6: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8006dfa: f7ff f8bb    	bl	0x8005f74 <LL_DMA_DisableFifoMode> @ imm = #-0xe8a
; 		LL_DMA_DisableIT_FE(dma, dma_stm32_id_to_stream(id));
 8006dfe: 68b8         	ldr	r0, [r7, #0x8]
 8006e00: f000 f95c    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #0x2b8
 8006e04: 4603         	mov	r3, r0
 8006e06: 4619         	mov	r1, r3
 8006e08: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8006e0c: f7ff f996    	bl	0x800613c <LL_DMA_DisableIT_FE> @ imm = #-0xcd4
; 	return ret;
 8006e10: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
; }
 8006e14: 4618         	mov	r0, r3
 8006e16: 37e0         	adds	r7, #0xe0
 8006e18: 46bd         	mov	sp, r7
 8006e1a: bd80         	pop	{r7, pc}

08006e1c <dma_stm32_init>:
; {
 8006e1c: b580         	push	{r7, lr}
 8006e1e: b08e         	sub	sp, #0x38
 8006e20: af04         	add	r7, sp, #0x10
 8006e22: 6078         	str	r0, [r7, #0x4]
; 	const struct dma_stm32_config *config = dev->config;
 8006e24: 687b         	ldr	r3, [r7, #0x4]
 8006e26: 685b         	ldr	r3, [r3, #0x4]
 8006e28: 623b         	str	r3, [r7, #0x20]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8006e2a: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8006f18 <dma_stm32_init+0xfc>
 8006e2c: 61fb         	str	r3, [r7, #0x1c]
; 	if (!device_is_ready(clk)) {
 8006e2e: 69f8         	ldr	r0, [r7, #0x1c]
 8006e30: f00c fed4    	bl	0x8013bdc <device_is_ready> @ imm = #0xcda8
 8006e34: 4603         	mov	r3, r0
 8006e36: f083 0301    	eor	r3, r3, #0x1
 8006e3a: b2db         	uxtb	r3, r3
 8006e3c: 2b00         	cmp	r3, #0x0
 8006e3e: d01c         	beq	0x8006e7a <dma_stm32_init+0x5e> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 8006e40: 2303         	movs	r3, #0x3
 8006e42: 2b00         	cmp	r3, #0x0
 8006e44: d016         	beq	0x8006e74 <dma_stm32_init+0x58> @ imm = #0x2c
 8006e46: 2301         	movs	r3, #0x1
 8006e48: 74fb         	strb	r3, [r7, #0x13]
 8006e4a: 7cfb         	ldrb	r3, [r7, #0x13]
 8006e4c: f083 0301    	eor	r3, r3, #0x1
 8006e50: b2db         	uxtb	r3, r3
 8006e52: 2b00         	cmp	r3, #0x0
 8006e54: d10e         	bne	0x8006e74 <dma_stm32_init+0x58> @ imm = #0x1c
 8006e56: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8006f1c <dma_stm32_init+0x100>
 8006e58: 6819         	ldr	r1, [r3]
 8006e5a: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8006f20 <dma_stm32_init+0x104>
 8006e5c: 9302         	str	r3, [sp, #0x8]
 8006e5e: 2300         	movs	r3, #0x0
 8006e60: 9301         	str	r3, [sp, #0x4]
 8006e62: 2300         	movs	r3, #0x0
 8006e64: 9300         	str	r3, [sp]
 8006e66: 2300         	movs	r3, #0x0
 8006e68: 2201         	movs	r2, #0x1
 8006e6a: 2000         	movs	r0, #0x0
 8006e6c: f00c fee2    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xcdc4
 8006e70: 2300         	movs	r3, #0x0
 8006e72: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 8006e74: f06f 0312    	mvn	r3, #0x12
 8006e78: e04a         	b	0x8006f10 <dma_stm32_init+0xf4> @ imm = #0x94
; 		(clock_control_subsys_t) &config->pclken) != 0) {
 8006e7a: 6a3b         	ldr	r3, [r7, #0x20]
; 	if (clock_control_on(clk,
 8006e7c: 4619         	mov	r1, r3
 8006e7e: 69f8         	ldr	r0, [r7, #0x1c]
 8006e80: f00c fec6    	bl	0x8013c10 <clock_control_on> @ imm = #0xcd8c
 8006e84: 4603         	mov	r3, r0
 8006e86: 2b00         	cmp	r3, #0x0
 8006e88: d01c         	beq	0x8006ec4 <dma_stm32_init+0xa8> @ imm = #0x38
; 		LOG_ERR("clock op failed\n");
 8006e8a: 2303         	movs	r3, #0x3
 8006e8c: 2b00         	cmp	r3, #0x0
 8006e8e: d016         	beq	0x8006ebe <dma_stm32_init+0xa2> @ imm = #0x2c
 8006e90: 2301         	movs	r3, #0x1
 8006e92: 76fb         	strb	r3, [r7, #0x1b]
 8006e94: 7efb         	ldrb	r3, [r7, #0x1b]
 8006e96: f083 0301    	eor	r3, r3, #0x1
 8006e9a: b2db         	uxtb	r3, r3
 8006e9c: 2b00         	cmp	r3, #0x0
 8006e9e: d10e         	bne	0x8006ebe <dma_stm32_init+0xa2> @ imm = #0x1c
 8006ea0: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8006f1c <dma_stm32_init+0x100>
 8006ea2: 6819         	ldr	r1, [r3]
 8006ea4: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8006f24 <dma_stm32_init+0x108>
 8006ea6: 9302         	str	r3, [sp, #0x8]
 8006ea8: 2300         	movs	r3, #0x0
 8006eaa: 9301         	str	r3, [sp, #0x4]
 8006eac: 2300         	movs	r3, #0x0
 8006eae: 9300         	str	r3, [sp]
 8006eb0: 2300         	movs	r3, #0x0
 8006eb2: 2201         	movs	r2, #0x1
 8006eb4: 2000         	movs	r0, #0x0
 8006eb6: f00c febd    	bl	0x8013c34 <z_log_msg_runtime_create> @ imm = #0xcd7a
 8006eba: 2300         	movs	r3, #0x0
 8006ebc: 617b         	str	r3, [r7, #0x14]
; 		return -EIO;
 8006ebe: f06f 0304    	mvn	r3, #0x4
 8006ec2: e025         	b	0x8006f10 <dma_stm32_init+0xf4> @ imm = #0x4a
; 	config->config_irq(dev);
 8006ec4: 6a3b         	ldr	r3, [r7, #0x20]
 8006ec6: 689b         	ldr	r3, [r3, #0x8]
 8006ec8: 6878         	ldr	r0, [r7, #0x4]
 8006eca: 4798         	blx	r3
; 	for (uint32_t i = 0; i < config->max_streams; i++) {
 8006ecc: 2300         	movs	r3, #0x0
 8006ece: 627b         	str	r3, [r7, #0x24]
 8006ed0: e00c         	b	0x8006eec <dma_stm32_init+0xd0> @ imm = #0x18
; 		config->streams[i].busy = false;
 8006ed2: 6a3b         	ldr	r3, [r7, #0x20]
 8006ed4: 6999         	ldr	r1, [r3, #0x18]
 8006ed6: 6a7a         	ldr	r2, [r7, #0x24]
 8006ed8: 4613         	mov	r3, r2
 8006eda: 00db         	lsls	r3, r3, #0x3
 8006edc: 1a9b         	subs	r3, r3, r2
 8006ede: 009b         	lsls	r3, r3, #0x2
 8006ee0: 440b         	add	r3, r1
 8006ee2: 2200         	movs	r2, #0x0
 8006ee4: 719a         	strb	r2, [r3, #0x6]
; 	for (uint32_t i = 0; i < config->max_streams; i++) {
 8006ee6: 6a7b         	ldr	r3, [r7, #0x24]
 8006ee8: 3301         	adds	r3, #0x1
 8006eea: 627b         	str	r3, [r7, #0x24]
 8006eec: 6a3b         	ldr	r3, [r7, #0x20]
 8006eee: 695b         	ldr	r3, [r3, #0x14]
 8006ef0: 6a7a         	ldr	r2, [r7, #0x24]
 8006ef2: 429a         	cmp	r2, r3
 8006ef4: d3ed         	blo	0x8006ed2 <dma_stm32_init+0xb6> @ imm = #-0x26
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.magic = 0;
 8006ef6: 687b         	ldr	r3, [r7, #0x4]
 8006ef8: 691b         	ldr	r3, [r3, #0x10]
 8006efa: 2200         	movs	r2, #0x0
 8006efc: 601a         	str	r2, [r3]
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.dma_channels = 0;
 8006efe: 687b         	ldr	r3, [r7, #0x4]
 8006f00: 691b         	ldr	r3, [r3, #0x10]
 8006f02: 2200         	movs	r2, #0x0
 8006f04: 605a         	str	r2, [r3, #0x4]
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.atomic = 0;
 8006f06: 687b         	ldr	r3, [r7, #0x4]
 8006f08: 691b         	ldr	r3, [r3, #0x10]
 8006f0a: 2200         	movs	r2, #0x0
 8006f0c: 609a         	str	r2, [r3, #0x8]
; 	return 0;
 8006f0e: 2300         	movs	r3, #0x0
; }
 8006f10: 4618         	mov	r0, r3
 8006f12: 3728         	adds	r7, #0x28
 8006f14: 46bd         	mov	sp, r7
 8006f16: bd80         	pop	{r7, pc}

08006f18 <$d>:
 8006f18: d8 ac 01 08  	.word	0x0801acd8
 8006f1c: 58 04 00 20  	.word	0x20000458
 8006f20: e0 c1 01 08  	.word	0x0801c1e0
 8006f24: 00 c2 01 08  	.word	0x0801c200

08006f28 <LL_DMA_EnableStream>:
; {
 8006f28: b480         	push	{r7}
 8006f2a: b083         	sub	sp, #0xc
 8006f2c: af00         	add	r7, sp, #0x0
 8006f2e: 6078         	str	r0, [r7, #0x4]
 8006f30: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN);
 8006f32: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006f60 <LL_DMA_EnableStream+0x38>
 8006f34: 683b         	ldr	r3, [r7]
 8006f36: 4413         	add	r3, r2
 8006f38: 781b         	ldrb	r3, [r3]
 8006f3a: 461a         	mov	r2, r3
 8006f3c: 687b         	ldr	r3, [r7, #0x4]
 8006f3e: 4413         	add	r3, r2
 8006f40: 681b         	ldr	r3, [r3]
 8006f42: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006f60 <LL_DMA_EnableStream+0x38>
 8006f44: 683a         	ldr	r2, [r7]
 8006f46: 440a         	add	r2, r1
 8006f48: 7812         	ldrb	r2, [r2]
 8006f4a: 4611         	mov	r1, r2
 8006f4c: 687a         	ldr	r2, [r7, #0x4]
 8006f4e: 440a         	add	r2, r1
 8006f50: f043 0301    	orr	r3, r3, #0x1
 8006f54: 6013         	str	r3, [r2]
; }
 8006f56: bf00         	nop
 8006f58: 370c         	adds	r7, #0xc
 8006f5a: 46bd         	mov	sp, r7
 8006f5c: bc80         	pop	{r7}
 8006f5e: 4770         	bx	lr

08006f60 <$d>:
 8006f60: 54 d2 01 08  	.word	0x0801d254

08006f64 <LL_DMA_DisableStream>:
; {
 8006f64: b480         	push	{r7}
 8006f66: b083         	sub	sp, #0xc
 8006f68: af00         	add	r7, sp, #0x0
 8006f6a: 6078         	str	r0, [r7, #0x4]
 8006f6c: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN);
 8006f6e: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006f9c <LL_DMA_DisableStream+0x38>
 8006f70: 683b         	ldr	r3, [r7]
 8006f72: 4413         	add	r3, r2
 8006f74: 781b         	ldrb	r3, [r3]
 8006f76: 461a         	mov	r2, r3
 8006f78: 687b         	ldr	r3, [r7, #0x4]
 8006f7a: 4413         	add	r3, r2
 8006f7c: 681b         	ldr	r3, [r3]
 8006f7e: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006f9c <LL_DMA_DisableStream+0x38>
 8006f80: 683a         	ldr	r2, [r7]
 8006f82: 440a         	add	r2, r1
 8006f84: 7812         	ldrb	r2, [r2]
 8006f86: 4611         	mov	r1, r2
 8006f88: 687a         	ldr	r2, [r7, #0x4]
 8006f8a: 440a         	add	r2, r1
 8006f8c: f023 0301    	bic	r3, r3, #0x1
 8006f90: 6013         	str	r3, [r2]
; }
 8006f92: bf00         	nop
 8006f94: 370c         	adds	r7, #0xc
 8006f96: 46bd         	mov	sp, r7
 8006f98: bc80         	pop	{r7}
 8006f9a: 4770         	bx	lr

08006f9c <$d>:
 8006f9c: 54 d2 01 08  	.word	0x0801d254

08006fa0 <LL_DMA_IsEnabledStream>:
; {
 8006fa0: b480         	push	{r7}
 8006fa2: b083         	sub	sp, #0xc
 8006fa4: af00         	add	r7, sp, #0x0
 8006fa6: 6078         	str	r0, [r7, #0x4]
 8006fa8: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN) == (DMA_SxCR_EN));
 8006faa: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8006fd4 <LL_DMA_IsEnabledStream+0x34>
 8006fac: 683b         	ldr	r3, [r7]
 8006fae: 4413         	add	r3, r2
 8006fb0: 781b         	ldrb	r3, [r3]
 8006fb2: 461a         	mov	r2, r3
 8006fb4: 687b         	ldr	r3, [r7, #0x4]
 8006fb6: 4413         	add	r3, r2
 8006fb8: 681b         	ldr	r3, [r3]
 8006fba: f003 0301    	and	r3, r3, #0x1
 8006fbe: 2b01         	cmp	r3, #0x1
 8006fc0: bf0c         	ite	eq
 8006fc2: 2301         	moveq	r3, #0x1
 8006fc4: 2300         	movne	r3, #0x0
 8006fc6: b2db         	uxtb	r3, r3
; }
 8006fc8: 4618         	mov	r0, r3
 8006fca: 370c         	adds	r7, #0xc
 8006fcc: 46bd         	mov	sp, r7
 8006fce: bc80         	pop	{r7}
 8006fd0: 4770         	bx	lr
 8006fd2: bf00         	nop

08006fd4 <$d>:
 8006fd4: 54 d2 01 08  	.word	0x0801d254

08006fd8 <LL_DMA_DisableIT_FE>:
; {
 8006fd8: b480         	push	{r7}
 8006fda: b083         	sub	sp, #0xc
 8006fdc: af00         	add	r7, sp, #0x0
 8006fde: 6078         	str	r0, [r7, #0x4]
 8006fe0: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 8006fe2: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8007010 <LL_DMA_DisableIT_FE+0x38>
 8006fe4: 683b         	ldr	r3, [r7]
 8006fe6: 4413         	add	r3, r2
 8006fe8: 781b         	ldrb	r3, [r3]
 8006fea: 461a         	mov	r2, r3
 8006fec: 687b         	ldr	r3, [r7, #0x4]
 8006fee: 4413         	add	r3, r2
 8006ff0: 695b         	ldr	r3, [r3, #0x14]
 8006ff2: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8007010 <LL_DMA_DisableIT_FE+0x38>
 8006ff4: 683a         	ldr	r2, [r7]
 8006ff6: 440a         	add	r2, r1
 8006ff8: 7812         	ldrb	r2, [r2]
 8006ffa: 4611         	mov	r1, r2
 8006ffc: 687a         	ldr	r2, [r7, #0x4]
 8006ffe: 440a         	add	r2, r1
 8007000: f023 0380    	bic	r3, r3, #0x80
 8007004: 6153         	str	r3, [r2, #0x14]
; }
 8007006: bf00         	nop
 8007008: 370c         	adds	r7, #0xc
 800700a: 46bd         	mov	sp, r7
 800700c: bc80         	pop	{r7}
 800700e: 4770         	bx	lr

08007010 <$d>:
 8007010: 54 d2 01 08  	.word	0x0801d254

08007014 <LL_DMA_IsEnabledIT_HT>:
; {
 8007014: b480         	push	{r7}
 8007016: b083         	sub	sp, #0xc
 8007018: af00         	add	r7, sp, #0x0
 800701a: 6078         	str	r0, [r7, #0x4]
 800701c: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_HTIE) == DMA_SxCR_HTIE);
 800701e: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007048 <LL_DMA_IsEnabledIT_HT+0x34>
 8007020: 683b         	ldr	r3, [r7]
 8007022: 4413         	add	r3, r2
 8007024: 781b         	ldrb	r3, [r3]
 8007026: 461a         	mov	r2, r3
 8007028: 687b         	ldr	r3, [r7, #0x4]
 800702a: 4413         	add	r3, r2
 800702c: 681b         	ldr	r3, [r3]
 800702e: f003 0308    	and	r3, r3, #0x8
 8007032: 2b08         	cmp	r3, #0x8
 8007034: bf0c         	ite	eq
 8007036: 2301         	moveq	r3, #0x1
 8007038: 2300         	movne	r3, #0x0
 800703a: b2db         	uxtb	r3, r3
; }
 800703c: 4618         	mov	r0, r3
 800703e: 370c         	adds	r7, #0xc
 8007040: 46bd         	mov	sp, r7
 8007042: bc80         	pop	{r7}
 8007044: 4770         	bx	lr
 8007046: bf00         	nop

08007048 <$d>:
 8007048: 54 d2 01 08  	.word	0x0801d254

0800704c <LL_DMA_IsEnabledIT_TC>:
; {
 800704c: b480         	push	{r7}
 800704e: b083         	sub	sp, #0xc
 8007050: af00         	add	r7, sp, #0x0
 8007052: 6078         	str	r0, [r7, #0x4]
 8007054: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE) == DMA_SxCR_TCIE);
 8007056: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007080 <LL_DMA_IsEnabledIT_TC+0x34>
 8007058: 683b         	ldr	r3, [r7]
 800705a: 4413         	add	r3, r2
 800705c: 781b         	ldrb	r3, [r3]
 800705e: 461a         	mov	r2, r3
 8007060: 687b         	ldr	r3, [r7, #0x4]
 8007062: 4413         	add	r3, r2
 8007064: 681b         	ldr	r3, [r3]
 8007066: f003 0310    	and	r3, r3, #0x10
 800706a: 2b10         	cmp	r3, #0x10
 800706c: bf0c         	ite	eq
 800706e: 2301         	moveq	r3, #0x1
 8007070: 2300         	movne	r3, #0x0
 8007072: b2db         	uxtb	r3, r3
; }
 8007074: 4618         	mov	r0, r3
 8007076: 370c         	adds	r7, #0xc
 8007078: 46bd         	mov	sp, r7
 800707a: bc80         	pop	{r7}
 800707c: 4770         	bx	lr
 800707e: bf00         	nop

08007080 <$d>:
 8007080: 54 d2 01 08  	.word	0x0801d254

08007084 <LL_DMA_IsEnabledIT_FE>:
; {
 8007084: b480         	push	{r7}
 8007086: b083         	sub	sp, #0xc
 8007088: af00         	add	r7, sp, #0x0
 800708a: 6078         	str	r0, [r7, #0x4]
 800708c: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE) == DMA_SxFCR_FEIE);
 800708e: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80070b8 <LL_DMA_IsEnabledIT_FE+0x34>
 8007090: 683b         	ldr	r3, [r7]
 8007092: 4413         	add	r3, r2
 8007094: 781b         	ldrb	r3, [r3]
 8007096: 461a         	mov	r2, r3
 8007098: 687b         	ldr	r3, [r7, #0x4]
 800709a: 4413         	add	r3, r2
 800709c: 695b         	ldr	r3, [r3, #0x14]
 800709e: f003 0380    	and	r3, r3, #0x80
 80070a2: 2b80         	cmp	r3, #0x80
 80070a4: bf0c         	ite	eq
 80070a6: 2301         	moveq	r3, #0x1
 80070a8: 2300         	movne	r3, #0x0
 80070aa: b2db         	uxtb	r3, r3
; }
 80070ac: 4618         	mov	r0, r3
 80070ae: 370c         	adds	r7, #0xc
 80070b0: 46bd         	mov	sp, r7
 80070b2: bc80         	pop	{r7}
 80070b4: 4770         	bx	lr
 80070b6: bf00         	nop

080070b8 <$d>:
 80070b8: 54 d2 01 08  	.word	0x0801d254

080070bc <dma_stm32_id_to_stream>:
; {
 80070bc: b480         	push	{r7}
 80070be: b083         	sub	sp, #0xc
 80070c0: af00         	add	r7, sp, #0x0
 80070c2: 6078         	str	r0, [r7, #0x4]
; 	return stream_nr[id];
 80070c4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80070d8 <dma_stm32_id_to_stream+0x1c>
 80070c6: 687b         	ldr	r3, [r7, #0x4]
 80070c8: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 80070cc: 4618         	mov	r0, r3
 80070ce: 370c         	adds	r7, #0xc
 80070d0: 46bd         	mov	sp, r7
 80070d2: bc80         	pop	{r7}
 80070d4: 4770         	bx	lr
 80070d6: bf00         	nop

080070d8 <$d>:
 80070d8: 5c d2 01 08  	.word	0x0801d25c

080070dc <dma_stm32_slot_to_channel>:
; {
 80070dc: b480         	push	{r7}
 80070de: b083         	sub	sp, #0xc
 80070e0: af00         	add	r7, sp, #0x0
 80070e2: 6078         	str	r0, [r7, #0x4]
; 	return channel_nr[slot];
 80070e4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80070f8 <dma_stm32_slot_to_channel+0x1c>
 80070e6: 687b         	ldr	r3, [r7, #0x4]
 80070e8: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 80070ec: 4618         	mov	r0, r3
 80070ee: 370c         	adds	r7, #0xc
 80070f0: 46bd         	mov	sp, r7
 80070f2: bc80         	pop	{r7}
 80070f4: 4770         	bx	lr
 80070f6: bf00         	nop

080070f8 <$d>:
 80070f8: 7c d2 01 08  	.word	0x0801d27c

080070fc <dma_stm32_clear_ht>:
; {
 80070fc: b580         	push	{r7, lr}
 80070fe: b082         	sub	sp, #0x8
 8007100: af00         	add	r7, sp, #0x0
 8007102: 6078         	str	r0, [r7, #0x4]
 8007104: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 8007106: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800711c <dma_stm32_clear_ht+0x20>
 8007108: 683b         	ldr	r3, [r7]
 800710a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800710e: 6878         	ldr	r0, [r7, #0x4]
 8007110: 4798         	blx	r3
; }
 8007112: bf00         	nop
 8007114: 3708         	adds	r7, #0x8
 8007116: 46bd         	mov	sp, r7
 8007118: bd80         	pop	{r7, pc}
 800711a: bf00         	nop

0800711c <$d>:
 800711c: 9c d2 01 08  	.word	0x0801d29c

08007120 <dma_stm32_clear_tc>:
; {
 8007120: b580         	push	{r7, lr}
 8007122: b082         	sub	sp, #0x8
 8007124: af00         	add	r7, sp, #0x0
 8007126: 6078         	str	r0, [r7, #0x4]
 8007128: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800712a: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8007140 <dma_stm32_clear_tc+0x20>
 800712c: 683b         	ldr	r3, [r7]
 800712e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8007132: 6878         	ldr	r0, [r7, #0x4]
 8007134: 4798         	blx	r3
; }
 8007136: bf00         	nop
 8007138: 3708         	adds	r7, #0x8
 800713a: 46bd         	mov	sp, r7
 800713c: bd80         	pop	{r7, pc}
 800713e: bf00         	nop

08007140 <$d>:
 8007140: bc d2 01 08  	.word	0x0801d2bc

08007144 <dma_stm32_is_ht_active>:
; {
 8007144: b580         	push	{r7, lr}
 8007146: b082         	sub	sp, #0x8
 8007148: af00         	add	r7, sp, #0x0
 800714a: 6078         	str	r0, [r7, #0x4]
 800714c: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800714e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8007170 <dma_stm32_is_ht_active+0x2c>
 8007150: 683b         	ldr	r3, [r7]
 8007152: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8007156: 6878         	ldr	r0, [r7, #0x4]
 8007158: 4798         	blx	r3
 800715a: 4603         	mov	r3, r0
 800715c: 2b00         	cmp	r3, #0x0
 800715e: bf14         	ite	ne
 8007160: 2301         	movne	r3, #0x1
 8007162: 2300         	moveq	r3, #0x0
 8007164: b2db         	uxtb	r3, r3
; }
 8007166: 4618         	mov	r0, r3
 8007168: 3708         	adds	r7, #0x8
 800716a: 46bd         	mov	sp, r7
 800716c: bd80         	pop	{r7, pc}
 800716e: bf00         	nop

08007170 <$d>:
 8007170: dc d2 01 08  	.word	0x0801d2dc

08007174 <dma_stm32_is_tc_active>:
; {
 8007174: b580         	push	{r7, lr}
 8007176: b082         	sub	sp, #0x8
 8007178: af00         	add	r7, sp, #0x0
 800717a: 6078         	str	r0, [r7, #0x4]
 800717c: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800717e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80071a0 <dma_stm32_is_tc_active+0x2c>
 8007180: 683b         	ldr	r3, [r7]
 8007182: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8007186: 6878         	ldr	r0, [r7, #0x4]
 8007188: 4798         	blx	r3
 800718a: 4603         	mov	r3, r0
 800718c: 2b00         	cmp	r3, #0x0
 800718e: bf14         	ite	ne
 8007190: 2301         	movne	r3, #0x1
 8007192: 2300         	moveq	r3, #0x0
 8007194: b2db         	uxtb	r3, r3
; }
 8007196: 4618         	mov	r0, r3
 8007198: 3708         	adds	r7, #0x8
 800719a: 46bd         	mov	sp, r7
 800719c: bd80         	pop	{r7, pc}
 800719e: bf00         	nop

080071a0 <$d>:
 80071a0: fc d2 01 08  	.word	0x0801d2fc

080071a4 <dma_stm32_clear_te>:
; {
 80071a4: b580         	push	{r7, lr}
 80071a6: b082         	sub	sp, #0x8
 80071a8: af00         	add	r7, sp, #0x0
 80071aa: 6078         	str	r0, [r7, #0x4]
 80071ac: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 80071ae: 4a05         	ldr	r2, [pc, #0x14]         @ 0x80071c4 <dma_stm32_clear_te+0x20>
 80071b0: 683b         	ldr	r3, [r7]
 80071b2: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80071b6: 6878         	ldr	r0, [r7, #0x4]
 80071b8: 4798         	blx	r3
; }
 80071ba: bf00         	nop
 80071bc: 3708         	adds	r7, #0x8
 80071be: 46bd         	mov	sp, r7
 80071c0: bd80         	pop	{r7, pc}
 80071c2: bf00         	nop

080071c4 <$d>:
 80071c4: 1c d3 01 08  	.word	0x0801d31c

080071c8 <dma_stm32_clear_dme>:
; {
 80071c8: b580         	push	{r7, lr}
 80071ca: b082         	sub	sp, #0x8
 80071cc: af00         	add	r7, sp, #0x0
 80071ce: 6078         	str	r0, [r7, #0x4]
 80071d0: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 80071d2: 4a05         	ldr	r2, [pc, #0x14]         @ 0x80071e8 <dma_stm32_clear_dme+0x20>
 80071d4: 683b         	ldr	r3, [r7]
 80071d6: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80071da: 6878         	ldr	r0, [r7, #0x4]
 80071dc: 4798         	blx	r3
; }
 80071de: bf00         	nop
 80071e0: 3708         	adds	r7, #0x8
 80071e2: 46bd         	mov	sp, r7
 80071e4: bd80         	pop	{r7, pc}
 80071e6: bf00         	nop

080071e8 <$d>:
 80071e8: 3c d3 01 08  	.word	0x0801d33c

080071ec <dma_stm32_clear_fe>:
; {
 80071ec: b580         	push	{r7, lr}
 80071ee: b082         	sub	sp, #0x8
 80071f0: af00         	add	r7, sp, #0x0
 80071f2: 6078         	str	r0, [r7, #0x4]
 80071f4: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 80071f6: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800720c <dma_stm32_clear_fe+0x20>
 80071f8: 683b         	ldr	r3, [r7]
 80071fa: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80071fe: 6878         	ldr	r0, [r7, #0x4]
 8007200: 4798         	blx	r3
; }
 8007202: bf00         	nop
 8007204: 3708         	adds	r7, #0x8
 8007206: 46bd         	mov	sp, r7
 8007208: bd80         	pop	{r7, pc}
 800720a: bf00         	nop

0800720c <$d>:
 800720c: 5c d3 01 08  	.word	0x0801d35c

08007210 <dma_stm32_is_te_active>:
; {
 8007210: b580         	push	{r7, lr}
 8007212: b082         	sub	sp, #0x8
 8007214: af00         	add	r7, sp, #0x0
 8007216: 6078         	str	r0, [r7, #0x4]
 8007218: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800721a: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800723c <dma_stm32_is_te_active+0x2c>
 800721c: 683b         	ldr	r3, [r7]
 800721e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8007222: 6878         	ldr	r0, [r7, #0x4]
 8007224: 4798         	blx	r3
 8007226: 4603         	mov	r3, r0
 8007228: 2b00         	cmp	r3, #0x0
 800722a: bf14         	ite	ne
 800722c: 2301         	movne	r3, #0x1
 800722e: 2300         	moveq	r3, #0x0
 8007230: b2db         	uxtb	r3, r3
; }
 8007232: 4618         	mov	r0, r3
 8007234: 3708         	adds	r7, #0x8
 8007236: 46bd         	mov	sp, r7
 8007238: bd80         	pop	{r7, pc}
 800723a: bf00         	nop

0800723c <$d>:
 800723c: 7c d3 01 08  	.word	0x0801d37c

08007240 <dma_stm32_is_dme_active>:
; {
 8007240: b580         	push	{r7, lr}
 8007242: b082         	sub	sp, #0x8
 8007244: af00         	add	r7, sp, #0x0
 8007246: 6078         	str	r0, [r7, #0x4]
 8007248: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800724a: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800726c <dma_stm32_is_dme_active+0x2c>
 800724c: 683b         	ldr	r3, [r7]
 800724e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8007252: 6878         	ldr	r0, [r7, #0x4]
 8007254: 4798         	blx	r3
 8007256: 4603         	mov	r3, r0
 8007258: 2b00         	cmp	r3, #0x0
 800725a: bf14         	ite	ne
 800725c: 2301         	movne	r3, #0x1
 800725e: 2300         	moveq	r3, #0x0
 8007260: b2db         	uxtb	r3, r3
; }
 8007262: 4618         	mov	r0, r3
 8007264: 3708         	adds	r7, #0x8
 8007266: 46bd         	mov	sp, r7
 8007268: bd80         	pop	{r7, pc}
 800726a: bf00         	nop

0800726c <$d>:
 800726c: 9c d3 01 08  	.word	0x0801d39c

08007270 <dma_stm32_is_fe_active>:
; {
 8007270: b580         	push	{r7, lr}
 8007272: b082         	sub	sp, #0x8
 8007274: af00         	add	r7, sp, #0x0
 8007276: 6078         	str	r0, [r7, #0x4]
 8007278: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800727a: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800729c <dma_stm32_is_fe_active+0x2c>
 800727c: 683b         	ldr	r3, [r7]
 800727e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8007282: 6878         	ldr	r0, [r7, #0x4]
 8007284: 4798         	blx	r3
 8007286: 4603         	mov	r3, r0
 8007288: 2b00         	cmp	r3, #0x0
 800728a: bf14         	ite	ne
 800728c: 2301         	movne	r3, #0x1
 800728e: 2300         	moveq	r3, #0x0
 8007290: b2db         	uxtb	r3, r3
; }
 8007292: 4618         	mov	r0, r3
 8007294: 3708         	adds	r7, #0x8
 8007296: 46bd         	mov	sp, r7
 8007298: bd80         	pop	{r7, pc}
 800729a: bf00         	nop

0800729c <$d>:
 800729c: bc d3 01 08  	.word	0x0801d3bc

080072a0 <stm32_dma_dump_stream_irq>:
; {
 80072a0: b5f0         	push	{r4, r5, r6, r7, lr}
 80072a2: b08f         	sub	sp, #0x3c
 80072a4: af08         	add	r7, sp, #0x20
 80072a6: 60f8         	str	r0, [r7, #0xc]
 80072a8: 60b9         	str	r1, [r7, #0x8]
; 	LOG_INF("tc: %d, ht: %d, te: %d, dme: %d, fe: %d",
 80072aa: 2303         	movs	r3, #0x3
 80072ac: 2b02         	cmp	r3, #0x2
 80072ae: d93c         	bls	0x800732a <stm32_dma_dump_stream_irq+0x8a> @ imm = #0x78
 80072b0: 2301         	movs	r3, #0x1
 80072b2: 74fb         	strb	r3, [r7, #0x13]
 80072b4: 7cfb         	ldrb	r3, [r7, #0x13]
 80072b6: f083 0301    	eor	r3, r3, #0x1
 80072ba: b2db         	uxtb	r3, r3
 80072bc: 2b00         	cmp	r3, #0x0
 80072be: d134         	bne	0x800732a <stm32_dma_dump_stream_irq+0x8a> @ imm = #0x68
 80072c0: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8007334 <stm32_dma_dump_stream_irq+0x94>
 80072c2: 681c         	ldr	r4, [r3]
 80072c4: 68b9         	ldr	r1, [r7, #0x8]
 80072c6: 68f8         	ldr	r0, [r7, #0xc]
 80072c8: f7ff ff54    	bl	0x8007174 <dma_stm32_is_tc_active> @ imm = #-0x158
 80072cc: 4603         	mov	r3, r0
 80072ce: 461d         	mov	r5, r3
 80072d0: 68b9         	ldr	r1, [r7, #0x8]
 80072d2: 68f8         	ldr	r0, [r7, #0xc]
 80072d4: f7ff ff36    	bl	0x8007144 <dma_stm32_is_ht_active> @ imm = #-0x194
 80072d8: 4603         	mov	r3, r0
 80072da: 461e         	mov	r6, r3
 80072dc: 68b9         	ldr	r1, [r7, #0x8]
 80072de: 68f8         	ldr	r0, [r7, #0xc]
 80072e0: f7ff ff96    	bl	0x8007210 <dma_stm32_is_te_active> @ imm = #-0xd4
 80072e4: 4603         	mov	r3, r0
 80072e6: 607b         	str	r3, [r7, #0x4]
 80072e8: 68b9         	ldr	r1, [r7, #0x8]
 80072ea: 68f8         	ldr	r0, [r7, #0xc]
 80072ec: f7ff ffa8    	bl	0x8007240 <dma_stm32_is_dme_active> @ imm = #-0xb0
 80072f0: 4603         	mov	r3, r0
 80072f2: 603b         	str	r3, [r7]
 80072f4: 68b9         	ldr	r1, [r7, #0x8]
 80072f6: 68f8         	ldr	r0, [r7, #0xc]
 80072f8: f7ff ffba    	bl	0x8007270 <dma_stm32_is_fe_active> @ imm = #-0x8c
 80072fc: 4603         	mov	r3, r0
 80072fe: 9307         	str	r3, [sp, #0x1c]
 8007300: 683a         	ldr	r2, [r7]
 8007302: 9206         	str	r2, [sp, #0x18]
 8007304: 687b         	ldr	r3, [r7, #0x4]
 8007306: 9305         	str	r3, [sp, #0x14]
 8007308: 9604         	str	r6, [sp, #0x10]
 800730a: 9503         	str	r5, [sp, #0xc]
 800730c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8007338 <stm32_dma_dump_stream_irq+0x98>
 800730e: 9302         	str	r3, [sp, #0x8]
 8007310: 2300         	movs	r3, #0x0
 8007312: 9301         	str	r3, [sp, #0x4]
 8007314: 2300         	movs	r3, #0x0
 8007316: 9300         	str	r3, [sp]
 8007318: 2300         	movs	r3, #0x0
 800731a: 2203         	movs	r2, #0x3
 800731c: 4621         	mov	r1, r4
 800731e: 2000         	movs	r0, #0x0
 8007320: f00d fc63    	bl	0x8014bea <z_log_msg_runtime_create> @ imm = #0xd8c6
 8007324: 2300         	movs	r3, #0x0
 8007326: 617b         	str	r3, [r7, #0x14]
; }
 8007328: bf00         	nop
 800732a: bf00         	nop
 800732c: 371c         	adds	r7, #0x1c
 800732e: 46bd         	mov	sp, r7
 8007330: bdf0         	pop	{r4, r5, r6, r7, pc}
 8007332: bf00         	nop

08007334 <$d>:
 8007334: 5c 04 00 20  	.word	0x2000045c
 8007338: 44 c2 01 08  	.word	0x0801c244

0800733c <stm32_dma_is_unexpected_irq_happened>:
; {
 800733c: b580         	push	{r7, lr}
 800733e: b088         	sub	sp, #0x20
 8007340: af04         	add	r7, sp, #0x10
 8007342: 6078         	str	r0, [r7, #0x4]
 8007344: 6039         	str	r1, [r7]
; 	if (LL_DMA_IsEnabledIT_FE(dma, dma_stm32_id_to_stream(id)) &&
 8007346: 6838         	ldr	r0, [r7]
 8007348: f7ff feb8    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0x290
 800734c: 4603         	mov	r3, r0
 800734e: 4619         	mov	r1, r3
 8007350: 6878         	ldr	r0, [r7, #0x4]
 8007352: f7ff fe97    	bl	0x8007084 <LL_DMA_IsEnabledIT_FE> @ imm = #-0x2d2
 8007356: 4603         	mov	r3, r0
 8007358: 2b00         	cmp	r3, #0x0
 800735a: d02a         	beq	0x80073b2 <stm32_dma_is_unexpected_irq_happened+0x76> @ imm = #0x54
; 	    dma_stm32_is_fe_active(dma, id)) {
 800735c: 6839         	ldr	r1, [r7]
 800735e: 6878         	ldr	r0, [r7, #0x4]
 8007360: f7ff ff86    	bl	0x8007270 <dma_stm32_is_fe_active> @ imm = #-0xf4
 8007364: 4603         	mov	r3, r0
; 	if (LL_DMA_IsEnabledIT_FE(dma, dma_stm32_id_to_stream(id)) &&
 8007366: 2b00         	cmp	r3, #0x0
 8007368: d023         	beq	0x80073b2 <stm32_dma_is_unexpected_irq_happened+0x76> @ imm = #0x46
; 		LOG_ERR("FiFo error.");
 800736a: 2303         	movs	r3, #0x3
 800736c: 2b00         	cmp	r3, #0x0
 800736e: d016         	beq	0x800739e <stm32_dma_is_unexpected_irq_happened+0x62> @ imm = #0x2c
 8007370: 2301         	movs	r3, #0x1
 8007372: 73fb         	strb	r3, [r7, #0xf]
 8007374: 7bfb         	ldrb	r3, [r7, #0xf]
 8007376: f083 0301    	eor	r3, r3, #0x1
 800737a: b2db         	uxtb	r3, r3
 800737c: 2b00         	cmp	r3, #0x0
 800737e: d10e         	bne	0x800739e <stm32_dma_is_unexpected_irq_happened+0x62> @ imm = #0x1c
 8007380: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80073bc <stm32_dma_is_unexpected_irq_happened+0x80>
 8007382: 6819         	ldr	r1, [r3]
 8007384: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80073c0 <stm32_dma_is_unexpected_irq_happened+0x84>
 8007386: 9302         	str	r3, [sp, #0x8]
 8007388: 2300         	movs	r3, #0x0
 800738a: 9301         	str	r3, [sp, #0x4]
 800738c: 2300         	movs	r3, #0x0
 800738e: 9300         	str	r3, [sp]
 8007390: 2300         	movs	r3, #0x0
 8007392: 2201         	movs	r2, #0x1
 8007394: 2000         	movs	r0, #0x0
 8007396: f00d fc28    	bl	0x8014bea <z_log_msg_runtime_create> @ imm = #0xd850
 800739a: 2300         	movs	r3, #0x0
 800739c: 60bb         	str	r3, [r7, #0x8]
; 		stm32_dma_dump_stream_irq(dma, id);
 800739e: 6839         	ldr	r1, [r7]
 80073a0: 6878         	ldr	r0, [r7, #0x4]
 80073a2: f7ff ff7d    	bl	0x80072a0 <stm32_dma_dump_stream_irq> @ imm = #-0x106
; 		stm32_dma_clear_stream_irq(dma, id);
 80073a6: 6839         	ldr	r1, [r7]
 80073a8: 6878         	ldr	r0, [r7, #0x4]
 80073aa: f00d fc7e    	bl	0x8014caa <stm32_dma_clear_stream_irq> @ imm = #0xd8fc
; 		return true;
 80073ae: 2301         	movs	r3, #0x1
 80073b0: e000         	b	0x80073b4 <stm32_dma_is_unexpected_irq_happened+0x78> @ imm = #0x0
; 	return false;
 80073b2: 2300         	movs	r3, #0x0
; }
 80073b4: 4618         	mov	r0, r3
 80073b6: 3710         	adds	r7, #0x10
 80073b8: 46bd         	mov	sp, r7
 80073ba: bd80         	pop	{r7, pc}

080073bc <$d>:
 80073bc: 5c 04 00 20  	.word	0x2000045c
 80073c0: 6c c2 01 08  	.word	0x0801c26c

080073c4 <stm32_dma_get_mburst>:
; {
 80073c4: b580         	push	{r7, lr}
 80073c6: b08a         	sub	sp, #0x28
 80073c8: af04         	add	r7, sp, #0x10
 80073ca: 6078         	str	r0, [r7, #0x4]
 80073cc: 460b         	mov	r3, r1
 80073ce: 70fb         	strb	r3, [r7, #0x3]
; 	if (source_periph) {
 80073d0: 78fb         	ldrb	r3, [r7, #0x3]
 80073d2: 2b00         	cmp	r3, #0x0
 80073d4: d003         	beq	0x80073de <stm32_dma_get_mburst+0x1a> @ imm = #0x6
; 		memory_burst = config->dest_burst_length;
 80073d6: 687b         	ldr	r3, [r7, #0x4]
 80073d8: 895b         	ldrh	r3, [r3, #0xa]
 80073da: 617b         	str	r3, [r7, #0x14]
 80073dc: e002         	b	0x80073e4 <stm32_dma_get_mburst+0x20> @ imm = #0x4
; 		memory_burst = config->source_burst_length;
 80073de: 687b         	ldr	r3, [r7, #0x4]
 80073e0: 891b         	ldrh	r3, [r3, #0x8]
 80073e2: 617b         	str	r3, [r7, #0x14]
; 	switch (memory_burst) {
 80073e4: 697b         	ldr	r3, [r7, #0x14]
 80073e6: 3b01         	subs	r3, #0x1
 80073e8: 2b0f         	cmp	r3, #0xf
 80073ea: d82e         	bhi	0x800744a <stm32_dma_get_mburst+0x86> @ imm = #0x5c
 80073ec: a201         	adr	r2, #4 <stm32_dma_get_mburst+0x2d>
 80073ee: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 80073f2: bf00         	nop

080073f4 <$d>:
 80073f4: 35 74 00 08  	.word	0x08007435
 80073f8: 4b 74 00 08  	.word	0x0800744b
 80073fc: 4b 74 00 08  	.word	0x0800744b
 8007400: 39 74 00 08  	.word	0x08007439
 8007404: 4b 74 00 08  	.word	0x0800744b
 8007408: 4b 74 00 08  	.word	0x0800744b
 800740c: 4b 74 00 08  	.word	0x0800744b
 8007410: 3f 74 00 08  	.word	0x0800743f
 8007414: 4b 74 00 08  	.word	0x0800744b
 8007418: 4b 74 00 08  	.word	0x0800744b
 800741c: 4b 74 00 08  	.word	0x0800744b
 8007420: 4b 74 00 08  	.word	0x0800744b
 8007424: 4b 74 00 08  	.word	0x0800744b
 8007428: 4b 74 00 08  	.word	0x0800744b
 800742c: 4b 74 00 08  	.word	0x0800744b
 8007430: 45 74 00 08  	.word	0x08007445

08007434 <$t>:
; 		return LL_DMA_MBURST_SINGLE;
 8007434: 2300         	movs	r3, #0x0
 8007436: e023         	b	0x8007480 <stm32_dma_get_mburst+0xbc> @ imm = #0x46
; 		return LL_DMA_MBURST_INC4;
 8007438: f44f 0300    	mov.w	r3, #0x800000
 800743c: e020         	b	0x8007480 <stm32_dma_get_mburst+0xbc> @ imm = #0x40
; 		return LL_DMA_MBURST_INC8;
 800743e: f04f 7380    	mov.w	r3, #0x1000000
 8007442: e01d         	b	0x8007480 <stm32_dma_get_mburst+0xbc> @ imm = #0x3a
; 		return LL_DMA_MBURST_INC16;
 8007444: f04f 73c0    	mov.w	r3, #0x1800000
 8007448: e01a         	b	0x8007480 <stm32_dma_get_mburst+0xbc> @ imm = #0x34
; 		LOG_ERR("Memory burst size error,"
 800744a: 2303         	movs	r3, #0x3
 800744c: 2b00         	cmp	r3, #0x0
 800744e: d016         	beq	0x800747e <stm32_dma_get_mburst+0xba> @ imm = #0x2c
 8007450: 2301         	movs	r3, #0x1
 8007452: 74fb         	strb	r3, [r7, #0x13]
 8007454: 7cfb         	ldrb	r3, [r7, #0x13]
 8007456: f083 0301    	eor	r3, r3, #0x1
 800745a: b2db         	uxtb	r3, r3
 800745c: 2b00         	cmp	r3, #0x0
 800745e: d10e         	bne	0x800747e <stm32_dma_get_mburst+0xba> @ imm = #0x1c
 8007460: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8007488 <stm32_dma_get_mburst+0xc4>
 8007462: 6819         	ldr	r1, [r3]
 8007464: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800748c <stm32_dma_get_mburst+0xc8>
 8007466: 9302         	str	r3, [sp, #0x8]
 8007468: 2300         	movs	r3, #0x0
 800746a: 9301         	str	r3, [sp, #0x4]
 800746c: 2300         	movs	r3, #0x0
 800746e: 9300         	str	r3, [sp]
 8007470: 2300         	movs	r3, #0x0
 8007472: 2201         	movs	r2, #0x1
 8007474: 2000         	movs	r0, #0x0
 8007476: f00d fbb8    	bl	0x8014bea <z_log_msg_runtime_create> @ imm = #0xd770
 800747a: 2300         	movs	r3, #0x0
 800747c: 60fb         	str	r3, [r7, #0xc]
; 		return LL_DMA_MBURST_SINGLE;
 800747e: 2300         	movs	r3, #0x0
; }
 8007480: 4618         	mov	r0, r3
 8007482: 3718         	adds	r7, #0x18
 8007484: 46bd         	mov	sp, r7
 8007486: bd80         	pop	{r7, pc}

08007488 <$d>:
 8007488: 5c 04 00 20  	.word	0x2000045c
 800748c: 78 c2 01 08  	.word	0x0801c278

08007490 <stm32_dma_get_pburst>:
; {
 8007490: b580         	push	{r7, lr}
 8007492: b08a         	sub	sp, #0x28
 8007494: af04         	add	r7, sp, #0x10
 8007496: 6078         	str	r0, [r7, #0x4]
 8007498: 460b         	mov	r3, r1
 800749a: 70fb         	strb	r3, [r7, #0x3]
; 	if (source_periph) {
 800749c: 78fb         	ldrb	r3, [r7, #0x3]
 800749e: 2b00         	cmp	r3, #0x0
 80074a0: d003         	beq	0x80074aa <stm32_dma_get_pburst+0x1a> @ imm = #0x6
; 		periph_burst = config->source_burst_length;
 80074a2: 687b         	ldr	r3, [r7, #0x4]
 80074a4: 891b         	ldrh	r3, [r3, #0x8]
 80074a6: 617b         	str	r3, [r7, #0x14]
 80074a8: e002         	b	0x80074b0 <stm32_dma_get_pburst+0x20> @ imm = #0x4
; 		periph_burst = config->dest_burst_length;
 80074aa: 687b         	ldr	r3, [r7, #0x4]
 80074ac: 895b         	ldrh	r3, [r3, #0xa]
 80074ae: 617b         	str	r3, [r7, #0x14]
; 	switch (periph_burst) {
 80074b0: 697b         	ldr	r3, [r7, #0x14]
 80074b2: 3b01         	subs	r3, #0x1
 80074b4: 2b0f         	cmp	r3, #0xf
 80074b6: d82e         	bhi	0x8007516 <stm32_dma_get_pburst+0x86> @ imm = #0x5c
 80074b8: a201         	adr	r2, #4 <stm32_dma_get_pburst+0x2d>
 80074ba: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 80074be: bf00         	nop

080074c0 <$d>:
 80074c0: 01 75 00 08  	.word	0x08007501
 80074c4: 17 75 00 08  	.word	0x08007517
 80074c8: 17 75 00 08  	.word	0x08007517
 80074cc: 05 75 00 08  	.word	0x08007505
 80074d0: 17 75 00 08  	.word	0x08007517
 80074d4: 17 75 00 08  	.word	0x08007517
 80074d8: 17 75 00 08  	.word	0x08007517
 80074dc: 0b 75 00 08  	.word	0x0800750b
 80074e0: 17 75 00 08  	.word	0x08007517
 80074e4: 17 75 00 08  	.word	0x08007517
 80074e8: 17 75 00 08  	.word	0x08007517
 80074ec: 17 75 00 08  	.word	0x08007517
 80074f0: 17 75 00 08  	.word	0x08007517
 80074f4: 17 75 00 08  	.word	0x08007517
 80074f8: 17 75 00 08  	.word	0x08007517
 80074fc: 11 75 00 08  	.word	0x08007511

08007500 <$t>:
; 		return LL_DMA_PBURST_SINGLE;
 8007500: 2300         	movs	r3, #0x0
 8007502: e023         	b	0x800754c <stm32_dma_get_pburst+0xbc> @ imm = #0x46
; 		return LL_DMA_PBURST_INC4;
 8007504: f44f 1300    	mov.w	r3, #0x200000
 8007508: e020         	b	0x800754c <stm32_dma_get_pburst+0xbc> @ imm = #0x40
; 		return LL_DMA_PBURST_INC8;
 800750a: f44f 0380    	mov.w	r3, #0x400000
 800750e: e01d         	b	0x800754c <stm32_dma_get_pburst+0xbc> @ imm = #0x3a
; 		return LL_DMA_PBURST_INC16;
 8007510: f44f 03c0    	mov.w	r3, #0x600000
 8007514: e01a         	b	0x800754c <stm32_dma_get_pburst+0xbc> @ imm = #0x34
; 		LOG_ERR("Peripheral burst size error,"
 8007516: 2303         	movs	r3, #0x3
 8007518: 2b00         	cmp	r3, #0x0
 800751a: d016         	beq	0x800754a <stm32_dma_get_pburst+0xba> @ imm = #0x2c
 800751c: 2301         	movs	r3, #0x1
 800751e: 74fb         	strb	r3, [r7, #0x13]
 8007520: 7cfb         	ldrb	r3, [r7, #0x13]
 8007522: f083 0301    	eor	r3, r3, #0x1
 8007526: b2db         	uxtb	r3, r3
 8007528: 2b00         	cmp	r3, #0x0
 800752a: d10e         	bne	0x800754a <stm32_dma_get_pburst+0xba> @ imm = #0x1c
 800752c: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8007554 <stm32_dma_get_pburst+0xc4>
 800752e: 6819         	ldr	r1, [r3]
 8007530: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8007558 <stm32_dma_get_pburst+0xc8>
 8007532: 9302         	str	r3, [sp, #0x8]
 8007534: 2300         	movs	r3, #0x0
 8007536: 9301         	str	r3, [sp, #0x4]
 8007538: 2300         	movs	r3, #0x0
 800753a: 9300         	str	r3, [sp]
 800753c: 2300         	movs	r3, #0x0
 800753e: 2201         	movs	r2, #0x1
 8007540: 2000         	movs	r0, #0x0
 8007542: f00d fb52    	bl	0x8014bea <z_log_msg_runtime_create> @ imm = #0xd6a4
 8007546: 2300         	movs	r3, #0x0
 8007548: 60fb         	str	r3, [r7, #0xc]
; 		return LL_DMA_PBURST_SINGLE;
 800754a: 2300         	movs	r3, #0x0
; }
 800754c: 4618         	mov	r0, r3
 800754e: 3718         	adds	r7, #0x18
 8007550: 46bd         	mov	sp, r7
 8007552: bd80         	pop	{r7, pc}

08007554 <$d>:
 8007554: 5c 04 00 20  	.word	0x2000045c
 8007558: b0 c2 01 08  	.word	0x0801c2b0

0800755c <stm32_dma_get_fifo_threshold>:
; {
 800755c: b580         	push	{r7, lr}
 800755e: b088         	sub	sp, #0x20
 8007560: af04         	add	r7, sp, #0x10
 8007562: 4603         	mov	r3, r0
 8007564: 80fb         	strh	r3, [r7, #0x6]
; 	switch (fifo_mode_control) {
 8007566: 88fb         	ldrh	r3, [r7, #0x6]
 8007568: 2b03         	cmp	r3, #0x3
 800756a: d813         	bhi	0x8007594 <stm32_dma_get_fifo_threshold+0x38> @ imm = #0x26
 800756c: a201         	adr	r2, #4 <stm32_dma_get_fifo_threshold+0x15>
 800756e: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8007572: bf00         	nop

08007574 <$d>:
 8007574: 85 75 00 08  	.word	0x08007585
 8007578: 89 75 00 08  	.word	0x08007589
 800757c: 8d 75 00 08  	.word	0x0800758d
 8007580: 91 75 00 08  	.word	0x08007591

08007584 <$t>:
; 		return LL_DMA_FIFOTHRESHOLD_1_4;
 8007584: 2300         	movs	r3, #0x0
 8007586: e020         	b	0x80075ca <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x40
; 		return LL_DMA_FIFOTHRESHOLD_1_2;
 8007588: 2301         	movs	r3, #0x1
 800758a: e01e         	b	0x80075ca <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x3c
; 		return LL_DMA_FIFOTHRESHOLD_3_4;
 800758c: 2302         	movs	r3, #0x2
 800758e: e01c         	b	0x80075ca <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x38
; 		return LL_DMA_FIFOTHRESHOLD_FULL;
 8007590: 2303         	movs	r3, #0x3
 8007592: e01a         	b	0x80075ca <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x34
; 		LOG_WRN("FIFO threshold parameter error, reset to 1/4");
 8007594: 2303         	movs	r3, #0x3
 8007596: 2b01         	cmp	r3, #0x1
 8007598: d916         	bls	0x80075c8 <stm32_dma_get_fifo_threshold+0x6c> @ imm = #0x2c
 800759a: 2301         	movs	r3, #0x1
 800759c: 73fb         	strb	r3, [r7, #0xf]
 800759e: 7bfb         	ldrb	r3, [r7, #0xf]
 80075a0: f083 0301    	eor	r3, r3, #0x1
 80075a4: b2db         	uxtb	r3, r3
 80075a6: 2b00         	cmp	r3, #0x0
 80075a8: d10e         	bne	0x80075c8 <stm32_dma_get_fifo_threshold+0x6c> @ imm = #0x1c
 80075aa: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80075d4 <stm32_dma_get_fifo_threshold+0x78>
 80075ac: 6819         	ldr	r1, [r3]
 80075ae: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80075d8 <stm32_dma_get_fifo_threshold+0x7c>
 80075b0: 9302         	str	r3, [sp, #0x8]
 80075b2: 2300         	movs	r3, #0x0
 80075b4: 9301         	str	r3, [sp, #0x4]
 80075b6: 2300         	movs	r3, #0x0
 80075b8: 9300         	str	r3, [sp]
 80075ba: 2300         	movs	r3, #0x0
 80075bc: 2202         	movs	r2, #0x2
 80075be: 2000         	movs	r0, #0x0
 80075c0: f00d fb13    	bl	0x8014bea <z_log_msg_runtime_create> @ imm = #0xd626
 80075c4: 2300         	movs	r3, #0x0
 80075c6: 60bb         	str	r3, [r7, #0x8]
; 		return LL_DMA_FIFOTHRESHOLD_1_4;
 80075c8: 2300         	movs	r3, #0x0
; }
 80075ca: 4618         	mov	r0, r3
 80075cc: 3710         	adds	r7, #0x10
 80075ce: 46bd         	mov	sp, r7
 80075d0: bd80         	pop	{r7, pc}
 80075d2: bf00         	nop

080075d4 <$d>:
 80075d4: 5c 04 00 20  	.word	0x2000045c
 80075d8: ec c2 01 08  	.word	0x0801c2ec

080075dc <gpio_stm32_clock_request>:
; {
 80075dc: b580         	push	{r7, lr}
 80075de: b086         	sub	sp, #0x18
 80075e0: af00         	add	r7, sp, #0x0
 80075e2: 6078         	str	r0, [r7, #0x4]
 80075e4: 460b         	mov	r3, r1
 80075e6: 70fb         	strb	r3, [r7, #0x3]
; 	const struct gpio_stm32_config *cfg = dev->config;
 80075e8: 687b         	ldr	r3, [r7, #0x4]
 80075ea: 685b         	ldr	r3, [r3, #0x4]
 80075ec: 613b         	str	r3, [r7, #0x10]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 80075ee: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007620 <gpio_stm32_clock_request+0x44>
 80075f0: 60fb         	str	r3, [r7, #0xc]
; 	if (on) {
 80075f2: 78fb         	ldrb	r3, [r7, #0x3]
 80075f4: 2b00         	cmp	r3, #0x0
 80075f6: d007         	beq	0x8007608 <gpio_stm32_clock_request+0x2c> @ imm = #0xe
; 					(clock_control_subsys_t)&cfg->pclken);
 80075f8: 693b         	ldr	r3, [r7, #0x10]
 80075fa: 330c         	adds	r3, #0xc
; 		ret = clock_control_on(clk,
 80075fc: 4619         	mov	r1, r3
 80075fe: 68f8         	ldr	r0, [r7, #0xc]
 8007600: f00d fea4    	bl	0x801534c <clock_control_on> @ imm = #0xdd48
 8007604: 6178         	str	r0, [r7, #0x14]
 8007606: e006         	b	0x8007616 <gpio_stm32_clock_request+0x3a> @ imm = #0xc
; 					(clock_control_subsys_t)&cfg->pclken);
 8007608: 693b         	ldr	r3, [r7, #0x10]
 800760a: 330c         	adds	r3, #0xc
; 		ret = clock_control_off(clk,
 800760c: 4619         	mov	r1, r3
 800760e: 68f8         	ldr	r0, [r7, #0xc]
 8007610: f00d feae    	bl	0x8015370 <clock_control_off> @ imm = #0xdd5c
 8007614: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 8007616: 697b         	ldr	r3, [r7, #0x14]
; }
 8007618: 4618         	mov	r0, r3
 800761a: 3718         	adds	r7, #0x18
 800761c: 46bd         	mov	sp, r7
 800761e: bd80         	pop	{r7, pc}

08007620 <$d>:
 8007620: d8 ac 01 08  	.word	0x0801acd8

08007624 <gpio_stm32_pin_interrupt_configure>:
; {
 8007624: b580         	push	{r7, lr}
 8007626: b08a         	sub	sp, #0x28
 8007628: af00         	add	r7, sp, #0x0
 800762a: 60f8         	str	r0, [r7, #0xc]
 800762c: 607a         	str	r2, [r7, #0x4]
 800762e: 603b         	str	r3, [r7]
 8007630: 460b         	mov	r3, r1
 8007632: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8007634: 68fb         	ldr	r3, [r7, #0xc]
 8007636: 685b         	ldr	r3, [r3, #0x4]
 8007638: 61fb         	str	r3, [r7, #0x1c]
; 	struct gpio_stm32_data *data = dev->data;
 800763a: 68fb         	ldr	r3, [r7, #0xc]
 800763c: 691b         	ldr	r3, [r3, #0x10]
 800763e: 61bb         	str	r3, [r7, #0x18]
; 	const stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(cfg->port, pin);
 8007640: 69fb         	ldr	r3, [r7, #0x1c]
 8007642: 689b         	ldr	r3, [r3, #0x8]
 8007644: 461a         	mov	r2, r3
 8007646: 7afb         	ldrb	r3, [r7, #0xb]
 8007648: 4619         	mov	r1, r3
 800764a: 4610         	mov	r0, r2
 800764c: f00b fb8a    	bl	0x8012d64 <stm32_gpio_intc_get_pin_irq_line> @ imm = #0xb714
 8007650: 6178         	str	r0, [r7, #0x14]
; 	uint32_t irq_trigger = 0;
 8007652: 2300         	movs	r3, #0x0
 8007654: 627b         	str	r3, [r7, #0x24]
; 	int err = 0;
 8007656: 2300         	movs	r3, #0x0
 8007658: 623b         	str	r3, [r7, #0x20]
; 	if (mode == GPIO_INT_MODE_DISABLED) {
 800765a: 687b         	ldr	r3, [r7, #0x4]
 800765c: f5b3 1f00    	cmp.w	r3, #0x200000
 8007660: d108         	bne	0x8007674 <gpio_stm32_pin_interrupt_configure+0x50> @ imm = #0x10
; 		gpio_stm32_disable_pin_irqs(cfg->port, pin);
 8007662: 69fb         	ldr	r3, [r7, #0x1c]
 8007664: 689b         	ldr	r3, [r3, #0x8]
 8007666: 461a         	mov	r2, r3
 8007668: 7afb         	ldrb	r3, [r7, #0xb]
 800766a: 4619         	mov	r1, r3
 800766c: 4610         	mov	r0, r2
 800766e: f00d ffef    	bl	0x8015650 <gpio_stm32_disable_pin_irqs> @ imm = #0xdfde
; 		goto exit;
 8007672: e040         	b	0x80076f6 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x80
; 	if (mode == GPIO_INT_MODE_LEVEL) {
 8007674: 687b         	ldr	r3, [r7, #0x4]
 8007676: f5b3 0f80    	cmp.w	r3, #0x400000
 800767a: d103         	bne	0x8007684 <gpio_stm32_pin_interrupt_configure+0x60> @ imm = #0x6
; 			err = -ENOTSUP;
 800767c: f06f 0385    	mvn	r3, #0x85
 8007680: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 8007682: e038         	b	0x80076f6 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x70
; 		switch (trig) {
 8007684: 683b         	ldr	r3, [r7]
 8007686: f1b3 6fc0    	cmp.w	r3, #0x6000000
 800768a: d012         	beq	0x80076b2 <gpio_stm32_pin_interrupt_configure+0x8e> @ imm = #0x24
 800768c: 683b         	ldr	r3, [r7]
 800768e: f1b3 6fc0    	cmp.w	r3, #0x6000000
 8007692: d811         	bhi	0x80076b8 <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x22
 8007694: 683b         	ldr	r3, [r7]
 8007696: f1b3 7f00    	cmp.w	r3, #0x2000000
 800769a: d004         	beq	0x80076a6 <gpio_stm32_pin_interrupt_configure+0x82> @ imm = #0x8
 800769c: 683b         	ldr	r3, [r7]
 800769e: f1b3 6f80    	cmp.w	r3, #0x4000000
 80076a2: d003         	beq	0x80076ac <gpio_stm32_pin_interrupt_configure+0x88> @ imm = #0x6
 80076a4: e008         	b	0x80076b8 <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x10
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_FALLING;
 80076a6: 2302         	movs	r3, #0x2
 80076a8: 627b         	str	r3, [r7, #0x24]
; 			break;
 80076aa: e009         	b	0x80076c0 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x12
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_RISING;
 80076ac: 2301         	movs	r3, #0x1
 80076ae: 627b         	str	r3, [r7, #0x24]
; 			break;
 80076b0: e006         	b	0x80076c0 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0xc
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_BOTH;
 80076b2: 2303         	movs	r3, #0x3
 80076b4: 627b         	str	r3, [r7, #0x24]
; 			break;
 80076b6: e003         	b	0x80076c0 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x6
; 			err = -EINVAL;
 80076b8: f06f 0315    	mvn	r3, #0x15
 80076bc: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 80076be: e01a         	b	0x80076f6 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x34
; 	if (stm32_gpio_intc_set_irq_callback(irq_line, gpio_stm32_isr, data) != 0) {
 80076c0: 69ba         	ldr	r2, [r7, #0x18]
 80076c2: 490f         	ldr	r1, [pc, #0x3c]         @ 0x8007700 <gpio_stm32_pin_interrupt_configure+0xdc>
 80076c4: 6978         	ldr	r0, [r7, #0x14]
 80076c6: f7fc fb0d    	bl	0x8003ce4 <stm32_gpio_intc_set_irq_callback> @ imm = #-0x39e6
 80076ca: 4603         	mov	r3, r0
 80076cc: 2b00         	cmp	r3, #0x0
 80076ce: d003         	beq	0x80076d8 <gpio_stm32_pin_interrupt_configure+0xb4> @ imm = #0x6
; 		err = -EBUSY;
 80076d0: f06f 030f    	mvn	r3, #0xf
 80076d4: 623b         	str	r3, [r7, #0x20]
; 		goto exit;
 80076d6: e00e         	b	0x80076f6 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x1c
; 	stm32_exti_set_line_src_port(pin, cfg->port);
 80076d8: 69fb         	ldr	r3, [r7, #0x1c]
 80076da: 689b         	ldr	r3, [r3, #0x8]
 80076dc: 461a         	mov	r2, r3
 80076de: 7afb         	ldrb	r3, [r7, #0xb]
 80076e0: 4611         	mov	r1, r2
 80076e2: 4618         	mov	r0, r3
 80076e4: f00b fb58    	bl	0x8012d98 <stm32_exti_set_line_src_port> @ imm = #0xb6b0
; 	stm32_gpio_intc_select_line_trigger(irq_line, irq_trigger);
 80076e8: 6a79         	ldr	r1, [r7, #0x24]
 80076ea: 6978         	ldr	r0, [r7, #0x14]
 80076ec: f7fc fabe    	bl	0x8003c6c <stm32_gpio_intc_select_line_trigger> @ imm = #-0x3a84
; 	stm32_gpio_intc_enable_line(irq_line);
 80076f0: 6978         	ldr	r0, [r7, #0x14]
 80076f2: f7fc fa9f    	bl	0x8003c34 <stm32_gpio_intc_enable_line> @ imm = #-0x3ac2
; 	return err;
 80076f6: 6a3b         	ldr	r3, [r7, #0x20]
; }
 80076f8: 4618         	mov	r0, r3
 80076fa: 3728         	adds	r7, #0x28
 80076fc: 46bd         	mov	sp, r7
 80076fe: bd80         	pop	{r7, pc}

08007700 <$d>:
 8007700: 15 55 01 08  	.word	0x08015515

08007704 <gpio_stm32_init>:
; {
 8007704: b580         	push	{r7, lr}
 8007706: b084         	sub	sp, #0x10
 8007708: af00         	add	r7, sp, #0x0
 800770a: 6078         	str	r0, [r7, #0x4]
; 	struct gpio_stm32_data *data = dev->data;
 800770c: 687b         	ldr	r3, [r7, #0x4]
 800770e: 691b         	ldr	r3, [r3, #0x10]
 8007710: 60fb         	str	r3, [r7, #0xc]
; 	data->dev = dev;
 8007712: 68fb         	ldr	r3, [r7, #0xc]
 8007714: 687a         	ldr	r2, [r7, #0x4]
 8007716: 605a         	str	r2, [r3, #0x4]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 8007718: 480e         	ldr	r0, [pc, #0x38]         @ 0x8007754 <gpio_stm32_init+0x50>
 800771a: f00d fc95    	bl	0x8015048 <device_is_ready> @ imm = #0xd92a
 800771e: 4603         	mov	r3, r0
 8007720: f083 0301    	eor	r3, r3, #0x1
 8007724: b2db         	uxtb	r3, r3
 8007726: 2b00         	cmp	r3, #0x0
 8007728: d002         	beq	0x8007730 <gpio_stm32_init+0x2c> @ imm = #0x4
; 		return -ENODEV;
 800772a: f06f 0312    	mvn	r3, #0x12
 800772e: e00d         	b	0x800774c <gpio_stm32_init+0x48> @ imm = #0x1a
; 	ret = gpio_stm32_clock_request(dev, !IS_ENABLED(CONFIG_PM_DEVICE_RUNTIME));
 8007730: 2101         	movs	r1, #0x1
 8007732: 6878         	ldr	r0, [r7, #0x4]
 8007734: f7ff ff52    	bl	0x80075dc <gpio_stm32_clock_request> @ imm = #-0x15c
 8007738: 60b8         	str	r0, [r7, #0x8]
; 	if (ret < 0) {
 800773a: 68bb         	ldr	r3, [r7, #0x8]
 800773c: 2b00         	cmp	r3, #0x0
 800773e: da01         	bge	0x8007744 <gpio_stm32_init+0x40> @ imm = #0x2
; 		return ret;
 8007740: 68bb         	ldr	r3, [r7, #0x8]
 8007742: e003         	b	0x800774c <gpio_stm32_init+0x48> @ imm = #0x6
; 	(void)pm_device_runtime_enable(dev);
 8007744: 6878         	ldr	r0, [r7, #0x4]
 8007746: f00d fe25    	bl	0x8015394 <pm_device_runtime_enable> @ imm = #0xdc4a
; 	return 0;
 800774a: 2300         	movs	r3, #0x0
; }
 800774c: 4618         	mov	r0, r3
 800774e: 3710         	adds	r7, #0x10
 8007750: 46bd         	mov	sp, r7
 8007752: bd80         	pop	{r7, pc}

08007754 <$d>:
 8007754: d8 ac 01 08  	.word	0x0801acd8

08007758 <stm32_pin_configure>:
; {
 8007758: b580         	push	{r7, lr}
 800775a: b086         	sub	sp, #0x18
 800775c: af00         	add	r7, sp, #0x0
 800775e: 60f8         	str	r0, [r7, #0xc]
 8007760: 60b9         	str	r1, [r7, #0x8]
 8007762: 607a         	str	r2, [r7, #0x4]
; 	if (STM32_PORT(pin) >= gpio_ports_cnt) {
 8007764: 68fb         	ldr	r3, [r7, #0xc]
 8007766: 091b         	lsrs	r3, r3, #0x4
 8007768: 2210         	movs	r2, #0x10
 800776a: 4293         	cmp	r3, r2
 800776c: d302         	blo	0x8007774 <stm32_pin_configure+0x1c> @ imm = #0x4
; 		return -EINVAL;
 800776e: f06f 0315    	mvn	r3, #0x15
 8007772: e01f         	b	0x80077b4 <stm32_pin_configure+0x5c> @ imm = #0x3e
; 	port_device = gpio_ports[STM32_PORT(pin)];
 8007774: 68fb         	ldr	r3, [r7, #0xc]
 8007776: 091b         	lsrs	r3, r3, #0x4
 8007778: 4a10         	ldr	r2, [pc, #0x40]         @ 0x80077bc <stm32_pin_configure+0x64>
 800777a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800777e: 617b         	str	r3, [r7, #0x14]
; 	if ((port_device == NULL) || (!device_is_ready(port_device))) {
 8007780: 697b         	ldr	r3, [r7, #0x14]
 8007782: 2b00         	cmp	r3, #0x0
 8007784: d008         	beq	0x8007798 <stm32_pin_configure+0x40> @ imm = #0x10
 8007786: 6978         	ldr	r0, [r7, #0x14]
 8007788: f00e f971    	bl	0x8015a6e <device_is_ready> @ imm = #0xe2e2
 800778c: 4603         	mov	r3, r0
 800778e: f083 0301    	eor	r3, r3, #0x1
 8007792: b2db         	uxtb	r3, r3
 8007794: 2b00         	cmp	r3, #0x0
 8007796: d002         	beq	0x800779e <stm32_pin_configure+0x46> @ imm = #0x4
; 		return -ENODEV;
 8007798: f06f 0312    	mvn	r3, #0x12
 800779c: e00a         	b	0x80077b4 <stm32_pin_configure+0x5c> @ imm = #0x14
; 	return gpio_stm32_configure(port_device, STM32_PIN(pin), pin_cgf, pin_func);
 800779e: 68fb         	ldr	r3, [r7, #0xc]
 80077a0: b2db         	uxtb	r3, r3
 80077a2: f003 030f    	and	r3, r3, #0xf
 80077a6: b2d9         	uxtb	r1, r3
 80077a8: 687b         	ldr	r3, [r7, #0x4]
 80077aa: 68ba         	ldr	r2, [r7, #0x8]
 80077ac: 6978         	ldr	r0, [r7, #0x14]
 80077ae: f00e f853    	bl	0x8015858 <gpio_stm32_configure> @ imm = #0xe0a6
 80077b2: 4603         	mov	r3, r0
; }
 80077b4: 4618         	mov	r0, r3
 80077b6: 3718         	adds	r7, #0x18
 80077b8: 46bd         	mov	sp, r7
 80077ba: bd80         	pop	{r7, pc}

080077bc <$d>:
 80077bc: 90 d4 01 08  	.word	0x0801d490

080077c0 <LL_USART_SetBaudRate>:
; {
 80077c0: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 80077c4: b0c0         	sub	sp, #0x100
 80077c6: af00         	add	r7, sp, #0x0
 80077c8: f8c7 00fc    	str.w	r0, [r7, #0xfc]
 80077cc: f8c7 10f8    	str.w	r1, [r7, #0xf8]
 80077d0: f8c7 20f4    	str.w	r2, [r7, #0xf4]
 80077d4: f8c7 30f0    	str.w	r3, [r7, #0xf0]
;   if (OverSampling == LL_USART_OVERSAMPLING_8)
 80077d8: f8d7 30f4    	ldr.w	r3, [r7, #0xf4]
 80077dc: f5b3 4f00    	cmp.w	r3, #0x8000
 80077e0: f040 810e    	bne.w	0x8007a00 <LL_USART_SetBaudRate+0x240> @ imm = #0x21c
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
 80077e4: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 80077e8: 2200         	movs	r2, #0x0
 80077ea: f8c7 30e8    	str.w	r3, [r7, #0xe8]
 80077ee: f8c7 20ec    	str.w	r2, [r7, #0xec]
 80077f2: e9d7 453a    	ldrd	r4, r5, [r7, #232]
 80077f6: 4622         	mov	r2, r4
 80077f8: 462b         	mov	r3, r5
 80077fa: 1891         	adds	r1, r2, r2
 80077fc: 6639         	str	r1, [r7, #0x60]
 80077fe: 415b         	adcs	r3, r3
 8007800: 667b         	str	r3, [r7, #0x64]
 8007802: e9d7 2318    	ldrd	r2, r3, [r7, #96]
 8007806: 4620         	mov	r0, r4
 8007808: 4629         	mov	r1, r5
 800780a: 4604         	mov	r4, r0
 800780c: eb12 0804    	adds.w	r8, r2, r4
 8007810: 460c         	mov	r4, r1
 8007812: eb43 0904    	adc.w	r9, r3, r4
 8007816: f04f 0200    	mov.w	r2, #0x0
 800781a: f04f 0300    	mov.w	r3, #0x0
 800781e: ea4f 03c9    	lsl.w	r3, r9, #0x3
 8007822: ea43 7358    	orr.w	r3, r3, r8, lsr #29
 8007826: ea4f 02c8    	lsl.w	r2, r8, #0x3
 800782a: 4690         	mov	r8, r2
 800782c: 4699         	mov	r9, r3
 800782e: 4603         	mov	r3, r0
 8007830: eb18 0303    	adds.w	r3, r8, r3
 8007834: f8c7 30e0    	str.w	r3, [r7, #0xe0]
 8007838: 460b         	mov	r3, r1
 800783a: eb49 0303    	adc.w	r3, r9, r3
 800783e: f8c7 30e4    	str.w	r3, [r7, #0xe4]
 8007842: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8007846: 2200         	movs	r2, #0x0
 8007848: 469a         	mov	r10, r3
 800784a: 4693         	mov	r11, r2
 800784c: eb1a 030a    	adds.w	r3, r10, r10
 8007850: 65bb         	str	r3, [r7, #0x58]
 8007852: eb4b 030b    	adc.w	r3, r11, r11
 8007856: 65fb         	str	r3, [r7, #0x5c]
 8007858: e9d7 2316    	ldrd	r2, r3, [r7, #88]
 800785c: e9d7 0138    	ldrd	r0, r1, [r7, #224]
 8007860: f7f9 f948    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x6d70
 8007864: 4602         	mov	r2, r0
 8007866: 460b         	mov	r3, r1
 8007868: 4b64         	ldr	r3, [pc, #0x190]        @ 0x80079fc <LL_USART_SetBaudRate+0x23c>
 800786a: fba3 2302    	umull	r2, r3, r3, r2
 800786e: 095b         	lsrs	r3, r3, #0x5
 8007870: b29b         	uxth	r3, r3
 8007872: 011b         	lsls	r3, r3, #0x4
 8007874: b29c         	uxth	r4, r3
 8007876: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800787a: 2200         	movs	r2, #0x0
 800787c: f8c7 30d8    	str.w	r3, [r7, #0xd8]
 8007880: f8c7 20dc    	str.w	r2, [r7, #0xdc]
 8007884: e9d7 8936    	ldrd	r8, r9, [r7, #216]
 8007888: 4642         	mov	r2, r8
 800788a: 464b         	mov	r3, r9
 800788c: 1891         	adds	r1, r2, r2
 800788e: 6539         	str	r1, [r7, #0x50]
 8007890: 415b         	adcs	r3, r3
 8007892: 657b         	str	r3, [r7, #0x54]
 8007894: e9d7 2314    	ldrd	r2, r3, [r7, #80]
 8007898: 4641         	mov	r1, r8
 800789a: 1851         	adds	r1, r2, r1
 800789c: 64b9         	str	r1, [r7, #0x48]
 800789e: 4649         	mov	r1, r9
 80078a0: 414b         	adcs	r3, r1
 80078a2: 64fb         	str	r3, [r7, #0x4c]
 80078a4: f04f 0200    	mov.w	r2, #0x0
 80078a8: f04f 0300    	mov.w	r3, #0x0
 80078ac: e9d7 ab12    	ldrd	r10, r11, [r7, #72]
 80078b0: 4659         	mov	r1, r11
 80078b2: 00cb         	lsls	r3, r1, #0x3
 80078b4: 4655         	mov	r5, r10
 80078b6: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 80078ba: 4651         	mov	r1, r10
 80078bc: 00ca         	lsls	r2, r1, #0x3
 80078be: 4610         	mov	r0, r2
 80078c0: 4619         	mov	r1, r3
 80078c2: 4603         	mov	r3, r0
 80078c4: 4642         	mov	r2, r8
 80078c6: 189b         	adds	r3, r3, r2
 80078c8: f8c7 30d0    	str.w	r3, [r7, #0xd0]
 80078cc: 464b         	mov	r3, r9
 80078ce: 460a         	mov	r2, r1
 80078d0: eb42 0303    	adc.w	r3, r2, r3
 80078d4: f8c7 30d4    	str.w	r3, [r7, #0xd4]
 80078d8: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 80078dc: 2200         	movs	r2, #0x0
 80078de: f8c7 30c8    	str.w	r3, [r7, #0xc8]
 80078e2: f8c7 20cc    	str.w	r2, [r7, #0xcc]
 80078e6: e9d7 1232    	ldrd	r1, r2, [r7, #200]
 80078ea: 460b         	mov	r3, r1
 80078ec: 18db         	adds	r3, r3, r3
 80078ee: 643b         	str	r3, [r7, #0x40]
 80078f0: 4613         	mov	r3, r2
 80078f2: eb42 0303    	adc.w	r3, r2, r3
 80078f6: 647b         	str	r3, [r7, #0x44]
 80078f8: e9d7 2310    	ldrd	r2, r3, [r7, #64]
 80078fc: e9d7 0134    	ldrd	r0, r1, [r7, #208]
 8007900: f7f9 f8f8    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x6e10
 8007904: 4602         	mov	r2, r0
 8007906: 460b         	mov	r3, r1
 8007908: 4611         	mov	r1, r2
 800790a: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x80079fc <LL_USART_SetBaudRate+0x23c>
 800790c: fba3 2301    	umull	r2, r3, r3, r1
 8007910: 095b         	lsrs	r3, r3, #0x5
 8007912: 2264         	movs	r2, #0x64
 8007914: fb02 f303    	mul	r3, r2, r3
 8007918: 1acb         	subs	r3, r1, r3
 800791a: 00db         	lsls	r3, r3, #0x3
 800791c: f103 0232    	add.w	r2, r3, #0x32
 8007920: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80079fc <LL_USART_SetBaudRate+0x23c>
 8007922: fba3 2302    	umull	r2, r3, r3, r2
 8007926: 095b         	lsrs	r3, r3, #0x5
 8007928: b29b         	uxth	r3, r3
 800792a: 005b         	lsls	r3, r3, #0x1
 800792c: b29b         	uxth	r3, r3
 800792e: f403 73f8    	and	r3, r3, #0x1f0
 8007932: b29b         	uxth	r3, r3
 8007934: 4423         	add	r3, r4
 8007936: b29c         	uxth	r4, r3
 8007938: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800793c: 2200         	movs	r2, #0x0
 800793e: f8c7 30c0    	str.w	r3, [r7, #0xc0]
 8007942: f8c7 20c4    	str.w	r2, [r7, #0xc4]
 8007946: e9d7 8930    	ldrd	r8, r9, [r7, #192]
 800794a: 4642         	mov	r2, r8
 800794c: 464b         	mov	r3, r9
 800794e: 1891         	adds	r1, r2, r2
 8007950: 63b9         	str	r1, [r7, #0x38]
 8007952: 415b         	adcs	r3, r3
 8007954: 63fb         	str	r3, [r7, #0x3c]
 8007956: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 800795a: 4641         	mov	r1, r8
 800795c: 1851         	adds	r1, r2, r1
 800795e: 6339         	str	r1, [r7, #0x30]
 8007960: 4649         	mov	r1, r9
 8007962: 414b         	adcs	r3, r1
 8007964: 637b         	str	r3, [r7, #0x34]
 8007966: f04f 0200    	mov.w	r2, #0x0
 800796a: f04f 0300    	mov.w	r3, #0x0
 800796e: e9d7 ab0c    	ldrd	r10, r11, [r7, #48]
 8007972: 4659         	mov	r1, r11
 8007974: 00cb         	lsls	r3, r1, #0x3
 8007976: 4655         	mov	r5, r10
 8007978: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 800797c: 4651         	mov	r1, r10
 800797e: 00ca         	lsls	r2, r1, #0x3
 8007980: 4610         	mov	r0, r2
 8007982: 4619         	mov	r1, r3
 8007984: 4603         	mov	r3, r0
 8007986: 4642         	mov	r2, r8
 8007988: 189b         	adds	r3, r3, r2
 800798a: f8c7 30b8    	str.w	r3, [r7, #0xb8]
 800798e: 464b         	mov	r3, r9
 8007990: 460a         	mov	r2, r1
 8007992: eb42 0303    	adc.w	r3, r2, r3
 8007996: f8c7 30bc    	str.w	r3, [r7, #0xbc]
 800799a: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800799e: 2200         	movs	r2, #0x0
 80079a0: f8c7 30b0    	str.w	r3, [r7, #0xb0]
 80079a4: f8c7 20b4    	str.w	r2, [r7, #0xb4]
 80079a8: e9d7 122c    	ldrd	r1, r2, [r7, #176]
 80079ac: 460b         	mov	r3, r1
 80079ae: 18db         	adds	r3, r3, r3
 80079b0: 62bb         	str	r3, [r7, #0x28]
 80079b2: 4613         	mov	r3, r2
 80079b4: eb42 0303    	adc.w	r3, r2, r3
 80079b8: 62fb         	str	r3, [r7, #0x2c]
 80079ba: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 80079be: e9d7 012e    	ldrd	r0, r1, [r7, #184]
 80079c2: f7f9 f897    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x6ed2
 80079c6: 4602         	mov	r2, r0
 80079c8: 460b         	mov	r3, r1
 80079ca: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80079fc <LL_USART_SetBaudRate+0x23c>
 80079cc: fba3 1302    	umull	r1, r3, r3, r2
 80079d0: 095b         	lsrs	r3, r3, #0x5
 80079d2: 2164         	movs	r1, #0x64
 80079d4: fb01 f303    	mul	r3, r1, r3
 80079d8: 1ad3         	subs	r3, r2, r3
 80079da: 00db         	lsls	r3, r3, #0x3
 80079dc: 3332         	adds	r3, #0x32
 80079de: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80079fc <LL_USART_SetBaudRate+0x23c>
 80079e0: fba2 2303    	umull	r2, r3, r2, r3
 80079e4: 095b         	lsrs	r3, r3, #0x5
 80079e6: b29b         	uxth	r3, r3
 80079e8: f003 0307    	and	r3, r3, #0x7
 80079ec: b29b         	uxth	r3, r3
 80079ee: 4423         	add	r3, r4
 80079f0: b29b         	uxth	r3, r3
 80079f2: 461a         	mov	r2, r3
 80079f4: f8d7 30fc    	ldr.w	r3, [r7, #0xfc]
 80079f8: 609a         	str	r2, [r3, #0x8]
; }
 80079fa: e10c         	b	0x8007c16 <LL_USART_SetBaudRate+0x456> @ imm = #0x218

080079fc <$d>:
 80079fc: 1f 85 eb 51  	.word	0x51eb851f

08007a00 <$t>:
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 8007a00: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8007a04: 2200         	movs	r2, #0x0
 8007a06: f8c7 30a8    	str.w	r3, [r7, #0xa8]
 8007a0a: f8c7 20ac    	str.w	r2, [r7, #0xac]
 8007a0e: e9d7 892a    	ldrd	r8, r9, [r7, #168]
 8007a12: 4642         	mov	r2, r8
 8007a14: 464b         	mov	r3, r9
 8007a16: 1891         	adds	r1, r2, r2
 8007a18: 6239         	str	r1, [r7, #0x20]
 8007a1a: 415b         	adcs	r3, r3
 8007a1c: 627b         	str	r3, [r7, #0x24]
 8007a1e: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 8007a22: 4641         	mov	r1, r8
 8007a24: 1854         	adds	r4, r2, r1
 8007a26: 46cc         	mov	r12, r9
 8007a28: eb43 050c    	adc.w	r5, r3, r12
 8007a2c: f04f 0200    	mov.w	r2, #0x0
 8007a30: f04f 0300    	mov.w	r3, #0x0
 8007a34: 00eb         	lsls	r3, r5, #0x3
 8007a36: ea43 7354    	orr.w	r3, r3, r4, lsr #29
 8007a3a: 00e2         	lsls	r2, r4, #0x3
 8007a3c: 4614         	mov	r4, r2
 8007a3e: 461d         	mov	r5, r3
 8007a40: 4640         	mov	r0, r8
 8007a42: 4649         	mov	r1, r9
 8007a44: 4603         	mov	r3, r0
 8007a46: 18e3         	adds	r3, r4, r3
 8007a48: f8c7 30a0    	str.w	r3, [r7, #0xa0]
 8007a4c: 460b         	mov	r3, r1
 8007a4e: eb45 0303    	adc.w	r3, r5, r3
 8007a52: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 8007a56: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8007a5a: 2200         	movs	r2, #0x0
 8007a5c: f8c7 3098    	str.w	r3, [r7, #0x98]
 8007a60: f8c7 209c    	str.w	r2, [r7, #0x9c]
 8007a64: f04f 0200    	mov.w	r2, #0x0
 8007a68: f04f 0300    	mov.w	r3, #0x0
 8007a6c: e9d7 4526    	ldrd	r4, r5, [r7, #152]
 8007a70: 4629         	mov	r1, r5
 8007a72: 008b         	lsls	r3, r1, #0x2
 8007a74: 4620         	mov	r0, r4
 8007a76: 4629         	mov	r1, r5
 8007a78: 4604         	mov	r4, r0
 8007a7a: ea43 7394    	orr.w	r3, r3, r4, lsr #30
 8007a7e: 4601         	mov	r1, r0
 8007a80: 008a         	lsls	r2, r1, #0x2
 8007a82: e9d7 0128    	ldrd	r0, r1, [r7, #160]
 8007a86: f7f9 f835    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x6f96
 8007a8a: 4602         	mov	r2, r0
 8007a8c: 460b         	mov	r3, r1
 8007a8e: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8007c24 <LL_USART_SetBaudRate+0x464>
 8007a90: fba3 2302    	umull	r2, r3, r3, r2
 8007a94: 095b         	lsrs	r3, r3, #0x5
 8007a96: b29b         	uxth	r3, r3
 8007a98: 011b         	lsls	r3, r3, #0x4
 8007a9a: b29c         	uxth	r4, r3
 8007a9c: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8007aa0: 2200         	movs	r2, #0x0
 8007aa2: f8c7 3090    	str.w	r3, [r7, #0x90]
 8007aa6: f8c7 2094    	str.w	r2, [r7, #0x94]
 8007aaa: e9d7 8924    	ldrd	r8, r9, [r7, #144]
 8007aae: 4642         	mov	r2, r8
 8007ab0: 464b         	mov	r3, r9
 8007ab2: 1891         	adds	r1, r2, r2
 8007ab4: 61b9         	str	r1, [r7, #0x18]
 8007ab6: 415b         	adcs	r3, r3
 8007ab8: 61fb         	str	r3, [r7, #0x1c]
 8007aba: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8007abe: 4641         	mov	r1, r8
 8007ac0: 1851         	adds	r1, r2, r1
 8007ac2: 6139         	str	r1, [r7, #0x10]
 8007ac4: 4649         	mov	r1, r9
 8007ac6: 414b         	adcs	r3, r1
 8007ac8: 617b         	str	r3, [r7, #0x14]
 8007aca: f04f 0200    	mov.w	r2, #0x0
 8007ace: f04f 0300    	mov.w	r3, #0x0
 8007ad2: e9d7 ab04    	ldrd	r10, r11, [r7, #16]
 8007ad6: 4659         	mov	r1, r11
 8007ad8: 00cb         	lsls	r3, r1, #0x3
 8007ada: 4655         	mov	r5, r10
 8007adc: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8007ae0: 4651         	mov	r1, r10
 8007ae2: 00ca         	lsls	r2, r1, #0x3
 8007ae4: 4610         	mov	r0, r2
 8007ae6: 4619         	mov	r1, r3
 8007ae8: 4603         	mov	r3, r0
 8007aea: 4642         	mov	r2, r8
 8007aec: 189b         	adds	r3, r3, r2
 8007aee: f8c7 3088    	str.w	r3, [r7, #0x88]
 8007af2: 464b         	mov	r3, r9
 8007af4: 460a         	mov	r2, r1
 8007af6: eb42 0303    	adc.w	r3, r2, r3
 8007afa: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8007afe: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8007b02: 2200         	movs	r2, #0x0
 8007b04: f8c7 3080    	str.w	r3, [r7, #0x80]
 8007b08: f8c7 2084    	str.w	r2, [r7, #0x84]
 8007b0c: f04f 0200    	mov.w	r2, #0x0
 8007b10: f04f 0300    	mov.w	r3, #0x0
 8007b14: e9d7 8920    	ldrd	r8, r9, [r7, #128]
 8007b18: 4649         	mov	r1, r9
 8007b1a: 008b         	lsls	r3, r1, #0x2
 8007b1c: 4645         	mov	r5, r8
 8007b1e: ea43 7395    	orr.w	r3, r3, r5, lsr #30
 8007b22: 4641         	mov	r1, r8
 8007b24: 008a         	lsls	r2, r1, #0x2
 8007b26: e9d7 0122    	ldrd	r0, r1, [r7, #136]
 8007b2a: f7f8 ffe3    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x703a
 8007b2e: 4602         	mov	r2, r0
 8007b30: 460b         	mov	r3, r1
 8007b32: 4611         	mov	r1, r2
 8007b34: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8007c24 <LL_USART_SetBaudRate+0x464>
 8007b36: fba3 2301    	umull	r2, r3, r3, r1
 8007b3a: 095b         	lsrs	r3, r3, #0x5
 8007b3c: 2264         	movs	r2, #0x64
 8007b3e: fb02 f303    	mul	r3, r2, r3
 8007b42: 1acb         	subs	r3, r1, r3
 8007b44: 011b         	lsls	r3, r3, #0x4
 8007b46: 3332         	adds	r3, #0x32
 8007b48: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x8007c24 <LL_USART_SetBaudRate+0x464>
 8007b4a: fba2 2303    	umull	r2, r3, r2, r3
 8007b4e: 095b         	lsrs	r3, r3, #0x5
 8007b50: b29b         	uxth	r3, r3
 8007b52: f003 03f0    	and	r3, r3, #0xf0
 8007b56: b29b         	uxth	r3, r3
 8007b58: 4423         	add	r3, r4
 8007b5a: b29c         	uxth	r4, r3
 8007b5c: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8007b60: 2200         	movs	r2, #0x0
 8007b62: 67bb         	str	r3, [r7, #0x78]
 8007b64: 67fa         	str	r2, [r7, #0x7c]
 8007b66: e9d7 891e    	ldrd	r8, r9, [r7, #120]
 8007b6a: 4642         	mov	r2, r8
 8007b6c: 464b         	mov	r3, r9
 8007b6e: 1891         	adds	r1, r2, r2
 8007b70: 60b9         	str	r1, [r7, #0x8]
 8007b72: 415b         	adcs	r3, r3
 8007b74: 60fb         	str	r3, [r7, #0xc]
 8007b76: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 8007b7a: 4641         	mov	r1, r8
 8007b7c: 1851         	adds	r1, r2, r1
 8007b7e: 6039         	str	r1, [r7]
 8007b80: 4649         	mov	r1, r9
 8007b82: 414b         	adcs	r3, r1
 8007b84: 607b         	str	r3, [r7, #0x4]
 8007b86: f04f 0200    	mov.w	r2, #0x0
 8007b8a: f04f 0300    	mov.w	r3, #0x0
 8007b8e: e9d7 ab00    	ldrd	r10, r11, [r7]
 8007b92: 4659         	mov	r1, r11
 8007b94: 00cb         	lsls	r3, r1, #0x3
 8007b96: 4655         	mov	r5, r10
 8007b98: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8007b9c: 4651         	mov	r1, r10
 8007b9e: 00ca         	lsls	r2, r1, #0x3
 8007ba0: 4610         	mov	r0, r2
 8007ba2: 4619         	mov	r1, r3
 8007ba4: 4603         	mov	r3, r0
 8007ba6: 4642         	mov	r2, r8
 8007ba8: 189b         	adds	r3, r3, r2
 8007baa: 673b         	str	r3, [r7, #0x70]
 8007bac: 464b         	mov	r3, r9
 8007bae: 460a         	mov	r2, r1
 8007bb0: eb42 0303    	adc.w	r3, r2, r3
 8007bb4: 677b         	str	r3, [r7, #0x74]
 8007bb6: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8007bba: 2200         	movs	r2, #0x0
 8007bbc: 66bb         	str	r3, [r7, #0x68]
 8007bbe: 66fa         	str	r2, [r7, #0x6c]
 8007bc0: f04f 0200    	mov.w	r2, #0x0
 8007bc4: f04f 0300    	mov.w	r3, #0x0
 8007bc8: e9d7 891a    	ldrd	r8, r9, [r7, #104]
 8007bcc: 4649         	mov	r1, r9
 8007bce: 008b         	lsls	r3, r1, #0x2
 8007bd0: 4645         	mov	r5, r8
 8007bd2: ea43 7395    	orr.w	r3, r3, r5, lsr #30
 8007bd6: 4641         	mov	r1, r8
 8007bd8: 008a         	lsls	r2, r1, #0x2
 8007bda: e9d7 011c    	ldrd	r0, r1, [r7, #112]
 8007bde: f7f8 ff89    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x70ee
 8007be2: 4602         	mov	r2, r0
 8007be4: 460b         	mov	r3, r1
 8007be6: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8007c24 <LL_USART_SetBaudRate+0x464>
 8007be8: fba3 1302    	umull	r1, r3, r3, r2
 8007bec: 095b         	lsrs	r3, r3, #0x5
 8007bee: 2164         	movs	r1, #0x64
 8007bf0: fb01 f303    	mul	r3, r1, r3
 8007bf4: 1ad3         	subs	r3, r2, r3
 8007bf6: 011b         	lsls	r3, r3, #0x4
 8007bf8: 3332         	adds	r3, #0x32
 8007bfa: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007c24 <LL_USART_SetBaudRate+0x464>
 8007bfc: fba2 2303    	umull	r2, r3, r2, r3
 8007c00: 095b         	lsrs	r3, r3, #0x5
 8007c02: b29b         	uxth	r3, r3
 8007c04: f003 030f    	and	r3, r3, #0xf
 8007c08: b29b         	uxth	r3, r3
 8007c0a: 4423         	add	r3, r4
 8007c0c: b29b         	uxth	r3, r3
 8007c0e: 461a         	mov	r2, r3
 8007c10: f8d7 30fc    	ldr.w	r3, [r7, #0xfc]
 8007c14: 609a         	str	r2, [r3, #0x8]
; }
 8007c16: bf00         	nop
 8007c18: f507 7780    	add.w	r7, r7, #0x100
 8007c1c: 46bd         	mov	sp, r7
 8007c1e: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 8007c22: bf00         	nop

08007c24 <$d>:
 8007c24: 1f 85 eb 51  	.word	0x51eb851f

08007c28 <uart_stm32_set_baudrate>:
; {
 8007c28: b580         	push	{r7, lr}
 8007c2a: b08c         	sub	sp, #0x30
 8007c2c: af04         	add	r7, sp, #0x10
 8007c2e: 6078         	str	r0, [r7, #0x4]
 8007c30: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8007c32: 687b         	ldr	r3, [r7, #0x4]
 8007c34: 685b         	ldr	r3, [r3, #0x4]
 8007c36: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 8007c38: 69bb         	ldr	r3, [r7, #0x18]
 8007c3a: 681b         	ldr	r3, [r3]
 8007c3c: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = dev->data;
 8007c3e: 687b         	ldr	r3, [r7, #0x4]
 8007c40: 691b         	ldr	r3, [r3, #0x10]
 8007c42: 61fb         	str	r3, [r7, #0x1c]
; 		if (clock_control_get_rate(data->clock,
 8007c44: 69fb         	ldr	r3, [r7, #0x1c]
 8007c46: 6818         	ldr	r0, [r3]
; 					   (clock_control_subsys_t)&config->pclken[0],
 8007c48: 69bb         	ldr	r3, [r7, #0x18]
 8007c4a: 68db         	ldr	r3, [r3, #0xc]
; 		if (clock_control_get_rate(data->clock,
 8007c4c: f107 0208    	add.w	r2, r7, #0x8
 8007c50: 4619         	mov	r1, r3
 8007c52: f00e f82f    	bl	0x8015cb4 <clock_control_get_rate> @ imm = #0xe05e
 8007c56: 4603         	mov	r3, r0
 8007c58: 2b00         	cmp	r3, #0x0
 8007c5a: da1a         	bge	0x8007c92 <uart_stm32_set_baudrate+0x6a> @ imm = #0x34
; 			LOG_ERR("Failed call clock_control_get_rate(pclken[0])");
 8007c5c: 2303         	movs	r3, #0x3
 8007c5e: 2b00         	cmp	r3, #0x0
 8007c60: d021         	beq	0x8007ca6 <uart_stm32_set_baudrate+0x7e> @ imm = #0x42
 8007c62: 2301         	movs	r3, #0x1
 8007c64: 74fb         	strb	r3, [r7, #0x13]
 8007c66: 7cfb         	ldrb	r3, [r7, #0x13]
 8007c68: f083 0301    	eor	r3, r3, #0x1
 8007c6c: b2db         	uxtb	r3, r3
 8007c6e: 2b00         	cmp	r3, #0x0
 8007c70: d119         	bne	0x8007ca6 <uart_stm32_set_baudrate+0x7e> @ imm = #0x32
 8007c72: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8007cac <uart_stm32_set_baudrate+0x84>
 8007c74: 6819         	ldr	r1, [r3]
 8007c76: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8007cb0 <uart_stm32_set_baudrate+0x88>
 8007c78: 9302         	str	r3, [sp, #0x8]
 8007c7a: 2300         	movs	r3, #0x0
 8007c7c: 9301         	str	r3, [sp, #0x4]
 8007c7e: 2300         	movs	r3, #0x0
 8007c80: 9300         	str	r3, [sp]
 8007c82: 2300         	movs	r3, #0x0
 8007c84: 2201         	movs	r2, #0x1
 8007c86: 2000         	movs	r0, #0x0
 8007c88: f00e fd76    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xeaec
 8007c8c: 2300         	movs	r3, #0x0
 8007c8e: 60fb         	str	r3, [r7, #0xc]
; 			return;
 8007c90: e009         	b	0x8007ca6 <uart_stm32_set_baudrate+0x7e> @ imm = #0x12
; 		LL_USART_SetOverSampling(usart,
 8007c92: 2100         	movs	r1, #0x0
 8007c94: 6978         	ldr	r0, [r7, #0x14]
 8007c96: f00e f9a0    	bl	0x8015fda <LL_USART_SetOverSampling> @ imm = #0xe340
; 		LL_USART_SetBaudRate(usart,
 8007c9a: 68b9         	ldr	r1, [r7, #0x8]
 8007c9c: 683b         	ldr	r3, [r7]
 8007c9e: 2200         	movs	r2, #0x0
 8007ca0: 6978         	ldr	r0, [r7, #0x14]
 8007ca2: f7ff fd8d    	bl	0x80077c0 <LL_USART_SetBaudRate> @ imm = #-0x4e6
; }
 8007ca6: 3720         	adds	r7, #0x20
 8007ca8: 46bd         	mov	sp, r7
 8007caa: bd80         	pop	{r7, pc}

08007cac <$d>:
 8007cac: 60 04 00 20  	.word	0x20000460
 8007cb0: d4 c3 01 08  	.word	0x0801c3d4

08007cb4 <uart_stm32_configure>:
; {
 8007cb4: b580         	push	{r7, lr}
 8007cb6: b08a         	sub	sp, #0x28
 8007cb8: af00         	add	r7, sp, #0x0
 8007cba: 6078         	str	r0, [r7, #0x4]
 8007cbc: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8007cbe: 687b         	ldr	r3, [r7, #0x4]
 8007cc0: 685b         	ldr	r3, [r3, #0x4]
 8007cc2: 627b         	str	r3, [r7, #0x24]
; 	USART_TypeDef *usart = config->usart;
 8007cc4: 6a7b         	ldr	r3, [r7, #0x24]
 8007cc6: 681b         	ldr	r3, [r3]
 8007cc8: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 8007cca: 687b         	ldr	r3, [r7, #0x4]
 8007ccc: 691b         	ldr	r3, [r3, #0x10]
 8007cce: 61fb         	str	r3, [r7, #0x1c]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 8007cd0: 69fb         	ldr	r3, [r7, #0x1c]
 8007cd2: 685b         	ldr	r3, [r3, #0x4]
 8007cd4: 61bb         	str	r3, [r7, #0x18]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 8007cd6: 683b         	ldr	r3, [r7]
 8007cd8: 791b         	ldrb	r3, [r3, #0x4]
 8007cda: 4618         	mov	r0, r3
 8007cdc: f00e fdf6    	bl	0x80168cc <uart_stm32_cfg2ll_parity> @ imm = #0xebec
 8007ce0: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 8007ce2: 683b         	ldr	r3, [r7]
 8007ce4: 795b         	ldrb	r3, [r3, #0x5]
 8007ce6: 4619         	mov	r1, r3
 8007ce8: 6a78         	ldr	r0, [r7, #0x24]
 8007cea: f00e fe1c    	bl	0x8016926 <uart_stm32_cfg2ll_stopbits> @ imm = #0xec38
 8007cee: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 8007cf0: 683b         	ldr	r3, [r7]
 8007cf2: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 8007cf4: 683b         	ldr	r3, [r7]
 8007cf6: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 8007cf8: 4619         	mov	r1, r3
 8007cfa: 4610         	mov	r0, r2
 8007cfc: f00e fe51    	bl	0x80169a2 <uart_stm32_cfg2ll_databits> @ imm = #0xeca2
 8007d00: 60f8         	str	r0, [r7, #0xc]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 8007d02: 683b         	ldr	r3, [r7]
 8007d04: 791b         	ldrb	r3, [r3, #0x4]
 8007d06: 2b03         	cmp	r3, #0x3
 8007d08: d003         	beq	0x8007d12 <uart_stm32_configure+0x5e> @ imm = #0x6
; 	    (cfg->parity == UART_CFG_PARITY_SPACE)) {
 8007d0a: 683b         	ldr	r3, [r7]
 8007d0c: 791b         	ldrb	r3, [r3, #0x4]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 8007d0e: 2b04         	cmp	r3, #0x4
 8007d10: d102         	bne	0x8007d18 <uart_stm32_configure+0x64> @ imm = #0x4
; 		return -ENOTSUP;
 8007d12: f06f 0385    	mvn	r3, #0x85
 8007d16: e04f         	b	0x8007db8 <uart_stm32_configure+0x104> @ imm = #0x9e
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 8007d18: 683b         	ldr	r3, [r7]
 8007d1a: 791b         	ldrb	r3, [r3, #0x4]
 8007d1c: 2b00         	cmp	r3, #0x0
 8007d1e: d006         	beq	0x8007d2e <uart_stm32_configure+0x7a> @ imm = #0xc
; 	    (cfg->data_bits == UART_CFG_DATA_BITS_9)) {
 8007d20: 683b         	ldr	r3, [r7]
 8007d22: 799b         	ldrb	r3, [r3, #0x6]
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 8007d24: 2b04         	cmp	r3, #0x4
 8007d26: d102         	bne	0x8007d2e <uart_stm32_configure+0x7a> @ imm = #0x4
; 		return -ENOTSUP;
 8007d28: f06f 0385    	mvn	r3, #0x85
 8007d2c: e044         	b	0x8007db8 <uart_stm32_configure+0x104> @ imm = #0x88
; 	if (uart_stm32_ll2cfg_stopbits(stopbits) != cfg->stop_bits) {
 8007d2e: 6938         	ldr	r0, [r7, #0x10]
 8007d30: f00e fe18    	bl	0x8016964 <uart_stm32_ll2cfg_stopbits> @ imm = #0xec30
 8007d34: 4603         	mov	r3, r0
 8007d36: 461a         	mov	r2, r3
 8007d38: 683b         	ldr	r3, [r7]
 8007d3a: 795b         	ldrb	r3, [r3, #0x5]
 8007d3c: 429a         	cmp	r2, r3
 8007d3e: d002         	beq	0x8007d46 <uart_stm32_configure+0x92> @ imm = #0x4
; 		return -ENOTSUP;
 8007d40: f06f 0385    	mvn	r3, #0x85
 8007d44: e038         	b	0x8007db8 <uart_stm32_configure+0x104> @ imm = #0x70
; 	if (uart_stm32_ll2cfg_databits(databits, parity) != cfg->data_bits) {
 8007d46: 6979         	ldr	r1, [r7, #0x14]
 8007d48: 68f8         	ldr	r0, [r7, #0xc]
 8007d4a: f00e fe44    	bl	0x80169d6 <uart_stm32_ll2cfg_databits> @ imm = #0xec88
 8007d4e: 4603         	mov	r3, r0
 8007d50: 461a         	mov	r2, r3
 8007d52: 683b         	ldr	r3, [r7]
 8007d54: 799b         	ldrb	r3, [r3, #0x6]
 8007d56: 429a         	cmp	r2, r3
 8007d58: d002         	beq	0x8007d60 <uart_stm32_configure+0xac> @ imm = #0x4
; 		return -ENOTSUP;
 8007d5a: f06f 0385    	mvn	r3, #0x85
 8007d5e: e02b         	b	0x8007db8 <uart_stm32_configure+0x104> @ imm = #0x56
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 8007d60: 683b         	ldr	r3, [r7]
 8007d62: 79db         	ldrb	r3, [r3, #0x7]
 8007d64: 2b00         	cmp	r3, #0x0
 8007d66: d016         	beq	0x8007d96 <uart_stm32_configure+0xe2> @ imm = #0x2c
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 8007d68: 683b         	ldr	r3, [r7]
 8007d6a: 79db         	ldrb	r3, [r3, #0x7]
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 8007d6c: 2b01         	cmp	r3, #0x1
 8007d6e: d10f         	bne	0x8007d90 <uart_stm32_configure+0xdc> @ imm = #0x1e
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 8007d70: 6a3b         	ldr	r3, [r7, #0x20]
 8007d72: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x8007dc0 <uart_stm32_configure+0x10c>
 8007d74: 4293         	cmp	r3, r2
 8007d76: d00e         	beq	0x8007d96 <uart_stm32_configure+0xe2> @ imm = #0x1c
; 			IS_UART_HWFLOW_INSTANCE(usart))
 8007d78: 6a3b         	ldr	r3, [r7, #0x20]
 8007d7a: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8007dc4 <uart_stm32_configure+0x110>
 8007d7c: 4293         	cmp	r3, r2
 8007d7e: d00a         	beq	0x8007d96 <uart_stm32_configure+0xe2> @ imm = #0x14
 8007d80: 6a3b         	ldr	r3, [r7, #0x20]
 8007d82: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8007dc8 <uart_stm32_configure+0x114>
 8007d84: 4293         	cmp	r3, r2
 8007d86: d006         	beq	0x8007d96 <uart_stm32_configure+0xe2> @ imm = #0xc
 8007d88: 6a3b         	ldr	r3, [r7, #0x20]
 8007d8a: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8007dcc <uart_stm32_configure+0x118>
 8007d8c: 4293         	cmp	r3, r2
 8007d8e: d002         	beq	0x8007d96 <uart_stm32_configure+0xe2> @ imm = #0x4
; 		return -ENOTSUP;
 8007d90: f06f 0385    	mvn	r3, #0x85
 8007d94: e010         	b	0x8007db8 <uart_stm32_configure+0x104> @ imm = #0x20
; 	LL_USART_Disable(usart);
 8007d96: 6a38         	ldr	r0, [r7, #0x20]
 8007d98: f00e f8ad    	bl	0x8015ef6 <LL_USART_Disable> @ imm = #0xe15a
; 	uart_stm32_parameters_set(dev, cfg);
 8007d9c: 6839         	ldr	r1, [r7]
 8007d9e: 6878         	ldr	r0, [r7, #0x4]
 8007da0: f00e fe5a    	bl	0x8016a58 <uart_stm32_parameters_set> @ imm = #0xecb4
; 	LL_USART_Enable(usart);
 8007da4: 6a38         	ldr	r0, [r7, #0x20]
 8007da6: f00e f897    	bl	0x8015ed8 <LL_USART_Enable> @ imm = #0xe12e
; 	*uart_cfg = *cfg;
 8007daa: 69bb         	ldr	r3, [r7, #0x18]
 8007dac: 683a         	ldr	r2, [r7]
 8007dae: e892 0003    	ldm.w	r2, {r0, r1}
 8007db2: e883 0003    	stm.w	r3, {r0, r1}
; 	return 0;
 8007db6: 2300         	movs	r3, #0x0
; };
 8007db8: 4618         	mov	r0, r3
 8007dba: 3728         	adds	r7, #0x28
 8007dbc: 46bd         	mov	sp, r7
 8007dbe: bd80         	pop	{r7, pc}

08007dc0 <$d>:
 8007dc0: 00 10 01 40  	.word	0x40011000
 8007dc4: 00 44 00 40  	.word	0x40004400
 8007dc8: 00 48 00 40  	.word	0x40004800
 8007dcc: 00 14 01 40  	.word	0x40011400

08007dd0 <uart_stm32_poll_in>:
; {
 8007dd0: b580         	push	{r7, lr}
 8007dd2: b082         	sub	sp, #0x8
 8007dd4: af00         	add	r7, sp, #0x0
 8007dd6: 6078         	str	r0, [r7, #0x4]
 8007dd8: 6039         	str	r1, [r7]
; 	return uart_stm32_poll_in_visitor(dev, (void *)c, poll_in_u8);
 8007dda: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8007df0 <uart_stm32_poll_in+0x20>
 8007ddc: 6839         	ldr	r1, [r7]
 8007dde: 6878         	ldr	r0, [r7, #0x4]
 8007de0: f00e feff    	bl	0x8016be2 <uart_stm32_poll_in_visitor> @ imm = #0xedfe
 8007de4: 4603         	mov	r3, r0
; }
 8007de6: 4618         	mov	r0, r3
 8007de8: 3708         	adds	r7, #0x8
 8007dea: 46bd         	mov	sp, r7
 8007dec: bd80         	pop	{r7, pc}
 8007dee: bf00         	nop

08007df0 <$d>:
 8007df0: c9 6c 01 08  	.word	0x08016cc9

08007df4 <uart_stm32_poll_out>:
; {
 8007df4: b580         	push	{r7, lr}
 8007df6: b082         	sub	sp, #0x8
 8007df8: af00         	add	r7, sp, #0x0
 8007dfa: 6078         	str	r0, [r7, #0x4]
 8007dfc: 460b         	mov	r3, r1
 8007dfe: 70fb         	strb	r3, [r7, #0x3]
; 	uart_stm32_poll_out_visitor(dev, c, poll_out_u8);
 8007e00: 78fb         	ldrb	r3, [r7, #0x3]
 8007e02: b29b         	uxth	r3, r3
 8007e04: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8007e18 <uart_stm32_poll_out+0x24>
 8007e06: 4619         	mov	r1, r3
 8007e08: 6878         	ldr	r0, [r7, #0x4]
 8007e0a: f00e ff11    	bl	0x8016c30 <uart_stm32_poll_out_visitor> @ imm = #0xee22
; }
 8007e0e: bf00         	nop
 8007e10: 3708         	adds	r7, #0x8
 8007e12: 46bd         	mov	sp, r7
 8007e14: bd80         	pop	{r7, pc}
 8007e16: bf00         	nop

08007e18 <$d>:
 8007e18: e9 6c 01 08  	.word	0x08016ce9

08007e1c <__uart_stm32_get_clock>:
; {
 8007e1c: b480         	push	{r7}
 8007e1e: b085         	sub	sp, #0x14
 8007e20: af00         	add	r7, sp, #0x0
 8007e22: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 8007e24: 687b         	ldr	r3, [r7, #0x4]
 8007e26: 691b         	ldr	r3, [r3, #0x10]
 8007e28: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8007e2a: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8007e40 <__uart_stm32_get_clock+0x24>
 8007e2c: 60bb         	str	r3, [r7, #0x8]
; 	data->clock = clk;
 8007e2e: 68fb         	ldr	r3, [r7, #0xc]
 8007e30: 68ba         	ldr	r2, [r7, #0x8]
 8007e32: 601a         	str	r2, [r3]
; }
 8007e34: bf00         	nop
 8007e36: 3714         	adds	r7, #0x14
 8007e38: 46bd         	mov	sp, r7
 8007e3a: bc80         	pop	{r7}
 8007e3c: 4770         	bx	lr
 8007e3e: bf00         	nop

08007e40 <$d>:
 8007e40: d8 ac 01 08  	.word	0x0801acd8

08007e44 <uart_stm32_fifo_fill>:
; {
 8007e44: b590         	push	{r4, r7, lr}
 8007e46: b085         	sub	sp, #0x14
 8007e48: af00         	add	r7, sp, #0x0
 8007e4a: 60f8         	str	r0, [r7, #0xc]
 8007e4c: 60b9         	str	r1, [r7, #0x8]
 8007e4e: 607a         	str	r2, [r7, #0x4]
; 	if (uart_stm32_ll2cfg_databits(uart_stm32_get_databits(dev), uart_stm32_get_parity(dev)) ==
 8007e50: 68f8         	ldr	r0, [r7, #0xc]
 8007e52: f00e fd07    	bl	0x8016864 <uart_stm32_get_databits> @ imm = #0xea0e
 8007e56: 4604         	mov	r4, r0
 8007e58: 68f8         	ldr	r0, [r7, #0xc]
 8007e5a: f00e fcbd    	bl	0x80167d8 <uart_stm32_get_parity> @ imm = #0xe97a
 8007e5e: 4603         	mov	r3, r0
 8007e60: 4619         	mov	r1, r3
 8007e62: 4620         	mov	r0, r4
 8007e64: f00e fdb7    	bl	0x80169d6 <uart_stm32_ll2cfg_databits> @ imm = #0xeb6e
 8007e68: 4603         	mov	r3, r0
 8007e6a: 2b04         	cmp	r3, #0x4
 8007e6c: d102         	bne	0x8007e74 <uart_stm32_fifo_fill+0x30> @ imm = #0x4
; 		return -ENOTSUP;
 8007e6e: f06f 0385    	mvn	r3, #0x85
 8007e72: e006         	b	0x8007e82 <uart_stm32_fifo_fill+0x3e> @ imm = #0xc
; 	return uart_stm32_fifo_fill_visitor(dev, (const void *)tx_data, size,
 8007e74: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8007e8c <uart_stm32_fifo_fill+0x48>
 8007e76: 687a         	ldr	r2, [r7, #0x4]
 8007e78: 68b9         	ldr	r1, [r7, #0x8]
 8007e7a: 68f8         	ldr	r0, [r7, #0xc]
 8007e7c: f00e ffaf    	bl	0x8016dde <uart_stm32_fifo_fill_visitor> @ imm = #0xef5e
 8007e80: 4603         	mov	r3, r0
; }
 8007e82: 4618         	mov	r0, r3
 8007e84: 3714         	adds	r7, #0x14
 8007e86: 46bd         	mov	sp, r7
 8007e88: bd90         	pop	{r4, r7, pc}
 8007e8a: bf00         	nop

08007e8c <$d>:
 8007e8c: 77 6e 01 08  	.word	0x08016e77

08007e90 <uart_stm32_fifo_read>:
; {
 8007e90: b590         	push	{r4, r7, lr}
 8007e92: b085         	sub	sp, #0x14
 8007e94: af00         	add	r7, sp, #0x0
 8007e96: 60f8         	str	r0, [r7, #0xc]
 8007e98: 60b9         	str	r1, [r7, #0x8]
 8007e9a: 607a         	str	r2, [r7, #0x4]
; 	if (uart_stm32_ll2cfg_databits(uart_stm32_get_databits(dev), uart_stm32_get_parity(dev)) ==
 8007e9c: 68f8         	ldr	r0, [r7, #0xc]
 8007e9e: f00e fce1    	bl	0x8016864 <uart_stm32_get_databits> @ imm = #0xe9c2
 8007ea2: 4604         	mov	r4, r0
 8007ea4: 68f8         	ldr	r0, [r7, #0xc]
 8007ea6: f00e fc97    	bl	0x80167d8 <uart_stm32_get_parity> @ imm = #0xe92e
 8007eaa: 4603         	mov	r3, r0
 8007eac: 4619         	mov	r1, r3
 8007eae: 4620         	mov	r0, r4
 8007eb0: f00e fd91    	bl	0x80169d6 <uart_stm32_ll2cfg_databits> @ imm = #0xeb22
 8007eb4: 4603         	mov	r3, r0
 8007eb6: 2b04         	cmp	r3, #0x4
 8007eb8: d102         	bne	0x8007ec0 <uart_stm32_fifo_read+0x30> @ imm = #0x4
; 		return -ENOTSUP;
 8007eba: f06f 0385    	mvn	r3, #0x85
 8007ebe: e006         	b	0x8007ece <uart_stm32_fifo_read+0x3e> @ imm = #0xc
; 	return uart_stm32_fifo_read_visitor(dev, (void *)rx_data, size,
 8007ec0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8007ed8 <uart_stm32_fifo_read+0x48>
 8007ec2: 687a         	ldr	r2, [r7, #0x4]
 8007ec4: 68b9         	ldr	r1, [r7, #0x8]
 8007ec6: 68f8         	ldr	r0, [r7, #0xc]
 8007ec8: f00e ffe9    	bl	0x8016e9e <uart_stm32_fifo_read_visitor> @ imm = #0xefd2
 8007ecc: 4603         	mov	r3, r0
; }
 8007ece: 4618         	mov	r0, r3
 8007ed0: 3714         	adds	r7, #0x14
 8007ed2: 46bd         	mov	sp, r7
 8007ed4: bd90         	pop	{r4, r7, pc}
 8007ed6: bf00         	nop

08007ed8 <$d>:
 8007ed8: 01 6f 01 08  	.word	0x08016f01

08007edc <uart_stm32_irq_err_enable>:
; {
 8007edc: b580         	push	{r7, lr}
 8007ede: b084         	sub	sp, #0x10
 8007ee0: af00         	add	r7, sp, #0x0
 8007ee2: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8007ee4: 687b         	ldr	r3, [r7, #0x4]
 8007ee6: 685b         	ldr	r3, [r3, #0x4]
 8007ee8: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 8007eea: 68fb         	ldr	r3, [r7, #0xc]
 8007eec: 681b         	ldr	r3, [r3]
 8007eee: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_EnableIT_ERROR(usart);
 8007ef0: 68b8         	ldr	r0, [r7, #0x8]
 8007ef2: f00e faa5    	bl	0x8016440 <LL_USART_EnableIT_ERROR> @ imm = #0xe54a
; 	if (IS_UART_LIN_INSTANCE(usart)) {
 8007ef6: 68bb         	ldr	r3, [r7, #0x8]
 8007ef8: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8007f3c <uart_stm32_irq_err_enable+0x60>
 8007efa: 4293         	cmp	r3, r2
 8007efc: d013         	beq	0x8007f26 <uart_stm32_irq_err_enable+0x4a> @ imm = #0x26
 8007efe: 68bb         	ldr	r3, [r7, #0x8]
 8007f00: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8007f40 <uart_stm32_irq_err_enable+0x64>
 8007f02: 4293         	cmp	r3, r2
 8007f04: d00f         	beq	0x8007f26 <uart_stm32_irq_err_enable+0x4a> @ imm = #0x1e
 8007f06: 68bb         	ldr	r3, [r7, #0x8]
 8007f08: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8007f44 <uart_stm32_irq_err_enable+0x68>
 8007f0a: 4293         	cmp	r3, r2
 8007f0c: d00b         	beq	0x8007f26 <uart_stm32_irq_err_enable+0x4a> @ imm = #0x16
 8007f0e: 68bb         	ldr	r3, [r7, #0x8]
 8007f10: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8007f48 <uart_stm32_irq_err_enable+0x6c>
 8007f12: 4293         	cmp	r3, r2
 8007f14: d007         	beq	0x8007f26 <uart_stm32_irq_err_enable+0x4a> @ imm = #0xe
 8007f16: 68bb         	ldr	r3, [r7, #0x8]
 8007f18: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8007f4c <uart_stm32_irq_err_enable+0x70>
 8007f1a: 4293         	cmp	r3, r2
 8007f1c: d003         	beq	0x8007f26 <uart_stm32_irq_err_enable+0x4a> @ imm = #0x6
 8007f1e: 68bb         	ldr	r3, [r7, #0x8]
 8007f20: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8007f50 <uart_stm32_irq_err_enable+0x74>
 8007f22: 4293         	cmp	r3, r2
 8007f24: d102         	bne	0x8007f2c <uart_stm32_irq_err_enable+0x50> @ imm = #0x4
; 		LL_USART_EnableIT_LBD(usart);
 8007f26: 68b8         	ldr	r0, [r7, #0x8]
 8007f28: f00e fa7b    	bl	0x8016422 <LL_USART_EnableIT_LBD> @ imm = #0xe4f6
; 	LL_USART_EnableIT_PE(usart);
 8007f2c: 68b8         	ldr	r0, [r7, #0x8]
 8007f2e: f00e fa56    	bl	0x80163de <LL_USART_EnableIT_PE> @ imm = #0xe4ac
; }
 8007f32: bf00         	nop
 8007f34: 3710         	adds	r7, #0x10
 8007f36: 46bd         	mov	sp, r7
 8007f38: bd80         	pop	{r7, pc}
 8007f3a: bf00         	nop

08007f3c <$d>:
 8007f3c: 00 10 01 40  	.word	0x40011000
 8007f40: 00 44 00 40  	.word	0x40004400
 8007f44: 00 48 00 40  	.word	0x40004800
 8007f48: 00 4c 00 40  	.word	0x40004c00
 8007f4c: 00 50 00 40  	.word	0x40005000
 8007f50: 00 14 01 40  	.word	0x40011400

08007f54 <uart_stm32_irq_err_disable>:
; {
 8007f54: b580         	push	{r7, lr}
 8007f56: b084         	sub	sp, #0x10
 8007f58: af00         	add	r7, sp, #0x0
 8007f5a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8007f5c: 687b         	ldr	r3, [r7, #0x4]
 8007f5e: 685b         	ldr	r3, [r3, #0x4]
 8007f60: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 8007f62: 68fb         	ldr	r3, [r7, #0xc]
 8007f64: 681b         	ldr	r3, [r3]
 8007f66: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_DisableIT_ERROR(usart);
 8007f68: 68b8         	ldr	r0, [r7, #0x8]
 8007f6a: f00e fb22    	bl	0x80165b2 <LL_USART_DisableIT_ERROR> @ imm = #0xe644
; 	if (IS_UART_LIN_INSTANCE(usart)) {
 8007f6e: 68bb         	ldr	r3, [r7, #0x8]
 8007f70: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8007fb4 <uart_stm32_irq_err_disable+0x60>
 8007f72: 4293         	cmp	r3, r2
 8007f74: d013         	beq	0x8007f9e <uart_stm32_irq_err_disable+0x4a> @ imm = #0x26
 8007f76: 68bb         	ldr	r3, [r7, #0x8]
 8007f78: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8007fb8 <uart_stm32_irq_err_disable+0x64>
 8007f7a: 4293         	cmp	r3, r2
 8007f7c: d00f         	beq	0x8007f9e <uart_stm32_irq_err_disable+0x4a> @ imm = #0x1e
 8007f7e: 68bb         	ldr	r3, [r7, #0x8]
 8007f80: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8007fbc <uart_stm32_irq_err_disable+0x68>
 8007f82: 4293         	cmp	r3, r2
 8007f84: d00b         	beq	0x8007f9e <uart_stm32_irq_err_disable+0x4a> @ imm = #0x16
 8007f86: 68bb         	ldr	r3, [r7, #0x8]
 8007f88: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8007fc0 <uart_stm32_irq_err_disable+0x6c>
 8007f8a: 4293         	cmp	r3, r2
 8007f8c: d007         	beq	0x8007f9e <uart_stm32_irq_err_disable+0x4a> @ imm = #0xe
 8007f8e: 68bb         	ldr	r3, [r7, #0x8]
 8007f90: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8007fc4 <uart_stm32_irq_err_disable+0x70>
 8007f92: 4293         	cmp	r3, r2
 8007f94: d003         	beq	0x8007f9e <uart_stm32_irq_err_disable+0x4a> @ imm = #0x6
 8007f96: 68bb         	ldr	r3, [r7, #0x8]
 8007f98: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8007fc8 <uart_stm32_irq_err_disable+0x74>
 8007f9a: 4293         	cmp	r3, r2
 8007f9c: d102         	bne	0x8007fa4 <uart_stm32_irq_err_disable+0x50> @ imm = #0x4
; 		LL_USART_DisableIT_LBD(usart);
 8007f9e: 68b8         	ldr	r0, [r7, #0x8]
 8007fa0: f00e faf8    	bl	0x8016594 <LL_USART_DisableIT_LBD> @ imm = #0xe5f0
; 	LL_USART_DisableIT_PE(usart);
 8007fa4: 68b8         	ldr	r0, [r7, #0x8]
 8007fa6: f00e fad3    	bl	0x8016550 <LL_USART_DisableIT_PE> @ imm = #0xe5a6
; }
 8007faa: bf00         	nop
 8007fac: 3710         	adds	r7, #0x10
 8007fae: 46bd         	mov	sp, r7
 8007fb0: bd80         	pop	{r7, pc}
 8007fb2: bf00         	nop

08007fb4 <$d>:
 8007fb4: 00 10 01 40  	.word	0x40011000
 8007fb8: 00 44 00 40  	.word	0x40004400
 8007fbc: 00 48 00 40  	.word	0x40004800
 8007fc0: 00 4c 00 40  	.word	0x40004c00
 8007fc4: 00 50 00 40  	.word	0x40005000
 8007fc8: 00 14 01 40  	.word	0x40011400

08007fcc <async_evt_rx_rdy>:
; {
 8007fcc: b580         	push	{r7, lr}
 8007fce: b090         	sub	sp, #0x40
 8007fd0: af06         	add	r7, sp, #0x18
 8007fd2: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("rx_rdy: (%d %d)", data->dma_rx.offset, data->dma_rx.counter);
 8007fd4: 2303         	movs	r3, #0x3
 8007fd6: 2b03         	cmp	r3, #0x3
 8007fd8: d920         	bls	0x800801c <async_evt_rx_rdy+0x50> @ imm = #0x40
 8007fda: 2301         	movs	r3, #0x1
 8007fdc: f887 3027    	strb.w	r3, [r7, #0x27]
 8007fe0: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8007fe4: f083 0301    	eor	r3, r3, #0x1
 8007fe8: b2db         	uxtb	r3, r3
 8007fea: 2b00         	cmp	r3, #0x0
 8007fec: d116         	bne	0x800801c <async_evt_rx_rdy+0x50> @ imm = #0x2c
 8007fee: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800806c <async_evt_rx_rdy+0xa0>
 8007ff0: 6819         	ldr	r1, [r3]
 8007ff2: 687b         	ldr	r3, [r7, #0x4]
 8007ff4: 6f5b         	ldr	r3, [r3, #0x74]
 8007ff6: 687a         	ldr	r2, [r7, #0x4]
 8007ff8: 6f92         	ldr	r2, [r2, #0x78]
 8007ffa: 9205         	str	r2, [sp, #0x14]
 8007ffc: 9304         	str	r3, [sp, #0x10]
 8007ffe: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8008070 <async_evt_rx_rdy+0xa4>
 8008000: 9303         	str	r3, [sp, #0xc]
 8008002: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8008074 <async_evt_rx_rdy+0xa8>
 8008004: 9302         	str	r3, [sp, #0x8]
 8008006: 2308         	movs	r3, #0x8
 8008008: 9301         	str	r3, [sp, #0x4]
 800800a: 2300         	movs	r3, #0x0
 800800c: 9300         	str	r3, [sp]
 800800e: 2300         	movs	r3, #0x0
 8008010: 2204         	movs	r2, #0x4
 8008012: 2000         	movs	r0, #0x0
 8008014: f00e fbb0    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xe760
 8008018: 2300         	movs	r3, #0x0
 800801a: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800801c: f107 030c    	add.w	r3, r7, #0xc
 8008020: 2200         	movs	r2, #0x0
 8008022: 601a         	str	r2, [r3]
 8008024: 605a         	str	r2, [r3, #0x4]
 8008026: 609a         	str	r2, [r3, #0x8]
 8008028: 60da         	str	r2, [r3, #0xc]
 800802a: 611a         	str	r2, [r3, #0x10]
 800802c: 2302         	movs	r3, #0x2
 800802e: 733b         	strb	r3, [r7, #0xc]
; 		.data.rx.buf = data->dma_rx.buffer,
 8008030: 687b         	ldr	r3, [r7, #0x4]
 8008032: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event event = {
 8008034: 613b         	str	r3, [r7, #0x10]
; 		.data.rx.offset = data->dma_rx.offset
 8008036: 687b         	ldr	r3, [r7, #0x4]
 8008038: 6f5b         	ldr	r3, [r3, #0x74]
; 	struct uart_event event = {
 800803a: 617b         	str	r3, [r7, #0x14]
; 		.data.rx.len = data->dma_rx.counter - data->dma_rx.offset,
 800803c: 687b         	ldr	r3, [r7, #0x4]
 800803e: 6f9a         	ldr	r2, [r3, #0x78]
 8008040: 687b         	ldr	r3, [r7, #0x4]
 8008042: 6f5b         	ldr	r3, [r3, #0x74]
 8008044: 1ad3         	subs	r3, r2, r3
; 	struct uart_event event = {
 8008046: 61bb         	str	r3, [r7, #0x18]
; 	data->dma_rx.offset = data->dma_rx.counter;
 8008048: 687b         	ldr	r3, [r7, #0x4]
 800804a: 6f9a         	ldr	r2, [r3, #0x78]
 800804c: 687b         	ldr	r3, [r7, #0x4]
 800804e: 675a         	str	r2, [r3, #0x74]
; 	if (event.data.rx.len > 0) {
 8008050: 69bb         	ldr	r3, [r7, #0x18]
 8008052: 2b00         	cmp	r3, #0x0
 8008054: d005         	beq	0x8008062 <async_evt_rx_rdy+0x96> @ imm = #0xa
; 		async_user_callback(data, &event);
 8008056: f107 030c    	add.w	r3, r7, #0xc
 800805a: 4619         	mov	r1, r3
 800805c: 6878         	ldr	r0, [r7, #0x4]
 800805e: f00f f830    	bl	0x80170c2 <async_user_callback> @ imm = #0xf060
; }
 8008062: bf00         	nop
 8008064: 3728         	adds	r7, #0x28
 8008066: 46bd         	mov	sp, r7
 8008068: bd80         	pop	{r7, pc}
 800806a: bf00         	nop

0800806c <$d>:
 800806c: 60 04 00 20  	.word	0x20000460
 8008070: c4 d5 01 08  	.word	0x0801d5c4
 8008074: 04 c4 01 08  	.word	0x0801c404

08008078 <async_evt_rx_err>:
; {
 8008078: b580         	push	{r7, lr}
 800807a: b090         	sub	sp, #0x40
 800807c: af06         	add	r7, sp, #0x18
 800807e: 6078         	str	r0, [r7, #0x4]
 8008080: 6039         	str	r1, [r7]
; 	LOG_DBG("rx error: %d", err_code);
 8008082: 2303         	movs	r3, #0x3
 8008084: 2b03         	cmp	r3, #0x3
 8008086: d91c         	bls	0x80080c2 <async_evt_rx_err+0x4a> @ imm = #0x38
 8008088: 2301         	movs	r3, #0x1
 800808a: f887 3027    	strb.w	r3, [r7, #0x27]
 800808e: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8008092: f083 0301    	eor	r3, r3, #0x1
 8008096: b2db         	uxtb	r3, r3
 8008098: 2b00         	cmp	r3, #0x0
 800809a: d112         	bne	0x80080c2 <async_evt_rx_err+0x4a> @ imm = #0x24
 800809c: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80080f0 <async_evt_rx_err+0x78>
 800809e: 6819         	ldr	r1, [r3]
 80080a0: 683b         	ldr	r3, [r7]
 80080a2: 9304         	str	r3, [sp, #0x10]
 80080a4: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80080f4 <async_evt_rx_err+0x7c>
 80080a6: 9303         	str	r3, [sp, #0xc]
 80080a8: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80080f8 <async_evt_rx_err+0x80>
 80080aa: 9302         	str	r3, [sp, #0x8]
 80080ac: 2308         	movs	r3, #0x8
 80080ae: 9301         	str	r3, [sp, #0x4]
 80080b0: 2300         	movs	r3, #0x0
 80080b2: 9300         	str	r3, [sp]
 80080b4: 2300         	movs	r3, #0x0
 80080b6: 2204         	movs	r2, #0x4
 80080b8: 2000         	movs	r0, #0x0
 80080ba: f00e fb5d    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xe6ba
 80080be: 2300         	movs	r3, #0x0
 80080c0: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 80080c2: 2306         	movs	r3, #0x6
 80080c4: 733b         	strb	r3, [r7, #0xc]
 80080c6: 683b         	ldr	r3, [r7]
 80080c8: b2db         	uxtb	r3, r3
 80080ca: 743b         	strb	r3, [r7, #0x10]
; 		.data.rx_stop.data.buf = data->dma_rx.buffer
 80080cc: 687b         	ldr	r3, [r7, #0x4]
 80080ce: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event event = {
 80080d0: 617b         	str	r3, [r7, #0x14]
 80080d2: 2300         	movs	r3, #0x0
 80080d4: 61bb         	str	r3, [r7, #0x18]
; 		.data.rx_stop.data.len = data->dma_rx.counter,
 80080d6: 687b         	ldr	r3, [r7, #0x4]
 80080d8: 6f9b         	ldr	r3, [r3, #0x78]
; 	struct uart_event event = {
 80080da: 61fb         	str	r3, [r7, #0x1c]
; 	async_user_callback(data, &event);
 80080dc: f107 030c    	add.w	r3, r7, #0xc
 80080e0: 4619         	mov	r1, r3
 80080e2: 6878         	ldr	r0, [r7, #0x4]
 80080e4: f00e ffed    	bl	0x80170c2 <async_user_callback> @ imm = #0xefda
; }
 80080e8: bf00         	nop
 80080ea: 3728         	adds	r7, #0x28
 80080ec: 46bd         	mov	sp, r7
 80080ee: bd80         	pop	{r7, pc}

080080f0 <$d>:
 80080f0: 60 04 00 20  	.word	0x20000460
 80080f4: 4c d6 01 08  	.word	0x0801d64c
 80080f8: 18 c4 01 08  	.word	0x0801c418

080080fc <async_evt_tx_done>:
; {
 80080fc: b580         	push	{r7, lr}
 80080fe: b090         	sub	sp, #0x40
 8008100: af06         	add	r7, sp, #0x18
 8008102: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("tx done: %d", data->dma_tx.counter);
 8008104: 2303         	movs	r3, #0x3
 8008106: 2b03         	cmp	r3, #0x3
 8008108: d91e         	bls	0x8008148 <async_evt_tx_done+0x4c> @ imm = #0x3c
 800810a: 2301         	movs	r3, #0x1
 800810c: f887 3027    	strb.w	r3, [r7, #0x27]
 8008110: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8008114: f083 0301    	eor	r3, r3, #0x1
 8008118: b2db         	uxtb	r3, r3
 800811a: 2b00         	cmp	r3, #0x0
 800811c: d114         	bne	0x8008148 <async_evt_tx_done+0x4c> @ imm = #0x28
 800811e: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800818c <async_evt_tx_done+0x90>
 8008120: 6819         	ldr	r1, [r3]
 8008122: 687b         	ldr	r3, [r7, #0x4]
 8008124: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 8008128: 9304         	str	r3, [sp, #0x10]
 800812a: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8008190 <async_evt_tx_done+0x94>
 800812c: 9303         	str	r3, [sp, #0xc]
 800812e: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8008194 <async_evt_tx_done+0x98>
 8008130: 9302         	str	r3, [sp, #0x8]
 8008132: 2308         	movs	r3, #0x8
 8008134: 9301         	str	r3, [sp, #0x4]
 8008136: 2300         	movs	r3, #0x0
 8008138: 9300         	str	r3, [sp]
 800813a: 2300         	movs	r3, #0x0
 800813c: 2204         	movs	r2, #0x4
 800813e: 2000         	movs	r0, #0x0
 8008140: f00e fb1a    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xe634
 8008144: 2300         	movs	r3, #0x0
 8008146: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 8008148: f107 030c    	add.w	r3, r7, #0xc
 800814c: 2200         	movs	r2, #0x0
 800814e: 601a         	str	r2, [r3]
 8008150: 605a         	str	r2, [r3, #0x4]
 8008152: 609a         	str	r2, [r3, #0x8]
 8008154: 60da         	str	r2, [r3, #0xc]
 8008156: 611a         	str	r2, [r3, #0x10]
; 		.data.tx.buf = data->dma_tx.buffer,
 8008158: 687b         	ldr	r3, [r7, #0x4]
 800815a: f8d3 3104    	ldr.w	r3, [r3, #0x104]
; 	struct uart_event event = {
 800815e: 613b         	str	r3, [r7, #0x10]
; 		.data.tx.len = data->dma_tx.counter
 8008160: 687b         	ldr	r3, [r7, #0x4]
 8008162: f8d3 3110    	ldr.w	r3, [r3, #0x110]
; 	struct uart_event event = {
 8008166: 617b         	str	r3, [r7, #0x14]
; 	data->dma_tx.buffer_length = 0;
 8008168: 687b         	ldr	r3, [r7, #0x4]
 800816a: 2200         	movs	r2, #0x0
 800816c: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.counter = 0;
 8008170: 687b         	ldr	r3, [r7, #0x4]
 8008172: 2200         	movs	r2, #0x0
 8008174: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	async_user_callback(data, &event);
 8008178: f107 030c    	add.w	r3, r7, #0xc
 800817c: 4619         	mov	r1, r3
 800817e: 6878         	ldr	r0, [r7, #0x4]
 8008180: f00e ff9f    	bl	0x80170c2 <async_user_callback> @ imm = #0xef3e
; }
 8008184: bf00         	nop
 8008186: 3728         	adds	r7, #0x28
 8008188: 46bd         	mov	sp, r7
 800818a: bd80         	pop	{r7, pc}

0800818c <$d>:
 800818c: 60 04 00 20  	.word	0x20000460
 8008190: fc d5 01 08  	.word	0x0801d5fc
 8008194: 2c c4 01 08  	.word	0x0801c42c

08008198 <async_evt_tx_abort>:
; {
 8008198: b580         	push	{r7, lr}
 800819a: b090         	sub	sp, #0x40
 800819c: af06         	add	r7, sp, #0x18
 800819e: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("tx abort: %d", data->dma_tx.counter);
 80081a0: 2303         	movs	r3, #0x3
 80081a2: 2b03         	cmp	r3, #0x3
 80081a4: d91e         	bls	0x80081e4 <async_evt_tx_abort+0x4c> @ imm = #0x3c
 80081a6: 2301         	movs	r3, #0x1
 80081a8: f887 3027    	strb.w	r3, [r7, #0x27]
 80081ac: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80081b0: f083 0301    	eor	r3, r3, #0x1
 80081b4: b2db         	uxtb	r3, r3
 80081b6: 2b00         	cmp	r3, #0x0
 80081b8: d114         	bne	0x80081e4 <async_evt_tx_abort+0x4c> @ imm = #0x28
 80081ba: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800822c <async_evt_tx_abort+0x94>
 80081bc: 6819         	ldr	r1, [r3]
 80081be: 687b         	ldr	r3, [r7, #0x4]
 80081c0: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 80081c4: 9304         	str	r3, [sp, #0x10]
 80081c6: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8008230 <async_evt_tx_abort+0x98>
 80081c8: 9303         	str	r3, [sp, #0xc]
 80081ca: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8008234 <async_evt_tx_abort+0x9c>
 80081cc: 9302         	str	r3, [sp, #0x8]
 80081ce: 2308         	movs	r3, #0x8
 80081d0: 9301         	str	r3, [sp, #0x4]
 80081d2: 2300         	movs	r3, #0x0
 80081d4: 9300         	str	r3, [sp]
 80081d6: 2300         	movs	r3, #0x0
 80081d8: 2204         	movs	r2, #0x4
 80081da: 2000         	movs	r0, #0x0
 80081dc: f00e facc    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xe598
 80081e0: 2300         	movs	r3, #0x0
 80081e2: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 80081e4: f107 030c    	add.w	r3, r7, #0xc
 80081e8: 2200         	movs	r2, #0x0
 80081ea: 601a         	str	r2, [r3]
 80081ec: 605a         	str	r2, [r3, #0x4]
 80081ee: 609a         	str	r2, [r3, #0x8]
 80081f0: 60da         	str	r2, [r3, #0xc]
 80081f2: 611a         	str	r2, [r3, #0x10]
 80081f4: 2301         	movs	r3, #0x1
 80081f6: 733b         	strb	r3, [r7, #0xc]
; 		.data.tx.buf = data->dma_tx.buffer,
 80081f8: 687b         	ldr	r3, [r7, #0x4]
 80081fa: f8d3 3104    	ldr.w	r3, [r3, #0x104]
; 	struct uart_event event = {
 80081fe: 613b         	str	r3, [r7, #0x10]
; 		.data.tx.len = data->dma_tx.counter
 8008200: 687b         	ldr	r3, [r7, #0x4]
 8008202: f8d3 3110    	ldr.w	r3, [r3, #0x110]
; 	struct uart_event event = {
 8008206: 617b         	str	r3, [r7, #0x14]
; 	data->dma_tx.buffer_length = 0;
 8008208: 687b         	ldr	r3, [r7, #0x4]
 800820a: 2200         	movs	r2, #0x0
 800820c: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.counter = 0;
 8008210: 687b         	ldr	r3, [r7, #0x4]
 8008212: 2200         	movs	r2, #0x0
 8008214: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	async_user_callback(data, &event);
 8008218: f107 030c    	add.w	r3, r7, #0xc
 800821c: 4619         	mov	r1, r3
 800821e: 6878         	ldr	r0, [r7, #0x4]
 8008220: f00e ff4f    	bl	0x80170c2 <async_user_callback> @ imm = #0xee9e
; }
 8008224: bf00         	nop
 8008226: 3728         	adds	r7, #0x28
 8008228: 46bd         	mov	sp, r7
 800822a: bd80         	pop	{r7, pc}

0800822c <$d>:
 800822c: 60 04 00 20  	.word	0x20000460
 8008230: 90 d6 01 08  	.word	0x0801d690
 8008234: 3c c4 01 08  	.word	0x0801c43c

08008238 <async_timer_start>:
; {
 8008238: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800823c: b08a         	sub	sp, #0x28
 800823e: af06         	add	r7, sp, #0x18
 8008240: 6078         	str	r0, [r7, #0x4]
 8008242: 6039         	str	r1, [r7]
; 	if ((timeout != SYS_FOREVER_US) && (timeout != 0)) {
 8008244: 683b         	ldr	r3, [r7]
 8008246: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800824a: d037         	beq	0x80082bc <async_timer_start+0x84> @ imm = #0x6e
 800824c: 683b         	ldr	r3, [r7]
 800824e: 2b00         	cmp	r3, #0x0
 8008250: d034         	beq	0x80082bc <async_timer_start+0x84> @ imm = #0x68
; 		LOG_DBG("async timer started for %d us", timeout);
 8008252: 2303         	movs	r3, #0x3
 8008254: 2b03         	cmp	r3, #0x3
 8008256: d91a         	bls	0x800828e <async_timer_start+0x56> @ imm = #0x34
 8008258: 2301         	movs	r3, #0x1
 800825a: 73fb         	strb	r3, [r7, #0xf]
 800825c: 7bfb         	ldrb	r3, [r7, #0xf]
 800825e: f083 0301    	eor	r3, r3, #0x1
 8008262: b2db         	uxtb	r3, r3
 8008264: 2b00         	cmp	r3, #0x0
 8008266: d112         	bne	0x800828e <async_timer_start+0x56> @ imm = #0x24
 8008268: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80082c8 <async_timer_start+0x90>
 800826a: 6819         	ldr	r1, [r3]
 800826c: 683b         	ldr	r3, [r7]
 800826e: 9304         	str	r3, [sp, #0x10]
 8008270: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80082cc <async_timer_start+0x94>
 8008272: 9303         	str	r3, [sp, #0xc]
 8008274: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80082d0 <async_timer_start+0x98>
 8008276: 9302         	str	r3, [sp, #0x8]
 8008278: 2308         	movs	r3, #0x8
 800827a: 9301         	str	r3, [sp, #0x4]
 800827c: 2300         	movs	r3, #0x0
 800827e: 9300         	str	r3, [sp]
 8008280: 2300         	movs	r3, #0x0
 8008282: 2204         	movs	r2, #0x4
 8008284: 2000         	movs	r0, #0x0
 8008286: f00e fa77    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xe4ee
 800828a: 2300         	movs	r3, #0x0
 800828c: 60bb         	str	r3, [r7, #0x8]
; 		k_work_reschedule(work, K_USEC(timeout));
 800828e: 683b         	ldr	r3, [r7]
 8008290: ea23 73e3    	bic.w	r3, r3, r3, asr #31
 8008294: 17da         	asrs	r2, r3, #0x1f
 8008296: 461c         	mov	r4, r3
 8008298: 4615         	mov	r5, r2
 800829a: f114 0863    	adds.w	r8, r4, #0x63
 800829e: f145 0900    	adc	r9, r5, #0x0
 80082a2: f04f 0264    	mov.w	r2, #0x64
 80082a6: f04f 0300    	mov.w	r3, #0x0
 80082aa: 4640         	mov	r0, r8
 80082ac: 4649         	mov	r1, r9
 80082ae: f7f8 fc21    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x77be
 80082b2: 4602         	mov	r2, r0
 80082b4: 460b         	mov	r3, r1
 80082b6: 6878         	ldr	r0, [r7, #0x4]
 80082b8: f005 f9ee    	bl	0x800d698 <k_work_reschedule> @ imm = #0x53dc
; }
 80082bc: bf00         	nop
 80082be: 3710         	adds	r7, #0x10
 80082c0: 46bd         	mov	sp, r7
 80082c2: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 80082c6: bf00         	nop

080082c8 <$d>:
 80082c8: 60 04 00 20  	.word	0x20000460
 80082cc: e8 d5 01 08  	.word	0x0801d5e8
 80082d0: 50 c4 01 08  	.word	0x0801c450

080082d4 <uart_stm32_isr>:
; {
 80082d4: b580         	push	{r7, lr}
 80082d6: b08c         	sub	sp, #0x30
 80082d8: af04         	add	r7, sp, #0x10
 80082da: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 80082dc: 687b         	ldr	r3, [r7, #0x4]
 80082de: 691b         	ldr	r3, [r3, #0x10]
 80082e0: 61fb         	str	r3, [r7, #0x1c]
; 	const struct uart_stm32_config *config = dev->config;
 80082e2: 687b         	ldr	r3, [r7, #0x4]
 80082e4: 685b         	ldr	r3, [r3, #0x4]
 80082e6: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 80082e8: 69bb         	ldr	r3, [r7, #0x18]
 80082ea: 681b         	ldr	r3, [r3]
 80082ec: 617b         	str	r3, [r7, #0x14]
; 	if (data->user_cb) {
 80082ee: 69fb         	ldr	r3, [r7, #0x1c]
 80082f0: 689b         	ldr	r3, [r3, #0x8]
 80082f2: 2b00         	cmp	r3, #0x0
 80082f4: d006         	beq	0x8008304 <uart_stm32_isr+0x30> @ imm = #0xc
; 		data->user_cb(dev, data->user_data);
 80082f6: 69fb         	ldr	r3, [r7, #0x1c]
 80082f8: 689b         	ldr	r3, [r3, #0x8]
 80082fa: 69fa         	ldr	r2, [r7, #0x1c]
 80082fc: 68d2         	ldr	r2, [r2, #0xc]
 80082fe: 4611         	mov	r1, r2
 8008300: 6878         	ldr	r0, [r7, #0x4]
 8008302: 4798         	blx	r3
; 	if (LL_USART_IsEnabledIT_IDLE(usart) &&
 8008304: 6978         	ldr	r0, [r7, #0x14]
 8008306: f00e f976    	bl	0x80165f6 <LL_USART_IsEnabledIT_IDLE> @ imm = #0xe2ec
 800830a: 4603         	mov	r3, r0
 800830c: 2b00         	cmp	r3, #0x0
 800830e: d036         	beq	0x800837e <uart_stm32_isr+0xaa> @ imm = #0x6c
; 			LL_USART_IsActiveFlag_IDLE(usart)) {
 8008310: 6978         	ldr	r0, [r7, #0x14]
 8008312: f00d ff27    	bl	0x8016164 <LL_USART_IsActiveFlag_IDLE> @ imm = #0xde4e
 8008316: 4603         	mov	r3, r0
; 	if (LL_USART_IsEnabledIT_IDLE(usart) &&
 8008318: 2b00         	cmp	r3, #0x0
 800831a: d030         	beq	0x800837e <uart_stm32_isr+0xaa> @ imm = #0x60
; 		LL_USART_ClearFlag_IDLE(usart);
 800831c: 6978         	ldr	r0, [r7, #0x14]
 800831e: f00d ffc0    	bl	0x80162a2 <LL_USART_ClearFlag_IDLE> @ imm = #0xdf80
; 		LOG_DBG("idle interrupt occurred");
 8008322: 2303         	movs	r3, #0x3
 8008324: 2b03         	cmp	r3, #0x3
 8008326: d918         	bls	0x800835a <uart_stm32_isr+0x86> @ imm = #0x30
 8008328: 2301         	movs	r3, #0x1
 800832a: 74fb         	strb	r3, [r7, #0x13]
 800832c: 7cfb         	ldrb	r3, [r7, #0x13]
 800832e: f083 0301    	eor	r3, r3, #0x1
 8008332: b2db         	uxtb	r3, r3
 8008334: 2b00         	cmp	r3, #0x0
 8008336: d110         	bne	0x800835a <uart_stm32_isr+0x86> @ imm = #0x20
 8008338: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80083d0 <uart_stm32_isr+0xfc>
 800833a: 6819         	ldr	r1, [r3]
 800833c: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80083d4 <uart_stm32_isr+0x100>
 800833e: 9303         	str	r3, [sp, #0xc]
 8008340: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80083d8 <uart_stm32_isr+0x104>
 8008342: 9302         	str	r3, [sp, #0x8]
 8008344: 2308         	movs	r3, #0x8
 8008346: 9301         	str	r3, [sp, #0x4]
 8008348: 2300         	movs	r3, #0x0
 800834a: 9300         	str	r3, [sp]
 800834c: 2300         	movs	r3, #0x0
 800834e: 2204         	movs	r2, #0x4
 8008350: 2000         	movs	r0, #0x0
 8008352: f00e fa11    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xe422
 8008356: 2300         	movs	r3, #0x0
 8008358: 60fb         	str	r3, [r7, #0xc]
; 		if (data->dma_rx.timeout == 0) {
 800835a: 69fb         	ldr	r3, [r7, #0x1c]
 800835c: 6fdb         	ldr	r3, [r3, #0x7c]
 800835e: 2b00         	cmp	r3, #0x0
 8008360: d103         	bne	0x800836a <uart_stm32_isr+0x96> @ imm = #0x6
; 			uart_stm32_dma_rx_flush(dev);
 8008362: 6878         	ldr	r0, [r7, #0x4]
 8008364: f00e fef5    	bl	0x8017152 <uart_stm32_dma_rx_flush> @ imm = #0xedea
; 		if (data->dma_rx.timeout == 0) {
 8008368: e02b         	b	0x80083c2 <uart_stm32_isr+0xee> @ imm = #0x56
; 			async_timer_start(&data->dma_rx.timeout_work,
 800836a: 69fb         	ldr	r3, [r7, #0x1c]
 800836c: f103 0280    	add.w	r2, r3, #0x80
 8008370: 69fb         	ldr	r3, [r7, #0x1c]
 8008372: 6fdb         	ldr	r3, [r3, #0x7c]
 8008374: 4619         	mov	r1, r3
 8008376: 4610         	mov	r0, r2
 8008378: f7ff ff5e    	bl	0x8008238 <async_timer_start> @ imm = #-0x144
; 		if (data->dma_rx.timeout == 0) {
 800837c: e021         	b	0x80083c2 <uart_stm32_isr+0xee> @ imm = #0x42
; 	} else if (LL_USART_IsEnabledIT_TC(usart) &&
 800837e: 6978         	ldr	r0, [r7, #0x14]
 8008380: f00e f95d    	bl	0x801663e <LL_USART_IsEnabledIT_TC> @ imm = #0xe2ba
 8008384: 4603         	mov	r3, r0
 8008386: 2b00         	cmp	r3, #0x0
 8008388: d00c         	beq	0x80083a4 <uart_stm32_isr+0xd0> @ imm = #0x18
; 			LL_USART_IsActiveFlag_TC(usart)) {
 800838a: 6978         	ldr	r0, [r7, #0x14]
 800838c: f00d ff0e    	bl	0x80161ac <LL_USART_IsActiveFlag_TC> @ imm = #0xde1c
 8008390: 4603         	mov	r3, r0
; 	} else if (LL_USART_IsEnabledIT_TC(usart) &&
 8008392: 2b00         	cmp	r3, #0x0
 8008394: d006         	beq	0x80083a4 <uart_stm32_isr+0xd0> @ imm = #0xc
; 		LL_USART_DisableIT_TC(usart);
 8008396: 6978         	ldr	r0, [r7, #0x14]
 8008398: f00e f8b8    	bl	0x801650c <LL_USART_DisableIT_TC> @ imm = #0xe170
; 		async_evt_tx_done(data);
 800839c: 69f8         	ldr	r0, [r7, #0x1c]
 800839e: f7ff fead    	bl	0x80080fc <async_evt_tx_done> @ imm = #-0x2a6
 80083a2: e00e         	b	0x80083c2 <uart_stm32_isr+0xee> @ imm = #0x1c
; 	} else if (LL_USART_IsEnabledIT_RXNE(usart) &&
 80083a4: 6978         	ldr	r0, [r7, #0x14]
 80083a6: f00e f938    	bl	0x801661a <LL_USART_IsEnabledIT_RXNE> @ imm = #0xe270
 80083aa: 4603         	mov	r3, r0
 80083ac: 2b00         	cmp	r3, #0x0
 80083ae: d008         	beq	0x80083c2 <uart_stm32_isr+0xee> @ imm = #0x10
; 			LL_USART_IsActiveFlag_RXNE(usart)) {
 80083b0: 6978         	ldr	r0, [r7, #0x14]
 80083b2: f00d fee9    	bl	0x8016188 <LL_USART_IsActiveFlag_RXNE> @ imm = #0xddd2
 80083b6: 4603         	mov	r3, r0
; 	} else if (LL_USART_IsEnabledIT_RXNE(usart) &&
 80083b8: 2b00         	cmp	r3, #0x0
 80083ba: d002         	beq	0x80083c2 <uart_stm32_isr+0xee> @ imm = #0x4
; 		LL_USART_ClearFlag_RXNE(usart);
 80083bc: 6978         	ldr	r0, [r7, #0x14]
 80083be: f00d ff8e    	bl	0x80162de <LL_USART_ClearFlag_RXNE> @ imm = #0xdf1c
; 	uart_stm32_err_check(dev);
 80083c2: 6878         	ldr	r0, [r7, #0x4]
 80083c4: f00e fca0    	bl	0x8016d08 <uart_stm32_err_check> @ imm = #0xe940
; }
 80083c8: bf00         	nop
 80083ca: 3720         	adds	r7, #0x20
 80083cc: 46bd         	mov	sp, r7
 80083ce: bd80         	pop	{r7, pc}

080083d0 <$d>:
 80083d0: 60 04 00 20  	.word	0x20000460
 80083d4: d8 d5 01 08  	.word	0x0801d5d8
 80083d8: 74 c4 01 08  	.word	0x0801c474

080083dc <uart_stm32_async_rx_disable>:
; {
 80083dc: b580         	push	{r7, lr}
 80083de: b096         	sub	sp, #0x58
 80083e0: af04         	add	r7, sp, #0x10
 80083e2: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80083e4: 687b         	ldr	r3, [r7, #0x4]
 80083e6: 685b         	ldr	r3, [r3, #0x4]
 80083e8: 647b         	str	r3, [r7, #0x44]
; 	USART_TypeDef *usart = config->usart;
 80083ea: 6c7b         	ldr	r3, [r7, #0x44]
 80083ec: 681b         	ldr	r3, [r3]
 80083ee: 643b         	str	r3, [r7, #0x40]
; 	struct uart_stm32_data *data = dev->data;
 80083f0: 687b         	ldr	r3, [r7, #0x4]
 80083f2: 691b         	ldr	r3, [r3, #0x10]
 80083f4: 63fb         	str	r3, [r7, #0x3c]
; 	struct uart_event disabled_event = {
 80083f6: f107 0320    	add.w	r3, r7, #0x20
 80083fa: 2200         	movs	r2, #0x0
 80083fc: 601a         	str	r2, [r3]
 80083fe: 605a         	str	r2, [r3, #0x4]
 8008400: 609a         	str	r2, [r3, #0x8]
 8008402: 60da         	str	r2, [r3, #0xc]
 8008404: 611a         	str	r2, [r3, #0x10]
 8008406: 2305         	movs	r3, #0x5
 8008408: f887 3020    	strb.w	r3, [r7, #0x20]
; 	if (!data->dma_rx.enabled) {
 800840c: 6bfb         	ldr	r3, [r7, #0x3c]
 800840e: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 8008412: f083 0301    	eor	r3, r3, #0x1
 8008416: b2db         	uxtb	r3, r3
 8008418: 2b00         	cmp	r3, #0x0
 800841a: d008         	beq	0x800842e <uart_stm32_async_rx_disable+0x52> @ imm = #0x10
; 		async_user_callback(data, &disabled_event);
 800841c: f107 0320    	add.w	r3, r7, #0x20
 8008420: 4619         	mov	r1, r3
 8008422: 6bf8         	ldr	r0, [r7, #0x3c]
 8008424: f00e fe4d    	bl	0x80170c2 <async_user_callback> @ imm = #0xec9a
; 		return -EFAULT;
 8008428: f06f 030d    	mvn	r3, #0xd
 800842c: e061         	b	0x80084f2 <uart_stm32_async_rx_disable+0x116> @ imm = #0xc2
; 	LL_USART_DisableIT_IDLE(usart);
 800842e: 6c38         	ldr	r0, [r7, #0x40]
 8008430: f00e f828    	bl	0x8016484 <LL_USART_DisableIT_IDLE> @ imm = #0xe050
; 	uart_stm32_dma_rx_flush(dev);
 8008434: 6878         	ldr	r0, [r7, #0x4]
 8008436: f00e fe8c    	bl	0x8017152 <uart_stm32_dma_rx_flush> @ imm = #0xed18
; 	async_evt_rx_buf_release(data);
 800843a: 6bf8         	ldr	r0, [r7, #0x3c]
 800843c: f00e fe6e    	bl	0x801711c <async_evt_rx_buf_release> @ imm = #0xecdc
; 	uart_stm32_dma_rx_disable(dev);
 8008440: 6878         	ldr	r0, [r7, #0x4]
 8008442: f00e feff    	bl	0x8017244 <uart_stm32_dma_rx_disable> @ imm = #0xedfe
; 	(void)k_work_cancel_delayable(&data->dma_rx.timeout_work);
 8008446: 6bfb         	ldr	r3, [r7, #0x3c]
 8008448: 3380         	adds	r3, #0x80
 800844a: 4618         	mov	r0, r3
 800844c: f005 f938    	bl	0x800d6c0 <k_work_cancel_delayable> @ imm = #0x5270
; 	dma_stop(data->dma_rx.dma_dev, data->dma_rx.dma_channel);
 8008450: 6bfb         	ldr	r3, [r7, #0x3c]
 8008452: 6a1a         	ldr	r2, [r3, #0x20]
 8008454: 6bfb         	ldr	r3, [r7, #0x3c]
 8008456: 6a5b         	ldr	r3, [r3, #0x24]
 8008458: 4619         	mov	r1, r3
 800845a: 4610         	mov	r0, r2
 800845c: f00d fcc5    	bl	0x8015dea <dma_stop>    @ imm = #0xd98a
; 	if (data->rx_next_buffer) {
 8008460: 6bfb         	ldr	r3, [r7, #0x3c]
 8008462: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 8008466: 2b00         	cmp	r3, #0x0
 8008468: d013         	beq	0x8008492 <uart_stm32_async_rx_disable+0xb6> @ imm = #0x26
; 		struct uart_event rx_next_buf_release_evt = {
 800846a: f107 030c    	add.w	r3, r7, #0xc
 800846e: 2200         	movs	r2, #0x0
 8008470: 601a         	str	r2, [r3]
 8008472: 605a         	str	r2, [r3, #0x4]
 8008474: 609a         	str	r2, [r3, #0x8]
 8008476: 60da         	str	r2, [r3, #0xc]
 8008478: 611a         	str	r2, [r3, #0x10]
 800847a: 2304         	movs	r3, #0x4
 800847c: 733b         	strb	r3, [r7, #0xc]
; 			.data.rx_buf.buf = data->rx_next_buffer,
 800847e: 6bfb         	ldr	r3, [r7, #0x3c]
 8008480: f8d3 3150    	ldr.w	r3, [r3, #0x150]
; 		struct uart_event rx_next_buf_release_evt = {
 8008484: 613b         	str	r3, [r7, #0x10]
; 		async_user_callback(data, &rx_next_buf_release_evt);
 8008486: f107 030c    	add.w	r3, r7, #0xc
 800848a: 4619         	mov	r1, r3
 800848c: 6bf8         	ldr	r0, [r7, #0x3c]
 800848e: f00e fe18    	bl	0x80170c2 <async_user_callback> @ imm = #0xec30
; 	data->rx_next_buffer = NULL;
 8008492: 6bfb         	ldr	r3, [r7, #0x3c]
 8008494: 2200         	movs	r2, #0x0
 8008496: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800849a: 6bfb         	ldr	r3, [r7, #0x3c]
 800849c: 2200         	movs	r2, #0x0
 800849e: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	LL_USART_EnableIT_RXNE(usart);
 80084a2: 6c38         	ldr	r0, [r7, #0x40]
 80084a4: f00d ff57    	bl	0x8016356 <LL_USART_EnableIT_RXNE> @ imm = #0xdeae
; 	LOG_DBG("rx: disabled");
 80084a8: 2303         	movs	r3, #0x3
 80084aa: 2b03         	cmp	r3, #0x3
 80084ac: d91a         	bls	0x80084e4 <uart_stm32_async_rx_disable+0x108> @ imm = #0x34
 80084ae: 2301         	movs	r3, #0x1
 80084b0: f887 303b    	strb.w	r3, [r7, #0x3b]
 80084b4: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 80084b8: f083 0301    	eor	r3, r3, #0x1
 80084bc: b2db         	uxtb	r3, r3
 80084be: 2b00         	cmp	r3, #0x0
 80084c0: d110         	bne	0x80084e4 <uart_stm32_async_rx_disable+0x108> @ imm = #0x20
 80084c2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80084fc <uart_stm32_async_rx_disable+0x120>
 80084c4: 6819         	ldr	r1, [r3]
 80084c6: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8008500 <uart_stm32_async_rx_disable+0x124>
 80084c8: 9303         	str	r3, [sp, #0xc]
 80084ca: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8008504 <uart_stm32_async_rx_disable+0x128>
 80084cc: 9302         	str	r3, [sp, #0x8]
 80084ce: 2308         	movs	r3, #0x8
 80084d0: 9301         	str	r3, [sp, #0x4]
 80084d2: 2300         	movs	r3, #0x0
 80084d4: 9300         	str	r3, [sp]
 80084d6: 2300         	movs	r3, #0x0
 80084d8: 2204         	movs	r2, #0x4
 80084da: 2000         	movs	r0, #0x0
 80084dc: f00e f94c    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xe298
 80084e0: 2300         	movs	r3, #0x0
 80084e2: 637b         	str	r3, [r7, #0x34]
; 	async_user_callback(data, &disabled_event);
 80084e4: f107 0320    	add.w	r3, r7, #0x20
 80084e8: 4619         	mov	r1, r3
 80084ea: 6bf8         	ldr	r0, [r7, #0x3c]
 80084ec: f00e fde9    	bl	0x80170c2 <async_user_callback> @ imm = #0xebd2
; 	return 0;
 80084f0: 2300         	movs	r3, #0x0
; }
 80084f2: 4618         	mov	r0, r3
 80084f4: 3748         	adds	r7, #0x48
 80084f6: 46bd         	mov	sp, r7
 80084f8: bd80         	pop	{r7, pc}
 80084fa: bf00         	nop

080084fc <$d>:
 80084fc: 60 04 00 20  	.word	0x20000460
 8008500: 10 d6 01 08  	.word	0x0801d610
 8008504: 90 c4 01 08  	.word	0x0801c490

08008508 <uart_stm32_dma_replace_buffer>:
; {
 8008508: b590         	push	{r4, r7, lr}
 800850a: b08f         	sub	sp, #0x3c
 800850c: af06         	add	r7, sp, #0x18
 800850e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8008510: 687b         	ldr	r3, [r7, #0x4]
 8008512: 685b         	ldr	r3, [r3, #0x4]
 8008514: 61fb         	str	r3, [r7, #0x1c]
; 	USART_TypeDef *usart = config->usart;
 8008516: 69fb         	ldr	r3, [r7, #0x1c]
 8008518: 681b         	ldr	r3, [r3]
 800851a: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = dev->data;
 800851c: 687b         	ldr	r3, [r7, #0x4]
 800851e: 691b         	ldr	r3, [r3, #0x10]
 8008520: 617b         	str	r3, [r7, #0x14]
; 	LOG_DBG("Replacing RX buffer: %d", data->rx_next_buffer_len);
 8008522: 2303         	movs	r3, #0x3
 8008524: 2b03         	cmp	r3, #0x3
 8008526: d91c         	bls	0x8008562 <uart_stm32_dma_replace_buffer+0x5a> @ imm = #0x38
 8008528: 2301         	movs	r3, #0x1
 800852a: 74fb         	strb	r3, [r7, #0x13]
 800852c: 7cfb         	ldrb	r3, [r7, #0x13]
 800852e: f083 0301    	eor	r3, r3, #0x1
 8008532: b2db         	uxtb	r3, r3
 8008534: 2b00         	cmp	r3, #0x0
 8008536: d114         	bne	0x8008562 <uart_stm32_dma_replace_buffer+0x5a> @ imm = #0x28
 8008538: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80085e4 <uart_stm32_dma_replace_buffer+0xdc>
 800853a: 6819         	ldr	r1, [r3]
 800853c: 697b         	ldr	r3, [r7, #0x14]
 800853e: f8d3 3154    	ldr.w	r3, [r3, #0x154]
 8008542: 9304         	str	r3, [sp, #0x10]
 8008544: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x80085e8 <uart_stm32_dma_replace_buffer+0xe0>
 8008546: 9303         	str	r3, [sp, #0xc]
 8008548: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x80085ec <uart_stm32_dma_replace_buffer+0xe4>
 800854a: 9302         	str	r3, [sp, #0x8]
 800854c: 2308         	movs	r3, #0x8
 800854e: 9301         	str	r3, [sp, #0x4]
 8008550: 2300         	movs	r3, #0x0
 8008552: 9300         	str	r3, [sp]
 8008554: 2300         	movs	r3, #0x0
 8008556: 2204         	movs	r2, #0x4
 8008558: 2000         	movs	r0, #0x0
 800855a: f00e f90d    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xe21a
 800855e: 2300         	movs	r3, #0x0
 8008560: 60fb         	str	r3, [r7, #0xc]
; 	data->dma_rx.offset = 0;
 8008562: 697b         	ldr	r3, [r7, #0x14]
 8008564: 2200         	movs	r2, #0x0
 8008566: 675a         	str	r2, [r3, #0x74]
; 	data->dma_rx.counter = 0;
 8008568: 697b         	ldr	r3, [r7, #0x14]
 800856a: 2200         	movs	r2, #0x0
 800856c: 679a         	str	r2, [r3, #0x78]
; 	data->dma_rx.buffer = data->rx_next_buffer;
 800856e: 697b         	ldr	r3, [r7, #0x14]
 8008570: f8d3 2150    	ldr.w	r2, [r3, #0x150]
 8008574: 697b         	ldr	r3, [r7, #0x14]
 8008576: 66da         	str	r2, [r3, #0x6c]
; 	data->dma_rx.buffer_length = data->rx_next_buffer_len;
 8008578: 697b         	ldr	r3, [r7, #0x14]
 800857a: f8d3 2154    	ldr.w	r2, [r3, #0x154]
 800857e: 697b         	ldr	r3, [r7, #0x14]
 8008580: 671a         	str	r2, [r3, #0x70]
; 	data->dma_rx.blk_cfg.block_size = data->dma_rx.buffer_length;
 8008582: 697b         	ldr	r3, [r7, #0x14]
 8008584: 6f1a         	ldr	r2, [r3, #0x70]
 8008586: 697b         	ldr	r3, [r7, #0x14]
 8008588: 661a         	str	r2, [r3, #0x60]
; 	data->dma_rx.blk_cfg.dest_address = (uint32_t)data->dma_rx.buffer;
 800858a: 697b         	ldr	r3, [r7, #0x14]
 800858c: 6edb         	ldr	r3, [r3, #0x6c]
 800858e: 461a         	mov	r2, r3
 8008590: 697b         	ldr	r3, [r7, #0x14]
 8008592: 651a         	str	r2, [r3, #0x50]
; 	data->rx_next_buffer = NULL;
 8008594: 697b         	ldr	r3, [r7, #0x14]
 8008596: 2200         	movs	r2, #0x0
 8008598: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800859c: 697b         	ldr	r3, [r7, #0x14]
 800859e: 2200         	movs	r2, #0x0
 80085a0: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	dma_reload(data->dma_rx.dma_dev, data->dma_rx.dma_channel,
 80085a4: 697b         	ldr	r3, [r7, #0x14]
 80085a6: 6a18         	ldr	r0, [r3, #0x20]
 80085a8: 697b         	ldr	r3, [r7, #0x14]
 80085aa: 6a59         	ldr	r1, [r3, #0x24]
 80085ac: 697b         	ldr	r3, [r7, #0x14]
 80085ae: 6cda         	ldr	r2, [r3, #0x4c]
 80085b0: 697b         	ldr	r3, [r7, #0x14]
 80085b2: 6d1c         	ldr	r4, [r3, #0x50]
 80085b4: 697b         	ldr	r3, [r7, #0x14]
 80085b6: 6e1b         	ldr	r3, [r3, #0x60]
 80085b8: 9300         	str	r3, [sp]
 80085ba: 4623         	mov	r3, r4
 80085bc: f00d fba9    	bl	0x8015d12 <dma_reload>  @ imm = #0xd752
; 	dma_start(data->dma_rx.dma_dev, data->dma_rx.dma_channel);
 80085c0: 697b         	ldr	r3, [r7, #0x14]
 80085c2: 6a1a         	ldr	r2, [r3, #0x20]
 80085c4: 697b         	ldr	r3, [r7, #0x14]
 80085c6: 6a5b         	ldr	r3, [r3, #0x24]
 80085c8: 4619         	mov	r1, r3
 80085ca: 4610         	mov	r0, r2
 80085cc: f00d fbff    	bl	0x8015dce <dma_start>   @ imm = #0xd7fe
; 	LL_USART_ClearFlag_IDLE(usart);
 80085d0: 69b8         	ldr	r0, [r7, #0x18]
 80085d2: f00d fe66    	bl	0x80162a2 <LL_USART_ClearFlag_IDLE> @ imm = #0xdccc
; 	async_evt_rx_buf_request(data);
 80085d6: 6978         	ldr	r0, [r7, #0x14]
 80085d8: f00e fd88    	bl	0x80170ec <async_evt_rx_buf_request> @ imm = #0xeb10
; }
 80085dc: bf00         	nop
 80085de: 3724         	adds	r7, #0x24
 80085e0: 46bd         	mov	sp, r7
 80085e2: bd90         	pop	{r4, r7, pc}

080085e4 <$d>:
 80085e4: 60 04 00 20  	.word	0x20000460
 80085e8: 2c d6 01 08  	.word	0x0801d62c
 80085ec: a4 c4 01 08  	.word	0x0801c4a4

080085f0 <uart_stm32_async_tx>:
; {
 80085f0: b580         	push	{r7, lr}
 80085f2: b094         	sub	sp, #0x50
 80085f4: af06         	add	r7, sp, #0x18
 80085f6: 60f8         	str	r0, [r7, #0xc]
 80085f8: 60b9         	str	r1, [r7, #0x8]
 80085fa: 607a         	str	r2, [r7, #0x4]
 80085fc: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 80085fe: 68fb         	ldr	r3, [r7, #0xc]
 8008600: 685b         	ldr	r3, [r3, #0x4]
 8008602: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 8008604: 6b7b         	ldr	r3, [r7, #0x34]
 8008606: 681b         	ldr	r3, [r3]
 8008608: 633b         	str	r3, [r7, #0x30]
; 	struct uart_stm32_data *data = dev->data;
 800860a: 68fb         	ldr	r3, [r7, #0xc]
 800860c: 691b         	ldr	r3, [r3, #0x10]
 800860e: 62fb         	str	r3, [r7, #0x2c]
; 	if (data->dma_tx.dma_dev == NULL) {
 8008610: 6afb         	ldr	r3, [r7, #0x2c]
 8008612: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 8008616: 2b00         	cmp	r3, #0x0
 8008618: d102         	bne	0x8008620 <uart_stm32_async_tx+0x30> @ imm = #0x4
; 		return -ENODEV;
 800861a: f06f 0312    	mvn	r3, #0x12
 800861e: e0ac         	b	0x800877a <uart_stm32_async_tx+0x18a> @ imm = #0x158
; 	if (data->dma_tx.buffer_length != 0) {
 8008620: 6afb         	ldr	r3, [r7, #0x2c]
 8008622: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 8008626: 2b00         	cmp	r3, #0x0
 8008628: d002         	beq	0x8008630 <uart_stm32_async_tx+0x40> @ imm = #0x4
; 		return -EBUSY;
 800862a: f06f 030f    	mvn	r3, #0xf
 800862e: e0a4         	b	0x800877a <uart_stm32_async_tx+0x18a> @ imm = #0x148
; 	data->dma_tx.buffer = (uint8_t *)tx_data;
 8008630: 6afb         	ldr	r3, [r7, #0x2c]
 8008632: 68ba         	ldr	r2, [r7, #0x8]
 8008634: f8c3 2104    	str.w	r2, [r3, #0x104]
; 	data->dma_tx.buffer_length = buf_size;
 8008638: 6afb         	ldr	r3, [r7, #0x2c]
 800863a: 687a         	ldr	r2, [r7, #0x4]
 800863c: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.timeout = timeout;
 8008640: 6afb         	ldr	r3, [r7, #0x2c]
 8008642: 683a         	ldr	r2, [r7]
 8008644: f8c3 2114    	str.w	r2, [r3, #0x114]
; 	LOG_DBG("tx: l=%d", data->dma_tx.buffer_length);
 8008648: 2303         	movs	r3, #0x3
 800864a: 2b03         	cmp	r3, #0x3
 800864c: d91e         	bls	0x800868c <uart_stm32_async_tx+0x9c> @ imm = #0x3c
 800864e: 2301         	movs	r3, #0x1
 8008650: f887 302b    	strb.w	r3, [r7, #0x2b]
 8008654: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8008658: f083 0301    	eor	r3, r3, #0x1
 800865c: b2db         	uxtb	r3, r3
 800865e: 2b00         	cmp	r3, #0x0
 8008660: d114         	bne	0x800868c <uart_stm32_async_tx+0x9c> @ imm = #0x28
 8008662: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8008784 <uart_stm32_async_tx+0x194>
 8008664: 6819         	ldr	r1, [r3]
 8008666: 6afb         	ldr	r3, [r7, #0x2c]
 8008668: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 800866c: 9304         	str	r3, [sp, #0x10]
 800866e: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8008788 <uart_stm32_async_tx+0x198>
 8008670: 9303         	str	r3, [sp, #0xc]
 8008672: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800878c <uart_stm32_async_tx+0x19c>
 8008674: 9302         	str	r3, [sp, #0x8]
 8008676: 2308         	movs	r3, #0x8
 8008678: 9301         	str	r3, [sp, #0x4]
 800867a: 2300         	movs	r3, #0x0
 800867c: 9300         	str	r3, [sp]
 800867e: 2300         	movs	r3, #0x0
 8008680: 2204         	movs	r2, #0x4
 8008682: 2000         	movs	r0, #0x0
 8008684: f00e f878    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xe0f0
 8008688: 2300         	movs	r3, #0x0
 800868a: 627b         	str	r3, [r7, #0x24]
; 	LL_USART_ClearFlag_TC(usart);
 800868c: 6b38         	ldr	r0, [r7, #0x30]
 800868e: f00d fe19    	bl	0x80162c4 <LL_USART_ClearFlag_TC> @ imm = #0xdc32
; 	LL_USART_EnableIT_TC(usart);
 8008692: 6b38         	ldr	r0, [r7, #0x30]
 8008694: f00d fe81    	bl	0x801639a <LL_USART_EnableIT_TC> @ imm = #0xdd02
; 	data->dma_tx.blk_cfg.source_address = (uint32_t)data->dma_tx.buffer;
 8008698: 6afb         	ldr	r3, [r7, #0x2c]
 800869a: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 800869e: 461a         	mov	r2, r3
 80086a0: 6afb         	ldr	r3, [r7, #0x2c]
 80086a2: f8c3 20e4    	str.w	r2, [r3, #0xe4]
; 	data->dma_tx.blk_cfg.block_size = data->dma_tx.buffer_length;
 80086a6: 6afb         	ldr	r3, [r7, #0x2c]
 80086a8: f8d3 2108    	ldr.w	r2, [r3, #0x108]
 80086ac: 6afb         	ldr	r3, [r7, #0x2c]
 80086ae: f8c3 20f8    	str.w	r2, [r3, #0xf8]
; 	ret = dma_config(data->dma_tx.dma_dev, data->dma_tx.dma_channel,
 80086b2: 6afb         	ldr	r3, [r7, #0x2c]
 80086b4: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 80086b8: 6afb         	ldr	r3, [r7, #0x2c]
 80086ba: f8d3 10bc    	ldr.w	r1, [r3, #0xbc]
 80086be: 6afb         	ldr	r3, [r7, #0x2c]
 80086c0: 33c0         	adds	r3, #0xc0
 80086c2: 461a         	mov	r2, r3
 80086c4: f00d fb11    	bl	0x8015cea <dma_config>  @ imm = #0xd622
 80086c8: 6238         	str	r0, [r7, #0x20]
; 	if (ret != 0) {
 80086ca: 6a3b         	ldr	r3, [r7, #0x20]
 80086cc: 2b00         	cmp	r3, #0x0
 80086ce: d01c         	beq	0x800870a <uart_stm32_async_tx+0x11a> @ imm = #0x38
; 		LOG_ERR("dma tx config error!");
 80086d0: 2303         	movs	r3, #0x3
 80086d2: 2b00         	cmp	r3, #0x0
 80086d4: d016         	beq	0x8008704 <uart_stm32_async_tx+0x114> @ imm = #0x2c
 80086d6: 2301         	movs	r3, #0x1
 80086d8: 75fb         	strb	r3, [r7, #0x17]
 80086da: 7dfb         	ldrb	r3, [r7, #0x17]
 80086dc: f083 0301    	eor	r3, r3, #0x1
 80086e0: b2db         	uxtb	r3, r3
 80086e2: 2b00         	cmp	r3, #0x0
 80086e4: d10e         	bne	0x8008704 <uart_stm32_async_tx+0x114> @ imm = #0x1c
 80086e6: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8008784 <uart_stm32_async_tx+0x194>
 80086e8: 6819         	ldr	r1, [r3]
 80086ea: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8008790 <uart_stm32_async_tx+0x1a0>
 80086ec: 9302         	str	r3, [sp, #0x8]
 80086ee: 2300         	movs	r3, #0x0
 80086f0: 9301         	str	r3, [sp, #0x4]
 80086f2: 2300         	movs	r3, #0x0
 80086f4: 9300         	str	r3, [sp]
 80086f6: 2300         	movs	r3, #0x0
 80086f8: 2201         	movs	r2, #0x1
 80086fa: 2000         	movs	r0, #0x0
 80086fc: f00e f83c    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xe078
 8008700: 2300         	movs	r3, #0x0
 8008702: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 8008704: f06f 0315    	mvn	r3, #0x15
 8008708: e037         	b	0x800877a <uart_stm32_async_tx+0x18a> @ imm = #0x6e
; 	if (dma_start(data->dma_tx.dma_dev, data->dma_tx.dma_channel)) {
 800870a: 6afb         	ldr	r3, [r7, #0x2c]
 800870c: f8d3 20b8    	ldr.w	r2, [r3, #0xb8]
 8008710: 6afb         	ldr	r3, [r7, #0x2c]
 8008712: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 8008716: 4619         	mov	r1, r3
 8008718: 4610         	mov	r0, r2
 800871a: f00d fb58    	bl	0x8015dce <dma_start>   @ imm = #0xd6b0
 800871e: 4603         	mov	r3, r0
 8008720: 2b00         	cmp	r3, #0x0
 8008722: d01c         	beq	0x800875e <uart_stm32_async_tx+0x16e> @ imm = #0x38
; 		LOG_ERR("UART err: TX DMA start failed!");
 8008724: 2303         	movs	r3, #0x3
 8008726: 2b00         	cmp	r3, #0x0
 8008728: d016         	beq	0x8008758 <uart_stm32_async_tx+0x168> @ imm = #0x2c
 800872a: 2301         	movs	r3, #0x1
 800872c: 77fb         	strb	r3, [r7, #0x1f]
 800872e: 7ffb         	ldrb	r3, [r7, #0x1f]
 8008730: f083 0301    	eor	r3, r3, #0x1
 8008734: b2db         	uxtb	r3, r3
 8008736: 2b00         	cmp	r3, #0x0
 8008738: d10e         	bne	0x8008758 <uart_stm32_async_tx+0x168> @ imm = #0x1c
 800873a: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8008784 <uart_stm32_async_tx+0x194>
 800873c: 6819         	ldr	r1, [r3]
 800873e: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8008794 <uart_stm32_async_tx+0x1a4>
 8008740: 9302         	str	r3, [sp, #0x8]
 8008742: 2300         	movs	r3, #0x0
 8008744: 9301         	str	r3, [sp, #0x4]
 8008746: 2300         	movs	r3, #0x0
 8008748: 9300         	str	r3, [sp]
 800874a: 2300         	movs	r3, #0x0
 800874c: 2201         	movs	r2, #0x1
 800874e: 2000         	movs	r0, #0x0
 8008750: f00e f812    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xe024
 8008754: 2300         	movs	r3, #0x0
 8008756: 61bb         	str	r3, [r7, #0x18]
; 		return -EFAULT;
 8008758: f06f 030d    	mvn	r3, #0xd
 800875c: e00d         	b	0x800877a <uart_stm32_async_tx+0x18a> @ imm = #0x1a
; 	async_timer_start(&data->dma_tx.timeout_work, data->dma_tx.timeout);
 800875e: 6afb         	ldr	r3, [r7, #0x2c]
 8008760: f503 728c    	add.w	r2, r3, #0x118
 8008764: 6afb         	ldr	r3, [r7, #0x2c]
 8008766: f8d3 3114    	ldr.w	r3, [r3, #0x114]
 800876a: 4619         	mov	r1, r3
 800876c: 4610         	mov	r0, r2
 800876e: f7ff fd63    	bl	0x8008238 <async_timer_start> @ imm = #-0x53a
; 	uart_stm32_dma_tx_enable(dev);
 8008772: 68f8         	ldr	r0, [r7, #0xc]
 8008774: f00e fd2f    	bl	0x80171d6 <uart_stm32_dma_tx_enable> @ imm = #0xea5e
; 	return 0;
 8008778: 2300         	movs	r3, #0x0
; }
 800877a: 4618         	mov	r0, r3
 800877c: 3738         	adds	r7, #0x38
 800877e: 46bd         	mov	sp, r7
 8008780: bd80         	pop	{r7, pc}
 8008782: bf00         	nop

08008784 <$d>:
 8008784: 60 04 00 20  	.word	0x20000460
 8008788: 60 d6 01 08  	.word	0x0801d660
 800878c: c0 c4 01 08  	.word	0x0801c4c0
 8008790: d0 c4 01 08  	.word	0x0801c4d0
 8008794: e8 c4 01 08  	.word	0x0801c4e8

08008798 <uart_stm32_async_rx_enable>:
; {
 8008798: b580         	push	{r7, lr}
 800879a: b094         	sub	sp, #0x50
 800879c: af04         	add	r7, sp, #0x10
 800879e: 60f8         	str	r0, [r7, #0xc]
 80087a0: 60b9         	str	r1, [r7, #0x8]
 80087a2: 607a         	str	r2, [r7, #0x4]
 80087a4: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 80087a6: 68fb         	ldr	r3, [r7, #0xc]
 80087a8: 685b         	ldr	r3, [r3, #0x4]
 80087aa: 63fb         	str	r3, [r7, #0x3c]
; 	USART_TypeDef *usart = config->usart;
 80087ac: 6bfb         	ldr	r3, [r7, #0x3c]
 80087ae: 681b         	ldr	r3, [r3]
 80087b0: 63bb         	str	r3, [r7, #0x38]
; 	struct uart_stm32_data *data = dev->data;
 80087b2: 68fb         	ldr	r3, [r7, #0xc]
 80087b4: 691b         	ldr	r3, [r3, #0x10]
 80087b6: 637b         	str	r3, [r7, #0x34]
; 	if (data->dma_rx.dma_dev == NULL) {
 80087b8: 6b7b         	ldr	r3, [r7, #0x34]
 80087ba: 6a1b         	ldr	r3, [r3, #0x20]
 80087bc: 2b00         	cmp	r3, #0x0
 80087be: d102         	bne	0x80087c6 <uart_stm32_async_rx_enable+0x2e> @ imm = #0x4
; 		return -ENODEV;
 80087c0: f06f 0312    	mvn	r3, #0x12
 80087c4: e0c0         	b	0x8008948 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x180
; 	if (data->dma_rx.enabled) {
 80087c6: 6b7b         	ldr	r3, [r7, #0x34]
 80087c8: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 80087cc: 2b00         	cmp	r3, #0x0
 80087ce: d01c         	beq	0x800880a <uart_stm32_async_rx_enable+0x72> @ imm = #0x38
; 		LOG_WRN("RX was already enabled");
 80087d0: 2303         	movs	r3, #0x3
 80087d2: 2b01         	cmp	r3, #0x1
 80087d4: d916         	bls	0x8008804 <uart_stm32_async_rx_enable+0x6c> @ imm = #0x2c
 80087d6: 2301         	movs	r3, #0x1
 80087d8: 75fb         	strb	r3, [r7, #0x17]
 80087da: 7dfb         	ldrb	r3, [r7, #0x17]
 80087dc: f083 0301    	eor	r3, r3, #0x1
 80087e0: b2db         	uxtb	r3, r3
 80087e2: 2b00         	cmp	r3, #0x0
 80087e4: d10e         	bne	0x8008804 <uart_stm32_async_rx_enable+0x6c> @ imm = #0x1c
 80087e6: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x8008950 <uart_stm32_async_rx_enable+0x1b8>
 80087e8: 6819         	ldr	r1, [r3]
 80087ea: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x8008954 <uart_stm32_async_rx_enable+0x1bc>
 80087ec: 9302         	str	r3, [sp, #0x8]
 80087ee: 2300         	movs	r3, #0x0
 80087f0: 9301         	str	r3, [sp, #0x4]
 80087f2: 2300         	movs	r3, #0x0
 80087f4: 9300         	str	r3, [sp]
 80087f6: 2300         	movs	r3, #0x0
 80087f8: 2202         	movs	r2, #0x2
 80087fa: 2000         	movs	r0, #0x0
 80087fc: f00d ffbc    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xdf78
 8008800: 2300         	movs	r3, #0x0
 8008802: 613b         	str	r3, [r7, #0x10]
; 		return -EBUSY;
 8008804: f06f 030f    	mvn	r3, #0xf
 8008808: e09e         	b	0x8008948 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x13c
; 	data->dma_rx.offset = 0;
 800880a: 6b7b         	ldr	r3, [r7, #0x34]
 800880c: 2200         	movs	r2, #0x0
 800880e: 675a         	str	r2, [r3, #0x74]
; 	data->dma_rx.buffer = rx_buf;
 8008810: 6b7b         	ldr	r3, [r7, #0x34]
 8008812: 68ba         	ldr	r2, [r7, #0x8]
 8008814: 66da         	str	r2, [r3, #0x6c]
; 	data->dma_rx.buffer_length = buf_size;
 8008816: 6b7b         	ldr	r3, [r7, #0x34]
 8008818: 687a         	ldr	r2, [r7, #0x4]
 800881a: 671a         	str	r2, [r3, #0x70]
; 	data->dma_rx.counter = 0;
 800881c: 6b7b         	ldr	r3, [r7, #0x34]
 800881e: 2200         	movs	r2, #0x0
 8008820: 679a         	str	r2, [r3, #0x78]
; 	data->dma_rx.timeout = timeout;
 8008822: 6b7b         	ldr	r3, [r7, #0x34]
 8008824: 683a         	ldr	r2, [r7]
 8008826: 67da         	str	r2, [r3, #0x7c]
; 	LL_USART_DisableIT_RXNE(usart);
 8008828: 6bb8         	ldr	r0, [r7, #0x38]
 800882a: f00d fe4d    	bl	0x80164c8 <LL_USART_DisableIT_RXNE> @ imm = #0xdc9a
; 	data->dma_rx.blk_cfg.block_size = buf_size;
 800882e: 6b7b         	ldr	r3, [r7, #0x34]
 8008830: 687a         	ldr	r2, [r7, #0x4]
 8008832: 661a         	str	r2, [r3, #0x60]
; 	data->dma_rx.blk_cfg.dest_address = (uint32_t)data->dma_rx.buffer;
 8008834: 6b7b         	ldr	r3, [r7, #0x34]
 8008836: 6edb         	ldr	r3, [r3, #0x6c]
 8008838: 461a         	mov	r2, r3
 800883a: 6b7b         	ldr	r3, [r7, #0x34]
 800883c: 651a         	str	r2, [r3, #0x50]
; 	ret = dma_config(data->dma_rx.dma_dev, data->dma_rx.dma_channel,
 800883e: 6b7b         	ldr	r3, [r7, #0x34]
 8008840: 6a18         	ldr	r0, [r3, #0x20]
 8008842: 6b7b         	ldr	r3, [r7, #0x34]
 8008844: 6a59         	ldr	r1, [r3, #0x24]
 8008846: 6b7b         	ldr	r3, [r7, #0x34]
 8008848: 3328         	adds	r3, #0x28
 800884a: 461a         	mov	r2, r3
 800884c: f00d fa4d    	bl	0x8015cea <dma_config>  @ imm = #0xd49a
 8008850: 6338         	str	r0, [r7, #0x30]
; 	if (ret != 0) {
 8008852: 6b3b         	ldr	r3, [r7, #0x30]
 8008854: 2b00         	cmp	r3, #0x0
 8008856: d01c         	beq	0x8008892 <uart_stm32_async_rx_enable+0xfa> @ imm = #0x38
; 		LOG_ERR("UART ERR: RX DMA config failed!");
 8008858: 2303         	movs	r3, #0x3
 800885a: 2b00         	cmp	r3, #0x0
 800885c: d016         	beq	0x800888c <uart_stm32_async_rx_enable+0xf4> @ imm = #0x2c
 800885e: 2301         	movs	r3, #0x1
 8008860: 77fb         	strb	r3, [r7, #0x1f]
 8008862: 7ffb         	ldrb	r3, [r7, #0x1f]
 8008864: f083 0301    	eor	r3, r3, #0x1
 8008868: b2db         	uxtb	r3, r3
 800886a: 2b00         	cmp	r3, #0x0
 800886c: d10e         	bne	0x800888c <uart_stm32_async_rx_enable+0xf4> @ imm = #0x1c
 800886e: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8008950 <uart_stm32_async_rx_enable+0x1b8>
 8008870: 6819         	ldr	r1, [r3]
 8008872: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8008958 <uart_stm32_async_rx_enable+0x1c0>
 8008874: 9302         	str	r3, [sp, #0x8]
 8008876: 2300         	movs	r3, #0x0
 8008878: 9301         	str	r3, [sp, #0x4]
 800887a: 2300         	movs	r3, #0x0
 800887c: 9300         	str	r3, [sp]
 800887e: 2300         	movs	r3, #0x0
 8008880: 2201         	movs	r2, #0x1
 8008882: 2000         	movs	r0, #0x0
 8008884: f00d ff78    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xdef0
 8008888: 2300         	movs	r3, #0x0
 800888a: 61bb         	str	r3, [r7, #0x18]
; 		return -EINVAL;
 800888c: f06f 0315    	mvn	r3, #0x15
 8008890: e05a         	b	0x8008948 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0xb4
; 	if (dma_start(data->dma_rx.dma_dev, data->dma_rx.dma_channel)) {
 8008892: 6b7b         	ldr	r3, [r7, #0x34]
 8008894: 6a1a         	ldr	r2, [r3, #0x20]
 8008896: 6b7b         	ldr	r3, [r7, #0x34]
 8008898: 6a5b         	ldr	r3, [r3, #0x24]
 800889a: 4619         	mov	r1, r3
 800889c: 4610         	mov	r0, r2
 800889e: f00d fa96    	bl	0x8015dce <dma_start>   @ imm = #0xd52c
 80088a2: 4603         	mov	r3, r0
 80088a4: 2b00         	cmp	r3, #0x0
 80088a6: d01e         	beq	0x80088e6 <uart_stm32_async_rx_enable+0x14e> @ imm = #0x3c
; 		LOG_ERR("UART ERR: RX DMA start failed!");
 80088a8: 2303         	movs	r3, #0x3
 80088aa: 2b00         	cmp	r3, #0x0
 80088ac: d018         	beq	0x80088e0 <uart_stm32_async_rx_enable+0x148> @ imm = #0x30
 80088ae: 2301         	movs	r3, #0x1
 80088b0: f887 3027    	strb.w	r3, [r7, #0x27]
 80088b4: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80088b8: f083 0301    	eor	r3, r3, #0x1
 80088bc: b2db         	uxtb	r3, r3
 80088be: 2b00         	cmp	r3, #0x0
 80088c0: d10e         	bne	0x80088e0 <uart_stm32_async_rx_enable+0x148> @ imm = #0x1c
 80088c2: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8008950 <uart_stm32_async_rx_enable+0x1b8>
 80088c4: 6819         	ldr	r1, [r3]
 80088c6: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800895c <uart_stm32_async_rx_enable+0x1c4>
 80088c8: 9302         	str	r3, [sp, #0x8]
 80088ca: 2300         	movs	r3, #0x0
 80088cc: 9301         	str	r3, [sp, #0x4]
 80088ce: 2300         	movs	r3, #0x0
 80088d0: 9300         	str	r3, [sp]
 80088d2: 2300         	movs	r3, #0x0
 80088d4: 2201         	movs	r2, #0x1
 80088d6: 2000         	movs	r0, #0x0
 80088d8: f00d ff4e    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xde9c
 80088dc: 2300         	movs	r3, #0x0
 80088de: 623b         	str	r3, [r7, #0x20]
; 		return -EFAULT;
 80088e0: f06f 030d    	mvn	r3, #0xd
 80088e4: e030         	b	0x8008948 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x60
; 	LL_USART_ClearFlag_RXNE(usart);
 80088e6: 6bb8         	ldr	r0, [r7, #0x38]
 80088e8: f00d fcf9    	bl	0x80162de <LL_USART_ClearFlag_RXNE> @ imm = #0xd9f2
; 	uart_stm32_dma_rx_enable(dev);
 80088ec: 68f8         	ldr	r0, [r7, #0xc]
 80088ee: f00e fc92    	bl	0x8017216 <uart_stm32_dma_rx_enable> @ imm = #0xe924
; 	LL_USART_ClearFlag_IDLE(usart);
 80088f2: 6bb8         	ldr	r0, [r7, #0x38]
 80088f4: f00d fcd5    	bl	0x80162a2 <LL_USART_ClearFlag_IDLE> @ imm = #0xd9aa
; 	LL_USART_EnableIT_IDLE(usart);
 80088f8: 6bb8         	ldr	r0, [r7, #0x38]
 80088fa: f00d fd0a    	bl	0x8016312 <LL_USART_EnableIT_IDLE> @ imm = #0xda14
; 	LL_USART_EnableIT_ERROR(usart);
 80088fe: 6bb8         	ldr	r0, [r7, #0x38]
 8008900: f00d fd9e    	bl	0x8016440 <LL_USART_EnableIT_ERROR> @ imm = #0xdb3c
; 	async_evt_rx_buf_request(data);
 8008904: 6b78         	ldr	r0, [r7, #0x34]
 8008906: f00e fbf1    	bl	0x80170ec <async_evt_rx_buf_request> @ imm = #0xe7e2
; 	LOG_DBG("async rx enabled");
 800890a: 2303         	movs	r3, #0x3
 800890c: 2b03         	cmp	r3, #0x3
 800890e: d91a         	bls	0x8008946 <uart_stm32_async_rx_enable+0x1ae> @ imm = #0x34
 8008910: 2301         	movs	r3, #0x1
 8008912: f887 302f    	strb.w	r3, [r7, #0x2f]
 8008916: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800891a: f083 0301    	eor	r3, r3, #0x1
 800891e: b2db         	uxtb	r3, r3
 8008920: 2b00         	cmp	r3, #0x0
 8008922: d110         	bne	0x8008946 <uart_stm32_async_rx_enable+0x1ae> @ imm = #0x20
 8008924: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8008950 <uart_stm32_async_rx_enable+0x1b8>
 8008926: 6819         	ldr	r1, [r3]
 8008928: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8008960 <uart_stm32_async_rx_enable+0x1c8>
 800892a: 9303         	str	r3, [sp, #0xc]
 800892c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8008964 <uart_stm32_async_rx_enable+0x1cc>
 800892e: 9302         	str	r3, [sp, #0x8]
 8008930: 2308         	movs	r3, #0x8
 8008932: 9301         	str	r3, [sp, #0x4]
 8008934: 2300         	movs	r3, #0x0
 8008936: 9300         	str	r3, [sp]
 8008938: 2300         	movs	r3, #0x0
 800893a: 2204         	movs	r2, #0x4
 800893c: 2000         	movs	r0, #0x0
 800893e: f00d ff1b    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xde36
 8008942: 2300         	movs	r3, #0x0
 8008944: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8008946: 6b3b         	ldr	r3, [r7, #0x30]
; }
 8008948: 4618         	mov	r0, r3
 800894a: 3740         	adds	r7, #0x40
 800894c: 46bd         	mov	sp, r7
 800894e: bd80         	pop	{r7, pc}

08008950 <$d>:
 8008950: 60 04 00 20  	.word	0x20000460
 8008954: 08 c5 01 08  	.word	0x0801c508
 8008958: 20 c5 01 08  	.word	0x0801c520
 800895c: 40 c5 01 08  	.word	0x0801c540
 8008960: 74 d6 01 08  	.word	0x0801d674
 8008964: 60 c5 01 08  	.word	0x0801c560

08008968 <uart_stm32_async_rx_timeout>:
; {
 8008968: b580         	push	{r7, lr}
 800896a: b08c         	sub	sp, #0x30
 800896c: af04         	add	r7, sp, #0x10
 800896e: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 8008970: 6878         	ldr	r0, [r7, #0x4]
 8008972: f00d f983    	bl	0x8015c7c <k_work_delayable_from_work> @ imm = #0xd306
 8008976: 61f8         	str	r0, [r7, #0x1c]
; 	struct uart_dma_stream *rx_stream = CONTAINER_OF(dwork,
 8008978: 69fb         	ldr	r3, [r7, #0x1c]
 800897a: 3b60         	subs	r3, #0x60
 800897c: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = CONTAINER_OF(rx_stream,
 800897e: 69bb         	ldr	r3, [r7, #0x18]
 8008980: 3b20         	subs	r3, #0x20
 8008982: 617b         	str	r3, [r7, #0x14]
; 	const struct device *dev = data->uart_dev;
 8008984: 697b         	ldr	r3, [r7, #0x14]
 8008986: 691b         	ldr	r3, [r3, #0x10]
 8008988: 613b         	str	r3, [r7, #0x10]
; 	LOG_DBG("rx timeout");
 800898a: 2303         	movs	r3, #0x3
 800898c: 2b03         	cmp	r3, #0x3
 800898e: d918         	bls	0x80089c2 <uart_stm32_async_rx_timeout+0x5a> @ imm = #0x30
 8008990: 2301         	movs	r3, #0x1
 8008992: 73fb         	strb	r3, [r7, #0xf]
 8008994: 7bfb         	ldrb	r3, [r7, #0xf]
 8008996: f083 0301    	eor	r3, r3, #0x1
 800899a: b2db         	uxtb	r3, r3
 800899c: 2b00         	cmp	r3, #0x0
 800899e: d110         	bne	0x80089c2 <uart_stm32_async_rx_timeout+0x5a> @ imm = #0x20
 80089a0: 4b10         	ldr	r3, [pc, #0x40]         @ 0x80089e4 <uart_stm32_async_rx_timeout+0x7c>
 80089a2: 6819         	ldr	r1, [r3]
 80089a4: 4b10         	ldr	r3, [pc, #0x40]         @ 0x80089e8 <uart_stm32_async_rx_timeout+0x80>
 80089a6: 9303         	str	r3, [sp, #0xc]
 80089a8: 4b10         	ldr	r3, [pc, #0x40]         @ 0x80089ec <uart_stm32_async_rx_timeout+0x84>
 80089aa: 9302         	str	r3, [sp, #0x8]
 80089ac: 2308         	movs	r3, #0x8
 80089ae: 9301         	str	r3, [sp, #0x4]
 80089b0: 2300         	movs	r3, #0x0
 80089b2: 9300         	str	r3, [sp]
 80089b4: 2300         	movs	r3, #0x0
 80089b6: 2204         	movs	r2, #0x4
 80089b8: 2000         	movs	r0, #0x0
 80089ba: f00d fedd    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xddba
 80089be: 2300         	movs	r3, #0x0
 80089c0: 60bb         	str	r3, [r7, #0x8]
; 	if (data->dma_rx.counter == data->dma_rx.buffer_length) {
 80089c2: 697b         	ldr	r3, [r7, #0x14]
 80089c4: 6f9a         	ldr	r2, [r3, #0x78]
 80089c6: 697b         	ldr	r3, [r7, #0x14]
 80089c8: 6f1b         	ldr	r3, [r3, #0x70]
 80089ca: 429a         	cmp	r2, r3
 80089cc: d103         	bne	0x80089d6 <uart_stm32_async_rx_timeout+0x6e> @ imm = #0x6
; 		uart_stm32_async_rx_disable(dev);
 80089ce: 6938         	ldr	r0, [r7, #0x10]
 80089d0: f7ff fd04    	bl	0x80083dc <uart_stm32_async_rx_disable> @ imm = #-0x5f8
; }
 80089d4: e002         	b	0x80089dc <uart_stm32_async_rx_timeout+0x74> @ imm = #0x4
; 		uart_stm32_dma_rx_flush(dev);
 80089d6: 6938         	ldr	r0, [r7, #0x10]
 80089d8: f00e fbbb    	bl	0x8017152 <uart_stm32_dma_rx_flush> @ imm = #0xe776
; }
 80089dc: bf00         	nop
 80089de: 3720         	adds	r7, #0x20
 80089e0: 46bd         	mov	sp, r7
 80089e2: bd80         	pop	{r7, pc}

080089e4 <$d>:
 80089e4: 60 04 00 20  	.word	0x20000460
 80089e8: a4 d6 01 08  	.word	0x0801d6a4
 80089ec: 78 c5 01 08  	.word	0x0801c578

080089f0 <uart_stm32_async_tx_timeout>:
; {
 80089f0: b580         	push	{r7, lr}
 80089f2: b08c         	sub	sp, #0x30
 80089f4: af04         	add	r7, sp, #0x10
 80089f6: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 80089f8: 6878         	ldr	r0, [r7, #0x4]
 80089fa: f00d f93f    	bl	0x8015c7c <k_work_delayable_from_work> @ imm = #0xd27e
 80089fe: 61f8         	str	r0, [r7, #0x1c]
; 	struct uart_dma_stream *tx_stream = CONTAINER_OF(dwork,
 8008a00: 69fb         	ldr	r3, [r7, #0x1c]
 8008a02: 3b60         	subs	r3, #0x60
 8008a04: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = CONTAINER_OF(tx_stream,
 8008a06: 69bb         	ldr	r3, [r7, #0x18]
 8008a08: 3bb8         	subs	r3, #0xb8
 8008a0a: 617b         	str	r3, [r7, #0x14]
; 	const struct device *dev = data->uart_dev;
 8008a0c: 697b         	ldr	r3, [r7, #0x14]
 8008a0e: 691b         	ldr	r3, [r3, #0x10]
 8008a10: 613b         	str	r3, [r7, #0x10]
; 	uart_stm32_async_tx_abort(dev);
 8008a12: 6938         	ldr	r0, [r7, #0x10]
 8008a14: f00e fcae    	bl	0x8017374 <uart_stm32_async_tx_abort> @ imm = #0xe95c
; 	LOG_DBG("tx: async timeout");
 8008a18: 2303         	movs	r3, #0x3
 8008a1a: 2b03         	cmp	r3, #0x3
 8008a1c: d919         	bls	0x8008a52 <uart_stm32_async_tx_timeout+0x62> @ imm = #0x32
 8008a1e: 2301         	movs	r3, #0x1
 8008a20: 73fb         	strb	r3, [r7, #0xf]
 8008a22: 7bfb         	ldrb	r3, [r7, #0xf]
 8008a24: f083 0301    	eor	r3, r3, #0x1
 8008a28: b2db         	uxtb	r3, r3
 8008a2a: 2b00         	cmp	r3, #0x0
 8008a2c: d111         	bne	0x8008a52 <uart_stm32_async_tx_timeout+0x62> @ imm = #0x22
 8008a2e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008a5c <uart_stm32_async_tx_timeout+0x6c>
 8008a30: 6819         	ldr	r1, [r3]
 8008a32: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008a60 <uart_stm32_async_tx_timeout+0x70>
 8008a34: 9303         	str	r3, [sp, #0xc]
 8008a36: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008a64 <uart_stm32_async_tx_timeout+0x74>
 8008a38: 9302         	str	r3, [sp, #0x8]
 8008a3a: 2308         	movs	r3, #0x8
 8008a3c: 9301         	str	r3, [sp, #0x4]
 8008a3e: 2300         	movs	r3, #0x0
 8008a40: 9300         	str	r3, [sp]
 8008a42: 2300         	movs	r3, #0x0
 8008a44: 2204         	movs	r2, #0x4
 8008a46: 2000         	movs	r0, #0x0
 8008a48: f00d fe96    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xdd2c
 8008a4c: 2300         	movs	r3, #0x0
 8008a4e: 60bb         	str	r3, [r7, #0x8]
; }
 8008a50: bf00         	nop
 8008a52: bf00         	nop
 8008a54: 3720         	adds	r7, #0x20
 8008a56: 46bd         	mov	sp, r7
 8008a58: bd80         	pop	{r7, pc}
 8008a5a: bf00         	nop

08008a5c <$d>:
 8008a5c: 60 04 00 20  	.word	0x20000460
 8008a60: c0 d6 01 08  	.word	0x0801d6c0
 8008a64: 88 c5 01 08  	.word	0x0801c588

08008a68 <uart_stm32_async_rx_buf_rsp>:
; {
 8008a68: b580         	push	{r7, lr}
 8008a6a: b094         	sub	sp, #0x50
 8008a6c: af06         	add	r7, sp, #0x18
 8008a6e: 60f8         	str	r0, [r7, #0xc]
 8008a70: 60b9         	str	r1, [r7, #0x8]
 8008a72: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 8008a74: 68fb         	ldr	r3, [r7, #0xc]
 8008a76: 691b         	ldr	r3, [r3, #0x10]
 8008a78: 633b         	str	r3, [r7, #0x30]
; 	int err = 0;
 8008a7a: 2300         	movs	r3, #0x0
 8008a7c: 637b         	str	r3, [r7, #0x34]
; 	LOG_DBG("replace buffer (%d)", len);
 8008a7e: 2303         	movs	r3, #0x3
 8008a80: 2b03         	cmp	r3, #0x3
 8008a82: d91c         	bls	0x8008abe <uart_stm32_async_rx_buf_rsp+0x56> @ imm = #0x38
 8008a84: 2301         	movs	r3, #0x1
 8008a86: f887 302f    	strb.w	r3, [r7, #0x2f]
 8008a8a: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8008a8e: f083 0301    	eor	r3, r3, #0x1
 8008a92: b2db         	uxtb	r3, r3
 8008a94: 2b00         	cmp	r3, #0x0
 8008a96: d112         	bne	0x8008abe <uart_stm32_async_rx_buf_rsp+0x56> @ imm = #0x24
 8008a98: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8008b3c <uart_stm32_async_rx_buf_rsp+0xd4>
 8008a9a: 6819         	ldr	r1, [r3]
 8008a9c: 687b         	ldr	r3, [r7, #0x4]
 8008a9e: 9304         	str	r3, [sp, #0x10]
 8008aa0: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8008b40 <uart_stm32_async_rx_buf_rsp+0xd8>
 8008aa2: 9303         	str	r3, [sp, #0xc]
 8008aa4: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8008b44 <uart_stm32_async_rx_buf_rsp+0xdc>
 8008aa6: 9302         	str	r3, [sp, #0x8]
 8008aa8: 2308         	movs	r3, #0x8
 8008aaa: 9301         	str	r3, [sp, #0x4]
 8008aac: 2300         	movs	r3, #0x0
 8008aae: 9300         	str	r3, [sp]
 8008ab0: 2300         	movs	r3, #0x0
 8008ab2: 2204         	movs	r2, #0x4
 8008ab4: 2000         	movs	r0, #0x0
 8008ab6: f00d fe5f    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xdcbe
 8008aba: 2300         	movs	r3, #0x0
 8008abc: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8008abe: f3ef 8311    	mrs	r3, basepri
 8008ac2: 623b         	str	r3, [r7, #0x20]
;   return(result);
 8008ac4: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 8008ac6: 61fb         	str	r3, [r7, #0x1c]
 8008ac8: 2310         	movs	r3, #0x10
 8008aca: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8008acc: 69bb         	ldr	r3, [r7, #0x18]
 8008ace: f383 8812    	msr	basepri_max, r3
; }
 8008ad2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8008ad4: f3bf 8f6f    	isb	sy
; }
 8008ad8: bf00         	nop
; 	return key;
 8008ada: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = irq_lock();
 8008adc: 627b         	str	r3, [r7, #0x24]
; 	if (data->rx_next_buffer != NULL) {
 8008ade: 6b3b         	ldr	r3, [r7, #0x30]
 8008ae0: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 8008ae4: 2b00         	cmp	r3, #0x0
 8008ae6: d003         	beq	0x8008af0 <uart_stm32_async_rx_buf_rsp+0x88> @ imm = #0x6
; 		err = -EBUSY;
 8008ae8: f06f 030f    	mvn	r3, #0xf
 8008aec: 637b         	str	r3, [r7, #0x34]
 8008aee: e013         	b	0x8008b18 <uart_stm32_async_rx_buf_rsp+0xb0> @ imm = #0x26
; 	} else if (!data->dma_rx.enabled) {
 8008af0: 6b3b         	ldr	r3, [r7, #0x30]
 8008af2: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 8008af6: f083 0301    	eor	r3, r3, #0x1
 8008afa: b2db         	uxtb	r3, r3
 8008afc: 2b00         	cmp	r3, #0x0
 8008afe: d003         	beq	0x8008b08 <uart_stm32_async_rx_buf_rsp+0xa0> @ imm = #0x6
; 		err = -EACCES;
 8008b00: f06f 030c    	mvn	r3, #0xc
 8008b04: 637b         	str	r3, [r7, #0x34]
 8008b06: e007         	b	0x8008b18 <uart_stm32_async_rx_buf_rsp+0xb0> @ imm = #0xe
; 		data->rx_next_buffer = buf;
 8008b08: 6b3b         	ldr	r3, [r7, #0x30]
 8008b0a: 68ba         	ldr	r2, [r7, #0x8]
 8008b0c: f8c3 2150    	str.w	r2, [r3, #0x150]
; 		data->rx_next_buffer_len = len;
 8008b10: 6b3b         	ldr	r3, [r7, #0x30]
 8008b12: 687a         	ldr	r2, [r7, #0x4]
 8008b14: f8c3 2154    	str.w	r2, [r3, #0x154]
 8008b18: 6a7b         	ldr	r3, [r7, #0x24]
 8008b1a: 617b         	str	r3, [r7, #0x14]
 8008b1c: 697b         	ldr	r3, [r7, #0x14]
 8008b1e: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008b20: 693b         	ldr	r3, [r7, #0x10]
 8008b22: f383 8811    	msr	basepri, r3
; }
 8008b26: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8008b28: f3bf 8f6f    	isb	sy
; }
 8008b2c: bf00         	nop
; }
 8008b2e: bf00         	nop
; 	return err;
 8008b30: 6b7b         	ldr	r3, [r7, #0x34]
; }
 8008b32: 4618         	mov	r0, r3
 8008b34: 3738         	adds	r7, #0x38
 8008b36: 46bd         	mov	sp, r7
 8008b38: bd80         	pop	{r7, pc}
 8008b3a: bf00         	nop

08008b3c <$d>:
 8008b3c: 60 04 00 20  	.word	0x20000460
 8008b40: dc d6 01 08  	.word	0x0801d6dc
 8008b44: a0 c5 01 08  	.word	0x0801c5a0

08008b48 <uart_stm32_async_init>:
; {
 8008b48: b580         	push	{r7, lr}
 8008b4a: b086         	sub	sp, #0x18
 8008b4c: af00         	add	r7, sp, #0x0
 8008b4e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8008b50: 687b         	ldr	r3, [r7, #0x4]
 8008b52: 685b         	ldr	r3, [r3, #0x4]
 8008b54: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 8008b56: 697b         	ldr	r3, [r7, #0x14]
 8008b58: 681b         	ldr	r3, [r3]
 8008b5a: 613b         	str	r3, [r7, #0x10]
; 	struct uart_stm32_data *data = dev->data;
 8008b5c: 687b         	ldr	r3, [r7, #0x4]
 8008b5e: 691b         	ldr	r3, [r3, #0x10]
 8008b60: 60fb         	str	r3, [r7, #0xc]
; 	data->uart_dev = dev;
 8008b62: 68fb         	ldr	r3, [r7, #0xc]
 8008b64: 687a         	ldr	r2, [r7, #0x4]
 8008b66: 611a         	str	r2, [r3, #0x10]
; 	if (data->dma_rx.dma_dev != NULL) {
 8008b68: 68fb         	ldr	r3, [r7, #0xc]
 8008b6a: 6a1b         	ldr	r3, [r3, #0x20]
 8008b6c: 2b00         	cmp	r3, #0x0
 8008b6e: d00d         	beq	0x8008b8c <uart_stm32_async_init+0x44> @ imm = #0x1a
; 		if (!device_is_ready(data->dma_rx.dma_dev)) {
 8008b70: 68fb         	ldr	r3, [r7, #0xc]
 8008b72: 6a1b         	ldr	r3, [r3, #0x20]
 8008b74: 4618         	mov	r0, r3
 8008b76: f00d f875    	bl	0x8015c64 <device_is_ready> @ imm = #0xd0ea
 8008b7a: 4603         	mov	r3, r0
 8008b7c: f083 0301    	eor	r3, r3, #0x1
 8008b80: b2db         	uxtb	r3, r3
 8008b82: 2b00         	cmp	r3, #0x0
 8008b84: d002         	beq	0x8008b8c <uart_stm32_async_init+0x44> @ imm = #0x4
; 			return -ENODEV;
 8008b86: f06f 0312    	mvn	r3, #0x12
 8008b8a: e0de         	b	0x8008d4a <uart_stm32_async_init+0x202> @ imm = #0x1bc
; 	if (data->dma_tx.dma_dev != NULL) {
 8008b8c: 68fb         	ldr	r3, [r7, #0xc]
 8008b8e: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 8008b92: 2b00         	cmp	r3, #0x0
 8008b94: d00e         	beq	0x8008bb4 <uart_stm32_async_init+0x6c> @ imm = #0x1c
; 		if (!device_is_ready(data->dma_tx.dma_dev)) {
 8008b96: 68fb         	ldr	r3, [r7, #0xc]
 8008b98: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 8008b9c: 4618         	mov	r0, r3
 8008b9e: f00d f861    	bl	0x8015c64 <device_is_ready> @ imm = #0xd0c2
 8008ba2: 4603         	mov	r3, r0
 8008ba4: f083 0301    	eor	r3, r3, #0x1
 8008ba8: b2db         	uxtb	r3, r3
 8008baa: 2b00         	cmp	r3, #0x0
 8008bac: d002         	beq	0x8008bb4 <uart_stm32_async_init+0x6c> @ imm = #0x4
; 			return -ENODEV;
 8008bae: f06f 0312    	mvn	r3, #0x12
 8008bb2: e0ca         	b	0x8008d4a <uart_stm32_async_init+0x202> @ imm = #0x194
; 	uart_stm32_dma_rx_disable(dev);
 8008bb4: 6878         	ldr	r0, [r7, #0x4]
 8008bb6: f00e fb45    	bl	0x8017244 <uart_stm32_dma_rx_disable> @ imm = #0xe68a
; 	uart_stm32_dma_tx_disable(dev);
 8008bba: 6878         	ldr	r0, [r7, #0x4]
 8008bbc: f00e fb1b    	bl	0x80171f6 <uart_stm32_dma_tx_disable> @ imm = #0xe636
; 	k_work_init_delayable(&data->dma_rx.timeout_work,
 8008bc0: 68fb         	ldr	r3, [r7, #0xc]
 8008bc2: 3380         	adds	r3, #0x80
 8008bc4: 4963         	ldr	r1, [pc, #0x18c]        @ 0x8008d54 <uart_stm32_async_init+0x20c>
 8008bc6: 4618         	mov	r0, r3
 8008bc8: f010 fe89    	bl	0x80198de <k_work_init_delayable> @ imm = #0x10d12
; 	k_work_init_delayable(&data->dma_tx.timeout_work,
 8008bcc: 68fb         	ldr	r3, [r7, #0xc]
 8008bce: f503 738c    	add.w	r3, r3, #0x118
 8008bd2: 4961         	ldr	r1, [pc, #0x184]        @ 0x8008d58 <uart_stm32_async_init+0x210>
 8008bd4: 4618         	mov	r0, r3
 8008bd6: f010 fe82    	bl	0x80198de <k_work_init_delayable> @ imm = #0x10d04
; 	memset(&data->dma_rx.blk_cfg, 0, sizeof(data->dma_rx.blk_cfg));
 8008bda: 68fb         	ldr	r3, [r7, #0xc]
 8008bdc: 334c         	adds	r3, #0x4c
 8008bde: 2220         	movs	r2, #0x20
 8008be0: 2100         	movs	r1, #0x0
 8008be2: 4618         	mov	r0, r3
 8008be4: f011 fe24    	bl	0x801a830 <memset>      @ imm = #0x11c48
; 				LL_USART_DMA_GetRegAddr(usart);
 8008be8: 6938         	ldr	r0, [r7, #0x10]
 8008bea: f00d fda0    	bl	0x801672e <LL_USART_DMA_GetRegAddr> @ imm = #0xdb40
 8008bee: 4602         	mov	r2, r0
; 	data->dma_rx.blk_cfg.source_address =
 8008bf0: 68fb         	ldr	r3, [r7, #0xc]
 8008bf2: 64da         	str	r2, [r3, #0x4c]
; 	data->dma_rx.blk_cfg.dest_address = 0; /* dest not ready */
 8008bf4: 68fb         	ldr	r3, [r7, #0xc]
 8008bf6: 2200         	movs	r2, #0x0
 8008bf8: 651a         	str	r2, [r3, #0x50]
; 	if (data->dma_rx.src_addr_increment) {
 8008bfa: 68fb         	ldr	r3, [r7, #0xc]
 8008bfc: f893 3045    	ldrb.w	r3, [r3, #0x45]
 8008c00: 2b00         	cmp	r3, #0x0
 8008c02: d007         	beq	0x8008c14 <uart_stm32_async_init+0xcc> @ imm = #0xe
; 		data->dma_rx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 8008c04: 68fa         	ldr	r2, [r7, #0xc]
 8008c06: f892 3068    	ldrb.w	r3, [r2, #0x68]
 8008c0a: f36f 0383    	bfc	r3, #2, #2
 8008c0e: f882 3068    	strb.w	r3, [r2, #0x68]
 8008c12: e007         	b	0x8008c24 <uart_stm32_async_init+0xdc> @ imm = #0xe
; 		data->dma_rx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 8008c14: 68fa         	ldr	r2, [r7, #0xc]
 8008c16: f892 3068    	ldrb.w	r3, [r2, #0x68]
 8008c1a: 2102         	movs	r1, #0x2
 8008c1c: f361 0383    	bfi	r3, r1, #2, #2
 8008c20: f882 3068    	strb.w	r3, [r2, #0x68]
; 	if (data->dma_rx.dst_addr_increment) {
 8008c24: 68fb         	ldr	r3, [r7, #0xc]
 8008c26: f893 3046    	ldrb.w	r3, [r3, #0x46]
 8008c2a: 2b00         	cmp	r3, #0x0
 8008c2c: d007         	beq	0x8008c3e <uart_stm32_async_init+0xf6> @ imm = #0xe
; 		data->dma_rx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 8008c2e: 68fa         	ldr	r2, [r7, #0xc]
 8008c30: f892 3068    	ldrb.w	r3, [r2, #0x68]
 8008c34: f36f 1305    	bfc	r3, #4, #2
 8008c38: f882 3068    	strb.w	r3, [r2, #0x68]
 8008c3c: e007         	b	0x8008c4e <uart_stm32_async_init+0x106> @ imm = #0xe
; 		data->dma_rx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 8008c3e: 68fa         	ldr	r2, [r7, #0xc]
 8008c40: f892 3068    	ldrb.w	r3, [r2, #0x68]
 8008c44: 2102         	movs	r1, #0x2
 8008c46: f361 1305    	bfi	r3, r1, #4, #2
 8008c4a: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.source_reload_en  = 0;
 8008c4e: 68fa         	ldr	r2, [r7, #0xc]
 8008c50: f892 3068    	ldrb.w	r3, [r2, #0x68]
 8008c54: f36f 1386    	bfc	r3, #6, #1
 8008c58: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.dest_reload_en = 0;
 8008c5c: 68fa         	ldr	r2, [r7, #0xc]
 8008c5e: f892 3068    	ldrb.w	r3, [r2, #0x68]
 8008c62: f36f 13c7    	bfc	r3, #7, #1
 8008c66: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.fifo_mode_control = data->dma_rx.fifo_threshold;
 8008c6a: 68fb         	ldr	r3, [r7, #0xc]
 8008c6c: 6c9b         	ldr	r3, [r3, #0x48]
 8008c6e: f003 030f    	and	r3, r3, #0xf
 8008c72: b2d9         	uxtb	r1, r3
 8008c74: 68fa         	ldr	r2, [r7, #0xc]
 8008c76: f892 3069    	ldrb.w	r3, [r2, #0x69]
 8008c7a: f361 0303    	bfi	r3, r1, #0, #4
 8008c7e: f882 3069    	strb.w	r3, [r2, #0x69]
; 	data->dma_rx.dma_cfg.head_block = &data->dma_rx.blk_cfg;
 8008c82: 68fb         	ldr	r3, [r7, #0xc]
 8008c84: f103 024c    	add.w	r2, r3, #0x4c
 8008c88: 68fb         	ldr	r3, [r7, #0xc]
 8008c8a: 639a         	str	r2, [r3, #0x38]
; 	data->dma_rx.dma_cfg.user_data = (void *)dev;
 8008c8c: 68fb         	ldr	r3, [r7, #0xc]
 8008c8e: 687a         	ldr	r2, [r7, #0x4]
 8008c90: 63da         	str	r2, [r3, #0x3c]
; 	data->rx_next_buffer = NULL;
 8008c92: 68fb         	ldr	r3, [r7, #0xc]
 8008c94: 2200         	movs	r2, #0x0
 8008c96: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 8008c9a: 68fb         	ldr	r3, [r7, #0xc]
 8008c9c: 2200         	movs	r2, #0x0
 8008c9e: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	memset(&data->dma_tx.blk_cfg, 0, sizeof(data->dma_tx.blk_cfg));
 8008ca2: 68fb         	ldr	r3, [r7, #0xc]
 8008ca4: 33e4         	adds	r3, #0xe4
 8008ca6: 2220         	movs	r2, #0x20
 8008ca8: 2100         	movs	r1, #0x0
 8008caa: 4618         	mov	r0, r3
 8008cac: f011 fdc0    	bl	0x801a830 <memset>      @ imm = #0x11b80
; 			LL_USART_DMA_GetRegAddr(usart);
 8008cb0: 6938         	ldr	r0, [r7, #0x10]
 8008cb2: f00d fd3c    	bl	0x801672e <LL_USART_DMA_GetRegAddr> @ imm = #0xda78
 8008cb6: 4602         	mov	r2, r0
; 	data->dma_tx.blk_cfg.dest_address =
 8008cb8: 68fb         	ldr	r3, [r7, #0xc]
 8008cba: f8c3 20e8    	str.w	r2, [r3, #0xe8]
; 	data->dma_tx.blk_cfg.source_address = 0; /* not ready */
 8008cbe: 68fb         	ldr	r3, [r7, #0xc]
 8008cc0: 2200         	movs	r2, #0x0
 8008cc2: f8c3 20e4    	str.w	r2, [r3, #0xe4]
; 	if (data->dma_tx.src_addr_increment) {
 8008cc6: 68fb         	ldr	r3, [r7, #0xc]
 8008cc8: f893 30dd    	ldrb.w	r3, [r3, #0xdd]
 8008ccc: 2b00         	cmp	r3, #0x0
 8008cce: d007         	beq	0x8008ce0 <uart_stm32_async_init+0x198> @ imm = #0xe
; 		data->dma_tx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 8008cd0: 68fa         	ldr	r2, [r7, #0xc]
 8008cd2: f892 3100    	ldrb.w	r3, [r2, #0x100]
 8008cd6: f36f 0383    	bfc	r3, #2, #2
 8008cda: f882 3100    	strb.w	r3, [r2, #0x100]
 8008cde: e007         	b	0x8008cf0 <uart_stm32_async_init+0x1a8> @ imm = #0xe
; 		data->dma_tx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 8008ce0: 68fa         	ldr	r2, [r7, #0xc]
 8008ce2: f892 3100    	ldrb.w	r3, [r2, #0x100]
 8008ce6: 2102         	movs	r1, #0x2
 8008ce8: f361 0383    	bfi	r3, r1, #2, #2
 8008cec: f882 3100    	strb.w	r3, [r2, #0x100]
; 	if (data->dma_tx.dst_addr_increment) {
 8008cf0: 68fb         	ldr	r3, [r7, #0xc]
 8008cf2: f893 30de    	ldrb.w	r3, [r3, #0xde]
 8008cf6: 2b00         	cmp	r3, #0x0
 8008cf8: d007         	beq	0x8008d0a <uart_stm32_async_init+0x1c2> @ imm = #0xe
; 		data->dma_tx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 8008cfa: 68fa         	ldr	r2, [r7, #0xc]
 8008cfc: f892 3100    	ldrb.w	r3, [r2, #0x100]
 8008d00: f36f 1305    	bfc	r3, #4, #2
 8008d04: f882 3100    	strb.w	r3, [r2, #0x100]
 8008d08: e007         	b	0x8008d1a <uart_stm32_async_init+0x1d2> @ imm = #0xe
; 		data->dma_tx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 8008d0a: 68fa         	ldr	r2, [r7, #0xc]
 8008d0c: f892 3100    	ldrb.w	r3, [r2, #0x100]
 8008d10: 2102         	movs	r1, #0x2
 8008d12: f361 1305    	bfi	r3, r1, #4, #2
 8008d16: f882 3100    	strb.w	r3, [r2, #0x100]
; 	data->dma_tx.blk_cfg.fifo_mode_control = data->dma_tx.fifo_threshold;
 8008d1a: 68fb         	ldr	r3, [r7, #0xc]
 8008d1c: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 8008d20: f003 030f    	and	r3, r3, #0xf
 8008d24: b2d9         	uxtb	r1, r3
 8008d26: 68fa         	ldr	r2, [r7, #0xc]
 8008d28: f892 3101    	ldrb.w	r3, [r2, #0x101]
 8008d2c: f361 0303    	bfi	r3, r1, #0, #4
 8008d30: f882 3101    	strb.w	r3, [r2, #0x101]
; 	data->dma_tx.dma_cfg.head_block = &data->dma_tx.blk_cfg;
 8008d34: 68fb         	ldr	r3, [r7, #0xc]
 8008d36: f103 02e4    	add.w	r2, r3, #0xe4
 8008d3a: 68fb         	ldr	r3, [r7, #0xc]
 8008d3c: f8c3 20d0    	str.w	r2, [r3, #0xd0]
; 	data->dma_tx.dma_cfg.user_data = (void *)dev;
 8008d40: 68fb         	ldr	r3, [r7, #0xc]
 8008d42: 687a         	ldr	r2, [r7, #0x4]
 8008d44: f8c3 20d4    	str.w	r2, [r3, #0xd4]
; 	return 0;
 8008d48: 2300         	movs	r3, #0x0
; }
 8008d4a: 4618         	mov	r0, r3
 8008d4c: 3718         	adds	r7, #0x18
 8008d4e: 46bd         	mov	sp, r7
 8008d50: bd80         	pop	{r7, pc}
 8008d52: bf00         	nop

08008d54 <$d>:
 8008d54: 69 89 00 08  	.word	0x08008969
 8008d58: f1 89 00 08  	.word	0x080089f1

08008d5c <uart_stm32_clocks_enable>:
; {
 8008d5c: b580         	push	{r7, lr}
 8008d5e: b08e         	sub	sp, #0x38
 8008d60: af04         	add	r7, sp, #0x10
 8008d62: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8008d64: 687b         	ldr	r3, [r7, #0x4]
 8008d66: 685b         	ldr	r3, [r3, #0x4]
 8008d68: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 8008d6a: 687b         	ldr	r3, [r7, #0x4]
 8008d6c: 691b         	ldr	r3, [r3, #0x10]
 8008d6e: 627b         	str	r3, [r7, #0x24]
; 	__uart_stm32_get_clock(dev);
 8008d70: 6878         	ldr	r0, [r7, #0x4]
 8008d72: f7ff f853    	bl	0x8007e1c <__uart_stm32_get_clock> @ imm = #-0xf5a
; 	if (!device_is_ready(data->clock)) {
 8008d76: 6a7b         	ldr	r3, [r7, #0x24]
 8008d78: 681b         	ldr	r3, [r3]
 8008d7a: 4618         	mov	r0, r3
 8008d7c: f00c ff72    	bl	0x8015c64 <device_is_ready> @ imm = #0xcee4
 8008d80: 4603         	mov	r3, r0
 8008d82: f083 0301    	eor	r3, r3, #0x1
 8008d86: b2db         	uxtb	r3, r3
 8008d88: 2b00         	cmp	r3, #0x0
 8008d8a: d01c         	beq	0x8008dc6 <uart_stm32_clocks_enable+0x6a> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 8008d8c: 2303         	movs	r3, #0x3
 8008d8e: 2b00         	cmp	r3, #0x0
 8008d90: d016         	beq	0x8008dc0 <uart_stm32_clocks_enable+0x64> @ imm = #0x2c
 8008d92: 2301         	movs	r3, #0x1
 8008d94: 74fb         	strb	r3, [r7, #0x13]
 8008d96: 7cfb         	ldrb	r3, [r7, #0x13]
 8008d98: f083 0301    	eor	r3, r3, #0x1
 8008d9c: b2db         	uxtb	r3, r3
 8008d9e: 2b00         	cmp	r3, #0x0
 8008da0: d10e         	bne	0x8008dc0 <uart_stm32_clocks_enable+0x64> @ imm = #0x1c
 8008da2: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8008e20 <uart_stm32_clocks_enable+0xc4>
 8008da4: 6819         	ldr	r1, [r3]
 8008da6: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8008e24 <uart_stm32_clocks_enable+0xc8>
 8008da8: 9302         	str	r3, [sp, #0x8]
 8008daa: 2300         	movs	r3, #0x0
 8008dac: 9301         	str	r3, [sp, #0x4]
 8008dae: 2300         	movs	r3, #0x0
 8008db0: 9300         	str	r3, [sp]
 8008db2: 2300         	movs	r3, #0x0
 8008db4: 2201         	movs	r2, #0x1
 8008db6: 2000         	movs	r0, #0x0
 8008db8: f00d fcde    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xd9bc
 8008dbc: 2300         	movs	r3, #0x0
 8008dbe: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 8008dc0: f06f 0312    	mvn	r3, #0x12
 8008dc4: e028         	b	0x8008e18 <uart_stm32_clocks_enable+0xbc> @ imm = #0x50
; 	err = clock_control_on(data->clock, (clock_control_subsys_t)&config->pclken[0]);
 8008dc6: 6a7b         	ldr	r3, [r7, #0x24]
 8008dc8: 681a         	ldr	r2, [r3]
 8008dca: 6a3b         	ldr	r3, [r7, #0x20]
 8008dcc: 68db         	ldr	r3, [r3, #0xc]
 8008dce: 4619         	mov	r1, r3
 8008dd0: 4610         	mov	r0, r2
 8008dd2: f00c ff5d    	bl	0x8015c90 <clock_control_on> @ imm = #0xceba
 8008dd6: 61f8         	str	r0, [r7, #0x1c]
; 	if (err != 0) {
 8008dd8: 69fb         	ldr	r3, [r7, #0x1c]
 8008dda: 2b00         	cmp	r3, #0x0
 8008ddc: d01b         	beq	0x8008e16 <uart_stm32_clocks_enable+0xba> @ imm = #0x36
; 		LOG_ERR("Could not enable (LP)UART clock");
 8008dde: 2303         	movs	r3, #0x3
 8008de0: 2b00         	cmp	r3, #0x0
 8008de2: d016         	beq	0x8008e12 <uart_stm32_clocks_enable+0xb6> @ imm = #0x2c
 8008de4: 2301         	movs	r3, #0x1
 8008de6: 76fb         	strb	r3, [r7, #0x1b]
 8008de8: 7efb         	ldrb	r3, [r7, #0x1b]
 8008dea: f083 0301    	eor	r3, r3, #0x1
 8008dee: b2db         	uxtb	r3, r3
 8008df0: 2b00         	cmp	r3, #0x0
 8008df2: d10e         	bne	0x8008e12 <uart_stm32_clocks_enable+0xb6> @ imm = #0x1c
 8008df4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8008e20 <uart_stm32_clocks_enable+0xc4>
 8008df6: 6819         	ldr	r1, [r3]
 8008df8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008e28 <uart_stm32_clocks_enable+0xcc>
 8008dfa: 9302         	str	r3, [sp, #0x8]
 8008dfc: 2300         	movs	r3, #0x0
 8008dfe: 9301         	str	r3, [sp, #0x4]
 8008e00: 2300         	movs	r3, #0x0
 8008e02: 9300         	str	r3, [sp]
 8008e04: 2300         	movs	r3, #0x0
 8008e06: 2201         	movs	r2, #0x1
 8008e08: 2000         	movs	r0, #0x0
 8008e0a: f00d fcb5    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xd96a
 8008e0e: 2300         	movs	r3, #0x0
 8008e10: 617b         	str	r3, [r7, #0x14]
; 		return err;
 8008e12: 69fb         	ldr	r3, [r7, #0x1c]
 8008e14: e000         	b	0x8008e18 <uart_stm32_clocks_enable+0xbc> @ imm = #0x0
; 	return 0;
 8008e16: 2300         	movs	r3, #0x0
; }
 8008e18: 4618         	mov	r0, r3
 8008e1a: 3728         	adds	r7, #0x28
 8008e1c: 46bd         	mov	sp, r7
 8008e1e: bd80         	pop	{r7, pc}

08008e20 <$d>:
 8008e20: 60 04 00 20  	.word	0x20000460
 8008e24: b8 c5 01 08  	.word	0x0801c5b8
 8008e28: d8 c5 01 08  	.word	0x0801c5d8

08008e2c <uart_stm32_registers_configure>:
; {
 8008e2c: b580         	push	{r7, lr}
 8008e2e: b08c         	sub	sp, #0x30
 8008e30: af04         	add	r7, sp, #0x10
 8008e32: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8008e34: 687b         	ldr	r3, [r7, #0x4]
 8008e36: 685b         	ldr	r3, [r3, #0x4]
 8008e38: 61fb         	str	r3, [r7, #0x1c]
; 	USART_TypeDef *usart = config->usart;
 8008e3a: 69fb         	ldr	r3, [r7, #0x1c]
 8008e3c: 681b         	ldr	r3, [r3]
 8008e3e: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = dev->data;
 8008e40: 687b         	ldr	r3, [r7, #0x4]
 8008e42: 691b         	ldr	r3, [r3, #0x10]
 8008e44: 617b         	str	r3, [r7, #0x14]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 8008e46: 697b         	ldr	r3, [r7, #0x14]
 8008e48: 685b         	ldr	r3, [r3, #0x4]
 8008e4a: 613b         	str	r3, [r7, #0x10]
; 	LL_USART_Disable(usart);
 8008e4c: 69b8         	ldr	r0, [r7, #0x18]
 8008e4e: f00d f852    	bl	0x8015ef6 <LL_USART_Disable> @ imm = #0xd0a4
; 	if (!device_is_ready(config->reset.dev)) {
 8008e52: 69fb         	ldr	r3, [r7, #0x1c]
 8008e54: 685b         	ldr	r3, [r3, #0x4]
 8008e56: 4618         	mov	r0, r3
 8008e58: f00c ff04    	bl	0x8015c64 <device_is_ready> @ imm = #0xce08
 8008e5c: 4603         	mov	r3, r0
 8008e5e: f083 0301    	eor	r3, r3, #0x1
 8008e62: b2db         	uxtb	r3, r3
 8008e64: 2b00         	cmp	r3, #0x0
 8008e66: d01c         	beq	0x8008ea2 <uart_stm32_registers_configure+0x76> @ imm = #0x38
; 		LOG_ERR("reset controller not ready");
 8008e68: 2303         	movs	r3, #0x3
 8008e6a: 2b00         	cmp	r3, #0x0
 8008e6c: d016         	beq	0x8008e9c <uart_stm32_registers_configure+0x70> @ imm = #0x2c
 8008e6e: 2301         	movs	r3, #0x1
 8008e70: 73fb         	strb	r3, [r7, #0xf]
 8008e72: 7bfb         	ldrb	r3, [r7, #0xf]
 8008e74: f083 0301    	eor	r3, r3, #0x1
 8008e78: b2db         	uxtb	r3, r3
 8008e7a: 2b00         	cmp	r3, #0x0
 8008e7c: d10e         	bne	0x8008e9c <uart_stm32_registers_configure+0x70> @ imm = #0x1c
 8008e7e: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8008edc <uart_stm32_registers_configure+0xb0>
 8008e80: 6819         	ldr	r1, [r3]
 8008e82: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8008ee0 <uart_stm32_registers_configure+0xb4>
 8008e84: 9302         	str	r3, [sp, #0x8]
 8008e86: 2300         	movs	r3, #0x0
 8008e88: 9301         	str	r3, [sp, #0x4]
 8008e8a: 2300         	movs	r3, #0x0
 8008e8c: 9300         	str	r3, [sp]
 8008e8e: 2300         	movs	r3, #0x0
 8008e90: 2201         	movs	r2, #0x1
 8008e92: 2000         	movs	r0, #0x0
 8008e94: f00d fc70    	bl	0x8016778 <z_log_msg_runtime_create> @ imm = #0xd8e0
 8008e98: 2300         	movs	r3, #0x0
 8008e9a: 60bb         	str	r3, [r7, #0x8]
; 		return -ENODEV;
 8008e9c: f06f 0312    	mvn	r3, #0x12
 8008ea0: e017         	b	0x8008ed2 <uart_stm32_registers_configure+0xa6> @ imm = #0x2e
; 	(void)reset_line_toggle_dt(&config->reset);
 8008ea2: 69fb         	ldr	r3, [r7, #0x1c]
 8008ea4: 3304         	adds	r3, #0x4
 8008ea6: 4618         	mov	r0, r3
 8008ea8: f00c fff7    	bl	0x8015e9a <reset_line_toggle_dt> @ imm = #0xcfee
; 	LL_USART_SetTransferDirection(usart, LL_USART_DIRECTION_TX_RX);
 8008eac: 210c         	movs	r1, #0xc
 8008eae: 69b8         	ldr	r0, [r7, #0x18]
 8008eb0: f00d f830    	bl	0x8015f14 <LL_USART_SetTransferDirection> @ imm = #0xd060
; 	uart_stm32_parameters_set(dev, uart_cfg);
 8008eb4: 6939         	ldr	r1, [r7, #0x10]
 8008eb6: 6878         	ldr	r0, [r7, #0x4]
 8008eb8: f00d fdce    	bl	0x8016a58 <uart_stm32_parameters_set> @ imm = #0xdb9c
; 	if (config->single_wire) {
 8008ebc: 69fb         	ldr	r3, [r7, #0x1c]
 8008ebe: 7d1b         	ldrb	r3, [r3, #0x14]
 8008ec0: 2b00         	cmp	r3, #0x0
 8008ec2: d002         	beq	0x8008eca <uart_stm32_registers_configure+0x9e> @ imm = #0x4
; 		LL_USART_EnableHalfDuplex(usart);
 8008ec4: 69b8         	ldr	r0, [r7, #0x18]
 8008ec6: f00d f8f6    	bl	0x80160b6 <LL_USART_EnableHalfDuplex> @ imm = #0xd1ec
; 	LL_USART_Enable(usart);
 8008eca: 69b8         	ldr	r0, [r7, #0x18]
 8008ecc: f00d f804    	bl	0x8015ed8 <LL_USART_Enable> @ imm = #0xd008
; 	return 0;
 8008ed0: 2300         	movs	r3, #0x0
; }
 8008ed2: 4618         	mov	r0, r3
 8008ed4: 3720         	adds	r7, #0x20
 8008ed6: 46bd         	mov	sp, r7
 8008ed8: bd80         	pop	{r7, pc}
 8008eda: bf00         	nop

08008edc <$d>:
 8008edc: 60 04 00 20  	.word	0x20000460
 8008ee0: f8 c5 01 08  	.word	0x0801c5f8

08008ee4 <spi_context_cs_configure_all>:
; {
 8008ee4: b580         	push	{r7, lr}
 8008ee6: b08c         	sub	sp, #0x30
 8008ee8: af06         	add	r7, sp, #0x18
 8008eea: 6078         	str	r0, [r7, #0x4]
; 	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
 8008eec: 687b         	ldr	r3, [r7, #0x4]
 8008eee: 689b         	ldr	r3, [r3, #0x8]
 8008ef0: 617b         	str	r3, [r7, #0x14]
 8008ef2: e03c         	b	0x8008f6e <spi_context_cs_configure_all+0x8a> @ imm = #0x78
; 		if (!device_is_ready(cs_gpio->port)) {
 8008ef4: 697b         	ldr	r3, [r7, #0x14]
 8008ef6: 681b         	ldr	r3, [r3]
 8008ef8: 4618         	mov	r0, r3
 8008efa: f00e fad6    	bl	0x80174aa <device_is_ready> @ imm = #0xe5ac
 8008efe: 4603         	mov	r3, r0
 8008f00: f083 0301    	eor	r3, r3, #0x1
 8008f04: b2db         	uxtb	r3, r3
 8008f06: 2b00         	cmp	r3, #0x0
 8008f08: d023         	beq	0x8008f52 <spi_context_cs_configure_all+0x6e> @ imm = #0x46
; 			LOG_ERR("CS GPIO port %s pin %d is not ready",
 8008f0a: 2303         	movs	r3, #0x3
 8008f0c: 2b00         	cmp	r3, #0x0
 8008f0e: d01d         	beq	0x8008f4c <spi_context_cs_configure_all+0x68> @ imm = #0x3a
 8008f10: 2301         	movs	r3, #0x1
 8008f12: 73fb         	strb	r3, [r7, #0xf]
 8008f14: 7bfb         	ldrb	r3, [r7, #0xf]
 8008f16: f083 0301    	eor	r3, r3, #0x1
 8008f1a: b2db         	uxtb	r3, r3
 8008f1c: 2b00         	cmp	r3, #0x0
 8008f1e: d115         	bne	0x8008f4c <spi_context_cs_configure_all+0x68> @ imm = #0x2a
 8008f20: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8008f8c <spi_context_cs_configure_all+0xa8>
 8008f22: 6819         	ldr	r1, [r3]
 8008f24: 697b         	ldr	r3, [r7, #0x14]
 8008f26: 681b         	ldr	r3, [r3]
 8008f28: 681b         	ldr	r3, [r3]
 8008f2a: 697a         	ldr	r2, [r7, #0x14]
 8008f2c: 7912         	ldrb	r2, [r2, #0x4]
 8008f2e: 9204         	str	r2, [sp, #0x10]
 8008f30: 9303         	str	r3, [sp, #0xc]
 8008f32: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8008f90 <spi_context_cs_configure_all+0xac>
 8008f34: 9302         	str	r3, [sp, #0x8]
 8008f36: 2300         	movs	r3, #0x0
 8008f38: 9301         	str	r3, [sp, #0x4]
 8008f3a: 2300         	movs	r3, #0x0
 8008f3c: 9300         	str	r3, [sp]
 8008f3e: 2300         	movs	r3, #0x0
 8008f40: 2201         	movs	r2, #0x1
 8008f42: 2000         	movs	r0, #0x0
 8008f44: f00e fabd    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xe57a
 8008f48: 2300         	movs	r3, #0x0
 8008f4a: 60bb         	str	r3, [r7, #0x8]
; 			return -ENODEV;
 8008f4c: f06f 0312    	mvn	r3, #0x12
 8008f50: e017         	b	0x8008f82 <spi_context_cs_configure_all+0x9e> @ imm = #0x2e
; 		ret = gpio_pin_configure_dt(cs_gpio, GPIO_OUTPUT_INACTIVE);
 8008f52: f44f 11b0    	mov.w	r1, #0x160000
 8008f56: 6978         	ldr	r0, [r7, #0x14]
 8008f58: f00e fd18    	bl	0x801798c <gpio_pin_configure_dt> @ imm = #0xea30
 8008f5c: 6138         	str	r0, [r7, #0x10]
; 		if (ret < 0) {
 8008f5e: 693b         	ldr	r3, [r7, #0x10]
 8008f60: 2b00         	cmp	r3, #0x0
 8008f62: da01         	bge	0x8008f68 <spi_context_cs_configure_all+0x84> @ imm = #0x2
; 			return ret;
 8008f64: 693b         	ldr	r3, [r7, #0x10]
 8008f66: e00c         	b	0x8008f82 <spi_context_cs_configure_all+0x9e> @ imm = #0x18
; 	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
 8008f68: 697b         	ldr	r3, [r7, #0x14]
 8008f6a: 3308         	adds	r3, #0x8
 8008f6c: 617b         	str	r3, [r7, #0x14]
 8008f6e: 687b         	ldr	r3, [r7, #0x4]
 8008f70: 689a         	ldr	r2, [r3, #0x8]
 8008f72: 687b         	ldr	r3, [r7, #0x4]
 8008f74: 68db         	ldr	r3, [r3, #0xc]
 8008f76: 00db         	lsls	r3, r3, #0x3
 8008f78: 4413         	add	r3, r2
 8008f7a: 697a         	ldr	r2, [r7, #0x14]
 8008f7c: 429a         	cmp	r2, r3
 8008f7e: d3b9         	blo	0x8008ef4 <spi_context_cs_configure_all+0x10> @ imm = #-0x8e
; 	return 0;
 8008f80: 2300         	movs	r3, #0x0
; }
 8008f82: 4618         	mov	r0, r3
 8008f84: 3718         	adds	r7, #0x18
 8008f86: 46bd         	mov	sp, r7
 8008f88: bd80         	pop	{r7, pc}
 8008f8a: bf00         	nop

08008f8c <$d>:
 8008f8c: 7c 04 00 20  	.word	0x2000047c
 8008f90: 54 c6 01 08  	.word	0x0801c654

08008f94 <spi_context_buffers_setup>:
; {
 8008f94: b5f0         	push	{r4, r5, r6, r7, lr}
 8008f96: b097         	sub	sp, #0x5c
 8008f98: af0c         	add	r7, sp, #0x30
 8008f9a: 6178         	str	r0, [r7, #0x14]
 8008f9c: 6139         	str	r1, [r7, #0x10]
 8008f9e: 60fa         	str	r2, [r7, #0xc]
 8008fa0: 72fb         	strb	r3, [r7, #0xb]
; 	LOG_DBG("tx_bufs %p - rx_bufs %p - %u", tx_bufs, rx_bufs, dfs);
 8008fa2: 2303         	movs	r3, #0x3
 8008fa4: 2b03         	cmp	r3, #0x3
 8008fa6: d920         	bls	0x8008fea <spi_context_buffers_setup+0x56> @ imm = #0x40
 8008fa8: 2301         	movs	r3, #0x1
 8008faa: f887 3023    	strb.w	r3, [r7, #0x23]
 8008fae: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8008fb2: f083 0301    	eor	r3, r3, #0x1
 8008fb6: b2db         	uxtb	r3, r3
 8008fb8: 2b00         	cmp	r3, #0x0
 8008fba: d116         	bne	0x8008fea <spi_context_buffers_setup+0x56> @ imm = #0x2c
 8008fbc: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x80090f8 <spi_context_buffers_setup+0x164>
 8008fbe: 6819         	ldr	r1, [r3]
 8008fc0: 7afb         	ldrb	r3, [r7, #0xb]
 8008fc2: 9306         	str	r3, [sp, #0x18]
 8008fc4: 68fb         	ldr	r3, [r7, #0xc]
 8008fc6: 9305         	str	r3, [sp, #0x14]
 8008fc8: 693b         	ldr	r3, [r7, #0x10]
 8008fca: 9304         	str	r3, [sp, #0x10]
 8008fcc: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x80090fc <spi_context_buffers_setup+0x168>
 8008fce: 9303         	str	r3, [sp, #0xc]
 8008fd0: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8009100 <spi_context_buffers_setup+0x16c>
 8008fd2: 9302         	str	r3, [sp, #0x8]
 8008fd4: 2308         	movs	r3, #0x8
 8008fd6: 9301         	str	r3, [sp, #0x4]
 8008fd8: 2300         	movs	r3, #0x0
 8008fda: 9300         	str	r3, [sp]
 8008fdc: 2300         	movs	r3, #0x0
 8008fde: 2204         	movs	r2, #0x4
 8008fe0: 2000         	movs	r0, #0x0
 8008fe2: f00e fa6e    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xe4dc
 8008fe6: 2300         	movs	r3, #0x0
 8008fe8: 627b         	str	r3, [r7, #0x24]
; 	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
 8008fea: 693b         	ldr	r3, [r7, #0x10]
 8008fec: 2b00         	cmp	r3, #0x0
 8008fee: d002         	beq	0x8008ff6 <spi_context_buffers_setup+0x62> @ imm = #0x4
 8008ff0: 693b         	ldr	r3, [r7, #0x10]
 8008ff2: 681b         	ldr	r3, [r3]
 8008ff4: e000         	b	0x8008ff8 <spi_context_buffers_setup+0x64> @ imm = #0x0
 8008ff6: 2300         	movs	r3, #0x0
 8008ff8: 697a         	ldr	r2, [r7, #0x14]
 8008ffa: 6353         	str	r3, [r2, #0x34]
; 	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
 8008ffc: 697b         	ldr	r3, [r7, #0x14]
 8008ffe: 6b5b         	ldr	r3, [r3, #0x34]
 8009000: 2b00         	cmp	r3, #0x0
 8009002: d002         	beq	0x800900a <spi_context_buffers_setup+0x76> @ imm = #0x4
 8009004: 693b         	ldr	r3, [r7, #0x10]
 8009006: 685b         	ldr	r3, [r3, #0x4]
 8009008: e000         	b	0x800900c <spi_context_buffers_setup+0x78> @ imm = #0x0
 800900a: 2300         	movs	r3, #0x0
 800900c: 697a         	ldr	r2, [r7, #0x14]
 800900e: 6393         	str	r3, [r2, #0x38]
; 		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
 8009010: 697b         	ldr	r3, [r7, #0x14]
 8009012: f103 0034    	add.w	r0, r3, #0x34
 8009016: 697b         	ldr	r3, [r7, #0x14]
 8009018: f103 0138    	add.w	r1, r3, #0x38
 800901c: 697b         	ldr	r3, [r7, #0x14]
 800901e: f103 0248    	add.w	r2, r3, #0x48
 8009022: 7afb         	ldrb	r3, [r7, #0xb]
 8009024: f00e feb8    	bl	0x8017d98 <spi_context_get_next_buf> @ imm = #0xed70
 8009028: 4602         	mov	r2, r0
; 	ctx->tx_buf = (const uint8_t *)
 800902a: 697b         	ldr	r3, [r7, #0x14]
 800902c: 645a         	str	r2, [r3, #0x44]
; 	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
 800902e: 68fb         	ldr	r3, [r7, #0xc]
 8009030: 2b00         	cmp	r3, #0x0
 8009032: d002         	beq	0x800903a <spi_context_buffers_setup+0xa6> @ imm = #0x4
 8009034: 68fb         	ldr	r3, [r7, #0xc]
 8009036: 681b         	ldr	r3, [r3]
 8009038: e000         	b	0x800903c <spi_context_buffers_setup+0xa8> @ imm = #0x0
 800903a: 2300         	movs	r3, #0x0
 800903c: 697a         	ldr	r2, [r7, #0x14]
 800903e: 63d3         	str	r3, [r2, #0x3c]
; 	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
 8009040: 697b         	ldr	r3, [r7, #0x14]
 8009042: 6bdb         	ldr	r3, [r3, #0x3c]
 8009044: 2b00         	cmp	r3, #0x0
 8009046: d002         	beq	0x800904e <spi_context_buffers_setup+0xba> @ imm = #0x4
 8009048: 68fb         	ldr	r3, [r7, #0xc]
 800904a: 685b         	ldr	r3, [r3, #0x4]
 800904c: e000         	b	0x8009050 <spi_context_buffers_setup+0xbc> @ imm = #0x0
 800904e: 2300         	movs	r3, #0x0
 8009050: 697a         	ldr	r2, [r7, #0x14]
 8009052: 6413         	str	r3, [r2, #0x40]
; 		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
 8009054: 697b         	ldr	r3, [r7, #0x14]
 8009056: f103 003c    	add.w	r0, r3, #0x3c
 800905a: 697b         	ldr	r3, [r7, #0x14]
 800905c: f103 0140    	add.w	r1, r3, #0x40
 8009060: 697b         	ldr	r3, [r7, #0x14]
 8009062: f103 0250    	add.w	r2, r3, #0x50
 8009066: 7afb         	ldrb	r3, [r7, #0xb]
 8009068: f00e fe96    	bl	0x8017d98 <spi_context_get_next_buf> @ imm = #0xed2c
 800906c: 4602         	mov	r2, r0
; 	ctx->rx_buf = (uint8_t *)
 800906e: 697b         	ldr	r3, [r7, #0x14]
 8009070: 64da         	str	r2, [r3, #0x4c]
; 	ctx->sync_status = 0;
 8009072: 697b         	ldr	r3, [r7, #0x14]
 8009074: 2200         	movs	r2, #0x0
 8009076: 631a         	str	r2, [r3, #0x30]
; 	LOG_DBG("current_tx %p (%zu), current_rx %p (%zu),"
 8009078: 2303         	movs	r3, #0x3
 800907a: 2b03         	cmp	r3, #0x3
 800907c: d938         	bls	0x80090f0 <spi_context_buffers_setup+0x15c> @ imm = #0x70
 800907e: 2301         	movs	r3, #0x1
 8009080: f887 3022    	strb.w	r3, [r7, #0x22]
 8009084: f897 3022    	ldrb.w	r3, [r7, #0x22]
 8009088: f083 0301    	eor	r3, r3, #0x1
 800908c: b2db         	uxtb	r3, r3
 800908e: 2b00         	cmp	r3, #0x0
 8009090: d12e         	bne	0x80090f0 <spi_context_buffers_setup+0x15c> @ imm = #0x5c
 8009092: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80090f8 <spi_context_buffers_setup+0x164>
 8009094: 681b         	ldr	r3, [r3]
 8009096: 607b         	str	r3, [r7, #0x4]
 8009098: 697b         	ldr	r3, [r7, #0x14]
 800909a: 6b5b         	ldr	r3, [r3, #0x34]
 800909c: 697a         	ldr	r2, [r7, #0x14]
 800909e: 6b92         	ldr	r2, [r2, #0x38]
 80090a0: 6979         	ldr	r1, [r7, #0x14]
 80090a2: 6bc9         	ldr	r1, [r1, #0x3c]
 80090a4: 6978         	ldr	r0, [r7, #0x14]
 80090a6: 6c00         	ldr	r0, [r0, #0x40]
 80090a8: 697c         	ldr	r4, [r7, #0x14]
 80090aa: 6c64         	ldr	r4, [r4, #0x44]
 80090ac: 697d         	ldr	r5, [r7, #0x14]
 80090ae: 6cad         	ldr	r5, [r5, #0x48]
 80090b0: 697e         	ldr	r6, [r7, #0x14]
 80090b2: 6cf6         	ldr	r6, [r6, #0x4c]
 80090b4: f8d7 c014    	ldr.w	r12, [r7, #0x14]
 80090b8: f8dc c050    	ldr.w	r12, [r12, #0x50]
 80090bc: f8cd c02c    	str.w	r12, [sp, #0x2c]
 80090c0: 960a         	str	r6, [sp, #0x28]
 80090c2: 9509         	str	r5, [sp, #0x24]
 80090c4: 9408         	str	r4, [sp, #0x20]
 80090c6: 9007         	str	r0, [sp, #0x1c]
 80090c8: 9106         	str	r1, [sp, #0x18]
 80090ca: 9205         	str	r2, [sp, #0x14]
 80090cc: 9304         	str	r3, [sp, #0x10]
 80090ce: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80090fc <spi_context_buffers_setup+0x168>
 80090d0: 9303         	str	r3, [sp, #0xc]
 80090d2: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8009104 <spi_context_buffers_setup+0x170>
 80090d4: 9302         	str	r3, [sp, #0x8]
 80090d6: 2308         	movs	r3, #0x8
 80090d8: 9301         	str	r3, [sp, #0x4]
 80090da: 2300         	movs	r3, #0x0
 80090dc: 9300         	str	r3, [sp]
 80090de: 2300         	movs	r3, #0x0
 80090e0: 2204         	movs	r2, #0x4
 80090e2: 6879         	ldr	r1, [r7, #0x4]
 80090e4: 2000         	movs	r0, #0x0
 80090e6: f00e f9ec    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xe3d8
 80090ea: 2300         	movs	r3, #0x0
 80090ec: 61fb         	str	r3, [r7, #0x1c]
; }
 80090ee: bf00         	nop
 80090f0: bf00         	nop
 80090f2: 372c         	adds	r7, #0x2c
 80090f4: 46bd         	mov	sp, r7
 80090f6: bdf0         	pop	{r4, r5, r6, r7, pc}

080090f8 <$d>:
 80090f8: 7c 04 00 20  	.word	0x2000047c
 80090fc: a4 d7 01 08  	.word	0x0801d7a4
 8009100: 78 c6 01 08  	.word	0x0801c678
 8009104: 9c c6 01 08  	.word	0x0801c69c

08009108 <spi_stm32_send_next_frame>:
; {
 8009108: b580         	push	{r7, lr}
 800910a: b09c         	sub	sp, #0x70
 800910c: af06         	add	r7, sp, #0x18
 800910e: 6078         	str	r0, [r7, #0x4]
 8009110: 6039         	str	r1, [r7]
; 	const uint8_t frame_size = SPI_WORD_SIZE_GET(data->ctx.config->operation);
 8009112: 683b         	ldr	r3, [r7]
 8009114: 681b         	ldr	r3, [r3]
 8009116: 889b         	ldrh	r3, [r3, #0x4]
 8009118: 095b         	lsrs	r3, r3, #0x5
 800911a: b2db         	uxtb	r3, r3
 800911c: f003 033f    	and	r3, r3, #0x3f
 8009120: f887 3053    	strb.w	r3, [r7, #0x53]
; 	uint32_t tx_frame = SPI_STM32_TX_NOP;
 8009124: 2300         	movs	r3, #0x0
 8009126: 657b         	str	r3, [r7, #0x54]
; 	if (frame_size == 8) {
 8009128: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800912c: 2b08         	cmp	r3, #0x8
 800912e: f040 80a8    	bne.w	0x8009282 <spi_stm32_send_next_frame+0x17a> @ imm = #0x150
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 8009132: 683b         	ldr	r3, [r7]
 8009134: 647b         	str	r3, [r7, #0x44]
; 	return !!(ctx->tx_buf && ctx->tx_len);
 8009136: 6c7b         	ldr	r3, [r7, #0x44]
 8009138: 6c5b         	ldr	r3, [r3, #0x44]
 800913a: 2b00         	cmp	r3, #0x0
 800913c: d005         	beq	0x800914a <spi_stm32_send_next_frame+0x42> @ imm = #0xa
 800913e: 6c7b         	ldr	r3, [r7, #0x44]
 8009140: 6c9b         	ldr	r3, [r3, #0x48]
 8009142: 2b00         	cmp	r3, #0x0
 8009144: d001         	beq	0x800914a <spi_stm32_send_next_frame+0x42> @ imm = #0x2
 8009146: 2301         	movs	r3, #0x1
 8009148: e000         	b	0x800914c <spi_stm32_send_next_frame+0x44> @ imm = #0x0
 800914a: 2300         	movs	r3, #0x0
 800914c: f003 0301    	and	r3, r3, #0x1
 8009150: b2db         	uxtb	r3, r3
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 8009152: 2b00         	cmp	r3, #0x0
 8009154: d005         	beq	0x8009162 <spi_stm32_send_next_frame+0x5a> @ imm = #0xa
; 			tx_frame = UNALIGNED_GET((uint8_t *)(data->ctx.tx_buf));
 8009156: 683b         	ldr	r3, [r7]
 8009158: 6c5b         	ldr	r3, [r3, #0x44]
 800915a: 64bb         	str	r3, [r7, #0x48]
 800915c: 6cbb         	ldr	r3, [r7, #0x48]
 800915e: 781b         	ldrb	r3, [r3]
 8009160: 657b         	str	r3, [r7, #0x54]
; 		LL_SPI_TransmitData8(spi, tx_frame);
 8009162: 6d7b         	ldr	r3, [r7, #0x54]
 8009164: b2db         	uxtb	r3, r3
 8009166: 4619         	mov	r1, r3
 8009168: 6878         	ldr	r0, [r7, #0x4]
 800916a: f00e fba2    	bl	0x80178b2 <LL_SPI_TransmitData8> @ imm = #0xe744
; 		spi_context_update_tx(&data->ctx, 1, 1);
 800916e: 683b         	ldr	r3, [r7]
 8009170: 643b         	str	r3, [r7, #0x40]
 8009172: 2301         	movs	r3, #0x1
 8009174: f887 303f    	strb.w	r3, [r7, #0x3f]
 8009178: 2301         	movs	r3, #0x1
 800917a: 63bb         	str	r3, [r7, #0x38]
; 	if (!ctx->tx_len) {
 800917c: 6c3b         	ldr	r3, [r7, #0x40]
 800917e: 6c9b         	ldr	r3, [r3, #0x48]
 8009180: 2b00         	cmp	r3, #0x0
 8009182: f000 811d    	beq.w	0x80093c0 <spi_stm32_send_next_frame+0x2b8> @ imm = #0x23a
; 	if (len > ctx->tx_len) {
 8009186: 6c3b         	ldr	r3, [r7, #0x40]
 8009188: 6c9b         	ldr	r3, [r3, #0x48]
 800918a: 6bba         	ldr	r2, [r7, #0x38]
 800918c: 429a         	cmp	r2, r3
 800918e: d91d         	bls	0x80091cc <spi_stm32_send_next_frame+0xc4> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 8009190: 2303         	movs	r3, #0x3
 8009192: 2b00         	cmp	r3, #0x0
 8009194: d019         	beq	0x80091ca <spi_stm32_send_next_frame+0xc2> @ imm = #0x32
 8009196: 2301         	movs	r3, #0x1
 8009198: f887 3037    	strb.w	r3, [r7, #0x37]
 800919c: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80091a0: f083 0301    	eor	r3, r3, #0x1
 80091a4: b2db         	uxtb	r3, r3
 80091a6: 2b00         	cmp	r3, #0x0
 80091a8: d10f         	bne	0x80091ca <spi_stm32_send_next_frame+0xc2> @ imm = #0x1e
 80091aa: 4b89         	ldr	r3, [pc, #0x224]        @ 0x80093d0 <spi_stm32_send_next_frame+0x2c8>
 80091ac: 6819         	ldr	r1, [r3]
 80091ae: 4b89         	ldr	r3, [pc, #0x224]        @ 0x80093d4 <spi_stm32_send_next_frame+0x2cc>
 80091b0: 9302         	str	r3, [sp, #0x8]
 80091b2: 2300         	movs	r3, #0x0
 80091b4: 9301         	str	r3, [sp, #0x4]
 80091b6: 2300         	movs	r3, #0x0
 80091b8: 9300         	str	r3, [sp]
 80091ba: 2300         	movs	r3, #0x0
 80091bc: 2201         	movs	r2, #0x1
 80091be: 2000         	movs	r0, #0x0
 80091c0: f00e f97f    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xe2fe
 80091c4: 2300         	movs	r3, #0x0
 80091c6: 633b         	str	r3, [r7, #0x30]
; 		return;
 80091c8: e0fd         	b	0x80093c6 <spi_stm32_send_next_frame+0x2be> @ imm = #0x1fa
 80091ca: e0fc         	b	0x80093c6 <spi_stm32_send_next_frame+0x2be> @ imm = #0x1f8
; 	ctx->tx_len -= len;
 80091cc: 6c3b         	ldr	r3, [r7, #0x40]
 80091ce: 6c9a         	ldr	r2, [r3, #0x48]
 80091d0: 6bbb         	ldr	r3, [r7, #0x38]
 80091d2: 1ad2         	subs	r2, r2, r3
 80091d4: 6c3b         	ldr	r3, [r7, #0x40]
 80091d6: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 80091d8: 6c3b         	ldr	r3, [r7, #0x40]
 80091da: 6c9b         	ldr	r3, [r3, #0x48]
 80091dc: 2b00         	cmp	r3, #0x0
 80091de: d11b         	bne	0x8009218 <spi_stm32_send_next_frame+0x110> @ imm = #0x36
; 		++ctx->current_tx;
 80091e0: 6c3b         	ldr	r3, [r7, #0x40]
 80091e2: 6b5b         	ldr	r3, [r3, #0x34]
 80091e4: f103 0208    	add.w	r2, r3, #0x8
 80091e8: 6c3b         	ldr	r3, [r7, #0x40]
 80091ea: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 80091ec: 6c3b         	ldr	r3, [r7, #0x40]
 80091ee: 6b9b         	ldr	r3, [r3, #0x38]
 80091f0: 1e5a         	subs	r2, r3, #0x1
 80091f2: 6c3b         	ldr	r3, [r7, #0x40]
 80091f4: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 80091f6: 6c3b         	ldr	r3, [r7, #0x40]
 80091f8: f103 0034    	add.w	r0, r3, #0x34
 80091fc: 6c3b         	ldr	r3, [r7, #0x40]
 80091fe: f103 0138    	add.w	r1, r3, #0x38
 8009202: 6c3b         	ldr	r3, [r7, #0x40]
 8009204: f103 0248    	add.w	r2, r3, #0x48
 8009208: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800920c: f00e fdc4    	bl	0x8017d98 <spi_context_get_next_buf> @ imm = #0xeb88
 8009210: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 8009212: 6c3b         	ldr	r3, [r7, #0x40]
 8009214: 645a         	str	r2, [r3, #0x44]
 8009216: e00d         	b	0x8009234 <spi_stm32_send_next_frame+0x12c> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 8009218: 6c3b         	ldr	r3, [r7, #0x40]
 800921a: 6c5b         	ldr	r3, [r3, #0x44]
 800921c: 2b00         	cmp	r3, #0x0
 800921e: d009         	beq	0x8009234 <spi_stm32_send_next_frame+0x12c> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 8009220: 6c3b         	ldr	r3, [r7, #0x40]
 8009222: 6c5a         	ldr	r2, [r3, #0x44]
 8009224: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8009228: 6bb9         	ldr	r1, [r7, #0x38]
 800922a: fb01 f303    	mul	r3, r1, r3
 800922e: 441a         	add	r2, r3
 8009230: 6c3b         	ldr	r3, [r7, #0x40]
 8009232: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 8009234: 2303         	movs	r3, #0x3
 8009236: 2b03         	cmp	r3, #0x3
 8009238: f240 80c5    	bls.w	0x80093c6 <spi_stm32_send_next_frame+0x2be> @ imm = #0x18a
 800923c: 2301         	movs	r3, #0x1
 800923e: f887 302f    	strb.w	r3, [r7, #0x2f]
 8009242: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8009246: f083 0301    	eor	r3, r3, #0x1
 800924a: b2db         	uxtb	r3, r3
 800924c: 2b00         	cmp	r3, #0x0
 800924e: f040 80ba    	bne.w	0x80093c6 <spi_stm32_send_next_frame+0x2be> @ imm = #0x174
 8009252: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x80093d0 <spi_stm32_send_next_frame+0x2c8>
 8009254: 6819         	ldr	r1, [r3]
 8009256: 6c3b         	ldr	r3, [r7, #0x40]
 8009258: 6c5b         	ldr	r3, [r3, #0x44]
 800925a: 6c3a         	ldr	r2, [r7, #0x40]
 800925c: 6c92         	ldr	r2, [r2, #0x48]
 800925e: 9205         	str	r2, [sp, #0x14]
 8009260: 9304         	str	r3, [sp, #0x10]
 8009262: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x80093d8 <spi_stm32_send_next_frame+0x2d0>
 8009264: 9303         	str	r3, [sp, #0xc]
 8009266: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x80093dc <spi_stm32_send_next_frame+0x2d4>
 8009268: 9302         	str	r3, [sp, #0x8]
 800926a: 2308         	movs	r3, #0x8
 800926c: 9301         	str	r3, [sp, #0x4]
 800926e: 2300         	movs	r3, #0x0
 8009270: 9300         	str	r3, [sp]
 8009272: 2300         	movs	r3, #0x0
 8009274: 2204         	movs	r2, #0x4
 8009276: 2000         	movs	r0, #0x0
 8009278: f00e f923    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xe246
 800927c: 2300         	movs	r3, #0x0
 800927e: 62bb         	str	r3, [r7, #0x28]
; }
 8009280: e0a1         	b	0x80093c6 <spi_stm32_send_next_frame+0x2be> @ imm = #0x142
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 8009282: 683b         	ldr	r3, [r7]
 8009284: 627b         	str	r3, [r7, #0x24]
; 	return !!(ctx->tx_buf && ctx->tx_len);
 8009286: 6a7b         	ldr	r3, [r7, #0x24]
 8009288: 6c5b         	ldr	r3, [r3, #0x44]
 800928a: 2b00         	cmp	r3, #0x0
 800928c: d005         	beq	0x800929a <spi_stm32_send_next_frame+0x192> @ imm = #0xa
 800928e: 6a7b         	ldr	r3, [r7, #0x24]
 8009290: 6c9b         	ldr	r3, [r3, #0x48]
 8009292: 2b00         	cmp	r3, #0x0
 8009294: d001         	beq	0x800929a <spi_stm32_send_next_frame+0x192> @ imm = #0x2
 8009296: 2301         	movs	r3, #0x1
 8009298: e000         	b	0x800929c <spi_stm32_send_next_frame+0x194> @ imm = #0x0
 800929a: 2300         	movs	r3, #0x0
 800929c: f003 0301    	and	r3, r3, #0x1
 80092a0: b2db         	uxtb	r3, r3
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 80092a2: 2b00         	cmp	r3, #0x0
 80092a4: d006         	beq	0x80092b4 <spi_stm32_send_next_frame+0x1ac> @ imm = #0xc
; 			tx_frame = UNALIGNED_GET((uint16_t *)(data->ctx.tx_buf));
 80092a6: 683b         	ldr	r3, [r7]
 80092a8: 6c5b         	ldr	r3, [r3, #0x44]
 80092aa: 64fb         	str	r3, [r7, #0x4c]
 80092ac: 6cfb         	ldr	r3, [r7, #0x4c]
 80092ae: 881b         	ldrh	r3, [r3]
 80092b0: b29b         	uxth	r3, r3
 80092b2: 657b         	str	r3, [r7, #0x54]
; 		LL_SPI_TransmitData16(spi, tx_frame);
 80092b4: 6d7b         	ldr	r3, [r7, #0x54]
 80092b6: b29b         	uxth	r3, r3
 80092b8: 4619         	mov	r1, r3
 80092ba: 6878         	ldr	r0, [r7, #0x4]
 80092bc: f00e fb0a    	bl	0x80178d4 <LL_SPI_TransmitData16> @ imm = #0xe614
; 		spi_context_update_tx(&data->ctx, 2, 1);
 80092c0: 683b         	ldr	r3, [r7]
 80092c2: 623b         	str	r3, [r7, #0x20]
 80092c4: 2302         	movs	r3, #0x2
 80092c6: 77fb         	strb	r3, [r7, #0x1f]
 80092c8: 2301         	movs	r3, #0x1
 80092ca: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->tx_len) {
 80092cc: 6a3b         	ldr	r3, [r7, #0x20]
 80092ce: 6c9b         	ldr	r3, [r3, #0x48]
 80092d0: 2b00         	cmp	r3, #0x0
 80092d2: d077         	beq	0x80093c4 <spi_stm32_send_next_frame+0x2bc> @ imm = #0xee
; 	if (len > ctx->tx_len) {
 80092d4: 6a3b         	ldr	r3, [r7, #0x20]
 80092d6: 6c9b         	ldr	r3, [r3, #0x48]
 80092d8: 69ba         	ldr	r2, [r7, #0x18]
 80092da: 429a         	cmp	r2, r3
 80092dc: d91b         	bls	0x8009316 <spi_stm32_send_next_frame+0x20e> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 80092de: 2303         	movs	r3, #0x3
 80092e0: 2b00         	cmp	r3, #0x0
 80092e2: d017         	beq	0x8009314 <spi_stm32_send_next_frame+0x20c> @ imm = #0x2e
 80092e4: 2301         	movs	r3, #0x1
 80092e6: 75fb         	strb	r3, [r7, #0x17]
 80092e8: 7dfb         	ldrb	r3, [r7, #0x17]
 80092ea: f083 0301    	eor	r3, r3, #0x1
 80092ee: b2db         	uxtb	r3, r3
 80092f0: 2b00         	cmp	r3, #0x0
 80092f2: d10f         	bne	0x8009314 <spi_stm32_send_next_frame+0x20c> @ imm = #0x1e
 80092f4: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80093d0 <spi_stm32_send_next_frame+0x2c8>
 80092f6: 6819         	ldr	r1, [r3]
 80092f8: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80093d4 <spi_stm32_send_next_frame+0x2cc>
 80092fa: 9302         	str	r3, [sp, #0x8]
 80092fc: 2300         	movs	r3, #0x0
 80092fe: 9301         	str	r3, [sp, #0x4]
 8009300: 2300         	movs	r3, #0x0
 8009302: 9300         	str	r3, [sp]
 8009304: 2300         	movs	r3, #0x0
 8009306: 2201         	movs	r2, #0x1
 8009308: 2000         	movs	r0, #0x0
 800930a: f00e f8da    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xe1b4
 800930e: 2300         	movs	r3, #0x0
 8009310: 613b         	str	r3, [r7, #0x10]
; 		return;
 8009312: e058         	b	0x80093c6 <spi_stm32_send_next_frame+0x2be> @ imm = #0xb0
 8009314: e057         	b	0x80093c6 <spi_stm32_send_next_frame+0x2be> @ imm = #0xae
; 	ctx->tx_len -= len;
 8009316: 6a3b         	ldr	r3, [r7, #0x20]
 8009318: 6c9a         	ldr	r2, [r3, #0x48]
 800931a: 69bb         	ldr	r3, [r7, #0x18]
 800931c: 1ad2         	subs	r2, r2, r3
 800931e: 6a3b         	ldr	r3, [r7, #0x20]
 8009320: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 8009322: 6a3b         	ldr	r3, [r7, #0x20]
 8009324: 6c9b         	ldr	r3, [r3, #0x48]
 8009326: 2b00         	cmp	r3, #0x0
 8009328: d11a         	bne	0x8009360 <spi_stm32_send_next_frame+0x258> @ imm = #0x34
; 		++ctx->current_tx;
 800932a: 6a3b         	ldr	r3, [r7, #0x20]
 800932c: 6b5b         	ldr	r3, [r3, #0x34]
 800932e: f103 0208    	add.w	r2, r3, #0x8
 8009332: 6a3b         	ldr	r3, [r7, #0x20]
 8009334: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 8009336: 6a3b         	ldr	r3, [r7, #0x20]
 8009338: 6b9b         	ldr	r3, [r3, #0x38]
 800933a: 1e5a         	subs	r2, r3, #0x1
 800933c: 6a3b         	ldr	r3, [r7, #0x20]
 800933e: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 8009340: 6a3b         	ldr	r3, [r7, #0x20]
 8009342: f103 0034    	add.w	r0, r3, #0x34
 8009346: 6a3b         	ldr	r3, [r7, #0x20]
 8009348: f103 0138    	add.w	r1, r3, #0x38
 800934c: 6a3b         	ldr	r3, [r7, #0x20]
 800934e: f103 0248    	add.w	r2, r3, #0x48
 8009352: 7ffb         	ldrb	r3, [r7, #0x1f]
 8009354: f00e fd20    	bl	0x8017d98 <spi_context_get_next_buf> @ imm = #0xea40
 8009358: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800935a: 6a3b         	ldr	r3, [r7, #0x20]
 800935c: 645a         	str	r2, [r3, #0x44]
 800935e: e00c         	b	0x800937a <spi_stm32_send_next_frame+0x272> @ imm = #0x18
; 	} else if (ctx->tx_buf) {
 8009360: 6a3b         	ldr	r3, [r7, #0x20]
 8009362: 6c5b         	ldr	r3, [r3, #0x44]
 8009364: 2b00         	cmp	r3, #0x0
 8009366: d008         	beq	0x800937a <spi_stm32_send_next_frame+0x272> @ imm = #0x10
; 		ctx->tx_buf += dfs * len;
 8009368: 6a3b         	ldr	r3, [r7, #0x20]
 800936a: 6c5a         	ldr	r2, [r3, #0x44]
 800936c: 7ffb         	ldrb	r3, [r7, #0x1f]
 800936e: 69b9         	ldr	r1, [r7, #0x18]
 8009370: fb01 f303    	mul	r3, r1, r3
 8009374: 441a         	add	r2, r3
 8009376: 6a3b         	ldr	r3, [r7, #0x20]
 8009378: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800937a: 2303         	movs	r3, #0x3
 800937c: 2b03         	cmp	r3, #0x3
 800937e: d922         	bls	0x80093c6 <spi_stm32_send_next_frame+0x2be> @ imm = #0x44
 8009380: 2301         	movs	r3, #0x1
 8009382: 73fb         	strb	r3, [r7, #0xf]
 8009384: 7bfb         	ldrb	r3, [r7, #0xf]
 8009386: f083 0301    	eor	r3, r3, #0x1
 800938a: b2db         	uxtb	r3, r3
 800938c: 2b00         	cmp	r3, #0x0
 800938e: d11a         	bne	0x80093c6 <spi_stm32_send_next_frame+0x2be> @ imm = #0x34
 8009390: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80093d0 <spi_stm32_send_next_frame+0x2c8>
 8009392: 6819         	ldr	r1, [r3]
 8009394: 6a3b         	ldr	r3, [r7, #0x20]
 8009396: 6c5b         	ldr	r3, [r3, #0x44]
 8009398: 6a3a         	ldr	r2, [r7, #0x20]
 800939a: 6c92         	ldr	r2, [r2, #0x48]
 800939c: 9205         	str	r2, [sp, #0x14]
 800939e: 9304         	str	r3, [sp, #0x10]
 80093a0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80093d8 <spi_stm32_send_next_frame+0x2d0>
 80093a2: 9303         	str	r3, [sp, #0xc]
 80093a4: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80093dc <spi_stm32_send_next_frame+0x2d4>
 80093a6: 9302         	str	r3, [sp, #0x8]
 80093a8: 2308         	movs	r3, #0x8
 80093aa: 9301         	str	r3, [sp, #0x4]
 80093ac: 2300         	movs	r3, #0x0
 80093ae: 9300         	str	r3, [sp]
 80093b0: 2300         	movs	r3, #0x0
 80093b2: 2204         	movs	r2, #0x4
 80093b4: 2000         	movs	r0, #0x0
 80093b6: f00e f884    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xe108
 80093ba: 2300         	movs	r3, #0x0
 80093bc: 60bb         	str	r3, [r7, #0x8]
; }
 80093be: e002         	b	0x80093c6 <spi_stm32_send_next_frame+0x2be> @ imm = #0x4
; 		return;
 80093c0: bf00         	nop
 80093c2: e000         	b	0x80093c6 <spi_stm32_send_next_frame+0x2be> @ imm = #0x0
 80093c4: bf00         	nop
; }
 80093c6: bf00         	nop
 80093c8: 3758         	adds	r7, #0x58
 80093ca: 46bd         	mov	sp, r7
 80093cc: bd80         	pop	{r7, pc}
 80093ce: bf00         	nop

080093d0 <$d>:
 80093d0: 7c 04 00 20  	.word	0x2000047c
 80093d4: f0 c6 01 08  	.word	0x0801c6f0
 80093d8: 4c d7 01 08  	.word	0x0801d74c
 80093dc: 10 c7 01 08  	.word	0x0801c710

080093e0 <spi_stm32_read_next_frame>:
; {
 80093e0: b580         	push	{r7, lr}
 80093e2: b09c         	sub	sp, #0x70
 80093e4: af06         	add	r7, sp, #0x18
 80093e6: 6078         	str	r0, [r7, #0x4]
 80093e8: 6039         	str	r1, [r7]
; 	const uint8_t frame_size = SPI_WORD_SIZE_GET(data->ctx.config->operation);
 80093ea: 683b         	ldr	r3, [r7]
 80093ec: 681b         	ldr	r3, [r3]
 80093ee: 889b         	ldrh	r3, [r3, #0x4]
 80093f0: 095b         	lsrs	r3, r3, #0x5
 80093f2: b2db         	uxtb	r3, r3
 80093f4: f003 033f    	and	r3, r3, #0x3f
 80093f8: f887 3057    	strb.w	r3, [r7, #0x57]
; 	uint32_t rx_frame = 0;
 80093fc: 2300         	movs	r3, #0x0
 80093fe: 653b         	str	r3, [r7, #0x50]
; 	if (frame_size == 8) {
 8009400: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8009404: 2b08         	cmp	r3, #0x8
 8009406: f040 80a8    	bne.w	0x800955a <spi_stm32_read_next_frame+0x17a> @ imm = #0x150
; 		rx_frame = LL_SPI_ReceiveData8(spi);
 800940a: 6878         	ldr	r0, [r7, #0x4]
 800940c: f00e fa38    	bl	0x8017880 <LL_SPI_ReceiveData8> @ imm = #0xe470
 8009410: 4603         	mov	r3, r0
 8009412: 653b         	str	r3, [r7, #0x50]
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 8009414: 683b         	ldr	r3, [r7]
 8009416: 647b         	str	r3, [r7, #0x44]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 8009418: 6c7b         	ldr	r3, [r7, #0x44]
 800941a: 6cdb         	ldr	r3, [r3, #0x4c]
 800941c: 2b00         	cmp	r3, #0x0
 800941e: d005         	beq	0x800942c <spi_stm32_read_next_frame+0x4c> @ imm = #0xa
 8009420: 6c7b         	ldr	r3, [r7, #0x44]
 8009422: 6d1b         	ldr	r3, [r3, #0x50]
 8009424: 2b00         	cmp	r3, #0x0
 8009426: d001         	beq	0x800942c <spi_stm32_read_next_frame+0x4c> @ imm = #0x2
 8009428: 2301         	movs	r3, #0x1
 800942a: e000         	b	0x800942e <spi_stm32_read_next_frame+0x4e> @ imm = #0x0
 800942c: 2300         	movs	r3, #0x0
 800942e: f003 0301    	and	r3, r3, #0x1
 8009432: b2db         	uxtb	r3, r3
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 8009434: 2b00         	cmp	r3, #0x0
 8009436: d006         	beq	0x8009446 <spi_stm32_read_next_frame+0x66> @ imm = #0xc
; 			UNALIGNED_PUT(rx_frame, (uint8_t *)data->ctx.rx_buf);
 8009438: 683b         	ldr	r3, [r7]
 800943a: 6cdb         	ldr	r3, [r3, #0x4c]
 800943c: 64bb         	str	r3, [r7, #0x48]
 800943e: 6d3b         	ldr	r3, [r7, #0x50]
 8009440: b2da         	uxtb	r2, r3
 8009442: 6cbb         	ldr	r3, [r7, #0x48]
 8009444: 701a         	strb	r2, [r3]
; 		spi_context_update_rx(&data->ctx, 1, 1);
 8009446: 683b         	ldr	r3, [r7]
 8009448: 643b         	str	r3, [r7, #0x40]
 800944a: 2301         	movs	r3, #0x1
 800944c: f887 303f    	strb.w	r3, [r7, #0x3f]
 8009450: 2301         	movs	r3, #0x1
 8009452: 63bb         	str	r3, [r7, #0x38]
; 	if (!ctx->rx_len) {
 8009454: 6c3b         	ldr	r3, [r7, #0x40]
 8009456: 6d1b         	ldr	r3, [r3, #0x50]
 8009458: 2b00         	cmp	r3, #0x0
 800945a: f000 811c    	beq.w	0x8009696 <spi_stm32_read_next_frame+0x2b6> @ imm = #0x238
; 	if (len > ctx->rx_len) {
 800945e: 6c3b         	ldr	r3, [r7, #0x40]
 8009460: 6d1b         	ldr	r3, [r3, #0x50]
 8009462: 6bba         	ldr	r2, [r7, #0x38]
 8009464: 429a         	cmp	r2, r3
 8009466: d91d         	bls	0x80094a4 <spi_stm32_read_next_frame+0xc4> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 8009468: 2303         	movs	r3, #0x3
 800946a: 2b00         	cmp	r3, #0x0
 800946c: d019         	beq	0x80094a2 <spi_stm32_read_next_frame+0xc2> @ imm = #0x32
 800946e: 2301         	movs	r3, #0x1
 8009470: f887 3037    	strb.w	r3, [r7, #0x37]
 8009474: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8009478: f083 0301    	eor	r3, r3, #0x1
 800947c: b2db         	uxtb	r3, r3
 800947e: 2b00         	cmp	r3, #0x0
 8009480: d10f         	bne	0x80094a2 <spi_stm32_read_next_frame+0xc2> @ imm = #0x1e
 8009482: 4b88         	ldr	r3, [pc, #0x220]        @ 0x80096a4 <spi_stm32_read_next_frame+0x2c4>
 8009484: 6819         	ldr	r1, [r3]
 8009486: 4b88         	ldr	r3, [pc, #0x220]        @ 0x80096a8 <spi_stm32_read_next_frame+0x2c8>
 8009488: 9302         	str	r3, [sp, #0x8]
 800948a: 2300         	movs	r3, #0x0
 800948c: 9301         	str	r3, [sp, #0x4]
 800948e: 2300         	movs	r3, #0x0
 8009490: 9300         	str	r3, [sp]
 8009492: 2300         	movs	r3, #0x0
 8009494: 2201         	movs	r2, #0x1
 8009496: 2000         	movs	r0, #0x0
 8009498: f00e f813    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xe026
 800949c: 2300         	movs	r3, #0x0
 800949e: 633b         	str	r3, [r7, #0x30]
; 		return;
 80094a0: e0fc         	b	0x800969c <spi_stm32_read_next_frame+0x2bc> @ imm = #0x1f8
 80094a2: e0fb         	b	0x800969c <spi_stm32_read_next_frame+0x2bc> @ imm = #0x1f6
; 	ctx->rx_len -= len;
 80094a4: 6c3b         	ldr	r3, [r7, #0x40]
 80094a6: 6d1a         	ldr	r2, [r3, #0x50]
 80094a8: 6bbb         	ldr	r3, [r7, #0x38]
 80094aa: 1ad2         	subs	r2, r2, r3
 80094ac: 6c3b         	ldr	r3, [r7, #0x40]
 80094ae: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 80094b0: 6c3b         	ldr	r3, [r7, #0x40]
 80094b2: 6d1b         	ldr	r3, [r3, #0x50]
 80094b4: 2b00         	cmp	r3, #0x0
 80094b6: d11b         	bne	0x80094f0 <spi_stm32_read_next_frame+0x110> @ imm = #0x36
; 		++ctx->current_rx;
 80094b8: 6c3b         	ldr	r3, [r7, #0x40]
 80094ba: 6bdb         	ldr	r3, [r3, #0x3c]
 80094bc: f103 0208    	add.w	r2, r3, #0x8
 80094c0: 6c3b         	ldr	r3, [r7, #0x40]
 80094c2: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 80094c4: 6c3b         	ldr	r3, [r7, #0x40]
 80094c6: 6c1b         	ldr	r3, [r3, #0x40]
 80094c8: 1e5a         	subs	r2, r3, #0x1
 80094ca: 6c3b         	ldr	r3, [r7, #0x40]
 80094cc: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 80094ce: 6c3b         	ldr	r3, [r7, #0x40]
 80094d0: f103 003c    	add.w	r0, r3, #0x3c
 80094d4: 6c3b         	ldr	r3, [r7, #0x40]
 80094d6: f103 0140    	add.w	r1, r3, #0x40
 80094da: 6c3b         	ldr	r3, [r7, #0x40]
 80094dc: f103 0250    	add.w	r2, r3, #0x50
 80094e0: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 80094e4: f00e fc58    	bl	0x8017d98 <spi_context_get_next_buf> @ imm = #0xe8b0
 80094e8: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 80094ea: 6c3b         	ldr	r3, [r7, #0x40]
 80094ec: 64da         	str	r2, [r3, #0x4c]
 80094ee: e00d         	b	0x800950c <spi_stm32_read_next_frame+0x12c> @ imm = #0x1a
; 	} else if (ctx->rx_buf) {
 80094f0: 6c3b         	ldr	r3, [r7, #0x40]
 80094f2: 6cdb         	ldr	r3, [r3, #0x4c]
 80094f4: 2b00         	cmp	r3, #0x0
 80094f6: d009         	beq	0x800950c <spi_stm32_read_next_frame+0x12c> @ imm = #0x12
; 		ctx->rx_buf += dfs * len;
 80094f8: 6c3b         	ldr	r3, [r7, #0x40]
 80094fa: 6cda         	ldr	r2, [r3, #0x4c]
 80094fc: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8009500: 6bb9         	ldr	r1, [r7, #0x38]
 8009502: fb01 f303    	mul	r3, r1, r3
 8009506: 441a         	add	r2, r3
 8009508: 6c3b         	ldr	r3, [r7, #0x40]
 800950a: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800950c: 2303         	movs	r3, #0x3
 800950e: 2b03         	cmp	r3, #0x3
 8009510: f240 80c4    	bls.w	0x800969c <spi_stm32_read_next_frame+0x2bc> @ imm = #0x188
 8009514: 2301         	movs	r3, #0x1
 8009516: f887 302f    	strb.w	r3, [r7, #0x2f]
 800951a: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800951e: f083 0301    	eor	r3, r3, #0x1
 8009522: b2db         	uxtb	r3, r3
 8009524: 2b00         	cmp	r3, #0x0
 8009526: f040 80b9    	bne.w	0x800969c <spi_stm32_read_next_frame+0x2bc> @ imm = #0x172
 800952a: 4b5e         	ldr	r3, [pc, #0x178]        @ 0x80096a4 <spi_stm32_read_next_frame+0x2c4>
 800952c: 6819         	ldr	r1, [r3]
 800952e: 6c3b         	ldr	r3, [r7, #0x40]
 8009530: 6cdb         	ldr	r3, [r3, #0x4c]
 8009532: 6c3a         	ldr	r2, [r7, #0x40]
 8009534: 6d12         	ldr	r2, [r2, #0x50]
 8009536: 9205         	str	r2, [sp, #0x14]
 8009538: 9304         	str	r3, [sp, #0x10]
 800953a: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x80096ac <spi_stm32_read_next_frame+0x2cc>
 800953c: 9303         	str	r3, [sp, #0xc]
 800953e: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x80096b0 <spi_stm32_read_next_frame+0x2d0>
 8009540: 9302         	str	r3, [sp, #0x8]
 8009542: 2308         	movs	r3, #0x8
 8009544: 9301         	str	r3, [sp, #0x4]
 8009546: 2300         	movs	r3, #0x0
 8009548: 9300         	str	r3, [sp]
 800954a: 2300         	movs	r3, #0x0
 800954c: 2204         	movs	r2, #0x4
 800954e: 2000         	movs	r0, #0x0
 8009550: f00d ffb7    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xdf6e
 8009554: 2300         	movs	r3, #0x0
 8009556: 62bb         	str	r3, [r7, #0x28]
; }
 8009558: e0a0         	b	0x800969c <spi_stm32_read_next_frame+0x2bc> @ imm = #0x140
; 		rx_frame = LL_SPI_ReceiveData16(spi);
 800955a: 6878         	ldr	r0, [r7, #0x4]
 800955c: f00e f99d    	bl	0x801789a <LL_SPI_ReceiveData16> @ imm = #0xe33a
 8009560: 4603         	mov	r3, r0
 8009562: 653b         	str	r3, [r7, #0x50]
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 8009564: 683b         	ldr	r3, [r7]
 8009566: 627b         	str	r3, [r7, #0x24]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 8009568: 6a7b         	ldr	r3, [r7, #0x24]
 800956a: 6cdb         	ldr	r3, [r3, #0x4c]
 800956c: 2b00         	cmp	r3, #0x0
 800956e: d005         	beq	0x800957c <spi_stm32_read_next_frame+0x19c> @ imm = #0xa
 8009570: 6a7b         	ldr	r3, [r7, #0x24]
 8009572: 6d1b         	ldr	r3, [r3, #0x50]
 8009574: 2b00         	cmp	r3, #0x0
 8009576: d001         	beq	0x800957c <spi_stm32_read_next_frame+0x19c> @ imm = #0x2
 8009578: 2301         	movs	r3, #0x1
 800957a: e000         	b	0x800957e <spi_stm32_read_next_frame+0x19e> @ imm = #0x0
 800957c: 2300         	movs	r3, #0x0
 800957e: f003 0301    	and	r3, r3, #0x1
 8009582: b2db         	uxtb	r3, r3
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 8009584: 2b00         	cmp	r3, #0x0
 8009586: d006         	beq	0x8009596 <spi_stm32_read_next_frame+0x1b6> @ imm = #0xc
; 			UNALIGNED_PUT(rx_frame, (uint16_t *)data->ctx.rx_buf);
 8009588: 683b         	ldr	r3, [r7]
 800958a: 6cdb         	ldr	r3, [r3, #0x4c]
 800958c: 64fb         	str	r3, [r7, #0x4c]
 800958e: 6d3b         	ldr	r3, [r7, #0x50]
 8009590: b29a         	uxth	r2, r3
 8009592: 6cfb         	ldr	r3, [r7, #0x4c]
 8009594: 801a         	strh	r2, [r3]
; 		spi_context_update_rx(&data->ctx, 2, 1);
 8009596: 683b         	ldr	r3, [r7]
 8009598: 623b         	str	r3, [r7, #0x20]
 800959a: 2302         	movs	r3, #0x2
 800959c: 77fb         	strb	r3, [r7, #0x1f]
 800959e: 2301         	movs	r3, #0x1
 80095a0: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->rx_len) {
 80095a2: 6a3b         	ldr	r3, [r7, #0x20]
 80095a4: 6d1b         	ldr	r3, [r3, #0x50]
 80095a6: 2b00         	cmp	r3, #0x0
 80095a8: d077         	beq	0x800969a <spi_stm32_read_next_frame+0x2ba> @ imm = #0xee
; 	if (len > ctx->rx_len) {
 80095aa: 6a3b         	ldr	r3, [r7, #0x20]
 80095ac: 6d1b         	ldr	r3, [r3, #0x50]
 80095ae: 69ba         	ldr	r2, [r7, #0x18]
 80095b0: 429a         	cmp	r2, r3
 80095b2: d91b         	bls	0x80095ec <spi_stm32_read_next_frame+0x20c> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 80095b4: 2303         	movs	r3, #0x3
 80095b6: 2b00         	cmp	r3, #0x0
 80095b8: d017         	beq	0x80095ea <spi_stm32_read_next_frame+0x20a> @ imm = #0x2e
 80095ba: 2301         	movs	r3, #0x1
 80095bc: 75fb         	strb	r3, [r7, #0x17]
 80095be: 7dfb         	ldrb	r3, [r7, #0x17]
 80095c0: f083 0301    	eor	r3, r3, #0x1
 80095c4: b2db         	uxtb	r3, r3
 80095c6: 2b00         	cmp	r3, #0x0
 80095c8: d10f         	bne	0x80095ea <spi_stm32_read_next_frame+0x20a> @ imm = #0x1e
 80095ca: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80096a4 <spi_stm32_read_next_frame+0x2c4>
 80095cc: 6819         	ldr	r1, [r3]
 80095ce: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80096a8 <spi_stm32_read_next_frame+0x2c8>
 80095d0: 9302         	str	r3, [sp, #0x8]
 80095d2: 2300         	movs	r3, #0x0
 80095d4: 9301         	str	r3, [sp, #0x4]
 80095d6: 2300         	movs	r3, #0x0
 80095d8: 9300         	str	r3, [sp]
 80095da: 2300         	movs	r3, #0x0
 80095dc: 2201         	movs	r2, #0x1
 80095de: 2000         	movs	r0, #0x0
 80095e0: f00d ff6f    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xdede
 80095e4: 2300         	movs	r3, #0x0
 80095e6: 613b         	str	r3, [r7, #0x10]
; 		return;
 80095e8: e058         	b	0x800969c <spi_stm32_read_next_frame+0x2bc> @ imm = #0xb0
 80095ea: e057         	b	0x800969c <spi_stm32_read_next_frame+0x2bc> @ imm = #0xae
; 	ctx->rx_len -= len;
 80095ec: 6a3b         	ldr	r3, [r7, #0x20]
 80095ee: 6d1a         	ldr	r2, [r3, #0x50]
 80095f0: 69bb         	ldr	r3, [r7, #0x18]
 80095f2: 1ad2         	subs	r2, r2, r3
 80095f4: 6a3b         	ldr	r3, [r7, #0x20]
 80095f6: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 80095f8: 6a3b         	ldr	r3, [r7, #0x20]
 80095fa: 6d1b         	ldr	r3, [r3, #0x50]
 80095fc: 2b00         	cmp	r3, #0x0
 80095fe: d11a         	bne	0x8009636 <spi_stm32_read_next_frame+0x256> @ imm = #0x34
; 		++ctx->current_rx;
 8009600: 6a3b         	ldr	r3, [r7, #0x20]
 8009602: 6bdb         	ldr	r3, [r3, #0x3c]
 8009604: f103 0208    	add.w	r2, r3, #0x8
 8009608: 6a3b         	ldr	r3, [r7, #0x20]
 800960a: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800960c: 6a3b         	ldr	r3, [r7, #0x20]
 800960e: 6c1b         	ldr	r3, [r3, #0x40]
 8009610: 1e5a         	subs	r2, r3, #0x1
 8009612: 6a3b         	ldr	r3, [r7, #0x20]
 8009614: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 8009616: 6a3b         	ldr	r3, [r7, #0x20]
 8009618: f103 003c    	add.w	r0, r3, #0x3c
 800961c: 6a3b         	ldr	r3, [r7, #0x20]
 800961e: f103 0140    	add.w	r1, r3, #0x40
 8009622: 6a3b         	ldr	r3, [r7, #0x20]
 8009624: f103 0250    	add.w	r2, r3, #0x50
 8009628: 7ffb         	ldrb	r3, [r7, #0x1f]
 800962a: f00e fbb5    	bl	0x8017d98 <spi_context_get_next_buf> @ imm = #0xe76a
 800962e: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 8009630: 6a3b         	ldr	r3, [r7, #0x20]
 8009632: 64da         	str	r2, [r3, #0x4c]
 8009634: e00c         	b	0x8009650 <spi_stm32_read_next_frame+0x270> @ imm = #0x18
; 	} else if (ctx->rx_buf) {
 8009636: 6a3b         	ldr	r3, [r7, #0x20]
 8009638: 6cdb         	ldr	r3, [r3, #0x4c]
 800963a: 2b00         	cmp	r3, #0x0
 800963c: d008         	beq	0x8009650 <spi_stm32_read_next_frame+0x270> @ imm = #0x10
; 		ctx->rx_buf += dfs * len;
 800963e: 6a3b         	ldr	r3, [r7, #0x20]
 8009640: 6cda         	ldr	r2, [r3, #0x4c]
 8009642: 7ffb         	ldrb	r3, [r7, #0x1f]
 8009644: 69b9         	ldr	r1, [r7, #0x18]
 8009646: fb01 f303    	mul	r3, r1, r3
 800964a: 441a         	add	r2, r3
 800964c: 6a3b         	ldr	r3, [r7, #0x20]
 800964e: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 8009650: 2303         	movs	r3, #0x3
 8009652: 2b03         	cmp	r3, #0x3
 8009654: d922         	bls	0x800969c <spi_stm32_read_next_frame+0x2bc> @ imm = #0x44
 8009656: 2301         	movs	r3, #0x1
 8009658: 73fb         	strb	r3, [r7, #0xf]
 800965a: 7bfb         	ldrb	r3, [r7, #0xf]
 800965c: f083 0301    	eor	r3, r3, #0x1
 8009660: b2db         	uxtb	r3, r3
 8009662: 2b00         	cmp	r3, #0x0
 8009664: d11a         	bne	0x800969c <spi_stm32_read_next_frame+0x2bc> @ imm = #0x34
 8009666: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80096a4 <spi_stm32_read_next_frame+0x2c4>
 8009668: 6819         	ldr	r1, [r3]
 800966a: 6a3b         	ldr	r3, [r7, #0x20]
 800966c: 6cdb         	ldr	r3, [r3, #0x4c]
 800966e: 6a3a         	ldr	r2, [r7, #0x20]
 8009670: 6d12         	ldr	r2, [r2, #0x50]
 8009672: 9205         	str	r2, [sp, #0x14]
 8009674: 9304         	str	r3, [sp, #0x10]
 8009676: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80096ac <spi_stm32_read_next_frame+0x2cc>
 8009678: 9303         	str	r3, [sp, #0xc]
 800967a: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80096b0 <spi_stm32_read_next_frame+0x2d0>
 800967c: 9302         	str	r3, [sp, #0x8]
 800967e: 2308         	movs	r3, #0x8
 8009680: 9301         	str	r3, [sp, #0x4]
 8009682: 2300         	movs	r3, #0x0
 8009684: 9300         	str	r3, [sp]
 8009686: 2300         	movs	r3, #0x0
 8009688: 2204         	movs	r2, #0x4
 800968a: 2000         	movs	r0, #0x0
 800968c: f00d ff19    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xde32
 8009690: 2300         	movs	r3, #0x0
 8009692: 60bb         	str	r3, [r7, #0x8]
; }
 8009694: e002         	b	0x800969c <spi_stm32_read_next_frame+0x2bc> @ imm = #0x4
; 		return;
 8009696: bf00         	nop
 8009698: e000         	b	0x800969c <spi_stm32_read_next_frame+0x2bc> @ imm = #0x0
 800969a: bf00         	nop
; }
 800969c: bf00         	nop
 800969e: 3758         	adds	r7, #0x58
 80096a0: 46bd         	mov	sp, r7
 80096a2: bd80         	pop	{r7, pc}

080096a4 <$d>:
 80096a4: 7c 04 00 20  	.word	0x2000047c
 80096a8: f0 c6 01 08  	.word	0x0801c6f0
 80096ac: 64 d7 01 08  	.word	0x0801d764
 80096b0: 28 c7 01 08  	.word	0x0801c728

080096b4 <spi_stm32_get_err>:
; {
 80096b4: b580         	push	{r7, lr}
 80096b6: b08c         	sub	sp, #0x30
 80096b8: af06         	add	r7, sp, #0x18
 80096ba: 6078         	str	r0, [r7, #0x4]
; 	uint32_t sr = LL_SPI_ReadReg(spi, SR);
 80096bc: 687b         	ldr	r3, [r7, #0x4]
 80096be: 689b         	ldr	r3, [r3, #0x8]
 80096c0: 617b         	str	r3, [r7, #0x14]
; 	if (sr & SPI_STM32_ERR_MSK) {
 80096c2: 697b         	ldr	r3, [r7, #0x14]
 80096c4: f403 73b8    	and	r3, r3, #0x170
 80096c8: 2b00         	cmp	r3, #0x0
 80096ca: d02b         	beq	0x8009724 <spi_stm32_get_err+0x70> @ imm = #0x56
; 		LOG_ERR("%s: err=%d", __func__,
 80096cc: 2303         	movs	r3, #0x3
 80096ce: 2b00         	cmp	r3, #0x0
 80096d0: d01c         	beq	0x800970c <spi_stm32_get_err+0x58> @ imm = #0x38
 80096d2: 2301         	movs	r3, #0x1
 80096d4: 74fb         	strb	r3, [r7, #0x13]
 80096d6: 7cfb         	ldrb	r3, [r7, #0x13]
 80096d8: f083 0301    	eor	r3, r3, #0x1
 80096dc: b2db         	uxtb	r3, r3
 80096de: 2b00         	cmp	r3, #0x0
 80096e0: d114         	bne	0x800970c <spi_stm32_get_err+0x58> @ imm = #0x28
 80096e2: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8009730 <spi_stm32_get_err+0x7c>
 80096e4: 6819         	ldr	r1, [r3]
 80096e6: 697b         	ldr	r3, [r7, #0x14]
 80096e8: f403 73b8    	and	r3, r3, #0x170
 80096ec: 9304         	str	r3, [sp, #0x10]
 80096ee: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8009734 <spi_stm32_get_err+0x80>
 80096f0: 9303         	str	r3, [sp, #0xc]
 80096f2: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8009738 <spi_stm32_get_err+0x84>
 80096f4: 9302         	str	r3, [sp, #0x8]
 80096f6: 2300         	movs	r3, #0x0
 80096f8: 9301         	str	r3, [sp, #0x4]
 80096fa: 2300         	movs	r3, #0x0
 80096fc: 9300         	str	r3, [sp]
 80096fe: 2300         	movs	r3, #0x0
 8009700: 2201         	movs	r2, #0x1
 8009702: 2000         	movs	r0, #0x0
 8009704: f00d fedd    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xddba
 8009708: 2300         	movs	r3, #0x0
 800970a: 60fb         	str	r3, [r7, #0xc]
; 		if (LL_SPI_IsActiveFlag_OVR(spi)) {
 800970c: 6878         	ldr	r0, [r7, #0x4]
 800970e: f00e f860    	bl	0x80177d2 <LL_SPI_IsActiveFlag_OVR> @ imm = #0xe0c0
 8009712: 4603         	mov	r3, r0
 8009714: 2b00         	cmp	r3, #0x0
 8009716: d002         	beq	0x800971e <spi_stm32_get_err+0x6a> @ imm = #0x4
; 			LL_SPI_ClearFlag_OVR(spi);
 8009718: 6878         	ldr	r0, [r7, #0x4]
 800971a: f00e f891    	bl	0x8017840 <LL_SPI_ClearFlag_OVR> @ imm = #0xe122
; 		return -EIO;
 800971e: f06f 0304    	mvn	r3, #0x4
 8009722: e000         	b	0x8009726 <spi_stm32_get_err+0x72> @ imm = #0x0
; 	return 0;
 8009724: 2300         	movs	r3, #0x0
; }
 8009726: 4618         	mov	r0, r3
 8009728: 3718         	adds	r7, #0x18
 800972a: 46bd         	mov	sp, r7
 800972c: bd80         	pop	{r7, pc}
 800972e: bf00         	nop

08009730 <$d>:
 8009730: 7c 04 00 20  	.word	0x2000047c
 8009734: 7c d7 01 08  	.word	0x0801d77c
 8009738: 40 c7 01 08  	.word	0x0801c740

0800973c <spi_stm32_shift_s>:
; {
 800973c: b580         	push	{r7, lr}
 800973e: b0ac         	sub	sp, #0xb0
 8009740: af06         	add	r7, sp, #0x18
 8009742: 6078         	str	r0, [r7, #0x4]
 8009744: 6039         	str	r1, [r7]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 8009746: 6878         	ldr	r0, [r7, #0x4]
 8009748: f00e fb58    	bl	0x8017dfc <ll_func_tx_is_not_full> @ imm = #0xe6b0
 800974c: 4603         	mov	r3, r0
 800974e: 2b00         	cmp	r3, #0x0
 8009750: f000 814a    	beq.w	0x80099e8 <spi_stm32_shift_s+0x2ac> @ imm = #0x294
 8009754: 683b         	ldr	r3, [r7]
 8009756: 67fb         	str	r3, [r7, #0x7c]
; 	return !!(ctx->tx_len);
 8009758: 6ffb         	ldr	r3, [r7, #0x7c]
 800975a: 6c9b         	ldr	r3, [r3, #0x48]
 800975c: 2b00         	cmp	r3, #0x0
 800975e: bf14         	ite	ne
 8009760: 2301         	movne	r3, #0x1
 8009762: 2300         	moveq	r3, #0x0
 8009764: b2db         	uxtb	r3, r3
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 8009766: 2b00         	cmp	r3, #0x0
 8009768: f000 813e    	beq.w	0x80099e8 <spi_stm32_shift_s+0x2ac> @ imm = #0x27c
; 		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 800976c: 683b         	ldr	r3, [r7]
 800976e: 681b         	ldr	r3, [r3]
 8009770: 889b         	ldrh	r3, [r3, #0x4]
 8009772: 095b         	lsrs	r3, r3, #0x5
 8009774: f003 033f    	and	r3, r3, #0x3f
 8009778: 2b08         	cmp	r3, #0x8
 800977a: f040 809a    	bne.w	0x80098b2 <spi_stm32_shift_s+0x176> @ imm = #0x134
; 			tx_frame = UNALIGNED_GET((uint8_t *)(data->ctx.tx_buf));
 800977e: 683b         	ldr	r3, [r7]
 8009780: 6c5b         	ldr	r3, [r3, #0x44]
 8009782: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8009786: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800978a: 781b         	ldrb	r3, [r3]
 800978c: f8a7 3092    	strh.w	r3, [r7, #0x92]
; 			LL_SPI_TransmitData8(spi, tx_frame);
 8009790: f8b7 3092    	ldrh.w	r3, [r7, #0x92]
 8009794: b2db         	uxtb	r3, r3
 8009796: 4619         	mov	r1, r3
 8009798: 6878         	ldr	r0, [r7, #0x4]
 800979a: f00e f88a    	bl	0x80178b2 <LL_SPI_TransmitData8> @ imm = #0xe114
; 			spi_context_update_tx(&data->ctx, 1, 1);
 800979e: 683b         	ldr	r3, [r7]
 80097a0: 67bb         	str	r3, [r7, #0x78]
 80097a2: 2301         	movs	r3, #0x1
 80097a4: f887 3077    	strb.w	r3, [r7, #0x77]
 80097a8: 2301         	movs	r3, #0x1
 80097aa: 673b         	str	r3, [r7, #0x70]
; 	if (!ctx->tx_len) {
 80097ac: 6fbb         	ldr	r3, [r7, #0x78]
 80097ae: 6c9b         	ldr	r3, [r3, #0x48]
 80097b0: 2b00         	cmp	r3, #0x0
 80097b2: f000 8115    	beq.w	0x80099e0 <spi_stm32_shift_s+0x2a4> @ imm = #0x22a
; 	if (len > ctx->tx_len) {
 80097b6: 6fbb         	ldr	r3, [r7, #0x78]
 80097b8: 6c9b         	ldr	r3, [r3, #0x48]
 80097ba: 6f3a         	ldr	r2, [r7, #0x70]
 80097bc: 429a         	cmp	r2, r3
 80097be: d91d         	bls	0x80097fc <spi_stm32_shift_s+0xc0> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 80097c0: 2303         	movs	r3, #0x3
 80097c2: 2b00         	cmp	r3, #0x0
 80097c4: d019         	beq	0x80097fa <spi_stm32_shift_s+0xbe> @ imm = #0x32
 80097c6: 2301         	movs	r3, #0x1
 80097c8: f887 306f    	strb.w	r3, [r7, #0x6f]
 80097cc: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 80097d0: f083 0301    	eor	r3, r3, #0x1
 80097d4: b2db         	uxtb	r3, r3
 80097d6: 2b00         	cmp	r3, #0x0
 80097d8: d10f         	bne	0x80097fa <spi_stm32_shift_s+0xbe> @ imm = #0x1e
 80097da: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8009a14 <spi_stm32_shift_s+0x2d8>
 80097dc: 6819         	ldr	r1, [r3]
 80097de: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8009a18 <spi_stm32_shift_s+0x2dc>
 80097e0: 9302         	str	r3, [sp, #0x8]
 80097e2: 2300         	movs	r3, #0x0
 80097e4: 9301         	str	r3, [sp, #0x4]
 80097e6: 2300         	movs	r3, #0x0
 80097e8: 9300         	str	r3, [sp]
 80097ea: 2300         	movs	r3, #0x0
 80097ec: 2201         	movs	r2, #0x1
 80097ee: 2000         	movs	r0, #0x0
 80097f0: f00d fe67    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xdcce
 80097f4: 2300         	movs	r3, #0x0
 80097f6: 66bb         	str	r3, [r7, #0x68]
; 		return;
 80097f8: e0f5         	b	0x80099e6 <spi_stm32_shift_s+0x2aa> @ imm = #0x1ea
 80097fa: e0f4         	b	0x80099e6 <spi_stm32_shift_s+0x2aa> @ imm = #0x1e8
; 	ctx->tx_len -= len;
 80097fc: 6fbb         	ldr	r3, [r7, #0x78]
 80097fe: 6c9a         	ldr	r2, [r3, #0x48]
 8009800: 6f3b         	ldr	r3, [r7, #0x70]
 8009802: 1ad2         	subs	r2, r2, r3
 8009804: 6fbb         	ldr	r3, [r7, #0x78]
 8009806: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 8009808: 6fbb         	ldr	r3, [r7, #0x78]
 800980a: 6c9b         	ldr	r3, [r3, #0x48]
 800980c: 2b00         	cmp	r3, #0x0
 800980e: d11b         	bne	0x8009848 <spi_stm32_shift_s+0x10c> @ imm = #0x36
; 		++ctx->current_tx;
 8009810: 6fbb         	ldr	r3, [r7, #0x78]
 8009812: 6b5b         	ldr	r3, [r3, #0x34]
 8009814: f103 0208    	add.w	r2, r3, #0x8
 8009818: 6fbb         	ldr	r3, [r7, #0x78]
 800981a: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800981c: 6fbb         	ldr	r3, [r7, #0x78]
 800981e: 6b9b         	ldr	r3, [r3, #0x38]
 8009820: 1e5a         	subs	r2, r3, #0x1
 8009822: 6fbb         	ldr	r3, [r7, #0x78]
 8009824: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 8009826: 6fbb         	ldr	r3, [r7, #0x78]
 8009828: f103 0034    	add.w	r0, r3, #0x34
 800982c: 6fbb         	ldr	r3, [r7, #0x78]
 800982e: f103 0138    	add.w	r1, r3, #0x38
 8009832: 6fbb         	ldr	r3, [r7, #0x78]
 8009834: f103 0248    	add.w	r2, r3, #0x48
 8009838: f897 3077    	ldrb.w	r3, [r7, #0x77]
 800983c: f00e faac    	bl	0x8017d98 <spi_context_get_next_buf> @ imm = #0xe558
 8009840: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 8009842: 6fbb         	ldr	r3, [r7, #0x78]
 8009844: 645a         	str	r2, [r3, #0x44]
 8009846: e00d         	b	0x8009864 <spi_stm32_shift_s+0x128> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 8009848: 6fbb         	ldr	r3, [r7, #0x78]
 800984a: 6c5b         	ldr	r3, [r3, #0x44]
 800984c: 2b00         	cmp	r3, #0x0
 800984e: d009         	beq	0x8009864 <spi_stm32_shift_s+0x128> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 8009850: 6fbb         	ldr	r3, [r7, #0x78]
 8009852: 6c5a         	ldr	r2, [r3, #0x44]
 8009854: f897 3077    	ldrb.w	r3, [r7, #0x77]
 8009858: 6f39         	ldr	r1, [r7, #0x70]
 800985a: fb01 f303    	mul	r3, r1, r3
 800985e: 441a         	add	r2, r3
 8009860: 6fbb         	ldr	r3, [r7, #0x78]
 8009862: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 8009864: 2303         	movs	r3, #0x3
 8009866: 2b03         	cmp	r3, #0x3
 8009868: f240 80bd    	bls.w	0x80099e6 <spi_stm32_shift_s+0x2aa> @ imm = #0x17a
 800986c: 2301         	movs	r3, #0x1
 800986e: f887 3067    	strb.w	r3, [r7, #0x67]
 8009872: f897 3067    	ldrb.w	r3, [r7, #0x67]
 8009876: f083 0301    	eor	r3, r3, #0x1
 800987a: b2db         	uxtb	r3, r3
 800987c: 2b00         	cmp	r3, #0x0
 800987e: f040 80b2    	bne.w	0x80099e6 <spi_stm32_shift_s+0x2aa> @ imm = #0x164
 8009882: 4b64         	ldr	r3, [pc, #0x190]        @ 0x8009a14 <spi_stm32_shift_s+0x2d8>
 8009884: 6819         	ldr	r1, [r3]
 8009886: 6fbb         	ldr	r3, [r7, #0x78]
 8009888: 6c5b         	ldr	r3, [r3, #0x44]
 800988a: 6fba         	ldr	r2, [r7, #0x78]
 800988c: 6c92         	ldr	r2, [r2, #0x48]
 800988e: 9205         	str	r2, [sp, #0x14]
 8009890: 9304         	str	r3, [sp, #0x10]
 8009892: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8009a1c <spi_stm32_shift_s+0x2e0>
 8009894: 9303         	str	r3, [sp, #0xc]
 8009896: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8009a20 <spi_stm32_shift_s+0x2e4>
 8009898: 9302         	str	r3, [sp, #0x8]
 800989a: 2308         	movs	r3, #0x8
 800989c: 9301         	str	r3, [sp, #0x4]
 800989e: 2300         	movs	r3, #0x0
 80098a0: 9300         	str	r3, [sp]
 80098a2: 2300         	movs	r3, #0x0
 80098a4: 2204         	movs	r2, #0x4
 80098a6: 2000         	movs	r0, #0x0
 80098a8: f00d fe0b    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xdc16
 80098ac: 2300         	movs	r3, #0x0
 80098ae: 663b         	str	r3, [r7, #0x60]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 80098b0: e09d         	b	0x80099ee <spi_stm32_shift_s+0x2b2> @ imm = #0x13a
; 			tx_frame = UNALIGNED_GET((uint16_t *)(data->ctx.tx_buf));
 80098b2: 683b         	ldr	r3, [r7]
 80098b4: 6c5b         	ldr	r3, [r3, #0x44]
 80098b6: f8c7 3094    	str.w	r3, [r7, #0x94]
 80098ba: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 80098be: 881b         	ldrh	r3, [r3]
 80098c0: b29b         	uxth	r3, r3
 80098c2: f8a7 3092    	strh.w	r3, [r7, #0x92]
; 			LL_SPI_TransmitData16(spi, tx_frame);
 80098c6: f8b7 3092    	ldrh.w	r3, [r7, #0x92]
 80098ca: 4619         	mov	r1, r3
 80098cc: 6878         	ldr	r0, [r7, #0x4]
 80098ce: f00e f801    	bl	0x80178d4 <LL_SPI_TransmitData16> @ imm = #0xe002
; 			spi_context_update_tx(&data->ctx, 2, 1);
 80098d2: 683b         	ldr	r3, [r7]
 80098d4: 65fb         	str	r3, [r7, #0x5c]
 80098d6: 2302         	movs	r3, #0x2
 80098d8: f887 305b    	strb.w	r3, [r7, #0x5b]
 80098dc: 2301         	movs	r3, #0x1
 80098de: 657b         	str	r3, [r7, #0x54]
; 	if (!ctx->tx_len) {
 80098e0: 6dfb         	ldr	r3, [r7, #0x5c]
 80098e2: 6c9b         	ldr	r3, [r3, #0x48]
 80098e4: 2b00         	cmp	r3, #0x0
 80098e6: d07d         	beq	0x80099e4 <spi_stm32_shift_s+0x2a8> @ imm = #0xfa
; 	if (len > ctx->tx_len) {
 80098e8: 6dfb         	ldr	r3, [r7, #0x5c]
 80098ea: 6c9b         	ldr	r3, [r3, #0x48]
 80098ec: 6d7a         	ldr	r2, [r7, #0x54]
 80098ee: 429a         	cmp	r2, r3
 80098f0: d91d         	bls	0x800992e <spi_stm32_shift_s+0x1f2> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 80098f2: 2303         	movs	r3, #0x3
 80098f4: 2b00         	cmp	r3, #0x0
 80098f6: d019         	beq	0x800992c <spi_stm32_shift_s+0x1f0> @ imm = #0x32
 80098f8: 2301         	movs	r3, #0x1
 80098fa: f887 3053    	strb.w	r3, [r7, #0x53]
 80098fe: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8009902: f083 0301    	eor	r3, r3, #0x1
 8009906: b2db         	uxtb	r3, r3
 8009908: 2b00         	cmp	r3, #0x0
 800990a: d10f         	bne	0x800992c <spi_stm32_shift_s+0x1f0> @ imm = #0x1e
 800990c: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8009a14 <spi_stm32_shift_s+0x2d8>
 800990e: 6819         	ldr	r1, [r3]
 8009910: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8009a18 <spi_stm32_shift_s+0x2dc>
 8009912: 9302         	str	r3, [sp, #0x8]
 8009914: 2300         	movs	r3, #0x0
 8009916: 9301         	str	r3, [sp, #0x4]
 8009918: 2300         	movs	r3, #0x0
 800991a: 9300         	str	r3, [sp]
 800991c: 2300         	movs	r3, #0x0
 800991e: 2201         	movs	r2, #0x1
 8009920: 2000         	movs	r0, #0x0
 8009922: f00d fdce    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xdb9c
 8009926: 2300         	movs	r3, #0x0
 8009928: 64fb         	str	r3, [r7, #0x4c]
; 		return;
 800992a: e05c         	b	0x80099e6 <spi_stm32_shift_s+0x2aa> @ imm = #0xb8
 800992c: e05b         	b	0x80099e6 <spi_stm32_shift_s+0x2aa> @ imm = #0xb6
; 	ctx->tx_len -= len;
 800992e: 6dfb         	ldr	r3, [r7, #0x5c]
 8009930: 6c9a         	ldr	r2, [r3, #0x48]
 8009932: 6d7b         	ldr	r3, [r7, #0x54]
 8009934: 1ad2         	subs	r2, r2, r3
 8009936: 6dfb         	ldr	r3, [r7, #0x5c]
 8009938: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800993a: 6dfb         	ldr	r3, [r7, #0x5c]
 800993c: 6c9b         	ldr	r3, [r3, #0x48]
 800993e: 2b00         	cmp	r3, #0x0
 8009940: d11b         	bne	0x800997a <spi_stm32_shift_s+0x23e> @ imm = #0x36
; 		++ctx->current_tx;
 8009942: 6dfb         	ldr	r3, [r7, #0x5c]
 8009944: 6b5b         	ldr	r3, [r3, #0x34]
 8009946: f103 0208    	add.w	r2, r3, #0x8
 800994a: 6dfb         	ldr	r3, [r7, #0x5c]
 800994c: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800994e: 6dfb         	ldr	r3, [r7, #0x5c]
 8009950: 6b9b         	ldr	r3, [r3, #0x38]
 8009952: 1e5a         	subs	r2, r3, #0x1
 8009954: 6dfb         	ldr	r3, [r7, #0x5c]
 8009956: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 8009958: 6dfb         	ldr	r3, [r7, #0x5c]
 800995a: f103 0034    	add.w	r0, r3, #0x34
 800995e: 6dfb         	ldr	r3, [r7, #0x5c]
 8009960: f103 0138    	add.w	r1, r3, #0x38
 8009964: 6dfb         	ldr	r3, [r7, #0x5c]
 8009966: f103 0248    	add.w	r2, r3, #0x48
 800996a: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 800996e: f00e fa13    	bl	0x8017d98 <spi_context_get_next_buf> @ imm = #0xe426
 8009972: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 8009974: 6dfb         	ldr	r3, [r7, #0x5c]
 8009976: 645a         	str	r2, [r3, #0x44]
 8009978: e00d         	b	0x8009996 <spi_stm32_shift_s+0x25a> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 800997a: 6dfb         	ldr	r3, [r7, #0x5c]
 800997c: 6c5b         	ldr	r3, [r3, #0x44]
 800997e: 2b00         	cmp	r3, #0x0
 8009980: d009         	beq	0x8009996 <spi_stm32_shift_s+0x25a> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 8009982: 6dfb         	ldr	r3, [r7, #0x5c]
 8009984: 6c5a         	ldr	r2, [r3, #0x44]
 8009986: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 800998a: 6d79         	ldr	r1, [r7, #0x54]
 800998c: fb01 f303    	mul	r3, r1, r3
 8009990: 441a         	add	r2, r3
 8009992: 6dfb         	ldr	r3, [r7, #0x5c]
 8009994: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 8009996: 2303         	movs	r3, #0x3
 8009998: 2b03         	cmp	r3, #0x3
 800999a: d924         	bls	0x80099e6 <spi_stm32_shift_s+0x2aa> @ imm = #0x48
 800999c: 2301         	movs	r3, #0x1
 800999e: f887 304b    	strb.w	r3, [r7, #0x4b]
 80099a2: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 80099a6: f083 0301    	eor	r3, r3, #0x1
 80099aa: b2db         	uxtb	r3, r3
 80099ac: 2b00         	cmp	r3, #0x0
 80099ae: d11a         	bne	0x80099e6 <spi_stm32_shift_s+0x2aa> @ imm = #0x34
 80099b0: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8009a14 <spi_stm32_shift_s+0x2d8>
 80099b2: 6819         	ldr	r1, [r3]
 80099b4: 6dfb         	ldr	r3, [r7, #0x5c]
 80099b6: 6c5b         	ldr	r3, [r3, #0x44]
 80099b8: 6dfa         	ldr	r2, [r7, #0x5c]
 80099ba: 6c92         	ldr	r2, [r2, #0x48]
 80099bc: 9205         	str	r2, [sp, #0x14]
 80099be: 9304         	str	r3, [sp, #0x10]
 80099c0: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8009a1c <spi_stm32_shift_s+0x2e0>
 80099c2: 9303         	str	r3, [sp, #0xc]
 80099c4: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8009a20 <spi_stm32_shift_s+0x2e4>
 80099c6: 9302         	str	r3, [sp, #0x8]
 80099c8: 2308         	movs	r3, #0x8
 80099ca: 9301         	str	r3, [sp, #0x4]
 80099cc: 2300         	movs	r3, #0x0
 80099ce: 9300         	str	r3, [sp]
 80099d0: 2300         	movs	r3, #0x0
 80099d2: 2204         	movs	r2, #0x4
 80099d4: 2000         	movs	r0, #0x0
 80099d6: f00d fd74    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xdae8
 80099da: 2300         	movs	r3, #0x0
 80099dc: 647b         	str	r3, [r7, #0x44]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 80099de: e006         	b	0x80099ee <spi_stm32_shift_s+0x2b2> @ imm = #0xc
; 		return;
 80099e0: bf00         	nop
 80099e2: e004         	b	0x80099ee <spi_stm32_shift_s+0x2b2> @ imm = #0x8
 80099e4: bf00         	nop
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 80099e6: e002         	b	0x80099ee <spi_stm32_shift_s+0x2b2> @ imm = #0x4
; 		ll_func_disable_int_tx_empty(spi);
 80099e8: 6878         	ldr	r0, [r7, #0x4]
 80099ea: f00e fa1f    	bl	0x8017e2c <ll_func_disable_int_tx_empty> @ imm = #0xe43e
; 	if (ll_func_rx_is_not_empty(spi) &&
 80099ee: 6878         	ldr	r0, [r7, #0x4]
 80099f0: f00e fa10    	bl	0x8017e14 <ll_func_rx_is_not_empty> @ imm = #0xe420
 80099f4: 4603         	mov	r3, r0
 80099f6: 2b00         	cmp	r3, #0x0
 80099f8: f000 8150    	beq.w	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0x2a0
; 	    spi_context_rx_buf_on(&data->ctx)) {
 80099fc: 683b         	ldr	r3, [r7]
 80099fe: 643b         	str	r3, [r7, #0x40]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 8009a00: 6c3b         	ldr	r3, [r7, #0x40]
 8009a02: 6cdb         	ldr	r3, [r3, #0x4c]
 8009a04: 2b00         	cmp	r3, #0x0
 8009a06: d00d         	beq	0x8009a24 <spi_stm32_shift_s+0x2e8> @ imm = #0x1a
 8009a08: 6c3b         	ldr	r3, [r7, #0x40]
 8009a0a: 6d1b         	ldr	r3, [r3, #0x50]
 8009a0c: 2b00         	cmp	r3, #0x0
 8009a0e: d009         	beq	0x8009a24 <spi_stm32_shift_s+0x2e8> @ imm = #0x12
 8009a10: 2301         	movs	r3, #0x1
 8009a12: e008         	b	0x8009a26 <spi_stm32_shift_s+0x2ea> @ imm = #0x10

08009a14 <$d>:
 8009a14: 7c 04 00 20  	.word	0x2000047c
 8009a18: f0 c6 01 08  	.word	0x0801c6f0
 8009a1c: 4c d7 01 08  	.word	0x0801d74c
 8009a20: 10 c7 01 08  	.word	0x0801c710

08009a24 <$t>:
 8009a24: 2300         	movs	r3, #0x0
 8009a26: f003 0301    	and	r3, r3, #0x1
 8009a2a: b2db         	uxtb	r3, r3
; 	if (ll_func_rx_is_not_empty(spi) &&
 8009a2c: 2b00         	cmp	r3, #0x0
 8009a2e: f000 8135    	beq.w	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0x26a
; 		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 8009a32: 683b         	ldr	r3, [r7]
 8009a34: 681b         	ldr	r3, [r3]
 8009a36: 889b         	ldrh	r3, [r3, #0x4]
 8009a38: 095b         	lsrs	r3, r3, #0x5
 8009a3a: f003 033f    	and	r3, r3, #0x3f
 8009a3e: 2b08         	cmp	r3, #0x8
 8009a40: f040 809a    	bne.w	0x8009b78 <spi_stm32_shift_s+0x43c> @ imm = #0x134
; 			rx_frame = LL_SPI_ReceiveData8(spi);
 8009a44: 6878         	ldr	r0, [r7, #0x4]
 8009a46: f00d ff1b    	bl	0x8017880 <LL_SPI_ReceiveData8> @ imm = #0xde36
 8009a4a: 4603         	mov	r3, r0
 8009a4c: f8a7 308a    	strh.w	r3, [r7, #0x8a]
; 			UNALIGNED_PUT(rx_frame, (uint8_t *)data->ctx.rx_buf);
 8009a50: 683b         	ldr	r3, [r7]
 8009a52: 6cdb         	ldr	r3, [r3, #0x4c]
 8009a54: f8c7 3080    	str.w	r3, [r7, #0x80]
 8009a58: f8b7 308a    	ldrh.w	r3, [r7, #0x8a]
 8009a5c: b2da         	uxtb	r2, r3
 8009a5e: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8009a62: 701a         	strb	r2, [r3]
; 			spi_context_update_rx(&data->ctx, 1, 1);
 8009a64: 683b         	ldr	r3, [r7]
 8009a66: 63fb         	str	r3, [r7, #0x3c]
 8009a68: 2301         	movs	r3, #0x1
 8009a6a: f887 303b    	strb.w	r3, [r7, #0x3b]
 8009a6e: 2301         	movs	r3, #0x1
 8009a70: 637b         	str	r3, [r7, #0x34]
; 	if (!ctx->rx_len) {
 8009a72: 6bfb         	ldr	r3, [r7, #0x3c]
 8009a74: 6d1b         	ldr	r3, [r3, #0x50]
 8009a76: 2b00         	cmp	r3, #0x0
 8009a78: f000 810d    	beq.w	0x8009c96 <spi_stm32_shift_s+0x55a> @ imm = #0x21a
; 	if (len > ctx->rx_len) {
 8009a7c: 6bfb         	ldr	r3, [r7, #0x3c]
 8009a7e: 6d1b         	ldr	r3, [r3, #0x50]
 8009a80: 6b7a         	ldr	r2, [r7, #0x34]
 8009a82: 429a         	cmp	r2, r3
 8009a84: d91d         	bls	0x8009ac2 <spi_stm32_shift_s+0x386> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 8009a86: 2303         	movs	r3, #0x3
 8009a88: 2b00         	cmp	r3, #0x0
 8009a8a: d019         	beq	0x8009ac0 <spi_stm32_shift_s+0x384> @ imm = #0x32
 8009a8c: 2301         	movs	r3, #0x1
 8009a8e: f887 3033    	strb.w	r3, [r7, #0x33]
 8009a92: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8009a96: f083 0301    	eor	r3, r3, #0x1
 8009a9a: b2db         	uxtb	r3, r3
 8009a9c: 2b00         	cmp	r3, #0x0
 8009a9e: d10f         	bne	0x8009ac0 <spi_stm32_shift_s+0x384> @ imm = #0x1e
 8009aa0: 4b80         	ldr	r3, [pc, #0x200]        @ 0x8009ca4 <spi_stm32_shift_s+0x568>
 8009aa2: 6819         	ldr	r1, [r3]
 8009aa4: 4b80         	ldr	r3, [pc, #0x200]        @ 0x8009ca8 <spi_stm32_shift_s+0x56c>
 8009aa6: 9302         	str	r3, [sp, #0x8]
 8009aa8: 2300         	movs	r3, #0x0
 8009aaa: 9301         	str	r3, [sp, #0x4]
 8009aac: 2300         	movs	r3, #0x0
 8009aae: 9300         	str	r3, [sp]
 8009ab0: 2300         	movs	r3, #0x0
 8009ab2: 2201         	movs	r2, #0x1
 8009ab4: 2000         	movs	r0, #0x0
 8009ab6: f00d fd04    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xda08
 8009aba: 2300         	movs	r3, #0x0
 8009abc: 62fb         	str	r3, [r7, #0x2c]
; 		return;
 8009abe: e0ed         	b	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0x1da
 8009ac0: e0ec         	b	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0x1d8
; 	ctx->rx_len -= len;
 8009ac2: 6bfb         	ldr	r3, [r7, #0x3c]
 8009ac4: 6d1a         	ldr	r2, [r3, #0x50]
 8009ac6: 6b7b         	ldr	r3, [r7, #0x34]
 8009ac8: 1ad2         	subs	r2, r2, r3
 8009aca: 6bfb         	ldr	r3, [r7, #0x3c]
 8009acc: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 8009ace: 6bfb         	ldr	r3, [r7, #0x3c]
 8009ad0: 6d1b         	ldr	r3, [r3, #0x50]
 8009ad2: 2b00         	cmp	r3, #0x0
 8009ad4: d11b         	bne	0x8009b0e <spi_stm32_shift_s+0x3d2> @ imm = #0x36
; 		++ctx->current_rx;
 8009ad6: 6bfb         	ldr	r3, [r7, #0x3c]
 8009ad8: 6bdb         	ldr	r3, [r3, #0x3c]
 8009ada: f103 0208    	add.w	r2, r3, #0x8
 8009ade: 6bfb         	ldr	r3, [r7, #0x3c]
 8009ae0: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 8009ae2: 6bfb         	ldr	r3, [r7, #0x3c]
 8009ae4: 6c1b         	ldr	r3, [r3, #0x40]
 8009ae6: 1e5a         	subs	r2, r3, #0x1
 8009ae8: 6bfb         	ldr	r3, [r7, #0x3c]
 8009aea: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 8009aec: 6bfb         	ldr	r3, [r7, #0x3c]
 8009aee: f103 003c    	add.w	r0, r3, #0x3c
 8009af2: 6bfb         	ldr	r3, [r7, #0x3c]
 8009af4: f103 0140    	add.w	r1, r3, #0x40
 8009af8: 6bfb         	ldr	r3, [r7, #0x3c]
 8009afa: f103 0250    	add.w	r2, r3, #0x50
 8009afe: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8009b02: f00e f949    	bl	0x8017d98 <spi_context_get_next_buf> @ imm = #0xe292
 8009b06: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 8009b08: 6bfb         	ldr	r3, [r7, #0x3c]
 8009b0a: 64da         	str	r2, [r3, #0x4c]
 8009b0c: e00d         	b	0x8009b2a <spi_stm32_shift_s+0x3ee> @ imm = #0x1a
; 	} else if (ctx->rx_buf) {
 8009b0e: 6bfb         	ldr	r3, [r7, #0x3c]
 8009b10: 6cdb         	ldr	r3, [r3, #0x4c]
 8009b12: 2b00         	cmp	r3, #0x0
 8009b14: d009         	beq	0x8009b2a <spi_stm32_shift_s+0x3ee> @ imm = #0x12
; 		ctx->rx_buf += dfs * len;
 8009b16: 6bfb         	ldr	r3, [r7, #0x3c]
 8009b18: 6cda         	ldr	r2, [r3, #0x4c]
 8009b1a: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8009b1e: 6b79         	ldr	r1, [r7, #0x34]
 8009b20: fb01 f303    	mul	r3, r1, r3
 8009b24: 441a         	add	r2, r3
 8009b26: 6bfb         	ldr	r3, [r7, #0x3c]
 8009b28: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 8009b2a: 2303         	movs	r3, #0x3
 8009b2c: 2b03         	cmp	r3, #0x3
 8009b2e: f240 80b5    	bls.w	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0x16a
 8009b32: 2301         	movs	r3, #0x1
 8009b34: f887 302b    	strb.w	r3, [r7, #0x2b]
 8009b38: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8009b3c: f083 0301    	eor	r3, r3, #0x1
 8009b40: b2db         	uxtb	r3, r3
 8009b42: 2b00         	cmp	r3, #0x0
 8009b44: f040 80aa    	bne.w	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0x154
 8009b48: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8009ca4 <spi_stm32_shift_s+0x568>
 8009b4a: 6819         	ldr	r1, [r3]
 8009b4c: 6bfb         	ldr	r3, [r7, #0x3c]
 8009b4e: 6cdb         	ldr	r3, [r3, #0x4c]
 8009b50: 6bfa         	ldr	r2, [r7, #0x3c]
 8009b52: 6d12         	ldr	r2, [r2, #0x50]
 8009b54: 9205         	str	r2, [sp, #0x14]
 8009b56: 9304         	str	r3, [sp, #0x10]
 8009b58: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8009cac <spi_stm32_shift_s+0x570>
 8009b5a: 9303         	str	r3, [sp, #0xc]
 8009b5c: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8009cb0 <spi_stm32_shift_s+0x574>
 8009b5e: 9302         	str	r3, [sp, #0x8]
 8009b60: 2308         	movs	r3, #0x8
 8009b62: 9301         	str	r3, [sp, #0x4]
 8009b64: 2300         	movs	r3, #0x0
 8009b66: 9300         	str	r3, [sp]
 8009b68: 2300         	movs	r3, #0x0
 8009b6a: 2204         	movs	r2, #0x4
 8009b6c: 2000         	movs	r0, #0x0
 8009b6e: f00d fca8    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xd950
 8009b72: 2300         	movs	r3, #0x0
 8009b74: 627b         	str	r3, [r7, #0x24]
; }
 8009b76: e091         	b	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0x122
; 			rx_frame = LL_SPI_ReceiveData16(spi);
 8009b78: 6878         	ldr	r0, [r7, #0x4]
 8009b7a: f00d fe8e    	bl	0x801789a <LL_SPI_ReceiveData16> @ imm = #0xdd1c
 8009b7e: 4603         	mov	r3, r0
 8009b80: f8a7 308a    	strh.w	r3, [r7, #0x8a]
; 			UNALIGNED_PUT(rx_frame, (uint16_t *)data->ctx.rx_buf);
 8009b84: 683b         	ldr	r3, [r7]
 8009b86: 6cdb         	ldr	r3, [r3, #0x4c]
 8009b88: f8c7 3084    	str.w	r3, [r7, #0x84]
 8009b8c: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8009b90: f8b7 208a    	ldrh.w	r2, [r7, #0x8a]
 8009b94: 801a         	strh	r2, [r3]
; 			spi_context_update_rx(&data->ctx, 2, 1);
 8009b96: 683b         	ldr	r3, [r7]
 8009b98: 623b         	str	r3, [r7, #0x20]
 8009b9a: 2302         	movs	r3, #0x2
 8009b9c: 77fb         	strb	r3, [r7, #0x1f]
 8009b9e: 2301         	movs	r3, #0x1
 8009ba0: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->rx_len) {
 8009ba2: 6a3b         	ldr	r3, [r7, #0x20]
 8009ba4: 6d1b         	ldr	r3, [r3, #0x50]
 8009ba6: 2b00         	cmp	r3, #0x0
 8009ba8: d077         	beq	0x8009c9a <spi_stm32_shift_s+0x55e> @ imm = #0xee
; 	if (len > ctx->rx_len) {
 8009baa: 6a3b         	ldr	r3, [r7, #0x20]
 8009bac: 6d1b         	ldr	r3, [r3, #0x50]
 8009bae: 69ba         	ldr	r2, [r7, #0x18]
 8009bb0: 429a         	cmp	r2, r3
 8009bb2: d91b         	bls	0x8009bec <spi_stm32_shift_s+0x4b0> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 8009bb4: 2303         	movs	r3, #0x3
 8009bb6: 2b00         	cmp	r3, #0x0
 8009bb8: d017         	beq	0x8009bea <spi_stm32_shift_s+0x4ae> @ imm = #0x2e
 8009bba: 2301         	movs	r3, #0x1
 8009bbc: 75fb         	strb	r3, [r7, #0x17]
 8009bbe: 7dfb         	ldrb	r3, [r7, #0x17]
 8009bc0: f083 0301    	eor	r3, r3, #0x1
 8009bc4: b2db         	uxtb	r3, r3
 8009bc6: 2b00         	cmp	r3, #0x0
 8009bc8: d10f         	bne	0x8009bea <spi_stm32_shift_s+0x4ae> @ imm = #0x1e
 8009bca: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8009ca4 <spi_stm32_shift_s+0x568>
 8009bcc: 6819         	ldr	r1, [r3]
 8009bce: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8009ca8 <spi_stm32_shift_s+0x56c>
 8009bd0: 9302         	str	r3, [sp, #0x8]
 8009bd2: 2300         	movs	r3, #0x0
 8009bd4: 9301         	str	r3, [sp, #0x4]
 8009bd6: 2300         	movs	r3, #0x0
 8009bd8: 9300         	str	r3, [sp]
 8009bda: 2300         	movs	r3, #0x0
 8009bdc: 2201         	movs	r2, #0x1
 8009bde: 2000         	movs	r0, #0x0
 8009be0: f00d fc6f    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xd8de
 8009be4: 2300         	movs	r3, #0x0
 8009be6: 613b         	str	r3, [r7, #0x10]
; 		return;
 8009be8: e058         	b	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0xb0
 8009bea: e057         	b	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0xae
; 	ctx->rx_len -= len;
 8009bec: 6a3b         	ldr	r3, [r7, #0x20]
 8009bee: 6d1a         	ldr	r2, [r3, #0x50]
 8009bf0: 69bb         	ldr	r3, [r7, #0x18]
 8009bf2: 1ad2         	subs	r2, r2, r3
 8009bf4: 6a3b         	ldr	r3, [r7, #0x20]
 8009bf6: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 8009bf8: 6a3b         	ldr	r3, [r7, #0x20]
 8009bfa: 6d1b         	ldr	r3, [r3, #0x50]
 8009bfc: 2b00         	cmp	r3, #0x0
 8009bfe: d11a         	bne	0x8009c36 <spi_stm32_shift_s+0x4fa> @ imm = #0x34
; 		++ctx->current_rx;
 8009c00: 6a3b         	ldr	r3, [r7, #0x20]
 8009c02: 6bdb         	ldr	r3, [r3, #0x3c]
 8009c04: f103 0208    	add.w	r2, r3, #0x8
 8009c08: 6a3b         	ldr	r3, [r7, #0x20]
 8009c0a: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 8009c0c: 6a3b         	ldr	r3, [r7, #0x20]
 8009c0e: 6c1b         	ldr	r3, [r3, #0x40]
 8009c10: 1e5a         	subs	r2, r3, #0x1
 8009c12: 6a3b         	ldr	r3, [r7, #0x20]
 8009c14: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 8009c16: 6a3b         	ldr	r3, [r7, #0x20]
 8009c18: f103 003c    	add.w	r0, r3, #0x3c
 8009c1c: 6a3b         	ldr	r3, [r7, #0x20]
 8009c1e: f103 0140    	add.w	r1, r3, #0x40
 8009c22: 6a3b         	ldr	r3, [r7, #0x20]
 8009c24: f103 0250    	add.w	r2, r3, #0x50
 8009c28: 7ffb         	ldrb	r3, [r7, #0x1f]
 8009c2a: f00e f8b5    	bl	0x8017d98 <spi_context_get_next_buf> @ imm = #0xe16a
 8009c2e: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 8009c30: 6a3b         	ldr	r3, [r7, #0x20]
 8009c32: 64da         	str	r2, [r3, #0x4c]
 8009c34: e00c         	b	0x8009c50 <spi_stm32_shift_s+0x514> @ imm = #0x18
; 	} else if (ctx->rx_buf) {
 8009c36: 6a3b         	ldr	r3, [r7, #0x20]
 8009c38: 6cdb         	ldr	r3, [r3, #0x4c]
 8009c3a: 2b00         	cmp	r3, #0x0
 8009c3c: d008         	beq	0x8009c50 <spi_stm32_shift_s+0x514> @ imm = #0x10
; 		ctx->rx_buf += dfs * len;
 8009c3e: 6a3b         	ldr	r3, [r7, #0x20]
 8009c40: 6cda         	ldr	r2, [r3, #0x4c]
 8009c42: 7ffb         	ldrb	r3, [r7, #0x1f]
 8009c44: 69b9         	ldr	r1, [r7, #0x18]
 8009c46: fb01 f303    	mul	r3, r1, r3
 8009c4a: 441a         	add	r2, r3
 8009c4c: 6a3b         	ldr	r3, [r7, #0x20]
 8009c4e: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 8009c50: 2303         	movs	r3, #0x3
 8009c52: 2b03         	cmp	r3, #0x3
 8009c54: d922         	bls	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0x44
 8009c56: 2301         	movs	r3, #0x1
 8009c58: 73fb         	strb	r3, [r7, #0xf]
 8009c5a: 7bfb         	ldrb	r3, [r7, #0xf]
 8009c5c: f083 0301    	eor	r3, r3, #0x1
 8009c60: b2db         	uxtb	r3, r3
 8009c62: 2b00         	cmp	r3, #0x0
 8009c64: d11a         	bne	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0x34
 8009c66: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8009ca4 <spi_stm32_shift_s+0x568>
 8009c68: 6819         	ldr	r1, [r3]
 8009c6a: 6a3b         	ldr	r3, [r7, #0x20]
 8009c6c: 6cdb         	ldr	r3, [r3, #0x4c]
 8009c6e: 6a3a         	ldr	r2, [r7, #0x20]
 8009c70: 6d12         	ldr	r2, [r2, #0x50]
 8009c72: 9205         	str	r2, [sp, #0x14]
 8009c74: 9304         	str	r3, [sp, #0x10]
 8009c76: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8009cac <spi_stm32_shift_s+0x570>
 8009c78: 9303         	str	r3, [sp, #0xc]
 8009c7a: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8009cb0 <spi_stm32_shift_s+0x574>
 8009c7c: 9302         	str	r3, [sp, #0x8]
 8009c7e: 2308         	movs	r3, #0x8
 8009c80: 9301         	str	r3, [sp, #0x4]
 8009c82: 2300         	movs	r3, #0x0
 8009c84: 9300         	str	r3, [sp]
 8009c86: 2300         	movs	r3, #0x0
 8009c88: 2204         	movs	r2, #0x4
 8009c8a: 2000         	movs	r0, #0x0
 8009c8c: f00d fc19    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xd832
 8009c90: 2300         	movs	r3, #0x0
 8009c92: 60bb         	str	r3, [r7, #0x8]
; }
 8009c94: e002         	b	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0x4
; 		return;
 8009c96: bf00         	nop
 8009c98: e000         	b	0x8009c9c <spi_stm32_shift_s+0x560> @ imm = #0x0
 8009c9a: bf00         	nop
; }
 8009c9c: bf00         	nop
 8009c9e: 3798         	adds	r7, #0x98
 8009ca0: 46bd         	mov	sp, r7
 8009ca2: bd80         	pop	{r7, pc}

08009ca4 <$d>:
 8009ca4: 7c 04 00 20  	.word	0x2000047c
 8009ca8: f0 c6 01 08  	.word	0x0801c6f0
 8009cac: 64 d7 01 08  	.word	0x0801d764
 8009cb0: 28 c7 01 08  	.word	0x0801c728

08009cb4 <spi_stm32_configure>:
; {
 8009cb4: b5f0         	push	{r4, r5, r6, r7, lr}
 8009cb6: b0a3         	sub	sp, #0x8c
 8009cb8: af0c         	add	r7, sp, #0x30
 8009cba: 6078         	str	r0, [r7, #0x4]
 8009cbc: 6039         	str	r1, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 8009cbe: 687b         	ldr	r3, [r7, #0x4]
 8009cc0: 685b         	ldr	r3, [r3, #0x4]
 8009cc2: 63bb         	str	r3, [r7, #0x38]
; 	struct spi_stm32_data *data = dev->data;
 8009cc4: 687b         	ldr	r3, [r7, #0x4]
 8009cc6: 691b         	ldr	r3, [r3, #0x10]
 8009cc8: 637b         	str	r3, [r7, #0x34]
; 	const uint32_t scaler[] = {
 8009cca: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8009f00 <spi_stm32_configure+0x24c>
 8009ccc: f107 0410    	add.w	r4, r7, #0x10
 8009cd0: 461d         	mov	r5, r3
 8009cd2: cd0f         	ldm	r5!, {r0, r1, r2, r3}
 8009cd4: c40f         	stm	r4!, {r0, r1, r2, r3}
 8009cd6: e895 000f    	ldm.w	r5, {r0, r1, r2, r3}
 8009cda: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
; 	SPI_TypeDef *spi = cfg->spi;
 8009cde: 6bbb         	ldr	r3, [r7, #0x38]
 8009ce0: 681b         	ldr	r3, [r3]
 8009ce2: 633b         	str	r3, [r7, #0x30]
; 	if (spi_context_configured(&data->ctx, config)) {
 8009ce4: 6b7b         	ldr	r3, [r7, #0x34]
 8009ce6: 6839         	ldr	r1, [r7]
 8009ce8: 4618         	mov	r0, r3
 8009cea: f00d ff8e    	bl	0x8017c0a <spi_context_configured> @ imm = #0xdf1c
 8009cee: 4603         	mov	r3, r0
 8009cf0: 2b00         	cmp	r3, #0x0
 8009cf2: d001         	beq	0x8009cf8 <spi_stm32_configure+0x44> @ imm = #0x2
; 		return 0;
 8009cf4: 2300         	movs	r3, #0x0
 8009cf6: e156         	b	0x8009fa6 <spi_stm32_configure+0x2f2> @ imm = #0x2ac
; 	if ((SPI_WORD_SIZE_GET(config->operation) != 8)
 8009cf8: 683b         	ldr	r3, [r7]
 8009cfa: 889b         	ldrh	r3, [r3, #0x4]
 8009cfc: 095b         	lsrs	r3, r3, #0x5
 8009cfe: f003 033f    	and	r3, r3, #0x3f
 8009d02: 2b08         	cmp	r3, #0x8
 8009d04: d009         	beq	0x8009d1a <spi_stm32_configure+0x66> @ imm = #0x12
; 	    && (SPI_WORD_SIZE_GET(config->operation) != 16)) {
 8009d06: 683b         	ldr	r3, [r7]
 8009d08: 889b         	ldrh	r3, [r3, #0x4]
 8009d0a: 095b         	lsrs	r3, r3, #0x5
 8009d0c: f003 033f    	and	r3, r3, #0x3f
 8009d10: 2b10         	cmp	r3, #0x10
 8009d12: d002         	beq	0x8009d1a <spi_stm32_configure+0x66> @ imm = #0x4
; 		return -ENOTSUP;
 8009d14: f06f 0385    	mvn	r3, #0x85
 8009d18: e145         	b	0x8009fa6 <spi_stm32_configure+0x2f2> @ imm = #0x28a
; 	if ((config->operation & SPI_FRAME_FORMAT_TI) == SPI_FRAME_FORMAT_TI) {
 8009d1a: 683b         	ldr	r3, [r7]
 8009d1c: 889b         	ldrh	r3, [r3, #0x4]
 8009d1e: b21b         	sxth	r3, r3
 8009d20: 2b00         	cmp	r3, #0x0
 8009d22: da04         	bge	0x8009d2e <spi_stm32_configure+0x7a> @ imm = #0x8
; 		LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_TI);
 8009d24: 2110         	movs	r1, #0x10
 8009d26: 6b38         	ldr	r0, [r7, #0x30]
 8009d28: f00d fc75    	bl	0x8017616 <LL_SPI_SetStandard> @ imm = #0xd8ea
 8009d2c: e003         	b	0x8009d36 <spi_stm32_configure+0x82> @ imm = #0x6
; 		LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_MOTOROLA);
 8009d2e: 2100         	movs	r1, #0x0
 8009d30: 6b38         	ldr	r0, [r7, #0x30]
 8009d32: f00d fc70    	bl	0x8017616 <LL_SPI_SetStandard> @ imm = #0xd8e0
; 					   (clock_control_subsys_t) &cfg->pclken[0], &clock) < 0) {
 8009d36: 6bbb         	ldr	r3, [r7, #0x38]
 8009d38: 68db         	ldr	r3, [r3, #0xc]
; 		if (clock_control_get_rate(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 8009d3a: f107 020c    	add.w	r2, r7, #0xc
 8009d3e: 4619         	mov	r1, r3
 8009d40: 4870         	ldr	r0, [pc, #0x1c0]        @ 0x8009f04 <spi_stm32_configure+0x250>
 8009d42: f00d ff47    	bl	0x8017bd4 <clock_control_get_rate> @ imm = #0xde8e
 8009d46: 4603         	mov	r3, r0
 8009d48: 2b00         	cmp	r3, #0x0
 8009d4a: da1e         	bge	0x8009d8a <spi_stm32_configure+0xd6> @ imm = #0x3c
; 			LOG_ERR("Failed call clock_control_get_rate(pclk[0])");
 8009d4c: 2303         	movs	r3, #0x3
 8009d4e: 2b00         	cmp	r3, #0x0
 8009d50: d018         	beq	0x8009d84 <spi_stm32_configure+0xd0> @ imm = #0x30
 8009d52: 2301         	movs	r3, #0x1
 8009d54: f887 3053    	strb.w	r3, [r7, #0x53]
 8009d58: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8009d5c: f083 0301    	eor	r3, r3, #0x1
 8009d60: b2db         	uxtb	r3, r3
 8009d62: 2b00         	cmp	r3, #0x0
 8009d64: d10e         	bne	0x8009d84 <spi_stm32_configure+0xd0> @ imm = #0x1c
 8009d66: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8009f08 <spi_stm32_configure+0x254>
 8009d68: 6819         	ldr	r1, [r3]
 8009d6a: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8009f0c <spi_stm32_configure+0x258>
 8009d6c: 9302         	str	r3, [sp, #0x8]
 8009d6e: 2300         	movs	r3, #0x0
 8009d70: 9301         	str	r3, [sp, #0x4]
 8009d72: 2300         	movs	r3, #0x0
 8009d74: 9300         	str	r3, [sp]
 8009d76: 2300         	movs	r3, #0x0
 8009d78: 2201         	movs	r2, #0x1
 8009d7a: 2000         	movs	r0, #0x0
 8009d7c: f00d fba1    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xd742
 8009d80: 2300         	movs	r3, #0x0
 8009d82: 657b         	str	r3, [r7, #0x54]
; 			return -EIO;
 8009d84: f06f 0304    	mvn	r3, #0x4
 8009d88: e10d         	b	0x8009fa6 <spi_stm32_configure+0x2f2> @ imm = #0x21a
; 	for (br = 1 ; br <= ARRAY_SIZE(scaler) ; ++br) {
 8009d8a: 2301         	movs	r3, #0x1
 8009d8c: 643b         	str	r3, [r7, #0x40]
 8009d8e: e00c         	b	0x8009daa <spi_stm32_configure+0xf6> @ imm = #0x18
; 		uint32_t clk = clock >> br;
 8009d90: 68fa         	ldr	r2, [r7, #0xc]
 8009d92: 6c3b         	ldr	r3, [r7, #0x40]
 8009d94: fa22 f303    	lsr.w	r3, r2, r3
 8009d98: 63fb         	str	r3, [r7, #0x3c]
; 		if (clk <= config->frequency) {
 8009d9a: 683b         	ldr	r3, [r7]
 8009d9c: 681b         	ldr	r3, [r3]
 8009d9e: 6bfa         	ldr	r2, [r7, #0x3c]
 8009da0: 429a         	cmp	r2, r3
 8009da2: d906         	bls	0x8009db2 <spi_stm32_configure+0xfe> @ imm = #0xc
; 	for (br = 1 ; br <= ARRAY_SIZE(scaler) ; ++br) {
 8009da4: 6c3b         	ldr	r3, [r7, #0x40]
 8009da6: 3301         	adds	r3, #0x1
 8009da8: 643b         	str	r3, [r7, #0x40]
 8009daa: 6c3b         	ldr	r3, [r7, #0x40]
 8009dac: 2b08         	cmp	r3, #0x8
 8009dae: d9ef         	bls	0x8009d90 <spi_stm32_configure+0xdc> @ imm = #-0x22
 8009db0: e000         	b	0x8009db4 <spi_stm32_configure+0x100> @ imm = #0x0
; 			break;
 8009db2: bf00         	nop
; 	if (br > ARRAY_SIZE(scaler)) {
 8009db4: 6c3b         	ldr	r3, [r7, #0x40]
 8009db6: 2b08         	cmp	r3, #0x8
 8009db8: d928         	bls	0x8009e0c <spi_stm32_configure+0x158> @ imm = #0x50
; 		LOG_ERR("Unsupported frequency %uHz, max %uHz, min %uHz",
 8009dba: 2303         	movs	r3, #0x3
 8009dbc: 2b00         	cmp	r3, #0x0
 8009dbe: d022         	beq	0x8009e06 <spi_stm32_configure+0x152> @ imm = #0x44
 8009dc0: 2301         	movs	r3, #0x1
 8009dc2: f887 304b    	strb.w	r3, [r7, #0x4b]
 8009dc6: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8009dca: f083 0301    	eor	r3, r3, #0x1
 8009dce: b2db         	uxtb	r3, r3
 8009dd0: 2b00         	cmp	r3, #0x0
 8009dd2: d118         	bne	0x8009e06 <spi_stm32_configure+0x152> @ imm = #0x30
 8009dd4: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x8009f08 <spi_stm32_configure+0x254>
 8009dd6: 6818         	ldr	r0, [r3]
 8009dd8: 683b         	ldr	r3, [r7]
 8009dda: 681b         	ldr	r3, [r3]
 8009ddc: 68fa         	ldr	r2, [r7, #0xc]
 8009dde: 0852         	lsrs	r2, r2, #0x1
 8009de0: 68f9         	ldr	r1, [r7, #0xc]
 8009de2: 0a09         	lsrs	r1, r1, #0x8
 8009de4: 9105         	str	r1, [sp, #0x14]
 8009de6: 9204         	str	r2, [sp, #0x10]
 8009de8: 9303         	str	r3, [sp, #0xc]
 8009dea: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8009f10 <spi_stm32_configure+0x25c>
 8009dec: 9302         	str	r3, [sp, #0x8]
 8009dee: 2300         	movs	r3, #0x0
 8009df0: 9301         	str	r3, [sp, #0x4]
 8009df2: 2300         	movs	r3, #0x0
 8009df4: 9300         	str	r3, [sp]
 8009df6: 2300         	movs	r3, #0x0
 8009df8: 2201         	movs	r2, #0x1
 8009dfa: 4601         	mov	r1, r0
 8009dfc: 2000         	movs	r0, #0x0
 8009dfe: f00d fb60    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xd6c0
 8009e02: 2300         	movs	r3, #0x0
 8009e04: 647b         	str	r3, [r7, #0x44]
; 		return -EINVAL;
 8009e06: f06f 0315    	mvn	r3, #0x15
 8009e0a: e0cc         	b	0x8009fa6 <spi_stm32_configure+0x2f2> @ imm = #0x198
; 	LL_SPI_Disable(spi);
 8009e0c: 6b38         	ldr	r0, [r7, #0x30]
 8009e0e: f00d fbc2    	bl	0x8017596 <LL_SPI_Disable> @ imm = #0xd784
; 	LL_SPI_SetBaudRatePrescaler(spi, scaler[br - 1]);
 8009e12: 6c3b         	ldr	r3, [r7, #0x40]
 8009e14: 3b01         	subs	r3, #0x1
 8009e16: 009b         	lsls	r3, r3, #0x2
 8009e18: 3358         	adds	r3, #0x58
 8009e1a: 443b         	add	r3, r7
 8009e1c: f853 3c48    	ldr	r3, [r3, #-72]
 8009e20: 4619         	mov	r1, r3
 8009e22: 6b38         	ldr	r0, [r7, #0x30]
 8009e24: f00d fc2d    	bl	0x8017682 <LL_SPI_SetBaudRatePrescaler> @ imm = #0xd85a
; 	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPOL) {
 8009e28: 683b         	ldr	r3, [r7]
 8009e2a: 889b         	ldrh	r3, [r3, #0x4]
 8009e2c: f003 0302    	and	r3, r3, #0x2
 8009e30: 2b00         	cmp	r3, #0x0
 8009e32: d004         	beq	0x8009e3e <spi_stm32_configure+0x18a> @ imm = #0x8
; 		LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_HIGH);
 8009e34: 2102         	movs	r1, #0x2
 8009e36: 6b38         	ldr	r0, [r7, #0x30]
 8009e38: f00d fc11    	bl	0x801765e <LL_SPI_SetClockPolarity> @ imm = #0xd822
 8009e3c: e003         	b	0x8009e46 <spi_stm32_configure+0x192> @ imm = #0x6
; 		LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_LOW);
 8009e3e: 2100         	movs	r1, #0x0
 8009e40: 6b38         	ldr	r0, [r7, #0x30]
 8009e42: f00d fc0c    	bl	0x801765e <LL_SPI_SetClockPolarity> @ imm = #0xd818
; 	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPHA) {
 8009e46: 683b         	ldr	r3, [r7]
 8009e48: 889b         	ldrh	r3, [r3, #0x4]
 8009e4a: f003 0304    	and	r3, r3, #0x4
 8009e4e: 2b00         	cmp	r3, #0x0
 8009e50: d004         	beq	0x8009e5c <spi_stm32_configure+0x1a8> @ imm = #0x8
; 		LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_2EDGE);
 8009e52: 2101         	movs	r1, #0x1
 8009e54: 6b38         	ldr	r0, [r7, #0x30]
 8009e56: f00d fbf0    	bl	0x801763a <LL_SPI_SetClockPhase> @ imm = #0xd7e0
 8009e5a: e003         	b	0x8009e64 <spi_stm32_configure+0x1b0> @ imm = #0x6
; 		LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_1EDGE);
 8009e5c: 2100         	movs	r1, #0x0
 8009e5e: 6b38         	ldr	r0, [r7, #0x30]
 8009e60: f00d fbeb    	bl	0x801763a <LL_SPI_SetClockPhase> @ imm = #0xd7d6
; 	LL_SPI_SetTransferDirection(spi, LL_SPI_FULL_DUPLEX);
 8009e64: 2100         	movs	r1, #0x0
 8009e66: 6b38         	ldr	r0, [r7, #0x30]
 8009e68: f00d fc2f    	bl	0x80176ca <LL_SPI_SetTransferDirection> @ imm = #0xd85e
; 	if (config->operation & SPI_TRANSFER_LSB) {
 8009e6c: 683b         	ldr	r3, [r7]
 8009e6e: 889b         	ldrh	r3, [r3, #0x4]
 8009e70: f003 0310    	and	r3, r3, #0x10
 8009e74: 2b00         	cmp	r3, #0x0
 8009e76: d004         	beq	0x8009e82 <spi_stm32_configure+0x1ce> @ imm = #0x8
; 		LL_SPI_SetTransferBitOrder(spi, LL_SPI_LSB_FIRST);
 8009e78: 2180         	movs	r1, #0x80
 8009e7a: 6b38         	ldr	r0, [r7, #0x30]
 8009e7c: f00d fc13    	bl	0x80176a6 <LL_SPI_SetTransferBitOrder> @ imm = #0xd826
 8009e80: e003         	b	0x8009e8a <spi_stm32_configure+0x1d6> @ imm = #0x6
; 		LL_SPI_SetTransferBitOrder(spi, LL_SPI_MSB_FIRST);
 8009e82: 2100         	movs	r1, #0x0
 8009e84: 6b38         	ldr	r0, [r7, #0x30]
 8009e86: f00d fc0e    	bl	0x80176a6 <LL_SPI_SetTransferBitOrder> @ imm = #0xd81c
; 	LL_SPI_DisableCRC(spi);
 8009e8a: 6b38         	ldr	r0, [r7, #0x30]
 8009e8c: f00d fc41    	bl	0x8017712 <LL_SPI_DisableCRC> @ imm = #0xd882
; 	if (spi_cs_is_gpio(config) || !IS_ENABLED(CONFIG_SPI_STM32_USE_HW_SS)) {
 8009e90: 6838         	ldr	r0, [r7]
 8009e92: f00d fe42    	bl	0x8017b1a <spi_cs_is_gpio> @ imm = #0xdc84
 8009e96: 4603         	mov	r3, r0
 8009e98: 2b00         	cmp	r3, #0x0
 8009e9a: d005         	beq	0x8009ea8 <spi_stm32_configure+0x1f4> @ imm = #0xa
; 		LL_SPI_SetNSSMode(spi, LL_SPI_NSS_SOFT);
 8009e9c: f44f 7100    	mov.w	r1, #0x200
 8009ea0: 6b38         	ldr	r0, [r7, #0x30]
 8009ea2: f00d fc45    	bl	0x8017730 <LL_SPI_SetNSSMode> @ imm = #0xd88a
 8009ea6: e00f         	b	0x8009ec8 <spi_stm32_configure+0x214> @ imm = #0x1e
; 		if (config->operation & SPI_OP_MODE_SLAVE) {
 8009ea8: 683b         	ldr	r3, [r7]
 8009eaa: 889b         	ldrh	r3, [r3, #0x4]
 8009eac: f003 0301    	and	r3, r3, #0x1
 8009eb0: 2b00         	cmp	r3, #0x0
 8009eb2: d004         	beq	0x8009ebe <spi_stm32_configure+0x20a> @ imm = #0x8
; 			LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_INPUT);
 8009eb4: 2100         	movs	r1, #0x0
 8009eb6: 6b38         	ldr	r0, [r7, #0x30]
 8009eb8: f00d fc3a    	bl	0x8017730 <LL_SPI_SetNSSMode> @ imm = #0xd874
 8009ebc: e004         	b	0x8009ec8 <spi_stm32_configure+0x214> @ imm = #0x8
; 			LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_OUTPUT);
 8009ebe: f44f 2180    	mov.w	r1, #0x40000
 8009ec2: 6b38         	ldr	r0, [r7, #0x30]
 8009ec4: f00d fc34    	bl	0x8017730 <LL_SPI_SetNSSMode> @ imm = #0xd868
; 	if (config->operation & SPI_OP_MODE_SLAVE) {
 8009ec8: 683b         	ldr	r3, [r7]
 8009eca: 889b         	ldrh	r3, [r3, #0x4]
 8009ecc: f003 0301    	and	r3, r3, #0x1
 8009ed0: 2b00         	cmp	r3, #0x0
 8009ed2: d004         	beq	0x8009ede <spi_stm32_configure+0x22a> @ imm = #0x8
; 		LL_SPI_SetMode(spi, LL_SPI_MODE_SLAVE);
 8009ed4: 2100         	movs	r1, #0x0
 8009ed6: 6b38         	ldr	r0, [r7, #0x30]
 8009ed8: f00d fb7e    	bl	0x80175d8 <LL_SPI_SetMode> @ imm = #0xd6fc
 8009edc: e004         	b	0x8009ee8 <spi_stm32_configure+0x234> @ imm = #0x8
; 		LL_SPI_SetMode(spi, LL_SPI_MODE_MASTER);
 8009ede: f44f 7182    	mov.w	r1, #0x104
 8009ee2: 6b38         	ldr	r0, [r7, #0x30]
 8009ee4: f00d fb78    	bl	0x80175d8 <LL_SPI_SetMode> @ imm = #0xd6f0
; 	if (SPI_WORD_SIZE_GET(config->operation) ==  8) {
 8009ee8: 683b         	ldr	r3, [r7]
 8009eea: 889b         	ldrh	r3, [r3, #0x4]
 8009eec: 095b         	lsrs	r3, r3, #0x5
 8009eee: f003 033f    	and	r3, r3, #0x3f
 8009ef2: 2b08         	cmp	r3, #0x8
 8009ef4: d10e         	bne	0x8009f14 <spi_stm32_configure+0x260> @ imm = #0x1c
; 		LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_8BIT);
 8009ef6: 2100         	movs	r1, #0x0
 8009ef8: 6b38         	ldr	r0, [r7, #0x30]
 8009efa: f00d fbf8    	bl	0x80176ee <LL_SPI_SetDataWidth> @ imm = #0xd7f0
 8009efe: e00e         	b	0x8009f1e <spi_stm32_configure+0x26a> @ imm = #0x1c

08009f00 <$d>:
 8009f00: f0 c7 01 08  	.word	0x0801c7f0
 8009f04: d8 ac 01 08  	.word	0x0801acd8
 8009f08: 7c 04 00 20  	.word	0x2000047c
 8009f0c: 4c c7 01 08  	.word	0x0801c74c
 8009f10: 78 c7 01 08  	.word	0x0801c778

08009f14 <$t>:
; 		LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_16BIT);
 8009f14: f44f 6100    	mov.w	r1, #0x800
 8009f18: 6b38         	ldr	r0, [r7, #0x30]
 8009f1a: f00d fbe8    	bl	0x80176ee <LL_SPI_SetDataWidth> @ imm = #0xd7d0
; 	data->ctx.config = config;
 8009f1e: 6b7b         	ldr	r3, [r7, #0x34]
 8009f20: 683a         	ldr	r2, [r7]
 8009f22: 601a         	str	r2, [r3]
; 	LOG_DBG("Installed config %p: freq %uHz (div = %u),"
 8009f24: 2303         	movs	r3, #0x3
 8009f26: 2b03         	cmp	r3, #0x3
 8009f28: d93c         	bls	0x8009fa4 <spi_stm32_configure+0x2f0> @ imm = #0x78
 8009f2a: 2301         	movs	r3, #0x1
 8009f2c: f887 3052    	strb.w	r3, [r7, #0x52]
 8009f30: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8009f34: f083 0301    	eor	r3, r3, #0x1
 8009f38: b2db         	uxtb	r3, r3
 8009f3a: 2b00         	cmp	r3, #0x0
 8009f3c: d132         	bne	0x8009fa4 <spi_stm32_configure+0x2f0> @ imm = #0x64
 8009f3e: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8009fb0 <spi_stm32_configure+0x2fc>
 8009f40: 681e         	ldr	r6, [r3]
 8009f42: 68fa         	ldr	r2, [r7, #0xc]
 8009f44: 6c3b         	ldr	r3, [r7, #0x40]
 8009f46: fa22 f303    	lsr.w	r3, r2, r3
 8009f4a: 2101         	movs	r1, #0x1
 8009f4c: 6c3a         	ldr	r2, [r7, #0x40]
 8009f4e: fa01 f202    	lsl.w	r2, r1, r2
 8009f52: 6839         	ldr	r1, [r7]
 8009f54: 8889         	ldrh	r1, [r1, #0x4]
 8009f56: 0849         	lsrs	r1, r1, #0x1
 8009f58: f001 0101    	and	r1, r1, #0x1
 8009f5c: 6838         	ldr	r0, [r7]
 8009f5e: 8880         	ldrh	r0, [r0, #0x4]
 8009f60: 0880         	lsrs	r0, r0, #0x2
 8009f62: f000 0001    	and	r0, r0, #0x1
 8009f66: 683c         	ldr	r4, [r7]
 8009f68: 88a4         	ldrh	r4, [r4, #0x4]
 8009f6a: 08e4         	lsrs	r4, r4, #0x3
 8009f6c: f004 0401    	and	r4, r4, #0x1
 8009f70: 683d         	ldr	r5, [r7]
 8009f72: 88ed         	ldrh	r5, [r5, #0x6]
 8009f74: 950a         	str	r5, [sp, #0x28]
 8009f76: 9409         	str	r4, [sp, #0x24]
 8009f78: 9008         	str	r0, [sp, #0x20]
 8009f7a: 9107         	str	r1, [sp, #0x1c]
 8009f7c: 9206         	str	r2, [sp, #0x18]
 8009f7e: 9305         	str	r3, [sp, #0x14]
 8009f80: 683b         	ldr	r3, [r7]
 8009f82: 9304         	str	r3, [sp, #0x10]
 8009f84: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8009fb4 <spi_stm32_configure+0x300>
 8009f86: 9303         	str	r3, [sp, #0xc]
 8009f88: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8009fb8 <spi_stm32_configure+0x304>
 8009f8a: 9302         	str	r3, [sp, #0x8]
 8009f8c: 2308         	movs	r3, #0x8
 8009f8e: 9301         	str	r3, [sp, #0x4]
 8009f90: 2300         	movs	r3, #0x0
 8009f92: 9300         	str	r3, [sp]
 8009f94: 2300         	movs	r3, #0x0
 8009f96: 2204         	movs	r2, #0x4
 8009f98: 4631         	mov	r1, r6
 8009f9a: 2000         	movs	r0, #0x0
 8009f9c: f00d fa91    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xd522
 8009fa0: 2300         	movs	r3, #0x0
 8009fa2: 64fb         	str	r3, [r7, #0x4c]
; 	return 0;
 8009fa4: 2300         	movs	r3, #0x0
; }
 8009fa6: 4618         	mov	r0, r3
 8009fa8: 375c         	adds	r7, #0x5c
 8009faa: 46bd         	mov	sp, r7
 8009fac: bdf0         	pop	{r4, r5, r6, r7, pc}
 8009fae: bf00         	nop

08009fb0 <$d>:
 8009fb0: 7c 04 00 20  	.word	0x2000047c
 8009fb4: 90 d7 01 08  	.word	0x0801d790
 8009fb8: a8 c7 01 08  	.word	0x0801c7a8

08009fbc <spi_stm32_init>:
; {
 8009fbc: b580         	push	{r7, lr}
 8009fbe: b090         	sub	sp, #0x40
 8009fc0: af04         	add	r7, sp, #0x10
 8009fc2: 6078         	str	r0, [r7, #0x4]
; 	struct spi_stm32_data *data __attribute__((unused)) = dev->data;
 8009fc4: 687b         	ldr	r3, [r7, #0x4]
 8009fc6: 691b         	ldr	r3, [r3, #0x10]
 8009fc8: 627b         	str	r3, [r7, #0x24]
; 	const struct spi_stm32_config *cfg = dev->config;
 8009fca: 687b         	ldr	r3, [r7, #0x4]
 8009fcc: 685b         	ldr	r3, [r3, #0x4]
 8009fce: 62bb         	str	r3, [r7, #0x28]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 8009fd0: 484a         	ldr	r0, [pc, #0x128]        @ 0x800a0fc <spi_stm32_init+0x140>
 8009fd2: f00d fa6a    	bl	0x80174aa <device_is_ready> @ imm = #0xd4d4
 8009fd6: 4603         	mov	r3, r0
 8009fd8: f083 0301    	eor	r3, r3, #0x1
 8009fdc: b2db         	uxtb	r3, r3
 8009fde: 2b00         	cmp	r3, #0x0
 8009fe0: d01c         	beq	0x800a01c <spi_stm32_init+0x60> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 8009fe2: 2303         	movs	r3, #0x3
 8009fe4: 2b00         	cmp	r3, #0x0
 8009fe6: d016         	beq	0x800a016 <spi_stm32_init+0x5a> @ imm = #0x2c
 8009fe8: 2301         	movs	r3, #0x1
 8009fea: 74fb         	strb	r3, [r7, #0x13]
 8009fec: 7cfb         	ldrb	r3, [r7, #0x13]
 8009fee: f083 0301    	eor	r3, r3, #0x1
 8009ff2: b2db         	uxtb	r3, r3
 8009ff4: 2b00         	cmp	r3, #0x0
 8009ff6: d10e         	bne	0x800a016 <spi_stm32_init+0x5a> @ imm = #0x1c
 8009ff8: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800a100 <spi_stm32_init+0x144>
 8009ffa: 6819         	ldr	r1, [r3]
 8009ffc: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800a104 <spi_stm32_init+0x148>
 8009ffe: 9302         	str	r3, [sp, #0x8]
 800a000: 2300         	movs	r3, #0x0
 800a002: 9301         	str	r3, [sp, #0x4]
 800a004: 2300         	movs	r3, #0x0
 800a006: 9300         	str	r3, [sp]
 800a008: 2300         	movs	r3, #0x0
 800a00a: 2201         	movs	r2, #0x1
 800a00c: 2000         	movs	r0, #0x0
 800a00e: f00d fa58    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xd4b0
 800a012: 2300         	movs	r3, #0x0
 800a014: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800a016: f06f 0312    	mvn	r3, #0x12
 800a01a: e06a         	b	0x800a0f2 <spi_stm32_init+0x136> @ imm = #0xd4
; 			       (clock_control_subsys_t) &cfg->pclken[0]);
 800a01c: 6abb         	ldr	r3, [r7, #0x28]
 800a01e: 68db         	ldr	r3, [r3, #0xc]
; 	err = clock_control_on(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 800a020: 4619         	mov	r1, r3
 800a022: 4836         	ldr	r0, [pc, #0xd8]         @ 0x800a0fc <spi_stm32_init+0x140>
 800a024: f00d fdc4    	bl	0x8017bb0 <clock_control_on> @ imm = #0xdb88
 800a028: 62f8         	str	r0, [r7, #0x2c]
; 	if (err < 0) {
 800a02a: 6afb         	ldr	r3, [r7, #0x2c]
 800a02c: 2b00         	cmp	r3, #0x0
 800a02e: da1b         	bge	0x800a068 <spi_stm32_init+0xac> @ imm = #0x36
; 		LOG_ERR("Could not enable SPI clock");
 800a030: 2303         	movs	r3, #0x3
 800a032: 2b00         	cmp	r3, #0x0
 800a034: d016         	beq	0x800a064 <spi_stm32_init+0xa8> @ imm = #0x2c
 800a036: 2301         	movs	r3, #0x1
 800a038: 76fb         	strb	r3, [r7, #0x1b]
 800a03a: 7efb         	ldrb	r3, [r7, #0x1b]
 800a03c: f083 0301    	eor	r3, r3, #0x1
 800a040: b2db         	uxtb	r3, r3
 800a042: 2b00         	cmp	r3, #0x0
 800a044: d10e         	bne	0x800a064 <spi_stm32_init+0xa8> @ imm = #0x1c
 800a046: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x800a100 <spi_stm32_init+0x144>
 800a048: 6819         	ldr	r1, [r3]
 800a04a: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800a108 <spi_stm32_init+0x14c>
 800a04c: 9302         	str	r3, [sp, #0x8]
 800a04e: 2300         	movs	r3, #0x0
 800a050: 9301         	str	r3, [sp, #0x4]
 800a052: 2300         	movs	r3, #0x0
 800a054: 9300         	str	r3, [sp]
 800a056: 2300         	movs	r3, #0x0
 800a058: 2201         	movs	r2, #0x1
 800a05a: 2000         	movs	r0, #0x0
 800a05c: f00d fa31    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xd462
 800a060: 2300         	movs	r3, #0x0
 800a062: 617b         	str	r3, [r7, #0x14]
; 		return err;
 800a064: 6afb         	ldr	r3, [r7, #0x2c]
 800a066: e044         	b	0x800a0f2 <spi_stm32_init+0x136> @ imm = #0x88
; 	if (!spi_stm32_is_subghzspi(dev)) {
 800a068: 6878         	ldr	r0, [r7, #0x4]
 800a06a: f00e f89c    	bl	0x80181a6 <spi_stm32_is_subghzspi> @ imm = #0xe138
 800a06e: 4603         	mov	r3, r0
 800a070: f083 0301    	eor	r3, r3, #0x1
 800a074: b2db         	uxtb	r3, r3
 800a076: 2b00         	cmp	r3, #0x0
 800a078: d029         	beq	0x800a0ce <spi_stm32_init+0x112> @ imm = #0x52
; 		err = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
 800a07a: 6abb         	ldr	r3, [r7, #0x28]
 800a07c: 685b         	ldr	r3, [r3, #0x4]
 800a07e: 2100         	movs	r1, #0x0
 800a080: 4618         	mov	r0, r3
 800a082: f00d fd6e    	bl	0x8017b62 <pinctrl_apply_state> @ imm = #0xdadc
 800a086: 62f8         	str	r0, [r7, #0x2c]
; 		if (err < 0) {
 800a088: 6afb         	ldr	r3, [r7, #0x2c]
 800a08a: 2b00         	cmp	r3, #0x0
 800a08c: da1f         	bge	0x800a0ce <spi_stm32_init+0x112> @ imm = #0x3e
; 			LOG_ERR("SPI pinctrl setup failed (%d)", err);
 800a08e: 2303         	movs	r3, #0x3
 800a090: 2b00         	cmp	r3, #0x0
 800a092: d01a         	beq	0x800a0ca <spi_stm32_init+0x10e> @ imm = #0x34
 800a094: 2301         	movs	r3, #0x1
 800a096: f887 3023    	strb.w	r3, [r7, #0x23]
 800a09a: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800a09e: f083 0301    	eor	r3, r3, #0x1
 800a0a2: b2db         	uxtb	r3, r3
 800a0a4: 2b00         	cmp	r3, #0x0
 800a0a6: d110         	bne	0x800a0ca <spi_stm32_init+0x10e> @ imm = #0x20
 800a0a8: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800a100 <spi_stm32_init+0x144>
 800a0aa: 6819         	ldr	r1, [r3]
 800a0ac: 6afb         	ldr	r3, [r7, #0x2c]
 800a0ae: 9303         	str	r3, [sp, #0xc]
 800a0b0: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800a10c <spi_stm32_init+0x150>
 800a0b2: 9302         	str	r3, [sp, #0x8]
 800a0b4: 2300         	movs	r3, #0x0
 800a0b6: 9301         	str	r3, [sp, #0x4]
 800a0b8: 2300         	movs	r3, #0x0
 800a0ba: 9300         	str	r3, [sp]
 800a0bc: 2300         	movs	r3, #0x0
 800a0be: 2201         	movs	r2, #0x1
 800a0c0: 2000         	movs	r0, #0x0
 800a0c2: f00d f9fe    	bl	0x80174c2 <z_log_msg_runtime_create> @ imm = #0xd3fc
 800a0c6: 2300         	movs	r3, #0x0
 800a0c8: 61fb         	str	r3, [r7, #0x1c]
; 			return err;
 800a0ca: 6afb         	ldr	r3, [r7, #0x2c]
 800a0cc: e011         	b	0x800a0f2 <spi_stm32_init+0x136> @ imm = #0x22
; 	err = spi_context_cs_configure_all(&data->ctx);
 800a0ce: 6a7b         	ldr	r3, [r7, #0x24]
 800a0d0: 4618         	mov	r0, r3
 800a0d2: f7fe ff07    	bl	0x8008ee4 <spi_context_cs_configure_all> @ imm = #-0x11f2
 800a0d6: 62f8         	str	r0, [r7, #0x2c]
; 	if (err < 0) {
 800a0d8: 6afb         	ldr	r3, [r7, #0x2c]
 800a0da: 2b00         	cmp	r3, #0x0
 800a0dc: da01         	bge	0x800a0e2 <spi_stm32_init+0x126> @ imm = #0x2
; 		return err;
 800a0de: 6afb         	ldr	r3, [r7, #0x2c]
 800a0e0: e007         	b	0x800a0f2 <spi_stm32_init+0x136> @ imm = #0xe
; 	spi_context_unlock_unconditionally(&data->ctx);
 800a0e2: 6a7b         	ldr	r3, [r7, #0x24]
 800a0e4: 4618         	mov	r0, r3
 800a0e6: f00d fe3a    	bl	0x8017d5e <spi_context_unlock_unconditionally> @ imm = #0xdc74
; 	return pm_device_runtime_enable(dev);
 800a0ea: 6878         	ldr	r0, [r7, #0x4]
 800a0ec: f00d fd56    	bl	0x8017b9c <pm_device_runtime_enable> @ imm = #0xdaac
 800a0f0: 4603         	mov	r3, r0
; }
 800a0f2: 4618         	mov	r0, r3
 800a0f4: 3730         	adds	r7, #0x30
 800a0f6: 46bd         	mov	sp, r7
 800a0f8: bd80         	pop	{r7, pc}
 800a0fa: bf00         	nop

0800a0fc <$d>:
 800a0fc: d8 ac 01 08  	.word	0x0801acd8
 800a100: 7c 04 00 20  	.word	0x2000047c
 800a104: 10 c8 01 08  	.word	0x0801c810
 800a108: 30 c8 01 08  	.word	0x0801c830
 800a10c: 4c c8 01 08  	.word	0x0801c84c

0800a110 <__NVIC_SetPriority>:
; {
 800a110: b480         	push	{r7}
 800a112: b083         	sub	sp, #0xc
 800a114: af00         	add	r7, sp, #0x0
 800a116: 4603         	mov	r3, r0
 800a118: 6039         	str	r1, [r7]
 800a11a: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 800a11c: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800a120: 2b00         	cmp	r3, #0x0
 800a122: db0a         	blt	0x800a13a <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800a124: 683b         	ldr	r3, [r7]
 800a126: b2da         	uxtb	r2, r3
 800a128: 490c         	ldr	r1, [pc, #0x30]         @ 0x800a15c <__NVIC_SetPriority+0x4c>
 800a12a: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800a12e: 0112         	lsls	r2, r2, #0x4
 800a130: b2d2         	uxtb	r2, r2
 800a132: 440b         	add	r3, r1
 800a134: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 800a138: e00a         	b	0x800a150 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800a13a: 683b         	ldr	r3, [r7]
 800a13c: b2da         	uxtb	r2, r3
 800a13e: 4908         	ldr	r1, [pc, #0x20]         @ 0x800a160 <__NVIC_SetPriority+0x50>
 800a140: 79fb         	ldrb	r3, [r7, #0x7]
 800a142: f003 030f    	and	r3, r3, #0xf
 800a146: 3b04         	subs	r3, #0x4
 800a148: 0112         	lsls	r2, r2, #0x4
 800a14a: b2d2         	uxtb	r2, r2
 800a14c: 440b         	add	r3, r1
 800a14e: 761a         	strb	r2, [r3, #0x18]
; }
 800a150: bf00         	nop
 800a152: 370c         	adds	r7, #0xc
 800a154: 46bd         	mov	sp, r7
 800a156: bc80         	pop	{r7}
 800a158: 4770         	bx	lr
 800a15a: bf00         	nop

0800a15c <$d>:
 800a15c: 00 e1 00 e0  	.word	0xe000e100
 800a160: 00 ed 00 e0  	.word	0xe000ed00

0800a164 <elapsed>:
; {
 800a164: b480         	push	{r7}
 800a166: b085         	sub	sp, #0x14
 800a168: af00         	add	r7, sp, #0x0
; 	uint32_t val1 = SysTick->VAL;	/* A */
 800a16a: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800a1d0 <elapsed+0x6c>
 800a16c: 689b         	ldr	r3, [r3, #0x8]
 800a16e: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ctrl = SysTick->CTRL;	/* B */
 800a170: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800a1d0 <elapsed+0x6c>
 800a172: 681b         	ldr	r3, [r3]
 800a174: 607b         	str	r3, [r7, #0x4]
; 	uint32_t val2 = SysTick->VAL;	/* C */
 800a176: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800a1d0 <elapsed+0x6c>
 800a178: 689b         	ldr	r3, [r3, #0x8]
 800a17a: 60bb         	str	r3, [r7, #0x8]
; 	if (val1 == 0) {
 800a17c: 68fb         	ldr	r3, [r7, #0xc]
 800a17e: 2b00         	cmp	r3, #0x0
 800a180: d102         	bne	0x800a188 <elapsed+0x24> @ imm = #0x4
; 		val1 = last_load;
 800a182: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800a1d4 <elapsed+0x70>
 800a184: 681b         	ldr	r3, [r3]
 800a186: 60fb         	str	r3, [r7, #0xc]
; 	if (val2 == 0) {
 800a188: 68bb         	ldr	r3, [r7, #0x8]
 800a18a: 2b00         	cmp	r3, #0x0
 800a18c: d102         	bne	0x800a194 <elapsed+0x30> @ imm = #0x4
; 		val2 = last_load;
 800a18e: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800a1d4 <elapsed+0x70>
 800a190: 681b         	ldr	r3, [r3]
 800a192: 60bb         	str	r3, [r7, #0x8]
; 	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
 800a194: 687b         	ldr	r3, [r7, #0x4]
 800a196: f403 3380    	and	r3, r3, #0x10000
 800a19a: 2b00         	cmp	r3, #0x0
 800a19c: d103         	bne	0x800a1a6 <elapsed+0x42> @ imm = #0x6
; 	    || (val1 < val2)) {
 800a19e: 68fa         	ldr	r2, [r7, #0xc]
 800a1a0: 68bb         	ldr	r3, [r7, #0x8]
 800a1a2: 429a         	cmp	r2, r3
 800a1a4: d208         	bhs	0x800a1b8 <elapsed+0x54> @ imm = #0x10
; 		overflow_cyc += last_load;
 800a1a6: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800a1d8 <elapsed+0x74>
 800a1a8: 681a         	ldr	r2, [r3]
 800a1aa: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800a1d4 <elapsed+0x70>
 800a1ac: 681b         	ldr	r3, [r3]
 800a1ae: 4413         	add	r3, r2
 800a1b0: 4a09         	ldr	r2, [pc, #0x24]         @ 0x800a1d8 <elapsed+0x74>
 800a1b2: 6013         	str	r3, [r2]
; 		(void)SysTick->CTRL;
 800a1b4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a1d0 <elapsed+0x6c>
 800a1b6: 681b         	ldr	r3, [r3]
; 	return (last_load - val2) + overflow_cyc;
 800a1b8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a1d4 <elapsed+0x70>
 800a1ba: 681a         	ldr	r2, [r3]
 800a1bc: 68bb         	ldr	r3, [r7, #0x8]
 800a1be: 1ad2         	subs	r2, r2, r3
 800a1c0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a1d8 <elapsed+0x74>
 800a1c2: 681b         	ldr	r3, [r3]
 800a1c4: 4413         	add	r3, r2
; }
 800a1c6: 4618         	mov	r0, r3
 800a1c8: 3714         	adds	r7, #0x14
 800a1ca: 46bd         	mov	sp, r7
 800a1cc: bc80         	pop	{r7}
 800a1ce: 4770         	bx	lr

0800a1d0 <$d>:
 800a1d0: 10 e0 00 e0  	.word	0xe000e010
 800a1d4: 74 10 00 20  	.word	0x20001074
 800a1d8: 78 10 00 20  	.word	0x20001078

0800a1dc <sys_clock_isr>:
; {
 800a1dc: 4668         	mov	r0, sp
 800a1de: f020 0107    	bic	r1, r0, #0x7
 800a1e2: 468d         	mov	sp, r1
 800a1e4: e92d 4fb1    	push.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 800a1e8: b085         	sub	sp, #0x14
 800a1ea: af00         	add	r7, sp, #0x0
; 	elapsed();
 800a1ec: f7ff ffba    	bl	0x800a164 <elapsed>     @ imm = #-0x8c
; 	cycle_count += overflow_cyc;
 800a1f0: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800a27c <sys_clock_isr+0xa0>
 800a1f2: 681b         	ldr	r3, [r3]
 800a1f4: 2200         	movs	r2, #0x0
 800a1f6: 4698         	mov	r8, r3
 800a1f8: 4691         	mov	r9, r2
 800a1fa: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800a280 <sys_clock_isr+0xa4>
 800a1fc: e9d3 2300    	ldrd	r2, r3, [r3]
 800a200: eb18 0102    	adds.w	r1, r8, r2
 800a204: 6039         	str	r1, [r7]
 800a206: eb49 0303    	adc.w	r3, r9, r3
 800a20a: 607b         	str	r3, [r7, #0x4]
 800a20c: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800a280 <sys_clock_isr+0xa4>
 800a20e: e9d7 1200    	ldrd	r1, r2, [r7]
 800a212: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0;
 800a216: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800a27c <sys_clock_isr+0xa0>
 800a218: 2200         	movs	r2, #0x0
 800a21a: 601a         	str	r2, [r3]
; 		dcycles = cycle_count - announced_cycles;
 800a21c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800a280 <sys_clock_isr+0xa4>
 800a21e: e9d3 2300    	ldrd	r2, r3, [r3]
 800a222: 4611         	mov	r1, r2
 800a224: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800a284 <sys_clock_isr+0xa8>
 800a226: e9d3 2300    	ldrd	r2, r3, [r3]
 800a22a: 4613         	mov	r3, r2
 800a22c: 1acb         	subs	r3, r1, r3
 800a22e: 60fb         	str	r3, [r7, #0xc]
; 		dticks = dcycles / CYC_PER_TICK;
 800a230: 68fb         	ldr	r3, [r7, #0xc]
 800a232: 4a15         	ldr	r2, [pc, #0x54]         @ 0x800a288 <sys_clock_isr+0xac>
 800a234: fba2 2303    	umull	r2, r3, r2, r3
 800a238: 0b9b         	lsrs	r3, r3, #0xe
 800a23a: 60bb         	str	r3, [r7, #0x8]
; 		announced_cycles += dticks * CYC_PER_TICK;
 800a23c: 68bb         	ldr	r3, [r7, #0x8]
 800a23e: f244 12a0    	movw	r2, #0x41a0
 800a242: fb02 f303    	mul	r3, r2, r3
 800a246: 2200         	movs	r2, #0x0
 800a248: 461c         	mov	r4, r3
 800a24a: 4615         	mov	r5, r2
 800a24c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800a284 <sys_clock_isr+0xa8>
 800a24e: e9d3 2300    	ldrd	r2, r3, [r3]
 800a252: eb14 0a02    	adds.w	r10, r4, r2
 800a256: eb45 0b03    	adc.w	r11, r5, r3
 800a25a: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800a284 <sys_clock_isr+0xa8>
 800a25c: e9c3 ab00    	strd	r10, r11, [r3]
; 		sys_clock_announce(dticks);
 800a260: 68bb         	ldr	r3, [r7, #0x8]
 800a262: 4618         	mov	r0, r3
 800a264: f005 fbc6    	bl	0x800f9f4 <sys_clock_announce> @ imm = #0x578c
; 	z_arm_int_exit();
 800a268: f7f8 fa02    	bl	0x8002670 <z_arm_int_exit> @ imm = #-0x7bfc
; }
 800a26c: bf00         	nop
 800a26e: 3714         	adds	r7, #0x14
 800a270: 46bd         	mov	sp, r7
 800a272: e8bd 4fb1    	pop.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 800a276: 4685         	mov	sp, r0
 800a278: 4770         	bx	lr
 800a27a: bf00         	nop

0800a27c <$d>:
 800a27c: 78 10 00 20  	.word	0x20001078
 800a280: 30 06 00 20  	.word	0x20000630
 800a284: 38 06 00 20  	.word	0x20000638
 800a288: 2d 34 a9 f9  	.word	0xf9a9342d

0800a28c <sys_clock_set_timeout>:
; {
 800a28c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800a290: b09a         	sub	sp, #0x68
 800a292: af00         	add	r7, sp, #0x0
 800a294: 61f8         	str	r0, [r7, #0x1c]
 800a296: 460b         	mov	r3, r1
 800a298: 76fb         	strb	r3, [r7, #0x1b]
; 	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
 800a29a: 7efb         	ldrb	r3, [r7, #0x1b]
 800a29c: 2b00         	cmp	r3, #0x0
 800a29e: d00e         	beq	0x800a2be <sys_clock_set_timeout+0x32> @ imm = #0x1c
 800a2a0: 69fb         	ldr	r3, [r7, #0x1c]
 800a2a2: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800a2a6: d10a         	bne	0x800a2be <sys_clock_set_timeout+0x32> @ imm = #0x14
; 		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
 800a2a8: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x800a474 <sys_clock_set_timeout+0x1e8>
 800a2aa: 681b         	ldr	r3, [r3]
 800a2ac: 4a71         	ldr	r2, [pc, #0x1c4]        @ 0x800a474 <sys_clock_set_timeout+0x1e8>
 800a2ae: f023 0301    	bic	r3, r3, #0x1
 800a2b2: 6013         	str	r3, [r2]
; 		last_load = TIMER_STOPPED;
 800a2b4: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x800a478 <sys_clock_set_timeout+0x1ec>
 800a2b6: f04f 427f    	mov.w	r2, #0xff000000
 800a2ba: 601a         	str	r2, [r3]
 800a2bc: e0d6         	b	0x800a46c <sys_clock_set_timeout+0x1e0> @ imm = #0x1ac
; 	uint32_t last_load_ = last_load;
 800a2be: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x800a478 <sys_clock_set_timeout+0x1ec>
 800a2c0: 681b         	ldr	r3, [r3]
 800a2c2: 667b         	str	r3, [r7, #0x64]
; 	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 800a2c4: 69fb         	ldr	r3, [r7, #0x1c]
 800a2c6: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800a2ca: d001         	beq	0x800a2d0 <sys_clock_set_timeout+0x44> @ imm = #0x2
 800a2cc: 69fb         	ldr	r3, [r7, #0x1c]
 800a2ce: e001         	b	0x800a2d4 <sys_clock_set_timeout+0x48> @ imm = #0x2
 800a2d0: f240 33e5    	movw	r3, #0x3e5
 800a2d4: 61fb         	str	r3, [r7, #0x1c]
; 	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
 800a2d6: 69fb         	ldr	r3, [r7, #0x1c]
 800a2d8: 2b01         	cmp	r3, #0x1
 800a2da: dd07         	ble	0x800a2ec <sys_clock_set_timeout+0x60> @ imm = #0xe
 800a2dc: 69fb         	ldr	r3, [r7, #0x1c]
 800a2de: f240 32e6    	movw	r2, #0x3e6
 800a2e2: 4293         	cmp	r3, r2
 800a2e4: bfa8         	it	ge
 800a2e6: 4613         	movge	r3, r2
 800a2e8: 3b01         	subs	r3, #0x1
 800a2ea: e000         	b	0x800a2ee <sys_clock_set_timeout+0x62> @ imm = #0x0
 800a2ec: 2300         	movs	r3, #0x0
 800a2ee: 61fb         	str	r3, [r7, #0x1c]
 800a2f0: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800a47c <sys_clock_set_timeout+0x1f0>
 800a2f2: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a2f4: f3ef 8311    	mrs	r3, basepri
 800a2f8: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800a2fa: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 800a2fc: 647b         	str	r3, [r7, #0x44]
 800a2fe: 2310         	movs	r3, #0x10
 800a300: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800a302: 6c3b         	ldr	r3, [r7, #0x40]
 800a304: f383 8812    	msr	basepri_max, r3
; }
 800a308: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a30a: f3bf 8f6f    	isb	sy
; }
 800a30e: bf00         	nop
; 	return key;
 800a310: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 800a312: 623b         	str	r3, [r7, #0x20]
 800a314: 6cfb         	ldr	r3, [r7, #0x4c]
 800a316: 63fb         	str	r3, [r7, #0x3c]
; }
 800a318: bf00         	nop
 800a31a: 6cfb         	ldr	r3, [r7, #0x4c]
 800a31c: 63bb         	str	r3, [r7, #0x38]
; }
 800a31e: bf00         	nop
; 	return k;
 800a320: 6a3b         	ldr	r3, [r7, #0x20]
 800a322: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pending = elapsed();
 800a324: f7ff ff1e    	bl	0x800a164 <elapsed>     @ imm = #-0x1c4
 800a328: 6638         	str	r0, [r7, #0x60]
; 	val1 = SysTick->VAL;
 800a32a: 4b52         	ldr	r3, [pc, #0x148]        @ 0x800a474 <sys_clock_set_timeout+0x1e8>
 800a32c: 689b         	ldr	r3, [r3, #0x8]
 800a32e: 65fb         	str	r3, [r7, #0x5c]
; 	cycle_count += pending;
 800a330: 6e3b         	ldr	r3, [r7, #0x60]
 800a332: 2200         	movs	r2, #0x0
 800a334: 469a         	mov	r10, r3
 800a336: 4693         	mov	r11, r2
 800a338: 4b51         	ldr	r3, [pc, #0x144]        @ 0x800a480 <sys_clock_set_timeout+0x1f4>
 800a33a: e9d3 2300    	ldrd	r2, r3, [r3]
 800a33e: eb1a 0102    	adds.w	r1, r10, r2
 800a342: 6139         	str	r1, [r7, #0x10]
 800a344: eb4b 0303    	adc.w	r3, r11, r3
 800a348: 617b         	str	r3, [r7, #0x14]
 800a34a: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800a480 <sys_clock_set_timeout+0x1f4>
 800a34c: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 800a350: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0U;
 800a354: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800a484 <sys_clock_set_timeout+0x1f8>
 800a356: 2200         	movs	r2, #0x0
 800a358: 601a         	str	r2, [r3]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 800a35a: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800a480 <sys_clock_set_timeout+0x1f4>
 800a35c: e9d3 2300    	ldrd	r2, r3, [r3]
 800a360: 4611         	mov	r1, r2
 800a362: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800a488 <sys_clock_set_timeout+0x1fc>
 800a364: e9d3 2300    	ldrd	r2, r3, [r3]
 800a368: 4613         	mov	r3, r2
 800a36a: 1acb         	subs	r3, r1, r3
 800a36c: 65bb         	str	r3, [r7, #0x58]
; 	if ((int32_t)unannounced < 0) {
 800a36e: 6dbb         	ldr	r3, [r7, #0x58]
 800a370: 2b00         	cmp	r3, #0x0
 800a372: da04         	bge	0x800a37e <sys_clock_set_timeout+0xf2> @ imm = #0x8
; 		last_load = MIN_DELAY;
 800a374: 4b40         	ldr	r3, [pc, #0x100]        @ 0x800a478 <sys_clock_set_timeout+0x1ec>
 800a376: f240 421a    	movw	r2, #0x41a
 800a37a: 601a         	str	r2, [r3]
 800a37c: e02c         	b	0x800a3d8 <sys_clock_set_timeout+0x14c> @ imm = #0x58
; 		delay = ticks * CYC_PER_TICK;
 800a37e: 69fb         	ldr	r3, [r7, #0x1c]
 800a380: f244 12a0    	movw	r2, #0x41a0
 800a384: fb02 f303    	mul	r3, r2, r3
 800a388: 657b         	str	r3, [r7, #0x54]
; 		delay += unannounced;
 800a38a: 6d7a         	ldr	r2, [r7, #0x54]
 800a38c: 6dbb         	ldr	r3, [r7, #0x58]
 800a38e: 4413         	add	r3, r2
 800a390: 657b         	str	r3, [r7, #0x54]
; 		delay = DIV_ROUND_UP(delay, CYC_PER_TICK) * CYC_PER_TICK;
 800a392: 6d7b         	ldr	r3, [r7, #0x54]
 800a394: f503 4383    	add.w	r3, r3, #0x4180
 800a398: 331f         	adds	r3, #0x1f
 800a39a: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x800a48c <sys_clock_set_timeout+0x200>
 800a39c: fba2 2303    	umull	r2, r3, r2, r3
 800a3a0: 0b9b         	lsrs	r3, r3, #0xe
 800a3a2: f244 12a0    	movw	r2, #0x41a0
 800a3a6: fb02 f303    	mul	r3, r2, r3
 800a3aa: 657b         	str	r3, [r7, #0x54]
; 		delay -= unannounced;
 800a3ac: 6d7a         	ldr	r2, [r7, #0x54]
 800a3ae: 6dbb         	ldr	r3, [r7, #0x58]
 800a3b0: 1ad3         	subs	r3, r2, r3
 800a3b2: 657b         	str	r3, [r7, #0x54]
; 		delay = MAX(delay, MIN_DELAY);
 800a3b4: 6d7b         	ldr	r3, [r7, #0x54]
 800a3b6: f240 421a    	movw	r2, #0x41a
 800a3ba: 4293         	cmp	r3, r2
 800a3bc: bf38         	it	lo
 800a3be: 4613         	movlo	r3, r2
 800a3c0: 657b         	str	r3, [r7, #0x54]
; 		if (delay > MAX_CYCLES) {
 800a3c2: 6d7b         	ldr	r3, [r7, #0x54]
 800a3c4: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x800a490 <sys_clock_set_timeout+0x204>
 800a3c6: 4293         	cmp	r3, r2
 800a3c8: d903         	bls	0x800a3d2 <sys_clock_set_timeout+0x146> @ imm = #0x6
; 			last_load = MAX_CYCLES;
 800a3ca: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800a478 <sys_clock_set_timeout+0x1ec>
 800a3cc: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x800a490 <sys_clock_set_timeout+0x204>
 800a3ce: 601a         	str	r2, [r3]
 800a3d0: e002         	b	0x800a3d8 <sys_clock_set_timeout+0x14c> @ imm = #0x4
; 			last_load = delay;
 800a3d2: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x800a478 <sys_clock_set_timeout+0x1ec>
 800a3d4: 6d7b         	ldr	r3, [r7, #0x54]
 800a3d6: 6013         	str	r3, [r2]
; 	val2 = SysTick->VAL;
 800a3d8: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800a474 <sys_clock_set_timeout+0x1e8>
 800a3da: 689b         	ldr	r3, [r3, #0x8]
 800a3dc: 653b         	str	r3, [r7, #0x50]
; 	SysTick->LOAD = last_load - 1;
 800a3de: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800a478 <sys_clock_set_timeout+0x1ec>
 800a3e0: 681b         	ldr	r3, [r3]
 800a3e2: 4a24         	ldr	r2, [pc, #0x90]         @ 0x800a474 <sys_clock_set_timeout+0x1e8>
 800a3e4: 3b01         	subs	r3, #0x1
 800a3e6: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 800a3e8: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800a474 <sys_clock_set_timeout+0x1e8>
 800a3ea: 2200         	movs	r2, #0x0
 800a3ec: 609a         	str	r2, [r3, #0x8]
; 	if (val1 < val2) {
 800a3ee: 6dfa         	ldr	r2, [r7, #0x5c]
 800a3f0: 6d3b         	ldr	r3, [r7, #0x50]
 800a3f2: 429a         	cmp	r2, r3
 800a3f4: d216         	bhs	0x800a424 <sys_clock_set_timeout+0x198> @ imm = #0x2c
; 		cycle_count += (val1 + (last_load_ - val2));
 800a3f6: 6e7a         	ldr	r2, [r7, #0x64]
 800a3f8: 6d3b         	ldr	r3, [r7, #0x50]
 800a3fa: 1ad2         	subs	r2, r2, r3
 800a3fc: 6dfb         	ldr	r3, [r7, #0x5c]
 800a3fe: 4413         	add	r3, r2
 800a400: 2200         	movs	r2, #0x0
 800a402: 4698         	mov	r8, r3
 800a404: 4691         	mov	r9, r2
 800a406: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800a480 <sys_clock_set_timeout+0x1f4>
 800a408: e9d3 2300    	ldrd	r2, r3, [r3]
 800a40c: eb18 0102    	adds.w	r1, r8, r2
 800a410: 60b9         	str	r1, [r7, #0x8]
 800a412: eb49 0303    	adc.w	r3, r9, r3
 800a416: 60fb         	str	r3, [r7, #0xc]
 800a418: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800a480 <sys_clock_set_timeout+0x1f4>
 800a41a: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 800a41e: e9c3 1200    	strd	r1, r2, [r3]
 800a422: e012         	b	0x800a44a <sys_clock_set_timeout+0x1be> @ imm = #0x24
; 		cycle_count += (val1 - val2);
 800a424: 6dfa         	ldr	r2, [r7, #0x5c]
 800a426: 6d3b         	ldr	r3, [r7, #0x50]
 800a428: 1ad3         	subs	r3, r2, r3
 800a42a: 2200         	movs	r2, #0x0
 800a42c: 461c         	mov	r4, r3
 800a42e: 4615         	mov	r5, r2
 800a430: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800a480 <sys_clock_set_timeout+0x1f4>
 800a432: e9d3 2300    	ldrd	r2, r3, [r3]
 800a436: 18a1         	adds	r1, r4, r2
 800a438: 6039         	str	r1, [r7]
 800a43a: eb45 0303    	adc.w	r3, r5, r3
 800a43e: 607b         	str	r3, [r7, #0x4]
 800a440: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800a480 <sys_clock_set_timeout+0x1f4>
 800a442: e9d7 1200    	ldrd	r1, r2, [r7]
 800a446: e9c3 1200    	strd	r1, r2, [r3]
 800a44a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800a47c <sys_clock_set_timeout+0x1f0>
 800a44c: 637b         	str	r3, [r7, #0x34]
 800a44e: 6abb         	ldr	r3, [r7, #0x28]
 800a450: 627b         	str	r3, [r7, #0x24]
; 	arch_irq_unlock(key.key);
 800a452: 6a7b         	ldr	r3, [r7, #0x24]
 800a454: 633b         	str	r3, [r7, #0x30]
 800a456: 6b3b         	ldr	r3, [r7, #0x30]
 800a458: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a45a: 6afb         	ldr	r3, [r7, #0x2c]
 800a45c: f383 8811    	msr	basepri, r3
; }
 800a460: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a462: f3bf 8f6f    	isb	sy
; }
 800a466: bf00         	nop
; }
 800a468: bf00         	nop
; }
 800a46a: bf00         	nop
; }
 800a46c: 3768         	adds	r7, #0x68
 800a46e: 46bd         	mov	sp, r7
 800a470: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800a474 <$d>:
 800a474: 10 e0 00 e0  	.word	0xe000e010
 800a478: 74 10 00 20  	.word	0x20001074
 800a47c: 74 10 00 20  	.word	0x20001074
 800a480: 30 06 00 20  	.word	0x20000630
 800a484: 78 10 00 20  	.word	0x20001078
 800a488: 38 06 00 20  	.word	0x20000638
 800a48c: 2d 34 a9 f9  	.word	0xf9a9342d
 800a490: 20 94 ff 00  	.word	0x00ff9420

0800a494 <sys_clock_elapsed>:
; {
 800a494: b580         	push	{r7, lr}
 800a496: b08e         	sub	sp, #0x38
 800a498: af00         	add	r7, sp, #0x0
 800a49a: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800a524 <sys_clock_elapsed+0x90>
 800a49c: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a49e: f3ef 8311    	mrs	r3, basepri
 800a4a2: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 800a4a4: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 800a4a6: 61bb         	str	r3, [r7, #0x18]
 800a4a8: 2310         	movs	r3, #0x10
 800a4aa: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800a4ac: 697b         	ldr	r3, [r7, #0x14]
 800a4ae: f383 8812    	msr	basepri_max, r3
; }
 800a4b2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a4b4: f3bf 8f6f    	isb	sy
; }
 800a4b8: bf00         	nop
; 	return key;
 800a4ba: 69bb         	ldr	r3, [r7, #0x18]
; 	k.key = arch_irq_lock();
 800a4bc: 607b         	str	r3, [r7, #0x4]
 800a4be: 6a3b         	ldr	r3, [r7, #0x20]
 800a4c0: 613b         	str	r3, [r7, #0x10]
; }
 800a4c2: bf00         	nop
 800a4c4: 6a3b         	ldr	r3, [r7, #0x20]
 800a4c6: 60fb         	str	r3, [r7, #0xc]
; }
 800a4c8: bf00         	nop
; 	return k;
 800a4ca: 687b         	ldr	r3, [r7, #0x4]
 800a4cc: 60bb         	str	r3, [r7, #0x8]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 800a4ce: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800a528 <sys_clock_elapsed+0x94>
 800a4d0: e9d3 2300    	ldrd	r2, r3, [r3]
 800a4d4: 4611         	mov	r1, r2
 800a4d6: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800a52c <sys_clock_elapsed+0x98>
 800a4d8: e9d3 2300    	ldrd	r2, r3, [r3]
 800a4dc: 4613         	mov	r3, r2
 800a4de: 1acb         	subs	r3, r1, r3
 800a4e0: 637b         	str	r3, [r7, #0x34]
; 	uint32_t cyc = elapsed() + unannounced;
 800a4e2: f7ff fe3f    	bl	0x800a164 <elapsed>     @ imm = #-0x382
 800a4e6: 4602         	mov	r2, r0
 800a4e8: 6b7b         	ldr	r3, [r7, #0x34]
 800a4ea: 4413         	add	r3, r2
 800a4ec: 633b         	str	r3, [r7, #0x30]
 800a4ee: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800a524 <sys_clock_elapsed+0x90>
 800a4f0: 62fb         	str	r3, [r7, #0x2c]
 800a4f2: 68bb         	ldr	r3, [r7, #0x8]
 800a4f4: 603b         	str	r3, [r7]
; 	arch_irq_unlock(key.key);
 800a4f6: 683b         	ldr	r3, [r7]
 800a4f8: 62bb         	str	r3, [r7, #0x28]
 800a4fa: 6abb         	ldr	r3, [r7, #0x28]
 800a4fc: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a4fe: 6a7b         	ldr	r3, [r7, #0x24]
 800a500: f383 8811    	msr	basepri, r3
; }
 800a504: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a506: f3bf 8f6f    	isb	sy
; }
 800a50a: bf00         	nop
; }
 800a50c: bf00         	nop
; }
 800a50e: bf00         	nop
; 	return cyc / CYC_PER_TICK;
 800a510: 6b3b         	ldr	r3, [r7, #0x30]
 800a512: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800a530 <sys_clock_elapsed+0x9c>
 800a514: fba2 2303    	umull	r2, r3, r2, r3
 800a518: 0b9b         	lsrs	r3, r3, #0xe
; }
 800a51a: 4618         	mov	r0, r3
 800a51c: 3738         	adds	r7, #0x38
 800a51e: 46bd         	mov	sp, r7
 800a520: bd80         	pop	{r7, pc}
 800a522: bf00         	nop

0800a524 <$d>:
 800a524: 74 10 00 20  	.word	0x20001074
 800a528: 30 06 00 20  	.word	0x20000630
 800a52c: 38 06 00 20  	.word	0x20000638
 800a530: 2d 34 a9 f9  	.word	0xf9a9342d

0800a534 <sys_clock_cycle_get_32>:
; {
 800a534: b580         	push	{r7, lr}
 800a536: b08e         	sub	sp, #0x38
 800a538: af00         	add	r7, sp, #0x0
 800a53a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800a5b0 <sys_clock_cycle_get_32+0x7c>
 800a53c: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a53e: f3ef 8311    	mrs	r3, basepri
 800a542: 623b         	str	r3, [r7, #0x20]
;   return(result);
 800a544: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 800a546: 61fb         	str	r3, [r7, #0x1c]
 800a548: 2310         	movs	r3, #0x10
 800a54a: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800a54c: 69bb         	ldr	r3, [r7, #0x18]
 800a54e: f383 8812    	msr	basepri_max, r3
; }
 800a552: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a554: f3bf 8f6f    	isb	sy
; }
 800a558: bf00         	nop
; 	return key;
 800a55a: 69fb         	ldr	r3, [r7, #0x1c]
; 	k.key = arch_irq_lock();
 800a55c: 60bb         	str	r3, [r7, #0x8]
 800a55e: 6a7b         	ldr	r3, [r7, #0x24]
 800a560: 617b         	str	r3, [r7, #0x14]
; }
 800a562: bf00         	nop
 800a564: 6a7b         	ldr	r3, [r7, #0x24]
 800a566: 613b         	str	r3, [r7, #0x10]
; }
 800a568: bf00         	nop
; 	return k;
 800a56a: 68bb         	ldr	r3, [r7, #0x8]
 800a56c: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ret = cycle_count;
 800a56e: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800a5b4 <sys_clock_cycle_get_32+0x80>
 800a570: e9d3 2300    	ldrd	r2, r3, [r3]
 800a574: 4613         	mov	r3, r2
 800a576: 637b         	str	r3, [r7, #0x34]
; 	ret += elapsed();
 800a578: f7ff fdf4    	bl	0x800a164 <elapsed>     @ imm = #-0x418
 800a57c: 4602         	mov	r2, r0
 800a57e: 6b7b         	ldr	r3, [r7, #0x34]
 800a580: 4413         	add	r3, r2
 800a582: 637b         	str	r3, [r7, #0x34]
 800a584: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800a5b0 <sys_clock_cycle_get_32+0x7c>
 800a586: 633b         	str	r3, [r7, #0x30]
 800a588: 68fb         	ldr	r3, [r7, #0xc]
 800a58a: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 800a58c: 687b         	ldr	r3, [r7, #0x4]
 800a58e: 62fb         	str	r3, [r7, #0x2c]
 800a590: 6afb         	ldr	r3, [r7, #0x2c]
 800a592: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a594: 6abb         	ldr	r3, [r7, #0x28]
 800a596: f383 8811    	msr	basepri, r3
; }
 800a59a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a59c: f3bf 8f6f    	isb	sy
; }
 800a5a0: bf00         	nop
; }
 800a5a2: bf00         	nop
; }
 800a5a4: bf00         	nop
; 	return ret;
 800a5a6: 6b7b         	ldr	r3, [r7, #0x34]
; }
 800a5a8: 4618         	mov	r0, r3
 800a5aa: 3738         	adds	r7, #0x38
 800a5ac: 46bd         	mov	sp, r7
 800a5ae: bd80         	pop	{r7, pc}

0800a5b0 <$d>:
 800a5b0: 74 10 00 20  	.word	0x20001074
 800a5b4: 30 06 00 20  	.word	0x20000630

0800a5b8 <sys_clock_driver_init>:
; {
 800a5b8: b580         	push	{r7, lr}
 800a5ba: af00         	add	r7, sp, #0x0
; 	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
 800a5bc: 2101         	movs	r1, #0x1
 800a5be: f04f 30ff    	mov.w	r0, #0xffffffff
 800a5c2: f7ff fda5    	bl	0x800a110 <__NVIC_SetPriority> @ imm = #-0x4b6
; 	last_load = CYC_PER_TICK;
 800a5c6: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800a5f8 <sys_clock_driver_init+0x40>
 800a5c8: f244 12a0    	movw	r2, #0x41a0
 800a5cc: 601a         	str	r2, [r3]
; 	overflow_cyc = 0U;
 800a5ce: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800a5fc <sys_clock_driver_init+0x44>
 800a5d0: 2200         	movs	r2, #0x0
 800a5d2: 601a         	str	r2, [r3]
; 	SysTick->LOAD = last_load - 1;
 800a5d4: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800a5f8 <sys_clock_driver_init+0x40>
 800a5d6: 681b         	ldr	r3, [r3]
 800a5d8: 4a09         	ldr	r2, [pc, #0x24]         @ 0x800a600 <sys_clock_driver_init+0x48>
 800a5da: 3b01         	subs	r3, #0x1
 800a5dc: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 800a5de: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800a600 <sys_clock_driver_init+0x48>
 800a5e0: 2200         	movs	r2, #0x0
 800a5e2: 609a         	str	r2, [r3, #0x8]
; 	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
 800a5e4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a600 <sys_clock_driver_init+0x48>
 800a5e6: 681b         	ldr	r3, [r3]
 800a5e8: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800a600 <sys_clock_driver_init+0x48>
 800a5ea: f043 0307    	orr	r3, r3, #0x7
 800a5ee: 6013         	str	r3, [r2]
; 	return 0;
 800a5f0: 2300         	movs	r3, #0x0
; }
 800a5f2: 4618         	mov	r0, r3
 800a5f4: bd80         	pop	{r7, pc}
 800a5f6: bf00         	nop

0800a5f8 <$d>:
 800a5f8: 74 10 00 20  	.word	0x20001074
 800a5fc: 78 10 00 20  	.word	0x20001078
 800a600: 10 e0 00 e0  	.word	0xe000e010

0800a604 <get_can_id>:
; {
 800a604: b480         	push	{r7}
 800a606: b085         	sub	sp, #0x14
 800a608: af00         	add	r7, sp, #0x0
 800a60a: 6078         	str	r0, [r7, #0x4]
; 	const struct dm_motor_config *cfg = dev->config;
 800a60c: 687b         	ldr	r3, [r7, #0x4]
 800a60e: 685b         	ldr	r3, [r3, #0x4]
 800a610: 60bb         	str	r3, [r7, #0x8]
; 	for (int i = 0; i < CAN_COUNT; i++) {
 800a612: 2300         	movs	r3, #0x0
 800a614: 60fb         	str	r3, [r7, #0xc]
 800a616: e00c         	b	0x800a632 <get_can_id+0x2e> @ imm = #0x18
; 		if (can_devices[i] == cfg->common.phy) {
 800a618: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800a648 <get_can_id+0x44>
 800a61a: 68fb         	ldr	r3, [r7, #0xc]
 800a61c: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 800a620: 68bb         	ldr	r3, [r7, #0x8]
 800a622: 681b         	ldr	r3, [r3]
 800a624: 429a         	cmp	r2, r3
 800a626: d101         	bne	0x800a62c <get_can_id+0x28> @ imm = #0x2
; 			return i;
 800a628: 68fb         	ldr	r3, [r7, #0xc]
 800a62a: e007         	b	0x800a63c <get_can_id+0x38> @ imm = #0xe
; 	for (int i = 0; i < CAN_COUNT; i++) {
 800a62c: 68fb         	ldr	r3, [r7, #0xc]
 800a62e: 3301         	adds	r3, #0x1
 800a630: 60fb         	str	r3, [r7, #0xc]
 800a632: 68fb         	ldr	r3, [r7, #0xc]
 800a634: 2b01         	cmp	r3, #0x1
 800a636: ddef         	ble	0x800a618 <get_can_id+0x14> @ imm = #-0x22
; 	return -1;
 800a638: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 800a63c: 4618         	mov	r0, r3
 800a63e: 3714         	adds	r7, #0x14
 800a640: 46bd         	mov	sp, r7
 800a642: bc80         	pop	{r7}
 800a644: 4770         	bx	lr
 800a646: bf00         	nop

0800a648 <$d>:
 800a648: dc 04 00 20  	.word	0x200004dc

0800a64c <dm_init>:
; {
 800a64c: b590         	push	{r4, r7, lr}
 800a64e: b087         	sub	sp, #0x1c
 800a650: af02         	add	r7, sp, #0x8
 800a652: 6078         	str	r0, [r7, #0x4]
; 	const struct dm_motor_config *cfg = dev->config;
 800a654: 687b         	ldr	r3, [r7, #0x4]
 800a656: 685b         	ldr	r3, [r3, #0x4]
 800a658: 60fb         	str	r3, [r7, #0xc]
; 	int can_id = get_can_id(dev);
 800a65a: 6878         	ldr	r0, [r7, #0x4]
 800a65c: f7ff ffd2    	bl	0x800a604 <get_can_id>  @ imm = #-0x5c
 800a660: 60b8         	str	r0, [r7, #0x8]
; 	k_sem_init(&tx_queue_sem[can_id], 3, 3); // 初始化信号量
 800a662: 68bb         	ldr	r3, [r7, #0x8]
 800a664: 011b         	lsls	r3, r3, #0x4
 800a666: 4a21         	ldr	r2, [pc, #0x84]         @ 0x800a6ec <dm_init+0xa0>
 800a668: 4413         	add	r3, r2
 800a66a: 2203         	movs	r2, #0x3
 800a66c: 2103         	movs	r1, #0x3
 800a66e: 4618         	mov	r0, r3
 800a670: f00d fe0f    	bl	0x8018292 <k_sem_init>  @ imm = #0xdc1e
; 	if (!device_is_ready(cfg->common.phy)) {
 800a674: 68fb         	ldr	r3, [r7, #0xc]
 800a676: 681b         	ldr	r3, [r3]
 800a678: 4618         	mov	r0, r3
 800a67a: f00d fd9e    	bl	0x80181ba <device_is_ready> @ imm = #0xdb3c
 800a67e: 4603         	mov	r3, r0
 800a680: f083 0301    	eor	r3, r3, #0x1
 800a684: b2db         	uxtb	r3, r3
 800a686: 2b00         	cmp	r3, #0x0
 800a688: d002         	beq	0x800a690 <dm_init+0x44> @ imm = #0x4
; 		return -1;
 800a68a: f04f 34ff    	mov.w	r4, #0xffffffff
 800a68e: e028         	b	0x800a6e2 <dm_init+0x96> @ imm = #0x50
; 	if (k_work_busy_get(&dm_init_work) != 0) {
 800a690: 4817         	ldr	r0, [pc, #0x5c]         @ 0x800a6f0 <dm_init+0xa4>
 800a692: f002 fcfd    	bl	0x800d090 <k_work_busy_get> @ imm = #0x29fa
 800a696: 4603         	mov	r3, r0
 800a698: 2b00         	cmp	r3, #0x0
 800a69a: d001         	beq	0x800a6a0 <dm_init+0x54> @ imm = #0x2
; 		return 0;
 800a69c: 2400         	movs	r4, #0x0
 800a69e: e020         	b	0x800a6e2 <dm_init+0x96> @ imm = #0x40
; 	k_work_queue_init(&dm_work_queue);
 800a6a0: 4814         	ldr	r0, [pc, #0x50]         @ 0x800a6f4 <dm_init+0xa8>
 800a6a2: f00f f90d    	bl	0x80198c0 <k_work_queue_init> @ imm = #0xf21a
; 	k_work_queue_start(&dm_work_queue, dm_work_queue_stack, CAN_SEND_STACK_SIZE,
 800a6a6: 2300         	movs	r3, #0x0
 800a6a8: 9300         	str	r3, [sp]
 800a6aa: f04f 33ff    	mov.w	r3, #0xffffffff
 800a6ae: f44f 6200    	mov.w	r2, #0x800
 800a6b2: 4911         	ldr	r1, [pc, #0x44]         @ 0x800a6f8 <dm_init+0xac>
 800a6b4: 480f         	ldr	r0, [pc, #0x3c]         @ 0x800a6f4 <dm_init+0xa8>
 800a6b6: f002 fec3    	bl	0x800d440 <k_work_queue_start> @ imm = #0x2d86
; 	k_timer_start(&dm_tx_timer, K_MSEC(500), K_MSEC(1));
 800a6ba: f241 3088    	movw	r0, #0x1388
 800a6be: f04f 0100    	mov.w	r1, #0x0
 800a6c2: f04f 020a    	mov.w	r2, #0xa
 800a6c6: f04f 0300    	mov.w	r3, #0x0
 800a6ca: e9cd 2300    	strd	r2, r3, [sp]
 800a6ce: 4602         	mov	r2, r0
 800a6d0: 460b         	mov	r3, r1
 800a6d2: 480a         	ldr	r0, [pc, #0x28]         @ 0x800a6fc <dm_init+0xb0>
 800a6d4: f00d fdb1    	bl	0x801823a <k_timer_start> @ imm = #0xdb62
; 	k_timer_user_data_set(&dm_tx_timer, &dm_init_work);
 800a6d8: 4905         	ldr	r1, [pc, #0x14]         @ 0x800a6f0 <dm_init+0xa4>
 800a6da: 4808         	ldr	r0, [pc, #0x20]         @ 0x800a6fc <dm_init+0xb0>
 800a6dc: f00d fdc0    	bl	0x8018260 <k_timer_user_data_set> @ imm = #0xdb80
; 	return 0;
 800a6e0: 2400         	movs	r4, #0x0
; }
 800a6e2: 4623         	mov	r3, r4
 800a6e4: 4618         	mov	r0, r3
 800a6e6: 3714         	adds	r7, #0x14
 800a6e8: 46bd         	mov	sp, r7
 800a6ea: bd90         	pop	{r4, r7, pc}

0800a6ec <$d>:
 800a6ec: 7c 10 00 20  	.word	0x2000107c
 800a6f0: 04 05 00 20  	.word	0x20000504
 800a6f4: 40 06 00 20  	.word	0x20000640
 800a6f8: 48 21 00 20  	.word	0x20002148
 800a6fc: d0 05 00 20  	.word	0x200005d0

0800a700 <dm_send_queued>:
; {
 800a700: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800a704: b08c         	sub	sp, #0x30
 800a706: af04         	add	r7, sp, #0x10
 800a708: 6078         	str	r0, [r7, #0x4]
 800a70a: 6039         	str	r1, [r7]
; 	int current_cyc = k_cycle_get_32();
 800a70c: f00d fd80    	bl	0x8018210 <k_cycle_get_32> @ imm = #0xdb00
 800a710: 4603         	mov	r3, r0
 800a712: 61bb         	str	r3, [r7, #0x18]
; 	delay = MIN(delay, k_cyc_to_us_near32(current_cyc - prev_cyc));
 800a714: 4b51         	ldr	r3, [pc, #0x144]        @ 0x800a85c <dm_send_queued+0x15c>
 800a716: 681b         	ldr	r3, [r3]
 800a718: 69ba         	ldr	r2, [r7, #0x18]
 800a71a: 1ad3         	subs	r3, r2, r3
 800a71c: 2b00         	cmp	r3, #0x0
 800a71e: db0a         	blt	0x800a736 <dm_send_queued+0x36> @ imm = #0x14
 800a720: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x800a85c <dm_send_queued+0x15c>
 800a722: 681b         	ldr	r3, [r3]
 800a724: 69ba         	ldr	r2, [r7, #0x18]
 800a726: 1ad3         	subs	r3, r2, r3
 800a728: 3354         	adds	r3, #0x54
 800a72a: 08db         	lsrs	r3, r3, #0x3
 800a72c: 4a4c         	ldr	r2, [pc, #0x130]        @ 0x800a860 <dm_send_queued+0x160>
 800a72e: fba2 2303    	umull	r2, r3, r2, r3
 800a732: 085b         	lsrs	r3, r3, #0x1
 800a734: e015         	b	0x800a762 <dm_send_queued+0x62> @ imm = #0x2a
 800a736: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800a85c <dm_send_queued+0x15c>
 800a738: 681b         	ldr	r3, [r3]
 800a73a: 69ba         	ldr	r2, [r7, #0x18]
 800a73c: 1ad3         	subs	r3, r2, r3
 800a73e: 17da         	asrs	r2, r3, #0x1f
 800a740: 461c         	mov	r4, r3
 800a742: 4615         	mov	r5, r2
 800a744: f114 0854    	adds.w	r8, r4, #0x54
 800a748: f145 0900    	adc	r9, r5, #0x0
 800a74c: f04f 02a8    	mov.w	r2, #0xa8
 800a750: f04f 0300    	mov.w	r3, #0x0
 800a754: 4640         	mov	r0, r8
 800a756: 4649         	mov	r1, r9
 800a758: f7f6 f9cc    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x9c68
 800a75c: 4602         	mov	r2, r0
 800a75e: 460b         	mov	r3, r1
 800a760: 4613         	mov	r3, r2
 800a762: 4a40         	ldr	r2, [pc, #0x100]        @ 0x800a864 <dm_send_queued+0x164>
 800a764: 6812         	ldr	r2, [r2]
 800a766: 4293         	cmp	r3, r2
 800a768: bf28         	it	hs
 800a76a: 4613         	movhs	r3, r2
 800a76c: 461a         	mov	r2, r3
 800a76e: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x800a864 <dm_send_queued+0x164>
 800a770: 601a         	str	r2, [r3]
; 	prev_cyc = current_cyc;
 800a772: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x800a85c <dm_send_queued+0x15c>
 800a774: 69bb         	ldr	r3, [r7, #0x18]
 800a776: 6013         	str	r3, [r2]
; 	int err = k_sem_take(frame->sem, K_NO_WAIT);
 800a778: 687b         	ldr	r3, [r7, #0x4]
 800a77a: 6859         	ldr	r1, [r3, #0x4]
 800a77c: f04f 0200    	mov.w	r2, #0x0
 800a780: f04f 0300    	mov.w	r3, #0x0
 800a784: 4608         	mov	r0, r1
 800a786: f00d fd94    	bl	0x80182b2 <k_sem_take>  @ imm = #0xdb28
 800a78a: 61f8         	str	r0, [r7, #0x1c]
; 	if (err == 0) {
 800a78c: 69fb         	ldr	r3, [r7, #0x1c]
 800a78e: 2b00         	cmp	r3, #0x0
 800a790: d131         	bne	0x800a7f6 <dm_send_queued+0xf6> @ imm = #0x62
; 		err = can_send(frame->can_dev, &frame->frame, K_NO_WAIT, can_tx_callback,
 800a792: 687b         	ldr	r3, [r7, #0x4]
 800a794: 6818         	ldr	r0, [r3]
 800a796: 687b         	ldr	r3, [r7, #0x4]
 800a798: f103 0408    	add.w	r4, r3, #0x8
 800a79c: f04f 0200    	mov.w	r2, #0x0
 800a7a0: f04f 0300    	mov.w	r3, #0x0
; 			       frame->sem);
 800a7a4: 6879         	ldr	r1, [r7, #0x4]
 800a7a6: 6849         	ldr	r1, [r1, #0x4]
; 		err = can_send(frame->can_dev, &frame->frame, K_NO_WAIT, can_tx_callback,
 800a7a8: 9101         	str	r1, [sp, #0x4]
 800a7aa: 492f         	ldr	r1, [pc, #0xbc]         @ 0x800a868 <dm_send_queued+0x168>
 800a7ac: 9100         	str	r1, [sp]
 800a7ae: 4621         	mov	r1, r4
 800a7b0: f00d fe25    	bl	0x80183fe <can_send>    @ imm = #0xdc4a
 800a7b4: 61f8         	str	r0, [r7, #0x1c]
; 		if (err) {
 800a7b6: 69fb         	ldr	r3, [r7, #0x1c]
 800a7b8: 2b00         	cmp	r3, #0x0
 800a7ba: d047         	beq	0x800a84c <dm_send_queued+0x14c> @ imm = #0x8e
; 			LOG_ERR("TX queue full, will be put into msgq: %d", err);
 800a7bc: 2304         	movs	r3, #0x4
 800a7be: 2b00         	cmp	r3, #0x0
 800a7c0: d044         	beq	0x800a84c <dm_send_queued+0x14c> @ imm = #0x88
 800a7c2: 2301         	movs	r3, #0x1
 800a7c4: 73fb         	strb	r3, [r7, #0xf]
 800a7c6: 7bfb         	ldrb	r3, [r7, #0xf]
 800a7c8: f083 0301    	eor	r3, r3, #0x1
 800a7cc: b2db         	uxtb	r3, r3
 800a7ce: 2b00         	cmp	r3, #0x0
 800a7d0: d13c         	bne	0x800a84c <dm_send_queued+0x14c> @ imm = #0x78
 800a7d2: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800a86c <dm_send_queued+0x16c>
 800a7d4: 6819         	ldr	r1, [r3]
 800a7d6: 69fb         	ldr	r3, [r7, #0x1c]
 800a7d8: 9303         	str	r3, [sp, #0xc]
 800a7da: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800a870 <dm_send_queued+0x170>
 800a7dc: 9302         	str	r3, [sp, #0x8]
 800a7de: 2300         	movs	r3, #0x0
 800a7e0: 9301         	str	r3, [sp, #0x4]
 800a7e2: 2300         	movs	r3, #0x0
 800a7e4: 9300         	str	r3, [sp]
 800a7e6: 2300         	movs	r3, #0x0
 800a7e8: 2201         	movs	r2, #0x1
 800a7ea: 2000         	movs	r0, #0x0
 800a7ec: f00d fdab    	bl	0x8018346 <z_log_msg_runtime_create> @ imm = #0xdb56
 800a7f0: 2300         	movs	r3, #0x0
 800a7f2: 60bb         	str	r3, [r7, #0x8]
 800a7f4: e02a         	b	0x800a84c <dm_send_queued+0x14c> @ imm = #0x54
; 	} else if (err < 0) {
 800a7f6: 69fb         	ldr	r3, [r7, #0x1c]
 800a7f8: 2b00         	cmp	r3, #0x0
 800a7fa: da27         	bge	0x800a84c <dm_send_queued+0x14c> @ imm = #0x4e
; 		err = k_msgq_put(msgq, frame, K_NO_WAIT);
 800a7fc: f04f 0200    	mov.w	r2, #0x0
 800a800: f04f 0300    	mov.w	r3, #0x0
 800a804: 6879         	ldr	r1, [r7, #0x4]
 800a806: 6838         	ldr	r0, [r7]
 800a808: f00d fd6e    	bl	0x80182e8 <k_msgq_put>  @ imm = #0xdadc
 800a80c: 61f8         	str	r0, [r7, #0x1c]
; 		if (err) {
 800a80e: 69fb         	ldr	r3, [r7, #0x1c]
 800a810: 2b00         	cmp	r3, #0x0
 800a812: d01b         	beq	0x800a84c <dm_send_queued+0x14c> @ imm = #0x36
; 			LOG_ERR("Failed to put CAN frame into TX queue: %d", err);
 800a814: 2304         	movs	r3, #0x4
 800a816: 2b00         	cmp	r3, #0x0
 800a818: d018         	beq	0x800a84c <dm_send_queued+0x14c> @ imm = #0x30
 800a81a: 2301         	movs	r3, #0x1
 800a81c: 75fb         	strb	r3, [r7, #0x17]
 800a81e: 7dfb         	ldrb	r3, [r7, #0x17]
 800a820: f083 0301    	eor	r3, r3, #0x1
 800a824: b2db         	uxtb	r3, r3
 800a826: 2b00         	cmp	r3, #0x0
 800a828: d110         	bne	0x800a84c <dm_send_queued+0x14c> @ imm = #0x20
 800a82a: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800a86c <dm_send_queued+0x16c>
 800a82c: 6819         	ldr	r1, [r3]
 800a82e: 69fb         	ldr	r3, [r7, #0x1c]
 800a830: 9303         	str	r3, [sp, #0xc]
 800a832: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800a874 <dm_send_queued+0x174>
 800a834: 9302         	str	r3, [sp, #0x8]
 800a836: 2300         	movs	r3, #0x0
 800a838: 9301         	str	r3, [sp, #0x4]
 800a83a: 2300         	movs	r3, #0x0
 800a83c: 9300         	str	r3, [sp]
 800a83e: 2300         	movs	r3, #0x0
 800a840: 2201         	movs	r2, #0x1
 800a842: 2000         	movs	r0, #0x0
 800a844: f00d fd7f    	bl	0x8018346 <z_log_msg_runtime_create> @ imm = #0xdafe
 800a848: 2300         	movs	r3, #0x0
 800a84a: 613b         	str	r3, [r7, #0x10]
; 	return err;
 800a84c: 69f9         	ldr	r1, [r7, #0x1c]
 800a84e: 460b         	mov	r3, r1
; }
 800a850: 4618         	mov	r0, r3
 800a852: 3720         	adds	r7, #0x20
 800a854: 46bd         	mov	sp, r7
 800a856: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 800a85a: bf00         	nop

0800a85c <$d>:
 800a85c: 9c 10 00 20  	.word	0x2000109c
 800a860: 19 86 61 18  	.word	0x18618619
 800a864: 18 05 00 20  	.word	0x20000518
 800a868: eb 84 01 08  	.word	0x080184eb
 800a86c: 14 05 00 20  	.word	0x20000514
 800a870: 88 c8 01 08  	.word	0x0801c888
 800a874: b4 c8 01 08  	.word	0x0801c8b4

0800a878 <dm_queue_proceed>:
; {
 800a878: b590         	push	{r4, r7, lr}
 800a87a: b091         	sub	sp, #0x44
 800a87c: af04         	add	r7, sp, #0x10
 800a87e: 6078         	str	r0, [r7, #0x4]
; 	int err = 0;
 800a880: 2300         	movs	r3, #0x0
 800a882: 62fb         	str	r3, [r7, #0x2c]
; 	bool give_up = false;
 800a884: 2300         	movs	r3, #0x0
 800a886: f887 302b    	strb.w	r3, [r7, #0x2b]
; 	while (!k_msgq_get(msgq, &frame, K_NO_WAIT)) {
 800a88a: e054         	b	0x800a936 <dm_queue_proceed+0xbe> @ imm = #0xa8
; 		err = k_sem_take(frame.sem, K_NO_WAIT);
 800a88c: 6939         	ldr	r1, [r7, #0x10]
 800a88e: f04f 0200    	mov.w	r2, #0x0
 800a892: f04f 0300    	mov.w	r3, #0x0
 800a896: 4608         	mov	r0, r1
 800a898: f00d fd0b    	bl	0x80182b2 <k_sem_take>  @ imm = #0xda16
 800a89c: 62f8         	str	r0, [r7, #0x2c]
; 		if (err == 0) {
 800a89e: 6afb         	ldr	r3, [r7, #0x2c]
 800a8a0: 2b00         	cmp	r3, #0x0
 800a8a2: d135         	bne	0x800a910 <dm_queue_proceed+0x98> @ imm = #0x6a
; 			err = can_send(frame.can_dev, &(frame.frame), K_MSEC(1), can_tx_callback,
 800a8a4: 68fc         	ldr	r4, [r7, #0xc]
 800a8a6: f04f 020a    	mov.w	r2, #0xa
 800a8aa: f04f 0300    	mov.w	r3, #0x0
; 				       frame.sem);
 800a8ae: 6939         	ldr	r1, [r7, #0x10]
; 			err = can_send(frame.can_dev, &(frame.frame), K_MSEC(1), can_tx_callback,
 800a8b0: f107 000c    	add.w	r0, r7, #0xc
 800a8b4: 3008         	adds	r0, #0x8
 800a8b6: 9101         	str	r1, [sp, #0x4]
 800a8b8: 4927         	ldr	r1, [pc, #0x9c]         @ 0x800a958 <dm_queue_proceed+0xe0>
 800a8ba: 9100         	str	r1, [sp]
 800a8bc: 4601         	mov	r1, r0
 800a8be: 4620         	mov	r0, r4
 800a8c0: f00d fd9d    	bl	0x80183fe <can_send>    @ imm = #0xdb3a
 800a8c4: 62f8         	str	r0, [r7, #0x2c]
; 			if (err) {
 800a8c6: 6afb         	ldr	r3, [r7, #0x2c]
 800a8c8: 2b00         	cmp	r3, #0x0
 800a8ca: d01d         	beq	0x800a908 <dm_queue_proceed+0x90> @ imm = #0x3a
; 				LOG_ERR("Failed to send CAN frame: %d", err);
 800a8cc: 2304         	movs	r3, #0x4
 800a8ce: 2b00         	cmp	r3, #0x0
 800a8d0: d01a         	beq	0x800a908 <dm_queue_proceed+0x90> @ imm = #0x34
 800a8d2: 2301         	movs	r3, #0x1
 800a8d4: f887 302a    	strb.w	r3, [r7, #0x2a]
 800a8d8: f897 302a    	ldrb.w	r3, [r7, #0x2a]
 800a8dc: f083 0301    	eor	r3, r3, #0x1
 800a8e0: b2db         	uxtb	r3, r3
 800a8e2: 2b00         	cmp	r3, #0x0
 800a8e4: d110         	bne	0x800a908 <dm_queue_proceed+0x90> @ imm = #0x20
 800a8e6: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800a95c <dm_queue_proceed+0xe4>
 800a8e8: 6819         	ldr	r1, [r3]
 800a8ea: 6afb         	ldr	r3, [r7, #0x2c]
 800a8ec: 9303         	str	r3, [sp, #0xc]
 800a8ee: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800a960 <dm_queue_proceed+0xe8>
 800a8f0: 9302         	str	r3, [sp, #0x8]
 800a8f2: 2300         	movs	r3, #0x0
 800a8f4: 9301         	str	r3, [sp, #0x4]
 800a8f6: 2300         	movs	r3, #0x0
 800a8f8: 9300         	str	r3, [sp]
 800a8fa: 2300         	movs	r3, #0x0
 800a8fc: 2201         	movs	r2, #0x1
 800a8fe: 2000         	movs	r0, #0x0
 800a900: f00d fd21    	bl	0x8018346 <z_log_msg_runtime_create> @ imm = #0xda42
 800a904: 2300         	movs	r3, #0x0
 800a906: 627b         	str	r3, [r7, #0x24]
; 			k_msgq_purge(msgq);
 800a908: 6878         	ldr	r0, [r7, #0x4]
 800a90a: f00d fd11    	bl	0x8018330 <k_msgq_purge> @ imm = #0xda22
 800a90e: e012         	b	0x800a936 <dm_queue_proceed+0xbe> @ imm = #0x24
; 			if (give_up) {
 800a910: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800a914: 2b00         	cmp	r3, #0x0
 800a916: d003         	beq	0x800a920 <dm_queue_proceed+0xa8> @ imm = #0x6
; 				k_msgq_purge(msgq);
 800a918: 6878         	ldr	r0, [r7, #0x4]
 800a91a: f00d fd09    	bl	0x8018330 <k_msgq_purge> @ imm = #0xda12
 800a91e: e016         	b	0x800a94e <dm_queue_proceed+0xd6> @ imm = #0x2c
; 			k_sleep(K_USEC(300));
 800a920: f04f 0203    	mov.w	r2, #0x3
 800a924: f04f 0300    	mov.w	r3, #0x0
 800a928: 4610         	mov	r0, r2
 800a92a: 4619         	mov	r1, r3
 800a92c: f00d fc77    	bl	0x801821e <k_sleep>     @ imm = #0xd8ee
; 			give_up = true;
 800a930: 2301         	movs	r3, #0x1
 800a932: f887 302b    	strb.w	r3, [r7, #0x2b]
; 	while (!k_msgq_get(msgq, &frame, K_NO_WAIT)) {
 800a936: f04f 0200    	mov.w	r2, #0x0
 800a93a: f04f 0300    	mov.w	r3, #0x0
 800a93e: f107 010c    	add.w	r1, r7, #0xc
 800a942: 6878         	ldr	r0, [r7, #0x4]
 800a944: f00d fce2    	bl	0x801830c <k_msgq_get>  @ imm = #0xd9c4
 800a948: 4603         	mov	r3, r0
 800a94a: 2b00         	cmp	r3, #0x0
 800a94c: d09e         	beq	0x800a88c <dm_queue_proceed+0x14> @ imm = #-0xc4
; 	return err;
 800a94e: 6afb         	ldr	r3, [r7, #0x2c]
; }
 800a950: 4618         	mov	r0, r3
 800a952: 3734         	adds	r7, #0x34
 800a954: 46bd         	mov	sp, r7
 800a956: bd90         	pop	{r4, r7, pc}

0800a958 <$d>:
 800a958: eb 84 01 08  	.word	0x080184eb
 800a95c: 14 05 00 20  	.word	0x20000514
 800a960: e0 c8 01 08  	.word	0x0801c8e0

0800a964 <dm_motor_control>:
; {
 800a964: b590         	push	{r4, r7, lr}
 800a966: b091         	sub	sp, #0x44
 800a968: af04         	add	r7, sp, #0x10
 800a96a: 6078         	str	r0, [r7, #0x4]
 800a96c: 460b         	mov	r3, r1
 800a96e: 70fb         	strb	r3, [r7, #0x3]
; 	struct dm_motor_data *data = dev->data;
 800a970: 687b         	ldr	r3, [r7, #0x4]
 800a972: 691b         	ldr	r3, [r3, #0x10]
 800a974: 62bb         	str	r3, [r7, #0x28]
; 	const struct dm_motor_config *cfg = dev->config;
 800a976: 687b         	ldr	r3, [r7, #0x4]
 800a978: 685b         	ldr	r3, [r3, #0x4]
 800a97a: 627b         	str	r3, [r7, #0x24]
; 	frame.id = cfg->common.tx_id;
 800a97c: 6a7b         	ldr	r3, [r7, #0x24]
 800a97e: 689b         	ldr	r3, [r3, #0x8]
 800a980: 60bb         	str	r3, [r7, #0x8]
; 	frame.flags = 0;
 800a982: 2300         	movs	r3, #0x0
 800a984: 737b         	strb	r3, [r7, #0xd]
; 	frame.dlc = 8;
 800a986: 2308         	movs	r3, #0x8
 800a988: 733b         	strb	r3, [r7, #0xc]
; 	int err = 0;
 800a98a: 2300         	movs	r3, #0x0
 800a98c: 62fb         	str	r3, [r7, #0x2c]
; 	int can_id = get_can_id(dev);
 800a98e: 6878         	ldr	r0, [r7, #0x4]
 800a990: f7ff fe38    	bl	0x800a604 <get_can_id>  @ imm = #-0x390
 800a994: 6238         	str	r0, [r7, #0x20]
; 	switch (cmd) {
 800a996: 78fb         	ldrb	r3, [r7, #0x3]
 800a998: 2b04         	cmp	r3, #0x4
 800a99a: f200 80c0    	bhi.w	0x800ab1e <dm_motor_control+0x1ba> @ imm = #0x180
 800a99e: a201         	adr	r2, #4 <dm_motor_control+0x3f>
 800a9a0: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800a9a4 <$d>:
 800a9a4: b9 a9 00 08  	.word	0x0800a9b9
 800a9a8: 13 aa 00 08  	.word	0x0800aa13
 800a9ac: 6b aa 00 08  	.word	0x0800aa6b
 800a9b0: bd aa 00 08  	.word	0x0800aabd
 800a9b4: cd aa 00 08  	.word	0x0800aacd

0800a9b8 <$t>:
; 		data->online = true;
 800a9b8: 6abb         	ldr	r3, [r7, #0x28]
 800a9ba: 2201         	movs	r2, #0x1
 800a9bc: 771a         	strb	r2, [r3, #0x1c]
; 		memcpy(frame.data, enable_frame, 8);
 800a9be: 4a6a         	ldr	r2, [pc, #0x1a8]        @ 0x800ab68 <dm_motor_control+0x204>
 800a9c0: f107 0310    	add.w	r3, r7, #0x10
 800a9c4: e892 0003    	ldm.w	r2, {r0, r1}
 800a9c8: e883 0003    	stm.w	r3, {r0, r1}
; 		if (k_sem_take(&tx_queue_sem[can_id], K_NO_WAIT) == 0) {
 800a9cc: 6a3b         	ldr	r3, [r7, #0x20]
 800a9ce: 011b         	lsls	r3, r3, #0x4
 800a9d0: 4a66         	ldr	r2, [pc, #0x198]        @ 0x800ab6c <dm_motor_control+0x208>
 800a9d2: 1899         	adds	r1, r3, r2
 800a9d4: f04f 0200    	mov.w	r2, #0x0
 800a9d8: f04f 0300    	mov.w	r3, #0x0
 800a9dc: 4608         	mov	r0, r1
 800a9de: f00d fc68    	bl	0x80182b2 <k_sem_take>  @ imm = #0xd8d0
 800a9e2: 4603         	mov	r3, r0
 800a9e4: 2b00         	cmp	r3, #0x0
 800a9e6: f040 809a    	bne.w	0x800ab1e <dm_motor_control+0x1ba> @ imm = #0x134
; 			err = can_send(cfg->common.phy, &frame, K_NO_WAIT, can_tx_callback,
 800a9ea: 6a7b         	ldr	r3, [r7, #0x24]
 800a9ec: 6818         	ldr	r0, [r3]
 800a9ee: f04f 0200    	mov.w	r2, #0x0
 800a9f2: f04f 0300    	mov.w	r3, #0x0
; 				       &tx_queue_sem[can_id]);
 800a9f6: 6a39         	ldr	r1, [r7, #0x20]
 800a9f8: 0109         	lsls	r1, r1, #0x4
 800a9fa: 4c5c         	ldr	r4, [pc, #0x170]        @ 0x800ab6c <dm_motor_control+0x208>
 800a9fc: 4421         	add	r1, r4
; 			err = can_send(cfg->common.phy, &frame, K_NO_WAIT, can_tx_callback,
 800a9fe: f107 0408    	add.w	r4, r7, #0x8
 800aa02: 9101         	str	r1, [sp, #0x4]
 800aa04: 495a         	ldr	r1, [pc, #0x168]        @ 0x800ab70 <dm_motor_control+0x20c>
 800aa06: 9100         	str	r1, [sp]
 800aa08: 4621         	mov	r1, r4
 800aa0a: f00d fcf8    	bl	0x80183fe <can_send>    @ imm = #0xd9f0
 800aa0e: 62f8         	str	r0, [r7, #0x2c]
; 		break;
 800aa10: e085         	b	0x800ab1e <dm_motor_control+0x1ba> @ imm = #0x10a
; 		data->online = false;
 800aa12: 6abb         	ldr	r3, [r7, #0x28]
 800aa14: 2200         	movs	r2, #0x0
 800aa16: 771a         	strb	r2, [r3, #0x1c]
; 		memcpy(frame.data, disable_frame, 8);
 800aa18: 4a56         	ldr	r2, [pc, #0x158]        @ 0x800ab74 <dm_motor_control+0x210>
 800aa1a: f107 0310    	add.w	r3, r7, #0x10
 800aa1e: e892 0003    	ldm.w	r2, {r0, r1}
 800aa22: e883 0003    	stm.w	r3, {r0, r1}
; 		if (k_sem_take(&tx_queue_sem[can_id], K_NO_WAIT) == 0) {
 800aa26: 6a3b         	ldr	r3, [r7, #0x20]
 800aa28: 011b         	lsls	r3, r3, #0x4
 800aa2a: 4a50         	ldr	r2, [pc, #0x140]        @ 0x800ab6c <dm_motor_control+0x208>
 800aa2c: 1899         	adds	r1, r3, r2
 800aa2e: f04f 0200    	mov.w	r2, #0x0
 800aa32: f04f 0300    	mov.w	r3, #0x0
 800aa36: 4608         	mov	r0, r1
 800aa38: f00d fc3b    	bl	0x80182b2 <k_sem_take>  @ imm = #0xd876
 800aa3c: 4603         	mov	r3, r0
 800aa3e: 2b00         	cmp	r3, #0x0
 800aa40: d16d         	bne	0x800ab1e <dm_motor_control+0x1ba> @ imm = #0xda
; 			err = can_send(cfg->common.phy, &frame, K_NO_WAIT, can_tx_callback,
 800aa42: 6a7b         	ldr	r3, [r7, #0x24]
 800aa44: 6818         	ldr	r0, [r3]
 800aa46: f04f 0200    	mov.w	r2, #0x0
 800aa4a: f04f 0300    	mov.w	r3, #0x0
; 				       &tx_queue_sem[can_id]);
 800aa4e: 6a39         	ldr	r1, [r7, #0x20]
 800aa50: 0109         	lsls	r1, r1, #0x4
 800aa52: 4c46         	ldr	r4, [pc, #0x118]        @ 0x800ab6c <dm_motor_control+0x208>
 800aa54: 4421         	add	r1, r4
; 			err = can_send(cfg->common.phy, &frame, K_NO_WAIT, can_tx_callback,
 800aa56: f107 0408    	add.w	r4, r7, #0x8
 800aa5a: 9101         	str	r1, [sp, #0x4]
 800aa5c: 4944         	ldr	r1, [pc, #0x110]        @ 0x800ab70 <dm_motor_control+0x20c>
 800aa5e: 9100         	str	r1, [sp]
 800aa60: 4621         	mov	r1, r4
 800aa62: f00d fccc    	bl	0x80183fe <can_send>    @ imm = #0xd998
 800aa66: 62f8         	str	r0, [r7, #0x2c]
; 		break;
 800aa68: e059         	b	0x800ab1e <dm_motor_control+0x1ba> @ imm = #0xb2
; 		memcpy(frame.data, set_zero_frame, 8);
 800aa6a: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x800ab78 <dm_motor_control+0x214>
 800aa6c: f107 0310    	add.w	r3, r7, #0x10
 800aa70: e892 0003    	ldm.w	r2, {r0, r1}
 800aa74: e883 0003    	stm.w	r3, {r0, r1}
; 		if (k_sem_take(&tx_queue_sem[can_id], K_NO_WAIT) == 0) {
 800aa78: 6a3b         	ldr	r3, [r7, #0x20]
 800aa7a: 011b         	lsls	r3, r3, #0x4
 800aa7c: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x800ab6c <dm_motor_control+0x208>
 800aa7e: 1899         	adds	r1, r3, r2
 800aa80: f04f 0200    	mov.w	r2, #0x0
 800aa84: f04f 0300    	mov.w	r3, #0x0
 800aa88: 4608         	mov	r0, r1
 800aa8a: f00d fc12    	bl	0x80182b2 <k_sem_take>  @ imm = #0xd824
 800aa8e: 4603         	mov	r3, r0
 800aa90: 2b00         	cmp	r3, #0x0
 800aa92: d144         	bne	0x800ab1e <dm_motor_control+0x1ba> @ imm = #0x88
; 			err = can_send(cfg->common.phy, &frame, K_NO_WAIT, can_tx_callback,
 800aa94: 6a7b         	ldr	r3, [r7, #0x24]
 800aa96: 6818         	ldr	r0, [r3]
 800aa98: f04f 0200    	mov.w	r2, #0x0
 800aa9c: f04f 0300    	mov.w	r3, #0x0
; 				       &tx_queue_sem[can_id]);
 800aaa0: 6a39         	ldr	r1, [r7, #0x20]
 800aaa2: 0109         	lsls	r1, r1, #0x4
 800aaa4: 4c31         	ldr	r4, [pc, #0xc4]         @ 0x800ab6c <dm_motor_control+0x208>
 800aaa6: 4421         	add	r1, r4
; 			err = can_send(cfg->common.phy, &frame, K_NO_WAIT, can_tx_callback,
 800aaa8: f107 0408    	add.w	r4, r7, #0x8
 800aaac: 9101         	str	r1, [sp, #0x4]
 800aaae: 4930         	ldr	r1, [pc, #0xc0]         @ 0x800ab70 <dm_motor_control+0x20c>
 800aab0: 9100         	str	r1, [sp]
 800aab2: 4621         	mov	r1, r4
 800aab4: f00d fca3    	bl	0x80183fe <can_send>    @ imm = #0xd946
 800aab8: 62f8         	str	r0, [r7, #0x2c]
; 		break;
 800aaba: e030         	b	0x800ab1e <dm_motor_control+0x1ba> @ imm = #0x60
; 		memset(&data->params, 0, sizeof(data->params));
 800aabc: 6abb         	ldr	r3, [r7, #0x28]
 800aabe: 3338         	adds	r3, #0x38
 800aac0: 220c         	movs	r2, #0xc
 800aac2: 2100         	movs	r1, #0x0
 800aac4: 4618         	mov	r0, r3
 800aac6: f00f feb3    	bl	0x801a830 <memset>      @ imm = #0xfd66
; 		break;
 800aaca: e028         	b	0x800ab1e <dm_motor_control+0x1ba> @ imm = #0x50
; 		memcpy(frame.data, clear_error_frame, 8);
 800aacc: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x800ab7c <dm_motor_control+0x218>
 800aace: f107 0310    	add.w	r3, r7, #0x10
 800aad2: e892 0003    	ldm.w	r2, {r0, r1}
 800aad6: e883 0003    	stm.w	r3, {r0, r1}
; 		if (k_sem_take(&tx_queue_sem[can_id], K_NO_WAIT) == 0) {
 800aada: 6a3b         	ldr	r3, [r7, #0x20]
 800aadc: 011b         	lsls	r3, r3, #0x4
 800aade: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x800ab6c <dm_motor_control+0x208>
 800aae0: 1899         	adds	r1, r3, r2
 800aae2: f04f 0200    	mov.w	r2, #0x0
 800aae6: f04f 0300    	mov.w	r3, #0x0
 800aaea: 4608         	mov	r0, r1
 800aaec: f00d fbe1    	bl	0x80182b2 <k_sem_take>  @ imm = #0xd7c2
 800aaf0: 4603         	mov	r3, r0
 800aaf2: 2b00         	cmp	r3, #0x0
 800aaf4: d112         	bne	0x800ab1c <dm_motor_control+0x1b8> @ imm = #0x24
; 			err = can_send(cfg->common.phy, &frame, K_NO_WAIT, can_tx_callback,
 800aaf6: 6a7b         	ldr	r3, [r7, #0x24]
 800aaf8: 6818         	ldr	r0, [r3]
 800aafa: f04f 0200    	mov.w	r2, #0x0
 800aafe: f04f 0300    	mov.w	r3, #0x0
; 				       &tx_queue_sem[can_id]);
 800ab02: 6a39         	ldr	r1, [r7, #0x20]
 800ab04: 0109         	lsls	r1, r1, #0x4
 800ab06: 4c19         	ldr	r4, [pc, #0x64]         @ 0x800ab6c <dm_motor_control+0x208>
 800ab08: 4421         	add	r1, r4
; 			err = can_send(cfg->common.phy, &frame, K_NO_WAIT, can_tx_callback,
 800ab0a: f107 0408    	add.w	r4, r7, #0x8
 800ab0e: 9101         	str	r1, [sp, #0x4]
 800ab10: 4917         	ldr	r1, [pc, #0x5c]         @ 0x800ab70 <dm_motor_control+0x20c>
 800ab12: 9100         	str	r1, [sp]
 800ab14: 4621         	mov	r1, r4
 800ab16: f00d fc72    	bl	0x80183fe <can_send>    @ imm = #0xd8e4
 800ab1a: 62f8         	str	r0, [r7, #0x2c]
; 		break;
 800ab1c: bf00         	nop
; 	if (err != 0) {
 800ab1e: 6afb         	ldr	r3, [r7, #0x2c]
 800ab20: 2b00         	cmp	r3, #0x0
 800ab22: d01c         	beq	0x800ab5e <dm_motor_control+0x1fa> @ imm = #0x38
; 		LOG_ERR("Failed to send CAN frame: %d", err);
 800ab24: 2304         	movs	r3, #0x4
 800ab26: 2b00         	cmp	r3, #0x0
 800ab28: d019         	beq	0x800ab5e <dm_motor_control+0x1fa> @ imm = #0x32
 800ab2a: 2301         	movs	r3, #0x1
 800ab2c: 77fb         	strb	r3, [r7, #0x1f]
 800ab2e: 7ffb         	ldrb	r3, [r7, #0x1f]
 800ab30: f083 0301    	eor	r3, r3, #0x1
 800ab34: b2db         	uxtb	r3, r3
 800ab36: 2b00         	cmp	r3, #0x0
 800ab38: d111         	bne	0x800ab5e <dm_motor_control+0x1fa> @ imm = #0x22
 800ab3a: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800ab80 <dm_motor_control+0x21c>
 800ab3c: 6819         	ldr	r1, [r3]
 800ab3e: 6afb         	ldr	r3, [r7, #0x2c]
 800ab40: 9303         	str	r3, [sp, #0xc]
 800ab42: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800ab84 <dm_motor_control+0x220>
 800ab44: 9302         	str	r3, [sp, #0x8]
 800ab46: 2300         	movs	r3, #0x0
 800ab48: 9301         	str	r3, [sp, #0x4]
 800ab4a: 2300         	movs	r3, #0x0
 800ab4c: 9300         	str	r3, [sp]
 800ab4e: 2300         	movs	r3, #0x0
 800ab50: 2201         	movs	r2, #0x1
 800ab52: 2000         	movs	r0, #0x0
 800ab54: f00d fbf7    	bl	0x8018346 <z_log_msg_runtime_create> @ imm = #0xd7ee
 800ab58: 2300         	movs	r3, #0x0
 800ab5a: 61bb         	str	r3, [r7, #0x18]
; }
 800ab5c: e7ff         	b	0x800ab5e <dm_motor_control+0x1fa> @ imm = #-0x2
 800ab5e: bf00         	nop
 800ab60: 3734         	adds	r7, #0x34
 800ab62: 46bd         	mov	sp, r7
 800ab64: bd90         	pop	{r4, r7, pc}
 800ab66: bf00         	nop

0800ab68 <$d>:
 800ab68: c0 d7 01 08  	.word	0x0801d7c0
 800ab6c: 7c 10 00 20  	.word	0x2000107c
 800ab70: eb 84 01 08  	.word	0x080184eb
 800ab74: c8 d7 01 08  	.word	0x0801d7c8
 800ab78: d0 d7 01 08  	.word	0x0801d7d0
 800ab7c: d8 d7 01 08  	.word	0x0801d7d8
 800ab80: 14 05 00 20  	.word	0x20000514
 800ab84: e0 c8 01 08  	.word	0x0801c8e0

0800ab88 <dm_motor_pack>:
; {
 800ab88: b580         	push	{r7, lr}
 800ab8a: b08a         	sub	sp, #0x28
 800ab8c: af00         	add	r7, sp, #0x0
 800ab8e: 6078         	str	r0, [r7, #0x4]
 800ab90: 6039         	str	r1, [r7]
; 	struct dm_motor_data *data = dev->data;
 800ab92: 687b         	ldr	r3, [r7, #0x4]
 800ab94: 691b         	ldr	r3, [r3, #0x10]
 800ab96: 627b         	str	r3, [r7, #0x24]
; 	const struct dm_motor_config *cfg = dev->config;
 800ab98: 687b         	ldr	r3, [r7, #0x4]
 800ab9a: 685b         	ldr	r3, [r3, #0x4]
 800ab9c: 623b         	str	r3, [r7, #0x20]
; 	frame->id = cfg->common.tx_id + data->tx_offset;
 800ab9e: 6a3b         	ldr	r3, [r7, #0x20]
 800aba0: 689a         	ldr	r2, [r3, #0x8]
 800aba2: 6a7b         	ldr	r3, [r7, #0x24]
 800aba4: 699b         	ldr	r3, [r3, #0x18]
 800aba6: 4413         	add	r3, r2
 800aba8: 461a         	mov	r2, r3
 800abaa: 683b         	ldr	r3, [r7]
 800abac: 601a         	str	r2, [r3]
; 	frame->dlc = 8;
 800abae: 683b         	ldr	r3, [r7]
 800abb0: 2208         	movs	r2, #0x8
 800abb2: 711a         	strb	r2, [r3, #0x4]
; 	frame->flags = 0;
 800abb4: 683b         	ldr	r3, [r7]
 800abb6: 2200         	movs	r2, #0x0
 800abb8: 715a         	strb	r2, [r3, #0x5]
; 	switch (data->common.mode) {
 800abba: 6a7b         	ldr	r3, [r7, #0x24]
 800abbc: 7d1b         	ldrb	r3, [r3, #0x14]
 800abbe: 2b02         	cmp	r3, #0x2
 800abc0: f000 8090    	beq.w	0x800ace4 <dm_motor_pack+0x15c> @ imm = #0x120
 800abc4: 2b02         	cmp	r3, #0x2
 800abc6: f300 8096    	bgt.w	0x800acf6 <dm_motor_pack+0x16e> @ imm = #0x12c
 800abca: 2b00         	cmp	r3, #0x0
 800abcc: d002         	beq	0x800abd4 <dm_motor_pack+0x4c> @ imm = #0x4
 800abce: 2b01         	cmp	r3, #0x1
 800abd0: d072         	beq	0x800acb8 <dm_motor_pack+0x130> @ imm = #0xe4
; 		break;
 800abd2: e090         	b	0x800acf6 <dm_motor_pack+0x16e> @ imm = #0x120
; 		pos_tmp = float_to_uint(data->target_angle, -cfg->p_max, cfg->p_max, 16);
 800abd4: 6a7b         	ldr	r3, [r7, #0x24]
 800abd6: 6a58         	ldr	r0, [r3, #0x24]
 800abd8: 6a3b         	ldr	r3, [r7, #0x20]
 800abda: 6d9b         	ldr	r3, [r3, #0x58]
 800abdc: f083 4100    	eor	r1, r3, #0x80000000
 800abe0: 6a3b         	ldr	r3, [r7, #0x20]
 800abe2: 6d9a         	ldr	r2, [r3, #0x58]
 800abe4: 2310         	movs	r3, #0x10
 800abe6: f00d fc50    	bl	0x801848a <float_to_uint> @ imm = #0xd8a0
 800abea: 4603         	mov	r3, r0
 800abec: 82fb         	strh	r3, [r7, #0x16]
; 		vel_tmp = float_to_uint(data->target_rpm, -cfg->v_max, cfg->v_max, 12);
 800abee: 6a7b         	ldr	r3, [r7, #0x24]
 800abf0: 6a98         	ldr	r0, [r3, #0x28]
 800abf2: 6a3b         	ldr	r3, [r7, #0x20]
 800abf4: 6d5b         	ldr	r3, [r3, #0x54]
 800abf6: f083 4100    	eor	r1, r3, #0x80000000
 800abfa: 6a3b         	ldr	r3, [r7, #0x20]
 800abfc: 6d5a         	ldr	r2, [r3, #0x54]
 800abfe: 230c         	movs	r3, #0xc
 800ac00: f00d fc43    	bl	0x801848a <float_to_uint> @ imm = #0xd886
 800ac04: 4603         	mov	r3, r0
 800ac06: 82bb         	strh	r3, [r7, #0x14]
; 		tor_tmp = float_to_uint(data->target_torque, -cfg->t_max, cfg->t_max, 12);
 800ac08: 6a7b         	ldr	r3, [r7, #0x24]
 800ac0a: 6ad8         	ldr	r0, [r3, #0x2c]
 800ac0c: 6a3b         	ldr	r3, [r7, #0x20]
 800ac0e: 6ddb         	ldr	r3, [r3, #0x5c]
 800ac10: f083 4100    	eor	r1, r3, #0x80000000
 800ac14: 6a3b         	ldr	r3, [r7, #0x20]
 800ac16: 6dda         	ldr	r2, [r3, #0x5c]
 800ac18: 230c         	movs	r3, #0xc
 800ac1a: f00d fc36    	bl	0x801848a <float_to_uint> @ imm = #0xd86c
 800ac1e: 4603         	mov	r3, r0
 800ac20: 827b         	strh	r3, [r7, #0x12]
; 		kp_tmp = float_to_uint(data->params.k_p, 0, 500, 12);
 800ac22: 6a7b         	ldr	r3, [r7, #0x24]
 800ac24: 6b98         	ldr	r0, [r3, #0x38]
 800ac26: 230c         	movs	r3, #0xc
 800ac28: 4a35         	ldr	r2, [pc, #0xd4]         @ 0x800ad00 <dm_motor_pack+0x178>
 800ac2a: f04f 0100    	mov.w	r1, #0x0
 800ac2e: f00d fc2c    	bl	0x801848a <float_to_uint> @ imm = #0xd858
 800ac32: 4603         	mov	r3, r0
 800ac34: 823b         	strh	r3, [r7, #0x10]
; 		kd_tmp = float_to_uint(data->params.k_d, 0, 5, 12);
 800ac36: 6a7b         	ldr	r3, [r7, #0x24]
 800ac38: 6c18         	ldr	r0, [r3, #0x40]
 800ac3a: 230c         	movs	r3, #0xc
 800ac3c: 4a31         	ldr	r2, [pc, #0xc4]         @ 0x800ad04 <dm_motor_pack+0x17c>
 800ac3e: f04f 0100    	mov.w	r1, #0x0
 800ac42: f00d fc22    	bl	0x801848a <float_to_uint> @ imm = #0xd844
 800ac46: 4603         	mov	r3, r0
 800ac48: 81fb         	strh	r3, [r7, #0xe]
; 		frame->data[0] = (pos_tmp >> 8);
 800ac4a: 8afb         	ldrh	r3, [r7, #0x16]
 800ac4c: 0a1b         	lsrs	r3, r3, #0x8
 800ac4e: b29b         	uxth	r3, r3
 800ac50: b2da         	uxtb	r2, r3
 800ac52: 683b         	ldr	r3, [r7]
 800ac54: 721a         	strb	r2, [r3, #0x8]
; 		frame->data[1] = pos_tmp;
 800ac56: 8afb         	ldrh	r3, [r7, #0x16]
 800ac58: b2da         	uxtb	r2, r3
 800ac5a: 683b         	ldr	r3, [r7]
 800ac5c: 725a         	strb	r2, [r3, #0x9]
; 		frame->data[2] = (vel_tmp >> 4);
 800ac5e: 8abb         	ldrh	r3, [r7, #0x14]
 800ac60: 091b         	lsrs	r3, r3, #0x4
 800ac62: b29b         	uxth	r3, r3
 800ac64: b2da         	uxtb	r2, r3
 800ac66: 683b         	ldr	r3, [r7]
 800ac68: 729a         	strb	r2, [r3, #0xa]
; 		frame->data[3] = ((vel_tmp & 0xF) << 4) | (kp_tmp >> 8);
 800ac6a: 8abb         	ldrh	r3, [r7, #0x14]
 800ac6c: 011b         	lsls	r3, r3, #0x4
 800ac6e: b25a         	sxtb	r2, r3
 800ac70: 8a3b         	ldrh	r3, [r7, #0x10]
 800ac72: 0a1b         	lsrs	r3, r3, #0x8
 800ac74: b29b         	uxth	r3, r3
 800ac76: b25b         	sxtb	r3, r3
 800ac78: 4313         	orrs	r3, r2
 800ac7a: b25b         	sxtb	r3, r3
 800ac7c: b2da         	uxtb	r2, r3
 800ac7e: 683b         	ldr	r3, [r7]
 800ac80: 72da         	strb	r2, [r3, #0xb]
; 		frame->data[4] = kp_tmp;
 800ac82: 8a3b         	ldrh	r3, [r7, #0x10]
 800ac84: b2da         	uxtb	r2, r3
 800ac86: 683b         	ldr	r3, [r7]
 800ac88: 731a         	strb	r2, [r3, #0xc]
; 		frame->data[5] = (kd_tmp >> 4);
 800ac8a: 89fb         	ldrh	r3, [r7, #0xe]
 800ac8c: 091b         	lsrs	r3, r3, #0x4
 800ac8e: b29b         	uxth	r3, r3
 800ac90: b2da         	uxtb	r2, r3
 800ac92: 683b         	ldr	r3, [r7]
 800ac94: 735a         	strb	r2, [r3, #0xd]
; 		frame->data[6] = ((kd_tmp & 0xF) << 4) | (tor_tmp >> 8);
 800ac96: 89fb         	ldrh	r3, [r7, #0xe]
 800ac98: 011b         	lsls	r3, r3, #0x4
 800ac9a: b25a         	sxtb	r2, r3
 800ac9c: 8a7b         	ldrh	r3, [r7, #0x12]
 800ac9e: 0a1b         	lsrs	r3, r3, #0x8
 800aca0: b29b         	uxth	r3, r3
 800aca2: b25b         	sxtb	r3, r3
 800aca4: 4313         	orrs	r3, r2
 800aca6: b25b         	sxtb	r3, r3
 800aca8: b2da         	uxtb	r2, r3
 800acaa: 683b         	ldr	r3, [r7]
 800acac: 739a         	strb	r2, [r3, #0xe]
; 		frame->data[7] = tor_tmp;
 800acae: 8a7b         	ldrh	r3, [r7, #0x12]
 800acb0: b2da         	uxtb	r2, r3
 800acb2: 683b         	ldr	r3, [r7]
 800acb4: 73da         	strb	r2, [r3, #0xf]
; 		break;
 800acb6: e01f         	b	0x800acf8 <dm_motor_pack+0x170> @ imm = #0x3e
; 		pbuf = (uint8_t *)&data->target_angle;
 800acb8: 6a7b         	ldr	r3, [r7, #0x24]
 800acba: 3324         	adds	r3, #0x24
 800acbc: 61bb         	str	r3, [r7, #0x18]
; 		vbuf = (uint8_t *)&data->target_rpm;
 800acbe: 6a7b         	ldr	r3, [r7, #0x24]
 800acc0: 3328         	adds	r3, #0x28
 800acc2: 61fb         	str	r3, [r7, #0x1c]
; 		frame->data[0] = *pbuf;
 800acc4: 69bb         	ldr	r3, [r7, #0x18]
 800acc6: 781a         	ldrb	r2, [r3]
 800acc8: 683b         	ldr	r3, [r7]
 800acca: 721a         	strb	r2, [r3, #0x8]
; 		memcpy(frame->data, pbuf, 4);
 800accc: 683b         	ldr	r3, [r7]
 800acce: 3308         	adds	r3, #0x8
 800acd0: 69ba         	ldr	r2, [r7, #0x18]
 800acd2: 6812         	ldr	r2, [r2]
 800acd4: 601a         	str	r2, [r3]
; 		memcpy(frame->data + 4, vbuf, 4);
 800acd6: 683b         	ldr	r3, [r7]
 800acd8: 3308         	adds	r3, #0x8
 800acda: 3304         	adds	r3, #0x4
 800acdc: 69fa         	ldr	r2, [r7, #0x1c]
 800acde: 6812         	ldr	r2, [r2]
 800ace0: 601a         	str	r2, [r3]
; 		break;
 800ace2: e009         	b	0x800acf8 <dm_motor_pack+0x170> @ imm = #0x12
; 		vbuf = (uint8_t *)&data->target_rpm;
 800ace4: 6a7b         	ldr	r3, [r7, #0x24]
 800ace6: 3328         	adds	r3, #0x28
 800ace8: 61fb         	str	r3, [r7, #0x1c]
; 		memcpy(frame->data, vbuf, 4);
 800acea: 683b         	ldr	r3, [r7]
 800acec: 3308         	adds	r3, #0x8
 800acee: 69fa         	ldr	r2, [r7, #0x1c]
 800acf0: 6812         	ldr	r2, [r2]
 800acf2: 601a         	str	r2, [r3]
; 		break;
 800acf4: e000         	b	0x800acf8 <dm_motor_pack+0x170> @ imm = #0x0
; 		break;
 800acf6: bf00         	nop
; }
 800acf8: bf00         	nop
 800acfa: 3728         	adds	r7, #0x28
 800acfc: 46bd         	mov	sp, r7
 800acfe: bd80         	pop	{r7, pc}

0800ad00 <$d>:
 800ad00: 00 00 fa 43  	.word	0x43fa0000
 800ad04: 00 00 a0 40  	.word	0x40a00000

0800ad08 <dm_motor_set_mode>:
; {
 800ad08: b580         	push	{r7, lr}
 800ad0a: b08a         	sub	sp, #0x28
 800ad0c: af00         	add	r7, sp, #0x0
 800ad0e: 6078         	str	r0, [r7, #0x4]
 800ad10: 460b         	mov	r3, r1
 800ad12: 70fb         	strb	r3, [r7, #0x3]
; 	struct dm_motor_data *data = dev->data;
 800ad14: 687b         	ldr	r3, [r7, #0x4]
 800ad16: 691b         	ldr	r3, [r3, #0x10]
 800ad18: 623b         	str	r3, [r7, #0x20]
; 	const struct dm_motor_config *cfg = dev->config;
 800ad1a: 687b         	ldr	r3, [r7, #0x4]
 800ad1c: 685b         	ldr	r3, [r3, #0x4]
 800ad1e: 61fb         	str	r3, [r7, #0x1c]
; 	data->common.mode = mode;
 800ad20: 6a3b         	ldr	r3, [r7, #0x20]
 800ad22: 78fa         	ldrb	r2, [r7, #0x3]
 800ad24: 751a         	strb	r2, [r3, #0x14]
; 	switch (mode) {
 800ad26: 78fb         	ldrb	r3, [r7, #0x3]
 800ad28: 2b03         	cmp	r3, #0x3
 800ad2a: d835         	bhi	0x800ad98 <dm_motor_set_mode+0x90> @ imm = #0x6a
 800ad2c: a201         	adr	r2, #4 <dm_motor_set_mode+0x29>
 800ad2e: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 800ad32: bf00         	nop

0800ad34 <$d>:
 800ad34: 45 ad 00 08  	.word	0x0800ad45
 800ad38: 55 ad 00 08  	.word	0x0800ad55
 800ad3c: 71 ad 00 08  	.word	0x0800ad71
 800ad40: 8d ad 00 08  	.word	0x0800ad8d

0800ad44 <$t>:
; 		strcpy(mode_str, "mit");
 800ad44: f107 030c    	add.w	r3, r7, #0xc
 800ad48: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x800ae14 <dm_motor_set_mode+0x10c>
 800ad4a: 601a         	str	r2, [r3]
; 		data->tx_offset = 0x0;
 800ad4c: 6a3b         	ldr	r3, [r7, #0x20]
 800ad4e: 2200         	movs	r2, #0x0
 800ad50: 619a         	str	r2, [r3, #0x18]
; 		break;
 800ad52: e022         	b	0x800ad9a <dm_motor_set_mode+0x92> @ imm = #0x44
; 		strcpy(mode_str, "pv");
 800ad54: f107 030c    	add.w	r3, r7, #0xc
 800ad58: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x800ae18 <dm_motor_set_mode+0x110>
 800ad5a: 6812         	ldr	r2, [r2]
 800ad5c: 4611         	mov	r1, r2
 800ad5e: 8019         	strh	r1, [r3]
 800ad60: 3302         	adds	r3, #0x2
 800ad62: 0c12         	lsrs	r2, r2, #0x10
 800ad64: 701a         	strb	r2, [r3]
; 		data->tx_offset = 0x100;
 800ad66: 6a3b         	ldr	r3, [r7, #0x20]
 800ad68: f44f 7280    	mov.w	r2, #0x100
 800ad6c: 619a         	str	r2, [r3, #0x18]
; 		break;
 800ad6e: e014         	b	0x800ad9a <dm_motor_set_mode+0x92> @ imm = #0x28
; 		strcpy(mode_str, "vo");
 800ad70: f107 030c    	add.w	r3, r7, #0xc
 800ad74: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x800ae1c <dm_motor_set_mode+0x114>
 800ad76: 6812         	ldr	r2, [r2]
 800ad78: 4611         	mov	r1, r2
 800ad7a: 8019         	strh	r1, [r3]
 800ad7c: 3302         	adds	r3, #0x2
 800ad7e: 0c12         	lsrs	r2, r2, #0x10
 800ad80: 701a         	strb	r2, [r3]
; 		data->tx_offset = 0x200;
 800ad82: 6a3b         	ldr	r3, [r7, #0x20]
 800ad84: f44f 7200    	mov.w	r2, #0x200
 800ad88: 619a         	str	r2, [r3, #0x18]
; 		break;
 800ad8a: e006         	b	0x800ad9a <dm_motor_set_mode+0x92> @ imm = #0xc
; 		data->online = false;
 800ad8c: 6a3b         	ldr	r3, [r7, #0x20]
 800ad8e: 2200         	movs	r2, #0x0
 800ad90: 771a         	strb	r2, [r3, #0x1c]
; 		return -ENOSYS;
 800ad92: f06f 0357    	mvn	r3, #0x57
 800ad96: e039         	b	0x800ae0c <dm_motor_set_mode+0x104> @ imm = #0x72
; 		break;
 800ad98: bf00         	nop
; 	for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.controller); i++) {
 800ad9a: 2300         	movs	r3, #0x0
 800ad9c: 627b         	str	r3, [r7, #0x24]
 800ad9e: e02f         	b	0x800ae00 <dm_motor_set_mode+0xf8> @ imm = #0x5e
; 		if (cfg->common.controller[i] == NULL) {
 800ada0: 69fb         	ldr	r3, [r7, #0x1c]
 800ada2: 6a7a         	ldr	r2, [r7, #0x24]
 800ada4: 3204         	adds	r2, #0x4
 800ada6: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800adaa: 2b00         	cmp	r3, #0x0
 800adac: d02c         	beq	0x800ae08 <dm_motor_set_mode+0x100> @ imm = #0x58
; 		if (strcmp(cfg->common.capabilities[i], mode_str) == 0) {
 800adae: 6a7a         	ldr	r2, [r7, #0x24]
 800adb0: 4613         	mov	r3, r2
 800adb2: 005b         	lsls	r3, r3, #0x1
 800adb4: 4413         	add	r3, r2
 800adb6: 009b         	lsls	r3, r3, #0x2
 800adb8: 3320         	adds	r3, #0x20
 800adba: 69fa         	ldr	r2, [r7, #0x1c]
 800adbc: 4413         	add	r3, r2
 800adbe: f107 020c    	add.w	r2, r7, #0xc
 800adc2: 4611         	mov	r1, r2
 800adc4: 4618         	mov	r0, r3
 800adc6: f7f5 feaf    	bl	0x8000b28 <strcmp>      @ imm = #-0xa2a2
 800adca: 4603         	mov	r3, r0
 800adcc: 2b00         	cmp	r3, #0x0
 800adce: d114         	bne	0x800adfa <dm_motor_set_mode+0xf2> @ imm = #0x28
; 				pid_get_params(cfg->common.controller[i]);
 800add0: 69fb         	ldr	r3, [r7, #0x1c]
 800add2: 6a7a         	ldr	r2, [r7, #0x24]
 800add4: 3204         	adds	r2, #0x4
 800add6: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800adda: 4618         	mov	r0, r3
 800addc: f00d fae7    	bl	0x80183ae <pid_get_params> @ imm = #0xd5ce
 800ade0: 61b8         	str	r0, [r7, #0x18]
; 			data->common.mode = mode;
 800ade2: 6a3b         	ldr	r3, [r7, #0x20]
 800ade4: 78fa         	ldrb	r2, [r7, #0x3]
 800ade6: 751a         	strb	r2, [r3, #0x14]
; 			data->params.k_p = params->k_p;
 800ade8: 69bb         	ldr	r3, [r7, #0x18]
 800adea: 681a         	ldr	r2, [r3]
 800adec: 6a3b         	ldr	r3, [r7, #0x20]
 800adee: 639a         	str	r2, [r3, #0x38]
; 			data->params.k_d = params->k_d;
 800adf0: 69bb         	ldr	r3, [r7, #0x18]
 800adf2: 689a         	ldr	r2, [r3, #0x8]
 800adf4: 6a3b         	ldr	r3, [r7, #0x20]
 800adf6: 641a         	str	r2, [r3, #0x40]
; 			break;
 800adf8: e007         	b	0x800ae0a <dm_motor_set_mode+0x102> @ imm = #0xe
; 	for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.controller); i++) {
 800adfa: 6a7b         	ldr	r3, [r7, #0x24]
 800adfc: 3301         	adds	r3, #0x1
 800adfe: 627b         	str	r3, [r7, #0x24]
 800ae00: 6a7b         	ldr	r3, [r7, #0x24]
 800ae02: 2b03         	cmp	r3, #0x3
 800ae04: d9cc         	bls	0x800ada0 <dm_motor_set_mode+0x98> @ imm = #-0x68
 800ae06: e000         	b	0x800ae0a <dm_motor_set_mode+0x102> @ imm = #0x0
; 			break;
 800ae08: bf00         	nop
; 	return 0;
 800ae0a: 2300         	movs	r3, #0x0
; }
 800ae0c: 4618         	mov	r0, r3
 800ae0e: 3728         	adds	r7, #0x28
 800ae10: 46bd         	mov	sp, r7
 800ae12: bd80         	pop	{r7, pc}

0800ae14 <$d>:
 800ae14: 6d 69 74 00  	.word	0x0074696d
 800ae18: 00 c9 01 08  	.word	0x0801c900
 800ae1c: 04 c9 01 08  	.word	0x0801c904

0800ae20 <get_motor_id>:
; {
 800ae20: b480         	push	{r7}
 800ae22: b087         	sub	sp, #0x1c
 800ae24: af00         	add	r7, sp, #0x0
 800ae26: 6078         	str	r0, [r7, #0x4]
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 800ae28: 2300         	movs	r3, #0x0
 800ae2a: 617b         	str	r3, [r7, #0x14]
 800ae2c: e011         	b	0x800ae52 <get_motor_id+0x32> @ imm = #0x22
; 		const struct device *dev = motor_devices[i];
 800ae2e: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800ae68 <get_motor_id+0x48>
 800ae30: 697b         	ldr	r3, [r7, #0x14]
 800ae32: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800ae36: 613b         	str	r3, [r7, #0x10]
; 		const struct dm_motor_config *cfg = (const struct dm_motor_config *)(dev->config);
 800ae38: 693b         	ldr	r3, [r7, #0x10]
 800ae3a: 685b         	ldr	r3, [r3, #0x4]
 800ae3c: 60fb         	str	r3, [r7, #0xc]
; 		if (cfg->common.rx_id == id) {
 800ae3e: 68fb         	ldr	r3, [r7, #0xc]
 800ae40: 68db         	ldr	r3, [r3, #0xc]
 800ae42: 687a         	ldr	r2, [r7, #0x4]
 800ae44: 429a         	cmp	r2, r3
 800ae46: d101         	bne	0x800ae4c <get_motor_id+0x2c> @ imm = #0x2
; 			return i;
 800ae48: 697b         	ldr	r3, [r7, #0x14]
 800ae4a: e007         	b	0x800ae5c <get_motor_id+0x3c> @ imm = #0xe
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 800ae4c: 697b         	ldr	r3, [r7, #0x14]
 800ae4e: 3301         	adds	r3, #0x1
 800ae50: 617b         	str	r3, [r7, #0x14]
 800ae52: 697b         	ldr	r3, [r7, #0x14]
 800ae54: 2b00         	cmp	r3, #0x0
 800ae56: ddea         	ble	0x800ae2e <get_motor_id+0xe> @ imm = #-0x2c
; 	return -1;
 800ae58: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 800ae5c: 4618         	mov	r0, r3
 800ae5e: 371c         	adds	r7, #0x1c
 800ae60: 46bd         	mov	sp, r7
 800ae62: bc80         	pop	{r7}
 800ae64: 4770         	bx	lr
 800ae66: bf00         	nop

0800ae68 <$d>:
 800ae68: d8 04 00 20  	.word	0x200004d8

0800ae6c <dm_can_rx_handler>:
; {
 800ae6c: b580         	push	{r7, lr}
 800ae6e: b08e         	sub	sp, #0x38
 800ae70: af04         	add	r7, sp, #0x10
 800ae72: 60f8         	str	r0, [r7, #0xc]
 800ae74: 60b9         	str	r1, [r7, #0x8]
 800ae76: 607a         	str	r2, [r7, #0x4]
; 	int id = get_motor_id(frame->id);
 800ae78: 68bb         	ldr	r3, [r7, #0x8]
 800ae7a: 681b         	ldr	r3, [r3]
 800ae7c: 4618         	mov	r0, r3
 800ae7e: f7ff ffcf    	bl	0x800ae20 <get_motor_id> @ imm = #-0x62
 800ae82: 6278         	str	r0, [r7, #0x24]
; 	if (id == -1) {
 800ae84: 6a7b         	ldr	r3, [r7, #0x24]
 800ae86: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800ae8a: d11e         	bne	0x800aeca <dm_can_rx_handler+0x5e> @ imm = #0x3c
; 		LOG_ERR("Unknown motor ID: %d", frame->id);
 800ae8c: 2304         	movs	r3, #0x4
 800ae8e: 2b00         	cmp	r3, #0x0
 800ae90: d01a         	beq	0x800aec8 <dm_can_rx_handler+0x5c> @ imm = #0x34
 800ae92: 2301         	movs	r3, #0x1
 800ae94: 75fb         	strb	r3, [r7, #0x17]
 800ae96: 7dfb         	ldrb	r3, [r7, #0x17]
 800ae98: f083 0301    	eor	r3, r3, #0x1
 800ae9c: b2db         	uxtb	r3, r3
 800ae9e: 2b00         	cmp	r3, #0x0
 800aea0: d112         	bne	0x800aec8 <dm_can_rx_handler+0x5c> @ imm = #0x24
 800aea2: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x800afa0 <dm_can_rx_handler+0x134>
 800aea4: 6819         	ldr	r1, [r3]
 800aea6: 68bb         	ldr	r3, [r7, #0x8]
 800aea8: 681b         	ldr	r3, [r3]
 800aeaa: 9303         	str	r3, [sp, #0xc]
 800aeac: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x800afa4 <dm_can_rx_handler+0x138>
 800aeae: 9302         	str	r3, [sp, #0x8]
 800aeb0: 2300         	movs	r3, #0x0
 800aeb2: 9301         	str	r3, [sp, #0x4]
 800aeb4: 2300         	movs	r3, #0x0
 800aeb6: 9300         	str	r3, [sp]
 800aeb8: 2300         	movs	r3, #0x0
 800aeba: 2201         	movs	r2, #0x1
 800aebc: 2000         	movs	r0, #0x0
 800aebe: f00d fa42    	bl	0x8018346 <z_log_msg_runtime_create> @ imm = #0xd484
 800aec2: 2300         	movs	r3, #0x0
 800aec4: 613b         	str	r3, [r7, #0x10]
; 		return;
 800aec6: e067         	b	0x800af98 <dm_can_rx_handler+0x12c> @ imm = #0xce
 800aec8: e066         	b	0x800af98 <dm_can_rx_handler+0x12c> @ imm = #0xcc
; 	struct dm_motor_data *data = (struct dm_motor_data *)(motor_devices[id]->data);
 800aeca: 4a37         	ldr	r2, [pc, #0xdc]         @ 0x800afa8 <dm_can_rx_handler+0x13c>
 800aecc: 6a7b         	ldr	r3, [r7, #0x24]
 800aece: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800aed2: 691b         	ldr	r3, [r3, #0x10]
 800aed4: 623b         	str	r3, [r7, #0x20]
; 	if (data->missed_times > 0) {
 800aed6: 6a3b         	ldr	r3, [r7, #0x20]
 800aed8: f993 301e    	ldrsb.w	r3, [r3, #0x1e]
 800aedc: 2b00         	cmp	r3, #0x0
 800aede: dd2c         	ble	0x800af3a <dm_can_rx_handler+0xce> @ imm = #0x58
; 		data->missed_times--;
 800aee0: 6a3b         	ldr	r3, [r7, #0x20]
 800aee2: f993 301e    	ldrsb.w	r3, [r3, #0x1e]
 800aee6: b2db         	uxtb	r3, r3
 800aee8: 3b01         	subs	r3, #0x1
 800aeea: b2db         	uxtb	r3, r3
 800aeec: b25a         	sxtb	r2, r3
 800aeee: 6a3b         	ldr	r3, [r7, #0x20]
 800aef0: 779a         	strb	r2, [r3, #0x1e]
; 		if (data->missed_times == 0) {
 800aef2: 6a3b         	ldr	r3, [r7, #0x20]
 800aef4: f993 301e    	ldrsb.w	r3, [r3, #0x1e]
 800aef8: 2b00         	cmp	r3, #0x0
 800aefa: d11e         	bne	0x800af3a <dm_can_rx_handler+0xce> @ imm = #0x3c
; 			LOG_INF("Motor %d is back online", id);
 800aefc: 2304         	movs	r3, #0x4
 800aefe: 2b02         	cmp	r3, #0x2
 800af00: d918         	bls	0x800af34 <dm_can_rx_handler+0xc8> @ imm = #0x30
 800af02: 2301         	movs	r3, #0x1
 800af04: 77fb         	strb	r3, [r7, #0x1f]
 800af06: 7ffb         	ldrb	r3, [r7, #0x1f]
 800af08: f083 0301    	eor	r3, r3, #0x1
 800af0c: b2db         	uxtb	r3, r3
 800af0e: 2b00         	cmp	r3, #0x0
 800af10: d110         	bne	0x800af34 <dm_can_rx_handler+0xc8> @ imm = #0x20
 800af12: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800afa0 <dm_can_rx_handler+0x134>
 800af14: 6819         	ldr	r1, [r3]
 800af16: 6a7b         	ldr	r3, [r7, #0x24]
 800af18: 9303         	str	r3, [sp, #0xc]
 800af1a: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800afac <dm_can_rx_handler+0x140>
 800af1c: 9302         	str	r3, [sp, #0x8]
 800af1e: 2300         	movs	r3, #0x0
 800af20: 9301         	str	r3, [sp, #0x4]
 800af22: 2300         	movs	r3, #0x0
 800af24: 9300         	str	r3, [sp]
 800af26: 2300         	movs	r3, #0x0
 800af28: 2203         	movs	r2, #0x3
 800af2a: 2000         	movs	r0, #0x0
 800af2c: f00d fa0b    	bl	0x8018346 <z_log_msg_runtime_create> @ imm = #0xd416
 800af30: 2300         	movs	r3, #0x0
 800af32: 61bb         	str	r3, [r7, #0x18]
; 			data->online = true;
 800af34: 6a3b         	ldr	r3, [r7, #0x20]
 800af36: 2201         	movs	r2, #0x1
 800af38: 771a         	strb	r2, [r3, #0x1c]
; 	data->err = frame->data[0] >> 4;
 800af3a: 68bb         	ldr	r3, [r7, #0x8]
 800af3c: 7a1b         	ldrb	r3, [r3, #0x8]
 800af3e: 091b         	lsrs	r3, r3, #0x4
 800af40: b2db         	uxtb	r3, r3
 800af42: b25a         	sxtb	r2, r3
 800af44: 6a3b         	ldr	r3, [r7, #0x20]
 800af46: 77da         	strb	r2, [r3, #0x1f]
; 	data->RAWangle = (frame->data[1] << 8) | (frame->data[2]);
 800af48: 68bb         	ldr	r3, [r7, #0x8]
 800af4a: 7a5b         	ldrb	r3, [r3, #0x9]
 800af4c: 021b         	lsls	r3, r3, #0x8
 800af4e: b21a         	sxth	r2, r3
 800af50: 68bb         	ldr	r3, [r7, #0x8]
 800af52: 7a9b         	ldrb	r3, [r3, #0xa]
 800af54: b21b         	sxth	r3, r3
 800af56: 4313         	orrs	r3, r2
 800af58: b21a         	sxth	r2, r3
 800af5a: 6a3b         	ldr	r3, [r7, #0x20]
 800af5c: 861a         	strh	r2, [r3, #0x30]
; 	data->RAWrpm = (frame->data[3] << 4) | (frame->data[4] >> 4);
 800af5e: 68bb         	ldr	r3, [r7, #0x8]
 800af60: 7adb         	ldrb	r3, [r3, #0xb]
 800af62: 011b         	lsls	r3, r3, #0x4
 800af64: b21a         	sxth	r2, r3
 800af66: 68bb         	ldr	r3, [r7, #0x8]
 800af68: 7b1b         	ldrb	r3, [r3, #0xc]
 800af6a: 091b         	lsrs	r3, r3, #0x4
 800af6c: b2db         	uxtb	r3, r3
 800af6e: b21b         	sxth	r3, r3
 800af70: 4313         	orrs	r3, r2
 800af72: b21a         	sxth	r2, r3
 800af74: 6a3b         	ldr	r3, [r7, #0x20]
 800af76: 865a         	strh	r2, [r3, #0x32]
; 	data->RAWtorque = (frame->data[4] & 0xF) << 8;
 800af78: 68bb         	ldr	r3, [r7, #0x8]
 800af7a: 7b1b         	ldrb	r3, [r3, #0xc]
 800af7c: 021b         	lsls	r3, r3, #0x8
 800af7e: b21b         	sxth	r3, r3
 800af80: f403 6370    	and	r3, r3, #0xf00
 800af84: b21a         	sxth	r2, r3
 800af86: 6a3b         	ldr	r3, [r7, #0x20]
 800af88: 869a         	strh	r2, [r3, #0x34]
; 	data->update = true;
 800af8a: 6a3b         	ldr	r3, [r7, #0x20]
 800af8c: 2201         	movs	r2, #0x1
 800af8e: 775a         	strb	r2, [r3, #0x1d]
; 	k_work_submit_to_queue(&dm_work_queue, &dm_rx_data_handle);
 800af90: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800afb0 <dm_can_rx_handler+0x144>
 800af92: 4808         	ldr	r0, [pc, #0x20]         @ 0x800afb4 <dm_can_rx_handler+0x148>
 800af94: f00e fc54    	bl	0x8019840 <k_work_submit_to_queue> @ imm = #0xe8a8
; }
 800af98: 3728         	adds	r7, #0x28
 800af9a: 46bd         	mov	sp, r7
 800af9c: bd80         	pop	{r7, pc}
 800af9e: bf00         	nop

0800afa0 <$d>:
 800afa0: 14 05 00 20  	.word	0x20000514
 800afa4: 08 c9 01 08  	.word	0x0801c908
 800afa8: d8 04 00 20  	.word	0x200004d8
 800afac: 20 c9 01 08  	.word	0x0801c920
 800afb0: e4 04 00 20  	.word	0x200004e4
 800afb4: 40 06 00 20  	.word	0x20000640

0800afb8 <dm_rx_data_handler>:
; {
 800afb8: b590         	push	{r4, r7, lr}
 800afba: b087         	sub	sp, #0x1c
 800afbc: af00         	add	r7, sp, #0x0
 800afbe: 6078         	str	r0, [r7, #0x4]
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 800afc0: 2300         	movs	r3, #0x0
 800afc2: 617b         	str	r3, [r7, #0x14]
 800afc4: e09b         	b	0x800b0fe <dm_rx_data_handler+0x146> @ imm = #0x136
; 		struct dm_motor_data *data = (struct dm_motor_data *)(motor_devices[i]->data);
 800afc6: 4a52         	ldr	r2, [pc, #0x148]        @ 0x800b110 <dm_rx_data_handler+0x158>
 800afc8: 697b         	ldr	r3, [r7, #0x14]
 800afca: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800afce: 691b         	ldr	r3, [r3, #0x10]
 800afd0: 613b         	str	r3, [r7, #0x10]
; 		if (!data->update) {
 800afd2: 693b         	ldr	r3, [r7, #0x10]
 800afd4: 7f5b         	ldrb	r3, [r3, #0x1d]
 800afd6: f083 0301    	eor	r3, r3, #0x1
 800afda: b2db         	uxtb	r3, r3
 800afdc: 2b00         	cmp	r3, #0x0
 800afde: f040 808a    	bne.w	0x800b0f6 <dm_rx_data_handler+0x13e> @ imm = #0x114
; 			(const struct dm_motor_config *)(motor_devices[i]->config);
 800afe2: 4a4b         	ldr	r2, [pc, #0x12c]        @ 0x800b110 <dm_rx_data_handler+0x158>
 800afe4: 697b         	ldr	r3, [r7, #0x14]
 800afe6: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; 		const struct dm_motor_config *cfg =
 800afea: 685b         	ldr	r3, [r3, #0x4]
 800afec: 60fb         	str	r3, [r7, #0xc]
; 		float prev_angle = data->common.angle;
 800afee: 693b         	ldr	r3, [r7, #0x10]
 800aff0: 681b         	ldr	r3, [r3]
 800aff2: 60bb         	str	r3, [r7, #0x8]
; 			(uint_to_float(data->RAWangle, -cfg->p_max, cfg->p_max, 16))*RAD2DEG;
 800aff4: 693b         	ldr	r3, [r7, #0x10]
 800aff6: f9b3 3030    	ldrsh.w	r3, [r3, #0x30]
 800affa: 4618         	mov	r0, r3
 800affc: 68fb         	ldr	r3, [r7, #0xc]
 800affe: 6d9b         	ldr	r3, [r3, #0x58]
 800b000: f083 4100    	eor	r1, r3, #0x80000000
 800b004: 68fb         	ldr	r3, [r7, #0xc]
 800b006: 6d9a         	ldr	r2, [r3, #0x58]
 800b008: 2310         	movs	r3, #0x10
 800b00a: f00d fa0e    	bl	0x801842a <uint_to_float> @ imm = #0xd41c
 800b00e: 4603         	mov	r3, r0
 800b010: 4940         	ldr	r1, [pc, #0x100]        @ 0x800b114 <dm_rx_data_handler+0x15c>
 800b012: 4618         	mov	r0, r3
 800b014: f7f5 fb82    	bl	0x800071c <__mulsf3>    @ imm = #-0xa8fc
 800b018: 4603         	mov	r3, r0
 800b01a: 493f         	ldr	r1, [pc, #0xfc]         @ 0x800b118 <dm_rx_data_handler+0x160>
 800b01c: 4618         	mov	r0, r3
 800b01e: f7f5 fc31    	bl	0x8000884 <__divsf3>    @ imm = #-0xa79e
 800b022: 4603         	mov	r3, r0
 800b024: 461a         	mov	r2, r3
; 		data->common.angle =
 800b026: 693b         	ldr	r3, [r7, #0x10]
 800b028: 601a         	str	r2, [r3]
; 		data->common.rpm = uint_to_float(data->RAWrpm, -cfg->v_max, cfg->v_max, 12);
 800b02a: 693b         	ldr	r3, [r7, #0x10]
 800b02c: f9b3 3032    	ldrsh.w	r3, [r3, #0x32]
 800b030: 4618         	mov	r0, r3
 800b032: 68fb         	ldr	r3, [r7, #0xc]
 800b034: 6d5b         	ldr	r3, [r3, #0x54]
 800b036: f083 4100    	eor	r1, r3, #0x80000000
 800b03a: 68fb         	ldr	r3, [r7, #0xc]
 800b03c: 6d5a         	ldr	r2, [r3, #0x54]
 800b03e: 230c         	movs	r3, #0xc
 800b040: f00d f9f3    	bl	0x801842a <uint_to_float> @ imm = #0xd3e6
 800b044: 4602         	mov	r2, r0
 800b046: 693b         	ldr	r3, [r7, #0x10]
 800b048: 605a         	str	r2, [r3, #0x4]
; 		data->common.torque = uint_to_float(data->RAWtorque, -cfg->t_max, cfg->t_max, 12);
 800b04a: 693b         	ldr	r3, [r7, #0x10]
 800b04c: f9b3 3034    	ldrsh.w	r3, [r3, #0x34]
 800b050: 4618         	mov	r0, r3
 800b052: 68fb         	ldr	r3, [r7, #0xc]
 800b054: 6ddb         	ldr	r3, [r3, #0x5c]
 800b056: f083 4100    	eor	r1, r3, #0x80000000
 800b05a: 68fb         	ldr	r3, [r7, #0xc]
 800b05c: 6dda         	ldr	r2, [r3, #0x5c]
 800b05e: 230c         	movs	r3, #0xc
 800b060: f00d f9e3    	bl	0x801842a <uint_to_float> @ imm = #0xd3c6
 800b064: 4602         	mov	r2, r0
 800b066: 693b         	ldr	r3, [r7, #0x10]
 800b068: 609a         	str	r2, [r3, #0x8]
; 		data->delta_deg_sum += data->common.angle - prev_angle;
 800b06a: 693b         	ldr	r3, [r7, #0x10]
 800b06c: 6a1c         	ldr	r4, [r3, #0x20]
 800b06e: 693b         	ldr	r3, [r7, #0x10]
 800b070: 681b         	ldr	r3, [r3]
 800b072: 68b9         	ldr	r1, [r7, #0x8]
 800b074: 4618         	mov	r0, r3
 800b076: f7f5 fa47    	bl	0x8000508 <__subsf3>    @ imm = #-0xab72
 800b07a: 4603         	mov	r3, r0
 800b07c: 4619         	mov	r1, r3
 800b07e: 4620         	mov	r0, r4
 800b080: f7f5 fa44    	bl	0x800050c <__aeabi_fadd> @ imm = #-0xab78
 800b084: 4603         	mov	r3, r0
 800b086: 461a         	mov	r2, r3
 800b088: 693b         	ldr	r3, [r7, #0x10]
 800b08a: 621a         	str	r2, [r3, #0x20]
; 		if (data->delta_deg_sum > 360) {
 800b08c: 693b         	ldr	r3, [r7, #0x10]
 800b08e: 6a1b         	ldr	r3, [r3, #0x20]
 800b090: 4922         	ldr	r1, [pc, #0x88]         @ 0x800b11c <dm_rx_data_handler+0x164>
 800b092: 4618         	mov	r0, r3
 800b094: f7f5 fcfe    	bl	0x8000a94 <__aeabi_fcmpgt> @ imm = #-0xa604
 800b098: 4603         	mov	r3, r0
 800b09a: 2b00         	cmp	r3, #0x0
 800b09c: d00f         	beq	0x800b0be <dm_rx_data_handler+0x106> @ imm = #0x1e
; 			data->common.round_cnt++;
 800b09e: 693b         	ldr	r3, [r7, #0x10]
 800b0a0: 691b         	ldr	r3, [r3, #0x10]
 800b0a2: 1c5a         	adds	r2, r3, #0x1
 800b0a4: 693b         	ldr	r3, [r7, #0x10]
 800b0a6: 611a         	str	r2, [r3, #0x10]
; 			data->delta_deg_sum -= 360.0f;
 800b0a8: 693b         	ldr	r3, [r7, #0x10]
 800b0aa: 6a1b         	ldr	r3, [r3, #0x20]
 800b0ac: 491b         	ldr	r1, [pc, #0x6c]         @ 0x800b11c <dm_rx_data_handler+0x164>
 800b0ae: 4618         	mov	r0, r3
 800b0b0: f7f5 fa2a    	bl	0x8000508 <__subsf3>    @ imm = #-0xabac
 800b0b4: 4603         	mov	r3, r0
 800b0b6: 461a         	mov	r2, r3
 800b0b8: 693b         	ldr	r3, [r7, #0x10]
 800b0ba: 621a         	str	r2, [r3, #0x20]
 800b0bc: e017         	b	0x800b0ee <dm_rx_data_handler+0x136> @ imm = #0x2e
; 		} else if (data->delta_deg_sum < -360) {
 800b0be: 693b         	ldr	r3, [r7, #0x10]
 800b0c0: 6a1b         	ldr	r3, [r3, #0x20]
 800b0c2: 4917         	ldr	r1, [pc, #0x5c]         @ 0x800b120 <dm_rx_data_handler+0x168>
 800b0c4: 4618         	mov	r0, r3
 800b0c6: f7f5 fcc7    	bl	0x8000a58 <__aeabi_fcmplt> @ imm = #-0xa672
 800b0ca: 4603         	mov	r3, r0
 800b0cc: 2b00         	cmp	r3, #0x0
 800b0ce: d00e         	beq	0x800b0ee <dm_rx_data_handler+0x136> @ imm = #0x1c
; 			data->common.round_cnt--;
 800b0d0: 693b         	ldr	r3, [r7, #0x10]
 800b0d2: 691b         	ldr	r3, [r3, #0x10]
 800b0d4: 1e5a         	subs	r2, r3, #0x1
 800b0d6: 693b         	ldr	r3, [r7, #0x10]
 800b0d8: 611a         	str	r2, [r3, #0x10]
; 			data->delta_deg_sum += 360.0f;
 800b0da: 693b         	ldr	r3, [r7, #0x10]
 800b0dc: 6a1b         	ldr	r3, [r3, #0x20]
 800b0de: 490f         	ldr	r1, [pc, #0x3c]         @ 0x800b11c <dm_rx_data_handler+0x164>
 800b0e0: 4618         	mov	r0, r3
 800b0e2: f7f5 fa13    	bl	0x800050c <__aeabi_fadd> @ imm = #-0xabda
 800b0e6: 4603         	mov	r3, r0
 800b0e8: 461a         	mov	r2, r3
 800b0ea: 693b         	ldr	r3, [r7, #0x10]
 800b0ec: 621a         	str	r2, [r3, #0x20]
; 		data->update = false;
 800b0ee: 693b         	ldr	r3, [r7, #0x10]
 800b0f0: 2200         	movs	r2, #0x0
 800b0f2: 775a         	strb	r2, [r3, #0x1d]
 800b0f4: e000         	b	0x800b0f8 <dm_rx_data_handler+0x140> @ imm = #0x0
; 			continue;
 800b0f6: bf00         	nop
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 800b0f8: 697b         	ldr	r3, [r7, #0x14]
 800b0fa: 3301         	adds	r3, #0x1
 800b0fc: 617b         	str	r3, [r7, #0x14]
 800b0fe: 697b         	ldr	r3, [r7, #0x14]
 800b100: 2b00         	cmp	r3, #0x0
 800b102: f77f af60    	ble.w	0x800afc6 <dm_rx_data_handler+0xe> @ imm = #-0x140
; }
 800b106: bf00         	nop
 800b108: bf00         	nop
 800b10a: 371c         	adds	r7, #0x1c
 800b10c: 46bd         	mov	sp, r7
 800b10e: bd90         	pop	{r4, r7, pc}

0800b110 <$d>:
 800b110: d8 04 00 20  	.word	0x200004d8
 800b114: 00 00 34 43  	.word	0x43340000
 800b118: db 0f 49 40  	.word	0x40490fdb
 800b11c: 00 00 b4 43  	.word	0x43b40000
 800b120: 00 00 b4 c3  	.word	0xc3b40000

0800b124 <dm_tx_isr_handler>:
; {
 800b124: b580         	push	{r7, lr}
 800b126: b084         	sub	sp, #0x10
 800b128: af00         	add	r7, sp, #0x0
 800b12a: 6078         	str	r0, [r7, #0x4]
; 	struct k_work *work = k_timer_user_data_get(dummy);
 800b12c: 6878         	ldr	r0, [r7, #0x4]
 800b12e: f00d f8a4    	bl	0x801827a <k_timer_user_data_get> @ imm = #0xd148
 800b132: 60f8         	str	r0, [r7, #0xc]
; 	k_work_submit_to_queue(&dm_work_queue, work);
 800b134: 68f9         	ldr	r1, [r7, #0xc]
 800b136: 4803         	ldr	r0, [pc, #0xc]          @ 0x800b144 <dm_tx_isr_handler+0x20>
 800b138: f00e fb82    	bl	0x8019840 <k_work_submit_to_queue> @ imm = #0xe704
; }
 800b13c: bf00         	nop
 800b13e: 3710         	adds	r7, #0x10
 800b140: 46bd         	mov	sp, r7
 800b142: bd80         	pop	{r7, pc}

0800b144 <$d>:
 800b144: 40 06 00 20  	.word	0x20000640

0800b148 <dm_tx_data_handler>:
; {
 800b148: b590         	push	{r4, r7, lr}
 800b14a: b099         	sub	sp, #0x64
 800b14c: af04         	add	r7, sp, #0x10
 800b14e: 6078         	str	r0, [r7, #0x4]
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 800b150: 2300         	movs	r3, #0x0
 800b152: 64fb         	str	r3, [r7, #0x4c]
 800b154: e08a         	b	0x800b26c <dm_tx_data_handler+0x124> @ imm = #0x114
; 		struct dm_motor_data *data = motor_devices[i]->data;
 800b156: 4a4b         	ldr	r2, [pc, #0x12c]        @ 0x800b284 <dm_tx_data_handler+0x13c>
 800b158: 6cfb         	ldr	r3, [r7, #0x4c]
 800b15a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800b15e: 691b         	ldr	r3, [r3, #0x10]
 800b160: 64bb         	str	r3, [r7, #0x48]
; 		const struct dm_motor_config *cfg = motor_devices[i]->config;
 800b162: 4a48         	ldr	r2, [pc, #0x120]        @ 0x800b284 <dm_tx_data_handler+0x13c>
 800b164: 6cfb         	ldr	r3, [r7, #0x4c]
 800b166: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800b16a: 685b         	ldr	r3, [r3, #0x4]
 800b16c: 647b         	str	r3, [r7, #0x44]
; 		if (data->online) {
 800b16e: 6cbb         	ldr	r3, [r7, #0x48]
 800b170: 7f1b         	ldrb	r3, [r3, #0x1c]
 800b172: 2b00         	cmp	r3, #0x0
 800b174: d077         	beq	0x800b266 <dm_tx_data_handler+0x11e> @ imm = #0xee
; 			int can_id = get_can_id(motor_devices[i]);
 800b176: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x800b284 <dm_tx_data_handler+0x13c>
 800b178: 6cfb         	ldr	r3, [r7, #0x4c]
 800b17a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800b17e: 4618         	mov	r0, r3
 800b180: f7ff fa40    	bl	0x800a604 <get_can_id>  @ imm = #-0xb80
 800b184: 6438         	str	r0, [r7, #0x40]
; 			int err = k_sem_take(&tx_queue_sem[can_id], K_NO_WAIT);
 800b186: 6c3b         	ldr	r3, [r7, #0x40]
 800b188: 011b         	lsls	r3, r3, #0x4
 800b18a: 4a3f         	ldr	r2, [pc, #0xfc]         @ 0x800b288 <dm_tx_data_handler+0x140>
 800b18c: 1899         	adds	r1, r3, r2
 800b18e: f04f 0200    	mov.w	r2, #0x0
 800b192: f04f 0300    	mov.w	r3, #0x0
 800b196: 4608         	mov	r0, r1
 800b198: f00d f88b    	bl	0x80182b2 <k_sem_take>  @ imm = #0xd116
 800b19c: 63f8         	str	r0, [r7, #0x3c]
; 			if (err == 0) {
 800b19e: 6bfb         	ldr	r3, [r7, #0x3c]
 800b1a0: 2b00         	cmp	r3, #0x0
 800b1a2: d11e         	bne	0x800b1e2 <dm_tx_data_handler+0x9a> @ imm = #0x3c
; 				dm_motor_pack(motor_devices[i], &tx_frame);
 800b1a4: 4a37         	ldr	r2, [pc, #0xdc]         @ 0x800b284 <dm_tx_data_handler+0x13c>
 800b1a6: 6cfb         	ldr	r3, [r7, #0x4c]
 800b1a8: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800b1ac: f107 0224    	add.w	r2, r7, #0x24
 800b1b0: 4611         	mov	r1, r2
 800b1b2: 4618         	mov	r0, r3
 800b1b4: f7ff fce8    	bl	0x800ab88 <dm_motor_pack> @ imm = #-0x630
; 					.can_dev = cfg->common.phy,
 800b1b8: 6c7b         	ldr	r3, [r7, #0x44]
 800b1ba: 681b         	ldr	r3, [r3]
; 				struct tx_frame queued_frame = {
 800b1bc: 60fb         	str	r3, [r7, #0xc]
; 					.sem = &tx_queue_sem[can_id],
 800b1be: 6c3b         	ldr	r3, [r7, #0x40]
 800b1c0: 011b         	lsls	r3, r3, #0x4
 800b1c2: 4a31         	ldr	r2, [pc, #0xc4]         @ 0x800b288 <dm_tx_data_handler+0x140>
 800b1c4: 4413         	add	r3, r2
; 				struct tx_frame queued_frame = {
 800b1c6: 613b         	str	r3, [r7, #0x10]
 800b1c8: f107 0414    	add.w	r4, r7, #0x14
 800b1cc: f107 0324    	add.w	r3, r7, #0x24
 800b1d0: cb0f         	ldm	r3, {r0, r1, r2, r3}
 800b1d2: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
; 				dm_send_queued(&queued_frame, &dm_can_tx_msgq);
 800b1d6: f107 030c    	add.w	r3, r7, #0xc
 800b1da: 492c         	ldr	r1, [pc, #0xb0]         @ 0x800b28c <dm_tx_data_handler+0x144>
 800b1dc: 4618         	mov	r0, r3
 800b1de: f7ff fa8f    	bl	0x800a700 <dm_send_queued> @ imm = #-0xae2
; 			if (++(data->missed_times) > 3 && data->err != 1) {
 800b1e2: 6cbb         	ldr	r3, [r7, #0x48]
 800b1e4: f993 301e    	ldrsb.w	r3, [r3, #0x1e]
 800b1e8: b2db         	uxtb	r3, r3
 800b1ea: 3301         	adds	r3, #0x1
 800b1ec: b2db         	uxtb	r3, r3
 800b1ee: b25a         	sxtb	r2, r3
 800b1f0: 6cbb         	ldr	r3, [r7, #0x48]
 800b1f2: 779a         	strb	r2, [r3, #0x1e]
 800b1f4: 6cbb         	ldr	r3, [r7, #0x48]
 800b1f6: f993 301e    	ldrsb.w	r3, [r3, #0x1e]
 800b1fa: 2b03         	cmp	r3, #0x3
 800b1fc: dd0d         	ble	0x800b21a <dm_tx_data_handler+0xd2> @ imm = #0x1a
 800b1fe: 6cbb         	ldr	r3, [r7, #0x48]
 800b200: f993 301f    	ldrsb.w	r3, [r3, #0x1f]
 800b204: 2b01         	cmp	r3, #0x1
 800b206: d008         	beq	0x800b21a <dm_tx_data_handler+0xd2> @ imm = #0x10
; 				dm_motor_control(motor_devices[i], CLEAR_ERROR);
 800b208: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x800b284 <dm_tx_data_handler+0x13c>
 800b20a: 6cfb         	ldr	r3, [r7, #0x4c]
 800b20c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800b210: 2104         	movs	r1, #0x4
 800b212: 4618         	mov	r0, r3
 800b214: f7ff fba6    	bl	0x800a964 <dm_motor_control> @ imm = #-0x8b4
 800b218: e025         	b	0x800b266 <dm_tx_data_handler+0x11e> @ imm = #0x4a
; 			} else if (data->missed_times > 5) {
 800b21a: 6cbb         	ldr	r3, [r7, #0x48]
 800b21c: f993 301e    	ldrsb.w	r3, [r3, #0x1e]
 800b220: 2b05         	cmp	r3, #0x5
 800b222: dd20         	ble	0x800b266 <dm_tx_data_handler+0x11e> @ imm = #0x40
; 				LOG_ERR("Motor %d is not responding, setting it to "
 800b224: 2304         	movs	r3, #0x4
 800b226: 2b00         	cmp	r3, #0x0
 800b228: d01a         	beq	0x800b260 <dm_tx_data_handler+0x118> @ imm = #0x34
 800b22a: 2301         	movs	r3, #0x1
 800b22c: f887 303b    	strb.w	r3, [r7, #0x3b]
 800b230: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800b234: f083 0301    	eor	r3, r3, #0x1
 800b238: b2db         	uxtb	r3, r3
 800b23a: 2b00         	cmp	r3, #0x0
 800b23c: d110         	bne	0x800b260 <dm_tx_data_handler+0x118> @ imm = #0x20
 800b23e: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800b290 <dm_tx_data_handler+0x148>
 800b240: 6819         	ldr	r1, [r3]
 800b242: 6cfb         	ldr	r3, [r7, #0x4c]
 800b244: 9303         	str	r3, [sp, #0xc]
 800b246: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800b294 <dm_tx_data_handler+0x14c>
 800b248: 9302         	str	r3, [sp, #0x8]
 800b24a: 2300         	movs	r3, #0x0
 800b24c: 9301         	str	r3, [sp, #0x4]
 800b24e: 2300         	movs	r3, #0x0
 800b250: 9300         	str	r3, [sp]
 800b252: 2300         	movs	r3, #0x0
 800b254: 2201         	movs	r2, #0x1
 800b256: 2000         	movs	r0, #0x0
 800b258: f00d f875    	bl	0x8018346 <z_log_msg_runtime_create> @ imm = #0xd0ea
 800b25c: 2300         	movs	r3, #0x0
 800b25e: 637b         	str	r3, [r7, #0x34]
; 				data->online = false;
 800b260: 6cbb         	ldr	r3, [r7, #0x48]
 800b262: 2200         	movs	r2, #0x0
 800b264: 771a         	strb	r2, [r3, #0x1c]
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 800b266: 6cfb         	ldr	r3, [r7, #0x4c]
 800b268: 3301         	adds	r3, #0x1
 800b26a: 64fb         	str	r3, [r7, #0x4c]
 800b26c: 6cfb         	ldr	r3, [r7, #0x4c]
 800b26e: 2b00         	cmp	r3, #0x0
 800b270: f77f af71    	ble.w	0x800b156 <dm_tx_data_handler+0xe> @ imm = #-0x11e
; 	dm_queue_proceed(&dm_can_tx_msgq);
 800b274: 4805         	ldr	r0, [pc, #0x14]         @ 0x800b28c <dm_tx_data_handler+0x144>
 800b276: f7ff faff    	bl	0x800a878 <dm_queue_proceed> @ imm = #-0xa02
; }
 800b27a: bf00         	nop
 800b27c: 3754         	adds	r7, #0x54
 800b27e: 46bd         	mov	sp, r7
 800b280: bd90         	pop	{r4, r7, pc}
 800b282: bf00         	nop

0800b284 <$d>:
 800b284: d8 04 00 20  	.word	0x200004d8
 800b288: 7c 10 00 20  	.word	0x2000107c
 800b28c: 08 06 00 20  	.word	0x20000608
 800b290: 14 05 00 20  	.word	0x20000514
 800b294: 38 c9 01 08  	.word	0x0801c938

0800b298 <dm_init_handler>:
; {
 800b298: b580         	push	{r7, lr}
 800b29a: b096         	sub	sp, #0x58
 800b29c: af04         	add	r7, sp, #0x10
 800b29e: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("DM motor control thread started");
 800b2a0: 2304         	movs	r3, #0x4
 800b2a2: 2b03         	cmp	r3, #0x3
 800b2a4: d91a         	bls	0x800b2dc <dm_init_handler+0x44> @ imm = #0x34
 800b2a6: 2301         	movs	r3, #0x1
 800b2a8: f887 3033    	strb.w	r3, [r7, #0x33]
 800b2ac: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800b2b0: f083 0301    	eor	r3, r3, #0x1
 800b2b4: b2db         	uxtb	r3, r3
 800b2b6: 2b00         	cmp	r3, #0x0
 800b2b8: d110         	bne	0x800b2dc <dm_init_handler+0x44> @ imm = #0x20
 800b2ba: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x800b4ac <dm_init_handler+0x214>
 800b2bc: 6819         	ldr	r1, [r3]
 800b2be: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x800b4b0 <dm_init_handler+0x218>
 800b2c0: 9303         	str	r3, [sp, #0xc]
 800b2c2: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x800b4b4 <dm_init_handler+0x21c>
 800b2c4: 9302         	str	r3, [sp, #0x8]
 800b2c6: 2308         	movs	r3, #0x8
 800b2c8: 9301         	str	r3, [sp, #0x4]
 800b2ca: 2300         	movs	r3, #0x0
 800b2cc: 9300         	str	r3, [sp]
 800b2ce: 2300         	movs	r3, #0x0
 800b2d0: 2204         	movs	r2, #0x4
 800b2d2: 2000         	movs	r0, #0x0
 800b2d4: f00d f837    	bl	0x8018346 <z_log_msg_runtime_create> @ imm = #0xd06e
 800b2d8: 2300         	movs	r3, #0x0
 800b2da: 62fb         	str	r3, [r7, #0x2c]
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 800b2dc: 2300         	movs	r3, #0x0
 800b2de: 63bb         	str	r3, [r7, #0x38]
 800b2e0: e06f         	b	0x800b3c2 <dm_init_handler+0x12a> @ imm = #0xde
; 		int can_id = 0;
 800b2e2: 2300         	movs	r3, #0x0
 800b2e4: 637b         	str	r3, [r7, #0x34]
; 			(const struct dm_motor_config *)(motor_devices[i]->config);
 800b2e6: 4a74         	ldr	r2, [pc, #0x1d0]        @ 0x800b4b8 <dm_init_handler+0x220>
 800b2e8: 6bbb         	ldr	r3, [r7, #0x38]
 800b2ea: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; 		const struct dm_motor_config *cfg =
 800b2ee: 685b         	ldr	r3, [r3, #0x4]
 800b2f0: 61bb         	str	r3, [r7, #0x18]
; 		for (int j = 0; j < CAN_COUNT; j++) {
 800b2f2: 2300         	movs	r3, #0x0
 800b2f4: 643b         	str	r3, [r7, #0x40]
 800b2f6: e00d         	b	0x800b314 <dm_init_handler+0x7c> @ imm = #0x1a
; 			if (can_devices[j] == cfg->common.phy) {
 800b2f8: 4a70         	ldr	r2, [pc, #0x1c0]        @ 0x800b4bc <dm_init_handler+0x224>
 800b2fa: 6c3b         	ldr	r3, [r7, #0x40]
 800b2fc: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 800b300: 69bb         	ldr	r3, [r7, #0x18]
 800b302: 681b         	ldr	r3, [r3]
 800b304: 429a         	cmp	r2, r3
 800b306: d102         	bne	0x800b30e <dm_init_handler+0x76> @ imm = #0x4
; 				can_id = j;
 800b308: 6c3b         	ldr	r3, [r7, #0x40]
 800b30a: 637b         	str	r3, [r7, #0x34]
; 				break;
 800b30c: e005         	b	0x800b31a <dm_init_handler+0x82> @ imm = #0xa
; 		for (int j = 0; j < CAN_COUNT; j++) {
 800b30e: 6c3b         	ldr	r3, [r7, #0x40]
 800b310: 3301         	adds	r3, #0x1
 800b312: 643b         	str	r3, [r7, #0x40]
 800b314: 6c3b         	ldr	r3, [r7, #0x40]
 800b316: 2b01         	cmp	r3, #0x1
 800b318: ddee         	ble	0x800b2f8 <dm_init_handler+0x60> @ imm = #-0x24
; 		filters[can_id].id &= cfg->common.rx_id & 0xFF;
 800b31a: 4969         	ldr	r1, [pc, #0x1a4]        @ 0x800b4c0 <dm_init_handler+0x228>
 800b31c: 6b7a         	ldr	r2, [r7, #0x34]
 800b31e: 4613         	mov	r3, r2
 800b320: 005b         	lsls	r3, r3, #0x1
 800b322: 4413         	add	r3, r2
 800b324: 009b         	lsls	r3, r3, #0x2
 800b326: 440b         	add	r3, r1
 800b328: 681b         	ldr	r3, [r3]
 800b32a: 69ba         	ldr	r2, [r7, #0x18]
 800b32c: 68d2         	ldr	r2, [r2, #0xc]
 800b32e: 4013         	ands	r3, r2
 800b330: b2d9         	uxtb	r1, r3
 800b332: 4863         	ldr	r0, [pc, #0x18c]        @ 0x800b4c0 <dm_init_handler+0x228>
 800b334: 6b7a         	ldr	r2, [r7, #0x34]
 800b336: 4613         	mov	r3, r2
 800b338: 005b         	lsls	r3, r3, #0x1
 800b33a: 4413         	add	r3, r2
 800b33c: 009b         	lsls	r3, r3, #0x2
 800b33e: 4403         	add	r3, r0
 800b340: 6019         	str	r1, [r3]
; 		filters[can_id].mask = ~(filters[can_id].mask ^ (cfg->common.rx_id & 0xFF)) & 0xFF;
 800b342: 495f         	ldr	r1, [pc, #0x17c]        @ 0x800b4c0 <dm_init_handler+0x228>
 800b344: 6b7a         	ldr	r2, [r7, #0x34]
 800b346: 4613         	mov	r3, r2
 800b348: 005b         	lsls	r3, r3, #0x1
 800b34a: 4413         	add	r3, r2
 800b34c: 009b         	lsls	r3, r3, #0x2
 800b34e: 440b         	add	r3, r1
 800b350: 3304         	adds	r3, #0x4
 800b352: 681a         	ldr	r2, [r3]
 800b354: 69bb         	ldr	r3, [r7, #0x18]
 800b356: 68db         	ldr	r3, [r3, #0xc]
 800b358: b2db         	uxtb	r3, r3
 800b35a: 4053         	eors	r3, r2
 800b35c: 43db         	mvns	r3, r3
 800b35e: b2d9         	uxtb	r1, r3
 800b360: 4857         	ldr	r0, [pc, #0x15c]        @ 0x800b4c0 <dm_init_handler+0x228>
 800b362: 6b7a         	ldr	r2, [r7, #0x34]
 800b364: 4613         	mov	r3, r2
 800b366: 005b         	lsls	r3, r3, #0x1
 800b368: 4413         	add	r3, r2
 800b36a: 009b         	lsls	r3, r3, #0x2
 800b36c: 4403         	add	r3, r0
 800b36e: 3304         	adds	r3, #0x4
 800b370: 6019         	str	r1, [r3]
; 		int err = can_start(cfg->common.phy);
 800b372: 69bb         	ldr	r3, [r7, #0x18]
 800b374: 681b         	ldr	r3, [r3]
 800b376: 4618         	mov	r0, r3
 800b378: f00d f835    	bl	0x80183e6 <can_start>   @ imm = #0xd06a
 800b37c: 6178         	str	r0, [r7, #0x14]
; 		if (err) {
 800b37e: 697b         	ldr	r3, [r7, #0x14]
 800b380: 2b00         	cmp	r3, #0x0
 800b382: d01b         	beq	0x800b3bc <dm_init_handler+0x124> @ imm = #0x36
; 			LOG_ERR("Failed to start CAN device: %d", err);
 800b384: 2304         	movs	r3, #0x4
 800b386: 2b00         	cmp	r3, #0x0
 800b388: d018         	beq	0x800b3bc <dm_init_handler+0x124> @ imm = #0x30
 800b38a: 2301         	movs	r3, #0x1
 800b38c: 74fb         	strb	r3, [r7, #0x13]
 800b38e: 7cfb         	ldrb	r3, [r7, #0x13]
 800b390: f083 0301    	eor	r3, r3, #0x1
 800b394: b2db         	uxtb	r3, r3
 800b396: 2b00         	cmp	r3, #0x0
 800b398: d110         	bne	0x800b3bc <dm_init_handler+0x124> @ imm = #0x20
 800b39a: 4b44         	ldr	r3, [pc, #0x110]        @ 0x800b4ac <dm_init_handler+0x214>
 800b39c: 6819         	ldr	r1, [r3]
 800b39e: 697b         	ldr	r3, [r7, #0x14]
 800b3a0: 9303         	str	r3, [sp, #0xc]
 800b3a2: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800b4c4 <dm_init_handler+0x22c>
 800b3a4: 9302         	str	r3, [sp, #0x8]
 800b3a6: 2300         	movs	r3, #0x0
 800b3a8: 9301         	str	r3, [sp, #0x4]
 800b3aa: 2300         	movs	r3, #0x0
 800b3ac: 9300         	str	r3, [sp]
 800b3ae: 2300         	movs	r3, #0x0
 800b3b0: 2201         	movs	r2, #0x1
 800b3b2: 2000         	movs	r0, #0x0
 800b3b4: f00c ffc7    	bl	0x8018346 <z_log_msg_runtime_create> @ imm = #0xcf8e
 800b3b8: 2300         	movs	r3, #0x0
 800b3ba: 60fb         	str	r3, [r7, #0xc]
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 800b3bc: 6bbb         	ldr	r3, [r7, #0x38]
 800b3be: 3301         	adds	r3, #0x1
 800b3c0: 63bb         	str	r3, [r7, #0x38]
 800b3c2: 6bbb         	ldr	r3, [r7, #0x38]
 800b3c4: 2b00         	cmp	r3, #0x0
 800b3c6: dd8c         	ble	0x800b2e2 <dm_init_handler+0x4a> @ imm = #-0xe8
; 	for (int i = 0; i < CAN_COUNT; i++) {
 800b3c8: 2300         	movs	r3, #0x0
 800b3ca: 63fb         	str	r3, [r7, #0x3c]
 800b3cc: e049         	b	0x800b462 <dm_init_handler+0x1ca> @ imm = #0x92
; 		filters[i].mask |= 0x700;
 800b3ce: 493c         	ldr	r1, [pc, #0xf0]         @ 0x800b4c0 <dm_init_handler+0x228>
 800b3d0: 6bfa         	ldr	r2, [r7, #0x3c]
 800b3d2: 4613         	mov	r3, r2
 800b3d4: 005b         	lsls	r3, r3, #0x1
 800b3d6: 4413         	add	r3, r2
 800b3d8: 009b         	lsls	r3, r3, #0x2
 800b3da: 440b         	add	r3, r1
 800b3dc: 3304         	adds	r3, #0x4
 800b3de: 681b         	ldr	r3, [r3]
 800b3e0: f443 61e0    	orr	r1, r3, #0x700
 800b3e4: 4836         	ldr	r0, [pc, #0xd8]         @ 0x800b4c0 <dm_init_handler+0x228>
 800b3e6: 6bfa         	ldr	r2, [r7, #0x3c]
 800b3e8: 4613         	mov	r3, r2
 800b3ea: 005b         	lsls	r3, r3, #0x1
 800b3ec: 4413         	add	r3, r2
 800b3ee: 009b         	lsls	r3, r3, #0x2
 800b3f0: 4403         	add	r3, r0
 800b3f2: 3304         	adds	r3, #0x4
 800b3f4: 6019         	str	r1, [r3]
; 		const struct device *can_dev = can_devices[i];
 800b3f6: 4a31         	ldr	r2, [pc, #0xc4]         @ 0x800b4bc <dm_init_handler+0x224>
 800b3f8: 6bfb         	ldr	r3, [r7, #0x3c]
 800b3fa: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800b3fe: 62bb         	str	r3, [r7, #0x28]
; 		int err = can_add_rx_filter(can_dev, dm_can_rx_handler, 0, &filters[i]);
 800b400: 6bfa         	ldr	r2, [r7, #0x3c]
 800b402: 4613         	mov	r3, r2
 800b404: 005b         	lsls	r3, r3, #0x1
 800b406: 4413         	add	r3, r2
 800b408: 009b         	lsls	r3, r3, #0x2
 800b40a: 4a2d         	ldr	r2, [pc, #0xb4]         @ 0x800b4c0 <dm_init_handler+0x228>
 800b40c: 4413         	add	r3, r2
 800b40e: 2200         	movs	r2, #0x0
 800b410: 492d         	ldr	r1, [pc, #0xb4]         @ 0x800b4c8 <dm_init_handler+0x230>
 800b412: 6ab8         	ldr	r0, [r7, #0x28]
 800b414: f7f8 fd6a    	bl	0x8003eec <can_add_rx_filter> @ imm = #-0x752c
 800b418: 6278         	str	r0, [r7, #0x24]
; 		if (err < 0) {
 800b41a: 6a7b         	ldr	r3, [r7, #0x24]
 800b41c: 2b00         	cmp	r3, #0x0
 800b41e: da1d         	bge	0x800b45c <dm_init_handler+0x1c4> @ imm = #0x3a
; 			LOG_ERR("Error adding CAN filter (err %d)", err);
 800b420: 2304         	movs	r3, #0x4
 800b422: 2b00         	cmp	r3, #0x0
 800b424: d01a         	beq	0x800b45c <dm_init_handler+0x1c4> @ imm = #0x34
 800b426: 2301         	movs	r3, #0x1
 800b428: f887 3023    	strb.w	r3, [r7, #0x23]
 800b42c: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800b430: f083 0301    	eor	r3, r3, #0x1
 800b434: b2db         	uxtb	r3, r3
 800b436: 2b00         	cmp	r3, #0x0
 800b438: d110         	bne	0x800b45c <dm_init_handler+0x1c4> @ imm = #0x20
 800b43a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800b4ac <dm_init_handler+0x214>
 800b43c: 6819         	ldr	r1, [r3]
 800b43e: 6a7b         	ldr	r3, [r7, #0x24]
 800b440: 9303         	str	r3, [sp, #0xc]
 800b442: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800b4cc <dm_init_handler+0x234>
 800b444: 9302         	str	r3, [sp, #0x8]
 800b446: 2300         	movs	r3, #0x0
 800b448: 9301         	str	r3, [sp, #0x4]
 800b44a: 2300         	movs	r3, #0x0
 800b44c: 9300         	str	r3, [sp]
 800b44e: 2300         	movs	r3, #0x0
 800b450: 2201         	movs	r2, #0x1
 800b452: 2000         	movs	r0, #0x0
 800b454: f00c ff77    	bl	0x8018346 <z_log_msg_runtime_create> @ imm = #0xceee
 800b458: 2300         	movs	r3, #0x0
 800b45a: 61fb         	str	r3, [r7, #0x1c]
; 	for (int i = 0; i < CAN_COUNT; i++) {
 800b45c: 6bfb         	ldr	r3, [r7, #0x3c]
 800b45e: 3301         	adds	r3, #0x1
 800b460: 63fb         	str	r3, [r7, #0x3c]
 800b462: 6bfb         	ldr	r3, [r7, #0x3c]
 800b464: 2b01         	cmp	r3, #0x1
 800b466: ddb2         	ble	0x800b3ce <dm_init_handler+0x136> @ imm = #-0x9c
; 	k_sleep(K_MSEC(500));
 800b468: f241 3288    	movw	r2, #0x1388
 800b46c: f04f 0300    	mov.w	r3, #0x0
 800b470: 4610         	mov	r0, r2
 800b472: 4619         	mov	r1, r3
 800b474: f00c fed3    	bl	0x801821e <k_sleep>     @ imm = #0xcda6
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 800b478: 2300         	movs	r3, #0x0
 800b47a: 647b         	str	r3, [r7, #0x44]
 800b47c: e00a         	b	0x800b494 <dm_init_handler+0x1fc> @ imm = #0x14
; 		dm_motor_control(motor_devices[i], ENABLE_MOTOR);
 800b47e: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800b4b8 <dm_init_handler+0x220>
 800b480: 6c7b         	ldr	r3, [r7, #0x44]
 800b482: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800b486: 2100         	movs	r1, #0x0
 800b488: 4618         	mov	r0, r3
 800b48a: f7ff fa6b    	bl	0x800a964 <dm_motor_control> @ imm = #-0xb2a
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 800b48e: 6c7b         	ldr	r3, [r7, #0x44]
 800b490: 3301         	adds	r3, #0x1
 800b492: 647b         	str	r3, [r7, #0x44]
 800b494: 6c7b         	ldr	r3, [r7, #0x44]
 800b496: 2b00         	cmp	r3, #0x0
 800b498: ddf1         	ble	0x800b47e <dm_init_handler+0x1e6> @ imm = #-0x1e
; 	k_timer_user_data_set(&dm_tx_timer, &dm_tx_data_handle);
 800b49a: 490d         	ldr	r1, [pc, #0x34]         @ 0x800b4d0 <dm_init_handler+0x238>
 800b49c: 480d         	ldr	r0, [pc, #0x34]         @ 0x800b4d4 <dm_init_handler+0x23c>
 800b49e: f00c fedf    	bl	0x8018260 <k_timer_user_data_set> @ imm = #0xcdbe
; }
 800b4a2: bf00         	nop
 800b4a4: 3748         	adds	r7, #0x48
 800b4a6: 46bd         	mov	sp, r7
 800b4a8: bd80         	pop	{r7, pc}
 800b4aa: bf00         	nop

0800b4ac <$d>:
 800b4ac: 14 05 00 20  	.word	0x20000514
 800b4b0: 60 d8 01 08  	.word	0x0801d860
 800b4b4: 70 c9 01 08  	.word	0x0801c970
 800b4b8: d8 04 00 20  	.word	0x200004d8
 800b4bc: dc 04 00 20  	.word	0x200004dc
 800b4c0: a0 10 00 20  	.word	0x200010a0
 800b4c4: 94 c9 01 08  	.word	0x0801c994
 800b4c8: 6d ae 00 08  	.word	0x0800ae6d
 800b4cc: b4 c9 01 08  	.word	0x0801c9b4
 800b4d0: f4 04 00 20  	.word	0x200004f4
 800b4d4: d0 05 00 20  	.word	0x200005d0

0800b4d8 <float_equal>:
; static bool float_equal(float a, float b) { return fabsf(a - b) < 0.0001f; }
 800b4d8: b590         	push	{r4, r7, lr}
 800b4da: b083         	sub	sp, #0xc
 800b4dc: af00         	add	r7, sp, #0x0
 800b4de: 6078         	str	r0, [r7, #0x4]
 800b4e0: 6039         	str	r1, [r7]
 800b4e2: 6839         	ldr	r1, [r7]
 800b4e4: 6878         	ldr	r0, [r7, #0x4]
 800b4e6: f7f5 f80f    	bl	0x8000508 <__subsf3>    @ imm = #-0xafe2
 800b4ea: 4603         	mov	r3, r0
 800b4ec: f023 4300    	bic	r3, r3, #0x80000000
 800b4f0: 2201         	movs	r2, #0x1
 800b4f2: 4614         	mov	r4, r2
 800b4f4: 4906         	ldr	r1, [pc, #0x18]         @ 0x800b510 <float_equal+0x38>
 800b4f6: 4618         	mov	r0, r3
 800b4f8: f7f5 faae    	bl	0x8000a58 <__aeabi_fcmplt> @ imm = #-0xaaa4
 800b4fc: 4603         	mov	r3, r0
 800b4fe: 2b00         	cmp	r3, #0x0
 800b500: d101         	bne	0x800b506 <float_equal+0x2e> @ imm = #0x2
 800b502: 2300         	movs	r3, #0x0
 800b504: 461c         	mov	r4, r3
 800b506: b2e3         	uxtb	r3, r4
 800b508: 4618         	mov	r0, r3
 800b50a: 370c         	adds	r7, #0xc
 800b50c: 46bd         	mov	sp, r7
 800b50e: bd90         	pop	{r4, r7, pc}

0800b510 <$d>:
 800b510: 17 b7 d1 38  	.word	0x38d1b717

0800b514 <pid_mit_calc>:
; static void pid_mit_calc(const struct device *pid_dev) {
 800b514: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800b518: b08a         	sub	sp, #0x28
 800b51a: af00         	add	r7, sp, #0x0
 800b51c: 6078         	str	r0, [r7, #0x4]
;     const struct pid_mit_config *pid_para = pid_dev->config;
 800b51e: 687b         	ldr	r3, [r7, #0x4]
 800b520: 685b         	ldr	r3, [r3, #0x4]
 800b522: 627b         	str	r3, [r7, #0x24]
;     struct pid_mit_data         *pid_data = pid_dev->data;
 800b524: 687b         	ldr	r3, [r7, #0x4]
 800b526: 691b         	ldr	r3, [r3, #0x10]
 800b528: 623b         	str	r3, [r7, #0x20]
;     if (pid_data->curr == NULL) {
 800b52a: 6a3b         	ldr	r3, [r7, #0x20]
 800b52c: 689b         	ldr	r3, [r3, #0x8]
 800b52e: 2b00         	cmp	r3, #0x0
 800b530: f000 80af    	beq.w	0x800b692 <pid_mit_calc+0x17e> @ imm = #0x15e
;     float kp     = pid_para->common.k_p;
 800b534: 6a7b         	ldr	r3, [r7, #0x24]
 800b536: 681b         	ldr	r3, [r3]
 800b538: 61fb         	str	r3, [r7, #0x1c]
;     float ki     = pid_para->common.k_i;
 800b53a: 6a7b         	ldr	r3, [r7, #0x24]
 800b53c: 685b         	ldr	r3, [r3, #0x4]
 800b53e: 61bb         	str	r3, [r7, #0x18]
;     float kd     = pid_para->common.k_d;
 800b540: 6a7b         	ldr	r3, [r7, #0x24]
 800b542: 689b         	ldr	r3, [r3, #0x8]
 800b544: 617b         	str	r3, [r7, #0x14]
;     float err    = *(pid_data->ref) - *(pid_data->curr);
 800b546: 6a3b         	ldr	r3, [r7, #0x20]
 800b548: 681b         	ldr	r3, [r3]
 800b54a: 681a         	ldr	r2, [r3]
 800b54c: 6a3b         	ldr	r3, [r7, #0x20]
 800b54e: 689b         	ldr	r3, [r3, #0x8]
 800b550: 681b         	ldr	r3, [r3]
 800b552: 4619         	mov	r1, r3
 800b554: 4610         	mov	r0, r2
 800b556: f7f4 ffd7    	bl	0x8000508 <__subsf3>    @ imm = #-0xb052
 800b55a: 4603         	mov	r3, r0
 800b55c: 613b         	str	r3, [r7, #0x10]
;     float deltaT = k_cyc_to_us_near32(*(pid_data->curr_time) - *(pid_data->prev_time));
 800b55e: 6a3b         	ldr	r3, [r7, #0x20]
 800b560: 69db         	ldr	r3, [r3, #0x1c]
 800b562: 681a         	ldr	r2, [r3]
 800b564: 6a3b         	ldr	r3, [r7, #0x20]
 800b566: 6a1b         	ldr	r3, [r3, #0x20]
 800b568: 681b         	ldr	r3, [r3]
 800b56a: 1ad3         	subs	r3, r2, r3
 800b56c: 2b00         	cmp	r3, #0x0
 800b56e: db11         	blt	0x800b594 <pid_mit_calc+0x80> @ imm = #0x22
 800b570: 6a3b         	ldr	r3, [r7, #0x20]
 800b572: 69db         	ldr	r3, [r3, #0x1c]
 800b574: 681a         	ldr	r2, [r3]
 800b576: 6a3b         	ldr	r3, [r7, #0x20]
 800b578: 6a1b         	ldr	r3, [r3, #0x20]
 800b57a: 681b         	ldr	r3, [r3]
 800b57c: 1ad3         	subs	r3, r2, r3
 800b57e: 3354         	adds	r3, #0x54
 800b580: 08db         	lsrs	r3, r3, #0x3
 800b582: 4a46         	ldr	r2, [pc, #0x118]        @ 0x800b69c <pid_mit_calc+0x188>
 800b584: fba2 2303    	umull	r2, r3, r2, r3
 800b588: 085b         	lsrs	r3, r3, #0x1
 800b58a: 4618         	mov	r0, r3
 800b58c: f7f5 f86e    	bl	0x800066c <__floatunsisf> @ imm = #-0xaf24
 800b590: 4603         	mov	r3, r0
 800b592: e01c         	b	0x800b5ce <pid_mit_calc+0xba> @ imm = #0x38
 800b594: 6a3b         	ldr	r3, [r7, #0x20]
 800b596: 69db         	ldr	r3, [r3, #0x1c]
 800b598: 681a         	ldr	r2, [r3]
 800b59a: 6a3b         	ldr	r3, [r7, #0x20]
 800b59c: 6a1b         	ldr	r3, [r3, #0x20]
 800b59e: 681b         	ldr	r3, [r3]
 800b5a0: 1ad3         	subs	r3, r2, r3
 800b5a2: 17da         	asrs	r2, r3, #0x1f
 800b5a4: 461c         	mov	r4, r3
 800b5a6: 4615         	mov	r5, r2
 800b5a8: f114 0854    	adds.w	r8, r4, #0x54
 800b5ac: f145 0900    	adc	r9, r5, #0x0
 800b5b0: f04f 02a8    	mov.w	r2, #0xa8
 800b5b4: f04f 0300    	mov.w	r3, #0x0
 800b5b8: 4640         	mov	r0, r8
 800b5ba: 4649         	mov	r1, r9
 800b5bc: f7f5 fa9a    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0xaacc
 800b5c0: 4602         	mov	r2, r0
 800b5c2: 460b         	mov	r3, r1
 800b5c4: 4613         	mov	r3, r2
 800b5c6: 4618         	mov	r0, r3
 800b5c8: f7f5 f850    	bl	0x800066c <__floatunsisf> @ imm = #-0xaf60
 800b5cc: 4603         	mov	r3, r0
 800b5ce: 60fb         	str	r3, [r7, #0xc]
;     if (!float_equal(ki, 0))
 800b5d0: f04f 0100    	mov.w	r1, #0x0
 800b5d4: 69b8         	ldr	r0, [r7, #0x18]
 800b5d6: f7ff ff7f    	bl	0x800b4d8 <float_equal> @ imm = #-0x102
 800b5da: 4603         	mov	r3, r0
 800b5dc: f083 0301    	eor	r3, r3, #0x1
 800b5e0: b2db         	uxtb	r3, r3
 800b5e2: 2b00         	cmp	r3, #0x0
 800b5e4: d019         	beq	0x800b61a <pid_mit_calc+0x106> @ imm = #0x32
;         pid_data->err_integral += (err * deltaT) / (1000000 * ki);
 800b5e6: 6a3b         	ldr	r3, [r7, #0x20]
 800b5e8: 691c         	ldr	r4, [r3, #0x10]
 800b5ea: 68f9         	ldr	r1, [r7, #0xc]
 800b5ec: 6938         	ldr	r0, [r7, #0x10]
 800b5ee: f7f5 f895    	bl	0x800071c <__mulsf3>    @ imm = #-0xaed6
 800b5f2: 4603         	mov	r3, r0
 800b5f4: 461d         	mov	r5, r3
 800b5f6: 492a         	ldr	r1, [pc, #0xa8]         @ 0x800b6a0 <pid_mit_calc+0x18c>
 800b5f8: 69b8         	ldr	r0, [r7, #0x18]
 800b5fa: f7f5 f88f    	bl	0x800071c <__mulsf3>    @ imm = #-0xaee2
 800b5fe: 4603         	mov	r3, r0
 800b600: 4619         	mov	r1, r3
 800b602: 4628         	mov	r0, r5
 800b604: f7f5 f93e    	bl	0x8000884 <__divsf3>    @ imm = #-0xad84
 800b608: 4603         	mov	r3, r0
 800b60a: 4619         	mov	r1, r3
 800b60c: 4620         	mov	r0, r4
 800b60e: f7f4 ff7d    	bl	0x800050c <__aeabi_fadd> @ imm = #-0xb106
 800b612: 4603         	mov	r3, r0
 800b614: 461a         	mov	r2, r3
 800b616: 6a3b         	ldr	r3, [r7, #0x20]
 800b618: 611a         	str	r2, [r3, #0x10]
;     if (!float_equal(kd, 0)) {
 800b61a: f04f 0100    	mov.w	r1, #0x0
 800b61e: 6978         	ldr	r0, [r7, #0x14]
 800b620: f7ff ff5a    	bl	0x800b4d8 <float_equal> @ imm = #-0x14c
 800b624: 4603         	mov	r3, r0
 800b626: f083 0301    	eor	r3, r3, #0x1
 800b62a: b2db         	uxtb	r3, r3
 800b62c: 2b00         	cmp	r3, #0x0
 800b62e: d017         	beq	0x800b660 <pid_mit_calc+0x14c> @ imm = #0x2e
;         pid_data->err_derivate = kd * (*(pid_data->detri_ref) - *(pid_data->detri_curr)) / deltaT;
 800b630: 6a3b         	ldr	r3, [r7, #0x20]
 800b632: 685b         	ldr	r3, [r3, #0x4]
 800b634: 681a         	ldr	r2, [r3]
 800b636: 6a3b         	ldr	r3, [r7, #0x20]
 800b638: 68db         	ldr	r3, [r3, #0xc]
 800b63a: 681b         	ldr	r3, [r3]
 800b63c: 4619         	mov	r1, r3
 800b63e: 4610         	mov	r0, r2
 800b640: f7f4 ff62    	bl	0x8000508 <__subsf3>    @ imm = #-0xb13c
 800b644: 4603         	mov	r3, r0
 800b646: 6979         	ldr	r1, [r7, #0x14]
 800b648: 4618         	mov	r0, r3
 800b64a: f7f5 f867    	bl	0x800071c <__mulsf3>    @ imm = #-0xaf32
 800b64e: 4603         	mov	r3, r0
 800b650: 68f9         	ldr	r1, [r7, #0xc]
 800b652: 4618         	mov	r0, r3
 800b654: f7f5 f916    	bl	0x8000884 <__divsf3>    @ imm = #-0xadd4
 800b658: 4603         	mov	r3, r0
 800b65a: 461a         	mov	r2, r3
 800b65c: 6a3b         	ldr	r3, [r7, #0x20]
 800b65e: 615a         	str	r2, [r3, #0x14]
;     *(pid_data->output) = kp * (err + pid_data->err_integral + pid_data->err_derivate);
 800b660: 6a3b         	ldr	r3, [r7, #0x20]
 800b662: 691b         	ldr	r3, [r3, #0x10]
 800b664: 6939         	ldr	r1, [r7, #0x10]
 800b666: 4618         	mov	r0, r3
 800b668: f7f4 ff50    	bl	0x800050c <__aeabi_fadd> @ imm = #-0xb160
 800b66c: 4603         	mov	r3, r0
 800b66e: 461a         	mov	r2, r3
 800b670: 6a3b         	ldr	r3, [r7, #0x20]
 800b672: 695b         	ldr	r3, [r3, #0x14]
 800b674: 4619         	mov	r1, r3
 800b676: 4610         	mov	r0, r2
 800b678: f7f4 ff48    	bl	0x800050c <__aeabi_fadd> @ imm = #-0xb170
 800b67c: 4603         	mov	r3, r0
 800b67e: 461a         	mov	r2, r3
 800b680: 6a3b         	ldr	r3, [r7, #0x20]
 800b682: 6a5c         	ldr	r4, [r3, #0x24]
 800b684: 69f9         	ldr	r1, [r7, #0x1c]
 800b686: 4610         	mov	r0, r2
 800b688: f7f5 f848    	bl	0x800071c <__mulsf3>    @ imm = #-0xaf70
 800b68c: 4603         	mov	r3, r0
 800b68e: 6023         	str	r3, [r4]
;     return;
 800b690: e000         	b	0x800b694 <pid_mit_calc+0x180> @ imm = #0x0
;         return;
 800b692: bf00         	nop
; }
 800b694: 3728         	adds	r7, #0x28
 800b696: 46bd         	mov	sp, r7
 800b698: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

0800b69c <$d>:
 800b69c: 19 86 61 18  	.word	0x18618619
 800b6a0: 00 24 74 49  	.word	0x49742400

0800b6a4 <HAL_RCC_GetSysClockFreq>:
; {
 800b6a4: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800b6a8: b090         	sub	sp, #0x40
 800b6aa: af00         	add	r7, sp, #0x0
;   uint32_t pllm = 0U;
 800b6ac: 2300         	movs	r3, #0x0
 800b6ae: 637b         	str	r3, [r7, #0x34]
;   uint32_t pllvco = 0U;
 800b6b0: 2300         	movs	r3, #0x0
 800b6b2: 63fb         	str	r3, [r7, #0x3c]
;   uint32_t pllp = 0U;
 800b6b4: 2300         	movs	r3, #0x0
 800b6b6: 633b         	str	r3, [r7, #0x30]
;   uint32_t sysclockfreq = 0U;
 800b6b8: 2300         	movs	r3, #0x0
 800b6ba: 63bb         	str	r3, [r7, #0x38]
;   switch (RCC->CFGR & RCC_CFGR_SWS)
 800b6bc: 4b59         	ldr	r3, [pc, #0x164]        @ 0x800b824 <HAL_RCC_GetSysClockFreq+0x180>
 800b6be: 689b         	ldr	r3, [r3, #0x8]
 800b6c0: f003 030c    	and	r3, r3, #0xc
 800b6c4: 2b08         	cmp	r3, #0x8
 800b6c6: d00d         	beq	0x800b6e4 <HAL_RCC_GetSysClockFreq+0x40> @ imm = #0x1a
 800b6c8: 2b08         	cmp	r3, #0x8
 800b6ca: f200 80a2    	bhi.w	0x800b812 <HAL_RCC_GetSysClockFreq+0x16e> @ imm = #0x144
 800b6ce: 2b00         	cmp	r3, #0x0
 800b6d0: d002         	beq	0x800b6d8 <HAL_RCC_GetSysClockFreq+0x34> @ imm = #0x4
 800b6d2: 2b04         	cmp	r3, #0x4
 800b6d4: d003         	beq	0x800b6de <HAL_RCC_GetSysClockFreq+0x3a> @ imm = #0x6
 800b6d6: e09c         	b	0x800b812 <HAL_RCC_GetSysClockFreq+0x16e> @ imm = #0x138
;       sysclockfreq = HSI_VALUE;
 800b6d8: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800b828 <HAL_RCC_GetSysClockFreq+0x184>
 800b6da: 63bb         	str	r3, [r7, #0x38]
;       break;
 800b6dc: e09c         	b	0x800b818 <HAL_RCC_GetSysClockFreq+0x174> @ imm = #0x138
;       sysclockfreq = HSE_VALUE;
 800b6de: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800b82c <HAL_RCC_GetSysClockFreq+0x188>
 800b6e0: 63bb         	str	r3, [r7, #0x38]
;       break;
 800b6e2: e099         	b	0x800b818 <HAL_RCC_GetSysClockFreq+0x174> @ imm = #0x132
;       pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800b6e4: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x800b824 <HAL_RCC_GetSysClockFreq+0x180>
 800b6e6: 685b         	ldr	r3, [r3, #0x4]
 800b6e8: f003 033f    	and	r3, r3, #0x3f
 800b6ec: 637b         	str	r3, [r7, #0x34]
;       if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800b6ee: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800b824 <HAL_RCC_GetSysClockFreq+0x180>
 800b6f0: 685b         	ldr	r3, [r3, #0x4]
 800b6f2: f403 0380    	and	r3, r3, #0x400000
 800b6f6: 2b00         	cmp	r3, #0x0
 800b6f8: d027         	beq	0x800b74a <HAL_RCC_GetSysClockFreq+0xa6> @ imm = #0x4e
;         pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800b6fa: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x800b824 <HAL_RCC_GetSysClockFreq+0x180>
 800b6fc: 685b         	ldr	r3, [r3, #0x4]
 800b6fe: 099b         	lsrs	r3, r3, #0x6
 800b700: 2200         	movs	r2, #0x0
 800b702: 623b         	str	r3, [r7, #0x20]
 800b704: 627a         	str	r2, [r7, #0x24]
 800b706: 6a3b         	ldr	r3, [r7, #0x20]
 800b708: f3c3 0008    	ubfx	r0, r3, #0x0, #0x9
 800b70c: 2100         	movs	r1, #0x0
 800b70e: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x800b82c <HAL_RCC_GetSysClockFreq+0x188>
 800b710: fb03 f201    	mul	r2, r3, r1
 800b714: 2300         	movs	r3, #0x0
 800b716: fb00 f303    	mul	r3, r0, r3
 800b71a: 4413         	add	r3, r2
 800b71c: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x800b82c <HAL_RCC_GetSysClockFreq+0x188>
 800b71e: fba0 2102    	umull	r2, r1, r0, r2
 800b722: 62f9         	str	r1, [r7, #0x2c]
 800b724: 62ba         	str	r2, [r7, #0x28]
 800b726: 6afa         	ldr	r2, [r7, #0x2c]
 800b728: 4413         	add	r3, r2
 800b72a: 62fb         	str	r3, [r7, #0x2c]
 800b72c: 6b7b         	ldr	r3, [r7, #0x34]
 800b72e: 2200         	movs	r2, #0x0
 800b730: 61bb         	str	r3, [r7, #0x18]
 800b732: 61fa         	str	r2, [r7, #0x1c]
 800b734: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 800b738: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 800b73c: f7f5 f9da    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0xac4c
 800b740: 4602         	mov	r2, r0
 800b742: 460b         	mov	r3, r1
 800b744: 4613         	mov	r3, r2
 800b746: 63fb         	str	r3, [r7, #0x3c]
 800b748: e055         	b	0x800b7f6 <HAL_RCC_GetSysClockFreq+0x152> @ imm = #0xaa
;         pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800b74a: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800b824 <HAL_RCC_GetSysClockFreq+0x180>
 800b74c: 685b         	ldr	r3, [r3, #0x4]
 800b74e: 099b         	lsrs	r3, r3, #0x6
 800b750: 2200         	movs	r2, #0x0
 800b752: 613b         	str	r3, [r7, #0x10]
 800b754: 617a         	str	r2, [r7, #0x14]
 800b756: 693b         	ldr	r3, [r7, #0x10]
 800b758: f3c3 0a08    	ubfx	r10, r3, #0x0, #0x9
 800b75c: f04f 0b00    	mov.w	r11, #0x0
 800b760: 4652         	mov	r2, r10
 800b762: 465b         	mov	r3, r11
 800b764: f04f 0000    	mov.w	r0, #0x0
 800b768: f04f 0100    	mov.w	r1, #0x0
 800b76c: 0159         	lsls	r1, r3, #0x5
 800b76e: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 800b772: 0150         	lsls	r0, r2, #0x5
 800b774: 4602         	mov	r2, r0
 800b776: 460b         	mov	r3, r1
 800b778: ebb2 080a    	subs.w	r8, r2, r10
 800b77c: eb63 090b    	sbc.w	r9, r3, r11
 800b780: f04f 0200    	mov.w	r2, #0x0
 800b784: f04f 0300    	mov.w	r3, #0x0
 800b788: ea4f 1389    	lsl.w	r3, r9, #0x6
 800b78c: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 800b790: ea4f 1288    	lsl.w	r2, r8, #0x6
 800b794: ebb2 0408    	subs.w	r4, r2, r8
 800b798: eb63 0509    	sbc.w	r5, r3, r9
 800b79c: f04f 0200    	mov.w	r2, #0x0
 800b7a0: f04f 0300    	mov.w	r3, #0x0
 800b7a4: 00eb         	lsls	r3, r5, #0x3
 800b7a6: ea43 7354    	orr.w	r3, r3, r4, lsr #29
 800b7aa: 00e2         	lsls	r2, r4, #0x3
 800b7ac: 4614         	mov	r4, r2
 800b7ae: 461d         	mov	r5, r3
 800b7b0: eb14 030a    	adds.w	r3, r4, r10
 800b7b4: 603b         	str	r3, [r7]
 800b7b6: eb45 030b    	adc.w	r3, r5, r11
 800b7ba: 607b         	str	r3, [r7, #0x4]
 800b7bc: f04f 0200    	mov.w	r2, #0x0
 800b7c0: f04f 0300    	mov.w	r3, #0x0
 800b7c4: e9d7 4500    	ldrd	r4, r5, [r7]
 800b7c8: 4629         	mov	r1, r5
 800b7ca: 028b         	lsls	r3, r1, #0xa
 800b7cc: 4620         	mov	r0, r4
 800b7ce: 4629         	mov	r1, r5
 800b7d0: 4604         	mov	r4, r0
 800b7d2: ea43 5394    	orr.w	r3, r3, r4, lsr #22
 800b7d6: 4601         	mov	r1, r0
 800b7d8: 028a         	lsls	r2, r1, #0xa
 800b7da: 4610         	mov	r0, r2
 800b7dc: 4619         	mov	r1, r3
 800b7de: 6b7b         	ldr	r3, [r7, #0x34]
 800b7e0: 2200         	movs	r2, #0x0
 800b7e2: 60bb         	str	r3, [r7, #0x8]
 800b7e4: 60fa         	str	r2, [r7, #0xc]
 800b7e6: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800b7ea: f7f5 f983    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0xacfa
 800b7ee: 4602         	mov	r2, r0
 800b7f0: 460b         	mov	r3, r1
 800b7f2: 4613         	mov	r3, r2
 800b7f4: 63fb         	str	r3, [r7, #0x3c]
;       pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) * 2U);
 800b7f6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b824 <HAL_RCC_GetSysClockFreq+0x180>
 800b7f8: 685b         	ldr	r3, [r3, #0x4]
 800b7fa: 0c1b         	lsrs	r3, r3, #0x10
 800b7fc: f003 0303    	and	r3, r3, #0x3
 800b800: 3301         	adds	r3, #0x1
 800b802: 005b         	lsls	r3, r3, #0x1
 800b804: 633b         	str	r3, [r7, #0x30]
;       sysclockfreq = pllvco / pllp;
 800b806: 6bfa         	ldr	r2, [r7, #0x3c]
 800b808: 6b3b         	ldr	r3, [r7, #0x30]
 800b80a: fbb2 f3f3    	udiv	r3, r2, r3
 800b80e: 63bb         	str	r3, [r7, #0x38]
;       break;
 800b810: e002         	b	0x800b818 <HAL_RCC_GetSysClockFreq+0x174> @ imm = #0x4
;       sysclockfreq = HSI_VALUE;
 800b812: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800b828 <HAL_RCC_GetSysClockFreq+0x184>
 800b814: 63bb         	str	r3, [r7, #0x38]
;       break;
 800b816: bf00         	nop
;   return sysclockfreq;
 800b818: 6bbb         	ldr	r3, [r7, #0x38]
; }
 800b81a: 4618         	mov	r0, r3
 800b81c: 3740         	adds	r7, #0x40
 800b81e: 46bd         	mov	sp, r7
 800b820: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800b824 <$d>:
 800b824: 00 38 02 40  	.word	0x40023800
 800b828: 00 24 f4 00  	.word	0x00f42400
 800b82c: 00 1b b7 00  	.word	0x00b71b00

0800b830 <LL_DMA_ConfigTransfer>:
; {
 800b830: b480         	push	{r7}
 800b832: b085         	sub	sp, #0x14
 800b834: af00         	add	r7, sp, #0x0
 800b836: 60f8         	str	r0, [r7, #0xc]
 800b838: 60b9         	str	r1, [r7, #0x8]
 800b83a: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR,
 800b83c: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800b874 <LL_DMA_ConfigTransfer+0x44>
 800b83e: 68bb         	ldr	r3, [r7, #0x8]
 800b840: 4413         	add	r3, r2
 800b842: 781b         	ldrb	r3, [r3]
 800b844: 461a         	mov	r2, r3
 800b846: 68fb         	ldr	r3, [r7, #0xc]
 800b848: 4413         	add	r3, r2
 800b84a: 681b         	ldr	r3, [r3]
 800b84c: f423 335f    	bic	r3, r3, #0x37c00
 800b850: f423 7378    	bic	r3, r3, #0x3e0
 800b854: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800b874 <LL_DMA_ConfigTransfer+0x44>
 800b856: 68ba         	ldr	r2, [r7, #0x8]
 800b858: 440a         	add	r2, r1
 800b85a: 7812         	ldrb	r2, [r2]
 800b85c: 4611         	mov	r1, r2
 800b85e: 68fa         	ldr	r2, [r7, #0xc]
 800b860: 440a         	add	r2, r1
 800b862: 4611         	mov	r1, r2
 800b864: 687a         	ldr	r2, [r7, #0x4]
 800b866: 4313         	orrs	r3, r2
 800b868: 600b         	str	r3, [r1]
; }
 800b86a: bf00         	nop
 800b86c: 3714         	adds	r7, #0x14
 800b86e: 46bd         	mov	sp, r7
 800b870: bc80         	pop	{r7}
 800b872: 4770         	bx	lr

0800b874 <$d>:
 800b874: 8c d8 01 08  	.word	0x0801d88c

0800b878 <LL_DMA_SetDataLength>:
; {
 800b878: b480         	push	{r7}
 800b87a: b085         	sub	sp, #0x14
 800b87c: af00         	add	r7, sp, #0x0
 800b87e: 60f8         	str	r0, [r7, #0xc]
 800b880: 60b9         	str	r1, [r7, #0x8]
 800b882: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT, NbData);
 800b884: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b8b8 <LL_DMA_SetDataLength+0x40>
 800b886: 68bb         	ldr	r3, [r7, #0x8]
 800b888: 4413         	add	r3, r2
 800b88a: 781b         	ldrb	r3, [r3]
 800b88c: 461a         	mov	r2, r3
 800b88e: 68fb         	ldr	r3, [r7, #0xc]
 800b890: 4413         	add	r3, r2
 800b892: 685b         	ldr	r3, [r3, #0x4]
 800b894: 0c1b         	lsrs	r3, r3, #0x10
 800b896: 041b         	lsls	r3, r3, #0x10
 800b898: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800b8b8 <LL_DMA_SetDataLength+0x40>
 800b89a: 68ba         	ldr	r2, [r7, #0x8]
 800b89c: 440a         	add	r2, r1
 800b89e: 7812         	ldrb	r2, [r2]
 800b8a0: 4611         	mov	r1, r2
 800b8a2: 68fa         	ldr	r2, [r7, #0xc]
 800b8a4: 440a         	add	r2, r1
 800b8a6: 4611         	mov	r1, r2
 800b8a8: 687a         	ldr	r2, [r7, #0x4]
 800b8aa: 4313         	orrs	r3, r2
 800b8ac: 604b         	str	r3, [r1, #0x4]
; }
 800b8ae: bf00         	nop
 800b8b0: 3714         	adds	r7, #0x14
 800b8b2: 46bd         	mov	sp, r7
 800b8b4: bc80         	pop	{r7}
 800b8b6: 4770         	bx	lr

0800b8b8 <$d>:
 800b8b8: 8c d8 01 08  	.word	0x0801d88c

0800b8bc <LL_DMA_SetChannelSelection>:
; {
 800b8bc: b480         	push	{r7}
 800b8be: b085         	sub	sp, #0x14
 800b8c0: af00         	add	r7, sp, #0x0
 800b8c2: 60f8         	str	r0, [r7, #0xc]
 800b8c4: 60b9         	str	r1, [r7, #0x8]
 800b8c6: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_CHSEL, Channel);
 800b8c8: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b8fc <LL_DMA_SetChannelSelection+0x40>
 800b8ca: 68bb         	ldr	r3, [r7, #0x8]
 800b8cc: 4413         	add	r3, r2
 800b8ce: 781b         	ldrb	r3, [r3]
 800b8d0: 461a         	mov	r2, r3
 800b8d2: 68fb         	ldr	r3, [r7, #0xc]
 800b8d4: 4413         	add	r3, r2
 800b8d6: 681b         	ldr	r3, [r3]
 800b8d8: f023 6260    	bic	r2, r3, #0xe000000
 800b8dc: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800b8fc <LL_DMA_SetChannelSelection+0x40>
 800b8de: 68bb         	ldr	r3, [r7, #0x8]
 800b8e0: 440b         	add	r3, r1
 800b8e2: 781b         	ldrb	r3, [r3]
 800b8e4: 4619         	mov	r1, r3
 800b8e6: 68fb         	ldr	r3, [r7, #0xc]
 800b8e8: 440b         	add	r3, r1
 800b8ea: 4619         	mov	r1, r3
 800b8ec: 687b         	ldr	r3, [r7, #0x4]
 800b8ee: 4313         	orrs	r3, r2
 800b8f0: 600b         	str	r3, [r1]
; }
 800b8f2: bf00         	nop
 800b8f4: 3714         	adds	r7, #0x14
 800b8f6: 46bd         	mov	sp, r7
 800b8f8: bc80         	pop	{r7}
 800b8fa: 4770         	bx	lr

0800b8fc <$d>:
 800b8fc: 8c d8 01 08  	.word	0x0801d88c

0800b900 <LL_DMA_SetMemoryBurstxfer>:
; {
 800b900: b480         	push	{r7}
 800b902: b085         	sub	sp, #0x14
 800b904: af00         	add	r7, sp, #0x0
 800b906: 60f8         	str	r0, [r7, #0xc]
 800b908: 60b9         	str	r1, [r7, #0x8]
 800b90a: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_MBURST, Mburst);
 800b90c: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b940 <LL_DMA_SetMemoryBurstxfer+0x40>
 800b90e: 68bb         	ldr	r3, [r7, #0x8]
 800b910: 4413         	add	r3, r2
 800b912: 781b         	ldrb	r3, [r3]
 800b914: 461a         	mov	r2, r3
 800b916: 68fb         	ldr	r3, [r7, #0xc]
 800b918: 4413         	add	r3, r2
 800b91a: 681b         	ldr	r3, [r3]
 800b91c: f023 72c0    	bic	r2, r3, #0x1800000
 800b920: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800b940 <LL_DMA_SetMemoryBurstxfer+0x40>
 800b922: 68bb         	ldr	r3, [r7, #0x8]
 800b924: 440b         	add	r3, r1
 800b926: 781b         	ldrb	r3, [r3]
 800b928: 4619         	mov	r1, r3
 800b92a: 68fb         	ldr	r3, [r7, #0xc]
 800b92c: 440b         	add	r3, r1
 800b92e: 4619         	mov	r1, r3
 800b930: 687b         	ldr	r3, [r7, #0x4]
 800b932: 4313         	orrs	r3, r2
 800b934: 600b         	str	r3, [r1]
; }
 800b936: bf00         	nop
 800b938: 3714         	adds	r7, #0x14
 800b93a: 46bd         	mov	sp, r7
 800b93c: bc80         	pop	{r7}
 800b93e: 4770         	bx	lr

0800b940 <$d>:
 800b940: 8c d8 01 08  	.word	0x0801d88c

0800b944 <LL_DMA_SetPeriphBurstxfer>:
; {
 800b944: b480         	push	{r7}
 800b946: b085         	sub	sp, #0x14
 800b948: af00         	add	r7, sp, #0x0
 800b94a: 60f8         	str	r0, [r7, #0xc]
 800b94c: 60b9         	str	r1, [r7, #0x8]
 800b94e: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_PBURST, Pburst);
 800b950: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b984 <LL_DMA_SetPeriphBurstxfer+0x40>
 800b952: 68bb         	ldr	r3, [r7, #0x8]
 800b954: 4413         	add	r3, r2
 800b956: 781b         	ldrb	r3, [r3]
 800b958: 461a         	mov	r2, r3
 800b95a: 68fb         	ldr	r3, [r7, #0xc]
 800b95c: 4413         	add	r3, r2
 800b95e: 681b         	ldr	r3, [r3]
 800b960: f423 02c0    	bic	r2, r3, #0x600000
 800b964: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800b984 <LL_DMA_SetPeriphBurstxfer+0x40>
 800b966: 68bb         	ldr	r3, [r7, #0x8]
 800b968: 440b         	add	r3, r1
 800b96a: 781b         	ldrb	r3, [r3]
 800b96c: 4619         	mov	r1, r3
 800b96e: 68fb         	ldr	r3, [r7, #0xc]
 800b970: 440b         	add	r3, r1
 800b972: 4619         	mov	r1, r3
 800b974: 687b         	ldr	r3, [r7, #0x4]
 800b976: 4313         	orrs	r3, r2
 800b978: 600b         	str	r3, [r1]
; }
 800b97a: bf00         	nop
 800b97c: 3714         	adds	r7, #0x14
 800b97e: 46bd         	mov	sp, r7
 800b980: bc80         	pop	{r7}
 800b982: 4770         	bx	lr

0800b984 <$d>:
 800b984: 8c d8 01 08  	.word	0x0801d88c

0800b988 <LL_DMA_ConfigFifo>:
; {
 800b988: b480         	push	{r7}
 800b98a: b085         	sub	sp, #0x14
 800b98c: af00         	add	r7, sp, #0x0
 800b98e: 60f8         	str	r0, [r7, #0xc]
 800b990: 60b9         	str	r1, [r7, #0x8]
 800b992: 607a         	str	r2, [r7, #0x4]
 800b994: 603b         	str	r3, [r7]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FTH|DMA_SxFCR_DMDIS, FifoMode|FifoThreshold);
 800b996: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800b9cc <LL_DMA_ConfigFifo+0x44>
 800b998: 68bb         	ldr	r3, [r7, #0x8]
 800b99a: 4413         	add	r3, r2
 800b99c: 781b         	ldrb	r3, [r3]
 800b99e: 461a         	mov	r2, r3
 800b9a0: 68fb         	ldr	r3, [r7, #0xc]
 800b9a2: 4413         	add	r3, r2
 800b9a4: 695b         	ldr	r3, [r3, #0x14]
 800b9a6: f023 0207    	bic	r2, r3, #0x7
 800b9aa: 6879         	ldr	r1, [r7, #0x4]
 800b9ac: 683b         	ldr	r3, [r7]
 800b9ae: 430b         	orrs	r3, r1
 800b9b0: 4806         	ldr	r0, [pc, #0x18]         @ 0x800b9cc <LL_DMA_ConfigFifo+0x44>
 800b9b2: 68b9         	ldr	r1, [r7, #0x8]
 800b9b4: 4401         	add	r1, r0
 800b9b6: 7809         	ldrb	r1, [r1]
 800b9b8: 4608         	mov	r0, r1
 800b9ba: 68f9         	ldr	r1, [r7, #0xc]
 800b9bc: 4401         	add	r1, r0
 800b9be: 4313         	orrs	r3, r2
 800b9c0: 614b         	str	r3, [r1, #0x14]
; }
 800b9c2: bf00         	nop
 800b9c4: 3714         	adds	r7, #0x14
 800b9c6: 46bd         	mov	sp, r7
 800b9c8: bc80         	pop	{r7}
 800b9ca: 4770         	bx	lr

0800b9cc <$d>:
 800b9cc: 8c d8 01 08  	.word	0x0801d88c

0800b9d0 <LL_DMA_SetMemoryAddress>:
; {
 800b9d0: b480         	push	{r7}
 800b9d2: b085         	sub	sp, #0x14
 800b9d4: af00         	add	r7, sp, #0x0
 800b9d6: 60f8         	str	r0, [r7, #0xc]
 800b9d8: 60b9         	str	r1, [r7, #0x8]
 800b9da: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->M0AR, MemoryAddress);
 800b9dc: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800b9fc <LL_DMA_SetMemoryAddress+0x2c>
 800b9de: 68bb         	ldr	r3, [r7, #0x8]
 800b9e0: 4413         	add	r3, r2
 800b9e2: 781b         	ldrb	r3, [r3]
 800b9e4: 461a         	mov	r2, r3
 800b9e6: 68fb         	ldr	r3, [r7, #0xc]
 800b9e8: 4413         	add	r3, r2
 800b9ea: 461a         	mov	r2, r3
 800b9ec: 687b         	ldr	r3, [r7, #0x4]
 800b9ee: 60d3         	str	r3, [r2, #0xc]
; }
 800b9f0: bf00         	nop
 800b9f2: 3714         	adds	r7, #0x14
 800b9f4: 46bd         	mov	sp, r7
 800b9f6: bc80         	pop	{r7}
 800b9f8: 4770         	bx	lr
 800b9fa: bf00         	nop

0800b9fc <$d>:
 800b9fc: 8c d8 01 08  	.word	0x0801d88c

0800ba00 <LL_DMA_SetPeriphAddress>:
; {
 800ba00: b480         	push	{r7}
 800ba02: b085         	sub	sp, #0x14
 800ba04: af00         	add	r7, sp, #0x0
 800ba06: 60f8         	str	r0, [r7, #0xc]
 800ba08: 60b9         	str	r1, [r7, #0x8]
 800ba0a: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->PAR, PeriphAddress);
 800ba0c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800ba2c <LL_DMA_SetPeriphAddress+0x2c>
 800ba0e: 68bb         	ldr	r3, [r7, #0x8]
 800ba10: 4413         	add	r3, r2
 800ba12: 781b         	ldrb	r3, [r3]
 800ba14: 461a         	mov	r2, r3
 800ba16: 68fb         	ldr	r3, [r7, #0xc]
 800ba18: 4413         	add	r3, r2
 800ba1a: 461a         	mov	r2, r3
 800ba1c: 687b         	ldr	r3, [r7, #0x4]
 800ba1e: 6093         	str	r3, [r2, #0x8]
; }
 800ba20: bf00         	nop
 800ba22: 3714         	adds	r7, #0x14
 800ba24: 46bd         	mov	sp, r7
 800ba26: bc80         	pop	{r7}
 800ba28: 4770         	bx	lr
 800ba2a: bf00         	nop

0800ba2c <$d>:
 800ba2c: 8c d8 01 08  	.word	0x0801d88c

0800ba30 <LL_FLASH_SetLatency>:
; {
 800ba30: b480         	push	{r7}
 800ba32: b083         	sub	sp, #0xc
 800ba34: af00         	add	r7, sp, #0x0
 800ba36: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 800ba38: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800ba54 <LL_FLASH_SetLatency+0x24>
 800ba3a: 681b         	ldr	r3, [r3]
 800ba3c: f023 0207    	bic	r2, r3, #0x7
 800ba40: 4904         	ldr	r1, [pc, #0x10]         @ 0x800ba54 <LL_FLASH_SetLatency+0x24>
 800ba42: 687b         	ldr	r3, [r7, #0x4]
 800ba44: 4313         	orrs	r3, r2
 800ba46: 600b         	str	r3, [r1]
; }
 800ba48: bf00         	nop
 800ba4a: 370c         	adds	r7, #0xc
 800ba4c: 46bd         	mov	sp, r7
 800ba4e: bc80         	pop	{r7}
 800ba50: 4770         	bx	lr
 800ba52: bf00         	nop

0800ba54 <$d>:
 800ba54: 00 3c 02 40  	.word	0x40023c00

0800ba58 <LL_FLASH_GetLatency>:
; {
 800ba58: b480         	push	{r7}
 800ba5a: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
 800ba5c: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800ba6c <LL_FLASH_GetLatency+0x14>
 800ba5e: 681b         	ldr	r3, [r3]
 800ba60: f003 0307    	and	r3, r3, #0x7
; }
 800ba64: 4618         	mov	r0, r3
 800ba66: 46bd         	mov	sp, r7
 800ba68: bc80         	pop	{r7}
 800ba6a: 4770         	bx	lr

0800ba6c <$d>:
 800ba6c: 00 3c 02 40  	.word	0x40023c00

0800ba70 <LL_PWR_GetRegulVoltageScaling>:
; {
 800ba70: b480         	push	{r7}
 800ba72: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(PWR->CR, PWR_CR_VOS));
 800ba74: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800ba84 <LL_PWR_GetRegulVoltageScaling+0x14>
 800ba76: 681b         	ldr	r3, [r3]
 800ba78: f403 4380    	and	r3, r3, #0x4000
; }
 800ba7c: 4618         	mov	r0, r3
 800ba7e: 46bd         	mov	sp, r7
 800ba80: bc80         	pop	{r7}
 800ba82: 4770         	bx	lr

0800ba84 <$d>:
 800ba84: 00 70 00 40  	.word	0x40007000

0800ba88 <LL_SetFlashLatency>:
; {
 800ba88: b580         	push	{r7, lr}
 800ba8a: b086         	sub	sp, #0x18
 800ba8c: af00         	add	r7, sp, #0x0
 800ba8e: 6078         	str	r0, [r7, #0x4]
;   uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */
 800ba90: 2300         	movs	r3, #0x0
 800ba92: 613b         	str	r3, [r7, #0x10]
;   ErrorStatus status = SUCCESS;
 800ba94: 2300         	movs	r3, #0x0
 800ba96: 73fb         	strb	r3, [r7, #0xf]
;   if(HCLK_Frequency == 0U)
 800ba98: 687b         	ldr	r3, [r7, #0x4]
 800ba9a: 2b00         	cmp	r3, #0x0
 800ba9c: d102         	bne	0x800baa4 <LL_SetFlashLatency+0x1c> @ imm = #0x4
;     status = ERROR;
 800ba9e: 2301         	movs	r3, #0x1
 800baa0: 73fb         	strb	r3, [r7, #0xf]
 800baa2: e078         	b	0x800bb96 <LL_SetFlashLatency+0x10e> @ imm = #0xf0
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)
 800baa4: f7ff ffe4    	bl	0x800ba70 <LL_PWR_GetRegulVoltageScaling> @ imm = #-0x38
 800baa8: 4603         	mov	r3, r0
 800baaa: f5b3 4f80    	cmp.w	r3, #0x4000
 800baae: d12d         	bne	0x800bb0c <LL_SetFlashLatency+0x84> @ imm = #0x5a
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY5_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800bab0: 687b         	ldr	r3, [r7, #0x4]
 800bab2: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x800bba0 <LL_SetFlashLatency+0x118>
 800bab4: 4293         	cmp	r3, r2
 800bab6: d904         	bls	0x800bac2 <LL_SetFlashLatency+0x3a> @ imm = #0x8
 800bab8: 693b         	ldr	r3, [r7, #0x10]
 800baba: 2b00         	cmp	r3, #0x0
 800babc: d101         	bne	0x800bac2 <LL_SetFlashLatency+0x3a> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_5;
 800babe: 2305         	movs	r3, #0x5
 800bac0: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800bac2: 687b         	ldr	r3, [r7, #0x4]
 800bac4: 4a37         	ldr	r2, [pc, #0xdc]         @ 0x800bba4 <LL_SetFlashLatency+0x11c>
 800bac6: 4293         	cmp	r3, r2
 800bac8: d904         	bls	0x800bad4 <LL_SetFlashLatency+0x4c> @ imm = #0x8
 800baca: 693b         	ldr	r3, [r7, #0x10]
 800bacc: 2b00         	cmp	r3, #0x0
 800bace: d101         	bne	0x800bad4 <LL_SetFlashLatency+0x4c> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_4;
 800bad0: 2304         	movs	r3, #0x4
 800bad2: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800bad4: 687b         	ldr	r3, [r7, #0x4]
 800bad6: 4a34         	ldr	r2, [pc, #0xd0]         @ 0x800bba8 <LL_SetFlashLatency+0x120>
 800bad8: 4293         	cmp	r3, r2
 800bada: d904         	bls	0x800bae6 <LL_SetFlashLatency+0x5e> @ imm = #0x8
 800badc: 693b         	ldr	r3, [r7, #0x10]
 800bade: 2b00         	cmp	r3, #0x0
 800bae0: d101         	bne	0x800bae6 <LL_SetFlashLatency+0x5e> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_3;
 800bae2: 2303         	movs	r3, #0x3
 800bae4: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800bae6: 687b         	ldr	r3, [r7, #0x4]
 800bae8: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x800bbac <LL_SetFlashLatency+0x124>
 800baea: 4293         	cmp	r3, r2
 800baec: d905         	bls	0x800bafa <LL_SetFlashLatency+0x72> @ imm = #0xa
 800baee: 693b         	ldr	r3, [r7, #0x10]
 800baf0: 2b00         	cmp	r3, #0x0
 800baf2: d102         	bne	0x800bafa <LL_SetFlashLatency+0x72> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 800baf4: 2302         	movs	r3, #0x2
 800baf6: 613b         	str	r3, [r7, #0x10]
 800baf8: e008         	b	0x800bb0c <LL_SetFlashLatency+0x84> @ imm = #0x10
;         if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800bafa: 687b         	ldr	r3, [r7, #0x4]
 800bafc: 4a2c         	ldr	r2, [pc, #0xb0]         @ 0x800bbb0 <LL_SetFlashLatency+0x128>
 800bafe: 4293         	cmp	r3, r2
 800bb00: d904         	bls	0x800bb0c <LL_SetFlashLatency+0x84> @ imm = #0x8
 800bb02: 693b         	ldr	r3, [r7, #0x10]
 800bb04: 2b00         	cmp	r3, #0x0
 800bb06: d101         	bne	0x800bb0c <LL_SetFlashLatency+0x84> @ imm = #0x2
;           latency = LL_FLASH_LATENCY_1;
 800bb08: 2301         	movs	r3, #0x1
 800bb0a: 613b         	str	r3, [r7, #0x10]
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2)
 800bb0c: f7ff ffb0    	bl	0x800ba70 <LL_PWR_GetRegulVoltageScaling> @ imm = #-0xa0
 800bb10: 4603         	mov	r3, r0
 800bb12: 2b00         	cmp	r3, #0x0
 800bb14: d124         	bne	0x800bb60 <LL_SetFlashLatency+0xd8> @ imm = #0x48
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800bb16: 687b         	ldr	r3, [r7, #0x4]
 800bb18: 4a22         	ldr	r2, [pc, #0x88]         @ 0x800bba4 <LL_SetFlashLatency+0x11c>
 800bb1a: 4293         	cmp	r3, r2
 800bb1c: d904         	bls	0x800bb28 <LL_SetFlashLatency+0xa0> @ imm = #0x8
 800bb1e: 693b         	ldr	r3, [r7, #0x10]
 800bb20: 2b00         	cmp	r3, #0x0
 800bb22: d101         	bne	0x800bb28 <LL_SetFlashLatency+0xa0> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_4;
 800bb24: 2304         	movs	r3, #0x4
 800bb26: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800bb28: 687b         	ldr	r3, [r7, #0x4]
 800bb2a: 4a1f         	ldr	r2, [pc, #0x7c]         @ 0x800bba8 <LL_SetFlashLatency+0x120>
 800bb2c: 4293         	cmp	r3, r2
 800bb2e: d904         	bls	0x800bb3a <LL_SetFlashLatency+0xb2> @ imm = #0x8
 800bb30: 693b         	ldr	r3, [r7, #0x10]
 800bb32: 2b00         	cmp	r3, #0x0
 800bb34: d101         	bne	0x800bb3a <LL_SetFlashLatency+0xb2> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_3;
 800bb36: 2303         	movs	r3, #0x3
 800bb38: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800bb3a: 687b         	ldr	r3, [r7, #0x4]
 800bb3c: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800bbac <LL_SetFlashLatency+0x124>
 800bb3e: 4293         	cmp	r3, r2
 800bb40: d905         	bls	0x800bb4e <LL_SetFlashLatency+0xc6> @ imm = #0xa
 800bb42: 693b         	ldr	r3, [r7, #0x10]
 800bb44: 2b00         	cmp	r3, #0x0
 800bb46: d102         	bne	0x800bb4e <LL_SetFlashLatency+0xc6> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 800bb48: 2302         	movs	r3, #0x2
 800bb4a: 613b         	str	r3, [r7, #0x10]
 800bb4c: e008         	b	0x800bb60 <LL_SetFlashLatency+0xd8> @ imm = #0x10
;         if((HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800bb4e: 687b         	ldr	r3, [r7, #0x4]
 800bb50: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800bbb0 <LL_SetFlashLatency+0x128>
 800bb52: 4293         	cmp	r3, r2
 800bb54: d904         	bls	0x800bb60 <LL_SetFlashLatency+0xd8> @ imm = #0x8
 800bb56: 693b         	ldr	r3, [r7, #0x10]
 800bb58: 2b00         	cmp	r3, #0x0
 800bb5a: d101         	bne	0x800bb60 <LL_SetFlashLatency+0xd8> @ imm = #0x2
;           latency = LL_FLASH_LATENCY_1;
 800bb5c: 2301         	movs	r3, #0x1
 800bb5e: 613b         	str	r3, [r7, #0x10]
;     LL_FLASH_SetLatency(latency);
 800bb60: 6938         	ldr	r0, [r7, #0x10]
 800bb62: f7ff ff65    	bl	0x800ba30 <LL_FLASH_SetLatency> @ imm = #-0x136
;     timeout = 2;
 800bb66: 2302         	movs	r3, #0x2
 800bb68: 617b         	str	r3, [r7, #0x14]
;     getlatency = LL_FLASH_GetLatency();
 800bb6a: f7ff ff75    	bl	0x800ba58 <LL_FLASH_GetLatency> @ imm = #-0x116
 800bb6e: 60b8         	str	r0, [r7, #0x8]
;     timeout--;
 800bb70: 697b         	ldr	r3, [r7, #0x14]
 800bb72: 3b01         	subs	r3, #0x1
 800bb74: 617b         	str	r3, [r7, #0x14]
;     } while ((getlatency != latency) && (timeout > 0));
 800bb76: 68ba         	ldr	r2, [r7, #0x8]
 800bb78: 693b         	ldr	r3, [r7, #0x10]
 800bb7a: 429a         	cmp	r2, r3
 800bb7c: d002         	beq	0x800bb84 <LL_SetFlashLatency+0xfc> @ imm = #0x4
 800bb7e: 697b         	ldr	r3, [r7, #0x14]
 800bb80: 2b00         	cmp	r3, #0x0
 800bb82: d1f2         	bne	0x800bb6a <LL_SetFlashLatency+0xe2> @ imm = #-0x1c
;     if(getlatency != latency)
 800bb84: 68ba         	ldr	r2, [r7, #0x8]
 800bb86: 693b         	ldr	r3, [r7, #0x10]
 800bb88: 429a         	cmp	r2, r3
 800bb8a: d002         	beq	0x800bb92 <LL_SetFlashLatency+0x10a> @ imm = #0x4
;       status = ERROR;
 800bb8c: 2301         	movs	r3, #0x1
 800bb8e: 73fb         	strb	r3, [r7, #0xf]
 800bb90: e001         	b	0x800bb96 <LL_SetFlashLatency+0x10e> @ imm = #0x2
;       status = SUCCESS;
 800bb92: 2300         	movs	r3, #0x0
 800bb94: 73fb         	strb	r3, [r7, #0xf]
;   return status;
 800bb96: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 800bb98: 4618         	mov	r0, r3
 800bb9a: 3718         	adds	r7, #0x18
 800bb9c: 46bd         	mov	sp, r7
 800bb9e: bd80         	pop	{r7, pc}

0800bba0 <$d>:
 800bba0: 80 d1 f0 08  	.word	0x08f0d180
 800bba4: 00 0e 27 07  	.word	0x07270e00
 800bba8: 80 4a 5d 05  	.word	0x055d4a80
 800bbac: 00 87 93 03  	.word	0x03938700
 800bbb0: 80 c3 c9 01  	.word	0x01c9c380

0800bbb4 <z_device_state_init>:
; {
 800bbb4: b580         	push	{r7, lr}
 800bbb6: b082         	sub	sp, #0x8
 800bbb8: af00         	add	r7, sp, #0x0
; 	STRUCT_SECTION_FOREACH(device, dev) {
 800bbba: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800bbe8 <z_device_state_init+0x34>
 800bbbc: 607b         	str	r3, [r7, #0x4]
 800bbbe: e005         	b	0x800bbcc <z_device_state_init+0x18> @ imm = #0xa
; 		k_object_init(dev);
 800bbc0: 6878         	ldr	r0, [r7, #0x4]
 800bbc2: f00c fe2f    	bl	0x8018824 <k_object_init> @ imm = #0xcc5e
; 	STRUCT_SECTION_FOREACH(device, dev) {
 800bbc6: 687b         	ldr	r3, [r7, #0x4]
 800bbc8: 3314         	adds	r3, #0x14
 800bbca: 607b         	str	r3, [r7, #0x4]
 800bbcc: 687b         	ldr	r3, [r7, #0x4]
 800bbce: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800bbec <z_device_state_init+0x38>
 800bbd0: 4293         	cmp	r3, r2
 800bbd2: bf34         	ite	lo
 800bbd4: 2301         	movlo	r3, #0x1
 800bbd6: 2300         	movhs	r3, #0x0
 800bbd8: b2db         	uxtb	r3, r3
 800bbda: 2b00         	cmp	r3, #0x0
 800bbdc: d1f0         	bne	0x800bbc0 <z_device_state_init+0xc> @ imm = #-0x20
; }
 800bbde: bf00         	nop
 800bbe0: bf00         	nop
 800bbe2: 3708         	adds	r7, #0x8
 800bbe4: 46bd         	mov	sp, r7
 800bbe6: bd80         	pop	{r7, pc}

0800bbe8 <$d>:
 800bbe8: d8 ac 01 08  	.word	0x0801acd8
 800bbec: 90 ae 01 08  	.word	0x0801ae90

0800bbf0 <k_sys_fatal_error_handler>:
; {
 800bbf0: b580         	push	{r7, lr}
 800bbf2: b088         	sub	sp, #0x20
 800bbf4: af04         	add	r7, sp, #0x10
 800bbf6: 6078         	str	r0, [r7, #0x4]
 800bbf8: 6039         	str	r1, [r7]
; 	LOG_PANIC();
 800bbfa: f00c fe66    	bl	0x80188ca <log_panic>   @ imm = #0xcccc
; 	LOG_ERR("Halting system");
 800bbfe: 2303         	movs	r3, #0x3
 800bc00: 2b00         	cmp	r3, #0x0
 800bc02: d016         	beq	0x800bc32 <k_sys_fatal_error_handler+0x42> @ imm = #0x2c
 800bc04: 2301         	movs	r3, #0x1
 800bc06: 73fb         	strb	r3, [r7, #0xf]
 800bc08: 7bfb         	ldrb	r3, [r7, #0xf]
 800bc0a: f083 0301    	eor	r3, r3, #0x1
 800bc0e: b2db         	uxtb	r3, r3
 800bc10: 2b00         	cmp	r3, #0x0
 800bc12: d10e         	bne	0x800bc32 <k_sys_fatal_error_handler+0x42> @ imm = #0x1c
 800bc14: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800bc38 <k_sys_fatal_error_handler+0x48>
 800bc16: 6819         	ldr	r1, [r3]
 800bc18: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800bc3c <k_sys_fatal_error_handler+0x4c>
 800bc1a: 9302         	str	r3, [sp, #0x8]
 800bc1c: 2300         	movs	r3, #0x0
 800bc1e: 9301         	str	r3, [sp, #0x4]
 800bc20: 2300         	movs	r3, #0x0
 800bc22: 9300         	str	r3, [sp]
 800bc24: 2300         	movs	r3, #0x0
 800bc26: 2201         	movs	r2, #0x1
 800bc28: 2000         	movs	r0, #0x0
 800bc2a: f00c fe30    	bl	0x801888e <z_log_msg_runtime_create> @ imm = #0xcc60
 800bc2e: 2300         	movs	r3, #0x0
 800bc30: 60bb         	str	r3, [r7, #0x8]
; 	arch_system_halt(reason);
 800bc32: 6878         	ldr	r0, [r7, #0x4]
 800bc34: f00c fe5a    	bl	0x80188ec <arch_system_halt> @ imm = #0xccb4

0800bc38 <$d>:
 800bc38: 38 05 00 20  	.word	0x20000538
 800bc3c: f8 c9 01 08  	.word	0x0801c9f8

0800bc40 <thread_name_get>:
; {
 800bc40: b580         	push	{r7, lr}
 800bc42: b084         	sub	sp, #0x10
 800bc44: af00         	add	r7, sp, #0x0
 800bc46: 6078         	str	r0, [r7, #0x4]
; 	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
 800bc48: 687b         	ldr	r3, [r7, #0x4]
 800bc4a: 2b00         	cmp	r3, #0x0
 800bc4c: d004         	beq	0x800bc58 <thread_name_get+0x18> @ imm = #0x8
 800bc4e: 6878         	ldr	r0, [r7, #0x4]
 800bc50: f00d ff41    	bl	0x8019ad6 <k_thread_name_get> @ imm = #0xde82
 800bc54: 4603         	mov	r3, r0
 800bc56: e000         	b	0x800bc5a <thread_name_get+0x1a> @ imm = #0x0
 800bc58: 2300         	movs	r3, #0x0
 800bc5a: 60fb         	str	r3, [r7, #0xc]
; 	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
 800bc5c: 68fb         	ldr	r3, [r7, #0xc]
 800bc5e: 2b00         	cmp	r3, #0x0
 800bc60: d003         	beq	0x800bc6a <thread_name_get+0x2a> @ imm = #0x6
 800bc62: 68fb         	ldr	r3, [r7, #0xc]
 800bc64: 781b         	ldrb	r3, [r3]
 800bc66: 2b00         	cmp	r3, #0x0
 800bc68: d101         	bne	0x800bc6e <thread_name_get+0x2e> @ imm = #0x2
; 		thread_name = "unknown";
 800bc6a: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800bc78 <thread_name_get+0x38>
 800bc6c: 60fb         	str	r3, [r7, #0xc]
; 	return thread_name;
 800bc6e: 68fb         	ldr	r3, [r7, #0xc]
; }
 800bc70: 4618         	mov	r0, r3
 800bc72: 3710         	adds	r7, #0x10
 800bc74: 46bd         	mov	sp, r7
 800bc76: bd80         	pop	{r7, pc}

0800bc78 <$d>:
 800bc78: 08 ca 01 08  	.word	0x0801ca08

0800bc7c <reason_to_str>:
; {
 800bc7c: b480         	push	{r7}
 800bc7e: b083         	sub	sp, #0xc
 800bc80: af00         	add	r7, sp, #0x0
 800bc82: 6078         	str	r0, [r7, #0x4]
; 	switch (reason) {
 800bc84: 687b         	ldr	r3, [r7, #0x4]
 800bc86: 2b04         	cmp	r3, #0x4
 800bc88: d816         	bhi	0x800bcb8 <reason_to_str+0x3c> @ imm = #0x2c
 800bc8a: a201         	adr	r2, #4 <reason_to_str+0x13>
 800bc8c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800bc90 <$d>:
 800bc90: a5 bc 00 08  	.word	0x0800bca5
 800bc94: a9 bc 00 08  	.word	0x0800bca9
 800bc98: ad bc 00 08  	.word	0x0800bcad
 800bc9c: b1 bc 00 08  	.word	0x0800bcb1
 800bca0: b5 bc 00 08  	.word	0x0800bcb5

0800bca4 <$t>:
; 		return "CPU exception";
 800bca4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800bcc4 <reason_to_str+0x48>
 800bca6: e008         	b	0x800bcba <reason_to_str+0x3e> @ imm = #0x10
; 		return "Unhandled interrupt";
 800bca8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800bcc8 <reason_to_str+0x4c>
 800bcaa: e006         	b	0x800bcba <reason_to_str+0x3e> @ imm = #0xc
; 		return "Stack overflow";
 800bcac: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800bccc <reason_to_str+0x50>
 800bcae: e004         	b	0x800bcba <reason_to_str+0x3e> @ imm = #0x8
; 		return "Kernel oops";
 800bcb0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800bcd0 <reason_to_str+0x54>
 800bcb2: e002         	b	0x800bcba <reason_to_str+0x3e> @ imm = #0x4
; 		return "Kernel panic";
 800bcb4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800bcd4 <reason_to_str+0x58>
 800bcb6: e000         	b	0x800bcba <reason_to_str+0x3e> @ imm = #0x0
; 		return "Unknown error";
 800bcb8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800bcd8 <reason_to_str+0x5c>
; }
 800bcba: 4618         	mov	r0, r3
 800bcbc: 370c         	adds	r7, #0xc
 800bcbe: 46bd         	mov	sp, r7
 800bcc0: bc80         	pop	{r7}
 800bcc2: 4770         	bx	lr

0800bcc4 <$d>:
 800bcc4: 10 ca 01 08  	.word	0x0801ca10
 800bcc8: 20 ca 01 08  	.word	0x0801ca20
 800bccc: 34 ca 01 08  	.word	0x0801ca34
 800bcd0: 44 ca 01 08  	.word	0x0801ca44
 800bcd4: 50 ca 01 08  	.word	0x0801ca50
 800bcd8: 60 ca 01 08  	.word	0x0801ca60

0800bcdc <z_fatal_error>:
; {
 800bcdc: b590         	push	{r4, r7, lr}
 800bcde: b099         	sub	sp, #0x64
 800bce0: af06         	add	r7, sp, #0x18
 800bce2: 6078         	str	r0, [r7, #0x4]
 800bce4: 6039         	str	r1, [r7]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bce6: f3ef 8311    	mrs	r3, basepri
 800bcea: 623b         	str	r3, [r7, #0x20]
;   return(result);
 800bcec: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 800bcee: 61fb         	str	r3, [r7, #0x1c]
 800bcf0: 2310         	movs	r3, #0x10
 800bcf2: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800bcf4: 69bb         	ldr	r3, [r7, #0x18]
 800bcf6: f383 8812    	msr	basepri_max, r3
; }
 800bcfa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800bcfc: f3bf 8f6f    	isb	sy
; }
 800bd00: bf00         	nop
; 	return key;
 800bd02: 69fb         	ldr	r3, [r7, #0x1c]
; 	unsigned int key = arch_irq_lock();
 800bd04: 63bb         	str	r3, [r7, #0x38]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800bd06: 4b50         	ldr	r3, [pc, #0x140]        @ 0x800be48 <z_fatal_error+0x16c>
 800bd08: 689b         	ldr	r3, [r3, #0x8]
 800bd0a: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800bd0c: 6a7b         	ldr	r3, [r7, #0x24]
; 			arch_current_thread() : NULL;
 800bd0e: 643b         	str	r3, [r7, #0x40]
; 	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
 800bd10: 2303         	movs	r3, #0x3
 800bd12: 2b00         	cmp	r3, #0x0
 800bd14: d023         	beq	0x800bd5e <z_fatal_error+0x82> @ imm = #0x46
 800bd16: 2301         	movs	r3, #0x1
 800bd18: f887 303f    	strb.w	r3, [r7, #0x3f]
 800bd1c: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800bd20: f083 0301    	eor	r3, r3, #0x1
 800bd24: b2db         	uxtb	r3, r3
 800bd26: 2b00         	cmp	r3, #0x0
 800bd28: d119         	bne	0x800bd5e <z_fatal_error+0x82> @ imm = #0x32
 800bd2a: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800be4c <z_fatal_error+0x170>
 800bd2c: 681c         	ldr	r4, [r3]
 800bd2e: 6878         	ldr	r0, [r7, #0x4]
 800bd30: f7ff ffa4    	bl	0x800bc7c <reason_to_str> @ imm = #-0xb8
 800bd34: 4603         	mov	r3, r0
 800bd36: 4a44         	ldr	r2, [pc, #0x110]        @ 0x800be48 <z_fatal_error+0x16c>
 800bd38: 7c12         	ldrb	r2, [r2, #0x10]
 800bd3a: 9205         	str	r2, [sp, #0x14]
 800bd3c: 9304         	str	r3, [sp, #0x10]
 800bd3e: 687b         	ldr	r3, [r7, #0x4]
 800bd40: 9303         	str	r3, [sp, #0xc]
 800bd42: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800be50 <z_fatal_error+0x174>
 800bd44: 9302         	str	r3, [sp, #0x8]
 800bd46: 2300         	movs	r3, #0x0
 800bd48: 9301         	str	r3, [sp, #0x4]
 800bd4a: 2300         	movs	r3, #0x0
 800bd4c: 9300         	str	r3, [sp]
 800bd4e: 2300         	movs	r3, #0x0
 800bd50: 2201         	movs	r2, #0x1
 800bd52: 4621         	mov	r1, r4
 800bd54: 2000         	movs	r0, #0x0
 800bd56: f00c fd9a    	bl	0x801888e <z_log_msg_runtime_create> @ imm = #0xcb34
 800bd5a: 2300         	movs	r3, #0x0
 800bd5c: 647b         	str	r3, [r7, #0x44]
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 800bd5e: 683b         	ldr	r3, [r7]
 800bd60: 2b00         	cmp	r3, #0x0
 800bd62: d028         	beq	0x800bdb6 <z_fatal_error+0xda> @ imm = #0x50
 800bd64: 683b         	ldr	r3, [r7]
 800bd66: 617b         	str	r3, [r7, #0x14]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 800bd68: 697b         	ldr	r3, [r7, #0x14]
 800bd6a: 69db         	ldr	r3, [r3, #0x1c]
 800bd6c: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 800bd70: 2b00         	cmp	r3, #0x0
 800bd72: bf14         	ite	ne
 800bd74: 2301         	movne	r3, #0x1
 800bd76: 2300         	moveq	r3, #0x0
 800bd78: b2db         	uxtb	r3, r3
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 800bd7a: 2b00         	cmp	r3, #0x0
 800bd7c: d01b         	beq	0x800bdb6 <z_fatal_error+0xda> @ imm = #0x36
; 		LOG_ERR("Fault during interrupt handling\n");
 800bd7e: 2303         	movs	r3, #0x3
 800bd80: 2b00         	cmp	r3, #0x0
 800bd82: d018         	beq	0x800bdb6 <z_fatal_error+0xda> @ imm = #0x30
 800bd84: 2301         	movs	r3, #0x1
 800bd86: f887 3037    	strb.w	r3, [r7, #0x37]
 800bd8a: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800bd8e: f083 0301    	eor	r3, r3, #0x1
 800bd92: b2db         	uxtb	r3, r3
 800bd94: 2b00         	cmp	r3, #0x0
 800bd96: d10e         	bne	0x800bdb6 <z_fatal_error+0xda> @ imm = #0x1c
 800bd98: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800be4c <z_fatal_error+0x170>
 800bd9a: 6819         	ldr	r1, [r3]
 800bd9c: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x800be54 <z_fatal_error+0x178>
 800bd9e: 9302         	str	r3, [sp, #0x8]
 800bda0: 2300         	movs	r3, #0x0
 800bda2: 9301         	str	r3, [sp, #0x4]
 800bda4: 2300         	movs	r3, #0x0
 800bda6: 9300         	str	r3, [sp]
 800bda8: 2300         	movs	r3, #0x0
 800bdaa: 2201         	movs	r2, #0x1
 800bdac: 2000         	movs	r0, #0x0
 800bdae: f00c fd6e    	bl	0x801888e <z_log_msg_runtime_create> @ imm = #0xcadc
 800bdb2: 2300         	movs	r3, #0x0
 800bdb4: 633b         	str	r3, [r7, #0x30]
; 		LOG_ERR("Current thread: %p (%s)", thread, thread_name_get(thread));
 800bdb6: 2303         	movs	r3, #0x3
 800bdb8: 2b00         	cmp	r3, #0x0
 800bdba: d020         	beq	0x800bdfe <z_fatal_error+0x122> @ imm = #0x40
 800bdbc: 2301         	movs	r3, #0x1
 800bdbe: f887 302f    	strb.w	r3, [r7, #0x2f]
 800bdc2: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800bdc6: f083 0301    	eor	r3, r3, #0x1
 800bdca: b2db         	uxtb	r3, r3
 800bdcc: 2b00         	cmp	r3, #0x0
 800bdce: d116         	bne	0x800bdfe <z_fatal_error+0x122> @ imm = #0x2c
 800bdd0: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800be4c <z_fatal_error+0x170>
 800bdd2: 681c         	ldr	r4, [r3]
 800bdd4: 6c38         	ldr	r0, [r7, #0x40]
 800bdd6: f7ff ff33    	bl	0x800bc40 <thread_name_get> @ imm = #-0x19a
 800bdda: 4603         	mov	r3, r0
 800bddc: 9304         	str	r3, [sp, #0x10]
 800bdde: 6c3b         	ldr	r3, [r7, #0x40]
 800bde0: 9303         	str	r3, [sp, #0xc]
 800bde2: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800be58 <z_fatal_error+0x17c>
 800bde4: 9302         	str	r3, [sp, #0x8]
 800bde6: 2300         	movs	r3, #0x0
 800bde8: 9301         	str	r3, [sp, #0x4]
 800bdea: 2300         	movs	r3, #0x0
 800bdec: 9300         	str	r3, [sp]
 800bdee: 2300         	movs	r3, #0x0
 800bdf0: 2201         	movs	r2, #0x1
 800bdf2: 4621         	mov	r1, r4
 800bdf4: 2000         	movs	r0, #0x0
 800bdf6: f00c fd4a    	bl	0x801888e <z_log_msg_runtime_create> @ imm = #0xca94
 800bdfa: 2300         	movs	r3, #0x0
 800bdfc: 62bb         	str	r3, [r7, #0x28]
; 	coredump(reason, esf, thread);
 800bdfe: 6c3a         	ldr	r2, [r7, #0x40]
 800be00: 6839         	ldr	r1, [r7]
 800be02: 6878         	ldr	r0, [r7, #0x4]
 800be04: f00c fd67    	bl	0x80188d6 <coredump>    @ imm = #0xcace
; 	k_sys_fatal_error_handler(reason, esf);
 800be08: 6839         	ldr	r1, [r7]
 800be0a: 6878         	ldr	r0, [r7, #0x4]
 800be0c: f7ff fef0    	bl	0x800bbf0 <k_sys_fatal_error_handler> @ imm = #-0x220
; 		if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 800be10: 683b         	ldr	r3, [r7]
 800be12: 2b00         	cmp	r3, #0x0
 800be14: d006         	beq	0x800be24 <z_fatal_error+0x148> @ imm = #0xc
 800be16: 683b         	ldr	r3, [r7]
 800be18: 613b         	str	r3, [r7, #0x10]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 800be1a: 693b         	ldr	r3, [r7, #0x10]
 800be1c: 69db         	ldr	r3, [r3, #0x1c]
 800be1e: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 800be22: 2b00         	cmp	r3, #0x0
 800be24: 6bbb         	ldr	r3, [r7, #0x38]
 800be26: 60fb         	str	r3, [r7, #0xc]
 800be28: 68fb         	ldr	r3, [r7, #0xc]
 800be2a: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800be2c: 68bb         	ldr	r3, [r7, #0x8]
 800be2e: f383 8811    	msr	basepri, r3
; }
 800be32: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800be34: f3bf 8f6f    	isb	sy
; }
 800be38: bf00         	nop
; }
 800be3a: bf00         	nop
; 		k_thread_abort(thread);
 800be3c: 6c38         	ldr	r0, [r7, #0x40]
 800be3e: f00c fd1b    	bl	0x8018878 <k_thread_abort> @ imm = #0xca36
; }
 800be42: 374c         	adds	r7, #0x4c
 800be44: 46bd         	mov	sp, r7
 800be46: bd90         	pop	{r4, r7, pc}

0800be48 <$d>:
 800be48: 30 07 00 20  	.word	0x20000730
 800be4c: 38 05 00 20  	.word	0x20000538
 800be50: 70 ca 01 08  	.word	0x0801ca70
 800be54: 98 ca 01 08  	.word	0x0801ca98
 800be58: bc ca 01 08  	.word	0x0801cabc

0800be5c <__NVIC_SetPriority>:
; {
 800be5c: b480         	push	{r7}
 800be5e: b083         	sub	sp, #0xc
 800be60: af00         	add	r7, sp, #0x0
 800be62: 4603         	mov	r3, r0
 800be64: 6039         	str	r1, [r7]
 800be66: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 800be68: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800be6c: 2b00         	cmp	r3, #0x0
 800be6e: db0a         	blt	0x800be86 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800be70: 683b         	ldr	r3, [r7]
 800be72: b2da         	uxtb	r2, r3
 800be74: 490c         	ldr	r1, [pc, #0x30]         @ 0x800bea8 <__NVIC_SetPriority+0x4c>
 800be76: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800be7a: 0112         	lsls	r2, r2, #0x4
 800be7c: b2d2         	uxtb	r2, r2
 800be7e: 440b         	add	r3, r1
 800be80: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 800be84: e00a         	b	0x800be9c <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800be86: 683b         	ldr	r3, [r7]
 800be88: b2da         	uxtb	r2, r3
 800be8a: 4908         	ldr	r1, [pc, #0x20]         @ 0x800beac <__NVIC_SetPriority+0x50>
 800be8c: 79fb         	ldrb	r3, [r7, #0x7]
 800be8e: f003 030f    	and	r3, r3, #0xf
 800be92: 3b04         	subs	r3, #0x4
 800be94: 0112         	lsls	r2, r2, #0x4
 800be96: b2d2         	uxtb	r2, r2
 800be98: 440b         	add	r3, r1
 800be9a: 761a         	strb	r2, [r3, #0x18]
; }
 800be9c: bf00         	nop
 800be9e: 370c         	adds	r7, #0xc
 800bea0: 46bd         	mov	sp, r7
 800bea2: bc80         	pop	{r7}
 800bea4: 4770         	bx	lr
 800bea6: bf00         	nop

0800bea8 <$d>:
 800bea8: 00 e1 00 e0  	.word	0xe000e100
 800beac: 00 ed 00 e0  	.word	0xe000ed00

0800beb0 <z_add_thread_timeout>:
; {
 800beb0: b580         	push	{r7, lr}
 800beb2: b084         	sub	sp, #0x10
 800beb4: af00         	add	r7, sp, #0x0
 800beb6: 60f8         	str	r0, [r7, #0xc]
 800beb8: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 800bebc: 68fb         	ldr	r3, [r7, #0xc]
 800bebe: f103 0018    	add.w	r0, r3, #0x18
 800bec2: e9d7 2300    	ldrd	r2, r3, [r7]
 800bec6: 4903         	ldr	r1, [pc, #0xc]          @ 0x800bed4 <z_add_thread_timeout+0x24>
 800bec8: f003 fc4e    	bl	0x800f768 <z_add_timeout> @ imm = #0x389c
; }
 800becc: bf00         	nop
 800bece: 3710         	adds	r7, #0x10
 800bed0: 46bd         	mov	sp, r7
 800bed2: bd80         	pop	{r7, pc}

0800bed4 <$d>:
 800bed4: 13 a2 01 08  	.word	0x0801a213

0800bed8 <z_dummy_thread_init>:
; {
 800bed8: b480         	push	{r7}
 800beda: b085         	sub	sp, #0x14
 800bedc: af00         	add	r7, sp, #0x0
 800bede: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 800bee0: 687b         	ldr	r3, [r7, #0x4]
 800bee2: 2201         	movs	r2, #0x1
 800bee4: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 800bee6: 687b         	ldr	r3, [r7, #0x4]
 800bee8: 2201         	movs	r2, #0x1
 800beea: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 800beec: 687b         	ldr	r3, [r7, #0x4]
 800beee: 2200         	movs	r2, #0x0
 800bef0: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 800bef4: 687b         	ldr	r3, [r7, #0x4]
 800bef6: 2200         	movs	r2, #0x0
 800bef8: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	dummy_thread->resource_pool = NULL;
 800befc: 687b         	ldr	r3, [r7, #0x4]
 800befe: 2200         	movs	r2, #0x0
 800bf00: f8c3 20c0    	str.w	r2, [r3, #0xc0]
 800bf04: 687b         	ldr	r3, [r7, #0x4]
 800bf06: 60fb         	str	r3, [r7, #0xc]
; 	_current_cpu->current = thread;
 800bf08: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800bf1c <z_dummy_thread_init+0x44>
 800bf0a: 68fb         	ldr	r3, [r7, #0xc]
 800bf0c: 6093         	str	r3, [r2, #0x8]
; }
 800bf0e: bf00         	nop
; }
 800bf10: bf00         	nop
 800bf12: 3714         	adds	r7, #0x14
 800bf14: 46bd         	mov	sp, r7
 800bf16: bc80         	pop	{r7}
 800bf18: 4770         	bx	lr
 800bf1a: bf00         	nop

0800bf1c <$d>:
 800bf1c: 30 07 00 20  	.word	0x20000730

0800bf20 <z_init_static_threads>:
; {
 800bf20: b5f0         	push	{r4, r5, r6, r7, lr}
 800bf22: b08f         	sub	sp, #0x3c
 800bf24: af06         	add	r7, sp, #0x18
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800bf26: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800bfec <z_init_static_threads+0xcc>
 800bf28: 61fb         	str	r3, [r7, #0x1c]
 800bf2a: e029         	b	0x800bf80 <z_init_static_threads+0x60> @ imm = #0x52
; 		z_setup_new_thread(
 800bf2c: 69fb         	ldr	r3, [r7, #0x1c]
 800bf2e: 681e         	ldr	r6, [r3]
 800bf30: 69fb         	ldr	r3, [r7, #0x1c]
 800bf32: 685b         	ldr	r3, [r3, #0x4]
 800bf34: 60fb         	str	r3, [r7, #0xc]
 800bf36: 69fb         	ldr	r3, [r7, #0x1c]
 800bf38: 689a         	ldr	r2, [r3, #0x8]
 800bf3a: 60ba         	str	r2, [r7, #0x8]
 800bf3c: 69fb         	ldr	r3, [r7, #0x1c]
 800bf3e: 68d8         	ldr	r0, [r3, #0xc]
 800bf40: 6078         	str	r0, [r7, #0x4]
 800bf42: 69fb         	ldr	r3, [r7, #0x1c]
 800bf44: 691b         	ldr	r3, [r3, #0x10]
 800bf46: 69fa         	ldr	r2, [r7, #0x1c]
 800bf48: 6952         	ldr	r2, [r2, #0x14]
 800bf4a: 69f9         	ldr	r1, [r7, #0x1c]
 800bf4c: 6989         	ldr	r1, [r1, #0x18]
 800bf4e: 69f8         	ldr	r0, [r7, #0x1c]
 800bf50: 69c0         	ldr	r0, [r0, #0x1c]
 800bf52: 69fc         	ldr	r4, [r7, #0x1c]
 800bf54: 6a24         	ldr	r4, [r4, #0x20]
 800bf56: 69fd         	ldr	r5, [r7, #0x1c]
 800bf58: 6a6d         	ldr	r5, [r5, #0x24]
 800bf5a: 9505         	str	r5, [sp, #0x14]
 800bf5c: 9404         	str	r4, [sp, #0x10]
 800bf5e: 9003         	str	r0, [sp, #0xc]
 800bf60: 9102         	str	r1, [sp, #0x8]
 800bf62: 9201         	str	r2, [sp, #0x4]
 800bf64: 9300         	str	r3, [sp]
 800bf66: 687b         	ldr	r3, [r7, #0x4]
 800bf68: 68ba         	ldr	r2, [r7, #0x8]
 800bf6a: 68f9         	ldr	r1, [r7, #0xc]
 800bf6c: 4630         	mov	r0, r6
 800bf6e: f001 fc85    	bl	0x800d87c <z_setup_new_thread> @ imm = #0x190a
; 		thread_data->init_thread->init_data = thread_data;
 800bf72: 69fb         	ldr	r3, [r7, #0x1c]
 800bf74: 681b         	ldr	r3, [r3]
 800bf76: 69fa         	ldr	r2, [r7, #0x1c]
 800bf78: 665a         	str	r2, [r3, #0x64]
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800bf7a: 69fb         	ldr	r3, [r7, #0x1c]
 800bf7c: 3330         	adds	r3, #0x30
 800bf7e: 61fb         	str	r3, [r7, #0x1c]
 800bf80: 69fb         	ldr	r3, [r7, #0x1c]
 800bf82: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800bff0 <z_init_static_threads+0xd0>
 800bf84: 4293         	cmp	r3, r2
 800bf86: bf34         	ite	lo
 800bf88: 2301         	movlo	r3, #0x1
 800bf8a: 2300         	movhs	r3, #0x0
 800bf8c: b2db         	uxtb	r3, r3
 800bf8e: 2b00         	cmp	r3, #0x0
 800bf90: d1cc         	bne	0x800bf2c <z_init_static_threads+0xc> @ imm = #-0x68
; 	k_sched_lock();
 800bf92: f002 fcdb    	bl	0x800e94c <k_sched_lock> @ imm = #0x29b6
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800bf96: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800bfec <z_init_static_threads+0xcc>
 800bf98: 61bb         	str	r3, [r7, #0x18]
 800bf9a: e018         	b	0x800bfce <z_init_static_threads+0xae> @ imm = #0x30
; 		k_timeout_t init_delay = Z_THREAD_INIT_DELAY(thread_data);
 800bf9c: 69bb         	ldr	r3, [r7, #0x18]
 800bf9e: e9d3 230a    	ldrd	r2, r3, [r3, #40]
 800bfa2: e9c7 2304    	strd	r2, r3, [r7, #16]
; 		if (!K_TIMEOUT_EQ(init_delay, K_FOREVER)) {
 800bfa6: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800bfaa: f04f 30ff    	mov.w	r0, #0xffffffff
 800bfae: f04f 31ff    	mov.w	r1, #0xffffffff
 800bfb2: 428b         	cmp	r3, r1
 800bfb4: bf08         	it	eq
 800bfb6: 4282         	cmpeq	r2, r0
 800bfb8: d006         	beq	0x800bfc8 <z_init_static_threads+0xa8> @ imm = #0xc
; 			thread_schedule_new(thread_data->init_thread,
 800bfba: 69bb         	ldr	r3, [r7, #0x18]
 800bfbc: 6819         	ldr	r1, [r3]
 800bfbe: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800bfc2: 4608         	mov	r0, r1
 800bfc4: f00c fcc6    	bl	0x8018954 <thread_schedule_new> @ imm = #0xc98c
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800bfc8: 69bb         	ldr	r3, [r7, #0x18]
 800bfca: 3330         	adds	r3, #0x30
 800bfcc: 61bb         	str	r3, [r7, #0x18]
 800bfce: 69bb         	ldr	r3, [r7, #0x18]
 800bfd0: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800bff0 <z_init_static_threads+0xd0>
 800bfd2: 4293         	cmp	r3, r2
 800bfd4: bf34         	ite	lo
 800bfd6: 2301         	movlo	r3, #0x1
 800bfd8: 2300         	movhs	r3, #0x0
 800bfda: b2db         	uxtb	r3, r3
 800bfdc: 2b00         	cmp	r3, #0x0
 800bfde: d1dd         	bne	0x800bf9c <z_init_static_threads+0x7c> @ imm = #-0x46
; 	k_sched_unlock();
 800bfe0: f002 fcf4    	bl	0x800e9cc <k_sched_unlock> @ imm = #0x29e8
; }
 800bfe4: bf00         	nop
 800bfe6: 3724         	adds	r7, #0x24
 800bfe8: 46bd         	mov	sp, r7
 800bfea: bdf0         	pop	{r4, r5, r6, r7, pc}

0800bfec <$d>:
 800bfec: 20 b1 01 08  	.word	0x0801b120
 800bff0: 20 b1 01 08  	.word	0x0801b120

0800bff4 <z_bss_zero>:
; {
 800bff4: b580         	push	{r7, lr}
 800bff6: af00         	add	r7, sp, #0x0
; 	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
 800bff8: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800c00c <z_bss_zero+0x18>
 800bffa: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800c010 <z_bss_zero+0x1c>
 800bffc: 1ad3         	subs	r3, r2, r3
 800bffe: 461a         	mov	r2, r3
 800c000: 2100         	movs	r1, #0x0
 800c002: 4803         	ldr	r0, [pc, #0xc]          @ 0x800c010 <z_bss_zero+0x1c>
 800c004: f00c fcf3    	bl	0x80189ee <z_early_memset> @ imm = #0xc9e6
; }
 800c008: bd80         	pop	{r7, pc}
 800c00a: bf00         	nop

0800c00c <$d>:
 800c00c: 44 11 00 20  	.word	0x20001144
 800c010: 30 06 00 20  	.word	0x20000630

0800c014 <z_sys_init_run_level>:
; {
 800c014: b580         	push	{r7, lr}
 800c016: b086         	sub	sp, #0x18
 800c018: af00         	add	r7, sp, #0x0
 800c01a: 4603         	mov	r3, r0
 800c01c: 71fb         	strb	r3, [r7, #0x7]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 800c01e: 79fb         	ldrb	r3, [r7, #0x7]
 800c020: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800c068 <z_sys_init_run_level+0x54>
 800c022: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c026: 617b         	str	r3, [r7, #0x14]
 800c028: e011         	b	0x800c04e <z_sys_init_run_level+0x3a> @ imm = #0x22
; 		const struct device *dev = entry->dev;
 800c02a: 697b         	ldr	r3, [r7, #0x14]
 800c02c: 685b         	ldr	r3, [r3, #0x4]
 800c02e: 613b         	str	r3, [r7, #0x10]
; 		if (dev != NULL) {
 800c030: 693b         	ldr	r3, [r7, #0x10]
 800c032: 2b00         	cmp	r3, #0x0
 800c034: d004         	beq	0x800c040 <z_sys_init_run_level+0x2c> @ imm = #0x8
; 			result = do_device_init(entry);
 800c036: 6978         	ldr	r0, [r7, #0x14]
 800c038: f00c fcf7    	bl	0x8018a2a <do_device_init> @ imm = #0xc9ee
 800c03c: 60f8         	str	r0, [r7, #0xc]
 800c03e: e003         	b	0x800c048 <z_sys_init_run_level+0x34> @ imm = #0x6
; 			result = entry->init_fn.sys();
 800c040: 697b         	ldr	r3, [r7, #0x14]
 800c042: 681b         	ldr	r3, [r3]
 800c044: 4798         	blx	r3
 800c046: 60f8         	str	r0, [r7, #0xc]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 800c048: 697b         	ldr	r3, [r7, #0x14]
 800c04a: 3308         	adds	r3, #0x8
 800c04c: 617b         	str	r3, [r7, #0x14]
 800c04e: 79fb         	ldrb	r3, [r7, #0x7]
 800c050: 3301         	adds	r3, #0x1
 800c052: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800c068 <z_sys_init_run_level+0x54>
 800c054: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c058: 697a         	ldr	r2, [r7, #0x14]
 800c05a: 429a         	cmp	r2, r3
 800c05c: d3e5         	blo	0x800c02a <z_sys_init_run_level+0x16> @ imm = #-0x36
; }
 800c05e: bf00         	nop
 800c060: bf00         	nop
 800c062: 3718         	adds	r7, #0x18
 800c064: 46bd         	mov	sp, r7
 800c066: bd80         	pop	{r7, pc}

0800c068 <$d>:
 800c068: 3c 05 00 20  	.word	0x2000053c

0800c06c <bg_thread_main>:
; {
 800c06c: b580         	push	{r7, lr}
 800c06e: b084         	sub	sp, #0x10
 800c070: af00         	add	r7, sp, #0x0
 800c072: 60f8         	str	r0, [r7, #0xc]
 800c074: 60b9         	str	r1, [r7, #0x8]
 800c076: 607a         	str	r2, [r7, #0x4]
; 	z_sys_post_kernel = true;
 800c078: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800c0a8 <bg_thread_main+0x3c>
 800c07a: 2201         	movs	r2, #0x1
 800c07c: 701a         	strb	r2, [r3]
; 	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 800c07e: 2003         	movs	r0, #0x3
 800c080: f7ff ffc8    	bl	0x800c014 <z_sys_init_run_level> @ imm = #-0x70
; 	boot_banner();
 800c084: f004 f838    	bl	0x80100f8 <boot_banner> @ imm = #0x4070
; 	z_init_static();
 800c088: f00c fd05    	bl	0x8018a96 <z_init_static> @ imm = #0xca0a
; 	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
 800c08c: 2004         	movs	r0, #0x4
 800c08e: f7ff ffc1    	bl	0x800c014 <z_sys_init_run_level> @ imm = #-0x7e
; 	z_init_static_threads();
 800c092: f7ff ff45    	bl	0x800bf20 <z_init_static_threads> @ imm = #-0x176
; 	(void)main();
 800c096: f7f4 fefb    	bl	0x8000e90 <main>        @ imm = #-0xb20a
; 	z_thread_essential_clear(&z_main_thread);
 800c09a: 4804         	ldr	r0, [pc, #0x10]         @ 0x800c0ac <bg_thread_main+0x40>
 800c09c: f00c fc87    	bl	0x80189ae <z_thread_essential_clear> @ imm = #0xc90e
; } /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 800c0a0: bf00         	nop
 800c0a2: 3710         	adds	r7, #0x10
 800c0a4: 46bd         	mov	sp, r7
 800c0a6: bd80         	pop	{r7, pc}

0800c0a8 <$d>:
 800c0a8: 42 11 00 20  	.word	0x20001142
 800c0ac: 70 07 00 20  	.word	0x20000770

0800c0b0 <init_idle_thread>:
; {
 800c0b0: b580         	push	{r7, lr}
 800c0b2: b08c         	sub	sp, #0x30
 800c0b4: af06         	add	r7, sp, #0x18
 800c0b6: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = &z_idle_threads[i];
 800c0b8: 687b         	ldr	r3, [r7, #0x4]
 800c0ba: 22d0         	movs	r2, #0xd0
 800c0bc: fb02 f303    	mul	r3, r2, r3
 800c0c0: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800c120 <init_idle_thread+0x70>
 800c0c2: 4413         	add	r3, r2
 800c0c4: 617b         	str	r3, [r7, #0x14]
; 	k_thread_stack_t *stack = z_idle_stacks[i];
 800c0c6: 687a         	ldr	r2, [r7, #0x4]
 800c0c8: 4613         	mov	r3, r2
 800c0ca: 009b         	lsls	r3, r3, #0x2
 800c0cc: 4413         	add	r3, r2
 800c0ce: 019b         	lsls	r3, r3, #0x6
 800c0d0: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800c124 <init_idle_thread+0x74>
 800c0d2: 4413         	add	r3, r2
 800c0d4: 613b         	str	r3, [r7, #0x10]
; 	size_t stack_size = K_KERNEL_STACK_SIZEOF(z_idle_stacks[i]);
 800c0d6: f44f 73a0    	mov.w	r3, #0x140
 800c0da: 60fb         	str	r3, [r7, #0xc]
; 	char *tname = "idle";
 800c0dc: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800c128 <init_idle_thread+0x78>
 800c0de: 60bb         	str	r3, [r7, #0x8]
; 			  stack_size, idle, &_kernel.cpus[i],
 800c0e0: 687a         	ldr	r2, [r7, #0x4]
 800c0e2: 4613         	mov	r3, r2
 800c0e4: 00db         	lsls	r3, r3, #0x3
 800c0e6: 1a9b         	subs	r3, r3, r2
 800c0e8: 009b         	lsls	r3, r3, #0x2
 800c0ea: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800c12c <init_idle_thread+0x7c>
 800c0ec: 4413         	add	r3, r2
; 	z_setup_new_thread(thread, stack,
 800c0ee: 68ba         	ldr	r2, [r7, #0x8]
 800c0f0: 9205         	str	r2, [sp, #0x14]
 800c0f2: 2201         	movs	r2, #0x1
 800c0f4: 9204         	str	r2, [sp, #0x10]
 800c0f6: 220f         	movs	r2, #0xf
 800c0f8: 9203         	str	r2, [sp, #0xc]
 800c0fa: 2200         	movs	r2, #0x0
 800c0fc: 9202         	str	r2, [sp, #0x8]
 800c0fe: 2200         	movs	r2, #0x0
 800c100: 9201         	str	r2, [sp, #0x4]
 800c102: 9300         	str	r3, [sp]
 800c104: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800c130 <init_idle_thread+0x80>
 800c106: 68fa         	ldr	r2, [r7, #0xc]
 800c108: 6939         	ldr	r1, [r7, #0x10]
 800c10a: 6978         	ldr	r0, [r7, #0x14]
 800c10c: f001 fbb6    	bl	0x800d87c <z_setup_new_thread> @ imm = #0x176c
; 	z_mark_thread_as_not_suspended(thread);
 800c110: 6978         	ldr	r0, [r7, #0x14]
 800c112: f00c fc3c    	bl	0x801898e <z_mark_thread_as_not_suspended> @ imm = #0xc878
; }
 800c116: bf00         	nop
 800c118: 3718         	adds	r7, #0x18
 800c11a: 46bd         	mov	sp, r7
 800c11c: bd80         	pop	{r7, pc}
 800c11e: bf00         	nop

0800c120 <$d>:
 800c120: 40 08 00 20  	.word	0x20000840
 800c124: 48 2d 00 20  	.word	0x20002d48
 800c128: d8 ca 01 08  	.word	0x0801cad8
 800c12c: 30 07 00 20  	.word	0x20000730
 800c130: af 8a 01 08  	.word	0x08018aaf

0800c134 <z_init_cpu>:
; {
 800c134: b580         	push	{r7, lr}
 800c136: b082         	sub	sp, #0x8
 800c138: af00         	add	r7, sp, #0x0
 800c13a: 6078         	str	r0, [r7, #0x4]
; 	init_idle_thread(id);
 800c13c: 6878         	ldr	r0, [r7, #0x4]
 800c13e: f7ff ffb7    	bl	0x800c0b0 <init_idle_thread> @ imm = #-0x92
; 	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 800c142: 687b         	ldr	r3, [r7, #0x4]
 800c144: 22d0         	movs	r2, #0xd0
 800c146: fb02 f303    	mul	r3, r2, r3
 800c14a: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x800c1d8 <z_init_cpu+0xa4>
 800c14c: 1899         	adds	r1, r3, r2
 800c14e: 4823         	ldr	r0, [pc, #0x8c]         @ 0x800c1dc <z_init_cpu+0xa8>
 800c150: 687a         	ldr	r2, [r7, #0x4]
 800c152: 4613         	mov	r3, r2
 800c154: 00db         	lsls	r3, r3, #0x3
 800c156: 1a9b         	subs	r3, r3, r2
 800c158: 009b         	lsls	r3, r3, #0x2
 800c15a: 4403         	add	r3, r0
 800c15c: 330c         	adds	r3, #0xc
 800c15e: 6019         	str	r1, [r3]
; 	_kernel.cpus[id].id = id;
 800c160: 687b         	ldr	r3, [r7, #0x4]
 800c162: b2d8         	uxtb	r0, r3
 800c164: 491d         	ldr	r1, [pc, #0x74]         @ 0x800c1dc <z_init_cpu+0xa8>
 800c166: 687a         	ldr	r2, [r7, #0x4]
 800c168: 4613         	mov	r3, r2
 800c16a: 00db         	lsls	r3, r3, #0x3
 800c16c: 1a9b         	subs	r3, r3, r2
 800c16e: 009b         	lsls	r3, r3, #0x2
 800c170: 440b         	add	r3, r1
 800c172: 3310         	adds	r3, #0x10
 800c174: 4602         	mov	r2, r0
 800c176: 701a         	strb	r2, [r3]
; 		(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 800c178: 687b         	ldr	r3, [r7, #0x4]
 800c17a: 02db         	lsls	r3, r3, #0xb
 800c17c: 4a18         	ldr	r2, [pc, #0x60]         @ 0x800c1e0 <z_init_cpu+0xac>
 800c17e: 4413         	add	r3, r2
 800c180: 4618         	mov	r0, r3
 800c182: f00c fbc7    	bl	0x8018914 <K_KERNEL_STACK_BUFFER> @ imm = #0xc78e
 800c186: 4603         	mov	r3, r0
 800c188: f503 6100    	add.w	r1, r3, #0x800
; 	_kernel.cpus[id].irq_stack =
 800c18c: 4813         	ldr	r0, [pc, #0x4c]         @ 0x800c1dc <z_init_cpu+0xa8>
 800c18e: 687a         	ldr	r2, [r7, #0x4]
 800c190: 4613         	mov	r3, r2
 800c192: 00db         	lsls	r3, r3, #0x3
 800c194: 1a9b         	subs	r3, r3, r2
 800c196: 009b         	lsls	r3, r3, #0x2
 800c198: 4403         	add	r3, r0
 800c19a: 3304         	adds	r3, #0x4
 800c19c: 6019         	str	r1, [r3]
; 	_kernel.cpus[id].usage = &_kernel.usage[id];
 800c19e: 687b         	ldr	r3, [r7, #0x4]
 800c1a0: 3303         	adds	r3, #0x3
 800c1a2: 011b         	lsls	r3, r3, #0x4
 800c1a4: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800c1dc <z_init_cpu+0xa8>
 800c1a6: 1899         	adds	r1, r3, r2
 800c1a8: 480c         	ldr	r0, [pc, #0x30]         @ 0x800c1dc <z_init_cpu+0xa8>
 800c1aa: 687a         	ldr	r2, [r7, #0x4]
 800c1ac: 4613         	mov	r3, r2
 800c1ae: 00db         	lsls	r3, r3, #0x3
 800c1b0: 1a9b         	subs	r3, r3, r2
 800c1b2: 009b         	lsls	r3, r3, #0x2
 800c1b4: 4403         	add	r3, r0
 800c1b6: 3318         	adds	r3, #0x18
 800c1b8: 6019         	str	r1, [r3]
; 	_kernel.cpus[id].usage->track_usage =
 800c1ba: 4908         	ldr	r1, [pc, #0x20]         @ 0x800c1dc <z_init_cpu+0xa8>
 800c1bc: 687a         	ldr	r2, [r7, #0x4]
 800c1be: 4613         	mov	r3, r2
 800c1c0: 00db         	lsls	r3, r3, #0x3
 800c1c2: 1a9b         	subs	r3, r3, r2
 800c1c4: 009b         	lsls	r3, r3, #0x2
 800c1c6: 440b         	add	r3, r1
 800c1c8: 3318         	adds	r3, #0x18
 800c1ca: 681b         	ldr	r3, [r3]
 800c1cc: 2201         	movs	r2, #0x1
 800c1ce: 721a         	strb	r2, [r3, #0x8]
; }
 800c1d0: bf00         	nop
 800c1d2: 3708         	adds	r7, #0x8
 800c1d4: 46bd         	mov	sp, r7
 800c1d6: bd80         	pop	{r7, pc}

0800c1d8 <$d>:
 800c1d8: 40 08 00 20  	.word	0x20000840
 800c1dc: 30 07 00 20  	.word	0x20000730
 800c1e0: 88 2e 00 20  	.word	0x20002e88

0800c1e4 <prepare_multithreading>:
; {
 800c1e4: b580         	push	{r7, lr}
 800c1e6: b088         	sub	sp, #0x20
 800c1e8: af06         	add	r7, sp, #0x18
; 	z_sched_init();
 800c1ea: f002 fccd    	bl	0x800eb88 <z_sched_init> @ imm = #0x299a
; 	_kernel.ready_q.cache = &z_main_thread;
 800c1ee: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800c238 <prepare_multithreading+0x54>
 800c1f0: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800c23c <prepare_multithreading+0x58>
 800c1f2: 61da         	str	r2, [r3, #0x1c]
; 	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 800c1f4: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800c240 <prepare_multithreading+0x5c>
 800c1f6: 9305         	str	r3, [sp, #0x14]
 800c1f8: 2301         	movs	r3, #0x1
 800c1fa: 9304         	str	r3, [sp, #0x10]
 800c1fc: 2300         	movs	r3, #0x0
 800c1fe: 9303         	str	r3, [sp, #0xc]
 800c200: 2300         	movs	r3, #0x0
 800c202: 9302         	str	r3, [sp, #0x8]
 800c204: 2300         	movs	r3, #0x0
 800c206: 9301         	str	r3, [sp, #0x4]
 800c208: 2300         	movs	r3, #0x0
 800c20a: 9300         	str	r3, [sp]
 800c20c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800c244 <prepare_multithreading+0x60>
 800c20e: f44f 6280    	mov.w	r2, #0x400
 800c212: 490d         	ldr	r1, [pc, #0x34]         @ 0x800c248 <prepare_multithreading+0x64>
 800c214: 4809         	ldr	r0, [pc, #0x24]         @ 0x800c23c <prepare_multithreading+0x58>
 800c216: f001 fb31    	bl	0x800d87c <z_setup_new_thread> @ imm = #0x1662
 800c21a: 6078         	str	r0, [r7, #0x4]
; 	z_mark_thread_as_not_suspended(&z_main_thread);
 800c21c: 4807         	ldr	r0, [pc, #0x1c]         @ 0x800c23c <prepare_multithreading+0x58>
 800c21e: f00c fbb6    	bl	0x801898e <z_mark_thread_as_not_suspended> @ imm = #0xc76c
; 	z_ready_thread(&z_main_thread);
 800c222: 4806         	ldr	r0, [pc, #0x18]         @ 0x800c23c <prepare_multithreading+0x58>
 800c224: f001 fdf2    	bl	0x800de0c <z_ready_thread> @ imm = #0x1be4
; 	z_init_cpu(0);
 800c228: 2000         	movs	r0, #0x0
 800c22a: f7ff ff83    	bl	0x800c134 <z_init_cpu>  @ imm = #-0xfa
; 	return stack_ptr;
 800c22e: 687b         	ldr	r3, [r7, #0x4]
; }
 800c230: 4618         	mov	r0, r3
 800c232: 3708         	adds	r7, #0x8
 800c234: 46bd         	mov	sp, r7
 800c236: bd80         	pop	{r7, pc}

0800c238 <$d>:
 800c238: 30 07 00 20  	.word	0x20000730
 800c23c: 70 07 00 20  	.word	0x20000770
 800c240: e0 ca 01 08  	.word	0x0801cae0
 800c244: 6d c0 00 08  	.word	0x0800c06d
 800c248: 48 29 00 20  	.word	0x20002948

0800c24c <switch_to_main_thread>:
; {
 800c24c: b580         	push	{r7, lr}
 800c24e: b082         	sub	sp, #0x8
 800c250: af00         	add	r7, sp, #0x0
 800c252: 6078         	str	r0, [r7, #0x4]
; 	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 800c254: 4a02         	ldr	r2, [pc, #0x8]          @ 0x800c260 <switch_to_main_thread+0x14>
 800c256: 6879         	ldr	r1, [r7, #0x4]
 800c258: 4802         	ldr	r0, [pc, #0x8]          @ 0x800c264 <switch_to_main_thread+0x18>
 800c25a: f7f7 fa03    	bl	0x8003664 <arch_switch_to_main_thread> @ imm = #-0x8bfa
 800c25e: bf00         	nop

0800c260 <$d>:
 800c260: 6d c0 00 08  	.word	0x0800c06d
 800c264: 70 07 00 20  	.word	0x20000770

0800c268 <z_cstart>:
; {
 800c268: b580         	push	{r7, lr}
 800c26a: b082         	sub	sp, #0x8
 800c26c: af00         	add	r7, sp, #0x0
; 	gcov_static_init();
 800c26e: f00c fbae    	bl	0x80189ce <gcov_static_init> @ imm = #0xc75c
; 	z_sys_init_run_level(INIT_LEVEL_EARLY);
 800c272: 2000         	movs	r0, #0x0
 800c274: f7ff fece    	bl	0x800c014 <z_sys_init_run_level> @ imm = #-0x264
; 		(uint32_t)(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
 800c278: 482d         	ldr	r0, [pc, #0xb4]         @ 0x800c330 <z_cstart+0xc8>
 800c27a: f00c fb4b    	bl	0x8018914 <K_KERNEL_STACK_BUFFER> @ imm = #0xc696
 800c27e: 4603         	mov	r3, r0
; 	uint32_t msp =
 800c280: f503 6300    	add.w	r3, r3, #0x800
 800c284: 607b         	str	r3, [r7, #0x4]
 800c286: 687b         	ldr	r3, [r7, #0x4]
 800c288: 603b         	str	r3, [r7]
;   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 800c28a: 683b         	ldr	r3, [r7]
 800c28c: f383 8808    	msr	msp, r3
; }
 800c290: bf00         	nop
; 	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
 800c292: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800c334 <z_cstart+0xcc>
 800c294: 695b         	ldr	r3, [r3, #0x14]
 800c296: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x800c334 <z_cstart+0xcc>
 800c298: f443 7300    	orr	r3, r3, #0x200
 800c29c: 6153         	str	r3, [r2, #0x14]
; }
 800c29e: bf00         	nop
; 	NVIC_SetPriority(PendSV_IRQn, _EXC_PENDSV_PRIO);
 800c2a0: 21ff         	movs	r1, #0xff
 800c2a2: f06f 0001    	mvn	r0, #0x1
 800c2a6: f7ff fdd9    	bl	0x800be5c <__NVIC_SetPriority> @ imm = #-0x44e
; 	NVIC_SetPriority(SVCall_IRQn, _EXC_SVC_PRIO);
 800c2aa: 2100         	movs	r1, #0x0
 800c2ac: f06f 0004    	mvn	r0, #0x4
 800c2b0: f7ff fdd4    	bl	0x800be5c <__NVIC_SetPriority> @ imm = #-0x458
; 	NVIC_SetPriority(MemoryManagement_IRQn, _EXC_FAULT_PRIO);
 800c2b4: 2100         	movs	r1, #0x0
 800c2b6: f06f 000b    	mvn	r0, #0xb
 800c2ba: f7ff fdcf    	bl	0x800be5c <__NVIC_SetPriority> @ imm = #-0x462
; 	NVIC_SetPriority(BusFault_IRQn, _EXC_FAULT_PRIO);
 800c2be: 2100         	movs	r1, #0x0
 800c2c0: f06f 000a    	mvn	r0, #0xa
 800c2c4: f7ff fdca    	bl	0x800be5c <__NVIC_SetPriority> @ imm = #-0x46c
; 	NVIC_SetPriority(UsageFault_IRQn, _EXC_FAULT_PRIO);
 800c2c8: 2100         	movs	r1, #0x0
 800c2ca: f06f 0009    	mvn	r0, #0x9
 800c2ce: f7ff fdc5    	bl	0x800be5c <__NVIC_SetPriority> @ imm = #-0x476
; 	NVIC_SetPriority(DebugMonitor_IRQn, _EXC_FAULT_PRIO);
 800c2d2: 2100         	movs	r1, #0x0
 800c2d4: f06f 0003    	mvn	r0, #0x3
 800c2d8: f7ff fdc0    	bl	0x800be5c <__NVIC_SetPriority> @ imm = #-0x480
; 	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 800c2dc: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800c334 <z_cstart+0xcc>
 800c2de: 6a5b         	ldr	r3, [r3, #0x24]
 800c2e0: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800c334 <z_cstart+0xcc>
 800c2e2: f443 23e0    	orr	r3, r3, #0x70000
 800c2e6: 6253         	str	r3, [r2, #0x24]
; }
 800c2e8: bf00         	nop
; 	z_arm_fault_init();
 800c2ea: f7f7 f823    	bl	0x8003334 <z_arm_fault_init> @ imm = #-0x8fba
; 	z_arm_cpu_idle_init();
 800c2ee: f7f7 f9e9    	bl	0x80036c4 <z_arm_cpu_idle_init> @ imm = #-0x8c2e
; 	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 800c2f2: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800c334 <z_cstart+0xcc>
 800c2f4: f04f 32ff    	mov.w	r2, #0xffffffff
 800c2f8: 629a         	str	r2, [r3, #0x28]
; 	SCB->HFSR = 0xffffffff;
 800c2fa: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800c334 <z_cstart+0xcc>
 800c2fc: f04f 32ff    	mov.w	r2, #0xffffffff
 800c300: 62da         	str	r2, [r3, #0x2c]
; }
 800c302: bf00         	nop
; }
 800c304: bf00         	nop
; 	LOG_CORE_INIT();
 800c306: f7f5 fa9f    	bl	0x8001848 <log_core_init> @ imm = #-0xaac2
; 	z_dummy_thread_init(&_thread_dummy);
 800c30a: 480b         	ldr	r0, [pc, #0x2c]         @ 0x800c338 <z_cstart+0xd0>
 800c30c: f7ff fde4    	bl	0x800bed8 <z_dummy_thread_init> @ imm = #-0x438
; 	z_device_state_init();
 800c310: f7ff fc50    	bl	0x800bbb4 <z_device_state_init> @ imm = #-0x760
; 	soc_early_init_hook();
 800c314: f7f5 fa64    	bl	0x80017e0 <soc_early_init_hook> @ imm = #-0xab38
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
 800c318: 2001         	movs	r0, #0x1
 800c31a: f7ff fe7b    	bl	0x800c014 <z_sys_init_run_level> @ imm = #-0x30a
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 800c31e: 2002         	movs	r0, #0x2
 800c320: f7ff fe78    	bl	0x800c014 <z_sys_init_run_level> @ imm = #-0x310
; 	switch_to_main_thread(prepare_multithreading());
 800c324: f7ff ff5e    	bl	0x800c1e4 <prepare_multithreading> @ imm = #-0x144
 800c328: 4603         	mov	r3, r0
 800c32a: 4618         	mov	r0, r3
 800c32c: f7ff ff8e    	bl	0x800c24c <switch_to_main_thread> @ imm = #-0xe4

0800c330 <$d>:
 800c330: 88 2e 00 20  	.word	0x20002e88
 800c334: 00 ed 00 e0  	.word	0xe000ed00
 800c338: 10 09 00 20  	.word	0x20000910

0800c33c <z_impl_k_msgq_put>:
; {
 800c33c: b580         	push	{r7, lr}
 800c33e: b09c         	sub	sp, #0x70
 800c340: af02         	add	r7, sp, #0x8
 800c342: 60f8         	str	r0, [r7, #0xc]
 800c344: 60b9         	str	r1, [r7, #0x8]
 800c346: e9c7 2300    	strd	r2, r3, [r7]
; 	key = k_spin_lock(&msgq->lock);
 800c34a: 68fb         	ldr	r3, [r7, #0xc]
 800c34c: 3308         	adds	r3, #0x8
 800c34e: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c350: f3ef 8311    	mrs	r3, basepri
 800c354: 65bb         	str	r3, [r7, #0x58]
;   return(result);
 800c356: 6dbb         	ldr	r3, [r7, #0x58]
; 	key = __get_BASEPRI();
 800c358: 657b         	str	r3, [r7, #0x54]
 800c35a: 2310         	movs	r3, #0x10
 800c35c: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c35e: 6d3b         	ldr	r3, [r7, #0x50]
 800c360: f383 8812    	msr	basepri_max, r3
; }
 800c364: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c366: f3bf 8f6f    	isb	sy
; }
 800c36a: bf00         	nop
; 	return key;
 800c36c: 6d7b         	ldr	r3, [r7, #0x54]
; 	k.key = arch_irq_lock();
 800c36e: 613b         	str	r3, [r7, #0x10]
 800c370: 6dfb         	ldr	r3, [r7, #0x5c]
 800c372: 64fb         	str	r3, [r7, #0x4c]
; }
 800c374: bf00         	nop
 800c376: 6dfb         	ldr	r3, [r7, #0x5c]
 800c378: 64bb         	str	r3, [r7, #0x48]
; }
 800c37a: bf00         	nop
; 	return k;
 800c37c: 693b         	ldr	r3, [r7, #0x10]
 800c37e: 61bb         	str	r3, [r7, #0x18]
; 	if (msgq->used_msgs < msgq->max_msgs) {
 800c380: 68fb         	ldr	r3, [r7, #0xc]
 800c382: 6a1a         	ldr	r2, [r3, #0x20]
 800c384: 68fb         	ldr	r3, [r7, #0xc]
 800c386: 68db         	ldr	r3, [r3, #0xc]
 800c388: 429a         	cmp	r2, r3
 800c38a: d267         	bhs	0x800c45c <z_impl_k_msgq_put+0x120> @ imm = #0xce
; 		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 800c38c: 68fb         	ldr	r3, [r7, #0xc]
 800c38e: 647b         	str	r3, [r7, #0x44]
; 	struct k_thread *thread = NULL;
 800c390: 2300         	movs	r3, #0x0
 800c392: 643b         	str	r3, [r7, #0x40]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800c394: 6c7b         	ldr	r3, [r7, #0x44]
 800c396: 63fb         	str	r3, [r7, #0x3c]
; 	struct k_thread *thread = NULL;
 800c398: 2300         	movs	r3, #0x0
 800c39a: 63bb         	str	r3, [r7, #0x38]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800c39c: 6bf8         	ldr	r0, [r7, #0x3c]
 800c39e: f00c fbc6    	bl	0x8018b2e <sys_dlist_peek_head> @ imm = #0xc78c
 800c3a2: 6378         	str	r0, [r7, #0x34]
; 	if (n != NULL) {
 800c3a4: 6b7b         	ldr	r3, [r7, #0x34]
 800c3a6: 2b00         	cmp	r3, #0x0
 800c3a8: d001         	beq	0x800c3ae <z_impl_k_msgq_put+0x72> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800c3aa: 6b7b         	ldr	r3, [r7, #0x34]
 800c3ac: 63bb         	str	r3, [r7, #0x38]
; 	return thread;
 800c3ae: 6bbb         	ldr	r3, [r7, #0x38]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800c3b0: 643b         	str	r3, [r7, #0x40]
; 		if (unlikely(thread != NULL)) {
 800c3b2: 6c3b         	ldr	r3, [r7, #0x40]
 800c3b4: 2b00         	cmp	r3, #0x0
 800c3b6: bf14         	ite	ne
 800c3b8: 2301         	movne	r3, #0x1
 800c3ba: 2300         	moveq	r3, #0x0
 800c3bc: b2db         	uxtb	r3, r3
 800c3be: 2b00         	cmp	r3, #0x0
 800c3c0: d005         	beq	0x800c3ce <z_impl_k_msgq_put+0x92> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 800c3c2: 6c38         	ldr	r0, [r7, #0x40]
 800c3c4: f00c fbfa    	bl	0x8018bbc <unpend_thread_no_timeout> @ imm = #0xc7f4
; 			(void)z_abort_thread_timeout(thread);
 800c3c8: 6c38         	ldr	r0, [r7, #0x40]
 800c3ca: f00c fbd9    	bl	0x8018b80 <z_abort_thread_timeout> @ imm = #0xc7b2
; 	return thread;
 800c3ce: 6c3b         	ldr	r3, [r7, #0x40]
; 		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 800c3d0: 663b         	str	r3, [r7, #0x60]
; 		if (unlikely(pending_thread != NULL)) {
 800c3d2: 6e3b         	ldr	r3, [r7, #0x60]
 800c3d4: 2b00         	cmp	r3, #0x0
 800c3d6: bf14         	ite	ne
 800c3d8: 2301         	movne	r3, #0x1
 800c3da: 2300         	moveq	r3, #0x0
 800c3dc: b2db         	uxtb	r3, r3
 800c3de: 2b00         	cmp	r3, #0x0
 800c3e0: d01b         	beq	0x800c41a <z_impl_k_msgq_put+0xde> @ imm = #0x36
; 			(void)memcpy(pending_thread->base.swap_data, data,
 800c3e2: 6e3b         	ldr	r3, [r7, #0x60]
 800c3e4: 6958         	ldr	r0, [r3, #0x14]
 800c3e6: 68fb         	ldr	r3, [r7, #0xc]
 800c3e8: 689b         	ldr	r3, [r3, #0x8]
 800c3ea: 461a         	mov	r2, r3
 800c3ec: 68b9         	ldr	r1, [r7, #0x8]
 800c3ee: f00e fa11    	bl	0x801a814 <memcpy>      @ imm = #0xe422
 800c3f2: 6e3b         	ldr	r3, [r7, #0x60]
 800c3f4: 633b         	str	r3, [r7, #0x30]
 800c3f6: 2300         	movs	r3, #0x0
 800c3f8: 62fb         	str	r3, [r7, #0x2c]
; 	thread->arch.swap_return_value = value;
 800c3fa: 6b3b         	ldr	r3, [r7, #0x30]
 800c3fc: 6afa         	ldr	r2, [r7, #0x2c]
 800c3fe: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800c402: bf00         	nop
; 			z_ready_thread(pending_thread);
 800c404: 6e38         	ldr	r0, [r7, #0x60]
 800c406: f001 fd01    	bl	0x800de0c <z_ready_thread> @ imm = #0x1a02
; 			z_reschedule(&msgq->lock, key);
 800c40a: 68fb         	ldr	r3, [r7, #0xc]
 800c40c: 3308         	adds	r3, #0x8
 800c40e: 69b9         	ldr	r1, [r7, #0x18]
 800c410: 4618         	mov	r0, r3
 800c412: f00d ff34    	bl	0x801a27e <z_reschedule> @ imm = #0xde68
; 			return 0;
 800c416: 2300         	movs	r3, #0x0
 800c418: e056         	b	0x800c4c8 <z_impl_k_msgq_put+0x18c> @ imm = #0xac
; 			(void)memcpy(msgq->write_ptr, (char *)data, msgq->msg_size);
 800c41a: 68fb         	ldr	r3, [r7, #0xc]
 800c41c: 69d8         	ldr	r0, [r3, #0x1c]
 800c41e: 68fb         	ldr	r3, [r7, #0xc]
 800c420: 689b         	ldr	r3, [r3, #0x8]
 800c422: 461a         	mov	r2, r3
 800c424: 68b9         	ldr	r1, [r7, #0x8]
 800c426: f00e f9f5    	bl	0x801a814 <memcpy>      @ imm = #0xe3ea
; 			msgq->write_ptr += msgq->msg_size;
 800c42a: 68fb         	ldr	r3, [r7, #0xc]
 800c42c: 69da         	ldr	r2, [r3, #0x1c]
 800c42e: 68fb         	ldr	r3, [r7, #0xc]
 800c430: 689b         	ldr	r3, [r3, #0x8]
 800c432: 441a         	add	r2, r3
 800c434: 68fb         	ldr	r3, [r7, #0xc]
 800c436: 61da         	str	r2, [r3, #0x1c]
; 			if (msgq->write_ptr == msgq->buffer_end) {
 800c438: 68fb         	ldr	r3, [r7, #0xc]
 800c43a: 69da         	ldr	r2, [r3, #0x1c]
 800c43c: 68fb         	ldr	r3, [r7, #0xc]
 800c43e: 695b         	ldr	r3, [r3, #0x14]
 800c440: 429a         	cmp	r2, r3
 800c442: d103         	bne	0x800c44c <z_impl_k_msgq_put+0x110> @ imm = #0x6
; 				msgq->write_ptr = msgq->buffer_start;
 800c444: 68fb         	ldr	r3, [r7, #0xc]
 800c446: 691a         	ldr	r2, [r3, #0x10]
 800c448: 68fb         	ldr	r3, [r7, #0xc]
 800c44a: 61da         	str	r2, [r3, #0x1c]
; 			msgq->used_msgs++;
 800c44c: 68fb         	ldr	r3, [r7, #0xc]
 800c44e: 6a1b         	ldr	r3, [r3, #0x20]
 800c450: 1c5a         	adds	r2, r3, #0x1
 800c452: 68fb         	ldr	r3, [r7, #0xc]
 800c454: 621a         	str	r2, [r3, #0x20]
; 		result = 0;
 800c456: 2300         	movs	r3, #0x0
 800c458: 667b         	str	r3, [r7, #0x64]
 800c45a: e022         	b	0x800c4a2 <z_impl_k_msgq_put+0x166> @ imm = #0x44
; 	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 800c45c: e9d7 2300    	ldrd	r2, r3, [r7]
 800c460: f04f 0000    	mov.w	r0, #0x0
 800c464: f04f 0100    	mov.w	r1, #0x0
 800c468: 428b         	cmp	r3, r1
 800c46a: bf08         	it	eq
 800c46c: 4282         	cmpeq	r2, r0
 800c46e: d103         	bne	0x800c478 <z_impl_k_msgq_put+0x13c> @ imm = #0x6
; 		result = -ENOMSG;
 800c470: f06f 0322    	mvn	r3, #0x22
 800c474: 667b         	str	r3, [r7, #0x64]
 800c476: e014         	b	0x800c4a2 <z_impl_k_msgq_put+0x166> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800c478: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800c4d0 <z_impl_k_msgq_put+0x194>
 800c47a: 689b         	ldr	r3, [r3, #0x8]
 800c47c: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800c47e: 6abb         	ldr	r3, [r7, #0x28]
; 		arch_current_thread()->base.swap_data = (void *) data;
 800c480: 68ba         	ldr	r2, [r7, #0x8]
 800c482: 615a         	str	r2, [r3, #0x14]
; 		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
 800c484: 68fb         	ldr	r3, [r7, #0xc]
 800c486: f103 0008    	add.w	r0, r3, #0x8
 800c48a: 68f9         	ldr	r1, [r7, #0xc]
 800c48c: e9d7 2300    	ldrd	r2, r3, [r7]
 800c490: e9cd 2300    	strd	r2, r3, [sp]
 800c494: 460a         	mov	r2, r1
 800c496: 69b9         	ldr	r1, [r7, #0x18]
 800c498: f002 f8ba    	bl	0x800e610 <z_pend_curr> @ imm = #0x2174
 800c49c: 6678         	str	r0, [r7, #0x64]
; 		return result;
 800c49e: 6e7b         	ldr	r3, [r7, #0x64]
 800c4a0: e012         	b	0x800c4c8 <z_impl_k_msgq_put+0x18c> @ imm = #0x24
; 	k_spin_unlock(&msgq->lock, key);
 800c4a2: 68fb         	ldr	r3, [r7, #0xc]
 800c4a4: 3308         	adds	r3, #0x8
 800c4a6: 627b         	str	r3, [r7, #0x24]
 800c4a8: 69bb         	ldr	r3, [r7, #0x18]
 800c4aa: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 800c4ac: 697b         	ldr	r3, [r7, #0x14]
 800c4ae: 623b         	str	r3, [r7, #0x20]
 800c4b0: 6a3b         	ldr	r3, [r7, #0x20]
 800c4b2: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c4b4: 69fb         	ldr	r3, [r7, #0x1c]
 800c4b6: f383 8811    	msr	basepri, r3
; }
 800c4ba: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c4bc: f3bf 8f6f    	isb	sy
; }
 800c4c0: bf00         	nop
; }
 800c4c2: bf00         	nop
; }
 800c4c4: bf00         	nop
; 	return result;
 800c4c6: 6e7b         	ldr	r3, [r7, #0x64]
; }
 800c4c8: 4618         	mov	r0, r3
 800c4ca: 3768         	adds	r7, #0x68
 800c4cc: 46bd         	mov	sp, r7
 800c4ce: bd80         	pop	{r7, pc}

0800c4d0 <$d>:
 800c4d0: 30 07 00 20  	.word	0x20000730

0800c4d4 <z_impl_k_msgq_get>:
; {
 800c4d4: b580         	push	{r7, lr}
 800c4d6: b09c         	sub	sp, #0x70
 800c4d8: af02         	add	r7, sp, #0x8
 800c4da: 60f8         	str	r0, [r7, #0xc]
 800c4dc: 60b9         	str	r1, [r7, #0x8]
 800c4de: e9c7 2300    	strd	r2, r3, [r7]
; 	key = k_spin_lock(&msgq->lock);
 800c4e2: 68fb         	ldr	r3, [r7, #0xc]
 800c4e4: 3308         	adds	r3, #0x8
 800c4e6: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c4e8: f3ef 8311    	mrs	r3, basepri
 800c4ec: 65bb         	str	r3, [r7, #0x58]
;   return(result);
 800c4ee: 6dbb         	ldr	r3, [r7, #0x58]
; 	key = __get_BASEPRI();
 800c4f0: 657b         	str	r3, [r7, #0x54]
 800c4f2: 2310         	movs	r3, #0x10
 800c4f4: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c4f6: 6d3b         	ldr	r3, [r7, #0x50]
 800c4f8: f383 8812    	msr	basepri_max, r3
; }
 800c4fc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c4fe: f3bf 8f6f    	isb	sy
; }
 800c502: bf00         	nop
; 	return key;
 800c504: 6d7b         	ldr	r3, [r7, #0x54]
; 	k.key = arch_irq_lock();
 800c506: 613b         	str	r3, [r7, #0x10]
 800c508: 6dfb         	ldr	r3, [r7, #0x5c]
 800c50a: 64fb         	str	r3, [r7, #0x4c]
; }
 800c50c: bf00         	nop
 800c50e: 6dfb         	ldr	r3, [r7, #0x5c]
 800c510: 64bb         	str	r3, [r7, #0x48]
; }
 800c512: bf00         	nop
; 	return k;
 800c514: 693b         	ldr	r3, [r7, #0x10]
 800c516: 61bb         	str	r3, [r7, #0x18]
; 	if (msgq->used_msgs > 0U) {
 800c518: 68fb         	ldr	r3, [r7, #0xc]
 800c51a: 6a1b         	ldr	r3, [r3, #0x20]
 800c51c: 2b00         	cmp	r3, #0x0
 800c51e: d07e         	beq	0x800c61e <z_impl_k_msgq_get+0x14a> @ imm = #0xfc
; 		(void)memcpy((char *)data, msgq->read_ptr, msgq->msg_size);
 800c520: 68fb         	ldr	r3, [r7, #0xc]
 800c522: 6999         	ldr	r1, [r3, #0x18]
 800c524: 68fb         	ldr	r3, [r7, #0xc]
 800c526: 689b         	ldr	r3, [r3, #0x8]
 800c528: 461a         	mov	r2, r3
 800c52a: 68b8         	ldr	r0, [r7, #0x8]
 800c52c: f00e f972    	bl	0x801a814 <memcpy>      @ imm = #0xe2e4
; 		msgq->read_ptr += msgq->msg_size;
 800c530: 68fb         	ldr	r3, [r7, #0xc]
 800c532: 699a         	ldr	r2, [r3, #0x18]
 800c534: 68fb         	ldr	r3, [r7, #0xc]
 800c536: 689b         	ldr	r3, [r3, #0x8]
 800c538: 441a         	add	r2, r3
 800c53a: 68fb         	ldr	r3, [r7, #0xc]
 800c53c: 619a         	str	r2, [r3, #0x18]
; 		if (msgq->read_ptr == msgq->buffer_end) {
 800c53e: 68fb         	ldr	r3, [r7, #0xc]
 800c540: 699a         	ldr	r2, [r3, #0x18]
 800c542: 68fb         	ldr	r3, [r7, #0xc]
 800c544: 695b         	ldr	r3, [r3, #0x14]
 800c546: 429a         	cmp	r2, r3
 800c548: d103         	bne	0x800c552 <z_impl_k_msgq_get+0x7e> @ imm = #0x6
; 			msgq->read_ptr = msgq->buffer_start;
 800c54a: 68fb         	ldr	r3, [r7, #0xc]
 800c54c: 691a         	ldr	r2, [r3, #0x10]
 800c54e: 68fb         	ldr	r3, [r7, #0xc]
 800c550: 619a         	str	r2, [r3, #0x18]
; 		msgq->used_msgs--;
 800c552: 68fb         	ldr	r3, [r7, #0xc]
 800c554: 6a1b         	ldr	r3, [r3, #0x20]
 800c556: 1e5a         	subs	r2, r3, #0x1
 800c558: 68fb         	ldr	r3, [r7, #0xc]
 800c55a: 621a         	str	r2, [r3, #0x20]
; 		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 800c55c: 68fb         	ldr	r3, [r7, #0xc]
 800c55e: 647b         	str	r3, [r7, #0x44]
; 	struct k_thread *thread = NULL;
 800c560: 2300         	movs	r3, #0x0
 800c562: 643b         	str	r3, [r7, #0x40]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800c564: 6c7b         	ldr	r3, [r7, #0x44]
 800c566: 63fb         	str	r3, [r7, #0x3c]
; 	struct k_thread *thread = NULL;
 800c568: 2300         	movs	r3, #0x0
 800c56a: 63bb         	str	r3, [r7, #0x38]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800c56c: 6bf8         	ldr	r0, [r7, #0x3c]
 800c56e: f00c fade    	bl	0x8018b2e <sys_dlist_peek_head> @ imm = #0xc5bc
 800c572: 6378         	str	r0, [r7, #0x34]
; 	if (n != NULL) {
 800c574: 6b7b         	ldr	r3, [r7, #0x34]
 800c576: 2b00         	cmp	r3, #0x0
 800c578: d001         	beq	0x800c57e <z_impl_k_msgq_get+0xaa> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800c57a: 6b7b         	ldr	r3, [r7, #0x34]
 800c57c: 63bb         	str	r3, [r7, #0x38]
; 	return thread;
 800c57e: 6bbb         	ldr	r3, [r7, #0x38]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800c580: 643b         	str	r3, [r7, #0x40]
; 		if (unlikely(thread != NULL)) {
 800c582: 6c3b         	ldr	r3, [r7, #0x40]
 800c584: 2b00         	cmp	r3, #0x0
 800c586: bf14         	ite	ne
 800c588: 2301         	movne	r3, #0x1
 800c58a: 2300         	moveq	r3, #0x0
 800c58c: b2db         	uxtb	r3, r3
 800c58e: 2b00         	cmp	r3, #0x0
 800c590: d005         	beq	0x800c59e <z_impl_k_msgq_get+0xca> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 800c592: 6c38         	ldr	r0, [r7, #0x40]
 800c594: f00c fb12    	bl	0x8018bbc <unpend_thread_no_timeout> @ imm = #0xc624
; 			(void)z_abort_thread_timeout(thread);
 800c598: 6c38         	ldr	r0, [r7, #0x40]
 800c59a: f00c faf1    	bl	0x8018b80 <z_abort_thread_timeout> @ imm = #0xc5e2
; 	return thread;
 800c59e: 6c3b         	ldr	r3, [r7, #0x40]
; 		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 800c5a0: 663b         	str	r3, [r7, #0x60]
; 		if (unlikely(pending_thread != NULL)) {
 800c5a2: 6e3b         	ldr	r3, [r7, #0x60]
 800c5a4: 2b00         	cmp	r3, #0x0
 800c5a6: bf14         	ite	ne
 800c5a8: 2301         	movne	r3, #0x1
 800c5aa: 2300         	moveq	r3, #0x0
 800c5ac: b2db         	uxtb	r3, r3
 800c5ae: 2b00         	cmp	r3, #0x0
 800c5b0: d032         	beq	0x800c618 <z_impl_k_msgq_get+0x144> @ imm = #0x64
; 			(void)memcpy(msgq->write_ptr, (char *)pending_thread->base.swap_data,
 800c5b2: 68fb         	ldr	r3, [r7, #0xc]
 800c5b4: 69d8         	ldr	r0, [r3, #0x1c]
 800c5b6: 6e3b         	ldr	r3, [r7, #0x60]
 800c5b8: 6959         	ldr	r1, [r3, #0x14]
 800c5ba: 68fb         	ldr	r3, [r7, #0xc]
 800c5bc: 689b         	ldr	r3, [r3, #0x8]
 800c5be: 461a         	mov	r2, r3
 800c5c0: f00e f928    	bl	0x801a814 <memcpy>      @ imm = #0xe250
; 			msgq->write_ptr += msgq->msg_size;
 800c5c4: 68fb         	ldr	r3, [r7, #0xc]
 800c5c6: 69da         	ldr	r2, [r3, #0x1c]
 800c5c8: 68fb         	ldr	r3, [r7, #0xc]
 800c5ca: 689b         	ldr	r3, [r3, #0x8]
 800c5cc: 441a         	add	r2, r3
 800c5ce: 68fb         	ldr	r3, [r7, #0xc]
 800c5d0: 61da         	str	r2, [r3, #0x1c]
; 			if (msgq->write_ptr == msgq->buffer_end) {
 800c5d2: 68fb         	ldr	r3, [r7, #0xc]
 800c5d4: 69da         	ldr	r2, [r3, #0x1c]
 800c5d6: 68fb         	ldr	r3, [r7, #0xc]
 800c5d8: 695b         	ldr	r3, [r3, #0x14]
 800c5da: 429a         	cmp	r2, r3
 800c5dc: d103         	bne	0x800c5e6 <z_impl_k_msgq_get+0x112> @ imm = #0x6
; 				msgq->write_ptr = msgq->buffer_start;
 800c5de: 68fb         	ldr	r3, [r7, #0xc]
 800c5e0: 691a         	ldr	r2, [r3, #0x10]
 800c5e2: 68fb         	ldr	r3, [r7, #0xc]
 800c5e4: 61da         	str	r2, [r3, #0x1c]
; 			msgq->used_msgs++;
 800c5e6: 68fb         	ldr	r3, [r7, #0xc]
 800c5e8: 6a1b         	ldr	r3, [r3, #0x20]
 800c5ea: 1c5a         	adds	r2, r3, #0x1
 800c5ec: 68fb         	ldr	r3, [r7, #0xc]
 800c5ee: 621a         	str	r2, [r3, #0x20]
 800c5f0: 6e3b         	ldr	r3, [r7, #0x60]
 800c5f2: 633b         	str	r3, [r7, #0x30]
 800c5f4: 2300         	movs	r3, #0x0
 800c5f6: 62fb         	str	r3, [r7, #0x2c]
; 	thread->arch.swap_return_value = value;
 800c5f8: 6b3b         	ldr	r3, [r7, #0x30]
 800c5fa: 6afa         	ldr	r2, [r7, #0x2c]
 800c5fc: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800c600: bf00         	nop
; 			z_ready_thread(pending_thread);
 800c602: 6e38         	ldr	r0, [r7, #0x60]
 800c604: f001 fc02    	bl	0x800de0c <z_ready_thread> @ imm = #0x1804
; 			z_reschedule(&msgq->lock, key);
 800c608: 68fb         	ldr	r3, [r7, #0xc]
 800c60a: 3308         	adds	r3, #0x8
 800c60c: 69b9         	ldr	r1, [r7, #0x18]
 800c60e: 4618         	mov	r0, r3
 800c610: f00d fe35    	bl	0x801a27e <z_reschedule> @ imm = #0xdc6a
; 			return 0;
 800c614: 2300         	movs	r3, #0x0
 800c616: e038         	b	0x800c68a <z_impl_k_msgq_get+0x1b6> @ imm = #0x70
; 		result = 0;
 800c618: 2300         	movs	r3, #0x0
 800c61a: 667b         	str	r3, [r7, #0x64]
 800c61c: e022         	b	0x800c664 <z_impl_k_msgq_get+0x190> @ imm = #0x44
; 	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 800c61e: e9d7 2300    	ldrd	r2, r3, [r7]
 800c622: f04f 0000    	mov.w	r0, #0x0
 800c626: f04f 0100    	mov.w	r1, #0x0
 800c62a: 428b         	cmp	r3, r1
 800c62c: bf08         	it	eq
 800c62e: 4282         	cmpeq	r2, r0
 800c630: d103         	bne	0x800c63a <z_impl_k_msgq_get+0x166> @ imm = #0x6
; 		result = -ENOMSG;
 800c632: f06f 0322    	mvn	r3, #0x22
 800c636: 667b         	str	r3, [r7, #0x64]
 800c638: e014         	b	0x800c664 <z_impl_k_msgq_get+0x190> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800c63a: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800c694 <z_impl_k_msgq_get+0x1c0>
 800c63c: 689b         	ldr	r3, [r3, #0x8]
 800c63e: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800c640: 6abb         	ldr	r3, [r7, #0x28]
; 		arch_current_thread()->base.swap_data = data;
 800c642: 68ba         	ldr	r2, [r7, #0x8]
 800c644: 615a         	str	r2, [r3, #0x14]
; 		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
 800c646: 68fb         	ldr	r3, [r7, #0xc]
 800c648: f103 0008    	add.w	r0, r3, #0x8
 800c64c: 68f9         	ldr	r1, [r7, #0xc]
 800c64e: e9d7 2300    	ldrd	r2, r3, [r7]
 800c652: e9cd 2300    	strd	r2, r3, [sp]
 800c656: 460a         	mov	r2, r1
 800c658: 69b9         	ldr	r1, [r7, #0x18]
 800c65a: f001 ffd9    	bl	0x800e610 <z_pend_curr> @ imm = #0x1fb2
 800c65e: 6678         	str	r0, [r7, #0x64]
; 		return result;
 800c660: 6e7b         	ldr	r3, [r7, #0x64]
 800c662: e012         	b	0x800c68a <z_impl_k_msgq_get+0x1b6> @ imm = #0x24
; 	k_spin_unlock(&msgq->lock, key);
 800c664: 68fb         	ldr	r3, [r7, #0xc]
 800c666: 3308         	adds	r3, #0x8
 800c668: 627b         	str	r3, [r7, #0x24]
 800c66a: 69bb         	ldr	r3, [r7, #0x18]
 800c66c: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 800c66e: 697b         	ldr	r3, [r7, #0x14]
 800c670: 623b         	str	r3, [r7, #0x20]
 800c672: 6a3b         	ldr	r3, [r7, #0x20]
 800c674: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c676: 69fb         	ldr	r3, [r7, #0x1c]
 800c678: f383 8811    	msr	basepri, r3
; }
 800c67c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c67e: f3bf 8f6f    	isb	sy
; }
 800c682: bf00         	nop
; }
 800c684: bf00         	nop
; }
 800c686: bf00         	nop
; 	return result;
 800c688: 6e7b         	ldr	r3, [r7, #0x64]
; }
 800c68a: 4618         	mov	r0, r3
 800c68c: 3768         	adds	r7, #0x68
 800c68e: 46bd         	mov	sp, r7
 800c690: bd80         	pop	{r7, pc}
 800c692: bf00         	nop

0800c694 <$d>:
 800c694: 30 07 00 20  	.word	0x20000730

0800c698 <adjust_owner_prio>:
; {
 800c698: b5b0         	push	{r4, r5, r7, lr}
 800c69a: b08c         	sub	sp, #0x30
 800c69c: af08         	add	r7, sp, #0x20
 800c69e: 6078         	str	r0, [r7, #0x4]
 800c6a0: 6039         	str	r1, [r7]
; 	if (mutex->owner->base.prio != new_prio) {
 800c6a2: 687b         	ldr	r3, [r7, #0x4]
 800c6a4: 689b         	ldr	r3, [r3, #0x8]
 800c6a6: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800c6aa: 461a         	mov	r2, r3
 800c6ac: 683b         	ldr	r3, [r7]
 800c6ae: 4293         	cmp	r3, r2
 800c6b0: d03a         	beq	0x800c728 <adjust_owner_prio+0x90> @ imm = #0x74
; 		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
 800c6b2: 2303         	movs	r3, #0x3
 800c6b4: 2b03         	cmp	r3, #0x3
 800c6b6: d92f         	bls	0x800c718 <adjust_owner_prio+0x80> @ imm = #0x5e
 800c6b8: 2301         	movs	r3, #0x1
 800c6ba: 72fb         	strb	r3, [r7, #0xb]
 800c6bc: 7afb         	ldrb	r3, [r7, #0xb]
 800c6be: f083 0301    	eor	r3, r3, #0x1
 800c6c2: b2db         	uxtb	r3, r3
 800c6c4: 2b00         	cmp	r3, #0x0
 800c6c6: d127         	bne	0x800c718 <adjust_owner_prio+0x80> @ imm = #0x4e
 800c6c8: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800c734 <adjust_owner_prio+0x9c>
 800c6ca: 681d         	ldr	r5, [r3]
 800c6cc: 687b         	ldr	r3, [r7, #0x4]
 800c6ce: 689c         	ldr	r4, [r3, #0x8]
 800c6d0: 687b         	ldr	r3, [r7, #0x4]
 800c6d2: 689b         	ldr	r3, [r3, #0x8]
 800c6d4: 4618         	mov	r0, r3
 800c6d6: f00c fbd6    	bl	0x8018e86 <z_is_thread_ready> @ imm = #0xc7ac
 800c6da: 4603         	mov	r3, r0
 800c6dc: 2b00         	cmp	r3, #0x0
 800c6de: d001         	beq	0x800c6e4 <adjust_owner_prio+0x4c> @ imm = #0x2
 800c6e0: 2379         	movs	r3, #0x79
 800c6e2: e000         	b	0x800c6e6 <adjust_owner_prio+0x4e> @ imm = #0x0
 800c6e4: 236e         	movs	r3, #0x6e
 800c6e6: 687a         	ldr	r2, [r7, #0x4]
 800c6e8: 6892         	ldr	r2, [r2, #0x8]
 800c6ea: f992 200e    	ldrsb.w	r2, [r2, #0xe]
 800c6ee: 9207         	str	r2, [sp, #0x1c]
 800c6f0: 683a         	ldr	r2, [r7]
 800c6f2: 9206         	str	r2, [sp, #0x18]
 800c6f4: 9305         	str	r3, [sp, #0x14]
 800c6f6: 9404         	str	r4, [sp, #0x10]
 800c6f8: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800c738 <adjust_owner_prio+0xa0>
 800c6fa: 9303         	str	r3, [sp, #0xc]
 800c6fc: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800c73c <adjust_owner_prio+0xa4>
 800c6fe: 9302         	str	r3, [sp, #0x8]
 800c700: 2308         	movs	r3, #0x8
 800c702: 9301         	str	r3, [sp, #0x4]
 800c704: 2300         	movs	r3, #0x0
 800c706: 9300         	str	r3, [sp]
 800c708: 2300         	movs	r3, #0x0
 800c70a: 2204         	movs	r2, #0x4
 800c70c: 4629         	mov	r1, r5
 800c70e: 2000         	movs	r0, #0x0
 800c710: f00c fc5d    	bl	0x8018fce <z_log_msg_runtime_create> @ imm = #0xc8ba
 800c714: 2300         	movs	r3, #0x0
 800c716: 60fb         	str	r3, [r7, #0xc]
; 		return z_thread_prio_set(mutex->owner, new_prio);
 800c718: 687b         	ldr	r3, [r7, #0x4]
 800c71a: 689b         	ldr	r3, [r3, #0x8]
 800c71c: 6839         	ldr	r1, [r7]
 800c71e: 4618         	mov	r0, r3
 800c720: f001 ffbc    	bl	0x800e69c <z_thread_prio_set> @ imm = #0x1f78
 800c724: 4603         	mov	r3, r0
 800c726: e000         	b	0x800c72a <adjust_owner_prio+0x92> @ imm = #0x0
; 	return false;
 800c728: 2300         	movs	r3, #0x0
; }
 800c72a: 4618         	mov	r0, r3
 800c72c: 3710         	adds	r7, #0x10
 800c72e: 46bd         	mov	sp, r7
 800c730: bdb0         	pop	{r4, r5, r7, pc}
 800c732: bf00         	nop

0800c734 <$d>:
 800c734: 54 05 00 20  	.word	0x20000554
 800c738: 94 d8 01 08  	.word	0x0801d894
 800c73c: e8 ca 01 08  	.word	0x0801cae8

0800c740 <z_impl_k_mutex_lock>:
; {
 800c740: b580         	push	{r7, lr}
 800c742: b0be         	sub	sp, #0xf8
 800c744: af08         	add	r7, sp, #0x20
 800c746: 60f8         	str	r0, [r7, #0xc]
 800c748: e9c7 2300    	strd	r2, r3, [r7]
; 	bool resched = false;
 800c74c: 2300         	movs	r3, #0x0
 800c74e: f887 30d7    	strb.w	r3, [r7, #0xd7]
 800c752: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x800c9ec <z_impl_k_mutex_lock+0x2ac>
 800c754: f8c7 3094    	str.w	r3, [r7, #0x94]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c758: f3ef 8311    	mrs	r3, basepri
 800c75c: f8c7 3090    	str.w	r3, [r7, #0x90]
;   return(result);
 800c760: f8d7 3090    	ldr.w	r3, [r7, #0x90]
; 	key = __get_BASEPRI();
 800c764: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800c768: 2310         	movs	r3, #0x10
 800c76a: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c76e: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800c772: f383 8812    	msr	basepri_max, r3
; }
 800c776: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c778: f3bf 8f6f    	isb	sy
; }
 800c77c: bf00         	nop
; 	return key;
 800c77e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	k.key = arch_irq_lock();
 800c782: 617b         	str	r3, [r7, #0x14]
 800c784: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800c788: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 800c78c: bf00         	nop
 800c78e: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800c792: f8c7 3080    	str.w	r3, [r7, #0x80]
; }
 800c796: bf00         	nop
; 	return k;
 800c798: 697b         	ldr	r3, [r7, #0x14]
 800c79a: 627b         	str	r3, [r7, #0x24]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == arch_current_thread()))) {
 800c79c: 68fb         	ldr	r3, [r7, #0xc]
 800c79e: 68db         	ldr	r3, [r3, #0xc]
 800c7a0: 2b00         	cmp	r3, #0x0
 800c7a2: bf0c         	ite	eq
 800c7a4: 2301         	moveq	r3, #0x1
 800c7a6: 2300         	movne	r3, #0x0
 800c7a8: b2db         	uxtb	r3, r3
 800c7aa: 2b00         	cmp	r3, #0x0
 800c7ac: d10c         	bne	0x800c7c8 <z_impl_k_mutex_lock+0x88> @ imm = #0x18
 800c7ae: 68fb         	ldr	r3, [r7, #0xc]
 800c7b0: 689a         	ldr	r2, [r3, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800c7b2: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x800c9f0 <z_impl_k_mutex_lock+0x2b0>
 800c7b4: 689b         	ldr	r3, [r3, #0x8]
 800c7b6: 67fb         	str	r3, [r7, #0x7c]
; 	return ret;
 800c7b8: 6ffb         	ldr	r3, [r7, #0x7c]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == arch_current_thread()))) {
 800c7ba: 429a         	cmp	r2, r3
 800c7bc: bf0c         	ite	eq
 800c7be: 2301         	moveq	r3, #0x1
 800c7c0: 2300         	movne	r3, #0x0
 800c7c2: b2db         	uxtb	r3, r3
 800c7c4: 2b00         	cmp	r3, #0x0
 800c7c6: d001         	beq	0x800c7cc <z_impl_k_mutex_lock+0x8c> @ imm = #0x2
 800c7c8: 2301         	movs	r3, #0x1
 800c7ca: e000         	b	0x800c7ce <z_impl_k_mutex_lock+0x8e> @ imm = #0x0
 800c7cc: 2300         	movs	r3, #0x0
 800c7ce: 2b00         	cmp	r3, #0x0
 800c7d0: d059         	beq	0x800c886 <z_impl_k_mutex_lock+0x146> @ imm = #0xb2
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 800c7d2: 68fb         	ldr	r3, [r7, #0xc]
 800c7d4: 68db         	ldr	r3, [r3, #0xc]
; 					arch_current_thread()->base.prio :
 800c7d6: 2b00         	cmp	r3, #0x0
 800c7d8: d106         	bne	0x800c7e8 <z_impl_k_mutex_lock+0xa8> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800c7da: 4b85         	ldr	r3, [pc, #0x214]        @ 0x800c9f0 <z_impl_k_mutex_lock+0x2b0>
 800c7dc: 689b         	ldr	r3, [r3, #0x8]
 800c7de: 67bb         	str	r3, [r7, #0x78]
; 	return ret;
 800c7e0: 6fbb         	ldr	r3, [r7, #0x78]
; 					arch_current_thread()->base.prio :
 800c7e2: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800c7e6: e001         	b	0x800c7ec <z_impl_k_mutex_lock+0xac> @ imm = #0x2
 800c7e8: 68fb         	ldr	r3, [r7, #0xc]
 800c7ea: 691b         	ldr	r3, [r3, #0x10]
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 800c7ec: 68fa         	ldr	r2, [r7, #0xc]
 800c7ee: 6113         	str	r3, [r2, #0x10]
; 		mutex->lock_count++;
 800c7f0: 68fb         	ldr	r3, [r7, #0xc]
 800c7f2: 68db         	ldr	r3, [r3, #0xc]
 800c7f4: 1c5a         	adds	r2, r3, #0x1
 800c7f6: 68fb         	ldr	r3, [r7, #0xc]
 800c7f8: 60da         	str	r2, [r3, #0xc]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800c7fa: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x800c9f0 <z_impl_k_mutex_lock+0x2b0>
 800c7fc: 689b         	ldr	r3, [r3, #0x8]
 800c7fe: 677b         	str	r3, [r7, #0x74]
; 	return ret;
 800c800: 6f7a         	ldr	r2, [r7, #0x74]
; 		mutex->owner = arch_current_thread();
 800c802: 68fb         	ldr	r3, [r7, #0xc]
 800c804: 609a         	str	r2, [r3, #0x8]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 800c806: 2303         	movs	r3, #0x3
 800c808: 2b03         	cmp	r3, #0x3
 800c80a: d929         	bls	0x800c860 <z_impl_k_mutex_lock+0x120> @ imm = #0x52
 800c80c: 2301         	movs	r3, #0x1
 800c80e: f887 309f    	strb.w	r3, [r7, #0x9f]
 800c812: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 800c816: f083 0301    	eor	r3, r3, #0x1
 800c81a: b2db         	uxtb	r3, r3
 800c81c: 2b00         	cmp	r3, #0x0
 800c81e: d11f         	bne	0x800c860 <z_impl_k_mutex_lock+0x120> @ imm = #0x3e
 800c820: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800c9f4 <z_impl_k_mutex_lock+0x2b4>
 800c822: 6818         	ldr	r0, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800c824: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x800c9f0 <z_impl_k_mutex_lock+0x2b0>
 800c826: 689b         	ldr	r3, [r3, #0x8]
 800c828: 673b         	str	r3, [r7, #0x70]
; 	return ret;
 800c82a: 6f3b         	ldr	r3, [r7, #0x70]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 800c82c: 68fa         	ldr	r2, [r7, #0xc]
 800c82e: 68d2         	ldr	r2, [r2, #0xc]
 800c830: 68f9         	ldr	r1, [r7, #0xc]
 800c832: 6909         	ldr	r1, [r1, #0x10]
 800c834: 9107         	str	r1, [sp, #0x1c]
 800c836: 9206         	str	r2, [sp, #0x18]
 800c838: 68fa         	ldr	r2, [r7, #0xc]
 800c83a: 9205         	str	r2, [sp, #0x14]
 800c83c: 9304         	str	r3, [sp, #0x10]
 800c83e: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x800c9f8 <z_impl_k_mutex_lock+0x2b8>
 800c840: 9303         	str	r3, [sp, #0xc]
 800c842: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x800c9fc <z_impl_k_mutex_lock+0x2bc>
 800c844: 9302         	str	r3, [sp, #0x8]
 800c846: 2308         	movs	r3, #0x8
 800c848: 9301         	str	r3, [sp, #0x4]
 800c84a: 2300         	movs	r3, #0x0
 800c84c: 9300         	str	r3, [sp]
 800c84e: 2300         	movs	r3, #0x0
 800c850: 2204         	movs	r2, #0x4
 800c852: 4601         	mov	r1, r0
 800c854: 2000         	movs	r0, #0x0
 800c856: f00c fbba    	bl	0x8018fce <z_log_msg_runtime_create> @ imm = #0xc774
 800c85a: 2300         	movs	r3, #0x0
 800c85c: f8c7 3098    	str.w	r3, [r7, #0x98]
 800c860: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800c9ec <z_impl_k_mutex_lock+0x2ac>
 800c862: 66fb         	str	r3, [r7, #0x6c]
 800c864: 6a7b         	ldr	r3, [r7, #0x24]
 800c866: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800c868: 69bb         	ldr	r3, [r7, #0x18]
 800c86a: 66bb         	str	r3, [r7, #0x68]
 800c86c: 6ebb         	ldr	r3, [r7, #0x68]
 800c86e: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c870: 6e7b         	ldr	r3, [r7, #0x64]
 800c872: f383 8811    	msr	basepri, r3
; }
 800c876: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c878: f3bf 8f6f    	isb	sy
; }
 800c87c: bf00         	nop
; }
 800c87e: bf00         	nop
; }
 800c880: bf00         	nop
; 		return 0;
 800c882: 2300         	movs	r3, #0x0
 800c884: e193         	b	0x800cbae <z_impl_k_mutex_lock+0x46e> @ imm = #0x326
; 	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
 800c886: e9d7 2300    	ldrd	r2, r3, [r7]
 800c88a: f04f 0000    	mov.w	r0, #0x0
 800c88e: f04f 0100    	mov.w	r1, #0x0
 800c892: 428b         	cmp	r3, r1
 800c894: bf08         	it	eq
 800c896: 4282         	cmpeq	r2, r0
 800c898: bf0c         	ite	eq
 800c89a: 2301         	moveq	r3, #0x1
 800c89c: 2300         	movne	r3, #0x0
 800c89e: b2db         	uxtb	r3, r3
 800c8a0: 2b00         	cmp	r3, #0x0
 800c8a2: d013         	beq	0x800c8cc <z_impl_k_mutex_lock+0x18c> @ imm = #0x26
 800c8a4: 4b51         	ldr	r3, [pc, #0x144]        @ 0x800c9ec <z_impl_k_mutex_lock+0x2ac>
 800c8a6: 663b         	str	r3, [r7, #0x60]
 800c8a8: 6a7b         	ldr	r3, [r7, #0x24]
 800c8aa: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800c8ac: 693b         	ldr	r3, [r7, #0x10]
 800c8ae: 65fb         	str	r3, [r7, #0x5c]
 800c8b0: 6dfb         	ldr	r3, [r7, #0x5c]
 800c8b2: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c8b4: 6dbb         	ldr	r3, [r7, #0x58]
 800c8b6: f383 8811    	msr	basepri, r3
; }
 800c8ba: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c8bc: f3bf 8f6f    	isb	sy
; }
 800c8c0: bf00         	nop
; }
 800c8c2: bf00         	nop
; }
 800c8c4: bf00         	nop
; 		return -EBUSY;
 800c8c6: f06f 030f    	mvn	r3, #0xf
 800c8ca: e170         	b	0x800cbae <z_impl_k_mutex_lock+0x46e> @ imm = #0x2e0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800c8cc: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800c9f0 <z_impl_k_mutex_lock+0x2b0>
 800c8ce: 689b         	ldr	r3, [r3, #0x8]
 800c8d0: 657b         	str	r3, [r7, #0x54]
; 	return ret;
 800c8d2: 6d7b         	ldr	r3, [r7, #0x54]
; 	new_prio = new_prio_for_inheritance(arch_current_thread()->base.prio,
 800c8d4: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800c8d8: 461a         	mov	r2, r3
; 					    mutex->owner->base.prio);
 800c8da: 68fb         	ldr	r3, [r7, #0xc]
 800c8dc: 689b         	ldr	r3, [r3, #0x8]
 800c8de: f993 300e    	ldrsb.w	r3, [r3, #0xe]
; 	new_prio = new_prio_for_inheritance(arch_current_thread()->base.prio,
 800c8e2: 4619         	mov	r1, r3
 800c8e4: 4610         	mov	r0, r2
 800c8e6: f00c fba6    	bl	0x8019036 <new_prio_for_inheritance> @ imm = #0xc74c
 800c8ea: f8c7 00d0    	str.w	r0, [r7, #0xd0]
; 	LOG_DBG("adjusting prio up on mutex %p", mutex);
 800c8ee: 2303         	movs	r3, #0x3
 800c8f0: 2b03         	cmp	r3, #0x3
 800c8f2: d91d         	bls	0x800c930 <z_impl_k_mutex_lock+0x1f0> @ imm = #0x3a
 800c8f4: 2301         	movs	r3, #0x1
 800c8f6: f887 30cf    	strb.w	r3, [r7, #0xcf]
 800c8fa: f897 30cf    	ldrb.w	r3, [r7, #0xcf]
 800c8fe: f083 0301    	eor	r3, r3, #0x1
 800c902: b2db         	uxtb	r3, r3
 800c904: 2b00         	cmp	r3, #0x0
 800c906: d113         	bne	0x800c930 <z_impl_k_mutex_lock+0x1f0> @ imm = #0x26
 800c908: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x800c9f4 <z_impl_k_mutex_lock+0x2b4>
 800c90a: 6819         	ldr	r1, [r3]
 800c90c: 68fb         	ldr	r3, [r7, #0xc]
 800c90e: 9304         	str	r3, [sp, #0x10]
 800c910: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800c9f8 <z_impl_k_mutex_lock+0x2b8>
 800c912: 9303         	str	r3, [sp, #0xc]
 800c914: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x800ca00 <z_impl_k_mutex_lock+0x2c0>
 800c916: 9302         	str	r3, [sp, #0x8]
 800c918: 2308         	movs	r3, #0x8
 800c91a: 9301         	str	r3, [sp, #0x4]
 800c91c: 2300         	movs	r3, #0x0
 800c91e: 9300         	str	r3, [sp]
 800c920: 2300         	movs	r3, #0x0
 800c922: 2204         	movs	r2, #0x4
 800c924: 2000         	movs	r0, #0x0
 800c926: f00c fb52    	bl	0x8018fce <z_log_msg_runtime_create> @ imm = #0xc6a4
 800c92a: 2300         	movs	r3, #0x0
 800c92c: f8c7 30c8    	str.w	r3, [r7, #0xc8]
; 	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
 800c930: 68fb         	ldr	r3, [r7, #0xc]
 800c932: 689b         	ldr	r3, [r3, #0x8]
 800c934: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800c938: 4619         	mov	r1, r3
 800c93a: f8d7 00d0    	ldr.w	r0, [r7, #0xd0]
 800c93e: f00c fb05    	bl	0x8018f4c <z_is_prio_higher> @ imm = #0xc60a
 800c942: 4603         	mov	r3, r0
 800c944: 2b00         	cmp	r3, #0x0
 800c946: d007         	beq	0x800c958 <z_impl_k_mutex_lock+0x218> @ imm = #0xe
; 		resched = adjust_owner_prio(mutex, new_prio);
 800c948: f8d7 10d0    	ldr.w	r1, [r7, #0xd0]
 800c94c: 68f8         	ldr	r0, [r7, #0xc]
 800c94e: f7ff fea3    	bl	0x800c698 <adjust_owner_prio> @ imm = #-0x2ba
 800c952: 4603         	mov	r3, r0
 800c954: f887 30d7    	strb.w	r3, [r7, #0xd7]
; 	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
 800c958: 68f9         	ldr	r1, [r7, #0xc]
 800c95a: e9d7 2300    	ldrd	r2, r3, [r7]
 800c95e: e9cd 2300    	strd	r2, r3, [sp]
 800c962: 460a         	mov	r2, r1
 800c964: 6a79         	ldr	r1, [r7, #0x24]
 800c966: 4821         	ldr	r0, [pc, #0x84]         @ 0x800c9ec <z_impl_k_mutex_lock+0x2ac>
 800c968: f001 fe52    	bl	0x800e610 <z_pend_curr> @ imm = #0x1ca4
 800c96c: f8c7 00c4    	str.w	r0, [r7, #0xc4]
; 	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);
 800c970: 2303         	movs	r3, #0x3
 800c972: 2b03         	cmp	r3, #0x3
 800c974: d920         	bls	0x800c9b8 <z_impl_k_mutex_lock+0x278> @ imm = #0x40
 800c976: 2301         	movs	r3, #0x1
 800c978: f887 30c3    	strb.w	r3, [r7, #0xc3]
 800c97c: f897 30c3    	ldrb.w	r3, [r7, #0xc3]
 800c980: f083 0301    	eor	r3, r3, #0x1
 800c984: b2db         	uxtb	r3, r3
 800c986: 2b00         	cmp	r3, #0x0
 800c988: d116         	bne	0x800c9b8 <z_impl_k_mutex_lock+0x278> @ imm = #0x2c
 800c98a: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800c9f4 <z_impl_k_mutex_lock+0x2b4>
 800c98c: 6819         	ldr	r1, [r3]
 800c98e: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800c992: 9305         	str	r3, [sp, #0x14]
 800c994: 68fb         	ldr	r3, [r7, #0xc]
 800c996: 9304         	str	r3, [sp, #0x10]
 800c998: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800c9f8 <z_impl_k_mutex_lock+0x2b8>
 800c99a: 9303         	str	r3, [sp, #0xc]
 800c99c: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800ca04 <z_impl_k_mutex_lock+0x2c4>
 800c99e: 9302         	str	r3, [sp, #0x8]
 800c9a0: 2308         	movs	r3, #0x8
 800c9a2: 9301         	str	r3, [sp, #0x4]
 800c9a4: 2300         	movs	r3, #0x0
 800c9a6: 9300         	str	r3, [sp]
 800c9a8: 2300         	movs	r3, #0x0
 800c9aa: 2204         	movs	r2, #0x4
 800c9ac: 2000         	movs	r0, #0x0
 800c9ae: f00c fb0e    	bl	0x8018fce <z_log_msg_runtime_create> @ imm = #0xc61c
 800c9b2: 2300         	movs	r3, #0x0
 800c9b4: f8c7 30bc    	str.w	r3, [r7, #0xbc]
; 	LOG_DBG("%p got mutex %p (y/n): %c", arch_current_thread(), mutex,
 800c9b8: 2303         	movs	r3, #0x3
 800c9ba: 2b03         	cmp	r3, #0x3
 800c9bc: d939         	bls	0x800ca32 <z_impl_k_mutex_lock+0x2f2> @ imm = #0x72
 800c9be: 2301         	movs	r3, #0x1
 800c9c0: f887 30bb    	strb.w	r3, [r7, #0xbb]
 800c9c4: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 800c9c8: f083 0301    	eor	r3, r3, #0x1
 800c9cc: b2db         	uxtb	r3, r3
 800c9ce: 2b00         	cmp	r3, #0x0
 800c9d0: d12f         	bne	0x800ca32 <z_impl_k_mutex_lock+0x2f2> @ imm = #0x5e
 800c9d2: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800c9f4 <z_impl_k_mutex_lock+0x2b4>
 800c9d4: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800c9d6: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800c9f0 <z_impl_k_mutex_lock+0x2b0>
 800c9d8: 689b         	ldr	r3, [r3, #0x8]
 800c9da: 653b         	str	r3, [r7, #0x50]
; 	return ret;
 800c9dc: 6d3b         	ldr	r3, [r7, #0x50]
; 	LOG_DBG("%p got mutex %p (y/n): %c", arch_current_thread(), mutex,
 800c9de: f8d7 20c4    	ldr.w	r2, [r7, #0xc4]
 800c9e2: 2a00         	cmp	r2, #0x0
 800c9e4: d010         	beq	0x800ca08 <z_impl_k_mutex_lock+0x2c8> @ imm = #0x20
 800c9e6: 2279         	movs	r2, #0x79
 800c9e8: e00f         	b	0x800ca0a <z_impl_k_mutex_lock+0x2ca> @ imm = #0x1e
 800c9ea: bf00         	nop

0800c9ec <$d>:
 800c9ec: 24 11 00 20  	.word	0x20001124
 800c9f0: 30 07 00 20  	.word	0x20000730
 800c9f4: 54 05 00 20  	.word	0x20000554
 800c9f8: a8 d8 01 08  	.word	0x0801d8a8
 800c9fc: 20 cb 01 08  	.word	0x0801cb20
 800ca00: 50 cb 01 08  	.word	0x0801cb50
 800ca04: 74 cb 01 08  	.word	0x0801cb74

0800ca08 <$t>:
 800ca08: 226e         	movs	r2, #0x6e
 800ca0a: 9206         	str	r2, [sp, #0x18]
 800ca0c: 68fa         	ldr	r2, [r7, #0xc]
 800ca0e: 9205         	str	r2, [sp, #0x14]
 800ca10: 9304         	str	r3, [sp, #0x10]
 800ca12: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x800cbb8 <z_impl_k_mutex_lock+0x478>
 800ca14: 9303         	str	r3, [sp, #0xc]
 800ca16: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x800cbbc <z_impl_k_mutex_lock+0x47c>
 800ca18: 9302         	str	r3, [sp, #0x8]
 800ca1a: 2308         	movs	r3, #0x8
 800ca1c: 9301         	str	r3, [sp, #0x4]
 800ca1e: 2300         	movs	r3, #0x0
 800ca20: 9300         	str	r3, [sp]
 800ca22: 2300         	movs	r3, #0x0
 800ca24: 2204         	movs	r2, #0x4
 800ca26: 2000         	movs	r0, #0x0
 800ca28: f00c fad1    	bl	0x8018fce <z_log_msg_runtime_create> @ imm = #0xc5a2
 800ca2c: 2300         	movs	r3, #0x0
 800ca2e: f8c7 30b4    	str.w	r3, [r7, #0xb4]
; 	if (got_mutex == 0) {
 800ca32: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800ca36: 2b00         	cmp	r3, #0x0
 800ca38: d101         	bne	0x800ca3e <z_impl_k_mutex_lock+0x2fe> @ imm = #0x2
; 		return 0;
 800ca3a: 2300         	movs	r3, #0x0
 800ca3c: e0b7         	b	0x800cbae <z_impl_k_mutex_lock+0x46e> @ imm = #0x16e
; 	LOG_DBG("%p timeout on mutex %p", arch_current_thread(), mutex);
 800ca3e: 2303         	movs	r3, #0x3
 800ca40: 2b03         	cmp	r3, #0x3
 800ca42: d922         	bls	0x800ca8a <z_impl_k_mutex_lock+0x34a> @ imm = #0x44
 800ca44: 2301         	movs	r3, #0x1
 800ca46: f887 30b3    	strb.w	r3, [r7, #0xb3]
 800ca4a: f897 30b3    	ldrb.w	r3, [r7, #0xb3]
 800ca4e: f083 0301    	eor	r3, r3, #0x1
 800ca52: b2db         	uxtb	r3, r3
 800ca54: 2b00         	cmp	r3, #0x0
 800ca56: d118         	bne	0x800ca8a <z_impl_k_mutex_lock+0x34a> @ imm = #0x30
 800ca58: 4b59         	ldr	r3, [pc, #0x164]        @ 0x800cbc0 <z_impl_k_mutex_lock+0x480>
 800ca5a: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ca5c: 4b59         	ldr	r3, [pc, #0x164]        @ 0x800cbc4 <z_impl_k_mutex_lock+0x484>
 800ca5e: 689b         	ldr	r3, [r3, #0x8]
 800ca60: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 800ca62: 6cfb         	ldr	r3, [r7, #0x4c]
; 	LOG_DBG("%p timeout on mutex %p", arch_current_thread(), mutex);
 800ca64: 68fa         	ldr	r2, [r7, #0xc]
 800ca66: 9205         	str	r2, [sp, #0x14]
 800ca68: 9304         	str	r3, [sp, #0x10]
 800ca6a: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800cbb8 <z_impl_k_mutex_lock+0x478>
 800ca6c: 9303         	str	r3, [sp, #0xc]
 800ca6e: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800cbc8 <z_impl_k_mutex_lock+0x488>
 800ca70: 9302         	str	r3, [sp, #0x8]
 800ca72: 2308         	movs	r3, #0x8
 800ca74: 9301         	str	r3, [sp, #0x4]
 800ca76: 2300         	movs	r3, #0x0
 800ca78: 9300         	str	r3, [sp]
 800ca7a: 2300         	movs	r3, #0x0
 800ca7c: 2204         	movs	r2, #0x4
 800ca7e: 2000         	movs	r0, #0x0
 800ca80: f00c faa5    	bl	0x8018fce <z_log_msg_runtime_create> @ imm = #0xc54a
 800ca84: 2300         	movs	r3, #0x0
 800ca86: f8c7 30ac    	str.w	r3, [r7, #0xac]
 800ca8a: 4b50         	ldr	r3, [pc, #0x140]        @ 0x800cbcc <z_impl_k_mutex_lock+0x48c>
 800ca8c: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ca8e: f3ef 8311    	mrs	r3, basepri
 800ca92: 647b         	str	r3, [r7, #0x44]
;   return(result);
 800ca94: 6c7b         	ldr	r3, [r7, #0x44]
; 	key = __get_BASEPRI();
 800ca96: 643b         	str	r3, [r7, #0x40]
 800ca98: 2310         	movs	r3, #0x10
 800ca9a: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ca9c: 6bfb         	ldr	r3, [r7, #0x3c]
 800ca9e: f383 8812    	msr	basepri_max, r3
; }
 800caa2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800caa4: f3bf 8f6f    	isb	sy
; }
 800caa8: bf00         	nop
; 	return key;
 800caaa: 6c3b         	ldr	r3, [r7, #0x40]
; 	k.key = arch_irq_lock();
 800caac: 61fb         	str	r3, [r7, #0x1c]
 800caae: 6cbb         	ldr	r3, [r7, #0x48]
 800cab0: 63bb         	str	r3, [r7, #0x38]
; }
 800cab2: bf00         	nop
 800cab4: 6cbb         	ldr	r3, [r7, #0x48]
 800cab6: 637b         	str	r3, [r7, #0x34]
; }
 800cab8: bf00         	nop
; 	return k;
 800caba: 69fb         	ldr	r3, [r7, #0x1c]
 800cabc: 627b         	str	r3, [r7, #0x24]
; 	if (likely(mutex->owner != NULL)) {
 800cabe: 68fb         	ldr	r3, [r7, #0xc]
 800cac0: 689b         	ldr	r3, [r3, #0x8]
 800cac2: 2b00         	cmp	r3, #0x0
 800cac4: bf14         	ite	ne
 800cac6: 2301         	movne	r3, #0x1
 800cac8: 2300         	moveq	r3, #0x0
 800caca: b2db         	uxtb	r3, r3
 800cacc: 2b00         	cmp	r3, #0x0
 800cace: d052         	beq	0x800cb76 <z_impl_k_mutex_lock+0x436> @ imm = #0xa4
; 		struct k_thread *waiter = z_waitq_head(&mutex->wait_q);
 800cad0: 68fb         	ldr	r3, [r7, #0xc]
 800cad2: 4618         	mov	r0, r3
 800cad4: f00c fa6e    	bl	0x8018fb4 <z_waitq_head> @ imm = #0xc4dc
 800cad8: f8c7 00a8    	str.w	r0, [r7, #0xa8]
; 			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
 800cadc: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800cae0: 2b00         	cmp	r3, #0x0
 800cae2: d00c         	beq	0x800cafe <z_impl_k_mutex_lock+0x3be> @ imm = #0x18
 800cae4: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800cae8: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800caec: 461a         	mov	r2, r3
 800caee: 68fb         	ldr	r3, [r7, #0xc]
 800caf0: 691b         	ldr	r3, [r3, #0x10]
 800caf2: 4619         	mov	r1, r3
 800caf4: 4610         	mov	r0, r2
 800caf6: f00c fa9e    	bl	0x8019036 <new_prio_for_inheritance> @ imm = #0xc53c
 800cafa: 4603         	mov	r3, r0
 800cafc: e001         	b	0x800cb02 <z_impl_k_mutex_lock+0x3c2> @ imm = #0x2
 800cafe: 68fb         	ldr	r3, [r7, #0xc]
 800cb00: 691b         	ldr	r3, [r3, #0x10]
; 		new_prio = (waiter != NULL) ?
 800cb02: f8c7 30d0    	str.w	r3, [r7, #0xd0]
; 		LOG_DBG("adjusting prio down on mutex %p", mutex);
 800cb06: 2303         	movs	r3, #0x3
 800cb08: 2b03         	cmp	r3, #0x3
 800cb0a: d91d         	bls	0x800cb48 <z_impl_k_mutex_lock+0x408> @ imm = #0x3a
 800cb0c: 2301         	movs	r3, #0x1
 800cb0e: f887 30a7    	strb.w	r3, [r7, #0xa7]
 800cb12: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 800cb16: f083 0301    	eor	r3, r3, #0x1
 800cb1a: b2db         	uxtb	r3, r3
 800cb1c: 2b00         	cmp	r3, #0x0
 800cb1e: d113         	bne	0x800cb48 <z_impl_k_mutex_lock+0x408> @ imm = #0x26
 800cb20: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800cbc0 <z_impl_k_mutex_lock+0x480>
 800cb22: 6819         	ldr	r1, [r3]
 800cb24: 68fb         	ldr	r3, [r7, #0xc]
 800cb26: 9304         	str	r3, [sp, #0x10]
 800cb28: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800cbb8 <z_impl_k_mutex_lock+0x478>
 800cb2a: 9303         	str	r3, [sp, #0xc]
 800cb2c: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800cbd0 <z_impl_k_mutex_lock+0x490>
 800cb2e: 9302         	str	r3, [sp, #0x8]
 800cb30: 2308         	movs	r3, #0x8
 800cb32: 9301         	str	r3, [sp, #0x4]
 800cb34: 2300         	movs	r3, #0x0
 800cb36: 9300         	str	r3, [sp]
 800cb38: 2300         	movs	r3, #0x0
 800cb3a: 2204         	movs	r2, #0x4
 800cb3c: 2000         	movs	r0, #0x0
 800cb3e: f00c fa46    	bl	0x8018fce <z_log_msg_runtime_create> @ imm = #0xc48c
 800cb42: 2300         	movs	r3, #0x0
 800cb44: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; 		resched = adjust_owner_prio(mutex, new_prio) || resched;
 800cb48: f8d7 10d0    	ldr.w	r1, [r7, #0xd0]
 800cb4c: 68f8         	ldr	r0, [r7, #0xc]
 800cb4e: f7ff fda3    	bl	0x800c698 <adjust_owner_prio> @ imm = #-0x4ba
 800cb52: 4603         	mov	r3, r0
 800cb54: 2b00         	cmp	r3, #0x0
 800cb56: d103         	bne	0x800cb60 <z_impl_k_mutex_lock+0x420> @ imm = #0x6
 800cb58: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 800cb5c: 2b00         	cmp	r3, #0x0
 800cb5e: d001         	beq	0x800cb64 <z_impl_k_mutex_lock+0x424> @ imm = #0x2
 800cb60: 2301         	movs	r3, #0x1
 800cb62: e000         	b	0x800cb66 <z_impl_k_mutex_lock+0x426> @ imm = #0x0
 800cb64: 2300         	movs	r3, #0x0
 800cb66: f887 30d7    	strb.w	r3, [r7, #0xd7]
 800cb6a: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 800cb6e: f003 0301    	and	r3, r3, #0x1
 800cb72: f887 30d7    	strb.w	r3, [r7, #0xd7]
; 	if (resched) {
 800cb76: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 800cb7a: 2b00         	cmp	r3, #0x0
 800cb7c: d004         	beq	0x800cb88 <z_impl_k_mutex_lock+0x448> @ imm = #0x8
; 		z_reschedule(&lock, key);
 800cb7e: 6a79         	ldr	r1, [r7, #0x24]
 800cb80: 4812         	ldr	r0, [pc, #0x48]         @ 0x800cbcc <z_impl_k_mutex_lock+0x48c>
 800cb82: f00d fb7c    	bl	0x801a27e <z_reschedule> @ imm = #0xd6f8
 800cb86: e010         	b	0x800cbaa <z_impl_k_mutex_lock+0x46a> @ imm = #0x20
 800cb88: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800cbcc <z_impl_k_mutex_lock+0x48c>
 800cb8a: 633b         	str	r3, [r7, #0x30]
 800cb8c: 6a7b         	ldr	r3, [r7, #0x24]
 800cb8e: 623b         	str	r3, [r7, #0x20]
; 	arch_irq_unlock(key.key);
 800cb90: 6a3b         	ldr	r3, [r7, #0x20]
 800cb92: 62fb         	str	r3, [r7, #0x2c]
 800cb94: 6afb         	ldr	r3, [r7, #0x2c]
 800cb96: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800cb98: 6abb         	ldr	r3, [r7, #0x28]
 800cb9a: f383 8811    	msr	basepri, r3
; }
 800cb9e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cba0: f3bf 8f6f    	isb	sy
; }
 800cba4: bf00         	nop
; }
 800cba6: bf00         	nop
; }
 800cba8: bf00         	nop
; 	return -EAGAIN;
 800cbaa: f06f 030a    	mvn	r3, #0xa
; }
 800cbae: 4618         	mov	r0, r3
 800cbb0: 37d8         	adds	r7, #0xd8
 800cbb2: 46bd         	mov	sp, r7
 800cbb4: bd80         	pop	{r7, pc}
 800cbb6: bf00         	nop

0800cbb8 <$d>:
 800cbb8: a8 d8 01 08  	.word	0x0801d8a8
 800cbbc: 98 cb 01 08  	.word	0x0801cb98
 800cbc0: 54 05 00 20  	.word	0x20000554
 800cbc4: 30 07 00 20  	.word	0x20000730
 800cbc8: b8 cb 01 08  	.word	0x0801cbb8
 800cbcc: 24 11 00 20  	.word	0x20001124
 800cbd0: d4 cb 01 08  	.word	0x0801cbd4

0800cbd4 <z_impl_k_mutex_unlock>:
; {
 800cbd4: b580         	push	{r7, lr}
 800cbd6: b0a4         	sub	sp, #0x90
 800cbd8: af08         	add	r7, sp, #0x20
 800cbda: 6078         	str	r0, [r7, #0x4]
; 	CHECKIF(mutex->owner == NULL) {
 800cbdc: 687b         	ldr	r3, [r7, #0x4]
 800cbde: 689b         	ldr	r3, [r3, #0x8]
 800cbe0: 2b00         	cmp	r3, #0x0
 800cbe2: d102         	bne	0x800cbea <z_impl_k_mutex_unlock+0x16> @ imm = #0x4
; 		return -EINVAL;
 800cbe4: f06f 0315    	mvn	r3, #0x15
 800cbe8: e0dc         	b	0x800cda4 <z_impl_k_mutex_unlock+0x1d0> @ imm = #0x1b8
; 	CHECKIF(mutex->owner != arch_current_thread()) {
 800cbea: 687b         	ldr	r3, [r7, #0x4]
 800cbec: 689a         	ldr	r2, [r3, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800cbee: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x800cdac <z_impl_k_mutex_unlock+0x1d8>
 800cbf0: 689b         	ldr	r3, [r3, #0x8]
 800cbf2: 65bb         	str	r3, [r7, #0x58]
; 	return ret;
 800cbf4: 6dbb         	ldr	r3, [r7, #0x58]
; 	CHECKIF(mutex->owner != arch_current_thread()) {
 800cbf6: 429a         	cmp	r2, r3
 800cbf8: d002         	beq	0x800cc00 <z_impl_k_mutex_unlock+0x2c> @ imm = #0x4
; 		return -EPERM;
 800cbfa: f04f 33ff    	mov.w	r3, #0xffffffff
 800cbfe: e0d1         	b	0x800cda4 <z_impl_k_mutex_unlock+0x1d0> @ imm = #0x1a2
; 	LOG_DBG("mutex %p lock_count: %d", mutex, mutex->lock_count);
 800cc00: 2303         	movs	r3, #0x3
 800cc02: 2b03         	cmp	r3, #0x3
 800cc04: d91f         	bls	0x800cc46 <z_impl_k_mutex_unlock+0x72> @ imm = #0x3e
 800cc06: 2301         	movs	r3, #0x1
 800cc08: f887 306f    	strb.w	r3, [r7, #0x6f]
 800cc0c: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800cc10: f083 0301    	eor	r3, r3, #0x1
 800cc14: b2db         	uxtb	r3, r3
 800cc16: 2b00         	cmp	r3, #0x0
 800cc18: d115         	bne	0x800cc46 <z_impl_k_mutex_unlock+0x72> @ imm = #0x2a
 800cc1a: 4b65         	ldr	r3, [pc, #0x194]        @ 0x800cdb0 <z_impl_k_mutex_unlock+0x1dc>
 800cc1c: 6819         	ldr	r1, [r3]
 800cc1e: 687b         	ldr	r3, [r7, #0x4]
 800cc20: 68db         	ldr	r3, [r3, #0xc]
 800cc22: 9305         	str	r3, [sp, #0x14]
 800cc24: 687b         	ldr	r3, [r7, #0x4]
 800cc26: 9304         	str	r3, [sp, #0x10]
 800cc28: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800cdb4 <z_impl_k_mutex_unlock+0x1e0>
 800cc2a: 9303         	str	r3, [sp, #0xc]
 800cc2c: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800cdb8 <z_impl_k_mutex_unlock+0x1e4>
 800cc2e: 9302         	str	r3, [sp, #0x8]
 800cc30: 2308         	movs	r3, #0x8
 800cc32: 9301         	str	r3, [sp, #0x4]
 800cc34: 2300         	movs	r3, #0x0
 800cc36: 9300         	str	r3, [sp]
 800cc38: 2300         	movs	r3, #0x0
 800cc3a: 2204         	movs	r2, #0x4
 800cc3c: 2000         	movs	r0, #0x0
 800cc3e: f00c f9c6    	bl	0x8018fce <z_log_msg_runtime_create> @ imm = #0xc38c
 800cc42: 2300         	movs	r3, #0x0
 800cc44: 66bb         	str	r3, [r7, #0x68]
; 	if (mutex->lock_count > 1U) {
 800cc46: 687b         	ldr	r3, [r7, #0x4]
 800cc48: 68db         	ldr	r3, [r3, #0xc]
 800cc4a: 2b01         	cmp	r3, #0x1
 800cc4c: d905         	bls	0x800cc5a <z_impl_k_mutex_unlock+0x86> @ imm = #0xa
; 		mutex->lock_count--;
 800cc4e: 687b         	ldr	r3, [r7, #0x4]
 800cc50: 68db         	ldr	r3, [r3, #0xc]
 800cc52: 1e5a         	subs	r2, r3, #0x1
 800cc54: 687b         	ldr	r3, [r7, #0x4]
 800cc56: 60da         	str	r2, [r3, #0xc]
; 		goto k_mutex_unlock_return;
 800cc58: e0a3         	b	0x800cda2 <z_impl_k_mutex_unlock+0x1ce> @ imm = #0x146
 800cc5a: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800cdbc <z_impl_k_mutex_unlock+0x1e8>
 800cc5c: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800cc5e: f3ef 8311    	mrs	r3, basepri
 800cc62: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800cc64: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 800cc66: 63bb         	str	r3, [r7, #0x38]
 800cc68: 2310         	movs	r3, #0x10
 800cc6a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800cc6c: 6b7b         	ldr	r3, [r7, #0x34]
 800cc6e: f383 8812    	msr	basepri_max, r3
; }
 800cc72: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cc74: f3bf 8f6f    	isb	sy
; }
 800cc78: bf00         	nop
; 	return key;
 800cc7a: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 800cc7c: 60fb         	str	r3, [r7, #0xc]
 800cc7e: 6c3b         	ldr	r3, [r7, #0x40]
 800cc80: 633b         	str	r3, [r7, #0x30]
; }
 800cc82: bf00         	nop
 800cc84: 6c3b         	ldr	r3, [r7, #0x40]
 800cc86: 62fb         	str	r3, [r7, #0x2c]
; }
 800cc88: bf00         	nop
; 	return k;
 800cc8a: 68fb         	ldr	r3, [r7, #0xc]
 800cc8c: 617b         	str	r3, [r7, #0x14]
; 	adjust_owner_prio(mutex, mutex->owner_orig_prio);
 800cc8e: 687b         	ldr	r3, [r7, #0x4]
 800cc90: 691b         	ldr	r3, [r3, #0x10]
 800cc92: 4619         	mov	r1, r3
 800cc94: 6878         	ldr	r0, [r7, #0x4]
 800cc96: f7ff fcff    	bl	0x800c698 <adjust_owner_prio> @ imm = #-0x602
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 800cc9a: 687b         	ldr	r3, [r7, #0x4]
 800cc9c: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 800cc9e: 2300         	movs	r3, #0x0
 800cca0: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800cca2: 6d7b         	ldr	r3, [r7, #0x54]
 800cca4: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800cca6: 2300         	movs	r3, #0x0
 800cca8: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800ccaa: 6cf8         	ldr	r0, [r7, #0x4c]
 800ccac: f00c f866    	bl	0x8018d7c <sys_dlist_peek_head> @ imm = #0xc0cc
 800ccb0: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800ccb2: 6c7b         	ldr	r3, [r7, #0x44]
 800ccb4: 2b00         	cmp	r3, #0x0
 800ccb6: d001         	beq	0x800ccbc <z_impl_k_mutex_unlock+0xe8> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800ccb8: 6c7b         	ldr	r3, [r7, #0x44]
 800ccba: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800ccbc: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800ccbe: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 800ccc0: 6d3b         	ldr	r3, [r7, #0x50]
 800ccc2: 2b00         	cmp	r3, #0x0
 800ccc4: bf14         	ite	ne
 800ccc6: 2301         	movne	r3, #0x1
 800ccc8: 2300         	moveq	r3, #0x0
 800ccca: b2db         	uxtb	r3, r3
 800cccc: 2b00         	cmp	r3, #0x0
 800ccce: d005         	beq	0x800ccdc <z_impl_k_mutex_unlock+0x108> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 800ccd0: 6d38         	ldr	r0, [r7, #0x50]
 800ccd2: f00c f949    	bl	0x8018f68 <unpend_thread_no_timeout> @ imm = #0xc292
; 			(void)z_abort_thread_timeout(thread);
 800ccd6: 6d38         	ldr	r0, [r7, #0x50]
 800ccd8: f00c f89a    	bl	0x8018e10 <z_abort_thread_timeout> @ imm = #0xc134
; 	return thread;
 800ccdc: 6d3b         	ldr	r3, [r7, #0x50]
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 800ccde: 667b         	str	r3, [r7, #0x64]
; 	mutex->owner = new_owner;
 800cce0: 687b         	ldr	r3, [r7, #0x4]
 800cce2: 6e7a         	ldr	r2, [r7, #0x64]
 800cce4: 609a         	str	r2, [r3, #0x8]
; 	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
 800cce6: 2303         	movs	r3, #0x3
 800cce8: 2b03         	cmp	r3, #0x3
 800ccea: d927         	bls	0x800cd3c <z_impl_k_mutex_unlock+0x168> @ imm = #0x4e
 800ccec: 2301         	movs	r3, #0x1
 800ccee: f887 3063    	strb.w	r3, [r7, #0x63]
 800ccf2: f897 3063    	ldrb.w	r3, [r7, #0x63]
 800ccf6: f083 0301    	eor	r3, r3, #0x1
 800ccfa: b2db         	uxtb	r3, r3
 800ccfc: 2b00         	cmp	r3, #0x0
 800ccfe: d11d         	bne	0x800cd3c <z_impl_k_mutex_unlock+0x168> @ imm = #0x3a
 800cd00: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800cdb0 <z_impl_k_mutex_unlock+0x1dc>
 800cd02: 6819         	ldr	r1, [r3]
 800cd04: 6e7b         	ldr	r3, [r7, #0x64]
 800cd06: 2b00         	cmp	r3, #0x0
 800cd08: d003         	beq	0x800cd12 <z_impl_k_mutex_unlock+0x13e> @ imm = #0x6
 800cd0a: 6e7b         	ldr	r3, [r7, #0x64]
 800cd0c: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800cd10: e000         	b	0x800cd14 <z_impl_k_mutex_unlock+0x140> @ imm = #0x0
 800cd12: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800cdc0 <z_impl_k_mutex_unlock+0x1ec>
 800cd14: 9306         	str	r3, [sp, #0x18]
 800cd16: 6e7b         	ldr	r3, [r7, #0x64]
 800cd18: 9305         	str	r3, [sp, #0x14]
 800cd1a: 687b         	ldr	r3, [r7, #0x4]
 800cd1c: 9304         	str	r3, [sp, #0x10]
 800cd1e: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800cdb4 <z_impl_k_mutex_unlock+0x1e0>
 800cd20: 9303         	str	r3, [sp, #0xc]
 800cd22: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800cdc4 <z_impl_k_mutex_unlock+0x1f0>
 800cd24: 9302         	str	r3, [sp, #0x8]
 800cd26: 2308         	movs	r3, #0x8
 800cd28: 9301         	str	r3, [sp, #0x4]
 800cd2a: 2300         	movs	r3, #0x0
 800cd2c: 9300         	str	r3, [sp]
 800cd2e: 2300         	movs	r3, #0x0
 800cd30: 2204         	movs	r2, #0x4
 800cd32: 2000         	movs	r0, #0x0
 800cd34: f00c f94b    	bl	0x8018fce <z_log_msg_runtime_create> @ imm = #0xc296
 800cd38: 2300         	movs	r3, #0x0
 800cd3a: 65fb         	str	r3, [r7, #0x5c]
; 	if (unlikely(new_owner != NULL)) {
 800cd3c: 6e7b         	ldr	r3, [r7, #0x64]
 800cd3e: 2b00         	cmp	r3, #0x0
 800cd40: bf14         	ite	ne
 800cd42: 2301         	movne	r3, #0x1
 800cd44: 2300         	moveq	r3, #0x0
 800cd46: b2db         	uxtb	r3, r3
 800cd48: 2b00         	cmp	r3, #0x0
 800cd4a: d016         	beq	0x800cd7a <z_impl_k_mutex_unlock+0x1a6> @ imm = #0x2c
; 		mutex->owner_orig_prio = new_owner->base.prio;
 800cd4c: 6e7b         	ldr	r3, [r7, #0x64]
 800cd4e: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800cd52: 461a         	mov	r2, r3
 800cd54: 687b         	ldr	r3, [r7, #0x4]
 800cd56: 611a         	str	r2, [r3, #0x10]
 800cd58: 6e7b         	ldr	r3, [r7, #0x64]
 800cd5a: 62bb         	str	r3, [r7, #0x28]
 800cd5c: 2300         	movs	r3, #0x0
 800cd5e: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 800cd60: 6abb         	ldr	r3, [r7, #0x28]
 800cd62: 6a7a         	ldr	r2, [r7, #0x24]
 800cd64: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800cd68: bf00         	nop
; 		z_ready_thread(new_owner);
 800cd6a: 6e78         	ldr	r0, [r7, #0x64]
 800cd6c: f001 f84e    	bl	0x800de0c <z_ready_thread> @ imm = #0x109c
; 		z_reschedule(&lock, key);
 800cd70: 6979         	ldr	r1, [r7, #0x14]
 800cd72: 4812         	ldr	r0, [pc, #0x48]         @ 0x800cdbc <z_impl_k_mutex_unlock+0x1e8>
 800cd74: f00d fa83    	bl	0x801a27e <z_reschedule> @ imm = #0xd506
 800cd78: e013         	b	0x800cda2 <z_impl_k_mutex_unlock+0x1ce> @ imm = #0x26
; 		mutex->lock_count = 0U;
 800cd7a: 687b         	ldr	r3, [r7, #0x4]
 800cd7c: 2200         	movs	r2, #0x0
 800cd7e: 60da         	str	r2, [r3, #0xc]
 800cd80: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800cdbc <z_impl_k_mutex_unlock+0x1e8>
 800cd82: 623b         	str	r3, [r7, #0x20]
 800cd84: 697b         	ldr	r3, [r7, #0x14]
 800cd86: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800cd88: 693b         	ldr	r3, [r7, #0x10]
 800cd8a: 61fb         	str	r3, [r7, #0x1c]
 800cd8c: 69fb         	ldr	r3, [r7, #0x1c]
 800cd8e: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800cd90: 69bb         	ldr	r3, [r7, #0x18]
 800cd92: f383 8811    	msr	basepri, r3
; }
 800cd96: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cd98: f3bf 8f6f    	isb	sy
; }
 800cd9c: bf00         	nop
; }
 800cd9e: bf00         	nop
; }
 800cda0: bf00         	nop
; 	return 0;
 800cda2: 2300         	movs	r3, #0x0
; }
 800cda4: 4618         	mov	r0, r3
 800cda6: 3770         	adds	r7, #0x70
 800cda8: 46bd         	mov	sp, r7
 800cdaa: bd80         	pop	{r7, pc}

0800cdac <$d>:
 800cdac: 30 07 00 20  	.word	0x20000730
 800cdb0: 54 05 00 20  	.word	0x20000554
 800cdb4: bc d8 01 08  	.word	0x0801d8bc
 800cdb8: f8 cb 01 08  	.word	0x0801cbf8
 800cdbc: 24 11 00 20  	.word	0x20001124
 800cdc0: 18 fc ff ff  	.word	0xfffffc18
 800cdc4: 14 cc 01 08  	.word	0x0801cc14

0800cdc8 <z_impl_k_sem_give>:
; {
 800cdc8: b580         	push	{r7, lr}
 800cdca: b098         	sub	sp, #0x60
 800cdcc: af00         	add	r7, sp, #0x0
 800cdce: 6078         	str	r0, [r7, #0x4]
 800cdd0: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800cee0 <z_impl_k_sem_give+0x118>
 800cdd2: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800cdd4: f3ef 8311    	mrs	r3, basepri
 800cdd8: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800cdda: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 800cddc: 63bb         	str	r3, [r7, #0x38]
 800cdde: 2310         	movs	r3, #0x10
 800cde0: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800cde2: 6b7b         	ldr	r3, [r7, #0x34]
 800cde4: f383 8812    	msr	basepri_max, r3
; }
 800cde8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cdea: f3bf 8f6f    	isb	sy
; }
 800cdee: bf00         	nop
; 	return key;
 800cdf0: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 800cdf2: 60fb         	str	r3, [r7, #0xc]
 800cdf4: 6c3b         	ldr	r3, [r7, #0x40]
 800cdf6: 633b         	str	r3, [r7, #0x30]
; }
 800cdf8: bf00         	nop
 800cdfa: 6c3b         	ldr	r3, [r7, #0x40]
 800cdfc: 62fb         	str	r3, [r7, #0x2c]
; }
 800cdfe: bf00         	nop
; 	return k;
 800ce00: 68fb         	ldr	r3, [r7, #0xc]
 800ce02: 617b         	str	r3, [r7, #0x14]
; 	bool resched = true;
 800ce04: 2301         	movs	r3, #0x1
 800ce06: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 800ce0a: 687b         	ldr	r3, [r7, #0x4]
 800ce0c: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 800ce0e: 2300         	movs	r3, #0x0
 800ce10: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800ce12: 6d7b         	ldr	r3, [r7, #0x54]
 800ce14: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800ce16: 2300         	movs	r3, #0x0
 800ce18: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800ce1a: 6cf8         	ldr	r0, [r7, #0x4c]
 800ce1c: f00c f953    	bl	0x80190c6 <sys_dlist_peek_head> @ imm = #0xc2a6
 800ce20: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800ce22: 6c7b         	ldr	r3, [r7, #0x44]
 800ce24: 2b00         	cmp	r3, #0x0
 800ce26: d001         	beq	0x800ce2c <z_impl_k_sem_give+0x64> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800ce28: 6c7b         	ldr	r3, [r7, #0x44]
 800ce2a: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800ce2c: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800ce2e: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 800ce30: 6d3b         	ldr	r3, [r7, #0x50]
 800ce32: 2b00         	cmp	r3, #0x0
 800ce34: bf14         	ite	ne
 800ce36: 2301         	movne	r3, #0x1
 800ce38: 2300         	moveq	r3, #0x0
 800ce3a: b2db         	uxtb	r3, r3
 800ce3c: 2b00         	cmp	r3, #0x0
 800ce3e: d005         	beq	0x800ce4c <z_impl_k_sem_give+0x84> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 800ce40: 6d38         	ldr	r0, [r7, #0x50]
 800ce42: f00c f99c    	bl	0x801917e <unpend_thread_no_timeout> @ imm = #0xc338
; 			(void)z_abort_thread_timeout(thread);
 800ce46: 6d38         	ldr	r0, [r7, #0x50]
 800ce48: f00c f96f    	bl	0x801912a <z_abort_thread_timeout> @ imm = #0xc2de
; 	return thread;
 800ce4c: 6d3b         	ldr	r3, [r7, #0x50]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 800ce4e: 65bb         	str	r3, [r7, #0x58]
; 	if (unlikely(thread != NULL)) {
 800ce50: 6dbb         	ldr	r3, [r7, #0x58]
 800ce52: 2b00         	cmp	r3, #0x0
 800ce54: bf14         	ite	ne
 800ce56: 2301         	movne	r3, #0x1
 800ce58: 2300         	moveq	r3, #0x0
 800ce5a: b2db         	uxtb	r3, r3
 800ce5c: 2b00         	cmp	r3, #0x0
 800ce5e: d00c         	beq	0x800ce7a <z_impl_k_sem_give+0xb2> @ imm = #0x18
 800ce60: 6dbb         	ldr	r3, [r7, #0x58]
 800ce62: 62bb         	str	r3, [r7, #0x28]
 800ce64: 2300         	movs	r3, #0x0
 800ce66: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 800ce68: 6abb         	ldr	r3, [r7, #0x28]
 800ce6a: 6a7a         	ldr	r2, [r7, #0x24]
 800ce6c: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800ce70: bf00         	nop
; 		z_ready_thread(thread);
 800ce72: 6db8         	ldr	r0, [r7, #0x58]
 800ce74: f000 ffca    	bl	0x800de0c <z_ready_thread> @ imm = #0xf94
 800ce78: e013         	b	0x800cea2 <z_impl_k_sem_give+0xda> @ imm = #0x26
; 		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 800ce7a: 687b         	ldr	r3, [r7, #0x4]
 800ce7c: 689b         	ldr	r3, [r3, #0x8]
 800ce7e: 687a         	ldr	r2, [r7, #0x4]
 800ce80: 6891         	ldr	r1, [r2, #0x8]
 800ce82: 687a         	ldr	r2, [r7, #0x4]
 800ce84: 68d2         	ldr	r2, [r2, #0xc]
 800ce86: 4291         	cmp	r1, r2
 800ce88: d001         	beq	0x800ce8e <z_impl_k_sem_give+0xc6> @ imm = #0x2
 800ce8a: 2201         	movs	r2, #0x1
 800ce8c: e000         	b	0x800ce90 <z_impl_k_sem_give+0xc8> @ imm = #0x0
 800ce8e: 2200         	movs	r2, #0x0
 800ce90: 441a         	add	r2, r3
 800ce92: 687b         	ldr	r3, [r7, #0x4]
 800ce94: 609a         	str	r2, [r3, #0x8]
; 		resched = handle_poll_events(sem);
 800ce96: 6878         	ldr	r0, [r7, #0x4]
 800ce98: f00c f9ad    	bl	0x80191f6 <handle_poll_events> @ imm = #0xc35a
 800ce9c: 4603         	mov	r3, r0
 800ce9e: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	if (unlikely(resched)) {
 800cea2: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 800cea6: 2b00         	cmp	r3, #0x0
 800cea8: d004         	beq	0x800ceb4 <z_impl_k_sem_give+0xec> @ imm = #0x8
; 		z_reschedule(&lock, key);
 800ceaa: 6979         	ldr	r1, [r7, #0x14]
 800ceac: 480c         	ldr	r0, [pc, #0x30]         @ 0x800cee0 <z_impl_k_sem_give+0x118>
 800ceae: f00d f9e6    	bl	0x801a27e <z_reschedule> @ imm = #0xd3cc
; }
 800ceb2: e010         	b	0x800ced6 <z_impl_k_sem_give+0x10e> @ imm = #0x20
 800ceb4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800cee0 <z_impl_k_sem_give+0x118>
 800ceb6: 623b         	str	r3, [r7, #0x20]
 800ceb8: 697b         	ldr	r3, [r7, #0x14]
 800ceba: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800cebc: 693b         	ldr	r3, [r7, #0x10]
 800cebe: 61fb         	str	r3, [r7, #0x1c]
 800cec0: 69fb         	ldr	r3, [r7, #0x1c]
 800cec2: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800cec4: 69bb         	ldr	r3, [r7, #0x18]
 800cec6: f383 8811    	msr	basepri, r3
; }
 800ceca: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cecc: f3bf 8f6f    	isb	sy
; }
 800ced0: bf00         	nop
; }
 800ced2: bf00         	nop
; }
 800ced4: bf00         	nop
; }
 800ced6: bf00         	nop
 800ced8: 3760         	adds	r7, #0x60
 800ceda: 46bd         	mov	sp, r7
 800cedc: bd80         	pop	{r7, pc}
 800cede: bf00         	nop

0800cee0 <$d>:
 800cee0: 24 11 00 20  	.word	0x20001124

0800cee4 <z_impl_k_sem_take>:
; {
 800cee4: b580         	push	{r7, lr}
 800cee6: b098         	sub	sp, #0x60
 800cee8: af02         	add	r7, sp, #0x8
 800ceea: 60f8         	str	r0, [r7, #0xc]
 800ceec: e9c7 2300    	strd	r2, r3, [r7]
 800cef0: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800cfc8 <z_impl_k_sem_take+0xe4>
 800cef2: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800cef4: f3ef 8311    	mrs	r3, basepri
 800cef8: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 800cefa: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 800cefc: 64bb         	str	r3, [r7, #0x48]
 800cefe: 2310         	movs	r3, #0x10
 800cf00: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800cf02: 6c7b         	ldr	r3, [r7, #0x44]
 800cf04: f383 8812    	msr	basepri_max, r3
; }
 800cf08: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cf0a: f3bf 8f6f    	isb	sy
; }
 800cf0e: bf00         	nop
; 	return key;
 800cf10: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 800cf12: 61bb         	str	r3, [r7, #0x18]
 800cf14: 6d3b         	ldr	r3, [r7, #0x50]
 800cf16: 643b         	str	r3, [r7, #0x40]
; }
 800cf18: bf00         	nop
 800cf1a: 6d3b         	ldr	r3, [r7, #0x50]
 800cf1c: 63fb         	str	r3, [r7, #0x3c]
; }
 800cf1e: bf00         	nop
; 	return k;
 800cf20: 69bb         	ldr	r3, [r7, #0x18]
 800cf22: 623b         	str	r3, [r7, #0x20]
; 	if (likely(sem->count > 0U)) {
 800cf24: 68fb         	ldr	r3, [r7, #0xc]
 800cf26: 689b         	ldr	r3, [r3, #0x8]
 800cf28: 2b00         	cmp	r3, #0x0
 800cf2a: bf14         	ite	ne
 800cf2c: 2301         	movne	r3, #0x1
 800cf2e: 2300         	moveq	r3, #0x0
 800cf30: b2db         	uxtb	r3, r3
 800cf32: 2b00         	cmp	r3, #0x0
 800cf34: d018         	beq	0x800cf68 <z_impl_k_sem_take+0x84> @ imm = #0x30
; 		sem->count--;
 800cf36: 68fb         	ldr	r3, [r7, #0xc]
 800cf38: 689b         	ldr	r3, [r3, #0x8]
 800cf3a: 1e5a         	subs	r2, r3, #0x1
 800cf3c: 68fb         	ldr	r3, [r7, #0xc]
 800cf3e: 609a         	str	r2, [r3, #0x8]
 800cf40: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800cfc8 <z_impl_k_sem_take+0xe4>
 800cf42: 63bb         	str	r3, [r7, #0x38]
 800cf44: 6a3b         	ldr	r3, [r7, #0x20]
 800cf46: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 800cf48: 69fb         	ldr	r3, [r7, #0x1c]
 800cf4a: 637b         	str	r3, [r7, #0x34]
 800cf4c: 6b7b         	ldr	r3, [r7, #0x34]
 800cf4e: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800cf50: 6b3b         	ldr	r3, [r7, #0x30]
 800cf52: f383 8811    	msr	basepri, r3
; }
 800cf56: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cf58: f3bf 8f6f    	isb	sy
; }
 800cf5c: bf00         	nop
; }
 800cf5e: bf00         	nop
; }
 800cf60: bf00         	nop
; 		ret = 0;
 800cf62: 2300         	movs	r3, #0x0
 800cf64: 657b         	str	r3, [r7, #0x54]
; 		goto out;
 800cf66: e029         	b	0x800cfbc <z_impl_k_sem_take+0xd8> @ imm = #0x52
; 	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 800cf68: e9d7 2300    	ldrd	r2, r3, [r7]
 800cf6c: f04f 0000    	mov.w	r0, #0x0
 800cf70: f04f 0100    	mov.w	r1, #0x0
 800cf74: 428b         	cmp	r3, r1
 800cf76: bf08         	it	eq
 800cf78: 4282         	cmpeq	r2, r0
 800cf7a: d114         	bne	0x800cfa6 <z_impl_k_sem_take+0xc2> @ imm = #0x28
 800cf7c: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800cfc8 <z_impl_k_sem_take+0xe4>
 800cf7e: 62fb         	str	r3, [r7, #0x2c]
 800cf80: 6a3b         	ldr	r3, [r7, #0x20]
 800cf82: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 800cf84: 697b         	ldr	r3, [r7, #0x14]
 800cf86: 62bb         	str	r3, [r7, #0x28]
 800cf88: 6abb         	ldr	r3, [r7, #0x28]
 800cf8a: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800cf8c: 6a7b         	ldr	r3, [r7, #0x24]
 800cf8e: f383 8811    	msr	basepri, r3
; }
 800cf92: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cf94: f3bf 8f6f    	isb	sy
; }
 800cf98: bf00         	nop
; }
 800cf9a: bf00         	nop
; }
 800cf9c: bf00         	nop
; 		ret = -EBUSY;
 800cf9e: f06f 030f    	mvn	r3, #0xf
 800cfa2: 657b         	str	r3, [r7, #0x54]
 800cfa4: e00a         	b	0x800cfbc <z_impl_k_sem_take+0xd8> @ imm = #0x14
; 	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 800cfa6: 68f9         	ldr	r1, [r7, #0xc]
 800cfa8: e9d7 2300    	ldrd	r2, r3, [r7]
 800cfac: e9cd 2300    	strd	r2, r3, [sp]
 800cfb0: 460a         	mov	r2, r1
 800cfb2: 6a39         	ldr	r1, [r7, #0x20]
 800cfb4: 4804         	ldr	r0, [pc, #0x10]         @ 0x800cfc8 <z_impl_k_sem_take+0xe4>
 800cfb6: f001 fb2b    	bl	0x800e610 <z_pend_curr> @ imm = #0x1656
 800cfba: 6578         	str	r0, [r7, #0x54]
; 	return ret;
 800cfbc: 6d7b         	ldr	r3, [r7, #0x54]
; }
 800cfbe: 4618         	mov	r0, r3
 800cfc0: 3758         	adds	r7, #0x58
 800cfc2: 46bd         	mov	sp, r7
 800cfc4: bd80         	pop	{r7, pc}
 800cfc6: bf00         	nop

0800cfc8 <$d>:
 800cfc8: 24 11 00 20  	.word	0x20001124

0800cfcc <finalize_cancel_locked>:
; {
 800cfcc: b580         	push	{r7, lr}
 800cfce: b086         	sub	sp, #0x18
 800cfd0: af00         	add	r7, sp, #0x0
 800cfd2: 6078         	str	r0, [r7, #0x4]
; 	sys_snode_t *prev = NULL;
 800cfd4: 2300         	movs	r3, #0x0
 800cfd6: 60fb         	str	r3, [r7, #0xc]
; 	flag_clear(&work->flags, K_WORK_CANCELING_BIT);
 800cfd8: 687b         	ldr	r3, [r7, #0x4]
 800cfda: 330c         	adds	r3, #0xc
 800cfdc: 2101         	movs	r1, #0x1
 800cfde: 4618         	mov	r0, r3
 800cfe0: f00c fb13    	bl	0x801960a <flag_clear>  @ imm = #0xc626
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 800cfe4: 4829         	ldr	r0, [pc, #0xa4]         @ 0x800d08c <finalize_cancel_locked+0xc0>
 800cfe6: f00c f96f    	bl	0x80192c8 <sys_slist_peek_head> @ imm = #0xc2de
 800cfea: 4603         	mov	r3, r0
 800cfec: 2b00         	cmp	r3, #0x0
 800cfee: d004         	beq	0x800cffa <finalize_cancel_locked+0x2e> @ imm = #0x8
 800cff0: 4826         	ldr	r0, [pc, #0x98]         @ 0x800d08c <finalize_cancel_locked+0xc0>
 800cff2: f00c f969    	bl	0x80192c8 <sys_slist_peek_head> @ imm = #0xc2d2
 800cff6: 4603         	mov	r3, r0
 800cff8: e000         	b	0x800cffc <finalize_cancel_locked+0x30> @ imm = #0x0
 800cffa: 2300         	movs	r3, #0x0
 800cffc: 617b         	str	r3, [r7, #0x14]
 800cffe: 697b         	ldr	r3, [r7, #0x14]
 800d000: 2b00         	cmp	r3, #0x0
 800d002: d00e         	beq	0x800d022 <finalize_cancel_locked+0x56> @ imm = #0x1c
 800d004: 697b         	ldr	r3, [r7, #0x14]
 800d006: 4618         	mov	r0, r3
 800d008: f00c f991    	bl	0x801932e <sys_slist_peek_next> @ imm = #0xc322
 800d00c: 4603         	mov	r3, r0
 800d00e: 2b00         	cmp	r3, #0x0
 800d010: d005         	beq	0x800d01e <finalize_cancel_locked+0x52> @ imm = #0xa
 800d012: 697b         	ldr	r3, [r7, #0x14]
 800d014: 4618         	mov	r0, r3
 800d016: f00c f98a    	bl	0x801932e <sys_slist_peek_next> @ imm = #0xc314
 800d01a: 4603         	mov	r3, r0
 800d01c: e002         	b	0x800d024 <finalize_cancel_locked+0x58> @ imm = #0x4
 800d01e: 2300         	movs	r3, #0x0
 800d020: e000         	b	0x800d024 <finalize_cancel_locked+0x58> @ imm = #0x0
 800d022: 2300         	movs	r3, #0x0
 800d024: 613b         	str	r3, [r7, #0x10]
 800d026: e028         	b	0x800d07a <finalize_cancel_locked+0xae> @ imm = #0x50
; 		if (wc->work == work) {
 800d028: 697b         	ldr	r3, [r7, #0x14]
 800d02a: 685b         	ldr	r3, [r3, #0x4]
 800d02c: 687a         	ldr	r2, [r7, #0x4]
 800d02e: 429a         	cmp	r2, r3
 800d030: d10b         	bne	0x800d04a <finalize_cancel_locked+0x7e> @ imm = #0x16
; 			sys_slist_remove(&pending_cancels, prev, &wc->node);
 800d032: 697b         	ldr	r3, [r7, #0x14]
 800d034: 461a         	mov	r2, r3
 800d036: 68f9         	ldr	r1, [r7, #0xc]
 800d038: 4814         	ldr	r0, [pc, #0x50]         @ 0x800d08c <finalize_cancel_locked+0xc0>
 800d03a: f00c f9e8    	bl	0x801940e <sys_slist_remove> @ imm = #0xc3d0
; 			k_sem_give(&wc->sem);
 800d03e: 697b         	ldr	r3, [r7, #0x14]
 800d040: 3308         	adds	r3, #0x8
 800d042: 4618         	mov	r0, r3
 800d044: f00c fa8d    	bl	0x8019562 <k_sem_give>  @ imm = #0xc51a
; 			break;
 800d048: e01b         	b	0x800d082 <finalize_cancel_locked+0xb6> @ imm = #0x36
; 		prev = &wc->node;
 800d04a: 697b         	ldr	r3, [r7, #0x14]
 800d04c: 60fb         	str	r3, [r7, #0xc]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 800d04e: 693b         	ldr	r3, [r7, #0x10]
 800d050: 617b         	str	r3, [r7, #0x14]
 800d052: 697b         	ldr	r3, [r7, #0x14]
 800d054: 2b00         	cmp	r3, #0x0
 800d056: d00e         	beq	0x800d076 <finalize_cancel_locked+0xaa> @ imm = #0x1c
 800d058: 697b         	ldr	r3, [r7, #0x14]
 800d05a: 4618         	mov	r0, r3
 800d05c: f00c f967    	bl	0x801932e <sys_slist_peek_next> @ imm = #0xc2ce
 800d060: 4603         	mov	r3, r0
 800d062: 2b00         	cmp	r3, #0x0
 800d064: d005         	beq	0x800d072 <finalize_cancel_locked+0xa6> @ imm = #0xa
 800d066: 697b         	ldr	r3, [r7, #0x14]
 800d068: 4618         	mov	r0, r3
 800d06a: f00c f960    	bl	0x801932e <sys_slist_peek_next> @ imm = #0xc2c0
 800d06e: 4603         	mov	r3, r0
 800d070: e002         	b	0x800d078 <finalize_cancel_locked+0xac> @ imm = #0x4
 800d072: 2300         	movs	r3, #0x0
 800d074: e000         	b	0x800d078 <finalize_cancel_locked+0xac> @ imm = #0x0
 800d076: 2300         	movs	r3, #0x0
 800d078: 613b         	str	r3, [r7, #0x10]
 800d07a: 697b         	ldr	r3, [r7, #0x14]
 800d07c: 2b00         	cmp	r3, #0x0
 800d07e: d1d3         	bne	0x800d028 <finalize_cancel_locked+0x5c> @ imm = #-0x5a
; }
 800d080: bf00         	nop
 800d082: bf00         	nop
 800d084: 3718         	adds	r7, #0x18
 800d086: 46bd         	mov	sp, r7
 800d088: bd80         	pop	{r7, pc}
 800d08a: bf00         	nop

0800d08c <$d>:
 800d08c: 24 11 00 20  	.word	0x20001124

0800d090 <k_work_busy_get>:
; {
 800d090: b580         	push	{r7, lr}
 800d092: b090         	sub	sp, #0x40
 800d094: af00         	add	r7, sp, #0x0
 800d096: 6078         	str	r0, [r7, #0x4]
 800d098: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800d100 <k_work_busy_get+0x70>
 800d09a: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d09c: f3ef 8311    	mrs	r3, basepri
 800d0a0: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 800d0a2: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 800d0a4: 627b         	str	r3, [r7, #0x24]
 800d0a6: 2310         	movs	r3, #0x10
 800d0a8: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d0aa: 6a3b         	ldr	r3, [r7, #0x20]
 800d0ac: f383 8812    	msr	basepri_max, r3
; }
 800d0b0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d0b2: f3bf 8f6f    	isb	sy
; }
 800d0b6: bf00         	nop
; 	return key;
 800d0b8: 6a7b         	ldr	r3, [r7, #0x24]
; 	k.key = arch_irq_lock();
 800d0ba: 613b         	str	r3, [r7, #0x10]
 800d0bc: 6afb         	ldr	r3, [r7, #0x2c]
 800d0be: 61fb         	str	r3, [r7, #0x1c]
; }
 800d0c0: bf00         	nop
 800d0c2: 6afb         	ldr	r3, [r7, #0x2c]
 800d0c4: 61bb         	str	r3, [r7, #0x18]
; }
 800d0c6: bf00         	nop
; 	return k;
 800d0c8: 693b         	ldr	r3, [r7, #0x10]
 800d0ca: 617b         	str	r3, [r7, #0x14]
; 	int ret = work_busy_get_locked(work);
 800d0cc: 6878         	ldr	r0, [r7, #0x4]
 800d0ce: f00c fb1c    	bl	0x801970a <work_busy_get_locked> @ imm = #0xc638
 800d0d2: 63f8         	str	r0, [r7, #0x3c]
 800d0d4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800d100 <k_work_busy_get+0x70>
 800d0d6: 63bb         	str	r3, [r7, #0x38]
 800d0d8: 697b         	ldr	r3, [r7, #0x14]
 800d0da: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800d0dc: 68fb         	ldr	r3, [r7, #0xc]
 800d0de: 637b         	str	r3, [r7, #0x34]
 800d0e0: 6b7b         	ldr	r3, [r7, #0x34]
 800d0e2: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d0e4: 6b3b         	ldr	r3, [r7, #0x30]
 800d0e6: f383 8811    	msr	basepri, r3
; }
 800d0ea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d0ec: f3bf 8f6f    	isb	sy
; }
 800d0f0: bf00         	nop
; }
 800d0f2: bf00         	nop
; }
 800d0f4: bf00         	nop
; 	return ret;
 800d0f6: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 800d0f8: 4618         	mov	r0, r3
 800d0fa: 3740         	adds	r7, #0x40
 800d0fc: 46bd         	mov	sp, r7
 800d0fe: bd80         	pop	{r7, pc}

0800d100 <$d>:
 800d100: 24 11 00 20  	.word	0x20001124

0800d104 <queue_submit_locked>:
; {
 800d104: b580         	push	{r7, lr}
 800d106: b086         	sub	sp, #0x18
 800d108: af00         	add	r7, sp, #0x0
 800d10a: 6078         	str	r0, [r7, #0x4]
 800d10c: 6039         	str	r1, [r7]
; 	if (queue == NULL) {
 800d10e: 687b         	ldr	r3, [r7, #0x4]
 800d110: 2b00         	cmp	r3, #0x0
 800d112: d102         	bne	0x800d11a <queue_submit_locked+0x16> @ imm = #0x4
; 		return -EINVAL;
 800d114: f06f 0315    	mvn	r3, #0x15
 800d118: e05d         	b	0x800d1d6 <queue_submit_locked+0xd2> @ imm = #0xba
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800d11a: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800d1e0 <queue_submit_locked+0xdc>
 800d11c: 689b         	ldr	r3, [r3, #0x8]
 800d11e: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800d120: 68fa         	ldr	r2, [r7, #0xc]
; 	bool chained = (arch_current_thread() == &queue->thread) && !k_is_in_isr();
 800d122: 687b         	ldr	r3, [r7, #0x4]
 800d124: 429a         	cmp	r2, r3
 800d126: d109         	bne	0x800d13c <queue_submit_locked+0x38> @ imm = #0x12
 800d128: f00c fcc4    	bl	0x8019ab4 <k_is_in_isr> @ imm = #0xc988
 800d12c: 4603         	mov	r3, r0
 800d12e: f083 0301    	eor	r3, r3, #0x1
 800d132: b2db         	uxtb	r3, r3
 800d134: 2b00         	cmp	r3, #0x0
 800d136: d001         	beq	0x800d13c <queue_submit_locked+0x38> @ imm = #0x2
 800d138: 2301         	movs	r3, #0x1
 800d13a: e000         	b	0x800d13e <queue_submit_locked+0x3a> @ imm = #0x0
 800d13c: 2300         	movs	r3, #0x0
 800d13e: 74fb         	strb	r3, [r7, #0x13]
 800d140: 7cfb         	ldrb	r3, [r7, #0x13]
 800d142: f003 0301    	and	r3, r3, #0x1
 800d146: 74fb         	strb	r3, [r7, #0x13]
; 	bool draining = flag_test(&queue->flags, K_WORK_QUEUE_DRAIN_BIT);
 800d148: 687b         	ldr	r3, [r7, #0x4]
 800d14a: 33e8         	adds	r3, #0xe8
 800d14c: 2102         	movs	r1, #0x2
 800d14e: 4618         	mov	r0, r3
 800d150: f00c fa82    	bl	0x8019658 <flag_test>   @ imm = #0xc504
 800d154: 4603         	mov	r3, r0
 800d156: 74bb         	strb	r3, [r7, #0x12]
; 	bool plugged = flag_test(&queue->flags, K_WORK_QUEUE_PLUGGED_BIT);
 800d158: 687b         	ldr	r3, [r7, #0x4]
 800d15a: 33e8         	adds	r3, #0xe8
 800d15c: 2103         	movs	r1, #0x3
 800d15e: 4618         	mov	r0, r3
 800d160: f00c fa7a    	bl	0x8019658 <flag_test>   @ imm = #0xc4f4
 800d164: 4603         	mov	r3, r0
 800d166: 747b         	strb	r3, [r7, #0x11]
; 	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
 800d168: 687b         	ldr	r3, [r7, #0x4]
 800d16a: 33e8         	adds	r3, #0xe8
 800d16c: 2100         	movs	r1, #0x0
 800d16e: 4618         	mov	r0, r3
 800d170: f00c fa72    	bl	0x8019658 <flag_test>   @ imm = #0xc4e4
 800d174: 4603         	mov	r3, r0
 800d176: f083 0301    	eor	r3, r3, #0x1
 800d17a: b2db         	uxtb	r3, r3
 800d17c: 2b00         	cmp	r3, #0x0
 800d17e: d003         	beq	0x800d188 <queue_submit_locked+0x84> @ imm = #0x6
; 		ret = -ENODEV;
 800d180: f06f 0312    	mvn	r3, #0x12
 800d184: 617b         	str	r3, [r7, #0x14]
 800d186: e025         	b	0x800d1d4 <queue_submit_locked+0xd0> @ imm = #0x4a
; 	} else if (draining && !chained) {
 800d188: 7cbb         	ldrb	r3, [r7, #0x12]
 800d18a: 2b00         	cmp	r3, #0x0
 800d18c: d009         	beq	0x800d1a2 <queue_submit_locked+0x9e> @ imm = #0x12
 800d18e: 7cfb         	ldrb	r3, [r7, #0x13]
 800d190: f083 0301    	eor	r3, r3, #0x1
 800d194: b2db         	uxtb	r3, r3
 800d196: 2b00         	cmp	r3, #0x0
 800d198: d003         	beq	0x800d1a2 <queue_submit_locked+0x9e> @ imm = #0x6
; 		ret = -EBUSY;
 800d19a: f06f 030f    	mvn	r3, #0xf
 800d19e: 617b         	str	r3, [r7, #0x14]
 800d1a0: e018         	b	0x800d1d4 <queue_submit_locked+0xd0> @ imm = #0x30
; 	} else if (plugged && !draining) {
 800d1a2: 7c7b         	ldrb	r3, [r7, #0x11]
 800d1a4: 2b00         	cmp	r3, #0x0
 800d1a6: d009         	beq	0x800d1bc <queue_submit_locked+0xb8> @ imm = #0x12
 800d1a8: 7cbb         	ldrb	r3, [r7, #0x12]
 800d1aa: f083 0301    	eor	r3, r3, #0x1
 800d1ae: b2db         	uxtb	r3, r3
 800d1b0: 2b00         	cmp	r3, #0x0
 800d1b2: d003         	beq	0x800d1bc <queue_submit_locked+0xb8> @ imm = #0x6
; 		ret = -EBUSY;
 800d1b4: f06f 030f    	mvn	r3, #0xf
 800d1b8: 617b         	str	r3, [r7, #0x14]
 800d1ba: e00b         	b	0x800d1d4 <queue_submit_locked+0xd0> @ imm = #0x16
; 		sys_slist_append(&queue->pending, &work->node);
 800d1bc: 687b         	ldr	r3, [r7, #0x4]
 800d1be: 33d0         	adds	r3, #0xd0
 800d1c0: 683a         	ldr	r2, [r7]
 800d1c2: 4611         	mov	r1, r2
 800d1c4: 4618         	mov	r0, r3
 800d1c6: f00c f8c3    	bl	0x8019350 <sys_slist_append> @ imm = #0xc186
; 		ret = 1;
 800d1ca: 2301         	movs	r3, #0x1
 800d1cc: 617b         	str	r3, [r7, #0x14]
; 		(void)notify_queue_locked(queue);
 800d1ce: 6878         	ldr	r0, [r7, #0x4]
 800d1d0: f00c fac4    	bl	0x801975c <notify_queue_locked> @ imm = #0xc588
; 	return ret;
 800d1d4: 697b         	ldr	r3, [r7, #0x14]
; }
 800d1d6: 4618         	mov	r0, r3
 800d1d8: 3718         	adds	r7, #0x18
 800d1da: 46bd         	mov	sp, r7
 800d1dc: bd80         	pop	{r7, pc}
 800d1de: bf00         	nop

0800d1e0 <$d>:
 800d1e0: 30 07 00 20  	.word	0x20000730

0800d1e4 <z_work_submit_to_queue>:
; {
 800d1e4: b580         	push	{r7, lr}
 800d1e6: b090         	sub	sp, #0x40
 800d1e8: af00         	add	r7, sp, #0x0
 800d1ea: 6078         	str	r0, [r7, #0x4]
 800d1ec: 6039         	str	r1, [r7]
 800d1ee: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800d25c <z_work_submit_to_queue+0x78>
 800d1f0: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d1f2: f3ef 8311    	mrs	r3, basepri
 800d1f6: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 800d1f8: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 800d1fa: 627b         	str	r3, [r7, #0x24]
 800d1fc: 2310         	movs	r3, #0x10
 800d1fe: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d200: 6a3b         	ldr	r3, [r7, #0x20]
 800d202: f383 8812    	msr	basepri_max, r3
; }
 800d206: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d208: f3bf 8f6f    	isb	sy
; }
 800d20c: bf00         	nop
; 	return key;
 800d20e: 6a7b         	ldr	r3, [r7, #0x24]
; 	k.key = arch_irq_lock();
 800d210: 613b         	str	r3, [r7, #0x10]
 800d212: 6afb         	ldr	r3, [r7, #0x2c]
 800d214: 61fb         	str	r3, [r7, #0x1c]
; }
 800d216: bf00         	nop
 800d218: 6afb         	ldr	r3, [r7, #0x2c]
 800d21a: 61bb         	str	r3, [r7, #0x18]
; }
 800d21c: bf00         	nop
; 	return k;
 800d21e: 693b         	ldr	r3, [r7, #0x10]
 800d220: 617b         	str	r3, [r7, #0x14]
; 	int ret = submit_to_queue_locked(work, &queue);
 800d222: 1d3b         	adds	r3, r7, #0x4
 800d224: 4619         	mov	r1, r3
 800d226: 6838         	ldr	r0, [r7]
 800d228: f00c faaf    	bl	0x801978a <submit_to_queue_locked> @ imm = #0xc55e
 800d22c: 63f8         	str	r0, [r7, #0x3c]
 800d22e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800d25c <z_work_submit_to_queue+0x78>
 800d230: 63bb         	str	r3, [r7, #0x38]
 800d232: 697b         	ldr	r3, [r7, #0x14]
 800d234: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800d236: 68fb         	ldr	r3, [r7, #0xc]
 800d238: 637b         	str	r3, [r7, #0x34]
 800d23a: 6b7b         	ldr	r3, [r7, #0x34]
 800d23c: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d23e: 6b3b         	ldr	r3, [r7, #0x30]
 800d240: f383 8811    	msr	basepri, r3
; }
 800d244: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d246: f3bf 8f6f    	isb	sy
; }
 800d24a: bf00         	nop
; }
 800d24c: bf00         	nop
; }
 800d24e: bf00         	nop
; 	return ret;
 800d250: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 800d252: 4618         	mov	r0, r3
 800d254: 3740         	adds	r7, #0x40
 800d256: 46bd         	mov	sp, r7
 800d258: bd80         	pop	{r7, pc}
 800d25a: bf00         	nop

0800d25c <$d>:
 800d25c: 24 11 00 20  	.word	0x20001124

0800d260 <work_queue_main>:
; {
 800d260: b580         	push	{r7, lr}
 800d262: b0a4         	sub	sp, #0x90
 800d264: af04         	add	r7, sp, #0x10
 800d266: 60f8         	str	r0, [r7, #0xc]
 800d268: 60b9         	str	r1, [r7, #0x8]
 800d26a: 607a         	str	r2, [r7, #0x4]
; 	struct k_work_q *queue = (struct k_work_q *)workq_ptr;
 800d26c: 68fb         	ldr	r3, [r7, #0xc]
 800d26e: 677b         	str	r3, [r7, #0x74]
; 		struct k_work *work = NULL;
 800d270: 2300         	movs	r3, #0x0
 800d272: 67fb         	str	r3, [r7, #0x7c]
; 		k_work_handler_t handler = NULL;
 800d274: 2300         	movs	r3, #0x0
 800d276: 67bb         	str	r3, [r7, #0x78]
 800d278: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x800d43c <work_queue_main+0x1dc>
 800d27a: 66bb         	str	r3, [r7, #0x68]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d27c: f3ef 8311    	mrs	r3, basepri
 800d280: 667b         	str	r3, [r7, #0x64]
;   return(result);
 800d282: 6e7b         	ldr	r3, [r7, #0x64]
; 	key = __get_BASEPRI();
 800d284: 663b         	str	r3, [r7, #0x60]
 800d286: 2310         	movs	r3, #0x10
 800d288: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d28a: 6dfb         	ldr	r3, [r7, #0x5c]
 800d28c: f383 8812    	msr	basepri_max, r3
; }
 800d290: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d292: f3bf 8f6f    	isb	sy
; }
 800d296: bf00         	nop
; 	return key;
 800d298: 6e3b         	ldr	r3, [r7, #0x60]
; 	k.key = arch_irq_lock();
 800d29a: 613b         	str	r3, [r7, #0x10]
 800d29c: 6ebb         	ldr	r3, [r7, #0x68]
 800d29e: 65bb         	str	r3, [r7, #0x58]
; }
 800d2a0: bf00         	nop
 800d2a2: 6ebb         	ldr	r3, [r7, #0x68]
 800d2a4: 657b         	str	r3, [r7, #0x54]
; }
 800d2a6: bf00         	nop
; 	return k;
 800d2a8: 693b         	ldr	r3, [r7, #0x10]
 800d2aa: 623b         	str	r3, [r7, #0x20]
; 		node = sys_slist_get(&queue->pending);
 800d2ac: 6f7b         	ldr	r3, [r7, #0x74]
 800d2ae: 33d0         	adds	r3, #0xd0
 800d2b0: 4618         	mov	r0, r3
 800d2b2: f00c f898    	bl	0x80193e6 <sys_slist_get> @ imm = #0xc130
 800d2b6: 6738         	str	r0, [r7, #0x70]
; 		if (node != NULL) {
 800d2b8: 6f3b         	ldr	r3, [r7, #0x70]
 800d2ba: 2b00         	cmp	r3, #0x0
 800d2bc: d017         	beq	0x800d2ee <work_queue_main+0x8e> @ imm = #0x2e
; 			flag_set(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
 800d2be: 6f7b         	ldr	r3, [r7, #0x74]
 800d2c0: 33e8         	adds	r3, #0xe8
 800d2c2: 2101         	movs	r1, #0x1
 800d2c4: 4618         	mov	r0, r3
 800d2c6: f00c f9b4    	bl	0x8019632 <flag_set>    @ imm = #0xc368
; 			work = CONTAINER_OF(node, struct k_work, node);
 800d2ca: 6f3b         	ldr	r3, [r7, #0x70]
 800d2cc: 67fb         	str	r3, [r7, #0x7c]
; 			flag_set(&work->flags, K_WORK_RUNNING_BIT);
 800d2ce: 6ffb         	ldr	r3, [r7, #0x7c]
 800d2d0: 330c         	adds	r3, #0xc
 800d2d2: 2100         	movs	r1, #0x0
 800d2d4: 4618         	mov	r0, r3
 800d2d6: f00c f9ac    	bl	0x8019632 <flag_set>    @ imm = #0xc358
; 			flag_clear(&work->flags, K_WORK_QUEUED_BIT);
 800d2da: 6ffb         	ldr	r3, [r7, #0x7c]
 800d2dc: 330c         	adds	r3, #0xc
 800d2de: 2102         	movs	r1, #0x2
 800d2e0: 4618         	mov	r0, r3
 800d2e2: f00c f992    	bl	0x801960a <flag_clear>  @ imm = #0xc324
; 			handler = work->handler;
 800d2e6: 6ffb         	ldr	r3, [r7, #0x7c]
 800d2e8: 685b         	ldr	r3, [r3, #0x4]
 800d2ea: 67bb         	str	r3, [r7, #0x78]
 800d2ec: e00f         	b	0x800d30e <work_queue_main+0xae> @ imm = #0x1e
; 		} else if (flag_test_and_clear(&queue->flags, K_WORK_QUEUE_DRAIN_BIT)) {
 800d2ee: 6f7b         	ldr	r3, [r7, #0x74]
 800d2f0: 33e8         	adds	r3, #0xe8
 800d2f2: 2102         	movs	r1, #0x2
 800d2f4: 4618         	mov	r0, r3
 800d2f6: f00c f9c5    	bl	0x8019684 <flag_test_and_clear> @ imm = #0xc38a
 800d2fa: 4603         	mov	r3, r0
 800d2fc: 2b00         	cmp	r3, #0x0
 800d2fe: d006         	beq	0x800d30e <work_queue_main+0xae> @ imm = #0xc
; 			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
 800d300: 6f7b         	ldr	r3, [r7, #0x74]
 800d302: 33e0         	adds	r3, #0xe0
 800d304: 2200         	movs	r2, #0x0
 800d306: 2101         	movs	r1, #0x1
 800d308: 4618         	mov	r0, r3
 800d30a: f00c f966    	bl	0x80195da <z_sched_wake_all> @ imm = #0xc2cc
; 		if (work == NULL) {
 800d30e: 6ffb         	ldr	r3, [r7, #0x7c]
 800d310: 2b00         	cmp	r3, #0x0
 800d312: d111         	bne	0x800d338 <work_queue_main+0xd8> @ imm = #0x22
; 			(void)z_sched_wait(&lock, key, &queue->notifyq, K_FOREVER, NULL);
 800d314: 6f7b         	ldr	r3, [r7, #0x74]
 800d316: f103 01d8    	add.w	r1, r3, #0xd8
 800d31a: f04f 32ff    	mov.w	r2, #0xffffffff
 800d31e: f04f 33ff    	mov.w	r3, #0xffffffff
 800d322: 2000         	movs	r0, #0x0
 800d324: 9002         	str	r0, [sp, #0x8]
 800d326: e9cd 2300    	strd	r2, r3, [sp]
 800d32a: 460a         	mov	r2, r1
 800d32c: 6a39         	ldr	r1, [r7, #0x20]
 800d32e: 4843         	ldr	r0, [pc, #0x10c]        @ 0x800d43c <work_queue_main+0x1dc>
 800d330: f002 f814    	bl	0x800f35c <z_sched_wait> @ imm = #0x2028
; 			continue;
 800d334: bf00         	nop
 800d336: e79b         	b	0x800d270 <work_queue_main+0x10> @ imm = #-0xca
 800d338: 4b40         	ldr	r3, [pc, #0x100]        @ 0x800d43c <work_queue_main+0x1dc>
 800d33a: 63bb         	str	r3, [r7, #0x38]
 800d33c: 6a3b         	ldr	r3, [r7, #0x20]
 800d33e: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800d340: 69bb         	ldr	r3, [r7, #0x18]
 800d342: 637b         	str	r3, [r7, #0x34]
 800d344: 6b7b         	ldr	r3, [r7, #0x34]
 800d346: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d348: 6b3b         	ldr	r3, [r7, #0x30]
 800d34a: f383 8811    	msr	basepri, r3
; }
 800d34e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d350: f3bf 8f6f    	isb	sy
; }
 800d354: bf00         	nop
; }
 800d356: bf00         	nop
; }
 800d358: bf00         	nop
; 		handler(work);
 800d35a: 6fbb         	ldr	r3, [r7, #0x78]
 800d35c: 6ff8         	ldr	r0, [r7, #0x7c]
 800d35e: 4798         	blx	r3
 800d360: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800d43c <work_queue_main+0x1dc>
 800d362: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d364: f3ef 8311    	mrs	r3, basepri
 800d368: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 800d36a: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 800d36c: 64bb         	str	r3, [r7, #0x48]
 800d36e: 2310         	movs	r3, #0x10
 800d370: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d372: 6c7b         	ldr	r3, [r7, #0x44]
 800d374: f383 8812    	msr	basepri_max, r3
; }
 800d378: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d37a: f3bf 8f6f    	isb	sy
; }
 800d37e: bf00         	nop
; 	return key;
 800d380: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 800d382: 617b         	str	r3, [r7, #0x14]
 800d384: 6d3b         	ldr	r3, [r7, #0x50]
 800d386: 643b         	str	r3, [r7, #0x40]
; }
 800d388: bf00         	nop
 800d38a: 6d3b         	ldr	r3, [r7, #0x50]
 800d38c: 63fb         	str	r3, [r7, #0x3c]
; }
 800d38e: bf00         	nop
; 	return k;
 800d390: 697b         	ldr	r3, [r7, #0x14]
 800d392: 623b         	str	r3, [r7, #0x20]
; 		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
 800d394: 6ffb         	ldr	r3, [r7, #0x7c]
 800d396: 330c         	adds	r3, #0xc
 800d398: 2100         	movs	r1, #0x0
 800d39a: 4618         	mov	r0, r3
 800d39c: f00c f935    	bl	0x801960a <flag_clear>  @ imm = #0xc26a
; 		if (flag_test(&work->flags, K_WORK_FLUSHING_BIT)) {
 800d3a0: 6ffb         	ldr	r3, [r7, #0x7c]
 800d3a2: 330c         	adds	r3, #0xc
 800d3a4: 2104         	movs	r1, #0x4
 800d3a6: 4618         	mov	r0, r3
 800d3a8: f00c f956    	bl	0x8019658 <flag_test>   @ imm = #0xc2ac
 800d3ac: 4603         	mov	r3, r0
 800d3ae: 2b00         	cmp	r3, #0x0
 800d3b0: d002         	beq	0x800d3b8 <work_queue_main+0x158> @ imm = #0x4
; 			finalize_flush_locked(work);
 800d3b2: 6ff8         	ldr	r0, [r7, #0x7c]
 800d3b4: f00c f994    	bl	0x80196e0 <finalize_flush_locked> @ imm = #0xc328
; 		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 800d3b8: 6ffb         	ldr	r3, [r7, #0x7c]
 800d3ba: 330c         	adds	r3, #0xc
 800d3bc: 2101         	movs	r1, #0x1
 800d3be: 4618         	mov	r0, r3
 800d3c0: f00c f94a    	bl	0x8019658 <flag_test>   @ imm = #0xc294
 800d3c4: 4603         	mov	r3, r0
 800d3c6: 2b00         	cmp	r3, #0x0
 800d3c8: d002         	beq	0x800d3d0 <work_queue_main+0x170> @ imm = #0x4
; 			finalize_cancel_locked(work);
 800d3ca: 6ff8         	ldr	r0, [r7, #0x7c]
 800d3cc: f7ff fdfe    	bl	0x800cfcc <finalize_cancel_locked> @ imm = #-0x404
; 		flag_clear(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
 800d3d0: 6f7b         	ldr	r3, [r7, #0x74]
 800d3d2: 33e8         	adds	r3, #0xe8
 800d3d4: 2101         	movs	r1, #0x1
 800d3d6: 4618         	mov	r0, r3
 800d3d8: f00c f917    	bl	0x801960a <flag_clear>  @ imm = #0xc22e
; 		yield = !flag_test(&queue->flags, K_WORK_QUEUE_NO_YIELD_BIT);
 800d3dc: 6f7b         	ldr	r3, [r7, #0x74]
 800d3de: 33e8         	adds	r3, #0xe8
 800d3e0: 2108         	movs	r1, #0x8
 800d3e2: 4618         	mov	r0, r3
 800d3e4: f00c f938    	bl	0x8019658 <flag_test>   @ imm = #0xc270
 800d3e8: 4603         	mov	r3, r0
 800d3ea: 2b00         	cmp	r3, #0x0
 800d3ec: bf14         	ite	ne
 800d3ee: 2301         	movne	r3, #0x1
 800d3f0: 2300         	moveq	r3, #0x0
 800d3f2: b2db         	uxtb	r3, r3
 800d3f4: f083 0301    	eor	r3, r3, #0x1
 800d3f8: b2db         	uxtb	r3, r3
 800d3fa: f887 306f    	strb.w	r3, [r7, #0x6f]
 800d3fe: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800d402: f003 0301    	and	r3, r3, #0x1
 800d406: f887 306f    	strb.w	r3, [r7, #0x6f]
 800d40a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800d43c <work_queue_main+0x1dc>
 800d40c: 62fb         	str	r3, [r7, #0x2c]
 800d40e: 6a3b         	ldr	r3, [r7, #0x20]
 800d410: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 800d412: 69fb         	ldr	r3, [r7, #0x1c]
 800d414: 62bb         	str	r3, [r7, #0x28]
 800d416: 6abb         	ldr	r3, [r7, #0x28]
 800d418: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d41a: 6a7b         	ldr	r3, [r7, #0x24]
 800d41c: f383 8811    	msr	basepri, r3
; }
 800d420: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d422: f3bf 8f6f    	isb	sy
; }
 800d426: bf00         	nop
; }
 800d428: bf00         	nop
; }
 800d42a: bf00         	nop
; 		if (yield) {
 800d42c: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800d430: 2b00         	cmp	r3, #0x0
 800d432: f43f af1d    	beq.w	0x800d270 <work_queue_main+0x10> @ imm = #-0x1c6
; 			k_yield();
 800d436: f00c f875    	bl	0x8019524 <k_yield>     @ imm = #0xc0ea
; 	while (true) {
 800d43a: e719         	b	0x800d270 <work_queue_main+0x10> @ imm = #-0x1ce

0800d43c <$d>:
 800d43c: 24 11 00 20  	.word	0x20001124

0800d440 <k_work_queue_start>:
; {
 800d440: b580         	push	{r7, lr}
 800d442: b08e         	sub	sp, #0x38
 800d444: af08         	add	r7, sp, #0x20
 800d446: 60f8         	str	r0, [r7, #0xc]
 800d448: 60b9         	str	r1, [r7, #0x8]
 800d44a: 607a         	str	r2, [r7, #0x4]
 800d44c: 603b         	str	r3, [r7]
; 	uint32_t flags = K_WORK_QUEUE_STARTED;
 800d44e: 2301         	movs	r3, #0x1
 800d450: 617b         	str	r3, [r7, #0x14]
; 	sys_slist_init(&queue->pending);
 800d452: 68fb         	ldr	r3, [r7, #0xc]
 800d454: 33d0         	adds	r3, #0xd0
 800d456: 4618         	mov	r0, r3
 800d458: f00b fef5    	bl	0x8019246 <sys_slist_init> @ imm = #0xbdea
; 	z_waitq_init(&queue->notifyq);
 800d45c: 68fb         	ldr	r3, [r7, #0xc]
 800d45e: 33d8         	adds	r3, #0xd8
 800d460: 4618         	mov	r0, r3
 800d462: f00c f895    	bl	0x8019590 <z_waitq_init> @ imm = #0xc12a
; 	z_waitq_init(&queue->drainq);
 800d466: 68fb         	ldr	r3, [r7, #0xc]
 800d468: 33e0         	adds	r3, #0xe0
 800d46a: 4618         	mov	r0, r3
 800d46c: f00c f890    	bl	0x8019590 <z_waitq_init> @ imm = #0xc120
; 	if ((cfg != NULL) && cfg->no_yield) {
 800d470: 6a3b         	ldr	r3, [r7, #0x20]
 800d472: 2b00         	cmp	r3, #0x0
 800d474: d007         	beq	0x800d486 <k_work_queue_start+0x46> @ imm = #0xe
 800d476: 6a3b         	ldr	r3, [r7, #0x20]
 800d478: 791b         	ldrb	r3, [r3, #0x4]
 800d47a: 2b00         	cmp	r3, #0x0
 800d47c: d003         	beq	0x800d486 <k_work_queue_start+0x46> @ imm = #0x6
; 		flags |= K_WORK_QUEUE_NO_YIELD;
 800d47e: 697b         	ldr	r3, [r7, #0x14]
 800d480: f443 7380    	orr	r3, r3, #0x100
 800d484: 617b         	str	r3, [r7, #0x14]
; 	flags_set(&queue->flags, flags);
 800d486: 68fb         	ldr	r3, [r7, #0xc]
 800d488: 33e8         	adds	r3, #0xe8
 800d48a: 6979         	ldr	r1, [r7, #0x14]
 800d48c: 4618         	mov	r0, r3
 800d48e: f00c f90f    	bl	0x80196b0 <flags_set>   @ imm = #0xc21e
; 	(void)k_thread_create(&queue->thread, stack, stack_size, work_queue_main, queue, NULL, NULL,
 800d492: 68f8         	ldr	r0, [r7, #0xc]
; 			      prio, 0, K_FOREVER);
 800d494: f04f 32ff    	mov.w	r2, #0xffffffff
 800d498: f04f 33ff    	mov.w	r3, #0xffffffff
; 	(void)k_thread_create(&queue->thread, stack, stack_size, work_queue_main, queue, NULL, NULL,
 800d49c: e9cd 2306    	strd	r2, r3, [sp, #24]
 800d4a0: 2300         	movs	r3, #0x0
 800d4a2: 9304         	str	r3, [sp, #0x10]
 800d4a4: 683b         	ldr	r3, [r7]
 800d4a6: 9303         	str	r3, [sp, #0xc]
 800d4a8: 2300         	movs	r3, #0x0
 800d4aa: 9302         	str	r3, [sp, #0x8]
 800d4ac: 2300         	movs	r3, #0x0
 800d4ae: 9301         	str	r3, [sp, #0x4]
 800d4b0: 68fb         	ldr	r3, [r7, #0xc]
 800d4b2: 9300         	str	r3, [sp]
 800d4b4: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800d508 <k_work_queue_start+0xc8>
 800d4b6: 687a         	ldr	r2, [r7, #0x4]
 800d4b8: 68b9         	ldr	r1, [r7, #0x8]
 800d4ba: f00c f813    	bl	0x80194e4 <k_thread_create> @ imm = #0xc026
; 	if ((cfg != NULL) && (cfg->name != NULL)) {
 800d4be: 6a3b         	ldr	r3, [r7, #0x20]
 800d4c0: 2b00         	cmp	r3, #0x0
 800d4c2: d00a         	beq	0x800d4da <k_work_queue_start+0x9a> @ imm = #0x14
 800d4c4: 6a3b         	ldr	r3, [r7, #0x20]
 800d4c6: 681b         	ldr	r3, [r3]
 800d4c8: 2b00         	cmp	r3, #0x0
 800d4ca: d006         	beq	0x800d4da <k_work_queue_start+0x9a> @ imm = #0xc
; 		k_thread_name_set(&queue->thread, cfg->name);
 800d4cc: 68fa         	ldr	r2, [r7, #0xc]
 800d4ce: 6a3b         	ldr	r3, [r7, #0x20]
 800d4d0: 681b         	ldr	r3, [r3]
 800d4d2: 4619         	mov	r1, r3
 800d4d4: 4610         	mov	r0, r2
 800d4d6: f00c f836    	bl	0x8019546 <k_thread_name_set> @ imm = #0xc06c
; 	if ((cfg != NULL) && (cfg->essential)) {
 800d4da: 6a3b         	ldr	r3, [r7, #0x20]
 800d4dc: 2b00         	cmp	r3, #0x0
 800d4de: d00a         	beq	0x800d4f6 <k_work_queue_start+0xb6> @ imm = #0x14
 800d4e0: 6a3b         	ldr	r3, [r7, #0x20]
 800d4e2: 795b         	ldrb	r3, [r3, #0x5]
 800d4e4: 2b00         	cmp	r3, #0x0
 800d4e6: d006         	beq	0x800d4f6 <k_work_queue_start+0xb6> @ imm = #0xc
; 		queue->thread.base.user_options |= K_ESSENTIAL;
 800d4e8: 68fb         	ldr	r3, [r7, #0xc]
 800d4ea: 7b1b         	ldrb	r3, [r3, #0xc]
 800d4ec: f043 0301    	orr	r3, r3, #0x1
 800d4f0: b2da         	uxtb	r2, r3
 800d4f2: 68fb         	ldr	r3, [r7, #0xc]
 800d4f4: 731a         	strb	r2, [r3, #0xc]
; 	k_thread_start(&queue->thread);
 800d4f6: 68fb         	ldr	r3, [r7, #0xc]
 800d4f8: 4618         	mov	r0, r3
 800d4fa: f00b ffe8    	bl	0x80194ce <k_thread_start> @ imm = #0xbfd0
; }
 800d4fe: bf00         	nop
 800d500: 3718         	adds	r7, #0x18
 800d502: 46bd         	mov	sp, r7
 800d504: bd80         	pop	{r7, pc}
 800d506: bf00         	nop

0800d508 <$d>:
 800d508: 61 d2 00 08  	.word	0x0800d261

0800d50c <work_timeout>:
; {
 800d50c: b580         	push	{r7, lr}
 800d50e: b092         	sub	sp, #0x48
 800d510: af00         	add	r7, sp, #0x0
 800d512: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dw = CONTAINER_OF(to, struct k_work_delayable, timeout);
 800d514: 687b         	ldr	r3, [r7, #0x4]
 800d516: 3b10         	subs	r3, #0x10
 800d518: 647b         	str	r3, [r7, #0x44]
; 	struct k_work *wp = &dw->work;
 800d51a: 6c7b         	ldr	r3, [r7, #0x44]
 800d51c: 643b         	str	r3, [r7, #0x40]
 800d51e: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800d5a4 <work_timeout+0x98>
 800d520: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d522: f3ef 8311    	mrs	r3, basepri
 800d526: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800d528: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 800d52a: 637b         	str	r3, [r7, #0x34]
 800d52c: 2310         	movs	r3, #0x10
 800d52e: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d530: 6b3b         	ldr	r3, [r7, #0x30]
 800d532: f383 8812    	msr	basepri_max, r3
; }
 800d536: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d538: f3bf 8f6f    	isb	sy
; }
 800d53c: bf00         	nop
; 	return key;
 800d53e: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 800d540: 60fb         	str	r3, [r7, #0xc]
 800d542: 6bfb         	ldr	r3, [r7, #0x3c]
 800d544: 62fb         	str	r3, [r7, #0x2c]
; }
 800d546: bf00         	nop
 800d548: 6bfb         	ldr	r3, [r7, #0x3c]
 800d54a: 62bb         	str	r3, [r7, #0x28]
; }
 800d54c: bf00         	nop
; 	return k;
 800d54e: 68fb         	ldr	r3, [r7, #0xc]
 800d550: 61bb         	str	r3, [r7, #0x18]
; 	struct k_work_q *queue = NULL;
 800d552: 2300         	movs	r3, #0x0
 800d554: 617b         	str	r3, [r7, #0x14]
; 	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
 800d556: 6c3b         	ldr	r3, [r7, #0x40]
 800d558: 330c         	adds	r3, #0xc
 800d55a: 2103         	movs	r1, #0x3
 800d55c: 4618         	mov	r0, r3
 800d55e: f00c f891    	bl	0x8019684 <flag_test_and_clear> @ imm = #0xc122
 800d562: 4603         	mov	r3, r0
 800d564: 2b00         	cmp	r3, #0x0
 800d566: d008         	beq	0x800d57a <work_timeout+0x6e> @ imm = #0x10
; 		queue = dw->queue;
 800d568: 6c7b         	ldr	r3, [r7, #0x44]
 800d56a: 6a9b         	ldr	r3, [r3, #0x28]
 800d56c: 617b         	str	r3, [r7, #0x14]
; 		(void)submit_to_queue_locked(wp, &queue);
 800d56e: f107 0314    	add.w	r3, r7, #0x14
 800d572: 4619         	mov	r1, r3
 800d574: 6c38         	ldr	r0, [r7, #0x40]
 800d576: f00c f908    	bl	0x801978a <submit_to_queue_locked> @ imm = #0xc210
 800d57a: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800d5a4 <work_timeout+0x98>
 800d57c: 627b         	str	r3, [r7, #0x24]
 800d57e: 69bb         	ldr	r3, [r7, #0x18]
 800d580: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800d582: 693b         	ldr	r3, [r7, #0x10]
 800d584: 623b         	str	r3, [r7, #0x20]
 800d586: 6a3b         	ldr	r3, [r7, #0x20]
 800d588: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d58a: 69fb         	ldr	r3, [r7, #0x1c]
 800d58c: f383 8811    	msr	basepri, r3
; }
 800d590: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d592: f3bf 8f6f    	isb	sy
; }
 800d596: bf00         	nop
; }
 800d598: bf00         	nop
; }
 800d59a: bf00         	nop
; }
 800d59c: bf00         	nop
 800d59e: 3748         	adds	r7, #0x48
 800d5a0: 46bd         	mov	sp, r7
 800d5a2: bd80         	pop	{r7, pc}

0800d5a4 <$d>:
 800d5a4: 24 11 00 20  	.word	0x20001124

0800d5a8 <schedule_for_queue_locked>:
; {
 800d5a8: b580         	push	{r7, lr}
 800d5aa: b086         	sub	sp, #0x18
 800d5ac: af00         	add	r7, sp, #0x0
 800d5ae: 60f8         	str	r0, [r7, #0xc]
 800d5b0: 60b9         	str	r1, [r7, #0x8]
 800d5b2: e9c7 2300    	strd	r2, r3, [r7]
; 	int ret = 1;
 800d5b6: 2301         	movs	r3, #0x1
 800d5b8: 617b         	str	r3, [r7, #0x14]
; 	struct k_work *work = &dwork->work;
 800d5ba: 68bb         	ldr	r3, [r7, #0x8]
 800d5bc: 613b         	str	r3, [r7, #0x10]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 800d5be: e9d7 2300    	ldrd	r2, r3, [r7]
 800d5c2: f04f 0000    	mov.w	r0, #0x0
 800d5c6: f04f 0100    	mov.w	r1, #0x0
 800d5ca: 428b         	cmp	r3, r1
 800d5cc: bf08         	it	eq
 800d5ce: 4282         	cmpeq	r2, r0
 800d5d0: d105         	bne	0x800d5de <schedule_for_queue_locked+0x36> @ imm = #0xa
; 		return submit_to_queue_locked(work, queuep);
 800d5d2: 68f9         	ldr	r1, [r7, #0xc]
 800d5d4: 6938         	ldr	r0, [r7, #0x10]
 800d5d6: f00c f8d8    	bl	0x801978a <submit_to_queue_locked> @ imm = #0xc1b0
 800d5da: 4603         	mov	r3, r0
 800d5dc: e012         	b	0x800d604 <schedule_for_queue_locked+0x5c> @ imm = #0x24
; 	flag_set(&work->flags, K_WORK_DELAYED_BIT);
 800d5de: 693b         	ldr	r3, [r7, #0x10]
 800d5e0: 330c         	adds	r3, #0xc
 800d5e2: 2103         	movs	r1, #0x3
 800d5e4: 4618         	mov	r0, r3
 800d5e6: f00c f824    	bl	0x8019632 <flag_set>    @ imm = #0xc048
; 	dwork->queue = *queuep;
 800d5ea: 68fb         	ldr	r3, [r7, #0xc]
 800d5ec: 681a         	ldr	r2, [r3]
 800d5ee: 68bb         	ldr	r3, [r7, #0x8]
 800d5f0: 629a         	str	r2, [r3, #0x28]
; 	z_add_timeout(&dwork->timeout, work_timeout, delay);
 800d5f2: 68bb         	ldr	r3, [r7, #0x8]
 800d5f4: f103 0010    	add.w	r0, r3, #0x10
 800d5f8: e9d7 2300    	ldrd	r2, r3, [r7]
 800d5fc: 4903         	ldr	r1, [pc, #0xc]          @ 0x800d60c <schedule_for_queue_locked+0x64>
 800d5fe: f002 f8b3    	bl	0x800f768 <z_add_timeout> @ imm = #0x2166
; 	return ret;
 800d602: 697b         	ldr	r3, [r7, #0x14]
; }
 800d604: 4618         	mov	r0, r3
 800d606: 3718         	adds	r7, #0x18
 800d608: 46bd         	mov	sp, r7
 800d60a: bd80         	pop	{r7, pc}

0800d60c <$d>:
 800d60c: 0d d5 00 08  	.word	0x0800d50d

0800d610 <k_work_reschedule_for_queue>:
; {
 800d610: b580         	push	{r7, lr}
 800d612: b092         	sub	sp, #0x48
 800d614: af00         	add	r7, sp, #0x0
 800d616: 60f8         	str	r0, [r7, #0xc]
 800d618: 60b9         	str	r1, [r7, #0x8]
 800d61a: e9c7 2300    	strd	r2, r3, [r7]
 800d61e: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800d694 <k_work_reschedule_for_queue+0x84>
 800d620: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d622: f3ef 8311    	mrs	r3, basepri
 800d626: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800d628: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800d62a: 62fb         	str	r3, [r7, #0x2c]
 800d62c: 2310         	movs	r3, #0x10
 800d62e: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d630: 6abb         	ldr	r3, [r7, #0x28]
 800d632: f383 8812    	msr	basepri_max, r3
; }
 800d636: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d638: f3bf 8f6f    	isb	sy
; }
 800d63c: bf00         	nop
; 	return key;
 800d63e: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800d640: 61bb         	str	r3, [r7, #0x18]
 800d642: 6b7b         	ldr	r3, [r7, #0x34]
 800d644: 627b         	str	r3, [r7, #0x24]
; }
 800d646: bf00         	nop
 800d648: 6b7b         	ldr	r3, [r7, #0x34]
 800d64a: 623b         	str	r3, [r7, #0x20]
; }
 800d64c: bf00         	nop
; 	return k;
 800d64e: 69bb         	ldr	r3, [r7, #0x18]
 800d650: 61fb         	str	r3, [r7, #0x1c]
; 	(void)unschedule_locked(dwork);
 800d652: 68b8         	ldr	r0, [r7, #0x8]
 800d654: f00c f95f    	bl	0x8019916 <unschedule_locked> @ imm = #0xc2be
; 	ret = schedule_for_queue_locked(&queue, dwork, delay);
 800d658: f107 000c    	add.w	r0, r7, #0xc
 800d65c: e9d7 2300    	ldrd	r2, r3, [r7]
 800d660: 68b9         	ldr	r1, [r7, #0x8]
 800d662: f7ff ffa1    	bl	0x800d5a8 <schedule_for_queue_locked> @ imm = #-0xbe
 800d666: 6478         	str	r0, [r7, #0x44]
 800d668: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800d694 <k_work_reschedule_for_queue+0x84>
 800d66a: 643b         	str	r3, [r7, #0x40]
 800d66c: 69fb         	ldr	r3, [r7, #0x1c]
 800d66e: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 800d670: 697b         	ldr	r3, [r7, #0x14]
 800d672: 63fb         	str	r3, [r7, #0x3c]
 800d674: 6bfb         	ldr	r3, [r7, #0x3c]
 800d676: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d678: 6bbb         	ldr	r3, [r7, #0x38]
 800d67a: f383 8811    	msr	basepri, r3
; }
 800d67e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d680: f3bf 8f6f    	isb	sy
; }
 800d684: bf00         	nop
; }
 800d686: bf00         	nop
; }
 800d688: bf00         	nop
; 	return ret;
 800d68a: 6c7b         	ldr	r3, [r7, #0x44]
; }
 800d68c: 4618         	mov	r0, r3
 800d68e: 3748         	adds	r7, #0x48
 800d690: 46bd         	mov	sp, r7
 800d692: bd80         	pop	{r7, pc}

0800d694 <$d>:
 800d694: 24 11 00 20  	.word	0x20001124

0800d698 <k_work_reschedule>:
; {
 800d698: b580         	push	{r7, lr}
 800d69a: b086         	sub	sp, #0x18
 800d69c: af00         	add	r7, sp, #0x0
 800d69e: 60f8         	str	r0, [r7, #0xc]
 800d6a0: e9c7 2300    	strd	r2, r3, [r7]
; 	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
 800d6a4: e9d7 2300    	ldrd	r2, r3, [r7]
 800d6a8: 68f9         	ldr	r1, [r7, #0xc]
 800d6aa: 4804         	ldr	r0, [pc, #0x10]         @ 0x800d6bc <k_work_reschedule+0x24>
 800d6ac: f7ff ffb0    	bl	0x800d610 <k_work_reschedule_for_queue> @ imm = #-0xa0
 800d6b0: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 800d6b2: 697b         	ldr	r3, [r7, #0x14]
; }
 800d6b4: 4618         	mov	r0, r3
 800d6b6: 3718         	adds	r7, #0x18
 800d6b8: 46bd         	mov	sp, r7
 800d6ba: bd80         	pop	{r7, pc}

0800d6bc <$d>:
 800d6bc: 00 0a 00 20  	.word	0x20000a00

0800d6c0 <k_work_cancel_delayable>:
; {
 800d6c0: b580         	push	{r7, lr}
 800d6c2: b090         	sub	sp, #0x40
 800d6c4: af00         	add	r7, sp, #0x0
 800d6c6: 6078         	str	r0, [r7, #0x4]
 800d6c8: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800d730 <k_work_cancel_delayable+0x70>
 800d6ca: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d6cc: f3ef 8311    	mrs	r3, basepri
 800d6d0: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 800d6d2: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 800d6d4: 627b         	str	r3, [r7, #0x24]
 800d6d6: 2310         	movs	r3, #0x10
 800d6d8: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d6da: 6a3b         	ldr	r3, [r7, #0x20]
 800d6dc: f383 8812    	msr	basepri_max, r3
; }
 800d6e0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d6e2: f3bf 8f6f    	isb	sy
; }
 800d6e6: bf00         	nop
; 	return key;
 800d6e8: 6a7b         	ldr	r3, [r7, #0x24]
; 	k.key = arch_irq_lock();
 800d6ea: 613b         	str	r3, [r7, #0x10]
 800d6ec: 6afb         	ldr	r3, [r7, #0x2c]
 800d6ee: 61fb         	str	r3, [r7, #0x1c]
; }
 800d6f0: bf00         	nop
 800d6f2: 6afb         	ldr	r3, [r7, #0x2c]
 800d6f4: 61bb         	str	r3, [r7, #0x18]
; }
 800d6f6: bf00         	nop
; 	return k;
 800d6f8: 693b         	ldr	r3, [r7, #0x10]
 800d6fa: 617b         	str	r3, [r7, #0x14]
; 	int ret = cancel_delayable_async_locked(dwork);
 800d6fc: 6878         	ldr	r0, [r7, #0x4]
 800d6fe: f00c f92b    	bl	0x8019958 <cancel_delayable_async_locked> @ imm = #0xc256
 800d702: 63f8         	str	r0, [r7, #0x3c]
 800d704: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800d730 <k_work_cancel_delayable+0x70>
 800d706: 63bb         	str	r3, [r7, #0x38]
 800d708: 697b         	ldr	r3, [r7, #0x14]
 800d70a: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800d70c: 68fb         	ldr	r3, [r7, #0xc]
 800d70e: 637b         	str	r3, [r7, #0x34]
 800d710: 6b7b         	ldr	r3, [r7, #0x34]
 800d712: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d714: 6b3b         	ldr	r3, [r7, #0x30]
 800d716: f383 8811    	msr	basepri, r3
; }
 800d71a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d71c: f3bf 8f6f    	isb	sy
; }
 800d720: bf00         	nop
; }
 800d722: bf00         	nop
; }
 800d724: bf00         	nop
; 	return ret;
 800d726: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 800d728: 4618         	mov	r0, r3
 800d72a: 3740         	adds	r7, #0x40
 800d72c: 46bd         	mov	sp, r7
 800d72e: bd80         	pop	{r7, pc}

0800d730 <$d>:
 800d730: 24 11 00 20  	.word	0x20001124

0800d734 <z_add_thread_timeout>:
; {
 800d734: b580         	push	{r7, lr}
 800d736: b084         	sub	sp, #0x10
 800d738: af00         	add	r7, sp, #0x0
 800d73a: 60f8         	str	r0, [r7, #0xc]
 800d73c: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 800d740: 68fb         	ldr	r3, [r7, #0xc]
 800d742: f103 0018    	add.w	r0, r3, #0x18
 800d746: e9d7 2300    	ldrd	r2, r3, [r7]
 800d74a: 4903         	ldr	r1, [pc, #0xc]          @ 0x800d758 <z_add_thread_timeout+0x24>
 800d74c: f002 f80c    	bl	0x800f768 <z_add_timeout> @ imm = #0x2018
; }
 800d750: bf00         	nop
 800d752: 3710         	adds	r7, #0x10
 800d754: 46bd         	mov	sp, r7
 800d756: bd80         	pop	{r7, pc}

0800d758 <$d>:
 800d758: 13 a2 01 08  	.word	0x0801a213

0800d75c <z_impl_k_thread_name_set>:
; {
 800d75c: b580         	push	{r7, lr}
 800d75e: b084         	sub	sp, #0x10
 800d760: af00         	add	r7, sp, #0x0
 800d762: 6078         	str	r0, [r7, #0x4]
 800d764: 6039         	str	r1, [r7]
; 	if (thread == NULL) {
 800d766: 687b         	ldr	r3, [r7, #0x4]
 800d768: 2b00         	cmp	r3, #0x0
 800d76a: d104         	bne	0x800d776 <z_impl_k_thread_name_set+0x1a> @ imm = #0x8
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800d76c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800d798 <z_impl_k_thread_name_set+0x3c>
 800d76e: 689b         	ldr	r3, [r3, #0x8]
 800d770: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800d772: 68fb         	ldr	r3, [r7, #0xc]
; 		thread = arch_current_thread();
 800d774: 607b         	str	r3, [r7, #0x4]
; 	strncpy(thread->name, str, CONFIG_THREAD_MAX_NAME_LEN - 1);
 800d776: 687b         	ldr	r3, [r7, #0x4]
 800d778: 3394         	adds	r3, #0x94
 800d77a: 221f         	movs	r2, #0x1f
 800d77c: 6839         	ldr	r1, [r7]
 800d77e: 4618         	mov	r0, r3
 800d780: f00d f85e    	bl	0x801a840 <strncpy>     @ imm = #0xd0bc
; 	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 800d784: 687b         	ldr	r3, [r7, #0x4]
 800d786: 2200         	movs	r2, #0x0
 800d788: f883 20b3    	strb.w	r2, [r3, #0xb3]
; 	return 0;
 800d78c: 2300         	movs	r3, #0x0
; }
 800d78e: 4618         	mov	r0, r3
 800d790: 3710         	adds	r7, #0x10
 800d792: 46bd         	mov	sp, r7
 800d794: bd80         	pop	{r7, pc}
 800d796: bf00         	nop

0800d798 <$d>:
 800d798: 30 07 00 20  	.word	0x20000730

0800d79c <setup_thread_stack>:
; {
 800d79c: b580         	push	{r7, lr}
 800d79e: b096         	sub	sp, #0x58
 800d7a0: af0a         	add	r7, sp, #0x28
 800d7a2: 60f8         	str	r0, [r7, #0xc]
 800d7a4: 60b9         	str	r1, [r7, #0x8]
 800d7a6: 607a         	str	r2, [r7, #0x4]
; 	size_t delta = 0;
 800d7a8: 2300         	movs	r3, #0x0
 800d7aa: 62fb         	str	r3, [r7, #0x2c]
; 		stack_obj_size = K_KERNEL_STACK_LEN(stack_size);
 800d7ac: 687b         	ldr	r3, [r7, #0x4]
 800d7ae: 3307         	adds	r3, #0x7
 800d7b0: f023 0307    	bic	r3, r3, #0x7
 800d7b4: 3307         	adds	r3, #0x7
 800d7b6: f023 0307    	bic	r3, r3, #0x7
 800d7ba: 62bb         	str	r3, [r7, #0x28]
; 		stack_buf_start = K_KERNEL_STACK_BUFFER(stack);
 800d7bc: 68b8         	ldr	r0, [r7, #0x8]
 800d7be: f00c f8f9    	bl	0x80199b4 <K_KERNEL_STACK_BUFFER> @ imm = #0xc1f2
 800d7c2: 6278         	str	r0, [r7, #0x24]
; 		stack_buf_size = stack_obj_size - K_KERNEL_STACK_RESERVED;
 800d7c4: 6abb         	ldr	r3, [r7, #0x28]
 800d7c6: 623b         	str	r3, [r7, #0x20]
; 	stack_ptr = (char *)stack + stack_obj_size;
 800d7c8: 68ba         	ldr	r2, [r7, #0x8]
 800d7ca: 6abb         	ldr	r3, [r7, #0x28]
 800d7cc: 4413         	add	r3, r2
 800d7ce: 61fb         	str	r3, [r7, #0x1c]
; 	LOG_DBG("stack %p for thread %p: obj_size=%zu buf_start=%p "
 800d7d0: 2303         	movs	r3, #0x3
 800d7d2: 2b03         	cmp	r3, #0x3
 800d7d4: d924         	bls	0x800d820 <setup_thread_stack+0x84> @ imm = #0x48
 800d7d6: 2301         	movs	r3, #0x1
 800d7d8: 76fb         	strb	r3, [r7, #0x1b]
 800d7da: 7efb         	ldrb	r3, [r7, #0x1b]
 800d7dc: f083 0301    	eor	r3, r3, #0x1
 800d7e0: b2db         	uxtb	r3, r3
 800d7e2: 2b00         	cmp	r3, #0x0
 800d7e4: d11c         	bne	0x800d820 <setup_thread_stack+0x84> @ imm = #0x38
 800d7e6: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800d870 <setup_thread_stack+0xd4>
 800d7e8: 6819         	ldr	r1, [r3]
 800d7ea: 69fb         	ldr	r3, [r7, #0x1c]
 800d7ec: 9309         	str	r3, [sp, #0x24]
 800d7ee: 6a3b         	ldr	r3, [r7, #0x20]
 800d7f0: 9308         	str	r3, [sp, #0x20]
 800d7f2: 6a7b         	ldr	r3, [r7, #0x24]
 800d7f4: 9307         	str	r3, [sp, #0x1c]
 800d7f6: 6abb         	ldr	r3, [r7, #0x28]
 800d7f8: 9306         	str	r3, [sp, #0x18]
 800d7fa: 68fb         	ldr	r3, [r7, #0xc]
 800d7fc: 9305         	str	r3, [sp, #0x14]
 800d7fe: 68bb         	ldr	r3, [r7, #0x8]
 800d800: 9304         	str	r3, [sp, #0x10]
 800d802: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800d874 <setup_thread_stack+0xd8>
 800d804: 9303         	str	r3, [sp, #0xc]
 800d806: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800d878 <setup_thread_stack+0xdc>
 800d808: 9302         	str	r3, [sp, #0x8]
 800d80a: 2308         	movs	r3, #0x8
 800d80c: 9301         	str	r3, [sp, #0x4]
 800d80e: 2300         	movs	r3, #0x0
 800d810: 9300         	str	r3, [sp]
 800d812: 2300         	movs	r3, #0x0
 800d814: 2204         	movs	r2, #0x4
 800d816: 2000         	movs	r0, #0x0
 800d818: f00c f92e    	bl	0x8019a78 <z_log_msg_runtime_create> @ imm = #0xc25c
 800d81c: 2300         	movs	r3, #0x0
 800d81e: 617b         	str	r3, [r7, #0x14]
; 	memset(stack_buf_start, 0xaa, stack_buf_size);
 800d820: 6a3a         	ldr	r2, [r7, #0x20]
 800d822: 21aa         	movs	r1, #0xaa
 800d824: 6a78         	ldr	r0, [r7, #0x24]
 800d826: f00d f803    	bl	0x801a830 <memset>      @ imm = #0xd006
; 	delta += arch_tls_stack_setup(new_thread, stack_ptr);
 800d82a: 69f9         	ldr	r1, [r7, #0x1c]
 800d82c: 68f8         	ldr	r0, [r7, #0xc]
 800d82e: f005 f914    	bl	0x8012a5a <arch_tls_stack_setup> @ imm = #0x5228
 800d832: 4602         	mov	r2, r0
 800d834: 6afb         	ldr	r3, [r7, #0x2c]
 800d836: 4413         	add	r3, r2
 800d838: 62fb         	str	r3, [r7, #0x2c]
; 	delta = ROUND_UP(delta, ARCH_STACK_PTR_ALIGN);
 800d83a: 6afb         	ldr	r3, [r7, #0x2c]
 800d83c: 3307         	adds	r3, #0x7
 800d83e: f023 0307    	bic	r3, r3, #0x7
 800d842: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
 800d844: 6a7a         	ldr	r2, [r7, #0x24]
 800d846: 68fb         	ldr	r3, [r7, #0xc]
 800d848: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	new_thread->stack_info.size = stack_buf_size;
 800d84c: 68fb         	ldr	r3, [r7, #0xc]
 800d84e: 6a3a         	ldr	r2, [r7, #0x20]
 800d850: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	new_thread->stack_info.delta = delta;
 800d854: 68fb         	ldr	r3, [r7, #0xc]
 800d856: 6afa         	ldr	r2, [r7, #0x2c]
 800d858: f8c3 20bc    	str.w	r2, [r3, #0xbc]
; 	stack_ptr -= delta;
 800d85c: 6afb         	ldr	r3, [r7, #0x2c]
 800d85e: 425b         	rsbs	r3, r3, #0
 800d860: 69fa         	ldr	r2, [r7, #0x1c]
 800d862: 4413         	add	r3, r2
 800d864: 61fb         	str	r3, [r7, #0x1c]
; 	return stack_ptr;
 800d866: 69fb         	ldr	r3, [r7, #0x1c]
; }
 800d868: 4618         	mov	r0, r3
 800d86a: 3730         	adds	r7, #0x30
 800d86c: 46bd         	mov	sp, r7
 800d86e: bd80         	pop	{r7, pc}

0800d870 <$d>:
 800d870: 58 05 00 20  	.word	0x20000558
 800d874: d4 d8 01 08  	.word	0x0801d8d4
 800d878: 48 cc 01 08  	.word	0x0801cc48

0800d87c <z_setup_new_thread>:
; {
 800d87c: b580         	push	{r7, lr}
 800d87e: b09c         	sub	sp, #0x70
 800d880: af04         	add	r7, sp, #0x10
 800d882: 60f8         	str	r0, [r7, #0xc]
 800d884: 60b9         	str	r1, [r7, #0x8]
 800d886: 607a         	str	r2, [r7, #0x4]
 800d888: 603b         	str	r3, [r7]
; 	z_waitq_init(&new_thread->join_queue);
 800d88a: 68fb         	ldr	r3, [r7, #0xc]
 800d88c: 3368         	adds	r3, #0x68
 800d88e: 4618         	mov	r0, r3
 800d890: f00c f8e6    	bl	0x8019a60 <z_waitq_init> @ imm = #0xc1cc
; 	z_init_thread_base(&new_thread->base, prio, _THREAD_SUSPENDED, options);
 800d894: 68f8         	ldr	r0, [r7, #0xc]
 800d896: 6fbb         	ldr	r3, [r7, #0x78]
 800d898: 2210         	movs	r2, #0x10
 800d89a: 6f79         	ldr	r1, [r7, #0x74]
 800d89c: f00c f953    	bl	0x8019b46 <z_init_thread_base> @ imm = #0xc2a6
; 	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
 800d8a0: 687a         	ldr	r2, [r7, #0x4]
 800d8a2: 68b9         	ldr	r1, [r7, #0x8]
 800d8a4: 68f8         	ldr	r0, [r7, #0xc]
 800d8a6: f7ff ff79    	bl	0x800d79c <setup_thread_stack> @ imm = #-0x10e
 800d8aa: 65f8         	str	r0, [r7, #0x5c]
; 	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 800d8ac: 6f3b         	ldr	r3, [r7, #0x70]
 800d8ae: 9302         	str	r3, [sp, #0x8]
 800d8b0: 6efb         	ldr	r3, [r7, #0x6c]
 800d8b2: 9301         	str	r3, [sp, #0x4]
 800d8b4: 6ebb         	ldr	r3, [r7, #0x68]
 800d8b6: 9300         	str	r3, [sp]
 800d8b8: 683b         	ldr	r3, [r7]
 800d8ba: 6dfa         	ldr	r2, [r7, #0x5c]
 800d8bc: 68b9         	ldr	r1, [r7, #0x8]
 800d8be: 68f8         	ldr	r0, [r7, #0xc]
 800d8c0: f7f5 fe9e    	bl	0x8003600 <arch_new_thread> @ imm = #-0xa2c4
; 	new_thread->init_data = NULL;
 800d8c4: 68fb         	ldr	r3, [r7, #0xc]
 800d8c6: 2200         	movs	r2, #0x0
 800d8c8: 665a         	str	r2, [r3, #0x64]
; 	new_thread->no_wake_on_timeout = false;
 800d8ca: 68fb         	ldr	r3, [r7, #0xc]
 800d8cc: 2200         	movs	r2, #0x0
 800d8ce: f883 207c    	strb.w	r2, [r3, #0x7c]
; 	new_thread->entry.pEntry = entry;
 800d8d2: 68fb         	ldr	r3, [r7, #0xc]
 800d8d4: 683a         	ldr	r2, [r7]
 800d8d6: f8c3 2080    	str.w	r2, [r3, #0x80]
; 	new_thread->entry.parameter1 = p1;
 800d8da: 68fb         	ldr	r3, [r7, #0xc]
 800d8dc: 6eba         	ldr	r2, [r7, #0x68]
 800d8de: f8c3 2084    	str.w	r2, [r3, #0x84]
; 	new_thread->entry.parameter2 = p2;
 800d8e2: 68fb         	ldr	r3, [r7, #0xc]
 800d8e4: 6efa         	ldr	r2, [r7, #0x6c]
 800d8e6: f8c3 2088    	str.w	r2, [r3, #0x88]
; 	new_thread->entry.parameter3 = p3;
 800d8ea: 68fb         	ldr	r3, [r7, #0xc]
 800d8ec: 6f3a         	ldr	r2, [r7, #0x70]
 800d8ee: f8c3 208c    	str.w	r2, [r3, #0x8c]
 800d8f2: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800d9c8 <z_setup_new_thread+0x14c>
 800d8f4: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d8f6: f3ef 8311    	mrs	r3, basepri
 800d8fa: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800d8fc: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 800d8fe: 647b         	str	r3, [r7, #0x44]
 800d900: 2310         	movs	r3, #0x10
 800d902: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d904: 6c3b         	ldr	r3, [r7, #0x40]
 800d906: f383 8812    	msr	basepri_max, r3
; }
 800d90a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d90c: f3bf 8f6f    	isb	sy
; }
 800d910: bf00         	nop
; 	return key;
 800d912: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 800d914: 617b         	str	r3, [r7, #0x14]
 800d916: 6cfb         	ldr	r3, [r7, #0x4c]
 800d918: 63fb         	str	r3, [r7, #0x3c]
; }
 800d91a: bf00         	nop
 800d91c: 6cfb         	ldr	r3, [r7, #0x4c]
 800d91e: 63bb         	str	r3, [r7, #0x38]
; }
 800d920: bf00         	nop
; 	return k;
 800d922: 697b         	ldr	r3, [r7, #0x14]
 800d924: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->next_thread = _kernel.threads;
 800d926: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800d9cc <z_setup_new_thread+0x150>
 800d928: 6a9a         	ldr	r2, [r3, #0x28]
 800d92a: 68fb         	ldr	r3, [r7, #0xc]
 800d92c: f8c3 2090    	str.w	r2, [r3, #0x90]
; 	_kernel.threads = new_thread;
 800d930: 4a26         	ldr	r2, [pc, #0x98]         @ 0x800d9cc <z_setup_new_thread+0x150>
 800d932: 68fb         	ldr	r3, [r7, #0xc]
 800d934: 6293         	str	r3, [r2, #0x28]
 800d936: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800d9c8 <z_setup_new_thread+0x14c>
 800d938: 65bb         	str	r3, [r7, #0x58]
 800d93a: 6afb         	ldr	r3, [r7, #0x2c]
 800d93c: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800d93e: 693b         	ldr	r3, [r7, #0x10]
 800d940: 657b         	str	r3, [r7, #0x54]
 800d942: 6d7b         	ldr	r3, [r7, #0x54]
 800d944: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d946: 6d3b         	ldr	r3, [r7, #0x50]
 800d948: f383 8811    	msr	basepri, r3
; }
 800d94c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d94e: f3bf 8f6f    	isb	sy
; }
 800d952: bf00         	nop
; }
 800d954: bf00         	nop
; }
 800d956: bf00         	nop
; 	if (name != NULL) {
 800d958: 6ffb         	ldr	r3, [r7, #0x7c]
 800d95a: 2b00         	cmp	r3, #0x0
 800d95c: d00b         	beq	0x800d976 <z_setup_new_thread+0xfa> @ imm = #0x16
; 		strncpy(new_thread->name, name,
 800d95e: 68fb         	ldr	r3, [r7, #0xc]
 800d960: 3394         	adds	r3, #0x94
 800d962: 221f         	movs	r2, #0x1f
 800d964: 6ff9         	ldr	r1, [r7, #0x7c]
 800d966: 4618         	mov	r0, r3
 800d968: f00c ff6a    	bl	0x801a840 <strncpy>     @ imm = #0xced4
; 		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 800d96c: 68fb         	ldr	r3, [r7, #0xc]
 800d96e: 2200         	movs	r2, #0x0
 800d970: f883 20b3    	strb.w	r2, [r3, #0xb3]
 800d974: e003         	b	0x800d97e <z_setup_new_thread+0x102> @ imm = #0x6
; 		new_thread->name[0] = '\0';
 800d976: 68fb         	ldr	r3, [r7, #0xc]
 800d978: 2200         	movs	r2, #0x0
 800d97a: f883 2094    	strb.w	r2, [r3, #0x94]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800d97e: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800d9cc <z_setup_new_thread+0x150>
 800d980: 689b         	ldr	r3, [r3, #0x8]
 800d982: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 800d984: 6b7b         	ldr	r3, [r7, #0x34]
; 	if (!arch_current_thread()) {
 800d986: 2b00         	cmp	r3, #0x0
 800d988: d105         	bne	0x800d996 <z_setup_new_thread+0x11a> @ imm = #0xa
; 		new_thread->resource_pool = NULL;
 800d98a: 68fb         	ldr	r3, [r7, #0xc]
 800d98c: 2200         	movs	r2, #0x0
 800d98e: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 		return stack_ptr;
 800d992: 6dfb         	ldr	r3, [r7, #0x5c]
 800d994: e014         	b	0x800d9c0 <z_setup_new_thread+0x144> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800d996: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800d9cc <z_setup_new_thread+0x150>
 800d998: 689b         	ldr	r3, [r3, #0x8]
 800d99a: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 800d99c: 6b3b         	ldr	r3, [r7, #0x30]
; 	new_thread->resource_pool = arch_current_thread()->resource_pool;
 800d99e: f8d3 20c0    	ldr.w	r2, [r3, #0xc0]
 800d9a2: 68fb         	ldr	r3, [r7, #0xc]
 800d9a4: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 	new_thread->base.usage = (struct k_cycle_stats) {};
 800d9a8: 68fb         	ldr	r3, [r7, #0xc]
 800d9aa: 3330         	adds	r3, #0x30
 800d9ac: 2200         	movs	r2, #0x0
 800d9ae: 601a         	str	r2, [r3]
 800d9b0: 605a         	str	r2, [r3, #0x4]
 800d9b2: 609a         	str	r2, [r3, #0x8]
 800d9b4: 60da         	str	r2, [r3, #0xc]
; 	new_thread->base.usage.track_usage =
 800d9b6: 68fb         	ldr	r3, [r7, #0xc]
 800d9b8: 2201         	movs	r2, #0x1
 800d9ba: f883 2038    	strb.w	r2, [r3, #0x38]
; 	return stack_ptr;
 800d9be: 6dfb         	ldr	r3, [r7, #0x5c]
; }
 800d9c0: 4618         	mov	r0, r3
 800d9c2: 3760         	adds	r7, #0x60
 800d9c4: 46bd         	mov	sp, r7
 800d9c6: bd80         	pop	{r7, pc}

0800d9c8 <$d>:
 800d9c8: 3c 11 00 20  	.word	0x2000113c
 800d9cc: 30 07 00 20  	.word	0x20000730

0800d9d0 <z_thread_mark_switched_in>:
; {
 800d9d0: b580         	push	{r7, lr}
 800d9d2: b082         	sub	sp, #0x8
 800d9d4: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800d9d6: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800d9ec <z_thread_mark_switched_in+0x1c>
 800d9d8: 689b         	ldr	r3, [r3, #0x8]
 800d9da: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 800d9dc: 687b         	ldr	r3, [r7, #0x4]
; 	z_sched_usage_start(arch_current_thread());
 800d9de: 4618         	mov	r0, r3
 800d9e0: f002 fb22    	bl	0x8010028 <z_sched_usage_start> @ imm = #0x2644
; }
 800d9e4: bf00         	nop
 800d9e6: 3708         	adds	r7, #0x8
 800d9e8: 46bd         	mov	sp, r7
 800d9ea: bd80         	pop	{r7, pc}

0800d9ec <$d>:
 800d9ec: 30 07 00 20  	.word	0x20000730

0800d9f0 <z_add_thread_timeout>:
; {
 800d9f0: b580         	push	{r7, lr}
 800d9f2: b084         	sub	sp, #0x10
 800d9f4: af00         	add	r7, sp, #0x0
 800d9f6: 60f8         	str	r0, [r7, #0xc]
 800d9f8: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 800d9fc: 68fb         	ldr	r3, [r7, #0xc]
 800d9fe: f103 0018    	add.w	r0, r3, #0x18
 800da02: e9d7 2300    	ldrd	r2, r3, [r7]
 800da06: 4903         	ldr	r1, [pc, #0xc]          @ 0x800da14 <z_add_thread_timeout+0x24>
 800da08: f001 feae    	bl	0x800f768 <z_add_timeout> @ imm = #0x1d5c
; }
 800da0c: bf00         	nop
 800da0e: 3710         	adds	r7, #0x10
 800da10: 46bd         	mov	sp, r7
 800da12: bd80         	pop	{r7, pc}

0800da14 <$d>:
 800da14: 13 a2 01 08  	.word	0x0801a213

0800da18 <z_sched_lock>:
; {
 800da18: b480         	push	{r7}
 800da1a: b083         	sub	sp, #0xc
 800da1c: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800da1e: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800da38 <z_sched_lock+0x20>
 800da20: 689b         	ldr	r3, [r3, #0x8]
 800da22: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 800da24: 687b         	ldr	r3, [r7, #0x4]
; 	--arch_current_thread()->base.sched_locked;
 800da26: 7bda         	ldrb	r2, [r3, #0xf]
 800da28: 3a01         	subs	r2, #0x1
 800da2a: b2d2         	uxtb	r2, r2
 800da2c: 73da         	strb	r2, [r3, #0xf]
; }
 800da2e: bf00         	nop
 800da30: 370c         	adds	r7, #0xc
 800da32: 46bd         	mov	sp, r7
 800da34: bc80         	pop	{r7}
 800da36: 4770         	bx	lr

0800da38 <$d>:
 800da38: 30 07 00 20  	.word	0x20000730

0800da3c <z_dummy_thread_init>:
; {
 800da3c: b480         	push	{r7}
 800da3e: b085         	sub	sp, #0x14
 800da40: af00         	add	r7, sp, #0x0
 800da42: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 800da44: 687b         	ldr	r3, [r7, #0x4]
 800da46: 2201         	movs	r2, #0x1
 800da48: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 800da4a: 687b         	ldr	r3, [r7, #0x4]
 800da4c: 2201         	movs	r2, #0x1
 800da4e: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 800da50: 687b         	ldr	r3, [r7, #0x4]
 800da52: 2200         	movs	r2, #0x0
 800da54: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 800da58: 687b         	ldr	r3, [r7, #0x4]
 800da5a: 2200         	movs	r2, #0x0
 800da5c: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	dummy_thread->resource_pool = NULL;
 800da60: 687b         	ldr	r3, [r7, #0x4]
 800da62: 2200         	movs	r2, #0x0
 800da64: f8c3 20c0    	str.w	r2, [r3, #0xc0]
 800da68: 687b         	ldr	r3, [r7, #0x4]
 800da6a: 60fb         	str	r3, [r7, #0xc]
; 	_current_cpu->current = thread;
 800da6c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800da80 <z_dummy_thread_init+0x44>
 800da6e: 68fb         	ldr	r3, [r7, #0xc]
 800da70: 6093         	str	r3, [r2, #0x8]
; }
 800da72: bf00         	nop
; }
 800da74: bf00         	nop
 800da76: 3714         	adds	r7, #0x14
 800da78: 46bd         	mov	sp, r7
 800da7a: bc80         	pop	{r7}
 800da7c: 4770         	bx	lr
 800da7e: bf00         	nop

0800da80 <$d>:
 800da80: 30 07 00 20  	.word	0x20000730

0800da84 <move_thread_to_end_of_prio_q>:
; {
 800da84: b580         	push	{r7, lr}
 800da86: b09a         	sub	sp, #0x68
 800da88: af00         	add	r7, sp, #0x0
 800da8a: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 800da8c: 6878         	ldr	r0, [r7, #0x4]
 800da8e: f00c fa04    	bl	0x8019e9a <z_is_thread_queued> @ imm = #0xc408
 800da92: 4603         	mov	r3, r0
 800da94: 2b00         	cmp	r3, #0x0
 800da96: d01d         	beq	0x800dad4 <move_thread_to_end_of_prio_q+0x50> @ imm = #0x3a
 800da98: 687b         	ldr	r3, [r7, #0x4]
 800da9a: 667b         	str	r3, [r7, #0x64]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800da9c: 6e7b         	ldr	r3, [r7, #0x64]
 800da9e: 7b5b         	ldrb	r3, [r3, #0xd]
 800daa0: f003 037f    	and	r3, r3, #0x7f
 800daa4: b2da         	uxtb	r2, r3
 800daa6: 6e7b         	ldr	r3, [r7, #0x64]
 800daa8: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800daaa: 6e78         	ldr	r0, [r7, #0x64]
 800daac: f00c fada    	bl	0x801a064 <should_queue_thread> @ imm = #0xc5b4
 800dab0: 4603         	mov	r3, r0
 800dab2: 2b00         	cmp	r3, #0x0
 800dab4: d00d         	beq	0x800dad2 <move_thread_to_end_of_prio_q+0x4e> @ imm = #0x1a
 800dab6: 6e7b         	ldr	r3, [r7, #0x64]
 800dab8: 663b         	str	r3, [r7, #0x60]
 800daba: 6e3b         	ldr	r3, [r7, #0x60]
 800dabc: 65fb         	str	r3, [r7, #0x5c]
; 	return &_kernel.ready_q.runq;
 800dabe: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x800dc5c <move_thread_to_end_of_prio_q+0x1d8>
 800dac0: 65bb         	str	r3, [r7, #0x58]
 800dac2: 6e3b         	ldr	r3, [r7, #0x60]
 800dac4: 657b         	str	r3, [r7, #0x54]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800dac6: 6d7b         	ldr	r3, [r7, #0x54]
 800dac8: 4618         	mov	r0, r3
 800daca: f00c f90b    	bl	0x8019ce4 <sys_dlist_remove> @ imm = #0xc216
; }
 800dace: bf00         	nop
; }
 800dad0: bf00         	nop
; }
 800dad2: bf00         	nop
 800dad4: 687b         	ldr	r3, [r7, #0x4]
 800dad6: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800dad8: 69fb         	ldr	r3, [r7, #0x1c]
 800dada: 7b5b         	ldrb	r3, [r3, #0xd]
 800dadc: f063 037f    	orn	r3, r3, #0x7f
 800dae0: b2da         	uxtb	r2, r3
 800dae2: 69fb         	ldr	r3, [r7, #0x1c]
 800dae4: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800dae6: 69f8         	ldr	r0, [r7, #0x1c]
 800dae8: f00c fabc    	bl	0x801a064 <should_queue_thread> @ imm = #0xc578
 800daec: 4603         	mov	r3, r0
 800daee: 2b00         	cmp	r3, #0x0
 800daf0: d042         	beq	0x800db78 <move_thread_to_end_of_prio_q+0xf4> @ imm = #0x84
 800daf2: 69fb         	ldr	r3, [r7, #0x1c]
 800daf4: 61bb         	str	r3, [r7, #0x18]
 800daf6: 69bb         	ldr	r3, [r7, #0x18]
 800daf8: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 800dafa: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800dc5c <move_thread_to_end_of_prio_q+0x1d8>
 800dafc: 613b         	str	r3, [r7, #0x10]
 800dafe: 69bb         	ldr	r3, [r7, #0x18]
 800db00: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800db02: 6938         	ldr	r0, [r7, #0x10]
 800db04: f00c f884    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xc108
 800db08: 4603         	mov	r3, r0
 800db0a: 2b00         	cmp	r3, #0x0
 800db0c: d004         	beq	0x800db18 <move_thread_to_end_of_prio_q+0x94> @ imm = #0x8
 800db0e: 6938         	ldr	r0, [r7, #0x10]
 800db10: f00c f87e    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xc0fc
 800db14: 4603         	mov	r3, r0
 800db16: e000         	b	0x800db1a <move_thread_to_end_of_prio_q+0x96> @ imm = #0x0
 800db18: 2300         	movs	r3, #0x0
 800db1a: 60bb         	str	r3, [r7, #0x8]
 800db1c: e023         	b	0x800db66 <move_thread_to_end_of_prio_q+0xe2> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800db1e: 68b9         	ldr	r1, [r7, #0x8]
 800db20: 68f8         	ldr	r0, [r7, #0xc]
 800db22: f00c fa84    	bl	0x801a02e <z_sched_prio_cmp> @ imm = #0xc508
 800db26: 4603         	mov	r3, r0
 800db28: 2b00         	cmp	r3, #0x0
 800db2a: dd06         	ble	0x800db3a <move_thread_to_end_of_prio_q+0xb6> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800db2c: 68bb         	ldr	r3, [r7, #0x8]
 800db2e: 68fa         	ldr	r2, [r7, #0xc]
 800db30: 4611         	mov	r1, r2
 800db32: 4618         	mov	r0, r3
 800db34: f00c f8bd    	bl	0x8019cb2 <sys_dlist_insert> @ imm = #0xc17a
; 			return;
 800db38: e01d         	b	0x800db76 <move_thread_to_end_of_prio_q+0xf2> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800db3a: 68bb         	ldr	r3, [r7, #0x8]
 800db3c: 2b00         	cmp	r3, #0x0
 800db3e: d010         	beq	0x800db62 <move_thread_to_end_of_prio_q+0xde> @ imm = #0x20
 800db40: 68bb         	ldr	r3, [r7, #0x8]
 800db42: 4619         	mov	r1, r3
 800db44: 6938         	ldr	r0, [r7, #0x10]
 800db46: f00c f888    	bl	0x8019c5a <sys_dlist_peek_next> @ imm = #0xc110
 800db4a: 4603         	mov	r3, r0
 800db4c: 2b00         	cmp	r3, #0x0
 800db4e: d006         	beq	0x800db5e <move_thread_to_end_of_prio_q+0xda> @ imm = #0xc
 800db50: 68bb         	ldr	r3, [r7, #0x8]
 800db52: 4619         	mov	r1, r3
 800db54: 6938         	ldr	r0, [r7, #0x10]
 800db56: f00c f880    	bl	0x8019c5a <sys_dlist_peek_next> @ imm = #0xc100
 800db5a: 4603         	mov	r3, r0
 800db5c: e002         	b	0x800db64 <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x4
 800db5e: 2300         	movs	r3, #0x0
 800db60: e000         	b	0x800db64 <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x0
 800db62: 2300         	movs	r3, #0x0
 800db64: 60bb         	str	r3, [r7, #0x8]
 800db66: 68bb         	ldr	r3, [r7, #0x8]
 800db68: 2b00         	cmp	r3, #0x0
 800db6a: d1d8         	bne	0x800db1e <move_thread_to_end_of_prio_q+0x9a> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800db6c: 68fb         	ldr	r3, [r7, #0xc]
 800db6e: 4619         	mov	r1, r3
 800db70: 6938         	ldr	r0, [r7, #0x10]
 800db72: f00c f885    	bl	0x8019c80 <sys_dlist_append> @ imm = #0xc10a
; }
 800db76: bf00         	nop
; }
 800db78: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800db7a: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800dc60 <move_thread_to_end_of_prio_q+0x1dc>
 800db7c: 689b         	ldr	r3, [r3, #0x8]
 800db7e: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 800db80: 6a3b         	ldr	r3, [r7, #0x20]
; 	update_cache(thread == arch_current_thread());
 800db82: 687a         	ldr	r2, [r7, #0x4]
 800db84: 429a         	cmp	r2, r3
 800db86: bf0c         	ite	eq
 800db88: 2301         	moveq	r3, #0x1
 800db8a: 2300         	movne	r3, #0x0
 800db8c: b2db         	uxtb	r3, r3
 800db8e: 653b         	str	r3, [r7, #0x50]
; 	return &_kernel.ready_q.runq;
 800db90: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x800dc5c <move_thread_to_end_of_prio_q+0x1d8>
 800db92: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800db94: 2300         	movs	r3, #0x0
 800db96: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800db98: 6cf8         	ldr	r0, [r7, #0x4c]
 800db9a: f00c f839    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xc072
 800db9e: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800dba0: 6c7b         	ldr	r3, [r7, #0x44]
 800dba2: 2b00         	cmp	r3, #0x0
 800dba4: d001         	beq	0x800dbaa <move_thread_to_end_of_prio_q+0x126> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800dba6: 6c7b         	ldr	r3, [r7, #0x44]
 800dba8: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800dbaa: 6cbb         	ldr	r3, [r7, #0x48]
; 	return _priq_run_best(curr_cpu_runq());
 800dbac: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800dbae: 643b         	str	r3, [r7, #0x40]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800dbb0: 6c3b         	ldr	r3, [r7, #0x40]
 800dbb2: 2b00         	cmp	r3, #0x0
 800dbb4: d102         	bne	0x800dbbc <move_thread_to_end_of_prio_q+0x138> @ imm = #0x4
 800dbb6: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800dc60 <move_thread_to_end_of_prio_q+0x1dc>
 800dbb8: 68db         	ldr	r3, [r3, #0xc]
 800dbba: e000         	b	0x800dbbe <move_thread_to_end_of_prio_q+0x13a> @ imm = #0x0
 800dbbc: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *thread = next_up();
 800dbbe: 63fb         	str	r3, [r7, #0x3c]
 800dbc0: 6bfb         	ldr	r3, [r7, #0x3c]
 800dbc2: 63bb         	str	r3, [r7, #0x38]
 800dbc4: 6d3b         	ldr	r3, [r7, #0x50]
 800dbc6: 637b         	str	r3, [r7, #0x34]
; 	if (preempt_ok != 0) {
 800dbc8: 6b7b         	ldr	r3, [r7, #0x34]
 800dbca: 2b00         	cmp	r3, #0x0
 800dbcc: d001         	beq	0x800dbd2 <move_thread_to_end_of_prio_q+0x14e> @ imm = #0x2
; 		return true;
 800dbce: 2301         	movs	r3, #0x1
 800dbd0: e026         	b	0x800dc20 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800dbd2: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800dc60 <move_thread_to_end_of_prio_q+0x1dc>
 800dbd4: 689b         	ldr	r3, [r3, #0x8]
 800dbd6: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 800dbd8: 6b3b         	ldr	r3, [r7, #0x30]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800dbda: 4618         	mov	r0, r3
 800dbdc: f00c f8fc    	bl	0x8019dd8 <z_is_thread_prevented_from_running> @ imm = #0xc1f8
 800dbe0: 4603         	mov	r3, r0
 800dbe2: 2b00         	cmp	r3, #0x0
 800dbe4: d001         	beq	0x800dbea <move_thread_to_end_of_prio_q+0x166> @ imm = #0x2
; 		return true;
 800dbe6: 2301         	movs	r3, #0x1
 800dbe8: e01a         	b	0x800dc20 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800dbea: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800dc60 <move_thread_to_end_of_prio_q+0x1dc>
 800dbec: 689b         	ldr	r3, [r3, #0x8]
 800dbee: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 800dbf0: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800dbf2: 4618         	mov	r0, r3
 800dbf4: f00c f8c4    	bl	0x8019d80 <thread_is_preemptible> @ imm = #0xc188
 800dbf8: 4603         	mov	r3, r0
 800dbfa: 2b00         	cmp	r3, #0x0
 800dbfc: d105         	bne	0x800dc0a <move_thread_to_end_of_prio_q+0x186> @ imm = #0xa
 800dbfe: 6bb8         	ldr	r0, [r7, #0x38]
 800dc00: f00c f8ce    	bl	0x8019da0 <thread_is_metairq> @ imm = #0xc19c
 800dc04: 4603         	mov	r3, r0
 800dc06: 2b00         	cmp	r3, #0x0
 800dc08: d001         	beq	0x800dc0e <move_thread_to_end_of_prio_q+0x18a> @ imm = #0x2
; 		return true;
 800dc0a: 2301         	movs	r3, #0x1
 800dc0c: e008         	b	0x800dc20 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800dc0e: 6bb8         	ldr	r0, [r7, #0x38]
 800dc10: f00c f8f6    	bl	0x8019e00 <z_is_thread_timeout_active> @ imm = #0xc1ec
 800dc14: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800dc16: 2b00         	cmp	r3, #0x0
 800dc18: d001         	beq	0x800dc1e <move_thread_to_end_of_prio_q+0x19a> @ imm = #0x2
; 		return true;
 800dc1a: 2301         	movs	r3, #0x1
 800dc1c: e000         	b	0x800dc20 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x0
; 	return false;
 800dc1e: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800dc20: 2b00         	cmp	r3, #0x0
 800dc22: d010         	beq	0x800dc46 <move_thread_to_end_of_prio_q+0x1c2> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800dc24: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800dc60 <move_thread_to_end_of_prio_q+0x1dc>
 800dc26: 689b         	ldr	r3, [r3, #0x8]
 800dc28: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800dc2a: 6abb         	ldr	r3, [r7, #0x28]
; 		if (thread != arch_current_thread()) {
 800dc2c: 6bfa         	ldr	r2, [r7, #0x3c]
 800dc2e: 429a         	cmp	r2, r3
 800dc30: d002         	beq	0x800dc38 <move_thread_to_end_of_prio_q+0x1b4> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800dc32: 6bf8         	ldr	r0, [r7, #0x3c]
 800dc34: f001 fc34    	bl	0x800f4a0 <z_reset_time_slice> @ imm = #0x1868
; 		update_metairq_preempt(thread);
 800dc38: 6bf8         	ldr	r0, [r7, #0x3c]
 800dc3a: f00c fa56    	bl	0x801a0ea <update_metairq_preempt> @ imm = #0xc4ac
; 		_kernel.ready_q.cache = thread;
 800dc3e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800dc60 <move_thread_to_end_of_prio_q+0x1dc>
 800dc40: 6bfb         	ldr	r3, [r7, #0x3c]
 800dc42: 61d3         	str	r3, [r2, #0x1c]
; }
 800dc44: e005         	b	0x800dc52 <move_thread_to_end_of_prio_q+0x1ce> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800dc46: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800dc60 <move_thread_to_end_of_prio_q+0x1dc>
 800dc48: 689b         	ldr	r3, [r3, #0x8]
 800dc4a: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800dc4c: 6a7b         	ldr	r3, [r7, #0x24]
; 		_kernel.ready_q.cache = arch_current_thread();
 800dc4e: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800dc60 <move_thread_to_end_of_prio_q+0x1dc>
 800dc50: 61d3         	str	r3, [r2, #0x1c]
; }
 800dc52: bf00         	nop
; }
 800dc54: bf00         	nop
 800dc56: 3768         	adds	r7, #0x68
 800dc58: 46bd         	mov	sp, r7
 800dc5a: bd80         	pop	{r7, pc}

0800dc5c <$d>:
 800dc5c: 50 07 00 20  	.word	0x20000750
 800dc60: 30 07 00 20  	.word	0x20000730

0800dc64 <ready_thread>:
; {
 800dc64: b580         	push	{r7, lr}
 800dc66: b094         	sub	sp, #0x50
 800dc68: af00         	add	r7, sp, #0x0
 800dc6a: 6078         	str	r0, [r7, #0x4]
; 	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 800dc6c: 6878         	ldr	r0, [r7, #0x4]
 800dc6e: f00c f914    	bl	0x8019e9a <z_is_thread_queued> @ imm = #0xc228
 800dc72: 4603         	mov	r3, r0
 800dc74: f083 0301    	eor	r3, r3, #0x1
 800dc78: b2db         	uxtb	r3, r3
 800dc7a: 2b00         	cmp	r3, #0x0
 800dc7c: f000 80be    	beq.w	0x800ddfc <ready_thread+0x198> @ imm = #0x17c
 800dc80: 6878         	ldr	r0, [r7, #0x4]
 800dc82: f00c f8d6    	bl	0x8019e32 <z_is_thread_ready> @ imm = #0xc1ac
 800dc86: 4603         	mov	r3, r0
 800dc88: 2b00         	cmp	r3, #0x0
 800dc8a: f000 80b7    	beq.w	0x800ddfc <ready_thread+0x198> @ imm = #0x16e
 800dc8e: 687b         	ldr	r3, [r7, #0x4]
 800dc90: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800dc92: 69fb         	ldr	r3, [r7, #0x1c]
 800dc94: 7b5b         	ldrb	r3, [r3, #0xd]
 800dc96: f063 037f    	orn	r3, r3, #0x7f
 800dc9a: b2da         	uxtb	r2, r3
 800dc9c: 69fb         	ldr	r3, [r7, #0x1c]
 800dc9e: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800dca0: 69f8         	ldr	r0, [r7, #0x1c]
 800dca2: f00c f9df    	bl	0x801a064 <should_queue_thread> @ imm = #0xc3be
 800dca6: 4603         	mov	r3, r0
 800dca8: 2b00         	cmp	r3, #0x0
 800dcaa: d042         	beq	0x800dd32 <ready_thread+0xce> @ imm = #0x84
 800dcac: 69fb         	ldr	r3, [r7, #0x1c]
 800dcae: 61bb         	str	r3, [r7, #0x18]
 800dcb0: 69bb         	ldr	r3, [r7, #0x18]
 800dcb2: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 800dcb4: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800de04 <ready_thread+0x1a0>
 800dcb6: 613b         	str	r3, [r7, #0x10]
 800dcb8: 69bb         	ldr	r3, [r7, #0x18]
 800dcba: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800dcbc: 6938         	ldr	r0, [r7, #0x10]
 800dcbe: f00b ffa7    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xbf4e
 800dcc2: 4603         	mov	r3, r0
 800dcc4: 2b00         	cmp	r3, #0x0
 800dcc6: d004         	beq	0x800dcd2 <ready_thread+0x6e> @ imm = #0x8
 800dcc8: 6938         	ldr	r0, [r7, #0x10]
 800dcca: f00b ffa1    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xbf42
 800dcce: 4603         	mov	r3, r0
 800dcd0: e000         	b	0x800dcd4 <ready_thread+0x70> @ imm = #0x0
 800dcd2: 2300         	movs	r3, #0x0
 800dcd4: 60bb         	str	r3, [r7, #0x8]
 800dcd6: e023         	b	0x800dd20 <ready_thread+0xbc> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800dcd8: 68b9         	ldr	r1, [r7, #0x8]
 800dcda: 68f8         	ldr	r0, [r7, #0xc]
 800dcdc: f00c f9a7    	bl	0x801a02e <z_sched_prio_cmp> @ imm = #0xc34e
 800dce0: 4603         	mov	r3, r0
 800dce2: 2b00         	cmp	r3, #0x0
 800dce4: dd06         	ble	0x800dcf4 <ready_thread+0x90> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800dce6: 68bb         	ldr	r3, [r7, #0x8]
 800dce8: 68fa         	ldr	r2, [r7, #0xc]
 800dcea: 4611         	mov	r1, r2
 800dcec: 4618         	mov	r0, r3
 800dcee: f00b ffe0    	bl	0x8019cb2 <sys_dlist_insert> @ imm = #0xbfc0
; 			return;
 800dcf2: e01d         	b	0x800dd30 <ready_thread+0xcc> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800dcf4: 68bb         	ldr	r3, [r7, #0x8]
 800dcf6: 2b00         	cmp	r3, #0x0
 800dcf8: d010         	beq	0x800dd1c <ready_thread+0xb8> @ imm = #0x20
 800dcfa: 68bb         	ldr	r3, [r7, #0x8]
 800dcfc: 4619         	mov	r1, r3
 800dcfe: 6938         	ldr	r0, [r7, #0x10]
 800dd00: f00b ffab    	bl	0x8019c5a <sys_dlist_peek_next> @ imm = #0xbf56
 800dd04: 4603         	mov	r3, r0
 800dd06: 2b00         	cmp	r3, #0x0
 800dd08: d006         	beq	0x800dd18 <ready_thread+0xb4> @ imm = #0xc
 800dd0a: 68bb         	ldr	r3, [r7, #0x8]
 800dd0c: 4619         	mov	r1, r3
 800dd0e: 6938         	ldr	r0, [r7, #0x10]
 800dd10: f00b ffa3    	bl	0x8019c5a <sys_dlist_peek_next> @ imm = #0xbf46
 800dd14: 4603         	mov	r3, r0
 800dd16: e002         	b	0x800dd1e <ready_thread+0xba> @ imm = #0x4
 800dd18: 2300         	movs	r3, #0x0
 800dd1a: e000         	b	0x800dd1e <ready_thread+0xba> @ imm = #0x0
 800dd1c: 2300         	movs	r3, #0x0
 800dd1e: 60bb         	str	r3, [r7, #0x8]
 800dd20: 68bb         	ldr	r3, [r7, #0x8]
 800dd22: 2b00         	cmp	r3, #0x0
 800dd24: d1d8         	bne	0x800dcd8 <ready_thread+0x74> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800dd26: 68fb         	ldr	r3, [r7, #0xc]
 800dd28: 4619         	mov	r1, r3
 800dd2a: 6938         	ldr	r0, [r7, #0x10]
 800dd2c: f00b ffa8    	bl	0x8019c80 <sys_dlist_append> @ imm = #0xbf50
; }
 800dd30: bf00         	nop
; }
 800dd32: bf00         	nop
 800dd34: 2300         	movs	r3, #0x0
 800dd36: 64fb         	str	r3, [r7, #0x4c]
; 	return &_kernel.ready_q.runq;
 800dd38: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x800de04 <ready_thread+0x1a0>
 800dd3a: 64bb         	str	r3, [r7, #0x48]
; 	struct k_thread *thread = NULL;
 800dd3c: 2300         	movs	r3, #0x0
 800dd3e: 647b         	str	r3, [r7, #0x44]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800dd40: 6cb8         	ldr	r0, [r7, #0x48]
 800dd42: f00b ff65    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xbeca
 800dd46: 6438         	str	r0, [r7, #0x40]
; 	if (n != NULL) {
 800dd48: 6c3b         	ldr	r3, [r7, #0x40]
 800dd4a: 2b00         	cmp	r3, #0x0
 800dd4c: d001         	beq	0x800dd52 <ready_thread+0xee> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800dd4e: 6c3b         	ldr	r3, [r7, #0x40]
 800dd50: 647b         	str	r3, [r7, #0x44]
; 	return thread;
 800dd52: 6c7b         	ldr	r3, [r7, #0x44]
; 	return _priq_run_best(curr_cpu_runq());
 800dd54: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800dd56: 63fb         	str	r3, [r7, #0x3c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800dd58: 6bfb         	ldr	r3, [r7, #0x3c]
 800dd5a: 2b00         	cmp	r3, #0x0
 800dd5c: d102         	bne	0x800dd64 <ready_thread+0x100> @ imm = #0x4
 800dd5e: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800de08 <ready_thread+0x1a4>
 800dd60: 68db         	ldr	r3, [r3, #0xc]
 800dd62: e000         	b	0x800dd66 <ready_thread+0x102> @ imm = #0x0
 800dd64: 6bfb         	ldr	r3, [r7, #0x3c]
; 	struct k_thread *thread = next_up();
 800dd66: 63bb         	str	r3, [r7, #0x38]
 800dd68: 6bbb         	ldr	r3, [r7, #0x38]
 800dd6a: 637b         	str	r3, [r7, #0x34]
 800dd6c: 6cfb         	ldr	r3, [r7, #0x4c]
 800dd6e: 633b         	str	r3, [r7, #0x30]
; 	if (preempt_ok != 0) {
 800dd70: 6b3b         	ldr	r3, [r7, #0x30]
 800dd72: 2b00         	cmp	r3, #0x0
 800dd74: d001         	beq	0x800dd7a <ready_thread+0x116> @ imm = #0x2
; 		return true;
 800dd76: 2301         	movs	r3, #0x1
 800dd78: e026         	b	0x800ddc8 <ready_thread+0x164> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800dd7a: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800de08 <ready_thread+0x1a4>
 800dd7c: 689b         	ldr	r3, [r3, #0x8]
 800dd7e: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 800dd80: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800dd82: 4618         	mov	r0, r3
 800dd84: f00c f828    	bl	0x8019dd8 <z_is_thread_prevented_from_running> @ imm = #0xc050
 800dd88: 4603         	mov	r3, r0
 800dd8a: 2b00         	cmp	r3, #0x0
 800dd8c: d001         	beq	0x800dd92 <ready_thread+0x12e> @ imm = #0x2
; 		return true;
 800dd8e: 2301         	movs	r3, #0x1
 800dd90: e01a         	b	0x800ddc8 <ready_thread+0x164> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800dd92: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800de08 <ready_thread+0x1a4>
 800dd94: 689b         	ldr	r3, [r3, #0x8]
 800dd96: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800dd98: 6abb         	ldr	r3, [r7, #0x28]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800dd9a: 4618         	mov	r0, r3
 800dd9c: f00b fff0    	bl	0x8019d80 <thread_is_preemptible> @ imm = #0xbfe0
 800dda0: 4603         	mov	r3, r0
 800dda2: 2b00         	cmp	r3, #0x0
 800dda4: d105         	bne	0x800ddb2 <ready_thread+0x14e> @ imm = #0xa
 800dda6: 6b78         	ldr	r0, [r7, #0x34]
 800dda8: f00b fffa    	bl	0x8019da0 <thread_is_metairq> @ imm = #0xbff4
 800ddac: 4603         	mov	r3, r0
 800ddae: 2b00         	cmp	r3, #0x0
 800ddb0: d001         	beq	0x800ddb6 <ready_thread+0x152> @ imm = #0x2
; 		return true;
 800ddb2: 2301         	movs	r3, #0x1
 800ddb4: e008         	b	0x800ddc8 <ready_thread+0x164> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800ddb6: 6b78         	ldr	r0, [r7, #0x34]
 800ddb8: f00c f822    	bl	0x8019e00 <z_is_thread_timeout_active> @ imm = #0xc044
 800ddbc: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800ddbe: 2b00         	cmp	r3, #0x0
 800ddc0: d001         	beq	0x800ddc6 <ready_thread+0x162> @ imm = #0x2
; 		return true;
 800ddc2: 2301         	movs	r3, #0x1
 800ddc4: e000         	b	0x800ddc8 <ready_thread+0x164> @ imm = #0x0
; 	return false;
 800ddc6: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800ddc8: 2b00         	cmp	r3, #0x0
 800ddca: d010         	beq	0x800ddee <ready_thread+0x18a> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ddcc: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800de08 <ready_thread+0x1a4>
 800ddce: 689b         	ldr	r3, [r3, #0x8]
 800ddd0: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800ddd2: 6a7b         	ldr	r3, [r7, #0x24]
; 		if (thread != arch_current_thread()) {
 800ddd4: 6bba         	ldr	r2, [r7, #0x38]
 800ddd6: 429a         	cmp	r2, r3
 800ddd8: d002         	beq	0x800dde0 <ready_thread+0x17c> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800ddda: 6bb8         	ldr	r0, [r7, #0x38]
 800dddc: f001 fb60    	bl	0x800f4a0 <z_reset_time_slice> @ imm = #0x16c0
; 		update_metairq_preempt(thread);
 800dde0: 6bb8         	ldr	r0, [r7, #0x38]
 800dde2: f00c f982    	bl	0x801a0ea <update_metairq_preempt> @ imm = #0xc304
; 		_kernel.ready_q.cache = thread;
 800dde6: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800de08 <ready_thread+0x1a4>
 800dde8: 6bbb         	ldr	r3, [r7, #0x38]
 800ddea: 61d3         	str	r3, [r2, #0x1c]
; }
 800ddec: e005         	b	0x800ddfa <ready_thread+0x196> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ddee: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800de08 <ready_thread+0x1a4>
 800ddf0: 689b         	ldr	r3, [r3, #0x8]
 800ddf2: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 800ddf4: 6a3b         	ldr	r3, [r7, #0x20]
; 		_kernel.ready_q.cache = arch_current_thread();
 800ddf6: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800de08 <ready_thread+0x1a4>
 800ddf8: 61d3         	str	r3, [r2, #0x1c]
; }
 800ddfa: bf00         	nop
; }
 800ddfc: bf00         	nop
 800ddfe: 3750         	adds	r7, #0x50
 800de00: 46bd         	mov	sp, r7
 800de02: bd80         	pop	{r7, pc}

0800de04 <$d>:
 800de04: 50 07 00 20  	.word	0x20000750
 800de08: 30 07 00 20  	.word	0x20000730

0800de0c <z_ready_thread>:
; {
 800de0c: b580         	push	{r7, lr}
 800de0e: b090         	sub	sp, #0x40
 800de10: af00         	add	r7, sp, #0x0
 800de12: 6078         	str	r0, [r7, #0x4]
; 	K_SPINLOCK(&_sched_spinlock) {
 800de14: 2300         	movs	r3, #0x0
 800de16: 61bb         	str	r3, [r7, #0x18]
 800de18: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800de98 <z_ready_thread+0x8c>
 800de1a: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800de1c: f3ef 8311    	mrs	r3, basepri
 800de20: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800de22: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 800de24: 637b         	str	r3, [r7, #0x34]
 800de26: 2310         	movs	r3, #0x10
 800de28: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800de2a: 6b3b         	ldr	r3, [r7, #0x30]
 800de2c: f383 8812    	msr	basepri_max, r3
; }
 800de30: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800de32: f3bf 8f6f    	isb	sy
; }
 800de36: bf00         	nop
; 	return key;
 800de38: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 800de3a: 60fb         	str	r3, [r7, #0xc]
 800de3c: 6bfb         	ldr	r3, [r7, #0x3c]
 800de3e: 62fb         	str	r3, [r7, #0x2c]
; }
 800de40: bf00         	nop
 800de42: 6bfb         	ldr	r3, [r7, #0x3c]
 800de44: 62bb         	str	r3, [r7, #0x28]
; }
 800de46: bf00         	nop
; 	return k;
 800de48: 68fb         	ldr	r3, [r7, #0xc]
 800de4a: 617b         	str	r3, [r7, #0x14]
; 	K_SPINLOCK(&_sched_spinlock) {
 800de4c: e01b         	b	0x800de86 <z_ready_thread+0x7a> @ imm = #0x36
; 		if (thread_active_elsewhere(thread) == NULL) {
 800de4e: 6878         	ldr	r0, [r7, #0x4]
 800de50: f00c f954    	bl	0x801a0fc <thread_active_elsewhere> @ imm = #0xc2a8
 800de54: 4603         	mov	r3, r0
 800de56: 2b00         	cmp	r3, #0x0
 800de58: d102         	bne	0x800de60 <z_ready_thread+0x54> @ imm = #0x4
; 			ready_thread(thread);
 800de5a: 6878         	ldr	r0, [r7, #0x4]
 800de5c: f7ff ff02    	bl	0x800dc64 <ready_thread> @ imm = #-0x1fc
 800de60: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800de98 <z_ready_thread+0x8c>
 800de62: 627b         	str	r3, [r7, #0x24]
 800de64: 697b         	ldr	r3, [r7, #0x14]
 800de66: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800de68: 693b         	ldr	r3, [r7, #0x10]
 800de6a: 623b         	str	r3, [r7, #0x20]
 800de6c: 6a3b         	ldr	r3, [r7, #0x20]
 800de6e: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800de70: 69fb         	ldr	r3, [r7, #0x1c]
 800de72: f383 8811    	msr	basepri, r3
; }
 800de76: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800de78: f3bf 8f6f    	isb	sy
; }
 800de7c: bf00         	nop
; }
 800de7e: bf00         	nop
; }
 800de80: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800de82: 2301         	movs	r3, #0x1
 800de84: 61bb         	str	r3, [r7, #0x18]
 800de86: 69bb         	ldr	r3, [r7, #0x18]
 800de88: 2b00         	cmp	r3, #0x0
 800de8a: d0e0         	beq	0x800de4e <z_ready_thread+0x42> @ imm = #-0x40
; }
 800de8c: bf00         	nop
 800de8e: bf00         	nop
 800de90: 3740         	adds	r7, #0x40
 800de92: 46bd         	mov	sp, r7
 800de94: bd80         	pop	{r7, pc}
 800de96: bf00         	nop

0800de98 <$d>:
 800de98: 2c 11 00 20  	.word	0x2000112c

0800de9c <thread_halt_spin>:
; {
 800de9c: b590         	push	{r4, r7, lr}
 800de9e: b091         	sub	sp, #0x44
 800dea0: af00         	add	r7, sp, #0x0
 800dea2: 6078         	str	r0, [r7, #0x4]
 800dea4: 6039         	str	r1, [r7]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800dea6: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x800df5c <thread_halt_spin+0xc0>
 800dea8: 689b         	ldr	r3, [r3, #0x8]
 800deaa: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 800deac: 6bbb         	ldr	r3, [r7, #0x38]
; 	if (is_halting(arch_current_thread())) {
 800deae: 4618         	mov	r0, r3
 800deb0: f00c f8f4    	bl	0x801a09c <is_halting>  @ imm = #0xc1e8
 800deb4: 4603         	mov	r3, r0
 800deb6: 2b00         	cmp	r3, #0x0
 800deb8: d014         	beq	0x800dee4 <thread_halt_spin+0x48> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800deba: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800df5c <thread_halt_spin+0xc0>
 800debc: 689b         	ldr	r3, [r3, #0x8]
 800debe: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 800dec0: 6b3c         	ldr	r4, [r7, #0x30]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800dec2: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800df5c <thread_halt_spin+0xc0>
 800dec4: 689b         	ldr	r3, [r3, #0x8]
 800dec6: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 800dec8: 6b7b         	ldr	r3, [r7, #0x34]
; 			    is_aborting(arch_current_thread()) ? _THREAD_DEAD : _THREAD_SUSPENDED);
 800deca: 4618         	mov	r0, r3
 800decc: f00c f8d4    	bl	0x801a078 <is_aborting> @ imm = #0xc1a8
 800ded0: 4603         	mov	r3, r0
; 		halt_thread(arch_current_thread(),
 800ded2: 2b00         	cmp	r3, #0x0
 800ded4: d001         	beq	0x800deda <thread_halt_spin+0x3e> @ imm = #0x2
 800ded6: 2308         	movs	r3, #0x8
 800ded8: e000         	b	0x800dedc <thread_halt_spin+0x40> @ imm = #0x0
 800deda: 2310         	movs	r3, #0x10
 800dedc: 4619         	mov	r1, r3
 800dede: 4620         	mov	r0, r4
 800dee0: f001 f87a    	bl	0x800efd8 <halt_thread> @ imm = #0x10f4
 800dee4: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800df60 <thread_halt_spin+0xc4>
 800dee6: 62fb         	str	r3, [r7, #0x2c]
 800dee8: 683b         	ldr	r3, [r7]
 800deea: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800deec: 68fb         	ldr	r3, [r7, #0xc]
 800deee: 62bb         	str	r3, [r7, #0x28]
 800def0: 6abb         	ldr	r3, [r7, #0x28]
 800def2: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800def4: 6a7b         	ldr	r3, [r7, #0x24]
 800def6: f383 8811    	msr	basepri, r3
; }
 800defa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800defc: f3bf 8f6f    	isb	sy
; }
 800df00: bf00         	nop
; }
 800df02: bf00         	nop
; }
 800df04: bf00         	nop
; 	while (is_halting(thread)) {
 800df06: e01d         	b	0x800df44 <thread_halt_spin+0xa8> @ imm = #0x3a
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800df08: f3ef 8311    	mrs	r3, basepri
 800df0c: 61bb         	str	r3, [r7, #0x18]
;   return(result);
 800df0e: 69bb         	ldr	r3, [r7, #0x18]
; 	key = __get_BASEPRI();
 800df10: 617b         	str	r3, [r7, #0x14]
 800df12: 2310         	movs	r3, #0x10
 800df14: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800df16: 693b         	ldr	r3, [r7, #0x10]
 800df18: f383 8812    	msr	basepri_max, r3
; }
 800df1c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800df1e: f3bf 8f6f    	isb	sy
; }
 800df22: bf00         	nop
; 	return key;
 800df24: 697b         	ldr	r3, [r7, #0x14]
; 		unsigned int k = arch_irq_lock();
 800df26: 63fb         	str	r3, [r7, #0x3c]
; 		arch_spin_relax(); /* Requires interrupts be masked */
 800df28: f00a fdd9    	bl	0x8018ade <arch_spin_relax> @ imm = #0xabb2
 800df2c: 6bfb         	ldr	r3, [r7, #0x3c]
 800df2e: 623b         	str	r3, [r7, #0x20]
 800df30: 6a3b         	ldr	r3, [r7, #0x20]
 800df32: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800df34: 69fb         	ldr	r3, [r7, #0x1c]
 800df36: f383 8811    	msr	basepri, r3
; }
 800df3a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800df3c: f3bf 8f6f    	isb	sy
; }
 800df40: bf00         	nop
; }
 800df42: bf00         	nop
; 	while (is_halting(thread)) {
 800df44: 6878         	ldr	r0, [r7, #0x4]
 800df46: f00c f8a9    	bl	0x801a09c <is_halting>  @ imm = #0xc152
 800df4a: 4603         	mov	r3, r0
 800df4c: 2b00         	cmp	r3, #0x0
 800df4e: d1db         	bne	0x800df08 <thread_halt_spin+0x6c> @ imm = #-0x4a
; }
 800df50: bf00         	nop
 800df52: bf00         	nop
 800df54: 3744         	adds	r7, #0x44
 800df56: 46bd         	mov	sp, r7
 800df58: bd90         	pop	{r4, r7, pc}
 800df5a: bf00         	nop

0800df5c <$d>:
 800df5c: 30 07 00 20  	.word	0x20000730
 800df60: 2c 11 00 20  	.word	0x2000112c

0800df64 <z_thread_halt>:
; {
 800df64: b580         	push	{r7, lr}
 800df66: b094         	sub	sp, #0x50
 800df68: af00         	add	r7, sp, #0x0
 800df6a: 60f8         	str	r0, [r7, #0xc]
 800df6c: 60b9         	str	r1, [r7, #0x8]
 800df6e: 4613         	mov	r3, r2
 800df70: 71fb         	strb	r3, [r7, #0x7]
; 	_wait_q_t *wq = &thread->join_queue;
 800df72: 68fb         	ldr	r3, [r7, #0xc]
 800df74: 3368         	adds	r3, #0x68
 800df76: 64fb         	str	r3, [r7, #0x4c]
; 	struct _cpu *cpu = thread_active_elsewhere(thread);
 800df78: 68f8         	ldr	r0, [r7, #0xc]
 800df7a: f00c f8bf    	bl	0x801a0fc <thread_active_elsewhere> @ imm = #0xc17e
 800df7e: 64b8         	str	r0, [r7, #0x48]
; 	if (cpu != NULL) {
 800df80: 6cbb         	ldr	r3, [r7, #0x48]
 800df82: 2b00         	cmp	r3, #0x0
 800df84: d02f         	beq	0x800dfe6 <z_thread_halt+0x82> @ imm = #0x5e
; 		thread->base.thread_state |= (terminate ? _THREAD_ABORTING
 800df86: 68fb         	ldr	r3, [r7, #0xc]
 800df88: 7b5b         	ldrb	r3, [r3, #0xd]
 800df8a: 79fa         	ldrb	r2, [r7, #0x7]
 800df8c: 2a00         	cmp	r2, #0x0
 800df8e: d001         	beq	0x800df94 <z_thread_halt+0x30> @ imm = #0x2
 800df90: 2220         	movs	r2, #0x20
 800df92: e000         	b	0x800df96 <z_thread_halt+0x32> @ imm = #0x0
 800df94: 2240         	movs	r2, #0x40
 800df96: 4313         	orrs	r3, r2
 800df98: b2da         	uxtb	r2, r3
 800df9a: 68fb         	ldr	r3, [r7, #0xc]
 800df9c: 735a         	strb	r2, [r3, #0xd]
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800df9e: f3ef 8305    	mrs	r3, ipsr
 800dfa2: 647b         	str	r3, [r7, #0x44]
;   return(result);
 800dfa4: 6c7b         	ldr	r3, [r7, #0x44]
; 	return (__get_IPSR()) ? (true) : (false);
 800dfa6: 2b00         	cmp	r3, #0x0
 800dfa8: bf14         	ite	ne
 800dfaa: 2301         	movne	r3, #0x1
 800dfac: 2300         	moveq	r3, #0x0
 800dfae: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 800dfb0: 2b00         	cmp	r3, #0x0
 800dfb2: d004         	beq	0x800dfbe <z_thread_halt+0x5a> @ imm = #0x8
; 			thread_halt_spin(thread, key);
 800dfb4: 68b9         	ldr	r1, [r7, #0x8]
 800dfb6: 68f8         	ldr	r0, [r7, #0xc]
 800dfb8: f7ff ff70    	bl	0x800de9c <thread_halt_spin> @ imm = #-0x120
; }
 800dfbc: e04f         	b	0x800e05e <z_thread_halt+0xfa> @ imm = #0x9e
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800dfbe: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800e068 <z_thread_halt+0x104>
 800dfc0: 689b         	ldr	r3, [r3, #0x8]
 800dfc2: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 800dfc4: 6bbb         	ldr	r3, [r7, #0x38]
; 			add_to_waitq_locked(arch_current_thread(), wq);
 800dfc6: 6cf9         	ldr	r1, [r7, #0x4c]
 800dfc8: 4618         	mov	r0, r3
 800dfca: f00c f8a1    	bl	0x801a110 <add_to_waitq_locked> @ imm = #0xc142
 800dfce: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800e06c <z_thread_halt+0x108>
 800dfd0: 643b         	str	r3, [r7, #0x40]
 800dfd2: 68bb         	ldr	r3, [r7, #0x8]
 800dfd4: 613b         	str	r3, [r7, #0x10]
 800dfd6: 6c3b         	ldr	r3, [r7, #0x40]
 800dfd8: 63fb         	str	r3, [r7, #0x3c]
; }
 800dfda: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800dfdc: 693b         	ldr	r3, [r7, #0x10]
 800dfde: 4618         	mov	r0, r3
 800dfe0: f00b fffa    	bl	0x8019fd8 <z_swap_irqlock> @ imm = #0xbff4
 800dfe4: e03b         	b	0x800e05e <z_thread_halt+0xfa> @ imm = #0x76
; 		halt_thread(thread, terminate ? _THREAD_DEAD : _THREAD_SUSPENDED);
 800dfe6: 79fb         	ldrb	r3, [r7, #0x7]
 800dfe8: 2b00         	cmp	r3, #0x0
 800dfea: d001         	beq	0x800dff0 <z_thread_halt+0x8c> @ imm = #0x2
 800dfec: 2308         	movs	r3, #0x8
 800dfee: e000         	b	0x800dff2 <z_thread_halt+0x8e> @ imm = #0x0
 800dff0: 2310         	movs	r3, #0x10
 800dff2: 4619         	mov	r1, r3
 800dff4: 68f8         	ldr	r0, [r7, #0xc]
 800dff6: f000 ffef    	bl	0x800efd8 <halt_thread> @ imm = #0xfde
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800dffa: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800e068 <z_thread_halt+0x104>
 800dffc: 689b         	ldr	r3, [r3, #0x8]
 800dffe: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 800e000: 6b7b         	ldr	r3, [r7, #0x34]
; 		if ((thread == arch_current_thread()) && !arch_is_in_isr()) {
 800e002: 68fa         	ldr	r2, [r7, #0xc]
 800e004: 429a         	cmp	r2, r3
 800e006: d119         	bne	0x800e03c <z_thread_halt+0xd8> @ imm = #0x32
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800e008: f3ef 8305    	mrs	r3, ipsr
 800e00c: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800e00e: 6b3b         	ldr	r3, [r7, #0x30]
; 	return (__get_IPSR()) ? (true) : (false);
 800e010: 2b00         	cmp	r3, #0x0
 800e012: bf14         	ite	ne
 800e014: 2301         	movne	r3, #0x1
 800e016: 2300         	moveq	r3, #0x0
 800e018: b2db         	uxtb	r3, r3
; 		if ((thread == arch_current_thread()) && !arch_is_in_isr()) {
 800e01a: f083 0301    	eor	r3, r3, #0x1
 800e01e: b2db         	uxtb	r3, r3
 800e020: 2b00         	cmp	r3, #0x0
 800e022: d00b         	beq	0x800e03c <z_thread_halt+0xd8> @ imm = #0x16
 800e024: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800e06c <z_thread_halt+0x108>
 800e026: 62fb         	str	r3, [r7, #0x2c]
 800e028: 68bb         	ldr	r3, [r7, #0x8]
 800e02a: 617b         	str	r3, [r7, #0x14]
 800e02c: 6afb         	ldr	r3, [r7, #0x2c]
 800e02e: 62bb         	str	r3, [r7, #0x28]
; }
 800e030: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800e032: 697b         	ldr	r3, [r7, #0x14]
 800e034: 4618         	mov	r0, r3
 800e036: f00b ffcf    	bl	0x8019fd8 <z_swap_irqlock> @ imm = #0xbf9e
; 			z_swap(&_sched_spinlock, key);
 800e03a: e010         	b	0x800e05e <z_thread_halt+0xfa> @ imm = #0x20
 800e03c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800e06c <z_thread_halt+0x108>
 800e03e: 627b         	str	r3, [r7, #0x24]
 800e040: 68bb         	ldr	r3, [r7, #0x8]
 800e042: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800e044: 69bb         	ldr	r3, [r7, #0x18]
 800e046: 623b         	str	r3, [r7, #0x20]
 800e048: 6a3b         	ldr	r3, [r7, #0x20]
 800e04a: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e04c: 69fb         	ldr	r3, [r7, #0x1c]
 800e04e: f383 8811    	msr	basepri, r3
; }
 800e052: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e054: f3bf 8f6f    	isb	sy
; }
 800e058: bf00         	nop
; }
 800e05a: bf00         	nop
; }
 800e05c: bf00         	nop
; }
 800e05e: bf00         	nop
 800e060: 3750         	adds	r7, #0x50
 800e062: 46bd         	mov	sp, r7
 800e064: bd80         	pop	{r7, pc}
 800e066: bf00         	nop

0800e068 <$d>:
 800e068: 30 07 00 20  	.word	0x20000730
 800e06c: 2c 11 00 20  	.word	0x2000112c

0800e070 <z_impl_k_thread_suspend>:
; {
 800e070: b580         	push	{r7, lr}
 800e072: b0ac         	sub	sp, #0xb0
 800e074: af00         	add	r7, sp, #0x0
 800e076: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e078: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x800e2b4 <z_impl_k_thread_suspend+0x244>
 800e07a: 689b         	ldr	r3, [r3, #0x8]
 800e07c: f8c7 30ac    	str.w	r3, [r7, #0xac]
; 	return ret;
 800e080: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
; 	if (thread == arch_current_thread() && !arch_is_in_isr() && !IS_ENABLED(CONFIG_SMP)) {
 800e084: 687a         	ldr	r2, [r7, #0x4]
 800e086: 429a         	cmp	r2, r3
 800e088: f040 80d7    	bne.w	0x800e23a <z_impl_k_thread_suspend+0x1ca> @ imm = #0x1ae
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800e08c: f3ef 8305    	mrs	r3, ipsr
 800e090: f8c7 30a8    	str.w	r3, [r7, #0xa8]
;   return(result);
 800e094: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
; 	return (__get_IPSR()) ? (true) : (false);
 800e098: 2b00         	cmp	r3, #0x0
 800e09a: bf14         	ite	ne
 800e09c: 2301         	movne	r3, #0x1
 800e09e: 2300         	moveq	r3, #0x0
 800e0a0: b2db         	uxtb	r3, r3
; 	if (thread == arch_current_thread() && !arch_is_in_isr() && !IS_ENABLED(CONFIG_SMP)) {
 800e0a2: f083 0301    	eor	r3, r3, #0x1
 800e0a6: b2db         	uxtb	r3, r3
 800e0a8: 2b00         	cmp	r3, #0x0
 800e0aa: f000 80c6    	beq.w	0x800e23a <z_impl_k_thread_suspend+0x1ca> @ imm = #0x18c
 800e0ae: 4b82         	ldr	r3, [pc, #0x208]        @ 0x800e2b8 <z_impl_k_thread_suspend+0x248>
 800e0b0: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e0b2: f3ef 8311    	mrs	r3, basepri
 800e0b6: 657b         	str	r3, [r7, #0x54]
;   return(result);
 800e0b8: 6d7b         	ldr	r3, [r7, #0x54]
; 	key = __get_BASEPRI();
 800e0ba: 653b         	str	r3, [r7, #0x50]
 800e0bc: 2310         	movs	r3, #0x10
 800e0be: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e0c0: 6cfb         	ldr	r3, [r7, #0x4c]
 800e0c2: f383 8812    	msr	basepri_max, r3
; }
 800e0c6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e0c8: f3bf 8f6f    	isb	sy
; }
 800e0cc: bf00         	nop
; 	return key;
 800e0ce: 6d3b         	ldr	r3, [r7, #0x50]
; 	k.key = arch_irq_lock();
 800e0d0: 60fb         	str	r3, [r7, #0xc]
 800e0d2: 6dbb         	ldr	r3, [r7, #0x58]
 800e0d4: 64bb         	str	r3, [r7, #0x48]
; }
 800e0d6: bf00         	nop
 800e0d8: 6dbb         	ldr	r3, [r7, #0x58]
 800e0da: 647b         	str	r3, [r7, #0x44]
; }
 800e0dc: bf00         	nop
; 	return k;
 800e0de: 68fb         	ldr	r3, [r7, #0xc]
 800e0e0: 613b         	str	r3, [r7, #0x10]
; 		z_mark_thread_as_suspended(thread);
 800e0e2: 6878         	ldr	r0, [r7, #0x4]
 800e0e4: f00b fee6    	bl	0x8019eb4 <z_mark_thread_as_suspended> @ imm = #0xbdcc
 800e0e8: 687b         	ldr	r3, [r7, #0x4]
 800e0ea: 66fb         	str	r3, [r7, #0x6c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800e0ec: 6efb         	ldr	r3, [r7, #0x6c]
 800e0ee: 7b5b         	ldrb	r3, [r3, #0xd]
 800e0f0: f003 037f    	and	r3, r3, #0x7f
 800e0f4: b2da         	uxtb	r2, r3
 800e0f6: 6efb         	ldr	r3, [r7, #0x6c]
 800e0f8: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800e0fa: 6ef8         	ldr	r0, [r7, #0x6c]
 800e0fc: f00b ffb2    	bl	0x801a064 <should_queue_thread> @ imm = #0xbf64
 800e100: 4603         	mov	r3, r0
 800e102: 2b00         	cmp	r3, #0x0
 800e104: d00d         	beq	0x800e122 <z_impl_k_thread_suspend+0xb2> @ imm = #0x1a
 800e106: 6efb         	ldr	r3, [r7, #0x6c]
 800e108: 66bb         	str	r3, [r7, #0x68]
 800e10a: 6ebb         	ldr	r3, [r7, #0x68]
 800e10c: 667b         	str	r3, [r7, #0x64]
; 	return &_kernel.ready_q.runq;
 800e10e: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x800e2bc <z_impl_k_thread_suspend+0x24c>
 800e110: 663b         	str	r3, [r7, #0x60]
 800e112: 6ebb         	ldr	r3, [r7, #0x68]
 800e114: 65fb         	str	r3, [r7, #0x5c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800e116: 6dfb         	ldr	r3, [r7, #0x5c]
 800e118: 4618         	mov	r0, r3
 800e11a: f00b fde3    	bl	0x8019ce4 <sys_dlist_remove> @ imm = #0xbbc6
; }
 800e11e: bf00         	nop
; }
 800e120: bf00         	nop
; }
 800e122: bf00         	nop
 800e124: 2301         	movs	r3, #0x1
 800e126: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	return &_kernel.ready_q.runq;
 800e12a: 4b64         	ldr	r3, [pc, #0x190]        @ 0x800e2bc <z_impl_k_thread_suspend+0x24c>
 800e12c: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	struct k_thread *thread = NULL;
 800e130: 2300         	movs	r3, #0x0
 800e132: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800e136: f8d7 0098    	ldr.w	r0, [r7, #0x98]
 800e13a: f00b fd69    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xbad2
 800e13e: f8c7 0090    	str.w	r0, [r7, #0x90]
; 	if (n != NULL) {
 800e142: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 800e146: 2b00         	cmp	r3, #0x0
 800e148: d003         	beq	0x800e152 <z_impl_k_thread_suspend+0xe2> @ imm = #0x6
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800e14a: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 800e14e: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	return thread;
 800e152: f8d7 3094    	ldr.w	r3, [r7, #0x94]
; 	return _priq_run_best(curr_cpu_runq());
 800e156: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800e158: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800e15c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800e160: 2b00         	cmp	r3, #0x0
 800e162: d102         	bne	0x800e16a <z_impl_k_thread_suspend+0xfa> @ imm = #0x4
 800e164: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800e2b4 <z_impl_k_thread_suspend+0x244>
 800e166: 68db         	ldr	r3, [r3, #0xc]
 800e168: e001         	b	0x800e16e <z_impl_k_thread_suspend+0xfe> @ imm = #0x2
 800e16a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	struct k_thread *thread = next_up();
 800e16e: f8c7 3088    	str.w	r3, [r7, #0x88]
 800e172: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800e176: f8c7 3084    	str.w	r3, [r7, #0x84]
 800e17a: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 800e17e: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	if (preempt_ok != 0) {
 800e182: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800e186: 2b00         	cmp	r3, #0x0
 800e188: d001         	beq	0x800e18e <z_impl_k_thread_suspend+0x11e> @ imm = #0x2
; 		return true;
 800e18a: 2301         	movs	r3, #0x1
 800e18c: e028         	b	0x800e1e0 <z_impl_k_thread_suspend+0x170> @ imm = #0x50
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e18e: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800e2b4 <z_impl_k_thread_suspend+0x244>
 800e190: 689b         	ldr	r3, [r3, #0x8]
 800e192: 67fb         	str	r3, [r7, #0x7c]
; 	return ret;
 800e194: 6ffb         	ldr	r3, [r7, #0x7c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800e196: 4618         	mov	r0, r3
 800e198: f00b fe1e    	bl	0x8019dd8 <z_is_thread_prevented_from_running> @ imm = #0xbc3c
 800e19c: 4603         	mov	r3, r0
 800e19e: 2b00         	cmp	r3, #0x0
 800e1a0: d001         	beq	0x800e1a6 <z_impl_k_thread_suspend+0x136> @ imm = #0x2
; 		return true;
 800e1a2: 2301         	movs	r3, #0x1
 800e1a4: e01c         	b	0x800e1e0 <z_impl_k_thread_suspend+0x170> @ imm = #0x38
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e1a6: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800e2b4 <z_impl_k_thread_suspend+0x244>
 800e1a8: 689b         	ldr	r3, [r3, #0x8]
 800e1aa: 67bb         	str	r3, [r7, #0x78]
; 	return ret;
 800e1ac: 6fbb         	ldr	r3, [r7, #0x78]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800e1ae: 4618         	mov	r0, r3
 800e1b0: f00b fde6    	bl	0x8019d80 <thread_is_preemptible> @ imm = #0xbbcc
 800e1b4: 4603         	mov	r3, r0
 800e1b6: 2b00         	cmp	r3, #0x0
 800e1b8: d106         	bne	0x800e1c8 <z_impl_k_thread_suspend+0x158> @ imm = #0xc
 800e1ba: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 800e1be: f00b fdef    	bl	0x8019da0 <thread_is_metairq> @ imm = #0xbbde
 800e1c2: 4603         	mov	r3, r0
 800e1c4: 2b00         	cmp	r3, #0x0
 800e1c6: d001         	beq	0x800e1cc <z_impl_k_thread_suspend+0x15c> @ imm = #0x2
; 		return true;
 800e1c8: 2301         	movs	r3, #0x1
 800e1ca: e009         	b	0x800e1e0 <z_impl_k_thread_suspend+0x170> @ imm = #0x12
; 	    && z_is_thread_timeout_active(thread)) {
 800e1cc: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 800e1d0: f00b fe16    	bl	0x8019e00 <z_is_thread_timeout_active> @ imm = #0xbc2c
 800e1d4: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800e1d6: 2b00         	cmp	r3, #0x0
 800e1d8: d001         	beq	0x800e1de <z_impl_k_thread_suspend+0x16e> @ imm = #0x2
; 		return true;
 800e1da: 2301         	movs	r3, #0x1
 800e1dc: e000         	b	0x800e1e0 <z_impl_k_thread_suspend+0x170> @ imm = #0x0
; 	return false;
 800e1de: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800e1e0: 2b00         	cmp	r3, #0x0
 800e1e2: d014         	beq	0x800e20e <z_impl_k_thread_suspend+0x19e> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e1e4: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800e2b4 <z_impl_k_thread_suspend+0x244>
 800e1e6: 689b         	ldr	r3, [r3, #0x8]
 800e1e8: 677b         	str	r3, [r7, #0x74]
; 	return ret;
 800e1ea: 6f7b         	ldr	r3, [r7, #0x74]
; 		if (thread != arch_current_thread()) {
 800e1ec: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 800e1f0: 429a         	cmp	r2, r3
 800e1f2: d003         	beq	0x800e1fc <z_impl_k_thread_suspend+0x18c> @ imm = #0x6
; 			z_reset_time_slice(thread);
 800e1f4: f8d7 0088    	ldr.w	r0, [r7, #0x88]
 800e1f8: f001 f952    	bl	0x800f4a0 <z_reset_time_slice> @ imm = #0x12a4
; 		update_metairq_preempt(thread);
 800e1fc: f8d7 0088    	ldr.w	r0, [r7, #0x88]
 800e200: f00b ff73    	bl	0x801a0ea <update_metairq_preempt> @ imm = #0xbee6
; 		_kernel.ready_q.cache = thread;
 800e204: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x800e2b4 <z_impl_k_thread_suspend+0x244>
 800e206: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800e20a: 61d3         	str	r3, [r2, #0x1c]
; }
 800e20c: e005         	b	0x800e21a <z_impl_k_thread_suspend+0x1aa> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e20e: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800e2b4 <z_impl_k_thread_suspend+0x244>
 800e210: 689b         	ldr	r3, [r3, #0x8]
 800e212: 673b         	str	r3, [r7, #0x70]
; 	return ret;
 800e214: 6f3b         	ldr	r3, [r7, #0x70]
; 		_kernel.ready_q.cache = arch_current_thread();
 800e216: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x800e2b4 <z_impl_k_thread_suspend+0x244>
 800e218: 61d3         	str	r3, [r2, #0x1c]
; }
 800e21a: bf00         	nop
 800e21c: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800e2b8 <z_impl_k_thread_suspend+0x248>
 800e21e: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 800e222: 693b         	ldr	r3, [r7, #0x10]
 800e224: 60bb         	str	r3, [r7, #0x8]
 800e226: f8d7 30a4    	ldr.w	r3, [r7, #0xa4]
 800e22a: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; }
 800e22e: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800e230: 68bb         	ldr	r3, [r7, #0x8]
 800e232: 4618         	mov	r0, r3
 800e234: f00b fed0    	bl	0x8019fd8 <z_swap_irqlock> @ imm = #0xbda0
 800e238: e039         	b	0x800e2ae <z_impl_k_thread_suspend+0x23e> @ imm = #0x72
; 	(void)z_abort_thread_timeout(thread);
 800e23a: 6878         	ldr	r0, [r7, #0x4]
 800e23c: f00b fd92    	bl	0x8019d64 <z_abort_thread_timeout> @ imm = #0xbb24
 800e240: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800e2b8 <z_impl_k_thread_suspend+0x248>
 800e242: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e244: f3ef 8311    	mrs	r3, basepri
 800e248: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800e24a: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 800e24c: 63bb         	str	r3, [r7, #0x38]
 800e24e: 2310         	movs	r3, #0x10
 800e250: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e252: 6b7b         	ldr	r3, [r7, #0x34]
 800e254: f383 8812    	msr	basepri_max, r3
; }
 800e258: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e25a: f3bf 8f6f    	isb	sy
; }
 800e25e: bf00         	nop
; 	return key;
 800e260: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 800e262: 617b         	str	r3, [r7, #0x14]
 800e264: 6c3b         	ldr	r3, [r7, #0x40]
 800e266: 633b         	str	r3, [r7, #0x30]
; }
 800e268: bf00         	nop
 800e26a: 6c3b         	ldr	r3, [r7, #0x40]
 800e26c: 62fb         	str	r3, [r7, #0x2c]
; }
 800e26e: bf00         	nop
; 	return k;
 800e270: 697b         	ldr	r3, [r7, #0x14]
 800e272: 61fb         	str	r3, [r7, #0x1c]
; 	if ((thread->base.thread_state & _THREAD_SUSPENDED) != 0U) {
 800e274: 687b         	ldr	r3, [r7, #0x4]
 800e276: 7b5b         	ldrb	r3, [r3, #0xd]
 800e278: f003 0310    	and	r3, r3, #0x10
 800e27c: 2b00         	cmp	r3, #0x0
 800e27e: d011         	beq	0x800e2a4 <z_impl_k_thread_suspend+0x234> @ imm = #0x22
 800e280: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e2b8 <z_impl_k_thread_suspend+0x248>
 800e282: 62bb         	str	r3, [r7, #0x28]
 800e284: 69fb         	ldr	r3, [r7, #0x1c]
 800e286: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800e288: 69bb         	ldr	r3, [r7, #0x18]
 800e28a: 627b         	str	r3, [r7, #0x24]
 800e28c: 6a7b         	ldr	r3, [r7, #0x24]
 800e28e: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e290: 6a3b         	ldr	r3, [r7, #0x20]
 800e292: f383 8811    	msr	basepri, r3
; }
 800e296: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e298: f3bf 8f6f    	isb	sy
; }
 800e29c: bf00         	nop
; }
 800e29e: bf00         	nop
; }
 800e2a0: bf00         	nop
; 		return;
 800e2a2: e004         	b	0x800e2ae <z_impl_k_thread_suspend+0x23e> @ imm = #0x8
; 	z_thread_halt(thread, key, false);
 800e2a4: 2200         	movs	r2, #0x0
 800e2a6: 69f9         	ldr	r1, [r7, #0x1c]
 800e2a8: 6878         	ldr	r0, [r7, #0x4]
 800e2aa: f7ff fe5b    	bl	0x800df64 <z_thread_halt> @ imm = #-0x34a
; }
 800e2ae: 37b0         	adds	r7, #0xb0
 800e2b0: 46bd         	mov	sp, r7
 800e2b2: bd80         	pop	{r7, pc}

0800e2b4 <$d>:
 800e2b4: 30 07 00 20  	.word	0x20000730
 800e2b8: 2c 11 00 20  	.word	0x2000112c
 800e2bc: 50 07 00 20  	.word	0x20000750

0800e2c0 <z_impl_k_thread_resume>:
; {
 800e2c0: b580         	push	{r7, lr}
 800e2c2: b08e         	sub	sp, #0x38
 800e2c4: af00         	add	r7, sp, #0x0
 800e2c6: 6078         	str	r0, [r7, #0x4]
 800e2c8: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800e34c <z_impl_k_thread_resume+0x8c>
 800e2ca: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e2cc: f3ef 8311    	mrs	r3, basepri
 800e2d0: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800e2d2: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800e2d4: 62fb         	str	r3, [r7, #0x2c]
 800e2d6: 2310         	movs	r3, #0x10
 800e2d8: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e2da: 6abb         	ldr	r3, [r7, #0x28]
 800e2dc: f383 8812    	msr	basepri_max, r3
; }
 800e2e0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e2e2: f3bf 8f6f    	isb	sy
; }
 800e2e6: bf00         	nop
; 	return key;
 800e2e8: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800e2ea: 60bb         	str	r3, [r7, #0x8]
 800e2ec: 6b7b         	ldr	r3, [r7, #0x34]
 800e2ee: 627b         	str	r3, [r7, #0x24]
; }
 800e2f0: bf00         	nop
 800e2f2: 6b7b         	ldr	r3, [r7, #0x34]
 800e2f4: 623b         	str	r3, [r7, #0x20]
; }
 800e2f6: bf00         	nop
; 	return k;
 800e2f8: 68bb         	ldr	r3, [r7, #0x8]
 800e2fa: 613b         	str	r3, [r7, #0x10]
; 	if (!z_is_thread_suspended(thread)) {
 800e2fc: 6878         	ldr	r0, [r7, #0x4]
 800e2fe: f00b fd59    	bl	0x8019db4 <z_is_thread_suspended> @ imm = #0xbab2
 800e302: 4603         	mov	r3, r0
 800e304: f083 0301    	eor	r3, r3, #0x1
 800e308: b2db         	uxtb	r3, r3
 800e30a: 2b00         	cmp	r3, #0x0
 800e30c: d010         	beq	0x800e330 <z_impl_k_thread_resume+0x70> @ imm = #0x20
 800e30e: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800e34c <z_impl_k_thread_resume+0x8c>
 800e310: 61fb         	str	r3, [r7, #0x1c]
 800e312: 693b         	ldr	r3, [r7, #0x10]
 800e314: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800e316: 68fb         	ldr	r3, [r7, #0xc]
 800e318: 61bb         	str	r3, [r7, #0x18]
 800e31a: 69bb         	ldr	r3, [r7, #0x18]
 800e31c: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e31e: 697b         	ldr	r3, [r7, #0x14]
 800e320: f383 8811    	msr	basepri, r3
; }
 800e324: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e326: f3bf 8f6f    	isb	sy
; }
 800e32a: bf00         	nop
; }
 800e32c: bf00         	nop
; }
 800e32e: e009         	b	0x800e344 <z_impl_k_thread_resume+0x84> @ imm = #0x12
; 	z_mark_thread_as_not_suspended(thread);
 800e330: 6878         	ldr	r0, [r7, #0x4]
 800e332: f00b fdcf    	bl	0x8019ed4 <z_mark_thread_as_not_suspended> @ imm = #0xbb9e
; 	ready_thread(thread);
 800e336: 6878         	ldr	r0, [r7, #0x4]
 800e338: f7ff fc94    	bl	0x800dc64 <ready_thread> @ imm = #-0x6d8
; 	z_reschedule(&_sched_spinlock, key);
 800e33c: 6939         	ldr	r1, [r7, #0x10]
 800e33e: 4803         	ldr	r0, [pc, #0xc]          @ 0x800e34c <z_impl_k_thread_resume+0x8c>
 800e340: f00b ff9d    	bl	0x801a27e <z_reschedule> @ imm = #0xbf3a
; }
 800e344: 3738         	adds	r7, #0x38
 800e346: 46bd         	mov	sp, r7
 800e348: bd80         	pop	{r7, pc}
 800e34a: bf00         	nop

0800e34c <$d>:
 800e34c: 2c 11 00 20  	.word	0x2000112c

0800e350 <unready_thread>:
; {
 800e350: b580         	push	{r7, lr}
 800e352: b094         	sub	sp, #0x50
 800e354: af00         	add	r7, sp, #0x0
 800e356: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 800e358: 6878         	ldr	r0, [r7, #0x4]
 800e35a: f00b fd9e    	bl	0x8019e9a <z_is_thread_queued> @ imm = #0xbb3c
 800e35e: 4603         	mov	r3, r0
 800e360: 2b00         	cmp	r3, #0x0
 800e362: d01d         	beq	0x800e3a0 <unready_thread+0x50> @ imm = #0x3a
 800e364: 687b         	ldr	r3, [r7, #0x4]
 800e366: 64fb         	str	r3, [r7, #0x4c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800e368: 6cfb         	ldr	r3, [r7, #0x4c]
 800e36a: 7b5b         	ldrb	r3, [r3, #0xd]
 800e36c: f003 037f    	and	r3, r3, #0x7f
 800e370: b2da         	uxtb	r2, r3
 800e372: 6cfb         	ldr	r3, [r7, #0x4c]
 800e374: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800e376: 6cf8         	ldr	r0, [r7, #0x4c]
 800e378: f00b fe74    	bl	0x801a064 <should_queue_thread> @ imm = #0xbce8
 800e37c: 4603         	mov	r3, r0
 800e37e: 2b00         	cmp	r3, #0x0
 800e380: d00d         	beq	0x800e39e <unready_thread+0x4e> @ imm = #0x1a
 800e382: 6cfb         	ldr	r3, [r7, #0x4c]
 800e384: 64bb         	str	r3, [r7, #0x48]
 800e386: 6cbb         	ldr	r3, [r7, #0x48]
 800e388: 647b         	str	r3, [r7, #0x44]
; 	return &_kernel.ready_q.runq;
 800e38a: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800e484 <unready_thread+0x134>
 800e38c: 643b         	str	r3, [r7, #0x40]
 800e38e: 6cbb         	ldr	r3, [r7, #0x48]
 800e390: 63fb         	str	r3, [r7, #0x3c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800e392: 6bfb         	ldr	r3, [r7, #0x3c]
 800e394: 4618         	mov	r0, r3
 800e396: f00b fca5    	bl	0x8019ce4 <sys_dlist_remove> @ imm = #0xb94a
; }
 800e39a: bf00         	nop
; }
 800e39c: bf00         	nop
; }
 800e39e: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e3a0: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800e488 <unready_thread+0x138>
 800e3a2: 689b         	ldr	r3, [r3, #0x8]
 800e3a4: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 800e3a6: 68bb         	ldr	r3, [r7, #0x8]
; 	update_cache(thread == arch_current_thread());
 800e3a8: 687a         	ldr	r2, [r7, #0x4]
 800e3aa: 429a         	cmp	r2, r3
 800e3ac: bf0c         	ite	eq
 800e3ae: 2301         	moveq	r3, #0x1
 800e3b0: 2300         	movne	r3, #0x0
 800e3b2: b2db         	uxtb	r3, r3
 800e3b4: 63bb         	str	r3, [r7, #0x38]
; 	return &_kernel.ready_q.runq;
 800e3b6: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800e484 <unready_thread+0x134>
 800e3b8: 637b         	str	r3, [r7, #0x34]
; 	struct k_thread *thread = NULL;
 800e3ba: 2300         	movs	r3, #0x0
 800e3bc: 633b         	str	r3, [r7, #0x30]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800e3be: 6b78         	ldr	r0, [r7, #0x34]
 800e3c0: f00b fc26    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xb84c
 800e3c4: 62f8         	str	r0, [r7, #0x2c]
; 	if (n != NULL) {
 800e3c6: 6afb         	ldr	r3, [r7, #0x2c]
 800e3c8: 2b00         	cmp	r3, #0x0
 800e3ca: d001         	beq	0x800e3d0 <unready_thread+0x80> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800e3cc: 6afb         	ldr	r3, [r7, #0x2c]
 800e3ce: 633b         	str	r3, [r7, #0x30]
; 	return thread;
 800e3d0: 6b3b         	ldr	r3, [r7, #0x30]
; 	return _priq_run_best(curr_cpu_runq());
 800e3d2: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800e3d4: 62bb         	str	r3, [r7, #0x28]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800e3d6: 6abb         	ldr	r3, [r7, #0x28]
 800e3d8: 2b00         	cmp	r3, #0x0
 800e3da: d102         	bne	0x800e3e2 <unready_thread+0x92> @ imm = #0x4
 800e3dc: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800e488 <unready_thread+0x138>
 800e3de: 68db         	ldr	r3, [r3, #0xc]
 800e3e0: e000         	b	0x800e3e4 <unready_thread+0x94> @ imm = #0x0
 800e3e2: 6abb         	ldr	r3, [r7, #0x28]
; 	struct k_thread *thread = next_up();
 800e3e4: 627b         	str	r3, [r7, #0x24]
 800e3e6: 6a7b         	ldr	r3, [r7, #0x24]
 800e3e8: 623b         	str	r3, [r7, #0x20]
 800e3ea: 6bbb         	ldr	r3, [r7, #0x38]
 800e3ec: 61fb         	str	r3, [r7, #0x1c]
; 	if (preempt_ok != 0) {
 800e3ee: 69fb         	ldr	r3, [r7, #0x1c]
 800e3f0: 2b00         	cmp	r3, #0x0
 800e3f2: d001         	beq	0x800e3f8 <unready_thread+0xa8> @ imm = #0x2
; 		return true;
 800e3f4: 2301         	movs	r3, #0x1
 800e3f6: e026         	b	0x800e446 <unready_thread+0xf6> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e3f8: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800e488 <unready_thread+0x138>
 800e3fa: 689b         	ldr	r3, [r3, #0x8]
 800e3fc: 61bb         	str	r3, [r7, #0x18]
; 	return ret;
 800e3fe: 69bb         	ldr	r3, [r7, #0x18]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800e400: 4618         	mov	r0, r3
 800e402: f00b fce9    	bl	0x8019dd8 <z_is_thread_prevented_from_running> @ imm = #0xb9d2
 800e406: 4603         	mov	r3, r0
 800e408: 2b00         	cmp	r3, #0x0
 800e40a: d001         	beq	0x800e410 <unready_thread+0xc0> @ imm = #0x2
; 		return true;
 800e40c: 2301         	movs	r3, #0x1
 800e40e: e01a         	b	0x800e446 <unready_thread+0xf6> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e410: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800e488 <unready_thread+0x138>
 800e412: 689b         	ldr	r3, [r3, #0x8]
 800e414: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 800e416: 697b         	ldr	r3, [r7, #0x14]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800e418: 4618         	mov	r0, r3
 800e41a: f00b fcb1    	bl	0x8019d80 <thread_is_preemptible> @ imm = #0xb962
 800e41e: 4603         	mov	r3, r0
 800e420: 2b00         	cmp	r3, #0x0
 800e422: d105         	bne	0x800e430 <unready_thread+0xe0> @ imm = #0xa
 800e424: 6a38         	ldr	r0, [r7, #0x20]
 800e426: f00b fcbb    	bl	0x8019da0 <thread_is_metairq> @ imm = #0xb976
 800e42a: 4603         	mov	r3, r0
 800e42c: 2b00         	cmp	r3, #0x0
 800e42e: d001         	beq	0x800e434 <unready_thread+0xe4> @ imm = #0x2
; 		return true;
 800e430: 2301         	movs	r3, #0x1
 800e432: e008         	b	0x800e446 <unready_thread+0xf6> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800e434: 6a38         	ldr	r0, [r7, #0x20]
 800e436: f00b fce3    	bl	0x8019e00 <z_is_thread_timeout_active> @ imm = #0xb9c6
 800e43a: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800e43c: 2b00         	cmp	r3, #0x0
 800e43e: d001         	beq	0x800e444 <unready_thread+0xf4> @ imm = #0x2
; 		return true;
 800e440: 2301         	movs	r3, #0x1
 800e442: e000         	b	0x800e446 <unready_thread+0xf6> @ imm = #0x0
; 	return false;
 800e444: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800e446: 2b00         	cmp	r3, #0x0
 800e448: d010         	beq	0x800e46c <unready_thread+0x11c> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e44a: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800e488 <unready_thread+0x138>
 800e44c: 689b         	ldr	r3, [r3, #0x8]
 800e44e: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 800e450: 693b         	ldr	r3, [r7, #0x10]
; 		if (thread != arch_current_thread()) {
 800e452: 6a7a         	ldr	r2, [r7, #0x24]
 800e454: 429a         	cmp	r2, r3
 800e456: d002         	beq	0x800e45e <unready_thread+0x10e> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800e458: 6a78         	ldr	r0, [r7, #0x24]
 800e45a: f001 f821    	bl	0x800f4a0 <z_reset_time_slice> @ imm = #0x1042
; 		update_metairq_preempt(thread);
 800e45e: 6a78         	ldr	r0, [r7, #0x24]
 800e460: f00b fe43    	bl	0x801a0ea <update_metairq_preempt> @ imm = #0xbc86
; 		_kernel.ready_q.cache = thread;
 800e464: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800e488 <unready_thread+0x138>
 800e466: 6a7b         	ldr	r3, [r7, #0x24]
 800e468: 61d3         	str	r3, [r2, #0x1c]
; }
 800e46a: e005         	b	0x800e478 <unready_thread+0x128> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e46c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800e488 <unready_thread+0x138>
 800e46e: 689b         	ldr	r3, [r3, #0x8]
 800e470: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800e472: 68fb         	ldr	r3, [r7, #0xc]
; 		_kernel.ready_q.cache = arch_current_thread();
 800e474: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800e488 <unready_thread+0x138>
 800e476: 61d3         	str	r3, [r2, #0x1c]
; }
 800e478: bf00         	nop
; }
 800e47a: bf00         	nop
 800e47c: 3750         	adds	r7, #0x50
 800e47e: 46bd         	mov	sp, r7
 800e480: bd80         	pop	{r7, pc}
 800e482: bf00         	nop

0800e484 <$d>:
 800e484: 50 07 00 20  	.word	0x20000750
 800e488: 30 07 00 20  	.word	0x20000730

0800e48c <z_unpend_thread_no_timeout>:
; {
 800e48c: b580         	push	{r7, lr}
 800e48e: b090         	sub	sp, #0x40
 800e490: af00         	add	r7, sp, #0x0
 800e492: 6078         	str	r0, [r7, #0x4]
; 	K_SPINLOCK(&_sched_spinlock) {
 800e494: 2300         	movs	r3, #0x0
 800e496: 61bb         	str	r3, [r7, #0x18]
 800e498: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800e514 <z_unpend_thread_no_timeout+0x88>
 800e49a: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e49c: f3ef 8311    	mrs	r3, basepri
 800e4a0: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800e4a2: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 800e4a4: 637b         	str	r3, [r7, #0x34]
 800e4a6: 2310         	movs	r3, #0x10
 800e4a8: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e4aa: 6b3b         	ldr	r3, [r7, #0x30]
 800e4ac: f383 8812    	msr	basepri_max, r3
; }
 800e4b0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e4b2: f3bf 8f6f    	isb	sy
; }
 800e4b6: bf00         	nop
; 	return key;
 800e4b8: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 800e4ba: 60fb         	str	r3, [r7, #0xc]
 800e4bc: 6bfb         	ldr	r3, [r7, #0x3c]
 800e4be: 62fb         	str	r3, [r7, #0x2c]
; }
 800e4c0: bf00         	nop
 800e4c2: 6bfb         	ldr	r3, [r7, #0x3c]
 800e4c4: 62bb         	str	r3, [r7, #0x28]
; }
 800e4c6: bf00         	nop
; 	return k;
 800e4c8: 68fb         	ldr	r3, [r7, #0xc]
 800e4ca: 617b         	str	r3, [r7, #0x14]
; 	K_SPINLOCK(&_sched_spinlock) {
 800e4cc: e019         	b	0x800e502 <z_unpend_thread_no_timeout+0x76> @ imm = #0x32
; 		if (thread->base.pended_on != NULL) {
 800e4ce: 687b         	ldr	r3, [r7, #0x4]
 800e4d0: 689b         	ldr	r3, [r3, #0x8]
 800e4d2: 2b00         	cmp	r3, #0x0
 800e4d4: d002         	beq	0x800e4dc <z_unpend_thread_no_timeout+0x50> @ imm = #0x4
; 			unpend_thread_no_timeout(thread);
 800e4d6: 6878         	ldr	r0, [r7, #0x4]
 800e4d8: f00b fd57    	bl	0x8019f8a <unpend_thread_no_timeout> @ imm = #0xbaae
 800e4dc: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e514 <z_unpend_thread_no_timeout+0x88>
 800e4de: 627b         	str	r3, [r7, #0x24]
 800e4e0: 697b         	ldr	r3, [r7, #0x14]
 800e4e2: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800e4e4: 693b         	ldr	r3, [r7, #0x10]
 800e4e6: 623b         	str	r3, [r7, #0x20]
 800e4e8: 6a3b         	ldr	r3, [r7, #0x20]
 800e4ea: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e4ec: 69fb         	ldr	r3, [r7, #0x1c]
 800e4ee: f383 8811    	msr	basepri, r3
; }
 800e4f2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e4f4: f3bf 8f6f    	isb	sy
; }
 800e4f8: bf00         	nop
; }
 800e4fa: bf00         	nop
; }
 800e4fc: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800e4fe: 2301         	movs	r3, #0x1
 800e500: 61bb         	str	r3, [r7, #0x18]
 800e502: 69bb         	ldr	r3, [r7, #0x18]
 800e504: 2b00         	cmp	r3, #0x0
 800e506: d0e2         	beq	0x800e4ce <z_unpend_thread_no_timeout+0x42> @ imm = #-0x3c
; }
 800e508: bf00         	nop
 800e50a: bf00         	nop
 800e50c: 3740         	adds	r7, #0x40
 800e50e: 46bd         	mov	sp, r7
 800e510: bd80         	pop	{r7, pc}
 800e512: bf00         	nop

0800e514 <$d>:
 800e514: 2c 11 00 20  	.word	0x2000112c

0800e518 <z_sched_wake_thread>:
; {
 800e518: b580         	push	{r7, lr}
 800e51a: b090         	sub	sp, #0x40
 800e51c: af00         	add	r7, sp, #0x0
 800e51e: 6078         	str	r0, [r7, #0x4]
 800e520: 460b         	mov	r3, r1
 800e522: 70fb         	strb	r3, [r7, #0x3]
; 	K_SPINLOCK(&_sched_spinlock) {
 800e524: 2300         	movs	r3, #0x0
 800e526: 617b         	str	r3, [r7, #0x14]
 800e528: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x800e60c <z_sched_wake_thread+0xf4>
 800e52a: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e52c: f3ef 8311    	mrs	r3, basepri
 800e530: 637b         	str	r3, [r7, #0x34]
;   return(result);
 800e532: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 800e534: 633b         	str	r3, [r7, #0x30]
 800e536: 2310         	movs	r3, #0x10
 800e538: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e53a: 6afb         	ldr	r3, [r7, #0x2c]
 800e53c: f383 8812    	msr	basepri_max, r3
; }
 800e540: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e542: f3bf 8f6f    	isb	sy
; }
 800e546: bf00         	nop
; 	return key;
 800e548: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 800e54a: 60bb         	str	r3, [r7, #0x8]
 800e54c: 6bbb         	ldr	r3, [r7, #0x38]
 800e54e: 62bb         	str	r3, [r7, #0x28]
; }
 800e550: bf00         	nop
 800e552: 6bbb         	ldr	r3, [r7, #0x38]
 800e554: 627b         	str	r3, [r7, #0x24]
; }
 800e556: bf00         	nop
; 	return k;
 800e558: 68bb         	ldr	r3, [r7, #0x8]
 800e55a: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 800e55c: e04d         	b	0x800e5fa <z_sched_wake_thread+0xe2> @ imm = #0x9a
; 		bool killed = (thread->base.thread_state &
 800e55e: 687b         	ldr	r3, [r7, #0x4]
 800e560: 7b5b         	ldrb	r3, [r3, #0xd]
 800e562: f003 0328    	and	r3, r3, #0x28
 800e566: 2b00         	cmp	r3, #0x0
 800e568: bf14         	ite	ne
 800e56a: 2301         	movne	r3, #0x1
 800e56c: 2300         	moveq	r3, #0x0
 800e56e: f887 303f    	strb.w	r3, [r7, #0x3f]
; 		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
 800e572: 687b         	ldr	r3, [r7, #0x4]
 800e574: f893 307c    	ldrb.w	r3, [r3, #0x7c]
 800e578: 2b00         	cmp	r3, #0x0
 800e57a: d004         	beq	0x800e586 <z_sched_wake_thread+0x6e> @ imm = #0x8
 800e57c: 78fb         	ldrb	r3, [r7, #0x3]
 800e57e: 2b00         	cmp	r3, #0x0
 800e580: d001         	beq	0x800e586 <z_sched_wake_thread+0x6e> @ imm = #0x2
 800e582: 2301         	movs	r3, #0x1
 800e584: e000         	b	0x800e588 <z_sched_wake_thread+0x70> @ imm = #0x0
 800e586: 2300         	movs	r3, #0x0
 800e588: f887 303e    	strb.w	r3, [r7, #0x3e]
 800e58c: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 800e590: f003 0301    	and	r3, r3, #0x1
 800e594: f887 303e    	strb.w	r3, [r7, #0x3e]
; 		thread->no_wake_on_timeout = false;
 800e598: 687b         	ldr	r3, [r7, #0x4]
 800e59a: 2200         	movs	r2, #0x0
 800e59c: f883 207c    	strb.w	r2, [r3, #0x7c]
; 		if (do_nothing) {
 800e5a0: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 800e5a4: 2b00         	cmp	r3, #0x0
 800e5a6: d114         	bne	0x800e5d2 <z_sched_wake_thread+0xba> @ imm = #0x28
; 		if (!killed) {
 800e5a8: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800e5ac: f083 0301    	eor	r3, r3, #0x1
 800e5b0: b2db         	uxtb	r3, r3
 800e5b2: 2b00         	cmp	r3, #0x0
 800e5b4: d00e         	beq	0x800e5d4 <z_sched_wake_thread+0xbc> @ imm = #0x1c
; 			if (thread->base.pended_on != NULL) {
 800e5b6: 687b         	ldr	r3, [r7, #0x4]
 800e5b8: 689b         	ldr	r3, [r3, #0x8]
 800e5ba: 2b00         	cmp	r3, #0x0
 800e5bc: d002         	beq	0x800e5c4 <z_sched_wake_thread+0xac> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 800e5be: 6878         	ldr	r0, [r7, #0x4]
 800e5c0: f00b fce3    	bl	0x8019f8a <unpend_thread_no_timeout> @ imm = #0xb9c6
; 			z_mark_thread_as_not_suspended(thread);
 800e5c4: 6878         	ldr	r0, [r7, #0x4]
 800e5c6: f00b fc85    	bl	0x8019ed4 <z_mark_thread_as_not_suspended> @ imm = #0xb90a
; 			ready_thread(thread);
 800e5ca: 6878         	ldr	r0, [r7, #0x4]
 800e5cc: f7ff fb4a    	bl	0x800dc64 <ready_thread> @ imm = #-0x96c
 800e5d0: e000         	b	0x800e5d4 <z_sched_wake_thread+0xbc> @ imm = #0x0
; 			continue;
 800e5d2: bf00         	nop
 800e5d4: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e60c <z_sched_wake_thread+0xf4>
 800e5d6: 623b         	str	r3, [r7, #0x20]
 800e5d8: 693b         	ldr	r3, [r7, #0x10]
 800e5da: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800e5dc: 68fb         	ldr	r3, [r7, #0xc]
 800e5de: 61fb         	str	r3, [r7, #0x1c]
 800e5e0: 69fb         	ldr	r3, [r7, #0x1c]
 800e5e2: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e5e4: 69bb         	ldr	r3, [r7, #0x18]
 800e5e6: f383 8811    	msr	basepri, r3
; }
 800e5ea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e5ec: f3bf 8f6f    	isb	sy
; }
 800e5f0: bf00         	nop
; }
 800e5f2: bf00         	nop
; }
 800e5f4: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800e5f6: 2301         	movs	r3, #0x1
 800e5f8: 617b         	str	r3, [r7, #0x14]
 800e5fa: 697b         	ldr	r3, [r7, #0x14]
 800e5fc: 2b00         	cmp	r3, #0x0
 800e5fe: d0ae         	beq	0x800e55e <z_sched_wake_thread+0x46> @ imm = #-0xa4
; }
 800e600: bf00         	nop
 800e602: bf00         	nop
 800e604: 3740         	adds	r7, #0x40
 800e606: 46bd         	mov	sp, r7
 800e608: bd80         	pop	{r7, pc}
 800e60a: bf00         	nop

0800e60c <$d>:
 800e60c: 2c 11 00 20  	.word	0x2000112c

0800e610 <z_pend_curr>:
; {
 800e610: b580         	push	{r7, lr}
 800e612: b092         	sub	sp, #0x48
 800e614: af00         	add	r7, sp, #0x0
 800e616: 60f8         	str	r0, [r7, #0xc]
 800e618: 60b9         	str	r1, [r7, #0x8]
 800e61a: 607a         	str	r2, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e61c: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800e690 <z_pend_curr+0x80>
 800e61e: 689b         	ldr	r3, [r3, #0x8]
 800e620: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 800e622: 69fb         	ldr	r3, [r7, #0x1c]
; 	pending_current = arch_current_thread();
 800e624: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800e694 <z_pend_curr+0x84>
 800e626: 6013         	str	r3, [r2]
 800e628: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800e698 <z_pend_curr+0x88>
 800e62a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e62c: f3ef 8311    	mrs	r3, basepri
 800e630: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800e632: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800e634: 62fb         	str	r3, [r7, #0x2c]
 800e636: 2310         	movs	r3, #0x10
 800e638: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e63a: 6abb         	ldr	r3, [r7, #0x28]
 800e63c: f383 8812    	msr	basepri_max, r3
; }
 800e640: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e642: f3bf 8f6f    	isb	sy
; }
 800e646: bf00         	nop
; 	return key;
 800e648: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800e64a: 61bb         	str	r3, [r7, #0x18]
 800e64c: 6b7b         	ldr	r3, [r7, #0x34]
 800e64e: 627b         	str	r3, [r7, #0x24]
; }
 800e650: bf00         	nop
 800e652: 6b7b         	ldr	r3, [r7, #0x34]
 800e654: 623b         	str	r3, [r7, #0x20]
; }
 800e656: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e658: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e690 <z_pend_curr+0x80>
 800e65a: 689b         	ldr	r3, [r3, #0x8]
 800e65c: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 800e65e: 6bb8         	ldr	r0, [r7, #0x38]
; 	pend_locked(arch_current_thread(), wait_q, timeout);
 800e660: e9d7 2314    	ldrd	r2, r3, [r7, #80]
 800e664: 6879         	ldr	r1, [r7, #0x4]
 800e666: f00b fdc0    	bl	0x801a1ea <pend_locked> @ imm = #0xbb80
 800e66a: 68fb         	ldr	r3, [r7, #0xc]
 800e66c: 63fb         	str	r3, [r7, #0x3c]
; }
 800e66e: bf00         	nop
 800e670: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800e698 <z_pend_curr+0x88>
 800e672: 647b         	str	r3, [r7, #0x44]
 800e674: 68bb         	ldr	r3, [r7, #0x8]
 800e676: 617b         	str	r3, [r7, #0x14]
 800e678: 6c7b         	ldr	r3, [r7, #0x44]
 800e67a: 643b         	str	r3, [r7, #0x40]
 800e67c: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800e67e: 697b         	ldr	r3, [r7, #0x14]
 800e680: 4618         	mov	r0, r3
 800e682: f00b fca9    	bl	0x8019fd8 <z_swap_irqlock> @ imm = #0xb952
 800e686: 4603         	mov	r3, r0
; }
 800e688: 4618         	mov	r0, r3
 800e68a: 3748         	adds	r7, #0x48
 800e68c: 46bd         	mov	sp, r7
 800e68e: bd80         	pop	{r7, pc}

0800e690 <$d>:
 800e690: 30 07 00 20  	.word	0x20000730
 800e694: 38 11 00 20  	.word	0x20001138
 800e698: 2c 11 00 20  	.word	0x2000112c

0800e69c <z_thread_prio_set>:
; {
 800e69c: b580         	push	{r7, lr}
 800e69e: b0a8         	sub	sp, #0xa0
 800e6a0: af00         	add	r7, sp, #0x0
 800e6a2: 6078         	str	r0, [r7, #0x4]
 800e6a4: 6039         	str	r1, [r7]
; 	bool need_sched = 0;
 800e6a6: 2300         	movs	r3, #0x0
 800e6a8: f887 309f    	strb.w	r3, [r7, #0x9f]
; 	int old_prio = thread->base.prio;
 800e6ac: 687b         	ldr	r3, [r7, #0x4]
 800e6ae: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800e6b2: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	K_SPINLOCK(&_sched_spinlock) {
 800e6b6: 2300         	movs	r3, #0x0
 800e6b8: 617b         	str	r3, [r7, #0x14]
 800e6ba: 4b95         	ldr	r3, [pc, #0x254]        @ 0x800e910 <z_thread_prio_set+0x274>
 800e6bc: f8c7 3094    	str.w	r3, [r7, #0x94]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e6c0: f3ef 8311    	mrs	r3, basepri
 800e6c4: f8c7 3090    	str.w	r3, [r7, #0x90]
;   return(result);
 800e6c8: f8d7 3090    	ldr.w	r3, [r7, #0x90]
; 	key = __get_BASEPRI();
 800e6cc: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800e6d0: 2310         	movs	r3, #0x10
 800e6d2: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e6d6: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800e6da: f383 8812    	msr	basepri_max, r3
; }
 800e6de: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e6e0: f3bf 8f6f    	isb	sy
; }
 800e6e4: bf00         	nop
; 	return key;
 800e6e6: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	k.key = arch_irq_lock();
 800e6ea: 60bb         	str	r3, [r7, #0x8]
 800e6ec: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800e6f0: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 800e6f4: bf00         	nop
 800e6f6: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800e6fa: f8c7 3080    	str.w	r3, [r7, #0x80]
; }
 800e6fe: bf00         	nop
; 	return k;
 800e700: 68bb         	ldr	r3, [r7, #0x8]
 800e702: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 800e704: e0fa         	b	0x800e8fc <z_thread_prio_set+0x260> @ imm = #0x1f4
; 		need_sched = z_is_thread_ready(thread);
 800e706: 6878         	ldr	r0, [r7, #0x4]
 800e708: f00b fb93    	bl	0x8019e32 <z_is_thread_ready> @ imm = #0xb726
 800e70c: 4603         	mov	r3, r0
 800e70e: f887 309f    	strb.w	r3, [r7, #0x9f]
; 		if (need_sched) {
 800e712: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 800e716: 2b00         	cmp	r3, #0x0
 800e718: f000 80d9    	beq.w	0x800e8ce <z_thread_prio_set+0x232> @ imm = #0x1b2
 800e71c: 687b         	ldr	r3, [r7, #0x4]
 800e71e: 667b         	str	r3, [r7, #0x64]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800e720: 6e7b         	ldr	r3, [r7, #0x64]
 800e722: 7b5b         	ldrb	r3, [r3, #0xd]
 800e724: f003 037f    	and	r3, r3, #0x7f
 800e728: b2da         	uxtb	r2, r3
 800e72a: 6e7b         	ldr	r3, [r7, #0x64]
 800e72c: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800e72e: 6e78         	ldr	r0, [r7, #0x64]
 800e730: f00b fc98    	bl	0x801a064 <should_queue_thread> @ imm = #0xb930
 800e734: 4603         	mov	r3, r0
 800e736: 2b00         	cmp	r3, #0x0
 800e738: d00d         	beq	0x800e756 <z_thread_prio_set+0xba> @ imm = #0x1a
 800e73a: 6e7b         	ldr	r3, [r7, #0x64]
 800e73c: 663b         	str	r3, [r7, #0x60]
 800e73e: 6e3b         	ldr	r3, [r7, #0x60]
 800e740: 65fb         	str	r3, [r7, #0x5c]
; 	return &_kernel.ready_q.runq;
 800e742: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800e914 <z_thread_prio_set+0x278>
 800e744: 65bb         	str	r3, [r7, #0x58]
 800e746: 6e3b         	ldr	r3, [r7, #0x60]
 800e748: 657b         	str	r3, [r7, #0x54]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800e74a: 6d7b         	ldr	r3, [r7, #0x54]
 800e74c: 4618         	mov	r0, r3
 800e74e: f00b fac9    	bl	0x8019ce4 <sys_dlist_remove> @ imm = #0xb592
; }
 800e752: bf00         	nop
; }
 800e754: bf00         	nop
; }
 800e756: bf00         	nop
; 				thread->base.prio = prio;
 800e758: 683b         	ldr	r3, [r7]
 800e75a: b25a         	sxtb	r2, r3
 800e75c: 687b         	ldr	r3, [r7, #0x4]
 800e75e: 739a         	strb	r2, [r3, #0xe]
 800e760: 687b         	ldr	r3, [r7, #0x4]
 800e762: 67fb         	str	r3, [r7, #0x7c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800e764: 6ffb         	ldr	r3, [r7, #0x7c]
 800e766: 7b5b         	ldrb	r3, [r3, #0xd]
 800e768: f063 037f    	orn	r3, r3, #0x7f
 800e76c: b2da         	uxtb	r2, r3
 800e76e: 6ffb         	ldr	r3, [r7, #0x7c]
 800e770: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800e772: 6ff8         	ldr	r0, [r7, #0x7c]
 800e774: f00b fc76    	bl	0x801a064 <should_queue_thread> @ imm = #0xb8ec
 800e778: 4603         	mov	r3, r0
 800e77a: 2b00         	cmp	r3, #0x0
 800e77c: d042         	beq	0x800e804 <z_thread_prio_set+0x168> @ imm = #0x84
 800e77e: 6ffb         	ldr	r3, [r7, #0x7c]
 800e780: 67bb         	str	r3, [r7, #0x78]
 800e782: 6fbb         	ldr	r3, [r7, #0x78]
 800e784: 677b         	str	r3, [r7, #0x74]
; 	return &_kernel.ready_q.runq;
 800e786: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x800e914 <z_thread_prio_set+0x278>
 800e788: 673b         	str	r3, [r7, #0x70]
 800e78a: 6fbb         	ldr	r3, [r7, #0x78]
 800e78c: 66fb         	str	r3, [r7, #0x6c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800e78e: 6f38         	ldr	r0, [r7, #0x70]
 800e790: f00b fa3e    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xb47c
 800e794: 4603         	mov	r3, r0
 800e796: 2b00         	cmp	r3, #0x0
 800e798: d004         	beq	0x800e7a4 <z_thread_prio_set+0x108> @ imm = #0x8
 800e79a: 6f38         	ldr	r0, [r7, #0x70]
 800e79c: f00b fa38    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xb470
 800e7a0: 4603         	mov	r3, r0
 800e7a2: e000         	b	0x800e7a6 <z_thread_prio_set+0x10a> @ imm = #0x0
 800e7a4: 2300         	movs	r3, #0x0
 800e7a6: 66bb         	str	r3, [r7, #0x68]
 800e7a8: e023         	b	0x800e7f2 <z_thread_prio_set+0x156> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800e7aa: 6eb9         	ldr	r1, [r7, #0x68]
 800e7ac: 6ef8         	ldr	r0, [r7, #0x6c]
 800e7ae: f00b fc3e    	bl	0x801a02e <z_sched_prio_cmp> @ imm = #0xb87c
 800e7b2: 4603         	mov	r3, r0
 800e7b4: 2b00         	cmp	r3, #0x0
 800e7b6: dd06         	ble	0x800e7c6 <z_thread_prio_set+0x12a> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800e7b8: 6ebb         	ldr	r3, [r7, #0x68]
 800e7ba: 6efa         	ldr	r2, [r7, #0x6c]
 800e7bc: 4611         	mov	r1, r2
 800e7be: 4618         	mov	r0, r3
 800e7c0: f00b fa77    	bl	0x8019cb2 <sys_dlist_insert> @ imm = #0xb4ee
; 			return;
 800e7c4: e01d         	b	0x800e802 <z_thread_prio_set+0x166> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800e7c6: 6ebb         	ldr	r3, [r7, #0x68]
 800e7c8: 2b00         	cmp	r3, #0x0
 800e7ca: d010         	beq	0x800e7ee <z_thread_prio_set+0x152> @ imm = #0x20
 800e7cc: 6ebb         	ldr	r3, [r7, #0x68]
 800e7ce: 4619         	mov	r1, r3
 800e7d0: 6f38         	ldr	r0, [r7, #0x70]
 800e7d2: f00b fa42    	bl	0x8019c5a <sys_dlist_peek_next> @ imm = #0xb484
 800e7d6: 4603         	mov	r3, r0
 800e7d8: 2b00         	cmp	r3, #0x0
 800e7da: d006         	beq	0x800e7ea <z_thread_prio_set+0x14e> @ imm = #0xc
 800e7dc: 6ebb         	ldr	r3, [r7, #0x68]
 800e7de: 4619         	mov	r1, r3
 800e7e0: 6f38         	ldr	r0, [r7, #0x70]
 800e7e2: f00b fa3a    	bl	0x8019c5a <sys_dlist_peek_next> @ imm = #0xb474
 800e7e6: 4603         	mov	r3, r0
 800e7e8: e002         	b	0x800e7f0 <z_thread_prio_set+0x154> @ imm = #0x4
 800e7ea: 2300         	movs	r3, #0x0
 800e7ec: e000         	b	0x800e7f0 <z_thread_prio_set+0x154> @ imm = #0x0
 800e7ee: 2300         	movs	r3, #0x0
 800e7f0: 66bb         	str	r3, [r7, #0x68]
 800e7f2: 6ebb         	ldr	r3, [r7, #0x68]
 800e7f4: 2b00         	cmp	r3, #0x0
 800e7f6: d1d8         	bne	0x800e7aa <z_thread_prio_set+0x10e> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800e7f8: 6efb         	ldr	r3, [r7, #0x6c]
 800e7fa: 4619         	mov	r1, r3
 800e7fc: 6f38         	ldr	r0, [r7, #0x70]
 800e7fe: f00b fa3f    	bl	0x8019c80 <sys_dlist_append> @ imm = #0xb47e
; }
 800e802: bf00         	nop
; }
 800e804: bf00         	nop
 800e806: 2301         	movs	r3, #0x1
 800e808: 653b         	str	r3, [r7, #0x50]
; 	return &_kernel.ready_q.runq;
 800e80a: 4b42         	ldr	r3, [pc, #0x108]        @ 0x800e914 <z_thread_prio_set+0x278>
 800e80c: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800e80e: 2300         	movs	r3, #0x0
 800e810: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800e812: 6cf8         	ldr	r0, [r7, #0x4c]
 800e814: f00b f9fc    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xb3f8
 800e818: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800e81a: 6c7b         	ldr	r3, [r7, #0x44]
 800e81c: 2b00         	cmp	r3, #0x0
 800e81e: d001         	beq	0x800e824 <z_thread_prio_set+0x188> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800e820: 6c7b         	ldr	r3, [r7, #0x44]
 800e822: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800e824: 6cbb         	ldr	r3, [r7, #0x48]
; 	return _priq_run_best(curr_cpu_runq());
 800e826: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800e828: 643b         	str	r3, [r7, #0x40]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800e82a: 6c3b         	ldr	r3, [r7, #0x40]
 800e82c: 2b00         	cmp	r3, #0x0
 800e82e: d102         	bne	0x800e836 <z_thread_prio_set+0x19a> @ imm = #0x4
 800e830: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800e918 <z_thread_prio_set+0x27c>
 800e832: 68db         	ldr	r3, [r3, #0xc]
 800e834: e000         	b	0x800e838 <z_thread_prio_set+0x19c> @ imm = #0x0
 800e836: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *thread = next_up();
 800e838: 63fb         	str	r3, [r7, #0x3c]
 800e83a: 6bfb         	ldr	r3, [r7, #0x3c]
 800e83c: 63bb         	str	r3, [r7, #0x38]
 800e83e: 6d3b         	ldr	r3, [r7, #0x50]
 800e840: 637b         	str	r3, [r7, #0x34]
; 	if (preempt_ok != 0) {
 800e842: 6b7b         	ldr	r3, [r7, #0x34]
 800e844: 2b00         	cmp	r3, #0x0
 800e846: d001         	beq	0x800e84c <z_thread_prio_set+0x1b0> @ imm = #0x2
; 		return true;
 800e848: 2301         	movs	r3, #0x1
 800e84a: e026         	b	0x800e89a <z_thread_prio_set+0x1fe> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e84c: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x800e918 <z_thread_prio_set+0x27c>
 800e84e: 689b         	ldr	r3, [r3, #0x8]
 800e850: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 800e852: 6b3b         	ldr	r3, [r7, #0x30]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800e854: 4618         	mov	r0, r3
 800e856: f00b fabf    	bl	0x8019dd8 <z_is_thread_prevented_from_running> @ imm = #0xb57e
 800e85a: 4603         	mov	r3, r0
 800e85c: 2b00         	cmp	r3, #0x0
 800e85e: d001         	beq	0x800e864 <z_thread_prio_set+0x1c8> @ imm = #0x2
; 		return true;
 800e860: 2301         	movs	r3, #0x1
 800e862: e01a         	b	0x800e89a <z_thread_prio_set+0x1fe> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e864: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800e918 <z_thread_prio_set+0x27c>
 800e866: 689b         	ldr	r3, [r3, #0x8]
 800e868: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 800e86a: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800e86c: 4618         	mov	r0, r3
 800e86e: f00b fa87    	bl	0x8019d80 <thread_is_preemptible> @ imm = #0xb50e
 800e872: 4603         	mov	r3, r0
 800e874: 2b00         	cmp	r3, #0x0
 800e876: d105         	bne	0x800e884 <z_thread_prio_set+0x1e8> @ imm = #0xa
 800e878: 6bb8         	ldr	r0, [r7, #0x38]
 800e87a: f00b fa91    	bl	0x8019da0 <thread_is_metairq> @ imm = #0xb522
 800e87e: 4603         	mov	r3, r0
 800e880: 2b00         	cmp	r3, #0x0
 800e882: d001         	beq	0x800e888 <z_thread_prio_set+0x1ec> @ imm = #0x2
; 		return true;
 800e884: 2301         	movs	r3, #0x1
 800e886: e008         	b	0x800e89a <z_thread_prio_set+0x1fe> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800e888: 6bb8         	ldr	r0, [r7, #0x38]
 800e88a: f00b fab9    	bl	0x8019e00 <z_is_thread_timeout_active> @ imm = #0xb572
 800e88e: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800e890: 2b00         	cmp	r3, #0x0
 800e892: d001         	beq	0x800e898 <z_thread_prio_set+0x1fc> @ imm = #0x2
; 		return true;
 800e894: 2301         	movs	r3, #0x1
 800e896: e000         	b	0x800e89a <z_thread_prio_set+0x1fe> @ imm = #0x0
; 	return false;
 800e898: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800e89a: 2b00         	cmp	r3, #0x0
 800e89c: d010         	beq	0x800e8c0 <z_thread_prio_set+0x224> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e89e: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800e918 <z_thread_prio_set+0x27c>
 800e8a0: 689b         	ldr	r3, [r3, #0x8]
 800e8a2: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800e8a4: 6abb         	ldr	r3, [r7, #0x28]
; 		if (thread != arch_current_thread()) {
 800e8a6: 6bfa         	ldr	r2, [r7, #0x3c]
 800e8a8: 429a         	cmp	r2, r3
 800e8aa: d002         	beq	0x800e8b2 <z_thread_prio_set+0x216> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800e8ac: 6bf8         	ldr	r0, [r7, #0x3c]
 800e8ae: f000 fdf7    	bl	0x800f4a0 <z_reset_time_slice> @ imm = #0xbee
; 		update_metairq_preempt(thread);
 800e8b2: 6bf8         	ldr	r0, [r7, #0x3c]
 800e8b4: f00b fc19    	bl	0x801a0ea <update_metairq_preempt> @ imm = #0xb832
; 		_kernel.ready_q.cache = thread;
 800e8b8: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800e918 <z_thread_prio_set+0x27c>
 800e8ba: 6bfb         	ldr	r3, [r7, #0x3c]
 800e8bc: 61d3         	str	r3, [r2, #0x1c]
; }
 800e8be: e00a         	b	0x800e8d6 <z_thread_prio_set+0x23a> @ imm = #0x14
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e8c0: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800e918 <z_thread_prio_set+0x27c>
 800e8c2: 689b         	ldr	r3, [r3, #0x8]
 800e8c4: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800e8c6: 6a7b         	ldr	r3, [r7, #0x24]
; 		_kernel.ready_q.cache = arch_current_thread();
 800e8c8: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800e918 <z_thread_prio_set+0x27c>
 800e8ca: 61d3         	str	r3, [r2, #0x1c]
; }
 800e8cc: e003         	b	0x800e8d6 <z_thread_prio_set+0x23a> @ imm = #0x6
; 			thread->base.prio = prio;
 800e8ce: 683b         	ldr	r3, [r7]
 800e8d0: b25a         	sxtb	r2, r3
 800e8d2: 687b         	ldr	r3, [r7, #0x4]
 800e8d4: 739a         	strb	r2, [r3, #0xe]
 800e8d6: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800e910 <z_thread_prio_set+0x274>
 800e8d8: 623b         	str	r3, [r7, #0x20]
 800e8da: 693b         	ldr	r3, [r7, #0x10]
 800e8dc: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800e8de: 68fb         	ldr	r3, [r7, #0xc]
 800e8e0: 61fb         	str	r3, [r7, #0x1c]
 800e8e2: 69fb         	ldr	r3, [r7, #0x1c]
 800e8e4: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e8e6: 69bb         	ldr	r3, [r7, #0x18]
 800e8e8: f383 8811    	msr	basepri, r3
; }
 800e8ec: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e8ee: f3bf 8f6f    	isb	sy
; }
 800e8f2: bf00         	nop
; }
 800e8f4: bf00         	nop
; }
 800e8f6: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800e8f8: 2301         	movs	r3, #0x1
 800e8fa: 617b         	str	r3, [r7, #0x14]
 800e8fc: 697b         	ldr	r3, [r7, #0x14]
 800e8fe: 2b00         	cmp	r3, #0x0
 800e900: f43f af01    	beq.w	0x800e706 <z_thread_prio_set+0x6a> @ imm = #-0x1fe
; 	return need_sched;
 800e904: f897 309f    	ldrb.w	r3, [r7, #0x9f]
; }
 800e908: 4618         	mov	r0, r3
 800e90a: 37a0         	adds	r7, #0xa0
 800e90c: 46bd         	mov	sp, r7
 800e90e: bd80         	pop	{r7, pc}

0800e910 <$d>:
 800e910: 2c 11 00 20  	.word	0x2000112c
 800e914: 50 07 00 20  	.word	0x20000750
 800e918: 30 07 00 20  	.word	0x20000730

0800e91c <need_swap>:
; {
 800e91c: b480         	push	{r7}
 800e91e: b083         	sub	sp, #0xc
 800e920: af00         	add	r7, sp, #0x0
; 	new_thread = _kernel.ready_q.cache;
 800e922: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800e948 <need_swap+0x2c>
 800e924: 69db         	ldr	r3, [r3, #0x1c]
 800e926: 607b         	str	r3, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800e928: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800e948 <need_swap+0x2c>
 800e92a: 689b         	ldr	r3, [r3, #0x8]
 800e92c: 603b         	str	r3, [r7]
; 	return ret;
 800e92e: 683b         	ldr	r3, [r7]
; 	return new_thread != arch_current_thread();
 800e930: 687a         	ldr	r2, [r7, #0x4]
 800e932: 429a         	cmp	r2, r3
 800e934: bf14         	ite	ne
 800e936: 2301         	movne	r3, #0x1
 800e938: 2300         	moveq	r3, #0x0
 800e93a: b2db         	uxtb	r3, r3
; }
 800e93c: 4618         	mov	r0, r3
 800e93e: 370c         	adds	r7, #0xc
 800e940: 46bd         	mov	sp, r7
 800e942: bc80         	pop	{r7}
 800e944: 4770         	bx	lr
 800e946: bf00         	nop

0800e948 <$d>:
 800e948: 30 07 00 20  	.word	0x20000730

0800e94c <k_sched_lock>:
; {
 800e94c: b580         	push	{r7, lr}
 800e94e: b08e         	sub	sp, #0x38
 800e950: af00         	add	r7, sp, #0x0
; 	K_SPINLOCK(&_sched_spinlock) {
 800e952: 2300         	movs	r3, #0x0
 800e954: 613b         	str	r3, [r7, #0x10]
 800e956: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800e9c8 <k_sched_lock+0x7c>
 800e958: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e95a: f3ef 8311    	mrs	r3, basepri
 800e95e: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800e960: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800e962: 62fb         	str	r3, [r7, #0x2c]
 800e964: 2310         	movs	r3, #0x10
 800e966: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e968: 6abb         	ldr	r3, [r7, #0x28]
 800e96a: f383 8812    	msr	basepri_max, r3
; }
 800e96e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e970: f3bf 8f6f    	isb	sy
; }
 800e974: bf00         	nop
; 	return key;
 800e976: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800e978: 607b         	str	r3, [r7, #0x4]
 800e97a: 6b7b         	ldr	r3, [r7, #0x34]
 800e97c: 627b         	str	r3, [r7, #0x24]
; }
 800e97e: bf00         	nop
 800e980: 6b7b         	ldr	r3, [r7, #0x34]
 800e982: 623b         	str	r3, [r7, #0x20]
; }
 800e984: bf00         	nop
; 	return k;
 800e986: 687b         	ldr	r3, [r7, #0x4]
 800e988: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&_sched_spinlock) {
 800e98a: e014         	b	0x800e9b6 <k_sched_lock+0x6a> @ imm = #0x28
; 		z_sched_lock();
 800e98c: f7ff f844    	bl	0x800da18 <z_sched_lock> @ imm = #-0xf78
 800e990: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e9c8 <k_sched_lock+0x7c>
 800e992: 61fb         	str	r3, [r7, #0x1c]
 800e994: 68fb         	ldr	r3, [r7, #0xc]
 800e996: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800e998: 68bb         	ldr	r3, [r7, #0x8]
 800e99a: 61bb         	str	r3, [r7, #0x18]
 800e99c: 69bb         	ldr	r3, [r7, #0x18]
 800e99e: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e9a0: 697b         	ldr	r3, [r7, #0x14]
 800e9a2: f383 8811    	msr	basepri, r3
; }
 800e9a6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e9a8: f3bf 8f6f    	isb	sy
; }
 800e9ac: bf00         	nop
; }
 800e9ae: bf00         	nop
; }
 800e9b0: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800e9b2: 2301         	movs	r3, #0x1
 800e9b4: 613b         	str	r3, [r7, #0x10]
 800e9b6: 693b         	ldr	r3, [r7, #0x10]
 800e9b8: 2b00         	cmp	r3, #0x0
 800e9ba: d0e7         	beq	0x800e98c <k_sched_lock+0x40> @ imm = #-0x32
; }
 800e9bc: bf00         	nop
 800e9be: bf00         	nop
 800e9c0: 3738         	adds	r7, #0x38
 800e9c2: 46bd         	mov	sp, r7
 800e9c4: bd80         	pop	{r7, pc}
 800e9c6: bf00         	nop

0800e9c8 <$d>:
 800e9c8: 2c 11 00 20  	.word	0x2000112c

0800e9cc <k_sched_unlock>:
; {
 800e9cc: b580         	push	{r7, lr}
 800e9ce: b0a4         	sub	sp, #0x90
 800e9d0: af06         	add	r7, sp, #0x18
; 	K_SPINLOCK(&_sched_spinlock) {
 800e9d2: 2300         	movs	r3, #0x0
 800e9d4: 60fb         	str	r3, [r7, #0xc]
 800e9d6: 4b66         	ldr	r3, [pc, #0x198]        @ 0x800eb70 <k_sched_unlock+0x1a4>
 800e9d8: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e9da: f3ef 8311    	mrs	r3, basepri
 800e9de: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 800e9e0: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 800e9e2: 667b         	str	r3, [r7, #0x64]
 800e9e4: 2310         	movs	r3, #0x10
 800e9e6: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e9e8: 6e3b         	ldr	r3, [r7, #0x60]
 800e9ea: f383 8812    	msr	basepri_max, r3
; }
 800e9ee: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e9f0: f3bf 8f6f    	isb	sy
; }
 800e9f4: bf00         	nop
; 	return key;
 800e9f6: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 800e9f8: 603b         	str	r3, [r7]
 800e9fa: 6efb         	ldr	r3, [r7, #0x6c]
 800e9fc: 65fb         	str	r3, [r7, #0x5c]
; }
 800e9fe: bf00         	nop
 800ea00: 6efb         	ldr	r3, [r7, #0x6c]
 800ea02: 65bb         	str	r3, [r7, #0x58]
; }
 800ea04: bf00         	nop
; 	return k;
 800ea06: 683b         	ldr	r3, [r7]
 800ea08: 60bb         	str	r3, [r7, #0x8]
; 	K_SPINLOCK(&_sched_spinlock) {
 800ea0a: e07e         	b	0x800eb0a <k_sched_unlock+0x13e> @ imm = #0xfc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ea0c: 4b59         	ldr	r3, [pc, #0x164]        @ 0x800eb74 <k_sched_unlock+0x1a8>
 800ea0e: 689b         	ldr	r3, [r3, #0x8]
 800ea10: 61bb         	str	r3, [r7, #0x18]
; 	return ret;
 800ea12: 69bb         	ldr	r3, [r7, #0x18]
; 		++arch_current_thread()->base.sched_locked;
 800ea14: 7bda         	ldrb	r2, [r3, #0xf]
 800ea16: 3201         	adds	r2, #0x1
 800ea18: b2d2         	uxtb	r2, r2
 800ea1a: 73da         	strb	r2, [r3, #0xf]
 800ea1c: 2300         	movs	r3, #0x0
 800ea1e: 64bb         	str	r3, [r7, #0x48]
; 	return &_kernel.ready_q.runq;
 800ea20: 4b55         	ldr	r3, [pc, #0x154]        @ 0x800eb78 <k_sched_unlock+0x1ac>
 800ea22: 647b         	str	r3, [r7, #0x44]
; 	struct k_thread *thread = NULL;
 800ea24: 2300         	movs	r3, #0x0
 800ea26: 643b         	str	r3, [r7, #0x40]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800ea28: 6c78         	ldr	r0, [r7, #0x44]
 800ea2a: f00b f8f1    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xb1e2
 800ea2e: 63f8         	str	r0, [r7, #0x3c]
; 	if (n != NULL) {
 800ea30: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea32: 2b00         	cmp	r3, #0x0
 800ea34: d001         	beq	0x800ea3a <k_sched_unlock+0x6e> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800ea36: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea38: 643b         	str	r3, [r7, #0x40]
; 	return thread;
 800ea3a: 6c3b         	ldr	r3, [r7, #0x40]
; 	return _priq_run_best(curr_cpu_runq());
 800ea3c: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800ea3e: 63bb         	str	r3, [r7, #0x38]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800ea40: 6bbb         	ldr	r3, [r7, #0x38]
 800ea42: 2b00         	cmp	r3, #0x0
 800ea44: d102         	bne	0x800ea4c <k_sched_unlock+0x80> @ imm = #0x4
 800ea46: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800eb74 <k_sched_unlock+0x1a8>
 800ea48: 68db         	ldr	r3, [r3, #0xc]
 800ea4a: e000         	b	0x800ea4e <k_sched_unlock+0x82> @ imm = #0x0
 800ea4c: 6bbb         	ldr	r3, [r7, #0x38]
; 	struct k_thread *thread = next_up();
 800ea4e: 637b         	str	r3, [r7, #0x34]
 800ea50: 6b7b         	ldr	r3, [r7, #0x34]
 800ea52: 633b         	str	r3, [r7, #0x30]
 800ea54: 6cbb         	ldr	r3, [r7, #0x48]
 800ea56: 62fb         	str	r3, [r7, #0x2c]
; 	if (preempt_ok != 0) {
 800ea58: 6afb         	ldr	r3, [r7, #0x2c]
 800ea5a: 2b00         	cmp	r3, #0x0
 800ea5c: d001         	beq	0x800ea62 <k_sched_unlock+0x96> @ imm = #0x2
; 		return true;
 800ea5e: 2301         	movs	r3, #0x1
 800ea60: e026         	b	0x800eab0 <k_sched_unlock+0xe4> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ea62: 4b44         	ldr	r3, [pc, #0x110]        @ 0x800eb74 <k_sched_unlock+0x1a8>
 800ea64: 689b         	ldr	r3, [r3, #0x8]
 800ea66: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800ea68: 6abb         	ldr	r3, [r7, #0x28]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800ea6a: 4618         	mov	r0, r3
 800ea6c: f00b f9b4    	bl	0x8019dd8 <z_is_thread_prevented_from_running> @ imm = #0xb368
 800ea70: 4603         	mov	r3, r0
 800ea72: 2b00         	cmp	r3, #0x0
 800ea74: d001         	beq	0x800ea7a <k_sched_unlock+0xae> @ imm = #0x2
; 		return true;
 800ea76: 2301         	movs	r3, #0x1
 800ea78: e01a         	b	0x800eab0 <k_sched_unlock+0xe4> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ea7a: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800eb74 <k_sched_unlock+0x1a8>
 800ea7c: 689b         	ldr	r3, [r3, #0x8]
 800ea7e: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800ea80: 6a7b         	ldr	r3, [r7, #0x24]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800ea82: 4618         	mov	r0, r3
 800ea84: f00b f97c    	bl	0x8019d80 <thread_is_preemptible> @ imm = #0xb2f8
 800ea88: 4603         	mov	r3, r0
 800ea8a: 2b00         	cmp	r3, #0x0
 800ea8c: d105         	bne	0x800ea9a <k_sched_unlock+0xce> @ imm = #0xa
 800ea8e: 6b38         	ldr	r0, [r7, #0x30]
 800ea90: f00b f986    	bl	0x8019da0 <thread_is_metairq> @ imm = #0xb30c
 800ea94: 4603         	mov	r3, r0
 800ea96: 2b00         	cmp	r3, #0x0
 800ea98: d001         	beq	0x800ea9e <k_sched_unlock+0xd2> @ imm = #0x2
; 		return true;
 800ea9a: 2301         	movs	r3, #0x1
 800ea9c: e008         	b	0x800eab0 <k_sched_unlock+0xe4> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800ea9e: 6b38         	ldr	r0, [r7, #0x30]
 800eaa0: f00b f9ae    	bl	0x8019e00 <z_is_thread_timeout_active> @ imm = #0xb35c
 800eaa4: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800eaa6: 2b00         	cmp	r3, #0x0
 800eaa8: d001         	beq	0x800eaae <k_sched_unlock+0xe2> @ imm = #0x2
; 		return true;
 800eaaa: 2301         	movs	r3, #0x1
 800eaac: e000         	b	0x800eab0 <k_sched_unlock+0xe4> @ imm = #0x0
; 	return false;
 800eaae: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800eab0: 2b00         	cmp	r3, #0x0
 800eab2: d010         	beq	0x800ead6 <k_sched_unlock+0x10a> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800eab4: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800eb74 <k_sched_unlock+0x1a8>
 800eab6: 689b         	ldr	r3, [r3, #0x8]
 800eab8: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 800eaba: 6a3b         	ldr	r3, [r7, #0x20]
; 		if (thread != arch_current_thread()) {
 800eabc: 6b7a         	ldr	r2, [r7, #0x34]
 800eabe: 429a         	cmp	r2, r3
 800eac0: d002         	beq	0x800eac8 <k_sched_unlock+0xfc> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800eac2: 6b78         	ldr	r0, [r7, #0x34]
 800eac4: f000 fcec    	bl	0x800f4a0 <z_reset_time_slice> @ imm = #0x9d8
; 		update_metairq_preempt(thread);
 800eac8: 6b78         	ldr	r0, [r7, #0x34]
 800eaca: f00b fb0e    	bl	0x801a0ea <update_metairq_preempt> @ imm = #0xb61c
; 		_kernel.ready_q.cache = thread;
 800eace: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x800eb74 <k_sched_unlock+0x1a8>
 800ead0: 6b7b         	ldr	r3, [r7, #0x34]
 800ead2: 61d3         	str	r3, [r2, #0x1c]
; }
 800ead4: e005         	b	0x800eae2 <k_sched_unlock+0x116> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ead6: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800eb74 <k_sched_unlock+0x1a8>
 800ead8: 689b         	ldr	r3, [r3, #0x8]
 800eada: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 800eadc: 69fb         	ldr	r3, [r7, #0x1c]
; 		_kernel.ready_q.cache = arch_current_thread();
 800eade: 4a25         	ldr	r2, [pc, #0x94]         @ 0x800eb74 <k_sched_unlock+0x1a8>
 800eae0: 61d3         	str	r3, [r2, #0x1c]
; }
 800eae2: bf00         	nop
 800eae4: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800eb70 <k_sched_unlock+0x1a4>
 800eae6: 657b         	str	r3, [r7, #0x54]
 800eae8: 68bb         	ldr	r3, [r7, #0x8]
 800eaea: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 800eaec: 687b         	ldr	r3, [r7, #0x4]
 800eaee: 653b         	str	r3, [r7, #0x50]
 800eaf0: 6d3b         	ldr	r3, [r7, #0x50]
 800eaf2: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800eaf4: 6cfb         	ldr	r3, [r7, #0x4c]
 800eaf6: f383 8811    	msr	basepri, r3
; }
 800eafa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800eafc: f3bf 8f6f    	isb	sy
; }
 800eb00: bf00         	nop
; }
 800eb02: bf00         	nop
; }
 800eb04: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800eb06: 2301         	movs	r3, #0x1
 800eb08: 60fb         	str	r3, [r7, #0xc]
 800eb0a: 68fb         	ldr	r3, [r7, #0xc]
 800eb0c: 2b00         	cmp	r3, #0x0
 800eb0e: f43f af7d    	beq.w	0x800ea0c <k_sched_unlock+0x40> @ imm = #-0x106
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 800eb12: 2303         	movs	r3, #0x3
 800eb14: 2b03         	cmp	r3, #0x3
 800eb16: d925         	bls	0x800eb64 <k_sched_unlock+0x198> @ imm = #0x4a
 800eb18: 2301         	movs	r3, #0x1
 800eb1a: f887 3077    	strb.w	r3, [r7, #0x77]
 800eb1e: f897 3077    	ldrb.w	r3, [r7, #0x77]
 800eb22: f083 0301    	eor	r3, r3, #0x1
 800eb26: b2db         	uxtb	r3, r3
 800eb28: 2b00         	cmp	r3, #0x0
 800eb2a: d11b         	bne	0x800eb64 <k_sched_unlock+0x198> @ imm = #0x36
 800eb2c: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800eb7c <k_sched_unlock+0x1b0>
 800eb2e: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800eb30: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800eb74 <k_sched_unlock+0x1a8>
 800eb32: 689b         	ldr	r3, [r3, #0x8]
 800eb34: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 800eb36: 693b         	ldr	r3, [r7, #0x10]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800eb38: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800eb74 <k_sched_unlock+0x1a8>
 800eb3a: 6892         	ldr	r2, [r2, #0x8]
 800eb3c: 617a         	str	r2, [r7, #0x14]
; 	return ret;
 800eb3e: 697a         	ldr	r2, [r7, #0x14]
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 800eb40: 7bd2         	ldrb	r2, [r2, #0xf]
 800eb42: 9205         	str	r2, [sp, #0x14]
 800eb44: 9304         	str	r3, [sp, #0x10]
 800eb46: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800eb80 <k_sched_unlock+0x1b4>
 800eb48: 9303         	str	r3, [sp, #0xc]
 800eb4a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800eb84 <k_sched_unlock+0x1b8>
 800eb4c: 9302         	str	r3, [sp, #0x8]
 800eb4e: 2308         	movs	r3, #0x8
 800eb50: 9301         	str	r3, [sp, #0x4]
 800eb52: 2300         	movs	r3, #0x0
 800eb54: 9300         	str	r3, [sp]
 800eb56: 2300         	movs	r3, #0x0
 800eb58: 2204         	movs	r2, #0x4
 800eb5a: 2000         	movs	r0, #0x0
 800eb5c: f00b fa49    	bl	0x8019ff2 <z_log_msg_runtime_create> @ imm = #0xb492
 800eb60: 2300         	movs	r3, #0x0
 800eb62: 673b         	str	r3, [r7, #0x70]
; 	z_reschedule_unlocked();
 800eb64: f00b f9f8    	bl	0x8019f58 <z_reschedule_unlocked> @ imm = #0xb3f0
; }
 800eb68: bf00         	nop
 800eb6a: 3778         	adds	r7, #0x78
 800eb6c: 46bd         	mov	sp, r7
 800eb6e: bd80         	pop	{r7, pc}

0800eb70 <$d>:
 800eb70: 2c 11 00 20  	.word	0x2000112c
 800eb74: 30 07 00 20  	.word	0x20000730
 800eb78: 50 07 00 20  	.word	0x20000750
 800eb7c: 5c 05 00 20  	.word	0x2000055c
 800eb80: e8 d8 01 08  	.word	0x0801d8e8
 800eb84: e0 cc 01 08  	.word	0x0801cce0

0800eb88 <z_sched_init>:
; {
 800eb88: b580         	push	{r7, lr}
 800eb8a: af00         	add	r7, sp, #0x0
; 	init_ready_q(&_kernel.ready_q);
 800eb8c: 4802         	ldr	r0, [pc, #0x8]          @ 0x800eb98 <z_sched_init+0x10>
 800eb8e: f00b fbcb    	bl	0x801a328 <init_ready_q> @ imm = #0xb796
; }
 800eb92: bf00         	nop
 800eb94: bd80         	pop	{r7, pc}
 800eb96: bf00         	nop

0800eb98 <$d>:
 800eb98: 4c 07 00 20  	.word	0x2000074c

0800eb9c <z_impl_k_yield>:
; {
 800eb9c: b580         	push	{r7, lr}
 800eb9e: b0a4         	sub	sp, #0x90
 800eba0: af00         	add	r7, sp, #0x0
 800eba2: 4b86         	ldr	r3, [pc, #0x218]        @ 0x800edbc <z_impl_k_yield+0x220>
 800eba4: f8c7 308c    	str.w	r3, [r7, #0x8c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800eba8: f3ef 8311    	mrs	r3, basepri
 800ebac: f8c7 3088    	str.w	r3, [r7, #0x88]
;   return(result);
 800ebb0: f8d7 3088    	ldr.w	r3, [r7, #0x88]
; 	key = __get_BASEPRI();
 800ebb4: f8c7 3084    	str.w	r3, [r7, #0x84]
 800ebb8: 2310         	movs	r3, #0x10
 800ebba: f8c7 3080    	str.w	r3, [r7, #0x80]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ebbe: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800ebc2: f383 8812    	msr	basepri_max, r3
; }
 800ebc6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ebc8: f3bf 8f6f    	isb	sy
; }
 800ebcc: bf00         	nop
; 	return key;
 800ebce: f8d7 3084    	ldr.w	r3, [r7, #0x84]
; 	k.key = arch_irq_lock();
 800ebd2: 603b         	str	r3, [r7]
 800ebd4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800ebd8: 67fb         	str	r3, [r7, #0x7c]
; }
 800ebda: bf00         	nop
 800ebdc: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800ebe0: 67bb         	str	r3, [r7, #0x78]
; }
 800ebe2: bf00         	nop
; 	return k;
 800ebe4: 683b         	ldr	r3, [r7]
 800ebe6: 60bb         	str	r3, [r7, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ebe8: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x800edc0 <z_impl_k_yield+0x224>
 800ebea: 689b         	ldr	r3, [r3, #0x8]
 800ebec: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800ebee: 68fb         	ldr	r3, [r7, #0xc]
 800ebf0: 623b         	str	r3, [r7, #0x20]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800ebf2: 6a3b         	ldr	r3, [r7, #0x20]
 800ebf4: 7b5b         	ldrb	r3, [r3, #0xd]
 800ebf6: f003 037f    	and	r3, r3, #0x7f
 800ebfa: b2da         	uxtb	r2, r3
 800ebfc: 6a3b         	ldr	r3, [r7, #0x20]
 800ebfe: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800ec00: 6a38         	ldr	r0, [r7, #0x20]
 800ec02: f00b fa2f    	bl	0x801a064 <should_queue_thread> @ imm = #0xb45e
 800ec06: 4603         	mov	r3, r0
 800ec08: 2b00         	cmp	r3, #0x0
 800ec0a: d00d         	beq	0x800ec28 <z_impl_k_yield+0x8c> @ imm = #0x1a
 800ec0c: 6a3b         	ldr	r3, [r7, #0x20]
 800ec0e: 61fb         	str	r3, [r7, #0x1c]
 800ec10: 69fb         	ldr	r3, [r7, #0x1c]
 800ec12: 61bb         	str	r3, [r7, #0x18]
; 	return &_kernel.ready_q.runq;
 800ec14: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x800edc4 <z_impl_k_yield+0x228>
 800ec16: 617b         	str	r3, [r7, #0x14]
 800ec18: 69fb         	ldr	r3, [r7, #0x1c]
 800ec1a: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800ec1c: 693b         	ldr	r3, [r7, #0x10]
 800ec1e: 4618         	mov	r0, r3
 800ec20: f00b f860    	bl	0x8019ce4 <sys_dlist_remove> @ imm = #0xb0c0
; }
 800ec24: bf00         	nop
; }
 800ec26: bf00         	nop
; }
 800ec28: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ec2a: 4b65         	ldr	r3, [pc, #0x194]        @ 0x800edc0 <z_impl_k_yield+0x224>
 800ec2c: 689b         	ldr	r3, [r3, #0x8]
 800ec2e: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800ec30: 6a7b         	ldr	r3, [r7, #0x24]
 800ec32: 63fb         	str	r3, [r7, #0x3c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800ec34: 6bfb         	ldr	r3, [r7, #0x3c]
 800ec36: 7b5b         	ldrb	r3, [r3, #0xd]
 800ec38: f063 037f    	orn	r3, r3, #0x7f
 800ec3c: b2da         	uxtb	r2, r3
 800ec3e: 6bfb         	ldr	r3, [r7, #0x3c]
 800ec40: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800ec42: 6bf8         	ldr	r0, [r7, #0x3c]
 800ec44: f00b fa0e    	bl	0x801a064 <should_queue_thread> @ imm = #0xb41c
 800ec48: 4603         	mov	r3, r0
 800ec4a: 2b00         	cmp	r3, #0x0
 800ec4c: d042         	beq	0x800ecd4 <z_impl_k_yield+0x138> @ imm = #0x84
 800ec4e: 6bfb         	ldr	r3, [r7, #0x3c]
 800ec50: 63bb         	str	r3, [r7, #0x38]
 800ec52: 6bbb         	ldr	r3, [r7, #0x38]
 800ec54: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 800ec56: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x800edc4 <z_impl_k_yield+0x228>
 800ec58: 633b         	str	r3, [r7, #0x30]
 800ec5a: 6bbb         	ldr	r3, [r7, #0x38]
 800ec5c: 62fb         	str	r3, [r7, #0x2c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800ec5e: 6b38         	ldr	r0, [r7, #0x30]
 800ec60: f00a ffd6    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xafac
 800ec64: 4603         	mov	r3, r0
 800ec66: 2b00         	cmp	r3, #0x0
 800ec68: d004         	beq	0x800ec74 <z_impl_k_yield+0xd8> @ imm = #0x8
 800ec6a: 6b38         	ldr	r0, [r7, #0x30]
 800ec6c: f00a ffd0    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xafa0
 800ec70: 4603         	mov	r3, r0
 800ec72: e000         	b	0x800ec76 <z_impl_k_yield+0xda> @ imm = #0x0
 800ec74: 2300         	movs	r3, #0x0
 800ec76: 62bb         	str	r3, [r7, #0x28]
 800ec78: e023         	b	0x800ecc2 <z_impl_k_yield+0x126> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800ec7a: 6ab9         	ldr	r1, [r7, #0x28]
 800ec7c: 6af8         	ldr	r0, [r7, #0x2c]
 800ec7e: f00b f9d6    	bl	0x801a02e <z_sched_prio_cmp> @ imm = #0xb3ac
 800ec82: 4603         	mov	r3, r0
 800ec84: 2b00         	cmp	r3, #0x0
 800ec86: dd06         	ble	0x800ec96 <z_impl_k_yield+0xfa> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800ec88: 6abb         	ldr	r3, [r7, #0x28]
 800ec8a: 6afa         	ldr	r2, [r7, #0x2c]
 800ec8c: 4611         	mov	r1, r2
 800ec8e: 4618         	mov	r0, r3
 800ec90: f00b f80f    	bl	0x8019cb2 <sys_dlist_insert> @ imm = #0xb01e
; 			return;
 800ec94: e01d         	b	0x800ecd2 <z_impl_k_yield+0x136> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800ec96: 6abb         	ldr	r3, [r7, #0x28]
 800ec98: 2b00         	cmp	r3, #0x0
 800ec9a: d010         	beq	0x800ecbe <z_impl_k_yield+0x122> @ imm = #0x20
 800ec9c: 6abb         	ldr	r3, [r7, #0x28]
 800ec9e: 4619         	mov	r1, r3
 800eca0: 6b38         	ldr	r0, [r7, #0x30]
 800eca2: f00a ffda    	bl	0x8019c5a <sys_dlist_peek_next> @ imm = #0xafb4
 800eca6: 4603         	mov	r3, r0
 800eca8: 2b00         	cmp	r3, #0x0
 800ecaa: d006         	beq	0x800ecba <z_impl_k_yield+0x11e> @ imm = #0xc
 800ecac: 6abb         	ldr	r3, [r7, #0x28]
 800ecae: 4619         	mov	r1, r3
 800ecb0: 6b38         	ldr	r0, [r7, #0x30]
 800ecb2: f00a ffd2    	bl	0x8019c5a <sys_dlist_peek_next> @ imm = #0xafa4
 800ecb6: 4603         	mov	r3, r0
 800ecb8: e002         	b	0x800ecc0 <z_impl_k_yield+0x124> @ imm = #0x4
 800ecba: 2300         	movs	r3, #0x0
 800ecbc: e000         	b	0x800ecc0 <z_impl_k_yield+0x124> @ imm = #0x0
 800ecbe: 2300         	movs	r3, #0x0
 800ecc0: 62bb         	str	r3, [r7, #0x28]
 800ecc2: 6abb         	ldr	r3, [r7, #0x28]
 800ecc4: 2b00         	cmp	r3, #0x0
 800ecc6: d1d8         	bne	0x800ec7a <z_impl_k_yield+0xde> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800ecc8: 6afb         	ldr	r3, [r7, #0x2c]
 800ecca: 4619         	mov	r1, r3
 800eccc: 6b38         	ldr	r0, [r7, #0x30]
 800ecce: f00a ffd7    	bl	0x8019c80 <sys_dlist_append> @ imm = #0xafae
; }
 800ecd2: bf00         	nop
; }
 800ecd4: bf00         	nop
 800ecd6: 2301         	movs	r3, #0x1
 800ecd8: 66fb         	str	r3, [r7, #0x6c]
; 	return &_kernel.ready_q.runq;
 800ecda: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x800edc4 <z_impl_k_yield+0x228>
 800ecdc: 66bb         	str	r3, [r7, #0x68]
; 	struct k_thread *thread = NULL;
 800ecde: 2300         	movs	r3, #0x0
 800ece0: 667b         	str	r3, [r7, #0x64]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800ece2: 6eb8         	ldr	r0, [r7, #0x68]
 800ece4: f00a ff94    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xaf28
 800ece8: 6638         	str	r0, [r7, #0x60]
; 	if (n != NULL) {
 800ecea: 6e3b         	ldr	r3, [r7, #0x60]
 800ecec: 2b00         	cmp	r3, #0x0
 800ecee: d001         	beq	0x800ecf4 <z_impl_k_yield+0x158> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800ecf0: 6e3b         	ldr	r3, [r7, #0x60]
 800ecf2: 667b         	str	r3, [r7, #0x64]
; 	return thread;
 800ecf4: 6e7b         	ldr	r3, [r7, #0x64]
; 	return _priq_run_best(curr_cpu_runq());
 800ecf6: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800ecf8: 65fb         	str	r3, [r7, #0x5c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800ecfa: 6dfb         	ldr	r3, [r7, #0x5c]
 800ecfc: 2b00         	cmp	r3, #0x0
 800ecfe: d102         	bne	0x800ed06 <z_impl_k_yield+0x16a> @ imm = #0x4
 800ed00: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800edc0 <z_impl_k_yield+0x224>
 800ed02: 68db         	ldr	r3, [r3, #0xc]
 800ed04: e000         	b	0x800ed08 <z_impl_k_yield+0x16c> @ imm = #0x0
 800ed06: 6dfb         	ldr	r3, [r7, #0x5c]
; 	struct k_thread *thread = next_up();
 800ed08: 65bb         	str	r3, [r7, #0x58]
 800ed0a: 6dbb         	ldr	r3, [r7, #0x58]
 800ed0c: 657b         	str	r3, [r7, #0x54]
 800ed0e: 6efb         	ldr	r3, [r7, #0x6c]
 800ed10: 653b         	str	r3, [r7, #0x50]
; 	if (preempt_ok != 0) {
 800ed12: 6d3b         	ldr	r3, [r7, #0x50]
 800ed14: 2b00         	cmp	r3, #0x0
 800ed16: d001         	beq	0x800ed1c <z_impl_k_yield+0x180> @ imm = #0x2
; 		return true;
 800ed18: 2301         	movs	r3, #0x1
 800ed1a: e026         	b	0x800ed6a <z_impl_k_yield+0x1ce> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ed1c: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800edc0 <z_impl_k_yield+0x224>
 800ed1e: 689b         	ldr	r3, [r3, #0x8]
 800ed20: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 800ed22: 6cfb         	ldr	r3, [r7, #0x4c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800ed24: 4618         	mov	r0, r3
 800ed26: f00b f857    	bl	0x8019dd8 <z_is_thread_prevented_from_running> @ imm = #0xb0ae
 800ed2a: 4603         	mov	r3, r0
 800ed2c: 2b00         	cmp	r3, #0x0
 800ed2e: d001         	beq	0x800ed34 <z_impl_k_yield+0x198> @ imm = #0x2
; 		return true;
 800ed30: 2301         	movs	r3, #0x1
 800ed32: e01a         	b	0x800ed6a <z_impl_k_yield+0x1ce> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ed34: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800edc0 <z_impl_k_yield+0x224>
 800ed36: 689b         	ldr	r3, [r3, #0x8]
 800ed38: 64bb         	str	r3, [r7, #0x48]
; 	return ret;
 800ed3a: 6cbb         	ldr	r3, [r7, #0x48]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800ed3c: 4618         	mov	r0, r3
 800ed3e: f00b f81f    	bl	0x8019d80 <thread_is_preemptible> @ imm = #0xb03e
 800ed42: 4603         	mov	r3, r0
 800ed44: 2b00         	cmp	r3, #0x0
 800ed46: d105         	bne	0x800ed54 <z_impl_k_yield+0x1b8> @ imm = #0xa
 800ed48: 6d78         	ldr	r0, [r7, #0x54]
 800ed4a: f00b f829    	bl	0x8019da0 <thread_is_metairq> @ imm = #0xb052
 800ed4e: 4603         	mov	r3, r0
 800ed50: 2b00         	cmp	r3, #0x0
 800ed52: d001         	beq	0x800ed58 <z_impl_k_yield+0x1bc> @ imm = #0x2
; 		return true;
 800ed54: 2301         	movs	r3, #0x1
 800ed56: e008         	b	0x800ed6a <z_impl_k_yield+0x1ce> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800ed58: 6d78         	ldr	r0, [r7, #0x54]
 800ed5a: f00b f851    	bl	0x8019e00 <z_is_thread_timeout_active> @ imm = #0xb0a2
 800ed5e: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800ed60: 2b00         	cmp	r3, #0x0
 800ed62: d001         	beq	0x800ed68 <z_impl_k_yield+0x1cc> @ imm = #0x2
; 		return true;
 800ed64: 2301         	movs	r3, #0x1
 800ed66: e000         	b	0x800ed6a <z_impl_k_yield+0x1ce> @ imm = #0x0
; 	return false;
 800ed68: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800ed6a: 2b00         	cmp	r3, #0x0
 800ed6c: d010         	beq	0x800ed90 <z_impl_k_yield+0x1f4> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ed6e: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800edc0 <z_impl_k_yield+0x224>
 800ed70: 689b         	ldr	r3, [r3, #0x8]
 800ed72: 647b         	str	r3, [r7, #0x44]
; 	return ret;
 800ed74: 6c7b         	ldr	r3, [r7, #0x44]
; 		if (thread != arch_current_thread()) {
 800ed76: 6dba         	ldr	r2, [r7, #0x58]
 800ed78: 429a         	cmp	r2, r3
 800ed7a: d002         	beq	0x800ed82 <z_impl_k_yield+0x1e6> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800ed7c: 6db8         	ldr	r0, [r7, #0x58]
 800ed7e: f000 fb8f    	bl	0x800f4a0 <z_reset_time_slice> @ imm = #0x71e
; 		update_metairq_preempt(thread);
 800ed82: 6db8         	ldr	r0, [r7, #0x58]
 800ed84: f00b f9b1    	bl	0x801a0ea <update_metairq_preempt> @ imm = #0xb362
; 		_kernel.ready_q.cache = thread;
 800ed88: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800edc0 <z_impl_k_yield+0x224>
 800ed8a: 6dbb         	ldr	r3, [r7, #0x58]
 800ed8c: 61d3         	str	r3, [r2, #0x1c]
; }
 800ed8e: e005         	b	0x800ed9c <z_impl_k_yield+0x200> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ed90: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800edc0 <z_impl_k_yield+0x224>
 800ed92: 689b         	ldr	r3, [r3, #0x8]
 800ed94: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 800ed96: 6c3b         	ldr	r3, [r7, #0x40]
; 		_kernel.ready_q.cache = arch_current_thread();
 800ed98: 4a09         	ldr	r2, [pc, #0x24]         @ 0x800edc0 <z_impl_k_yield+0x224>
 800ed9a: 61d3         	str	r3, [r2, #0x1c]
; }
 800ed9c: bf00         	nop
 800ed9e: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800edbc <z_impl_k_yield+0x220>
 800eda0: 677b         	str	r3, [r7, #0x74]
 800eda2: 68bb         	ldr	r3, [r7, #0x8]
 800eda4: 607b         	str	r3, [r7, #0x4]
 800eda6: 6f7b         	ldr	r3, [r7, #0x74]
 800eda8: 673b         	str	r3, [r7, #0x70]
; }
 800edaa: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800edac: 687b         	ldr	r3, [r7, #0x4]
 800edae: 4618         	mov	r0, r3
 800edb0: f00b f912    	bl	0x8019fd8 <z_swap_irqlock> @ imm = #0xb224
; }
 800edb4: bf00         	nop
 800edb6: 3790         	adds	r7, #0x90
 800edb8: 46bd         	mov	sp, r7
 800edba: bd80         	pop	{r7, pc}

0800edbc <$d>:
 800edbc: 2c 11 00 20  	.word	0x2000112c
 800edc0: 30 07 00 20  	.word	0x20000730
 800edc4: 50 07 00 20  	.word	0x20000750

0800edc8 <z_tick_sleep>:
; {
 800edc8: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800edcc: b0a0         	sub	sp, #0x80
 800edce: af06         	add	r7, sp, #0x18
 800edd0: e9c7 0100    	strd	r0, r1, [r7]
; 	LOG_DBG("thread %p for %lu ticks", arch_current_thread(), (unsigned long)ticks);
 800edd4: 2303         	movs	r3, #0x3
 800edd6: 2b03         	cmp	r3, #0x3
 800edd8: d921         	bls	0x800ee1e <z_tick_sleep+0x56> @ imm = #0x42
 800edda: 2301         	movs	r3, #0x1
 800eddc: f887 3067    	strb.w	r3, [r7, #0x67]
 800ede0: f897 3067    	ldrb.w	r3, [r7, #0x67]
 800ede4: f083 0301    	eor	r3, r3, #0x1
 800ede8: b2db         	uxtb	r3, r3
 800edea: 2b00         	cmp	r3, #0x0
 800edec: d117         	bne	0x800ee1e <z_tick_sleep+0x56> @ imm = #0x2e
 800edee: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x800ef20 <z_tick_sleep+0x158>
 800edf0: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800edf2: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x800ef24 <z_tick_sleep+0x15c>
 800edf4: 689b         	ldr	r3, [r3, #0x8]
 800edf6: 657b         	str	r3, [r7, #0x54]
; 	return ret;
 800edf8: 6d7b         	ldr	r3, [r7, #0x54]
; 	LOG_DBG("thread %p for %lu ticks", arch_current_thread(), (unsigned long)ticks);
 800edfa: 683a         	ldr	r2, [r7]
 800edfc: 9205         	str	r2, [sp, #0x14]
 800edfe: 9304         	str	r3, [sp, #0x10]
 800ee00: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800ef28 <z_tick_sleep+0x160>
 800ee02: 9303         	str	r3, [sp, #0xc]
 800ee04: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800ef2c <z_tick_sleep+0x164>
 800ee06: 9302         	str	r3, [sp, #0x8]
 800ee08: 2308         	movs	r3, #0x8
 800ee0a: 9301         	str	r3, [sp, #0x4]
 800ee0c: 2300         	movs	r3, #0x0
 800ee0e: 9300         	str	r3, [sp]
 800ee10: 2300         	movs	r3, #0x0
 800ee12: 2204         	movs	r2, #0x4
 800ee14: 2000         	movs	r0, #0x0
 800ee16: f00b f8ec    	bl	0x8019ff2 <z_log_msg_runtime_create> @ imm = #0xb1d8
 800ee1a: 2300         	movs	r3, #0x0
 800ee1c: 65fb         	str	r3, [r7, #0x5c]
; 	if (ticks == 0) {
 800ee1e: e9d7 2300    	ldrd	r2, r3, [r7]
 800ee22: 4313         	orrs	r3, r2
 800ee24: d103         	bne	0x800ee2e <z_tick_sleep+0x66> @ imm = #0x6
; 		k_yield();
 800ee26: f00a ff74    	bl	0x8019d12 <k_yield>     @ imm = #0xaee8
; 		return 0;
 800ee2a: 2300         	movs	r3, #0x0
 800ee2c: e073         	b	0x800ef16 <z_tick_sleep+0x14e> @ imm = #0xe6
; 	if (Z_TICK_ABS(ticks) <= 0) {
 800ee2e: e9d7 2300    	ldrd	r2, r3, [r7]
 800ee32: f06f 0001    	mvn	r0, #0x1
 800ee36: f04f 31ff    	mov.w	r1, #0xffffffff
 800ee3a: 1a84         	subs	r4, r0, r2
 800ee3c: eb61 0503    	sbc.w	r5, r1, r3
 800ee40: 2c01         	cmp	r4, #0x1
 800ee42: f175 0300    	sbcs	r3, r5, #0x0
 800ee46: da06         	bge	0x800ee56 <z_tick_sleep+0x8e> @ imm = #0xc
; 		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
 800ee48: f00b fbf6    	bl	0x801a638 <sys_clock_tick_get_32> @ imm = #0xb7ec
 800ee4c: 4602         	mov	r2, r0
 800ee4e: 683b         	ldr	r3, [r7]
 800ee50: 4413         	add	r3, r2
 800ee52: 663b         	str	r3, [r7, #0x60]
 800ee54: e004         	b	0x800ee60 <z_tick_sleep+0x98> @ imm = #0x8
; 		expected_wakeup_ticks = Z_TICK_ABS(ticks);
 800ee56: 683a         	ldr	r2, [r7]
 800ee58: f06f 0301    	mvn	r3, #0x1
 800ee5c: 1a9b         	subs	r3, r3, r2
 800ee5e: 663b         	str	r3, [r7, #0x60]
; 	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
 800ee60: e9d7 2300    	ldrd	r2, r3, [r7]
 800ee64: e9c7 2306    	strd	r2, r3, [r7, #24]
 800ee68: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800ef30 <z_tick_sleep+0x168>
 800ee6a: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ee6c: f3ef 8311    	mrs	r3, basepri
 800ee70: 637b         	str	r3, [r7, #0x34]
;   return(result);
 800ee72: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 800ee74: 633b         	str	r3, [r7, #0x30]
 800ee76: 2310         	movs	r3, #0x10
 800ee78: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ee7a: 6afb         	ldr	r3, [r7, #0x2c]
 800ee7c: f383 8812    	msr	basepri_max, r3
; }
 800ee80: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ee82: f3bf 8f6f    	isb	sy
; }
 800ee86: bf00         	nop
; 	return key;
 800ee88: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 800ee8a: 613b         	str	r3, [r7, #0x10]
 800ee8c: 6bbb         	ldr	r3, [r7, #0x38]
 800ee8e: 62bb         	str	r3, [r7, #0x28]
; }
 800ee90: bf00         	nop
 800ee92: 6bbb         	ldr	r3, [r7, #0x38]
 800ee94: 627b         	str	r3, [r7, #0x24]
; }
 800ee96: bf00         	nop
; 	return k;
 800ee98: 693b         	ldr	r3, [r7, #0x10]
 800ee9a: 617b         	str	r3, [r7, #0x14]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ee9c: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800ef24 <z_tick_sleep+0x15c>
 800ee9e: 689b         	ldr	r3, [r3, #0x8]
 800eea0: 63fb         	str	r3, [r7, #0x3c]
; 	return ret;
 800eea2: 6bfb         	ldr	r3, [r7, #0x3c]
; 	pending_current = arch_current_thread();
 800eea4: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x800ef34 <z_tick_sleep+0x16c>
 800eea6: 6013         	str	r3, [r2]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800eea8: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800ef24 <z_tick_sleep+0x15c>
 800eeaa: 689b         	ldr	r3, [r3, #0x8]
 800eeac: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 800eeae: 6c3b         	ldr	r3, [r7, #0x40]
; 	unready_thread(arch_current_thread());
 800eeb0: 4618         	mov	r0, r3
 800eeb2: f7ff fa4d    	bl	0x800e350 <unready_thread> @ imm = #-0xb66
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800eeb6: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800ef24 <z_tick_sleep+0x15c>
 800eeb8: 689b         	ldr	r3, [r3, #0x8]
 800eeba: 647b         	str	r3, [r7, #0x44]
; 	return ret;
 800eebc: 6c79         	ldr	r1, [r7, #0x44]
; 	z_add_thread_timeout(arch_current_thread(), timeout);
 800eebe: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 800eec2: 4608         	mov	r0, r1
 800eec4: f7fe fd94    	bl	0x800d9f0 <z_add_thread_timeout> @ imm = #-0x14d8
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800eec8: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800ef24 <z_tick_sleep+0x15c>
 800eeca: 689b         	ldr	r3, [r3, #0x8]
 800eecc: 64bb         	str	r3, [r7, #0x48]
; 	return ret;
 800eece: 6cbb         	ldr	r3, [r7, #0x48]
; 	z_mark_thread_as_suspended(arch_current_thread());
 800eed0: 4618         	mov	r0, r3
 800eed2: f00a ffef    	bl	0x8019eb4 <z_mark_thread_as_suspended> @ imm = #0xafde
 800eed6: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800ef30 <z_tick_sleep+0x168>
 800eed8: 653b         	str	r3, [r7, #0x50]
 800eeda: 697b         	ldr	r3, [r7, #0x14]
 800eedc: 60fb         	str	r3, [r7, #0xc]
 800eede: 6d3b         	ldr	r3, [r7, #0x50]
 800eee0: 64fb         	str	r3, [r7, #0x4c]
; }
 800eee2: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800eee4: 68fb         	ldr	r3, [r7, #0xc]
 800eee6: 4618         	mov	r0, r3
 800eee8: f00b f876    	bl	0x8019fd8 <z_swap_irqlock> @ imm = #0xb0ec
; 	uint32_t left_ticks = expected_wakeup_ticks - sys_clock_tick_get_32();
 800eeec: f00b fba4    	bl	0x801a638 <sys_clock_tick_get_32> @ imm = #0xb748
 800eef0: 4602         	mov	r2, r0
 800eef2: 6e3b         	ldr	r3, [r7, #0x60]
 800eef4: 1a9b         	subs	r3, r3, r2
 800eef6: 65bb         	str	r3, [r7, #0x58]
; 	ticks = (k_ticks_t)(int32_t)left_ticks;
 800eef8: 6dbb         	ldr	r3, [r7, #0x58]
 800eefa: 17da         	asrs	r2, r3, #0x1f
 800eefc: 4698         	mov	r8, r3
 800eefe: 4691         	mov	r9, r2
 800ef00: e9c7 8900    	strd	r8, r9, [r7]
; 	if (ticks > 0) {
 800ef04: e9d7 2300    	ldrd	r2, r3, [r7]
 800ef08: 2a01         	cmp	r2, #0x1
 800ef0a: f173 0300    	sbcs	r3, r3, #0x0
 800ef0e: db01         	blt	0x800ef14 <z_tick_sleep+0x14c> @ imm = #0x2
; 		return ticks;
 800ef10: 683b         	ldr	r3, [r7]
 800ef12: e000         	b	0x800ef16 <z_tick_sleep+0x14e> @ imm = #0x0
; 	return 0;
 800ef14: 2300         	movs	r3, #0x0
; }
 800ef16: 4618         	mov	r0, r3
 800ef18: 3768         	adds	r7, #0x68
 800ef1a: 46bd         	mov	sp, r7
 800ef1c: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

0800ef20 <$d>:
 800ef20: 5c 05 00 20  	.word	0x2000055c
 800ef24: 30 07 00 20  	.word	0x20000730
 800ef28: f8 d8 01 08  	.word	0x0801d8f8
 800ef2c: 00 cd 01 08  	.word	0x0801cd00
 800ef30: 2c 11 00 20  	.word	0x2000112c
 800ef34: 38 11 00 20  	.word	0x20001138

0800ef38 <z_impl_k_sleep>:
; {
 800ef38: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800ef3c: b086         	sub	sp, #0x18
 800ef3e: af00         	add	r7, sp, #0x0
 800ef40: e9c7 0100    	strd	r0, r1, [r7]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 800ef44: e9d7 2300    	ldrd	r2, r3, [r7]
 800ef48: f04f 30ff    	mov.w	r0, #0xffffffff
 800ef4c: f04f 31ff    	mov.w	r1, #0xffffffff
 800ef50: 428b         	cmp	r3, r1
 800ef52: bf08         	it	eq
 800ef54: 4282         	cmpeq	r2, r0
 800ef56: d109         	bne	0x800ef6c <z_impl_k_sleep+0x34> @ imm = #0x12
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ef58: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800efb8 <z_impl_k_sleep+0x80>
 800ef5a: 689b         	ldr	r3, [r3, #0x8]
 800ef5c: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 800ef5e: 68bb         	ldr	r3, [r7, #0x8]
; 		k_thread_suspend(arch_current_thread());
 800ef60: 4618         	mov	r0, r3
 800ef62: f00a fedc    	bl	0x8019d1e <k_thread_suspend> @ imm = #0xadb8
; 		return (int32_t) K_TICKS_FOREVER;
 800ef66: f04f 33ff    	mov.w	r3, #0xffffffff
 800ef6a: e020         	b	0x800efae <z_impl_k_sleep+0x76> @ imm = #0x40
; 	ticks = timeout.ticks;
 800ef6c: e9d7 2300    	ldrd	r2, r3, [r7]
 800ef70: e9c7 2304    	strd	r2, r3, [r7, #16]
; 	ticks = z_tick_sleep(ticks);
 800ef74: e9d7 0104    	ldrd	r0, r1, [r7, #16]
 800ef78: f7ff ff26    	bl	0x800edc8 <z_tick_sleep> @ imm = #-0x1b4
 800ef7c: 4603         	mov	r3, r0
 800ef7e: 17da         	asrs	r2, r3, #0x1f
 800ef80: 4698         	mov	r8, r3
 800ef82: 4691         	mov	r9, r2
 800ef84: e9c7 8904    	strd	r8, r9, [r7, #16]
; 	int32_t ret = k_ticks_to_ms_ceil64(ticks);
 800ef88: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800ef8c: f112 0409    	adds.w	r4, r2, #0x9
 800ef90: f143 0500    	adc	r5, r3, #0x0
 800ef94: f04f 020a    	mov.w	r2, #0xa
 800ef98: f04f 0300    	mov.w	r3, #0x0
 800ef9c: 4620         	mov	r0, r4
 800ef9e: 4629         	mov	r1, r5
 800efa0: f7f1 fda8    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0xe4b0
 800efa4: 4602         	mov	r2, r0
 800efa6: 460b         	mov	r3, r1
 800efa8: 4613         	mov	r3, r2
 800efaa: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800efac: 68fb         	ldr	r3, [r7, #0xc]
; }
 800efae: 4618         	mov	r0, r3
 800efb0: 3718         	adds	r7, #0x18
 800efb2: 46bd         	mov	sp, r7
 800efb4: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

0800efb8 <$d>:
 800efb8: 30 07 00 20  	.word	0x20000730

0800efbc <z_impl_k_sched_current_thread_query>:
; {
 800efbc: b480         	push	{r7}
 800efbe: b083         	sub	sp, #0xc
 800efc0: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800efc2: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800efd4 <z_impl_k_sched_current_thread_query+0x18>
 800efc4: 689b         	ldr	r3, [r3, #0x8]
 800efc6: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 800efc8: 687b         	ldr	r3, [r7, #0x4]
; }
 800efca: 4618         	mov	r0, r3
 800efcc: 370c         	adds	r7, #0xc
 800efce: 46bd         	mov	sp, r7
 800efd0: bc80         	pop	{r7}
 800efd2: 4770         	bx	lr

0800efd4 <$d>:
 800efd4: 30 07 00 20  	.word	0x20000730

0800efd8 <halt_thread>:
; {
 800efd8: b580         	push	{r7, lr}
 800efda: b096         	sub	sp, #0x58
 800efdc: af00         	add	r7, sp, #0x0
 800efde: 6078         	str	r0, [r7, #0x4]
 800efe0: 460b         	mov	r3, r1
 800efe2: 70fb         	strb	r3, [r7, #0x3]
; 	bool dummify = false;
 800efe4: 2300         	movs	r3, #0x0
 800efe6: f887 3057    	strb.w	r3, [r7, #0x57]
; 	if ((thread->base.thread_state & new_state) == 0U) {
 800efea: 687b         	ldr	r3, [r7, #0x4]
 800efec: 7b5a         	ldrb	r2, [r3, #0xd]
 800efee: 78fb         	ldrb	r3, [r7, #0x3]
 800eff0: 4013         	ands	r3, r2
 800eff2: b2db         	uxtb	r3, r3
 800eff4: 2b00         	cmp	r3, #0x0
 800eff6: f040 80ca    	bne.w	0x800f18e <halt_thread+0x1b6> @ imm = #0x194
; 		thread->base.thread_state |= new_state;
 800effa: 687b         	ldr	r3, [r7, #0x4]
 800effc: 7b5a         	ldrb	r2, [r3, #0xd]
 800effe: 78fb         	ldrb	r3, [r7, #0x3]
 800f000: 4313         	orrs	r3, r2
 800f002: b2da         	uxtb	r2, r3
 800f004: 687b         	ldr	r3, [r7, #0x4]
 800f006: 735a         	strb	r2, [r3, #0xd]
; 		if (z_is_thread_queued(thread)) {
 800f008: 6878         	ldr	r0, [r7, #0x4]
 800f00a: f00a ff46    	bl	0x8019e9a <z_is_thread_queued> @ imm = #0xae8c
 800f00e: 4603         	mov	r3, r0
 800f010: 2b00         	cmp	r3, #0x0
 800f012: d01d         	beq	0x800f050 <halt_thread+0x78> @ imm = #0x3a
 800f014: 687b         	ldr	r3, [r7, #0x4]
 800f016: 653b         	str	r3, [r7, #0x50]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800f018: 6d3b         	ldr	r3, [r7, #0x50]
 800f01a: 7b5b         	ldrb	r3, [r3, #0xd]
 800f01c: f003 037f    	and	r3, r3, #0x7f
 800f020: b2da         	uxtb	r2, r3
 800f022: 6d3b         	ldr	r3, [r7, #0x50]
 800f024: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800f026: 6d38         	ldr	r0, [r7, #0x50]
 800f028: f00b f81c    	bl	0x801a064 <should_queue_thread> @ imm = #0xb038
 800f02c: 4603         	mov	r3, r0
 800f02e: 2b00         	cmp	r3, #0x0
 800f030: d00d         	beq	0x800f04e <halt_thread+0x76> @ imm = #0x1a
 800f032: 6d3b         	ldr	r3, [r7, #0x50]
 800f034: 64fb         	str	r3, [r7, #0x4c]
 800f036: 6cfb         	ldr	r3, [r7, #0x4c]
 800f038: 64bb         	str	r3, [r7, #0x48]
; 	return &_kernel.ready_q.runq;
 800f03a: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800f194 <halt_thread+0x1bc>
 800f03c: 647b         	str	r3, [r7, #0x44]
 800f03e: 6cfb         	ldr	r3, [r7, #0x4c]
 800f040: 643b         	str	r3, [r7, #0x40]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800f042: 6c3b         	ldr	r3, [r7, #0x40]
 800f044: 4618         	mov	r0, r3
 800f046: f00a fe4d    	bl	0x8019ce4 <sys_dlist_remove> @ imm = #0xac9a
; }
 800f04a: bf00         	nop
; }
 800f04c: bf00         	nop
; }
 800f04e: bf00         	nop
; 		if (new_state == _THREAD_DEAD) {
 800f050: 78fb         	ldrb	r3, [r7, #0x3]
 800f052: 2b08         	cmp	r3, #0x8
 800f054: d123         	bne	0x800f09e <halt_thread+0xc6> @ imm = #0x46
; 			if (thread->base.pended_on != NULL) {
 800f056: 687b         	ldr	r3, [r7, #0x4]
 800f058: 689b         	ldr	r3, [r3, #0x8]
 800f05a: 2b00         	cmp	r3, #0x0
 800f05c: d002         	beq	0x800f064 <halt_thread+0x8c> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 800f05e: 6878         	ldr	r0, [r7, #0x4]
 800f060: f00a ff93    	bl	0x8019f8a <unpend_thread_no_timeout> @ imm = #0xaf26
; 			(void)z_abort_thread_timeout(thread);
 800f064: 6878         	ldr	r0, [r7, #0x4]
 800f066: f00a fe7d    	bl	0x8019d64 <z_abort_thread_timeout> @ imm = #0xacfa
; 			unpend_all(&thread->join_queue);
 800f06a: 687b         	ldr	r3, [r7, #0x4]
 800f06c: 3368         	adds	r3, #0x68
 800f06e: 4618         	mov	r0, r3
 800f070: f00b f969    	bl	0x801a346 <unpend_all>  @ imm = #0xb2d2
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f074: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800f198 <halt_thread+0x1c0>
 800f076: 689b         	ldr	r3, [r3, #0x8]
 800f078: 63fb         	str	r3, [r7, #0x3c]
; 	return ret;
 800f07a: 6bfb         	ldr	r3, [r7, #0x3c]
; 			if (thread == arch_current_thread() && arch_is_in_isr()) {
 800f07c: 687a         	ldr	r2, [r7, #0x4]
 800f07e: 429a         	cmp	r2, r3
 800f080: d10d         	bne	0x800f09e <halt_thread+0xc6> @ imm = #0x1a
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800f082: f3ef 8305    	mrs	r3, ipsr
 800f086: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800f088: 6bbb         	ldr	r3, [r7, #0x38]
; 	return (__get_IPSR()) ? (true) : (false);
 800f08a: 2b00         	cmp	r3, #0x0
 800f08c: bf14         	ite	ne
 800f08e: 2301         	movne	r3, #0x1
 800f090: 2300         	moveq	r3, #0x0
 800f092: b2db         	uxtb	r3, r3
; 			if (thread == arch_current_thread() && arch_is_in_isr()) {
 800f094: 2b00         	cmp	r3, #0x0
 800f096: d002         	beq	0x800f09e <halt_thread+0xc6> @ imm = #0x4
; 				dummify = true;
 800f098: 2301         	movs	r3, #0x1
 800f09a: f887 3057    	strb.w	r3, [r7, #0x57]
 800f09e: 2301         	movs	r3, #0x1
 800f0a0: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 800f0a2: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x800f194 <halt_thread+0x1bc>
 800f0a4: 633b         	str	r3, [r7, #0x30]
; 	struct k_thread *thread = NULL;
 800f0a6: 2300         	movs	r3, #0x0
 800f0a8: 62fb         	str	r3, [r7, #0x2c]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800f0aa: 6b38         	ldr	r0, [r7, #0x30]
 800f0ac: f00a fdb0    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xab60
 800f0b0: 62b8         	str	r0, [r7, #0x28]
; 	if (n != NULL) {
 800f0b2: 6abb         	ldr	r3, [r7, #0x28]
 800f0b4: 2b00         	cmp	r3, #0x0
 800f0b6: d001         	beq	0x800f0bc <halt_thread+0xe4> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800f0b8: 6abb         	ldr	r3, [r7, #0x28]
 800f0ba: 62fb         	str	r3, [r7, #0x2c]
; 	return thread;
 800f0bc: 6afb         	ldr	r3, [r7, #0x2c]
; 	return _priq_run_best(curr_cpu_runq());
 800f0be: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800f0c0: 627b         	str	r3, [r7, #0x24]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800f0c2: 6a7b         	ldr	r3, [r7, #0x24]
 800f0c4: 2b00         	cmp	r3, #0x0
 800f0c6: d102         	bne	0x800f0ce <halt_thread+0xf6> @ imm = #0x4
 800f0c8: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800f198 <halt_thread+0x1c0>
 800f0ca: 68db         	ldr	r3, [r3, #0xc]
 800f0cc: e000         	b	0x800f0d0 <halt_thread+0xf8> @ imm = #0x0
 800f0ce: 6a7b         	ldr	r3, [r7, #0x24]
; 	struct k_thread *thread = next_up();
 800f0d0: 623b         	str	r3, [r7, #0x20]
 800f0d2: 6a3b         	ldr	r3, [r7, #0x20]
 800f0d4: 61fb         	str	r3, [r7, #0x1c]
 800f0d6: 6b7b         	ldr	r3, [r7, #0x34]
 800f0d8: 61bb         	str	r3, [r7, #0x18]
; 	if (preempt_ok != 0) {
 800f0da: 69bb         	ldr	r3, [r7, #0x18]
 800f0dc: 2b00         	cmp	r3, #0x0
 800f0de: d001         	beq	0x800f0e4 <halt_thread+0x10c> @ imm = #0x2
; 		return true;
 800f0e0: 2301         	movs	r3, #0x1
 800f0e2: e026         	b	0x800f132 <halt_thread+0x15a> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f0e4: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800f198 <halt_thread+0x1c0>
 800f0e6: 689b         	ldr	r3, [r3, #0x8]
 800f0e8: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 800f0ea: 697b         	ldr	r3, [r7, #0x14]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800f0ec: 4618         	mov	r0, r3
 800f0ee: f00a fe73    	bl	0x8019dd8 <z_is_thread_prevented_from_running> @ imm = #0xace6
 800f0f2: 4603         	mov	r3, r0
 800f0f4: 2b00         	cmp	r3, #0x0
 800f0f6: d001         	beq	0x800f0fc <halt_thread+0x124> @ imm = #0x2
; 		return true;
 800f0f8: 2301         	movs	r3, #0x1
 800f0fa: e01a         	b	0x800f132 <halt_thread+0x15a> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f0fc: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800f198 <halt_thread+0x1c0>
 800f0fe: 689b         	ldr	r3, [r3, #0x8]
 800f100: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 800f102: 693b         	ldr	r3, [r7, #0x10]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800f104: 4618         	mov	r0, r3
 800f106: f00a fe3b    	bl	0x8019d80 <thread_is_preemptible> @ imm = #0xac76
 800f10a: 4603         	mov	r3, r0
 800f10c: 2b00         	cmp	r3, #0x0
 800f10e: d105         	bne	0x800f11c <halt_thread+0x144> @ imm = #0xa
 800f110: 69f8         	ldr	r0, [r7, #0x1c]
 800f112: f00a fe45    	bl	0x8019da0 <thread_is_metairq> @ imm = #0xac8a
 800f116: 4603         	mov	r3, r0
 800f118: 2b00         	cmp	r3, #0x0
 800f11a: d001         	beq	0x800f120 <halt_thread+0x148> @ imm = #0x2
; 		return true;
 800f11c: 2301         	movs	r3, #0x1
 800f11e: e008         	b	0x800f132 <halt_thread+0x15a> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800f120: 69f8         	ldr	r0, [r7, #0x1c]
 800f122: f00a fe6d    	bl	0x8019e00 <z_is_thread_timeout_active> @ imm = #0xacda
 800f126: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800f128: 2b00         	cmp	r3, #0x0
 800f12a: d001         	beq	0x800f130 <halt_thread+0x158> @ imm = #0x2
; 		return true;
 800f12c: 2301         	movs	r3, #0x1
 800f12e: e000         	b	0x800f132 <halt_thread+0x15a> @ imm = #0x0
; 	return false;
 800f130: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800f132: 2b00         	cmp	r3, #0x0
 800f134: d010         	beq	0x800f158 <halt_thread+0x180> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f136: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800f198 <halt_thread+0x1c0>
 800f138: 689b         	ldr	r3, [r3, #0x8]
 800f13a: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800f13c: 68fb         	ldr	r3, [r7, #0xc]
; 		if (thread != arch_current_thread()) {
 800f13e: 6a3a         	ldr	r2, [r7, #0x20]
 800f140: 429a         	cmp	r2, r3
 800f142: d002         	beq	0x800f14a <halt_thread+0x172> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800f144: 6a38         	ldr	r0, [r7, #0x20]
 800f146: f000 f9ab    	bl	0x800f4a0 <z_reset_time_slice> @ imm = #0x356
; 		update_metairq_preempt(thread);
 800f14a: 6a38         	ldr	r0, [r7, #0x20]
 800f14c: f00a ffcd    	bl	0x801a0ea <update_metairq_preempt> @ imm = #0xaf9a
; 		_kernel.ready_q.cache = thread;
 800f150: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800f198 <halt_thread+0x1c0>
 800f152: 6a3b         	ldr	r3, [r7, #0x20]
 800f154: 61d3         	str	r3, [r2, #0x1c]
; }
 800f156: e005         	b	0x800f164 <halt_thread+0x18c> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f158: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800f198 <halt_thread+0x1c0>
 800f15a: 689b         	ldr	r3, [r3, #0x8]
 800f15c: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 800f15e: 68bb         	ldr	r3, [r7, #0x8]
; 		_kernel.ready_q.cache = arch_current_thread();
 800f160: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800f198 <halt_thread+0x1c0>
 800f162: 61d3         	str	r3, [r2, #0x1c]
; }
 800f164: bf00         	nop
; 		if (new_state == _THREAD_SUSPENDED) {
 800f166: 78fb         	ldrb	r3, [r7, #0x3]
 800f168: 2b10         	cmp	r3, #0x10
 800f16a: d103         	bne	0x800f174 <halt_thread+0x19c> @ imm = #0x6
; 			clear_halting(thread);
 800f16c: 6878         	ldr	r0, [r7, #0x4]
 800f16e: f00a ffa7    	bl	0x801a0c0 <clear_halting> @ imm = #0xaf4e
; 			return;
 800f172: e00c         	b	0x800f18e <halt_thread+0x1b6> @ imm = #0x18
; 		z_thread_monitor_exit(thread);
 800f174: 6878         	ldr	r0, [r7, #0x4]
 800f176: f000 fa49    	bl	0x800f60c <z_thread_monitor_exit> @ imm = #0x492
; 		if (dummify && !IS_ENABLED(CONFIG_ARCH_POSIX)) {
 800f17a: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800f17e: 2b00         	cmp	r3, #0x0
 800f180: d002         	beq	0x800f188 <halt_thread+0x1b0> @ imm = #0x4
; 			z_dummy_thread_init(&_thread_dummy);
 800f182: 4806         	ldr	r0, [pc, #0x18]         @ 0x800f19c <halt_thread+0x1c4>
 800f184: f7fe fc5a    	bl	0x800da3c <z_dummy_thread_init> @ imm = #-0x174c
; 		clear_halting(thread);
 800f188: 6878         	ldr	r0, [r7, #0x4]
 800f18a: f00a ff99    	bl	0x801a0c0 <clear_halting> @ imm = #0xaf32
; }
 800f18e: 3758         	adds	r7, #0x58
 800f190: 46bd         	mov	sp, r7
 800f192: bd80         	pop	{r7, pc}

0800f194 <$d>:
 800f194: 50 07 00 20  	.word	0x20000750
 800f198: 30 07 00 20  	.word	0x20000730
 800f19c: 10 09 00 20  	.word	0x20000910

0800f1a0 <z_thread_abort>:
; {
 800f1a0: b580         	push	{r7, lr}
 800f1a2: b094         	sub	sp, #0x50
 800f1a4: af00         	add	r7, sp, #0x0
 800f1a6: 6078         	str	r0, [r7, #0x4]
 800f1a8: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x800f26c <z_thread_abort+0xcc>
 800f1aa: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f1ac: f3ef 8311    	mrs	r3, basepri
 800f1b0: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800f1b2: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 800f1b4: 647b         	str	r3, [r7, #0x44]
 800f1b6: 2310         	movs	r3, #0x10
 800f1b8: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f1ba: 6c3b         	ldr	r3, [r7, #0x40]
 800f1bc: f383 8812    	msr	basepri_max, r3
; }
 800f1c0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f1c2: f3bf 8f6f    	isb	sy
; }
 800f1c6: bf00         	nop
; 	return key;
 800f1c8: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 800f1ca: 60bb         	str	r3, [r7, #0x8]
 800f1cc: 6cfb         	ldr	r3, [r7, #0x4c]
 800f1ce: 63fb         	str	r3, [r7, #0x3c]
; }
 800f1d0: bf00         	nop
 800f1d2: 6cfb         	ldr	r3, [r7, #0x4c]
 800f1d4: 63bb         	str	r3, [r7, #0x38]
; }
 800f1d6: bf00         	nop
; 	return k;
 800f1d8: 68bb         	ldr	r3, [r7, #0x8]
 800f1da: 617b         	str	r3, [r7, #0x14]
; 	if (z_is_thread_essential(thread)) {
 800f1dc: 6878         	ldr	r0, [r7, #0x4]
 800f1de: f00a fea9    	bl	0x8019f34 <z_is_thread_essential> @ imm = #0xad52
 800f1e2: 4603         	mov	r3, r0
 800f1e4: 2b00         	cmp	r3, #0x0
 800f1e6: d020         	beq	0x800f22a <z_thread_abort+0x8a> @ imm = #0x40
 800f1e8: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800f26c <z_thread_abort+0xcc>
 800f1ea: 62fb         	str	r3, [r7, #0x2c]
 800f1ec: 697b         	ldr	r3, [r7, #0x14]
 800f1ee: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800f1f0: 68fb         	ldr	r3, [r7, #0xc]
 800f1f2: 62bb         	str	r3, [r7, #0x28]
 800f1f4: 6abb         	ldr	r3, [r7, #0x28]
 800f1f6: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f1f8: 6a7b         	ldr	r3, [r7, #0x24]
 800f1fa: f383 8811    	msr	basepri, r3
; }
 800f1fe: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f200: f3bf 8f6f    	isb	sy
; }
 800f204: bf00         	nop
; }
 800f206: bf00         	nop
; }
 800f208: bf00         	nop
 800f20a: 2300         	movs	r3, #0x0
 800f20c: 637b         	str	r3, [r7, #0x34]
 800f20e: 6b7b         	ldr	r3, [r7, #0x34]
 800f210: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f212: 6b3b         	ldr	r3, [r7, #0x30]
 800f214: f383 8811    	msr	basepri, r3
; }
 800f218: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f21a: f3bf 8f6f    	isb	sy
; }
 800f21e: bf00         	nop
; }
 800f220: bf00         	nop
; 		k_panic();
 800f222: 2304         	movs	r3, #0x4
 800f224: 4618         	mov	r0, r3
 800f226: df02         	svc	#0x2
; 		return;
 800f228: e01c         	b	0x800f264 <z_thread_abort+0xc4> @ imm = #0x38
; 	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 800f22a: 687b         	ldr	r3, [r7, #0x4]
 800f22c: 7b5b         	ldrb	r3, [r3, #0xd]
 800f22e: f003 0308    	and	r3, r3, #0x8
 800f232: 2b00         	cmp	r3, #0x0
 800f234: d011         	beq	0x800f25a <z_thread_abort+0xba> @ imm = #0x22
 800f236: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800f26c <z_thread_abort+0xcc>
 800f238: 623b         	str	r3, [r7, #0x20]
 800f23a: 697b         	ldr	r3, [r7, #0x14]
 800f23c: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800f23e: 693b         	ldr	r3, [r7, #0x10]
 800f240: 61fb         	str	r3, [r7, #0x1c]
 800f242: 69fb         	ldr	r3, [r7, #0x1c]
 800f244: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f246: 69bb         	ldr	r3, [r7, #0x18]
 800f248: f383 8811    	msr	basepri, r3
; }
 800f24c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f24e: f3bf 8f6f    	isb	sy
; }
 800f252: bf00         	nop
; }
 800f254: bf00         	nop
; }
 800f256: bf00         	nop
; 		return;
 800f258: e004         	b	0x800f264 <z_thread_abort+0xc4> @ imm = #0x8
; 	z_thread_halt(thread, key, true);
 800f25a: 2201         	movs	r2, #0x1
 800f25c: 6979         	ldr	r1, [r7, #0x14]
 800f25e: 6878         	ldr	r0, [r7, #0x4]
 800f260: f7fe fe80    	bl	0x800df64 <z_thread_halt> @ imm = #-0x1300
; }
 800f264: 3750         	adds	r7, #0x50
 800f266: 46bd         	mov	sp, r7
 800f268: bd80         	pop	{r7, pc}
 800f26a: bf00         	nop

0800f26c <$d>:
 800f26c: 2c 11 00 20  	.word	0x2000112c

0800f270 <z_sched_wake>:
; {
 800f270: b580         	push	{r7, lr}
 800f272: b09c         	sub	sp, #0x70
 800f274: af00         	add	r7, sp, #0x0
 800f276: 60f8         	str	r0, [r7, #0xc]
 800f278: 60b9         	str	r1, [r7, #0x8]
 800f27a: 607a         	str	r2, [r7, #0x4]
; 	bool ret = false;
 800f27c: 2300         	movs	r3, #0x0
 800f27e: f887 306f    	strb.w	r3, [r7, #0x6f]
; 	K_SPINLOCK(&_sched_spinlock) {
 800f282: 2300         	movs	r3, #0x0
 800f284: 623b         	str	r3, [r7, #0x20]
 800f286: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x800f358 <z_sched_wake+0xe8>
 800f288: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f28a: f3ef 8311    	mrs	r3, basepri
 800f28e: 663b         	str	r3, [r7, #0x60]
;   return(result);
 800f290: 6e3b         	ldr	r3, [r7, #0x60]
; 	key = __get_BASEPRI();
 800f292: 65fb         	str	r3, [r7, #0x5c]
 800f294: 2310         	movs	r3, #0x10
 800f296: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f298: 6dbb         	ldr	r3, [r7, #0x58]
 800f29a: f383 8812    	msr	basepri_max, r3
; }
 800f29e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f2a0: f3bf 8f6f    	isb	sy
; }
 800f2a4: bf00         	nop
; 	return key;
 800f2a6: 6dfb         	ldr	r3, [r7, #0x5c]
; 	k.key = arch_irq_lock();
 800f2a8: 617b         	str	r3, [r7, #0x14]
 800f2aa: 6e7b         	ldr	r3, [r7, #0x64]
 800f2ac: 657b         	str	r3, [r7, #0x54]
; }
 800f2ae: bf00         	nop
 800f2b0: 6e7b         	ldr	r3, [r7, #0x64]
 800f2b2: 653b         	str	r3, [r7, #0x50]
; }
 800f2b4: bf00         	nop
; 	return k;
 800f2b6: 697b         	ldr	r3, [r7, #0x14]
 800f2b8: 61fb         	str	r3, [r7, #0x1c]
; 	K_SPINLOCK(&_sched_spinlock) {
 800f2ba: e043         	b	0x800f344 <z_sched_wake+0xd4> @ imm = #0x86
; 		thread = _priq_wait_best(&wait_q->waitq);
 800f2bc: 68fb         	ldr	r3, [r7, #0xc]
 800f2be: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800f2c0: 2300         	movs	r3, #0x0
 800f2c2: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800f2c4: 6cf8         	ldr	r0, [r7, #0x4c]
 800f2c6: f00a fca3    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #0xa946
 800f2ca: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800f2cc: 6c7b         	ldr	r3, [r7, #0x44]
 800f2ce: 2b00         	cmp	r3, #0x0
 800f2d0: d001         	beq	0x800f2d6 <z_sched_wake+0x66> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800f2d2: 6c7b         	ldr	r3, [r7, #0x44]
 800f2d4: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800f2d6: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800f2d8: 66bb         	str	r3, [r7, #0x68]
; 		if (thread != NULL) {
 800f2da: 6ebb         	ldr	r3, [r7, #0x68]
 800f2dc: 2b00         	cmp	r3, #0x0
 800f2de: d01e         	beq	0x800f31e <z_sched_wake+0xae> @ imm = #0x3c
; 			z_thread_return_value_set_with_data(thread,
 800f2e0: 68bb         	ldr	r3, [r7, #0x8]
 800f2e2: 6eba         	ldr	r2, [r7, #0x68]
 800f2e4: 643a         	str	r2, [r7, #0x40]
 800f2e6: 63fb         	str	r3, [r7, #0x3c]
 800f2e8: 687b         	ldr	r3, [r7, #0x4]
 800f2ea: 63bb         	str	r3, [r7, #0x38]
 800f2ec: 6c3b         	ldr	r3, [r7, #0x40]
 800f2ee: 637b         	str	r3, [r7, #0x34]
 800f2f0: 6bfb         	ldr	r3, [r7, #0x3c]
 800f2f2: 633b         	str	r3, [r7, #0x30]
; 	thread->arch.swap_return_value = value;
 800f2f4: 6b7b         	ldr	r3, [r7, #0x34]
 800f2f6: 6b3a         	ldr	r2, [r7, #0x30]
 800f2f8: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800f2fc: bf00         	nop
; 	thread->base.swap_data = data;
 800f2fe: 6c3b         	ldr	r3, [r7, #0x40]
 800f300: 6bba         	ldr	r2, [r7, #0x38]
 800f302: 615a         	str	r2, [r3, #0x14]
; }
 800f304: bf00         	nop
; 			unpend_thread_no_timeout(thread);
 800f306: 6eb8         	ldr	r0, [r7, #0x68]
 800f308: f00a fe3f    	bl	0x8019f8a <unpend_thread_no_timeout> @ imm = #0xac7e
; 			(void)z_abort_thread_timeout(thread);
 800f30c: 6eb8         	ldr	r0, [r7, #0x68]
 800f30e: f00a fd29    	bl	0x8019d64 <z_abort_thread_timeout> @ imm = #0xaa52
; 			ready_thread(thread);
 800f312: 6eb8         	ldr	r0, [r7, #0x68]
 800f314: f7fe fca6    	bl	0x800dc64 <ready_thread> @ imm = #-0x16b4
; 			ret = true;
 800f318: 2301         	movs	r3, #0x1
 800f31a: f887 306f    	strb.w	r3, [r7, #0x6f]
 800f31e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800f358 <z_sched_wake+0xe8>
 800f320: 62fb         	str	r3, [r7, #0x2c]
 800f322: 69fb         	ldr	r3, [r7, #0x1c]
 800f324: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800f326: 69bb         	ldr	r3, [r7, #0x18]
 800f328: 62bb         	str	r3, [r7, #0x28]
 800f32a: 6abb         	ldr	r3, [r7, #0x28]
 800f32c: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f32e: 6a7b         	ldr	r3, [r7, #0x24]
 800f330: f383 8811    	msr	basepri, r3
; }
 800f334: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f336: f3bf 8f6f    	isb	sy
; }
 800f33a: bf00         	nop
; }
 800f33c: bf00         	nop
; }
 800f33e: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800f340: 2301         	movs	r3, #0x1
 800f342: 623b         	str	r3, [r7, #0x20]
 800f344: 6a3b         	ldr	r3, [r7, #0x20]
 800f346: 2b00         	cmp	r3, #0x0
 800f348: d0b8         	beq	0x800f2bc <z_sched_wake+0x4c> @ imm = #-0x90
; 	return ret;
 800f34a: f897 306f    	ldrb.w	r3, [r7, #0x6f]
; }
 800f34e: 4618         	mov	r0, r3
 800f350: 3770         	adds	r7, #0x70
 800f352: 46bd         	mov	sp, r7
 800f354: bd80         	pop	{r7, pc}
 800f356: bf00         	nop

0800f358 <$d>:
 800f358: 2c 11 00 20  	.word	0x2000112c

0800f35c <z_sched_wait>:
; {
 800f35c: b580         	push	{r7, lr}
 800f35e: b088         	sub	sp, #0x20
 800f360: af02         	add	r7, sp, #0x8
 800f362: 60f8         	str	r0, [r7, #0xc]
 800f364: 60b9         	str	r1, [r7, #0x8]
 800f366: 607a         	str	r2, [r7, #0x4]
; 	int ret = z_pend_curr(lock, key, wait_q, timeout);
 800f368: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 800f36c: e9cd 2300    	strd	r2, r3, [sp]
 800f370: 687a         	ldr	r2, [r7, #0x4]
 800f372: 68b9         	ldr	r1, [r7, #0x8]
 800f374: 68f8         	ldr	r0, [r7, #0xc]
 800f376: f7ff f94b    	bl	0x800e610 <z_pend_curr> @ imm = #-0xd6a
 800f37a: 6178         	str	r0, [r7, #0x14]
; 	if (data != NULL) {
 800f37c: 6abb         	ldr	r3, [r7, #0x28]
 800f37e: 2b00         	cmp	r3, #0x0
 800f380: d006         	beq	0x800f390 <z_sched_wait+0x34> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f382: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800f39c <z_sched_wait+0x40>
 800f384: 689b         	ldr	r3, [r3, #0x8]
 800f386: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 800f388: 693b         	ldr	r3, [r7, #0x10]
; 		*data = arch_current_thread()->base.swap_data;
 800f38a: 695a         	ldr	r2, [r3, #0x14]
 800f38c: 6abb         	ldr	r3, [r7, #0x28]
 800f38e: 601a         	str	r2, [r3]
; 	return ret;
 800f390: 697b         	ldr	r3, [r7, #0x14]
; }
 800f392: 4618         	mov	r0, r3
 800f394: 3718         	adds	r7, #0x18
 800f396: 46bd         	mov	sp, r7
 800f398: bd80         	pop	{r7, pc}
 800f39a: bf00         	nop

0800f39c <$d>:
 800f39c: 30 07 00 20  	.word	0x20000730

0800f3a0 <z_is_idle_thread_object>:
; {
 800f3a0: b480         	push	{r7}
 800f3a2: b083         	sub	sp, #0xc
 800f3a4: af00         	add	r7, sp, #0x0
 800f3a6: 6078         	str	r0, [r7, #0x4]
; 	return thread == &z_idle_threads[0];
 800f3a8: 687b         	ldr	r3, [r7, #0x4]
 800f3aa: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800f3c0 <z_is_idle_thread_object+0x20>
 800f3ac: 4293         	cmp	r3, r2
 800f3ae: bf0c         	ite	eq
 800f3b0: 2301         	moveq	r3, #0x1
 800f3b2: 2300         	movne	r3, #0x0
 800f3b4: b2db         	uxtb	r3, r3
; }
 800f3b6: 4618         	mov	r0, r3
 800f3b8: 370c         	adds	r7, #0xc
 800f3ba: 46bd         	mov	sp, r7
 800f3bc: bc80         	pop	{r7}
 800f3be: 4770         	bx	lr

0800f3c0 <$d>:
 800f3c0: 40 08 00 20  	.word	0x20000840

0800f3c4 <slice_time>:
; {
 800f3c4: b480         	push	{r7}
 800f3c6: b085         	sub	sp, #0x14
 800f3c8: af00         	add	r7, sp, #0x0
 800f3ca: 6078         	str	r0, [r7, #0x4]
; 	int ret = slice_ticks;
 800f3cc: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800f3e0 <slice_time+0x1c>
 800f3ce: 681b         	ldr	r3, [r3]
 800f3d0: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800f3d2: 68fb         	ldr	r3, [r7, #0xc]
; }
 800f3d4: 4618         	mov	r0, r3
 800f3d6: 3714         	adds	r7, #0x14
 800f3d8: 46bd         	mov	sp, r7
 800f3da: bc80         	pop	{r7}
 800f3dc: 4770         	bx	lr
 800f3de: bf00         	nop

0800f3e0 <$d>:
 800f3e0: 2c 11 00 20  	.word	0x2000112c

0800f3e4 <thread_is_sliceable>:
; {
 800f3e4: b580         	push	{r7, lr}
 800f3e6: b084         	sub	sp, #0x10
 800f3e8: af00         	add	r7, sp, #0x0
 800f3ea: 6078         	str	r0, [r7, #0x4]
; 	bool ret = thread_is_preemptible(thread)
 800f3ec: 6878         	ldr	r0, [r7, #0x4]
 800f3ee: f00a ffd1    	bl	0x801a394 <thread_is_preemptible> @ imm = #0xafa2
 800f3f2: 4603         	mov	r3, r0
; 		&& !z_is_idle_thread_object(thread);
 800f3f4: 2b00         	cmp	r3, #0x0
 800f3f6: d029         	beq	0x800f44c <thread_is_sliceable+0x68> @ imm = #0x52
; 		&& slice_time(thread) != 0
 800f3f8: 6878         	ldr	r0, [r7, #0x4]
 800f3fa: f7ff ffe3    	bl	0x800f3c4 <slice_time>  @ imm = #-0x3a
 800f3fe: 4603         	mov	r3, r0
 800f400: 2b00         	cmp	r3, #0x0
 800f402: d023         	beq	0x800f44c <thread_is_sliceable+0x68> @ imm = #0x46
; 		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 800f404: 687b         	ldr	r3, [r7, #0x4]
 800f406: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800f40a: 461a         	mov	r2, r3
 800f40c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800f464 <thread_is_sliceable+0x80>
 800f40e: 681b         	ldr	r3, [r3]
 800f410: 4619         	mov	r1, r3
 800f412: 4610         	mov	r0, r2
 800f414: f00a fff3    	bl	0x801a3fe <z_is_prio_higher> @ imm = #0xafe6
 800f418: 4603         	mov	r3, r0
 800f41a: f083 0301    	eor	r3, r3, #0x1
 800f41e: b2db         	uxtb	r3, r3
 800f420: 2b00         	cmp	r3, #0x0
 800f422: d013         	beq	0x800f44c <thread_is_sliceable+0x68> @ imm = #0x26
; 		&& !z_is_thread_prevented_from_running(thread)
 800f424: 6878         	ldr	r0, [r7, #0x4]
 800f426: f00a ffc5    	bl	0x801a3b4 <z_is_thread_prevented_from_running> @ imm = #0xaf8a
 800f42a: 4603         	mov	r3, r0
 800f42c: f083 0301    	eor	r3, r3, #0x1
 800f430: b2db         	uxtb	r3, r3
 800f432: 2b00         	cmp	r3, #0x0
 800f434: d00a         	beq	0x800f44c <thread_is_sliceable+0x68> @ imm = #0x14
; 		&& !z_is_idle_thread_object(thread);
 800f436: 6878         	ldr	r0, [r7, #0x4]
 800f438: f7ff ffb2    	bl	0x800f3a0 <z_is_idle_thread_object> @ imm = #-0x9c
 800f43c: 4603         	mov	r3, r0
 800f43e: f083 0301    	eor	r3, r3, #0x1
 800f442: b2db         	uxtb	r3, r3
 800f444: 2b00         	cmp	r3, #0x0
 800f446: d001         	beq	0x800f44c <thread_is_sliceable+0x68> @ imm = #0x2
 800f448: 2301         	movs	r3, #0x1
 800f44a: e000         	b	0x800f44e <thread_is_sliceable+0x6a> @ imm = #0x0
 800f44c: 2300         	movs	r3, #0x0
; 	bool ret = thread_is_preemptible(thread)
 800f44e: 73fb         	strb	r3, [r7, #0xf]
 800f450: 7bfb         	ldrb	r3, [r7, #0xf]
 800f452: f003 0301    	and	r3, r3, #0x1
 800f456: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 800f458: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 800f45a: 4618         	mov	r0, r3
 800f45c: 3710         	adds	r7, #0x10
 800f45e: 46bd         	mov	sp, r7
 800f460: bd80         	pop	{r7, pc}
 800f462: bf00         	nop

0800f464 <$d>:
 800f464: 30 11 00 20  	.word	0x20001130

0800f468 <slice_timeout>:
; {
 800f468: b480         	push	{r7}
 800f46a: b085         	sub	sp, #0x14
 800f46c: af00         	add	r7, sp, #0x0
 800f46e: 6078         	str	r0, [r7, #0x4]
; 	int cpu = ARRAY_INDEX(slice_timeouts, timeout);
 800f470: 687b         	ldr	r3, [r7, #0x4]
 800f472: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800f494 <slice_timeout+0x2c>
 800f474: 1a9b         	subs	r3, r3, r2
 800f476: 10db         	asrs	r3, r3, #0x3
 800f478: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800f498 <slice_timeout+0x30>
 800f47a: fb02 f303    	mul	r3, r2, r3
 800f47e: 60fb         	str	r3, [r7, #0xc]
; 	slice_expired[cpu] = true;
 800f480: 4a06         	ldr	r2, [pc, #0x18]         @ 0x800f49c <slice_timeout+0x34>
 800f482: 68fb         	ldr	r3, [r7, #0xc]
 800f484: 4413         	add	r3, r2
 800f486: 2201         	movs	r2, #0x1
 800f488: 701a         	strb	r2, [r3]
; }
 800f48a: bf00         	nop
 800f48c: 3714         	adds	r7, #0x14
 800f48e: 46bd         	mov	sp, r7
 800f490: bc80         	pop	{r7}
 800f492: 4770         	bx	lr

0800f494 <$d>:
 800f494: e0 09 00 20  	.word	0x200009e0
 800f498: ab aa aa aa  	.word	0xaaaaaaab
 800f49c: 34 11 00 20  	.word	0x20001134

0800f4a0 <z_reset_time_slice>:
; {
 800f4a0: e92d 4390    	push.w	{r4, r7, r8, r9, lr}
 800f4a4: b085         	sub	sp, #0x14
 800f4a6: af00         	add	r7, sp, #0x0
 800f4a8: 6078         	str	r0, [r7, #0x4]
; 	int cpu = _current_cpu->id;
 800f4aa: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800f510 <z_reset_time_slice+0x70>
 800f4ac: 7c1b         	ldrb	r3, [r3, #0x10]
 800f4ae: 60fb         	str	r3, [r7, #0xc]
; 	z_abort_timeout(&slice_timeouts[cpu]);
 800f4b0: 68fa         	ldr	r2, [r7, #0xc]
 800f4b2: 4613         	mov	r3, r2
 800f4b4: 005b         	lsls	r3, r3, #0x1
 800f4b6: 4413         	add	r3, r2
 800f4b8: 00db         	lsls	r3, r3, #0x3
 800f4ba: 4a16         	ldr	r2, [pc, #0x58]         @ 0x800f514 <z_reset_time_slice+0x74>
 800f4bc: 4413         	add	r3, r2
 800f4be: 4618         	mov	r0, r3
 800f4c0: f000 fa4a    	bl	0x800f958 <z_abort_timeout> @ imm = #0x494
; 	slice_expired[cpu] = false;
 800f4c4: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800f518 <z_reset_time_slice+0x78>
 800f4c6: 68fb         	ldr	r3, [r7, #0xc]
 800f4c8: 4413         	add	r3, r2
 800f4ca: 2200         	movs	r2, #0x0
 800f4cc: 701a         	strb	r2, [r3]
; 	if (thread_is_sliceable(thread)) {
 800f4ce: 6878         	ldr	r0, [r7, #0x4]
 800f4d0: f7ff ff88    	bl	0x800f3e4 <thread_is_sliceable> @ imm = #-0xf0
 800f4d4: 4603         	mov	r3, r0
 800f4d6: 2b00         	cmp	r3, #0x0
 800f4d8: d014         	beq	0x800f504 <z_reset_time_slice+0x64> @ imm = #0x28
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 800f4da: 68fa         	ldr	r2, [r7, #0xc]
 800f4dc: 4613         	mov	r3, r2
 800f4de: 005b         	lsls	r3, r3, #0x1
 800f4e0: 4413         	add	r3, r2
 800f4e2: 00db         	lsls	r3, r3, #0x3
 800f4e4: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800f514 <z_reset_time_slice+0x74>
 800f4e6: 189c         	adds	r4, r3, r2
; 			      K_TICKS(slice_time(thread) - 1));
 800f4e8: 6878         	ldr	r0, [r7, #0x4]
 800f4ea: f7ff ff6b    	bl	0x800f3c4 <slice_time>  @ imm = #-0x12a
 800f4ee: 4603         	mov	r3, r0
 800f4f0: 3b01         	subs	r3, #0x1
 800f4f2: 17da         	asrs	r2, r3, #0x1f
 800f4f4: 4698         	mov	r8, r3
 800f4f6: 4691         	mov	r9, r2
 800f4f8: 4642         	mov	r2, r8
 800f4fa: 464b         	mov	r3, r9
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 800f4fc: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800f51c <z_reset_time_slice+0x7c>
 800f4fe: 4620         	mov	r0, r4
 800f500: f000 f932    	bl	0x800f768 <z_add_timeout> @ imm = #0x264
; }
 800f504: bf00         	nop
 800f506: 3714         	adds	r7, #0x14
 800f508: 46bd         	mov	sp, r7
 800f50a: e8bd 8390    	pop.w	{r4, r7, r8, r9, pc}
 800f50e: bf00         	nop

0800f510 <$d>:
 800f510: 30 07 00 20  	.word	0x20000730
 800f514: e0 09 00 20  	.word	0x200009e0
 800f518: 34 11 00 20  	.word	0x20001134
 800f51c: 69 f4 00 08  	.word	0x0800f469

0800f520 <z_time_slice>:
; {
 800f520: b580         	push	{r7, lr}
 800f522: b092         	sub	sp, #0x48
 800f524: af00         	add	r7, sp, #0x0
 800f526: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800f5fc <z_time_slice+0xdc>
 800f528: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f52a: f3ef 8311    	mrs	r3, basepri
 800f52e: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800f530: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 800f532: 637b         	str	r3, [r7, #0x34]
 800f534: 2310         	movs	r3, #0x10
 800f536: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f538: 6b3b         	ldr	r3, [r7, #0x30]
 800f53a: f383 8812    	msr	basepri_max, r3
; }
 800f53e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f540: f3bf 8f6f    	isb	sy
; }
 800f544: bf00         	nop
; 	return key;
 800f546: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 800f548: 603b         	str	r3, [r7]
 800f54a: 6bfb         	ldr	r3, [r7, #0x3c]
 800f54c: 62fb         	str	r3, [r7, #0x2c]
; }
 800f54e: bf00         	nop
 800f550: 6bfb         	ldr	r3, [r7, #0x3c]
 800f552: 62bb         	str	r3, [r7, #0x28]
; }
 800f554: bf00         	nop
; 	return k;
 800f556: 683b         	ldr	r3, [r7]
 800f558: 60fb         	str	r3, [r7, #0xc]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f55a: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800f600 <z_time_slice+0xe0>
 800f55c: 689b         	ldr	r3, [r3, #0x8]
 800f55e: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 800f560: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *curr = arch_current_thread();
 800f562: 647b         	str	r3, [r7, #0x44]
; 	if (pending_current == curr) {
 800f564: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800f604 <z_time_slice+0xe4>
 800f566: 681b         	ldr	r3, [r3]
 800f568: 6c7a         	ldr	r2, [r7, #0x44]
 800f56a: 429a         	cmp	r2, r3
 800f56c: d113         	bne	0x800f596 <z_time_slice+0x76> @ imm = #0x26
; 		z_reset_time_slice(curr);
 800f56e: 6c78         	ldr	r0, [r7, #0x44]
 800f570: f7ff ff96    	bl	0x800f4a0 <z_reset_time_slice> @ imm = #-0xd4
 800f574: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800f5fc <z_time_slice+0xdc>
 800f576: 627b         	str	r3, [r7, #0x24]
 800f578: 68fb         	ldr	r3, [r7, #0xc]
 800f57a: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 800f57c: 687b         	ldr	r3, [r7, #0x4]
 800f57e: 623b         	str	r3, [r7, #0x20]
 800f580: 6a3b         	ldr	r3, [r7, #0x20]
 800f582: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f584: 69fb         	ldr	r3, [r7, #0x1c]
 800f586: f383 8811    	msr	basepri, r3
; }
 800f58a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f58c: f3bf 8f6f    	isb	sy
; }
 800f590: bf00         	nop
; }
 800f592: bf00         	nop
; }
 800f594: e02f         	b	0x800f5f6 <z_time_slice+0xd6> @ imm = #0x5e
; 	pending_current = NULL;
 800f596: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800f604 <z_time_slice+0xe4>
 800f598: 2200         	movs	r2, #0x0
 800f59a: 601a         	str	r2, [r3]
; 	if (slice_expired[_current_cpu->id] && thread_is_sliceable(curr)) {
 800f59c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800f600 <z_time_slice+0xe0>
 800f59e: 7c1b         	ldrb	r3, [r3, #0x10]
 800f5a0: 461a         	mov	r2, r3
 800f5a2: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800f608 <z_time_slice+0xe8>
 800f5a4: 5c9b         	ldrb	r3, [r3, r2]
 800f5a6: 2b00         	cmp	r3, #0x0
 800f5a8: d014         	beq	0x800f5d4 <z_time_slice+0xb4> @ imm = #0x28
 800f5aa: 6c78         	ldr	r0, [r7, #0x44]
 800f5ac: f7ff ff1a    	bl	0x800f3e4 <thread_is_sliceable> @ imm = #-0x1cc
 800f5b0: 4603         	mov	r3, r0
 800f5b2: 2b00         	cmp	r3, #0x0
 800f5b4: d00e         	beq	0x800f5d4 <z_time_slice+0xb4> @ imm = #0x1c
; 		if (!z_is_thread_prevented_from_running(curr)) {
 800f5b6: 6c78         	ldr	r0, [r7, #0x44]
 800f5b8: f00a fefc    	bl	0x801a3b4 <z_is_thread_prevented_from_running> @ imm = #0xadf8
 800f5bc: 4603         	mov	r3, r0
 800f5be: f083 0301    	eor	r3, r3, #0x1
 800f5c2: b2db         	uxtb	r3, r3
 800f5c4: 2b00         	cmp	r3, #0x0
 800f5c6: d002         	beq	0x800f5ce <z_time_slice+0xae> @ imm = #0x4
; 			move_thread_to_end_of_prio_q(curr);
 800f5c8: 6c78         	ldr	r0, [r7, #0x44]
 800f5ca: f7fe fa5b    	bl	0x800da84 <move_thread_to_end_of_prio_q> @ imm = #-0x1b4a
; 		z_reset_time_slice(curr);
 800f5ce: 6c78         	ldr	r0, [r7, #0x44]
 800f5d0: f7ff ff66    	bl	0x800f4a0 <z_reset_time_slice> @ imm = #-0x134
 800f5d4: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800f5fc <z_time_slice+0xdc>
 800f5d6: 61bb         	str	r3, [r7, #0x18]
 800f5d8: 68fb         	ldr	r3, [r7, #0xc]
 800f5da: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800f5dc: 68bb         	ldr	r3, [r7, #0x8]
 800f5de: 617b         	str	r3, [r7, #0x14]
 800f5e0: 697b         	ldr	r3, [r7, #0x14]
 800f5e2: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f5e4: 693b         	ldr	r3, [r7, #0x10]
 800f5e6: f383 8811    	msr	basepri, r3
; }
 800f5ea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f5ec: f3bf 8f6f    	isb	sy
; }
 800f5f0: bf00         	nop
; }
 800f5f2: bf00         	nop
; }
 800f5f4: bf00         	nop
; }
 800f5f6: 3748         	adds	r7, #0x48
 800f5f8: 46bd         	mov	sp, r7
 800f5fa: bd80         	pop	{r7, pc}

0800f5fc <$d>:
 800f5fc: 2c 11 00 20  	.word	0x2000112c
 800f600: 30 07 00 20  	.word	0x20000730
 800f604: 38 11 00 20  	.word	0x20001138
 800f608: 34 11 00 20  	.word	0x20001134

0800f60c <z_thread_monitor_exit>:
; {
 800f60c: b480         	push	{r7}
 800f60e: b091         	sub	sp, #0x44
 800f610: af00         	add	r7, sp, #0x0
 800f612: 6078         	str	r0, [r7, #0x4]
 800f614: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800f6c0 <z_thread_monitor_exit+0xb4>
 800f616: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f618: f3ef 8311    	mrs	r3, basepri
 800f61c: 637b         	str	r3, [r7, #0x34]
;   return(result);
 800f61e: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 800f620: 633b         	str	r3, [r7, #0x30]
 800f622: 2310         	movs	r3, #0x10
 800f624: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f626: 6afb         	ldr	r3, [r7, #0x2c]
 800f628: f383 8812    	msr	basepri_max, r3
; }
 800f62c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f62e: f3bf 8f6f    	isb	sy
; }
 800f632: bf00         	nop
; 	return key;
 800f634: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 800f636: 60fb         	str	r3, [r7, #0xc]
 800f638: 6bbb         	ldr	r3, [r7, #0x38]
 800f63a: 62bb         	str	r3, [r7, #0x28]
; }
 800f63c: bf00         	nop
 800f63e: 6bbb         	ldr	r3, [r7, #0x38]
 800f640: 627b         	str	r3, [r7, #0x24]
; }
 800f642: bf00         	nop
; 	return k;
 800f644: 68fb         	ldr	r3, [r7, #0xc]
 800f646: 617b         	str	r3, [r7, #0x14]
; 	if (thread == _kernel.threads) {
 800f648: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800f6c4 <z_thread_monitor_exit+0xb8>
 800f64a: 6a9b         	ldr	r3, [r3, #0x28]
 800f64c: 687a         	ldr	r2, [r7, #0x4]
 800f64e: 429a         	cmp	r2, r3
 800f650: d106         	bne	0x800f660 <z_thread_monitor_exit+0x54> @ imm = #0xc
; 		_kernel.threads = _kernel.threads->next_thread;
 800f652: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800f6c4 <z_thread_monitor_exit+0xb8>
 800f654: 6a9b         	ldr	r3, [r3, #0x28]
 800f656: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 800f65a: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x800f6c4 <z_thread_monitor_exit+0xb8>
 800f65c: 6293         	str	r3, [r2, #0x28]
 800f65e: e019         	b	0x800f694 <z_thread_monitor_exit+0x88> @ imm = #0x32
; 		prev_thread = _kernel.threads;
 800f660: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800f6c4 <z_thread_monitor_exit+0xb8>
 800f662: 6a9b         	ldr	r3, [r3, #0x28]
 800f664: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 800f666: e003         	b	0x800f670 <z_thread_monitor_exit+0x64> @ imm = #0x6
; 			prev_thread = prev_thread->next_thread;
 800f668: 6bfb         	ldr	r3, [r7, #0x3c]
 800f66a: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 800f66e: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 800f670: 6bfb         	ldr	r3, [r7, #0x3c]
 800f672: 2b00         	cmp	r3, #0x0
 800f674: d005         	beq	0x800f682 <z_thread_monitor_exit+0x76> @ imm = #0xa
; 			(thread != prev_thread->next_thread)) {
 800f676: 6bfb         	ldr	r3, [r7, #0x3c]
 800f678: f8d3 3090    	ldr.w	r3, [r3, #0x90]
; 		while ((prev_thread != NULL) &&
 800f67c: 687a         	ldr	r2, [r7, #0x4]
 800f67e: 429a         	cmp	r2, r3
 800f680: d1f2         	bne	0x800f668 <z_thread_monitor_exit+0x5c> @ imm = #-0x1c
; 		if (prev_thread != NULL) {
 800f682: 6bfb         	ldr	r3, [r7, #0x3c]
 800f684: 2b00         	cmp	r3, #0x0
 800f686: d005         	beq	0x800f694 <z_thread_monitor_exit+0x88> @ imm = #0xa
; 			prev_thread->next_thread = thread->next_thread;
 800f688: 687b         	ldr	r3, [r7, #0x4]
 800f68a: f8d3 2090    	ldr.w	r2, [r3, #0x90]
 800f68e: 6bfb         	ldr	r3, [r7, #0x3c]
 800f690: f8c3 2090    	str.w	r2, [r3, #0x90]
 800f694: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800f6c0 <z_thread_monitor_exit+0xb4>
 800f696: 623b         	str	r3, [r7, #0x20]
 800f698: 697b         	ldr	r3, [r7, #0x14]
 800f69a: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800f69c: 693b         	ldr	r3, [r7, #0x10]
 800f69e: 61fb         	str	r3, [r7, #0x1c]
 800f6a0: 69fb         	ldr	r3, [r7, #0x1c]
 800f6a2: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f6a4: 69bb         	ldr	r3, [r7, #0x18]
 800f6a6: f383 8811    	msr	basepri, r3
; }
 800f6aa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f6ac: f3bf 8f6f    	isb	sy
; }
 800f6b0: bf00         	nop
; }
 800f6b2: bf00         	nop
; }
 800f6b4: bf00         	nop
; }
 800f6b6: bf00         	nop
 800f6b8: 3744         	adds	r7, #0x44
 800f6ba: 46bd         	mov	sp, r7
 800f6bc: bc80         	pop	{r7}
 800f6be: 4770         	bx	lr

0800f6c0 <$d>:
 800f6c0: 3c 11 00 20  	.word	0x2000113c
 800f6c4: 30 07 00 20  	.word	0x20000730

0800f6c8 <z_data_copy>:
; {
 800f6c8: b580         	push	{r7, lr}
 800f6ca: af00         	add	r7, sp, #0x0
; 		       __data_region_end - __data_region_start);
 800f6cc: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800f6f0 <z_data_copy+0x28>
 800f6ce: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800f6f4 <z_data_copy+0x2c>
 800f6d0: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__data_region_start, &__data_region_load_start,
 800f6d2: 461a         	mov	r2, r3
 800f6d4: 4908         	ldr	r1, [pc, #0x20]         @ 0x800f6f8 <z_data_copy+0x30>
 800f6d6: 4807         	ldr	r0, [pc, #0x1c]         @ 0x800f6f4 <z_data_copy+0x2c>
 800f6d8: f009 f998    	bl	0x8018a0c <z_early_memcpy> @ imm = #0x9330
; 		       __ramfunc_end - __ramfunc_region_start);
 800f6dc: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800f6fc <z_data_copy+0x34>
 800f6de: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800f700 <z_data_copy+0x38>
 800f6e0: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__ramfunc_region_start, &__ramfunc_load_start,
 800f6e2: 461a         	mov	r2, r3
 800f6e4: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800f704 <z_data_copy+0x3c>
 800f6e6: 4806         	ldr	r0, [pc, #0x18]         @ 0x800f700 <z_data_copy+0x38>
 800f6e8: f009 f990    	bl	0x8018a0c <z_early_memcpy> @ imm = #0x9320
; }
 800f6ec: bf00         	nop
 800f6ee: bd80         	pop	{r7, pc}

0800f6f0 <$d>:
 800f6f0: 30 06 00 20  	.word	0x20000630
 800f6f4: 00 00 00 20  	.word	0x20000000
 800f6f8: c0 da 01 08  	.word	0x0801dac0
 800f6fc: 00 00 00 20  	.word	0x20000000
 800f700: 00 00 00 20  	.word	0x20000000
 800f704: c0 da 01 08  	.word	0x0801dac0

0800f708 <first>:
; {
 800f708: b580         	push	{r7, lr}
 800f70a: b082         	sub	sp, #0x8
 800f70c: af00         	add	r7, sp, #0x0
; 	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);
 800f70e: 4804         	ldr	r0, [pc, #0x10]         @ 0x800f720 <first+0x18>
 800f710: f00a feb3    	bl	0x801a47a <sys_dlist_peek_head> @ imm = #0xad66
 800f714: 6078         	str	r0, [r7, #0x4]
; 	return (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);
 800f716: 687b         	ldr	r3, [r7, #0x4]
; }
 800f718: 4618         	mov	r0, r3
 800f71a: 3708         	adds	r7, #0x8
 800f71c: 46bd         	mov	sp, r7
 800f71e: bd80         	pop	{r7, pc}

0800f720 <$d>:
 800f720: 60 05 00 20  	.word	0x20000560

0800f724 <next>:
; {
 800f724: b580         	push	{r7, lr}
 800f726: b084         	sub	sp, #0x10
 800f728: af00         	add	r7, sp, #0x0
 800f72a: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);
 800f72c: 687b         	ldr	r3, [r7, #0x4]
 800f72e: 4619         	mov	r1, r3
 800f730: 4804         	ldr	r0, [pc, #0x10]         @ 0x800f744 <next+0x20>
 800f732: f00a fec7    	bl	0x801a4c4 <sys_dlist_peek_next> @ imm = #0xad8e
 800f736: 60f8         	str	r0, [r7, #0xc]
; 	return (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);
 800f738: 68fb         	ldr	r3, [r7, #0xc]
; }
 800f73a: 4618         	mov	r0, r3
 800f73c: 3710         	adds	r7, #0x10
 800f73e: 46bd         	mov	sp, r7
 800f740: bd80         	pop	{r7, pc}
 800f742: bf00         	nop

0800f744 <$d>:
 800f744: 60 05 00 20  	.word	0x20000560

0800f748 <elapsed>:
; {
 800f748: b580         	push	{r7, lr}
 800f74a: af00         	add	r7, sp, #0x0
; 	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 800f74c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800f764 <elapsed+0x1c>
 800f74e: 681b         	ldr	r3, [r3]
 800f750: 2b00         	cmp	r3, #0x0
 800f752: d103         	bne	0x800f75c <elapsed+0x14> @ imm = #0x6
 800f754: f7fa fe9e    	bl	0x800a494 <sys_clock_elapsed> @ imm = #-0x52c4
 800f758: 4603         	mov	r3, r0
 800f75a: e000         	b	0x800f75e <elapsed+0x16> @ imm = #0x0
 800f75c: 2300         	movs	r3, #0x0
; }
 800f75e: 4618         	mov	r0, r3
 800f760: bd80         	pop	{r7, pc}
 800f762: bf00         	nop

0800f764 <$d>:
 800f764: 3c 11 00 20  	.word	0x2000113c

0800f768 <z_add_timeout>:
; {
 800f768: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800f76c: b0a0         	sub	sp, #0x80
 800f76e: af00         	add	r7, sp, #0x0
 800f770: 6378         	str	r0, [r7, #0x34]
 800f772: 6339         	str	r1, [r7, #0x30]
 800f774: e9c7 230a    	strd	r2, r3, [r7, #40]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 800f778: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 800f77c: f04f 32ff    	mov.w	r2, #0xffffffff
 800f780: f04f 33ff    	mov.w	r3, #0xffffffff
 800f784: 4299         	cmp	r1, r3
 800f786: bf08         	it	eq
 800f788: 4290         	cmpeq	r0, r2
 800f78a: d100         	bne	0x800f78e <z_add_timeout+0x26> @ imm = #0x0
 800f78c: e0d8         	b	0x800f940 <z_add_timeout+0x1d8> @ imm = #0x1b0
; 	to->fn = fn;
 800f78e: 6b7a         	ldr	r2, [r7, #0x34]
 800f790: 6b3b         	ldr	r3, [r7, #0x30]
 800f792: 6093         	str	r3, [r2, #0x8]
; 	K_SPINLOCK(&timeout_lock) {
 800f794: 2300         	movs	r3, #0x0
 800f796: 64bb         	str	r3, [r7, #0x48]
 800f798: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x800f948 <z_add_timeout+0x1e0>
 800f79a: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f79c: f3ef 8311    	mrs	r3, basepri
 800f7a0: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 800f7a2: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 800f7a4: 667b         	str	r3, [r7, #0x64]
 800f7a6: 2310         	movs	r3, #0x10
 800f7a8: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f7aa: 6e3b         	ldr	r3, [r7, #0x60]
 800f7ac: f383 8812    	msr	basepri_max, r3
; }
 800f7b0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f7b2: f3bf 8f6f    	isb	sy
; }
 800f7b6: bf00         	nop
; 	return key;
 800f7b8: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 800f7ba: 63fb         	str	r3, [r7, #0x3c]
 800f7bc: 6efb         	ldr	r3, [r7, #0x6c]
 800f7be: 65fb         	str	r3, [r7, #0x5c]
; }
 800f7c0: bf00         	nop
 800f7c2: 6efb         	ldr	r3, [r7, #0x6c]
 800f7c4: 65bb         	str	r3, [r7, #0x58]
; }
 800f7c6: bf00         	nop
; 	return k;
 800f7c8: 6bfb         	ldr	r3, [r7, #0x3c]
 800f7ca: 647b         	str	r3, [r7, #0x44]
; 	K_SPINLOCK(&timeout_lock) {
 800f7cc: e0b4         	b	0x800f938 <z_add_timeout+0x1d0> @ imm = #0x168
; 		    (Z_TICK_ABS(timeout.ticks) >= 0)) {
 800f7ce: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 800f7d2: f06f 0001    	mvn	r0, #0x1
 800f7d6: f04f 31ff    	mov.w	r1, #0xffffffff
 800f7da: 1a80         	subs	r0, r0, r2
 800f7dc: 6238         	str	r0, [r7, #0x20]
 800f7de: eb61 0303    	sbc.w	r3, r1, r3
 800f7e2: 627b         	str	r3, [r7, #0x24]
; 		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 800f7e4: 6a7b         	ldr	r3, [r7, #0x24]
 800f7e6: 2b00         	cmp	r3, #0x0
 800f7e8: db24         	blt	0x800f834 <z_add_timeout+0xcc> @ imm = #0x48
; 			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 800f7ea: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 800f7ee: 4610         	mov	r0, r2
 800f7f0: 4619         	mov	r1, r3
 800f7f2: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800f94c <z_add_timeout+0x1e4>
 800f7f4: e9d3 2300    	ldrd	r2, r3, [r3]
 800f7f8: 1884         	adds	r4, r0, r2
 800f7fa: eb41 0503    	adc.w	r5, r1, r3
 800f7fe: f06f 0201    	mvn	r2, #0x1
 800f802: f04f 33ff    	mov.w	r3, #0xffffffff
 800f806: 1b12         	subs	r2, r2, r4
 800f808: 61ba         	str	r2, [r7, #0x18]
 800f80a: eb63 0305    	sbc.w	r3, r3, r5
 800f80e: 61fb         	str	r3, [r7, #0x1c]
 800f810: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 800f814: e9c7 231c    	strd	r2, r3, [r7, #112]
; 			to->dticks = MAX(1, ticks);
 800f818: e9d7 231c    	ldrd	r2, r3, [r7, #112]
 800f81c: 2a01         	cmp	r2, #0x1
 800f81e: f173 0100    	sbcs	r1, r3, #0x0
 800f822: da03         	bge	0x800f82c <z_add_timeout+0xc4> @ imm = #0x6
 800f824: f04f 0201    	mov.w	r2, #0x1
 800f828: f04f 0300    	mov.w	r3, #0x0
 800f82c: 6b79         	ldr	r1, [r7, #0x34]
 800f82e: e9c1 2304    	strd	r2, r3, [r1, #16]
 800f832: e016         	b	0x800f862 <z_add_timeout+0xfa> @ imm = #0x2c
; 			to->dticks = timeout.ticks + 1 + elapsed();
 800f834: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 800f838: f112 0801    	adds.w	r8, r2, #0x1
 800f83c: f143 0900    	adc	r9, r3, #0x0
 800f840: f7ff ff82    	bl	0x800f748 <elapsed>     @ imm = #-0xfc
 800f844: 4603         	mov	r3, r0
 800f846: 17da         	asrs	r2, r3, #0x1f
 800f848: 469a         	mov	r10, r3
 800f84a: 4693         	mov	r11, r2
 800f84c: eb18 030a    	adds.w	r3, r8, r10
 800f850: 613b         	str	r3, [r7, #0x10]
 800f852: eb49 030b    	adc.w	r3, r9, r11
 800f856: 617b         	str	r3, [r7, #0x14]
 800f858: 6b7b         	ldr	r3, [r7, #0x34]
 800f85a: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 800f85e: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 800f862: f7ff ff51    	bl	0x800f708 <first>       @ imm = #-0x15e
 800f866: 67f8         	str	r0, [r7, #0x7c]
 800f868: e037         	b	0x800f8da <z_add_timeout+0x172> @ imm = #0x6e
; 			if (t->dticks > to->dticks) {
 800f86a: 6ffb         	ldr	r3, [r7, #0x7c]
 800f86c: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 800f870: 6b7b         	ldr	r3, [r7, #0x34]
 800f872: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800f876: 4282         	cmp	r2, r0
 800f878: 418b         	sbcs	r3, r1
 800f87a: da18         	bge	0x800f8ae <z_add_timeout+0x146> @ imm = #0x30
; 				t->dticks -= to->dticks;
 800f87c: 6ffb         	ldr	r3, [r7, #0x7c]
 800f87e: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 800f882: 6b7b         	ldr	r3, [r7, #0x34]
 800f884: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800f888: ebb0 0c02    	subs.w	r12, r0, r2
 800f88c: f8c7 c008    	str.w	r12, [r7, #0x8]
 800f890: eb61 0303    	sbc.w	r3, r1, r3
 800f894: 60fb         	str	r3, [r7, #0xc]
 800f896: 6ffb         	ldr	r3, [r7, #0x7c]
 800f898: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 800f89c: e9c3 1204    	strd	r1, r2, [r3, #16]
; 				sys_dlist_insert(&t->node, &to->node);
 800f8a0: 6ffa         	ldr	r2, [r7, #0x7c]
 800f8a2: 6b7b         	ldr	r3, [r7, #0x34]
 800f8a4: 4619         	mov	r1, r3
 800f8a6: 4610         	mov	r0, r2
 800f8a8: f00a fe38    	bl	0x801a51c <sys_dlist_insert> @ imm = #0xac70
; 				break;
 800f8ac: e018         	b	0x800f8e0 <z_add_timeout+0x178> @ imm = #0x30
; 			to->dticks -= t->dticks;
 800f8ae: 6b7b         	ldr	r3, [r7, #0x34]
 800f8b0: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 800f8b4: 6ffb         	ldr	r3, [r7, #0x7c]
 800f8b6: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800f8ba: ebb0 0c02    	subs.w	r12, r0, r2
 800f8be: f8c7 c000    	str.w	r12, [r7]
 800f8c2: eb61 0303    	sbc.w	r3, r1, r3
 800f8c6: 607b         	str	r3, [r7, #0x4]
 800f8c8: 6b7b         	ldr	r3, [r7, #0x34]
 800f8ca: e9d7 1200    	ldrd	r1, r2, [r7]
 800f8ce: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 800f8d2: 6ff8         	ldr	r0, [r7, #0x7c]
 800f8d4: f7ff ff26    	bl	0x800f724 <next>        @ imm = #-0x1b4
 800f8d8: 67f8         	str	r0, [r7, #0x7c]
 800f8da: 6ffb         	ldr	r3, [r7, #0x7c]
 800f8dc: 2b00         	cmp	r3, #0x0
 800f8de: d1c4         	bne	0x800f86a <z_add_timeout+0x102> @ imm = #-0x78
; 		if (t == NULL) {
 800f8e0: 6ffb         	ldr	r3, [r7, #0x7c]
 800f8e2: 2b00         	cmp	r3, #0x0
 800f8e4: d104         	bne	0x800f8f0 <z_add_timeout+0x188> @ imm = #0x8
; 			sys_dlist_append(&timeout_list, &to->node);
 800f8e6: 6b7b         	ldr	r3, [r7, #0x34]
 800f8e8: 4619         	mov	r1, r3
 800f8ea: 4819         	ldr	r0, [pc, #0x64]         @ 0x800f950 <z_add_timeout+0x1e8>
 800f8ec: f00a fdfd    	bl	0x801a4ea <sys_dlist_append> @ imm = #0xabfa
; 		if (to == first() && announce_remaining == 0) {
 800f8f0: f7ff ff0a    	bl	0x800f708 <first>       @ imm = #-0x1ec
 800f8f4: 4602         	mov	r2, r0
 800f8f6: 6b7b         	ldr	r3, [r7, #0x34]
 800f8f8: 4293         	cmp	r3, r2
 800f8fa: d10a         	bne	0x800f912 <z_add_timeout+0x1aa> @ imm = #0x14
 800f8fc: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800f954 <z_add_timeout+0x1ec>
 800f8fe: 681b         	ldr	r3, [r3]
 800f900: 2b00         	cmp	r3, #0x0
 800f902: d106         	bne	0x800f912 <z_add_timeout+0x1aa> @ imm = #0xc
; 			sys_clock_set_timeout(next_timeout(), false);
 800f904: f00a fe5a    	bl	0x801a5bc <next_timeout> @ imm = #0xacb4
 800f908: 4603         	mov	r3, r0
 800f90a: 2100         	movs	r1, #0x0
 800f90c: 4618         	mov	r0, r3
 800f90e: f7fa fcbd    	bl	0x800a28c <sys_clock_set_timeout> @ imm = #-0x5686
 800f912: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800f948 <z_add_timeout+0x1e0>
 800f914: 657b         	str	r3, [r7, #0x54]
 800f916: 6c7b         	ldr	r3, [r7, #0x44]
 800f918: 643b         	str	r3, [r7, #0x40]
; 	arch_irq_unlock(key.key);
 800f91a: 6c3b         	ldr	r3, [r7, #0x40]
 800f91c: 653b         	str	r3, [r7, #0x50]
 800f91e: 6d3b         	ldr	r3, [r7, #0x50]
 800f920: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f922: 6cfb         	ldr	r3, [r7, #0x4c]
 800f924: f383 8811    	msr	basepri, r3
; }
 800f928: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f92a: f3bf 8f6f    	isb	sy
; }
 800f92e: bf00         	nop
; }
 800f930: bf00         	nop
; }
 800f932: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 800f934: 2301         	movs	r3, #0x1
 800f936: 64bb         	str	r3, [r7, #0x48]
 800f938: 6cbb         	ldr	r3, [r7, #0x48]
 800f93a: 2b00         	cmp	r3, #0x0
 800f93c: f43f af47    	beq.w	0x800f7ce <z_add_timeout+0x66> @ imm = #-0x172
; }
 800f940: 3780         	adds	r7, #0x80
 800f942: 46bd         	mov	sp, r7
 800f944: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800f948 <$d>:
 800f948: 3c 11 00 20  	.word	0x2000113c
 800f94c: f8 09 00 20  	.word	0x200009f8
 800f950: 60 05 00 20  	.word	0x20000560
 800f954: 3c 11 00 20  	.word	0x2000113c

0800f958 <z_abort_timeout>:
; {
 800f958: b580         	push	{r7, lr}
 800f95a: b090         	sub	sp, #0x40
 800f95c: af00         	add	r7, sp, #0x0
 800f95e: 6078         	str	r0, [r7, #0x4]
; 	int ret = -EINVAL;
 800f960: f06f 0315    	mvn	r3, #0x15
 800f964: 63fb         	str	r3, [r7, #0x3c]
; 	K_SPINLOCK(&timeout_lock) {
 800f966: 2300         	movs	r3, #0x0
 800f968: 617b         	str	r3, [r7, #0x14]
 800f96a: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800f9f0 <z_abort_timeout+0x98>
 800f96c: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f96e: f3ef 8311    	mrs	r3, basepri
 800f972: 637b         	str	r3, [r7, #0x34]
;   return(result);
 800f974: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 800f976: 633b         	str	r3, [r7, #0x30]
 800f978: 2310         	movs	r3, #0x10
 800f97a: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f97c: 6afb         	ldr	r3, [r7, #0x2c]
 800f97e: f383 8812    	msr	basepri_max, r3
; }
 800f982: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f984: f3bf 8f6f    	isb	sy
; }
 800f988: bf00         	nop
; 	return key;
 800f98a: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 800f98c: 60bb         	str	r3, [r7, #0x8]
 800f98e: 6bbb         	ldr	r3, [r7, #0x38]
 800f990: 62bb         	str	r3, [r7, #0x28]
; }
 800f992: bf00         	nop
 800f994: 6bbb         	ldr	r3, [r7, #0x38]
 800f996: 627b         	str	r3, [r7, #0x24]
; }
 800f998: bf00         	nop
; 	return k;
 800f99a: 68bb         	ldr	r3, [r7, #0x8]
 800f99c: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&timeout_lock) {
 800f99e: e01e         	b	0x800f9de <z_abort_timeout+0x86> @ imm = #0x3c
; 		if (sys_dnode_is_linked(&to->node)) {
 800f9a0: 687b         	ldr	r3, [r7, #0x4]
 800f9a2: 4618         	mov	r0, r3
 800f9a4: f00a fd48    	bl	0x801a438 <sys_dnode_is_linked> @ imm = #0xaa90
 800f9a8: 4603         	mov	r3, r0
 800f9aa: 2b00         	cmp	r3, #0x0
 800f9ac: d004         	beq	0x800f9b8 <z_abort_timeout+0x60> @ imm = #0x8
; 			remove_timeout(to);
 800f9ae: 6878         	ldr	r0, [r7, #0x4]
 800f9b0: f00a fde4    	bl	0x801a57c <remove_timeout> @ imm = #0xabc8
; 			ret = 0;
 800f9b4: 2300         	movs	r3, #0x0
 800f9b6: 63fb         	str	r3, [r7, #0x3c]
 800f9b8: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800f9f0 <z_abort_timeout+0x98>
 800f9ba: 623b         	str	r3, [r7, #0x20]
 800f9bc: 693b         	ldr	r3, [r7, #0x10]
 800f9be: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800f9c0: 68fb         	ldr	r3, [r7, #0xc]
 800f9c2: 61fb         	str	r3, [r7, #0x1c]
 800f9c4: 69fb         	ldr	r3, [r7, #0x1c]
 800f9c6: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f9c8: 69bb         	ldr	r3, [r7, #0x18]
 800f9ca: f383 8811    	msr	basepri, r3
; }
 800f9ce: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f9d0: f3bf 8f6f    	isb	sy
; }
 800f9d4: bf00         	nop
; }
 800f9d6: bf00         	nop
; }
 800f9d8: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 800f9da: 2301         	movs	r3, #0x1
 800f9dc: 617b         	str	r3, [r7, #0x14]
 800f9de: 697b         	ldr	r3, [r7, #0x14]
 800f9e0: 2b00         	cmp	r3, #0x0
 800f9e2: d0dd         	beq	0x800f9a0 <z_abort_timeout+0x48> @ imm = #-0x46
; 	return ret;
 800f9e4: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 800f9e6: 4618         	mov	r0, r3
 800f9e8: 3740         	adds	r7, #0x40
 800f9ea: 46bd         	mov	sp, r7
 800f9ec: bd80         	pop	{r7, pc}
 800f9ee: bf00         	nop

0800f9f0 <$d>:
 800f9f0: 3c 11 00 20  	.word	0x2000113c

0800f9f4 <sys_clock_announce>:
; {
 800f9f4: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800f9f8: b0a4         	sub	sp, #0x90
 800f9fa: af00         	add	r7, sp, #0x0
 800f9fc: 6278         	str	r0, [r7, #0x24]
 800f9fe: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800fbd0 <sys_clock_announce+0x1dc>
 800fa00: f8c7 3084    	str.w	r3, [r7, #0x84]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fa04: f3ef 8311    	mrs	r3, basepri
 800fa08: f8c7 3080    	str.w	r3, [r7, #0x80]
;   return(result);
 800fa0c: f8d7 3080    	ldr.w	r3, [r7, #0x80]
; 	key = __get_BASEPRI();
 800fa10: 67fb         	str	r3, [r7, #0x7c]
 800fa12: 2310         	movs	r3, #0x10
 800fa14: 67bb         	str	r3, [r7, #0x78]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800fa16: 6fbb         	ldr	r3, [r7, #0x78]
 800fa18: f383 8812    	msr	basepri_max, r3
; }
 800fa1c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fa1e: f3bf 8f6f    	isb	sy
; }
 800fa22: bf00         	nop
; 	return key;
 800fa24: 6ffb         	ldr	r3, [r7, #0x7c]
; 	k.key = arch_irq_lock();
 800fa26: 637b         	str	r3, [r7, #0x34]
 800fa28: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800fa2c: 677b         	str	r3, [r7, #0x74]
; }
 800fa2e: bf00         	nop
 800fa30: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800fa34: 673b         	str	r3, [r7, #0x70]
; }
 800fa36: bf00         	nop
; 	return k;
 800fa38: 6b7b         	ldr	r3, [r7, #0x34]
 800fa3a: 63fb         	str	r3, [r7, #0x3c]
; 	announce_remaining = ticks;
 800fa3c: 4a65         	ldr	r2, [pc, #0x194]        @ 0x800fbd4 <sys_clock_announce+0x1e0>
 800fa3e: 6a7b         	ldr	r3, [r7, #0x24]
 800fa40: 6013         	str	r3, [r2]
; 	for (t = first();
 800fa42: f7ff fe61    	bl	0x800f708 <first>       @ imm = #-0x33e
 800fa46: f8c7 008c    	str.w	r0, [r7, #0x8c]
 800fa4a: e061         	b	0x800fb10 <sys_clock_announce+0x11c> @ imm = #0xc2
; 		int dt = t->dticks;
 800fa4c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800fa50: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800fa54: 4613         	mov	r3, r2
 800fa56: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		curr_tick += dt;
 800fa5a: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800fa5e: 17da         	asrs	r2, r3, #0x1f
 800fa60: 469a         	mov	r10, r3
 800fa62: 4693         	mov	r11, r2
 800fa64: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800fbd8 <sys_clock_announce+0x1e4>
 800fa66: e9d3 2300    	ldrd	r2, r3, [r3]
 800fa6a: eb1a 0102    	adds.w	r1, r10, r2
 800fa6e: 61b9         	str	r1, [r7, #0x18]
 800fa70: eb4b 0303    	adc.w	r3, r11, r3
 800fa74: 61fb         	str	r3, [r7, #0x1c]
 800fa76: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800fbd8 <sys_clock_announce+0x1e4>
 800fa78: e9d7 1206    	ldrd	r1, r2, [r7, #24]
 800fa7c: e9c3 1200    	strd	r1, r2, [r3]
; 		t->dticks = 0;
 800fa80: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 800fa84: f04f 0200    	mov.w	r2, #0x0
 800fa88: f04f 0300    	mov.w	r3, #0x0
 800fa8c: e9c1 2304    	strd	r2, r3, [r1, #16]
; 		remove_timeout(t);
 800fa90: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 800fa94: f00a fd72    	bl	0x801a57c <remove_timeout> @ imm = #0xaae4
 800fa98: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800fbd0 <sys_clock_announce+0x1dc>
 800fa9a: 657b         	str	r3, [r7, #0x54]
 800fa9c: 6bfb         	ldr	r3, [r7, #0x3c]
 800fa9e: 633b         	str	r3, [r7, #0x30]
; 	arch_irq_unlock(key.key);
 800faa0: 6b3b         	ldr	r3, [r7, #0x30]
 800faa2: 653b         	str	r3, [r7, #0x50]
 800faa4: 6d3b         	ldr	r3, [r7, #0x50]
 800faa6: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800faa8: 6cfb         	ldr	r3, [r7, #0x4c]
 800faaa: f383 8811    	msr	basepri, r3
; }
 800faae: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fab0: f3bf 8f6f    	isb	sy
; }
 800fab4: bf00         	nop
; }
 800fab6: bf00         	nop
; }
 800fab8: bf00         	nop
; 		t->fn(t);
 800faba: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800fabe: 689b         	ldr	r3, [r3, #0x8]
 800fac0: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 800fac4: 4798         	blx	r3
 800fac6: 4b42         	ldr	r3, [pc, #0x108]        @ 0x800fbd0 <sys_clock_announce+0x1dc>
 800fac8: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800faca: f3ef 8311    	mrs	r3, basepri
 800face: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 800fad0: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 800fad2: 667b         	str	r3, [r7, #0x64]
 800fad4: 2310         	movs	r3, #0x10
 800fad6: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800fad8: 6e3b         	ldr	r3, [r7, #0x60]
 800fada: f383 8812    	msr	basepri_max, r3
; }
 800fade: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fae0: f3bf 8f6f    	isb	sy
; }
 800fae4: bf00         	nop
; 	return key;
 800fae6: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 800fae8: 62fb         	str	r3, [r7, #0x2c]
 800faea: 6efb         	ldr	r3, [r7, #0x6c]
 800faec: 65fb         	str	r3, [r7, #0x5c]
; }
 800faee: bf00         	nop
 800faf0: 6efb         	ldr	r3, [r7, #0x6c]
 800faf2: 65bb         	str	r3, [r7, #0x58]
; }
 800faf4: bf00         	nop
; 	return k;
 800faf6: 6afb         	ldr	r3, [r7, #0x2c]
 800faf8: 63fb         	str	r3, [r7, #0x3c]
; 		announce_remaining -= dt;
 800fafa: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800fbd4 <sys_clock_announce+0x1e0>
 800fafc: 681a         	ldr	r2, [r3]
 800fafe: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800fb02: 1ad2         	subs	r2, r2, r3
 800fb04: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800fbd4 <sys_clock_announce+0x1e0>
 800fb06: 601a         	str	r2, [r3]
; 	     t = first()) {
 800fb08: f7ff fdfe    	bl	0x800f708 <first>       @ imm = #-0x404
 800fb0c: f8c7 008c    	str.w	r0, [r7, #0x8c]
; 	     (t != NULL) && (t->dticks <= announce_remaining);
 800fb10: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800fb14: 2b00         	cmp	r3, #0x0
 800fb16: d00e         	beq	0x800fb36 <sys_clock_announce+0x142> @ imm = #0x1c
 800fb18: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800fb1c: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 800fb20: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800fbd4 <sys_clock_announce+0x1e0>
 800fb22: 681b         	ldr	r3, [r3]
 800fb24: 17da         	asrs	r2, r3, #0x1f
 800fb26: 613b         	str	r3, [r7, #0x10]
 800fb28: 617a         	str	r2, [r7, #0x14]
 800fb2a: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800fb2e: 4694         	mov	r12, r2
 800fb30: 4584         	cmp	r12, r0
 800fb32: 418b         	sbcs	r3, r1
 800fb34: da8a         	bge	0x800fa4c <sys_clock_announce+0x58> @ imm = #-0xec
; 	if (t != NULL) {
 800fb36: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800fb3a: 2b00         	cmp	r3, #0x0
 800fb3c: d014         	beq	0x800fb68 <sys_clock_announce+0x174> @ imm = #0x28
; 		t->dticks -= announce_remaining;
 800fb3e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800fb42: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800fb46: 4923         	ldr	r1, [pc, #0x8c]         @ 0x800fbd4 <sys_clock_announce+0x1e0>
 800fb48: 6809         	ldr	r1, [r1]
 800fb4a: 17c8         	asrs	r0, r1, #0x1f
 800fb4c: 4688         	mov	r8, r1
 800fb4e: 4681         	mov	r9, r0
 800fb50: ebb2 0108    	subs.w	r1, r2, r8
 800fb54: 60b9         	str	r1, [r7, #0x8]
 800fb56: eb63 0309    	sbc.w	r3, r3, r9
 800fb5a: 60fb         	str	r3, [r7, #0xc]
 800fb5c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800fb60: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 800fb64: e9c3 1204    	strd	r1, r2, [r3, #16]
; 	curr_tick += announce_remaining;
 800fb68: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800fbd4 <sys_clock_announce+0x1e0>
 800fb6a: 681b         	ldr	r3, [r3]
 800fb6c: 17da         	asrs	r2, r3, #0x1f
 800fb6e: 461c         	mov	r4, r3
 800fb70: 4615         	mov	r5, r2
 800fb72: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800fbd8 <sys_clock_announce+0x1e4>
 800fb74: e9d3 2300    	ldrd	r2, r3, [r3]
 800fb78: 18a1         	adds	r1, r4, r2
 800fb7a: 6039         	str	r1, [r7]
 800fb7c: eb45 0303    	adc.w	r3, r5, r3
 800fb80: 607b         	str	r3, [r7, #0x4]
 800fb82: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800fbd8 <sys_clock_announce+0x1e4>
 800fb84: e9d7 1200    	ldrd	r1, r2, [r7]
 800fb88: e9c3 1200    	strd	r1, r2, [r3]
; 	announce_remaining = 0;
 800fb8c: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800fbd4 <sys_clock_announce+0x1e0>
 800fb8e: 2200         	movs	r2, #0x0
 800fb90: 601a         	str	r2, [r3]
; 	sys_clock_set_timeout(next_timeout(), false);
 800fb92: f00a fd13    	bl	0x801a5bc <next_timeout> @ imm = #0xaa26
 800fb96: 4603         	mov	r3, r0
 800fb98: 2100         	movs	r1, #0x0
 800fb9a: 4618         	mov	r0, r3
 800fb9c: f7fa fb76    	bl	0x800a28c <sys_clock_set_timeout> @ imm = #-0x5914
 800fba0: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800fbd0 <sys_clock_announce+0x1dc>
 800fba2: 64bb         	str	r3, [r7, #0x48]
 800fba4: 6bfb         	ldr	r3, [r7, #0x3c]
 800fba6: 63bb         	str	r3, [r7, #0x38]
; 	arch_irq_unlock(key.key);
 800fba8: 6bbb         	ldr	r3, [r7, #0x38]
 800fbaa: 647b         	str	r3, [r7, #0x44]
 800fbac: 6c7b         	ldr	r3, [r7, #0x44]
 800fbae: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800fbb0: 6c3b         	ldr	r3, [r7, #0x40]
 800fbb2: f383 8811    	msr	basepri, r3
; }
 800fbb6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fbb8: f3bf 8f6f    	isb	sy
; }
 800fbbc: bf00         	nop
; }
 800fbbe: bf00         	nop
; }
 800fbc0: bf00         	nop
; 	z_time_slice();
 800fbc2: f7ff fcad    	bl	0x800f520 <z_time_slice> @ imm = #-0x6a6
; }
 800fbc6: 3790         	adds	r7, #0x90
 800fbc8: 46bd         	mov	sp, r7
 800fbca: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 800fbce: bf00         	nop

0800fbd0 <$d>:
 800fbd0: 3c 11 00 20  	.word	0x2000113c
 800fbd4: 3c 11 00 20  	.word	0x2000113c
 800fbd8: f8 09 00 20  	.word	0x200009f8

0800fbdc <sys_clock_tick_get>:
; {
 800fbdc: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800fbe0: b090         	sub	sp, #0x40
 800fbe2: af00         	add	r7, sp, #0x0
; 	uint64_t t = 0U;
 800fbe4: f04f 0200    	mov.w	r2, #0x0
 800fbe8: f04f 0300    	mov.w	r3, #0x0
 800fbec: e9c7 230e    	strd	r2, r3, [r7, #56]
; 	K_SPINLOCK(&timeout_lock) {
 800fbf0: 2300         	movs	r3, #0x0
 800fbf2: 613b         	str	r3, [r7, #0x10]
 800fbf4: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800fc84 <sys_clock_tick_get+0xa8>
 800fbf6: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fbf8: f3ef 8311    	mrs	r3, basepri
 800fbfc: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800fbfe: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800fc00: 62fb         	str	r3, [r7, #0x2c]
 800fc02: 2310         	movs	r3, #0x10
 800fc04: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800fc06: 6abb         	ldr	r3, [r7, #0x28]
 800fc08: f383 8812    	msr	basepri_max, r3
; }
 800fc0c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fc0e: f3bf 8f6f    	isb	sy
; }
 800fc12: bf00         	nop
; 	return key;
 800fc14: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800fc16: 607b         	str	r3, [r7, #0x4]
 800fc18: 6b7b         	ldr	r3, [r7, #0x34]
 800fc1a: 627b         	str	r3, [r7, #0x24]
; }
 800fc1c: bf00         	nop
 800fc1e: 6b7b         	ldr	r3, [r7, #0x34]
 800fc20: 623b         	str	r3, [r7, #0x20]
; }
 800fc22: bf00         	nop
; 	return k;
 800fc24: 687b         	ldr	r3, [r7, #0x4]
 800fc26: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&timeout_lock) {
 800fc28: e021         	b	0x800fc6e <sys_clock_tick_get+0x92> @ imm = #0x42
; 		t = curr_tick + elapsed();
 800fc2a: f7ff fd8d    	bl	0x800f748 <elapsed>     @ imm = #-0x4e6
 800fc2e: 4603         	mov	r3, r0
 800fc30: 17da         	asrs	r2, r3, #0x1f
 800fc32: 461c         	mov	r4, r3
 800fc34: 4615         	mov	r5, r2
 800fc36: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800fc88 <sys_clock_tick_get+0xac>
 800fc38: e9d3 2300    	ldrd	r2, r3, [r3]
 800fc3c: eb14 0802    	adds.w	r8, r4, r2
 800fc40: eb45 0903    	adc.w	r9, r5, r3
 800fc44: e9c7 890e    	strd	r8, r9, [r7, #56]
 800fc48: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800fc84 <sys_clock_tick_get+0xa8>
 800fc4a: 61fb         	str	r3, [r7, #0x1c]
 800fc4c: 68fb         	ldr	r3, [r7, #0xc]
 800fc4e: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800fc50: 68bb         	ldr	r3, [r7, #0x8]
 800fc52: 61bb         	str	r3, [r7, #0x18]
 800fc54: 69bb         	ldr	r3, [r7, #0x18]
 800fc56: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800fc58: 697b         	ldr	r3, [r7, #0x14]
 800fc5a: f383 8811    	msr	basepri, r3
; }
 800fc5e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fc60: f3bf 8f6f    	isb	sy
; }
 800fc64: bf00         	nop
; }
 800fc66: bf00         	nop
; }
 800fc68: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 800fc6a: 2301         	movs	r3, #0x1
 800fc6c: 613b         	str	r3, [r7, #0x10]
 800fc6e: 693b         	ldr	r3, [r7, #0x10]
 800fc70: 2b00         	cmp	r3, #0x0
 800fc72: d0da         	beq	0x800fc2a <sys_clock_tick_get+0x4e> @ imm = #-0x4c
; 	return t;
 800fc74: e9d7 230e    	ldrd	r2, r3, [r7, #56]
; }
 800fc78: 4610         	mov	r0, r2
 800fc7a: 4619         	mov	r1, r3
 800fc7c: 3740         	adds	r7, #0x40
 800fc7e: 46bd         	mov	sp, r7
 800fc80: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

0800fc84 <$d>:
 800fc84: 3c 11 00 20  	.word	0x2000113c
 800fc88: f8 09 00 20  	.word	0x200009f8

0800fc8c <z_timer_expiration_handler>:
; {
 800fc8c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800fc90: b0ae         	sub	sp, #0xb8
 800fc92: af00         	add	r7, sp, #0x0
 800fc94: 61f8         	str	r0, [r7, #0x1c]
; 	struct k_timer *timer = CONTAINER_OF(t, struct k_timer, timeout);
 800fc96: 69fb         	ldr	r3, [r7, #0x1c]
 800fc98: f8c7 30b4    	str.w	r3, [r7, #0xb4]
 800fc9c: 4b9e         	ldr	r3, [pc, #0x278]        @ 0x800ff18 <z_timer_expiration_handler+0x28c>
 800fc9e: f8c7 30ac    	str.w	r3, [r7, #0xac]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fca2: f3ef 8311    	mrs	r3, basepri
 800fca6: f8c7 30a8    	str.w	r3, [r7, #0xa8]
;   return(result);
 800fcaa: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
; 	key = __get_BASEPRI();
 800fcae: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 800fcb2: 2310         	movs	r3, #0x10
 800fcb4: f8c7 30a0    	str.w	r3, [r7, #0xa0]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800fcb8: f8d7 30a0    	ldr.w	r3, [r7, #0xa0]
 800fcbc: f383 8812    	msr	basepri_max, r3
; }
 800fcc0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fcc2: f3bf 8f6f    	isb	sy
; }
 800fcc6: bf00         	nop
; 	return key;
 800fcc8: f8d7 30a4    	ldr.w	r3, [r7, #0xa4]
; 	k.key = arch_irq_lock();
 800fccc: 62fb         	str	r3, [r7, #0x2c]
 800fcce: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 800fcd2: f8c7 309c    	str.w	r3, [r7, #0x9c]
; }
 800fcd6: bf00         	nop
 800fcd8: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 800fcdc: f8c7 3098    	str.w	r3, [r7, #0x98]
; }
 800fce0: bf00         	nop
; 	return k;
 800fce2: 6afb         	ldr	r3, [r7, #0x2c]
 800fce4: 647b         	str	r3, [r7, #0x44]
; 	if (sys_dnode_is_linked(&t->node)) {
 800fce6: 69fb         	ldr	r3, [r7, #0x1c]
 800fce8: 4618         	mov	r0, r3
 800fcea: f00a fcb7    	bl	0x801a65c <sys_dnode_is_linked> @ imm = #0xa96e
 800fcee: 4603         	mov	r3, r0
 800fcf0: 2b00         	cmp	r3, #0x0
 800fcf2: d016         	beq	0x800fd22 <z_timer_expiration_handler+0x96> @ imm = #0x2c
 800fcf4: 4b88         	ldr	r3, [pc, #0x220]        @ 0x800ff18 <z_timer_expiration_handler+0x28c>
 800fcf6: f8c7 3094    	str.w	r3, [r7, #0x94]
 800fcfa: 6c7b         	ldr	r3, [r7, #0x44]
 800fcfc: 633b         	str	r3, [r7, #0x30]
; 	arch_irq_unlock(key.key);
 800fcfe: 6b3b         	ldr	r3, [r7, #0x30]
 800fd00: f8c7 3090    	str.w	r3, [r7, #0x90]
 800fd04: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 800fd08: f8c7 308c    	str.w	r3, [r7, #0x8c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800fd0c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800fd10: f383 8811    	msr	basepri, r3
; }
 800fd14: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fd16: f3bf 8f6f    	isb	sy
; }
 800fd1a: bf00         	nop
; }
 800fd1c: bf00         	nop
; }
 800fd1e: bf00         	nop
; 		return;
 800fd20: e0f5         	b	0x800ff0e <z_timer_expiration_handler+0x282> @ imm = #0x1ea
; 	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
 800fd22: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 800fd26: e9d3 010a    	ldrd	r0, r1, [r3, #40]
 800fd2a: f04f 0200    	mov.w	r2, #0x0
 800fd2e: f04f 0300    	mov.w	r3, #0x0
 800fd32: 4299         	cmp	r1, r3
 800fd34: bf08         	it	eq
 800fd36: 4290         	cmpeq	r0, r2
 800fd38: d064         	beq	0x800fe04 <z_timer_expiration_handler+0x178> @ imm = #0xc8
; 	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
 800fd3a: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 800fd3e: e9d3 010a    	ldrd	r0, r1, [r3, #40]
 800fd42: f04f 32ff    	mov.w	r2, #0xffffffff
 800fd46: f04f 33ff    	mov.w	r3, #0xffffffff
; 	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
 800fd4a: 4299         	cmp	r1, r3
 800fd4c: bf08         	it	eq
 800fd4e: 4290         	cmpeq	r0, r2
 800fd50: d058         	beq	0x800fe04 <z_timer_expiration_handler+0x178> @ imm = #0xb0
; 		k_timeout_t next = timer->period;
 800fd52: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 800fd56: e9d3 230a    	ldrd	r2, r3, [r3, #40]
 800fd5a: e9c7 2308    	strd	r2, r3, [r7, #32]
; 		next.ticks = MAX(next.ticks - 1, 0);
 800fd5e: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 800fd62: 2a01         	cmp	r2, #0x1
 800fd64: f173 0100    	sbcs	r1, r3, #0x0
 800fd68: da03         	bge	0x800fd72 <z_timer_expiration_handler+0xe6> @ imm = #0x6
 800fd6a: f04f 0201    	mov.w	r2, #0x1
 800fd6e: f04f 0300    	mov.w	r3, #0x0
 800fd72: 1e51         	subs	r1, r2, #0x1
 800fd74: 60b9         	str	r1, [r7, #0x8]
 800fd76: f143 33ff    	adc	r3, r3, #0xffffffff
 800fd7a: 60fb         	str	r3, [r7, #0xc]
 800fd7c: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800fd80: e9c7 2308    	strd	r2, r3, [r7, #32]
; 		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
 800fd84: f00a fc9d    	bl	0x801a6c2 <k_uptime_ticks> @ imm = #0xa93a
 800fd88: 4602         	mov	r2, r0
 800fd8a: 460b         	mov	r3, r1
 800fd8c: 1c51         	adds	r1, r2, #0x1
 800fd8e: 6039         	str	r1, [r7]
 800fd90: f143 0300    	adc	r3, r3, #0x0
 800fd94: 607b         	str	r3, [r7, #0x4]
 800fd96: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 800fd9a: e9d7 0100    	ldrd	r0, r1, [r7]
 800fd9e: 4684         	mov	r12, r0
 800fda0: eb1c 0a02    	adds.w	r10, r12, r2
 800fda4: eb41 0b03    	adc.w	r11, r1, r3
 800fda8: f1ba 0f01    	cmp.w	r10, #0x1
 800fdac: f17b 0300    	sbcs	r3, r11, #0x0
 800fdb0: db17         	blt	0x800fde2 <z_timer_expiration_handler+0x156> @ imm = #0x2e
 800fdb2: f00a fc86    	bl	0x801a6c2 <k_uptime_ticks> @ imm = #0xa90c
 800fdb6: 4602         	mov	r2, r0
 800fdb8: 460b         	mov	r3, r1
 800fdba: f112 0801    	adds.w	r8, r2, #0x1
 800fdbe: f143 0900    	adc	r9, r3, #0x0
 800fdc2: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 800fdc6: eb18 0402    	adds.w	r4, r8, r2
 800fdca: eb49 0503    	adc.w	r5, r9, r3
 800fdce: f06f 0201    	mvn	r2, #0x1
 800fdd2: f04f 33ff    	mov.w	r3, #0xffffffff
 800fdd6: 1b12         	subs	r2, r2, r4
 800fdd8: 613a         	str	r2, [r7, #0x10]
 800fdda: eb63 0305    	sbc.w	r3, r3, r5
 800fdde: 617b         	str	r3, [r7, #0x14]
 800fde0: e005         	b	0x800fdee <z_timer_expiration_handler+0x162> @ imm = #0xa
 800fde2: f06f 0301    	mvn	r3, #0x1
 800fde6: f04f 34ff    	mov.w	r4, #0xffffffff
 800fdea: e9c7 3404    	strd	r3, r4, [r7, #16]
 800fdee: e9d7 3404    	ldrd	r3, r4, [r7, #16]
 800fdf2: e9c7 3408    	strd	r3, r4, [r7, #32]
; 		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 800fdf6: f8d7 00b4    	ldr.w	r0, [r7, #0xb4]
 800fdfa: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 800fdfe: 4947         	ldr	r1, [pc, #0x11c]        @ 0x800ff1c <z_timer_expiration_handler+0x290>
 800fe00: f7ff fcb2    	bl	0x800f768 <z_add_timeout> @ imm = #-0x69c
; 	timer->status += 1U;
 800fe04: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 800fe08: 6b1b         	ldr	r3, [r3, #0x30]
 800fe0a: 1c5a         	adds	r2, r3, #0x1
 800fe0c: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 800fe10: 631a         	str	r2, [r3, #0x30]
; 	if (timer->expiry_fn != NULL) {
 800fe12: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 800fe16: 6a1b         	ldr	r3, [r3, #0x20]
 800fe18: 2b00         	cmp	r3, #0x0
 800fe1a: d037         	beq	0x800fe8c <z_timer_expiration_handler+0x200> @ imm = #0x6e
 800fe1c: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800ff18 <z_timer_expiration_handler+0x28c>
 800fe1e: 673b         	str	r3, [r7, #0x70]
 800fe20: 6c7b         	ldr	r3, [r7, #0x44]
 800fe22: 63bb         	str	r3, [r7, #0x38]
; 	arch_irq_unlock(key.key);
 800fe24: 6bbb         	ldr	r3, [r7, #0x38]
 800fe26: 66fb         	str	r3, [r7, #0x6c]
 800fe28: 6efb         	ldr	r3, [r7, #0x6c]
 800fe2a: 66bb         	str	r3, [r7, #0x68]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800fe2c: 6ebb         	ldr	r3, [r7, #0x68]
 800fe2e: f383 8811    	msr	basepri, r3
; }
 800fe32: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fe34: f3bf 8f6f    	isb	sy
; }
 800fe38: bf00         	nop
; }
 800fe3a: bf00         	nop
; }
 800fe3c: bf00         	nop
; 		timer->expiry_fn(timer);
 800fe3e: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 800fe42: 6a1b         	ldr	r3, [r3, #0x20]
 800fe44: f8d7 00b4    	ldr.w	r0, [r7, #0xb4]
 800fe48: 4798         	blx	r3
 800fe4a: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800ff18 <z_timer_expiration_handler+0x28c>
 800fe4c: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fe50: f3ef 8311    	mrs	r3, basepri
 800fe54: f8c7 3084    	str.w	r3, [r7, #0x84]
;   return(result);
 800fe58: f8d7 3084    	ldr.w	r3, [r7, #0x84]
; 	key = __get_BASEPRI();
 800fe5c: f8c7 3080    	str.w	r3, [r7, #0x80]
 800fe60: 2310         	movs	r3, #0x10
 800fe62: 67fb         	str	r3, [r7, #0x7c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800fe64: 6ffb         	ldr	r3, [r7, #0x7c]
 800fe66: f383 8812    	msr	basepri_max, r3
; }
 800fe6a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fe6c: f3bf 8f6f    	isb	sy
; }
 800fe70: bf00         	nop
; 	return key;
 800fe72: f8d7 3080    	ldr.w	r3, [r7, #0x80]
; 	k.key = arch_irq_lock();
 800fe76: 637b         	str	r3, [r7, #0x34]
 800fe78: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800fe7c: 67bb         	str	r3, [r7, #0x78]
; }
 800fe7e: bf00         	nop
 800fe80: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800fe84: 677b         	str	r3, [r7, #0x74]
; }
 800fe86: bf00         	nop
; 	return k;
 800fe88: 6b7b         	ldr	r3, [r7, #0x34]
 800fe8a: 647b         	str	r3, [r7, #0x44]
; 	thread = z_waitq_head(&timer->wait_q);
 800fe8c: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 800fe90: 3318         	adds	r3, #0x18
 800fe92: 4618         	mov	r0, r3
 800fe94: f00a fc1e    	bl	0x801a6d4 <z_waitq_head> @ imm = #0xa83c
 800fe98: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (thread == NULL) {
 800fe9c: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 800fea0: 2b00         	cmp	r3, #0x0
 800fea2: d111         	bne	0x800fec8 <z_timer_expiration_handler+0x23c> @ imm = #0x22
 800fea4: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800ff18 <z_timer_expiration_handler+0x28c>
 800fea6: 667b         	str	r3, [r7, #0x64]
 800fea8: 6c7b         	ldr	r3, [r7, #0x44]
 800feaa: 63fb         	str	r3, [r7, #0x3c]
; 	arch_irq_unlock(key.key);
 800feac: 6bfb         	ldr	r3, [r7, #0x3c]
 800feae: 663b         	str	r3, [r7, #0x60]
 800feb0: 6e3b         	ldr	r3, [r7, #0x60]
 800feb2: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800feb4: 6dfb         	ldr	r3, [r7, #0x5c]
 800feb6: f383 8811    	msr	basepri, r3
; }
 800feba: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800febc: f3bf 8f6f    	isb	sy
; }
 800fec0: bf00         	nop
; }
 800fec2: bf00         	nop
; }
 800fec4: bf00         	nop
; 		return;
 800fec6: e022         	b	0x800ff0e <z_timer_expiration_handler+0x282> @ imm = #0x44
; 	z_unpend_thread_no_timeout(thread);
 800fec8: f8d7 00b0    	ldr.w	r0, [r7, #0xb0]
 800fecc: f7fe fade    	bl	0x800e48c <z_unpend_thread_no_timeout> @ imm = #-0x1a44
 800fed0: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 800fed4: 64fb         	str	r3, [r7, #0x4c]
 800fed6: 2300         	movs	r3, #0x0
 800fed8: 64bb         	str	r3, [r7, #0x48]
; 	thread->arch.swap_return_value = value;
 800feda: 6cfb         	ldr	r3, [r7, #0x4c]
 800fedc: 6cba         	ldr	r2, [r7, #0x48]
 800fede: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800fee2: bf00         	nop
 800fee4: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800ff18 <z_timer_expiration_handler+0x28c>
 800fee6: 65bb         	str	r3, [r7, #0x58]
 800fee8: 6c7b         	ldr	r3, [r7, #0x44]
 800feea: 643b         	str	r3, [r7, #0x40]
; 	arch_irq_unlock(key.key);
 800feec: 6c3b         	ldr	r3, [r7, #0x40]
 800feee: 657b         	str	r3, [r7, #0x54]
 800fef0: 6d7b         	ldr	r3, [r7, #0x54]
 800fef2: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800fef4: 6d3b         	ldr	r3, [r7, #0x50]
 800fef6: f383 8811    	msr	basepri, r3
; }
 800fefa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fefc: f3bf 8f6f    	isb	sy
; }
 800ff00: bf00         	nop
; }
 800ff02: bf00         	nop
; }
 800ff04: bf00         	nop
; 	z_ready_thread(thread);
 800ff06: f8d7 00b0    	ldr.w	r0, [r7, #0xb0]
 800ff0a: f7fd ff7f    	bl	0x800de0c <z_ready_thread> @ imm = #-0x2102
; }
 800ff0e: 37b8         	adds	r7, #0xb8
 800ff10: 46bd         	mov	sp, r7
 800ff12: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 800ff16: bf00         	nop

0800ff18 <$d>:
 800ff18: 40 11 00 20  	.word	0x20001140
 800ff1c: 8d fc 00 08  	.word	0x0800fc8d

0800ff20 <z_impl_k_timer_start>:
; {
 800ff20: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800ff24: b094         	sub	sp, #0x50
 800ff26: af00         	add	r7, sp, #0x0
 800ff28: 60f8         	str	r0, [r7, #0xc]
 800ff2a: e9c7 2300    	strd	r2, r3, [r7]
 800ff2e: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8010020 <z_impl_k_timer_start+0x100>
 800ff30: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ff32: f3ef 8311    	mrs	r3, basepri
 800ff36: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800ff38: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 800ff3a: 647b         	str	r3, [r7, #0x44]
 800ff3c: 2310         	movs	r3, #0x10
 800ff3e: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ff40: 6c3b         	ldr	r3, [r7, #0x40]
 800ff42: f383 8812    	msr	basepri_max, r3
; }
 800ff46: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ff48: f3bf 8f6f    	isb	sy
; }
 800ff4c: bf00         	nop
; 	return key;
 800ff4e: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 800ff50: 617b         	str	r3, [r7, #0x14]
 800ff52: 6cfb         	ldr	r3, [r7, #0x4c]
 800ff54: 63fb         	str	r3, [r7, #0x3c]
; }
 800ff56: bf00         	nop
 800ff58: 6cfb         	ldr	r3, [r7, #0x4c]
 800ff5a: 63bb         	str	r3, [r7, #0x38]
; }
 800ff5c: bf00         	nop
; 	return k;
 800ff5e: 697b         	ldr	r3, [r7, #0x14]
 800ff60: 61fb         	str	r3, [r7, #0x1c]
; 	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
 800ff62: e9d7 2300    	ldrd	r2, r3, [r7]
 800ff66: f04f 30ff    	mov.w	r0, #0xffffffff
 800ff6a: f04f 31ff    	mov.w	r1, #0xffffffff
 800ff6e: 428b         	cmp	r3, r1
 800ff70: bf08         	it	eq
 800ff72: 4282         	cmpeq	r2, r0
 800ff74: d111         	bne	0x800ff9a <z_impl_k_timer_start+0x7a> @ imm = #0x22
 800ff76: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8010020 <z_impl_k_timer_start+0x100>
 800ff78: 637b         	str	r3, [r7, #0x34]
 800ff7a: 69fb         	ldr	r3, [r7, #0x1c]
 800ff7c: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800ff7e: 693b         	ldr	r3, [r7, #0x10]
 800ff80: 633b         	str	r3, [r7, #0x30]
 800ff82: 6b3b         	ldr	r3, [r7, #0x30]
 800ff84: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ff86: 6afb         	ldr	r3, [r7, #0x2c]
 800ff88: f383 8811    	msr	basepri, r3
; }
 800ff8c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ff8e: f3bf 8f6f    	isb	sy
; }
 800ff92: bf00         	nop
; }
 800ff94: bf00         	nop
; }
 800ff96: bf00         	nop
 800ff98: e03e         	b	0x8010018 <z_impl_k_timer_start+0xf8> @ imm = #0x7c
; 	if (Z_TICK_ABS(duration.ticks) < 0) {
 800ff9a: e9d7 2300    	ldrd	r2, r3, [r7]
 800ff9e: f06f 0001    	mvn	r0, #0x1
 800ffa2: f04f 31ff    	mov.w	r1, #0xffffffff
 800ffa6: ebb0 0802    	subs.w	r8, r0, r2
 800ffaa: eb61 0903    	sbc.w	r9, r1, r3
 800ffae: f1b9 0f00    	cmp.w	r9, #0x0
 800ffb2: da0e         	bge	0x800ffd2 <z_impl_k_timer_start+0xb2> @ imm = #0x1c
; 		duration.ticks = MAX(duration.ticks - 1, 0);
 800ffb4: e9d7 2300    	ldrd	r2, r3, [r7]
 800ffb8: 2a01         	cmp	r2, #0x1
 800ffba: f173 0100    	sbcs	r1, r3, #0x0
 800ffbe: da03         	bge	0x800ffc8 <z_impl_k_timer_start+0xa8> @ imm = #0x6
 800ffc0: f04f 0201    	mov.w	r2, #0x1
 800ffc4: f04f 0300    	mov.w	r3, #0x0
 800ffc8: 1e54         	subs	r4, r2, #0x1
 800ffca: f143 35ff    	adc	r5, r3, #0xffffffff
 800ffce: e9c7 4500    	strd	r4, r5, [r7]
; 	(void)z_abort_timeout(&timer->timeout);
 800ffd2: 68fb         	ldr	r3, [r7, #0xc]
 800ffd4: 4618         	mov	r0, r3
 800ffd6: f7ff fcbf    	bl	0x800f958 <z_abort_timeout> @ imm = #-0x682
; 	timer->period = period;
 800ffda: 68f9         	ldr	r1, [r7, #0xc]
 800ffdc: e9d7 231a    	ldrd	r2, r3, [r7, #104]
 800ffe0: e9c1 230a    	strd	r2, r3, [r1, #40]
; 	timer->status = 0U;
 800ffe4: 68fb         	ldr	r3, [r7, #0xc]
 800ffe6: 2200         	movs	r2, #0x0
 800ffe8: 631a         	str	r2, [r3, #0x30]
; 	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 800ffea: 68f8         	ldr	r0, [r7, #0xc]
 800ffec: e9d7 2300    	ldrd	r2, r3, [r7]
 800fff0: 490c         	ldr	r1, [pc, #0x30]         @ 0x8010024 <z_impl_k_timer_start+0x104>
 800fff2: f7ff fbb9    	bl	0x800f768 <z_add_timeout> @ imm = #-0x88e
 800fff6: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8010020 <z_impl_k_timer_start+0x100>
 800fff8: 62bb         	str	r3, [r7, #0x28]
 800fffa: 69fb         	ldr	r3, [r7, #0x1c]
 800fffc: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800fffe: 69bb         	ldr	r3, [r7, #0x18]
 8010000: 627b         	str	r3, [r7, #0x24]
 8010002: 6a7b         	ldr	r3, [r7, #0x24]
 8010004: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010006: 6a3b         	ldr	r3, [r7, #0x20]
 8010008: f383 8811    	msr	basepri, r3
; }
 801000c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801000e: f3bf 8f6f    	isb	sy
; }
 8010012: bf00         	nop
; }
 8010014: bf00         	nop
; }
 8010016: bf00         	nop
; }
 8010018: 3750         	adds	r7, #0x50
 801001a: 46bd         	mov	sp, r7
 801001c: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

08010020 <$d>:
 8010020: 40 11 00 20  	.word	0x20001140
 8010024: 8d fc 00 08  	.word	0x0800fc8d

08010028 <z_sched_usage_start>:
; {
 8010028: b580         	push	{r7, lr}
 801002a: b082         	sub	sp, #0x8
 801002c: af00         	add	r7, sp, #0x0
 801002e: 6078         	str	r0, [r7, #0x4]
; 	_current_cpu->usage0 = usage_now();
 8010030: f00a fb6b    	bl	0x801a70a <usage_now>   @ imm = #0xa6d6
 8010034: 4603         	mov	r3, r0
 8010036: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8010044 <z_sched_usage_start+0x1c>
 8010038: 6153         	str	r3, [r2, #0x14]
; }
 801003a: bf00         	nop
 801003c: 3708         	adds	r7, #0x8
 801003e: 46bd         	mov	sp, r7
 8010040: bd80         	pop	{r7, pc}
 8010042: bf00         	nop

08010044 <$d>:
 8010044: 30 07 00 20  	.word	0x20000730

08010048 <z_sched_usage_stop>:
; {
 8010048: b580         	push	{r7, lr}
 801004a: b090         	sub	sp, #0x40
 801004c: af00         	add	r7, sp, #0x0
 801004e: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x80100f0 <z_sched_usage_stop+0xa8>
 8010050: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010052: f3ef 8311    	mrs	r3, basepri
 8010056: 62fb         	str	r3, [r7, #0x2c]
;   return(result);
 8010058: 6afb         	ldr	r3, [r7, #0x2c]
; 	key = __get_BASEPRI();
 801005a: 62bb         	str	r3, [r7, #0x28]
 801005c: 2310         	movs	r3, #0x10
 801005e: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010060: 6a7b         	ldr	r3, [r7, #0x24]
 8010062: f383 8812    	msr	basepri_max, r3
; }
 8010066: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010068: f3bf 8f6f    	isb	sy
; }
 801006c: bf00         	nop
; 	return key;
 801006e: 6abb         	ldr	r3, [r7, #0x28]
; 	k.key = arch_irq_lock();
 8010070: 607b         	str	r3, [r7, #0x4]
 8010072: 6b3b         	ldr	r3, [r7, #0x30]
 8010074: 623b         	str	r3, [r7, #0x20]
; }
 8010076: bf00         	nop
 8010078: 6b3b         	ldr	r3, [r7, #0x30]
 801007a: 61fb         	str	r3, [r7, #0x1c]
; }
 801007c: bf00         	nop
; 	return k;
 801007e: 687b         	ldr	r3, [r7, #0x4]
 8010080: 60fb         	str	r3, [r7, #0xc]
; 	struct _cpu     *cpu = _current_cpu;
 8010082: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80100f4 <z_sched_usage_stop+0xac>
 8010084: 63fb         	str	r3, [r7, #0x3c]
; 	uint32_t u0 = cpu->usage0;
 8010086: 6bfb         	ldr	r3, [r7, #0x3c]
 8010088: 695b         	ldr	r3, [r3, #0x14]
 801008a: 63bb         	str	r3, [r7, #0x38]
; 	if (u0 != 0) {
 801008c: 6bbb         	ldr	r3, [r7, #0x38]
 801008e: 2b00         	cmp	r3, #0x0
 8010090: d015         	beq	0x80100be <z_sched_usage_stop+0x76> @ imm = #0x2a
; 		uint32_t cycles = usage_now() - u0;
 8010092: f00a fb3a    	bl	0x801a70a <usage_now>   @ imm = #0xa674
 8010096: 4602         	mov	r2, r0
 8010098: 6bbb         	ldr	r3, [r7, #0x38]
 801009a: 1ad3         	subs	r3, r2, r3
 801009c: 637b         	str	r3, [r7, #0x34]
; 		if (cpu->current->base.usage.track_usage) {
 801009e: 6bfb         	ldr	r3, [r7, #0x3c]
 80100a0: 689b         	ldr	r3, [r3, #0x8]
 80100a2: f893 3038    	ldrb.w	r3, [r3, #0x38]
 80100a6: 2b00         	cmp	r3, #0x0
 80100a8: d005         	beq	0x80100b6 <z_sched_usage_stop+0x6e> @ imm = #0xa
; 			sched_thread_update_usage(cpu->current, cycles);
 80100aa: 6bfb         	ldr	r3, [r7, #0x3c]
 80100ac: 689b         	ldr	r3, [r3, #0x8]
 80100ae: 6b79         	ldr	r1, [r7, #0x34]
 80100b0: 4618         	mov	r0, r3
 80100b2: f00a fb65    	bl	0x801a780 <sched_thread_update_usage> @ imm = #0xa6ca
; 		sched_cpu_update_usage(cpu, cycles);
 80100b6: 6b79         	ldr	r1, [r7, #0x34]
 80100b8: 6bf8         	ldr	r0, [r7, #0x3c]
 80100ba: f00a fb36    	bl	0x801a72a <sched_cpu_update_usage> @ imm = #0xa66c
; 	cpu->usage0 = 0;
 80100be: 6bfb         	ldr	r3, [r7, #0x3c]
 80100c0: 2200         	movs	r2, #0x0
 80100c2: 615a         	str	r2, [r3, #0x14]
 80100c4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80100f0 <z_sched_usage_stop+0xa8>
 80100c6: 61bb         	str	r3, [r7, #0x18]
 80100c8: 68fb         	ldr	r3, [r7, #0xc]
 80100ca: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 80100cc: 68bb         	ldr	r3, [r7, #0x8]
 80100ce: 617b         	str	r3, [r7, #0x14]
 80100d0: 697b         	ldr	r3, [r7, #0x14]
 80100d2: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80100d4: 693b         	ldr	r3, [r7, #0x10]
 80100d6: f383 8811    	msr	basepri, r3
; }
 80100da: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80100dc: f3bf 8f6f    	isb	sy
; }
 80100e0: bf00         	nop
; }
 80100e2: bf00         	nop
; }
 80100e4: bf00         	nop
; }
 80100e6: bf00         	nop
 80100e8: 3740         	adds	r7, #0x40
 80100ea: 46bd         	mov	sp, r7
 80100ec: bd80         	pop	{r7, pc}
 80100ee: bf00         	nop

080100f0 <$d>:
 80100f0: 40 11 00 20  	.word	0x20001140
 80100f4: 30 07 00 20  	.word	0x20000730

080100f8 <boot_banner>:
; {
 80100f8: b580         	push	{r7, lr}
 80100fa: af00         	add	r7, sp, #0x0
; 	printk("*** " CONFIG_BOOT_BANNER_STRING " " BANNER_VERSION BANNER_POSTFIX " ***\n");
 80100fc: 4802         	ldr	r0, [pc, #0x8]          @ 0x8010108 <boot_banner+0x10>
 80100fe: f001 fd5e    	bl	0x8011bbe <printk>      @ imm = #0x1abc
; }
 8010102: bf00         	nop
 8010104: bd80         	pop	{r7, pc}
 8010106: bf00         	nop

08010108 <$d>:
 8010108: 1c cd 01 08  	.word	0x0801cd1c

0801010c <statics_init>:
; {
 801010c: b580         	push	{r7, lr}
 801010e: b082         	sub	sp, #0x8
 8010110: af00         	add	r7, sp, #0x0
; 	STRUCT_SECTION_FOREACH(k_heap, heap) {
 8010112: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x801014c <statics_init+0x40>
 8010114: 607b         	str	r3, [r7, #0x4]
 8010116: e00a         	b	0x801012e <statics_init+0x22> @ imm = #0x14
; 			k_heap_init(heap, heap->heap.init_mem, heap->heap.init_bytes);
 8010118: 687b         	ldr	r3, [r7, #0x4]
 801011a: 6859         	ldr	r1, [r3, #0x4]
 801011c: 687b         	ldr	r3, [r7, #0x4]
 801011e: 689b         	ldr	r3, [r3, #0x8]
 8010120: 461a         	mov	r2, r3
 8010122: 6878         	ldr	r0, [r7, #0x4]
 8010124: f00a fb61    	bl	0x801a7ea <k_heap_init> @ imm = #0xa6c2
; 	STRUCT_SECTION_FOREACH(k_heap, heap) {
 8010128: 687b         	ldr	r3, [r7, #0x4]
 801012a: 3314         	adds	r3, #0x14
 801012c: 607b         	str	r3, [r7, #0x4]
 801012e: 687b         	ldr	r3, [r7, #0x4]
 8010130: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8010150 <statics_init+0x44>
 8010132: 4293         	cmp	r3, r2
 8010134: bf34         	ite	lo
 8010136: 2301         	movlo	r3, #0x1
 8010138: 2300         	movhs	r3, #0x0
 801013a: b2db         	uxtb	r3, r3
 801013c: 2b00         	cmp	r3, #0x0
 801013e: d1eb         	bne	0x8010118 <statics_init+0xc> @ imm = #-0x2a
; 	return 0;
 8010140: 2300         	movs	r3, #0x0
; }
 8010142: 4618         	mov	r0, r3
 8010144: 3708         	adds	r7, #0x8
 8010146: 46bd         	mov	sp, r7
 8010148: bd80         	pop	{r7, pc}
 801014a: bf00         	nop

0801014c <$d>:
 801014c: 08 06 00 20  	.word	0x20000608
 8010150: 08 06 00 20  	.word	0x20000608

08010154 <k_sys_work_q_init>:
; {
 8010154: b580         	push	{r7, lr}
 8010156: b084         	sub	sp, #0x10
 8010158: af02         	add	r7, sp, #0x8
; 	struct k_work_queue_config cfg = {
 801015a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8010184 <k_sys_work_q_init+0x30>
 801015c: 463b         	mov	r3, r7
 801015e: e892 0003    	ldm.w	r2, {r0, r1}
 8010162: e883 0003    	stm.w	r3, {r0, r1}
; 	k_work_queue_start(&k_sys_work_q,
 8010166: 463b         	mov	r3, r7
 8010168: 9300         	str	r3, [sp]
 801016a: f04f 33ff    	mov.w	r3, #0xffffffff
 801016e: f44f 6280    	mov.w	r2, #0x400
 8010172: 4905         	ldr	r1, [pc, #0x14]         @ 0x8010188 <k_sys_work_q_init+0x34>
 8010174: 4805         	ldr	r0, [pc, #0x14]         @ 0x801018c <k_sys_work_q_init+0x38>
 8010176: f7fd f963    	bl	0x800d440 <k_work_queue_start> @ imm = #-0x2d3a
; 	return 0;
 801017a: 2300         	movs	r3, #0x0
; }
 801017c: 4618         	mov	r0, r3
 801017e: 3708         	adds	r7, #0x8
 8010180: 46bd         	mov	sp, r7
 8010182: bd80         	pop	{r7, pc}

08010184 <$d>:
 8010184: 64 cd 01 08  	.word	0x0801cd64
 8010188: 88 36 00 20  	.word	0x20003688
 801018c: 00 0a 00 20  	.word	0x20000a00

08010190 <skip_to_arg>:
 8010190: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 8010194: 2601         	movs	r6, #0x1
 8010196: 4607         	mov	r7, r0
 8010198: 42b2         	cmp	r2, r6
 801019a: dc01         	bgt	0x80101a0 <skip_to_arg+0x10> @ imm = #0x2
 801019c: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 80101a0: 463b         	mov	r3, r7
 80101a2: 461f         	mov	r7, r3
 80101a4: f813 4b01    	ldrb	r4, [r3], #1
 80101a8: 2c00         	cmp	r4, #0x0
 80101aa: d0f7         	beq	0x801019c <skip_to_arg+0xc> @ imm = #-0x12
 80101ac: 2c25         	cmp	r4, #0x25
 80101ae: d1f8         	bne	0x80101a2 <skip_to_arg+0x12> @ imm = #-0x10
 80101b0: 781c         	ldrb	r4, [r3]
 80101b2: 2c25         	cmp	r4, #0x25
 80101b4: f107 0702    	add.w	r7, r7, #0x2
 80101b8: d0f2         	beq	0x80101a0 <skip_to_arg+0x10> @ imm = #-0x1c
 80101ba: 2300         	movs	r3, #0x0
 80101bc: f8df 8104    	ldr.w	r8, [pc, #0x104]        @ 0x80102c4 <skip_to_arg+0x134>
 80101c0: 469c         	mov	r12, r3
 80101c2: 461d         	mov	r5, r3
 80101c4: 2d1f         	cmp	r5, #0x1f
 80101c6: d818         	bhi	0x80101fa <skip_to_arg+0x6a> @ imm = #0x30
 80101c8: f1a4 0e20    	sub.w	lr, r4, #0x20
 80101cc: f1be 0f10    	cmp.w	lr, #0x10
 80101d0: d909         	bls	0x80101e6 <skip_to_arg+0x56> @ imm = #0x12
 80101d2: f1a4 0e30    	sub.w	lr, r4, #0x30
 80101d6: f1be 0f09    	cmp.w	lr, #0x9
 80101da: d81e         	bhi	0x801021a <skip_to_arg+0x8a> @ imm = #0x3c
 80101dc: 240a         	movs	r4, #0xa
 80101de: fb04 e303    	mla	r3, r4, r3, lr
 80101e2: 2520         	movs	r5, #0x20
 80101e4: e004         	b	0x80101f0 <skip_to_arg+0x60> @ imm = #0x8
 80101e6: fa28 fe0e    	lsr.w	lr, r8, lr
 80101ea: f01e 0f01    	tst.w	lr, #0x1
 80101ee: d006         	beq	0x80101fe <skip_to_arg+0x6e> @ imm = #0xc
 80101f0: f817 4b01    	ldrb	r4, [r7], #1
 80101f4: 2c00         	cmp	r4, #0x0
 80101f6: d1e5         	bne	0x80101c4 <skip_to_arg+0x34> @ imm = #-0x36
 80101f8: e028         	b	0x801024c <skip_to_arg+0xbc> @ imm = #0x50
 80101fa: 2d7f         	cmp	r5, #0x7f
 80101fc: d81c         	bhi	0x8010238 <skip_to_arg+0xa8> @ imm = #0x38
 80101fe: f1a4 0e30    	sub.w	lr, r4, #0x30
 8010202: f1be 0f09    	cmp.w	lr, #0x9
 8010206: d9e9         	bls	0x80101dc <skip_to_arg+0x4c> @ imm = #-0x2e
 8010208: 2c24         	cmp	r4, #0x24
 801020a: d110         	bne	0x801022e <skip_to_arg+0x9e> @ imm = #0x20
 801020c: f1bc 0f00    	cmp.w	r12, #0x0
 8010210: d046         	beq	0x80102a0 <skip_to_arg+0x110> @ imm = #0x8c
 8010212: 42b3         	cmp	r3, r6
 8010214: d046         	beq	0x80102a4 <skip_to_arg+0x114> @ imm = #0x8c
 8010216: 2300         	movs	r3, #0x0
 8010218: e7ea         	b	0x80101f0 <skip_to_arg+0x60> @ imm = #-0x2c
 801021a: f024 0e04    	bic	lr, r4, #0x4
 801021e: f1be 0f2a    	cmp.w	lr, #0x2a
 8010222: d0f8         	beq	0x8010216 <skip_to_arg+0x86> @ imm = #-0x10
 8010224: 2c6c         	cmp	r4, #0x6c
 8010226: d109         	bne	0x801023c <skip_to_arg+0xac> @ imm = #0x12
 8010228: f045 0580    	orr	r5, r5, #0x80
 801022c: e7e0         	b	0x80101f0 <skip_to_arg+0x60> @ imm = #-0x40
 801022e: f024 0e04    	bic	lr, r4, #0x4
 8010232: f1be 0f2a    	cmp.w	lr, #0x2a
 8010236: d0ee         	beq	0x8010216 <skip_to_arg+0x86> @ imm = #-0x24
 8010238: 2c6c         	cmp	r4, #0x6c
 801023a: d022         	beq	0x8010282 <skip_to_arg+0xf2> @ imm = #0x44
 801023c: 2c6c         	cmp	r4, #0x6c
 801023e: d81b         	bhi	0x8010278 <skip_to_arg+0xe8> @ imm = #0x36
 8010240: 2c68         	cmp	r4, #0x68
 8010242: d023         	beq	0x801028c <skip_to_arg+0xfc> @ imm = #0x46
 8010244: 2c6a         	cmp	r4, #0x6a
 8010246: d028         	beq	0x801029a <skip_to_arg+0x10a> @ imm = #0x50
 8010248: 2c4c         	cmp	r4, #0x4c
 801024a: d026         	beq	0x801029a <skip_to_arg+0x10a> @ imm = #0x4c
 801024c: f1bc 0f00    	cmp.w	r12, #0x0
 8010250: d0a4         	beq	0x801019c <skip_to_arg+0xc> @ imm = #-0xb8
 8010252: 45b4         	cmp	r12, r6
 8010254: d1a0         	bne	0x8010198 <skip_to_arg+0x8> @ imm = #-0xc0
 8010256: f044 0720    	orr	r7, r4, #0x20
 801025a: f1a7 0c65    	sub.w	r12, r7, #0x65
 801025e: f1bc 0f02    	cmp.w	r12, #0x2
 8010262: 680b         	ldr	r3, [r1]
 8010264: d901         	bls	0x801026a <skip_to_arg+0xda> @ imm = #0x2
 8010266: 2f61         	cmp	r7, #0x61
 8010268: d11e         	bne	0x80102a8 <skip_to_arg+0x118> @ imm = #0x3c
 801026a: 3307         	adds	r3, #0x7
 801026c: f023 0307    	bic	r3, r3, #0x7
 8010270: 3308         	adds	r3, #0x8
 8010272: 600b         	str	r3, [r1]
 8010274: 3601         	adds	r6, #0x1
 8010276: e78e         	b	0x8010196 <skip_to_arg+0x6> @ imm = #-0xe4
 8010278: 2c74         	cmp	r4, #0x74
 801027a: d0b9         	beq	0x80101f0 <skip_to_arg+0x60> @ imm = #-0x8e
 801027c: 2c7a         	cmp	r4, #0x7a
 801027e: d0b7         	beq	0x80101f0 <skip_to_arg+0x60> @ imm = #-0x92
 8010280: e7e4         	b	0x801024c <skip_to_arg+0xbc> @ imm = #-0x38
 8010282: 062c         	lsls	r4, r5, #0x18
 8010284: bf48         	it	mi
 8010286: f445 7500    	orrmi	r5, r5, #0x200
 801028a: e7cd         	b	0x8010228 <skip_to_arg+0x98> @ imm = #-0x66
 801028c: 05ec         	lsls	r4, r5, #0x17
 801028e: bf48         	it	mi
 8010290: f445 7500    	orrmi	r5, r5, #0x200
 8010294: f445 7580    	orr	r5, r5, #0x100
 8010298: e7aa         	b	0x80101f0 <skip_to_arg+0x60> @ imm = #-0xac
 801029a: f445 7520    	orr	r5, r5, #0x280
 801029e: e7a7         	b	0x80101f0 <skip_to_arg+0x60> @ imm = #-0xb2
 80102a0: 469c         	mov	r12, r3
 80102a2: e7b8         	b	0x8010216 <skip_to_arg+0x86> @ imm = #-0x90
 80102a4: 2463         	movs	r4, #0x63
 80102a6: e7d6         	b	0x8010256 <skip_to_arg+0xc6> @ imm = #-0x54
 80102a8: 2c69         	cmp	r4, #0x69
 80102aa: d002         	beq	0x80102b2 <skip_to_arg+0x122> @ imm = #0x4
 80102ac: d807         	bhi	0x80102be <skip_to_arg+0x12e> @ imm = #0xe
 80102ae: 2c63         	cmp	r4, #0x63
 80102b0: d003         	beq	0x80102ba <skip_to_arg+0x12a> @ imm = #0x6
 80102b2: 062f         	lsls	r7, r5, #0x18
 80102b4: d501         	bpl	0x80102ba <skip_to_arg+0x12a> @ imm = #0x2
 80102b6: 05ac         	lsls	r4, r5, #0x16
 80102b8: d4d7         	bmi	0x801026a <skip_to_arg+0xda> @ imm = #-0x52
 80102ba: 3304         	adds	r3, #0x4
 80102bc: e7d9         	b	0x8010272 <skip_to_arg+0xe2> @ imm = #-0x4e
 80102be: 2c73         	cmp	r4, #0x73
 80102c0: e7f6         	b	0x80102b0 <skip_to_arg+0x120> @ imm = #-0x14
 80102c2: bf00         	nop

080102c4 <$d>:
 80102c4: 89 28 01 00  	.word	0x00012889

080102c8 <vfprintf>:
 80102c8: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80102cc: b095         	sub	sp, #0x54
 80102ce: 6843         	ldr	r3, [r0, #0x4]
 80102d0: 9303         	str	r3, [sp, #0xc]
 80102d2: 7883         	ldrb	r3, [r0, #0x2]
 80102d4: 4680         	mov	r8, r0
 80102d6: 0798         	lsls	r0, r3, #0x1e
 80102d8: e9cd 1208    	strd	r1, r2, [sp, #32]
 80102dc: d517         	bpl	0x801030e <vfprintf+0x46> @ imm = #0x2e
 80102de: 920d         	str	r2, [sp, #0x34]
 80102e0: 460b         	mov	r3, r1
 80102e2: 2500         	movs	r5, #0x0
 80102e4: 781f         	ldrb	r7, [r3]
 80102e6: b1a7         	cbz	r7, 0x8010312 <vfprintf+0x4a> @ imm = #0x28
 80102e8: 2f25         	cmp	r7, #0x25
 80102ea: d016         	beq	0x801031a <vfprintf+0x52> @ imm = #0x2c
 80102ec: 3301         	adds	r3, #0x1
 80102ee: 9307         	str	r3, [sp, #0x1c]
 80102f0: 9b03         	ldr	r3, [sp, #0xc]
 80102f2: 4641         	mov	r1, r8
 80102f4: 4638         	mov	r0, r7
 80102f6: 4798         	blx	r3
 80102f8: 2800         	cmp	r0, #0x0
 80102fa: f105 0501    	add.w	r5, r5, #0x1
 80102fe: f280 8439    	bge.w	0x8010b74 <vfprintf+0x8ac> @ imm = #0x872
 8010302: f898 3002    	ldrb.w	r3, [r8, #0x2]
 8010306: f043 0304    	orr	r3, r3, #0x4
 801030a: f888 3002    	strb.w	r3, [r8, #0x2]
 801030e: f04f 35ff    	mov.w	r5, #0xffffffff
 8010312: 4628         	mov	r0, r5
 8010314: b015         	add	sp, #0x54
 8010316: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 801031a: 785f         	ldrb	r7, [r3, #0x1]
 801031c: 1c9a         	adds	r2, r3, #0x2
 801031e: 2f25         	cmp	r7, #0x25
 8010320: 9207         	str	r2, [sp, #0x1c]
 8010322: d0e5         	beq	0x80102f0 <vfprintf+0x28> @ imm = #-0x36
 8010324: 2400         	movs	r4, #0x0
 8010326: 4626         	mov	r6, r4
 8010328: 46a2         	mov	r10, r4
 801032a: 46a3         	mov	r11, r4
 801032c: f1bb 0f1f    	cmp.w	r11, #0x1f
 8010330: d832         	bhi	0x8010398 <vfprintf+0xd0> @ imm = #0x64
 8010332: f1a7 0320    	sub.w	r3, r7, #0x20
 8010336: 2b10         	cmp	r3, #0x10
 8010338: d80a         	bhi	0x8010350 <vfprintf+0x88> @ imm = #0x14
 801033a: e8df f003    	tbb	[pc, r3]

0801033e <$d>:
 801033e: 24 09 09 2a  	.word	0x2a090924
 8010342: 09 09 09 1b  	.word	0x1b090909
 8010346: 09 09 09 22  	.word	0x22090909
 801034a: 09 27 09 09  	.word	0x09092709
 801034e: 19           	.byte	0x19

0801034f <$d>:
 801034f: 00           	.byte	0x00

08010350 <$t>:
 8010350: f1a7 0330    	sub.w	r3, r7, #0x30
 8010354: 2b09         	cmp	r3, #0x9
 8010356: d92d         	bls	0x80103b4 <vfprintf+0xec> @ imm = #0x5a
 8010358: 2f2a         	cmp	r7, #0x2a
 801035a: d139         	bne	0x80103d0 <vfprintf+0x108> @ imm = #0x72
 801035c: b954         	cbnz	r4, 0x8010374 <vfprintf+0xac> @ imm = #0x14
 801035e: 9b0d         	ldr	r3, [sp, #0x34]
 8010360: f01b 0f40    	tst.w	r11, #0x40
 8010364: f853 2b04    	ldr	r2, [r3], #4
 8010368: 930d         	str	r3, [sp, #0x34]
 801036a: d029         	beq	0x80103c0 <vfprintf+0xf8> @ imm = #0x52
 801036c: 4616         	mov	r6, r2
 801036e: e001         	b	0x8010374 <vfprintf+0xac> @ imm = #0x2
 8010370: f04b 0b01    	orr	r11, r11, #0x1
 8010374: 9b07         	ldr	r3, [sp, #0x1c]
 8010376: f813 7b01    	ldrb	r7, [r3], #1
 801037a: 9307         	str	r3, [sp, #0x1c]
 801037c: 2f00         	cmp	r7, #0x0
 801037e: d1d5         	bne	0x801032c <vfprintf+0x64> @ imm = #-0x56
 8010380: e05b         	b	0x801043a <vfprintf+0x172> @ imm = #0xb6
 8010382: f04b 0b02    	orr	r11, r11, #0x2
 8010386: f04b 0b04    	orr	r11, r11, #0x4
 801038a: e7f3         	b	0x8010374 <vfprintf+0xac> @ imm = #-0x1a
 801038c: f04b 0b08    	orr	r11, r11, #0x8
 8010390: e7f0         	b	0x8010374 <vfprintf+0xac> @ imm = #-0x20
 8010392: f04b 0b10    	orr	r11, r11, #0x10
 8010396: e7ed         	b	0x8010374 <vfprintf+0xac> @ imm = #-0x26
 8010398: f1bb 0f7f    	cmp.w	r11, #0x7f
 801039c: d83f         	bhi	0x801041e <vfprintf+0x156> @ imm = #0x7e
 801039e: f1a7 0330    	sub.w	r3, r7, #0x30
 80103a2: 2b09         	cmp	r3, #0x9
 80103a4: d8d8         	bhi	0x8010358 <vfprintf+0x90> @ imm = #-0x50
 80103a6: f01b 0f40    	tst.w	r11, #0x40
 80103aa: d003         	beq	0x80103b4 <vfprintf+0xec> @ imm = #0x6
 80103ac: 220a         	movs	r2, #0xa
 80103ae: fb02 3606    	mla	r6, r2, r6, r3
 80103b2: e7df         	b	0x8010374 <vfprintf+0xac> @ imm = #-0x42
 80103b4: 220a         	movs	r2, #0xa
 80103b6: fb02 3a0a    	mla	r10, r2, r10, r3
 80103ba: f04b 0b20    	orr	r11, r11, #0x20
 80103be: e7d9         	b	0x8010374 <vfprintf+0xac> @ imm = #-0x4e
 80103c0: f1b2 0a00    	subs.w	r10, r2, #0x0
 80103c4: daf9         	bge	0x80103ba <vfprintf+0xf2> @ imm = #-0xe
 80103c6: f1ca 0a00    	rsb.w	r10, r10, #0x0
 80103ca: f04b 0b28    	orr	r11, r11, #0x28
 80103ce: e7d1         	b	0x8010374 <vfprintf+0xac> @ imm = #-0x5e
 80103d0: 2f2e         	cmp	r7, #0x2e
 80103d2: d105         	bne	0x80103e0 <vfprintf+0x118> @ imm = #0xa
 80103d4: f01b 0f40    	tst.w	r11, #0x40
 80103d8: d19b         	bne	0x8010312 <vfprintf+0x4a> @ imm = #-0xca
 80103da: f04b 0b40    	orr	r11, r11, #0x40
 80103de: e7c9         	b	0x8010374 <vfprintf+0xac> @ imm = #-0x6e
 80103e0: 2f24         	cmp	r7, #0x24
 80103e2: d11c         	bne	0x801041e <vfprintf+0x156> @ imm = #0x38
 80103e4: 2c00         	cmp	r4, #0x0
 80103e6: f000 8142    	beq.w	0x801066e <vfprintf+0x3a6> @ imm = #0x284
 80103ea: 9b09         	ldr	r3, [sp, #0x24]
 80103ec: 930d         	str	r3, [sp, #0x34]
 80103ee: f01b 0f40    	tst.w	r11, #0x40
 80103f2: d10a         	bne	0x801040a <vfprintf+0x142> @ imm = #0x14
 80103f4: 4652         	mov	r2, r10
 80103f6: 9808         	ldr	r0, [sp, #0x20]
 80103f8: a90d         	add	r1, sp, #0x34
 80103fa: f7ff fec9    	bl	0x8010190 <skip_to_arg> @ imm = #-0x26e
 80103fe: 9b0d         	ldr	r3, [sp, #0x34]
 8010400: 1d1a         	adds	r2, r3, #0x4
 8010402: f8d3 a000    	ldr.w	r10, [r3]
 8010406: 920d         	str	r2, [sp, #0x34]
 8010408: e7b4         	b	0x8010374 <vfprintf+0xac> @ imm = #-0x98
 801040a: 4632         	mov	r2, r6
 801040c: 9808         	ldr	r0, [sp, #0x20]
 801040e: a90d         	add	r1, sp, #0x34
 8010410: f7ff febe    	bl	0x8010190 <skip_to_arg> @ imm = #-0x284
 8010414: 9b0d         	ldr	r3, [sp, #0x34]
 8010416: 1d1a         	adds	r2, r3, #0x4
 8010418: 681e         	ldr	r6, [r3]
 801041a: 920d         	str	r2, [sp, #0x34]
 801041c: e7aa         	b	0x8010374 <vfprintf+0xac> @ imm = #-0xac
 801041e: 2f6c         	cmp	r7, #0x6c
 8010420: f000 8112    	beq.w	0x8010648 <vfprintf+0x380> @ imm = #0x224
 8010424: f200 8109    	bhi.w	0x801063a <vfprintf+0x372> @ imm = #0x212
 8010428: 2f68         	cmp	r7, #0x68
 801042a: f000 8115    	beq.w	0x8010658 <vfprintf+0x390> @ imm = #0x22a
 801042e: 2f6a         	cmp	r7, #0x6a
 8010430: f000 811a    	beq.w	0x8010668 <vfprintf+0x3a0> @ imm = #0x234
 8010434: 2f4c         	cmp	r7, #0x4c
 8010436: f000 8117    	beq.w	0x8010668 <vfprintf+0x3a0> @ imm = #0x22e
 801043a: b134         	cbz	r4, 0x801044a <vfprintf+0x182> @ imm = #0xc
 801043c: 9b09         	ldr	r3, [sp, #0x24]
 801043e: 9808         	ldr	r0, [sp, #0x20]
 8010440: 930d         	str	r3, [sp, #0x34]
 8010442: 4622         	mov	r2, r4
 8010444: a90d         	add	r1, sp, #0x34
 8010446: f7ff fea3    	bl	0x8010190 <skip_to_arg> @ imm = #-0x2ba
 801044a: 2e00         	cmp	r6, #0x0
 801044c: f047 0920    	orr	r9, r7, #0x20
 8010450: bfb8         	it	lt
 8010452: f02b 0b40    	biclt	r11, r11, #0x40
 8010456: f1a9 0365    	sub.w	r3, r9, #0x65
 801045a: bfbc         	itt	lt
 801045c: fa1f fb8b    	uxthlt.w	r11, r11
 8010460: 2600         	movlt	r6, #0x0
 8010462: 2b02         	cmp	r3, #0x2
 8010464: f240 8108    	bls.w	0x8010678 <vfprintf+0x3b0> @ imm = #0x210
 8010468: f1b9 0f61    	cmp.w	r9, #0x61
 801046c: f040 8267    	bne.w	0x801093e <vfprintf+0x676> @ imm = #0x4ce
 8010470: 43ff         	mvns	r7, r7
 8010472: f007 0320    	and	r3, r7, #0x20
 8010476: 9306         	str	r3, [sp, #0x18]
 8010478: 9b0d         	ldr	r3, [sp, #0x34]
 801047a: 3307         	adds	r3, #0x7
 801047c: f023 0307    	bic	r3, r3, #0x7
 8010480: f01b 0f40    	tst.w	r11, #0x40
 8010484: e9d3 0100    	ldrd	r0, r1, [r3]
 8010488: f103 0208    	add.w	r2, r3, #0x8
 801048c: bf08         	it	eq
 801048e: f04f 36ff    	moveq.w	r6, #0xffffffff
 8010492: 9b06         	ldr	r3, [sp, #0x18]
 8010494: 920d         	str	r2, [sp, #0x34]
 8010496: 9300         	str	r3, [sp]
 8010498: aa0e         	add	r2, sp, #0x38
 801049a: 4633         	mov	r3, r6
 801049c: f00a fb09    	bl	0x801aab2 <__dtox_engine> @ imm = #0xa612
 80104a0: 3001         	adds	r0, #0x1
 80104a2: b2c3         	uxtb	r3, r0
 80104a4: 42b3         	cmp	r3, r6
 80104a6: f44b 54c0    	orr	r4, r11, #0x1800
 80104aa: 9304         	str	r3, [sp, #0x10]
 80104ac: db01         	blt	0x80104b2 <vfprintf+0x1ea> @ imm = #0x2
 80104ae: 9b04         	ldr	r3, [sp, #0x10]
 80104b0: 1e5e         	subs	r6, r3, #0x1
 80104b2: 2301         	movs	r3, #0x1
 80104b4: 9f0e         	ldr	r7, [sp, #0x38]
 80104b6: 9305         	str	r3, [sp, #0x14]
 80104b8: 46a3         	mov	r11, r4
 80104ba: f04f 0970    	mov.w	r9, #0x70
 80104be: f107 0309    	add.w	r3, r7, #0x9
 80104c2: 2b12         	cmp	r3, #0x12
 80104c4: d90d         	bls	0x80104e2 <vfprintf+0x21a> @ imm = #0x1a
 80104c6: f107 0363    	add.w	r3, r7, #0x63
 80104ca: 2bc6         	cmp	r3, #0xc6
 80104cc: f240 810f    	bls.w	0x80106ee <vfprintf+0x426> @ imm = #0x21e
 80104d0: f207 33e7    	addw	r3, r7, #0x3e7
 80104d4: f240 72ce    	movw	r2, #0x7ce
 80104d8: 4293         	cmp	r3, r2
 80104da: bf94         	ite	ls
 80104dc: 2303         	movls	r3, #0x3
 80104de: 2304         	movhi	r3, #0x4
 80104e0: 9305         	str	r3, [sp, #0x14]
 80104e2: f89d 203c    	ldrb.w	r2, [sp, #0x3c]
 80104e6: f002 030c    	and	r3, r2, #0xc
 80104ea: f012 0201    	ands	r2, r2, #0x1
 80104ee: f040 8119    	bne.w	0x8010724 <vfprintf+0x45c> @ imm = #0x232
 80104f2: f01b 0f02    	tst.w	r11, #0x2
 80104f6: f040 8112    	bne.w	0x801071e <vfprintf+0x456> @ imm = #0x224
 80104fa: f01b 0404    	ands	r4, r11, #0x4
 80104fe: f000 80f8    	beq.w	0x80106f2 <vfprintf+0x42a> @ imm = #0x1f0
 8010502: 2b00         	cmp	r3, #0x0
 8010504: f040 8111    	bne.w	0x801072a <vfprintf+0x462> @ imm = #0x222
 8010508: 2320         	movs	r3, #0x20
 801050a: f41b 5f40    	tst.w	r11, #0x3000
 801050e: d11f         	bne	0x8010550 <vfprintf+0x288> @ imm = #0x3e
 8010510: 9a04         	ldr	r2, [sp, #0x10]
 8010512: 3250         	adds	r2, #0x50
 8010514: 2e00         	cmp	r6, #0x0
 8010516: 446a         	add	r2, sp, r2
 8010518: bf08         	it	eq
 801051a: 2601         	moveq	r6, #0x1
 801051c: 3a13         	subs	r2, #0x13
 801051e: 9904         	ldr	r1, [sp, #0x10]
 8010520: b121         	cbz	r1, 0x801052c <vfprintf+0x264> @ imm = #0x8
 8010522: f812 1d01    	ldrb	r1, [r2, #-1]!
 8010526: 2930         	cmp	r1, #0x30
 8010528: f000 8136    	beq.w	0x8010798 <vfprintf+0x4d0> @ imm = #0x26c
 801052c: f01b 0f10    	tst.w	r11, #0x10
 8010530: 9a04         	ldr	r2, [sp, #0x10]
 8010532: bf18         	it	ne
 8010534: 4632         	movne	r2, r6
 8010536: 1d39         	adds	r1, r7, #0x4
 8010538: f2c0 8133    	blt.w	0x80107a2 <vfprintf+0x4da> @ imm = #0x266
 801053c: 42b7         	cmp	r7, r6
 801053e: f280 8130    	bge.w	0x80107a2 <vfprintf+0x4da> @ imm = #0x260
 8010542: 42ba         	cmp	r2, r7
 8010544: f44b 5b00    	orr	r11, r11, #0x2000
 8010548: f340 812d    	ble.w	0x80107a6 <vfprintf+0x4de> @ imm = #0x25a
 801054c: 1c7e         	adds	r6, r7, #0x1
 801054e: 1b96         	subs	r6, r2, r6
 8010550: f41b 5200    	ands	r2, r11, #0x2000
 8010554: 920a         	str	r2, [sp, #0x28]
 8010556: f000 8128    	beq.w	0x80107aa <vfprintf+0x4e2> @ imm = #0x250
 801055a: ea27 74e7    	bic.w	r4, r7, r7, asr #31
 801055e: 3401         	adds	r4, #0x1
 8010560: b103         	cbz	r3, 0x8010564 <vfprintf+0x29c> @ imm = #0x0
 8010562: 3401         	adds	r4, #0x1
 8010564: 2e00         	cmp	r6, #0x0
 8010566: f000 8128    	beq.w	0x80107ba <vfprintf+0x4f2> @ imm = #0x250
 801056a: 1c72         	adds	r2, r6, #0x1
 801056c: 4414         	add	r4, r2
 801056e: 45a2         	cmp	r10, r4
 8010570: bfcc         	ite	gt
 8010572: ebaa 0404    	subgt.w	r4, r10, r4
 8010576: 2400         	movle	r4, #0x0
 8010578: f01b 0f09    	tst.w	r11, #0x9
 801057c: d104         	bne	0x8010588 <vfprintf+0x2c0> @ imm = #0x8
 801057e: 442c         	add	r4, r5
 8010580: 42a5         	cmp	r5, r4
 8010582: f040 811f    	bne.w	0x80107c4 <vfprintf+0x4fc> @ imm = #0x23e
 8010586: 2400         	movs	r4, #0x0
 8010588: b143         	cbz	r3, 0x801059c <vfprintf+0x2d4> @ imm = #0x10
 801058a: 4618         	mov	r0, r3
 801058c: 4641         	mov	r1, r8
 801058e: 9b03         	ldr	r3, [sp, #0xc]
 8010590: 4798         	blx	r3
 8010592: 2800         	cmp	r0, #0x0
 8010594: f105 0501    	add.w	r5, r5, #0x1
 8010598: f6ff aeb3    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x29a
 801059c: f41b 6f00    	tst.w	r11, #0x800
 80105a0: d013         	beq	0x80105ca <vfprintf+0x302> @ imm = #0x26
 80105a2: 9b03         	ldr	r3, [sp, #0xc]
 80105a4: 4641         	mov	r1, r8
 80105a6: 2030         	movs	r0, #0x30
 80105a8: 4798         	blx	r3
 80105aa: 2800         	cmp	r0, #0x0
 80105ac: f6ff aea9    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x2ae
 80105b0: 9b06         	ldr	r3, [sp, #0x18]
 80105b2: f1c3 0078    	rsb.w	r0, r3, #0x78
 80105b6: 4641         	mov	r1, r8
 80105b8: 9b03         	ldr	r3, [sp, #0xc]
 80105ba: f000 00f8    	and	r0, r0, #0xf8
 80105be: 4798         	blx	r3
 80105c0: 2800         	cmp	r0, #0x0
 80105c2: f105 0502    	add.w	r5, r5, #0x2
 80105c6: f6ff ae9c    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x2c8
 80105ca: f01b 0f08    	tst.w	r11, #0x8
 80105ce: d105         	bne	0x80105dc <vfprintf+0x314> @ imm = #0xa
 80105d0: 442c         	add	r4, r5
 80105d2: 42ac         	cmp	r4, r5
 80105d4: f040 8102    	bne.w	0x80107dc <vfprintf+0x514> @ imm = #0x204
 80105d8: 4625         	mov	r5, r4
 80105da: 2400         	movs	r4, #0x0
 80105dc: 9b0a         	ldr	r3, [sp, #0x28]
 80105de: 2b00         	cmp	r3, #0x0
 80105e0: f000 811c    	beq.w	0x801081c <vfprintf+0x554> @ imm = #0x238
 80105e4: ea27 7ae7    	bic.w	r10, r7, r7, asr #31
 80105e8: eba7 070a    	sub.w	r7, r7, r10
 80105ec: 4276         	rsbs	r6, r6, #0
 80105ee: 9b04         	ldr	r3, [sp, #0x10]
 80105f0: 42bb         	cmp	r3, r7
 80105f2: bf84         	itt	hi
 80105f4: ab0e         	addhi	r3, sp, #0x38
 80105f6: 18fb         	addhi	r3, r7, r3
 80105f8: f10a 3aff    	add.w	r10, r10, #0xffffffff
 80105fc: bf88         	it	hi
 80105fe: 7958         	ldrbhi	r0, [r3, #0x5]
 8010600: 9b03         	ldr	r3, [sp, #0xc]
 8010602: bf98         	it	ls
 8010604: 2030         	movls	r0, #0x30
 8010606: 4556         	cmp	r6, r10
 8010608: f105 0901    	add.w	r9, r5, #0x1
 801060c: 4641         	mov	r1, r8
 801060e: f300 80ef    	bgt.w	0x80107f0 <vfprintf+0x528> @ imm = #0x1de
 8010612: 4798         	blx	r3
 8010614: 2800         	cmp	r0, #0x0
 8010616: f107 0701    	add.w	r7, r7, #0x1
 801061a: f6ff ae72    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x31c
 801061e: f1ba 3fff    	cmp.w	r10, #0xffffffff
 8010622: d108         	bne	0x8010636 <vfprintf+0x36e> @ imm = #0x10
 8010624: 9b03         	ldr	r3, [sp, #0xc]
 8010626: 4641         	mov	r1, r8
 8010628: 202e         	movs	r0, #0x2e
 801062a: 4798         	blx	r3
 801062c: 2800         	cmp	r0, #0x0
 801062e: f6ff ae68    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x330
 8010632: f105 0902    	add.w	r9, r5, #0x2
 8010636: 464d         	mov	r5, r9
 8010638: e7d9         	b	0x80105ee <vfprintf+0x326> @ imm = #-0x4e
 801063a: 2f74         	cmp	r7, #0x74
 801063c: f43f ae9a    	beq.w	0x8010374 <vfprintf+0xac> @ imm = #-0x2cc
 8010640: 2f7a         	cmp	r7, #0x7a
 8010642: f43f ae97    	beq.w	0x8010374 <vfprintf+0xac> @ imm = #-0x2d2
 8010646: e6f8         	b	0x801043a <vfprintf+0x172> @ imm = #-0x210
 8010648: f01b 0f80    	tst.w	r11, #0x80
 801064c: bf18         	it	ne
 801064e: f44b 7b00    	orrne	r11, r11, #0x200
 8010652: f04b 0b80    	orr	r11, r11, #0x80
 8010656: e68d         	b	0x8010374 <vfprintf+0xac> @ imm = #-0x2e6
 8010658: f41b 7f80    	tst.w	r11, #0x100
 801065c: bf18         	it	ne
 801065e: f44b 7b00    	orrne	r11, r11, #0x200
 8010662: f44b 7b80    	orr	r11, r11, #0x100
 8010666: e685         	b	0x8010374 <vfprintf+0xac> @ imm = #-0x2f6
 8010668: f44b 7b20    	orr	r11, r11, #0x280
 801066c: e682         	b	0x8010374 <vfprintf+0xac> @ imm = #-0x2fc
 801066e: 4626         	mov	r6, r4
 8010670: 46b3         	mov	r11, r6
 8010672: 4654         	mov	r4, r10
 8010674: 46b2         	mov	r10, r6
 8010676: e67d         	b	0x8010374 <vfprintf+0xac> @ imm = #-0x306
 8010678: 43ff         	mvns	r7, r7
 801067a: f007 0320    	and	r3, r7, #0x20
 801067e: 9306         	str	r3, [sp, #0x18]
 8010680: 9b0d         	ldr	r3, [sp, #0x34]
 8010682: 3307         	adds	r3, #0x7
 8010684: f023 0307    	bic	r3, r3, #0x7
 8010688: f01b 0f40    	tst.w	r11, #0x40
 801068c: f103 0208    	add.w	r2, r3, #0x8
 8010690: bf08         	it	eq
 8010692: 2606         	moveq	r6, #0x6
 8010694: f1b9 0f65    	cmp.w	r9, #0x65
 8010698: e9d3 0100    	ldrd	r0, r1, [r3]
 801069c: 920d         	str	r2, [sp, #0x34]
 801069e: d113         	bne	0x80106c8 <vfprintf+0x400> @ imm = #0x26
 80106a0: 1c73         	adds	r3, r6, #0x1
 80106a2: 2200         	movs	r2, #0x0
 80106a4: b2db         	uxtb	r3, r3
 80106a6: f44b 5b80    	orr	r11, r11, #0x1000
 80106aa: 4614         	mov	r4, r2
 80106ac: 2b11         	cmp	r3, #0x11
 80106ae: e9cd 2400    	strd	r2, r4, [sp]
 80106b2: bf28         	it	hs
 80106b4: 2311         	movhs	r3, #0x11
 80106b6: aa0e         	add	r2, sp, #0x38
 80106b8: f000 fafc    	bl	0x8010cb4 <__dtoa_engine> @ imm = #0x5f8
 80106bc: b2c3         	uxtb	r3, r0
 80106be: 9304         	str	r3, [sp, #0x10]
 80106c0: 2302         	movs	r3, #0x2
 80106c2: 9f0e         	ldr	r7, [sp, #0x38]
 80106c4: 9305         	str	r3, [sp, #0x14]
 80106c6: e6fa         	b	0x80104be <vfprintf+0x1f6> @ imm = #-0x20c
 80106c8: f1b9 0f66    	cmp.w	r9, #0x66
 80106cc: d105         	bne	0x80106da <vfprintf+0x412> @ imm = #0xa
 80106ce: f44b 5b00    	orr	r11, r11, #0x2000
 80106d2: 4634         	mov	r4, r6
 80106d4: 2201         	movs	r2, #0x1
 80106d6: 2311         	movs	r3, #0x11
 80106d8: e7e8         	b	0x80106ac <vfprintf+0x3e4> @ imm = #-0x30
 80106da: b2f3         	uxtb	r3, r6
 80106dc: 2b01         	cmp	r3, #0x1
 80106de: f04f 0200    	mov.w	r2, #0x0
 80106e2: bf38         	it	lo
 80106e4: 2301         	movlo	r3, #0x1
 80106e6: 4614         	mov	r4, r2
 80106e8: f04f 0965    	mov.w	r9, #0x65
 80106ec: e7de         	b	0x80106ac <vfprintf+0x3e4> @ imm = #-0x44
 80106ee: 2302         	movs	r3, #0x2
 80106f0: e6f6         	b	0x80104e0 <vfprintf+0x218> @ imm = #-0x214
 80106f2: 2b00         	cmp	r3, #0x0
 80106f4: f43f af09    	beq.w	0x801050a <vfprintf+0x242> @ imm = #-0x1ee
 80106f8: f1ba 0f03    	cmp.w	r10, #0x3
 80106fc: dc3b         	bgt	0x8010776 <vfprintf+0x4ae> @ imm = #0x76
 80106fe: f89d 303c    	ldrb.w	r3, [sp, #0x3c]
 8010702: 4ea6         	ldr	r6, [pc, #0x298]        @ 0x801099c <vfprintf+0x6d4>
 8010704: f013 0f08    	tst.w	r3, #0x8
 8010708: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x80109a0 <vfprintf+0x6d8>
 801070a: bf08         	it	eq
 801070c: 461e         	moveq	r6, r3
 801070e: 4637         	mov	r7, r6
 8010710: 46b9         	mov	r9, r7
 8010712: f817 0b01    	ldrb	r0, [r7], #1
 8010716: bbb0         	cbnz	r0, 0x8010786 <vfprintf+0x4be> @ imm = #0x6c
 8010718: 1bae         	subs	r6, r5, r6
 801071a: 44b1         	add	r9, r6
 801071c: e07b         	b	0x8010816 <vfprintf+0x54e> @ imm = #0xf6
 801071e: bb33         	cbnz	r3, 0x801076e <vfprintf+0x4a6> @ imm = #0x4c
 8010720: 232b         	movs	r3, #0x2b
 8010722: e6f2         	b	0x801050a <vfprintf+0x242> @ imm = #-0x21c
 8010724: bb2b         	cbnz	r3, 0x8010772 <vfprintf+0x4aa> @ imm = #0x4a
 8010726: 232d         	movs	r3, #0x2d
 8010728: e6ef         	b	0x801050a <vfprintf+0x242> @ imm = #-0x222
 801072a: 2220         	movs	r2, #0x20
 801072c: f1ba 0f04    	cmp.w	r10, #0x4
 8010730: dd13         	ble	0x801075a <vfprintf+0x492> @ imm = #0x26
 8010732: f01b 0f08    	tst.w	r11, #0x8
 8010736: f1aa 0404    	sub.w	r4, r10, #0x4
 801073a: d10f         	bne	0x801075c <vfprintf+0x494> @ imm = #0x1e
 801073c: 442c         	add	r4, r5
 801073e: 9b03         	ldr	r3, [sp, #0xc]
 8010740: 9204         	str	r2, [sp, #0x10]
 8010742: 4641         	mov	r1, r8
 8010744: 2020         	movs	r0, #0x20
 8010746: 4798         	blx	r3
 8010748: 2800         	cmp	r0, #0x0
 801074a: f105 0501    	add.w	r5, r5, #0x1
 801074e: f6ff add8    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x450
 8010752: 42a5         	cmp	r5, r4
 8010754: 9a04         	ldr	r2, [sp, #0x10]
 8010756: d1f2         	bne	0x801073e <vfprintf+0x476> @ imm = #-0x1c
 8010758: b19a         	cbz	r2, 0x8010782 <vfprintf+0x4ba> @ imm = #0x26
 801075a: 2400         	movs	r4, #0x0
 801075c: 9b03         	ldr	r3, [sp, #0xc]
 801075e: 4641         	mov	r1, r8
 8010760: 4610         	mov	r0, r2
 8010762: 4798         	blx	r3
 8010764: 2800         	cmp	r0, #0x0
 8010766: f105 0501    	add.w	r5, r5, #0x1
 801076a: dac8         	bge	0x80106fe <vfprintf+0x436> @ imm = #-0x70
 801076c: e5c9         	b	0x8010302 <vfprintf+0x3a> @ imm = #-0x46e
 801076e: 222b         	movs	r2, #0x2b
 8010770: e7dc         	b	0x801072c <vfprintf+0x464> @ imm = #-0x48
 8010772: 222d         	movs	r2, #0x2d
 8010774: e7da         	b	0x801072c <vfprintf+0x464> @ imm = #-0x4c
 8010776: f01b 0f08    	tst.w	r11, #0x8
 801077a: f1aa 0403    	sub.w	r4, r10, #0x3
 801077e: d1be         	bne	0x80106fe <vfprintf+0x436> @ imm = #-0x84
 8010780: e7dc         	b	0x801073c <vfprintf+0x474> @ imm = #-0x48
 8010782: 4614         	mov	r4, r2
 8010784: e7bb         	b	0x80106fe <vfprintf+0x436> @ imm = #-0x8a
 8010786: 9b06         	ldr	r3, [sp, #0x18]
 8010788: 1ac0         	subs	r0, r0, r3
 801078a: 4641         	mov	r1, r8
 801078c: 9b03         	ldr	r3, [sp, #0xc]
 801078e: b2c0         	uxtb	r0, r0
 8010790: 4798         	blx	r3
 8010792: 2800         	cmp	r0, #0x0
 8010794: dabc         	bge	0x8010710 <vfprintf+0x448> @ imm = #-0x88
 8010796: e5b4         	b	0x8010302 <vfprintf+0x3a> @ imm = #-0x498
 8010798: 9904         	ldr	r1, [sp, #0x10]
 801079a: 3901         	subs	r1, #0x1
 801079c: b2c9         	uxtb	r1, r1
 801079e: 9104         	str	r1, [sp, #0x10]
 80107a0: e6bd         	b	0x801051e <vfprintf+0x256> @ imm = #-0x286
 80107a2: 1e56         	subs	r6, r2, #0x1
 80107a4: e6d4         	b	0x8010550 <vfprintf+0x288> @ imm = #-0x258
 80107a6: 2600         	movs	r6, #0x0
 80107a8: e6d2         	b	0x8010550 <vfprintf+0x288> @ imm = #-0x25c
 80107aa: f41b 6f00    	tst.w	r11, #0x800
 80107ae: 9a05         	ldr	r2, [sp, #0x14]
 80107b0: bf0c         	ite	eq
 80107b2: 2403         	moveq	r4, #0x3
 80107b4: 2405         	movne	r4, #0x5
 80107b6: 4414         	add	r4, r2
 80107b8: e6d2         	b	0x8010560 <vfprintf+0x298> @ imm = #-0x25c
 80107ba: f01b 0f10    	tst.w	r11, #0x10
 80107be: bf18         	it	ne
 80107c0: 3401         	addne	r4, #0x1
 80107c2: e6d4         	b	0x801056e <vfprintf+0x2a6> @ imm = #-0x258
 80107c4: 930b         	str	r3, [sp, #0x2c]
 80107c6: 4641         	mov	r1, r8
 80107c8: 9b03         	ldr	r3, [sp, #0xc]
 80107ca: 2020         	movs	r0, #0x20
 80107cc: 4798         	blx	r3
 80107ce: 2800         	cmp	r0, #0x0
 80107d0: 9b0b         	ldr	r3, [sp, #0x2c]
 80107d2: f105 0501    	add.w	r5, r5, #0x1
 80107d6: f6bf aed3    	bge.w	0x8010580 <vfprintf+0x2b8> @ imm = #-0x25a
 80107da: e592         	b	0x8010302 <vfprintf+0x3a> @ imm = #-0x4dc
 80107dc: 9b03         	ldr	r3, [sp, #0xc]
 80107de: 4641         	mov	r1, r8
 80107e0: 2030         	movs	r0, #0x30
 80107e2: 4798         	blx	r3
 80107e4: 2800         	cmp	r0, #0x0
 80107e6: f105 0501    	add.w	r5, r5, #0x1
 80107ea: f6bf aef2    	bge.w	0x80105d2 <vfprintf+0x30a> @ imm = #-0x21c
 80107ee: e588         	b	0x8010302 <vfprintf+0x3a> @ imm = #-0x4f0
 80107f0: 4798         	blx	r3
 80107f2: 2800         	cmp	r0, #0x0
 80107f4: f6ff ad85    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x4f6
 80107f8: f01b 0f10    	tst.w	r11, #0x10
 80107fc: d00b         	beq	0x8010816 <vfprintf+0x54e> @ imm = #0x16
 80107fe: f1ba 3fff    	cmp.w	r10, #0xffffffff
 8010802: d108         	bne	0x8010816 <vfprintf+0x54e> @ imm = #0x10
 8010804: f105 0902    	add.w	r9, r5, #0x2
 8010808: 4641         	mov	r1, r8
 801080a: 202e         	movs	r0, #0x2e
 801080c: 9b03         	ldr	r3, [sp, #0xc]
 801080e: 4798         	blx	r3
 8010810: 2800         	cmp	r0, #0x0
 8010812: f6ff ad76    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x514
 8010816: 464d         	mov	r5, r9
 8010818: 444c         	add	r4, r9
 801081a: e233         	b	0x8010c84 <vfprintf+0x9bc> @ imm = #0x466
 801081c: f89d 003d    	ldrb.w	r0, [sp, #0x3d]
 8010820: 9b03         	ldr	r3, [sp, #0xc]
 8010822: 4641         	mov	r1, r8
 8010824: 4798         	blx	r3
 8010826: 2800         	cmp	r0, #0x0
 8010828: f6ff ad6b    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x52a
 801082c: 2e00         	cmp	r6, #0x0
 801082e: dd69         	ble	0x8010904 <vfprintf+0x63c> @ imm = #0xd2
 8010830: 9b03         	ldr	r3, [sp, #0xc]
 8010832: 4641         	mov	r1, r8
 8010834: 202e         	movs	r0, #0x2e
 8010836: 4798         	blx	r3
 8010838: 2800         	cmp	r0, #0x0
 801083a: f6ff ad62    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x53c
 801083e: f04f 0a01    	mov.w	r10, #0x1
 8010842: 9b04         	ldr	r3, [sp, #0x10]
 8010844: 459a         	cmp	r10, r3
 8010846: bfbb         	ittet	lt
 8010848: ab0e         	addlt	r3, sp, #0x38
 801084a: 4453         	addlt	r3, r10
 801084c: 2030         	movge	r0, #0x30
 801084e: 7958         	ldrblt	r0, [r3, #0x5]
 8010850: 9b03         	ldr	r3, [sp, #0xc]
 8010852: 4641         	mov	r1, r8
 8010854: 4798         	blx	r3
 8010856: 2800         	cmp	r0, #0x0
 8010858: 46d3         	mov	r11, r10
 801085a: f6ff ad52    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x55c
 801085e: f10a 0a01    	add.w	r10, r10, #0x1
 8010862: 4556         	cmp	r6, r10
 8010864: daed         	bge	0x8010842 <vfprintf+0x57a> @ imm = #-0x26
 8010866: 3502         	adds	r5, #0x2
 8010868: 445d         	add	r5, r11
 801086a: 9b06         	ldr	r3, [sp, #0x18]
 801086c: eba9 0003    	sub.w	r0, r9, r3
 8010870: 4641         	mov	r1, r8
 8010872: 9b03         	ldr	r3, [sp, #0xc]
 8010874: b2c0         	uxtb	r0, r0
 8010876: 4798         	blx	r3
 8010878: 2800         	cmp	r0, #0x0
 801087a: f6ff ad42    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x57c
 801087e: 2f00         	cmp	r7, #0x0
 8010880: bfb4         	ite	lt
 8010882: 202d         	movlt	r0, #0x2d
 8010884: 202b         	movge	r0, #0x2b
 8010886: 9b03         	ldr	r3, [sp, #0xc]
 8010888: 4641         	mov	r1, r8
 801088a: bfb8         	it	lt
 801088c: 427f         	rsblt	r7, r7, #0
 801088e: 4798         	blx	r3
 8010890: 2800         	cmp	r0, #0x0
 8010892: f6ff ad36    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x594
 8010896: 9b05         	ldr	r3, [sp, #0x14]
 8010898: 2b04         	cmp	r3, #0x4
 801089a: d141         	bne	0x8010920 <vfprintf+0x658> @ imm = #0x82
 801089c: f44f 797a    	mov.w	r9, #0x3e8
 80108a0: fbb7 f6f9    	udiv	r6, r7, r9
 80108a4: f106 0030    	add.w	r0, r6, #0x30
 80108a8: 9b03         	ldr	r3, [sp, #0xc]
 80108aa: 4641         	mov	r1, r8
 80108ac: b2c0         	uxtb	r0, r0
 80108ae: 4798         	blx	r3
 80108b0: 2800         	cmp	r0, #0x0
 80108b2: f105 0503    	add.w	r5, r5, #0x3
 80108b6: f6ff ad24    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x5b8
 80108ba: fb09 7716    	mls	r7, r9, r6, r7
 80108be: f04f 0964    	mov.w	r9, #0x64
 80108c2: fbb7 f6f9    	udiv	r6, r7, r9
 80108c6: f106 0030    	add.w	r0, r6, #0x30
 80108ca: 9b03         	ldr	r3, [sp, #0xc]
 80108cc: 4641         	mov	r1, r8
 80108ce: b2c0         	uxtb	r0, r0
 80108d0: 4798         	blx	r3
 80108d2: 2800         	cmp	r0, #0x0
 80108d4: f105 0501    	add.w	r5, r5, #0x1
 80108d8: f6ff ad13    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x5da
 80108dc: fb09 7716    	mls	r7, r9, r6, r7
 80108e0: f04f 090a    	mov.w	r9, #0xa
 80108e4: fbb7 f6f9    	udiv	r6, r7, r9
 80108e8: f106 0030    	add.w	r0, r6, #0x30
 80108ec: 9b03         	ldr	r3, [sp, #0xc]
 80108ee: 4641         	mov	r1, r8
 80108f0: b2c0         	uxtb	r0, r0
 80108f2: 4798         	blx	r3
 80108f4: 2800         	cmp	r0, #0x0
 80108f6: f105 0501    	add.w	r5, r5, #0x1
 80108fa: f6ff ad02    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x5fc
 80108fe: fb09 7716    	mls	r7, r9, r6, r7
 8010902: e015         	b	0x8010930 <vfprintf+0x668> @ imm = #0x2a
 8010904: f01b 0f10    	tst.w	r11, #0x10
 8010908: d101         	bne	0x801090e <vfprintf+0x646> @ imm = #0x2
 801090a: 3501         	adds	r5, #0x1
 801090c: e7ad         	b	0x801086a <vfprintf+0x5a2> @ imm = #-0xa6
 801090e: 9b03         	ldr	r3, [sp, #0xc]
 8010910: 4641         	mov	r1, r8
 8010912: 202e         	movs	r0, #0x2e
 8010914: 4798         	blx	r3
 8010916: 2800         	cmp	r0, #0x0
 8010918: f105 0502    	add.w	r5, r5, #0x2
 801091c: daa5         	bge	0x801086a <vfprintf+0x5a2> @ imm = #-0xb6
 801091e: e4f0         	b	0x8010302 <vfprintf+0x3a> @ imm = #-0x620
 8010920: 9b05         	ldr	r3, [sp, #0x14]
 8010922: 2b03         	cmp	r3, #0x3
 8010924: f105 0502    	add.w	r5, r5, #0x2
 8010928: d0c9         	beq	0x80108be <vfprintf+0x5f6> @ imm = #-0x6e
 801092a: 9b05         	ldr	r3, [sp, #0x14]
 801092c: 2b01         	cmp	r3, #0x1
 801092e: d1d7         	bne	0x80108e0 <vfprintf+0x618> @ imm = #-0x52
 8010930: f107 0030    	add.w	r0, r7, #0x30
 8010934: f105 0901    	add.w	r9, r5, #0x1
 8010938: 4641         	mov	r1, r8
 801093a: b2c0         	uxtb	r0, r0
 801093c: e766         	b	0x801080c <vfprintf+0x544> @ imm = #-0x134
 801093e: f1a7 0363    	sub.w	r3, r7, #0x63
 8010942: 2b12         	cmp	r3, #0x12
 8010944: f200 80ff    	bhi.w	0x8010b46 <vfprintf+0x87e> @ imm = #0x1fe
 8010948: e8df f013    	tbh	[pc, r3, lsl #1]

0801094c <$d>:
 801094c: 13 00 57 00  	.word	0x00570013
 8010950: fd 00 fd 00  	.word	0x00fd00fd
 8010954: fd 00 fd 00  	.word	0x00fd00fd
 8010958: 57 00 fd 00  	.word	0x00fd0057
 801095c: fd 00 fd 00  	.word	0x00fd00fd
 8010960: fd 00 fd 00  	.word	0x00fd00fd
 8010964: 17 01 f8 00  	.word	0x00f80117
 8010968: fd 00 fd 00  	.word	0x00fd00fd
 801096c: 2c 00 fd 00  	.word	0x00fd002c
 8010970: b9 00        	.short	0x00b9

08010972 <$t>:
 8010972: 9b0d         	ldr	r3, [sp, #0x34]
 8010974: 1d1a         	adds	r2, r3, #0x4
 8010976: 681b         	ldr	r3, [r3]
 8010978: 920d         	str	r2, [sp, #0x34]
 801097a: f88d 3038    	strb.w	r3, [sp, #0x38]
 801097e: 2401         	movs	r4, #0x1
 8010980: af0e         	add	r7, sp, #0x38
 8010982: f01b 0f08    	tst.w	r11, #0x8
 8010986: d02e         	beq	0x80109e6 <vfprintf+0x71e> @ imm = #0x5c
 8010988: 193e         	adds	r6, r7, r4
 801098a: 46b9         	mov	r9, r7
 801098c: 45b1         	cmp	r9, r6
 801098e: d12c         	bne	0x80109ea <vfprintf+0x722> @ imm = #0x58
 8010990: 1bef         	subs	r7, r5, r7
 8010992: 44b9         	add	r9, r7
 8010994: ebaa 0404    	sub.w	r4, r10, r4
 8010998: e73d         	b	0x8010816 <vfprintf+0x54e> @ imm = #-0x186
 801099a: bf00         	nop

0801099c <$d>:
 801099c: b5 da 01 08  	.word	0x0801dab5
 80109a0: b1 da 01 08  	.word	0x0801dab1

080109a4 <$t>:
 80109a4: 9b0d         	ldr	r3, [sp, #0x34]
 80109a6: 1d1a         	adds	r2, r3, #0x4
 80109a8: 920d         	str	r2, [sp, #0x34]
 80109aa: 681f         	ldr	r7, [r3]
 80109ac: 4bab         	ldr	r3, [pc, #0x2ac]        @ 0x8010c5c <vfprintf+0x994>
 80109ae: 2f00         	cmp	r7, #0x0
 80109b0: bf08         	it	eq
 80109b2: 461f         	moveq	r7, r3
 80109b4: f01b 0f40    	tst.w	r11, #0x40
 80109b8: bf14         	ite	ne
 80109ba: 4631         	movne	r1, r6
 80109bc: f04f 31ff    	moveq.w	r1, #0xffffffff
 80109c0: 4638         	mov	r0, r7
 80109c2: f009 ff4d    	bl	0x801a860 <strnlen>     @ imm = #0x9e9a
 80109c6: 4604         	mov	r4, r0
 80109c8: e7db         	b	0x8010982 <vfprintf+0x6ba> @ imm = #-0x4a
 80109ca: 9b03         	ldr	r3, [sp, #0xc]
 80109cc: 4641         	mov	r1, r8
 80109ce: 2020         	movs	r0, #0x20
 80109d0: 4798         	blx	r3
 80109d2: 2800         	cmp	r0, #0x0
 80109d4: f6ff ac95    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x6d6
 80109d8: 3e01         	subs	r6, #0x1
 80109da: 42b4         	cmp	r4, r6
 80109dc: d3f5         	blo	0x80109ca <vfprintf+0x702> @ imm = #-0x16
 80109de: 4455         	add	r5, r10
 80109e0: 1bad         	subs	r5, r5, r6
 80109e2: 46b2         	mov	r10, r6
 80109e4: e7d0         	b	0x8010988 <vfprintf+0x6c0> @ imm = #-0x60
 80109e6: 4656         	mov	r6, r10
 80109e8: e7f7         	b	0x80109da <vfprintf+0x712> @ imm = #-0x12
 80109ea: f819 0b01    	ldrb	r0, [r9], #1
 80109ee: 9b03         	ldr	r3, [sp, #0xc]
 80109f0: 4641         	mov	r1, r8
 80109f2: 4798         	blx	r3
 80109f4: 2800         	cmp	r0, #0x0
 80109f6: dac9         	bge	0x801098c <vfprintf+0x6c4> @ imm = #-0x6e
 80109f8: e483         	b	0x8010302 <vfprintf+0x3a> @ imm = #-0x6fa
 80109fa: f01b 0f80    	tst.w	r11, #0x80
 80109fe: 9b0d         	ldr	r3, [sp, #0x34]
 8010a00: d035         	beq	0x8010a6e <vfprintf+0x7a6> @ imm = #0x6a
 8010a02: f41b 7f00    	tst.w	r11, #0x200
 8010a06: d02d         	beq	0x8010a64 <vfprintf+0x79c> @ imm = #0x5a
 8010a08: 3307         	adds	r3, #0x7
 8010a0a: f023 0307    	bic	r3, r3, #0x7
 8010a0e: e9d3 0100    	ldrd	r0, r1, [r3]
 8010a12: f103 0208    	add.w	r2, r3, #0x8
 8010a16: 920d         	str	r2, [sp, #0x34]
 8010a18: f02b 0910    	bic	r9, r11, #0x10
 8010a1c: 2900         	cmp	r1, #0x0
 8010a1e: fa1f f989    	uxth.w	r9, r9
 8010a22: da36         	bge	0x8010a92 <vfprintf+0x7ca> @ imm = #0x6c
 8010a24: 4240         	rsbs	r0, r0, #0
 8010a26: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8010a2a: f449 6980    	orr	r9, r9, #0x400
 8010a2e: f10d 0b38    	add.w	r11, sp, #0x38
 8010a32: 230a         	movs	r3, #0xa
 8010a34: 465a         	mov	r2, r11
 8010a36: f009 ff1f    	bl	0x801a878 <__ultoa_invert> @ imm = #0x9e3e
 8010a3a: f019 0f40    	tst.w	r9, #0x40
 8010a3e: eba0 0b0b    	sub.w	r11, r0, r11
 8010a42: d065         	beq	0x8010b10 <vfprintf+0x848> @ imm = #0xca
 8010a44: f029 0201    	bic	r2, r9, #0x1
 8010a48: 455e         	cmp	r6, r11
 8010a4a: b292         	uxth	r2, r2
 8010a4c: f340 80b2    	ble.w	0x8010bb4 <vfprintf+0x8ec> @ imm = #0x164
 8010a50: 2f00         	cmp	r7, #0x0
 8010a52: f000 80a9    	beq.w	0x8010ba8 <vfprintf+0x8e0> @ imm = #0x152
 8010a56: f019 0310    	ands	r3, r9, #0x10
 8010a5a: 4634         	mov	r4, r6
 8010a5c: 4691         	mov	r9, r2
 8010a5e: d026         	beq	0x8010aae <vfprintf+0x7e6> @ imm = #0x4c
 8010a60: 3402         	adds	r4, #0x2
 8010a62: e05c         	b	0x8010b1e <vfprintf+0x856> @ imm = #0xb8
 8010a64: 1d1a         	adds	r2, r3, #0x4
 8010a66: 6818         	ldr	r0, [r3]
 8010a68: 920d         	str	r2, [sp, #0x34]
 8010a6a: 17c1         	asrs	r1, r0, #0x1f
 8010a6c: e7d4         	b	0x8010a18 <vfprintf+0x750> @ imm = #-0x58
 8010a6e: 1d1a         	adds	r2, r3, #0x4
 8010a70: f41b 7f80    	tst.w	r11, #0x100
 8010a74: 6819         	ldr	r1, [r3]
 8010a76: 920d         	str	r2, [sp, #0x34]
 8010a78: d101         	bne	0x8010a7e <vfprintf+0x7b6> @ imm = #0x2
 8010a7a: 4608         	mov	r0, r1
 8010a7c: e7f5         	b	0x8010a6a <vfprintf+0x7a2> @ imm = #-0x16
 8010a7e: f41b 7f00    	tst.w	r11, #0x200
 8010a82: bf15         	itete	ne
 8010a84: b248         	sxtbne	r0, r1
 8010a86: b208         	sxtheq	r0, r1
 8010a88: f341 11c0    	sbfxne	r1, r1, #0x7, #0x1
 8010a8c: f341 31c0    	sbfxeq	r1, r1, #0xf, #0x1
 8010a90: e7c2         	b	0x8010a18 <vfprintf+0x750> @ imm = #-0x7c
 8010a92: ea50 0301    	orrs.w	r3, r0, r1
 8010a96: d1ca         	bne	0x8010a2e <vfprintf+0x766> @ imm = #-0x6c
 8010a98: f01b 0f40    	tst.w	r11, #0x40
 8010a9c: d0c7         	beq	0x8010a2e <vfprintf+0x766> @ imm = #-0x72
 8010a9e: 2e00         	cmp	r6, #0x0
 8010aa0: d1c5         	bne	0x8010a2e <vfprintf+0x766> @ imm = #-0x76
 8010aa2: f02b 0b11    	bic	r11, r11, #0x11
 8010aa6: fa1f f98b    	uxth.w	r9, r11
 8010aaa: 4634         	mov	r4, r6
 8010aac: 46b3         	mov	r11, r6
 8010aae: f240 4306    	movw	r3, #0x406
 8010ab2: ea19 0303    	ands.w	r3, r9, r3
 8010ab6: bf1c         	itt	ne
 8010ab8: 3401         	addne	r4, #0x1
 8010aba: 2300         	movne	r3, #0x0
 8010abc: e02f         	b	0x8010b1e <vfprintf+0x856> @ imm = #0x5e
 8010abe: f02b 0b10    	bic	r11, r11, #0x10
 8010ac2: fa1f fb8b    	uxth.w	r11, r11
 8010ac6: 230a         	movs	r3, #0xa
 8010ac8: f01b 0480    	ands	r4, r11, #0x80
 8010acc: 9a0d         	ldr	r2, [sp, #0x34]
 8010ace: d057         	beq	0x8010b80 <vfprintf+0x8b8> @ imm = #0xae
 8010ad0: f41b 7100    	ands	r1, r11, #0x200
 8010ad4: bf1d         	ittte	ne
 8010ad6: 3207         	addne	r2, #0x7
 8010ad8: f022 0207    	bicne	r2, r2, #0x7
 8010adc: f102 0108    	addne.w	r1, r2, #0x8
 8010ae0: 1d10         	addeq	r0, r2, #0x4
 8010ae2: bf19         	ittee	ne
 8010ae4: 910d         	strne	r1, [sp, #0x34]
 8010ae6: e9d2 0100    	ldrdne	r0, r1, [r2]
 8010aea: 900d         	streq	r0, [sp, #0x34]
 8010aec: 6810         	ldreq	r0, [r2]
 8010aee: ea50 0201    	orrs.w	r2, r0, r1
 8010af2: d152         	bne	0x8010b9a <vfprintf+0x8d2> @ imm = #0xa4
 8010af4: f02b 0916    	bic	r9, r11, #0x16
 8010af8: f01b 0f40    	tst.w	r11, #0x40
 8010afc: fa1f f989    	uxth.w	r9, r9
 8010b00: d04f         	beq	0x8010ba2 <vfprintf+0x8da> @ imm = #0x9e
 8010b02: 2e00         	cmp	r6, #0x0
 8010b04: d14d         	bne	0x8010ba2 <vfprintf+0x8da> @ imm = #0x9a
 8010b06: f02b 0b17    	bic	r11, r11, #0x17
 8010b0a: fa1f f98b    	uxth.w	r9, r11
 8010b0e: 46b3         	mov	r11, r6
 8010b10: f019 0310    	ands	r3, r9, #0x10
 8010b14: d052         	beq	0x8010bbc <vfprintf+0x8f4> @ imm = #0xa4
 8010b16: 2f00         	cmp	r7, #0x0
 8010b18: d14e         	bne	0x8010bb8 <vfprintf+0x8f0> @ imm = #0x9c
 8010b1a: f10b 0401    	add.w	r4, r11, #0x1
 8010b1e: f019 0f08    	tst.w	r9, #0x8
 8010b22: d15e         	bne	0x8010be2 <vfprintf+0x91a> @ imm = #0xbc
 8010b24: f019 0f01    	tst.w	r9, #0x1
 8010b28: d006         	beq	0x8010b38 <vfprintf+0x870> @ imm = #0xc
 8010b2a: 45a2         	cmp	r10, r4
 8010b2c: dd6e         	ble	0x8010c0c <vfprintf+0x944> @ imm = #0xdc
 8010b2e: ebaa 0404    	sub.w	r4, r10, r4
 8010b32: eb04 060b    	add.w	r6, r4, r11
 8010b36: 4654         	mov	r4, r10
 8010b38: 4622         	mov	r2, r4
 8010b3a: e04d         	b	0x8010bd8 <vfprintf+0x910> @ imm = #0x9a
 8010b3c: f04b 0b10    	orr	r11, r11, #0x10
 8010b40: 2310         	movs	r3, #0x10
 8010b42: 2778         	movs	r7, #0x78
 8010b44: e7c0         	b	0x8010ac8 <vfprintf+0x800> @ imm = #-0x80
 8010b46: f1b9 0f78    	cmp.w	r9, #0x78
 8010b4a: d104         	bne	0x8010b56 <vfprintf+0x88e> @ imm = #0x8
 8010b4c: f1c7 0378    	rsb.w	r3, r7, #0x78
 8010b50: f043 0310    	orr	r3, r3, #0x10
 8010b54: e7b8         	b	0x8010ac8 <vfprintf+0x800> @ imm = #-0x90
 8010b56: 9b03         	ldr	r3, [sp, #0xc]
 8010b58: 4641         	mov	r1, r8
 8010b5a: 2025         	movs	r0, #0x25
 8010b5c: 4798         	blx	r3
 8010b5e: 2800         	cmp	r0, #0x0
 8010b60: f6ff abcf    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x862
 8010b64: 9b03         	ldr	r3, [sp, #0xc]
 8010b66: 4641         	mov	r1, r8
 8010b68: 4638         	mov	r0, r7
 8010b6a: 4798         	blx	r3
 8010b6c: 2800         	cmp	r0, #0x0
 8010b6e: f6ff abc8    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x870
 8010b72: 3502         	adds	r5, #0x2
 8010b74: 9b07         	ldr	r3, [sp, #0x1c]
 8010b76: f7ff bbb5    	b.w	0x80102e4 <vfprintf+0x1c> @ imm = #-0x896
 8010b7a: 2308         	movs	r3, #0x8
 8010b7c: 2700         	movs	r7, #0x0
 8010b7e: e7a3         	b	0x8010ac8 <vfprintf+0x800> @ imm = #-0xba
 8010b80: 1d11         	adds	r1, r2, #0x4
 8010b82: 910d         	str	r1, [sp, #0x34]
 8010b84: f41b 7180    	ands	r1, r11, #0x100
 8010b88: 6810         	ldr	r0, [r2]
 8010b8a: d0b0         	beq	0x8010aee <vfprintf+0x826> @ imm = #-0xa0
 8010b8c: f41b 7100    	ands	r1, r11, #0x200
 8010b90: bf1a         	itte	ne
 8010b92: b2c0         	uxtbne	r0, r0
 8010b94: 4621         	movne	r1, r4
 8010b96: b280         	uxtheq	r0, r0
 8010b98: e7a9         	b	0x8010aee <vfprintf+0x826> @ imm = #-0xae
 8010b9a: f02b 0b06    	bic	r11, r11, #0x6
 8010b9e: fa1f f98b    	uxth.w	r9, r11
 8010ba2: f10d 0b38    	add.w	r11, sp, #0x38
 8010ba6: e745         	b	0x8010a34 <vfprintf+0x76c> @ imm = #-0x176
 8010ba8: f029 0911    	bic	r9, r9, #0x11
 8010bac: fa1f f989    	uxth.w	r9, r9
 8010bb0: 4634         	mov	r4, r6
 8010bb2: e77c         	b	0x8010aae <vfprintf+0x7e6> @ imm = #-0x108
 8010bb4: 4691         	mov	r9, r2
 8010bb6: e7ab         	b	0x8010b10 <vfprintf+0x848> @ imm = #-0xaa
 8010bb8: 465c         	mov	r4, r11
 8010bba: e751         	b	0x8010a60 <vfprintf+0x798> @ imm = #-0x15e
 8010bbc: 465c         	mov	r4, r11
 8010bbe: e776         	b	0x8010aae <vfprintf+0x7e6> @ imm = #-0x114
 8010bc0: e9cd 2304    	strd	r2, r3, [sp, #16]
 8010bc4: 4641         	mov	r1, r8
 8010bc6: 9b03         	ldr	r3, [sp, #0xc]
 8010bc8: 2020         	movs	r0, #0x20
 8010bca: 4798         	blx	r3
 8010bcc: 2800         	cmp	r0, #0x0
 8010bce: f6ff ab98    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x8d0
 8010bd2: 9a04         	ldr	r2, [sp, #0x10]
 8010bd4: 9b05         	ldr	r3, [sp, #0x14]
 8010bd6: 3201         	adds	r2, #0x1
 8010bd8: 4592         	cmp	r10, r2
 8010bda: dcf1         	bgt	0x8010bc0 <vfprintf+0x8f8> @ imm = #-0x1e
 8010bdc: 1b2c         	subs	r4, r5, r4
 8010bde: 18a5         	adds	r5, r4, r2
 8010be0: 4614         	mov	r4, r2
 8010be2: b1f3         	cbz	r3, 0x8010c22 <vfprintf+0x95a> @ imm = #0x3c
 8010be4: 9b03         	ldr	r3, [sp, #0xc]
 8010be6: 4641         	mov	r1, r8
 8010be8: 2030         	movs	r0, #0x30
 8010bea: 4798         	blx	r3
 8010bec: 2800         	cmp	r0, #0x0
 8010bee: f6ff ab88    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x8f0
 8010bf2: b96f         	cbnz	r7, 0x8010c10 <vfprintf+0x948> @ imm = #0x1a
 8010bf4: 3501         	adds	r5, #0x1
 8010bf6: 46a9         	mov	r9, r5
 8010bf8: 442e         	add	r6, r5
 8010bfa: eba6 0309    	sub.w	r3, r6, r9
 8010bfe: 455b         	cmp	r3, r11
 8010c00: dc21         	bgt	0x8010c46 <vfprintf+0x97e> @ imm = #0x42
 8010c02: 465d         	mov	r5, r11
 8010c04: ae0e         	add	r6, sp, #0x38
 8010c06: bb5d         	cbnz	r5, 0x8010c60 <vfprintf+0x998> @ imm = #0x56
 8010c08: 44d9         	add	r9, r11
 8010c0a: e6c3         	b	0x8010994 <vfprintf+0x6cc> @ imm = #-0x27a
 8010c0c: 465e         	mov	r6, r11
 8010c0e: e793         	b	0x8010b38 <vfprintf+0x870> @ imm = #-0xda
 8010c10: 3502         	adds	r5, #0x2
 8010c12: 4641         	mov	r1, r8
 8010c14: 4638         	mov	r0, r7
 8010c16: 9b03         	ldr	r3, [sp, #0xc]
 8010c18: 4798         	blx	r3
 8010c1a: 2800         	cmp	r0, #0x0
 8010c1c: daeb         	bge	0x8010bf6 <vfprintf+0x92e> @ imm = #-0x2a
 8010c1e: f7ff bb70    	b.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x920
 8010c22: f240 4306    	movw	r3, #0x406
 8010c26: ea19 0f03    	tst.w	r9, r3
 8010c2a: d0e4         	beq	0x8010bf6 <vfprintf+0x92e> @ imm = #-0x38
 8010c2c: f019 0f02    	tst.w	r9, #0x2
 8010c30: bf14         	ite	ne
 8010c32: 202b         	movne	r0, #0x2b
 8010c34: 2020         	moveq	r0, #0x20
 8010c36: f419 6f80    	tst.w	r9, #0x400
 8010c3a: f105 0501    	add.w	r5, r5, #0x1
 8010c3e: 4641         	mov	r1, r8
 8010c40: bf18         	it	ne
 8010c42: 202d         	movne	r0, #0x2d
 8010c44: e7e7         	b	0x8010c16 <vfprintf+0x94e> @ imm = #-0x32
 8010c46: 9b03         	ldr	r3, [sp, #0xc]
 8010c48: 4641         	mov	r1, r8
 8010c4a: 2030         	movs	r0, #0x30
 8010c4c: 4798         	blx	r3
 8010c4e: 2800         	cmp	r0, #0x0
 8010c50: f109 0901    	add.w	r9, r9, #0x1
 8010c54: dad1         	bge	0x8010bfa <vfprintf+0x932> @ imm = #-0x5e
 8010c56: f7ff bb54    	b.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x958
 8010c5a: bf00         	nop

08010c5c <$d>:
 8010c5c: b9 da 01 08  	.word	0x0801dab9

08010c60 <$t>:
 8010c60: 3d01         	subs	r5, #0x1
 8010c62: 9b03         	ldr	r3, [sp, #0xc]
 8010c64: 5d70         	ldrb	r0, [r6, r5]
 8010c66: 4641         	mov	r1, r8
 8010c68: 4798         	blx	r3
 8010c6a: 2800         	cmp	r0, #0x0
 8010c6c: dacb         	bge	0x8010c06 <vfprintf+0x93e> @ imm = #-0x6a
 8010c6e: f7ff bb48    	b.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x970
 8010c72: 9b03         	ldr	r3, [sp, #0xc]
 8010c74: 4641         	mov	r1, r8
 8010c76: 2020         	movs	r0, #0x20
 8010c78: 4798         	blx	r3
 8010c7a: 2800         	cmp	r0, #0x0
 8010c7c: f105 0501    	add.w	r5, r5, #0x1
 8010c80: f6ff ab3f    	blt.w	0x8010302 <vfprintf+0x3a> @ imm = #-0x982
 8010c84: 1b63         	subs	r3, r4, r5
 8010c86: 2b00         	cmp	r3, #0x0
 8010c88: dcf3         	bgt	0x8010c72 <vfprintf+0x9aa> @ imm = #-0x1a
 8010c8a: e773         	b	0x8010b74 <vfprintf+0x8ac> @ imm = #-0x11a

08010c8c <div10>:
 8010c8c: b51f         	push	{r0, r1, r2, r3, r4, lr}
 8010c8e: ab02         	add	r3, sp, #0x8
 8010c90: 9300         	str	r3, [sp]
 8010c92: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8010cb0 <div10+0x24>
 8010c94: f04f 33cc    	mov.w	r3, #0xcccccccc
 8010c98: f009 fed1    	bl	0x801aa3e <__umul128>   @ imm = #0x9da2
 8010c9c: e9dd 0102    	ldrd	r0, r1, [sp, #8]
 8010ca0: 08c0         	lsrs	r0, r0, #0x3
 8010ca2: ea40 7041    	orr.w	r0, r0, r1, lsl #29
 8010ca6: 08c9         	lsrs	r1, r1, #0x3
 8010ca8: b005         	add	sp, #0x14
 8010caa: f85d fb04    	ldr	pc, [sp], #4
 8010cae: bf00         	nop

08010cb0 <$d>:
 8010cb0: cd cc cc cc  	.word	0xcccccccd

08010cb4 <__dtoa_engine>:
 8010cb4: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8010cb8: b09b         	sub	sp, #0x6c
 8010cba: 4604         	mov	r4, r0
 8010cbc: 9205         	str	r2, [sp, #0x14]
 8010cbe: 460a         	mov	r2, r1
 8010cc0: 930a         	str	r3, [sp, #0x28]
 8010cc2: f3c2 550a    	ubfx	r5, r2, #0x14, #0xb
 8010cc6: f89d 3090    	ldrb.w	r3, [sp, #0x90]
 8010cca: 930b         	str	r3, [sp, #0x2c]
 8010ccc: 0fd2         	lsrs	r2, r2, #0x1f
 8010cce: f3c1 0313    	ubfx	r3, r1, #0x0, #0x14
 8010cd2: 9209         	str	r2, [sp, #0x24]
 8010cd4: 0d09         	lsrs	r1, r1, #0x14
 8010cd6: b97d         	cbnz	r5, 0x8010cf8 <__dtoa_engine+0x44> @ imm = #0x1e
 8010cd8: ea50 0203    	orrs.w	r2, r0, r3
 8010cdc: d11b         	bne	0x8010d16 <__dtoa_engine+0x62> @ imm = #0x36
 8010cde: 9a05         	ldr	r2, [sp, #0x14]
 8010ce0: 2330         	movs	r3, #0x30
 8010ce2: 7153         	strb	r3, [r2, #0x5]
 8010ce4: 9b09         	ldr	r3, [sp, #0x24]
 8010ce6: 6015         	str	r5, [r2]
 8010ce8: f043 0302    	orr	r3, r3, #0x2
 8010cec: 7113         	strb	r3, [r2, #0x4]
 8010cee: 2701         	movs	r7, #0x1
 8010cf0: 4638         	mov	r0, r7
 8010cf2: b01b         	add	sp, #0x6c
 8010cf4: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8010cf8: f240 72ff    	movw	r2, #0x7ff
 8010cfc: 4295         	cmp	r5, r2
 8010cfe: d14a         	bne	0x8010d96 <__dtoa_engine+0xe2> @ imm = #0x94
 8010d00: 4303         	orrs	r3, r0
 8010d02: 9b09         	ldr	r3, [sp, #0x24]
 8010d04: 9a05         	ldr	r2, [sp, #0x14]
 8010d06: bf14         	ite	ne
 8010d08: f043 0308    	orrne	r3, r3, #0x8
 8010d0c: f043 0304    	orreq	r3, r3, #0x4
 8010d10: 7113         	strb	r3, [r2, #0x4]
 8010d12: 2700         	movs	r7, #0x0
 8010d14: e7ec         	b	0x8010cf0 <__dtoa_engine+0x3c> @ imm = #-0x28
 8010d16: f000 0201    	and	r2, r0, #0x1
 8010d1a: 9208         	str	r2, [sp, #0x20]
 8010d1c: ea4f 0883    	lsl.w	r8, r3, #0x2
 8010d20: 2201         	movs	r2, #0x1
 8010d22: 4dac         	ldr	r5, [pc, #0x2b0]        @ 0x8010fd4 <__dtoa_engine+0x320>
 8010d24: ea48 7890    	orr.w	r8, r8, r0, lsr #30
 8010d28: 0087         	lsls	r7, r0, #0x2
 8010d2a: 469a         	mov	r10, r3
 8010d2c: 4616         	mov	r6, r2
 8010d2e: f1c5 0b00    	rsb.w	r11, r5, #0x0
 8010d32: 4658         	mov	r0, r11
 8010d34: 9206         	str	r2, [sp, #0x18]
 8010d36: f000 fa11    	bl	0x801115c <__log10Pow5> @ imm = #0x422
 8010d3a: f1b5 3fff    	cmp.w	r5, #0xffffffff
 8010d3e: bfac         	ite	ge
 8010d40: 4681         	movge	r9, r0
 8010d42: f1a0 0901    	sublt.w	r9, r0, #0x1
 8010d46: ebab 0b09    	sub.w	r11, r11, r9
 8010d4a: eb09 0305    	add.w	r3, r9, r5
 8010d4e: 4658         	mov	r0, r11
 8010d50: 9304         	str	r3, [sp, #0x10]
 8010d52: f000 fa09    	bl	0x8011168 <__pow5bits>  @ imm = #0x412
 8010d56: a916         	add	r1, sp, #0x58
 8010d58: f1a0 057d    	sub.w	r5, r0, #0x7d
 8010d5c: 4658         	mov	r0, r11
 8010d5e: f000 fa23    	bl	0x80111a8 <__double_computePow5> @ imm = #0x446
 8010d62: ab12         	add	r3, sp, #0x48
 8010d64: 9a06         	ldr	r2, [sp, #0x18]
 8010d66: 9301         	str	r3, [sp, #0x4]
 8010d68: eba9 0505    	sub.w	r5, r9, r5
 8010d6c: ab10         	add	r3, sp, #0x40
 8010d6e: 9202         	str	r2, [sp, #0x8]
 8010d70: 9300         	str	r3, [sp]
 8010d72: 4620         	mov	r0, r4
 8010d74: 462b         	mov	r3, r5
 8010d76: aa16         	add	r2, sp, #0x58
 8010d78: 4651         	mov	r1, r10
 8010d7a: f009 fda5    	bl	0x801a8c8 <mulShiftAll64> @ imm = #0x9b4a
 8010d7e: f1b9 0f01    	cmp.w	r9, #0x1
 8010d82: 4604         	mov	r4, r0
 8010d84: 460d         	mov	r5, r1
 8010d86: f200 80d2    	bhi.w	0x8010f2e <__dtoa_engine+0x27a> @ imm = #0x1a4
 8010d8a: 9b08         	ldr	r3, [sp, #0x20]
 8010d8c: 2b00         	cmp	r3, #0x0
 8010d8e: f040 80c5    	bne.w	0x8010f1c <__dtoa_engine+0x268> @ imm = #0x18a
 8010d92: 2701         	movs	r7, #0x1
 8010d94: e06b         	b	0x8010e6e <__dtoa_engine+0x1ba> @ imm = #0xd6
 8010d96: f443 1a80    	orr	r10, r3, #0x100000
 8010d9a: f000 0201    	and	r2, r0, #0x1
 8010d9e: ea4f 088a    	lsl.w	r8, r10, #0x2
 8010da2: 4303         	orrs	r3, r0
 8010da4: f2a5 4535    	subw	r5, r5, #0x435
 8010da8: 9208         	str	r2, [sp, #0x20]
 8010daa: ea48 7890    	orr.w	r8, r8, r0, lsr #30
 8010dae: ea4f 0780    	lsl.w	r7, r0, #0x2
 8010db2: d149         	bne	0x8010e48 <__dtoa_engine+0x194> @ imm = #0x92
 8010db4: f240 73fe    	movw	r3, #0x7fe
 8010db8: 4219         	tst	r1, r3
 8010dba: bf0c         	ite	eq
 8010dbc: 2601         	moveq	r6, #0x1
 8010dbe: 2600         	movne	r6, #0x0
 8010dc0: 2d00         	cmp	r5, #0x0
 8010dc2: 4632         	mov	r2, r6
 8010dc4: dbb3         	blt	0x8010d2e <__dtoa_engine+0x7a> @ imm = #-0x9a
 8010dc6: 4628         	mov	r0, r5
 8010dc8: f000 f9c2    	bl	0x8011150 <__log10Pow2> @ imm = #0x384
 8010dcc: 2d03         	cmp	r5, #0x3
 8010dce: bfc8         	it	gt
 8010dd0: 3801         	subgt	r0, #0x1
 8010dd2: 9004         	str	r0, [sp, #0x10]
 8010dd4: f000 f9c8    	bl	0x8011168 <__pow5bits>  @ imm = #0x390
 8010dd8: 9b04         	ldr	r3, [sp, #0x10]
 8010dda: 307c         	adds	r0, #0x7c
 8010ddc: 1b5d         	subs	r5, r3, r5
 8010dde: 4405         	add	r5, r0
 8010de0: a916         	add	r1, sp, #0x58
 8010de2: 4618         	mov	r0, r3
 8010de4: f000 fa54    	bl	0x8011290 <__double_computeInvPow5> @ imm = #0x4a8
 8010de8: ab12         	add	r3, sp, #0x48
 8010dea: 9301         	str	r3, [sp, #0x4]
 8010dec: ab10         	add	r3, sp, #0x40
 8010dee: 9300         	str	r3, [sp]
 8010df0: 4620         	mov	r0, r4
 8010df2: 462b         	mov	r3, r5
 8010df4: 9602         	str	r6, [sp, #0x8]
 8010df6: aa16         	add	r2, sp, #0x58
 8010df8: 4651         	mov	r1, r10
 8010dfa: f009 fd65    	bl	0x801a8c8 <mulShiftAll64> @ imm = #0x9aca
 8010dfe: 9b04         	ldr	r3, [sp, #0x10]
 8010e00: 2b15         	cmp	r3, #0x15
 8010e02: 4604         	mov	r4, r0
 8010e04: 460d         	mov	r5, r1
 8010e06: f200 8086    	bhi.w	0x8010f16 <__dtoa_engine+0x262> @ imm = #0x10c
 8010e0a: ab14         	add	r3, sp, #0x50
 8010e0c: 4a72         	ldr	r2, [pc, #0x1c8]        @ 0x8010fd8 <__dtoa_engine+0x324>
 8010e0e: 9300         	str	r3, [sp]
 8010e10: 4638         	mov	r0, r7
 8010e12: f04f 33cc    	mov.w	r3, #0xcccccccc
 8010e16: 4641         	mov	r1, r8
 8010e18: f009 fe11    	bl	0x801aa3e <__umul128>   @ imm = #0x9c22
 8010e1c: 9b14         	ldr	r3, [sp, #0x50]
 8010e1e: 9a15         	ldr	r2, [sp, #0x54]
 8010e20: 089b         	lsrs	r3, r3, #0x2
 8010e22: ea43 7382    	orr.w	r3, r3, r2, lsl #30
 8010e26: eb03 0383    	add.w	r3, r3, r3, lsl #2
 8010e2a: 42bb         	cmp	r3, r7
 8010e2c: e9dd 9a10    	ldrd	r9, r10, [sp, #64]
 8010e30: d10c         	bne	0x8010e4c <__dtoa_engine+0x198> @ imm = #0x18
 8010e32: 4638         	mov	r0, r7
 8010e34: 4641         	mov	r1, r8
 8010e36: f000 f99f    	bl	0x8011178 <__pow5Factor> @ imm = #0x33e
 8010e3a: 9b04         	ldr	r3, [sp, #0x10]
 8010e3c: 4283         	cmp	r3, r0
 8010e3e: bf8c         	ite	hi
 8010e40: 2700         	movhi	r7, #0x0
 8010e42: 2701         	movls	r7, #0x1
 8010e44: 2600         	movs	r6, #0x0
 8010e46: e012         	b	0x8010e6e <__dtoa_engine+0x1ba> @ imm = #0x24
 8010e48: 2601         	movs	r6, #0x1
 8010e4a: e7b9         	b	0x8010dc0 <__dtoa_engine+0x10c> @ imm = #-0x8e
 8010e4c: 9b08         	ldr	r3, [sp, #0x20]
 8010e4e: 2b00         	cmp	r3, #0x0
 8010e50: d151         	bne	0x8010ef6 <__dtoa_engine+0x242> @ imm = #0xa2
 8010e52: 3f01         	subs	r7, #0x1
 8010e54: f148 31ff    	adc	r1, r8, #0xffffffff
 8010e58: 1bb8         	subs	r0, r7, r6
 8010e5a: f161 0100    	sbc	r1, r1, #0x0
 8010e5e: f000 f98b    	bl	0x8011178 <__pow5Factor> @ imm = #0x316
 8010e62: 9b04         	ldr	r3, [sp, #0x10]
 8010e64: 9f08         	ldr	r7, [sp, #0x20]
 8010e66: 4283         	cmp	r3, r0
 8010e68: bf8c         	ite	hi
 8010e6a: 2600         	movhi	r6, #0x0
 8010e6c: 2601         	movls	r6, #0x1
 8010e6e: 9b0b         	ldr	r3, [sp, #0x2c]
 8010e70: 2b00         	cmp	r3, #0x0
 8010e72: f040 8091    	bne.w	0x8010f98 <__dtoa_engine+0x2e4> @ imm = #0x122
 8010e76: f8dd b028    	ldr.w	r11, [sp, #0x28]
 8010e7a: f04f 0800    	mov.w	r8, #0x0
 8010e7e: e9cd 8806    	strd	r8, r8, [sp, #24]
 8010e82: f04f 0a0a    	mov.w	r10, #0xa
 8010e86: e9dd 0110    	ldrd	r0, r1, [sp, #64]
 8010e8a: f7ff feff    	bl	0x8010c8c <div10>       @ imm = #-0x202
 8010e8e: 9b12         	ldr	r3, [sp, #0x48]
 8010e90: 930e         	str	r3, [sp, #0x38]
 8010e92: e9cd 010c    	strd	r0, r1, [sp, #48]
 8010e96: 4618         	mov	r0, r3
 8010e98: 9913         	ldr	r1, [sp, #0x4c]
 8010e9a: f7ff fef7    	bl	0x8010c8c <div10>       @ imm = #-0x212
 8010e9e: 9b0c         	ldr	r3, [sp, #0x30]
 8010ea0: 9a0d         	ldr	r2, [sp, #0x34]
 8010ea2: 910f         	str	r1, [sp, #0x3c]
 8010ea4: 4298         	cmp	r0, r3
 8010ea6: 460b         	mov	r3, r1
 8010ea8: 4193         	sbcs	r3, r2
 8010eaa: 4681         	mov	r9, r0
 8010eac: f080 808e    	bhs.w	0x8010fcc <__dtoa_engine+0x318> @ imm = #0x11c
 8010eb0: 4620         	mov	r0, r4
 8010eb2: 4629         	mov	r1, r5
 8010eb4: f7ff feea    	bl	0x8010c8c <div10>       @ imm = #-0x22c
 8010eb8: 9a0e         	ldr	r2, [sp, #0x38]
 8010eba: fb0a f309    	mul	r3, r10, r9
 8010ebe: 4293         	cmp	r3, r2
 8010ec0: bf14         	ite	ne
 8010ec2: 2600         	movne	r6, #0x0
 8010ec4: f006 0601    	andeq	r6, r6, #0x1
 8010ec8: 9b0c         	ldr	r3, [sp, #0x30]
 8010eca: 9310         	str	r3, [sp, #0x40]
 8010ecc: 9b0d         	ldr	r3, [sp, #0x34]
 8010ece: e9cd 3911    	strd	r3, r9, [sp, #68]
 8010ed2: 9b0f         	ldr	r3, [sp, #0x3c]
 8010ed4: 9313         	str	r3, [sp, #0x4c]
 8010ed6: 9b07         	ldr	r3, [sp, #0x1c]
 8010ed8: f1b8 0f00    	cmp.w	r8, #0x0
 8010edc: bf14         	ite	ne
 8010ede: 2700         	movne	r7, #0x0
 8010ee0: f007 0701    	andeq	r7, r7, #0x1
 8010ee4: 3301         	adds	r3, #0x1
 8010ee6: fb0a 4810    	mls	r8, r10, r0, r4
 8010eea: fa5f f888    	uxtb.w	r8, r8
 8010eee: 9307         	str	r3, [sp, #0x1c]
 8010ef0: 4604         	mov	r4, r0
 8010ef2: 460d         	mov	r5, r1
 8010ef4: e7c7         	b	0x8010e86 <__dtoa_engine+0x1d2> @ imm = #-0x72
 8010ef6: 1cb8         	adds	r0, r7, #0x2
 8010ef8: f148 0100    	adc	r1, r8, #0x0
 8010efc: f000 f93c    	bl	0x8011178 <__pow5Factor> @ imm = #0x278
 8010f00: 9b04         	ldr	r3, [sp, #0x10]
 8010f02: 4283         	cmp	r3, r0
 8010f04: bf8c         	ite	hi
 8010f06: 2000         	movhi	r0, #0x0
 8010f08: 2001         	movls	r0, #0x1
 8010f0a: ebb9 0000    	subs.w	r0, r9, r0
 8010f0e: f16a 0200    	sbc	r2, r10, #0x0
 8010f12: e9cd 0210    	strd	r0, r2, [sp, #64]
 8010f16: 2700         	movs	r7, #0x0
 8010f18: 463e         	mov	r6, r7
 8010f1a: e7a8         	b	0x8010e6e <__dtoa_engine+0x1ba> @ imm = #-0xb0
 8010f1c: 9b10         	ldr	r3, [sp, #0x40]
 8010f1e: 9a11         	ldr	r2, [sp, #0x44]
 8010f20: 3b01         	subs	r3, #0x1
 8010f22: f142 32ff    	adc	r2, r2, #0xffffffff
 8010f26: e9cd 3210    	strd	r3, r2, [sp, #64]
 8010f2a: 2701         	movs	r7, #0x1
 8010f2c: e78a         	b	0x8010e44 <__dtoa_engine+0x190> @ imm = #-0xec
 8010f2e: f1b9 0f3e    	cmp.w	r9, #0x3e
 8010f32: d8f0         	bhi	0x8010f16 <__dtoa_engine+0x262> @ imm = #-0x20
 8010f34: f04f 33ff    	mov.w	r3, #0xffffffff
 8010f38: f1a9 0020    	sub.w	r0, r9, #0x20
 8010f3c: fa03 f209    	lsl.w	r2, r3, r9
 8010f40: fa03 f000    	lsl.w	r0, r3, r0
 8010f44: f1c9 0120    	rsb.w	r1, r9, #0x20
 8010f48: fa23 f101    	lsr.w	r1, r3, r1
 8010f4c: 4302         	orrs	r2, r0
 8010f4e: 430a         	orrs	r2, r1
 8010f50: fa03 f309    	lsl.w	r3, r3, r9
 8010f54: ea27 0703    	bic.w	r7, r7, r3
 8010f58: ea28 0802    	bic.w	r8, r8, r2
 8010f5c: ea57 0708    	orrs.w	r7, r7, r8
 8010f60: bf0c         	ite	eq
 8010f62: 2701         	moveq	r7, #0x1
 8010f64: 2700         	movne	r7, #0x0
 8010f66: e76d         	b	0x8010e44 <__dtoa_engine+0x190> @ imm = #-0x126
 8010f68: fb00 fc02    	mul	r12, r0, r2
 8010f6c: fba1 1200    	umull	r1, r2, r1, r0
 8010f70: 3301         	adds	r3, #0x1
 8010f72: 4462         	add	r2, r12
 8010f74: 428c         	cmp	r4, r1
 8010f76: eb75 0c02    	sbcs.w	r12, r5, r2
 8010f7a: d2f5         	bhs	0x8010f68 <__dtoa_engine+0x2b4> @ imm = #-0x16
 8010f7c: 9a04         	ldr	r2, [sp, #0x10]
 8010f7e: f8dd b028    	ldr.w	r11, [sp, #0x28]
 8010f82: 4413         	add	r3, r2
 8010f84: 9a25         	ldr	r2, [sp, #0x94]
 8010f86: 4413         	add	r3, r2
 8010f88: 0fd2         	lsrs	r2, r2, #0x1f
 8010f8a: 4293         	cmp	r3, r2
 8010f8c: bfb8         	it	lt
 8010f8e: 4613         	movlt	r3, r2
 8010f90: 459b         	cmp	r11, r3
 8010f92: bfa8         	it	ge
 8010f94: 469b         	movge	r11, r3
 8010f96: e770         	b	0x8010e7a <__dtoa_engine+0x1c6> @ imm = #-0x120
 8010f98: 210a         	movs	r1, #0xa
 8010f9a: 2200         	movs	r2, #0x0
 8010f9c: 2301         	movs	r3, #0x1
 8010f9e: 4608         	mov	r0, r1
 8010fa0: e7e8         	b	0x8010f74 <__dtoa_engine+0x2c0> @ imm = #-0x30
 8010fa2: fb0a f003    	mul	r0, r10, r3
 8010fa6: fba2 230a    	umull	r2, r3, r2, r10
 8010faa: 3101         	adds	r1, #0x1
 8010fac: 4403         	add	r3, r0
 8010fae: 4294         	cmp	r4, r2
 8010fb0: eb75 0003    	sbcs.w	r0, r5, r3
 8010fb4: d2f5         	bhs	0x8010fa2 <__dtoa_engine+0x2ee> @ imm = #-0x16
 8010fb6: 4559         	cmp	r1, r11
 8010fb8: dd10         	ble	0x8010fdc <__dtoa_engine+0x328> @ imm = #0x20
 8010fba: f1bb 0f00    	cmp.w	r11, #0x0
 8010fbe: d102         	bne	0x8010fc6 <__dtoa_engine+0x312> @ imm = #0x4
 8010fc0: ea54 0305    	orrs.w	r3, r4, r5
 8010fc4: d00a         	beq	0x8010fdc <__dtoa_engine+0x328> @ imm = #0x14
 8010fc6: 2301         	movs	r3, #0x1
 8010fc8: 9306         	str	r3, [sp, #0x18]
 8010fca: e771         	b	0x8010eb0 <__dtoa_engine+0x1fc> @ imm = #-0x11e
 8010fcc: 220a         	movs	r2, #0xa
 8010fce: 2300         	movs	r3, #0x0
 8010fd0: 2101         	movs	r1, #0x1
 8010fd2: e7ec         	b	0x8010fae <__dtoa_engine+0x2fa> @ imm = #-0x28

08010fd4 <$d>:
 8010fd4: cc fb ff ff  	.word	0xfffffbcc
 8010fd8: cd cc cc cc  	.word	0xcccccccd

08010fdc <$t>:
 8010fdc: 2e00         	cmp	r6, #0x0
 8010fde: d02f         	beq	0x8011040 <__dtoa_engine+0x38c> @ imm = #0x5e
 8010fe0: f04f 0a0a    	mov.w	r10, #0xa
 8010fe4: 9b12         	ldr	r3, [sp, #0x48]
 8010fe6: 9913         	ldr	r1, [sp, #0x4c]
 8010fe8: 930d         	str	r3, [sp, #0x34]
 8010fea: 4618         	mov	r0, r3
 8010fec: f7ff fe4e    	bl	0x8010c8c <div10>       @ imm = #-0x364
 8010ff0: 9b0d         	ldr	r3, [sp, #0x34]
 8010ff2: 910c         	str	r1, [sp, #0x30]
 8010ff4: fb0a f200    	mul	r2, r10, r0
 8010ff8: 429a         	cmp	r2, r3
 8010ffa: 4681         	mov	r9, r0
 8010ffc: d120         	bne	0x8011040 <__dtoa_engine+0x38c> @ imm = #0x40
 8010ffe: e9dd 0110    	ldrd	r0, r1, [sp, #64]
 8011002: f7ff fe43    	bl	0x8010c8c <div10>       @ imm = #-0x37a
 8011006: 900e         	str	r0, [sp, #0x38]
 8011008: 910d         	str	r1, [sp, #0x34]
 801100a: 4620         	mov	r0, r4
 801100c: 4629         	mov	r1, r5
 801100e: f7ff fe3d    	bl	0x8010c8c <div10>       @ imm = #-0x386
 8011012: 9b0d         	ldr	r3, [sp, #0x34]
 8011014: 9a0e         	ldr	r2, [sp, #0x38]
 8011016: 9210         	str	r2, [sp, #0x40]
 8011018: e9cd 3911    	strd	r3, r9, [sp, #68]
 801101c: 9b0c         	ldr	r3, [sp, #0x30]
 801101e: 9313         	str	r3, [sp, #0x4c]
 8011020: 9b07         	ldr	r3, [sp, #0x1c]
 8011022: f1b8 0f00    	cmp.w	r8, #0x0
 8011026: bf14         	ite	ne
 8011028: 2700         	movne	r7, #0x0
 801102a: f007 0701    	andeq	r7, r7, #0x1
 801102e: 3301         	adds	r3, #0x1
 8011030: fb0a 4810    	mls	r8, r10, r0, r4
 8011034: fa5f f888    	uxtb.w	r8, r8
 8011038: 9307         	str	r3, [sp, #0x1c]
 801103a: 4604         	mov	r4, r0
 801103c: 460d         	mov	r5, r1
 801103e: e7d1         	b	0x8010fe4 <__dtoa_engine+0x330> @ imm = #-0x5e
 8011040: f8dd 9010    	ldr.w	r9, [sp, #0x10]
 8011044: 9b07         	ldr	r3, [sp, #0x1c]
 8011046: 4499         	add	r9, r3
 8011048: 2f00         	cmp	r7, #0x0
 801104a: d05a         	beq	0x8011102 <__dtoa_engine+0x44e> @ imm = #0xb4
 801104c: f1b8 0f05    	cmp.w	r8, #0x5
 8011050: d157         	bne	0x8011102 <__dtoa_engine+0x44e> @ imm = #0xae
 8011052: f014 0301    	ands	r3, r4, #0x1
 8011056: d14a         	bne	0x80110ee <__dtoa_engine+0x43a> @ imm = #0x94
 8011058: 9a06         	ldr	r2, [sp, #0x18]
 801105a: b932         	cbnz	r2, 0x801106a <__dtoa_engine+0x3b6> @ imm = #0xc
 801105c: e9dd 2312    	ldrd	r2, r3, [sp, #72]
 8011060: 429d         	cmp	r5, r3
 8011062: bf08         	it	eq
 8011064: 4294         	cmpeq	r4, r2
 8011066: d05f         	beq	0x8011128 <__dtoa_engine+0x474> @ imm = #0xbe
 8011068: 9b06         	ldr	r3, [sp, #0x18]
 801106a: 1918         	adds	r0, r3, r4
 801106c: f04f 040a    	mov.w	r4, #0xa
 8011070: f145 0100    	adc	r1, r5, #0x0
 8011074: 2200         	movs	r2, #0x0
 8011076: 2601         	movs	r6, #0x1
 8011078: 4625         	mov	r5, r4
 801107a: 42a0         	cmp	r0, r4
 801107c: eb71 0702    	sbcs.w	r7, r1, r2
 8011080: d255         	bhs	0x801112e <__dtoa_engine+0x47a> @ imm = #0xaa
 8011082: b1eb         	cbz	r3, 0x80110c0 <__dtoa_engine+0x40c> @ imm = #0x3a
 8011084: 45b3         	cmp	r11, r6
 8011086: da1b         	bge	0x80110c0 <__dtoa_engine+0x40c> @ imm = #0x36
 8011088: 9b0b         	ldr	r3, [sp, #0x2c]
 801108a: b16b         	cbz	r3, 0x80110a8 <__dtoa_engine+0x3f4> @ imm = #0x1a
 801108c: 9a25         	ldr	r2, [sp, #0x94]
 801108e: f8dd b028    	ldr.w	r11, [sp, #0x28]
 8011092: eb06 0309    	add.w	r3, r6, r9
 8011096: 4413         	add	r3, r2
 8011098: 2b01         	cmp	r3, #0x1
 801109a: bfb8         	it	lt
 801109c: 2301         	movlt	r3, #0x1
 801109e: 459b         	cmp	r11, r3
 80110a0: bfa8         	it	ge
 80110a2: 469b         	movge	r11, r3
 80110a4: 455e         	cmp	r6, r11
 80110a6: dd0b         	ble	0x80110c0 <__dtoa_engine+0x40c> @ imm = #0x16
 80110a8: 3005         	adds	r0, #0x5
 80110aa: f04f 020a    	mov.w	r2, #0xa
 80110ae: f04f 0300    	mov.w	r3, #0x0
 80110b2: f141 0100    	adc	r1, r1, #0x0
 80110b6: f7ef fd1d    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x105c6
 80110ba: f109 0901    	add.w	r9, r9, #0x1
 80110be: 3e01         	subs	r6, #0x1
 80110c0: 455e         	cmp	r6, r11
 80110c2: bfa8         	it	ge
 80110c4: 465e         	movge	r6, r11
 80110c6: b237         	sxth	r7, r6
 80110c8: fa0f f989    	sxth.w	r9, r9
 80110cc: 9b05         	ldr	r3, [sp, #0x14]
 80110ce: fa09 f686    	sxtah	r6, r9, r6
 80110d2: f107 0805    	add.w	r8, r7, #0x5
 80110d6: 3e01         	subs	r6, #0x1
 80110d8: 4498         	add	r8, r3
 80110da: f04f 0900    	mov.w	r9, #0x0
 80110de: 45b9         	cmp	r9, r7
 80110e0: db2c         	blt	0x801113c <__dtoa_engine+0x488> @ imm = #0x58
 80110e2: 9b05         	ldr	r3, [sp, #0x14]
 80110e4: 461a         	mov	r2, r3
 80110e6: 601e         	str	r6, [r3]
 80110e8: 9b09         	ldr	r3, [sp, #0x24]
 80110ea: 7113         	strb	r3, [r2, #0x4]
 80110ec: e600         	b	0x8010cf0 <__dtoa_engine+0x3c> @ imm = #-0x400
 80110ee: 9b06         	ldr	r3, [sp, #0x18]
 80110f0: b92b         	cbnz	r3, 0x80110fe <__dtoa_engine+0x44a> @ imm = #0xa
 80110f2: e9dd 2312    	ldrd	r2, r3, [sp, #72]
 80110f6: 429d         	cmp	r5, r3
 80110f8: bf08         	it	eq
 80110fa: 4294         	cmpeq	r4, r2
 80110fc: d009         	beq	0x8011112 <__dtoa_engine+0x45e> @ imm = #0x12
 80110fe: 2301         	movs	r3, #0x1
 8011100: e7b3         	b	0x801106a <__dtoa_engine+0x3b6> @ imm = #-0x9a
 8011102: 9b06         	ldr	r3, [sp, #0x18]
 8011104: b953         	cbnz	r3, 0x801111c <__dtoa_engine+0x468> @ imm = #0x14
 8011106: e9dd 2312    	ldrd	r2, r3, [sp, #72]
 801110a: 429d         	cmp	r5, r3
 801110c: bf08         	it	eq
 801110e: 4294         	cmpeq	r4, r2
 8011110: d104         	bne	0x801111c <__dtoa_engine+0x468> @ imm = #0x8
 8011112: 9b08         	ldr	r3, [sp, #0x20]
 8011114: 2b00         	cmp	r3, #0x0
 8011116: d1f2         	bne	0x80110fe <__dtoa_engine+0x44a> @ imm = #-0x1c
 8011118: 2e00         	cmp	r6, #0x0
 801111a: d0f0         	beq	0x80110fe <__dtoa_engine+0x44a> @ imm = #-0x20
 801111c: f1b8 0f04    	cmp.w	r8, #0x4
 8011120: bf94         	ite	ls
 8011122: 2300         	movls	r3, #0x0
 8011124: 2301         	movhi	r3, #0x1
 8011126: e7a0         	b	0x801106a <__dtoa_engine+0x3b6> @ imm = #-0xc0
 8011128: f04f 0804    	mov.w	r8, #0x4
 801112c: e7f1         	b	0x8011112 <__dtoa_engine+0x45e> @ imm = #-0x1e
 801112e: fb05 f702    	mul	r7, r5, r2
 8011132: fba4 4205    	umull	r4, r2, r4, r5
 8011136: 3601         	adds	r6, #0x1
 8011138: 443a         	add	r2, r7
 801113a: e79e         	b	0x801107a <__dtoa_engine+0x3c6> @ imm = #-0xc4
 801113c: 220a         	movs	r2, #0xa
 801113e: 2300         	movs	r3, #0x0
 8011140: f7ef fcd8    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x10650
 8011144: 3230         	adds	r2, #0x30
 8011146: f808 2d01    	strb	r2, [r8, #-1]!
 801114a: f109 0901    	add.w	r9, r9, #0x1
 801114e: e7c6         	b	0x80110de <__dtoa_engine+0x42a> @ imm = #-0x74

08011150 <__log10Pow2>:
 8011150: 4b01         	ldr	r3, [pc, #0x4]          @ 0x8011158 <__log10Pow2+0x8>
 8011152: 4358         	muls	r0, r3, r0
 8011154: 0c80         	lsrs	r0, r0, #0x12
 8011156: 4770         	bx	lr

08011158 <$d>:
 8011158: 41 34 01 00  	.word	0x00013441

0801115c <__log10Pow5>:
 801115c: 4b01         	ldr	r3, [pc, #0x4]          @ 0x8011164 <__log10Pow5+0x8>
 801115e: 4358         	muls	r0, r3, r0
 8011160: 0d00         	lsrs	r0, r0, #0x14
 8011162: 4770         	bx	lr

08011164 <$d>:
 8011164: fb 2e 0b 00  	.word	0x000b2efb

08011168 <__pow5bits>:
 8011168: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8011174 <__pow5bits+0xc>
 801116a: 4358         	muls	r0, r3, r0
 801116c: 0cc0         	lsrs	r0, r0, #0x13
 801116e: 3001         	adds	r0, #0x1
 8011170: 4770         	bx	lr
 8011172: bf00         	nop

08011174 <$d>:
 8011174: 4f 93 12 00  	.word	0x0012934f

08011178 <__pow5Factor>:
 8011178: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80111a4 <__pow5Factor+0x2c>
 801117a: b570         	push	{r4, r5, r6, lr}
 801117c: 4603         	mov	r3, r0
 801117e: f04f 36cc    	mov.w	r6, #0xcccccccc
 8011182: 2000         	movs	r0, #0x0
 8011184: f04f 3533    	mov.w	r5, #0x33333333
 8011188: fb06 f403    	mul	r4, r6, r3
 801118c: fb02 4401    	mla	r4, r2, r1, r4
 8011190: fba3 3102    	umull	r3, r1, r3, r2
 8011194: 4421         	add	r1, r4
 8011196: 429d         	cmp	r5, r3
 8011198: eb75 0401    	sbcs.w	r4, r5, r1
 801119c: d301         	blo	0x80111a2 <__pow5Factor+0x2a> @ imm = #0x2
 801119e: 3001         	adds	r0, #0x1
 80111a0: e7f2         	b	0x8011188 <__pow5Factor+0x10> @ imm = #-0x1c
 80111a2: bd70         	pop	{r4, r5, r6, pc}

080111a4 <$d>:
 80111a4: cd cc cc cc  	.word	0xcccccccd

080111a8 <__double_computePow5>:
 80111a8: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80111ac: 231a         	movs	r3, #0x1a
 80111ae: 4e35         	ldr	r6, [pc, #0xd4]         @ 0x8011284 <__double_computePow5+0xdc>
 80111b0: fbb0 faf3    	udiv	r10, r0, r3
 80111b4: fb03 031a    	mls	r3, r3, r10, r0
 80111b8: b089         	sub	sp, #0x24
 80111ba: 4604         	mov	r4, r0
 80111bc: 460d         	mov	r5, r1
 80111be: eb06 160a    	add.w	r6, r6, r10, lsl #4
 80111c2: b953         	cbnz	r3, 0x80111da <__double_computePow5+0x32> @ imm = #0x14
 80111c4: e9d6 2300    	ldrd	r2, r3, [r6]
 80111c8: e9c1 2300    	strd	r2, r3, [r1]
 80111cc: e9d6 0102    	ldrd	r0, r1, [r6, #8]
 80111d0: e9c5 0102    	strd	r0, r1, [r5, #8]
 80111d4: b009         	add	sp, #0x24
 80111d6: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80111da: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x8011288 <__double_computePow5+0xe0>
 80111dc: eb02 03c3    	add.w	r3, r2, r3, lsl #3
 80111e0: e9d3 8900    	ldrd	r8, r9, [r3]
 80111e4: ab04         	add	r3, sp, #0x10
 80111e6: 9300         	str	r3, [sp]
 80111e8: e9d6 2302    	ldrd	r2, r3, [r6, #8]
 80111ec: 4640         	mov	r0, r8
 80111ee: 4649         	mov	r1, r9
 80111f0: f009 fc25    	bl	0x801aa3e <__umul128>   @ imm = #0x984a
 80111f4: ab06         	add	r3, sp, #0x18
 80111f6: 9300         	str	r3, [sp]
 80111f8: e9d6 2300    	ldrd	r2, r3, [r6]
 80111fc: 4683         	mov	r11, r0
 80111fe: 460f         	mov	r7, r1
 8011200: 4640         	mov	r0, r8
 8011202: 4649         	mov	r1, r9
 8011204: f009 fc1b    	bl	0x801aa3e <__umul128>   @ imm = #0x9836
 8011208: e9dd 6206    	ldrd	r6, r2, [sp, #24]
 801120c: eb16 060b    	adds.w	r6, r6, r11
 8011210: eb52 0807    	adcs.w	r8, r2, r7
 8011214: f04f 0300    	mov.w	r3, #0x0
 8011218: bf28         	it	hs
 801121a: 2301         	movhs	r3, #0x1
 801121c: 4681         	mov	r9, r0
 801121e: b133         	cbz	r3, 0x801122e <__double_computePow5+0x86> @ imm = #0xc
 8011220: 9b04         	ldr	r3, [sp, #0x10]
 8011222: 9a05         	ldr	r2, [sp, #0x14]
 8011224: 3301         	adds	r3, #0x1
 8011226: f142 0200    	adc	r2, r2, #0x0
 801122a: e9cd 3204    	strd	r3, r2, [sp, #16]
 801122e: 4620         	mov	r0, r4
 8011230: 9103         	str	r1, [sp, #0xc]
 8011232: f7ff ff99    	bl	0x8011168 <__pow5bits>  @ imm = #-0xce
 8011236: 4607         	mov	r7, r0
 8011238: 201a         	movs	r0, #0x1a
 801123a: fb00 f00a    	mul	r0, r0, r10
 801123e: f7ff ff93    	bl	0x8011168 <__pow5bits>  @ imm = #-0xda
 8011242: 1a3f         	subs	r7, r7, r0
 8011244: 4632         	mov	r2, r6
 8011246: 4643         	mov	r3, r8
 8011248: 9903         	ldr	r1, [sp, #0xc]
 801124a: 9700         	str	r7, [sp]
 801124c: 4648         	mov	r0, r9
 801124e: f009 fc11    	bl	0x801aa74 <__shiftright128> @ imm = #0x9822
 8011252: ea4f 1c14    	lsr.w	r12, r4, #0x4
 8011256: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x801128c <__double_computePow5+0xe4>
 8011258: 0064         	lsls	r4, r4, #0x1
 801125a: f004 031e    	and	r3, r4, #0x1e
 801125e: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 8011262: 40dc         	lsrs	r4, r3
 8011264: f004 0403    	and	r4, r4, #0x3
 8011268: 1824         	adds	r4, r4, r0
 801126a: f141 0100    	adc	r1, r1, #0x0
 801126e: e9c5 4100    	strd	r4, r1, [r5]
 8011272: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 8011276: 9700         	str	r7, [sp]
 8011278: 4630         	mov	r0, r6
 801127a: 4641         	mov	r1, r8
 801127c: f009 fbfa    	bl	0x801aa74 <__shiftright128> @ imm = #0x97f4
 8011280: e7a6         	b	0x80111d0 <__double_computePow5+0x28> @ imm = #-0xb4
 8011282: bf00         	nop

08011284 <$d>:
 8011284: 40 ce 01 08  	.word	0x0801ce40
 8011288: 70 cd 01 08  	.word	0x0801cd70
 801128c: 08 d9 01 08  	.word	0x0801d908

08011290 <__double_computeInvPow5>:
 8011290: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8011294: 271a         	movs	r7, #0x1a
 8011296: f8df a0e4    	ldr.w	r10, [pc, #0xe4]        @ 0x801137c <__double_computeInvPow5+0xec>
 801129a: f100 0519    	add.w	r5, r0, #0x19
 801129e: fbb5 f5f7    	udiv	r5, r5, r7
 80112a2: 436f         	muls	r7, r5, r7
 80112a4: 1a3a         	subs	r2, r7, r0
 80112a6: ea4f 1b05    	lsl.w	r11, r5, #0x4
 80112aa: b089         	sub	sp, #0x24
 80112ac: 4604         	mov	r4, r0
 80112ae: 460e         	mov	r6, r1
 80112b0: eb0a 1505    	add.w	r5, r10, r5, lsl #4
 80112b4: d10a         	bne	0x80112cc <__double_computeInvPow5+0x3c> @ imm = #0x14
 80112b6: e9d5 2300    	ldrd	r2, r3, [r5]
 80112ba: e9c1 2300    	strd	r2, r3, [r1]
 80112be: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 80112c2: e9c6 0102    	strd	r0, r1, [r6, #8]
 80112c6: b009         	add	sp, #0x24
 80112c8: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80112cc: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8011380 <__double_computeInvPow5+0xf0>
 80112ce: eb03 03c2    	add.w	r3, r3, r2, lsl #3
 80112d2: e9d3 8900    	ldrd	r8, r9, [r3]
 80112d6: ab04         	add	r3, sp, #0x10
 80112d8: 9300         	str	r3, [sp]
 80112da: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 80112de: 4640         	mov	r0, r8
 80112e0: 4649         	mov	r1, r9
 80112e2: f009 fbac    	bl	0x801aa3e <__umul128>   @ imm = #0x9758
 80112e6: f85a 200b    	ldr.w	r2, [r10, r11]
 80112ea: 686b         	ldr	r3, [r5, #0x4]
 80112ec: 3a01         	subs	r2, #0x1
 80112ee: e9cd 0102    	strd	r0, r1, [sp, #8]
 80112f2: a906         	add	r1, sp, #0x18
 80112f4: f163 0300    	sbc	r3, r3, #0x0
 80112f8: 9100         	str	r1, [sp]
 80112fa: 4640         	mov	r0, r8
 80112fc: 4649         	mov	r1, r9
 80112fe: f009 fb9e    	bl	0x801aa3e <__umul128>   @ imm = #0x973c
 8011302: e9dd 5206    	ldrd	r5, r2, [sp, #24]
 8011306: 468a         	mov	r10, r1
 8011308: 9902         	ldr	r1, [sp, #0x8]
 801130a: 186d         	adds	r5, r5, r1
 801130c: 9903         	ldr	r1, [sp, #0xc]
 801130e: eb52 0801    	adcs.w	r8, r2, r1
 8011312: f04f 0300    	mov.w	r3, #0x0
 8011316: bf28         	it	hs
 8011318: 2301         	movhs	r3, #0x1
 801131a: 4681         	mov	r9, r0
 801131c: b133         	cbz	r3, 0x801132c <__double_computeInvPow5+0x9c> @ imm = #0xc
 801131e: 9b04         	ldr	r3, [sp, #0x10]
 8011320: 9a05         	ldr	r2, [sp, #0x14]
 8011322: 3301         	adds	r3, #0x1
 8011324: f142 0200    	adc	r2, r2, #0x0
 8011328: e9cd 3204    	strd	r3, r2, [sp, #16]
 801132c: 4638         	mov	r0, r7
 801132e: f7ff ff1b    	bl	0x8011168 <__pow5bits>  @ imm = #-0x1ca
 8011332: 4607         	mov	r7, r0
 8011334: 4620         	mov	r0, r4
 8011336: f7ff ff17    	bl	0x8011168 <__pow5bits>  @ imm = #-0x1d2
 801133a: 1a3f         	subs	r7, r7, r0
 801133c: 462a         	mov	r2, r5
 801133e: 4643         	mov	r3, r8
 8011340: 9700         	str	r7, [sp]
 8011342: 4648         	mov	r0, r9
 8011344: 4651         	mov	r1, r10
 8011346: f009 fb95    	bl	0x801aa74 <__shiftright128> @ imm = #0x972a
 801134a: ea4f 1c14    	lsr.w	r12, r4, #0x4
 801134e: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8011384 <__double_computeInvPow5+0xf4>
 8011350: 0064         	lsls	r4, r4, #0x1
 8011352: f004 031e    	and	r3, r4, #0x1e
 8011356: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 801135a: 40dc         	lsrs	r4, r3
 801135c: f004 0403    	and	r4, r4, #0x3
 8011360: 3401         	adds	r4, #0x1
 8011362: 1824         	adds	r4, r4, r0
 8011364: f141 0100    	adc	r1, r1, #0x0
 8011368: e9c6 4100    	strd	r4, r1, [r6]
 801136c: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 8011370: 9700         	str	r7, [sp]
 8011372: 4628         	mov	r0, r5
 8011374: 4641         	mov	r1, r8
 8011376: f009 fb7d    	bl	0x801aa74 <__shiftright128> @ imm = #0x96fa
 801137a: e7a2         	b	0x80112c2 <__double_computeInvPow5+0x32> @ imm = #-0xbc

0801137c <$d>:
 801137c: 10 cf 01 08  	.word	0x0801cf10
 8011380: 70 cd 01 08  	.word	0x0801cd70
 8011384: 5c d9 01 08  	.word	0x0801d95c

08011388 <_OffsetAbsSyms>:
; GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
 8011388: b480         	push	{r7}
 801138a: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 801138c: bf00         	nop
 801138e: 46bd         	mov	sp, r7
 8011390: bc80         	pop	{r7}
 8011392: 4770         	bx	lr

08011394 <z_log_msg_runtime_create>:
; {
 8011394: b580         	push	{r7, lr}
 8011396: b08a         	sub	sp, #0x28
 8011398: af04         	add	r7, sp, #0x10
 801139a: 60b9         	str	r1, [r7, #0x8]
 801139c: 607b         	str	r3, [r7, #0x4]
 801139e: 4603         	mov	r3, r0
 80113a0: 73fb         	strb	r3, [r7, #0xf]
 80113a2: 4613         	mov	r3, r2
 80113a4: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80113a6: f107 032c    	add.w	r3, r7, #0x2c
 80113aa: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80113ac: 7bba         	ldrb	r2, [r7, #0xe]
 80113ae: 7bf8         	ldrb	r0, [r7, #0xf]
 80113b0: 697b         	ldr	r3, [r7, #0x14]
 80113b2: 9303         	str	r3, [sp, #0xc]
 80113b4: 6abb         	ldr	r3, [r7, #0x28]
 80113b6: 9302         	str	r3, [sp, #0x8]
 80113b8: 6a7b         	ldr	r3, [r7, #0x24]
 80113ba: 9301         	str	r3, [sp, #0x4]
 80113bc: 6a3b         	ldr	r3, [r7, #0x20]
 80113be: 9300         	str	r3, [sp]
 80113c0: 687b         	ldr	r3, [r7, #0x4]
 80113c2: 68b9         	ldr	r1, [r7, #0x8]
 80113c4: f7f0 fc52    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0xf75c
; }
 80113c8: bf00         	nop
 80113ca: 3718         	adds	r7, #0x18
 80113cc: 46bd         	mov	sp, r7
 80113ce: bd80         	pop	{r7, pc}

080113d0 <k_msleep>:
; {
 80113d0: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 80113d4: b082         	sub	sp, #0x8
 80113d6: af00         	add	r7, sp, #0x0
 80113d8: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 80113da: 6879         	ldr	r1, [r7, #0x4]
 80113dc: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 80113e0: 17c8         	asrs	r0, r1, #0x1f
 80113e2: 4688         	mov	r8, r1
 80113e4: 4681         	mov	r9, r0
 80113e6: 4640         	mov	r0, r8
 80113e8: 4649         	mov	r1, r9
 80113ea: f04f 0400    	mov.w	r4, #0x0
 80113ee: f04f 0500    	mov.w	r5, #0x0
 80113f2: 008d         	lsls	r5, r1, #0x2
 80113f4: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 80113f8: 0084         	lsls	r4, r0, #0x2
 80113fa: 4620         	mov	r0, r4
 80113fc: 4629         	mov	r1, r5
 80113fe: eb10 0208    	adds.w	r2, r0, r8
 8011402: eb41 0309    	adc.w	r3, r1, r9
 8011406: eb12 0a02    	adds.w	r10, r2, r2
 801140a: eb43 0b03    	adc.w	r11, r3, r3
 801140e: 4652         	mov	r2, r10
 8011410: 465b         	mov	r3, r11
 8011412: 4610         	mov	r0, r2
 8011414: 4619         	mov	r1, r3
 8011416: f000 f827    	bl	0x8011468 <k_sleep>     @ imm = #0x4e
 801141a: 4601         	mov	r1, r0
 801141c: 460b         	mov	r3, r1
; }
 801141e: 4618         	mov	r0, r3
 8011420: 3708         	adds	r7, #0x8
 8011422: 46bd         	mov	sp, r7
 8011424: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08011428 <k_thread_create>:
; {
 8011428: b580         	push	{r7, lr}
 801142a: b08c         	sub	sp, #0x30
 801142c: af08         	add	r7, sp, #0x20
 801142e: 60f8         	str	r0, [r7, #0xc]
 8011430: 60b9         	str	r1, [r7, #0x8]
 8011432: 607a         	str	r2, [r7, #0x4]
 8011434: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 8011436: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 801143a: e9cd 2306    	strd	r2, r3, [sp, #24]
 801143e: 6abb         	ldr	r3, [r7, #0x28]
 8011440: 9304         	str	r3, [sp, #0x10]
 8011442: 6a7b         	ldr	r3, [r7, #0x24]
 8011444: 9303         	str	r3, [sp, #0xc]
 8011446: 6a3b         	ldr	r3, [r7, #0x20]
 8011448: 9302         	str	r3, [sp, #0x8]
 801144a: 69fb         	ldr	r3, [r7, #0x1c]
 801144c: 9301         	str	r3, [sp, #0x4]
 801144e: 69bb         	ldr	r3, [r7, #0x18]
 8011450: 9300         	str	r3, [sp]
 8011452: 683b         	ldr	r3, [r7]
 8011454: 687a         	ldr	r2, [r7, #0x4]
 8011456: 68b9         	ldr	r1, [r7, #0x8]
 8011458: 68f8         	ldr	r0, [r7, #0xc]
 801145a: f008 fb47    	bl	0x8019aec <z_impl_k_thread_create> @ imm = #0x868e
 801145e: 4603         	mov	r3, r0
; }
 8011460: 4618         	mov	r0, r3
 8011462: 3710         	adds	r7, #0x10
 8011464: 46bd         	mov	sp, r7
 8011466: bd80         	pop	{r7, pc}

08011468 <k_sleep>:
; {
 8011468: b580         	push	{r7, lr}
 801146a: b082         	sub	sp, #0x8
 801146c: af00         	add	r7, sp, #0x0
 801146e: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8011472: e9d7 0100    	ldrd	r0, r1, [r7]
 8011476: f7fd fd5f    	bl	0x800ef38 <z_impl_k_sleep> @ imm = #-0x2542
 801147a: 4603         	mov	r3, r0
; }
 801147c: 4618         	mov	r0, r3
 801147e: 3708         	adds	r7, #0x8
 8011480: 46bd         	mov	sp, r7
 8011482: bd80         	pop	{r7, pc}

08011484 <z_impl_motor_set_speed>:
; static inline int z_impl_motor_set_speed(const struct device *dev, float speed_rpm) {
 8011484: b580         	push	{r7, lr}
 8011486: b084         	sub	sp, #0x10
 8011488: af00         	add	r7, sp, #0x0
 801148a: 6078         	str	r0, [r7, #0x4]
 801148c: 6039         	str	r1, [r7]
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 801148e: 687b         	ldr	r3, [r7, #0x4]
 8011490: 689b         	ldr	r3, [r3, #0x8]
 8011492: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_set_speed == NULL) {
 8011494: 68fb         	ldr	r3, [r7, #0xc]
 8011496: 68db         	ldr	r3, [r3, #0xc]
 8011498: 2b00         	cmp	r3, #0x0
 801149a: d102         	bne	0x80114a2 <z_impl_motor_set_speed+0x1e> @ imm = #0x4
;         return -ENOSYS;
 801149c: f06f 0357    	mvn	r3, #0x57
 80114a0: e005         	b	0x80114ae <z_impl_motor_set_speed+0x2a> @ imm = #0xa
;     return api->motor_set_speed(dev, speed_rpm);
 80114a2: 68fb         	ldr	r3, [r7, #0xc]
 80114a4: 68db         	ldr	r3, [r3, #0xc]
 80114a6: 6839         	ldr	r1, [r7]
 80114a8: 6878         	ldr	r0, [r7, #0x4]
 80114aa: 4798         	blx	r3
 80114ac: 4603         	mov	r3, r0
; }
 80114ae: 4618         	mov	r0, r3
 80114b0: 3710         	adds	r7, #0x10
 80114b2: 46bd         	mov	sp, r7
 80114b4: bd80         	pop	{r7, pc}

080114b6 <z_impl_motor_control>:
; static inline void z_impl_motor_control(const struct device *dev, enum motor_cmd cmd) {
 80114b6: b580         	push	{r7, lr}
 80114b8: b084         	sub	sp, #0x10
 80114ba: af00         	add	r7, sp, #0x0
 80114bc: 6078         	str	r0, [r7, #0x4]
 80114be: 460b         	mov	r3, r1
 80114c0: 70fb         	strb	r3, [r7, #0x3]
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 80114c2: 687b         	ldr	r3, [r7, #0x4]
 80114c4: 689b         	ldr	r3, [r3, #0x8]
 80114c6: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_control == NULL) {
 80114c8: 68fb         	ldr	r3, [r7, #0xc]
 80114ca: 69db         	ldr	r3, [r3, #0x1c]
 80114cc: 2b00         	cmp	r3, #0x0
 80114ce: d006         	beq	0x80114de <z_impl_motor_control+0x28> @ imm = #0xc
;     api->motor_control(dev, cmd);
 80114d0: 68fb         	ldr	r3, [r7, #0xc]
 80114d2: 69db         	ldr	r3, [r3, #0x1c]
 80114d4: 78fa         	ldrb	r2, [r7, #0x3]
 80114d6: 4611         	mov	r1, r2
 80114d8: 6878         	ldr	r0, [r7, #0x4]
 80114da: 4798         	blx	r3
;     return;
 80114dc: e000         	b	0x80114e0 <z_impl_motor_control+0x2a> @ imm = #0x0
;         return;
 80114de: bf00         	nop
; }
 80114e0: 3710         	adds	r7, #0x10
 80114e2: 46bd         	mov	sp, r7
 80114e4: bd80         	pop	{r7, pc}

080114e6 <z_impl_motor_set_mode>:
; static inline int z_impl_motor_set_mode(const struct device *dev, enum motor_mode mode) {
 80114e6: b580         	push	{r7, lr}
 80114e8: b084         	sub	sp, #0x10
 80114ea: af00         	add	r7, sp, #0x0
 80114ec: 6078         	str	r0, [r7, #0x4]
 80114ee: 460b         	mov	r3, r1
 80114f0: 70fb         	strb	r3, [r7, #0x3]
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 80114f2: 687b         	ldr	r3, [r7, #0x4]
 80114f4: 689b         	ldr	r3, [r3, #0x8]
 80114f6: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_set_mode == NULL) {
 80114f8: 68fb         	ldr	r3, [r7, #0xc]
 80114fa: 699b         	ldr	r3, [r3, #0x18]
 80114fc: 2b00         	cmp	r3, #0x0
 80114fe: d102         	bne	0x8011506 <z_impl_motor_set_mode+0x20> @ imm = #0x4
;         return -ENOSYS;
 8011500: f06f 0357    	mvn	r3, #0x57
 8011504: e006         	b	0x8011514 <z_impl_motor_set_mode+0x2e> @ imm = #0xc
;     return api->motor_set_mode(dev, mode);
 8011506: 68fb         	ldr	r3, [r7, #0xc]
 8011508: 699b         	ldr	r3, [r3, #0x18]
 801150a: 78fa         	ldrb	r2, [r7, #0x3]
 801150c: 4611         	mov	r1, r2
 801150e: 6878         	ldr	r0, [r7, #0x4]
 8011510: 4798         	blx	r3
 8011512: 4603         	mov	r3, r0
; }
 8011514: 4618         	mov	r0, r3
 8011516: 3710         	adds	r7, #0x10
 8011518: 46bd         	mov	sp, r7
 801151a: bd80         	pop	{r7, pc}

0801151c <motor_get_speed>:
; {
 801151c: b580         	push	{r7, lr}
 801151e: b082         	sub	sp, #0x8
 8011520: af00         	add	r7, sp, #0x0
 8011522: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_motor_get_speed(dev);
 8011524: 6878         	ldr	r0, [r7, #0x4]
 8011526: f7ef fc61    	bl	0x8000dec <z_impl_motor_get_speed> @ imm = #-0x1073e
 801152a: 4603         	mov	r3, r0
; }
 801152c: 4618         	mov	r0, r3
 801152e: 3708         	adds	r7, #0x8
 8011530: 46bd         	mov	sp, r7
 8011532: bd80         	pop	{r7, pc}

08011534 <motor_set_speed>:
; {
 8011534: b580         	push	{r7, lr}
 8011536: b082         	sub	sp, #0x8
 8011538: af00         	add	r7, sp, #0x0
 801153a: 6078         	str	r0, [r7, #0x4]
 801153c: 6039         	str	r1, [r7]
; 	return z_impl_motor_set_speed(dev, speed_rpm);
 801153e: 6839         	ldr	r1, [r7]
 8011540: 6878         	ldr	r0, [r7, #0x4]
 8011542: f7ff ff9f    	bl	0x8011484 <z_impl_motor_set_speed> @ imm = #-0xc2
 8011546: 4603         	mov	r3, r0
; }
 8011548: 4618         	mov	r0, r3
 801154a: 3708         	adds	r7, #0x8
 801154c: 46bd         	mov	sp, r7
 801154e: bd80         	pop	{r7, pc}

08011550 <motor_control>:
; {
 8011550: b580         	push	{r7, lr}
 8011552: b082         	sub	sp, #0x8
 8011554: af00         	add	r7, sp, #0x0
 8011556: 6078         	str	r0, [r7, #0x4]
 8011558: 460b         	mov	r3, r1
 801155a: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_motor_control(dev, cmd);
 801155c: 78fb         	ldrb	r3, [r7, #0x3]
 801155e: 4619         	mov	r1, r3
 8011560: 6878         	ldr	r0, [r7, #0x4]
 8011562: f7ff ffa8    	bl	0x80114b6 <z_impl_motor_control> @ imm = #-0xb0
; }
 8011566: bf00         	nop
 8011568: 3708         	adds	r7, #0x8
 801156a: 46bd         	mov	sp, r7
 801156c: bd80         	pop	{r7, pc}

0801156e <motor_set_mode>:
; {
 801156e: b580         	push	{r7, lr}
 8011570: b082         	sub	sp, #0x8
 8011572: af00         	add	r7, sp, #0x0
 8011574: 6078         	str	r0, [r7, #0x4]
 8011576: 460b         	mov	r3, r1
 8011578: 70fb         	strb	r3, [r7, #0x3]
; 	return z_impl_motor_set_mode(dev, mode);
 801157a: 78fb         	ldrb	r3, [r7, #0x3]
 801157c: 4619         	mov	r1, r3
 801157e: 6878         	ldr	r0, [r7, #0x4]
 8011580: f7ff ffb1    	bl	0x80114e6 <z_impl_motor_set_mode> @ imm = #-0x9e
 8011584: 4603         	mov	r3, r0
; }
 8011586: 4618         	mov	r0, r3
 8011588: 3708         	adds	r7, #0x8
 801158a: 46bd         	mov	sp, r7
 801158c: bd80         	pop	{r7, pc}

0801158e <big_heap_chunks>:
; {
 801158e: b480         	push	{r7}
 8011590: b083         	sub	sp, #0xc
 8011592: af00         	add	r7, sp, #0x0
 8011594: 6078         	str	r0, [r7, #0x4]
; 		return false;
 8011596: 2300         	movs	r3, #0x0
; }
 8011598: 4618         	mov	r0, r3
 801159a: 370c         	adds	r7, #0xc
 801159c: 46bd         	mov	sp, r7
 801159e: bc80         	pop	{r7}
 80115a0: 4770         	bx	lr

080115a2 <big_heap_bytes>:
; {
 80115a2: b580         	push	{r7, lr}
 80115a4: b082         	sub	sp, #0x8
 80115a6: af00         	add	r7, sp, #0x0
 80115a8: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(bytes / CHUNK_UNIT);
 80115aa: 687b         	ldr	r3, [r7, #0x4]
 80115ac: 08db         	lsrs	r3, r3, #0x3
 80115ae: 4618         	mov	r0, r3
 80115b0: f7ff ffed    	bl	0x801158e <big_heap_chunks> @ imm = #-0x26
 80115b4: 4603         	mov	r3, r0
; }
 80115b6: 4618         	mov	r0, r3
 80115b8: 3708         	adds	r7, #0x8
 80115ba: 46bd         	mov	sp, r7
 80115bc: bd80         	pop	{r7, pc}

080115be <big_heap>:
; {
 80115be: b580         	push	{r7, lr}
 80115c0: b082         	sub	sp, #0x8
 80115c2: af00         	add	r7, sp, #0x0
 80115c4: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(h->end_chunk);
 80115c6: 687b         	ldr	r3, [r7, #0x4]
 80115c8: 689b         	ldr	r3, [r3, #0x8]
 80115ca: 4618         	mov	r0, r3
 80115cc: f7ff ffdf    	bl	0x801158e <big_heap_chunks> @ imm = #-0x42
 80115d0: 4603         	mov	r3, r0
; }
 80115d2: 4618         	mov	r0, r3
 80115d4: 3708         	adds	r7, #0x8
 80115d6: 46bd         	mov	sp, r7
 80115d8: bd80         	pop	{r7, pc}

080115da <chunk_buf>:
; {
 80115da: b480         	push	{r7}
 80115dc: b083         	sub	sp, #0xc
 80115de: af00         	add	r7, sp, #0x0
 80115e0: 6078         	str	r0, [r7, #0x4]
; 	return (chunk_unit_t *)h;
 80115e2: 687b         	ldr	r3, [r7, #0x4]
; }
 80115e4: 4618         	mov	r0, r3
 80115e6: 370c         	adds	r7, #0xc
 80115e8: 46bd         	mov	sp, r7
 80115ea: bc80         	pop	{r7}
 80115ec: 4770         	bx	lr

080115ee <chunk_field>:
; {
 80115ee: b580         	push	{r7, lr}
 80115f0: b086         	sub	sp, #0x18
 80115f2: af00         	add	r7, sp, #0x0
 80115f4: 60f8         	str	r0, [r7, #0xc]
 80115f6: 60b9         	str	r1, [r7, #0x8]
 80115f8: 4613         	mov	r3, r2
 80115fa: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 80115fc: 68f8         	ldr	r0, [r7, #0xc]
 80115fe: f7ff ffec    	bl	0x80115da <chunk_buf>   @ imm = #-0x28
 8011602: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 8011604: 68bb         	ldr	r3, [r7, #0x8]
 8011606: 00db         	lsls	r3, r3, #0x3
 8011608: 697a         	ldr	r2, [r7, #0x14]
 801160a: 4413         	add	r3, r2
 801160c: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 801160e: 68f8         	ldr	r0, [r7, #0xc]
 8011610: f7ff ffd5    	bl	0x80115be <big_heap>    @ imm = #-0x56
 8011614: 4603         	mov	r3, r0
 8011616: 2b00         	cmp	r3, #0x0
 8011618: d005         	beq	0x8011626 <chunk_field+0x38> @ imm = #0xa
; 		return ((uint32_t *)cmem)[f];
 801161a: 79fb         	ldrb	r3, [r7, #0x7]
 801161c: 009b         	lsls	r3, r3, #0x2
 801161e: 693a         	ldr	r2, [r7, #0x10]
 8011620: 4413         	add	r3, r2
 8011622: 681b         	ldr	r3, [r3]
 8011624: e004         	b	0x8011630 <chunk_field+0x42> @ imm = #0x8
; 		return ((uint16_t *)cmem)[f];
 8011626: 79fb         	ldrb	r3, [r7, #0x7]
 8011628: 005b         	lsls	r3, r3, #0x1
 801162a: 693a         	ldr	r2, [r7, #0x10]
 801162c: 4413         	add	r3, r2
 801162e: 881b         	ldrh	r3, [r3]
; }
 8011630: 4618         	mov	r0, r3
 8011632: 3718         	adds	r7, #0x18
 8011634: 46bd         	mov	sp, r7
 8011636: bd80         	pop	{r7, pc}

08011638 <chunk_set>:
; {
 8011638: b580         	push	{r7, lr}
 801163a: b086         	sub	sp, #0x18
 801163c: af00         	add	r7, sp, #0x0
 801163e: 60f8         	str	r0, [r7, #0xc]
 8011640: 60b9         	str	r1, [r7, #0x8]
 8011642: 603b         	str	r3, [r7]
 8011644: 4613         	mov	r3, r2
 8011646: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 8011648: 68f8         	ldr	r0, [r7, #0xc]
 801164a: f7ff ffc6    	bl	0x80115da <chunk_buf>   @ imm = #-0x74
 801164e: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 8011650: 68bb         	ldr	r3, [r7, #0x8]
 8011652: 00db         	lsls	r3, r3, #0x3
 8011654: 697a         	ldr	r2, [r7, #0x14]
 8011656: 4413         	add	r3, r2
 8011658: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 801165a: 68f8         	ldr	r0, [r7, #0xc]
 801165c: f7ff ffaf    	bl	0x80115be <big_heap>    @ imm = #-0xa2
 8011660: 4603         	mov	r3, r0
 8011662: 2b00         	cmp	r3, #0x0
 8011664: d006         	beq	0x8011674 <chunk_set+0x3c> @ imm = #0xc
; 		((uint32_t *)cmem)[f] = val;
 8011666: 79fb         	ldrb	r3, [r7, #0x7]
 8011668: 009b         	lsls	r3, r3, #0x2
 801166a: 693a         	ldr	r2, [r7, #0x10]
 801166c: 4413         	add	r3, r2
 801166e: 683a         	ldr	r2, [r7]
 8011670: 601a         	str	r2, [r3]
; }
 8011672: e006         	b	0x8011682 <chunk_set+0x4a> @ imm = #0xc
; 		((uint16_t *)cmem)[f] = val;
 8011674: 79fb         	ldrb	r3, [r7, #0x7]
 8011676: 005b         	lsls	r3, r3, #0x1
 8011678: 693a         	ldr	r2, [r7, #0x10]
 801167a: 4413         	add	r3, r2
 801167c: 683a         	ldr	r2, [r7]
 801167e: b292         	uxth	r2, r2
 8011680: 801a         	strh	r2, [r3]
; }
 8011682: bf00         	nop
 8011684: 3718         	adds	r7, #0x18
 8011686: 46bd         	mov	sp, r7
 8011688: bd80         	pop	{r7, pc}

0801168a <chunk_size>:
; {
 801168a: b580         	push	{r7, lr}
 801168c: b082         	sub	sp, #0x8
 801168e: af00         	add	r7, sp, #0x0
 8011690: 6078         	str	r0, [r7, #0x4]
 8011692: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, SIZE_AND_USED) >> 1;
 8011694: 2201         	movs	r2, #0x1
 8011696: 6839         	ldr	r1, [r7]
 8011698: 6878         	ldr	r0, [r7, #0x4]
 801169a: f7ff ffa8    	bl	0x80115ee <chunk_field> @ imm = #-0xb0
 801169e: 4603         	mov	r3, r0
 80116a0: 085b         	lsrs	r3, r3, #0x1
; }
 80116a2: 4618         	mov	r0, r3
 80116a4: 3708         	adds	r7, #0x8
 80116a6: 46bd         	mov	sp, r7
 80116a8: bd80         	pop	{r7, pc}

080116aa <set_chunk_used>:
; {
 80116aa: b580         	push	{r7, lr}
 80116ac: b086         	sub	sp, #0x18
 80116ae: af00         	add	r7, sp, #0x0
 80116b0: 60f8         	str	r0, [r7, #0xc]
 80116b2: 60b9         	str	r1, [r7, #0x8]
 80116b4: 4613         	mov	r3, r2
 80116b6: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 80116b8: 68f8         	ldr	r0, [r7, #0xc]
 80116ba: f7ff ff8e    	bl	0x80115da <chunk_buf>   @ imm = #-0xe4
 80116be: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 80116c0: 68bb         	ldr	r3, [r7, #0x8]
 80116c2: 00db         	lsls	r3, r3, #0x3
 80116c4: 697a         	ldr	r2, [r7, #0x14]
 80116c6: 4413         	add	r3, r2
 80116c8: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 80116ca: 68f8         	ldr	r0, [r7, #0xc]
 80116cc: f7ff ff77    	bl	0x80115be <big_heap>    @ imm = #-0x112
 80116d0: 4603         	mov	r3, r0
 80116d2: 2b00         	cmp	r3, #0x0
 80116d4: d014         	beq	0x8011700 <set_chunk_used+0x56> @ imm = #0x28
; 		if (used) {
 80116d6: 79fb         	ldrb	r3, [r7, #0x7]
 80116d8: 2b00         	cmp	r3, #0x0
 80116da: d008         	beq	0x80116ee <set_chunk_used+0x44> @ imm = #0x10
; 			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
 80116dc: 693b         	ldr	r3, [r7, #0x10]
 80116de: 3304         	adds	r3, #0x4
 80116e0: 681a         	ldr	r2, [r3]
 80116e2: 693b         	ldr	r3, [r7, #0x10]
 80116e4: 3304         	adds	r3, #0x4
 80116e6: f042 0201    	orr	r2, r2, #0x1
 80116ea: 601a         	str	r2, [r3]
; }
 80116ec: e01e         	b	0x801172c <set_chunk_used+0x82> @ imm = #0x3c
; 			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
 80116ee: 693b         	ldr	r3, [r7, #0x10]
 80116f0: 3304         	adds	r3, #0x4
 80116f2: 681a         	ldr	r2, [r3]
 80116f4: 693b         	ldr	r3, [r7, #0x10]
 80116f6: 3304         	adds	r3, #0x4
 80116f8: f022 0201    	bic	r2, r2, #0x1
 80116fc: 601a         	str	r2, [r3]
; }
 80116fe: e015         	b	0x801172c <set_chunk_used+0x82> @ imm = #0x2a
; 		if (used) {
 8011700: 79fb         	ldrb	r3, [r7, #0x7]
 8011702: 2b00         	cmp	r3, #0x0
 8011704: d009         	beq	0x801171a <set_chunk_used+0x70> @ imm = #0x12
; 			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 8011706: 693b         	ldr	r3, [r7, #0x10]
 8011708: 3302         	adds	r3, #0x2
 801170a: 881a         	ldrh	r2, [r3]
 801170c: 693b         	ldr	r3, [r7, #0x10]
 801170e: 3302         	adds	r3, #0x2
 8011710: f042 0201    	orr	r2, r2, #0x1
 8011714: b292         	uxth	r2, r2
 8011716: 801a         	strh	r2, [r3]
; }
 8011718: e008         	b	0x801172c <set_chunk_used+0x82> @ imm = #0x10
; 			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
 801171a: 693b         	ldr	r3, [r7, #0x10]
 801171c: 3302         	adds	r3, #0x2
 801171e: 881a         	ldrh	r2, [r3]
 8011720: 693b         	ldr	r3, [r7, #0x10]
 8011722: 3302         	adds	r3, #0x2
 8011724: f022 0201    	bic	r2, r2, #0x1
 8011728: b292         	uxth	r2, r2
 801172a: 801a         	strh	r2, [r3]
; }
 801172c: bf00         	nop
 801172e: 3718         	adds	r7, #0x18
 8011730: 46bd         	mov	sp, r7
 8011732: bd80         	pop	{r7, pc}

08011734 <set_chunk_size>:
; {
 8011734: b580         	push	{r7, lr}
 8011736: b084         	sub	sp, #0x10
 8011738: af00         	add	r7, sp, #0x0
 801173a: 60f8         	str	r0, [r7, #0xc]
 801173c: 60b9         	str	r1, [r7, #0x8]
 801173e: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, SIZE_AND_USED, size << 1);
 8011740: 687b         	ldr	r3, [r7, #0x4]
 8011742: 005b         	lsls	r3, r3, #0x1
 8011744: 2201         	movs	r2, #0x1
 8011746: 68b9         	ldr	r1, [r7, #0x8]
 8011748: 68f8         	ldr	r0, [r7, #0xc]
 801174a: f7ff ff75    	bl	0x8011638 <chunk_set>   @ imm = #-0x116
; }
 801174e: bf00         	nop
 8011750: 3710         	adds	r7, #0x10
 8011752: 46bd         	mov	sp, r7
 8011754: bd80         	pop	{r7, pc}

08011756 <prev_free_chunk>:
; {
 8011756: b580         	push	{r7, lr}
 8011758: b082         	sub	sp, #0x8
 801175a: af00         	add	r7, sp, #0x0
 801175c: 6078         	str	r0, [r7, #0x4]
 801175e: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, FREE_PREV);
 8011760: 2202         	movs	r2, #0x2
 8011762: 6839         	ldr	r1, [r7]
 8011764: 6878         	ldr	r0, [r7, #0x4]
 8011766: f7ff ff42    	bl	0x80115ee <chunk_field> @ imm = #-0x17c
 801176a: 4603         	mov	r3, r0
; }
 801176c: 4618         	mov	r0, r3
 801176e: 3708         	adds	r7, #0x8
 8011770: 46bd         	mov	sp, r7
 8011772: bd80         	pop	{r7, pc}

08011774 <set_prev_free_chunk>:
; {
 8011774: b580         	push	{r7, lr}
 8011776: b084         	sub	sp, #0x10
 8011778: af00         	add	r7, sp, #0x0
 801177a: 60f8         	str	r0, [r7, #0xc]
 801177c: 60b9         	str	r1, [r7, #0x8]
 801177e: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_PREV, prev);
 8011780: 687b         	ldr	r3, [r7, #0x4]
 8011782: 2202         	movs	r2, #0x2
 8011784: 68b9         	ldr	r1, [r7, #0x8]
 8011786: 68f8         	ldr	r0, [r7, #0xc]
 8011788: f7ff ff56    	bl	0x8011638 <chunk_set>   @ imm = #-0x154
; }
 801178c: bf00         	nop
 801178e: 3710         	adds	r7, #0x10
 8011790: 46bd         	mov	sp, r7
 8011792: bd80         	pop	{r7, pc}

08011794 <set_next_free_chunk>:
; {
 8011794: b580         	push	{r7, lr}
 8011796: b084         	sub	sp, #0x10
 8011798: af00         	add	r7, sp, #0x0
 801179a: 60f8         	str	r0, [r7, #0xc]
 801179c: 60b9         	str	r1, [r7, #0x8]
 801179e: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_NEXT, next);
 80117a0: 687b         	ldr	r3, [r7, #0x4]
 80117a2: 2203         	movs	r2, #0x3
 80117a4: 68b9         	ldr	r1, [r7, #0x8]
 80117a6: 68f8         	ldr	r0, [r7, #0xc]
 80117a8: f7ff ff46    	bl	0x8011638 <chunk_set>   @ imm = #-0x174
; }
 80117ac: bf00         	nop
 80117ae: 3710         	adds	r7, #0x10
 80117b0: 46bd         	mov	sp, r7
 80117b2: bd80         	pop	{r7, pc}

080117b4 <set_left_chunk_size>:
; {
 80117b4: b580         	push	{r7, lr}
 80117b6: b084         	sub	sp, #0x10
 80117b8: af00         	add	r7, sp, #0x0
 80117ba: 60f8         	str	r0, [r7, #0xc]
 80117bc: 60b9         	str	r1, [r7, #0x8]
 80117be: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, LEFT_SIZE, size);
 80117c0: 687b         	ldr	r3, [r7, #0x4]
 80117c2: 2200         	movs	r2, #0x0
 80117c4: 68b9         	ldr	r1, [r7, #0x8]
 80117c6: 68f8         	ldr	r0, [r7, #0xc]
 80117c8: f7ff ff36    	bl	0x8011638 <chunk_set>   @ imm = #-0x194
; }
 80117cc: bf00         	nop
 80117ce: 3710         	adds	r7, #0x10
 80117d0: 46bd         	mov	sp, r7
 80117d2: bd80         	pop	{r7, pc}

080117d4 <solo_free_header>:
; {
 80117d4: b580         	push	{r7, lr}
 80117d6: b082         	sub	sp, #0x8
 80117d8: af00         	add	r7, sp, #0x0
 80117da: 6078         	str	r0, [r7, #0x4]
 80117dc: 6039         	str	r1, [r7]
; 	return big_heap(h) && (chunk_size(h, c) == 1U);
 80117de: 6878         	ldr	r0, [r7, #0x4]
 80117e0: f7ff feed    	bl	0x80115be <big_heap>    @ imm = #-0x226
 80117e4: 4603         	mov	r3, r0
 80117e6: 2b00         	cmp	r3, #0x0
 80117e8: d008         	beq	0x80117fc <solo_free_header+0x28> @ imm = #0x10
 80117ea: 6839         	ldr	r1, [r7]
 80117ec: 6878         	ldr	r0, [r7, #0x4]
 80117ee: f7ff ff4c    	bl	0x801168a <chunk_size>  @ imm = #-0x168
 80117f2: 4603         	mov	r3, r0
 80117f4: 2b01         	cmp	r3, #0x1
 80117f6: d101         	bne	0x80117fc <solo_free_header+0x28> @ imm = #0x2
 80117f8: 2301         	movs	r3, #0x1
 80117fa: e000         	b	0x80117fe <solo_free_header+0x2a> @ imm = #0x0
 80117fc: 2300         	movs	r3, #0x0
 80117fe: f003 0301    	and	r3, r3, #0x1
 8011802: b2db         	uxtb	r3, r3
; }
 8011804: 4618         	mov	r0, r3
 8011806: 3708         	adds	r7, #0x8
 8011808: 46bd         	mov	sp, r7
 801180a: bd80         	pop	{r7, pc}

0801180c <chunk_header_bytes>:
; {
 801180c: b580         	push	{r7, lr}
 801180e: b082         	sub	sp, #0x8
 8011810: af00         	add	r7, sp, #0x0
 8011812: 6078         	str	r0, [r7, #0x4]
; 	return big_heap(h) ? 8 : 4;
 8011814: 6878         	ldr	r0, [r7, #0x4]
 8011816: f7ff fed2    	bl	0x80115be <big_heap>    @ imm = #-0x25c
 801181a: 4603         	mov	r3, r0
 801181c: 2b00         	cmp	r3, #0x0
 801181e: d001         	beq	0x8011824 <chunk_header_bytes+0x18> @ imm = #0x2
 8011820: 2308         	movs	r3, #0x8
 8011822: e000         	b	0x8011826 <chunk_header_bytes+0x1a> @ imm = #0x0
 8011824: 2304         	movs	r3, #0x4
; }
 8011826: 4618         	mov	r0, r3
 8011828: 3708         	adds	r7, #0x8
 801182a: 46bd         	mov	sp, r7
 801182c: bd80         	pop	{r7, pc}

0801182e <heap_footer_bytes>:
; {
 801182e: b580         	push	{r7, lr}
 8011830: b082         	sub	sp, #0x8
 8011832: af00         	add	r7, sp, #0x0
 8011834: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_bytes(size) ? 8 : 4;
 8011836: 6878         	ldr	r0, [r7, #0x4]
 8011838: f7ff feb3    	bl	0x80115a2 <big_heap_bytes> @ imm = #-0x29a
 801183c: 4603         	mov	r3, r0
 801183e: 2b00         	cmp	r3, #0x0
 8011840: d001         	beq	0x8011846 <heap_footer_bytes+0x18> @ imm = #0x2
 8011842: 2308         	movs	r3, #0x8
 8011844: e000         	b	0x8011848 <heap_footer_bytes+0x1a> @ imm = #0x0
 8011846: 2304         	movs	r3, #0x4
; }
 8011848: 4618         	mov	r0, r3
 801184a: 3708         	adds	r7, #0x8
 801184c: 46bd         	mov	sp, r7
 801184e: bd80         	pop	{r7, pc}

08011850 <chunksz>:
; {
 8011850: b480         	push	{r7}
 8011852: b083         	sub	sp, #0xc
 8011854: af00         	add	r7, sp, #0x0
 8011856: 6078         	str	r0, [r7, #0x4]
; 	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 8011858: 687b         	ldr	r3, [r7, #0x4]
 801185a: 3307         	adds	r3, #0x7
 801185c: 08db         	lsrs	r3, r3, #0x3
; }
 801185e: 4618         	mov	r0, r3
 8011860: 370c         	adds	r7, #0xc
 8011862: 46bd         	mov	sp, r7
 8011864: bc80         	pop	{r7}
 8011866: 4770         	bx	lr

08011868 <bytes_to_chunksz>:
; {
 8011868: b580         	push	{r7, lr}
 801186a: b082         	sub	sp, #0x8
 801186c: af00         	add	r7, sp, #0x0
 801186e: 6078         	str	r0, [r7, #0x4]
 8011870: 6039         	str	r1, [r7]
; 	return chunksz(chunk_header_bytes(h) + bytes);
 8011872: 6878         	ldr	r0, [r7, #0x4]
 8011874: f7ff ffca    	bl	0x801180c <chunk_header_bytes> @ imm = #-0x6c
 8011878: 4602         	mov	r2, r0
 801187a: 683b         	ldr	r3, [r7]
 801187c: 4413         	add	r3, r2
 801187e: 4618         	mov	r0, r3
 8011880: f7ff ffe6    	bl	0x8011850 <chunksz>     @ imm = #-0x34
 8011884: 4603         	mov	r3, r0
; }
 8011886: 4618         	mov	r0, r3
 8011888: 3708         	adds	r7, #0x8
 801188a: 46bd         	mov	sp, r7
 801188c: bd80         	pop	{r7, pc}

0801188e <min_chunk_size>:
; {
 801188e: b580         	push	{r7, lr}
 8011890: b082         	sub	sp, #0x8
 8011892: af00         	add	r7, sp, #0x0
 8011894: 6078         	str	r0, [r7, #0x4]
; 	return bytes_to_chunksz(h, 1);
 8011896: 2101         	movs	r1, #0x1
 8011898: 6878         	ldr	r0, [r7, #0x4]
 801189a: f7ff ffe5    	bl	0x8011868 <bytes_to_chunksz> @ imm = #-0x36
 801189e: 4603         	mov	r3, r0
; }
 80118a0: 4618         	mov	r0, r3
 80118a2: 3708         	adds	r7, #0x8
 80118a4: 46bd         	mov	sp, r7
 80118a6: bd80         	pop	{r7, pc}

080118a8 <bucket_idx>:
; {
 80118a8: b580         	push	{r7, lr}
 80118aa: b084         	sub	sp, #0x10
 80118ac: af00         	add	r7, sp, #0x0
 80118ae: 6078         	str	r0, [r7, #0x4]
 80118b0: 6039         	str	r1, [r7]
; 	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
 80118b2: 6878         	ldr	r0, [r7, #0x4]
 80118b4: f7ff ffeb    	bl	0x801188e <min_chunk_size> @ imm = #-0x2a
 80118b8: 4602         	mov	r2, r0
 80118ba: 683b         	ldr	r3, [r7]
 80118bc: 1a9b         	subs	r3, r3, r2
 80118be: 3301         	adds	r3, #0x1
 80118c0: 60fb         	str	r3, [r7, #0xc]
; 	return 31 - __builtin_clz(usable_sz);
 80118c2: 68fb         	ldr	r3, [r7, #0xc]
 80118c4: fab3 f383    	clz	r3, r3
 80118c8: f1c3 031f    	rsb.w	r3, r3, #0x1f
; }
 80118cc: 4618         	mov	r0, r3
 80118ce: 3710         	adds	r7, #0x10
 80118d0: 46bd         	mov	sp, r7
 80118d2: bd80         	pop	{r7, pc}

080118d4 <free_list_add_bidx>:
; {
 80118d4: b580         	push	{r7, lr}
 80118d6: b088         	sub	sp, #0x20
 80118d8: af00         	add	r7, sp, #0x0
 80118da: 60f8         	str	r0, [r7, #0xc]
 80118dc: 60b9         	str	r1, [r7, #0x8]
 80118de: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap_bucket *b = &h->buckets[bidx];
 80118e0: 687b         	ldr	r3, [r7, #0x4]
 80118e2: 3304         	adds	r3, #0x4
 80118e4: 009b         	lsls	r3, r3, #0x2
 80118e6: 68fa         	ldr	r2, [r7, #0xc]
 80118e8: 4413         	add	r3, r2
 80118ea: 61fb         	str	r3, [r7, #0x1c]
; 	if (b->next == 0U) {
 80118ec: 69fb         	ldr	r3, [r7, #0x1c]
 80118ee: 681b         	ldr	r3, [r3]
 80118f0: 2b00         	cmp	r3, #0x0
 80118f2: d116         	bne	0x8011922 <free_list_add_bidx+0x4e> @ imm = #0x2c
; 		h->avail_buckets |= BIT(bidx);
 80118f4: 68fb         	ldr	r3, [r7, #0xc]
 80118f6: 68da         	ldr	r2, [r3, #0xc]
 80118f8: 2101         	movs	r1, #0x1
 80118fa: 687b         	ldr	r3, [r7, #0x4]
 80118fc: fa01 f303    	lsl.w	r3, r1, r3
 8011900: 431a         	orrs	r2, r3
 8011902: 68fb         	ldr	r3, [r7, #0xc]
 8011904: 60da         	str	r2, [r3, #0xc]
; 		b->next = c;
 8011906: 69fb         	ldr	r3, [r7, #0x1c]
 8011908: 68ba         	ldr	r2, [r7, #0x8]
 801190a: 601a         	str	r2, [r3]
; 		set_prev_free_chunk(h, c, c);
 801190c: 68ba         	ldr	r2, [r7, #0x8]
 801190e: 68b9         	ldr	r1, [r7, #0x8]
 8011910: 68f8         	ldr	r0, [r7, #0xc]
 8011912: f7ff ff2f    	bl	0x8011774 <set_prev_free_chunk> @ imm = #-0x1a2
; 		set_next_free_chunk(h, c, c);
 8011916: 68ba         	ldr	r2, [r7, #0x8]
 8011918: 68b9         	ldr	r1, [r7, #0x8]
 801191a: 68f8         	ldr	r0, [r7, #0xc]
 801191c: f7ff ff3a    	bl	0x8011794 <set_next_free_chunk> @ imm = #-0x18c
; }
 8011920: e01b         	b	0x801195a <free_list_add_bidx+0x86> @ imm = #0x36
; 		chunkid_t second = b->next;
 8011922: 69fb         	ldr	r3, [r7, #0x1c]
 8011924: 681b         	ldr	r3, [r3]
 8011926: 61bb         	str	r3, [r7, #0x18]
; 		chunkid_t first = prev_free_chunk(h, second);
 8011928: 69b9         	ldr	r1, [r7, #0x18]
 801192a: 68f8         	ldr	r0, [r7, #0xc]
 801192c: f7ff ff13    	bl	0x8011756 <prev_free_chunk> @ imm = #-0x1da
 8011930: 6178         	str	r0, [r7, #0x14]
; 		set_prev_free_chunk(h, c, first);
 8011932: 697a         	ldr	r2, [r7, #0x14]
 8011934: 68b9         	ldr	r1, [r7, #0x8]
 8011936: 68f8         	ldr	r0, [r7, #0xc]
 8011938: f7ff ff1c    	bl	0x8011774 <set_prev_free_chunk> @ imm = #-0x1c8
; 		set_next_free_chunk(h, c, second);
 801193c: 69ba         	ldr	r2, [r7, #0x18]
 801193e: 68b9         	ldr	r1, [r7, #0x8]
 8011940: 68f8         	ldr	r0, [r7, #0xc]
 8011942: f7ff ff27    	bl	0x8011794 <set_next_free_chunk> @ imm = #-0x1b2
; 		set_next_free_chunk(h, first, c);
 8011946: 68ba         	ldr	r2, [r7, #0x8]
 8011948: 6979         	ldr	r1, [r7, #0x14]
 801194a: 68f8         	ldr	r0, [r7, #0xc]
 801194c: f7ff ff22    	bl	0x8011794 <set_next_free_chunk> @ imm = #-0x1bc
; 		set_prev_free_chunk(h, second, c);
 8011950: 68ba         	ldr	r2, [r7, #0x8]
 8011952: 69b9         	ldr	r1, [r7, #0x18]
 8011954: 68f8         	ldr	r0, [r7, #0xc]
 8011956: f7ff ff0d    	bl	0x8011774 <set_prev_free_chunk> @ imm = #-0x1e6
; }
 801195a: bf00         	nop
 801195c: 3720         	adds	r7, #0x20
 801195e: 46bd         	mov	sp, r7
 8011960: bd80         	pop	{r7, pc}

08011962 <free_list_add>:
; {
 8011962: b580         	push	{r7, lr}
 8011964: b084         	sub	sp, #0x10
 8011966: af00         	add	r7, sp, #0x0
 8011968: 6078         	str	r0, [r7, #0x4]
 801196a: 6039         	str	r1, [r7]
; 	if (!solo_free_header(h, c)) {
 801196c: 6839         	ldr	r1, [r7]
 801196e: 6878         	ldr	r0, [r7, #0x4]
 8011970: f7ff ff30    	bl	0x80117d4 <solo_free_header> @ imm = #-0x1a0
 8011974: 4603         	mov	r3, r0
 8011976: f083 0301    	eor	r3, r3, #0x1
 801197a: b2db         	uxtb	r3, r3
 801197c: 2b00         	cmp	r3, #0x0
 801197e: d00e         	beq	0x801199e <free_list_add+0x3c> @ imm = #0x1c
; 		int bidx = bucket_idx(h, chunk_size(h, c));
 8011980: 6839         	ldr	r1, [r7]
 8011982: 6878         	ldr	r0, [r7, #0x4]
 8011984: f7ff fe81    	bl	0x801168a <chunk_size>  @ imm = #-0x2fe
 8011988: 4603         	mov	r3, r0
 801198a: 4619         	mov	r1, r3
 801198c: 6878         	ldr	r0, [r7, #0x4]
 801198e: f7ff ff8b    	bl	0x80118a8 <bucket_idx>  @ imm = #-0xea
 8011992: 60f8         	str	r0, [r7, #0xc]
; 		free_list_add_bidx(h, c, bidx);
 8011994: 68fa         	ldr	r2, [r7, #0xc]
 8011996: 6839         	ldr	r1, [r7]
 8011998: 6878         	ldr	r0, [r7, #0x4]
 801199a: f7ff ff9b    	bl	0x80118d4 <free_list_add_bidx> @ imm = #-0xca
; }
 801199e: bf00         	nop
 80119a0: 3710         	adds	r7, #0x10
 80119a2: 46bd         	mov	sp, r7
 80119a4: bd80         	pop	{r7, pc}

080119a6 <sys_heap_init>:
; {
 80119a6: b580         	push	{r7, lr}
 80119a8: b08c         	sub	sp, #0x30
 80119aa: af00         	add	r7, sp, #0x0
 80119ac: 60f8         	str	r0, [r7, #0xc]
 80119ae: 60b9         	str	r1, [r7, #0x8]
 80119b0: 607a         	str	r2, [r7, #0x4]
; 	bytes -= heap_footer_bytes(bytes);
 80119b2: 6878         	ldr	r0, [r7, #0x4]
 80119b4: f7ff ff3b    	bl	0x801182e <heap_footer_bytes> @ imm = #-0x18a
 80119b8: 4602         	mov	r2, r0
 80119ba: 687b         	ldr	r3, [r7, #0x4]
 80119bc: 1a9b         	subs	r3, r3, r2
 80119be: 607b         	str	r3, [r7, #0x4]
; 	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 80119c0: 68bb         	ldr	r3, [r7, #0x8]
 80119c2: 3307         	adds	r3, #0x7
 80119c4: f023 0307    	bic	r3, r3, #0x7
 80119c8: 62bb         	str	r3, [r7, #0x28]
; 	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 80119ca: 68ba         	ldr	r2, [r7, #0x8]
 80119cc: 687b         	ldr	r3, [r7, #0x4]
 80119ce: 4413         	add	r3, r2
 80119d0: f023 0307    	bic	r3, r3, #0x7
 80119d4: 627b         	str	r3, [r7, #0x24]
; 	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
 80119d6: 6a7a         	ldr	r2, [r7, #0x24]
 80119d8: 6abb         	ldr	r3, [r7, #0x28]
 80119da: 1ad3         	subs	r3, r2, r3
 80119dc: 08db         	lsrs	r3, r3, #0x3
 80119de: 623b         	str	r3, [r7, #0x20]
; 	struct z_heap *h = (struct z_heap *)addr;
 80119e0: 6abb         	ldr	r3, [r7, #0x28]
 80119e2: 61fb         	str	r3, [r7, #0x1c]
; 	heap->heap = h;
 80119e4: 68fb         	ldr	r3, [r7, #0xc]
 80119e6: 69fa         	ldr	r2, [r7, #0x1c]
 80119e8: 601a         	str	r2, [r3]
; 	h->end_chunk = heap_sz;
 80119ea: 69fb         	ldr	r3, [r7, #0x1c]
 80119ec: 6a3a         	ldr	r2, [r7, #0x20]
 80119ee: 609a         	str	r2, [r3, #0x8]
; 	h->avail_buckets = 0;
 80119f0: 69fb         	ldr	r3, [r7, #0x1c]
 80119f2: 2200         	movs	r2, #0x0
 80119f4: 60da         	str	r2, [r3, #0xc]
; 	int nb_buckets = bucket_idx(h, heap_sz) + 1;
 80119f6: 6a39         	ldr	r1, [r7, #0x20]
 80119f8: 69f8         	ldr	r0, [r7, #0x1c]
 80119fa: f7ff ff55    	bl	0x80118a8 <bucket_idx>  @ imm = #-0x156
 80119fe: 4603         	mov	r3, r0
 8011a00: 3301         	adds	r3, #0x1
 8011a02: 61bb         	str	r3, [r7, #0x18]
; 	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
 8011a04: 69bb         	ldr	r3, [r7, #0x18]
 8011a06: 3304         	adds	r3, #0x4
 8011a08: 009b         	lsls	r3, r3, #0x2
 8011a0a: 4618         	mov	r0, r3
 8011a0c: f7ff ff20    	bl	0x8011850 <chunksz>     @ imm = #-0x1c0
 8011a10: 6178         	str	r0, [r7, #0x14]
; 	for (int i = 0; i < nb_buckets; i++) {
 8011a12: 2300         	movs	r3, #0x0
 8011a14: 62fb         	str	r3, [r7, #0x2c]
 8011a16: e008         	b	0x8011a2a <sys_heap_init+0x84> @ imm = #0x10
; 		h->buckets[i].next = 0;
 8011a18: 69fb         	ldr	r3, [r7, #0x1c]
 8011a1a: 6afa         	ldr	r2, [r7, #0x2c]
 8011a1c: 3204         	adds	r2, #0x4
 8011a1e: 2100         	movs	r1, #0x0
 8011a20: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 	for (int i = 0; i < nb_buckets; i++) {
 8011a24: 6afb         	ldr	r3, [r7, #0x2c]
 8011a26: 3301         	adds	r3, #0x1
 8011a28: 62fb         	str	r3, [r7, #0x2c]
 8011a2a: 6afa         	ldr	r2, [r7, #0x2c]
 8011a2c: 69bb         	ldr	r3, [r7, #0x18]
 8011a2e: 429a         	cmp	r2, r3
 8011a30: dbf2         	blt	0x8011a18 <sys_heap_init+0x72> @ imm = #-0x1c
; 	set_chunk_size(h, 0, chunk0_size);
 8011a32: 697a         	ldr	r2, [r7, #0x14]
 8011a34: 2100         	movs	r1, #0x0
 8011a36: 69f8         	ldr	r0, [r7, #0x1c]
 8011a38: f7ff fe7c    	bl	0x8011734 <set_chunk_size> @ imm = #-0x308
; 	set_left_chunk_size(h, 0, 0);
 8011a3c: 2200         	movs	r2, #0x0
 8011a3e: 2100         	movs	r1, #0x0
 8011a40: 69f8         	ldr	r0, [r7, #0x1c]
 8011a42: f7ff feb7    	bl	0x80117b4 <set_left_chunk_size> @ imm = #-0x292
; 	set_chunk_used(h, 0, true);
 8011a46: 2201         	movs	r2, #0x1
 8011a48: 2100         	movs	r1, #0x0
 8011a4a: 69f8         	ldr	r0, [r7, #0x1c]
 8011a4c: f7ff fe2d    	bl	0x80116aa <set_chunk_used> @ imm = #-0x3a6
; 	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
 8011a50: 6a3a         	ldr	r2, [r7, #0x20]
 8011a52: 697b         	ldr	r3, [r7, #0x14]
 8011a54: 1ad3         	subs	r3, r2, r3
 8011a56: 461a         	mov	r2, r3
 8011a58: 6979         	ldr	r1, [r7, #0x14]
 8011a5a: 69f8         	ldr	r0, [r7, #0x1c]
 8011a5c: f7ff fe6a    	bl	0x8011734 <set_chunk_size> @ imm = #-0x32c
; 	set_left_chunk_size(h, chunk0_size, chunk0_size);
 8011a60: 697a         	ldr	r2, [r7, #0x14]
 8011a62: 6979         	ldr	r1, [r7, #0x14]
 8011a64: 69f8         	ldr	r0, [r7, #0x1c]
 8011a66: f7ff fea5    	bl	0x80117b4 <set_left_chunk_size> @ imm = #-0x2b6
; 	set_chunk_size(h, heap_sz, 0);
 8011a6a: 2200         	movs	r2, #0x0
 8011a6c: 6a39         	ldr	r1, [r7, #0x20]
 8011a6e: 69f8         	ldr	r0, [r7, #0x1c]
 8011a70: f7ff fe60    	bl	0x8011734 <set_chunk_size> @ imm = #-0x340
; 	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
 8011a74: 6a3a         	ldr	r2, [r7, #0x20]
 8011a76: 697b         	ldr	r3, [r7, #0x14]
 8011a78: 1ad3         	subs	r3, r2, r3
 8011a7a: 461a         	mov	r2, r3
 8011a7c: 6a39         	ldr	r1, [r7, #0x20]
 8011a7e: 69f8         	ldr	r0, [r7, #0x1c]
 8011a80: f7ff fe98    	bl	0x80117b4 <set_left_chunk_size> @ imm = #-0x2d0
; 	set_chunk_used(h, heap_sz, true);
 8011a84: 2201         	movs	r2, #0x1
 8011a86: 6a39         	ldr	r1, [r7, #0x20]
 8011a88: 69f8         	ldr	r0, [r7, #0x1c]
 8011a8a: f7ff fe0e    	bl	0x80116aa <set_chunk_used> @ imm = #-0x3e4
; 	free_list_add(h, chunk0_size);
 8011a8e: 6979         	ldr	r1, [r7, #0x14]
 8011a90: 69f8         	ldr	r0, [r7, #0x1c]
 8011a92: f7ff ff66    	bl	0x8011962 <free_list_add> @ imm = #-0x134
; }
 8011a96: bf00         	nop
 8011a98: 3730         	adds	r7, #0x30
 8011a9a: 46bd         	mov	sp, r7
 8011a9c: bd80         	pop	{r7, pc}

08011a9e <ptr_in_rodata>:
; {
 8011a9e: b580         	push	{r7, lr}
 8011aa0: b082         	sub	sp, #0x8
 8011aa2: af00         	add	r7, sp, #0x0
 8011aa4: 6078         	str	r0, [r7, #0x4]
; 	return linker_is_in_rodata(addr);
 8011aa6: 6878         	ldr	r0, [r7, #0x4]
 8011aa8: f7ef fa34    	bl	0x8000f14 <linker_is_in_rodata> @ imm = #-0x10b98
 8011aac: 4603         	mov	r3, r0
; }
 8011aae: 4618         	mov	r0, r3
 8011ab0: 3708         	adds	r7, #0x8
 8011ab2: 46bd         	mov	sp, r7
 8011ab4: bd80         	pop	{r7, pc}

08011ab6 <cbprintf_via_va_list>:
; {
 8011ab6: b590         	push	{r4, r7, lr}
 8011ab8: b087         	sub	sp, #0x1c
 8011aba: af00         	add	r7, sp, #0x0
 8011abc: 60f8         	str	r0, [r7, #0xc]
 8011abe: 60b9         	str	r1, [r7, #0x8]
 8011ac0: 607a         	str	r2, [r7, #0x4]
 8011ac2: 603b         	str	r3, [r7]
; 	u.ptr = buf;
 8011ac4: 6abb         	ldr	r3, [r7, #0x28]
 8011ac6: 617b         	str	r3, [r7, #0x14]
; 	return formatter(out, ctx, fmt, u.ap);
 8011ac8: 68bc         	ldr	r4, [r7, #0x8]
 8011aca: 697b         	ldr	r3, [r7, #0x14]
 8011acc: 683a         	ldr	r2, [r7]
 8011ace: 6879         	ldr	r1, [r7, #0x4]
 8011ad0: 68f8         	ldr	r0, [r7, #0xc]
 8011ad2: 47a0         	blx	r4
 8011ad4: 4603         	mov	r3, r0
; }
 8011ad6: 4618         	mov	r0, r3
 8011ad8: 371c         	adds	r7, #0x1c
 8011ada: 46bd         	mov	sp, r7
 8011adc: bd90         	pop	{r4, r7, pc}

08011ade <cbpprintf_external>:
; {
 8011ade: b580         	push	{r7, lr}
 8011ae0: b090         	sub	sp, #0x40
 8011ae2: af02         	add	r7, sp, #0x8
 8011ae4: 60f8         	str	r0, [r7, #0xc]
 8011ae6: 60b9         	str	r1, [r7, #0x8]
 8011ae8: 607a         	str	r2, [r7, #0x4]
 8011aea: 603b         	str	r3, [r7]
; 	uint8_t *buf = packaged;
 8011aec: 683b         	ldr	r3, [r7]
 8011aee: 62fb         	str	r3, [r7, #0x2c]
; 	struct cbprintf_package_hdr_ext *hdr = packaged;
 8011af0: 683b         	ldr	r3, [r7]
 8011af2: 62bb         	str	r3, [r7, #0x28]
; 	if (buf == NULL) {
 8011af4: 6afb         	ldr	r3, [r7, #0x2c]
 8011af6: 2b00         	cmp	r3, #0x0
 8011af8: d102         	bne	0x8011b00 <cbpprintf_external+0x22> @ imm = #0x4
; 		return -EINVAL;
 8011afa: f06f 0315    	mvn	r3, #0x15
 8011afe: e043         	b	0x8011b88 <cbpprintf_external+0xaa> @ imm = #0x86
; 	args_size = hdr->hdr.desc.len * sizeof(int);
 8011b00: 6abb         	ldr	r3, [r7, #0x28]
 8011b02: 781b         	ldrb	r3, [r3]
 8011b04: 009b         	lsls	r3, r3, #0x2
 8011b06: 627b         	str	r3, [r7, #0x24]
; 	s_nbr     = hdr->hdr.desc.str_cnt;
 8011b08: 6abb         	ldr	r3, [r7, #0x28]
 8011b0a: 785b         	ldrb	r3, [r3, #0x1]
 8011b0c: 623b         	str	r3, [r7, #0x20]
; 	ros_nbr   = hdr->hdr.desc.ro_str_cnt;
 8011b0e: 6abb         	ldr	r3, [r7, #0x28]
 8011b10: 789b         	ldrb	r3, [r3, #0x2]
 8011b12: 61fb         	str	r3, [r7, #0x1c]
; 	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
 8011b14: 6abb         	ldr	r3, [r7, #0x28]
 8011b16: 78db         	ldrb	r3, [r3, #0x3]
 8011b18: 61bb         	str	r3, [r7, #0x18]
; 	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
 8011b1a: 6a7a         	ldr	r2, [r7, #0x24]
 8011b1c: 69fb         	ldr	r3, [r7, #0x1c]
 8011b1e: 441a         	add	r2, r3
 8011b20: 69bb         	ldr	r3, [r7, #0x18]
 8011b22: 005b         	lsls	r3, r3, #0x1
 8011b24: 4413         	add	r3, r2
 8011b26: 6afa         	ldr	r2, [r7, #0x2c]
 8011b28: 4413         	add	r3, r2
 8011b2a: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 8011b2c: 2300         	movs	r3, #0x0
 8011b2e: 633b         	str	r3, [r7, #0x30]
 8011b30: e018         	b	0x8011b64 <cbpprintf_external+0x86> @ imm = #0x30
; 		s_idx = *(uint8_t *)s;
 8011b32: 6b7b         	ldr	r3, [r7, #0x34]
 8011b34: 781b         	ldrb	r3, [r3]
 8011b36: 617b         	str	r3, [r7, #0x14]
; 		++s;
 8011b38: 6b7b         	ldr	r3, [r7, #0x34]
 8011b3a: 3301         	adds	r3, #0x1
 8011b3c: 637b         	str	r3, [r7, #0x34]
; 		ps = (char **)(buf + s_idx * sizeof(int));
 8011b3e: 697b         	ldr	r3, [r7, #0x14]
 8011b40: 009b         	lsls	r3, r3, #0x2
 8011b42: 6afa         	ldr	r2, [r7, #0x2c]
 8011b44: 4413         	add	r3, r2
 8011b46: 613b         	str	r3, [r7, #0x10]
; 		*ps = s;
 8011b48: 693b         	ldr	r3, [r7, #0x10]
 8011b4a: 6b7a         	ldr	r2, [r7, #0x34]
 8011b4c: 601a         	str	r2, [r3]
; 		s += strlen(s) + 1;
 8011b4e: 6b78         	ldr	r0, [r7, #0x34]
 8011b50: f7ee fff4    	bl	0x8000b3c <strlen>      @ imm = #-0x11018
 8011b54: 4603         	mov	r3, r0
 8011b56: 3301         	adds	r3, #0x1
 8011b58: 6b7a         	ldr	r2, [r7, #0x34]
 8011b5a: 4413         	add	r3, r2
 8011b5c: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 8011b5e: 6b3b         	ldr	r3, [r7, #0x30]
 8011b60: 3301         	adds	r3, #0x1
 8011b62: 633b         	str	r3, [r7, #0x30]
 8011b64: 6b3a         	ldr	r2, [r7, #0x30]
 8011b66: 6a3b         	ldr	r3, [r7, #0x20]
 8011b68: 429a         	cmp	r2, r3
 8011b6a: d3e2         	blo	0x8011b32 <cbpprintf_external+0x54> @ imm = #-0x3c
; 	buf += sizeof(*hdr);
 8011b6c: 6afb         	ldr	r3, [r7, #0x2c]
 8011b6e: 3308         	adds	r3, #0x8
 8011b70: 62fb         	str	r3, [r7, #0x2c]
; 	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
 8011b72: 6abb         	ldr	r3, [r7, #0x28]
 8011b74: 685a         	ldr	r2, [r3, #0x4]
 8011b76: 6afb         	ldr	r3, [r7, #0x2c]
 8011b78: 9300         	str	r3, [sp]
 8011b7a: 4613         	mov	r3, r2
 8011b7c: 687a         	ldr	r2, [r7, #0x4]
 8011b7e: 68b9         	ldr	r1, [r7, #0x8]
 8011b80: 68f8         	ldr	r0, [r7, #0xc]
 8011b82: f7ff ff98    	bl	0x8011ab6 <cbprintf_via_va_list> @ imm = #-0xd0
 8011b86: 4603         	mov	r3, r0
; }
 8011b88: 4618         	mov	r0, r3
 8011b8a: 3738         	adds	r7, #0x38
 8011b8c: 46bd         	mov	sp, r7
 8011b8e: bd80         	pop	{r7, pc}

08011b90 <arch_printk_char_out>:
; {
 8011b90: b480         	push	{r7}
 8011b92: b083         	sub	sp, #0xc
 8011b94: af00         	add	r7, sp, #0x0
 8011b96: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8011b98: 2300         	movs	r3, #0x0
; }
 8011b9a: 4618         	mov	r0, r3
 8011b9c: 370c         	adds	r7, #0xc
 8011b9e: 46bd         	mov	sp, r7
 8011ba0: bc80         	pop	{r7}
 8011ba2: 4770         	bx	lr

08011ba4 <vprintk>:
; {
 8011ba4: b580         	push	{r7, lr}
 8011ba6: b08c         	sub	sp, #0x30
 8011ba8: af00         	add	r7, sp, #0x0
 8011baa: 6078         	str	r0, [r7, #0x4]
 8011bac: 6039         	str	r1, [r7]
; 		z_log_vprintk(fmt, ap);
 8011bae: 6839         	ldr	r1, [r7]
 8011bb0: 6878         	ldr	r0, [r7, #0x4]
 8011bb2: f000 f949    	bl	0x8011e48 <z_log_vprintk> @ imm = #0x292
; 		return;
 8011bb6: bf00         	nop
; }
 8011bb8: 3730         	adds	r7, #0x30
 8011bba: 46bd         	mov	sp, r7
 8011bbc: bd80         	pop	{r7, pc}

08011bbe <printk>:
; {
 8011bbe: b40f         	push	{r0, r1, r2, r3}
 8011bc0: b580         	push	{r7, lr}
 8011bc2: b082         	sub	sp, #0x8
 8011bc4: af00         	add	r7, sp, #0x0
; 	va_start(ap, fmt);
 8011bc6: f107 0314    	add.w	r3, r7, #0x14
 8011bca: 607b         	str	r3, [r7, #0x4]
; 	vprintk(fmt, ap);
 8011bcc: 6879         	ldr	r1, [r7, #0x4]
 8011bce: 6938         	ldr	r0, [r7, #0x10]
 8011bd0: f7ff ffe8    	bl	0x8011ba4 <vprintk>     @ imm = #-0x30
; }
 8011bd4: bf00         	nop
 8011bd6: 3708         	adds	r7, #0x8
 8011bd8: 46bd         	mov	sp, r7
 8011bda: e8bd 4080    	pop.w	{r7, lr}
 8011bde: b004         	add	sp, #0x10
 8011be0: 4770         	bx	lr

08011be2 <k_sched_current_thread_query>:
; {
 8011be2: b580         	push	{r7, lr}
 8011be4: af00         	add	r7, sp, #0x0
; 	return z_impl_k_sched_current_thread_query();
 8011be6: f7fd f9e9    	bl	0x800efbc <z_impl_k_sched_current_thread_query> @ imm = #-0x2c2e
 8011bea: 4603         	mov	r3, r0
; }
 8011bec: 4618         	mov	r0, r3
 8011bee: bd80         	pop	{r7, pc}

08011bf0 <k_thread_abort>:
; {
 8011bf0: b580         	push	{r7, lr}
 8011bf2: b082         	sub	sp, #0x8
 8011bf4: af00         	add	r7, sp, #0x0
 8011bf6: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 8011bf8: 6878         	ldr	r0, [r7, #0x4]
 8011bfa: f7f1 fbd5    	bl	0x80033a8 <z_impl_k_thread_abort> @ imm = #-0xe856
; }
 8011bfe: bf00         	nop
 8011c00: 3708         	adds	r7, #0x8
 8011c02: 46bd         	mov	sp, r7
 8011c04: bd80         	pop	{r7, pc}

08011c06 <_ConfigAbsSyms>:
; GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
 8011c06: b480         	push	{r7}
 8011c08: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 8011c0a: bf00         	nop
 8011c0c: 46bd         	mov	sp, r7
 8011c0e: bc80         	pop	{r7}
 8011c10: 4770         	bx	lr

08011c12 <st_stm32_common_config>:
; {
 8011c12: b580         	push	{r7, lr}
 8011c14: af00         	add	r7, sp, #0x0
; 	LL_DBGMCU_DisableDBGStopMode();
 8011c16: f7ef fdab    	bl	0x8001770 <LL_DBGMCU_DisableDBGStopMode> @ imm = #-0x104aa
; 	return 0;
 8011c1a: 2300         	movs	r3, #0x0
; }
 8011c1c: 4618         	mov	r0, r3
 8011c1e: bd80         	pop	{r7, pc}

08011c20 <atomic_add>:
; {
 8011c20: b490         	push	{r4, r7}
 8011c22: b082         	sub	sp, #0x8
 8011c24: af00         	add	r7, sp, #0x0
 8011c26: 6078         	str	r0, [r7, #0x4]
 8011c28: 6039         	str	r1, [r7]
; 	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 8011c2a: 683a         	ldr	r2, [r7]
 8011c2c: 687b         	ldr	r3, [r7, #0x4]
 8011c2e: f3bf 8f5b    	dmb	ish
 8011c32: e853 1f00    	ldrex	r1, [r3]
 8011c36: eb01 0002    	add.w	r0, r1, r2
 8011c3a: e843 0400    	strex	r4, r0, [r3]
 8011c3e: 2c00         	cmp	r4, #0x0
 8011c40: d1f7         	bne	0x8011c32 <atomic_add+0x12> @ imm = #-0x12
 8011c42: f3bf 8f5b    	dmb	ish
 8011c46: 460b         	mov	r3, r1
; }
 8011c48: 4618         	mov	r0, r3
 8011c4a: 3708         	adds	r7, #0x8
 8011c4c: 46bd         	mov	sp, r7
 8011c4e: bc90         	pop	{r4, r7}
 8011c50: 4770         	bx	lr

08011c52 <atomic_sub>:
; {
 8011c52: b490         	push	{r4, r7}
 8011c54: b082         	sub	sp, #0x8
 8011c56: af00         	add	r7, sp, #0x0
 8011c58: 6078         	str	r0, [r7, #0x4]
 8011c5a: 6039         	str	r1, [r7]
; 	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 8011c5c: 683a         	ldr	r2, [r7]
 8011c5e: 687b         	ldr	r3, [r7, #0x4]
 8011c60: f3bf 8f5b    	dmb	ish
 8011c64: e853 1f00    	ldrex	r1, [r3]
 8011c68: eba1 0002    	sub.w	r0, r1, r2
 8011c6c: e843 0400    	strex	r4, r0, [r3]
 8011c70: 2c00         	cmp	r4, #0x0
 8011c72: d1f7         	bne	0x8011c64 <atomic_sub+0x12> @ imm = #-0x12
 8011c74: f3bf 8f5b    	dmb	ish
 8011c78: 460b         	mov	r3, r1
; }
 8011c7a: 4618         	mov	r0, r3
 8011c7c: 3708         	adds	r7, #0x8
 8011c7e: 46bd         	mov	sp, r7
 8011c80: bc90         	pop	{r4, r7}
 8011c82: 4770         	bx	lr

08011c84 <atomic_inc>:
; {
 8011c84: b580         	push	{r7, lr}
 8011c86: b082         	sub	sp, #0x8
 8011c88: af00         	add	r7, sp, #0x0
 8011c8a: 6078         	str	r0, [r7, #0x4]
; 	return atomic_add(target, 1);
 8011c8c: 2101         	movs	r1, #0x1
 8011c8e: 6878         	ldr	r0, [r7, #0x4]
 8011c90: f7ff ffc6    	bl	0x8011c20 <atomic_add>  @ imm = #-0x74
 8011c94: 4603         	mov	r3, r0
; }
 8011c96: 4618         	mov	r0, r3
 8011c98: 3708         	adds	r7, #0x8
 8011c9a: 46bd         	mov	sp, r7
 8011c9c: bd80         	pop	{r7, pc}

08011c9e <atomic_dec>:
; {
 8011c9e: b580         	push	{r7, lr}
 8011ca0: b082         	sub	sp, #0x8
 8011ca2: af00         	add	r7, sp, #0x0
 8011ca4: 6078         	str	r0, [r7, #0x4]
; 	return atomic_sub(target, 1);
 8011ca6: 2101         	movs	r1, #0x1
 8011ca8: 6878         	ldr	r0, [r7, #0x4]
 8011caa: f7ff ffd2    	bl	0x8011c52 <atomic_sub>  @ imm = #-0x5c
 8011cae: 4603         	mov	r3, r0
; }
 8011cb0: 4618         	mov	r0, r3
 8011cb2: 3708         	adds	r7, #0x8
 8011cb4: 46bd         	mov	sp, r7
 8011cb6: bd80         	pop	{r7, pc}

08011cb8 <z_log_item_is_msg>:
; {
 8011cb8: b480         	push	{r7}
 8011cba: b083         	sub	sp, #0xc
 8011cbc: af00         	add	r7, sp, #0x0
 8011cbe: 6078         	str	r0, [r7, #0x4]
; 	return msg->generic.type == Z_LOG_MSG_LOG;
 8011cc0: 687b         	ldr	r3, [r7, #0x4]
 8011cc2: 781b         	ldrb	r3, [r3]
 8011cc4: f003 0304    	and	r3, r3, #0x4
 8011cc8: b2db         	uxtb	r3, r3
 8011cca: 2b00         	cmp	r3, #0x0
 8011ccc: bf0c         	ite	eq
 8011cce: 2301         	moveq	r3, #0x1
 8011cd0: 2300         	movne	r3, #0x0
 8011cd2: b2db         	uxtb	r3, r3
; }
 8011cd4: 4618         	mov	r0, r3
 8011cd6: 370c         	adds	r7, #0xc
 8011cd8: 46bd         	mov	sp, r7
 8011cda: bc80         	pop	{r7}
 8011cdc: 4770         	bx	lr

08011cde <k_msleep>:
; {
 8011cde: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8011ce2: b082         	sub	sp, #0x8
 8011ce4: af00         	add	r7, sp, #0x0
 8011ce6: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 8011ce8: 6879         	ldr	r1, [r7, #0x4]
 8011cea: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 8011cee: 17c8         	asrs	r0, r1, #0x1f
 8011cf0: 4688         	mov	r8, r1
 8011cf2: 4681         	mov	r9, r0
 8011cf4: 4640         	mov	r0, r8
 8011cf6: 4649         	mov	r1, r9
 8011cf8: f04f 0400    	mov.w	r4, #0x0
 8011cfc: f04f 0500    	mov.w	r5, #0x0
 8011d00: 008d         	lsls	r5, r1, #0x2
 8011d02: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 8011d06: 0084         	lsls	r4, r0, #0x2
 8011d08: 4620         	mov	r0, r4
 8011d0a: 4629         	mov	r1, r5
 8011d0c: eb10 0208    	adds.w	r2, r0, r8
 8011d10: eb41 0309    	adc.w	r3, r1, r9
 8011d14: eb12 0a02    	adds.w	r10, r2, r2
 8011d18: eb43 0b03    	adc.w	r11, r3, r3
 8011d1c: 4652         	mov	r2, r10
 8011d1e: 465b         	mov	r3, r11
 8011d20: 4610         	mov	r0, r2
 8011d22: 4619         	mov	r1, r3
 8011d24: f000 f823    	bl	0x8011d6e <k_sleep>     @ imm = #0x46
 8011d28: 4601         	mov	r1, r0
 8011d2a: 460b         	mov	r3, r1
; }
 8011d2c: 4618         	mov	r0, r3
 8011d2e: 3708         	adds	r7, #0x8
 8011d30: 46bd         	mov	sp, r7
 8011d32: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08011d36 <k_uptime_get>:
; {
 8011d36: b580         	push	{r7, lr}
 8011d38: af00         	add	r7, sp, #0x0
; 	return k_ticks_to_ms_floor64(k_uptime_ticks());
 8011d3a: f000 f826    	bl	0x8011d8a <k_uptime_ticks> @ imm = #0x4c
 8011d3e: 4602         	mov	r2, r0
 8011d40: 460b         	mov	r3, r1
 8011d42: 4610         	mov	r0, r2
 8011d44: 4619         	mov	r1, r3
 8011d46: f04f 020a    	mov.w	r2, #0xa
 8011d4a: f04f 0300    	mov.w	r3, #0x0
 8011d4e: f7ee fed1    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x1125e
 8011d52: 4602         	mov	r2, r0
 8011d54: 460b         	mov	r3, r1
; }
 8011d56: 4610         	mov	r0, r2
 8011d58: 4619         	mov	r1, r3
 8011d5a: bd80         	pop	{r7, pc}

08011d5c <k_uptime_get_32>:
; {
 8011d5c: b580         	push	{r7, lr}
 8011d5e: af00         	add	r7, sp, #0x0
; 	return (uint32_t)k_uptime_get();
 8011d60: f7ff ffe9    	bl	0x8011d36 <k_uptime_get> @ imm = #-0x2e
 8011d64: 4602         	mov	r2, r0
 8011d66: 460b         	mov	r3, r1
 8011d68: 4613         	mov	r3, r2
; }
 8011d6a: 4618         	mov	r0, r3
 8011d6c: bd80         	pop	{r7, pc}

08011d6e <k_sleep>:
; {
 8011d6e: b580         	push	{r7, lr}
 8011d70: b082         	sub	sp, #0x8
 8011d72: af00         	add	r7, sp, #0x0
 8011d74: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8011d78: e9d7 0100    	ldrd	r0, r1, [r7]
 8011d7c: f7fd f8dc    	bl	0x800ef38 <z_impl_k_sleep> @ imm = #-0x2e48
 8011d80: 4603         	mov	r3, r0
; }
 8011d82: 4618         	mov	r0, r3
 8011d84: 3708         	adds	r7, #0x8
 8011d86: 46bd         	mov	sp, r7
 8011d88: bd80         	pop	{r7, pc}

08011d8a <k_uptime_ticks>:
; {
 8011d8a: b580         	push	{r7, lr}
 8011d8c: af00         	add	r7, sp, #0x0
; 	return z_impl_k_uptime_ticks();
 8011d8e: f008 fc5c    	bl	0x801a64a <z_impl_k_uptime_ticks> @ imm = #0x88b8
 8011d92: 4602         	mov	r2, r0
 8011d94: 460b         	mov	r3, r1
; }
 8011d96: 4610         	mov	r0, r2
 8011d98: 4619         	mov	r1, r3
 8011d9a: bd80         	pop	{r7, pc}

08011d9c <log_backend_init>:
; {
 8011d9c: b580         	push	{r7, lr}
 8011d9e: b082         	sub	sp, #0x8
 8011da0: af00         	add	r7, sp, #0x0
 8011da2: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->init) {
 8011da4: 687b         	ldr	r3, [r7, #0x4]
 8011da6: 681b         	ldr	r3, [r3]
 8011da8: 68db         	ldr	r3, [r3, #0xc]
 8011daa: 2b00         	cmp	r3, #0x0
 8011dac: d004         	beq	0x8011db8 <log_backend_init+0x1c> @ imm = #0x8
; 		backend->api->init(backend);
 8011dae: 687b         	ldr	r3, [r7, #0x4]
 8011db0: 681b         	ldr	r3, [r3]
 8011db2: 68db         	ldr	r3, [r3, #0xc]
 8011db4: 6878         	ldr	r0, [r7, #0x4]
 8011db6: 4798         	blx	r3
; }
 8011db8: bf00         	nop
 8011dba: 3708         	adds	r7, #0x8
 8011dbc: 46bd         	mov	sp, r7
 8011dbe: bd80         	pop	{r7, pc}

08011dc0 <log_backend_is_ready>:
; {
 8011dc0: b580         	push	{r7, lr}
 8011dc2: b082         	sub	sp, #0x8
 8011dc4: af00         	add	r7, sp, #0x0
 8011dc6: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->is_ready != NULL) {
 8011dc8: 687b         	ldr	r3, [r7, #0x4]
 8011dca: 681b         	ldr	r3, [r3]
 8011dcc: 691b         	ldr	r3, [r3, #0x10]
 8011dce: 2b00         	cmp	r3, #0x0
 8011dd0: d006         	beq	0x8011de0 <log_backend_is_ready+0x20> @ imm = #0xc
; 		return backend->api->is_ready(backend);
 8011dd2: 687b         	ldr	r3, [r7, #0x4]
 8011dd4: 681b         	ldr	r3, [r3]
 8011dd6: 691b         	ldr	r3, [r3, #0x10]
 8011dd8: 6878         	ldr	r0, [r7, #0x4]
 8011dda: 4798         	blx	r3
 8011ddc: 4603         	mov	r3, r0
 8011dde: e000         	b	0x8011de2 <log_backend_is_ready+0x22> @ imm = #0x0
; 	return 0;
 8011de0: 2300         	movs	r3, #0x0
; }
 8011de2: 4618         	mov	r0, r3
 8011de4: 3708         	adds	r7, #0x8
 8011de6: 46bd         	mov	sp, r7
 8011de8: bd80         	pop	{r7, pc}

08011dea <log_backend_msg_process>:
; {
 8011dea: b580         	push	{r7, lr}
 8011dec: b082         	sub	sp, #0x8
 8011dee: af00         	add	r7, sp, #0x0
 8011df0: 6078         	str	r0, [r7, #0x4]
 8011df2: 6039         	str	r1, [r7]
; 	backend->api->process(backend, msg);
 8011df4: 687b         	ldr	r3, [r7, #0x4]
 8011df6: 681b         	ldr	r3, [r3]
 8011df8: 681b         	ldr	r3, [r3]
 8011dfa: 6839         	ldr	r1, [r7]
 8011dfc: 6878         	ldr	r0, [r7, #0x4]
 8011dfe: 4798         	blx	r3
; }
 8011e00: bf00         	nop
 8011e02: 3708         	adds	r7, #0x8
 8011e04: 46bd         	mov	sp, r7
 8011e06: bd80         	pop	{r7, pc}

08011e08 <log_backend_panic>:
; {
 8011e08: b580         	push	{r7, lr}
 8011e0a: b082         	sub	sp, #0x8
 8011e0c: af00         	add	r7, sp, #0x0
 8011e0e: 6078         	str	r0, [r7, #0x4]
; 	backend->api->panic(backend);
 8011e10: 687b         	ldr	r3, [r7, #0x4]
 8011e12: 681b         	ldr	r3, [r3]
 8011e14: 689b         	ldr	r3, [r3, #0x8]
 8011e16: 6878         	ldr	r0, [r7, #0x4]
 8011e18: 4798         	blx	r3
; }
 8011e1a: bf00         	nop
 8011e1c: 3708         	adds	r7, #0x8
 8011e1e: 46bd         	mov	sp, r7
 8011e20: bd80         	pop	{r7, pc}

08011e22 <log_backend_is_active>:
; {
 8011e22: b480         	push	{r7}
 8011e24: b083         	sub	sp, #0xc
 8011e26: af00         	add	r7, sp, #0x0
 8011e28: 6078         	str	r0, [r7, #0x4]
; 	return backend->cb->active;
 8011e2a: 687b         	ldr	r3, [r7, #0x4]
 8011e2c: 685b         	ldr	r3, [r3, #0x4]
 8011e2e: 795b         	ldrb	r3, [r3, #0x5]
; }
 8011e30: 4618         	mov	r0, r3
 8011e32: 370c         	adds	r7, #0xc
 8011e34: 46bd         	mov	sp, r7
 8011e36: bc80         	pop	{r7}
 8011e38: 4770         	bx	lr

08011e3a <dummy_timestamp>:
; {
 8011e3a: b480         	push	{r7}
 8011e3c: af00         	add	r7, sp, #0x0
; 	return 0;
 8011e3e: 2300         	movs	r3, #0x0
; }
 8011e40: 4618         	mov	r0, r3
 8011e42: 46bd         	mov	sp, r7
 8011e44: bc80         	pop	{r7}
 8011e46: 4770         	bx	lr

08011e48 <z_log_vprintk>:
; {
 8011e48: b580         	push	{r7, lr}
 8011e4a: b086         	sub	sp, #0x18
 8011e4c: af04         	add	r7, sp, #0x10
 8011e4e: 6078         	str	r0, [r7, #0x4]
 8011e50: 6039         	str	r1, [r7]
; 	z_log_msg_runtime_vcreate(Z_LOG_LOCAL_DOMAIN_ID, NULL,
 8011e52: 683b         	ldr	r3, [r7]
 8011e54: 9303         	str	r3, [sp, #0xc]
 8011e56: 687b         	ldr	r3, [r7, #0x4]
 8011e58: 9302         	str	r3, [sp, #0x8]
 8011e5a: 2300         	movs	r3, #0x0
 8011e5c: 9301         	str	r3, [sp, #0x4]
 8011e5e: 2300         	movs	r3, #0x0
 8011e60: 9300         	str	r3, [sp]
 8011e62: 2300         	movs	r3, #0x0
 8011e64: 2200         	movs	r2, #0x0
 8011e66: 2100         	movs	r1, #0x0
 8011e68: 2000         	movs	r0, #0x0
 8011e6a: f7ef feff    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x10202
; }
 8011e6e: 3708         	adds	r7, #0x8
 8011e70: 46bd         	mov	sp, r7
 8011e72: bd80         	pop	{r7, pc}

08011e74 <default_lf_get_timestamp>:
; {
 8011e74: b580         	push	{r7, lr}
 8011e76: af00         	add	r7, sp, #0x0
; 		k_uptime_get() : k_uptime_get_32();
 8011e78: f7ff ff70    	bl	0x8011d5c <k_uptime_get_32> @ imm = #-0x120
 8011e7c: 4603         	mov	r3, r0
; }
 8011e7e: 4618         	mov	r0, r3
 8011e80: bd80         	pop	{r7, pc}

08011e82 <activate_foreach_backend>:
; {
 8011e82: b580         	push	{r7, lr}
 8011e84: b086         	sub	sp, #0x18
 8011e86: af00         	add	r7, sp, #0x0
 8011e88: 6078         	str	r0, [r7, #0x4]
; 	uint32_t mask_cpy = mask;
 8011e8a: 687b         	ldr	r3, [r7, #0x4]
 8011e8c: 617b         	str	r3, [r7, #0x14]
; 	while (mask_cpy) {
 8011e8e: e02b         	b	0x8011ee8 <activate_foreach_backend+0x66> @ imm = #0x56
; 		uint32_t i = __builtin_ctz(mask_cpy);
 8011e90: 697b         	ldr	r3, [r7, #0x14]
 8011e92: fa93 f3a3    	rbit	r3, r3
 8011e96: fab3 f383    	clz	r3, r3
 8011e9a: 613b         	str	r3, [r7, #0x10]
; 		const struct log_backend *backend = log_backend_get(i);
 8011e9c: 6938         	ldr	r0, [r7, #0x10]
 8011e9e: f7ef fcb1    	bl	0x8001804 <log_backend_get> @ imm = #-0x1069e
 8011ea2: 60f8         	str	r0, [r7, #0xc]
; 		mask_cpy &= ~BIT(i);
 8011ea4: 2201         	movs	r2, #0x1
 8011ea6: 693b         	ldr	r3, [r7, #0x10]
 8011ea8: fa02 f303    	lsl.w	r3, r2, r3
 8011eac: 43db         	mvns	r3, r3
 8011eae: 697a         	ldr	r2, [r7, #0x14]
 8011eb0: 4013         	ands	r3, r2
 8011eb2: 617b         	str	r3, [r7, #0x14]
; 		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
 8011eb4: 68fb         	ldr	r3, [r7, #0xc]
 8011eb6: 7b1b         	ldrb	r3, [r3, #0xc]
 8011eb8: 2b00         	cmp	r3, #0x0
 8011eba: d015         	beq	0x8011ee8 <activate_foreach_backend+0x66> @ imm = #0x2a
 8011ebc: 68f8         	ldr	r0, [r7, #0xc]
 8011ebe: f7ff ff7f    	bl	0x8011dc0 <log_backend_is_ready> @ imm = #-0x102
 8011ec2: 4603         	mov	r3, r0
 8011ec4: 2b00         	cmp	r3, #0x0
 8011ec6: d10f         	bne	0x8011ee8 <activate_foreach_backend+0x66> @ imm = #0x1e
; 			mask &= ~BIT(i);
 8011ec8: 2201         	movs	r2, #0x1
 8011eca: 693b         	ldr	r3, [r7, #0x10]
 8011ecc: fa02 f303    	lsl.w	r3, r2, r3
 8011ed0: 43db         	mvns	r3, r3
 8011ed2: 687a         	ldr	r2, [r7, #0x4]
 8011ed4: 4013         	ands	r3, r2
 8011ed6: 607b         	str	r3, [r7, #0x4]
; 					   backend->cb->ctx,
 8011ed8: 68fb         	ldr	r3, [r7, #0xc]
 8011eda: 685b         	ldr	r3, [r3, #0x4]
; 			log_backend_enable(backend,
 8011edc: 681b         	ldr	r3, [r3]
 8011ede: 2204         	movs	r2, #0x4
 8011ee0: 4619         	mov	r1, r3
 8011ee2: 68f8         	ldr	r0, [r7, #0xc]
 8011ee4: f000 f8c8    	bl	0x8012078 <log_backend_enable> @ imm = #0x190
; 	while (mask_cpy) {
 8011ee8: 697b         	ldr	r3, [r7, #0x14]
 8011eea: 2b00         	cmp	r3, #0x0
 8011eec: d1d0         	bne	0x8011e90 <activate_foreach_backend+0xe> @ imm = #-0x60
; 	return mask;
 8011eee: 687b         	ldr	r3, [r7, #0x4]
; }
 8011ef0: 4618         	mov	r0, r3
 8011ef2: 3718         	adds	r7, #0x18
 8011ef4: 46bd         	mov	sp, r7
 8011ef6: bd80         	pop	{r7, pc}

08011ef8 <msg_filter_check>:
; {
 8011ef8: b580         	push	{r7, lr}
 8011efa: b082         	sub	sp, #0x8
 8011efc: af00         	add	r7, sp, #0x0
 8011efe: 6078         	str	r0, [r7, #0x4]
 8011f00: 6039         	str	r1, [r7]
; 	if (!z_log_item_is_msg(msg)) {
 8011f02: 6838         	ldr	r0, [r7]
 8011f04: f7ff fed8    	bl	0x8011cb8 <z_log_item_is_msg> @ imm = #-0x250
 8011f08: 4603         	mov	r3, r0
 8011f0a: f083 0301    	eor	r3, r3, #0x1
 8011f0e: b2db         	uxtb	r3, r3
 8011f10: 2b00         	cmp	r3, #0x0
 8011f12: d001         	beq	0x8011f18 <msg_filter_check+0x20> @ imm = #0x2
; 		return true;
 8011f14: 2301         	movs	r3, #0x1
 8011f16: e000         	b	0x8011f1a <msg_filter_check+0x22> @ imm = #0x0
; 		return true;
 8011f18: 2301         	movs	r3, #0x1
; }
 8011f1a: 4618         	mov	r0, r3
 8011f1c: 3708         	adds	r7, #0x8
 8011f1e: 46bd         	mov	sp, r7
 8011f20: bd80         	pop	{r7, pc}

08011f22 <msg_commit>:
; {
 8011f22: b580         	push	{r7, lr}
 8011f24: b084         	sub	sp, #0x10
 8011f26: af00         	add	r7, sp, #0x0
 8011f28: 6078         	str	r0, [r7, #0x4]
 8011f2a: 6039         	str	r1, [r7]
; 	union log_msg_generic *m = (union log_msg_generic *)msg;
 8011f2c: 683b         	ldr	r3, [r7]
 8011f2e: 60fb         	str	r3, [r7, #0xc]
; 		msg_process(m);
 8011f30: 68f8         	ldr	r0, [r7, #0xc]
 8011f32: f7ef fd53    	bl	0x80019dc <msg_process> @ imm = #-0x1055a
; }
 8011f36: 3710         	adds	r7, #0x10
 8011f38: 46bd         	mov	sp, r7
 8011f3a: bd80         	pop	{r7, pc}

08011f3c <z_log_get_tag>:
; {
 8011f3c: b480         	push	{r7}
 8011f3e: af00         	add	r7, sp, #0x0
; 	return CONFIG_LOG_TAG_MAX_LEN > 0 ? tag : NULL;
 8011f40: 2300         	movs	r3, #0x0
; }
 8011f42: 4618         	mov	r0, r3
 8011f44: 46bd         	mov	sp, r7
 8011f46: bc80         	pop	{r7}
 8011f48: 4770         	bx	lr

08011f4a <enable_logger>:
; {
 8011f4a: b580         	push	{r7, lr}
 8011f4c: af00         	add	r7, sp, #0x0
; 		(void)z_log_init(false, false);
 8011f4e: 2100         	movs	r1, #0x0
 8011f50: 2000         	movs	r0, #0x0
 8011f52: f7ef fc93    	bl	0x800187c <z_log_init>  @ imm = #-0x106da
; 	return 0;
 8011f56: 2300         	movs	r3, #0x0
; }
 8011f58: 4618         	mov	r0, r3
 8011f5a: bd80         	pop	{r7, pc}

08011f5c <z_log_is_local_domain>:
; {
 8011f5c: b480         	push	{r7}
 8011f5e: b083         	sub	sp, #0xc
 8011f60: af00         	add	r7, sp, #0x0
 8011f62: 4603         	mov	r3, r0
 8011f64: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 8011f66: 2301         	movs	r3, #0x1
; }
 8011f68: 4618         	mov	r0, r3
 8011f6a: 370c         	adds	r7, #0xc
 8011f6c: 46bd         	mov	sp, r7
 8011f6e: bc80         	pop	{r7}
 8011f70: 4770         	bx	lr

08011f72 <log_backend_id_set>:
; {
 8011f72: b480         	push	{r7}
 8011f74: b083         	sub	sp, #0xc
 8011f76: af00         	add	r7, sp, #0x0
 8011f78: 6078         	str	r0, [r7, #0x4]
 8011f7a: 460b         	mov	r3, r1
 8011f7c: 70fb         	strb	r3, [r7, #0x3]
; 	backend->cb->id = id;
 8011f7e: 687b         	ldr	r3, [r7, #0x4]
 8011f80: 685b         	ldr	r3, [r3, #0x4]
 8011f82: 78fa         	ldrb	r2, [r7, #0x3]
 8011f84: 711a         	strb	r2, [r3, #0x4]
; }
 8011f86: bf00         	nop
 8011f88: 370c         	adds	r7, #0xc
 8011f8a: 46bd         	mov	sp, r7
 8011f8c: bc80         	pop	{r7}
 8011f8e: 4770         	bx	lr

08011f90 <log_backend_activate>:
; {
 8011f90: b480         	push	{r7}
 8011f92: b083         	sub	sp, #0xc
 8011f94: af00         	add	r7, sp, #0x0
 8011f96: 6078         	str	r0, [r7, #0x4]
 8011f98: 6039         	str	r1, [r7]
; 	backend->cb->ctx = ctx;
 8011f9a: 687b         	ldr	r3, [r7, #0x4]
 8011f9c: 685b         	ldr	r3, [r3, #0x4]
 8011f9e: 683a         	ldr	r2, [r7]
 8011fa0: 601a         	str	r2, [r3]
; 	backend->cb->active = true;
 8011fa2: 687b         	ldr	r3, [r7, #0x4]
 8011fa4: 685b         	ldr	r3, [r3, #0x4]
 8011fa6: 2201         	movs	r2, #0x1
 8011fa8: 715a         	strb	r2, [r3, #0x5]
; }
 8011faa: bf00         	nop
 8011fac: 370c         	adds	r7, #0xc
 8011fae: 46bd         	mov	sp, r7
 8011fb0: bc80         	pop	{r7}
 8011fb2: 4770         	bx	lr

08011fb4 <log_link_sources_count>:
; {
 8011fb4: b480         	push	{r7}
 8011fb6: b083         	sub	sp, #0xc
 8011fb8: af00         	add	r7, sp, #0x0
 8011fba: 6078         	str	r0, [r7, #0x4]
 8011fbc: 6039         	str	r1, [r7]
; 	return link->ctrl_blk->source_cnt[domain_id];
 8011fbe: 687b         	ldr	r3, [r7, #0x4]
 8011fc0: 689a         	ldr	r2, [r3, #0x8]
 8011fc2: 683b         	ldr	r3, [r7]
 8011fc4: 005b         	lsls	r3, r3, #0x1
 8011fc6: 4413         	add	r3, r2
 8011fc8: 889b         	ldrh	r3, [r3, #0x4]
; }
 8011fca: 4618         	mov	r0, r3
 8011fcc: 370c         	adds	r7, #0xc
 8011fce: 46bd         	mov	sp, r7
 8011fd0: bc80         	pop	{r7}
 8011fd2: 4770         	bx	lr

08011fd4 <log_link_get_source_name>:
; {
 8011fd4: b590         	push	{r4, r7, lr}
 8011fd6: b087         	sub	sp, #0x1c
 8011fd8: af02         	add	r7, sp, #0x8
 8011fda: 60f8         	str	r0, [r7, #0xc]
 8011fdc: 60b9         	str	r1, [r7, #0x8]
 8011fde: 603b         	str	r3, [r7]
 8011fe0: 4613         	mov	r3, r2
 8011fe2: 80fb         	strh	r3, [r7, #0x6]
; 	return link->api->get_source_name(link, domain_id, source_id,
 8011fe4: 68fb         	ldr	r3, [r7, #0xc]
 8011fe6: 681b         	ldr	r3, [r3]
 8011fe8: 68dc         	ldr	r4, [r3, #0xc]
 8011fea: 88fa         	ldrh	r2, [r7, #0x6]
 8011fec: 6a3b         	ldr	r3, [r7, #0x20]
 8011fee: 9300         	str	r3, [sp]
 8011ff0: 683b         	ldr	r3, [r7]
 8011ff2: 68b9         	ldr	r1, [r7, #0x8]
 8011ff4: 68f8         	ldr	r0, [r7, #0xc]
 8011ff6: 47a0         	blx	r4
 8011ff8: 4603         	mov	r3, r0
; }
 8011ffa: 4618         	mov	r0, r3
 8011ffc: 3714         	adds	r7, #0x14
 8011ffe: 46bd         	mov	sp, r7
 8012000: bd90         	pop	{r4, r7, pc}

08012002 <link_source_count>:
; {
 8012002: b580         	push	{r7, lr}
 8012004: b084         	sub	sp, #0x10
 8012006: af00         	add	r7, sp, #0x0
 8012008: 4603         	mov	r3, r0
 801200a: 71fb         	strb	r3, [r7, #0x7]
; 	const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 801200c: f107 020b    	add.w	r2, r7, #0xb
 8012010: 79fb         	ldrb	r3, [r7, #0x7]
 8012012: 4611         	mov	r1, r2
 8012014: 4618         	mov	r0, r3
 8012016: f7ef fd73    	bl	0x8001b00 <get_link_domain> @ imm = #-0x1051a
 801201a: 60f8         	str	r0, [r7, #0xc]
; 	return log_link_sources_count(link, rel_domain_id);
 801201c: 7afb         	ldrb	r3, [r7, #0xb]
 801201e: 4619         	mov	r1, r3
 8012020: 68f8         	ldr	r0, [r7, #0xc]
 8012022: f7ff ffc7    	bl	0x8011fb4 <log_link_sources_count> @ imm = #-0x72
 8012026: 4603         	mov	r3, r0
; }
 8012028: 4618         	mov	r0, r3
 801202a: 3710         	adds	r7, #0x10
 801202c: 46bd         	mov	sp, r7
 801202e: bd80         	pop	{r7, pc}

08012030 <log_src_cnt_get>:
; {
 8012030: b580         	push	{r7, lr}
 8012032: b082         	sub	sp, #0x8
 8012034: af00         	add	r7, sp, #0x0
 8012036: 6078         	str	r0, [r7, #0x4]
; 	if (z_log_is_local_domain(domain_id)) {
 8012038: 687b         	ldr	r3, [r7, #0x4]
 801203a: b2db         	uxtb	r3, r3
 801203c: 4618         	mov	r0, r3
 801203e: f7ff ff8d    	bl	0x8011f5c <z_log_is_local_domain> @ imm = #-0xe6
 8012042: 4603         	mov	r3, r0
 8012044: 2b00         	cmp	r3, #0x0
 8012046: d003         	beq	0x8012050 <log_src_cnt_get+0x20> @ imm = #0x6
; 		return z_log_sources_count();
 8012048: f7ef fd3e    	bl	0x8001ac8 <z_log_sources_count> @ imm = #-0x10584
 801204c: 4603         	mov	r3, r0
 801204e: e005         	b	0x801205c <log_src_cnt_get+0x2c> @ imm = #0xa
; 	return link_source_count(domain_id);
 8012050: 687b         	ldr	r3, [r7, #0x4]
 8012052: b2db         	uxtb	r3, r3
 8012054: 4618         	mov	r0, r3
 8012056: f7ff ffd4    	bl	0x8012002 <link_source_count> @ imm = #-0x58
 801205a: 4603         	mov	r3, r0
; }
 801205c: 4618         	mov	r0, r3
 801205e: 3708         	adds	r7, #0x8
 8012060: 46bd         	mov	sp, r7
 8012062: bd80         	pop	{r7, pc}

08012064 <backend_filter_set>:
; {
 8012064: b480         	push	{r7}
 8012066: b083         	sub	sp, #0xc
 8012068: af00         	add	r7, sp, #0x0
 801206a: 6078         	str	r0, [r7, #0x4]
 801206c: 6039         	str	r1, [r7]
; 		return;
 801206e: bf00         	nop
; }
 8012070: 370c         	adds	r7, #0xc
 8012072: 46bd         	mov	sp, r7
 8012074: bc80         	pop	{r7}
 8012076: 4770         	bx	lr

08012078 <log_backend_enable>:
; {
 8012078: b580         	push	{r7, lr}
 801207a: b086         	sub	sp, #0x18
 801207c: af00         	add	r7, sp, #0x0
 801207e: 60f8         	str	r0, [r7, #0xc]
 8012080: 60b9         	str	r1, [r7, #0x8]
 8012082: 607a         	str	r2, [r7, #0x4]
; 	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;
 8012084: 2301         	movs	r3, #0x1
 8012086: 617b         	str	r3, [r7, #0x14]
; 	id += backend - log_backend_get(0);
 8012088: 2000         	movs	r0, #0x0
 801208a: f7ef fd27    	bl	0x8001adc <log_backend_get> @ imm = #-0x105b2
 801208e: 4602         	mov	r2, r0
 8012090: 68fb         	ldr	r3, [r7, #0xc]
 8012092: 1a9b         	subs	r3, r3, r2
 8012094: 111b         	asrs	r3, r3, #0x4
 8012096: 461a         	mov	r2, r3
 8012098: 697b         	ldr	r3, [r7, #0x14]
 801209a: 4413         	add	r3, r2
 801209c: 617b         	str	r3, [r7, #0x14]
; 	log_backend_id_set(backend, id);
 801209e: 697b         	ldr	r3, [r7, #0x14]
 80120a0: b2db         	uxtb	r3, r3
 80120a2: 4619         	mov	r1, r3
 80120a4: 68f8         	ldr	r0, [r7, #0xc]
 80120a6: f7ff ff64    	bl	0x8011f72 <log_backend_id_set> @ imm = #-0x138
; 	backend->cb->level = level;
 80120aa: 68fb         	ldr	r3, [r7, #0xc]
 80120ac: 685b         	ldr	r3, [r3, #0x4]
 80120ae: 687a         	ldr	r2, [r7, #0x4]
 80120b0: b2d2         	uxtb	r2, r2
 80120b2: 719a         	strb	r2, [r3, #0x6]
; 	backend_filter_set(backend, level);
 80120b4: 6879         	ldr	r1, [r7, #0x4]
 80120b6: 68f8         	ldr	r0, [r7, #0xc]
 80120b8: f7ff ffd4    	bl	0x8012064 <backend_filter_set> @ imm = #-0x58
; 	log_backend_activate(backend, ctx);
 80120bc: 68b9         	ldr	r1, [r7, #0x8]
 80120be: 68f8         	ldr	r0, [r7, #0xc]
 80120c0: f7ff ff66    	bl	0x8011f90 <log_backend_activate> @ imm = #-0x134
; 	z_log_notify_backend_enabled();
 80120c4: f7ef fcb8    	bl	0x8001a38 <z_log_notify_backend_enabled> @ imm = #-0x10690
; }
 80120c8: bf00         	nop
 80120ca: 3718         	adds	r7, #0x18
 80120cc: 46bd         	mov	sp, r7
 80120ce: bd80         	pop	{r7, pc}

080120d0 <z_snode_next_peek>:
; {
 80120d0: b480         	push	{r7}
 80120d2: b083         	sub	sp, #0xc
 80120d4: af00         	add	r7, sp, #0x0
 80120d6: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 80120d8: 687b         	ldr	r3, [r7, #0x4]
 80120da: 681b         	ldr	r3, [r3]
; }
 80120dc: 4618         	mov	r0, r3
 80120de: 370c         	adds	r7, #0xc
 80120e0: 46bd         	mov	sp, r7
 80120e2: bc80         	pop	{r7}
 80120e4: 4770         	bx	lr

080120e6 <z_snode_next_set>:
; {
 80120e6: b480         	push	{r7}
 80120e8: b083         	sub	sp, #0xc
 80120ea: af00         	add	r7, sp, #0x0
 80120ec: 6078         	str	r0, [r7, #0x4]
 80120ee: 6039         	str	r1, [r7]
; 	parent->next = child;
 80120f0: 687b         	ldr	r3, [r7, #0x4]
 80120f2: 683a         	ldr	r2, [r7]
 80120f4: 601a         	str	r2, [r3]
; }
 80120f6: bf00         	nop
 80120f8: 370c         	adds	r7, #0xc
 80120fa: 46bd         	mov	sp, r7
 80120fc: bc80         	pop	{r7}
 80120fe: 4770         	bx	lr

08012100 <z_slist_head_set>:
; {
 8012100: b480         	push	{r7}
 8012102: b083         	sub	sp, #0xc
 8012104: af00         	add	r7, sp, #0x0
 8012106: 6078         	str	r0, [r7, #0x4]
 8012108: 6039         	str	r1, [r7]
; 	list->head = node;
 801210a: 687b         	ldr	r3, [r7, #0x4]
 801210c: 683a         	ldr	r2, [r7]
 801210e: 601a         	str	r2, [r3]
; }
 8012110: bf00         	nop
 8012112: 370c         	adds	r7, #0xc
 8012114: 46bd         	mov	sp, r7
 8012116: bc80         	pop	{r7}
 8012118: 4770         	bx	lr

0801211a <z_slist_tail_set>:
; {
 801211a: b480         	push	{r7}
 801211c: b083         	sub	sp, #0xc
 801211e: af00         	add	r7, sp, #0x0
 8012120: 6078         	str	r0, [r7, #0x4]
 8012122: 6039         	str	r1, [r7]
; 	list->tail = node;
 8012124: 687b         	ldr	r3, [r7, #0x4]
 8012126: 683a         	ldr	r2, [r7]
 8012128: 605a         	str	r2, [r3, #0x4]
; }
 801212a: bf00         	nop
 801212c: 370c         	adds	r7, #0xc
 801212e: 46bd         	mov	sp, r7
 8012130: bc80         	pop	{r7}
 8012132: 4770         	bx	lr

08012134 <sys_slist_peek_head>:
; {
 8012134: b480         	push	{r7}
 8012136: b083         	sub	sp, #0xc
 8012138: af00         	add	r7, sp, #0x0
 801213a: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 801213c: 687b         	ldr	r3, [r7, #0x4]
 801213e: 681b         	ldr	r3, [r3]
; }
 8012140: 4618         	mov	r0, r3
 8012142: 370c         	adds	r7, #0xc
 8012144: 46bd         	mov	sp, r7
 8012146: bc80         	pop	{r7}
 8012148: 4770         	bx	lr

0801214a <sys_slist_peek_tail>:
; {
 801214a: b480         	push	{r7}
 801214c: b083         	sub	sp, #0xc
 801214e: af00         	add	r7, sp, #0x0
 8012150: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 8012152: 687b         	ldr	r3, [r7, #0x4]
 8012154: 685b         	ldr	r3, [r3, #0x4]
; }
 8012156: 4618         	mov	r0, r3
 8012158: 370c         	adds	r7, #0xc
 801215a: 46bd         	mov	sp, r7
 801215c: bc80         	pop	{r7}
 801215e: 4770         	bx	lr

08012160 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 8012160: b580         	push	{r7, lr}
 8012162: b082         	sub	sp, #0x8
 8012164: af00         	add	r7, sp, #0x0
 8012166: 6078         	str	r0, [r7, #0x4]
 8012168: 6878         	ldr	r0, [r7, #0x4]
 801216a: f7ff ffe3    	bl	0x8012134 <sys_slist_peek_head> @ imm = #-0x3a
 801216e: 4603         	mov	r3, r0
 8012170: 2b00         	cmp	r3, #0x0
 8012172: bf0c         	ite	eq
 8012174: 2301         	moveq	r3, #0x1
 8012176: 2300         	movne	r3, #0x0
 8012178: b2db         	uxtb	r3, r3
 801217a: 4618         	mov	r0, r3
 801217c: 3708         	adds	r7, #0x8
 801217e: 46bd         	mov	sp, r7
 8012180: bd80         	pop	{r7, pc}

08012182 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8012182: b580         	push	{r7, lr}
 8012184: b082         	sub	sp, #0x8
 8012186: af00         	add	r7, sp, #0x0
 8012188: 6078         	str	r0, [r7, #0x4]
 801218a: 6878         	ldr	r0, [r7, #0x4]
 801218c: f7ff ffa0    	bl	0x80120d0 <z_snode_next_peek> @ imm = #-0xc0
 8012190: 4603         	mov	r3, r0
 8012192: 4618         	mov	r0, r3
 8012194: 3708         	adds	r7, #0x8
 8012196: 46bd         	mov	sp, r7
 8012198: bd80         	pop	{r7, pc}

0801219a <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 801219a: b580         	push	{r7, lr}
 801219c: b082         	sub	sp, #0x8
 801219e: af00         	add	r7, sp, #0x0
 80121a0: 6078         	str	r0, [r7, #0x4]
 80121a2: 687b         	ldr	r3, [r7, #0x4]
 80121a4: 2b00         	cmp	r3, #0x0
 80121a6: d004         	beq	0x80121b2 <sys_slist_peek_next+0x18> @ imm = #0x8
 80121a8: 6878         	ldr	r0, [r7, #0x4]
 80121aa: f7ff ffea    	bl	0x8012182 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 80121ae: 4603         	mov	r3, r0
 80121b0: e000         	b	0x80121b4 <sys_slist_peek_next+0x1a> @ imm = #0x0
 80121b2: 2300         	movs	r3, #0x0
 80121b4: 4618         	mov	r0, r3
 80121b6: 3708         	adds	r7, #0x8
 80121b8: 46bd         	mov	sp, r7
 80121ba: bd80         	pop	{r7, pc}

080121bc <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 80121bc: b580         	push	{r7, lr}
 80121be: b082         	sub	sp, #0x8
 80121c0: af00         	add	r7, sp, #0x0
 80121c2: 6078         	str	r0, [r7, #0x4]
 80121c4: 6039         	str	r1, [r7]
 80121c6: 6878         	ldr	r0, [r7, #0x4]
 80121c8: f7ff ffb4    	bl	0x8012134 <sys_slist_peek_head> @ imm = #-0x98
 80121cc: 4603         	mov	r3, r0
 80121ce: 4619         	mov	r1, r3
 80121d0: 6838         	ldr	r0, [r7]
 80121d2: f7ff ff88    	bl	0x80120e6 <z_snode_next_set> @ imm = #-0xf0
 80121d6: 6839         	ldr	r1, [r7]
 80121d8: 6878         	ldr	r0, [r7, #0x4]
 80121da: f7ff ff91    	bl	0x8012100 <z_slist_head_set> @ imm = #-0xde
 80121de: 6878         	ldr	r0, [r7, #0x4]
 80121e0: f7ff ffb3    	bl	0x801214a <sys_slist_peek_tail> @ imm = #-0x9a
 80121e4: 4603         	mov	r3, r0
 80121e6: 2b00         	cmp	r3, #0x0
 80121e8: d107         	bne	0x80121fa <sys_slist_prepend+0x3e> @ imm = #0xe
 80121ea: 6878         	ldr	r0, [r7, #0x4]
 80121ec: f7ff ffa2    	bl	0x8012134 <sys_slist_peek_head> @ imm = #-0xbc
 80121f0: 4603         	mov	r3, r0
 80121f2: 4619         	mov	r1, r3
 80121f4: 6878         	ldr	r0, [r7, #0x4]
 80121f6: f7ff ff90    	bl	0x801211a <z_slist_tail_set> @ imm = #-0xe0
 80121fa: 3708         	adds	r7, #0x8
 80121fc: 46bd         	mov	sp, r7
 80121fe: bd80         	pop	{r7, pc}

08012200 <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 8012200: b580         	push	{r7, lr}
 8012202: b084         	sub	sp, #0x10
 8012204: af00         	add	r7, sp, #0x0
 8012206: 6078         	str	r0, [r7, #0x4]
 8012208: 6878         	ldr	r0, [r7, #0x4]
 801220a: f7ff ff93    	bl	0x8012134 <sys_slist_peek_head> @ imm = #-0xda
 801220e: 60f8         	str	r0, [r7, #0xc]
 8012210: 68f8         	ldr	r0, [r7, #0xc]
 8012212: f7ff ff5d    	bl	0x80120d0 <z_snode_next_peek> @ imm = #-0x146
 8012216: 4603         	mov	r3, r0
 8012218: 4619         	mov	r1, r3
 801221a: 6878         	ldr	r0, [r7, #0x4]
 801221c: f7ff ff70    	bl	0x8012100 <z_slist_head_set> @ imm = #-0x120
 8012220: 6878         	ldr	r0, [r7, #0x4]
 8012222: f7ff ff92    	bl	0x801214a <sys_slist_peek_tail> @ imm = #-0xdc
 8012226: 4602         	mov	r2, r0
 8012228: 68fb         	ldr	r3, [r7, #0xc]
 801222a: 4293         	cmp	r3, r2
 801222c: d107         	bne	0x801223e <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 801222e: 6878         	ldr	r0, [r7, #0x4]
 8012230: f7ff ff80    	bl	0x8012134 <sys_slist_peek_head> @ imm = #-0x100
 8012234: 4603         	mov	r3, r0
 8012236: 4619         	mov	r1, r3
 8012238: 6878         	ldr	r0, [r7, #0x4]
 801223a: f7ff ff6e    	bl	0x801211a <z_slist_tail_set> @ imm = #-0x124
 801223e: 68fb         	ldr	r3, [r7, #0xc]
 8012240: 4618         	mov	r0, r3
 8012242: 3710         	adds	r7, #0x10
 8012244: 46bd         	mov	sp, r7
 8012246: bd80         	pop	{r7, pc}

08012248 <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 8012248: b580         	push	{r7, lr}
 801224a: b082         	sub	sp, #0x8
 801224c: af00         	add	r7, sp, #0x0
 801224e: 6078         	str	r0, [r7, #0x4]
 8012250: 6878         	ldr	r0, [r7, #0x4]
 8012252: f7ff ff85    	bl	0x8012160 <sys_slist_is_empty> @ imm = #-0xf6
 8012256: 4603         	mov	r3, r0
 8012258: 2b00         	cmp	r3, #0x0
 801225a: d104         	bne	0x8012266 <sys_slist_get+0x1e> @ imm = #0x8
 801225c: 6878         	ldr	r0, [r7, #0x4]
 801225e: f7ff ffcf    	bl	0x8012200 <sys_slist_get_not_empty> @ imm = #-0x62
 8012262: 4603         	mov	r3, r0
 8012264: e000         	b	0x8012268 <sys_slist_get+0x20> @ imm = #0x0
 8012266: 2300         	movs	r3, #0x0
 8012268: 4618         	mov	r0, r3
 801226a: 3708         	adds	r7, #0x8
 801226c: 46bd         	mov	sp, r7
 801226e: bd80         	pop	{r7, pc}

08012270 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 8012270: b580         	push	{r7, lr}
 8012272: b084         	sub	sp, #0x10
 8012274: af00         	add	r7, sp, #0x0
 8012276: 60f8         	str	r0, [r7, #0xc]
 8012278: 60b9         	str	r1, [r7, #0x8]
 801227a: 607a         	str	r2, [r7, #0x4]
 801227c: 68bb         	ldr	r3, [r7, #0x8]
 801227e: 2b00         	cmp	r3, #0x0
 8012280: d117         	bne	0x80122b2 <sys_slist_remove+0x42> @ imm = #0x2e
 8012282: 6878         	ldr	r0, [r7, #0x4]
 8012284: f7ff ff24    	bl	0x80120d0 <z_snode_next_peek> @ imm = #-0x1b8
 8012288: 4603         	mov	r3, r0
 801228a: 4619         	mov	r1, r3
 801228c: 68f8         	ldr	r0, [r7, #0xc]
 801228e: f7ff ff37    	bl	0x8012100 <z_slist_head_set> @ imm = #-0x192
 8012292: 68f8         	ldr	r0, [r7, #0xc]
 8012294: f7ff ff59    	bl	0x801214a <sys_slist_peek_tail> @ imm = #-0x14e
 8012298: 4602         	mov	r2, r0
 801229a: 687b         	ldr	r3, [r7, #0x4]
 801229c: 4293         	cmp	r3, r2
 801229e: d11b         	bne	0x80122d8 <sys_slist_remove+0x68> @ imm = #0x36
 80122a0: 68f8         	ldr	r0, [r7, #0xc]
 80122a2: f7ff ff47    	bl	0x8012134 <sys_slist_peek_head> @ imm = #-0x172
 80122a6: 4603         	mov	r3, r0
 80122a8: 4619         	mov	r1, r3
 80122aa: 68f8         	ldr	r0, [r7, #0xc]
 80122ac: f7ff ff35    	bl	0x801211a <z_slist_tail_set> @ imm = #-0x196
 80122b0: e012         	b	0x80122d8 <sys_slist_remove+0x68> @ imm = #0x24
 80122b2: 6878         	ldr	r0, [r7, #0x4]
 80122b4: f7ff ff0c    	bl	0x80120d0 <z_snode_next_peek> @ imm = #-0x1e8
 80122b8: 4603         	mov	r3, r0
 80122ba: 4619         	mov	r1, r3
 80122bc: 68b8         	ldr	r0, [r7, #0x8]
 80122be: f7ff ff12    	bl	0x80120e6 <z_snode_next_set> @ imm = #-0x1dc
 80122c2: 68f8         	ldr	r0, [r7, #0xc]
 80122c4: f7ff ff41    	bl	0x801214a <sys_slist_peek_tail> @ imm = #-0x17e
 80122c8: 4602         	mov	r2, r0
 80122ca: 687b         	ldr	r3, [r7, #0x4]
 80122cc: 4293         	cmp	r3, r2
 80122ce: d103         	bne	0x80122d8 <sys_slist_remove+0x68> @ imm = #0x6
 80122d0: 68b9         	ldr	r1, [r7, #0x8]
 80122d2: 68f8         	ldr	r0, [r7, #0xc]
 80122d4: f7ff ff21    	bl	0x801211a <z_slist_tail_set> @ imm = #-0x1be
 80122d8: 2100         	movs	r1, #0x0
 80122da: 6878         	ldr	r0, [r7, #0x4]
 80122dc: f7ff ff03    	bl	0x80120e6 <z_snode_next_set> @ imm = #-0x1fa
 80122e0: 3710         	adds	r7, #0x10
 80122e2: 46bd         	mov	sp, r7
 80122e4: bd80         	pop	{r7, pc}

080122e6 <log_cache_get>:
; {
 80122e6: b590         	push	{r4, r7, lr}
 80122e8: b089         	sub	sp, #0x24
 80122ea: af00         	add	r7, sp, #0x0
 80122ec: 60f8         	str	r0, [r7, #0xc]
 80122ee: 60b9         	str	r1, [r7, #0x8]
 80122f0: 607a         	str	r2, [r7, #0x4]
; 	sys_snode_t *prev_node = NULL;
 80122f2: 2300         	movs	r3, #0x0
 80122f4: 61fb         	str	r3, [r7, #0x1c]
; 	bool hit = false;
 80122f6: 2300         	movs	r3, #0x0
 80122f8: 75fb         	strb	r3, [r7, #0x17]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 80122fa: 68fb         	ldr	r3, [r7, #0xc]
 80122fc: 4618         	mov	r0, r3
 80122fe: f7ff ff19    	bl	0x8012134 <sys_slist_peek_head> @ imm = #-0x1ce
 8012302: 4603         	mov	r3, r0
 8012304: 2b00         	cmp	r3, #0x0
 8012306: d005         	beq	0x8012314 <log_cache_get+0x2e> @ imm = #0xa
 8012308: 68fb         	ldr	r3, [r7, #0xc]
 801230a: 4618         	mov	r0, r3
 801230c: f7ff ff12    	bl	0x8012134 <sys_slist_peek_head> @ imm = #-0x1dc
 8012310: 4603         	mov	r3, r0
 8012312: e000         	b	0x8012316 <log_cache_get+0x30> @ imm = #0x0
 8012314: 2300         	movs	r3, #0x0
 8012316: 61bb         	str	r3, [r7, #0x18]
 8012318: e02f         	b	0x801237a <log_cache_get+0x94> @ imm = #0x5e
; 		if (cache->cmp(entry->id, id)) {
 801231a: 68fb         	ldr	r3, [r7, #0xc]
 801231c: 691b         	ldr	r3, [r3, #0x10]
 801231e: 69ba         	ldr	r2, [r7, #0x18]
 8012320: 6852         	ldr	r2, [r2, #0x4]
 8012322: 68b9         	ldr	r1, [r7, #0x8]
 8012324: 4610         	mov	r0, r2
 8012326: 4798         	blx	r3
 8012328: 4603         	mov	r3, r0
 801232a: 2b00         	cmp	r3, #0x0
 801232c: d007         	beq	0x801233e <log_cache_get+0x58> @ imm = #0xe
; 			cache->hit++;
 801232e: 68fb         	ldr	r3, [r7, #0xc]
 8012330: 695b         	ldr	r3, [r3, #0x14]
 8012332: 1c5a         	adds	r2, r3, #0x1
 8012334: 68fb         	ldr	r3, [r7, #0xc]
 8012336: 615a         	str	r2, [r3, #0x14]
; 			hit = true;
 8012338: 2301         	movs	r3, #0x1
 801233a: 75fb         	strb	r3, [r7, #0x17]
; 			break;
 801233c: e022         	b	0x8012384 <log_cache_get+0x9e> @ imm = #0x44
; 		if (&entry->node == sys_slist_peek_tail(&cache->active)) {
 801233e: 69bc         	ldr	r4, [r7, #0x18]
 8012340: 68fb         	ldr	r3, [r7, #0xc]
 8012342: 4618         	mov	r0, r3
 8012344: f7ff ff01    	bl	0x801214a <sys_slist_peek_tail> @ imm = #-0x1fe
 8012348: 4603         	mov	r3, r0
 801234a: 429c         	cmp	r4, r3
 801234c: d019         	beq	0x8012382 <log_cache_get+0x9c> @ imm = #0x32
; 		prev_node = &entry->node;
 801234e: 69bb         	ldr	r3, [r7, #0x18]
 8012350: 61fb         	str	r3, [r7, #0x1c]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 8012352: 69bb         	ldr	r3, [r7, #0x18]
 8012354: 2b00         	cmp	r3, #0x0
 8012356: d00e         	beq	0x8012376 <log_cache_get+0x90> @ imm = #0x1c
 8012358: 69bb         	ldr	r3, [r7, #0x18]
 801235a: 4618         	mov	r0, r3
 801235c: f7ff ff1d    	bl	0x801219a <sys_slist_peek_next> @ imm = #-0x1c6
 8012360: 4603         	mov	r3, r0
 8012362: 2b00         	cmp	r3, #0x0
 8012364: d005         	beq	0x8012372 <log_cache_get+0x8c> @ imm = #0xa
 8012366: 69bb         	ldr	r3, [r7, #0x18]
 8012368: 4618         	mov	r0, r3
 801236a: f7ff ff16    	bl	0x801219a <sys_slist_peek_next> @ imm = #-0x1d4
 801236e: 4603         	mov	r3, r0
 8012370: e002         	b	0x8012378 <log_cache_get+0x92> @ imm = #0x4
 8012372: 2300         	movs	r3, #0x0
 8012374: e000         	b	0x8012378 <log_cache_get+0x92> @ imm = #0x0
 8012376: 2300         	movs	r3, #0x0
 8012378: 61bb         	str	r3, [r7, #0x18]
 801237a: 69bb         	ldr	r3, [r7, #0x18]
 801237c: 2b00         	cmp	r3, #0x0
 801237e: d1cc         	bne	0x801231a <log_cache_get+0x34> @ imm = #-0x68
 8012380: e000         	b	0x8012384 <log_cache_get+0x9e> @ imm = #0x0
; 			break;
 8012382: bf00         	nop
; 	if (hit) {
 8012384: 7dfb         	ldrb	r3, [r7, #0x17]
 8012386: 2b00         	cmp	r3, #0x0
 8012388: d00c         	beq	0x80123a4 <log_cache_get+0xbe> @ imm = #0x18
; 		sys_slist_remove(&cache->active, prev_node, &entry->node);
 801238a: 68fb         	ldr	r3, [r7, #0xc]
 801238c: 69ba         	ldr	r2, [r7, #0x18]
 801238e: 69f9         	ldr	r1, [r7, #0x1c]
 8012390: 4618         	mov	r0, r3
 8012392: f7ff ff6d    	bl	0x8012270 <sys_slist_remove> @ imm = #-0x126
; 		sys_slist_prepend(&cache->active, &entry->node);
 8012396: 68fb         	ldr	r3, [r7, #0xc]
 8012398: 69ba         	ldr	r2, [r7, #0x18]
 801239a: 4611         	mov	r1, r2
 801239c: 4618         	mov	r0, r3
 801239e: f7ff ff0d    	bl	0x80121bc <sys_slist_prepend> @ imm = #-0x1e6
 80123a2: e016         	b	0x80123d2 <log_cache_get+0xec> @ imm = #0x2c
; 		cache->miss++;
 80123a4: 68fb         	ldr	r3, [r7, #0xc]
 80123a6: 699b         	ldr	r3, [r3, #0x18]
 80123a8: 1c5a         	adds	r2, r3, #0x1
 80123aa: 68fb         	ldr	r3, [r7, #0xc]
 80123ac: 619a         	str	r2, [r3, #0x18]
; 		sys_snode_t *from_idle = sys_slist_get(&cache->idle);
 80123ae: 68fb         	ldr	r3, [r7, #0xc]
 80123b0: 3308         	adds	r3, #0x8
 80123b2: 4618         	mov	r0, r3
 80123b4: f7ff ff48    	bl	0x8012248 <sys_slist_get> @ imm = #-0x170
 80123b8: 6138         	str	r0, [r7, #0x10]
; 		if (from_idle) {
 80123ba: 693b         	ldr	r3, [r7, #0x10]
 80123bc: 2b00         	cmp	r3, #0x0
 80123be: d002         	beq	0x80123c6 <log_cache_get+0xe0> @ imm = #0x4
; 			entry = CONTAINER_OF(from_idle, struct log_cache_entry, node);
 80123c0: 693b         	ldr	r3, [r7, #0x10]
 80123c2: 61bb         	str	r3, [r7, #0x18]
 80123c4: e005         	b	0x80123d2 <log_cache_get+0xec> @ imm = #0xa
; 			sys_slist_remove(&cache->active, prev_node, &entry->node);
 80123c6: 68fb         	ldr	r3, [r7, #0xc]
 80123c8: 69ba         	ldr	r2, [r7, #0x18]
 80123ca: 69f9         	ldr	r1, [r7, #0x1c]
 80123cc: 4618         	mov	r0, r3
 80123ce: f7ff ff4f    	bl	0x8012270 <sys_slist_remove> @ imm = #-0x162
; 	*data = entry->data;
 80123d2: 69bb         	ldr	r3, [r7, #0x18]
 80123d4: f103 0208    	add.w	r2, r3, #0x8
 80123d8: 687b         	ldr	r3, [r7, #0x4]
 80123da: 601a         	str	r2, [r3]
; 	entry->id = id;
 80123dc: 69bb         	ldr	r3, [r7, #0x18]
 80123de: 68ba         	ldr	r2, [r7, #0x8]
 80123e0: 605a         	str	r2, [r3, #0x4]
; 	return hit;
 80123e2: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 80123e4: 4618         	mov	r0, r3
 80123e6: 3724         	adds	r7, #0x24
 80123e8: 46bd         	mov	sp, r7
 80123ea: bd90         	pop	{r4, r7, pc}

080123ec <log_cache_put>:
; {
 80123ec: b580         	push	{r7, lr}
 80123ee: b084         	sub	sp, #0x10
 80123f0: af00         	add	r7, sp, #0x0
 80123f2: 6078         	str	r0, [r7, #0x4]
 80123f4: 6039         	str	r1, [r7]
; 	struct log_cache_entry *entry = CONTAINER_OF(data, struct log_cache_entry, data[0]);
 80123f6: 683b         	ldr	r3, [r7]
 80123f8: 3b08         	subs	r3, #0x8
 80123fa: 60fb         	str	r3, [r7, #0xc]
; 	sys_slist_prepend(&cache->active, &entry->node);
 80123fc: 687b         	ldr	r3, [r7, #0x4]
 80123fe: 68fa         	ldr	r2, [r7, #0xc]
 8012400: 4611         	mov	r1, r2
 8012402: 4618         	mov	r0, r3
 8012404: f7ff feda    	bl	0x80121bc <sys_slist_prepend> @ imm = #-0x24c
; }
 8012408: bf00         	nop
 801240a: 3710         	adds	r7, #0x10
 801240c: 46bd         	mov	sp, r7
 801240e: bd80         	pop	{r7, pc}

08012410 <z_log_msg_runtime_create>:
; {
 8012410: b580         	push	{r7, lr}
 8012412: b08a         	sub	sp, #0x28
 8012414: af04         	add	r7, sp, #0x10
 8012416: 60b9         	str	r1, [r7, #0x8]
 8012418: 607b         	str	r3, [r7, #0x4]
 801241a: 4603         	mov	r3, r0
 801241c: 73fb         	strb	r3, [r7, #0xf]
 801241e: 4613         	mov	r3, r2
 8012420: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8012422: f107 032c    	add.w	r3, r7, #0x2c
 8012426: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8012428: 7bba         	ldrb	r2, [r7, #0xe]
 801242a: 7bf8         	ldrb	r0, [r7, #0xf]
 801242c: 697b         	ldr	r3, [r7, #0x14]
 801242e: 9303         	str	r3, [sp, #0xc]
 8012430: 6abb         	ldr	r3, [r7, #0x28]
 8012432: 9302         	str	r3, [sp, #0x8]
 8012434: 6a7b         	ldr	r3, [r7, #0x24]
 8012436: 9301         	str	r3, [sp, #0x4]
 8012438: 6a3b         	ldr	r3, [r7, #0x20]
 801243a: 9300         	str	r3, [sp]
 801243c: 687b         	ldr	r3, [r7, #0x4]
 801243e: 68b9         	ldr	r1, [r7, #0x8]
 8012440: f7ef fc14    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x107d8
; }
 8012444: bf00         	nop
 8012446: 3718         	adds	r7, #0x18
 8012448: 46bd         	mov	sp, r7
 801244a: bd80         	pop	{r7, pc}

0801244c <log_msg_get_domain>:
; {
 801244c: b480         	push	{r7}
 801244e: b083         	sub	sp, #0xc
 8012450: af00         	add	r7, sp, #0x0
 8012452: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 8012454: 687b         	ldr	r3, [r7, #0x4]
 8012456: 781b         	ldrb	r3, [r3]
 8012458: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 801245c: b2db         	uxtb	r3, r3
; }
 801245e: 4618         	mov	r0, r3
 8012460: 370c         	adds	r7, #0xc
 8012462: 46bd         	mov	sp, r7
 8012464: bc80         	pop	{r7}
 8012466: 4770         	bx	lr

08012468 <log_msg_get_source>:
; {
 8012468: b480         	push	{r7}
 801246a: b083         	sub	sp, #0xc
 801246c: af00         	add	r7, sp, #0x0
 801246e: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.source;
 8012470: 687b         	ldr	r3, [r7, #0x4]
 8012472: 685b         	ldr	r3, [r3, #0x4]
; }
 8012474: 4618         	mov	r0, r3
 8012476: 370c         	adds	r7, #0xc
 8012478: 46bd         	mov	sp, r7
 801247a: bc80         	pop	{r7}
 801247c: 4770         	bx	lr

0801247e <log_source_id>:
; {
 801247e: b580         	push	{r7, lr}
 8012480: b082         	sub	sp, #0x8
 8012482: af00         	add	r7, sp, #0x0
 8012484: 6078         	str	r0, [r7, #0x4]
; 		log_dynamic_source_id((struct log_source_dynamic_data *)source) :
 8012486: 6878         	ldr	r0, [r7, #0x4]
 8012488: f7ef fbe0    	bl	0x8001c4c <log_const_source_id> @ imm = #-0x10840
 801248c: 4603         	mov	r3, r0
; }
 801248e: 4618         	mov	r0, r3
 8012490: 3708         	adds	r7, #0x8
 8012492: 46bd         	mov	sp, r7
 8012494: bd80         	pop	{r7, pc}

08012496 <z_log_is_local_domain>:
; {
 8012496: b480         	push	{r7}
 8012498: b083         	sub	sp, #0xc
 801249a: af00         	add	r7, sp, #0x0
 801249c: 4603         	mov	r3, r0
 801249e: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 80124a0: 2301         	movs	r3, #0x1
; }
 80124a2: 4618         	mov	r0, r3
 80124a4: 370c         	adds	r7, #0xc
 80124a6: 46bd         	mov	sp, r7
 80124a8: bc80         	pop	{r7}
 80124aa: 4770         	bx	lr

080124ac <z_log_msg_finalize>:
; {
 80124ac: b580         	push	{r7, lr}
 80124ae: b086         	sub	sp, #0x18
 80124b0: af00         	add	r7, sp, #0x0
 80124b2: 60f8         	str	r0, [r7, #0xc]
 80124b4: 60b9         	str	r1, [r7, #0x8]
 80124b6: 607a         	str	r2, [r7, #0x4]
 80124b8: 603b         	str	r3, [r7]
; 	if (!msg) {
 80124ba: 68fb         	ldr	r3, [r7, #0xc]
 80124bc: 2b00         	cmp	r3, #0x0
 80124be: d103         	bne	0x80124c8 <z_log_msg_finalize+0x1c> @ imm = #0x6
; 		z_log_dropped(false);
 80124c0: 2000         	movs	r0, #0x0
 80124c2: f7ef fac5    	bl	0x8001a50 <z_log_dropped> @ imm = #-0x10a76
; 		return;
 80124c6: e01c         	b	0x8012502 <z_log_msg_finalize+0x56> @ imm = #0x38
; 	if (data) {
 80124c8: 683b         	ldr	r3, [r7]
 80124ca: 2b00         	cmp	r3, #0x0
 80124cc: d010         	beq	0x80124f0 <z_log_msg_finalize+0x44> @ imm = #0x20
; 		uint8_t *d = msg->data + desc.package_len;
 80124ce: 68fb         	ldr	r3, [r7, #0xc]
 80124d0: 3310         	adds	r3, #0x10
 80124d2: 687a         	ldr	r2, [r7, #0x4]
 80124d4: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 80124d8: b292         	uxth	r2, r2
 80124da: 4413         	add	r3, r2
 80124dc: 617b         	str	r3, [r7, #0x14]
; 		memcpy(d, data, desc.data_len);
 80124de: 88fb         	ldrh	r3, [r7, #0x6]
 80124e0: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 80124e4: b29b         	uxth	r3, r3
 80124e6: 461a         	mov	r2, r3
 80124e8: 6839         	ldr	r1, [r7]
 80124ea: 6978         	ldr	r0, [r7, #0x14]
 80124ec: f008 f992    	bl	0x801a814 <memcpy>      @ imm = #0x8324
; 	msg->hdr.desc = desc;
 80124f0: 68fb         	ldr	r3, [r7, #0xc]
 80124f2: 687a         	ldr	r2, [r7, #0x4]
 80124f4: 601a         	str	r2, [r3]
; 	msg->hdr.source = source;
 80124f6: 68fb         	ldr	r3, [r7, #0xc]
 80124f8: 68ba         	ldr	r2, [r7, #0x8]
 80124fa: 605a         	str	r2, [r3, #0x4]
; 	z_log_msg_commit(msg);
 80124fc: 68f8         	ldr	r0, [r7, #0xc]
 80124fe: f7ef fabd    	bl	0x8001a7c <z_log_msg_commit> @ imm = #-0x10a86
; }
 8012502: 3718         	adds	r7, #0x18
 8012504: 46bd         	mov	sp, r7
 8012506: bd80         	pop	{r7, pc}

08012508 <log_msg_get_source_id>:
; {
 8012508: b580         	push	{r7, lr}
 801250a: b084         	sub	sp, #0x10
 801250c: af00         	add	r7, sp, #0x0
 801250e: 6078         	str	r0, [r7, #0x4]
; 	if (!z_log_is_local_domain(log_msg_get_domain(msg))) {
 8012510: 6878         	ldr	r0, [r7, #0x4]
 8012512: f7ff ff9b    	bl	0x801244c <log_msg_get_domain> @ imm = #-0xca
 8012516: 4603         	mov	r3, r0
 8012518: 4618         	mov	r0, r3
 801251a: f7ff ffbc    	bl	0x8012496 <z_log_is_local_domain> @ imm = #-0x88
 801251e: 4603         	mov	r3, r0
 8012520: f083 0301    	eor	r3, r3, #0x1
 8012524: b2db         	uxtb	r3, r3
 8012526: 2b00         	cmp	r3, #0x0
 8012528: d005         	beq	0x8012536 <log_msg_get_source_id+0x2e> @ imm = #0xa
; 		return (int16_t)(uintptr_t)log_msg_get_source(msg);
 801252a: 6878         	ldr	r0, [r7, #0x4]
 801252c: f7ff ff9c    	bl	0x8012468 <log_msg_get_source> @ imm = #-0xc8
 8012530: 4603         	mov	r3, r0
 8012532: b21b         	sxth	r3, r3
 8012534: e00e         	b	0x8012554 <log_msg_get_source_id+0x4c> @ imm = #0x1c
; 	void *source = (void *)log_msg_get_source(msg);
 8012536: 6878         	ldr	r0, [r7, #0x4]
 8012538: f7ff ff96    	bl	0x8012468 <log_msg_get_source> @ imm = #-0xd4
 801253c: 60f8         	str	r0, [r7, #0xc]
; 	if (source != NULL) {
 801253e: 68fb         	ldr	r3, [r7, #0xc]
 8012540: 2b00         	cmp	r3, #0x0
 8012542: d005         	beq	0x8012550 <log_msg_get_source_id+0x48> @ imm = #0xa
; 		return log_source_id(source);
 8012544: 68f8         	ldr	r0, [r7, #0xc]
 8012546: f7ff ff9a    	bl	0x801247e <log_source_id> @ imm = #-0xcc
 801254a: 4603         	mov	r3, r0
 801254c: b21b         	sxth	r3, r3
 801254e: e001         	b	0x8012554 <log_msg_get_source_id+0x4c> @ imm = #0x2
; 	return -1;
 8012550: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 8012554: 4618         	mov	r0, r3
 8012556: 3710         	adds	r7, #0x10
 8012558: 46bd         	mov	sp, r7
 801255a: bd80         	pop	{r7, pc}

0801255c <log_msg_get_domain>:
; {
 801255c: b480         	push	{r7}
 801255e: b083         	sub	sp, #0xc
 8012560: af00         	add	r7, sp, #0x0
 8012562: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 8012564: 687b         	ldr	r3, [r7, #0x4]
 8012566: 781b         	ldrb	r3, [r3]
 8012568: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 801256c: b2db         	uxtb	r3, r3
; }
 801256e: 4618         	mov	r0, r3
 8012570: 370c         	adds	r7, #0xc
 8012572: 46bd         	mov	sp, r7
 8012574: bc80         	pop	{r7}
 8012576: 4770         	bx	lr

08012578 <log_msg_get_level>:
; {
 8012578: b480         	push	{r7}
 801257a: b083         	sub	sp, #0xc
 801257c: af00         	add	r7, sp, #0x0
 801257e: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.level;
 8012580: 687b         	ldr	r3, [r7, #0x4]
 8012582: 881b         	ldrh	r3, [r3]
 8012584: f3c3 1382    	ubfx	r3, r3, #0x6, #0x3
 8012588: b2db         	uxtb	r3, r3
; }
 801258a: 4618         	mov	r0, r3
 801258c: 370c         	adds	r7, #0xc
 801258e: 46bd         	mov	sp, r7
 8012590: bc80         	pop	{r7}
 8012592: 4770         	bx	lr

08012594 <log_msg_get_timestamp>:
; {
 8012594: b480         	push	{r7}
 8012596: b083         	sub	sp, #0xc
 8012598: af00         	add	r7, sp, #0x0
 801259a: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.timestamp;
 801259c: 687b         	ldr	r3, [r7, #0x4]
 801259e: 689b         	ldr	r3, [r3, #0x8]
; }
 80125a0: 4618         	mov	r0, r3
 80125a2: 370c         	adds	r7, #0xc
 80125a4: 46bd         	mov	sp, r7
 80125a6: bc80         	pop	{r7}
 80125a8: 4770         	bx	lr

080125aa <log_msg_get_tid>:
; {
 80125aa: b480         	push	{r7}
 80125ac: b083         	sub	sp, #0xc
 80125ae: af00         	add	r7, sp, #0x0
 80125b0: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 80125b2: 2300         	movs	r3, #0x0
; }
 80125b4: 4618         	mov	r0, r3
 80125b6: 370c         	adds	r7, #0xc
 80125b8: 46bd         	mov	sp, r7
 80125ba: bc80         	pop	{r7}
 80125bc: 4770         	bx	lr

080125be <log_msg_get_data>:
; {
 80125be: b480         	push	{r7}
 80125c0: b083         	sub	sp, #0xc
 80125c2: af00         	add	r7, sp, #0x0
 80125c4: 6078         	str	r0, [r7, #0x4]
 80125c6: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.data_len;
 80125c8: 687b         	ldr	r3, [r7, #0x4]
 80125ca: 885b         	ldrh	r3, [r3, #0x2]
 80125cc: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 80125d0: b29b         	uxth	r3, r3
 80125d2: 461a         	mov	r2, r3
 80125d4: 683b         	ldr	r3, [r7]
 80125d6: 601a         	str	r2, [r3]
; 	return msg->data + msg->hdr.desc.package_len;
 80125d8: 687b         	ldr	r3, [r7, #0x4]
 80125da: 3310         	adds	r3, #0x10
 80125dc: 687a         	ldr	r2, [r7, #0x4]
 80125de: 6812         	ldr	r2, [r2]
 80125e0: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 80125e4: b292         	uxth	r2, r2
 80125e6: 4413         	add	r3, r2
; }
 80125e8: 4618         	mov	r0, r3
 80125ea: 370c         	adds	r7, #0xc
 80125ec: 46bd         	mov	sp, r7
 80125ee: bc80         	pop	{r7}
 80125f0: 4770         	bx	lr

080125f2 <log_msg_get_package>:
; {
 80125f2: b480         	push	{r7}
 80125f4: b083         	sub	sp, #0xc
 80125f6: af00         	add	r7, sp, #0x0
 80125f8: 6078         	str	r0, [r7, #0x4]
 80125fa: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.package_len;
 80125fc: 687b         	ldr	r3, [r7, #0x4]
 80125fe: 681b         	ldr	r3, [r3]
 8012600: f3c3 234a    	ubfx	r3, r3, #0x9, #0xb
 8012604: b29b         	uxth	r3, r3
 8012606: 461a         	mov	r2, r3
 8012608: 683b         	ldr	r3, [r7]
 801260a: 601a         	str	r2, [r3]
; 	return msg->data;
 801260c: 687b         	ldr	r3, [r7, #0x4]
 801260e: 3310         	adds	r3, #0x10
; }
 8012610: 4618         	mov	r0, r3
 8012612: 370c         	adds	r7, #0xc
 8012614: 46bd         	mov	sp, r7
 8012616: bc80         	pop	{r7}
 8012618: 4770         	bx	lr

0801261a <log_output_write>:
; {
 801261a: b580         	push	{r7, lr}
 801261c: b086         	sub	sp, #0x18
 801261e: af00         	add	r7, sp, #0x0
 8012620: 60f8         	str	r0, [r7, #0xc]
 8012622: 60b9         	str	r1, [r7, #0x8]
 8012624: 607a         	str	r2, [r7, #0x4]
 8012626: 603b         	str	r3, [r7]
; 	while (len != 0) {
 8012628: e00d         	b	0x8012646 <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 801262a: 68fb         	ldr	r3, [r7, #0xc]
 801262c: 683a         	ldr	r2, [r7]
 801262e: 6879         	ldr	r1, [r7, #0x4]
 8012630: 68b8         	ldr	r0, [r7, #0x8]
 8012632: 4798         	blx	r3
 8012634: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 8012636: 697b         	ldr	r3, [r7, #0x14]
 8012638: 687a         	ldr	r2, [r7, #0x4]
 801263a: 1ad3         	subs	r3, r2, r3
 801263c: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 801263e: 697b         	ldr	r3, [r7, #0x14]
 8012640: 68ba         	ldr	r2, [r7, #0x8]
 8012642: 4413         	add	r3, r2
 8012644: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 8012646: 687b         	ldr	r3, [r7, #0x4]
 8012648: 2b00         	cmp	r3, #0x0
 801264a: d1ee         	bne	0x801262a <log_output_write+0x10> @ imm = #-0x24
; }
 801264c: bf00         	nop
 801264e: bf00         	nop
 8012650: 3718         	adds	r7, #0x18
 8012652: 46bd         	mov	sp, r7
 8012654: bd80         	pop	{r7, pc}

08012656 <log_output_flush>:
; {
 8012656: b580         	push	{r7, lr}
 8012658: b082         	sub	sp, #0x8
 801265a: af00         	add	r7, sp, #0x0
 801265c: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 801265e: 687b         	ldr	r3, [r7, #0x4]
 8012660: 6818         	ldr	r0, [r3]
 8012662: 687b         	ldr	r3, [r7, #0x4]
 8012664: 6899         	ldr	r1, [r3, #0x8]
 8012666: 687b         	ldr	r3, [r7, #0x4]
 8012668: 685b         	ldr	r3, [r3, #0x4]
 801266a: 681b         	ldr	r3, [r3]
 801266c: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 801266e: 687b         	ldr	r3, [r7, #0x4]
 8012670: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 8012672: 685b         	ldr	r3, [r3, #0x4]
 8012674: f7ff ffd1    	bl	0x801261a <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 8012678: 687b         	ldr	r3, [r7, #0x4]
 801267a: 685b         	ldr	r3, [r3, #0x4]
 801267c: 2200         	movs	r2, #0x0
 801267e: 601a         	str	r2, [r3]
; }
 8012680: bf00         	nop
 8012682: 3708         	adds	r7, #0x8
 8012684: 46bd         	mov	sp, r7
 8012686: bd80         	pop	{r7, pc}

08012688 <out_func>:
; {
 8012688: b580         	push	{r7, lr}
 801268a: b084         	sub	sp, #0x10
 801268c: af00         	add	r7, sp, #0x0
 801268e: 6078         	str	r0, [r7, #0x4]
 8012690: 6039         	str	r1, [r7]
; 	const struct log_output *out_ctx = (const struct log_output *)ctx;
 8012692: 683b         	ldr	r3, [r7]
 8012694: 60fb         	str	r3, [r7, #0xc]
; 		char x = (char)c;
 8012696: 687b         	ldr	r3, [r7, #0x4]
 8012698: b2db         	uxtb	r3, r3
 801269a: 72fb         	strb	r3, [r7, #0xb]
; 		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
 801269c: 68fb         	ldr	r3, [r7, #0xc]
 801269e: 681b         	ldr	r3, [r3]
 80126a0: 68fa         	ldr	r2, [r7, #0xc]
 80126a2: 6852         	ldr	r2, [r2, #0x4]
 80126a4: 6852         	ldr	r2, [r2, #0x4]
 80126a6: f107 000b    	add.w	r0, r7, #0xb
 80126aa: 2101         	movs	r1, #0x1
 80126ac: 4798         	blx	r3
; 		return 0;
 80126ae: 2300         	movs	r3, #0x0
; }
 80126b0: 4618         	mov	r0, r3
 80126b2: 3710         	adds	r7, #0x10
 80126b4: 46bd         	mov	sp, r7
 80126b6: bd80         	pop	{r7, pc}

080126b8 <cr_out_func>:
; {
 80126b8: b580         	push	{r7, lr}
 80126ba: b082         	sub	sp, #0x8
 80126bc: af00         	add	r7, sp, #0x0
 80126be: 6078         	str	r0, [r7, #0x4]
 80126c0: 6039         	str	r1, [r7]
; 	if (c == '\n') {
 80126c2: 687b         	ldr	r3, [r7, #0x4]
 80126c4: 2b0a         	cmp	r3, #0xa
 80126c6: d103         	bne	0x80126d0 <cr_out_func+0x18> @ imm = #0x6
; 		out_func((int)'\r', ctx);
 80126c8: 6839         	ldr	r1, [r7]
 80126ca: 200d         	movs	r0, #0xd
 80126cc: f7ff ffdc    	bl	0x8012688 <out_func>    @ imm = #-0x48
; 	out_func(c, ctx);
 80126d0: 6839         	ldr	r1, [r7]
 80126d2: 6878         	ldr	r0, [r7, #0x4]
 80126d4: f7ff ffd8    	bl	0x8012688 <out_func>    @ imm = #-0x50
; 	return 0;
 80126d8: 2300         	movs	r3, #0x0
; }
 80126da: 4618         	mov	r0, r3
 80126dc: 3708         	adds	r7, #0x8
 80126de: 46bd         	mov	sp, r7
 80126e0: bd80         	pop	{r7, pc}

080126e2 <color_prefix>:
; {
 80126e2: b580         	push	{r7, lr}
 80126e4: b084         	sub	sp, #0x10
 80126e6: af00         	add	r7, sp, #0x0
 80126e8: 60f8         	str	r0, [r7, #0xc]
 80126ea: 460b         	mov	r3, r1
 80126ec: 607a         	str	r2, [r7, #0x4]
 80126ee: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, true, level);
 80126f0: 7af9         	ldrb	r1, [r7, #0xb]
 80126f2: 687b         	ldr	r3, [r7, #0x4]
 80126f4: 2201         	movs	r2, #0x1
 80126f6: 68f8         	ldr	r0, [r7, #0xc]
 80126f8: f7ef fc28    	bl	0x8001f4c <color_print> @ imm = #-0x107b0
; }
 80126fc: bf00         	nop
 80126fe: 3710         	adds	r7, #0x10
 8012700: 46bd         	mov	sp, r7
 8012702: bd80         	pop	{r7, pc}

08012704 <color_postfix>:
; {
 8012704: b580         	push	{r7, lr}
 8012706: b084         	sub	sp, #0x10
 8012708: af00         	add	r7, sp, #0x0
 801270a: 60f8         	str	r0, [r7, #0xc]
 801270c: 460b         	mov	r3, r1
 801270e: 607a         	str	r2, [r7, #0x4]
 8012710: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, false, level);
 8012712: 7af9         	ldrb	r1, [r7, #0xb]
 8012714: 687b         	ldr	r3, [r7, #0x4]
 8012716: 2200         	movs	r2, #0x0
 8012718: 68f8         	ldr	r0, [r7, #0xc]
 801271a: f7ef fc17    	bl	0x8001f4c <color_print> @ imm = #-0x107d2
; }
 801271e: bf00         	nop
 8012720: 3710         	adds	r7, #0x10
 8012722: 46bd         	mov	sp, r7
 8012724: bd80         	pop	{r7, pc}

08012726 <log_msg_hexdump>:
; {
 8012726: b580         	push	{r7, lr}
 8012728: b088         	sub	sp, #0x20
 801272a: af02         	add	r7, sp, #0x8
 801272c: 60f8         	str	r0, [r7, #0xc]
 801272e: 60b9         	str	r1, [r7, #0x8]
 8012730: 607a         	str	r2, [r7, #0x4]
 8012732: 603b         	str	r3, [r7]
; 		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
 8012734: 687b         	ldr	r3, [r7, #0x4]
 8012736: 2b10         	cmp	r3, #0x10
 8012738: bf28         	it	hs
 801273a: 2310         	movhs	r3, #0x10
 801273c: 617b         	str	r3, [r7, #0x14]
; 		hexdump_line_print(output, data, length,
 801273e: 6a3b         	ldr	r3, [r7, #0x20]
 8012740: 9300         	str	r3, [sp]
 8012742: 683b         	ldr	r3, [r7]
 8012744: 697a         	ldr	r2, [r7, #0x14]
 8012746: 68b9         	ldr	r1, [r7, #0x8]
 8012748: 68f8         	ldr	r0, [r7, #0xc]
 801274a: f7ef fc9d    	bl	0x8002088 <hexdump_line_print> @ imm = #-0x106c6
; 		data += length;
 801274e: 68ba         	ldr	r2, [r7, #0x8]
 8012750: 697b         	ldr	r3, [r7, #0x14]
 8012752: 4413         	add	r3, r2
 8012754: 60bb         	str	r3, [r7, #0x8]
; 		len -= length;
 8012756: 687a         	ldr	r2, [r7, #0x4]
 8012758: 697b         	ldr	r3, [r7, #0x14]
 801275a: 1ad3         	subs	r3, r2, r3
 801275c: 607b         	str	r3, [r7, #0x4]
; 	} while (len);
 801275e: 687b         	ldr	r3, [r7, #0x4]
 8012760: 2b00         	cmp	r3, #0x0
 8012762: d1e7         	bne	0x8012734 <log_msg_hexdump+0xe> @ imm = #-0x32
; }
 8012764: bf00         	nop
 8012766: bf00         	nop
 8012768: 3718         	adds	r7, #0x18
 801276a: 46bd         	mov	sp, r7
 801276c: bd80         	pop	{r7, pc}

0801276e <postfix_print>:
; {
 801276e: b580         	push	{r7, lr}
 8012770: b084         	sub	sp, #0x10
 8012772: af00         	add	r7, sp, #0x0
 8012774: 60f8         	str	r0, [r7, #0xc]
 8012776: 60b9         	str	r1, [r7, #0x8]
 8012778: 4613         	mov	r3, r2
 801277a: 71fb         	strb	r3, [r7, #0x7]
; 	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
 801277c: 68bb         	ldr	r3, [r7, #0x8]
 801277e: f003 0301    	and	r3, r3, #0x1
 8012782: 2b00         	cmp	r3, #0x0
 8012784: bf14         	ite	ne
 8012786: 2301         	movne	r3, #0x1
 8012788: 2300         	moveq	r3, #0x0
 801278a: b2db         	uxtb	r3, r3
 801278c: 79fa         	ldrb	r2, [r7, #0x7]
 801278e: 4619         	mov	r1, r3
 8012790: 68f8         	ldr	r0, [r7, #0xc]
 8012792: f7ff ffb7    	bl	0x8012704 <color_postfix> @ imm = #-0x92
; 	newline_print(output, flags);
 8012796: 68b9         	ldr	r1, [r7, #0x8]
 8012798: 68f8         	ldr	r0, [r7, #0xc]
 801279a: f7ef fc53    	bl	0x8002044 <newline_print> @ imm = #-0x1075a
; }
 801279e: bf00         	nop
 80127a0: 3710         	adds	r7, #0x10
 80127a2: 46bd         	mov	sp, r7
 80127a4: bd80         	pop	{r7, pc}

080127a6 <log_output_msg_process>:
; {
 80127a6: b580         	push	{r7, lr}
 80127a8: b092         	sub	sp, #0x48
 80127aa: af06         	add	r7, sp, #0x18
 80127ac: 60f8         	str	r0, [r7, #0xc]
 80127ae: 60b9         	str	r1, [r7, #0x8]
 80127b0: 607a         	str	r2, [r7, #0x4]
; 	log_timestamp_t timestamp = log_msg_get_timestamp(msg);
 80127b2: 68b8         	ldr	r0, [r7, #0x8]
 80127b4: f7ff feee    	bl	0x8012594 <log_msg_get_timestamp> @ imm = #-0x224
 80127b8: 62f8         	str	r0, [r7, #0x2c]
; 	uint8_t level = log_msg_get_level(msg);
 80127ba: 68b8         	ldr	r0, [r7, #0x8]
 80127bc: f7ff fedc    	bl	0x8012578 <log_msg_get_level> @ imm = #-0x248
 80127c0: 4603         	mov	r3, r0
 80127c2: f887 302b    	strb.w	r3, [r7, #0x2b]
; 	uint8_t domain_id = log_msg_get_domain(msg);
 80127c6: 68b8         	ldr	r0, [r7, #0x8]
 80127c8: f7ff fec8    	bl	0x801255c <log_msg_get_domain> @ imm = #-0x270
 80127cc: 4603         	mov	r3, r0
 80127ce: f887 302a    	strb.w	r3, [r7, #0x2a]
; 	int16_t source_id = log_msg_get_source_id(msg);
 80127d2: 68b8         	ldr	r0, [r7, #0x8]
 80127d4: f7ff fe98    	bl	0x8012508 <log_msg_get_source_id> @ imm = #-0x2d0
 80127d8: 4603         	mov	r3, r0
 80127da: 853b         	strh	r3, [r7, #0x28]
; 	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
 80127dc: f9b7 3028    	ldrsh.w	r3, [r7, #0x28]
 80127e0: 2b00         	cmp	r3, #0x0
 80127e2: db09         	blt	0x80127f8 <log_output_msg_process+0x52> @ imm = #0x12
 80127e4: f897 302a    	ldrb.w	r3, [r7, #0x2a]
 80127e8: f9b7 2028    	ldrsh.w	r2, [r7, #0x28]
 80127ec: 4611         	mov	r1, r2
 80127ee: 4618         	mov	r0, r3
 80127f0: f7ef fa04    	bl	0x8001bfc <log_source_name_get> @ imm = #-0x10bf8
 80127f4: 4603         	mov	r3, r0
 80127f6: e000         	b	0x80127fa <log_output_msg_process+0x54> @ imm = #0x0
 80127f8: 2300         	movs	r3, #0x0
 80127fa: 627b         	str	r3, [r7, #0x24]
; 	uint8_t *package = log_msg_get_package(msg, &plen);
 80127fc: f107 0318    	add.w	r3, r7, #0x18
 8012800: 4619         	mov	r1, r3
 8012802: 68b8         	ldr	r0, [r7, #0x8]
 8012804: f7ff fef5    	bl	0x80125f2 <log_msg_get_package> @ imm = #-0x216
 8012808: 6238         	str	r0, [r7, #0x20]
; 	uint8_t *data = log_msg_get_data(msg, &dlen);
 801280a: f107 0314    	add.w	r3, r7, #0x14
 801280e: 4619         	mov	r1, r3
 8012810: 68b8         	ldr	r0, [r7, #0x8]
 8012812: f7ff fed4    	bl	0x80125be <log_msg_get_data> @ imm = #-0x258
 8012816: 61f8         	str	r0, [r7, #0x1c]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 8012818: 68b8         	ldr	r0, [r7, #0x8]
 801281a: f7ff fec6    	bl	0x80125aa <log_msg_get_tid> @ imm = #-0x274
; 			   plen > 0 ? package : NULL, data, dlen, flags);
 801281e: 69bb         	ldr	r3, [r7, #0x18]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 8012820: 2b00         	cmp	r3, #0x0
 8012822: d001         	beq	0x8012828 <log_output_msg_process+0x82> @ imm = #0x2
 8012824: 6a3b         	ldr	r3, [r7, #0x20]
 8012826: e000         	b	0x801282a <log_output_msg_process+0x84> @ imm = #0x0
 8012828: 2300         	movs	r3, #0x0
 801282a: 697a         	ldr	r2, [r7, #0x14]
 801282c: 6879         	ldr	r1, [r7, #0x4]
 801282e: 9105         	str	r1, [sp, #0x14]
 8012830: 9204         	str	r2, [sp, #0x10]
 8012832: 69fa         	ldr	r2, [r7, #0x1c]
 8012834: 9203         	str	r2, [sp, #0xc]
 8012836: 9302         	str	r3, [sp, #0x8]
 8012838: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 801283c: 9301         	str	r3, [sp, #0x4]
 801283e: 9000         	str	r0, [sp]
 8012840: 6a7b         	ldr	r3, [r7, #0x24]
 8012842: 2200         	movs	r2, #0x0
 8012844: 6af9         	ldr	r1, [r7, #0x2c]
 8012846: 68f8         	ldr	r0, [r7, #0xc]
 8012848: f7ef fd18    	bl	0x800227c <log_output_process> @ imm = #-0x105d0
; }
 801284c: bf00         	nop
 801284e: 3730         	adds	r7, #0x30
 8012850: 46bd         	mov	sp, r7
 8012852: bd80         	pop	{r7, pc}

08012854 <log_output_write>:
; {
 8012854: b580         	push	{r7, lr}
 8012856: b086         	sub	sp, #0x18
 8012858: af00         	add	r7, sp, #0x0
 801285a: 60f8         	str	r0, [r7, #0xc]
 801285c: 60b9         	str	r1, [r7, #0x8]
 801285e: 607a         	str	r2, [r7, #0x4]
 8012860: 603b         	str	r3, [r7]
; 	while (len != 0) {
 8012862: e00d         	b	0x8012880 <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 8012864: 68fb         	ldr	r3, [r7, #0xc]
 8012866: 683a         	ldr	r2, [r7]
 8012868: 6879         	ldr	r1, [r7, #0x4]
 801286a: 68b8         	ldr	r0, [r7, #0x8]
 801286c: 4798         	blx	r3
 801286e: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 8012870: 697b         	ldr	r3, [r7, #0x14]
 8012872: 687a         	ldr	r2, [r7, #0x4]
 8012874: 1ad3         	subs	r3, r2, r3
 8012876: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 8012878: 697b         	ldr	r3, [r7, #0x14]
 801287a: 68ba         	ldr	r2, [r7, #0x8]
 801287c: 4413         	add	r3, r2
 801287e: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 8012880: 687b         	ldr	r3, [r7, #0x4]
 8012882: 2b00         	cmp	r3, #0x0
 8012884: d1ee         	bne	0x8012864 <log_output_write+0x10> @ imm = #-0x24
; }
 8012886: bf00         	nop
 8012888: bf00         	nop
 801288a: 3718         	adds	r7, #0x18
 801288c: 46bd         	mov	sp, r7
 801288e: bd80         	pop	{r7, pc}

08012890 <log_output_flush>:
; {
 8012890: b580         	push	{r7, lr}
 8012892: b082         	sub	sp, #0x8
 8012894: af00         	add	r7, sp, #0x0
 8012896: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 8012898: 687b         	ldr	r3, [r7, #0x4]
 801289a: 6818         	ldr	r0, [r3]
 801289c: 687b         	ldr	r3, [r7, #0x4]
 801289e: 6899         	ldr	r1, [r3, #0x8]
 80128a0: 687b         	ldr	r3, [r7, #0x4]
 80128a2: 685b         	ldr	r3, [r3, #0x4]
 80128a4: 681b         	ldr	r3, [r3]
 80128a6: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 80128a8: 687b         	ldr	r3, [r7, #0x4]
 80128aa: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 80128ac: 685b         	ldr	r3, [r3, #0x4]
 80128ae: f7ff ffd1    	bl	0x8012854 <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 80128b2: 687b         	ldr	r3, [r7, #0x4]
 80128b4: 685b         	ldr	r3, [r3, #0x4]
 80128b6: 2200         	movs	r2, #0x0
 80128b8: 601a         	str	r2, [r3]
; }
 80128ba: bf00         	nop
 80128bc: 3708         	adds	r7, #0x8
 80128be: 46bd         	mov	sp, r7
 80128c0: bd80         	pop	{r7, pc}

080128c2 <log_output_ctx_set>:
; {
 80128c2: b480         	push	{r7}
 80128c4: b083         	sub	sp, #0xc
 80128c6: af00         	add	r7, sp, #0x0
 80128c8: 6078         	str	r0, [r7, #0x4]
 80128ca: 6039         	str	r1, [r7]
; 	output->control_block->ctx = ctx;
 80128cc: 687b         	ldr	r3, [r7, #0x4]
 80128ce: 685b         	ldr	r3, [r3, #0x4]
 80128d0: 683a         	ldr	r2, [r7]
 80128d2: 605a         	str	r2, [r3, #0x4]
; }
 80128d4: bf00         	nop
 80128d6: 370c         	adds	r7, #0xc
 80128d8: 46bd         	mov	sp, r7
 80128da: bc80         	pop	{r7}
 80128dc: 4770         	bx	lr

080128de <log_backend_std_get_flags>:
; {
 80128de: b480         	push	{r7}
 80128e0: b083         	sub	sp, #0xc
 80128e2: af00         	add	r7, sp, #0x0
; 	uint32_t flags = (LOG_OUTPUT_FLAG_LEVEL | LOG_OUTPUT_FLAG_TIMESTAMP);
 80128e4: 230a         	movs	r3, #0xa
 80128e6: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_COLORS;
 80128e8: 687b         	ldr	r3, [r7, #0x4]
 80128ea: f043 0301    	orr	r3, r3, #0x1
 80128ee: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP;
 80128f0: 687b         	ldr	r3, [r7, #0x4]
 80128f2: f043 0304    	orr	r3, r3, #0x4
 80128f6: 607b         	str	r3, [r7, #0x4]
; 	return flags;
 80128f8: 687b         	ldr	r3, [r7, #0x4]
; }
 80128fa: 4618         	mov	r0, r3
 80128fc: 370c         	adds	r7, #0xc
 80128fe: 46bd         	mov	sp, r7
 8012900: bc80         	pop	{r7}
 8012902: 4770         	bx	lr

08012904 <log_backend_std_panic>:
; {
 8012904: b580         	push	{r7, lr}
 8012906: b082         	sub	sp, #0x8
 8012908: af00         	add	r7, sp, #0x0
 801290a: 6078         	str	r0, [r7, #0x4]
; 	log_output_flush(output);
 801290c: 6878         	ldr	r0, [r7, #0x4]
 801290e: f7ff ffbf    	bl	0x8012890 <log_output_flush> @ imm = #-0x82
; }
 8012912: bf00         	nop
 8012914: 3708         	adds	r7, #0x8
 8012916: 46bd         	mov	sp, r7
 8012918: bd80         	pop	{r7, pc}

0801291a <z_impl_uart_poll_out>:
; {
 801291a: b580         	push	{r7, lr}
 801291c: b084         	sub	sp, #0x10
 801291e: af00         	add	r7, sp, #0x0
 8012920: 6078         	str	r0, [r7, #0x4]
 8012922: 460b         	mov	r3, r1
 8012924: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8012926: 687b         	ldr	r3, [r7, #0x4]
 8012928: 689b         	ldr	r3, [r3, #0x8]
 801292a: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 801292c: 68fb         	ldr	r3, [r7, #0xc]
 801292e: 69db         	ldr	r3, [r3, #0x1c]
 8012930: 78fa         	ldrb	r2, [r7, #0x3]
 8012932: 4611         	mov	r1, r2
 8012934: 6878         	ldr	r0, [r7, #0x4]
 8012936: 4798         	blx	r3
; }
 8012938: bf00         	nop
 801293a: 3710         	adds	r7, #0x10
 801293c: 46bd         	mov	sp, r7
 801293e: bd80         	pop	{r7, pc}

08012940 <uart_poll_out>:
; {
 8012940: b580         	push	{r7, lr}
 8012942: b082         	sub	sp, #0x8
 8012944: af00         	add	r7, sp, #0x0
 8012946: 6078         	str	r0, [r7, #0x4]
 8012948: 460b         	mov	r3, r1
 801294a: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 801294c: 78fb         	ldrb	r3, [r7, #0x3]
 801294e: 4619         	mov	r1, r3
 8012950: 6878         	ldr	r0, [r7, #0x4]
 8012952: f7ff ffe2    	bl	0x801291a <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 8012956: bf00         	nop
 8012958: 3708         	adds	r7, #0x8
 801295a: 46bd         	mov	sp, r7
 801295c: bd80         	pop	{r7, pc}

0801295e <pm_device_runtime_get>:
; {
 801295e: b480         	push	{r7}
 8012960: b083         	sub	sp, #0xc
 8012962: af00         	add	r7, sp, #0x0
 8012964: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8012966: 2300         	movs	r3, #0x0
; }
 8012968: 4618         	mov	r0, r3
 801296a: 370c         	adds	r7, #0xc
 801296c: 46bd         	mov	sp, r7
 801296e: bc80         	pop	{r7}
 8012970: 4770         	bx	lr

08012972 <pm_device_runtime_put_async>:
; {
 8012972: b480         	push	{r7}
 8012974: b085         	sub	sp, #0x14
 8012976: af00         	add	r7, sp, #0x0
 8012978: 60f8         	str	r0, [r7, #0xc]
 801297a: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 801297e: 2300         	movs	r3, #0x0
; }
 8012980: 4618         	mov	r0, r3
 8012982: 3714         	adds	r7, #0x14
 8012984: 46bd         	mov	sp, r7
 8012986: bc80         	pop	{r7}
 8012988: 4770         	bx	lr

0801298a <process>:
; {
 801298a: b580         	push	{r7, lr}
 801298c: b086         	sub	sp, #0x18
 801298e: af00         	add	r7, sp, #0x0
 8012990: 6078         	str	r0, [r7, #0x4]
 8012992: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8012994: 687b         	ldr	r3, [r7, #0x4]
 8012996: 685b         	ldr	r3, [r3, #0x4]
 8012998: 681b         	ldr	r3, [r3]
 801299a: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 801299c: 697b         	ldr	r3, [r7, #0x14]
 801299e: 685b         	ldr	r3, [r3, #0x4]
 80129a0: 613b         	str	r3, [r7, #0x10]
; 	uint32_t flags = log_backend_std_get_flags();
 80129a2: f7ff ff9c    	bl	0x80128de <log_backend_std_get_flags> @ imm = #-0xc8
 80129a6: 60f8         	str	r0, [r7, #0xc]
; 	log_format_func_t log_output_func = log_format_func_t_get(data->log_format_current);
 80129a8: 693b         	ldr	r3, [r7, #0x10]
 80129aa: 691b         	ldr	r3, [r3, #0x10]
 80129ac: 4618         	mov	r0, r3
 80129ae: f7ee ff3b    	bl	0x8001828 <log_format_func_t_get> @ imm = #-0x1118a
 80129b2: 60b8         	str	r0, [r7, #0x8]
; 	log_output_func(ctx->output, &msg->log, flags);
 80129b4: 697b         	ldr	r3, [r7, #0x14]
 80129b6: 6818         	ldr	r0, [r3]
 80129b8: 6839         	ldr	r1, [r7]
 80129ba: 68bb         	ldr	r3, [r7, #0x8]
 80129bc: 68fa         	ldr	r2, [r7, #0xc]
 80129be: 4798         	blx	r3
; }
 80129c0: bf00         	nop
 80129c2: 3718         	adds	r7, #0x18
 80129c4: 46bd         	mov	sp, r7
 80129c6: bd80         	pop	{r7, pc}

080129c8 <format_set>:
; {
 80129c8: b480         	push	{r7}
 80129ca: b085         	sub	sp, #0x14
 80129cc: af00         	add	r7, sp, #0x0
 80129ce: 6078         	str	r0, [r7, #0x4]
 80129d0: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 80129d2: 687b         	ldr	r3, [r7, #0x4]
 80129d4: 685b         	ldr	r3, [r3, #0x4]
 80129d6: 681b         	ldr	r3, [r3]
 80129d8: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 80129da: 68fb         	ldr	r3, [r7, #0xc]
 80129dc: 685b         	ldr	r3, [r3, #0x4]
 80129de: 60bb         	str	r3, [r7, #0x8]
; 	data->log_format_current = log_type;
 80129e0: 68bb         	ldr	r3, [r7, #0x8]
 80129e2: 683a         	ldr	r2, [r7]
 80129e4: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 80129e6: 2300         	movs	r3, #0x0
; }
 80129e8: 4618         	mov	r0, r3
 80129ea: 3714         	adds	r7, #0x14
 80129ec: 46bd         	mov	sp, r7
 80129ee: bc80         	pop	{r7}
 80129f0: 4770         	bx	lr

080129f2 <z_log_msg_runtime_create>:
; {
 80129f2: b580         	push	{r7, lr}
 80129f4: b08a         	sub	sp, #0x28
 80129f6: af04         	add	r7, sp, #0x10
 80129f8: 60b9         	str	r1, [r7, #0x8]
 80129fa: 607b         	str	r3, [r7, #0x4]
 80129fc: 4603         	mov	r3, r0
 80129fe: 73fb         	strb	r3, [r7, #0xf]
 8012a00: 4613         	mov	r3, r2
 8012a02: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8012a04: f107 032c    	add.w	r3, r7, #0x2c
 8012a08: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8012a0a: 7bba         	ldrb	r2, [r7, #0xe]
 8012a0c: 7bf8         	ldrb	r0, [r7, #0xf]
 8012a0e: 697b         	ldr	r3, [r7, #0x14]
 8012a10: 9303         	str	r3, [sp, #0xc]
 8012a12: 6abb         	ldr	r3, [r7, #0x28]
 8012a14: 9302         	str	r3, [sp, #0x8]
 8012a16: 6a7b         	ldr	r3, [r7, #0x24]
 8012a18: 9301         	str	r3, [sp, #0x4]
 8012a1a: 6a3b         	ldr	r3, [r7, #0x20]
 8012a1c: 9300         	str	r3, [sp]
 8012a1e: 687b         	ldr	r3, [r7, #0x4]
 8012a20: 68b9         	ldr	r1, [r7, #0x8]
 8012a22: f7ef f923    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x10dba
; }
 8012a26: bf00         	nop
 8012a28: 3718         	adds	r7, #0x18
 8012a2a: 46bd         	mov	sp, r7
 8012a2c: bd80         	pop	{r7, pc}

08012a2e <z_do_kernel_oops>:
; {
 8012a2e: b580         	push	{r7, lr}
 8012a30: b088         	sub	sp, #0x20
 8012a32: af00         	add	r7, sp, #0x0
 8012a34: 60f8         	str	r0, [r7, #0xc]
 8012a36: 60b9         	str	r1, [r7, #0x8]
 8012a38: 607a         	str	r2, [r7, #0x4]
; 	unsigned int reason = esf->basic.r0;
 8012a3a: 68fb         	ldr	r3, [r7, #0xc]
 8012a3c: 681b         	ldr	r3, [r3]
 8012a3e: 61fb         	str	r3, [r7, #0x1c]
 8012a40: 68fb         	ldr	r3, [r7, #0xc]
 8012a42: 61bb         	str	r3, [r7, #0x18]
 8012a44: 687b         	ldr	r3, [r7, #0x4]
 8012a46: 617b         	str	r3, [r7, #0x14]
; }
 8012a48: bf00         	nop
; 	z_arm_fatal_error(reason, esf);
 8012a4a: 68f9         	ldr	r1, [r7, #0xc]
 8012a4c: 69f8         	ldr	r0, [r7, #0x1c]
 8012a4e: f7ef fd97    	bl	0x8002580 <z_arm_fatal_error> @ imm = #-0x104d2
; }
 8012a52: bf00         	nop
 8012a54: 3720         	adds	r7, #0x20
 8012a56: 46bd         	mov	sp, r7
 8012a58: bd80         	pop	{r7, pc}

08012a5a <arch_tls_stack_setup>:
; {
 8012a5a: b580         	push	{r7, lr}
 8012a5c: b082         	sub	sp, #0x8
 8012a5e: af00         	add	r7, sp, #0x0
 8012a60: 6078         	str	r0, [r7, #0x4]
 8012a62: 6039         	str	r1, [r7]
; 	stack_ptr -= z_tls_data_size();
 8012a64: f7ef fdd8    	bl	0x8002618 <z_tls_data_size> @ imm = #-0x10450
 8012a68: 4603         	mov	r3, r0
 8012a6a: 425b         	rsbs	r3, r3, #0
 8012a6c: 683a         	ldr	r2, [r7]
 8012a6e: 4413         	add	r3, r2
 8012a70: 603b         	str	r3, [r7]
; 	z_tls_copy(stack_ptr);
 8012a72: 6838         	ldr	r0, [r7]
 8012a74: f7ef fdde    	bl	0x8002634 <z_tls_copy>  @ imm = #-0x10444
; 	stack_ptr -= sizeof(uintptr_t) * 2;
 8012a78: 683b         	ldr	r3, [r7]
 8012a7a: 3b08         	subs	r3, #0x8
 8012a7c: 603b         	str	r3, [r7]
; 	new_thread->tls = POINTER_TO_UINT(stack_ptr);
 8012a7e: 683a         	ldr	r2, [r7]
 8012a80: 687b         	ldr	r3, [r7, #0x4]
 8012a82: f8c3 20c4    	str.w	r2, [r3, #0xc4]
; 	return (z_tls_data_size() + (sizeof(uintptr_t) * 2));
 8012a86: f7ef fdc7    	bl	0x8002618 <z_tls_data_size> @ imm = #-0x10472
 8012a8a: 4603         	mov	r3, r0
 8012a8c: 3308         	adds	r3, #0x8
; }
 8012a8e: 4618         	mov	r0, r3
 8012a90: 3708         	adds	r7, #0x8
 8012a92: 46bd         	mov	sp, r7
 8012a94: bd80         	pop	{r7, pc}

08012a96 <z_log_msg_runtime_create>:
; {
 8012a96: b580         	push	{r7, lr}
 8012a98: b08a         	sub	sp, #0x28
 8012a9a: af04         	add	r7, sp, #0x10
 8012a9c: 60b9         	str	r1, [r7, #0x8]
 8012a9e: 607b         	str	r3, [r7, #0x4]
 8012aa0: 4603         	mov	r3, r0
 8012aa2: 73fb         	strb	r3, [r7, #0xf]
 8012aa4: 4613         	mov	r3, r2
 8012aa6: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8012aa8: f107 032c    	add.w	r3, r7, #0x2c
 8012aac: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8012aae: 7bba         	ldrb	r2, [r7, #0xe]
 8012ab0: 7bf8         	ldrb	r0, [r7, #0xf]
 8012ab2: 697b         	ldr	r3, [r7, #0x14]
 8012ab4: 9303         	str	r3, [sp, #0xc]
 8012ab6: 6abb         	ldr	r3, [r7, #0x28]
 8012ab8: 9302         	str	r3, [sp, #0x8]
 8012aba: 6a7b         	ldr	r3, [r7, #0x24]
 8012abc: 9301         	str	r3, [sp, #0x4]
 8012abe: 6a3b         	ldr	r3, [r7, #0x20]
 8012ac0: 9300         	str	r3, [sp]
 8012ac2: 687b         	ldr	r3, [r7, #0x4]
 8012ac4: 68b9         	ldr	r1, [r7, #0x8]
 8012ac6: f7ef f8d1    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x10e5e
; }
 8012aca: bf00         	nop
 8012acc: 3718         	adds	r7, #0x18
 8012ace: 46bd         	mov	sp, r7
 8012ad0: bd80         	pop	{r7, pc}

08012ad2 <fault_show>:
; {
 8012ad2: b480         	push	{r7}
 8012ad4: b083         	sub	sp, #0xc
 8012ad6: af00         	add	r7, sp, #0x0
 8012ad8: 6078         	str	r0, [r7, #0x4]
 8012ada: 6039         	str	r1, [r7]
; }
 8012adc: bf00         	nop
 8012ade: 370c         	adds	r7, #0xc
 8012ae0: 46bd         	mov	sp, r7
 8012ae2: bc80         	pop	{r7}
 8012ae4: 4770         	bx	lr

08012ae6 <memory_fault_recoverable>:
; {
 8012ae6: b480         	push	{r7}
 8012ae8: b083         	sub	sp, #0xc
 8012aea: af00         	add	r7, sp, #0x0
 8012aec: 6078         	str	r0, [r7, #0x4]
 8012aee: 460b         	mov	r3, r1
 8012af0: 70fb         	strb	r3, [r7, #0x3]
; 	return false;
 8012af2: 2300         	movs	r3, #0x0
; }
 8012af4: 4618         	mov	r0, r3
 8012af6: 370c         	adds	r7, #0xc
 8012af8: 46bd         	mov	sp, r7
 8012afa: bc80         	pop	{r7}
 8012afc: 4770         	bx	lr

08012afe <arch_irq_enable>:
; {
 8012afe: b580         	push	{r7, lr}
 8012b00: b082         	sub	sp, #0x8
 8012b02: af00         	add	r7, sp, #0x0
 8012b04: 6078         	str	r0, [r7, #0x4]
; 	NVIC_EnableIRQ((IRQn_Type)irq);
 8012b06: 687b         	ldr	r3, [r7, #0x4]
 8012b08: b25b         	sxtb	r3, r3
 8012b0a: 4618         	mov	r0, r3
 8012b0c: f7f0 fcf8    	bl	0x8003500 <__NVIC_EnableIRQ> @ imm = #-0xf610
; }
 8012b10: bf00         	nop
 8012b12: 3708         	adds	r7, #0x8
 8012b14: 46bd         	mov	sp, r7
 8012b16: bd80         	pop	{r7, pc}

08012b18 <z_arm_irq_priority_set>:
; {
 8012b18: b580         	push	{r7, lr}
 8012b1a: b084         	sub	sp, #0x10
 8012b1c: af00         	add	r7, sp, #0x0
 8012b1e: 60f8         	str	r0, [r7, #0xc]
 8012b20: 60b9         	str	r1, [r7, #0x8]
 8012b22: 607a         	str	r2, [r7, #0x4]
; 		prio += _IRQ_PRIO_OFFSET;
 8012b24: 68bb         	ldr	r3, [r7, #0x8]
 8012b26: 3301         	adds	r3, #0x1
 8012b28: 60bb         	str	r3, [r7, #0x8]
; 	NVIC_SetPriority((IRQn_Type)irq, prio);
 8012b2a: 68fb         	ldr	r3, [r7, #0xc]
 8012b2c: b25b         	sxtb	r3, r3
 8012b2e: 68b9         	ldr	r1, [r7, #0x8]
 8012b30: 4618         	mov	r0, r3
 8012b32: f7f0 fd01    	bl	0x8003538 <__NVIC_SetPriority> @ imm = #-0xf5fe
; }
 8012b36: bf00         	nop
 8012b38: 3710         	adds	r7, #0x10
 8012b3a: 46bd         	mov	sp, r7
 8012b3c: bd80         	pop	{r7, pc}

08012b3e <z_irq_spurious>:
; {
 8012b3e: b580         	push	{r7, lr}
 8012b40: b082         	sub	sp, #0x8
 8012b42: af00         	add	r7, sp, #0x0
 8012b44: 6078         	str	r0, [r7, #0x4]
; 	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 8012b46: 2100         	movs	r1, #0x0
 8012b48: 2001         	movs	r0, #0x1
 8012b4a: f7ef fd19    	bl	0x8002580 <z_arm_fatal_error> @ imm = #-0x105ce
; }
 8012b4e: bf00         	nop
 8012b50: 3708         	adds	r7, #0x8
 8012b52: 46bd         	mov	sp, r7
 8012b54: bd80         	pop	{r7, pc}

08012b56 <z_prep_c>:
; {
 8012b56: b580         	push	{r7, lr}
 8012b58: af00         	add	r7, sp, #0x0
; 	relocate_vector_table();
 8012b5a: f7f0 fd17    	bl	0x800358c <relocate_vector_table> @ imm = #-0xf5d2
; 	z_arm_floating_point_init();
 8012b5e: f7f0 fd2f    	bl	0x80035c0 <z_arm_floating_point_init> @ imm = #-0xf5a2
; 	z_bss_zero();
 8012b62: f7f9 fa47    	bl	0x800bff4 <z_bss_zero>  @ imm = #-0x6b72
; 	z_data_copy();
 8012b66: f7fc fdaf    	bl	0x800f6c8 <z_data_copy> @ imm = #-0x34a2
; 	z_arm_interrupt_init();
 8012b6a: f000 f83d    	bl	0x8012be8 <z_arm_interrupt_init> @ imm = #0x7a
; 	z_cstart();
 8012b6e: f7f9 fb7b    	bl	0x800c268 <z_cstart>    @ imm = #-0x690a

08012b72 <z_arm_prepare_switch_to_main>:
; {
 8012b72: b480         	push	{r7}
 8012b74: af00         	add	r7, sp, #0x0
; }
 8012b76: bf00         	nop
 8012b78: 46bd         	mov	sp, r7
 8012b7a: bc80         	pop	{r7}
 8012b7c: 4770         	bx	lr

08012b7e <arch_irq_unlock_outlined>:
; {
 8012b7e: b480         	push	{r7}
 8012b80: b085         	sub	sp, #0x14
 8012b82: af00         	add	r7, sp, #0x0
 8012b84: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("cpsie f" : : : "memory");
 8012b86: b661         	cpsie f
; }
 8012b88: bf00         	nop
;   __ASM volatile ("cpsie i" : : : "memory");
 8012b8a: b662         	cpsie i
; }
 8012b8c: bf00         	nop
 8012b8e: 687b         	ldr	r3, [r7, #0x4]
 8012b90: 60fb         	str	r3, [r7, #0xc]
 8012b92: 68fb         	ldr	r3, [r7, #0xc]
 8012b94: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8012b96: 68bb         	ldr	r3, [r7, #0x8]
 8012b98: f383 8811    	msr	basepri, r3
; }
 8012b9c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012b9e: f3bf 8f6f    	isb	sy
; }
 8012ba2: bf00         	nop
; }
 8012ba4: bf00         	nop
; }
 8012ba6: bf00         	nop
 8012ba8: 3714         	adds	r7, #0x14
 8012baa: 46bd         	mov	sp, r7
 8012bac: bc80         	pop	{r7}
 8012bae: 4770         	bx	lr

08012bb0 <arch_cpu_idle>:
; {
 8012bb0: b480         	push	{r7}
 8012bb2: b083         	sub	sp, #0xc
 8012bb4: af00         	add	r7, sp, #0x0
;   __ASM volatile ("cpsid i" : : : "memory");
 8012bb6: b672         	cpsid i
; }
 8012bb8: bf00         	nop
 8012bba: 2300         	movs	r3, #0x0
 8012bbc: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8012bbe: 687b         	ldr	r3, [r7, #0x4]
 8012bc0: f383 8811    	msr	basepri, r3
; }
 8012bc4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012bc6: f3bf 8f6f    	isb	sy
; }
 8012bca: bf00         	nop
;   __ASM volatile ("dsb 0xF":::"memory");
 8012bcc: f3bf 8f4f    	dsb	sy
; }
 8012bd0: bf00         	nop
; 	SLEEP_IF_ALLOWED(__WFI);
 8012bd2: bf30         	wfi
;   __ASM volatile ("cpsie i" : : : "memory");
 8012bd4: b662         	cpsie i
; }
 8012bd6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012bd8: f3bf 8f6f    	isb	sy
; }
 8012bdc: bf00         	nop
; }
 8012bde: bf00         	nop
 8012be0: 370c         	adds	r7, #0xc
 8012be2: 46bd         	mov	sp, r7
 8012be4: bc80         	pop	{r7}
 8012be6: 4770         	bx	lr

08012be8 <z_arm_interrupt_init>:
; {
 8012be8: b580         	push	{r7, lr}
 8012bea: b082         	sub	sp, #0x8
 8012bec: af00         	add	r7, sp, #0x0
; 	int irq = 0;
 8012bee: 2300         	movs	r3, #0x0
 8012bf0: 607b         	str	r3, [r7, #0x4]
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 8012bf2: e008         	b	0x8012c06 <z_arm_interrupt_init+0x1e> @ imm = #0x10
; 		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
 8012bf4: 687b         	ldr	r3, [r7, #0x4]
 8012bf6: b25b         	sxtb	r3, r3
 8012bf8: 2101         	movs	r1, #0x1
 8012bfa: 4618         	mov	r0, r3
 8012bfc: f7f0 fd6e    	bl	0x80036dc <__NVIC_SetPriority> @ imm = #-0xf524
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 8012c00: 687b         	ldr	r3, [r7, #0x4]
 8012c02: 3301         	adds	r3, #0x1
 8012c04: 607b         	str	r3, [r7, #0x4]
 8012c06: 687b         	ldr	r3, [r7, #0x4]
 8012c08: 2b51         	cmp	r3, #0x51
 8012c0a: ddf3         	ble	0x8012bf4 <z_arm_interrupt_init+0xc> @ imm = #-0x1a
; }
 8012c0c: bf00         	nop
 8012c0e: bf00         	nop
 8012c10: 3708         	adds	r7, #0x8
 8012c12: 46bd         	mov	sp, r7
 8012c14: bd80         	pop	{r7, pc}

08012c16 <cbputc>:
; {
 8012c16: b580         	push	{r7, lr}
 8012c18: b084         	sub	sp, #0x10
 8012c1a: af00         	add	r7, sp, #0x0
 8012c1c: 4603         	mov	r3, r0
 8012c1e: 6039         	str	r1, [r7]
 8012c20: 71fb         	strb	r3, [r7, #0x7]
; 	struct cb_bits *s = (struct cb_bits *) _s;
 8012c22: 683b         	ldr	r3, [r7]
 8012c24: 60fb         	str	r3, [r7, #0xc]
; 	(*s->out) (c, s->ctx);
 8012c26: 68fb         	ldr	r3, [r7, #0xc]
 8012c28: 691b         	ldr	r3, [r3, #0x10]
 8012c2a: 79f8         	ldrb	r0, [r7, #0x7]
 8012c2c: 68fa         	ldr	r2, [r7, #0xc]
 8012c2e: 6952         	ldr	r2, [r2, #0x14]
 8012c30: 4611         	mov	r1, r2
 8012c32: 4798         	blx	r3
; 	return 0;
 8012c34: 2300         	movs	r3, #0x0
; }
 8012c36: 4618         	mov	r0, r3
 8012c38: 3710         	adds	r7, #0x10
 8012c3a: 46bd         	mov	sp, r7
 8012c3c: bd80         	pop	{r7, pc}

08012c3e <zephyr_fputc>:
; {
 8012c3e: b580         	push	{r7, lr}
 8012c40: b082         	sub	sp, #0x8
 8012c42: af00         	add	r7, sp, #0x0
 8012c44: 6078         	str	r0, [r7, #0x4]
 8012c46: 6039         	str	r1, [r7]
; 	return z_impl_zephyr_fputc(c, stream);
 8012c48: 6839         	ldr	r1, [r7]
 8012c4a: 6878         	ldr	r0, [r7, #0x4]
 8012c4c: f7f0 fdb4    	bl	0x80037b8 <z_impl_zephyr_fputc> @ imm = #-0xf498
 8012c50: 4603         	mov	r3, r0
; }
 8012c52: 4618         	mov	r0, r3
 8012c54: 3708         	adds	r7, #0x8
 8012c56: 46bd         	mov	sp, r7
 8012c58: bd80         	pop	{r7, pc}

08012c5a <picolibc_put>:
; {
 8012c5a: b580         	push	{r7, lr}
 8012c5c: b082         	sub	sp, #0x8
 8012c5e: af00         	add	r7, sp, #0x0
 8012c60: 4603         	mov	r3, r0
 8012c62: 6039         	str	r1, [r7]
 8012c64: 71fb         	strb	r3, [r7, #0x7]
; 	zephyr_fputc(a, f);
 8012c66: 79fb         	ldrb	r3, [r7, #0x7]
 8012c68: 6839         	ldr	r1, [r7]
 8012c6a: 4618         	mov	r0, r3
 8012c6c: f7ff ffe7    	bl	0x8012c3e <zephyr_fputc> @ imm = #-0x32
; 	return 0;
 8012c70: 2300         	movs	r3, #0x0
; }
 8012c72: 4618         	mov	r0, r3
 8012c74: 3708         	adds	r7, #0x8
 8012c76: 46bd         	mov	sp, r7
 8012c78: bd80         	pop	{r7, pc}

08012c7a <clock_control_on>:
; {
 8012c7a: b580         	push	{r7, lr}
 8012c7c: b084         	sub	sp, #0x10
 8012c7e: af00         	add	r7, sp, #0x0
 8012c80: 6078         	str	r0, [r7, #0x4]
 8012c82: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8012c84: 687b         	ldr	r3, [r7, #0x4]
 8012c86: 689b         	ldr	r3, [r3, #0x8]
 8012c88: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8012c8a: 68fb         	ldr	r3, [r7, #0xc]
 8012c8c: 681b         	ldr	r3, [r3]
 8012c8e: 6839         	ldr	r1, [r7]
 8012c90: 6878         	ldr	r0, [r7, #0x4]
 8012c92: 4798         	blx	r3
 8012c94: 4603         	mov	r3, r0
; }
 8012c96: 4618         	mov	r0, r3
 8012c98: 3710         	adds	r7, #0x10
 8012c9a: 46bd         	mov	sp, r7
 8012c9c: bd80         	pop	{r7, pc}

08012c9e <z_stm32_hsem_lock>:
; {
 8012c9e: b480         	push	{r7}
 8012ca0: b083         	sub	sp, #0xc
 8012ca2: af00         	add	r7, sp, #0x0
 8012ca4: 6078         	str	r0, [r7, #0x4]
 8012ca6: 6039         	str	r1, [r7]
; }
 8012ca8: bf00         	nop
 8012caa: 370c         	adds	r7, #0xc
 8012cac: 46bd         	mov	sp, r7
 8012cae: bc80         	pop	{r7}
 8012cb0: 4770         	bx	lr

08012cb2 <z_stm32_hsem_unlock>:
; {
 8012cb2: b480         	push	{r7}
 8012cb4: b083         	sub	sp, #0xc
 8012cb6: af00         	add	r7, sp, #0x0
 8012cb8: 6078         	str	r0, [r7, #0x4]
; }
 8012cba: bf00         	nop
 8012cbc: 370c         	adds	r7, #0xc
 8012cbe: 46bd         	mov	sp, r7
 8012cc0: bc80         	pop	{r7}
 8012cc2: 4770         	bx	lr

08012cc4 <stm32_exti_linenum_to_src_cfg_line>:
; {
 8012cc4: b480         	push	{r7}
 8012cc6: b083         	sub	sp, #0xc
 8012cc8: af00         	add	r7, sp, #0x0
 8012cca: 4603         	mov	r3, r0
 8012ccc: 71fb         	strb	r3, [r7, #0x7]
; 	return (0xF << ((linenum % 4 * 4) + 16)) | (linenum / 4);
 8012cce: 79fb         	ldrb	r3, [r7, #0x7]
 8012cd0: f003 0303    	and	r3, r3, #0x3
 8012cd4: 3304         	adds	r3, #0x4
 8012cd6: 009b         	lsls	r3, r3, #0x2
 8012cd8: 220f         	movs	r2, #0xf
 8012cda: fa02 f303    	lsl.w	r3, r2, r3
 8012cde: 79fa         	ldrb	r2, [r7, #0x7]
 8012ce0: 0892         	lsrs	r2, r2, #0x2
 8012ce2: b2d2         	uxtb	r2, r2
 8012ce4: 4313         	orrs	r3, r2
; }
 8012ce6: 4618         	mov	r0, r3
 8012ce8: 370c         	adds	r7, #0xc
 8012cea: 46bd         	mov	sp, r7
 8012cec: bc80         	pop	{r7}
 8012cee: 4770         	bx	lr

08012cf0 <stm32_exti_is_pending>:
; {
 8012cf0: b580         	push	{r7, lr}
 8012cf2: b082         	sub	sp, #0x8
 8012cf4: af00         	add	r7, sp, #0x0
 8012cf6: 6078         	str	r0, [r7, #0x4]
; 	return LL_EXTI_IsActiveFlag_0_31(line);
 8012cf8: 6878         	ldr	r0, [r7, #0x4]
 8012cfa: f7f0 fe13    	bl	0x8003924 <LL_EXTI_IsActiveFlag_0_31> @ imm = #-0xf3da
 8012cfe: 4603         	mov	r3, r0
; }
 8012d00: 4618         	mov	r0, r3
 8012d02: 3708         	adds	r7, #0x8
 8012d04: 46bd         	mov	sp, r7
 8012d06: bd80         	pop	{r7, pc}

08012d08 <stm32_exti_clear_pending>:
; {
 8012d08: b580         	push	{r7, lr}
 8012d0a: b082         	sub	sp, #0x8
 8012d0c: af00         	add	r7, sp, #0x0
 8012d0e: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_ClearFlag_0_31(line);
 8012d10: 6878         	ldr	r0, [r7, #0x4]
 8012d12: f7f0 fe1d    	bl	0x8003950 <LL_EXTI_ClearFlag_0_31> @ imm = #-0xf3c6
; }
 8012d16: bf00         	nop
 8012d18: 3708         	adds	r7, #0x8
 8012d1a: 46bd         	mov	sp, r7
 8012d1c: bd80         	pop	{r7, pc}

08012d1e <linenum_to_ll_exti_line>:
; {
 8012d1e: b480         	push	{r7}
 8012d20: b083         	sub	sp, #0xc
 8012d22: af00         	add	r7, sp, #0x0
 8012d24: 4603         	mov	r3, r0
 8012d26: 71fb         	strb	r3, [r7, #0x7]
; 	return BIT(linenum);
 8012d28: 79fb         	ldrb	r3, [r7, #0x7]
 8012d2a: 2201         	movs	r2, #0x1
 8012d2c: fa02 f303    	lsl.w	r3, r2, r3
; }
 8012d30: 4618         	mov	r0, r3
 8012d32: 370c         	adds	r7, #0xc
 8012d34: 46bd         	mov	sp, r7
 8012d36: bc80         	pop	{r7}
 8012d38: 4770         	bx	lr

08012d3a <ll_exti_line_to_linenum>:
; {
 8012d3a: b480         	push	{r7}
 8012d3c: b083         	sub	sp, #0xc
 8012d3e: af00         	add	r7, sp, #0x0
 8012d40: 6078         	str	r0, [r7, #0x4]
; 	return LOG2(line);
 8012d42: 687b         	ldr	r3, [r7, #0x4]
 8012d44: 2b00         	cmp	r3, #0x0
 8012d46: d007         	beq	0x8012d58 <ll_exti_line_to_linenum+0x1e> @ imm = #0xe
 8012d48: 687b         	ldr	r3, [r7, #0x4]
 8012d4a: fab3 f383    	clz	r3, r3
 8012d4e: b2db         	uxtb	r3, r3
 8012d50: f1c3 031f    	rsb.w	r3, r3, #0x1f
 8012d54: b2db         	uxtb	r3, r3
 8012d56: e000         	b	0x8012d5a <ll_exti_line_to_linenum+0x20> @ imm = #0x0
 8012d58: 23ff         	movs	r3, #0xff
; }
 8012d5a: 4618         	mov	r0, r3
 8012d5c: 370c         	adds	r7, #0xc
 8012d5e: 46bd         	mov	sp, r7
 8012d60: bc80         	pop	{r7}
 8012d62: 4770         	bx	lr

08012d64 <stm32_gpio_intc_get_pin_irq_line>:
; {
 8012d64: b580         	push	{r7, lr}
 8012d66: b082         	sub	sp, #0x8
 8012d68: af00         	add	r7, sp, #0x0
 8012d6a: 6078         	str	r0, [r7, #0x4]
 8012d6c: 460b         	mov	r3, r1
 8012d6e: 70fb         	strb	r3, [r7, #0x3]
; 	return linenum_to_ll_exti_line(pin);
 8012d70: 78fb         	ldrb	r3, [r7, #0x3]
 8012d72: 4618         	mov	r0, r3
 8012d74: f7ff ffd3    	bl	0x8012d1e <linenum_to_ll_exti_line> @ imm = #-0x5a
 8012d78: 4603         	mov	r3, r0
; }
 8012d7a: 4618         	mov	r0, r3
 8012d7c: 3708         	adds	r7, #0x8
 8012d7e: 46bd         	mov	sp, r7
 8012d80: bd80         	pop	{r7, pc}

08012d82 <stm32_gpio_intc_disable_line>:
; {
 8012d82: b580         	push	{r7, lr}
 8012d84: b082         	sub	sp, #0x8
 8012d86: af00         	add	r7, sp, #0x0
 8012d88: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_DisableIT_0_31(line);
 8012d8a: 6878         	ldr	r0, [r7, #0x4]
 8012d8c: f7f0 fd70    	bl	0x8003870 <LL_EXTI_DisableIT_0_31> @ imm = #-0xf520
; }
 8012d90: bf00         	nop
 8012d92: 3708         	adds	r7, #0x8
 8012d94: 46bd         	mov	sp, r7
 8012d96: bd80         	pop	{r7, pc}

08012d98 <stm32_exti_set_line_src_port>:
; {
 8012d98: b580         	push	{r7, lr}
 8012d9a: b084         	sub	sp, #0x10
 8012d9c: af00         	add	r7, sp, #0x0
 8012d9e: 4603         	mov	r3, r0
 8012da0: 6039         	str	r1, [r7]
 8012da2: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 8012da4: 79fb         	ldrb	r3, [r7, #0x7]
 8012da6: 4618         	mov	r0, r3
 8012da8: f7ff ff8c    	bl	0x8012cc4 <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0xe8
 8012dac: 60f8         	str	r0, [r7, #0xc]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8012dae: f44f 1180    	mov.w	r1, #0x100000
 8012db2: 2000         	movs	r0, #0x0
 8012db4: f7ff ff73    	bl	0x8012c9e <z_stm32_hsem_lock> @ imm = #-0x11a
; 	LL_SYSCFG_SetEXTISource(port, ll_line);
 8012db8: 68f9         	ldr	r1, [r7, #0xc]
 8012dba: 6838         	ldr	r0, [r7]
 8012dbc: f7f0 fdd6    	bl	0x800396c <LL_SYSCFG_SetEXTISource> @ imm = #-0xf454
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 8012dc0: 2000         	movs	r0, #0x0
 8012dc2: f7ff ff76    	bl	0x8012cb2 <z_stm32_hsem_unlock> @ imm = #-0x114
; }
 8012dc6: bf00         	nop
 8012dc8: 3710         	adds	r7, #0x10
 8012dca: 46bd         	mov	sp, r7
 8012dcc: bd80         	pop	{r7, pc}

08012dce <stm32_exti_get_line_src_port>:
; {
 8012dce: b580         	push	{r7, lr}
 8012dd0: b084         	sub	sp, #0x10
 8012dd2: af00         	add	r7, sp, #0x0
 8012dd4: 4603         	mov	r3, r0
 8012dd6: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 8012dd8: 79fb         	ldrb	r3, [r7, #0x7]
 8012dda: 4618         	mov	r0, r3
 8012ddc: f7ff ff72    	bl	0x8012cc4 <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0x11c
 8012de0: 60f8         	str	r0, [r7, #0xc]
; 	port = LL_SYSCFG_GetEXTISource(ll_line);
 8012de2: 68f8         	ldr	r0, [r7, #0xc]
 8012de4: f7f0 fdf6    	bl	0x80039d4 <LL_SYSCFG_GetEXTISource> @ imm = #-0xf414
 8012de8: 60b8         	str	r0, [r7, #0x8]
; 	return port;
 8012dea: 68bb         	ldr	r3, [r7, #0x8]
; }
 8012dec: 4618         	mov	r0, r3
 8012dee: 3710         	adds	r7, #0x10
 8012df0: 46bd         	mov	sp, r7
 8012df2: bd80         	pop	{r7, pc}

08012df4 <k_sem_init>:
; {
 8012df4: b580         	push	{r7, lr}
 8012df6: b084         	sub	sp, #0x10
 8012df8: af00         	add	r7, sp, #0x0
 8012dfa: 60f8         	str	r0, [r7, #0xc]
 8012dfc: 60b9         	str	r1, [r7, #0x8]
 8012dfe: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 8012e00: 687a         	ldr	r2, [r7, #0x4]
 8012e02: 68b9         	ldr	r1, [r7, #0x8]
 8012e04: 68f8         	ldr	r0, [r7, #0xc]
 8012e06: f006 f9d4    	bl	0x80191b2 <z_impl_k_sem_init> @ imm = #0x63a8
 8012e0a: 4603         	mov	r3, r0
; }
 8012e0c: 4618         	mov	r0, r3
 8012e0e: 3710         	adds	r7, #0x10
 8012e10: 46bd         	mov	sp, r7
 8012e12: bd80         	pop	{r7, pc}

08012e14 <k_sem_take>:
; {
 8012e14: b580         	push	{r7, lr}
 8012e16: b084         	sub	sp, #0x10
 8012e18: af00         	add	r7, sp, #0x0
 8012e1a: 60f8         	str	r0, [r7, #0xc]
 8012e1c: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 8012e20: e9d7 2300    	ldrd	r2, r3, [r7]
 8012e24: 68f8         	ldr	r0, [r7, #0xc]
 8012e26: f7fa f85d    	bl	0x800cee4 <z_impl_k_sem_take> @ imm = #-0x5f46
 8012e2a: 4603         	mov	r3, r0
; }
 8012e2c: 4618         	mov	r0, r3
 8012e2e: 3710         	adds	r7, #0x10
 8012e30: 46bd         	mov	sp, r7
 8012e32: bd80         	pop	{r7, pc}

08012e34 <k_sem_give>:
; {
 8012e34: b580         	push	{r7, lr}
 8012e36: b082         	sub	sp, #0x8
 8012e38: af00         	add	r7, sp, #0x0
 8012e3a: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 8012e3c: 6878         	ldr	r0, [r7, #0x4]
 8012e3e: f7f9 ffc3    	bl	0x800cdc8 <z_impl_k_sem_give> @ imm = #-0x607a
; }
 8012e42: bf00         	nop
 8012e44: 3708         	adds	r7, #0x8
 8012e46: 46bd         	mov	sp, r7
 8012e48: bd80         	pop	{r7, pc}

08012e4a <z_impl_can_get_core_clock>:
; {
 8012e4a: b580         	push	{r7, lr}
 8012e4c: b084         	sub	sp, #0x10
 8012e4e: af00         	add	r7, sp, #0x0
 8012e50: 6078         	str	r0, [r7, #0x4]
 8012e52: 6039         	str	r1, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8012e54: 687b         	ldr	r3, [r7, #0x4]
 8012e56: 689b         	ldr	r3, [r3, #0x8]
 8012e58: 60fb         	str	r3, [r7, #0xc]
; 	return api->get_core_clock(dev, rate);
 8012e5a: 68fb         	ldr	r3, [r7, #0xc]
 8012e5c: 6a9b         	ldr	r3, [r3, #0x28]
 8012e5e: 6839         	ldr	r1, [r7]
 8012e60: 6878         	ldr	r0, [r7, #0x4]
 8012e62: 4798         	blx	r3
 8012e64: 4603         	mov	r3, r0
; }
 8012e66: 4618         	mov	r0, r3
 8012e68: 3710         	adds	r7, #0x10
 8012e6a: 46bd         	mov	sp, r7
 8012e6c: bd80         	pop	{r7, pc}

08012e6e <z_impl_can_get_timing_min>:
; {
 8012e6e: b480         	push	{r7}
 8012e70: b085         	sub	sp, #0x14
 8012e72: af00         	add	r7, sp, #0x0
 8012e74: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8012e76: 687b         	ldr	r3, [r7, #0x4]
 8012e78: 689b         	ldr	r3, [r3, #0x8]
 8012e7a: 60fb         	str	r3, [r7, #0xc]
; 	return &api->timing_min;
 8012e7c: 68fb         	ldr	r3, [r7, #0xc]
 8012e7e: 3330         	adds	r3, #0x30
; }
 8012e80: 4618         	mov	r0, r3
 8012e82: 3714         	adds	r7, #0x14
 8012e84: 46bd         	mov	sp, r7
 8012e86: bc80         	pop	{r7}
 8012e88: 4770         	bx	lr

08012e8a <z_impl_can_get_timing_max>:
; {
 8012e8a: b480         	push	{r7}
 8012e8c: b085         	sub	sp, #0x14
 8012e8e: af00         	add	r7, sp, #0x0
 8012e90: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8012e92: 687b         	ldr	r3, [r7, #0x4]
 8012e94: 689b         	ldr	r3, [r3, #0x8]
 8012e96: 60fb         	str	r3, [r7, #0xc]
; 	return &api->timing_max;
 8012e98: 68fb         	ldr	r3, [r7, #0xc]
 8012e9a: 333a         	adds	r3, #0x3a
; }
 8012e9c: 4618         	mov	r0, r3
 8012e9e: 3714         	adds	r7, #0x14
 8012ea0: 46bd         	mov	sp, r7
 8012ea2: bc80         	pop	{r7}
 8012ea4: 4770         	bx	lr

08012ea6 <can_get_core_clock>:
; {
 8012ea6: b580         	push	{r7, lr}
 8012ea8: b082         	sub	sp, #0x8
 8012eaa: af00         	add	r7, sp, #0x0
 8012eac: 6078         	str	r0, [r7, #0x4]
 8012eae: 6039         	str	r1, [r7]
; 	return z_impl_can_get_core_clock(dev, rate);
 8012eb0: 6839         	ldr	r1, [r7]
 8012eb2: 6878         	ldr	r0, [r7, #0x4]
 8012eb4: f7ff ffc9    	bl	0x8012e4a <z_impl_can_get_core_clock> @ imm = #-0x6e
 8012eb8: 4603         	mov	r3, r0
; }
 8012eba: 4618         	mov	r0, r3
 8012ebc: 3708         	adds	r7, #0x8
 8012ebe: 46bd         	mov	sp, r7
 8012ec0: bd80         	pop	{r7, pc}

08012ec2 <can_get_timing_min>:
; {
 8012ec2: b580         	push	{r7, lr}
 8012ec4: b082         	sub	sp, #0x8
 8012ec6: af00         	add	r7, sp, #0x0
 8012ec8: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_get_timing_min(dev);
 8012eca: 6878         	ldr	r0, [r7, #0x4]
 8012ecc: f7ff ffcf    	bl	0x8012e6e <z_impl_can_get_timing_min> @ imm = #-0x62
 8012ed0: 4603         	mov	r3, r0
; }
 8012ed2: 4618         	mov	r0, r3
 8012ed4: 3708         	adds	r7, #0x8
 8012ed6: 46bd         	mov	sp, r7
 8012ed8: bd80         	pop	{r7, pc}

08012eda <can_get_timing_max>:
; {
 8012eda: b580         	push	{r7, lr}
 8012edc: b082         	sub	sp, #0x8
 8012ede: af00         	add	r7, sp, #0x0
 8012ee0: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_get_timing_max(dev);
 8012ee2: 6878         	ldr	r0, [r7, #0x4]
 8012ee4: f7ff ffd1    	bl	0x8012e8a <z_impl_can_get_timing_max> @ imm = #-0x5e
 8012ee8: 4603         	mov	r3, r0
; }
 8012eea: 4618         	mov	r0, r3
 8012eec: 3708         	adds	r7, #0x8
 8012eee: 46bd         	mov	sp, r7
 8012ef0: bd80         	pop	{r7, pc}

08012ef2 <z_log_msg_runtime_create>:
; {
 8012ef2: b580         	push	{r7, lr}
 8012ef4: b08a         	sub	sp, #0x28
 8012ef6: af04         	add	r7, sp, #0x10
 8012ef8: 60b9         	str	r1, [r7, #0x8]
 8012efa: 607b         	str	r3, [r7, #0x4]
 8012efc: 4603         	mov	r3, r0
 8012efe: 73fb         	strb	r3, [r7, #0xf]
 8012f00: 4613         	mov	r3, r2
 8012f02: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8012f04: f107 032c    	add.w	r3, r7, #0x2c
 8012f08: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8012f0a: 7bba         	ldrb	r2, [r7, #0xe]
 8012f0c: 7bf8         	ldrb	r0, [r7, #0xf]
 8012f0e: 697b         	ldr	r3, [r7, #0x14]
 8012f10: 9303         	str	r3, [sp, #0xc]
 8012f12: 6abb         	ldr	r3, [r7, #0x28]
 8012f14: 9302         	str	r3, [sp, #0x8]
 8012f16: 6a7b         	ldr	r3, [r7, #0x24]
 8012f18: 9301         	str	r3, [sp, #0x4]
 8012f1a: 6a3b         	ldr	r3, [r7, #0x20]
 8012f1c: 9300         	str	r3, [sp]
 8012f1e: 687b         	ldr	r3, [r7, #0x4]
 8012f20: 68b9         	ldr	r1, [r7, #0x8]
 8012f22: f7ee fea3    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x112ba
; }
 8012f26: bf00         	nop
 8012f28: 3718         	adds	r7, #0x18
 8012f2a: 46bd         	mov	sp, r7
 8012f2c: bd80         	pop	{r7, pc}

08012f2e <can_tx_default_cb>:
; {
 8012f2e: b580         	push	{r7, lr}
 8012f30: b086         	sub	sp, #0x18
 8012f32: af00         	add	r7, sp, #0x0
 8012f34: 60f8         	str	r0, [r7, #0xc]
 8012f36: 60b9         	str	r1, [r7, #0x8]
 8012f38: 607a         	str	r2, [r7, #0x4]
; 	struct can_tx_default_cb_ctx *ctx = user_data;
 8012f3a: 687b         	ldr	r3, [r7, #0x4]
 8012f3c: 617b         	str	r3, [r7, #0x14]
; 	ctx->status = error;
 8012f3e: 697b         	ldr	r3, [r7, #0x14]
 8012f40: 68ba         	ldr	r2, [r7, #0x8]
 8012f42: 611a         	str	r2, [r3, #0x10]
; 	k_sem_give(&ctx->done);
 8012f44: 697b         	ldr	r3, [r7, #0x14]
 8012f46: 4618         	mov	r0, r3
 8012f48: f7ff ff74    	bl	0x8012e34 <k_sem_give>  @ imm = #-0x118
; }
 8012f4c: bf00         	nop
 8012f4e: 3718         	adds	r7, #0x18
 8012f50: 46bd         	mov	sp, r7
 8012f52: bd80         	pop	{r7, pc}

08012f54 <check_timing_in_range>:
; {
 8012f54: b480         	push	{r7}
 8012f56: b085         	sub	sp, #0x14
 8012f58: af00         	add	r7, sp, #0x0
 8012f5a: 60f8         	str	r0, [r7, #0xc]
 8012f5c: 60b9         	str	r1, [r7, #0x8]
 8012f5e: 607a         	str	r2, [r7, #0x4]
; 	if (!IN_RANGE(timing->sjw, min->sjw, max->sjw) ||
 8012f60: 68fb         	ldr	r3, [r7, #0xc]
 8012f62: 881a         	ldrh	r2, [r3]
 8012f64: 68bb         	ldr	r3, [r7, #0x8]
 8012f66: 881b         	ldrh	r3, [r3]
 8012f68: 429a         	cmp	r2, r3
 8012f6a: d335         	blo	0x8012fd8 <check_timing_in_range+0x84> @ imm = #0x6a
 8012f6c: 68fb         	ldr	r3, [r7, #0xc]
 8012f6e: 881a         	ldrh	r2, [r3]
 8012f70: 687b         	ldr	r3, [r7, #0x4]
 8012f72: 881b         	ldrh	r3, [r3]
 8012f74: 429a         	cmp	r2, r3
 8012f76: d82f         	bhi	0x8012fd8 <check_timing_in_range+0x84> @ imm = #0x5e
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 8012f78: 68fb         	ldr	r3, [r7, #0xc]
 8012f7a: 885a         	ldrh	r2, [r3, #0x2]
 8012f7c: 68bb         	ldr	r3, [r7, #0x8]
 8012f7e: 885b         	ldrh	r3, [r3, #0x2]
; 	if (!IN_RANGE(timing->sjw, min->sjw, max->sjw) ||
 8012f80: 429a         	cmp	r2, r3
 8012f82: d329         	blo	0x8012fd8 <check_timing_in_range+0x84> @ imm = #0x52
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 8012f84: 68fb         	ldr	r3, [r7, #0xc]
 8012f86: 885a         	ldrh	r2, [r3, #0x2]
 8012f88: 687b         	ldr	r3, [r7, #0x4]
 8012f8a: 885b         	ldrh	r3, [r3, #0x2]
 8012f8c: 429a         	cmp	r2, r3
 8012f8e: d823         	bhi	0x8012fd8 <check_timing_in_range+0x84> @ imm = #0x46
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 8012f90: 68fb         	ldr	r3, [r7, #0xc]
 8012f92: 889a         	ldrh	r2, [r3, #0x4]
 8012f94: 68bb         	ldr	r3, [r7, #0x8]
 8012f96: 889b         	ldrh	r3, [r3, #0x4]
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 8012f98: 429a         	cmp	r2, r3
 8012f9a: d31d         	blo	0x8012fd8 <check_timing_in_range+0x84> @ imm = #0x3a
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 8012f9c: 68fb         	ldr	r3, [r7, #0xc]
 8012f9e: 889a         	ldrh	r2, [r3, #0x4]
 8012fa0: 687b         	ldr	r3, [r7, #0x4]
 8012fa2: 889b         	ldrh	r3, [r3, #0x4]
 8012fa4: 429a         	cmp	r2, r3
 8012fa6: d817         	bhi	0x8012fd8 <check_timing_in_range+0x84> @ imm = #0x2e
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 8012fa8: 68fb         	ldr	r3, [r7, #0xc]
 8012faa: 88da         	ldrh	r2, [r3, #0x6]
 8012fac: 68bb         	ldr	r3, [r7, #0x8]
 8012fae: 88db         	ldrh	r3, [r3, #0x6]
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 8012fb0: 429a         	cmp	r2, r3
 8012fb2: d311         	blo	0x8012fd8 <check_timing_in_range+0x84> @ imm = #0x22
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 8012fb4: 68fb         	ldr	r3, [r7, #0xc]
 8012fb6: 88da         	ldrh	r2, [r3, #0x6]
 8012fb8: 687b         	ldr	r3, [r7, #0x4]
 8012fba: 88db         	ldrh	r3, [r3, #0x6]
 8012fbc: 429a         	cmp	r2, r3
 8012fbe: d80b         	bhi	0x8012fd8 <check_timing_in_range+0x84> @ imm = #0x16
; 	    !IN_RANGE(timing->prescaler, min->prescaler, max->prescaler)) {
 8012fc0: 68fb         	ldr	r3, [r7, #0xc]
 8012fc2: 891a         	ldrh	r2, [r3, #0x8]
 8012fc4: 68bb         	ldr	r3, [r7, #0x8]
 8012fc6: 891b         	ldrh	r3, [r3, #0x8]
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 8012fc8: 429a         	cmp	r2, r3
 8012fca: d305         	blo	0x8012fd8 <check_timing_in_range+0x84> @ imm = #0xa
; 	    !IN_RANGE(timing->prescaler, min->prescaler, max->prescaler)) {
 8012fcc: 68fb         	ldr	r3, [r7, #0xc]
 8012fce: 891a         	ldrh	r2, [r3, #0x8]
 8012fd0: 687b         	ldr	r3, [r7, #0x4]
 8012fd2: 891b         	ldrh	r3, [r3, #0x8]
 8012fd4: 429a         	cmp	r2, r3
 8012fd6: d902         	bls	0x8012fde <check_timing_in_range+0x8a> @ imm = #0x4
; 		return -ENOTSUP;
 8012fd8: f06f 0385    	mvn	r3, #0x85
 8012fdc: e00f         	b	0x8012ffe <check_timing_in_range+0xaa> @ imm = #0x1e
; 	if ((timing->sjw > timing->phase_seg1) || (timing->sjw > timing->phase_seg2)) {
 8012fde: 68fb         	ldr	r3, [r7, #0xc]
 8012fe0: 881a         	ldrh	r2, [r3]
 8012fe2: 68fb         	ldr	r3, [r7, #0xc]
 8012fe4: 889b         	ldrh	r3, [r3, #0x4]
 8012fe6: 429a         	cmp	r2, r3
 8012fe8: d805         	bhi	0x8012ff6 <check_timing_in_range+0xa2> @ imm = #0xa
 8012fea: 68fb         	ldr	r3, [r7, #0xc]
 8012fec: 881a         	ldrh	r2, [r3]
 8012fee: 68fb         	ldr	r3, [r7, #0xc]
 8012ff0: 88db         	ldrh	r3, [r3, #0x6]
 8012ff2: 429a         	cmp	r2, r3
 8012ff4: d902         	bls	0x8012ffc <check_timing_in_range+0xa8> @ imm = #0x4
; 		return -ENOTSUP;
 8012ff6: f06f 0385    	mvn	r3, #0x85
 8012ffa: e000         	b	0x8012ffe <check_timing_in_range+0xaa> @ imm = #0x0
; 	return 0;
 8012ffc: 2300         	movs	r3, #0x0
; }
 8012ffe: 4618         	mov	r0, r3
 8013000: 3714         	adds	r7, #0x14
 8013002: 46bd         	mov	sp, r7
 8013004: bc80         	pop	{r7}
 8013006: 4770         	bx	lr

08013008 <z_impl_can_set_timing>:
; {
 8013008: b580         	push	{r7, lr}
 801300a: b086         	sub	sp, #0x18
 801300c: af00         	add	r7, sp, #0x0
 801300e: 6078         	str	r0, [r7, #0x4]
 8013010: 6039         	str	r1, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8013012: 687b         	ldr	r3, [r7, #0x4]
 8013014: 689b         	ldr	r3, [r3, #0x8]
 8013016: 617b         	str	r3, [r7, #0x14]
; 	const struct can_timing *min = can_get_timing_min(dev);
 8013018: 6878         	ldr	r0, [r7, #0x4]
 801301a: f7ff ff52    	bl	0x8012ec2 <can_get_timing_min> @ imm = #-0x15c
 801301e: 6138         	str	r0, [r7, #0x10]
; 	const struct can_timing *max = can_get_timing_max(dev);
 8013020: 6878         	ldr	r0, [r7, #0x4]
 8013022: f7ff ff5a    	bl	0x8012eda <can_get_timing_max> @ imm = #-0x14c
 8013026: 60f8         	str	r0, [r7, #0xc]
; 	err = check_timing_in_range(timing, min, max);
 8013028: 68fa         	ldr	r2, [r7, #0xc]
 801302a: 6939         	ldr	r1, [r7, #0x10]
 801302c: 6838         	ldr	r0, [r7]
 801302e: f7ff ff91    	bl	0x8012f54 <check_timing_in_range> @ imm = #-0xde
 8013032: 60b8         	str	r0, [r7, #0x8]
; 	if (err != 0) {
 8013034: 68bb         	ldr	r3, [r7, #0x8]
 8013036: 2b00         	cmp	r3, #0x0
 8013038: d001         	beq	0x801303e <z_impl_can_set_timing+0x36> @ imm = #0x2
; 		return err;
 801303a: 68bb         	ldr	r3, [r7, #0x8]
 801303c: e005         	b	0x801304a <z_impl_can_set_timing+0x42> @ imm = #0xa
; 	return api->set_timing(dev, timing);
 801303e: 697b         	ldr	r3, [r7, #0x14]
 8013040: 691b         	ldr	r3, [r3, #0x10]
 8013042: 6839         	ldr	r1, [r7]
 8013044: 6878         	ldr	r0, [r7, #0x4]
 8013046: 4798         	blx	r3
 8013048: 4603         	mov	r3, r0
; }
 801304a: 4618         	mov	r0, r3
 801304c: 3718         	adds	r7, #0x18
 801304e: 46bd         	mov	sp, r7
 8013050: bd80         	pop	{r7, pc}

08013052 <device_is_ready>:
; {
 8013052: b580         	push	{r7, lr}
 8013054: b082         	sub	sp, #0x8
 8013056: af00         	add	r7, sp, #0x0
 8013058: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801305a: 6878         	ldr	r0, [r7, #0x4]
 801305c: f005 fbeb    	bl	0x8018836 <z_impl_device_is_ready> @ imm = #0x57d6
 8013060: 4603         	mov	r3, r0
; }
 8013062: 4618         	mov	r0, r3
 8013064: 3708         	adds	r7, #0x8
 8013066: 46bd         	mov	sp, r7
 8013068: bd80         	pop	{r7, pc}

0801306a <arch_k_cycle_get_32>:
; {
 801306a: b580         	push	{r7, lr}
 801306c: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 801306e: f7f7 fa61    	bl	0x800a534 <sys_clock_cycle_get_32> @ imm = #-0x8b3e
 8013072: 4603         	mov	r3, r0
; }
 8013074: 4618         	mov	r0, r3
 8013076: bd80         	pop	{r7, pc}

08013078 <k_cycle_get_32>:
; {
 8013078: b580         	push	{r7, lr}
 801307a: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 801307c: f7ff fff5    	bl	0x801306a <arch_k_cycle_get_32> @ imm = #-0x16
 8013080: 4603         	mov	r3, r0
; }
 8013082: 4618         	mov	r0, r3
 8013084: bd80         	pop	{r7, pc}

08013086 <k_mutex_init>:
; {
 8013086: b580         	push	{r7, lr}
 8013088: b082         	sub	sp, #0x8
 801308a: af00         	add	r7, sp, #0x0
 801308c: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_init(mutex);
 801308e: 6878         	ldr	r0, [r7, #0x4]
 8013090: f005 ffbb    	bl	0x801900a <z_impl_k_mutex_init> @ imm = #0x5f76
 8013094: 4603         	mov	r3, r0
; }
 8013096: 4618         	mov	r0, r3
 8013098: 3708         	adds	r7, #0x8
 801309a: 46bd         	mov	sp, r7
 801309c: bd80         	pop	{r7, pc}

0801309e <k_mutex_lock>:
; {
 801309e: b580         	push	{r7, lr}
 80130a0: b084         	sub	sp, #0x10
 80130a2: af00         	add	r7, sp, #0x0
 80130a4: 60f8         	str	r0, [r7, #0xc]
 80130a6: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_mutex_lock(mutex, timeout);
 80130aa: e9d7 2300    	ldrd	r2, r3, [r7]
 80130ae: 68f8         	ldr	r0, [r7, #0xc]
 80130b0: f7f9 fb46    	bl	0x800c740 <z_impl_k_mutex_lock> @ imm = #-0x6974
 80130b4: 4603         	mov	r3, r0
; }
 80130b6: 4618         	mov	r0, r3
 80130b8: 3710         	adds	r7, #0x10
 80130ba: 46bd         	mov	sp, r7
 80130bc: bd80         	pop	{r7, pc}

080130be <k_mutex_unlock>:
; {
 80130be: b580         	push	{r7, lr}
 80130c0: b082         	sub	sp, #0x8
 80130c2: af00         	add	r7, sp, #0x0
 80130c4: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_unlock(mutex);
 80130c6: 6878         	ldr	r0, [r7, #0x4]
 80130c8: f7f9 fd84    	bl	0x800cbd4 <z_impl_k_mutex_unlock> @ imm = #-0x64f8
 80130cc: 4603         	mov	r3, r0
; }
 80130ce: 4618         	mov	r0, r3
 80130d0: 3708         	adds	r7, #0x8
 80130d2: 46bd         	mov	sp, r7
 80130d4: bd80         	pop	{r7, pc}

080130d6 <k_sem_init>:
; {
 80130d6: b580         	push	{r7, lr}
 80130d8: b084         	sub	sp, #0x10
 80130da: af00         	add	r7, sp, #0x0
 80130dc: 60f8         	str	r0, [r7, #0xc]
 80130de: 60b9         	str	r1, [r7, #0x8]
 80130e0: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 80130e2: 687a         	ldr	r2, [r7, #0x4]
 80130e4: 68b9         	ldr	r1, [r7, #0x8]
 80130e6: 68f8         	ldr	r0, [r7, #0xc]
 80130e8: f006 f863    	bl	0x80191b2 <z_impl_k_sem_init> @ imm = #0x60c6
 80130ec: 4603         	mov	r3, r0
; }
 80130ee: 4618         	mov	r0, r3
 80130f0: 3710         	adds	r7, #0x10
 80130f2: 46bd         	mov	sp, r7
 80130f4: bd80         	pop	{r7, pc}

080130f6 <k_sem_take>:
; {
 80130f6: b580         	push	{r7, lr}
 80130f8: b084         	sub	sp, #0x10
 80130fa: af00         	add	r7, sp, #0x0
 80130fc: 60f8         	str	r0, [r7, #0xc]
 80130fe: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 8013102: e9d7 2300    	ldrd	r2, r3, [r7]
 8013106: 68f8         	ldr	r0, [r7, #0xc]
 8013108: f7f9 feec    	bl	0x800cee4 <z_impl_k_sem_take> @ imm = #-0x6228
 801310c: 4603         	mov	r3, r0
; }
 801310e: 4618         	mov	r0, r3
 8013110: 3710         	adds	r7, #0x10
 8013112: 46bd         	mov	sp, r7
 8013114: bd80         	pop	{r7, pc}

08013116 <k_sem_give>:
; {
 8013116: b580         	push	{r7, lr}
 8013118: b082         	sub	sp, #0x8
 801311a: af00         	add	r7, sp, #0x0
 801311c: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801311e: 6878         	ldr	r0, [r7, #0x4]
 8013120: f7f9 fe52    	bl	0x800cdc8 <z_impl_k_sem_give> @ imm = #-0x635c
; }
 8013124: bf00         	nop
 8013126: 3708         	adds	r7, #0x8
 8013128: 46bd         	mov	sp, r7
 801312a: bd80         	pop	{r7, pc}

0801312c <can_calc_timing>:
; {
 801312c: b580         	push	{r7, lr}
 801312e: b084         	sub	sp, #0x10
 8013130: af00         	add	r7, sp, #0x0
 8013132: 60f8         	str	r0, [r7, #0xc]
 8013134: 60b9         	str	r1, [r7, #0x8]
 8013136: 607a         	str	r2, [r7, #0x4]
 8013138: 807b         	strh	r3, [r7, #0x2]
; 	return z_impl_can_calc_timing(dev, res, bitrate, sample_pnt);
 801313a: 887b         	ldrh	r3, [r7, #0x2]
 801313c: 687a         	ldr	r2, [r7, #0x4]
 801313e: 68b9         	ldr	r1, [r7, #0x8]
 8013140: 68f8         	ldr	r0, [r7, #0xc]
 8013142: f7f1 f92b    	bl	0x800439c <z_impl_can_calc_timing> @ imm = #-0xedaa
 8013146: 4603         	mov	r3, r0
; }
 8013148: 4618         	mov	r0, r3
 801314a: 3710         	adds	r7, #0x10
 801314c: 46bd         	mov	sp, r7
 801314e: bd80         	pop	{r7, pc}

08013150 <can_set_timing>:
; {
 8013150: b580         	push	{r7, lr}
 8013152: b082         	sub	sp, #0x8
 8013154: af00         	add	r7, sp, #0x0
 8013156: 6078         	str	r0, [r7, #0x4]
 8013158: 6039         	str	r1, [r7]
; 	return z_impl_can_set_timing(dev, timing);
 801315a: 6839         	ldr	r1, [r7]
 801315c: 6878         	ldr	r0, [r7, #0x4]
 801315e: f7ff ff53    	bl	0x8013008 <z_impl_can_set_timing> @ imm = #-0x15a
 8013162: 4603         	mov	r3, r0
; }
 8013164: 4618         	mov	r0, r3
 8013166: 3708         	adds	r7, #0x8
 8013168: 46bd         	mov	sp, r7
 801316a: bd80         	pop	{r7, pc}

0801316c <can_transceiver_enable>:
; {
 801316c: b580         	push	{r7, lr}
 801316e: b082         	sub	sp, #0x8
 8013170: af00         	add	r7, sp, #0x0
 8013172: 6078         	str	r0, [r7, #0x4]
 8013174: 6039         	str	r1, [r7]
; 	return DEVICE_API_GET(can_transceiver, dev)->enable(dev, mode);
 8013176: 687b         	ldr	r3, [r7, #0x4]
 8013178: 689b         	ldr	r3, [r3, #0x8]
 801317a: 681b         	ldr	r3, [r3]
 801317c: 6839         	ldr	r1, [r7]
 801317e: 6878         	ldr	r0, [r7, #0x4]
 8013180: 4798         	blx	r3
 8013182: 4603         	mov	r3, r0
; }
 8013184: 4618         	mov	r0, r3
 8013186: 3708         	adds	r7, #0x8
 8013188: 46bd         	mov	sp, r7
 801318a: bd80         	pop	{r7, pc}

0801318c <can_transceiver_disable>:
; {
 801318c: b580         	push	{r7, lr}
 801318e: b082         	sub	sp, #0x8
 8013190: af00         	add	r7, sp, #0x0
 8013192: 6078         	str	r0, [r7, #0x4]
; 	return DEVICE_API_GET(can_transceiver, dev)->disable(dev);
 8013194: 687b         	ldr	r3, [r7, #0x4]
 8013196: 689b         	ldr	r3, [r3, #0x8]
 8013198: 685b         	ldr	r3, [r3, #0x4]
 801319a: 6878         	ldr	r0, [r7, #0x4]
 801319c: 4798         	blx	r3
 801319e: 4603         	mov	r3, r0
; }
 80131a0: 4618         	mov	r0, r3
 80131a2: 3708         	adds	r7, #0x8
 80131a4: 46bd         	mov	sp, r7
 80131a6: bd80         	pop	{r7, pc}

080131a8 <clock_control_on>:
; {
 80131a8: b580         	push	{r7, lr}
 80131aa: b084         	sub	sp, #0x10
 80131ac: af00         	add	r7, sp, #0x0
 80131ae: 6078         	str	r0, [r7, #0x4]
 80131b0: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 80131b2: 687b         	ldr	r3, [r7, #0x4]
 80131b4: 689b         	ldr	r3, [r3, #0x8]
 80131b6: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 80131b8: 68fb         	ldr	r3, [r7, #0xc]
 80131ba: 681b         	ldr	r3, [r3]
 80131bc: 6839         	ldr	r1, [r7]
 80131be: 6878         	ldr	r0, [r7, #0x4]
 80131c0: 4798         	blx	r3
 80131c2: 4603         	mov	r3, r0
; }
 80131c4: 4618         	mov	r0, r3
 80131c6: 3710         	adds	r7, #0x10
 80131c8: 46bd         	mov	sp, r7
 80131ca: bd80         	pop	{r7, pc}

080131cc <clock_control_get_rate>:
; {
 80131cc: b580         	push	{r7, lr}
 80131ce: b086         	sub	sp, #0x18
 80131d0: af00         	add	r7, sp, #0x0
 80131d2: 60f8         	str	r0, [r7, #0xc]
 80131d4: 60b9         	str	r1, [r7, #0x8]
 80131d6: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 80131d8: 68fb         	ldr	r3, [r7, #0xc]
 80131da: 689b         	ldr	r3, [r3, #0x8]
 80131dc: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 80131de: 697b         	ldr	r3, [r7, #0x14]
 80131e0: 68db         	ldr	r3, [r3, #0xc]
 80131e2: 2b00         	cmp	r3, #0x0
 80131e4: d102         	bne	0x80131ec <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 80131e6: f06f 0357    	mvn	r3, #0x57
 80131ea: e006         	b	0x80131fa <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 80131ec: 697b         	ldr	r3, [r7, #0x14]
 80131ee: 68db         	ldr	r3, [r3, #0xc]
 80131f0: 687a         	ldr	r2, [r7, #0x4]
 80131f2: 68b9         	ldr	r1, [r7, #0x8]
 80131f4: 68f8         	ldr	r0, [r7, #0xc]
 80131f6: 4798         	blx	r3
 80131f8: 4603         	mov	r3, r0
; }
 80131fa: 4618         	mov	r0, r3
 80131fc: 3718         	adds	r7, #0x18
 80131fe: 46bd         	mov	sp, r7
 8013200: bd80         	pop	{r7, pc}

08013202 <pinctrl_apply_state_direct>:
; {
 8013202: b580         	push	{r7, lr}
 8013204: b084         	sub	sp, #0x10
 8013206: af00         	add	r7, sp, #0x0
 8013208: 6078         	str	r0, [r7, #0x4]
 801320a: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 801320c: 2300         	movs	r3, #0x0
 801320e: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 8013210: 683b         	ldr	r3, [r7]
 8013212: 6818         	ldr	r0, [r3]
 8013214: 683b         	ldr	r3, [r7]
 8013216: 791b         	ldrb	r3, [r3, #0x4]
 8013218: 68fa         	ldr	r2, [r7, #0xc]
 801321a: 4619         	mov	r1, r3
 801321c: f002 fc33    	bl	0x8015a86 <pinctrl_configure_pins> @ imm = #0x2866
 8013220: 4603         	mov	r3, r0
; }
 8013222: 4618         	mov	r0, r3
 8013224: 3710         	adds	r7, #0x10
 8013226: 46bd         	mov	sp, r7
 8013228: bd80         	pop	{r7, pc}

0801322a <pinctrl_apply_state>:
; {
 801322a: b580         	push	{r7, lr}
 801322c: b084         	sub	sp, #0x10
 801322e: af00         	add	r7, sp, #0x0
 8013230: 6078         	str	r0, [r7, #0x4]
 8013232: 460b         	mov	r3, r1
 8013234: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 8013236: f107 0208    	add.w	r2, r7, #0x8
 801323a: 78fb         	ldrb	r3, [r7, #0x3]
 801323c: 4619         	mov	r1, r3
 801323e: 6878         	ldr	r0, [r7, #0x4]
 8013240: f002 fbea    	bl	0x8015a18 <pinctrl_lookup_state> @ imm = #0x27d4
 8013244: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8013246: 68fb         	ldr	r3, [r7, #0xc]
 8013248: 2b00         	cmp	r3, #0x0
 801324a: da01         	bge	0x8013250 <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 801324c: 68fb         	ldr	r3, [r7, #0xc]
 801324e: e005         	b	0x801325c <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 8013250: 68bb         	ldr	r3, [r7, #0x8]
 8013252: 4619         	mov	r1, r3
 8013254: 6878         	ldr	r0, [r7, #0x4]
 8013256: f7ff ffd4    	bl	0x8013202 <pinctrl_apply_state_direct> @ imm = #-0x58
 801325a: 4603         	mov	r3, r0
; }
 801325c: 4618         	mov	r0, r3
 801325e: 3710         	adds	r7, #0x10
 8013260: 46bd         	mov	sp, r7
 8013262: bd80         	pop	{r7, pc}

08013264 <z_log_msg_runtime_create>:
; {
 8013264: b580         	push	{r7, lr}
 8013266: b08a         	sub	sp, #0x28
 8013268: af04         	add	r7, sp, #0x10
 801326a: 60b9         	str	r1, [r7, #0x8]
 801326c: 607b         	str	r3, [r7, #0x4]
 801326e: 4603         	mov	r3, r0
 8013270: 73fb         	strb	r3, [r7, #0xf]
 8013272: 4613         	mov	r3, r2
 8013274: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8013276: f107 032c    	add.w	r3, r7, #0x2c
 801327a: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801327c: 7bba         	ldrb	r2, [r7, #0xe]
 801327e: 7bf8         	ldrb	r0, [r7, #0xf]
 8013280: 697b         	ldr	r3, [r7, #0x14]
 8013282: 9303         	str	r3, [sp, #0xc]
 8013284: 6abb         	ldr	r3, [r7, #0x28]
 8013286: 9302         	str	r3, [sp, #0x8]
 8013288: 6a7b         	ldr	r3, [r7, #0x24]
 801328a: 9301         	str	r3, [sp, #0x4]
 801328c: 6a3b         	ldr	r3, [r7, #0x20]
 801328e: 9300         	str	r3, [sp]
 8013290: 687b         	ldr	r3, [r7, #0x4]
 8013292: 68b9         	ldr	r1, [r7, #0x8]
 8013294: f7ee fcea    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x1162c
; }
 8013298: bf00         	nop
 801329a: 3718         	adds	r7, #0x18
 801329c: 46bd         	mov	sp, r7
 801329e: bd80         	pop	{r7, pc}

080132a0 <can_stm32_signal_tx_complete>:
; {
 80132a0: b580         	push	{r7, lr}
 80132a2: b086         	sub	sp, #0x18
 80132a4: af00         	add	r7, sp, #0x0
 80132a6: 60f8         	str	r0, [r7, #0xc]
 80132a8: 60b9         	str	r1, [r7, #0x8]
 80132aa: 607a         	str	r2, [r7, #0x4]
; 	can_tx_callback_t callback = mb->tx_callback;
 80132ac: 68bb         	ldr	r3, [r7, #0x8]
 80132ae: 681b         	ldr	r3, [r3]
 80132b0: 617b         	str	r3, [r7, #0x14]
; 	if (callback != NULL) {
 80132b2: 697b         	ldr	r3, [r7, #0x14]
 80132b4: 2b00         	cmp	r3, #0x0
 80132b6: d008         	beq	0x80132ca <can_stm32_signal_tx_complete+0x2a> @ imm = #0x10
; 		callback(dev, status, mb->callback_arg);
 80132b8: 68bb         	ldr	r3, [r7, #0x8]
 80132ba: 685a         	ldr	r2, [r3, #0x4]
 80132bc: 697b         	ldr	r3, [r7, #0x14]
 80132be: 6879         	ldr	r1, [r7, #0x4]
 80132c0: 68f8         	ldr	r0, [r7, #0xc]
 80132c2: 4798         	blx	r3
; 		mb->tx_callback = NULL;
 80132c4: 68bb         	ldr	r3, [r7, #0x8]
 80132c6: 2200         	movs	r2, #0x0
 80132c8: 601a         	str	r2, [r3]
; }
 80132ca: bf00         	nop
 80132cc: 3718         	adds	r7, #0x18
 80132ce: 46bd         	mov	sp, r7
 80132d0: bd80         	pop	{r7, pc}

080132d2 <can_stm32_rx_fifo_pop>:
; {
 80132d2: b580         	push	{r7, lr}
 80132d4: b082         	sub	sp, #0x8
 80132d6: af00         	add	r7, sp, #0x0
 80132d8: 6078         	str	r0, [r7, #0x4]
 80132da: 6039         	str	r1, [r7]
; 	memset(frame, 0, sizeof(*frame));
 80132dc: 2210         	movs	r2, #0x10
 80132de: 2100         	movs	r1, #0x0
 80132e0: 6838         	ldr	r0, [r7]
 80132e2: f007 faa5    	bl	0x801a830 <memset>      @ imm = #0x754a
; 	if (mbox->RIR & CAN_RI0R_IDE) {
 80132e6: 687b         	ldr	r3, [r7, #0x4]
 80132e8: 681b         	ldr	r3, [r3]
 80132ea: f003 0304    	and	r3, r3, #0x4
 80132ee: 2b00         	cmp	r3, #0x0
 80132f0: d00c         	beq	0x801330c <can_stm32_rx_fifo_pop+0x3a> @ imm = #0x18
; 		frame->id = mbox->RIR >> CAN_RI0R_EXID_Pos;
 80132f2: 687b         	ldr	r3, [r7, #0x4]
 80132f4: 681b         	ldr	r3, [r3]
 80132f6: 08da         	lsrs	r2, r3, #0x3
 80132f8: 683b         	ldr	r3, [r7]
 80132fa: 601a         	str	r2, [r3]
; 		frame->flags |= CAN_FRAME_IDE;
 80132fc: 683b         	ldr	r3, [r7]
 80132fe: 795b         	ldrb	r3, [r3, #0x5]
 8013300: f043 0301    	orr	r3, r3, #0x1
 8013304: b2da         	uxtb	r2, r3
 8013306: 683b         	ldr	r3, [r7]
 8013308: 715a         	strb	r2, [r3, #0x5]
 801330a: e004         	b	0x8013316 <can_stm32_rx_fifo_pop+0x44> @ imm = #0x8
; 		frame->id = mbox->RIR >> CAN_RI0R_STID_Pos;
 801330c: 687b         	ldr	r3, [r7, #0x4]
 801330e: 681b         	ldr	r3, [r3]
 8013310: 0d5a         	lsrs	r2, r3, #0x15
 8013312: 683b         	ldr	r3, [r7]
 8013314: 601a         	str	r2, [r3]
; 	if ((mbox->RIR & CAN_RI0R_RTR) != 0) {
 8013316: 687b         	ldr	r3, [r7, #0x4]
 8013318: 681b         	ldr	r3, [r3]
 801331a: f003 0302    	and	r3, r3, #0x2
 801331e: 2b00         	cmp	r3, #0x0
 8013320: d007         	beq	0x8013332 <can_stm32_rx_fifo_pop+0x60> @ imm = #0xe
; 		frame->flags |= CAN_FRAME_RTR;
 8013322: 683b         	ldr	r3, [r7]
 8013324: 795b         	ldrb	r3, [r3, #0x5]
 8013326: f043 0302    	orr	r3, r3, #0x2
 801332a: b2da         	uxtb	r2, r3
 801332c: 683b         	ldr	r3, [r7]
 801332e: 715a         	strb	r2, [r3, #0x5]
 8013330: e007         	b	0x8013342 <can_stm32_rx_fifo_pop+0x70> @ imm = #0xe
; 		frame->data_32[0] = mbox->RDLR;
 8013332: 687b         	ldr	r3, [r7, #0x4]
 8013334: 689a         	ldr	r2, [r3, #0x8]
 8013336: 683b         	ldr	r3, [r7]
 8013338: 609a         	str	r2, [r3, #0x8]
; 		frame->data_32[1] = mbox->RDHR;
 801333a: 687b         	ldr	r3, [r7, #0x4]
 801333c: 68da         	ldr	r2, [r3, #0xc]
 801333e: 683b         	ldr	r3, [r7]
 8013340: 60da         	str	r2, [r3, #0xc]
; 	frame->dlc = mbox->RDTR & (CAN_RDT0R_DLC >> CAN_RDT0R_DLC_Pos);
 8013342: 687b         	ldr	r3, [r7, #0x4]
 8013344: 685b         	ldr	r3, [r3, #0x4]
 8013346: b2db         	uxtb	r3, r3
 8013348: f003 030f    	and	r3, r3, #0xf
 801334c: b2da         	uxtb	r2, r3
 801334e: 683b         	ldr	r3, [r7]
 8013350: 711a         	strb	r2, [r3, #0x4]
; }
 8013352: bf00         	nop
 8013354: 3708         	adds	r7, #0x8
 8013356: 46bd         	mov	sp, r7
 8013358: bd80         	pop	{r7, pc}

0801335a <can_stm32_get_state>:
; {
 801335a: b480         	push	{r7}
 801335c: b089         	sub	sp, #0x24
 801335e: af00         	add	r7, sp, #0x0
 8013360: 60f8         	str	r0, [r7, #0xc]
 8013362: 60b9         	str	r1, [r7, #0x8]
 8013364: 607a         	str	r2, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8013366: 68fb         	ldr	r3, [r7, #0xc]
 8013368: 685b         	ldr	r3, [r3, #0x4]
 801336a: 61fb         	str	r3, [r7, #0x1c]
; 	struct can_stm32_data *data = dev->data;
 801336c: 68fb         	ldr	r3, [r7, #0xc]
 801336e: 691b         	ldr	r3, [r3, #0x10]
 8013370: 61bb         	str	r3, [r7, #0x18]
; 	CAN_TypeDef *can = cfg->can;
 8013372: 69fb         	ldr	r3, [r7, #0x1c]
 8013374: 695b         	ldr	r3, [r3, #0x14]
 8013376: 617b         	str	r3, [r7, #0x14]
; 	if (state != NULL) {
 8013378: 68bb         	ldr	r3, [r7, #0x8]
 801337a: 2b00         	cmp	r3, #0x0
 801337c: d02b         	beq	0x80133d6 <can_stm32_get_state+0x7c> @ imm = #0x56
; 		if (!data->common.started) {
 801337e: 69bb         	ldr	r3, [r7, #0x18]
 8013380: 791b         	ldrb	r3, [r3, #0x4]
 8013382: f083 0301    	eor	r3, r3, #0x1
 8013386: b2db         	uxtb	r3, r3
 8013388: 2b00         	cmp	r3, #0x0
 801338a: d003         	beq	0x8013394 <can_stm32_get_state+0x3a> @ imm = #0x6
; 			*state = CAN_STATE_STOPPED;
 801338c: 68bb         	ldr	r3, [r7, #0x8]
 801338e: 2204         	movs	r2, #0x4
 8013390: 701a         	strb	r2, [r3]
 8013392: e020         	b	0x80133d6 <can_stm32_get_state+0x7c> @ imm = #0x40
; 		} else if (can->ESR & CAN_ESR_BOFF) {
 8013394: 697b         	ldr	r3, [r7, #0x14]
 8013396: 699b         	ldr	r3, [r3, #0x18]
 8013398: f003 0304    	and	r3, r3, #0x4
 801339c: 2b00         	cmp	r3, #0x0
 801339e: d003         	beq	0x80133a8 <can_stm32_get_state+0x4e> @ imm = #0x6
; 			*state = CAN_STATE_BUS_OFF;
 80133a0: 68bb         	ldr	r3, [r7, #0x8]
 80133a2: 2203         	movs	r2, #0x3
 80133a4: 701a         	strb	r2, [r3]
 80133a6: e016         	b	0x80133d6 <can_stm32_get_state+0x7c> @ imm = #0x2c
; 		} else if (can->ESR & CAN_ESR_EPVF) {
 80133a8: 697b         	ldr	r3, [r7, #0x14]
 80133aa: 699b         	ldr	r3, [r3, #0x18]
 80133ac: f003 0302    	and	r3, r3, #0x2
 80133b0: 2b00         	cmp	r3, #0x0
 80133b2: d003         	beq	0x80133bc <can_stm32_get_state+0x62> @ imm = #0x6
; 			*state = CAN_STATE_ERROR_PASSIVE;
 80133b4: 68bb         	ldr	r3, [r7, #0x8]
 80133b6: 2202         	movs	r2, #0x2
 80133b8: 701a         	strb	r2, [r3]
 80133ba: e00c         	b	0x80133d6 <can_stm32_get_state+0x7c> @ imm = #0x18
; 		} else if (can->ESR & CAN_ESR_EWGF) {
 80133bc: 697b         	ldr	r3, [r7, #0x14]
 80133be: 699b         	ldr	r3, [r3, #0x18]
 80133c0: f003 0301    	and	r3, r3, #0x1
 80133c4: 2b00         	cmp	r3, #0x0
 80133c6: d003         	beq	0x80133d0 <can_stm32_get_state+0x76> @ imm = #0x6
; 			*state = CAN_STATE_ERROR_WARNING;
 80133c8: 68bb         	ldr	r3, [r7, #0x8]
 80133ca: 2201         	movs	r2, #0x1
 80133cc: 701a         	strb	r2, [r3]
 80133ce: e002         	b	0x80133d6 <can_stm32_get_state+0x7c> @ imm = #0x4
; 			*state = CAN_STATE_ERROR_ACTIVE;
 80133d0: 68bb         	ldr	r3, [r7, #0x8]
 80133d2: 2200         	movs	r2, #0x0
 80133d4: 701a         	strb	r2, [r3]
; 	if (err_cnt != NULL) {
 80133d6: 687b         	ldr	r3, [r7, #0x4]
 80133d8: 2b00         	cmp	r3, #0x0
 80133da: d00b         	beq	0x80133f4 <can_stm32_get_state+0x9a> @ imm = #0x16
; 			((can->ESR & CAN_ESR_TEC) >> CAN_ESR_TEC_Pos);
 80133dc: 697b         	ldr	r3, [r7, #0x14]
 80133de: 699b         	ldr	r3, [r3, #0x18]
 80133e0: 0c1b         	lsrs	r3, r3, #0x10
; 		err_cnt->tx_err_cnt =
 80133e2: b2da         	uxtb	r2, r3
 80133e4: 687b         	ldr	r3, [r7, #0x4]
 80133e6: 701a         	strb	r2, [r3]
; 			((can->ESR & CAN_ESR_REC) >> CAN_ESR_REC_Pos);
 80133e8: 697b         	ldr	r3, [r7, #0x14]
 80133ea: 699b         	ldr	r3, [r3, #0x18]
 80133ec: 0e1b         	lsrs	r3, r3, #0x18
; 		err_cnt->rx_err_cnt =
 80133ee: b2da         	uxtb	r2, r3
 80133f0: 687b         	ldr	r3, [r7, #0x4]
 80133f2: 705a         	strb	r2, [r3, #0x1]
; 	return 0;
 80133f4: 2300         	movs	r3, #0x0
; }
 80133f6: 4618         	mov	r0, r3
 80133f8: 3724         	adds	r7, #0x24
 80133fa: 46bd         	mov	sp, r7
 80133fc: bc80         	pop	{r7}
 80133fe: 4770         	bx	lr

08013400 <can_stm32_bus_state_change_isr>:
; {
 8013400: b590         	push	{r4, r7, lr}
 8013402: b089         	sub	sp, #0x24
 8013404: af00         	add	r7, sp, #0x0
 8013406: 6078         	str	r0, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 8013408: 687b         	ldr	r3, [r7, #0x4]
 801340a: 691b         	ldr	r3, [r3, #0x10]
 801340c: 61fb         	str	r3, [r7, #0x1c]
; 	const can_state_change_callback_t cb = data->common.state_change_cb;
 801340e: 69fb         	ldr	r3, [r7, #0x1c]
 8013410: 689b         	ldr	r3, [r3, #0x8]
 8013412: 61bb         	str	r3, [r7, #0x18]
; 	void *state_change_cb_data = data->common.state_change_cb_user_data;
 8013414: 69fb         	ldr	r3, [r7, #0x1c]
 8013416: 68db         	ldr	r3, [r3, #0xc]
 8013418: 617b         	str	r3, [r7, #0x14]
; 	(void)can_stm32_get_state(dev, &state, &err_cnt);
 801341a: f107 0210    	add.w	r2, r7, #0x10
 801341e: f107 030f    	add.w	r3, r7, #0xf
 8013422: 4619         	mov	r1, r3
 8013424: 6878         	ldr	r0, [r7, #0x4]
 8013426: f7ff ff98    	bl	0x801335a <can_stm32_get_state> @ imm = #-0xd0
; 	if (state != data->state) {
 801342a: 69fb         	ldr	r3, [r7, #0x1c]
 801342c: f893 20f4    	ldrb.w	r2, [r3, #0xf4]
 8013430: 7bfb         	ldrb	r3, [r7, #0xf]
 8013432: 429a         	cmp	r2, r3
 8013434: d00c         	beq	0x8013450 <can_stm32_bus_state_change_isr+0x50> @ imm = #0x18
; 		data->state = state;
 8013436: 7bfa         	ldrb	r2, [r7, #0xf]
 8013438: 69fb         	ldr	r3, [r7, #0x1c]
 801343a: f883 20f4    	strb.w	r2, [r3, #0xf4]
; 		if (cb != NULL) {
 801343e: 69bb         	ldr	r3, [r7, #0x18]
 8013440: 2b00         	cmp	r3, #0x0
 8013442: d005         	beq	0x8013450 <can_stm32_bus_state_change_isr+0x50> @ imm = #0xa
; 			cb(dev, state, err_cnt, state_change_cb_data);
 8013444: 7bf9         	ldrb	r1, [r7, #0xf]
 8013446: 69bc         	ldr	r4, [r7, #0x18]
 8013448: 697b         	ldr	r3, [r7, #0x14]
 801344a: 693a         	ldr	r2, [r7, #0x10]
 801344c: 6878         	ldr	r0, [r7, #0x4]
 801344e: 47a0         	blx	r4
; }
 8013450: bf00         	nop
 8013452: 3724         	adds	r7, #0x24
 8013454: 46bd         	mov	sp, r7
 8013456: bd90         	pop	{r4, r7, pc}

08013458 <can_stm32_tx_isr_handler>:
; {
 8013458: b580         	push	{r7, lr}
 801345a: b088         	sub	sp, #0x20
 801345c: af00         	add	r7, sp, #0x0
 801345e: 6078         	str	r0, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 8013460: 687b         	ldr	r3, [r7, #0x4]
 8013462: 691b         	ldr	r3, [r3, #0x10]
 8013464: 61fb         	str	r3, [r7, #0x1c]
; 	const struct can_stm32_config *cfg = dev->config;
 8013466: 687b         	ldr	r3, [r7, #0x4]
 8013468: 685b         	ldr	r3, [r3, #0x4]
 801346a: 61bb         	str	r3, [r7, #0x18]
; 	CAN_TypeDef *can = cfg->can;
 801346c: 69bb         	ldr	r3, [r7, #0x18]
 801346e: 695b         	ldr	r3, [r3, #0x14]
 8013470: 617b         	str	r3, [r7, #0x14]
; 	bus_off = can->ESR & CAN_ESR_BOFF;
 8013472: 697b         	ldr	r3, [r7, #0x14]
 8013474: 699b         	ldr	r3, [r3, #0x18]
 8013476: f003 0304    	and	r3, r3, #0x4
 801347a: 613b         	str	r3, [r7, #0x10]
; 	if ((can->TSR & CAN_TSR_RQCP0) | bus_off) {
 801347c: 697b         	ldr	r3, [r7, #0x14]
 801347e: 689b         	ldr	r3, [r3, #0x8]
 8013480: f003 0201    	and	r2, r3, #0x1
 8013484: 693b         	ldr	r3, [r7, #0x10]
 8013486: 4313         	orrs	r3, r2
 8013488: 2b00         	cmp	r3, #0x0
 801348a: d02f         	beq	0x80134ec <can_stm32_tx_isr_handler+0x94> @ imm = #0x5e
; 		status = can->TSR & CAN_TSR_TXOK0 ? 0  :
 801348c: 697b         	ldr	r3, [r7, #0x14]
 801348e: 689b         	ldr	r3, [r3, #0x8]
 8013490: f003 0302    	and	r3, r3, #0x2
 8013494: 2b00         	cmp	r3, #0x0
 8013496: d11a         	bne	0x80134ce <can_stm32_tx_isr_handler+0x76> @ imm = #0x34
; 			 can->TSR & CAN_TSR_TERR0 ? -EIO :
 8013498: 697b         	ldr	r3, [r7, #0x14]
 801349a: 689b         	ldr	r3, [r3, #0x8]
 801349c: f003 0308    	and	r3, r3, #0x8
 80134a0: 2b00         	cmp	r3, #0x0
 80134a2: d111         	bne	0x80134c8 <can_stm32_tx_isr_handler+0x70> @ imm = #0x22
; 			 can->TSR & CAN_TSR_ALST0 ? -EBUSY :
 80134a4: 697b         	ldr	r3, [r7, #0x14]
 80134a6: 689b         	ldr	r3, [r3, #0x8]
 80134a8: f003 0304    	and	r3, r3, #0x4
 80134ac: 2b00         	cmp	r3, #0x0
 80134ae: d108         	bne	0x80134c2 <can_stm32_tx_isr_handler+0x6a> @ imm = #0x10
; 					  bus_off ? -ENETUNREACH :
 80134b0: 693b         	ldr	r3, [r7, #0x10]
 80134b2: 2b00         	cmp	r3, #0x0
 80134b4: d002         	beq	0x80134bc <can_stm32_tx_isr_handler+0x64> @ imm = #0x4
 80134b6: f06f 0371    	mvn	r3, #0x71
 80134ba: e009         	b	0x80134d0 <can_stm32_tx_isr_handler+0x78> @ imm = #0x12
 80134bc: f06f 0304    	mvn	r3, #0x4
 80134c0: e006         	b	0x80134d0 <can_stm32_tx_isr_handler+0x78> @ imm = #0xc
; 			 can->TSR & CAN_TSR_ALST0 ? -EBUSY :
 80134c2: f06f 030f    	mvn	r3, #0xf
 80134c6: e003         	b	0x80134d0 <can_stm32_tx_isr_handler+0x78> @ imm = #0x6
; 			 can->TSR & CAN_TSR_TERR0 ? -EIO :
 80134c8: f06f 0304    	mvn	r3, #0x4
 80134cc: e000         	b	0x80134d0 <can_stm32_tx_isr_handler+0x78> @ imm = #0x0
; 		status = can->TSR & CAN_TSR_TXOK0 ? 0  :
 80134ce: 2300         	movs	r3, #0x0
 80134d0: 60fb         	str	r3, [r7, #0xc]
; 		can->TSR |= CAN_TSR_RQCP0;
 80134d2: 697b         	ldr	r3, [r7, #0x14]
 80134d4: 689b         	ldr	r3, [r3, #0x8]
 80134d6: f043 0201    	orr	r2, r3, #0x1
 80134da: 697b         	ldr	r3, [r7, #0x14]
 80134dc: 609a         	str	r2, [r3, #0x8]
; 		can_stm32_signal_tx_complete(dev, &data->mb0, status);
 80134de: 69fb         	ldr	r3, [r7, #0x1c]
 80134e0: 3334         	adds	r3, #0x34
 80134e2: 68fa         	ldr	r2, [r7, #0xc]
 80134e4: 4619         	mov	r1, r3
 80134e6: 6878         	ldr	r0, [r7, #0x4]
 80134e8: f7ff feda    	bl	0x80132a0 <can_stm32_signal_tx_complete> @ imm = #-0x24c
; 	if ((can->TSR & CAN_TSR_RQCP1) | bus_off) {
 80134ec: 697b         	ldr	r3, [r7, #0x14]
 80134ee: 689b         	ldr	r3, [r3, #0x8]
 80134f0: f403 7280    	and	r2, r3, #0x100
 80134f4: 693b         	ldr	r3, [r7, #0x10]
 80134f6: 4313         	orrs	r3, r2
 80134f8: 2b00         	cmp	r3, #0x0
 80134fa: d02f         	beq	0x801355c <can_stm32_tx_isr_handler+0x104> @ imm = #0x5e
; 		status = can->TSR & CAN_TSR_TXOK1 ? 0  :
 80134fc: 697b         	ldr	r3, [r7, #0x14]
 80134fe: 689b         	ldr	r3, [r3, #0x8]
 8013500: f403 7300    	and	r3, r3, #0x200
 8013504: 2b00         	cmp	r3, #0x0
 8013506: d11a         	bne	0x801353e <can_stm32_tx_isr_handler+0xe6> @ imm = #0x34
; 			 can->TSR & CAN_TSR_TERR1 ? -EIO :
 8013508: 697b         	ldr	r3, [r7, #0x14]
 801350a: 689b         	ldr	r3, [r3, #0x8]
 801350c: f403 6300    	and	r3, r3, #0x800
 8013510: 2b00         	cmp	r3, #0x0
 8013512: d111         	bne	0x8013538 <can_stm32_tx_isr_handler+0xe0> @ imm = #0x22
; 			 can->TSR & CAN_TSR_ALST1 ? -EBUSY :
 8013514: 697b         	ldr	r3, [r7, #0x14]
 8013516: 689b         	ldr	r3, [r3, #0x8]
 8013518: f403 6380    	and	r3, r3, #0x400
 801351c: 2b00         	cmp	r3, #0x0
 801351e: d108         	bne	0x8013532 <can_stm32_tx_isr_handler+0xda> @ imm = #0x10
; 			 bus_off                  ? -ENETUNREACH :
 8013520: 693b         	ldr	r3, [r7, #0x10]
 8013522: 2b00         	cmp	r3, #0x0
 8013524: d002         	beq	0x801352c <can_stm32_tx_isr_handler+0xd4> @ imm = #0x4
 8013526: f06f 0371    	mvn	r3, #0x71
 801352a: e009         	b	0x8013540 <can_stm32_tx_isr_handler+0xe8> @ imm = #0x12
 801352c: f06f 0304    	mvn	r3, #0x4
 8013530: e006         	b	0x8013540 <can_stm32_tx_isr_handler+0xe8> @ imm = #0xc
; 			 can->TSR & CAN_TSR_ALST1 ? -EBUSY :
 8013532: f06f 030f    	mvn	r3, #0xf
 8013536: e003         	b	0x8013540 <can_stm32_tx_isr_handler+0xe8> @ imm = #0x6
; 			 can->TSR & CAN_TSR_TERR1 ? -EIO :
 8013538: f06f 0304    	mvn	r3, #0x4
 801353c: e000         	b	0x8013540 <can_stm32_tx_isr_handler+0xe8> @ imm = #0x0
; 		status = can->TSR & CAN_TSR_TXOK1 ? 0  :
 801353e: 2300         	movs	r3, #0x0
 8013540: 60fb         	str	r3, [r7, #0xc]
; 		can->TSR |= CAN_TSR_RQCP1;
 8013542: 697b         	ldr	r3, [r7, #0x14]
 8013544: 689b         	ldr	r3, [r3, #0x8]
 8013546: f443 7280    	orr	r2, r3, #0x100
 801354a: 697b         	ldr	r3, [r7, #0x14]
 801354c: 609a         	str	r2, [r3, #0x8]
; 		can_stm32_signal_tx_complete(dev, &data->mb1, status);
 801354e: 69fb         	ldr	r3, [r7, #0x1c]
 8013550: 333c         	adds	r3, #0x3c
 8013552: 68fa         	ldr	r2, [r7, #0xc]
 8013554: 4619         	mov	r1, r3
 8013556: 6878         	ldr	r0, [r7, #0x4]
 8013558: f7ff fea2    	bl	0x80132a0 <can_stm32_signal_tx_complete> @ imm = #-0x2bc
; 	if ((can->TSR & CAN_TSR_RQCP2) | bus_off) {
 801355c: 697b         	ldr	r3, [r7, #0x14]
 801355e: 689b         	ldr	r3, [r3, #0x8]
 8013560: f403 3280    	and	r2, r3, #0x10000
 8013564: 693b         	ldr	r3, [r7, #0x10]
 8013566: 4313         	orrs	r3, r2
 8013568: 2b00         	cmp	r3, #0x0
 801356a: d02f         	beq	0x80135cc <can_stm32_tx_isr_handler+0x174> @ imm = #0x5e
; 		status = can->TSR & CAN_TSR_TXOK2 ? 0  :
 801356c: 697b         	ldr	r3, [r7, #0x14]
 801356e: 689b         	ldr	r3, [r3, #0x8]
 8013570: f403 3300    	and	r3, r3, #0x20000
 8013574: 2b00         	cmp	r3, #0x0
 8013576: d11a         	bne	0x80135ae <can_stm32_tx_isr_handler+0x156> @ imm = #0x34
; 			 can->TSR & CAN_TSR_TERR2 ? -EIO :
 8013578: 697b         	ldr	r3, [r7, #0x14]
 801357a: 689b         	ldr	r3, [r3, #0x8]
 801357c: f403 2300    	and	r3, r3, #0x80000
 8013580: 2b00         	cmp	r3, #0x0
 8013582: d111         	bne	0x80135a8 <can_stm32_tx_isr_handler+0x150> @ imm = #0x22
; 			 can->TSR & CAN_TSR_ALST2 ? -EBUSY :
 8013584: 697b         	ldr	r3, [r7, #0x14]
 8013586: 689b         	ldr	r3, [r3, #0x8]
 8013588: f403 2380    	and	r3, r3, #0x40000
 801358c: 2b00         	cmp	r3, #0x0
 801358e: d108         	bne	0x80135a2 <can_stm32_tx_isr_handler+0x14a> @ imm = #0x10
; 			 bus_off                  ? -ENETUNREACH :
 8013590: 693b         	ldr	r3, [r7, #0x10]
 8013592: 2b00         	cmp	r3, #0x0
 8013594: d002         	beq	0x801359c <can_stm32_tx_isr_handler+0x144> @ imm = #0x4
 8013596: f06f 0371    	mvn	r3, #0x71
 801359a: e009         	b	0x80135b0 <can_stm32_tx_isr_handler+0x158> @ imm = #0x12
 801359c: f06f 0304    	mvn	r3, #0x4
 80135a0: e006         	b	0x80135b0 <can_stm32_tx_isr_handler+0x158> @ imm = #0xc
; 			 can->TSR & CAN_TSR_ALST2 ? -EBUSY :
 80135a2: f06f 030f    	mvn	r3, #0xf
 80135a6: e003         	b	0x80135b0 <can_stm32_tx_isr_handler+0x158> @ imm = #0x6
; 			 can->TSR & CAN_TSR_TERR2 ? -EIO :
 80135a8: f06f 0304    	mvn	r3, #0x4
 80135ac: e000         	b	0x80135b0 <can_stm32_tx_isr_handler+0x158> @ imm = #0x0
; 		status = can->TSR & CAN_TSR_TXOK2 ? 0  :
 80135ae: 2300         	movs	r3, #0x0
 80135b0: 60fb         	str	r3, [r7, #0xc]
; 		can->TSR |= CAN_TSR_RQCP2;
 80135b2: 697b         	ldr	r3, [r7, #0x14]
 80135b4: 689b         	ldr	r3, [r3, #0x8]
 80135b6: f443 3280    	orr	r2, r3, #0x10000
 80135ba: 697b         	ldr	r3, [r7, #0x14]
 80135bc: 609a         	str	r2, [r3, #0x8]
; 		can_stm32_signal_tx_complete(dev, &data->mb2, status);
 80135be: 69fb         	ldr	r3, [r7, #0x1c]
 80135c0: 3344         	adds	r3, #0x44
 80135c2: 68fa         	ldr	r2, [r7, #0xc]
 80135c4: 4619         	mov	r1, r3
 80135c6: 6878         	ldr	r0, [r7, #0x4]
 80135c8: f7ff fe6a    	bl	0x80132a0 <can_stm32_signal_tx_complete> @ imm = #-0x32c
; 	if (can->TSR & CAN_TSR_TME) {
 80135cc: 697b         	ldr	r3, [r7, #0x14]
 80135ce: 689b         	ldr	r3, [r3, #0x8]
 80135d0: f003 53e0    	and	r3, r3, #0x1c000000
 80135d4: 2b00         	cmp	r3, #0x0
 80135d6: d004         	beq	0x80135e2 <can_stm32_tx_isr_handler+0x18a> @ imm = #0x8
; 		k_sem_give(&data->tx_int_sem);
 80135d8: 69fb         	ldr	r3, [r7, #0x1c]
 80135da: 3324         	adds	r3, #0x24
 80135dc: 4618         	mov	r0, r3
 80135de: f7ff fd9a    	bl	0x8013116 <k_sem_give>  @ imm = #-0x4cc
; }
 80135e2: bf00         	nop
 80135e4: 3720         	adds	r7, #0x20
 80135e6: 46bd         	mov	sp, r7
 80135e8: bd80         	pop	{r7, pc}

080135ea <can_stm32_rx_isr>:
; {
 80135ea: b580         	push	{r7, lr}
 80135ec: b082         	sub	sp, #0x8
 80135ee: af00         	add	r7, sp, #0x0
 80135f0: 6078         	str	r0, [r7, #0x4]
; 	can_stm32_rx_isr_handler(dev);
 80135f2: 6878         	ldr	r0, [r7, #0x4]
 80135f4: f7f0 fefa    	bl	0x80043ec <can_stm32_rx_isr_handler> @ imm = #-0xf20c
; }
 80135f8: bf00         	nop
 80135fa: 3708         	adds	r7, #0x8
 80135fc: 46bd         	mov	sp, r7
 80135fe: bd80         	pop	{r7, pc}

08013600 <can_stm32_tx_isr>:
; {
 8013600: b580         	push	{r7, lr}
 8013602: b082         	sub	sp, #0x8
 8013604: af00         	add	r7, sp, #0x0
 8013606: 6078         	str	r0, [r7, #0x4]
; 	can_stm32_tx_isr_handler(dev);
 8013608: 6878         	ldr	r0, [r7, #0x4]
 801360a: f7ff ff25    	bl	0x8013458 <can_stm32_tx_isr_handler> @ imm = #-0x1b6
; }
 801360e: bf00         	nop
 8013610: 3708         	adds	r7, #0x8
 8013612: 46bd         	mov	sp, r7
 8013614: bd80         	pop	{r7, pc}

08013616 <can_stm32_state_change_isr>:
; {
 8013616: b580         	push	{r7, lr}
 8013618: b084         	sub	sp, #0x10
 801361a: af00         	add	r7, sp, #0x0
 801361c: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 801361e: 687b         	ldr	r3, [r7, #0x4]
 8013620: 685b         	ldr	r3, [r3, #0x4]
 8013622: 60fb         	str	r3, [r7, #0xc]
; 	CAN_TypeDef *can = cfg->can;
 8013624: 68fb         	ldr	r3, [r7, #0xc]
 8013626: 695b         	ldr	r3, [r3, #0x14]
 8013628: 60bb         	str	r3, [r7, #0x8]
; 	if (can->MSR & CAN_MSR_ERRI) {
 801362a: 68bb         	ldr	r3, [r7, #0x8]
 801362c: 685b         	ldr	r3, [r3, #0x4]
 801362e: f003 0304    	and	r3, r3, #0x4
 8013632: 2b00         	cmp	r3, #0x0
 8013634: d00b         	beq	0x801364e <can_stm32_state_change_isr+0x38> @ imm = #0x16
; 		can_stm32_tx_isr_handler(dev);
 8013636: 6878         	ldr	r0, [r7, #0x4]
 8013638: f7ff ff0e    	bl	0x8013458 <can_stm32_tx_isr_handler> @ imm = #-0x1e4
; 		can_stm32_bus_state_change_isr(dev);
 801363c: 6878         	ldr	r0, [r7, #0x4]
 801363e: f7ff fedf    	bl	0x8013400 <can_stm32_bus_state_change_isr> @ imm = #-0x242
; 		can->MSR |= CAN_MSR_ERRI;
 8013642: 68bb         	ldr	r3, [r7, #0x8]
 8013644: 685b         	ldr	r3, [r3, #0x4]
 8013646: f043 0204    	orr	r2, r3, #0x4
 801364a: 68bb         	ldr	r3, [r7, #0x8]
 801364c: 605a         	str	r2, [r3, #0x4]
; }
 801364e: bf00         	nop
 8013650: 3710         	adds	r7, #0x10
 8013652: 46bd         	mov	sp, r7
 8013654: bd80         	pop	{r7, pc}

08013656 <can_stm32_get_capabilities>:
; {
 8013656: b480         	push	{r7}
 8013658: b083         	sub	sp, #0xc
 801365a: af00         	add	r7, sp, #0x0
 801365c: 6078         	str	r0, [r7, #0x4]
 801365e: 6039         	str	r1, [r7]
; 	*cap = CAN_MODE_NORMAL | CAN_MODE_LOOPBACK | CAN_MODE_LISTENONLY | CAN_MODE_ONE_SHOT;
 8013660: 683b         	ldr	r3, [r7]
 8013662: 220b         	movs	r2, #0xb
 8013664: 601a         	str	r2, [r3]
; 	return 0;
 8013666: 2300         	movs	r3, #0x0
; }
 8013668: 4618         	mov	r0, r3
 801366a: 370c         	adds	r7, #0xc
 801366c: 46bd         	mov	sp, r7
 801366e: bc80         	pop	{r7}
 8013670: 4770         	bx	lr

08013672 <can_stm32_get_max_filters>:
; {
 8013672: b480         	push	{r7}
 8013674: b083         	sub	sp, #0xc
 8013676: af00         	add	r7, sp, #0x0
 8013678: 6078         	str	r0, [r7, #0x4]
 801367a: 460b         	mov	r3, r1
 801367c: 70fb         	strb	r3, [r7, #0x3]
; 	if (ide) {
 801367e: 78fb         	ldrb	r3, [r7, #0x3]
 8013680: 2b00         	cmp	r3, #0x0
 8013682: d001         	beq	0x8013688 <can_stm32_get_max_filters+0x16> @ imm = #0x2
; 		return CONFIG_CAN_MAX_EXT_ID_FILTER;
 8013684: 2307         	movs	r3, #0x7
 8013686: e000         	b	0x801368a <can_stm32_get_max_filters+0x18> @ imm = #0x0
; 		return CONFIG_CAN_MAX_STD_ID_FILTER;
 8013688: 230e         	movs	r3, #0xe
; }
 801368a: 4618         	mov	r0, r3
 801368c: 370c         	adds	r7, #0xc
 801368e: 46bd         	mov	sp, r7
 8013690: bc80         	pop	{r7}
 8013692: 4770         	bx	lr

08013694 <can_stm32_set_state_change_callback>:
; {
 8013694: b480         	push	{r7}
 8013696: b089         	sub	sp, #0x24
 8013698: af00         	add	r7, sp, #0x0
 801369a: 60f8         	str	r0, [r7, #0xc]
 801369c: 60b9         	str	r1, [r7, #0x8]
 801369e: 607a         	str	r2, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 80136a0: 68fb         	ldr	r3, [r7, #0xc]
 80136a2: 691b         	ldr	r3, [r3, #0x10]
 80136a4: 61fb         	str	r3, [r7, #0x1c]
; 	const struct can_stm32_config *cfg = dev->config;
 80136a6: 68fb         	ldr	r3, [r7, #0xc]
 80136a8: 685b         	ldr	r3, [r3, #0x4]
 80136aa: 61bb         	str	r3, [r7, #0x18]
; 	CAN_TypeDef *can = cfg->can;
 80136ac: 69bb         	ldr	r3, [r7, #0x18]
 80136ae: 695b         	ldr	r3, [r3, #0x14]
 80136b0: 617b         	str	r3, [r7, #0x14]
; 	data->common.state_change_cb = cb;
 80136b2: 69fb         	ldr	r3, [r7, #0x1c]
 80136b4: 68ba         	ldr	r2, [r7, #0x8]
 80136b6: 609a         	str	r2, [r3, #0x8]
; 	data->common.state_change_cb_user_data = user_data;
 80136b8: 69fb         	ldr	r3, [r7, #0x1c]
 80136ba: 687a         	ldr	r2, [r7, #0x4]
 80136bc: 60da         	str	r2, [r3, #0xc]
; 	if (cb == NULL) {
 80136be: 68bb         	ldr	r3, [r7, #0x8]
 80136c0: 2b00         	cmp	r3, #0x0
 80136c2: d106         	bne	0x80136d2 <can_stm32_set_state_change_callback+0x3e> @ imm = #0xc
; 		can->IER &= ~(CAN_IER_BOFIE | CAN_IER_EPVIE | CAN_IER_EWGIE);
 80136c4: 697b         	ldr	r3, [r7, #0x14]
 80136c6: 695b         	ldr	r3, [r3, #0x14]
 80136c8: f423 62e0    	bic	r2, r3, #0x700
 80136cc: 697b         	ldr	r3, [r7, #0x14]
 80136ce: 615a         	str	r2, [r3, #0x14]
; }
 80136d0: e005         	b	0x80136de <can_stm32_set_state_change_callback+0x4a> @ imm = #0xa
; 		can->IER |= CAN_IER_BOFIE | CAN_IER_EPVIE | CAN_IER_EWGIE;
 80136d2: 697b         	ldr	r3, [r7, #0x14]
 80136d4: 695b         	ldr	r3, [r3, #0x14]
 80136d6: f443 62e0    	orr	r2, r3, #0x700
 80136da: 697b         	ldr	r3, [r7, #0x14]
 80136dc: 615a         	str	r2, [r3, #0x14]
; }
 80136de: bf00         	nop
 80136e0: 3724         	adds	r7, #0x24
 80136e2: 46bd         	mov	sp, r7
 80136e4: bc80         	pop	{r7}
 80136e6: 4770         	bx	lr

080136e8 <can_stm32_set_filter_bank>:
; {
 80136e8: b480         	push	{r7}
 80136ea: b085         	sub	sp, #0x14
 80136ec: af00         	add	r7, sp, #0x0
 80136ee: 60f8         	str	r0, [r7, #0xc]
 80136f0: 60b9         	str	r1, [r7, #0x8]
 80136f2: 603b         	str	r3, [r7]
 80136f4: 4613         	mov	r3, r2
 80136f6: 71fb         	strb	r3, [r7, #0x7]
; 	if (ide) {
 80136f8: 79fb         	ldrb	r3, [r7, #0x7]
 80136fa: 2b00         	cmp	r3, #0x0
 80136fc: d006         	beq	0x801370c <can_stm32_set_filter_bank+0x24> @ imm = #0xc
; 		filter_reg->FR1 = id;
 80136fe: 68bb         	ldr	r3, [r7, #0x8]
 8013700: 683a         	ldr	r2, [r7]
 8013702: 601a         	str	r2, [r3]
; 		filter_reg->FR2 = mask;
 8013704: 68bb         	ldr	r3, [r7, #0x8]
 8013706: 69ba         	ldr	r2, [r7, #0x18]
 8013708: 605a         	str	r2, [r3, #0x4]
; }
 801370a: e012         	b	0x8013732 <can_stm32_set_filter_bank+0x4a> @ imm = #0x24
; 		if ((filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER) % 2 == 0) {
 801370c: 68fb         	ldr	r3, [r7, #0xc]
 801370e: 3b07         	subs	r3, #0x7
 8013710: f003 0301    	and	r3, r3, #0x1
 8013714: 2b00         	cmp	r3, #0x0
 8013716: d106         	bne	0x8013726 <can_stm32_set_filter_bank+0x3e> @ imm = #0xc
; 			filter_reg->FR1 = id | (mask << 16);
 8013718: 69bb         	ldr	r3, [r7, #0x18]
 801371a: 041a         	lsls	r2, r3, #0x10
 801371c: 683b         	ldr	r3, [r7]
 801371e: 431a         	orrs	r2, r3
 8013720: 68bb         	ldr	r3, [r7, #0x8]
 8013722: 601a         	str	r2, [r3]
; }
 8013724: e005         	b	0x8013732 <can_stm32_set_filter_bank+0x4a> @ imm = #0xa
; 			filter_reg->FR2 = id | (mask << 16);
 8013726: 69bb         	ldr	r3, [r7, #0x18]
 8013728: 041a         	lsls	r2, r3, #0x10
 801372a: 683b         	ldr	r3, [r7]
 801372c: 431a         	orrs	r2, r3
 801372e: 68bb         	ldr	r3, [r7, #0x8]
 8013730: 605a         	str	r2, [r3, #0x4]
; }
 8013732: bf00         	nop
 8013734: 3714         	adds	r7, #0x14
 8013736: 46bd         	mov	sp, r7
 8013738: bc80         	pop	{r7}
 801373a: 4770         	bx	lr

0801373c <can_stm32_filter_to_std_mask>:
; {
 801373c: b480         	push	{r7}
 801373e: b085         	sub	sp, #0x14
 8013740: af00         	add	r7, sp, #0x0
 8013742: 6078         	str	r0, [r7, #0x4]
; 	uint32_t rtr_mask = !IS_ENABLED(CONFIG_CAN_ACCEPT_RTR);
 8013744: 2301         	movs	r3, #0x1
 8013746: 60fb         	str	r3, [r7, #0xc]
; 	return  (filter->mask << CAN_STM32_FIRX_STD_ID_POS) |
 8013748: 687b         	ldr	r3, [r7, #0x4]
 801374a: 685b         	ldr	r3, [r3, #0x4]
 801374c: 015a         	lsls	r2, r3, #0x5
; 		(rtr_mask << CAN_STM32_FIRX_STD_RTR_POS) |
 801374e: 68fb         	ldr	r3, [r7, #0xc]
 8013750: 011b         	lsls	r3, r3, #0x4
; 	return  (filter->mask << CAN_STM32_FIRX_STD_ID_POS) |
 8013752: 4313         	orrs	r3, r2
; 		(rtr_mask << CAN_STM32_FIRX_STD_RTR_POS) |
 8013754: f043 0308    	orr	r3, r3, #0x8
; }
 8013758: 4618         	mov	r0, r3
 801375a: 3714         	adds	r7, #0x14
 801375c: 46bd         	mov	sp, r7
 801375e: bc80         	pop	{r7}
 8013760: 4770         	bx	lr

08013762 <can_stm32_filter_to_ext_mask>:
; {
 8013762: b480         	push	{r7}
 8013764: b085         	sub	sp, #0x14
 8013766: af00         	add	r7, sp, #0x0
 8013768: 6078         	str	r0, [r7, #0x4]
; 	uint32_t rtr_mask = !IS_ENABLED(CONFIG_CAN_ACCEPT_RTR);
 801376a: 2301         	movs	r3, #0x1
 801376c: 60fb         	str	r3, [r7, #0xc]
; 	return  (filter->mask << CAN_STM32_FIRX_EXT_EXT_ID_POS) |
 801376e: 687b         	ldr	r3, [r7, #0x4]
 8013770: 685b         	ldr	r3, [r3, #0x4]
 8013772: 00da         	lsls	r2, r3, #0x3
; 		(rtr_mask << CAN_STM32_FIRX_EXT_RTR_POS) |
 8013774: 68fb         	ldr	r3, [r7, #0xc]
 8013776: 005b         	lsls	r3, r3, #0x1
; 	return  (filter->mask << CAN_STM32_FIRX_EXT_EXT_ID_POS) |
 8013778: 4313         	orrs	r3, r2
; 		(rtr_mask << CAN_STM32_FIRX_EXT_RTR_POS) |
 801377a: f043 0304    	orr	r3, r3, #0x4
; }
 801377e: 4618         	mov	r0, r3
 8013780: 3714         	adds	r7, #0x14
 8013782: 46bd         	mov	sp, r7
 8013784: bc80         	pop	{r7}
 8013786: 4770         	bx	lr

08013788 <can_stm32_filter_to_std_id>:
; {
 8013788: b480         	push	{r7}
 801378a: b083         	sub	sp, #0xc
 801378c: af00         	add	r7, sp, #0x0
 801378e: 6078         	str	r0, [r7, #0x4]
; 	return  (filter->id  << CAN_STM32_FIRX_STD_ID_POS);
 8013790: 687b         	ldr	r3, [r7, #0x4]
 8013792: 681b         	ldr	r3, [r3]
 8013794: 015b         	lsls	r3, r3, #0x5
; }
 8013796: 4618         	mov	r0, r3
 8013798: 370c         	adds	r7, #0xc
 801379a: 46bd         	mov	sp, r7
 801379c: bc80         	pop	{r7}
 801379e: 4770         	bx	lr

080137a0 <can_stm32_filter_to_ext_id>:
; {
 80137a0: b480         	push	{r7}
 80137a2: b083         	sub	sp, #0xc
 80137a4: af00         	add	r7, sp, #0x0
 80137a6: 6078         	str	r0, [r7, #0x4]
; 	return  (filter->id << CAN_STM32_FIRX_EXT_EXT_ID_POS) |
 80137a8: 687b         	ldr	r3, [r7, #0x4]
 80137aa: 681b         	ldr	r3, [r3]
 80137ac: 00db         	lsls	r3, r3, #0x3
 80137ae: f043 0304    	orr	r3, r3, #0x4
; }
 80137b2: 4618         	mov	r0, r3
 80137b4: 370c         	adds	r7, #0xc
 80137b6: 46bd         	mov	sp, r7
 80137b8: bc80         	pop	{r7}
 80137ba: 4770         	bx	lr

080137bc <config_can_0_irq>:
; DT_INST_FOREACH_STATUS_OKAY(CAN_STM32_INST)
 80137bc: b580         	push	{r7, lr}
 80137be: b082         	sub	sp, #0x8
 80137c0: af00         	add	r7, sp, #0x0
 80137c2: 6078         	str	r0, [r7, #0x4]
 80137c4: 2200         	movs	r2, #0x0
 80137c6: 2100         	movs	r1, #0x0
 80137c8: 2014         	movs	r0, #0x14
 80137ca: f7ff f9a5    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0xcb6
 80137ce: 2014         	movs	r0, #0x14
 80137d0: f7ff f995    	bl	0x8012afe <arch_irq_enable> @ imm = #-0xcd6
 80137d4: 2200         	movs	r2, #0x0
 80137d6: 2100         	movs	r1, #0x0
 80137d8: 2013         	movs	r0, #0x13
 80137da: f7ff f99d    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0xcc6
 80137de: 2013         	movs	r0, #0x13
 80137e0: f7ff f98d    	bl	0x8012afe <arch_irq_enable> @ imm = #-0xce6
 80137e4: 2200         	movs	r2, #0x0
 80137e6: 2100         	movs	r1, #0x0
 80137e8: 2016         	movs	r0, #0x16
 80137ea: f7ff f995    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0xcd6
 80137ee: 2016         	movs	r0, #0x16
 80137f0: f7ff f985    	bl	0x8012afe <arch_irq_enable> @ imm = #-0xcf6
 80137f4: 687b         	ldr	r3, [r7, #0x4]
 80137f6: 695b         	ldr	r3, [r3, #0x14]
 80137f8: f443 4304    	orr	r3, r3, #0x8400
 80137fc: f043 0313    	orr	r3, r3, #0x13
 8013800: 687a         	ldr	r2, [r7, #0x4]
 8013802: 6153         	str	r3, [r2, #0x14]
 8013804: 3708         	adds	r7, #0x8
 8013806: 46bd         	mov	sp, r7
 8013808: bd80         	pop	{r7, pc}

0801380a <config_can_1_irq>:
 801380a: b580         	push	{r7, lr}
 801380c: b082         	sub	sp, #0x8
 801380e: af00         	add	r7, sp, #0x0
 8013810: 6078         	str	r0, [r7, #0x4]
 8013812: 2200         	movs	r2, #0x0
 8013814: 2100         	movs	r1, #0x0
 8013816: 2040         	movs	r0, #0x40
 8013818: f7ff f97e    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0xd04
 801381c: 2040         	movs	r0, #0x40
 801381e: f7ff f96e    	bl	0x8012afe <arch_irq_enable> @ imm = #-0xd24
 8013822: 2200         	movs	r2, #0x0
 8013824: 2100         	movs	r1, #0x0
 8013826: 203f         	movs	r0, #0x3f
 8013828: f7ff f976    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0xd14
 801382c: 203f         	movs	r0, #0x3f
 801382e: f7ff f966    	bl	0x8012afe <arch_irq_enable> @ imm = #-0xd34
 8013832: 2200         	movs	r2, #0x0
 8013834: 2100         	movs	r1, #0x0
 8013836: 2042         	movs	r0, #0x42
 8013838: f7ff f96e    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0xd24
 801383c: 2042         	movs	r0, #0x42
 801383e: f7ff f95e    	bl	0x8012afe <arch_irq_enable> @ imm = #-0xd44
 8013842: 687b         	ldr	r3, [r7, #0x4]
 8013844: 695b         	ldr	r3, [r3, #0x14]
 8013846: f443 4304    	orr	r3, r3, #0x8400
 801384a: f043 0313    	orr	r3, r3, #0x13
 801384e: 687a         	ldr	r2, [r7, #0x4]
 8013850: 6153         	str	r3, [r2, #0x14]
 8013852: 3708         	adds	r7, #0x8
 8013854: 46bd         	mov	sp, r7
 8013856: bd80         	pop	{r7, pc}

08013858 <stm32_clock_control_mco_init>:
; {
 8013858: b480         	push	{r7}
 801385a: af00         	add	r7, sp, #0x0
; }
 801385c: bf00         	nop
 801385e: 46bd         	mov	sp, r7
 8013860: bc80         	pop	{r7}
 8013862: 4770         	bx	lr

08013864 <get_pll_div_frequency>:
; {
 8013864: b480         	push	{r7}
 8013866: b085         	sub	sp, #0x14
 8013868: af00         	add	r7, sp, #0x0
 801386a: 60f8         	str	r0, [r7, #0xc]
 801386c: 60b9         	str	r1, [r7, #0x8]
 801386e: 607a         	str	r2, [r7, #0x4]
 8013870: 603b         	str	r3, [r7]
; 	return pllsrc_freq / pllm_div * plln_mul / pllout_div;
 8013872: 68bb         	ldr	r3, [r7, #0x8]
 8013874: 68fa         	ldr	r2, [r7, #0xc]
 8013876: fbb2 f3f3    	udiv	r3, r2, r3
 801387a: 687a         	ldr	r2, [r7, #0x4]
 801387c: fb03 f202    	mul	r2, r3, r2
 8013880: 683b         	ldr	r3, [r7]
 8013882: fbb2 f3f3    	udiv	r3, r2, r3
; }
 8013886: 4618         	mov	r0, r3
 8013888: 3714         	adds	r7, #0x14
 801388a: 46bd         	mov	sp, r7
 801388c: bc80         	pop	{r7}
 801388e: 4770         	bx	lr

08013890 <get_bus_clock>:
; {
 8013890: b480         	push	{r7}
 8013892: b083         	sub	sp, #0xc
 8013894: af00         	add	r7, sp, #0x0
 8013896: 6078         	str	r0, [r7, #0x4]
 8013898: 6039         	str	r1, [r7]
; 	return clock / prescaler;
 801389a: 687a         	ldr	r2, [r7, #0x4]
 801389c: 683b         	ldr	r3, [r7]
 801389e: fbb2 f3f3    	udiv	r3, r2, r3
; }
 80138a2: 4618         	mov	r0, r3
 80138a4: 370c         	adds	r7, #0xc
 80138a6: 46bd         	mov	sp, r7
 80138a8: bc80         	pop	{r7}
 80138aa: 4770         	bx	lr

080138ac <stm32_clock_control_on>:
; {
 80138ac: b480         	push	{r7}
 80138ae: b089         	sub	sp, #0x24
 80138b0: af00         	add	r7, sp, #0x0
 80138b2: 6078         	str	r0, [r7, #0x4]
 80138b4: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 80138b6: 683b         	ldr	r3, [r7]
 80138b8: 61fb         	str	r3, [r7, #0x1c]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 80138ba: 69fb         	ldr	r3, [r7, #0x1c]
 80138bc: 681b         	ldr	r3, [r3]
 80138be: 2b2f         	cmp	r3, #0x2f
 80138c0: d905         	bls	0x80138ce <stm32_clock_control_on+0x22> @ imm = #0xa
 80138c2: 69fb         	ldr	r3, [r7, #0x1c]
 80138c4: 681b         	ldr	r3, [r3]
 80138c6: 2ba8         	cmp	r3, #0xa8
 80138c8: d801         	bhi	0x80138ce <stm32_clock_control_on+0x22> @ imm = #0x2
 80138ca: 2301         	movs	r3, #0x1
 80138cc: e000         	b	0x80138d0 <stm32_clock_control_on+0x24> @ imm = #0x0
 80138ce: 2300         	movs	r3, #0x0
 80138d0: 2b00         	cmp	r3, #0x0
 80138d2: d102         	bne	0x80138da <stm32_clock_control_on+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 80138d4: f06f 0385    	mvn	r3, #0x85
 80138d8: e01e         	b	0x8013918 <stm32_clock_control_on+0x6c> @ imm = #0x3c
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus,
 80138da: 69fb         	ldr	r3, [r7, #0x1c]
 80138dc: 681b         	ldr	r3, [r3]
 80138de: f103 4380    	add.w	r3, r3, #0x40000000
 80138e2: f503 330e    	add.w	r3, r3, #0x23800
 80138e6: 69fa         	ldr	r2, [r7, #0x1c]
 80138e8: 6852         	ldr	r2, [r2, #0x4]
 80138ea: 617b         	str	r3, [r7, #0x14]
 80138ec: 613a         	str	r2, [r7, #0x10]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 80138ee: 697b         	ldr	r3, [r7, #0x14]
 80138f0: 681b         	ldr	r3, [r3]
 80138f2: 60fb         	str	r3, [r7, #0xc]
; 	*(volatile uint32_t *)addr = temp | mask;
 80138f4: 697b         	ldr	r3, [r7, #0x14]
 80138f6: 6939         	ldr	r1, [r7, #0x10]
 80138f8: 68fa         	ldr	r2, [r7, #0xc]
 80138fa: 430a         	orrs	r2, r1
 80138fc: 601a         	str	r2, [r3]
; }
 80138fe: bf00         	nop
; 	temp = sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus);
 8013900: 69fb         	ldr	r3, [r7, #0x1c]
 8013902: 681b         	ldr	r3, [r3]
 8013904: f103 4380    	add.w	r3, r3, #0x40000000
 8013908: f503 330e    	add.w	r3, r3, #0x23800
 801390c: 61bb         	str	r3, [r7, #0x18]
; 	return *(volatile uint32_t *)addr;
 801390e: 69bb         	ldr	r3, [r7, #0x18]
 8013910: 681b         	ldr	r3, [r3]
; 	temp = sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus);
 8013912: 60bb         	str	r3, [r7, #0x8]
; 	UNUSED(temp);
 8013914: 68bb         	ldr	r3, [r7, #0x8]
; 	return 0;
 8013916: 2300         	movs	r3, #0x0
; }
 8013918: 4618         	mov	r0, r3
 801391a: 3724         	adds	r7, #0x24
 801391c: 46bd         	mov	sp, r7
 801391e: bc80         	pop	{r7}
 8013920: 4770         	bx	lr

08013922 <stm32_clock_control_off>:
; {
 8013922: b480         	push	{r7}
 8013924: b087         	sub	sp, #0x1c
 8013926: af00         	add	r7, sp, #0x0
 8013928: 6078         	str	r0, [r7, #0x4]
 801392a: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 801392c: 683b         	ldr	r3, [r7]
 801392e: 617b         	str	r3, [r7, #0x14]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 8013930: 697b         	ldr	r3, [r7, #0x14]
 8013932: 681b         	ldr	r3, [r3]
 8013934: 2b2f         	cmp	r3, #0x2f
 8013936: d905         	bls	0x8013944 <stm32_clock_control_off+0x22> @ imm = #0xa
 8013938: 697b         	ldr	r3, [r7, #0x14]
 801393a: 681b         	ldr	r3, [r3]
 801393c: 2ba8         	cmp	r3, #0xa8
 801393e: d801         	bhi	0x8013944 <stm32_clock_control_off+0x22> @ imm = #0x2
 8013940: 2301         	movs	r3, #0x1
 8013942: e000         	b	0x8013946 <stm32_clock_control_off+0x24> @ imm = #0x0
 8013944: 2300         	movs	r3, #0x0
 8013946: 2b00         	cmp	r3, #0x0
 8013948: d102         	bne	0x8013950 <stm32_clock_control_off+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 801394a: f06f 0385    	mvn	r3, #0x85
 801394e: e014         	b	0x801397a <stm32_clock_control_off+0x58> @ imm = #0x28
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus,
 8013950: 697b         	ldr	r3, [r7, #0x14]
 8013952: 681b         	ldr	r3, [r3]
 8013954: f103 4380    	add.w	r3, r3, #0x40000000
 8013958: f503 330e    	add.w	r3, r3, #0x23800
 801395c: 697a         	ldr	r2, [r7, #0x14]
 801395e: 6852         	ldr	r2, [r2, #0x4]
 8013960: 613b         	str	r3, [r7, #0x10]
 8013962: 60fa         	str	r2, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8013964: 693b         	ldr	r3, [r7, #0x10]
 8013966: 681b         	ldr	r3, [r3]
 8013968: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 801396a: 68fb         	ldr	r3, [r7, #0xc]
 801396c: 43d9         	mvns	r1, r3
 801396e: 693b         	ldr	r3, [r7, #0x10]
 8013970: 68ba         	ldr	r2, [r7, #0x8]
 8013972: 400a         	ands	r2, r1
 8013974: 601a         	str	r2, [r3]
; }
 8013976: bf00         	nop
; 	return 0;
 8013978: 2300         	movs	r3, #0x0
; }
 801397a: 4618         	mov	r0, r3
 801397c: 371c         	adds	r7, #0x1c
 801397e: 46bd         	mov	sp, r7
 8013980: bc80         	pop	{r7}
 8013982: 4770         	bx	lr

08013984 <stm32_clock_control_configure>:
; {
 8013984: b580         	push	{r7, lr}
 8013986: b08c         	sub	sp, #0x30
 8013988: af00         	add	r7, sp, #0x0
 801398a: 60f8         	str	r0, [r7, #0xc]
 801398c: 60b9         	str	r1, [r7, #0x8]
 801398e: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 8013990: 68bb         	ldr	r3, [r7, #0x8]
 8013992: 62fb         	str	r3, [r7, #0x2c]
; 	err = enabled_clock(pclken->bus);
 8013994: 6afb         	ldr	r3, [r7, #0x2c]
 8013996: 681b         	ldr	r3, [r3]
 8013998: 4618         	mov	r0, r3
 801399a: f7f2 f865    	bl	0x8005a68 <enabled_clock> @ imm = #-0xdf36
 801399e: 62b8         	str	r0, [r7, #0x28]
; 	if (err < 0) {
 80139a0: 6abb         	ldr	r3, [r7, #0x28]
 80139a2: 2b00         	cmp	r3, #0x0
 80139a4: da01         	bge	0x80139aa <stm32_clock_control_configure+0x26> @ imm = #0x2
; 		return err;
 80139a6: 6abb         	ldr	r3, [r7, #0x28]
 80139a8: e043         	b	0x8013a32 <stm32_clock_control_configure+0xae> @ imm = #0x86
; 	if (pclken->enr == NO_SEL) {
 80139aa: 6afb         	ldr	r3, [r7, #0x2c]
 80139ac: 685b         	ldr	r3, [r3, #0x4]
 80139ae: 2bff         	cmp	r3, #0xff
 80139b0: d101         	bne	0x80139b6 <stm32_clock_control_configure+0x32> @ imm = #0x2
; 		return 0;
 80139b2: 2300         	movs	r3, #0x0
 80139b4: e03d         	b	0x8013a32 <stm32_clock_control_configure+0xae> @ imm = #0x7a
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 80139b6: 6afb         	ldr	r3, [r7, #0x2c]
 80139b8: 685b         	ldr	r3, [r3, #0x4]
 80139ba: b2db         	uxtb	r3, r3
 80139bc: f103 4380    	add.w	r3, r3, #0x40000000
 80139c0: f503 330e    	add.w	r3, r3, #0x23800
; 		       STM32_CLOCK_MASK_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 80139c4: 6afa         	ldr	r2, [r7, #0x2c]
 80139c6: 6852         	ldr	r2, [r2, #0x4]
 80139c8: 0b52         	lsrs	r2, r2, #0xd
 80139ca: f002 0107    	and	r1, r2, #0x7
 80139ce: 6afa         	ldr	r2, [r7, #0x2c]
 80139d0: 6852         	ldr	r2, [r2, #0x4]
 80139d2: 0a12         	lsrs	r2, r2, #0x8
 80139d4: f002 021f    	and	r2, r2, #0x1f
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 80139d8: fa01 f202    	lsl.w	r2, r1, r2
 80139dc: 61bb         	str	r3, [r7, #0x18]
 80139de: 617a         	str	r2, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 80139e0: 69bb         	ldr	r3, [r7, #0x18]
 80139e2: 681b         	ldr	r3, [r3]
 80139e4: 613b         	str	r3, [r7, #0x10]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 80139e6: 697b         	ldr	r3, [r7, #0x14]
 80139e8: 43d9         	mvns	r1, r3
 80139ea: 69bb         	ldr	r3, [r7, #0x18]
 80139ec: 693a         	ldr	r2, [r7, #0x10]
 80139ee: 400a         	ands	r2, r1
 80139f0: 601a         	str	r2, [r3]
; }
 80139f2: bf00         	nop
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 80139f4: 6afb         	ldr	r3, [r7, #0x2c]
 80139f6: 685b         	ldr	r3, [r3, #0x4]
 80139f8: b2db         	uxtb	r3, r3
 80139fa: f103 4380    	add.w	r3, r3, #0x40000000
 80139fe: f503 330e    	add.w	r3, r3, #0x23800
; 		     STM32_CLOCK_VAL_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 8013a02: 6afa         	ldr	r2, [r7, #0x2c]
 8013a04: 6852         	ldr	r2, [r2, #0x4]
 8013a06: 0c12         	lsrs	r2, r2, #0x10
 8013a08: f002 0107    	and	r1, r2, #0x7
 8013a0c: 6afa         	ldr	r2, [r7, #0x2c]
 8013a0e: 6852         	ldr	r2, [r2, #0x4]
 8013a10: 0a12         	lsrs	r2, r2, #0x8
 8013a12: f002 021f    	and	r2, r2, #0x1f
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 8013a16: fa01 f202    	lsl.w	r2, r1, r2
 8013a1a: 627b         	str	r3, [r7, #0x24]
 8013a1c: 623a         	str	r2, [r7, #0x20]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8013a1e: 6a7b         	ldr	r3, [r7, #0x24]
 8013a20: 681b         	ldr	r3, [r3]
 8013a22: 61fb         	str	r3, [r7, #0x1c]
; 	*(volatile uint32_t *)addr = temp | mask;
 8013a24: 6a7b         	ldr	r3, [r7, #0x24]
 8013a26: 6a39         	ldr	r1, [r7, #0x20]
 8013a28: 69fa         	ldr	r2, [r7, #0x1c]
 8013a2a: 430a         	orrs	r2, r1
 8013a2c: 601a         	str	r2, [r3]
; }
 8013a2e: bf00         	nop
; 	return 0;
 8013a30: 2300         	movs	r3, #0x0
; }
 8013a32: 4618         	mov	r0, r3
 8013a34: 3730         	adds	r7, #0x30
 8013a36: 46bd         	mov	sp, r7
 8013a38: bd80         	pop	{r7, pc}

08013a3a <stm32_clock_control_get_status>:
; {
 8013a3a: b580         	push	{r7, lr}
 8013a3c: b084         	sub	sp, #0x10
 8013a3e: af00         	add	r7, sp, #0x0
 8013a40: 6078         	str	r0, [r7, #0x4]
 8013a42: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)sub_system;
 8013a44: 683b         	ldr	r3, [r7]
 8013a46: 60fb         	str	r3, [r7, #0xc]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == true) {
 8013a48: 68fb         	ldr	r3, [r7, #0xc]
 8013a4a: 681b         	ldr	r3, [r3]
 8013a4c: 2b2f         	cmp	r3, #0x2f
 8013a4e: d905         	bls	0x8013a5c <stm32_clock_control_get_status+0x22> @ imm = #0xa
 8013a50: 68fb         	ldr	r3, [r7, #0xc]
 8013a52: 681b         	ldr	r3, [r3]
 8013a54: 2ba8         	cmp	r3, #0xa8
 8013a56: d801         	bhi	0x8013a5c <stm32_clock_control_get_status+0x22> @ imm = #0x2
 8013a58: 2301         	movs	r3, #0x1
 8013a5a: e000         	b	0x8013a5e <stm32_clock_control_get_status+0x24> @ imm = #0x0
 8013a5c: 2300         	movs	r3, #0x0
 8013a5e: 2b01         	cmp	r3, #0x1
 8013a60: d113         	bne	0x8013a8a <stm32_clock_control_get_status+0x50> @ imm = #0x26
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 8013a62: 68fb         	ldr	r3, [r7, #0xc]
 8013a64: 681b         	ldr	r3, [r3]
 8013a66: f103 4380    	add.w	r3, r3, #0x40000000
 8013a6a: f503 330e    	add.w	r3, r3, #0x23800
 8013a6e: 60bb         	str	r3, [r7, #0x8]
; 	return *(volatile uint32_t *)addr;
 8013a70: 68bb         	ldr	r3, [r7, #0x8]
 8013a72: 681a         	ldr	r2, [r3]
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 8013a74: 68fb         	ldr	r3, [r7, #0xc]
 8013a76: 685b         	ldr	r3, [r3, #0x4]
 8013a78: 401a         	ands	r2, r3
; 		    == pclken->enr) {
 8013a7a: 68fb         	ldr	r3, [r7, #0xc]
 8013a7c: 685b         	ldr	r3, [r3, #0x4]
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 8013a7e: 429a         	cmp	r2, r3
 8013a80: d101         	bne	0x8013a86 <stm32_clock_control_get_status+0x4c> @ imm = #0x2
; 			return CLOCK_CONTROL_STATUS_ON;
 8013a82: 2302         	movs	r3, #0x2
 8013a84: e00c         	b	0x8013aa0 <stm32_clock_control_get_status+0x66> @ imm = #0x18
; 			return CLOCK_CONTROL_STATUS_OFF;
 8013a86: 2301         	movs	r3, #0x1
 8013a88: e00a         	b	0x8013aa0 <stm32_clock_control_get_status+0x66> @ imm = #0x14
; 		if (enabled_clock(pclken->bus) == 0) {
 8013a8a: 68fb         	ldr	r3, [r7, #0xc]
 8013a8c: 681b         	ldr	r3, [r3]
 8013a8e: 4618         	mov	r0, r3
 8013a90: f7f1 ffea    	bl	0x8005a68 <enabled_clock> @ imm = #-0xe02c
 8013a94: 4603         	mov	r3, r0
 8013a96: 2b00         	cmp	r3, #0x0
 8013a98: d101         	bne	0x8013a9e <stm32_clock_control_get_status+0x64> @ imm = #0x2
; 			return CLOCK_CONTROL_STATUS_ON;
 8013a9a: 2302         	movs	r3, #0x2
 8013a9c: e000         	b	0x8013aa0 <stm32_clock_control_get_status+0x66> @ imm = #0x0
; 			return CLOCK_CONTROL_STATUS_OFF;
 8013a9e: 2301         	movs	r3, #0x1
; }
 8013aa0: 4618         	mov	r0, r3
 8013aa2: 3710         	adds	r7, #0x10
 8013aa4: 46bd         	mov	sp, r7
 8013aa6: bd80         	pop	{r7, pc}

08013aa8 <stm32_clock_switch_to_hsi>:
; {
 8013aa8: b580         	push	{r7, lr}
 8013aaa: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_HSI_IsReady() != 1) {
 8013aac: f7f1 ff14    	bl	0x80058d8 <LL_RCC_HSI_IsReady> @ imm = #-0xe1d8
 8013ab0: 4603         	mov	r3, r0
 8013ab2: 2b01         	cmp	r3, #0x1
 8013ab4: d007         	beq	0x8013ac6 <stm32_clock_switch_to_hsi+0x1e> @ imm = #0xe
; 		LL_RCC_HSI_Enable();
 8013ab6: f7f1 ff01    	bl	0x80058bc <LL_RCC_HSI_Enable> @ imm = #-0xe1fe
; 		while (LL_RCC_HSI_IsReady() != 1) {
 8013aba: bf00         	nop
 8013abc: f7f1 ff0c    	bl	0x80058d8 <LL_RCC_HSI_IsReady> @ imm = #-0xe1e8
 8013ac0: 4603         	mov	r3, r0
 8013ac2: 2b01         	cmp	r3, #0x1
 8013ac4: d1fa         	bne	0x8013abc <stm32_clock_switch_to_hsi+0x14> @ imm = #-0xc
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI);
 8013ac6: 2000         	movs	r0, #0x0
 8013ac8: f7f1 ff38    	bl	0x800593c <LL_RCC_SetSysClkSource> @ imm = #-0xe190
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI) {
 8013acc: bf00         	nop
 8013ace: f7f1 ff49    	bl	0x8005964 <LL_RCC_GetSysClkSource> @ imm = #-0xe16e
 8013ad2: 4603         	mov	r3, r0
 8013ad4: 2b00         	cmp	r3, #0x0
 8013ad6: d1fa         	bne	0x8013ace <stm32_clock_switch_to_hsi+0x26> @ imm = #-0xc
; }
 8013ad8: bf00         	nop
 8013ada: bf00         	nop
 8013adc: bd80         	pop	{r7, pc}

08013ade <set_up_fixed_clock_sources>:
; {
 8013ade: b580         	push	{r7, lr}
 8013ae0: af00         	add	r7, sp, #0x0
; 			LL_RCC_HSE_DisableBypass();
 8013ae2: f7f1 febd    	bl	0x8005860 <LL_RCC_HSE_DisableBypass> @ imm = #-0xe286
; 		LL_RCC_HSE_Enable();
 8013ae6: f7f1 fec9    	bl	0x800587c <LL_RCC_HSE_Enable> @ imm = #-0xe26e
; 		while (LL_RCC_HSE_IsReady() != 1) {
 8013aea: bf00         	nop
 8013aec: f7f1 fed4    	bl	0x8005898 <LL_RCC_HSE_IsReady> @ imm = #-0xe258
 8013af0: 4603         	mov	r3, r0
 8013af2: 2b01         	cmp	r3, #0x1
 8013af4: d1fa         	bne	0x8013aec <set_up_fixed_clock_sources+0xe> @ imm = #-0xc
; 		LL_RCC_LSI_Enable();
 8013af6: f7f1 ff01    	bl	0x80058fc <LL_RCC_LSI_Enable> @ imm = #-0xe1fe
; 		while (LL_RCC_LSI_IsReady() != 1) {
 8013afa: bf00         	nop
 8013afc: f7f1 ff0c    	bl	0x8005918 <LL_RCC_LSI_IsReady> @ imm = #-0xe1e8
 8013b00: 4603         	mov	r3, r0
 8013b02: 2b01         	cmp	r3, #0x1
 8013b04: d1fa         	bne	0x8013afc <set_up_fixed_clock_sources+0x1e> @ imm = #-0xc
; }
 8013b06: bf00         	nop
 8013b08: bf00         	nop
 8013b0a: bd80         	pop	{r7, pc}

08013b0c <config_regulator_voltage>:
; void __weak config_regulator_voltage(uint32_t hclk_freq) {}
 8013b0c: b480         	push	{r7}
 8013b0e: b083         	sub	sp, #0xc
 8013b10: af00         	add	r7, sp, #0x0
 8013b12: 6078         	str	r0, [r7, #0x4]
 8013b14: bf00         	nop
 8013b16: 370c         	adds	r7, #0xc
 8013b18: 46bd         	mov	sp, r7
 8013b1a: bc80         	pop	{r7}
 8013b1c: 4770         	bx	lr

08013b1e <get_pll_source>:
; {
 8013b1e: b480         	push	{r7}
 8013b20: af00         	add	r7, sp, #0x0
; 		return LL_RCC_PLLSOURCE_HSE;
 8013b22: f44f 0380    	mov.w	r3, #0x400000
; }
 8013b26: 4618         	mov	r0, r3
 8013b28: 46bd         	mov	sp, r7
 8013b2a: bc80         	pop	{r7}
 8013b2c: 4770         	bx	lr

08013b2e <config_pll_sysclock>:
; {
 8013b2e: b580         	push	{r7, lr}
 8013b30: af00         	add	r7, sp, #0x0
; 	LL_RCC_PLL_ConfigDomain_SYS(get_pll_source(),
 8013b32: f7ff fff4    	bl	0x8013b1e <get_pll_source> @ imm = #-0x18
 8013b36: 2300         	movs	r3, #0x0
 8013b38: 22a8         	movs	r2, #0xa8
 8013b3a: 2106         	movs	r1, #0x6
 8013b3c: f7f2 f964    	bl	0x8005e08 <LL_RCC_PLL_ConfigDomain_SYS> @ imm = #-0xdd38
; }
 8013b40: bf00         	nop
 8013b42: bd80         	pop	{r7, pc}

08013b44 <config_enable_default_clocks>:
; {
 8013b44: b580         	push	{r7, lr}
 8013b46: af00         	add	r7, sp, #0x0
; 	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
 8013b48: f04f 5080    	mov.w	r0, #0x10000000
 8013b4c: f7f2 f944    	bl	0x8005dd8 <LL_APB1_GRP1_EnableClock> @ imm = #-0xdd78
; }
 8013b50: bf00         	nop
 8013b52: bd80         	pop	{r7, pc}

08013b54 <device_is_ready>:
; {
 8013b54: b580         	push	{r7, lr}
 8013b56: b082         	sub	sp, #0x8
 8013b58: af00         	add	r7, sp, #0x0
 8013b5a: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8013b5c: 6878         	ldr	r0, [r7, #0x4]
 8013b5e: f004 fe6a    	bl	0x8018836 <z_impl_device_is_ready> @ imm = #0x4cd4
 8013b62: 4603         	mov	r3, r0
; }
 8013b64: 4618         	mov	r0, r3
 8013b66: 3708         	adds	r7, #0x8
 8013b68: 46bd         	mov	sp, r7
 8013b6a: bd80         	pop	{r7, pc}

08013b6c <z_impl_uart_poll_out>:
; {
 8013b6c: b580         	push	{r7, lr}
 8013b6e: b084         	sub	sp, #0x10
 8013b70: af00         	add	r7, sp, #0x0
 8013b72: 6078         	str	r0, [r7, #0x4]
 8013b74: 460b         	mov	r3, r1
 8013b76: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8013b78: 687b         	ldr	r3, [r7, #0x4]
 8013b7a: 689b         	ldr	r3, [r3, #0x8]
 8013b7c: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 8013b7e: 68fb         	ldr	r3, [r7, #0xc]
 8013b80: 69db         	ldr	r3, [r3, #0x1c]
 8013b82: 78fa         	ldrb	r2, [r7, #0x3]
 8013b84: 4611         	mov	r1, r2
 8013b86: 6878         	ldr	r0, [r7, #0x4]
 8013b88: 4798         	blx	r3
; }
 8013b8a: bf00         	nop
 8013b8c: 3710         	adds	r7, #0x10
 8013b8e: 46bd         	mov	sp, r7
 8013b90: bd80         	pop	{r7, pc}

08013b92 <uart_poll_out>:
; {
 8013b92: b580         	push	{r7, lr}
 8013b94: b082         	sub	sp, #0x8
 8013b96: af00         	add	r7, sp, #0x0
 8013b98: 6078         	str	r0, [r7, #0x4]
 8013b9a: 460b         	mov	r3, r1
 8013b9c: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 8013b9e: 78fb         	ldrb	r3, [r7, #0x3]
 8013ba0: 4619         	mov	r1, r3
 8013ba2: 6878         	ldr	r0, [r7, #0x4]
 8013ba4: f7ff ffe2    	bl	0x8013b6c <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 8013ba8: bf00         	nop
 8013baa: 3708         	adds	r7, #0x8
 8013bac: 46bd         	mov	sp, r7
 8013bae: bd80         	pop	{r7, pc}

08013bb0 <pm_device_runtime_get>:
; {
 8013bb0: b480         	push	{r7}
 8013bb2: b083         	sub	sp, #0xc
 8013bb4: af00         	add	r7, sp, #0x0
 8013bb6: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8013bb8: 2300         	movs	r3, #0x0
; }
 8013bba: 4618         	mov	r0, r3
 8013bbc: 370c         	adds	r7, #0xc
 8013bbe: 46bd         	mov	sp, r7
 8013bc0: bc80         	pop	{r7}
 8013bc2: 4770         	bx	lr

08013bc4 <pm_device_runtime_put_async>:
; {
 8013bc4: b480         	push	{r7}
 8013bc6: b085         	sub	sp, #0x14
 8013bc8: af00         	add	r7, sp, #0x0
 8013bca: 60f8         	str	r0, [r7, #0xc]
 8013bcc: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 8013bd0: 2300         	movs	r3, #0x0
; }
 8013bd2: 4618         	mov	r0, r3
 8013bd4: 3714         	adds	r7, #0x14
 8013bd6: 46bd         	mov	sp, r7
 8013bd8: bc80         	pop	{r7}
 8013bda: 4770         	bx	lr

08013bdc <device_is_ready>:
; {
 8013bdc: b580         	push	{r7, lr}
 8013bde: b082         	sub	sp, #0x8
 8013be0: af00         	add	r7, sp, #0x0
 8013be2: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8013be4: 6878         	ldr	r0, [r7, #0x4]
 8013be6: f004 fe26    	bl	0x8018836 <z_impl_device_is_ready> @ imm = #0x4c4c
 8013bea: 4603         	mov	r3, r0
; }
 8013bec: 4618         	mov	r0, r3
 8013bee: 3708         	adds	r7, #0x8
 8013bf0: 46bd         	mov	sp, r7
 8013bf2: bd80         	pop	{r7, pc}

08013bf4 <k_sleep>:
; {
 8013bf4: b580         	push	{r7, lr}
 8013bf6: b082         	sub	sp, #0x8
 8013bf8: af00         	add	r7, sp, #0x0
 8013bfa: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8013bfe: e9d7 0100    	ldrd	r0, r1, [r7]
 8013c02: f7fb f999    	bl	0x800ef38 <z_impl_k_sleep> @ imm = #-0x4cce
 8013c06: 4603         	mov	r3, r0
; }
 8013c08: 4618         	mov	r0, r3
 8013c0a: 3708         	adds	r7, #0x8
 8013c0c: 46bd         	mov	sp, r7
 8013c0e: bd80         	pop	{r7, pc}

08013c10 <clock_control_on>:
; {
 8013c10: b580         	push	{r7, lr}
 8013c12: b084         	sub	sp, #0x10
 8013c14: af00         	add	r7, sp, #0x0
 8013c16: 6078         	str	r0, [r7, #0x4]
 8013c18: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8013c1a: 687b         	ldr	r3, [r7, #0x4]
 8013c1c: 689b         	ldr	r3, [r3, #0x8]
 8013c1e: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8013c20: 68fb         	ldr	r3, [r7, #0xc]
 8013c22: 681b         	ldr	r3, [r3]
 8013c24: 6839         	ldr	r1, [r7]
 8013c26: 6878         	ldr	r0, [r7, #0x4]
 8013c28: 4798         	blx	r3
 8013c2a: 4603         	mov	r3, r0
; }
 8013c2c: 4618         	mov	r0, r3
 8013c2e: 3710         	adds	r7, #0x10
 8013c30: 46bd         	mov	sp, r7
 8013c32: bd80         	pop	{r7, pc}

08013c34 <z_log_msg_runtime_create>:
; {
 8013c34: b580         	push	{r7, lr}
 8013c36: b08a         	sub	sp, #0x28
 8013c38: af04         	add	r7, sp, #0x10
 8013c3a: 60b9         	str	r1, [r7, #0x8]
 8013c3c: 607b         	str	r3, [r7, #0x4]
 8013c3e: 4603         	mov	r3, r0
 8013c40: 73fb         	strb	r3, [r7, #0xf]
 8013c42: 4613         	mov	r3, r2
 8013c44: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8013c46: f107 032c    	add.w	r3, r7, #0x2c
 8013c4a: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8013c4c: 7bba         	ldrb	r2, [r7, #0xe]
 8013c4e: 7bf8         	ldrb	r0, [r7, #0xf]
 8013c50: 697b         	ldr	r3, [r7, #0x14]
 8013c52: 9303         	str	r3, [sp, #0xc]
 8013c54: 6abb         	ldr	r3, [r7, #0x28]
 8013c56: 9302         	str	r3, [sp, #0x8]
 8013c58: 6a7b         	ldr	r3, [r7, #0x24]
 8013c5a: 9301         	str	r3, [sp, #0x4]
 8013c5c: 6a3b         	ldr	r3, [r7, #0x20]
 8013c5e: 9300         	str	r3, [sp]
 8013c60: 687b         	ldr	r3, [r7, #0x4]
 8013c62: 68b9         	ldr	r1, [r7, #0x8]
 8013c64: f7ee f802    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x11ffc
; }
 8013c68: bf00         	nop
 8013c6a: 3718         	adds	r7, #0x18
 8013c6c: 46bd         	mov	sp, r7
 8013c6e: bd80         	pop	{r7, pc}

08013c70 <dma_stm32_dump_stream_irq>:
; {
 8013c70: b580         	push	{r7, lr}
 8013c72: b084         	sub	sp, #0x10
 8013c74: af00         	add	r7, sp, #0x0
 8013c76: 6078         	str	r0, [r7, #0x4]
 8013c78: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8013c7a: 687b         	ldr	r3, [r7, #0x4]
 8013c7c: 685b         	ldr	r3, [r3, #0x4]
 8013c7e: 60fb         	str	r3, [r7, #0xc]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8013c80: 68fb         	ldr	r3, [r7, #0xc]
 8013c82: 691b         	ldr	r3, [r3, #0x10]
 8013c84: 60bb         	str	r3, [r7, #0x8]
; 	stm32_dma_dump_stream_irq(dma, id);
 8013c86: 6839         	ldr	r1, [r7]
 8013c88: 68b8         	ldr	r0, [r7, #0x8]
 8013c8a: f7f3 fb09    	bl	0x80072a0 <stm32_dma_dump_stream_irq> @ imm = #-0xc9ee
; }
 8013c8e: bf00         	nop
 8013c90: 3710         	adds	r7, #0x10
 8013c92: 46bd         	mov	sp, r7
 8013c94: bd80         	pop	{r7, pc}

08013c96 <dma_stm32_clear_stream_irq>:
; {
 8013c96: b580         	push	{r7, lr}
 8013c98: b084         	sub	sp, #0x10
 8013c9a: af00         	add	r7, sp, #0x0
 8013c9c: 6078         	str	r0, [r7, #0x4]
 8013c9e: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8013ca0: 687b         	ldr	r3, [r7, #0x4]
 8013ca2: 685b         	ldr	r3, [r3, #0x4]
 8013ca4: 60fb         	str	r3, [r7, #0xc]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8013ca6: 68fb         	ldr	r3, [r7, #0xc]
 8013ca8: 691b         	ldr	r3, [r3, #0x10]
 8013caa: 60bb         	str	r3, [r7, #0x8]
; 	dma_stm32_clear_tc(dma, id);
 8013cac: 6839         	ldr	r1, [r7]
 8013cae: 68b8         	ldr	r0, [r7, #0x8]
 8013cb0: f7f3 fa36    	bl	0x8007120 <dma_stm32_clear_tc> @ imm = #-0xcb94
; 	dma_stm32_clear_ht(dma, id);
 8013cb4: 6839         	ldr	r1, [r7]
 8013cb6: 68b8         	ldr	r0, [r7, #0x8]
 8013cb8: f7f3 fa20    	bl	0x80070fc <dma_stm32_clear_ht> @ imm = #-0xcbc0
; 	stm32_dma_clear_stream_irq(dma, id);
 8013cbc: 6839         	ldr	r1, [r7]
 8013cbe: 68b8         	ldr	r0, [r7, #0x8]
 8013cc0: f000 fff3    	bl	0x8014caa <stm32_dma_clear_stream_irq> @ imm = #0xfe6
; }
 8013cc4: bf00         	nop
 8013cc6: 3710         	adds	r7, #0x10
 8013cc8: 46bd         	mov	sp, r7
 8013cca: bd80         	pop	{r7, pc}

08013ccc <dma_stm32_disable_stream>:
; {
 8013ccc: b580         	push	{r7, lr}
 8013cce: b084         	sub	sp, #0x10
 8013cd0: af00         	add	r7, sp, #0x0
 8013cd2: 6078         	str	r0, [r7, #0x4]
 8013cd4: 6039         	str	r1, [r7]
; 	int count = 0;
 8013cd6: 2300         	movs	r3, #0x0
 8013cd8: 60fb         	str	r3, [r7, #0xc]
; 		if (stm32_dma_disable_stream(dma, id) == 0) {
 8013cda: 6839         	ldr	r1, [r7]
 8013cdc: 6878         	ldr	r0, [r7, #0x4]
 8013cde: f001 f821    	bl	0x8014d24 <stm32_dma_disable_stream> @ imm = #0x1042
 8013ce2: 4603         	mov	r3, r0
 8013ce4: 2b00         	cmp	r3, #0x0
 8013ce6: d101         	bne	0x8013cec <dma_stm32_disable_stream+0x20> @ imm = #0x2
; 			return 0;
 8013ce8: 2100         	movs	r1, #0x0
 8013cea: e012         	b	0x8013d12 <dma_stm32_disable_stream+0x46> @ imm = #0x24
; 		if (count++ > (5 * 1000)) {
 8013cec: 68fb         	ldr	r3, [r7, #0xc]
 8013cee: 1c5a         	adds	r2, r3, #0x1
 8013cf0: 60fa         	str	r2, [r7, #0xc]
 8013cf2: f241 3288    	movw	r2, #0x1388
 8013cf6: 4293         	cmp	r3, r2
 8013cf8: dd02         	ble	0x8013d00 <dma_stm32_disable_stream+0x34> @ imm = #0x4
; 			return -EBUSY;
 8013cfa: f06f 010f    	mvn	r1, #0xf
 8013cfe: e008         	b	0x8013d12 <dma_stm32_disable_stream+0x46> @ imm = #0x10
; 		k_sleep(K_MSEC(1));
 8013d00: f04f 020a    	mov.w	r2, #0xa
 8013d04: f04f 0300    	mov.w	r3, #0x0
 8013d08: 4610         	mov	r0, r2
 8013d0a: 4619         	mov	r1, r3
 8013d0c: f7ff ff72    	bl	0x8013bf4 <k_sleep>     @ imm = #-0x11c
; 	for (;;) {
 8013d10: e7e3         	b	0x8013cda <dma_stm32_disable_stream+0xe> @ imm = #-0x3a
; }
 8013d12: 460b         	mov	r3, r1
 8013d14: 4618         	mov	r0, r3
 8013d16: 3710         	adds	r7, #0x10
 8013d18: 46bd         	mov	sp, r7
 8013d1a: bd80         	pop	{r7, pc}

08013d1c <dma_stm32_reload>:
; {
 8013d1c: b580         	push	{r7, lr}
 8013d1e: b088         	sub	sp, #0x20
 8013d20: af00         	add	r7, sp, #0x0
 8013d22: 60f8         	str	r0, [r7, #0xc]
 8013d24: 60b9         	str	r1, [r7, #0x8]
 8013d26: 607a         	str	r2, [r7, #0x4]
 8013d28: 603b         	str	r3, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8013d2a: 68fb         	ldr	r3, [r7, #0xc]
 8013d2c: 685b         	ldr	r3, [r3, #0x4]
 8013d2e: 61fb         	str	r3, [r7, #0x1c]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8013d30: 69fb         	ldr	r3, [r7, #0x1c]
 8013d32: 691b         	ldr	r3, [r3, #0x10]
 8013d34: 61bb         	str	r3, [r7, #0x18]
; 	if (id >= config->max_streams) {
 8013d36: 69fb         	ldr	r3, [r7, #0x1c]
 8013d38: 695b         	ldr	r3, [r3, #0x14]
 8013d3a: 68ba         	ldr	r2, [r7, #0x8]
 8013d3c: 429a         	cmp	r2, r3
 8013d3e: d302         	blo	0x8013d46 <dma_stm32_reload+0x2a> @ imm = #0x4
; 		return -EINVAL;
 8013d40: f06f 0315    	mvn	r3, #0x15
 8013d44: e06c         	b	0x8013e20 <dma_stm32_reload+0x104> @ imm = #0xd8
; 	stream = &config->streams[id];
 8013d46: 69fb         	ldr	r3, [r7, #0x1c]
 8013d48: 6999         	ldr	r1, [r3, #0x18]
 8013d4a: 68ba         	ldr	r2, [r7, #0x8]
 8013d4c: 4613         	mov	r3, r2
 8013d4e: 00db         	lsls	r3, r3, #0x3
 8013d50: 1a9b         	subs	r3, r3, r2
 8013d52: 009b         	lsls	r3, r3, #0x2
 8013d54: 440b         	add	r3, r1
 8013d56: 617b         	str	r3, [r7, #0x14]
; 	if (dma_stm32_disable_stream(dma, id) != 0) {
 8013d58: 68b9         	ldr	r1, [r7, #0x8]
 8013d5a: 69b8         	ldr	r0, [r7, #0x18]
 8013d5c: f7ff ffb6    	bl	0x8013ccc <dma_stm32_disable_stream> @ imm = #-0x94
 8013d60: 4603         	mov	r3, r0
 8013d62: 2b00         	cmp	r3, #0x0
 8013d64: d002         	beq	0x8013d6c <dma_stm32_reload+0x50> @ imm = #0x4
; 		return -EBUSY;
 8013d66: f06f 030f    	mvn	r3, #0xf
 8013d6a: e059         	b	0x8013e20 <dma_stm32_reload+0x104> @ imm = #0xb2
; 	switch (stream->direction) {
 8013d6c: 697b         	ldr	r3, [r7, #0x14]
 8013d6e: 681b         	ldr	r3, [r3]
 8013d70: 2b02         	cmp	r3, #0x2
 8013d72: d018         	beq	0x8013da6 <dma_stm32_reload+0x8a> @ imm = #0x30
 8013d74: 2b02         	cmp	r3, #0x2
 8013d76: d829         	bhi	0x8013dcc <dma_stm32_reload+0xb0> @ imm = #0x52
 8013d78: 2b00         	cmp	r3, #0x0
 8013d7a: d014         	beq	0x8013da6 <dma_stm32_reload+0x8a> @ imm = #0x28
 8013d7c: 2b01         	cmp	r3, #0x1
 8013d7e: d125         	bne	0x8013dcc <dma_stm32_reload+0xb0> @ imm = #0x4a
; 		LL_DMA_SetMemoryAddress(dma, dma_stm32_id_to_stream(id), src);
 8013d80: 68b8         	ldr	r0, [r7, #0x8]
 8013d82: f7f3 f99b    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xccca
 8013d86: 4603         	mov	r3, r0
 8013d88: 687a         	ldr	r2, [r7, #0x4]
 8013d8a: 4619         	mov	r1, r3
 8013d8c: 69b8         	ldr	r0, [r7, #0x18]
 8013d8e: f7f2 f92d    	bl	0x8005fec <LL_DMA_SetMemoryAddress> @ imm = #-0xdda6
; 		LL_DMA_SetPeriphAddress(dma, dma_stm32_id_to_stream(id), dst);
 8013d92: 68b8         	ldr	r0, [r7, #0x8]
 8013d94: f7f3 f992    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xccdc
 8013d98: 4603         	mov	r3, r0
 8013d9a: 683a         	ldr	r2, [r7]
 8013d9c: 4619         	mov	r1, r3
 8013d9e: 69b8         	ldr	r0, [r7, #0x18]
 8013da0: f7f2 f93c    	bl	0x800601c <LL_DMA_SetPeriphAddress> @ imm = #-0xdd88
; 		break;
 8013da4: e015         	b	0x8013dd2 <dma_stm32_reload+0xb6> @ imm = #0x2a
; 		LL_DMA_SetPeriphAddress(dma, dma_stm32_id_to_stream(id), src);
 8013da6: 68b8         	ldr	r0, [r7, #0x8]
 8013da8: f7f3 f988    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xccf0
 8013dac: 4603         	mov	r3, r0
 8013dae: 687a         	ldr	r2, [r7, #0x4]
 8013db0: 4619         	mov	r1, r3
 8013db2: 69b8         	ldr	r0, [r7, #0x18]
 8013db4: f7f2 f932    	bl	0x800601c <LL_DMA_SetPeriphAddress> @ imm = #-0xdd9c
; 		LL_DMA_SetMemoryAddress(dma, dma_stm32_id_to_stream(id), dst);
 8013db8: 68b8         	ldr	r0, [r7, #0x8]
 8013dba: f7f3 f97f    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xcd02
 8013dbe: 4603         	mov	r3, r0
 8013dc0: 683a         	ldr	r2, [r7]
 8013dc2: 4619         	mov	r1, r3
 8013dc4: 69b8         	ldr	r0, [r7, #0x18]
 8013dc6: f7f2 f911    	bl	0x8005fec <LL_DMA_SetMemoryAddress> @ imm = #-0xddde
; 		break;
 8013dca: e002         	b	0x8013dd2 <dma_stm32_reload+0xb6> @ imm = #0x4
; 		return -EINVAL;
 8013dcc: f06f 0315    	mvn	r3, #0x15
 8013dd0: e026         	b	0x8013e20 <dma_stm32_reload+0x104> @ imm = #0x4c
; 	if (stream->source_periph) {
 8013dd2: 697b         	ldr	r3, [r7, #0x14]
 8013dd4: 791b         	ldrb	r3, [r3, #0x4]
 8013dd6: 2b00         	cmp	r3, #0x0
 8013dd8: d00d         	beq	0x8013df6 <dma_stm32_reload+0xda> @ imm = #0x1a
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8013dda: 68b8         	ldr	r0, [r7, #0x8]
 8013ddc: f7f3 f96e    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xcd24
 8013de0: 4601         	mov	r1, r0
; 				     size / stream->src_size);
 8013de2: 697b         	ldr	r3, [r7, #0x14]
 8013de4: 689b         	ldr	r3, [r3, #0x8]
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8013de6: 6aba         	ldr	r2, [r7, #0x28]
 8013de8: fbb2 f3f3    	udiv	r3, r2, r3
 8013dec: 461a         	mov	r2, r3
 8013dee: 69b8         	ldr	r0, [r7, #0x18]
 8013df0: f7f2 f888    	bl	0x8005f04 <LL_DMA_SetDataLength> @ imm = #-0xdef0
 8013df4: e00c         	b	0x8013e10 <dma_stm32_reload+0xf4> @ imm = #0x18
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8013df6: 68b8         	ldr	r0, [r7, #0x8]
 8013df8: f7f3 f960    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xcd40
 8013dfc: 4601         	mov	r1, r0
; 				     size / stream->dst_size);
 8013dfe: 697b         	ldr	r3, [r7, #0x14]
 8013e00: 68db         	ldr	r3, [r3, #0xc]
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8013e02: 6aba         	ldr	r2, [r7, #0x28]
 8013e04: fbb2 f3f3    	udiv	r3, r2, r3
 8013e08: 461a         	mov	r2, r3
 8013e0a: 69b8         	ldr	r0, [r7, #0x18]
 8013e0c: f7f2 f87a    	bl	0x8005f04 <LL_DMA_SetDataLength> @ imm = #-0xdf0c
; 	stream->busy = true;
 8013e10: 697b         	ldr	r3, [r7, #0x14]
 8013e12: 2201         	movs	r2, #0x1
 8013e14: 719a         	strb	r2, [r3, #0x6]
; 	stm32_dma_enable_stream(dma, id);
 8013e16: 68b9         	ldr	r1, [r7, #0x8]
 8013e18: 69b8         	ldr	r0, [r7, #0x18]
 8013e1a: f000 ff5b    	bl	0x8014cd4 <stm32_dma_enable_stream> @ imm = #0xeb6
; 	return 0;
 8013e1e: 2300         	movs	r3, #0x0
; }
 8013e20: 4618         	mov	r0, r3
 8013e22: 3720         	adds	r7, #0x20
 8013e24: 46bd         	mov	sp, r7
 8013e26: bd80         	pop	{r7, pc}

08013e28 <dma_stm32_start>:
; {
 8013e28: b580         	push	{r7, lr}
 8013e2a: b086         	sub	sp, #0x18
 8013e2c: af00         	add	r7, sp, #0x0
 8013e2e: 6078         	str	r0, [r7, #0x4]
 8013e30: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8013e32: 687b         	ldr	r3, [r7, #0x4]
 8013e34: 685b         	ldr	r3, [r3, #0x4]
 8013e36: 617b         	str	r3, [r7, #0x14]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8013e38: 697b         	ldr	r3, [r7, #0x14]
 8013e3a: 691b         	ldr	r3, [r3, #0x10]
 8013e3c: 613b         	str	r3, [r7, #0x10]
; 	if (id >= config->max_streams) {
 8013e3e: 697b         	ldr	r3, [r7, #0x14]
 8013e40: 695b         	ldr	r3, [r3, #0x14]
 8013e42: 683a         	ldr	r2, [r7]
 8013e44: 429a         	cmp	r2, r3
 8013e46: d302         	blo	0x8013e4e <dma_stm32_start+0x26> @ imm = #0x4
; 		return -EINVAL;
 8013e48: f06f 0315    	mvn	r3, #0x15
 8013e4c: e01d         	b	0x8013e8a <dma_stm32_start+0x62> @ imm = #0x3a
; 	if (stm32_dma_is_enabled_stream(dma, id)) {
 8013e4e: 6839         	ldr	r1, [r7]
 8013e50: 6938         	ldr	r0, [r7, #0x10]
 8013e52: f000 ff50    	bl	0x8014cf6 <stm32_dma_is_enabled_stream> @ imm = #0xea0
 8013e56: 4603         	mov	r3, r0
 8013e58: 2b00         	cmp	r3, #0x0
 8013e5a: d001         	beq	0x8013e60 <dma_stm32_start+0x38> @ imm = #0x2
; 		return 0;
 8013e5c: 2300         	movs	r3, #0x0
 8013e5e: e014         	b	0x8013e8a <dma_stm32_start+0x62> @ imm = #0x28
; 	stream = &config->streams[id];
 8013e60: 697b         	ldr	r3, [r7, #0x14]
 8013e62: 6999         	ldr	r1, [r3, #0x18]
 8013e64: 683a         	ldr	r2, [r7]
 8013e66: 4613         	mov	r3, r2
 8013e68: 00db         	lsls	r3, r3, #0x3
 8013e6a: 1a9b         	subs	r3, r3, r2
 8013e6c: 009b         	lsls	r3, r3, #0x2
 8013e6e: 440b         	add	r3, r1
 8013e70: 60fb         	str	r3, [r7, #0xc]
; 	stream->busy = true;
 8013e72: 68fb         	ldr	r3, [r7, #0xc]
 8013e74: 2201         	movs	r2, #0x1
 8013e76: 719a         	strb	r2, [r3, #0x6]
; 	dma_stm32_clear_stream_irq(dev, id);
 8013e78: 6839         	ldr	r1, [r7]
 8013e7a: 6878         	ldr	r0, [r7, #0x4]
 8013e7c: f7ff ff0b    	bl	0x8013c96 <dma_stm32_clear_stream_irq> @ imm = #-0x1ea
; 	stm32_dma_enable_stream(dma, id);
 8013e80: 6839         	ldr	r1, [r7]
 8013e82: 6938         	ldr	r0, [r7, #0x10]
 8013e84: f000 ff26    	bl	0x8014cd4 <stm32_dma_enable_stream> @ imm = #0xe4c
; 	return 0;
 8013e88: 2300         	movs	r3, #0x0
; }
 8013e8a: 4618         	mov	r0, r3
 8013e8c: 3718         	adds	r7, #0x18
 8013e8e: 46bd         	mov	sp, r7
 8013e90: bd80         	pop	{r7, pc}

08013e92 <dma_stm32_stop>:
; {
 8013e92: b580         	push	{r7, lr}
 8013e94: b086         	sub	sp, #0x18
 8013e96: af00         	add	r7, sp, #0x0
 8013e98: 6078         	str	r0, [r7, #0x4]
 8013e9a: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8013e9c: 687b         	ldr	r3, [r7, #0x4]
 8013e9e: 685b         	ldr	r3, [r3, #0x4]
 8013ea0: 617b         	str	r3, [r7, #0x14]
; 	struct dma_stm32_stream *stream = &config->streams[id - STM32_DMA_STREAM_OFFSET];
 8013ea2: 697b         	ldr	r3, [r7, #0x14]
 8013ea4: 6999         	ldr	r1, [r3, #0x18]
 8013ea6: 683a         	ldr	r2, [r7]
 8013ea8: 4613         	mov	r3, r2
 8013eaa: 00db         	lsls	r3, r3, #0x3
 8013eac: 1a9b         	subs	r3, r3, r2
 8013eae: 009b         	lsls	r3, r3, #0x2
 8013eb0: 440b         	add	r3, r1
 8013eb2: 613b         	str	r3, [r7, #0x10]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8013eb4: 697b         	ldr	r3, [r7, #0x14]
 8013eb6: 691b         	ldr	r3, [r3, #0x10]
 8013eb8: 60fb         	str	r3, [r7, #0xc]
; 	if (id >= config->max_streams) {
 8013eba: 697b         	ldr	r3, [r7, #0x14]
 8013ebc: 695b         	ldr	r3, [r3, #0x14]
 8013ebe: 683a         	ldr	r2, [r7]
 8013ec0: 429a         	cmp	r2, r3
 8013ec2: d302         	blo	0x8013eca <dma_stm32_stop+0x38> @ imm = #0x4
; 		return -EINVAL;
 8013ec4: f06f 0315    	mvn	r3, #0x15
 8013ec8: e02c         	b	0x8013f24 <dma_stm32_stop+0x92> @ imm = #0x58
; 	if (stream->hal_override) {
 8013eca: 693b         	ldr	r3, [r7, #0x10]
 8013ecc: 795b         	ldrb	r3, [r3, #0x5]
 8013ece: 2b00         	cmp	r3, #0x0
 8013ed0: d004         	beq	0x8013edc <dma_stm32_stop+0x4a> @ imm = #0x8
; 		stream->busy = false;
 8013ed2: 693b         	ldr	r3, [r7, #0x10]
 8013ed4: 2200         	movs	r2, #0x0
 8013ed6: 719a         	strb	r2, [r3, #0x6]
; 		return 0;
 8013ed8: 2300         	movs	r3, #0x0
 8013eda: e023         	b	0x8013f24 <dma_stm32_stop+0x92> @ imm = #0x46
; 	if (!stm32_dma_is_enabled_stream(dma, id)) {
 8013edc: 6839         	ldr	r1, [r7]
 8013ede: 68f8         	ldr	r0, [r7, #0xc]
 8013ee0: f000 ff09    	bl	0x8014cf6 <stm32_dma_is_enabled_stream> @ imm = #0xe12
 8013ee4: 4603         	mov	r3, r0
 8013ee6: f083 0301    	eor	r3, r3, #0x1
 8013eea: b2db         	uxtb	r3, r3
 8013eec: 2b00         	cmp	r3, #0x0
 8013eee: d001         	beq	0x8013ef4 <dma_stm32_stop+0x62> @ imm = #0x2
; 		return 0;
 8013ef0: 2300         	movs	r3, #0x0
 8013ef2: e017         	b	0x8013f24 <dma_stm32_stop+0x92> @ imm = #0x2e
; 	LL_DMA_DisableIT_TC(dma, dma_stm32_id_to_stream(id));
 8013ef4: 6838         	ldr	r0, [r7]
 8013ef6: f7f3 f8e1    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xce3e
 8013efa: 4603         	mov	r3, r0
 8013efc: 4619         	mov	r1, r3
 8013efe: 68f8         	ldr	r0, [r7, #0xc]
 8013f00: f7f2 f8fe    	bl	0x8006100 <LL_DMA_DisableIT_TC> @ imm = #-0xde04
; 	stm32_dma_disable_fifo_irq(dma, id);
 8013f04: 6839         	ldr	r1, [r7]
 8013f06: 68f8         	ldr	r0, [r7, #0xc]
 8013f08: f000 ff2a    	bl	0x8014d60 <stm32_dma_disable_fifo_irq> @ imm = #0xe54
; 	dma_stm32_clear_stream_irq(dev, id);
 8013f0c: 6839         	ldr	r1, [r7]
 8013f0e: 6878         	ldr	r0, [r7, #0x4]
 8013f10: f7ff fec1    	bl	0x8013c96 <dma_stm32_clear_stream_irq> @ imm = #-0x27e
; 	dma_stm32_disable_stream(dma, id);
 8013f14: 6839         	ldr	r1, [r7]
 8013f16: 68f8         	ldr	r0, [r7, #0xc]
 8013f18: f7ff fed8    	bl	0x8013ccc <dma_stm32_disable_stream> @ imm = #-0x250
; 	stream->busy = false;
 8013f1c: 693b         	ldr	r3, [r7, #0x10]
 8013f1e: 2200         	movs	r2, #0x0
 8013f20: 719a         	strb	r2, [r3, #0x6]
; 	return 0;
 8013f22: 2300         	movs	r3, #0x0
; }
 8013f24: 4618         	mov	r0, r3
 8013f26: 3718         	adds	r7, #0x18
 8013f28: 46bd         	mov	sp, r7
 8013f2a: bd80         	pop	{r7, pc}

08013f2c <dma_stm32_get_status>:
; {
 8013f2c: b580         	push	{r7, lr}
 8013f2e: b088         	sub	sp, #0x20
 8013f30: af00         	add	r7, sp, #0x0
 8013f32: 60f8         	str	r0, [r7, #0xc]
 8013f34: 60b9         	str	r1, [r7, #0x8]
 8013f36: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_stm32_config *config = dev->config;
 8013f38: 68fb         	ldr	r3, [r7, #0xc]
 8013f3a: 685b         	ldr	r3, [r3, #0x4]
 8013f3c: 61fb         	str	r3, [r7, #0x1c]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8013f3e: 69fb         	ldr	r3, [r7, #0x1c]
 8013f40: 691b         	ldr	r3, [r3, #0x10]
 8013f42: 61bb         	str	r3, [r7, #0x18]
; 	if (id >= config->max_streams) {
 8013f44: 69fb         	ldr	r3, [r7, #0x1c]
 8013f46: 695b         	ldr	r3, [r3, #0x14]
 8013f48: 68ba         	ldr	r2, [r7, #0x8]
 8013f4a: 429a         	cmp	r2, r3
 8013f4c: d302         	blo	0x8013f54 <dma_stm32_get_status+0x28> @ imm = #0x4
; 		return -EINVAL;
 8013f4e: f06f 0315    	mvn	r3, #0x15
 8013f52: e01e         	b	0x8013f92 <dma_stm32_get_status+0x66> @ imm = #0x3c
; 	stream = &config->streams[id];
 8013f54: 69fb         	ldr	r3, [r7, #0x1c]
 8013f56: 6999         	ldr	r1, [r3, #0x18]
 8013f58: 68ba         	ldr	r2, [r7, #0x8]
 8013f5a: 4613         	mov	r3, r2
 8013f5c: 00db         	lsls	r3, r3, #0x3
 8013f5e: 1a9b         	subs	r3, r3, r2
 8013f60: 009b         	lsls	r3, r3, #0x2
 8013f62: 440b         	add	r3, r1
 8013f64: 617b         	str	r3, [r7, #0x14]
; 	stat->pending_length = LL_DMA_GetDataLength(dma, dma_stm32_id_to_stream(id));
 8013f66: 68b8         	ldr	r0, [r7, #0x8]
 8013f68: f7f3 f8a8    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xceb0
 8013f6c: 4603         	mov	r3, r0
 8013f6e: 4619         	mov	r1, r3
 8013f70: 69b8         	ldr	r0, [r7, #0x18]
 8013f72: f7f1 ffe9    	bl	0x8005f48 <LL_DMA_GetDataLength> @ imm = #-0xe02e
 8013f76: 4602         	mov	r2, r0
 8013f78: 687b         	ldr	r3, [r7, #0x4]
 8013f7a: 605a         	str	r2, [r3, #0x4]
; 	stat->dir = stream->direction;
 8013f7c: 697b         	ldr	r3, [r7, #0x14]
 8013f7e: 681b         	ldr	r3, [r3]
 8013f80: b2da         	uxtb	r2, r3
 8013f82: 687b         	ldr	r3, [r7, #0x4]
 8013f84: 705a         	strb	r2, [r3, #0x1]
; 	stat->busy = stream->busy;
 8013f86: 697b         	ldr	r3, [r7, #0x14]
 8013f88: 799b         	ldrb	r3, [r3, #0x6]
 8013f8a: b2da         	uxtb	r2, r3
 8013f8c: 687b         	ldr	r3, [r7, #0x4]
 8013f8e: 701a         	strb	r2, [r3]
; 	return 0;
 8013f90: 2300         	movs	r3, #0x0
; }
 8013f92: 4618         	mov	r0, r3
 8013f94: 3720         	adds	r7, #0x20
 8013f96: 46bd         	mov	sp, r7
 8013f98: bd80         	pop	{r7, pc}

08013f9a <dma_stm32_irq_0_0>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 0);
 8013f9a: b580         	push	{r7, lr}
 8013f9c: b082         	sub	sp, #0x8
 8013f9e: af00         	add	r7, sp, #0x0
 8013fa0: 6078         	str	r0, [r7, #0x4]
 8013fa2: 2100         	movs	r1, #0x0
 8013fa4: 6878         	ldr	r0, [r7, #0x4]
 8013fa6: f7f2 f8e7    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xde32
 8013faa: 3708         	adds	r7, #0x8
 8013fac: 46bd         	mov	sp, r7
 8013fae: bd80         	pop	{r7, pc}

08013fb0 <dma_stm32_irq_0_1>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 1);
 8013fb0: b580         	push	{r7, lr}
 8013fb2: b082         	sub	sp, #0x8
 8013fb4: af00         	add	r7, sp, #0x0
 8013fb6: 6078         	str	r0, [r7, #0x4]
 8013fb8: 2101         	movs	r1, #0x1
 8013fba: 6878         	ldr	r0, [r7, #0x4]
 8013fbc: f7f2 f8dc    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xde48
 8013fc0: 3708         	adds	r7, #0x8
 8013fc2: 46bd         	mov	sp, r7
 8013fc4: bd80         	pop	{r7, pc}

08013fc6 <dma_stm32_irq_0_2>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 2);
 8013fc6: b580         	push	{r7, lr}
 8013fc8: b082         	sub	sp, #0x8
 8013fca: af00         	add	r7, sp, #0x0
 8013fcc: 6078         	str	r0, [r7, #0x4]
 8013fce: 2102         	movs	r1, #0x2
 8013fd0: 6878         	ldr	r0, [r7, #0x4]
 8013fd2: f7f2 f8d1    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xde5e
 8013fd6: 3708         	adds	r7, #0x8
 8013fd8: 46bd         	mov	sp, r7
 8013fda: bd80         	pop	{r7, pc}

08013fdc <dma_stm32_irq_0_3>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 3);
 8013fdc: b580         	push	{r7, lr}
 8013fde: b082         	sub	sp, #0x8
 8013fe0: af00         	add	r7, sp, #0x0
 8013fe2: 6078         	str	r0, [r7, #0x4]
 8013fe4: 2103         	movs	r1, #0x3
 8013fe6: 6878         	ldr	r0, [r7, #0x4]
 8013fe8: f7f2 f8c6    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xde74
 8013fec: 3708         	adds	r7, #0x8
 8013fee: 46bd         	mov	sp, r7
 8013ff0: bd80         	pop	{r7, pc}

08013ff2 <dma_stm32_irq_0_4>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 4);
 8013ff2: b580         	push	{r7, lr}
 8013ff4: b082         	sub	sp, #0x8
 8013ff6: af00         	add	r7, sp, #0x0
 8013ff8: 6078         	str	r0, [r7, #0x4]
 8013ffa: 2104         	movs	r1, #0x4
 8013ffc: 6878         	ldr	r0, [r7, #0x4]
 8013ffe: f7f2 f8bb    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xde8a
 8014002: 3708         	adds	r7, #0x8
 8014004: 46bd         	mov	sp, r7
 8014006: bd80         	pop	{r7, pc}

08014008 <dma_stm32_irq_0_5>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 5);
 8014008: b580         	push	{r7, lr}
 801400a: b082         	sub	sp, #0x8
 801400c: af00         	add	r7, sp, #0x0
 801400e: 6078         	str	r0, [r7, #0x4]
 8014010: 2105         	movs	r1, #0x5
 8014012: 6878         	ldr	r0, [r7, #0x4]
 8014014: f7f2 f8b0    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xdea0
 8014018: 3708         	adds	r7, #0x8
 801401a: 46bd         	mov	sp, r7
 801401c: bd80         	pop	{r7, pc}

0801401e <dma_stm32_irq_0_6>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 6);
 801401e: b580         	push	{r7, lr}
 8014020: b082         	sub	sp, #0x8
 8014022: af00         	add	r7, sp, #0x0
 8014024: 6078         	str	r0, [r7, #0x4]
 8014026: 2106         	movs	r1, #0x6
 8014028: 6878         	ldr	r0, [r7, #0x4]
 801402a: f7f2 f8a5    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xdeb6
 801402e: 3708         	adds	r7, #0x8
 8014030: 46bd         	mov	sp, r7
 8014032: bd80         	pop	{r7, pc}

08014034 <dma_stm32_irq_0_7>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 7);
 8014034: b580         	push	{r7, lr}
 8014036: b082         	sub	sp, #0x8
 8014038: af00         	add	r7, sp, #0x0
 801403a: 6078         	str	r0, [r7, #0x4]
 801403c: 2107         	movs	r1, #0x7
 801403e: 6878         	ldr	r0, [r7, #0x4]
 8014040: f7f2 f89a    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xdecc
 8014044: 3708         	adds	r7, #0x8
 8014046: 46bd         	mov	sp, r7
 8014048: bd80         	pop	{r7, pc}

0801404a <dma_stm32_config_irq_0>:
; {
 801404a: b580         	push	{r7, lr}
 801404c: b082         	sub	sp, #0x8
 801404e: af00         	add	r7, sp, #0x0
 8014050: 6078         	str	r0, [r7, #0x4]
; 	LISTIFY(
 8014052: 2200         	movs	r2, #0x0
 8014054: 2100         	movs	r1, #0x0
 8014056: 200b         	movs	r0, #0xb
 8014058: f7fe fd5e    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x1544
 801405c: 200b         	movs	r0, #0xb
 801405e: f7fe fd4e    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x1564
 8014062: 2200         	movs	r2, #0x0
 8014064: 2100         	movs	r1, #0x0
 8014066: 200c         	movs	r0, #0xc
 8014068: f7fe fd56    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x1554
 801406c: 200c         	movs	r0, #0xc
 801406e: f7fe fd46    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x1574
 8014072: 2200         	movs	r2, #0x0
 8014074: 2100         	movs	r1, #0x0
 8014076: 200d         	movs	r0, #0xd
 8014078: f7fe fd4e    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x1564
 801407c: 200d         	movs	r0, #0xd
 801407e: f7fe fd3e    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x1584
 8014082: 2200         	movs	r2, #0x0
 8014084: 2100         	movs	r1, #0x0
 8014086: 200e         	movs	r0, #0xe
 8014088: f7fe fd46    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x1574
 801408c: 200e         	movs	r0, #0xe
 801408e: f7fe fd36    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x1594
 8014092: 2200         	movs	r2, #0x0
 8014094: 2100         	movs	r1, #0x0
 8014096: 200f         	movs	r0, #0xf
 8014098: f7fe fd3e    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x1584
 801409c: 200f         	movs	r0, #0xf
 801409e: f7fe fd2e    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x15a4
 80140a2: 2200         	movs	r2, #0x0
 80140a4: 2100         	movs	r1, #0x0
 80140a6: 2010         	movs	r0, #0x10
 80140a8: f7fe fd36    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x1594
 80140ac: 2010         	movs	r0, #0x10
 80140ae: f7fe fd26    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x15b4
 80140b2: 2200         	movs	r2, #0x0
 80140b4: 2100         	movs	r1, #0x0
 80140b6: 2011         	movs	r0, #0x11
 80140b8: f7fe fd2e    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x15a4
 80140bc: 2011         	movs	r0, #0x11
 80140be: f7fe fd1e    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x15c4
 80140c2: 2200         	movs	r2, #0x0
 80140c4: 2100         	movs	r1, #0x0
 80140c6: 202f         	movs	r0, #0x2f
 80140c8: f7fe fd26    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x15b4
 80140cc: 202f         	movs	r0, #0x2f
 80140ce: f7fe fd16    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x15d4
; }
 80140d2: bf00         	nop
 80140d4: 3708         	adds	r7, #0x8
 80140d6: 46bd         	mov	sp, r7
 80140d8: bd80         	pop	{r7, pc}

080140da <dma_stm32_irq_1_0>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 0);
 80140da: b580         	push	{r7, lr}
 80140dc: b082         	sub	sp, #0x8
 80140de: af00         	add	r7, sp, #0x0
 80140e0: 6078         	str	r0, [r7, #0x4]
 80140e2: 2100         	movs	r1, #0x0
 80140e4: 6878         	ldr	r0, [r7, #0x4]
 80140e6: f7f2 f847    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xdf72
 80140ea: 3708         	adds	r7, #0x8
 80140ec: 46bd         	mov	sp, r7
 80140ee: bd80         	pop	{r7, pc}

080140f0 <dma_stm32_irq_1_1>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 1);
 80140f0: b580         	push	{r7, lr}
 80140f2: b082         	sub	sp, #0x8
 80140f4: af00         	add	r7, sp, #0x0
 80140f6: 6078         	str	r0, [r7, #0x4]
 80140f8: 2101         	movs	r1, #0x1
 80140fa: 6878         	ldr	r0, [r7, #0x4]
 80140fc: f7f2 f83c    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xdf88
 8014100: 3708         	adds	r7, #0x8
 8014102: 46bd         	mov	sp, r7
 8014104: bd80         	pop	{r7, pc}

08014106 <dma_stm32_irq_1_2>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 2);
 8014106: b580         	push	{r7, lr}
 8014108: b082         	sub	sp, #0x8
 801410a: af00         	add	r7, sp, #0x0
 801410c: 6078         	str	r0, [r7, #0x4]
 801410e: 2102         	movs	r1, #0x2
 8014110: 6878         	ldr	r0, [r7, #0x4]
 8014112: f7f2 f831    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xdf9e
 8014116: 3708         	adds	r7, #0x8
 8014118: 46bd         	mov	sp, r7
 801411a: bd80         	pop	{r7, pc}

0801411c <dma_stm32_irq_1_3>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 3);
 801411c: b580         	push	{r7, lr}
 801411e: b082         	sub	sp, #0x8
 8014120: af00         	add	r7, sp, #0x0
 8014122: 6078         	str	r0, [r7, #0x4]
 8014124: 2103         	movs	r1, #0x3
 8014126: 6878         	ldr	r0, [r7, #0x4]
 8014128: f7f2 f826    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xdfb4
 801412c: 3708         	adds	r7, #0x8
 801412e: 46bd         	mov	sp, r7
 8014130: bd80         	pop	{r7, pc}

08014132 <dma_stm32_irq_1_4>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 4);
 8014132: b580         	push	{r7, lr}
 8014134: b082         	sub	sp, #0x8
 8014136: af00         	add	r7, sp, #0x0
 8014138: 6078         	str	r0, [r7, #0x4]
 801413a: 2104         	movs	r1, #0x4
 801413c: 6878         	ldr	r0, [r7, #0x4]
 801413e: f7f2 f81b    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xdfca
 8014142: 3708         	adds	r7, #0x8
 8014144: 46bd         	mov	sp, r7
 8014146: bd80         	pop	{r7, pc}

08014148 <dma_stm32_irq_1_5>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 5);
 8014148: b580         	push	{r7, lr}
 801414a: b082         	sub	sp, #0x8
 801414c: af00         	add	r7, sp, #0x0
 801414e: 6078         	str	r0, [r7, #0x4]
 8014150: 2105         	movs	r1, #0x5
 8014152: 6878         	ldr	r0, [r7, #0x4]
 8014154: f7f2 f810    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xdfe0
 8014158: 3708         	adds	r7, #0x8
 801415a: 46bd         	mov	sp, r7
 801415c: bd80         	pop	{r7, pc}

0801415e <dma_stm32_irq_1_6>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 6);
 801415e: b580         	push	{r7, lr}
 8014160: b082         	sub	sp, #0x8
 8014162: af00         	add	r7, sp, #0x0
 8014164: 6078         	str	r0, [r7, #0x4]
 8014166: 2106         	movs	r1, #0x6
 8014168: 6878         	ldr	r0, [r7, #0x4]
 801416a: f7f2 f805    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xdff6
 801416e: 3708         	adds	r7, #0x8
 8014170: 46bd         	mov	sp, r7
 8014172: bd80         	pop	{r7, pc}

08014174 <dma_stm32_irq_1_7>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 7);
 8014174: b580         	push	{r7, lr}
 8014176: b082         	sub	sp, #0x8
 8014178: af00         	add	r7, sp, #0x0
 801417a: 6078         	str	r0, [r7, #0x4]
 801417c: 2107         	movs	r1, #0x7
 801417e: 6878         	ldr	r0, [r7, #0x4]
 8014180: f7f1 fffa    	bl	0x8006178 <dma_stm32_irq_handler> @ imm = #-0xe00c
 8014184: 3708         	adds	r7, #0x8
 8014186: 46bd         	mov	sp, r7
 8014188: bd80         	pop	{r7, pc}

0801418a <dma_stm32_config_irq_1>:
; {
 801418a: b580         	push	{r7, lr}
 801418c: b082         	sub	sp, #0x8
 801418e: af00         	add	r7, sp, #0x0
 8014190: 6078         	str	r0, [r7, #0x4]
; 	LISTIFY(
 8014192: 2200         	movs	r2, #0x0
 8014194: 2100         	movs	r1, #0x0
 8014196: 2038         	movs	r0, #0x38
 8014198: f7fe fcbe    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x1684
 801419c: 2038         	movs	r0, #0x38
 801419e: f7fe fcae    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x16a4
 80141a2: 2200         	movs	r2, #0x0
 80141a4: 2100         	movs	r1, #0x0
 80141a6: 2039         	movs	r0, #0x39
 80141a8: f7fe fcb6    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x1694
 80141ac: 2039         	movs	r0, #0x39
 80141ae: f7fe fca6    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x16b4
 80141b2: 2200         	movs	r2, #0x0
 80141b4: 2100         	movs	r1, #0x0
 80141b6: 203a         	movs	r0, #0x3a
 80141b8: f7fe fcae    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x16a4
 80141bc: 203a         	movs	r0, #0x3a
 80141be: f7fe fc9e    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x16c4
 80141c2: 2200         	movs	r2, #0x0
 80141c4: 2100         	movs	r1, #0x0
 80141c6: 203b         	movs	r0, #0x3b
 80141c8: f7fe fca6    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x16b4
 80141cc: 203b         	movs	r0, #0x3b
 80141ce: f7fe fc96    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x16d4
 80141d2: 2200         	movs	r2, #0x0
 80141d4: 2100         	movs	r1, #0x0
 80141d6: 203c         	movs	r0, #0x3c
 80141d8: f7fe fc9e    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x16c4
 80141dc: 203c         	movs	r0, #0x3c
 80141de: f7fe fc8e    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x16e4
 80141e2: 2200         	movs	r2, #0x0
 80141e4: 2100         	movs	r1, #0x0
 80141e6: 2044         	movs	r0, #0x44
 80141e8: f7fe fc96    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x16d4
 80141ec: 2044         	movs	r0, #0x44
 80141ee: f7fe fc86    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x16f4
 80141f2: 2200         	movs	r2, #0x0
 80141f4: 2100         	movs	r1, #0x0
 80141f6: 2045         	movs	r0, #0x45
 80141f8: f7fe fc8e    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x16e4
 80141fc: 2045         	movs	r0, #0x45
 80141fe: f7fe fc7e    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x1704
 8014202: 2200         	movs	r2, #0x0
 8014204: 2100         	movs	r1, #0x0
 8014206: 2046         	movs	r0, #0x46
 8014208: f7fe fc86    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x16f4
 801420c: 2046         	movs	r0, #0x46
 801420e: f7fe fc76    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x1714
; }
 8014212: bf00         	nop
 8014214: 3708         	adds	r7, #0x8
 8014216: 46bd         	mov	sp, r7
 8014218: bd80         	pop	{r7, pc}

0801421a <LL_DMA_IsActiveFlag_HT0>:
; {
 801421a: b480         	push	{r7}
 801421c: b083         	sub	sp, #0xc
 801421e: af00         	add	r7, sp, #0x0
 8014220: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF0)==(DMA_LISR_HTIF0));
 8014222: 687b         	ldr	r3, [r7, #0x4]
 8014224: 681b         	ldr	r3, [r3]
 8014226: f003 0310    	and	r3, r3, #0x10
 801422a: 2b10         	cmp	r3, #0x10
 801422c: bf0c         	ite	eq
 801422e: 2301         	moveq	r3, #0x1
 8014230: 2300         	movne	r3, #0x0
 8014232: b2db         	uxtb	r3, r3
; }
 8014234: 4618         	mov	r0, r3
 8014236: 370c         	adds	r7, #0xc
 8014238: 46bd         	mov	sp, r7
 801423a: bc80         	pop	{r7}
 801423c: 4770         	bx	lr

0801423e <LL_DMA_IsActiveFlag_HT1>:
; {
 801423e: b480         	push	{r7}
 8014240: b083         	sub	sp, #0xc
 8014242: af00         	add	r7, sp, #0x0
 8014244: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF1)==(DMA_LISR_HTIF1));
 8014246: 687b         	ldr	r3, [r7, #0x4]
 8014248: 681b         	ldr	r3, [r3]
 801424a: f403 6380    	and	r3, r3, #0x400
 801424e: f5b3 6f80    	cmp.w	r3, #0x400
 8014252: bf0c         	ite	eq
 8014254: 2301         	moveq	r3, #0x1
 8014256: 2300         	movne	r3, #0x0
 8014258: b2db         	uxtb	r3, r3
; }
 801425a: 4618         	mov	r0, r3
 801425c: 370c         	adds	r7, #0xc
 801425e: 46bd         	mov	sp, r7
 8014260: bc80         	pop	{r7}
 8014262: 4770         	bx	lr

08014264 <LL_DMA_IsActiveFlag_HT2>:
; {
 8014264: b480         	push	{r7}
 8014266: b083         	sub	sp, #0xc
 8014268: af00         	add	r7, sp, #0x0
 801426a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF2)==(DMA_LISR_HTIF2));
 801426c: 687b         	ldr	r3, [r7, #0x4]
 801426e: 681b         	ldr	r3, [r3]
 8014270: f403 1380    	and	r3, r3, #0x100000
 8014274: f5b3 1f80    	cmp.w	r3, #0x100000
 8014278: bf0c         	ite	eq
 801427a: 2301         	moveq	r3, #0x1
 801427c: 2300         	movne	r3, #0x0
 801427e: b2db         	uxtb	r3, r3
; }
 8014280: 4618         	mov	r0, r3
 8014282: 370c         	adds	r7, #0xc
 8014284: 46bd         	mov	sp, r7
 8014286: bc80         	pop	{r7}
 8014288: 4770         	bx	lr

0801428a <LL_DMA_IsActiveFlag_HT3>:
; {
 801428a: b480         	push	{r7}
 801428c: b083         	sub	sp, #0xc
 801428e: af00         	add	r7, sp, #0x0
 8014290: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF3)==(DMA_LISR_HTIF3));
 8014292: 687b         	ldr	r3, [r7, #0x4]
 8014294: 681b         	ldr	r3, [r3]
 8014296: f003 6380    	and	r3, r3, #0x4000000
 801429a: f1b3 6f80    	cmp.w	r3, #0x4000000
 801429e: bf0c         	ite	eq
 80142a0: 2301         	moveq	r3, #0x1
 80142a2: 2300         	movne	r3, #0x0
 80142a4: b2db         	uxtb	r3, r3
; }
 80142a6: 4618         	mov	r0, r3
 80142a8: 370c         	adds	r7, #0xc
 80142aa: 46bd         	mov	sp, r7
 80142ac: bc80         	pop	{r7}
 80142ae: 4770         	bx	lr

080142b0 <LL_DMA_IsActiveFlag_HT4>:
; {
 80142b0: b480         	push	{r7}
 80142b2: b083         	sub	sp, #0xc
 80142b4: af00         	add	r7, sp, #0x0
 80142b6: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF4)==(DMA_HISR_HTIF4));
 80142b8: 687b         	ldr	r3, [r7, #0x4]
 80142ba: 685b         	ldr	r3, [r3, #0x4]
 80142bc: f003 0310    	and	r3, r3, #0x10
 80142c0: 2b10         	cmp	r3, #0x10
 80142c2: bf0c         	ite	eq
 80142c4: 2301         	moveq	r3, #0x1
 80142c6: 2300         	movne	r3, #0x0
 80142c8: b2db         	uxtb	r3, r3
; }
 80142ca: 4618         	mov	r0, r3
 80142cc: 370c         	adds	r7, #0xc
 80142ce: 46bd         	mov	sp, r7
 80142d0: bc80         	pop	{r7}
 80142d2: 4770         	bx	lr

080142d4 <LL_DMA_IsActiveFlag_HT5>:
; {
 80142d4: b480         	push	{r7}
 80142d6: b083         	sub	sp, #0xc
 80142d8: af00         	add	r7, sp, #0x0
 80142da: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF5)==(DMA_HISR_HTIF5));
 80142dc: 687b         	ldr	r3, [r7, #0x4]
 80142de: 685b         	ldr	r3, [r3, #0x4]
 80142e0: f403 6380    	and	r3, r3, #0x400
 80142e4: f5b3 6f80    	cmp.w	r3, #0x400
 80142e8: bf0c         	ite	eq
 80142ea: 2301         	moveq	r3, #0x1
 80142ec: 2300         	movne	r3, #0x0
 80142ee: b2db         	uxtb	r3, r3
; }
 80142f0: 4618         	mov	r0, r3
 80142f2: 370c         	adds	r7, #0xc
 80142f4: 46bd         	mov	sp, r7
 80142f6: bc80         	pop	{r7}
 80142f8: 4770         	bx	lr

080142fa <LL_DMA_IsActiveFlag_HT6>:
; {
 80142fa: b480         	push	{r7}
 80142fc: b083         	sub	sp, #0xc
 80142fe: af00         	add	r7, sp, #0x0
 8014300: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF6)==(DMA_HISR_HTIF6));
 8014302: 687b         	ldr	r3, [r7, #0x4]
 8014304: 685b         	ldr	r3, [r3, #0x4]
 8014306: f403 1380    	and	r3, r3, #0x100000
 801430a: f5b3 1f80    	cmp.w	r3, #0x100000
 801430e: bf0c         	ite	eq
 8014310: 2301         	moveq	r3, #0x1
 8014312: 2300         	movne	r3, #0x0
 8014314: b2db         	uxtb	r3, r3
; }
 8014316: 4618         	mov	r0, r3
 8014318: 370c         	adds	r7, #0xc
 801431a: 46bd         	mov	sp, r7
 801431c: bc80         	pop	{r7}
 801431e: 4770         	bx	lr

08014320 <LL_DMA_IsActiveFlag_HT7>:
; {
 8014320: b480         	push	{r7}
 8014322: b083         	sub	sp, #0xc
 8014324: af00         	add	r7, sp, #0x0
 8014326: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF7)==(DMA_HISR_HTIF7));
 8014328: 687b         	ldr	r3, [r7, #0x4]
 801432a: 685b         	ldr	r3, [r3, #0x4]
 801432c: f003 6380    	and	r3, r3, #0x4000000
 8014330: f1b3 6f80    	cmp.w	r3, #0x4000000
 8014334: bf0c         	ite	eq
 8014336: 2301         	moveq	r3, #0x1
 8014338: 2300         	movne	r3, #0x0
 801433a: b2db         	uxtb	r3, r3
; }
 801433c: 4618         	mov	r0, r3
 801433e: 370c         	adds	r7, #0xc
 8014340: 46bd         	mov	sp, r7
 8014342: bc80         	pop	{r7}
 8014344: 4770         	bx	lr

08014346 <LL_DMA_IsActiveFlag_TC0>:
; {
 8014346: b480         	push	{r7}
 8014348: b083         	sub	sp, #0xc
 801434a: af00         	add	r7, sp, #0x0
 801434c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF0)==(DMA_LISR_TCIF0));
 801434e: 687b         	ldr	r3, [r7, #0x4]
 8014350: 681b         	ldr	r3, [r3]
 8014352: f003 0320    	and	r3, r3, #0x20
 8014356: 2b20         	cmp	r3, #0x20
 8014358: bf0c         	ite	eq
 801435a: 2301         	moveq	r3, #0x1
 801435c: 2300         	movne	r3, #0x0
 801435e: b2db         	uxtb	r3, r3
; }
 8014360: 4618         	mov	r0, r3
 8014362: 370c         	adds	r7, #0xc
 8014364: 46bd         	mov	sp, r7
 8014366: bc80         	pop	{r7}
 8014368: 4770         	bx	lr

0801436a <LL_DMA_IsActiveFlag_TC1>:
; {
 801436a: b480         	push	{r7}
 801436c: b083         	sub	sp, #0xc
 801436e: af00         	add	r7, sp, #0x0
 8014370: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF1)==(DMA_LISR_TCIF1));
 8014372: 687b         	ldr	r3, [r7, #0x4]
 8014374: 681b         	ldr	r3, [r3]
 8014376: f403 6300    	and	r3, r3, #0x800
 801437a: f5b3 6f00    	cmp.w	r3, #0x800
 801437e: bf0c         	ite	eq
 8014380: 2301         	moveq	r3, #0x1
 8014382: 2300         	movne	r3, #0x0
 8014384: b2db         	uxtb	r3, r3
; }
 8014386: 4618         	mov	r0, r3
 8014388: 370c         	adds	r7, #0xc
 801438a: 46bd         	mov	sp, r7
 801438c: bc80         	pop	{r7}
 801438e: 4770         	bx	lr

08014390 <LL_DMA_IsActiveFlag_TC2>:
; {
 8014390: b480         	push	{r7}
 8014392: b083         	sub	sp, #0xc
 8014394: af00         	add	r7, sp, #0x0
 8014396: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF2)==(DMA_LISR_TCIF2));
 8014398: 687b         	ldr	r3, [r7, #0x4]
 801439a: 681b         	ldr	r3, [r3]
 801439c: f403 1300    	and	r3, r3, #0x200000
 80143a0: f5b3 1f00    	cmp.w	r3, #0x200000
 80143a4: bf0c         	ite	eq
 80143a6: 2301         	moveq	r3, #0x1
 80143a8: 2300         	movne	r3, #0x0
 80143aa: b2db         	uxtb	r3, r3
; }
 80143ac: 4618         	mov	r0, r3
 80143ae: 370c         	adds	r7, #0xc
 80143b0: 46bd         	mov	sp, r7
 80143b2: bc80         	pop	{r7}
 80143b4: 4770         	bx	lr

080143b6 <LL_DMA_IsActiveFlag_TC3>:
; {
 80143b6: b480         	push	{r7}
 80143b8: b083         	sub	sp, #0xc
 80143ba: af00         	add	r7, sp, #0x0
 80143bc: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF3)==(DMA_LISR_TCIF3));
 80143be: 687b         	ldr	r3, [r7, #0x4]
 80143c0: 681b         	ldr	r3, [r3]
 80143c2: f003 6300    	and	r3, r3, #0x8000000
 80143c6: f1b3 6f00    	cmp.w	r3, #0x8000000
 80143ca: bf0c         	ite	eq
 80143cc: 2301         	moveq	r3, #0x1
 80143ce: 2300         	movne	r3, #0x0
 80143d0: b2db         	uxtb	r3, r3
; }
 80143d2: 4618         	mov	r0, r3
 80143d4: 370c         	adds	r7, #0xc
 80143d6: 46bd         	mov	sp, r7
 80143d8: bc80         	pop	{r7}
 80143da: 4770         	bx	lr

080143dc <LL_DMA_IsActiveFlag_TC4>:
; {
 80143dc: b480         	push	{r7}
 80143de: b083         	sub	sp, #0xc
 80143e0: af00         	add	r7, sp, #0x0
 80143e2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF4)==(DMA_HISR_TCIF4));
 80143e4: 687b         	ldr	r3, [r7, #0x4]
 80143e6: 685b         	ldr	r3, [r3, #0x4]
 80143e8: f003 0320    	and	r3, r3, #0x20
 80143ec: 2b20         	cmp	r3, #0x20
 80143ee: bf0c         	ite	eq
 80143f0: 2301         	moveq	r3, #0x1
 80143f2: 2300         	movne	r3, #0x0
 80143f4: b2db         	uxtb	r3, r3
; }
 80143f6: 4618         	mov	r0, r3
 80143f8: 370c         	adds	r7, #0xc
 80143fa: 46bd         	mov	sp, r7
 80143fc: bc80         	pop	{r7}
 80143fe: 4770         	bx	lr

08014400 <LL_DMA_IsActiveFlag_TC5>:
; {
 8014400: b480         	push	{r7}
 8014402: b083         	sub	sp, #0xc
 8014404: af00         	add	r7, sp, #0x0
 8014406: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF5)==(DMA_HISR_TCIF5));
 8014408: 687b         	ldr	r3, [r7, #0x4]
 801440a: 685b         	ldr	r3, [r3, #0x4]
 801440c: f403 6300    	and	r3, r3, #0x800
 8014410: f5b3 6f00    	cmp.w	r3, #0x800
 8014414: bf0c         	ite	eq
 8014416: 2301         	moveq	r3, #0x1
 8014418: 2300         	movne	r3, #0x0
 801441a: b2db         	uxtb	r3, r3
; }
 801441c: 4618         	mov	r0, r3
 801441e: 370c         	adds	r7, #0xc
 8014420: 46bd         	mov	sp, r7
 8014422: bc80         	pop	{r7}
 8014424: 4770         	bx	lr

08014426 <LL_DMA_IsActiveFlag_TC6>:
; {
 8014426: b480         	push	{r7}
 8014428: b083         	sub	sp, #0xc
 801442a: af00         	add	r7, sp, #0x0
 801442c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF6)==(DMA_HISR_TCIF6));
 801442e: 687b         	ldr	r3, [r7, #0x4]
 8014430: 685b         	ldr	r3, [r3, #0x4]
 8014432: f403 1300    	and	r3, r3, #0x200000
 8014436: f5b3 1f00    	cmp.w	r3, #0x200000
 801443a: bf0c         	ite	eq
 801443c: 2301         	moveq	r3, #0x1
 801443e: 2300         	movne	r3, #0x0
 8014440: b2db         	uxtb	r3, r3
; }
 8014442: 4618         	mov	r0, r3
 8014444: 370c         	adds	r7, #0xc
 8014446: 46bd         	mov	sp, r7
 8014448: bc80         	pop	{r7}
 801444a: 4770         	bx	lr

0801444c <LL_DMA_IsActiveFlag_TC7>:
; {
 801444c: b480         	push	{r7}
 801444e: b083         	sub	sp, #0xc
 8014450: af00         	add	r7, sp, #0x0
 8014452: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF7)==(DMA_HISR_TCIF7));
 8014454: 687b         	ldr	r3, [r7, #0x4]
 8014456: 685b         	ldr	r3, [r3, #0x4]
 8014458: f003 6300    	and	r3, r3, #0x8000000
 801445c: f1b3 6f00    	cmp.w	r3, #0x8000000
 8014460: bf0c         	ite	eq
 8014462: 2301         	moveq	r3, #0x1
 8014464: 2300         	movne	r3, #0x0
 8014466: b2db         	uxtb	r3, r3
; }
 8014468: 4618         	mov	r0, r3
 801446a: 370c         	adds	r7, #0xc
 801446c: 46bd         	mov	sp, r7
 801446e: bc80         	pop	{r7}
 8014470: 4770         	bx	lr

08014472 <LL_DMA_IsActiveFlag_TE0>:
; {
 8014472: b480         	push	{r7}
 8014474: b083         	sub	sp, #0xc
 8014476: af00         	add	r7, sp, #0x0
 8014478: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF0)==(DMA_LISR_TEIF0));
 801447a: 687b         	ldr	r3, [r7, #0x4]
 801447c: 681b         	ldr	r3, [r3]
 801447e: f003 0308    	and	r3, r3, #0x8
 8014482: 2b08         	cmp	r3, #0x8
 8014484: bf0c         	ite	eq
 8014486: 2301         	moveq	r3, #0x1
 8014488: 2300         	movne	r3, #0x0
 801448a: b2db         	uxtb	r3, r3
; }
 801448c: 4618         	mov	r0, r3
 801448e: 370c         	adds	r7, #0xc
 8014490: 46bd         	mov	sp, r7
 8014492: bc80         	pop	{r7}
 8014494: 4770         	bx	lr

08014496 <LL_DMA_IsActiveFlag_TE1>:
; {
 8014496: b480         	push	{r7}
 8014498: b083         	sub	sp, #0xc
 801449a: af00         	add	r7, sp, #0x0
 801449c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF1)==(DMA_LISR_TEIF1));
 801449e: 687b         	ldr	r3, [r7, #0x4]
 80144a0: 681b         	ldr	r3, [r3]
 80144a2: f403 7300    	and	r3, r3, #0x200
 80144a6: f5b3 7f00    	cmp.w	r3, #0x200
 80144aa: bf0c         	ite	eq
 80144ac: 2301         	moveq	r3, #0x1
 80144ae: 2300         	movne	r3, #0x0
 80144b0: b2db         	uxtb	r3, r3
; }
 80144b2: 4618         	mov	r0, r3
 80144b4: 370c         	adds	r7, #0xc
 80144b6: 46bd         	mov	sp, r7
 80144b8: bc80         	pop	{r7}
 80144ba: 4770         	bx	lr

080144bc <LL_DMA_IsActiveFlag_TE2>:
; {
 80144bc: b480         	push	{r7}
 80144be: b083         	sub	sp, #0xc
 80144c0: af00         	add	r7, sp, #0x0
 80144c2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF2)==(DMA_LISR_TEIF2));
 80144c4: 687b         	ldr	r3, [r7, #0x4]
 80144c6: 681b         	ldr	r3, [r3]
 80144c8: f403 2300    	and	r3, r3, #0x80000
 80144cc: f5b3 2f00    	cmp.w	r3, #0x80000
 80144d0: bf0c         	ite	eq
 80144d2: 2301         	moveq	r3, #0x1
 80144d4: 2300         	movne	r3, #0x0
 80144d6: b2db         	uxtb	r3, r3
; }
 80144d8: 4618         	mov	r0, r3
 80144da: 370c         	adds	r7, #0xc
 80144dc: 46bd         	mov	sp, r7
 80144de: bc80         	pop	{r7}
 80144e0: 4770         	bx	lr

080144e2 <LL_DMA_IsActiveFlag_TE3>:
; {
 80144e2: b480         	push	{r7}
 80144e4: b083         	sub	sp, #0xc
 80144e6: af00         	add	r7, sp, #0x0
 80144e8: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF3)==(DMA_LISR_TEIF3));
 80144ea: 687b         	ldr	r3, [r7, #0x4]
 80144ec: 681b         	ldr	r3, [r3]
 80144ee: f003 7300    	and	r3, r3, #0x2000000
 80144f2: f1b3 7f00    	cmp.w	r3, #0x2000000
 80144f6: bf0c         	ite	eq
 80144f8: 2301         	moveq	r3, #0x1
 80144fa: 2300         	movne	r3, #0x0
 80144fc: b2db         	uxtb	r3, r3
; }
 80144fe: 4618         	mov	r0, r3
 8014500: 370c         	adds	r7, #0xc
 8014502: 46bd         	mov	sp, r7
 8014504: bc80         	pop	{r7}
 8014506: 4770         	bx	lr

08014508 <LL_DMA_IsActiveFlag_TE4>:
; {
 8014508: b480         	push	{r7}
 801450a: b083         	sub	sp, #0xc
 801450c: af00         	add	r7, sp, #0x0
 801450e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF4)==(DMA_HISR_TEIF4));
 8014510: 687b         	ldr	r3, [r7, #0x4]
 8014512: 685b         	ldr	r3, [r3, #0x4]
 8014514: f003 0308    	and	r3, r3, #0x8
 8014518: 2b08         	cmp	r3, #0x8
 801451a: bf0c         	ite	eq
 801451c: 2301         	moveq	r3, #0x1
 801451e: 2300         	movne	r3, #0x0
 8014520: b2db         	uxtb	r3, r3
; }
 8014522: 4618         	mov	r0, r3
 8014524: 370c         	adds	r7, #0xc
 8014526: 46bd         	mov	sp, r7
 8014528: bc80         	pop	{r7}
 801452a: 4770         	bx	lr

0801452c <LL_DMA_IsActiveFlag_TE5>:
; {
 801452c: b480         	push	{r7}
 801452e: b083         	sub	sp, #0xc
 8014530: af00         	add	r7, sp, #0x0
 8014532: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF5)==(DMA_HISR_TEIF5));
 8014534: 687b         	ldr	r3, [r7, #0x4]
 8014536: 685b         	ldr	r3, [r3, #0x4]
 8014538: f403 7300    	and	r3, r3, #0x200
 801453c: f5b3 7f00    	cmp.w	r3, #0x200
 8014540: bf0c         	ite	eq
 8014542: 2301         	moveq	r3, #0x1
 8014544: 2300         	movne	r3, #0x0
 8014546: b2db         	uxtb	r3, r3
; }
 8014548: 4618         	mov	r0, r3
 801454a: 370c         	adds	r7, #0xc
 801454c: 46bd         	mov	sp, r7
 801454e: bc80         	pop	{r7}
 8014550: 4770         	bx	lr

08014552 <LL_DMA_IsActiveFlag_TE6>:
; {
 8014552: b480         	push	{r7}
 8014554: b083         	sub	sp, #0xc
 8014556: af00         	add	r7, sp, #0x0
 8014558: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF6)==(DMA_HISR_TEIF6));
 801455a: 687b         	ldr	r3, [r7, #0x4]
 801455c: 685b         	ldr	r3, [r3, #0x4]
 801455e: f403 2300    	and	r3, r3, #0x80000
 8014562: f5b3 2f00    	cmp.w	r3, #0x80000
 8014566: bf0c         	ite	eq
 8014568: 2301         	moveq	r3, #0x1
 801456a: 2300         	movne	r3, #0x0
 801456c: b2db         	uxtb	r3, r3
; }
 801456e: 4618         	mov	r0, r3
 8014570: 370c         	adds	r7, #0xc
 8014572: 46bd         	mov	sp, r7
 8014574: bc80         	pop	{r7}
 8014576: 4770         	bx	lr

08014578 <LL_DMA_IsActiveFlag_TE7>:
; {
 8014578: b480         	push	{r7}
 801457a: b083         	sub	sp, #0xc
 801457c: af00         	add	r7, sp, #0x0
 801457e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF7)==(DMA_HISR_TEIF7));
 8014580: 687b         	ldr	r3, [r7, #0x4]
 8014582: 685b         	ldr	r3, [r3, #0x4]
 8014584: f003 7300    	and	r3, r3, #0x2000000
 8014588: f1b3 7f00    	cmp.w	r3, #0x2000000
 801458c: bf0c         	ite	eq
 801458e: 2301         	moveq	r3, #0x1
 8014590: 2300         	movne	r3, #0x0
 8014592: b2db         	uxtb	r3, r3
; }
 8014594: 4618         	mov	r0, r3
 8014596: 370c         	adds	r7, #0xc
 8014598: 46bd         	mov	sp, r7
 801459a: bc80         	pop	{r7}
 801459c: 4770         	bx	lr

0801459e <LL_DMA_IsActiveFlag_DME0>:
; {
 801459e: b480         	push	{r7}
 80145a0: b083         	sub	sp, #0xc
 80145a2: af00         	add	r7, sp, #0x0
 80145a4: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF0)==(DMA_LISR_DMEIF0));
 80145a6: 687b         	ldr	r3, [r7, #0x4]
 80145a8: 681b         	ldr	r3, [r3]
 80145aa: f003 0304    	and	r3, r3, #0x4
 80145ae: 2b04         	cmp	r3, #0x4
 80145b0: bf0c         	ite	eq
 80145b2: 2301         	moveq	r3, #0x1
 80145b4: 2300         	movne	r3, #0x0
 80145b6: b2db         	uxtb	r3, r3
; }
 80145b8: 4618         	mov	r0, r3
 80145ba: 370c         	adds	r7, #0xc
 80145bc: 46bd         	mov	sp, r7
 80145be: bc80         	pop	{r7}
 80145c0: 4770         	bx	lr

080145c2 <LL_DMA_IsActiveFlag_DME1>:
; {
 80145c2: b480         	push	{r7}
 80145c4: b083         	sub	sp, #0xc
 80145c6: af00         	add	r7, sp, #0x0
 80145c8: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF1)==(DMA_LISR_DMEIF1));
 80145ca: 687b         	ldr	r3, [r7, #0x4]
 80145cc: 681b         	ldr	r3, [r3]
 80145ce: f403 7380    	and	r3, r3, #0x100
 80145d2: f5b3 7f80    	cmp.w	r3, #0x100
 80145d6: bf0c         	ite	eq
 80145d8: 2301         	moveq	r3, #0x1
 80145da: 2300         	movne	r3, #0x0
 80145dc: b2db         	uxtb	r3, r3
; }
 80145de: 4618         	mov	r0, r3
 80145e0: 370c         	adds	r7, #0xc
 80145e2: 46bd         	mov	sp, r7
 80145e4: bc80         	pop	{r7}
 80145e6: 4770         	bx	lr

080145e8 <LL_DMA_IsActiveFlag_DME2>:
; {
 80145e8: b480         	push	{r7}
 80145ea: b083         	sub	sp, #0xc
 80145ec: af00         	add	r7, sp, #0x0
 80145ee: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF2)==(DMA_LISR_DMEIF2));
 80145f0: 687b         	ldr	r3, [r7, #0x4]
 80145f2: 681b         	ldr	r3, [r3]
 80145f4: f403 2380    	and	r3, r3, #0x40000
 80145f8: f5b3 2f80    	cmp.w	r3, #0x40000
 80145fc: bf0c         	ite	eq
 80145fe: 2301         	moveq	r3, #0x1
 8014600: 2300         	movne	r3, #0x0
 8014602: b2db         	uxtb	r3, r3
; }
 8014604: 4618         	mov	r0, r3
 8014606: 370c         	adds	r7, #0xc
 8014608: 46bd         	mov	sp, r7
 801460a: bc80         	pop	{r7}
 801460c: 4770         	bx	lr

0801460e <LL_DMA_IsActiveFlag_DME3>:
; {
 801460e: b480         	push	{r7}
 8014610: b083         	sub	sp, #0xc
 8014612: af00         	add	r7, sp, #0x0
 8014614: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF3)==(DMA_LISR_DMEIF3));
 8014616: 687b         	ldr	r3, [r7, #0x4]
 8014618: 681b         	ldr	r3, [r3]
 801461a: f003 7380    	and	r3, r3, #0x1000000
 801461e: f1b3 7f80    	cmp.w	r3, #0x1000000
 8014622: bf0c         	ite	eq
 8014624: 2301         	moveq	r3, #0x1
 8014626: 2300         	movne	r3, #0x0
 8014628: b2db         	uxtb	r3, r3
; }
 801462a: 4618         	mov	r0, r3
 801462c: 370c         	adds	r7, #0xc
 801462e: 46bd         	mov	sp, r7
 8014630: bc80         	pop	{r7}
 8014632: 4770         	bx	lr

08014634 <LL_DMA_IsActiveFlag_DME4>:
; {
 8014634: b480         	push	{r7}
 8014636: b083         	sub	sp, #0xc
 8014638: af00         	add	r7, sp, #0x0
 801463a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF4)==(DMA_HISR_DMEIF4));
 801463c: 687b         	ldr	r3, [r7, #0x4]
 801463e: 685b         	ldr	r3, [r3, #0x4]
 8014640: f003 0304    	and	r3, r3, #0x4
 8014644: 2b04         	cmp	r3, #0x4
 8014646: bf0c         	ite	eq
 8014648: 2301         	moveq	r3, #0x1
 801464a: 2300         	movne	r3, #0x0
 801464c: b2db         	uxtb	r3, r3
; }
 801464e: 4618         	mov	r0, r3
 8014650: 370c         	adds	r7, #0xc
 8014652: 46bd         	mov	sp, r7
 8014654: bc80         	pop	{r7}
 8014656: 4770         	bx	lr

08014658 <LL_DMA_IsActiveFlag_DME5>:
; {
 8014658: b480         	push	{r7}
 801465a: b083         	sub	sp, #0xc
 801465c: af00         	add	r7, sp, #0x0
 801465e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF5)==(DMA_HISR_DMEIF5));
 8014660: 687b         	ldr	r3, [r7, #0x4]
 8014662: 685b         	ldr	r3, [r3, #0x4]
 8014664: f403 7380    	and	r3, r3, #0x100
 8014668: f5b3 7f80    	cmp.w	r3, #0x100
 801466c: bf0c         	ite	eq
 801466e: 2301         	moveq	r3, #0x1
 8014670: 2300         	movne	r3, #0x0
 8014672: b2db         	uxtb	r3, r3
; }
 8014674: 4618         	mov	r0, r3
 8014676: 370c         	adds	r7, #0xc
 8014678: 46bd         	mov	sp, r7
 801467a: bc80         	pop	{r7}
 801467c: 4770         	bx	lr

0801467e <LL_DMA_IsActiveFlag_DME6>:
; {
 801467e: b480         	push	{r7}
 8014680: b083         	sub	sp, #0xc
 8014682: af00         	add	r7, sp, #0x0
 8014684: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF6)==(DMA_HISR_DMEIF6));
 8014686: 687b         	ldr	r3, [r7, #0x4]
 8014688: 685b         	ldr	r3, [r3, #0x4]
 801468a: f403 2380    	and	r3, r3, #0x40000
 801468e: f5b3 2f80    	cmp.w	r3, #0x40000
 8014692: bf0c         	ite	eq
 8014694: 2301         	moveq	r3, #0x1
 8014696: 2300         	movne	r3, #0x0
 8014698: b2db         	uxtb	r3, r3
; }
 801469a: 4618         	mov	r0, r3
 801469c: 370c         	adds	r7, #0xc
 801469e: 46bd         	mov	sp, r7
 80146a0: bc80         	pop	{r7}
 80146a2: 4770         	bx	lr

080146a4 <LL_DMA_IsActiveFlag_DME7>:
; {
 80146a4: b480         	push	{r7}
 80146a6: b083         	sub	sp, #0xc
 80146a8: af00         	add	r7, sp, #0x0
 80146aa: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF7)==(DMA_HISR_DMEIF7));
 80146ac: 687b         	ldr	r3, [r7, #0x4]
 80146ae: 685b         	ldr	r3, [r3, #0x4]
 80146b0: f003 7380    	and	r3, r3, #0x1000000
 80146b4: f1b3 7f80    	cmp.w	r3, #0x1000000
 80146b8: bf0c         	ite	eq
 80146ba: 2301         	moveq	r3, #0x1
 80146bc: 2300         	movne	r3, #0x0
 80146be: b2db         	uxtb	r3, r3
; }
 80146c0: 4618         	mov	r0, r3
 80146c2: 370c         	adds	r7, #0xc
 80146c4: 46bd         	mov	sp, r7
 80146c6: bc80         	pop	{r7}
 80146c8: 4770         	bx	lr

080146ca <LL_DMA_IsActiveFlag_FE0>:
; {
 80146ca: b480         	push	{r7}
 80146cc: b083         	sub	sp, #0xc
 80146ce: af00         	add	r7, sp, #0x0
 80146d0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF0)==(DMA_LISR_FEIF0));
 80146d2: 687b         	ldr	r3, [r7, #0x4]
 80146d4: 681b         	ldr	r3, [r3]
 80146d6: f003 0301    	and	r3, r3, #0x1
 80146da: 2b01         	cmp	r3, #0x1
 80146dc: bf0c         	ite	eq
 80146de: 2301         	moveq	r3, #0x1
 80146e0: 2300         	movne	r3, #0x0
 80146e2: b2db         	uxtb	r3, r3
; }
 80146e4: 4618         	mov	r0, r3
 80146e6: 370c         	adds	r7, #0xc
 80146e8: 46bd         	mov	sp, r7
 80146ea: bc80         	pop	{r7}
 80146ec: 4770         	bx	lr

080146ee <LL_DMA_IsActiveFlag_FE1>:
; {
 80146ee: b480         	push	{r7}
 80146f0: b083         	sub	sp, #0xc
 80146f2: af00         	add	r7, sp, #0x0
 80146f4: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF1)==(DMA_LISR_FEIF1));
 80146f6: 687b         	ldr	r3, [r7, #0x4]
 80146f8: 681b         	ldr	r3, [r3]
 80146fa: f003 0340    	and	r3, r3, #0x40
 80146fe: 2b40         	cmp	r3, #0x40
 8014700: bf0c         	ite	eq
 8014702: 2301         	moveq	r3, #0x1
 8014704: 2300         	movne	r3, #0x0
 8014706: b2db         	uxtb	r3, r3
; }
 8014708: 4618         	mov	r0, r3
 801470a: 370c         	adds	r7, #0xc
 801470c: 46bd         	mov	sp, r7
 801470e: bc80         	pop	{r7}
 8014710: 4770         	bx	lr

08014712 <LL_DMA_IsActiveFlag_FE2>:
; {
 8014712: b480         	push	{r7}
 8014714: b083         	sub	sp, #0xc
 8014716: af00         	add	r7, sp, #0x0
 8014718: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF2)==(DMA_LISR_FEIF2));
 801471a: 687b         	ldr	r3, [r7, #0x4]
 801471c: 681b         	ldr	r3, [r3]
 801471e: f403 3380    	and	r3, r3, #0x10000
 8014722: f5b3 3f80    	cmp.w	r3, #0x10000
 8014726: bf0c         	ite	eq
 8014728: 2301         	moveq	r3, #0x1
 801472a: 2300         	movne	r3, #0x0
 801472c: b2db         	uxtb	r3, r3
; }
 801472e: 4618         	mov	r0, r3
 8014730: 370c         	adds	r7, #0xc
 8014732: 46bd         	mov	sp, r7
 8014734: bc80         	pop	{r7}
 8014736: 4770         	bx	lr

08014738 <LL_DMA_IsActiveFlag_FE3>:
; {
 8014738: b480         	push	{r7}
 801473a: b083         	sub	sp, #0xc
 801473c: af00         	add	r7, sp, #0x0
 801473e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF3)==(DMA_LISR_FEIF3));
 8014740: 687b         	ldr	r3, [r7, #0x4]
 8014742: 681b         	ldr	r3, [r3]
 8014744: f403 0380    	and	r3, r3, #0x400000
 8014748: f5b3 0f80    	cmp.w	r3, #0x400000
 801474c: bf0c         	ite	eq
 801474e: 2301         	moveq	r3, #0x1
 8014750: 2300         	movne	r3, #0x0
 8014752: b2db         	uxtb	r3, r3
; }
 8014754: 4618         	mov	r0, r3
 8014756: 370c         	adds	r7, #0xc
 8014758: 46bd         	mov	sp, r7
 801475a: bc80         	pop	{r7}
 801475c: 4770         	bx	lr

0801475e <LL_DMA_IsActiveFlag_FE4>:
; {
 801475e: b480         	push	{r7}
 8014760: b083         	sub	sp, #0xc
 8014762: af00         	add	r7, sp, #0x0
 8014764: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF4)==(DMA_HISR_FEIF4));
 8014766: 687b         	ldr	r3, [r7, #0x4]
 8014768: 685b         	ldr	r3, [r3, #0x4]
 801476a: f003 0301    	and	r3, r3, #0x1
 801476e: 2b01         	cmp	r3, #0x1
 8014770: bf0c         	ite	eq
 8014772: 2301         	moveq	r3, #0x1
 8014774: 2300         	movne	r3, #0x0
 8014776: b2db         	uxtb	r3, r3
; }
 8014778: 4618         	mov	r0, r3
 801477a: 370c         	adds	r7, #0xc
 801477c: 46bd         	mov	sp, r7
 801477e: bc80         	pop	{r7}
 8014780: 4770         	bx	lr

08014782 <LL_DMA_IsActiveFlag_FE5>:
; {
 8014782: b480         	push	{r7}
 8014784: b083         	sub	sp, #0xc
 8014786: af00         	add	r7, sp, #0x0
 8014788: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF5)==(DMA_HISR_FEIF5));
 801478a: 687b         	ldr	r3, [r7, #0x4]
 801478c: 685b         	ldr	r3, [r3, #0x4]
 801478e: f003 0340    	and	r3, r3, #0x40
 8014792: 2b40         	cmp	r3, #0x40
 8014794: bf0c         	ite	eq
 8014796: 2301         	moveq	r3, #0x1
 8014798: 2300         	movne	r3, #0x0
 801479a: b2db         	uxtb	r3, r3
; }
 801479c: 4618         	mov	r0, r3
 801479e: 370c         	adds	r7, #0xc
 80147a0: 46bd         	mov	sp, r7
 80147a2: bc80         	pop	{r7}
 80147a4: 4770         	bx	lr

080147a6 <LL_DMA_IsActiveFlag_FE6>:
; {
 80147a6: b480         	push	{r7}
 80147a8: b083         	sub	sp, #0xc
 80147aa: af00         	add	r7, sp, #0x0
 80147ac: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF6)==(DMA_HISR_FEIF6));
 80147ae: 687b         	ldr	r3, [r7, #0x4]
 80147b0: 685b         	ldr	r3, [r3, #0x4]
 80147b2: f403 3380    	and	r3, r3, #0x10000
 80147b6: f5b3 3f80    	cmp.w	r3, #0x10000
 80147ba: bf0c         	ite	eq
 80147bc: 2301         	moveq	r3, #0x1
 80147be: 2300         	movne	r3, #0x0
 80147c0: b2db         	uxtb	r3, r3
; }
 80147c2: 4618         	mov	r0, r3
 80147c4: 370c         	adds	r7, #0xc
 80147c6: 46bd         	mov	sp, r7
 80147c8: bc80         	pop	{r7}
 80147ca: 4770         	bx	lr

080147cc <LL_DMA_IsActiveFlag_FE7>:
; {
 80147cc: b480         	push	{r7}
 80147ce: b083         	sub	sp, #0xc
 80147d0: af00         	add	r7, sp, #0x0
 80147d2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF7)==(DMA_HISR_FEIF7));
 80147d4: 687b         	ldr	r3, [r7, #0x4]
 80147d6: 685b         	ldr	r3, [r3, #0x4]
 80147d8: f403 0380    	and	r3, r3, #0x400000
 80147dc: f5b3 0f80    	cmp.w	r3, #0x400000
 80147e0: bf0c         	ite	eq
 80147e2: 2301         	moveq	r3, #0x1
 80147e4: 2300         	movne	r3, #0x0
 80147e6: b2db         	uxtb	r3, r3
; }
 80147e8: 4618         	mov	r0, r3
 80147ea: 370c         	adds	r7, #0xc
 80147ec: 46bd         	mov	sp, r7
 80147ee: bc80         	pop	{r7}
 80147f0: 4770         	bx	lr

080147f2 <LL_DMA_ClearFlag_HT0>:
; {
 80147f2: b480         	push	{r7}
 80147f4: b083         	sub	sp, #0xc
 80147f6: af00         	add	r7, sp, #0x0
 80147f8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF0);
 80147fa: 687b         	ldr	r3, [r7, #0x4]
 80147fc: 2210         	movs	r2, #0x10
 80147fe: 609a         	str	r2, [r3, #0x8]
; }
 8014800: bf00         	nop
 8014802: 370c         	adds	r7, #0xc
 8014804: 46bd         	mov	sp, r7
 8014806: bc80         	pop	{r7}
 8014808: 4770         	bx	lr

0801480a <LL_DMA_ClearFlag_HT1>:
; {
 801480a: b480         	push	{r7}
 801480c: b083         	sub	sp, #0xc
 801480e: af00         	add	r7, sp, #0x0
 8014810: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF1);
 8014812: 687b         	ldr	r3, [r7, #0x4]
 8014814: f44f 6280    	mov.w	r2, #0x400
 8014818: 609a         	str	r2, [r3, #0x8]
; }
 801481a: bf00         	nop
 801481c: 370c         	adds	r7, #0xc
 801481e: 46bd         	mov	sp, r7
 8014820: bc80         	pop	{r7}
 8014822: 4770         	bx	lr

08014824 <LL_DMA_ClearFlag_HT2>:
; {
 8014824: b480         	push	{r7}
 8014826: b083         	sub	sp, #0xc
 8014828: af00         	add	r7, sp, #0x0
 801482a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF2);
 801482c: 687b         	ldr	r3, [r7, #0x4]
 801482e: f44f 1280    	mov.w	r2, #0x100000
 8014832: 609a         	str	r2, [r3, #0x8]
; }
 8014834: bf00         	nop
 8014836: 370c         	adds	r7, #0xc
 8014838: 46bd         	mov	sp, r7
 801483a: bc80         	pop	{r7}
 801483c: 4770         	bx	lr

0801483e <LL_DMA_ClearFlag_HT3>:
; {
 801483e: b480         	push	{r7}
 8014840: b083         	sub	sp, #0xc
 8014842: af00         	add	r7, sp, #0x0
 8014844: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF3);
 8014846: 687b         	ldr	r3, [r7, #0x4]
 8014848: f04f 6280    	mov.w	r2, #0x4000000
 801484c: 609a         	str	r2, [r3, #0x8]
; }
 801484e: bf00         	nop
 8014850: 370c         	adds	r7, #0xc
 8014852: 46bd         	mov	sp, r7
 8014854: bc80         	pop	{r7}
 8014856: 4770         	bx	lr

08014858 <LL_DMA_ClearFlag_HT4>:
; {
 8014858: b480         	push	{r7}
 801485a: b083         	sub	sp, #0xc
 801485c: af00         	add	r7, sp, #0x0
 801485e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF4);
 8014860: 687b         	ldr	r3, [r7, #0x4]
 8014862: 2210         	movs	r2, #0x10
 8014864: 60da         	str	r2, [r3, #0xc]
; }
 8014866: bf00         	nop
 8014868: 370c         	adds	r7, #0xc
 801486a: 46bd         	mov	sp, r7
 801486c: bc80         	pop	{r7}
 801486e: 4770         	bx	lr

08014870 <LL_DMA_ClearFlag_HT5>:
; {
 8014870: b480         	push	{r7}
 8014872: b083         	sub	sp, #0xc
 8014874: af00         	add	r7, sp, #0x0
 8014876: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF5);
 8014878: 687b         	ldr	r3, [r7, #0x4]
 801487a: f44f 6280    	mov.w	r2, #0x400
 801487e: 60da         	str	r2, [r3, #0xc]
; }
 8014880: bf00         	nop
 8014882: 370c         	adds	r7, #0xc
 8014884: 46bd         	mov	sp, r7
 8014886: bc80         	pop	{r7}
 8014888: 4770         	bx	lr

0801488a <LL_DMA_ClearFlag_HT6>:
; {
 801488a: b480         	push	{r7}
 801488c: b083         	sub	sp, #0xc
 801488e: af00         	add	r7, sp, #0x0
 8014890: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF6);
 8014892: 687b         	ldr	r3, [r7, #0x4]
 8014894: f44f 1280    	mov.w	r2, #0x100000
 8014898: 60da         	str	r2, [r3, #0xc]
; }
 801489a: bf00         	nop
 801489c: 370c         	adds	r7, #0xc
 801489e: 46bd         	mov	sp, r7
 80148a0: bc80         	pop	{r7}
 80148a2: 4770         	bx	lr

080148a4 <LL_DMA_ClearFlag_HT7>:
; {
 80148a4: b480         	push	{r7}
 80148a6: b083         	sub	sp, #0xc
 80148a8: af00         	add	r7, sp, #0x0
 80148aa: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF7);
 80148ac: 687b         	ldr	r3, [r7, #0x4]
 80148ae: f04f 6280    	mov.w	r2, #0x4000000
 80148b2: 60da         	str	r2, [r3, #0xc]
; }
 80148b4: bf00         	nop
 80148b6: 370c         	adds	r7, #0xc
 80148b8: 46bd         	mov	sp, r7
 80148ba: bc80         	pop	{r7}
 80148bc: 4770         	bx	lr

080148be <LL_DMA_ClearFlag_TC0>:
; {
 80148be: b480         	push	{r7}
 80148c0: b083         	sub	sp, #0xc
 80148c2: af00         	add	r7, sp, #0x0
 80148c4: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF0);
 80148c6: 687b         	ldr	r3, [r7, #0x4]
 80148c8: 2220         	movs	r2, #0x20
 80148ca: 609a         	str	r2, [r3, #0x8]
; }
 80148cc: bf00         	nop
 80148ce: 370c         	adds	r7, #0xc
 80148d0: 46bd         	mov	sp, r7
 80148d2: bc80         	pop	{r7}
 80148d4: 4770         	bx	lr

080148d6 <LL_DMA_ClearFlag_TC1>:
; {
 80148d6: b480         	push	{r7}
 80148d8: b083         	sub	sp, #0xc
 80148da: af00         	add	r7, sp, #0x0
 80148dc: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF1);
 80148de: 687b         	ldr	r3, [r7, #0x4]
 80148e0: f44f 6200    	mov.w	r2, #0x800
 80148e4: 609a         	str	r2, [r3, #0x8]
; }
 80148e6: bf00         	nop
 80148e8: 370c         	adds	r7, #0xc
 80148ea: 46bd         	mov	sp, r7
 80148ec: bc80         	pop	{r7}
 80148ee: 4770         	bx	lr

080148f0 <LL_DMA_ClearFlag_TC2>:
; {
 80148f0: b480         	push	{r7}
 80148f2: b083         	sub	sp, #0xc
 80148f4: af00         	add	r7, sp, #0x0
 80148f6: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF2);
 80148f8: 687b         	ldr	r3, [r7, #0x4]
 80148fa: f44f 1200    	mov.w	r2, #0x200000
 80148fe: 609a         	str	r2, [r3, #0x8]
; }
 8014900: bf00         	nop
 8014902: 370c         	adds	r7, #0xc
 8014904: 46bd         	mov	sp, r7
 8014906: bc80         	pop	{r7}
 8014908: 4770         	bx	lr

0801490a <LL_DMA_ClearFlag_TC3>:
; {
 801490a: b480         	push	{r7}
 801490c: b083         	sub	sp, #0xc
 801490e: af00         	add	r7, sp, #0x0
 8014910: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF3);
 8014912: 687b         	ldr	r3, [r7, #0x4]
 8014914: f04f 6200    	mov.w	r2, #0x8000000
 8014918: 609a         	str	r2, [r3, #0x8]
; }
 801491a: bf00         	nop
 801491c: 370c         	adds	r7, #0xc
 801491e: 46bd         	mov	sp, r7
 8014920: bc80         	pop	{r7}
 8014922: 4770         	bx	lr

08014924 <LL_DMA_ClearFlag_TC4>:
; {
 8014924: b480         	push	{r7}
 8014926: b083         	sub	sp, #0xc
 8014928: af00         	add	r7, sp, #0x0
 801492a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF4);
 801492c: 687b         	ldr	r3, [r7, #0x4]
 801492e: 2220         	movs	r2, #0x20
 8014930: 60da         	str	r2, [r3, #0xc]
; }
 8014932: bf00         	nop
 8014934: 370c         	adds	r7, #0xc
 8014936: 46bd         	mov	sp, r7
 8014938: bc80         	pop	{r7}
 801493a: 4770         	bx	lr

0801493c <LL_DMA_ClearFlag_TC5>:
; {
 801493c: b480         	push	{r7}
 801493e: b083         	sub	sp, #0xc
 8014940: af00         	add	r7, sp, #0x0
 8014942: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF5);
 8014944: 687b         	ldr	r3, [r7, #0x4]
 8014946: f44f 6200    	mov.w	r2, #0x800
 801494a: 60da         	str	r2, [r3, #0xc]
; }
 801494c: bf00         	nop
 801494e: 370c         	adds	r7, #0xc
 8014950: 46bd         	mov	sp, r7
 8014952: bc80         	pop	{r7}
 8014954: 4770         	bx	lr

08014956 <LL_DMA_ClearFlag_TC6>:
; {
 8014956: b480         	push	{r7}
 8014958: b083         	sub	sp, #0xc
 801495a: af00         	add	r7, sp, #0x0
 801495c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF6);
 801495e: 687b         	ldr	r3, [r7, #0x4]
 8014960: f44f 1200    	mov.w	r2, #0x200000
 8014964: 60da         	str	r2, [r3, #0xc]
; }
 8014966: bf00         	nop
 8014968: 370c         	adds	r7, #0xc
 801496a: 46bd         	mov	sp, r7
 801496c: bc80         	pop	{r7}
 801496e: 4770         	bx	lr

08014970 <LL_DMA_ClearFlag_TC7>:
; {
 8014970: b480         	push	{r7}
 8014972: b083         	sub	sp, #0xc
 8014974: af00         	add	r7, sp, #0x0
 8014976: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF7);
 8014978: 687b         	ldr	r3, [r7, #0x4]
 801497a: f04f 6200    	mov.w	r2, #0x8000000
 801497e: 60da         	str	r2, [r3, #0xc]
; }
 8014980: bf00         	nop
 8014982: 370c         	adds	r7, #0xc
 8014984: 46bd         	mov	sp, r7
 8014986: bc80         	pop	{r7}
 8014988: 4770         	bx	lr

0801498a <LL_DMA_ClearFlag_TE0>:
; {
 801498a: b480         	push	{r7}
 801498c: b083         	sub	sp, #0xc
 801498e: af00         	add	r7, sp, #0x0
 8014990: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF0);
 8014992: 687b         	ldr	r3, [r7, #0x4]
 8014994: 2208         	movs	r2, #0x8
 8014996: 609a         	str	r2, [r3, #0x8]
; }
 8014998: bf00         	nop
 801499a: 370c         	adds	r7, #0xc
 801499c: 46bd         	mov	sp, r7
 801499e: bc80         	pop	{r7}
 80149a0: 4770         	bx	lr

080149a2 <LL_DMA_ClearFlag_TE1>:
; {
 80149a2: b480         	push	{r7}
 80149a4: b083         	sub	sp, #0xc
 80149a6: af00         	add	r7, sp, #0x0
 80149a8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF1);
 80149aa: 687b         	ldr	r3, [r7, #0x4]
 80149ac: f44f 7200    	mov.w	r2, #0x200
 80149b0: 609a         	str	r2, [r3, #0x8]
; }
 80149b2: bf00         	nop
 80149b4: 370c         	adds	r7, #0xc
 80149b6: 46bd         	mov	sp, r7
 80149b8: bc80         	pop	{r7}
 80149ba: 4770         	bx	lr

080149bc <LL_DMA_ClearFlag_TE2>:
; {
 80149bc: b480         	push	{r7}
 80149be: b083         	sub	sp, #0xc
 80149c0: af00         	add	r7, sp, #0x0
 80149c2: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF2);
 80149c4: 687b         	ldr	r3, [r7, #0x4]
 80149c6: f44f 2200    	mov.w	r2, #0x80000
 80149ca: 609a         	str	r2, [r3, #0x8]
; }
 80149cc: bf00         	nop
 80149ce: 370c         	adds	r7, #0xc
 80149d0: 46bd         	mov	sp, r7
 80149d2: bc80         	pop	{r7}
 80149d4: 4770         	bx	lr

080149d6 <LL_DMA_ClearFlag_TE3>:
; {
 80149d6: b480         	push	{r7}
 80149d8: b083         	sub	sp, #0xc
 80149da: af00         	add	r7, sp, #0x0
 80149dc: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF3);
 80149de: 687b         	ldr	r3, [r7, #0x4]
 80149e0: f04f 7200    	mov.w	r2, #0x2000000
 80149e4: 609a         	str	r2, [r3, #0x8]
; }
 80149e6: bf00         	nop
 80149e8: 370c         	adds	r7, #0xc
 80149ea: 46bd         	mov	sp, r7
 80149ec: bc80         	pop	{r7}
 80149ee: 4770         	bx	lr

080149f0 <LL_DMA_ClearFlag_TE4>:
; {
 80149f0: b480         	push	{r7}
 80149f2: b083         	sub	sp, #0xc
 80149f4: af00         	add	r7, sp, #0x0
 80149f6: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF4);
 80149f8: 687b         	ldr	r3, [r7, #0x4]
 80149fa: 2208         	movs	r2, #0x8
 80149fc: 60da         	str	r2, [r3, #0xc]
; }
 80149fe: bf00         	nop
 8014a00: 370c         	adds	r7, #0xc
 8014a02: 46bd         	mov	sp, r7
 8014a04: bc80         	pop	{r7}
 8014a06: 4770         	bx	lr

08014a08 <LL_DMA_ClearFlag_TE5>:
; {
 8014a08: b480         	push	{r7}
 8014a0a: b083         	sub	sp, #0xc
 8014a0c: af00         	add	r7, sp, #0x0
 8014a0e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF5);
 8014a10: 687b         	ldr	r3, [r7, #0x4]
 8014a12: f44f 7200    	mov.w	r2, #0x200
 8014a16: 60da         	str	r2, [r3, #0xc]
; }
 8014a18: bf00         	nop
 8014a1a: 370c         	adds	r7, #0xc
 8014a1c: 46bd         	mov	sp, r7
 8014a1e: bc80         	pop	{r7}
 8014a20: 4770         	bx	lr

08014a22 <LL_DMA_ClearFlag_TE6>:
; {
 8014a22: b480         	push	{r7}
 8014a24: b083         	sub	sp, #0xc
 8014a26: af00         	add	r7, sp, #0x0
 8014a28: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF6);
 8014a2a: 687b         	ldr	r3, [r7, #0x4]
 8014a2c: f44f 2200    	mov.w	r2, #0x80000
 8014a30: 60da         	str	r2, [r3, #0xc]
; }
 8014a32: bf00         	nop
 8014a34: 370c         	adds	r7, #0xc
 8014a36: 46bd         	mov	sp, r7
 8014a38: bc80         	pop	{r7}
 8014a3a: 4770         	bx	lr

08014a3c <LL_DMA_ClearFlag_TE7>:
; {
 8014a3c: b480         	push	{r7}
 8014a3e: b083         	sub	sp, #0xc
 8014a40: af00         	add	r7, sp, #0x0
 8014a42: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF7);
 8014a44: 687b         	ldr	r3, [r7, #0x4]
 8014a46: f04f 7200    	mov.w	r2, #0x2000000
 8014a4a: 60da         	str	r2, [r3, #0xc]
; }
 8014a4c: bf00         	nop
 8014a4e: 370c         	adds	r7, #0xc
 8014a50: 46bd         	mov	sp, r7
 8014a52: bc80         	pop	{r7}
 8014a54: 4770         	bx	lr

08014a56 <LL_DMA_ClearFlag_DME0>:
; {
 8014a56: b480         	push	{r7}
 8014a58: b083         	sub	sp, #0xc
 8014a5a: af00         	add	r7, sp, #0x0
 8014a5c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF0);
 8014a5e: 687b         	ldr	r3, [r7, #0x4]
 8014a60: 2204         	movs	r2, #0x4
 8014a62: 609a         	str	r2, [r3, #0x8]
; }
 8014a64: bf00         	nop
 8014a66: 370c         	adds	r7, #0xc
 8014a68: 46bd         	mov	sp, r7
 8014a6a: bc80         	pop	{r7}
 8014a6c: 4770         	bx	lr

08014a6e <LL_DMA_ClearFlag_DME1>:
; {
 8014a6e: b480         	push	{r7}
 8014a70: b083         	sub	sp, #0xc
 8014a72: af00         	add	r7, sp, #0x0
 8014a74: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF1);
 8014a76: 687b         	ldr	r3, [r7, #0x4]
 8014a78: f44f 7280    	mov.w	r2, #0x100
 8014a7c: 609a         	str	r2, [r3, #0x8]
; }
 8014a7e: bf00         	nop
 8014a80: 370c         	adds	r7, #0xc
 8014a82: 46bd         	mov	sp, r7
 8014a84: bc80         	pop	{r7}
 8014a86: 4770         	bx	lr

08014a88 <LL_DMA_ClearFlag_DME2>:
; {
 8014a88: b480         	push	{r7}
 8014a8a: b083         	sub	sp, #0xc
 8014a8c: af00         	add	r7, sp, #0x0
 8014a8e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF2);
 8014a90: 687b         	ldr	r3, [r7, #0x4]
 8014a92: f44f 2280    	mov.w	r2, #0x40000
 8014a96: 609a         	str	r2, [r3, #0x8]
; }
 8014a98: bf00         	nop
 8014a9a: 370c         	adds	r7, #0xc
 8014a9c: 46bd         	mov	sp, r7
 8014a9e: bc80         	pop	{r7}
 8014aa0: 4770         	bx	lr

08014aa2 <LL_DMA_ClearFlag_DME3>:
; {
 8014aa2: b480         	push	{r7}
 8014aa4: b083         	sub	sp, #0xc
 8014aa6: af00         	add	r7, sp, #0x0
 8014aa8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF3);
 8014aaa: 687b         	ldr	r3, [r7, #0x4]
 8014aac: f04f 7280    	mov.w	r2, #0x1000000
 8014ab0: 609a         	str	r2, [r3, #0x8]
; }
 8014ab2: bf00         	nop
 8014ab4: 370c         	adds	r7, #0xc
 8014ab6: 46bd         	mov	sp, r7
 8014ab8: bc80         	pop	{r7}
 8014aba: 4770         	bx	lr

08014abc <LL_DMA_ClearFlag_DME4>:
; {
 8014abc: b480         	push	{r7}
 8014abe: b083         	sub	sp, #0xc
 8014ac0: af00         	add	r7, sp, #0x0
 8014ac2: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF4);
 8014ac4: 687b         	ldr	r3, [r7, #0x4]
 8014ac6: 2204         	movs	r2, #0x4
 8014ac8: 60da         	str	r2, [r3, #0xc]
; }
 8014aca: bf00         	nop
 8014acc: 370c         	adds	r7, #0xc
 8014ace: 46bd         	mov	sp, r7
 8014ad0: bc80         	pop	{r7}
 8014ad2: 4770         	bx	lr

08014ad4 <LL_DMA_ClearFlag_DME5>:
; {
 8014ad4: b480         	push	{r7}
 8014ad6: b083         	sub	sp, #0xc
 8014ad8: af00         	add	r7, sp, #0x0
 8014ada: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF5);
 8014adc: 687b         	ldr	r3, [r7, #0x4]
 8014ade: f44f 7280    	mov.w	r2, #0x100
 8014ae2: 60da         	str	r2, [r3, #0xc]
; }
 8014ae4: bf00         	nop
 8014ae6: 370c         	adds	r7, #0xc
 8014ae8: 46bd         	mov	sp, r7
 8014aea: bc80         	pop	{r7}
 8014aec: 4770         	bx	lr

08014aee <LL_DMA_ClearFlag_DME6>:
; {
 8014aee: b480         	push	{r7}
 8014af0: b083         	sub	sp, #0xc
 8014af2: af00         	add	r7, sp, #0x0
 8014af4: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF6);
 8014af6: 687b         	ldr	r3, [r7, #0x4]
 8014af8: f44f 2280    	mov.w	r2, #0x40000
 8014afc: 60da         	str	r2, [r3, #0xc]
; }
 8014afe: bf00         	nop
 8014b00: 370c         	adds	r7, #0xc
 8014b02: 46bd         	mov	sp, r7
 8014b04: bc80         	pop	{r7}
 8014b06: 4770         	bx	lr

08014b08 <LL_DMA_ClearFlag_DME7>:
; {
 8014b08: b480         	push	{r7}
 8014b0a: b083         	sub	sp, #0xc
 8014b0c: af00         	add	r7, sp, #0x0
 8014b0e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF7);
 8014b10: 687b         	ldr	r3, [r7, #0x4]
 8014b12: f04f 7280    	mov.w	r2, #0x1000000
 8014b16: 60da         	str	r2, [r3, #0xc]
; }
 8014b18: bf00         	nop
 8014b1a: 370c         	adds	r7, #0xc
 8014b1c: 46bd         	mov	sp, r7
 8014b1e: bc80         	pop	{r7}
 8014b20: 4770         	bx	lr

08014b22 <LL_DMA_ClearFlag_FE0>:
; {
 8014b22: b480         	push	{r7}
 8014b24: b083         	sub	sp, #0xc
 8014b26: af00         	add	r7, sp, #0x0
 8014b28: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF0);
 8014b2a: 687b         	ldr	r3, [r7, #0x4]
 8014b2c: 2201         	movs	r2, #0x1
 8014b2e: 609a         	str	r2, [r3, #0x8]
; }
 8014b30: bf00         	nop
 8014b32: 370c         	adds	r7, #0xc
 8014b34: 46bd         	mov	sp, r7
 8014b36: bc80         	pop	{r7}
 8014b38: 4770         	bx	lr

08014b3a <LL_DMA_ClearFlag_FE1>:
; {
 8014b3a: b480         	push	{r7}
 8014b3c: b083         	sub	sp, #0xc
 8014b3e: af00         	add	r7, sp, #0x0
 8014b40: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF1);
 8014b42: 687b         	ldr	r3, [r7, #0x4]
 8014b44: 2240         	movs	r2, #0x40
 8014b46: 609a         	str	r2, [r3, #0x8]
; }
 8014b48: bf00         	nop
 8014b4a: 370c         	adds	r7, #0xc
 8014b4c: 46bd         	mov	sp, r7
 8014b4e: bc80         	pop	{r7}
 8014b50: 4770         	bx	lr

08014b52 <LL_DMA_ClearFlag_FE2>:
; {
 8014b52: b480         	push	{r7}
 8014b54: b083         	sub	sp, #0xc
 8014b56: af00         	add	r7, sp, #0x0
 8014b58: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF2);
 8014b5a: 687b         	ldr	r3, [r7, #0x4]
 8014b5c: f44f 3280    	mov.w	r2, #0x10000
 8014b60: 609a         	str	r2, [r3, #0x8]
; }
 8014b62: bf00         	nop
 8014b64: 370c         	adds	r7, #0xc
 8014b66: 46bd         	mov	sp, r7
 8014b68: bc80         	pop	{r7}
 8014b6a: 4770         	bx	lr

08014b6c <LL_DMA_ClearFlag_FE3>:
; {
 8014b6c: b480         	push	{r7}
 8014b6e: b083         	sub	sp, #0xc
 8014b70: af00         	add	r7, sp, #0x0
 8014b72: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF3);
 8014b74: 687b         	ldr	r3, [r7, #0x4]
 8014b76: f44f 0280    	mov.w	r2, #0x400000
 8014b7a: 609a         	str	r2, [r3, #0x8]
; }
 8014b7c: bf00         	nop
 8014b7e: 370c         	adds	r7, #0xc
 8014b80: 46bd         	mov	sp, r7
 8014b82: bc80         	pop	{r7}
 8014b84: 4770         	bx	lr

08014b86 <LL_DMA_ClearFlag_FE4>:
; {
 8014b86: b480         	push	{r7}
 8014b88: b083         	sub	sp, #0xc
 8014b8a: af00         	add	r7, sp, #0x0
 8014b8c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF4);
 8014b8e: 687b         	ldr	r3, [r7, #0x4]
 8014b90: 2201         	movs	r2, #0x1
 8014b92: 60da         	str	r2, [r3, #0xc]
; }
 8014b94: bf00         	nop
 8014b96: 370c         	adds	r7, #0xc
 8014b98: 46bd         	mov	sp, r7
 8014b9a: bc80         	pop	{r7}
 8014b9c: 4770         	bx	lr

08014b9e <LL_DMA_ClearFlag_FE5>:
; {
 8014b9e: b480         	push	{r7}
 8014ba0: b083         	sub	sp, #0xc
 8014ba2: af00         	add	r7, sp, #0x0
 8014ba4: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF5);
 8014ba6: 687b         	ldr	r3, [r7, #0x4]
 8014ba8: 2240         	movs	r2, #0x40
 8014baa: 60da         	str	r2, [r3, #0xc]
; }
 8014bac: bf00         	nop
 8014bae: 370c         	adds	r7, #0xc
 8014bb0: 46bd         	mov	sp, r7
 8014bb2: bc80         	pop	{r7}
 8014bb4: 4770         	bx	lr

08014bb6 <LL_DMA_ClearFlag_FE6>:
; {
 8014bb6: b480         	push	{r7}
 8014bb8: b083         	sub	sp, #0xc
 8014bba: af00         	add	r7, sp, #0x0
 8014bbc: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF6);
 8014bbe: 687b         	ldr	r3, [r7, #0x4]
 8014bc0: f44f 3280    	mov.w	r2, #0x10000
 8014bc4: 60da         	str	r2, [r3, #0xc]
; }
 8014bc6: bf00         	nop
 8014bc8: 370c         	adds	r7, #0xc
 8014bca: 46bd         	mov	sp, r7
 8014bcc: bc80         	pop	{r7}
 8014bce: 4770         	bx	lr

08014bd0 <LL_DMA_ClearFlag_FE7>:
; {
 8014bd0: b480         	push	{r7}
 8014bd2: b083         	sub	sp, #0xc
 8014bd4: af00         	add	r7, sp, #0x0
 8014bd6: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF7);
 8014bd8: 687b         	ldr	r3, [r7, #0x4]
 8014bda: f44f 0280    	mov.w	r2, #0x400000
 8014bde: 60da         	str	r2, [r3, #0xc]
; }
 8014be0: bf00         	nop
 8014be2: 370c         	adds	r7, #0xc
 8014be4: 46bd         	mov	sp, r7
 8014be6: bc80         	pop	{r7}
 8014be8: 4770         	bx	lr

08014bea <z_log_msg_runtime_create>:
; {
 8014bea: b580         	push	{r7, lr}
 8014bec: b08a         	sub	sp, #0x28
 8014bee: af04         	add	r7, sp, #0x10
 8014bf0: 60b9         	str	r1, [r7, #0x8]
 8014bf2: 607b         	str	r3, [r7, #0x4]
 8014bf4: 4603         	mov	r3, r0
 8014bf6: 73fb         	strb	r3, [r7, #0xf]
 8014bf8: 4613         	mov	r3, r2
 8014bfa: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8014bfc: f107 032c    	add.w	r3, r7, #0x2c
 8014c00: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8014c02: 7bba         	ldrb	r2, [r7, #0xe]
 8014c04: 7bf8         	ldrb	r0, [r7, #0xf]
 8014c06: 697b         	ldr	r3, [r7, #0x14]
 8014c08: 9303         	str	r3, [sp, #0xc]
 8014c0a: 6abb         	ldr	r3, [r7, #0x28]
 8014c0c: 9302         	str	r3, [sp, #0x8]
 8014c0e: 6a7b         	ldr	r3, [r7, #0x24]
 8014c10: 9301         	str	r3, [sp, #0x4]
 8014c12: 6a3b         	ldr	r3, [r7, #0x20]
 8014c14: 9300         	str	r3, [sp]
 8014c16: 687b         	ldr	r3, [r7, #0x4]
 8014c18: 68b9         	ldr	r1, [r7, #0x8]
 8014c1a: f7ed f827    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x12fb2
; }
 8014c1e: bf00         	nop
 8014c20: 3718         	adds	r7, #0x18
 8014c22: 46bd         	mov	sp, r7
 8014c24: bd80         	pop	{r7, pc}

08014c26 <stm32_dma_is_tc_irq_active>:
; {
 8014c26: b580         	push	{r7, lr}
 8014c28: b082         	sub	sp, #0x8
 8014c2a: af00         	add	r7, sp, #0x0
 8014c2c: 6078         	str	r0, [r7, #0x4]
 8014c2e: 6039         	str	r1, [r7]
; 	return LL_DMA_IsEnabledIT_TC(dma, dma_stm32_id_to_stream(id)) &&
 8014c30: 6838         	ldr	r0, [r7]
 8014c32: f7f2 fa43    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xdb7a
 8014c36: 4603         	mov	r3, r0
 8014c38: 4619         	mov	r1, r3
 8014c3a: 6878         	ldr	r0, [r7, #0x4]
 8014c3c: f7f2 fa06    	bl	0x800704c <LL_DMA_IsEnabledIT_TC> @ imm = #-0xdbf4
 8014c40: 4603         	mov	r3, r0
 8014c42: 2b00         	cmp	r3, #0x0
 8014c44: d008         	beq	0x8014c58 <stm32_dma_is_tc_irq_active+0x32> @ imm = #0x10
; 	       dma_stm32_is_tc_active(dma, id);
 8014c46: 6839         	ldr	r1, [r7]
 8014c48: 6878         	ldr	r0, [r7, #0x4]
 8014c4a: f7f2 fa93    	bl	0x8007174 <dma_stm32_is_tc_active> @ imm = #-0xdada
 8014c4e: 4603         	mov	r3, r0
; 	return LL_DMA_IsEnabledIT_TC(dma, dma_stm32_id_to_stream(id)) &&
 8014c50: 2b00         	cmp	r3, #0x0
 8014c52: d001         	beq	0x8014c58 <stm32_dma_is_tc_irq_active+0x32> @ imm = #0x2
 8014c54: 2301         	movs	r3, #0x1
 8014c56: e000         	b	0x8014c5a <stm32_dma_is_tc_irq_active+0x34> @ imm = #0x0
 8014c58: 2300         	movs	r3, #0x0
 8014c5a: f003 0301    	and	r3, r3, #0x1
 8014c5e: b2db         	uxtb	r3, r3
; }
 8014c60: 4618         	mov	r0, r3
 8014c62: 3708         	adds	r7, #0x8
 8014c64: 46bd         	mov	sp, r7
 8014c66: bd80         	pop	{r7, pc}

08014c68 <stm32_dma_is_ht_irq_active>:
; {
 8014c68: b580         	push	{r7, lr}
 8014c6a: b082         	sub	sp, #0x8
 8014c6c: af00         	add	r7, sp, #0x0
 8014c6e: 6078         	str	r0, [r7, #0x4]
 8014c70: 6039         	str	r1, [r7]
; 	return LL_DMA_IsEnabledIT_HT(dma, dma_stm32_id_to_stream(id)) &&
 8014c72: 6838         	ldr	r0, [r7]
 8014c74: f7f2 fa22    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xdbbc
 8014c78: 4603         	mov	r3, r0
 8014c7a: 4619         	mov	r1, r3
 8014c7c: 6878         	ldr	r0, [r7, #0x4]
 8014c7e: f7f2 f9c9    	bl	0x8007014 <LL_DMA_IsEnabledIT_HT> @ imm = #-0xdc6e
 8014c82: 4603         	mov	r3, r0
 8014c84: 2b00         	cmp	r3, #0x0
 8014c86: d008         	beq	0x8014c9a <stm32_dma_is_ht_irq_active+0x32> @ imm = #0x10
; 	       dma_stm32_is_ht_active(dma, id);
 8014c88: 6839         	ldr	r1, [r7]
 8014c8a: 6878         	ldr	r0, [r7, #0x4]
 8014c8c: f7f2 fa5a    	bl	0x8007144 <dma_stm32_is_ht_active> @ imm = #-0xdb4c
 8014c90: 4603         	mov	r3, r0
; 	return LL_DMA_IsEnabledIT_HT(dma, dma_stm32_id_to_stream(id)) &&
 8014c92: 2b00         	cmp	r3, #0x0
 8014c94: d001         	beq	0x8014c9a <stm32_dma_is_ht_irq_active+0x32> @ imm = #0x2
 8014c96: 2301         	movs	r3, #0x1
 8014c98: e000         	b	0x8014c9c <stm32_dma_is_ht_irq_active+0x34> @ imm = #0x0
 8014c9a: 2300         	movs	r3, #0x0
 8014c9c: f003 0301    	and	r3, r3, #0x1
 8014ca0: b2db         	uxtb	r3, r3
; }
 8014ca2: 4618         	mov	r0, r3
 8014ca4: 3708         	adds	r7, #0x8
 8014ca6: 46bd         	mov	sp, r7
 8014ca8: bd80         	pop	{r7, pc}

08014caa <stm32_dma_clear_stream_irq>:
; {
 8014caa: b580         	push	{r7, lr}
 8014cac: b082         	sub	sp, #0x8
 8014cae: af00         	add	r7, sp, #0x0
 8014cb0: 6078         	str	r0, [r7, #0x4]
 8014cb2: 6039         	str	r1, [r7]
; 	dma_stm32_clear_te(dma, id);
 8014cb4: 6839         	ldr	r1, [r7]
 8014cb6: 6878         	ldr	r0, [r7, #0x4]
 8014cb8: f7f2 fa74    	bl	0x80071a4 <dma_stm32_clear_te> @ imm = #-0xdb18
; 	dma_stm32_clear_dme(dma, id);
 8014cbc: 6839         	ldr	r1, [r7]
 8014cbe: 6878         	ldr	r0, [r7, #0x4]
 8014cc0: f7f2 fa82    	bl	0x80071c8 <dma_stm32_clear_dme> @ imm = #-0xdafc
; 	dma_stm32_clear_fe(dma, id);
 8014cc4: 6839         	ldr	r1, [r7]
 8014cc6: 6878         	ldr	r0, [r7, #0x4]
 8014cc8: f7f2 fa90    	bl	0x80071ec <dma_stm32_clear_fe> @ imm = #-0xdae0
; }
 8014ccc: bf00         	nop
 8014cce: 3708         	adds	r7, #0x8
 8014cd0: 46bd         	mov	sp, r7
 8014cd2: bd80         	pop	{r7, pc}

08014cd4 <stm32_dma_enable_stream>:
; {
 8014cd4: b580         	push	{r7, lr}
 8014cd6: b082         	sub	sp, #0x8
 8014cd8: af00         	add	r7, sp, #0x0
 8014cda: 6078         	str	r0, [r7, #0x4]
 8014cdc: 6039         	str	r1, [r7]
; 	LL_DMA_EnableStream(dma, dma_stm32_id_to_stream(id));
 8014cde: 6838         	ldr	r0, [r7]
 8014ce0: f7f2 f9ec    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xdc28
 8014ce4: 4603         	mov	r3, r0
 8014ce6: 4619         	mov	r1, r3
 8014ce8: 6878         	ldr	r0, [r7, #0x4]
 8014cea: f7f2 f91d    	bl	0x8006f28 <LL_DMA_EnableStream> @ imm = #-0xddc6
; }
 8014cee: bf00         	nop
 8014cf0: 3708         	adds	r7, #0x8
 8014cf2: 46bd         	mov	sp, r7
 8014cf4: bd80         	pop	{r7, pc}

08014cf6 <stm32_dma_is_enabled_stream>:
; {
 8014cf6: b580         	push	{r7, lr}
 8014cf8: b082         	sub	sp, #0x8
 8014cfa: af00         	add	r7, sp, #0x0
 8014cfc: 6078         	str	r0, [r7, #0x4]
 8014cfe: 6039         	str	r1, [r7]
; 	if (LL_DMA_IsEnabledStream(dma, dma_stm32_id_to_stream(id)) == 1) {
 8014d00: 6838         	ldr	r0, [r7]
 8014d02: f7f2 f9db    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xdc4a
 8014d06: 4603         	mov	r3, r0
 8014d08: 4619         	mov	r1, r3
 8014d0a: 6878         	ldr	r0, [r7, #0x4]
 8014d0c: f7f2 f948    	bl	0x8006fa0 <LL_DMA_IsEnabledStream> @ imm = #-0xdd70
 8014d10: 4603         	mov	r3, r0
 8014d12: 2b01         	cmp	r3, #0x1
 8014d14: d101         	bne	0x8014d1a <stm32_dma_is_enabled_stream+0x24> @ imm = #0x2
; 		return true;
 8014d16: 2301         	movs	r3, #0x1
 8014d18: e000         	b	0x8014d1c <stm32_dma_is_enabled_stream+0x26> @ imm = #0x0
; 	return false;
 8014d1a: 2300         	movs	r3, #0x0
; }
 8014d1c: 4618         	mov	r0, r3
 8014d1e: 3708         	adds	r7, #0x8
 8014d20: 46bd         	mov	sp, r7
 8014d22: bd80         	pop	{r7, pc}

08014d24 <stm32_dma_disable_stream>:
; {
 8014d24: b580         	push	{r7, lr}
 8014d26: b082         	sub	sp, #0x8
 8014d28: af00         	add	r7, sp, #0x0
 8014d2a: 6078         	str	r0, [r7, #0x4]
 8014d2c: 6039         	str	r1, [r7]
; 	LL_DMA_DisableStream(dma, dma_stm32_id_to_stream(id));
 8014d2e: 6838         	ldr	r0, [r7]
 8014d30: f7f2 f9c4    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xdc78
 8014d34: 4603         	mov	r3, r0
 8014d36: 4619         	mov	r1, r3
 8014d38: 6878         	ldr	r0, [r7, #0x4]
 8014d3a: f7f2 f913    	bl	0x8006f64 <LL_DMA_DisableStream> @ imm = #-0xddda
; 	while (stm32_dma_is_enabled_stream(dma, id)) {
 8014d3e: bf00         	nop
 8014d40: 6839         	ldr	r1, [r7]
 8014d42: 6878         	ldr	r0, [r7, #0x4]
 8014d44: f7ff ffd7    	bl	0x8014cf6 <stm32_dma_is_enabled_stream> @ imm = #-0x52
 8014d48: 4603         	mov	r3, r0
 8014d4a: 2b00         	cmp	r3, #0x0
 8014d4c: d1f8         	bne	0x8014d40 <stm32_dma_disable_stream+0x1c> @ imm = #-0x10
; 	dma_stm32_clear_tc(dma, id);
 8014d4e: 6839         	ldr	r1, [r7]
 8014d50: 6878         	ldr	r0, [r7, #0x4]
 8014d52: f7f2 f9e5    	bl	0x8007120 <dma_stm32_clear_tc> @ imm = #-0xdc36
; 	return 0;
 8014d56: 2300         	movs	r3, #0x0
; }
 8014d58: 4618         	mov	r0, r3
 8014d5a: 3708         	adds	r7, #0x8
 8014d5c: 46bd         	mov	sp, r7
 8014d5e: bd80         	pop	{r7, pc}

08014d60 <stm32_dma_disable_fifo_irq>:
; {
 8014d60: b580         	push	{r7, lr}
 8014d62: b082         	sub	sp, #0x8
 8014d64: af00         	add	r7, sp, #0x0
 8014d66: 6078         	str	r0, [r7, #0x4]
 8014d68: 6039         	str	r1, [r7]
; 	LL_DMA_DisableIT_FE(dma, dma_stm32_id_to_stream(id));
 8014d6a: 6838         	ldr	r0, [r7]
 8014d6c: f7f2 f9a6    	bl	0x80070bc <dma_stm32_id_to_stream> @ imm = #-0xdcb4
 8014d70: 4603         	mov	r3, r0
 8014d72: 4619         	mov	r1, r3
 8014d74: 6878         	ldr	r0, [r7, #0x4]
 8014d76: f7f2 f92f    	bl	0x8006fd8 <LL_DMA_DisableIT_FE> @ imm = #-0xdda2
; }
 8014d7a: bf00         	nop
 8014d7c: 3708         	adds	r7, #0x8
 8014d7e: 46bd         	mov	sp, r7
 8014d80: bd80         	pop	{r7, pc}

08014d82 <stm32_dma_check_fifo_mburst>:
; {
 8014d82: b480         	push	{r7}
 8014d84: b087         	sub	sp, #0x1c
 8014d86: af00         	add	r7, sp, #0x0
 8014d88: 6078         	str	r0, [r7, #0x4]
; 	uint32_t msize = DMAx->MemoryOrM2MDstDataSize;
 8014d8a: 687b         	ldr	r3, [r7, #0x4]
 8014d8c: 69db         	ldr	r3, [r3, #0x1c]
 8014d8e: 617b         	str	r3, [r7, #0x14]
; 	uint32_t fifo_level = DMAx->FIFOThreshold;
 8014d90: 687b         	ldr	r3, [r7, #0x4]
 8014d92: 6b1b         	ldr	r3, [r3, #0x30]
 8014d94: 613b         	str	r3, [r7, #0x10]
; 	uint32_t mburst = DMAx->MemBurst;
 8014d96: 687b         	ldr	r3, [r7, #0x4]
 8014d98: 6b5b         	ldr	r3, [r3, #0x34]
 8014d9a: 60fb         	str	r3, [r7, #0xc]
; 	switch (msize) {
 8014d9c: 697b         	ldr	r3, [r7, #0x14]
 8014d9e: f5b3 4f80    	cmp.w	r3, #0x4000
 8014da2: d049         	beq	0x8014e38 <stm32_dma_check_fifo_mburst+0xb6> @ imm = #0x92
 8014da4: 697b         	ldr	r3, [r7, #0x14]
 8014da6: f5b3 4f80    	cmp.w	r3, #0x4000
 8014daa: d84f         	bhi	0x8014e4c <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x9e
 8014dac: 697b         	ldr	r3, [r7, #0x14]
 8014dae: 2b00         	cmp	r3, #0x0
 8014db0: d004         	beq	0x8014dbc <stm32_dma_check_fifo_mburst+0x3a> @ imm = #0x8
 8014db2: 697b         	ldr	r3, [r7, #0x14]
 8014db4: f5b3 5f00    	cmp.w	r3, #0x2000
 8014db8: d024         	beq	0x8014e04 <stm32_dma_check_fifo_mburst+0x82> @ imm = #0x48
 8014dba: e047         	b	0x8014e4c <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x8e
 8014dbc: 68fb         	ldr	r3, [r7, #0xc]
 8014dbe: f1b3 7fc0    	cmp.w	r3, #0x1800000
 8014dc2: d016         	beq	0x8014df2 <stm32_dma_check_fifo_mburst+0x70> @ imm = #0x2c
 8014dc4: 68fb         	ldr	r3, [r7, #0xc]
 8014dc6: f1b3 7fc0    	cmp.w	r3, #0x1800000
 8014dca: d83e         	bhi	0x8014e4a <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x7c
 8014dcc: 68fb         	ldr	r3, [r7, #0xc]
 8014dce: f5b3 0f00    	cmp.w	r3, #0x800000
 8014dd2: d004         	beq	0x8014dde <stm32_dma_check_fifo_mburst+0x5c> @ imm = #0x8
 8014dd4: 68fb         	ldr	r3, [r7, #0xc]
 8014dd6: f1b3 7f80    	cmp.w	r3, #0x1000000
 8014dda: d002         	beq	0x8014de2 <stm32_dma_check_fifo_mburst+0x60> @ imm = #0x4
; 		break;
 8014ddc: e035         	b	0x8014e4a <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x6a
; 			return true;
 8014dde: 2301         	movs	r3, #0x1
 8014de0: e035         	b	0x8014e4e <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x6a
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_1_2 ||
 8014de2: 693b         	ldr	r3, [r7, #0x10]
 8014de4: 2b01         	cmp	r3, #0x1
 8014de6: d002         	beq	0x8014dee <stm32_dma_check_fifo_mburst+0x6c> @ imm = #0x4
 8014de8: 693b         	ldr	r3, [r7, #0x10]
 8014dea: 2b03         	cmp	r3, #0x3
 8014dec: d106         	bne	0x8014dfc <stm32_dma_check_fifo_mburst+0x7a> @ imm = #0xc
; 				return true;
 8014dee: 2301         	movs	r3, #0x1
 8014df0: e02d         	b	0x8014e4e <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x5a
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_FULL) {
 8014df2: 693b         	ldr	r3, [r7, #0x10]
 8014df4: 2b03         	cmp	r3, #0x3
 8014df6: d103         	bne	0x8014e00 <stm32_dma_check_fifo_mburst+0x7e> @ imm = #0x6
; 				return true;
 8014df8: 2301         	movs	r3, #0x1
 8014dfa: e028         	b	0x8014e4e <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x50
; 			break;
 8014dfc: bf00         	nop
 8014dfe: e024         	b	0x8014e4a <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x48
; 			break;
 8014e00: bf00         	nop
; 		break;
 8014e02: e022         	b	0x8014e4a <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x44
 8014e04: 68fb         	ldr	r3, [r7, #0xc]
 8014e06: f5b3 0f00    	cmp.w	r3, #0x800000
 8014e0a: d004         	beq	0x8014e16 <stm32_dma_check_fifo_mburst+0x94> @ imm = #0x8
 8014e0c: 68fb         	ldr	r3, [r7, #0xc]
 8014e0e: f1b3 7f80    	cmp.w	r3, #0x1000000
 8014e12: d008         	beq	0x8014e26 <stm32_dma_check_fifo_mburst+0xa4> @ imm = #0x10
; 		break;
 8014e14: e01a         	b	0x8014e4c <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x34
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_1_2 ||
 8014e16: 693b         	ldr	r3, [r7, #0x10]
 8014e18: 2b01         	cmp	r3, #0x1
 8014e1a: d002         	beq	0x8014e22 <stm32_dma_check_fifo_mburst+0xa0> @ imm = #0x4
 8014e1c: 693b         	ldr	r3, [r7, #0x10]
 8014e1e: 2b03         	cmp	r3, #0x3
 8014e20: d106         	bne	0x8014e30 <stm32_dma_check_fifo_mburst+0xae> @ imm = #0xc
; 				return true;
 8014e22: 2301         	movs	r3, #0x1
 8014e24: e013         	b	0x8014e4e <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x26
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_FULL) {
 8014e26: 693b         	ldr	r3, [r7, #0x10]
 8014e28: 2b03         	cmp	r3, #0x3
 8014e2a: d103         	bne	0x8014e34 <stm32_dma_check_fifo_mburst+0xb2> @ imm = #0x6
; 				return true;
 8014e2c: 2301         	movs	r3, #0x1
 8014e2e: e00e         	b	0x8014e4e <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x1c
; 			break;
 8014e30: bf00         	nop
 8014e32: e00b         	b	0x8014e4c <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x16
; 			break;
 8014e34: bf00         	nop
; 		break;
 8014e36: e009         	b	0x8014e4c <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x12
; 		if (mburst == LL_DMA_MBURST_INC4 &&
 8014e38: 68fb         	ldr	r3, [r7, #0xc]
 8014e3a: f5b3 0f00    	cmp.w	r3, #0x800000
 8014e3e: d105         	bne	0x8014e4c <stm32_dma_check_fifo_mburst+0xca> @ imm = #0xa
 8014e40: 693b         	ldr	r3, [r7, #0x10]
 8014e42: 2b03         	cmp	r3, #0x3
 8014e44: d102         	bne	0x8014e4c <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x4
; 			return true;
 8014e46: 2301         	movs	r3, #0x1
 8014e48: e001         	b	0x8014e4e <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x2
; 		break;
 8014e4a: bf00         	nop
; 	return false;
 8014e4c: 2300         	movs	r3, #0x0
; }
 8014e4e: 4618         	mov	r0, r3
 8014e50: 371c         	adds	r7, #0x1c
 8014e52: 46bd         	mov	sp, r7
 8014e54: bc80         	pop	{r7}
 8014e56: 4770         	bx	lr

08014e58 <z_snode_next_peek>:
; {
 8014e58: b480         	push	{r7}
 8014e5a: b083         	sub	sp, #0xc
 8014e5c: af00         	add	r7, sp, #0x0
 8014e5e: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 8014e60: 687b         	ldr	r3, [r7, #0x4]
 8014e62: 681b         	ldr	r3, [r3]
; }
 8014e64: 4618         	mov	r0, r3
 8014e66: 370c         	adds	r7, #0xc
 8014e68: 46bd         	mov	sp, r7
 8014e6a: bc80         	pop	{r7}
 8014e6c: 4770         	bx	lr

08014e6e <z_snode_next_set>:
; {
 8014e6e: b480         	push	{r7}
 8014e70: b083         	sub	sp, #0xc
 8014e72: af00         	add	r7, sp, #0x0
 8014e74: 6078         	str	r0, [r7, #0x4]
 8014e76: 6039         	str	r1, [r7]
; 	parent->next = child;
 8014e78: 687b         	ldr	r3, [r7, #0x4]
 8014e7a: 683a         	ldr	r2, [r7]
 8014e7c: 601a         	str	r2, [r3]
; }
 8014e7e: bf00         	nop
 8014e80: 370c         	adds	r7, #0xc
 8014e82: 46bd         	mov	sp, r7
 8014e84: bc80         	pop	{r7}
 8014e86: 4770         	bx	lr

08014e88 <z_slist_head_set>:
; {
 8014e88: b480         	push	{r7}
 8014e8a: b083         	sub	sp, #0xc
 8014e8c: af00         	add	r7, sp, #0x0
 8014e8e: 6078         	str	r0, [r7, #0x4]
 8014e90: 6039         	str	r1, [r7]
; 	list->head = node;
 8014e92: 687b         	ldr	r3, [r7, #0x4]
 8014e94: 683a         	ldr	r2, [r7]
 8014e96: 601a         	str	r2, [r3]
; }
 8014e98: bf00         	nop
 8014e9a: 370c         	adds	r7, #0xc
 8014e9c: 46bd         	mov	sp, r7
 8014e9e: bc80         	pop	{r7}
 8014ea0: 4770         	bx	lr

08014ea2 <z_slist_tail_set>:
; {
 8014ea2: b480         	push	{r7}
 8014ea4: b083         	sub	sp, #0xc
 8014ea6: af00         	add	r7, sp, #0x0
 8014ea8: 6078         	str	r0, [r7, #0x4]
 8014eaa: 6039         	str	r1, [r7]
; 	list->tail = node;
 8014eac: 687b         	ldr	r3, [r7, #0x4]
 8014eae: 683a         	ldr	r2, [r7]
 8014eb0: 605a         	str	r2, [r3, #0x4]
; }
 8014eb2: bf00         	nop
 8014eb4: 370c         	adds	r7, #0xc
 8014eb6: 46bd         	mov	sp, r7
 8014eb8: bc80         	pop	{r7}
 8014eba: 4770         	bx	lr

08014ebc <sys_slist_peek_head>:
; {
 8014ebc: b480         	push	{r7}
 8014ebe: b083         	sub	sp, #0xc
 8014ec0: af00         	add	r7, sp, #0x0
 8014ec2: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 8014ec4: 687b         	ldr	r3, [r7, #0x4]
 8014ec6: 681b         	ldr	r3, [r3]
; }
 8014ec8: 4618         	mov	r0, r3
 8014eca: 370c         	adds	r7, #0xc
 8014ecc: 46bd         	mov	sp, r7
 8014ece: bc80         	pop	{r7}
 8014ed0: 4770         	bx	lr

08014ed2 <sys_slist_peek_tail>:
; {
 8014ed2: b480         	push	{r7}
 8014ed4: b083         	sub	sp, #0xc
 8014ed6: af00         	add	r7, sp, #0x0
 8014ed8: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 8014eda: 687b         	ldr	r3, [r7, #0x4]
 8014edc: 685b         	ldr	r3, [r3, #0x4]
; }
 8014ede: 4618         	mov	r0, r3
 8014ee0: 370c         	adds	r7, #0xc
 8014ee2: 46bd         	mov	sp, r7
 8014ee4: bc80         	pop	{r7}
 8014ee6: 4770         	bx	lr

08014ee8 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 8014ee8: b580         	push	{r7, lr}
 8014eea: b082         	sub	sp, #0x8
 8014eec: af00         	add	r7, sp, #0x0
 8014eee: 6078         	str	r0, [r7, #0x4]
 8014ef0: 6878         	ldr	r0, [r7, #0x4]
 8014ef2: f7ff ffe3    	bl	0x8014ebc <sys_slist_peek_head> @ imm = #-0x3a
 8014ef6: 4603         	mov	r3, r0
 8014ef8: 2b00         	cmp	r3, #0x0
 8014efa: bf0c         	ite	eq
 8014efc: 2301         	moveq	r3, #0x1
 8014efe: 2300         	movne	r3, #0x0
 8014f00: b2db         	uxtb	r3, r3
 8014f02: 4618         	mov	r0, r3
 8014f04: 3708         	adds	r7, #0x8
 8014f06: 46bd         	mov	sp, r7
 8014f08: bd80         	pop	{r7, pc}

08014f0a <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8014f0a: b580         	push	{r7, lr}
 8014f0c: b082         	sub	sp, #0x8
 8014f0e: af00         	add	r7, sp, #0x0
 8014f10: 6078         	str	r0, [r7, #0x4]
 8014f12: 6878         	ldr	r0, [r7, #0x4]
 8014f14: f7ff ffa0    	bl	0x8014e58 <z_snode_next_peek> @ imm = #-0xc0
 8014f18: 4603         	mov	r3, r0
 8014f1a: 4618         	mov	r0, r3
 8014f1c: 3708         	adds	r7, #0x8
 8014f1e: 46bd         	mov	sp, r7
 8014f20: bd80         	pop	{r7, pc}

08014f22 <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 8014f22: b580         	push	{r7, lr}
 8014f24: b082         	sub	sp, #0x8
 8014f26: af00         	add	r7, sp, #0x0
 8014f28: 6078         	str	r0, [r7, #0x4]
 8014f2a: 687b         	ldr	r3, [r7, #0x4]
 8014f2c: 2b00         	cmp	r3, #0x0
 8014f2e: d004         	beq	0x8014f3a <sys_slist_peek_next+0x18> @ imm = #0x8
 8014f30: 6878         	ldr	r0, [r7, #0x4]
 8014f32: f7ff ffea    	bl	0x8014f0a <sys_slist_peek_next_no_check> @ imm = #-0x2c
 8014f36: 4603         	mov	r3, r0
 8014f38: e000         	b	0x8014f3c <sys_slist_peek_next+0x1a> @ imm = #0x0
 8014f3a: 2300         	movs	r3, #0x0
 8014f3c: 4618         	mov	r0, r3
 8014f3e: 3708         	adds	r7, #0x8
 8014f40: 46bd         	mov	sp, r7
 8014f42: bd80         	pop	{r7, pc}

08014f44 <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 8014f44: b580         	push	{r7, lr}
 8014f46: b082         	sub	sp, #0x8
 8014f48: af00         	add	r7, sp, #0x0
 8014f4a: 6078         	str	r0, [r7, #0x4]
 8014f4c: 6039         	str	r1, [r7]
 8014f4e: 6878         	ldr	r0, [r7, #0x4]
 8014f50: f7ff ffb4    	bl	0x8014ebc <sys_slist_peek_head> @ imm = #-0x98
 8014f54: 4603         	mov	r3, r0
 8014f56: 4619         	mov	r1, r3
 8014f58: 6838         	ldr	r0, [r7]
 8014f5a: f7ff ff88    	bl	0x8014e6e <z_snode_next_set> @ imm = #-0xf0
 8014f5e: 6839         	ldr	r1, [r7]
 8014f60: 6878         	ldr	r0, [r7, #0x4]
 8014f62: f7ff ff91    	bl	0x8014e88 <z_slist_head_set> @ imm = #-0xde
 8014f66: 6878         	ldr	r0, [r7, #0x4]
 8014f68: f7ff ffb3    	bl	0x8014ed2 <sys_slist_peek_tail> @ imm = #-0x9a
 8014f6c: 4603         	mov	r3, r0
 8014f6e: 2b00         	cmp	r3, #0x0
 8014f70: d107         	bne	0x8014f82 <sys_slist_prepend+0x3e> @ imm = #0xe
 8014f72: 6878         	ldr	r0, [r7, #0x4]
 8014f74: f7ff ffa2    	bl	0x8014ebc <sys_slist_peek_head> @ imm = #-0xbc
 8014f78: 4603         	mov	r3, r0
 8014f7a: 4619         	mov	r1, r3
 8014f7c: 6878         	ldr	r0, [r7, #0x4]
 8014f7e: f7ff ff90    	bl	0x8014ea2 <z_slist_tail_set> @ imm = #-0xe0
 8014f82: 3708         	adds	r7, #0x8
 8014f84: 46bd         	mov	sp, r7
 8014f86: bd80         	pop	{r7, pc}

08014f88 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 8014f88: b580         	push	{r7, lr}
 8014f8a: b084         	sub	sp, #0x10
 8014f8c: af00         	add	r7, sp, #0x0
 8014f8e: 60f8         	str	r0, [r7, #0xc]
 8014f90: 60b9         	str	r1, [r7, #0x8]
 8014f92: 607a         	str	r2, [r7, #0x4]
 8014f94: 68bb         	ldr	r3, [r7, #0x8]
 8014f96: 2b00         	cmp	r3, #0x0
 8014f98: d117         	bne	0x8014fca <sys_slist_remove+0x42> @ imm = #0x2e
 8014f9a: 6878         	ldr	r0, [r7, #0x4]
 8014f9c: f7ff ff5c    	bl	0x8014e58 <z_snode_next_peek> @ imm = #-0x148
 8014fa0: 4603         	mov	r3, r0
 8014fa2: 4619         	mov	r1, r3
 8014fa4: 68f8         	ldr	r0, [r7, #0xc]
 8014fa6: f7ff ff6f    	bl	0x8014e88 <z_slist_head_set> @ imm = #-0x122
 8014faa: 68f8         	ldr	r0, [r7, #0xc]
 8014fac: f7ff ff91    	bl	0x8014ed2 <sys_slist_peek_tail> @ imm = #-0xde
 8014fb0: 4602         	mov	r2, r0
 8014fb2: 687b         	ldr	r3, [r7, #0x4]
 8014fb4: 4293         	cmp	r3, r2
 8014fb6: d11b         	bne	0x8014ff0 <sys_slist_remove+0x68> @ imm = #0x36
 8014fb8: 68f8         	ldr	r0, [r7, #0xc]
 8014fba: f7ff ff7f    	bl	0x8014ebc <sys_slist_peek_head> @ imm = #-0x102
 8014fbe: 4603         	mov	r3, r0
 8014fc0: 4619         	mov	r1, r3
 8014fc2: 68f8         	ldr	r0, [r7, #0xc]
 8014fc4: f7ff ff6d    	bl	0x8014ea2 <z_slist_tail_set> @ imm = #-0x126
 8014fc8: e012         	b	0x8014ff0 <sys_slist_remove+0x68> @ imm = #0x24
 8014fca: 6878         	ldr	r0, [r7, #0x4]
 8014fcc: f7ff ff44    	bl	0x8014e58 <z_snode_next_peek> @ imm = #-0x178
 8014fd0: 4603         	mov	r3, r0
 8014fd2: 4619         	mov	r1, r3
 8014fd4: 68b8         	ldr	r0, [r7, #0x8]
 8014fd6: f7ff ff4a    	bl	0x8014e6e <z_snode_next_set> @ imm = #-0x16c
 8014fda: 68f8         	ldr	r0, [r7, #0xc]
 8014fdc: f7ff ff79    	bl	0x8014ed2 <sys_slist_peek_tail> @ imm = #-0x10e
 8014fe0: 4602         	mov	r2, r0
 8014fe2: 687b         	ldr	r3, [r7, #0x4]
 8014fe4: 4293         	cmp	r3, r2
 8014fe6: d103         	bne	0x8014ff0 <sys_slist_remove+0x68> @ imm = #0x6
 8014fe8: 68b9         	ldr	r1, [r7, #0x8]
 8014fea: 68f8         	ldr	r0, [r7, #0xc]
 8014fec: f7ff ff59    	bl	0x8014ea2 <z_slist_tail_set> @ imm = #-0x14e
 8014ff0: 2100         	movs	r1, #0x0
 8014ff2: 6878         	ldr	r0, [r7, #0x4]
 8014ff4: f7ff ff3b    	bl	0x8014e6e <z_snode_next_set> @ imm = #-0x18a
 8014ff8: 3710         	adds	r7, #0x10
 8014ffa: 46bd         	mov	sp, r7
 8014ffc: bd80         	pop	{r7, pc}

08014ffe <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8014ffe: b580         	push	{r7, lr}
 8015000: b084         	sub	sp, #0x10
 8015002: af00         	add	r7, sp, #0x0
 8015004: 6078         	str	r0, [r7, #0x4]
 8015006: 6039         	str	r1, [r7]
 8015008: 2300         	movs	r3, #0x0
 801500a: 60fb         	str	r3, [r7, #0xc]
 801500c: 6878         	ldr	r0, [r7, #0x4]
 801500e: f7ff ff55    	bl	0x8014ebc <sys_slist_peek_head> @ imm = #-0x156
 8015012: 60b8         	str	r0, [r7, #0x8]
 8015014: e010         	b	0x8015038 <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 8015016: 68ba         	ldr	r2, [r7, #0x8]
 8015018: 683b         	ldr	r3, [r7]
 801501a: 429a         	cmp	r2, r3
 801501c: d106         	bne	0x801502c <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 801501e: 683a         	ldr	r2, [r7]
 8015020: 68f9         	ldr	r1, [r7, #0xc]
 8015022: 6878         	ldr	r0, [r7, #0x4]
 8015024: f7ff ffb0    	bl	0x8014f88 <sys_slist_remove> @ imm = #-0xa0
 8015028: 2301         	movs	r3, #0x1
 801502a: e009         	b	0x8015040 <sys_slist_find_and_remove+0x42> @ imm = #0x12
 801502c: 68bb         	ldr	r3, [r7, #0x8]
 801502e: 60fb         	str	r3, [r7, #0xc]
 8015030: 68b8         	ldr	r0, [r7, #0x8]
 8015032: f7ff ff76    	bl	0x8014f22 <sys_slist_peek_next> @ imm = #-0x114
 8015036: 60b8         	str	r0, [r7, #0x8]
 8015038: 68bb         	ldr	r3, [r7, #0x8]
 801503a: 2b00         	cmp	r3, #0x0
 801503c: d1eb         	bne	0x8015016 <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 801503e: 2300         	movs	r3, #0x0
 8015040: 4618         	mov	r0, r3
 8015042: 3710         	adds	r7, #0x10
 8015044: 46bd         	mov	sp, r7
 8015046: bd80         	pop	{r7, pc}

08015048 <device_is_ready>:
; {
 8015048: b580         	push	{r7, lr}
 801504a: b082         	sub	sp, #0x8
 801504c: af00         	add	r7, sp, #0x0
 801504e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8015050: 6878         	ldr	r0, [r7, #0x4]
 8015052: f003 fbf0    	bl	0x8018836 <z_impl_device_is_ready> @ imm = #0x37e0
 8015056: 4603         	mov	r3, r0
; }
 8015058: 4618         	mov	r0, r3
 801505a: 3708         	adds	r7, #0x8
 801505c: 46bd         	mov	sp, r7
 801505e: bd80         	pop	{r7, pc}

08015060 <LL_GPIO_SetPinMode>:
; {
 8015060: b480         	push	{r7}
 8015062: b08b         	sub	sp, #0x2c
 8015064: af00         	add	r7, sp, #0x0
 8015066: 60f8         	str	r0, [r7, #0xc]
 8015068: 60b9         	str	r1, [r7, #0x8]
 801506a: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 801506c: 68fb         	ldr	r3, [r7, #0xc]
 801506e: 681a         	ldr	r2, [r3]
 8015070: 68bb         	ldr	r3, [r7, #0x8]
 8015072: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8015074: 697b         	ldr	r3, [r7, #0x14]
 8015076: fa93 f3a3    	rbit	r3, r3
 801507a: 613b         	str	r3, [r7, #0x10]
;   return result;
 801507c: 693b         	ldr	r3, [r7, #0x10]
 801507e: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8015080: 69bb         	ldr	r3, [r7, #0x18]
 8015082: 2b00         	cmp	r3, #0x0
 8015084: d101         	bne	0x801508a <LL_GPIO_SetPinMode+0x2a> @ imm = #0x2
;     return 32U;
 8015086: 2320         	movs	r3, #0x20
 8015088: e003         	b	0x8015092 <LL_GPIO_SetPinMode+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 801508a: 69bb         	ldr	r3, [r7, #0x18]
 801508c: fab3 f383    	clz	r3, r3
 8015090: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8015092: 005b         	lsls	r3, r3, #0x1
 8015094: 2103         	movs	r1, #0x3
 8015096: fa01 f303    	lsl.w	r3, r1, r3
 801509a: 43db         	mvns	r3, r3
 801509c: 401a         	ands	r2, r3
 801509e: 68bb         	ldr	r3, [r7, #0x8]
 80150a0: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80150a2: 6a3b         	ldr	r3, [r7, #0x20]
 80150a4: fa93 f3a3    	rbit	r3, r3
 80150a8: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 80150aa: 69fb         	ldr	r3, [r7, #0x1c]
 80150ac: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 80150ae: 6a7b         	ldr	r3, [r7, #0x24]
 80150b0: 2b00         	cmp	r3, #0x0
 80150b2: d101         	bne	0x80150b8 <LL_GPIO_SetPinMode+0x58> @ imm = #0x2
;     return 32U;
 80150b4: 2320         	movs	r3, #0x20
 80150b6: e003         	b	0x80150c0 <LL_GPIO_SetPinMode+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 80150b8: 6a7b         	ldr	r3, [r7, #0x24]
 80150ba: fab3 f383    	clz	r3, r3
 80150be: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 80150c0: 005b         	lsls	r3, r3, #0x1
 80150c2: 6879         	ldr	r1, [r7, #0x4]
 80150c4: fa01 f303    	lsl.w	r3, r1, r3
 80150c8: 431a         	orrs	r2, r3
 80150ca: 68fb         	ldr	r3, [r7, #0xc]
 80150cc: 601a         	str	r2, [r3]
; }
 80150ce: bf00         	nop
 80150d0: 372c         	adds	r7, #0x2c
 80150d2: 46bd         	mov	sp, r7
 80150d4: bc80         	pop	{r7}
 80150d6: 4770         	bx	lr

080150d8 <LL_GPIO_SetPinOutputType>:
; {
 80150d8: b480         	push	{r7}
 80150da: b085         	sub	sp, #0x14
 80150dc: af00         	add	r7, sp, #0x0
 80150de: 60f8         	str	r0, [r7, #0xc]
 80150e0: 60b9         	str	r1, [r7, #0x8]
 80150e2: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 80150e4: 68fb         	ldr	r3, [r7, #0xc]
 80150e6: 685a         	ldr	r2, [r3, #0x4]
 80150e8: 68bb         	ldr	r3, [r7, #0x8]
 80150ea: 43db         	mvns	r3, r3
 80150ec: 401a         	ands	r2, r3
 80150ee: 68bb         	ldr	r3, [r7, #0x8]
 80150f0: 6879         	ldr	r1, [r7, #0x4]
 80150f2: fb01 f303    	mul	r3, r1, r3
 80150f6: 431a         	orrs	r2, r3
 80150f8: 68fb         	ldr	r3, [r7, #0xc]
 80150fa: 605a         	str	r2, [r3, #0x4]
; }
 80150fc: bf00         	nop
 80150fe: 3714         	adds	r7, #0x14
 8015100: 46bd         	mov	sp, r7
 8015102: bc80         	pop	{r7}
 8015104: 4770         	bx	lr

08015106 <LL_GPIO_SetPinSpeed>:
; {
 8015106: b480         	push	{r7}
 8015108: b08b         	sub	sp, #0x2c
 801510a: af00         	add	r7, sp, #0x0
 801510c: 60f8         	str	r0, [r7, #0xc]
 801510e: 60b9         	str	r1, [r7, #0x8]
 8015110: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8015112: 68fb         	ldr	r3, [r7, #0xc]
 8015114: 689a         	ldr	r2, [r3, #0x8]
 8015116: 68bb         	ldr	r3, [r7, #0x8]
 8015118: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801511a: 697b         	ldr	r3, [r7, #0x14]
 801511c: fa93 f3a3    	rbit	r3, r3
 8015120: 613b         	str	r3, [r7, #0x10]
;   return result;
 8015122: 693b         	ldr	r3, [r7, #0x10]
 8015124: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8015126: 69bb         	ldr	r3, [r7, #0x18]
 8015128: 2b00         	cmp	r3, #0x0
 801512a: d101         	bne	0x8015130 <LL_GPIO_SetPinSpeed+0x2a> @ imm = #0x2
;     return 32U;
 801512c: 2320         	movs	r3, #0x20
 801512e: e003         	b	0x8015138 <LL_GPIO_SetPinSpeed+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 8015130: 69bb         	ldr	r3, [r7, #0x18]
 8015132: fab3 f383    	clz	r3, r3
 8015136: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8015138: 005b         	lsls	r3, r3, #0x1
 801513a: 2103         	movs	r1, #0x3
 801513c: fa01 f303    	lsl.w	r3, r1, r3
 8015140: 43db         	mvns	r3, r3
 8015142: 401a         	ands	r2, r3
 8015144: 68bb         	ldr	r3, [r7, #0x8]
 8015146: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8015148: 6a3b         	ldr	r3, [r7, #0x20]
 801514a: fa93 f3a3    	rbit	r3, r3
 801514e: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 8015150: 69fb         	ldr	r3, [r7, #0x1c]
 8015152: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 8015154: 6a7b         	ldr	r3, [r7, #0x24]
 8015156: 2b00         	cmp	r3, #0x0
 8015158: d101         	bne	0x801515e <LL_GPIO_SetPinSpeed+0x58> @ imm = #0x2
;     return 32U;
 801515a: 2320         	movs	r3, #0x20
 801515c: e003         	b	0x8015166 <LL_GPIO_SetPinSpeed+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 801515e: 6a7b         	ldr	r3, [r7, #0x24]
 8015160: fab3 f383    	clz	r3, r3
 8015164: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8015166: 005b         	lsls	r3, r3, #0x1
 8015168: 6879         	ldr	r1, [r7, #0x4]
 801516a: fa01 f303    	lsl.w	r3, r1, r3
 801516e: 431a         	orrs	r2, r3
 8015170: 68fb         	ldr	r3, [r7, #0xc]
 8015172: 609a         	str	r2, [r3, #0x8]
; }
 8015174: bf00         	nop
 8015176: 372c         	adds	r7, #0x2c
 8015178: 46bd         	mov	sp, r7
 801517a: bc80         	pop	{r7}
 801517c: 4770         	bx	lr

0801517e <LL_GPIO_SetPinPull>:
; {
 801517e: b480         	push	{r7}
 8015180: b08b         	sub	sp, #0x2c
 8015182: af00         	add	r7, sp, #0x0
 8015184: 60f8         	str	r0, [r7, #0xc]
 8015186: 60b9         	str	r1, [r7, #0x8]
 8015188: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 801518a: 68fb         	ldr	r3, [r7, #0xc]
 801518c: 68da         	ldr	r2, [r3, #0xc]
 801518e: 68bb         	ldr	r3, [r7, #0x8]
 8015190: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8015192: 697b         	ldr	r3, [r7, #0x14]
 8015194: fa93 f3a3    	rbit	r3, r3
 8015198: 613b         	str	r3, [r7, #0x10]
;   return result;
 801519a: 693b         	ldr	r3, [r7, #0x10]
 801519c: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 801519e: 69bb         	ldr	r3, [r7, #0x18]
 80151a0: 2b00         	cmp	r3, #0x0
 80151a2: d101         	bne	0x80151a8 <LL_GPIO_SetPinPull+0x2a> @ imm = #0x2
;     return 32U;
 80151a4: 2320         	movs	r3, #0x20
 80151a6: e003         	b	0x80151b0 <LL_GPIO_SetPinPull+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 80151a8: 69bb         	ldr	r3, [r7, #0x18]
 80151aa: fab3 f383    	clz	r3, r3
 80151ae: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 80151b0: 005b         	lsls	r3, r3, #0x1
 80151b2: 2103         	movs	r1, #0x3
 80151b4: fa01 f303    	lsl.w	r3, r1, r3
 80151b8: 43db         	mvns	r3, r3
 80151ba: 401a         	ands	r2, r3
 80151bc: 68bb         	ldr	r3, [r7, #0x8]
 80151be: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80151c0: 6a3b         	ldr	r3, [r7, #0x20]
 80151c2: fa93 f3a3    	rbit	r3, r3
 80151c6: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 80151c8: 69fb         	ldr	r3, [r7, #0x1c]
 80151ca: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 80151cc: 6a7b         	ldr	r3, [r7, #0x24]
 80151ce: 2b00         	cmp	r3, #0x0
 80151d0: d101         	bne	0x80151d6 <LL_GPIO_SetPinPull+0x58> @ imm = #0x2
;     return 32U;
 80151d2: 2320         	movs	r3, #0x20
 80151d4: e003         	b	0x80151de <LL_GPIO_SetPinPull+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 80151d6: 6a7b         	ldr	r3, [r7, #0x24]
 80151d8: fab3 f383    	clz	r3, r3
 80151dc: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 80151de: 005b         	lsls	r3, r3, #0x1
 80151e0: 6879         	ldr	r1, [r7, #0x4]
 80151e2: fa01 f303    	lsl.w	r3, r1, r3
 80151e6: 431a         	orrs	r2, r3
 80151e8: 68fb         	ldr	r3, [r7, #0xc]
 80151ea: 60da         	str	r2, [r3, #0xc]
; }
 80151ec: bf00         	nop
 80151ee: 372c         	adds	r7, #0x2c
 80151f0: 46bd         	mov	sp, r7
 80151f2: bc80         	pop	{r7}
 80151f4: 4770         	bx	lr

080151f6 <LL_GPIO_SetAFPin_0_7>:
; {
 80151f6: b480         	push	{r7}
 80151f8: b08b         	sub	sp, #0x2c
 80151fa: af00         	add	r7, sp, #0x0
 80151fc: 60f8         	str	r0, [r7, #0xc]
 80151fe: 60b9         	str	r1, [r7, #0x8]
 8015200: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8015202: 68fb         	ldr	r3, [r7, #0xc]
 8015204: 6a1a         	ldr	r2, [r3, #0x20]
 8015206: 68bb         	ldr	r3, [r7, #0x8]
 8015208: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801520a: 697b         	ldr	r3, [r7, #0x14]
 801520c: fa93 f3a3    	rbit	r3, r3
 8015210: 613b         	str	r3, [r7, #0x10]
;   return result;
 8015212: 693b         	ldr	r3, [r7, #0x10]
 8015214: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8015216: 69bb         	ldr	r3, [r7, #0x18]
 8015218: 2b00         	cmp	r3, #0x0
 801521a: d101         	bne	0x8015220 <LL_GPIO_SetAFPin_0_7+0x2a> @ imm = #0x2
;     return 32U;
 801521c: 2320         	movs	r3, #0x20
 801521e: e003         	b	0x8015228 <LL_GPIO_SetAFPin_0_7+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 8015220: 69bb         	ldr	r3, [r7, #0x18]
 8015222: fab3 f383    	clz	r3, r3
 8015226: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8015228: 009b         	lsls	r3, r3, #0x2
 801522a: 210f         	movs	r1, #0xf
 801522c: fa01 f303    	lsl.w	r3, r1, r3
 8015230: 43db         	mvns	r3, r3
 8015232: 401a         	ands	r2, r3
 8015234: 68bb         	ldr	r3, [r7, #0x8]
 8015236: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8015238: 6a3b         	ldr	r3, [r7, #0x20]
 801523a: fa93 f3a3    	rbit	r3, r3
 801523e: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 8015240: 69fb         	ldr	r3, [r7, #0x1c]
 8015242: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 8015244: 6a7b         	ldr	r3, [r7, #0x24]
 8015246: 2b00         	cmp	r3, #0x0
 8015248: d101         	bne	0x801524e <LL_GPIO_SetAFPin_0_7+0x58> @ imm = #0x2
;     return 32U;
 801524a: 2320         	movs	r3, #0x20
 801524c: e003         	b	0x8015256 <LL_GPIO_SetAFPin_0_7+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 801524e: 6a7b         	ldr	r3, [r7, #0x24]
 8015250: fab3 f383    	clz	r3, r3
 8015254: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8015256: 009b         	lsls	r3, r3, #0x2
 8015258: 6879         	ldr	r1, [r7, #0x4]
 801525a: fa01 f303    	lsl.w	r3, r1, r3
 801525e: 431a         	orrs	r2, r3
 8015260: 68fb         	ldr	r3, [r7, #0xc]
 8015262: 621a         	str	r2, [r3, #0x20]
; }
 8015264: bf00         	nop
 8015266: 372c         	adds	r7, #0x2c
 8015268: 46bd         	mov	sp, r7
 801526a: bc80         	pop	{r7}
 801526c: 4770         	bx	lr

0801526e <LL_GPIO_SetAFPin_8_15>:
; {
 801526e: b480         	push	{r7}
 8015270: b08b         	sub	sp, #0x2c
 8015272: af00         	add	r7, sp, #0x0
 8015274: 60f8         	str	r0, [r7, #0xc]
 8015276: 60b9         	str	r1, [r7, #0x8]
 8015278: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 801527a: 68fb         	ldr	r3, [r7, #0xc]
 801527c: 6a5a         	ldr	r2, [r3, #0x24]
 801527e: 68bb         	ldr	r3, [r7, #0x8]
 8015280: 0a1b         	lsrs	r3, r3, #0x8
 8015282: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8015284: 697b         	ldr	r3, [r7, #0x14]
 8015286: fa93 f3a3    	rbit	r3, r3
 801528a: 613b         	str	r3, [r7, #0x10]
;   return result;
 801528c: 693b         	ldr	r3, [r7, #0x10]
 801528e: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8015290: 69bb         	ldr	r3, [r7, #0x18]
 8015292: 2b00         	cmp	r3, #0x0
 8015294: d101         	bne	0x801529a <LL_GPIO_SetAFPin_8_15+0x2c> @ imm = #0x2
;     return 32U;
 8015296: 2320         	movs	r3, #0x20
 8015298: e003         	b	0x80152a2 <LL_GPIO_SetAFPin_8_15+0x34> @ imm = #0x6
;   return __builtin_clz(value);
 801529a: 69bb         	ldr	r3, [r7, #0x18]
 801529c: fab3 f383    	clz	r3, r3
 80152a0: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 80152a2: 009b         	lsls	r3, r3, #0x2
 80152a4: 210f         	movs	r1, #0xf
 80152a6: fa01 f303    	lsl.w	r3, r1, r3
 80152aa: 43db         	mvns	r3, r3
 80152ac: 401a         	ands	r2, r3
 80152ae: 68bb         	ldr	r3, [r7, #0x8]
 80152b0: 0a1b         	lsrs	r3, r3, #0x8
 80152b2: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80152b4: 6a3b         	ldr	r3, [r7, #0x20]
 80152b6: fa93 f3a3    	rbit	r3, r3
 80152ba: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 80152bc: 69fb         	ldr	r3, [r7, #0x1c]
 80152be: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 80152c0: 6a7b         	ldr	r3, [r7, #0x24]
 80152c2: 2b00         	cmp	r3, #0x0
 80152c4: d101         	bne	0x80152ca <LL_GPIO_SetAFPin_8_15+0x5c> @ imm = #0x2
;     return 32U;
 80152c6: 2320         	movs	r3, #0x20
 80152c8: e003         	b	0x80152d2 <LL_GPIO_SetAFPin_8_15+0x64> @ imm = #0x6
;   return __builtin_clz(value);
 80152ca: 6a7b         	ldr	r3, [r7, #0x24]
 80152cc: fab3 f383    	clz	r3, r3
 80152d0: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 80152d2: 009b         	lsls	r3, r3, #0x2
 80152d4: 6879         	ldr	r1, [r7, #0x4]
 80152d6: fa01 f303    	lsl.w	r3, r1, r3
 80152da: 431a         	orrs	r2, r3
 80152dc: 68fb         	ldr	r3, [r7, #0xc]
 80152de: 625a         	str	r2, [r3, #0x24]
; }
 80152e0: bf00         	nop
 80152e2: 372c         	adds	r7, #0x2c
 80152e4: 46bd         	mov	sp, r7
 80152e6: bc80         	pop	{r7}
 80152e8: 4770         	bx	lr

080152ea <LL_GPIO_ReadInputPort>:
; {
 80152ea: b480         	push	{r7}
 80152ec: b083         	sub	sp, #0xc
 80152ee: af00         	add	r7, sp, #0x0
 80152f0: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->IDR));
 80152f2: 687b         	ldr	r3, [r7, #0x4]
 80152f4: 691b         	ldr	r3, [r3, #0x10]
; }
 80152f6: 4618         	mov	r0, r3
 80152f8: 370c         	adds	r7, #0xc
 80152fa: 46bd         	mov	sp, r7
 80152fc: bc80         	pop	{r7}
 80152fe: 4770         	bx	lr

08015300 <LL_GPIO_WriteOutputPort>:
; {
 8015300: b480         	push	{r7}
 8015302: b083         	sub	sp, #0xc
 8015304: af00         	add	r7, sp, #0x0
 8015306: 6078         	str	r0, [r7, #0x4]
 8015308: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->ODR, PortValue);
 801530a: 687b         	ldr	r3, [r7, #0x4]
 801530c: 683a         	ldr	r2, [r7]
 801530e: 615a         	str	r2, [r3, #0x14]
; }
 8015310: bf00         	nop
 8015312: 370c         	adds	r7, #0xc
 8015314: 46bd         	mov	sp, r7
 8015316: bc80         	pop	{r7}
 8015318: 4770         	bx	lr

0801531a <LL_GPIO_ReadOutputPort>:
; {
 801531a: b480         	push	{r7}
 801531c: b083         	sub	sp, #0xc
 801531e: af00         	add	r7, sp, #0x0
 8015320: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->ODR));
 8015322: 687b         	ldr	r3, [r7, #0x4]
 8015324: 695b         	ldr	r3, [r3, #0x14]
; }
 8015326: 4618         	mov	r0, r3
 8015328: 370c         	adds	r7, #0xc
 801532a: 46bd         	mov	sp, r7
 801532c: bc80         	pop	{r7}
 801532e: 4770         	bx	lr

08015330 <LL_GPIO_ResetOutputPin>:
; {
 8015330: b480         	push	{r7}
 8015332: b083         	sub	sp, #0xc
 8015334: af00         	add	r7, sp, #0x0
 8015336: 6078         	str	r0, [r7, #0x4]
 8015338: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->BSRR, (PinMask << 16));
 801533a: 683b         	ldr	r3, [r7]
 801533c: 041a         	lsls	r2, r3, #0x10
 801533e: 687b         	ldr	r3, [r7, #0x4]
 8015340: 619a         	str	r2, [r3, #0x18]
; }
 8015342: bf00         	nop
 8015344: 370c         	adds	r7, #0xc
 8015346: 46bd         	mov	sp, r7
 8015348: bc80         	pop	{r7}
 801534a: 4770         	bx	lr

0801534c <clock_control_on>:
; {
 801534c: b580         	push	{r7, lr}
 801534e: b084         	sub	sp, #0x10
 8015350: af00         	add	r7, sp, #0x0
 8015352: 6078         	str	r0, [r7, #0x4]
 8015354: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8015356: 687b         	ldr	r3, [r7, #0x4]
 8015358: 689b         	ldr	r3, [r3, #0x8]
 801535a: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801535c: 68fb         	ldr	r3, [r7, #0xc]
 801535e: 681b         	ldr	r3, [r3]
 8015360: 6839         	ldr	r1, [r7]
 8015362: 6878         	ldr	r0, [r7, #0x4]
 8015364: 4798         	blx	r3
 8015366: 4603         	mov	r3, r0
; }
 8015368: 4618         	mov	r0, r3
 801536a: 3710         	adds	r7, #0x10
 801536c: 46bd         	mov	sp, r7
 801536e: bd80         	pop	{r7, pc}

08015370 <clock_control_off>:
; {
 8015370: b580         	push	{r7, lr}
 8015372: b084         	sub	sp, #0x10
 8015374: af00         	add	r7, sp, #0x0
 8015376: 6078         	str	r0, [r7, #0x4]
 8015378: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801537a: 687b         	ldr	r3, [r7, #0x4]
 801537c: 689b         	ldr	r3, [r3, #0x8]
 801537e: 60fb         	str	r3, [r7, #0xc]
; 	return api->off(dev, sys);
 8015380: 68fb         	ldr	r3, [r7, #0xc]
 8015382: 685b         	ldr	r3, [r3, #0x4]
 8015384: 6839         	ldr	r1, [r7]
 8015386: 6878         	ldr	r0, [r7, #0x4]
 8015388: 4798         	blx	r3
 801538a: 4603         	mov	r3, r0
; }
 801538c: 4618         	mov	r0, r3
 801538e: 3710         	adds	r7, #0x10
 8015390: 46bd         	mov	sp, r7
 8015392: bd80         	pop	{r7, pc}

08015394 <pm_device_runtime_enable>:
; {
 8015394: b480         	push	{r7}
 8015396: b083         	sub	sp, #0xc
 8015398: af00         	add	r7, sp, #0x0
 801539a: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801539c: 2300         	movs	r3, #0x0
; }
 801539e: 4618         	mov	r0, r3
 80153a0: 370c         	adds	r7, #0xc
 80153a2: 46bd         	mov	sp, r7
 80153a4: bc80         	pop	{r7}
 80153a6: 4770         	bx	lr

080153a8 <pm_device_runtime_get>:
; {
 80153a8: b480         	push	{r7}
 80153aa: b083         	sub	sp, #0xc
 80153ac: af00         	add	r7, sp, #0x0
 80153ae: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 80153b0: 2300         	movs	r3, #0x0
; }
 80153b2: 4618         	mov	r0, r3
 80153b4: 370c         	adds	r7, #0xc
 80153b6: 46bd         	mov	sp, r7
 80153b8: bc80         	pop	{r7}
 80153ba: 4770         	bx	lr

080153bc <pm_device_runtime_put>:
; {
 80153bc: b480         	push	{r7}
 80153be: b083         	sub	sp, #0xc
 80153c0: af00         	add	r7, sp, #0x0
 80153c2: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 80153c4: 2300         	movs	r3, #0x0
; }
 80153c6: 4618         	mov	r0, r3
 80153c8: 370c         	adds	r7, #0xc
 80153ca: 46bd         	mov	sp, r7
 80153cc: bc80         	pop	{r7}
 80153ce: 4770         	bx	lr

080153d0 <z_stm32_hsem_lock>:
; {
 80153d0: b480         	push	{r7}
 80153d2: b083         	sub	sp, #0xc
 80153d4: af00         	add	r7, sp, #0x0
 80153d6: 6078         	str	r0, [r7, #0x4]
 80153d8: 6039         	str	r1, [r7]
; }
 80153da: bf00         	nop
 80153dc: 370c         	adds	r7, #0xc
 80153de: 46bd         	mov	sp, r7
 80153e0: bc80         	pop	{r7}
 80153e2: 4770         	bx	lr

080153e4 <z_stm32_hsem_unlock>:
; {
 80153e4: b480         	push	{r7}
 80153e6: b083         	sub	sp, #0xc
 80153e8: af00         	add	r7, sp, #0x0
 80153ea: 6078         	str	r0, [r7, #0x4]
; }
 80153ec: bf00         	nop
 80153ee: 370c         	adds	r7, #0xc
 80153f0: 46bd         	mov	sp, r7
 80153f2: bc80         	pop	{r7}
 80153f4: 4770         	bx	lr

080153f6 <gpio_manage_callback>:
; {
 80153f6: b580         	push	{r7, lr}
 80153f8: b084         	sub	sp, #0x10
 80153fa: af00         	add	r7, sp, #0x0
 80153fc: 60f8         	str	r0, [r7, #0xc]
 80153fe: 60b9         	str	r1, [r7, #0x8]
 8015400: 4613         	mov	r3, r2
 8015402: 71fb         	strb	r3, [r7, #0x7]
; 	if (!sys_slist_is_empty(callbacks)) {
 8015404: 68f8         	ldr	r0, [r7, #0xc]
 8015406: f7ff fd6f    	bl	0x8014ee8 <sys_slist_is_empty> @ imm = #-0x522
 801540a: 4603         	mov	r3, r0
 801540c: f083 0301    	eor	r3, r3, #0x1
 8015410: b2db         	uxtb	r3, r3
 8015412: 2b00         	cmp	r3, #0x0
 8015414: d013         	beq	0x801543e <gpio_manage_callback+0x48> @ imm = #0x26
; 		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
 8015416: 68bb         	ldr	r3, [r7, #0x8]
 8015418: 4619         	mov	r1, r3
 801541a: 68f8         	ldr	r0, [r7, #0xc]
 801541c: f7ff fdef    	bl	0x8014ffe <sys_slist_find_and_remove> @ imm = #-0x422
 8015420: 4603         	mov	r3, r0
 8015422: f083 0301    	eor	r3, r3, #0x1
 8015426: b2db         	uxtb	r3, r3
 8015428: 2b00         	cmp	r3, #0x0
 801542a: d011         	beq	0x8015450 <gpio_manage_callback+0x5a> @ imm = #0x22
; 			if (!set) {
 801542c: 79fb         	ldrb	r3, [r7, #0x7]
 801542e: f083 0301    	eor	r3, r3, #0x1
 8015432: b2db         	uxtb	r3, r3
 8015434: 2b00         	cmp	r3, #0x0
 8015436: d00b         	beq	0x8015450 <gpio_manage_callback+0x5a> @ imm = #0x16
; 				return -EINVAL;
 8015438: f06f 0315    	mvn	r3, #0x15
 801543c: e011         	b	0x8015462 <gpio_manage_callback+0x6c> @ imm = #0x22
; 	} else if (!set) {
 801543e: 79fb         	ldrb	r3, [r7, #0x7]
 8015440: f083 0301    	eor	r3, r3, #0x1
 8015444: b2db         	uxtb	r3, r3
 8015446: 2b00         	cmp	r3, #0x0
 8015448: d002         	beq	0x8015450 <gpio_manage_callback+0x5a> @ imm = #0x4
; 		return -EINVAL;
 801544a: f06f 0315    	mvn	r3, #0x15
 801544e: e008         	b	0x8015462 <gpio_manage_callback+0x6c> @ imm = #0x10
; 	if (set) {
 8015450: 79fb         	ldrb	r3, [r7, #0x7]
 8015452: 2b00         	cmp	r3, #0x0
 8015454: d004         	beq	0x8015460 <gpio_manage_callback+0x6a> @ imm = #0x8
; 		sys_slist_prepend(callbacks, &callback->node);
 8015456: 68bb         	ldr	r3, [r7, #0x8]
 8015458: 4619         	mov	r1, r3
 801545a: 68f8         	ldr	r0, [r7, #0xc]
 801545c: f7ff fd72    	bl	0x8014f44 <sys_slist_prepend> @ imm = #-0x51c
; 	return 0;
 8015460: 2300         	movs	r3, #0x0
; }
 8015462: 4618         	mov	r0, r3
 8015464: 3710         	adds	r7, #0x10
 8015466: 46bd         	mov	sp, r7
 8015468: bd80         	pop	{r7, pc}

0801546a <gpio_fire_callbacks>:
; {
 801546a: b580         	push	{r7, lr}
 801546c: b086         	sub	sp, #0x18
 801546e: af00         	add	r7, sp, #0x0
 8015470: 60f8         	str	r0, [r7, #0xc]
 8015472: 60b9         	str	r1, [r7, #0x8]
 8015474: 607a         	str	r2, [r7, #0x4]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 8015476: 68f8         	ldr	r0, [r7, #0xc]
 8015478: f7ff fd20    	bl	0x8014ebc <sys_slist_peek_head> @ imm = #-0x5c0
 801547c: 4603         	mov	r3, r0
 801547e: 2b00         	cmp	r3, #0x0
 8015480: d004         	beq	0x801548c <gpio_fire_callbacks+0x22> @ imm = #0x8
 8015482: 68f8         	ldr	r0, [r7, #0xc]
 8015484: f7ff fd1a    	bl	0x8014ebc <sys_slist_peek_head> @ imm = #-0x5cc
 8015488: 4603         	mov	r3, r0
 801548a: e000         	b	0x801548e <gpio_fire_callbacks+0x24> @ imm = #0x0
 801548c: 2300         	movs	r3, #0x0
 801548e: 617b         	str	r3, [r7, #0x14]
 8015490: 697b         	ldr	r3, [r7, #0x14]
 8015492: 2b00         	cmp	r3, #0x0
 8015494: d00e         	beq	0x80154b4 <gpio_fire_callbacks+0x4a> @ imm = #0x1c
 8015496: 697b         	ldr	r3, [r7, #0x14]
 8015498: 4618         	mov	r0, r3
 801549a: f7ff fd42    	bl	0x8014f22 <sys_slist_peek_next> @ imm = #-0x57c
 801549e: 4603         	mov	r3, r0
 80154a0: 2b00         	cmp	r3, #0x0
 80154a2: d005         	beq	0x80154b0 <gpio_fire_callbacks+0x46> @ imm = #0xa
 80154a4: 697b         	ldr	r3, [r7, #0x14]
 80154a6: 4618         	mov	r0, r3
 80154a8: f7ff fd3b    	bl	0x8014f22 <sys_slist_peek_next> @ imm = #-0x58a
 80154ac: 4603         	mov	r3, r0
 80154ae: e002         	b	0x80154b6 <gpio_fire_callbacks+0x4c> @ imm = #0x4
 80154b0: 2300         	movs	r3, #0x0
 80154b2: e000         	b	0x80154b6 <gpio_fire_callbacks+0x4c> @ imm = #0x0
 80154b4: 2300         	movs	r3, #0x0
 80154b6: 613b         	str	r3, [r7, #0x10]
 80154b8: e024         	b	0x8015504 <gpio_fire_callbacks+0x9a> @ imm = #0x48
; 		if (cb->pin_mask & pins) {
 80154ba: 697b         	ldr	r3, [r7, #0x14]
 80154bc: 689a         	ldr	r2, [r3, #0x8]
 80154be: 687b         	ldr	r3, [r7, #0x4]
 80154c0: 4013         	ands	r3, r2
 80154c2: 2b00         	cmp	r3, #0x0
 80154c4: d008         	beq	0x80154d8 <gpio_fire_callbacks+0x6e> @ imm = #0x10
; 			cb->handler(port, cb, cb->pin_mask & pins);
 80154c6: 697b         	ldr	r3, [r7, #0x14]
 80154c8: 685b         	ldr	r3, [r3, #0x4]
 80154ca: 697a         	ldr	r2, [r7, #0x14]
 80154cc: 6891         	ldr	r1, [r2, #0x8]
 80154ce: 687a         	ldr	r2, [r7, #0x4]
 80154d0: 400a         	ands	r2, r1
 80154d2: 6979         	ldr	r1, [r7, #0x14]
 80154d4: 68b8         	ldr	r0, [r7, #0x8]
 80154d6: 4798         	blx	r3
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 80154d8: 693b         	ldr	r3, [r7, #0x10]
 80154da: 617b         	str	r3, [r7, #0x14]
 80154dc: 697b         	ldr	r3, [r7, #0x14]
 80154de: 2b00         	cmp	r3, #0x0
 80154e0: d00e         	beq	0x8015500 <gpio_fire_callbacks+0x96> @ imm = #0x1c
 80154e2: 697b         	ldr	r3, [r7, #0x14]
 80154e4: 4618         	mov	r0, r3
 80154e6: f7ff fd1c    	bl	0x8014f22 <sys_slist_peek_next> @ imm = #-0x5c8
 80154ea: 4603         	mov	r3, r0
 80154ec: 2b00         	cmp	r3, #0x0
 80154ee: d005         	beq	0x80154fc <gpio_fire_callbacks+0x92> @ imm = #0xa
 80154f0: 697b         	ldr	r3, [r7, #0x14]
 80154f2: 4618         	mov	r0, r3
 80154f4: f7ff fd15    	bl	0x8014f22 <sys_slist_peek_next> @ imm = #-0x5d6
 80154f8: 4603         	mov	r3, r0
 80154fa: e002         	b	0x8015502 <gpio_fire_callbacks+0x98> @ imm = #0x4
 80154fc: 2300         	movs	r3, #0x0
 80154fe: e000         	b	0x8015502 <gpio_fire_callbacks+0x98> @ imm = #0x0
 8015500: 2300         	movs	r3, #0x0
 8015502: 613b         	str	r3, [r7, #0x10]
 8015504: 697b         	ldr	r3, [r7, #0x14]
 8015506: 2b00         	cmp	r3, #0x0
 8015508: d1d7         	bne	0x80154ba <gpio_fire_callbacks+0x50> @ imm = #-0x52
; }
 801550a: bf00         	nop
 801550c: bf00         	nop
 801550e: 3718         	adds	r7, #0x18
 8015510: 46bd         	mov	sp, r7
 8015512: bd80         	pop	{r7, pc}

08015514 <gpio_stm32_isr>:
; {
 8015514: b580         	push	{r7, lr}
 8015516: b084         	sub	sp, #0x10
 8015518: af00         	add	r7, sp, #0x0
 801551a: 6078         	str	r0, [r7, #0x4]
 801551c: 6039         	str	r1, [r7]
; 	struct gpio_stm32_data *data = arg;
 801551e: 683b         	ldr	r3, [r7]
 8015520: 60fb         	str	r3, [r7, #0xc]
; 	gpio_fire_callbacks(&data->cb, data->dev, pin);
 8015522: 68fb         	ldr	r3, [r7, #0xc]
 8015524: f103 0008    	add.w	r0, r3, #0x8
 8015528: 68fb         	ldr	r3, [r7, #0xc]
 801552a: 685b         	ldr	r3, [r3, #0x4]
 801552c: 687a         	ldr	r2, [r7, #0x4]
 801552e: 4619         	mov	r1, r3
 8015530: f7ff ff9b    	bl	0x801546a <gpio_fire_callbacks> @ imm = #-0xca
; }
 8015534: bf00         	nop
 8015536: 3710         	adds	r7, #0x10
 8015538: 46bd         	mov	sp, r7
 801553a: bd80         	pop	{r7, pc}

0801553c <gpio_stm32_flags_to_conf>:
; {
 801553c: b480         	push	{r7}
 801553e: b083         	sub	sp, #0xc
 8015540: af00         	add	r7, sp, #0x0
 8015542: 6078         	str	r0, [r7, #0x4]
 8015544: 6039         	str	r1, [r7]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 8015546: 687b         	ldr	r3, [r7, #0x4]
 8015548: f403 3300    	and	r3, r3, #0x20000
 801554c: 2b00         	cmp	r3, #0x0
 801554e: d032         	beq	0x80155b6 <gpio_stm32_flags_to_conf+0x7a> @ imm = #0x64
; 		*pincfg = STM32_PINCFG_MODE_OUTPUT;
 8015550: 683b         	ldr	r3, [r7]
 8015552: 2210         	movs	r2, #0x10
 8015554: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_SINGLE_ENDED) != 0) {
 8015556: 687b         	ldr	r3, [r7, #0x4]
 8015558: f003 0302    	and	r3, r3, #0x2
 801555c: 2b00         	cmp	r3, #0x0
 801555e: d00e         	beq	0x801557e <gpio_stm32_flags_to_conf+0x42> @ imm = #0x1c
; 			if (flags & GPIO_LINE_OPEN_DRAIN) {
 8015560: 687b         	ldr	r3, [r7, #0x4]
 8015562: f003 0304    	and	r3, r3, #0x4
 8015566: 2b00         	cmp	r3, #0x0
 8015568: d006         	beq	0x8015578 <gpio_stm32_flags_to_conf+0x3c> @ imm = #0xc
; 				*pincfg |= STM32_PINCFG_OPEN_DRAIN;
 801556a: 683b         	ldr	r3, [r7]
 801556c: 681b         	ldr	r3, [r3]
 801556e: f043 0240    	orr	r2, r3, #0x40
 8015572: 683b         	ldr	r3, [r7]
 8015574: 601a         	str	r2, [r3]
 8015576: e006         	b	0x8015586 <gpio_stm32_flags_to_conf+0x4a> @ imm = #0xc
; 				return -ENOTSUP;
 8015578: f06f 0385    	mvn	r3, #0x85
 801557c: e044         	b	0x8015608 <gpio_stm32_flags_to_conf+0xcc> @ imm = #0x88
; 			*pincfg |= STM32_PINCFG_PUSH_PULL;
 801557e: 683b         	ldr	r3, [r7]
 8015580: 681a         	ldr	r2, [r3]
 8015582: 683b         	ldr	r3, [r7]
 8015584: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 8015586: 687b         	ldr	r3, [r7, #0x4]
 8015588: f003 0310    	and	r3, r3, #0x10
 801558c: 2b00         	cmp	r3, #0x0
 801558e: d006         	beq	0x801559e <gpio_stm32_flags_to_conf+0x62> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 8015590: 683b         	ldr	r3, [r7]
 8015592: 681b         	ldr	r3, [r3]
 8015594: f443 7200    	orr	r2, r3, #0x200
 8015598: 683b         	ldr	r3, [r7]
 801559a: 601a         	str	r2, [r3]
 801559c: e033         	b	0x8015606 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x66
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 801559e: 687b         	ldr	r3, [r7, #0x4]
 80155a0: f003 0320    	and	r3, r3, #0x20
 80155a4: 2b00         	cmp	r3, #0x0
 80155a6: d02e         	beq	0x8015606 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x5c
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 80155a8: 683b         	ldr	r3, [r7]
 80155aa: 681b         	ldr	r3, [r3]
 80155ac: f443 6280    	orr	r2, r3, #0x400
 80155b0: 683b         	ldr	r3, [r7]
 80155b2: 601a         	str	r2, [r3]
 80155b4: e027         	b	0x8015606 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4e
; 	} else if  ((flags & GPIO_INPUT) != 0) {
 80155b6: 687b         	ldr	r3, [r7, #0x4]
 80155b8: f403 3380    	and	r3, r3, #0x10000
 80155bc: 2b00         	cmp	r3, #0x0
 80155be: d01f         	beq	0x8015600 <gpio_stm32_flags_to_conf+0xc4> @ imm = #0x3e
; 		*pincfg = STM32_PINCFG_MODE_INPUT;
 80155c0: 683b         	ldr	r3, [r7]
 80155c2: 2200         	movs	r2, #0x0
 80155c4: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 80155c6: 687b         	ldr	r3, [r7, #0x4]
 80155c8: f003 0310    	and	r3, r3, #0x10
 80155cc: 2b00         	cmp	r3, #0x0
 80155ce: d006         	beq	0x80155de <gpio_stm32_flags_to_conf+0xa2> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 80155d0: 683b         	ldr	r3, [r7]
 80155d2: 681b         	ldr	r3, [r3]
 80155d4: f443 7200    	orr	r2, r3, #0x200
 80155d8: 683b         	ldr	r3, [r7]
 80155da: 601a         	str	r2, [r3]
 80155dc: e013         	b	0x8015606 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x26
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 80155de: 687b         	ldr	r3, [r7, #0x4]
 80155e0: f003 0320    	and	r3, r3, #0x20
 80155e4: 2b00         	cmp	r3, #0x0
 80155e6: d006         	beq	0x80155f6 <gpio_stm32_flags_to_conf+0xba> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 80155e8: 683b         	ldr	r3, [r7]
 80155ea: 681b         	ldr	r3, [r3]
 80155ec: f443 6280    	orr	r2, r3, #0x400
 80155f0: 683b         	ldr	r3, [r7]
 80155f2: 601a         	str	r2, [r3]
 80155f4: e007         	b	0x8015606 <gpio_stm32_flags_to_conf+0xca> @ imm = #0xe
; 			*pincfg |= STM32_PINCFG_FLOATING;
 80155f6: 683b         	ldr	r3, [r7]
 80155f8: 681a         	ldr	r2, [r3]
 80155fa: 683b         	ldr	r3, [r7]
 80155fc: 601a         	str	r2, [r3]
 80155fe: e002         	b	0x8015606 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4
; 		*pincfg = STM32_PINCFG_MODE_ANALOG;
 8015600: 683b         	ldr	r3, [r7]
 8015602: 2230         	movs	r2, #0x30
 8015604: 601a         	str	r2, [r3]
; 	return 0;
 8015606: 2300         	movs	r3, #0x0
; }
 8015608: 4618         	mov	r0, r3
 801560a: 370c         	adds	r7, #0xc
 801560c: 46bd         	mov	sp, r7
 801560e: bc80         	pop	{r7}
 8015610: 4770         	bx	lr

08015612 <stm32_pinval_get>:
; {
 8015612: b480         	push	{r7}
 8015614: b085         	sub	sp, #0x14
 8015616: af00         	add	r7, sp, #0x0
 8015618: 4603         	mov	r3, r0
 801561a: 71fb         	strb	r3, [r7, #0x7]
; 	pinval = 1 << pin;
 801561c: 79fb         	ldrb	r3, [r7, #0x7]
 801561e: 2201         	movs	r2, #0x1
 8015620: fa02 f303    	lsl.w	r3, r2, r3
 8015624: 60fb         	str	r3, [r7, #0xc]
; 	return pinval;
 8015626: 68fb         	ldr	r3, [r7, #0xc]
; }
 8015628: 4618         	mov	r0, r3
 801562a: 3714         	adds	r7, #0x14
 801562c: 46bd         	mov	sp, r7
 801562e: bc80         	pop	{r7}
 8015630: 4770         	bx	lr

08015632 <ll_gpio_set_pin_pull>:
; {
 8015632: b580         	push	{r7, lr}
 8015634: b084         	sub	sp, #0x10
 8015636: af00         	add	r7, sp, #0x0
 8015638: 60f8         	str	r0, [r7, #0xc]
 801563a: 60b9         	str	r1, [r7, #0x8]
 801563c: 607a         	str	r2, [r7, #0x4]
; 	LL_GPIO_SetPinPull(GPIOx, Pin, Pull);
 801563e: 687a         	ldr	r2, [r7, #0x4]
 8015640: 68b9         	ldr	r1, [r7, #0x8]
 8015642: 68f8         	ldr	r0, [r7, #0xc]
 8015644: f7ff fd9b    	bl	0x801517e <LL_GPIO_SetPinPull> @ imm = #-0x4ca
; }
 8015648: bf00         	nop
 801564a: 3710         	adds	r7, #0x10
 801564c: 46bd         	mov	sp, r7
 801564e: bd80         	pop	{r7, pc}

08015650 <gpio_stm32_disable_pin_irqs>:
; {
 8015650: b580         	push	{r7, lr}
 8015652: b084         	sub	sp, #0x10
 8015654: af00         	add	r7, sp, #0x0
 8015656: 6078         	str	r0, [r7, #0x4]
 8015658: 460b         	mov	r3, r1
 801565a: 70fb         	strb	r3, [r7, #0x3]
; 	if (port != stm32_exti_get_line_src_port(pin)) {
 801565c: 78fb         	ldrb	r3, [r7, #0x3]
 801565e: 4618         	mov	r0, r3
 8015660: f7fd fbb5    	bl	0x8012dce <stm32_exti_get_line_src_port> @ imm = #-0x2896
 8015664: 4602         	mov	r2, r0
 8015666: 687b         	ldr	r3, [r7, #0x4]
 8015668: 4293         	cmp	r3, r2
 801566a: d110         	bne	0x801568e <gpio_stm32_disable_pin_irqs+0x3e> @ imm = #0x20
; 	stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(port, pin);
 801566c: 78fb         	ldrb	r3, [r7, #0x3]
 801566e: 4619         	mov	r1, r3
 8015670: 6878         	ldr	r0, [r7, #0x4]
 8015672: f7fd fb77    	bl	0x8012d64 <stm32_gpio_intc_get_pin_irq_line> @ imm = #-0x2912
 8015676: 60f8         	str	r0, [r7, #0xc]
; 	stm32_gpio_intc_disable_line(irq_line);
 8015678: 68f8         	ldr	r0, [r7, #0xc]
 801567a: f7fd fb82    	bl	0x8012d82 <stm32_gpio_intc_disable_line> @ imm = #-0x28fc
; 	stm32_gpio_intc_remove_irq_callback(irq_line);
 801567e: 68f8         	ldr	r0, [r7, #0xc]
 8015680: f7ee fb6c    	bl	0x8003d5c <stm32_gpio_intc_remove_irq_callback> @ imm = #-0x11928
; 	stm32_gpio_intc_select_line_trigger(irq_line, STM32_GPIO_IRQ_TRIG_NONE);
 8015684: 2100         	movs	r1, #0x0
 8015686: 68f8         	ldr	r0, [r7, #0xc]
 8015688: f7ee faf0    	bl	0x8003c6c <stm32_gpio_intc_select_line_trigger> @ imm = #-0x11a20
 801568c: e000         	b	0x8015690 <gpio_stm32_disable_pin_irqs+0x40> @ imm = #0x0
; 		return;
 801568e: bf00         	nop
; }
 8015690: 3710         	adds	r7, #0x10
 8015692: 46bd         	mov	sp, r7
 8015694: bd80         	pop	{r7, pc}

08015696 <gpio_stm32_configure_raw>:
; {
 8015696: b580         	push	{r7, lr}
 8015698: b08c         	sub	sp, #0x30
 801569a: af00         	add	r7, sp, #0x0
 801569c: 60f8         	str	r0, [r7, #0xc]
 801569e: 607a         	str	r2, [r7, #0x4]
 80156a0: 603b         	str	r3, [r7]
 80156a2: 460b         	mov	r3, r1
 80156a4: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 80156a6: 68fb         	ldr	r3, [r7, #0xc]
 80156a8: 685b         	ldr	r3, [r3, #0x4]
 80156aa: 62fb         	str	r3, [r7, #0x2c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 80156ac: 6afb         	ldr	r3, [r7, #0x2c]
 80156ae: 685b         	ldr	r3, [r3, #0x4]
 80156b0: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pin_ll = stm32_pinval_get(pin);
 80156b2: 7afb         	ldrb	r3, [r7, #0xb]
 80156b4: 4618         	mov	r0, r3
 80156b6: f7ff ffac    	bl	0x8015612 <stm32_pinval_get> @ imm = #-0xa8
 80156ba: 6278         	str	r0, [r7, #0x24]
; 	mode = conf & (STM32_MODER_MASK << STM32_MODER_SHIFT);
 80156bc: 687b         	ldr	r3, [r7, #0x4]
 80156be: f003 0330    	and	r3, r3, #0x30
 80156c2: 623b         	str	r3, [r7, #0x20]
; 	otype = conf & (STM32_OTYPER_MASK << STM32_OTYPER_SHIFT);
 80156c4: 687b         	ldr	r3, [r7, #0x4]
 80156c6: f003 0340    	and	r3, r3, #0x40
 80156ca: 61fb         	str	r3, [r7, #0x1c]
; 	ospeed = conf & (STM32_OSPEEDR_MASK << STM32_OSPEEDR_SHIFT);
 80156cc: 687b         	ldr	r3, [r7, #0x4]
 80156ce: f403 73c0    	and	r3, r3, #0x180
 80156d2: 61bb         	str	r3, [r7, #0x18]
; 	pupd = conf & (STM32_PUPDR_MASK << STM32_PUPDR_SHIFT);
 80156d4: 687b         	ldr	r3, [r7, #0x4]
 80156d6: f403 63c0    	and	r3, r3, #0x600
 80156da: 617b         	str	r3, [r7, #0x14]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 80156dc: f44f 1180    	mov.w	r1, #0x100000
 80156e0: 2000         	movs	r0, #0x0
 80156e2: f7ff fe75    	bl	0x80153d0 <z_stm32_hsem_lock> @ imm = #-0x316
; 	LL_GPIO_SetPinOutputType(gpio, pin_ll, otype >> STM32_OTYPER_SHIFT);
 80156e6: 69fb         	ldr	r3, [r7, #0x1c]
 80156e8: 099b         	lsrs	r3, r3, #0x6
 80156ea: 461a         	mov	r2, r3
 80156ec: 6a79         	ldr	r1, [r7, #0x24]
 80156ee: 6ab8         	ldr	r0, [r7, #0x28]
 80156f0: f7ff fcf2    	bl	0x80150d8 <LL_GPIO_SetPinOutputType> @ imm = #-0x61c
; 	LL_GPIO_SetPinSpeed(gpio, pin_ll, ospeed >> STM32_OSPEEDR_SHIFT);
 80156f4: 69bb         	ldr	r3, [r7, #0x18]
 80156f6: 09db         	lsrs	r3, r3, #0x7
 80156f8: 461a         	mov	r2, r3
 80156fa: 6a79         	ldr	r1, [r7, #0x24]
 80156fc: 6ab8         	ldr	r0, [r7, #0x28]
 80156fe: f7ff fd02    	bl	0x8015106 <LL_GPIO_SetPinSpeed> @ imm = #-0x5fc
; 	ll_gpio_set_pin_pull(gpio, pin_ll, pupd >> STM32_PUPDR_SHIFT);
 8015702: 697b         	ldr	r3, [r7, #0x14]
 8015704: 0a5b         	lsrs	r3, r3, #0x9
 8015706: 461a         	mov	r2, r3
 8015708: 6a79         	ldr	r1, [r7, #0x24]
 801570a: 6ab8         	ldr	r0, [r7, #0x28]
 801570c: f7ff ff91    	bl	0x8015632 <ll_gpio_set_pin_pull> @ imm = #-0xde
; 	if (mode == STM32_MODER_ALT_MODE) {
 8015710: 6a3b         	ldr	r3, [r7, #0x20]
 8015712: 2b20         	cmp	r3, #0x20
 8015714: d10d         	bne	0x8015732 <gpio_stm32_configure_raw+0x9c> @ imm = #0x1a
; 		if (pin < 8) {
 8015716: 7afb         	ldrb	r3, [r7, #0xb]
 8015718: 2b07         	cmp	r3, #0x7
 801571a: d805         	bhi	0x8015728 <gpio_stm32_configure_raw+0x92> @ imm = #0xa
; 			LL_GPIO_SetAFPin_0_7(gpio, pin_ll, func);
 801571c: 683a         	ldr	r2, [r7]
 801571e: 6a79         	ldr	r1, [r7, #0x24]
 8015720: 6ab8         	ldr	r0, [r7, #0x28]
 8015722: f7ff fd68    	bl	0x80151f6 <LL_GPIO_SetAFPin_0_7> @ imm = #-0x530
 8015726: e004         	b	0x8015732 <gpio_stm32_configure_raw+0x9c> @ imm = #0x8
; 			LL_GPIO_SetAFPin_8_15(gpio, pin_ll, func);
 8015728: 683a         	ldr	r2, [r7]
 801572a: 6a79         	ldr	r1, [r7, #0x24]
 801572c: 6ab8         	ldr	r0, [r7, #0x28]
 801572e: f7ff fd9e    	bl	0x801526e <LL_GPIO_SetAFPin_8_15> @ imm = #-0x4c4
; 	LL_GPIO_SetPinMode(gpio, pin_ll, mode >> STM32_MODER_SHIFT);
 8015732: 6a3b         	ldr	r3, [r7, #0x20]
 8015734: 091b         	lsrs	r3, r3, #0x4
 8015736: 461a         	mov	r2, r3
 8015738: 6a79         	ldr	r1, [r7, #0x24]
 801573a: 6ab8         	ldr	r0, [r7, #0x28]
 801573c: f7ff fc90    	bl	0x8015060 <LL_GPIO_SetPinMode> @ imm = #-0x6e0
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 8015740: 2000         	movs	r0, #0x0
 8015742: f7ff fe4f    	bl	0x80153e4 <z_stm32_hsem_unlock> @ imm = #-0x362
; }
 8015746: bf00         	nop
 8015748: 3730         	adds	r7, #0x30
 801574a: 46bd         	mov	sp, r7
 801574c: bd80         	pop	{r7, pc}

0801574e <gpio_stm32_port_get_raw>:
; {
 801574e: b580         	push	{r7, lr}
 8015750: b084         	sub	sp, #0x10
 8015752: af00         	add	r7, sp, #0x0
 8015754: 6078         	str	r0, [r7, #0x4]
 8015756: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8015758: 687b         	ldr	r3, [r7, #0x4]
 801575a: 685b         	ldr	r3, [r3, #0x4]
 801575c: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 801575e: 68fb         	ldr	r3, [r7, #0xc]
 8015760: 685b         	ldr	r3, [r3, #0x4]
 8015762: 60bb         	str	r3, [r7, #0x8]
; 	*value = LL_GPIO_ReadInputPort(gpio);
 8015764: 68b8         	ldr	r0, [r7, #0x8]
 8015766: f7ff fdc0    	bl	0x80152ea <LL_GPIO_ReadInputPort> @ imm = #-0x480
 801576a: 4602         	mov	r2, r0
 801576c: 683b         	ldr	r3, [r7]
 801576e: 601a         	str	r2, [r3]
; 	return 0;
 8015770: 2300         	movs	r3, #0x0
; }
 8015772: 4618         	mov	r0, r3
 8015774: 3710         	adds	r7, #0x10
 8015776: 46bd         	mov	sp, r7
 8015778: bd80         	pop	{r7, pc}

0801577a <gpio_stm32_port_set_masked_raw>:
; {
 801577a: b580         	push	{r7, lr}
 801577c: b088         	sub	sp, #0x20
 801577e: af00         	add	r7, sp, #0x0
 8015780: 60f8         	str	r0, [r7, #0xc]
 8015782: 60b9         	str	r1, [r7, #0x8]
 8015784: 607a         	str	r2, [r7, #0x4]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8015786: 68fb         	ldr	r3, [r7, #0xc]
 8015788: 685b         	ldr	r3, [r3, #0x4]
 801578a: 61fb         	str	r3, [r7, #0x1c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 801578c: 69fb         	ldr	r3, [r7, #0x1c]
 801578e: 685b         	ldr	r3, [r3, #0x4]
 8015790: 61bb         	str	r3, [r7, #0x18]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8015792: f44f 1180    	mov.w	r1, #0x100000
 8015796: 2000         	movs	r0, #0x0
 8015798: f7ff fe1a    	bl	0x80153d0 <z_stm32_hsem_lock> @ imm = #-0x3cc
; 	port_value = LL_GPIO_ReadOutputPort(gpio);
 801579c: 69b8         	ldr	r0, [r7, #0x18]
 801579e: f7ff fdbc    	bl	0x801531a <LL_GPIO_ReadOutputPort> @ imm = #-0x488
 80157a2: 6178         	str	r0, [r7, #0x14]
; 	LL_GPIO_WriteOutputPort(gpio, (port_value & ~mask) | (mask & value));
 80157a4: 68bb         	ldr	r3, [r7, #0x8]
 80157a6: 43da         	mvns	r2, r3
 80157a8: 697b         	ldr	r3, [r7, #0x14]
 80157aa: 401a         	ands	r2, r3
 80157ac: 68b9         	ldr	r1, [r7, #0x8]
 80157ae: 687b         	ldr	r3, [r7, #0x4]
 80157b0: 400b         	ands	r3, r1
 80157b2: 4313         	orrs	r3, r2
 80157b4: 4619         	mov	r1, r3
 80157b6: 69b8         	ldr	r0, [r7, #0x18]
 80157b8: f7ff fda2    	bl	0x8015300 <LL_GPIO_WriteOutputPort> @ imm = #-0x4bc
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 80157bc: 2000         	movs	r0, #0x0
 80157be: f7ff fe11    	bl	0x80153e4 <z_stm32_hsem_unlock> @ imm = #-0x3de
; 	return 0;
 80157c2: 2300         	movs	r3, #0x0
; }
 80157c4: 4618         	mov	r0, r3
 80157c6: 3720         	adds	r7, #0x20
 80157c8: 46bd         	mov	sp, r7
 80157ca: bd80         	pop	{r7, pc}

080157cc <gpio_stm32_port_set_bits_raw>:
; {
 80157cc: b480         	push	{r7}
 80157ce: b085         	sub	sp, #0x14
 80157d0: af00         	add	r7, sp, #0x0
 80157d2: 6078         	str	r0, [r7, #0x4]
 80157d4: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 80157d6: 687b         	ldr	r3, [r7, #0x4]
 80157d8: 685b         	ldr	r3, [r3, #0x4]
 80157da: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 80157dc: 68fb         	ldr	r3, [r7, #0xc]
 80157de: 685b         	ldr	r3, [r3, #0x4]
 80157e0: 60bb         	str	r3, [r7, #0x8]
; 	WRITE_REG(gpio->BSRR, pins);
 80157e2: 68bb         	ldr	r3, [r7, #0x8]
 80157e4: 683a         	ldr	r2, [r7]
 80157e6: 619a         	str	r2, [r3, #0x18]
; 	return 0;
 80157e8: 2300         	movs	r3, #0x0
; }
 80157ea: 4618         	mov	r0, r3
 80157ec: 3714         	adds	r7, #0x14
 80157ee: 46bd         	mov	sp, r7
 80157f0: bc80         	pop	{r7}
 80157f2: 4770         	bx	lr

080157f4 <gpio_stm32_port_clear_bits_raw>:
; {
 80157f4: b580         	push	{r7, lr}
 80157f6: b084         	sub	sp, #0x10
 80157f8: af00         	add	r7, sp, #0x0
 80157fa: 6078         	str	r0, [r7, #0x4]
 80157fc: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 80157fe: 687b         	ldr	r3, [r7, #0x4]
 8015800: 685b         	ldr	r3, [r3, #0x4]
 8015802: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8015804: 68fb         	ldr	r3, [r7, #0xc]
 8015806: 685b         	ldr	r3, [r3, #0x4]
 8015808: 60bb         	str	r3, [r7, #0x8]
; 	LL_GPIO_ResetOutputPin(gpio, pins);
 801580a: 6839         	ldr	r1, [r7]
 801580c: 68b8         	ldr	r0, [r7, #0x8]
 801580e: f7ff fd8f    	bl	0x8015330 <LL_GPIO_ResetOutputPin> @ imm = #-0x4e2
; 	return 0;
 8015812: 2300         	movs	r3, #0x0
; }
 8015814: 4618         	mov	r0, r3
 8015816: 3710         	adds	r7, #0x10
 8015818: 46bd         	mov	sp, r7
 801581a: bd80         	pop	{r7, pc}

0801581c <gpio_stm32_port_toggle_bits>:
; {
 801581c: b580         	push	{r7, lr}
 801581e: b084         	sub	sp, #0x10
 8015820: af00         	add	r7, sp, #0x0
 8015822: 6078         	str	r0, [r7, #0x4]
 8015824: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8015826: 687b         	ldr	r3, [r7, #0x4]
 8015828: 685b         	ldr	r3, [r3, #0x4]
 801582a: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 801582c: 68fb         	ldr	r3, [r7, #0xc]
 801582e: 685b         	ldr	r3, [r3, #0x4]
 8015830: 60bb         	str	r3, [r7, #0x8]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8015832: f44f 1180    	mov.w	r1, #0x100000
 8015836: 2000         	movs	r0, #0x0
 8015838: f7ff fdca    	bl	0x80153d0 <z_stm32_hsem_lock> @ imm = #-0x46c
; 	WRITE_REG(gpio->ODR, READ_REG(gpio->ODR) ^ pins);
 801583c: 68bb         	ldr	r3, [r7, #0x8]
 801583e: 695a         	ldr	r2, [r3, #0x14]
 8015840: 683b         	ldr	r3, [r7]
 8015842: 405a         	eors	r2, r3
 8015844: 68bb         	ldr	r3, [r7, #0x8]
 8015846: 615a         	str	r2, [r3, #0x14]
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 8015848: 2000         	movs	r0, #0x0
 801584a: f7ff fdcb    	bl	0x80153e4 <z_stm32_hsem_unlock> @ imm = #-0x46a
; 	return 0;
 801584e: 2300         	movs	r3, #0x0
; }
 8015850: 4618         	mov	r0, r3
 8015852: 3710         	adds	r7, #0x10
 8015854: 46bd         	mov	sp, r7
 8015856: bd80         	pop	{r7, pc}

08015858 <gpio_stm32_configure>:
; {
 8015858: b580         	push	{r7, lr}
 801585a: b086         	sub	sp, #0x18
 801585c: af00         	add	r7, sp, #0x0
 801585e: 60f8         	str	r0, [r7, #0xc]
 8015860: 607a         	str	r2, [r7, #0x4]
 8015862: 603b         	str	r3, [r7]
 8015864: 460b         	mov	r3, r1
 8015866: 72fb         	strb	r3, [r7, #0xb]
; 	ret = pm_device_runtime_get(dev);
 8015868: 68f8         	ldr	r0, [r7, #0xc]
 801586a: f7ff fd9d    	bl	0x80153a8 <pm_device_runtime_get> @ imm = #-0x4c6
 801586e: 6178         	str	r0, [r7, #0x14]
; 	if (ret < 0) {
 8015870: 697b         	ldr	r3, [r7, #0x14]
 8015872: 2b00         	cmp	r3, #0x0
 8015874: da01         	bge	0x801587a <gpio_stm32_configure+0x22> @ imm = #0x2
; 		return ret;
 8015876: 697b         	ldr	r3, [r7, #0x14]
 8015878: e028         	b	0x80158cc <gpio_stm32_configure+0x74> @ imm = #0x50
; 	gpio_stm32_configure_raw(dev, pin, conf, func);
 801587a: 7af9         	ldrb	r1, [r7, #0xb]
 801587c: 683b         	ldr	r3, [r7]
 801587e: 687a         	ldr	r2, [r7, #0x4]
 8015880: 68f8         	ldr	r0, [r7, #0xc]
 8015882: f7ff ff08    	bl	0x8015696 <gpio_stm32_configure_raw> @ imm = #-0x1f0
; 	if (func == IS_GPIO_OUT) {
 8015886: 683b         	ldr	r3, [r7]
 8015888: 2b11         	cmp	r3, #0x11
 801588a: d11b         	bne	0x80158c4 <gpio_stm32_configure+0x6c> @ imm = #0x36
; 		uint32_t gpio_out = conf & (STM32_ODR_MASK << STM32_ODR_SHIFT);
 801588c: 687b         	ldr	r3, [r7, #0x4]
 801588e: f403 6300    	and	r3, r3, #0x800
 8015892: 613b         	str	r3, [r7, #0x10]
; 		if (gpio_out == STM32_ODR_1) {
 8015894: 693b         	ldr	r3, [r7, #0x10]
 8015896: f5b3 6f00    	cmp.w	r3, #0x800
 801589a: d108         	bne	0x80158ae <gpio_stm32_configure+0x56> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 801589c: 7afb         	ldrb	r3, [r7, #0xb]
 801589e: 2201         	movs	r2, #0x1
 80158a0: fa02 f303    	lsl.w	r3, r2, r3
 80158a4: 4619         	mov	r1, r3
 80158a6: 68f8         	ldr	r0, [r7, #0xc]
 80158a8: f7ff ff90    	bl	0x80157cc <gpio_stm32_port_set_bits_raw> @ imm = #-0xe0
 80158ac: e00a         	b	0x80158c4 <gpio_stm32_configure+0x6c> @ imm = #0x14
; 		} else if (gpio_out == STM32_ODR_0) {
 80158ae: 693b         	ldr	r3, [r7, #0x10]
 80158b0: 2b00         	cmp	r3, #0x0
 80158b2: d107         	bne	0x80158c4 <gpio_stm32_configure+0x6c> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 80158b4: 7afb         	ldrb	r3, [r7, #0xb]
 80158b6: 2201         	movs	r2, #0x1
 80158b8: fa02 f303    	lsl.w	r3, r2, r3
 80158bc: 4619         	mov	r1, r3
 80158be: 68f8         	ldr	r0, [r7, #0xc]
 80158c0: f7ff ff98    	bl	0x80157f4 <gpio_stm32_port_clear_bits_raw> @ imm = #-0xd0
; 	return pm_device_runtime_put(dev);
 80158c4: 68f8         	ldr	r0, [r7, #0xc]
 80158c6: f7ff fd79    	bl	0x80153bc <pm_device_runtime_put> @ imm = #-0x50e
 80158ca: 4603         	mov	r3, r0
; }
 80158cc: 4618         	mov	r0, r3
 80158ce: 3718         	adds	r7, #0x18
 80158d0: 46bd         	mov	sp, r7
 80158d2: bd80         	pop	{r7, pc}

080158d4 <gpio_stm32_config>:
; {
 80158d4: b580         	push	{r7, lr}
 80158d6: b088         	sub	sp, #0x20
 80158d8: af00         	add	r7, sp, #0x0
 80158da: 60f8         	str	r0, [r7, #0xc]
 80158dc: 460b         	mov	r3, r1
 80158de: 607a         	str	r2, [r7, #0x4]
 80158e0: 72fb         	strb	r3, [r7, #0xb]
; 	struct gpio_stm32_data *data = dev->data;
 80158e2: 68fb         	ldr	r3, [r7, #0xc]
 80158e4: 691b         	ldr	r3, [r3, #0x10]
 80158e6: 61fb         	str	r3, [r7, #0x1c]
; 	err = gpio_stm32_flags_to_conf(flags, &pincfg);
 80158e8: f107 0314    	add.w	r3, r7, #0x14
 80158ec: 4619         	mov	r1, r3
 80158ee: 6878         	ldr	r0, [r7, #0x4]
 80158f0: f7ff fe24    	bl	0x801553c <gpio_stm32_flags_to_conf> @ imm = #-0x3b8
 80158f4: 61b8         	str	r0, [r7, #0x18]
; 	if (err != 0) {
 80158f6: 69bb         	ldr	r3, [r7, #0x18]
 80158f8: 2b00         	cmp	r3, #0x0
 80158fa: d001         	beq	0x8015900 <gpio_stm32_config+0x2c> @ imm = #0x2
; 		return err;
 80158fc: 69bb         	ldr	r3, [r7, #0x18]
 80158fe: e071         	b	0x80159e4 <gpio_stm32_config+0x110> @ imm = #0xe2
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 8015900: 687b         	ldr	r3, [r7, #0x4]
 8015902: f403 3300    	and	r3, r3, #0x20000
 8015906: 2b00         	cmp	r3, #0x0
 8015908: d104         	bne	0x8015914 <gpio_stm32_config+0x40> @ imm = #0x8
 801590a: 687b         	ldr	r3, [r7, #0x4]
 801590c: f403 3380    	and	r3, r3, #0x10000
 8015910: 2b00         	cmp	r3, #0x0
 8015912: d01a         	beq	0x801594a <gpio_stm32_config+0x76> @ imm = #0x34
; 	    !(data->pin_has_clock_enabled & BIT(pin))) {
 8015914: 69fb         	ldr	r3, [r7, #0x1c]
 8015916: 691a         	ldr	r2, [r3, #0x10]
 8015918: 7afb         	ldrb	r3, [r7, #0xb]
 801591a: fa22 f303    	lsr.w	r3, r2, r3
 801591e: f003 0301    	and	r3, r3, #0x1
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 8015922: 2b00         	cmp	r3, #0x0
 8015924: d111         	bne	0x801594a <gpio_stm32_config+0x76> @ imm = #0x22
; 		err = pm_device_runtime_get(dev);
 8015926: 68f8         	ldr	r0, [r7, #0xc]
 8015928: f7ff fd3e    	bl	0x80153a8 <pm_device_runtime_get> @ imm = #-0x584
 801592c: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 801592e: 69bb         	ldr	r3, [r7, #0x18]
 8015930: 2b00         	cmp	r3, #0x0
 8015932: da01         	bge	0x8015938 <gpio_stm32_config+0x64> @ imm = #0x2
; 			return err;
 8015934: 69bb         	ldr	r3, [r7, #0x18]
 8015936: e055         	b	0x80159e4 <gpio_stm32_config+0x110> @ imm = #0xaa
; 		data->pin_has_clock_enabled |= BIT(pin);
 8015938: 69fb         	ldr	r3, [r7, #0x1c]
 801593a: 691a         	ldr	r2, [r3, #0x10]
 801593c: 7afb         	ldrb	r3, [r7, #0xb]
 801593e: 2101         	movs	r1, #0x1
 8015940: fa01 f303    	lsl.w	r3, r1, r3
 8015944: 431a         	orrs	r2, r3
 8015946: 69fb         	ldr	r3, [r7, #0x1c]
 8015948: 611a         	str	r2, [r3, #0x10]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 801594a: 687b         	ldr	r3, [r7, #0x4]
 801594c: f403 3300    	and	r3, r3, #0x20000
 8015950: 2b00         	cmp	r3, #0x0
 8015952: d01a         	beq	0x801598a <gpio_stm32_config+0xb6> @ imm = #0x34
; 		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
 8015954: 687b         	ldr	r3, [r7, #0x4]
 8015956: f403 2300    	and	r3, r3, #0x80000
 801595a: 2b00         	cmp	r3, #0x0
 801595c: d008         	beq	0x8015970 <gpio_stm32_config+0x9c> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 801595e: 7afb         	ldrb	r3, [r7, #0xb]
 8015960: 2201         	movs	r2, #0x1
 8015962: fa02 f303    	lsl.w	r3, r2, r3
 8015966: 4619         	mov	r1, r3
 8015968: 68f8         	ldr	r0, [r7, #0xc]
 801596a: f7ff ff2f    	bl	0x80157cc <gpio_stm32_port_set_bits_raw> @ imm = #-0x1a2
 801596e: e00c         	b	0x801598a <gpio_stm32_config+0xb6> @ imm = #0x18
; 		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
 8015970: 687b         	ldr	r3, [r7, #0x4]
 8015972: f403 2380    	and	r3, r3, #0x40000
 8015976: 2b00         	cmp	r3, #0x0
 8015978: d007         	beq	0x801598a <gpio_stm32_config+0xb6> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 801597a: 7afb         	ldrb	r3, [r7, #0xb]
 801597c: 2201         	movs	r2, #0x1
 801597e: fa02 f303    	lsl.w	r3, r2, r3
 8015982: 4619         	mov	r1, r3
 8015984: 68f8         	ldr	r0, [r7, #0xc]
 8015986: f7ff ff35    	bl	0x80157f4 <gpio_stm32_port_clear_bits_raw> @ imm = #-0x196
; 	gpio_stm32_configure_raw(dev, pin, pincfg, 0);
 801598a: 697a         	ldr	r2, [r7, #0x14]
 801598c: 7af9         	ldrb	r1, [r7, #0xb]
 801598e: 2300         	movs	r3, #0x0
 8015990: 68f8         	ldr	r0, [r7, #0xc]
 8015992: f7ff fe80    	bl	0x8015696 <gpio_stm32_configure_raw> @ imm = #-0x300
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 8015996: 687b         	ldr	r3, [r7, #0x4]
 8015998: f403 3300    	and	r3, r3, #0x20000
 801599c: 2b00         	cmp	r3, #0x0
 801599e: d120         	bne	0x80159e2 <gpio_stm32_config+0x10e> @ imm = #0x40
 80159a0: 687b         	ldr	r3, [r7, #0x4]
 80159a2: f403 3380    	and	r3, r3, #0x10000
 80159a6: 2b00         	cmp	r3, #0x0
 80159a8: d11b         	bne	0x80159e2 <gpio_stm32_config+0x10e> @ imm = #0x36
; 	    (data->pin_has_clock_enabled & BIT(pin))) {
 80159aa: 69fb         	ldr	r3, [r7, #0x1c]
 80159ac: 691a         	ldr	r2, [r3, #0x10]
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 80159ae: 7afb         	ldrb	r3, [r7, #0xb]
 80159b0: fa22 f303    	lsr.w	r3, r2, r3
 80159b4: f003 0301    	and	r3, r3, #0x1
 80159b8: 2b00         	cmp	r3, #0x0
 80159ba: d012         	beq	0x80159e2 <gpio_stm32_config+0x10e> @ imm = #0x24
; 		err = pm_device_runtime_put(dev);
 80159bc: 68f8         	ldr	r0, [r7, #0xc]
 80159be: f7ff fcfd    	bl	0x80153bc <pm_device_runtime_put> @ imm = #-0x606
 80159c2: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 80159c4: 69bb         	ldr	r3, [r7, #0x18]
 80159c6: 2b00         	cmp	r3, #0x0
 80159c8: da01         	bge	0x80159ce <gpio_stm32_config+0xfa> @ imm = #0x2
; 			return err;
 80159ca: 69bb         	ldr	r3, [r7, #0x18]
 80159cc: e00a         	b	0x80159e4 <gpio_stm32_config+0x110> @ imm = #0x14
; 		data->pin_has_clock_enabled &= ~BIT(pin);
 80159ce: 69fb         	ldr	r3, [r7, #0x1c]
 80159d0: 691a         	ldr	r2, [r3, #0x10]
 80159d2: 7afb         	ldrb	r3, [r7, #0xb]
 80159d4: 2101         	movs	r1, #0x1
 80159d6: fa01 f303    	lsl.w	r3, r1, r3
 80159da: 43db         	mvns	r3, r3
 80159dc: 401a         	ands	r2, r3
 80159de: 69fb         	ldr	r3, [r7, #0x1c]
 80159e0: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 80159e2: 2300         	movs	r3, #0x0
; }
 80159e4: 4618         	mov	r0, r3
 80159e6: 3720         	adds	r7, #0x20
 80159e8: 46bd         	mov	sp, r7
 80159ea: bd80         	pop	{r7, pc}

080159ec <gpio_stm32_manage_callback>:
; {
 80159ec: b580         	push	{r7, lr}
 80159ee: b086         	sub	sp, #0x18
 80159f0: af00         	add	r7, sp, #0x0
 80159f2: 60f8         	str	r0, [r7, #0xc]
 80159f4: 60b9         	str	r1, [r7, #0x8]
 80159f6: 4613         	mov	r3, r2
 80159f8: 71fb         	strb	r3, [r7, #0x7]
; 	struct gpio_stm32_data *data = dev->data;
 80159fa: 68fb         	ldr	r3, [r7, #0xc]
 80159fc: 691b         	ldr	r3, [r3, #0x10]
 80159fe: 617b         	str	r3, [r7, #0x14]
; 	return gpio_manage_callback(&data->cb, callback, set);
 8015a00: 697b         	ldr	r3, [r7, #0x14]
 8015a02: 3308         	adds	r3, #0x8
 8015a04: 79fa         	ldrb	r2, [r7, #0x7]
 8015a06: 68b9         	ldr	r1, [r7, #0x8]
 8015a08: 4618         	mov	r0, r3
 8015a0a: f7ff fcf4    	bl	0x80153f6 <gpio_manage_callback> @ imm = #-0x618
 8015a0e: 4603         	mov	r3, r0
; }
 8015a10: 4618         	mov	r0, r3
 8015a12: 3718         	adds	r7, #0x18
 8015a14: 46bd         	mov	sp, r7
 8015a16: bd80         	pop	{r7, pc}

08015a18 <pinctrl_lookup_state>:
; {
 8015a18: b480         	push	{r7}
 8015a1a: b085         	sub	sp, #0x14
 8015a1c: af00         	add	r7, sp, #0x0
 8015a1e: 60f8         	str	r0, [r7, #0xc]
 8015a20: 460b         	mov	r3, r1
 8015a22: 607a         	str	r2, [r7, #0x4]
 8015a24: 72fb         	strb	r3, [r7, #0xb]
; 	*state = &config->states[0];
 8015a26: 68fb         	ldr	r3, [r7, #0xc]
 8015a28: 681a         	ldr	r2, [r3]
 8015a2a: 687b         	ldr	r3, [r7, #0x4]
 8015a2c: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 8015a2e: e00d         	b	0x8015a4c <pinctrl_lookup_state+0x34> @ imm = #0x1a
; 		if (id == (*state)->id) {
 8015a30: 687b         	ldr	r3, [r7, #0x4]
 8015a32: 681b         	ldr	r3, [r3]
 8015a34: 795b         	ldrb	r3, [r3, #0x5]
 8015a36: 7afa         	ldrb	r2, [r7, #0xb]
 8015a38: 429a         	cmp	r2, r3
 8015a3a: d101         	bne	0x8015a40 <pinctrl_lookup_state+0x28> @ imm = #0x2
; 			return 0;
 8015a3c: 2300         	movs	r3, #0x0
 8015a3e: e011         	b	0x8015a64 <pinctrl_lookup_state+0x4c> @ imm = #0x22
; 		(*state)++;
 8015a40: 687b         	ldr	r3, [r7, #0x4]
 8015a42: 681b         	ldr	r3, [r3]
 8015a44: f103 0208    	add.w	r2, r3, #0x8
 8015a48: 687b         	ldr	r3, [r7, #0x4]
 8015a4a: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 8015a4c: 687b         	ldr	r3, [r7, #0x4]
 8015a4e: 681a         	ldr	r2, [r3]
 8015a50: 68fb         	ldr	r3, [r7, #0xc]
 8015a52: 6819         	ldr	r1, [r3]
 8015a54: 68fb         	ldr	r3, [r7, #0xc]
 8015a56: 791b         	ldrb	r3, [r3, #0x4]
 8015a58: 00db         	lsls	r3, r3, #0x3
 8015a5a: 440b         	add	r3, r1
 8015a5c: 429a         	cmp	r2, r3
 8015a5e: d3e7         	blo	0x8015a30 <pinctrl_lookup_state+0x18> @ imm = #-0x32
; 	return -ENOENT;
 8015a60: f06f 0301    	mvn	r3, #0x1
; }
 8015a64: 4618         	mov	r0, r3
 8015a66: 3714         	adds	r7, #0x14
 8015a68: 46bd         	mov	sp, r7
 8015a6a: bc80         	pop	{r7}
 8015a6c: 4770         	bx	lr

08015a6e <device_is_ready>:
; {
 8015a6e: b580         	push	{r7, lr}
 8015a70: b082         	sub	sp, #0x8
 8015a72: af00         	add	r7, sp, #0x0
 8015a74: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8015a76: 6878         	ldr	r0, [r7, #0x4]
 8015a78: f002 fedd    	bl	0x8018836 <z_impl_device_is_ready> @ imm = #0x2dba
 8015a7c: 4603         	mov	r3, r0
; }
 8015a7e: 4618         	mov	r0, r3
 8015a80: 3708         	adds	r7, #0x8
 8015a82: 46bd         	mov	sp, r7
 8015a84: bd80         	pop	{r7, pc}

08015a86 <pinctrl_configure_pins>:
; {
 8015a86: b580         	push	{r7, lr}
 8015a88: b08a         	sub	sp, #0x28
 8015a8a: af00         	add	r7, sp, #0x0
 8015a8c: 60f8         	str	r0, [r7, #0xc]
 8015a8e: 460b         	mov	r3, r1
 8015a90: 607a         	str	r2, [r7, #0x4]
 8015a92: 72fb         	strb	r3, [r7, #0xb]
; 	uint32_t pin_cgf = 0;
 8015a94: 2300         	movs	r3, #0x0
 8015a96: 627b         	str	r3, [r7, #0x24]
; 	int ret = 0;
 8015a98: 2300         	movs	r3, #0x0
 8015a9a: 61fb         	str	r3, [r7, #0x1c]
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 8015a9c: 2300         	movs	r3, #0x0
 8015a9e: f887 3023    	strb.w	r3, [r7, #0x23]
 8015aa2: e047         	b	0x8015b34 <pinctrl_configure_pins+0xae> @ imm = #0x8e
; 		mux = pins[i].pinmux;
 8015aa4: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8015aa8: 00db         	lsls	r3, r3, #0x3
 8015aaa: 68fa         	ldr	r2, [r7, #0xc]
 8015aac: 4413         	add	r3, r2
 8015aae: 681b         	ldr	r3, [r3]
 8015ab0: 61bb         	str	r3, [r7, #0x18]
; 		if (STM32_DT_PINMUX_FUNC(mux) < STM32_ANALOG) {
 8015ab2: 69bb         	ldr	r3, [r7, #0x18]
 8015ab4: f003 0310    	and	r3, r3, #0x10
 8015ab8: 2b00         	cmp	r3, #0x0
 8015aba: d109         	bne	0x8015ad0 <pinctrl_configure_pins+0x4a> @ imm = #0x12
; 			pin_cgf = pins[i].pincfg | STM32_MODER_ALT_MODE;
 8015abc: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8015ac0: 00db         	lsls	r3, r3, #0x3
 8015ac2: 68fa         	ldr	r2, [r7, #0xc]
 8015ac4: 4413         	add	r3, r2
 8015ac6: 685b         	ldr	r3, [r3, #0x4]
 8015ac8: f043 0320    	orr	r3, r3, #0x20
 8015acc: 627b         	str	r3, [r7, #0x24]
 8015ace: e013         	b	0x8015af8 <pinctrl_configure_pins+0x72> @ imm = #0x26
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_ANALOG) {
 8015ad0: 69bb         	ldr	r3, [r7, #0x18]
 8015ad2: f003 031f    	and	r3, r3, #0x1f
 8015ad6: 2b10         	cmp	r3, #0x10
 8015ad8: d102         	bne	0x8015ae0 <pinctrl_configure_pins+0x5a> @ imm = #0x4
; 			pin_cgf = STM32_MODER_ANALOG_MODE;
 8015ada: 2330         	movs	r3, #0x30
 8015adc: 627b         	str	r3, [r7, #0x24]
 8015ade: e00b         	b	0x8015af8 <pinctrl_configure_pins+0x72> @ imm = #0x16
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_GPIO) {
 8015ae0: 69bb         	ldr	r3, [r7, #0x18]
 8015ae2: f003 031f    	and	r3, r3, #0x1f
 8015ae6: 2b11         	cmp	r3, #0x11
 8015ae8: d106         	bne	0x8015af8 <pinctrl_configure_pins+0x72> @ imm = #0xc
; 			pin_cgf = pins[i].pincfg;
 8015aea: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8015aee: 00db         	lsls	r3, r3, #0x3
 8015af0: 68fa         	ldr	r2, [r7, #0xc]
 8015af2: 4413         	add	r3, r2
 8015af4: 685b         	ldr	r3, [r3, #0x4]
 8015af6: 627b         	str	r3, [r7, #0x24]
; 		pin = STM32PIN(STM32_DT_PINMUX_PORT(mux),
 8015af8: 69bb         	ldr	r3, [r7, #0x18]
 8015afa: 0a5b         	lsrs	r3, r3, #0x9
 8015afc: 011b         	lsls	r3, r3, #0x4
 8015afe: f403 72f8    	and	r2, r3, #0x1f0
 8015b02: 69bb         	ldr	r3, [r7, #0x18]
 8015b04: 095b         	lsrs	r3, r3, #0x5
 8015b06: f003 030f    	and	r3, r3, #0xf
 8015b0a: 4313         	orrs	r3, r2
 8015b0c: 617b         	str	r3, [r7, #0x14]
; 		ret = stm32_pin_configure(pin, pin_cgf, STM32_DT_PINMUX_FUNC(mux));
 8015b0e: 69bb         	ldr	r3, [r7, #0x18]
 8015b10: f003 031f    	and	r3, r3, #0x1f
 8015b14: 461a         	mov	r2, r3
 8015b16: 6a79         	ldr	r1, [r7, #0x24]
 8015b18: 6978         	ldr	r0, [r7, #0x14]
 8015b1a: f7f1 fe1d    	bl	0x8007758 <stm32_pin_configure> @ imm = #-0xe3c6
 8015b1e: 61f8         	str	r0, [r7, #0x1c]
; 		if (ret < 0) {
 8015b20: 69fb         	ldr	r3, [r7, #0x1c]
 8015b22: 2b00         	cmp	r3, #0x0
 8015b24: da01         	bge	0x8015b2a <pinctrl_configure_pins+0xa4> @ imm = #0x2
; 			return ret;
 8015b26: 69fb         	ldr	r3, [r7, #0x1c]
 8015b28: e00a         	b	0x8015b40 <pinctrl_configure_pins+0xba> @ imm = #0x14
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 8015b2a: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8015b2e: 3301         	adds	r3, #0x1
 8015b30: f887 3023    	strb.w	r3, [r7, #0x23]
 8015b34: f897 2023    	ldrb.w	r2, [r7, #0x23]
 8015b38: 7afb         	ldrb	r3, [r7, #0xb]
 8015b3a: 429a         	cmp	r2, r3
 8015b3c: d3b2         	blo	0x8015aa4 <pinctrl_configure_pins+0x1e> @ imm = #-0x9c
; 	return 0;
 8015b3e: 2300         	movs	r3, #0x0
; }
 8015b40: 4618         	mov	r0, r3
 8015b42: 3728         	adds	r7, #0x28
 8015b44: 46bd         	mov	sp, r7
 8015b46: bd80         	pop	{r7, pc}

08015b48 <reset_stm32_status>:
; {
 8015b48: b480         	push	{r7}
 8015b4a: b089         	sub	sp, #0x24
 8015b4c: af00         	add	r7, sp, #0x0
 8015b4e: 60f8         	str	r0, [r7, #0xc]
 8015b50: 60b9         	str	r1, [r7, #0x8]
 8015b52: 607a         	str	r2, [r7, #0x4]
; 	const struct reset_stm32_config *config = dev->config;
 8015b54: 68fb         	ldr	r3, [r7, #0xc]
 8015b56: 685b         	ldr	r3, [r3, #0x4]
 8015b58: 61fb         	str	r3, [r7, #0x1c]
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8015b5a: 69fb         	ldr	r3, [r7, #0x1c]
 8015b5c: 681a         	ldr	r2, [r3]
 8015b5e: 68bb         	ldr	r3, [r7, #0x8]
 8015b60: 095b         	lsrs	r3, r3, #0x5
 8015b62: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8015b66: 441a         	add	r2, r3
 8015b68: 68bb         	ldr	r3, [r7, #0x8]
 8015b6a: f003 031f    	and	r3, r3, #0x1f
 8015b6e: 61ba         	str	r2, [r7, #0x18]
 8015b70: 617b         	str	r3, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8015b72: 69bb         	ldr	r3, [r7, #0x18]
 8015b74: 681b         	ldr	r3, [r3]
 8015b76: 613b         	str	r3, [r7, #0x10]
; 	return temp & (1 << bit);
 8015b78: 2201         	movs	r2, #0x1
 8015b7a: 697b         	ldr	r3, [r7, #0x14]
 8015b7c: fa02 f303    	lsl.w	r3, r2, r3
 8015b80: 461a         	mov	r2, r3
 8015b82: 693b         	ldr	r3, [r7, #0x10]
 8015b84: 4013         	ands	r3, r2
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8015b86: 2b00         	cmp	r3, #0x0
 8015b88: bf14         	ite	ne
 8015b8a: 2301         	movne	r3, #0x1
 8015b8c: 2300         	moveq	r3, #0x0
 8015b8e: b2db         	uxtb	r3, r3
 8015b90: 461a         	mov	r2, r3
 8015b92: 687b         	ldr	r3, [r7, #0x4]
 8015b94: 701a         	strb	r2, [r3]
; 	return 0;
 8015b96: 2300         	movs	r3, #0x0
; }
 8015b98: 4618         	mov	r0, r3
 8015b9a: 3724         	adds	r7, #0x24
 8015b9c: 46bd         	mov	sp, r7
 8015b9e: bc80         	pop	{r7}
 8015ba0: 4770         	bx	lr

08015ba2 <reset_stm32_line_assert>:
; {
 8015ba2: b480         	push	{r7}
 8015ba4: b087         	sub	sp, #0x1c
 8015ba6: af00         	add	r7, sp, #0x0
 8015ba8: 6078         	str	r0, [r7, #0x4]
 8015baa: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 8015bac: 687b         	ldr	r3, [r7, #0x4]
 8015bae: 685b         	ldr	r3, [r3, #0x4]
 8015bb0: 617b         	str	r3, [r7, #0x14]
; 	sys_set_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8015bb2: 697b         	ldr	r3, [r7, #0x14]
 8015bb4: 681a         	ldr	r2, [r3]
 8015bb6: 683b         	ldr	r3, [r7]
 8015bb8: 095b         	lsrs	r3, r3, #0x5
 8015bba: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8015bbe: 441a         	add	r2, r3
 8015bc0: 683b         	ldr	r3, [r7]
 8015bc2: f003 031f    	and	r3, r3, #0x1f
 8015bc6: 613a         	str	r2, [r7, #0x10]
 8015bc8: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8015bca: 693b         	ldr	r3, [r7, #0x10]
 8015bcc: 681b         	ldr	r3, [r3]
 8015bce: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp | (1 << bit);
 8015bd0: 2201         	movs	r2, #0x1
 8015bd2: 68fb         	ldr	r3, [r7, #0xc]
 8015bd4: fa02 f303    	lsl.w	r3, r2, r3
 8015bd8: 4619         	mov	r1, r3
 8015bda: 693b         	ldr	r3, [r7, #0x10]
 8015bdc: 68ba         	ldr	r2, [r7, #0x8]
 8015bde: 430a         	orrs	r2, r1
 8015be0: 601a         	str	r2, [r3]
; }
 8015be2: bf00         	nop
; 	return 0;
 8015be4: 2300         	movs	r3, #0x0
; }
 8015be6: 4618         	mov	r0, r3
 8015be8: 371c         	adds	r7, #0x1c
 8015bea: 46bd         	mov	sp, r7
 8015bec: bc80         	pop	{r7}
 8015bee: 4770         	bx	lr

08015bf0 <reset_stm32_line_deassert>:
; {
 8015bf0: b480         	push	{r7}
 8015bf2: b087         	sub	sp, #0x1c
 8015bf4: af00         	add	r7, sp, #0x0
 8015bf6: 6078         	str	r0, [r7, #0x4]
 8015bf8: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 8015bfa: 687b         	ldr	r3, [r7, #0x4]
 8015bfc: 685b         	ldr	r3, [r3, #0x4]
 8015bfe: 617b         	str	r3, [r7, #0x14]
; 	sys_clear_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8015c00: 697b         	ldr	r3, [r7, #0x14]
 8015c02: 681a         	ldr	r2, [r3]
 8015c04: 683b         	ldr	r3, [r7]
 8015c06: 095b         	lsrs	r3, r3, #0x5
 8015c08: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8015c0c: 441a         	add	r2, r3
 8015c0e: 683b         	ldr	r3, [r7]
 8015c10: f003 031f    	and	r3, r3, #0x1f
 8015c14: 613a         	str	r2, [r7, #0x10]
 8015c16: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8015c18: 693b         	ldr	r3, [r7, #0x10]
 8015c1a: 681b         	ldr	r3, [r3]
 8015c1c: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~(1 << bit);
 8015c1e: 2201         	movs	r2, #0x1
 8015c20: 68fb         	ldr	r3, [r7, #0xc]
 8015c22: fa02 f303    	lsl.w	r3, r2, r3
 8015c26: 43db         	mvns	r3, r3
 8015c28: 4619         	mov	r1, r3
 8015c2a: 693b         	ldr	r3, [r7, #0x10]
 8015c2c: 68ba         	ldr	r2, [r7, #0x8]
 8015c2e: 400a         	ands	r2, r1
 8015c30: 601a         	str	r2, [r3]
; }
 8015c32: bf00         	nop
; 	return 0;
 8015c34: 2300         	movs	r3, #0x0
; }
 8015c36: 4618         	mov	r0, r3
 8015c38: 371c         	adds	r7, #0x1c
 8015c3a: 46bd         	mov	sp, r7
 8015c3c: bc80         	pop	{r7}
 8015c3e: 4770         	bx	lr

08015c40 <reset_stm32_line_toggle>:
; {
 8015c40: b580         	push	{r7, lr}
 8015c42: b082         	sub	sp, #0x8
 8015c44: af00         	add	r7, sp, #0x0
 8015c46: 6078         	str	r0, [r7, #0x4]
 8015c48: 6039         	str	r1, [r7]
; 	reset_stm32_line_assert(dev, id);
 8015c4a: 6839         	ldr	r1, [r7]
 8015c4c: 6878         	ldr	r0, [r7, #0x4]
 8015c4e: f7ff ffa8    	bl	0x8015ba2 <reset_stm32_line_assert> @ imm = #-0xb0
; 	reset_stm32_line_deassert(dev, id);
 8015c52: 6839         	ldr	r1, [r7]
 8015c54: 6878         	ldr	r0, [r7, #0x4]
 8015c56: f7ff ffcb    	bl	0x8015bf0 <reset_stm32_line_deassert> @ imm = #-0x6a
; 	return 0;
 8015c5a: 2300         	movs	r3, #0x0
; }
 8015c5c: 4618         	mov	r0, r3
 8015c5e: 3708         	adds	r7, #0x8
 8015c60: 46bd         	mov	sp, r7
 8015c62: bd80         	pop	{r7, pc}

08015c64 <device_is_ready>:
; {
 8015c64: b580         	push	{r7, lr}
 8015c66: b082         	sub	sp, #0x8
 8015c68: af00         	add	r7, sp, #0x0
 8015c6a: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8015c6c: 6878         	ldr	r0, [r7, #0x4]
 8015c6e: f002 fde2    	bl	0x8018836 <z_impl_device_is_ready> @ imm = #0x2bc4
 8015c72: 4603         	mov	r3, r0
; }
 8015c74: 4618         	mov	r0, r3
 8015c76: 3708         	adds	r7, #0x8
 8015c78: 46bd         	mov	sp, r7
 8015c7a: bd80         	pop	{r7, pc}

08015c7c <k_work_delayable_from_work>:
; {
 8015c7c: b480         	push	{r7}
 8015c7e: b083         	sub	sp, #0xc
 8015c80: af00         	add	r7, sp, #0x0
 8015c82: 6078         	str	r0, [r7, #0x4]
; 	return CONTAINER_OF(work, struct k_work_delayable, work);
 8015c84: 687b         	ldr	r3, [r7, #0x4]
; }
 8015c86: 4618         	mov	r0, r3
 8015c88: 370c         	adds	r7, #0xc
 8015c8a: 46bd         	mov	sp, r7
 8015c8c: bc80         	pop	{r7}
 8015c8e: 4770         	bx	lr

08015c90 <clock_control_on>:
; {
 8015c90: b580         	push	{r7, lr}
 8015c92: b084         	sub	sp, #0x10
 8015c94: af00         	add	r7, sp, #0x0
 8015c96: 6078         	str	r0, [r7, #0x4]
 8015c98: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8015c9a: 687b         	ldr	r3, [r7, #0x4]
 8015c9c: 689b         	ldr	r3, [r3, #0x8]
 8015c9e: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8015ca0: 68fb         	ldr	r3, [r7, #0xc]
 8015ca2: 681b         	ldr	r3, [r3]
 8015ca4: 6839         	ldr	r1, [r7]
 8015ca6: 6878         	ldr	r0, [r7, #0x4]
 8015ca8: 4798         	blx	r3
 8015caa: 4603         	mov	r3, r0
; }
 8015cac: 4618         	mov	r0, r3
 8015cae: 3710         	adds	r7, #0x10
 8015cb0: 46bd         	mov	sp, r7
 8015cb2: bd80         	pop	{r7, pc}

08015cb4 <clock_control_get_rate>:
; {
 8015cb4: b580         	push	{r7, lr}
 8015cb6: b086         	sub	sp, #0x18
 8015cb8: af00         	add	r7, sp, #0x0
 8015cba: 60f8         	str	r0, [r7, #0xc]
 8015cbc: 60b9         	str	r1, [r7, #0x8]
 8015cbe: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 8015cc0: 68fb         	ldr	r3, [r7, #0xc]
 8015cc2: 689b         	ldr	r3, [r3, #0x8]
 8015cc4: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 8015cc6: 697b         	ldr	r3, [r7, #0x14]
 8015cc8: 68db         	ldr	r3, [r3, #0xc]
 8015cca: 2b00         	cmp	r3, #0x0
 8015ccc: d102         	bne	0x8015cd4 <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8015cce: f06f 0357    	mvn	r3, #0x57
 8015cd2: e006         	b	0x8015ce2 <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 8015cd4: 697b         	ldr	r3, [r7, #0x14]
 8015cd6: 68db         	ldr	r3, [r3, #0xc]
 8015cd8: 687a         	ldr	r2, [r7, #0x4]
 8015cda: 68b9         	ldr	r1, [r7, #0x8]
 8015cdc: 68f8         	ldr	r0, [r7, #0xc]
 8015cde: 4798         	blx	r3
 8015ce0: 4603         	mov	r3, r0
; }
 8015ce2: 4618         	mov	r0, r3
 8015ce4: 3718         	adds	r7, #0x18
 8015ce6: 46bd         	mov	sp, r7
 8015ce8: bd80         	pop	{r7, pc}

08015cea <dma_config>:
; {
 8015cea: b580         	push	{r7, lr}
 8015cec: b086         	sub	sp, #0x18
 8015cee: af00         	add	r7, sp, #0x0
 8015cf0: 60f8         	str	r0, [r7, #0xc]
 8015cf2: 60b9         	str	r1, [r7, #0x8]
 8015cf4: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_driver_api *api =
 8015cf6: 68fb         	ldr	r3, [r7, #0xc]
 8015cf8: 689b         	ldr	r3, [r3, #0x8]
 8015cfa: 617b         	str	r3, [r7, #0x14]
; 	return api->config(dev, channel, config);
 8015cfc: 697b         	ldr	r3, [r7, #0x14]
 8015cfe: 681b         	ldr	r3, [r3]
 8015d00: 687a         	ldr	r2, [r7, #0x4]
 8015d02: 68b9         	ldr	r1, [r7, #0x8]
 8015d04: 68f8         	ldr	r0, [r7, #0xc]
 8015d06: 4798         	blx	r3
 8015d08: 4603         	mov	r3, r0
; }
 8015d0a: 4618         	mov	r0, r3
 8015d0c: 3718         	adds	r7, #0x18
 8015d0e: 46bd         	mov	sp, r7
 8015d10: bd80         	pop	{r7, pc}

08015d12 <dma_reload>:
; {
 8015d12: b590         	push	{r4, r7, lr}
 8015d14: b089         	sub	sp, #0x24
 8015d16: af02         	add	r7, sp, #0x8
 8015d18: 60f8         	str	r0, [r7, #0xc]
 8015d1a: 60b9         	str	r1, [r7, #0x8]
 8015d1c: 607a         	str	r2, [r7, #0x4]
 8015d1e: 603b         	str	r3, [r7]
; 	const struct dma_driver_api *api =
 8015d20: 68fb         	ldr	r3, [r7, #0xc]
 8015d22: 689b         	ldr	r3, [r3, #0x8]
 8015d24: 617b         	str	r3, [r7, #0x14]
; 	if (api->reload) {
 8015d26: 697b         	ldr	r3, [r7, #0x14]
 8015d28: 685b         	ldr	r3, [r3, #0x4]
 8015d2a: 2b00         	cmp	r3, #0x0
 8015d2c: d00a         	beq	0x8015d44 <dma_reload+0x32> @ imm = #0x14
; 		return api->reload(dev, channel, src, dst, size);
 8015d2e: 697b         	ldr	r3, [r7, #0x14]
 8015d30: 685c         	ldr	r4, [r3, #0x4]
 8015d32: 6abb         	ldr	r3, [r7, #0x28]
 8015d34: 9300         	str	r3, [sp]
 8015d36: 683b         	ldr	r3, [r7]
 8015d38: 687a         	ldr	r2, [r7, #0x4]
 8015d3a: 68b9         	ldr	r1, [r7, #0x8]
 8015d3c: 68f8         	ldr	r0, [r7, #0xc]
 8015d3e: 47a0         	blx	r4
 8015d40: 4603         	mov	r3, r0
 8015d42: e001         	b	0x8015d48 <dma_reload+0x36> @ imm = #0x2
; 	return -ENOSYS;
 8015d44: f06f 0357    	mvn	r3, #0x57
; }
 8015d48: 4618         	mov	r0, r3
 8015d4a: 371c         	adds	r7, #0x1c
 8015d4c: 46bd         	mov	sp, r7
 8015d4e: bd90         	pop	{r4, r7, pc}

08015d50 <z_impl_dma_start>:
; {
 8015d50: b580         	push	{r7, lr}
 8015d52: b084         	sub	sp, #0x10
 8015d54: af00         	add	r7, sp, #0x0
 8015d56: 6078         	str	r0, [r7, #0x4]
 8015d58: 6039         	str	r1, [r7]
; 	const struct dma_driver_api *api =
 8015d5a: 687b         	ldr	r3, [r7, #0x4]
 8015d5c: 689b         	ldr	r3, [r3, #0x8]
 8015d5e: 60fb         	str	r3, [r7, #0xc]
; 	return api->start(dev, channel);
 8015d60: 68fb         	ldr	r3, [r7, #0xc]
 8015d62: 689b         	ldr	r3, [r3, #0x8]
 8015d64: 6839         	ldr	r1, [r7]
 8015d66: 6878         	ldr	r0, [r7, #0x4]
 8015d68: 4798         	blx	r3
 8015d6a: 4603         	mov	r3, r0
; }
 8015d6c: 4618         	mov	r0, r3
 8015d6e: 3710         	adds	r7, #0x10
 8015d70: 46bd         	mov	sp, r7
 8015d72: bd80         	pop	{r7, pc}

08015d74 <z_impl_dma_stop>:
; {
 8015d74: b580         	push	{r7, lr}
 8015d76: b084         	sub	sp, #0x10
 8015d78: af00         	add	r7, sp, #0x0
 8015d7a: 6078         	str	r0, [r7, #0x4]
 8015d7c: 6039         	str	r1, [r7]
; 	const struct dma_driver_api *api =
 8015d7e: 687b         	ldr	r3, [r7, #0x4]
 8015d80: 689b         	ldr	r3, [r3, #0x8]
 8015d82: 60fb         	str	r3, [r7, #0xc]
; 	return api->stop(dev, channel);
 8015d84: 68fb         	ldr	r3, [r7, #0xc]
 8015d86: 68db         	ldr	r3, [r3, #0xc]
 8015d88: 6839         	ldr	r1, [r7]
 8015d8a: 6878         	ldr	r0, [r7, #0x4]
 8015d8c: 4798         	blx	r3
 8015d8e: 4603         	mov	r3, r0
; }
 8015d90: 4618         	mov	r0, r3
 8015d92: 3710         	adds	r7, #0x10
 8015d94: 46bd         	mov	sp, r7
 8015d96: bd80         	pop	{r7, pc}

08015d98 <dma_get_status>:
; {
 8015d98: b580         	push	{r7, lr}
 8015d9a: b086         	sub	sp, #0x18
 8015d9c: af00         	add	r7, sp, #0x0
 8015d9e: 60f8         	str	r0, [r7, #0xc]
 8015da0: 60b9         	str	r1, [r7, #0x8]
 8015da2: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_driver_api *api =
 8015da4: 68fb         	ldr	r3, [r7, #0xc]
 8015da6: 689b         	ldr	r3, [r3, #0x8]
 8015da8: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_status) {
 8015daa: 697b         	ldr	r3, [r7, #0x14]
 8015dac: 699b         	ldr	r3, [r3, #0x18]
 8015dae: 2b00         	cmp	r3, #0x0
 8015db0: d007         	beq	0x8015dc2 <dma_get_status+0x2a> @ imm = #0xe
; 		return api->get_status(dev, channel, stat);
 8015db2: 697b         	ldr	r3, [r7, #0x14]
 8015db4: 699b         	ldr	r3, [r3, #0x18]
 8015db6: 687a         	ldr	r2, [r7, #0x4]
 8015db8: 68b9         	ldr	r1, [r7, #0x8]
 8015dba: 68f8         	ldr	r0, [r7, #0xc]
 8015dbc: 4798         	blx	r3
 8015dbe: 4603         	mov	r3, r0
 8015dc0: e001         	b	0x8015dc6 <dma_get_status+0x2e> @ imm = #0x2
; 	return -ENOSYS;
 8015dc2: f06f 0357    	mvn	r3, #0x57
; }
 8015dc6: 4618         	mov	r0, r3
 8015dc8: 3718         	adds	r7, #0x18
 8015dca: 46bd         	mov	sp, r7
 8015dcc: bd80         	pop	{r7, pc}

08015dce <dma_start>:
; {
 8015dce: b580         	push	{r7, lr}
 8015dd0: b082         	sub	sp, #0x8
 8015dd2: af00         	add	r7, sp, #0x0
 8015dd4: 6078         	str	r0, [r7, #0x4]
 8015dd6: 6039         	str	r1, [r7]
; 	return z_impl_dma_start(dev, channel);
 8015dd8: 6839         	ldr	r1, [r7]
 8015dda: 6878         	ldr	r0, [r7, #0x4]
 8015ddc: f7ff ffb8    	bl	0x8015d50 <z_impl_dma_start> @ imm = #-0x90
 8015de0: 4603         	mov	r3, r0
; }
 8015de2: 4618         	mov	r0, r3
 8015de4: 3708         	adds	r7, #0x8
 8015de6: 46bd         	mov	sp, r7
 8015de8: bd80         	pop	{r7, pc}

08015dea <dma_stop>:
; {
 8015dea: b580         	push	{r7, lr}
 8015dec: b082         	sub	sp, #0x8
 8015dee: af00         	add	r7, sp, #0x0
 8015df0: 6078         	str	r0, [r7, #0x4]
 8015df2: 6039         	str	r1, [r7]
; 	return z_impl_dma_stop(dev, channel);
 8015df4: 6839         	ldr	r1, [r7]
 8015df6: 6878         	ldr	r0, [r7, #0x4]
 8015df8: f7ff ffbc    	bl	0x8015d74 <z_impl_dma_stop> @ imm = #-0x88
 8015dfc: 4603         	mov	r3, r0
; }
 8015dfe: 4618         	mov	r0, r3
 8015e00: 3708         	adds	r7, #0x8
 8015e02: 46bd         	mov	sp, r7
 8015e04: bd80         	pop	{r7, pc}

08015e06 <pinctrl_apply_state_direct>:
; {
 8015e06: b580         	push	{r7, lr}
 8015e08: b084         	sub	sp, #0x10
 8015e0a: af00         	add	r7, sp, #0x0
 8015e0c: 6078         	str	r0, [r7, #0x4]
 8015e0e: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 8015e10: 2300         	movs	r3, #0x0
 8015e12: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 8015e14: 683b         	ldr	r3, [r7]
 8015e16: 6818         	ldr	r0, [r3]
 8015e18: 683b         	ldr	r3, [r7]
 8015e1a: 791b         	ldrb	r3, [r3, #0x4]
 8015e1c: 68fa         	ldr	r2, [r7, #0xc]
 8015e1e: 4619         	mov	r1, r3
 8015e20: f7ff fe31    	bl	0x8015a86 <pinctrl_configure_pins> @ imm = #-0x39e
 8015e24: 4603         	mov	r3, r0
; }
 8015e26: 4618         	mov	r0, r3
 8015e28: 3710         	adds	r7, #0x10
 8015e2a: 46bd         	mov	sp, r7
 8015e2c: bd80         	pop	{r7, pc}

08015e2e <pinctrl_apply_state>:
; {
 8015e2e: b580         	push	{r7, lr}
 8015e30: b084         	sub	sp, #0x10
 8015e32: af00         	add	r7, sp, #0x0
 8015e34: 6078         	str	r0, [r7, #0x4]
 8015e36: 460b         	mov	r3, r1
 8015e38: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 8015e3a: f107 0208    	add.w	r2, r7, #0x8
 8015e3e: 78fb         	ldrb	r3, [r7, #0x3]
 8015e40: 4619         	mov	r1, r3
 8015e42: 6878         	ldr	r0, [r7, #0x4]
 8015e44: f7ff fde8    	bl	0x8015a18 <pinctrl_lookup_state> @ imm = #-0x430
 8015e48: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8015e4a: 68fb         	ldr	r3, [r7, #0xc]
 8015e4c: 2b00         	cmp	r3, #0x0
 8015e4e: da01         	bge	0x8015e54 <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 8015e50: 68fb         	ldr	r3, [r7, #0xc]
 8015e52: e005         	b	0x8015e60 <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 8015e54: 68bb         	ldr	r3, [r7, #0x8]
 8015e56: 4619         	mov	r1, r3
 8015e58: 6878         	ldr	r0, [r7, #0x4]
 8015e5a: f7ff ffd4    	bl	0x8015e06 <pinctrl_apply_state_direct> @ imm = #-0x58
 8015e5e: 4603         	mov	r3, r0
; }
 8015e60: 4618         	mov	r0, r3
 8015e62: 3710         	adds	r7, #0x10
 8015e64: 46bd         	mov	sp, r7
 8015e66: bd80         	pop	{r7, pc}

08015e68 <z_impl_reset_line_toggle>:
; {
 8015e68: b580         	push	{r7, lr}
 8015e6a: b084         	sub	sp, #0x10
 8015e6c: af00         	add	r7, sp, #0x0
 8015e6e: 6078         	str	r0, [r7, #0x4]
 8015e70: 6039         	str	r1, [r7]
; 	const struct reset_driver_api *api = (const struct reset_driver_api *)dev->api;
 8015e72: 687b         	ldr	r3, [r7, #0x4]
 8015e74: 689b         	ldr	r3, [r3, #0x8]
 8015e76: 60fb         	str	r3, [r7, #0xc]
; 	if (api->line_toggle == NULL) {
 8015e78: 68fb         	ldr	r3, [r7, #0xc]
 8015e7a: 68db         	ldr	r3, [r3, #0xc]
 8015e7c: 2b00         	cmp	r3, #0x0
 8015e7e: d102         	bne	0x8015e86 <z_impl_reset_line_toggle+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 8015e80: f06f 0357    	mvn	r3, #0x57
 8015e84: e005         	b	0x8015e92 <z_impl_reset_line_toggle+0x2a> @ imm = #0xa
; 	return api->line_toggle(dev, id);
 8015e86: 68fb         	ldr	r3, [r7, #0xc]
 8015e88: 68db         	ldr	r3, [r3, #0xc]
 8015e8a: 6839         	ldr	r1, [r7]
 8015e8c: 6878         	ldr	r0, [r7, #0x4]
 8015e8e: 4798         	blx	r3
 8015e90: 4603         	mov	r3, r0
; }
 8015e92: 4618         	mov	r0, r3
 8015e94: 3710         	adds	r7, #0x10
 8015e96: 46bd         	mov	sp, r7
 8015e98: bd80         	pop	{r7, pc}

08015e9a <reset_line_toggle_dt>:
; {
 8015e9a: b580         	push	{r7, lr}
 8015e9c: b082         	sub	sp, #0x8
 8015e9e: af00         	add	r7, sp, #0x0
 8015ea0: 6078         	str	r0, [r7, #0x4]
; 	return reset_line_toggle(spec->dev, spec->id);
 8015ea2: 687b         	ldr	r3, [r7, #0x4]
 8015ea4: 681a         	ldr	r2, [r3]
 8015ea6: 687b         	ldr	r3, [r7, #0x4]
 8015ea8: 685b         	ldr	r3, [r3, #0x4]
 8015eaa: 4619         	mov	r1, r3
 8015eac: 4610         	mov	r0, r2
 8015eae: f000 f805    	bl	0x8015ebc <reset_line_toggle> @ imm = #0xa
 8015eb2: 4603         	mov	r3, r0
; }
 8015eb4: 4618         	mov	r0, r3
 8015eb6: 3708         	adds	r7, #0x8
 8015eb8: 46bd         	mov	sp, r7
 8015eba: bd80         	pop	{r7, pc}

08015ebc <reset_line_toggle>:
; {
 8015ebc: b580         	push	{r7, lr}
 8015ebe: b082         	sub	sp, #0x8
 8015ec0: af00         	add	r7, sp, #0x0
 8015ec2: 6078         	str	r0, [r7, #0x4]
 8015ec4: 6039         	str	r1, [r7]
; 	return z_impl_reset_line_toggle(dev, id);
 8015ec6: 6839         	ldr	r1, [r7]
 8015ec8: 6878         	ldr	r0, [r7, #0x4]
 8015eca: f7ff ffcd    	bl	0x8015e68 <z_impl_reset_line_toggle> @ imm = #-0x66
 8015ece: 4603         	mov	r3, r0
; }
 8015ed0: 4618         	mov	r0, r3
 8015ed2: 3708         	adds	r7, #0x8
 8015ed4: 46bd         	mov	sp, r7
 8015ed6: bd80         	pop	{r7, pc}

08015ed8 <LL_USART_Enable>:
; {
 8015ed8: b480         	push	{r7}
 8015eda: b083         	sub	sp, #0xc
 8015edc: af00         	add	r7, sp, #0x0
 8015ede: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR1, USART_CR1_UE);
 8015ee0: 687b         	ldr	r3, [r7, #0x4]
 8015ee2: 68db         	ldr	r3, [r3, #0xc]
 8015ee4: f443 5200    	orr	r2, r3, #0x2000
 8015ee8: 687b         	ldr	r3, [r7, #0x4]
 8015eea: 60da         	str	r2, [r3, #0xc]
; }
 8015eec: bf00         	nop
 8015eee: 370c         	adds	r7, #0xc
 8015ef0: 46bd         	mov	sp, r7
 8015ef2: bc80         	pop	{r7}
 8015ef4: 4770         	bx	lr

08015ef6 <LL_USART_Disable>:
; {
 8015ef6: b480         	push	{r7}
 8015ef8: b083         	sub	sp, #0xc
 8015efa: af00         	add	r7, sp, #0x0
 8015efc: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
 8015efe: 687b         	ldr	r3, [r7, #0x4]
 8015f00: 68db         	ldr	r3, [r3, #0xc]
 8015f02: f423 5200    	bic	r2, r3, #0x2000
 8015f06: 687b         	ldr	r3, [r7, #0x4]
 8015f08: 60da         	str	r2, [r3, #0xc]
; }
 8015f0a: bf00         	nop
 8015f0c: 370c         	adds	r7, #0xc
 8015f0e: 46bd         	mov	sp, r7
 8015f10: bc80         	pop	{r7}
 8015f12: 4770         	bx	lr

08015f14 <LL_USART_SetTransferDirection>:
; {
 8015f14: b480         	push	{r7}
 8015f16: b089         	sub	sp, #0x24
 8015f18: af00         	add	r7, sp, #0x0
 8015f1a: 6078         	str	r0, [r7, #0x4]
 8015f1c: 6039         	str	r1, [r7]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8015f1e: 687b         	ldr	r3, [r7, #0x4]
 8015f20: 330c         	adds	r3, #0xc
 8015f22: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8015f24: 68fb         	ldr	r3, [r7, #0xc]
 8015f26: e853 3f00    	ldrex	r3, [r3]
 8015f2a: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8015f2c: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8015f2e: f023 030c    	bic	r3, r3, #0xc
 8015f32: 683a         	ldr	r2, [r7]
 8015f34: 4313         	orrs	r3, r2
 8015f36: 61fb         	str	r3, [r7, #0x1c]
 8015f38: 687b         	ldr	r3, [r7, #0x4]
 8015f3a: 330c         	adds	r3, #0xc
 8015f3c: 69fa         	ldr	r2, [r7, #0x1c]
 8015f3e: 61ba         	str	r2, [r7, #0x18]
 8015f40: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8015f42: 6979         	ldr	r1, [r7, #0x14]
 8015f44: 69ba         	ldr	r2, [r7, #0x18]
 8015f46: e841 2300    	strex	r3, r2, [r1]
 8015f4a: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8015f4c: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8015f4e: 2b00         	cmp	r3, #0x0
 8015f50: d1e5         	bne	0x8015f1e <LL_USART_SetTransferDirection+0xa> @ imm = #-0x36
; }
 8015f52: bf00         	nop
 8015f54: bf00         	nop
 8015f56: 3724         	adds	r7, #0x24
 8015f58: 46bd         	mov	sp, r7
 8015f5a: bc80         	pop	{r7}
 8015f5c: 4770         	bx	lr

08015f5e <LL_USART_SetParity>:
; {
 8015f5e: b480         	push	{r7}
 8015f60: b083         	sub	sp, #0xc
 8015f62: af00         	add	r7, sp, #0x0
 8015f64: 6078         	str	r0, [r7, #0x4]
 8015f66: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
 8015f68: 687b         	ldr	r3, [r7, #0x4]
 8015f6a: 68db         	ldr	r3, [r3, #0xc]
 8015f6c: f423 62c0    	bic	r2, r3, #0x600
 8015f70: 683b         	ldr	r3, [r7]
 8015f72: 431a         	orrs	r2, r3
 8015f74: 687b         	ldr	r3, [r7, #0x4]
 8015f76: 60da         	str	r2, [r3, #0xc]
; }
 8015f78: bf00         	nop
 8015f7a: 370c         	adds	r7, #0xc
 8015f7c: 46bd         	mov	sp, r7
 8015f7e: bc80         	pop	{r7}
 8015f80: 4770         	bx	lr

08015f82 <LL_USART_GetParity>:
; {
 8015f82: b480         	push	{r7}
 8015f84: b083         	sub	sp, #0xc
 8015f86: af00         	add	r7, sp, #0x0
 8015f88: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
 8015f8a: 687b         	ldr	r3, [r7, #0x4]
 8015f8c: 68db         	ldr	r3, [r3, #0xc]
 8015f8e: f403 63c0    	and	r3, r3, #0x600
; }
 8015f92: 4618         	mov	r0, r3
 8015f94: 370c         	adds	r7, #0xc
 8015f96: 46bd         	mov	sp, r7
 8015f98: bc80         	pop	{r7}
 8015f9a: 4770         	bx	lr

08015f9c <LL_USART_SetDataWidth>:
; {
 8015f9c: b480         	push	{r7}
 8015f9e: b083         	sub	sp, #0xc
 8015fa0: af00         	add	r7, sp, #0x0
 8015fa2: 6078         	str	r0, [r7, #0x4]
 8015fa4: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
 8015fa6: 687b         	ldr	r3, [r7, #0x4]
 8015fa8: 68db         	ldr	r3, [r3, #0xc]
 8015faa: f423 5280    	bic	r2, r3, #0x1000
 8015fae: 683b         	ldr	r3, [r7]
 8015fb0: 431a         	orrs	r2, r3
 8015fb2: 687b         	ldr	r3, [r7, #0x4]
 8015fb4: 60da         	str	r2, [r3, #0xc]
; }
 8015fb6: bf00         	nop
 8015fb8: 370c         	adds	r7, #0xc
 8015fba: 46bd         	mov	sp, r7
 8015fbc: bc80         	pop	{r7}
 8015fbe: 4770         	bx	lr

08015fc0 <LL_USART_GetDataWidth>:
; {
 8015fc0: b480         	push	{r7}
 8015fc2: b083         	sub	sp, #0xc
 8015fc4: af00         	add	r7, sp, #0x0
 8015fc6: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
 8015fc8: 687b         	ldr	r3, [r7, #0x4]
 8015fca: 68db         	ldr	r3, [r3, #0xc]
 8015fcc: f403 5380    	and	r3, r3, #0x1000
; }
 8015fd0: 4618         	mov	r0, r3
 8015fd2: 370c         	adds	r7, #0xc
 8015fd4: 46bd         	mov	sp, r7
 8015fd6: bc80         	pop	{r7}
 8015fd8: 4770         	bx	lr

08015fda <LL_USART_SetOverSampling>:
; {
 8015fda: b480         	push	{r7}
 8015fdc: b083         	sub	sp, #0xc
 8015fde: af00         	add	r7, sp, #0x0
 8015fe0: 6078         	str	r0, [r7, #0x4]
 8015fe2: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_OVER8, OverSampling);
 8015fe4: 687b         	ldr	r3, [r7, #0x4]
 8015fe6: 68db         	ldr	r3, [r3, #0xc]
 8015fe8: f423 4200    	bic	r2, r3, #0x8000
 8015fec: 683b         	ldr	r3, [r7]
 8015fee: 431a         	orrs	r2, r3
 8015ff0: 687b         	ldr	r3, [r7, #0x4]
 8015ff2: 60da         	str	r2, [r3, #0xc]
; }
 8015ff4: bf00         	nop
 8015ff6: 370c         	adds	r7, #0xc
 8015ff8: 46bd         	mov	sp, r7
 8015ffa: bc80         	pop	{r7}
 8015ffc: 4770         	bx	lr

08015ffe <LL_USART_SetStopBitsLength>:
; {
 8015ffe: b480         	push	{r7}
 8016000: b083         	sub	sp, #0xc
 8016002: af00         	add	r7, sp, #0x0
 8016004: 6078         	str	r0, [r7, #0x4]
 8016006: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8016008: 687b         	ldr	r3, [r7, #0x4]
 801600a: 691b         	ldr	r3, [r3, #0x10]
 801600c: f423 5240    	bic	r2, r3, #0x3000
 8016010: 683b         	ldr	r3, [r7]
 8016012: 431a         	orrs	r2, r3
 8016014: 687b         	ldr	r3, [r7, #0x4]
 8016016: 611a         	str	r2, [r3, #0x10]
; }
 8016018: bf00         	nop
 801601a: 370c         	adds	r7, #0xc
 801601c: 46bd         	mov	sp, r7
 801601e: bc80         	pop	{r7}
 8016020: 4770         	bx	lr

08016022 <LL_USART_GetStopBitsLength>:
; {
 8016022: b480         	push	{r7}
 8016024: b083         	sub	sp, #0xc
 8016026: af00         	add	r7, sp, #0x0
 8016028: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
 801602a: 687b         	ldr	r3, [r7, #0x4]
 801602c: 691b         	ldr	r3, [r3, #0x10]
 801602e: f403 5340    	and	r3, r3, #0x3000
; }
 8016032: 4618         	mov	r0, r3
 8016034: 370c         	adds	r7, #0xc
 8016036: 46bd         	mov	sp, r7
 8016038: bc80         	pop	{r7}
 801603a: 4770         	bx	lr

0801603c <LL_USART_ConfigCharacter>:
; {
 801603c: b480         	push	{r7}
 801603e: b085         	sub	sp, #0x14
 8016040: af00         	add	r7, sp, #0x0
 8016042: 60f8         	str	r0, [r7, #0xc]
 8016044: 60b9         	str	r1, [r7, #0x8]
 8016046: 607a         	str	r2, [r7, #0x4]
 8016048: 603b         	str	r3, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
 801604a: 68fb         	ldr	r3, [r7, #0xc]
 801604c: 68db         	ldr	r3, [r3, #0xc]
 801604e: f423 52b0    	bic	r2, r3, #0x1600
 8016052: 6879         	ldr	r1, [r7, #0x4]
 8016054: 68bb         	ldr	r3, [r7, #0x8]
 8016056: 430b         	orrs	r3, r1
 8016058: 431a         	orrs	r2, r3
 801605a: 68fb         	ldr	r3, [r7, #0xc]
 801605c: 60da         	str	r2, [r3, #0xc]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 801605e: 68fb         	ldr	r3, [r7, #0xc]
 8016060: 691b         	ldr	r3, [r3, #0x10]
 8016062: f423 5240    	bic	r2, r3, #0x3000
 8016066: 683b         	ldr	r3, [r7]
 8016068: 431a         	orrs	r2, r3
 801606a: 68fb         	ldr	r3, [r7, #0xc]
 801606c: 611a         	str	r2, [r3, #0x10]
; }
 801606e: bf00         	nop
 8016070: 3714         	adds	r7, #0x14
 8016072: 46bd         	mov	sp, r7
 8016074: bc80         	pop	{r7}
 8016076: 4770         	bx	lr

08016078 <LL_USART_SetHWFlowCtrl>:
; {
 8016078: b480         	push	{r7}
 801607a: b083         	sub	sp, #0xc
 801607c: af00         	add	r7, sp, #0x0
 801607e: 6078         	str	r0, [r7, #0x4]
 8016080: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 8016082: 687b         	ldr	r3, [r7, #0x4]
 8016084: 695b         	ldr	r3, [r3, #0x14]
 8016086: f423 7240    	bic	r2, r3, #0x300
 801608a: 683b         	ldr	r3, [r7]
 801608c: 431a         	orrs	r2, r3
 801608e: 687b         	ldr	r3, [r7, #0x4]
 8016090: 615a         	str	r2, [r3, #0x14]
; }
 8016092: bf00         	nop
 8016094: 370c         	adds	r7, #0xc
 8016096: 46bd         	mov	sp, r7
 8016098: bc80         	pop	{r7}
 801609a: 4770         	bx	lr

0801609c <LL_USART_GetHWFlowCtrl>:
; {
 801609c: b480         	push	{r7}
 801609e: b083         	sub	sp, #0xc
 80160a0: af00         	add	r7, sp, #0x0
 80160a2: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
 80160a4: 687b         	ldr	r3, [r7, #0x4]
 80160a6: 695b         	ldr	r3, [r3, #0x14]
 80160a8: f403 7340    	and	r3, r3, #0x300
; }
 80160ac: 4618         	mov	r0, r3
 80160ae: 370c         	adds	r7, #0xc
 80160b0: 46bd         	mov	sp, r7
 80160b2: bc80         	pop	{r7}
 80160b4: 4770         	bx	lr

080160b6 <LL_USART_EnableHalfDuplex>:
; {
 80160b6: b480         	push	{r7}
 80160b8: b083         	sub	sp, #0xc
 80160ba: af00         	add	r7, sp, #0x0
 80160bc: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
 80160be: 687b         	ldr	r3, [r7, #0x4]
 80160c0: 695b         	ldr	r3, [r3, #0x14]
 80160c2: f043 0208    	orr	r2, r3, #0x8
 80160c6: 687b         	ldr	r3, [r7, #0x4]
 80160c8: 615a         	str	r2, [r3, #0x14]
; }
 80160ca: bf00         	nop
 80160cc: 370c         	adds	r7, #0xc
 80160ce: 46bd         	mov	sp, r7
 80160d0: bc80         	pop	{r7}
 80160d2: 4770         	bx	lr

080160d4 <LL_USART_IsActiveFlag_PE>:
; {
 80160d4: b480         	push	{r7}
 80160d6: b083         	sub	sp, #0xc
 80160d8: af00         	add	r7, sp, #0x0
 80160da: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_PE) == (USART_SR_PE));
 80160dc: 687b         	ldr	r3, [r7, #0x4]
 80160de: 681b         	ldr	r3, [r3]
 80160e0: f003 0301    	and	r3, r3, #0x1
 80160e4: 2b01         	cmp	r3, #0x1
 80160e6: bf0c         	ite	eq
 80160e8: 2301         	moveq	r3, #0x1
 80160ea: 2300         	movne	r3, #0x0
 80160ec: b2db         	uxtb	r3, r3
; }
 80160ee: 4618         	mov	r0, r3
 80160f0: 370c         	adds	r7, #0xc
 80160f2: 46bd         	mov	sp, r7
 80160f4: bc80         	pop	{r7}
 80160f6: 4770         	bx	lr

080160f8 <LL_USART_IsActiveFlag_FE>:
; {
 80160f8: b480         	push	{r7}
 80160fa: b083         	sub	sp, #0xc
 80160fc: af00         	add	r7, sp, #0x0
 80160fe: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_FE) == (USART_SR_FE));
 8016100: 687b         	ldr	r3, [r7, #0x4]
 8016102: 681b         	ldr	r3, [r3]
 8016104: f003 0302    	and	r3, r3, #0x2
 8016108: 2b02         	cmp	r3, #0x2
 801610a: bf0c         	ite	eq
 801610c: 2301         	moveq	r3, #0x1
 801610e: 2300         	movne	r3, #0x0
 8016110: b2db         	uxtb	r3, r3
; }
 8016112: 4618         	mov	r0, r3
 8016114: 370c         	adds	r7, #0xc
 8016116: 46bd         	mov	sp, r7
 8016118: bc80         	pop	{r7}
 801611a: 4770         	bx	lr

0801611c <LL_USART_IsActiveFlag_NE>:
; {
 801611c: b480         	push	{r7}
 801611e: b083         	sub	sp, #0xc
 8016120: af00         	add	r7, sp, #0x0
 8016122: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_NE) == (USART_SR_NE));
 8016124: 687b         	ldr	r3, [r7, #0x4]
 8016126: 681b         	ldr	r3, [r3]
 8016128: f003 0304    	and	r3, r3, #0x4
 801612c: 2b04         	cmp	r3, #0x4
 801612e: bf0c         	ite	eq
 8016130: 2301         	moveq	r3, #0x1
 8016132: 2300         	movne	r3, #0x0
 8016134: b2db         	uxtb	r3, r3
; }
 8016136: 4618         	mov	r0, r3
 8016138: 370c         	adds	r7, #0xc
 801613a: 46bd         	mov	sp, r7
 801613c: bc80         	pop	{r7}
 801613e: 4770         	bx	lr

08016140 <LL_USART_IsActiveFlag_ORE>:
; {
 8016140: b480         	push	{r7}
 8016142: b083         	sub	sp, #0xc
 8016144: af00         	add	r7, sp, #0x0
 8016146: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_ORE) == (USART_SR_ORE));
 8016148: 687b         	ldr	r3, [r7, #0x4]
 801614a: 681b         	ldr	r3, [r3]
 801614c: f003 0308    	and	r3, r3, #0x8
 8016150: 2b08         	cmp	r3, #0x8
 8016152: bf0c         	ite	eq
 8016154: 2301         	moveq	r3, #0x1
 8016156: 2300         	movne	r3, #0x0
 8016158: b2db         	uxtb	r3, r3
; }
 801615a: 4618         	mov	r0, r3
 801615c: 370c         	adds	r7, #0xc
 801615e: 46bd         	mov	sp, r7
 8016160: bc80         	pop	{r7}
 8016162: 4770         	bx	lr

08016164 <LL_USART_IsActiveFlag_IDLE>:
; {
 8016164: b480         	push	{r7}
 8016166: b083         	sub	sp, #0xc
 8016168: af00         	add	r7, sp, #0x0
 801616a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_IDLE) == (USART_SR_IDLE));
 801616c: 687b         	ldr	r3, [r7, #0x4]
 801616e: 681b         	ldr	r3, [r3]
 8016170: f003 0310    	and	r3, r3, #0x10
 8016174: 2b10         	cmp	r3, #0x10
 8016176: bf0c         	ite	eq
 8016178: 2301         	moveq	r3, #0x1
 801617a: 2300         	movne	r3, #0x0
 801617c: b2db         	uxtb	r3, r3
; }
 801617e: 4618         	mov	r0, r3
 8016180: 370c         	adds	r7, #0xc
 8016182: 46bd         	mov	sp, r7
 8016184: bc80         	pop	{r7}
 8016186: 4770         	bx	lr

08016188 <LL_USART_IsActiveFlag_RXNE>:
; {
 8016188: b480         	push	{r7}
 801618a: b083         	sub	sp, #0xc
 801618c: af00         	add	r7, sp, #0x0
 801618e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
 8016190: 687b         	ldr	r3, [r7, #0x4]
 8016192: 681b         	ldr	r3, [r3]
 8016194: f003 0320    	and	r3, r3, #0x20
 8016198: 2b20         	cmp	r3, #0x20
 801619a: bf0c         	ite	eq
 801619c: 2301         	moveq	r3, #0x1
 801619e: 2300         	movne	r3, #0x0
 80161a0: b2db         	uxtb	r3, r3
; }
 80161a2: 4618         	mov	r0, r3
 80161a4: 370c         	adds	r7, #0xc
 80161a6: 46bd         	mov	sp, r7
 80161a8: bc80         	pop	{r7}
 80161aa: 4770         	bx	lr

080161ac <LL_USART_IsActiveFlag_TC>:
; {
 80161ac: b480         	push	{r7}
 80161ae: b083         	sub	sp, #0xc
 80161b0: af00         	add	r7, sp, #0x0
 80161b2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_TC) == (USART_SR_TC));
 80161b4: 687b         	ldr	r3, [r7, #0x4]
 80161b6: 681b         	ldr	r3, [r3]
 80161b8: f003 0340    	and	r3, r3, #0x40
 80161bc: 2b40         	cmp	r3, #0x40
 80161be: bf0c         	ite	eq
 80161c0: 2301         	moveq	r3, #0x1
 80161c2: 2300         	movne	r3, #0x0
 80161c4: b2db         	uxtb	r3, r3
; }
 80161c6: 4618         	mov	r0, r3
 80161c8: 370c         	adds	r7, #0xc
 80161ca: 46bd         	mov	sp, r7
 80161cc: bc80         	pop	{r7}
 80161ce: 4770         	bx	lr

080161d0 <LL_USART_IsActiveFlag_TXE>:
; {
 80161d0: b480         	push	{r7}
 80161d2: b083         	sub	sp, #0xc
 80161d4: af00         	add	r7, sp, #0x0
 80161d6: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_TXE) == (USART_SR_TXE));
 80161d8: 687b         	ldr	r3, [r7, #0x4]
 80161da: 681b         	ldr	r3, [r3]
 80161dc: f003 0380    	and	r3, r3, #0x80
 80161e0: 2b80         	cmp	r3, #0x80
 80161e2: bf0c         	ite	eq
 80161e4: 2301         	moveq	r3, #0x1
 80161e6: 2300         	movne	r3, #0x0
 80161e8: b2db         	uxtb	r3, r3
; }
 80161ea: 4618         	mov	r0, r3
 80161ec: 370c         	adds	r7, #0xc
 80161ee: 46bd         	mov	sp, r7
 80161f0: bc80         	pop	{r7}
 80161f2: 4770         	bx	lr

080161f4 <LL_USART_IsActiveFlag_LBD>:
; {
 80161f4: b480         	push	{r7}
 80161f6: b083         	sub	sp, #0xc
 80161f8: af00         	add	r7, sp, #0x0
 80161fa: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_LBD) == (USART_SR_LBD));
 80161fc: 687b         	ldr	r3, [r7, #0x4]
 80161fe: 681b         	ldr	r3, [r3]
 8016200: f403 7380    	and	r3, r3, #0x100
 8016204: f5b3 7f80    	cmp.w	r3, #0x100
 8016208: bf0c         	ite	eq
 801620a: 2301         	moveq	r3, #0x1
 801620c: 2300         	movne	r3, #0x0
 801620e: b2db         	uxtb	r3, r3
; }
 8016210: 4618         	mov	r0, r3
 8016212: 370c         	adds	r7, #0xc
 8016214: 46bd         	mov	sp, r7
 8016216: bc80         	pop	{r7}
 8016218: 4770         	bx	lr

0801621a <LL_USART_ClearFlag_PE>:
; {
 801621a: b480         	push	{r7}
 801621c: b085         	sub	sp, #0x14
 801621e: af00         	add	r7, sp, #0x0
 8016220: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 8016222: 687b         	ldr	r3, [r7, #0x4]
 8016224: 681b         	ldr	r3, [r3]
 8016226: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8016228: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 801622a: 687b         	ldr	r3, [r7, #0x4]
 801622c: 685b         	ldr	r3, [r3, #0x4]
 801622e: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8016230: 68fb         	ldr	r3, [r7, #0xc]
; }
 8016232: bf00         	nop
 8016234: 3714         	adds	r7, #0x14
 8016236: 46bd         	mov	sp, r7
 8016238: bc80         	pop	{r7}
 801623a: 4770         	bx	lr

0801623c <LL_USART_ClearFlag_FE>:
; {
 801623c: b480         	push	{r7}
 801623e: b085         	sub	sp, #0x14
 8016240: af00         	add	r7, sp, #0x0
 8016242: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 8016244: 687b         	ldr	r3, [r7, #0x4]
 8016246: 681b         	ldr	r3, [r3]
 8016248: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801624a: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 801624c: 687b         	ldr	r3, [r7, #0x4]
 801624e: 685b         	ldr	r3, [r3, #0x4]
 8016250: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8016252: 68fb         	ldr	r3, [r7, #0xc]
; }
 8016254: bf00         	nop
 8016256: 3714         	adds	r7, #0x14
 8016258: 46bd         	mov	sp, r7
 801625a: bc80         	pop	{r7}
 801625c: 4770         	bx	lr

0801625e <LL_USART_ClearFlag_NE>:
; {
 801625e: b480         	push	{r7}
 8016260: b085         	sub	sp, #0x14
 8016262: af00         	add	r7, sp, #0x0
 8016264: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 8016266: 687b         	ldr	r3, [r7, #0x4]
 8016268: 681b         	ldr	r3, [r3]
 801626a: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801626c: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 801626e: 687b         	ldr	r3, [r7, #0x4]
 8016270: 685b         	ldr	r3, [r3, #0x4]
 8016272: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8016274: 68fb         	ldr	r3, [r7, #0xc]
; }
 8016276: bf00         	nop
 8016278: 3714         	adds	r7, #0x14
 801627a: 46bd         	mov	sp, r7
 801627c: bc80         	pop	{r7}
 801627e: 4770         	bx	lr

08016280 <LL_USART_ClearFlag_ORE>:
; {
 8016280: b480         	push	{r7}
 8016282: b085         	sub	sp, #0x14
 8016284: af00         	add	r7, sp, #0x0
 8016286: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 8016288: 687b         	ldr	r3, [r7, #0x4]
 801628a: 681b         	ldr	r3, [r3]
 801628c: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801628e: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 8016290: 687b         	ldr	r3, [r7, #0x4]
 8016292: 685b         	ldr	r3, [r3, #0x4]
 8016294: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8016296: 68fb         	ldr	r3, [r7, #0xc]
; }
 8016298: bf00         	nop
 801629a: 3714         	adds	r7, #0x14
 801629c: 46bd         	mov	sp, r7
 801629e: bc80         	pop	{r7}
 80162a0: 4770         	bx	lr

080162a2 <LL_USART_ClearFlag_IDLE>:
; {
 80162a2: b480         	push	{r7}
 80162a4: b085         	sub	sp, #0x14
 80162a6: af00         	add	r7, sp, #0x0
 80162a8: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 80162aa: 687b         	ldr	r3, [r7, #0x4]
 80162ac: 681b         	ldr	r3, [r3]
 80162ae: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80162b0: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 80162b2: 687b         	ldr	r3, [r7, #0x4]
 80162b4: 685b         	ldr	r3, [r3, #0x4]
 80162b6: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80162b8: 68fb         	ldr	r3, [r7, #0xc]
; }
 80162ba: bf00         	nop
 80162bc: 3714         	adds	r7, #0x14
 80162be: 46bd         	mov	sp, r7
 80162c0: bc80         	pop	{r7}
 80162c2: 4770         	bx	lr

080162c4 <LL_USART_ClearFlag_TC>:
; {
 80162c4: b480         	push	{r7}
 80162c6: b083         	sub	sp, #0xc
 80162c8: af00         	add	r7, sp, #0x0
 80162ca: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_TC));
 80162cc: 687b         	ldr	r3, [r7, #0x4]
 80162ce: f06f 0240    	mvn	r2, #0x40
 80162d2: 601a         	str	r2, [r3]
; }
 80162d4: bf00         	nop
 80162d6: 370c         	adds	r7, #0xc
 80162d8: 46bd         	mov	sp, r7
 80162da: bc80         	pop	{r7}
 80162dc: 4770         	bx	lr

080162de <LL_USART_ClearFlag_RXNE>:
; {
 80162de: b480         	push	{r7}
 80162e0: b083         	sub	sp, #0xc
 80162e2: af00         	add	r7, sp, #0x0
 80162e4: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_RXNE));
 80162e6: 687b         	ldr	r3, [r7, #0x4]
 80162e8: f06f 0220    	mvn	r2, #0x20
 80162ec: 601a         	str	r2, [r3]
; }
 80162ee: bf00         	nop
 80162f0: 370c         	adds	r7, #0xc
 80162f2: 46bd         	mov	sp, r7
 80162f4: bc80         	pop	{r7}
 80162f6: 4770         	bx	lr

080162f8 <LL_USART_ClearFlag_LBD>:
; {
 80162f8: b480         	push	{r7}
 80162fa: b083         	sub	sp, #0xc
 80162fc: af00         	add	r7, sp, #0x0
 80162fe: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_LBD));
 8016300: 687b         	ldr	r3, [r7, #0x4]
 8016302: f46f 7280    	mvn	r2, #0x100
 8016306: 601a         	str	r2, [r3]
; }
 8016308: bf00         	nop
 801630a: 370c         	adds	r7, #0xc
 801630c: 46bd         	mov	sp, r7
 801630e: bc80         	pop	{r7}
 8016310: 4770         	bx	lr

08016312 <LL_USART_EnableIT_IDLE>:
; {
 8016312: b480         	push	{r7}
 8016314: b089         	sub	sp, #0x24
 8016316: af00         	add	r7, sp, #0x0
 8016318: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 801631a: 687b         	ldr	r3, [r7, #0x4]
 801631c: 330c         	adds	r3, #0xc
 801631e: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8016320: 68fb         	ldr	r3, [r7, #0xc]
 8016322: e853 3f00    	ldrex	r3, [r3]
 8016326: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8016328: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 801632a: f043 0310    	orr	r3, r3, #0x10
 801632e: 61fb         	str	r3, [r7, #0x1c]
 8016330: 687b         	ldr	r3, [r7, #0x4]
 8016332: 330c         	adds	r3, #0xc
 8016334: 69fa         	ldr	r2, [r7, #0x1c]
 8016336: 61ba         	str	r2, [r7, #0x18]
 8016338: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801633a: 6979         	ldr	r1, [r7, #0x14]
 801633c: 69ba         	ldr	r2, [r7, #0x18]
 801633e: e841 2300    	strex	r3, r2, [r1]
 8016342: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8016344: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8016346: 2b00         	cmp	r3, #0x0
 8016348: d1e7         	bne	0x801631a <LL_USART_EnableIT_IDLE+0x8> @ imm = #-0x32
; }
 801634a: bf00         	nop
 801634c: bf00         	nop
 801634e: 3724         	adds	r7, #0x24
 8016350: 46bd         	mov	sp, r7
 8016352: bc80         	pop	{r7}
 8016354: 4770         	bx	lr

08016356 <LL_USART_EnableIT_RXNE>:
; {
 8016356: b480         	push	{r7}
 8016358: b089         	sub	sp, #0x24
 801635a: af00         	add	r7, sp, #0x0
 801635c: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 801635e: 687b         	ldr	r3, [r7, #0x4]
 8016360: 330c         	adds	r3, #0xc
 8016362: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8016364: 68fb         	ldr	r3, [r7, #0xc]
 8016366: e853 3f00    	ldrex	r3, [r3]
 801636a: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801636c: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 801636e: f043 0320    	orr	r3, r3, #0x20
 8016372: 61fb         	str	r3, [r7, #0x1c]
 8016374: 687b         	ldr	r3, [r7, #0x4]
 8016376: 330c         	adds	r3, #0xc
 8016378: 69fa         	ldr	r2, [r7, #0x1c]
 801637a: 61ba         	str	r2, [r7, #0x18]
 801637c: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801637e: 6979         	ldr	r1, [r7, #0x14]
 8016380: 69ba         	ldr	r2, [r7, #0x18]
 8016382: e841 2300    	strex	r3, r2, [r1]
 8016386: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8016388: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 801638a: 2b00         	cmp	r3, #0x0
 801638c: d1e7         	bne	0x801635e <LL_USART_EnableIT_RXNE+0x8> @ imm = #-0x32
; }
 801638e: bf00         	nop
 8016390: bf00         	nop
 8016392: 3724         	adds	r7, #0x24
 8016394: 46bd         	mov	sp, r7
 8016396: bc80         	pop	{r7}
 8016398: 4770         	bx	lr

0801639a <LL_USART_EnableIT_TC>:
; {
 801639a: b480         	push	{r7}
 801639c: b089         	sub	sp, #0x24
 801639e: af00         	add	r7, sp, #0x0
 80163a0: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 80163a2: 687b         	ldr	r3, [r7, #0x4]
 80163a4: 330c         	adds	r3, #0xc
 80163a6: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80163a8: 68fb         	ldr	r3, [r7, #0xc]
 80163aa: e853 3f00    	ldrex	r3, [r3]
 80163ae: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80163b0: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 80163b2: f043 0340    	orr	r3, r3, #0x40
 80163b6: 61fb         	str	r3, [r7, #0x1c]
 80163b8: 687b         	ldr	r3, [r7, #0x4]
 80163ba: 330c         	adds	r3, #0xc
 80163bc: 69fa         	ldr	r2, [r7, #0x1c]
 80163be: 61ba         	str	r2, [r7, #0x18]
 80163c0: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80163c2: 6979         	ldr	r1, [r7, #0x14]
 80163c4: 69ba         	ldr	r2, [r7, #0x18]
 80163c6: e841 2300    	strex	r3, r2, [r1]
 80163ca: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80163cc: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 80163ce: 2b00         	cmp	r3, #0x0
 80163d0: d1e7         	bne	0x80163a2 <LL_USART_EnableIT_TC+0x8> @ imm = #-0x32
; }
 80163d2: bf00         	nop
 80163d4: bf00         	nop
 80163d6: 3724         	adds	r7, #0x24
 80163d8: 46bd         	mov	sp, r7
 80163da: bc80         	pop	{r7}
 80163dc: 4770         	bx	lr

080163de <LL_USART_EnableIT_PE>:
; {
 80163de: b480         	push	{r7}
 80163e0: b089         	sub	sp, #0x24
 80163e2: af00         	add	r7, sp, #0x0
 80163e4: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 80163e6: 687b         	ldr	r3, [r7, #0x4]
 80163e8: 330c         	adds	r3, #0xc
 80163ea: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80163ec: 68fb         	ldr	r3, [r7, #0xc]
 80163ee: e853 3f00    	ldrex	r3, [r3]
 80163f2: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80163f4: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 80163f6: f443 7380    	orr	r3, r3, #0x100
 80163fa: 61fb         	str	r3, [r7, #0x1c]
 80163fc: 687b         	ldr	r3, [r7, #0x4]
 80163fe: 330c         	adds	r3, #0xc
 8016400: 69fa         	ldr	r2, [r7, #0x1c]
 8016402: 61ba         	str	r2, [r7, #0x18]
 8016404: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8016406: 6979         	ldr	r1, [r7, #0x14]
 8016408: 69ba         	ldr	r2, [r7, #0x18]
 801640a: e841 2300    	strex	r3, r2, [r1]
 801640e: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8016410: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 8016412: 2b00         	cmp	r3, #0x0
 8016414: d1e7         	bne	0x80163e6 <LL_USART_EnableIT_PE+0x8> @ imm = #-0x32
; }
 8016416: bf00         	nop
 8016418: bf00         	nop
 801641a: 3724         	adds	r7, #0x24
 801641c: 46bd         	mov	sp, r7
 801641e: bc80         	pop	{r7}
 8016420: 4770         	bx	lr

08016422 <LL_USART_EnableIT_LBD>:
; {
 8016422: b480         	push	{r7}
 8016424: b083         	sub	sp, #0xc
 8016426: af00         	add	r7, sp, #0x0
 8016428: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR2, USART_CR2_LBDIE);
 801642a: 687b         	ldr	r3, [r7, #0x4]
 801642c: 691b         	ldr	r3, [r3, #0x10]
 801642e: f043 0240    	orr	r2, r3, #0x40
 8016432: 687b         	ldr	r3, [r7, #0x4]
 8016434: 611a         	str	r2, [r3, #0x10]
; }
 8016436: bf00         	nop
 8016438: 370c         	adds	r7, #0xc
 801643a: 46bd         	mov	sp, r7
 801643c: bc80         	pop	{r7}
 801643e: 4770         	bx	lr

08016440 <LL_USART_EnableIT_ERROR>:
; {
 8016440: b480         	push	{r7}
 8016442: b089         	sub	sp, #0x24
 8016444: af00         	add	r7, sp, #0x0
 8016446: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8016448: 687b         	ldr	r3, [r7, #0x4]
 801644a: 3314         	adds	r3, #0x14
 801644c: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801644e: 68fb         	ldr	r3, [r7, #0xc]
 8016450: e853 3f00    	ldrex	r3, [r3]
 8016454: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8016456: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8016458: f043 0301    	orr	r3, r3, #0x1
 801645c: 61fb         	str	r3, [r7, #0x1c]
 801645e: 687b         	ldr	r3, [r7, #0x4]
 8016460: 3314         	adds	r3, #0x14
 8016462: 69fa         	ldr	r2, [r7, #0x1c]
 8016464: 61ba         	str	r2, [r7, #0x18]
 8016466: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8016468: 6979         	ldr	r1, [r7, #0x14]
 801646a: 69ba         	ldr	r2, [r7, #0x18]
 801646c: e841 2300    	strex	r3, r2, [r1]
 8016470: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8016472: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8016474: 2b00         	cmp	r3, #0x0
 8016476: d1e7         	bne	0x8016448 <LL_USART_EnableIT_ERROR+0x8> @ imm = #-0x32
; }
 8016478: bf00         	nop
 801647a: bf00         	nop
 801647c: 3724         	adds	r7, #0x24
 801647e: 46bd         	mov	sp, r7
 8016480: bc80         	pop	{r7}
 8016482: 4770         	bx	lr

08016484 <LL_USART_DisableIT_IDLE>:
; {
 8016484: b480         	push	{r7}
 8016486: b089         	sub	sp, #0x24
 8016488: af00         	add	r7, sp, #0x0
 801648a: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 801648c: 687b         	ldr	r3, [r7, #0x4]
 801648e: 330c         	adds	r3, #0xc
 8016490: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8016492: 68fb         	ldr	r3, [r7, #0xc]
 8016494: e853 3f00    	ldrex	r3, [r3]
 8016498: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801649a: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 801649c: f023 0310    	bic	r3, r3, #0x10
 80164a0: 61fb         	str	r3, [r7, #0x1c]
 80164a2: 687b         	ldr	r3, [r7, #0x4]
 80164a4: 330c         	adds	r3, #0xc
 80164a6: 69fa         	ldr	r2, [r7, #0x1c]
 80164a8: 61ba         	str	r2, [r7, #0x18]
 80164aa: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80164ac: 6979         	ldr	r1, [r7, #0x14]
 80164ae: 69ba         	ldr	r2, [r7, #0x18]
 80164b0: e841 2300    	strex	r3, r2, [r1]
 80164b4: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80164b6: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 80164b8: 2b00         	cmp	r3, #0x0
 80164ba: d1e7         	bne	0x801648c <LL_USART_DisableIT_IDLE+0x8> @ imm = #-0x32
; }
 80164bc: bf00         	nop
 80164be: bf00         	nop
 80164c0: 3724         	adds	r7, #0x24
 80164c2: 46bd         	mov	sp, r7
 80164c4: bc80         	pop	{r7}
 80164c6: 4770         	bx	lr

080164c8 <LL_USART_DisableIT_RXNE>:
; {
 80164c8: b480         	push	{r7}
 80164ca: b089         	sub	sp, #0x24
 80164cc: af00         	add	r7, sp, #0x0
 80164ce: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 80164d0: 687b         	ldr	r3, [r7, #0x4]
 80164d2: 330c         	adds	r3, #0xc
 80164d4: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80164d6: 68fb         	ldr	r3, [r7, #0xc]
 80164d8: e853 3f00    	ldrex	r3, [r3]
 80164dc: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80164de: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 80164e0: f023 0320    	bic	r3, r3, #0x20
 80164e4: 61fb         	str	r3, [r7, #0x1c]
 80164e6: 687b         	ldr	r3, [r7, #0x4]
 80164e8: 330c         	adds	r3, #0xc
 80164ea: 69fa         	ldr	r2, [r7, #0x1c]
 80164ec: 61ba         	str	r2, [r7, #0x18]
 80164ee: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80164f0: 6979         	ldr	r1, [r7, #0x14]
 80164f2: 69ba         	ldr	r2, [r7, #0x18]
 80164f4: e841 2300    	strex	r3, r2, [r1]
 80164f8: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80164fa: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 80164fc: 2b00         	cmp	r3, #0x0
 80164fe: d1e7         	bne	0x80164d0 <LL_USART_DisableIT_RXNE+0x8> @ imm = #-0x32
; }
 8016500: bf00         	nop
 8016502: bf00         	nop
 8016504: 3724         	adds	r7, #0x24
 8016506: 46bd         	mov	sp, r7
 8016508: bc80         	pop	{r7}
 801650a: 4770         	bx	lr

0801650c <LL_USART_DisableIT_TC>:
; {
 801650c: b480         	push	{r7}
 801650e: b089         	sub	sp, #0x24
 8016510: af00         	add	r7, sp, #0x0
 8016512: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 8016514: 687b         	ldr	r3, [r7, #0x4]
 8016516: 330c         	adds	r3, #0xc
 8016518: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801651a: 68fb         	ldr	r3, [r7, #0xc]
 801651c: e853 3f00    	ldrex	r3, [r3]
 8016520: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8016522: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 8016524: f023 0340    	bic	r3, r3, #0x40
 8016528: 61fb         	str	r3, [r7, #0x1c]
 801652a: 687b         	ldr	r3, [r7, #0x4]
 801652c: 330c         	adds	r3, #0xc
 801652e: 69fa         	ldr	r2, [r7, #0x1c]
 8016530: 61ba         	str	r2, [r7, #0x18]
 8016532: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8016534: 6979         	ldr	r1, [r7, #0x14]
 8016536: 69ba         	ldr	r2, [r7, #0x18]
 8016538: e841 2300    	strex	r3, r2, [r1]
 801653c: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801653e: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 8016540: 2b00         	cmp	r3, #0x0
 8016542: d1e7         	bne	0x8016514 <LL_USART_DisableIT_TC+0x8> @ imm = #-0x32
; }
 8016544: bf00         	nop
 8016546: bf00         	nop
 8016548: 3724         	adds	r7, #0x24
 801654a: 46bd         	mov	sp, r7
 801654c: bc80         	pop	{r7}
 801654e: 4770         	bx	lr

08016550 <LL_USART_DisableIT_PE>:
; {
 8016550: b480         	push	{r7}
 8016552: b089         	sub	sp, #0x24
 8016554: af00         	add	r7, sp, #0x0
 8016556: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 8016558: 687b         	ldr	r3, [r7, #0x4]
 801655a: 330c         	adds	r3, #0xc
 801655c: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801655e: 68fb         	ldr	r3, [r7, #0xc]
 8016560: e853 3f00    	ldrex	r3, [r3]
 8016564: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8016566: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 8016568: f423 7380    	bic	r3, r3, #0x100
 801656c: 61fb         	str	r3, [r7, #0x1c]
 801656e: 687b         	ldr	r3, [r7, #0x4]
 8016570: 330c         	adds	r3, #0xc
 8016572: 69fa         	ldr	r2, [r7, #0x1c]
 8016574: 61ba         	str	r2, [r7, #0x18]
 8016576: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8016578: 6979         	ldr	r1, [r7, #0x14]
 801657a: 69ba         	ldr	r2, [r7, #0x18]
 801657c: e841 2300    	strex	r3, r2, [r1]
 8016580: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8016582: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 8016584: 2b00         	cmp	r3, #0x0
 8016586: d1e7         	bne	0x8016558 <LL_USART_DisableIT_PE+0x8> @ imm = #-0x32
; }
 8016588: bf00         	nop
 801658a: bf00         	nop
 801658c: 3724         	adds	r7, #0x24
 801658e: 46bd         	mov	sp, r7
 8016590: bc80         	pop	{r7}
 8016592: 4770         	bx	lr

08016594 <LL_USART_DisableIT_LBD>:
; {
 8016594: b480         	push	{r7}
 8016596: b083         	sub	sp, #0xc
 8016598: af00         	add	r7, sp, #0x0
 801659a: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR2, USART_CR2_LBDIE);
 801659c: 687b         	ldr	r3, [r7, #0x4]
 801659e: 691b         	ldr	r3, [r3, #0x10]
 80165a0: f023 0240    	bic	r2, r3, #0x40
 80165a4: 687b         	ldr	r3, [r7, #0x4]
 80165a6: 611a         	str	r2, [r3, #0x10]
; }
 80165a8: bf00         	nop
 80165aa: 370c         	adds	r7, #0xc
 80165ac: 46bd         	mov	sp, r7
 80165ae: bc80         	pop	{r7}
 80165b0: 4770         	bx	lr

080165b2 <LL_USART_DisableIT_ERROR>:
; {
 80165b2: b480         	push	{r7}
 80165b4: b089         	sub	sp, #0x24
 80165b6: af00         	add	r7, sp, #0x0
 80165b8: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 80165ba: 687b         	ldr	r3, [r7, #0x4]
 80165bc: 3314         	adds	r3, #0x14
 80165be: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80165c0: 68fb         	ldr	r3, [r7, #0xc]
 80165c2: e853 3f00    	ldrex	r3, [r3]
 80165c6: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80165c8: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 80165ca: f023 0301    	bic	r3, r3, #0x1
 80165ce: 61fb         	str	r3, [r7, #0x1c]
 80165d0: 687b         	ldr	r3, [r7, #0x4]
 80165d2: 3314         	adds	r3, #0x14
 80165d4: 69fa         	ldr	r2, [r7, #0x1c]
 80165d6: 61ba         	str	r2, [r7, #0x18]
 80165d8: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80165da: 6979         	ldr	r1, [r7, #0x14]
 80165dc: 69ba         	ldr	r2, [r7, #0x18]
 80165de: e841 2300    	strex	r3, r2, [r1]
 80165e2: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80165e4: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 80165e6: 2b00         	cmp	r3, #0x0
 80165e8: d1e7         	bne	0x80165ba <LL_USART_DisableIT_ERROR+0x8> @ imm = #-0x32
; }
 80165ea: bf00         	nop
 80165ec: bf00         	nop
 80165ee: 3724         	adds	r7, #0x24
 80165f0: 46bd         	mov	sp, r7
 80165f2: bc80         	pop	{r7}
 80165f4: 4770         	bx	lr

080165f6 <LL_USART_IsEnabledIT_IDLE>:
; {
 80165f6: b480         	push	{r7}
 80165f8: b083         	sub	sp, #0xc
 80165fa: af00         	add	r7, sp, #0x0
 80165fc: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE));
 80165fe: 687b         	ldr	r3, [r7, #0x4]
 8016600: 68db         	ldr	r3, [r3, #0xc]
 8016602: f003 0310    	and	r3, r3, #0x10
 8016606: 2b10         	cmp	r3, #0x10
 8016608: bf0c         	ite	eq
 801660a: 2301         	moveq	r3, #0x1
 801660c: 2300         	movne	r3, #0x0
 801660e: b2db         	uxtb	r3, r3
; }
 8016610: 4618         	mov	r0, r3
 8016612: 370c         	adds	r7, #0xc
 8016614: 46bd         	mov	sp, r7
 8016616: bc80         	pop	{r7}
 8016618: 4770         	bx	lr

0801661a <LL_USART_IsEnabledIT_RXNE>:
; {
 801661a: b480         	push	{r7}
 801661c: b083         	sub	sp, #0xc
 801661e: af00         	add	r7, sp, #0x0
 8016620: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE));
 8016622: 687b         	ldr	r3, [r7, #0x4]
 8016624: 68db         	ldr	r3, [r3, #0xc]
 8016626: f003 0320    	and	r3, r3, #0x20
 801662a: 2b20         	cmp	r3, #0x20
 801662c: bf0c         	ite	eq
 801662e: 2301         	moveq	r3, #0x1
 8016630: 2300         	movne	r3, #0x0
 8016632: b2db         	uxtb	r3, r3
; }
 8016634: 4618         	mov	r0, r3
 8016636: 370c         	adds	r7, #0xc
 8016638: 46bd         	mov	sp, r7
 801663a: bc80         	pop	{r7}
 801663c: 4770         	bx	lr

0801663e <LL_USART_IsEnabledIT_TC>:
; {
 801663e: b480         	push	{r7}
 8016640: b083         	sub	sp, #0xc
 8016642: af00         	add	r7, sp, #0x0
 8016644: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_TCIE) == (USART_CR1_TCIE));
 8016646: 687b         	ldr	r3, [r7, #0x4]
 8016648: 68db         	ldr	r3, [r3, #0xc]
 801664a: f003 0340    	and	r3, r3, #0x40
 801664e: 2b40         	cmp	r3, #0x40
 8016650: bf0c         	ite	eq
 8016652: 2301         	moveq	r3, #0x1
 8016654: 2300         	movne	r3, #0x0
 8016656: b2db         	uxtb	r3, r3
; }
 8016658: 4618         	mov	r0, r3
 801665a: 370c         	adds	r7, #0xc
 801665c: 46bd         	mov	sp, r7
 801665e: bc80         	pop	{r7}
 8016660: 4770         	bx	lr

08016662 <LL_USART_EnableDMAReq_RX>:
; {
 8016662: b480         	push	{r7}
 8016664: b089         	sub	sp, #0x24
 8016666: af00         	add	r7, sp, #0x0
 8016668: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 801666a: 687b         	ldr	r3, [r7, #0x4]
 801666c: 3314         	adds	r3, #0x14
 801666e: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8016670: 68fb         	ldr	r3, [r7, #0xc]
 8016672: e853 3f00    	ldrex	r3, [r3]
 8016676: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8016678: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 801667a: f043 0340    	orr	r3, r3, #0x40
 801667e: 61fb         	str	r3, [r7, #0x1c]
 8016680: 687b         	ldr	r3, [r7, #0x4]
 8016682: 3314         	adds	r3, #0x14
 8016684: 69fa         	ldr	r2, [r7, #0x1c]
 8016686: 61ba         	str	r2, [r7, #0x18]
 8016688: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801668a: 6979         	ldr	r1, [r7, #0x14]
 801668c: 69ba         	ldr	r2, [r7, #0x18]
 801668e: e841 2300    	strex	r3, r2, [r1]
 8016692: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8016694: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8016696: 2b00         	cmp	r3, #0x0
 8016698: d1e7         	bne	0x801666a <LL_USART_EnableDMAReq_RX+0x8> @ imm = #-0x32
; }
 801669a: bf00         	nop
 801669c: bf00         	nop
 801669e: 3724         	adds	r7, #0x24
 80166a0: 46bd         	mov	sp, r7
 80166a2: bc80         	pop	{r7}
 80166a4: 4770         	bx	lr

080166a6 <LL_USART_EnableDMAReq_TX>:
; {
 80166a6: b480         	push	{r7}
 80166a8: b089         	sub	sp, #0x24
 80166aa: af00         	add	r7, sp, #0x0
 80166ac: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 80166ae: 687b         	ldr	r3, [r7, #0x4]
 80166b0: 3314         	adds	r3, #0x14
 80166b2: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80166b4: 68fb         	ldr	r3, [r7, #0xc]
 80166b6: e853 3f00    	ldrex	r3, [r3]
 80166ba: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80166bc: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 80166be: f043 0380    	orr	r3, r3, #0x80
 80166c2: 61fb         	str	r3, [r7, #0x1c]
 80166c4: 687b         	ldr	r3, [r7, #0x4]
 80166c6: 3314         	adds	r3, #0x14
 80166c8: 69fa         	ldr	r2, [r7, #0x1c]
 80166ca: 61ba         	str	r2, [r7, #0x18]
 80166cc: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80166ce: 6979         	ldr	r1, [r7, #0x14]
 80166d0: 69ba         	ldr	r2, [r7, #0x18]
 80166d2: e841 2300    	strex	r3, r2, [r1]
 80166d6: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80166d8: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 80166da: 2b00         	cmp	r3, #0x0
 80166dc: d1e7         	bne	0x80166ae <LL_USART_EnableDMAReq_TX+0x8> @ imm = #-0x32
; }
 80166de: bf00         	nop
 80166e0: bf00         	nop
 80166e2: 3724         	adds	r7, #0x24
 80166e4: 46bd         	mov	sp, r7
 80166e6: bc80         	pop	{r7}
 80166e8: 4770         	bx	lr

080166ea <LL_USART_DisableDMAReq_TX>:
; {
 80166ea: b480         	push	{r7}
 80166ec: b089         	sub	sp, #0x24
 80166ee: af00         	add	r7, sp, #0x0
 80166f0: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 80166f2: 687b         	ldr	r3, [r7, #0x4]
 80166f4: 3314         	adds	r3, #0x14
 80166f6: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80166f8: 68fb         	ldr	r3, [r7, #0xc]
 80166fa: e853 3f00    	ldrex	r3, [r3]
 80166fe: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8016700: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 8016702: f023 0380    	bic	r3, r3, #0x80
 8016706: 61fb         	str	r3, [r7, #0x1c]
 8016708: 687b         	ldr	r3, [r7, #0x4]
 801670a: 3314         	adds	r3, #0x14
 801670c: 69fa         	ldr	r2, [r7, #0x1c]
 801670e: 61ba         	str	r2, [r7, #0x18]
 8016710: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8016712: 6979         	ldr	r1, [r7, #0x14]
 8016714: 69ba         	ldr	r2, [r7, #0x18]
 8016716: e841 2300    	strex	r3, r2, [r1]
 801671a: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801671c: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 801671e: 2b00         	cmp	r3, #0x0
 8016720: d1e7         	bne	0x80166f2 <LL_USART_DisableDMAReq_TX+0x8> @ imm = #-0x32
; }
 8016722: bf00         	nop
 8016724: bf00         	nop
 8016726: 3724         	adds	r7, #0x24
 8016728: 46bd         	mov	sp, r7
 801672a: bc80         	pop	{r7}
 801672c: 4770         	bx	lr

0801672e <LL_USART_DMA_GetRegAddr>:
; {
 801672e: b480         	push	{r7}
 8016730: b083         	sub	sp, #0xc
 8016732: af00         	add	r7, sp, #0x0
 8016734: 6078         	str	r0, [r7, #0x4]
;   return ((uint32_t) &(USARTx->DR));
 8016736: 687b         	ldr	r3, [r7, #0x4]
 8016738: 3304         	adds	r3, #0x4
; }
 801673a: 4618         	mov	r0, r3
 801673c: 370c         	adds	r7, #0xc
 801673e: 46bd         	mov	sp, r7
 8016740: bc80         	pop	{r7}
 8016742: 4770         	bx	lr

08016744 <LL_USART_ReceiveData8>:
; {
 8016744: b480         	push	{r7}
 8016746: b083         	sub	sp, #0xc
 8016748: af00         	add	r7, sp, #0x0
 801674a: 6078         	str	r0, [r7, #0x4]
;   return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
 801674c: 687b         	ldr	r3, [r7, #0x4]
 801674e: 685b         	ldr	r3, [r3, #0x4]
 8016750: b2db         	uxtb	r3, r3
; }
 8016752: 4618         	mov	r0, r3
 8016754: 370c         	adds	r7, #0xc
 8016756: 46bd         	mov	sp, r7
 8016758: bc80         	pop	{r7}
 801675a: 4770         	bx	lr

0801675c <LL_USART_TransmitData8>:
; {
 801675c: b480         	push	{r7}
 801675e: b083         	sub	sp, #0xc
 8016760: af00         	add	r7, sp, #0x0
 8016762: 6078         	str	r0, [r7, #0x4]
 8016764: 460b         	mov	r3, r1
 8016766: 70fb         	strb	r3, [r7, #0x3]
;   USARTx->DR = Value;
 8016768: 78fa         	ldrb	r2, [r7, #0x3]
 801676a: 687b         	ldr	r3, [r7, #0x4]
 801676c: 605a         	str	r2, [r3, #0x4]
; }
 801676e: bf00         	nop
 8016770: 370c         	adds	r7, #0xc
 8016772: 46bd         	mov	sp, r7
 8016774: bc80         	pop	{r7}
 8016776: 4770         	bx	lr

08016778 <z_log_msg_runtime_create>:
; {
 8016778: b580         	push	{r7, lr}
 801677a: b08a         	sub	sp, #0x28
 801677c: af04         	add	r7, sp, #0x10
 801677e: 60b9         	str	r1, [r7, #0x8]
 8016780: 607b         	str	r3, [r7, #0x4]
 8016782: 4603         	mov	r3, r0
 8016784: 73fb         	strb	r3, [r7, #0xf]
 8016786: 4613         	mov	r3, r2
 8016788: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801678a: f107 032c    	add.w	r3, r7, #0x2c
 801678e: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8016790: 7bba         	ldrb	r2, [r7, #0xe]
 8016792: 7bf8         	ldrb	r0, [r7, #0xf]
 8016794: 697b         	ldr	r3, [r7, #0x14]
 8016796: 9303         	str	r3, [sp, #0xc]
 8016798: 6abb         	ldr	r3, [r7, #0x28]
 801679a: 9302         	str	r3, [sp, #0x8]
 801679c: 6a7b         	ldr	r3, [r7, #0x24]
 801679e: 9301         	str	r3, [sp, #0x4]
 80167a0: 6a3b         	ldr	r3, [r7, #0x20]
 80167a2: 9300         	str	r3, [sp]
 80167a4: 687b         	ldr	r3, [r7, #0x4]
 80167a6: 68b9         	ldr	r1, [r7, #0x8]
 80167a8: f7eb fa60    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x14b40
; }
 80167ac: bf00         	nop
 80167ae: 3718         	adds	r7, #0x18
 80167b0: 46bd         	mov	sp, r7
 80167b2: bd80         	pop	{r7, pc}

080167b4 <uart_stm32_set_parity>:
; {
 80167b4: b580         	push	{r7, lr}
 80167b6: b084         	sub	sp, #0x10
 80167b8: af00         	add	r7, sp, #0x0
 80167ba: 6078         	str	r0, [r7, #0x4]
 80167bc: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 80167be: 687b         	ldr	r3, [r7, #0x4]
 80167c0: 685b         	ldr	r3, [r3, #0x4]
 80167c2: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetParity(config->usart, parity);
 80167c4: 68fb         	ldr	r3, [r7, #0xc]
 80167c6: 681b         	ldr	r3, [r3]
 80167c8: 6839         	ldr	r1, [r7]
 80167ca: 4618         	mov	r0, r3
 80167cc: f7ff fbc7    	bl	0x8015f5e <LL_USART_SetParity> @ imm = #-0x872
; }
 80167d0: bf00         	nop
 80167d2: 3710         	adds	r7, #0x10
 80167d4: 46bd         	mov	sp, r7
 80167d6: bd80         	pop	{r7, pc}

080167d8 <uart_stm32_get_parity>:
; {
 80167d8: b580         	push	{r7, lr}
 80167da: b084         	sub	sp, #0x10
 80167dc: af00         	add	r7, sp, #0x0
 80167de: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80167e0: 687b         	ldr	r3, [r7, #0x4]
 80167e2: 685b         	ldr	r3, [r3, #0x4]
 80167e4: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetParity(config->usart);
 80167e6: 68fb         	ldr	r3, [r7, #0xc]
 80167e8: 681b         	ldr	r3, [r3]
 80167ea: 4618         	mov	r0, r3
 80167ec: f7ff fbc9    	bl	0x8015f82 <LL_USART_GetParity> @ imm = #-0x86e
 80167f0: 4603         	mov	r3, r0
; }
 80167f2: 4618         	mov	r0, r3
 80167f4: 3710         	adds	r7, #0x10
 80167f6: 46bd         	mov	sp, r7
 80167f8: bd80         	pop	{r7, pc}

080167fa <uart_stm32_set_stopbits>:
; {
 80167fa: b580         	push	{r7, lr}
 80167fc: b084         	sub	sp, #0x10
 80167fe: af00         	add	r7, sp, #0x0
 8016800: 6078         	str	r0, [r7, #0x4]
 8016802: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8016804: 687b         	ldr	r3, [r7, #0x4]
 8016806: 685b         	ldr	r3, [r3, #0x4]
 8016808: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetStopBitsLength(config->usart, stopbits);
 801680a: 68fb         	ldr	r3, [r7, #0xc]
 801680c: 681b         	ldr	r3, [r3]
 801680e: 6839         	ldr	r1, [r7]
 8016810: 4618         	mov	r0, r3
 8016812: f7ff fbf4    	bl	0x8015ffe <LL_USART_SetStopBitsLength> @ imm = #-0x818
; }
 8016816: bf00         	nop
 8016818: 3710         	adds	r7, #0x10
 801681a: 46bd         	mov	sp, r7
 801681c: bd80         	pop	{r7, pc}

0801681e <uart_stm32_get_stopbits>:
; {
 801681e: b580         	push	{r7, lr}
 8016820: b084         	sub	sp, #0x10
 8016822: af00         	add	r7, sp, #0x0
 8016824: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8016826: 687b         	ldr	r3, [r7, #0x4]
 8016828: 685b         	ldr	r3, [r3, #0x4]
 801682a: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetStopBitsLength(config->usart);
 801682c: 68fb         	ldr	r3, [r7, #0xc]
 801682e: 681b         	ldr	r3, [r3]
 8016830: 4618         	mov	r0, r3
 8016832: f7ff fbf6    	bl	0x8016022 <LL_USART_GetStopBitsLength> @ imm = #-0x814
 8016836: 4603         	mov	r3, r0
; }
 8016838: 4618         	mov	r0, r3
 801683a: 3710         	adds	r7, #0x10
 801683c: 46bd         	mov	sp, r7
 801683e: bd80         	pop	{r7, pc}

08016840 <uart_stm32_set_databits>:
; {
 8016840: b580         	push	{r7, lr}
 8016842: b084         	sub	sp, #0x10
 8016844: af00         	add	r7, sp, #0x0
 8016846: 6078         	str	r0, [r7, #0x4]
 8016848: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801684a: 687b         	ldr	r3, [r7, #0x4]
 801684c: 685b         	ldr	r3, [r3, #0x4]
 801684e: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetDataWidth(config->usart, databits);
 8016850: 68fb         	ldr	r3, [r7, #0xc]
 8016852: 681b         	ldr	r3, [r3]
 8016854: 6839         	ldr	r1, [r7]
 8016856: 4618         	mov	r0, r3
 8016858: f7ff fba0    	bl	0x8015f9c <LL_USART_SetDataWidth> @ imm = #-0x8c0
; }
 801685c: bf00         	nop
 801685e: 3710         	adds	r7, #0x10
 8016860: 46bd         	mov	sp, r7
 8016862: bd80         	pop	{r7, pc}

08016864 <uart_stm32_get_databits>:
; {
 8016864: b580         	push	{r7, lr}
 8016866: b084         	sub	sp, #0x10
 8016868: af00         	add	r7, sp, #0x0
 801686a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801686c: 687b         	ldr	r3, [r7, #0x4]
 801686e: 685b         	ldr	r3, [r3, #0x4]
 8016870: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetDataWidth(config->usart);
 8016872: 68fb         	ldr	r3, [r7, #0xc]
 8016874: 681b         	ldr	r3, [r3]
 8016876: 4618         	mov	r0, r3
 8016878: f7ff fba2    	bl	0x8015fc0 <LL_USART_GetDataWidth> @ imm = #-0x8bc
 801687c: 4603         	mov	r3, r0
; }
 801687e: 4618         	mov	r0, r3
 8016880: 3710         	adds	r7, #0x10
 8016882: 46bd         	mov	sp, r7
 8016884: bd80         	pop	{r7, pc}

08016886 <uart_stm32_set_hwctrl>:
; {
 8016886: b580         	push	{r7, lr}
 8016888: b084         	sub	sp, #0x10
 801688a: af00         	add	r7, sp, #0x0
 801688c: 6078         	str	r0, [r7, #0x4]
 801688e: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8016890: 687b         	ldr	r3, [r7, #0x4]
 8016892: 685b         	ldr	r3, [r3, #0x4]
 8016894: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetHWFlowCtrl(config->usart, hwctrl);
 8016896: 68fb         	ldr	r3, [r7, #0xc]
 8016898: 681b         	ldr	r3, [r3]
 801689a: 6839         	ldr	r1, [r7]
 801689c: 4618         	mov	r0, r3
 801689e: f7ff fbeb    	bl	0x8016078 <LL_USART_SetHWFlowCtrl> @ imm = #-0x82a
; }
 80168a2: bf00         	nop
 80168a4: 3710         	adds	r7, #0x10
 80168a6: 46bd         	mov	sp, r7
 80168a8: bd80         	pop	{r7, pc}

080168aa <uart_stm32_get_hwctrl>:
; {
 80168aa: b580         	push	{r7, lr}
 80168ac: b084         	sub	sp, #0x10
 80168ae: af00         	add	r7, sp, #0x0
 80168b0: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80168b2: 687b         	ldr	r3, [r7, #0x4]
 80168b4: 685b         	ldr	r3, [r3, #0x4]
 80168b6: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetHWFlowCtrl(config->usart);
 80168b8: 68fb         	ldr	r3, [r7, #0xc]
 80168ba: 681b         	ldr	r3, [r3]
 80168bc: 4618         	mov	r0, r3
 80168be: f7ff fbed    	bl	0x801609c <LL_USART_GetHWFlowCtrl> @ imm = #-0x826
 80168c2: 4603         	mov	r3, r0
; }
 80168c4: 4618         	mov	r0, r3
 80168c6: 3710         	adds	r7, #0x10
 80168c8: 46bd         	mov	sp, r7
 80168ca: bd80         	pop	{r7, pc}

080168cc <uart_stm32_cfg2ll_parity>:
; {
 80168cc: b480         	push	{r7}
 80168ce: b083         	sub	sp, #0xc
 80168d0: af00         	add	r7, sp, #0x0
 80168d2: 4603         	mov	r3, r0
 80168d4: 71fb         	strb	r3, [r7, #0x7]
; 	switch (parity) {
 80168d6: 79fb         	ldrb	r3, [r7, #0x7]
 80168d8: 2b01         	cmp	r3, #0x1
 80168da: d002         	beq	0x80168e2 <uart_stm32_cfg2ll_parity+0x16> @ imm = #0x4
 80168dc: 2b02         	cmp	r3, #0x2
 80168de: d003         	beq	0x80168e8 <uart_stm32_cfg2ll_parity+0x1c> @ imm = #0x6
 80168e0: e005         	b	0x80168ee <uart_stm32_cfg2ll_parity+0x22> @ imm = #0xa
; 		return LL_USART_PARITY_ODD;
 80168e2: f44f 63c0    	mov.w	r3, #0x600
 80168e6: e003         	b	0x80168f0 <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x6
; 		return LL_USART_PARITY_EVEN;
 80168e8: f44f 6380    	mov.w	r3, #0x400
 80168ec: e000         	b	0x80168f0 <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x0
; 		return LL_USART_PARITY_NONE;
 80168ee: 2300         	movs	r3, #0x0
; }
 80168f0: 4618         	mov	r0, r3
 80168f2: 370c         	adds	r7, #0xc
 80168f4: 46bd         	mov	sp, r7
 80168f6: bc80         	pop	{r7}
 80168f8: 4770         	bx	lr

080168fa <uart_stm32_ll2cfg_parity>:
; {
 80168fa: b480         	push	{r7}
 80168fc: b083         	sub	sp, #0xc
 80168fe: af00         	add	r7, sp, #0x0
 8016900: 6078         	str	r0, [r7, #0x4]
; 	switch (parity) {
 8016902: 687b         	ldr	r3, [r7, #0x4]
 8016904: f5b3 6f80    	cmp.w	r3, #0x400
 8016908: d005         	beq	0x8016916 <uart_stm32_ll2cfg_parity+0x1c> @ imm = #0xa
 801690a: 687b         	ldr	r3, [r7, #0x4]
 801690c: f5b3 6fc0    	cmp.w	r3, #0x600
 8016910: d103         	bne	0x801691a <uart_stm32_ll2cfg_parity+0x20> @ imm = #0x6
; 		return UART_CFG_PARITY_ODD;
 8016912: 2301         	movs	r3, #0x1
 8016914: e002         	b	0x801691c <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x4
; 		return UART_CFG_PARITY_EVEN;
 8016916: 2302         	movs	r3, #0x2
 8016918: e000         	b	0x801691c <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x0
; 		return UART_CFG_PARITY_NONE;
 801691a: 2300         	movs	r3, #0x0
; }
 801691c: 4618         	mov	r0, r3
 801691e: 370c         	adds	r7, #0xc
 8016920: 46bd         	mov	sp, r7
 8016922: bc80         	pop	{r7}
 8016924: 4770         	bx	lr

08016926 <uart_stm32_cfg2ll_stopbits>:
; {
 8016926: b480         	push	{r7}
 8016928: b083         	sub	sp, #0xc
 801692a: af00         	add	r7, sp, #0x0
 801692c: 6078         	str	r0, [r7, #0x4]
 801692e: 460b         	mov	r3, r1
 8016930: 70fb         	strb	r3, [r7, #0x3]
; 	switch (sb) {
 8016932: 78fb         	ldrb	r3, [r7, #0x3]
 8016934: 2b02         	cmp	r3, #0x2
 8016936: d00b         	beq	0x8016950 <uart_stm32_cfg2ll_stopbits+0x2a> @ imm = #0x16
 8016938: 2b02         	cmp	r3, #0x2
 801693a: dc0c         	bgt	0x8016956 <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0x18
 801693c: 2b00         	cmp	r3, #0x0
 801693e: d002         	beq	0x8016946 <uart_stm32_cfg2ll_stopbits+0x20> @ imm = #0x4
 8016940: 2b01         	cmp	r3, #0x1
 8016942: d003         	beq	0x801694c <uart_stm32_cfg2ll_stopbits+0x26> @ imm = #0x6
 8016944: e007         	b	0x8016956 <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0xe
; 		return LL_USART_STOPBITS_0_5;
 8016946: f44f 5380    	mov.w	r3, #0x1000
 801694a: e006         	b	0x801695a <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0xc
; 		return LL_USART_STOPBITS_1;
 801694c: 2300         	movs	r3, #0x0
 801694e: e004         	b	0x801695a <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x8
; 		return LL_USART_STOPBITS_1_5;
 8016950: f44f 5340    	mov.w	r3, #0x3000
 8016954: e001         	b	0x801695a <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x2
; 		return LL_USART_STOPBITS_2;
 8016956: f44f 5300    	mov.w	r3, #0x2000
; }
 801695a: 4618         	mov	r0, r3
 801695c: 370c         	adds	r7, #0xc
 801695e: 46bd         	mov	sp, r7
 8016960: bc80         	pop	{r7}
 8016962: 4770         	bx	lr

08016964 <uart_stm32_ll2cfg_stopbits>:
; {
 8016964: b480         	push	{r7}
 8016966: b083         	sub	sp, #0xc
 8016968: af00         	add	r7, sp, #0x0
 801696a: 6078         	str	r0, [r7, #0x4]
; 	switch (sb) {
 801696c: 687b         	ldr	r3, [r7, #0x4]
 801696e: f5b3 5f40    	cmp.w	r3, #0x3000
 8016972: d00e         	beq	0x8016992 <uart_stm32_ll2cfg_stopbits+0x2e> @ imm = #0x1c
 8016974: 687b         	ldr	r3, [r7, #0x4]
 8016976: f5b3 5f40    	cmp.w	r3, #0x3000
 801697a: d80c         	bhi	0x8016996 <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0x18
 801697c: 687b         	ldr	r3, [r7, #0x4]
 801697e: 2b00         	cmp	r3, #0x0
 8016980: d005         	beq	0x801698e <uart_stm32_ll2cfg_stopbits+0x2a> @ imm = #0xa
 8016982: 687b         	ldr	r3, [r7, #0x4]
 8016984: f5b3 5f80    	cmp.w	r3, #0x1000
 8016988: d105         	bne	0x8016996 <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0xa
; 		return UART_CFG_STOP_BITS_0_5;
 801698a: 2300         	movs	r3, #0x0
 801698c: e004         	b	0x8016998 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x8
; 		return UART_CFG_STOP_BITS_1;
 801698e: 2301         	movs	r3, #0x1
 8016990: e002         	b	0x8016998 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x4
; 		return UART_CFG_STOP_BITS_1_5;
 8016992: 2302         	movs	r3, #0x2
 8016994: e000         	b	0x8016998 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x0
; 		return UART_CFG_STOP_BITS_2;
 8016996: 2303         	movs	r3, #0x3
; }
 8016998: 4618         	mov	r0, r3
 801699a: 370c         	adds	r7, #0xc
 801699c: 46bd         	mov	sp, r7
 801699e: bc80         	pop	{r7}
 80169a0: 4770         	bx	lr

080169a2 <uart_stm32_cfg2ll_databits>:
; {
 80169a2: b480         	push	{r7}
 80169a4: b083         	sub	sp, #0xc
 80169a6: af00         	add	r7, sp, #0x0
 80169a8: 4603         	mov	r3, r0
 80169aa: 460a         	mov	r2, r1
 80169ac: 71fb         	strb	r3, [r7, #0x7]
 80169ae: 4613         	mov	r3, r2
 80169b0: 71bb         	strb	r3, [r7, #0x6]
; 	switch (db) {
 80169b2: 79fb         	ldrb	r3, [r7, #0x7]
 80169b4: 2b04         	cmp	r3, #0x4
 80169b6: d102         	bne	0x80169be <uart_stm32_cfg2ll_databits+0x1c> @ imm = #0x4
; 		return LL_USART_DATAWIDTH_9B;
 80169b8: f44f 5380    	mov.w	r3, #0x1000
 80169bc: e006         	b	0x80169cc <uart_stm32_cfg2ll_databits+0x2a> @ imm = #0xc
; 		if (p == UART_CFG_PARITY_NONE) {
 80169be: 79bb         	ldrb	r3, [r7, #0x6]
 80169c0: 2b00         	cmp	r3, #0x0
 80169c2: d101         	bne	0x80169c8 <uart_stm32_cfg2ll_databits+0x26> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_8B;
 80169c4: 2300         	movs	r3, #0x0
 80169c6: e001         	b	0x80169cc <uart_stm32_cfg2ll_databits+0x2a> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_9B;
 80169c8: f44f 5380    	mov.w	r3, #0x1000
; }
 80169cc: 4618         	mov	r0, r3
 80169ce: 370c         	adds	r7, #0xc
 80169d0: 46bd         	mov	sp, r7
 80169d2: bc80         	pop	{r7}
 80169d4: 4770         	bx	lr

080169d6 <uart_stm32_ll2cfg_databits>:
; {
 80169d6: b480         	push	{r7}
 80169d8: b083         	sub	sp, #0xc
 80169da: af00         	add	r7, sp, #0x0
 80169dc: 6078         	str	r0, [r7, #0x4]
 80169de: 6039         	str	r1, [r7]
; 	switch (db) {
 80169e0: 687b         	ldr	r3, [r7, #0x4]
 80169e2: f5b3 5f80    	cmp.w	r3, #0x1000
 80169e6: d106         	bne	0x80169f6 <uart_stm32_ll2cfg_databits+0x20> @ imm = #0xc
; 		if (p == LL_USART_PARITY_NONE) {
 80169e8: 683b         	ldr	r3, [r7]
 80169ea: 2b00         	cmp	r3, #0x0
 80169ec: d101         	bne	0x80169f2 <uart_stm32_ll2cfg_databits+0x1c> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_9;
 80169ee: 2304         	movs	r3, #0x4
 80169f0: e007         	b	0x8016a02 <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0xe
; 			return UART_CFG_DATA_BITS_8;
 80169f2: 2303         	movs	r3, #0x3
 80169f4: e005         	b	0x8016a02 <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0xa
; 		if (p == LL_USART_PARITY_NONE) {
 80169f6: 683b         	ldr	r3, [r7]
 80169f8: 2b00         	cmp	r3, #0x0
 80169fa: d101         	bne	0x8016a00 <uart_stm32_ll2cfg_databits+0x2a> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_8;
 80169fc: 2303         	movs	r3, #0x3
 80169fe: e000         	b	0x8016a02 <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0x0
; 			return UART_CFG_DATA_BITS_7;
 8016a00: 2302         	movs	r3, #0x2
; }
 8016a02: 4618         	mov	r0, r3
 8016a04: 370c         	adds	r7, #0xc
 8016a06: 46bd         	mov	sp, r7
 8016a08: bc80         	pop	{r7}
 8016a0a: 4770         	bx	lr

08016a0c <uart_stm32_cfg2ll_hwctrl>:
; {
 8016a0c: b480         	push	{r7}
 8016a0e: b083         	sub	sp, #0xc
 8016a10: af00         	add	r7, sp, #0x0
 8016a12: 4603         	mov	r3, r0
 8016a14: 71fb         	strb	r3, [r7, #0x7]
; 	if (fc == UART_CFG_FLOW_CTRL_RTS_CTS) {
 8016a16: 79fb         	ldrb	r3, [r7, #0x7]
 8016a18: 2b01         	cmp	r3, #0x1
 8016a1a: d102         	bne	0x8016a22 <uart_stm32_cfg2ll_hwctrl+0x16> @ imm = #0x4
; 		return LL_USART_HWCONTROL_RTS_CTS;
 8016a1c: f44f 7340    	mov.w	r3, #0x300
 8016a20: e005         	b	0x8016a2e <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0xa
; 	} else if (fc == UART_CFG_FLOW_CTRL_RS485) {
 8016a22: 79fb         	ldrb	r3, [r7, #0x7]
 8016a24: 2b03         	cmp	r3, #0x3
 8016a26: d101         	bne	0x8016a2c <uart_stm32_cfg2ll_hwctrl+0x20> @ imm = #0x2
; 		return LL_USART_HWCONTROL_NONE;
 8016a28: 2300         	movs	r3, #0x0
 8016a2a: e000         	b	0x8016a2e <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0x0
; 	return LL_USART_HWCONTROL_NONE;
 8016a2c: 2300         	movs	r3, #0x0
; }
 8016a2e: 4618         	mov	r0, r3
 8016a30: 370c         	adds	r7, #0xc
 8016a32: 46bd         	mov	sp, r7
 8016a34: bc80         	pop	{r7}
 8016a36: 4770         	bx	lr

08016a38 <uart_stm32_ll2cfg_hwctrl>:
; {
 8016a38: b480         	push	{r7}
 8016a3a: b083         	sub	sp, #0xc
 8016a3c: af00         	add	r7, sp, #0x0
 8016a3e: 6078         	str	r0, [r7, #0x4]
; 	if (fc == LL_USART_HWCONTROL_RTS_CTS) {
 8016a40: 687b         	ldr	r3, [r7, #0x4]
 8016a42: f5b3 7f40    	cmp.w	r3, #0x300
 8016a46: d101         	bne	0x8016a4c <uart_stm32_ll2cfg_hwctrl+0x14> @ imm = #0x2
; 		return UART_CFG_FLOW_CTRL_RTS_CTS;
 8016a48: 2301         	movs	r3, #0x1
 8016a4a: e000         	b	0x8016a4e <uart_stm32_ll2cfg_hwctrl+0x16> @ imm = #0x0
; 	return UART_CFG_FLOW_CTRL_NONE;
 8016a4c: 2300         	movs	r3, #0x0
; }
 8016a4e: 4618         	mov	r0, r3
 8016a50: 370c         	adds	r7, #0xc
 8016a52: 46bd         	mov	sp, r7
 8016a54: bc80         	pop	{r7}
 8016a56: 4770         	bx	lr

08016a58 <uart_stm32_parameters_set>:
; {
 8016a58: b580         	push	{r7, lr}
 8016a5a: b08a         	sub	sp, #0x28
 8016a5c: af00         	add	r7, sp, #0x0
 8016a5e: 6078         	str	r0, [r7, #0x4]
 8016a60: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8016a62: 687b         	ldr	r3, [r7, #0x4]
 8016a64: 685b         	ldr	r3, [r3, #0x4]
 8016a66: 627b         	str	r3, [r7, #0x24]
; 	struct uart_stm32_data *data = dev->data;
 8016a68: 687b         	ldr	r3, [r7, #0x4]
 8016a6a: 691b         	ldr	r3, [r3, #0x10]
 8016a6c: 623b         	str	r3, [r7, #0x20]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 8016a6e: 6a3b         	ldr	r3, [r7, #0x20]
 8016a70: 685b         	ldr	r3, [r3, #0x4]
 8016a72: 61fb         	str	r3, [r7, #0x1c]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 8016a74: 683b         	ldr	r3, [r7]
 8016a76: 791b         	ldrb	r3, [r3, #0x4]
 8016a78: 4618         	mov	r0, r3
 8016a7a: f7ff ff27    	bl	0x80168cc <uart_stm32_cfg2ll_parity> @ imm = #-0x1b2
 8016a7e: 61b8         	str	r0, [r7, #0x18]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 8016a80: 683b         	ldr	r3, [r7]
 8016a82: 795b         	ldrb	r3, [r3, #0x5]
 8016a84: 4619         	mov	r1, r3
 8016a86: 6a78         	ldr	r0, [r7, #0x24]
 8016a88: f7ff ff4d    	bl	0x8016926 <uart_stm32_cfg2ll_stopbits> @ imm = #-0x166
 8016a8c: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 8016a8e: 683b         	ldr	r3, [r7]
 8016a90: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 8016a92: 683b         	ldr	r3, [r7]
 8016a94: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 8016a96: 4619         	mov	r1, r3
 8016a98: 4610         	mov	r0, r2
 8016a9a: f7ff ff82    	bl	0x80169a2 <uart_stm32_cfg2ll_databits> @ imm = #-0xfc
 8016a9e: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t flowctrl = uart_stm32_cfg2ll_hwctrl(cfg->flow_ctrl);
 8016aa0: 683b         	ldr	r3, [r7]
 8016aa2: 79db         	ldrb	r3, [r3, #0x7]
 8016aa4: 4618         	mov	r0, r3
 8016aa6: f7ff ffb1    	bl	0x8016a0c <uart_stm32_cfg2ll_hwctrl> @ imm = #-0x9e
 8016aaa: 60f8         	str	r0, [r7, #0xc]
; 	if (cfg == uart_cfg) {
 8016aac: 683a         	ldr	r2, [r7]
 8016aae: 69fb         	ldr	r3, [r7, #0x1c]
 8016ab0: 429a         	cmp	r2, r3
 8016ab2: d111         	bne	0x8016ad8 <uart_stm32_parameters_set+0x80> @ imm = #0x22
; 		LL_USART_ConfigCharacter(config->usart,
 8016ab4: 6a7b         	ldr	r3, [r7, #0x24]
 8016ab6: 6818         	ldr	r0, [r3]
 8016ab8: 697b         	ldr	r3, [r7, #0x14]
 8016aba: 69ba         	ldr	r2, [r7, #0x18]
 8016abc: 6939         	ldr	r1, [r7, #0x10]
 8016abe: f7ff fabd    	bl	0x801603c <LL_USART_ConfigCharacter> @ imm = #-0xa86
; 		uart_stm32_set_hwctrl(dev, flowctrl);
 8016ac2: 68f9         	ldr	r1, [r7, #0xc]
 8016ac4: 6878         	ldr	r0, [r7, #0x4]
 8016ac6: f7ff fede    	bl	0x8016886 <uart_stm32_set_hwctrl> @ imm = #-0x244
; 		uart_stm32_set_baudrate(dev, cfg->baudrate);
 8016aca: 683b         	ldr	r3, [r7]
 8016acc: 681b         	ldr	r3, [r3]
 8016ace: 4619         	mov	r1, r3
 8016ad0: 6878         	ldr	r0, [r7, #0x4]
 8016ad2: f7f1 f8a9    	bl	0x8007c28 <uart_stm32_set_baudrate> @ imm = #-0xeeae
; }
 8016ad6: e03b         	b	0x8016b50 <uart_stm32_parameters_set+0xf8> @ imm = #0x76
; 		if (parity != uart_stm32_get_parity(dev)) {
 8016ad8: 6878         	ldr	r0, [r7, #0x4]
 8016ada: f7ff fe7d    	bl	0x80167d8 <uart_stm32_get_parity> @ imm = #-0x306
 8016ade: 4602         	mov	r2, r0
 8016ae0: 69bb         	ldr	r3, [r7, #0x18]
 8016ae2: 4293         	cmp	r3, r2
 8016ae4: d003         	beq	0x8016aee <uart_stm32_parameters_set+0x96> @ imm = #0x6
; 			uart_stm32_set_parity(dev, parity);
 8016ae6: 69b9         	ldr	r1, [r7, #0x18]
 8016ae8: 6878         	ldr	r0, [r7, #0x4]
 8016aea: f7ff fe63    	bl	0x80167b4 <uart_stm32_set_parity> @ imm = #-0x33a
; 		if (stopbits != uart_stm32_get_stopbits(dev)) {
 8016aee: 6878         	ldr	r0, [r7, #0x4]
 8016af0: f7ff fe95    	bl	0x801681e <uart_stm32_get_stopbits> @ imm = #-0x2d6
 8016af4: 4602         	mov	r2, r0
 8016af6: 697b         	ldr	r3, [r7, #0x14]
 8016af8: 4293         	cmp	r3, r2
 8016afa: d003         	beq	0x8016b04 <uart_stm32_parameters_set+0xac> @ imm = #0x6
; 			uart_stm32_set_stopbits(dev, stopbits);
 8016afc: 6979         	ldr	r1, [r7, #0x14]
 8016afe: 6878         	ldr	r0, [r7, #0x4]
 8016b00: f7ff fe7b    	bl	0x80167fa <uart_stm32_set_stopbits> @ imm = #-0x30a
; 		if (databits != uart_stm32_get_databits(dev)) {
 8016b04: 6878         	ldr	r0, [r7, #0x4]
 8016b06: f7ff fead    	bl	0x8016864 <uart_stm32_get_databits> @ imm = #-0x2a6
 8016b0a: 4602         	mov	r2, r0
 8016b0c: 693b         	ldr	r3, [r7, #0x10]
 8016b0e: 4293         	cmp	r3, r2
 8016b10: d003         	beq	0x8016b1a <uart_stm32_parameters_set+0xc2> @ imm = #0x6
; 			uart_stm32_set_databits(dev, databits);
 8016b12: 6939         	ldr	r1, [r7, #0x10]
 8016b14: 6878         	ldr	r0, [r7, #0x4]
 8016b16: f7ff fe93    	bl	0x8016840 <uart_stm32_set_databits> @ imm = #-0x2da
; 		if (flowctrl != uart_stm32_get_hwctrl(dev)) {
 8016b1a: 6878         	ldr	r0, [r7, #0x4]
 8016b1c: f7ff fec5    	bl	0x80168aa <uart_stm32_get_hwctrl> @ imm = #-0x276
 8016b20: 4602         	mov	r2, r0
 8016b22: 68fb         	ldr	r3, [r7, #0xc]
 8016b24: 4293         	cmp	r3, r2
 8016b26: d003         	beq	0x8016b30 <uart_stm32_parameters_set+0xd8> @ imm = #0x6
; 			uart_stm32_set_hwctrl(dev, flowctrl);
 8016b28: 68f9         	ldr	r1, [r7, #0xc]
 8016b2a: 6878         	ldr	r0, [r7, #0x4]
 8016b2c: f7ff feab    	bl	0x8016886 <uart_stm32_set_hwctrl> @ imm = #-0x2aa
; 		if (cfg->baudrate != uart_cfg->baudrate) {
 8016b30: 683b         	ldr	r3, [r7]
 8016b32: 681a         	ldr	r2, [r3]
 8016b34: 69fb         	ldr	r3, [r7, #0x1c]
 8016b36: 681b         	ldr	r3, [r3]
 8016b38: 429a         	cmp	r2, r3
 8016b3a: d009         	beq	0x8016b50 <uart_stm32_parameters_set+0xf8> @ imm = #0x12
; 			uart_stm32_set_baudrate(dev, cfg->baudrate);
 8016b3c: 683b         	ldr	r3, [r7]
 8016b3e: 681b         	ldr	r3, [r3]
 8016b40: 4619         	mov	r1, r3
 8016b42: 6878         	ldr	r0, [r7, #0x4]
 8016b44: f7f1 f870    	bl	0x8007c28 <uart_stm32_set_baudrate> @ imm = #-0xef20
; 			uart_cfg->baudrate = cfg->baudrate;
 8016b48: 683b         	ldr	r3, [r7]
 8016b4a: 681a         	ldr	r2, [r3]
 8016b4c: 69fb         	ldr	r3, [r7, #0x1c]
 8016b4e: 601a         	str	r2, [r3]
; }
 8016b50: bf00         	nop
 8016b52: 3728         	adds	r7, #0x28
 8016b54: 46bd         	mov	sp, r7
 8016b56: bd80         	pop	{r7, pc}

08016b58 <uart_stm32_config_get>:
; {
 8016b58: b590         	push	{r4, r7, lr}
 8016b5a: b085         	sub	sp, #0x14
 8016b5c: af00         	add	r7, sp, #0x0
 8016b5e: 6078         	str	r0, [r7, #0x4]
 8016b60: 6039         	str	r1, [r7]
; 	struct uart_stm32_data *data = dev->data;
 8016b62: 687b         	ldr	r3, [r7, #0x4]
 8016b64: 691b         	ldr	r3, [r3, #0x10]
 8016b66: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 8016b68: 68fb         	ldr	r3, [r7, #0xc]
 8016b6a: 685b         	ldr	r3, [r3, #0x4]
 8016b6c: 60bb         	str	r3, [r7, #0x8]
; 	cfg->baudrate = uart_cfg->baudrate;
 8016b6e: 68bb         	ldr	r3, [r7, #0x8]
 8016b70: 681a         	ldr	r2, [r3]
 8016b72: 683b         	ldr	r3, [r7]
 8016b74: 601a         	str	r2, [r3]
; 	cfg->parity = uart_stm32_ll2cfg_parity(uart_stm32_get_parity(dev));
 8016b76: 6878         	ldr	r0, [r7, #0x4]
 8016b78: f7ff fe2e    	bl	0x80167d8 <uart_stm32_get_parity> @ imm = #-0x3a4
 8016b7c: 4603         	mov	r3, r0
 8016b7e: 4618         	mov	r0, r3
 8016b80: f7ff febb    	bl	0x80168fa <uart_stm32_ll2cfg_parity> @ imm = #-0x28a
 8016b84: 4603         	mov	r3, r0
 8016b86: 461a         	mov	r2, r3
 8016b88: 683b         	ldr	r3, [r7]
 8016b8a: 711a         	strb	r2, [r3, #0x4]
; 	cfg->stop_bits = uart_stm32_ll2cfg_stopbits(
 8016b8c: 6878         	ldr	r0, [r7, #0x4]
 8016b8e: f7ff fe46    	bl	0x801681e <uart_stm32_get_stopbits> @ imm = #-0x374
 8016b92: 4603         	mov	r3, r0
 8016b94: 4618         	mov	r0, r3
 8016b96: f7ff fee5    	bl	0x8016964 <uart_stm32_ll2cfg_stopbits> @ imm = #-0x236
 8016b9a: 4603         	mov	r3, r0
 8016b9c: 461a         	mov	r2, r3
 8016b9e: 683b         	ldr	r3, [r7]
 8016ba0: 715a         	strb	r2, [r3, #0x5]
; 	cfg->data_bits = uart_stm32_ll2cfg_databits(
 8016ba2: 6878         	ldr	r0, [r7, #0x4]
 8016ba4: f7ff fe5e    	bl	0x8016864 <uart_stm32_get_databits> @ imm = #-0x344
 8016ba8: 4604         	mov	r4, r0
 8016baa: 6878         	ldr	r0, [r7, #0x4]
 8016bac: f7ff fe14    	bl	0x80167d8 <uart_stm32_get_parity> @ imm = #-0x3d8
 8016bb0: 4603         	mov	r3, r0
 8016bb2: 4619         	mov	r1, r3
 8016bb4: 4620         	mov	r0, r4
 8016bb6: f7ff ff0e    	bl	0x80169d6 <uart_stm32_ll2cfg_databits> @ imm = #-0x1e4
 8016bba: 4603         	mov	r3, r0
 8016bbc: 461a         	mov	r2, r3
 8016bbe: 683b         	ldr	r3, [r7]
 8016bc0: 719a         	strb	r2, [r3, #0x6]
; 	cfg->flow_ctrl = uart_stm32_ll2cfg_hwctrl(
 8016bc2: 6878         	ldr	r0, [r7, #0x4]
 8016bc4: f7ff fe71    	bl	0x80168aa <uart_stm32_get_hwctrl> @ imm = #-0x31e
 8016bc8: 4603         	mov	r3, r0
 8016bca: 4618         	mov	r0, r3
 8016bcc: f7ff ff34    	bl	0x8016a38 <uart_stm32_ll2cfg_hwctrl> @ imm = #-0x198
 8016bd0: 4603         	mov	r3, r0
 8016bd2: 461a         	mov	r2, r3
 8016bd4: 683b         	ldr	r3, [r7]
 8016bd6: 71da         	strb	r2, [r3, #0x7]
; 	return 0;
 8016bd8: 2300         	movs	r3, #0x0
; }
 8016bda: 4618         	mov	r0, r3
 8016bdc: 3714         	adds	r7, #0x14
 8016bde: 46bd         	mov	sp, r7
 8016be0: bd90         	pop	{r4, r7, pc}

08016be2 <uart_stm32_poll_in_visitor>:
; {
 8016be2: b580         	push	{r7, lr}
 8016be4: b086         	sub	sp, #0x18
 8016be6: af00         	add	r7, sp, #0x0
 8016be8: 60f8         	str	r0, [r7, #0xc]
 8016bea: 60b9         	str	r1, [r7, #0x8]
 8016bec: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8016bee: 68fb         	ldr	r3, [r7, #0xc]
 8016bf0: 685b         	ldr	r3, [r3, #0x4]
 8016bf2: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 8016bf4: 697b         	ldr	r3, [r7, #0x14]
 8016bf6: 681b         	ldr	r3, [r3]
 8016bf8: 613b         	str	r3, [r7, #0x10]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 8016bfa: 6938         	ldr	r0, [r7, #0x10]
 8016bfc: f7ff faa0    	bl	0x8016140 <LL_USART_IsActiveFlag_ORE> @ imm = #-0xac0
 8016c00: 4603         	mov	r3, r0
 8016c02: 2b00         	cmp	r3, #0x0
 8016c04: d002         	beq	0x8016c0c <uart_stm32_poll_in_visitor+0x2a> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 8016c06: 6938         	ldr	r0, [r7, #0x10]
 8016c08: f7ff fb3a    	bl	0x8016280 <LL_USART_ClearFlag_ORE> @ imm = #-0x98c
; 	if (!LL_USART_IsActiveFlag_RXNE(usart)) {
 8016c0c: 6938         	ldr	r0, [r7, #0x10]
 8016c0e: f7ff fabb    	bl	0x8016188 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xa8a
 8016c12: 4603         	mov	r3, r0
 8016c14: 2b00         	cmp	r3, #0x0
 8016c16: d102         	bne	0x8016c1e <uart_stm32_poll_in_visitor+0x3c> @ imm = #0x4
; 		return -1;
 8016c18: f04f 33ff    	mov.w	r3, #0xffffffff
 8016c1c: e004         	b	0x8016c28 <uart_stm32_poll_in_visitor+0x46> @ imm = #0x8
; 	get_fn(usart, in);
 8016c1e: 687b         	ldr	r3, [r7, #0x4]
 8016c20: 68b9         	ldr	r1, [r7, #0x8]
 8016c22: 6938         	ldr	r0, [r7, #0x10]
 8016c24: 4798         	blx	r3
; 	return 0;
 8016c26: 2300         	movs	r3, #0x0
; }
 8016c28: 4618         	mov	r0, r3
 8016c2a: 3718         	adds	r7, #0x18
 8016c2c: 46bd         	mov	sp, r7
 8016c2e: bd80         	pop	{r7, pc}

08016c30 <uart_stm32_poll_out_visitor>:
; {
 8016c30: b580         	push	{r7, lr}
 8016c32: b08e         	sub	sp, #0x38
 8016c34: af00         	add	r7, sp, #0x0
 8016c36: 60f8         	str	r0, [r7, #0xc]
 8016c38: 460b         	mov	r3, r1
 8016c3a: 607a         	str	r2, [r7, #0x4]
 8016c3c: 817b         	strh	r3, [r7, #0xa]
; 	const struct uart_stm32_config *config = dev->config;
 8016c3e: 68fb         	ldr	r3, [r7, #0xc]
 8016c40: 685b         	ldr	r3, [r3, #0x4]
 8016c42: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 8016c44: 6b7b         	ldr	r3, [r7, #0x34]
 8016c46: 681b         	ldr	r3, [r3]
 8016c48: 633b         	str	r3, [r7, #0x30]
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 8016c4a: 6b38         	ldr	r0, [r7, #0x30]
 8016c4c: f7ff fac0    	bl	0x80161d0 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xa80
 8016c50: 4603         	mov	r3, r0
 8016c52: 2b00         	cmp	r3, #0x0
 8016c54: d0f9         	beq	0x8016c4a <uart_stm32_poll_out_visitor+0x1a> @ imm = #-0xe
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016c56: f3ef 8311    	mrs	r3, basepri
 8016c5a: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 8016c5c: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 8016c5e: 627b         	str	r3, [r7, #0x24]
 8016c60: 2310         	movs	r3, #0x10
 8016c62: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016c64: 6a3b         	ldr	r3, [r7, #0x20]
 8016c66: f383 8812    	msr	basepri_max, r3
; }
 8016c6a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016c6c: f3bf 8f6f    	isb	sy
; }
 8016c70: bf00         	nop
; 	return key;
 8016c72: 6a7b         	ldr	r3, [r7, #0x24]
; 			key = irq_lock();
 8016c74: 62fb         	str	r3, [r7, #0x2c]
; 			if (LL_USART_IsActiveFlag_TXE(usart)) {
 8016c76: 6b38         	ldr	r0, [r7, #0x30]
 8016c78: f7ff faaa    	bl	0x80161d0 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xaac
 8016c7c: 4603         	mov	r3, r0
 8016c7e: 2b00         	cmp	r3, #0x0
 8016c80: d10c         	bne	0x8016c9c <uart_stm32_poll_out_visitor+0x6c> @ imm = #0x18
 8016c82: 6afb         	ldr	r3, [r7, #0x2c]
 8016c84: 61fb         	str	r3, [r7, #0x1c]
 8016c86: 69fb         	ldr	r3, [r7, #0x1c]
 8016c88: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016c8a: 69bb         	ldr	r3, [r7, #0x18]
 8016c8c: f383 8811    	msr	basepri, r3
; }
 8016c90: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016c92: f3bf 8f6f    	isb	sy
; }
 8016c96: bf00         	nop
; }
 8016c98: bf00         	nop
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 8016c9a: e7d6         	b	0x8016c4a <uart_stm32_poll_out_visitor+0x1a> @ imm = #-0x54
; 				break;
 8016c9c: bf00         	nop
; 	set_fn(usart, out);
 8016c9e: 897a         	ldrh	r2, [r7, #0xa]
 8016ca0: 687b         	ldr	r3, [r7, #0x4]
 8016ca2: 4611         	mov	r1, r2
 8016ca4: 6b38         	ldr	r0, [r7, #0x30]
 8016ca6: 4798         	blx	r3
 8016ca8: 6afb         	ldr	r3, [r7, #0x2c]
 8016caa: 617b         	str	r3, [r7, #0x14]
 8016cac: 697b         	ldr	r3, [r7, #0x14]
 8016cae: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016cb0: 693b         	ldr	r3, [r7, #0x10]
 8016cb2: f383 8811    	msr	basepri, r3
; }
 8016cb6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016cb8: f3bf 8f6f    	isb	sy
; }
 8016cbc: bf00         	nop
; }
 8016cbe: bf00         	nop
; }
 8016cc0: bf00         	nop
 8016cc2: 3738         	adds	r7, #0x38
 8016cc4: 46bd         	mov	sp, r7
 8016cc6: bd80         	pop	{r7, pc}

08016cc8 <poll_in_u8>:
; {
 8016cc8: b580         	push	{r7, lr}
 8016cca: b082         	sub	sp, #0x8
 8016ccc: af00         	add	r7, sp, #0x0
 8016cce: 6078         	str	r0, [r7, #0x4]
 8016cd0: 6039         	str	r1, [r7]
; 	*((unsigned char *)in) = (unsigned char)LL_USART_ReceiveData8(usart);
 8016cd2: 6878         	ldr	r0, [r7, #0x4]
 8016cd4: f7ff fd36    	bl	0x8016744 <LL_USART_ReceiveData8> @ imm = #-0x594
 8016cd8: 4603         	mov	r3, r0
 8016cda: 461a         	mov	r2, r3
 8016cdc: 683b         	ldr	r3, [r7]
 8016cde: 701a         	strb	r2, [r3]
; }
 8016ce0: bf00         	nop
 8016ce2: 3708         	adds	r7, #0x8
 8016ce4: 46bd         	mov	sp, r7
 8016ce6: bd80         	pop	{r7, pc}

08016ce8 <poll_out_u8>:
; {
 8016ce8: b580         	push	{r7, lr}
 8016cea: b082         	sub	sp, #0x8
 8016cec: af00         	add	r7, sp, #0x0
 8016cee: 6078         	str	r0, [r7, #0x4]
 8016cf0: 460b         	mov	r3, r1
 8016cf2: 807b         	strh	r3, [r7, #0x2]
; 	LL_USART_TransmitData8(usart, (uint8_t)out);
 8016cf4: 887b         	ldrh	r3, [r7, #0x2]
 8016cf6: b2db         	uxtb	r3, r3
 8016cf8: 4619         	mov	r1, r3
 8016cfa: 6878         	ldr	r0, [r7, #0x4]
 8016cfc: f7ff fd2e    	bl	0x801675c <LL_USART_TransmitData8> @ imm = #-0x5a4
; }
 8016d00: bf00         	nop
 8016d02: 3708         	adds	r7, #0x8
 8016d04: 46bd         	mov	sp, r7
 8016d06: bd80         	pop	{r7, pc}

08016d08 <uart_stm32_err_check>:
; {
 8016d08: b580         	push	{r7, lr}
 8016d0a: b086         	sub	sp, #0x18
 8016d0c: af00         	add	r7, sp, #0x0
 8016d0e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8016d10: 687b         	ldr	r3, [r7, #0x4]
 8016d12: 685b         	ldr	r3, [r3, #0x4]
 8016d14: 613b         	str	r3, [r7, #0x10]
; 	USART_TypeDef *usart = config->usart;
 8016d16: 693b         	ldr	r3, [r7, #0x10]
 8016d18: 681b         	ldr	r3, [r3]
 8016d1a: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t err = 0U;
 8016d1c: 2300         	movs	r3, #0x0
 8016d1e: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 8016d20: 68f8         	ldr	r0, [r7, #0xc]
 8016d22: f7ff fa0d    	bl	0x8016140 <LL_USART_IsActiveFlag_ORE> @ imm = #-0xbe6
 8016d26: 4603         	mov	r3, r0
 8016d28: 2b00         	cmp	r3, #0x0
 8016d2a: d003         	beq	0x8016d34 <uart_stm32_err_check+0x2c> @ imm = #0x6
; 		err |= UART_ERROR_OVERRUN;
 8016d2c: 697b         	ldr	r3, [r7, #0x14]
 8016d2e: f043 0301    	orr	r3, r3, #0x1
 8016d32: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_PE(usart)) {
 8016d34: 68f8         	ldr	r0, [r7, #0xc]
 8016d36: f7ff f9cd    	bl	0x80160d4 <LL_USART_IsActiveFlag_PE> @ imm = #-0xc66
 8016d3a: 4603         	mov	r3, r0
 8016d3c: 2b00         	cmp	r3, #0x0
 8016d3e: d003         	beq	0x8016d48 <uart_stm32_err_check+0x40> @ imm = #0x6
; 		err |= UART_ERROR_PARITY;
 8016d40: 697b         	ldr	r3, [r7, #0x14]
 8016d42: f043 0302    	orr	r3, r3, #0x2
 8016d46: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_FE(usart)) {
 8016d48: 68f8         	ldr	r0, [r7, #0xc]
 8016d4a: f7ff f9d5    	bl	0x80160f8 <LL_USART_IsActiveFlag_FE> @ imm = #-0xc56
 8016d4e: 4603         	mov	r3, r0
 8016d50: 2b00         	cmp	r3, #0x0
 8016d52: d003         	beq	0x8016d5c <uart_stm32_err_check+0x54> @ imm = #0x6
; 		err |= UART_ERROR_FRAMING;
 8016d54: 697b         	ldr	r3, [r7, #0x14]
 8016d56: f043 0304    	orr	r3, r3, #0x4
 8016d5a: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_NE(usart)) {
 8016d5c: 68f8         	ldr	r0, [r7, #0xc]
 8016d5e: f7ff f9dd    	bl	0x801611c <LL_USART_IsActiveFlag_NE> @ imm = #-0xc46
 8016d62: 4603         	mov	r3, r0
 8016d64: 2b00         	cmp	r3, #0x0
 8016d66: d003         	beq	0x8016d70 <uart_stm32_err_check+0x68> @ imm = #0x6
; 		err |= UART_ERROR_NOISE;
 8016d68: 697b         	ldr	r3, [r7, #0x14]
 8016d6a: f043 0320    	orr	r3, r3, #0x20
 8016d6e: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_LBD(usart)) {
 8016d70: 68f8         	ldr	r0, [r7, #0xc]
 8016d72: f7ff fa3f    	bl	0x80161f4 <LL_USART_IsActiveFlag_LBD> @ imm = #-0xb82
 8016d76: 4603         	mov	r3, r0
 8016d78: 2b00         	cmp	r3, #0x0
 8016d7a: d003         	beq	0x8016d84 <uart_stm32_err_check+0x7c> @ imm = #0x6
; 		err |= UART_BREAK;
 8016d7c: 697b         	ldr	r3, [r7, #0x14]
 8016d7e: f043 0308    	orr	r3, r3, #0x8
 8016d82: 617b         	str	r3, [r7, #0x14]
; 	if (err & UART_BREAK) {
 8016d84: 697b         	ldr	r3, [r7, #0x14]
 8016d86: f003 0308    	and	r3, r3, #0x8
 8016d8a: 2b00         	cmp	r3, #0x0
 8016d8c: d002         	beq	0x8016d94 <uart_stm32_err_check+0x8c> @ imm = #0x4
; 		LL_USART_ClearFlag_LBD(usart);
 8016d8e: 68f8         	ldr	r0, [r7, #0xc]
 8016d90: f7ff fab2    	bl	0x80162f8 <LL_USART_ClearFlag_LBD> @ imm = #-0xa9c
; 	if (err & UART_ERROR_OVERRUN) {
 8016d94: 697b         	ldr	r3, [r7, #0x14]
 8016d96: f003 0301    	and	r3, r3, #0x1
 8016d9a: 2b00         	cmp	r3, #0x0
 8016d9c: d002         	beq	0x8016da4 <uart_stm32_err_check+0x9c> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 8016d9e: 68f8         	ldr	r0, [r7, #0xc]
 8016da0: f7ff fa6e    	bl	0x8016280 <LL_USART_ClearFlag_ORE> @ imm = #-0xb24
; 	if (err & UART_ERROR_PARITY) {
 8016da4: 697b         	ldr	r3, [r7, #0x14]
 8016da6: f003 0302    	and	r3, r3, #0x2
 8016daa: 2b00         	cmp	r3, #0x0
 8016dac: d002         	beq	0x8016db4 <uart_stm32_err_check+0xac> @ imm = #0x4
; 		LL_USART_ClearFlag_PE(usart);
 8016dae: 68f8         	ldr	r0, [r7, #0xc]
 8016db0: f7ff fa33    	bl	0x801621a <LL_USART_ClearFlag_PE> @ imm = #-0xb9a
; 	if (err & UART_ERROR_FRAMING) {
 8016db4: 697b         	ldr	r3, [r7, #0x14]
 8016db6: f003 0304    	and	r3, r3, #0x4
 8016dba: 2b00         	cmp	r3, #0x0
 8016dbc: d002         	beq	0x8016dc4 <uart_stm32_err_check+0xbc> @ imm = #0x4
; 		LL_USART_ClearFlag_FE(usart);
 8016dbe: 68f8         	ldr	r0, [r7, #0xc]
 8016dc0: f7ff fa3c    	bl	0x801623c <LL_USART_ClearFlag_FE> @ imm = #-0xb88
; 	if (err & UART_ERROR_NOISE) {
 8016dc4: 697b         	ldr	r3, [r7, #0x14]
 8016dc6: f003 0320    	and	r3, r3, #0x20
 8016dca: 2b00         	cmp	r3, #0x0
 8016dcc: d002         	beq	0x8016dd4 <uart_stm32_err_check+0xcc> @ imm = #0x4
; 		LL_USART_ClearFlag_NE(usart);
 8016dce: 68f8         	ldr	r0, [r7, #0xc]
 8016dd0: f7ff fa45    	bl	0x801625e <LL_USART_ClearFlag_NE> @ imm = #-0xb76
; 	return err;
 8016dd4: 697b         	ldr	r3, [r7, #0x14]
; }
 8016dd6: 4618         	mov	r0, r3
 8016dd8: 3718         	adds	r7, #0x18
 8016dda: 46bd         	mov	sp, r7
 8016ddc: bd80         	pop	{r7, pc}

08016dde <uart_stm32_fifo_fill_visitor>:
; {
 8016dde: b580         	push	{r7, lr}
 8016de0: b08e         	sub	sp, #0x38
 8016de2: af00         	add	r7, sp, #0x0
 8016de4: 60f8         	str	r0, [r7, #0xc]
 8016de6: 60b9         	str	r1, [r7, #0x8]
 8016de8: 607a         	str	r2, [r7, #0x4]
 8016dea: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8016dec: 68fb         	ldr	r3, [r7, #0xc]
 8016dee: 685b         	ldr	r3, [r3, #0x4]
 8016df0: 633b         	str	r3, [r7, #0x30]
; 	USART_TypeDef *usart = config->usart;
 8016df2: 6b3b         	ldr	r3, [r7, #0x30]
 8016df4: 681b         	ldr	r3, [r3]
 8016df6: 62fb         	str	r3, [r7, #0x2c]
; 	int num_tx = 0U;
 8016df8: 2300         	movs	r3, #0x0
 8016dfa: 637b         	str	r3, [r7, #0x34]
; 	if (!LL_USART_IsActiveFlag_TXE(usart)) {
 8016dfc: 6af8         	ldr	r0, [r7, #0x2c]
 8016dfe: f7ff f9e7    	bl	0x80161d0 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xc32
 8016e02: 4603         	mov	r3, r0
 8016e04: 2b00         	cmp	r3, #0x0
 8016e06: d101         	bne	0x8016e0c <uart_stm32_fifo_fill_visitor+0x2e> @ imm = #0x2
; 		return num_tx;
 8016e08: 6b7b         	ldr	r3, [r7, #0x34]
 8016e0a: e030         	b	0x8016e6e <uart_stm32_fifo_fill_visitor+0x90> @ imm = #0x60
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016e0c: f3ef 8311    	mrs	r3, basepri
 8016e10: 627b         	str	r3, [r7, #0x24]
;   return(result);
 8016e12: 6a7b         	ldr	r3, [r7, #0x24]
; 	key = __get_BASEPRI();
 8016e14: 623b         	str	r3, [r7, #0x20]
 8016e16: 2310         	movs	r3, #0x10
 8016e18: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016e1a: 69fb         	ldr	r3, [r7, #0x1c]
 8016e1c: f383 8812    	msr	basepri_max, r3
; }
 8016e20: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016e22: f3bf 8f6f    	isb	sy
; }
 8016e26: bf00         	nop
; 	return key;
 8016e28: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = irq_lock();
 8016e2a: 62bb         	str	r3, [r7, #0x28]
; 	while ((size - num_tx > 0) && LL_USART_IsActiveFlag_TXE(usart)) {
 8016e2c: e007         	b	0x8016e3e <uart_stm32_fifo_fill_visitor+0x60> @ imm = #0xe
; 		fill_fn(usart, tx_data, num_tx);
 8016e2e: 683b         	ldr	r3, [r7]
 8016e30: 6b7a         	ldr	r2, [r7, #0x34]
 8016e32: 68b9         	ldr	r1, [r7, #0x8]
 8016e34: 6af8         	ldr	r0, [r7, #0x2c]
 8016e36: 4798         	blx	r3
; 		num_tx++;
 8016e38: 6b7b         	ldr	r3, [r7, #0x34]
 8016e3a: 3301         	adds	r3, #0x1
 8016e3c: 637b         	str	r3, [r7, #0x34]
; 	while ((size - num_tx > 0) && LL_USART_IsActiveFlag_TXE(usart)) {
 8016e3e: 687a         	ldr	r2, [r7, #0x4]
 8016e40: 6b7b         	ldr	r3, [r7, #0x34]
 8016e42: 1ad3         	subs	r3, r2, r3
 8016e44: 2b00         	cmp	r3, #0x0
 8016e46: dd05         	ble	0x8016e54 <uart_stm32_fifo_fill_visitor+0x76> @ imm = #0xa
 8016e48: 6af8         	ldr	r0, [r7, #0x2c]
 8016e4a: f7ff f9c1    	bl	0x80161d0 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xc7e
 8016e4e: 4603         	mov	r3, r0
 8016e50: 2b00         	cmp	r3, #0x0
 8016e52: d1ec         	bne	0x8016e2e <uart_stm32_fifo_fill_visitor+0x50> @ imm = #-0x28
 8016e54: 6abb         	ldr	r3, [r7, #0x28]
 8016e56: 61bb         	str	r3, [r7, #0x18]
 8016e58: 69bb         	ldr	r3, [r7, #0x18]
 8016e5a: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016e5c: 697b         	ldr	r3, [r7, #0x14]
 8016e5e: f383 8811    	msr	basepri, r3
; }
 8016e62: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016e64: f3bf 8f6f    	isb	sy
; }
 8016e68: bf00         	nop
; }
 8016e6a: bf00         	nop
; 	return num_tx;
 8016e6c: 6b7b         	ldr	r3, [r7, #0x34]
; }
 8016e6e: 4618         	mov	r0, r3
 8016e70: 3738         	adds	r7, #0x38
 8016e72: 46bd         	mov	sp, r7
 8016e74: bd80         	pop	{r7, pc}

08016e76 <fifo_fill_with_u8>:
; {
 8016e76: b580         	push	{r7, lr}
 8016e78: b086         	sub	sp, #0x18
 8016e7a: af00         	add	r7, sp, #0x0
 8016e7c: 60f8         	str	r0, [r7, #0xc]
 8016e7e: 60b9         	str	r1, [r7, #0x8]
 8016e80: 607a         	str	r2, [r7, #0x4]
; 	const uint8_t *data = (const uint8_t *)tx_data;
 8016e82: 68bb         	ldr	r3, [r7, #0x8]
 8016e84: 617b         	str	r3, [r7, #0x14]
; 	LL_USART_TransmitData8(usart, data[offset]);
 8016e86: 687b         	ldr	r3, [r7, #0x4]
 8016e88: 697a         	ldr	r2, [r7, #0x14]
 8016e8a: 4413         	add	r3, r2
 8016e8c: 781b         	ldrb	r3, [r3]
 8016e8e: 4619         	mov	r1, r3
 8016e90: 68f8         	ldr	r0, [r7, #0xc]
 8016e92: f7ff fc63    	bl	0x801675c <LL_USART_TransmitData8> @ imm = #-0x73a
; }
 8016e96: bf00         	nop
 8016e98: 3718         	adds	r7, #0x18
 8016e9a: 46bd         	mov	sp, r7
 8016e9c: bd80         	pop	{r7, pc}

08016e9e <uart_stm32_fifo_read_visitor>:
; {
 8016e9e: b580         	push	{r7, lr}
 8016ea0: b088         	sub	sp, #0x20
 8016ea2: af00         	add	r7, sp, #0x0
 8016ea4: 60f8         	str	r0, [r7, #0xc]
 8016ea6: 60b9         	str	r1, [r7, #0x8]
 8016ea8: 607a         	str	r2, [r7, #0x4]
 8016eaa: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8016eac: 68fb         	ldr	r3, [r7, #0xc]
 8016eae: 685b         	ldr	r3, [r3, #0x4]
 8016eb0: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 8016eb2: 69bb         	ldr	r3, [r7, #0x18]
 8016eb4: 681b         	ldr	r3, [r3]
 8016eb6: 617b         	str	r3, [r7, #0x14]
; 	int num_rx = 0U;
 8016eb8: 2300         	movs	r3, #0x0
 8016eba: 61fb         	str	r3, [r7, #0x1c]
; 	while ((size - num_rx > 0) && LL_USART_IsActiveFlag_RXNE(usart)) {
 8016ebc: e010         	b	0x8016ee0 <uart_stm32_fifo_read_visitor+0x42> @ imm = #0x20
; 		read_fn(usart, rx_data, num_rx);
 8016ebe: 683b         	ldr	r3, [r7]
 8016ec0: 69fa         	ldr	r2, [r7, #0x1c]
 8016ec2: 68b9         	ldr	r1, [r7, #0x8]
 8016ec4: 6978         	ldr	r0, [r7, #0x14]
 8016ec6: 4798         	blx	r3
; 		num_rx++;
 8016ec8: 69fb         	ldr	r3, [r7, #0x1c]
 8016eca: 3301         	adds	r3, #0x1
 8016ecc: 61fb         	str	r3, [r7, #0x1c]
; 		if (LL_USART_IsActiveFlag_ORE(usart)) {
 8016ece: 6978         	ldr	r0, [r7, #0x14]
 8016ed0: f7ff f936    	bl	0x8016140 <LL_USART_IsActiveFlag_ORE> @ imm = #-0xd94
 8016ed4: 4603         	mov	r3, r0
 8016ed6: 2b00         	cmp	r3, #0x0
 8016ed8: d002         	beq	0x8016ee0 <uart_stm32_fifo_read_visitor+0x42> @ imm = #0x4
; 			LL_USART_ClearFlag_ORE(usart);
 8016eda: 6978         	ldr	r0, [r7, #0x14]
 8016edc: f7ff f9d0    	bl	0x8016280 <LL_USART_ClearFlag_ORE> @ imm = #-0xc60
; 	while ((size - num_rx > 0) && LL_USART_IsActiveFlag_RXNE(usart)) {
 8016ee0: 687a         	ldr	r2, [r7, #0x4]
 8016ee2: 69fb         	ldr	r3, [r7, #0x1c]
 8016ee4: 1ad3         	subs	r3, r2, r3
 8016ee6: 2b00         	cmp	r3, #0x0
 8016ee8: dd05         	ble	0x8016ef6 <uart_stm32_fifo_read_visitor+0x58> @ imm = #0xa
 8016eea: 6978         	ldr	r0, [r7, #0x14]
 8016eec: f7ff f94c    	bl	0x8016188 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xd68
 8016ef0: 4603         	mov	r3, r0
 8016ef2: 2b00         	cmp	r3, #0x0
 8016ef4: d1e3         	bne	0x8016ebe <uart_stm32_fifo_read_visitor+0x20> @ imm = #-0x3a
; 	return num_rx;
 8016ef6: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8016ef8: 4618         	mov	r0, r3
 8016efa: 3720         	adds	r7, #0x20
 8016efc: 46bd         	mov	sp, r7
 8016efe: bd80         	pop	{r7, pc}

08016f00 <fifo_read_with_u8>:
; {
 8016f00: b590         	push	{r4, r7, lr}
 8016f02: b087         	sub	sp, #0x1c
 8016f04: af00         	add	r7, sp, #0x0
 8016f06: 60f8         	str	r0, [r7, #0xc]
 8016f08: 60b9         	str	r1, [r7, #0x8]
 8016f0a: 607a         	str	r2, [r7, #0x4]
; 	uint8_t *data = (uint8_t *)rx_data;
 8016f0c: 68bb         	ldr	r3, [r7, #0x8]
 8016f0e: 617b         	str	r3, [r7, #0x14]
; 	data[offset] = LL_USART_ReceiveData8(usart);
 8016f10: 687b         	ldr	r3, [r7, #0x4]
 8016f12: 697a         	ldr	r2, [r7, #0x14]
 8016f14: 18d4         	adds	r4, r2, r3
 8016f16: 68f8         	ldr	r0, [r7, #0xc]
 8016f18: f7ff fc14    	bl	0x8016744 <LL_USART_ReceiveData8> @ imm = #-0x7d8
 8016f1c: 4603         	mov	r3, r0
 8016f1e: 7023         	strb	r3, [r4]
; }
 8016f20: bf00         	nop
 8016f22: 371c         	adds	r7, #0x1c
 8016f24: 46bd         	mov	sp, r7
 8016f26: bd90         	pop	{r4, r7, pc}

08016f28 <uart_stm32_irq_tx_enable>:
; {
 8016f28: b580         	push	{r7, lr}
 8016f2a: b084         	sub	sp, #0x10
 8016f2c: af00         	add	r7, sp, #0x0
 8016f2e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8016f30: 687b         	ldr	r3, [r7, #0x4]
 8016f32: 685b         	ldr	r3, [r3, #0x4]
 8016f34: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableIT_TC(config->usart);
 8016f36: 68fb         	ldr	r3, [r7, #0xc]
 8016f38: 681b         	ldr	r3, [r3]
 8016f3a: 4618         	mov	r0, r3
 8016f3c: f7ff fa2d    	bl	0x801639a <LL_USART_EnableIT_TC> @ imm = #-0xba6
; }
 8016f40: bf00         	nop
 8016f42: 3710         	adds	r7, #0x10
 8016f44: 46bd         	mov	sp, r7
 8016f46: bd80         	pop	{r7, pc}

08016f48 <uart_stm32_irq_tx_disable>:
; {
 8016f48: b580         	push	{r7, lr}
 8016f4a: b084         	sub	sp, #0x10
 8016f4c: af00         	add	r7, sp, #0x0
 8016f4e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8016f50: 687b         	ldr	r3, [r7, #0x4]
 8016f52: 685b         	ldr	r3, [r3, #0x4]
 8016f54: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableIT_TC(config->usart);
 8016f56: 68fb         	ldr	r3, [r7, #0xc]
 8016f58: 681b         	ldr	r3, [r3]
 8016f5a: 4618         	mov	r0, r3
 8016f5c: f7ff fad6    	bl	0x801650c <LL_USART_DisableIT_TC> @ imm = #-0xa54
; }
 8016f60: bf00         	nop
 8016f62: 3710         	adds	r7, #0x10
 8016f64: 46bd         	mov	sp, r7
 8016f66: bd80         	pop	{r7, pc}

08016f68 <uart_stm32_irq_tx_ready>:
; {
 8016f68: b580         	push	{r7, lr}
 8016f6a: b084         	sub	sp, #0x10
 8016f6c: af00         	add	r7, sp, #0x0
 8016f6e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8016f70: 687b         	ldr	r3, [r7, #0x4]
 8016f72: 685b         	ldr	r3, [r3, #0x4]
 8016f74: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_TXE(config->usart) &&
 8016f76: 68fb         	ldr	r3, [r7, #0xc]
 8016f78: 681b         	ldr	r3, [r3]
 8016f7a: 4618         	mov	r0, r3
 8016f7c: f7ff f928    	bl	0x80161d0 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xdb0
 8016f80: 4603         	mov	r3, r0
 8016f82: 2b00         	cmp	r3, #0x0
 8016f84: d009         	beq	0x8016f9a <uart_stm32_irq_tx_ready+0x32> @ imm = #0x12
; 		LL_USART_IsEnabledIT_TC(config->usart);
 8016f86: 68fb         	ldr	r3, [r7, #0xc]
 8016f88: 681b         	ldr	r3, [r3]
 8016f8a: 4618         	mov	r0, r3
 8016f8c: f7ff fb57    	bl	0x801663e <LL_USART_IsEnabledIT_TC> @ imm = #-0x952
 8016f90: 4603         	mov	r3, r0
; 	return LL_USART_IsActiveFlag_TXE(config->usart) &&
 8016f92: 2b00         	cmp	r3, #0x0
 8016f94: d001         	beq	0x8016f9a <uart_stm32_irq_tx_ready+0x32> @ imm = #0x2
 8016f96: 2301         	movs	r3, #0x1
 8016f98: e000         	b	0x8016f9c <uart_stm32_irq_tx_ready+0x34> @ imm = #0x0
 8016f9a: 2300         	movs	r3, #0x0
; }
 8016f9c: 4618         	mov	r0, r3
 8016f9e: 3710         	adds	r7, #0x10
 8016fa0: 46bd         	mov	sp, r7
 8016fa2: bd80         	pop	{r7, pc}

08016fa4 <uart_stm32_irq_tx_complete>:
; {
 8016fa4: b580         	push	{r7, lr}
 8016fa6: b084         	sub	sp, #0x10
 8016fa8: af00         	add	r7, sp, #0x0
 8016faa: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8016fac: 687b         	ldr	r3, [r7, #0x4]
 8016fae: 685b         	ldr	r3, [r3, #0x4]
 8016fb0: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_TC(config->usart);
 8016fb2: 68fb         	ldr	r3, [r7, #0xc]
 8016fb4: 681b         	ldr	r3, [r3]
 8016fb6: 4618         	mov	r0, r3
 8016fb8: f7ff f8f8    	bl	0x80161ac <LL_USART_IsActiveFlag_TC> @ imm = #-0xe10
 8016fbc: 4603         	mov	r3, r0
; }
 8016fbe: 4618         	mov	r0, r3
 8016fc0: 3710         	adds	r7, #0x10
 8016fc2: 46bd         	mov	sp, r7
 8016fc4: bd80         	pop	{r7, pc}

08016fc6 <uart_stm32_irq_rx_enable>:
; {
 8016fc6: b580         	push	{r7, lr}
 8016fc8: b084         	sub	sp, #0x10
 8016fca: af00         	add	r7, sp, #0x0
 8016fcc: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8016fce: 687b         	ldr	r3, [r7, #0x4]
 8016fd0: 685b         	ldr	r3, [r3, #0x4]
 8016fd2: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableIT_RXNE(config->usart);
 8016fd4: 68fb         	ldr	r3, [r7, #0xc]
 8016fd6: 681b         	ldr	r3, [r3]
 8016fd8: 4618         	mov	r0, r3
 8016fda: f7ff f9bc    	bl	0x8016356 <LL_USART_EnableIT_RXNE> @ imm = #-0xc88
; }
 8016fde: bf00         	nop
 8016fe0: 3710         	adds	r7, #0x10
 8016fe2: 46bd         	mov	sp, r7
 8016fe4: bd80         	pop	{r7, pc}

08016fe6 <uart_stm32_irq_rx_disable>:
; {
 8016fe6: b580         	push	{r7, lr}
 8016fe8: b084         	sub	sp, #0x10
 8016fea: af00         	add	r7, sp, #0x0
 8016fec: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8016fee: 687b         	ldr	r3, [r7, #0x4]
 8016ff0: 685b         	ldr	r3, [r3, #0x4]
 8016ff2: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableIT_RXNE(config->usart);
 8016ff4: 68fb         	ldr	r3, [r7, #0xc]
 8016ff6: 681b         	ldr	r3, [r3]
 8016ff8: 4618         	mov	r0, r3
 8016ffa: f7ff fa65    	bl	0x80164c8 <LL_USART_DisableIT_RXNE> @ imm = #-0xb36
; }
 8016ffe: bf00         	nop
 8017000: 3710         	adds	r7, #0x10
 8017002: 46bd         	mov	sp, r7
 8017004: bd80         	pop	{r7, pc}

08017006 <uart_stm32_irq_rx_ready>:
; {
 8017006: b580         	push	{r7, lr}
 8017008: b084         	sub	sp, #0x10
 801700a: af00         	add	r7, sp, #0x0
 801700c: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801700e: 687b         	ldr	r3, [r7, #0x4]
 8017010: 685b         	ldr	r3, [r3, #0x4]
 8017012: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_RXNE(config->usart);
 8017014: 68fb         	ldr	r3, [r7, #0xc]
 8017016: 681b         	ldr	r3, [r3]
 8017018: 4618         	mov	r0, r3
 801701a: f7ff f8b5    	bl	0x8016188 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xe96
 801701e: 4603         	mov	r3, r0
; }
 8017020: 4618         	mov	r0, r3
 8017022: 3710         	adds	r7, #0x10
 8017024: 46bd         	mov	sp, r7
 8017026: bd80         	pop	{r7, pc}

08017028 <uart_stm32_irq_is_pending>:
; {
 8017028: b580         	push	{r7, lr}
 801702a: b084         	sub	sp, #0x10
 801702c: af00         	add	r7, sp, #0x0
 801702e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8017030: 687b         	ldr	r3, [r7, #0x4]
 8017032: 685b         	ldr	r3, [r3, #0x4]
 8017034: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 8017036: 68fb         	ldr	r3, [r7, #0xc]
 8017038: 681b         	ldr	r3, [r3]
 801703a: 60bb         	str	r3, [r7, #0x8]
; 	return ((LL_USART_IsActiveFlag_RXNE(usart) &&
 801703c: 68b8         	ldr	r0, [r7, #0x8]
 801703e: f7ff f8a3    	bl	0x8016188 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xeba
 8017042: 4603         	mov	r3, r0
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 8017044: 2b00         	cmp	r3, #0x0
 8017046: d005         	beq	0x8017054 <uart_stm32_irq_is_pending+0x2c> @ imm = #0xa
 8017048: 68b8         	ldr	r0, [r7, #0x8]
 801704a: f7ff fae6    	bl	0x801661a <LL_USART_IsEnabledIT_RXNE> @ imm = #-0xa34
 801704e: 4603         	mov	r3, r0
; 	return ((LL_USART_IsActiveFlag_RXNE(usart) &&
 8017050: 2b00         	cmp	r3, #0x0
 8017052: d10b         	bne	0x801706c <uart_stm32_irq_is_pending+0x44> @ imm = #0x16
; 		(LL_USART_IsActiveFlag_TC(usart) &&
 8017054: 68b8         	ldr	r0, [r7, #0x8]
 8017056: f7ff f8a9    	bl	0x80161ac <LL_USART_IsActiveFlag_TC> @ imm = #-0xeae
 801705a: 4603         	mov	r3, r0
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 801705c: 2b00         	cmp	r3, #0x0
 801705e: d007         	beq	0x8017070 <uart_stm32_irq_is_pending+0x48> @ imm = #0xe
; 		 LL_USART_IsEnabledIT_TC(usart)));
 8017060: 68b8         	ldr	r0, [r7, #0x8]
 8017062: f7ff faec    	bl	0x801663e <LL_USART_IsEnabledIT_TC> @ imm = #-0xa28
 8017066: 4603         	mov	r3, r0
; 		(LL_USART_IsActiveFlag_TC(usart) &&
 8017068: 2b00         	cmp	r3, #0x0
 801706a: d001         	beq	0x8017070 <uart_stm32_irq_is_pending+0x48> @ imm = #0x2
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 801706c: 2301         	movs	r3, #0x1
 801706e: e000         	b	0x8017072 <uart_stm32_irq_is_pending+0x4a> @ imm = #0x0
 8017070: 2300         	movs	r3, #0x0
; }
 8017072: 4618         	mov	r0, r3
 8017074: 3710         	adds	r7, #0x10
 8017076: 46bd         	mov	sp, r7
 8017078: bd80         	pop	{r7, pc}

0801707a <uart_stm32_irq_update>:
; {
 801707a: b480         	push	{r7}
 801707c: b083         	sub	sp, #0xc
 801707e: af00         	add	r7, sp, #0x0
 8017080: 6078         	str	r0, [r7, #0x4]
; 	return 1;
 8017082: 2301         	movs	r3, #0x1
; }
 8017084: 4618         	mov	r0, r3
 8017086: 370c         	adds	r7, #0xc
 8017088: 46bd         	mov	sp, r7
 801708a: bc80         	pop	{r7}
 801708c: 4770         	bx	lr

0801708e <uart_stm32_irq_callback_set>:
; {
 801708e: b480         	push	{r7}
 8017090: b087         	sub	sp, #0x1c
 8017092: af00         	add	r7, sp, #0x0
 8017094: 60f8         	str	r0, [r7, #0xc]
 8017096: 60b9         	str	r1, [r7, #0x8]
 8017098: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801709a: 68fb         	ldr	r3, [r7, #0xc]
 801709c: 691b         	ldr	r3, [r3, #0x10]
 801709e: 617b         	str	r3, [r7, #0x14]
; 	data->user_cb = cb;
 80170a0: 697b         	ldr	r3, [r7, #0x14]
 80170a2: 68ba         	ldr	r2, [r7, #0x8]
 80170a4: 609a         	str	r2, [r3, #0x8]
; 	data->user_data = cb_data;
 80170a6: 697b         	ldr	r3, [r7, #0x14]
 80170a8: 687a         	ldr	r2, [r7, #0x4]
 80170aa: 60da         	str	r2, [r3, #0xc]
; 	data->async_cb = NULL;
 80170ac: 697b         	ldr	r3, [r7, #0x14]
 80170ae: 2200         	movs	r2, #0x0
 80170b0: 615a         	str	r2, [r3, #0x14]
; 	data->async_user_data = NULL;
 80170b2: 697b         	ldr	r3, [r7, #0x14]
 80170b4: 2200         	movs	r2, #0x0
 80170b6: 619a         	str	r2, [r3, #0x18]
; }
 80170b8: bf00         	nop
 80170ba: 371c         	adds	r7, #0x1c
 80170bc: 46bd         	mov	sp, r7
 80170be: bc80         	pop	{r7}
 80170c0: 4770         	bx	lr

080170c2 <async_user_callback>:
; {
 80170c2: b580         	push	{r7, lr}
 80170c4: b082         	sub	sp, #0x8
 80170c6: af00         	add	r7, sp, #0x0
 80170c8: 6078         	str	r0, [r7, #0x4]
 80170ca: 6039         	str	r1, [r7]
; 	if (data->async_cb) {
 80170cc: 687b         	ldr	r3, [r7, #0x4]
 80170ce: 695b         	ldr	r3, [r3, #0x14]
 80170d0: 2b00         	cmp	r3, #0x0
 80170d2: d007         	beq	0x80170e4 <async_user_callback+0x22> @ imm = #0xe
; 		data->async_cb(data->uart_dev, event, data->async_user_data);
 80170d4: 687b         	ldr	r3, [r7, #0x4]
 80170d6: 695b         	ldr	r3, [r3, #0x14]
 80170d8: 687a         	ldr	r2, [r7, #0x4]
 80170da: 6910         	ldr	r0, [r2, #0x10]
 80170dc: 687a         	ldr	r2, [r7, #0x4]
 80170de: 6992         	ldr	r2, [r2, #0x18]
 80170e0: 6839         	ldr	r1, [r7]
 80170e2: 4798         	blx	r3
; }
 80170e4: bf00         	nop
 80170e6: 3708         	adds	r7, #0x8
 80170e8: 46bd         	mov	sp, r7
 80170ea: bd80         	pop	{r7, pc}

080170ec <async_evt_rx_buf_request>:
; {
 80170ec: b580         	push	{r7, lr}
 80170ee: b088         	sub	sp, #0x20
 80170f0: af00         	add	r7, sp, #0x0
 80170f2: 6078         	str	r0, [r7, #0x4]
; 	struct uart_event evt = {
 80170f4: f107 030c    	add.w	r3, r7, #0xc
 80170f8: 2200         	movs	r2, #0x0
 80170fa: 601a         	str	r2, [r3]
 80170fc: 605a         	str	r2, [r3, #0x4]
 80170fe: 609a         	str	r2, [r3, #0x8]
 8017100: 60da         	str	r2, [r3, #0xc]
 8017102: 611a         	str	r2, [r3, #0x10]
 8017104: 2303         	movs	r3, #0x3
 8017106: 733b         	strb	r3, [r7, #0xc]
; 	async_user_callback(data, &evt);
 8017108: f107 030c    	add.w	r3, r7, #0xc
 801710c: 4619         	mov	r1, r3
 801710e: 6878         	ldr	r0, [r7, #0x4]
 8017110: f7ff ffd7    	bl	0x80170c2 <async_user_callback> @ imm = #-0x52
; }
 8017114: bf00         	nop
 8017116: 3720         	adds	r7, #0x20
 8017118: 46bd         	mov	sp, r7
 801711a: bd80         	pop	{r7, pc}

0801711c <async_evt_rx_buf_release>:
; {
 801711c: b580         	push	{r7, lr}
 801711e: b088         	sub	sp, #0x20
 8017120: af00         	add	r7, sp, #0x0
 8017122: 6078         	str	r0, [r7, #0x4]
; 	struct uart_event evt = {
 8017124: f107 030c    	add.w	r3, r7, #0xc
 8017128: 2200         	movs	r2, #0x0
 801712a: 601a         	str	r2, [r3]
 801712c: 605a         	str	r2, [r3, #0x4]
 801712e: 609a         	str	r2, [r3, #0x8]
 8017130: 60da         	str	r2, [r3, #0xc]
 8017132: 611a         	str	r2, [r3, #0x10]
 8017134: 2304         	movs	r3, #0x4
 8017136: 733b         	strb	r3, [r7, #0xc]
; 		.data.rx_buf.buf = data->dma_rx.buffer,
 8017138: 687b         	ldr	r3, [r7, #0x4]
 801713a: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event evt = {
 801713c: 613b         	str	r3, [r7, #0x10]
; 	async_user_callback(data, &evt);
 801713e: f107 030c    	add.w	r3, r7, #0xc
 8017142: 4619         	mov	r1, r3
 8017144: 6878         	ldr	r0, [r7, #0x4]
 8017146: f7ff ffbc    	bl	0x80170c2 <async_user_callback> @ imm = #-0x88
; }
 801714a: bf00         	nop
 801714c: 3720         	adds	r7, #0x20
 801714e: 46bd         	mov	sp, r7
 8017150: bd80         	pop	{r7, pc}

08017152 <uart_stm32_dma_rx_flush>:
; {
 8017152: b580         	push	{r7, lr}
 8017154: b08c         	sub	sp, #0x30
 8017156: af00         	add	r7, sp, #0x0
 8017158: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801715a: 687b         	ldr	r3, [r7, #0x4]
 801715c: 691b         	ldr	r3, [r3, #0x10]
 801715e: 62fb         	str	r3, [r7, #0x2c]
; 	if (dma_get_status(data->dma_rx.dma_dev,
 8017160: 6afb         	ldr	r3, [r7, #0x2c]
 8017162: 6a18         	ldr	r0, [r3, #0x20]
 8017164: 6afb         	ldr	r3, [r7, #0x2c]
 8017166: 6a5b         	ldr	r3, [r3, #0x24]
 8017168: f107 0208    	add.w	r2, r7, #0x8
 801716c: 4619         	mov	r1, r3
 801716e: f7fe fe13    	bl	0x8015d98 <dma_get_status> @ imm = #-0x13da
 8017172: 4603         	mov	r3, r0
 8017174: 2b00         	cmp	r3, #0x0
 8017176: d10f         	bne	0x8017198 <uart_stm32_dma_rx_flush+0x46> @ imm = #0x1e
; 		size_t rx_rcv_len = data->dma_rx.buffer_length -
 8017178: 6afb         	ldr	r3, [r7, #0x2c]
 801717a: 6f1a         	ldr	r2, [r3, #0x70]
; 					stat.pending_length;
 801717c: 68fb         	ldr	r3, [r7, #0xc]
; 		size_t rx_rcv_len = data->dma_rx.buffer_length -
 801717e: 1ad3         	subs	r3, r2, r3
 8017180: 62bb         	str	r3, [r7, #0x28]
; 		if (rx_rcv_len > data->dma_rx.offset) {
 8017182: 6afb         	ldr	r3, [r7, #0x2c]
 8017184: 6f5b         	ldr	r3, [r3, #0x74]
 8017186: 6aba         	ldr	r2, [r7, #0x28]
 8017188: 429a         	cmp	r2, r3
 801718a: d905         	bls	0x8017198 <uart_stm32_dma_rx_flush+0x46> @ imm = #0xa
; 			data->dma_rx.counter = rx_rcv_len;
 801718c: 6afb         	ldr	r3, [r7, #0x2c]
 801718e: 6aba         	ldr	r2, [r7, #0x28]
 8017190: 679a         	str	r2, [r3, #0x78]
; 			async_evt_rx_rdy(data);
 8017192: 6af8         	ldr	r0, [r7, #0x2c]
 8017194: f7f0 ff1a    	bl	0x8007fcc <async_evt_rx_rdy> @ imm = #-0xf1cc
; }
 8017198: bf00         	nop
 801719a: 3730         	adds	r7, #0x30
 801719c: 46bd         	mov	sp, r7
 801719e: bd80         	pop	{r7, pc}

080171a0 <uart_stm32_async_callback_set>:
; {
 80171a0: b480         	push	{r7}
 80171a2: b087         	sub	sp, #0x1c
 80171a4: af00         	add	r7, sp, #0x0
 80171a6: 60f8         	str	r0, [r7, #0xc]
 80171a8: 60b9         	str	r1, [r7, #0x8]
 80171aa: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 80171ac: 68fb         	ldr	r3, [r7, #0xc]
 80171ae: 691b         	ldr	r3, [r3, #0x10]
 80171b0: 617b         	str	r3, [r7, #0x14]
; 	data->async_cb = callback;
 80171b2: 697b         	ldr	r3, [r7, #0x14]
 80171b4: 68ba         	ldr	r2, [r7, #0x8]
 80171b6: 615a         	str	r2, [r3, #0x14]
; 	data->async_user_data = user_data;
 80171b8: 697b         	ldr	r3, [r7, #0x14]
 80171ba: 687a         	ldr	r2, [r7, #0x4]
 80171bc: 619a         	str	r2, [r3, #0x18]
; 	data->user_cb = NULL;
 80171be: 697b         	ldr	r3, [r7, #0x14]
 80171c0: 2200         	movs	r2, #0x0
 80171c2: 609a         	str	r2, [r3, #0x8]
; 	data->user_data = NULL;
 80171c4: 697b         	ldr	r3, [r7, #0x14]
 80171c6: 2200         	movs	r2, #0x0
 80171c8: 60da         	str	r2, [r3, #0xc]
; 	return 0;
 80171ca: 2300         	movs	r3, #0x0
; }
 80171cc: 4618         	mov	r0, r3
 80171ce: 371c         	adds	r7, #0x1c
 80171d0: 46bd         	mov	sp, r7
 80171d2: bc80         	pop	{r7}
 80171d4: 4770         	bx	lr

080171d6 <uart_stm32_dma_tx_enable>:
; {
 80171d6: b580         	push	{r7, lr}
 80171d8: b084         	sub	sp, #0x10
 80171da: af00         	add	r7, sp, #0x0
 80171dc: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80171de: 687b         	ldr	r3, [r7, #0x4]
 80171e0: 685b         	ldr	r3, [r3, #0x4]
 80171e2: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableDMAReq_TX(config->usart);
 80171e4: 68fb         	ldr	r3, [r7, #0xc]
 80171e6: 681b         	ldr	r3, [r3]
 80171e8: 4618         	mov	r0, r3
 80171ea: f7ff fa5c    	bl	0x80166a6 <LL_USART_EnableDMAReq_TX> @ imm = #-0xb48
; }
 80171ee: bf00         	nop
 80171f0: 3710         	adds	r7, #0x10
 80171f2: 46bd         	mov	sp, r7
 80171f4: bd80         	pop	{r7, pc}

080171f6 <uart_stm32_dma_tx_disable>:
; {
 80171f6: b580         	push	{r7, lr}
 80171f8: b084         	sub	sp, #0x10
 80171fa: af00         	add	r7, sp, #0x0
 80171fc: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80171fe: 687b         	ldr	r3, [r7, #0x4]
 8017200: 685b         	ldr	r3, [r3, #0x4]
 8017202: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableDMAReq_TX(config->usart);
 8017204: 68fb         	ldr	r3, [r7, #0xc]
 8017206: 681b         	ldr	r3, [r3]
 8017208: 4618         	mov	r0, r3
 801720a: f7ff fa6e    	bl	0x80166ea <LL_USART_DisableDMAReq_TX> @ imm = #-0xb24
; }
 801720e: bf00         	nop
 8017210: 3710         	adds	r7, #0x10
 8017212: 46bd         	mov	sp, r7
 8017214: bd80         	pop	{r7, pc}

08017216 <uart_stm32_dma_rx_enable>:
; {
 8017216: b580         	push	{r7, lr}
 8017218: b084         	sub	sp, #0x10
 801721a: af00         	add	r7, sp, #0x0
 801721c: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801721e: 687b         	ldr	r3, [r7, #0x4]
 8017220: 685b         	ldr	r3, [r3, #0x4]
 8017222: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_stm32_data *data = dev->data;
 8017224: 687b         	ldr	r3, [r7, #0x4]
 8017226: 691b         	ldr	r3, [r3, #0x10]
 8017228: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_EnableDMAReq_RX(config->usart);
 801722a: 68fb         	ldr	r3, [r7, #0xc]
 801722c: 681b         	ldr	r3, [r3]
 801722e: 4618         	mov	r0, r3
 8017230: f7ff fa17    	bl	0x8016662 <LL_USART_EnableDMAReq_RX> @ imm = #-0xbd2
; 	data->dma_rx.enabled = true;
 8017234: 68bb         	ldr	r3, [r7, #0x8]
 8017236: 2201         	movs	r2, #0x1
 8017238: f883 20b0    	strb.w	r2, [r3, #0xb0]
; }
 801723c: bf00         	nop
 801723e: 3710         	adds	r7, #0x10
 8017240: 46bd         	mov	sp, r7
 8017242: bd80         	pop	{r7, pc}

08017244 <uart_stm32_dma_rx_disable>:
; {
 8017244: b480         	push	{r7}
 8017246: b085         	sub	sp, #0x14
 8017248: af00         	add	r7, sp, #0x0
 801724a: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801724c: 687b         	ldr	r3, [r7, #0x4]
 801724e: 691b         	ldr	r3, [r3, #0x10]
 8017250: 60fb         	str	r3, [r7, #0xc]
; 	data->dma_rx.enabled = false;
 8017252: 68fb         	ldr	r3, [r7, #0xc]
 8017254: 2200         	movs	r2, #0x0
 8017256: f883 20b0    	strb.w	r2, [r3, #0xb0]
; }
 801725a: bf00         	nop
 801725c: 3714         	adds	r7, #0x14
 801725e: 46bd         	mov	sp, r7
 8017260: bc80         	pop	{r7}
 8017262: 4770         	bx	lr

08017264 <uart_stm32_dma_tx_cb>:
; {
 8017264: b580         	push	{r7, lr}
 8017266: b094         	sub	sp, #0x50
 8017268: af00         	add	r7, sp, #0x0
 801726a: 60f8         	str	r0, [r7, #0xc]
 801726c: 60b9         	str	r1, [r7, #0x8]
 801726e: 607a         	str	r2, [r7, #0x4]
 8017270: 603b         	str	r3, [r7]
; 	const struct device *uart_dev = user_data;
 8017272: 68bb         	ldr	r3, [r7, #0x8]
 8017274: 64fb         	str	r3, [r7, #0x4c]
; 	struct uart_stm32_data *data = uart_dev->data;
 8017276: 6cfb         	ldr	r3, [r7, #0x4c]
 8017278: 691b         	ldr	r3, [r3, #0x10]
 801727a: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801727c: f3ef 8311    	mrs	r3, basepri
 8017280: 643b         	str	r3, [r7, #0x40]
;   return(result);
 8017282: 6c3b         	ldr	r3, [r7, #0x40]
; 	key = __get_BASEPRI();
 8017284: 63fb         	str	r3, [r7, #0x3c]
 8017286: 2310         	movs	r3, #0x10
 8017288: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801728a: 6bbb         	ldr	r3, [r7, #0x38]
 801728c: f383 8812    	msr	basepri_max, r3
; }
 8017290: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017292: f3bf 8f6f    	isb	sy
; }
 8017296: bf00         	nop
; 	return key;
 8017298: 6bfb         	ldr	r3, [r7, #0x3c]
; 	unsigned int key = irq_lock();
 801729a: 647b         	str	r3, [r7, #0x44]
; 	uart_stm32_dma_tx_disable(uart_dev);
 801729c: 6cf8         	ldr	r0, [r7, #0x4c]
 801729e: f7ff ffaa    	bl	0x80171f6 <uart_stm32_dma_tx_disable> @ imm = #-0xac
; 	(void)k_work_cancel_delayable(&data->dma_tx.timeout_work);
 80172a2: 6cbb         	ldr	r3, [r7, #0x48]
 80172a4: f503 738c    	add.w	r3, r3, #0x118
 80172a8: 4618         	mov	r0, r3
 80172aa: f7f6 fa09    	bl	0x800d6c0 <k_work_cancel_delayable> @ imm = #-0x9bee
; 	if (!dma_get_status(data->dma_tx.dma_dev,
 80172ae: 6cbb         	ldr	r3, [r7, #0x48]
 80172b0: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 80172b4: 6cbb         	ldr	r3, [r7, #0x48]
 80172b6: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 80172ba: f107 0210    	add.w	r2, r7, #0x10
 80172be: 4619         	mov	r1, r3
 80172c0: f7fe fd6a    	bl	0x8015d98 <dma_get_status> @ imm = #-0x152c
 80172c4: 4603         	mov	r3, r0
 80172c6: 2b00         	cmp	r3, #0x0
 80172c8: d107         	bne	0x80172da <uart_stm32_dma_tx_cb+0x76> @ imm = #0xe
; 		data->dma_tx.counter = data->dma_tx.buffer_length -
 80172ca: 6cbb         	ldr	r3, [r7, #0x48]
 80172cc: f8d3 2108    	ldr.w	r2, [r3, #0x108]
; 					stat.pending_length;
 80172d0: 697b         	ldr	r3, [r7, #0x14]
; 		data->dma_tx.counter = data->dma_tx.buffer_length -
 80172d2: 1ad2         	subs	r2, r2, r3
 80172d4: 6cbb         	ldr	r3, [r7, #0x48]
 80172d6: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	data->dma_tx.buffer_length = 0;
 80172da: 6cbb         	ldr	r3, [r7, #0x48]
 80172dc: 2200         	movs	r2, #0x0
 80172de: f8c3 2108    	str.w	r2, [r3, #0x108]
 80172e2: 6c7b         	ldr	r3, [r7, #0x44]
 80172e4: 637b         	str	r3, [r7, #0x34]
 80172e6: 6b7b         	ldr	r3, [r7, #0x34]
 80172e8: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80172ea: 6b3b         	ldr	r3, [r7, #0x30]
 80172ec: f383 8811    	msr	basepri, r3
; }
 80172f0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80172f2: f3bf 8f6f    	isb	sy
; }
 80172f6: bf00         	nop
; }
 80172f8: bf00         	nop
; }
 80172fa: bf00         	nop
 80172fc: 3750         	adds	r7, #0x50
 80172fe: 46bd         	mov	sp, r7
 8017300: bd80         	pop	{r7, pc}

08017302 <uart_stm32_dma_rx_cb>:
; {
 8017302: b580         	push	{r7, lr}
 8017304: b086         	sub	sp, #0x18
 8017306: af00         	add	r7, sp, #0x0
 8017308: 60f8         	str	r0, [r7, #0xc]
 801730a: 60b9         	str	r1, [r7, #0x8]
 801730c: 607a         	str	r2, [r7, #0x4]
 801730e: 603b         	str	r3, [r7]
; 	const struct device *uart_dev = user_data;
 8017310: 68bb         	ldr	r3, [r7, #0x8]
 8017312: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = uart_dev->data;
 8017314: 697b         	ldr	r3, [r7, #0x14]
 8017316: 691b         	ldr	r3, [r3, #0x10]
 8017318: 613b         	str	r3, [r7, #0x10]
; 	if (status < 0) {
 801731a: 683b         	ldr	r3, [r7]
 801731c: 2b00         	cmp	r3, #0x0
 801731e: da04         	bge	0x801732a <uart_stm32_dma_rx_cb+0x28> @ imm = #0x8
; 		async_evt_rx_err(data, status);
 8017320: 6839         	ldr	r1, [r7]
 8017322: 6938         	ldr	r0, [r7, #0x10]
 8017324: f7f0 fea8    	bl	0x8008078 <async_evt_rx_err> @ imm = #-0xf2b0
; 		return;
 8017328: e021         	b	0x801736e <uart_stm32_dma_rx_cb+0x6c> @ imm = #0x42
; 	(void)k_work_cancel_delayable(&data->dma_rx.timeout_work);
 801732a: 693b         	ldr	r3, [r7, #0x10]
 801732c: 3380         	adds	r3, #0x80
 801732e: 4618         	mov	r0, r3
 8017330: f7f6 f9c6    	bl	0x800d6c0 <k_work_cancel_delayable> @ imm = #-0x9c74
; 	data->dma_rx.counter = data->dma_rx.buffer_length;
 8017334: 693b         	ldr	r3, [r7, #0x10]
 8017336: 6f1a         	ldr	r2, [r3, #0x70]
 8017338: 693b         	ldr	r3, [r7, #0x10]
 801733a: 679a         	str	r2, [r3, #0x78]
; 	async_evt_rx_rdy(data);
 801733c: 6938         	ldr	r0, [r7, #0x10]
 801733e: f7f0 fe45    	bl	0x8007fcc <async_evt_rx_rdy> @ imm = #-0xf376
; 	if (data->rx_next_buffer != NULL) {
 8017342: 693b         	ldr	r3, [r7, #0x10]
 8017344: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 8017348: 2b00         	cmp	r3, #0x0
 801734a: d006         	beq	0x801735a <uart_stm32_dma_rx_cb+0x58> @ imm = #0xc
; 		async_evt_rx_buf_release(data);
 801734c: 6938         	ldr	r0, [r7, #0x10]
 801734e: f7ff fee5    	bl	0x801711c <async_evt_rx_buf_release> @ imm = #-0x236
; 		uart_stm32_dma_replace_buffer(uart_dev);
 8017352: 6978         	ldr	r0, [r7, #0x14]
 8017354: f7f1 f8d8    	bl	0x8008508 <uart_stm32_dma_replace_buffer> @ imm = #-0xee50
 8017358: e009         	b	0x801736e <uart_stm32_dma_rx_cb+0x6c> @ imm = #0x12
; 		k_work_reschedule(&data->dma_rx.timeout_work, K_TICKS(1));
 801735a: 693b         	ldr	r3, [r7, #0x10]
 801735c: f103 0180    	add.w	r1, r3, #0x80
 8017360: f04f 0201    	mov.w	r2, #0x1
 8017364: f04f 0300    	mov.w	r3, #0x0
 8017368: 4608         	mov	r0, r1
 801736a: f7f6 f995    	bl	0x800d698 <k_work_reschedule> @ imm = #-0x9cd6
; }
 801736e: 3718         	adds	r7, #0x18
 8017370: 46bd         	mov	sp, r7
 8017372: bd80         	pop	{r7, pc}

08017374 <uart_stm32_async_tx_abort>:
; {
 8017374: b580         	push	{r7, lr}
 8017376: b08c         	sub	sp, #0x30
 8017378: af00         	add	r7, sp, #0x0
 801737a: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801737c: 687b         	ldr	r3, [r7, #0x4]
 801737e: 691b         	ldr	r3, [r3, #0x10]
 8017380: 62fb         	str	r3, [r7, #0x2c]
; 	size_t tx_buffer_length = data->dma_tx.buffer_length;
 8017382: 6afb         	ldr	r3, [r7, #0x2c]
 8017384: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 8017388: 62bb         	str	r3, [r7, #0x28]
; 	if (tx_buffer_length == 0) {
 801738a: 6abb         	ldr	r3, [r7, #0x28]
 801738c: 2b00         	cmp	r3, #0x0
 801738e: d102         	bne	0x8017396 <uart_stm32_async_tx_abort+0x22> @ imm = #0x4
; 		return -EFAULT;
 8017390: f06f 030d    	mvn	r3, #0xd
 8017394: e027         	b	0x80173e6 <uart_stm32_async_tx_abort+0x72> @ imm = #0x4e
; 	(void)k_work_cancel_delayable(&data->dma_tx.timeout_work);
 8017396: 6afb         	ldr	r3, [r7, #0x2c]
 8017398: f503 738c    	add.w	r3, r3, #0x118
 801739c: 4618         	mov	r0, r3
 801739e: f7f6 f98f    	bl	0x800d6c0 <k_work_cancel_delayable> @ imm = #-0x9ce2
; 	if (!dma_get_status(data->dma_tx.dma_dev,
 80173a2: 6afb         	ldr	r3, [r7, #0x2c]
 80173a4: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 80173a8: 6afb         	ldr	r3, [r7, #0x2c]
 80173aa: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 80173ae: f107 0208    	add.w	r2, r7, #0x8
 80173b2: 4619         	mov	r1, r3
 80173b4: f7fe fcf0    	bl	0x8015d98 <dma_get_status> @ imm = #-0x1620
 80173b8: 4603         	mov	r3, r0
 80173ba: 2b00         	cmp	r3, #0x0
 80173bc: d105         	bne	0x80173ca <uart_stm32_async_tx_abort+0x56> @ imm = #0xa
; 		data->dma_tx.counter = tx_buffer_length - stat.pending_length;
 80173be: 68fb         	ldr	r3, [r7, #0xc]
 80173c0: 6aba         	ldr	r2, [r7, #0x28]
 80173c2: 1ad2         	subs	r2, r2, r3
 80173c4: 6afb         	ldr	r3, [r7, #0x2c]
 80173c6: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	dma_stop(data->dma_tx.dma_dev, data->dma_tx.dma_channel);
 80173ca: 6afb         	ldr	r3, [r7, #0x2c]
 80173cc: f8d3 20b8    	ldr.w	r2, [r3, #0xb8]
 80173d0: 6afb         	ldr	r3, [r7, #0x2c]
 80173d2: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 80173d6: 4619         	mov	r1, r3
 80173d8: 4610         	mov	r0, r2
 80173da: f7fe fd06    	bl	0x8015dea <dma_stop>    @ imm = #-0x15f4
; 	async_evt_tx_abort(data);
 80173de: 6af8         	ldr	r0, [r7, #0x2c]
 80173e0: f7f0 feda    	bl	0x8008198 <async_evt_tx_abort> @ imm = #-0xf24c
; 	return 0;
 80173e4: 2300         	movs	r3, #0x0
; }
 80173e6: 4618         	mov	r0, r3
 80173e8: 3730         	adds	r7, #0x30
 80173ea: 46bd         	mov	sp, r7
 80173ec: bd80         	pop	{r7, pc}

080173ee <uart_stm32_init>:
; {
 80173ee: b580         	push	{r7, lr}
 80173f0: b084         	sub	sp, #0x10
 80173f2: af00         	add	r7, sp, #0x0
 80173f4: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80173f6: 687b         	ldr	r3, [r7, #0x4]
 80173f8: 685b         	ldr	r3, [r3, #0x4]
 80173fa: 60fb         	str	r3, [r7, #0xc]
; 	err = uart_stm32_clocks_enable(dev);
 80173fc: 6878         	ldr	r0, [r7, #0x4]
 80173fe: f7f1 fcad    	bl	0x8008d5c <uart_stm32_clocks_enable> @ imm = #-0xe6a6
 8017402: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 8017404: 68bb         	ldr	r3, [r7, #0x8]
 8017406: 2b00         	cmp	r3, #0x0
 8017408: da01         	bge	0x801740e <uart_stm32_init+0x20> @ imm = #0x2
; 		return err;
 801740a: 68bb         	ldr	r3, [r7, #0x8]
 801740c: e01c         	b	0x8017448 <uart_stm32_init+0x5a> @ imm = #0x38
; 	err = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
 801740e: 68fb         	ldr	r3, [r7, #0xc]
 8017410: 6a1b         	ldr	r3, [r3, #0x20]
 8017412: 2100         	movs	r1, #0x0
 8017414: 4618         	mov	r0, r3
 8017416: f7fe fd0a    	bl	0x8015e2e <pinctrl_apply_state> @ imm = #-0x15ec
 801741a: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 801741c: 68bb         	ldr	r3, [r7, #0x8]
 801741e: 2b00         	cmp	r3, #0x0
 8017420: da01         	bge	0x8017426 <uart_stm32_init+0x38> @ imm = #0x2
; 		return err;
 8017422: 68bb         	ldr	r3, [r7, #0x8]
 8017424: e010         	b	0x8017448 <uart_stm32_init+0x5a> @ imm = #0x20
; 	err = uart_stm32_registers_configure(dev);
 8017426: 6878         	ldr	r0, [r7, #0x4]
 8017428: f7f1 fd00    	bl	0x8008e2c <uart_stm32_registers_configure> @ imm = #-0xe600
 801742c: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 801742e: 68bb         	ldr	r3, [r7, #0x8]
 8017430: 2b00         	cmp	r3, #0x0
 8017432: da01         	bge	0x8017438 <uart_stm32_init+0x4a> @ imm = #0x2
; 		return err;
 8017434: 68bb         	ldr	r3, [r7, #0x8]
 8017436: e007         	b	0x8017448 <uart_stm32_init+0x5a> @ imm = #0xe
; 	config->irq_config_func(dev);
 8017438: 68fb         	ldr	r3, [r7, #0xc]
 801743a: 6a5b         	ldr	r3, [r3, #0x24]
 801743c: 6878         	ldr	r0, [r7, #0x4]
 801743e: 4798         	blx	r3
; 	return uart_stm32_async_init(dev);
 8017440: 6878         	ldr	r0, [r7, #0x4]
 8017442: f7f1 fb81    	bl	0x8008b48 <uart_stm32_async_init> @ imm = #-0xe8fe
 8017446: 4603         	mov	r3, r0
; }
 8017448: 4618         	mov	r0, r3
 801744a: 3710         	adds	r7, #0x10
 801744c: 46bd         	mov	sp, r7
 801744e: bd80         	pop	{r7, pc}

08017450 <uart_stm32_irq_config_func_0>:
; DT_INST_FOREACH_STATUS_OKAY(STM32_UART_INIT)
 8017450: b580         	push	{r7, lr}
 8017452: b082         	sub	sp, #0x8
 8017454: af00         	add	r7, sp, #0x0
 8017456: 6078         	str	r0, [r7, #0x4]
 8017458: 2200         	movs	r2, #0x0
 801745a: 2100         	movs	r1, #0x0
 801745c: 2025         	movs	r0, #0x25
 801745e: f7fb fb5b    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x494a
 8017462: 2025         	movs	r0, #0x25
 8017464: f7fb fb4b    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x496a
 8017468: 3708         	adds	r7, #0x8
 801746a: 46bd         	mov	sp, r7
 801746c: bd80         	pop	{r7, pc}

0801746e <uart_stm32_irq_config_func_1>:
 801746e: b580         	push	{r7, lr}
 8017470: b082         	sub	sp, #0x8
 8017472: af00         	add	r7, sp, #0x0
 8017474: 6078         	str	r0, [r7, #0x4]
 8017476: 2200         	movs	r2, #0x0
 8017478: 2100         	movs	r1, #0x0
 801747a: 2047         	movs	r0, #0x47
 801747c: f7fb fb4c    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x4968
 8017480: 2047         	movs	r0, #0x47
 8017482: f7fb fb3c    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x4988
 8017486: 3708         	adds	r7, #0x8
 8017488: 46bd         	mov	sp, r7
 801748a: bd80         	pop	{r7, pc}

0801748c <uart_stm32_irq_config_func_2>:
 801748c: b580         	push	{r7, lr}
 801748e: b082         	sub	sp, #0x8
 8017490: af00         	add	r7, sp, #0x0
 8017492: 6078         	str	r0, [r7, #0x4]
 8017494: 2200         	movs	r2, #0x0
 8017496: 2100         	movs	r1, #0x0
 8017498: 2027         	movs	r0, #0x27
 801749a: f7fb fb3d    	bl	0x8012b18 <z_arm_irq_priority_set> @ imm = #-0x4986
 801749e: 2027         	movs	r0, #0x27
 80174a0: f7fb fb2d    	bl	0x8012afe <arch_irq_enable> @ imm = #-0x49a6
 80174a4: 3708         	adds	r7, #0x8
 80174a6: 46bd         	mov	sp, r7
 80174a8: bd80         	pop	{r7, pc}

080174aa <device_is_ready>:
; {
 80174aa: b580         	push	{r7, lr}
 80174ac: b082         	sub	sp, #0x8
 80174ae: af00         	add	r7, sp, #0x0
 80174b0: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80174b2: 6878         	ldr	r0, [r7, #0x4]
 80174b4: f001 f9bf    	bl	0x8018836 <z_impl_device_is_ready> @ imm = #0x137e
 80174b8: 4603         	mov	r3, r0
; }
 80174ba: 4618         	mov	r0, r3
 80174bc: 3708         	adds	r7, #0x8
 80174be: 46bd         	mov	sp, r7
 80174c0: bd80         	pop	{r7, pc}

080174c2 <z_log_msg_runtime_create>:
; {
 80174c2: b580         	push	{r7, lr}
 80174c4: b08a         	sub	sp, #0x28
 80174c6: af04         	add	r7, sp, #0x10
 80174c8: 60b9         	str	r1, [r7, #0x8]
 80174ca: 607b         	str	r3, [r7, #0x4]
 80174cc: 4603         	mov	r3, r0
 80174ce: 73fb         	strb	r3, [r7, #0xf]
 80174d0: 4613         	mov	r3, r2
 80174d2: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80174d4: f107 032c    	add.w	r3, r7, #0x2c
 80174d8: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80174da: 7bba         	ldrb	r2, [r7, #0xe]
 80174dc: 7bf8         	ldrb	r0, [r7, #0xf]
 80174de: 697b         	ldr	r3, [r7, #0x14]
 80174e0: 9303         	str	r3, [sp, #0xc]
 80174e2: 6abb         	ldr	r3, [r7, #0x28]
 80174e4: 9302         	str	r3, [sp, #0x8]
 80174e6: 6a7b         	ldr	r3, [r7, #0x24]
 80174e8: 9301         	str	r3, [sp, #0x4]
 80174ea: 6a3b         	ldr	r3, [r7, #0x20]
 80174ec: 9300         	str	r3, [sp]
 80174ee: 687b         	ldr	r3, [r7, #0x4]
 80174f0: 68b9         	ldr	r1, [r7, #0x8]
 80174f2: f7ea fbbb    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x1588a
; }
 80174f6: bf00         	nop
 80174f8: 3718         	adds	r7, #0x18
 80174fa: 46bd         	mov	sp, r7
 80174fc: bd80         	pop	{r7, pc}

080174fe <z_impl_k_sem_count_get>:
; {
 80174fe: b480         	push	{r7}
 8017500: b083         	sub	sp, #0xc
 8017502: af00         	add	r7, sp, #0x0
 8017504: 6078         	str	r0, [r7, #0x4]
; 	return sem->count;
 8017506: 687b         	ldr	r3, [r7, #0x4]
 8017508: 689b         	ldr	r3, [r3, #0x8]
; }
 801750a: 4618         	mov	r0, r3
 801750c: 370c         	adds	r7, #0xc
 801750e: 46bd         	mov	sp, r7
 8017510: bc80         	pop	{r7}
 8017512: 4770         	bx	lr

08017514 <k_busy_wait>:
; {
 8017514: b580         	push	{r7, lr}
 8017516: b082         	sub	sp, #0x8
 8017518: af00         	add	r7, sp, #0x0
 801751a: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_busy_wait(usec_to_wait);
 801751c: 6878         	ldr	r0, [r7, #0x4]
 801751e: f001 f962    	bl	0x80187e6 <z_impl_k_busy_wait> @ imm = #0x12c4
; }
 8017522: bf00         	nop
 8017524: 3708         	adds	r7, #0x8
 8017526: 46bd         	mov	sp, r7
 8017528: bd80         	pop	{r7, pc}

0801752a <k_sem_take>:
; {
 801752a: b580         	push	{r7, lr}
 801752c: b084         	sub	sp, #0x10
 801752e: af00         	add	r7, sp, #0x0
 8017530: 60f8         	str	r0, [r7, #0xc]
 8017532: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 8017536: e9d7 2300    	ldrd	r2, r3, [r7]
 801753a: 68f8         	ldr	r0, [r7, #0xc]
 801753c: f7f5 fcd2    	bl	0x800cee4 <z_impl_k_sem_take> @ imm = #-0xa65c
 8017540: 4603         	mov	r3, r0
; }
 8017542: 4618         	mov	r0, r3
 8017544: 3710         	adds	r7, #0x10
 8017546: 46bd         	mov	sp, r7
 8017548: bd80         	pop	{r7, pc}

0801754a <k_sem_give>:
; {
 801754a: b580         	push	{r7, lr}
 801754c: b082         	sub	sp, #0x8
 801754e: af00         	add	r7, sp, #0x0
 8017550: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 8017552: 6878         	ldr	r0, [r7, #0x4]
 8017554: f7f5 fc38    	bl	0x800cdc8 <z_impl_k_sem_give> @ imm = #-0xa790
; }
 8017558: bf00         	nop
 801755a: 3708         	adds	r7, #0x8
 801755c: 46bd         	mov	sp, r7
 801755e: bd80         	pop	{r7, pc}

08017560 <k_sem_count_get>:
; {
 8017560: b580         	push	{r7, lr}
 8017562: b082         	sub	sp, #0x8
 8017564: af00         	add	r7, sp, #0x0
 8017566: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_sem_count_get(sem);
 8017568: 6878         	ldr	r0, [r7, #0x4]
 801756a: f7ff ffc8    	bl	0x80174fe <z_impl_k_sem_count_get> @ imm = #-0x70
 801756e: 4603         	mov	r3, r0
; }
 8017570: 4618         	mov	r0, r3
 8017572: 3708         	adds	r7, #0x8
 8017574: 46bd         	mov	sp, r7
 8017576: bd80         	pop	{r7, pc}

08017578 <LL_SPI_Enable>:
; {
 8017578: b480         	push	{r7}
 801757a: b083         	sub	sp, #0xc
 801757c: af00         	add	r7, sp, #0x0
 801757e: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(SPIx->CR1, SPI_CR1_SPE);
 8017580: 687b         	ldr	r3, [r7, #0x4]
 8017582: 681b         	ldr	r3, [r3]
 8017584: f043 0240    	orr	r2, r3, #0x40
 8017588: 687b         	ldr	r3, [r7, #0x4]
 801758a: 601a         	str	r2, [r3]
; }
 801758c: bf00         	nop
 801758e: 370c         	adds	r7, #0xc
 8017590: 46bd         	mov	sp, r7
 8017592: bc80         	pop	{r7}
 8017594: 4770         	bx	lr

08017596 <LL_SPI_Disable>:
; {
 8017596: b480         	push	{r7}
 8017598: b083         	sub	sp, #0xc
 801759a: af00         	add	r7, sp, #0x0
 801759c: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 801759e: 687b         	ldr	r3, [r7, #0x4]
 80175a0: 681b         	ldr	r3, [r3]
 80175a2: f023 0240    	bic	r2, r3, #0x40
 80175a6: 687b         	ldr	r3, [r7, #0x4]
 80175a8: 601a         	str	r2, [r3]
; }
 80175aa: bf00         	nop
 80175ac: 370c         	adds	r7, #0xc
 80175ae: 46bd         	mov	sp, r7
 80175b0: bc80         	pop	{r7}
 80175b2: 4770         	bx	lr

080175b4 <LL_SPI_IsEnabled>:
; {
 80175b4: b480         	push	{r7}
 80175b6: b083         	sub	sp, #0xc
 80175b8: af00         	add	r7, sp, #0x0
 80175ba: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->CR1, SPI_CR1_SPE) == (SPI_CR1_SPE)) ? 1UL : 0UL);
 80175bc: 687b         	ldr	r3, [r7, #0x4]
 80175be: 681b         	ldr	r3, [r3]
 80175c0: f003 0340    	and	r3, r3, #0x40
 80175c4: 2b40         	cmp	r3, #0x40
 80175c6: d101         	bne	0x80175cc <LL_SPI_IsEnabled+0x18> @ imm = #0x2
 80175c8: 2301         	movs	r3, #0x1
 80175ca: e000         	b	0x80175ce <LL_SPI_IsEnabled+0x1a> @ imm = #0x0
 80175cc: 2300         	movs	r3, #0x0
; }
 80175ce: 4618         	mov	r0, r3
 80175d0: 370c         	adds	r7, #0xc
 80175d2: 46bd         	mov	sp, r7
 80175d4: bc80         	pop	{r7}
 80175d6: 4770         	bx	lr

080175d8 <LL_SPI_SetMode>:
; {
 80175d8: b480         	push	{r7}
 80175da: b083         	sub	sp, #0xc
 80175dc: af00         	add	r7, sp, #0x0
 80175de: 6078         	str	r0, [r7, #0x4]
 80175e0: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI, Mode);
 80175e2: 687b         	ldr	r3, [r7, #0x4]
 80175e4: 681b         	ldr	r3, [r3]
 80175e6: f423 7282    	bic	r2, r3, #0x104
 80175ea: 683b         	ldr	r3, [r7]
 80175ec: 431a         	orrs	r2, r3
 80175ee: 687b         	ldr	r3, [r7, #0x4]
 80175f0: 601a         	str	r2, [r3]
; }
 80175f2: bf00         	nop
 80175f4: 370c         	adds	r7, #0xc
 80175f6: 46bd         	mov	sp, r7
 80175f8: bc80         	pop	{r7}
 80175fa: 4770         	bx	lr

080175fc <LL_SPI_GetMode>:
; {
 80175fc: b480         	push	{r7}
 80175fe: b083         	sub	sp, #0xc
 8017600: af00         	add	r7, sp, #0x0
 8017602: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI));
 8017604: 687b         	ldr	r3, [r7, #0x4]
 8017606: 681b         	ldr	r3, [r3]
 8017608: f403 7382    	and	r3, r3, #0x104
; }
 801760c: 4618         	mov	r0, r3
 801760e: 370c         	adds	r7, #0xc
 8017610: 46bd         	mov	sp, r7
 8017612: bc80         	pop	{r7}
 8017614: 4770         	bx	lr

08017616 <LL_SPI_SetStandard>:
; {
 8017616: b480         	push	{r7}
 8017618: b083         	sub	sp, #0xc
 801761a: af00         	add	r7, sp, #0x0
 801761c: 6078         	str	r0, [r7, #0x4]
 801761e: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR2, SPI_CR2_FRF, Standard);
 8017620: 687b         	ldr	r3, [r7, #0x4]
 8017622: 685b         	ldr	r3, [r3, #0x4]
 8017624: f023 0210    	bic	r2, r3, #0x10
 8017628: 683b         	ldr	r3, [r7]
 801762a: 431a         	orrs	r2, r3
 801762c: 687b         	ldr	r3, [r7, #0x4]
 801762e: 605a         	str	r2, [r3, #0x4]
; }
 8017630: bf00         	nop
 8017632: 370c         	adds	r7, #0xc
 8017634: 46bd         	mov	sp, r7
 8017636: bc80         	pop	{r7}
 8017638: 4770         	bx	lr

0801763a <LL_SPI_SetClockPhase>:
; {
 801763a: b480         	push	{r7}
 801763c: b083         	sub	sp, #0xc
 801763e: af00         	add	r7, sp, #0x0
 8017640: 6078         	str	r0, [r7, #0x4]
 8017642: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_CPHA, ClockPhase);
 8017644: 687b         	ldr	r3, [r7, #0x4]
 8017646: 681b         	ldr	r3, [r3]
 8017648: f023 0201    	bic	r2, r3, #0x1
 801764c: 683b         	ldr	r3, [r7]
 801764e: 431a         	orrs	r2, r3
 8017650: 687b         	ldr	r3, [r7, #0x4]
 8017652: 601a         	str	r2, [r3]
; }
 8017654: bf00         	nop
 8017656: 370c         	adds	r7, #0xc
 8017658: 46bd         	mov	sp, r7
 801765a: bc80         	pop	{r7}
 801765c: 4770         	bx	lr

0801765e <LL_SPI_SetClockPolarity>:
; {
 801765e: b480         	push	{r7}
 8017660: b083         	sub	sp, #0xc
 8017662: af00         	add	r7, sp, #0x0
 8017664: 6078         	str	r0, [r7, #0x4]
 8017666: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_CPOL, ClockPolarity);
 8017668: 687b         	ldr	r3, [r7, #0x4]
 801766a: 681b         	ldr	r3, [r3]
 801766c: f023 0202    	bic	r2, r3, #0x2
 8017670: 683b         	ldr	r3, [r7]
 8017672: 431a         	orrs	r2, r3
 8017674: 687b         	ldr	r3, [r7, #0x4]
 8017676: 601a         	str	r2, [r3]
; }
 8017678: bf00         	nop
 801767a: 370c         	adds	r7, #0xc
 801767c: 46bd         	mov	sp, r7
 801767e: bc80         	pop	{r7}
 8017680: 4770         	bx	lr

08017682 <LL_SPI_SetBaudRatePrescaler>:
; {
 8017682: b480         	push	{r7}
 8017684: b083         	sub	sp, #0xc
 8017686: af00         	add	r7, sp, #0x0
 8017688: 6078         	str	r0, [r7, #0x4]
 801768a: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_BR, BaudRate);
 801768c: 687b         	ldr	r3, [r7, #0x4]
 801768e: 681b         	ldr	r3, [r3]
 8017690: f023 0238    	bic	r2, r3, #0x38
 8017694: 683b         	ldr	r3, [r7]
 8017696: 431a         	orrs	r2, r3
 8017698: 687b         	ldr	r3, [r7, #0x4]
 801769a: 601a         	str	r2, [r3]
; }
 801769c: bf00         	nop
 801769e: 370c         	adds	r7, #0xc
 80176a0: 46bd         	mov	sp, r7
 80176a2: bc80         	pop	{r7}
 80176a4: 4770         	bx	lr

080176a6 <LL_SPI_SetTransferBitOrder>:
; {
 80176a6: b480         	push	{r7}
 80176a8: b083         	sub	sp, #0xc
 80176aa: af00         	add	r7, sp, #0x0
 80176ac: 6078         	str	r0, [r7, #0x4]
 80176ae: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_LSBFIRST, BitOrder);
 80176b0: 687b         	ldr	r3, [r7, #0x4]
 80176b2: 681b         	ldr	r3, [r3]
 80176b4: f023 0280    	bic	r2, r3, #0x80
 80176b8: 683b         	ldr	r3, [r7]
 80176ba: 431a         	orrs	r2, r3
 80176bc: 687b         	ldr	r3, [r7, #0x4]
 80176be: 601a         	str	r2, [r3]
; }
 80176c0: bf00         	nop
 80176c2: 370c         	adds	r7, #0xc
 80176c4: 46bd         	mov	sp, r7
 80176c6: bc80         	pop	{r7}
 80176c8: 4770         	bx	lr

080176ca <LL_SPI_SetTransferDirection>:
; {
 80176ca: b480         	push	{r7}
 80176cc: b083         	sub	sp, #0xc
 80176ce: af00         	add	r7, sp, #0x0
 80176d0: 6078         	str	r0, [r7, #0x4]
 80176d2: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_RXONLY | SPI_CR1_BIDIMODE | SPI_CR1_BIDIOE, TransferDirection);
 80176d4: 687b         	ldr	r3, [r7, #0x4]
 80176d6: 681b         	ldr	r3, [r3]
 80176d8: f423 4244    	bic	r2, r3, #0xc400
 80176dc: 683b         	ldr	r3, [r7]
 80176de: 431a         	orrs	r2, r3
 80176e0: 687b         	ldr	r3, [r7, #0x4]
 80176e2: 601a         	str	r2, [r3]
; }
 80176e4: bf00         	nop
 80176e6: 370c         	adds	r7, #0xc
 80176e8: 46bd         	mov	sp, r7
 80176ea: bc80         	pop	{r7}
 80176ec: 4770         	bx	lr

080176ee <LL_SPI_SetDataWidth>:
; {
 80176ee: b480         	push	{r7}
 80176f0: b083         	sub	sp, #0xc
 80176f2: af00         	add	r7, sp, #0x0
 80176f4: 6078         	str	r0, [r7, #0x4]
 80176f6: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_DFF, DataWidth);
 80176f8: 687b         	ldr	r3, [r7, #0x4]
 80176fa: 681b         	ldr	r3, [r3]
 80176fc: f423 6200    	bic	r2, r3, #0x800
 8017700: 683b         	ldr	r3, [r7]
 8017702: 431a         	orrs	r2, r3
 8017704: 687b         	ldr	r3, [r7, #0x4]
 8017706: 601a         	str	r2, [r3]
; }
 8017708: bf00         	nop
 801770a: 370c         	adds	r7, #0xc
 801770c: 46bd         	mov	sp, r7
 801770e: bc80         	pop	{r7}
 8017710: 4770         	bx	lr

08017712 <LL_SPI_DisableCRC>:
; {
 8017712: b480         	push	{r7}
 8017714: b083         	sub	sp, #0xc
 8017716: af00         	add	r7, sp, #0x0
 8017718: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_CRCEN);
 801771a: 687b         	ldr	r3, [r7, #0x4]
 801771c: 681b         	ldr	r3, [r3]
 801771e: f423 5200    	bic	r2, r3, #0x2000
 8017722: 687b         	ldr	r3, [r7, #0x4]
 8017724: 601a         	str	r2, [r3]
; }
 8017726: bf00         	nop
 8017728: 370c         	adds	r7, #0xc
 801772a: 46bd         	mov	sp, r7
 801772c: bc80         	pop	{r7}
 801772e: 4770         	bx	lr

08017730 <LL_SPI_SetNSSMode>:
; {
 8017730: b480         	push	{r7}
 8017732: b083         	sub	sp, #0xc
 8017734: af00         	add	r7, sp, #0x0
 8017736: 6078         	str	r0, [r7, #0x4]
 8017738: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_SSM,  NSS);
 801773a: 687b         	ldr	r3, [r7, #0x4]
 801773c: 681b         	ldr	r3, [r3]
 801773e: f423 7200    	bic	r2, r3, #0x200
 8017742: 683b         	ldr	r3, [r7]
 8017744: 431a         	orrs	r2, r3
 8017746: 687b         	ldr	r3, [r7, #0x4]
 8017748: 601a         	str	r2, [r3]
;   MODIFY_REG(SPIx->CR2, SPI_CR2_SSOE, ((uint32_t)(NSS >> 16U)));
 801774a: 687b         	ldr	r3, [r7, #0x4]
 801774c: 685b         	ldr	r3, [r3, #0x4]
 801774e: f023 0204    	bic	r2, r3, #0x4
 8017752: 683b         	ldr	r3, [r7]
 8017754: 0c1b         	lsrs	r3, r3, #0x10
 8017756: 431a         	orrs	r2, r3
 8017758: 687b         	ldr	r3, [r7, #0x4]
 801775a: 605a         	str	r2, [r3, #0x4]
; }
 801775c: bf00         	nop
 801775e: 370c         	adds	r7, #0xc
 8017760: 46bd         	mov	sp, r7
 8017762: bc80         	pop	{r7}
 8017764: 4770         	bx	lr

08017766 <LL_SPI_IsActiveFlag_RXNE>:
; {
 8017766: b480         	push	{r7}
 8017768: b083         	sub	sp, #0xc
 801776a: af00         	add	r7, sp, #0x0
 801776c: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_RXNE) == (SPI_SR_RXNE)) ? 1UL : 0UL);
 801776e: 687b         	ldr	r3, [r7, #0x4]
 8017770: 689b         	ldr	r3, [r3, #0x8]
 8017772: f003 0301    	and	r3, r3, #0x1
 8017776: 2b01         	cmp	r3, #0x1
 8017778: d101         	bne	0x801777e <LL_SPI_IsActiveFlag_RXNE+0x18> @ imm = #0x2
 801777a: 2301         	movs	r3, #0x1
 801777c: e000         	b	0x8017780 <LL_SPI_IsActiveFlag_RXNE+0x1a> @ imm = #0x0
 801777e: 2300         	movs	r3, #0x0
; }
 8017780: 4618         	mov	r0, r3
 8017782: 370c         	adds	r7, #0xc
 8017784: 46bd         	mov	sp, r7
 8017786: bc80         	pop	{r7}
 8017788: 4770         	bx	lr

0801778a <LL_SPI_IsActiveFlag_TXE>:
; {
 801778a: b480         	push	{r7}
 801778c: b083         	sub	sp, #0xc
 801778e: af00         	add	r7, sp, #0x0
 8017790: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_TXE) == (SPI_SR_TXE)) ? 1UL : 0UL);
 8017792: 687b         	ldr	r3, [r7, #0x4]
 8017794: 689b         	ldr	r3, [r3, #0x8]
 8017796: f003 0302    	and	r3, r3, #0x2
 801779a: 2b02         	cmp	r3, #0x2
 801779c: d101         	bne	0x80177a2 <LL_SPI_IsActiveFlag_TXE+0x18> @ imm = #0x2
 801779e: 2301         	movs	r3, #0x1
 80177a0: e000         	b	0x80177a4 <LL_SPI_IsActiveFlag_TXE+0x1a> @ imm = #0x0
 80177a2: 2300         	movs	r3, #0x0
; }
 80177a4: 4618         	mov	r0, r3
 80177a6: 370c         	adds	r7, #0xc
 80177a8: 46bd         	mov	sp, r7
 80177aa: bc80         	pop	{r7}
 80177ac: 4770         	bx	lr

080177ae <LL_SPI_IsActiveFlag_MODF>:
; {
 80177ae: b480         	push	{r7}
 80177b0: b083         	sub	sp, #0xc
 80177b2: af00         	add	r7, sp, #0x0
 80177b4: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_MODF) == (SPI_SR_MODF)) ? 1UL : 0UL);
 80177b6: 687b         	ldr	r3, [r7, #0x4]
 80177b8: 689b         	ldr	r3, [r3, #0x8]
 80177ba: f003 0320    	and	r3, r3, #0x20
 80177be: 2b20         	cmp	r3, #0x20
 80177c0: d101         	bne	0x80177c6 <LL_SPI_IsActiveFlag_MODF+0x18> @ imm = #0x2
 80177c2: 2301         	movs	r3, #0x1
 80177c4: e000         	b	0x80177c8 <LL_SPI_IsActiveFlag_MODF+0x1a> @ imm = #0x0
 80177c6: 2300         	movs	r3, #0x0
; }
 80177c8: 4618         	mov	r0, r3
 80177ca: 370c         	adds	r7, #0xc
 80177cc: 46bd         	mov	sp, r7
 80177ce: bc80         	pop	{r7}
 80177d0: 4770         	bx	lr

080177d2 <LL_SPI_IsActiveFlag_OVR>:
; {
 80177d2: b480         	push	{r7}
 80177d4: b083         	sub	sp, #0xc
 80177d6: af00         	add	r7, sp, #0x0
 80177d8: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_OVR) == (SPI_SR_OVR)) ? 1UL : 0UL);
 80177da: 687b         	ldr	r3, [r7, #0x4]
 80177dc: 689b         	ldr	r3, [r3, #0x8]
 80177de: f003 0340    	and	r3, r3, #0x40
 80177e2: 2b40         	cmp	r3, #0x40
 80177e4: d101         	bne	0x80177ea <LL_SPI_IsActiveFlag_OVR+0x18> @ imm = #0x2
 80177e6: 2301         	movs	r3, #0x1
 80177e8: e000         	b	0x80177ec <LL_SPI_IsActiveFlag_OVR+0x1a> @ imm = #0x0
 80177ea: 2300         	movs	r3, #0x0
; }
 80177ec: 4618         	mov	r0, r3
 80177ee: 370c         	adds	r7, #0xc
 80177f0: 46bd         	mov	sp, r7
 80177f2: bc80         	pop	{r7}
 80177f4: 4770         	bx	lr

080177f6 <LL_SPI_IsActiveFlag_BSY>:
; {
 80177f6: b480         	push	{r7}
 80177f8: b083         	sub	sp, #0xc
 80177fa: af00         	add	r7, sp, #0x0
 80177fc: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_BSY) == (SPI_SR_BSY)) ? 1UL : 0UL);
 80177fe: 687b         	ldr	r3, [r7, #0x4]
 8017800: 689b         	ldr	r3, [r3, #0x8]
 8017802: f003 0380    	and	r3, r3, #0x80
 8017806: 2b80         	cmp	r3, #0x80
 8017808: d101         	bne	0x801780e <LL_SPI_IsActiveFlag_BSY+0x18> @ imm = #0x2
 801780a: 2301         	movs	r3, #0x1
 801780c: e000         	b	0x8017810 <LL_SPI_IsActiveFlag_BSY+0x1a> @ imm = #0x0
 801780e: 2300         	movs	r3, #0x0
; }
 8017810: 4618         	mov	r0, r3
 8017812: 370c         	adds	r7, #0xc
 8017814: 46bd         	mov	sp, r7
 8017816: bc80         	pop	{r7}
 8017818: 4770         	bx	lr

0801781a <LL_SPI_ClearFlag_MODF>:
; {
 801781a: b480         	push	{r7}
 801781c: b085         	sub	sp, #0x14
 801781e: af00         	add	r7, sp, #0x0
 8017820: 6078         	str	r0, [r7, #0x4]
;   tmpreg_sr = SPIx->SR;
 8017822: 687b         	ldr	r3, [r7, #0x4]
 8017824: 689b         	ldr	r3, [r3, #0x8]
 8017826: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg_sr;
 8017828: 68fb         	ldr	r3, [r7, #0xc]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 801782a: 687b         	ldr	r3, [r7, #0x4]
 801782c: 681b         	ldr	r3, [r3]
 801782e: f023 0240    	bic	r2, r3, #0x40
 8017832: 687b         	ldr	r3, [r7, #0x4]
 8017834: 601a         	str	r2, [r3]
; }
 8017836: bf00         	nop
 8017838: 3714         	adds	r7, #0x14
 801783a: 46bd         	mov	sp, r7
 801783c: bc80         	pop	{r7}
 801783e: 4770         	bx	lr

08017840 <LL_SPI_ClearFlag_OVR>:
; {
 8017840: b480         	push	{r7}
 8017842: b085         	sub	sp, #0x14
 8017844: af00         	add	r7, sp, #0x0
 8017846: 6078         	str	r0, [r7, #0x4]
;   tmpreg = SPIx->DR;
 8017848: 687b         	ldr	r3, [r7, #0x4]
 801784a: 68db         	ldr	r3, [r3, #0xc]
 801784c: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801784e: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = SPIx->SR;
 8017850: 687b         	ldr	r3, [r7, #0x4]
 8017852: 689b         	ldr	r3, [r3, #0x8]
 8017854: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8017856: 68fb         	ldr	r3, [r7, #0xc]
; }
 8017858: bf00         	nop
 801785a: 3714         	adds	r7, #0x14
 801785c: 46bd         	mov	sp, r7
 801785e: bc80         	pop	{r7}
 8017860: 4770         	bx	lr

08017862 <LL_SPI_DisableIT_TXE>:
; {
 8017862: b480         	push	{r7}
 8017864: b083         	sub	sp, #0xc
 8017866: af00         	add	r7, sp, #0x0
 8017868: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR2, SPI_CR2_TXEIE);
 801786a: 687b         	ldr	r3, [r7, #0x4]
 801786c: 685b         	ldr	r3, [r3, #0x4]
 801786e: f023 0280    	bic	r2, r3, #0x80
 8017872: 687b         	ldr	r3, [r7, #0x4]
 8017874: 605a         	str	r2, [r3, #0x4]
; }
 8017876: bf00         	nop
 8017878: 370c         	adds	r7, #0xc
 801787a: 46bd         	mov	sp, r7
 801787c: bc80         	pop	{r7}
 801787e: 4770         	bx	lr

08017880 <LL_SPI_ReceiveData8>:
; {
 8017880: b480         	push	{r7}
 8017882: b083         	sub	sp, #0xc
 8017884: af00         	add	r7, sp, #0x0
 8017886: 6078         	str	r0, [r7, #0x4]
;   return (*((__IO uint8_t *)&SPIx->DR));
 8017888: 687b         	ldr	r3, [r7, #0x4]
 801788a: 330c         	adds	r3, #0xc
 801788c: 781b         	ldrb	r3, [r3]
 801788e: b2db         	uxtb	r3, r3
; }
 8017890: 4618         	mov	r0, r3
 8017892: 370c         	adds	r7, #0xc
 8017894: 46bd         	mov	sp, r7
 8017896: bc80         	pop	{r7}
 8017898: 4770         	bx	lr

0801789a <LL_SPI_ReceiveData16>:
; {
 801789a: b480         	push	{r7}
 801789c: b083         	sub	sp, #0xc
 801789e: af00         	add	r7, sp, #0x0
 80178a0: 6078         	str	r0, [r7, #0x4]
;   return (uint16_t)(READ_REG(SPIx->DR));
 80178a2: 687b         	ldr	r3, [r7, #0x4]
 80178a4: 68db         	ldr	r3, [r3, #0xc]
 80178a6: b29b         	uxth	r3, r3
; }
 80178a8: 4618         	mov	r0, r3
 80178aa: 370c         	adds	r7, #0xc
 80178ac: 46bd         	mov	sp, r7
 80178ae: bc80         	pop	{r7}
 80178b0: 4770         	bx	lr

080178b2 <LL_SPI_TransmitData8>:
; {
 80178b2: b480         	push	{r7}
 80178b4: b085         	sub	sp, #0x14
 80178b6: af00         	add	r7, sp, #0x0
 80178b8: 6078         	str	r0, [r7, #0x4]
 80178ba: 460b         	mov	r3, r1
 80178bc: 70fb         	strb	r3, [r7, #0x3]
;   __IO uint8_t *spidr = ((__IO uint8_t *)&SPIx->DR);
 80178be: 687b         	ldr	r3, [r7, #0x4]
 80178c0: 330c         	adds	r3, #0xc
 80178c2: 60fb         	str	r3, [r7, #0xc]
;   *spidr = TxData;
 80178c4: 68fb         	ldr	r3, [r7, #0xc]
 80178c6: 78fa         	ldrb	r2, [r7, #0x3]
 80178c8: 701a         	strb	r2, [r3]
; }
 80178ca: bf00         	nop
 80178cc: 3714         	adds	r7, #0x14
 80178ce: 46bd         	mov	sp, r7
 80178d0: bc80         	pop	{r7}
 80178d2: 4770         	bx	lr

080178d4 <LL_SPI_TransmitData16>:
; {
 80178d4: b480         	push	{r7}
 80178d6: b085         	sub	sp, #0x14
 80178d8: af00         	add	r7, sp, #0x0
 80178da: 6078         	str	r0, [r7, #0x4]
 80178dc: 460b         	mov	r3, r1
 80178de: 807b         	strh	r3, [r7, #0x2]
;   __IO uint16_t *spidr = ((__IO uint16_t *)&SPIx->DR);
 80178e0: 687b         	ldr	r3, [r7, #0x4]
 80178e2: 330c         	adds	r3, #0xc
 80178e4: 60fb         	str	r3, [r7, #0xc]
;   *spidr = TxData;
 80178e6: 68fb         	ldr	r3, [r7, #0xc]
 80178e8: 887a         	ldrh	r2, [r7, #0x2]
 80178ea: 801a         	strh	r2, [r3]
; }
 80178ec: bf00         	nop
 80178ee: 3714         	adds	r7, #0x14
 80178f0: 46bd         	mov	sp, r7
 80178f2: bc80         	pop	{r7}
 80178f4: 4770         	bx	lr

080178f6 <z_impl_gpio_pin_configure>:
; {
 80178f6: b580         	push	{r7, lr}
 80178f8: b088         	sub	sp, #0x20
 80178fa: af00         	add	r7, sp, #0x0
 80178fc: 60f8         	str	r0, [r7, #0xc]
 80178fe: 460b         	mov	r3, r1
 8017900: 607a         	str	r2, [r7, #0x4]
 8017902: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 8017904: 68fb         	ldr	r3, [r7, #0xc]
 8017906: 689b         	ldr	r3, [r3, #0x8]
 8017908: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 801790a: 68fb         	ldr	r3, [r7, #0xc]
 801790c: 685b         	ldr	r3, [r3, #0x4]
 801790e: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 8017910: 68fb         	ldr	r3, [r7, #0xc]
 8017912: 691b         	ldr	r3, [r3, #0x10]
 8017914: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 8017916: 687b         	ldr	r3, [r7, #0x4]
 8017918: f403 1380    	and	r3, r3, #0x100000
 801791c: 2b00         	cmp	r3, #0x0
 801791e: d00d         	beq	0x801793c <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 8017920: 687b         	ldr	r3, [r7, #0x4]
 8017922: f403 2340    	and	r3, r3, #0xc0000
 8017926: 2b00         	cmp	r3, #0x0
 8017928: d008         	beq	0x801793c <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 801792a: 687b         	ldr	r3, [r7, #0x4]
 801792c: f003 0301    	and	r3, r3, #0x1
 8017930: 2b00         	cmp	r3, #0x0
 8017932: d003         	beq	0x801793c <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 8017934: 687b         	ldr	r3, [r7, #0x4]
 8017936: f483 2340    	eor	r3, r3, #0xc0000
 801793a: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 801793c: 687b         	ldr	r3, [r7, #0x4]
 801793e: f423 1380    	bic	r3, r3, #0x100000
 8017942: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 8017944: 687b         	ldr	r3, [r7, #0x4]
 8017946: f003 0301    	and	r3, r3, #0x1
 801794a: 2b00         	cmp	r3, #0x0
 801794c: d009         	beq	0x8017962 <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 801794e: 697b         	ldr	r3, [r7, #0x14]
 8017950: 681a         	ldr	r2, [r3]
 8017952: 7afb         	ldrb	r3, [r7, #0xb]
 8017954: 2101         	movs	r1, #0x1
 8017956: fa01 f303    	lsl.w	r3, r1, r3
 801795a: 431a         	orrs	r2, r3
 801795c: 697b         	ldr	r3, [r7, #0x14]
 801795e: 601a         	str	r2, [r3]
 8017960: e009         	b	0x8017976 <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 8017962: 697b         	ldr	r3, [r7, #0x14]
 8017964: 681a         	ldr	r2, [r3]
 8017966: 7afb         	ldrb	r3, [r7, #0xb]
 8017968: 2101         	movs	r1, #0x1
 801796a: fa01 f303    	lsl.w	r3, r1, r3
 801796e: 43db         	mvns	r3, r3
 8017970: 401a         	ands	r2, r3
 8017972: 697b         	ldr	r3, [r7, #0x14]
 8017974: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 8017976: 69fb         	ldr	r3, [r7, #0x1c]
 8017978: 681b         	ldr	r3, [r3]
 801797a: 7af9         	ldrb	r1, [r7, #0xb]
 801797c: 687a         	ldr	r2, [r7, #0x4]
 801797e: 68f8         	ldr	r0, [r7, #0xc]
 8017980: 4798         	blx	r3
 8017982: 4603         	mov	r3, r0
; }
 8017984: 4618         	mov	r0, r3
 8017986: 3720         	adds	r7, #0x20
 8017988: 46bd         	mov	sp, r7
 801798a: bd80         	pop	{r7, pc}

0801798c <gpio_pin_configure_dt>:
; {
 801798c: b580         	push	{r7, lr}
 801798e: b082         	sub	sp, #0x8
 8017990: af00         	add	r7, sp, #0x0
 8017992: 6078         	str	r0, [r7, #0x4]
 8017994: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 8017996: 687b         	ldr	r3, [r7, #0x4]
 8017998: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 801799a: 687b         	ldr	r3, [r7, #0x4]
 801799c: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 801799e: 687b         	ldr	r3, [r7, #0x4]
 80179a0: 88db         	ldrh	r3, [r3, #0x6]
 80179a2: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 80179a4: 683b         	ldr	r3, [r7]
 80179a6: 4313         	orrs	r3, r2
 80179a8: 461a         	mov	r2, r3
 80179aa: f000 f888    	bl	0x8017abe <gpio_pin_configure> @ imm = #0x110
 80179ae: 4603         	mov	r3, r0
; }
 80179b0: 4618         	mov	r0, r3
 80179b2: 3708         	adds	r7, #0x8
 80179b4: 46bd         	mov	sp, r7
 80179b6: bd80         	pop	{r7, pc}

080179b8 <z_impl_gpio_port_set_bits_raw>:
; {
 80179b8: b580         	push	{r7, lr}
 80179ba: b084         	sub	sp, #0x10
 80179bc: af00         	add	r7, sp, #0x0
 80179be: 6078         	str	r0, [r7, #0x4]
 80179c0: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 80179c2: 687b         	ldr	r3, [r7, #0x4]
 80179c4: 689b         	ldr	r3, [r3, #0x8]
 80179c6: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_set_bits_raw(port, pins);
 80179c8: 68fb         	ldr	r3, [r7, #0xc]
 80179ca: 68db         	ldr	r3, [r3, #0xc]
 80179cc: 6839         	ldr	r1, [r7]
 80179ce: 6878         	ldr	r0, [r7, #0x4]
 80179d0: 4798         	blx	r3
 80179d2: 4603         	mov	r3, r0
; }
 80179d4: 4618         	mov	r0, r3
 80179d6: 3710         	adds	r7, #0x10
 80179d8: 46bd         	mov	sp, r7
 80179da: bd80         	pop	{r7, pc}

080179dc <z_impl_gpio_port_clear_bits_raw>:
; {
 80179dc: b580         	push	{r7, lr}
 80179de: b084         	sub	sp, #0x10
 80179e0: af00         	add	r7, sp, #0x0
 80179e2: 6078         	str	r0, [r7, #0x4]
 80179e4: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 80179e6: 687b         	ldr	r3, [r7, #0x4]
 80179e8: 689b         	ldr	r3, [r3, #0x8]
 80179ea: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_clear_bits_raw(port, pins);
 80179ec: 68fb         	ldr	r3, [r7, #0xc]
 80179ee: 691b         	ldr	r3, [r3, #0x10]
 80179f0: 6839         	ldr	r1, [r7]
 80179f2: 6878         	ldr	r0, [r7, #0x4]
 80179f4: 4798         	blx	r3
 80179f6: 4603         	mov	r3, r0
; }
 80179f8: 4618         	mov	r0, r3
 80179fa: 3710         	adds	r7, #0x10
 80179fc: 46bd         	mov	sp, r7
 80179fe: bd80         	pop	{r7, pc}

08017a00 <gpio_pin_set_raw>:
; {
 8017a00: b580         	push	{r7, lr}
 8017a02: b086         	sub	sp, #0x18
 8017a04: af00         	add	r7, sp, #0x0
 8017a06: 60f8         	str	r0, [r7, #0xc]
 8017a08: 460b         	mov	r3, r1
 8017a0a: 607a         	str	r2, [r7, #0x4]
 8017a0c: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 8017a0e: 68fb         	ldr	r3, [r7, #0xc]
 8017a10: 685b         	ldr	r3, [r3, #0x4]
 8017a12: 613b         	str	r3, [r7, #0x10]
; 	if (value != 0)	{
 8017a14: 687b         	ldr	r3, [r7, #0x4]
 8017a16: 2b00         	cmp	r3, #0x0
 8017a18: d009         	beq	0x8017a2e <gpio_pin_set_raw+0x2e> @ imm = #0x12
; 		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 8017a1a: 7afb         	ldrb	r3, [r7, #0xb]
 8017a1c: 2201         	movs	r2, #0x1
 8017a1e: fa02 f303    	lsl.w	r3, r2, r3
 8017a22: 4619         	mov	r1, r3
 8017a24: 68f8         	ldr	r0, [r7, #0xc]
 8017a26: f000 f85c    	bl	0x8017ae2 <gpio_port_set_bits_raw> @ imm = #0xb8
 8017a2a: 6178         	str	r0, [r7, #0x14]
 8017a2c: e008         	b	0x8017a40 <gpio_pin_set_raw+0x40> @ imm = #0x10
; 		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 8017a2e: 7afb         	ldrb	r3, [r7, #0xb]
 8017a30: 2201         	movs	r2, #0x1
 8017a32: fa02 f303    	lsl.w	r3, r2, r3
 8017a36: 4619         	mov	r1, r3
 8017a38: 68f8         	ldr	r0, [r7, #0xc]
 8017a3a: f000 f860    	bl	0x8017afe <gpio_port_clear_bits_raw> @ imm = #0xc0
 8017a3e: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 8017a40: 697b         	ldr	r3, [r7, #0x14]
; }
 8017a42: 4618         	mov	r0, r3
 8017a44: 3718         	adds	r7, #0x18
 8017a46: 46bd         	mov	sp, r7
 8017a48: bd80         	pop	{r7, pc}

08017a4a <gpio_pin_set>:
; {
 8017a4a: b580         	push	{r7, lr}
 8017a4c: b086         	sub	sp, #0x18
 8017a4e: af00         	add	r7, sp, #0x0
 8017a50: 60f8         	str	r0, [r7, #0xc]
 8017a52: 460b         	mov	r3, r1
 8017a54: 607a         	str	r2, [r7, #0x4]
 8017a56: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 8017a58: 68fb         	ldr	r3, [r7, #0xc]
 8017a5a: 685b         	ldr	r3, [r3, #0x4]
 8017a5c: 617b         	str	r3, [r7, #0x14]
; 	const struct gpio_driver_data *const data =
 8017a5e: 68fb         	ldr	r3, [r7, #0xc]
 8017a60: 691b         	ldr	r3, [r3, #0x10]
 8017a62: 613b         	str	r3, [r7, #0x10]
; 	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
 8017a64: 693b         	ldr	r3, [r7, #0x10]
 8017a66: 681a         	ldr	r2, [r3]
 8017a68: 7afb         	ldrb	r3, [r7, #0xb]
 8017a6a: 2101         	movs	r1, #0x1
 8017a6c: fa01 f303    	lsl.w	r3, r1, r3
 8017a70: 4013         	ands	r3, r2
 8017a72: 2b00         	cmp	r3, #0x0
 8017a74: d006         	beq	0x8017a84 <gpio_pin_set+0x3a> @ imm = #0xc
; 		value = (value != 0) ? 0 : 1;
 8017a76: 687b         	ldr	r3, [r7, #0x4]
 8017a78: 2b00         	cmp	r3, #0x0
 8017a7a: bf0c         	ite	eq
 8017a7c: 2301         	moveq	r3, #0x1
 8017a7e: 2300         	movne	r3, #0x0
 8017a80: b2db         	uxtb	r3, r3
 8017a82: 607b         	str	r3, [r7, #0x4]
; 	return gpio_pin_set_raw(port, pin, value);
 8017a84: 7afb         	ldrb	r3, [r7, #0xb]
 8017a86: 687a         	ldr	r2, [r7, #0x4]
 8017a88: 4619         	mov	r1, r3
 8017a8a: 68f8         	ldr	r0, [r7, #0xc]
 8017a8c: f7ff ffb8    	bl	0x8017a00 <gpio_pin_set_raw> @ imm = #-0x90
 8017a90: 4603         	mov	r3, r0
; }
 8017a92: 4618         	mov	r0, r3
 8017a94: 3718         	adds	r7, #0x18
 8017a96: 46bd         	mov	sp, r7
 8017a98: bd80         	pop	{r7, pc}

08017a9a <gpio_pin_set_dt>:
; {
 8017a9a: b580         	push	{r7, lr}
 8017a9c: b082         	sub	sp, #0x8
 8017a9e: af00         	add	r7, sp, #0x0
 8017aa0: 6078         	str	r0, [r7, #0x4]
 8017aa2: 6039         	str	r1, [r7]
; 	return gpio_pin_set(spec->port, spec->pin, value);
 8017aa4: 687b         	ldr	r3, [r7, #0x4]
 8017aa6: 6818         	ldr	r0, [r3]
 8017aa8: 687b         	ldr	r3, [r7, #0x4]
 8017aaa: 791b         	ldrb	r3, [r3, #0x4]
 8017aac: 683a         	ldr	r2, [r7]
 8017aae: 4619         	mov	r1, r3
 8017ab0: f7ff ffcb    	bl	0x8017a4a <gpio_pin_set> @ imm = #-0x6a
 8017ab4: 4603         	mov	r3, r0
; }
 8017ab6: 4618         	mov	r0, r3
 8017ab8: 3708         	adds	r7, #0x8
 8017aba: 46bd         	mov	sp, r7
 8017abc: bd80         	pop	{r7, pc}

08017abe <gpio_pin_configure>:
; {
 8017abe: b580         	push	{r7, lr}
 8017ac0: b084         	sub	sp, #0x10
 8017ac2: af00         	add	r7, sp, #0x0
 8017ac4: 60f8         	str	r0, [r7, #0xc]
 8017ac6: 460b         	mov	r3, r1
 8017ac8: 607a         	str	r2, [r7, #0x4]
 8017aca: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 8017acc: 7afb         	ldrb	r3, [r7, #0xb]
 8017ace: 687a         	ldr	r2, [r7, #0x4]
 8017ad0: 4619         	mov	r1, r3
 8017ad2: 68f8         	ldr	r0, [r7, #0xc]
 8017ad4: f7ff ff0f    	bl	0x80178f6 <z_impl_gpio_pin_configure> @ imm = #-0x1e2
 8017ad8: 4603         	mov	r3, r0
; }
 8017ada: 4618         	mov	r0, r3
 8017adc: 3710         	adds	r7, #0x10
 8017ade: 46bd         	mov	sp, r7
 8017ae0: bd80         	pop	{r7, pc}

08017ae2 <gpio_port_set_bits_raw>:
; {
 8017ae2: b580         	push	{r7, lr}
 8017ae4: b082         	sub	sp, #0x8
 8017ae6: af00         	add	r7, sp, #0x0
 8017ae8: 6078         	str	r0, [r7, #0x4]
 8017aea: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_set_bits_raw(port, pins);
 8017aec: 6839         	ldr	r1, [r7]
 8017aee: 6878         	ldr	r0, [r7, #0x4]
 8017af0: f7ff ff62    	bl	0x80179b8 <z_impl_gpio_port_set_bits_raw> @ imm = #-0x13c
 8017af4: 4603         	mov	r3, r0
; }
 8017af6: 4618         	mov	r0, r3
 8017af8: 3708         	adds	r7, #0x8
 8017afa: 46bd         	mov	sp, r7
 8017afc: bd80         	pop	{r7, pc}

08017afe <gpio_port_clear_bits_raw>:
; {
 8017afe: b580         	push	{r7, lr}
 8017b00: b082         	sub	sp, #0x8
 8017b02: af00         	add	r7, sp, #0x0
 8017b04: 6078         	str	r0, [r7, #0x4]
 8017b06: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_clear_bits_raw(port, pins);
 8017b08: 6839         	ldr	r1, [r7]
 8017b0a: 6878         	ldr	r0, [r7, #0x4]
 8017b0c: f7ff ff66    	bl	0x80179dc <z_impl_gpio_port_clear_bits_raw> @ imm = #-0x134
 8017b10: 4603         	mov	r3, r0
; }
 8017b12: 4618         	mov	r0, r3
 8017b14: 3708         	adds	r7, #0x8
 8017b16: 46bd         	mov	sp, r7
 8017b18: bd80         	pop	{r7, pc}

08017b1a <spi_cs_is_gpio>:
; {
 8017b1a: b480         	push	{r7}
 8017b1c: b083         	sub	sp, #0xc
 8017b1e: af00         	add	r7, sp, #0x0
 8017b20: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 8017b22: 687b         	ldr	r3, [r7, #0x4]
 8017b24: 689b         	ldr	r3, [r3, #0x8]
 8017b26: 2b00         	cmp	r3, #0x0
 8017b28: bf14         	ite	ne
 8017b2a: 2301         	movne	r3, #0x1
 8017b2c: 2300         	moveq	r3, #0x0
 8017b2e: b2db         	uxtb	r3, r3
; }
 8017b30: 4618         	mov	r0, r3
 8017b32: 370c         	adds	r7, #0xc
 8017b34: 46bd         	mov	sp, r7
 8017b36: bc80         	pop	{r7}
 8017b38: 4770         	bx	lr

08017b3a <pinctrl_apply_state_direct>:
; {
 8017b3a: b580         	push	{r7, lr}
 8017b3c: b084         	sub	sp, #0x10
 8017b3e: af00         	add	r7, sp, #0x0
 8017b40: 6078         	str	r0, [r7, #0x4]
 8017b42: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 8017b44: 2300         	movs	r3, #0x0
 8017b46: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 8017b48: 683b         	ldr	r3, [r7]
 8017b4a: 6818         	ldr	r0, [r3]
 8017b4c: 683b         	ldr	r3, [r7]
 8017b4e: 791b         	ldrb	r3, [r3, #0x4]
 8017b50: 68fa         	ldr	r2, [r7, #0xc]
 8017b52: 4619         	mov	r1, r3
 8017b54: f7fd ff97    	bl	0x8015a86 <pinctrl_configure_pins> @ imm = #-0x20d2
 8017b58: 4603         	mov	r3, r0
; }
 8017b5a: 4618         	mov	r0, r3
 8017b5c: 3710         	adds	r7, #0x10
 8017b5e: 46bd         	mov	sp, r7
 8017b60: bd80         	pop	{r7, pc}

08017b62 <pinctrl_apply_state>:
; {
 8017b62: b580         	push	{r7, lr}
 8017b64: b084         	sub	sp, #0x10
 8017b66: af00         	add	r7, sp, #0x0
 8017b68: 6078         	str	r0, [r7, #0x4]
 8017b6a: 460b         	mov	r3, r1
 8017b6c: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 8017b6e: f107 0208    	add.w	r2, r7, #0x8
 8017b72: 78fb         	ldrb	r3, [r7, #0x3]
 8017b74: 4619         	mov	r1, r3
 8017b76: 6878         	ldr	r0, [r7, #0x4]
 8017b78: f7fd ff4e    	bl	0x8015a18 <pinctrl_lookup_state> @ imm = #-0x2164
 8017b7c: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8017b7e: 68fb         	ldr	r3, [r7, #0xc]
 8017b80: 2b00         	cmp	r3, #0x0
 8017b82: da01         	bge	0x8017b88 <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 8017b84: 68fb         	ldr	r3, [r7, #0xc]
 8017b86: e005         	b	0x8017b94 <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 8017b88: 68bb         	ldr	r3, [r7, #0x8]
 8017b8a: 4619         	mov	r1, r3
 8017b8c: 6878         	ldr	r0, [r7, #0x4]
 8017b8e: f7ff ffd4    	bl	0x8017b3a <pinctrl_apply_state_direct> @ imm = #-0x58
 8017b92: 4603         	mov	r3, r0
; }
 8017b94: 4618         	mov	r0, r3
 8017b96: 3710         	adds	r7, #0x10
 8017b98: 46bd         	mov	sp, r7
 8017b9a: bd80         	pop	{r7, pc}

08017b9c <pm_device_runtime_enable>:
; {
 8017b9c: b480         	push	{r7}
 8017b9e: b083         	sub	sp, #0xc
 8017ba0: af00         	add	r7, sp, #0x0
 8017ba2: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8017ba4: 2300         	movs	r3, #0x0
; }
 8017ba6: 4618         	mov	r0, r3
 8017ba8: 370c         	adds	r7, #0xc
 8017baa: 46bd         	mov	sp, r7
 8017bac: bc80         	pop	{r7}
 8017bae: 4770         	bx	lr

08017bb0 <clock_control_on>:
; {
 8017bb0: b580         	push	{r7, lr}
 8017bb2: b084         	sub	sp, #0x10
 8017bb4: af00         	add	r7, sp, #0x0
 8017bb6: 6078         	str	r0, [r7, #0x4]
 8017bb8: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8017bba: 687b         	ldr	r3, [r7, #0x4]
 8017bbc: 689b         	ldr	r3, [r3, #0x8]
 8017bbe: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8017bc0: 68fb         	ldr	r3, [r7, #0xc]
 8017bc2: 681b         	ldr	r3, [r3]
 8017bc4: 6839         	ldr	r1, [r7]
 8017bc6: 6878         	ldr	r0, [r7, #0x4]
 8017bc8: 4798         	blx	r3
 8017bca: 4603         	mov	r3, r0
; }
 8017bcc: 4618         	mov	r0, r3
 8017bce: 3710         	adds	r7, #0x10
 8017bd0: 46bd         	mov	sp, r7
 8017bd2: bd80         	pop	{r7, pc}

08017bd4 <clock_control_get_rate>:
; {
 8017bd4: b580         	push	{r7, lr}
 8017bd6: b086         	sub	sp, #0x18
 8017bd8: af00         	add	r7, sp, #0x0
 8017bda: 60f8         	str	r0, [r7, #0xc]
 8017bdc: 60b9         	str	r1, [r7, #0x8]
 8017bde: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 8017be0: 68fb         	ldr	r3, [r7, #0xc]
 8017be2: 689b         	ldr	r3, [r3, #0x8]
 8017be4: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 8017be6: 697b         	ldr	r3, [r7, #0x14]
 8017be8: 68db         	ldr	r3, [r3, #0xc]
 8017bea: 2b00         	cmp	r3, #0x0
 8017bec: d102         	bne	0x8017bf4 <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8017bee: f06f 0357    	mvn	r3, #0x57
 8017bf2: e006         	b	0x8017c02 <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 8017bf4: 697b         	ldr	r3, [r7, #0x14]
 8017bf6: 68db         	ldr	r3, [r3, #0xc]
 8017bf8: 687a         	ldr	r2, [r7, #0x4]
 8017bfa: 68b9         	ldr	r1, [r7, #0x8]
 8017bfc: 68f8         	ldr	r0, [r7, #0xc]
 8017bfe: 4798         	blx	r3
 8017c00: 4603         	mov	r3, r0
; }
 8017c02: 4618         	mov	r0, r3
 8017c04: 3718         	adds	r7, #0x18
 8017c06: 46bd         	mov	sp, r7
 8017c08: bd80         	pop	{r7, pc}

08017c0a <spi_context_configured>:
; {
 8017c0a: b480         	push	{r7}
 8017c0c: b083         	sub	sp, #0xc
 8017c0e: af00         	add	r7, sp, #0x0
 8017c10: 6078         	str	r0, [r7, #0x4]
 8017c12: 6039         	str	r1, [r7]
; 	return !!(ctx->config == config);
 8017c14: 687b         	ldr	r3, [r7, #0x4]
 8017c16: 681b         	ldr	r3, [r3]
 8017c18: 683a         	ldr	r2, [r7]
 8017c1a: 429a         	cmp	r2, r3
 8017c1c: bf0c         	ite	eq
 8017c1e: 2301         	moveq	r3, #0x1
 8017c20: 2300         	movne	r3, #0x0
 8017c22: b2db         	uxtb	r3, r3
; }
 8017c24: 4618         	mov	r0, r3
 8017c26: 370c         	adds	r7, #0xc
 8017c28: 46bd         	mov	sp, r7
 8017c2a: bc80         	pop	{r7}
 8017c2c: 4770         	bx	lr

08017c2e <spi_context_lock>:
; {
 8017c2e: b580         	push	{r7, lr}
 8017c30: b084         	sub	sp, #0x10
 8017c32: af00         	add	r7, sp, #0x0
 8017c34: 60f8         	str	r0, [r7, #0xc]
 8017c36: 607a         	str	r2, [r7, #0x4]
 8017c38: 603b         	str	r3, [r7]
 8017c3a: 460b         	mov	r3, r1
 8017c3c: 72fb         	strb	r3, [r7, #0xb]
; 	if ((spi_cfg->operation & SPI_LOCK_ON) &&
 8017c3e: 69bb         	ldr	r3, [r7, #0x18]
 8017c40: 889b         	ldrh	r3, [r3, #0x4]
 8017c42: f403 5300    	and	r3, r3, #0x2000
 8017c46: 2b00         	cmp	r3, #0x0
 8017c48: d00d         	beq	0x8017c66 <spi_context_lock+0x38> @ imm = #0x1a
; 		(k_sem_count_get(&ctx->lock) == 0) &&
 8017c4a: 68fb         	ldr	r3, [r7, #0xc]
 8017c4c: 3310         	adds	r3, #0x10
 8017c4e: 4618         	mov	r0, r3
 8017c50: f7ff fc86    	bl	0x8017560 <k_sem_count_get> @ imm = #-0x6f4
 8017c54: 4603         	mov	r3, r0
; 	if ((spi_cfg->operation & SPI_LOCK_ON) &&
 8017c56: 2b00         	cmp	r3, #0x0
 8017c58: d105         	bne	0x8017c66 <spi_context_lock+0x38> @ imm = #0xa
; 		(ctx->owner == spi_cfg)) {
 8017c5a: 68fb         	ldr	r3, [r7, #0xc]
 8017c5c: 685b         	ldr	r3, [r3, #0x4]
; 		(k_sem_count_get(&ctx->lock) == 0) &&
 8017c5e: 69ba         	ldr	r2, [r7, #0x18]
 8017c60: 429a         	cmp	r2, r3
 8017c62: d100         	bne	0x8017c66 <spi_context_lock+0x38> @ imm = #0x0
 8017c64: e00c         	b	0x8017c80 <spi_context_lock+0x52> @ imm = #0x18
; 	k_sem_take(&ctx->lock, K_FOREVER);
 8017c66: 68fb         	ldr	r3, [r7, #0xc]
 8017c68: f103 0110    	add.w	r1, r3, #0x10
 8017c6c: f04f 32ff    	mov.w	r2, #0xffffffff
 8017c70: f04f 33ff    	mov.w	r3, #0xffffffff
 8017c74: 4608         	mov	r0, r1
 8017c76: f7ff fc58    	bl	0x801752a <k_sem_take>  @ imm = #-0x750
; 	ctx->owner = spi_cfg;
 8017c7a: 68fb         	ldr	r3, [r7, #0xc]
 8017c7c: 69ba         	ldr	r2, [r7, #0x18]
 8017c7e: 605a         	str	r2, [r3, #0x4]
; }
 8017c80: 3710         	adds	r7, #0x10
 8017c82: 46bd         	mov	sp, r7
 8017c84: bd80         	pop	{r7, pc}

08017c86 <spi_context_release>:
; {
 8017c86: b580         	push	{r7, lr}
 8017c88: b082         	sub	sp, #0x8
 8017c8a: af00         	add	r7, sp, #0x0
 8017c8c: 6078         	str	r0, [r7, #0x4]
 8017c8e: 6039         	str	r1, [r7]
; 	if (!(ctx->config->operation & SPI_LOCK_ON)) {
 8017c90: 687b         	ldr	r3, [r7, #0x4]
 8017c92: 681b         	ldr	r3, [r3]
 8017c94: 889b         	ldrh	r3, [r3, #0x4]
 8017c96: f403 5300    	and	r3, r3, #0x2000
 8017c9a: 2b00         	cmp	r3, #0x0
 8017c9c: d107         	bne	0x8017cae <spi_context_release+0x28> @ imm = #0xe
; 		ctx->owner = NULL;
 8017c9e: 687b         	ldr	r3, [r7, #0x4]
 8017ca0: 2200         	movs	r2, #0x0
 8017ca2: 605a         	str	r2, [r3, #0x4]
; 		k_sem_give(&ctx->lock);
 8017ca4: 687b         	ldr	r3, [r7, #0x4]
 8017ca6: 3310         	adds	r3, #0x10
 8017ca8: 4618         	mov	r0, r3
 8017caa: f7ff fc4e    	bl	0x801754a <k_sem_give>  @ imm = #-0x764
; }
 8017cae: bf00         	nop
 8017cb0: 3708         	adds	r7, #0x8
 8017cb2: 46bd         	mov	sp, r7
 8017cb4: bd80         	pop	{r7, pc}

08017cb6 <_spi_context_cs_control>:
; {
 8017cb6: b580         	push	{r7, lr}
 8017cb8: b082         	sub	sp, #0x8
 8017cba: af00         	add	r7, sp, #0x0
 8017cbc: 6078         	str	r0, [r7, #0x4]
 8017cbe: 460b         	mov	r3, r1
 8017cc0: 70fb         	strb	r3, [r7, #0x3]
 8017cc2: 4613         	mov	r3, r2
 8017cc4: 70bb         	strb	r3, [r7, #0x2]
; 	if (ctx->config && spi_cs_is_gpio(ctx->config)) {
 8017cc6: 687b         	ldr	r3, [r7, #0x4]
 8017cc8: 681b         	ldr	r3, [r3]
 8017cca: 2b00         	cmp	r3, #0x0
 8017ccc: d034         	beq	0x8017d38 <_spi_context_cs_control+0x82> @ imm = #0x68
 8017cce: 687b         	ldr	r3, [r7, #0x4]
 8017cd0: 681b         	ldr	r3, [r3]
 8017cd2: 4618         	mov	r0, r3
 8017cd4: f7ff ff21    	bl	0x8017b1a <spi_cs_is_gpio> @ imm = #-0x1be
 8017cd8: 4603         	mov	r3, r0
 8017cda: 2b00         	cmp	r3, #0x0
 8017cdc: d02c         	beq	0x8017d38 <_spi_context_cs_control+0x82> @ imm = #0x58
; 		if (on) {
 8017cde: 78fb         	ldrb	r3, [r7, #0x3]
 8017ce0: 2b00         	cmp	r3, #0x0
 8017ce2: d00d         	beq	0x8017d00 <_spi_context_cs_control+0x4a> @ imm = #0x1a
; 			gpio_pin_set_dt(&ctx->config->cs.gpio, 1);
 8017ce4: 687b         	ldr	r3, [r7, #0x4]
 8017ce6: 681b         	ldr	r3, [r3]
 8017ce8: 3308         	adds	r3, #0x8
 8017cea: 2101         	movs	r1, #0x1
 8017cec: 4618         	mov	r0, r3
 8017cee: f7ff fed4    	bl	0x8017a9a <gpio_pin_set_dt> @ imm = #-0x258
; 			k_busy_wait(ctx->config->cs.delay);
 8017cf2: 687b         	ldr	r3, [r7, #0x4]
 8017cf4: 681b         	ldr	r3, [r3]
 8017cf6: 691b         	ldr	r3, [r3, #0x10]
 8017cf8: 4618         	mov	r0, r3
 8017cfa: f7ff fc0b    	bl	0x8017514 <k_busy_wait> @ imm = #-0x7ea
 8017cfe: e01b         	b	0x8017d38 <_spi_context_cs_control+0x82> @ imm = #0x36
; 			if (!force_off &&
 8017d00: 78bb         	ldrb	r3, [r7, #0x2]
 8017d02: f083 0301    	eor	r3, r3, #0x1
 8017d06: b2db         	uxtb	r3, r3
 8017d08: 2b00         	cmp	r3, #0x0
 8017d0a: d006         	beq	0x8017d1a <_spi_context_cs_control+0x64> @ imm = #0xc
; 			    ctx->config->operation & SPI_HOLD_ON_CS) {
 8017d0c: 687b         	ldr	r3, [r7, #0x4]
 8017d0e: 681b         	ldr	r3, [r3]
 8017d10: 889b         	ldrh	r3, [r3, #0x4]
 8017d12: f403 5380    	and	r3, r3, #0x1000
; 			if (!force_off &&
 8017d16: 2b00         	cmp	r3, #0x0
 8017d18: d10d         	bne	0x8017d36 <_spi_context_cs_control+0x80> @ imm = #0x1a
; 			k_busy_wait(ctx->config->cs.delay);
 8017d1a: 687b         	ldr	r3, [r7, #0x4]
 8017d1c: 681b         	ldr	r3, [r3]
 8017d1e: 691b         	ldr	r3, [r3, #0x10]
 8017d20: 4618         	mov	r0, r3
 8017d22: f7ff fbf7    	bl	0x8017514 <k_busy_wait> @ imm = #-0x812
; 			gpio_pin_set_dt(&ctx->config->cs.gpio, 0);
 8017d26: 687b         	ldr	r3, [r7, #0x4]
 8017d28: 681b         	ldr	r3, [r3]
 8017d2a: 3308         	adds	r3, #0x8
 8017d2c: 2100         	movs	r1, #0x0
 8017d2e: 4618         	mov	r0, r3
 8017d30: f7ff feb3    	bl	0x8017a9a <gpio_pin_set_dt> @ imm = #-0x29a
 8017d34: e000         	b	0x8017d38 <_spi_context_cs_control+0x82> @ imm = #0x0
; 				return;
 8017d36: bf00         	nop
; }
 8017d38: 3708         	adds	r7, #0x8
 8017d3a: 46bd         	mov	sp, r7
 8017d3c: bd80         	pop	{r7, pc}

08017d3e <spi_context_cs_control>:
; {
 8017d3e: b580         	push	{r7, lr}
 8017d40: b082         	sub	sp, #0x8
 8017d42: af00         	add	r7, sp, #0x0
 8017d44: 6078         	str	r0, [r7, #0x4]
 8017d46: 460b         	mov	r3, r1
 8017d48: 70fb         	strb	r3, [r7, #0x3]
; 	_spi_context_cs_control(ctx, on, false);
 8017d4a: 78fb         	ldrb	r3, [r7, #0x3]
 8017d4c: 2200         	movs	r2, #0x0
 8017d4e: 4619         	mov	r1, r3
 8017d50: 6878         	ldr	r0, [r7, #0x4]
 8017d52: f7ff ffb0    	bl	0x8017cb6 <_spi_context_cs_control> @ imm = #-0xa0
; }
 8017d56: bf00         	nop
 8017d58: 3708         	adds	r7, #0x8
 8017d5a: 46bd         	mov	sp, r7
 8017d5c: bd80         	pop	{r7, pc}

08017d5e <spi_context_unlock_unconditionally>:
; {
 8017d5e: b580         	push	{r7, lr}
 8017d60: b082         	sub	sp, #0x8
 8017d62: af00         	add	r7, sp, #0x0
 8017d64: 6078         	str	r0, [r7, #0x4]
; 	_spi_context_cs_control(ctx, false, true);
 8017d66: 2201         	movs	r2, #0x1
 8017d68: 2100         	movs	r1, #0x0
 8017d6a: 6878         	ldr	r0, [r7, #0x4]
 8017d6c: f7ff ffa3    	bl	0x8017cb6 <_spi_context_cs_control> @ imm = #-0xba
; 	if (!k_sem_count_get(&ctx->lock)) {
 8017d70: 687b         	ldr	r3, [r7, #0x4]
 8017d72: 3310         	adds	r3, #0x10
 8017d74: 4618         	mov	r0, r3
 8017d76: f7ff fbf3    	bl	0x8017560 <k_sem_count_get> @ imm = #-0x81a
 8017d7a: 4603         	mov	r3, r0
 8017d7c: 2b00         	cmp	r3, #0x0
 8017d7e: d107         	bne	0x8017d90 <spi_context_unlock_unconditionally+0x32> @ imm = #0xe
; 		ctx->owner = NULL;
 8017d80: 687b         	ldr	r3, [r7, #0x4]
 8017d82: 2200         	movs	r2, #0x0
 8017d84: 605a         	str	r2, [r3, #0x4]
; 		k_sem_give(&ctx->lock);
 8017d86: 687b         	ldr	r3, [r7, #0x4]
 8017d88: 3310         	adds	r3, #0x10
 8017d8a: 4618         	mov	r0, r3
 8017d8c: f7ff fbdd    	bl	0x801754a <k_sem_give>  @ imm = #-0x846
; }
 8017d90: bf00         	nop
 8017d92: 3708         	adds	r7, #0x8
 8017d94: 46bd         	mov	sp, r7
 8017d96: bd80         	pop	{r7, pc}

08017d98 <spi_context_get_next_buf>:
; {
 8017d98: b480         	push	{r7}
 8017d9a: b085         	sub	sp, #0x14
 8017d9c: af00         	add	r7, sp, #0x0
 8017d9e: 60f8         	str	r0, [r7, #0xc]
 8017da0: 60b9         	str	r1, [r7, #0x8]
 8017da2: 607a         	str	r2, [r7, #0x4]
 8017da4: 70fb         	strb	r3, [r7, #0x3]
; 	while (*count) {
 8017da6: e01c         	b	0x8017de2 <spi_context_get_next_buf+0x4a> @ imm = #0x38
; 		if (((*current)->len / dfs) != 0) {
 8017da8: 68fb         	ldr	r3, [r7, #0xc]
 8017daa: 681b         	ldr	r3, [r3]
 8017dac: 685a         	ldr	r2, [r3, #0x4]
 8017dae: 78fb         	ldrb	r3, [r7, #0x3]
 8017db0: 429a         	cmp	r2, r3
 8017db2: d30b         	blo	0x8017dcc <spi_context_get_next_buf+0x34> @ imm = #0x16
; 			*buf_len = (*current)->len / dfs;
 8017db4: 68fb         	ldr	r3, [r7, #0xc]
 8017db6: 681b         	ldr	r3, [r3]
 8017db8: 685a         	ldr	r2, [r3, #0x4]
 8017dba: 78fb         	ldrb	r3, [r7, #0x3]
 8017dbc: fbb2 f2f3    	udiv	r2, r2, r3
 8017dc0: 687b         	ldr	r3, [r7, #0x4]
 8017dc2: 601a         	str	r2, [r3]
; 			return (*current)->buf;
 8017dc4: 68fb         	ldr	r3, [r7, #0xc]
 8017dc6: 681b         	ldr	r3, [r3]
 8017dc8: 681b         	ldr	r3, [r3]
 8017dca: e012         	b	0x8017df2 <spi_context_get_next_buf+0x5a> @ imm = #0x24
; 		++(*current);
 8017dcc: 68fb         	ldr	r3, [r7, #0xc]
 8017dce: 681b         	ldr	r3, [r3]
 8017dd0: f103 0208    	add.w	r2, r3, #0x8
 8017dd4: 68fb         	ldr	r3, [r7, #0xc]
 8017dd6: 601a         	str	r2, [r3]
; 		--(*count);
 8017dd8: 68bb         	ldr	r3, [r7, #0x8]
 8017dda: 681b         	ldr	r3, [r3]
 8017ddc: 1e5a         	subs	r2, r3, #0x1
 8017dde: 68bb         	ldr	r3, [r7, #0x8]
 8017de0: 601a         	str	r2, [r3]
; 	while (*count) {
 8017de2: 68bb         	ldr	r3, [r7, #0x8]
 8017de4: 681b         	ldr	r3, [r3]
 8017de6: 2b00         	cmp	r3, #0x0
 8017de8: d1de         	bne	0x8017da8 <spi_context_get_next_buf+0x10> @ imm = #-0x44
; 	*buf_len = 0;
 8017dea: 687b         	ldr	r3, [r7, #0x4]
 8017dec: 2200         	movs	r2, #0x0
 8017dee: 601a         	str	r2, [r3]
; 	return NULL;
 8017df0: 2300         	movs	r3, #0x0
; }
 8017df2: 4618         	mov	r0, r3
 8017df4: 3714         	adds	r7, #0x14
 8017df6: 46bd         	mov	sp, r7
 8017df8: bc80         	pop	{r7}
 8017dfa: 4770         	bx	lr

08017dfc <ll_func_tx_is_not_full>:
; {
 8017dfc: b580         	push	{r7, lr}
 8017dfe: b082         	sub	sp, #0x8
 8017e00: af00         	add	r7, sp, #0x0
 8017e02: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_TXE(spi);
 8017e04: 6878         	ldr	r0, [r7, #0x4]
 8017e06: f7ff fcc0    	bl	0x801778a <LL_SPI_IsActiveFlag_TXE> @ imm = #-0x680
 8017e0a: 4603         	mov	r3, r0
; }
 8017e0c: 4618         	mov	r0, r3
 8017e0e: 3708         	adds	r7, #0x8
 8017e10: 46bd         	mov	sp, r7
 8017e12: bd80         	pop	{r7, pc}

08017e14 <ll_func_rx_is_not_empty>:
; {
 8017e14: b580         	push	{r7, lr}
 8017e16: b082         	sub	sp, #0x8
 8017e18: af00         	add	r7, sp, #0x0
 8017e1a: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_RXNE(spi);
 8017e1c: 6878         	ldr	r0, [r7, #0x4]
 8017e1e: f7ff fca2    	bl	0x8017766 <LL_SPI_IsActiveFlag_RXNE> @ imm = #-0x6bc
 8017e22: 4603         	mov	r3, r0
; }
 8017e24: 4618         	mov	r0, r3
 8017e26: 3708         	adds	r7, #0x8
 8017e28: 46bd         	mov	sp, r7
 8017e2a: bd80         	pop	{r7, pc}

08017e2c <ll_func_disable_int_tx_empty>:
; {
 8017e2c: b580         	push	{r7, lr}
 8017e2e: b082         	sub	sp, #0x8
 8017e30: af00         	add	r7, sp, #0x0
 8017e32: 6078         	str	r0, [r7, #0x4]
; 	LL_SPI_DisableIT_TXE(spi);
 8017e34: 6878         	ldr	r0, [r7, #0x4]
 8017e36: f7ff fd14    	bl	0x8017862 <LL_SPI_DisableIT_TXE> @ imm = #-0x5d8
; }
 8017e3a: bf00         	nop
 8017e3c: 3708         	adds	r7, #0x8
 8017e3e: 46bd         	mov	sp, r7
 8017e40: bd80         	pop	{r7, pc}

08017e42 <ll_func_spi_is_busy>:
; {
 8017e42: b580         	push	{r7, lr}
 8017e44: b082         	sub	sp, #0x8
 8017e46: af00         	add	r7, sp, #0x0
 8017e48: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_BSY(spi);
 8017e4a: 6878         	ldr	r0, [r7, #0x4]
 8017e4c: f7ff fcd3    	bl	0x80177f6 <LL_SPI_IsActiveFlag_BSY> @ imm = #-0x65a
 8017e50: 4603         	mov	r3, r0
; }
 8017e52: 4618         	mov	r0, r3
 8017e54: 3708         	adds	r7, #0x8
 8017e56: 46bd         	mov	sp, r7
 8017e58: bd80         	pop	{r7, pc}

08017e5a <ll_func_disable_spi>:
; {
 8017e5a: b580         	push	{r7, lr}
 8017e5c: b082         	sub	sp, #0x8
 8017e5e: af00         	add	r7, sp, #0x0
 8017e60: 6078         	str	r0, [r7, #0x4]
; 	LL_SPI_Disable(spi);
 8017e62: 6878         	ldr	r0, [r7, #0x4]
 8017e64: f7ff fb97    	bl	0x8017596 <LL_SPI_Disable> @ imm = #-0x8d2
; 	while (LL_SPI_IsEnabled(spi)) {
 8017e68: bf00         	nop
 8017e6a: 6878         	ldr	r0, [r7, #0x4]
 8017e6c: f7ff fba2    	bl	0x80175b4 <LL_SPI_IsEnabled> @ imm = #-0x8bc
 8017e70: 4603         	mov	r3, r0
 8017e72: 2b00         	cmp	r3, #0x0
 8017e74: d1f9         	bne	0x8017e6a <ll_func_disable_spi+0x10> @ imm = #-0xe
; }
 8017e76: bf00         	nop
 8017e78: bf00         	nop
 8017e7a: 3708         	adds	r7, #0x8
 8017e7c: 46bd         	mov	sp, r7
 8017e7e: bd80         	pop	{r7, pc}

08017e80 <spi_stm32_pm_policy_state_lock_get>:
; {
 8017e80: b480         	push	{r7}
 8017e82: b083         	sub	sp, #0xc
 8017e84: af00         	add	r7, sp, #0x0
 8017e86: 6078         	str	r0, [r7, #0x4]
; }
 8017e88: bf00         	nop
 8017e8a: 370c         	adds	r7, #0xc
 8017e8c: 46bd         	mov	sp, r7
 8017e8e: bc80         	pop	{r7}
 8017e90: 4770         	bx	lr

08017e92 <spi_stm32_pm_policy_state_lock_put>:
; {
 8017e92: b480         	push	{r7}
 8017e94: b083         	sub	sp, #0xc
 8017e96: af00         	add	r7, sp, #0x0
 8017e98: 6078         	str	r0, [r7, #0x4]
; }
 8017e9a: bf00         	nop
 8017e9c: 370c         	adds	r7, #0xc
 8017e9e: 46bd         	mov	sp, r7
 8017ea0: bc80         	pop	{r7}
 8017ea2: 4770         	bx	lr

08017ea4 <spi_stm32_transfer_ongoing>:
; {
 8017ea4: b480         	push	{r7}
 8017ea6: b085         	sub	sp, #0x14
 8017ea8: af00         	add	r7, sp, #0x0
 8017eaa: 6078         	str	r0, [r7, #0x4]
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 8017eac: 687b         	ldr	r3, [r7, #0x4]
 8017eae: 60fb         	str	r3, [r7, #0xc]
; 	return !!(ctx->tx_len);
 8017eb0: 68fb         	ldr	r3, [r7, #0xc]
 8017eb2: 6c9b         	ldr	r3, [r3, #0x48]
 8017eb4: 2b00         	cmp	r3, #0x0
 8017eb6: bf14         	ite	ne
 8017eb8: 2301         	movne	r3, #0x1
 8017eba: 2300         	moveq	r3, #0x0
 8017ebc: b2db         	uxtb	r3, r3
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 8017ebe: 2b00         	cmp	r3, #0x0
 8017ec0: d10a         	bne	0x8017ed8 <spi_stm32_transfer_ongoing+0x34> @ imm = #0x14
 8017ec2: 687b         	ldr	r3, [r7, #0x4]
 8017ec4: 60bb         	str	r3, [r7, #0x8]
; 	return !!(ctx->rx_len);
 8017ec6: 68bb         	ldr	r3, [r7, #0x8]
 8017ec8: 6d1b         	ldr	r3, [r3, #0x50]
 8017eca: 2b00         	cmp	r3, #0x0
 8017ecc: bf14         	ite	ne
 8017ece: 2301         	movne	r3, #0x1
 8017ed0: 2300         	moveq	r3, #0x0
 8017ed2: b2db         	uxtb	r3, r3
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 8017ed4: 2b00         	cmp	r3, #0x0
 8017ed6: d001         	beq	0x8017edc <spi_stm32_transfer_ongoing+0x38> @ imm = #0x2
 8017ed8: 2301         	movs	r3, #0x1
 8017eda: e000         	b	0x8017ede <spi_stm32_transfer_ongoing+0x3a> @ imm = #0x0
 8017edc: 2300         	movs	r3, #0x0
 8017ede: f003 0301    	and	r3, r3, #0x1
 8017ee2: b2db         	uxtb	r3, r3
; }
 8017ee4: 4618         	mov	r0, r3
 8017ee6: 3714         	adds	r7, #0x14
 8017ee8: 46bd         	mov	sp, r7
 8017eea: bc80         	pop	{r7}
 8017eec: 4770         	bx	lr

08017eee <spi_stm32_shift_fifo>:
; {
 8017eee: b580         	push	{r7, lr}
 8017ef0: b082         	sub	sp, #0x8
 8017ef2: af00         	add	r7, sp, #0x0
 8017ef4: 6078         	str	r0, [r7, #0x4]
 8017ef6: 6039         	str	r1, [r7]
; 	if (ll_func_rx_is_not_empty(spi)) {
 8017ef8: 6878         	ldr	r0, [r7, #0x4]
 8017efa: f7ff ff8b    	bl	0x8017e14 <ll_func_rx_is_not_empty> @ imm = #-0xea
 8017efe: 4603         	mov	r3, r0
 8017f00: 2b00         	cmp	r3, #0x0
 8017f02: d003         	beq	0x8017f0c <spi_stm32_shift_fifo+0x1e> @ imm = #0x6
; 		spi_stm32_read_next_frame(spi, data);
 8017f04: 6839         	ldr	r1, [r7]
 8017f06: 6878         	ldr	r0, [r7, #0x4]
 8017f08: f7f1 fa6a    	bl	0x80093e0 <spi_stm32_read_next_frame> @ imm = #-0xeb2c
; 	if (ll_func_tx_is_not_full(spi)) {
 8017f0c: 6878         	ldr	r0, [r7, #0x4]
 8017f0e: f7ff ff75    	bl	0x8017dfc <ll_func_tx_is_not_full> @ imm = #-0x116
 8017f12: 4603         	mov	r3, r0
 8017f14: 2b00         	cmp	r3, #0x0
 8017f16: d003         	beq	0x8017f20 <spi_stm32_shift_fifo+0x32> @ imm = #0x6
; 		spi_stm32_send_next_frame(spi, data);
 8017f18: 6839         	ldr	r1, [r7]
 8017f1a: 6878         	ldr	r0, [r7, #0x4]
 8017f1c: f7f1 f8f4    	bl	0x8009108 <spi_stm32_send_next_frame> @ imm = #-0xee18
; }
 8017f20: bf00         	nop
 8017f22: 3708         	adds	r7, #0x8
 8017f24: 46bd         	mov	sp, r7
 8017f26: bd80         	pop	{r7, pc}

08017f28 <spi_stm32_shift_m>:
; {
 8017f28: b580         	push	{r7, lr}
 8017f2a: b082         	sub	sp, #0x8
 8017f2c: af00         	add	r7, sp, #0x0
 8017f2e: 6078         	str	r0, [r7, #0x4]
 8017f30: 6039         	str	r1, [r7]
; 	if (cfg->fifo_enabled) {
 8017f32: 687b         	ldr	r3, [r7, #0x4]
 8017f34: 7c1b         	ldrb	r3, [r3, #0x10]
 8017f36: 2b00         	cmp	r3, #0x0
 8017f38: d006         	beq	0x8017f48 <spi_stm32_shift_m+0x20> @ imm = #0xc
; 		spi_stm32_shift_fifo(cfg->spi, data);
 8017f3a: 687b         	ldr	r3, [r7, #0x4]
 8017f3c: 681b         	ldr	r3, [r3]
 8017f3e: 6839         	ldr	r1, [r7]
 8017f40: 4618         	mov	r0, r3
 8017f42: f7ff ffd4    	bl	0x8017eee <spi_stm32_shift_fifo> @ imm = #-0x58
; }
 8017f46: e01d         	b	0x8017f84 <spi_stm32_shift_m+0x5c> @ imm = #0x3a
; 		while (!ll_func_tx_is_not_full(cfg->spi)) {
 8017f48: bf00         	nop
 8017f4a: 687b         	ldr	r3, [r7, #0x4]
 8017f4c: 681b         	ldr	r3, [r3]
 8017f4e: 4618         	mov	r0, r3
 8017f50: f7ff ff54    	bl	0x8017dfc <ll_func_tx_is_not_full> @ imm = #-0x158
 8017f54: 4603         	mov	r3, r0
 8017f56: 2b00         	cmp	r3, #0x0
 8017f58: d0f7         	beq	0x8017f4a <spi_stm32_shift_m+0x22> @ imm = #-0x12
; 		spi_stm32_send_next_frame(cfg->spi, data);
 8017f5a: 687b         	ldr	r3, [r7, #0x4]
 8017f5c: 681b         	ldr	r3, [r3]
 8017f5e: 6839         	ldr	r1, [r7]
 8017f60: 4618         	mov	r0, r3
 8017f62: f7f1 f8d1    	bl	0x8009108 <spi_stm32_send_next_frame> @ imm = #-0xee5e
; 		while (!ll_func_rx_is_not_empty(cfg->spi)) {
 8017f66: bf00         	nop
 8017f68: 687b         	ldr	r3, [r7, #0x4]
 8017f6a: 681b         	ldr	r3, [r3]
 8017f6c: 4618         	mov	r0, r3
 8017f6e: f7ff ff51    	bl	0x8017e14 <ll_func_rx_is_not_empty> @ imm = #-0x15e
 8017f72: 4603         	mov	r3, r0
 8017f74: 2b00         	cmp	r3, #0x0
 8017f76: d0f7         	beq	0x8017f68 <spi_stm32_shift_m+0x40> @ imm = #-0x12
; 		spi_stm32_read_next_frame(cfg->spi, data);
 8017f78: 687b         	ldr	r3, [r7, #0x4]
 8017f7a: 681b         	ldr	r3, [r3]
 8017f7c: 6839         	ldr	r1, [r7]
 8017f7e: 4618         	mov	r0, r3
 8017f80: f7f1 fa2e    	bl	0x80093e0 <spi_stm32_read_next_frame> @ imm = #-0xeba4
; }
 8017f84: bf00         	nop
 8017f86: 3708         	adds	r7, #0x8
 8017f88: 46bd         	mov	sp, r7
 8017f8a: bd80         	pop	{r7, pc}

08017f8c <spi_stm32_shift_frames>:
; {
 8017f8c: b580         	push	{r7, lr}
 8017f8e: b084         	sub	sp, #0x10
 8017f90: af00         	add	r7, sp, #0x0
 8017f92: 6078         	str	r0, [r7, #0x4]
 8017f94: 6039         	str	r1, [r7]
; 	uint16_t operation = data->ctx.config->operation;
 8017f96: 683b         	ldr	r3, [r7]
 8017f98: 681b         	ldr	r3, [r3]
 8017f9a: 889b         	ldrh	r3, [r3, #0x4]
 8017f9c: 81fb         	strh	r3, [r7, #0xe]
; 	if (SPI_OP_MODE_GET(operation) == SPI_OP_MODE_MASTER) {
 8017f9e: 89fb         	ldrh	r3, [r7, #0xe]
 8017fa0: f003 0301    	and	r3, r3, #0x1
 8017fa4: 2b00         	cmp	r3, #0x0
 8017fa6: d104         	bne	0x8017fb2 <spi_stm32_shift_frames+0x26> @ imm = #0x8
; 		spi_stm32_shift_m(cfg, data);
 8017fa8: 6839         	ldr	r1, [r7]
 8017faa: 6878         	ldr	r0, [r7, #0x4]
 8017fac: f7ff ffbc    	bl	0x8017f28 <spi_stm32_shift_m> @ imm = #-0x88
 8017fb0: e005         	b	0x8017fbe <spi_stm32_shift_frames+0x32> @ imm = #0xa
; 		spi_stm32_shift_s(cfg->spi, data);
 8017fb2: 687b         	ldr	r3, [r7, #0x4]
 8017fb4: 681b         	ldr	r3, [r3]
 8017fb6: 6839         	ldr	r1, [r7]
 8017fb8: 4618         	mov	r0, r3
 8017fba: f7f1 fbbf    	bl	0x800973c <spi_stm32_shift_s> @ imm = #-0xe882
; 	return spi_stm32_get_err(cfg->spi);
 8017fbe: 687b         	ldr	r3, [r7, #0x4]
 8017fc0: 681b         	ldr	r3, [r3]
 8017fc2: 4618         	mov	r0, r3
 8017fc4: f7f1 fb76    	bl	0x80096b4 <spi_stm32_get_err> @ imm = #-0xe914
 8017fc8: 4603         	mov	r3, r0
; }
 8017fca: 4618         	mov	r0, r3
 8017fcc: 3710         	adds	r7, #0x10
 8017fce: 46bd         	mov	sp, r7
 8017fd0: bd80         	pop	{r7, pc}

08017fd2 <spi_stm32_cs_control>:
; {
 8017fd2: b580         	push	{r7, lr}
 8017fd4: b084         	sub	sp, #0x10
 8017fd6: af00         	add	r7, sp, #0x0
 8017fd8: 6078         	str	r0, [r7, #0x4]
 8017fda: 460b         	mov	r3, r1
 8017fdc: 70fb         	strb	r3, [r7, #0x3]
; 	struct spi_stm32_data *data = dev->data;
 8017fde: 687b         	ldr	r3, [r7, #0x4]
 8017fe0: 691b         	ldr	r3, [r3, #0x10]
 8017fe2: 60fb         	str	r3, [r7, #0xc]
; 	spi_context_cs_control(&data->ctx, on);
 8017fe4: 68fb         	ldr	r3, [r7, #0xc]
 8017fe6: 78fa         	ldrb	r2, [r7, #0x3]
 8017fe8: 4611         	mov	r1, r2
 8017fea: 4618         	mov	r0, r3
 8017fec: f7ff fea7    	bl	0x8017d3e <spi_context_cs_control> @ imm = #-0x2b2
; }
 8017ff0: bf00         	nop
 8017ff2: 3710         	adds	r7, #0x10
 8017ff4: 46bd         	mov	sp, r7
 8017ff6: bd80         	pop	{r7, pc}

08017ff8 <spi_stm32_complete>:
; {
 8017ff8: b580         	push	{r7, lr}
 8017ffa: b086         	sub	sp, #0x18
 8017ffc: af00         	add	r7, sp, #0x0
 8017ffe: 6078         	str	r0, [r7, #0x4]
 8018000: 6039         	str	r1, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 8018002: 687b         	ldr	r3, [r7, #0x4]
 8018004: 685b         	ldr	r3, [r3, #0x4]
 8018006: 617b         	str	r3, [r7, #0x14]
; 	SPI_TypeDef *spi = cfg->spi;
 8018008: 697b         	ldr	r3, [r7, #0x14]
 801800a: 681b         	ldr	r3, [r3]
 801800c: 613b         	str	r3, [r7, #0x10]
; 	struct spi_stm32_data *data = dev->data;
 801800e: 687b         	ldr	r3, [r7, #0x4]
 8018010: 691b         	ldr	r3, [r3, #0x10]
 8018012: 60fb         	str	r3, [r7, #0xc]
; 	if (LL_SPI_GetMode(spi) == LL_SPI_MODE_MASTER) {
 8018014: 6938         	ldr	r0, [r7, #0x10]
 8018016: f7ff faf1    	bl	0x80175fc <LL_SPI_GetMode> @ imm = #-0xa1e
 801801a: 4603         	mov	r3, r0
 801801c: f5b3 7f82    	cmp.w	r3, #0x104
 8018020: d10a         	bne	0x8018038 <spi_stm32_complete+0x40> @ imm = #0x14
; 		while (ll_func_spi_is_busy(spi)) {
 8018022: bf00         	nop
 8018024: 6938         	ldr	r0, [r7, #0x10]
 8018026: f7ff ff0c    	bl	0x8017e42 <ll_func_spi_is_busy> @ imm = #-0x1e8
 801802a: 4603         	mov	r3, r0
 801802c: 2b00         	cmp	r3, #0x0
 801802e: d1f9         	bne	0x8018024 <spi_stm32_complete+0x2c> @ imm = #-0xe
; 		spi_stm32_cs_control(dev, false);
 8018030: 2100         	movs	r1, #0x0
 8018032: 6878         	ldr	r0, [r7, #0x4]
 8018034: f7ff ffcd    	bl	0x8017fd2 <spi_stm32_cs_control> @ imm = #-0x66
; 	if (LL_SPI_IsActiveFlag_MODF(spi)) {
 8018038: 6938         	ldr	r0, [r7, #0x10]
 801803a: f7ff fbb8    	bl	0x80177ae <LL_SPI_IsActiveFlag_MODF> @ imm = #-0x890
 801803e: 4603         	mov	r3, r0
 8018040: 2b00         	cmp	r3, #0x0
 8018042: d002         	beq	0x801804a <spi_stm32_complete+0x52> @ imm = #0x4
; 		LL_SPI_ClearFlag_MODF(spi);
 8018044: 6938         	ldr	r0, [r7, #0x10]
 8018046: f7ff fbe8    	bl	0x801781a <LL_SPI_ClearFlag_MODF> @ imm = #-0x830
; 	if (!(data->ctx.config->operation & SPI_HOLD_ON_CS)) {
 801804a: 68fb         	ldr	r3, [r7, #0xc]
 801804c: 681b         	ldr	r3, [r3]
 801804e: 889b         	ldrh	r3, [r3, #0x4]
 8018050: f403 5380    	and	r3, r3, #0x1000
 8018054: 2b00         	cmp	r3, #0x0
 8018056: d102         	bne	0x801805e <spi_stm32_complete+0x66> @ imm = #0x4
; 		ll_func_disable_spi(spi);
 8018058: 6938         	ldr	r0, [r7, #0x10]
 801805a: f7ff fefe    	bl	0x8017e5a <ll_func_disable_spi> @ imm = #-0x204
; 	spi_stm32_pm_policy_state_lock_put(dev);
 801805e: 6878         	ldr	r0, [r7, #0x4]
 8018060: f7ff ff17    	bl	0x8017e92 <spi_stm32_pm_policy_state_lock_put> @ imm = #-0x1d2
; }
 8018064: bf00         	nop
 8018066: 3718         	adds	r7, #0x18
 8018068: 46bd         	mov	sp, r7
 801806a: bd80         	pop	{r7, pc}

0801806c <spi_stm32_release>:
; {
 801806c: b580         	push	{r7, lr}
 801806e: b084         	sub	sp, #0x10
 8018070: af00         	add	r7, sp, #0x0
 8018072: 6078         	str	r0, [r7, #0x4]
 8018074: 6039         	str	r1, [r7]
; 	struct spi_stm32_data *data = dev->data;
 8018076: 687b         	ldr	r3, [r7, #0x4]
 8018078: 691b         	ldr	r3, [r3, #0x10]
 801807a: 60fb         	str	r3, [r7, #0xc]
; 	const struct spi_stm32_config *cfg = dev->config;
 801807c: 687b         	ldr	r3, [r7, #0x4]
 801807e: 685b         	ldr	r3, [r3, #0x4]
 8018080: 60bb         	str	r3, [r7, #0x8]
; 	spi_context_unlock_unconditionally(&data->ctx);
 8018082: 68fb         	ldr	r3, [r7, #0xc]
 8018084: 4618         	mov	r0, r3
 8018086: f7ff fe6a    	bl	0x8017d5e <spi_context_unlock_unconditionally> @ imm = #-0x32c
; 	ll_func_disable_spi(cfg->spi);
 801808a: 68bb         	ldr	r3, [r7, #0x8]
 801808c: 681b         	ldr	r3, [r3]
 801808e: 4618         	mov	r0, r3
 8018090: f7ff fee3    	bl	0x8017e5a <ll_func_disable_spi> @ imm = #-0x23a
; 	return 0;
 8018094: 2300         	movs	r3, #0x0
; }
 8018096: 4618         	mov	r0, r3
 8018098: 3710         	adds	r7, #0x10
 801809a: 46bd         	mov	sp, r7
 801809c: bd80         	pop	{r7, pc}

0801809e <transceive>:
; {
 801809e: b580         	push	{r7, lr}
 80180a0: b08a         	sub	sp, #0x28
 80180a2: af02         	add	r7, sp, #0x8
 80180a4: 60f8         	str	r0, [r7, #0xc]
 80180a6: 60b9         	str	r1, [r7, #0x8]
 80180a8: 607a         	str	r2, [r7, #0x4]
 80180aa: 603b         	str	r3, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 80180ac: 68fb         	ldr	r3, [r7, #0xc]
 80180ae: 685b         	ldr	r3, [r3, #0x4]
 80180b0: 61bb         	str	r3, [r7, #0x18]
; 	struct spi_stm32_data *data = dev->data;
 80180b2: 68fb         	ldr	r3, [r7, #0xc]
 80180b4: 691b         	ldr	r3, [r3, #0x10]
 80180b6: 617b         	str	r3, [r7, #0x14]
; 	SPI_TypeDef *spi = cfg->spi;
 80180b8: 69bb         	ldr	r3, [r7, #0x18]
 80180ba: 681b         	ldr	r3, [r3]
 80180bc: 613b         	str	r3, [r7, #0x10]
; 	if (!tx_bufs && !rx_bufs) {
 80180be: 687b         	ldr	r3, [r7, #0x4]
 80180c0: 2b00         	cmp	r3, #0x0
 80180c2: d104         	bne	0x80180ce <transceive+0x30> @ imm = #0x8
 80180c4: 683b         	ldr	r3, [r7]
 80180c6: 2b00         	cmp	r3, #0x0
 80180c8: d101         	bne	0x80180ce <transceive+0x30> @ imm = #0x2
; 		return 0;
 80180ca: 2300         	movs	r3, #0x0
 80180cc: e04f         	b	0x801816e <transceive+0xd0> @ imm = #0x9e
; 	if (asynchronous) {
 80180ce: f897 3028    	ldrb.w	r3, [r7, #0x28]
 80180d2: 2b00         	cmp	r3, #0x0
 80180d4: d002         	beq	0x80180dc <transceive+0x3e> @ imm = #0x4
; 		return -ENOTSUP;
 80180d6: f06f 0385    	mvn	r3, #0x85
 80180da: e048         	b	0x801816e <transceive+0xd0> @ imm = #0x90
; 	spi_context_lock(&data->ctx, asynchronous, cb, userdata, config);
 80180dc: 6978         	ldr	r0, [r7, #0x14]
 80180de: f897 1028    	ldrb.w	r1, [r7, #0x28]
 80180e2: 68bb         	ldr	r3, [r7, #0x8]
 80180e4: 9300         	str	r3, [sp]
 80180e6: 6b3b         	ldr	r3, [r7, #0x30]
 80180e8: 6afa         	ldr	r2, [r7, #0x2c]
 80180ea: f7ff fda0    	bl	0x8017c2e <spi_context_lock> @ imm = #-0x4c0
; 	spi_stm32_pm_policy_state_lock_get(dev);
 80180ee: 68f8         	ldr	r0, [r7, #0xc]
 80180f0: f7ff fec6    	bl	0x8017e80 <spi_stm32_pm_policy_state_lock_get> @ imm = #-0x274
; 	ret = spi_stm32_configure(dev, config);
 80180f4: 68b9         	ldr	r1, [r7, #0x8]
 80180f6: 68f8         	ldr	r0, [r7, #0xc]
 80180f8: f7f1 fddc    	bl	0x8009cb4 <spi_stm32_configure> @ imm = #-0xe448
 80180fc: 61f8         	str	r0, [r7, #0x1c]
; 	if (ret) {
 80180fe: 69fb         	ldr	r3, [r7, #0x1c]
 8018100: 2b00         	cmp	r3, #0x0
 8018102: d12d         	bne	0x8018160 <transceive+0xc2> @ imm = #0x5a
; 	if (SPI_WORD_SIZE_GET(config->operation) == 8) {
 8018104: 68bb         	ldr	r3, [r7, #0x8]
 8018106: 889b         	ldrh	r3, [r3, #0x4]
 8018108: 095b         	lsrs	r3, r3, #0x5
 801810a: f003 033f    	and	r3, r3, #0x3f
 801810e: 2b08         	cmp	r3, #0x8
 8018110: d106         	bne	0x8018120 <transceive+0x82> @ imm = #0xc
; 		spi_context_buffers_setup(&data->ctx, tx_bufs, rx_bufs, 1);
 8018112: 6978         	ldr	r0, [r7, #0x14]
 8018114: 2301         	movs	r3, #0x1
 8018116: 683a         	ldr	r2, [r7]
 8018118: 6879         	ldr	r1, [r7, #0x4]
 801811a: f7f0 ff3b    	bl	0x8008f94 <spi_context_buffers_setup> @ imm = #-0xf18a
 801811e: e005         	b	0x801812c <transceive+0x8e> @ imm = #0xa
; 		spi_context_buffers_setup(&data->ctx, tx_bufs, rx_bufs, 2);
 8018120: 6978         	ldr	r0, [r7, #0x14]
 8018122: 2302         	movs	r3, #0x2
 8018124: 683a         	ldr	r2, [r7]
 8018126: 6879         	ldr	r1, [r7, #0x4]
 8018128: f7f0 ff34    	bl	0x8008f94 <spi_context_buffers_setup> @ imm = #-0xf198
; 	LL_SPI_Enable(spi);
 801812c: 6938         	ldr	r0, [r7, #0x10]
 801812e: f7ff fa23    	bl	0x8017578 <LL_SPI_Enable> @ imm = #-0xbba
; 	spi_stm32_cs_control(dev, true);
 8018132: 2101         	movs	r1, #0x1
 8018134: 68f8         	ldr	r0, [r7, #0xc]
 8018136: f7ff ff4c    	bl	0x8017fd2 <spi_stm32_cs_control> @ imm = #-0x168
; 		ret = spi_stm32_shift_frames(cfg, data);
 801813a: 6979         	ldr	r1, [r7, #0x14]
 801813c: 69b8         	ldr	r0, [r7, #0x18]
 801813e: f7ff ff25    	bl	0x8017f8c <spi_stm32_shift_frames> @ imm = #-0x1b6
 8018142: 61f8         	str	r0, [r7, #0x1c]
; 	} while (!ret && spi_stm32_transfer_ongoing(data));
 8018144: 69fb         	ldr	r3, [r7, #0x1c]
 8018146: 2b00         	cmp	r3, #0x0
 8018148: d105         	bne	0x8018156 <transceive+0xb8> @ imm = #0xa
 801814a: 6978         	ldr	r0, [r7, #0x14]
 801814c: f7ff feaa    	bl	0x8017ea4 <spi_stm32_transfer_ongoing> @ imm = #-0x2ac
 8018150: 4603         	mov	r3, r0
 8018152: 2b00         	cmp	r3, #0x0
 8018154: d1f1         	bne	0x801813a <transceive+0x9c> @ imm = #-0x1e
; 	spi_stm32_complete(dev, ret);
 8018156: 69f9         	ldr	r1, [r7, #0x1c]
 8018158: 68f8         	ldr	r0, [r7, #0xc]
 801815a: f7ff ff4d    	bl	0x8017ff8 <spi_stm32_complete> @ imm = #-0x166
 801815e: e000         	b	0x8018162 <transceive+0xc4> @ imm = #0x0
; 		goto end;
 8018160: bf00         	nop
; 	spi_context_release(&data->ctx, ret);
 8018162: 697b         	ldr	r3, [r7, #0x14]
 8018164: 69f9         	ldr	r1, [r7, #0x1c]
 8018166: 4618         	mov	r0, r3
 8018168: f7ff fd8d    	bl	0x8017c86 <spi_context_release> @ imm = #-0x4e6
; 	return ret;
 801816c: 69fb         	ldr	r3, [r7, #0x1c]
; }
 801816e: 4618         	mov	r0, r3
 8018170: 3720         	adds	r7, #0x20
 8018172: 46bd         	mov	sp, r7
 8018174: bd80         	pop	{r7, pc}

08018176 <spi_stm32_transceive>:
; {
 8018176: b580         	push	{r7, lr}
 8018178: b088         	sub	sp, #0x20
 801817a: af04         	add	r7, sp, #0x10
 801817c: 60f8         	str	r0, [r7, #0xc]
 801817e: 60b9         	str	r1, [r7, #0x8]
 8018180: 607a         	str	r2, [r7, #0x4]
 8018182: 603b         	str	r3, [r7]
; 	return transceive(dev, config, tx_bufs, rx_bufs, false, NULL, NULL);
 8018184: 2300         	movs	r3, #0x0
 8018186: 9302         	str	r3, [sp, #0x8]
 8018188: 2300         	movs	r3, #0x0
 801818a: 9301         	str	r3, [sp, #0x4]
 801818c: 2300         	movs	r3, #0x0
 801818e: 9300         	str	r3, [sp]
 8018190: 683b         	ldr	r3, [r7]
 8018192: 687a         	ldr	r2, [r7, #0x4]
 8018194: 68b9         	ldr	r1, [r7, #0x8]
 8018196: 68f8         	ldr	r0, [r7, #0xc]
 8018198: f7ff ff81    	bl	0x801809e <transceive>  @ imm = #-0xfe
 801819c: 4603         	mov	r3, r0
; }
 801819e: 4618         	mov	r0, r3
 80181a0: 3710         	adds	r7, #0x10
 80181a2: 46bd         	mov	sp, r7
 80181a4: bd80         	pop	{r7, pc}

080181a6 <spi_stm32_is_subghzspi>:
; {
 80181a6: b480         	push	{r7}
 80181a8: b083         	sub	sp, #0xc
 80181aa: af00         	add	r7, sp, #0x0
 80181ac: 6078         	str	r0, [r7, #0x4]
; 	return false;
 80181ae: 2300         	movs	r3, #0x0
; }
 80181b0: 4618         	mov	r0, r3
 80181b2: 370c         	adds	r7, #0xc
 80181b4: 46bd         	mov	sp, r7
 80181b6: bc80         	pop	{r7}
 80181b8: 4770         	bx	lr

080181ba <device_is_ready>:
; {
 80181ba: b580         	push	{r7, lr}
 80181bc: b082         	sub	sp, #0x8
 80181be: af00         	add	r7, sp, #0x0
 80181c0: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80181c2: 6878         	ldr	r0, [r7, #0x4]
 80181c4: f000 fb37    	bl	0x8018836 <z_impl_device_is_ready> @ imm = #0x66e
 80181c8: 4603         	mov	r3, r0
; }
 80181ca: 4618         	mov	r0, r3
 80181cc: 3708         	adds	r7, #0x8
 80181ce: 46bd         	mov	sp, r7
 80181d0: bd80         	pop	{r7, pc}

080181d2 <arch_k_cycle_get_32>:
; {
 80181d2: b580         	push	{r7, lr}
 80181d4: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 80181d6: f7f2 f9ad    	bl	0x800a534 <sys_clock_cycle_get_32> @ imm = #-0xdca6
 80181da: 4603         	mov	r3, r0
; }
 80181dc: 4618         	mov	r0, r3
 80181de: bd80         	pop	{r7, pc}

080181e0 <z_impl_k_timer_user_data_set>:
; {
 80181e0: b480         	push	{r7}
 80181e2: b083         	sub	sp, #0xc
 80181e4: af00         	add	r7, sp, #0x0
 80181e6: 6078         	str	r0, [r7, #0x4]
 80181e8: 6039         	str	r1, [r7]
; 	timer->user_data = user_data;
 80181ea: 687b         	ldr	r3, [r7, #0x4]
 80181ec: 683a         	ldr	r2, [r7]
 80181ee: 635a         	str	r2, [r3, #0x34]
; }
 80181f0: bf00         	nop
 80181f2: 370c         	adds	r7, #0xc
 80181f4: 46bd         	mov	sp, r7
 80181f6: bc80         	pop	{r7}
 80181f8: 4770         	bx	lr

080181fa <z_impl_k_timer_user_data_get>:
; {
 80181fa: b480         	push	{r7}
 80181fc: b083         	sub	sp, #0xc
 80181fe: af00         	add	r7, sp, #0x0
 8018200: 6078         	str	r0, [r7, #0x4]
; 	return timer->user_data;
 8018202: 687b         	ldr	r3, [r7, #0x4]
 8018204: 6b5b         	ldr	r3, [r3, #0x34]
; }
 8018206: 4618         	mov	r0, r3
 8018208: 370c         	adds	r7, #0xc
 801820a: 46bd         	mov	sp, r7
 801820c: bc80         	pop	{r7}
 801820e: 4770         	bx	lr

08018210 <k_cycle_get_32>:
; {
 8018210: b580         	push	{r7, lr}
 8018212: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 8018214: f7ff ffdd    	bl	0x80181d2 <arch_k_cycle_get_32> @ imm = #-0x46
 8018218: 4603         	mov	r3, r0
; }
 801821a: 4618         	mov	r0, r3
 801821c: bd80         	pop	{r7, pc}

0801821e <k_sleep>:
; {
 801821e: b580         	push	{r7, lr}
 8018220: b082         	sub	sp, #0x8
 8018222: af00         	add	r7, sp, #0x0
 8018224: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8018228: e9d7 0100    	ldrd	r0, r1, [r7]
 801822c: f7f6 fe84    	bl	0x800ef38 <z_impl_k_sleep> @ imm = #-0x92f8
 8018230: 4603         	mov	r3, r0
; }
 8018232: 4618         	mov	r0, r3
 8018234: 3708         	adds	r7, #0x8
 8018236: 46bd         	mov	sp, r7
 8018238: bd80         	pop	{r7, pc}

0801823a <k_timer_start>:
; {
 801823a: b580         	push	{r7, lr}
 801823c: b086         	sub	sp, #0x18
 801823e: af02         	add	r7, sp, #0x8
 8018240: 60f8         	str	r0, [r7, #0xc]
 8018242: e9c7 2300    	strd	r2, r3, [r7]
; 	z_impl_k_timer_start(timer, duration, period);
 8018246: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 801824a: e9cd 2300    	strd	r2, r3, [sp]
 801824e: e9d7 2300    	ldrd	r2, r3, [r7]
 8018252: 68f8         	ldr	r0, [r7, #0xc]
 8018254: f7f7 fe64    	bl	0x800ff20 <z_impl_k_timer_start> @ imm = #-0x8338
; }
 8018258: bf00         	nop
 801825a: 3710         	adds	r7, #0x10
 801825c: 46bd         	mov	sp, r7
 801825e: bd80         	pop	{r7, pc}

08018260 <k_timer_user_data_set>:
; {
 8018260: b580         	push	{r7, lr}
 8018262: b082         	sub	sp, #0x8
 8018264: af00         	add	r7, sp, #0x0
 8018266: 6078         	str	r0, [r7, #0x4]
 8018268: 6039         	str	r1, [r7]
; 	z_impl_k_timer_user_data_set(timer, user_data);
 801826a: 6839         	ldr	r1, [r7]
 801826c: 6878         	ldr	r0, [r7, #0x4]
 801826e: f7ff ffb7    	bl	0x80181e0 <z_impl_k_timer_user_data_set> @ imm = #-0x92
; }
 8018272: bf00         	nop
 8018274: 3708         	adds	r7, #0x8
 8018276: 46bd         	mov	sp, r7
 8018278: bd80         	pop	{r7, pc}

0801827a <k_timer_user_data_get>:
; {
 801827a: b580         	push	{r7, lr}
 801827c: b082         	sub	sp, #0x8
 801827e: af00         	add	r7, sp, #0x0
 8018280: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_timer_user_data_get(timer);
 8018282: 6878         	ldr	r0, [r7, #0x4]
 8018284: f7ff ffb9    	bl	0x80181fa <z_impl_k_timer_user_data_get> @ imm = #-0x8e
 8018288: 4603         	mov	r3, r0
; }
 801828a: 4618         	mov	r0, r3
 801828c: 3708         	adds	r7, #0x8
 801828e: 46bd         	mov	sp, r7
 8018290: bd80         	pop	{r7, pc}

08018292 <k_sem_init>:
; {
 8018292: b580         	push	{r7, lr}
 8018294: b084         	sub	sp, #0x10
 8018296: af00         	add	r7, sp, #0x0
 8018298: 60f8         	str	r0, [r7, #0xc]
 801829a: 60b9         	str	r1, [r7, #0x8]
 801829c: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 801829e: 687a         	ldr	r2, [r7, #0x4]
 80182a0: 68b9         	ldr	r1, [r7, #0x8]
 80182a2: 68f8         	ldr	r0, [r7, #0xc]
 80182a4: f000 ff85    	bl	0x80191b2 <z_impl_k_sem_init> @ imm = #0xf0a
 80182a8: 4603         	mov	r3, r0
; }
 80182aa: 4618         	mov	r0, r3
 80182ac: 3710         	adds	r7, #0x10
 80182ae: 46bd         	mov	sp, r7
 80182b0: bd80         	pop	{r7, pc}

080182b2 <k_sem_take>:
; {
 80182b2: b580         	push	{r7, lr}
 80182b4: b084         	sub	sp, #0x10
 80182b6: af00         	add	r7, sp, #0x0
 80182b8: 60f8         	str	r0, [r7, #0xc]
 80182ba: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 80182be: e9d7 2300    	ldrd	r2, r3, [r7]
 80182c2: 68f8         	ldr	r0, [r7, #0xc]
 80182c4: f7f4 fe0e    	bl	0x800cee4 <z_impl_k_sem_take> @ imm = #-0xb3e4
 80182c8: 4603         	mov	r3, r0
; }
 80182ca: 4618         	mov	r0, r3
 80182cc: 3710         	adds	r7, #0x10
 80182ce: 46bd         	mov	sp, r7
 80182d0: bd80         	pop	{r7, pc}

080182d2 <k_sem_give>:
; {
 80182d2: b580         	push	{r7, lr}
 80182d4: b082         	sub	sp, #0x8
 80182d6: af00         	add	r7, sp, #0x0
 80182d8: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 80182da: 6878         	ldr	r0, [r7, #0x4]
 80182dc: f7f4 fd74    	bl	0x800cdc8 <z_impl_k_sem_give> @ imm = #-0xb518
; }
 80182e0: bf00         	nop
 80182e2: 3708         	adds	r7, #0x8
 80182e4: 46bd         	mov	sp, r7
 80182e6: bd80         	pop	{r7, pc}

080182e8 <k_msgq_put>:
; {
 80182e8: b580         	push	{r7, lr}
 80182ea: b084         	sub	sp, #0x10
 80182ec: af00         	add	r7, sp, #0x0
 80182ee: 60f8         	str	r0, [r7, #0xc]
 80182f0: 60b9         	str	r1, [r7, #0x8]
 80182f2: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_msgq_put(msgq, data, timeout);
 80182f6: e9d7 2300    	ldrd	r2, r3, [r7]
 80182fa: 68b9         	ldr	r1, [r7, #0x8]
 80182fc: 68f8         	ldr	r0, [r7, #0xc]
 80182fe: f7f4 f81d    	bl	0x800c33c <z_impl_k_msgq_put> @ imm = #-0xbfc6
 8018302: 4603         	mov	r3, r0
; }
 8018304: 4618         	mov	r0, r3
 8018306: 3710         	adds	r7, #0x10
 8018308: 46bd         	mov	sp, r7
 801830a: bd80         	pop	{r7, pc}

0801830c <k_msgq_get>:
; {
 801830c: b580         	push	{r7, lr}
 801830e: b084         	sub	sp, #0x10
 8018310: af00         	add	r7, sp, #0x0
 8018312: 60f8         	str	r0, [r7, #0xc]
 8018314: 60b9         	str	r1, [r7, #0x8]
 8018316: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_msgq_get(msgq, data, timeout);
 801831a: e9d7 2300    	ldrd	r2, r3, [r7]
 801831e: 68b9         	ldr	r1, [r7, #0x8]
 8018320: 68f8         	ldr	r0, [r7, #0xc]
 8018322: f7f4 f8d7    	bl	0x800c4d4 <z_impl_k_msgq_get> @ imm = #-0xbe52
 8018326: 4603         	mov	r3, r0
; }
 8018328: 4618         	mov	r0, r3
 801832a: 3710         	adds	r7, #0x10
 801832c: 46bd         	mov	sp, r7
 801832e: bd80         	pop	{r7, pc}

08018330 <k_msgq_purge>:
; {
 8018330: b580         	push	{r7, lr}
 8018332: b082         	sub	sp, #0x8
 8018334: af00         	add	r7, sp, #0x0
 8018336: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_msgq_purge(msgq);
 8018338: 6878         	ldr	r0, [r7, #0x4]
 801833a: f000 fc59    	bl	0x8018bf0 <z_impl_k_msgq_purge> @ imm = #0x8b2
; }
 801833e: bf00         	nop
 8018340: 3708         	adds	r7, #0x8
 8018342: 46bd         	mov	sp, r7
 8018344: bd80         	pop	{r7, pc}

08018346 <z_log_msg_runtime_create>:
; {
 8018346: b580         	push	{r7, lr}
 8018348: b08a         	sub	sp, #0x28
 801834a: af04         	add	r7, sp, #0x10
 801834c: 60b9         	str	r1, [r7, #0x8]
 801834e: 607b         	str	r3, [r7, #0x4]
 8018350: 4603         	mov	r3, r0
 8018352: 73fb         	strb	r3, [r7, #0xf]
 8018354: 4613         	mov	r3, r2
 8018356: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8018358: f107 032c    	add.w	r3, r7, #0x2c
 801835c: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801835e: 7bba         	ldrb	r2, [r7, #0xe]
 8018360: 7bf8         	ldrb	r0, [r7, #0xf]
 8018362: 697b         	ldr	r3, [r7, #0x14]
 8018364: 9303         	str	r3, [sp, #0xc]
 8018366: 6abb         	ldr	r3, [r7, #0x28]
 8018368: 9302         	str	r3, [sp, #0x8]
 801836a: 6a7b         	ldr	r3, [r7, #0x24]
 801836c: 9301         	str	r3, [sp, #0x4]
 801836e: 6a3b         	ldr	r3, [r7, #0x20]
 8018370: 9300         	str	r3, [sp]
 8018372: 687b         	ldr	r3, [r7, #0x4]
 8018374: 68b9         	ldr	r1, [r7, #0x8]
 8018376: f7e9 fc79    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x1670e
; }
 801837a: bf00         	nop
 801837c: 3718         	adds	r7, #0x18
 801837e: 46bd         	mov	sp, r7
 8018380: bd80         	pop	{r7, pc}

08018382 <z_impl_pid_get_params>:
; static inline const struct pid_single_config *z_impl_pid_get_params(const struct device *dev) {
 8018382: b580         	push	{r7, lr}
 8018384: b084         	sub	sp, #0x10
 8018386: af00         	add	r7, sp, #0x0
 8018388: 6078         	str	r0, [r7, #0x4]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 801838a: 687b         	ldr	r3, [r7, #0x4]
 801838c: 689b         	ldr	r3, [r3, #0x8]
 801838e: 60fb         	str	r3, [r7, #0xc]
;     if (api->pid_get_params != NULL) {
 8018390: 68fb         	ldr	r3, [r7, #0xc]
 8018392: 695b         	ldr	r3, [r3, #0x14]
 8018394: 2b00         	cmp	r3, #0x0
 8018396: d005         	beq	0x80183a4 <z_impl_pid_get_params+0x22> @ imm = #0xa
;         return api->pid_get_params(dev);
 8018398: 68fb         	ldr	r3, [r7, #0xc]
 801839a: 695b         	ldr	r3, [r3, #0x14]
 801839c: 6878         	ldr	r0, [r7, #0x4]
 801839e: 4798         	blx	r3
 80183a0: 4603         	mov	r3, r0
 80183a2: e000         	b	0x80183a6 <z_impl_pid_get_params+0x24> @ imm = #0x0
;     return NULL;
 80183a4: 2300         	movs	r3, #0x0
; }
 80183a6: 4618         	mov	r0, r3
 80183a8: 3710         	adds	r7, #0x10
 80183aa: 46bd         	mov	sp, r7
 80183ac: bd80         	pop	{r7, pc}

080183ae <pid_get_params>:
; {
 80183ae: b580         	push	{r7, lr}
 80183b0: b082         	sub	sp, #0x8
 80183b2: af00         	add	r7, sp, #0x0
 80183b4: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_pid_get_params(dev);
 80183b6: 6878         	ldr	r0, [r7, #0x4]
 80183b8: f7ff ffe3    	bl	0x8018382 <z_impl_pid_get_params> @ imm = #-0x3a
 80183bc: 4603         	mov	r3, r0
; }
 80183be: 4618         	mov	r0, r3
 80183c0: 3708         	adds	r7, #0x8
 80183c2: 46bd         	mov	sp, r7
 80183c4: bd80         	pop	{r7, pc}

080183c6 <z_impl_can_start>:
; {
 80183c6: b580         	push	{r7, lr}
 80183c8: b084         	sub	sp, #0x10
 80183ca: af00         	add	r7, sp, #0x0
 80183cc: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 80183ce: 687b         	ldr	r3, [r7, #0x4]
 80183d0: 689b         	ldr	r3, [r3, #0x8]
 80183d2: 60fb         	str	r3, [r7, #0xc]
; 	return api->start(dev);
 80183d4: 68fb         	ldr	r3, [r7, #0xc]
 80183d6: 685b         	ldr	r3, [r3, #0x4]
 80183d8: 6878         	ldr	r0, [r7, #0x4]
 80183da: 4798         	blx	r3
 80183dc: 4603         	mov	r3, r0
; }
 80183de: 4618         	mov	r0, r3
 80183e0: 3710         	adds	r7, #0x10
 80183e2: 46bd         	mov	sp, r7
 80183e4: bd80         	pop	{r7, pc}

080183e6 <can_start>:
; {
 80183e6: b580         	push	{r7, lr}
 80183e8: b082         	sub	sp, #0x8
 80183ea: af00         	add	r7, sp, #0x0
 80183ec: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_start(dev);
 80183ee: 6878         	ldr	r0, [r7, #0x4]
 80183f0: f7ff ffe9    	bl	0x80183c6 <z_impl_can_start> @ imm = #-0x2e
 80183f4: 4603         	mov	r3, r0
; }
 80183f6: 4618         	mov	r0, r3
 80183f8: 3708         	adds	r7, #0x8
 80183fa: 46bd         	mov	sp, r7
 80183fc: bd80         	pop	{r7, pc}

080183fe <can_send>:
; {
 80183fe: b580         	push	{r7, lr}
 8018400: b086         	sub	sp, #0x18
 8018402: af02         	add	r7, sp, #0x8
 8018404: 60f8         	str	r0, [r7, #0xc]
 8018406: 60b9         	str	r1, [r7, #0x8]
 8018408: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_can_send(dev, frame, timeout, callback, user_data);
 801840c: 69fb         	ldr	r3, [r7, #0x1c]
 801840e: 9301         	str	r3, [sp, #0x4]
 8018410: 69bb         	ldr	r3, [r7, #0x18]
 8018412: 9300         	str	r3, [sp]
 8018414: e9d7 2300    	ldrd	r2, r3, [r7]
 8018418: 68b9         	ldr	r1, [r7, #0x8]
 801841a: 68f8         	ldr	r0, [r7, #0xc]
 801841c: f7eb fcbe    	bl	0x8003d9c <z_impl_can_send> @ imm = #-0x14684
 8018420: 4603         	mov	r3, r0
; }
 8018422: 4618         	mov	r0, r3
 8018424: 3710         	adds	r7, #0x10
 8018426: 46bd         	mov	sp, r7
 8018428: bd80         	pop	{r7, pc}

0801842a <uint_to_float>:
; {
 801842a: b590         	push	{r4, r7, lr}
 801842c: b087         	sub	sp, #0x1c
 801842e: af00         	add	r7, sp, #0x0
 8018430: 60f8         	str	r0, [r7, #0xc]
 8018432: 60b9         	str	r1, [r7, #0x8]
 8018434: 607a         	str	r2, [r7, #0x4]
 8018436: 603b         	str	r3, [r7]
; 	float span = x_max - x_min;
 8018438: 68b9         	ldr	r1, [r7, #0x8]
 801843a: 6878         	ldr	r0, [r7, #0x4]
 801843c: f7e8 f864    	bl	0x8000508 <__subsf3>    @ imm = #-0x17f38
 8018440: 4603         	mov	r3, r0
 8018442: 617b         	str	r3, [r7, #0x14]
; 	float offset = x_min;
 8018444: 68bb         	ldr	r3, [r7, #0x8]
 8018446: 613b         	str	r3, [r7, #0x10]
; 	return ((float)x_int) * span / ((float)((1 << bits) - 1)) + offset;
 8018448: 68f8         	ldr	r0, [r7, #0xc]
 801844a: f7e8 f913    	bl	0x8000674 <__floatsisf> @ imm = #-0x17dda
 801844e: 4603         	mov	r3, r0
 8018450: 6979         	ldr	r1, [r7, #0x14]
 8018452: 4618         	mov	r0, r3
 8018454: f7e8 f962    	bl	0x800071c <__mulsf3>    @ imm = #-0x17d3c
 8018458: 4603         	mov	r3, r0
 801845a: 461c         	mov	r4, r3
 801845c: 2201         	movs	r2, #0x1
 801845e: 683b         	ldr	r3, [r7]
 8018460: fa02 f303    	lsl.w	r3, r2, r3
 8018464: 3b01         	subs	r3, #0x1
 8018466: 4618         	mov	r0, r3
 8018468: f7e8 f904    	bl	0x8000674 <__floatsisf> @ imm = #-0x17df8
 801846c: 4603         	mov	r3, r0
 801846e: 4619         	mov	r1, r3
 8018470: 4620         	mov	r0, r4
 8018472: f7e8 fa07    	bl	0x8000884 <__divsf3>    @ imm = #-0x17bf2
 8018476: 4603         	mov	r3, r0
 8018478: 6939         	ldr	r1, [r7, #0x10]
 801847a: 4618         	mov	r0, r3
 801847c: f7e8 f846    	bl	0x800050c <__aeabi_fadd> @ imm = #-0x17f74
 8018480: 4603         	mov	r3, r0
; }
 8018482: 4618         	mov	r0, r3
 8018484: 371c         	adds	r7, #0x1c
 8018486: 46bd         	mov	sp, r7
 8018488: bd90         	pop	{r4, r7, pc}

0801848a <float_to_uint>:
; {
 801848a: b590         	push	{r4, r7, lr}
 801848c: b087         	sub	sp, #0x1c
 801848e: af00         	add	r7, sp, #0x0
 8018490: 60f8         	str	r0, [r7, #0xc]
 8018492: 60b9         	str	r1, [r7, #0x8]
 8018494: 607a         	str	r2, [r7, #0x4]
 8018496: 603b         	str	r3, [r7]
; 	float span = x_max - x_min;
 8018498: 68b9         	ldr	r1, [r7, #0x8]
 801849a: 6878         	ldr	r0, [r7, #0x4]
 801849c: f7e8 f834    	bl	0x8000508 <__subsf3>    @ imm = #-0x17f98
 80184a0: 4603         	mov	r3, r0
 80184a2: 617b         	str	r3, [r7, #0x14]
; 	float offset = x_min;
 80184a4: 68bb         	ldr	r3, [r7, #0x8]
 80184a6: 613b         	str	r3, [r7, #0x10]
; 	return (int)((x - offset) * ((float)((1 << bits) - 1)) / span);
 80184a8: 6939         	ldr	r1, [r7, #0x10]
 80184aa: 68f8         	ldr	r0, [r7, #0xc]
 80184ac: f7e8 f82c    	bl	0x8000508 <__subsf3>    @ imm = #-0x17fa8
 80184b0: 4603         	mov	r3, r0
 80184b2: 461c         	mov	r4, r3
 80184b4: 2201         	movs	r2, #0x1
 80184b6: 683b         	ldr	r3, [r7]
 80184b8: fa02 f303    	lsl.w	r3, r2, r3
 80184bc: 3b01         	subs	r3, #0x1
 80184be: 4618         	mov	r0, r3
 80184c0: f7e8 f8d8    	bl	0x8000674 <__floatsisf> @ imm = #-0x17e50
 80184c4: 4603         	mov	r3, r0
 80184c6: 4619         	mov	r1, r3
 80184c8: 4620         	mov	r0, r4
 80184ca: f7e8 f927    	bl	0x800071c <__mulsf3>    @ imm = #-0x17db2
 80184ce: 4603         	mov	r3, r0
 80184d0: 6979         	ldr	r1, [r7, #0x14]
 80184d2: 4618         	mov	r0, r3
 80184d4: f7e8 f9d6    	bl	0x8000884 <__divsf3>    @ imm = #-0x17c54
 80184d8: 4603         	mov	r3, r0
 80184da: 4618         	mov	r0, r3
 80184dc: f7e8 fae4    	bl	0x8000aa8 <__fixsfsi>   @ imm = #-0x17a38
 80184e0: 4603         	mov	r3, r0
; }
 80184e2: 4618         	mov	r0, r3
 80184e4: 371c         	adds	r7, #0x1c
 80184e6: 46bd         	mov	sp, r7
 80184e8: bd90         	pop	{r4, r7, pc}

080184ea <can_tx_callback>:
; {
 80184ea: b580         	push	{r7, lr}
 80184ec: b086         	sub	sp, #0x18
 80184ee: af00         	add	r7, sp, #0x0
 80184f0: 60f8         	str	r0, [r7, #0xc]
 80184f2: 60b9         	str	r1, [r7, #0x8]
 80184f4: 607a         	str	r2, [r7, #0x4]
; 	struct k_sem *queue_sem = user_data;
 80184f6: 687b         	ldr	r3, [r7, #0x4]
 80184f8: 617b         	str	r3, [r7, #0x14]
; 	if (!error) {
 80184fa: 68bb         	ldr	r3, [r7, #0x8]
 80184fc: 2b00         	cmp	r3, #0x0
 80184fe: d102         	bne	0x8018506 <can_tx_callback+0x1c> @ imm = #0x4
; 		k_sem_give(queue_sem);
 8018500: 6978         	ldr	r0, [r7, #0x14]
 8018502: f7ff fee6    	bl	0x80182d2 <k_sem_give>  @ imm = #-0x234
; }
 8018506: bf00         	nop
 8018508: 3718         	adds	r7, #0x18
 801850a: 46bd         	mov	sp, r7
 801850c: bd80         	pop	{r7, pc}

0801850e <dm_motor_get_angle>:
; {
 801850e: b480         	push	{r7}
 8018510: b085         	sub	sp, #0x14
 8018512: af00         	add	r7, sp, #0x0
 8018514: 6078         	str	r0, [r7, #0x4]
; 	struct dm_motor_data *data = dev->data;
 8018516: 687b         	ldr	r3, [r7, #0x4]
 8018518: 691b         	ldr	r3, [r3, #0x10]
 801851a: 60fb         	str	r3, [r7, #0xc]
; 	return data->common.angle;
 801851c: 68fb         	ldr	r3, [r7, #0xc]
 801851e: 681b         	ldr	r3, [r3]
; }
 8018520: 4618         	mov	r0, r3
 8018522: 3714         	adds	r7, #0x14
 8018524: 46bd         	mov	sp, r7
 8018526: bc80         	pop	{r7}
 8018528: 4770         	bx	lr

0801852a <dm_motor_get_speed>:
; {
 801852a: b480         	push	{r7}
 801852c: b085         	sub	sp, #0x14
 801852e: af00         	add	r7, sp, #0x0
 8018530: 6078         	str	r0, [r7, #0x4]
; 	struct dm_motor_data *data = dev->data;
 8018532: 687b         	ldr	r3, [r7, #0x4]
 8018534: 691b         	ldr	r3, [r3, #0x10]
 8018536: 60fb         	str	r3, [r7, #0xc]
; 	return data->common.rpm;
 8018538: 68fb         	ldr	r3, [r7, #0xc]
 801853a: 685b         	ldr	r3, [r3, #0x4]
; }
 801853c: 4618         	mov	r0, r3
 801853e: 3714         	adds	r7, #0x14
 8018540: 46bd         	mov	sp, r7
 8018542: bc80         	pop	{r7}
 8018544: 4770         	bx	lr

08018546 <dm_motor_get_torque>:
; {
 8018546: b480         	push	{r7}
 8018548: b085         	sub	sp, #0x14
 801854a: af00         	add	r7, sp, #0x0
 801854c: 6078         	str	r0, [r7, #0x4]
; 	struct dm_motor_data *data = dev->data;
 801854e: 687b         	ldr	r3, [r7, #0x4]
 8018550: 691b         	ldr	r3, [r3, #0x10]
 8018552: 60fb         	str	r3, [r7, #0xc]
; 	return data->common.torque;
 8018554: 68fb         	ldr	r3, [r7, #0xc]
 8018556: 689b         	ldr	r3, [r3, #0x8]
; }
 8018558: 4618         	mov	r0, r3
 801855a: 3714         	adds	r7, #0x14
 801855c: 46bd         	mov	sp, r7
 801855e: bc80         	pop	{r7}
 8018560: 4770         	bx	lr

08018562 <dm_motor_set_torque>:
; {
 8018562: b580         	push	{r7, lr}
 8018564: b086         	sub	sp, #0x18
 8018566: af00         	add	r7, sp, #0x0
 8018568: 6078         	str	r0, [r7, #0x4]
 801856a: 6039         	str	r1, [r7]
; 	struct dm_motor_data *data = dev->data;
 801856c: 687b         	ldr	r3, [r7, #0x4]
 801856e: 691b         	ldr	r3, [r3, #0x10]
 8018570: 617b         	str	r3, [r7, #0x14]
; 	const struct dm_motor_config *cfg = dev->config;
 8018572: 687b         	ldr	r3, [r7, #0x4]
 8018574: 685b         	ldr	r3, [r3, #0x4]
 8018576: 613b         	str	r3, [r7, #0x10]
; 	data->target_rpm = 0;
 8018578: 697b         	ldr	r3, [r7, #0x14]
 801857a: f04f 0200    	mov.w	r2, #0x0
 801857e: 629a         	str	r2, [r3, #0x28]
; 	data->target_angle = 0;
 8018580: 697b         	ldr	r3, [r7, #0x14]
 8018582: f04f 0200    	mov.w	r2, #0x0
 8018586: 625a         	str	r2, [r3, #0x24]
; 	float torque_scaled = torque / cfg->gear_ratio;
 8018588: 693b         	ldr	r3, [r7, #0x10]
 801858a: 6d1b         	ldr	r3, [r3, #0x50]
 801858c: 4619         	mov	r1, r3
 801858e: 6838         	ldr	r0, [r7]
 8018590: f7e8 f978    	bl	0x8000884 <__divsf3>    @ imm = #-0x17d10
 8018594: 4603         	mov	r3, r0
 8018596: 60fb         	str	r3, [r7, #0xc]
; 	data->target_torque = torque_scaled;
 8018598: 697b         	ldr	r3, [r7, #0x14]
 801859a: 68fa         	ldr	r2, [r7, #0xc]
 801859c: 62da         	str	r2, [r3, #0x2c]
; 	data->params.k_p = 0;
 801859e: 697b         	ldr	r3, [r7, #0x14]
 80185a0: f04f 0200    	mov.w	r2, #0x0
 80185a4: 639a         	str	r2, [r3, #0x38]
; 	data->params.k_d = 0;
 80185a6: 697b         	ldr	r3, [r7, #0x14]
 80185a8: f04f 0200    	mov.w	r2, #0x0
 80185ac: 641a         	str	r2, [r3, #0x40]
; 	return 0;
 80185ae: 2300         	movs	r3, #0x0
; }
 80185b0: 4618         	mov	r0, r3
 80185b2: 3718         	adds	r7, #0x18
 80185b4: 46bd         	mov	sp, r7
 80185b6: bd80         	pop	{r7, pc}

080185b8 <dm_motor_set_speed>:
; {
 80185b8: b480         	push	{r7}
 80185ba: b085         	sub	sp, #0x14
 80185bc: af00         	add	r7, sp, #0x0
 80185be: 6078         	str	r0, [r7, #0x4]
 80185c0: 6039         	str	r1, [r7]
; 	struct dm_motor_data *data = dev->data;
 80185c2: 687b         	ldr	r3, [r7, #0x4]
 80185c4: 691b         	ldr	r3, [r3, #0x10]
 80185c6: 60fb         	str	r3, [r7, #0xc]
; 	data->target_rpm = speed_rpm;
 80185c8: 68fb         	ldr	r3, [r7, #0xc]
 80185ca: 683a         	ldr	r2, [r7]
 80185cc: 629a         	str	r2, [r3, #0x28]
; 	return 0;
 80185ce: 2300         	movs	r3, #0x0
; }
 80185d0: 4618         	mov	r0, r3
 80185d2: 3714         	adds	r7, #0x14
 80185d4: 46bd         	mov	sp, r7
 80185d6: bc80         	pop	{r7}
 80185d8: 4770         	bx	lr

080185da <dm_motor_set_angle>:
; {
 80185da: b480         	push	{r7}
 80185dc: b085         	sub	sp, #0x14
 80185de: af00         	add	r7, sp, #0x0
 80185e0: 6078         	str	r0, [r7, #0x4]
 80185e2: 6039         	str	r1, [r7]
; 	struct dm_motor_data *data = dev->data;
 80185e4: 687b         	ldr	r3, [r7, #0x4]
 80185e6: 691b         	ldr	r3, [r3, #0x10]
 80185e8: 60fb         	str	r3, [r7, #0xc]
; 	data->target_angle = angle;
 80185ea: 68fb         	ldr	r3, [r7, #0xc]
 80185ec: 683a         	ldr	r2, [r7]
 80185ee: 625a         	str	r2, [r3, #0x24]
; 	return 0;
 80185f0: 2300         	movs	r3, #0x0
; }
 80185f2: 4618         	mov	r0, r3
 80185f4: 3714         	adds	r7, #0x14
 80185f6: 46bd         	mov	sp, r7
 80185f8: bc80         	pop	{r7}
 80185fa: 4770         	bx	lr

080185fc <pid_mit_get_params>:
; static const struct pid_single_config *pid_mit_get_params(const struct device *pid_dev) {
 80185fc: b480         	push	{r7}
 80185fe: b083         	sub	sp, #0xc
 8018600: af00         	add	r7, sp, #0x0
 8018602: 6078         	str	r0, [r7, #0x4]
;     return &((struct pid_mit_config *)pid_dev->config)->common;
 8018604: 687b         	ldr	r3, [r7, #0x4]
 8018606: 685b         	ldr	r3, [r3, #0x4]
; }
 8018608: 4618         	mov	r0, r3
 801860a: 370c         	adds	r7, #0xc
 801860c: 46bd         	mov	sp, r7
 801860e: bc80         	pop	{r7}
 8018610: 4770         	bx	lr

08018612 <pid_mit_reg_input>:
; static void pid_mit_reg_input(const struct device *pid_dev, float *curr, float *ref) {
 8018612: b480         	push	{r7}
 8018614: b087         	sub	sp, #0x1c
 8018616: af00         	add	r7, sp, #0x0
 8018618: 60f8         	str	r0, [r7, #0xc]
 801861a: 60b9         	str	r1, [r7, #0x8]
 801861c: 607a         	str	r2, [r7, #0x4]
;     struct pid_mit_data *pid_data = pid_dev->data;
 801861e: 68fb         	ldr	r3, [r7, #0xc]
 8018620: 691b         	ldr	r3, [r3, #0x10]
 8018622: 617b         	str	r3, [r7, #0x14]
;     pid_data->curr                = curr;
 8018624: 697b         	ldr	r3, [r7, #0x14]
 8018626: 68ba         	ldr	r2, [r7, #0x8]
 8018628: 609a         	str	r2, [r3, #0x8]
;     pid_data->ref                 = ref;
 801862a: 697b         	ldr	r3, [r7, #0x14]
 801862c: 687a         	ldr	r2, [r7, #0x4]
 801862e: 601a         	str	r2, [r3]
;     return;
 8018630: bf00         	nop
; }
 8018632: 371c         	adds	r7, #0x1c
 8018634: 46bd         	mov	sp, r7
 8018636: bc80         	pop	{r7}
 8018638: 4770         	bx	lr

0801863a <pid_mit_reg_detri>:
; static void pid_mit_reg_detri(const struct device *pid_dev, float *curr, float *ref) {
 801863a: b480         	push	{r7}
 801863c: b087         	sub	sp, #0x1c
 801863e: af00         	add	r7, sp, #0x0
 8018640: 60f8         	str	r0, [r7, #0xc]
 8018642: 60b9         	str	r1, [r7, #0x8]
 8018644: 607a         	str	r2, [r7, #0x4]
;     struct pid_mit_data *pid_data = pid_dev->data;
 8018646: 68fb         	ldr	r3, [r7, #0xc]
 8018648: 691b         	ldr	r3, [r3, #0x10]
 801864a: 617b         	str	r3, [r7, #0x14]
;     pid_data->detri_curr          = curr;
 801864c: 697b         	ldr	r3, [r7, #0x14]
 801864e: 68ba         	ldr	r2, [r7, #0x8]
 8018650: 60da         	str	r2, [r3, #0xc]
;     pid_data->detri_ref           = ref;
 8018652: 697b         	ldr	r3, [r7, #0x14]
 8018654: 687a         	ldr	r2, [r7, #0x4]
 8018656: 605a         	str	r2, [r3, #0x4]
;     return;
 8018658: bf00         	nop
; }
 801865a: 371c         	adds	r7, #0x1c
 801865c: 46bd         	mov	sp, r7
 801865e: bc80         	pop	{r7}
 8018660: 4770         	bx	lr

08018662 <pid_mit_reg_time>:
;                              uint32_t *prev_time) {
 8018662: b480         	push	{r7}
 8018664: b087         	sub	sp, #0x1c
 8018666: af00         	add	r7, sp, #0x0
 8018668: 60f8         	str	r0, [r7, #0xc]
 801866a: 60b9         	str	r1, [r7, #0x8]
 801866c: 607a         	str	r2, [r7, #0x4]
;     struct pid_mit_data *pid_data = pid_dev->data;
 801866e: 68fb         	ldr	r3, [r7, #0xc]
 8018670: 691b         	ldr	r3, [r3, #0x10]
 8018672: 617b         	str	r3, [r7, #0x14]
;     pid_data->curr_time           = curr_time;
 8018674: 697b         	ldr	r3, [r7, #0x14]
 8018676: 68ba         	ldr	r2, [r7, #0x8]
 8018678: 61da         	str	r2, [r3, #0x1c]
;     pid_data->prev_time           = prev_time;
 801867a: 697b         	ldr	r3, [r7, #0x14]
 801867c: 687a         	ldr	r2, [r7, #0x4]
 801867e: 621a         	str	r2, [r3, #0x20]
;     return;
 8018680: bf00         	nop
; }
 8018682: 371c         	adds	r7, #0x1c
 8018684: 46bd         	mov	sp, r7
 8018686: bc80         	pop	{r7}
 8018688: 4770         	bx	lr

0801868a <pid_mit_reg_output>:
; static void pid_mit_reg_output(const struct device *pid_dev, float *output) {
 801868a: b480         	push	{r7}
 801868c: b085         	sub	sp, #0x14
 801868e: af00         	add	r7, sp, #0x0
 8018690: 6078         	str	r0, [r7, #0x4]
 8018692: 6039         	str	r1, [r7]
;     struct pid_mit_data *pid_data = pid_dev->data;
 8018694: 687b         	ldr	r3, [r7, #0x4]
 8018696: 691b         	ldr	r3, [r3, #0x10]
 8018698: 60fb         	str	r3, [r7, #0xc]
;     pid_data->output              = output;
 801869a: 68fb         	ldr	r3, [r7, #0xc]
 801869c: 683a         	ldr	r2, [r7]
 801869e: 625a         	str	r2, [r3, #0x24]
;     return;
 80186a0: bf00         	nop
; }
 80186a2: 3714         	adds	r7, #0x14
 80186a4: 46bd         	mov	sp, r7
 80186a6: bc80         	pop	{r7}
 80186a8: 4770         	bx	lr

080186aa <LL_DMA_Init>:
; {
 80186aa: b580         	push	{r7, lr}
 80186ac: b084         	sub	sp, #0x10
 80186ae: af00         	add	r7, sp, #0x0
 80186b0: 60f8         	str	r0, [r7, #0xc]
 80186b2: 60b9         	str	r1, [r7, #0x8]
 80186b4: 607a         	str	r2, [r7, #0x4]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 80186b6: 687b         	ldr	r3, [r7, #0x4]
 80186b8: 689a         	ldr	r2, [r3, #0x8]
;                         DMA_InitStruct->Mode                    | \
 80186ba: 687b         	ldr	r3, [r7, #0x4]
 80186bc: 68db         	ldr	r3, [r3, #0xc]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 80186be: 431a         	orrs	r2, r3
;                         DMA_InitStruct->PeriphOrM2MSrcIncMode   | \
 80186c0: 687b         	ldr	r3, [r7, #0x4]
 80186c2: 691b         	ldr	r3, [r3, #0x10]
;                         DMA_InitStruct->Mode                    | \
 80186c4: 431a         	orrs	r2, r3
;                         DMA_InitStruct->MemoryOrM2MDstIncMode   | \
 80186c6: 687b         	ldr	r3, [r7, #0x4]
 80186c8: 695b         	ldr	r3, [r3, #0x14]
;                         DMA_InitStruct->PeriphOrM2MSrcIncMode   | \
 80186ca: 431a         	orrs	r2, r3
;                         DMA_InitStruct->PeriphOrM2MSrcDataSize  | \
 80186cc: 687b         	ldr	r3, [r7, #0x4]
 80186ce: 699b         	ldr	r3, [r3, #0x18]
;                         DMA_InitStruct->MemoryOrM2MDstIncMode   | \
 80186d0: 431a         	orrs	r2, r3
;                         DMA_InitStruct->MemoryOrM2MDstDataSize  | \
 80186d2: 687b         	ldr	r3, [r7, #0x4]
 80186d4: 69db         	ldr	r3, [r3, #0x1c]
;                         DMA_InitStruct->PeriphOrM2MSrcDataSize  | \
 80186d6: 431a         	orrs	r2, r3
;                         DMA_InitStruct->Priority
 80186d8: 687b         	ldr	r3, [r7, #0x4]
 80186da: 6a9b         	ldr	r3, [r3, #0x28]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 80186dc: 4313         	orrs	r3, r2
 80186de: 461a         	mov	r2, r3
 80186e0: 68b9         	ldr	r1, [r7, #0x8]
 80186e2: 68f8         	ldr	r0, [r7, #0xc]
 80186e4: f7f3 f8a4    	bl	0x800b830 <LL_DMA_ConfigTransfer> @ imm = #-0xceb8
;   if(DMA_InitStruct->FIFOMode != LL_DMA_FIFOMODE_DISABLE)
 80186e8: 687b         	ldr	r3, [r7, #0x4]
 80186ea: 6adb         	ldr	r3, [r3, #0x2c]
 80186ec: 2b00         	cmp	r3, #0x0
 80186ee: d015         	beq	0x801871c <LL_DMA_Init+0x72> @ imm = #0x2a
;     LL_DMA_ConfigFifo(DMAx, Stream, DMA_InitStruct->FIFOMode, DMA_InitStruct->FIFOThreshold);
 80186f0: 687b         	ldr	r3, [r7, #0x4]
 80186f2: 6ada         	ldr	r2, [r3, #0x2c]
 80186f4: 687b         	ldr	r3, [r7, #0x4]
 80186f6: 6b1b         	ldr	r3, [r3, #0x30]
 80186f8: 68b9         	ldr	r1, [r7, #0x8]
 80186fa: 68f8         	ldr	r0, [r7, #0xc]
 80186fc: f7f3 f944    	bl	0x800b988 <LL_DMA_ConfigFifo> @ imm = #-0xcd78
;     LL_DMA_SetMemoryBurstxfer(DMAx,Stream,DMA_InitStruct->MemBurst);
 8018700: 687b         	ldr	r3, [r7, #0x4]
 8018702: 6b5b         	ldr	r3, [r3, #0x34]
 8018704: 461a         	mov	r2, r3
 8018706: 68b9         	ldr	r1, [r7, #0x8]
 8018708: 68f8         	ldr	r0, [r7, #0xc]
 801870a: f7f3 f8f9    	bl	0x800b900 <LL_DMA_SetMemoryBurstxfer> @ imm = #-0xce0e
;     LL_DMA_SetPeriphBurstxfer(DMAx,Stream,DMA_InitStruct->PeriphBurst);
 801870e: 687b         	ldr	r3, [r7, #0x4]
 8018710: 6b9b         	ldr	r3, [r3, #0x38]
 8018712: 461a         	mov	r2, r3
 8018714: 68b9         	ldr	r1, [r7, #0x8]
 8018716: 68f8         	ldr	r0, [r7, #0xc]
 8018718: f7f3 f914    	bl	0x800b944 <LL_DMA_SetPeriphBurstxfer> @ imm = #-0xcdd8
;   LL_DMA_SetMemoryAddress(DMAx, Stream, DMA_InitStruct->MemoryOrM2MDstAddress);
 801871c: 687b         	ldr	r3, [r7, #0x4]
 801871e: 685b         	ldr	r3, [r3, #0x4]
 8018720: 461a         	mov	r2, r3
 8018722: 68b9         	ldr	r1, [r7, #0x8]
 8018724: 68f8         	ldr	r0, [r7, #0xc]
 8018726: f7f3 f953    	bl	0x800b9d0 <LL_DMA_SetMemoryAddress> @ imm = #-0xcd5a
;   LL_DMA_SetPeriphAddress(DMAx, Stream, DMA_InitStruct->PeriphOrM2MSrcAddress);
 801872a: 687b         	ldr	r3, [r7, #0x4]
 801872c: 681b         	ldr	r3, [r3]
 801872e: 461a         	mov	r2, r3
 8018730: 68b9         	ldr	r1, [r7, #0x8]
 8018732: 68f8         	ldr	r0, [r7, #0xc]
 8018734: f7f3 f964    	bl	0x800ba00 <LL_DMA_SetPeriphAddress> @ imm = #-0xcd38
;   LL_DMA_SetDataLength(DMAx, Stream, DMA_InitStruct->NbData);
 8018738: 687b         	ldr	r3, [r7, #0x4]
 801873a: 6a1b         	ldr	r3, [r3, #0x20]
 801873c: 461a         	mov	r2, r3
 801873e: 68b9         	ldr	r1, [r7, #0x8]
 8018740: 68f8         	ldr	r0, [r7, #0xc]
 8018742: f7f3 f899    	bl	0x800b878 <LL_DMA_SetDataLength> @ imm = #-0xcece
;   LL_DMA_SetChannelSelection(DMAx, Stream, DMA_InitStruct->Channel);
 8018746: 687b         	ldr	r3, [r7, #0x4]
 8018748: 6a5b         	ldr	r3, [r3, #0x24]
 801874a: 461a         	mov	r2, r3
 801874c: 68b9         	ldr	r1, [r7, #0x8]
 801874e: 68f8         	ldr	r0, [r7, #0xc]
 8018750: f7f3 f8b4    	bl	0x800b8bc <LL_DMA_SetChannelSelection> @ imm = #-0xce98
;   return SUCCESS;
 8018754: 2300         	movs	r3, #0x0
; }
 8018756: 4618         	mov	r0, r3
 8018758: 3710         	adds	r7, #0x10
 801875a: 46bd         	mov	sp, r7
 801875c: bd80         	pop	{r7, pc}

0801875e <LL_DMA_StructInit>:
; {
 801875e: b480         	push	{r7}
 8018760: b083         	sub	sp, #0xc
 8018762: af00         	add	r7, sp, #0x0
 8018764: 6078         	str	r0, [r7, #0x4]
;   DMA_InitStruct->PeriphOrM2MSrcAddress  = 0x00000000U;
 8018766: 687b         	ldr	r3, [r7, #0x4]
 8018768: 2200         	movs	r2, #0x0
 801876a: 601a         	str	r2, [r3]
;   DMA_InitStruct->MemoryOrM2MDstAddress  = 0x00000000U;
 801876c: 687b         	ldr	r3, [r7, #0x4]
 801876e: 2200         	movs	r2, #0x0
 8018770: 605a         	str	r2, [r3, #0x4]
;   DMA_InitStruct->Direction              = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
 8018772: 687b         	ldr	r3, [r7, #0x4]
 8018774: 2200         	movs	r2, #0x0
 8018776: 609a         	str	r2, [r3, #0x8]
;   DMA_InitStruct->Mode                   = LL_DMA_MODE_NORMAL;
 8018778: 687b         	ldr	r3, [r7, #0x4]
 801877a: 2200         	movs	r2, #0x0
 801877c: 60da         	str	r2, [r3, #0xc]
;   DMA_InitStruct->PeriphOrM2MSrcIncMode  = LL_DMA_PERIPH_NOINCREMENT;
 801877e: 687b         	ldr	r3, [r7, #0x4]
 8018780: 2200         	movs	r2, #0x0
 8018782: 611a         	str	r2, [r3, #0x10]
;   DMA_InitStruct->MemoryOrM2MDstIncMode  = LL_DMA_MEMORY_NOINCREMENT;
 8018784: 687b         	ldr	r3, [r7, #0x4]
 8018786: 2200         	movs	r2, #0x0
 8018788: 615a         	str	r2, [r3, #0x14]
;   DMA_InitStruct->PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;
 801878a: 687b         	ldr	r3, [r7, #0x4]
 801878c: 2200         	movs	r2, #0x0
 801878e: 619a         	str	r2, [r3, #0x18]
;   DMA_InitStruct->MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;
 8018790: 687b         	ldr	r3, [r7, #0x4]
 8018792: 2200         	movs	r2, #0x0
 8018794: 61da         	str	r2, [r3, #0x1c]
;   DMA_InitStruct->NbData                 = 0x00000000U;
 8018796: 687b         	ldr	r3, [r7, #0x4]
 8018798: 2200         	movs	r2, #0x0
 801879a: 621a         	str	r2, [r3, #0x20]
;   DMA_InitStruct->Channel                = LL_DMA_CHANNEL_0;
 801879c: 687b         	ldr	r3, [r7, #0x4]
 801879e: 2200         	movs	r2, #0x0
 80187a0: 625a         	str	r2, [r3, #0x24]
;   DMA_InitStruct->Priority               = LL_DMA_PRIORITY_LOW;
 80187a2: 687b         	ldr	r3, [r7, #0x4]
 80187a4: 2200         	movs	r2, #0x0
 80187a6: 629a         	str	r2, [r3, #0x28]
;   DMA_InitStruct->FIFOMode               = LL_DMA_FIFOMODE_DISABLE;
 80187a8: 687b         	ldr	r3, [r7, #0x4]
 80187aa: 2200         	movs	r2, #0x0
 80187ac: 62da         	str	r2, [r3, #0x2c]
;   DMA_InitStruct->FIFOThreshold          = LL_DMA_FIFOTHRESHOLD_1_4;
 80187ae: 687b         	ldr	r3, [r7, #0x4]
 80187b0: 2200         	movs	r2, #0x0
 80187b2: 631a         	str	r2, [r3, #0x30]
;   DMA_InitStruct->MemBurst               = LL_DMA_MBURST_SINGLE;
 80187b4: 687b         	ldr	r3, [r7, #0x4]
 80187b6: 2200         	movs	r2, #0x0
 80187b8: 635a         	str	r2, [r3, #0x34]
;   DMA_InitStruct->PeriphBurst            = LL_DMA_PBURST_SINGLE;
 80187ba: 687b         	ldr	r3, [r7, #0x4]
 80187bc: 2200         	movs	r2, #0x0
 80187be: 639a         	str	r2, [r3, #0x38]
; }
 80187c0: bf00         	nop
 80187c2: 370c         	adds	r7, #0xc
 80187c4: 46bd         	mov	sp, r7
 80187c6: bc80         	pop	{r7}
 80187c8: 4770         	bx	lr

080187ca <arch_k_cycle_get_32>:
; {
 80187ca: b580         	push	{r7, lr}
 80187cc: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 80187ce: f7f1 feb1    	bl	0x800a534 <sys_clock_cycle_get_32> @ imm = #-0xe29e
 80187d2: 4603         	mov	r3, r0
; }
 80187d4: 4618         	mov	r0, r3
 80187d6: bd80         	pop	{r7, pc}

080187d8 <k_cycle_get_32>:
; {
 80187d8: b580         	push	{r7, lr}
 80187da: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 80187dc: f7ff fff5    	bl	0x80187ca <arch_k_cycle_get_32> @ imm = #-0x16
 80187e0: 4603         	mov	r3, r0
; }
 80187e2: 4618         	mov	r0, r3
 80187e4: bd80         	pop	{r7, pc}

080187e6 <z_impl_k_busy_wait>:
; {
 80187e6: b580         	push	{r7, lr}
 80187e8: b086         	sub	sp, #0x18
 80187ea: af00         	add	r7, sp, #0x0
 80187ec: 6078         	str	r0, [r7, #0x4]
; 	if (usec_to_wait == 0U) {
 80187ee: 687b         	ldr	r3, [r7, #0x4]
 80187f0: 2b00         	cmp	r3, #0x0
 80187f2: d011         	beq	0x8018818 <z_impl_k_busy_wait+0x32> @ imm = #0x22
; 	uint32_t start_cycles = k_cycle_get_32();
 80187f4: f7ff fff0    	bl	0x80187d8 <k_cycle_get_32> @ imm = #-0x20
 80187f8: 6178         	str	r0, [r7, #0x14]
; 	uint32_t cycles_to_wait = k_us_to_cyc_ceil32(usec_to_wait);
 80187fa: 687b         	ldr	r3, [r7, #0x4]
 80187fc: 22a8         	movs	r2, #0xa8
 80187fe: fb02 f303    	mul	r3, r2, r3
 8018802: 613b         	str	r3, [r7, #0x10]
; 		uint32_t current_cycles = k_cycle_get_32();
 8018804: f7ff ffe8    	bl	0x80187d8 <k_cycle_get_32> @ imm = #-0x30
 8018808: 60f8         	str	r0, [r7, #0xc]
; 		if ((current_cycles - start_cycles) >= cycles_to_wait) {
 801880a: 68fa         	ldr	r2, [r7, #0xc]
 801880c: 697b         	ldr	r3, [r7, #0x14]
 801880e: 1ad3         	subs	r3, r2, r3
 8018810: 693a         	ldr	r2, [r7, #0x10]
 8018812: 429a         	cmp	r2, r3
 8018814: d902         	bls	0x801881c <z_impl_k_busy_wait+0x36> @ imm = #0x4
; 	for (;;) {
 8018816: e7f5         	b	0x8018804 <z_impl_k_busy_wait+0x1e> @ imm = #-0x16
; 		return;
 8018818: bf00         	nop
 801881a: e000         	b	0x801881e <z_impl_k_busy_wait+0x38> @ imm = #0x0
; 			break;
 801881c: bf00         	nop
; }
 801881e: 3718         	adds	r7, #0x18
 8018820: 46bd         	mov	sp, r7
 8018822: bd80         	pop	{r7, pc}

08018824 <k_object_init>:
; {
 8018824: b480         	push	{r7}
 8018826: b083         	sub	sp, #0xc
 8018828: af00         	add	r7, sp, #0x0
 801882a: 6078         	str	r0, [r7, #0x4]
; }
 801882c: bf00         	nop
 801882e: 370c         	adds	r7, #0xc
 8018830: 46bd         	mov	sp, r7
 8018832: bc80         	pop	{r7}
 8018834: 4770         	bx	lr

08018836 <z_impl_device_is_ready>:
; {
 8018836: b480         	push	{r7}
 8018838: b083         	sub	sp, #0xc
 801883a: af00         	add	r7, sp, #0x0
 801883c: 6078         	str	r0, [r7, #0x4]
; 	if (dev == NULL) {
 801883e: 687b         	ldr	r3, [r7, #0x4]
 8018840: 2b00         	cmp	r3, #0x0
 8018842: d101         	bne	0x8018848 <z_impl_device_is_ready+0x12> @ imm = #0x2
; 		return false;
 8018844: 2300         	movs	r3, #0x0
 8018846: e012         	b	0x801886e <z_impl_device_is_ready+0x38> @ imm = #0x24
; 	return dev->state->initialized && (dev->state->init_res == 0U);
 8018848: 687b         	ldr	r3, [r7, #0x4]
 801884a: 68db         	ldr	r3, [r3, #0xc]
 801884c: 785b         	ldrb	r3, [r3, #0x1]
 801884e: f003 0301    	and	r3, r3, #0x1
 8018852: b2db         	uxtb	r3, r3
 8018854: 2b00         	cmp	r3, #0x0
 8018856: d006         	beq	0x8018866 <z_impl_device_is_ready+0x30> @ imm = #0xc
 8018858: 687b         	ldr	r3, [r7, #0x4]
 801885a: 68db         	ldr	r3, [r3, #0xc]
 801885c: 781b         	ldrb	r3, [r3]
 801885e: 2b00         	cmp	r3, #0x0
 8018860: d101         	bne	0x8018866 <z_impl_device_is_ready+0x30> @ imm = #0x2
 8018862: 2301         	movs	r3, #0x1
 8018864: e000         	b	0x8018868 <z_impl_device_is_ready+0x32> @ imm = #0x0
 8018866: 2300         	movs	r3, #0x0
 8018868: f003 0301    	and	r3, r3, #0x1
 801886c: b2db         	uxtb	r3, r3
; }
 801886e: 4618         	mov	r0, r3
 8018870: 370c         	adds	r7, #0xc
 8018872: 46bd         	mov	sp, r7
 8018874: bc80         	pop	{r7}
 8018876: 4770         	bx	lr

08018878 <k_thread_abort>:
; {
 8018878: b580         	push	{r7, lr}
 801887a: b082         	sub	sp, #0x8
 801887c: af00         	add	r7, sp, #0x0
 801887e: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 8018880: 6878         	ldr	r0, [r7, #0x4]
 8018882: f7ea fd91    	bl	0x80033a8 <z_impl_k_thread_abort> @ imm = #-0x154de
; }
 8018886: bf00         	nop
 8018888: 3708         	adds	r7, #0x8
 801888a: 46bd         	mov	sp, r7
 801888c: bd80         	pop	{r7, pc}

0801888e <z_log_msg_runtime_create>:
; {
 801888e: b580         	push	{r7, lr}
 8018890: b08a         	sub	sp, #0x28
 8018892: af04         	add	r7, sp, #0x10
 8018894: 60b9         	str	r1, [r7, #0x8]
 8018896: 607b         	str	r3, [r7, #0x4]
 8018898: 4603         	mov	r3, r0
 801889a: 73fb         	strb	r3, [r7, #0xf]
 801889c: 4613         	mov	r3, r2
 801889e: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80188a0: f107 032c    	add.w	r3, r7, #0x2c
 80188a4: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80188a6: 7bba         	ldrb	r2, [r7, #0xe]
 80188a8: 7bf8         	ldrb	r0, [r7, #0xf]
 80188aa: 697b         	ldr	r3, [r7, #0x14]
 80188ac: 9303         	str	r3, [sp, #0xc]
 80188ae: 6abb         	ldr	r3, [r7, #0x28]
 80188b0: 9302         	str	r3, [sp, #0x8]
 80188b2: 6a7b         	ldr	r3, [r7, #0x24]
 80188b4: 9301         	str	r3, [sp, #0x4]
 80188b6: 6a3b         	ldr	r3, [r7, #0x20]
 80188b8: 9300         	str	r3, [sp]
 80188ba: 687b         	ldr	r3, [r7, #0x4]
 80188bc: 68b9         	ldr	r1, [r7, #0x8]
 80188be: f7e9 f9d5    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x16c56
; }
 80188c2: bf00         	nop
 80188c4: 3718         	adds	r7, #0x18
 80188c6: 46bd         	mov	sp, r7
 80188c8: bd80         	pop	{r7, pc}

080188ca <log_panic>:
; {
 80188ca: b580         	push	{r7, lr}
 80188cc: af00         	add	r7, sp, #0x0
; 	z_impl_log_panic();
 80188ce: f7e9 f853    	bl	0x8001978 <z_impl_log_panic> @ imm = #-0x16f5a
; }
 80188d2: bf00         	nop
 80188d4: bd80         	pop	{r7, pc}

080188d6 <coredump>:
; {
 80188d6: b480         	push	{r7}
 80188d8: b085         	sub	sp, #0x14
 80188da: af00         	add	r7, sp, #0x0
 80188dc: 60f8         	str	r0, [r7, #0xc]
 80188de: 60b9         	str	r1, [r7, #0x8]
 80188e0: 607a         	str	r2, [r7, #0x4]
; }
 80188e2: bf00         	nop
 80188e4: 3714         	adds	r7, #0x14
 80188e6: 46bd         	mov	sp, r7
 80188e8: bc80         	pop	{r7}
 80188ea: 4770         	bx	lr

080188ec <arch_system_halt>:
; {
 80188ec: b480         	push	{r7}
 80188ee: b087         	sub	sp, #0x1c
 80188f0: af00         	add	r7, sp, #0x0
 80188f2: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80188f4: f3ef 8311    	mrs	r3, basepri
 80188f8: 617b         	str	r3, [r7, #0x14]
;   return(result);
 80188fa: 697b         	ldr	r3, [r7, #0x14]
; 	key = __get_BASEPRI();
 80188fc: 613b         	str	r3, [r7, #0x10]
 80188fe: 2310         	movs	r3, #0x10
 8018900: 60fb         	str	r3, [r7, #0xc]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8018902: 68fb         	ldr	r3, [r7, #0xc]
 8018904: f383 8812    	msr	basepri_max, r3
; }
 8018908: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801890a: f3bf 8f6f    	isb	sy
; }
 801890e: bf00         	nop
; 	for (;;) {
 8018910: bf00         	nop
 8018912: e7fd         	b	0x8018910 <arch_system_halt+0x24> @ imm = #-0x6

08018914 <K_KERNEL_STACK_BUFFER>:
; {
 8018914: b480         	push	{r7}
 8018916: b083         	sub	sp, #0xc
 8018918: af00         	add	r7, sp, #0x0
 801891a: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 801891c: 687b         	ldr	r3, [r7, #0x4]
; }
 801891e: 4618         	mov	r0, r3
 8018920: 370c         	adds	r7, #0xc
 8018922: 46bd         	mov	sp, r7
 8018924: bc80         	pop	{r7}
 8018926: 4770         	bx	lr

08018928 <k_thread_start>:
; {
 8018928: b580         	push	{r7, lr}
 801892a: b082         	sub	sp, #0x8
 801892c: af00         	add	r7, sp, #0x0
 801892e: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 8018930: 6878         	ldr	r0, [r7, #0x4]
 8018932: f000 f804    	bl	0x801893e <k_thread_resume> @ imm = #0x8
; }
 8018936: bf00         	nop
 8018938: 3708         	adds	r7, #0x8
 801893a: 46bd         	mov	sp, r7
 801893c: bd80         	pop	{r7, pc}

0801893e <k_thread_resume>:
; {
 801893e: b580         	push	{r7, lr}
 8018940: b082         	sub	sp, #0x8
 8018942: af00         	add	r7, sp, #0x0
 8018944: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 8018946: 6878         	ldr	r0, [r7, #0x4]
 8018948: f7f5 fcba    	bl	0x800e2c0 <z_impl_k_thread_resume> @ imm = #-0xa68c
; }
 801894c: bf00         	nop
 801894e: 3708         	adds	r7, #0x8
 8018950: 46bd         	mov	sp, r7
 8018952: bd80         	pop	{r7, pc}

08018954 <thread_schedule_new>:
; {
 8018954: b580         	push	{r7, lr}
 8018956: b084         	sub	sp, #0x10
 8018958: af00         	add	r7, sp, #0x0
 801895a: 60f8         	str	r0, [r7, #0xc]
 801895c: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 8018960: e9d7 2300    	ldrd	r2, r3, [r7]
 8018964: f04f 0000    	mov.w	r0, #0x0
 8018968: f04f 0100    	mov.w	r1, #0x0
 801896c: 428b         	cmp	r3, r1
 801896e: bf08         	it	eq
 8018970: 4282         	cmpeq	r2, r0
 8018972: d103         	bne	0x801897c <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 8018974: 68f8         	ldr	r0, [r7, #0xc]
 8018976: f7ff ffd7    	bl	0x8018928 <k_thread_start> @ imm = #-0x52
 801897a: e004         	b	0x8018986 <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 801897c: e9d7 2300    	ldrd	r2, r3, [r7]
 8018980: 68f8         	ldr	r0, [r7, #0xc]
 8018982: f7f3 fa95    	bl	0x800beb0 <z_add_thread_timeout> @ imm = #-0xcad6
; }
 8018986: bf00         	nop
 8018988: 3710         	adds	r7, #0x10
 801898a: 46bd         	mov	sp, r7
 801898c: bd80         	pop	{r7, pc}

0801898e <z_mark_thread_as_not_suspended>:
; {
 801898e: b480         	push	{r7}
 8018990: b083         	sub	sp, #0xc
 8018992: af00         	add	r7, sp, #0x0
 8018994: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 8018996: 687b         	ldr	r3, [r7, #0x4]
 8018998: 7b5b         	ldrb	r3, [r3, #0xd]
 801899a: f023 0310    	bic	r3, r3, #0x10
 801899e: b2da         	uxtb	r2, r3
 80189a0: 687b         	ldr	r3, [r7, #0x4]
 80189a2: 735a         	strb	r2, [r3, #0xd]
; }
 80189a4: bf00         	nop
 80189a6: 370c         	adds	r7, #0xc
 80189a8: 46bd         	mov	sp, r7
 80189aa: bc80         	pop	{r7}
 80189ac: 4770         	bx	lr

080189ae <z_thread_essential_clear>:
; {
 80189ae: b480         	push	{r7}
 80189b0: b083         	sub	sp, #0xc
 80189b2: af00         	add	r7, sp, #0x0
 80189b4: 6078         	str	r0, [r7, #0x4]
; 	thread->base.user_options &= ~K_ESSENTIAL;
 80189b6: 687b         	ldr	r3, [r7, #0x4]
 80189b8: 7b1b         	ldrb	r3, [r3, #0xc]
 80189ba: f023 0301    	bic	r3, r3, #0x1
 80189be: b2da         	uxtb	r2, r3
 80189c0: 687b         	ldr	r3, [r7, #0x4]
 80189c2: 731a         	strb	r2, [r3, #0xc]
; }
 80189c4: bf00         	nop
 80189c6: 370c         	adds	r7, #0xc
 80189c8: 46bd         	mov	sp, r7
 80189ca: bc80         	pop	{r7}
 80189cc: 4770         	bx	lr

080189ce <gcov_static_init>:
; static inline void gcov_static_init(void) { }
 80189ce: b480         	push	{r7}
 80189d0: af00         	add	r7, sp, #0x0
 80189d2: bf00         	nop
 80189d4: 46bd         	mov	sp, r7
 80189d6: bc80         	pop	{r7}
 80189d8: 4770         	bx	lr

080189da <pm_device_runtime_auto_enable>:
; {
 80189da: b480         	push	{r7}
 80189dc: b083         	sub	sp, #0xc
 80189de: af00         	add	r7, sp, #0x0
 80189e0: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 80189e2: 2300         	movs	r3, #0x0
; }
 80189e4: 4618         	mov	r0, r3
 80189e6: 370c         	adds	r7, #0xc
 80189e8: 46bd         	mov	sp, r7
 80189ea: bc80         	pop	{r7}
 80189ec: 4770         	bx	lr

080189ee <z_early_memset>:
; {
 80189ee: b580         	push	{r7, lr}
 80189f0: b084         	sub	sp, #0x10
 80189f2: af00         	add	r7, sp, #0x0
 80189f4: 60f8         	str	r0, [r7, #0xc]
 80189f6: 60b9         	str	r1, [r7, #0x8]
 80189f8: 607a         	str	r2, [r7, #0x4]
; 	(void) memset(dst, c, n);
 80189fa: 687a         	ldr	r2, [r7, #0x4]
 80189fc: 68b9         	ldr	r1, [r7, #0x8]
 80189fe: 68f8         	ldr	r0, [r7, #0xc]
 8018a00: f001 ff16    	bl	0x801a830 <memset>      @ imm = #0x1e2c
; }
 8018a04: bf00         	nop
 8018a06: 3710         	adds	r7, #0x10
 8018a08: 46bd         	mov	sp, r7
 8018a0a: bd80         	pop	{r7, pc}

08018a0c <z_early_memcpy>:
; {
 8018a0c: b580         	push	{r7, lr}
 8018a0e: b084         	sub	sp, #0x10
 8018a10: af00         	add	r7, sp, #0x0
 8018a12: 60f8         	str	r0, [r7, #0xc]
 8018a14: 60b9         	str	r1, [r7, #0x8]
 8018a16: 607a         	str	r2, [r7, #0x4]
; 	(void) memcpy(dst, src, n);
 8018a18: 687a         	ldr	r2, [r7, #0x4]
 8018a1a: 68b9         	ldr	r1, [r7, #0x8]
 8018a1c: 68f8         	ldr	r0, [r7, #0xc]
 8018a1e: f001 fef9    	bl	0x801a814 <memcpy>      @ imm = #0x1df2
; }
 8018a22: bf00         	nop
 8018a24: 3710         	adds	r7, #0x10
 8018a26: 46bd         	mov	sp, r7
 8018a28: bd80         	pop	{r7, pc}

08018a2a <do_device_init>:
; {
 8018a2a: b580         	push	{r7, lr}
 8018a2c: b084         	sub	sp, #0x10
 8018a2e: af00         	add	r7, sp, #0x0
 8018a30: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = entry->dev;
 8018a32: 687b         	ldr	r3, [r7, #0x4]
 8018a34: 685b         	ldr	r3, [r3, #0x4]
 8018a36: 60bb         	str	r3, [r7, #0x8]
; 	int rc = 0;
 8018a38: 2300         	movs	r3, #0x0
 8018a3a: 60fb         	str	r3, [r7, #0xc]
; 	if (entry->init_fn.dev != NULL) {
 8018a3c: 687b         	ldr	r3, [r7, #0x4]
 8018a3e: 681b         	ldr	r3, [r3]
 8018a40: 2b00         	cmp	r3, #0x0
 8018a42: d017         	beq	0x8018a74 <do_device_init+0x4a> @ imm = #0x2e
; 		rc = entry->init_fn.dev(dev);
 8018a44: 687b         	ldr	r3, [r7, #0x4]
 8018a46: 681b         	ldr	r3, [r3]
 8018a48: 68b8         	ldr	r0, [r7, #0x8]
 8018a4a: 4798         	blx	r3
 8018a4c: 60f8         	str	r0, [r7, #0xc]
; 		if (rc != 0) {
 8018a4e: 68fb         	ldr	r3, [r7, #0xc]
 8018a50: 2b00         	cmp	r3, #0x0
 8018a52: d00f         	beq	0x8018a74 <do_device_init+0x4a> @ imm = #0x1e
; 			if (rc < 0) {
 8018a54: 68fb         	ldr	r3, [r7, #0xc]
 8018a56: 2b00         	cmp	r3, #0x0
 8018a58: da02         	bge	0x8018a60 <do_device_init+0x36> @ imm = #0x4
; 				rc = -rc;
 8018a5a: 68fb         	ldr	r3, [r7, #0xc]
 8018a5c: 425b         	rsbs	r3, r3, #0
 8018a5e: 60fb         	str	r3, [r7, #0xc]
; 			if (rc > UINT8_MAX) {
 8018a60: 68fb         	ldr	r3, [r7, #0xc]
 8018a62: 2bff         	cmp	r3, #0xff
 8018a64: dd01         	ble	0x8018a6a <do_device_init+0x40> @ imm = #0x2
; 				rc = UINT8_MAX;
 8018a66: 23ff         	movs	r3, #0xff
 8018a68: 60fb         	str	r3, [r7, #0xc]
; 			dev->state->init_res = rc;
 8018a6a: 68bb         	ldr	r3, [r7, #0x8]
 8018a6c: 68db         	ldr	r3, [r3, #0xc]
 8018a6e: 68fa         	ldr	r2, [r7, #0xc]
 8018a70: b2d2         	uxtb	r2, r2
 8018a72: 701a         	strb	r2, [r3]
; 	dev->state->initialized = true;
 8018a74: 68bb         	ldr	r3, [r7, #0x8]
 8018a76: 68da         	ldr	r2, [r3, #0xc]
 8018a78: 7853         	ldrb	r3, [r2, #0x1]
 8018a7a: f043 0301    	orr	r3, r3, #0x1
 8018a7e: 7053         	strb	r3, [r2, #0x1]
; 	if (rc == 0) {
 8018a80: 68fb         	ldr	r3, [r7, #0xc]
 8018a82: 2b00         	cmp	r3, #0x0
 8018a84: d102         	bne	0x8018a8c <do_device_init+0x62> @ imm = #0x4
; 		(void)pm_device_runtime_auto_enable(dev);
 8018a86: 68b8         	ldr	r0, [r7, #0x8]
 8018a88: f7ff ffa7    	bl	0x80189da <pm_device_runtime_auto_enable> @ imm = #-0xb2
; 	return rc;
 8018a8c: 68fb         	ldr	r3, [r7, #0xc]
; }
 8018a8e: 4618         	mov	r0, r3
 8018a90: 3710         	adds	r7, #0x10
 8018a92: 46bd         	mov	sp, r7
 8018a94: bd80         	pop	{r7, pc}

08018a96 <z_init_static>:
; {
 8018a96: b480         	push	{r7}
 8018a98: af00         	add	r7, sp, #0x0
; }
 8018a9a: bf00         	nop
 8018a9c: 46bd         	mov	sp, r7
 8018a9e: bc80         	pop	{r7}
 8018aa0: 4770         	bx	lr

08018aa2 <k_cpu_idle>:
; {
 8018aa2: b580         	push	{r7, lr}
 8018aa4: af00         	add	r7, sp, #0x0
; 	arch_cpu_idle();
 8018aa6: f7fa f883    	bl	0x8012bb0 <arch_cpu_idle> @ imm = #-0x5efa
; }
 8018aaa: bf00         	nop
 8018aac: bd80         	pop	{r7, pc}

08018aae <idle>:
; {
 8018aae: b580         	push	{r7, lr}
 8018ab0: b088         	sub	sp, #0x20
 8018ab2: af00         	add	r7, sp, #0x0
 8018ab4: 60f8         	str	r0, [r7, #0xc]
 8018ab6: 60b9         	str	r1, [r7, #0x8]
 8018ab8: 607a         	str	r2, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8018aba: f3ef 8311    	mrs	r3, basepri
 8018abe: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 8018ac0: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 8018ac2: 61bb         	str	r3, [r7, #0x18]
 8018ac4: 2310         	movs	r3, #0x10
 8018ac6: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8018ac8: 697b         	ldr	r3, [r7, #0x14]
 8018aca: f383 8812    	msr	basepri_max, r3
; }
 8018ace: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8018ad0: f3bf 8f6f    	isb	sy
; }
 8018ad4: bf00         	nop
; 	return key;
 8018ad6: bf00         	nop
; 		k_cpu_idle();
 8018ad8: f7ff ffe3    	bl	0x8018aa2 <k_cpu_idle>  @ imm = #-0x3a
; 		if (IS_ENABLED(CONFIG_SMP) && !IS_ENABLED(CONFIG_SCHED_IPI_SUPPORTED)) {
 8018adc: e7ed         	b	0x8018aba <idle+0xc>    @ imm = #-0x26

08018ade <arch_spin_relax>:
; {
 8018ade: b480         	push	{r7}
 8018ae0: af00         	add	r7, sp, #0x0
; 	__asm__ volatile("nop");
 8018ae2: bf00         	nop
; }
 8018ae4: bf00         	nop
; }
 8018ae6: bf00         	nop
 8018ae8: 46bd         	mov	sp, r7
 8018aea: bc80         	pop	{r7}
 8018aec: 4770         	bx	lr

08018aee <sys_dnode_init>:
; {
 8018aee: b480         	push	{r7}
 8018af0: b083         	sub	sp, #0xc
 8018af2: af00         	add	r7, sp, #0x0
 8018af4: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8018af6: 687b         	ldr	r3, [r7, #0x4]
 8018af8: 2200         	movs	r2, #0x0
 8018afa: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8018afc: 687b         	ldr	r3, [r7, #0x4]
 8018afe: 2200         	movs	r2, #0x0
 8018b00: 605a         	str	r2, [r3, #0x4]
; }
 8018b02: bf00         	nop
 8018b04: 370c         	adds	r7, #0xc
 8018b06: 46bd         	mov	sp, r7
 8018b08: bc80         	pop	{r7}
 8018b0a: 4770         	bx	lr

08018b0c <sys_dlist_is_empty>:
; {
 8018b0c: b480         	push	{r7}
 8018b0e: b083         	sub	sp, #0xc
 8018b10: af00         	add	r7, sp, #0x0
 8018b12: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8018b14: 687b         	ldr	r3, [r7, #0x4]
 8018b16: 681b         	ldr	r3, [r3]
 8018b18: 687a         	ldr	r2, [r7, #0x4]
 8018b1a: 429a         	cmp	r2, r3
 8018b1c: bf0c         	ite	eq
 8018b1e: 2301         	moveq	r3, #0x1
 8018b20: 2300         	movne	r3, #0x0
 8018b22: b2db         	uxtb	r3, r3
; }
 8018b24: 4618         	mov	r0, r3
 8018b26: 370c         	adds	r7, #0xc
 8018b28: 46bd         	mov	sp, r7
 8018b2a: bc80         	pop	{r7}
 8018b2c: 4770         	bx	lr

08018b2e <sys_dlist_peek_head>:
; {
 8018b2e: b580         	push	{r7, lr}
 8018b30: b082         	sub	sp, #0x8
 8018b32: af00         	add	r7, sp, #0x0
 8018b34: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8018b36: 6878         	ldr	r0, [r7, #0x4]
 8018b38: f7ff ffe8    	bl	0x8018b0c <sys_dlist_is_empty> @ imm = #-0x30
 8018b3c: 4603         	mov	r3, r0
 8018b3e: 2b00         	cmp	r3, #0x0
 8018b40: d102         	bne	0x8018b48 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8018b42: 687b         	ldr	r3, [r7, #0x4]
 8018b44: 681b         	ldr	r3, [r3]
 8018b46: e000         	b	0x8018b4a <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8018b48: 2300         	movs	r3, #0x0
; }
 8018b4a: 4618         	mov	r0, r3
 8018b4c: 3708         	adds	r7, #0x8
 8018b4e: 46bd         	mov	sp, r7
 8018b50: bd80         	pop	{r7, pc}

08018b52 <sys_dlist_remove>:
; {
 8018b52: b580         	push	{r7, lr}
 8018b54: b084         	sub	sp, #0x10
 8018b56: af00         	add	r7, sp, #0x0
 8018b58: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8018b5a: 687b         	ldr	r3, [r7, #0x4]
 8018b5c: 685b         	ldr	r3, [r3, #0x4]
 8018b5e: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8018b60: 687b         	ldr	r3, [r7, #0x4]
 8018b62: 681b         	ldr	r3, [r3]
 8018b64: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8018b66: 68fb         	ldr	r3, [r7, #0xc]
 8018b68: 68ba         	ldr	r2, [r7, #0x8]
 8018b6a: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8018b6c: 68bb         	ldr	r3, [r7, #0x8]
 8018b6e: 68fa         	ldr	r2, [r7, #0xc]
 8018b70: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8018b72: 6878         	ldr	r0, [r7, #0x4]
 8018b74: f7ff ffbb    	bl	0x8018aee <sys_dnode_init> @ imm = #-0x8a
; }
 8018b78: bf00         	nop
 8018b7a: 3710         	adds	r7, #0x10
 8018b7c: 46bd         	mov	sp, r7
 8018b7e: bd80         	pop	{r7, pc}

08018b80 <z_abort_thread_timeout>:
; {
 8018b80: b580         	push	{r7, lr}
 8018b82: b082         	sub	sp, #0x8
 8018b84: af00         	add	r7, sp, #0x0
 8018b86: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8018b88: 687b         	ldr	r3, [r7, #0x4]
 8018b8a: 3318         	adds	r3, #0x18
 8018b8c: 4618         	mov	r0, r3
 8018b8e: f7f6 fee3    	bl	0x800f958 <z_abort_timeout> @ imm = #-0x923a
 8018b92: 4603         	mov	r3, r0
; }
 8018b94: 4618         	mov	r0, r3
 8018b96: 3708         	adds	r7, #0x8
 8018b98: 46bd         	mov	sp, r7
 8018b9a: bd80         	pop	{r7, pc}

08018b9c <z_mark_thread_as_not_pending>:
; {
 8018b9c: b480         	push	{r7}
 8018b9e: b083         	sub	sp, #0xc
 8018ba0: af00         	add	r7, sp, #0x0
 8018ba2: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8018ba4: 687b         	ldr	r3, [r7, #0x4]
 8018ba6: 7b5b         	ldrb	r3, [r3, #0xd]
 8018ba8: f023 0302    	bic	r3, r3, #0x2
 8018bac: b2da         	uxtb	r2, r3
 8018bae: 687b         	ldr	r3, [r7, #0x4]
 8018bb0: 735a         	strb	r2, [r3, #0xd]
; }
 8018bb2: bf00         	nop
 8018bb4: 370c         	adds	r7, #0xc
 8018bb6: 46bd         	mov	sp, r7
 8018bb8: bc80         	pop	{r7}
 8018bba: 4770         	bx	lr

08018bbc <unpend_thread_no_timeout>:
; {
 8018bbc: b580         	push	{r7, lr}
 8018bbe: b086         	sub	sp, #0x18
 8018bc0: af00         	add	r7, sp, #0x0
 8018bc2: 6078         	str	r0, [r7, #0x4]
 8018bc4: 687b         	ldr	r3, [r7, #0x4]
 8018bc6: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8018bc8: 68fb         	ldr	r3, [r7, #0xc]
 8018bca: 689b         	ldr	r3, [r3, #0x8]
 8018bcc: 617b         	str	r3, [r7, #0x14]
 8018bce: 687b         	ldr	r3, [r7, #0x4]
 8018bd0: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8018bd2: 693b         	ldr	r3, [r7, #0x10]
 8018bd4: 4618         	mov	r0, r3
 8018bd6: f7ff ffbc    	bl	0x8018b52 <sys_dlist_remove> @ imm = #-0x88
; }
 8018bda: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8018bdc: 6878         	ldr	r0, [r7, #0x4]
 8018bde: f7ff ffdd    	bl	0x8018b9c <z_mark_thread_as_not_pending> @ imm = #-0x46
; 	thread->base.pended_on = NULL;
 8018be2: 687b         	ldr	r3, [r7, #0x4]
 8018be4: 2200         	movs	r2, #0x0
 8018be6: 609a         	str	r2, [r3, #0x8]
; }
 8018be8: bf00         	nop
 8018bea: 3718         	adds	r7, #0x18
 8018bec: 46bd         	mov	sp, r7
 8018bee: bd80         	pop	{r7, pc}

08018bf0 <z_impl_k_msgq_purge>:
; {
 8018bf0: b580         	push	{r7, lr}
 8018bf2: b098         	sub	sp, #0x60
 8018bf4: af00         	add	r7, sp, #0x0
 8018bf6: 6078         	str	r0, [r7, #0x4]
; 	key = k_spin_lock(&msgq->lock);
 8018bf8: 687b         	ldr	r3, [r7, #0x4]
 8018bfa: 3308         	adds	r3, #0x8
 8018bfc: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8018bfe: f3ef 8311    	mrs	r3, basepri
 8018c02: 643b         	str	r3, [r7, #0x40]
;   return(result);
 8018c04: 6c3b         	ldr	r3, [r7, #0x40]
; 	key = __get_BASEPRI();
 8018c06: 63fb         	str	r3, [r7, #0x3c]
 8018c08: 2310         	movs	r3, #0x10
 8018c0a: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8018c0c: 6bbb         	ldr	r3, [r7, #0x38]
 8018c0e: f383 8812    	msr	basepri_max, r3
; }
 8018c12: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8018c14: f3bf 8f6f    	isb	sy
; }
 8018c18: bf00         	nop
; 	return key;
 8018c1a: 6bfb         	ldr	r3, [r7, #0x3c]
; 	k.key = arch_irq_lock();
 8018c1c: 60fb         	str	r3, [r7, #0xc]
 8018c1e: 6c7b         	ldr	r3, [r7, #0x44]
 8018c20: 637b         	str	r3, [r7, #0x34]
; }
 8018c22: bf00         	nop
 8018c24: 6c7b         	ldr	r3, [r7, #0x44]
 8018c26: 633b         	str	r3, [r7, #0x30]
; }
 8018c28: bf00         	nop
; 	return k;
 8018c2a: 68fb         	ldr	r3, [r7, #0xc]
 8018c2c: 613b         	str	r3, [r7, #0x10]
; 	for (pending_thread = z_unpend_first_thread(&msgq->wait_q); pending_thread != NULL;
 8018c2e: 687b         	ldr	r3, [r7, #0x4]
 8018c30: 65bb         	str	r3, [r7, #0x58]
; 	struct k_thread *thread = NULL;
 8018c32: 2300         	movs	r3, #0x0
 8018c34: 657b         	str	r3, [r7, #0x54]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8018c36: 6dbb         	ldr	r3, [r7, #0x58]
 8018c38: 653b         	str	r3, [r7, #0x50]
; 	struct k_thread *thread = NULL;
 8018c3a: 2300         	movs	r3, #0x0
 8018c3c: 64fb         	str	r3, [r7, #0x4c]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8018c3e: 6d38         	ldr	r0, [r7, #0x50]
 8018c40: f7ff ff75    	bl	0x8018b2e <sys_dlist_peek_head> @ imm = #-0x116
 8018c44: 64b8         	str	r0, [r7, #0x48]
; 	if (n != NULL) {
 8018c46: 6cbb         	ldr	r3, [r7, #0x48]
 8018c48: 2b00         	cmp	r3, #0x0
 8018c4a: d001         	beq	0x8018c50 <z_impl_k_msgq_purge+0x60> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8018c4c: 6cbb         	ldr	r3, [r7, #0x48]
 8018c4e: 64fb         	str	r3, [r7, #0x4c]
; 	return thread;
 8018c50: 6cfb         	ldr	r3, [r7, #0x4c]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8018c52: 657b         	str	r3, [r7, #0x54]
; 		if (unlikely(thread != NULL)) {
 8018c54: 6d7b         	ldr	r3, [r7, #0x54]
 8018c56: 2b00         	cmp	r3, #0x0
 8018c58: bf14         	ite	ne
 8018c5a: 2301         	movne	r3, #0x1
 8018c5c: 2300         	moveq	r3, #0x0
 8018c5e: b2db         	uxtb	r3, r3
 8018c60: 2b00         	cmp	r3, #0x0
 8018c62: d005         	beq	0x8018c70 <z_impl_k_msgq_purge+0x80> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 8018c64: 6d78         	ldr	r0, [r7, #0x54]
 8018c66: f7ff ffa9    	bl	0x8018bbc <unpend_thread_no_timeout> @ imm = #-0xae
; 			(void)z_abort_thread_timeout(thread);
 8018c6a: 6d78         	ldr	r0, [r7, #0x54]
 8018c6c: f7ff ff88    	bl	0x8018b80 <z_abort_thread_timeout> @ imm = #-0xf0
; 	return thread;
 8018c70: 6d7b         	ldr	r3, [r7, #0x54]
; 	for (pending_thread = z_unpend_first_thread(&msgq->wait_q); pending_thread != NULL;
 8018c72: 65fb         	str	r3, [r7, #0x5c]
 8018c74: e02f         	b	0x8018cd6 <z_impl_k_msgq_purge+0xe6> @ imm = #0x5e
 8018c76: 6dfb         	ldr	r3, [r7, #0x5c]
 8018c78: 61bb         	str	r3, [r7, #0x18]
 8018c7a: f06f 0322    	mvn	r3, #0x22
 8018c7e: 617b         	str	r3, [r7, #0x14]
; 	thread->arch.swap_return_value = value;
 8018c80: 69bb         	ldr	r3, [r7, #0x18]
 8018c82: 697a         	ldr	r2, [r7, #0x14]
 8018c84: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8018c88: bf00         	nop
; 		z_ready_thread(pending_thread);
 8018c8a: 6df8         	ldr	r0, [r7, #0x5c]
 8018c8c: f7f5 f8be    	bl	0x800de0c <z_ready_thread> @ imm = #-0xae84
; 		 pending_thread = z_unpend_first_thread(&msgq->wait_q)) {
 8018c90: 687b         	ldr	r3, [r7, #0x4]
 8018c92: 62fb         	str	r3, [r7, #0x2c]
; 	struct k_thread *thread = NULL;
 8018c94: 2300         	movs	r3, #0x0
 8018c96: 62bb         	str	r3, [r7, #0x28]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8018c98: 6afb         	ldr	r3, [r7, #0x2c]
 8018c9a: 627b         	str	r3, [r7, #0x24]
; 	struct k_thread *thread = NULL;
 8018c9c: 2300         	movs	r3, #0x0
 8018c9e: 623b         	str	r3, [r7, #0x20]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8018ca0: 6a78         	ldr	r0, [r7, #0x24]
 8018ca2: f7ff ff44    	bl	0x8018b2e <sys_dlist_peek_head> @ imm = #-0x178
 8018ca6: 61f8         	str	r0, [r7, #0x1c]
; 	if (n != NULL) {
 8018ca8: 69fb         	ldr	r3, [r7, #0x1c]
 8018caa: 2b00         	cmp	r3, #0x0
 8018cac: d001         	beq	0x8018cb2 <z_impl_k_msgq_purge+0xc2> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8018cae: 69fb         	ldr	r3, [r7, #0x1c]
 8018cb0: 623b         	str	r3, [r7, #0x20]
; 	return thread;
 8018cb2: 6a3b         	ldr	r3, [r7, #0x20]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8018cb4: 62bb         	str	r3, [r7, #0x28]
; 		if (unlikely(thread != NULL)) {
 8018cb6: 6abb         	ldr	r3, [r7, #0x28]
 8018cb8: 2b00         	cmp	r3, #0x0
 8018cba: bf14         	ite	ne
 8018cbc: 2301         	movne	r3, #0x1
 8018cbe: 2300         	moveq	r3, #0x0
 8018cc0: b2db         	uxtb	r3, r3
 8018cc2: 2b00         	cmp	r3, #0x0
 8018cc4: d005         	beq	0x8018cd2 <z_impl_k_msgq_purge+0xe2> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 8018cc6: 6ab8         	ldr	r0, [r7, #0x28]
 8018cc8: f7ff ff78    	bl	0x8018bbc <unpend_thread_no_timeout> @ imm = #-0x110
; 			(void)z_abort_thread_timeout(thread);
 8018ccc: 6ab8         	ldr	r0, [r7, #0x28]
 8018cce: f7ff ff57    	bl	0x8018b80 <z_abort_thread_timeout> @ imm = #-0x152
; 	return thread;
 8018cd2: 6abb         	ldr	r3, [r7, #0x28]
; 		 pending_thread = z_unpend_first_thread(&msgq->wait_q)) {
 8018cd4: 65fb         	str	r3, [r7, #0x5c]
; 	for (pending_thread = z_unpend_first_thread(&msgq->wait_q); pending_thread != NULL;
 8018cd6: 6dfb         	ldr	r3, [r7, #0x5c]
 8018cd8: 2b00         	cmp	r3, #0x0
 8018cda: d1cc         	bne	0x8018c76 <z_impl_k_msgq_purge+0x86> @ imm = #-0x68
; 	msgq->used_msgs = 0;
 8018cdc: 687b         	ldr	r3, [r7, #0x4]
 8018cde: 2200         	movs	r2, #0x0
 8018ce0: 621a         	str	r2, [r3, #0x20]
; 	msgq->read_ptr = msgq->write_ptr;
 8018ce2: 687b         	ldr	r3, [r7, #0x4]
 8018ce4: 69da         	ldr	r2, [r3, #0x1c]
 8018ce6: 687b         	ldr	r3, [r7, #0x4]
 8018ce8: 619a         	str	r2, [r3, #0x18]
; 	z_reschedule(&msgq->lock, key);
 8018cea: 687b         	ldr	r3, [r7, #0x4]
 8018cec: 3308         	adds	r3, #0x8
 8018cee: 6939         	ldr	r1, [r7, #0x10]
 8018cf0: 4618         	mov	r0, r3
 8018cf2: f001 fac4    	bl	0x801a27e <z_reschedule> @ imm = #0x1588
; }
 8018cf6: bf00         	nop
 8018cf8: 3760         	adds	r7, #0x60
 8018cfa: 46bd         	mov	sp, r7
 8018cfc: bd80         	pop	{r7, pc}

08018cfe <sys_dlist_init>:
; {
 8018cfe: b480         	push	{r7}
 8018d00: b083         	sub	sp, #0xc
 8018d02: af00         	add	r7, sp, #0x0
 8018d04: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8018d06: 687b         	ldr	r3, [r7, #0x4]
 8018d08: 687a         	ldr	r2, [r7, #0x4]
 8018d0a: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8018d0c: 687b         	ldr	r3, [r7, #0x4]
 8018d0e: 687a         	ldr	r2, [r7, #0x4]
 8018d10: 605a         	str	r2, [r3, #0x4]
; }
 8018d12: bf00         	nop
 8018d14: 370c         	adds	r7, #0xc
 8018d16: 46bd         	mov	sp, r7
 8018d18: bc80         	pop	{r7}
 8018d1a: 4770         	bx	lr

08018d1c <sys_dnode_init>:
; {
 8018d1c: b480         	push	{r7}
 8018d1e: b083         	sub	sp, #0xc
 8018d20: af00         	add	r7, sp, #0x0
 8018d22: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8018d24: 687b         	ldr	r3, [r7, #0x4]
 8018d26: 2200         	movs	r2, #0x0
 8018d28: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8018d2a: 687b         	ldr	r3, [r7, #0x4]
 8018d2c: 2200         	movs	r2, #0x0
 8018d2e: 605a         	str	r2, [r3, #0x4]
; }
 8018d30: bf00         	nop
 8018d32: 370c         	adds	r7, #0xc
 8018d34: 46bd         	mov	sp, r7
 8018d36: bc80         	pop	{r7}
 8018d38: 4770         	bx	lr

08018d3a <sys_dnode_is_linked>:
; {
 8018d3a: b480         	push	{r7}
 8018d3c: b083         	sub	sp, #0xc
 8018d3e: af00         	add	r7, sp, #0x0
 8018d40: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 8018d42: 687b         	ldr	r3, [r7, #0x4]
 8018d44: 681b         	ldr	r3, [r3]
 8018d46: 2b00         	cmp	r3, #0x0
 8018d48: bf14         	ite	ne
 8018d4a: 2301         	movne	r3, #0x1
 8018d4c: 2300         	moveq	r3, #0x0
 8018d4e: b2db         	uxtb	r3, r3
; }
 8018d50: 4618         	mov	r0, r3
 8018d52: 370c         	adds	r7, #0xc
 8018d54: 46bd         	mov	sp, r7
 8018d56: bc80         	pop	{r7}
 8018d58: 4770         	bx	lr

08018d5a <sys_dlist_is_empty>:
; {
 8018d5a: b480         	push	{r7}
 8018d5c: b083         	sub	sp, #0xc
 8018d5e: af00         	add	r7, sp, #0x0
 8018d60: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8018d62: 687b         	ldr	r3, [r7, #0x4]
 8018d64: 681b         	ldr	r3, [r3]
 8018d66: 687a         	ldr	r2, [r7, #0x4]
 8018d68: 429a         	cmp	r2, r3
 8018d6a: bf0c         	ite	eq
 8018d6c: 2301         	moveq	r3, #0x1
 8018d6e: 2300         	movne	r3, #0x0
 8018d70: b2db         	uxtb	r3, r3
; }
 8018d72: 4618         	mov	r0, r3
 8018d74: 370c         	adds	r7, #0xc
 8018d76: 46bd         	mov	sp, r7
 8018d78: bc80         	pop	{r7}
 8018d7a: 4770         	bx	lr

08018d7c <sys_dlist_peek_head>:
; {
 8018d7c: b580         	push	{r7, lr}
 8018d7e: b082         	sub	sp, #0x8
 8018d80: af00         	add	r7, sp, #0x0
 8018d82: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8018d84: 6878         	ldr	r0, [r7, #0x4]
 8018d86: f7ff ffe8    	bl	0x8018d5a <sys_dlist_is_empty> @ imm = #-0x30
 8018d8a: 4603         	mov	r3, r0
 8018d8c: 2b00         	cmp	r3, #0x0
 8018d8e: d102         	bne	0x8018d96 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8018d90: 687b         	ldr	r3, [r7, #0x4]
 8018d92: 681b         	ldr	r3, [r3]
 8018d94: e000         	b	0x8018d98 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8018d96: 2300         	movs	r3, #0x0
; }
 8018d98: 4618         	mov	r0, r3
 8018d9a: 3708         	adds	r7, #0x8
 8018d9c: 46bd         	mov	sp, r7
 8018d9e: bd80         	pop	{r7, pc}

08018da0 <sys_dlist_remove>:
; {
 8018da0: b580         	push	{r7, lr}
 8018da2: b084         	sub	sp, #0x10
 8018da4: af00         	add	r7, sp, #0x0
 8018da6: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8018da8: 687b         	ldr	r3, [r7, #0x4]
 8018daa: 685b         	ldr	r3, [r3, #0x4]
 8018dac: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8018dae: 687b         	ldr	r3, [r7, #0x4]
 8018db0: 681b         	ldr	r3, [r3]
 8018db2: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8018db4: 68fb         	ldr	r3, [r7, #0xc]
 8018db6: 68ba         	ldr	r2, [r7, #0x8]
 8018db8: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8018dba: 68bb         	ldr	r3, [r7, #0x8]
 8018dbc: 68fa         	ldr	r2, [r7, #0xc]
 8018dbe: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8018dc0: 6878         	ldr	r0, [r7, #0x4]
 8018dc2: f7ff ffab    	bl	0x8018d1c <sys_dnode_init> @ imm = #-0xaa
; }
 8018dc6: bf00         	nop
 8018dc8: 3710         	adds	r7, #0x10
 8018dca: 46bd         	mov	sp, r7
 8018dcc: bd80         	pop	{r7, pc}

08018dce <k_object_init>:
; {
 8018dce: b480         	push	{r7}
 8018dd0: b083         	sub	sp, #0xc
 8018dd2: af00         	add	r7, sp, #0x0
 8018dd4: 6078         	str	r0, [r7, #0x4]
; }
 8018dd6: bf00         	nop
 8018dd8: 370c         	adds	r7, #0xc
 8018dda: 46bd         	mov	sp, r7
 8018ddc: bc80         	pop	{r7}
 8018dde: 4770         	bx	lr

08018de0 <z_is_inactive_timeout>:
; {
 8018de0: b580         	push	{r7, lr}
 8018de2: b082         	sub	sp, #0x8
 8018de4: af00         	add	r7, sp, #0x0
 8018de6: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 8018de8: 687b         	ldr	r3, [r7, #0x4]
 8018dea: 4618         	mov	r0, r3
 8018dec: f7ff ffa5    	bl	0x8018d3a <sys_dnode_is_linked> @ imm = #-0xb6
 8018df0: 4603         	mov	r3, r0
 8018df2: 2b00         	cmp	r3, #0x0
 8018df4: bf14         	ite	ne
 8018df6: 2301         	movne	r3, #0x1
 8018df8: 2300         	moveq	r3, #0x0
 8018dfa: b2db         	uxtb	r3, r3
 8018dfc: f083 0301    	eor	r3, r3, #0x1
 8018e00: b2db         	uxtb	r3, r3
 8018e02: f003 0301    	and	r3, r3, #0x1
 8018e06: b2db         	uxtb	r3, r3
; }
 8018e08: 4618         	mov	r0, r3
 8018e0a: 3708         	adds	r7, #0x8
 8018e0c: 46bd         	mov	sp, r7
 8018e0e: bd80         	pop	{r7, pc}

08018e10 <z_abort_thread_timeout>:
; {
 8018e10: b580         	push	{r7, lr}
 8018e12: b082         	sub	sp, #0x8
 8018e14: af00         	add	r7, sp, #0x0
 8018e16: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8018e18: 687b         	ldr	r3, [r7, #0x4]
 8018e1a: 3318         	adds	r3, #0x18
 8018e1c: 4618         	mov	r0, r3
 8018e1e: f7f6 fd9b    	bl	0x800f958 <z_abort_timeout> @ imm = #-0x94ca
 8018e22: 4603         	mov	r3, r0
; }
 8018e24: 4618         	mov	r0, r3
 8018e26: 3708         	adds	r7, #0x8
 8018e28: 46bd         	mov	sp, r7
 8018e2a: bd80         	pop	{r7, pc}

08018e2c <z_is_thread_prevented_from_running>:
; {
 8018e2c: b480         	push	{r7}
 8018e2e: b085         	sub	sp, #0x14
 8018e30: af00         	add	r7, sp, #0x0
 8018e32: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 8018e34: 687b         	ldr	r3, [r7, #0x4]
 8018e36: 7b5b         	ldrb	r3, [r3, #0xd]
 8018e38: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 8018e3a: 7bfb         	ldrb	r3, [r7, #0xf]
 8018e3c: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 8018e40: 2b00         	cmp	r3, #0x0
 8018e42: bf14         	ite	ne
 8018e44: 2301         	movne	r3, #0x1
 8018e46: 2300         	moveq	r3, #0x0
 8018e48: b2db         	uxtb	r3, r3
; }
 8018e4a: 4618         	mov	r0, r3
 8018e4c: 3714         	adds	r7, #0x14
 8018e4e: 46bd         	mov	sp, r7
 8018e50: bc80         	pop	{r7}
 8018e52: 4770         	bx	lr

08018e54 <z_is_thread_timeout_active>:
; {
 8018e54: b580         	push	{r7, lr}
 8018e56: b082         	sub	sp, #0x8
 8018e58: af00         	add	r7, sp, #0x0
 8018e5a: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 8018e5c: 687b         	ldr	r3, [r7, #0x4]
 8018e5e: 3318         	adds	r3, #0x18
 8018e60: 4618         	mov	r0, r3
 8018e62: f7ff ffbd    	bl	0x8018de0 <z_is_inactive_timeout> @ imm = #-0x86
 8018e66: 4603         	mov	r3, r0
 8018e68: 2b00         	cmp	r3, #0x0
 8018e6a: bf14         	ite	ne
 8018e6c: 2301         	movne	r3, #0x1
 8018e6e: 2300         	moveq	r3, #0x0
 8018e70: b2db         	uxtb	r3, r3
 8018e72: f083 0301    	eor	r3, r3, #0x1
 8018e76: b2db         	uxtb	r3, r3
 8018e78: f003 0301    	and	r3, r3, #0x1
 8018e7c: b2db         	uxtb	r3, r3
; }
 8018e7e: 4618         	mov	r0, r3
 8018e80: 3708         	adds	r7, #0x8
 8018e82: 46bd         	mov	sp, r7
 8018e84: bd80         	pop	{r7, pc}

08018e86 <z_is_thread_ready>:
; {
 8018e86: b580         	push	{r7, lr}
 8018e88: b082         	sub	sp, #0x8
 8018e8a: af00         	add	r7, sp, #0x0
 8018e8c: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 8018e8e: 6878         	ldr	r0, [r7, #0x4]
 8018e90: f7ff ffcc    	bl	0x8018e2c <z_is_thread_prevented_from_running> @ imm = #-0x68
 8018e94: 4603         	mov	r3, r0
 8018e96: f083 0301    	eor	r3, r3, #0x1
 8018e9a: b2db         	uxtb	r3, r3
 8018e9c: 2b00         	cmp	r3, #0x0
 8018e9e: d00a         	beq	0x8018eb6 <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 8018ea0: 6878         	ldr	r0, [r7, #0x4]
 8018ea2: f7ff ffd7    	bl	0x8018e54 <z_is_thread_timeout_active> @ imm = #-0x52
 8018ea6: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 8018ea8: f083 0301    	eor	r3, r3, #0x1
 8018eac: b2db         	uxtb	r3, r3
 8018eae: 2b00         	cmp	r3, #0x0
 8018eb0: d001         	beq	0x8018eb6 <z_is_thread_ready+0x30> @ imm = #0x2
 8018eb2: 2301         	movs	r3, #0x1
 8018eb4: e000         	b	0x8018eb8 <z_is_thread_ready+0x32> @ imm = #0x0
 8018eb6: 2300         	movs	r3, #0x0
 8018eb8: f003 0301    	and	r3, r3, #0x1
 8018ebc: b2db         	uxtb	r3, r3
; }
 8018ebe: 4618         	mov	r0, r3
 8018ec0: 3708         	adds	r7, #0x8
 8018ec2: 46bd         	mov	sp, r7
 8018ec4: bd80         	pop	{r7, pc}

08018ec6 <z_mark_thread_as_not_pending>:
; {
 8018ec6: b480         	push	{r7}
 8018ec8: b083         	sub	sp, #0xc
 8018eca: af00         	add	r7, sp, #0x0
 8018ecc: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8018ece: 687b         	ldr	r3, [r7, #0x4]
 8018ed0: 7b5b         	ldrb	r3, [r3, #0xd]
 8018ed2: f023 0302    	bic	r3, r3, #0x2
 8018ed6: b2da         	uxtb	r2, r3
 8018ed8: 687b         	ldr	r3, [r7, #0x4]
 8018eda: 735a         	strb	r2, [r3, #0xd]
; }
 8018edc: bf00         	nop
 8018ede: 370c         	adds	r7, #0xc
 8018ee0: 46bd         	mov	sp, r7
 8018ee2: bc80         	pop	{r7}
 8018ee4: 4770         	bx	lr

08018ee6 <z_is_under_prio_ceiling>:
; {
 8018ee6: b480         	push	{r7}
 8018ee8: b083         	sub	sp, #0xc
 8018eea: af00         	add	r7, sp, #0x0
 8018eec: 6078         	str	r0, [r7, #0x4]
; 	return prio >= CONFIG_PRIORITY_CEILING;
 8018eee: 687b         	ldr	r3, [r7, #0x4]
 8018ef0: f113 0f7f    	cmn.w	r3, #0x7f
 8018ef4: bfac         	ite	ge
 8018ef6: 2301         	movge	r3, #0x1
 8018ef8: 2300         	movlt	r3, #0x0
 8018efa: b2db         	uxtb	r3, r3
; }
 8018efc: 4618         	mov	r0, r3
 8018efe: 370c         	adds	r7, #0xc
 8018f00: 46bd         	mov	sp, r7
 8018f02: bc80         	pop	{r7}
 8018f04: 4770         	bx	lr

08018f06 <z_get_new_prio_with_ceiling>:
; {
 8018f06: b580         	push	{r7, lr}
 8018f08: b082         	sub	sp, #0x8
 8018f0a: af00         	add	r7, sp, #0x0
 8018f0c: 6078         	str	r0, [r7, #0x4]
; 	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
 8018f0e: 6878         	ldr	r0, [r7, #0x4]
 8018f10: f7ff ffe9    	bl	0x8018ee6 <z_is_under_prio_ceiling> @ imm = #-0x2e
 8018f14: 4603         	mov	r3, r0
 8018f16: 2b00         	cmp	r3, #0x0
 8018f18: d001         	beq	0x8018f1e <z_get_new_prio_with_ceiling+0x18> @ imm = #0x2
 8018f1a: 687b         	ldr	r3, [r7, #0x4]
 8018f1c: e001         	b	0x8018f22 <z_get_new_prio_with_ceiling+0x1c> @ imm = #0x2
 8018f1e: f06f 037e    	mvn	r3, #0x7e
; }
 8018f22: 4618         	mov	r0, r3
 8018f24: 3708         	adds	r7, #0x8
 8018f26: 46bd         	mov	sp, r7
 8018f28: bd80         	pop	{r7, pc}

08018f2a <z_is_prio1_higher_than_prio2>:
; {
 8018f2a: b480         	push	{r7}
 8018f2c: b083         	sub	sp, #0xc
 8018f2e: af00         	add	r7, sp, #0x0
 8018f30: 6078         	str	r0, [r7, #0x4]
 8018f32: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 8018f34: 687a         	ldr	r2, [r7, #0x4]
 8018f36: 683b         	ldr	r3, [r7]
 8018f38: 429a         	cmp	r2, r3
 8018f3a: bfb4         	ite	lt
 8018f3c: 2301         	movlt	r3, #0x1
 8018f3e: 2300         	movge	r3, #0x0
 8018f40: b2db         	uxtb	r3, r3
; }
 8018f42: 4618         	mov	r0, r3
 8018f44: 370c         	adds	r7, #0xc
 8018f46: 46bd         	mov	sp, r7
 8018f48: bc80         	pop	{r7}
 8018f4a: 4770         	bx	lr

08018f4c <z_is_prio_higher>:
; {
 8018f4c: b580         	push	{r7, lr}
 8018f4e: b082         	sub	sp, #0x8
 8018f50: af00         	add	r7, sp, #0x0
 8018f52: 6078         	str	r0, [r7, #0x4]
 8018f54: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 8018f56: 6839         	ldr	r1, [r7]
 8018f58: 6878         	ldr	r0, [r7, #0x4]
 8018f5a: f7ff ffe6    	bl	0x8018f2a <z_is_prio1_higher_than_prio2> @ imm = #-0x34
 8018f5e: 4603         	mov	r3, r0
; }
 8018f60: 4618         	mov	r0, r3
 8018f62: 3708         	adds	r7, #0x8
 8018f64: 46bd         	mov	sp, r7
 8018f66: bd80         	pop	{r7, pc}

08018f68 <unpend_thread_no_timeout>:
; {
 8018f68: b580         	push	{r7, lr}
 8018f6a: b086         	sub	sp, #0x18
 8018f6c: af00         	add	r7, sp, #0x0
 8018f6e: 6078         	str	r0, [r7, #0x4]
 8018f70: 687b         	ldr	r3, [r7, #0x4]
 8018f72: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8018f74: 68fb         	ldr	r3, [r7, #0xc]
 8018f76: 689b         	ldr	r3, [r3, #0x8]
 8018f78: 617b         	str	r3, [r7, #0x14]
 8018f7a: 687b         	ldr	r3, [r7, #0x4]
 8018f7c: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8018f7e: 693b         	ldr	r3, [r7, #0x10]
 8018f80: 4618         	mov	r0, r3
 8018f82: f7ff ff0d    	bl	0x8018da0 <sys_dlist_remove> @ imm = #-0x1e6
; }
 8018f86: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8018f88: 6878         	ldr	r0, [r7, #0x4]
 8018f8a: f7ff ff9c    	bl	0x8018ec6 <z_mark_thread_as_not_pending> @ imm = #-0xc8
; 	thread->base.pended_on = NULL;
 8018f8e: 687b         	ldr	r3, [r7, #0x4]
 8018f90: 2200         	movs	r2, #0x0
 8018f92: 609a         	str	r2, [r3, #0x8]
; }
 8018f94: bf00         	nop
 8018f96: 3718         	adds	r7, #0x18
 8018f98: 46bd         	mov	sp, r7
 8018f9a: bd80         	pop	{r7, pc}

08018f9c <z_waitq_init>:
; {
 8018f9c: b580         	push	{r7, lr}
 8018f9e: b082         	sub	sp, #0x8
 8018fa0: af00         	add	r7, sp, #0x0
 8018fa2: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8018fa4: 687b         	ldr	r3, [r7, #0x4]
 8018fa6: 4618         	mov	r0, r3
 8018fa8: f7ff fea9    	bl	0x8018cfe <sys_dlist_init> @ imm = #-0x2ae
; }
 8018fac: bf00         	nop
 8018fae: 3708         	adds	r7, #0x8
 8018fb0: 46bd         	mov	sp, r7
 8018fb2: bd80         	pop	{r7, pc}

08018fb4 <z_waitq_head>:
; {
 8018fb4: b580         	push	{r7, lr}
 8018fb6: b082         	sub	sp, #0x8
 8018fb8: af00         	add	r7, sp, #0x0
 8018fba: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 8018fbc: 687b         	ldr	r3, [r7, #0x4]
 8018fbe: 4618         	mov	r0, r3
 8018fc0: f7ff fedc    	bl	0x8018d7c <sys_dlist_peek_head> @ imm = #-0x248
 8018fc4: 4603         	mov	r3, r0
; }
 8018fc6: 4618         	mov	r0, r3
 8018fc8: 3708         	adds	r7, #0x8
 8018fca: 46bd         	mov	sp, r7
 8018fcc: bd80         	pop	{r7, pc}

08018fce <z_log_msg_runtime_create>:
; {
 8018fce: b580         	push	{r7, lr}
 8018fd0: b08a         	sub	sp, #0x28
 8018fd2: af04         	add	r7, sp, #0x10
 8018fd4: 60b9         	str	r1, [r7, #0x8]
 8018fd6: 607b         	str	r3, [r7, #0x4]
 8018fd8: 4603         	mov	r3, r0
 8018fda: 73fb         	strb	r3, [r7, #0xf]
 8018fdc: 4613         	mov	r3, r2
 8018fde: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8018fe0: f107 032c    	add.w	r3, r7, #0x2c
 8018fe4: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8018fe6: 7bba         	ldrb	r2, [r7, #0xe]
 8018fe8: 7bf8         	ldrb	r0, [r7, #0xf]
 8018fea: 697b         	ldr	r3, [r7, #0x14]
 8018fec: 9303         	str	r3, [sp, #0xc]
 8018fee: 6abb         	ldr	r3, [r7, #0x28]
 8018ff0: 9302         	str	r3, [sp, #0x8]
 8018ff2: 6a7b         	ldr	r3, [r7, #0x24]
 8018ff4: 9301         	str	r3, [sp, #0x4]
 8018ff6: 6a3b         	ldr	r3, [r7, #0x20]
 8018ff8: 9300         	str	r3, [sp]
 8018ffa: 687b         	ldr	r3, [r7, #0x4]
 8018ffc: 68b9         	ldr	r1, [r7, #0x8]
 8018ffe: f7e8 fe35    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x17396
; }
 8019002: bf00         	nop
 8019004: 3718         	adds	r7, #0x18
 8019006: 46bd         	mov	sp, r7
 8019008: bd80         	pop	{r7, pc}

0801900a <z_impl_k_mutex_init>:
; {
 801900a: b580         	push	{r7, lr}
 801900c: b082         	sub	sp, #0x8
 801900e: af00         	add	r7, sp, #0x0
 8019010: 6078         	str	r0, [r7, #0x4]
; 	mutex->owner = NULL;
 8019012: 687b         	ldr	r3, [r7, #0x4]
 8019014: 2200         	movs	r2, #0x0
 8019016: 609a         	str	r2, [r3, #0x8]
; 	mutex->lock_count = 0U;
 8019018: 687b         	ldr	r3, [r7, #0x4]
 801901a: 2200         	movs	r2, #0x0
 801901c: 60da         	str	r2, [r3, #0xc]
; 	z_waitq_init(&mutex->wait_q);
 801901e: 687b         	ldr	r3, [r7, #0x4]
 8019020: 4618         	mov	r0, r3
 8019022: f7ff ffbb    	bl	0x8018f9c <z_waitq_init> @ imm = #-0x8a
; 	k_object_init(mutex);
 8019026: 6878         	ldr	r0, [r7, #0x4]
 8019028: f7ff fed1    	bl	0x8018dce <k_object_init> @ imm = #-0x25e
; 	return 0;
 801902c: 2300         	movs	r3, #0x0
; }
 801902e: 4618         	mov	r0, r3
 8019030: 3708         	adds	r7, #0x8
 8019032: 46bd         	mov	sp, r7
 8019034: bd80         	pop	{r7, pc}

08019036 <new_prio_for_inheritance>:
; {
 8019036: b580         	push	{r7, lr}
 8019038: b084         	sub	sp, #0x10
 801903a: af00         	add	r7, sp, #0x0
 801903c: 6078         	str	r0, [r7, #0x4]
 801903e: 6039         	str	r1, [r7]
; 	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
 8019040: 6839         	ldr	r1, [r7]
 8019042: 6878         	ldr	r0, [r7, #0x4]
 8019044: f7ff ff82    	bl	0x8018f4c <z_is_prio_higher> @ imm = #-0xfc
 8019048: 4603         	mov	r3, r0
 801904a: 2b00         	cmp	r3, #0x0
 801904c: d001         	beq	0x8019052 <new_prio_for_inheritance+0x1c> @ imm = #0x2
 801904e: 687b         	ldr	r3, [r7, #0x4]
 8019050: e000         	b	0x8019054 <new_prio_for_inheritance+0x1e> @ imm = #0x0
 8019052: 683b         	ldr	r3, [r7]
 8019054: 60fb         	str	r3, [r7, #0xc]
; 	new_prio = z_get_new_prio_with_ceiling(new_prio);
 8019056: 68f8         	ldr	r0, [r7, #0xc]
 8019058: f7ff ff55    	bl	0x8018f06 <z_get_new_prio_with_ceiling> @ imm = #-0x156
 801905c: 60f8         	str	r0, [r7, #0xc]
; 	return new_prio;
 801905e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8019060: 4618         	mov	r0, r3
 8019062: 3710         	adds	r7, #0x10
 8019064: 46bd         	mov	sp, r7
 8019066: bd80         	pop	{r7, pc}

08019068 <sys_dlist_init>:
; {
 8019068: b480         	push	{r7}
 801906a: b083         	sub	sp, #0xc
 801906c: af00         	add	r7, sp, #0x0
 801906e: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8019070: 687b         	ldr	r3, [r7, #0x4]
 8019072: 687a         	ldr	r2, [r7, #0x4]
 8019074: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8019076: 687b         	ldr	r3, [r7, #0x4]
 8019078: 687a         	ldr	r2, [r7, #0x4]
 801907a: 605a         	str	r2, [r3, #0x4]
; }
 801907c: bf00         	nop
 801907e: 370c         	adds	r7, #0xc
 8019080: 46bd         	mov	sp, r7
 8019082: bc80         	pop	{r7}
 8019084: 4770         	bx	lr

08019086 <sys_dnode_init>:
; {
 8019086: b480         	push	{r7}
 8019088: b083         	sub	sp, #0xc
 801908a: af00         	add	r7, sp, #0x0
 801908c: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801908e: 687b         	ldr	r3, [r7, #0x4]
 8019090: 2200         	movs	r2, #0x0
 8019092: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8019094: 687b         	ldr	r3, [r7, #0x4]
 8019096: 2200         	movs	r2, #0x0
 8019098: 605a         	str	r2, [r3, #0x4]
; }
 801909a: bf00         	nop
 801909c: 370c         	adds	r7, #0xc
 801909e: 46bd         	mov	sp, r7
 80190a0: bc80         	pop	{r7}
 80190a2: 4770         	bx	lr

080190a4 <sys_dlist_is_empty>:
; {
 80190a4: b480         	push	{r7}
 80190a6: b083         	sub	sp, #0xc
 80190a8: af00         	add	r7, sp, #0x0
 80190aa: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 80190ac: 687b         	ldr	r3, [r7, #0x4]
 80190ae: 681b         	ldr	r3, [r3]
 80190b0: 687a         	ldr	r2, [r7, #0x4]
 80190b2: 429a         	cmp	r2, r3
 80190b4: bf0c         	ite	eq
 80190b6: 2301         	moveq	r3, #0x1
 80190b8: 2300         	movne	r3, #0x0
 80190ba: b2db         	uxtb	r3, r3
; }
 80190bc: 4618         	mov	r0, r3
 80190be: 370c         	adds	r7, #0xc
 80190c0: 46bd         	mov	sp, r7
 80190c2: bc80         	pop	{r7}
 80190c4: 4770         	bx	lr

080190c6 <sys_dlist_peek_head>:
; {
 80190c6: b580         	push	{r7, lr}
 80190c8: b082         	sub	sp, #0x8
 80190ca: af00         	add	r7, sp, #0x0
 80190cc: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 80190ce: 6878         	ldr	r0, [r7, #0x4]
 80190d0: f7ff ffe8    	bl	0x80190a4 <sys_dlist_is_empty> @ imm = #-0x30
 80190d4: 4603         	mov	r3, r0
 80190d6: 2b00         	cmp	r3, #0x0
 80190d8: d102         	bne	0x80190e0 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 80190da: 687b         	ldr	r3, [r7, #0x4]
 80190dc: 681b         	ldr	r3, [r3]
 80190de: e000         	b	0x80190e2 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 80190e0: 2300         	movs	r3, #0x0
; }
 80190e2: 4618         	mov	r0, r3
 80190e4: 3708         	adds	r7, #0x8
 80190e6: 46bd         	mov	sp, r7
 80190e8: bd80         	pop	{r7, pc}

080190ea <sys_dlist_remove>:
; {
 80190ea: b580         	push	{r7, lr}
 80190ec: b084         	sub	sp, #0x10
 80190ee: af00         	add	r7, sp, #0x0
 80190f0: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 80190f2: 687b         	ldr	r3, [r7, #0x4]
 80190f4: 685b         	ldr	r3, [r3, #0x4]
 80190f6: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 80190f8: 687b         	ldr	r3, [r7, #0x4]
 80190fa: 681b         	ldr	r3, [r3]
 80190fc: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 80190fe: 68fb         	ldr	r3, [r7, #0xc]
 8019100: 68ba         	ldr	r2, [r7, #0x8]
 8019102: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8019104: 68bb         	ldr	r3, [r7, #0x8]
 8019106: 68fa         	ldr	r2, [r7, #0xc]
 8019108: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 801910a: 6878         	ldr	r0, [r7, #0x4]
 801910c: f7ff ffbb    	bl	0x8019086 <sys_dnode_init> @ imm = #-0x8a
; }
 8019110: bf00         	nop
 8019112: 3710         	adds	r7, #0x10
 8019114: 46bd         	mov	sp, r7
 8019116: bd80         	pop	{r7, pc}

08019118 <k_object_init>:
; {
 8019118: b480         	push	{r7}
 801911a: b083         	sub	sp, #0xc
 801911c: af00         	add	r7, sp, #0x0
 801911e: 6078         	str	r0, [r7, #0x4]
; }
 8019120: bf00         	nop
 8019122: 370c         	adds	r7, #0xc
 8019124: 46bd         	mov	sp, r7
 8019126: bc80         	pop	{r7}
 8019128: 4770         	bx	lr

0801912a <z_abort_thread_timeout>:
; {
 801912a: b580         	push	{r7, lr}
 801912c: b082         	sub	sp, #0x8
 801912e: af00         	add	r7, sp, #0x0
 8019130: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8019132: 687b         	ldr	r3, [r7, #0x4]
 8019134: 3318         	adds	r3, #0x18
 8019136: 4618         	mov	r0, r3
 8019138: f7f6 fc0e    	bl	0x800f958 <z_abort_timeout> @ imm = #-0x97e4
 801913c: 4603         	mov	r3, r0
; }
 801913e: 4618         	mov	r0, r3
 8019140: 3708         	adds	r7, #0x8
 8019142: 46bd         	mov	sp, r7
 8019144: bd80         	pop	{r7, pc}

08019146 <z_waitq_init>:
; {
 8019146: b580         	push	{r7, lr}
 8019148: b082         	sub	sp, #0x8
 801914a: af00         	add	r7, sp, #0x0
 801914c: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 801914e: 687b         	ldr	r3, [r7, #0x4]
 8019150: 4618         	mov	r0, r3
 8019152: f7ff ff89    	bl	0x8019068 <sys_dlist_init> @ imm = #-0xee
; }
 8019156: bf00         	nop
 8019158: 3708         	adds	r7, #0x8
 801915a: 46bd         	mov	sp, r7
 801915c: bd80         	pop	{r7, pc}

0801915e <z_mark_thread_as_not_pending>:
; {
 801915e: b480         	push	{r7}
 8019160: b083         	sub	sp, #0xc
 8019162: af00         	add	r7, sp, #0x0
 8019164: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8019166: 687b         	ldr	r3, [r7, #0x4]
 8019168: 7b5b         	ldrb	r3, [r3, #0xd]
 801916a: f023 0302    	bic	r3, r3, #0x2
 801916e: b2da         	uxtb	r2, r3
 8019170: 687b         	ldr	r3, [r7, #0x4]
 8019172: 735a         	strb	r2, [r3, #0xd]
; }
 8019174: bf00         	nop
 8019176: 370c         	adds	r7, #0xc
 8019178: 46bd         	mov	sp, r7
 801917a: bc80         	pop	{r7}
 801917c: 4770         	bx	lr

0801917e <unpend_thread_no_timeout>:
; {
 801917e: b580         	push	{r7, lr}
 8019180: b086         	sub	sp, #0x18
 8019182: af00         	add	r7, sp, #0x0
 8019184: 6078         	str	r0, [r7, #0x4]
 8019186: 687b         	ldr	r3, [r7, #0x4]
 8019188: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 801918a: 68fb         	ldr	r3, [r7, #0xc]
 801918c: 689b         	ldr	r3, [r3, #0x8]
 801918e: 617b         	str	r3, [r7, #0x14]
 8019190: 687b         	ldr	r3, [r7, #0x4]
 8019192: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8019194: 693b         	ldr	r3, [r7, #0x10]
 8019196: 4618         	mov	r0, r3
 8019198: f7ff ffa7    	bl	0x80190ea <sys_dlist_remove> @ imm = #-0xb2
; }
 801919c: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 801919e: 6878         	ldr	r0, [r7, #0x4]
 80191a0: f7ff ffdd    	bl	0x801915e <z_mark_thread_as_not_pending> @ imm = #-0x46
; 	thread->base.pended_on = NULL;
 80191a4: 687b         	ldr	r3, [r7, #0x4]
 80191a6: 2200         	movs	r2, #0x0
 80191a8: 609a         	str	r2, [r3, #0x8]
; }
 80191aa: bf00         	nop
 80191ac: 3718         	adds	r7, #0x18
 80191ae: 46bd         	mov	sp, r7
 80191b0: bd80         	pop	{r7, pc}

080191b2 <z_impl_k_sem_init>:
; {
 80191b2: b580         	push	{r7, lr}
 80191b4: b084         	sub	sp, #0x10
 80191b6: af00         	add	r7, sp, #0x0
 80191b8: 60f8         	str	r0, [r7, #0xc]
 80191ba: 60b9         	str	r1, [r7, #0x8]
 80191bc: 607a         	str	r2, [r7, #0x4]
; 	CHECKIF(limit == 0U || initial_count > limit) {
 80191be: 687b         	ldr	r3, [r7, #0x4]
 80191c0: 2b00         	cmp	r3, #0x0
 80191c2: d003         	beq	0x80191cc <z_impl_k_sem_init+0x1a> @ imm = #0x6
 80191c4: 68ba         	ldr	r2, [r7, #0x8]
 80191c6: 687b         	ldr	r3, [r7, #0x4]
 80191c8: 429a         	cmp	r2, r3
 80191ca: d902         	bls	0x80191d2 <z_impl_k_sem_init+0x20> @ imm = #0x4
; 		return -EINVAL;
 80191cc: f06f 0315    	mvn	r3, #0x15
 80191d0: e00d         	b	0x80191ee <z_impl_k_sem_init+0x3c> @ imm = #0x1a
; 	sem->count = initial_count;
 80191d2: 68fb         	ldr	r3, [r7, #0xc]
 80191d4: 68ba         	ldr	r2, [r7, #0x8]
 80191d6: 609a         	str	r2, [r3, #0x8]
; 	sem->limit = limit;
 80191d8: 68fb         	ldr	r3, [r7, #0xc]
 80191da: 687a         	ldr	r2, [r7, #0x4]
 80191dc: 60da         	str	r2, [r3, #0xc]
; 	z_waitq_init(&sem->wait_q);
 80191de: 68fb         	ldr	r3, [r7, #0xc]
 80191e0: 4618         	mov	r0, r3
 80191e2: f7ff ffb0    	bl	0x8019146 <z_waitq_init> @ imm = #-0xa0
; 	k_object_init(sem);
 80191e6: 68f8         	ldr	r0, [r7, #0xc]
 80191e8: f7ff ff96    	bl	0x8019118 <k_object_init> @ imm = #-0xd4
; 	return 0;
 80191ec: 2300         	movs	r3, #0x0
; }
 80191ee: 4618         	mov	r0, r3
 80191f0: 3710         	adds	r7, #0x10
 80191f2: 46bd         	mov	sp, r7
 80191f4: bd80         	pop	{r7, pc}

080191f6 <handle_poll_events>:
; {
 80191f6: b480         	push	{r7}
 80191f8: b083         	sub	sp, #0xc
 80191fa: af00         	add	r7, sp, #0x0
 80191fc: 6078         	str	r0, [r7, #0x4]
; 	return false;
 80191fe: 2300         	movs	r3, #0x0
; }
 8019200: 4618         	mov	r0, r3
 8019202: 370c         	adds	r7, #0xc
 8019204: 46bd         	mov	sp, r7
 8019206: bc80         	pop	{r7}
 8019208: 4770         	bx	lr

0801920a <sys_dlist_init>:
; {
 801920a: b480         	push	{r7}
 801920c: b083         	sub	sp, #0xc
 801920e: af00         	add	r7, sp, #0x0
 8019210: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8019212: 687b         	ldr	r3, [r7, #0x4]
 8019214: 687a         	ldr	r2, [r7, #0x4]
 8019216: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8019218: 687b         	ldr	r3, [r7, #0x4]
 801921a: 687a         	ldr	r2, [r7, #0x4]
 801921c: 605a         	str	r2, [r3, #0x4]
; }
 801921e: bf00         	nop
 8019220: 370c         	adds	r7, #0xc
 8019222: 46bd         	mov	sp, r7
 8019224: bc80         	pop	{r7}
 8019226: 4770         	bx	lr

08019228 <sys_dnode_init>:
; {
 8019228: b480         	push	{r7}
 801922a: b083         	sub	sp, #0xc
 801922c: af00         	add	r7, sp, #0x0
 801922e: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8019230: 687b         	ldr	r3, [r7, #0x4]
 8019232: 2200         	movs	r2, #0x0
 8019234: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8019236: 687b         	ldr	r3, [r7, #0x4]
 8019238: 2200         	movs	r2, #0x0
 801923a: 605a         	str	r2, [r3, #0x4]
; }
 801923c: bf00         	nop
 801923e: 370c         	adds	r7, #0xc
 8019240: 46bd         	mov	sp, r7
 8019242: bc80         	pop	{r7}
 8019244: 4770         	bx	lr

08019246 <sys_slist_init>:
; {
 8019246: b480         	push	{r7}
 8019248: b083         	sub	sp, #0xc
 801924a: af00         	add	r7, sp, #0x0
 801924c: 6078         	str	r0, [r7, #0x4]
; 	list->head = NULL;
 801924e: 687b         	ldr	r3, [r7, #0x4]
 8019250: 2200         	movs	r2, #0x0
 8019252: 601a         	str	r2, [r3]
; 	list->tail = NULL;
 8019254: 687b         	ldr	r3, [r7, #0x4]
 8019256: 2200         	movs	r2, #0x0
 8019258: 605a         	str	r2, [r3, #0x4]
; }
 801925a: bf00         	nop
 801925c: 370c         	adds	r7, #0xc
 801925e: 46bd         	mov	sp, r7
 8019260: bc80         	pop	{r7}
 8019262: 4770         	bx	lr

08019264 <z_snode_next_peek>:
; {
 8019264: b480         	push	{r7}
 8019266: b083         	sub	sp, #0xc
 8019268: af00         	add	r7, sp, #0x0
 801926a: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 801926c: 687b         	ldr	r3, [r7, #0x4]
 801926e: 681b         	ldr	r3, [r3]
; }
 8019270: 4618         	mov	r0, r3
 8019272: 370c         	adds	r7, #0xc
 8019274: 46bd         	mov	sp, r7
 8019276: bc80         	pop	{r7}
 8019278: 4770         	bx	lr

0801927a <z_snode_next_set>:
; {
 801927a: b480         	push	{r7}
 801927c: b083         	sub	sp, #0xc
 801927e: af00         	add	r7, sp, #0x0
 8019280: 6078         	str	r0, [r7, #0x4]
 8019282: 6039         	str	r1, [r7]
; 	parent->next = child;
 8019284: 687b         	ldr	r3, [r7, #0x4]
 8019286: 683a         	ldr	r2, [r7]
 8019288: 601a         	str	r2, [r3]
; }
 801928a: bf00         	nop
 801928c: 370c         	adds	r7, #0xc
 801928e: 46bd         	mov	sp, r7
 8019290: bc80         	pop	{r7}
 8019292: 4770         	bx	lr

08019294 <z_slist_head_set>:
; {
 8019294: b480         	push	{r7}
 8019296: b083         	sub	sp, #0xc
 8019298: af00         	add	r7, sp, #0x0
 801929a: 6078         	str	r0, [r7, #0x4]
 801929c: 6039         	str	r1, [r7]
; 	list->head = node;
 801929e: 687b         	ldr	r3, [r7, #0x4]
 80192a0: 683a         	ldr	r2, [r7]
 80192a2: 601a         	str	r2, [r3]
; }
 80192a4: bf00         	nop
 80192a6: 370c         	adds	r7, #0xc
 80192a8: 46bd         	mov	sp, r7
 80192aa: bc80         	pop	{r7}
 80192ac: 4770         	bx	lr

080192ae <z_slist_tail_set>:
; {
 80192ae: b480         	push	{r7}
 80192b0: b083         	sub	sp, #0xc
 80192b2: af00         	add	r7, sp, #0x0
 80192b4: 6078         	str	r0, [r7, #0x4]
 80192b6: 6039         	str	r1, [r7]
; 	list->tail = node;
 80192b8: 687b         	ldr	r3, [r7, #0x4]
 80192ba: 683a         	ldr	r2, [r7]
 80192bc: 605a         	str	r2, [r3, #0x4]
; }
 80192be: bf00         	nop
 80192c0: 370c         	adds	r7, #0xc
 80192c2: 46bd         	mov	sp, r7
 80192c4: bc80         	pop	{r7}
 80192c6: 4770         	bx	lr

080192c8 <sys_slist_peek_head>:
; {
 80192c8: b480         	push	{r7}
 80192ca: b083         	sub	sp, #0xc
 80192cc: af00         	add	r7, sp, #0x0
 80192ce: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 80192d0: 687b         	ldr	r3, [r7, #0x4]
 80192d2: 681b         	ldr	r3, [r3]
; }
 80192d4: 4618         	mov	r0, r3
 80192d6: 370c         	adds	r7, #0xc
 80192d8: 46bd         	mov	sp, r7
 80192da: bc80         	pop	{r7}
 80192dc: 4770         	bx	lr

080192de <sys_slist_peek_tail>:
; {
 80192de: b480         	push	{r7}
 80192e0: b083         	sub	sp, #0xc
 80192e2: af00         	add	r7, sp, #0x0
 80192e4: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 80192e6: 687b         	ldr	r3, [r7, #0x4]
 80192e8: 685b         	ldr	r3, [r3, #0x4]
; }
 80192ea: 4618         	mov	r0, r3
 80192ec: 370c         	adds	r7, #0xc
 80192ee: 46bd         	mov	sp, r7
 80192f0: bc80         	pop	{r7}
 80192f2: 4770         	bx	lr

080192f4 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 80192f4: b580         	push	{r7, lr}
 80192f6: b082         	sub	sp, #0x8
 80192f8: af00         	add	r7, sp, #0x0
 80192fa: 6078         	str	r0, [r7, #0x4]
 80192fc: 6878         	ldr	r0, [r7, #0x4]
 80192fe: f7ff ffe3    	bl	0x80192c8 <sys_slist_peek_head> @ imm = #-0x3a
 8019302: 4603         	mov	r3, r0
 8019304: 2b00         	cmp	r3, #0x0
 8019306: bf0c         	ite	eq
 8019308: 2301         	moveq	r3, #0x1
 801930a: 2300         	movne	r3, #0x0
 801930c: b2db         	uxtb	r3, r3
 801930e: 4618         	mov	r0, r3
 8019310: 3708         	adds	r7, #0x8
 8019312: 46bd         	mov	sp, r7
 8019314: bd80         	pop	{r7, pc}

08019316 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8019316: b580         	push	{r7, lr}
 8019318: b082         	sub	sp, #0x8
 801931a: af00         	add	r7, sp, #0x0
 801931c: 6078         	str	r0, [r7, #0x4]
 801931e: 6878         	ldr	r0, [r7, #0x4]
 8019320: f7ff ffa0    	bl	0x8019264 <z_snode_next_peek> @ imm = #-0xc0
 8019324: 4603         	mov	r3, r0
 8019326: 4618         	mov	r0, r3
 8019328: 3708         	adds	r7, #0x8
 801932a: 46bd         	mov	sp, r7
 801932c: bd80         	pop	{r7, pc}

0801932e <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 801932e: b580         	push	{r7, lr}
 8019330: b082         	sub	sp, #0x8
 8019332: af00         	add	r7, sp, #0x0
 8019334: 6078         	str	r0, [r7, #0x4]
 8019336: 687b         	ldr	r3, [r7, #0x4]
 8019338: 2b00         	cmp	r3, #0x0
 801933a: d004         	beq	0x8019346 <sys_slist_peek_next+0x18> @ imm = #0x8
 801933c: 6878         	ldr	r0, [r7, #0x4]
 801933e: f7ff ffea    	bl	0x8019316 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 8019342: 4603         	mov	r3, r0
 8019344: e000         	b	0x8019348 <sys_slist_peek_next+0x1a> @ imm = #0x0
 8019346: 2300         	movs	r3, #0x0
 8019348: 4618         	mov	r0, r3
 801934a: 3708         	adds	r7, #0x8
 801934c: 46bd         	mov	sp, r7
 801934e: bd80         	pop	{r7, pc}

08019350 <sys_slist_append>:
; Z_GENLIST_APPEND(slist, snode)
 8019350: b580         	push	{r7, lr}
 8019352: b082         	sub	sp, #0x8
 8019354: af00         	add	r7, sp, #0x0
 8019356: 6078         	str	r0, [r7, #0x4]
 8019358: 6039         	str	r1, [r7]
 801935a: 2100         	movs	r1, #0x0
 801935c: 6838         	ldr	r0, [r7]
 801935e: f7ff ff8c    	bl	0x801927a <z_snode_next_set> @ imm = #-0xe8
 8019362: 6878         	ldr	r0, [r7, #0x4]
 8019364: f7ff ffbb    	bl	0x80192de <sys_slist_peek_tail> @ imm = #-0x8a
 8019368: 4603         	mov	r3, r0
 801936a: 2b00         	cmp	r3, #0x0
 801936c: d108         	bne	0x8019380 <sys_slist_append+0x30> @ imm = #0x10
 801936e: 6839         	ldr	r1, [r7]
 8019370: 6878         	ldr	r0, [r7, #0x4]
 8019372: f7ff ff9c    	bl	0x80192ae <z_slist_tail_set> @ imm = #-0xc8
 8019376: 6839         	ldr	r1, [r7]
 8019378: 6878         	ldr	r0, [r7, #0x4]
 801937a: f7ff ff8b    	bl	0x8019294 <z_slist_head_set> @ imm = #-0xea
 801937e: e00b         	b	0x8019398 <sys_slist_append+0x48> @ imm = #0x16
 8019380: 6878         	ldr	r0, [r7, #0x4]
 8019382: f7ff ffac    	bl	0x80192de <sys_slist_peek_tail> @ imm = #-0xa8
 8019386: 4603         	mov	r3, r0
 8019388: 6839         	ldr	r1, [r7]
 801938a: 4618         	mov	r0, r3
 801938c: f7ff ff75    	bl	0x801927a <z_snode_next_set> @ imm = #-0x116
 8019390: 6839         	ldr	r1, [r7]
 8019392: 6878         	ldr	r0, [r7, #0x4]
 8019394: f7ff ff8b    	bl	0x80192ae <z_slist_tail_set> @ imm = #-0xea
 8019398: 3708         	adds	r7, #0x8
 801939a: 46bd         	mov	sp, r7
 801939c: bd80         	pop	{r7, pc}

0801939e <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 801939e: b580         	push	{r7, lr}
 80193a0: b084         	sub	sp, #0x10
 80193a2: af00         	add	r7, sp, #0x0
 80193a4: 6078         	str	r0, [r7, #0x4]
 80193a6: 6878         	ldr	r0, [r7, #0x4]
 80193a8: f7ff ff8e    	bl	0x80192c8 <sys_slist_peek_head> @ imm = #-0xe4
 80193ac: 60f8         	str	r0, [r7, #0xc]
 80193ae: 68f8         	ldr	r0, [r7, #0xc]
 80193b0: f7ff ff58    	bl	0x8019264 <z_snode_next_peek> @ imm = #-0x150
 80193b4: 4603         	mov	r3, r0
 80193b6: 4619         	mov	r1, r3
 80193b8: 6878         	ldr	r0, [r7, #0x4]
 80193ba: f7ff ff6b    	bl	0x8019294 <z_slist_head_set> @ imm = #-0x12a
 80193be: 6878         	ldr	r0, [r7, #0x4]
 80193c0: f7ff ff8d    	bl	0x80192de <sys_slist_peek_tail> @ imm = #-0xe6
 80193c4: 4602         	mov	r2, r0
 80193c6: 68fb         	ldr	r3, [r7, #0xc]
 80193c8: 4293         	cmp	r3, r2
 80193ca: d107         	bne	0x80193dc <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 80193cc: 6878         	ldr	r0, [r7, #0x4]
 80193ce: f7ff ff7b    	bl	0x80192c8 <sys_slist_peek_head> @ imm = #-0x10a
 80193d2: 4603         	mov	r3, r0
 80193d4: 4619         	mov	r1, r3
 80193d6: 6878         	ldr	r0, [r7, #0x4]
 80193d8: f7ff ff69    	bl	0x80192ae <z_slist_tail_set> @ imm = #-0x12e
 80193dc: 68fb         	ldr	r3, [r7, #0xc]
 80193de: 4618         	mov	r0, r3
 80193e0: 3710         	adds	r7, #0x10
 80193e2: 46bd         	mov	sp, r7
 80193e4: bd80         	pop	{r7, pc}

080193e6 <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 80193e6: b580         	push	{r7, lr}
 80193e8: b082         	sub	sp, #0x8
 80193ea: af00         	add	r7, sp, #0x0
 80193ec: 6078         	str	r0, [r7, #0x4]
 80193ee: 6878         	ldr	r0, [r7, #0x4]
 80193f0: f7ff ff80    	bl	0x80192f4 <sys_slist_is_empty> @ imm = #-0x100
 80193f4: 4603         	mov	r3, r0
 80193f6: 2b00         	cmp	r3, #0x0
 80193f8: d104         	bne	0x8019404 <sys_slist_get+0x1e> @ imm = #0x8
 80193fa: 6878         	ldr	r0, [r7, #0x4]
 80193fc: f7ff ffcf    	bl	0x801939e <sys_slist_get_not_empty> @ imm = #-0x62
 8019400: 4603         	mov	r3, r0
 8019402: e000         	b	0x8019406 <sys_slist_get+0x20> @ imm = #0x0
 8019404: 2300         	movs	r3, #0x0
 8019406: 4618         	mov	r0, r3
 8019408: 3708         	adds	r7, #0x8
 801940a: 46bd         	mov	sp, r7
 801940c: bd80         	pop	{r7, pc}

0801940e <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 801940e: b580         	push	{r7, lr}
 8019410: b084         	sub	sp, #0x10
 8019412: af00         	add	r7, sp, #0x0
 8019414: 60f8         	str	r0, [r7, #0xc]
 8019416: 60b9         	str	r1, [r7, #0x8]
 8019418: 607a         	str	r2, [r7, #0x4]
 801941a: 68bb         	ldr	r3, [r7, #0x8]
 801941c: 2b00         	cmp	r3, #0x0
 801941e: d117         	bne	0x8019450 <sys_slist_remove+0x42> @ imm = #0x2e
 8019420: 6878         	ldr	r0, [r7, #0x4]
 8019422: f7ff ff1f    	bl	0x8019264 <z_snode_next_peek> @ imm = #-0x1c2
 8019426: 4603         	mov	r3, r0
 8019428: 4619         	mov	r1, r3
 801942a: 68f8         	ldr	r0, [r7, #0xc]
 801942c: f7ff ff32    	bl	0x8019294 <z_slist_head_set> @ imm = #-0x19c
 8019430: 68f8         	ldr	r0, [r7, #0xc]
 8019432: f7ff ff54    	bl	0x80192de <sys_slist_peek_tail> @ imm = #-0x158
 8019436: 4602         	mov	r2, r0
 8019438: 687b         	ldr	r3, [r7, #0x4]
 801943a: 4293         	cmp	r3, r2
 801943c: d11b         	bne	0x8019476 <sys_slist_remove+0x68> @ imm = #0x36
 801943e: 68f8         	ldr	r0, [r7, #0xc]
 8019440: f7ff ff42    	bl	0x80192c8 <sys_slist_peek_head> @ imm = #-0x17c
 8019444: 4603         	mov	r3, r0
 8019446: 4619         	mov	r1, r3
 8019448: 68f8         	ldr	r0, [r7, #0xc]
 801944a: f7ff ff30    	bl	0x80192ae <z_slist_tail_set> @ imm = #-0x1a0
 801944e: e012         	b	0x8019476 <sys_slist_remove+0x68> @ imm = #0x24
 8019450: 6878         	ldr	r0, [r7, #0x4]
 8019452: f7ff ff07    	bl	0x8019264 <z_snode_next_peek> @ imm = #-0x1f2
 8019456: 4603         	mov	r3, r0
 8019458: 4619         	mov	r1, r3
 801945a: 68b8         	ldr	r0, [r7, #0x8]
 801945c: f7ff ff0d    	bl	0x801927a <z_snode_next_set> @ imm = #-0x1e6
 8019460: 68f8         	ldr	r0, [r7, #0xc]
 8019462: f7ff ff3c    	bl	0x80192de <sys_slist_peek_tail> @ imm = #-0x188
 8019466: 4602         	mov	r2, r0
 8019468: 687b         	ldr	r3, [r7, #0x4]
 801946a: 4293         	cmp	r3, r2
 801946c: d103         	bne	0x8019476 <sys_slist_remove+0x68> @ imm = #0x6
 801946e: 68b9         	ldr	r1, [r7, #0x8]
 8019470: 68f8         	ldr	r0, [r7, #0xc]
 8019472: f7ff ff1c    	bl	0x80192ae <z_slist_tail_set> @ imm = #-0x1c8
 8019476: 2100         	movs	r1, #0x0
 8019478: 6878         	ldr	r0, [r7, #0x4]
 801947a: f7ff fefe    	bl	0x801927a <z_snode_next_set> @ imm = #-0x204
 801947e: 3710         	adds	r7, #0x10
 8019480: 46bd         	mov	sp, r7
 8019482: bd80         	pop	{r7, pc}

08019484 <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8019484: b580         	push	{r7, lr}
 8019486: b084         	sub	sp, #0x10
 8019488: af00         	add	r7, sp, #0x0
 801948a: 6078         	str	r0, [r7, #0x4]
 801948c: 6039         	str	r1, [r7]
 801948e: 2300         	movs	r3, #0x0
 8019490: 60fb         	str	r3, [r7, #0xc]
 8019492: 6878         	ldr	r0, [r7, #0x4]
 8019494: f7ff ff18    	bl	0x80192c8 <sys_slist_peek_head> @ imm = #-0x1d0
 8019498: 60b8         	str	r0, [r7, #0x8]
 801949a: e010         	b	0x80194be <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 801949c: 68ba         	ldr	r2, [r7, #0x8]
 801949e: 683b         	ldr	r3, [r7]
 80194a0: 429a         	cmp	r2, r3
 80194a2: d106         	bne	0x80194b2 <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 80194a4: 683a         	ldr	r2, [r7]
 80194a6: 68f9         	ldr	r1, [r7, #0xc]
 80194a8: 6878         	ldr	r0, [r7, #0x4]
 80194aa: f7ff ffb0    	bl	0x801940e <sys_slist_remove> @ imm = #-0xa0
 80194ae: 2301         	movs	r3, #0x1
 80194b0: e009         	b	0x80194c6 <sys_slist_find_and_remove+0x42> @ imm = #0x12
 80194b2: 68bb         	ldr	r3, [r7, #0x8]
 80194b4: 60fb         	str	r3, [r7, #0xc]
 80194b6: 68b8         	ldr	r0, [r7, #0x8]
 80194b8: f7ff ff39    	bl	0x801932e <sys_slist_peek_next> @ imm = #-0x18e
 80194bc: 60b8         	str	r0, [r7, #0x8]
 80194be: 68bb         	ldr	r3, [r7, #0x8]
 80194c0: 2b00         	cmp	r3, #0x0
 80194c2: d1eb         	bne	0x801949c <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 80194c4: 2300         	movs	r3, #0x0
 80194c6: 4618         	mov	r0, r3
 80194c8: 3710         	adds	r7, #0x10
 80194ca: 46bd         	mov	sp, r7
 80194cc: bd80         	pop	{r7, pc}

080194ce <k_thread_start>:
; {
 80194ce: b580         	push	{r7, lr}
 80194d0: b082         	sub	sp, #0x8
 80194d2: af00         	add	r7, sp, #0x0
 80194d4: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 80194d6: 6878         	ldr	r0, [r7, #0x4]
 80194d8: f000 f82a    	bl	0x8019530 <k_thread_resume> @ imm = #0x54
; }
 80194dc: bf00         	nop
 80194de: 3708         	adds	r7, #0x8
 80194e0: 46bd         	mov	sp, r7
 80194e2: bd80         	pop	{r7, pc}

080194e4 <k_thread_create>:
; {
 80194e4: b580         	push	{r7, lr}
 80194e6: b08c         	sub	sp, #0x30
 80194e8: af08         	add	r7, sp, #0x20
 80194ea: 60f8         	str	r0, [r7, #0xc]
 80194ec: 60b9         	str	r1, [r7, #0x8]
 80194ee: 607a         	str	r2, [r7, #0x4]
 80194f0: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 80194f2: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 80194f6: e9cd 2306    	strd	r2, r3, [sp, #24]
 80194fa: 6abb         	ldr	r3, [r7, #0x28]
 80194fc: 9304         	str	r3, [sp, #0x10]
 80194fe: 6a7b         	ldr	r3, [r7, #0x24]
 8019500: 9303         	str	r3, [sp, #0xc]
 8019502: 6a3b         	ldr	r3, [r7, #0x20]
 8019504: 9302         	str	r3, [sp, #0x8]
 8019506: 69fb         	ldr	r3, [r7, #0x1c]
 8019508: 9301         	str	r3, [sp, #0x4]
 801950a: 69bb         	ldr	r3, [r7, #0x18]
 801950c: 9300         	str	r3, [sp]
 801950e: 683b         	ldr	r3, [r7]
 8019510: 687a         	ldr	r2, [r7, #0x4]
 8019512: 68b9         	ldr	r1, [r7, #0x8]
 8019514: 68f8         	ldr	r0, [r7, #0xc]
 8019516: f000 fae9    	bl	0x8019aec <z_impl_k_thread_create> @ imm = #0x5d2
 801951a: 4603         	mov	r3, r0
; }
 801951c: 4618         	mov	r0, r3
 801951e: 3710         	adds	r7, #0x10
 8019520: 46bd         	mov	sp, r7
 8019522: bd80         	pop	{r7, pc}

08019524 <k_yield>:
; {
 8019524: b580         	push	{r7, lr}
 8019526: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 8019528: f7f5 fb38    	bl	0x800eb9c <z_impl_k_yield> @ imm = #-0xa990
; }
 801952c: bf00         	nop
 801952e: bd80         	pop	{r7, pc}

08019530 <k_thread_resume>:
; {
 8019530: b580         	push	{r7, lr}
 8019532: b082         	sub	sp, #0x8
 8019534: af00         	add	r7, sp, #0x0
 8019536: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 8019538: 6878         	ldr	r0, [r7, #0x4]
 801953a: f7f4 fec1    	bl	0x800e2c0 <z_impl_k_thread_resume> @ imm = #-0xb27e
; }
 801953e: bf00         	nop
 8019540: 3708         	adds	r7, #0x8
 8019542: 46bd         	mov	sp, r7
 8019544: bd80         	pop	{r7, pc}

08019546 <k_thread_name_set>:
; {
 8019546: b580         	push	{r7, lr}
 8019548: b082         	sub	sp, #0x8
 801954a: af00         	add	r7, sp, #0x0
 801954c: 6078         	str	r0, [r7, #0x4]
 801954e: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 8019550: 6839         	ldr	r1, [r7]
 8019552: 6878         	ldr	r0, [r7, #0x4]
 8019554: f7f4 f902    	bl	0x800d75c <z_impl_k_thread_name_set> @ imm = #-0xbdfc
 8019558: 4603         	mov	r3, r0
; }
 801955a: 4618         	mov	r0, r3
 801955c: 3708         	adds	r7, #0x8
 801955e: 46bd         	mov	sp, r7
 8019560: bd80         	pop	{r7, pc}

08019562 <k_sem_give>:
; {
 8019562: b580         	push	{r7, lr}
 8019564: b082         	sub	sp, #0x8
 8019566: af00         	add	r7, sp, #0x0
 8019568: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801956a: 6878         	ldr	r0, [r7, #0x4]
 801956c: f7f3 fc2c    	bl	0x800cdc8 <z_impl_k_sem_give> @ imm = #-0xc7a8
; }
 8019570: bf00         	nop
 8019572: 3708         	adds	r7, #0x8
 8019574: 46bd         	mov	sp, r7
 8019576: bd80         	pop	{r7, pc}

08019578 <z_init_timeout>:
; {
 8019578: b580         	push	{r7, lr}
 801957a: b082         	sub	sp, #0x8
 801957c: af00         	add	r7, sp, #0x0
 801957e: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 8019580: 687b         	ldr	r3, [r7, #0x4]
 8019582: 4618         	mov	r0, r3
 8019584: f7ff fe50    	bl	0x8019228 <sys_dnode_init> @ imm = #-0x360
; }
 8019588: bf00         	nop
 801958a: 3708         	adds	r7, #0x8
 801958c: 46bd         	mov	sp, r7
 801958e: bd80         	pop	{r7, pc}

08019590 <z_waitq_init>:
; {
 8019590: b580         	push	{r7, lr}
 8019592: b082         	sub	sp, #0x8
 8019594: af00         	add	r7, sp, #0x0
 8019596: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8019598: 687b         	ldr	r3, [r7, #0x4]
 801959a: 4618         	mov	r0, r3
 801959c: f7ff fe35    	bl	0x801920a <sys_dlist_init> @ imm = #-0x396
; }
 80195a0: bf00         	nop
 80195a2: 3708         	adds	r7, #0x8
 80195a4: 46bd         	mov	sp, r7
 80195a6: bd80         	pop	{r7, pc}

080195a8 <z_reschedule_unlocked>:
; {
 80195a8: b580         	push	{r7, lr}
 80195aa: b084         	sub	sp, #0x10
 80195ac: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80195ae: f3ef 8311    	mrs	r3, basepri
 80195b2: 60fb         	str	r3, [r7, #0xc]
;   return(result);
 80195b4: 68fb         	ldr	r3, [r7, #0xc]
; 	key = __get_BASEPRI();
 80195b6: 60bb         	str	r3, [r7, #0x8]
 80195b8: 2310         	movs	r3, #0x10
 80195ba: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80195bc: 687b         	ldr	r3, [r7, #0x4]
 80195be: f383 8812    	msr	basepri_max, r3
; }
 80195c2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80195c4: f3bf 8f6f    	isb	sy
; }
 80195c8: bf00         	nop
; 	return key;
 80195ca: 68bb         	ldr	r3, [r7, #0x8]
; 	(void) z_reschedule_irqlock(arch_irq_lock());
 80195cc: 4618         	mov	r0, r3
 80195ce: f000 fe88    	bl	0x801a2e2 <z_reschedule_irqlock> @ imm = #0xd10
; }
 80195d2: bf00         	nop
 80195d4: 3710         	adds	r7, #0x10
 80195d6: 46bd         	mov	sp, r7
 80195d8: bd80         	pop	{r7, pc}

080195da <z_sched_wake_all>:
; {
 80195da: b580         	push	{r7, lr}
 80195dc: b086         	sub	sp, #0x18
 80195de: af00         	add	r7, sp, #0x0
 80195e0: 60f8         	str	r0, [r7, #0xc]
 80195e2: 60b9         	str	r1, [r7, #0x8]
 80195e4: 607a         	str	r2, [r7, #0x4]
; 	bool woken = false;
 80195e6: 2300         	movs	r3, #0x0
 80195e8: 75fb         	strb	r3, [r7, #0x17]
; 	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 80195ea: e001         	b	0x80195f0 <z_sched_wake_all+0x16> @ imm = #0x2
; 		woken = true;
 80195ec: 2301         	movs	r3, #0x1
 80195ee: 75fb         	strb	r3, [r7, #0x17]
; 	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 80195f0: 687a         	ldr	r2, [r7, #0x4]
 80195f2: 68b9         	ldr	r1, [r7, #0x8]
 80195f4: 68f8         	ldr	r0, [r7, #0xc]
 80195f6: f7f5 fe3b    	bl	0x800f270 <z_sched_wake> @ imm = #-0xa38a
 80195fa: 4603         	mov	r3, r0
 80195fc: 2b00         	cmp	r3, #0x0
 80195fe: d1f5         	bne	0x80195ec <z_sched_wake_all+0x12> @ imm = #-0x16
; 	return woken;
 8019600: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 8019602: 4618         	mov	r0, r3
 8019604: 3718         	adds	r7, #0x18
 8019606: 46bd         	mov	sp, r7
 8019608: bd80         	pop	{r7, pc}

0801960a <flag_clear>:
; {
 801960a: b480         	push	{r7}
 801960c: b083         	sub	sp, #0xc
 801960e: af00         	add	r7, sp, #0x0
 8019610: 6078         	str	r0, [r7, #0x4]
 8019612: 6039         	str	r1, [r7]
; 	*flagp &= ~BIT(bit);
 8019614: 687b         	ldr	r3, [r7, #0x4]
 8019616: 681a         	ldr	r2, [r3]
 8019618: 2101         	movs	r1, #0x1
 801961a: 683b         	ldr	r3, [r7]
 801961c: fa01 f303    	lsl.w	r3, r1, r3
 8019620: 43db         	mvns	r3, r3
 8019622: 401a         	ands	r2, r3
 8019624: 687b         	ldr	r3, [r7, #0x4]
 8019626: 601a         	str	r2, [r3]
; }
 8019628: bf00         	nop
 801962a: 370c         	adds	r7, #0xc
 801962c: 46bd         	mov	sp, r7
 801962e: bc80         	pop	{r7}
 8019630: 4770         	bx	lr

08019632 <flag_set>:
; {
 8019632: b480         	push	{r7}
 8019634: b083         	sub	sp, #0xc
 8019636: af00         	add	r7, sp, #0x0
 8019638: 6078         	str	r0, [r7, #0x4]
 801963a: 6039         	str	r1, [r7]
; 	*flagp |= BIT(bit);
 801963c: 687b         	ldr	r3, [r7, #0x4]
 801963e: 681a         	ldr	r2, [r3]
 8019640: 2101         	movs	r1, #0x1
 8019642: 683b         	ldr	r3, [r7]
 8019644: fa01 f303    	lsl.w	r3, r1, r3
 8019648: 431a         	orrs	r2, r3
 801964a: 687b         	ldr	r3, [r7, #0x4]
 801964c: 601a         	str	r2, [r3]
; }
 801964e: bf00         	nop
 8019650: 370c         	adds	r7, #0xc
 8019652: 46bd         	mov	sp, r7
 8019654: bc80         	pop	{r7}
 8019656: 4770         	bx	lr

08019658 <flag_test>:
; {
 8019658: b480         	push	{r7}
 801965a: b083         	sub	sp, #0xc
 801965c: af00         	add	r7, sp, #0x0
 801965e: 6078         	str	r0, [r7, #0x4]
 8019660: 6039         	str	r1, [r7]
; 	return (*flagp & BIT(bit)) != 0U;
 8019662: 687b         	ldr	r3, [r7, #0x4]
 8019664: 681a         	ldr	r2, [r3]
 8019666: 683b         	ldr	r3, [r7]
 8019668: fa22 f303    	lsr.w	r3, r2, r3
 801966c: f003 0301    	and	r3, r3, #0x1
 8019670: 2b00         	cmp	r3, #0x0
 8019672: bf14         	ite	ne
 8019674: 2301         	movne	r3, #0x1
 8019676: 2300         	moveq	r3, #0x0
 8019678: b2db         	uxtb	r3, r3
; }
 801967a: 4618         	mov	r0, r3
 801967c: 370c         	adds	r7, #0xc
 801967e: 46bd         	mov	sp, r7
 8019680: bc80         	pop	{r7}
 8019682: 4770         	bx	lr

08019684 <flag_test_and_clear>:
; {
 8019684: b580         	push	{r7, lr}
 8019686: b084         	sub	sp, #0x10
 8019688: af00         	add	r7, sp, #0x0
 801968a: 6078         	str	r0, [r7, #0x4]
 801968c: 6039         	str	r1, [r7]
; 	bool ret = flag_test(flagp, bit);
 801968e: 683b         	ldr	r3, [r7]
 8019690: 4619         	mov	r1, r3
 8019692: 6878         	ldr	r0, [r7, #0x4]
 8019694: f7ff ffe0    	bl	0x8019658 <flag_test>   @ imm = #-0x40
 8019698: 4603         	mov	r3, r0
 801969a: 73fb         	strb	r3, [r7, #0xf]
; 	flag_clear(flagp, bit);
 801969c: 683b         	ldr	r3, [r7]
 801969e: 4619         	mov	r1, r3
 80196a0: 6878         	ldr	r0, [r7, #0x4]
 80196a2: f7ff ffb2    	bl	0x801960a <flag_clear>  @ imm = #-0x9c
; 	return ret;
 80196a6: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 80196a8: 4618         	mov	r0, r3
 80196aa: 3710         	adds	r7, #0x10
 80196ac: 46bd         	mov	sp, r7
 80196ae: bd80         	pop	{r7, pc}

080196b0 <flags_set>:
; {
 80196b0: b480         	push	{r7}
 80196b2: b083         	sub	sp, #0xc
 80196b4: af00         	add	r7, sp, #0x0
 80196b6: 6078         	str	r0, [r7, #0x4]
 80196b8: 6039         	str	r1, [r7]
; 	*flagp = flags;
 80196ba: 687b         	ldr	r3, [r7, #0x4]
 80196bc: 683a         	ldr	r2, [r7]
 80196be: 601a         	str	r2, [r3]
; }
 80196c0: bf00         	nop
 80196c2: 370c         	adds	r7, #0xc
 80196c4: 46bd         	mov	sp, r7
 80196c6: bc80         	pop	{r7}
 80196c8: 4770         	bx	lr

080196ca <flags_get>:
; {
 80196ca: b480         	push	{r7}
 80196cc: b083         	sub	sp, #0xc
 80196ce: af00         	add	r7, sp, #0x0
 80196d0: 6078         	str	r0, [r7, #0x4]
; 	return *flagp;
 80196d2: 687b         	ldr	r3, [r7, #0x4]
 80196d4: 681b         	ldr	r3, [r3]
; }
 80196d6: 4618         	mov	r0, r3
 80196d8: 370c         	adds	r7, #0xc
 80196da: 46bd         	mov	sp, r7
 80196dc: bc80         	pop	{r7}
 80196de: 4770         	bx	lr

080196e0 <finalize_flush_locked>:
; {
 80196e0: b580         	push	{r7, lr}
 80196e2: b084         	sub	sp, #0x10
 80196e4: af00         	add	r7, sp, #0x0
 80196e6: 6078         	str	r0, [r7, #0x4]
; 	struct z_work_flusher *flusher = CONTAINER_OF(work, struct z_work_flusher, work);
 80196e8: 687b         	ldr	r3, [r7, #0x4]
 80196ea: 60fb         	str	r3, [r7, #0xc]
; 	flag_clear(&work->flags, K_WORK_FLUSHING_BIT);
 80196ec: 687b         	ldr	r3, [r7, #0x4]
 80196ee: 330c         	adds	r3, #0xc
 80196f0: 2104         	movs	r1, #0x4
 80196f2: 4618         	mov	r0, r3
 80196f4: f7ff ff89    	bl	0x801960a <flag_clear>  @ imm = #-0xee
; 	k_sem_give(&flusher->sem);
 80196f8: 68fb         	ldr	r3, [r7, #0xc]
 80196fa: 3310         	adds	r3, #0x10
 80196fc: 4618         	mov	r0, r3
 80196fe: f7ff ff30    	bl	0x8019562 <k_sem_give>  @ imm = #-0x1a0
; };
 8019702: bf00         	nop
 8019704: 3710         	adds	r7, #0x10
 8019706: 46bd         	mov	sp, r7
 8019708: bd80         	pop	{r7, pc}

0801970a <work_busy_get_locked>:
; {
 801970a: b580         	push	{r7, lr}
 801970c: b082         	sub	sp, #0x8
 801970e: af00         	add	r7, sp, #0x0
 8019710: 6078         	str	r0, [r7, #0x4]
; 	return flags_get(&work->flags) & K_WORK_MASK;
 8019712: 687b         	ldr	r3, [r7, #0x4]
 8019714: 330c         	adds	r3, #0xc
 8019716: 4618         	mov	r0, r3
 8019718: f7ff ffd7    	bl	0x80196ca <flags_get>   @ imm = #-0x52
 801971c: 4603         	mov	r3, r0
 801971e: f003 031f    	and	r3, r3, #0x1f
; }
 8019722: 4618         	mov	r0, r3
 8019724: 3708         	adds	r7, #0x8
 8019726: 46bd         	mov	sp, r7
 8019728: bd80         	pop	{r7, pc}

0801972a <queue_remove_locked>:
; {
 801972a: b580         	push	{r7, lr}
 801972c: b082         	sub	sp, #0x8
 801972e: af00         	add	r7, sp, #0x0
 8019730: 6078         	str	r0, [r7, #0x4]
 8019732: 6039         	str	r1, [r7]
; 	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
 8019734: 683b         	ldr	r3, [r7]
 8019736: 330c         	adds	r3, #0xc
 8019738: 2102         	movs	r1, #0x2
 801973a: 4618         	mov	r0, r3
 801973c: f7ff ffa2    	bl	0x8019684 <flag_test_and_clear> @ imm = #-0xbc
 8019740: 4603         	mov	r3, r0
 8019742: 2b00         	cmp	r3, #0x0
 8019744: d006         	beq	0x8019754 <queue_remove_locked+0x2a> @ imm = #0xc
; 		(void)sys_slist_find_and_remove(&queue->pending, &work->node);
 8019746: 687b         	ldr	r3, [r7, #0x4]
 8019748: 33d0         	adds	r3, #0xd0
 801974a: 683a         	ldr	r2, [r7]
 801974c: 4611         	mov	r1, r2
 801974e: 4618         	mov	r0, r3
 8019750: f7ff fe98    	bl	0x8019484 <sys_slist_find_and_remove> @ imm = #-0x2d0
; }
 8019754: bf00         	nop
 8019756: 3708         	adds	r7, #0x8
 8019758: 46bd         	mov	sp, r7
 801975a: bd80         	pop	{r7, pc}

0801975c <notify_queue_locked>:
; {
 801975c: b580         	push	{r7, lr}
 801975e: b084         	sub	sp, #0x10
 8019760: af00         	add	r7, sp, #0x0
 8019762: 6078         	str	r0, [r7, #0x4]
; 	bool rv = false;
 8019764: 2300         	movs	r3, #0x0
 8019766: 73fb         	strb	r3, [r7, #0xf]
; 	if (queue != NULL) {
 8019768: 687b         	ldr	r3, [r7, #0x4]
 801976a: 2b00         	cmp	r3, #0x0
 801976c: d008         	beq	0x8019780 <notify_queue_locked+0x24> @ imm = #0x10
; 		rv = z_sched_wake(&queue->notifyq, 0, NULL);
 801976e: 687b         	ldr	r3, [r7, #0x4]
 8019770: 33d8         	adds	r3, #0xd8
 8019772: 2200         	movs	r2, #0x0
 8019774: 2100         	movs	r1, #0x0
 8019776: 4618         	mov	r0, r3
 8019778: f7f5 fd7a    	bl	0x800f270 <z_sched_wake> @ imm = #-0xa50c
 801977c: 4603         	mov	r3, r0
 801977e: 73fb         	strb	r3, [r7, #0xf]
; 	return rv;
 8019780: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8019782: 4618         	mov	r0, r3
 8019784: 3710         	adds	r7, #0x10
 8019786: 46bd         	mov	sp, r7
 8019788: bd80         	pop	{r7, pc}

0801978a <submit_to_queue_locked>:
; {
 801978a: b580         	push	{r7, lr}
 801978c: b084         	sub	sp, #0x10
 801978e: af00         	add	r7, sp, #0x0
 8019790: 6078         	str	r0, [r7, #0x4]
 8019792: 6039         	str	r1, [r7]
; 	int ret = 0;
 8019794: 2300         	movs	r3, #0x0
 8019796: 60fb         	str	r3, [r7, #0xc]
; 	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 8019798: 687b         	ldr	r3, [r7, #0x4]
 801979a: 330c         	adds	r3, #0xc
 801979c: 2101         	movs	r1, #0x1
 801979e: 4618         	mov	r0, r3
 80197a0: f7ff ff5a    	bl	0x8019658 <flag_test>   @ imm = #-0x14c
 80197a4: 4603         	mov	r3, r0
 80197a6: 2b00         	cmp	r3, #0x0
 80197a8: d003         	beq	0x80197b2 <submit_to_queue_locked+0x28> @ imm = #0x6
; 		ret = -EBUSY;
 80197aa: f06f 030f    	mvn	r3, #0xf
 80197ae: 60fb         	str	r3, [r7, #0xc]
 80197b0: e03b         	b	0x801982a <submit_to_queue_locked+0xa0> @ imm = #0x76
; 	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
 80197b2: 687b         	ldr	r3, [r7, #0x4]
 80197b4: 330c         	adds	r3, #0xc
 80197b6: 2102         	movs	r1, #0x2
 80197b8: 4618         	mov	r0, r3
 80197ba: f7ff ff4d    	bl	0x8019658 <flag_test>   @ imm = #-0x166
 80197be: 4603         	mov	r3, r0
 80197c0: f083 0301    	eor	r3, r3, #0x1
 80197c4: b2db         	uxtb	r3, r3
 80197c6: 2b00         	cmp	r3, #0x0
 80197c8: d02f         	beq	0x801982a <submit_to_queue_locked+0xa0> @ imm = #0x5e
; 		ret = 1;
 80197ca: 2301         	movs	r3, #0x1
 80197cc: 60fb         	str	r3, [r7, #0xc]
; 		if (*queuep == NULL) {
 80197ce: 683b         	ldr	r3, [r7]
 80197d0: 681b         	ldr	r3, [r3]
 80197d2: 2b00         	cmp	r3, #0x0
 80197d4: d103         	bne	0x80197de <submit_to_queue_locked+0x54> @ imm = #0x6
; 			*queuep = work->queue;
 80197d6: 687b         	ldr	r3, [r7, #0x4]
 80197d8: 689a         	ldr	r2, [r3, #0x8]
 80197da: 683b         	ldr	r3, [r7]
 80197dc: 601a         	str	r2, [r3]
; 		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
 80197de: 687b         	ldr	r3, [r7, #0x4]
 80197e0: 330c         	adds	r3, #0xc
 80197e2: 2100         	movs	r1, #0x0
 80197e4: 4618         	mov	r0, r3
 80197e6: f7ff ff37    	bl	0x8019658 <flag_test>   @ imm = #-0x192
 80197ea: 4603         	mov	r3, r0
 80197ec: 2b00         	cmp	r3, #0x0
 80197ee: d005         	beq	0x80197fc <submit_to_queue_locked+0x72> @ imm = #0xa
; 			*queuep = work->queue;
 80197f0: 687b         	ldr	r3, [r7, #0x4]
 80197f2: 689a         	ldr	r2, [r3, #0x8]
 80197f4: 683b         	ldr	r3, [r7]
 80197f6: 601a         	str	r2, [r3]
; 			ret = 2;
 80197f8: 2302         	movs	r3, #0x2
 80197fa: 60fb         	str	r3, [r7, #0xc]
; 		int rc = queue_submit_locked(*queuep, work);
 80197fc: 683b         	ldr	r3, [r7]
 80197fe: 681b         	ldr	r3, [r3]
 8019800: 6879         	ldr	r1, [r7, #0x4]
 8019802: 4618         	mov	r0, r3
 8019804: f7f3 fc7e    	bl	0x800d104 <queue_submit_locked> @ imm = #-0xc704
 8019808: 60b8         	str	r0, [r7, #0x8]
; 		if (rc < 0) {
 801980a: 68bb         	ldr	r3, [r7, #0x8]
 801980c: 2b00         	cmp	r3, #0x0
 801980e: da02         	bge	0x8019816 <submit_to_queue_locked+0x8c> @ imm = #0x4
; 			ret = rc;
 8019810: 68bb         	ldr	r3, [r7, #0x8]
 8019812: 60fb         	str	r3, [r7, #0xc]
 8019814: e009         	b	0x801982a <submit_to_queue_locked+0xa0> @ imm = #0x12
; 			flag_set(&work->flags, K_WORK_QUEUED_BIT);
 8019816: 687b         	ldr	r3, [r7, #0x4]
 8019818: 330c         	adds	r3, #0xc
 801981a: 2102         	movs	r1, #0x2
 801981c: 4618         	mov	r0, r3
 801981e: f7ff ff08    	bl	0x8019632 <flag_set>    @ imm = #-0x1f0
; 			work->queue = *queuep;
 8019822: 683b         	ldr	r3, [r7]
 8019824: 681a         	ldr	r2, [r3]
 8019826: 687b         	ldr	r3, [r7, #0x4]
 8019828: 609a         	str	r2, [r3, #0x8]
; 	if (ret <= 0) {
 801982a: 68fb         	ldr	r3, [r7, #0xc]
 801982c: 2b00         	cmp	r3, #0x0
 801982e: dc02         	bgt	0x8019836 <submit_to_queue_locked+0xac> @ imm = #0x4
; 		*queuep = NULL;
 8019830: 683b         	ldr	r3, [r7]
 8019832: 2200         	movs	r2, #0x0
 8019834: 601a         	str	r2, [r3]
; 	return ret;
 8019836: 68fb         	ldr	r3, [r7, #0xc]
; }
 8019838: 4618         	mov	r0, r3
 801983a: 3710         	adds	r7, #0x10
 801983c: 46bd         	mov	sp, r7
 801983e: bd80         	pop	{r7, pc}

08019840 <k_work_submit_to_queue>:
; {
 8019840: b580         	push	{r7, lr}
 8019842: b084         	sub	sp, #0x10
 8019844: af00         	add	r7, sp, #0x0
 8019846: 6078         	str	r0, [r7, #0x4]
 8019848: 6039         	str	r1, [r7]
; 	int ret = z_work_submit_to_queue(queue, work);
 801984a: 6839         	ldr	r1, [r7]
 801984c: 6878         	ldr	r0, [r7, #0x4]
 801984e: f7f3 fcc9    	bl	0x800d1e4 <z_work_submit_to_queue> @ imm = #-0xc66e
 8019852: 60f8         	str	r0, [r7, #0xc]
; 	if (ret > 0) {
 8019854: 68fb         	ldr	r3, [r7, #0xc]
 8019856: 2b00         	cmp	r3, #0x0
 8019858: dd01         	ble	0x801985e <k_work_submit_to_queue+0x1e> @ imm = #0x2
; 		z_reschedule_unlocked();
 801985a: f7ff fea5    	bl	0x80195a8 <z_reschedule_unlocked> @ imm = #-0x2b6
; 	return ret;
 801985e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8019860: 4618         	mov	r0, r3
 8019862: 3710         	adds	r7, #0x10
 8019864: 46bd         	mov	sp, r7
 8019866: bd80         	pop	{r7, pc}

08019868 <cancel_async_locked>:
; {
 8019868: b580         	push	{r7, lr}
 801986a: b084         	sub	sp, #0x10
 801986c: af00         	add	r7, sp, #0x0
 801986e: 6078         	str	r0, [r7, #0x4]
; 	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 8019870: 687b         	ldr	r3, [r7, #0x4]
 8019872: 330c         	adds	r3, #0xc
 8019874: 2101         	movs	r1, #0x1
 8019876: 4618         	mov	r0, r3
 8019878: f7ff feee    	bl	0x8019658 <flag_test>   @ imm = #-0x224
 801987c: 4603         	mov	r3, r0
 801987e: f083 0301    	eor	r3, r3, #0x1
 8019882: b2db         	uxtb	r3, r3
 8019884: 2b00         	cmp	r3, #0x0
 8019886: d005         	beq	0x8019894 <cancel_async_locked+0x2c> @ imm = #0xa
; 		queue_remove_locked(work->queue, work);
 8019888: 687b         	ldr	r3, [r7, #0x4]
 801988a: 689b         	ldr	r3, [r3, #0x8]
 801988c: 6879         	ldr	r1, [r7, #0x4]
 801988e: 4618         	mov	r0, r3
 8019890: f7ff ff4b    	bl	0x801972a <queue_remove_locked> @ imm = #-0x16a
; 	int ret = work_busy_get_locked(work);
 8019894: 6878         	ldr	r0, [r7, #0x4]
 8019896: f7ff ff38    	bl	0x801970a <work_busy_get_locked> @ imm = #-0x190
 801989a: 60f8         	str	r0, [r7, #0xc]
; 	if (ret != 0) {
 801989c: 68fb         	ldr	r3, [r7, #0xc]
 801989e: 2b00         	cmp	r3, #0x0
 80198a0: d009         	beq	0x80198b6 <cancel_async_locked+0x4e> @ imm = #0x12
; 		flag_set(&work->flags, K_WORK_CANCELING_BIT);
 80198a2: 687b         	ldr	r3, [r7, #0x4]
 80198a4: 330c         	adds	r3, #0xc
 80198a6: 2101         	movs	r1, #0x1
 80198a8: 4618         	mov	r0, r3
 80198aa: f7ff fec2    	bl	0x8019632 <flag_set>    @ imm = #-0x27c
; 		ret = work_busy_get_locked(work);
 80198ae: 6878         	ldr	r0, [r7, #0x4]
 80198b0: f7ff ff2b    	bl	0x801970a <work_busy_get_locked> @ imm = #-0x1aa
 80198b4: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 80198b6: 68fb         	ldr	r3, [r7, #0xc]
; }
 80198b8: 4618         	mov	r0, r3
 80198ba: 3710         	adds	r7, #0x10
 80198bc: 46bd         	mov	sp, r7
 80198be: bd80         	pop	{r7, pc}

080198c0 <k_work_queue_init>:
; {
 80198c0: b580         	push	{r7, lr}
 80198c2: b0be         	sub	sp, #0xf8
 80198c4: af00         	add	r7, sp, #0x0
 80198c6: 6078         	str	r0, [r7, #0x4]
; 	*queue = (struct k_work_q){
 80198c8: 687b         	ldr	r3, [r7, #0x4]
 80198ca: 4618         	mov	r0, r3
 80198cc: 23f0         	movs	r3, #0xf0
 80198ce: 461a         	mov	r2, r3
 80198d0: 2100         	movs	r1, #0x0
 80198d2: f000 ffad    	bl	0x801a830 <memset>      @ imm = #0xf5a
; }
 80198d6: bf00         	nop
 80198d8: 37f8         	adds	r7, #0xf8
 80198da: 46bd         	mov	sp, r7
 80198dc: bd80         	pop	{r7, pc}

080198de <k_work_init_delayable>:
; {
 80198de: b580         	push	{r7, lr}
 80198e0: b08e         	sub	sp, #0x38
 80198e2: af00         	add	r7, sp, #0x0
 80198e4: 6078         	str	r0, [r7, #0x4]
 80198e6: 6039         	str	r1, [r7]
; 	*dwork = (struct k_work_delayable){
 80198e8: 687b         	ldr	r3, [r7, #0x4]
 80198ea: 4618         	mov	r0, r3
 80198ec: 2330         	movs	r3, #0x30
 80198ee: 461a         	mov	r2, r3
 80198f0: 2100         	movs	r1, #0x0
 80198f2: f000 ff9d    	bl	0x801a830 <memset>      @ imm = #0xf3a
 80198f6: 687b         	ldr	r3, [r7, #0x4]
 80198f8: 683a         	ldr	r2, [r7]
 80198fa: 605a         	str	r2, [r3, #0x4]
 80198fc: 687b         	ldr	r3, [r7, #0x4]
 80198fe: f44f 7280    	mov.w	r2, #0x100
 8019902: 60da         	str	r2, [r3, #0xc]
; 	z_init_timeout(&dwork->timeout);
 8019904: 687b         	ldr	r3, [r7, #0x4]
 8019906: 3310         	adds	r3, #0x10
 8019908: 4618         	mov	r0, r3
 801990a: f7ff fe35    	bl	0x8019578 <z_init_timeout> @ imm = #-0x396
; }
 801990e: bf00         	nop
 8019910: 3738         	adds	r7, #0x38
 8019912: 46bd         	mov	sp, r7
 8019914: bd80         	pop	{r7, pc}

08019916 <unschedule_locked>:
; {
 8019916: b580         	push	{r7, lr}
 8019918: b084         	sub	sp, #0x10
 801991a: af00         	add	r7, sp, #0x0
 801991c: 6078         	str	r0, [r7, #0x4]
; 	bool ret = false;
 801991e: 2300         	movs	r3, #0x0
 8019920: 73fb         	strb	r3, [r7, #0xf]
; 	struct k_work *work = &dwork->work;
 8019922: 687b         	ldr	r3, [r7, #0x4]
 8019924: 60bb         	str	r3, [r7, #0x8]
; 	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
 8019926: 68bb         	ldr	r3, [r7, #0x8]
 8019928: 330c         	adds	r3, #0xc
 801992a: 2103         	movs	r1, #0x3
 801992c: 4618         	mov	r0, r3
 801992e: f7ff fea9    	bl	0x8019684 <flag_test_and_clear> @ imm = #-0x2ae
 8019932: 4603         	mov	r3, r0
 8019934: 2b00         	cmp	r3, #0x0
 8019936: d00a         	beq	0x801994e <unschedule_locked+0x38> @ imm = #0x14
; 		ret = z_abort_timeout(&dwork->timeout) == 0;
 8019938: 687b         	ldr	r3, [r7, #0x4]
 801993a: 3310         	adds	r3, #0x10
 801993c: 4618         	mov	r0, r3
 801993e: f7f6 f80b    	bl	0x800f958 <z_abort_timeout> @ imm = #-0x9fea
 8019942: 4603         	mov	r3, r0
 8019944: 2b00         	cmp	r3, #0x0
 8019946: bf0c         	ite	eq
 8019948: 2301         	moveq	r3, #0x1
 801994a: 2300         	movne	r3, #0x0
 801994c: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 801994e: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8019950: 4618         	mov	r0, r3
 8019952: 3710         	adds	r7, #0x10
 8019954: 46bd         	mov	sp, r7
 8019956: bd80         	pop	{r7, pc}

08019958 <cancel_delayable_async_locked>:
; {
 8019958: b580         	push	{r7, lr}
 801995a: b082         	sub	sp, #0x8
 801995c: af00         	add	r7, sp, #0x0
 801995e: 6078         	str	r0, [r7, #0x4]
; 	(void)unschedule_locked(dwork);
 8019960: 6878         	ldr	r0, [r7, #0x4]
 8019962: f7ff ffd8    	bl	0x8019916 <unschedule_locked> @ imm = #-0x50
; 	return cancel_async_locked(&dwork->work);
 8019966: 687b         	ldr	r3, [r7, #0x4]
 8019968: 4618         	mov	r0, r3
 801996a: f7ff ff7d    	bl	0x8019868 <cancel_async_locked> @ imm = #-0x106
 801996e: 4603         	mov	r3, r0
; }
 8019970: 4618         	mov	r0, r3
 8019972: 3708         	adds	r7, #0x8
 8019974: 46bd         	mov	sp, r7
 8019976: bd80         	pop	{r7, pc}

08019978 <sys_dlist_init>:
; {
 8019978: b480         	push	{r7}
 801997a: b083         	sub	sp, #0xc
 801997c: af00         	add	r7, sp, #0x0
 801997e: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8019980: 687b         	ldr	r3, [r7, #0x4]
 8019982: 687a         	ldr	r2, [r7, #0x4]
 8019984: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8019986: 687b         	ldr	r3, [r7, #0x4]
 8019988: 687a         	ldr	r2, [r7, #0x4]
 801998a: 605a         	str	r2, [r3, #0x4]
; }
 801998c: bf00         	nop
 801998e: 370c         	adds	r7, #0xc
 8019990: 46bd         	mov	sp, r7
 8019992: bc80         	pop	{r7}
 8019994: 4770         	bx	lr

08019996 <sys_dnode_init>:
; {
 8019996: b480         	push	{r7}
 8019998: b083         	sub	sp, #0xc
 801999a: af00         	add	r7, sp, #0x0
 801999c: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801999e: 687b         	ldr	r3, [r7, #0x4]
 80199a0: 2200         	movs	r2, #0x0
 80199a2: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 80199a4: 687b         	ldr	r3, [r7, #0x4]
 80199a6: 2200         	movs	r2, #0x0
 80199a8: 605a         	str	r2, [r3, #0x4]
; }
 80199aa: bf00         	nop
 80199ac: 370c         	adds	r7, #0xc
 80199ae: 46bd         	mov	sp, r7
 80199b0: bc80         	pop	{r7}
 80199b2: 4770         	bx	lr

080199b4 <K_KERNEL_STACK_BUFFER>:
; {
 80199b4: b480         	push	{r7}
 80199b6: b083         	sub	sp, #0xc
 80199b8: af00         	add	r7, sp, #0x0
 80199ba: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 80199bc: 687b         	ldr	r3, [r7, #0x4]
; }
 80199be: 4618         	mov	r0, r3
 80199c0: 370c         	adds	r7, #0xc
 80199c2: 46bd         	mov	sp, r7
 80199c4: bc80         	pop	{r7}
 80199c6: 4770         	bx	lr

080199c8 <k_thread_start>:
; {
 80199c8: b580         	push	{r7, lr}
 80199ca: b082         	sub	sp, #0x8
 80199cc: af00         	add	r7, sp, #0x0
 80199ce: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 80199d0: 6878         	ldr	r0, [r7, #0x4]
 80199d2: f000 f804    	bl	0x80199de <k_thread_resume> @ imm = #0x8
; }
 80199d6: bf00         	nop
 80199d8: 3708         	adds	r7, #0x8
 80199da: 46bd         	mov	sp, r7
 80199dc: bd80         	pop	{r7, pc}

080199de <k_thread_resume>:
; {
 80199de: b580         	push	{r7, lr}
 80199e0: b082         	sub	sp, #0x8
 80199e2: af00         	add	r7, sp, #0x0
 80199e4: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 80199e6: 6878         	ldr	r0, [r7, #0x4]
 80199e8: f7f4 fc6a    	bl	0x800e2c0 <z_impl_k_thread_resume> @ imm = #-0xb72c
; }
 80199ec: bf00         	nop
 80199ee: 3708         	adds	r7, #0x8
 80199f0: 46bd         	mov	sp, r7
 80199f2: bd80         	pop	{r7, pc}

080199f4 <z_init_timeout>:
; {
 80199f4: b580         	push	{r7, lr}
 80199f6: b082         	sub	sp, #0x8
 80199f8: af00         	add	r7, sp, #0x0
 80199fa: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 80199fc: 687b         	ldr	r3, [r7, #0x4]
 80199fe: 4618         	mov	r0, r3
 8019a00: f7ff ffc9    	bl	0x8019996 <sys_dnode_init> @ imm = #-0x6e
; }
 8019a04: bf00         	nop
 8019a06: 3708         	adds	r7, #0x8
 8019a08: 46bd         	mov	sp, r7
 8019a0a: bd80         	pop	{r7, pc}

08019a0c <z_init_thread_timeout>:
; {
 8019a0c: b580         	push	{r7, lr}
 8019a0e: b082         	sub	sp, #0x8
 8019a10: af00         	add	r7, sp, #0x0
 8019a12: 6078         	str	r0, [r7, #0x4]
; 	z_init_timeout(&thread_base->timeout);
 8019a14: 687b         	ldr	r3, [r7, #0x4]
 8019a16: 3318         	adds	r3, #0x18
 8019a18: 4618         	mov	r0, r3
 8019a1a: f7ff ffeb    	bl	0x80199f4 <z_init_timeout> @ imm = #-0x2a
; }
 8019a1e: bf00         	nop
 8019a20: 3708         	adds	r7, #0x8
 8019a22: 46bd         	mov	sp, r7
 8019a24: bd80         	pop	{r7, pc}

08019a26 <thread_schedule_new>:
; {
 8019a26: b580         	push	{r7, lr}
 8019a28: b084         	sub	sp, #0x10
 8019a2a: af00         	add	r7, sp, #0x0
 8019a2c: 60f8         	str	r0, [r7, #0xc]
 8019a2e: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 8019a32: e9d7 2300    	ldrd	r2, r3, [r7]
 8019a36: f04f 0000    	mov.w	r0, #0x0
 8019a3a: f04f 0100    	mov.w	r1, #0x0
 8019a3e: 428b         	cmp	r3, r1
 8019a40: bf08         	it	eq
 8019a42: 4282         	cmpeq	r2, r0
 8019a44: d103         	bne	0x8019a4e <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 8019a46: 68f8         	ldr	r0, [r7, #0xc]
 8019a48: f7ff ffbe    	bl	0x80199c8 <k_thread_start> @ imm = #-0x84
 8019a4c: e004         	b	0x8019a58 <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 8019a4e: e9d7 2300    	ldrd	r2, r3, [r7]
 8019a52: 68f8         	ldr	r0, [r7, #0xc]
 8019a54: f7f3 fe6e    	bl	0x800d734 <z_add_thread_timeout> @ imm = #-0xc324
; }
 8019a58: bf00         	nop
 8019a5a: 3710         	adds	r7, #0x10
 8019a5c: 46bd         	mov	sp, r7
 8019a5e: bd80         	pop	{r7, pc}

08019a60 <z_waitq_init>:
; {
 8019a60: b580         	push	{r7, lr}
 8019a62: b082         	sub	sp, #0x8
 8019a64: af00         	add	r7, sp, #0x0
 8019a66: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8019a68: 687b         	ldr	r3, [r7, #0x4]
 8019a6a: 4618         	mov	r0, r3
 8019a6c: f7ff ff84    	bl	0x8019978 <sys_dlist_init> @ imm = #-0xf8
; }
 8019a70: bf00         	nop
 8019a72: 3708         	adds	r7, #0x8
 8019a74: 46bd         	mov	sp, r7
 8019a76: bd80         	pop	{r7, pc}

08019a78 <z_log_msg_runtime_create>:
; {
 8019a78: b580         	push	{r7, lr}
 8019a7a: b08a         	sub	sp, #0x28
 8019a7c: af04         	add	r7, sp, #0x10
 8019a7e: 60b9         	str	r1, [r7, #0x8]
 8019a80: 607b         	str	r3, [r7, #0x4]
 8019a82: 4603         	mov	r3, r0
 8019a84: 73fb         	strb	r3, [r7, #0xf]
 8019a86: 4613         	mov	r3, r2
 8019a88: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8019a8a: f107 032c    	add.w	r3, r7, #0x2c
 8019a8e: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8019a90: 7bba         	ldrb	r2, [r7, #0xe]
 8019a92: 7bf8         	ldrb	r0, [r7, #0xf]
 8019a94: 697b         	ldr	r3, [r7, #0x14]
 8019a96: 9303         	str	r3, [sp, #0xc]
 8019a98: 6abb         	ldr	r3, [r7, #0x28]
 8019a9a: 9302         	str	r3, [sp, #0x8]
 8019a9c: 6a7b         	ldr	r3, [r7, #0x24]
 8019a9e: 9301         	str	r3, [sp, #0x4]
 8019aa0: 6a3b         	ldr	r3, [r7, #0x20]
 8019aa2: 9300         	str	r3, [sp]
 8019aa4: 687b         	ldr	r3, [r7, #0x4]
 8019aa6: 68b9         	ldr	r1, [r7, #0x8]
 8019aa8: f7e8 f8e0    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x17e40
; }
 8019aac: bf00         	nop
 8019aae: 3718         	adds	r7, #0x18
 8019ab0: 46bd         	mov	sp, r7
 8019ab2: bd80         	pop	{r7, pc}

08019ab4 <k_is_in_isr>:
; {
 8019ab4: b480         	push	{r7}
 8019ab6: b083         	sub	sp, #0xc
 8019ab8: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8019aba: f3ef 8305    	mrs	r3, ipsr
 8019abe: 607b         	str	r3, [r7, #0x4]
;   return(result);
 8019ac0: 687b         	ldr	r3, [r7, #0x4]
; 	return (__get_IPSR()) ? (true) : (false);
 8019ac2: 2b00         	cmp	r3, #0x0
 8019ac4: bf14         	ite	ne
 8019ac6: 2301         	movne	r3, #0x1
 8019ac8: 2300         	moveq	r3, #0x0
 8019aca: b2db         	uxtb	r3, r3
; }
 8019acc: 4618         	mov	r0, r3
 8019ace: 370c         	adds	r7, #0xc
 8019ad0: 46bd         	mov	sp, r7
 8019ad2: bc80         	pop	{r7}
 8019ad4: 4770         	bx	lr

08019ad6 <k_thread_name_get>:
; {
 8019ad6: b480         	push	{r7}
 8019ad8: b083         	sub	sp, #0xc
 8019ada: af00         	add	r7, sp, #0x0
 8019adc: 6078         	str	r0, [r7, #0x4]
; 	return (const char *)thread->name;
 8019ade: 687b         	ldr	r3, [r7, #0x4]
 8019ae0: 3394         	adds	r3, #0x94
; }
 8019ae2: 4618         	mov	r0, r3
 8019ae4: 370c         	adds	r7, #0xc
 8019ae6: 46bd         	mov	sp, r7
 8019ae8: bc80         	pop	{r7}
 8019aea: 4770         	bx	lr

08019aec <z_impl_k_thread_create>:
; {
 8019aec: b580         	push	{r7, lr}
 8019aee: b08a         	sub	sp, #0x28
 8019af0: af06         	add	r7, sp, #0x18
 8019af2: 60f8         	str	r0, [r7, #0xc]
 8019af4: 60b9         	str	r1, [r7, #0x8]
 8019af6: 607a         	str	r2, [r7, #0x4]
 8019af8: 603b         	str	r3, [r7]
; 	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 8019afa: 2300         	movs	r3, #0x0
 8019afc: 9305         	str	r3, [sp, #0x14]
 8019afe: 6abb         	ldr	r3, [r7, #0x28]
 8019b00: 9304         	str	r3, [sp, #0x10]
 8019b02: 6a7b         	ldr	r3, [r7, #0x24]
 8019b04: 9303         	str	r3, [sp, #0xc]
 8019b06: 6a3b         	ldr	r3, [r7, #0x20]
 8019b08: 9302         	str	r3, [sp, #0x8]
 8019b0a: 69fb         	ldr	r3, [r7, #0x1c]
 8019b0c: 9301         	str	r3, [sp, #0x4]
 8019b0e: 69bb         	ldr	r3, [r7, #0x18]
 8019b10: 9300         	str	r3, [sp]
 8019b12: 683b         	ldr	r3, [r7]
 8019b14: 687a         	ldr	r2, [r7, #0x4]
 8019b16: 68b9         	ldr	r1, [r7, #0x8]
 8019b18: 68f8         	ldr	r0, [r7, #0xc]
 8019b1a: f7f3 feaf    	bl	0x800d87c <z_setup_new_thread> @ imm = #-0xc2a2
; 	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
 8019b1e: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8019b22: f04f 30ff    	mov.w	r0, #0xffffffff
 8019b26: f04f 31ff    	mov.w	r1, #0xffffffff
 8019b2a: 428b         	cmp	r3, r1
 8019b2c: bf08         	it	eq
 8019b2e: 4282         	cmpeq	r2, r0
 8019b30: d004         	beq	0x8019b3c <z_impl_k_thread_create+0x50> @ imm = #0x8
; 		thread_schedule_new(new_thread, delay);
 8019b32: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8019b36: 68f8         	ldr	r0, [r7, #0xc]
 8019b38: f7ff ff75    	bl	0x8019a26 <thread_schedule_new> @ imm = #-0x116
; 	return new_thread;
 8019b3c: 68fb         	ldr	r3, [r7, #0xc]
; }
 8019b3e: 4618         	mov	r0, r3
 8019b40: 3710         	adds	r7, #0x10
 8019b42: 46bd         	mov	sp, r7
 8019b44: bd80         	pop	{r7, pc}

08019b46 <z_init_thread_base>:
; {
 8019b46: b580         	push	{r7, lr}
 8019b48: b084         	sub	sp, #0x10
 8019b4a: af00         	add	r7, sp, #0x0
 8019b4c: 60f8         	str	r0, [r7, #0xc]
 8019b4e: 60b9         	str	r1, [r7, #0x8]
 8019b50: 607a         	str	r2, [r7, #0x4]
 8019b52: 603b         	str	r3, [r7]
; 	thread_base->pended_on = NULL;
 8019b54: 68fb         	ldr	r3, [r7, #0xc]
 8019b56: 2200         	movs	r2, #0x0
 8019b58: 609a         	str	r2, [r3, #0x8]
; 	thread_base->user_options = (uint8_t)options;
 8019b5a: 683b         	ldr	r3, [r7]
 8019b5c: b2da         	uxtb	r2, r3
 8019b5e: 68fb         	ldr	r3, [r7, #0xc]
 8019b60: 731a         	strb	r2, [r3, #0xc]
; 	thread_base->thread_state = (uint8_t)initial_state;
 8019b62: 687b         	ldr	r3, [r7, #0x4]
 8019b64: b2da         	uxtb	r2, r3
 8019b66: 68fb         	ldr	r3, [r7, #0xc]
 8019b68: 735a         	strb	r2, [r3, #0xd]
; 	thread_base->prio = priority;
 8019b6a: 68bb         	ldr	r3, [r7, #0x8]
 8019b6c: b25a         	sxtb	r2, r3
 8019b6e: 68fb         	ldr	r3, [r7, #0xc]
 8019b70: 739a         	strb	r2, [r3, #0xe]
; 	thread_base->sched_locked = 0U;
 8019b72: 68fb         	ldr	r3, [r7, #0xc]
 8019b74: 2200         	movs	r2, #0x0
 8019b76: 73da         	strb	r2, [r3, #0xf]
; 	z_init_thread_timeout(thread_base);
 8019b78: 68f8         	ldr	r0, [r7, #0xc]
 8019b7a: f7ff ff47    	bl	0x8019a0c <z_init_thread_timeout> @ imm = #-0x172
; }
 8019b7e: bf00         	nop
 8019b80: 3710         	adds	r7, #0x10
 8019b82: 46bd         	mov	sp, r7
 8019b84: bd80         	pop	{r7, pc}

08019b86 <z_thread_mark_switched_out>:
; {
 8019b86: b580         	push	{r7, lr}
 8019b88: af00         	add	r7, sp, #0x0
; 	z_sched_usage_stop();
 8019b8a: f7f6 fa5d    	bl	0x8010048 <z_sched_usage_stop> @ imm = #-0x9b46
; }
 8019b8e: bf00         	nop
 8019b90: bd80         	pop	{r7, pc}

08019b92 <sys_dlist_init>:
; {
 8019b92: b480         	push	{r7}
 8019b94: b083         	sub	sp, #0xc
 8019b96: af00         	add	r7, sp, #0x0
 8019b98: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8019b9a: 687b         	ldr	r3, [r7, #0x4]
 8019b9c: 687a         	ldr	r2, [r7, #0x4]
 8019b9e: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8019ba0: 687b         	ldr	r3, [r7, #0x4]
 8019ba2: 687a         	ldr	r2, [r7, #0x4]
 8019ba4: 605a         	str	r2, [r3, #0x4]
; }
 8019ba6: bf00         	nop
 8019ba8: 370c         	adds	r7, #0xc
 8019baa: 46bd         	mov	sp, r7
 8019bac: bc80         	pop	{r7}
 8019bae: 4770         	bx	lr

08019bb0 <sys_dnode_init>:
; {
 8019bb0: b480         	push	{r7}
 8019bb2: b083         	sub	sp, #0xc
 8019bb4: af00         	add	r7, sp, #0x0
 8019bb6: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8019bb8: 687b         	ldr	r3, [r7, #0x4]
 8019bba: 2200         	movs	r2, #0x0
 8019bbc: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8019bbe: 687b         	ldr	r3, [r7, #0x4]
 8019bc0: 2200         	movs	r2, #0x0
 8019bc2: 605a         	str	r2, [r3, #0x4]
; }
 8019bc4: bf00         	nop
 8019bc6: 370c         	adds	r7, #0xc
 8019bc8: 46bd         	mov	sp, r7
 8019bca: bc80         	pop	{r7}
 8019bcc: 4770         	bx	lr

08019bce <sys_dnode_is_linked>:
; {
 8019bce: b480         	push	{r7}
 8019bd0: b083         	sub	sp, #0xc
 8019bd2: af00         	add	r7, sp, #0x0
 8019bd4: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 8019bd6: 687b         	ldr	r3, [r7, #0x4]
 8019bd8: 681b         	ldr	r3, [r3]
 8019bda: 2b00         	cmp	r3, #0x0
 8019bdc: bf14         	ite	ne
 8019bde: 2301         	movne	r3, #0x1
 8019be0: 2300         	moveq	r3, #0x0
 8019be2: b2db         	uxtb	r3, r3
; }
 8019be4: 4618         	mov	r0, r3
 8019be6: 370c         	adds	r7, #0xc
 8019be8: 46bd         	mov	sp, r7
 8019bea: bc80         	pop	{r7}
 8019bec: 4770         	bx	lr

08019bee <sys_dlist_is_empty>:
; {
 8019bee: b480         	push	{r7}
 8019bf0: b083         	sub	sp, #0xc
 8019bf2: af00         	add	r7, sp, #0x0
 8019bf4: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8019bf6: 687b         	ldr	r3, [r7, #0x4]
 8019bf8: 681b         	ldr	r3, [r3]
 8019bfa: 687a         	ldr	r2, [r7, #0x4]
 8019bfc: 429a         	cmp	r2, r3
 8019bfe: bf0c         	ite	eq
 8019c00: 2301         	moveq	r3, #0x1
 8019c02: 2300         	movne	r3, #0x0
 8019c04: b2db         	uxtb	r3, r3
; }
 8019c06: 4618         	mov	r0, r3
 8019c08: 370c         	adds	r7, #0xc
 8019c0a: 46bd         	mov	sp, r7
 8019c0c: bc80         	pop	{r7}
 8019c0e: 4770         	bx	lr

08019c10 <sys_dlist_peek_head>:
; {
 8019c10: b580         	push	{r7, lr}
 8019c12: b082         	sub	sp, #0x8
 8019c14: af00         	add	r7, sp, #0x0
 8019c16: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8019c18: 6878         	ldr	r0, [r7, #0x4]
 8019c1a: f7ff ffe8    	bl	0x8019bee <sys_dlist_is_empty> @ imm = #-0x30
 8019c1e: 4603         	mov	r3, r0
 8019c20: 2b00         	cmp	r3, #0x0
 8019c22: d102         	bne	0x8019c2a <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8019c24: 687b         	ldr	r3, [r7, #0x4]
 8019c26: 681b         	ldr	r3, [r3]
 8019c28: e000         	b	0x8019c2c <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8019c2a: 2300         	movs	r3, #0x0
; }
 8019c2c: 4618         	mov	r0, r3
 8019c2e: 3708         	adds	r7, #0x8
 8019c30: 46bd         	mov	sp, r7
 8019c32: bd80         	pop	{r7, pc}

08019c34 <sys_dlist_peek_next_no_check>:
; {
 8019c34: b480         	push	{r7}
 8019c36: b083         	sub	sp, #0xc
 8019c38: af00         	add	r7, sp, #0x0
 8019c3a: 6078         	str	r0, [r7, #0x4]
 8019c3c: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 8019c3e: 687b         	ldr	r3, [r7, #0x4]
 8019c40: 685b         	ldr	r3, [r3, #0x4]
 8019c42: 683a         	ldr	r2, [r7]
 8019c44: 429a         	cmp	r2, r3
 8019c46: d002         	beq	0x8019c4e <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 8019c48: 683b         	ldr	r3, [r7]
 8019c4a: 681b         	ldr	r3, [r3]
 8019c4c: e000         	b	0x8019c50 <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 8019c4e: 2300         	movs	r3, #0x0
; }
 8019c50: 4618         	mov	r0, r3
 8019c52: 370c         	adds	r7, #0xc
 8019c54: 46bd         	mov	sp, r7
 8019c56: bc80         	pop	{r7}
 8019c58: 4770         	bx	lr

08019c5a <sys_dlist_peek_next>:
; {
 8019c5a: b580         	push	{r7, lr}
 8019c5c: b082         	sub	sp, #0x8
 8019c5e: af00         	add	r7, sp, #0x0
 8019c60: 6078         	str	r0, [r7, #0x4]
 8019c62: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 8019c64: 683b         	ldr	r3, [r7]
 8019c66: 2b00         	cmp	r3, #0x0
 8019c68: d005         	beq	0x8019c76 <sys_dlist_peek_next+0x1c> @ imm = #0xa
 8019c6a: 6839         	ldr	r1, [r7]
 8019c6c: 6878         	ldr	r0, [r7, #0x4]
 8019c6e: f7ff ffe1    	bl	0x8019c34 <sys_dlist_peek_next_no_check> @ imm = #-0x3e
 8019c72: 4603         	mov	r3, r0
 8019c74: e000         	b	0x8019c78 <sys_dlist_peek_next+0x1e> @ imm = #0x0
 8019c76: 2300         	movs	r3, #0x0
; }
 8019c78: 4618         	mov	r0, r3
 8019c7a: 3708         	adds	r7, #0x8
 8019c7c: 46bd         	mov	sp, r7
 8019c7e: bd80         	pop	{r7, pc}

08019c80 <sys_dlist_append>:
; {
 8019c80: b480         	push	{r7}
 8019c82: b085         	sub	sp, #0x14
 8019c84: af00         	add	r7, sp, #0x0
 8019c86: 6078         	str	r0, [r7, #0x4]
 8019c88: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 8019c8a: 687b         	ldr	r3, [r7, #0x4]
 8019c8c: 685b         	ldr	r3, [r3, #0x4]
 8019c8e: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 8019c90: 683b         	ldr	r3, [r7]
 8019c92: 687a         	ldr	r2, [r7, #0x4]
 8019c94: 601a         	str	r2, [r3]
; 	node->prev = tail;
 8019c96: 683b         	ldr	r3, [r7]
 8019c98: 68fa         	ldr	r2, [r7, #0xc]
 8019c9a: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 8019c9c: 68fb         	ldr	r3, [r7, #0xc]
 8019c9e: 683a         	ldr	r2, [r7]
 8019ca0: 601a         	str	r2, [r3]
; 	list->tail = node;
 8019ca2: 687b         	ldr	r3, [r7, #0x4]
 8019ca4: 683a         	ldr	r2, [r7]
 8019ca6: 605a         	str	r2, [r3, #0x4]
; }
 8019ca8: bf00         	nop
 8019caa: 3714         	adds	r7, #0x14
 8019cac: 46bd         	mov	sp, r7
 8019cae: bc80         	pop	{r7}
 8019cb0: 4770         	bx	lr

08019cb2 <sys_dlist_insert>:
; {
 8019cb2: b480         	push	{r7}
 8019cb4: b085         	sub	sp, #0x14
 8019cb6: af00         	add	r7, sp, #0x0
 8019cb8: 6078         	str	r0, [r7, #0x4]
 8019cba: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 8019cbc: 687b         	ldr	r3, [r7, #0x4]
 8019cbe: 685b         	ldr	r3, [r3, #0x4]
 8019cc0: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 8019cc2: 683b         	ldr	r3, [r7]
 8019cc4: 68fa         	ldr	r2, [r7, #0xc]
 8019cc6: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 8019cc8: 683b         	ldr	r3, [r7]
 8019cca: 687a         	ldr	r2, [r7, #0x4]
 8019ccc: 601a         	str	r2, [r3]
; 	prev->next = node;
 8019cce: 68fb         	ldr	r3, [r7, #0xc]
 8019cd0: 683a         	ldr	r2, [r7]
 8019cd2: 601a         	str	r2, [r3]
; 	successor->prev = node;
 8019cd4: 687b         	ldr	r3, [r7, #0x4]
 8019cd6: 683a         	ldr	r2, [r7]
 8019cd8: 605a         	str	r2, [r3, #0x4]
; }
 8019cda: bf00         	nop
 8019cdc: 3714         	adds	r7, #0x14
 8019cde: 46bd         	mov	sp, r7
 8019ce0: bc80         	pop	{r7}
 8019ce2: 4770         	bx	lr

08019ce4 <sys_dlist_remove>:
; {
 8019ce4: b580         	push	{r7, lr}
 8019ce6: b084         	sub	sp, #0x10
 8019ce8: af00         	add	r7, sp, #0x0
 8019cea: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8019cec: 687b         	ldr	r3, [r7, #0x4]
 8019cee: 685b         	ldr	r3, [r3, #0x4]
 8019cf0: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8019cf2: 687b         	ldr	r3, [r7, #0x4]
 8019cf4: 681b         	ldr	r3, [r3]
 8019cf6: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8019cf8: 68fb         	ldr	r3, [r7, #0xc]
 8019cfa: 68ba         	ldr	r2, [r7, #0x8]
 8019cfc: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8019cfe: 68bb         	ldr	r3, [r7, #0x8]
 8019d00: 68fa         	ldr	r2, [r7, #0xc]
 8019d02: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8019d04: 6878         	ldr	r0, [r7, #0x4]
 8019d06: f7ff ff53    	bl	0x8019bb0 <sys_dnode_init> @ imm = #-0x15a
; }
 8019d0a: bf00         	nop
 8019d0c: 3710         	adds	r7, #0x10
 8019d0e: 46bd         	mov	sp, r7
 8019d10: bd80         	pop	{r7, pc}

08019d12 <k_yield>:
; {
 8019d12: b580         	push	{r7, lr}
 8019d14: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 8019d16: f7f4 ff41    	bl	0x800eb9c <z_impl_k_yield> @ imm = #-0xb17e
; }
 8019d1a: bf00         	nop
 8019d1c: bd80         	pop	{r7, pc}

08019d1e <k_thread_suspend>:
; {
 8019d1e: b580         	push	{r7, lr}
 8019d20: b082         	sub	sp, #0x8
 8019d22: af00         	add	r7, sp, #0x0
 8019d24: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_suspend(thread);
 8019d26: 6878         	ldr	r0, [r7, #0x4]
 8019d28: f7f4 f9a2    	bl	0x800e070 <z_impl_k_thread_suspend> @ imm = #-0xbcbc
; }
 8019d2c: bf00         	nop
 8019d2e: 3708         	adds	r7, #0x8
 8019d30: 46bd         	mov	sp, r7
 8019d32: bd80         	pop	{r7, pc}

08019d34 <z_is_inactive_timeout>:
; {
 8019d34: b580         	push	{r7, lr}
 8019d36: b082         	sub	sp, #0x8
 8019d38: af00         	add	r7, sp, #0x0
 8019d3a: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 8019d3c: 687b         	ldr	r3, [r7, #0x4]
 8019d3e: 4618         	mov	r0, r3
 8019d40: f7ff ff45    	bl	0x8019bce <sys_dnode_is_linked> @ imm = #-0x176
 8019d44: 4603         	mov	r3, r0
 8019d46: 2b00         	cmp	r3, #0x0
 8019d48: bf14         	ite	ne
 8019d4a: 2301         	movne	r3, #0x1
 8019d4c: 2300         	moveq	r3, #0x0
 8019d4e: b2db         	uxtb	r3, r3
 8019d50: f083 0301    	eor	r3, r3, #0x1
 8019d54: b2db         	uxtb	r3, r3
 8019d56: f003 0301    	and	r3, r3, #0x1
 8019d5a: b2db         	uxtb	r3, r3
; }
 8019d5c: 4618         	mov	r0, r3
 8019d5e: 3708         	adds	r7, #0x8
 8019d60: 46bd         	mov	sp, r7
 8019d62: bd80         	pop	{r7, pc}

08019d64 <z_abort_thread_timeout>:
; {
 8019d64: b580         	push	{r7, lr}
 8019d66: b082         	sub	sp, #0x8
 8019d68: af00         	add	r7, sp, #0x0
 8019d6a: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8019d6c: 687b         	ldr	r3, [r7, #0x4]
 8019d6e: 3318         	adds	r3, #0x18
 8019d70: 4618         	mov	r0, r3
 8019d72: f7f5 fdf1    	bl	0x800f958 <z_abort_timeout> @ imm = #-0xa41e
 8019d76: 4603         	mov	r3, r0
; }
 8019d78: 4618         	mov	r0, r3
 8019d7a: 3708         	adds	r7, #0x8
 8019d7c: 46bd         	mov	sp, r7
 8019d7e: bd80         	pop	{r7, pc}

08019d80 <thread_is_preemptible>:
; {
 8019d80: b480         	push	{r7}
 8019d82: b083         	sub	sp, #0xc
 8019d84: af00         	add	r7, sp, #0x0
 8019d86: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 8019d88: 687b         	ldr	r3, [r7, #0x4]
 8019d8a: 89db         	ldrh	r3, [r3, #0xe]
 8019d8c: 2b7f         	cmp	r3, #0x7f
 8019d8e: bf94         	ite	ls
 8019d90: 2301         	movls	r3, #0x1
 8019d92: 2300         	movhi	r3, #0x0
 8019d94: b2db         	uxtb	r3, r3
; }
 8019d96: 4618         	mov	r0, r3
 8019d98: 370c         	adds	r7, #0xc
 8019d9a: 46bd         	mov	sp, r7
 8019d9c: bc80         	pop	{r7}
 8019d9e: 4770         	bx	lr

08019da0 <thread_is_metairq>:
; {
 8019da0: b480         	push	{r7}
 8019da2: b083         	sub	sp, #0xc
 8019da4: af00         	add	r7, sp, #0x0
 8019da6: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8019da8: 2300         	movs	r3, #0x0
; }
 8019daa: 4618         	mov	r0, r3
 8019dac: 370c         	adds	r7, #0xc
 8019dae: 46bd         	mov	sp, r7
 8019db0: bc80         	pop	{r7}
 8019db2: 4770         	bx	lr

08019db4 <z_is_thread_suspended>:
; {
 8019db4: b480         	push	{r7}
 8019db6: b083         	sub	sp, #0xc
 8019db8: af00         	add	r7, sp, #0x0
 8019dba: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_SUSPENDED) != 0U;
 8019dbc: 687b         	ldr	r3, [r7, #0x4]
 8019dbe: 7b5b         	ldrb	r3, [r3, #0xd]
 8019dc0: f003 0310    	and	r3, r3, #0x10
 8019dc4: 2b00         	cmp	r3, #0x0
 8019dc6: bf14         	ite	ne
 8019dc8: 2301         	movne	r3, #0x1
 8019dca: 2300         	moveq	r3, #0x0
 8019dcc: b2db         	uxtb	r3, r3
; }
 8019dce: 4618         	mov	r0, r3
 8019dd0: 370c         	adds	r7, #0xc
 8019dd2: 46bd         	mov	sp, r7
 8019dd4: bc80         	pop	{r7}
 8019dd6: 4770         	bx	lr

08019dd8 <z_is_thread_prevented_from_running>:
; {
 8019dd8: b480         	push	{r7}
 8019dda: b085         	sub	sp, #0x14
 8019ddc: af00         	add	r7, sp, #0x0
 8019dde: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 8019de0: 687b         	ldr	r3, [r7, #0x4]
 8019de2: 7b5b         	ldrb	r3, [r3, #0xd]
 8019de4: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 8019de6: 7bfb         	ldrb	r3, [r7, #0xf]
 8019de8: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 8019dec: 2b00         	cmp	r3, #0x0
 8019dee: bf14         	ite	ne
 8019df0: 2301         	movne	r3, #0x1
 8019df2: 2300         	moveq	r3, #0x0
 8019df4: b2db         	uxtb	r3, r3
; }
 8019df6: 4618         	mov	r0, r3
 8019df8: 3714         	adds	r7, #0x14
 8019dfa: 46bd         	mov	sp, r7
 8019dfc: bc80         	pop	{r7}
 8019dfe: 4770         	bx	lr

08019e00 <z_is_thread_timeout_active>:
; {
 8019e00: b580         	push	{r7, lr}
 8019e02: b082         	sub	sp, #0x8
 8019e04: af00         	add	r7, sp, #0x0
 8019e06: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 8019e08: 687b         	ldr	r3, [r7, #0x4]
 8019e0a: 3318         	adds	r3, #0x18
 8019e0c: 4618         	mov	r0, r3
 8019e0e: f7ff ff91    	bl	0x8019d34 <z_is_inactive_timeout> @ imm = #-0xde
 8019e12: 4603         	mov	r3, r0
 8019e14: 2b00         	cmp	r3, #0x0
 8019e16: bf14         	ite	ne
 8019e18: 2301         	movne	r3, #0x1
 8019e1a: 2300         	moveq	r3, #0x0
 8019e1c: b2db         	uxtb	r3, r3
 8019e1e: f083 0301    	eor	r3, r3, #0x1
 8019e22: b2db         	uxtb	r3, r3
 8019e24: f003 0301    	and	r3, r3, #0x1
 8019e28: b2db         	uxtb	r3, r3
; }
 8019e2a: 4618         	mov	r0, r3
 8019e2c: 3708         	adds	r7, #0x8
 8019e2e: 46bd         	mov	sp, r7
 8019e30: bd80         	pop	{r7, pc}

08019e32 <z_is_thread_ready>:
; {
 8019e32: b580         	push	{r7, lr}
 8019e34: b082         	sub	sp, #0x8
 8019e36: af00         	add	r7, sp, #0x0
 8019e38: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 8019e3a: 6878         	ldr	r0, [r7, #0x4]
 8019e3c: f7ff ffcc    	bl	0x8019dd8 <z_is_thread_prevented_from_running> @ imm = #-0x68
 8019e40: 4603         	mov	r3, r0
 8019e42: f083 0301    	eor	r3, r3, #0x1
 8019e46: b2db         	uxtb	r3, r3
 8019e48: 2b00         	cmp	r3, #0x0
 8019e4a: d00a         	beq	0x8019e62 <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 8019e4c: 6878         	ldr	r0, [r7, #0x4]
 8019e4e: f7ff ffd7    	bl	0x8019e00 <z_is_thread_timeout_active> @ imm = #-0x52
 8019e52: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 8019e54: f083 0301    	eor	r3, r3, #0x1
 8019e58: b2db         	uxtb	r3, r3
 8019e5a: 2b00         	cmp	r3, #0x0
 8019e5c: d001         	beq	0x8019e62 <z_is_thread_ready+0x30> @ imm = #0x2
 8019e5e: 2301         	movs	r3, #0x1
 8019e60: e000         	b	0x8019e64 <z_is_thread_ready+0x32> @ imm = #0x0
 8019e62: 2300         	movs	r3, #0x0
 8019e64: f003 0301    	and	r3, r3, #0x1
 8019e68: b2db         	uxtb	r3, r3
; }
 8019e6a: 4618         	mov	r0, r3
 8019e6c: 3708         	adds	r7, #0x8
 8019e6e: 46bd         	mov	sp, r7
 8019e70: bd80         	pop	{r7, pc}

08019e72 <z_is_thread_state_set>:
; {
 8019e72: b480         	push	{r7}
 8019e74: b083         	sub	sp, #0xc
 8019e76: af00         	add	r7, sp, #0x0
 8019e78: 6078         	str	r0, [r7, #0x4]
 8019e7a: 6039         	str	r1, [r7]
; 	return (thread->base.thread_state & state) != 0U;
 8019e7c: 687b         	ldr	r3, [r7, #0x4]
 8019e7e: 7b5b         	ldrb	r3, [r3, #0xd]
 8019e80: 461a         	mov	r2, r3
 8019e82: 683b         	ldr	r3, [r7]
 8019e84: 4013         	ands	r3, r2
 8019e86: 2b00         	cmp	r3, #0x0
 8019e88: bf14         	ite	ne
 8019e8a: 2301         	movne	r3, #0x1
 8019e8c: 2300         	moveq	r3, #0x0
 8019e8e: b2db         	uxtb	r3, r3
; }
 8019e90: 4618         	mov	r0, r3
 8019e92: 370c         	adds	r7, #0xc
 8019e94: 46bd         	mov	sp, r7
 8019e96: bc80         	pop	{r7}
 8019e98: 4770         	bx	lr

08019e9a <z_is_thread_queued>:
; {
 8019e9a: b580         	push	{r7, lr}
 8019e9c: b082         	sub	sp, #0x8
 8019e9e: af00         	add	r7, sp, #0x0
 8019ea0: 6078         	str	r0, [r7, #0x4]
; 	return z_is_thread_state_set(thread, _THREAD_QUEUED);
 8019ea2: 2180         	movs	r1, #0x80
 8019ea4: 6878         	ldr	r0, [r7, #0x4]
 8019ea6: f7ff ffe4    	bl	0x8019e72 <z_is_thread_state_set> @ imm = #-0x38
 8019eaa: 4603         	mov	r3, r0
; }
 8019eac: 4618         	mov	r0, r3
 8019eae: 3708         	adds	r7, #0x8
 8019eb0: 46bd         	mov	sp, r7
 8019eb2: bd80         	pop	{r7, pc}

08019eb4 <z_mark_thread_as_suspended>:
; {
 8019eb4: b480         	push	{r7}
 8019eb6: b083         	sub	sp, #0xc
 8019eb8: af00         	add	r7, sp, #0x0
 8019eba: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_SUSPENDED;
 8019ebc: 687b         	ldr	r3, [r7, #0x4]
 8019ebe: 7b5b         	ldrb	r3, [r3, #0xd]
 8019ec0: f043 0310    	orr	r3, r3, #0x10
 8019ec4: b2da         	uxtb	r2, r3
 8019ec6: 687b         	ldr	r3, [r7, #0x4]
 8019ec8: 735a         	strb	r2, [r3, #0xd]
; }
 8019eca: bf00         	nop
 8019ecc: 370c         	adds	r7, #0xc
 8019ece: 46bd         	mov	sp, r7
 8019ed0: bc80         	pop	{r7}
 8019ed2: 4770         	bx	lr

08019ed4 <z_mark_thread_as_not_suspended>:
; {
 8019ed4: b480         	push	{r7}
 8019ed6: b083         	sub	sp, #0xc
 8019ed8: af00         	add	r7, sp, #0x0
 8019eda: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 8019edc: 687b         	ldr	r3, [r7, #0x4]
 8019ede: 7b5b         	ldrb	r3, [r3, #0xd]
 8019ee0: f023 0310    	bic	r3, r3, #0x10
 8019ee4: b2da         	uxtb	r2, r3
 8019ee6: 687b         	ldr	r3, [r7, #0x4]
 8019ee8: 735a         	strb	r2, [r3, #0xd]
; }
 8019eea: bf00         	nop
 8019eec: 370c         	adds	r7, #0xc
 8019eee: 46bd         	mov	sp, r7
 8019ef0: bc80         	pop	{r7}
 8019ef2: 4770         	bx	lr

08019ef4 <z_mark_thread_as_pending>:
; {
 8019ef4: b480         	push	{r7}
 8019ef6: b083         	sub	sp, #0xc
 8019ef8: af00         	add	r7, sp, #0x0
 8019efa: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_PENDING;
 8019efc: 687b         	ldr	r3, [r7, #0x4]
 8019efe: 7b5b         	ldrb	r3, [r3, #0xd]
 8019f00: f043 0302    	orr	r3, r3, #0x2
 8019f04: b2da         	uxtb	r2, r3
 8019f06: 687b         	ldr	r3, [r7, #0x4]
 8019f08: 735a         	strb	r2, [r3, #0xd]
; }
 8019f0a: bf00         	nop
 8019f0c: 370c         	adds	r7, #0xc
 8019f0e: 46bd         	mov	sp, r7
 8019f10: bc80         	pop	{r7}
 8019f12: 4770         	bx	lr

08019f14 <z_mark_thread_as_not_pending>:
; {
 8019f14: b480         	push	{r7}
 8019f16: b083         	sub	sp, #0xc
 8019f18: af00         	add	r7, sp, #0x0
 8019f1a: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8019f1c: 687b         	ldr	r3, [r7, #0x4]
 8019f1e: 7b5b         	ldrb	r3, [r3, #0xd]
 8019f20: f023 0302    	bic	r3, r3, #0x2
 8019f24: b2da         	uxtb	r2, r3
 8019f26: 687b         	ldr	r3, [r7, #0x4]
 8019f28: 735a         	strb	r2, [r3, #0xd]
; }
 8019f2a: bf00         	nop
 8019f2c: 370c         	adds	r7, #0xc
 8019f2e: 46bd         	mov	sp, r7
 8019f30: bc80         	pop	{r7}
 8019f32: 4770         	bx	lr

08019f34 <z_is_thread_essential>:
; {
 8019f34: b480         	push	{r7}
 8019f36: b083         	sub	sp, #0xc
 8019f38: af00         	add	r7, sp, #0x0
 8019f3a: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
 8019f3c: 687b         	ldr	r3, [r7, #0x4]
 8019f3e: 7b1b         	ldrb	r3, [r3, #0xc]
 8019f40: f003 0301    	and	r3, r3, #0x1
 8019f44: 2b00         	cmp	r3, #0x0
 8019f46: bf14         	ite	ne
 8019f48: 2301         	movne	r3, #0x1
 8019f4a: 2300         	moveq	r3, #0x0
 8019f4c: b2db         	uxtb	r3, r3
; }
 8019f4e: 4618         	mov	r0, r3
 8019f50: 370c         	adds	r7, #0xc
 8019f52: 46bd         	mov	sp, r7
 8019f54: bc80         	pop	{r7}
 8019f56: 4770         	bx	lr

08019f58 <z_reschedule_unlocked>:
; {
 8019f58: b580         	push	{r7, lr}
 8019f5a: b084         	sub	sp, #0x10
 8019f5c: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8019f5e: f3ef 8311    	mrs	r3, basepri
 8019f62: 60fb         	str	r3, [r7, #0xc]
;   return(result);
 8019f64: 68fb         	ldr	r3, [r7, #0xc]
; 	key = __get_BASEPRI();
 8019f66: 60bb         	str	r3, [r7, #0x8]
 8019f68: 2310         	movs	r3, #0x10
 8019f6a: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8019f6c: 687b         	ldr	r3, [r7, #0x4]
 8019f6e: f383 8812    	msr	basepri_max, r3
; }
 8019f72: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8019f74: f3bf 8f6f    	isb	sy
; }
 8019f78: bf00         	nop
; 	return key;
 8019f7a: 68bb         	ldr	r3, [r7, #0x8]
; 	(void) z_reschedule_irqlock(arch_irq_lock());
 8019f7c: 4618         	mov	r0, r3
 8019f7e: f000 f9b0    	bl	0x801a2e2 <z_reschedule_irqlock> @ imm = #0x360
; }
 8019f82: bf00         	nop
 8019f84: 3710         	adds	r7, #0x10
 8019f86: 46bd         	mov	sp, r7
 8019f88: bd80         	pop	{r7, pc}

08019f8a <unpend_thread_no_timeout>:
; {
 8019f8a: b580         	push	{r7, lr}
 8019f8c: b086         	sub	sp, #0x18
 8019f8e: af00         	add	r7, sp, #0x0
 8019f90: 6078         	str	r0, [r7, #0x4]
 8019f92: 687b         	ldr	r3, [r7, #0x4]
 8019f94: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8019f96: 68fb         	ldr	r3, [r7, #0xc]
 8019f98: 689b         	ldr	r3, [r3, #0x8]
 8019f9a: 617b         	str	r3, [r7, #0x14]
 8019f9c: 687b         	ldr	r3, [r7, #0x4]
 8019f9e: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8019fa0: 693b         	ldr	r3, [r7, #0x10]
 8019fa2: 4618         	mov	r0, r3
 8019fa4: f7ff fe9e    	bl	0x8019ce4 <sys_dlist_remove> @ imm = #-0x2c4
; }
 8019fa8: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8019faa: 6878         	ldr	r0, [r7, #0x4]
 8019fac: f7ff ffb2    	bl	0x8019f14 <z_mark_thread_as_not_pending> @ imm = #-0x9c
; 	thread->base.pended_on = NULL;
 8019fb0: 687b         	ldr	r3, [r7, #0x4]
 8019fb2: 2200         	movs	r2, #0x0
 8019fb4: 609a         	str	r2, [r3, #0x8]
; }
 8019fb6: bf00         	nop
 8019fb8: 3718         	adds	r7, #0x18
 8019fba: 46bd         	mov	sp, r7
 8019fbc: bd80         	pop	{r7, pc}

08019fbe <z_waitq_head>:
; {
 8019fbe: b580         	push	{r7, lr}
 8019fc0: b082         	sub	sp, #0x8
 8019fc2: af00         	add	r7, sp, #0x0
 8019fc4: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 8019fc6: 687b         	ldr	r3, [r7, #0x4]
 8019fc8: 4618         	mov	r0, r3
 8019fca: f7ff fe21    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #-0x3be
 8019fce: 4603         	mov	r3, r0
; }
 8019fd0: 4618         	mov	r0, r3
 8019fd2: 3708         	adds	r7, #0x8
 8019fd4: 46bd         	mov	sp, r7
 8019fd6: bd80         	pop	{r7, pc}

08019fd8 <z_swap_irqlock>:
; {
 8019fd8: b580         	push	{r7, lr}
 8019fda: b084         	sub	sp, #0x10
 8019fdc: af00         	add	r7, sp, #0x0
 8019fde: 6078         	str	r0, [r7, #0x4]
; 	ret = arch_swap(key);
 8019fe0: 6878         	ldr	r0, [r7, #0x4]
 8019fe2: f7e9 fa0f    	bl	0x8003404 <arch_swap>   @ imm = #-0x16be2
 8019fe6: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 8019fe8: 68fb         	ldr	r3, [r7, #0xc]
; }
 8019fea: 4618         	mov	r0, r3
 8019fec: 3710         	adds	r7, #0x10
 8019fee: 46bd         	mov	sp, r7
 8019ff0: bd80         	pop	{r7, pc}

08019ff2 <z_log_msg_runtime_create>:
; {
 8019ff2: b580         	push	{r7, lr}
 8019ff4: b08a         	sub	sp, #0x28
 8019ff6: af04         	add	r7, sp, #0x10
 8019ff8: 60b9         	str	r1, [r7, #0x8]
 8019ffa: 607b         	str	r3, [r7, #0x4]
 8019ffc: 4603         	mov	r3, r0
 8019ffe: 73fb         	strb	r3, [r7, #0xf]
 801a000: 4613         	mov	r3, r2
 801a002: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801a004: f107 032c    	add.w	r3, r7, #0x2c
 801a008: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801a00a: 7bba         	ldrb	r2, [r7, #0xe]
 801a00c: 7bf8         	ldrb	r0, [r7, #0xf]
 801a00e: 697b         	ldr	r3, [r7, #0x14]
 801a010: 9303         	str	r3, [sp, #0xc]
 801a012: 6abb         	ldr	r3, [r7, #0x28]
 801a014: 9302         	str	r3, [sp, #0x8]
 801a016: 6a7b         	ldr	r3, [r7, #0x24]
 801a018: 9301         	str	r3, [sp, #0x4]
 801a01a: 6a3b         	ldr	r3, [r7, #0x20]
 801a01c: 9300         	str	r3, [sp]
 801a01e: 687b         	ldr	r3, [r7, #0x4]
 801a020: 68b9         	ldr	r1, [r7, #0x8]
 801a022: f7e7 fe23    	bl	0x8001c6c <z_log_msg_runtime_vcreate> @ imm = #-0x183ba
; }
 801a026: bf00         	nop
 801a028: 3718         	adds	r7, #0x18
 801a02a: 46bd         	mov	sp, r7
 801a02c: bd80         	pop	{r7, pc}

0801a02e <z_sched_prio_cmp>:
; {
 801a02e: b480         	push	{r7}
 801a030: b085         	sub	sp, #0x14
 801a032: af00         	add	r7, sp, #0x0
 801a034: 6078         	str	r0, [r7, #0x4]
 801a036: 6039         	str	r1, [r7]
; 	int32_t b1 = thread_1->base.prio;
 801a038: 687b         	ldr	r3, [r7, #0x4]
 801a03a: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 801a03e: 60fb         	str	r3, [r7, #0xc]
; 	int32_t b2 = thread_2->base.prio;
 801a040: 683b         	ldr	r3, [r7]
 801a042: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 801a046: 60bb         	str	r3, [r7, #0x8]
; 	if (b1 != b2) {
 801a048: 68fa         	ldr	r2, [r7, #0xc]
 801a04a: 68bb         	ldr	r3, [r7, #0x8]
 801a04c: 429a         	cmp	r2, r3
 801a04e: d003         	beq	0x801a058 <z_sched_prio_cmp+0x2a> @ imm = #0x6
; 		return b2 - b1;
 801a050: 68ba         	ldr	r2, [r7, #0x8]
 801a052: 68fb         	ldr	r3, [r7, #0xc]
 801a054: 1ad3         	subs	r3, r2, r3
 801a056: e000         	b	0x801a05a <z_sched_prio_cmp+0x2c> @ imm = #0x0
; 	return 0;
 801a058: 2300         	movs	r3, #0x0
; }
 801a05a: 4618         	mov	r0, r3
 801a05c: 3714         	adds	r7, #0x14
 801a05e: 46bd         	mov	sp, r7
 801a060: bc80         	pop	{r7}
 801a062: 4770         	bx	lr

0801a064 <should_queue_thread>:
; {
 801a064: b480         	push	{r7}
 801a066: b083         	sub	sp, #0xc
 801a068: af00         	add	r7, sp, #0x0
 801a06a: 6078         	str	r0, [r7, #0x4]
; 	return !IS_ENABLED(CONFIG_SMP) || (thread != arch_current_thread());
 801a06c: 2301         	movs	r3, #0x1
; }
 801a06e: 4618         	mov	r0, r3
 801a070: 370c         	adds	r7, #0xc
 801a072: 46bd         	mov	sp, r7
 801a074: bc80         	pop	{r7}
 801a076: 4770         	bx	lr

0801a078 <is_aborting>:
; {
 801a078: b480         	push	{r7}
 801a07a: b083         	sub	sp, #0xc
 801a07c: af00         	add	r7, sp, #0x0
 801a07e: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_ABORTING) != 0U;
 801a080: 687b         	ldr	r3, [r7, #0x4]
 801a082: 7b5b         	ldrb	r3, [r3, #0xd]
 801a084: f003 0320    	and	r3, r3, #0x20
 801a088: 2b00         	cmp	r3, #0x0
 801a08a: bf14         	ite	ne
 801a08c: 2301         	movne	r3, #0x1
 801a08e: 2300         	moveq	r3, #0x0
 801a090: b2db         	uxtb	r3, r3
; }
 801a092: 4618         	mov	r0, r3
 801a094: 370c         	adds	r7, #0xc
 801a096: 46bd         	mov	sp, r7
 801a098: bc80         	pop	{r7}
 801a09a: 4770         	bx	lr

0801a09c <is_halting>:
; {
 801a09c: b480         	push	{r7}
 801a09e: b083         	sub	sp, #0xc
 801a0a0: af00         	add	r7, sp, #0x0
 801a0a2: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state &
 801a0a4: 687b         	ldr	r3, [r7, #0x4]
 801a0a6: 7b5b         	ldrb	r3, [r3, #0xd]
 801a0a8: f003 0360    	and	r3, r3, #0x60
; 		(_THREAD_ABORTING | _THREAD_SUSPENDING)) != 0U;
 801a0ac: 2b00         	cmp	r3, #0x0
 801a0ae: bf14         	ite	ne
 801a0b0: 2301         	movne	r3, #0x1
 801a0b2: 2300         	moveq	r3, #0x0
 801a0b4: b2db         	uxtb	r3, r3
; }
 801a0b6: 4618         	mov	r0, r3
 801a0b8: 370c         	adds	r7, #0xc
 801a0ba: 46bd         	mov	sp, r7
 801a0bc: bc80         	pop	{r7}
 801a0be: 4770         	bx	lr

0801a0c0 <clear_halting>:
; {
 801a0c0: b480         	push	{r7}
 801a0c2: b083         	sub	sp, #0xc
 801a0c4: af00         	add	r7, sp, #0x0
 801a0c6: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("dmb 0xF":::"memory");
 801a0c8: f3bf 8f5f    	dmb	sy
; }
 801a0cc: bf00         	nop
; }
 801a0ce: bf00         	nop
; }
 801a0d0: bf00         	nop
; 	thread->base.thread_state &= ~(_THREAD_ABORTING | _THREAD_SUSPENDING);
 801a0d2: 687b         	ldr	r3, [r7, #0x4]
 801a0d4: 7b5b         	ldrb	r3, [r3, #0xd]
 801a0d6: f023 0360    	bic	r3, r3, #0x60
 801a0da: b2da         	uxtb	r2, r3
 801a0dc: 687b         	ldr	r3, [r7, #0x4]
 801a0de: 735a         	strb	r2, [r3, #0xd]
; }
 801a0e0: bf00         	nop
 801a0e2: 370c         	adds	r7, #0xc
 801a0e4: 46bd         	mov	sp, r7
 801a0e6: bc80         	pop	{r7}
 801a0e8: 4770         	bx	lr

0801a0ea <update_metairq_preempt>:
; {
 801a0ea: b480         	push	{r7}
 801a0ec: b083         	sub	sp, #0xc
 801a0ee: af00         	add	r7, sp, #0x0
 801a0f0: 6078         	str	r0, [r7, #0x4]
; }
 801a0f2: bf00         	nop
 801a0f4: 370c         	adds	r7, #0xc
 801a0f6: 46bd         	mov	sp, r7
 801a0f8: bc80         	pop	{r7}
 801a0fa: 4770         	bx	lr

0801a0fc <thread_active_elsewhere>:
; {
 801a0fc: b480         	push	{r7}
 801a0fe: b083         	sub	sp, #0xc
 801a100: af00         	add	r7, sp, #0x0
 801a102: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 801a104: 2300         	movs	r3, #0x0
; }
 801a106: 4618         	mov	r0, r3
 801a108: 370c         	adds	r7, #0xc
 801a10a: 46bd         	mov	sp, r7
 801a10c: bc80         	pop	{r7}
 801a10e: 4770         	bx	lr

0801a110 <add_to_waitq_locked>:
; {
 801a110: b580         	push	{r7, lr}
 801a112: b086         	sub	sp, #0x18
 801a114: af00         	add	r7, sp, #0x0
 801a116: 6078         	str	r0, [r7, #0x4]
 801a118: 6039         	str	r1, [r7]
; 	unready_thread(thread);
 801a11a: 6878         	ldr	r0, [r7, #0x4]
 801a11c: f7f4 f918    	bl	0x800e350 <unready_thread> @ imm = #-0xbdd0
; 	z_mark_thread_as_pending(thread);
 801a120: 6878         	ldr	r0, [r7, #0x4]
 801a122: f7ff fee7    	bl	0x8019ef4 <z_mark_thread_as_pending> @ imm = #-0x232
; 	if (wait_q != NULL) {
 801a126: 683b         	ldr	r3, [r7]
 801a128: 2b00         	cmp	r3, #0x0
 801a12a: d041         	beq	0x801a1b0 <add_to_waitq_locked+0xa0> @ imm = #0x82
; 		thread->base.pended_on = wait_q;
 801a12c: 687b         	ldr	r3, [r7, #0x4]
 801a12e: 683a         	ldr	r2, [r7]
 801a130: 609a         	str	r2, [r3, #0x8]
; 		_priq_wait_add(&wait_q->waitq, thread);
 801a132: 683b         	ldr	r3, [r7]
 801a134: 617b         	str	r3, [r7, #0x14]
 801a136: 687b         	ldr	r3, [r7, #0x4]
 801a138: 613b         	str	r3, [r7, #0x10]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 801a13a: 6978         	ldr	r0, [r7, #0x14]
 801a13c: f7ff fd68    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #-0x530
 801a140: 4603         	mov	r3, r0
 801a142: 2b00         	cmp	r3, #0x0
 801a144: d004         	beq	0x801a150 <add_to_waitq_locked+0x40> @ imm = #0x8
 801a146: 6978         	ldr	r0, [r7, #0x14]
 801a148: f7ff fd62    	bl	0x8019c10 <sys_dlist_peek_head> @ imm = #-0x53c
 801a14c: 4603         	mov	r3, r0
 801a14e: e000         	b	0x801a152 <add_to_waitq_locked+0x42> @ imm = #0x0
 801a150: 2300         	movs	r3, #0x0
 801a152: 60fb         	str	r3, [r7, #0xc]
 801a154: e024         	b	0x801a1a0 <add_to_waitq_locked+0x90> @ imm = #0x48
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 801a156: 68f9         	ldr	r1, [r7, #0xc]
 801a158: 6938         	ldr	r0, [r7, #0x10]
 801a15a: f7ff ff68    	bl	0x801a02e <z_sched_prio_cmp> @ imm = #-0x130
 801a15e: 4603         	mov	r3, r0
 801a160: 2b00         	cmp	r3, #0x0
 801a162: dd07         	ble	0x801a174 <add_to_waitq_locked+0x64> @ imm = #0xe
; 			sys_dlist_insert(&t->base.qnode_dlist,
 801a164: 68fb         	ldr	r3, [r7, #0xc]
 801a166: 693a         	ldr	r2, [r7, #0x10]
 801a168: 4611         	mov	r1, r2
 801a16a: 4618         	mov	r0, r3
 801a16c: f7ff fda1    	bl	0x8019cb2 <sys_dlist_insert> @ imm = #-0x4be
; 			return;
 801a170: bf00         	nop
; }
 801a172: e01d         	b	0x801a1b0 <add_to_waitq_locked+0xa0> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 801a174: 68fb         	ldr	r3, [r7, #0xc]
 801a176: 2b00         	cmp	r3, #0x0
 801a178: d010         	beq	0x801a19c <add_to_waitq_locked+0x8c> @ imm = #0x20
 801a17a: 68fb         	ldr	r3, [r7, #0xc]
 801a17c: 4619         	mov	r1, r3
 801a17e: 6978         	ldr	r0, [r7, #0x14]
 801a180: f7ff fd6b    	bl	0x8019c5a <sys_dlist_peek_next> @ imm = #-0x52a
 801a184: 4603         	mov	r3, r0
 801a186: 2b00         	cmp	r3, #0x0
 801a188: d006         	beq	0x801a198 <add_to_waitq_locked+0x88> @ imm = #0xc
 801a18a: 68fb         	ldr	r3, [r7, #0xc]
 801a18c: 4619         	mov	r1, r3
 801a18e: 6978         	ldr	r0, [r7, #0x14]
 801a190: f7ff fd63    	bl	0x8019c5a <sys_dlist_peek_next> @ imm = #-0x53a
 801a194: 4603         	mov	r3, r0
 801a196: e002         	b	0x801a19e <add_to_waitq_locked+0x8e> @ imm = #0x4
 801a198: 2300         	movs	r3, #0x0
 801a19a: e000         	b	0x801a19e <add_to_waitq_locked+0x8e> @ imm = #0x0
 801a19c: 2300         	movs	r3, #0x0
 801a19e: 60fb         	str	r3, [r7, #0xc]
 801a1a0: 68fb         	ldr	r3, [r7, #0xc]
 801a1a2: 2b00         	cmp	r3, #0x0
 801a1a4: d1d7         	bne	0x801a156 <add_to_waitq_locked+0x46> @ imm = #-0x52
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 801a1a6: 693b         	ldr	r3, [r7, #0x10]
 801a1a8: 4619         	mov	r1, r3
 801a1aa: 6978         	ldr	r0, [r7, #0x14]
 801a1ac: f7ff fd68    	bl	0x8019c80 <sys_dlist_append> @ imm = #-0x530
; }
 801a1b0: bf00         	nop
 801a1b2: 3718         	adds	r7, #0x18
 801a1b4: 46bd         	mov	sp, r7
 801a1b6: bd80         	pop	{r7, pc}

0801a1b8 <add_thread_timeout>:
; {
 801a1b8: b580         	push	{r7, lr}
 801a1ba: b084         	sub	sp, #0x10
 801a1bc: af00         	add	r7, sp, #0x0
 801a1be: 60f8         	str	r0, [r7, #0xc]
 801a1c0: e9c7 2300    	strd	r2, r3, [r7]
; 	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 801a1c4: e9d7 2300    	ldrd	r2, r3, [r7]
 801a1c8: f04f 30ff    	mov.w	r0, #0xffffffff
 801a1cc: f04f 31ff    	mov.w	r1, #0xffffffff
 801a1d0: 428b         	cmp	r3, r1
 801a1d2: bf08         	it	eq
 801a1d4: 4282         	cmpeq	r2, r0
 801a1d6: d004         	beq	0x801a1e2 <add_thread_timeout+0x2a> @ imm = #0x8
; 		z_add_thread_timeout(thread, timeout);
 801a1d8: e9d7 2300    	ldrd	r2, r3, [r7]
 801a1dc: 68f8         	ldr	r0, [r7, #0xc]
 801a1de: f7f3 fc07    	bl	0x800d9f0 <z_add_thread_timeout> @ imm = #-0xc7f2
; }
 801a1e2: bf00         	nop
 801a1e4: 3710         	adds	r7, #0x10
 801a1e6: 46bd         	mov	sp, r7
 801a1e8: bd80         	pop	{r7, pc}

0801a1ea <pend_locked>:
; {
 801a1ea: b580         	push	{r7, lr}
 801a1ec: b084         	sub	sp, #0x10
 801a1ee: af00         	add	r7, sp, #0x0
 801a1f0: 60f8         	str	r0, [r7, #0xc]
 801a1f2: 60b9         	str	r1, [r7, #0x8]
 801a1f4: e9c7 2300    	strd	r2, r3, [r7]
; 	add_to_waitq_locked(thread, wait_q);
 801a1f8: 68b9         	ldr	r1, [r7, #0x8]
 801a1fa: 68f8         	ldr	r0, [r7, #0xc]
 801a1fc: f7ff ff88    	bl	0x801a110 <add_to_waitq_locked> @ imm = #-0xf0
; 	add_thread_timeout(thread, timeout);
 801a200: e9d7 2300    	ldrd	r2, r3, [r7]
 801a204: 68f8         	ldr	r0, [r7, #0xc]
 801a206: f7ff ffd7    	bl	0x801a1b8 <add_thread_timeout> @ imm = #-0x52
; }
 801a20a: bf00         	nop
 801a20c: 3710         	adds	r7, #0x10
 801a20e: 46bd         	mov	sp, r7
 801a210: bd80         	pop	{r7, pc}

0801a212 <z_thread_timeout>:
; {
 801a212: b580         	push	{r7, lr}
 801a214: b084         	sub	sp, #0x10
 801a216: af00         	add	r7, sp, #0x0
 801a218: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = CONTAINER_OF(timeout,
 801a21a: 687b         	ldr	r3, [r7, #0x4]
 801a21c: 3b18         	subs	r3, #0x18
 801a21e: 60fb         	str	r3, [r7, #0xc]
; 	z_sched_wake_thread(thread, true);
 801a220: 2101         	movs	r1, #0x1
 801a222: 68f8         	ldr	r0, [r7, #0xc]
 801a224: f7f4 f978    	bl	0x800e518 <z_sched_wake_thread> @ imm = #-0xbd10
; }
 801a228: bf00         	nop
 801a22a: 3710         	adds	r7, #0x10
 801a22c: 46bd         	mov	sp, r7
 801a22e: bd80         	pop	{r7, pc}

0801a230 <resched>:
; {
 801a230: b480         	push	{r7}
 801a232: b085         	sub	sp, #0x14
 801a234: af00         	add	r7, sp, #0x0
 801a236: 6078         	str	r0, [r7, #0x4]
 801a238: 687b         	ldr	r3, [r7, #0x4]
 801a23a: 60fb         	str	r3, [r7, #0xc]
; 	return key == 0U;
 801a23c: 68fb         	ldr	r3, [r7, #0xc]
 801a23e: 2b00         	cmp	r3, #0x0
 801a240: bf0c         	ite	eq
 801a242: 2301         	moveq	r3, #0x1
 801a244: 2300         	movne	r3, #0x0
 801a246: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 801a248: 2b00         	cmp	r3, #0x0
 801a24a: d00f         	beq	0x801a26c <resched+0x3c> @ imm = #0x1e
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801a24c: f3ef 8305    	mrs	r3, ipsr
 801a250: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 801a252: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 801a254: 2b00         	cmp	r3, #0x0
 801a256: bf14         	ite	ne
 801a258: 2301         	movne	r3, #0x1
 801a25a: 2300         	moveq	r3, #0x0
 801a25c: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 801a25e: f083 0301    	eor	r3, r3, #0x1
 801a262: b2db         	uxtb	r3, r3
 801a264: 2b00         	cmp	r3, #0x0
 801a266: d001         	beq	0x801a26c <resched+0x3c> @ imm = #0x2
 801a268: 2301         	movs	r3, #0x1
 801a26a: e000         	b	0x801a26e <resched+0x3e> @ imm = #0x0
 801a26c: 2300         	movs	r3, #0x0
 801a26e: f003 0301    	and	r3, r3, #0x1
 801a272: b2db         	uxtb	r3, r3
; }
 801a274: 4618         	mov	r0, r3
 801a276: 3714         	adds	r7, #0x14
 801a278: 46bd         	mov	sp, r7
 801a27a: bc80         	pop	{r7}
 801a27c: 4770         	bx	lr

0801a27e <z_reschedule>:
; {
 801a27e: b580         	push	{r7, lr}
 801a280: b08a         	sub	sp, #0x28
 801a282: af00         	add	r7, sp, #0x0
 801a284: 6078         	str	r0, [r7, #0x4]
 801a286: 6039         	str	r1, [r7]
; 	if (resched(key.key) && need_swap()) {
 801a288: 683b         	ldr	r3, [r7]
 801a28a: 4618         	mov	r0, r3
 801a28c: f7ff ffd0    	bl	0x801a230 <resched>     @ imm = #-0x60
 801a290: 4603         	mov	r3, r0
 801a292: 2b00         	cmp	r3, #0x0
 801a294: d010         	beq	0x801a2b8 <z_reschedule+0x3a> @ imm = #0x20
 801a296: f7f4 fb41    	bl	0x800e91c <need_swap>   @ imm = #-0xb97e
 801a29a: 4603         	mov	r3, r0
 801a29c: 2b00         	cmp	r3, #0x0
 801a29e: d00b         	beq	0x801a2b8 <z_reschedule+0x3a> @ imm = #0x16
 801a2a0: 687b         	ldr	r3, [r7, #0x4]
 801a2a2: 627b         	str	r3, [r7, #0x24]
 801a2a4: 683b         	ldr	r3, [r7]
 801a2a6: 60fb         	str	r3, [r7, #0xc]
 801a2a8: 6a7b         	ldr	r3, [r7, #0x24]
 801a2aa: 623b         	str	r3, [r7, #0x20]
; }
 801a2ac: bf00         	nop
; 	return z_swap_irqlock(key.key);
 801a2ae: 68fb         	ldr	r3, [r7, #0xc]
 801a2b0: 4618         	mov	r0, r3
 801a2b2: f7ff fe91    	bl	0x8019fd8 <z_swap_irqlock> @ imm = #-0x2de
; 		z_swap(lock, key);
 801a2b6: e010         	b	0x801a2da <z_reschedule+0x5c> @ imm = #0x20
 801a2b8: 687b         	ldr	r3, [r7, #0x4]
 801a2ba: 61fb         	str	r3, [r7, #0x1c]
 801a2bc: 683b         	ldr	r3, [r7]
 801a2be: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 801a2c0: 693b         	ldr	r3, [r7, #0x10]
 801a2c2: 61bb         	str	r3, [r7, #0x18]
 801a2c4: 69bb         	ldr	r3, [r7, #0x18]
 801a2c6: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801a2c8: 697b         	ldr	r3, [r7, #0x14]
 801a2ca: f383 8811    	msr	basepri, r3
; }
 801a2ce: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801a2d0: f3bf 8f6f    	isb	sy
; }
 801a2d4: bf00         	nop
; }
 801a2d6: bf00         	nop
; }
 801a2d8: bf00         	nop
; }
 801a2da: bf00         	nop
 801a2dc: 3728         	adds	r7, #0x28
 801a2de: 46bd         	mov	sp, r7
 801a2e0: bd80         	pop	{r7, pc}

0801a2e2 <z_reschedule_irqlock>:
; {
 801a2e2: b580         	push	{r7, lr}
 801a2e4: b084         	sub	sp, #0x10
 801a2e6: af00         	add	r7, sp, #0x0
 801a2e8: 6078         	str	r0, [r7, #0x4]
; 	if (resched(key) && need_swap()) {
 801a2ea: 6878         	ldr	r0, [r7, #0x4]
 801a2ec: f7ff ffa0    	bl	0x801a230 <resched>     @ imm = #-0xc0
 801a2f0: 4603         	mov	r3, r0
 801a2f2: 2b00         	cmp	r3, #0x0
 801a2f4: d008         	beq	0x801a308 <z_reschedule_irqlock+0x26> @ imm = #0x10
 801a2f6: f7f4 fb11    	bl	0x800e91c <need_swap>   @ imm = #-0xb9de
 801a2fa: 4603         	mov	r3, r0
 801a2fc: 2b00         	cmp	r3, #0x0
 801a2fe: d003         	beq	0x801a308 <z_reschedule_irqlock+0x26> @ imm = #0x6
; 		z_swap_irqlock(key);
 801a300: 6878         	ldr	r0, [r7, #0x4]
 801a302: f7ff fe69    	bl	0x8019fd8 <z_swap_irqlock> @ imm = #-0x32e
 801a306: e00b         	b	0x801a320 <z_reschedule_irqlock+0x3e> @ imm = #0x16
 801a308: 687b         	ldr	r3, [r7, #0x4]
 801a30a: 60fb         	str	r3, [r7, #0xc]
 801a30c: 68fb         	ldr	r3, [r7, #0xc]
 801a30e: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801a310: 68bb         	ldr	r3, [r7, #0x8]
 801a312: f383 8811    	msr	basepri, r3
; }
 801a316: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801a318: f3bf 8f6f    	isb	sy
; }
 801a31c: bf00         	nop
; }
 801a31e: bf00         	nop
; }
 801a320: bf00         	nop
 801a322: 3710         	adds	r7, #0x10
 801a324: 46bd         	mov	sp, r7
 801a326: bd80         	pop	{r7, pc}

0801a328 <init_ready_q>:
; {
 801a328: b580         	push	{r7, lr}
 801a32a: b084         	sub	sp, #0x10
 801a32c: af00         	add	r7, sp, #0x0
 801a32e: 6078         	str	r0, [r7, #0x4]
; 	_priq_run_init(&ready_q->runq);
 801a330: 687b         	ldr	r3, [r7, #0x4]
 801a332: 3304         	adds	r3, #0x4
 801a334: 60fb         	str	r3, [r7, #0xc]
; 	sys_dlist_init(pq);
 801a336: 68f8         	ldr	r0, [r7, #0xc]
 801a338: f7ff fc2b    	bl	0x8019b92 <sys_dlist_init> @ imm = #-0x7aa
; }
 801a33c: bf00         	nop
; }
 801a33e: bf00         	nop
 801a340: 3710         	adds	r7, #0x10
 801a342: 46bd         	mov	sp, r7
 801a344: bd80         	pop	{r7, pc}

0801a346 <unpend_all>:
; {
 801a346: b580         	push	{r7, lr}
 801a348: b086         	sub	sp, #0x18
 801a34a: af00         	add	r7, sp, #0x0
 801a34c: 6078         	str	r0, [r7, #0x4]
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 801a34e: 6878         	ldr	r0, [r7, #0x4]
 801a350: f7ff fe35    	bl	0x8019fbe <z_waitq_head> @ imm = #-0x396
 801a354: 6178         	str	r0, [r7, #0x14]
 801a356: e015         	b	0x801a384 <unpend_all+0x3e> @ imm = #0x2a
; 		unpend_thread_no_timeout(thread);
 801a358: 6978         	ldr	r0, [r7, #0x14]
 801a35a: f7ff fe16    	bl	0x8019f8a <unpend_thread_no_timeout> @ imm = #-0x3d4
; 		(void)z_abort_thread_timeout(thread);
 801a35e: 6978         	ldr	r0, [r7, #0x14]
 801a360: f7ff fd00    	bl	0x8019d64 <z_abort_thread_timeout> @ imm = #-0x600
 801a364: 697b         	ldr	r3, [r7, #0x14]
 801a366: 613b         	str	r3, [r7, #0x10]
 801a368: 2300         	movs	r3, #0x0
 801a36a: 60fb         	str	r3, [r7, #0xc]
; 	thread->arch.swap_return_value = value;
 801a36c: 693b         	ldr	r3, [r7, #0x10]
 801a36e: 68fa         	ldr	r2, [r7, #0xc]
 801a370: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 801a374: bf00         	nop
; 		ready_thread(thread);
 801a376: 6978         	ldr	r0, [r7, #0x14]
 801a378: f7f3 fc74    	bl	0x800dc64 <ready_thread> @ imm = #-0xc718
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 801a37c: 6878         	ldr	r0, [r7, #0x4]
 801a37e: f7ff fe1e    	bl	0x8019fbe <z_waitq_head> @ imm = #-0x3c4
 801a382: 6178         	str	r0, [r7, #0x14]
 801a384: 697b         	ldr	r3, [r7, #0x14]
 801a386: 2b00         	cmp	r3, #0x0
 801a388: d1e6         	bne	0x801a358 <unpend_all+0x12> @ imm = #-0x34
; }
 801a38a: bf00         	nop
 801a38c: bf00         	nop
 801a38e: 3718         	adds	r7, #0x18
 801a390: 46bd         	mov	sp, r7
 801a392: bd80         	pop	{r7, pc}

0801a394 <thread_is_preemptible>:
; {
 801a394: b480         	push	{r7}
 801a396: b083         	sub	sp, #0xc
 801a398: af00         	add	r7, sp, #0x0
 801a39a: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 801a39c: 687b         	ldr	r3, [r7, #0x4]
 801a39e: 89db         	ldrh	r3, [r3, #0xe]
 801a3a0: 2b7f         	cmp	r3, #0x7f
 801a3a2: bf94         	ite	ls
 801a3a4: 2301         	movls	r3, #0x1
 801a3a6: 2300         	movhi	r3, #0x0
 801a3a8: b2db         	uxtb	r3, r3
; }
 801a3aa: 4618         	mov	r0, r3
 801a3ac: 370c         	adds	r7, #0xc
 801a3ae: 46bd         	mov	sp, r7
 801a3b0: bc80         	pop	{r7}
 801a3b2: 4770         	bx	lr

0801a3b4 <z_is_thread_prevented_from_running>:
; {
 801a3b4: b480         	push	{r7}
 801a3b6: b085         	sub	sp, #0x14
 801a3b8: af00         	add	r7, sp, #0x0
 801a3ba: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 801a3bc: 687b         	ldr	r3, [r7, #0x4]
 801a3be: 7b5b         	ldrb	r3, [r3, #0xd]
 801a3c0: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 801a3c2: 7bfb         	ldrb	r3, [r7, #0xf]
 801a3c4: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 801a3c8: 2b00         	cmp	r3, #0x0
 801a3ca: bf14         	ite	ne
 801a3cc: 2301         	movne	r3, #0x1
 801a3ce: 2300         	moveq	r3, #0x0
 801a3d0: b2db         	uxtb	r3, r3
; }
 801a3d2: 4618         	mov	r0, r3
 801a3d4: 3714         	adds	r7, #0x14
 801a3d6: 46bd         	mov	sp, r7
 801a3d8: bc80         	pop	{r7}
 801a3da: 4770         	bx	lr

0801a3dc <z_is_prio1_higher_than_prio2>:
; {
 801a3dc: b480         	push	{r7}
 801a3de: b083         	sub	sp, #0xc
 801a3e0: af00         	add	r7, sp, #0x0
 801a3e2: 6078         	str	r0, [r7, #0x4]
 801a3e4: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 801a3e6: 687a         	ldr	r2, [r7, #0x4]
 801a3e8: 683b         	ldr	r3, [r7]
 801a3ea: 429a         	cmp	r2, r3
 801a3ec: bfb4         	ite	lt
 801a3ee: 2301         	movlt	r3, #0x1
 801a3f0: 2300         	movge	r3, #0x0
 801a3f2: b2db         	uxtb	r3, r3
; }
 801a3f4: 4618         	mov	r0, r3
 801a3f6: 370c         	adds	r7, #0xc
 801a3f8: 46bd         	mov	sp, r7
 801a3fa: bc80         	pop	{r7}
 801a3fc: 4770         	bx	lr

0801a3fe <z_is_prio_higher>:
; {
 801a3fe: b580         	push	{r7, lr}
 801a400: b082         	sub	sp, #0x8
 801a402: af00         	add	r7, sp, #0x0
 801a404: 6078         	str	r0, [r7, #0x4]
 801a406: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 801a408: 6839         	ldr	r1, [r7]
 801a40a: 6878         	ldr	r0, [r7, #0x4]
 801a40c: f7ff ffe6    	bl	0x801a3dc <z_is_prio1_higher_than_prio2> @ imm = #-0x34
 801a410: 4603         	mov	r3, r0
; }
 801a412: 4618         	mov	r0, r3
 801a414: 3708         	adds	r7, #0x8
 801a416: 46bd         	mov	sp, r7
 801a418: bd80         	pop	{r7, pc}

0801a41a <sys_dnode_init>:
; {
 801a41a: b480         	push	{r7}
 801a41c: b083         	sub	sp, #0xc
 801a41e: af00         	add	r7, sp, #0x0
 801a420: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801a422: 687b         	ldr	r3, [r7, #0x4]
 801a424: 2200         	movs	r2, #0x0
 801a426: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801a428: 687b         	ldr	r3, [r7, #0x4]
 801a42a: 2200         	movs	r2, #0x0
 801a42c: 605a         	str	r2, [r3, #0x4]
; }
 801a42e: bf00         	nop
 801a430: 370c         	adds	r7, #0xc
 801a432: 46bd         	mov	sp, r7
 801a434: bc80         	pop	{r7}
 801a436: 4770         	bx	lr

0801a438 <sys_dnode_is_linked>:
; {
 801a438: b480         	push	{r7}
 801a43a: b083         	sub	sp, #0xc
 801a43c: af00         	add	r7, sp, #0x0
 801a43e: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 801a440: 687b         	ldr	r3, [r7, #0x4]
 801a442: 681b         	ldr	r3, [r3]
 801a444: 2b00         	cmp	r3, #0x0
 801a446: bf14         	ite	ne
 801a448: 2301         	movne	r3, #0x1
 801a44a: 2300         	moveq	r3, #0x0
 801a44c: b2db         	uxtb	r3, r3
; }
 801a44e: 4618         	mov	r0, r3
 801a450: 370c         	adds	r7, #0xc
 801a452: 46bd         	mov	sp, r7
 801a454: bc80         	pop	{r7}
 801a456: 4770         	bx	lr

0801a458 <sys_dlist_is_empty>:
; {
 801a458: b480         	push	{r7}
 801a45a: b083         	sub	sp, #0xc
 801a45c: af00         	add	r7, sp, #0x0
 801a45e: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 801a460: 687b         	ldr	r3, [r7, #0x4]
 801a462: 681b         	ldr	r3, [r3]
 801a464: 687a         	ldr	r2, [r7, #0x4]
 801a466: 429a         	cmp	r2, r3
 801a468: bf0c         	ite	eq
 801a46a: 2301         	moveq	r3, #0x1
 801a46c: 2300         	movne	r3, #0x0
 801a46e: b2db         	uxtb	r3, r3
; }
 801a470: 4618         	mov	r0, r3
 801a472: 370c         	adds	r7, #0xc
 801a474: 46bd         	mov	sp, r7
 801a476: bc80         	pop	{r7}
 801a478: 4770         	bx	lr

0801a47a <sys_dlist_peek_head>:
; {
 801a47a: b580         	push	{r7, lr}
 801a47c: b082         	sub	sp, #0x8
 801a47e: af00         	add	r7, sp, #0x0
 801a480: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 801a482: 6878         	ldr	r0, [r7, #0x4]
 801a484: f7ff ffe8    	bl	0x801a458 <sys_dlist_is_empty> @ imm = #-0x30
 801a488: 4603         	mov	r3, r0
 801a48a: 2b00         	cmp	r3, #0x0
 801a48c: d102         	bne	0x801a494 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 801a48e: 687b         	ldr	r3, [r7, #0x4]
 801a490: 681b         	ldr	r3, [r3]
 801a492: e000         	b	0x801a496 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 801a494: 2300         	movs	r3, #0x0
; }
 801a496: 4618         	mov	r0, r3
 801a498: 3708         	adds	r7, #0x8
 801a49a: 46bd         	mov	sp, r7
 801a49c: bd80         	pop	{r7, pc}

0801a49e <sys_dlist_peek_next_no_check>:
; {
 801a49e: b480         	push	{r7}
 801a4a0: b083         	sub	sp, #0xc
 801a4a2: af00         	add	r7, sp, #0x0
 801a4a4: 6078         	str	r0, [r7, #0x4]
 801a4a6: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 801a4a8: 687b         	ldr	r3, [r7, #0x4]
 801a4aa: 685b         	ldr	r3, [r3, #0x4]
 801a4ac: 683a         	ldr	r2, [r7]
 801a4ae: 429a         	cmp	r2, r3
 801a4b0: d002         	beq	0x801a4b8 <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 801a4b2: 683b         	ldr	r3, [r7]
 801a4b4: 681b         	ldr	r3, [r3]
 801a4b6: e000         	b	0x801a4ba <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 801a4b8: 2300         	movs	r3, #0x0
; }
 801a4ba: 4618         	mov	r0, r3
 801a4bc: 370c         	adds	r7, #0xc
 801a4be: 46bd         	mov	sp, r7
 801a4c0: bc80         	pop	{r7}
 801a4c2: 4770         	bx	lr

0801a4c4 <sys_dlist_peek_next>:
; {
 801a4c4: b580         	push	{r7, lr}
 801a4c6: b082         	sub	sp, #0x8
 801a4c8: af00         	add	r7, sp, #0x0
 801a4ca: 6078         	str	r0, [r7, #0x4]
 801a4cc: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 801a4ce: 683b         	ldr	r3, [r7]
 801a4d0: 2b00         	cmp	r3, #0x0
 801a4d2: d005         	beq	0x801a4e0 <sys_dlist_peek_next+0x1c> @ imm = #0xa
 801a4d4: 6839         	ldr	r1, [r7]
 801a4d6: 6878         	ldr	r0, [r7, #0x4]
 801a4d8: f7ff ffe1    	bl	0x801a49e <sys_dlist_peek_next_no_check> @ imm = #-0x3e
 801a4dc: 4603         	mov	r3, r0
 801a4de: e000         	b	0x801a4e2 <sys_dlist_peek_next+0x1e> @ imm = #0x0
 801a4e0: 2300         	movs	r3, #0x0
; }
 801a4e2: 4618         	mov	r0, r3
 801a4e4: 3708         	adds	r7, #0x8
 801a4e6: 46bd         	mov	sp, r7
 801a4e8: bd80         	pop	{r7, pc}

0801a4ea <sys_dlist_append>:
; {
 801a4ea: b480         	push	{r7}
 801a4ec: b085         	sub	sp, #0x14
 801a4ee: af00         	add	r7, sp, #0x0
 801a4f0: 6078         	str	r0, [r7, #0x4]
 801a4f2: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 801a4f4: 687b         	ldr	r3, [r7, #0x4]
 801a4f6: 685b         	ldr	r3, [r3, #0x4]
 801a4f8: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 801a4fa: 683b         	ldr	r3, [r7]
 801a4fc: 687a         	ldr	r2, [r7, #0x4]
 801a4fe: 601a         	str	r2, [r3]
; 	node->prev = tail;
 801a500: 683b         	ldr	r3, [r7]
 801a502: 68fa         	ldr	r2, [r7, #0xc]
 801a504: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 801a506: 68fb         	ldr	r3, [r7, #0xc]
 801a508: 683a         	ldr	r2, [r7]
 801a50a: 601a         	str	r2, [r3]
; 	list->tail = node;
 801a50c: 687b         	ldr	r3, [r7, #0x4]
 801a50e: 683a         	ldr	r2, [r7]
 801a510: 605a         	str	r2, [r3, #0x4]
; }
 801a512: bf00         	nop
 801a514: 3714         	adds	r7, #0x14
 801a516: 46bd         	mov	sp, r7
 801a518: bc80         	pop	{r7}
 801a51a: 4770         	bx	lr

0801a51c <sys_dlist_insert>:
; {
 801a51c: b480         	push	{r7}
 801a51e: b085         	sub	sp, #0x14
 801a520: af00         	add	r7, sp, #0x0
 801a522: 6078         	str	r0, [r7, #0x4]
 801a524: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 801a526: 687b         	ldr	r3, [r7, #0x4]
 801a528: 685b         	ldr	r3, [r3, #0x4]
 801a52a: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 801a52c: 683b         	ldr	r3, [r7]
 801a52e: 68fa         	ldr	r2, [r7, #0xc]
 801a530: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 801a532: 683b         	ldr	r3, [r7]
 801a534: 687a         	ldr	r2, [r7, #0x4]
 801a536: 601a         	str	r2, [r3]
; 	prev->next = node;
 801a538: 68fb         	ldr	r3, [r7, #0xc]
 801a53a: 683a         	ldr	r2, [r7]
 801a53c: 601a         	str	r2, [r3]
; 	successor->prev = node;
 801a53e: 687b         	ldr	r3, [r7, #0x4]
 801a540: 683a         	ldr	r2, [r7]
 801a542: 605a         	str	r2, [r3, #0x4]
; }
 801a544: bf00         	nop
 801a546: 3714         	adds	r7, #0x14
 801a548: 46bd         	mov	sp, r7
 801a54a: bc80         	pop	{r7}
 801a54c: 4770         	bx	lr

0801a54e <sys_dlist_remove>:
; {
 801a54e: b580         	push	{r7, lr}
 801a550: b084         	sub	sp, #0x10
 801a552: af00         	add	r7, sp, #0x0
 801a554: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 801a556: 687b         	ldr	r3, [r7, #0x4]
 801a558: 685b         	ldr	r3, [r3, #0x4]
 801a55a: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 801a55c: 687b         	ldr	r3, [r7, #0x4]
 801a55e: 681b         	ldr	r3, [r3]
 801a560: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 801a562: 68fb         	ldr	r3, [r7, #0xc]
 801a564: 68ba         	ldr	r2, [r7, #0x8]
 801a566: 601a         	str	r2, [r3]
; 	next->prev = prev;
 801a568: 68bb         	ldr	r3, [r7, #0x8]
 801a56a: 68fa         	ldr	r2, [r7, #0xc]
 801a56c: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 801a56e: 6878         	ldr	r0, [r7, #0x4]
 801a570: f7ff ff53    	bl	0x801a41a <sys_dnode_init> @ imm = #-0x15a
; }
 801a574: bf00         	nop
 801a576: 3710         	adds	r7, #0x10
 801a578: 46bd         	mov	sp, r7
 801a57a: bd80         	pop	{r7, pc}

0801a57c <remove_timeout>:
; {
 801a57c: b5f0         	push	{r4, r5, r6, r7, lr}
 801a57e: b083         	sub	sp, #0xc
 801a580: af00         	add	r7, sp, #0x0
 801a582: 6078         	str	r0, [r7, #0x4]
; 	if (next(t) != NULL) {
 801a584: 6878         	ldr	r0, [r7, #0x4]
 801a586: f7f5 f8cd    	bl	0x800f724 <next>        @ imm = #-0xae66
 801a58a: 4603         	mov	r3, r0
 801a58c: 2b00         	cmp	r3, #0x0
 801a58e: d00d         	beq	0x801a5ac <remove_timeout+0x30> @ imm = #0x1a
; 		next(t)->dticks += t->dticks;
 801a590: 6878         	ldr	r0, [r7, #0x4]
 801a592: f7f5 f8c7    	bl	0x800f724 <next>        @ imm = #-0xae72
 801a596: 4606         	mov	r6, r0
 801a598: e9d6 0104    	ldrd	r0, r1, [r6, #16]
 801a59c: 687b         	ldr	r3, [r7, #0x4]
 801a59e: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 801a5a2: 1884         	adds	r4, r0, r2
 801a5a4: eb41 0503    	adc.w	r5, r1, r3
 801a5a8: e9c6 4504    	strd	r4, r5, [r6, #16]
; 	sys_dlist_remove(&t->node);
 801a5ac: 687b         	ldr	r3, [r7, #0x4]
 801a5ae: 4618         	mov	r0, r3
 801a5b0: f7ff ffcd    	bl	0x801a54e <sys_dlist_remove> @ imm = #-0x66
; }
 801a5b4: bf00         	nop
 801a5b6: 370c         	adds	r7, #0xc
 801a5b8: 46bd         	mov	sp, r7
 801a5ba: bdf0         	pop	{r4, r5, r6, r7, pc}

0801a5bc <next_timeout>:
; {
 801a5bc: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 801a5c0: b086         	sub	sp, #0x18
 801a5c2: af00         	add	r7, sp, #0x0
; 	struct _timeout *to = first();
 801a5c4: f7f5 f8a0    	bl	0x800f708 <first>       @ imm = #-0xaec0
 801a5c8: 6138         	str	r0, [r7, #0x10]
; 	int32_t ticks_elapsed = elapsed();
 801a5ca: f7f5 f8bd    	bl	0x800f748 <elapsed>     @ imm = #-0xae86
 801a5ce: 60f8         	str	r0, [r7, #0xc]
; 	if ((to == NULL) ||
 801a5d0: 693b         	ldr	r3, [r7, #0x10]
 801a5d2: 2b00         	cmp	r3, #0x0
 801a5d4: d00f         	beq	0x801a5f6 <next_timeout+0x3a> @ imm = #0x1e
; 	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 801a5d6: 693b         	ldr	r3, [r7, #0x10]
 801a5d8: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 801a5dc: 68f9         	ldr	r1, [r7, #0xc]
 801a5de: 17c8         	asrs	r0, r1, #0x1f
 801a5e0: 468a         	mov	r10, r1
 801a5e2: 4683         	mov	r11, r0
 801a5e4: ebb2 040a    	subs.w	r4, r2, r10
 801a5e8: eb63 050b    	sbc.w	r5, r3, r11
; 	if ((to == NULL) ||
 801a5ec: f1b4 4f00    	cmp.w	r4, #0x80000000
 801a5f0: f175 0300    	sbcs	r3, r5, #0x0
 801a5f4: db03         	blt	0x801a5fe <next_timeout+0x42> @ imm = #0x6
; 		ret = MAX_WAIT;
 801a5f6: f06f 4300    	mvn	r3, #0x80000000
 801a5fa: 617b         	str	r3, [r7, #0x14]
 801a5fc: e016         	b	0x801a62c <next_timeout+0x70> @ imm = #0x2c
; 		ret = MAX(0, to->dticks - ticks_elapsed);
 801a5fe: 693b         	ldr	r3, [r7, #0x10]
 801a600: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 801a604: 68f9         	ldr	r1, [r7, #0xc]
 801a606: 17c8         	asrs	r0, r1, #0x1f
 801a608: 4688         	mov	r8, r1
 801a60a: 4681         	mov	r9, r0
 801a60c: ebb2 0108    	subs.w	r1, r2, r8
 801a610: 6039         	str	r1, [r7]
 801a612: eb63 0309    	sbc.w	r3, r3, r9
 801a616: 607b         	str	r3, [r7, #0x4]
 801a618: e9d7 2300    	ldrd	r2, r3, [r7]
 801a61c: 2b00         	cmp	r3, #0x0
 801a61e: da03         	bge	0x801a628 <next_timeout+0x6c> @ imm = #0x6
 801a620: f04f 0200    	mov.w	r2, #0x0
 801a624: f04f 0300    	mov.w	r3, #0x0
 801a628: 4613         	mov	r3, r2
 801a62a: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 801a62c: 697b         	ldr	r3, [r7, #0x14]
; }
 801a62e: 4618         	mov	r0, r3
 801a630: 3718         	adds	r7, #0x18
 801a632: 46bd         	mov	sp, r7
 801a634: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0801a638 <sys_clock_tick_get_32>:
; {
 801a638: b580         	push	{r7, lr}
 801a63a: af00         	add	r7, sp, #0x0
; 	return (uint32_t)sys_clock_tick_get();
 801a63c: f7f5 face    	bl	0x800fbdc <sys_clock_tick_get> @ imm = #-0xaa64
 801a640: 4602         	mov	r2, r0
 801a642: 460b         	mov	r3, r1
 801a644: 4613         	mov	r3, r2
; }
 801a646: 4618         	mov	r0, r3
 801a648: bd80         	pop	{r7, pc}

0801a64a <z_impl_k_uptime_ticks>:
; {
 801a64a: b580         	push	{r7, lr}
 801a64c: af00         	add	r7, sp, #0x0
; 	return sys_clock_tick_get();
 801a64e: f7f5 fac5    	bl	0x800fbdc <sys_clock_tick_get> @ imm = #-0xaa76
 801a652: 4602         	mov	r2, r0
 801a654: 460b         	mov	r3, r1
; }
 801a656: 4610         	mov	r0, r2
 801a658: 4619         	mov	r1, r3
 801a65a: bd80         	pop	{r7, pc}

0801a65c <sys_dnode_is_linked>:
; {
 801a65c: b480         	push	{r7}
 801a65e: b083         	sub	sp, #0xc
 801a660: af00         	add	r7, sp, #0x0
 801a662: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 801a664: 687b         	ldr	r3, [r7, #0x4]
 801a666: 681b         	ldr	r3, [r3]
 801a668: 2b00         	cmp	r3, #0x0
 801a66a: bf14         	ite	ne
 801a66c: 2301         	movne	r3, #0x1
 801a66e: 2300         	moveq	r3, #0x0
 801a670: b2db         	uxtb	r3, r3
; }
 801a672: 4618         	mov	r0, r3
 801a674: 370c         	adds	r7, #0xc
 801a676: 46bd         	mov	sp, r7
 801a678: bc80         	pop	{r7}
 801a67a: 4770         	bx	lr

0801a67c <sys_dlist_is_empty>:
; {
 801a67c: b480         	push	{r7}
 801a67e: b083         	sub	sp, #0xc
 801a680: af00         	add	r7, sp, #0x0
 801a682: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 801a684: 687b         	ldr	r3, [r7, #0x4]
 801a686: 681b         	ldr	r3, [r3]
 801a688: 687a         	ldr	r2, [r7, #0x4]
 801a68a: 429a         	cmp	r2, r3
 801a68c: bf0c         	ite	eq
 801a68e: 2301         	moveq	r3, #0x1
 801a690: 2300         	movne	r3, #0x0
 801a692: b2db         	uxtb	r3, r3
; }
 801a694: 4618         	mov	r0, r3
 801a696: 370c         	adds	r7, #0xc
 801a698: 46bd         	mov	sp, r7
 801a69a: bc80         	pop	{r7}
 801a69c: 4770         	bx	lr

0801a69e <sys_dlist_peek_head>:
; {
 801a69e: b580         	push	{r7, lr}
 801a6a0: b082         	sub	sp, #0x8
 801a6a2: af00         	add	r7, sp, #0x0
 801a6a4: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 801a6a6: 6878         	ldr	r0, [r7, #0x4]
 801a6a8: f7ff ffe8    	bl	0x801a67c <sys_dlist_is_empty> @ imm = #-0x30
 801a6ac: 4603         	mov	r3, r0
 801a6ae: 2b00         	cmp	r3, #0x0
 801a6b0: d102         	bne	0x801a6b8 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 801a6b2: 687b         	ldr	r3, [r7, #0x4]
 801a6b4: 681b         	ldr	r3, [r3]
 801a6b6: e000         	b	0x801a6ba <sys_dlist_peek_head+0x1c> @ imm = #0x0
 801a6b8: 2300         	movs	r3, #0x0
; }
 801a6ba: 4618         	mov	r0, r3
 801a6bc: 3708         	adds	r7, #0x8
 801a6be: 46bd         	mov	sp, r7
 801a6c0: bd80         	pop	{r7, pc}

0801a6c2 <k_uptime_ticks>:
; {
 801a6c2: b580         	push	{r7, lr}
 801a6c4: af00         	add	r7, sp, #0x0
; 	return z_impl_k_uptime_ticks();
 801a6c6: f7ff ffc0    	bl	0x801a64a <z_impl_k_uptime_ticks> @ imm = #-0x80
 801a6ca: 4602         	mov	r2, r0
 801a6cc: 460b         	mov	r3, r1
; }
 801a6ce: 4610         	mov	r0, r2
 801a6d0: 4619         	mov	r1, r3
 801a6d2: bd80         	pop	{r7, pc}

0801a6d4 <z_waitq_head>:
; {
 801a6d4: b580         	push	{r7, lr}
 801a6d6: b082         	sub	sp, #0x8
 801a6d8: af00         	add	r7, sp, #0x0
 801a6da: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 801a6dc: 687b         	ldr	r3, [r7, #0x4]
 801a6de: 4618         	mov	r0, r3
 801a6e0: f7ff ffdd    	bl	0x801a69e <sys_dlist_peek_head> @ imm = #-0x46
 801a6e4: 4603         	mov	r3, r0
; }
 801a6e6: 4618         	mov	r0, r3
 801a6e8: 3708         	adds	r7, #0x8
 801a6ea: 46bd         	mov	sp, r7
 801a6ec: bd80         	pop	{r7, pc}

0801a6ee <arch_k_cycle_get_32>:
; {
 801a6ee: b580         	push	{r7, lr}
 801a6f0: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 801a6f2: f7ef ff1f    	bl	0x800a534 <sys_clock_cycle_get_32> @ imm = #-0x101c2
 801a6f6: 4603         	mov	r3, r0
; }
 801a6f8: 4618         	mov	r0, r3
 801a6fa: bd80         	pop	{r7, pc}

0801a6fc <k_cycle_get_32>:
; {
 801a6fc: b580         	push	{r7, lr}
 801a6fe: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 801a700: f7ff fff5    	bl	0x801a6ee <arch_k_cycle_get_32> @ imm = #-0x16
 801a704: 4603         	mov	r3, r0
; }
 801a706: 4618         	mov	r0, r3
 801a708: bd80         	pop	{r7, pc}

0801a70a <usage_now>:
; {
 801a70a: b580         	push	{r7, lr}
 801a70c: b082         	sub	sp, #0x8
 801a70e: af00         	add	r7, sp, #0x0
; 	now = k_cycle_get_32();
 801a710: f7ff fff4    	bl	0x801a6fc <k_cycle_get_32> @ imm = #-0x18
 801a714: 6078         	str	r0, [r7, #0x4]
; 	return (now == 0) ? 1 : now;
 801a716: 687b         	ldr	r3, [r7, #0x4]
 801a718: 2b00         	cmp	r3, #0x0
 801a71a: d001         	beq	0x801a720 <usage_now+0x16> @ imm = #0x2
 801a71c: 687b         	ldr	r3, [r7, #0x4]
 801a71e: e000         	b	0x801a722 <usage_now+0x18> @ imm = #0x0
 801a720: 2301         	movs	r3, #0x1
; }
 801a722: 4618         	mov	r0, r3
 801a724: 3708         	adds	r7, #0x8
 801a726: 46bd         	mov	sp, r7
 801a728: bd80         	pop	{r7, pc}

0801a72a <sched_cpu_update_usage>:
; {
 801a72a: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 801a72e: b083         	sub	sp, #0xc
 801a730: af00         	add	r7, sp, #0x0
 801a732: 6078         	str	r0, [r7, #0x4]
 801a734: 6039         	str	r1, [r7]
; 	if (!cpu->usage->track_usage) {
 801a736: 687b         	ldr	r3, [r7, #0x4]
 801a738: 699b         	ldr	r3, [r3, #0x18]
 801a73a: 7a1b         	ldrb	r3, [r3, #0x8]
 801a73c: f083 0301    	eor	r3, r3, #0x1
 801a740: b2db         	uxtb	r3, r3
 801a742: 2b00         	cmp	r3, #0x0
 801a744: d116         	bne	0x801a774 <sched_cpu_update_usage+0x4a> @ imm = #0x2c
; 	if (cpu->current != cpu->idle_thread) {
 801a746: 687b         	ldr	r3, [r7, #0x4]
 801a748: 689a         	ldr	r2, [r3, #0x8]
 801a74a: 687b         	ldr	r3, [r7, #0x4]
 801a74c: 68db         	ldr	r3, [r3, #0xc]
 801a74e: 429a         	cmp	r2, r3
 801a750: d011         	beq	0x801a776 <sched_cpu_update_usage+0x4c> @ imm = #0x22
; 		cpu->usage->total += cycles;
 801a752: 687b         	ldr	r3, [r7, #0x4]
 801a754: 699b         	ldr	r3, [r3, #0x18]
 801a756: e9d3 2300    	ldrd	r2, r3, [r3]
 801a75a: 6839         	ldr	r1, [r7]
 801a75c: 2000         	movs	r0, #0x0
 801a75e: 460c         	mov	r4, r1
 801a760: 4605         	mov	r5, r0
 801a762: 6879         	ldr	r1, [r7, #0x4]
 801a764: 6989         	ldr	r1, [r1, #0x18]
 801a766: eb12 0804    	adds.w	r8, r2, r4
 801a76a: eb43 0905    	adc.w	r9, r3, r5
 801a76e: e9c1 8900    	strd	r8, r9, [r1]
 801a772: e000         	b	0x801a776 <sched_cpu_update_usage+0x4c> @ imm = #0x0
; 		return;
 801a774: bf00         	nop
; }
 801a776: 370c         	adds	r7, #0xc
 801a778: 46bd         	mov	sp, r7
 801a77a: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 801a77e: 4770         	bx	lr

0801a780 <sched_thread_update_usage>:
; {
 801a780: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 801a784: b083         	sub	sp, #0xc
 801a786: af00         	add	r7, sp, #0x0
 801a788: 6078         	str	r0, [r7, #0x4]
 801a78a: 6039         	str	r1, [r7]
; 	thread->base.usage.total += cycles;
 801a78c: 687b         	ldr	r3, [r7, #0x4]
 801a78e: e9d3 230c    	ldrd	r2, r3, [r3, #48]
 801a792: 6839         	ldr	r1, [r7]
 801a794: 2000         	movs	r0, #0x0
 801a796: 460c         	mov	r4, r1
 801a798: 4605         	mov	r5, r0
 801a79a: eb12 0804    	adds.w	r8, r2, r4
 801a79e: eb43 0905    	adc.w	r9, r3, r5
 801a7a2: 687b         	ldr	r3, [r7, #0x4]
 801a7a4: e9c3 890c    	strd	r8, r9, [r3, #48]
; }
 801a7a8: bf00         	nop
 801a7aa: 370c         	adds	r7, #0xc
 801a7ac: 46bd         	mov	sp, r7
 801a7ae: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 801a7b2: 4770         	bx	lr

0801a7b4 <sys_dlist_init>:
; {
 801a7b4: b480         	push	{r7}
 801a7b6: b083         	sub	sp, #0xc
 801a7b8: af00         	add	r7, sp, #0x0
 801a7ba: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 801a7bc: 687b         	ldr	r3, [r7, #0x4]
 801a7be: 687a         	ldr	r2, [r7, #0x4]
 801a7c0: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 801a7c2: 687b         	ldr	r3, [r7, #0x4]
 801a7c4: 687a         	ldr	r2, [r7, #0x4]
 801a7c6: 605a         	str	r2, [r3, #0x4]
; }
 801a7c8: bf00         	nop
 801a7ca: 370c         	adds	r7, #0xc
 801a7cc: 46bd         	mov	sp, r7
 801a7ce: bc80         	pop	{r7}
 801a7d0: 4770         	bx	lr

0801a7d2 <z_waitq_init>:
; {
 801a7d2: b580         	push	{r7, lr}
 801a7d4: b082         	sub	sp, #0x8
 801a7d6: af00         	add	r7, sp, #0x0
 801a7d8: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 801a7da: 687b         	ldr	r3, [r7, #0x4]
 801a7dc: 4618         	mov	r0, r3
 801a7de: f7ff ffe9    	bl	0x801a7b4 <sys_dlist_init> @ imm = #-0x2e
; }
 801a7e2: bf00         	nop
 801a7e4: 3708         	adds	r7, #0x8
 801a7e6: 46bd         	mov	sp, r7
 801a7e8: bd80         	pop	{r7, pc}

0801a7ea <k_heap_init>:
; {
 801a7ea: b580         	push	{r7, lr}
 801a7ec: b084         	sub	sp, #0x10
 801a7ee: af00         	add	r7, sp, #0x0
 801a7f0: 60f8         	str	r0, [r7, #0xc]
 801a7f2: 60b9         	str	r1, [r7, #0x8]
 801a7f4: 607a         	str	r2, [r7, #0x4]
; 	z_waitq_init(&heap->wait_q);
 801a7f6: 68fb         	ldr	r3, [r7, #0xc]
 801a7f8: 330c         	adds	r3, #0xc
 801a7fa: 4618         	mov	r0, r3
 801a7fc: f7ff ffe9    	bl	0x801a7d2 <z_waitq_init> @ imm = #-0x2e
; 	sys_heap_init(&heap->heap, mem, bytes);
 801a800: 68fb         	ldr	r3, [r7, #0xc]
 801a802: 687a         	ldr	r2, [r7, #0x4]
 801a804: 68b9         	ldr	r1, [r7, #0x8]
 801a806: 4618         	mov	r0, r3
 801a808: f7f7 f8cd    	bl	0x80119a6 <sys_heap_init> @ imm = #-0x8e66
; }
 801a80c: bf00         	nop
 801a80e: 3710         	adds	r7, #0x10
 801a810: 46bd         	mov	sp, r7
 801a812: bd80         	pop	{r7, pc}

0801a814 <memcpy>:
 801a814: 440a         	add	r2, r1
 801a816: 4291         	cmp	r1, r2
 801a818: f100 33ff    	add.w	r3, r0, #0xffffffff
 801a81c: d100         	bne	0x801a820 <memcpy+0xc>  @ imm = #0x0
 801a81e: 4770         	bx	lr
 801a820: b510         	push	{r4, lr}
 801a822: f811 4b01    	ldrb	r4, [r1], #1
 801a826: f803 4f01    	strb	r4, [r3, #1]!
 801a82a: 4291         	cmp	r1, r2
 801a82c: d1f9         	bne	0x801a822 <memcpy+0xe>  @ imm = #-0xe
 801a82e: bd10         	pop	{r4, pc}

0801a830 <memset>:
 801a830: 4402         	add	r2, r0
 801a832: 4603         	mov	r3, r0
 801a834: 4293         	cmp	r3, r2
 801a836: d100         	bne	0x801a83a <memset+0xa>  @ imm = #0x0
 801a838: 4770         	bx	lr
 801a83a: f803 1b01    	strb	r1, [r3], #1
 801a83e: e7f9         	b	0x801a834 <memset+0x4>  @ imm = #-0xe

0801a840 <strncpy>:
 801a840: b510         	push	{r4, lr}
 801a842: 3901         	subs	r1, #0x1
 801a844: 4604         	mov	r4, r0
 801a846: b132         	cbz	r2, 0x801a856 <strncpy+0x16> @ imm = #0xc
 801a848: f811 3f01    	ldrb	r3, [r1, #1]!
 801a84c: f800 3b01    	strb	r3, [r0], #1
 801a850: 3a01         	subs	r2, #0x1
 801a852: 2b00         	cmp	r3, #0x0
 801a854: d1f7         	bne	0x801a846 <strncpy+0x6> @ imm = #-0x12
 801a856: 2100         	movs	r1, #0x0
 801a858: f7ff ffea    	bl	0x801a830 <memset>      @ imm = #-0x2c
 801a85c: 4620         	mov	r0, r4
 801a85e: bd10         	pop	{r4, pc}

0801a860 <strnlen>:
 801a860: b510         	push	{r4, lr}
 801a862: 4602         	mov	r2, r0
 801a864: 4401         	add	r1, r0
 801a866: 428a         	cmp	r2, r1
 801a868: 4613         	mov	r3, r2
 801a86a: d003         	beq	0x801a874 <strnlen+0x14> @ imm = #0x6
 801a86c: 781c         	ldrb	r4, [r3]
 801a86e: 3201         	adds	r2, #0x1
 801a870: 2c00         	cmp	r4, #0x0
 801a872: d1f8         	bne	0x801a866 <strnlen+0x6> @ imm = #-0x10
 801a874: 1a18         	subs	r0, r3, r0
 801a876: bd10         	pop	{r4, pc}

0801a878 <__ultoa_invert>:
 801a878: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 801a87c: f1c3 0937    	rsb.w	r9, r3, #0x37
 801a880: 4607         	mov	r7, r0
 801a882: 4688         	mov	r8, r1
 801a884: fa5f f989    	uxtb.w	r9, r9
 801a888: f003 051f    	and	r5, r3, #0x1f
 801a88c: 4616         	mov	r6, r2
 801a88e: f04f 0a00    	mov.w	r10, #0x0
 801a892: 4638         	mov	r0, r7
 801a894: 4641         	mov	r1, r8
 801a896: 462a         	mov	r2, r5
 801a898: 4653         	mov	r3, r10
 801a89a: f7e6 f92b    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x19daa
 801a89e: b2d4         	uxtb	r4, r2
 801a8a0: 2c09         	cmp	r4, #0x9
 801a8a2: bf88         	it	hi
 801a8a4: 444c         	addhi	r4, r9
 801a8a6: 463a         	mov	r2, r7
 801a8a8: 4643         	mov	r3, r8
 801a8aa: bf88         	it	hi
 801a8ac: b2e4         	uxtbhi	r4, r4
 801a8ae: 42aa         	cmp	r2, r5
 801a8b0: f104 0430    	add.w	r4, r4, #0x30
 801a8b4: eb73 030a    	sbcs.w	r3, r3, r10
 801a8b8: f806 4b01    	strb	r4, [r6], #1
 801a8bc: 4607         	mov	r7, r0
 801a8be: 4688         	mov	r8, r1
 801a8c0: d2e7         	bhs	0x801a892 <__ultoa_invert+0x1a> @ imm = #-0x32
 801a8c2: 4630         	mov	r0, r6
 801a8c4: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}

0801a8c8 <mulShiftAll64>:
 801a8c8: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 801a8cc: b087         	sub	sp, #0x1c
 801a8ce: 1806         	adds	r6, r0, r0
 801a8d0: 4699         	mov	r9, r3
 801a8d2: ab02         	add	r3, sp, #0x8
 801a8d4: eb41 0401    	adc.w	r4, r1, r1
 801a8d8: 9300         	str	r3, [sp]
 801a8da: 4615         	mov	r5, r2
 801a8dc: 4630         	mov	r0, r6
 801a8de: e9d2 2300    	ldrd	r2, r3, [r2]
 801a8e2: 4621         	mov	r1, r4
 801a8e4: f8dd b044    	ldr.w	r11, [sp, #0x44]
 801a8e8: f000 f8a9    	bl	0x801aa3e <__umul128>   @ imm = #0x152
 801a8ec: ab04         	add	r3, sp, #0x10
 801a8ee: 9300         	str	r3, [sp]
 801a8f0: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 801a8f4: 4607         	mov	r7, r0
 801a8f6: 4688         	mov	r8, r1
 801a8f8: 4630         	mov	r0, r6
 801a8fa: 4621         	mov	r1, r4
 801a8fc: f000 f89f    	bl	0x801aa3e <__umul128>   @ imm = #0x13e
 801a900: e9dd 6302    	ldrd	r6, r3, [sp, #8]
 801a904: 1984         	adds	r4, r0, r6
 801a906: eb51 0603    	adcs.w	r6, r1, r3
 801a90a: 9b04         	ldr	r3, [sp, #0x10]
 801a90c: e9d5 0100    	ldrd	r0, r1, [r5]
 801a910: f04f 0200    	mov.w	r2, #0x0
 801a914: bf28         	it	hs
 801a916: 2201         	movhs	r2, #0x1
 801a918: 18d2         	adds	r2, r2, r3
 801a91a: 9b05         	ldr	r3, [sp, #0x14]
 801a91c: f143 0300    	adc	r3, r3, #0x0
 801a920: 1838         	adds	r0, r7, r0
 801a922: eb48 0101    	adc.w	r1, r8, r1
 801a926: 42b8         	cmp	r0, r7
 801a928: eb71 0108    	sbcs.w	r1, r1, r8
 801a92c: e9d5 c102    	ldrd	r12, r1, [r5, #8]
 801a930: bf34         	ite	lo
 801a932: 2001         	movlo	r0, #0x1
 801a934: 2000         	movhs	r0, #0x0
 801a936: eb14 0c0c    	adds.w	r12, r4, r12
 801a93a: eb46 0101    	adc.w	r1, r6, r1
 801a93e: eb10 000c    	adds.w	r0, r0, r12
 801a942: f141 0100    	adc	r1, r1, #0x0
 801a946: 42a0         	cmp	r0, r4
 801a948: eb71 0c06    	sbcs.w	r12, r1, r6
 801a94c: bf34         	ite	lo
 801a94e: f04f 0c01    	movlo.w	r12, #0x1
 801a952: f04f 0c00    	movhs.w	r12, #0x0
 801a956: e9cd 2304    	strd	r2, r3, [sp, #16]
 801a95a: f1a9 0a41    	sub.w	r10, r9, #0x41
 801a95e: eb1c 0202    	adds.w	r2, r12, r2
 801a962: f143 0300    	adc	r3, r3, #0x0
 801a966: f8cd a000    	str.w	r10, [sp]
 801a96a: f000 f883    	bl	0x801aa74 <__shiftright128> @ imm = #0x106
 801a96e: 9b10         	ldr	r3, [sp, #0x40]
 801a970: e9c3 0100    	strd	r0, r1, [r3]
 801a974: 9b12         	ldr	r3, [sp, #0x48]
 801a976: 2b01         	cmp	r3, #0x1
 801a978: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 801a97c: d129         	bne	0x801a9d2 <mulShiftAll64+0x10a> @ imm = #0x52
 801a97e: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 801a982: e9d5 c500    	ldrd	r12, r5, [r5]
 801a986: 1a20         	subs	r0, r4, r0
 801a988: eb66 0101    	sbc.w	r1, r6, r1
 801a98c: 4567         	cmp	r7, r12
 801a98e: eb78 0505    	sbcs.w	r5, r8, r5
 801a992: bf34         	ite	lo
 801a994: 2501         	movlo	r5, #0x1
 801a996: 2500         	movhs	r5, #0x0
 801a998: 1b40         	subs	r0, r0, r5
 801a99a: f161 0100    	sbc	r1, r1, #0x0
 801a99e: 4284         	cmp	r4, r0
 801a9a0: eb76 0501    	sbcs.w	r5, r6, r1
 801a9a4: bf34         	ite	lo
 801a9a6: 2501         	movlo	r5, #0x1
 801a9a8: 2500         	movhs	r5, #0x0
 801a9aa: 1b52         	subs	r2, r2, r5
 801a9ac: f8cd a000    	str.w	r10, [sp]
 801a9b0: f163 0300    	sbc	r3, r3, #0x0
 801a9b4: f000 f85e    	bl	0x801aa74 <__shiftright128> @ imm = #0xbc
 801a9b8: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 801a9bc: e9cb 0100    	strd	r0, r1, [r11]
 801a9c0: f8cd a000    	str.w	r10, [sp]
 801a9c4: 4620         	mov	r0, r4
 801a9c6: 4631         	mov	r1, r6
 801a9c8: f000 f854    	bl	0x801aa74 <__shiftright128> @ imm = #0xa8
 801a9cc: b007         	add	sp, #0x1c
 801a9ce: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 801a9d2: eb17 0e07    	adds.w	lr, r7, r7
 801a9d6: eb48 0c08    	adc.w	r12, r8, r8
 801a9da: 1920         	adds	r0, r4, r4
 801a9dc: eb46 0106    	adc.w	r1, r6, r6
 801a9e0: 45be         	cmp	lr, r7
 801a9e2: eb7c 0808    	sbcs.w	r8, r12, r8
 801a9e6: bf34         	ite	lo
 801a9e8: 2701         	movlo	r7, #0x1
 801a9ea: 2700         	movhs	r7, #0x0
 801a9ec: 19c7         	adds	r7, r0, r7
 801a9ee: f141 0800    	adc	r8, r1, #0x0
 801a9f2: e9d5 0100    	ldrd	r0, r1, [r5]
 801a9f6: 4586         	cmp	lr, r0
 801a9f8: eb7c 0c01    	sbcs.w	r12, r12, r1
 801a9fc: e9d5 1502    	ldrd	r1, r5, [r5, #8]
 801aa00: bf34         	ite	lo
 801aa02: 2001         	movlo	r0, #0x1
 801aa04: 2000         	movhs	r0, #0x0
 801aa06: 1a38         	subs	r0, r7, r0
 801aa08: f168 0c00    	sbc	r12, r8, #0x0
 801aa0c: 1a40         	subs	r0, r0, r1
 801aa0e: eb6c 0105    	sbc.w	r1, r12, r5
 801aa12: 1892         	adds	r2, r2, r2
 801aa14: 415b         	adcs	r3, r3
 801aa16: 42a7         	cmp	r7, r4
 801aa18: eb78 0506    	sbcs.w	r5, r8, r6
 801aa1c: bf34         	ite	lo
 801aa1e: 2501         	movlo	r5, #0x1
 801aa20: 2500         	movhs	r5, #0x0
 801aa22: 1952         	adds	r2, r2, r5
 801aa24: f143 0300    	adc	r3, r3, #0x0
 801aa28: 4287         	cmp	r7, r0
 801aa2a: eb78 0801    	sbcs.w	r8, r8, r1
 801aa2e: bf34         	ite	lo
 801aa30: 2501         	movlo	r5, #0x1
 801aa32: 2500         	movhs	r5, #0x0
 801aa34: 1b52         	subs	r2, r2, r5
 801aa36: f1a9 0540    	sub.w	r5, r9, #0x40
 801aa3a: 9500         	str	r5, [sp]
 801aa3c: e7b8         	b	0x801a9b0 <mulShiftAll64+0xe8> @ imm = #-0x90

0801aa3e <__umul128>:
 801aa3e: b5f0         	push	{r4, r5, r6, r7, lr}
 801aa40: 460f         	mov	r7, r1
 801aa42: 4604         	mov	r4, r0
 801aa44: fba0 0102    	umull	r0, r1, r0, r2
 801aa48: fba7 5202    	umull	r5, r2, r7, r2
 801aa4c: 1949         	adds	r1, r1, r5
 801aa4e: fba3 4504    	umull	r4, r5, r3, r4
 801aa52: f142 0200    	adc	r2, r2, #0x0
 801aa56: fba7 7303    	umull	r7, r3, r7, r3
 801aa5a: 1861         	adds	r1, r4, r1
 801aa5c: f145 0400    	adc	r4, r5, #0x0
 801aa60: 19d2         	adds	r2, r2, r7
 801aa62: 9e05         	ldr	r6, [sp, #0x14]
 801aa64: f143 0300    	adc	r3, r3, #0x0
 801aa68: 1912         	adds	r2, r2, r4
 801aa6a: f143 0300    	adc	r3, r3, #0x0
 801aa6e: e9c6 2300    	strd	r2, r3, [r6]
 801aa72: bdf0         	pop	{r4, r5, r6, r7, pc}

0801aa74 <__shiftright128>:
 801aa74: b5f0         	push	{r4, r5, r6, r7, lr}
 801aa76: 9c05         	ldr	r4, [sp, #0x14]
 801aa78: f1c4 0740    	rsb.w	r7, r4, #0x40
 801aa7c: f1c4 0620    	rsb.w	r6, r4, #0x20
 801aa80: fa02 f606    	lsl.w	r6, r2, r6
 801aa84: f1a4 0520    	sub.w	r5, r4, #0x20
 801aa88: 40bb         	lsls	r3, r7
 801aa8a: fa22 f505    	lsr.w	r5, r2, r5
 801aa8e: 4333         	orrs	r3, r6
 801aa90: f1c4 0620    	rsb.w	r6, r4, #0x20
 801aa94: 432b         	orrs	r3, r5
 801aa96: fa01 f606    	lsl.w	r6, r1, r6
 801aa9a: f1a4 0520    	sub.w	r5, r4, #0x20
 801aa9e: 40e0         	lsrs	r0, r4
 801aaa0: fa21 f505    	lsr.w	r5, r1, r5
 801aaa4: 4330         	orrs	r0, r6
 801aaa6: 40ba         	lsls	r2, r7
 801aaa8: 4328         	orrs	r0, r5
 801aaaa: 40e1         	lsrs	r1, r4
 801aaac: 4310         	orrs	r0, r2
 801aaae: 4319         	orrs	r1, r3
 801aab0: bdf0         	pop	{r4, r5, r6, r7, pc}

0801aab2 <__dtox_engine>:
 801aab2: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 801aab6: 4604         	mov	r4, r0
 801aab8: 0fcd         	lsrs	r5, r1, #0x1f
 801aaba: f3c1 500a    	ubfx	r0, r1, #0x14, #0xb
 801aabe: f3c1 0113    	ubfx	r1, r1, #0x0, #0x14
 801aac2: ea54 0701    	orrs.w	r7, r4, r1
 801aac6: 7115         	strb	r5, [r2, #0x4]
 801aac8: f240 76ff    	movw	r6, #0x7ff
 801aacc: d007         	beq	0x801aade <__dtox_engine+0x2c> @ imm = #0xe
 801aace: 42b0         	cmp	r0, r6
 801aad0: d10c         	bne	0x801aaec <__dtox_engine+0x3a> @ imm = #0x18
 801aad2: f045 0508    	orr	r5, r5, #0x8
 801aad6: 7115         	strb	r5, [r2, #0x4]
 801aad8: 2000         	movs	r0, #0x0
 801aada: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 801aade: 2800         	cmp	r0, #0x0
 801aae0: d063         	beq	0x801abaa <__dtox_engine+0xf8> @ imm = #0xc6
 801aae2: 42b0         	cmp	r0, r6
 801aae4: d15e         	bne	0x801aba4 <__dtox_engine+0xf2> @ imm = #0xbc
 801aae6: f045 0504    	orr	r5, r5, #0x4
 801aaea: e7f4         	b	0x801aad6 <__dtox_engine+0x24> @ imm = #-0x18
 801aaec: 2800         	cmp	r0, #0x0
 801aaee: d159         	bne	0x801aba4 <__dtox_engine+0xf2> @ imm = #0xb2
 801aaf0: 2001         	movs	r0, #0x1
 801aaf2: f2a0 30ff    	subw	r0, r0, #0x3ff
 801aaf6: 2b00         	cmp	r3, #0x0
 801aaf8: 6010         	str	r0, [r2]
 801aafa: db59         	blt	0x801abb0 <__dtox_engine+0xfe> @ imm = #0xb2
 801aafc: 2b0c         	cmp	r3, #0xc
 801aafe: dc59         	bgt	0x801abb4 <__dtox_engine+0x102> @ imm = #0xb2
 801ab00: f1c3 050d    	rsb.w	r5, r3, #0xd
 801ab04: 00ad         	lsls	r5, r5, #0x2
 801ab06: 2001         	movs	r0, #0x1
 801ab08: f105 3cff    	add.w	r12, r5, #0xffffffff
 801ab0c: f1a5 0721    	sub.w	r7, r5, #0x21
 801ab10: f1c5 0621    	rsb.w	r6, r5, #0x21
 801ab14: fa20 f606    	lsr.w	r6, r0, r6
 801ab18: fa00 f707    	lsl.w	r7, r0, r7
 801ab1c: fa00 f00c    	lsl.w	r0, r0, r12
 801ab20: 4337         	orrs	r7, r6
 801ab22: 1806         	adds	r6, r0, r0
 801ab24: eb47 0807    	adc.w	r8, r7, r7
 801ab28: f1d6 0e00    	rsbs.w	lr, r6, #0x0
 801ab2c: eb68 0c48    	sbc.w	r12, r8, r8, lsl #1
 801ab30: 3e01         	subs	r6, #0x1
 801ab32: f148 38ff    	adc	r8, r8, #0xffffffff
 801ab36: 4026         	ands	r6, r4
 801ab38: ea08 0801    	and.w	r8, r8, r1
 801ab3c: 42b0         	cmp	r0, r6
 801ab3e: eb77 0808    	sbcs.w	r8, r7, r8
 801ab42: db0f         	blt	0x801ab64 <__dtox_engine+0xb2> @ imm = #0x1e
 801ab44: f1c5 0820    	rsb.w	r8, r5, #0x20
 801ab48: f1b5 0620    	subs.w	r6, r5, #0x20
 801ab4c: fa01 f808    	lsl.w	r8, r1, r8
 801ab50: fa24 f505    	lsr.w	r5, r4, r5
 801ab54: ea45 0508    	orr.w	r5, r5, r8
 801ab58: bf5c         	itt	pl
 801ab5a: fa41 f606    	asrpl.w	r6, r1, r6
 801ab5e: 4335         	orrpl	r5, r6
 801ab60: 07ed         	lsls	r5, r5, #0x1f
 801ab62: d503         	bpl	0x801ab6c <__dtox_engine+0xba> @ imm = #0x6
 801ab64: 1820         	adds	r0, r4, r0
 801ab66: 4604         	mov	r4, r0
 801ab68: eb41 0107    	adc.w	r1, r1, r7
 801ab6c: ea04 040e    	and.w	r4, r4, lr
 801ab70: ea01 010c    	and.w	r1, r1, r12
 801ab74: f89d 6018    	ldrb.w	r6, [sp, #0x18]
 801ab78: 3212         	adds	r2, #0x12
 801ab7a: 4618         	mov	r0, r3
 801ab7c: 250d         	movs	r5, #0xd
 801ab7e: f1c6 0627    	rsb.w	r6, r6, #0x27
 801ab82: f04f 0e30    	mov.w	lr, #0x30
 801ab86: f004 030f    	and	r3, r4, #0xf
 801ab8a: 0924         	lsrs	r4, r4, #0x4
 801ab8c: ea44 7401    	orr.w	r4, r4, r1, lsl #28
 801ab90: f105 3cff    	add.w	r12, r5, #0xffffffff
 801ab94: 1109         	asrs	r1, r1, #0x4
 801ab96: 1e57         	subs	r7, r2, #0x1
 801ab98: b9b3         	cbnz	r3, 0x801abc8 <__dtox_engine+0x116> @ imm = #0x2c
 801ab9a: 42a8         	cmp	r0, r5
 801ab9c: da0c         	bge	0x801abb8 <__dtox_engine+0x106> @ imm = #0x18
 801ab9e: 4665         	mov	r5, r12
 801aba0: 463a         	mov	r2, r7
 801aba2: e7f0         	b	0x801ab86 <__dtox_engine+0xd4> @ imm = #-0x20
 801aba4: f441 1180    	orr	r1, r1, #0x100000
 801aba8: e7a3         	b	0x801aaf2 <__dtox_engine+0x40> @ imm = #-0xba
 801abaa: 4604         	mov	r4, r0
 801abac: 4601         	mov	r1, r0
 801abae: e7a2         	b	0x801aaf6 <__dtox_engine+0x44> @ imm = #-0xbc
 801abb0: 2300         	movs	r3, #0x0
 801abb2: e7df         	b	0x801ab74 <__dtox_engine+0xc2> @ imm = #-0x42
 801abb4: 230d         	movs	r3, #0xd
 801abb6: e7dd         	b	0x801ab74 <__dtox_engine+0xc2> @ imm = #-0x46
 801abb8: f882 e000    	strb.w	lr, [r2]
 801abbc: f11c 0301    	adds.w	r3, r12, #0x1
 801abc0: 4665         	mov	r5, r12
 801abc2: 463a         	mov	r2, r7
 801abc4: d1df         	bne	0x801ab86 <__dtox_engine+0xd4> @ imm = #-0x42
 801abc6: e788         	b	0x801aada <__dtox_engine+0x28> @ imm = #-0xf0
 801abc8: 2b09         	cmp	r3, #0x9
 801abca: bfc8         	it	gt
 801abcc: 199b         	addgt	r3, r3, r6
 801abce: 3330         	adds	r3, #0x30
 801abd0: 42a8         	cmp	r0, r5
 801abd2: 7013         	strb	r3, [r2]
 801abd4: bfb8         	it	lt
 801abd6: 4628         	movlt	r0, r5
 801abd8: e7f0         	b	0x801abbc <__dtox_engine+0x10a> @ imm = #-0x20
 801abda: 0000         	movs	r0, r0

0801abdc <__aeabi_read_tp>:
; 	ldr r0, =z_arm_tls_ptr
 801abdc: 4801         	ldr	r0, [pc, #0x4]          @ 0x801abe4 <__aeabi_read_tp+0x8>
; 	ldr r0, [r0]
 801abde: 6800         	ldr	r0, [r0]
; 	bx lr
 801abe0: 4770         	bx	lr

0801abe2 <$d>:
 801abe2: 00 00        	.short	0x0000

0801abe4 <$d>:
 801abe4: 50 0b 00 20  	.word	0x20000b50
