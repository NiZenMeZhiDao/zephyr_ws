
build/zephyr/zephyr.elf:	file format elf32-littlearm

Disassembly of section rom_start:

08000000 <_vector_start>:
 8000000: f8 55 00 24  	.word	0x240055f8
 8000004: 89 63 00 08  	.word	0x08006389
 8000008: f1 55 00 08  	.word	0x080055f1
 800000c: 75 63 00 08  	.word	0x08006375
 8000010: 75 63 00 08  	.word	0x08006375
 8000014: 75 63 00 08  	.word	0x08006375
 8000018: 75 63 00 08  	.word	0x08006375
 800001c: 00 00 00 00  	.word	0x00000000
 8000020: 00 00 00 00  	.word	0x00000000
 8000024: 00 00 00 00  	.word	0x00000000
 8000028: 00 00 00 00  	.word	0x00000000
 800002c: 35 65 00 08  	.word	0x08006535
 8000030: 75 63 00 08  	.word	0x08006375
 8000034: 00 00 00 00  	.word	0x00000000
 8000038: 89 64 00 08  	.word	0x08006489
 800003c: ed 14 01 08  	.word	0x080114ed

08000040 <$d>:
 8000040: 6d 68 00 08  	.word	0x0800686d
 8000044: 6d 68 00 08  	.word	0x0800686d
 8000048: 6d 68 00 08  	.word	0x0800686d
 800004c: 6d 68 00 08  	.word	0x0800686d
 8000050: 6d 68 00 08  	.word	0x0800686d
 8000054: 6d 68 00 08  	.word	0x0800686d
 8000058: 6d 68 00 08  	.word	0x0800686d
 800005c: 6d 68 00 08  	.word	0x0800686d
 8000060: 6d 68 00 08  	.word	0x0800686d
 8000064: 6d 68 00 08  	.word	0x0800686d
 8000068: 6d 68 00 08  	.word	0x0800686d
 800006c: 6d 68 00 08  	.word	0x0800686d
 8000070: 6d 68 00 08  	.word	0x0800686d
 8000074: 6d 68 00 08  	.word	0x0800686d
 8000078: 6d 68 00 08  	.word	0x0800686d
 800007c: 6d 68 00 08  	.word	0x0800686d
 8000080: 6d 68 00 08  	.word	0x0800686d
 8000084: 6d 68 00 08  	.word	0x0800686d
 8000088: 6d 68 00 08  	.word	0x0800686d
 800008c: 6d 68 00 08  	.word	0x0800686d
 8000090: 6d 68 00 08  	.word	0x0800686d
 8000094: 6d 68 00 08  	.word	0x0800686d
 8000098: 6d 68 00 08  	.word	0x0800686d
 800009c: 6d 68 00 08  	.word	0x0800686d
 80000a0: 6d 68 00 08  	.word	0x0800686d
 80000a4: 6d 68 00 08  	.word	0x0800686d
 80000a8: 6d 68 00 08  	.word	0x0800686d
 80000ac: 6d 68 00 08  	.word	0x0800686d
 80000b0: 6d 68 00 08  	.word	0x0800686d
 80000b4: 6d 68 00 08  	.word	0x0800686d
 80000b8: 6d 68 00 08  	.word	0x0800686d
 80000bc: 6d 68 00 08  	.word	0x0800686d
 80000c0: 6d 68 00 08  	.word	0x0800686d
 80000c4: 6d 68 00 08  	.word	0x0800686d
 80000c8: 6d 68 00 08  	.word	0x0800686d
 80000cc: 6d 68 00 08  	.word	0x0800686d
 80000d0: 6d 68 00 08  	.word	0x0800686d
 80000d4: 6d 68 00 08  	.word	0x0800686d
 80000d8: 6d 68 00 08  	.word	0x0800686d
 80000dc: 6d 68 00 08  	.word	0x0800686d
 80000e0: 6d 68 00 08  	.word	0x0800686d
 80000e4: 6d 68 00 08  	.word	0x0800686d
 80000e8: 6d 68 00 08  	.word	0x0800686d
 80000ec: 6d 68 00 08  	.word	0x0800686d
 80000f0: 6d 68 00 08  	.word	0x0800686d
 80000f4: 6d 68 00 08  	.word	0x0800686d
 80000f8: 6d 68 00 08  	.word	0x0800686d
 80000fc: 6d 68 00 08  	.word	0x0800686d
 8000100: 6d 68 00 08  	.word	0x0800686d
 8000104: 6d 68 00 08  	.word	0x0800686d
 8000108: 6d 68 00 08  	.word	0x0800686d
 800010c: 6d 68 00 08  	.word	0x0800686d
 8000110: 6d 68 00 08  	.word	0x0800686d
 8000114: 6d 68 00 08  	.word	0x0800686d
 8000118: 6d 68 00 08  	.word	0x0800686d
 800011c: 6d 68 00 08  	.word	0x0800686d
 8000120: 6d 68 00 08  	.word	0x0800686d
 8000124: 6d 68 00 08  	.word	0x0800686d
 8000128: 6d 68 00 08  	.word	0x0800686d
 800012c: 6d 68 00 08  	.word	0x0800686d
 8000130: 6d 68 00 08  	.word	0x0800686d
 8000134: 6d 68 00 08  	.word	0x0800686d
 8000138: 6d 68 00 08  	.word	0x0800686d
 800013c: 6d 68 00 08  	.word	0x0800686d
 8000140: 6d 68 00 08  	.word	0x0800686d
 8000144: 6d 68 00 08  	.word	0x0800686d
 8000148: 6d 68 00 08  	.word	0x0800686d
 800014c: 6d 68 00 08  	.word	0x0800686d
 8000150: 6d 68 00 08  	.word	0x0800686d
 8000154: 6d 68 00 08  	.word	0x0800686d
 8000158: 6d 68 00 08  	.word	0x0800686d
 800015c: 6d 68 00 08  	.word	0x0800686d
 8000160: 6d 68 00 08  	.word	0x0800686d
 8000164: 6d 68 00 08  	.word	0x0800686d
 8000168: 6d 68 00 08  	.word	0x0800686d
 800016c: 6d 68 00 08  	.word	0x0800686d
 8000170: 6d 68 00 08  	.word	0x0800686d
 8000174: 6d 68 00 08  	.word	0x0800686d
 8000178: 6d 68 00 08  	.word	0x0800686d
 800017c: 6d 68 00 08  	.word	0x0800686d
 8000180: 6d 68 00 08  	.word	0x0800686d
 8000184: 6d 68 00 08  	.word	0x0800686d
 8000188: 6d 68 00 08  	.word	0x0800686d
 800018c: 6d 68 00 08  	.word	0x0800686d
 8000190: 6d 68 00 08  	.word	0x0800686d
 8000194: 6d 68 00 08  	.word	0x0800686d
 8000198: 6d 68 00 08  	.word	0x0800686d
 800019c: 6d 68 00 08  	.word	0x0800686d
 80001a0: 6d 68 00 08  	.word	0x0800686d
 80001a4: 6d 68 00 08  	.word	0x0800686d
 80001a8: 6d 68 00 08  	.word	0x0800686d
 80001ac: 6d 68 00 08  	.word	0x0800686d
 80001b0: 6d 68 00 08  	.word	0x0800686d
 80001b4: 6d 68 00 08  	.word	0x0800686d
 80001b8: 6d 68 00 08  	.word	0x0800686d
 80001bc: 6d 68 00 08  	.word	0x0800686d
 80001c0: 6d 68 00 08  	.word	0x0800686d
 80001c4: 6d 68 00 08  	.word	0x0800686d
 80001c8: 6d 68 00 08  	.word	0x0800686d
 80001cc: 6d 68 00 08  	.word	0x0800686d
 80001d0: 6d 68 00 08  	.word	0x0800686d
 80001d4: 6d 68 00 08  	.word	0x0800686d
 80001d8: 6d 68 00 08  	.word	0x0800686d
 80001dc: 6d 68 00 08  	.word	0x0800686d
 80001e0: 6d 68 00 08  	.word	0x0800686d
 80001e4: 6d 68 00 08  	.word	0x0800686d
 80001e8: 6d 68 00 08  	.word	0x0800686d
 80001ec: 6d 68 00 08  	.word	0x0800686d
 80001f0: 6d 68 00 08  	.word	0x0800686d
 80001f4: 6d 68 00 08  	.word	0x0800686d
 80001f8: 6d 68 00 08  	.word	0x0800686d
 80001fc: 6d 68 00 08  	.word	0x0800686d
 8000200: 6d 68 00 08  	.word	0x0800686d
 8000204: 6d 68 00 08  	.word	0x0800686d
 8000208: 6d 68 00 08  	.word	0x0800686d
 800020c: 6d 68 00 08  	.word	0x0800686d
 8000210: 6d 68 00 08  	.word	0x0800686d
 8000214: 6d 68 00 08  	.word	0x0800686d
 8000218: 6d 68 00 08  	.word	0x0800686d
 800021c: 6d 68 00 08  	.word	0x0800686d
 8000220: 6d 68 00 08  	.word	0x0800686d
 8000224: 6d 68 00 08  	.word	0x0800686d
 8000228: 6d 68 00 08  	.word	0x0800686d
 800022c: 6d 68 00 08  	.word	0x0800686d
 8000230: 6d 68 00 08  	.word	0x0800686d
 8000234: 6d 68 00 08  	.word	0x0800686d
 8000238: 6d 68 00 08  	.word	0x0800686d
 800023c: 6d 68 00 08  	.word	0x0800686d
 8000240: 6d 68 00 08  	.word	0x0800686d
 8000244: 6d 68 00 08  	.word	0x0800686d
 8000248: 6d 68 00 08  	.word	0x0800686d
 800024c: 6d 68 00 08  	.word	0x0800686d
 8000250: 6d 68 00 08  	.word	0x0800686d
 8000254: 6d 68 00 08  	.word	0x0800686d
 8000258: 6d 68 00 08  	.word	0x0800686d
 800025c: 6d 68 00 08  	.word	0x0800686d
 8000260: 6d 68 00 08  	.word	0x0800686d
 8000264: 6d 68 00 08  	.word	0x0800686d
 8000268: 6d 68 00 08  	.word	0x0800686d
 800026c: 6d 68 00 08  	.word	0x0800686d
 8000270: 6d 68 00 08  	.word	0x0800686d
 8000274: 6d 68 00 08  	.word	0x0800686d
 8000278: 6d 68 00 08  	.word	0x0800686d
 800027c: 6d 68 00 08  	.word	0x0800686d
 8000280: 6d 68 00 08  	.word	0x0800686d
 8000284: 6d 68 00 08  	.word	0x0800686d
 8000288: 6d 68 00 08  	.word	0x0800686d
 800028c: 6d 68 00 08  	.word	0x0800686d
 8000290: 6d 68 00 08  	.word	0x0800686d
 8000294: 6d 68 00 08  	.word	0x0800686d
 8000298: 6d 68 00 08  	.word	0x0800686d
 800029c: 6d 68 00 08  	.word	0x0800686d
 80002a0: 6d 68 00 08  	.word	0x0800686d
 80002a4: 6d 68 00 08  	.word	0x0800686d
 80002a8: 6d 68 00 08  	.word	0x0800686d
 80002ac: 6d 68 00 08  	.word	0x0800686d
 80002b0: 6d 68 00 08  	.word	0x0800686d
 80002b4: 6d 68 00 08  	.word	0x0800686d
 80002b8: 6d 68 00 08  	.word	0x0800686d
 80002bc: 6d 68 00 08  	.word	0x0800686d
 80002c0: 6d 68 00 08  	.word	0x0800686d
 80002c4: 6d 68 00 08  	.word	0x0800686d
 80002c8: 6d 68 00 08  	.word	0x0800686d

Disassembly of section text:

080002d0 <__text_region_start>:
 80002d0: b97b         	cbnz	r3, 0x80002f2 <__text_region_start+0x22> @ imm = #0x1e
 80002d2: b972         	cbnz	r2, 0x80002f2 <__text_region_start+0x22> @ imm = #0x1c
 80002d4: 2900         	cmp	r1, #0x0
 80002d6: bfbe         	ittt	lt
 80002d8: 2000         	movlt	r0, #0x0
 80002da: f04f 4100    	movlt.w	r1, #0x80000000
 80002de: e006         	blt	0x80002ee <__text_region_start+0x1e> @ imm = #0xc
 80002e0: bf08         	it	eq
 80002e2: 2800         	cmpeq	r0, #0x0
 80002e4: bf1c         	itt	ne
 80002e6: f06f 4100    	mvnne	r1, #0x80000000
 80002ea: f04f 30ff    	movne.w	r0, #0xffffffff
 80002ee: f000 b857    	b.w	0x80003a0 <__aeabi_ldiv0> @ imm = #0xae
 80002f2: f1ad 0c08    	sub.w	r12, sp, #0x8
 80002f6: e96d ce04    	strd	r12, lr, [sp, #-16]!
 80002fa: 2900         	cmp	r1, #0x0
 80002fc: db09         	blt	0x8000312 <__text_region_start+0x42> @ imm = #0x12
 80002fe: 2b00         	cmp	r3, #0x0
 8000300: db1a         	blt	0x8000338 <__text_region_start+0x68> @ imm = #0x34
 8000302: f000 f861    	bl	0x80003c8 <__udivmoddi4> @ imm = #0xc2
 8000306: f8dd e004    	ldr.w	lr, [sp, #0x4]
 800030a: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 800030e: b004         	add	sp, #0x10
 8000310: 4770         	bx	lr
 8000312: 4240         	rsbs	r0, r0, #0
 8000314: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8000318: 2b00         	cmp	r3, #0x0
 800031a: db1b         	blt	0x8000354 <__text_region_start+0x84> @ imm = #0x36
 800031c: f000 f854    	bl	0x80003c8 <__udivmoddi4> @ imm = #0xa8
 8000320: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000324: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 8000328: b004         	add	sp, #0x10
 800032a: 4240         	rsbs	r0, r0, #0
 800032c: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8000330: 4252         	rsbs	r2, r2, #0
 8000332: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 8000336: 4770         	bx	lr
 8000338: 4252         	rsbs	r2, r2, #0
 800033a: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 800033e: f000 f843    	bl	0x80003c8 <__udivmoddi4> @ imm = #0x86
 8000342: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000346: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 800034a: b004         	add	sp, #0x10
 800034c: 4240         	rsbs	r0, r0, #0
 800034e: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8000352: 4770         	bx	lr
 8000354: 4252         	rsbs	r2, r2, #0
 8000356: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 800035a: f000 f835    	bl	0x80003c8 <__udivmoddi4> @ imm = #0x6a
 800035e: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000362: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 8000366: b004         	add	sp, #0x10
 8000368: 4252         	rsbs	r2, r2, #0
 800036a: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 800036e: 4770         	bx	lr

08000370 <__aeabi_uldivmod>:
 8000370: b953         	cbnz	r3, 0x8000388 <__aeabi_uldivmod+0x18> @ imm = #0x14
 8000372: b94a         	cbnz	r2, 0x8000388 <__aeabi_uldivmod+0x18> @ imm = #0x12
 8000374: 2900         	cmp	r1, #0x0
 8000376: bf08         	it	eq
 8000378: 2800         	cmpeq	r0, #0x0
 800037a: bf1c         	itt	ne
 800037c: f04f 31ff    	movne.w	r1, #0xffffffff
 8000380: f04f 30ff    	movne.w	r0, #0xffffffff
 8000384: f000 b80c    	b.w	0x80003a0 <__aeabi_ldiv0> @ imm = #0x18
 8000388: f1ad 0c08    	sub.w	r12, sp, #0x8
 800038c: e96d ce04    	strd	r12, lr, [sp, #-16]!
 8000390: f000 f81a    	bl	0x80003c8 <__udivmoddi4> @ imm = #0x34
 8000394: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000398: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 800039c: b004         	add	sp, #0x10
 800039e: 4770         	bx	lr

080003a0 <__aeabi_ldiv0>:
 80003a0: 4770         	bx	lr
 80003a2: bf00         	nop

080003a4 <strcmp>:
 80003a4: f810 2b01    	ldrb	r2, [r0], #1
 80003a8: f811 3b01    	ldrb	r3, [r1], #1
 80003ac: 2a01         	cmp	r2, #0x1
 80003ae: bf28         	it	hs
 80003b0: 429a         	cmphs	r2, r3
 80003b2: d0f7         	beq	0x80003a4 <strcmp>      @ imm = #-0x12
 80003b4: 1ad0         	subs	r0, r2, r3
 80003b6: 4770         	bx	lr

080003b8 <strlen>:
 80003b8: 4603         	mov	r3, r0
 80003ba: f813 2b01    	ldrb	r2, [r3], #1
 80003be: 2a00         	cmp	r2, #0x0
 80003c0: d1fb         	bne	0x80003ba <strlen+0x2>  @ imm = #-0xa
 80003c2: 1a18         	subs	r0, r3, r0
 80003c4: 3801         	subs	r0, #0x1
 80003c6: 4770         	bx	lr

080003c8 <__udivmoddi4>:
 80003c8: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 80003cc: 4686         	mov	lr, r0
 80003ce: 468c         	mov	r12, r1
 80003d0: 4608         	mov	r0, r1
 80003d2: 9e08         	ldr	r6, [sp, #0x20]
 80003d4: 4615         	mov	r5, r2
 80003d6: 4674         	mov	r4, lr
 80003d8: 4619         	mov	r1, r3
 80003da: 2b00         	cmp	r3, #0x0
 80003dc: f040 80c2    	bne.w	0x8000564 <__udivmoddi4+0x19c> @ imm = #0x184
 80003e0: 4285         	cmp	r5, r0
 80003e2: fab2 f282    	clz	r2, r2
 80003e6: d945         	bls	0x8000474 <__udivmoddi4+0xac> @ imm = #0x8a
 80003e8: b14a         	cbz	r2, 0x80003fe <__udivmoddi4+0x36> @ imm = #0x12
 80003ea: f1c2 0320    	rsb.w	r3, r2, #0x20
 80003ee: fa00 fc02    	lsl.w	r12, r0, r2
 80003f2: fa2e f303    	lsr.w	r3, lr, r3
 80003f6: 4095         	lsls	r5, r2
 80003f8: ea43 0c0c    	orr.w	r12, r3, r12
 80003fc: 4094         	lsls	r4, r2
 80003fe: ea4f 4e15    	lsr.w	lr, r5, #0x10
 8000402: b2a8         	uxth	r0, r5
 8000404: fbbc f8fe    	udiv	r8, r12, lr
 8000408: 0c23         	lsrs	r3, r4, #0x10
 800040a: fb0e cc18    	mls	r12, lr, r8, r12
 800040e: fb08 f900    	mul	r9, r8, r0
 8000412: ea43 430c    	orr.w	r3, r3, r12, lsl #16
 8000416: 4599         	cmp	r9, r3
 8000418: d928         	bls	0x800046c <__udivmoddi4+0xa4> @ imm = #0x50
 800041a: 18eb         	adds	r3, r5, r3
 800041c: f108 37ff    	add.w	r7, r8, #0xffffffff
 8000420: d204         	bhs	0x800042c <__udivmoddi4+0x64> @ imm = #0x8
 8000422: 4599         	cmp	r9, r3
 8000424: d902         	bls	0x800042c <__udivmoddi4+0x64> @ imm = #0x4
 8000426: f1a8 0702    	sub.w	r7, r8, #0x2
 800042a: 442b         	add	r3, r5
 800042c: eba3 0309    	sub.w	r3, r3, r9
 8000430: b2a4         	uxth	r4, r4
 8000432: fbb3 fcfe    	udiv	r12, r3, lr
 8000436: fb0e 331c    	mls	r3, lr, r12, r3
 800043a: fb0c f000    	mul	r0, r12, r0
 800043e: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 8000442: 42a0         	cmp	r0, r4
 8000444: d914         	bls	0x8000470 <__udivmoddi4+0xa8> @ imm = #0x28
 8000446: 192c         	adds	r4, r5, r4
 8000448: f10c 33ff    	add.w	r3, r12, #0xffffffff
 800044c: d204         	bhs	0x8000458 <__udivmoddi4+0x90> @ imm = #0x8
 800044e: 42a0         	cmp	r0, r4
 8000450: d902         	bls	0x8000458 <__udivmoddi4+0x90> @ imm = #0x4
 8000452: f1ac 0302    	sub.w	r3, r12, #0x2
 8000456: 442c         	add	r4, r5
 8000458: 1a24         	subs	r4, r4, r0
 800045a: ea43 4007    	orr.w	r0, r3, r7, lsl #16
 800045e: b11e         	cbz	r6, 0x8000468 <__udivmoddi4+0xa0> @ imm = #0x6
 8000460: 40d4         	lsrs	r4, r2
 8000462: 2300         	movs	r3, #0x0
 8000464: 6034         	str	r4, [r6]
 8000466: 6073         	str	r3, [r6, #0x4]
 8000468: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}
 800046c: 4647         	mov	r7, r8
 800046e: e7dd         	b	0x800042c <__udivmoddi4+0x64> @ imm = #-0x46
 8000470: 4663         	mov	r3, r12
 8000472: e7f1         	b	0x8000458 <__udivmoddi4+0x90> @ imm = #-0x1e
 8000474: bb92         	cbnz	r2, 0x80004dc <__udivmoddi4+0x114> @ imm = #0x64
 8000476: 1b43         	subs	r3, r0, r5
 8000478: 2101         	movs	r1, #0x1
 800047a: ea4f 4e15    	lsr.w	lr, r5, #0x10
 800047e: b2af         	uxth	r7, r5
 8000480: fbb3 fcfe    	udiv	r12, r3, lr
 8000484: 0c20         	lsrs	r0, r4, #0x10
 8000486: fb0e 331c    	mls	r3, lr, r12, r3
 800048a: fb0c f807    	mul	r8, r12, r7
 800048e: ea40 4303    	orr.w	r3, r0, r3, lsl #16
 8000492: 4598         	cmp	r8, r3
 8000494: d962         	bls	0x800055c <__udivmoddi4+0x194> @ imm = #0xc4
 8000496: 18eb         	adds	r3, r5, r3
 8000498: f10c 30ff    	add.w	r0, r12, #0xffffffff
 800049c: d204         	bhs	0x80004a8 <__udivmoddi4+0xe0> @ imm = #0x8
 800049e: 4598         	cmp	r8, r3
 80004a0: d902         	bls	0x80004a8 <__udivmoddi4+0xe0> @ imm = #0x4
 80004a2: f1ac 0002    	sub.w	r0, r12, #0x2
 80004a6: 442b         	add	r3, r5
 80004a8: eba3 0308    	sub.w	r3, r3, r8
 80004ac: b2a4         	uxth	r4, r4
 80004ae: fbb3 fcfe    	udiv	r12, r3, lr
 80004b2: fb0e 331c    	mls	r3, lr, r12, r3
 80004b6: fb0c f707    	mul	r7, r12, r7
 80004ba: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 80004be: 42a7         	cmp	r7, r4
 80004c0: d94e         	bls	0x8000560 <__udivmoddi4+0x198> @ imm = #0x9c
 80004c2: 192c         	adds	r4, r5, r4
 80004c4: f10c 33ff    	add.w	r3, r12, #0xffffffff
 80004c8: d204         	bhs	0x80004d4 <__udivmoddi4+0x10c> @ imm = #0x8
 80004ca: 42a7         	cmp	r7, r4
 80004cc: d902         	bls	0x80004d4 <__udivmoddi4+0x10c> @ imm = #0x4
 80004ce: f1ac 0302    	sub.w	r3, r12, #0x2
 80004d2: 442c         	add	r4, r5
 80004d4: 1be4         	subs	r4, r4, r7
 80004d6: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 80004da: e7c0         	b	0x800045e <__udivmoddi4+0x96> @ imm = #-0x80
 80004dc: f1c2 0320    	rsb.w	r3, r2, #0x20
 80004e0: fa20 f103    	lsr.w	r1, r0, r3
 80004e4: 4095         	lsls	r5, r2
 80004e6: 4090         	lsls	r0, r2
 80004e8: fa2e f303    	lsr.w	r3, lr, r3
 80004ec: 4303         	orrs	r3, r0
 80004ee: ea4f 4e15    	lsr.w	lr, r5, #0x10
 80004f2: b2af         	uxth	r7, r5
 80004f4: fbb1 fcfe    	udiv	r12, r1, lr
 80004f8: fb0e 101c    	mls	r0, lr, r12, r1
 80004fc: 0c19         	lsrs	r1, r3, #0x10
 80004fe: fb0c f807    	mul	r8, r12, r7
 8000502: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 8000506: 4588         	cmp	r8, r1
 8000508: fa04 f402    	lsl.w	r4, r4, r2
 800050c: d922         	bls	0x8000554 <__udivmoddi4+0x18c> @ imm = #0x44
 800050e: 1869         	adds	r1, r5, r1
 8000510: f10c 30ff    	add.w	r0, r12, #0xffffffff
 8000514: d204         	bhs	0x8000520 <__udivmoddi4+0x158> @ imm = #0x8
 8000516: 4588         	cmp	r8, r1
 8000518: d902         	bls	0x8000520 <__udivmoddi4+0x158> @ imm = #0x4
 800051a: f1ac 0002    	sub.w	r0, r12, #0x2
 800051e: 4429         	add	r1, r5
 8000520: eba1 0108    	sub.w	r1, r1, r8
 8000524: b29b         	uxth	r3, r3
 8000526: fbb1 fcfe    	udiv	r12, r1, lr
 800052a: fb0e 111c    	mls	r1, lr, r12, r1
 800052e: fb0c f707    	mul	r7, r12, r7
 8000532: ea43 4301    	orr.w	r3, r3, r1, lsl #16
 8000536: 429f         	cmp	r7, r3
 8000538: d90e         	bls	0x8000558 <__udivmoddi4+0x190> @ imm = #0x1c
 800053a: 18eb         	adds	r3, r5, r3
 800053c: f10c 31ff    	add.w	r1, r12, #0xffffffff
 8000540: d204         	bhs	0x800054c <__udivmoddi4+0x184> @ imm = #0x8
 8000542: 429f         	cmp	r7, r3
 8000544: d902         	bls	0x800054c <__udivmoddi4+0x184> @ imm = #0x4
 8000546: f1ac 0102    	sub.w	r1, r12, #0x2
 800054a: 442b         	add	r3, r5
 800054c: 1bdb         	subs	r3, r3, r7
 800054e: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 8000552: e792         	b	0x800047a <__udivmoddi4+0xb2> @ imm = #-0xdc
 8000554: 4660         	mov	r0, r12
 8000556: e7e3         	b	0x8000520 <__udivmoddi4+0x158> @ imm = #-0x3a
 8000558: 4661         	mov	r1, r12
 800055a: e7f7         	b	0x800054c <__udivmoddi4+0x184> @ imm = #-0x12
 800055c: 4660         	mov	r0, r12
 800055e: e7a3         	b	0x80004a8 <__udivmoddi4+0xe0> @ imm = #-0xba
 8000560: 4663         	mov	r3, r12
 8000562: e7b7         	b	0x80004d4 <__udivmoddi4+0x10c> @ imm = #-0x92
 8000564: 4283         	cmp	r3, r0
 8000566: d906         	bls	0x8000576 <__udivmoddi4+0x1ae> @ imm = #0xc
 8000568: b916         	cbnz	r6, 0x8000570 <__udivmoddi4+0x1a8> @ imm = #0x4
 800056a: 2100         	movs	r1, #0x0
 800056c: 4608         	mov	r0, r1
 800056e: e77b         	b	0x8000468 <__udivmoddi4+0xa0> @ imm = #-0x10a
 8000570: e9c6 e000    	strd	lr, r0, [r6]
 8000574: e7f9         	b	0x800056a <__udivmoddi4+0x1a2> @ imm = #-0xe
 8000576: fab3 f783    	clz	r7, r3
 800057a: b98f         	cbnz	r7, 0x80005a0 <__udivmoddi4+0x1d8> @ imm = #0x22
 800057c: 4283         	cmp	r3, r0
 800057e: d301         	blo	0x8000584 <__udivmoddi4+0x1bc> @ imm = #0x2
 8000580: 4572         	cmp	r2, lr
 8000582: d808         	bhi	0x8000596 <__udivmoddi4+0x1ce> @ imm = #0x10
 8000584: ebbe 0402    	subs.w	r4, lr, r2
 8000588: eb60 0303    	sbc.w	r3, r0, r3
 800058c: 2001         	movs	r0, #0x1
 800058e: 469c         	mov	r12, r3
 8000590: b91e         	cbnz	r6, 0x800059a <__udivmoddi4+0x1d2> @ imm = #0x6
 8000592: 2100         	movs	r1, #0x0
 8000594: e768         	b	0x8000468 <__udivmoddi4+0xa0> @ imm = #-0x130
 8000596: 4638         	mov	r0, r7
 8000598: e7fa         	b	0x8000590 <__udivmoddi4+0x1c8> @ imm = #-0xc
 800059a: e9c6 4c00    	strd	r4, r12, [r6]
 800059e: e7f8         	b	0x8000592 <__udivmoddi4+0x1ca> @ imm = #-0x10
 80005a0: f1c7 0c20    	rsb.w	r12, r7, #0x20
 80005a4: 40bb         	lsls	r3, r7
 80005a6: fa22 f40c    	lsr.w	r4, r2, r12
 80005aa: 431c         	orrs	r4, r3
 80005ac: fa2e f10c    	lsr.w	r1, lr, r12
 80005b0: fa20 f30c    	lsr.w	r3, r0, r12
 80005b4: 40b8         	lsls	r0, r7
 80005b6: 4301         	orrs	r1, r0
 80005b8: ea4f 4914    	lsr.w	r9, r4, #0x10
 80005bc: fa0e f507    	lsl.w	r5, lr, r7
 80005c0: fbb3 f8f9    	udiv	r8, r3, r9
 80005c4: fa1f fe84    	uxth.w	lr, r4
 80005c8: fb09 3018    	mls	r0, r9, r8, r3
 80005cc: 0c0b         	lsrs	r3, r1, #0x10
 80005ce: fb08 fa0e    	mul	r10, r8, lr
 80005d2: ea43 4300    	orr.w	r3, r3, r0, lsl #16
 80005d6: 459a         	cmp	r10, r3
 80005d8: fa02 f207    	lsl.w	r2, r2, r7
 80005dc: d940         	bls	0x8000660 <__udivmoddi4+0x298> @ imm = #0x80
 80005de: 18e3         	adds	r3, r4, r3
 80005e0: f108 30ff    	add.w	r0, r8, #0xffffffff
 80005e4: d204         	bhs	0x80005f0 <__udivmoddi4+0x228> @ imm = #0x8
 80005e6: 459a         	cmp	r10, r3
 80005e8: d902         	bls	0x80005f0 <__udivmoddi4+0x228> @ imm = #0x4
 80005ea: f1a8 0002    	sub.w	r0, r8, #0x2
 80005ee: 4423         	add	r3, r4
 80005f0: eba3 030a    	sub.w	r3, r3, r10
 80005f4: b289         	uxth	r1, r1
 80005f6: fbb3 f8f9    	udiv	r8, r3, r9
 80005fa: fb09 3318    	mls	r3, r9, r8, r3
 80005fe: fb08 fe0e    	mul	lr, r8, lr
 8000602: ea41 4103    	orr.w	r1, r1, r3, lsl #16
 8000606: 458e         	cmp	lr, r1
 8000608: d92c         	bls	0x8000664 <__udivmoddi4+0x29c> @ imm = #0x58
 800060a: 1861         	adds	r1, r4, r1
 800060c: f108 33ff    	add.w	r3, r8, #0xffffffff
 8000610: d204         	bhs	0x800061c <__udivmoddi4+0x254> @ imm = #0x8
 8000612: 458e         	cmp	lr, r1
 8000614: d902         	bls	0x800061c <__udivmoddi4+0x254> @ imm = #0x4
 8000616: f1a8 0302    	sub.w	r3, r8, #0x2
 800061a: 4421         	add	r1, r4
 800061c: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 8000620: fba0 9802    	umull	r9, r8, r0, r2
 8000624: eba1 010e    	sub.w	r1, r1, lr
 8000628: 4541         	cmp	r1, r8
 800062a: 46ce         	mov	lr, r9
 800062c: 4643         	mov	r3, r8
 800062e: d302         	blo	0x8000636 <__udivmoddi4+0x26e> @ imm = #0x4
 8000630: d106         	bne	0x8000640 <__udivmoddi4+0x278> @ imm = #0xc
 8000632: 454d         	cmp	r5, r9
 8000634: d204         	bhs	0x8000640 <__udivmoddi4+0x278> @ imm = #0x8
 8000636: ebb9 0e02    	subs.w	lr, r9, r2
 800063a: eb68 0304    	sbc.w	r3, r8, r4
 800063e: 3801         	subs	r0, #0x1
 8000640: 2e00         	cmp	r6, #0x0
 8000642: d0a6         	beq	0x8000592 <__udivmoddi4+0x1ca> @ imm = #-0xb4
 8000644: ebb5 020e    	subs.w	r2, r5, lr
 8000648: eb61 0103    	sbc.w	r1, r1, r3
 800064c: fa01 fc0c    	lsl.w	r12, r1, r12
 8000650: fa22 f307    	lsr.w	r3, r2, r7
 8000654: ea4c 0303    	orr.w	r3, r12, r3
 8000658: 40f9         	lsrs	r1, r7
 800065a: e9c6 3100    	strd	r3, r1, [r6]
 800065e: e798         	b	0x8000592 <__udivmoddi4+0x1ca> @ imm = #-0xd0
 8000660: 4640         	mov	r0, r8
 8000662: e7c5         	b	0x80005f0 <__udivmoddi4+0x228> @ imm = #-0x76
 8000664: 4643         	mov	r3, r8
 8000666: e7d9         	b	0x800061c <__udivmoddi4+0x254> @ imm = #-0x4e

08000668 <sensor_ms2_to_g>:
; {
 8000668: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800066c: b090         	sub	sp, #0x40
 800066e: af00         	add	r7, sp, #0x0
 8000670: 6378         	str	r0, [r7, #0x34]
; 	int64_t micro_ms2 = ms2->val1 * 1000000LL + ms2->val2;
 8000672: 6b7b         	ldr	r3, [r7, #0x34]
 8000674: 681b         	ldr	r3, [r3]
 8000676: 17da         	asrs	r2, r3, #0x1f
 8000678: 469a         	mov	r10, r3
 800067a: 4693         	mov	r11, r2
 800067c: 4652         	mov	r2, r10
 800067e: 465b         	mov	r3, r11
 8000680: f04f 0000    	mov.w	r0, #0x0
 8000684: f04f 0100    	mov.w	r1, #0x0
 8000688: 0159         	lsls	r1, r3, #0x5
 800068a: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 800068e: 0150         	lsls	r0, r2, #0x5
 8000690: 4602         	mov	r2, r0
 8000692: 460b         	mov	r3, r1
 8000694: ebb2 040a    	subs.w	r4, r2, r10
 8000698: eb63 050b    	sbc.w	r5, r3, r11
 800069c: f04f 0200    	mov.w	r2, #0x0
 80006a0: f04f 0300    	mov.w	r3, #0x0
 80006a4: 026b         	lsls	r3, r5, #0x9
 80006a6: ea43 53d4    	orr.w	r3, r3, r4, lsr #23
 80006aa: 0262         	lsls	r2, r4, #0x9
 80006ac: 4614         	mov	r4, r2
 80006ae: 461d         	mov	r5, r3
 80006b0: eb14 080a    	adds.w	r8, r4, r10
 80006b4: eb45 090b    	adc.w	r9, r5, r11
 80006b8: f04f 0200    	mov.w	r2, #0x0
 80006bc: f04f 0300    	mov.w	r3, #0x0
 80006c0: ea4f 1389    	lsl.w	r3, r9, #0x6
 80006c4: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 80006c8: ea4f 1288    	lsl.w	r2, r8, #0x6
 80006cc: ebb2 0108    	subs.w	r1, r2, r8
 80006d0: 60b9         	str	r1, [r7, #0x8]
 80006d2: eb63 0309    	sbc.w	r3, r3, r9
 80006d6: 60fb         	str	r3, [r7, #0xc]
 80006d8: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 80006dc: 460b         	mov	r3, r1
 80006de: eb13 030a    	adds.w	r3, r3, r10
 80006e2: 62bb         	str	r3, [r7, #0x28]
 80006e4: 4613         	mov	r3, r2
 80006e6: eb43 030b    	adc.w	r3, r3, r11
 80006ea: 62fb         	str	r3, [r7, #0x2c]
 80006ec: 6b7b         	ldr	r3, [r7, #0x34]
 80006ee: 685b         	ldr	r3, [r3, #0x4]
 80006f0: 17da         	asrs	r2, r3, #0x1f
 80006f2: 623b         	str	r3, [r7, #0x20]
 80006f4: 627a         	str	r2, [r7, #0x24]
 80006f6: e9d7 450a    	ldrd	r4, r5, [r7, #40]
 80006fa: 4623         	mov	r3, r4
 80006fc: e9d7 0108    	ldrd	r0, r1, [r7, #32]
 8000700: 4602         	mov	r2, r0
 8000702: 189b         	adds	r3, r3, r2
 8000704: 603b         	str	r3, [r7]
 8000706: 460b         	mov	r3, r1
 8000708: 462a         	mov	r2, r5
 800070a: eb42 0303    	adc.w	r3, r2, r3
 800070e: 607b         	str	r3, [r7, #0x4]
 8000710: e9d7 3400    	ldrd	r3, r4, [r7]
 8000714: e9c7 340e    	strd	r3, r4, [r7, #56]
; 	if (micro_ms2 > 0) {
 8000718: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 800071c: 2a01         	cmp	r2, #0x1
 800071e: f173 0300    	sbcs	r3, r3, #0x0
 8000722: db12         	blt	0x800074a <sensor_ms2_to_g+0xe2> @ imm = #0x24
; 		return (micro_ms2 + SENSOR_G / 2) / SENSOR_G;
 8000724: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 8000728: 4915         	ldr	r1, [pc, #0x54]         @ 0x8000780 <sensor_ms2_to_g+0x118>
 800072a: 1851         	adds	r1, r2, r1
 800072c: 61b9         	str	r1, [r7, #0x18]
 800072e: f143 0300    	adc	r3, r3, #0x0
 8000732: 61fb         	str	r3, [r7, #0x1c]
 8000734: a310         	adr	r3, #64 <sensor_ms2_to_g+0xe0>
 8000736: e9d3 2300    	ldrd	r2, r3, [r3]
 800073a: e9d7 0106    	ldrd	r0, r1, [r7, #24]
 800073e: f7ff fdc7    	bl	0x80002d0 <__text_region_start> @ imm = #-0x472
 8000742: 4602         	mov	r2, r0
 8000744: 460b         	mov	r3, r1
 8000746: 4613         	mov	r3, r2
 8000748: e011         	b	0x800076e <sensor_ms2_to_g+0x106> @ imm = #0x22
; 		return (micro_ms2 - SENSOR_G / 2) / SENSOR_G;
 800074a: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 800074e: 490d         	ldr	r1, [pc, #0x34]         @ 0x8000784 <sensor_ms2_to_g+0x11c>
 8000750: 1851         	adds	r1, r2, r1
 8000752: 6139         	str	r1, [r7, #0x10]
 8000754: f143 33ff    	adc	r3, r3, #0xffffffff
 8000758: 617b         	str	r3, [r7, #0x14]
 800075a: a307         	adr	r3, #28 <sensor_ms2_to_g+0xfd>
 800075c: e9d3 2300    	ldrd	r2, r3, [r3]
 8000760: e9d7 0104    	ldrd	r0, r1, [r7, #16]
 8000764: f7ff fdb4    	bl	0x80002d0 <__text_region_start> @ imm = #-0x498
 8000768: 4602         	mov	r2, r0
 800076a: 460b         	mov	r3, r1
 800076c: 4613         	mov	r3, r2
; }
 800076e: 4618         	mov	r0, r3
 8000770: 3740         	adds	r7, #0x40
 8000772: 46bd         	mov	sp, r7
 8000774: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08000778 <$d>:
 8000778: 3a a3 95 00  	.word	0x0095a33a
 800077c: 00 00 00 00  	.word	0x00000000
 8000780: 9d d1 4a 00  	.word	0x004ad19d
 8000784: 63 2e b5 ff  	.word	0xffb52e63

08000788 <sensor_rad_to_degrees>:
; {
 8000788: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800078c: b09c         	sub	sp, #0x70
 800078e: af00         	add	r7, sp, #0x0
 8000790: 6678         	str	r0, [r7, #0x64]
; 	int64_t micro_rad_s = rad->val1 * 1000000LL + rad->val2;
 8000792: 6e7b         	ldr	r3, [r7, #0x64]
 8000794: 681b         	ldr	r3, [r3]
 8000796: 17da         	asrs	r2, r3, #0x1f
 8000798: 65bb         	str	r3, [r7, #0x58]
 800079a: 65fa         	str	r2, [r7, #0x5c]
 800079c: e9d7 2316    	ldrd	r2, r3, [r7, #88]
 80007a0: f04f 0000    	mov.w	r0, #0x0
 80007a4: f04f 0100    	mov.w	r1, #0x0
 80007a8: 0159         	lsls	r1, r3, #0x5
 80007aa: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 80007ae: 0150         	lsls	r0, r2, #0x5
 80007b0: 4602         	mov	r2, r0
 80007b2: 460b         	mov	r3, r1
 80007b4: 6db9         	ldr	r1, [r7, #0x58]
 80007b6: 1a54         	subs	r4, r2, r1
 80007b8: 6df9         	ldr	r1, [r7, #0x5c]
 80007ba: eb63 0501    	sbc.w	r5, r3, r1
 80007be: f04f 0200    	mov.w	r2, #0x0
 80007c2: f04f 0300    	mov.w	r3, #0x0
 80007c6: 026b         	lsls	r3, r5, #0x9
 80007c8: ea43 53d4    	orr.w	r3, r3, r4, lsr #23
 80007cc: 0262         	lsls	r2, r4, #0x9
 80007ce: 4614         	mov	r4, r2
 80007d0: 461d         	mov	r5, r3
 80007d2: e9d7 0116    	ldrd	r0, r1, [r7, #88]
 80007d6: 4603         	mov	r3, r0
 80007d8: eb14 0803    	adds.w	r8, r4, r3
 80007dc: e9c7 0116    	strd	r0, r1, [r7, #88]
 80007e0: 460b         	mov	r3, r1
 80007e2: eb45 0903    	adc.w	r9, r5, r3
 80007e6: f04f 0200    	mov.w	r2, #0x0
 80007ea: f04f 0300    	mov.w	r3, #0x0
 80007ee: ea4f 1389    	lsl.w	r3, r9, #0x6
 80007f2: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 80007f6: ea4f 1288    	lsl.w	r2, r8, #0x6
 80007fa: ebb2 0108    	subs.w	r1, r2, r8
 80007fe: 6339         	str	r1, [r7, #0x30]
 8000800: eb63 0309    	sbc.w	r3, r3, r9
 8000804: 637b         	str	r3, [r7, #0x34]
 8000806: e9d7 450c    	ldrd	r4, r5, [r7, #48]
 800080a: 4623         	mov	r3, r4
 800080c: e9d7 0116    	ldrd	r0, r1, [r7, #88]
 8000810: 4602         	mov	r2, r0
 8000812: 189b         	adds	r3, r3, r2
 8000814: 653b         	str	r3, [r7, #0x50]
 8000816: 460b         	mov	r3, r1
 8000818: 462a         	mov	r2, r5
 800081a: eb42 0303    	adc.w	r3, r2, r3
 800081e: 657b         	str	r3, [r7, #0x54]
 8000820: 6e7b         	ldr	r3, [r7, #0x64]
 8000822: 685b         	ldr	r3, [r3, #0x4]
 8000824: 17da         	asrs	r2, r3, #0x1f
 8000826: 64bb         	str	r3, [r7, #0x48]
 8000828: 64fa         	str	r2, [r7, #0x4c]
 800082a: e9d7 4514    	ldrd	r4, r5, [r7, #80]
 800082e: 4623         	mov	r3, r4
 8000830: e9d7 0112    	ldrd	r0, r1, [r7, #72]
 8000834: 4602         	mov	r2, r0
 8000836: 189b         	adds	r3, r3, r2
 8000838: 62bb         	str	r3, [r7, #0x28]
 800083a: 460b         	mov	r3, r1
 800083c: 462a         	mov	r2, r5
 800083e: eb42 0303    	adc.w	r3, r2, r3
 8000842: 62fb         	str	r3, [r7, #0x2c]
 8000844: e9d7 340a    	ldrd	r3, r4, [r7, #40]
 8000848: e9c7 341a    	strd	r3, r4, [r7, #104]
; 	if (micro_rad_s > 0) {
 800084c: e9d7 231a    	ldrd	r2, r3, [r7, #104]
 8000850: 2a01         	cmp	r2, #0x1
 8000852: f173 0300    	sbcs	r3, r3, #0x0
 8000856: db3f         	blt	0x80008d8 <sensor_rad_to_degrees+0x150> @ imm = #0x7e
; 		return (micro_rad_s * 180LL + SENSOR_PI / 2) / SENSOR_PI;
 8000858: e9d7 011a    	ldrd	r0, r1, [r7, #104]
 800085c: 4602         	mov	r2, r0
 800085e: 460b         	mov	r3, r1
 8000860: 1894         	adds	r4, r2, r2
 8000862: 623c         	str	r4, [r7, #0x20]
 8000864: 415b         	adcs	r3, r3
 8000866: 627b         	str	r3, [r7, #0x24]
 8000868: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 800086c: 1814         	adds	r4, r2, r0
 800086e: 61bc         	str	r4, [r7, #0x18]
 8000870: 414b         	adcs	r3, r1
 8000872: 61fb         	str	r3, [r7, #0x1c]
 8000874: f04f 0200    	mov.w	r2, #0x0
 8000878: f04f 0300    	mov.w	r3, #0x0
 800087c: e9d7 4506    	ldrd	r4, r5, [r7, #24]
 8000880: 4629         	mov	r1, r5
 8000882: 010b         	lsls	r3, r1, #0x4
 8000884: 4621         	mov	r1, r4
 8000886: ea43 7311    	orr.w	r3, r3, r1, lsr #28
 800088a: 4621         	mov	r1, r4
 800088c: 010a         	lsls	r2, r1, #0x4
 800088e: 4621         	mov	r1, r4
 8000890: 1a51         	subs	r1, r2, r1
 8000892: 6139         	str	r1, [r7, #0x10]
 8000894: 4629         	mov	r1, r5
 8000896: eb63 0301    	sbc.w	r3, r3, r1
 800089a: 617b         	str	r3, [r7, #0x14]
 800089c: f04f 0200    	mov.w	r2, #0x0
 80008a0: f04f 0300    	mov.w	r3, #0x0
 80008a4: e9d7 4504    	ldrd	r4, r5, [r7, #16]
 80008a8: 4629         	mov	r1, r5
 80008aa: 008b         	lsls	r3, r1, #0x2
 80008ac: 4621         	mov	r1, r4
 80008ae: ea43 7391    	orr.w	r3, r3, r1, lsr #30
 80008b2: 4621         	mov	r1, r4
 80008b4: 008a         	lsls	r2, r1, #0x2
 80008b6: 492a         	ldr	r1, [pc, #0xa8]         @ 0x8000960 <sensor_rad_to_degrees+0x1d8>
 80008b8: 1851         	adds	r1, r2, r1
 80008ba: 6439         	str	r1, [r7, #0x40]
 80008bc: f143 0300    	adc	r3, r3, #0x0
 80008c0: 647b         	str	r3, [r7, #0x44]
 80008c2: a325         	adr	r3, #148 <sensor_rad_to_degrees+0x163>
 80008c4: e9d3 2300    	ldrd	r2, r3, [r3]
 80008c8: e9d7 0110    	ldrd	r0, r1, [r7, #64]
 80008cc: f7ff fd00    	bl	0x80002d0 <__text_region_start> @ imm = #-0x600
 80008d0: 4602         	mov	r2, r0
 80008d2: 460b         	mov	r3, r1
 80008d4: 4613         	mov	r3, r2
 80008d6: e03a         	b	0x800094e <sensor_rad_to_degrees+0x1c6> @ imm = #0x74
; 		return (micro_rad_s * 180LL - SENSOR_PI / 2) / SENSOR_PI;
 80008d8: e9d7 011a    	ldrd	r0, r1, [r7, #104]
 80008dc: 4602         	mov	r2, r0
 80008de: 460b         	mov	r3, r1
 80008e0: 1894         	adds	r4, r2, r2
 80008e2: 60bc         	str	r4, [r7, #0x8]
 80008e4: 415b         	adcs	r3, r3
 80008e6: 60fb         	str	r3, [r7, #0xc]
 80008e8: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 80008ec: eb12 0a00    	adds.w	r10, r2, r0
 80008f0: eb43 0b01    	adc.w	r11, r3, r1
 80008f4: f04f 0200    	mov.w	r2, #0x0
 80008f8: f04f 0300    	mov.w	r3, #0x0
 80008fc: ea4f 130b    	lsl.w	r3, r11, #0x4
 8000900: ea43 731a    	orr.w	r3, r3, r10, lsr #28
 8000904: ea4f 120a    	lsl.w	r2, r10, #0x4
 8000908: ebb2 010a    	subs.w	r1, r2, r10
 800090c: 6039         	str	r1, [r7]
 800090e: eb63 030b    	sbc.w	r3, r3, r11
 8000912: 607b         	str	r3, [r7, #0x4]
 8000914: f04f 0200    	mov.w	r2, #0x0
 8000918: f04f 0300    	mov.w	r3, #0x0
 800091c: e9d7 4500    	ldrd	r4, r5, [r7]
 8000920: 4629         	mov	r1, r5
 8000922: 008b         	lsls	r3, r1, #0x2
 8000924: 4621         	mov	r1, r4
 8000926: ea43 7391    	orr.w	r3, r3, r1, lsr #30
 800092a: 4621         	mov	r1, r4
 800092c: 008a         	lsls	r2, r1, #0x2
 800092e: 490d         	ldr	r1, [pc, #0x34]         @ 0x8000964 <sensor_rad_to_degrees+0x1dc>
 8000930: 1851         	adds	r1, r2, r1
 8000932: 63b9         	str	r1, [r7, #0x38]
 8000934: f143 33ff    	adc	r3, r3, #0xffffffff
 8000938: 63fb         	str	r3, [r7, #0x3c]
 800093a: a307         	adr	r3, #28 <sensor_rad_to_degrees+0x1bd>
 800093c: e9d3 2300    	ldrd	r2, r3, [r3]
 8000940: e9d7 010e    	ldrd	r0, r1, [r7, #56]
 8000944: f7ff fcc4    	bl	0x80002d0 <__text_region_start> @ imm = #-0x678
 8000948: 4602         	mov	r2, r0
 800094a: 460b         	mov	r3, r1
 800094c: 4613         	mov	r3, r2
; }
 800094e: 4618         	mov	r0, r3
 8000950: 3770         	adds	r7, #0x70
 8000952: 46bd         	mov	sp, r7
 8000954: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08000958 <$d>:
 8000958: d8 ef 2f 00  	.word	0x002fefd8
 800095c: 00 00 00 00  	.word	0x00000000
 8000960: ec f7 17 00  	.word	0x0017f7ec
 8000964: 14 08 e8 ff  	.word	0xffe80814

08000968 <chassis_main_thread>:
; {
 8000968: b580         	push	{r7, lr}
 800096a: b08c         	sub	sp, #0x30
 800096c: af02         	add	r7, sp, #0x8
 800096e: 60f8         	str	r0, [r7, #0xc]
 8000970: 60b9         	str	r1, [r7, #0x8]
 8000972: 607a         	str	r2, [r7, #0x4]
; 	struct pos_data pos = {0};
 8000974: f107 0314    	add.w	r3, r7, #0x14
 8000978: 2200         	movs	r2, #0x0
 800097a: 601a         	str	r2, [r3]
 800097c: 605a         	str	r2, [r3, #0x4]
 800097e: 609a         	str	r2, [r3, #0x8]
; 	for (int i = 0; i < 3; i++) {
 8000980: 2300         	movs	r3, #0x0
 8000982: 627b         	str	r3, [r7, #0x24]
 8000984: e010         	b	0x80009a8 <chassis_main_thread+0x40> @ imm = #0x20
; 		pid_reg_input(steerwheel_pid, &(chassis_data.targetYaw), &(pos.Yaw));
 8000986: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80009ec <chassis_main_thread+0x84>
 8000988: 681b         	ldr	r3, [r3]
 800098a: f107 0214    	add.w	r2, r7, #0x14
 800098e: 4918         	ldr	r1, [pc, #0x60]         @ 0x80009f0 <chassis_main_thread+0x88>
 8000990: 4618         	mov	r0, r3
 8000992: f01a fab0    	bl	0x801aef6 <pid_reg_input> @ imm = #0x1a560
; 		pid_reg_output(steerwheel_pid, &(chassis_data.targetYSpeed));
 8000996: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80009ec <chassis_main_thread+0x84>
 8000998: 681b         	ldr	r3, [r3]
 800099a: 4916         	ldr	r1, [pc, #0x58]         @ 0x80009f4 <chassis_main_thread+0x8c>
 800099c: 4618         	mov	r0, r3
 800099e: f01a fab9    	bl	0x801af14 <pid_reg_output> @ imm = #0x1a572
; 	for (int i = 0; i < 3; i++) {
 80009a2: 6a7b         	ldr	r3, [r7, #0x24]
 80009a4: 3301         	adds	r3, #0x1
 80009a6: 627b         	str	r3, [r7, #0x24]
 80009a8: 6a7b         	ldr	r3, [r7, #0x24]
 80009aa: 2b02         	cmp	r3, #0x2
 80009ac: ddeb         	ble	0x8000986 <chassis_main_thread+0x1e> @ imm = #-0x2a
; 	while (!zbus_sub_wait_msg(&chassis_sensor_msg_suscriber, &chan, &pos, K_FOREVER)) {
 80009ae: e008         	b	0x80009c2 <chassis_main_thread+0x5a> @ imm = #0x10
; 		if (&pos_chan != chan) {
 80009b0: 6a3b         	ldr	r3, [r7, #0x20]
 80009b2: 4a11         	ldr	r2, [pc, #0x44]         @ 0x80009f8 <chassis_main_thread+0x90>
 80009b4: 4293         	cmp	r3, r2
 80009b6: d103         	bne	0x80009c0 <chassis_main_thread+0x58> @ imm = #0x6
; 		chassis_calc(&chassis_data);
 80009b8: 480d         	ldr	r0, [pc, #0x34]         @ 0x80009f0 <chassis_main_thread+0x88>
 80009ba: f000 f83d    	bl	0x8000a38 <chassis_calc> @ imm = #0x7a
 80009be: e000         	b	0x80009c2 <chassis_main_thread+0x5a> @ imm = #0x0
; 			continue;
 80009c0: bf00         	nop
; 	while (!zbus_sub_wait_msg(&chassis_sensor_msg_suscriber, &chan, &pos, K_FOREVER)) {
 80009c2: f04f 32ff    	mov.w	r2, #0xffffffff
 80009c6: f04f 33ff    	mov.w	r3, #0xffffffff
 80009ca: f107 0014    	add.w	r0, r7, #0x14
 80009ce: f107 0120    	add.w	r1, r7, #0x20
 80009d2: e9cd 2300    	strd	r2, r3, [sp]
 80009d6: 4602         	mov	r2, r0
 80009d8: 4808         	ldr	r0, [pc, #0x20]         @ 0x80009fc <chassis_main_thread+0x94>
 80009da: f01d fb28    	bl	0x801e02e <zbus_sub_wait_msg> @ imm = #0x1d650
 80009de: 4603         	mov	r3, r0
 80009e0: 2b00         	cmp	r3, #0x0
 80009e2: d0e5         	beq	0x80009b0 <chassis_main_thread+0x48> @ imm = #-0x36
; }
 80009e4: bf00         	nop
 80009e6: 3728         	adds	r7, #0x28
 80009e8: 46bd         	mov	sp, r7
 80009ea: bd80         	pop	{r7, pc}

080009ec <$d>:
 80009ec: 88 05 00 24  	.word	0x24000588
 80009f0: 54 25 00 24  	.word	0x24002554
 80009f4: dc 25 00 24  	.word	0x240025dc
 80009f8: 60 a2 02 08  	.word	0x0802a260
 80009fc: 74 a2 02 08  	.word	0x0802a274

08000a00 <chassis_set>:
; {
 8000a00: b480         	push	{r7}
 8000a02: b085         	sub	sp, #0x14
 8000a04: af00         	add	r7, sp, #0x0
 8000a06: ed87 0a03    	<unknown>
 8000a0a: edc7 0a02    	<unknown>
 8000a0e: ed87 1a01    	<unknown>
; 	chassis_data.targetXSpeed = speedX;
 8000a12: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8000a34 <chassis_set+0x34>
 8000a14: 68fb         	ldr	r3, [r7, #0xc]
 8000a16: f8c2 3084    	str.w	r3, [r2, #0x84]
; 	chassis_data.targetYSpeed = speedY;
 8000a1a: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8000a34 <chassis_set+0x34>
 8000a1c: 68bb         	ldr	r3, [r7, #0x8]
 8000a1e: f8c2 3088    	str.w	r3, [r2, #0x88]
; 	chassis_data.targetYaw = angle;
 8000a22: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8000a34 <chassis_set+0x34>
 8000a24: 687b         	ldr	r3, [r7, #0x4]
 8000a26: 6013         	str	r3, [r2]
; }
 8000a28: bf00         	nop
 8000a2a: 3714         	adds	r7, #0x14
 8000a2c: 46bd         	mov	sp, r7
 8000a2e: f85d 7b04    	ldr	r7, [sp], #4
 8000a32: 4770         	bx	lr

08000a34 <$d>:
 8000a34: 54 25 00 24  	.word	0x24002554

08000a38 <chassis_calc>:
; {
 8000a38: b580         	push	{r7, lr}
 8000a3a: b0a2         	sub	sp, #0x88
 8000a3c: af00         	add	r7, sp, #0x0
 8000a3e: 6078         	str	r0, [r7, #0x4]
; 	pid_calc(steerwheel_pid);
 8000a40: 4b7b         	ldr	r3, [pc, #0x1ec]        @ 0x8000c30 <chassis_calc+0x1f8>
 8000a42: 681b         	ldr	r3, [r3]
 8000a44: 4618         	mov	r0, r3
 8000a46: f01a fa4b    	bl	0x801aee0 <pid_calc>    @ imm = #0x1a496
; 	arm_sin_cos_f32(chassis->currentYaw, &sin_theta, &cos_theta);
 8000a4a: 687b         	ldr	r3, [r7, #0x4]
 8000a4c: edd3 7a01    	<unknown>
 8000a50: f107 0258    	add.w	r2, r7, #0x58
 8000a54: f107 035c    	add.w	r3, r7, #0x5c
 8000a58: 4611         	mov	r1, r2
 8000a5a: 4618         	mov	r0, r3
 8000a5c: eeb0 0a67    	<unknown>
 8000a60: f012 fa90    	bl	0x8012f84 <arm_sin_cos_f32> @ imm = #0x12520
; 	RollMatrix[0] = cos_theta;  //	RollMatrix =
 8000a64: 6dbb         	ldr	r3, [r7, #0x58]
 8000a66: 66bb         	str	r3, [r7, #0x68]
; 	RollMatrix[1] = -sin_theta; //	cos_theta	-sin_theta
 8000a68: edd7 7a17    	<unknown>
 8000a6c: eef1 7a67    	<unknown>
 8000a70: edc7 7a1b    	<unknown>
; 	RollMatrix[2] = sin_theta;  //	sin_theta	 cos_theta
 8000a74: 6dfb         	ldr	r3, [r7, #0x5c]
 8000a76: 673b         	str	r3, [r7, #0x70]
; 	RollMatrix[3] = cos_theta;  //
 8000a78: 6dbb         	ldr	r3, [r7, #0x58]
 8000a7a: 677b         	str	r3, [r7, #0x74]
; 	arm_mat_init_f32(&RollMatrixInstance, 2, 2, RollMatrix);
 8000a7c: f107 0368    	add.w	r3, r7, #0x68
 8000a80: f107 0060    	add.w	r0, r7, #0x60
 8000a84: 2202         	movs	r2, #0x2
 8000a86: 2102         	movs	r1, #0x2
 8000a88: f012 fc94    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x12928
; 	arm_mat_init_f32(&posOffsetMatrixInstance, 2, STEERWHEEL_COUNT, chassis->posOffsetMatrix);
 8000a8c: 687b         	ldr	r3, [r7, #0x4]
 8000a8e: f8d3 308c    	ldr.w	r3, [r3, #0x8c]
 8000a92: f107 0050    	add.w	r0, r7, #0x50
 8000a96: 2203         	movs	r2, #0x3
 8000a98: 2102         	movs	r1, #0x2
 8000a9a: f012 fc8b    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x12916
; 	arm_mat_init_f32(&posOffsetRolledMatrixInstance, 2, STEERWHEEL_COUNT, result);
 8000a9e: f107 0338    	add.w	r3, r7, #0x38
 8000aa2: f107 0030    	add.w	r0, r7, #0x30
 8000aa6: 2203         	movs	r2, #0x3
 8000aa8: 2102         	movs	r1, #0x2
 8000aaa: f012 fc83    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x12906
; 	arm_mat_mult_f32(&RollMatrixInstance, &posOffsetMatrixInstance,
 8000aae: f107 0230    	add.w	r2, r7, #0x30
 8000ab2: f107 0150    	add.w	r1, r7, #0x50
 8000ab6: f107 0360    	add.w	r3, r7, #0x60
 8000aba: 4618         	mov	r0, r3
 8000abc: f012 fdf8    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #0x12bf0
; 		chassis->targetRollSpeed,
 8000ac0: 687b         	ldr	r3, [r7, #0x4]
 8000ac2: f8d3 3080    	ldr.w	r3, [r3, #0x80]
; 	float speedMatrix[4] = {
 8000ac6: 623b         	str	r3, [r7, #0x20]
 8000ac8: f04f 0300    	mov.w	r3, #0x0
 8000acc: 627b         	str	r3, [r7, #0x24]
 8000ace: f04f 0300    	mov.w	r3, #0x0
 8000ad2: 62bb         	str	r3, [r7, #0x28]
; 		-chassis->targetRollSpeed,
 8000ad4: 687b         	ldr	r3, [r7, #0x4]
 8000ad6: edd3 7a20    	<unknown>
 8000ada: eef1 7a67    	<unknown>
; 	float speedMatrix[4] = {
 8000ade: edc7 7a0b    	<unknown>
; 	arm_mat_init_f32(&speedMatrixInstance, 2, 2, speedMatrix);
 8000ae2: f107 0320    	add.w	r3, r7, #0x20
 8000ae6: f107 0018    	add.w	r0, r7, #0x18
 8000aea: 2202         	movs	r2, #0x2
 8000aec: 2102         	movs	r1, #0x2
 8000aee: f012 fc61    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x128c2
; 	arm_mat_init_f32(&rollSpeedMatrixInstance, 2, STEERWHEEL_COUNT, result);
 8000af2: f107 0338    	add.w	r3, r7, #0x38
 8000af6: f107 0010    	add.w	r0, r7, #0x10
 8000afa: 2203         	movs	r2, #0x3
 8000afc: 2102         	movs	r1, #0x2
 8000afe: f012 fc59    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x128b2
; 	arm_mat_mult_f32(&posOffsetRolledMatrixInstance, &speedMatrixInstance,
 8000b02: f107 0210    	add.w	r2, r7, #0x10
 8000b06: f107 0118    	add.w	r1, r7, #0x18
 8000b0a: f107 0330    	add.w	r3, r7, #0x30
 8000b0e: 4618         	mov	r0, r3
 8000b10: f012 fdce    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #0x12b9c
; 	for (int i = 0; i < STEERWHEEL_COUNT; i++) {
 8000b14: 2300         	movs	r3, #0x0
 8000b16: f8c7 3084    	str.w	r3, [r7, #0x84]
 8000b1a: e067         	b	0x8000bec <chassis_calc+0x1b4> @ imm = #0xce
; 		speed[0] = result[i * 2 + 1] + chassis->targetXSpeed;
 8000b1c: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8000b20: 005b         	lsls	r3, r3, #0x1
 8000b22: 3301         	adds	r3, #0x1
 8000b24: 009b         	lsls	r3, r3, #0x2
 8000b26: 3388         	adds	r3, #0x88
 8000b28: 443b         	add	r3, r7
 8000b2a: 3b50         	subs	r3, #0x50
 8000b2c: ed93 7a00    	<unknown>
 8000b30: 687b         	ldr	r3, [r7, #0x4]
 8000b32: edd3 7a21    	<unknown>
 8000b36: ee77 7a27    	<unknown>
 8000b3a: edc7 7a02    	<unknown>
; 		speed[1] = result[i * 2 + 0] + chassis->targetYSpeed;
 8000b3e: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8000b42: 005b         	lsls	r3, r3, #0x1
 8000b44: 009b         	lsls	r3, r3, #0x2
 8000b46: 3388         	adds	r3, #0x88
 8000b48: 443b         	add	r3, r7
 8000b4a: 3b50         	subs	r3, #0x50
 8000b4c: ed93 7a00    	<unknown>
 8000b50: 687b         	ldr	r3, [r7, #0x4]
 8000b52: edd3 7a22    	<unknown>
 8000b56: ee77 7a27    	<unknown>
 8000b5a: edc7 7a03    	<unknown>
; 		arm_sqrt_f32(speed[0] * speed[0] + speed[1] * speed[1],
 8000b5e: ed97 7a02    	<unknown>
 8000b62: edd7 7a02    	<unknown>
 8000b66: ee27 7a27    	<unknown>
 8000b6a: edd7 6a03    	<unknown>
 8000b6e: edd7 7a03    	<unknown>
 8000b72: ee66 7aa7    	<unknown>
 8000b76: ee77 7a27    	<unknown>
; 			     &chassis_data.steerwheel[i].speed);
 8000b7a: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8000b7e: 4613         	mov	r3, r2
 8000b80: 009b         	lsls	r3, r3, #0x2
 8000b82: 4413         	add	r3, r2
 8000b84: 00db         	lsls	r3, r3, #0x3
 8000b86: 3310         	adds	r3, #0x10
 8000b88: 4a2a         	ldr	r2, [pc, #0xa8]         @ 0x8000c34 <chassis_calc+0x1fc>
 8000b8a: 4413         	add	r3, r2
 8000b8c: edc7 7a1f    	<unknown>
 8000b90: 67bb         	str	r3, [r7, #0x78]
;     if (in >= 0.0f)
 8000b92: edd7 7a1f    	<unknown>
 8000b96: eef5 7ac0    	<unknown>
 8000b9a: eef1 fa10    	<unknown>
 8000b9e: db07         	blt	0x8000bb0 <chassis_calc+0x178> @ imm = #0xe
;       __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
 8000ba0: edd7 7a1f    	<unknown>
 8000ba4: eef1 7ae7    	<unknown>
 8000ba8: 6fbb         	ldr	r3, [r7, #0x78]
 8000baa: edc3 7a00    	<unknown>
;       return (ARM_MATH_SUCCESS);
 8000bae: e004         	b	0x8000bba <chassis_calc+0x182> @ imm = #0x8
;       *pOut = 0.0f;
 8000bb0: 6fbb         	ldr	r3, [r7, #0x78]
 8000bb2: f04f 0200    	mov.w	r2, #0x0
 8000bb6: 601a         	str	r2, [r3]
;       return (ARM_MATH_ARGUMENT_ERROR);
 8000bb8: bf00         	nop
; 		arm_atan2_f32(speed[1], speed[0], &chassis_data.steerwheel[i].angle);
 8000bba: edd7 7a03    	<unknown>
 8000bbe: ed97 7a02    	<unknown>
 8000bc2: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8000bc6: 4613         	mov	r3, r2
 8000bc8: 009b         	lsls	r3, r3, #0x2
 8000bca: 4413         	add	r3, r2
 8000bcc: 00db         	lsls	r3, r3, #0x3
 8000bce: 3308         	adds	r3, #0x8
 8000bd0: 4a18         	ldr	r2, [pc, #0x60]         @ 0x8000c34 <chassis_calc+0x1fc>
 8000bd2: 4413         	add	r3, r2
 8000bd4: 4618         	mov	r0, r3
 8000bd6: eef0 0a47    	<unknown>
 8000bda: eeb0 0a67    	<unknown>
 8000bde: f012 fa4f    	bl	0x8013080 <arm_atan2_f32> @ imm = #0x1249e
; 	for (int i = 0; i < STEERWHEEL_COUNT; i++) {
 8000be2: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8000be6: 3301         	adds	r3, #0x1
 8000be8: f8c7 3084    	str.w	r3, [r7, #0x84]
 8000bec: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8000bf0: 2b02         	cmp	r3, #0x2
 8000bf2: dd93         	ble	0x8000b1c <chassis_calc+0xe4> @ imm = #-0xda
; 	for (int i = 0; i < 3; i++) {
 8000bf4: 2300         	movs	r3, #0x0
 8000bf6: f8c7 3080    	str.w	r3, [r7, #0x80]
 8000bfa: e010         	b	0x8000c1e <chassis_calc+0x1e6> @ imm = #0x20
; 		steerwheel_calc(&chassis->steerwheel[i]);
 8000bfc: f8d7 2080    	ldr.w	r2, [r7, #0x80]
 8000c00: 4613         	mov	r3, r2
 8000c02: 009b         	lsls	r3, r3, #0x2
 8000c04: 4413         	add	r3, r2
 8000c06: 00db         	lsls	r3, r3, #0x3
 8000c08: 3308         	adds	r3, #0x8
 8000c0a: 687a         	ldr	r2, [r7, #0x4]
 8000c0c: 4413         	add	r3, r2
 8000c0e: 4618         	mov	r0, r3
 8000c10: f002 fea4    	bl	0x800395c <steerwheel_calc> @ imm = #0x2d48
; 	for (int i = 0; i < 3; i++) {
 8000c14: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000c18: 3301         	adds	r3, #0x1
 8000c1a: f8c7 3080    	str.w	r3, [r7, #0x80]
 8000c1e: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000c22: 2b02         	cmp	r3, #0x2
 8000c24: ddea         	ble	0x8000bfc <chassis_calc+0x1c4> @ imm = #-0x2c
; }
 8000c26: bf00         	nop
 8000c28: bf00         	nop
 8000c2a: 3788         	adds	r7, #0x88
 8000c2c: 46bd         	mov	sp, r7
 8000c2e: bd80         	pop	{r7, pc}

08000c30 <$d>:
 8000c30: 88 05 00 24  	.word	0x24000588
 8000c34: 54 25 00 24  	.word	0x24002554

08000c38 <pwr_init>:
; {
 8000c38: b580         	push	{r7, lr}
 8000c3a: af00         	add	r7, sp, #0x0
; 	gpio_pin_configure_dt(&pwr1, GPIO_OUTPUT_HIGH);
 8000c3c: f44f 2120    	mov.w	r1, #0xa0000
 8000c40: 4804         	ldr	r0, [pc, #0x10]         @ 0x8000c54 <pwr_init+0x1c>
 8000c42: f01a fa65    	bl	0x801b110 <gpio_pin_configure_dt> @ imm = #0x1a4ca
; 	gpio_pin_configure_dt(&pwr2, GPIO_OUTPUT_HIGH);
 8000c46: f44f 2120    	mov.w	r1, #0xa0000
 8000c4a: 4803         	ldr	r0, [pc, #0xc]          @ 0x8000c58 <pwr_init+0x20>
 8000c4c: f01a fa60    	bl	0x801b110 <gpio_pin_configure_dt> @ imm = #0x1a4c0
; }
 8000c50: bf00         	nop
 8000c52: bd80         	pop	{r7, pc}

08000c54 <$d>:
 8000c54: 08 cd 02 08  	.word	0x0802cd08
 8000c58: 10 cd 02 08  	.word	0x0802cd10

08000c5c <board_init>:
; {
 8000c5c: b580         	push	{r7, lr}
 8000c5e: af00         	add	r7, sp, #0x0
; 	PWR_INIT
 8000c60: f7ff ffea    	bl	0x8000c38 <pwr_init>    @ imm = #-0x2c
; 	printk("Board init done");
 8000c64: 4802         	ldr	r0, [pc, #0x8]          @ 0x8000c70 <board_init+0x14>
 8000c66: f01b fc98    	bl	0x801c59a <printk>      @ imm = #0x1b930
; }
 8000c6a: bf00         	nop
 8000c6c: bd80         	pop	{r7, pc}
 8000c6e: bf00         	nop

08000c70 <$d>:
 8000c70: bc a2 02 08  	.word	0x0802a2bc

08000c74 <sensor_value_to_float>:
; {
 8000c74: b480         	push	{r7}
 8000c76: b083         	sub	sp, #0xc
 8000c78: af00         	add	r7, sp, #0x0
 8000c7a: 6078         	str	r0, [r7, #0x4]
; 	return (float)val->val1 + (float)val->val2 / 1000000;
 8000c7c: 687b         	ldr	r3, [r7, #0x4]
 8000c7e: 681b         	ldr	r3, [r3]
 8000c80: ee07 3a90    	<unknown>
 8000c84: eeb8 7ae7    	<unknown>
 8000c88: 687b         	ldr	r3, [r7, #0x4]
 8000c8a: 685b         	ldr	r3, [r3, #0x4]
 8000c8c: ee07 3a90    	<unknown>
 8000c90: eef8 6ae7    	<unknown>
 8000c94: ed9f 6a06    	<unknown>
 8000c98: eec6 7a86    	<unknown>
 8000c9c: ee77 7a27    	<unknown>
; }
 8000ca0: eeb0 0a67    	<unknown>
 8000ca4: 370c         	adds	r7, #0xc
 8000ca6: 46bd         	mov	sp, r7
 8000ca8: f85d 7b04    	ldr	r7, [sp], #4
 8000cac: 4770         	bx	lr
 8000cae: bf00         	nop

08000cb0 <$d>:
 8000cb0: 00 24 74 49  	.word	0x49742400

08000cb4 <Kalman_Filter_Init>:
; {
 8000cb4: b580         	push	{r7, lr}
 8000cb6: b082         	sub	sp, #0x8
 8000cb8: af00         	add	r7, sp, #0x0
 8000cba: 6078         	str	r0, [r7, #0x4]
 8000cbc: 4608         	mov	r0, r1
 8000cbe: 4611         	mov	r1, r2
 8000cc0: 461a         	mov	r2, r3
 8000cc2: 4603         	mov	r3, r0
 8000cc4: 70fb         	strb	r3, [r7, #0x3]
 8000cc6: 460b         	mov	r3, r1
 8000cc8: 70bb         	strb	r3, [r7, #0x2]
 8000cca: 4613         	mov	r3, r2
 8000ccc: 707b         	strb	r3, [r7, #0x1]
; 	sizeof_float = sizeof(float);
 8000cce: 4bba         	ldr	r3, [pc, #0x2e8]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000cd0: 2204         	movs	r2, #0x4
 8000cd2: 801a         	strh	r2, [r3]
; 	sizeof_double = sizeof(double);
 8000cd4: 4bb9         	ldr	r3, [pc, #0x2e4]        @ 0x8000fbc <Kalman_Filter_Init+0x308>
 8000cd6: 2208         	movs	r2, #0x8
 8000cd8: 801a         	strh	r2, [r3]
; 	kf->xhatSize = xhatSize;
 8000cda: 687b         	ldr	r3, [r7, #0x4]
 8000cdc: 78fa         	ldrb	r2, [r7, #0x3]
 8000cde: 731a         	strb	r2, [r3, #0xc]
; 	kf->uSize = uSize;
 8000ce0: 687b         	ldr	r3, [r7, #0x4]
 8000ce2: 78ba         	ldrb	r2, [r7, #0x2]
 8000ce4: 735a         	strb	r2, [r3, #0xd]
; 	kf->zSize = zSize;
 8000ce6: 687b         	ldr	r3, [r7, #0x4]
 8000ce8: 787a         	ldrb	r2, [r7, #0x1]
 8000cea: 739a         	strb	r2, [r3, #0xe]
; 	kf->MeasurementValidNum = 0;
 8000cec: 687b         	ldr	r3, [r7, #0x4]
 8000cee: 2200         	movs	r2, #0x0
 8000cf0: 741a         	strb	r2, [r3, #0x10]
; 	kf->MeasurementMap = (uint8_t *)user_malloc(sizeof(uint8_t) * zSize);
 8000cf2: 787b         	ldrb	r3, [r7, #0x1]
 8000cf4: 4618         	mov	r0, r3
 8000cf6: f005 fe41    	bl	0x800697c <malloc>      @ imm = #0x5c82
 8000cfa: 4603         	mov	r3, r0
 8000cfc: 461a         	mov	r2, r3
 8000cfe: 687b         	ldr	r3, [r7, #0x4]
 8000d00: 615a         	str	r2, [r3, #0x14]
; 	memset(kf->MeasurementMap, 0, sizeof(uint8_t) * zSize);
 8000d02: 687b         	ldr	r3, [r7, #0x4]
 8000d04: 695b         	ldr	r3, [r3, #0x14]
 8000d06: 787a         	ldrb	r2, [r7, #0x1]
 8000d08: 2100         	movs	r1, #0x0
 8000d0a: 4618         	mov	r0, r3
 8000d0c: f028 fa00    	bl	0x8029110 <memset>      @ imm = #0x28400
; 	kf->MeasurementDegree = (float *)user_malloc(sizeof_float * zSize);
 8000d10: 4ba9         	ldr	r3, [pc, #0x2a4]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000d12: 881b         	ldrh	r3, [r3]
 8000d14: 461a         	mov	r2, r3
 8000d16: 787b         	ldrb	r3, [r7, #0x1]
 8000d18: fb02 f303    	mul	r3, r2, r3
 8000d1c: 4618         	mov	r0, r3
 8000d1e: f005 fe2d    	bl	0x800697c <malloc>      @ imm = #0x5c5a
 8000d22: 4603         	mov	r3, r0
 8000d24: 461a         	mov	r2, r3
 8000d26: 687b         	ldr	r3, [r7, #0x4]
 8000d28: 619a         	str	r2, [r3, #0x18]
; 	memset(kf->MeasurementDegree, 0, sizeof_float * zSize);
 8000d2a: 687b         	ldr	r3, [r7, #0x4]
 8000d2c: 6998         	ldr	r0, [r3, #0x18]
 8000d2e: 4ba2         	ldr	r3, [pc, #0x288]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000d30: 881b         	ldrh	r3, [r3]
 8000d32: 461a         	mov	r2, r3
 8000d34: 787b         	ldrb	r3, [r7, #0x1]
 8000d36: fb02 f303    	mul	r3, r2, r3
 8000d3a: 461a         	mov	r2, r3
 8000d3c: 2100         	movs	r1, #0x0
 8000d3e: f028 f9e7    	bl	0x8029110 <memset>      @ imm = #0x283ce
; 	kf->MatR_DiagonalElements = (float *)user_malloc(sizeof_float * zSize);
 8000d42: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000d44: 881b         	ldrh	r3, [r3]
 8000d46: 461a         	mov	r2, r3
 8000d48: 787b         	ldrb	r3, [r7, #0x1]
 8000d4a: fb02 f303    	mul	r3, r2, r3
 8000d4e: 4618         	mov	r0, r3
 8000d50: f005 fe14    	bl	0x800697c <malloc>      @ imm = #0x5c28
 8000d54: 4603         	mov	r3, r0
 8000d56: 461a         	mov	r2, r3
 8000d58: 687b         	ldr	r3, [r7, #0x4]
 8000d5a: 61da         	str	r2, [r3, #0x1c]
; 	memset(kf->MatR_DiagonalElements, 0, sizeof_float * zSize);
 8000d5c: 687b         	ldr	r3, [r7, #0x4]
 8000d5e: 69d8         	ldr	r0, [r3, #0x1c]
 8000d60: 4b95         	ldr	r3, [pc, #0x254]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000d62: 881b         	ldrh	r3, [r3]
 8000d64: 461a         	mov	r2, r3
 8000d66: 787b         	ldrb	r3, [r7, #0x1]
 8000d68: fb02 f303    	mul	r3, r2, r3
 8000d6c: 461a         	mov	r2, r3
 8000d6e: 2100         	movs	r1, #0x0
 8000d70: f028 f9ce    	bl	0x8029110 <memset>      @ imm = #0x2839c
; 	kf->StateMinVariance = (float *)user_malloc(sizeof_float * xhatSize);
 8000d74: 4b90         	ldr	r3, [pc, #0x240]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000d76: 881b         	ldrh	r3, [r3]
 8000d78: 461a         	mov	r2, r3
 8000d7a: 78fb         	ldrb	r3, [r7, #0x3]
 8000d7c: fb02 f303    	mul	r3, r2, r3
 8000d80: 4618         	mov	r0, r3
 8000d82: f005 fdfb    	bl	0x800697c <malloc>      @ imm = #0x5bf6
 8000d86: 4603         	mov	r3, r0
 8000d88: 461a         	mov	r2, r3
 8000d8a: 687b         	ldr	r3, [r7, #0x4]
 8000d8c: 621a         	str	r2, [r3, #0x20]
; 	memset(kf->StateMinVariance, 0, sizeof_float * xhatSize);
 8000d8e: 687b         	ldr	r3, [r7, #0x4]
 8000d90: 6a18         	ldr	r0, [r3, #0x20]
 8000d92: 4b89         	ldr	r3, [pc, #0x224]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000d94: 881b         	ldrh	r3, [r3]
 8000d96: 461a         	mov	r2, r3
 8000d98: 78fb         	ldrb	r3, [r7, #0x3]
 8000d9a: fb02 f303    	mul	r3, r2, r3
 8000d9e: 461a         	mov	r2, r3
 8000da0: 2100         	movs	r1, #0x0
 8000da2: f028 f9b5    	bl	0x8029110 <memset>      @ imm = #0x2836a
; 	kf->temp = (uint8_t *)user_malloc(sizeof(uint8_t) * zSize);
 8000da6: 787b         	ldrb	r3, [r7, #0x1]
 8000da8: 4618         	mov	r0, r3
 8000daa: f005 fde7    	bl	0x800697c <malloc>      @ imm = #0x5bce
 8000dae: 4603         	mov	r3, r0
 8000db0: 461a         	mov	r2, r3
 8000db2: 687b         	ldr	r3, [r7, #0x4]
 8000db4: 625a         	str	r2, [r3, #0x24]
; 	memset(kf->temp, 0, sizeof(uint8_t) * zSize);
 8000db6: 687b         	ldr	r3, [r7, #0x4]
 8000db8: 6a5b         	ldr	r3, [r3, #0x24]
 8000dba: 787a         	ldrb	r2, [r7, #0x1]
 8000dbc: 2100         	movs	r1, #0x0
 8000dbe: 4618         	mov	r0, r3
 8000dc0: f028 f9a6    	bl	0x8029110 <memset>      @ imm = #0x2834c
; 	kf->FilteredValue = (float *)user_malloc(sizeof_float * xhatSize);
 8000dc4: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000dc6: 881b         	ldrh	r3, [r3]
 8000dc8: 461a         	mov	r2, r3
 8000dca: 78fb         	ldrb	r3, [r7, #0x3]
 8000dcc: fb02 f303    	mul	r3, r2, r3
 8000dd0: 4618         	mov	r0, r3
 8000dd2: f005 fdd3    	bl	0x800697c <malloc>      @ imm = #0x5ba6
 8000dd6: 4603         	mov	r3, r0
 8000dd8: 461a         	mov	r2, r3
 8000dda: 687b         	ldr	r3, [r7, #0x4]
 8000ddc: 601a         	str	r2, [r3]
; 	memset(kf->FilteredValue, 0, sizeof_float * xhatSize);
 8000dde: 687b         	ldr	r3, [r7, #0x4]
 8000de0: 6818         	ldr	r0, [r3]
 8000de2: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000de4: 881b         	ldrh	r3, [r3]
 8000de6: 461a         	mov	r2, r3
 8000de8: 78fb         	ldrb	r3, [r7, #0x3]
 8000dea: fb02 f303    	mul	r3, r2, r3
 8000dee: 461a         	mov	r2, r3
 8000df0: 2100         	movs	r1, #0x0
 8000df2: f028 f98d    	bl	0x8029110 <memset>      @ imm = #0x2831a
; 	kf->MeasuredVector = (float *)user_malloc(sizeof_float * zSize);
 8000df6: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000df8: 881b         	ldrh	r3, [r3]
 8000dfa: 461a         	mov	r2, r3
 8000dfc: 787b         	ldrb	r3, [r7, #0x1]
 8000dfe: fb02 f303    	mul	r3, r2, r3
 8000e02: 4618         	mov	r0, r3
 8000e04: f005 fdba    	bl	0x800697c <malloc>      @ imm = #0x5b74
 8000e08: 4603         	mov	r3, r0
 8000e0a: 461a         	mov	r2, r3
 8000e0c: 687b         	ldr	r3, [r7, #0x4]
 8000e0e: 605a         	str	r2, [r3, #0x4]
; 	memset(kf->MeasuredVector, 0, sizeof_float * zSize);
 8000e10: 687b         	ldr	r3, [r7, #0x4]
 8000e12: 6858         	ldr	r0, [r3, #0x4]
 8000e14: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000e16: 881b         	ldrh	r3, [r3]
 8000e18: 461a         	mov	r2, r3
 8000e1a: 787b         	ldrb	r3, [r7, #0x1]
 8000e1c: fb02 f303    	mul	r3, r2, r3
 8000e20: 461a         	mov	r2, r3
 8000e22: 2100         	movs	r1, #0x0
 8000e24: f028 f974    	bl	0x8029110 <memset>      @ imm = #0x282e8
; 	kf->ControlVector = (float *)user_malloc(sizeof_float * uSize);
 8000e28: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000e2a: 881b         	ldrh	r3, [r3]
 8000e2c: 461a         	mov	r2, r3
 8000e2e: 78bb         	ldrb	r3, [r7, #0x2]
 8000e30: fb02 f303    	mul	r3, r2, r3
 8000e34: 4618         	mov	r0, r3
 8000e36: f005 fda1    	bl	0x800697c <malloc>      @ imm = #0x5b42
 8000e3a: 4603         	mov	r3, r0
 8000e3c: 461a         	mov	r2, r3
 8000e3e: 687b         	ldr	r3, [r7, #0x4]
 8000e40: 609a         	str	r2, [r3, #0x8]
; 	memset(kf->ControlVector, 0, sizeof_float * uSize);
 8000e42: 687b         	ldr	r3, [r7, #0x4]
 8000e44: 6898         	ldr	r0, [r3, #0x8]
 8000e46: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000e48: 881b         	ldrh	r3, [r3]
 8000e4a: 461a         	mov	r2, r3
 8000e4c: 78bb         	ldrb	r3, [r7, #0x2]
 8000e4e: fb02 f303    	mul	r3, r2, r3
 8000e52: 461a         	mov	r2, r3
 8000e54: 2100         	movs	r1, #0x0
 8000e56: f028 f95b    	bl	0x8029110 <memset>      @ imm = #0x282b6
; 	kf->xhat_data = (float *)user_malloc(sizeof_float * xhatSize);
 8000e5a: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000e5c: 881b         	ldrh	r3, [r3]
 8000e5e: 461a         	mov	r2, r3
 8000e60: 78fb         	ldrb	r3, [r7, #0x3]
 8000e62: fb02 f303    	mul	r3, r2, r3
 8000e66: 4618         	mov	r0, r3
 8000e68: f005 fd88    	bl	0x800697c <malloc>      @ imm = #0x5b10
 8000e6c: 4603         	mov	r3, r0
 8000e6e: 461a         	mov	r2, r3
 8000e70: 687b         	ldr	r3, [r7, #0x4]
 8000e72: f8c3 20e8    	str.w	r2, [r3, #0xe8]
; 	memset(kf->xhat_data, 0, sizeof_float * xhatSize);
 8000e76: 687b         	ldr	r3, [r7, #0x4]
 8000e78: f8d3 00e8    	ldr.w	r0, [r3, #0xe8]
 8000e7c: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000e7e: 881b         	ldrh	r3, [r3]
 8000e80: 461a         	mov	r2, r3
 8000e82: 78fb         	ldrb	r3, [r7, #0x3]
 8000e84: fb02 f303    	mul	r3, r2, r3
 8000e88: 461a         	mov	r2, r3
 8000e8a: 2100         	movs	r1, #0x0
 8000e8c: f028 f940    	bl	0x8029110 <memset>      @ imm = #0x28280
; 	Matrix_Init(&kf->xhat, kf->xhatSize, 1, (float *)kf->xhat_data);
 8000e90: 687b         	ldr	r3, [r7, #0x4]
 8000e92: f103 0030    	add.w	r0, r3, #0x30
 8000e96: 687b         	ldr	r3, [r7, #0x4]
 8000e98: 7b1b         	ldrb	r3, [r3, #0xc]
 8000e9a: 4619         	mov	r1, r3
 8000e9c: 687b         	ldr	r3, [r7, #0x4]
 8000e9e: f8d3 30e8    	ldr.w	r3, [r3, #0xe8]
 8000ea2: 2201         	movs	r2, #0x1
 8000ea4: f012 fa86    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x1250c
; 	kf->xhatminus_data = (float *)user_malloc(sizeof_float * xhatSize);
 8000ea8: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000eaa: 881b         	ldrh	r3, [r3]
 8000eac: 461a         	mov	r2, r3
 8000eae: 78fb         	ldrb	r3, [r7, #0x3]
 8000eb0: fb02 f303    	mul	r3, r2, r3
 8000eb4: 4618         	mov	r0, r3
 8000eb6: f005 fd61    	bl	0x800697c <malloc>      @ imm = #0x5ac2
 8000eba: 4603         	mov	r3, r0
 8000ebc: 461a         	mov	r2, r3
 8000ebe: 687b         	ldr	r3, [r7, #0x4]
 8000ec0: f8c3 20ec    	str.w	r2, [r3, #0xec]
; 	memset(kf->xhatminus_data, 0, sizeof_float * xhatSize);
 8000ec4: 687b         	ldr	r3, [r7, #0x4]
 8000ec6: f8d3 00ec    	ldr.w	r0, [r3, #0xec]
 8000eca: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000ecc: 881b         	ldrh	r3, [r3]
 8000ece: 461a         	mov	r2, r3
 8000ed0: 78fb         	ldrb	r3, [r7, #0x3]
 8000ed2: fb02 f303    	mul	r3, r2, r3
 8000ed6: 461a         	mov	r2, r3
 8000ed8: 2100         	movs	r1, #0x0
 8000eda: f028 f919    	bl	0x8029110 <memset>      @ imm = #0x28232
; 	Matrix_Init(&kf->xhatminus, kf->xhatSize, 1, (float *)kf->xhatminus_data);
 8000ede: 687b         	ldr	r3, [r7, #0x4]
 8000ee0: f103 0038    	add.w	r0, r3, #0x38
 8000ee4: 687b         	ldr	r3, [r7, #0x4]
 8000ee6: 7b1b         	ldrb	r3, [r3, #0xc]
 8000ee8: 4619         	mov	r1, r3
 8000eea: 687b         	ldr	r3, [r7, #0x4]
 8000eec: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8000ef0: 2201         	movs	r2, #0x1
 8000ef2: f012 fa5f    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x124be
; 	if (uSize != 0) {
 8000ef6: 78bb         	ldrb	r3, [r7, #0x2]
 8000ef8: 2b00         	cmp	r3, #0x0
 8000efa: d026         	beq	0x8000f4a <Kalman_Filter_Init+0x296> @ imm = #0x4c
; 		kf->u_data = (float *)user_malloc(sizeof_float * uSize);
 8000efc: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000efe: 881b         	ldrh	r3, [r3]
 8000f00: 461a         	mov	r2, r3
 8000f02: 78bb         	ldrb	r3, [r7, #0x2]
 8000f04: fb02 f303    	mul	r3, r2, r3
 8000f08: 4618         	mov	r0, r3
 8000f0a: f005 fd37    	bl	0x800697c <malloc>      @ imm = #0x5a6e
 8000f0e: 4603         	mov	r3, r0
 8000f10: 461a         	mov	r2, r3
 8000f12: 687b         	ldr	r3, [r7, #0x4]
 8000f14: f8c3 20f0    	str.w	r2, [r3, #0xf0]
; 		memset(kf->u_data, 0, sizeof_float * uSize);
 8000f18: 687b         	ldr	r3, [r7, #0x4]
 8000f1a: f8d3 00f0    	ldr.w	r0, [r3, #0xf0]
 8000f1e: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000f20: 881b         	ldrh	r3, [r3]
 8000f22: 461a         	mov	r2, r3
 8000f24: 78bb         	ldrb	r3, [r7, #0x2]
 8000f26: fb02 f303    	mul	r3, r2, r3
 8000f2a: 461a         	mov	r2, r3
 8000f2c: 2100         	movs	r1, #0x0
 8000f2e: f028 f8ef    	bl	0x8029110 <memset>      @ imm = #0x281de
; 		Matrix_Init(&kf->u, kf->uSize, 1, (float *)kf->u_data);
 8000f32: 687b         	ldr	r3, [r7, #0x4]
 8000f34: f103 0040    	add.w	r0, r3, #0x40
 8000f38: 687b         	ldr	r3, [r7, #0x4]
 8000f3a: 7b5b         	ldrb	r3, [r3, #0xd]
 8000f3c: 4619         	mov	r1, r3
 8000f3e: 687b         	ldr	r3, [r7, #0x4]
 8000f40: f8d3 30f0    	ldr.w	r3, [r3, #0xf0]
 8000f44: 2201         	movs	r2, #0x1
 8000f46: f012 fa35    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x1246a
; 	kf->z_data = (float *)user_malloc(sizeof_float * zSize);
 8000f4a: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000f4c: 881b         	ldrh	r3, [r3]
 8000f4e: 461a         	mov	r2, r3
 8000f50: 787b         	ldrb	r3, [r7, #0x1]
 8000f52: fb02 f303    	mul	r3, r2, r3
 8000f56: 4618         	mov	r0, r3
 8000f58: f005 fd10    	bl	0x800697c <malloc>      @ imm = #0x5a20
 8000f5c: 4603         	mov	r3, r0
 8000f5e: 461a         	mov	r2, r3
 8000f60: 687b         	ldr	r3, [r7, #0x4]
 8000f62: f8c3 20f4    	str.w	r2, [r3, #0xf4]
; 	memset(kf->z_data, 0, sizeof_float * zSize);
 8000f66: 687b         	ldr	r3, [r7, #0x4]
 8000f68: f8d3 00f4    	ldr.w	r0, [r3, #0xf4]
 8000f6c: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000f6e: 881b         	ldrh	r3, [r3]
 8000f70: 461a         	mov	r2, r3
 8000f72: 787b         	ldrb	r3, [r7, #0x1]
 8000f74: fb02 f303    	mul	r3, r2, r3
 8000f78: 461a         	mov	r2, r3
 8000f7a: 2100         	movs	r1, #0x0
 8000f7c: f028 f8c8    	bl	0x8029110 <memset>      @ imm = #0x28190
; 	Matrix_Init(&kf->z, kf->zSize, 1, (float *)kf->z_data);
 8000f80: 687b         	ldr	r3, [r7, #0x4]
 8000f82: f103 0048    	add.w	r0, r3, #0x48
 8000f86: 687b         	ldr	r3, [r7, #0x4]
 8000f88: 7b9b         	ldrb	r3, [r3, #0xe]
 8000f8a: 4619         	mov	r1, r3
 8000f8c: 687b         	ldr	r3, [r7, #0x4]
 8000f8e: f8d3 30f4    	ldr.w	r3, [r3, #0xf4]
 8000f92: 2201         	movs	r2, #0x1
 8000f94: f012 fa0e    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x1241c
; 	kf->P_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8000f98: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8000fb8 <Kalman_Filter_Init+0x304>
 8000f9a: 881b         	ldrh	r3, [r3]
 8000f9c: 461a         	mov	r2, r3
 8000f9e: 78fb         	ldrb	r3, [r7, #0x3]
 8000fa0: fb02 f303    	mul	r3, r2, r3
 8000fa4: 78fa         	ldrb	r2, [r7, #0x3]
 8000fa6: fb02 f303    	mul	r3, r2, r3
 8000faa: 4618         	mov	r0, r3
 8000fac: f005 fce6    	bl	0x800697c <malloc>      @ imm = #0x59cc
 8000fb0: 4603         	mov	r3, r0
 8000fb2: 461a         	mov	r2, r3
 8000fb4: 687b         	ldr	r3, [r7, #0x4]
 8000fb6: e003         	b	0x8000fc0 <Kalman_Filter_Init+0x30c> @ imm = #0x6

08000fb8 <$d>:
 8000fb8: ec 32 00 24  	.word	0x240032ec
 8000fbc: ee 32 00 24  	.word	0x240032ee

08000fc0 <$t>:
 8000fc0: f8c3 20f8    	str.w	r2, [r3, #0xf8]
; 	memset(kf->P_data, 0, sizeof_float * xhatSize * xhatSize);
 8000fc4: 687b         	ldr	r3, [r7, #0x4]
 8000fc6: f8d3 00f8    	ldr.w	r0, [r3, #0xf8]
 8000fca: 4bbd         	ldr	r3, [pc, #0x2f4]        @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 8000fcc: 881b         	ldrh	r3, [r3]
 8000fce: 461a         	mov	r2, r3
 8000fd0: 78fb         	ldrb	r3, [r7, #0x3]
 8000fd2: fb02 f303    	mul	r3, r2, r3
 8000fd6: 78fa         	ldrb	r2, [r7, #0x3]
 8000fd8: fb02 f303    	mul	r3, r2, r3
 8000fdc: 461a         	mov	r2, r3
 8000fde: 2100         	movs	r1, #0x0
 8000fe0: f028 f896    	bl	0x8029110 <memset>      @ imm = #0x2812c
; 	Matrix_Init(&kf->P, kf->xhatSize, kf->xhatSize, (float *)kf->P_data);
 8000fe4: 687b         	ldr	r3, [r7, #0x4]
 8000fe6: f103 0050    	add.w	r0, r3, #0x50
 8000fea: 687b         	ldr	r3, [r7, #0x4]
 8000fec: 7b1b         	ldrb	r3, [r3, #0xc]
 8000fee: 4619         	mov	r1, r3
 8000ff0: 687b         	ldr	r3, [r7, #0x4]
 8000ff2: 7b1b         	ldrb	r3, [r3, #0xc]
 8000ff4: 461a         	mov	r2, r3
 8000ff6: 687b         	ldr	r3, [r7, #0x4]
 8000ff8: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8000ffc: f012 f9da    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x123b4
; 	kf->Pminus_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001000: 4baf         	ldr	r3, [pc, #0x2bc]        @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 8001002: 881b         	ldrh	r3, [r3]
 8001004: 461a         	mov	r2, r3
 8001006: 78fb         	ldrb	r3, [r7, #0x3]
 8001008: fb02 f303    	mul	r3, r2, r3
 800100c: 78fa         	ldrb	r2, [r7, #0x3]
 800100e: fb02 f303    	mul	r3, r2, r3
 8001012: 4618         	mov	r0, r3
 8001014: f005 fcb2    	bl	0x800697c <malloc>      @ imm = #0x5964
 8001018: 4603         	mov	r3, r0
 800101a: 461a         	mov	r2, r3
 800101c: 687b         	ldr	r3, [r7, #0x4]
 800101e: f8c3 20fc    	str.w	r2, [r3, #0xfc]
; 	memset(kf->Pminus_data, 0, sizeof_float * xhatSize * xhatSize);
 8001022: 687b         	ldr	r3, [r7, #0x4]
 8001024: f8d3 00fc    	ldr.w	r0, [r3, #0xfc]
 8001028: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 800102a: 881b         	ldrh	r3, [r3]
 800102c: 461a         	mov	r2, r3
 800102e: 78fb         	ldrb	r3, [r7, #0x3]
 8001030: fb02 f303    	mul	r3, r2, r3
 8001034: 78fa         	ldrb	r2, [r7, #0x3]
 8001036: fb02 f303    	mul	r3, r2, r3
 800103a: 461a         	mov	r2, r3
 800103c: 2100         	movs	r1, #0x0
 800103e: f028 f867    	bl	0x8029110 <memset>      @ imm = #0x280ce
; 	Matrix_Init(&kf->Pminus, kf->xhatSize, kf->xhatSize, (float *)kf->Pminus_data);
 8001042: 687b         	ldr	r3, [r7, #0x4]
 8001044: f103 0058    	add.w	r0, r3, #0x58
 8001048: 687b         	ldr	r3, [r7, #0x4]
 800104a: 7b1b         	ldrb	r3, [r3, #0xc]
 800104c: 4619         	mov	r1, r3
 800104e: 687b         	ldr	r3, [r7, #0x4]
 8001050: 7b1b         	ldrb	r3, [r3, #0xc]
 8001052: 461a         	mov	r2, r3
 8001054: 687b         	ldr	r3, [r7, #0x4]
 8001056: f8d3 30fc    	ldr.w	r3, [r3, #0xfc]
 800105a: f012 f9ab    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x12356
; 	kf->F_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 800105e: 4b98         	ldr	r3, [pc, #0x260]        @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 8001060: 881b         	ldrh	r3, [r3]
 8001062: 461a         	mov	r2, r3
 8001064: 78fb         	ldrb	r3, [r7, #0x3]
 8001066: fb02 f303    	mul	r3, r2, r3
 800106a: 78fa         	ldrb	r2, [r7, #0x3]
 800106c: fb02 f303    	mul	r3, r2, r3
 8001070: 4618         	mov	r0, r3
 8001072: f005 fc83    	bl	0x800697c <malloc>      @ imm = #0x5906
 8001076: 4603         	mov	r3, r0
 8001078: 461a         	mov	r2, r3
 800107a: 687b         	ldr	r3, [r7, #0x4]
 800107c: f8c3 2100    	str.w	r2, [r3, #0x100]
; 	kf->FT_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001080: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 8001082: 881b         	ldrh	r3, [r3]
 8001084: 461a         	mov	r2, r3
 8001086: 78fb         	ldrb	r3, [r7, #0x3]
 8001088: fb02 f303    	mul	r3, r2, r3
 800108c: 78fa         	ldrb	r2, [r7, #0x3]
 800108e: fb02 f303    	mul	r3, r2, r3
 8001092: 4618         	mov	r0, r3
 8001094: f005 fc72    	bl	0x800697c <malloc>      @ imm = #0x58e4
 8001098: 4603         	mov	r3, r0
 800109a: 461a         	mov	r2, r3
 800109c: 687b         	ldr	r3, [r7, #0x4]
 800109e: f8c3 2104    	str.w	r2, [r3, #0x104]
; 	memset(kf->F_data, 0, sizeof_float * xhatSize * xhatSize);
 80010a2: 687b         	ldr	r3, [r7, #0x4]
 80010a4: f8d3 0100    	ldr.w	r0, [r3, #0x100]
 80010a8: 4b85         	ldr	r3, [pc, #0x214]        @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 80010aa: 881b         	ldrh	r3, [r3]
 80010ac: 461a         	mov	r2, r3
 80010ae: 78fb         	ldrb	r3, [r7, #0x3]
 80010b0: fb02 f303    	mul	r3, r2, r3
 80010b4: 78fa         	ldrb	r2, [r7, #0x3]
 80010b6: fb02 f303    	mul	r3, r2, r3
 80010ba: 461a         	mov	r2, r3
 80010bc: 2100         	movs	r1, #0x0
 80010be: f028 f827    	bl	0x8029110 <memset>      @ imm = #0x2804e
; 	memset(kf->FT_data, 0, sizeof_float * xhatSize * xhatSize);
 80010c2: 687b         	ldr	r3, [r7, #0x4]
 80010c4: f8d3 0104    	ldr.w	r0, [r3, #0x104]
 80010c8: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 80010ca: 881b         	ldrh	r3, [r3]
 80010cc: 461a         	mov	r2, r3
 80010ce: 78fb         	ldrb	r3, [r7, #0x3]
 80010d0: fb02 f303    	mul	r3, r2, r3
 80010d4: 78fa         	ldrb	r2, [r7, #0x3]
 80010d6: fb02 f303    	mul	r3, r2, r3
 80010da: 461a         	mov	r2, r3
 80010dc: 2100         	movs	r1, #0x0
 80010de: f028 f817    	bl	0x8029110 <memset>      @ imm = #0x2802e
; 	Matrix_Init(&kf->F, kf->xhatSize, kf->xhatSize, (float *)kf->F_data);
 80010e2: 687b         	ldr	r3, [r7, #0x4]
 80010e4: f103 0060    	add.w	r0, r3, #0x60
 80010e8: 687b         	ldr	r3, [r7, #0x4]
 80010ea: 7b1b         	ldrb	r3, [r3, #0xc]
 80010ec: 4619         	mov	r1, r3
 80010ee: 687b         	ldr	r3, [r7, #0x4]
 80010f0: 7b1b         	ldrb	r3, [r3, #0xc]
 80010f2: 461a         	mov	r2, r3
 80010f4: 687b         	ldr	r3, [r7, #0x4]
 80010f6: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 80010fa: f012 f95b    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x122b6
; 	Matrix_Init(&kf->FT, kf->xhatSize, kf->xhatSize, (float *)kf->FT_data);
 80010fe: 687b         	ldr	r3, [r7, #0x4]
 8001100: f103 0068    	add.w	r0, r3, #0x68
 8001104: 687b         	ldr	r3, [r7, #0x4]
 8001106: 7b1b         	ldrb	r3, [r3, #0xc]
 8001108: 4619         	mov	r1, r3
 800110a: 687b         	ldr	r3, [r7, #0x4]
 800110c: 7b1b         	ldrb	r3, [r3, #0xc]
 800110e: 461a         	mov	r2, r3
 8001110: 687b         	ldr	r3, [r7, #0x4]
 8001112: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001116: f012 f94d    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x1229a
; 	if (uSize != 0) {
 800111a: 78bb         	ldrb	r3, [r7, #0x2]
 800111c: 2b00         	cmp	r3, #0x0
 800111e: d02e         	beq	0x800117e <Kalman_Filter_Init+0x4ca> @ imm = #0x5c
; 		kf->B_data = (float *)user_malloc(sizeof_float * xhatSize * uSize);
 8001120: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 8001122: 881b         	ldrh	r3, [r3]
 8001124: 461a         	mov	r2, r3
 8001126: 78fb         	ldrb	r3, [r7, #0x3]
 8001128: fb02 f303    	mul	r3, r2, r3
 800112c: 78ba         	ldrb	r2, [r7, #0x2]
 800112e: fb02 f303    	mul	r3, r2, r3
 8001132: 4618         	mov	r0, r3
 8001134: f005 fc22    	bl	0x800697c <malloc>      @ imm = #0x5844
 8001138: 4603         	mov	r3, r0
 800113a: 461a         	mov	r2, r3
 800113c: 687b         	ldr	r3, [r7, #0x4]
 800113e: f8c3 2108    	str.w	r2, [r3, #0x108]
; 		memset(kf->B_data, 0, sizeof_float * xhatSize * uSize);
 8001142: 687b         	ldr	r3, [r7, #0x4]
 8001144: f8d3 0108    	ldr.w	r0, [r3, #0x108]
 8001148: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 800114a: 881b         	ldrh	r3, [r3]
 800114c: 461a         	mov	r2, r3
 800114e: 78fb         	ldrb	r3, [r7, #0x3]
 8001150: fb02 f303    	mul	r3, r2, r3
 8001154: 78ba         	ldrb	r2, [r7, #0x2]
 8001156: fb02 f303    	mul	r3, r2, r3
 800115a: 461a         	mov	r2, r3
 800115c: 2100         	movs	r1, #0x0
 800115e: f027 ffd7    	bl	0x8029110 <memset>      @ imm = #0x27fae
; 		Matrix_Init(&kf->B, kf->xhatSize, kf->uSize, (float *)kf->B_data);
 8001162: 687b         	ldr	r3, [r7, #0x4]
 8001164: f103 0070    	add.w	r0, r3, #0x70
 8001168: 687b         	ldr	r3, [r7, #0x4]
 800116a: 7b1b         	ldrb	r3, [r3, #0xc]
 800116c: 4619         	mov	r1, r3
 800116e: 687b         	ldr	r3, [r7, #0x4]
 8001170: 7b5b         	ldrb	r3, [r3, #0xd]
 8001172: 461a         	mov	r2, r3
 8001174: 687b         	ldr	r3, [r7, #0x4]
 8001176: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 800117a: f012 f91b    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x12236
; 	kf->H_data = (float *)user_malloc(sizeof_float * zSize * xhatSize);
 800117e: 4b50         	ldr	r3, [pc, #0x140]        @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 8001180: 881b         	ldrh	r3, [r3]
 8001182: 461a         	mov	r2, r3
 8001184: 787b         	ldrb	r3, [r7, #0x1]
 8001186: fb02 f303    	mul	r3, r2, r3
 800118a: 78fa         	ldrb	r2, [r7, #0x3]
 800118c: fb02 f303    	mul	r3, r2, r3
 8001190: 4618         	mov	r0, r3
 8001192: f005 fbf3    	bl	0x800697c <malloc>      @ imm = #0x57e6
 8001196: 4603         	mov	r3, r0
 8001198: 461a         	mov	r2, r3
 800119a: 687b         	ldr	r3, [r7, #0x4]
 800119c: f8c3 210c    	str.w	r2, [r3, #0x10c]
; 	kf->HT_data = (float *)user_malloc(sizeof_float * xhatSize * zSize);
 80011a0: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 80011a2: 881b         	ldrh	r3, [r3]
 80011a4: 461a         	mov	r2, r3
 80011a6: 78fb         	ldrb	r3, [r7, #0x3]
 80011a8: fb02 f303    	mul	r3, r2, r3
 80011ac: 787a         	ldrb	r2, [r7, #0x1]
 80011ae: fb02 f303    	mul	r3, r2, r3
 80011b2: 4618         	mov	r0, r3
 80011b4: f005 fbe2    	bl	0x800697c <malloc>      @ imm = #0x57c4
 80011b8: 4603         	mov	r3, r0
 80011ba: 461a         	mov	r2, r3
 80011bc: 687b         	ldr	r3, [r7, #0x4]
 80011be: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	memset(kf->H_data, 0, sizeof_float * zSize * xhatSize);
 80011c2: 687b         	ldr	r3, [r7, #0x4]
 80011c4: f8d3 010c    	ldr.w	r0, [r3, #0x10c]
 80011c8: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 80011ca: 881b         	ldrh	r3, [r3]
 80011cc: 461a         	mov	r2, r3
 80011ce: 787b         	ldrb	r3, [r7, #0x1]
 80011d0: fb02 f303    	mul	r3, r2, r3
 80011d4: 78fa         	ldrb	r2, [r7, #0x3]
 80011d6: fb02 f303    	mul	r3, r2, r3
 80011da: 461a         	mov	r2, r3
 80011dc: 2100         	movs	r1, #0x0
 80011de: f027 ff97    	bl	0x8029110 <memset>      @ imm = #0x27f2e
; 	memset(kf->HT_data, 0, sizeof_float * xhatSize * zSize);
 80011e2: 687b         	ldr	r3, [r7, #0x4]
 80011e4: f8d3 0110    	ldr.w	r0, [r3, #0x110]
 80011e8: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 80011ea: 881b         	ldrh	r3, [r3]
 80011ec: 461a         	mov	r2, r3
 80011ee: 78fb         	ldrb	r3, [r7, #0x3]
 80011f0: fb02 f303    	mul	r3, r2, r3
 80011f4: 787a         	ldrb	r2, [r7, #0x1]
 80011f6: fb02 f303    	mul	r3, r2, r3
 80011fa: 461a         	mov	r2, r3
 80011fc: 2100         	movs	r1, #0x0
 80011fe: f027 ff87    	bl	0x8029110 <memset>      @ imm = #0x27f0e
; 	Matrix_Init(&kf->H, kf->zSize, kf->xhatSize, (float *)kf->H_data);
 8001202: 687b         	ldr	r3, [r7, #0x4]
 8001204: f103 0078    	add.w	r0, r3, #0x78
 8001208: 687b         	ldr	r3, [r7, #0x4]
 800120a: 7b9b         	ldrb	r3, [r3, #0xe]
 800120c: 4619         	mov	r1, r3
 800120e: 687b         	ldr	r3, [r7, #0x4]
 8001210: 7b1b         	ldrb	r3, [r3, #0xc]
 8001212: 461a         	mov	r2, r3
 8001214: 687b         	ldr	r3, [r7, #0x4]
 8001216: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 800121a: f012 f8cb    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x12196
; 	Matrix_Init(&kf->HT, kf->xhatSize, kf->zSize, (float *)kf->HT_data);
 800121e: 687b         	ldr	r3, [r7, #0x4]
 8001220: f103 0080    	add.w	r0, r3, #0x80
 8001224: 687b         	ldr	r3, [r7, #0x4]
 8001226: 7b1b         	ldrb	r3, [r3, #0xc]
 8001228: 4619         	mov	r1, r3
 800122a: 687b         	ldr	r3, [r7, #0x4]
 800122c: 7b9b         	ldrb	r3, [r3, #0xe]
 800122e: 461a         	mov	r2, r3
 8001230: 687b         	ldr	r3, [r7, #0x4]
 8001232: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 8001236: f012 f8bd    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x1217a
; 	kf->Q_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 800123a: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 800123c: 881b         	ldrh	r3, [r3]
 800123e: 461a         	mov	r2, r3
 8001240: 78fb         	ldrb	r3, [r7, #0x3]
 8001242: fb02 f303    	mul	r3, r2, r3
 8001246: 78fa         	ldrb	r2, [r7, #0x3]
 8001248: fb02 f303    	mul	r3, r2, r3
 800124c: 4618         	mov	r0, r3
 800124e: f005 fb95    	bl	0x800697c <malloc>      @ imm = #0x572a
 8001252: 4603         	mov	r3, r0
 8001254: 461a         	mov	r2, r3
 8001256: 687b         	ldr	r3, [r7, #0x4]
 8001258: f8c3 2114    	str.w	r2, [r3, #0x114]
; 	memset(kf->Q_data, 0, sizeof_float * xhatSize * xhatSize);
 800125c: 687b         	ldr	r3, [r7, #0x4]
 800125e: f8d3 0114    	ldr.w	r0, [r3, #0x114]
 8001262: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 8001264: 881b         	ldrh	r3, [r3]
 8001266: 461a         	mov	r2, r3
 8001268: 78fb         	ldrb	r3, [r7, #0x3]
 800126a: fb02 f303    	mul	r3, r2, r3
 800126e: 78fa         	ldrb	r2, [r7, #0x3]
 8001270: fb02 f303    	mul	r3, r2, r3
 8001274: 461a         	mov	r2, r3
 8001276: 2100         	movs	r1, #0x0
 8001278: f027 ff4a    	bl	0x8029110 <memset>      @ imm = #0x27e94
; 	Matrix_Init(&kf->Q, kf->xhatSize, kf->xhatSize, (float *)kf->Q_data);
 800127c: 687b         	ldr	r3, [r7, #0x4]
 800127e: f103 0088    	add.w	r0, r3, #0x88
 8001282: 687b         	ldr	r3, [r7, #0x4]
 8001284: 7b1b         	ldrb	r3, [r3, #0xc]
 8001286: 4619         	mov	r1, r3
 8001288: 687b         	ldr	r3, [r7, #0x4]
 800128a: 7b1b         	ldrb	r3, [r3, #0xc]
 800128c: 461a         	mov	r2, r3
 800128e: 687b         	ldr	r3, [r7, #0x4]
 8001290: f8d3 3114    	ldr.w	r3, [r3, #0x114]
 8001294: f012 f88e    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x1211c
; 	kf->R_data = (float *)user_malloc(sizeof_float * zSize * zSize);
 8001298: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80012c0 <Kalman_Filter_Init+0x60c>
 800129a: 881b         	ldrh	r3, [r3]
 800129c: 461a         	mov	r2, r3
 800129e: 787b         	ldrb	r3, [r7, #0x1]
 80012a0: fb02 f303    	mul	r3, r2, r3
 80012a4: 787a         	ldrb	r2, [r7, #0x1]
 80012a6: fb02 f303    	mul	r3, r2, r3
 80012aa: 4618         	mov	r0, r3
 80012ac: f005 fb66    	bl	0x800697c <malloc>      @ imm = #0x56cc
 80012b0: 4603         	mov	r3, r0
 80012b2: 461a         	mov	r2, r3
 80012b4: 687b         	ldr	r3, [r7, #0x4]
 80012b6: f8c3 2118    	str.w	r2, [r3, #0x118]
; 	memset(kf->R_data, 0, sizeof_float * zSize * zSize);
 80012ba: 687b         	ldr	r3, [r7, #0x4]
 80012bc: e002         	b	0x80012c4 <Kalman_Filter_Init+0x610> @ imm = #0x4
 80012be: bf00         	nop

080012c0 <$d>:
 80012c0: ec 32 00 24  	.word	0x240032ec

080012c4 <$t>:
 80012c4: f8d3 0118    	ldr.w	r0, [r3, #0x118]
 80012c8: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x80014c0 <Kalman_Filter_Init+0x80c>
 80012ca: 881b         	ldrh	r3, [r3]
 80012cc: 461a         	mov	r2, r3
 80012ce: 787b         	ldrb	r3, [r7, #0x1]
 80012d0: fb02 f303    	mul	r3, r2, r3
 80012d4: 787a         	ldrb	r2, [r7, #0x1]
 80012d6: fb02 f303    	mul	r3, r2, r3
 80012da: 461a         	mov	r2, r3
 80012dc: 2100         	movs	r1, #0x0
 80012de: f027 ff17    	bl	0x8029110 <memset>      @ imm = #0x27e2e
; 	Matrix_Init(&kf->R, kf->zSize, kf->zSize, (float *)kf->R_data);
 80012e2: 687b         	ldr	r3, [r7, #0x4]
 80012e4: f103 0090    	add.w	r0, r3, #0x90
 80012e8: 687b         	ldr	r3, [r7, #0x4]
 80012ea: 7b9b         	ldrb	r3, [r3, #0xe]
 80012ec: 4619         	mov	r1, r3
 80012ee: 687b         	ldr	r3, [r7, #0x4]
 80012f0: 7b9b         	ldrb	r3, [r3, #0xe]
 80012f2: 461a         	mov	r2, r3
 80012f4: 687b         	ldr	r3, [r7, #0x4]
 80012f6: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 80012fa: f012 f85b    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x120b6
; 	kf->K_data = (float *)user_malloc(sizeof_float * xhatSize * zSize);
 80012fe: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x80014c0 <Kalman_Filter_Init+0x80c>
 8001300: 881b         	ldrh	r3, [r3]
 8001302: 461a         	mov	r2, r3
 8001304: 78fb         	ldrb	r3, [r7, #0x3]
 8001306: fb02 f303    	mul	r3, r2, r3
 800130a: 787a         	ldrb	r2, [r7, #0x1]
 800130c: fb02 f303    	mul	r3, r2, r3
 8001310: 4618         	mov	r0, r3
 8001312: f005 fb33    	bl	0x800697c <malloc>      @ imm = #0x5666
 8001316: 4603         	mov	r3, r0
 8001318: 461a         	mov	r2, r3
 800131a: 687b         	ldr	r3, [r7, #0x4]
 800131c: f8c3 211c    	str.w	r2, [r3, #0x11c]
; 	memset(kf->K_data, 0, sizeof_float * xhatSize * zSize);
 8001320: 687b         	ldr	r3, [r7, #0x4]
 8001322: f8d3 011c    	ldr.w	r0, [r3, #0x11c]
 8001326: 4b66         	ldr	r3, [pc, #0x198]        @ 0x80014c0 <Kalman_Filter_Init+0x80c>
 8001328: 881b         	ldrh	r3, [r3]
 800132a: 461a         	mov	r2, r3
 800132c: 78fb         	ldrb	r3, [r7, #0x3]
 800132e: fb02 f303    	mul	r3, r2, r3
 8001332: 787a         	ldrb	r2, [r7, #0x1]
 8001334: fb02 f303    	mul	r3, r2, r3
 8001338: 461a         	mov	r2, r3
 800133a: 2100         	movs	r1, #0x0
 800133c: f027 fee8    	bl	0x8029110 <memset>      @ imm = #0x27dd0
; 	Matrix_Init(&kf->K, kf->xhatSize, kf->zSize, (float *)kf->K_data);
 8001340: 687b         	ldr	r3, [r7, #0x4]
 8001342: f103 0098    	add.w	r0, r3, #0x98
 8001346: 687b         	ldr	r3, [r7, #0x4]
 8001348: 7b1b         	ldrb	r3, [r3, #0xc]
 800134a: 4619         	mov	r1, r3
 800134c: 687b         	ldr	r3, [r7, #0x4]
 800134e: 7b9b         	ldrb	r3, [r3, #0xe]
 8001350: 461a         	mov	r2, r3
 8001352: 687b         	ldr	r3, [r7, #0x4]
 8001354: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8001358: f012 f82c    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x12058
; 	kf->S_data = (float *)user_malloc(sizeof_float * kf->xhatSize * kf->xhatSize);
 800135c: 4b58         	ldr	r3, [pc, #0x160]        @ 0x80014c0 <Kalman_Filter_Init+0x80c>
 800135e: 881b         	ldrh	r3, [r3]
 8001360: 461a         	mov	r2, r3
 8001362: 687b         	ldr	r3, [r7, #0x4]
 8001364: 7b1b         	ldrb	r3, [r3, #0xc]
 8001366: fb02 f303    	mul	r3, r2, r3
 800136a: 687a         	ldr	r2, [r7, #0x4]
 800136c: 7b12         	ldrb	r2, [r2, #0xc]
 800136e: fb02 f303    	mul	r3, r2, r3
 8001372: 4618         	mov	r0, r3
 8001374: f005 fb02    	bl	0x800697c <malloc>      @ imm = #0x5604
 8001378: 4603         	mov	r3, r0
 800137a: 461a         	mov	r2, r3
 800137c: 687b         	ldr	r3, [r7, #0x4]
 800137e: f8c3 2120    	str.w	r2, [r3, #0x120]
; 	kf->temp_matrix_data = (float *)user_malloc(sizeof_float * kf->xhatSize * kf->xhatSize);
 8001382: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x80014c0 <Kalman_Filter_Init+0x80c>
 8001384: 881b         	ldrh	r3, [r3]
 8001386: 461a         	mov	r2, r3
 8001388: 687b         	ldr	r3, [r7, #0x4]
 800138a: 7b1b         	ldrb	r3, [r3, #0xc]
 800138c: fb02 f303    	mul	r3, r2, r3
 8001390: 687a         	ldr	r2, [r7, #0x4]
 8001392: 7b12         	ldrb	r2, [r2, #0xc]
 8001394: fb02 f303    	mul	r3, r2, r3
 8001398: 4618         	mov	r0, r3
 800139a: f005 faef    	bl	0x800697c <malloc>      @ imm = #0x55de
 800139e: 4603         	mov	r3, r0
 80013a0: 461a         	mov	r2, r3
 80013a2: 687b         	ldr	r3, [r7, #0x4]
 80013a4: f8c3 2124    	str.w	r2, [r3, #0x124]
; 	kf->temp_matrix_data1 = (float *)user_malloc(sizeof_float * kf->xhatSize * kf->xhatSize);
 80013a8: 4b45         	ldr	r3, [pc, #0x114]        @ 0x80014c0 <Kalman_Filter_Init+0x80c>
 80013aa: 881b         	ldrh	r3, [r3]
 80013ac: 461a         	mov	r2, r3
 80013ae: 687b         	ldr	r3, [r7, #0x4]
 80013b0: 7b1b         	ldrb	r3, [r3, #0xc]
 80013b2: fb02 f303    	mul	r3, r2, r3
 80013b6: 687a         	ldr	r2, [r7, #0x4]
 80013b8: 7b12         	ldrb	r2, [r2, #0xc]
 80013ba: fb02 f303    	mul	r3, r2, r3
 80013be: 4618         	mov	r0, r3
 80013c0: f005 fadc    	bl	0x800697c <malloc>      @ imm = #0x55b8
 80013c4: 4603         	mov	r3, r0
 80013c6: 461a         	mov	r2, r3
 80013c8: 687b         	ldr	r3, [r7, #0x4]
 80013ca: f8c3 2128    	str.w	r2, [r3, #0x128]
; 	kf->temp_vector_data = (float *)user_malloc(sizeof_float * kf->xhatSize);
 80013ce: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x80014c0 <Kalman_Filter_Init+0x80c>
 80013d0: 881b         	ldrh	r3, [r3]
 80013d2: 461a         	mov	r2, r3
 80013d4: 687b         	ldr	r3, [r7, #0x4]
 80013d6: 7b1b         	ldrb	r3, [r3, #0xc]
 80013d8: fb02 f303    	mul	r3, r2, r3
 80013dc: 4618         	mov	r0, r3
 80013de: f005 facd    	bl	0x800697c <malloc>      @ imm = #0x559a
 80013e2: 4603         	mov	r3, r0
 80013e4: 461a         	mov	r2, r3
 80013e6: 687b         	ldr	r3, [r7, #0x4]
 80013e8: f8c3 212c    	str.w	r2, [r3, #0x12c]
; 	kf->temp_vector_data1 = (float *)user_malloc(sizeof_float * kf->xhatSize);
 80013ec: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x80014c0 <Kalman_Filter_Init+0x80c>
 80013ee: 881b         	ldrh	r3, [r3]
 80013f0: 461a         	mov	r2, r3
 80013f2: 687b         	ldr	r3, [r7, #0x4]
 80013f4: 7b1b         	ldrb	r3, [r3, #0xc]
 80013f6: fb02 f303    	mul	r3, r2, r3
 80013fa: 4618         	mov	r0, r3
 80013fc: f005 fabe    	bl	0x800697c <malloc>      @ imm = #0x557c
 8001400: 4603         	mov	r3, r0
 8001402: 461a         	mov	r2, r3
 8001404: 687b         	ldr	r3, [r7, #0x4]
 8001406: f8c3 2130    	str.w	r2, [r3, #0x130]
; 	Matrix_Init(&kf->S, kf->xhatSize, kf->xhatSize, (float *)kf->S_data);
 800140a: 687b         	ldr	r3, [r7, #0x4]
 800140c: f103 00a0    	add.w	r0, r3, #0xa0
 8001410: 687b         	ldr	r3, [r7, #0x4]
 8001412: 7b1b         	ldrb	r3, [r3, #0xc]
 8001414: 4619         	mov	r1, r3
 8001416: 687b         	ldr	r3, [r7, #0x4]
 8001418: 7b1b         	ldrb	r3, [r3, #0xc]
 800141a: 461a         	mov	r2, r3
 800141c: 687b         	ldr	r3, [r7, #0x4]
 800141e: f8d3 3120    	ldr.w	r3, [r3, #0x120]
 8001422: f011 ffc7    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x11f8e
; 	Matrix_Init(&kf->temp_matrix, kf->xhatSize, kf->xhatSize, (float *)kf->temp_matrix_data);
 8001426: 687b         	ldr	r3, [r7, #0x4]
 8001428: f103 00a8    	add.w	r0, r3, #0xa8
 800142c: 687b         	ldr	r3, [r7, #0x4]
 800142e: 7b1b         	ldrb	r3, [r3, #0xc]
 8001430: 4619         	mov	r1, r3
 8001432: 687b         	ldr	r3, [r7, #0x4]
 8001434: 7b1b         	ldrb	r3, [r3, #0xc]
 8001436: 461a         	mov	r2, r3
 8001438: 687b         	ldr	r3, [r7, #0x4]
 800143a: f8d3 3124    	ldr.w	r3, [r3, #0x124]
 800143e: f011 ffb9    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x11f72
; 	Matrix_Init(&kf->temp_matrix1, kf->xhatSize, kf->xhatSize, (float *)kf->temp_matrix_data1);
 8001442: 687b         	ldr	r3, [r7, #0x4]
 8001444: f103 00b0    	add.w	r0, r3, #0xb0
 8001448: 687b         	ldr	r3, [r7, #0x4]
 800144a: 7b1b         	ldrb	r3, [r3, #0xc]
 800144c: 4619         	mov	r1, r3
 800144e: 687b         	ldr	r3, [r7, #0x4]
 8001450: 7b1b         	ldrb	r3, [r3, #0xc]
 8001452: 461a         	mov	r2, r3
 8001454: 687b         	ldr	r3, [r7, #0x4]
 8001456: f8d3 3128    	ldr.w	r3, [r3, #0x128]
 800145a: f011 ffab    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x11f56
; 	Matrix_Init(&kf->temp_vector, kf->xhatSize, 1, (float *)kf->temp_vector_data);
 800145e: 687b         	ldr	r3, [r7, #0x4]
 8001460: f103 00b8    	add.w	r0, r3, #0xb8
 8001464: 687b         	ldr	r3, [r7, #0x4]
 8001466: 7b1b         	ldrb	r3, [r3, #0xc]
 8001468: 4619         	mov	r1, r3
 800146a: 687b         	ldr	r3, [r7, #0x4]
 800146c: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 8001470: 2201         	movs	r2, #0x1
 8001472: f011 ff9f    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x11f3e
; 	Matrix_Init(&kf->temp_vector1, kf->xhatSize, 1, (float *)kf->temp_vector_data1);
 8001476: 687b         	ldr	r3, [r7, #0x4]
 8001478: f103 00c0    	add.w	r0, r3, #0xc0
 800147c: 687b         	ldr	r3, [r7, #0x4]
 800147e: 7b1b         	ldrb	r3, [r3, #0xc]
 8001480: 4619         	mov	r1, r3
 8001482: 687b         	ldr	r3, [r7, #0x4]
 8001484: f8d3 3130    	ldr.w	r3, [r3, #0x130]
 8001488: 2201         	movs	r2, #0x1
 800148a: f011 ff93    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x11f26
; 	kf->SkipEq1 = 0;
 800148e: 687b         	ldr	r3, [r7, #0x4]
 8001490: 2200         	movs	r2, #0x0
 8001492: f883 2028    	strb.w	r2, [r3, #0x28]
; 	kf->SkipEq2 = 0;
 8001496: 687b         	ldr	r3, [r7, #0x4]
 8001498: 2200         	movs	r2, #0x0
 800149a: f883 2029    	strb.w	r2, [r3, #0x29]
; 	kf->SkipEq3 = 0;
 800149e: 687b         	ldr	r3, [r7, #0x4]
 80014a0: 2200         	movs	r2, #0x0
 80014a2: f883 202a    	strb.w	r2, [r3, #0x2a]
; 	kf->SkipEq4 = 0;
 80014a6: 687b         	ldr	r3, [r7, #0x4]
 80014a8: 2200         	movs	r2, #0x0
 80014aa: f883 202b    	strb.w	r2, [r3, #0x2b]
; 	kf->SkipEq5 = 0;
 80014ae: 687b         	ldr	r3, [r7, #0x4]
 80014b0: 2200         	movs	r2, #0x0
 80014b2: f883 202c    	strb.w	r2, [r3, #0x2c]
; }
 80014b6: bf00         	nop
 80014b8: 3708         	adds	r7, #0x8
 80014ba: 46bd         	mov	sp, r7
 80014bc: bd80         	pop	{r7, pc}
 80014be: bf00         	nop

080014c0 <$d>:
 80014c0: ec 32 00 24  	.word	0x240032ec

080014c4 <Kalman_Filter_Measure>:
; {
 80014c4: b580         	push	{r7, lr}
 80014c6: b082         	sub	sp, #0x8
 80014c8: af00         	add	r7, sp, #0x0
 80014ca: 6078         	str	r0, [r7, #0x4]
; 	if (kf->UseAutoAdjustment != 0) {
 80014cc: 687b         	ldr	r3, [r7, #0x4]
 80014ce: 7bdb         	ldrb	r3, [r3, #0xf]
 80014d0: 2b00         	cmp	r3, #0x0
 80014d2: d003         	beq	0x80014dc <Kalman_Filter_Measure+0x18> @ imm = #0x6
; 		H_K_R_Adjustment(kf);
 80014d4: 6878         	ldr	r0, [r7, #0x4]
 80014d6: f000 f97b    	bl	0x80017d0 <H_K_R_Adjustment> @ imm = #0x2f6
 80014da: e01b         	b	0x8001514 <Kalman_Filter_Measure+0x50> @ imm = #0x36
; 		memcpy(kf->z_data, kf->MeasuredVector, sizeof_float * kf->zSize);
 80014dc: 687b         	ldr	r3, [r7, #0x4]
 80014de: f8d3 00f4    	ldr.w	r0, [r3, #0xf4]
 80014e2: 687b         	ldr	r3, [r7, #0x4]
 80014e4: 6859         	ldr	r1, [r3, #0x4]
 80014e6: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800153c <Kalman_Filter_Measure+0x78>
 80014e8: 881b         	ldrh	r3, [r3]
 80014ea: 461a         	mov	r2, r3
 80014ec: 687b         	ldr	r3, [r7, #0x4]
 80014ee: 7b9b         	ldrb	r3, [r3, #0xe]
 80014f0: fb02 f303    	mul	r3, r2, r3
 80014f4: 461a         	mov	r2, r3
 80014f6: f027 fdfd    	bl	0x80290f4 <memcpy>      @ imm = #0x27bfa
; 		memset(kf->MeasuredVector, 0, sizeof_float * kf->zSize);
 80014fa: 687b         	ldr	r3, [r7, #0x4]
 80014fc: 6858         	ldr	r0, [r3, #0x4]
 80014fe: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800153c <Kalman_Filter_Measure+0x78>
 8001500: 881b         	ldrh	r3, [r3]
 8001502: 461a         	mov	r2, r3
 8001504: 687b         	ldr	r3, [r7, #0x4]
 8001506: 7b9b         	ldrb	r3, [r3, #0xe]
 8001508: fb02 f303    	mul	r3, r2, r3
 800150c: 461a         	mov	r2, r3
 800150e: 2100         	movs	r1, #0x0
 8001510: f027 fdfe    	bl	0x8029110 <memset>      @ imm = #0x27bfc
; 	memcpy(kf->u_data, kf->ControlVector, sizeof_float * kf->uSize);
 8001514: 687b         	ldr	r3, [r7, #0x4]
 8001516: f8d3 00f0    	ldr.w	r0, [r3, #0xf0]
 800151a: 687b         	ldr	r3, [r7, #0x4]
 800151c: 6899         	ldr	r1, [r3, #0x8]
 800151e: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800153c <Kalman_Filter_Measure+0x78>
 8001520: 881b         	ldrh	r3, [r3]
 8001522: 461a         	mov	r2, r3
 8001524: 687b         	ldr	r3, [r7, #0x4]
 8001526: 7b5b         	ldrb	r3, [r3, #0xd]
 8001528: fb02 f303    	mul	r3, r2, r3
 800152c: 461a         	mov	r2, r3
 800152e: f027 fde1    	bl	0x80290f4 <memcpy>      @ imm = #0x27bc2
; }
 8001532: bf00         	nop
 8001534: 3708         	adds	r7, #0x8
 8001536: 46bd         	mov	sp, r7
 8001538: bd80         	pop	{r7, pc}
 800153a: bf00         	nop

0800153c <$d>:
 800153c: ec 32 00 24  	.word	0x240032ec

08001540 <Kalman_Filter_Update>:
; {
 8001540: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8001544: b08a         	sub	sp, #0x28
 8001546: af00         	add	r7, sp, #0x0
 8001548: 6178         	str	r0, [r7, #0x14]
; 	QEKF_INS_t *QEKF_INS = CONTAINER_OF(kf, QEKF_INS_t, IMU_QuaternionEKF);
 800154a: 697b         	ldr	r3, [r7, #0x14]
 800154c: 3b04         	subs	r3, #0x4
 800154e: 623b         	str	r3, [r7, #0x20]
; 	Kalman_Filter_Measure(kf);
 8001550: 6978         	ldr	r0, [r7, #0x14]
 8001552: f7ff ffb7    	bl	0x80014c4 <Kalman_Filter_Measure> @ imm = #-0x92
; 	if (kf->User_Func0_f != NULL) {
 8001556: 697b         	ldr	r3, [r7, #0x14]
 8001558: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
 800155c: 2b00         	cmp	r3, #0x0
 800155e: d004         	beq	0x800156a <Kalman_Filter_Update+0x2a> @ imm = #0x8
; 		kf->User_Func0_f(kf);
 8001560: 697b         	ldr	r3, [r7, #0x14]
 8001562: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
 8001566: 6978         	ldr	r0, [r7, #0x14]
 8001568: 4798         	blx	r3
; 	Kalman_Filter_xhatMinusUpdate(kf);
 800156a: 6978         	ldr	r0, [r7, #0x14]
 800156c: f019 fe57    	bl	0x801b21e <Kalman_Filter_xhatMinusUpdate> @ imm = #0x19cae
; 	if (kf->User_Func1_f != NULL) {
 8001570: 697b         	ldr	r3, [r7, #0x14]
 8001572: f8d3 30d0    	ldr.w	r3, [r3, #0xd0]
 8001576: 2b00         	cmp	r3, #0x0
 8001578: d004         	beq	0x8001584 <Kalman_Filter_Update+0x44> @ imm = #0x8
; 		kf->User_Func1_f(kf);
 800157a: 697b         	ldr	r3, [r7, #0x14]
 800157c: f8d3 30d0    	ldr.w	r3, [r3, #0xd0]
 8001580: 6978         	ldr	r0, [r7, #0x14]
 8001582: 4798         	blx	r3
; 	Kalman_Filter_PminusUpdate(kf);
 8001584: 6978         	ldr	r0, [r7, #0x14]
 8001586: f019 feb0    	bl	0x801b2ea <Kalman_Filter_PminusUpdate> @ imm = #0x19d60
; 	if (kf->User_Func2_f != NULL) {
 800158a: 697b         	ldr	r3, [r7, #0x14]
 800158c: f8d3 30d4    	ldr.w	r3, [r3, #0xd4]
 8001590: 2b00         	cmp	r3, #0x0
 8001592: d004         	beq	0x800159e <Kalman_Filter_Update+0x5e> @ imm = #0x8
; 		kf->User_Func2_f(kf);
 8001594: 697b         	ldr	r3, [r7, #0x14]
 8001596: f8d3 30d4    	ldr.w	r3, [r3, #0xd4]
 800159a: 6978         	ldr	r0, [r7, #0x14]
 800159c: 4798         	blx	r3
; 	if (kf->MeasurementValidNum != 0 || kf->UseAutoAdjustment == 0) {
 800159e: 697b         	ldr	r3, [r7, #0x14]
 80015a0: 7c1b         	ldrb	r3, [r3, #0x10]
 80015a2: 2b00         	cmp	r3, #0x0
 80015a4: d103         	bne	0x80015ae <Kalman_Filter_Update+0x6e> @ imm = #0x6
 80015a6: 697b         	ldr	r3, [r7, #0x14]
 80015a8: 7bdb         	ldrb	r3, [r3, #0xf]
 80015aa: 2b00         	cmp	r3, #0x0
 80015ac: d17c         	bne	0x80016a8 <Kalman_Filter_Update+0x168> @ imm = #0xf8
; 		Kalman_Filter_SetK(kf);
 80015ae: 6978         	ldr	r0, [r7, #0x14]
 80015b0: f019 fef2    	bl	0x801b398 <Kalman_Filter_SetK> @ imm = #0x19de4
; 		int start_us = k_cyc_to_us_near32(k_cycle_get_32());
 80015b4: f019 fcfa    	bl	0x801afac <k_cycle_get_32> @ imm = #0x199f4
 80015b8: 4603         	mov	r3, r0
 80015ba: f513 7f8a    	cmn.w	r3, #0x114
 80015be: d80a         	bhi	0x80015d6 <Kalman_Filter_Update+0x96> @ imm = #0x14
 80015c0: f019 fcf4    	bl	0x801afac <k_cycle_get_32> @ imm = #0x199e8
 80015c4: 4603         	mov	r3, r0
 80015c6: f203 1313    	addw	r3, r3, #0x113
 80015ca: 085b         	lsrs	r3, r3, #0x1
 80015cc: 4a7e         	ldr	r2, [pc, #0x1f8]        @ 0x80017c8 <Kalman_Filter_Update+0x288>
 80015ce: fba2 2303    	umull	r2, r3, r2, r3
 80015d2: 09db         	lsrs	r3, r3, #0x7
 80015d4: e018         	b	0x8001608 <Kalman_Filter_Update+0xc8> @ imm = #0x30
 80015d6: f019 fce9    	bl	0x801afac <k_cycle_get_32> @ imm = #0x199d2
 80015da: 4603         	mov	r3, r0
 80015dc: 2200         	movs	r2, #0x0
 80015de: 4698         	mov	r8, r3
 80015e0: 4691         	mov	r9, r2
 80015e2: f240 1313    	movw	r3, #0x113
 80015e6: eb18 0303    	adds.w	r3, r8, r3
 80015ea: 60bb         	str	r3, [r7, #0x8]
 80015ec: f149 0300    	adc	r3, r9, #0x0
 80015f0: 60fb         	str	r3, [r7, #0xc]
 80015f2: f240 2226    	movw	r2, #0x226
 80015f6: f04f 0300    	mov.w	r3, #0x0
 80015fa: e9d7 0102    	ldrd	r0, r1, [r7, #8]
 80015fe: f7fe feb7    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x1292
 8001602: 4602         	mov	r2, r0
 8001604: 460b         	mov	r3, r1
 8001606: 4613         	mov	r3, r2
 8001608: 61fb         	str	r3, [r7, #0x1c]
; 		if (kf->User_Func3_f != NULL) {
 800160a: 697b         	ldr	r3, [r7, #0x14]
 800160c: f8d3 30d8    	ldr.w	r3, [r3, #0xd8]
 8001610: 2b00         	cmp	r3, #0x0
 8001612: d004         	beq	0x800161e <Kalman_Filter_Update+0xde> @ imm = #0x8
; 			kf->User_Func3_f(kf);
 8001614: 697b         	ldr	r3, [r7, #0x14]
 8001616: f8d3 30d8    	ldr.w	r3, [r3, #0xd8]
 800161a: 6978         	ldr	r0, [r7, #0x14]
 800161c: 4798         	blx	r3
; 		int end_us = k_cyc_to_us_near32(k_cycle_get_32());
 800161e: f019 fcc5    	bl	0x801afac <k_cycle_get_32> @ imm = #0x1998a
 8001622: 4603         	mov	r3, r0
 8001624: f513 7f8a    	cmn.w	r3, #0x114
 8001628: d80a         	bhi	0x8001640 <Kalman_Filter_Update+0x100> @ imm = #0x14
 800162a: f019 fcbf    	bl	0x801afac <k_cycle_get_32> @ imm = #0x1997e
 800162e: 4603         	mov	r3, r0
 8001630: f203 1313    	addw	r3, r3, #0x113
 8001634: 085b         	lsrs	r3, r3, #0x1
 8001636: 4a64         	ldr	r2, [pc, #0x190]        @ 0x80017c8 <Kalman_Filter_Update+0x288>
 8001638: fba2 2303    	umull	r2, r3, r2, r3
 800163c: 09db         	lsrs	r3, r3, #0x7
 800163e: e016         	b	0x800166e <Kalman_Filter_Update+0x12e> @ imm = #0x2c
 8001640: f019 fcb4    	bl	0x801afac <k_cycle_get_32> @ imm = #0x19968
 8001644: 4603         	mov	r3, r0
 8001646: 2200         	movs	r2, #0x0
 8001648: 461c         	mov	r4, r3
 800164a: 4615         	mov	r5, r2
 800164c: f240 1313    	movw	r3, #0x113
 8001650: eb14 0a03    	adds.w	r10, r4, r3
 8001654: f145 0b00    	adc	r11, r5, #0x0
 8001658: f240 2226    	movw	r2, #0x226
 800165c: f04f 0300    	mov.w	r3, #0x0
 8001660: 4650         	mov	r0, r10
 8001662: 4659         	mov	r1, r11
 8001664: f7fe fe84    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x12f8
 8001668: 4602         	mov	r2, r0
 800166a: 460b         	mov	r3, r1
 800166c: 4613         	mov	r3, r2
 800166e: 61bb         	str	r3, [r7, #0x18]
; 		QEKF_INS->UpdateTime = end_us - start_us;
 8001670: 69ba         	ldr	r2, [r7, #0x18]
 8001672: 69fb         	ldr	r3, [r7, #0x1c]
 8001674: 1ad3         	subs	r3, r2, r3
 8001676: 17da         	asrs	r2, r3, #0x1f
 8001678: 603b         	str	r3, [r7]
 800167a: 607a         	str	r2, [r7, #0x4]
 800167c: 6a3b         	ldr	r3, [r7, #0x20]
 800167e: e9d7 1200    	ldrd	r1, r2, [r7]
 8001682: e9c3 1278    	strd	r1, r2, [r3, #480]
; 		Kalman_Filter_xhatUpdate(kf);
 8001686: 6978         	ldr	r0, [r7, #0x14]
 8001688: f019 ff30    	bl	0x801b4ec <Kalman_Filter_xhatUpdate> @ imm = #0x19e60
; 		if (kf->User_Func4_f != NULL) {
 800168c: 697b         	ldr	r3, [r7, #0x14]
 800168e: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8001692: 2b00         	cmp	r3, #0x0
 8001694: d004         	beq	0x80016a0 <Kalman_Filter_Update+0x160> @ imm = #0x8
; 			kf->User_Func4_f(kf);
 8001696: 697b         	ldr	r3, [r7, #0x14]
 8001698: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 800169c: 6978         	ldr	r0, [r7, #0x14]
 800169e: 4798         	blx	r3
; 		Kalman_Filter_P_Update(kf);
 80016a0: 6978         	ldr	r0, [r7, #0x14]
 80016a2: f019 ff8e    	bl	0x801b5c2 <Kalman_Filter_P_Update> @ imm = #0x19f1c
; 	if (kf->MeasurementValidNum != 0 || kf->UseAutoAdjustment == 0) {
 80016a6: e023         	b	0x80016f0 <Kalman_Filter_Update+0x1b0> @ imm = #0x46
; 		memcpy(kf->xhat_data, kf->xhatminus_data, sizeof_float * kf->xhatSize);
 80016a8: 697b         	ldr	r3, [r7, #0x14]
 80016aa: f8d3 00e8    	ldr.w	r0, [r3, #0xe8]
 80016ae: 697b         	ldr	r3, [r7, #0x14]
 80016b0: f8d3 10ec    	ldr.w	r1, [r3, #0xec]
 80016b4: 4b45         	ldr	r3, [pc, #0x114]        @ 0x80017cc <Kalman_Filter_Update+0x28c>
 80016b6: 881b         	ldrh	r3, [r3]
 80016b8: 461a         	mov	r2, r3
 80016ba: 697b         	ldr	r3, [r7, #0x14]
 80016bc: 7b1b         	ldrb	r3, [r3, #0xc]
 80016be: fb02 f303    	mul	r3, r2, r3
 80016c2: 461a         	mov	r2, r3
 80016c4: f027 fd16    	bl	0x80290f4 <memcpy>      @ imm = #0x27a2c
; 		memcpy(kf->P_data, kf->Pminus_data, sizeof_float * kf->xhatSize * kf->xhatSize);
 80016c8: 697b         	ldr	r3, [r7, #0x14]
 80016ca: f8d3 00f8    	ldr.w	r0, [r3, #0xf8]
 80016ce: 697b         	ldr	r3, [r7, #0x14]
 80016d0: f8d3 10fc    	ldr.w	r1, [r3, #0xfc]
 80016d4: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x80017cc <Kalman_Filter_Update+0x28c>
 80016d6: 881b         	ldrh	r3, [r3]
 80016d8: 461a         	mov	r2, r3
 80016da: 697b         	ldr	r3, [r7, #0x14]
 80016dc: 7b1b         	ldrb	r3, [r3, #0xc]
 80016de: fb02 f303    	mul	r3, r2, r3
 80016e2: 697a         	ldr	r2, [r7, #0x14]
 80016e4: 7b12         	ldrb	r2, [r2, #0xc]
 80016e6: fb02 f303    	mul	r3, r2, r3
 80016ea: 461a         	mov	r2, r3
 80016ec: f027 fd02    	bl	0x80290f4 <memcpy>      @ imm = #0x27a04
; 	if (kf->User_Func5_f != NULL) {
 80016f0: 697b         	ldr	r3, [r7, #0x14]
 80016f2: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 80016f6: 2b00         	cmp	r3, #0x0
 80016f8: d004         	beq	0x8001704 <Kalman_Filter_Update+0x1c4> @ imm = #0x8
; 		kf->User_Func5_f(kf);
 80016fa: 697b         	ldr	r3, [r7, #0x14]
 80016fc: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 8001700: 6978         	ldr	r0, [r7, #0x14]
 8001702: 4798         	blx	r3
; 	for (uint8_t i = 0; i < kf->xhatSize; ++i) {
 8001704: 2300         	movs	r3, #0x0
 8001706: f887 3027    	strb.w	r3, [r7, #0x27]
 800170a: e037         	b	0x800177c <Kalman_Filter_Update+0x23c> @ imm = #0x6e
; 		if (kf->P_data[i * kf->xhatSize + i] < kf->StateMinVariance[i]) {
 800170c: 697b         	ldr	r3, [r7, #0x14]
 800170e: f8d3 20f8    	ldr.w	r2, [r3, #0xf8]
 8001712: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001716: 6979         	ldr	r1, [r7, #0x14]
 8001718: 7b09         	ldrb	r1, [r1, #0xc]
 800171a: fb03 f101    	mul	r1, r3, r1
 800171e: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001722: 440b         	add	r3, r1
 8001724: 009b         	lsls	r3, r3, #0x2
 8001726: 4413         	add	r3, r2
 8001728: ed93 7a00    	<unknown>
 800172c: 697b         	ldr	r3, [r7, #0x14]
 800172e: 6a1a         	ldr	r2, [r3, #0x20]
 8001730: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001734: 009b         	lsls	r3, r3, #0x2
 8001736: 4413         	add	r3, r2
 8001738: edd3 7a00    	<unknown>
 800173c: eeb4 7ae7    	<unknown>
 8001740: eef1 fa10    	<unknown>
 8001744: d515         	bpl	0x8001772 <Kalman_Filter_Update+0x232> @ imm = #0x2a
; 			kf->P_data[i * kf->xhatSize + i] = kf->StateMinVariance[i];
 8001746: 697b         	ldr	r3, [r7, #0x14]
 8001748: 6a1a         	ldr	r2, [r3, #0x20]
 800174a: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800174e: 009b         	lsls	r3, r3, #0x2
 8001750: 441a         	add	r2, r3
 8001752: 697b         	ldr	r3, [r7, #0x14]
 8001754: f8d3 10f8    	ldr.w	r1, [r3, #0xf8]
 8001758: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800175c: 6978         	ldr	r0, [r7, #0x14]
 800175e: 7b00         	ldrb	r0, [r0, #0xc]
 8001760: fb03 f000    	mul	r0, r3, r0
 8001764: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001768: 4403         	add	r3, r0
 800176a: 009b         	lsls	r3, r3, #0x2
 800176c: 440b         	add	r3, r1
 800176e: 6812         	ldr	r2, [r2]
 8001770: 601a         	str	r2, [r3]
; 	for (uint8_t i = 0; i < kf->xhatSize; ++i) {
 8001772: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001776: 3301         	adds	r3, #0x1
 8001778: f887 3027    	strb.w	r3, [r7, #0x27]
 800177c: 697b         	ldr	r3, [r7, #0x14]
 800177e: 7b1b         	ldrb	r3, [r3, #0xc]
 8001780: f897 2027    	ldrb.w	r2, [r7, #0x27]
 8001784: 429a         	cmp	r2, r3
 8001786: d3c1         	blo	0x800170c <Kalman_Filter_Update+0x1cc> @ imm = #-0x7e
; 	memcpy(kf->FilteredValue, kf->xhat_data, sizeof_float * kf->xhatSize);
 8001788: 697b         	ldr	r3, [r7, #0x14]
 800178a: 6818         	ldr	r0, [r3]
 800178c: 697b         	ldr	r3, [r7, #0x14]
 800178e: f8d3 10e8    	ldr.w	r1, [r3, #0xe8]
 8001792: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80017cc <Kalman_Filter_Update+0x28c>
 8001794: 881b         	ldrh	r3, [r3]
 8001796: 461a         	mov	r2, r3
 8001798: 697b         	ldr	r3, [r7, #0x14]
 800179a: 7b1b         	ldrb	r3, [r3, #0xc]
 800179c: fb02 f303    	mul	r3, r2, r3
 80017a0: 461a         	mov	r2, r3
 80017a2: f027 fca7    	bl	0x80290f4 <memcpy>      @ imm = #0x2794e
; 	if (kf->User_Func6_f != NULL) {
 80017a6: 697b         	ldr	r3, [r7, #0x14]
 80017a8: f8d3 30e4    	ldr.w	r3, [r3, #0xe4]
 80017ac: 2b00         	cmp	r3, #0x0
 80017ae: d004         	beq	0x80017ba <Kalman_Filter_Update+0x27a> @ imm = #0x8
; 		kf->User_Func6_f(kf);
 80017b0: 697b         	ldr	r3, [r7, #0x14]
 80017b2: f8d3 30e4    	ldr.w	r3, [r3, #0xe4]
 80017b6: 6978         	ldr	r0, [r7, #0x14]
 80017b8: 4798         	blx	r3
; 	return kf->FilteredValue;
 80017ba: 697b         	ldr	r3, [r7, #0x14]
 80017bc: 681b         	ldr	r3, [r3]
; }
 80017be: 4618         	mov	r0, r3
 80017c0: 3728         	adds	r7, #0x28
 80017c2: 46bd         	mov	sp, r7
 80017c4: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

080017c8 <$d>:
 80017c8: 73 07 28 77  	.word	0x77280773
 80017cc: ec 32 00 24  	.word	0x240032ec

080017d0 <H_K_R_Adjustment>:
; {
 80017d0: b590         	push	{r4, r7, lr}
 80017d2: b085         	sub	sp, #0x14
 80017d4: af00         	add	r7, sp, #0x0
 80017d6: 6078         	str	r0, [r7, #0x4]
; 	kf->MeasurementValidNum = 0;
 80017d8: 687b         	ldr	r3, [r7, #0x4]
 80017da: 2200         	movs	r2, #0x0
 80017dc: 741a         	strb	r2, [r3, #0x10]
; 	memcpy(kf->z_data, kf->MeasuredVector, sizeof_float * kf->zSize);
 80017de: 687b         	ldr	r3, [r7, #0x4]
 80017e0: f8d3 00f4    	ldr.w	r0, [r3, #0xf4]
 80017e4: 687b         	ldr	r3, [r7, #0x4]
 80017e6: 6859         	ldr	r1, [r3, #0x4]
 80017e8: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x80019b8 <H_K_R_Adjustment+0x1e8>
 80017ea: 881b         	ldrh	r3, [r3]
 80017ec: 461a         	mov	r2, r3
 80017ee: 687b         	ldr	r3, [r7, #0x4]
 80017f0: 7b9b         	ldrb	r3, [r3, #0xe]
 80017f2: fb02 f303    	mul	r3, r2, r3
 80017f6: 461a         	mov	r2, r3
 80017f8: f027 fc7c    	bl	0x80290f4 <memcpy>      @ imm = #0x278f8
; 	memset(kf->MeasuredVector, 0, sizeof_float * kf->zSize);
 80017fc: 687b         	ldr	r3, [r7, #0x4]
 80017fe: 6858         	ldr	r0, [r3, #0x4]
 8001800: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x80019b8 <H_K_R_Adjustment+0x1e8>
 8001802: 881b         	ldrh	r3, [r3]
 8001804: 461a         	mov	r2, r3
 8001806: 687b         	ldr	r3, [r7, #0x4]
 8001808: 7b9b         	ldrb	r3, [r3, #0xe]
 800180a: fb02 f303    	mul	r3, r2, r3
 800180e: 461a         	mov	r2, r3
 8001810: 2100         	movs	r1, #0x0
 8001812: f027 fc7d    	bl	0x8029110 <memset>      @ imm = #0x278fa
; 	memset(kf->R_data, 0, sizeof_float * kf->zSize * kf->zSize);
 8001816: 687b         	ldr	r3, [r7, #0x4]
 8001818: f8d3 0118    	ldr.w	r0, [r3, #0x118]
 800181c: 4b66         	ldr	r3, [pc, #0x198]        @ 0x80019b8 <H_K_R_Adjustment+0x1e8>
 800181e: 881b         	ldrh	r3, [r3]
 8001820: 461a         	mov	r2, r3
 8001822: 687b         	ldr	r3, [r7, #0x4]
 8001824: 7b9b         	ldrb	r3, [r3, #0xe]
 8001826: fb02 f303    	mul	r3, r2, r3
 800182a: 687a         	ldr	r2, [r7, #0x4]
 800182c: 7b92         	ldrb	r2, [r2, #0xe]
 800182e: fb02 f303    	mul	r3, r2, r3
 8001832: 461a         	mov	r2, r3
 8001834: 2100         	movs	r1, #0x0
 8001836: f027 fc6b    	bl	0x8029110 <memset>      @ imm = #0x278d6
; 	memset(kf->H_data, 0, sizeof_float * kf->xhatSize * kf->zSize);
 800183a: 687b         	ldr	r3, [r7, #0x4]
 800183c: f8d3 010c    	ldr.w	r0, [r3, #0x10c]
 8001840: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x80019b8 <H_K_R_Adjustment+0x1e8>
 8001842: 881b         	ldrh	r3, [r3]
 8001844: 461a         	mov	r2, r3
 8001846: 687b         	ldr	r3, [r7, #0x4]
 8001848: 7b1b         	ldrb	r3, [r3, #0xc]
 800184a: fb02 f303    	mul	r3, r2, r3
 800184e: 687a         	ldr	r2, [r7, #0x4]
 8001850: 7b92         	ldrb	r2, [r2, #0xe]
 8001852: fb02 f303    	mul	r3, r2, r3
 8001856: 461a         	mov	r2, r3
 8001858: 2100         	movs	r1, #0x0
 800185a: f027 fc59    	bl	0x8029110 <memset>      @ imm = #0x278b2
; 	for (uint8_t i = 0; i < kf->zSize; ++i) {
 800185e: 2300         	movs	r3, #0x0
 8001860: 73fb         	strb	r3, [r7, #0xf]
 8001862: e048         	b	0x80018f6 <H_K_R_Adjustment+0x126> @ imm = #0x90
; 		if (kf->z_data[i] != 0) {
 8001864: 687b         	ldr	r3, [r7, #0x4]
 8001866: f8d3 20f4    	ldr.w	r2, [r3, #0xf4]
 800186a: 7bfb         	ldrb	r3, [r7, #0xf]
 800186c: 009b         	lsls	r3, r3, #0x2
 800186e: 4413         	add	r3, r2
 8001870: edd3 7a00    	<unknown>
 8001874: eef5 7a40    	<unknown>
 8001878: eef1 fa10    	<unknown>
 800187c: d038         	beq	0x80018f0 <H_K_R_Adjustment+0x120> @ imm = #0x70
; 			kf->z_data[kf->MeasurementValidNum] = kf->z_data[i];
 800187e: 687b         	ldr	r3, [r7, #0x4]
 8001880: f8d3 20f4    	ldr.w	r2, [r3, #0xf4]
 8001884: 7bfb         	ldrb	r3, [r7, #0xf]
 8001886: 009b         	lsls	r3, r3, #0x2
 8001888: 441a         	add	r2, r3
 800188a: 687b         	ldr	r3, [r7, #0x4]
 800188c: f8d3 10f4    	ldr.w	r1, [r3, #0xf4]
 8001890: 687b         	ldr	r3, [r7, #0x4]
 8001892: 7c1b         	ldrb	r3, [r3, #0x10]
 8001894: 009b         	lsls	r3, r3, #0x2
 8001896: 440b         	add	r3, r1
 8001898: 6812         	ldr	r2, [r2]
 800189a: 601a         	str	r2, [r3]
; 			kf->temp[kf->MeasurementValidNum] = i;
 800189c: 687b         	ldr	r3, [r7, #0x4]
 800189e: 6a5b         	ldr	r3, [r3, #0x24]
 80018a0: 687a         	ldr	r2, [r7, #0x4]
 80018a2: 7c12         	ldrb	r2, [r2, #0x10]
 80018a4: 4413         	add	r3, r2
 80018a6: 7bfa         	ldrb	r2, [r7, #0xf]
 80018a8: 701a         	strb	r2, [r3]
; 				   1] = kf->MeasurementDegree[i];
 80018aa: 687b         	ldr	r3, [r7, #0x4]
 80018ac: 699a         	ldr	r2, [r3, #0x18]
 80018ae: 7bfb         	ldrb	r3, [r7, #0xf]
 80018b0: 009b         	lsls	r3, r3, #0x2
 80018b2: 441a         	add	r2, r3
; 			kf->H_data[kf->xhatSize * kf->MeasurementValidNum + kf->MeasurementMap[i] -
 80018b4: 687b         	ldr	r3, [r7, #0x4]
 80018b6: f8d3 110c    	ldr.w	r1, [r3, #0x10c]
 80018ba: 687b         	ldr	r3, [r7, #0x4]
 80018bc: 7b1b         	ldrb	r3, [r3, #0xc]
 80018be: 4618         	mov	r0, r3
 80018c0: 687b         	ldr	r3, [r7, #0x4]
 80018c2: 7c1b         	ldrb	r3, [r3, #0x10]
 80018c4: fb00 f303    	mul	r3, r0, r3
 80018c8: 6878         	ldr	r0, [r7, #0x4]
 80018ca: 6944         	ldr	r4, [r0, #0x14]
 80018cc: 7bf8         	ldrb	r0, [r7, #0xf]
 80018ce: 4420         	add	r0, r4
 80018d0: 7800         	ldrb	r0, [r0]
 80018d2: 4403         	add	r3, r0
 80018d4: 4618         	mov	r0, r3
 80018d6: f06f 4340    	mvn	r3, #0xc0000000
 80018da: 4403         	add	r3, r0
 80018dc: 009b         	lsls	r3, r3, #0x2
 80018de: 440b         	add	r3, r1
; 				   1] = kf->MeasurementDegree[i];
 80018e0: 6812         	ldr	r2, [r2]
 80018e2: 601a         	str	r2, [r3]
; 			kf->MeasurementValidNum++;
 80018e4: 687b         	ldr	r3, [r7, #0x4]
 80018e6: 7c1b         	ldrb	r3, [r3, #0x10]
 80018e8: 3301         	adds	r3, #0x1
 80018ea: b2da         	uxtb	r2, r3
 80018ec: 687b         	ldr	r3, [r7, #0x4]
 80018ee: 741a         	strb	r2, [r3, #0x10]
; 	for (uint8_t i = 0; i < kf->zSize; ++i) {
 80018f0: 7bfb         	ldrb	r3, [r7, #0xf]
 80018f2: 3301         	adds	r3, #0x1
 80018f4: 73fb         	strb	r3, [r7, #0xf]
 80018f6: 687b         	ldr	r3, [r7, #0x4]
 80018f8: 7b9b         	ldrb	r3, [r3, #0xe]
 80018fa: 7bfa         	ldrb	r2, [r7, #0xf]
 80018fc: 429a         	cmp	r2, r3
 80018fe: d3b1         	blo	0x8001864 <H_K_R_Adjustment+0x94> @ imm = #-0x9e
; 	for (uint8_t i = 0; i < kf->MeasurementValidNum; ++i) {
 8001900: 2300         	movs	r3, #0x0
 8001902: 73bb         	strb	r3, [r7, #0xe]
 8001904: e019         	b	0x800193a <H_K_R_Adjustment+0x16a> @ imm = #0x32
; 			kf->MatR_DiagonalElements[kf->temp[i]];
 8001906: 687b         	ldr	r3, [r7, #0x4]
 8001908: 69da         	ldr	r2, [r3, #0x1c]
 800190a: 687b         	ldr	r3, [r7, #0x4]
 800190c: 6a59         	ldr	r1, [r3, #0x24]
 800190e: 7bbb         	ldrb	r3, [r7, #0xe]
 8001910: 440b         	add	r3, r1
 8001912: 781b         	ldrb	r3, [r3]
 8001914: 009b         	lsls	r3, r3, #0x2
 8001916: 441a         	add	r2, r3
; 		kf->R_data[i * kf->MeasurementValidNum + i] =
 8001918: 687b         	ldr	r3, [r7, #0x4]
 800191a: f8d3 1118    	ldr.w	r1, [r3, #0x118]
 800191e: 7bbb         	ldrb	r3, [r7, #0xe]
 8001920: 6878         	ldr	r0, [r7, #0x4]
 8001922: 7c00         	ldrb	r0, [r0, #0x10]
 8001924: fb03 f000    	mul	r0, r3, r0
 8001928: 7bbb         	ldrb	r3, [r7, #0xe]
 800192a: 4403         	add	r3, r0
 800192c: 009b         	lsls	r3, r3, #0x2
 800192e: 440b         	add	r3, r1
; 			kf->MatR_DiagonalElements[kf->temp[i]];
 8001930: 6812         	ldr	r2, [r2]
; 		kf->R_data[i * kf->MeasurementValidNum + i] =
 8001932: 601a         	str	r2, [r3]
; 	for (uint8_t i = 0; i < kf->MeasurementValidNum; ++i) {
 8001934: 7bbb         	ldrb	r3, [r7, #0xe]
 8001936: 3301         	adds	r3, #0x1
 8001938: 73bb         	strb	r3, [r7, #0xe]
 800193a: 687b         	ldr	r3, [r7, #0x4]
 800193c: 7c1b         	ldrb	r3, [r3, #0x10]
 800193e: 7bba         	ldrb	r2, [r7, #0xe]
 8001940: 429a         	cmp	r2, r3
 8001942: d3e0         	blo	0x8001906 <H_K_R_Adjustment+0x136> @ imm = #-0x40
; 	kf->H.numRows = kf->MeasurementValidNum;
 8001944: 687b         	ldr	r3, [r7, #0x4]
 8001946: 7c1b         	ldrb	r3, [r3, #0x10]
 8001948: 461a         	mov	r2, r3
 800194a: 687b         	ldr	r3, [r7, #0x4]
 800194c: f8a3 2078    	strh.w	r2, [r3, #0x78]
; 	kf->H.numCols = kf->xhatSize;
 8001950: 687b         	ldr	r3, [r7, #0x4]
 8001952: 7b1b         	ldrb	r3, [r3, #0xc]
 8001954: 461a         	mov	r2, r3
 8001956: 687b         	ldr	r3, [r7, #0x4]
 8001958: f8a3 207a    	strh.w	r2, [r3, #0x7a]
; 	kf->HT.numRows = kf->xhatSize;
 800195c: 687b         	ldr	r3, [r7, #0x4]
 800195e: 7b1b         	ldrb	r3, [r3, #0xc]
 8001960: 461a         	mov	r2, r3
 8001962: 687b         	ldr	r3, [r7, #0x4]
 8001964: f8a3 2080    	strh.w	r2, [r3, #0x80]
; 	kf->HT.numCols = kf->MeasurementValidNum;
 8001968: 687b         	ldr	r3, [r7, #0x4]
 800196a: 7c1b         	ldrb	r3, [r3, #0x10]
 800196c: 461a         	mov	r2, r3
 800196e: 687b         	ldr	r3, [r7, #0x4]
 8001970: f8a3 2082    	strh.w	r2, [r3, #0x82]
; 	kf->R.numRows = kf->MeasurementValidNum;
 8001974: 687b         	ldr	r3, [r7, #0x4]
 8001976: 7c1b         	ldrb	r3, [r3, #0x10]
 8001978: 461a         	mov	r2, r3
 800197a: 687b         	ldr	r3, [r7, #0x4]
 800197c: f8a3 2090    	strh.w	r2, [r3, #0x90]
; 	kf->R.numCols = kf->MeasurementValidNum;
 8001980: 687b         	ldr	r3, [r7, #0x4]
 8001982: 7c1b         	ldrb	r3, [r3, #0x10]
 8001984: 461a         	mov	r2, r3
 8001986: 687b         	ldr	r3, [r7, #0x4]
 8001988: f8a3 2092    	strh.w	r2, [r3, #0x92]
; 	kf->K.numRows = kf->xhatSize;
 800198c: 687b         	ldr	r3, [r7, #0x4]
 800198e: 7b1b         	ldrb	r3, [r3, #0xc]
 8001990: 461a         	mov	r2, r3
 8001992: 687b         	ldr	r3, [r7, #0x4]
 8001994: f8a3 2098    	strh.w	r2, [r3, #0x98]
; 	kf->K.numCols = kf->MeasurementValidNum;
 8001998: 687b         	ldr	r3, [r7, #0x4]
 800199a: 7c1b         	ldrb	r3, [r3, #0x10]
 800199c: 461a         	mov	r2, r3
 800199e: 687b         	ldr	r3, [r7, #0x4]
 80019a0: f8a3 209a    	strh.w	r2, [r3, #0x9a]
; 	kf->z.numRows = kf->MeasurementValidNum;
 80019a4: 687b         	ldr	r3, [r7, #0x4]
 80019a6: 7c1b         	ldrb	r3, [r3, #0x10]
 80019a8: 461a         	mov	r2, r3
 80019aa: 687b         	ldr	r3, [r7, #0x4]
 80019ac: f8a3 2048    	strh.w	r2, [r3, #0x48]
; }
 80019b0: bf00         	nop
 80019b2: 3714         	adds	r7, #0x14
 80019b4: 46bd         	mov	sp, r7
 80019b6: bd90         	pop	{r4, r7, pc}

080019b8 <$d>:
 80019b8: ec 32 00 24  	.word	0x240032ec

080019bc <IMU_QuaternionEKF_Init>:
; {
 80019bc: b580         	push	{r7, lr}
 80019be: b088         	sub	sp, #0x20
 80019c0: af00         	add	r7, sp, #0x0
 80019c2: 6178         	str	r0, [r7, #0x14]
 80019c4: ed87 0a04    	<unknown>
 80019c8: edc7 0a03    	<unknown>
 80019cc: ed87 1a02    	<unknown>
 80019d0: edc7 1a01    	<unknown>
 80019d4: ed87 2a00    	<unknown>
; 	QEKF_INS.Initialized = 1;
 80019d8: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 80019da: 2201         	movs	r2, #0x1
 80019dc: 701a         	strb	r2, [r3]
; 	QEKF_INS.Q1 = process_noise1;
 80019de: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 80019e0: 693b         	ldr	r3, [r7, #0x10]
 80019e2: f8c2 31b0    	str.w	r3, [r2, #0x1b0]
; 	QEKF_INS.Q2 = process_noise2;
 80019e6: 4a3f         	ldr	r2, [pc, #0xfc]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 80019e8: 68fb         	ldr	r3, [r7, #0xc]
 80019ea: f8c2 31b4    	str.w	r3, [r2, #0x1b4]
; 	QEKF_INS.R = measure_noise;
 80019ee: 4a3d         	ldr	r2, [pc, #0xf4]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 80019f0: 68bb         	ldr	r3, [r7, #0x8]
 80019f2: f8c2 31b8    	str.w	r3, [r2, #0x1b8]
; 	QEKF_INS.ChiSquareTestThreshold = 1e-8;
 80019f6: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 80019f8: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x8001ae8 <IMU_QuaternionEKF_Init+0x12c>
 80019fa: f8c3 21cc    	str.w	r2, [r3, #0x1cc]
; 	QEKF_INS.ConvergeFlag = 0;
 80019fe: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001a00: 2200         	movs	r2, #0x0
 8001a02: f883 2138    	strb.w	r2, [r3, #0x138]
; 	QEKF_INS.ErrorCount = 0;
 8001a06: 4937         	ldr	r1, [pc, #0xdc]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001a08: f04f 0200    	mov.w	r2, #0x0
 8001a0c: f04f 0300    	mov.w	r3, #0x0
 8001a10: e9c1 2350    	strd	r2, r3, [r1, #320]
; 	QEKF_INS.UpdateCount = 0;
 8001a14: 4933         	ldr	r1, [pc, #0xcc]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001a16: f04f 0200    	mov.w	r2, #0x0
 8001a1a: f04f 0300    	mov.w	r3, #0x0
 8001a1e: e9c1 2352    	strd	r2, r3, [r1, #328]
; 	if (lambda > 1) {
 8001a22: edd7 7a01    	<unknown>
 8001a26: eeb7 7a00    	<unknown>
 8001a2a: eef4 7ac7    	<unknown>
 8001a2e: eef1 fa10    	<unknown>
 8001a32: dd02         	ble	0x8001a3a <IMU_QuaternionEKF_Init+0x7e> @ imm = #0x4
; 		lambda = 1;
 8001a34: f04f 537e    	mov.w	r3, #0x3f800000
 8001a38: 607b         	str	r3, [r7, #0x4]
; 	QEKF_INS.lambda = lambda;
 8001a3a: 4a2a         	ldr	r2, [pc, #0xa8]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001a3c: 687b         	ldr	r3, [r7, #0x4]
 8001a3e: f8c2 31d0    	str.w	r3, [r2, #0x1d0]
; 	QEKF_INS.accLPFcoef = lpf;
 8001a42: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001a44: 683b         	ldr	r3, [r7]
 8001a46: f8c2 3190    	str.w	r3, [r2, #0x190]
; 	Kalman_Filter_Init(&QEKF_INS.IMU_QuaternionEKF, 6, 0, 3);
 8001a4a: 2303         	movs	r3, #0x3
 8001a4c: 2200         	movs	r2, #0x0
 8001a4e: 2106         	movs	r1, #0x6
 8001a50: 4826         	ldr	r0, [pc, #0x98]         @ 0x8001aec <IMU_QuaternionEKF_Init+0x130>
 8001a52: f7ff f92f    	bl	0x8000cb4 <Kalman_Filter_Init> @ imm = #-0xda2
; 	Matrix_Init(&QEKF_INS.ChiSquare, 1, 1, (float *)QEKF_INS.ChiSquare_Data);
 8001a56: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8001af0 <IMU_QuaternionEKF_Init+0x134>
 8001a58: 2201         	movs	r2, #0x1
 8001a5a: 2101         	movs	r1, #0x1
 8001a5c: 4825         	ldr	r0, [pc, #0x94]         @ 0x8001af4 <IMU_QuaternionEKF_Init+0x138>
 8001a5e: f011 fca9    	bl	0x80133b4 <arm_mat_init_f32> @ imm = #0x11952
; 	for (int i = 0; i < 4; i++) {
 8001a62: 2300         	movs	r3, #0x0
 8001a64: 61fb         	str	r3, [r7, #0x1c]
 8001a66: e00e         	b	0x8001a86 <IMU_QuaternionEKF_Init+0xca> @ imm = #0x1c
; 		QEKF_INS.IMU_QuaternionEKF.xhat_data[i] = init_quaternion[i];
 8001a68: 69fb         	ldr	r3, [r7, #0x1c]
 8001a6a: 009b         	lsls	r3, r3, #0x2
 8001a6c: 697a         	ldr	r2, [r7, #0x14]
 8001a6e: 441a         	add	r2, r3
 8001a70: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001a72: f8d3 10ec    	ldr.w	r1, [r3, #0xec]
 8001a76: 69fb         	ldr	r3, [r7, #0x1c]
 8001a78: 009b         	lsls	r3, r3, #0x2
 8001a7a: 440b         	add	r3, r1
 8001a7c: 6812         	ldr	r2, [r2]
 8001a7e: 601a         	str	r2, [r3]
; 	for (int i = 0; i < 4; i++) {
 8001a80: 69fb         	ldr	r3, [r7, #0x1c]
 8001a82: 3301         	adds	r3, #0x1
 8001a84: 61fb         	str	r3, [r7, #0x1c]
 8001a86: 69fb         	ldr	r3, [r7, #0x1c]
 8001a88: 2b03         	cmp	r3, #0x3
 8001a8a: dded         	ble	0x8001a68 <IMU_QuaternionEKF_Init+0xac> @ imm = #-0x26
; 	QEKF_INS.IMU_QuaternionEKF.User_Func0_f = IMU_QuaternionEKF_Observe;
 8001a8c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001a8e: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x8001af8 <IMU_QuaternionEKF_Init+0x13c>
 8001a90: f8c3 20d0    	str.w	r2, [r3, #0xd0]
; 	QEKF_INS.IMU_QuaternionEKF.User_Func1_f = IMU_QuaternionEKF_F_Linearization_P_Fading;
 8001a94: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001a96: 4a19         	ldr	r2, [pc, #0x64]         @ 0x8001afc <IMU_QuaternionEKF_Init+0x140>
 8001a98: f8c3 20d4    	str.w	r2, [r3, #0xd4]
; 	QEKF_INS.IMU_QuaternionEKF.User_Func2_f = IMU_QuaternionEKF_SetH;
 8001a9c: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001a9e: 4a18         	ldr	r2, [pc, #0x60]         @ 0x8001b00 <IMU_QuaternionEKF_Init+0x144>
 8001aa0: f8c3 20d8    	str.w	r2, [r3, #0xd8]
; 	QEKF_INS.IMU_QuaternionEKF.User_Func3_f = IMU_QuaternionEKF_xhatUpdate;
 8001aa4: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001aa6: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x8001b04 <IMU_QuaternionEKF_Init+0x148>
 8001aa8: f8c3 20dc    	str.w	r2, [r3, #0xdc]
; 	QEKF_INS.IMU_QuaternionEKF.SkipEq3 = TRUE;
 8001aac: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001aae: 2201         	movs	r2, #0x1
 8001ab0: f883 202e    	strb.w	r2, [r3, #0x2e]
; 	QEKF_INS.IMU_QuaternionEKF.SkipEq4 = TRUE;
 8001ab4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001ab6: 2201         	movs	r2, #0x1
 8001ab8: f883 202f    	strb.w	r2, [r3, #0x2f]
; 	memcpy(QEKF_INS.IMU_QuaternionEKF.F_data, IMU_QuaternionEKF_F, sizeof(IMU_QuaternionEKF_F));
 8001abc: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001abe: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001ac2: 2290         	movs	r2, #0x90
 8001ac4: 4910         	ldr	r1, [pc, #0x40]         @ 0x8001b08 <IMU_QuaternionEKF_Init+0x14c>
 8001ac6: 4618         	mov	r0, r3
 8001ac8: f027 fb14    	bl	0x80290f4 <memcpy>      @ imm = #0x27628
; 	memcpy(QEKF_INS.IMU_QuaternionEKF.P_data, IMU_QuaternionEKF_P, sizeof(IMU_QuaternionEKF_P));
 8001acc: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8001ae4 <IMU_QuaternionEKF_Init+0x128>
 8001ace: f8d3 30fc    	ldr.w	r3, [r3, #0xfc]
 8001ad2: 2290         	movs	r2, #0x90
 8001ad4: 490d         	ldr	r1, [pc, #0x34]         @ 0x8001b0c <IMU_QuaternionEKF_Init+0x150>
 8001ad6: 4618         	mov	r0, r3
 8001ad8: f027 fb0c    	bl	0x80290f4 <memcpy>      @ imm = #0x27618
; }
 8001adc: bf00         	nop
 8001ade: 3720         	adds	r7, #0x20
 8001ae0: 46bd         	mov	sp, r7
 8001ae2: bd80         	pop	{r7, pc}

08001ae4 <$d>:
 8001ae4: a0 0d 00 24  	.word	0x24000da0
 8001ae8: 77 cc 2b 32  	.word	0x322bcc77
 8001aec: a4 0d 00 24  	.word	0x24000da4
 8001af0: 68 0f 00 24  	.word	0x24000f68
 8001af4: 60 0f 00 24  	.word	0x24000f60
 8001af8: 19 2d 00 08  	.word	0x08002d19
 8001afc: 51 22 00 08  	.word	0x08002251
 8001b00: 0d 25 00 08  	.word	0x0800250d
 8001b04: 71 26 00 08  	.word	0x08002671
 8001b08: 18 cd 02 08  	.word	0x0802cd18
 8001b0c: 8c 05 00 24  	.word	0x2400058c

08001b10 <IMU_QuaternionEKF_Update>:
; {
 8001b10: b5b0         	push	{r4, r5, r7, lr}
 8001b12: b08a         	sub	sp, #0x28
 8001b14: af00         	add	r7, sp, #0x0
 8001b16: ed87 0a07    	<unknown>
 8001b1a: edc7 0a06    	<unknown>
 8001b1e: ed87 1a05    	<unknown>
 8001b22: edc7 1a04    	<unknown>
 8001b26: ed87 2a03    	<unknown>
 8001b2a: edc7 2a02    	<unknown>
 8001b2e: ed87 3a01    	<unknown>
 8001b32: edc7 3a00    	<unknown>
; 	QEKF_INS.dt = gyro_dt;
 8001b36: 4ab5         	ldr	r2, [pc, #0x2d4]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001b38: 683b         	ldr	r3, [r7]
 8001b3a: f8c2 31bc    	str.w	r3, [r2, #0x1bc]
; 	QEKF_INS.Gyro[0] = gx - QEKF_INS.GyroBias[0];
 8001b3e: 4bb3         	ldr	r3, [pc, #0x2cc]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001b40: edd3 7a58    	<unknown>
 8001b44: ed97 7a07    	<unknown>
 8001b48: ee77 7a67    	<unknown>
 8001b4c: 4baf         	ldr	r3, [pc, #0x2bc]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001b4e: edc3 7a5b    	<unknown>
; 	QEKF_INS.Gyro[1] = gy - QEKF_INS.GyroBias[1];
 8001b52: 4bae         	ldr	r3, [pc, #0x2b8]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001b54: edd3 7a59    	<unknown>
 8001b58: ed97 7a06    	<unknown>
 8001b5c: ee77 7a67    	<unknown>
 8001b60: 4baa         	ldr	r3, [pc, #0x2a8]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001b62: edc3 7a5c    	<unknown>
; 	QEKF_INS.Gyro[2] = gz - QEKF_INS.GyroBias[2];
 8001b66: 4ba9         	ldr	r3, [pc, #0x2a4]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001b68: edd3 7a5a    	<unknown>
 8001b6c: ed97 7a05    	<unknown>
 8001b70: ee77 7a67    	<unknown>
 8001b74: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001b76: edc3 7a5d    	<unknown>
; 	halfgxdt = 0.5f * QEKF_INS.Gyro[0] * gyro_dt;
 8001b7a: 4ba4         	ldr	r3, [pc, #0x290]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001b7c: edd3 7a5b    	<unknown>
 8001b80: eeb6 7a00    	<unknown>
 8001b84: ee27 7a87    	<unknown>
 8001b88: edd7 7a00    	<unknown>
 8001b8c: ee67 7a27    	<unknown>
 8001b90: 4b9f         	ldr	r3, [pc, #0x27c]        @ 0x8001e10 <IMU_QuaternionEKF_Update+0x300>
 8001b92: edc3 7a00    	<unknown>
; 	halfgydt = 0.5f * QEKF_INS.Gyro[1] * gyro_dt;
 8001b96: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001b98: edd3 7a5c    	<unknown>
 8001b9c: eeb6 7a00    	<unknown>
 8001ba0: ee27 7a87    	<unknown>
 8001ba4: edd7 7a00    	<unknown>
 8001ba8: ee67 7a27    	<unknown>
 8001bac: 4b99         	ldr	r3, [pc, #0x264]        @ 0x8001e14 <IMU_QuaternionEKF_Update+0x304>
 8001bae: edc3 7a00    	<unknown>
; 	halfgzdt = 0.5f * QEKF_INS.Gyro[2] * gyro_dt;
 8001bb2: 4b96         	ldr	r3, [pc, #0x258]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001bb4: edd3 7a5d    	<unknown>
 8001bb8: eeb6 7a00    	<unknown>
 8001bbc: ee27 7a87    	<unknown>
 8001bc0: edd7 7a00    	<unknown>
 8001bc4: ee67 7a27    	<unknown>
 8001bc8: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8001e18 <IMU_QuaternionEKF_Update+0x308>
 8001bca: edc3 7a00    	<unknown>
; 	memcpy(QEKF_INS.IMU_QuaternionEKF.F_data, IMU_QuaternionEKF_F, sizeof(IMU_QuaternionEKF_F));
 8001bce: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001bd0: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001bd4: 2290         	movs	r2, #0x90
 8001bd6: 4991         	ldr	r1, [pc, #0x244]        @ 0x8001e1c <IMU_QuaternionEKF_Update+0x30c>
 8001bd8: 4618         	mov	r0, r3
 8001bda: f027 fa8b    	bl	0x80290f4 <memcpy>      @ imm = #0x27516
; 	QEKF_INS.IMU_QuaternionEKF.F_data[1] = -halfgxdt;
 8001bde: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x8001e10 <IMU_QuaternionEKF_Update+0x300>
 8001be0: edd3 7a00    	<unknown>
 8001be4: 4b89         	ldr	r3, [pc, #0x224]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001be6: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001bea: 3304         	adds	r3, #0x4
 8001bec: eef1 7a67    	<unknown>
 8001bf0: edc3 7a00    	<unknown>
; 	QEKF_INS.IMU_QuaternionEKF.F_data[2] = -halfgydt;
 8001bf4: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8001e14 <IMU_QuaternionEKF_Update+0x304>
 8001bf6: edd3 7a00    	<unknown>
 8001bfa: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001bfc: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c00: 3308         	adds	r3, #0x8
 8001c02: eef1 7a67    	<unknown>
 8001c06: edc3 7a00    	<unknown>
; 	QEKF_INS.IMU_QuaternionEKF.F_data[3] = -halfgzdt;
 8001c0a: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x8001e18 <IMU_QuaternionEKF_Update+0x308>
 8001c0c: edd3 7a00    	<unknown>
 8001c10: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001c12: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c16: 330c         	adds	r3, #0xc
 8001c18: eef1 7a67    	<unknown>
 8001c1c: edc3 7a00    	<unknown>
; 	QEKF_INS.IMU_QuaternionEKF.F_data[6] = halfgxdt;
 8001c20: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001c22: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c26: 3318         	adds	r3, #0x18
 8001c28: 4a79         	ldr	r2, [pc, #0x1e4]        @ 0x8001e10 <IMU_QuaternionEKF_Update+0x300>
 8001c2a: 6812         	ldr	r2, [r2]
 8001c2c: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[8] = halfgzdt;
 8001c2e: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001c30: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c34: 3320         	adds	r3, #0x20
 8001c36: 4a78         	ldr	r2, [pc, #0x1e0]        @ 0x8001e18 <IMU_QuaternionEKF_Update+0x308>
 8001c38: 6812         	ldr	r2, [r2]
 8001c3a: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[9] = -halfgydt;
 8001c3c: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8001e14 <IMU_QuaternionEKF_Update+0x304>
 8001c3e: edd3 7a00    	<unknown>
 8001c42: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001c44: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c48: 3324         	adds	r3, #0x24
 8001c4a: eef1 7a67    	<unknown>
 8001c4e: edc3 7a00    	<unknown>
; 	QEKF_INS.IMU_QuaternionEKF.F_data[12] = halfgydt;
 8001c52: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001c54: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c58: 3330         	adds	r3, #0x30
 8001c5a: 4a6e         	ldr	r2, [pc, #0x1b8]        @ 0x8001e14 <IMU_QuaternionEKF_Update+0x304>
 8001c5c: 6812         	ldr	r2, [r2]
 8001c5e: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[13] = -halfgzdt;
 8001c60: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x8001e18 <IMU_QuaternionEKF_Update+0x308>
 8001c62: edd3 7a00    	<unknown>
 8001c66: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001c68: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c6c: 3334         	adds	r3, #0x34
 8001c6e: eef1 7a67    	<unknown>
 8001c72: edc3 7a00    	<unknown>
; 	QEKF_INS.IMU_QuaternionEKF.F_data[15] = halfgxdt;
 8001c76: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001c78: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c7c: 333c         	adds	r3, #0x3c
 8001c7e: 4a64         	ldr	r2, [pc, #0x190]        @ 0x8001e10 <IMU_QuaternionEKF_Update+0x300>
 8001c80: 6812         	ldr	r2, [r2]
 8001c82: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[18] = halfgzdt;
 8001c84: 4b61         	ldr	r3, [pc, #0x184]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001c86: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c8a: 3348         	adds	r3, #0x48
 8001c8c: 4a62         	ldr	r2, [pc, #0x188]        @ 0x8001e18 <IMU_QuaternionEKF_Update+0x308>
 8001c8e: 6812         	ldr	r2, [r2]
 8001c90: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[19] = halfgydt;
 8001c92: 4b5e         	ldr	r3, [pc, #0x178]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001c94: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c98: 334c         	adds	r3, #0x4c
 8001c9a: 4a5e         	ldr	r2, [pc, #0x178]        @ 0x8001e14 <IMU_QuaternionEKF_Update+0x304>
 8001c9c: 6812         	ldr	r2, [r2]
 8001c9e: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[20] = -halfgxdt;
 8001ca0: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8001e10 <IMU_QuaternionEKF_Update+0x300>
 8001ca2: edd3 7a00    	<unknown>
 8001ca6: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001ca8: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001cac: 3350         	adds	r3, #0x50
 8001cae: eef1 7a67    	<unknown>
 8001cb2: edc3 7a00    	<unknown>
; 	if (QEKF_INS.UpdateCount == 0) // 如果是第一次进入,需要初始化低通滤波
 8001cb6: 4b55         	ldr	r3, [pc, #0x154]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001cb8: e9d3 2352    	ldrd	r2, r3, [r3, #328]
 8001cbc: 4313         	orrs	r3, r2
 8001cbe: d10b         	bne	0x8001cd8 <IMU_QuaternionEKF_Update+0x1c8> @ imm = #0x16
; 		QEKF_INS.Accel[0] = ax;
 8001cc0: 4a52         	ldr	r2, [pc, #0x148]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001cc2: 693b         	ldr	r3, [r7, #0x10]
 8001cc4: f8c2 3178    	str.w	r3, [r2, #0x178]
; 		QEKF_INS.Accel[1] = ay;
 8001cc8: 4a50         	ldr	r2, [pc, #0x140]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001cca: 68fb         	ldr	r3, [r7, #0xc]
 8001ccc: f8c2 317c    	str.w	r3, [r2, #0x17c]
; 		QEKF_INS.Accel[2] = az;
 8001cd0: 4a4e         	ldr	r2, [pc, #0x138]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001cd2: 68bb         	ldr	r3, [r7, #0x8]
 8001cd4: f8c2 3180    	str.w	r3, [r2, #0x180]
; 		QEKF_INS.Accel[0] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001cd8: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001cda: ed93 7a5e    	<unknown>
 8001cde: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001ce0: edd3 7a64    	<unknown>
 8001ce4: ee67 6a27    	<unknown>
 8001ce8: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001cea: ed93 7a64    	<unknown>
 8001cee: edd7 7a01    	<unknown>
 8001cf2: ee77 7a27    	<unknown>
 8001cf6: ee86 7aa7    	<unknown>
; 		ax * accel_dt / (accel_dt + QEKF_INS.accLPFcoef);
 8001cfa: edd7 6a04    	<unknown>
 8001cfe: edd7 7a01    	<unknown>
 8001d02: ee26 6aa7    	<unknown>
 8001d06: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001d08: edd3 6a64    	<unknown>
 8001d0c: edd7 7a01    	<unknown>
 8001d10: ee76 6aa7    	<unknown>
 8001d14: eec6 7a26    	<unknown>
; 		QEKF_INS.Accel[0] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001d18: ee77 7a27    	<unknown>
; 	QEKF_INS.Accel[0] =
 8001d1c: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001d1e: edc3 7a5e    	<unknown>
; 		QEKF_INS.Accel[1] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001d22: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001d24: ed93 7a5f    	<unknown>
 8001d28: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001d2a: edd3 7a64    	<unknown>
 8001d2e: ee67 6a27    	<unknown>
 8001d32: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001d34: ed93 7a64    	<unknown>
 8001d38: edd7 7a01    	<unknown>
 8001d3c: ee77 7a27    	<unknown>
 8001d40: ee86 7aa7    	<unknown>
; 		ay * accel_dt / (QEKF_INS.dt + QEKF_INS.accLPFcoef);
 8001d44: edd7 6a03    	<unknown>
 8001d48: edd7 7a01    	<unknown>
 8001d4c: ee26 6aa7    	<unknown>
 8001d50: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001d52: edd3 6a6f    	<unknown>
 8001d56: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001d58: edd3 7a64    	<unknown>
 8001d5c: ee76 6aa7    	<unknown>
 8001d60: eec6 7a26    	<unknown>
; 		QEKF_INS.Accel[1] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001d64: ee77 7a27    	<unknown>
; 	QEKF_INS.Accel[1] =
 8001d68: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001d6a: edc3 7a5f    	<unknown>
; 		QEKF_INS.Accel[2] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001d6e: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001d70: ed93 7a60    	<unknown>
 8001d74: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001d76: edd3 7a64    	<unknown>
 8001d7a: ee67 6a27    	<unknown>
 8001d7e: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001d80: ed93 7a64    	<unknown>
 8001d84: edd7 7a01    	<unknown>
 8001d88: ee77 7a27    	<unknown>
 8001d8c: ee86 7aa7    	<unknown>
; 		az * accel_dt / (accel_dt + QEKF_INS.accLPFcoef);
 8001d90: edd7 6a02    	<unknown>
 8001d94: edd7 7a01    	<unknown>
 8001d98: ee26 6aa7    	<unknown>
 8001d9c: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001d9e: edd3 6a64    	<unknown>
 8001da2: edd7 7a01    	<unknown>
 8001da6: ee76 6aa7    	<unknown>
 8001daa: eec6 7a26    	<unknown>
; 		QEKF_INS.Accel[2] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001dae: ee77 7a27    	<unknown>
; 	QEKF_INS.Accel[2] =
 8001db2: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001db4: edc3 7a60    	<unknown>
; 	accelInvNorm = invSqrt(QEKF_INS.Accel[0] * QEKF_INS.Accel[0] +
 8001db8: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001dba: ed93 7a5e    	<unknown>
 8001dbe: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001dc0: edd3 7a5e    	<unknown>
 8001dc4: ee27 7a27    	<unknown>
; 			       QEKF_INS.Accel[1] * QEKF_INS.Accel[1] +
 8001dc8: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001dca: edd3 6a5f    	<unknown>
 8001dce: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001dd0: edd3 7a5f    	<unknown>
 8001dd4: ee66 7aa7    	<unknown>
; 	accelInvNorm = invSqrt(QEKF_INS.Accel[0] * QEKF_INS.Accel[0] +
 8001dd8: ee37 7a27    	<unknown>
; 			       QEKF_INS.Accel[2] * QEKF_INS.Accel[2]);
 8001ddc: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001dde: edd3 6a60    	<unknown>
 8001de2: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8001e0c <IMU_QuaternionEKF_Update+0x2fc>
 8001de4: edd3 7a60    	<unknown>
 8001de8: ee66 7aa7    	<unknown>
; 	accelInvNorm = invSqrt(QEKF_INS.Accel[0] * QEKF_INS.Accel[0] +
 8001dec: ee77 7a27    	<unknown>
 8001df0: eeb0 0a67    	<unknown>
 8001df4: f000 ffb6    	bl	0x8002d64 <invSqrt>     @ imm = #0xf6c
 8001df8: eef0 7a40    	<unknown>
 8001dfc: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8001e20 <IMU_QuaternionEKF_Update+0x310>
 8001dfe: edc3 7a00    	<unknown>
; 	for (uint8_t i = 0; i < 3; ++i) {
 8001e02: 2300         	movs	r3, #0x0
 8001e04: f887 3027    	strb.w	r3, [r7, #0x27]
 8001e08: e026         	b	0x8001e58 <IMU_QuaternionEKF_Update+0x348> @ imm = #0x4c
 8001e0a: bf00         	nop

08001e0c <$d>:
 8001e0c: a0 0d 00 24  	.word	0x24000da0
 8001e10: b4 27 00 24  	.word	0x240027b4
 8001e14: b8 27 00 24  	.word	0x240027b8
 8001e18: bc 27 00 24  	.word	0x240027bc
 8001e1c: 18 cd 02 08  	.word	0x0802cd18
 8001e20: c0 27 00 24  	.word	0x240027c0

08001e24 <$t>:
; 			QEKF_INS.Accel[i] * accelInvNorm; // 用加速度向量更新量测值
 8001e24: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001e28: 4a38         	ldr	r2, [pc, #0xe0]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001e2a: 335e         	adds	r3, #0x5e
 8001e2c: 009b         	lsls	r3, r3, #0x2
 8001e2e: 4413         	add	r3, r2
 8001e30: ed93 7a00    	<unknown>
 8001e34: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8001f10 <IMU_QuaternionEKF_Update+0x400>
 8001e36: edd3 7a00    	<unknown>
; 		QEKF_INS.IMU_QuaternionEKF.MeasuredVector[i] =
 8001e3a: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001e3c: 689a         	ldr	r2, [r3, #0x8]
 8001e3e: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001e42: 009b         	lsls	r3, r3, #0x2
 8001e44: 4413         	add	r3, r2
; 			QEKF_INS.Accel[i] * accelInvNorm; // 用加速度向量更新量测值
 8001e46: ee67 7a27    	<unknown>
; 		QEKF_INS.IMU_QuaternionEKF.MeasuredVector[i] =
 8001e4a: edc3 7a00    	<unknown>
; 	for (uint8_t i = 0; i < 3; ++i) {
 8001e4e: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001e52: 3301         	adds	r3, #0x1
 8001e54: f887 3027    	strb.w	r3, [r7, #0x27]
 8001e58: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001e5c: 2b02         	cmp	r3, #0x2
 8001e5e: d9e1         	bls	0x8001e24 <IMU_QuaternionEKF_Update+0x314> @ imm = #-0x3e
; 	QEKF_INS.gyro_norm = 1.0f / invSqrt(QEKF_INS.Gyro[0] * QEKF_INS.Gyro[0] +
 8001e60: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001e62: ed93 7a5b    	<unknown>
 8001e66: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001e68: edd3 7a5b    	<unknown>
 8001e6c: ee27 7a27    	<unknown>
; 					    QEKF_INS.Gyro[1] * QEKF_INS.Gyro[1] +
 8001e70: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001e72: edd3 6a5c    	<unknown>
 8001e76: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001e78: edd3 7a5c    	<unknown>
 8001e7c: ee66 7aa7    	<unknown>
; 	QEKF_INS.gyro_norm = 1.0f / invSqrt(QEKF_INS.Gyro[0] * QEKF_INS.Gyro[0] +
 8001e80: ee37 7a27    	<unknown>
; 					    QEKF_INS.Gyro[2] * QEKF_INS.Gyro[2]);
 8001e84: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001e86: edd3 6a5d    	<unknown>
 8001e8a: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001e8c: edd3 7a5d    	<unknown>
 8001e90: ee66 7aa7    	<unknown>
; 	QEKF_INS.gyro_norm = 1.0f / invSqrt(QEKF_INS.Gyro[0] * QEKF_INS.Gyro[0] +
 8001e94: ee77 7a27    	<unknown>
 8001e98: eeb0 0a67    	<unknown>
 8001e9c: f000 ff62    	bl	0x8002d64 <invSqrt>     @ imm = #0xec4
 8001ea0: eeb0 7a40    	<unknown>
 8001ea4: eef7 6a00    	<unknown>
 8001ea8: eec6 7a87    	<unknown>
 8001eac: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001eae: edc3 7a65    	<unknown>
; 	QEKF_INS.accl_norm = 1.0f / accelInvNorm;
 8001eb2: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8001f10 <IMU_QuaternionEKF_Update+0x400>
 8001eb4: ed93 7a00    	<unknown>
 8001eb8: eef7 6a00    	<unknown>
 8001ebc: eec6 7a87    	<unknown>
 8001ec0: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001ec2: edc3 7a66    	<unknown>
; 	if (QEKF_INS.gyro_norm < 0.3f && QEKF_INS.accl_norm > 9.8f - 0.5f &&
 8001ec6: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001ec8: edd3 7a65    	<unknown>
 8001ecc: ed9f 7a11    	<unknown>
 8001ed0: eef4 7ac7    	<unknown>
 8001ed4: eef1 fa10    	<unknown>
 8001ed8: d522         	bpl	0x8001f20 <IMU_QuaternionEKF_Update+0x410> @ imm = #0x44
 8001eda: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001edc: edd3 7a66    	<unknown>
 8001ee0: ed9f 7a0d    	<unknown>
 8001ee4: eef4 7ac7    	<unknown>
 8001ee8: eef1 fa10    	<unknown>
 8001eec: dd18         	ble	0x8001f20 <IMU_QuaternionEKF_Update+0x410> @ imm = #0x30
; 	    QEKF_INS.accl_norm < 9.8f + 0.5f) {
 8001eee: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001ef0: edd3 7a66    	<unknown>
; 	if (QEKF_INS.gyro_norm < 0.3f && QEKF_INS.accl_norm > 9.8f - 0.5f &&
 8001ef4: ed9f 7a09    	<unknown>
 8001ef8: eef4 7ac7    	<unknown>
 8001efc: eef1 fa10    	<unknown>
 8001f00: d50e         	bpl	0x8001f20 <IMU_QuaternionEKF_Update+0x410> @ imm = #0x1c
; 		QEKF_INS.StableFlag = 1;
 8001f02: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8001f0c <IMU_QuaternionEKF_Update+0x3fc>
 8001f04: 2201         	movs	r2, #0x1
 8001f06: f883 2139    	strb.w	r2, [r3, #0x139]
 8001f0a: e00d         	b	0x8001f28 <IMU_QuaternionEKF_Update+0x418> @ imm = #0x1a

08001f0c <$d>:
 8001f0c: a0 0d 00 24  	.word	0x24000da0
 8001f10: c0 27 00 24  	.word	0x240027c0
 8001f14: 9a 99 99 3e  	.word	0x3e99999a
 8001f18: cd cc 14 41  	.word	0x4114cccd
 8001f1c: cd cc 24 41  	.word	0x4124cccd

08001f20 <$t>:
; 		QEKF_INS.StableFlag = 0;
 8001f20: 4bc5         	ldr	r3, [pc, #0x314]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f22: 2200         	movs	r2, #0x0
 8001f24: f883 2139    	strb.w	r2, [r3, #0x139]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[0] = QEKF_INS.Q1 * QEKF_INS.dt;
 8001f28: 4bc3         	ldr	r3, [pc, #0x30c]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f2a: ed93 7a6c    	<unknown>
 8001f2e: 4bc2         	ldr	r3, [pc, #0x308]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f30: edd3 7a6f    	<unknown>
 8001f34: 4bc0         	ldr	r3, [pc, #0x300]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f36: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001f3a: ee67 7a27    	<unknown>
 8001f3e: edc3 7a00    	<unknown>
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[7] = QEKF_INS.Q1 * QEKF_INS.dt;
 8001f42: 4bbd         	ldr	r3, [pc, #0x2f4]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f44: ed93 7a6c    	<unknown>
 8001f48: 4bbb         	ldr	r3, [pc, #0x2ec]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f4a: edd3 7a6f    	<unknown>
 8001f4e: 4bba         	ldr	r3, [pc, #0x2e8]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f50: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001f54: 331c         	adds	r3, #0x1c
 8001f56: ee67 7a27    	<unknown>
 8001f5a: edc3 7a00    	<unknown>
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[14] = QEKF_INS.Q1 * QEKF_INS.dt;
 8001f5e: 4bb6         	ldr	r3, [pc, #0x2d8]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f60: ed93 7a6c    	<unknown>
 8001f64: 4bb4         	ldr	r3, [pc, #0x2d0]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f66: edd3 7a6f    	<unknown>
 8001f6a: 4bb3         	ldr	r3, [pc, #0x2cc]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f6c: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001f70: 3338         	adds	r3, #0x38
 8001f72: ee67 7a27    	<unknown>
 8001f76: edc3 7a00    	<unknown>
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[21] = QEKF_INS.Q1 * QEKF_INS.dt;
 8001f7a: 4baf         	ldr	r3, [pc, #0x2bc]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f7c: ed93 7a6c    	<unknown>
 8001f80: 4bad         	ldr	r3, [pc, #0x2b4]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f82: edd3 7a6f    	<unknown>
 8001f86: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f88: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001f8c: 3354         	adds	r3, #0x54
 8001f8e: ee67 7a27    	<unknown>
 8001f92: edc3 7a00    	<unknown>
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[28] = QEKF_INS.Q2 * QEKF_INS.dt;
 8001f96: 4ba8         	ldr	r3, [pc, #0x2a0]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f98: ed93 7a6d    	<unknown>
 8001f9c: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001f9e: edd3 7a6f    	<unknown>
 8001fa2: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001fa4: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001fa8: 3370         	adds	r3, #0x70
 8001faa: ee67 7a27    	<unknown>
 8001fae: edc3 7a00    	<unknown>
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[35] = QEKF_INS.Q2 * QEKF_INS.dt;
 8001fb2: 4ba1         	ldr	r3, [pc, #0x284]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001fb4: ed93 7a6d    	<unknown>
 8001fb8: 4b9f         	ldr	r3, [pc, #0x27c]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001fba: edd3 7a6f    	<unknown>
 8001fbe: 4b9e         	ldr	r3, [pc, #0x278]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001fc0: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001fc4: 338c         	adds	r3, #0x8c
 8001fc6: ee67 7a27    	<unknown>
 8001fca: edc3 7a00    	<unknown>
; 	QEKF_INS.IMU_QuaternionEKF.R_data[0] = QEKF_INS.R;
 8001fce: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001fd0: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8001fd4: 4a98         	ldr	r2, [pc, #0x260]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001fd6: f8d2 21b8    	ldr.w	r2, [r2, #0x1b8]
 8001fda: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.R_data[4] = QEKF_INS.R;
 8001fdc: 4b96         	ldr	r3, [pc, #0x258]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001fde: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8001fe2: 3310         	adds	r3, #0x10
 8001fe4: 4a94         	ldr	r2, [pc, #0x250]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001fe6: f8d2 21b8    	ldr.w	r2, [r2, #0x1b8]
 8001fea: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.R_data[8] = QEKF_INS.R;
 8001fec: 4b92         	ldr	r3, [pc, #0x248]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001fee: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8001ff2: 3320         	adds	r3, #0x20
 8001ff4: 4a90         	ldr	r2, [pc, #0x240]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8001ff6: f8d2 21b8    	ldr.w	r2, [r2, #0x1b8]
 8001ffa: 601a         	str	r2, [r3]
; 	Kalman_Filter_Update(&QEKF_INS.IMU_QuaternionEKF);
 8001ffc: 488f         	ldr	r0, [pc, #0x23c]        @ 0x800223c <IMU_QuaternionEKF_Update+0x72c>
 8001ffe: f7ff fa9f    	bl	0x8001540 <Kalman_Filter_Update> @ imm = #-0xac2
; 	QEKF_INS.q[0] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[0];
 8002002: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002004: 685b         	ldr	r3, [r3, #0x4]
 8002006: 681b         	ldr	r3, [r3]
 8002008: 4a8b         	ldr	r2, [pc, #0x22c]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800200a: f8c2 3150    	str.w	r3, [r2, #0x150]
; 	QEKF_INS.q[1] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[1];
 800200e: 4b8a         	ldr	r3, [pc, #0x228]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002010: 685b         	ldr	r3, [r3, #0x4]
 8002012: 685b         	ldr	r3, [r3, #0x4]
 8002014: 4a88         	ldr	r2, [pc, #0x220]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002016: f8c2 3154    	str.w	r3, [r2, #0x154]
; 	QEKF_INS.q[2] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[2];
 800201a: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800201c: 685b         	ldr	r3, [r3, #0x4]
 800201e: 689b         	ldr	r3, [r3, #0x8]
 8002020: 4a85         	ldr	r2, [pc, #0x214]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002022: f8c2 3158    	str.w	r3, [r2, #0x158]
; 	QEKF_INS.q[3] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[3];
 8002026: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002028: 685b         	ldr	r3, [r3, #0x4]
 800202a: 68db         	ldr	r3, [r3, #0xc]
 800202c: 4a82         	ldr	r2, [pc, #0x208]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800202e: f8c2 315c    	str.w	r3, [r2, #0x15c]
; 	QEKF_INS.GyroBias[0] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[4];
 8002032: 4b81         	ldr	r3, [pc, #0x204]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002034: 685b         	ldr	r3, [r3, #0x4]
 8002036: 691b         	ldr	r3, [r3, #0x10]
 8002038: 4a7f         	ldr	r2, [pc, #0x1fc]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800203a: f8c2 3160    	str.w	r3, [r2, #0x160]
; 	QEKF_INS.GyroBias[1] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[5];
 800203e: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002040: 685b         	ldr	r3, [r3, #0x4]
 8002042: 695b         	ldr	r3, [r3, #0x14]
 8002044: 4a7c         	ldr	r2, [pc, #0x1f0]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002046: f8c2 3164    	str.w	r3, [r2, #0x164]
; 	QEKF_INS.GyroBias[2] = 0; // 大部分时候z轴通天,无法观测yaw的漂移
 800204a: 4b7b         	ldr	r3, [pc, #0x1ec]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800204c: f04f 0200    	mov.w	r2, #0x0
 8002050: f8c3 2168    	str.w	r2, [r3, #0x168]
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[3] + QEKF_INS.q[1] * QEKF_INS.q[2]),
 8002054: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002056: ed93 7a54    	<unknown>
 800205a: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800205c: edd3 7a57    	<unknown>
 8002060: ee27 7a27    	<unknown>
 8002064: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002066: edd3 6a55    	<unknown>
 800206a: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800206c: edd3 7a56    	<unknown>
 8002070: ee66 7aa7    	<unknown>
 8002074: ee77 7a27    	<unknown>
 8002078: ee37 6aa7    	<unknown>
; 		       2.0f * (QEKF_INS.q[0] * QEKF_INS.q[0] + QEKF_INS.q[1] * QEKF_INS.q[1]) -
 800207c: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800207e: ed93 7a54    	<unknown>
 8002082: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002084: edd3 7a54    	<unknown>
 8002088: ee27 7a27    	<unknown>
 800208c: 4b6a         	ldr	r3, [pc, #0x1a8]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800208e: edd3 6a55    	<unknown>
 8002092: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002094: edd3 7a55    	<unknown>
 8002098: ee66 7aa7    	<unknown>
 800209c: ee77 7a27    	<unknown>
 80020a0: ee77 7aa7    	<unknown>
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[3] + QEKF_INS.q[1] * QEKF_INS.q[2]),
 80020a4: eeb7 7a00    	<unknown>
 80020a8: ee77 7ac7    	<unknown>
 80020ac: eef0 0a67    	<unknown>
 80020b0: eeb0 0a46    	<unknown>
 80020b4: f017 ff1e    	bl	0x8019ef4 <atan2f>      @ imm = #0x17e3c
 80020b8: eef0 7a40    	<unknown>
; 			       1.0f) *
 80020bc: ed9f 7a60    	<unknown>
 80020c0: ee67 7a87    	<unknown>
; 	QEKF_INS.Yaw =
 80020c4: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80020c6: edc3 7a6a    	<unknown>
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[1] + QEKF_INS.q[2] * QEKF_INS.q[3]),
 80020ca: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80020cc: ed93 7a54    	<unknown>
 80020d0: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80020d2: edd3 7a55    	<unknown>
 80020d6: ee27 7a27    	<unknown>
 80020da: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80020dc: edd3 6a56    	<unknown>
 80020e0: 4b55         	ldr	r3, [pc, #0x154]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80020e2: edd3 7a57    	<unknown>
 80020e6: ee66 7aa7    	<unknown>
 80020ea: ee77 7a27    	<unknown>
 80020ee: ee37 6aa7    	<unknown>
; 		       2.0f * (QEKF_INS.q[0] * QEKF_INS.q[0] + QEKF_INS.q[3] * QEKF_INS.q[3]) -
 80020f2: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80020f4: ed93 7a54    	<unknown>
 80020f8: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80020fa: edd3 7a54    	<unknown>
 80020fe: ee27 7a27    	<unknown>
 8002102: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002104: edd3 6a57    	<unknown>
 8002108: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800210a: edd3 7a57    	<unknown>
 800210e: ee66 7aa7    	<unknown>
 8002112: ee77 7a27    	<unknown>
 8002116: ee77 7aa7    	<unknown>
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[1] + QEKF_INS.q[2] * QEKF_INS.q[3]),
 800211a: eeb7 7a00    	<unknown>
 800211e: ee77 7ac7    	<unknown>
 8002122: eef0 0a67    	<unknown>
 8002126: eeb0 0a46    	<unknown>
 800212a: f017 fee3    	bl	0x8019ef4 <atan2f>      @ imm = #0x17dc6
 800212e: eef0 7a40    	<unknown>
; 			       1.0f) *
 8002132: ed9f 7a43    	<unknown>
 8002136: ee67 7a87    	<unknown>
; 	QEKF_INS.Pitch =
 800213a: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800213c: edc3 7a69    	<unknown>
; 		asinf(-2.0f * (QEKF_INS.q[1] * QEKF_INS.q[3] - QEKF_INS.q[0] * QEKF_INS.q[2])) *
 8002140: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002142: ed93 7a55    	<unknown>
 8002146: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002148: edd3 7a57    	<unknown>
 800214c: ee27 7a27    	<unknown>
 8002150: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002152: edd3 6a54    	<unknown>
 8002156: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002158: edd3 7a56    	<unknown>
 800215c: ee66 7aa7    	<unknown>
 8002160: ee77 7a67    	<unknown>
 8002164: eeb8 7a00    	<unknown>
 8002168: ee67 7a87    	<unknown>
 800216c: eeb0 0a67    	<unknown>
 8002170: f017 fdde    	bl	0x8019d30 <asinf>       @ imm = #0x17bbc
 8002174: eef0 7a40    	<unknown>
 8002178: ed9f 7a31    	<unknown>
 800217c: ee67 7a87    	<unknown>
; 	QEKF_INS.Roll =
 8002180: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002182: edc3 7a68    	<unknown>
; 	if (QEKF_INS.Yaw - QEKF_INS.YawAngleLast > 180.0f) {
 8002186: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002188: ed93 7a6a    	<unknown>
 800218c: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800218e: edd3 7a76    	<unknown>
 8002192: ee77 7a67    	<unknown>
 8002196: ed9f 7a2b    	<unknown>
 800219a: eef4 7ac7    	<unknown>
 800219e: eef1 fa10    	<unknown>
 80021a2: dd0a         	ble	0x80021ba <IMU_QuaternionEKF_Update+0x6aa> @ imm = #0x14
; 		QEKF_INS.YawRoundCount--;
 80021a4: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80021a6: f9b3 31d4    	ldrsh.w	r3, [r3, #0x1d4]
 80021aa: b29b         	uxth	r3, r3
 80021ac: 3b01         	subs	r3, #0x1
 80021ae: b29b         	uxth	r3, r3
 80021b0: b21a         	sxth	r2, r3
 80021b2: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80021b4: f8a3 21d4    	strh.w	r2, [r3, #0x1d4]
 80021b8: e018         	b	0x80021ec <IMU_QuaternionEKF_Update+0x6dc> @ imm = #0x30
; 	} else if (QEKF_INS.Yaw - QEKF_INS.YawAngleLast < -180.0f) {
 80021ba: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80021bc: ed93 7a6a    	<unknown>
 80021c0: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80021c2: edd3 7a76    	<unknown>
 80021c6: ee77 7a67    	<unknown>
 80021ca: ed9f 7a1f    	<unknown>
 80021ce: eef4 7ac7    	<unknown>
 80021d2: eef1 fa10    	<unknown>
 80021d6: d509         	bpl	0x80021ec <IMU_QuaternionEKF_Update+0x6dc> @ imm = #0x12
; 		QEKF_INS.YawRoundCount++;
 80021d8: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80021da: f9b3 31d4    	ldrsh.w	r3, [r3, #0x1d4]
 80021de: b29b         	uxth	r3, r3
 80021e0: 3301         	adds	r3, #0x1
 80021e2: b29b         	uxth	r3, r3
 80021e4: b21a         	sxth	r2, r3
 80021e6: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80021e8: f8a3 21d4    	strh.w	r2, [r3, #0x1d4]
; 	QEKF_INS.YawTotalAngle = 360.0f * QEKF_INS.YawRoundCount + QEKF_INS.Yaw;
 80021ec: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 80021ee: f9b3 31d4    	ldrsh.w	r3, [r3, #0x1d4]
 80021f2: ee07 3a90    	<unknown>
 80021f6: eef8 7ae7    	<unknown>
 80021fa: ed9f 7a14    	<unknown>
 80021fe: ee27 7a87    	<unknown>
 8002202: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002204: edd3 7a6a    	<unknown>
 8002208: ee77 7a27    	<unknown>
 800220c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800220e: edc3 7a6b    	<unknown>
; 	QEKF_INS.YawAngleLast = QEKF_INS.Yaw;
 8002212: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002214: f8d3 31a8    	ldr.w	r3, [r3, #0x1a8]
 8002218: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800221a: f8c2 31d8    	str.w	r3, [r2, #0x1d8]
; 	QEKF_INS.UpdateCount++; // 初始化低通滤波用,计数测试用
 800221e: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 8002220: e9d3 2352    	ldrd	r2, r3, [r3, #328]
 8002224: 1c54         	adds	r4, r2, #0x1
 8002226: f143 0500    	adc	r5, r3, #0x0
 800222a: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8002238 <IMU_QuaternionEKF_Update+0x728>
 800222c: e9c3 4552    	strd	r4, r5, [r3, #328]
; }
 8002230: bf00         	nop
 8002232: 3728         	adds	r7, #0x28
 8002234: 46bd         	mov	sp, r7
 8002236: bdb0         	pop	{r4, r5, r7, pc}

08002238 <$d>:
 8002238: a0 0d 00 24  	.word	0x24000da0
 800223c: a4 0d 00 24  	.word	0x24000da4
 8002240: e1 2e 65 42  	.word	0x42652ee1
 8002244: 00 00 34 43  	.word	0x43340000
 8002248: 00 00 34 c3  	.word	0xc3340000
 800224c: 00 00 b4 43  	.word	0x43b40000

08002250 <IMU_QuaternionEKF_F_Linearization_P_Fading>:
; {
 8002250: b580         	push	{r7, lr}
 8002252: b084         	sub	sp, #0x10
 8002254: af00         	add	r7, sp, #0x0
 8002256: 6078         	str	r0, [r7, #0x4]
; 	q0 = kf->xhatminus_data[0];
 8002258: 687b         	ldr	r3, [r7, #0x4]
 800225a: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800225e: 681b         	ldr	r3, [r3]
 8002260: 4aa2         	ldr	r2, [pc, #0x288]        @ 0x80024ec <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 8002262: 6013         	str	r3, [r2]
; 	q1 = kf->xhatminus_data[1];
 8002264: 687b         	ldr	r3, [r7, #0x4]
 8002266: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800226a: 685b         	ldr	r3, [r3, #0x4]
 800226c: 4aa0         	ldr	r2, [pc, #0x280]        @ 0x80024f0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 800226e: 6013         	str	r3, [r2]
; 	q2 = kf->xhatminus_data[2];
 8002270: 687b         	ldr	r3, [r7, #0x4]
 8002272: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002276: 689b         	ldr	r3, [r3, #0x8]
 8002278: 4a9e         	ldr	r2, [pc, #0x278]        @ 0x80024f4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 800227a: 6013         	str	r3, [r2]
; 	q3 = kf->xhatminus_data[3];
 800227c: 687b         	ldr	r3, [r7, #0x4]
 800227e: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002282: 68db         	ldr	r3, [r3, #0xc]
 8002284: 4a9c         	ldr	r2, [pc, #0x270]        @ 0x80024f8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 8002286: 6013         	str	r3, [r2]
; 	qInvNorm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
 8002288: 4b98         	ldr	r3, [pc, #0x260]        @ 0x80024ec <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 800228a: ed93 7a00    	<unknown>
 800228e: 4b97         	ldr	r3, [pc, #0x25c]        @ 0x80024ec <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 8002290: edd3 7a00    	<unknown>
 8002294: ee27 7a27    	<unknown>
 8002298: 4b95         	ldr	r3, [pc, #0x254]        @ 0x80024f0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 800229a: edd3 6a00    	<unknown>
 800229e: 4b94         	ldr	r3, [pc, #0x250]        @ 0x80024f0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 80022a0: edd3 7a00    	<unknown>
 80022a4: ee66 7aa7    	<unknown>
 80022a8: ee37 7a27    	<unknown>
 80022ac: 4b91         	ldr	r3, [pc, #0x244]        @ 0x80024f4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 80022ae: edd3 6a00    	<unknown>
 80022b2: 4b90         	ldr	r3, [pc, #0x240]        @ 0x80024f4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 80022b4: edd3 7a00    	<unknown>
 80022b8: ee66 7aa7    	<unknown>
 80022bc: ee37 7a27    	<unknown>
 80022c0: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x80024f8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 80022c2: edd3 6a00    	<unknown>
 80022c6: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x80024f8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 80022c8: edd3 7a00    	<unknown>
 80022cc: ee66 7aa7    	<unknown>
 80022d0: ee77 7a27    	<unknown>
 80022d4: eeb0 0a67    	<unknown>
 80022d8: f000 fd44    	bl	0x8002d64 <invSqrt>     @ imm = #0xa88
 80022dc: eef0 7a40    	<unknown>
 80022e0: 4b86         	ldr	r3, [pc, #0x218]        @ 0x80024fc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2ac>
 80022e2: edc3 7a00    	<unknown>
; 	for (uint8_t i = 0; i < 4; ++i) {
 80022e6: 2300         	movs	r3, #0x0
 80022e8: 73fb         	strb	r3, [r7, #0xf]
 80022ea: e017         	b	0x800231c <IMU_QuaternionEKF_F_Linearization_P_Fading+0xcc> @ imm = #0x2e
; 		kf->xhatminus_data[i] *= qInvNorm;
 80022ec: 687b         	ldr	r3, [r7, #0x4]
 80022ee: f8d3 20ec    	ldr.w	r2, [r3, #0xec]
 80022f2: 7bfb         	ldrb	r3, [r7, #0xf]
 80022f4: 009b         	lsls	r3, r3, #0x2
 80022f6: 4413         	add	r3, r2
 80022f8: ed93 7a00    	<unknown>
 80022fc: 4b7f         	ldr	r3, [pc, #0x1fc]        @ 0x80024fc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2ac>
 80022fe: edd3 7a00    	<unknown>
 8002302: 687b         	ldr	r3, [r7, #0x4]
 8002304: f8d3 20ec    	ldr.w	r2, [r3, #0xec]
 8002308: 7bfb         	ldrb	r3, [r7, #0xf]
 800230a: 009b         	lsls	r3, r3, #0x2
 800230c: 4413         	add	r3, r2
 800230e: ee67 7a27    	<unknown>
 8002312: edc3 7a00    	<unknown>
; 	for (uint8_t i = 0; i < 4; ++i) {
 8002316: 7bfb         	ldrb	r3, [r7, #0xf]
 8002318: 3301         	adds	r3, #0x1
 800231a: 73fb         	strb	r3, [r7, #0xf]
 800231c: 7bfb         	ldrb	r3, [r7, #0xf]
 800231e: 2b03         	cmp	r3, #0x3
 8002320: d9e4         	bls	0x80022ec <IMU_QuaternionEKF_F_Linearization_P_Fading+0x9c> @ imm = #-0x38
; 	kf->F_data[4] = q1 * QEKF_INS.dt / 2;
 8002322: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x8002500 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002324: ed93 7a6f    	<unknown>
 8002328: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x80024f0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 800232a: edd3 7a00    	<unknown>
 800232e: ee27 7a27    	<unknown>
 8002332: 687b         	ldr	r3, [r7, #0x4]
 8002334: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002338: 3310         	adds	r3, #0x10
 800233a: eef0 6a00    	<unknown>
 800233e: eec7 7a26    	<unknown>
 8002342: edc3 7a00    	<unknown>
; 	kf->F_data[5] = q2 * QEKF_INS.dt / 2;
 8002346: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8002500 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002348: ed93 7a6f    	<unknown>
 800234c: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x80024f4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 800234e: edd3 7a00    	<unknown>
 8002352: ee27 7a27    	<unknown>
 8002356: 687b         	ldr	r3, [r7, #0x4]
 8002358: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 800235c: 3314         	adds	r3, #0x14
 800235e: eef0 6a00    	<unknown>
 8002362: eec7 7a26    	<unknown>
 8002366: edc3 7a00    	<unknown>
; 	kf->F_data[10] = -q0 * QEKF_INS.dt / 2;
 800236a: 4b60         	ldr	r3, [pc, #0x180]        @ 0x80024ec <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 800236c: edd3 7a00    	<unknown>
 8002370: eeb1 7a67    	<unknown>
 8002374: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8002500 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002376: edd3 7a6f    	<unknown>
 800237a: ee27 7a27    	<unknown>
 800237e: 687b         	ldr	r3, [r7, #0x4]
 8002380: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002384: 3328         	adds	r3, #0x28
 8002386: eef0 6a00    	<unknown>
 800238a: eec7 7a26    	<unknown>
 800238e: edc3 7a00    	<unknown>
; 	kf->F_data[11] = q3 * QEKF_INS.dt / 2;
 8002392: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8002500 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002394: ed93 7a6f    	<unknown>
 8002398: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x80024f8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 800239a: edd3 7a00    	<unknown>
 800239e: ee27 7a27    	<unknown>
 80023a2: 687b         	ldr	r3, [r7, #0x4]
 80023a4: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 80023a8: 332c         	adds	r3, #0x2c
 80023aa: eef0 6a00    	<unknown>
 80023ae: eec7 7a26    	<unknown>
 80023b2: edc3 7a00    	<unknown>
; 	kf->F_data[16] = -q3 * QEKF_INS.dt / 2;
 80023b6: 4b50         	ldr	r3, [pc, #0x140]        @ 0x80024f8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 80023b8: edd3 7a00    	<unknown>
 80023bc: eeb1 7a67    	<unknown>
 80023c0: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8002500 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 80023c2: edd3 7a6f    	<unknown>
 80023c6: ee27 7a27    	<unknown>
 80023ca: 687b         	ldr	r3, [r7, #0x4]
 80023cc: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 80023d0: 3340         	adds	r3, #0x40
 80023d2: eef0 6a00    	<unknown>
 80023d6: eec7 7a26    	<unknown>
 80023da: edc3 7a00    	<unknown>
; 	kf->F_data[17] = -q0 * QEKF_INS.dt / 2;
 80023de: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x80024ec <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 80023e0: edd3 7a00    	<unknown>
 80023e4: eeb1 7a67    	<unknown>
 80023e8: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8002500 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 80023ea: edd3 7a6f    	<unknown>
 80023ee: ee27 7a27    	<unknown>
 80023f2: 687b         	ldr	r3, [r7, #0x4]
 80023f4: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 80023f8: 3344         	adds	r3, #0x44
 80023fa: eef0 6a00    	<unknown>
 80023fe: eec7 7a26    	<unknown>
 8002402: edc3 7a00    	<unknown>
; 	kf->F_data[22] = q2 * QEKF_INS.dt / 2;
 8002406: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8002500 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002408: ed93 7a6f    	<unknown>
 800240c: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x80024f4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 800240e: edd3 7a00    	<unknown>
 8002412: ee27 7a27    	<unknown>
 8002416: 687b         	ldr	r3, [r7, #0x4]
 8002418: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 800241c: 3358         	adds	r3, #0x58
 800241e: eef0 6a00    	<unknown>
 8002422: eec7 7a26    	<unknown>
 8002426: edc3 7a00    	<unknown>
; 	kf->F_data[23] = -q1 * QEKF_INS.dt / 2;
 800242a: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80024f0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 800242c: edd3 7a00    	<unknown>
 8002430: eeb1 7a67    	<unknown>
 8002434: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8002500 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002436: edd3 7a6f    	<unknown>
 800243a: ee27 7a27    	<unknown>
 800243e: 687b         	ldr	r3, [r7, #0x4]
 8002440: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002444: 335c         	adds	r3, #0x5c
 8002446: eef0 6a00    	<unknown>
 800244a: eec7 7a26    	<unknown>
 800244e: edc3 7a00    	<unknown>
; 	kf->P_data[28] /= QEKF_INS.lambda;
 8002452: 687b         	ldr	r3, [r7, #0x4]
 8002454: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002458: 3370         	adds	r3, #0x70
 800245a: edd3 6a00    	<unknown>
 800245e: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8002500 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002460: ed93 7a74    	<unknown>
 8002464: 687b         	ldr	r3, [r7, #0x4]
 8002466: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 800246a: 3370         	adds	r3, #0x70
 800246c: eec6 7a87    	<unknown>
 8002470: edc3 7a00    	<unknown>
; 	kf->P_data[35] /= QEKF_INS.lambda;
 8002474: 687b         	ldr	r3, [r7, #0x4]
 8002476: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 800247a: 338c         	adds	r3, #0x8c
 800247c: edd3 6a00    	<unknown>
 8002480: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8002500 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002482: ed93 7a74    	<unknown>
 8002486: 687b         	ldr	r3, [r7, #0x4]
 8002488: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 800248c: 338c         	adds	r3, #0x8c
 800248e: eec6 7a87    	<unknown>
 8002492: edc3 7a00    	<unknown>
; 	if (kf->P_data[28] > 10000) {
 8002496: 687b         	ldr	r3, [r7, #0x4]
 8002498: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 800249c: 3370         	adds	r3, #0x70
 800249e: edd3 7a00    	<unknown>
 80024a2: ed9f 7a18    	<unknown>
 80024a6: eef4 7ac7    	<unknown>
 80024aa: eef1 fa10    	<unknown>
 80024ae: dd05         	ble	0x80024bc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x26c> @ imm = #0xa
; 		kf->P_data[28] = 10000;
 80024b0: 687b         	ldr	r3, [r7, #0x4]
 80024b2: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 80024b6: 3370         	adds	r3, #0x70
 80024b8: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x8002508 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b8>
 80024ba: 601a         	str	r2, [r3]
; 	if (kf->P_data[35] > 10000) {
 80024bc: 687b         	ldr	r3, [r7, #0x4]
 80024be: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 80024c2: 338c         	adds	r3, #0x8c
 80024c4: edd3 7a00    	<unknown>
 80024c8: ed9f 7a0e    	<unknown>
 80024cc: eef4 7ac7    	<unknown>
 80024d0: eef1 fa10    	<unknown>
 80024d4: dc00         	bgt	0x80024d8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x288> @ imm = #0x0
; }
 80024d6: e005         	b	0x80024e4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x294> @ imm = #0xa
; 		kf->P_data[35] = 10000;
 80024d8: 687b         	ldr	r3, [r7, #0x4]
 80024da: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 80024de: 338c         	adds	r3, #0x8c
 80024e0: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8002508 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b8>
 80024e2: 601a         	str	r2, [r3]
; }
 80024e4: bf00         	nop
 80024e6: 3710         	adds	r7, #0x10
 80024e8: 46bd         	mov	sp, r7
 80024ea: bd80         	pop	{r7, pc}

080024ec <$d>:
 80024ec: c4 27 00 24  	.word	0x240027c4
 80024f0: c8 27 00 24  	.word	0x240027c8
 80024f4: cc 27 00 24  	.word	0x240027cc
 80024f8: d0 27 00 24  	.word	0x240027d0
 80024fc: d4 27 00 24  	.word	0x240027d4
 8002500: a0 0d 00 24  	.word	0x24000da0
 8002504: 00 40 1c 46  	.word	0x461c4000
 8002508: 00 40 1c 46  	.word	0x461c4000

0800250c <IMU_QuaternionEKF_SetH>:
; {
 800250c: b580         	push	{r7, lr}
 800250e: b082         	sub	sp, #0x8
 8002510: af00         	add	r7, sp, #0x0
 8002512: 6078         	str	r0, [r7, #0x4]
; 	doubleq0 = 2 * kf->xhatminus_data[0];
 8002514: 687b         	ldr	r3, [r7, #0x4]
 8002516: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800251a: edd3 7a00    	<unknown>
 800251e: ee77 7aa7    	<unknown>
 8002522: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x800265c <IMU_QuaternionEKF_SetH+0x150>
 8002524: edc3 7a00    	<unknown>
; 	doubleq1 = 2 * kf->xhatminus_data[1];
 8002528: 687b         	ldr	r3, [r7, #0x4]
 800252a: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800252e: 3304         	adds	r3, #0x4
 8002530: edd3 7a00    	<unknown>
 8002534: ee77 7aa7    	<unknown>
 8002538: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8002660 <IMU_QuaternionEKF_SetH+0x154>
 800253a: edc3 7a00    	<unknown>
; 	doubleq2 = 2 * kf->xhatminus_data[2];
 800253e: 687b         	ldr	r3, [r7, #0x4]
 8002540: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002544: 3308         	adds	r3, #0x8
 8002546: edd3 7a00    	<unknown>
 800254a: ee77 7aa7    	<unknown>
 800254e: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8002664 <IMU_QuaternionEKF_SetH+0x158>
 8002550: edc3 7a00    	<unknown>
; 	doubleq3 = 2 * kf->xhatminus_data[3];
 8002554: 687b         	ldr	r3, [r7, #0x4]
 8002556: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800255a: 330c         	adds	r3, #0xc
 800255c: edd3 7a00    	<unknown>
 8002560: ee77 7aa7    	<unknown>
 8002564: 4b40         	ldr	r3, [pc, #0x100]        @ 0x8002668 <IMU_QuaternionEKF_SetH+0x15c>
 8002566: edc3 7a00    	<unknown>
; 	memset(kf->H_data, 0, sizeof_float * kf->zSize * kf->xhatSize);
 800256a: 687b         	ldr	r3, [r7, #0x4]
 800256c: f8d3 010c    	ldr.w	r0, [r3, #0x10c]
 8002570: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800266c <IMU_QuaternionEKF_SetH+0x160>
 8002572: 881b         	ldrh	r3, [r3]
 8002574: 461a         	mov	r2, r3
 8002576: 687b         	ldr	r3, [r7, #0x4]
 8002578: 7b9b         	ldrb	r3, [r3, #0xe]
 800257a: fb02 f303    	mul	r3, r2, r3
 800257e: 687a         	ldr	r2, [r7, #0x4]
 8002580: 7b12         	ldrb	r2, [r2, #0xc]
 8002582: fb02 f303    	mul	r3, r2, r3
 8002586: 461a         	mov	r2, r3
 8002588: 2100         	movs	r1, #0x0
 800258a: f026 fdc1    	bl	0x8029110 <memset>      @ imm = #0x26b82
; 	kf->H_data[0] = -doubleq2;
 800258e: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8002664 <IMU_QuaternionEKF_SetH+0x158>
 8002590: edd3 7a00    	<unknown>
 8002594: 687b         	ldr	r3, [r7, #0x4]
 8002596: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 800259a: eef1 7a67    	<unknown>
 800259e: edc3 7a00    	<unknown>
; 	kf->H_data[1] = doubleq3;
 80025a2: 687b         	ldr	r3, [r7, #0x4]
 80025a4: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80025a8: 3304         	adds	r3, #0x4
 80025aa: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x8002668 <IMU_QuaternionEKF_SetH+0x15c>
 80025ac: 6812         	ldr	r2, [r2]
 80025ae: 601a         	str	r2, [r3]
; 	kf->H_data[2] = -doubleq0;
 80025b0: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800265c <IMU_QuaternionEKF_SetH+0x150>
 80025b2: edd3 7a00    	<unknown>
 80025b6: 687b         	ldr	r3, [r7, #0x4]
 80025b8: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80025bc: 3308         	adds	r3, #0x8
 80025be: eef1 7a67    	<unknown>
 80025c2: edc3 7a00    	<unknown>
; 	kf->H_data[3] = doubleq1;
 80025c6: 687b         	ldr	r3, [r7, #0x4]
 80025c8: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80025cc: 330c         	adds	r3, #0xc
 80025ce: 4a24         	ldr	r2, [pc, #0x90]         @ 0x8002660 <IMU_QuaternionEKF_SetH+0x154>
 80025d0: 6812         	ldr	r2, [r2]
 80025d2: 601a         	str	r2, [r3]
; 	kf->H_data[6] = doubleq1;
 80025d4: 687b         	ldr	r3, [r7, #0x4]
 80025d6: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80025da: 3318         	adds	r3, #0x18
 80025dc: 4a20         	ldr	r2, [pc, #0x80]         @ 0x8002660 <IMU_QuaternionEKF_SetH+0x154>
 80025de: 6812         	ldr	r2, [r2]
 80025e0: 601a         	str	r2, [r3]
; 	kf->H_data[7] = doubleq0;
 80025e2: 687b         	ldr	r3, [r7, #0x4]
 80025e4: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80025e8: 331c         	adds	r3, #0x1c
 80025ea: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x800265c <IMU_QuaternionEKF_SetH+0x150>
 80025ec: 6812         	ldr	r2, [r2]
 80025ee: 601a         	str	r2, [r3]
; 	kf->H_data[8] = doubleq3;
 80025f0: 687b         	ldr	r3, [r7, #0x4]
 80025f2: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80025f6: 3320         	adds	r3, #0x20
 80025f8: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8002668 <IMU_QuaternionEKF_SetH+0x15c>
 80025fa: 6812         	ldr	r2, [r2]
 80025fc: 601a         	str	r2, [r3]
; 	kf->H_data[9] = doubleq2;
 80025fe: 687b         	ldr	r3, [r7, #0x4]
 8002600: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002604: 3324         	adds	r3, #0x24
 8002606: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x8002664 <IMU_QuaternionEKF_SetH+0x158>
 8002608: 6812         	ldr	r2, [r2]
 800260a: 601a         	str	r2, [r3]
; 	kf->H_data[12] = doubleq0;
 800260c: 687b         	ldr	r3, [r7, #0x4]
 800260e: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002612: 3330         	adds	r3, #0x30
 8002614: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800265c <IMU_QuaternionEKF_SetH+0x150>
 8002616: 6812         	ldr	r2, [r2]
 8002618: 601a         	str	r2, [r3]
; 	kf->H_data[13] = -doubleq1;
 800261a: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8002660 <IMU_QuaternionEKF_SetH+0x154>
 800261c: edd3 7a00    	<unknown>
 8002620: 687b         	ldr	r3, [r7, #0x4]
 8002622: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002626: 3334         	adds	r3, #0x34
 8002628: eef1 7a67    	<unknown>
 800262c: edc3 7a00    	<unknown>
; 	kf->H_data[14] = -doubleq2;
 8002630: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8002664 <IMU_QuaternionEKF_SetH+0x158>
 8002632: edd3 7a00    	<unknown>
 8002636: 687b         	ldr	r3, [r7, #0x4]
 8002638: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 800263c: 3338         	adds	r3, #0x38
 800263e: eef1 7a67    	<unknown>
 8002642: edc3 7a00    	<unknown>
; 	kf->H_data[15] = doubleq3;
 8002646: 687b         	ldr	r3, [r7, #0x4]
 8002648: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 800264c: 333c         	adds	r3, #0x3c
 800264e: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8002668 <IMU_QuaternionEKF_SetH+0x15c>
 8002650: 6812         	ldr	r2, [r2]
 8002652: 601a         	str	r2, [r3]
; }
 8002654: bf00         	nop
 8002656: 3708         	adds	r7, #0x8
 8002658: 46bd         	mov	sp, r7
 800265a: bd80         	pop	{r7, pc}

0800265c <$d>:
 800265c: d8 27 00 24  	.word	0x240027d8
 8002660: dc 27 00 24  	.word	0x240027dc
 8002664: e0 27 00 24  	.word	0x240027e0
 8002668: e4 27 00 24  	.word	0x240027e4
 800266c: ec 32 00 24  	.word	0x240032ec

08002670 <IMU_QuaternionEKF_xhatUpdate>:
; {
 8002670: b5f0         	push	{r4, r5, r6, r7, lr}
 8002672: b087         	sub	sp, #0x1c
 8002674: af00         	add	r7, sp, #0x0
 8002676: 6078         	str	r0, [r7, #0x4]
; 	kf->MatStatus = Matrix_Transpose(&kf->H, &kf->HT); // z|x => x|z
 8002678: 687b         	ldr	r3, [r7, #0x4]
 800267a: f103 0278    	add.w	r2, r3, #0x78
 800267e: 687b         	ldr	r3, [r7, #0x4]
 8002680: 3380         	adds	r3, #0x80
 8002682: 4619         	mov	r1, r3
 8002684: 4610         	mov	r0, r2
 8002686: f011 f899    	bl	0x80137bc <arm_mat_trans_f32> @ imm = #0x11132
 800268a: 4603         	mov	r3, r0
 800268c: 461a         	mov	r2, r3
 800268e: 687b         	ldr	r3, [r7, #0x4]
 8002690: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_matrix.numRows = kf->H.numRows;
 8002694: 687b         	ldr	r3, [r7, #0x4]
 8002696: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 800269a: 687b         	ldr	r3, [r7, #0x4]
 800269c: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 	kf->temp_matrix.numCols = kf->Pminus.numCols;
 80026a0: 687b         	ldr	r3, [r7, #0x4]
 80026a2: f8b3 205a    	ldrh.w	r2, [r3, #0x5a]
 80026a6: 687b         	ldr	r3, [r7, #0x4]
 80026a8: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		Matrix_Multiply(&kf->H, &kf->Pminus, &kf->temp_matrix); // temp_matrix = H·P'(k)
 80026ac: 687b         	ldr	r3, [r7, #0x4]
 80026ae: f103 0078    	add.w	r0, r3, #0x78
 80026b2: 687b         	ldr	r3, [r7, #0x4]
 80026b4: f103 0158    	add.w	r1, r3, #0x58
 80026b8: 687b         	ldr	r3, [r7, #0x4]
 80026ba: 33a8         	adds	r3, #0xa8
 80026bc: 461a         	mov	r2, r3
 80026be: f010 fff7    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #0x10fee
 80026c2: 4603         	mov	r3, r0
 80026c4: 461a         	mov	r2, r3
; 	kf->MatStatus =
 80026c6: 687b         	ldr	r3, [r7, #0x4]
 80026c8: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_matrix1.numRows = kf->temp_matrix.numRows;
 80026cc: 687b         	ldr	r3, [r7, #0x4]
 80026ce: f8b3 20a8    	ldrh.w	r2, [r3, #0xa8]
 80026d2: 687b         	ldr	r3, [r7, #0x4]
 80026d4: f8a3 20b0    	strh.w	r2, [r3, #0xb0]
; 	kf->temp_matrix1.numCols = kf->HT.numCols;
 80026d8: 687b         	ldr	r3, [r7, #0x4]
 80026da: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 80026de: 687b         	ldr	r3, [r7, #0x4]
 80026e0: f8a3 20b2    	strh.w	r2, [r3, #0xb2]
; 	kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->HT,
 80026e4: 687b         	ldr	r3, [r7, #0x4]
 80026e6: f103 00a8    	add.w	r0, r3, #0xa8
 80026ea: 687b         	ldr	r3, [r7, #0x4]
 80026ec: f103 0180    	add.w	r1, r3, #0x80
 80026f0: 687b         	ldr	r3, [r7, #0x4]
 80026f2: 33b0         	adds	r3, #0xb0
 80026f4: 461a         	mov	r2, r3
 80026f6: f010 ffdb    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #0x10fb6
 80026fa: 4603         	mov	r3, r0
 80026fc: 461a         	mov	r2, r3
 80026fe: 687b         	ldr	r3, [r7, #0x4]
 8002700: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->S.numRows = kf->R.numRows;
 8002704: 687b         	ldr	r3, [r7, #0x4]
 8002706: f8b3 2090    	ldrh.w	r2, [r3, #0x90]
 800270a: 687b         	ldr	r3, [r7, #0x4]
 800270c: f8a3 20a0    	strh.w	r2, [r3, #0xa0]
; 	kf->S.numCols = kf->R.numCols;
 8002710: 687b         	ldr	r3, [r7, #0x4]
 8002712: f8b3 2092    	ldrh.w	r2, [r3, #0x92]
 8002716: 687b         	ldr	r3, [r7, #0x4]
 8002718: f8a3 20a2    	strh.w	r2, [r3, #0xa2]
; 	kf->MatStatus = Matrix_Add(&kf->temp_matrix1, &kf->R, &kf->S); // S = H P'(k) HT + R
 800271c: 687b         	ldr	r3, [r7, #0x4]
 800271e: f103 00b0    	add.w	r0, r3, #0xb0
 8002722: 687b         	ldr	r3, [r7, #0x4]
 8002724: f103 0190    	add.w	r1, r3, #0x90
 8002728: 687b         	ldr	r3, [r7, #0x4]
 800272a: 33a0         	adds	r3, #0xa0
 800272c: 461a         	mov	r2, r3
 800272e: f010 fe29    	bl	0x8013384 <arm_mat_add_f32> @ imm = #0x10c52
 8002732: 4603         	mov	r3, r0
 8002734: 461a         	mov	r2, r3
 8002736: 687b         	ldr	r3, [r7, #0x4]
 8002738: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		Matrix_Inverse(&kf->S, &kf->temp_matrix1); // temp_matrix1 = inv(H·P'(k)·HT + R)
 800273c: 687b         	ldr	r3, [r7, #0x4]
 800273e: f103 02a0    	add.w	r2, r3, #0xa0
 8002742: 687b         	ldr	r3, [r7, #0x4]
 8002744: 33b0         	adds	r3, #0xb0
 8002746: 4619         	mov	r1, r3
 8002748: 4610         	mov	r0, r2
 800274a: f010 fe37    	bl	0x80133bc <arm_mat_inverse_f32> @ imm = #0x10c6e
 800274e: 4603         	mov	r3, r0
 8002750: 461a         	mov	r2, r3
; 	kf->MatStatus =
 8002752: 687b         	ldr	r3, [r7, #0x4]
 8002754: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	q0 = kf->xhatminus_data[0];
 8002758: 687b         	ldr	r3, [r7, #0x4]
 800275a: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800275e: 681b         	ldr	r3, [r3]
 8002760: 4ab8         	ldr	r2, [pc, #0x2e0]        @ 0x8002a44 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 8002762: 6013         	str	r3, [r2]
; 	q1 = kf->xhatminus_data[1];
 8002764: 687b         	ldr	r3, [r7, #0x4]
 8002766: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800276a: 685b         	ldr	r3, [r3, #0x4]
 800276c: 4ab6         	ldr	r2, [pc, #0x2d8]        @ 0x8002a48 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 800276e: 6013         	str	r3, [r2]
; 	q2 = kf->xhatminus_data[2];
 8002770: 687b         	ldr	r3, [r7, #0x4]
 8002772: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002776: 689b         	ldr	r3, [r3, #0x8]
 8002778: 4ab4         	ldr	r2, [pc, #0x2d0]        @ 0x8002a4c <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 800277a: 6013         	str	r3, [r2]
; 	q3 = kf->xhatminus_data[3];
 800277c: 687b         	ldr	r3, [r7, #0x4]
 800277e: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002782: 68db         	ldr	r3, [r3, #0xc]
 8002784: 4ab2         	ldr	r2, [pc, #0x2c8]        @ 0x8002a50 <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 8002786: 6013         	str	r3, [r2]
; 	kf->temp_vector.numRows = kf->H.numRows;
 8002788: 687b         	ldr	r3, [r7, #0x4]
 800278a: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 800278e: 687b         	ldr	r3, [r7, #0x4]
 8002790: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 	kf->temp_vector.numCols = 1;
 8002794: 687b         	ldr	r3, [r7, #0x4]
 8002796: 2201         	movs	r2, #0x1
 8002798: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 	kf->temp_vector_data[0] = 2 * (q1 * q3 - q0 * q2);
 800279c: 4baa         	ldr	r3, [pc, #0x2a8]        @ 0x8002a48 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 800279e: ed93 7a00    	<unknown>
 80027a2: 4bab         	ldr	r3, [pc, #0x2ac]        @ 0x8002a50 <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 80027a4: edd3 7a00    	<unknown>
 80027a8: ee27 7a27    	<unknown>
 80027ac: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8002a44 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 80027ae: edd3 6a00    	<unknown>
 80027b2: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8002a4c <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 80027b4: edd3 7a00    	<unknown>
 80027b8: ee66 7aa7    	<unknown>
 80027bc: ee77 7a67    	<unknown>
 80027c0: 687b         	ldr	r3, [r7, #0x4]
 80027c2: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 80027c6: ee77 7aa7    	<unknown>
 80027ca: edc3 7a00    	<unknown>
; 	kf->temp_vector_data[1] = 2 * (q0 * q1 + q2 * q3);
 80027ce: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x8002a44 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 80027d0: ed93 7a00    	<unknown>
 80027d4: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8002a48 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 80027d6: edd3 7a00    	<unknown>
 80027da: ee27 7a27    	<unknown>
 80027de: 4b9b         	ldr	r3, [pc, #0x26c]        @ 0x8002a4c <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 80027e0: edd3 6a00    	<unknown>
 80027e4: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x8002a50 <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 80027e6: edd3 7a00    	<unknown>
 80027ea: ee66 7aa7    	<unknown>
 80027ee: ee77 7a27    	<unknown>
 80027f2: 687b         	ldr	r3, [r7, #0x4]
 80027f4: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 80027f8: 3304         	adds	r3, #0x4
 80027fa: ee77 7aa7    	<unknown>
 80027fe: edc3 7a00    	<unknown>
; 		q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3; // temp_vector = h(xhat'(k))
 8002802: 4b90         	ldr	r3, [pc, #0x240]        @ 0x8002a44 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 8002804: ed93 7a00    	<unknown>
 8002808: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8002a44 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 800280a: edd3 7a00    	<unknown>
 800280e: ee27 7a27    	<unknown>
 8002812: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8002a48 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 8002814: edd3 6a00    	<unknown>
 8002818: 4b8b         	ldr	r3, [pc, #0x22c]        @ 0x8002a48 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 800281a: edd3 7a00    	<unknown>
 800281e: ee66 7aa7    	<unknown>
 8002822: ee37 7a67    	<unknown>
 8002826: 4b89         	ldr	r3, [pc, #0x224]        @ 0x8002a4c <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 8002828: edd3 6a00    	<unknown>
 800282c: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8002a4c <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 800282e: edd3 7a00    	<unknown>
 8002832: ee66 7aa7    	<unknown>
 8002836: ee37 7a67    	<unknown>
 800283a: 4b85         	ldr	r3, [pc, #0x214]        @ 0x8002a50 <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 800283c: edd3 6a00    	<unknown>
 8002840: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x8002a50 <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 8002842: edd3 7a00    	<unknown>
 8002846: ee66 7aa7    	<unknown>
; 	kf->temp_vector_data[2] =
 800284a: 687b         	ldr	r3, [r7, #0x4]
 800284c: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 8002850: 3308         	adds	r3, #0x8
; 		q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3; // temp_vector = h(xhat'(k))
 8002852: ee77 7a27    	<unknown>
; 	kf->temp_vector_data[2] =
 8002856: edc3 7a00    	<unknown>
; 	for (uint8_t i = 0; i < 3; ++i) {
 800285a: 2300         	movs	r3, #0x0
 800285c: 75fb         	strb	r3, [r7, #0x17]
 800285e: e021         	b	0x80028a4 <IMU_QuaternionEKF_xhatUpdate+0x234> @ imm = #0x42
; 		QEKF_INS.OrientationCosine[i] = acosf(fabsf(kf->temp_vector_data[i]));
 8002860: 687b         	ldr	r3, [r7, #0x4]
 8002862: f8d3 212c    	ldr.w	r2, [r3, #0x12c]
 8002866: 7dfb         	ldrb	r3, [r7, #0x17]
 8002868: 009b         	lsls	r3, r3, #0x2
 800286a: 4413         	add	r3, r2
 800286c: 681b         	ldr	r3, [r3]
 800286e: 60fb         	str	r3, [r7, #0xc]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 8002870: edd7 7a03    	<unknown>
 8002874: eef0 7ae7    	<unknown>
 8002878: edc7 7a02    	<unknown>
;     return result;
 800287c: edd7 7a02    	<unknown>
; 		QEKF_INS.OrientationCosine[i] = acosf(fabsf(kf->temp_vector_data[i]));
 8002880: 7dfe         	ldrb	r6, [r7, #0x17]
 8002882: eeb0 0a67    	<unknown>
 8002886: f017 f965    	bl	0x8019b54 <acosf>       @ imm = #0x172ca
 800288a: eef0 7a40    	<unknown>
 800288e: 4a71         	ldr	r2, [pc, #0x1c4]        @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8002890: f106 0360    	add.w	r3, r6, #0x60
 8002894: 009b         	lsls	r3, r3, #0x2
 8002896: 4413         	add	r3, r2
 8002898: 3304         	adds	r3, #0x4
 800289a: edc3 7a00    	<unknown>
; 	for (uint8_t i = 0; i < 3; ++i) {
 800289e: 7dfb         	ldrb	r3, [r7, #0x17]
 80028a0: 3301         	adds	r3, #0x1
 80028a2: 75fb         	strb	r3, [r7, #0x17]
 80028a4: 7dfb         	ldrb	r3, [r7, #0x17]
 80028a6: 2b02         	cmp	r3, #0x2
 80028a8: d9da         	bls	0x8002860 <IMU_QuaternionEKF_xhatUpdate+0x1f0> @ imm = #-0x4c
; 	kf->temp_vector1.numRows = kf->z.numRows;
 80028aa: 687b         	ldr	r3, [r7, #0x4]
 80028ac: f8b3 2048    	ldrh.w	r2, [r3, #0x48]
 80028b0: 687b         	ldr	r3, [r7, #0x4]
 80028b2: f8a3 20c0    	strh.w	r2, [r3, #0xc0]
; 	kf->temp_vector1.numCols = 1;
 80028b6: 687b         	ldr	r3, [r7, #0x4]
 80028b8: 2201         	movs	r2, #0x1
 80028ba: f8a3 20c2    	strh.w	r2, [r3, #0xc2]
; 	kf->MatStatus = Matrix_Subtract(&kf->z, &kf->temp_vector,
 80028be: 687b         	ldr	r3, [r7, #0x4]
 80028c0: f103 0048    	add.w	r0, r3, #0x48
 80028c4: 687b         	ldr	r3, [r7, #0x4]
 80028c6: f103 01b8    	add.w	r1, r3, #0xb8
 80028ca: 687b         	ldr	r3, [r7, #0x4]
 80028cc: 33c0         	adds	r3, #0xc0
 80028ce: 461a         	mov	r2, r3
 80028d0: f010 ff5c    	bl	0x801378c <arm_mat_sub_f32> @ imm = #0x10eb8
 80028d4: 4603         	mov	r3, r0
 80028d6: 461a         	mov	r2, r3
 80028d8: 687b         	ldr	r3, [r7, #0x4]
 80028da: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_matrix.numRows = kf->temp_vector1.numRows;
 80028de: 687b         	ldr	r3, [r7, #0x4]
 80028e0: f8b3 20c0    	ldrh.w	r2, [r3, #0xc0]
 80028e4: 687b         	ldr	r3, [r7, #0x4]
 80028e6: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 	kf->temp_matrix.numCols = 1;
 80028ea: 687b         	ldr	r3, [r7, #0x4]
 80028ec: 2201         	movs	r2, #0x1
 80028ee: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		&kf->temp_matrix1, &kf->temp_vector1,
 80028f2: 687b         	ldr	r3, [r7, #0x4]
 80028f4: f103 00b0    	add.w	r0, r3, #0xb0
 80028f8: 687b         	ldr	r3, [r7, #0x4]
 80028fa: f103 01c0    	add.w	r1, r3, #0xc0
; 	kf->MatStatus = Matrix_Multiply(
 80028fe: 687b         	ldr	r3, [r7, #0x4]
 8002900: 33a8         	adds	r3, #0xa8
 8002902: 461a         	mov	r2, r3
 8002904: f010 fed4    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #0x10da8
 8002908: 4603         	mov	r3, r0
 800290a: 461a         	mov	r2, r3
 800290c: 687b         	ldr	r3, [r7, #0x4]
 800290e: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_vector.numRows = 1;
 8002912: 687b         	ldr	r3, [r7, #0x4]
 8002914: 2201         	movs	r2, #0x1
 8002916: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 	kf->temp_vector.numCols = kf->temp_vector1.numRows;
 800291a: 687b         	ldr	r3, [r7, #0x4]
 800291c: f8b3 20c0    	ldrh.w	r2, [r3, #0xc0]
 8002920: 687b         	ldr	r3, [r7, #0x4]
 8002922: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 	kf->MatStatus = Matrix_Transpose(&kf->temp_vector1,
 8002926: 687b         	ldr	r3, [r7, #0x4]
 8002928: f103 02c0    	add.w	r2, r3, #0xc0
 800292c: 687b         	ldr	r3, [r7, #0x4]
 800292e: 33b8         	adds	r3, #0xb8
 8002930: 4619         	mov	r1, r3
 8002932: 4610         	mov	r0, r2
 8002934: f010 ff42    	bl	0x80137bc <arm_mat_trans_f32> @ imm = #0x10e84
 8002938: 4603         	mov	r3, r0
 800293a: 461a         	mov	r2, r3
 800293c: 687b         	ldr	r3, [r7, #0x4]
 800293e: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->MatStatus = Matrix_Multiply(&kf->temp_vector, &kf->temp_matrix, &QEKF_INS.ChiSquare);
 8002942: 687b         	ldr	r3, [r7, #0x4]
 8002944: f103 00b8    	add.w	r0, r3, #0xb8
 8002948: 687b         	ldr	r3, [r7, #0x4]
 800294a: 33a8         	adds	r3, #0xa8
 800294c: 4a42         	ldr	r2, [pc, #0x108]        @ 0x8002a58 <IMU_QuaternionEKF_xhatUpdate+0x3e8>
 800294e: 4619         	mov	r1, r3
 8002950: f010 feae    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #0x10d5c
 8002954: 4603         	mov	r3, r0
 8002956: 461a         	mov	r2, r3
 8002958: 687b         	ldr	r3, [r7, #0x4]
 800295a: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	if (QEKF_INS.ChiSquare_Data[0] < 0.5f * QEKF_INS.ChiSquareTestThreshold) {
 800295e: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8002960: ed93 7a72    	<unknown>
 8002964: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8002966: edd3 7a73    	<unknown>
 800296a: eef6 6a00    	<unknown>
 800296e: ee67 7aa6    	<unknown>
 8002972: eeb4 7ae7    	<unknown>
 8002976: eef1 fa10    	<unknown>
 800297a: d503         	bpl	0x8002984 <IMU_QuaternionEKF_xhatUpdate+0x314> @ imm = #0x6
; 		QEKF_INS.ConvergeFlag = 1;
 800297c: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 800297e: 2201         	movs	r2, #0x1
 8002980: f883 2138    	strb.w	r2, [r3, #0x138]
; 	if (QEKF_INS.ChiSquare_Data[0] > QEKF_INS.ChiSquareTestThreshold && QEKF_INS.ConvergeFlag) {
 8002984: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8002986: ed93 7a72    	<unknown>
 800298a: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 800298c: edd3 7a73    	<unknown>
 8002990: eeb4 7ae7    	<unknown>
 8002994: eef1 fa10    	<unknown>
 8002998: dd62         	ble	0x8002a60 <IMU_QuaternionEKF_xhatUpdate+0x3f0> @ imm = #0xc4
 800299a: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 800299c: f893 3138    	ldrb.w	r3, [r3, #0x138]
 80029a0: 2b00         	cmp	r3, #0x0
 80029a2: d05d         	beq	0x8002a60 <IMU_QuaternionEKF_xhatUpdate+0x3f0> @ imm = #0xba
; 		if (QEKF_INS.StableFlag) {
 80029a4: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 80029a6: f893 3139    	ldrb.w	r3, [r3, #0x139]
 80029aa: 2b00         	cmp	r3, #0x0
 80029ac: d009         	beq	0x80029c2 <IMU_QuaternionEKF_xhatUpdate+0x352> @ imm = #0x12
; 			QEKF_INS.ErrorCount++; // 载体静止时仍无法通过卡方检验
 80029ae: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 80029b0: e9d3 2350    	ldrd	r2, r3, [r3, #320]
 80029b4: 1c54         	adds	r4, r2, #0x1
 80029b6: f143 0500    	adc	r5, r3, #0x0
 80029ba: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 80029bc: e9c3 4550    	strd	r4, r5, [r3, #320]
 80029c0: e006         	b	0x80029d0 <IMU_QuaternionEKF_xhatUpdate+0x360> @ imm = #0xc
; 			QEKF_INS.ErrorCount = 0;
 80029c2: 4924         	ldr	r1, [pc, #0x90]         @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 80029c4: f04f 0200    	mov.w	r2, #0x0
 80029c8: f04f 0300    	mov.w	r3, #0x0
 80029cc: e9c1 2350    	strd	r2, r3, [r1, #320]
; 		if (QEKF_INS.ErrorCount > 50) {
 80029d0: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 80029d2: e9d3 2350    	ldrd	r2, r3, [r3, #320]
 80029d6: 2a33         	cmp	r2, #0x33
 80029d8: f173 0300    	sbcs	r3, r3, #0x0
 80029dc: d308         	blo	0x80029f0 <IMU_QuaternionEKF_xhatUpdate+0x380> @ imm = #0x10
; 			QEKF_INS.ConvergeFlag = 0;
 80029de: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8002a54 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 80029e0: 2200         	movs	r2, #0x0
 80029e2: f883 2138    	strb.w	r2, [r3, #0x138]
; 			kf->SkipEq5 = FALSE; // step-5 is cov mat P updating
 80029e6: 687b         	ldr	r3, [r7, #0x4]
 80029e8: 2200         	movs	r2, #0x0
 80029ea: f883 202c    	strb.w	r2, [r3, #0x2c]
; 		if (QEKF_INS.ErrorCount > 50) {
 80029ee: e070         	b	0x8002ad2 <IMU_QuaternionEKF_xhatUpdate+0x462> @ imm = #0xe0
; 			memcpy(kf->xhat_data, kf->xhatminus_data, sizeof_float * kf->xhatSize);
 80029f0: 687b         	ldr	r3, [r7, #0x4]
 80029f2: f8d3 00e8    	ldr.w	r0, [r3, #0xe8]
 80029f6: 687b         	ldr	r3, [r7, #0x4]
 80029f8: f8d3 10ec    	ldr.w	r1, [r3, #0xec]
 80029fc: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8002a5c <IMU_QuaternionEKF_xhatUpdate+0x3ec>
 80029fe: 881b         	ldrh	r3, [r3]
 8002a00: 461a         	mov	r2, r3
 8002a02: 687b         	ldr	r3, [r7, #0x4]
 8002a04: 7b1b         	ldrb	r3, [r3, #0xc]
 8002a06: fb02 f303    	mul	r3, r2, r3
 8002a0a: 461a         	mov	r2, r3
 8002a0c: f026 fb72    	bl	0x80290f4 <memcpy>      @ imm = #0x266e4
; 			memcpy(kf->P_data, kf->Pminus_data,
 8002a10: 687b         	ldr	r3, [r7, #0x4]
 8002a12: f8d3 00f8    	ldr.w	r0, [r3, #0xf8]
 8002a16: 687b         	ldr	r3, [r7, #0x4]
 8002a18: f8d3 10fc    	ldr.w	r1, [r3, #0xfc]
; 			       sizeof_float * kf->xhatSize * kf->xhatSize);
 8002a1c: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8002a5c <IMU_QuaternionEKF_xhatUpdate+0x3ec>
 8002a1e: 881b         	ldrh	r3, [r3]
 8002a20: 461a         	mov	r2, r3
 8002a22: 687b         	ldr	r3, [r7, #0x4]
 8002a24: 7b1b         	ldrb	r3, [r3, #0xc]
 8002a26: fb02 f303    	mul	r3, r2, r3
 8002a2a: 687a         	ldr	r2, [r7, #0x4]
 8002a2c: 7b12         	ldrb	r2, [r2, #0xc]
 8002a2e: fb02 f303    	mul	r3, r2, r3
; 			memcpy(kf->P_data, kf->Pminus_data,
 8002a32: 461a         	mov	r2, r3
 8002a34: f026 fb5e    	bl	0x80290f4 <memcpy>      @ imm = #0x266bc
; 			kf->SkipEq5 = TRUE; // part5 is P updating
 8002a38: 687b         	ldr	r3, [r7, #0x4]
 8002a3a: 2201         	movs	r2, #0x1
 8002a3c: f883 202c    	strb.w	r2, [r3, #0x2c]
; 			return;
 8002a40: e15a         	b	0x8002cf8 <IMU_QuaternionEKF_xhatUpdate+0x688> @ imm = #0x2b4
 8002a42: bf00         	nop

08002a44 <$d>:
 8002a44: e8 27 00 24  	.word	0x240027e8
 8002a48: ec 27 00 24  	.word	0x240027ec
 8002a4c: f0 27 00 24  	.word	0x240027f0
 8002a50: f4 27 00 24  	.word	0x240027f4
 8002a54: a0 0d 00 24  	.word	0x24000da0
 8002a58: 60 0f 00 24  	.word	0x24000f60
 8002a5c: ec 32 00 24  	.word	0x240032ec

08002a60 <$t>:
; 		if (QEKF_INS.ChiSquare_Data[0] > 0.1f * QEKF_INS.ChiSquareTestThreshold &&
 8002a60: 4ba7         	ldr	r3, [pc, #0x29c]        @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a62: ed93 7a72    	<unknown>
 8002a66: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a68: edd3 7a73    	<unknown>
 8002a6c: eddf 6aa5    	<unknown>
 8002a70: ee67 7aa6    	<unknown>
 8002a74: eeb4 7ae7    	<unknown>
 8002a78: eef1 fa10    	<unknown>
 8002a7c: dd19         	ble	0x8002ab2 <IMU_QuaternionEKF_xhatUpdate+0x442> @ imm = #0x32
; 		    QEKF_INS.ConvergeFlag) {
 8002a7e: 4ba0         	ldr	r3, [pc, #0x280]        @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a80: f893 3138    	ldrb.w	r3, [r3, #0x138]
; 		if (QEKF_INS.ChiSquare_Data[0] > 0.1f * QEKF_INS.ChiSquareTestThreshold &&
 8002a84: 2b00         	cmp	r3, #0x0
 8002a86: d014         	beq	0x8002ab2 <IMU_QuaternionEKF_xhatUpdate+0x442> @ imm = #0x28
; 				(QEKF_INS.ChiSquareTestThreshold - QEKF_INS.ChiSquare_Data[0]) /
 8002a88: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a8a: ed93 7a73    	<unknown>
 8002a8e: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a90: edd3 7a72    	<unknown>
 8002a94: ee77 6a67    	<unknown>
; 				(0.9f * QEKF_INS.ChiSquareTestThreshold);
 8002a98: 4b99         	ldr	r3, [pc, #0x264]        @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a9a: edd3 7a73    	<unknown>
 8002a9e: ed9f 7a9a    	<unknown>
 8002aa2: ee27 7a87    	<unknown>
; 				(QEKF_INS.ChiSquareTestThreshold - QEKF_INS.ChiSquare_Data[0]) /
 8002aa6: eec6 7a87    	<unknown>
; 			QEKF_INS.AdaptiveGainScale =
 8002aaa: 4b95         	ldr	r3, [pc, #0x254]        @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002aac: edc3 7a67    	<unknown>
 8002ab0: e004         	b	0x8002abc <IMU_QuaternionEKF_xhatUpdate+0x44c> @ imm = #0x8
; 			QEKF_INS.AdaptiveGainScale = 1;
 8002ab2: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002ab4: f04f 527e    	mov.w	r2, #0x3f800000
 8002ab8: f8c3 219c    	str.w	r2, [r3, #0x19c]
; 		QEKF_INS.ErrorCount = 0;
 8002abc: 4990         	ldr	r1, [pc, #0x240]        @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002abe: f04f 0200    	mov.w	r2, #0x0
 8002ac2: f04f 0300    	mov.w	r3, #0x0
 8002ac6: e9c1 2350    	strd	r2, r3, [r1, #320]
; 		kf->SkipEq5 = FALSE;
 8002aca: 687b         	ldr	r3, [r7, #0x4]
 8002acc: 2200         	movs	r2, #0x0
 8002ace: f883 202c    	strb.w	r2, [r3, #0x2c]
; 	kf->temp_matrix.numRows = kf->Pminus.numRows;
 8002ad2: 687b         	ldr	r3, [r7, #0x4]
 8002ad4: f8b3 2058    	ldrh.w	r2, [r3, #0x58]
 8002ad8: 687b         	ldr	r3, [r7, #0x4]
 8002ada: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 	kf->temp_matrix.numCols = kf->HT.numCols;
 8002ade: 687b         	ldr	r3, [r7, #0x4]
 8002ae0: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 8002ae4: 687b         	ldr	r3, [r7, #0x4]
 8002ae6: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		Matrix_Multiply(&kf->Pminus, &kf->HT, &kf->temp_matrix); // temp_matrix = P'(k)·HT
 8002aea: 687b         	ldr	r3, [r7, #0x4]
 8002aec: f103 0058    	add.w	r0, r3, #0x58
 8002af0: 687b         	ldr	r3, [r7, #0x4]
 8002af2: f103 0180    	add.w	r1, r3, #0x80
 8002af6: 687b         	ldr	r3, [r7, #0x4]
 8002af8: 33a8         	adds	r3, #0xa8
 8002afa: 461a         	mov	r2, r3
 8002afc: f010 fdd8    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #0x10bb0
 8002b00: 4603         	mov	r3, r0
 8002b02: 461a         	mov	r2, r3
; 	kf->MatStatus =
 8002b04: 687b         	ldr	r3, [r7, #0x4]
 8002b06: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->temp_matrix1, &kf->K);
 8002b0a: 687b         	ldr	r3, [r7, #0x4]
 8002b0c: f103 00a8    	add.w	r0, r3, #0xa8
 8002b10: 687b         	ldr	r3, [r7, #0x4]
 8002b12: f103 01b0    	add.w	r1, r3, #0xb0
 8002b16: 687b         	ldr	r3, [r7, #0x4]
 8002b18: 3398         	adds	r3, #0x98
 8002b1a: 461a         	mov	r2, r3
 8002b1c: f010 fdc8    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #0x10b90
 8002b20: 4603         	mov	r3, r0
 8002b22: 461a         	mov	r2, r3
 8002b24: 687b         	ldr	r3, [r7, #0x4]
 8002b26: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	for (uint8_t i = 0; i < kf->K.numRows * kf->K.numCols; ++i) {
 8002b2a: 2300         	movs	r3, #0x0
 8002b2c: 75bb         	strb	r3, [r7, #0x16]
 8002b2e: e017         	b	0x8002b60 <IMU_QuaternionEKF_xhatUpdate+0x4f0> @ imm = #0x2e
; 		kf->K_data[i] *= QEKF_INS.AdaptiveGainScale;
 8002b30: 687b         	ldr	r3, [r7, #0x4]
 8002b32: f8d3 211c    	ldr.w	r2, [r3, #0x11c]
 8002b36: 7dbb         	ldrb	r3, [r7, #0x16]
 8002b38: 009b         	lsls	r3, r3, #0x2
 8002b3a: 4413         	add	r3, r2
 8002b3c: ed93 7a00    	<unknown>
 8002b40: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002b42: edd3 7a67    	<unknown>
 8002b46: 687b         	ldr	r3, [r7, #0x4]
 8002b48: f8d3 211c    	ldr.w	r2, [r3, #0x11c]
 8002b4c: 7dbb         	ldrb	r3, [r7, #0x16]
 8002b4e: 009b         	lsls	r3, r3, #0x2
 8002b50: 4413         	add	r3, r2
 8002b52: ee67 7a27    	<unknown>
 8002b56: edc3 7a00    	<unknown>
; 	for (uint8_t i = 0; i < kf->K.numRows * kf->K.numCols; ++i) {
 8002b5a: 7dbb         	ldrb	r3, [r7, #0x16]
 8002b5c: 3301         	adds	r3, #0x1
 8002b5e: 75bb         	strb	r3, [r7, #0x16]
 8002b60: 7dba         	ldrb	r2, [r7, #0x16]
 8002b62: 687b         	ldr	r3, [r7, #0x4]
 8002b64: f8b3 3098    	ldrh.w	r3, [r3, #0x98]
 8002b68: 4619         	mov	r1, r3
 8002b6a: 687b         	ldr	r3, [r7, #0x4]
 8002b6c: f8b3 309a    	ldrh.w	r3, [r3, #0x9a]
 8002b70: fb01 f303    	mul	r3, r1, r3
 8002b74: 429a         	cmp	r2, r3
 8002b76: dbdb         	blt	0x8002b30 <IMU_QuaternionEKF_xhatUpdate+0x4c0> @ imm = #-0x4a
; 	for (uint8_t i = 4; i < 6; ++i) {
 8002b78: 2304         	movs	r3, #0x4
 8002b7a: 757b         	strb	r3, [r7, #0x15]
 8002b7c: e034         	b	0x8002be8 <IMU_QuaternionEKF_xhatUpdate+0x578> @ imm = #0x68
; 		for (uint8_t j = 0; j < 3; ++j) {
 8002b7e: 2300         	movs	r3, #0x0
 8002b80: 753b         	strb	r3, [r7, #0x14]
 8002b82: e02b         	b	0x8002bdc <IMU_QuaternionEKF_xhatUpdate+0x56c> @ imm = #0x56
; 			kf->K_data[i * 3 + j] *=
 8002b84: 687b         	ldr	r3, [r7, #0x4]
 8002b86: f8d3 111c    	ldr.w	r1, [r3, #0x11c]
 8002b8a: 7d7a         	ldrb	r2, [r7, #0x15]
 8002b8c: 4613         	mov	r3, r2
 8002b8e: 005b         	lsls	r3, r3, #0x1
 8002b90: 441a         	add	r2, r3
 8002b92: 7d3b         	ldrb	r3, [r7, #0x14]
 8002b94: 4413         	add	r3, r2
 8002b96: 009b         	lsls	r3, r3, #0x2
 8002b98: 440b         	add	r3, r1
 8002b9a: ed93 7a00    	<unknown>
; 				QEKF_INS.OrientationCosine[i - 4] / 1.5707963f; // 1 rad
 8002b9e: 7d7b         	ldrb	r3, [r7, #0x15]
 8002ba0: 3b04         	subs	r3, #0x4
 8002ba2: 4a57         	ldr	r2, [pc, #0x15c]        @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002ba4: 3360         	adds	r3, #0x60
 8002ba6: 009b         	lsls	r3, r3, #0x2
 8002ba8: 4413         	add	r3, r2
 8002baa: 3304         	adds	r3, #0x4
 8002bac: edd3 6a00    	<unknown>
 8002bb0: ed9f 6a56    	<unknown>
 8002bb4: eec6 7a86    	<unknown>
; 			kf->K_data[i * 3 + j] *=
 8002bb8: 687b         	ldr	r3, [r7, #0x4]
 8002bba: f8d3 111c    	ldr.w	r1, [r3, #0x11c]
 8002bbe: 7d7a         	ldrb	r2, [r7, #0x15]
 8002bc0: 4613         	mov	r3, r2
 8002bc2: 005b         	lsls	r3, r3, #0x1
 8002bc4: 441a         	add	r2, r3
 8002bc6: 7d3b         	ldrb	r3, [r7, #0x14]
 8002bc8: 4413         	add	r3, r2
 8002bca: 009b         	lsls	r3, r3, #0x2
 8002bcc: 440b         	add	r3, r1
 8002bce: ee67 7a27    	<unknown>
 8002bd2: edc3 7a00    	<unknown>
; 		for (uint8_t j = 0; j < 3; ++j) {
 8002bd6: 7d3b         	ldrb	r3, [r7, #0x14]
 8002bd8: 3301         	adds	r3, #0x1
 8002bda: 753b         	strb	r3, [r7, #0x14]
 8002bdc: 7d3b         	ldrb	r3, [r7, #0x14]
 8002bde: 2b02         	cmp	r3, #0x2
 8002be0: d9d0         	bls	0x8002b84 <IMU_QuaternionEKF_xhatUpdate+0x514> @ imm = #-0x60
; 	for (uint8_t i = 4; i < 6; ++i) {
 8002be2: 7d7b         	ldrb	r3, [r7, #0x15]
 8002be4: 3301         	adds	r3, #0x1
 8002be6: 757b         	strb	r3, [r7, #0x15]
 8002be8: 7d7b         	ldrb	r3, [r7, #0x15]
 8002bea: 2b05         	cmp	r3, #0x5
 8002bec: d9c7         	bls	0x8002b7e <IMU_QuaternionEKF_xhatUpdate+0x50e> @ imm = #-0x72
; 	kf->temp_vector.numRows = kf->K.numRows;
 8002bee: 687b         	ldr	r3, [r7, #0x4]
 8002bf0: f8b3 2098    	ldrh.w	r2, [r3, #0x98]
 8002bf4: 687b         	ldr	r3, [r7, #0x4]
 8002bf6: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 	kf->temp_vector.numCols = 1;
 8002bfa: 687b         	ldr	r3, [r7, #0x4]
 8002bfc: 2201         	movs	r2, #0x1
 8002bfe: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 	kf->MatStatus = Matrix_Multiply(&kf->K, &kf->temp_vector1,
 8002c02: 687b         	ldr	r3, [r7, #0x4]
 8002c04: f103 0098    	add.w	r0, r3, #0x98
 8002c08: 687b         	ldr	r3, [r7, #0x4]
 8002c0a: f103 01c0    	add.w	r1, r3, #0xc0
 8002c0e: 687b         	ldr	r3, [r7, #0x4]
 8002c10: 33b8         	adds	r3, #0xb8
 8002c12: 461a         	mov	r2, r3
 8002c14: f010 fd4c    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #0x10a98
 8002c18: 4603         	mov	r3, r0
 8002c1a: 461a         	mov	r2, r3
 8002c1c: 687b         	ldr	r3, [r7, #0x4]
 8002c1e: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	if (QEKF_INS.ConvergeFlag) {
 8002c22: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002c24: f893 3138    	ldrb.w	r3, [r3, #0x138]
 8002c28: 2b00         	cmp	r3, #0x0
 8002c2a: d04e         	beq	0x8002cca <IMU_QuaternionEKF_xhatUpdate+0x65a> @ imm = #0x9c
; 		for (uint8_t i = 4; i < 6; ++i) {
 8002c2c: 2304         	movs	r3, #0x4
 8002c2e: 74fb         	strb	r3, [r7, #0x13]
 8002c30: e048         	b	0x8002cc4 <IMU_QuaternionEKF_xhatUpdate+0x654> @ imm = #0x90
; 			if (kf->temp_vector.pData[i] > 1e-2f * QEKF_INS.dt) {
 8002c32: 687b         	ldr	r3, [r7, #0x4]
 8002c34: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 8002c38: 7cfb         	ldrb	r3, [r7, #0x13]
 8002c3a: 009b         	lsls	r3, r3, #0x2
 8002c3c: 4413         	add	r3, r2
 8002c3e: ed93 7a00    	<unknown>
 8002c42: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002c44: edd3 7a6f    	<unknown>
 8002c48: eddf 6a31    	<unknown>
 8002c4c: ee67 7aa6    	<unknown>
 8002c50: eeb4 7ae7    	<unknown>
 8002c54: eef1 fa10    	<unknown>
 8002c58: dd0e         	ble	0x8002c78 <IMU_QuaternionEKF_xhatUpdate+0x608> @ imm = #0x1c
; 				kf->temp_vector.pData[i] = 1e-2f * QEKF_INS.dt;
 8002c5a: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002c5c: edd3 7a6f    	<unknown>
 8002c60: 687b         	ldr	r3, [r7, #0x4]
 8002c62: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 8002c66: 7cfb         	ldrb	r3, [r7, #0x13]
 8002c68: 009b         	lsls	r3, r3, #0x2
 8002c6a: 4413         	add	r3, r2
 8002c6c: ed9f 7a28    	<unknown>
 8002c70: ee67 7a87    	<unknown>
 8002c74: edc3 7a00    	<unknown>
; 			if (kf->temp_vector.pData[i] < -1e-2f * QEKF_INS.dt) {
 8002c78: 687b         	ldr	r3, [r7, #0x4]
 8002c7a: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 8002c7e: 7cfb         	ldrb	r3, [r7, #0x13]
 8002c80: 009b         	lsls	r3, r3, #0x2
 8002c82: 4413         	add	r3, r2
 8002c84: ed93 7a00    	<unknown>
 8002c88: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002c8a: edd3 7a6f    	<unknown>
 8002c8e: eddf 6a21    	<unknown>
 8002c92: ee67 7aa6    	<unknown>
 8002c96: eeb4 7ae7    	<unknown>
 8002c9a: eef1 fa10    	<unknown>
 8002c9e: d50e         	bpl	0x8002cbe <IMU_QuaternionEKF_xhatUpdate+0x64e> @ imm = #0x1c
; 				kf->temp_vector.pData[i] = -1e-2f * QEKF_INS.dt;
 8002ca0: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8002d00 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002ca2: edd3 7a6f    	<unknown>
 8002ca6: 687b         	ldr	r3, [r7, #0x4]
 8002ca8: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 8002cac: 7cfb         	ldrb	r3, [r7, #0x13]
 8002cae: 009b         	lsls	r3, r3, #0x2
 8002cb0: 4413         	add	r3, r2
 8002cb2: ed9f 7a18    	<unknown>
 8002cb6: ee67 7a87    	<unknown>
 8002cba: edc3 7a00    	<unknown>
; 		for (uint8_t i = 4; i < 6; ++i) {
 8002cbe: 7cfb         	ldrb	r3, [r7, #0x13]
 8002cc0: 3301         	adds	r3, #0x1
 8002cc2: 74fb         	strb	r3, [r7, #0x13]
 8002cc4: 7cfb         	ldrb	r3, [r7, #0x13]
 8002cc6: 2b05         	cmp	r3, #0x5
 8002cc8: d9b3         	bls	0x8002c32 <IMU_QuaternionEKF_xhatUpdate+0x5c2> @ imm = #-0x9a
; 	kf->temp_vector.pData[3] = 0;
 8002cca: 687b         	ldr	r3, [r7, #0x4]
 8002ccc: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 8002cd0: 330c         	adds	r3, #0xc
 8002cd2: f04f 0200    	mov.w	r2, #0x0
 8002cd6: 601a         	str	r2, [r3]
; 	kf->MatStatus = Matrix_Add(&kf->xhatminus, &kf->temp_vector, &kf->xhat);
 8002cd8: 687b         	ldr	r3, [r7, #0x4]
 8002cda: f103 0038    	add.w	r0, r3, #0x38
 8002cde: 687b         	ldr	r3, [r7, #0x4]
 8002ce0: f103 01b8    	add.w	r1, r3, #0xb8
 8002ce4: 687b         	ldr	r3, [r7, #0x4]
 8002ce6: 3330         	adds	r3, #0x30
 8002ce8: 461a         	mov	r2, r3
 8002cea: f010 fb4b    	bl	0x8013384 <arm_mat_add_f32> @ imm = #0x10696
 8002cee: 4603         	mov	r3, r0
 8002cf0: 461a         	mov	r2, r3
 8002cf2: 687b         	ldr	r3, [r7, #0x4]
 8002cf4: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 8002cf8: 371c         	adds	r7, #0x1c
 8002cfa: 46bd         	mov	sp, r7
 8002cfc: bdf0         	pop	{r4, r5, r6, r7, pc}
 8002cfe: bf00         	nop

08002d00 <$d>:
 8002d00: a0 0d 00 24  	.word	0x24000da0
 8002d04: cd cc cc 3d  	.word	0x3dcccccd
 8002d08: 66 66 66 3f  	.word	0x3f666666
 8002d0c: da 0f c9 3f  	.word	0x3fc90fda
 8002d10: 0a d7 23 3c  	.word	0x3c23d70a
 8002d14: 0a d7 23 bc  	.word	0xbc23d70a

08002d18 <IMU_QuaternionEKF_Observe>:
; {
 8002d18: b580         	push	{r7, lr}
 8002d1a: b082         	sub	sp, #0x8
 8002d1c: af00         	add	r7, sp, #0x0
 8002d1e: 6078         	str	r0, [r7, #0x4]
; 	memcpy(IMU_QuaternionEKF_P, kf->P_data, sizeof(IMU_QuaternionEKF_P));
 8002d20: 687b         	ldr	r3, [r7, #0x4]
 8002d22: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002d26: 2290         	movs	r2, #0x90
 8002d28: 4619         	mov	r1, r3
 8002d2a: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8002d58 <IMU_QuaternionEKF_Observe+0x40>
 8002d2c: f026 f9e2    	bl	0x80290f4 <memcpy>      @ imm = #0x263c4
; 	memcpy(IMU_QuaternionEKF_K, kf->K_data, sizeof(IMU_QuaternionEKF_K));
 8002d30: 687b         	ldr	r3, [r7, #0x4]
 8002d32: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8002d36: 2248         	movs	r2, #0x48
 8002d38: 4619         	mov	r1, r3
 8002d3a: 4808         	ldr	r0, [pc, #0x20]         @ 0x8002d5c <IMU_QuaternionEKF_Observe+0x44>
 8002d3c: f026 f9da    	bl	0x80290f4 <memcpy>      @ imm = #0x263b4
; 	memcpy(IMU_QuaternionEKF_H, kf->H_data, sizeof(IMU_QuaternionEKF_H));
 8002d40: 687b         	ldr	r3, [r7, #0x4]
 8002d42: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002d46: 2248         	movs	r2, #0x48
 8002d48: 4619         	mov	r1, r3
 8002d4a: 4805         	ldr	r0, [pc, #0x14]         @ 0x8002d60 <IMU_QuaternionEKF_Observe+0x48>
 8002d4c: f026 f9d2    	bl	0x80290f4 <memcpy>      @ imm = #0x263a4
; }
 8002d50: bf00         	nop
 8002d52: 3708         	adds	r7, #0x8
 8002d54: 46bd         	mov	sp, r7
 8002d56: bd80         	pop	{r7, pc}

08002d58 <$d>:
 8002d58: 8c 05 00 24  	.word	0x2400058c
 8002d5c: e4 25 00 24  	.word	0x240025e4
 8002d60: 2c 26 00 24  	.word	0x2400262c

08002d64 <invSqrt>:
; {
 8002d64: b480         	push	{r7}
 8002d66: b087         	sub	sp, #0x1c
 8002d68: af00         	add	r7, sp, #0x0
 8002d6a: ed87 0a01    	<unknown>
; 	float halfx = 0.5f * x;
 8002d6e: edd7 7a01    	<unknown>
 8002d72: eeb6 7a00    	<unknown>
 8002d76: ee67 7a87    	<unknown>
 8002d7a: edc7 7a05    	<unknown>
; 	float y = x;
 8002d7e: 687b         	ldr	r3, [r7, #0x4]
 8002d80: 613b         	str	r3, [r7, #0x10]
; 	long i = *(long *)&y;
 8002d82: f107 0310    	add.w	r3, r7, #0x10
 8002d86: 681b         	ldr	r3, [r3]
 8002d88: 60fb         	str	r3, [r7, #0xc]
; 	i = 0x5f375a86 - (i >> 1);
 8002d8a: 68fb         	ldr	r3, [r7, #0xc]
 8002d8c: 105a         	asrs	r2, r3, #0x1
 8002d8e: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8002dd8 <invSqrt+0x74>
 8002d90: 1a9b         	subs	r3, r3, r2
 8002d92: 60fb         	str	r3, [r7, #0xc]
; 	y = *(float *)&i;
 8002d94: f107 030c    	add.w	r3, r7, #0xc
 8002d98: 681b         	ldr	r3, [r3]
 8002d9a: 613b         	str	r3, [r7, #0x10]
; 	y = y * (1.5f - (halfx * y * y));
 8002d9c: ed97 7a04    	<unknown>
 8002da0: edd7 7a05    	<unknown>
 8002da4: ee27 7a27    	<unknown>
 8002da8: edd7 7a04    	<unknown>
 8002dac: ee67 7a27    	<unknown>
 8002db0: eeb7 7a08    	<unknown>
 8002db4: ee37 7a67    	<unknown>
 8002db8: edd7 7a04    	<unknown>
 8002dbc: ee67 7a27    	<unknown>
 8002dc0: edc7 7a04    	<unknown>
; 	return y;
 8002dc4: 693b         	ldr	r3, [r7, #0x10]
 8002dc6: ee07 3a90    	<unknown>
; }
 8002dca: eeb0 0a67    	<unknown>
 8002dce: 371c         	adds	r7, #0x1c
 8002dd0: 46bd         	mov	sp, r7
 8002dd2: f85d 7b04    	ldr	r7, [sp], #4
 8002dd6: 4770         	bx	lr

08002dd8 <$d>:
 8002dd8: 86 5a 37 5f  	.word	0x5f375a86

08002ddc <Sqrt>:
; {
 8002ddc: b480         	push	{r7}
 8002dde: b087         	sub	sp, #0x1c
 8002de0: af00         	add	r7, sp, #0x0
 8002de2: ed87 0a01    	<unknown>
; 	if (x <= 0) {
 8002de6: edd7 7a01    	<unknown>
 8002dea: eef5 7ac0    	<unknown>
 8002dee: eef1 fa10    	<unknown>
 8002df2: d802         	bhi	0x8002dfa <Sqrt+0x1e>   @ imm = #0x4
; 		return 0;
 8002df4: f04f 0300    	mov.w	r3, #0x0
 8002df8: e03c         	b	0x8002e74 <Sqrt+0x98>   @ imm = #0x78
; 	y = x / 2;
 8002dfa: ed97 7a01    	<unknown>
 8002dfe: eef0 6a00    	<unknown>
 8002e02: eec7 7a26    	<unknown>
 8002e06: edc7 7a05    	<unknown>
; 	maxError = x * 0.001f;
 8002e0a: edd7 7a01    	<unknown>
 8002e0e: ed9f 7a1e    	<unknown>
 8002e12: ee67 7a87    	<unknown>
 8002e16: edc7 7a04    	<unknown>
; 		delta = (y * y) - x;
 8002e1a: edd7 7a05    	<unknown>
 8002e1e: ee27 7aa7    	<unknown>
 8002e22: edd7 7a01    	<unknown>
 8002e26: ee77 7a67    	<unknown>
 8002e2a: edc7 7a03    	<unknown>
; 		y -= delta / (2 * y);
 8002e2e: edd7 7a05    	<unknown>
 8002e32: ee37 7aa7    	<unknown>
 8002e36: edd7 6a03    	<unknown>
 8002e3a: eec6 7a87    	<unknown>
 8002e3e: ed97 7a05    	<unknown>
 8002e42: ee77 7a67    	<unknown>
 8002e46: edc7 7a05    	<unknown>
; 	} while (delta > maxError || delta < -maxError);
 8002e4a: ed97 7a03    	<unknown>
 8002e4e: edd7 7a04    	<unknown>
 8002e52: eeb4 7ae7    	<unknown>
 8002e56: eef1 fa10    	<unknown>
 8002e5a: dcde         	bgt	0x8002e1a <Sqrt+0x3e>   @ imm = #-0x44
 8002e5c: edd7 7a04    	<unknown>
 8002e60: eef1 7a67    	<unknown>
 8002e64: ed97 7a03    	<unknown>
 8002e68: eeb4 7ae7    	<unknown>
 8002e6c: eef1 fa10    	<unknown>
 8002e70: d4d3         	bmi	0x8002e1a <Sqrt+0x3e>   @ imm = #-0x5a
; 	return y;
 8002e72: 697b         	ldr	r3, [r7, #0x14]
; }
 8002e74: ee07 3a90    	<unknown>
 8002e78: eeb0 0a67    	<unknown>
 8002e7c: 371c         	adds	r7, #0x1c
 8002e7e: 46bd         	mov	sp, r7
 8002e80: f85d 7b04    	ldr	r7, [sp], #4
 8002e84: 4770         	bx	lr
 8002e86: bf00         	nop

08002e88 <$d>:
 8002e88: 6f 12 83 3a  	.word	0x3a83126f

08002e8c <IMU_Sensor_handle_update>:
; {
 8002e8c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8002e90: b084         	sub	sp, #0x10
 8002e92: af00         	add	r7, sp, #0x0
 8002e94: 6078         	str	r0, [r7, #0x4]
; 	if (data->flag < 3) {
 8002e96: 6879         	ldr	r1, [r7, #0x4]
 8002e98: f891 1024    	ldrb.w	r1, [r1, #0x24]
 8002e9c: 2902         	cmp	r1, #0x2
 8002e9e: f240 80ca    	bls.w	0x8003036 <IMU_Sensor_handle_update+0x1aa> @ imm = #0x194
; 	data->flag = 0;
 8002ea2: 6879         	ldr	r1, [r7, #0x4]
 8002ea4: 2000         	movs	r0, #0x0
 8002ea6: f881 0024    	strb.w	r0, [r1, #0x24]
; 	count++;
 8002eaa: 4965         	ldr	r1, [pc, #0x194]        @ 0x8003040 <IMU_Sensor_handle_update+0x1b4>
 8002eac: 6809         	ldr	r1, [r1]
 8002eae: 3101         	adds	r1, #0x1
 8002eb0: 4863         	ldr	r0, [pc, #0x18c]        @ 0x8003040 <IMU_Sensor_handle_update+0x1b4>
 8002eb2: 6001         	str	r1, [r0]
; 		k_cyc_to_us_near32(data->accel_curr_cyc - data->accel_prev_cyc) * 0.000001f;
 8002eb4: 6879         	ldr	r1, [r7, #0x4]
 8002eb6: 6b88         	ldr	r0, [r1, #0x38]
 8002eb8: 6879         	ldr	r1, [r7, #0x4]
 8002eba: 6ac9         	ldr	r1, [r1, #0x2c]
 8002ebc: 1a41         	subs	r1, r0, r1
 8002ebe: 2900         	cmp	r1, #0x0
 8002ec0: db10         	blt	0x8002ee4 <IMU_Sensor_handle_update+0x58> @ imm = #0x20
 8002ec2: 687b         	ldr	r3, [r7, #0x4]
 8002ec4: 6b9a         	ldr	r2, [r3, #0x38]
 8002ec6: 687b         	ldr	r3, [r7, #0x4]
 8002ec8: 6adb         	ldr	r3, [r3, #0x2c]
 8002eca: 1ad3         	subs	r3, r2, r3
 8002ecc: f203 1313    	addw	r3, r3, #0x113
 8002ed0: 085b         	lsrs	r3, r3, #0x1
 8002ed2: 4a5c         	ldr	r2, [pc, #0x170]        @ 0x8003044 <IMU_Sensor_handle_update+0x1b8>
 8002ed4: fba2 2303    	umull	r2, r3, r2, r3
 8002ed8: 09db         	lsrs	r3, r3, #0x7
 8002eda: ee07 3a90    	<unknown>
 8002ede: eef8 7a67    	<unknown>
 8002ee2: e01b         	b	0x8002f1c <IMU_Sensor_handle_update+0x90> @ imm = #0x36
 8002ee4: 6879         	ldr	r1, [r7, #0x4]
 8002ee6: 6b88         	ldr	r0, [r1, #0x38]
 8002ee8: 6879         	ldr	r1, [r7, #0x4]
 8002eea: 6ac9         	ldr	r1, [r1, #0x2c]
 8002eec: 1a41         	subs	r1, r0, r1
 8002eee: 17c8         	asrs	r0, r1, #0x1f
 8002ef0: 460a         	mov	r2, r1
 8002ef2: 4603         	mov	r3, r0
 8002ef4: f240 1113    	movw	r1, #0x113
 8002ef8: eb12 0a01    	adds.w	r10, r2, r1
 8002efc: f143 0b00    	adc	r11, r3, #0x0
 8002f00: f240 2226    	movw	r2, #0x226
 8002f04: f04f 0300    	mov.w	r3, #0x0
 8002f08: 4650         	mov	r0, r10
 8002f0a: 4659         	mov	r1, r11
 8002f0c: f7fd fa30    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x2ba0
 8002f10: 4602         	mov	r2, r0
 8002f12: 460b         	mov	r3, r1
 8002f14: ee07 2a90    	<unknown>
 8002f18: eef8 7a67    	<unknown>
; 	float accel_dt =
 8002f1c: ed9f 7a4a    	<unknown>
 8002f20: ee67 7a87    	<unknown>
 8002f24: edc7 7a03    	<unknown>
; 	float gyro_dt = k_cyc_to_us_near32(data->gyro_curr_cyc - data->gyro_prev_cyc) * 0.000001f;
 8002f28: 687b         	ldr	r3, [r7, #0x4]
 8002f2a: 6b5a         	ldr	r2, [r3, #0x34]
 8002f2c: 687b         	ldr	r3, [r7, #0x4]
 8002f2e: 6a9b         	ldr	r3, [r3, #0x28]
 8002f30: 1ad3         	subs	r3, r2, r3
 8002f32: 2b00         	cmp	r3, #0x0
 8002f34: db10         	blt	0x8002f58 <IMU_Sensor_handle_update+0xcc> @ imm = #0x20
 8002f36: 687b         	ldr	r3, [r7, #0x4]
 8002f38: 6b5a         	ldr	r2, [r3, #0x34]
 8002f3a: 687b         	ldr	r3, [r7, #0x4]
 8002f3c: 6a9b         	ldr	r3, [r3, #0x28]
 8002f3e: 1ad3         	subs	r3, r2, r3
 8002f40: f203 1313    	addw	r3, r3, #0x113
 8002f44: 085b         	lsrs	r3, r3, #0x1
 8002f46: 4a3f         	ldr	r2, [pc, #0xfc]         @ 0x8003044 <IMU_Sensor_handle_update+0x1b8>
 8002f48: fba2 2303    	umull	r2, r3, r2, r3
 8002f4c: 09db         	lsrs	r3, r3, #0x7
 8002f4e: ee07 3a90    	<unknown>
 8002f52: eef8 7a67    	<unknown>
 8002f56: e01b         	b	0x8002f90 <IMU_Sensor_handle_update+0x104> @ imm = #0x36
 8002f58: 687b         	ldr	r3, [r7, #0x4]
 8002f5a: 6b5a         	ldr	r2, [r3, #0x34]
 8002f5c: 687b         	ldr	r3, [r7, #0x4]
 8002f5e: 6a9b         	ldr	r3, [r3, #0x28]
 8002f60: 1ad3         	subs	r3, r2, r3
 8002f62: 17da         	asrs	r2, r3, #0x1f
 8002f64: 461c         	mov	r4, r3
 8002f66: 4615         	mov	r5, r2
 8002f68: f240 1313    	movw	r3, #0x113
 8002f6c: eb14 0803    	adds.w	r8, r4, r3
 8002f70: f145 0900    	adc	r9, r5, #0x0
 8002f74: f240 2226    	movw	r2, #0x226
 8002f78: f04f 0300    	mov.w	r3, #0x0
 8002f7c: 4640         	mov	r0, r8
 8002f7e: 4649         	mov	r1, r9
 8002f80: f7fd f9f6    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x2c14
 8002f84: 4602         	mov	r2, r0
 8002f86: 460b         	mov	r3, r1
 8002f88: ee07 2a90    	<unknown>
 8002f8c: eef8 7a67    	<unknown>
 8002f90: ed9f 7a2d    	<unknown>
 8002f94: ee67 7a87    	<unknown>
 8002f98: edc7 7a02    	<unknown>
; 	IMU_QuaternionEKF_Update(INS.Gyro[X], INS.Gyro[Y], INS.Gyro[Z], INS.Accel[X], INS.Accel[Y],
 8002f9c: 2300         	movs	r3, #0x0
 8002f9e: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x800304c <IMU_Sensor_handle_update+0x1c0>
 8002fa0: 009b         	lsls	r3, r3, #0x2
 8002fa2: 4413         	add	r3, r2
 8002fa4: edd3 7a00    	<unknown>
 8002fa8: 2301         	movs	r3, #0x1
 8002faa: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x800304c <IMU_Sensor_handle_update+0x1c0>
 8002fac: 009b         	lsls	r3, r3, #0x2
 8002fae: 4413         	add	r3, r2
 8002fb0: ed93 7a00    	<unknown>
 8002fb4: 2302         	movs	r3, #0x2
 8002fb6: 4a25         	ldr	r2, [pc, #0x94]         @ 0x800304c <IMU_Sensor_handle_update+0x1c0>
 8002fb8: 009b         	lsls	r3, r3, #0x2
 8002fba: 4413         	add	r3, r2
 8002fbc: edd3 6a00    	<unknown>
 8002fc0: 2300         	movs	r3, #0x0
 8002fc2: 4a22         	ldr	r2, [pc, #0x88]         @ 0x800304c <IMU_Sensor_handle_update+0x1c0>
 8002fc4: 3302         	adds	r3, #0x2
 8002fc6: 009b         	lsls	r3, r3, #0x2
 8002fc8: 4413         	add	r3, r2
 8002fca: 3304         	adds	r3, #0x4
 8002fcc: ed93 6a00    	<unknown>
 8002fd0: 2301         	movs	r3, #0x1
 8002fd2: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x800304c <IMU_Sensor_handle_update+0x1c0>
 8002fd4: 3302         	adds	r3, #0x2
 8002fd6: 009b         	lsls	r3, r3, #0x2
 8002fd8: 4413         	add	r3, r2
 8002fda: 3304         	adds	r3, #0x4
 8002fdc: edd3 5a00    	<unknown>
 8002fe0: 2302         	movs	r3, #0x2
 8002fe2: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x800304c <IMU_Sensor_handle_update+0x1c0>
 8002fe4: 3302         	adds	r3, #0x2
 8002fe6: 009b         	lsls	r3, r3, #0x2
 8002fe8: 4413         	add	r3, r2
 8002fea: 3304         	adds	r3, #0x4
 8002fec: ed93 5a00    	<unknown>
 8002ff0: edd7 3a02    	<unknown>
 8002ff4: ed97 3a03    	<unknown>
 8002ff8: eef0 2a45    	<unknown>
 8002ffc: eeb0 2a65    	<unknown>
 8003000: eef0 1a46    	<unknown>
 8003004: eeb0 1a66    	<unknown>
 8003008: eef0 0a47    	<unknown>
 800300c: eeb0 0a67    	<unknown>
 8003010: f7fe fd7e    	bl	0x8001b10 <IMU_QuaternionEKF_Update> @ imm = #-0x1504
; 	data->gyro_prev_cyc = data->gyro_curr_cyc;
 8003014: 687b         	ldr	r3, [r7, #0x4]
 8003016: 6b5a         	ldr	r2, [r3, #0x34]
 8003018: 687b         	ldr	r3, [r7, #0x4]
 800301a: 629a         	str	r2, [r3, #0x28]
; 	data->accel_prev_cyc = data->accel_curr_cyc;
 800301c: 687b         	ldr	r3, [r7, #0x4]
 800301e: 6b9a         	ldr	r2, [r3, #0x38]
 8003020: 687b         	ldr	r3, [r7, #0x4]
 8003022: 62da         	str	r2, [r3, #0x2c]
; 	if (data->update_cb != NULL) {
 8003024: 687b         	ldr	r3, [r7, #0x4]
 8003026: 6bdb         	ldr	r3, [r3, #0x3c]
 8003028: 2b00         	cmp	r3, #0x0
 800302a: d005         	beq	0x8003038 <IMU_Sensor_handle_update+0x1ac> @ imm = #0xa
; 		data->update_cb(&QEKF_INS);
 800302c: 687b         	ldr	r3, [r7, #0x4]
 800302e: 6bdb         	ldr	r3, [r3, #0x3c]
 8003030: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8003050 <IMU_Sensor_handle_update+0x1c4>
 8003032: 4798         	blx	r3
 8003034: e000         	b	0x8003038 <IMU_Sensor_handle_update+0x1ac> @ imm = #0x0
; 		return;
 8003036: bf00         	nop
; }
 8003038: 3710         	adds	r7, #0x10
 800303a: 46bd         	mov	sp, r7
 800303c: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08003040 <$d>:
 8003040: d0 26 00 24  	.word	0x240026d0
 8003044: 73 07 28 77  	.word	0x77280773
 8003048: bd 37 86 35  	.word	0x358637bd
 800304c: 90 26 00 24  	.word	0x24002690
 8003050: a0 0d 00 24  	.word	0x24000da0

08003054 <IMU_Sensor_set_update_cb>:
; {
 8003054: b480         	push	{r7}
 8003056: b083         	sub	sp, #0xc
 8003058: af00         	add	r7, sp, #0x0
 800305a: 6078         	str	r0, [r7, #0x4]
; 	INS.update_cb = cb;
 800305c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8003070 <IMU_Sensor_set_update_cb+0x1c>
 800305e: 687b         	ldr	r3, [r7, #0x4]
 8003060: 63d3         	str	r3, [r2, #0x3c]
; }
 8003062: bf00         	nop
 8003064: 370c         	adds	r7, #0xc
 8003066: 46bd         	mov	sp, r7
 8003068: f85d 7b04    	ldr	r7, [sp], #4
 800306c: 4770         	bx	lr
 800306e: bf00         	nop

08003070 <$d>:
 8003070: 90 26 00 24  	.word	0x24002690

08003074 <InitQuaternion>:
; {
 8003074: b580         	push	{r7, lr}
 8003076: ed2d 8b02    	<unknown>
 800307a: b096         	sub	sp, #0x58
 800307c: af00         	add	r7, sp, #0x0
 800307e: 60f8         	str	r0, [r7, #0xc]
 8003080: 60b9         	str	r1, [r7, #0x8]
 8003082: 607a         	str	r2, [r7, #0x4]
; 	float acc_init[3] = {0};
 8003084: f107 0344    	add.w	r3, r7, #0x44
 8003088: 2200         	movs	r2, #0x0
 800308a: 601a         	str	r2, [r3]
 800308c: 605a         	str	r2, [r3, #0x4]
 800308e: 609a         	str	r2, [r3, #0x8]
; 	float gravity_norm[3] = {0, 0, 1}; // 导航系重力加速度矢量,归一化后为(0,0,1)
 8003090: f04f 0300    	mov.w	r3, #0x0
 8003094: 63bb         	str	r3, [r7, #0x38]
 8003096: f04f 0300    	mov.w	r3, #0x0
 800309a: 63fb         	str	r3, [r7, #0x3c]
 800309c: f04f 537e    	mov.w	r3, #0x3f800000
 80030a0: 643b         	str	r3, [r7, #0x40]
; 	float axis_rot[3] = {0};           // 旋转轴
 80030a2: f107 032c    	add.w	r3, r7, #0x2c
 80030a6: 2200         	movs	r2, #0x0
 80030a8: 601a         	str	r2, [r3]
 80030aa: 605a         	str	r2, [r3, #0x4]
 80030ac: 609a         	str	r2, [r3, #0x8]
; 	for (uint8_t i = 0; i < 100; ++i) {
 80030ae: 2300         	movs	r3, #0x0
 80030b0: f887 3057    	strb.w	r3, [r7, #0x57]
 80030b4: e05f         	b	0x8003176 <InitQuaternion+0x102> @ imm = #0xbe
; 		sensor_sample_fetch(dev);
 80030b6: 68f8         	ldr	r0, [r7, #0xc]
 80030b8: f018 f893    	bl	0x801b1e2 <sensor_sample_fetch> @ imm = #0x18126
; 		sensor_channel_get(dev, SENSOR_CHAN_ACCEL_XYZ, accel_data);
 80030bc: f107 0314    	add.w	r3, r7, #0x14
 80030c0: 461a         	mov	r2, r3
 80030c2: 2103         	movs	r1, #0x3
 80030c4: 68f8         	ldr	r0, [r7, #0xc]
 80030c6: f018 f898    	bl	0x801b1fa <sensor_channel_get> @ imm = #0x18130
; 		acc_init[X] += sensor_value_to_float(&accel_data[X]);
 80030ca: 2300         	movs	r3, #0x0
 80030cc: f107 0214    	add.w	r2, r7, #0x14
 80030d0: 00db         	lsls	r3, r3, #0x3
 80030d2: 4413         	add	r3, r2
 80030d4: 4618         	mov	r0, r3
 80030d6: f7fd fdcd    	bl	0x8000c74 <sensor_value_to_float> @ imm = #-0x2466
 80030da: eeb0 7a40    	<unknown>
 80030de: 2300         	movs	r3, #0x0
 80030e0: 009b         	lsls	r3, r3, #0x2
 80030e2: 3358         	adds	r3, #0x58
 80030e4: 443b         	add	r3, r7
 80030e6: 3b14         	subs	r3, #0x14
 80030e8: edd3 7a00    	<unknown>
 80030ec: 2300         	movs	r3, #0x0
 80030ee: ee77 7a27    	<unknown>
 80030f2: 009b         	lsls	r3, r3, #0x2
 80030f4: 3358         	adds	r3, #0x58
 80030f6: 443b         	add	r3, r7
 80030f8: 3b14         	subs	r3, #0x14
 80030fa: edc3 7a00    	<unknown>
; 		acc_init[Y] += sensor_value_to_float(&accel_data[Y]);
 80030fe: 2301         	movs	r3, #0x1
 8003100: f107 0214    	add.w	r2, r7, #0x14
 8003104: 00db         	lsls	r3, r3, #0x3
 8003106: 4413         	add	r3, r2
 8003108: 4618         	mov	r0, r3
 800310a: f7fd fdb3    	bl	0x8000c74 <sensor_value_to_float> @ imm = #-0x249a
 800310e: eeb0 7a40    	<unknown>
 8003112: 2301         	movs	r3, #0x1
 8003114: 009b         	lsls	r3, r3, #0x2
 8003116: 3358         	adds	r3, #0x58
 8003118: 443b         	add	r3, r7
 800311a: 3b14         	subs	r3, #0x14
 800311c: edd3 7a00    	<unknown>
 8003120: 2301         	movs	r3, #0x1
 8003122: ee77 7a27    	<unknown>
 8003126: 009b         	lsls	r3, r3, #0x2
 8003128: 3358         	adds	r3, #0x58
 800312a: 443b         	add	r3, r7
 800312c: 3b14         	subs	r3, #0x14
 800312e: edc3 7a00    	<unknown>
; 		acc_init[Z] += sensor_value_to_float(&accel_data[Z]);
 8003132: 2302         	movs	r3, #0x2
 8003134: f107 0214    	add.w	r2, r7, #0x14
 8003138: 00db         	lsls	r3, r3, #0x3
 800313a: 4413         	add	r3, r2
 800313c: 4618         	mov	r0, r3
 800313e: f7fd fd99    	bl	0x8000c74 <sensor_value_to_float> @ imm = #-0x24ce
 8003142: eeb0 7a40    	<unknown>
 8003146: 2302         	movs	r3, #0x2
 8003148: 009b         	lsls	r3, r3, #0x2
 800314a: 3358         	adds	r3, #0x58
 800314c: 443b         	add	r3, r7
 800314e: 3b14         	subs	r3, #0x14
 8003150: edd3 7a00    	<unknown>
 8003154: 2302         	movs	r3, #0x2
 8003156: ee77 7a27    	<unknown>
 800315a: 009b         	lsls	r3, r3, #0x2
 800315c: 3358         	adds	r3, #0x58
 800315e: 443b         	add	r3, r7
 8003160: 3b14         	subs	r3, #0x14
 8003162: edc3 7a00    	<unknown>
; 		k_msleep(1);
 8003166: 2001         	movs	r0, #0x1
 8003168: f017 fef4    	bl	0x801af54 <k_msleep>    @ imm = #0x17de8
; 	for (uint8_t i = 0; i < 100; ++i) {
 800316c: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8003170: 3301         	adds	r3, #0x1
 8003172: f887 3057    	strb.w	r3, [r7, #0x57]
 8003176: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800317a: 2b63         	cmp	r3, #0x63
 800317c: d99b         	bls	0x80030b6 <InitQuaternion+0x42> @ imm = #-0xca
; 	for (uint8_t i = 0; i < 3; ++i) {
 800317e: 2300         	movs	r3, #0x0
 8003180: f887 3056    	strb.w	r3, [r7, #0x56]
 8003184: e018         	b	0x80031b8 <InitQuaternion+0x144> @ imm = #0x30
; 		acc_init[i] /= 100;
 8003186: f897 3056    	ldrb.w	r3, [r7, #0x56]
 800318a: 009b         	lsls	r3, r3, #0x2
 800318c: 3358         	adds	r3, #0x58
 800318e: 443b         	add	r3, r7
 8003190: 3b14         	subs	r3, #0x14
 8003192: ed93 7a00    	<unknown>
 8003196: f897 3056    	ldrb.w	r3, [r7, #0x56]
 800319a: eddf 6a4c    	<unknown>
 800319e: eec7 7a26    	<unknown>
 80031a2: 009b         	lsls	r3, r3, #0x2
 80031a4: 3358         	adds	r3, #0x58
 80031a6: 443b         	add	r3, r7
 80031a8: 3b14         	subs	r3, #0x14
 80031aa: edc3 7a00    	<unknown>
; 	for (uint8_t i = 0; i < 3; ++i) {
 80031ae: f897 3056    	ldrb.w	r3, [r7, #0x56]
 80031b2: 3301         	adds	r3, #0x1
 80031b4: f887 3056    	strb.w	r3, [r7, #0x56]
 80031b8: f897 3056    	ldrb.w	r3, [r7, #0x56]
 80031bc: 2b02         	cmp	r3, #0x2
 80031be: d9e2         	bls	0x8003186 <InitQuaternion+0x112> @ imm = #-0x3c
; 	accel[X] = acc_init[X];
 80031c0: 2100         	movs	r1, #0x0
 80031c2: 2300         	movs	r3, #0x0
 80031c4: 009b         	lsls	r3, r3, #0x2
 80031c6: 687a         	ldr	r2, [r7, #0x4]
 80031c8: 4413         	add	r3, r2
 80031ca: 008a         	lsls	r2, r1, #0x2
 80031cc: 3258         	adds	r2, #0x58
 80031ce: 443a         	add	r2, r7
 80031d0: 3a14         	subs	r2, #0x14
 80031d2: 6812         	ldr	r2, [r2]
 80031d4: 601a         	str	r2, [r3]
; 	accel[Y] = acc_init[Y];
 80031d6: 2101         	movs	r1, #0x1
 80031d8: 2301         	movs	r3, #0x1
 80031da: 009b         	lsls	r3, r3, #0x2
 80031dc: 687a         	ldr	r2, [r7, #0x4]
 80031de: 4413         	add	r3, r2
 80031e0: 008a         	lsls	r2, r1, #0x2
 80031e2: 3258         	adds	r2, #0x58
 80031e4: 443a         	add	r2, r7
 80031e6: 3a14         	subs	r2, #0x14
 80031e8: 6812         	ldr	r2, [r2]
 80031ea: 601a         	str	r2, [r3]
; 	accel[Z] = acc_init[Z];
 80031ec: 2102         	movs	r1, #0x2
 80031ee: 2302         	movs	r3, #0x2
 80031f0: 009b         	lsls	r3, r3, #0x2
 80031f2: 687a         	ldr	r2, [r7, #0x4]
 80031f4: 4413         	add	r3, r2
 80031f6: 008a         	lsls	r2, r1, #0x2
 80031f8: 3258         	adds	r2, #0x58
 80031fa: 443a         	add	r2, r7
 80031fc: 3a14         	subs	r2, #0x14
 80031fe: 6812         	ldr	r2, [r2]
 8003200: 601a         	str	r2, [r3]
; 	Norm3d(acc_init);
 8003202: f107 0344    	add.w	r3, r7, #0x44
 8003206: 4618         	mov	r0, r3
 8003208: f018 fa30    	bl	0x801b66c <Norm3d>      @ imm = #0x18460
; 	float angle = acosf(Dot3d(acc_init, gravity_norm));
 800320c: f107 0238    	add.w	r2, r7, #0x38
 8003210: f107 0344    	add.w	r3, r7, #0x44
 8003214: 4611         	mov	r1, r2
 8003216: 4618         	mov	r0, r3
 8003218: f018 face    	bl	0x801b7b8 <Dot3d>       @ imm = #0x1859c
 800321c: eef0 7a40    	<unknown>
 8003220: eeb0 0a67    	<unknown>
 8003224: f016 fc96    	bl	0x8019b54 <acosf>       @ imm = #0x1692c
 8003228: ed87 0a14    	<unknown>
; 	Cross3d(acc_init, gravity_norm, axis_rot);
 800322c: f107 022c    	add.w	r2, r7, #0x2c
 8003230: f107 0138    	add.w	r1, r7, #0x38
 8003234: f107 0344    	add.w	r3, r7, #0x44
 8003238: 4618         	mov	r0, r3
 800323a: f018 fa68    	bl	0x801b70e <Cross3d>     @ imm = #0x184d0
; 	Norm3d(axis_rot);
 800323e: f107 032c    	add.w	r3, r7, #0x2c
 8003242: 4618         	mov	r0, r3
 8003244: f018 fa12    	bl	0x801b66c <Norm3d>      @ imm = #0x18424
; 	init_q4[0] = cosf(angle / 2.0f);
 8003248: edd7 7a14    	<unknown>
 800324c: eef0 6a00    	<unknown>
 8003250: ee87 7aa6    	<unknown>
 8003254: eeb0 0a47    	<unknown>
 8003258: f016 ff0a    	bl	0x801a070 <cosf>        @ imm = #0x16e14
 800325c: eef0 7a40    	<unknown>
 8003260: 68bb         	ldr	r3, [r7, #0x8]
 8003262: edc3 7a00    	<unknown>
; 	for (uint8_t i = 0; i < 2; ++i) {
 8003266: 2300         	movs	r3, #0x0
 8003268: f887 3055    	strb.w	r3, [r7, #0x55]
 800326c: e022         	b	0x80032b4 <InitQuaternion+0x240> @ imm = #0x44
; 			axis_rot[i] * sinf(angle / 2.0f); // 轴角公式,第三轴为0(没有z轴分量)
 800326e: f897 3055    	ldrb.w	r3, [r7, #0x55]
 8003272: 009b         	lsls	r3, r3, #0x2
 8003274: 3358         	adds	r3, #0x58
 8003276: 443b         	add	r3, r7
 8003278: 3b2c         	subs	r3, #0x2c
 800327a: ed93 8a00    	<unknown>
 800327e: edd7 7a14    	<unknown>
 8003282: eef0 6a00    	<unknown>
 8003286: ee87 7aa6    	<unknown>
 800328a: eeb0 0a47    	<unknown>
 800328e: f017 f905    	bl	0x801a49c <sinf>        @ imm = #0x1720a
 8003292: eef0 7a40    	<unknown>
; 		init_q4[i + 1] =
 8003296: f897 3055    	ldrb.w	r3, [r7, #0x55]
 800329a: 3301         	adds	r3, #0x1
 800329c: 009b         	lsls	r3, r3, #0x2
 800329e: 68ba         	ldr	r2, [r7, #0x8]
 80032a0: 4413         	add	r3, r2
; 			axis_rot[i] * sinf(angle / 2.0f); // 轴角公式,第三轴为0(没有z轴分量)
 80032a2: ee68 7a27    	<unknown>
; 		init_q4[i + 1] =
 80032a6: edc3 7a00    	<unknown>
; 	for (uint8_t i = 0; i < 2; ++i) {
 80032aa: f897 3055    	ldrb.w	r3, [r7, #0x55]
 80032ae: 3301         	adds	r3, #0x1
 80032b0: f887 3055    	strb.w	r3, [r7, #0x55]
 80032b4: f897 3055    	ldrb.w	r3, [r7, #0x55]
 80032b8: 2b01         	cmp	r3, #0x1
 80032ba: d9d8         	bls	0x800326e <InitQuaternion+0x1fa> @ imm = #-0x50
; }
 80032bc: bf00         	nop
 80032be: bf00         	nop
 80032c0: 3758         	adds	r7, #0x58
 80032c2: 46bd         	mov	sp, r7
 80032c4: ecbd 8b02    	<unknown>
 80032c8: bd80         	pop	{r7, pc}
 80032ca: bf00         	nop

080032cc <$d>:
 80032cc: 00 00 c8 42  	.word	0x42c80000

080032d0 <IMU_Sensor_trig_handler>:
; {
 80032d0: b590         	push	{r4, r7, lr}
 80032d2: b091         	sub	sp, #0x44
 80032d4: af00         	add	r7, sp, #0x0
 80032d6: 6078         	str	r0, [r7, #0x4]
 80032d8: 6039         	str	r1, [r7]
; 	if (trigger->type != SENSOR_TRIG_DATA_READY) {
 80032da: 683b         	ldr	r3, [r7]
 80032dc: 881b         	ldrh	r3, [r3]
 80032de: 2b01         	cmp	r3, #0x1
 80032e0: f040 8090    	bne.w	0x8003404 <IMU_Sensor_trig_handler+0x134> @ imm = #0x120
; 	int current_cyc = k_cycle_get_32();
 80032e4: f017 fe62    	bl	0x801afac <k_cycle_get_32> @ imm = #0x17cc4
 80032e8: 4603         	mov	r3, r0
 80032ea: 63fb         	str	r3, [r7, #0x3c]
; 	sensor_sample_fetch(dev);
 80032ec: 6878         	ldr	r0, [r7, #0x4]
 80032ee: f017 ff78    	bl	0x801b1e2 <sensor_sample_fetch> @ imm = #0x17ef0
; 	if (trigger->chan == SENSOR_CHAN_ACCEL_XYZ) {
 80032f2: 683b         	ldr	r3, [r7]
 80032f4: 885b         	ldrh	r3, [r3, #0x2]
 80032f6: 2b03         	cmp	r3, #0x3
 80032f8: d149         	bne	0x800338e <IMU_Sensor_trig_handler+0xbe> @ imm = #0x92
; 		sensor_channel_get(dev, SENSOR_CHAN_ACCEL_XYZ, accel_data);
 80032fa: f107 0324    	add.w	r3, r7, #0x24
 80032fe: 461a         	mov	r2, r3
 8003300: 2103         	movs	r1, #0x3
 8003302: 6878         	ldr	r0, [r7, #0x4]
 8003304: f017 ff79    	bl	0x801b1fa <sensor_channel_get> @ imm = #0x17ef2
; 		INS.flag |= 1;
 8003308: 4b40         	ldr	r3, [pc, #0x100]        @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 800330a: f893 3024    	ldrb.w	r3, [r3, #0x24]
 800330e: f043 0301    	orr	r3, r3, #0x1
 8003312: b2da         	uxtb	r2, r3
 8003314: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 8003316: f883 2024    	strb.w	r2, [r3, #0x24]
; 		INS.accel_curr_cyc = current_cyc;
 800331a: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 800331c: 6bfb         	ldr	r3, [r7, #0x3c]
 800331e: 6393         	str	r3, [r2, #0x38]
; 		INS.Accel[X] = sensor_value_to_float(&accel_data[X]);
 8003320: 2300         	movs	r3, #0x0
 8003322: f107 0224    	add.w	r2, r7, #0x24
 8003326: 00db         	lsls	r3, r3, #0x3
 8003328: 4413         	add	r3, r2
 800332a: 2400         	movs	r4, #0x0
 800332c: 4618         	mov	r0, r3
 800332e: f7fd fca1    	bl	0x8000c74 <sensor_value_to_float> @ imm = #-0x26be
 8003332: eef0 7a40    	<unknown>
 8003336: 4a35         	ldr	r2, [pc, #0xd4]         @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 8003338: 1ca3         	adds	r3, r4, #0x2
 800333a: 009b         	lsls	r3, r3, #0x2
 800333c: 4413         	add	r3, r2
 800333e: 3304         	adds	r3, #0x4
 8003340: edc3 7a00    	<unknown>
; 		INS.Accel[Y] = sensor_value_to_float(&accel_data[Y]);
 8003344: 2301         	movs	r3, #0x1
 8003346: f107 0224    	add.w	r2, r7, #0x24
 800334a: 00db         	lsls	r3, r3, #0x3
 800334c: 4413         	add	r3, r2
 800334e: 2401         	movs	r4, #0x1
 8003350: 4618         	mov	r0, r3
 8003352: f7fd fc8f    	bl	0x8000c74 <sensor_value_to_float> @ imm = #-0x26e2
 8003356: eef0 7a40    	<unknown>
 800335a: 4a2c         	ldr	r2, [pc, #0xb0]         @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 800335c: 1ca3         	adds	r3, r4, #0x2
 800335e: 009b         	lsls	r3, r3, #0x2
 8003360: 4413         	add	r3, r2
 8003362: 3304         	adds	r3, #0x4
 8003364: edc3 7a00    	<unknown>
; 		INS.Accel[Z] = sensor_value_to_float(&accel_data[Z]);
 8003368: 2302         	movs	r3, #0x2
 800336a: f107 0224    	add.w	r2, r7, #0x24
 800336e: 00db         	lsls	r3, r3, #0x3
 8003370: 4413         	add	r3, r2
 8003372: 2402         	movs	r4, #0x2
 8003374: 4618         	mov	r0, r3
 8003376: f7fd fc7d    	bl	0x8000c74 <sensor_value_to_float> @ imm = #-0x2706
 800337a: eef0 7a40    	<unknown>
 800337e: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 8003380: 1ca3         	adds	r3, r4, #0x2
 8003382: 009b         	lsls	r3, r3, #0x2
 8003384: 4413         	add	r3, r2
 8003386: 3304         	adds	r3, #0x4
 8003388: edc3 7a00    	<unknown>
 800338c: e036         	b	0x80033fc <IMU_Sensor_trig_handler+0x12c> @ imm = #0x6c
; 	} else if (trigger->chan == SENSOR_CHAN_GYRO_XYZ) {
 800338e: 683b         	ldr	r3, [r7]
 8003390: 885b         	ldrh	r3, [r3, #0x2]
 8003392: 2b07         	cmp	r3, #0x7
 8003394: d132         	bne	0x80033fc <IMU_Sensor_trig_handler+0x12c> @ imm = #0x64
; 		sensor_channel_get(dev, SENSOR_CHAN_GYRO_XYZ, gyro_data);
 8003396: f107 030c    	add.w	r3, r7, #0xc
 800339a: 461a         	mov	r2, r3
 800339c: 2107         	movs	r1, #0x7
 800339e: 6878         	ldr	r0, [r7, #0x4]
 80033a0: f017 ff2b    	bl	0x801b1fa <sensor_channel_get> @ imm = #0x17e56
; 		INS.flag |= 2;
 80033a4: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 80033a6: f893 3024    	ldrb.w	r3, [r3, #0x24]
 80033aa: f043 0302    	orr	r3, r3, #0x2
 80033ae: b2da         	uxtb	r2, r3
 80033b0: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 80033b2: f883 2024    	strb.w	r2, [r3, #0x24]
; 		INS.gyro_curr_cyc = current_cyc;
 80033b6: 4a15         	ldr	r2, [pc, #0x54]         @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 80033b8: 6bfb         	ldr	r3, [r7, #0x3c]
 80033ba: 6353         	str	r3, [r2, #0x34]
; 		INS.Gyro[0] = sensor_value_to_float(&gyro_data[0]);
 80033bc: f107 030c    	add.w	r3, r7, #0xc
 80033c0: 4618         	mov	r0, r3
 80033c2: f7fd fc57    	bl	0x8000c74 <sensor_value_to_float> @ imm = #-0x2752
 80033c6: eef0 7a40    	<unknown>
 80033ca: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 80033cc: edc3 7a00    	<unknown>
; 		INS.Gyro[1] = sensor_value_to_float(&gyro_data[1]);
 80033d0: f107 030c    	add.w	r3, r7, #0xc
 80033d4: 3308         	adds	r3, #0x8
 80033d6: 4618         	mov	r0, r3
 80033d8: f7fd fc4c    	bl	0x8000c74 <sensor_value_to_float> @ imm = #-0x2768
 80033dc: eef0 7a40    	<unknown>
 80033e0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 80033e2: edc3 7a01    	<unknown>
; 		INS.Gyro[2] = sensor_value_to_float(&gyro_data[2]);
 80033e6: f107 030c    	add.w	r3, r7, #0xc
 80033ea: 3310         	adds	r3, #0x10
 80033ec: 4618         	mov	r0, r3
 80033ee: f7fd fc41    	bl	0x8000c74 <sensor_value_to_float> @ imm = #-0x277e
 80033f2: eef0 7a40    	<unknown>
 80033f6: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 80033f8: edc3 7a02    	<unknown>
; 	IMU_Sensor_handle_update(&INS);
 80033fc: 4803         	ldr	r0, [pc, #0xc]          @ 0x800340c <IMU_Sensor_trig_handler+0x13c>
 80033fe: f7ff fd45    	bl	0x8002e8c <IMU_Sensor_handle_update> @ imm = #-0x576
 8003402: e000         	b	0x8003406 <IMU_Sensor_trig_handler+0x136> @ imm = #0x0
; 		return;
 8003404: bf00         	nop
; }
 8003406: 3744         	adds	r7, #0x44
 8003408: 46bd         	mov	sp, r7
 800340a: bd90         	pop	{r4, r7, pc}

0800340c <$d>:
 800340c: 90 26 00 24  	.word	0x24002690

08003410 <IMU_Sensor_trig_init>:
; {
 8003410: b580         	push	{r7, lr}
 8003412: b088         	sub	sp, #0x20
 8003414: af00         	add	r7, sp, #0x0
 8003416: 6078         	str	r0, [r7, #0x4]
 8003418: 6039         	str	r1, [r7]
; 	IMU_Param.scale[X] = 1;
 800341a: 2300         	movs	r3, #0x0
 800341c: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x80034dc <IMU_Sensor_trig_init+0xcc>
 800341e: 009b         	lsls	r3, r3, #0x2
 8003420: 4413         	add	r3, r2
 8003422: 3304         	adds	r3, #0x4
 8003424: f04f 527e    	mov.w	r2, #0x3f800000
 8003428: 601a         	str	r2, [r3]
; 	IMU_Param.scale[Y] = 1;
 800342a: 2301         	movs	r3, #0x1
 800342c: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x80034dc <IMU_Sensor_trig_init+0xcc>
 800342e: 009b         	lsls	r3, r3, #0x2
 8003430: 4413         	add	r3, r2
 8003432: 3304         	adds	r3, #0x4
 8003434: f04f 527e    	mov.w	r2, #0x3f800000
 8003438: 601a         	str	r2, [r3]
; 	IMU_Param.scale[Z] = 1;
 800343a: 2302         	movs	r3, #0x2
 800343c: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x80034dc <IMU_Sensor_trig_init+0xcc>
 800343e: 009b         	lsls	r3, r3, #0x2
 8003440: 4413         	add	r3, r2
 8003442: 3304         	adds	r3, #0x4
 8003444: f04f 527e    	mov.w	r2, #0x3f800000
 8003448: 601a         	str	r2, [r3]
; 	IMU_Param.Yaw = 0;
 800344a: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80034dc <IMU_Sensor_trig_init+0xcc>
 800344c: f04f 0200    	mov.w	r2, #0x0
 8003450: 611a         	str	r2, [r3, #0x10]
; 	IMU_Param.Pitch = 0;
 8003452: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80034dc <IMU_Sensor_trig_init+0xcc>
 8003454: f04f 0200    	mov.w	r2, #0x0
 8003458: 615a         	str	r2, [r3, #0x14]
; 	IMU_Param.Roll = 0;
 800345a: 4b20         	ldr	r3, [pc, #0x80]         @ 0x80034dc <IMU_Sensor_trig_init+0xcc>
 800345c: f04f 0200    	mov.w	r2, #0x0
 8003460: 619a         	str	r2, [r3, #0x18]
; 	IMU_Param.flag = 1;
 8003462: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80034dc <IMU_Sensor_trig_init+0xcc>
 8003464: 2201         	movs	r2, #0x1
 8003466: 701a         	strb	r2, [r3]
; 	float init_quaternion[4] = {0};
 8003468: f107 030c    	add.w	r3, r7, #0xc
 800346c: 2200         	movs	r2, #0x0
 800346e: 601a         	str	r2, [r3]
 8003470: 605a         	str	r2, [r3, #0x4]
 8003472: 609a         	str	r2, [r3, #0x8]
 8003474: 60da         	str	r2, [r3, #0xc]
; 	InitQuaternion(accel_dev, init_quaternion, INS.lpf_Accel);
 8003476: f107 030c    	add.w	r3, r7, #0xc
 800347a: 4a19         	ldr	r2, [pc, #0x64]         @ 0x80034e0 <IMU_Sensor_trig_init+0xd0>
 800347c: 4619         	mov	r1, r3
 800347e: 6878         	ldr	r0, [r7, #0x4]
 8003480: f7ff fdf8    	bl	0x8003074 <InitQuaternion> @ imm = #-0x410
; 	IMU_QuaternionEKF_Init(init_quaternion, 10, 0.001, 100000, 1, 0.95);
 8003484: f107 030c    	add.w	r3, r7, #0xc
 8003488: ed9f 2a16    	<unknown>
 800348c: eef7 1a00    	<unknown>
 8003490: ed9f 1a15    	<unknown>
 8003494: eddf 0a15    	<unknown>
 8003498: eeb2 0a04    	<unknown>
 800349c: 4618         	mov	r0, r3
 800349e: f7fe fa8d    	bl	0x80019bc <IMU_QuaternionEKF_Init> @ imm = #-0x1ae6
; 	int current_cyc = k_cycle_get_32();
 80034a2: f017 fd83    	bl	0x801afac <k_cycle_get_32> @ imm = #0x17b06
 80034a6: 4603         	mov	r3, r0
 80034a8: 61fb         	str	r3, [r7, #0x1c]
; 	INS.gyro_prev_cyc = current_cyc;
 80034aa: 4a11         	ldr	r2, [pc, #0x44]         @ 0x80034f0 <IMU_Sensor_trig_init+0xe0>
 80034ac: 69fb         	ldr	r3, [r7, #0x1c]
 80034ae: 6293         	str	r3, [r2, #0x28]
; 	INS.accel_prev_cyc = current_cyc;
 80034b0: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x80034f0 <IMU_Sensor_trig_init+0xe0>
 80034b2: 69fb         	ldr	r3, [r7, #0x1c]
 80034b4: 62d3         	str	r3, [r2, #0x2c]
; 	INS.flag = 0;
 80034b6: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80034f0 <IMU_Sensor_trig_init+0xe0>
 80034b8: 2200         	movs	r2, #0x0
 80034ba: f883 2024    	strb.w	r2, [r3, #0x24]
; 	sensor_trigger_set(accel_dev, &accel_trig, IMU_Sensor_trig_handler);
 80034be: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x80034f4 <IMU_Sensor_trig_init+0xe4>
 80034c0: 490d         	ldr	r1, [pc, #0x34]         @ 0x80034f8 <IMU_Sensor_trig_init+0xe8>
 80034c2: 6878         	ldr	r0, [r7, #0x4]
 80034c4: f017 fe4c    	bl	0x801b160 <sensor_trigger_set> @ imm = #0x17c98
; 	sensor_trigger_set(gyro_dev, &gyro_trig, IMU_Sensor_trig_handler);
 80034c8: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80034f4 <IMU_Sensor_trig_init+0xe4>
 80034ca: 490c         	ldr	r1, [pc, #0x30]         @ 0x80034fc <IMU_Sensor_trig_init+0xec>
 80034cc: 6838         	ldr	r0, [r7]
 80034ce: f017 fe47    	bl	0x801b160 <sensor_trigger_set> @ imm = #0x17c8e
; }
 80034d2: bf00         	nop
 80034d4: 3720         	adds	r7, #0x20
 80034d6: 46bd         	mov	sp, r7
 80034d8: bd80         	pop	{r7, pc}
 80034da: bf00         	nop

080034dc <$d>:
 80034dc: 74 26 00 24  	.word	0x24002674
 80034e0: a8 26 00 24  	.word	0x240026a8
 80034e4: 33 33 73 3f  	.word	0x3f733333
 80034e8: 00 50 c3 47  	.word	0x47c35000
 80034ec: 6f 12 83 3a  	.word	0x3a83126f
 80034f0: 90 26 00 24  	.word	0x24002690
 80034f4: d1 32 00 08  	.word	0x080032d1
 80034f8: 1c 06 00 24  	.word	0x2400061c
 80034fc: 20 06 00 24  	.word	0x24000620

08003500 <jf_send_float>:
; {
 8003500: b580         	push	{r7, lr}
 8003502: b084         	sub	sp, #0x10
 8003504: af00         	add	r7, sp, #0x0
 8003506: 6078         	str	r0, [r7, #0x4]
; 	const struct device *uart_dev = data->uart_dev;
 8003508: 687b         	ldr	r3, [r7, #0x4]
 800350a: 681b         	ldr	r3, [r3]
 800350c: 60bb         	str	r3, [r7, #0x8]
; 	for (int i = 0; i < data->channel; i++) {
 800350e: 2300         	movs	r3, #0x0
 8003510: 60fb         	str	r3, [r7, #0xc]
 8003512: e01a         	b	0x800354a <jf_send_float+0x4a> @ imm = #0x34
; 		if (data->fdata[i] == *(float *)tail) {
 8003514: 687a         	ldr	r2, [r7, #0x4]
 8003516: 68fb         	ldr	r3, [r7, #0xc]
 8003518: 3318         	adds	r3, #0x18
 800351a: 009b         	lsls	r3, r3, #0x2
 800351c: 4413         	add	r3, r2
 800351e: 3304         	adds	r3, #0x4
 8003520: ed93 7a00    	<unknown>
 8003524: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80035b4 <jf_send_float+0xb4>
 8003526: edd3 7a00    	<unknown>
 800352a: eeb4 7a67    	<unknown>
 800352e: eef1 fa10    	<unknown>
 8003532: d107         	bne	0x8003544 <jf_send_float+0x44> @ imm = #0xe
; 			data->fdata[i] = 1e+6;
 8003534: 687a         	ldr	r2, [r7, #0x4]
 8003536: 68fb         	ldr	r3, [r7, #0xc]
 8003538: 3318         	adds	r3, #0x18
 800353a: 009b         	lsls	r3, r3, #0x2
 800353c: 4413         	add	r3, r2
 800353e: 3304         	adds	r3, #0x4
 8003540: 4a1d         	ldr	r2, [pc, #0x74]         @ 0x80035b8 <jf_send_float+0xb8>
 8003542: 601a         	str	r2, [r3]
; 	for (int i = 0; i < data->channel; i++) {
 8003544: 68fb         	ldr	r3, [r7, #0xc]
 8003546: 3301         	adds	r3, #0x1
 8003548: 60fb         	str	r3, [r7, #0xc]
 800354a: 687b         	ldr	r3, [r7, #0x4]
 800354c: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003550: 68fa         	ldr	r2, [r7, #0xc]
 8003552: 429a         	cmp	r2, r3
 8003554: dbde         	blt	0x8003514 <jf_send_float+0x14> @ imm = #-0x44
; 	if (data->fdata[data->channel] != *(float *)tail) {
 8003556: 687b         	ldr	r3, [r7, #0x4]
 8003558: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 800355c: 687a         	ldr	r2, [r7, #0x4]
 800355e: 3318         	adds	r3, #0x18
 8003560: 009b         	lsls	r3, r3, #0x2
 8003562: 4413         	add	r3, r2
 8003564: 3304         	adds	r3, #0x4
 8003566: ed93 7a00    	<unknown>
 800356a: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80035b4 <jf_send_float+0xb4>
 800356c: edd3 7a00    	<unknown>
 8003570: eeb4 7a67    	<unknown>
 8003574: eef1 fa10    	<unknown>
 8003578: d00a         	beq	0x8003590 <jf_send_float+0x90> @ imm = #0x14
; 		memcpy(&(data->fdata[data->channel]), tail, 4 * sizeof(uint8_t));
 800357a: 687b         	ldr	r3, [r7, #0x4]
 800357c: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003580: 3318         	adds	r3, #0x18
 8003582: 009b         	lsls	r3, r3, #0x2
 8003584: 687a         	ldr	r2, [r7, #0x4]
 8003586: 4413         	add	r3, r2
 8003588: 3304         	adds	r3, #0x4
 800358a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80035b4 <jf_send_float+0xb4>
 800358c: 6810         	ldr	r0, [r2]
 800358e: 6018         	str	r0, [r3]
; 	uart_tx(uart_dev, (const uint8_t *)data->fdata, data->channel * 4 + 4, SYS_FOREVER_US);
 8003590: 687b         	ldr	r3, [r7, #0x4]
 8003592: f103 0164    	add.w	r1, r3, #0x64
 8003596: 687b         	ldr	r3, [r7, #0x4]
 8003598: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 800359c: 3301         	adds	r3, #0x1
 800359e: 009b         	lsls	r3, r3, #0x2
 80035a0: 461a         	mov	r2, r3
 80035a2: f04f 33ff    	mov.w	r3, #0xffffffff
 80035a6: 68b8         	ldr	r0, [r7, #0x8]
 80035a8: f018 f948    	bl	0x801b83c <uart_tx>     @ imm = #0x18290
; }
 80035ac: bf00         	nop
 80035ae: 3710         	adds	r7, #0x10
 80035b0: 46bd         	mov	sp, r7
 80035b2: bd80         	pop	{r7, pc}

080035b4 <$d>:
 80035b4: a8 cd 02 08  	.word	0x0802cda8
 80035b8: 00 24 74 49  	.word	0x49742400

080035bc <jf_feedback>:
; {
 80035bc: b580         	push	{r7, lr}
 80035be: b088         	sub	sp, #0x20
 80035c0: af00         	add	r7, sp, #0x0
 80035c2: 60f8         	str	r0, [r7, #0xc]
 80035c4: 60b9         	str	r1, [r7, #0x8]
 80035c6: 607a         	str	r2, [r7, #0x4]
; 	int delay = (int)arg1;
 80035c8: 68fb         	ldr	r3, [r7, #0xc]
 80035ca: 61bb         	str	r3, [r7, #0x18]
; 	struct JFData *data = (struct JFData *)arg2;
 80035cc: 68bb         	ldr	r3, [r7, #0x8]
 80035ce: 617b         	str	r3, [r7, #0x14]
; 		k_msleep(delay);
 80035d0: 69b8         	ldr	r0, [r7, #0x18]
 80035d2: f017 fcbf    	bl	0x801af54 <k_msleep>    @ imm = #0x1797e
; 		if (data->channel == 0) {
 80035d6: 697b         	ldr	r3, [r7, #0x14]
 80035d8: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80035dc: 2b00         	cmp	r3, #0x0
 80035de: f000 8080    	beq.w	0x80036e2 <jf_feedback+0x126> @ imm = #0x100
; 		for (int i = 0; i < data->channel; i++) {
 80035e2: 2300         	movs	r3, #0x0
 80035e4: 61fb         	str	r3, [r7, #0x1c]
 80035e6: e072         	b	0x80036ce <jf_feedback+0x112> @ imm = #0xe4
; 			switch (data->types[i]) {
 80035e8: 697a         	ldr	r2, [r7, #0x14]
 80035ea: 69fb         	ldr	r3, [r7, #0x1c]
 80035ec: 4413         	add	r3, r2
 80035ee: 33c4         	adds	r3, #0xc4
 80035f0: 781b         	ldrb	r3, [r3]
 80035f2: 2b04         	cmp	r3, #0x4
 80035f4: d867         	bhi	0x80036c6 <jf_feedback+0x10a> @ imm = #0xce
 80035f6: a201         	adr	r2, #4 <jf_feedback+0x3f>
 80035f8: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

080035fc <$d>:
 80035fc: 11 36 00 08  	.word	0x08003611
 8003600: 37 36 00 08  	.word	0x08003637
 8003604: 53 36 00 08  	.word	0x08003653
 8003608: 77 36 00 08  	.word	0x08003677
 800360c: 9f 36 00 08  	.word	0x0800369f

08003610 <$t>:
; 				data->fdata[i] = *(int *)data->data_ptr[i];
 8003610: 697a         	ldr	r2, [r7, #0x14]
 8003612: 69fb         	ldr	r3, [r7, #0x1c]
 8003614: 009b         	lsls	r3, r3, #0x2
 8003616: 4413         	add	r3, r2
 8003618: 685b         	ldr	r3, [r3, #0x4]
 800361a: 681b         	ldr	r3, [r3]
 800361c: ee07 3a90    	<unknown>
 8003620: eef8 7ae7    	<unknown>
 8003624: 697a         	ldr	r2, [r7, #0x14]
 8003626: 69fb         	ldr	r3, [r7, #0x1c]
 8003628: 3318         	adds	r3, #0x18
 800362a: 009b         	lsls	r3, r3, #0x2
 800362c: 4413         	add	r3, r2
 800362e: 3304         	adds	r3, #0x4
 8003630: edc3 7a00    	<unknown>
; 				break;
 8003634: e048         	b	0x80036c8 <jf_feedback+0x10c> @ imm = #0x90
; 				data->fdata[i] = *(float *)data->data_ptr[i];
 8003636: 697a         	ldr	r2, [r7, #0x14]
 8003638: 69fb         	ldr	r3, [r7, #0x1c]
 800363a: 009b         	lsls	r3, r3, #0x2
 800363c: 4413         	add	r3, r2
 800363e: 685b         	ldr	r3, [r3, #0x4]
 8003640: 681a         	ldr	r2, [r3]
 8003642: 6979         	ldr	r1, [r7, #0x14]
 8003644: 69fb         	ldr	r3, [r7, #0x1c]
 8003646: 3318         	adds	r3, #0x18
 8003648: 009b         	lsls	r3, r3, #0x2
 800364a: 440b         	add	r3, r1
 800364c: 3304         	adds	r3, #0x4
 800364e: 601a         	str	r2, [r3]
; 				break;
 8003650: e03a         	b	0x80036c8 <jf_feedback+0x10c> @ imm = #0x74
; 				data->fdata[i] = *(double *)data->data_ptr[i];
 8003652: 697a         	ldr	r2, [r7, #0x14]
 8003654: 69fb         	ldr	r3, [r7, #0x1c]
 8003656: 009b         	lsls	r3, r3, #0x2
 8003658: 4413         	add	r3, r2
 800365a: 685b         	ldr	r3, [r3, #0x4]
 800365c: ed93 7b00    	<unknown>
 8003660: eef7 7bc7    	<unknown>
 8003664: 697a         	ldr	r2, [r7, #0x14]
 8003666: 69fb         	ldr	r3, [r7, #0x1c]
 8003668: 3318         	adds	r3, #0x18
 800366a: 009b         	lsls	r3, r3, #0x2
 800366c: 4413         	add	r3, r2
 800366e: 3304         	adds	r3, #0x4
 8003670: edc3 7a00    	<unknown>
; 				break;
 8003674: e028         	b	0x80036c8 <jf_feedback+0x10c> @ imm = #0x50
; 				data->fdata[i] = *(int8_t *)data->data_ptr[i];
 8003676: 697a         	ldr	r2, [r7, #0x14]
 8003678: 69fb         	ldr	r3, [r7, #0x1c]
 800367a: 009b         	lsls	r3, r3, #0x2
 800367c: 4413         	add	r3, r2
 800367e: 685b         	ldr	r3, [r3, #0x4]
 8003680: f993 3000    	ldrsb.w	r3, [r3]
 8003684: ee07 3a90    	<unknown>
 8003688: eef8 7ae7    	<unknown>
 800368c: 697a         	ldr	r2, [r7, #0x14]
 800368e: 69fb         	ldr	r3, [r7, #0x1c]
 8003690: 3318         	adds	r3, #0x18
 8003692: 009b         	lsls	r3, r3, #0x2
 8003694: 4413         	add	r3, r2
 8003696: 3304         	adds	r3, #0x4
 8003698: edc3 7a00    	<unknown>
; 				break;
 800369c: e014         	b	0x80036c8 <jf_feedback+0x10c> @ imm = #0x28
; 				data->fdata[i] = *(int16_t *)data->data_ptr[i];
 800369e: 697a         	ldr	r2, [r7, #0x14]
 80036a0: 69fb         	ldr	r3, [r7, #0x1c]
 80036a2: 009b         	lsls	r3, r3, #0x2
 80036a4: 4413         	add	r3, r2
 80036a6: 685b         	ldr	r3, [r3, #0x4]
 80036a8: f9b3 3000    	ldrsh.w	r3, [r3]
 80036ac: ee07 3a90    	<unknown>
 80036b0: eef8 7ae7    	<unknown>
 80036b4: 697a         	ldr	r2, [r7, #0x14]
 80036b6: 69fb         	ldr	r3, [r7, #0x1c]
 80036b8: 3318         	adds	r3, #0x18
 80036ba: 009b         	lsls	r3, r3, #0x2
 80036bc: 4413         	add	r3, r2
 80036be: 3304         	adds	r3, #0x4
 80036c0: edc3 7a00    	<unknown>
; 				break;
 80036c4: e000         	b	0x80036c8 <jf_feedback+0x10c> @ imm = #0x0
; 				break;
 80036c6: bf00         	nop
; 		for (int i = 0; i < data->channel; i++) {
 80036c8: 69fb         	ldr	r3, [r7, #0x1c]
 80036ca: 3301         	adds	r3, #0x1
 80036cc: 61fb         	str	r3, [r7, #0x1c]
 80036ce: 697b         	ldr	r3, [r7, #0x14]
 80036d0: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80036d4: 69fa         	ldr	r2, [r7, #0x1c]
 80036d6: 429a         	cmp	r2, r3
 80036d8: db86         	blt	0x80035e8 <jf_feedback+0x2c> @ imm = #-0xf4
; 		jf_send_float(data);
 80036da: 6978         	ldr	r0, [r7, #0x14]
 80036dc: f7ff ff10    	bl	0x8003500 <jf_send_float> @ imm = #-0x1e0
 80036e0: e776         	b	0x80035d0 <jf_feedback+0x14> @ imm = #-0x114
; 			continue;
 80036e2: bf00         	nop
; 		k_msleep(delay);
 80036e4: e774         	b	0x80035d0 <jf_feedback+0x14> @ imm = #-0x118
 80036e6: bf00         	nop

080036e8 <jf_send_init>:
; {
 80036e8: b580         	push	{r7, lr}
 80036ea: b08c         	sub	sp, #0x30
 80036ec: af08         	add	r7, sp, #0x20
 80036ee: 6078         	str	r0, [r7, #0x4]
 80036f0: 6039         	str	r1, [r7]
; 	int channel = 24;
 80036f2: 2318         	movs	r3, #0x18
 80036f4: 60fb         	str	r3, [r7, #0xc]
; 	aresPlotData.channel = 0;
 80036f6: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800377c <jf_send_init+0x94>
 80036f8: 2200         	movs	r2, #0x0
 80036fa: f8c3 20dc    	str.w	r2, [r3, #0xdc]
; 	if (!device_is_ready(uart_dev)) {
 80036fe: 6878         	ldr	r0, [r7, #0x4]
 8003700: f017 fc15    	bl	0x801af2e <device_is_ready> @ imm = #0x1782a
 8003704: 4603         	mov	r3, r0
 8003706: f083 0301    	eor	r3, r3, #0x1
 800370a: b2db         	uxtb	r3, r3
 800370c: 2b00         	cmp	r3, #0x0
 800370e: d001         	beq	0x8003714 <jf_send_init+0x2c> @ imm = #0x2
; 		return NULL;
 8003710: 2100         	movs	r1, #0x0
 8003712: e02e         	b	0x8003772 <jf_send_init+0x8a> @ imm = #0x5c
; 	aresPlotData.uart_dev = (struct device *)uart_dev;
 8003714: 4a19         	ldr	r2, [pc, #0x64]         @ 0x800377c <jf_send_init+0x94>
 8003716: 687b         	ldr	r3, [r7, #0x4]
 8003718: 6013         	str	r3, [r2]
; 	memcpy(&(aresPlotData.fdata[aresPlotData.channel]), tail, 4 * sizeof(uint8_t));
 800371a: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800377c <jf_send_init+0x94>
 800371c: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003720: 3318         	adds	r3, #0x18
 8003722: 009b         	lsls	r3, r3, #0x2
 8003724: 4a15         	ldr	r2, [pc, #0x54]         @ 0x800377c <jf_send_init+0x94>
 8003726: 4413         	add	r3, r2
 8003728: 3304         	adds	r3, #0x4
 800372a: 4a15         	ldr	r2, [pc, #0x54]         @ 0x8003780 <jf_send_init+0x98>
 800372c: 6810         	ldr	r0, [r2]
 800372e: 6018         	str	r0, [r3]
; 	aresPlotData.types[aresPlotData.channel] = RAW;
 8003730: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800377c <jf_send_init+0x94>
 8003732: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003736: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800377c <jf_send_init+0x94>
 8003738: 4413         	add	r3, r2
 800373a: 2208         	movs	r2, #0x8
 800373c: f883 20c4    	strb.w	r2, [r3, #0xc4]
; 	k_thread_create(&jf_thread_data, jf_stack_area, K_THREAD_STACK_SIZEOF(jf_stack_area),
 8003740: 6839         	ldr	r1, [r7]
; 			jf_feedback, (void *)delay, &aresPlotData, NULL, -1, 0, K_NO_WAIT);
 8003742: f04f 0200    	mov.w	r2, #0x0
 8003746: f04f 0300    	mov.w	r3, #0x0
; 	k_thread_create(&jf_thread_data, jf_stack_area, K_THREAD_STACK_SIZEOF(jf_stack_area),
 800374a: e9cd 2306    	strd	r2, r3, [sp, #24]
 800374e: 2300         	movs	r3, #0x0
 8003750: 9304         	str	r3, [sp, #0x10]
 8003752: f04f 33ff    	mov.w	r3, #0xffffffff
 8003756: 9303         	str	r3, [sp, #0xc]
 8003758: 2300         	movs	r3, #0x0
 800375a: 9302         	str	r3, [sp, #0x8]
 800375c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800377c <jf_send_init+0x94>
 800375e: 9301         	str	r3, [sp, #0x4]
 8003760: 9100         	str	r1, [sp]
 8003762: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8003784 <jf_send_init+0x9c>
 8003764: f44f 7240    	mov.w	r2, #0x300
 8003768: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8003788 <jf_send_init+0xa0>
 800376a: 4808         	ldr	r0, [pc, #0x20]         @ 0x800378c <jf_send_init+0xa4>
 800376c: f017 fc25    	bl	0x801afba <k_thread_create> @ imm = #0x1784a
; 	return &aresPlotData;
 8003770: 4902         	ldr	r1, [pc, #0x8]          @ 0x800377c <jf_send_init+0x94>
; }
 8003772: 460b         	mov	r3, r1
 8003774: 4618         	mov	r0, r3
 8003776: 3710         	adds	r7, #0x10
 8003778: 46bd         	mov	sp, r7
 800377a: bd80         	pop	{r7, pc}

0800377c <$d>:
 800377c: d4 26 00 24  	.word	0x240026d4
 8003780: a8 cd 02 08  	.word	0x0802cda8
 8003784: bd 35 00 08  	.word	0x080035bd
 8003788: f8 36 00 24  	.word	0x240036f8
 800378c: 88 0f 00 24  	.word	0x24000f88

08003790 <Sensor_update_cb>:
; {
 8003790: b580         	push	{r7, lr}
 8003792: b086         	sub	sp, #0x18
 8003794: af00         	add	r7, sp, #0x0
 8003796: 6078         	str	r0, [r7, #0x4]
; 	struct pos_data pos = {0};
 8003798: f107 030c    	add.w	r3, r7, #0xc
 800379c: 2200         	movs	r2, #0x0
 800379e: 601a         	str	r2, [r3]
 80037a0: 605a         	str	r2, [r3, #0x4]
 80037a2: 609a         	str	r2, [r3, #0x8]
; 	pos.Yaw = QEKF->Yaw;
 80037a4: 687b         	ldr	r3, [r7, #0x4]
 80037a6: f8d3 31a8    	ldr.w	r3, [r3, #0x1a8]
 80037aa: 60fb         	str	r3, [r7, #0xc]
; 	zbus_chan_pub(&pos_chan, &pos, K_USEC(60));
 80037ac: f04f 0201    	mov.w	r2, #0x1
 80037b0: f04f 0300    	mov.w	r3, #0x0
 80037b4: f107 010c    	add.w	r1, r7, #0xc
 80037b8: 4803         	ldr	r0, [pc, #0xc]          @ 0x80037c8 <Sensor_update_cb+0x38>
 80037ba: f01a fbe3    	bl	0x801df84 <zbus_chan_pub> @ imm = #0x1a7c6
; }
 80037be: bf00         	nop
 80037c0: 3718         	adds	r7, #0x18
 80037c2: 46bd         	mov	sp, r7
 80037c4: bd80         	pop	{r7, pc}
 80037c6: bf00         	nop

080037c8 <$d>:
 80037c8: 60 a2 02 08  	.word	0x0802a260

080037cc <steerwheel_init>:
; {
 80037cc: b480         	push	{r7}
 80037ce: af00         	add	r7, sp, #0x0
; 	chassis_data.steerwheel[0].angle_offset = 0;
 80037d0: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8003820 <steerwheel_init+0x54>
 80037d2: f04f 0200    	mov.w	r2, #0x0
 80037d6: 60da         	str	r2, [r3, #0xc]
; 	chassis_data.steerwheel[1].angle_offset = 120;
 80037d8: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8003820 <steerwheel_init+0x54>
 80037da: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8003824 <steerwheel_init+0x58>
 80037dc: 635a         	str	r2, [r3, #0x34]
; 	chassis_data.steerwheel[2].angle_offset = 240;
 80037de: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8003820 <steerwheel_init+0x54>
 80037e0: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8003828 <steerwheel_init+0x5c>
 80037e2: 65da         	str	r2, [r3, #0x5c]
; 	chassis_data.steerwheel[0].steer_motor = steer_motor1;
 80037e4: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800382c <steerwheel_init+0x60>
 80037e6: 681b         	ldr	r3, [r3]
 80037e8: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8003820 <steerwheel_init+0x54>
 80037ea: 6293         	str	r3, [r2, #0x28]
; 	chassis_data.steerwheel[1].steer_motor = steer_motor2;
 80037ec: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8003830 <steerwheel_init+0x64>
 80037ee: 681b         	ldr	r3, [r3]
 80037f0: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8003820 <steerwheel_init+0x54>
 80037f2: 6513         	str	r3, [r2, #0x50]
; 	chassis_data.steerwheel[2].steer_motor = steer_motor3;
 80037f4: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8003834 <steerwheel_init+0x68>
 80037f6: 681b         	ldr	r3, [r3]
 80037f8: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8003820 <steerwheel_init+0x54>
 80037fa: 6793         	str	r3, [r2, #0x78]
; 	chassis_data.steerwheel[0].wheel_motor = wheel_motor1;
 80037fc: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8003838 <steerwheel_init+0x6c>
 80037fe: 681b         	ldr	r3, [r3]
 8003800: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8003820 <steerwheel_init+0x54>
 8003802: 62d3         	str	r3, [r2, #0x2c]
; 	chassis_data.steerwheel[1].wheel_motor = wheel_motor2;
 8003804: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800383c <steerwheel_init+0x70>
 8003806: 681b         	ldr	r3, [r3]
 8003808: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8003820 <steerwheel_init+0x54>
 800380a: 6553         	str	r3, [r2, #0x54]
; 	chassis_data.steerwheel[2].wheel_motor = wheel_motor3;
 800380c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8003840 <steerwheel_init+0x74>
 800380e: 681b         	ldr	r3, [r3]
 8003810: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8003820 <steerwheel_init+0x54>
 8003812: 67d3         	str	r3, [r2, #0x7c]
; }
 8003814: bf00         	nop
 8003816: 46bd         	mov	sp, r7
 8003818: f85d 7b04    	ldr	r7, [sp], #4
 800381c: 4770         	bx	lr
 800381e: bf00         	nop

08003820 <$d>:
 8003820: 54 25 00 24  	.word	0x24002554
 8003824: 00 00 f0 42  	.word	0x42f00000
 8003828: 00 00 70 43  	.word	0x43700000
 800382c: 3c 06 00 24  	.word	0x2400063c
 8003830: 40 06 00 24  	.word	0x24000640
 8003834: 44 06 00 24  	.word	0x24000644
 8003838: 30 06 00 24  	.word	0x24000630
 800383c: 34 06 00 24  	.word	0x24000634
 8003840: 38 06 00 24  	.word	0x24000638

08003844 <main>:
; {
 8003844: b580         	push	{r7, lr}
 8003846: ed2d 8b02    	<unknown>
 800384a: b0d0         	sub	sp, #0x140
 800384c: af08         	add	r7, sp, #0x20
; 	board_init();
 800384e: f7fd fa05    	bl	0x8000c5c <board_init>  @ imm = #-0x2bf6
; 	steerwheel_init();
 8003852: f7ff ffbb    	bl	0x80037cc <steerwheel_init> @ imm = #-0x8a
; 	struct JFData *data = jf_send_init(uart_dev, 50);
 8003856: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8003904 <main+0xc0>
 8003858: 681b         	ldr	r3, [r3]
 800385a: 2132         	movs	r1, #0x32
 800385c: 4618         	mov	r0, r3
 800385e: f7ff ff43    	bl	0x80036e8 <jf_send_init> @ imm = #-0x17a
 8003862: f8c7 011c    	str.w	r0, [r7, #0x11c]
; 	k_sleep(K_MSEC(50));
 8003866: f44f 72fa    	mov.w	r2, #0x1f4
 800386a: f04f 0300    	mov.w	r3, #0x0
 800386e: 4610         	mov	r0, r2
 8003870: 4619         	mov	r1, r3
 8003872: f017 fbc2    	bl	0x801affa <k_sleep>     @ imm = #0x17784
; 	IMU_Sensor_trig_init(accel_dev, gyro_dev);
 8003876: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8003908 <main+0xc4>
 8003878: 681b         	ldr	r3, [r3]
 800387a: 4a24         	ldr	r2, [pc, #0x90]         @ 0x800390c <main+0xc8>
 800387c: 6812         	ldr	r2, [r2]
 800387e: 4611         	mov	r1, r2
 8003880: 4618         	mov	r0, r3
 8003882: f7ff fdc5    	bl	0x8003410 <IMU_Sensor_trig_init> @ imm = #-0x476
; 	IMU_Sensor_set_update_cb(Sensor_update_cb);
 8003886: 4822         	ldr	r0, [pc, #0x88]         @ 0x8003910 <main+0xcc>
 8003888: f7ff fbe4    	bl	0x8003054 <IMU_Sensor_set_update_cb> @ imm = #-0x838
; 			NULL, 0, 0, K_MSEC(300));
 800388c: f640 32b8    	movw	r2, #0xbb8
 8003890: f04f 0300    	mov.w	r3, #0x0
; 	k_thread_create(&feedback_thread_data, feedback_stack_area,
 8003894: 4638         	mov	r0, r7
 8003896: e9cd 2306    	strd	r2, r3, [sp, #24]
 800389a: 2300         	movs	r3, #0x0
 800389c: 9304         	str	r3, [sp, #0x10]
 800389e: 2300         	movs	r3, #0x0
 80038a0: 9303         	str	r3, [sp, #0xc]
 80038a2: 2300         	movs	r3, #0x0
 80038a4: 9302         	str	r3, [sp, #0x8]
 80038a6: 2300         	movs	r3, #0x0
 80038a8: 9301         	str	r3, [sp, #0x4]
 80038aa: 2300         	movs	r3, #0x0
 80038ac: 9300         	str	r3, [sp]
 80038ae: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8003914 <main+0xd0>
 80038b0: f44f 6200    	mov.w	r2, #0x800
 80038b4: 4918         	ldr	r1, [pc, #0x60]         @ 0x8003918 <main+0xd4>
 80038b6: f017 fb80    	bl	0x801afba <k_thread_create> @ imm = #0x17700
; 	int t = 0;
 80038ba: 2300         	movs	r3, #0x0
 80038bc: f8c7 3118    	str.w	r3, [r7, #0x118]
; 		chassis_set(sbus_get_percent(sbus, 1), sbus_get_percent(sbus, 3), 0);
 80038c0: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800391c <main+0xd8>
 80038c2: 681b         	ldr	r3, [r3]
 80038c4: 2101         	movs	r1, #0x1
 80038c6: 4618         	mov	r0, r3
 80038c8: f017 fbc5    	bl	0x801b056 <sbus_get_percent> @ imm = #0x1778a
 80038cc: eeb0 8a40    	<unknown>
 80038d0: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800391c <main+0xd8>
 80038d2: 681b         	ldr	r3, [r3]
 80038d4: 2103         	movs	r1, #0x3
 80038d6: 4618         	mov	r0, r3
 80038d8: f017 fbbd    	bl	0x801b056 <sbus_get_percent> @ imm = #0x1777a
 80038dc: eef0 7a40    	<unknown>
 80038e0: ed9f 1a0f    	<unknown>
 80038e4: eef0 0a67    	<unknown>
 80038e8: eeb0 0a48    	<unknown>
 80038ec: f7fd f888    	bl	0x8000a00 <chassis_set> @ imm = #-0x2ef0
; 		k_sleep(K_MSEC(50));
 80038f0: f44f 72fa    	mov.w	r2, #0x1f4
 80038f4: f04f 0300    	mov.w	r3, #0x0
 80038f8: 4610         	mov	r0, r2
 80038fa: 4619         	mov	r1, r3
 80038fc: f017 fb7d    	bl	0x801affa <k_sleep>     @ imm = #0x176fa
; 	while (1) {
 8003900: bf00         	nop
 8003902: e7dd         	b	0x80038c0 <main+0x7c>   @ imm = #-0x46

08003904 <$d>:
 8003904: 24 06 00 24  	.word	0x24000624
 8003908: 28 06 00 24  	.word	0x24000628
 800390c: 2c 06 00 24  	.word	0x2400062c
 8003910: 91 37 00 08  	.word	0x08003791
 8003914: 61 b8 01 08  	.word	0x0801b861
 8003918: f8 39 00 24  	.word	0x240039f8
 800391c: 48 06 00 24  	.word	0x24000648
 8003920: 00 00 00 00  	.word	0x00000000

08003924 <z_impl_motor_get_angle>:
; static inline float z_impl_motor_get_angle(const struct device *dev) {
 8003924: b580         	push	{r7, lr}
 8003926: b084         	sub	sp, #0x10
 8003928: af00         	add	r7, sp, #0x0
 800392a: 6078         	str	r0, [r7, #0x4]
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 800392c: 687b         	ldr	r3, [r7, #0x4]
 800392e: 689b         	ldr	r3, [r3, #0x8]
 8003930: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_get_angle == NULL) {
 8003932: 68fb         	ldr	r3, [r7, #0xc]
 8003934: 689b         	ldr	r3, [r3, #0x8]
 8003936: 2b00         	cmp	r3, #0x0
 8003938: d102         	bne	0x8003940 <z_impl_motor_get_angle+0x1c> @ imm = #0x4
;         return -ENOSYS;
 800393a: eddf 7a07    	<unknown>
 800393e: e005         	b	0x800394c <z_impl_motor_get_angle+0x28> @ imm = #0xa
;     return api->motor_get_angle(dev);
 8003940: 68fb         	ldr	r3, [r7, #0xc]
 8003942: 689b         	ldr	r3, [r3, #0x8]
 8003944: 6878         	ldr	r0, [r7, #0x4]
 8003946: 4798         	blx	r3
 8003948: eef0 7a40    	<unknown>
; }
 800394c: eeb0 0a67    	<unknown>
 8003950: 3710         	adds	r7, #0x10
 8003952: 46bd         	mov	sp, r7
 8003954: bd80         	pop	{r7, pc}
 8003956: bf00         	nop

08003958 <$d>:
 8003958: 00 00 b0 c2  	.word	0xc2b00000

0800395c <steerwheel_calc>:
; {
 800395c: b580         	push	{r7, lr}
 800395e: b086         	sub	sp, #0x18
 8003960: af00         	add	r7, sp, #0x0
 8003962: 6078         	str	r0, [r7, #0x4]
; 	float current_angle = motor_get_angle(steerwheel->steer_motor);
 8003964: 687b         	ldr	r3, [r7, #0x4]
 8003966: 6a1b         	ldr	r3, [r3, #0x20]
 8003968: 4618         	mov	r0, r3
 800396a: f017 ffbe    	bl	0x801b8ea <motor_get_angle> @ imm = #0x17f7c
 800396e: ed87 0a05    	<unknown>
; 	float target_angle = fmodf(steerwheel->angle + steerwheel->angle_offset, 360.0f);
 8003972: 687b         	ldr	r3, [r7, #0x4]
 8003974: ed93 7a00    	<unknown>
 8003978: 687b         	ldr	r3, [r7, #0x4]
 800397a: edd3 7a01    	<unknown>
 800397e: ee77 7a27    	<unknown>
 8003982: eddf 0a18    	<unknown>
 8003986: eeb0 0a67    	<unknown>
 800398a: f016 fbb7    	bl	0x801a0fc <fmodf>       @ imm = #0x1676e
 800398e: ed87 0a04    	<unknown>
; 	float rpm = (2 * PI * steerwheel->wheel_radius) / steerwheel->speed;
 8003992: 687b         	ldr	r3, [r7, #0x4]
 8003994: edd3 7a07    	<unknown>
 8003998: ed9f 7a13    	<unknown>
 800399c: ee67 6a87    	<unknown>
 80039a0: 687b         	ldr	r3, [r7, #0x4]
 80039a2: ed93 7a02    	<unknown>
 80039a6: eec6 7a87    	<unknown>
 80039aa: edc7 7a03    	<unknown>
; 	motor_set_angle(steerwheel->steer_motor, steerwheel->angle + steerwheel->angle_offset);
 80039ae: 687b         	ldr	r3, [r7, #0x4]
 80039b0: 6a1a         	ldr	r2, [r3, #0x20]
 80039b2: 687b         	ldr	r3, [r7, #0x4]
 80039b4: ed93 7a00    	<unknown>
 80039b8: 687b         	ldr	r3, [r7, #0x4]
 80039ba: edd3 7a01    	<unknown>
 80039be: ee77 7a27    	<unknown>
 80039c2: eeb0 0a67    	<unknown>
 80039c6: 4610         	mov	r0, r2
 80039c8: f017 ffad    	bl	0x801b926 <motor_set_angle> @ imm = #0x17f5a
; 	motor_set_speed(steerwheel->wheel_motor, rpm);
 80039cc: 687b         	ldr	r3, [r7, #0x4]
 80039ce: 6a5b         	ldr	r3, [r3, #0x24]
 80039d0: ed97 0a03    	<unknown>
 80039d4: 4618         	mov	r0, r3
 80039d6: f017 ff96    	bl	0x801b906 <motor_set_speed> @ imm = #0x17f2c
; }
 80039da: bf00         	nop
 80039dc: 3718         	adds	r7, #0x18
 80039de: 46bd         	mov	sp, r7
 80039e0: bd80         	pop	{r7, pc}
 80039e2: bf00         	nop

080039e4 <$d>:
 80039e4: 00 00 b4 43  	.word	0x43b40000
 80039e8: db 0f c9 40  	.word	0x40c90fdb

080039ec <linker_is_in_rodata>:
; {
 80039ec: b480         	push	{r7}
 80039ee: b083         	sub	sp, #0xc
 80039f0: af00         	add	r7, sp, #0x0
 80039f2: 6078         	str	r0, [r7, #0x4]
; 	return (((const char *)addr >= (const char *)RO_START) &&
 80039f4: 687b         	ldr	r3, [r7, #0x4]
 80039f6: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8003a1c <linker_is_in_rodata+0x30>
 80039f8: 4293         	cmp	r3, r2
 80039fa: d305         	blo	0x8003a08 <linker_is_in_rodata+0x1c> @ imm = #0xa
 80039fc: 687b         	ldr	r3, [r7, #0x4]
 80039fe: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8003a20 <linker_is_in_rodata+0x34>
 8003a00: 4293         	cmp	r3, r2
 8003a02: d201         	bhs	0x8003a08 <linker_is_in_rodata+0x1c> @ imm = #0x2
 8003a04: 2301         	movs	r3, #0x1
 8003a06: e000         	b	0x8003a0a <linker_is_in_rodata+0x1e> @ imm = #0x0
 8003a08: 2300         	movs	r3, #0x0
 8003a0a: f003 0301    	and	r3, r3, #0x1
 8003a0e: b2db         	uxtb	r3, r3
; }
 8003a10: 4618         	mov	r0, r3
 8003a12: 370c         	adds	r7, #0xc
 8003a14: 46bd         	mov	sp, r7
 8003a16: f85d 7b04    	ldr	r7, [sp], #4
 8003a1a: 4770         	bx	lr

08003a1c <$d>:
 8003a1c: e8 94 02 08  	.word	0x080294e8
 8003a20: 08 ec 02 08  	.word	0x0802ec08

08003a24 <cbvprintf_package>:
; {
 8003a24: b580         	push	{r7, lr}
 8003a26: b0a4         	sub	sp, #0x90
 8003a28: af00         	add	r7, sp, #0x0
 8003a2a: 60f8         	str	r0, [r7, #0xc]
 8003a2c: 60b9         	str	r1, [r7, #0x8]
 8003a2e: 607a         	str	r2, [r7, #0x4]
 8003a30: 603b         	str	r3, [r7]
; 	uint8_t *buf0 = packaged;  /* buffer start (may be NULL) */
 8003a32: 68fb         	ldr	r3, [r7, #0xc]
 8003a34: 65fb         	str	r3, [r7, #0x5c]
; 	uintptr_t buf = (uintptr_t)buf0; /* current buffer position */
 8003a36: 6dfb         	ldr	r3, [r7, #0x5c]
 8003a38: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
 8003a3c: 2300         	movs	r3, #0x0
 8003a3e: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	unsigned int s_rw_cnt = 0; /* number of rw strings */
 8003a42: 2300         	movs	r3, #0x0
 8003a44: 67fb         	str	r3, [r7, #0x7c]
; 	unsigned int s_ro_cnt = 0; /* number of ro strings */
 8003a46: 2300         	movs	r3, #0x0
 8003a48: 67bb         	str	r3, [r7, #0x78]
; 	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
 8003a4a: f04f 33ff    	mov.w	r3, #0xffffffff
 8003a4e: 677b         	str	r3, [r7, #0x74]
; 	bool parsing = false;
 8003a50: 2300         	movs	r3, #0x0
 8003a52: f887 306b    	strb.w	r3, [r7, #0x6b]
; 	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
 8003a56: 687b         	ldr	r3, [r7, #0x4]
 8003a58: f003 0304    	and	r3, r3, #0x4
 8003a5c: 2b00         	cmp	r3, #0x0
 8003a5e: bf14         	ite	ne
 8003a60: 2301         	movne	r3, #0x1
 8003a62: 2300         	moveq	r3, #0x0
 8003a64: f887 305b    	strb.w	r3, [r7, #0x5b]
; 	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
 8003a68: 687b         	ldr	r3, [r7, #0x4]
 8003a6a: 08db         	lsrs	r3, r3, #0x3
 8003a6c: f003 0307    	and	r3, r3, #0x7
 8003a70: 3301         	adds	r3, #0x1
 8003a72: 667b         	str	r3, [r7, #0x64]
; 	bool is_str_arg = false;
 8003a74: 2300         	movs	r3, #0x0
 8003a76: f887 3063    	strb.w	r3, [r7, #0x63]
; 	union cbprintf_package_hdr *pkg_hdr = packaged;
 8003a7a: 68fb         	ldr	r3, [r7, #0xc]
 8003a7c: 657b         	str	r3, [r7, #0x54]
; 	if ((uintptr_t)packaged % sizeof(void *)) {
 8003a7e: 68fb         	ldr	r3, [r7, #0xc]
 8003a80: f003 0303    	and	r3, r3, #0x3
 8003a84: 2b00         	cmp	r3, #0x0
 8003a86: d002         	beq	0x8003a8e <cbvprintf_package+0x6a> @ imm = #0x4
; 		return -EFAULT;
 8003a88: f06f 030d    	mvn	r3, #0xd
 8003a8c: e3a2         	b	0x80041d4 <cbvprintf_package+0x7b0> @ imm = #0x744
; 	buf += sizeof(*pkg_hdr);
 8003a8e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003a92: 3304         	adds	r3, #0x4
 8003a94: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	if (buf0 == NULL) {
 8003a98: 6dfb         	ldr	r3, [r7, #0x5c]
 8003a9a: 2b00         	cmp	r3, #0x0
 8003a9c: d10d         	bne	0x8003aba <cbvprintf_package+0x96> @ imm = #0x1a
; 		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
 8003a9e: 68bb         	ldr	r3, [r7, #0x8]
 8003aa0: f003 0307    	and	r3, r3, #0x7
 8003aa4: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003aa8: 4413         	add	r3, r2
 8003aaa: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
 8003aae: 68bb         	ldr	r3, [r7, #0x8]
 8003ab0: f003 0307    	and	r3, r3, #0x7
 8003ab4: f1c3 0308    	rsb.w	r3, r3, #0x8
 8003ab8: 60bb         	str	r3, [r7, #0x8]
; 	if ((buf0 != NULL) && (BUF_OFFSET + sizeof(char *)) > len) {
 8003aba: 6dfb         	ldr	r3, [r7, #0x5c]
 8003abc: 2b00         	cmp	r3, #0x0
 8003abe: d00a         	beq	0x8003ad6 <cbvprintf_package+0xb2> @ imm = #0x14
 8003ac0: 6dfb         	ldr	r3, [r7, #0x5c]
 8003ac2: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003ac6: 1ad3         	subs	r3, r2, r3
 8003ac8: 3304         	adds	r3, #0x4
 8003aca: 68ba         	ldr	r2, [r7, #0x8]
 8003acc: 429a         	cmp	r2, r3
 8003ace: d202         	bhs	0x8003ad6 <cbvprintf_package+0xb2> @ imm = #0x4
; 		return -ENOSPC;
 8003ad0: f06f 031b    	mvn	r3, #0x1b
 8003ad4: e37e         	b	0x80041d4 <cbvprintf_package+0x7b0> @ imm = #0x6fc
; 	s = fmt;
 8003ad6: 683b         	ldr	r3, [r7]
 8003ad8: 66fb         	str	r3, [r7, #0x6c]
; 	--fmt;
 8003ada: 683b         	ldr	r3, [r7]
 8003adc: 3b01         	subs	r3, #0x1
 8003ade: 603b         	str	r3, [r7]
; 	align = VA_STACK_ALIGN(char *);
 8003ae0: 2304         	movs	r3, #0x4
 8003ae2: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	size = sizeof(char *);
 8003ae6: 2304         	movs	r3, #0x4
 8003ae8: f8c7 3088    	str.w	r3, [r7, #0x88]
; 	goto process_string;
 8003aec: e197         	b	0x8003e1e <cbvprintf_package+0x3fa> @ imm = #0x32e
; 			if (!parsing) {
 8003aee: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 8003af2: f083 0301    	eor	r3, r3, #0x1
 8003af6: b2db         	uxtb	r3, r3
 8003af8: 2b00         	cmp	r3, #0x0
 8003afa: d011         	beq	0x8003b20 <cbvprintf_package+0xfc> @ imm = #0x22
; 				if (*fmt == '%') {
 8003afc: 683b         	ldr	r3, [r7]
 8003afe: 781b         	ldrb	r3, [r3]
 8003b00: 2b25         	cmp	r3, #0x25
 8003b02: f040 8278    	bne.w	0x8003ff6 <cbvprintf_package+0x5d2> @ imm = #0x4f0
; 					parsing = true;
 8003b06: 2301         	movs	r3, #0x1
 8003b08: f887 306b    	strb.w	r3, [r7, #0x6b]
; 					arg_idx++;
 8003b0c: 6f7b         	ldr	r3, [r7, #0x74]
 8003b0e: 3301         	adds	r3, #0x1
 8003b10: 677b         	str	r3, [r7, #0x74]
; 					align = VA_STACK_ALIGN(int);
 8003b12: 2304         	movs	r3, #0x4
 8003b14: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(int);
 8003b18: 2304         	movs	r3, #0x4
 8003b1a: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8003b1e: e26a         	b	0x8003ff6 <cbvprintf_package+0x5d2> @ imm = #0x4d4
; 			switch (*fmt) {
 8003b20: 683b         	ldr	r3, [r7]
 8003b22: 781b         	ldrb	r3, [r3]
 8003b24: 2b7a         	cmp	r3, #0x7a
 8003b26: f300 8149    	bgt.w	0x8003dbc <cbvprintf_package+0x398> @ imm = #0x292
 8003b2a: 2b4c         	cmp	r3, #0x4c
 8003b2c: da11         	bge	0x8003b52 <cbvprintf_package+0x12e> @ imm = #0x22
 8003b2e: 2b47         	cmp	r3, #0x47
 8003b30: f300 8144    	bgt.w	0x8003dbc <cbvprintf_package+0x398> @ imm = #0x288
 8003b34: 2b2a         	cmp	r3, #0x2a
 8003b36: da71         	bge	0x8003c1c <cbvprintf_package+0x1f8> @ imm = #0xe2
 8003b38: 2b25         	cmp	r3, #0x25
 8003b3a: f000 8092    	beq.w	0x8003c62 <cbvprintf_package+0x23e> @ imm = #0x124
 8003b3e: 2b25         	cmp	r3, #0x25
 8003b40: f300 813c    	bgt.w	0x8003dbc <cbvprintf_package+0x398> @ imm = #0x278
 8003b44: 2b20         	cmp	r3, #0x20
 8003b46: f000 8258    	beq.w	0x8003ffa <cbvprintf_package+0x5d6> @ imm = #0x4b0
 8003b4a: 2b23         	cmp	r3, #0x23
 8003b4c: f000 8255    	beq.w	0x8003ffa <cbvprintf_package+0x5d6> @ imm = #0x4aa
 8003b50: e134         	b	0x8003dbc <cbvprintf_package+0x398> @ imm = #0x268
 8003b52: 3b4c         	subs	r3, #0x4c
 8003b54: 2b2e         	cmp	r3, #0x2e
 8003b56: f200 8131    	bhi.w	0x8003dbc <cbvprintf_package+0x398> @ imm = #0x262
 8003b5a: a201         	adr	r2, #4 <cbvprintf_package+0x13b>
 8003b5c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08003b60 <$d>:
 8003b60: fb 3f 00 08  	.word	0x08003ffb
 8003b64: bd 3d 00 08  	.word	0x08003dbd
 8003b68: bd 3d 00 08  	.word	0x08003dbd
 8003b6c: bd 3d 00 08  	.word	0x08003dbd
 8003b70: bd 3d 00 08  	.word	0x08003dbd
 8003b74: bd 3d 00 08  	.word	0x08003dbd
 8003b78: bd 3d 00 08  	.word	0x08003dbd
 8003b7c: bd 3d 00 08  	.word	0x08003dbd
 8003b80: bd 3d 00 08  	.word	0x08003dbd
 8003b84: bd 3d 00 08  	.word	0x08003dbd
 8003b88: bd 3d 00 08  	.word	0x08003dbd
 8003b8c: bd 3d 00 08  	.word	0x08003dbd
 8003b90: 9b 3c 00 08  	.word	0x08003c9b
 8003b94: bd 3d 00 08  	.word	0x08003dbd
 8003b98: bd 3d 00 08  	.word	0x08003dbd
 8003b9c: bd 3d 00 08  	.word	0x08003dbd
 8003ba0: bd 3d 00 08  	.word	0x08003dbd
 8003ba4: bd 3d 00 08  	.word	0x08003dbd
 8003ba8: bd 3d 00 08  	.word	0x08003dbd
 8003bac: bd 3d 00 08  	.word	0x08003dbd
 8003bb0: bd 3d 00 08  	.word	0x08003dbd
 8003bb4: eb 3c 00 08  	.word	0x08003ceb
 8003bb8: bd 3d 00 08  	.word	0x08003dbd
 8003bbc: 9b 3c 00 08  	.word	0x08003c9b
 8003bc0: 9b 3c 00 08  	.word	0x08003c9b
 8003bc4: eb 3c 00 08  	.word	0x08003ceb
 8003bc8: eb 3c 00 08  	.word	0x08003ceb
 8003bcc: eb 3c 00 08  	.word	0x08003ceb
 8003bd0: fb 3f 00 08  	.word	0x08003ffb
 8003bd4: 9b 3c 00 08  	.word	0x08003c9b
 8003bd8: 71 3c 00 08  	.word	0x08003c71
 8003bdc: bd 3d 00 08  	.word	0x08003dbd
 8003be0: fb 3f 00 08  	.word	0x08003ffb
 8003be4: bd 3d 00 08  	.word	0x08003dbd
 8003be8: d7 3c 00 08  	.word	0x08003cd7
 8003bec: 9b 3c 00 08  	.word	0x08003c9b
 8003bf0: d7 3c 00 08  	.word	0x08003cd7
 8003bf4: bd 3d 00 08  	.word	0x08003dbd
 8003bf8: bd 3d 00 08  	.word	0x08003dbd
 8003bfc: d1 3c 00 08  	.word	0x08003cd1
 8003c00: 8d 3c 00 08  	.word	0x08003c8d
 8003c04: 9b 3c 00 08  	.word	0x08003c9b
 8003c08: bd 3d 00 08  	.word	0x08003dbd
 8003c0c: bd 3d 00 08  	.word	0x08003dbd
 8003c10: 9b 3c 00 08  	.word	0x08003c9b
 8003c14: bd 3d 00 08  	.word	0x08003dbd
 8003c18: 7f 3c 00 08  	.word	0x08003c7f

08003c1c <$t>:
 8003c1c: 3b2a         	subs	r3, #0x2a
 8003c1e: 2201         	movs	r2, #0x1
 8003c20: fa02 f303    	lsl.w	r3, r2, r3
 8003c24: f64f 72da    	movw	r2, #0xffda
 8003c28: 401a         	ands	r2, r3
 8003c2a: 2a00         	cmp	r2, #0x0
 8003c2c: bf14         	ite	ne
 8003c2e: 2201         	movne	r2, #0x1
 8003c30: 2200         	moveq	r2, #0x0
 8003c32: b2d2         	uxtb	r2, r2
 8003c34: 2a00         	cmp	r2, #0x0
 8003c36: f040 81e0    	bne.w	0x8003ffa <cbvprintf_package+0x5d6> @ imm = #0x3c0
 8003c3a: f003 5262    	and	r2, r3, #0x38800000
 8003c3e: 2a00         	cmp	r2, #0x0
 8003c40: bf14         	ite	ne
 8003c42: 2201         	movne	r2, #0x1
 8003c44: 2200         	moveq	r2, #0x0
 8003c46: b2d2         	uxtb	r2, r2
 8003c48: 2a00         	cmp	r2, #0x0
 8003c4a: d14e         	bne	0x8003cea <cbvprintf_package+0x2c6> @ imm = #0x9c
 8003c4c: f003 0301    	and	r3, r3, #0x1
 8003c50: 2b00         	cmp	r3, #0x0
 8003c52: bf14         	ite	ne
 8003c54: 2301         	movne	r3, #0x1
 8003c56: 2300         	moveq	r3, #0x0
 8003c58: b2db         	uxtb	r3, r3
 8003c5a: 2b00         	cmp	r3, #0x0
 8003c5c: f040 80b2    	bne.w	0x8003dc4 <cbvprintf_package+0x3a0> @ imm = #0x164
 8003c60: e0ac         	b	0x8003dbc <cbvprintf_package+0x398> @ imm = #0x158
; 				parsing = false;
 8003c62: 2300         	movs	r3, #0x0
 8003c64: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				arg_idx--;
 8003c68: 6f7b         	ldr	r3, [r7, #0x74]
 8003c6a: 3b01         	subs	r3, #0x1
 8003c6c: 677b         	str	r3, [r7, #0x74]
; 				continue;
 8003c6e: e1c5         	b	0x8003ffc <cbvprintf_package+0x5d8> @ imm = #0x38a
; 				align = VA_STACK_ALIGN(intmax_t);
 8003c70: 2308         	movs	r3, #0x8
 8003c72: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(intmax_t);
 8003c76: 2308         	movs	r3, #0x8
 8003c78: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8003c7c: e1be         	b	0x8003ffc <cbvprintf_package+0x5d8> @ imm = #0x37c
; 				align = VA_STACK_ALIGN(size_t);
 8003c7e: 2304         	movs	r3, #0x4
 8003c80: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(size_t);
 8003c84: 2304         	movs	r3, #0x4
 8003c86: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8003c8a: e1b7         	b	0x8003ffc <cbvprintf_package+0x5d8> @ imm = #0x36e
; 				align = VA_STACK_ALIGN(ptrdiff_t);
 8003c8c: 2304         	movs	r3, #0x4
 8003c8e: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(ptrdiff_t);
 8003c92: 2304         	movs	r3, #0x4
 8003c94: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8003c98: e1b0         	b	0x8003ffc <cbvprintf_package+0x5d8> @ imm = #0x360
; 				if (fmt[-1] == 'l') {
 8003c9a: 683b         	ldr	r3, [r7]
 8003c9c: 3b01         	subs	r3, #0x1
 8003c9e: 781b         	ldrb	r3, [r3]
 8003ca0: 2b6c         	cmp	r3, #0x6c
 8003ca2: d111         	bne	0x8003cc8 <cbvprintf_package+0x2a4> @ imm = #0x22
; 					if (fmt[-2] == 'l') {
 8003ca4: 683b         	ldr	r3, [r7]
 8003ca6: 3b02         	subs	r3, #0x2
 8003ca8: 781b         	ldrb	r3, [r3]
 8003caa: 2b6c         	cmp	r3, #0x6c
 8003cac: d106         	bne	0x8003cbc <cbvprintf_package+0x298> @ imm = #0xc
; 						align = VA_STACK_ALIGN(long long);
 8003cae: 2308         	movs	r3, #0x8
 8003cb0: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long long);
 8003cb4: 2308         	movs	r3, #0x8
 8003cb6: f8c7 3088    	str.w	r3, [r7, #0x88]
 8003cba: e005         	b	0x8003cc8 <cbvprintf_package+0x2a4> @ imm = #0xa
; 						align = VA_STACK_ALIGN(long);
 8003cbc: 2304         	movs	r3, #0x4
 8003cbe: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long);
 8003cc2: 2304         	movs	r3, #0x4
 8003cc4: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 8003cc8: 2300         	movs	r3, #0x0
 8003cca: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 8003cce: e07a         	b	0x8003dc6 <cbvprintf_package+0x3a2> @ imm = #0xf4
; 				is_str_arg = true;
 8003cd0: 2301         	movs	r3, #0x1
 8003cd2: f887 3063    	strb.w	r3, [r7, #0x63]
; 				align = VA_STACK_ALIGN(void *);
 8003cd6: 2304         	movs	r3, #0x4
 8003cd8: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(void *);
 8003cdc: 2304         	movs	r3, #0x4
 8003cde: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 8003ce2: 2300         	movs	r3, #0x0
 8003ce4: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 8003ce8: e06d         	b	0x8003dc6 <cbvprintf_package+0x3a2> @ imm = #0xda
; 				if (fmt[-1] == 'L') {
 8003cea: 683b         	ldr	r3, [r7]
 8003cec: 3b01         	subs	r3, #0x1
 8003cee: 781b         	ldrb	r3, [r3]
 8003cf0: 2b4c         	cmp	r3, #0x4c
 8003cf2: d113         	bne	0x8003d1c <cbvprintf_package+0x2f8> @ imm = #0x26
; 					v.ld = va_arg(ap, long double);
 8003cf4: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003cf8: 3307         	adds	r3, #0x7
 8003cfa: f023 0307    	bic	r3, r3, #0x7
 8003cfe: f103 0208    	add.w	r2, r3, #0x8
 8003d02: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003d06: e9d3 2300    	ldrd	r2, r3, [r3]
 8003d0a: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(long double);
 8003d0e: 2308         	movs	r3, #0x8
 8003d10: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(long double);
 8003d14: 2308         	movs	r3, #0x8
 8003d16: f8c7 3088    	str.w	r3, [r7, #0x88]
 8003d1a: e012         	b	0x8003d42 <cbvprintf_package+0x31e> @ imm = #0x24
; 					v.d = va_arg(ap, double);
 8003d1c: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003d20: 3307         	adds	r3, #0x7
 8003d22: f023 0307    	bic	r3, r3, #0x7
 8003d26: f103 0208    	add.w	r2, r3, #0x8
 8003d2a: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003d2e: e9d3 2300    	ldrd	r2, r3, [r3]
 8003d32: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(double);
 8003d36: 2308         	movs	r3, #0x8
 8003d38: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(double);
 8003d3c: 2308         	movs	r3, #0x8
 8003d3e: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				buf = ROUND_UP(buf, align);
 8003d42: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8003d46: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003d4a: 4413         	add	r3, r2
 8003d4c: 1e5a         	subs	r2, r3, #0x1
 8003d4e: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8003d52: fbb2 f2f3    	udiv	r2, r2, r3
 8003d56: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8003d5a: fb02 f303    	mul	r3, r2, r3
 8003d5e: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				if (buf0 != NULL) {
 8003d62: 6dfb         	ldr	r3, [r7, #0x5c]
 8003d64: 2b00         	cmp	r3, #0x0
 8003d66: d01e         	beq	0x8003da6 <cbvprintf_package+0x382> @ imm = #0x3c
; 					if (BUF_OFFSET + size > len) {
 8003d68: 6dfb         	ldr	r3, [r7, #0x5c]
 8003d6a: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003d6e: 1ad2         	subs	r2, r2, r3
 8003d70: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003d74: 4413         	add	r3, r2
 8003d76: 68ba         	ldr	r2, [r7, #0x8]
 8003d78: 429a         	cmp	r2, r3
 8003d7a: d202         	bhs	0x8003d82 <cbvprintf_package+0x35e> @ imm = #0x4
; 						return -ENOSPC;
 8003d7c: f06f 031b    	mvn	r3, #0x1b
 8003d80: e228         	b	0x80041d4 <cbvprintf_package+0x7b0> @ imm = #0x450
; 					} else if (fmt[-1] == 'L') {
 8003d82: 683b         	ldr	r3, [r7]
 8003d84: 3b01         	subs	r3, #0x1
 8003d86: 781b         	ldrb	r3, [r3]
 8003d88: 2b4c         	cmp	r3, #0x4c
 8003d8a: d106         	bne	0x8003d9a <cbvprintf_package+0x376> @ imm = #0xc
; 						*(long double *)buf = v.ld;
 8003d8c: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8003d90: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8003d94: e9c1 2300    	strd	r2, r3, [r1]
 8003d98: e005         	b	0x8003da6 <cbvprintf_package+0x382> @ imm = #0xa
; 						*(double *)buf = v.d;
 8003d9a: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8003d9e: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8003da2: e9c1 2300    	strd	r2, r3, [r1]
; 				buf += size;
 8003da6: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003daa: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003dae: 4413         	add	r3, r2
 8003db0: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				parsing = false;
 8003db4: 2300         	movs	r3, #0x0
 8003db6: f887 306b    	strb.w	r3, [r7, #0x6b]
 8003dba: e11f         	b	0x8003ffc <cbvprintf_package+0x5d8> @ imm = #0x23e
; 				parsing = false;
 8003dbc: 2300         	movs	r3, #0x0
 8003dbe: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				continue;
 8003dc2: e11b         	b	0x8003ffc <cbvprintf_package+0x5d8> @ imm = #0x236
; 				break;
 8003dc4: bf00         	nop
; 		buf = ROUND_UP(buf, align);
 8003dc6: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8003dca: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003dce: 4413         	add	r3, r2
 8003dd0: 1e5a         	subs	r2, r3, #0x1
 8003dd2: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8003dd6: fbb2 f2f3    	udiv	r2, r2, r3
 8003dda: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8003dde: fb02 f303    	mul	r3, r2, r3
 8003de2: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		if ((buf0 != NULL) && (BUF_OFFSET + size) > len) {
 8003de6: 6dfb         	ldr	r3, [r7, #0x5c]
 8003de8: 2b00         	cmp	r3, #0x0
 8003dea: d00c         	beq	0x8003e06 <cbvprintf_package+0x3e2> @ imm = #0x18
 8003dec: 6dfb         	ldr	r3, [r7, #0x5c]
 8003dee: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003df2: 1ad2         	subs	r2, r2, r3
 8003df4: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003df8: 4413         	add	r3, r2
 8003dfa: 68ba         	ldr	r2, [r7, #0x8]
 8003dfc: 429a         	cmp	r2, r3
 8003dfe: d202         	bhs	0x8003e06 <cbvprintf_package+0x3e2> @ imm = #0x4
; 			return -ENOSPC;
 8003e00: f06f 031b    	mvn	r3, #0x1b
 8003e04: e1e6         	b	0x80041d4 <cbvprintf_package+0x7b0> @ imm = #0x3cc
; 		if (is_str_arg) {
 8003e06: f897 3063    	ldrb.w	r3, [r7, #0x63]
 8003e0a: 2b00         	cmp	r3, #0x0
 8003e0c: f000 80a0    	beq.w	0x8003f50 <cbvprintf_package+0x52c> @ imm = #0x140
; 			s = va_arg(ap, char *);
 8003e10: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003e14: 1d1a         	adds	r2, r3, #0x4
 8003e16: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003e1a: 681b         	ldr	r3, [r3]
 8003e1c: 66fb         	str	r3, [r7, #0x6c]
; 			if (buf0 != NULL) {
 8003e1e: 6dfb         	ldr	r3, [r7, #0x5c]
 8003e20: 2b00         	cmp	r3, #0x0
 8003e22: d003         	beq	0x8003e2c <cbvprintf_package+0x408> @ imm = #0x6
; 				*(const char **)buf = s;
 8003e24: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003e28: 6efa         	ldr	r2, [r7, #0x6c]
 8003e2a: 601a         	str	r2, [r3]
; 			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 8003e2c: 6e7b         	ldr	r3, [r7, #0x64]
 8003e2e: 1e5a         	subs	r2, r3, #0x1
 8003e30: 667a         	str	r2, [r7, #0x64]
 8003e32: 2b00         	cmp	r3, #0x0
 8003e34: dc05         	bgt	0x8003e42 <cbvprintf_package+0x41e> @ imm = #0xa
 8003e36: 6ef8         	ldr	r0, [r7, #0x6c]
 8003e38: f018 fb1e    	bl	0x801c478 <ptr_in_rodata> @ imm = #0x1863c
 8003e3c: 4603         	mov	r3, r0
 8003e3e: 2b00         	cmp	r3, #0x0
 8003e40: d001         	beq	0x8003e46 <cbvprintf_package+0x422> @ imm = #0x2
 8003e42: 2301         	movs	r3, #0x1
 8003e44: e000         	b	0x8003e48 <cbvprintf_package+0x424> @ imm = #0x0
 8003e46: 2300         	movs	r3, #0x0
 8003e48: f887 3053    	strb.w	r3, [r7, #0x53]
; 			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);
 8003e4c: 687b         	ldr	r3, [r7, #0x4]
 8003e4e: f003 0302    	and	r3, r3, #0x2
 8003e52: 2b00         	cmp	r3, #0x0
 8003e54: bf14         	ite	ne
 8003e56: 2301         	movne	r3, #0x1
 8003e58: 2300         	moveq	r3, #0x0
 8003e5a: f887 3052    	strb.w	r3, [r7, #0x52]
; 			if (is_ro && !do_ro) {
 8003e5e: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8003e62: 2b00         	cmp	r3, #0x0
 8003e64: d006         	beq	0x8003e74 <cbvprintf_package+0x450> @ imm = #0xc
 8003e66: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8003e6a: f083 0301    	eor	r3, r3, #0x1
 8003e6e: b2db         	uxtb	r3, r3
 8003e70: 2b00         	cmp	r3, #0x0
 8003e72: d164         	bne	0x8003f3e <cbvprintf_package+0x51a> @ imm = #0xc8
; 				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
 8003e74: 6dfb         	ldr	r3, [r7, #0x5c]
 8003e76: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003e7a: 1ad3         	subs	r3, r2, r3
 8003e7c: 089b         	lsrs	r3, r3, #0x2
 8003e7e: 64fb         	str	r3, [r7, #0x4c]
; 				if (do_ro && s_ptr_idx > STR_POS_MASK) {
 8003e80: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8003e84: 2b00         	cmp	r3, #0x0
 8003e86: d005         	beq	0x8003e94 <cbvprintf_package+0x470> @ imm = #0xa
 8003e88: 6cfb         	ldr	r3, [r7, #0x4c]
 8003e8a: 2b7f         	cmp	r3, #0x7f
 8003e8c: d902         	bls	0x8003e94 <cbvprintf_package+0x470> @ imm = #0x4
; 					return -EINVAL;
 8003e8e: f06f 0315    	mvn	r3, #0x15
 8003e92: e19f         	b	0x80041d4 <cbvprintf_package+0x7b0> @ imm = #0x33e
; 				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
 8003e94: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003e98: 2b0f         	cmp	r3, #0xf
 8003e9a: d902         	bls	0x8003ea2 <cbvprintf_package+0x47e> @ imm = #0x4
; 					return -EINVAL;
 8003e9c: f06f 0315    	mvn	r3, #0x15
 8003ea0: e198         	b	0x80041d4 <cbvprintf_package+0x7b0> @ imm = #0x330
; 				if (buf0 != NULL) {
 8003ea2: 6dfb         	ldr	r3, [r7, #0x5c]
 8003ea4: 2b00         	cmp	r3, #0x0
 8003ea6: d02d         	beq	0x8003f04 <cbvprintf_package+0x4e0> @ imm = #0x5a
; 					str_ptr_pos[s_idx] = s_ptr_idx;
 8003ea8: 6cfb         	ldr	r3, [r7, #0x4c]
 8003eaa: b2d9         	uxtb	r1, r3
 8003eac: f107 0230    	add.w	r2, r7, #0x30
 8003eb0: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003eb4: 4413         	add	r3, r2
 8003eb6: 460a         	mov	r2, r1
 8003eb8: 701a         	strb	r2, [r3]
; 					str_ptr_arg[s_idx] = arg_idx;
 8003eba: 6f7b         	ldr	r3, [r7, #0x74]
 8003ebc: b2d9         	uxtb	r1, r3
 8003ebe: f107 0220    	add.w	r2, r7, #0x20
 8003ec2: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003ec6: 4413         	add	r3, r2
 8003ec8: 460a         	mov	r2, r1
 8003eca: 701a         	strb	r2, [r3]
; 					if (is_ro) {
 8003ecc: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8003ed0: 2b00         	cmp	r3, #0x0
 8003ed2: d013         	beq	0x8003efc <cbvprintf_package+0x4d8> @ imm = #0x26
; 						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
 8003ed4: f107 0230    	add.w	r2, r7, #0x30
 8003ed8: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003edc: 4413         	add	r3, r2
 8003ede: 781b         	ldrb	r3, [r3]
 8003ee0: f063 037f    	orn	r3, r3, #0x7f
 8003ee4: b2d9         	uxtb	r1, r3
 8003ee6: f107 0230    	add.w	r2, r7, #0x30
 8003eea: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003eee: 4413         	add	r3, r2
 8003ef0: 460a         	mov	r2, r1
 8003ef2: 701a         	strb	r2, [r3]
; 						s_ro_cnt++;
 8003ef4: 6fbb         	ldr	r3, [r7, #0x78]
 8003ef6: 3301         	adds	r3, #0x1
 8003ef8: 67bb         	str	r3, [r7, #0x78]
 8003efa: e01b         	b	0x8003f34 <cbvprintf_package+0x510> @ imm = #0x36
; 						s_rw_cnt++;
 8003efc: 6ffb         	ldr	r3, [r7, #0x7c]
 8003efe: 3301         	adds	r3, #0x1
 8003f00: 67fb         	str	r3, [r7, #0x7c]
 8003f02: e017         	b	0x8003f34 <cbvprintf_package+0x510> @ imm = #0x2e
; 				} else if (is_ro) {
 8003f04: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8003f08: 2b00         	cmp	r3, #0x0
 8003f0a: d003         	beq	0x8003f14 <cbvprintf_package+0x4f0> @ imm = #0x6
; 					len += 1;
 8003f0c: 68bb         	ldr	r3, [r7, #0x8]
 8003f0e: 3301         	adds	r3, #0x1
 8003f10: 60bb         	str	r3, [r7, #0x8]
 8003f12: e00f         	b	0x8003f34 <cbvprintf_package+0x510> @ imm = #0x1e
; 				} else if (rws_pos_en) {
 8003f14: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8003f18: 2b00         	cmp	r3, #0x0
 8003f1a: d003         	beq	0x8003f24 <cbvprintf_package+0x500> @ imm = #0x6
; 					len += 2;
 8003f1c: 68bb         	ldr	r3, [r7, #0x8]
 8003f1e: 3302         	adds	r3, #0x2
 8003f20: 60bb         	str	r3, [r7, #0x8]
 8003f22: e007         	b	0x8003f34 <cbvprintf_package+0x510> @ imm = #0xe
; 					len += strlen(s) + 1 + 1;
 8003f24: 6ef8         	ldr	r0, [r7, #0x6c]
 8003f26: f7fc fa47    	bl	0x80003b8 <strlen>      @ imm = #-0x3b72
 8003f2a: 4602         	mov	r2, r0
 8003f2c: 68bb         	ldr	r3, [r7, #0x8]
 8003f2e: 4413         	add	r3, r2
 8003f30: 3302         	adds	r3, #0x2
 8003f32: 60bb         	str	r3, [r7, #0x8]
; 				s_idx++;
 8003f34: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003f38: 3301         	adds	r3, #0x1
 8003f3a: f8c7 3080    	str.w	r3, [r7, #0x80]
; 			buf += sizeof(char *);
 8003f3e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003f42: 3304         	adds	r3, #0x4
 8003f44: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 			is_str_arg = false;
 8003f48: 2300         	movs	r3, #0x0
 8003f4a: f887 3063    	strb.w	r3, [r7, #0x63]
 8003f4e: e055         	b	0x8003ffc <cbvprintf_package+0x5d8> @ imm = #0xaa
; 		} else if (size == sizeof(int)) {
 8003f50: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003f54: 2b04         	cmp	r3, #0x4
 8003f56: d113         	bne	0x8003f80 <cbvprintf_package+0x55c> @ imm = #0x26
; 			int v = va_arg(ap, int);
 8003f58: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003f5c: 1d1a         	adds	r2, r3, #0x4
 8003f5e: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003f62: 681b         	ldr	r3, [r3]
 8003f64: 647b         	str	r3, [r7, #0x44]
; 			if (buf0 != NULL) {
 8003f66: 6dfb         	ldr	r3, [r7, #0x5c]
 8003f68: 2b00         	cmp	r3, #0x0
 8003f6a: d003         	beq	0x8003f74 <cbvprintf_package+0x550> @ imm = #0x6
; 				*(int *)buf = v;
 8003f6c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003f70: 6c7a         	ldr	r2, [r7, #0x44]
 8003f72: 601a         	str	r2, [r3]
; 			buf += sizeof(int);
 8003f74: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003f78: 3304         	adds	r3, #0x4
 8003f7a: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8003f7e: e03d         	b	0x8003ffc <cbvprintf_package+0x5d8> @ imm = #0x7a
; 		} else if (size == sizeof(long)) {
 8003f80: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003f84: 2b04         	cmp	r3, #0x4
 8003f86: d113         	bne	0x8003fb0 <cbvprintf_package+0x58c> @ imm = #0x26
; 			long v = va_arg(ap, long);
 8003f88: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003f8c: 1d1a         	adds	r2, r3, #0x4
 8003f8e: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003f92: 681b         	ldr	r3, [r3]
 8003f94: 64bb         	str	r3, [r7, #0x48]
; 			if (buf0 != NULL) {
 8003f96: 6dfb         	ldr	r3, [r7, #0x5c]
 8003f98: 2b00         	cmp	r3, #0x0
 8003f9a: d003         	beq	0x8003fa4 <cbvprintf_package+0x580> @ imm = #0x6
; 				*(long *)buf = v;
 8003f9c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003fa0: 6cba         	ldr	r2, [r7, #0x48]
 8003fa2: 601a         	str	r2, [r3]
; 			buf += sizeof(long);
 8003fa4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003fa8: 3304         	adds	r3, #0x4
 8003faa: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8003fae: e025         	b	0x8003ffc <cbvprintf_package+0x5d8> @ imm = #0x4a
; 		} else if (size == sizeof(long long)) {
 8003fb0: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003fb4: 2b08         	cmp	r3, #0x8
 8003fb6: d11b         	bne	0x8003ff0 <cbvprintf_package+0x5cc> @ imm = #0x36
; 			long long v = va_arg(ap, long long);
 8003fb8: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003fbc: 3307         	adds	r3, #0x7
 8003fbe: f023 0307    	bic	r3, r3, #0x7
 8003fc2: f103 0208    	add.w	r2, r3, #0x8
 8003fc6: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003fca: e9d3 2300    	ldrd	r2, r3, [r3]
 8003fce: e9c7 2304    	strd	r2, r3, [r7, #16]
; 			if (buf0 != NULL) {
 8003fd2: 6dfb         	ldr	r3, [r7, #0x5c]
 8003fd4: 2b00         	cmp	r3, #0x0
 8003fd6: d005         	beq	0x8003fe4 <cbvprintf_package+0x5c0> @ imm = #0xa
; 					*(long long *)buf = v;
 8003fd8: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8003fdc: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8003fe0: e9c1 2300    	strd	r2, r3, [r1]
; 			buf += sizeof(long long);
 8003fe4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003fe8: 3308         	adds	r3, #0x8
 8003fea: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8003fee: e005         	b	0x8003ffc <cbvprintf_package+0x5d8> @ imm = #0xa
; 			return -EINVAL;
 8003ff0: f06f 0315    	mvn	r3, #0x15
 8003ff4: e0ee         	b	0x80041d4 <cbvprintf_package+0x7b0> @ imm = #0x1dc
; 				continue;
 8003ff6: bf00         	nop
 8003ff8: e000         	b	0x8003ffc <cbvprintf_package+0x5d8> @ imm = #0x0
; 				continue;
 8003ffa: bf00         	nop
; 			if (*++fmt == '\0') {
 8003ffc: 683b         	ldr	r3, [r7]
 8003ffe: 3301         	adds	r3, #0x1
 8004000: 603b         	str	r3, [r7]
 8004002: 683b         	ldr	r3, [r7]
 8004004: 781b         	ldrb	r3, [r3]
 8004006: 2b00         	cmp	r3, #0x0
 8004008: f47f ad71    	bne.w	0x8003aee <cbvprintf_package+0xca> @ imm = #-0x51e
; 				break;
 800400c: bf00         	nop
; 	if ((BUF_OFFSET / sizeof(int)) > 255) {
 800400e: 6dfb         	ldr	r3, [r7, #0x5c]
 8004010: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004014: 1ad3         	subs	r3, r2, r3
 8004016: f5b3 6f80    	cmp.w	r3, #0x400
 800401a: d302         	blo	0x8004022 <cbvprintf_package+0x5fe> @ imm = #0x4
; 		return -EINVAL;
 800401c: f06f 0315    	mvn	r3, #0x15
 8004020: e0d8         	b	0x80041d4 <cbvprintf_package+0x7b0> @ imm = #0x1b0
; 	if (buf0 == NULL) {
 8004022: 6dfb         	ldr	r3, [r7, #0x5c]
 8004024: 2b00         	cmp	r3, #0x0
 8004026: d107         	bne	0x8004038 <cbvprintf_package+0x614> @ imm = #0xe
; 		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
 8004028: 6dfb         	ldr	r3, [r7, #0x5c]
 800402a: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 800402e: 1ad2         	subs	r2, r2, r3
 8004030: 68bb         	ldr	r3, [r7, #0x8]
 8004032: 4413         	add	r3, r2
 8004034: 3b08         	subs	r3, #0x8
 8004036: e0cd         	b	0x80041d4 <cbvprintf_package+0x7b0> @ imm = #0x19a
; 	*(char **)buf0 = NULL;
 8004038: 6dfb         	ldr	r3, [r7, #0x5c]
 800403a: 2200         	movs	r2, #0x0
 800403c: 601a         	str	r2, [r3]
; 	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
 800403e: 6dfb         	ldr	r3, [r7, #0x5c]
 8004040: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004044: 1ad3         	subs	r3, r2, r3
 8004046: 089b         	lsrs	r3, r3, #0x2
 8004048: b2da         	uxtb	r2, r3
 800404a: 6d7b         	ldr	r3, [r7, #0x54]
 800404c: 701a         	strb	r2, [r3]
; 	if (rws_pos_en) {
 800404e: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8004052: 2b00         	cmp	r3, #0x0
 8004054: d007         	beq	0x8004066 <cbvprintf_package+0x642> @ imm = #0xe
; 		pkg_hdr->desc.str_cnt = 0;
 8004056: 6d7b         	ldr	r3, [r7, #0x54]
 8004058: 2200         	movs	r2, #0x0
 800405a: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
 800405c: 6ffb         	ldr	r3, [r7, #0x7c]
 800405e: b2da         	uxtb	r2, r3
 8004060: 6d7b         	ldr	r3, [r7, #0x54]
 8004062: 70da         	strb	r2, [r3, #0x3]
 8004064: e006         	b	0x8004074 <cbvprintf_package+0x650> @ imm = #0xc
; 		pkg_hdr->desc.str_cnt = s_rw_cnt;
 8004066: 6ffb         	ldr	r3, [r7, #0x7c]
 8004068: b2da         	uxtb	r2, r3
 800406a: 6d7b         	ldr	r3, [r7, #0x54]
 800406c: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = 0;
 800406e: 6d7b         	ldr	r3, [r7, #0x54]
 8004070: 2200         	movs	r2, #0x0
 8004072: 70da         	strb	r2, [r3, #0x3]
; 	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
 8004074: 6fbb         	ldr	r3, [r7, #0x78]
 8004076: b2da         	uxtb	r2, r3
 8004078: 6d7b         	ldr	r3, [r7, #0x54]
 800407a: 709a         	strb	r2, [r3, #0x2]
; 	if (s_ro_cnt != 0U) {
 800407c: 6fbb         	ldr	r3, [r7, #0x78]
 800407e: 2b00         	cmp	r3, #0x0
 8004080: d032         	beq	0x80040e8 <cbvprintf_package+0x6c4> @ imm = #0x64
; 		for (i = 0; i < s_idx; i++) {
 8004082: 2300         	movs	r3, #0x0
 8004084: 673b         	str	r3, [r7, #0x70]
 8004086: e02a         	b	0x80040de <cbvprintf_package+0x6ba> @ imm = #0x54
; 			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
 8004088: f107 0230    	add.w	r2, r7, #0x30
 800408c: 6f3b         	ldr	r3, [r7, #0x70]
 800408e: 4413         	add	r3, r2
 8004090: 781b         	ldrb	r3, [r3]
 8004092: b25b         	sxtb	r3, r3
 8004094: 2b00         	cmp	r3, #0x0
 8004096: da1e         	bge	0x80040d6 <cbvprintf_package+0x6b2> @ imm = #0x3c
; 			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
 8004098: f107 0230    	add.w	r2, r7, #0x30
 800409c: 6f3b         	ldr	r3, [r7, #0x70]
 800409e: 4413         	add	r3, r2
 80040a0: 781b         	ldrb	r3, [r3]
 80040a2: f003 037f    	and	r3, r3, #0x7f
 80040a6: f887 3043    	strb.w	r3, [r7, #0x43]
; 			if ((BUF_OFFSET + 1) > len) {
 80040aa: 6dfb         	ldr	r3, [r7, #0x5c]
 80040ac: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80040b0: 1ad3         	subs	r3, r2, r3
 80040b2: 3301         	adds	r3, #0x1
 80040b4: 68ba         	ldr	r2, [r7, #0x8]
 80040b6: 429a         	cmp	r2, r3
 80040b8: d202         	bhs	0x80040c0 <cbvprintf_package+0x69c> @ imm = #0x4
; 				return -ENOSPC;
 80040ba: f06f 031b    	mvn	r3, #0x1b
 80040be: e089         	b	0x80041d4 <cbvprintf_package+0x7b0> @ imm = #0x112
; 			*(uint8_t *)buf = pos;
 80040c0: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80040c4: f897 2043    	ldrb.w	r2, [r7, #0x43]
 80040c8: 701a         	strb	r2, [r3]
; 			++buf;
 80040ca: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80040ce: 3301         	adds	r3, #0x1
 80040d0: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80040d4: e000         	b	0x80040d8 <cbvprintf_package+0x6b4> @ imm = #0x0
; 				continue;
 80040d6: bf00         	nop
; 		for (i = 0; i < s_idx; i++) {
 80040d8: 6f3b         	ldr	r3, [r7, #0x70]
 80040da: 3301         	adds	r3, #0x1
 80040dc: 673b         	str	r3, [r7, #0x70]
 80040de: 6f3a         	ldr	r2, [r7, #0x70]
 80040e0: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80040e4: 429a         	cmp	r2, r3
 80040e6: d3cf         	blo	0x8004088 <cbvprintf_package+0x664> @ imm = #-0x62
; 	for (i = 0; i < s_idx; i++) {
 80040e8: 2300         	movs	r3, #0x0
 80040ea: 673b         	str	r3, [r7, #0x70]
 80040ec: e069         	b	0x80041c2 <cbvprintf_package+0x79e> @ imm = #0xd2
; 		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
 80040ee: 6fbb         	ldr	r3, [r7, #0x78]
 80040f0: 2b00         	cmp	r3, #0x0
 80040f2: d007         	beq	0x8004104 <cbvprintf_package+0x6e0> @ imm = #0xe
 80040f4: f107 0230    	add.w	r2, r7, #0x30
 80040f8: 6f3b         	ldr	r3, [r7, #0x70]
 80040fa: 4413         	add	r3, r2
 80040fc: 781b         	ldrb	r3, [r3]
 80040fe: b25b         	sxtb	r3, r3
 8004100: 2b00         	cmp	r3, #0x0
 8004102: db5a         	blt	0x80041ba <cbvprintf_package+0x796> @ imm = #0xb4
; 		if (rws_pos_en) {
 8004104: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8004108: 2b00         	cmp	r3, #0x0
 800410a: d010         	beq	0x800412e <cbvprintf_package+0x70a> @ imm = #0x20
; 			size = 0;
 800410c: 2300         	movs	r3, #0x0
 800410e: f8c7 3088    	str.w	r3, [r7, #0x88]
; 			*(uint8_t *)buf = str_ptr_arg[i];
 8004112: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004116: f107 0120    	add.w	r1, r7, #0x20
 800411a: 6f3a         	ldr	r2, [r7, #0x70]
 800411c: 440a         	add	r2, r1
 800411e: 7812         	ldrb	r2, [r2]
 8004120: 701a         	strb	r2, [r3]
; 			++buf;
 8004122: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004126: 3301         	adds	r3, #0x1
 8004128: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800412c: e01a         	b	0x8004164 <cbvprintf_package+0x740> @ imm = #0x34
; 			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
 800412e: f107 0230    	add.w	r2, r7, #0x30
 8004132: 6f3b         	ldr	r3, [r7, #0x70]
 8004134: 4413         	add	r3, r2
 8004136: 781b         	ldrb	r3, [r3]
 8004138: 009b         	lsls	r3, r3, #0x2
 800413a: 6dfa         	ldr	r2, [r7, #0x5c]
 800413c: 4413         	add	r3, r2
 800413e: 681b         	ldr	r3, [r3]
 8004140: 66fb         	str	r3, [r7, #0x6c]
; 			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
 8004142: f107 0230    	add.w	r2, r7, #0x30
 8004146: 6f3b         	ldr	r3, [r7, #0x70]
 8004148: 4413         	add	r3, r2
 800414a: 781b         	ldrb	r3, [r3]
 800414c: 009b         	lsls	r3, r3, #0x2
 800414e: 6dfa         	ldr	r2, [r7, #0x5c]
 8004150: 4413         	add	r3, r2
 8004152: 2200         	movs	r2, #0x0
 8004154: 601a         	str	r2, [r3]
; 			size = strlen(s) + 1;
 8004156: 6ef8         	ldr	r0, [r7, #0x6c]
 8004158: f7fc f92e    	bl	0x80003b8 <strlen>      @ imm = #-0x3da4
 800415c: 4603         	mov	r3, r0
 800415e: 3301         	adds	r3, #0x1
 8004160: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		if ((BUF_OFFSET + 1 + size) > len) {
 8004164: 6dfb         	ldr	r3, [r7, #0x5c]
 8004166: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 800416a: 1ad2         	subs	r2, r2, r3
 800416c: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8004170: 4413         	add	r3, r2
 8004172: 3301         	adds	r3, #0x1
 8004174: 68ba         	ldr	r2, [r7, #0x8]
 8004176: 429a         	cmp	r2, r3
 8004178: d202         	bhs	0x8004180 <cbvprintf_package+0x75c> @ imm = #0x4
; 			return -ENOSPC;
 800417a: f06f 031b    	mvn	r3, #0x1b
 800417e: e029         	b	0x80041d4 <cbvprintf_package+0x7b0> @ imm = #0x52
; 		*(uint8_t *)buf = str_ptr_pos[i];
 8004180: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004184: f107 0130    	add.w	r1, r7, #0x30
 8004188: 6f3a         	ldr	r2, [r7, #0x70]
 800418a: 440a         	add	r2, r1
 800418c: 7812         	ldrb	r2, [r2]
 800418e: 701a         	strb	r2, [r3]
; 		++buf;
 8004190: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004194: 3301         	adds	r3, #0x1
 8004196: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		memcpy((void *)buf, (uint8_t *)s, size);
 800419a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800419e: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 80041a2: 6ef9         	ldr	r1, [r7, #0x6c]
 80041a4: 4618         	mov	r0, r3
 80041a6: f024 ffa5    	bl	0x80290f4 <memcpy>      @ imm = #0x24f4a
; 		buf += size;
 80041aa: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80041ae: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80041b2: 4413         	add	r3, r2
 80041b4: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80041b8: e000         	b	0x80041bc <cbvprintf_package+0x798> @ imm = #0x0
; 			continue;
 80041ba: bf00         	nop
; 	for (i = 0; i < s_idx; i++) {
 80041bc: 6f3b         	ldr	r3, [r7, #0x70]
 80041be: 3301         	adds	r3, #0x1
 80041c0: 673b         	str	r3, [r7, #0x70]
 80041c2: 6f3a         	ldr	r2, [r7, #0x70]
 80041c4: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80041c8: 429a         	cmp	r2, r3
 80041ca: d390         	blo	0x80040ee <cbvprintf_package+0x6ca> @ imm = #-0xe0
; 	return BUF_OFFSET;
 80041cc: 6dfb         	ldr	r3, [r7, #0x5c]
 80041ce: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80041d2: 1ad3         	subs	r3, r2, r3
; }
 80041d4: 4618         	mov	r0, r3
 80041d6: 3790         	adds	r7, #0x90
 80041d8: 46bd         	mov	sp, r7
 80041da: bd80         	pop	{r7, pc}

080041dc <__printk_hook_install>:
; {
 80041dc: b480         	push	{r7}
 80041de: b083         	sub	sp, #0xc
 80041e0: af00         	add	r7, sp, #0x0
 80041e2: 6078         	str	r0, [r7, #0x4]
; 	_char_out = fn;
 80041e4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80041f8 <__printk_hook_install+0x1c>
 80041e6: 687b         	ldr	r3, [r7, #0x4]
 80041e8: 6013         	str	r3, [r2]
; }
 80041ea: bf00         	nop
 80041ec: 370c         	adds	r7, #0xc
 80041ee: 46bd         	mov	sp, r7
 80041f0: f85d 7b04    	ldr	r7, [sp], #4
 80041f4: 4770         	bx	lr
 80041f6: bf00         	nop

080041f8 <$d>:
 80041f8: 4c 06 00 24  	.word	0x2400064c

080041fc <k_current_get>:
; {
 80041fc: b580         	push	{r7, lr}
 80041fe: af00         	add	r7, sp, #0x0
; 	return z_tls_current;
 8004200: f025 f968    	bl	0x80294d4 <__aeabi_read_tp> @ imm = #0x252d0
 8004204: 4603         	mov	r3, r0
 8004206: 4a02         	ldr	r2, [pc, #0x8]          @ 0x8004210 <k_current_get+0x14>
 8004208: 589b         	ldr	r3, [r3, r2]
; }
 800420a: 4618         	mov	r0, r3
 800420c: bd80         	pop	{r7, pc}
 800420e: bf00         	nop

08004210 <$d>:
 8004210: 08 00 00 00  	.word	0x00000008

08004214 <z_thread_entry>:
; {
 8004214: b580         	push	{r7, lr}
 8004216: b084         	sub	sp, #0x10
 8004218: af00         	add	r7, sp, #0x0
 800421a: 60f8         	str	r0, [r7, #0xc]
 800421c: 60b9         	str	r1, [r7, #0x8]
 800421e: 607a         	str	r2, [r7, #0x4]
 8004220: 603b         	str	r3, [r7]
; 	z_tls_current = k_sched_current_thread_query();
 8004222: f018 f9cc    	bl	0x801c5be <k_sched_current_thread_query> @ imm = #0x18398
 8004226: 4602         	mov	r2, r0
 8004228: f025 f954    	bl	0x80294d4 <__aeabi_read_tp> @ imm = #0x252a8
 800422c: 4603         	mov	r3, r0
 800422e: 4906         	ldr	r1, [pc, #0x18]         @ 0x8004248 <z_thread_entry+0x34>
 8004230: 505a         	str	r2, [r3, r1]
; 	entry(p1, p2, p3);
 8004232: 68fb         	ldr	r3, [r7, #0xc]
 8004234: 683a         	ldr	r2, [r7]
 8004236: 6879         	ldr	r1, [r7, #0x4]
 8004238: 68b8         	ldr	r0, [r7, #0x8]
 800423a: 4798         	blx	r3
; 	k_thread_abort(k_current_get());
 800423c: f7ff ffde    	bl	0x80041fc <k_current_get> @ imm = #-0x44
 8004240: 4603         	mov	r3, r0
 8004242: 4618         	mov	r0, r3
 8004244: f018 f9c2    	bl	0x801c5cc <k_thread_abort> @ imm = #0x18384

08004248 <$d>:
 8004248: 08 00 00 00  	.word	0x00000008

0800424c <LL_DBGMCU_DisableD1DebugInSleepMode>:
; {
 800424c: b480         	push	{r7}
 800424e: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
 8004250: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8004268 <LL_DBGMCU_DisableD1DebugInSleepMode+0x1c>
 8004252: 685b         	ldr	r3, [r3, #0x4]
 8004254: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004268 <LL_DBGMCU_DisableD1DebugInSleepMode+0x1c>
 8004256: f023 0301    	bic	r3, r3, #0x1
 800425a: 6053         	str	r3, [r2, #0x4]
; }
 800425c: bf00         	nop
 800425e: 46bd         	mov	sp, r7
 8004260: f85d 7b04    	ldr	r7, [sp], #4
 8004264: 4770         	bx	lr
 8004266: bf00         	nop

08004268 <$d>:
 8004268: 00 10 00 5c  	.word	0x5c001000

0800426c <LL_DBGMCU_DisableD1DebugInStopMode>:
; {
 800426c: b480         	push	{r7}
 800426e: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
 8004270: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8004288 <LL_DBGMCU_DisableD1DebugInStopMode+0x1c>
 8004272: 685b         	ldr	r3, [r3, #0x4]
 8004274: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004288 <LL_DBGMCU_DisableD1DebugInStopMode+0x1c>
 8004276: f023 0302    	bic	r3, r3, #0x2
 800427a: 6053         	str	r3, [r2, #0x4]
; }
 800427c: bf00         	nop
 800427e: 46bd         	mov	sp, r7
 8004280: f85d 7b04    	ldr	r7, [sp], #4
 8004284: 4770         	bx	lr
 8004286: bf00         	nop

08004288 <$d>:
 8004288: 00 10 00 5c  	.word	0x5c001000

0800428c <LL_PWR_ConfigSupply>:
; {
 800428c: b480         	push	{r7}
 800428e: b083         	sub	sp, #0xc
 8004290: af00         	add	r7, sp, #0x0
 8004292: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(PWR->CR3, (PWR_CR3_SCUEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS), SupplySource);
 8004294: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80042b0 <LL_PWR_ConfigSupply+0x24>
 8004296: 68db         	ldr	r3, [r3, #0xc]
 8004298: f023 0207    	bic	r2, r3, #0x7
 800429c: 4904         	ldr	r1, [pc, #0x10]         @ 0x80042b0 <LL_PWR_ConfigSupply+0x24>
 800429e: 687b         	ldr	r3, [r7, #0x4]
 80042a0: 4313         	orrs	r3, r2
 80042a2: 60cb         	str	r3, [r1, #0xc]
; }
 80042a4: bf00         	nop
 80042a6: 370c         	adds	r7, #0xc
 80042a8: 46bd         	mov	sp, r7
 80042aa: f85d 7b04    	ldr	r7, [sp], #4
 80042ae: 4770         	bx	lr

080042b0 <$d>:
 80042b0: 00 48 02 58  	.word	0x58024800

080042b4 <LL_PWR_SetRegulVoltageScaling>:
; {
 80042b4: b480         	push	{r7}
 80042b6: b083         	sub	sp, #0xc
 80042b8: af00         	add	r7, sp, #0x0
 80042ba: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);
 80042bc: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80042d8 <LL_PWR_SetRegulVoltageScaling+0x24>
 80042be: 699b         	ldr	r3, [r3, #0x18]
 80042c0: f423 4240    	bic	r2, r3, #0xc000
 80042c4: 4904         	ldr	r1, [pc, #0x10]         @ 0x80042d8 <LL_PWR_SetRegulVoltageScaling+0x24>
 80042c6: 687b         	ldr	r3, [r7, #0x4]
 80042c8: 4313         	orrs	r3, r2
 80042ca: 618b         	str	r3, [r1, #0x18]
; }
 80042cc: bf00         	nop
 80042ce: 370c         	adds	r7, #0xc
 80042d0: 46bd         	mov	sp, r7
 80042d2: f85d 7b04    	ldr	r7, [sp], #4
 80042d6: 4770         	bx	lr

080042d8 <$d>:
 80042d8: 00 48 02 58  	.word	0x58024800

080042dc <LL_PWR_IsActiveFlag_VOS>:
; {
 80042dc: b480         	push	{r7}
 80042de: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(PWR->D3CR, PWR_D3CR_VOSRDY) == (PWR_D3CR_VOSRDY)) ? 1UL : 0UL);
 80042e0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8004300 <LL_PWR_IsActiveFlag_VOS+0x24>
 80042e2: 699b         	ldr	r3, [r3, #0x18]
 80042e4: f403 5300    	and	r3, r3, #0x2000
 80042e8: f5b3 5f00    	cmp.w	r3, #0x2000
 80042ec: d101         	bne	0x80042f2 <LL_PWR_IsActiveFlag_VOS+0x16> @ imm = #0x2
 80042ee: 2301         	movs	r3, #0x1
 80042f0: e000         	b	0x80042f4 <LL_PWR_IsActiveFlag_VOS+0x18> @ imm = #0x0
 80042f2: 2300         	movs	r3, #0x0
; }
 80042f4: 4618         	mov	r0, r3
 80042f6: 46bd         	mov	sp, r7
 80042f8: f85d 7b04    	ldr	r7, [sp], #4
 80042fc: 4770         	bx	lr
 80042fe: bf00         	nop

08004300 <$d>:
 8004300: 00 48 02 58  	.word	0x58024800

08004304 <LL_DBGMCU_GetRevisionID>:
; {
 8004304: b480         	push	{r7}
 8004306: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(DBGMCU->IDCODE, DBGMCU_IDCODE_REV_ID) >> DBGMCU_IDCODE_REV_ID_Pos);
 8004308: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800431c <LL_DBGMCU_GetRevisionID+0x18>
 800430a: 681b         	ldr	r3, [r3]
 800430c: 0c1b         	lsrs	r3, r3, #0x10
 800430e: b29b         	uxth	r3, r3
; }
 8004310: 4618         	mov	r0, r3
 8004312: 46bd         	mov	sp, r7
 8004314: f85d 7b04    	ldr	r7, [sp], #4
 8004318: 4770         	bx	lr
 800431a: bf00         	nop

0800431c <$d>:
 800431c: 00 10 00 5c  	.word	0x5c001000

08004320 <soc_early_init_hook>:
; {
 8004320: b580         	push	{r7, lr}
 8004322: af00         	add	r7, sp, #0x0
; }
 8004324: bf00         	nop
; }
 8004326: bf00         	nop
; 	SystemCoreClock = 64000000;
 8004328: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8004378 <soc_early_init_hook+0x58>
 800432a: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800437c <soc_early_init_hook+0x5c>
 800432c: 601a         	str	r2, [r3]
; 	LL_PWR_ConfigSupply(LL_PWR_LDO_SUPPLY);
 800432e: 2002         	movs	r0, #0x2
 8004330: f7ff ffac    	bl	0x800428c <LL_PWR_ConfigSupply> @ imm = #-0xa8
; 	LL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE1);
 8004334: f44f 4040    	mov.w	r0, #0xc000
 8004338: f7ff ffbc    	bl	0x80042b4 <LL_PWR_SetRegulVoltageScaling> @ imm = #-0x88
; 	while (LL_PWR_IsActiveFlag_VOS() == 0) {
 800433c: bf00         	nop
 800433e: f7ff ffcd    	bl	0x80042dc <LL_PWR_IsActiveFlag_VOS> @ imm = #-0x66
 8004342: 4603         	mov	r3, r0
 8004344: 2b00         	cmp	r3, #0x0
 8004346: d0fa         	beq	0x800433e <soc_early_init_hook+0x1e> @ imm = #-0xc
; 	if (LL_DBGMCU_GetRevisionID() == 0x1003) {
 8004348: f7ff ffdc    	bl	0x8004304 <LL_DBGMCU_GetRevisionID> @ imm = #-0x48
 800434c: 4603         	mov	r3, r0
 800434e: f241 0203    	movw	r2, #0x1003
 8004352: 4293         	cmp	r3, r2
 8004354: d10d         	bne	0x8004372 <soc_early_init_hook+0x52> @ imm = #0x1a
; 		MODIFY_REG(GPV->AXI_TARG7_FN_MOD, 0x1, 0x1);
 8004356: f04f 43a2    	mov.w	r3, #0x51000000
 800435a: f503 4300    	add.w	r3, r3, #0x8000
 800435e: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 8004362: f04f 42a2    	mov.w	r2, #0x51000000
 8004366: f043 0301    	orr	r3, r3, #0x1
 800436a: f502 4200    	add.w	r2, r2, #0x8000
 800436e: f8c2 3108    	str.w	r3, [r2, #0x108]
; }
 8004372: bf00         	nop
 8004374: bd80         	pop	{r7, pc}
 8004376: bf00         	nop

08004378 <$d>:
 8004378: 4c 0b 00 24  	.word	0x24000b4c
 800437c: 00 90 d0 03  	.word	0x03d09000

08004380 <thread_print_cb>:
; {
 8004380: b5b0         	push	{r4, r5, r7, lr}
 8004382: b092         	sub	sp, #0x48
 8004384: af0a         	add	r7, sp, #0x28
 8004386: 6078         	str	r0, [r7, #0x4]
; 	size_t pcnt = (info->stack_used * 100U) / info->stack_size;
 8004388: 687b         	ldr	r3, [r7, #0x4]
 800438a: 689b         	ldr	r3, [r3, #0x8]
 800438c: 2264         	movs	r2, #0x64
 800438e: fb03 f202    	mul	r2, r3, r2
 8004392: 687b         	ldr	r3, [r7, #0x4]
 8004394: 685b         	ldr	r3, [r3, #0x4]
 8004396: fbb2 f3f3    	udiv	r3, r2, r3
 800439a: 61fb         	str	r3, [r7, #0x1c]
; 	THREAD_ANALYZER_PRINT(
 800439c: 2303         	movs	r3, #0x3
 800439e: 2b02         	cmp	r3, #0x2
 80043a0: d92b         	bls	0x80043fa <thread_print_cb+0x7a> @ imm = #0x56
 80043a2: 2301         	movs	r3, #0x1
 80043a4: 76fb         	strb	r3, [r7, #0x1b]
 80043a6: 7efb         	ldrb	r3, [r7, #0x1b]
 80043a8: f083 0301    	eor	r3, r3, #0x1
 80043ac: b2db         	uxtb	r3, r3
 80043ae: 2b00         	cmp	r3, #0x0
 80043b0: d123         	bne	0x80043fa <thread_print_cb+0x7a> @ imm = #0x46
 80043b2: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8004448 <thread_print_cb+0xc8>
 80043b4: 681d         	ldr	r5, [r3]
 80043b6: 687b         	ldr	r3, [r7, #0x4]
 80043b8: 681b         	ldr	r3, [r3]
 80043ba: 687a         	ldr	r2, [r7, #0x4]
 80043bc: 6851         	ldr	r1, [r2, #0x4]
 80043be: 687a         	ldr	r2, [r7, #0x4]
 80043c0: 6892         	ldr	r2, [r2, #0x8]
 80043c2: 1a8a         	subs	r2, r1, r2
 80043c4: 6879         	ldr	r1, [r7, #0x4]
 80043c6: 6889         	ldr	r1, [r1, #0x8]
 80043c8: 6878         	ldr	r0, [r7, #0x4]
 80043ca: 6840         	ldr	r0, [r0, #0x4]
 80043cc: 687c         	ldr	r4, [r7, #0x4]
 80043ce: 68e4         	ldr	r4, [r4, #0xc]
 80043d0: 9408         	str	r4, [sp, #0x20]
 80043d2: 69fc         	ldr	r4, [r7, #0x1c]
 80043d4: 9407         	str	r4, [sp, #0x1c]
 80043d6: 9006         	str	r0, [sp, #0x18]
 80043d8: 9105         	str	r1, [sp, #0x14]
 80043da: 9204         	str	r2, [sp, #0x10]
 80043dc: 9303         	str	r3, [sp, #0xc]
 80043de: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800444c <thread_print_cb+0xcc>
 80043e0: 9302         	str	r3, [sp, #0x8]
 80043e2: 2300         	movs	r3, #0x0
 80043e4: 9301         	str	r3, [sp, #0x4]
 80043e6: 2300         	movs	r3, #0x0
 80043e8: 9300         	str	r3, [sp]
 80043ea: 2300         	movs	r3, #0x0
 80043ec: 2203         	movs	r2, #0x3
 80043ee: 4629         	mov	r1, r5
 80043f0: 2000         	movs	r0, #0x0
 80043f2: f018 f91f    	bl	0x801c634 <z_log_msg_runtime_create> @ imm = #0x1823e
 80043f6: 2300         	movs	r3, #0x0
 80043f8: 617b         	str	r3, [r7, #0x14]
; 	THREAD_ANALYZER_PRINT(
 80043fa: 2303         	movs	r3, #0x3
 80043fc: 2b02         	cmp	r3, #0x2
 80043fe: d91e         	bls	0x800443e <thread_print_cb+0xbe> @ imm = #0x3c
 8004400: 2301         	movs	r3, #0x1
 8004402: 74fb         	strb	r3, [r7, #0x13]
 8004404: 7cfb         	ldrb	r3, [r7, #0x13]
 8004406: f083 0301    	eor	r3, r3, #0x1
 800440a: b2db         	uxtb	r3, r3
 800440c: 2b00         	cmp	r3, #0x0
 800440e: d116         	bne	0x800443e <thread_print_cb+0xbe> @ imm = #0x2c
 8004410: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8004448 <thread_print_cb+0xc8>
 8004412: 6819         	ldr	r1, [r3]
 8004414: 687b         	ldr	r3, [r7, #0x4]
 8004416: e9d3 2306    	ldrd	r2, r3, [r3, #24]
 800441a: e9cd 2304    	strd	r2, r3, [sp, #16]
 800441e: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004450 <thread_print_cb+0xd0>
 8004420: 9303         	str	r3, [sp, #0xc]
 8004422: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004454 <thread_print_cb+0xd4>
 8004424: 9302         	str	r3, [sp, #0x8]
 8004426: 2300         	movs	r3, #0x0
 8004428: 9301         	str	r3, [sp, #0x4]
 800442a: 2300         	movs	r3, #0x0
 800442c: 9300         	str	r3, [sp]
 800442e: 2300         	movs	r3, #0x0
 8004430: 2203         	movs	r2, #0x3
 8004432: 2000         	movs	r0, #0x0
 8004434: f018 f8fe    	bl	0x801c634 <z_log_msg_runtime_create> @ imm = #0x181fc
 8004438: 2300         	movs	r3, #0x0
 800443a: 60fb         	str	r3, [r7, #0xc]
; }
 800443c: bf00         	nop
 800443e: bf00         	nop
 8004440: 3720         	adds	r7, #0x20
 8004442: 46bd         	mov	sp, r7
 8004444: bdb0         	pop	{r4, r5, r7, pc}
 8004446: bf00         	nop

08004448 <$d>:
 8004448: 50 06 00 24  	.word	0x24000650
 800444c: 9c a3 02 08  	.word	0x0802a39c
 8004450: dc a3 02 08  	.word	0x0802a3dc
 8004454: e0 a3 02 08  	.word	0x0802a3e0

08004458 <thread_analyze_cb>:
; {
 8004458: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800445c: b0a9         	sub	sp, #0xa4
 800445e: af06         	add	r7, sp, #0x18
 8004460: 60f8         	str	r0, [r7, #0xc]
 8004462: 60b9         	str	r1, [r7, #0x8]
; 	struct k_thread *thread = (struct k_thread *)cthread;
 8004464: 68fb         	ldr	r3, [r7, #0xc]
 8004466: 67fb         	str	r3, [r7, #0x7c]
; 	size_t size = thread->stack_info.size;
 8004468: 6ffb         	ldr	r3, [r7, #0x7c]
 800446a: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800446e: 67bb         	str	r3, [r7, #0x78]
; 	struct ta_cb_user_data *ud = user_data;
 8004470: 68bb         	ldr	r3, [r7, #0x8]
 8004472: 677b         	str	r3, [r7, #0x74]
; 	thread_analyzer_cb cb = ud->cb;
 8004474: 6f7b         	ldr	r3, [r7, #0x74]
 8004476: 681b         	ldr	r3, [r3]
 8004478: 673b         	str	r3, [r7, #0x70]
; 	unsigned int cpu = ud->cpu;
 800447a: 6f7b         	ldr	r3, [r7, #0x74]
 800447c: 685b         	ldr	r3, [r3, #0x4]
 800447e: 66fb         	str	r3, [r7, #0x6c]
; 	name = k_thread_name_get((k_tid_t)thread);
 8004480: 6ff8         	ldr	r0, [r7, #0x7c]
 8004482: f023 fdc2    	bl	0x802800a <k_thread_name_get> @ imm = #0x23b84
 8004486: f8c7 0080    	str.w	r0, [r7, #0x80]
; 	if (!name || name[0] == '\0') {
 800448a: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800448e: 2b00         	cmp	r3, #0x0
 8004490: d004         	beq	0x800449c <thread_analyze_cb+0x44> @ imm = #0x8
 8004492: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004496: 781b         	ldrb	r3, [r3]
 8004498: 2b00         	cmp	r3, #0x0
 800449a: d10a         	bne	0x80044b2 <thread_analyze_cb+0x5a> @ imm = #0x14
; 		name = hexname;
 800449c: f107 0314    	add.w	r3, r7, #0x14
 80044a0: f8c7 3080    	str.w	r3, [r7, #0x80]
; 		snprintk(hexname, sizeof(hexname), "%p", (void *)thread);
 80044a4: f107 0014    	add.w	r0, r7, #0x14
 80044a8: 6ffb         	ldr	r3, [r7, #0x7c]
 80044aa: 4a47         	ldr	r2, [pc, #0x11c]        @ 0x80045c8 <thread_analyze_cb+0x170>
 80044ac: 210b         	movs	r1, #0xb
 80044ae: f014 fa23    	bl	0x80188f8 <snprintf>    @ imm = #0x14446
; 	err = k_thread_stack_space_get(thread, &unused);
 80044b2: f107 0310    	add.w	r3, r7, #0x10
 80044b6: 4619         	mov	r1, r3
 80044b8: 6ff8         	ldr	r0, [r7, #0x7c]
 80044ba: f018 f8ad    	bl	0x801c618 <k_thread_stack_space_get> @ imm = #0x1815a
 80044be: 66b8         	str	r0, [r7, #0x68]
; 	if (err) {
 80044c0: 6ebb         	ldr	r3, [r7, #0x68]
 80044c2: 2b00         	cmp	r3, #0x0
 80044c4: d022         	beq	0x800450c <thread_analyze_cb+0xb4> @ imm = #0x44
; 		THREAD_ANALYZER_PRINT(
 80044c6: 2303         	movs	r3, #0x3
 80044c8: 2b02         	cmp	r3, #0x2
 80044ca: d91d         	bls	0x8004508 <thread_analyze_cb+0xb0> @ imm = #0x3a
 80044cc: 2301         	movs	r3, #0x1
 80044ce: f887 3067    	strb.w	r3, [r7, #0x67]
 80044d2: f897 3067    	ldrb.w	r3, [r7, #0x67]
 80044d6: f083 0301    	eor	r3, r3, #0x1
 80044da: b2db         	uxtb	r3, r3
 80044dc: 2b00         	cmp	r3, #0x0
 80044de: d113         	bne	0x8004508 <thread_analyze_cb+0xb0> @ imm = #0x26
 80044e0: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x80045cc <thread_analyze_cb+0x174>
 80044e2: 6819         	ldr	r1, [r3]
 80044e4: 6ebb         	ldr	r3, [r7, #0x68]
 80044e6: 9304         	str	r3, [sp, #0x10]
 80044e8: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80044ec: 9303         	str	r3, [sp, #0xc]
 80044ee: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x80045d0 <thread_analyze_cb+0x178>
 80044f0: 9302         	str	r3, [sp, #0x8]
 80044f2: 2300         	movs	r3, #0x0
 80044f4: 9301         	str	r3, [sp, #0x4]
 80044f6: 2300         	movs	r3, #0x0
 80044f8: 9300         	str	r3, [sp]
 80044fa: 2300         	movs	r3, #0x0
 80044fc: 2203         	movs	r2, #0x3
 80044fe: 2000         	movs	r0, #0x0
 8004500: f018 f898    	bl	0x801c634 <z_log_msg_runtime_create> @ imm = #0x18130
 8004504: 2300         	movs	r3, #0x0
 8004506: 663b         	str	r3, [r7, #0x60]
; 		unused = 0;
 8004508: 2300         	movs	r3, #0x0
 800450a: 613b         	str	r3, [r7, #0x10]
; 	info.name = name;
 800450c: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004510: 623b         	str	r3, [r7, #0x20]
; 	info.stack_size = size;
 8004512: 6fbb         	ldr	r3, [r7, #0x78]
 8004514: 627b         	str	r3, [r7, #0x24]
; 	info.stack_used = size - unused;
 8004516: 693b         	ldr	r3, [r7, #0x10]
 8004518: 6fba         	ldr	r2, [r7, #0x78]
 800451a: 1ad3         	subs	r3, r2, r3
 800451c: 62bb         	str	r3, [r7, #0x28]
; 	ret = 0;
 800451e: 2300         	movs	r3, #0x0
 8004520: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	if (k_thread_runtime_stats_get(thread, &info.usage) != 0) {
 8004524: f107 0320    	add.w	r3, r7, #0x20
 8004528: 3310         	adds	r3, #0x10
 800452a: 4619         	mov	r1, r3
 800452c: 6ff8         	ldr	r0, [r7, #0x7c]
 800452e: f023 fe0c    	bl	0x802814a <k_thread_runtime_stats_get> @ imm = #0x23c18
 8004532: 4603         	mov	r3, r0
 8004534: 2b00         	cmp	r3, #0x0
 8004536: d004         	beq	0x8004542 <thread_analyze_cb+0xea> @ imm = #0x8
; 		ret++;
 8004538: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800453c: 3301         	adds	r3, #0x1
 800453e: f8c7 3084    	str.w	r3, [r7, #0x84]
; 		if (k_thread_runtime_stats_all_get(&rt_stats_all) != 0) {
 8004542: f107 0348    	add.w	r3, r7, #0x48
 8004546: 4618         	mov	r0, r3
 8004548: f023 fe16    	bl	0x8028178 <k_thread_runtime_stats_all_get> @ imm = #0x23c2c
 800454c: 4603         	mov	r3, r0
 800454e: 2b00         	cmp	r3, #0x0
 8004550: d004         	beq	0x800455c <thread_analyze_cb+0x104> @ imm = #0x8
; 			ret++;
 8004552: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8004556: 3301         	adds	r3, #0x1
 8004558: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	if (ret == 0) {
 800455c: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8004560: 2b00         	cmp	r3, #0x0
 8004562: d126         	bne	0x80045b2 <thread_analyze_cb+0x15a> @ imm = #0x4c
; 		info.utilization = (info.usage.execution_cycles * 100U) /
 8004564: e9d7 010c    	ldrd	r0, r1, [r7, #48]
 8004568: 4602         	mov	r2, r0
 800456a: 460b         	mov	r3, r1
 800456c: 1896         	adds	r6, r2, r2
 800456e: 603e         	str	r6, [r7]
 8004570: 415b         	adcs	r3, r3
 8004572: 607b         	str	r3, [r7, #0x4]
 8004574: e9d7 2300    	ldrd	r2, r3, [r7]
 8004578: 1814         	adds	r4, r2, r0
 800457a: eb43 0501    	adc.w	r5, r3, r1
 800457e: f04f 0200    	mov.w	r2, #0x0
 8004582: f04f 0300    	mov.w	r3, #0x0
 8004586: 016b         	lsls	r3, r5, #0x5
 8004588: ea43 63d4    	orr.w	r3, r3, r4, lsr #27
 800458c: 0162         	lsls	r2, r4, #0x5
 800458e: eb14 0802    	adds.w	r8, r4, r2
 8004592: eb45 0903    	adc.w	r9, r5, r3
 8004596: eb18 0a00    	adds.w	r10, r8, r0
 800459a: eb49 0b01    	adc.w	r11, r9, r1
; 			rt_stats_all.execution_cycles;
 800459e: e9d7 2312    	ldrd	r2, r3, [r7, #72]
; 		info.utilization = (info.usage.execution_cycles * 100U) /
 80045a2: 4650         	mov	r0, r10
 80045a4: 4659         	mov	r1, r11
 80045a6: f7fb fee3    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x423a
 80045aa: 4602         	mov	r2, r0
 80045ac: 460b         	mov	r3, r1
 80045ae: 4613         	mov	r3, r2
 80045b0: 62fb         	str	r3, [r7, #0x2c]
; 	cb(&info);
 80045b2: f107 0220    	add.w	r2, r7, #0x20
 80045b6: 6f3b         	ldr	r3, [r7, #0x70]
 80045b8: 4610         	mov	r0, r2
 80045ba: 4798         	blx	r3
; }
 80045bc: bf00         	nop
 80045be: 378c         	adds	r7, #0x8c
 80045c0: 46bd         	mov	sp, r7
 80045c2: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80045c6: bf00         	nop

080045c8 <$d>:
 80045c8: 04 a4 02 08  	.word	0x0802a404
 80045cc: 50 06 00 24  	.word	0x24000650
 80045d0: 08 a4 02 08  	.word	0x0802a408

080045d4 <isr_stack>:
; {
 80045d4: b590         	push	{r4, r7, lr}
 80045d6: b093         	sub	sp, #0x4c
 80045d8: af0a         	add	r7, sp, #0x28
 80045da: 6078         	str	r0, [r7, #0x4]
; 	const uint8_t *buf = K_KERNEL_STACK_BUFFER(z_interrupt_stacks[core]);
 80045dc: 687b         	ldr	r3, [r7, #0x4]
 80045de: 02db         	lsls	r3, r3, #0xb
 80045e0: 4a24         	ldr	r2, [pc, #0x90]         @ 0x8004674 <isr_stack+0xa0>
 80045e2: 4413         	add	r3, r2
 80045e4: 4618         	mov	r0, r3
 80045e6: f018 f80c    	bl	0x801c602 <K_KERNEL_STACK_BUFFER> @ imm = #0x18018
 80045ea: 6138         	str	r0, [r7, #0x10]
; 	size_t size = K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[core]);
 80045ec: f44f 6300    	mov.w	r3, #0x800
 80045f0: 60fb         	str	r3, [r7, #0xc]
; 	err = z_stack_space_get(buf, size, &unused);
 80045f2: f107 0308    	add.w	r3, r7, #0x8
 80045f6: 461a         	mov	r2, r3
 80045f8: 68f9         	ldr	r1, [r7, #0xc]
 80045fa: 6938         	ldr	r0, [r7, #0x10]
 80045fc: f023 fd5e    	bl	0x80280bc <z_stack_space_get> @ imm = #0x23abc
 8004600: 61f8         	str	r0, [r7, #0x1c]
; 	if (err == 0) {
 8004602: 69fb         	ldr	r3, [r7, #0x1c]
 8004604: 2b00         	cmp	r3, #0x0
 8004606: d131         	bne	0x800466c <isr_stack+0x98> @ imm = #0x62
; 		THREAD_ANALYZER_PRINT(
 8004608: 2303         	movs	r3, #0x3
 800460a: 2b02         	cmp	r3, #0x2
 800460c: d92e         	bls	0x800466c <isr_stack+0x98> @ imm = #0x5c
 800460e: 2301         	movs	r3, #0x1
 8004610: 76fb         	strb	r3, [r7, #0x1b]
 8004612: 7efb         	ldrb	r3, [r7, #0x1b]
 8004614: f083 0301    	eor	r3, r3, #0x1
 8004618: b2db         	uxtb	r3, r3
 800461a: 2b00         	cmp	r3, #0x0
 800461c: d126         	bne	0x800466c <isr_stack+0x98> @ imm = #0x4c
 800461e: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8004678 <isr_stack+0xa4>
 8004620: 681c         	ldr	r4, [r3]
 8004622: 68bb         	ldr	r3, [r7, #0x8]
 8004624: 68ba         	ldr	r2, [r7, #0x8]
 8004626: 68f9         	ldr	r1, [r7, #0xc]
 8004628: 1a8a         	subs	r2, r1, r2
 800462a: 68b9         	ldr	r1, [r7, #0x8]
 800462c: 68f8         	ldr	r0, [r7, #0xc]
 800462e: 1a41         	subs	r1, r0, r1
 8004630: 2064         	movs	r0, #0x64
 8004632: fb01 f000    	mul	r0, r1, r0
 8004636: 68f9         	ldr	r1, [r7, #0xc]
 8004638: fbb0 f1f1    	udiv	r1, r0, r1
 800463c: 9108         	str	r1, [sp, #0x20]
 800463e: 68f9         	ldr	r1, [r7, #0xc]
 8004640: 9107         	str	r1, [sp, #0x1c]
 8004642: 9206         	str	r2, [sp, #0x18]
 8004644: 9305         	str	r3, [sp, #0x14]
 8004646: 687b         	ldr	r3, [r7, #0x4]
 8004648: 9304         	str	r3, [sp, #0x10]
 800464a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800467c <isr_stack+0xa8>
 800464c: 9303         	str	r3, [sp, #0xc]
 800464e: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004680 <isr_stack+0xac>
 8004650: 9302         	str	r3, [sp, #0x8]
 8004652: 2300         	movs	r3, #0x0
 8004654: 9301         	str	r3, [sp, #0x4]
 8004656: 2300         	movs	r3, #0x0
 8004658: 9300         	str	r3, [sp]
 800465a: 2300         	movs	r3, #0x0
 800465c: 2203         	movs	r2, #0x3
 800465e: 4621         	mov	r1, r4
 8004660: 2000         	movs	r0, #0x0
 8004662: f017 ffe7    	bl	0x801c634 <z_log_msg_runtime_create> @ imm = #0x17fce
 8004666: 2300         	movs	r3, #0x0
 8004668: 617b         	str	r3, [r7, #0x14]
; }
 800466a: e7ff         	b	0x800466c <isr_stack+0x98> @ imm = #-0x2
 800466c: bf00         	nop
 800466e: 3724         	adds	r7, #0x24
 8004670: 46bd         	mov	sp, r7
 8004672: bd90         	pop	{r4, r7, pc}

08004674 <$d>:
 8004674: 38 57 00 24  	.word	0x24005738
 8004678: 50 06 00 24  	.word	0x24000650
 800467c: 30 a4 02 08  	.word	0x0802a430
 8004680: 34 a4 02 08  	.word	0x0802a434

08004684 <thread_analyzer_run>:
; {
 8004684: b580         	push	{r7, lr}
 8004686: b084         	sub	sp, #0x10
 8004688: af00         	add	r7, sp, #0x0
 800468a: 6078         	str	r0, [r7, #0x4]
 800468c: 6039         	str	r1, [r7]
; 	struct ta_cb_user_data ud = { .cb = cb, .cpu = cpu };
 800468e: 687b         	ldr	r3, [r7, #0x4]
 8004690: 60bb         	str	r3, [r7, #0x8]
 8004692: 683b         	ldr	r3, [r7]
 8004694: 60fb         	str	r3, [r7, #0xc]
; 			k_thread_foreach_unlocked(thread_analyze_cb, &ud);
 8004696: f107 0308    	add.w	r3, r7, #0x8
 800469a: 4619         	mov	r1, r3
 800469c: 4804         	ldr	r0, [pc, #0x10]         @ 0x80046b0 <thread_analyzer_run+0x2c>
 800469e: f013 fc39    	bl	0x8017f14 <k_thread_foreach_unlocked> @ imm = #0x13872
; 			isr_stacks();
 80046a2: f017 ffe5    	bl	0x801c670 <isr_stacks>  @ imm = #0x17fca
; }
 80046a6: bf00         	nop
 80046a8: 3710         	adds	r7, #0x10
 80046aa: 46bd         	mov	sp, r7
 80046ac: bd80         	pop	{r7, pc}
 80046ae: bf00         	nop

080046b0 <$d>:
 80046b0: 59 44 00 08  	.word	0x08004459

080046b4 <thread_analyzer_print>:
; {
 80046b4: b580         	push	{r7, lr}
 80046b6: b088         	sub	sp, #0x20
 80046b8: af04         	add	r7, sp, #0x10
 80046ba: 6078         	str	r0, [r7, #0x4]
; 	THREAD_ANALYZER_PRINT(THREAD_ANALYZER_FMT("Thread analyze:"));
 80046bc: 2303         	movs	r3, #0x3
 80046be: 2b02         	cmp	r3, #0x2
 80046c0: d916         	bls	0x80046f0 <thread_analyzer_print+0x3c> @ imm = #0x2c
 80046c2: 2301         	movs	r3, #0x1
 80046c4: 73fb         	strb	r3, [r7, #0xf]
 80046c6: 7bfb         	ldrb	r3, [r7, #0xf]
 80046c8: f083 0301    	eor	r3, r3, #0x1
 80046cc: b2db         	uxtb	r3, r3
 80046ce: 2b00         	cmp	r3, #0x0
 80046d0: d10e         	bne	0x80046f0 <thread_analyzer_print+0x3c> @ imm = #0x1c
 80046d2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8004700 <thread_analyzer_print+0x4c>
 80046d4: 6819         	ldr	r1, [r3]
 80046d6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8004704 <thread_analyzer_print+0x50>
 80046d8: 9302         	str	r3, [sp, #0x8]
 80046da: 2300         	movs	r3, #0x0
 80046dc: 9301         	str	r3, [sp, #0x4]
 80046de: 2300         	movs	r3, #0x0
 80046e0: 9300         	str	r3, [sp]
 80046e2: 2300         	movs	r3, #0x0
 80046e4: 2203         	movs	r2, #0x3
 80046e6: 2000         	movs	r0, #0x0
 80046e8: f017 ffa4    	bl	0x801c634 <z_log_msg_runtime_create> @ imm = #0x17f48
 80046ec: 2300         	movs	r3, #0x0
 80046ee: 60bb         	str	r3, [r7, #0x8]
; 	thread_analyzer_run(thread_print_cb, cpu);
 80046f0: 6879         	ldr	r1, [r7, #0x4]
 80046f2: 4805         	ldr	r0, [pc, #0x14]         @ 0x8004708 <thread_analyzer_print+0x54>
 80046f4: f7ff ffc6    	bl	0x8004684 <thread_analyzer_run> @ imm = #-0x74
; }
 80046f8: bf00         	nop
 80046fa: 3710         	adds	r7, #0x10
 80046fc: 46bd         	mov	sp, r7
 80046fe: bd80         	pop	{r7, pc}

08004700 <$d>:
 8004700: 50 06 00 24  	.word	0x24000650
 8004704: 6c a4 02 08  	.word	0x0802a46c
 8004708: 81 43 00 08  	.word	0x08004381

0800470c <log_backend_get>:
; {
 800470c: b480         	push	{r7}
 800470e: b085         	sub	sp, #0x14
 8004710: af00         	add	r7, sp, #0x0
 8004712: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 8004714: 687b         	ldr	r3, [r7, #0x4]
 8004716: 011b         	lsls	r3, r3, #0x4
 8004718: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800472c <log_backend_get+0x20>
 800471a: 4413         	add	r3, r2
 800471c: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 800471e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8004720: 4618         	mov	r0, r3
 8004722: 3714         	adds	r7, #0x14
 8004724: 46bd         	mov	sp, r7
 8004726: f85d 7b04    	ldr	r7, [sp], #4
 800472a: 4770         	bx	lr

0800472c <$d>:
 800472c: 50 a2 02 08  	.word	0x0802a250

08004730 <log_format_func_t_get>:
; {
 8004730: b480         	push	{r7}
 8004732: b083         	sub	sp, #0xc
 8004734: af00         	add	r7, sp, #0x0
 8004736: 6078         	str	r0, [r7, #0x4]
; 	return format_table[log_type];
 8004738: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800474c <log_format_func_t_get+0x1c>
 800473a: 687b         	ldr	r3, [r7, #0x4]
 800473c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 8004740: 4618         	mov	r0, r3
 8004742: 370c         	adds	r7, #0xc
 8004744: 46bd         	mov	sp, r7
 8004746: f85d 7b04    	ldr	r7, [sp], #4
 800474a: 4770         	bx	lr

0800474c <$d>:
 800474c: ac cd 02 08  	.word	0x0802cdac

08004750 <log_core_init>:
; {
 8004750: b580         	push	{r7, lr}
 8004752: af00         	add	r7, sp, #0x0
; 	panic_mode = false;
 8004754: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8004774 <log_core_init+0x24>
 8004756: 2200         	movs	r2, #0x0
 8004758: 701a         	strb	r2, [r3]
; 	dropped_cnt = 0;
 800475a: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8004778 <log_core_init+0x28>
 800475c: 2200         	movs	r2, #0x0
 800475e: 601a         	str	r2, [r3]
; 	buffered_cnt = 0;
 8004760: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800477c <log_core_init+0x2c>
 8004762: 2200         	movs	r2, #0x0
 8004764: 601a         	str	r2, [r3]
; 		log_set_timestamp_func(default_lf_get_timestamp, 1000U);
 8004766: f44f 717a    	mov.w	r1, #0x3e8
 800476a: 4805         	ldr	r0, [pc, #0x14]         @ 0x8004780 <log_core_init+0x30>
 800476c: f000 f86a    	bl	0x8004844 <log_set_timestamp_func> @ imm = #0xd4
; }
 8004770: bd80         	pop	{r7, pc}
 8004772: bf00         	nop

08004774 <$d>:
 8004774: f0 32 00 24  	.word	0x240032f0
 8004778: 00 28 00 24  	.word	0x24002800
 800477c: fc 27 00 24  	.word	0x240027fc
 8004780: f9 c8 01 08  	.word	0x0801c8f9

08004784 <z_log_init>:
; {
 8004784: b580         	push	{r7, lr}
 8004786: b086         	sub	sp, #0x18
 8004788: af00         	add	r7, sp, #0x0
 800478a: 4603         	mov	r3, r0
 800478c: 460a         	mov	r2, r1
 800478e: 71fb         	strb	r3, [r7, #0x7]
 8004790: 4613         	mov	r3, r2
 8004792: 71bb         	strb	r3, [r7, #0x6]
; 	uint32_t mask = 0;
 8004794: 2300         	movs	r3, #0x0
 8004796: 617b         	str	r3, [r7, #0x14]
; 	if (atomic_inc(&initialized) != 0) {
 8004798: 4827         	ldr	r0, [pc, #0x9c]         @ 0x8004838 <z_log_init+0xb4>
 800479a: f017 ffb2    	bl	0x801c702 <atomic_inc>  @ imm = #0x17f64
 800479e: 4603         	mov	r3, r0
 80047a0: 2b00         	cmp	r3, #0x0
 80047a2: d001         	beq	0x80047a8 <z_log_init+0x24> @ imm = #0x2
; 		return 0;
 80047a4: 2300         	movs	r3, #0x0
 80047a6: e042         	b	0x800482e <z_log_init+0xaa> @ imm = #0x84
; 	int backend_index = 0;
 80047a8: 2300         	movs	r3, #0x0
 80047aa: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80047ac: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800483c <z_log_init+0xb8>
 80047ae: 60fb         	str	r3, [r7, #0xc]
 80047b0: e022         	b	0x80047f8 <z_log_init+0x74> @ imm = #0x44
; 		if (backend->autostart) {
 80047b2: 68fb         	ldr	r3, [r7, #0xc]
 80047b4: 7b1b         	ldrb	r3, [r3, #0xc]
 80047b6: 2b00         	cmp	r3, #0x0
 80047b8: d018         	beq	0x80047ec <z_log_init+0x68> @ imm = #0x30
; 			log_backend_init(backend);
 80047ba: 68f8         	ldr	r0, [r7, #0xc]
 80047bc: f018 f82e    	bl	0x801c81c <log_backend_init> @ imm = #0x1805c
; 			if (log_backend_is_ready(backend) == 0) {
 80047c0: 68f8         	ldr	r0, [r7, #0xc]
 80047c2: f018 f83d    	bl	0x801c840 <log_backend_is_ready> @ imm = #0x1807a
 80047c6: 4603         	mov	r3, r0
 80047c8: 2b00         	cmp	r3, #0x0
 80047ca: d108         	bne	0x80047de <z_log_init+0x5a> @ imm = #0x10
; 						   backend->cb->ctx,
 80047cc: 68fb         	ldr	r3, [r7, #0xc]
 80047ce: 685b         	ldr	r3, [r3, #0x4]
; 				log_backend_enable(backend,
 80047d0: 681b         	ldr	r3, [r3]
 80047d2: 2204         	movs	r2, #0x4
 80047d4: 4619         	mov	r1, r3
 80047d6: 68f8         	ldr	r0, [r7, #0xc]
 80047d8: f018 f996    	bl	0x801cb08 <log_backend_enable> @ imm = #0x1832c
 80047dc: e006         	b	0x80047ec <z_log_init+0x68> @ imm = #0xc
; 				mask |= BIT(backend_index);
 80047de: 2201         	movs	r2, #0x1
 80047e0: 693b         	ldr	r3, [r7, #0x10]
 80047e2: fa02 f303    	lsl.w	r3, r2, r3
 80047e6: 697a         	ldr	r2, [r7, #0x14]
 80047e8: 4313         	orrs	r3, r2
 80047ea: 617b         	str	r3, [r7, #0x14]
; 		++backend_index;
 80047ec: 693b         	ldr	r3, [r7, #0x10]
 80047ee: 3301         	adds	r3, #0x1
 80047f0: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80047f2: 68fb         	ldr	r3, [r7, #0xc]
 80047f4: 3310         	adds	r3, #0x10
 80047f6: 60fb         	str	r3, [r7, #0xc]
 80047f8: 68fb         	ldr	r3, [r7, #0xc]
 80047fa: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8004840 <z_log_init+0xbc>
 80047fc: 4293         	cmp	r3, r2
 80047fe: bf34         	ite	lo
 8004800: 2301         	movlo	r3, #0x1
 8004802: 2300         	movhs	r3, #0x0
 8004804: b2db         	uxtb	r3, r3
 8004806: 2b00         	cmp	r3, #0x0
 8004808: d1d3         	bne	0x80047b2 <z_log_init+0x2e> @ imm = #-0x5a
; 	if (blocking) {
 800480a: 79fb         	ldrb	r3, [r7, #0x7]
 800480c: 2b00         	cmp	r3, #0x0
 800480e: d00d         	beq	0x800482c <z_log_init+0xa8> @ imm = #0x1a
; 		while (mask) {
 8004810: e009         	b	0x8004826 <z_log_init+0xa2> @ imm = #0x12
; 			mask = activate_foreach_backend(mask);
 8004812: 6978         	ldr	r0, [r7, #0x14]
 8004814: f018 f877    	bl	0x801c906 <activate_foreach_backend> @ imm = #0x180ee
 8004818: 6178         	str	r0, [r7, #0x14]
; 			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
 800481a: 79bb         	ldrb	r3, [r7, #0x6]
 800481c: 2b00         	cmp	r3, #0x0
 800481e: d002         	beq	0x8004826 <z_log_init+0xa2> @ imm = #0x4
; 				k_msleep(10);
 8004820: 200a         	movs	r0, #0xa
 8004822: f017 ff9c    	bl	0x801c75e <k_msleep>    @ imm = #0x17f38
; 		while (mask) {
 8004826: 697b         	ldr	r3, [r7, #0x14]
 8004828: 2b00         	cmp	r3, #0x0
 800482a: d1f2         	bne	0x8004812 <z_log_init+0x8e> @ imm = #-0x1c
; 	return mask;
 800482c: 697b         	ldr	r3, [r7, #0x14]
; }
 800482e: 4618         	mov	r0, r3
 8004830: 3718         	adds	r7, #0x18
 8004832: 46bd         	mov	sp, r7
 8004834: bd80         	pop	{r7, pc}
 8004836: bf00         	nop

08004838 <$d>:
 8004838: f8 27 00 24  	.word	0x240027f8
 800483c: 50 a2 02 08  	.word	0x0802a250
 8004840: 60 a2 02 08  	.word	0x0802a260

08004844 <log_set_timestamp_func>:
; {
 8004844: b580         	push	{r7, lr}
 8004846: b082         	sub	sp, #0x8
 8004848: af00         	add	r7, sp, #0x0
 800484a: 6078         	str	r0, [r7, #0x4]
 800484c: 6039         	str	r1, [r7]
; 	if (timestamp_getter == NULL) {
 800484e: 687b         	ldr	r3, [r7, #0x4]
 8004850: 2b00         	cmp	r3, #0x0
 8004852: d102         	bne	0x800485a <log_set_timestamp_func+0x16> @ imm = #0x4
; 		return -EINVAL;
 8004854: f06f 0315    	mvn	r3, #0x15
 8004858: e009         	b	0x800486e <log_set_timestamp_func+0x2a> @ imm = #0x12
; 	timestamp_func = timestamp_getter;
 800485a: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8004878 <log_set_timestamp_func+0x34>
 800485c: 687b         	ldr	r3, [r7, #0x4]
 800485e: 6013         	str	r3, [r2]
; 	timestamp_freq = freq;
 8004860: 4a06         	ldr	r2, [pc, #0x18]         @ 0x800487c <log_set_timestamp_func+0x38>
 8004862: 683b         	ldr	r3, [r7]
 8004864: 6013         	str	r3, [r2]
; 		log_output_timestamp_freq_set(freq);
 8004866: 6838         	ldr	r0, [r7]
 8004868: f000 fcec    	bl	0x8005244 <log_output_timestamp_freq_set> @ imm = #0x9d8
; 	return 0;
 800486c: 2300         	movs	r3, #0x0
; }
 800486e: 4618         	mov	r0, r3
 8004870: 3708         	adds	r7, #0x8
 8004872: 46bd         	mov	sp, r7
 8004874: bd80         	pop	{r7, pc}
 8004876: bf00         	nop

08004878 <$d>:
 8004878: 54 06 00 24  	.word	0x24000654
 800487c: 04 28 00 24  	.word	0x24002804

08004880 <z_impl_log_panic>:
; {
 8004880: b580         	push	{r7, lr}
 8004882: b082         	sub	sp, #0x8
 8004884: af00         	add	r7, sp, #0x0
; 	if (panic_mode) {
 8004886: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80048d8 <z_impl_log_panic+0x58>
 8004888: 781b         	ldrb	r3, [r3]
 800488a: 2b00         	cmp	r3, #0x0
 800488c: d120         	bne	0x80048d0 <z_impl_log_panic+0x50> @ imm = #0x40
; 	(void)z_log_init(true, false);
 800488e: 2100         	movs	r1, #0x0
 8004890: 2001         	movs	r0, #0x1
 8004892: f7ff ff77    	bl	0x8004784 <z_log_init>  @ imm = #-0x112
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8004896: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80048dc <z_impl_log_panic+0x5c>
 8004898: 607b         	str	r3, [r7, #0x4]
 800489a: e00b         	b	0x80048b4 <z_impl_log_panic+0x34> @ imm = #0x16
; 		if (log_backend_is_active(backend)) {
 800489c: 6878         	ldr	r0, [r7, #0x4]
 800489e: f018 f800    	bl	0x801c8a2 <log_backend_is_active> @ imm = #0x18000
 80048a2: 4603         	mov	r3, r0
 80048a4: 2b00         	cmp	r3, #0x0
 80048a6: d002         	beq	0x80048ae <z_impl_log_panic+0x2e> @ imm = #0x4
; 			log_backend_panic(backend);
 80048a8: 6878         	ldr	r0, [r7, #0x4]
 80048aa: f017 ffed    	bl	0x801c888 <log_backend_panic> @ imm = #0x17fda
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80048ae: 687b         	ldr	r3, [r7, #0x4]
 80048b0: 3310         	adds	r3, #0x10
 80048b2: 607b         	str	r3, [r7, #0x4]
 80048b4: 687b         	ldr	r3, [r7, #0x4]
 80048b6: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80048e0 <z_impl_log_panic+0x60>
 80048b8: 4293         	cmp	r3, r2
 80048ba: bf34         	ite	lo
 80048bc: 2301         	movlo	r3, #0x1
 80048be: 2300         	movhs	r3, #0x0
 80048c0: b2db         	uxtb	r3, r3
 80048c2: 2b00         	cmp	r3, #0x0
 80048c4: d1ea         	bne	0x800489c <z_impl_log_panic+0x1c> @ imm = #-0x2c
; out:
 80048c6: bf00         	nop
; 	panic_mode = true;
 80048c8: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80048d8 <z_impl_log_panic+0x58>
 80048ca: 2201         	movs	r2, #0x1
 80048cc: 701a         	strb	r2, [r3]
 80048ce: e000         	b	0x80048d2 <z_impl_log_panic+0x52> @ imm = #0x0
; 		return;
 80048d0: bf00         	nop
; }
 80048d2: 3708         	adds	r7, #0x8
 80048d4: 46bd         	mov	sp, r7
 80048d6: bd80         	pop	{r7, pc}

080048d8 <$d>:
 80048d8: f0 32 00 24  	.word	0x240032f0
 80048dc: 50 a2 02 08  	.word	0x0802a250
 80048e0: 60 a2 02 08  	.word	0x0802a260

080048e4 <msg_process>:
; {
 80048e4: b580         	push	{r7, lr}
 80048e6: b084         	sub	sp, #0x10
 80048e8: af00         	add	r7, sp, #0x0
 80048ea: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80048ec: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8004938 <msg_process+0x54>
 80048ee: 60fb         	str	r3, [r7, #0xc]
 80048f0: e013         	b	0x800491a <msg_process+0x36> @ imm = #0x26
; 		if (log_backend_is_active(backend) &&
 80048f2: 68f8         	ldr	r0, [r7, #0xc]
 80048f4: f017 ffd5    	bl	0x801c8a2 <log_backend_is_active> @ imm = #0x17faa
 80048f8: 4603         	mov	r3, r0
 80048fa: 2b00         	cmp	r3, #0x0
 80048fc: d00a         	beq	0x8004914 <msg_process+0x30> @ imm = #0x14
; 		    msg_filter_check(backend, msg)) {
 80048fe: 6879         	ldr	r1, [r7, #0x4]
 8004900: 68f8         	ldr	r0, [r7, #0xc]
 8004902: f018 f83b    	bl	0x801c97c <msg_filter_check> @ imm = #0x18076
 8004906: 4603         	mov	r3, r0
; 		if (log_backend_is_active(backend) &&
 8004908: 2b00         	cmp	r3, #0x0
 800490a: d003         	beq	0x8004914 <msg_process+0x30> @ imm = #0x6
; 			log_backend_msg_process(backend, msg);
 800490c: 6879         	ldr	r1, [r7, #0x4]
 800490e: 68f8         	ldr	r0, [r7, #0xc]
 8004910: f017 ffab    	bl	0x801c86a <log_backend_msg_process> @ imm = #0x17f56
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8004914: 68fb         	ldr	r3, [r7, #0xc]
 8004916: 3310         	adds	r3, #0x10
 8004918: 60fb         	str	r3, [r7, #0xc]
 800491a: 68fb         	ldr	r3, [r7, #0xc]
 800491c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800493c <msg_process+0x58>
 800491e: 4293         	cmp	r3, r2
 8004920: bf34         	ite	lo
 8004922: 2301         	movlo	r3, #0x1
 8004924: 2300         	movhs	r3, #0x0
 8004926: b2db         	uxtb	r3, r3
 8004928: 2b00         	cmp	r3, #0x0
 800492a: d1e2         	bne	0x80048f2 <msg_process+0xe> @ imm = #-0x3c
; }
 800492c: bf00         	nop
 800492e: bf00         	nop
 8004930: 3710         	adds	r7, #0x10
 8004932: 46bd         	mov	sp, r7
 8004934: bd80         	pop	{r7, pc}
 8004936: bf00         	nop

08004938 <$d>:
 8004938: 50 a2 02 08  	.word	0x0802a250
 800493c: 60 a2 02 08  	.word	0x0802a260

08004940 <z_log_notify_backend_enabled>:
; {
 8004940: b480         	push	{r7}
 8004942: af00         	add	r7, sp, #0x0
; 	backend_attached = true;
 8004944: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8004954 <z_log_notify_backend_enabled+0x14>
 8004946: 2201         	movs	r2, #0x1
 8004948: 701a         	strb	r2, [r3]
; }
 800494a: bf00         	nop
 800494c: 46bd         	mov	sp, r7
 800494e: f85d 7b04    	ldr	r7, [sp], #4
 8004952: 4770         	bx	lr

08004954 <$d>:
 8004954: f1 32 00 24  	.word	0x240032f1

08004958 <z_log_dropped>:
; {
 8004958: b580         	push	{r7, lr}
 800495a: b082         	sub	sp, #0x8
 800495c: af00         	add	r7, sp, #0x0
 800495e: 4603         	mov	r3, r0
 8004960: 71fb         	strb	r3, [r7, #0x7]
; 	atomic_inc(&dropped_cnt);
 8004962: 4806         	ldr	r0, [pc, #0x18]         @ 0x800497c <z_log_dropped+0x24>
 8004964: f017 fecd    	bl	0x801c702 <atomic_inc>  @ imm = #0x17d9a
; 	if (buffered) {
 8004968: 79fb         	ldrb	r3, [r7, #0x7]
 800496a: 2b00         	cmp	r3, #0x0
 800496c: d002         	beq	0x8004974 <z_log_dropped+0x1c> @ imm = #0x4
; 		atomic_dec(&buffered_cnt);
 800496e: 4804         	ldr	r0, [pc, #0x10]         @ 0x8004980 <z_log_dropped+0x28>
 8004970: f017 fed4    	bl	0x801c71c <atomic_dec>  @ imm = #0x17da8
; }
 8004974: bf00         	nop
 8004976: 3708         	adds	r7, #0x8
 8004978: 46bd         	mov	sp, r7
 800497a: bd80         	pop	{r7, pc}

0800497c <$d>:
 800497c: 00 28 00 24  	.word	0x24002800
 8004980: fc 27 00 24  	.word	0x240027fc

08004984 <z_log_msg_commit>:
; {
 8004984: b580         	push	{r7, lr}
 8004986: b082         	sub	sp, #0x8
 8004988: af00         	add	r7, sp, #0x0
 800498a: 6078         	str	r0, [r7, #0x4]
; 	msg->hdr.timestamp = timestamp_func();
 800498c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80049a8 <z_log_msg_commit+0x24>
 800498e: 681b         	ldr	r3, [r3]
 8004990: 4798         	blx	r3
 8004992: 4602         	mov	r2, r0
 8004994: 687b         	ldr	r3, [r7, #0x4]
 8004996: 609a         	str	r2, [r3, #0x8]
; 	msg_commit(&log_buffer, msg);
 8004998: 6879         	ldr	r1, [r7, #0x4]
 800499a: 4804         	ldr	r0, [pc, #0x10]         @ 0x80049ac <z_log_msg_commit+0x28>
 800499c: f018 f803    	bl	0x801c9a6 <msg_commit>  @ imm = #0x18006
; }
 80049a0: bf00         	nop
 80049a2: 3708         	adds	r7, #0x8
 80049a4: 46bd         	mov	sp, r7
 80049a6: bd80         	pop	{r7, pc}

080049a8 <$d>:
 80049a8: 54 06 00 24  	.word	0x24000654
 80049ac: e4 0b 00 24  	.word	0x24000be4

080049b0 <log_const_source_id>:
; {
 80049b0: b480         	push	{r7}
 80049b2: b083         	sub	sp, #0xc
 80049b4: af00         	add	r7, sp, #0x0
 80049b6: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 80049b8: 687b         	ldr	r3, [r7, #0x4]
 80049ba: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80049cc <log_const_source_id+0x1c>
 80049bc: 1a9b         	subs	r3, r3, r2
 80049be: 08db         	lsrs	r3, r3, #0x3
; }
 80049c0: 4618         	mov	r0, r3
 80049c2: 370c         	adds	r7, #0xc
 80049c4: 46bd         	mov	sp, r7
 80049c6: f85d 7b04    	ldr	r7, [sp], #4
 80049ca: 4770         	bx	lr

080049cc <$d>:
 80049cc: 80 a1 02 08  	.word	0x0802a180

080049d0 <z_log_sources_count>:
; {
 80049d0: b580         	push	{r7, lr}
 80049d2: af00         	add	r7, sp, #0x0
; 	return log_const_source_id(TYPE_SECTION_END(log_const));
 80049d4: 4802         	ldr	r0, [pc, #0x8]          @ 0x80049e0 <z_log_sources_count+0x10>
 80049d6: f7ff ffeb    	bl	0x80049b0 <log_const_source_id> @ imm = #-0x2a
 80049da: 4603         	mov	r3, r0
; }
 80049dc: 4618         	mov	r0, r3
 80049de: bd80         	pop	{r7, pc}

080049e0 <$d>:
 80049e0: 50 a2 02 08  	.word	0x0802a250

080049e4 <log_backend_get>:
; {
 80049e4: b480         	push	{r7}
 80049e6: b085         	sub	sp, #0x14
 80049e8: af00         	add	r7, sp, #0x0
 80049ea: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 80049ec: 687b         	ldr	r3, [r7, #0x4]
 80049ee: 011b         	lsls	r3, r3, #0x4
 80049f0: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004a04 <log_backend_get+0x20>
 80049f2: 4413         	add	r3, r2
 80049f4: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 80049f6: 68fb         	ldr	r3, [r7, #0xc]
; }
 80049f8: 4618         	mov	r0, r3
 80049fa: 3714         	adds	r7, #0x14
 80049fc: 46bd         	mov	sp, r7
 80049fe: f85d 7b04    	ldr	r7, [sp], #4
 8004a02: 4770         	bx	lr

08004a04 <$d>:
 8004a04: 50 a2 02 08  	.word	0x0802a250

08004a08 <get_link_domain>:
; {
 8004a08: b480         	push	{r7}
 8004a0a: b085         	sub	sp, #0x14
 8004a0c: af00         	add	r7, sp, #0x0
 8004a0e: 4603         	mov	r3, r0
 8004a10: 6039         	str	r1, [r7]
 8004a12: 71fb         	strb	r3, [r7, #0x7]
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 8004a14: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8004a78 <get_link_domain+0x70>
 8004a16: 60fb         	str	r3, [r7, #0xc]
 8004a18: e01b         	b	0x8004a52 <get_link_domain+0x4a> @ imm = #0x36
; 		domain_max = link->ctrl_blk->domain_offset +
 8004a1a: 68fb         	ldr	r3, [r7, #0xc]
 8004a1c: 689b         	ldr	r3, [r3, #0x8]
 8004a1e: 689b         	ldr	r3, [r3, #0x8]
 8004a20: b2da         	uxtb	r2, r3
; 				link->ctrl_blk->domain_cnt;
 8004a22: 68fb         	ldr	r3, [r7, #0xc]
 8004a24: 689b         	ldr	r3, [r3, #0x8]
 8004a26: 681b         	ldr	r3, [r3]
; 		domain_max = link->ctrl_blk->domain_offset +
 8004a28: b2db         	uxtb	r3, r3
 8004a2a: 4413         	add	r3, r2
 8004a2c: 72fb         	strb	r3, [r7, #0xb]
; 		if (domain_id < domain_max) {
 8004a2e: 79fa         	ldrb	r2, [r7, #0x7]
 8004a30: 7afb         	ldrb	r3, [r7, #0xb]
 8004a32: 429a         	cmp	r2, r3
 8004a34: d20a         	bhs	0x8004a4c <get_link_domain+0x44> @ imm = #0x14
; 			*rel_domain_id = domain_id - link->ctrl_blk->domain_offset;
 8004a36: 68fb         	ldr	r3, [r7, #0xc]
 8004a38: 689b         	ldr	r3, [r3, #0x8]
 8004a3a: 689b         	ldr	r3, [r3, #0x8]
 8004a3c: b2db         	uxtb	r3, r3
 8004a3e: 79fa         	ldrb	r2, [r7, #0x7]
 8004a40: 1ad3         	subs	r3, r2, r3
 8004a42: b2da         	uxtb	r2, r3
 8004a44: 683b         	ldr	r3, [r7]
 8004a46: 701a         	strb	r2, [r3]
; 			return link;
 8004a48: 68fb         	ldr	r3, [r7, #0xc]
 8004a4a: e00f         	b	0x8004a6c <get_link_domain+0x64> @ imm = #0x1e
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 8004a4c: 68fb         	ldr	r3, [r7, #0xc]
 8004a4e: 3318         	adds	r3, #0x18
 8004a50: 60fb         	str	r3, [r7, #0xc]
 8004a52: 68fb         	ldr	r3, [r7, #0xc]
 8004a54: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8004a7c <get_link_domain+0x74>
 8004a56: 4293         	cmp	r3, r2
 8004a58: bf34         	ite	lo
 8004a5a: 2301         	movlo	r3, #0x1
 8004a5c: 2300         	movhs	r3, #0x0
 8004a5e: b2db         	uxtb	r3, r3
 8004a60: 2b00         	cmp	r3, #0x0
 8004a62: d1da         	bne	0x8004a1a <get_link_domain+0x12> @ imm = #-0x4c
; 	*rel_domain_id = 0;
 8004a64: 683b         	ldr	r3, [r7]
 8004a66: 2200         	movs	r2, #0x0
 8004a68: 701a         	strb	r2, [r3]
; 	return NULL;
 8004a6a: 2300         	movs	r3, #0x0
; }
 8004a6c: 4618         	mov	r0, r3
 8004a6e: 3714         	adds	r7, #0x14
 8004a70: 46bd         	mov	sp, r7
 8004a72: f85d 7b04    	ldr	r7, [sp], #4
 8004a76: 4770         	bx	lr

08004a78 <$d>:
 8004a78: 60 a2 02 08  	.word	0x0802a260
 8004a7c: 60 a2 02 08  	.word	0x0802a260

08004a80 <link_source_name_get>:
; {
 8004a80: b580         	push	{r7, lr}
 8004a82: b08a         	sub	sp, #0x28
 8004a84: af02         	add	r7, sp, #0x8
 8004a86: 4603         	mov	r3, r0
 8004a88: 6039         	str	r1, [r7]
 8004a8a: 71fb         	strb	r3, [r7, #0x7]
; 	size_t cache_size = sname_cache.item_size;
 8004a8c: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8004b00 <link_source_name_get+0x80>
 8004a8e: 69db         	ldr	r3, [r3, #0x1c]
 8004a90: 613b         	str	r3, [r7, #0x10]
; 	union log_source_ids id = {
 8004a92: 79fb         	ldrb	r3, [r7, #0x7]
 8004a94: 733b         	strb	r3, [r7, #0xc]
 8004a96: 683b         	ldr	r3, [r7]
 8004a98: b29b         	uxth	r3, r3
 8004a9a: 81fb         	strh	r3, [r7, #0xe]
; 	if (!log_cache_get(&sname_cache, id.raw, &cached)) {
 8004a9c: 68fb         	ldr	r3, [r7, #0xc]
 8004a9e: f107 0214    	add.w	r2, r7, #0x14
 8004aa2: 4619         	mov	r1, r3
 8004aa4: 4816         	ldr	r0, [pc, #0x58]         @ 0x8004b00 <link_source_name_get+0x80>
 8004aa6: f018 f96c    	bl	0x801cd82 <log_cache_get> @ imm = #0x182d8
 8004aaa: 4603         	mov	r3, r0
 8004aac: f083 0301    	eor	r3, r3, #0x1
 8004ab0: b2db         	uxtb	r3, r3
 8004ab2: 2b00         	cmp	r3, #0x0
 8004ab4: d01f         	beq	0x8004af6 <link_source_name_get+0x76> @ imm = #0x3e
; 		const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 8004ab6: f107 020b    	add.w	r2, r7, #0xb
 8004aba: 79fb         	ldrb	r3, [r7, #0x7]
 8004abc: 4611         	mov	r1, r2
 8004abe: 4618         	mov	r0, r3
 8004ac0: f7ff ffa2    	bl	0x8004a08 <get_link_domain> @ imm = #-0xbc
 8004ac4: 61f8         	str	r0, [r7, #0x1c]
; 		err = log_link_get_source_name(link, rel_domain_id, source_id,
 8004ac6: 7afb         	ldrb	r3, [r7, #0xb]
 8004ac8: 4618         	mov	r0, r3
 8004aca: 683b         	ldr	r3, [r7]
 8004acc: b29a         	uxth	r2, r3
 8004ace: 6979         	ldr	r1, [r7, #0x14]
 8004ad0: f107 0310    	add.w	r3, r7, #0x10
 8004ad4: 9300         	str	r3, [sp]
 8004ad6: 460b         	mov	r3, r1
 8004ad8: 4601         	mov	r1, r0
 8004ada: 69f8         	ldr	r0, [r7, #0x1c]
 8004adc: f017 ffc1    	bl	0x801ca62 <log_link_get_source_name> @ imm = #0x17f82
 8004ae0: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 8004ae2: 69bb         	ldr	r3, [r7, #0x18]
 8004ae4: 2b00         	cmp	r3, #0x0
 8004ae6: da01         	bge	0x8004aec <link_source_name_get+0x6c> @ imm = #0x2
; 			return NULL;
 8004ae8: 2300         	movs	r3, #0x0
 8004aea: e005         	b	0x8004af8 <link_source_name_get+0x78> @ imm = #0xa
; 		log_cache_put(&sname_cache, cached);
 8004aec: 697b         	ldr	r3, [r7, #0x14]
 8004aee: 4619         	mov	r1, r3
 8004af0: 4803         	ldr	r0, [pc, #0xc]          @ 0x8004b00 <link_source_name_get+0x80>
 8004af2: f018 f9c9    	bl	0x801ce88 <log_cache_put> @ imm = #0x18392
; 	return (const char *)cached;
 8004af6: 697b         	ldr	r3, [r7, #0x14]
; }
 8004af8: 4618         	mov	r0, r3
 8004afa: 3720         	adds	r7, #0x20
 8004afc: 46bd         	mov	sp, r7
 8004afe: bd80         	pop	{r7, pc}

08004b00 <$d>:
 8004b00: 08 28 00 24  	.word	0x24002808

08004b04 <log_source_name_get>:
; {
 8004b04: b580         	push	{r7, lr}
 8004b06: b082         	sub	sp, #0x8
 8004b08: af00         	add	r7, sp, #0x0
 8004b0a: 6078         	str	r0, [r7, #0x4]
 8004b0c: 6039         	str	r1, [r7]
; 	if (z_log_is_local_domain(domain_id)) {
 8004b0e: 687b         	ldr	r3, [r7, #0x4]
 8004b10: b2db         	uxtb	r3, r3
 8004b12: 4618         	mov	r0, r3
 8004b14: f017 ff65    	bl	0x801c9e2 <z_log_is_local_domain> @ imm = #0x17eca
 8004b18: 4603         	mov	r3, r0
 8004b1a: 2b00         	cmp	r3, #0x0
 8004b1c: d00d         	beq	0x8004b3a <log_source_name_get+0x36> @ imm = #0x1a
; 		if (source_id < log_src_cnt_get(domain_id)) {
 8004b1e: 6878         	ldr	r0, [r7, #0x4]
 8004b20: f017 ffcd    	bl	0x801cabe <log_src_cnt_get> @ imm = #0x17f9a
 8004b24: 4602         	mov	r2, r0
 8004b26: 683b         	ldr	r3, [r7]
 8004b28: 4293         	cmp	r3, r2
 8004b2a: d204         	bhs	0x8004b36 <log_source_name_get+0x32> @ imm = #0x8
; 			return TYPE_SECTION_START(log_const)[source_id].name;
 8004b2c: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8004b50 <log_source_name_get+0x4c>
 8004b2e: 683b         	ldr	r3, [r7]
 8004b30: f852 3033    	ldr.w	r3, [r2, r3, lsl #3]
 8004b34: e008         	b	0x8004b48 <log_source_name_get+0x44> @ imm = #0x10
; 			return NULL;
 8004b36: 2300         	movs	r3, #0x0
 8004b38: e006         	b	0x8004b48 <log_source_name_get+0x44> @ imm = #0xc
; 	return link_source_name_get(domain_id, source_id);
 8004b3a: 687b         	ldr	r3, [r7, #0x4]
 8004b3c: b2db         	uxtb	r3, r3
 8004b3e: 6839         	ldr	r1, [r7]
 8004b40: 4618         	mov	r0, r3
 8004b42: f7ff ff9d    	bl	0x8004a80 <link_source_name_get> @ imm = #-0xc6
 8004b46: 4603         	mov	r3, r0
; }
 8004b48: 4618         	mov	r0, r3
 8004b4a: 3708         	adds	r7, #0x8
 8004b4c: 46bd         	mov	sp, r7
 8004b4e: bd80         	pop	{r7, pc}

08004b50 <$d>:
 8004b50: 80 a1 02 08  	.word	0x0802a180

08004b54 <log_const_source_id>:
; {
 8004b54: b480         	push	{r7}
 8004b56: b083         	sub	sp, #0xc
 8004b58: af00         	add	r7, sp, #0x0
 8004b5a: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 8004b5c: 687b         	ldr	r3, [r7, #0x4]
 8004b5e: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004b70 <log_const_source_id+0x1c>
 8004b60: 1a9b         	subs	r3, r3, r2
 8004b62: 08db         	lsrs	r3, r3, #0x3
; }
 8004b64: 4618         	mov	r0, r3
 8004b66: 370c         	adds	r7, #0xc
 8004b68: 46bd         	mov	sp, r7
 8004b6a: f85d 7b04    	ldr	r7, [sp], #4
 8004b6e: 4770         	bx	lr

08004b70 <$d>:
 8004b70: 80 a1 02 08  	.word	0x0802a180

08004b74 <z_log_msg_runtime_vcreate>:
; {
 8004b74: b580         	push	{r7, lr}
 8004b76: b090         	sub	sp, #0x40
 8004b78: af04         	add	r7, sp, #0x10
 8004b7a: 60b9         	str	r1, [r7, #0x8]
 8004b7c: 607b         	str	r3, [r7, #0x4]
 8004b7e: 4603         	mov	r3, r0
 8004b80: 73fb         	strb	r3, [r7, #0xf]
 8004b82: 4613         	mov	r3, r2
 8004b84: 73bb         	strb	r3, [r7, #0xe]
; 	if (fmt) {
 8004b86: 6c3b         	ldr	r3, [r7, #0x40]
 8004b88: 2b00         	cmp	r3, #0x0
 8004b8a: d00b         	beq	0x8004ba4 <z_log_msg_runtime_vcreate+0x30> @ imm = #0x16
; 		va_copy(ap2, ap);
 8004b8c: 6c7b         	ldr	r3, [r7, #0x44]
 8004b8e: 613b         	str	r3, [r7, #0x10]
; 		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
 8004b90: 693b         	ldr	r3, [r7, #0x10]
 8004b92: 9300         	str	r3, [sp]
 8004b94: 6c3b         	ldr	r3, [r7, #0x40]
 8004b96: 6bfa         	ldr	r2, [r7, #0x3c]
 8004b98: 2110         	movs	r1, #0x10
 8004b9a: 2000         	movs	r0, #0x0
 8004b9c: f7fe ff42    	bl	0x8003a24 <cbvprintf_package> @ imm = #-0x117c
 8004ba0: 62f8         	str	r0, [r7, #0x2c]
 8004ba2: e001         	b	0x8004ba8 <z_log_msg_runtime_vcreate+0x34> @ imm = #0x2
; 		plen = 0;
 8004ba4: 2300         	movs	r3, #0x0
 8004ba6: 62fb         	str	r3, [r7, #0x2c]
; 	if (plen > Z_LOG_MSG_MAX_PACKAGE) {
 8004ba8: 6afb         	ldr	r3, [r7, #0x2c]
 8004baa: f5b3 6f00    	cmp.w	r3, #0x800
 8004bae: d31d         	blo	0x8004bec <z_log_msg_runtime_vcreate+0x78> @ imm = #0x3a
; 		LOG_WRN("Message dropped because it exceeds size limitation (%u)",
 8004bb0: 2303         	movs	r3, #0x3
 8004bb2: 2b01         	cmp	r3, #0x1
 8004bb4: d973         	bls	0x8004c9e <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xe6
 8004bb6: 2301         	movs	r3, #0x1
 8004bb8: 77fb         	strb	r3, [r7, #0x1f]
 8004bba: 7ffb         	ldrb	r3, [r7, #0x1f]
 8004bbc: f083 0301    	eor	r3, r3, #0x1
 8004bc0: b2db         	uxtb	r3, r3
 8004bc2: 2b00         	cmp	r3, #0x0
 8004bc4: d16b         	bne	0x8004c9e <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xd6
 8004bc6: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8004ca4 <z_log_msg_runtime_vcreate+0x130>
 8004bc8: 6819         	ldr	r1, [r3]
 8004bca: f240 73ff    	movw	r3, #0x7ff
 8004bce: 9303         	str	r3, [sp, #0xc]
 8004bd0: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8004ca8 <z_log_msg_runtime_vcreate+0x134>
 8004bd2: 9302         	str	r3, [sp, #0x8]
 8004bd4: 2300         	movs	r3, #0x0
 8004bd6: 9301         	str	r3, [sp, #0x4]
 8004bd8: 2300         	movs	r3, #0x0
 8004bda: 9300         	str	r3, [sp]
 8004bdc: 2300         	movs	r3, #0x0
 8004bde: 2202         	movs	r2, #0x2
 8004be0: 2000         	movs	r0, #0x0
 8004be2: f018 f963    	bl	0x801ceac <z_log_msg_runtime_create> @ imm = #0x182c6
 8004be6: 2300         	movs	r3, #0x0
 8004be8: 61bb         	str	r3, [r7, #0x18]
; 		return;
 8004bea: e058         	b	0x8004c9e <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xb0
; 	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
 8004bec: 6afa         	ldr	r2, [r7, #0x2c]
 8004bee: 6bbb         	ldr	r3, [r7, #0x38]
 8004bf0: 4413         	add	r3, r2
 8004bf2: 3317         	adds	r3, #0x17
 8004bf4: f023 0307    	bic	r3, r3, #0x7
 8004bf8: 3303         	adds	r3, #0x3
 8004bfa: 089b         	lsrs	r3, r3, #0x2
 8004bfc: 62bb         	str	r3, [r7, #0x28]
; 	struct log_msg_desc desc =
 8004bfe: 7d3b         	ldrb	r3, [r7, #0x14]
 8004c00: f36f 0300    	bfc	r3, #0, #1
 8004c04: 753b         	strb	r3, [r7, #0x14]
 8004c06: 7d3b         	ldrb	r3, [r7, #0x14]
 8004c08: f36f 0341    	bfc	r3, #1, #1
 8004c0c: 753b         	strb	r3, [r7, #0x14]
 8004c0e: 7d3b         	ldrb	r3, [r7, #0x14]
 8004c10: f36f 0382    	bfc	r3, #2, #1
 8004c14: 753b         	strb	r3, [r7, #0x14]
 8004c16: 7bfb         	ldrb	r3, [r7, #0xf]
 8004c18: f003 0307    	and	r3, r3, #0x7
 8004c1c: b2da         	uxtb	r2, r3
 8004c1e: 7d3b         	ldrb	r3, [r7, #0x14]
 8004c20: f362 03c5    	bfi	r3, r2, #3, #3
 8004c24: 753b         	strb	r3, [r7, #0x14]
 8004c26: 7bbb         	ldrb	r3, [r7, #0xe]
 8004c28: f003 0307    	and	r3, r3, #0x7
 8004c2c: b2da         	uxtb	r2, r3
 8004c2e: 8abb         	ldrh	r3, [r7, #0x14]
 8004c30: f362 1388    	bfi	r3, r2, #6, #3
 8004c34: 82bb         	strh	r3, [r7, #0x14]
 8004c36: 6afb         	ldr	r3, [r7, #0x2c]
 8004c38: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8004c3c: b29a         	uxth	r2, r3
 8004c3e: 697b         	ldr	r3, [r7, #0x14]
 8004c40: f362 2353    	bfi	r3, r2, #9, #11
 8004c44: 617b         	str	r3, [r7, #0x14]
 8004c46: 6bbb         	ldr	r3, [r7, #0x38]
 8004c48: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8004c4c: b29a         	uxth	r2, r3
 8004c4e: 8afb         	ldrh	r3, [r7, #0x16]
 8004c50: f362 130f    	bfi	r3, r2, #4, #12
 8004c54: 82fb         	strh	r3, [r7, #0x16]
; 		msg = alloca(msg_wlen * sizeof(int));
 8004c56: 6abb         	ldr	r3, [r7, #0x28]
 8004c58: 009b         	lsls	r3, r3, #0x2
 8004c5a: 3307         	adds	r3, #0x7
 8004c5c: 08db         	lsrs	r3, r3, #0x3
 8004c5e: 00db         	lsls	r3, r3, #0x3
 8004c60: ebad 0d03    	sub.w	sp, sp, r3
 8004c64: ab04         	add	r3, sp, #0x10
 8004c66: 3307         	adds	r3, #0x7
 8004c68: 08db         	lsrs	r3, r3, #0x3
 8004c6a: 00db         	lsls	r3, r3, #0x3
 8004c6c: 627b         	str	r3, [r7, #0x24]
; 		pkg = msg->data;
 8004c6e: 6a7b         	ldr	r3, [r7, #0x24]
 8004c70: 3310         	adds	r3, #0x10
 8004c72: 623b         	str	r3, [r7, #0x20]
; 	if (pkg && fmt) {
 8004c74: 6a3b         	ldr	r3, [r7, #0x20]
 8004c76: 2b00         	cmp	r3, #0x0
 8004c78: d00b         	beq	0x8004c92 <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x16
 8004c7a: 6c3b         	ldr	r3, [r7, #0x40]
 8004c7c: 2b00         	cmp	r3, #0x0
 8004c7e: d008         	beq	0x8004c92 <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x10
; 		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
 8004c80: 6af9         	ldr	r1, [r7, #0x2c]
 8004c82: 6c7b         	ldr	r3, [r7, #0x44]
 8004c84: 9300         	str	r3, [sp]
 8004c86: 6c3b         	ldr	r3, [r7, #0x40]
 8004c88: 6bfa         	ldr	r2, [r7, #0x3c]
 8004c8a: 6a38         	ldr	r0, [r7, #0x20]
 8004c8c: f7fe feca    	bl	0x8003a24 <cbvprintf_package> @ imm = #-0x126c
 8004c90: 62f8         	str	r0, [r7, #0x2c]
; 		z_log_msg_finalize(msg, source, desc, data);
 8004c92: 687b         	ldr	r3, [r7, #0x4]
 8004c94: 697a         	ldr	r2, [r7, #0x14]
 8004c96: 68b9         	ldr	r1, [r7, #0x8]
 8004c98: 6a78         	ldr	r0, [r7, #0x24]
 8004c9a: f018 f958    	bl	0x801cf4e <z_log_msg_finalize> @ imm = #0x182b0
; }
 8004c9e: 3730         	adds	r7, #0x30
 8004ca0: 46bd         	mov	sp, r7
 8004ca2: bd80         	pop	{r7, pc}

08004ca4 <$d>:
 8004ca4: 58 06 00 24  	.word	0x24000658
 8004ca8: 00 a5 02 08  	.word	0x0802a500

08004cac <cbpprintf>:
; {
 8004cac: b580         	push	{r7, lr}
 8004cae: b084         	sub	sp, #0x10
 8004cb0: af00         	add	r7, sp, #0x0
 8004cb2: 60f8         	str	r0, [r7, #0xc]
 8004cb4: 60b9         	str	r1, [r7, #0x8]
 8004cb6: 607a         	str	r2, [r7, #0x4]
; 	return cbpprintf_external(out, cbvprintf, ctx, packaged);
 8004cb8: 687b         	ldr	r3, [r7, #0x4]
 8004cba: 68ba         	ldr	r2, [r7, #0x8]
 8004cbc: 4904         	ldr	r1, [pc, #0x10]         @ 0x8004cd0 <cbpprintf+0x24>
 8004cbe: 68f8         	ldr	r0, [r7, #0xc]
 8004cc0: f017 fbfa    	bl	0x801c4b8 <cbpprintf_external> @ imm = #0x177f4
 8004cc4: 4603         	mov	r3, r0
; }
 8004cc6: 4618         	mov	r0, r3
 8004cc8: 3710         	adds	r7, #0x10
 8004cca: 46bd         	mov	sp, r7
 8004ccc: bd80         	pop	{r7, pc}
 8004cce: bf00         	nop

08004cd0 <$d>:
 8004cd0: a9 68 00 08  	.word	0x080068a9

08004cd4 <__ctype_lookup>:
; static __inline char __ctype_lookup(int c) { return (__CTYPE_PTR + 1)[c]; }
 8004cd4: b480         	push	{r7}
 8004cd6: b083         	sub	sp, #0xc
 8004cd8: af00         	add	r7, sp, #0x0
 8004cda: 6078         	str	r0, [r7, #0x4]
 8004cdc: 687b         	ldr	r3, [r7, #0x4]
 8004cde: 3301         	adds	r3, #0x1
 8004ce0: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004cf4 <__ctype_lookup+0x20>
 8004ce2: 4413         	add	r3, r2
 8004ce4: 781b         	ldrb	r3, [r3]
 8004ce6: 4618         	mov	r0, r3
 8004ce8: 370c         	adds	r7, #0xc
 8004cea: 46bd         	mov	sp, r7
 8004cec: f85d 7b04    	ldr	r7, [sp], #4
 8004cf0: 4770         	bx	lr
 8004cf2: bf00         	nop

08004cf4 <$d>:
 8004cf4: f8 ea 02 08  	.word	0x0802eaf8

08004cf8 <print_formatted>:
; {
 8004cf8: b40e         	push	{r1, r2, r3}
 8004cfa: b580         	push	{r7, lr}
 8004cfc: b085         	sub	sp, #0x14
 8004cfe: af00         	add	r7, sp, #0x0
 8004d00: 6078         	str	r0, [r7, #0x4]
; 	int length = 0;
 8004d02: 2300         	movs	r3, #0x0
 8004d04: 60fb         	str	r3, [r7, #0xc]
; 	va_start(args, fmt);
 8004d06: f107 0320    	add.w	r3, r7, #0x20
 8004d0a: 60bb         	str	r3, [r7, #0x8]
; 	length = cbvprintf(out_func, (void *)output, fmt, args);
 8004d0c: 68bb         	ldr	r3, [r7, #0x8]
 8004d0e: 69fa         	ldr	r2, [r7, #0x1c]
 8004d10: 6879         	ldr	r1, [r7, #0x4]
 8004d12: 4806         	ldr	r0, [pc, #0x18]         @ 0x8004d2c <print_formatted+0x34>
 8004d14: f001 fdc8    	bl	0x80068a8 <cbvprintf>   @ imm = #0x1b90
 8004d18: 60f8         	str	r0, [r7, #0xc]
; 	return length;
 8004d1a: 68fb         	ldr	r3, [r7, #0xc]
; }
 8004d1c: 4618         	mov	r0, r3
 8004d1e: 3714         	adds	r7, #0x14
 8004d20: 46bd         	mov	sp, r7
 8004d22: e8bd 4080    	pop.w	{r7, lr}
 8004d26: b003         	add	sp, #0xc
 8004d28: 4770         	bx	lr
 8004d2a: bf00         	nop

08004d2c <$d>:
 8004d2c: 37 d1 01 08  	.word	0x0801d137

08004d30 <timestamp_print>:
; {
 8004d30: b580         	push	{r7, lr}
 8004d32: b09a         	sub	sp, #0x68
 8004d34: af04         	add	r7, sp, #0x10
 8004d36: 60f8         	str	r0, [r7, #0xc]
 8004d38: 60b9         	str	r1, [r7, #0x8]
 8004d3a: 607a         	str	r2, [r7, #0x4]
; 		IS_ENABLED(CONFIG_LOG_OUTPUT_FORMAT_LINUX_TIMESTAMP) |
 8004d3c: 68bb         	ldr	r3, [r7, #0x8]
 8004d3e: f003 0344    	and	r3, r3, #0x44
; 	bool format =
 8004d42: 2b00         	cmp	r3, #0x0
 8004d44: bf14         	ite	ne
 8004d46: 2301         	movne	r3, #0x1
 8004d48: 2300         	moveq	r3, #0x0
 8004d4a: f887 3037    	strb.w	r3, [r7, #0x37]
; 	if (!format) {
 8004d4e: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8004d52: f083 0301    	eor	r3, r3, #0x1
 8004d56: b2db         	uxtb	r3, r3
 8004d58: 2b00         	cmp	r3, #0x0
 8004d5a: d006         	beq	0x8004d6a <timestamp_print+0x3a> @ imm = #0xc
; 		length = print_formatted(output, "[%08lu] ", timestamp);
 8004d5c: 687a         	ldr	r2, [r7, #0x4]
 8004d5e: 4938         	ldr	r1, [pc, #0xe0]         @ 0x8004e40 <timestamp_print+0x110>
 8004d60: 68f8         	ldr	r0, [r7, #0xc]
 8004d62: f7ff ffc9    	bl	0x8004cf8 <print_formatted> @ imm = #-0x6e
 8004d66: 63b8         	str	r0, [r7, #0x38]
 8004d68: e065         	b	0x8004e36 <timestamp_print+0x106> @ imm = #0xca
; 	} else if (freq != 0U) {
 8004d6a: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8004e44 <timestamp_print+0x114>
 8004d6c: 681b         	ldr	r3, [r3]
 8004d6e: 2b00         	cmp	r3, #0x0
 8004d70: d05f         	beq	0x8004e32 <timestamp_print+0x102> @ imm = #0xbe
; 		timestamp /= timestamp_div;
 8004d72: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8004e48 <timestamp_print+0x118>
 8004d74: 681b         	ldr	r3, [r3]
 8004d76: 687a         	ldr	r2, [r7, #0x4]
 8004d78: fbb2 f3f3    	udiv	r3, r2, r3
 8004d7c: 607b         	str	r3, [r7, #0x4]
; 		total_seconds = timestamp / freq;
 8004d7e: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8004e44 <timestamp_print+0x114>
 8004d80: 681b         	ldr	r3, [r3]
 8004d82: 687a         	ldr	r2, [r7, #0x4]
 8004d84: fbb2 f3f3    	udiv	r3, r2, r3
 8004d88: 63fb         	str	r3, [r7, #0x3c]
; 		seconds = total_seconds;
 8004d8a: 6bfb         	ldr	r3, [r7, #0x3c]
 8004d8c: 653b         	str	r3, [r7, #0x50]
; 		hours = seconds / 3600U;
 8004d8e: 6d3b         	ldr	r3, [r7, #0x50]
 8004d90: 4a2e         	ldr	r2, [pc, #0xb8]         @ 0x8004e4c <timestamp_print+0x11c>
 8004d92: fba2 2303    	umull	r2, r3, r2, r3
 8004d96: 0adb         	lsrs	r3, r3, #0xb
 8004d98: 643b         	str	r3, [r7, #0x40]
; 		seconds -= hours * 3600U;
 8004d9a: 6c3b         	ldr	r3, [r7, #0x40]
 8004d9c: f44f 6261    	mov.w	r2, #0xe10
 8004da0: fb02 f303    	mul	r3, r2, r3
 8004da4: 6d3a         	ldr	r2, [r7, #0x50]
 8004da6: 1ad3         	subs	r3, r2, r3
 8004da8: 653b         	str	r3, [r7, #0x50]
; 		mins = seconds / 60U;
 8004daa: 6d3b         	ldr	r3, [r7, #0x50]
 8004dac: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x8004e50 <timestamp_print+0x120>
 8004dae: fba2 2303    	umull	r2, r3, r2, r3
 8004db2: 095b         	lsrs	r3, r3, #0x5
 8004db4: 657b         	str	r3, [r7, #0x54]
; 		seconds -= mins * 60U;
 8004db6: 6d7a         	ldr	r2, [r7, #0x54]
 8004db8: 4613         	mov	r3, r2
 8004dba: 011b         	lsls	r3, r3, #0x4
 8004dbc: 1a9b         	subs	r3, r3, r2
 8004dbe: 009b         	lsls	r3, r3, #0x2
 8004dc0: 461a         	mov	r2, r3
 8004dc2: 6d3b         	ldr	r3, [r7, #0x50]
 8004dc4: 1a9b         	subs	r3, r3, r2
 8004dc6: 653b         	str	r3, [r7, #0x50]
; 		remainder = timestamp % freq;
 8004dc8: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8004e44 <timestamp_print+0x114>
 8004dca: 681a         	ldr	r2, [r3]
 8004dcc: 687b         	ldr	r3, [r7, #0x4]
 8004dce: fbb3 f1f2    	udiv	r1, r3, r2
 8004dd2: fb01 f202    	mul	r2, r1, r2
 8004dd6: 1a9b         	subs	r3, r3, r2
 8004dd8: 64fb         	str	r3, [r7, #0x4c]
; 		ms = (remainder * 1000U) / freq;
 8004dda: 6cfb         	ldr	r3, [r7, #0x4c]
 8004ddc: f44f 727a    	mov.w	r2, #0x3e8
 8004de0: fb03 f202    	mul	r2, r3, r2
 8004de4: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8004e44 <timestamp_print+0x114>
 8004de6: 681b         	ldr	r3, [r3]
 8004de8: fbb2 f3f3    	udiv	r3, r2, r3
 8004dec: 64bb         	str	r3, [r7, #0x48]
; 		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 8004dee: 6cfb         	ldr	r3, [r7, #0x4c]
 8004df0: f44f 727a    	mov.w	r2, #0x3e8
 8004df4: fb03 f202    	mul	r2, r3, r2
 8004df8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8004e44 <timestamp_print+0x114>
 8004dfa: 681b         	ldr	r3, [r3]
 8004dfc: 6cb9         	ldr	r1, [r7, #0x48]
 8004dfe: fb01 f303    	mul	r3, r1, r3
 8004e02: 1ad3         	subs	r3, r2, r3
 8004e04: f44f 727a    	mov.w	r2, #0x3e8
 8004e08: fb03 f202    	mul	r2, r3, r2
 8004e0c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8004e44 <timestamp_print+0x114>
 8004e0e: 681b         	ldr	r3, [r3]
 8004e10: fbb2 f3f3    	udiv	r3, r2, r3
 8004e14: 647b         	str	r3, [r7, #0x44]
; 				length = print_formatted(output,
 8004e16: 6c7b         	ldr	r3, [r7, #0x44]
 8004e18: 9302         	str	r3, [sp, #0x8]
 8004e1a: 6cbb         	ldr	r3, [r7, #0x48]
 8004e1c: 9301         	str	r3, [sp, #0x4]
 8004e1e: 6d3b         	ldr	r3, [r7, #0x50]
 8004e20: 9300         	str	r3, [sp]
 8004e22: 6d7b         	ldr	r3, [r7, #0x54]
 8004e24: 6c3a         	ldr	r2, [r7, #0x40]
 8004e26: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8004e54 <timestamp_print+0x124>
 8004e28: 68f8         	ldr	r0, [r7, #0xc]
 8004e2a: f7ff ff65    	bl	0x8004cf8 <print_formatted> @ imm = #-0x136
 8004e2e: 63b8         	str	r0, [r7, #0x38]
 8004e30: e001         	b	0x8004e36 <timestamp_print+0x106> @ imm = #0x2
; 		length = 0;
 8004e32: 2300         	movs	r3, #0x0
 8004e34: 63bb         	str	r3, [r7, #0x38]
; 	return length;
 8004e36: 6bbb         	ldr	r3, [r7, #0x38]
; }
 8004e38: 4618         	mov	r0, r3
 8004e3a: 3758         	adds	r7, #0x58
 8004e3c: 46bd         	mov	sp, r7
 8004e3e: bd80         	pop	{r7, pc}

08004e40 <$d>:
 8004e40: 58 a5 02 08  	.word	0x0802a558
 8004e44: 28 28 00 24  	.word	0x24002828
 8004e48: 2c 28 00 24  	.word	0x2400282c
 8004e4c: c5 b3 a2 91  	.word	0x91a2b3c5
 8004e50: 89 88 88 88  	.word	0x88888889
 8004e54: 64 a5 02 08  	.word	0x0802a564

08004e58 <color_print>:
; {
 8004e58: b580         	push	{r7, lr}
 8004e5a: b086         	sub	sp, #0x18
 8004e5c: af00         	add	r7, sp, #0x0
 8004e5e: 60f8         	str	r0, [r7, #0xc]
 8004e60: 607b         	str	r3, [r7, #0x4]
 8004e62: 460b         	mov	r3, r1
 8004e64: 72fb         	strb	r3, [r7, #0xb]
 8004e66: 4613         	mov	r3, r2
 8004e68: 72bb         	strb	r3, [r7, #0xa]
; 	if (color) {
 8004e6a: 7afb         	ldrb	r3, [r7, #0xb]
 8004e6c: 2b00         	cmp	r3, #0x0
 8004e6e: d014         	beq	0x8004e9a <color_print+0x42> @ imm = #0x28
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8004e70: 7abb         	ldrb	r3, [r7, #0xa]
 8004e72: 2b00         	cmp	r3, #0x0
 8004e74: d00a         	beq	0x8004e8c <color_print+0x34> @ imm = #0x14
; 		const char *log_color = start && (colors[level] != NULL) ?
 8004e76: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8004ea4 <color_print+0x4c>
 8004e78: 687b         	ldr	r3, [r7, #0x4]
 8004e7a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8004e7e: 2b00         	cmp	r3, #0x0
 8004e80: d004         	beq	0x8004e8c <color_print+0x34> @ imm = #0x8
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8004e82: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8004ea4 <color_print+0x4c>
 8004e84: 687b         	ldr	r3, [r7, #0x4]
 8004e86: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8004e8a: e000         	b	0x8004e8e <color_print+0x36> @ imm = #0x0
 8004e8c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8004ea8 <color_print+0x50>
; 		const char *log_color = start && (colors[level] != NULL) ?
 8004e8e: 617b         	str	r3, [r7, #0x14]
; 		print_formatted(output, "%s", log_color);
 8004e90: 697a         	ldr	r2, [r7, #0x14]
 8004e92: 4906         	ldr	r1, [pc, #0x18]         @ 0x8004eac <color_print+0x54>
 8004e94: 68f8         	ldr	r0, [r7, #0xc]
 8004e96: f7ff ff2f    	bl	0x8004cf8 <print_formatted> @ imm = #-0x1a2
; }
 8004e9a: bf00         	nop
 8004e9c: 3718         	adds	r7, #0x18
 8004e9e: 46bd         	mov	sp, r7
 8004ea0: bd80         	pop	{r7, pc}
 8004ea2: bf00         	nop

08004ea4 <$d>:
 8004ea4: d0 cd 02 08  	.word	0x0802cdd0
 8004ea8: 80 a5 02 08  	.word	0x0802a580
 8004eac: 88 a5 02 08  	.word	0x0802a588

08004eb0 <ids_print>:
; {
 8004eb0: b580         	push	{r7, lr}
 8004eb2: b084         	sub	sp, #0x10
 8004eb4: af00         	add	r7, sp, #0x0
 8004eb6: 6078         	str	r0, [r7, #0x4]
 8004eb8: 4608         	mov	r0, r1
 8004eba: 4611         	mov	r1, r2
 8004ebc: 461a         	mov	r2, r3
 8004ebe: 4603         	mov	r3, r0
 8004ec0: 70fb         	strb	r3, [r7, #0x3]
 8004ec2: 460b         	mov	r3, r1
 8004ec4: 70bb         	strb	r3, [r7, #0x2]
 8004ec6: 4613         	mov	r3, r2
 8004ec8: 707b         	strb	r3, [r7, #0x1]
; 	int total = 0;
 8004eca: 2300         	movs	r3, #0x0
 8004ecc: 60fb         	str	r3, [r7, #0xc]
; 	if (level_on) {
 8004ece: 78fb         	ldrb	r3, [r7, #0x3]
 8004ed0: 2b00         	cmp	r3, #0x0
 8004ed2: d00c         	beq	0x8004eee <ids_print+0x3e> @ imm = #0x18
; 		total += print_formatted(output, "<%s> ", severity[level]);
 8004ed4: 4a19         	ldr	r2, [pc, #0x64]         @ 0x8004f3c <ids_print+0x8c>
 8004ed6: 6a7b         	ldr	r3, [r7, #0x24]
 8004ed8: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8004edc: 461a         	mov	r2, r3
 8004ede: 4918         	ldr	r1, [pc, #0x60]         @ 0x8004f40 <ids_print+0x90>
 8004ee0: 6878         	ldr	r0, [r7, #0x4]
 8004ee2: f7ff ff09    	bl	0x8004cf8 <print_formatted> @ imm = #-0x1ee
 8004ee6: 4602         	mov	r2, r0
 8004ee8: 68fb         	ldr	r3, [r7, #0xc]
 8004eea: 4413         	add	r3, r2
 8004eec: 60fb         	str	r3, [r7, #0xc]
; 	if (domain) {
 8004eee: 69bb         	ldr	r3, [r7, #0x18]
 8004ef0: 2b00         	cmp	r3, #0x0
 8004ef2: d008         	beq	0x8004f06 <ids_print+0x56> @ imm = #0x10
; 		total += print_formatted(output, "%s/", domain);
 8004ef4: 69ba         	ldr	r2, [r7, #0x18]
 8004ef6: 4913         	ldr	r1, [pc, #0x4c]         @ 0x8004f44 <ids_print+0x94>
 8004ef8: 6878         	ldr	r0, [r7, #0x4]
 8004efa: f7ff fefd    	bl	0x8004cf8 <print_formatted> @ imm = #-0x206
 8004efe: 4602         	mov	r2, r0
 8004f00: 68fb         	ldr	r3, [r7, #0xc]
 8004f02: 4413         	add	r3, r2
 8004f04: 60fb         	str	r3, [r7, #0xc]
; 	if (source) {
 8004f06: 69fb         	ldr	r3, [r7, #0x1c]
 8004f08: 2b00         	cmp	r3, #0x0
 8004f0a: d011         	beq	0x8004f30 <ids_print+0x80> @ imm = #0x22
; 		total += print_formatted(output,
 8004f0c: 78bb         	ldrb	r3, [r7, #0x2]
 8004f0e: 2b00         	cmp	r3, #0x0
 8004f10: d004         	beq	0x8004f1c <ids_print+0x6c> @ imm = #0x8
; 				(func_on &&
 8004f12: 6a7b         	ldr	r3, [r7, #0x24]
 8004f14: 2b04         	cmp	r3, #0x4
 8004f16: d101         	bne	0x8004f1c <ids_print+0x6c> @ imm = #0x2
; 		total += print_formatted(output,
 8004f18: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8004f48 <ids_print+0x98>
 8004f1a: e000         	b	0x8004f1e <ids_print+0x6e> @ imm = #0x0
 8004f1c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8004f4c <ids_print+0x9c>
 8004f1e: 69fa         	ldr	r2, [r7, #0x1c]
 8004f20: 4619         	mov	r1, r3
 8004f22: 6878         	ldr	r0, [r7, #0x4]
 8004f24: f7ff fee8    	bl	0x8004cf8 <print_formatted> @ imm = #-0x230
 8004f28: 4602         	mov	r2, r0
 8004f2a: 68fb         	ldr	r3, [r7, #0xc]
 8004f2c: 4413         	add	r3, r2
 8004f2e: 60fb         	str	r3, [r7, #0xc]
; 	return total;
 8004f30: 68fb         	ldr	r3, [r7, #0xc]
; }
 8004f32: 4618         	mov	r0, r3
 8004f34: 3710         	adds	r7, #0x10
 8004f36: 46bd         	mov	sp, r7
 8004f38: bd80         	pop	{r7, pc}
 8004f3a: bf00         	nop

08004f3c <$d>:
 8004f3c: bc cd 02 08  	.word	0x0802cdbc
 8004f40: 8c a5 02 08  	.word	0x0802a58c
 8004f44: 94 a5 02 08  	.word	0x0802a594
 8004f48: 98 a5 02 08  	.word	0x0802a598
 8004f4c: 9c a5 02 08  	.word	0x0802a59c

08004f50 <newline_print>:
; {
 8004f50: b580         	push	{r7, lr}
 8004f52: b082         	sub	sp, #0x8
 8004f54: af00         	add	r7, sp, #0x0
 8004f56: 6078         	str	r0, [r7, #0x4]
 8004f58: 6039         	str	r1, [r7]
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 8004f5a: 683b         	ldr	r3, [r7]
 8004f5c: f003 0310    	and	r3, r3, #0x10
 8004f60: 2b00         	cmp	r3, #0x0
 8004f62: d10e         	bne	0x8004f82 <newline_print+0x32> @ imm = #0x1c
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 8004f64: 683b         	ldr	r3, [r7]
 8004f66: f003 0320    	and	r3, r3, #0x20
 8004f6a: 2b00         	cmp	r3, #0x0
 8004f6c: d004         	beq	0x8004f78 <newline_print+0x28> @ imm = #0x8
; 		print_formatted(ctx, "\n");
 8004f6e: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8004f8c <newline_print+0x3c>
 8004f70: 6878         	ldr	r0, [r7, #0x4]
 8004f72: f7ff fec1    	bl	0x8004cf8 <print_formatted> @ imm = #-0x27e
 8004f76: e005         	b	0x8004f84 <newline_print+0x34> @ imm = #0xa
; 		print_formatted(ctx, "\r\n");
 8004f78: 4905         	ldr	r1, [pc, #0x14]         @ 0x8004f90 <newline_print+0x40>
 8004f7a: 6878         	ldr	r0, [r7, #0x4]
 8004f7c: f7ff febc    	bl	0x8004cf8 <print_formatted> @ imm = #-0x288
 8004f80: e000         	b	0x8004f84 <newline_print+0x34> @ imm = #0x0
; 		return;
 8004f82: bf00         	nop
; }
 8004f84: 3708         	adds	r7, #0x8
 8004f86: 46bd         	mov	sp, r7
 8004f88: bd80         	pop	{r7, pc}
 8004f8a: bf00         	nop

08004f8c <$d>:
 8004f8c: a4 a5 02 08  	.word	0x0802a5a4
 8004f90: a8 a5 02 08  	.word	0x0802a5a8

08004f94 <hexdump_line_print>:
; {
 8004f94: b580         	push	{r7, lr}
 8004f96: b088         	sub	sp, #0x20
 8004f98: af00         	add	r7, sp, #0x0
 8004f9a: 60f8         	str	r0, [r7, #0xc]
 8004f9c: 60b9         	str	r1, [r7, #0x8]
 8004f9e: 607a         	str	r2, [r7, #0x4]
 8004fa0: 603b         	str	r3, [r7]
; 	newline_print(output, flags);
 8004fa2: 6ab9         	ldr	r1, [r7, #0x28]
 8004fa4: 68f8         	ldr	r0, [r7, #0xc]
 8004fa6: f7ff ffd3    	bl	0x8004f50 <newline_print> @ imm = #-0x5a
; 	for (int i = 0; i < prefix_offset; i++) {
 8004faa: 2300         	movs	r3, #0x0
 8004fac: 61fb         	str	r3, [r7, #0x1c]
 8004fae: e006         	b	0x8004fbe <hexdump_line_print+0x2a> @ imm = #0xc
; 		print_formatted(output, " ");
 8004fb0: 4937         	ldr	r1, [pc, #0xdc]         @ 0x8005090 <hexdump_line_print+0xfc>
 8004fb2: 68f8         	ldr	r0, [r7, #0xc]
 8004fb4: f7ff fea0    	bl	0x8004cf8 <print_formatted> @ imm = #-0x2c0
; 	for (int i = 0; i < prefix_offset; i++) {
 8004fb8: 69fb         	ldr	r3, [r7, #0x1c]
 8004fba: 3301         	adds	r3, #0x1
 8004fbc: 61fb         	str	r3, [r7, #0x1c]
 8004fbe: 69fa         	ldr	r2, [r7, #0x1c]
 8004fc0: 683b         	ldr	r3, [r7]
 8004fc2: 429a         	cmp	r2, r3
 8004fc4: dbf4         	blt	0x8004fb0 <hexdump_line_print+0x1c> @ imm = #-0x18
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8004fc6: 2300         	movs	r3, #0x0
 8004fc8: 61bb         	str	r3, [r7, #0x18]
 8004fca: e020         	b	0x800500e <hexdump_line_print+0x7a> @ imm = #0x40
; 		if (i > 0 && !(i % 8)) {
 8004fcc: 69bb         	ldr	r3, [r7, #0x18]
 8004fce: 2b00         	cmp	r3, #0x0
 8004fd0: dd08         	ble	0x8004fe4 <hexdump_line_print+0x50> @ imm = #0x10
 8004fd2: 69bb         	ldr	r3, [r7, #0x18]
 8004fd4: f003 0307    	and	r3, r3, #0x7
 8004fd8: 2b00         	cmp	r3, #0x0
 8004fda: d103         	bne	0x8004fe4 <hexdump_line_print+0x50> @ imm = #0x6
; 			print_formatted(output, " ");
 8004fdc: 492c         	ldr	r1, [pc, #0xb0]         @ 0x8005090 <hexdump_line_print+0xfc>
 8004fde: 68f8         	ldr	r0, [r7, #0xc]
 8004fe0: f7ff fe8a    	bl	0x8004cf8 <print_formatted> @ imm = #-0x2ec
; 		if (i < length) {
 8004fe4: 69bb         	ldr	r3, [r7, #0x18]
 8004fe6: 687a         	ldr	r2, [r7, #0x4]
 8004fe8: 429a         	cmp	r2, r3
 8004fea: d909         	bls	0x8005000 <hexdump_line_print+0x6c> @ imm = #0x12
; 			print_formatted(output, "%02x ", data[i]);
 8004fec: 69bb         	ldr	r3, [r7, #0x18]
 8004fee: 68ba         	ldr	r2, [r7, #0x8]
 8004ff0: 4413         	add	r3, r2
 8004ff2: 781b         	ldrb	r3, [r3]
 8004ff4: 461a         	mov	r2, r3
 8004ff6: 4927         	ldr	r1, [pc, #0x9c]         @ 0x8005094 <hexdump_line_print+0x100>
 8004ff8: 68f8         	ldr	r0, [r7, #0xc]
 8004ffa: f7ff fe7d    	bl	0x8004cf8 <print_formatted> @ imm = #-0x306
 8004ffe: e003         	b	0x8005008 <hexdump_line_print+0x74> @ imm = #0x6
; 			print_formatted(output, "   ");
 8005000: 4925         	ldr	r1, [pc, #0x94]         @ 0x8005098 <hexdump_line_print+0x104>
 8005002: 68f8         	ldr	r0, [r7, #0xc]
 8005004: f7ff fe78    	bl	0x8004cf8 <print_formatted> @ imm = #-0x310
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8005008: 69bb         	ldr	r3, [r7, #0x18]
 800500a: 3301         	adds	r3, #0x1
 800500c: 61bb         	str	r3, [r7, #0x18]
 800500e: 69bb         	ldr	r3, [r7, #0x18]
 8005010: 2b0f         	cmp	r3, #0xf
 8005012: dddb         	ble	0x8004fcc <hexdump_line_print+0x38> @ imm = #-0x4a
; 	print_formatted(output, "|");
 8005014: 4921         	ldr	r1, [pc, #0x84]         @ 0x800509c <hexdump_line_print+0x108>
 8005016: 68f8         	ldr	r0, [r7, #0xc]
 8005018: f7ff fe6e    	bl	0x8004cf8 <print_formatted> @ imm = #-0x324
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 800501c: 2300         	movs	r3, #0x0
 800501e: 617b         	str	r3, [r7, #0x14]
 8005020: e02d         	b	0x800507e <hexdump_line_print+0xea> @ imm = #0x5a
; 		if (i > 0 && !(i % 8)) {
 8005022: 697b         	ldr	r3, [r7, #0x14]
 8005024: 2b00         	cmp	r3, #0x0
 8005026: dd08         	ble	0x800503a <hexdump_line_print+0xa6> @ imm = #0x10
 8005028: 697b         	ldr	r3, [r7, #0x14]
 800502a: f003 0307    	and	r3, r3, #0x7
 800502e: 2b00         	cmp	r3, #0x0
 8005030: d103         	bne	0x800503a <hexdump_line_print+0xa6> @ imm = #0x6
; 			print_formatted(output, " ");
 8005032: 4917         	ldr	r1, [pc, #0x5c]         @ 0x8005090 <hexdump_line_print+0xfc>
 8005034: 68f8         	ldr	r0, [r7, #0xc]
 8005036: f7ff fe5f    	bl	0x8004cf8 <print_formatted> @ imm = #-0x342
; 		if (i < length) {
 800503a: 697b         	ldr	r3, [r7, #0x14]
 800503c: 687a         	ldr	r2, [r7, #0x4]
 800503e: 429a         	cmp	r2, r3
 8005040: d916         	bls	0x8005070 <hexdump_line_print+0xdc> @ imm = #0x2c
; 			unsigned char c = (unsigned char)data[i];
 8005042: 697b         	ldr	r3, [r7, #0x14]
 8005044: 68ba         	ldr	r2, [r7, #0x8]
 8005046: 4413         	add	r3, r2
 8005048: 781b         	ldrb	r3, [r3]
 800504a: 74fb         	strb	r3, [r7, #0x13]
; 			      isprint((int)c) != 0 ? c : '.');
 800504c: 7cfb         	ldrb	r3, [r7, #0x13]
 800504e: 4618         	mov	r0, r3
 8005050: f7ff fe40    	bl	0x8004cd4 <__ctype_lookup> @ imm = #-0x380
 8005054: 4603         	mov	r3, r0
 8005056: f003 0397    	and	r3, r3, #0x97
; 			print_formatted(output, "%c",
 800505a: 2b00         	cmp	r3, #0x0
 800505c: d001         	beq	0x8005062 <hexdump_line_print+0xce> @ imm = #0x2
 800505e: 7cfb         	ldrb	r3, [r7, #0x13]
 8005060: e000         	b	0x8005064 <hexdump_line_print+0xd0> @ imm = #0x0
 8005062: 232e         	movs	r3, #0x2e
 8005064: 461a         	mov	r2, r3
 8005066: 490e         	ldr	r1, [pc, #0x38]         @ 0x80050a0 <hexdump_line_print+0x10c>
 8005068: 68f8         	ldr	r0, [r7, #0xc]
 800506a: f7ff fe45    	bl	0x8004cf8 <print_formatted> @ imm = #-0x376
 800506e: e003         	b	0x8005078 <hexdump_line_print+0xe4> @ imm = #0x6
; 			print_formatted(output, " ");
 8005070: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8005090 <hexdump_line_print+0xfc>
 8005072: 68f8         	ldr	r0, [r7, #0xc]
 8005074: f7ff fe40    	bl	0x8004cf8 <print_formatted> @ imm = #-0x380
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8005078: 697b         	ldr	r3, [r7, #0x14]
 800507a: 3301         	adds	r3, #0x1
 800507c: 617b         	str	r3, [r7, #0x14]
 800507e: 697b         	ldr	r3, [r7, #0x14]
 8005080: 2b0f         	cmp	r3, #0xf
 8005082: ddce         	ble	0x8005022 <hexdump_line_print+0x8e> @ imm = #-0x64
; }
 8005084: bf00         	nop
 8005086: bf00         	nop
 8005088: 3720         	adds	r7, #0x20
 800508a: 46bd         	mov	sp, r7
 800508c: bd80         	pop	{r7, pc}
 800508e: bf00         	nop

08005090 <$d>:
 8005090: ac a5 02 08  	.word	0x0802a5ac
 8005094: b0 a5 02 08  	.word	0x0802a5b0
 8005098: b8 a5 02 08  	.word	0x0802a5b8
 800509c: bc a5 02 08  	.word	0x0802a5bc
 80050a0: c0 a5 02 08  	.word	0x0802a5c0

080050a4 <prefix_print>:
; {
 80050a4: b590         	push	{r4, r7, lr}
 80050a6: b08d         	sub	sp, #0x34
 80050a8: af04         	add	r7, sp, #0x10
 80050aa: 60f8         	str	r0, [r7, #0xc]
 80050ac: 60b9         	str	r1, [r7, #0x8]
 80050ae: 603b         	str	r3, [r7]
 80050b0: 4613         	mov	r3, r2
 80050b2: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t length = 0U;
 80050b4: 2300         	movs	r3, #0x0
 80050b6: 61fb         	str	r3, [r7, #0x1c]
; 	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
 80050b8: 68bb         	ldr	r3, [r7, #0x8]
 80050ba: f003 0302    	and	r3, r3, #0x2
 80050be: 2b00         	cmp	r3, #0x0
 80050c0: bf14         	ite	ne
 80050c2: 2301         	movne	r3, #0x1
 80050c4: 2300         	moveq	r3, #0x0
 80050c6: 76fb         	strb	r3, [r7, #0x1b]
; 	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
 80050c8: 68bb         	ldr	r3, [r7, #0x8]
 80050ca: f003 0301    	and	r3, r3, #0x1
 80050ce: 2b00         	cmp	r3, #0x0
 80050d0: bf14         	ite	ne
 80050d2: 2301         	movne	r3, #0x1
 80050d4: 2300         	moveq	r3, #0x0
 80050d6: 76bb         	strb	r3, [r7, #0x1a]
; 	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
 80050d8: 68bb         	ldr	r3, [r7, #0x8]
 80050da: f003 0308    	and	r3, r3, #0x8
 80050de: 2b00         	cmp	r3, #0x0
 80050e0: bf14         	ite	ne
 80050e2: 2301         	movne	r3, #0x1
 80050e4: 2300         	moveq	r3, #0x0
 80050e6: 767b         	strb	r3, [r7, #0x19]
; 	bool thread_on = IS_ENABLED(CONFIG_LOG_THREAD_ID_PREFIX) &&
 80050e8: 2300         	movs	r3, #0x0
 80050ea: 74fb         	strb	r3, [r7, #0x13]
; 	bool source_off = flags & LOG_OUTPUT_FLAG_SKIP_SOURCE;
 80050ec: 68bb         	ldr	r3, [r7, #0x8]
 80050ee: f403 7380    	and	r3, r3, #0x100
 80050f2: 2b00         	cmp	r3, #0x0
 80050f4: bf14         	ite	ne
 80050f6: 2301         	movne	r3, #0x1
 80050f8: 2300         	moveq	r3, #0x0
 80050fa: 763b         	strb	r3, [r7, #0x18]
; 	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
 80050fc: f017 fc60    	bl	0x801c9c0 <z_log_get_tag> @ imm = #0x178c0
 8005100: 6178         	str	r0, [r7, #0x14]
; 	if (tag) {
 8005102: 697b         	ldr	r3, [r7, #0x14]
 8005104: 2b00         	cmp	r3, #0x0
 8005106: d009         	beq	0x800511c <prefix_print+0x78> @ imm = #0x12
; 		length += print_formatted(output, "%s ", tag);
 8005108: 697a         	ldr	r2, [r7, #0x14]
 800510a: 491e         	ldr	r1, [pc, #0x78]         @ 0x8005184 <prefix_print+0xe0>
 800510c: 68f8         	ldr	r0, [r7, #0xc]
 800510e: f7ff fdf3    	bl	0x8004cf8 <print_formatted> @ imm = #-0x41a
 8005112: 4603         	mov	r3, r0
 8005114: 461a         	mov	r2, r3
 8005116: 69fb         	ldr	r3, [r7, #0x1c]
 8005118: 4413         	add	r3, r2
 800511a: 61fb         	str	r3, [r7, #0x1c]
; 	if (stamp) {
 800511c: 7efb         	ldrb	r3, [r7, #0x1b]
 800511e: 2b00         	cmp	r3, #0x0
 8005120: d009         	beq	0x8005136 <prefix_print+0x92> @ imm = #0x12
; 		length += timestamp_print(output, flags, timestamp);
 8005122: 683a         	ldr	r2, [r7]
 8005124: 68b9         	ldr	r1, [r7, #0x8]
 8005126: 68f8         	ldr	r0, [r7, #0xc]
 8005128: f7ff fe02    	bl	0x8004d30 <timestamp_print> @ imm = #-0x3fc
 800512c: 4603         	mov	r3, r0
 800512e: 461a         	mov	r2, r3
 8005130: 69fb         	ldr	r3, [r7, #0x1c]
 8005132: 4413         	add	r3, r2
 8005134: 61fb         	str	r3, [r7, #0x1c]
; 		color_prefix(output, colors_on, level);
 8005136: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 800513a: 7ebb         	ldrb	r3, [r7, #0x1a]
 800513c: 4619         	mov	r1, r3
 800513e: 68f8         	ldr	r0, [r7, #0xc]
 8005140: f018 f826    	bl	0x801d190 <color_prefix> @ imm = #0x1804c
; 	length += ids_print(output, level_on, func_on, thread_on, domain,
 8005144: 7cfc         	ldrb	r4, [r7, #0x13]
 8005146: 7e3b         	ldrb	r3, [r7, #0x18]
 8005148: 2b00         	cmp	r3, #0x0
 800514a: d001         	beq	0x8005150 <prefix_print+0xac> @ imm = #0x2
 800514c: 2300         	movs	r3, #0x0
 800514e: e000         	b	0x8005152 <prefix_print+0xae> @ imm = #0x0
 8005150: 6b7b         	ldr	r3, [r7, #0x34]
 8005152: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 8005156: 79f8         	ldrb	r0, [r7, #0x7]
 8005158: 7e79         	ldrb	r1, [r7, #0x19]
 800515a: 9203         	str	r2, [sp, #0xc]
 800515c: 6bba         	ldr	r2, [r7, #0x38]
 800515e: 9202         	str	r2, [sp, #0x8]
 8005160: 9301         	str	r3, [sp, #0x4]
 8005162: 6b3b         	ldr	r3, [r7, #0x30]
 8005164: 9300         	str	r3, [sp]
 8005166: 4623         	mov	r3, r4
 8005168: 4602         	mov	r2, r0
 800516a: 68f8         	ldr	r0, [r7, #0xc]
 800516c: f7ff fea0    	bl	0x8004eb0 <ids_print>   @ imm = #-0x2c0
 8005170: 4603         	mov	r3, r0
 8005172: 461a         	mov	r2, r3
 8005174: 69fb         	ldr	r3, [r7, #0x1c]
 8005176: 4413         	add	r3, r2
 8005178: 61fb         	str	r3, [r7, #0x1c]
; 	return length;
 800517a: 69fb         	ldr	r3, [r7, #0x1c]
; }
 800517c: 4618         	mov	r0, r3
 800517e: 3724         	adds	r7, #0x24
 8005180: 46bd         	mov	sp, r7
 8005182: bd90         	pop	{r4, r7, pc}

08005184 <$d>:
 8005184: cc a5 02 08  	.word	0x0802a5cc

08005188 <log_output_process>:
; {
 8005188: b580         	push	{r7, lr}
 800518a: b08c         	sub	sp, #0x30
 800518c: af04         	add	r7, sp, #0x10
 800518e: 60f8         	str	r0, [r7, #0xc]
 8005190: 60b9         	str	r1, [r7, #0x8]
 8005192: 607a         	str	r2, [r7, #0x4]
 8005194: 603b         	str	r3, [r7]
; 	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
 8005196: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 800519a: 2b00         	cmp	r3, #0x0
 800519c: bf0c         	ite	eq
 800519e: 2301         	moveq	r3, #0x1
 80051a0: 2300         	movne	r3, #0x0
 80051a2: 75fb         	strb	r3, [r7, #0x17]
; 	if (!raw_string) {
 80051a4: 7dfb         	ldrb	r3, [r7, #0x17]
 80051a6: f083 0301    	eor	r3, r3, #0x1
 80051aa: b2db         	uxtb	r3, r3
 80051ac: 2b00         	cmp	r3, #0x0
 80051ae: d012         	beq	0x80051d6 <log_output_process+0x4e> @ imm = #0x24
; 		prefix_offset = prefix_print(output, flags, 0, timestamp,
 80051b0: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 80051b4: 9303         	str	r3, [sp, #0xc]
 80051b6: 6abb         	ldr	r3, [r7, #0x28]
 80051b8: 9302         	str	r3, [sp, #0x8]
 80051ba: 683b         	ldr	r3, [r7]
 80051bc: 9301         	str	r3, [sp, #0x4]
 80051be: 687b         	ldr	r3, [r7, #0x4]
 80051c0: 9300         	str	r3, [sp]
 80051c2: 68bb         	ldr	r3, [r7, #0x8]
 80051c4: 2200         	movs	r2, #0x0
 80051c6: 6bf9         	ldr	r1, [r7, #0x3c]
 80051c8: 68f8         	ldr	r0, [r7, #0xc]
 80051ca: f7ff ff6b    	bl	0x80050a4 <prefix_print> @ imm = #-0x12a
 80051ce: 61f8         	str	r0, [r7, #0x1c]
; 		cb = out_func;
 80051d0: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800523c <log_output_process+0xb4>
 80051d2: 61bb         	str	r3, [r7, #0x18]
 80051d4: e008         	b	0x80051e8 <log_output_process+0x60> @ imm = #0x10
; 		prefix_offset = 0;
 80051d6: 2300         	movs	r3, #0x0
 80051d8: 61fb         	str	r3, [r7, #0x1c]
; 		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
 80051da: 683b         	ldr	r3, [r7]
 80051dc: 2b01         	cmp	r3, #0x1
 80051de: d101         	bne	0x80051e4 <log_output_process+0x5c> @ imm = #0x2
 80051e0: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800523c <log_output_process+0xb4>
 80051e2: e000         	b	0x80051e6 <log_output_process+0x5e> @ imm = #0x0
 80051e4: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8005240 <log_output_process+0xb8>
 80051e6: 61bb         	str	r3, [r7, #0x18]
; 	if (package) {
 80051e8: 6b3b         	ldr	r3, [r7, #0x30]
 80051ea: 2b00         	cmp	r3, #0x0
 80051ec: d005         	beq	0x80051fa <log_output_process+0x72> @ imm = #0xa
; 		int err = cbpprintf(cb, (void *)output, (void *)package);
 80051ee: 6b3a         	ldr	r2, [r7, #0x30]
 80051f0: 68f9         	ldr	r1, [r7, #0xc]
 80051f2: 69b8         	ldr	r0, [r7, #0x18]
 80051f4: f7ff fd5a    	bl	0x8004cac <cbpprintf>   @ imm = #-0x54c
 80051f8: 6138         	str	r0, [r7, #0x10]
; 	if (data_len) {
 80051fa: 6bbb         	ldr	r3, [r7, #0x38]
 80051fc: 2b00         	cmp	r3, #0x0
 80051fe: d008         	beq	0x8005212 <log_output_process+0x8a> @ imm = #0x10
; 		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
 8005200: 69fa         	ldr	r2, [r7, #0x1c]
 8005202: 6bfb         	ldr	r3, [r7, #0x3c]
 8005204: 9300         	str	r3, [sp]
 8005206: 4613         	mov	r3, r2
 8005208: 6bba         	ldr	r2, [r7, #0x38]
 800520a: 6b79         	ldr	r1, [r7, #0x34]
 800520c: 68f8         	ldr	r0, [r7, #0xc]
 800520e: f017 ffe1    	bl	0x801d1d4 <log_msg_hexdump> @ imm = #0x17fc2
; 	if (!raw_string) {
 8005212: 7dfb         	ldrb	r3, [r7, #0x17]
 8005214: f083 0301    	eor	r3, r3, #0x1
 8005218: b2db         	uxtb	r3, r3
 800521a: 2b00         	cmp	r3, #0x0
 800521c: d006         	beq	0x800522c <log_output_process+0xa4> @ imm = #0xc
; 		postfix_print(output, flags, level);
 800521e: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8005222: 461a         	mov	r2, r3
 8005224: 6bf9         	ldr	r1, [r7, #0x3c]
 8005226: 68f8         	ldr	r0, [r7, #0xc]
 8005228: f017 fff8    	bl	0x801d21c <postfix_print> @ imm = #0x17ff0
; 	log_output_flush(output);
 800522c: 68f8         	ldr	r0, [r7, #0xc]
 800522e: f017 ff69    	bl	0x801d104 <log_output_flush> @ imm = #0x17ed2
; }
 8005232: bf00         	nop
 8005234: 3720         	adds	r7, #0x20
 8005236: 46bd         	mov	sp, r7
 8005238: bd80         	pop	{r7, pc}
 800523a: bf00         	nop

0800523c <$d>:
 800523c: 37 d1 01 08  	.word	0x0801d137
 8005240: 67 d1 01 08  	.word	0x0801d167

08005244 <log_output_timestamp_freq_set>:
; {
 8005244: b480         	push	{r7}
 8005246: b083         	sub	sp, #0xc
 8005248: af00         	add	r7, sp, #0x0
 800524a: 6078         	str	r0, [r7, #0x4]
; 	timestamp_div = 1U;
 800524c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8005280 <log_output_timestamp_freq_set+0x3c>
 800524e: 2201         	movs	r2, #0x1
 8005250: 601a         	str	r2, [r3]
; 	while (frequency > 1000000) {
 8005252: e007         	b	0x8005264 <log_output_timestamp_freq_set+0x20> @ imm = #0xe
; 		frequency /= 2U;
 8005254: 687b         	ldr	r3, [r7, #0x4]
 8005256: 085b         	lsrs	r3, r3, #0x1
 8005258: 607b         	str	r3, [r7, #0x4]
; 		timestamp_div *= 2U;
 800525a: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8005280 <log_output_timestamp_freq_set+0x3c>
 800525c: 681b         	ldr	r3, [r3]
 800525e: 005b         	lsls	r3, r3, #0x1
 8005260: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8005280 <log_output_timestamp_freq_set+0x3c>
 8005262: 6013         	str	r3, [r2]
; 	while (frequency > 1000000) {
 8005264: 687b         	ldr	r3, [r7, #0x4]
 8005266: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8005284 <log_output_timestamp_freq_set+0x40>
 8005268: 4293         	cmp	r3, r2
 800526a: d8f3         	bhi	0x8005254 <log_output_timestamp_freq_set+0x10> @ imm = #-0x1a
; 	freq = frequency;
 800526c: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8005288 <log_output_timestamp_freq_set+0x44>
 800526e: 687b         	ldr	r3, [r7, #0x4]
 8005270: 6013         	str	r3, [r2]
; }
 8005272: bf00         	nop
 8005274: 370c         	adds	r7, #0xc
 8005276: 46bd         	mov	sp, r7
 8005278: f85d 7b04    	ldr	r7, [sp], #4
 800527c: 4770         	bx	lr
 800527e: bf00         	nop

08005280 <$d>:
 8005280: 2c 28 00 24  	.word	0x2400282c
 8005284: 40 42 0f 00  	.word	0x000f4240
 8005288: 28 28 00 24  	.word	0x24002828

0800528c <char_out>:
; {
 800528c: b580         	push	{r7, lr}
 800528e: b088         	sub	sp, #0x20
 8005290: af00         	add	r7, sp, #0x0
 8005292: 60f8         	str	r0, [r7, #0xc]
 8005294: 60b9         	str	r1, [r7, #0x8]
 8005296: 607a         	str	r2, [r7, #0x4]
; 	const struct lbu_cb_ctx *cb_ctx = ctx;
 8005298: 687b         	ldr	r3, [r7, #0x4]
 800529a: 61bb         	str	r3, [r7, #0x18]
; 	struct lbu_data *lb_data = cb_ctx->data;
 800529c: 69bb         	ldr	r3, [r7, #0x18]
 800529e: 685b         	ldr	r3, [r3, #0x4]
 80052a0: 617b         	str	r3, [r7, #0x14]
; 	const struct device *uart_dev = LBU_UART_DEV(cb_ctx);
 80052a2: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80052f8 <char_out+0x6c>
 80052a4: 613b         	str	r3, [r7, #0x10]
; 	if (pm_device_runtime_get(uart_dev) < 0) {
 80052a6: 6938         	ldr	r0, [r7, #0x10]
 80052a8: f018 f8b2    	bl	0x801d410 <pm_device_runtime_get> @ imm = #0x18164
 80052ac: 4603         	mov	r3, r0
 80052ae: 2b00         	cmp	r3, #0x0
 80052b0: da01         	bge	0x80052b6 <char_out+0x2a> @ imm = #0x2
; 		return length;
 80052b2: 68b9         	ldr	r1, [r7, #0x8]
 80052b4: e01a         	b	0x80052ec <char_out+0x60> @ imm = #0x34
; 		for (size_t i = 0; i < length; i++) {
 80052b6: 2300         	movs	r3, #0x0
 80052b8: 61fb         	str	r3, [r7, #0x1c]
 80052ba: e00a         	b	0x80052d2 <char_out+0x46> @ imm = #0x14
; 			uart_poll_out(uart_dev, data[i]);
 80052bc: 68fa         	ldr	r2, [r7, #0xc]
 80052be: 69fb         	ldr	r3, [r7, #0x1c]
 80052c0: 4413         	add	r3, r2
 80052c2: 781b         	ldrb	r3, [r3]
 80052c4: 4619         	mov	r1, r3
 80052c6: 6938         	ldr	r0, [r7, #0x10]
 80052c8: f018 f893    	bl	0x801d3f2 <uart_poll_out> @ imm = #0x18126
; 		for (size_t i = 0; i < length; i++) {
 80052cc: 69fb         	ldr	r3, [r7, #0x1c]
 80052ce: 3301         	adds	r3, #0x1
 80052d0: 61fb         	str	r3, [r7, #0x1c]
 80052d2: 69fa         	ldr	r2, [r7, #0x1c]
 80052d4: 68bb         	ldr	r3, [r7, #0x8]
 80052d6: 429a         	cmp	r2, r3
 80052d8: d3f0         	blo	0x80052bc <char_out+0x30> @ imm = #-0x20
; 		goto cleanup;
 80052da: bf00         	nop
; 	(void)pm_device_runtime_put_async(uart_dev, K_MSEC(1));
 80052dc: f04f 020a    	mov.w	r2, #0xa
 80052e0: f04f 0300    	mov.w	r3, #0x0
 80052e4: 6938         	ldr	r0, [r7, #0x10]
 80052e6: f018 f89e    	bl	0x801d426 <pm_device_runtime_put_async> @ imm = #0x1813c
; 	return length;
 80052ea: 68b9         	ldr	r1, [r7, #0x8]
; }
 80052ec: 460b         	mov	r3, r1
 80052ee: 4618         	mov	r0, r3
 80052f0: 3720         	adds	r7, #0x20
 80052f2: 46bd         	mov	sp, r7
 80052f4: bd80         	pop	{r7, pc}
 80052f6: bf00         	nop

080052f8 <$d>:
 80052f8: 3c 98 02 08  	.word	0x0802983c

080052fc <log_backend_uart_init>:
; {
 80052fc: b580         	push	{r7, lr}
 80052fe: b086         	sub	sp, #0x18
 8005300: af00         	add	r7, sp, #0x0
 8005302: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8005304: 687b         	ldr	r3, [r7, #0x4]
 8005306: 685b         	ldr	r3, [r3, #0x4]
 8005308: 681b         	ldr	r3, [r3]
 800530a: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 800530c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005328 <log_backend_uart_init+0x2c>
 800530e: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 8005310: 693b         	ldr	r3, [r7, #0x10]
 8005312: 685b         	ldr	r3, [r3, #0x4]
 8005314: 617b         	str	r3, [r7, #0x14]
; 	log_output_ctx_set(ctx->output, (void *)ctx);
 8005316: 693b         	ldr	r3, [r7, #0x10]
 8005318: 681b         	ldr	r3, [r3]
 800531a: 6939         	ldr	r1, [r7, #0x10]
 800531c: 4618         	mov	r0, r3
 800531e: f018 f827    	bl	0x801d370 <log_output_ctx_set> @ imm = #0x1804e
; }
 8005322: 3718         	adds	r7, #0x18
 8005324: 46bd         	mov	sp, r7
 8005326: bd80         	pop	{r7, pc}

08005328 <$d>:
 8005328: 3c 98 02 08  	.word	0x0802983c

0800532c <panic>:
; {
 800532c: b580         	push	{r7, lr}
 800532e: b086         	sub	sp, #0x18
 8005330: af00         	add	r7, sp, #0x0
 8005332: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8005334: 687b         	ldr	r3, [r7, #0x4]
 8005336: 685b         	ldr	r3, [r3, #0x4]
 8005338: 681b         	ldr	r3, [r3]
 800533a: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 800533c: 697b         	ldr	r3, [r7, #0x14]
 800533e: 685b         	ldr	r3, [r3, #0x4]
 8005340: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 8005342: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8005360 <panic+0x34>
 8005344: 60fb         	str	r3, [r7, #0xc]
; 	data->in_panic = true;
 8005346: 693b         	ldr	r3, [r7, #0x10]
 8005348: 2201         	movs	r2, #0x1
 800534a: 751a         	strb	r2, [r3, #0x14]
; 	log_backend_std_panic(ctx->output);
 800534c: 697b         	ldr	r3, [r7, #0x14]
 800534e: 681b         	ldr	r3, [r3]
 8005350: 4618         	mov	r0, r3
 8005352: f018 f830    	bl	0x801d3b6 <log_backend_std_panic> @ imm = #0x18060
; }
 8005356: bf00         	nop
 8005358: 3718         	adds	r7, #0x18
 800535a: 46bd         	mov	sp, r7
 800535c: bd80         	pop	{r7, pc}
 800535e: bf00         	nop

08005360 <$d>:
 8005360: 3c 98 02 08  	.word	0x0802983c

08005364 <esf_dump>:
; {
 8005364: b5f0         	push	{r4, r5, r6, r7, lr}
 8005366: b09d         	sub	sp, #0x74
 8005368: af0c         	add	r7, sp, #0x30
 800536a: 6078         	str	r0, [r7, #0x4]
; 	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
 800536c: 2303         	movs	r3, #0x3
 800536e: 2b00         	cmp	r3, #0x0
 8005370: d020         	beq	0x80053b4 <esf_dump+0x50> @ imm = #0x40
 8005372: 2301         	movs	r3, #0x1
 8005374: 77fb         	strb	r3, [r7, #0x1f]
 8005376: 7ffb         	ldrb	r3, [r7, #0x1f]
 8005378: f083 0301    	eor	r3, r3, #0x1
 800537c: b2db         	uxtb	r3, r3
 800537e: 2b00         	cmp	r3, #0x0
 8005380: d118         	bne	0x80053b4 <esf_dump+0x50> @ imm = #0x30
 8005382: 4b76         	ldr	r3, [pc, #0x1d8]        @ 0x800555c <esf_dump+0x1f8>
 8005384: 6818         	ldr	r0, [r3]
 8005386: 687b         	ldr	r3, [r7, #0x4]
 8005388: 681b         	ldr	r3, [r3]
 800538a: 687a         	ldr	r2, [r7, #0x4]
 800538c: 6852         	ldr	r2, [r2, #0x4]
 800538e: 6879         	ldr	r1, [r7, #0x4]
 8005390: 6889         	ldr	r1, [r1, #0x8]
 8005392: 9105         	str	r1, [sp, #0x14]
 8005394: 9204         	str	r2, [sp, #0x10]
 8005396: 9303         	str	r3, [sp, #0xc]
 8005398: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8005560 <esf_dump+0x1fc>
 800539a: 9302         	str	r3, [sp, #0x8]
 800539c: 2300         	movs	r3, #0x0
 800539e: 9301         	str	r3, [sp, #0x4]
 80053a0: 2300         	movs	r3, #0x0
 80053a2: 9300         	str	r3, [sp]
 80053a4: 2300         	movs	r3, #0x0
 80053a6: 2201         	movs	r2, #0x1
 80053a8: 4601         	mov	r1, r0
 80053aa: 2000         	movs	r0, #0x0
 80053ac: f018 f87d    	bl	0x801d4aa <z_log_msg_runtime_create> @ imm = #0x180fa
 80053b0: 2300         	movs	r3, #0x0
 80053b2: 61bb         	str	r3, [r7, #0x18]
; 	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
 80053b4: 2303         	movs	r3, #0x3
 80053b6: 2b00         	cmp	r3, #0x0
 80053b8: d020         	beq	0x80053fc <esf_dump+0x98> @ imm = #0x40
 80053ba: 2301         	movs	r3, #0x1
 80053bc: 75fb         	strb	r3, [r7, #0x17]
 80053be: 7dfb         	ldrb	r3, [r7, #0x17]
 80053c0: f083 0301    	eor	r3, r3, #0x1
 80053c4: b2db         	uxtb	r3, r3
 80053c6: 2b00         	cmp	r3, #0x0
 80053c8: d118         	bne	0x80053fc <esf_dump+0x98> @ imm = #0x30
 80053ca: 4b64         	ldr	r3, [pc, #0x190]        @ 0x800555c <esf_dump+0x1f8>
 80053cc: 6818         	ldr	r0, [r3]
 80053ce: 687b         	ldr	r3, [r7, #0x4]
 80053d0: 68db         	ldr	r3, [r3, #0xc]
 80053d2: 687a         	ldr	r2, [r7, #0x4]
 80053d4: 6912         	ldr	r2, [r2, #0x10]
 80053d6: 6879         	ldr	r1, [r7, #0x4]
 80053d8: 6949         	ldr	r1, [r1, #0x14]
 80053da: 9105         	str	r1, [sp, #0x14]
 80053dc: 9204         	str	r2, [sp, #0x10]
 80053de: 9303         	str	r3, [sp, #0xc]
 80053e0: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8005564 <esf_dump+0x200>
 80053e2: 9302         	str	r3, [sp, #0x8]
 80053e4: 2300         	movs	r3, #0x0
 80053e6: 9301         	str	r3, [sp, #0x4]
 80053e8: 2300         	movs	r3, #0x0
 80053ea: 9300         	str	r3, [sp]
 80053ec: 2300         	movs	r3, #0x0
 80053ee: 2201         	movs	r2, #0x1
 80053f0: 4601         	mov	r1, r0
 80053f2: 2000         	movs	r0, #0x0
 80053f4: f018 f859    	bl	0x801d4aa <z_log_msg_runtime_create> @ imm = #0x180b2
 80053f8: 2300         	movs	r3, #0x0
 80053fa: 613b         	str	r3, [r7, #0x10]
; 	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
 80053fc: 2303         	movs	r3, #0x3
 80053fe: 2b00         	cmp	r3, #0x0
 8005400: d019         	beq	0x8005436 <esf_dump+0xd2> @ imm = #0x32
 8005402: 2301         	movs	r3, #0x1
 8005404: 73fb         	strb	r3, [r7, #0xf]
 8005406: 7bfb         	ldrb	r3, [r7, #0xf]
 8005408: f083 0301    	eor	r3, r3, #0x1
 800540c: b2db         	uxtb	r3, r3
 800540e: 2b00         	cmp	r3, #0x0
 8005410: d111         	bne	0x8005436 <esf_dump+0xd2> @ imm = #0x22
 8005412: 4b52         	ldr	r3, [pc, #0x148]        @ 0x800555c <esf_dump+0x1f8>
 8005414: 6819         	ldr	r1, [r3]
 8005416: 687b         	ldr	r3, [r7, #0x4]
 8005418: 69db         	ldr	r3, [r3, #0x1c]
 800541a: 9303         	str	r3, [sp, #0xc]
 800541c: 4b52         	ldr	r3, [pc, #0x148]        @ 0x8005568 <esf_dump+0x204>
 800541e: 9302         	str	r3, [sp, #0x8]
 8005420: 2300         	movs	r3, #0x0
 8005422: 9301         	str	r3, [sp, #0x4]
 8005424: 2300         	movs	r3, #0x0
 8005426: 9300         	str	r3, [sp]
 8005428: 2300         	movs	r3, #0x0
 800542a: 2201         	movs	r2, #0x1
 800542c: 2000         	movs	r0, #0x0
 800542e: f018 f83c    	bl	0x801d4aa <z_log_msg_runtime_create> @ imm = #0x18078
 8005432: 2300         	movs	r3, #0x0
 8005434: 63fb         	str	r3, [r7, #0x3c]
; 	for (int i = 0; i < ARRAY_SIZE(esf->fpu.s); i += 4) {
 8005436: 2300         	movs	r3, #0x0
 8005438: 63bb         	str	r3, [r7, #0x38]
 800543a: e048         	b	0x80054ce <esf_dump+0x16a> @ imm = #0x90
; 		LOG_ERR("s[%2d]:  0x%08x  s[%2d]:  0x%08x"
 800543c: 2303         	movs	r3, #0x3
 800543e: 2b00         	cmp	r3, #0x0
 8005440: d042         	beq	0x80054c8 <esf_dump+0x164> @ imm = #0x84
 8005442: 2301         	movs	r3, #0x1
 8005444: f887 3027    	strb.w	r3, [r7, #0x27]
 8005448: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800544c: f083 0301    	eor	r3, r3, #0x1
 8005450: b2db         	uxtb	r3, r3
 8005452: 2b00         	cmp	r3, #0x0
 8005454: d138         	bne	0x80054c8 <esf_dump+0x164> @ imm = #0x70
 8005456: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800555c <esf_dump+0x1f8>
 8005458: 681b         	ldr	r3, [r3]
 800545a: 603b         	str	r3, [r7]
 800545c: 687b         	ldr	r3, [r7, #0x4]
 800545e: 6bba         	ldr	r2, [r7, #0x38]
 8005460: 3208         	adds	r2, #0x8
 8005462: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8005466: 6bba         	ldr	r2, [r7, #0x38]
 8005468: 3201         	adds	r2, #0x1
 800546a: 6bb9         	ldr	r1, [r7, #0x38]
 800546c: 1c48         	adds	r0, r1, #0x1
 800546e: 6879         	ldr	r1, [r7, #0x4]
 8005470: 3008         	adds	r0, #0x8
 8005472: f851 1020    	ldr.w	r1, [r1, r0, lsl #2]
 8005476: 6bb8         	ldr	r0, [r7, #0x38]
 8005478: 3002         	adds	r0, #0x2
 800547a: 6bbc         	ldr	r4, [r7, #0x38]
 800547c: 1ca5         	adds	r5, r4, #0x2
 800547e: 687c         	ldr	r4, [r7, #0x4]
 8005480: 3508         	adds	r5, #0x8
 8005482: f854 4025    	ldr.w	r4, [r4, r5, lsl #2]
 8005486: 6bbd         	ldr	r5, [r7, #0x38]
 8005488: 3503         	adds	r5, #0x3
 800548a: 6bbe         	ldr	r6, [r7, #0x38]
 800548c: f106 0c03    	add.w	r12, r6, #0x3
 8005490: 687e         	ldr	r6, [r7, #0x4]
 8005492: f10c 0c08    	add.w	r12, r12, #0x8
 8005496: f856 602c    	ldr.w	r6, [r6, r12, lsl #2]
 800549a: 960a         	str	r6, [sp, #0x28]
 800549c: 9509         	str	r5, [sp, #0x24]
 800549e: 9408         	str	r4, [sp, #0x20]
 80054a0: 9007         	str	r0, [sp, #0x1c]
 80054a2: 9106         	str	r1, [sp, #0x18]
 80054a4: 9205         	str	r2, [sp, #0x14]
 80054a6: 9304         	str	r3, [sp, #0x10]
 80054a8: 6bbb         	ldr	r3, [r7, #0x38]
 80054aa: 9303         	str	r3, [sp, #0xc]
 80054ac: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800556c <esf_dump+0x208>
 80054ae: 9302         	str	r3, [sp, #0x8]
 80054b0: 2300         	movs	r3, #0x0
 80054b2: 9301         	str	r3, [sp, #0x4]
 80054b4: 2300         	movs	r3, #0x0
 80054b6: 9300         	str	r3, [sp]
 80054b8: 2300         	movs	r3, #0x0
 80054ba: 2201         	movs	r2, #0x1
 80054bc: 6839         	ldr	r1, [r7]
 80054be: 2000         	movs	r0, #0x0
 80054c0: f017 fff3    	bl	0x801d4aa <z_log_msg_runtime_create> @ imm = #0x17fe6
 80054c4: 2300         	movs	r3, #0x0
 80054c6: 623b         	str	r3, [r7, #0x20]
; 	for (int i = 0; i < ARRAY_SIZE(esf->fpu.s); i += 4) {
 80054c8: 6bbb         	ldr	r3, [r7, #0x38]
 80054ca: 3304         	adds	r3, #0x4
 80054cc: 63bb         	str	r3, [r7, #0x38]
 80054ce: 6bbb         	ldr	r3, [r7, #0x38]
 80054d0: 2b0f         	cmp	r3, #0xf
 80054d2: d9b3         	bls	0x800543c <esf_dump+0xd8> @ imm = #-0x9a
; 	LOG_ERR("fpscr:  0x%08x", esf->fpu.fpscr);
 80054d4: 2303         	movs	r3, #0x3
 80054d6: 2b00         	cmp	r3, #0x0
 80054d8: d01b         	beq	0x8005512 <esf_dump+0x1ae> @ imm = #0x36
 80054da: 2301         	movs	r3, #0x1
 80054dc: f887 3037    	strb.w	r3, [r7, #0x37]
 80054e0: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80054e4: f083 0301    	eor	r3, r3, #0x1
 80054e8: b2db         	uxtb	r3, r3
 80054ea: 2b00         	cmp	r3, #0x0
 80054ec: d111         	bne	0x8005512 <esf_dump+0x1ae> @ imm = #0x22
 80054ee: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800555c <esf_dump+0x1f8>
 80054f0: 6819         	ldr	r1, [r3]
 80054f2: 687b         	ldr	r3, [r7, #0x4]
 80054f4: 6e1b         	ldr	r3, [r3, #0x60]
 80054f6: 9303         	str	r3, [sp, #0xc]
 80054f8: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8005570 <esf_dump+0x20c>
 80054fa: 9302         	str	r3, [sp, #0x8]
 80054fc: 2300         	movs	r3, #0x0
 80054fe: 9301         	str	r3, [sp, #0x4]
 8005500: 2300         	movs	r3, #0x0
 8005502: 9300         	str	r3, [sp]
 8005504: 2300         	movs	r3, #0x0
 8005506: 2201         	movs	r2, #0x1
 8005508: 2000         	movs	r0, #0x0
 800550a: f017 ffce    	bl	0x801d4aa <z_log_msg_runtime_create> @ imm = #0x17f9c
 800550e: 2300         	movs	r3, #0x0
 8005510: 633b         	str	r3, [r7, #0x30]
; 	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
 8005512: 2303         	movs	r3, #0x3
 8005514: 2b00         	cmp	r3, #0x0
 8005516: d01c         	beq	0x8005552 <esf_dump+0x1ee> @ imm = #0x38
 8005518: 2301         	movs	r3, #0x1
 800551a: f887 302f    	strb.w	r3, [r7, #0x2f]
 800551e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8005522: f083 0301    	eor	r3, r3, #0x1
 8005526: b2db         	uxtb	r3, r3
 8005528: 2b00         	cmp	r3, #0x0
 800552a: d112         	bne	0x8005552 <esf_dump+0x1ee> @ imm = #0x24
 800552c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800555c <esf_dump+0x1f8>
 800552e: 6819         	ldr	r1, [r3]
 8005530: 687b         	ldr	r3, [r7, #0x4]
 8005532: 699b         	ldr	r3, [r3, #0x18]
 8005534: 9303         	str	r3, [sp, #0xc]
 8005536: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8005574 <esf_dump+0x210>
 8005538: 9302         	str	r3, [sp, #0x8]
 800553a: 2300         	movs	r3, #0x0
 800553c: 9301         	str	r3, [sp, #0x4]
 800553e: 2300         	movs	r3, #0x0
 8005540: 9300         	str	r3, [sp]
 8005542: 2300         	movs	r3, #0x0
 8005544: 2201         	movs	r2, #0x1
 8005546: 2000         	movs	r0, #0x0
 8005548: f017 ffaf    	bl	0x801d4aa <z_log_msg_runtime_create> @ imm = #0x17f5e
 800554c: 2300         	movs	r3, #0x0
 800554e: 62bb         	str	r3, [r7, #0x28]
; }
 8005550: bf00         	nop
 8005552: bf00         	nop
 8005554: 3744         	adds	r7, #0x44
 8005556: 46bd         	mov	sp, r7
 8005558: bdf0         	pop	{r4, r5, r6, r7, pc}
 800555a: bf00         	nop

0800555c <$d>:
 800555c: 64 06 00 24  	.word	0x24000664
 8005560: 08 a6 02 08  	.word	0x0802a608
 8005564: 38 a6 02 08  	.word	0x0802a638
 8005568: 68 a6 02 08  	.word	0x0802a668
 800556c: 78 a6 02 08  	.word	0x0802a678
 8005570: bc a6 02 08  	.word	0x0802a6bc
 8005574: cc a6 02 08  	.word	0x0802a6cc

08005578 <z_arm_fatal_error>:
; {
 8005578: b580         	push	{r7, lr}
 800557a: b08a         	sub	sp, #0x28
 800557c: af04         	add	r7, sp, #0x10
 800557e: 6078         	str	r0, [r7, #0x4]
 8005580: 6039         	str	r1, [r7]
; 	if (esf != NULL) {
 8005582: 683b         	ldr	r3, [r7]
 8005584: 2b00         	cmp	r3, #0x0
 8005586: d002         	beq	0x800558e <z_arm_fatal_error+0x16> @ imm = #0x4
; 		esf_dump(esf);
 8005588: 6838         	ldr	r0, [r7]
 800558a: f7ff feeb    	bl	0x8005364 <esf_dump>    @ imm = #-0x22a
; 	if (reason == K_ERR_SPURIOUS_IRQ) {
 800558e: 687b         	ldr	r3, [r7, #0x4]
 8005590: 2b01         	cmp	r3, #0x1
 8005592: d121         	bne	0x80055d8 <z_arm_fatal_error+0x60> @ imm = #0x42
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8005594: f3ef 8305    	mrs	r3, ipsr
 8005598: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 800559a: 68bb         	ldr	r3, [r7, #0x8]
; 		uint32_t irqn = __get_IPSR() - 16;
 800559c: 3b10         	subs	r3, #0x10
 800559e: 617b         	str	r3, [r7, #0x14]
; 		LOG_ERR("Unhandled IRQn: %d", irqn);
 80055a0: 2303         	movs	r3, #0x3
 80055a2: 2b00         	cmp	r3, #0x0
 80055a4: d018         	beq	0x80055d8 <z_arm_fatal_error+0x60> @ imm = #0x30
 80055a6: 2301         	movs	r3, #0x1
 80055a8: 74fb         	strb	r3, [r7, #0x13]
 80055aa: 7cfb         	ldrb	r3, [r7, #0x13]
 80055ac: f083 0301    	eor	r3, r3, #0x1
 80055b0: b2db         	uxtb	r3, r3
 80055b2: 2b00         	cmp	r3, #0x0
 80055b4: d110         	bne	0x80055d8 <z_arm_fatal_error+0x60> @ imm = #0x20
 80055b6: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80055e8 <z_arm_fatal_error+0x70>
 80055b8: 6819         	ldr	r1, [r3]
 80055ba: 697b         	ldr	r3, [r7, #0x14]
 80055bc: 9303         	str	r3, [sp, #0xc]
 80055be: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80055ec <z_arm_fatal_error+0x74>
 80055c0: 9302         	str	r3, [sp, #0x8]
 80055c2: 2300         	movs	r3, #0x0
 80055c4: 9301         	str	r3, [sp, #0x4]
 80055c6: 2300         	movs	r3, #0x0
 80055c8: 9300         	str	r3, [sp]
 80055ca: 2300         	movs	r3, #0x0
 80055cc: 2201         	movs	r2, #0x1
 80055ce: 2000         	movs	r0, #0x0
 80055d0: f017 ff6b    	bl	0x801d4aa <z_log_msg_runtime_create> @ imm = #0x17ed6
 80055d4: 2300         	movs	r3, #0x0
 80055d6: 60fb         	str	r3, [r7, #0xc]
; 	z_fatal_error(reason, esf);
 80055d8: 6839         	ldr	r1, [r7]
 80055da: 6878         	ldr	r0, [r7, #0x4]
 80055dc: f00e ff72    	bl	0x80144c4 <z_fatal_error> @ imm = #0xeee4
; }
 80055e0: bf00         	nop
 80055e2: 3718         	adds	r7, #0x18
 80055e4: 46bd         	mov	sp, r7
 80055e6: bd80         	pop	{r7, pc}

080055e8 <$d>:
 80055e8: 64 06 00 24  	.word	0x24000664
 80055ec: fc a6 02 08  	.word	0x0802a6fc

080055f0 <z_arm_nmi>:
; {
 80055f0: b580         	push	{r7, lr}
 80055f2: af00         	add	r7, sp, #0x0
; 	handler();
 80055f4: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8005604 <z_arm_nmi+0x14>
 80055f6: 681b         	ldr	r3, [r3]
 80055f8: 4798         	blx	r3
; 	z_arm_int_exit();
 80055fa: f000 f835    	bl	0x8005668 <z_arm_int_exit> @ imm = #0x6a
; }
 80055fe: bf00         	nop
 8005600: bd80         	pop	{r7, pc}
 8005602: bf00         	nop

08005604 <$d>:
 8005604: 68 06 00 24  	.word	0x24000668

08005608 <z_SysNmiOnReset>:
;     wfi
 8005608: bf30         	wfi
;     b z_SysNmiOnReset
 800560a: f7ff bffd    	b.w	0x8005608 <z_SysNmiOnReset> @ imm = #-0x6
 800560e: bf00         	nop

08005610 <z_tls_data_size>:
; {
 8005610: b480         	push	{r7}
 8005612: af00         	add	r7, sp, #0x0
; 	return (size_t)(uintptr_t)__tdata_size +
 8005614: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005624 <z_tls_data_size+0x14>
; 	       (size_t)(uintptr_t)__tbss_size;
 8005616: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005628 <z_tls_data_size+0x18>
; 	return (size_t)(uintptr_t)__tdata_size +
 8005618: 4413         	add	r3, r2
; }
 800561a: 4618         	mov	r0, r3
 800561c: 46bd         	mov	sp, r7
 800561e: f85d 7b04    	ldr	r7, [sp], #4
 8005622: 4770         	bx	lr

08005624 <$d>:
 8005624: 00 00 00 00  	.word	0x00000000
 8005628: 08 00 00 00  	.word	0x00000008

0800562c <z_tls_copy>:
; {
 800562c: b580         	push	{r7, lr}
 800562e: b082         	sub	sp, #0x8
 8005630: af00         	add	r7, sp, #0x0
 8005632: 6078         	str	r0, [r7, #0x4]
; 	memcpy(dest, __tdata_start, (size_t)(uintptr_t)__tdata_size);
 8005634: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800565c <z_tls_copy+0x30>
 8005636: 461a         	mov	r2, r3
 8005638: 4909         	ldr	r1, [pc, #0x24]         @ 0x8005660 <z_tls_copy+0x34>
 800563a: 6878         	ldr	r0, [r7, #0x4]
 800563c: f023 fd5a    	bl	0x80290f4 <memcpy>      @ imm = #0x23ab4
; 	dest += (size_t)(uintptr_t)__tdata_size;
 8005640: 4a06         	ldr	r2, [pc, #0x18]         @ 0x800565c <z_tls_copy+0x30>
 8005642: 687b         	ldr	r3, [r7, #0x4]
 8005644: 4413         	add	r3, r2
 8005646: 607b         	str	r3, [r7, #0x4]
; 	memset(dest, 0, (size_t)(uintptr_t)__tbss_size);
 8005648: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005664 <z_tls_copy+0x38>
 800564a: 461a         	mov	r2, r3
 800564c: 2100         	movs	r1, #0x0
 800564e: 6878         	ldr	r0, [r7, #0x4]
 8005650: f023 fd5e    	bl	0x8029110 <memset>      @ imm = #0x23abc
; }
 8005654: bf00         	nop
 8005656: 3708         	adds	r7, #0x8
 8005658: 46bd         	mov	sp, r7
 800565a: bd80         	pop	{r7, pc}

0800565c <$d>:
 800565c: 00 00 00 00  	.word	0x00000000
 8005660: 88 a2 02 08  	.word	0x0802a288
 8005664: 08 00 00 00  	.word	0x00000008

08005668 <z_arm_int_exit>:
; {
 8005668: b480         	push	{r7}
 800566a: af00         	add	r7, sp, #0x0
; 	if (_kernel.cpus->current->base.prio >= 0) {
 800566c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800569c <z_arm_int_exit+0x34>
 800566e: 689b         	ldr	r3, [r3, #0x8]
 8005670: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8005674: 2b00         	cmp	r3, #0x0
 8005676: db0b         	blt	0x8005690 <z_arm_int_exit+0x28> @ imm = #0x16
; 		if (_kernel.ready_q.cache != _kernel.cpus->current) {
 8005678: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800569c <z_arm_int_exit+0x34>
 800567a: 6a1a         	ldr	r2, [r3, #0x20]
 800567c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800569c <z_arm_int_exit+0x34>
 800567e: 689b         	ldr	r3, [r3, #0x8]
 8005680: 429a         	cmp	r2, r3
 8005682: d005         	beq	0x8005690 <z_arm_int_exit+0x28> @ imm = #0xa
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8005684: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80056a0 <z_arm_int_exit+0x38>
 8005686: 685b         	ldr	r3, [r3, #0x4]
 8005688: 4a05         	ldr	r2, [pc, #0x14]         @ 0x80056a0 <z_arm_int_exit+0x38>
 800568a: f043 5380    	orr	r3, r3, #0x10000000
 800568e: 6053         	str	r3, [r2, #0x4]
; }
 8005690: bf00         	nop
 8005692: 46bd         	mov	sp, r7
 8005694: f85d 7b04    	ldr	r7, [sp], #4
 8005698: 4770         	bx	lr
 800569a: bf00         	nop

0800569c <$d>:
 800569c: 60 20 00 24  	.word	0x24002060
 80056a0: 00 ed 00 e0  	.word	0xe000ed00

080056a4 <mem_manage_fault>:
; {
 80056a4: b580         	push	{r7, lr}
 80056a6: b09a         	sub	sp, #0x68
 80056a8: af04         	add	r7, sp, #0x10
 80056aa: 60f8         	str	r0, [r7, #0xc]
 80056ac: 60b9         	str	r1, [r7, #0x8]
 80056ae: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
 80056b0: 2310         	movs	r3, #0x10
 80056b2: 657b         	str	r3, [r7, #0x54]
; 	uint32_t mmfar = -EINVAL;
 80056b4: f06f 0315    	mvn	r3, #0x15
 80056b8: 653b         	str	r3, [r7, #0x50]
; 	PR_FAULT_INFO("***** MPU FAULT *****");
 80056ba: 2303         	movs	r3, #0x3
 80056bc: 2b00         	cmp	r3, #0x0
 80056be: d018         	beq	0x80056f2 <mem_manage_fault+0x4e> @ imm = #0x30
 80056c0: 2301         	movs	r3, #0x1
 80056c2: f887 304f    	strb.w	r3, [r7, #0x4f]
 80056c6: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 80056ca: f083 0301    	eor	r3, r3, #0x1
 80056ce: b2db         	uxtb	r3, r3
 80056d0: 2b00         	cmp	r3, #0x0
 80056d2: d10e         	bne	0x80056f2 <mem_manage_fault+0x4e> @ imm = #0x1c
 80056d4: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x8005908 <mem_manage_fault+0x264>
 80056d6: 6819         	ldr	r1, [r3]
 80056d8: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x800590c <mem_manage_fault+0x268>
 80056da: 9302         	str	r3, [sp, #0x8]
 80056dc: 2300         	movs	r3, #0x0
 80056de: 9301         	str	r3, [sp, #0x4]
 80056e0: 2300         	movs	r3, #0x0
 80056e2: 9300         	str	r3, [sp]
 80056e4: 2300         	movs	r3, #0x0
 80056e6: 2201         	movs	r2, #0x1
 80056e8: 2000         	movs	r0, #0x0
 80056ea: f017 ff30    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17e60
 80056ee: 2300         	movs	r3, #0x0
 80056f0: 64bb         	str	r3, [r7, #0x48]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 80056f2: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8005910 <mem_manage_fault+0x26c>
 80056f4: 6a9b         	ldr	r3, [r3, #0x28]
 80056f6: f003 0310    	and	r3, r3, #0x10
 80056fa: 2b00         	cmp	r3, #0x0
 80056fc: d01d         	beq	0x800573a <mem_manage_fault+0x96> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_STACKING;
 80056fe: 2311         	movs	r3, #0x11
 8005700: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error (context area might be"
 8005702: 2303         	movs	r3, #0x3
 8005704: 2b00         	cmp	r3, #0x0
 8005706: d018         	beq	0x800573a <mem_manage_fault+0x96> @ imm = #0x30
 8005708: 2301         	movs	r3, #0x1
 800570a: f887 3047    	strb.w	r3, [r7, #0x47]
 800570e: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8005712: f083 0301    	eor	r3, r3, #0x1
 8005716: b2db         	uxtb	r3, r3
 8005718: 2b00         	cmp	r3, #0x0
 800571a: d10e         	bne	0x800573a <mem_manage_fault+0x96> @ imm = #0x1c
 800571c: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x8005908 <mem_manage_fault+0x264>
 800571e: 6819         	ldr	r1, [r3]
 8005720: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x8005914 <mem_manage_fault+0x270>
 8005722: 9302         	str	r3, [sp, #0x8]
 8005724: 2300         	movs	r3, #0x0
 8005726: 9301         	str	r3, [sp, #0x4]
 8005728: 2300         	movs	r3, #0x0
 800572a: 9300         	str	r3, [sp]
 800572c: 2300         	movs	r3, #0x0
 800572e: 2201         	movs	r2, #0x1
 8005730: 2000         	movs	r0, #0x0
 8005732: f017 ff0c    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17e18
 8005736: 2300         	movs	r3, #0x0
 8005738: 643b         	str	r3, [r7, #0x40]
; 	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 800573a: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8005910 <mem_manage_fault+0x26c>
 800573c: 6a9b         	ldr	r3, [r3, #0x28]
 800573e: f003 0308    	and	r3, r3, #0x8
 8005742: 2b00         	cmp	r3, #0x0
 8005744: d01d         	beq	0x8005782 <mem_manage_fault+0xde> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_UNSTACKING;
 8005746: 2312         	movs	r3, #0x12
 8005748: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 800574a: 2303         	movs	r3, #0x3
 800574c: 2b00         	cmp	r3, #0x0
 800574e: d018         	beq	0x8005782 <mem_manage_fault+0xde> @ imm = #0x30
 8005750: 2301         	movs	r3, #0x1
 8005752: f887 303f    	strb.w	r3, [r7, #0x3f]
 8005756: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800575a: f083 0301    	eor	r3, r3, #0x1
 800575e: b2db         	uxtb	r3, r3
 8005760: 2b00         	cmp	r3, #0x0
 8005762: d10e         	bne	0x8005782 <mem_manage_fault+0xde> @ imm = #0x1c
 8005764: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8005908 <mem_manage_fault+0x264>
 8005766: 6819         	ldr	r1, [r3]
 8005768: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x8005918 <mem_manage_fault+0x274>
 800576a: 9302         	str	r3, [sp, #0x8]
 800576c: 2300         	movs	r3, #0x0
 800576e: 9301         	str	r3, [sp, #0x4]
 8005770: 2300         	movs	r3, #0x0
 8005772: 9300         	str	r3, [sp]
 8005774: 2300         	movs	r3, #0x0
 8005776: 2201         	movs	r2, #0x1
 8005778: 2000         	movs	r0, #0x0
 800577a: f017 fee8    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17dd0
 800577e: 2300         	movs	r3, #0x0
 8005780: 63bb         	str	r3, [r7, #0x38]
; 	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 8005782: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8005910 <mem_manage_fault+0x26c>
 8005784: 6a9b         	ldr	r3, [r3, #0x28]
 8005786: f003 0302    	and	r3, r3, #0x2
 800578a: 2b00         	cmp	r3, #0x0
 800578c: d04f         	beq	0x800582e <mem_manage_fault+0x18a> @ imm = #0x9e
; 		reason = K_ERR_ARM_MEM_DATA_ACCESS;
 800578e: 2313         	movs	r3, #0x13
 8005790: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Data Access Violation");
 8005792: 2303         	movs	r3, #0x3
 8005794: 2b00         	cmp	r3, #0x0
 8005796: d018         	beq	0x80057ca <mem_manage_fault+0x126> @ imm = #0x30
 8005798: 2301         	movs	r3, #0x1
 800579a: f887 3037    	strb.w	r3, [r7, #0x37]
 800579e: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80057a2: f083 0301    	eor	r3, r3, #0x1
 80057a6: b2db         	uxtb	r3, r3
 80057a8: 2b00         	cmp	r3, #0x0
 80057aa: d10e         	bne	0x80057ca <mem_manage_fault+0x126> @ imm = #0x1c
 80057ac: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8005908 <mem_manage_fault+0x264>
 80057ae: 6819         	ldr	r1, [r3]
 80057b0: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x800591c <mem_manage_fault+0x278>
 80057b2: 9302         	str	r3, [sp, #0x8]
 80057b4: 2300         	movs	r3, #0x0
 80057b6: 9301         	str	r3, [sp, #0x4]
 80057b8: 2300         	movs	r3, #0x0
 80057ba: 9300         	str	r3, [sp]
 80057bc: 2300         	movs	r3, #0x0
 80057be: 2201         	movs	r2, #0x1
 80057c0: 2000         	movs	r0, #0x0
 80057c2: f017 fec4    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17d88
 80057c6: 2300         	movs	r3, #0x0
 80057c8: 633b         	str	r3, [r7, #0x30]
; 		uint32_t temp = SCB->MMFAR;
 80057ca: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8005910 <mem_manage_fault+0x26c>
 80057cc: 6b5b         	ldr	r3, [r3, #0x34]
 80057ce: 62fb         	str	r3, [r7, #0x2c]
; 		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 80057d0: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8005910 <mem_manage_fault+0x26c>
 80057d2: 6a9b         	ldr	r3, [r3, #0x28]
 80057d4: f003 0380    	and	r3, r3, #0x80
 80057d8: 2b00         	cmp	r3, #0x0
 80057da: d028         	beq	0x800582e <mem_manage_fault+0x18a> @ imm = #0x50
; 			mmfar = temp;
 80057dc: 6afb         	ldr	r3, [r7, #0x2c]
 80057de: 653b         	str	r3, [r7, #0x50]
; 			PR_EXC("  MMFAR Address: 0x%x", mmfar);
 80057e0: 2303         	movs	r3, #0x3
 80057e2: 2b00         	cmp	r3, #0x0
 80057e4: d01a         	beq	0x800581c <mem_manage_fault+0x178> @ imm = #0x34
 80057e6: 2301         	movs	r3, #0x1
 80057e8: f887 302b    	strb.w	r3, [r7, #0x2b]
 80057ec: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80057f0: f083 0301    	eor	r3, r3, #0x1
 80057f4: b2db         	uxtb	r3, r3
 80057f6: 2b00         	cmp	r3, #0x0
 80057f8: d110         	bne	0x800581c <mem_manage_fault+0x178> @ imm = #0x20
 80057fa: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8005908 <mem_manage_fault+0x264>
 80057fc: 6819         	ldr	r1, [r3]
 80057fe: 6d3b         	ldr	r3, [r7, #0x50]
 8005800: 9303         	str	r3, [sp, #0xc]
 8005802: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x8005920 <mem_manage_fault+0x27c>
 8005804: 9302         	str	r3, [sp, #0x8]
 8005806: 2300         	movs	r3, #0x0
 8005808: 9301         	str	r3, [sp, #0x4]
 800580a: 2300         	movs	r3, #0x0
 800580c: 9300         	str	r3, [sp]
 800580e: 2300         	movs	r3, #0x0
 8005810: 2201         	movs	r2, #0x1
 8005812: 2000         	movs	r0, #0x0
 8005814: f017 fe9b    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17d36
 8005818: 2300         	movs	r3, #0x0
 800581a: 627b         	str	r3, [r7, #0x24]
; 			if (from_hard_fault != 0) {
 800581c: 68bb         	ldr	r3, [r7, #0x8]
 800581e: 2b00         	cmp	r3, #0x0
 8005820: d005         	beq	0x800582e <mem_manage_fault+0x18a> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 8005822: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8005910 <mem_manage_fault+0x26c>
 8005824: 6a9b         	ldr	r3, [r3, #0x28]
 8005826: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x8005910 <mem_manage_fault+0x26c>
 8005828: f023 0380    	bic	r3, r3, #0x80
 800582c: 6293         	str	r3, [r2, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 800582e: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8005910 <mem_manage_fault+0x26c>
 8005830: 6a9b         	ldr	r3, [r3, #0x28]
 8005832: f003 0301    	and	r3, r3, #0x1
 8005836: 2b00         	cmp	r3, #0x0
 8005838: d01d         	beq	0x8005876 <mem_manage_fault+0x1d2> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
 800583a: 2314         	movs	r3, #0x14
 800583c: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction Access Violation");
 800583e: 2303         	movs	r3, #0x3
 8005840: 2b00         	cmp	r3, #0x0
 8005842: d018         	beq	0x8005876 <mem_manage_fault+0x1d2> @ imm = #0x30
 8005844: 2301         	movs	r3, #0x1
 8005846: f887 3023    	strb.w	r3, [r7, #0x23]
 800584a: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800584e: f083 0301    	eor	r3, r3, #0x1
 8005852: b2db         	uxtb	r3, r3
 8005854: 2b00         	cmp	r3, #0x0
 8005856: d10e         	bne	0x8005876 <mem_manage_fault+0x1d2> @ imm = #0x1c
 8005858: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8005908 <mem_manage_fault+0x264>
 800585a: 6819         	ldr	r1, [r3]
 800585c: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8005924 <mem_manage_fault+0x280>
 800585e: 9302         	str	r3, [sp, #0x8]
 8005860: 2300         	movs	r3, #0x0
 8005862: 9301         	str	r3, [sp, #0x4]
 8005864: 2300         	movs	r3, #0x0
 8005866: 9300         	str	r3, [sp]
 8005868: 2300         	movs	r3, #0x0
 800586a: 2201         	movs	r2, #0x1
 800586c: 2000         	movs	r0, #0x0
 800586e: f017 fe6e    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17cdc
 8005872: 2300         	movs	r3, #0x0
 8005874: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 8005876: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8005910 <mem_manage_fault+0x26c>
 8005878: 6a9b         	ldr	r3, [r3, #0x28]
 800587a: f003 0320    	and	r3, r3, #0x20
 800587e: 2b00         	cmp	r3, #0x0
 8005880: d01b         	beq	0x80058ba <mem_manage_fault+0x216> @ imm = #0x36
; 		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
 8005882: 2315         	movs	r3, #0x15
 8005884: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO(
 8005886: 2303         	movs	r3, #0x3
 8005888: 2b00         	cmp	r3, #0x0
 800588a: d016         	beq	0x80058ba <mem_manage_fault+0x216> @ imm = #0x2c
 800588c: 2301         	movs	r3, #0x1
 800588e: 76fb         	strb	r3, [r7, #0x1b]
 8005890: 7efb         	ldrb	r3, [r7, #0x1b]
 8005892: f083 0301    	eor	r3, r3, #0x1
 8005896: b2db         	uxtb	r3, r3
 8005898: 2b00         	cmp	r3, #0x0
 800589a: d10e         	bne	0x80058ba <mem_manage_fault+0x216> @ imm = #0x1c
 800589c: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8005908 <mem_manage_fault+0x264>
 800589e: 6819         	ldr	r1, [r3]
 80058a0: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8005928 <mem_manage_fault+0x284>
 80058a2: 9302         	str	r3, [sp, #0x8]
 80058a4: 2300         	movs	r3, #0x0
 80058a6: 9301         	str	r3, [sp, #0x4]
 80058a8: 2300         	movs	r3, #0x0
 80058aa: 9300         	str	r3, [sp]
 80058ac: 2300         	movs	r3, #0x0
 80058ae: 2201         	movs	r2, #0x1
 80058b0: 2000         	movs	r0, #0x0
 80058b2: f017 fe4c    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17c98
 80058b6: 2300         	movs	r3, #0x0
 80058b8: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 80058ba: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8005910 <mem_manage_fault+0x26c>
 80058bc: 6a9b         	ldr	r3, [r3, #0x28]
 80058be: f003 0310    	and	r3, r3, #0x10
 80058c2: 2b00         	cmp	r3, #0x0
 80058c4: d101         	bne	0x80058ca <mem_manage_fault+0x226> @ imm = #0x2
; 		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
 80058c6: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8005910 <mem_manage_fault+0x26c>
 80058c8: 6a9b         	ldr	r3, [r3, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 80058ca: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8005910 <mem_manage_fault+0x26c>
 80058cc: 6a9b         	ldr	r3, [r3, #0x28]
 80058ce: f003 0320    	and	r3, r3, #0x20
 80058d2: 2b00         	cmp	r3, #0x0
 80058d4: d005         	beq	0x80058e2 <mem_manage_fault+0x23e> @ imm = #0xa
; 		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
 80058d6: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8005910 <mem_manage_fault+0x26c>
 80058d8: 6a5b         	ldr	r3, [r3, #0x24]
 80058da: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8005910 <mem_manage_fault+0x26c>
 80058dc: f423 5300    	bic	r3, r3, #0x2000
 80058e0: 6253         	str	r3, [r2, #0x24]
; 	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 80058e2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8005910 <mem_manage_fault+0x26c>
 80058e4: 6a9b         	ldr	r3, [r3, #0x28]
 80058e6: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8005910 <mem_manage_fault+0x26c>
 80058e8: f043 03ff    	orr	r3, r3, #0xff
 80058ec: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 80058ee: 2101         	movs	r1, #0x1
 80058f0: 68f8         	ldr	r0, [r7, #0xc]
 80058f2: f017 fe55    	bl	0x801d5a0 <memory_fault_recoverable> @ imm = #0x17caa
 80058f6: 4603         	mov	r3, r0
 80058f8: 461a         	mov	r2, r3
 80058fa: 687b         	ldr	r3, [r7, #0x4]
 80058fc: 701a         	strb	r2, [r3]
; 	return reason;
 80058fe: 6d7b         	ldr	r3, [r7, #0x54]
; }
 8005900: 4618         	mov	r0, r3
 8005902: 3758         	adds	r7, #0x58
 8005904: 46bd         	mov	sp, r7
 8005906: bd80         	pop	{r7, pc}

08005908 <$d>:
 8005908: 6c 06 00 24  	.word	0x2400066c
 800590c: 10 a7 02 08  	.word	0x0802a710
 8005910: 00 ed 00 e0  	.word	0xe000ed00
 8005914: 28 a7 02 08  	.word	0x0802a728
 8005918: 5c a7 02 08  	.word	0x0802a75c
 800591c: 70 a7 02 08  	.word	0x0802a770
 8005920: 88 a7 02 08  	.word	0x0802a788
 8005924: a0 a7 02 08  	.word	0x0802a7a0
 8005928: c0 a7 02 08  	.word	0x0802a7c0

0800592c <bus_fault>:
; {
 800592c: b580         	push	{r7, lr}
 800592e: b09a         	sub	sp, #0x68
 8005930: af04         	add	r7, sp, #0x10
 8005932: 60f8         	str	r0, [r7, #0xc]
 8005934: 60b9         	str	r1, [r7, #0x8]
 8005936: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
 8005938: 2316         	movs	r3, #0x16
 800593a: 657b         	str	r3, [r7, #0x54]
; 	PR_FAULT_INFO("***** BUS FAULT *****");
 800593c: 2303         	movs	r3, #0x3
 800593e: 2b00         	cmp	r3, #0x0
 8005940: d018         	beq	0x8005974 <bus_fault+0x48> @ imm = #0x30
 8005942: 2301         	movs	r3, #0x1
 8005944: f887 3053    	strb.w	r3, [r7, #0x53]
 8005948: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800594c: f083 0301    	eor	r3, r3, #0x1
 8005950: b2db         	uxtb	r3, r3
 8005952: 2b00         	cmp	r3, #0x0
 8005954: d10e         	bne	0x8005974 <bus_fault+0x48> @ imm = #0x1c
 8005956: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8005ba4 <bus_fault+0x278>
 8005958: 6819         	ldr	r1, [r3]
 800595a: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8005ba8 <bus_fault+0x27c>
 800595c: 9302         	str	r3, [sp, #0x8]
 800595e: 2300         	movs	r3, #0x0
 8005960: 9301         	str	r3, [sp, #0x4]
 8005962: 2300         	movs	r3, #0x0
 8005964: 9300         	str	r3, [sp]
 8005966: 2300         	movs	r3, #0x0
 8005968: 2201         	movs	r2, #0x1
 800596a: 2000         	movs	r0, #0x0
 800596c: f017 fdef    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17bde
 8005970: 2300         	movs	r3, #0x0
 8005972: 64fb         	str	r3, [r7, #0x4c]
; 	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 8005974: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8005bac <bus_fault+0x280>
 8005976: 6a9b         	ldr	r3, [r3, #0x28]
 8005978: f403 5380    	and	r3, r3, #0x1000
 800597c: 2b00         	cmp	r3, #0x0
 800597e: d01d         	beq	0x80059bc <bus_fault+0x90> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_STACKING;
 8005980: 2317         	movs	r3, #0x17
 8005982: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error");
 8005984: 2303         	movs	r3, #0x3
 8005986: 2b00         	cmp	r3, #0x0
 8005988: d018         	beq	0x80059bc <bus_fault+0x90> @ imm = #0x30
 800598a: 2301         	movs	r3, #0x1
 800598c: f887 304b    	strb.w	r3, [r7, #0x4b]
 8005990: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8005994: f083 0301    	eor	r3, r3, #0x1
 8005998: b2db         	uxtb	r3, r3
 800599a: 2b00         	cmp	r3, #0x0
 800599c: d10e         	bne	0x80059bc <bus_fault+0x90> @ imm = #0x1c
 800599e: 4b81         	ldr	r3, [pc, #0x204]        @ 0x8005ba4 <bus_fault+0x278>
 80059a0: 6819         	ldr	r1, [r3]
 80059a2: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x8005bb0 <bus_fault+0x284>
 80059a4: 9302         	str	r3, [sp, #0x8]
 80059a6: 2300         	movs	r3, #0x0
 80059a8: 9301         	str	r3, [sp, #0x4]
 80059aa: 2300         	movs	r3, #0x0
 80059ac: 9300         	str	r3, [sp]
 80059ae: 2300         	movs	r3, #0x0
 80059b0: 2201         	movs	r2, #0x1
 80059b2: 2000         	movs	r0, #0x0
 80059b4: f017 fdcb    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17b96
 80059b8: 2300         	movs	r3, #0x0
 80059ba: 647b         	str	r3, [r7, #0x44]
; 	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 80059bc: 4b7b         	ldr	r3, [pc, #0x1ec]        @ 0x8005bac <bus_fault+0x280>
 80059be: 6a9b         	ldr	r3, [r3, #0x28]
 80059c0: f403 6300    	and	r3, r3, #0x800
 80059c4: 2b00         	cmp	r3, #0x0
 80059c6: d01d         	beq	0x8005a04 <bus_fault+0xd8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_UNSTACKING;
 80059c8: 2318         	movs	r3, #0x18
 80059ca: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 80059cc: 2303         	movs	r3, #0x3
 80059ce: 2b00         	cmp	r3, #0x0
 80059d0: d018         	beq	0x8005a04 <bus_fault+0xd8> @ imm = #0x30
 80059d2: 2301         	movs	r3, #0x1
 80059d4: f887 3043    	strb.w	r3, [r7, #0x43]
 80059d8: f897 3043    	ldrb.w	r3, [r7, #0x43]
 80059dc: f083 0301    	eor	r3, r3, #0x1
 80059e0: b2db         	uxtb	r3, r3
 80059e2: 2b00         	cmp	r3, #0x0
 80059e4: d10e         	bne	0x8005a04 <bus_fault+0xd8> @ imm = #0x1c
 80059e6: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x8005ba4 <bus_fault+0x278>
 80059e8: 6819         	ldr	r1, [r3]
 80059ea: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8005bb4 <bus_fault+0x288>
 80059ec: 9302         	str	r3, [sp, #0x8]
 80059ee: 2300         	movs	r3, #0x0
 80059f0: 9301         	str	r3, [sp, #0x4]
 80059f2: 2300         	movs	r3, #0x0
 80059f4: 9300         	str	r3, [sp]
 80059f6: 2300         	movs	r3, #0x0
 80059f8: 2201         	movs	r2, #0x1
 80059fa: 2000         	movs	r0, #0x0
 80059fc: f017 fda7    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17b4e
 8005a00: 2300         	movs	r3, #0x0
 8005a02: 63fb         	str	r3, [r7, #0x3c]
; 	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 8005a04: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8005bac <bus_fault+0x280>
 8005a06: 6a9b         	ldr	r3, [r3, #0x28]
 8005a08: f403 7300    	and	r3, r3, #0x200
 8005a0c: 2b00         	cmp	r3, #0x0
 8005a0e: d04d         	beq	0x8005aac <bus_fault+0x180> @ imm = #0x9a
; 		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
 8005a10: 2319         	movs	r3, #0x19
 8005a12: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Precise data bus error");
 8005a14: 2303         	movs	r3, #0x3
 8005a16: 2b00         	cmp	r3, #0x0
 8005a18: d018         	beq	0x8005a4c <bus_fault+0x120> @ imm = #0x30
 8005a1a: 2301         	movs	r3, #0x1
 8005a1c: f887 303b    	strb.w	r3, [r7, #0x3b]
 8005a20: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8005a24: f083 0301    	eor	r3, r3, #0x1
 8005a28: b2db         	uxtb	r3, r3
 8005a2a: 2b00         	cmp	r3, #0x0
 8005a2c: d10e         	bne	0x8005a4c <bus_fault+0x120> @ imm = #0x1c
 8005a2e: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8005ba4 <bus_fault+0x278>
 8005a30: 6819         	ldr	r1, [r3]
 8005a32: 4b61         	ldr	r3, [pc, #0x184]        @ 0x8005bb8 <bus_fault+0x28c>
 8005a34: 9302         	str	r3, [sp, #0x8]
 8005a36: 2300         	movs	r3, #0x0
 8005a38: 9301         	str	r3, [sp, #0x4]
 8005a3a: 2300         	movs	r3, #0x0
 8005a3c: 9300         	str	r3, [sp]
 8005a3e: 2300         	movs	r3, #0x0
 8005a40: 2201         	movs	r2, #0x1
 8005a42: 2000         	movs	r0, #0x0
 8005a44: f017 fd83    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17b06
 8005a48: 2300         	movs	r3, #0x0
 8005a4a: 637b         	str	r3, [r7, #0x34]
; 		STORE_xFAR(bfar, SCB->BFAR);
 8005a4c: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8005bac <bus_fault+0x280>
 8005a4e: 6b9b         	ldr	r3, [r3, #0x38]
 8005a50: 633b         	str	r3, [r7, #0x30]
; 		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 8005a52: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8005bac <bus_fault+0x280>
 8005a54: 6a9b         	ldr	r3, [r3, #0x28]
 8005a56: f403 4300    	and	r3, r3, #0x8000
 8005a5a: 2b00         	cmp	r3, #0x0
 8005a5c: d026         	beq	0x8005aac <bus_fault+0x180> @ imm = #0x4c
; 			PR_EXC("  BFAR Address: 0x%x", bfar);
 8005a5e: 2303         	movs	r3, #0x3
 8005a60: 2b00         	cmp	r3, #0x0
 8005a62: d01a         	beq	0x8005a9a <bus_fault+0x16e> @ imm = #0x34
 8005a64: 2301         	movs	r3, #0x1
 8005a66: f887 302f    	strb.w	r3, [r7, #0x2f]
 8005a6a: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8005a6e: f083 0301    	eor	r3, r3, #0x1
 8005a72: b2db         	uxtb	r3, r3
 8005a74: 2b00         	cmp	r3, #0x0
 8005a76: d110         	bne	0x8005a9a <bus_fault+0x16e> @ imm = #0x20
 8005a78: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x8005ba4 <bus_fault+0x278>
 8005a7a: 6819         	ldr	r1, [r3]
 8005a7c: 6b3b         	ldr	r3, [r7, #0x30]
 8005a7e: 9303         	str	r3, [sp, #0xc]
 8005a80: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8005bbc <bus_fault+0x290>
 8005a82: 9302         	str	r3, [sp, #0x8]
 8005a84: 2300         	movs	r3, #0x0
 8005a86: 9301         	str	r3, [sp, #0x4]
 8005a88: 2300         	movs	r3, #0x0
 8005a8a: 9300         	str	r3, [sp]
 8005a8c: 2300         	movs	r3, #0x0
 8005a8e: 2201         	movs	r2, #0x1
 8005a90: 2000         	movs	r0, #0x0
 8005a92: f017 fd5c    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17ab8
 8005a96: 2300         	movs	r3, #0x0
 8005a98: 62bb         	str	r3, [r7, #0x28]
; 			if (from_hard_fault != 0) {
 8005a9a: 68bb         	ldr	r3, [r7, #0x8]
 8005a9c: 2b00         	cmp	r3, #0x0
 8005a9e: d005         	beq	0x8005aac <bus_fault+0x180> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 8005aa0: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8005bac <bus_fault+0x280>
 8005aa2: 6a9b         	ldr	r3, [r3, #0x28]
 8005aa4: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8005bac <bus_fault+0x280>
 8005aa6: f423 4300    	bic	r3, r3, #0x8000
 8005aaa: 6293         	str	r3, [r2, #0x28]
; 	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 8005aac: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x8005bac <bus_fault+0x280>
 8005aae: 6a9b         	ldr	r3, [r3, #0x28]
 8005ab0: f403 6380    	and	r3, r3, #0x400
 8005ab4: 2b00         	cmp	r3, #0x0
 8005ab6: d01d         	beq	0x8005af4 <bus_fault+0x1c8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
 8005ab8: 231a         	movs	r3, #0x1a
 8005aba: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Imprecise data bus error");
 8005abc: 2303         	movs	r3, #0x3
 8005abe: 2b00         	cmp	r3, #0x0
 8005ac0: d018         	beq	0x8005af4 <bus_fault+0x1c8> @ imm = #0x30
 8005ac2: 2301         	movs	r3, #0x1
 8005ac4: f887 3027    	strb.w	r3, [r7, #0x27]
 8005ac8: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8005acc: f083 0301    	eor	r3, r3, #0x1
 8005ad0: b2db         	uxtb	r3, r3
 8005ad2: 2b00         	cmp	r3, #0x0
 8005ad4: d10e         	bne	0x8005af4 <bus_fault+0x1c8> @ imm = #0x1c
 8005ad6: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8005ba4 <bus_fault+0x278>
 8005ad8: 6819         	ldr	r1, [r3]
 8005ada: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8005bc0 <bus_fault+0x294>
 8005adc: 9302         	str	r3, [sp, #0x8]
 8005ade: 2300         	movs	r3, #0x0
 8005ae0: 9301         	str	r3, [sp, #0x4]
 8005ae2: 2300         	movs	r3, #0x0
 8005ae4: 9300         	str	r3, [sp]
 8005ae6: 2300         	movs	r3, #0x0
 8005ae8: 2201         	movs	r2, #0x1
 8005aea: 2000         	movs	r0, #0x0
 8005aec: f017 fd2f    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17a5e
 8005af0: 2300         	movs	r3, #0x0
 8005af2: 623b         	str	r3, [r7, #0x20]
; 	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 8005af4: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8005bac <bus_fault+0x280>
 8005af6: 6a9b         	ldr	r3, [r3, #0x28]
 8005af8: f403 7380    	and	r3, r3, #0x100
 8005afc: 2b00         	cmp	r3, #0x0
 8005afe: d01c         	beq	0x8005b3a <bus_fault+0x20e> @ imm = #0x38
; 		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
 8005b00: 231b         	movs	r3, #0x1b
 8005b02: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction bus error");
 8005b04: 2303         	movs	r3, #0x3
 8005b06: 2b00         	cmp	r3, #0x0
 8005b08: d039         	beq	0x8005b7e <bus_fault+0x252> @ imm = #0x72
 8005b0a: 2301         	movs	r3, #0x1
 8005b0c: 75fb         	strb	r3, [r7, #0x17]
 8005b0e: 7dfb         	ldrb	r3, [r7, #0x17]
 8005b10: f083 0301    	eor	r3, r3, #0x1
 8005b14: b2db         	uxtb	r3, r3
 8005b16: 2b00         	cmp	r3, #0x0
 8005b18: d131         	bne	0x8005b7e <bus_fault+0x252> @ imm = #0x62
 8005b1a: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8005ba4 <bus_fault+0x278>
 8005b1c: 6819         	ldr	r1, [r3]
 8005b1e: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8005bc4 <bus_fault+0x298>
 8005b20: 9302         	str	r3, [sp, #0x8]
 8005b22: 2300         	movs	r3, #0x0
 8005b24: 9301         	str	r3, [sp, #0x4]
 8005b26: 2300         	movs	r3, #0x0
 8005b28: 9300         	str	r3, [sp]
 8005b2a: 2300         	movs	r3, #0x0
 8005b2c: 2201         	movs	r2, #0x1
 8005b2e: 2000         	movs	r0, #0x0
 8005b30: f017 fd0d    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17a1a
 8005b34: 2300         	movs	r3, #0x0
 8005b36: 613b         	str	r3, [r7, #0x10]
 8005b38: e021         	b	0x8005b7e <bus_fault+0x252> @ imm = #0x42
; 	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
 8005b3a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8005bac <bus_fault+0x280>
 8005b3c: 6a9b         	ldr	r3, [r3, #0x28]
 8005b3e: f403 5300    	and	r3, r3, #0x2000
 8005b42: 2b00         	cmp	r3, #0x0
 8005b44: d01b         	beq	0x8005b7e <bus_fault+0x252> @ imm = #0x36
; 		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
 8005b46: 231c         	movs	r3, #0x1c
 8005b48: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Floating-point lazy state preservation error");
 8005b4a: 2303         	movs	r3, #0x3
 8005b4c: 2b00         	cmp	r3, #0x0
 8005b4e: d016         	beq	0x8005b7e <bus_fault+0x252> @ imm = #0x2c
 8005b50: 2301         	movs	r3, #0x1
 8005b52: 77fb         	strb	r3, [r7, #0x1f]
 8005b54: 7ffb         	ldrb	r3, [r7, #0x1f]
 8005b56: f083 0301    	eor	r3, r3, #0x1
 8005b5a: b2db         	uxtb	r3, r3
 8005b5c: 2b00         	cmp	r3, #0x0
 8005b5e: d10e         	bne	0x8005b7e <bus_fault+0x252> @ imm = #0x1c
 8005b60: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8005ba4 <bus_fault+0x278>
 8005b62: 6819         	ldr	r1, [r3]
 8005b64: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8005bc8 <bus_fault+0x29c>
 8005b66: 9302         	str	r3, [sp, #0x8]
 8005b68: 2300         	movs	r3, #0x0
 8005b6a: 9301         	str	r3, [sp, #0x4]
 8005b6c: 2300         	movs	r3, #0x0
 8005b6e: 9300         	str	r3, [sp]
 8005b70: 2300         	movs	r3, #0x0
 8005b72: 2201         	movs	r2, #0x1
 8005b74: 2000         	movs	r0, #0x0
 8005b76: f017 fcea    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x179d4
 8005b7a: 2300         	movs	r3, #0x0
 8005b7c: 61bb         	str	r3, [r7, #0x18]
; 	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 8005b7e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8005bac <bus_fault+0x280>
 8005b80: 6a9b         	ldr	r3, [r3, #0x28]
 8005b82: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8005bac <bus_fault+0x280>
 8005b84: f443 437f    	orr	r3, r3, #0xff00
 8005b88: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 8005b8a: 2101         	movs	r1, #0x1
 8005b8c: 68f8         	ldr	r0, [r7, #0xc]
 8005b8e: f017 fd07    	bl	0x801d5a0 <memory_fault_recoverable> @ imm = #0x17a0e
 8005b92: 4603         	mov	r3, r0
 8005b94: 461a         	mov	r2, r3
 8005b96: 687b         	ldr	r3, [r7, #0x4]
 8005b98: 701a         	strb	r2, [r3]
; 	return reason;
 8005b9a: 6d7b         	ldr	r3, [r7, #0x54]
; }
 8005b9c: 4618         	mov	r0, r3
 8005b9e: 3758         	adds	r7, #0x58
 8005ba0: 46bd         	mov	sp, r7
 8005ba2: bd80         	pop	{r7, pc}

08005ba4 <$d>:
 8005ba4: 6c 06 00 24  	.word	0x2400066c
 8005ba8: f0 a7 02 08  	.word	0x0802a7f0
 8005bac: 00 ed 00 e0  	.word	0xe000ed00
 8005bb0: 08 a8 02 08  	.word	0x0802a808
 8005bb4: 5c a7 02 08  	.word	0x0802a75c
 8005bb8: 1c a8 02 08  	.word	0x0802a81c
 8005bbc: 38 a8 02 08  	.word	0x0802a838
 8005bc0: 50 a8 02 08  	.word	0x0802a850
 8005bc4: 6c a8 02 08  	.word	0x0802a86c
 8005bc8: c0 a7 02 08  	.word	0x0802a7c0

08005bcc <usage_fault>:
; {
 8005bcc: b580         	push	{r7, lr}
 8005bce: b096         	sub	sp, #0x58
 8005bd0: af04         	add	r7, sp, #0x10
 8005bd2: 6078         	str	r0, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
 8005bd4: 231d         	movs	r3, #0x1d
 8005bd6: 647b         	str	r3, [r7, #0x44]
; 	PR_FAULT_INFO("***** USAGE FAULT *****");
 8005bd8: 2303         	movs	r3, #0x3
 8005bda: 2b00         	cmp	r3, #0x0
 8005bdc: d018         	beq	0x8005c10 <usage_fault+0x44> @ imm = #0x30
 8005bde: 2301         	movs	r3, #0x1
 8005be0: f887 3043    	strb.w	r3, [r7, #0x43]
 8005be4: f897 3043    	ldrb.w	r3, [r7, #0x43]
 8005be8: f083 0301    	eor	r3, r3, #0x1
 8005bec: b2db         	uxtb	r3, r3
 8005bee: 2b00         	cmp	r3, #0x0
 8005bf0: d10e         	bne	0x8005c10 <usage_fault+0x44> @ imm = #0x1c
 8005bf2: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x8005dd0 <usage_fault+0x204>
 8005bf4: 6819         	ldr	r1, [r3]
 8005bf6: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x8005dd4 <usage_fault+0x208>
 8005bf8: 9302         	str	r3, [sp, #0x8]
 8005bfa: 2300         	movs	r3, #0x0
 8005bfc: 9301         	str	r3, [sp, #0x4]
 8005bfe: 2300         	movs	r3, #0x0
 8005c00: 9300         	str	r3, [sp]
 8005c02: 2300         	movs	r3, #0x0
 8005c04: 2201         	movs	r2, #0x1
 8005c06: 2000         	movs	r0, #0x0
 8005c08: f017 fca1    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17942
 8005c0c: 2300         	movs	r3, #0x0
 8005c0e: 63fb         	str	r3, [r7, #0x3c]
; 	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 8005c10: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8005dd8 <usage_fault+0x20c>
 8005c12: 6a9b         	ldr	r3, [r3, #0x28]
 8005c14: f003 7300    	and	r3, r3, #0x2000000
 8005c18: 2b00         	cmp	r3, #0x0
 8005c1a: d01d         	beq	0x8005c58 <usage_fault+0x8c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_DIV_0;
 8005c1c: 231e         	movs	r3, #0x1e
 8005c1e: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Division by zero");
 8005c20: 2303         	movs	r3, #0x3
 8005c22: 2b00         	cmp	r3, #0x0
 8005c24: d018         	beq	0x8005c58 <usage_fault+0x8c> @ imm = #0x30
 8005c26: 2301         	movs	r3, #0x1
 8005c28: f887 303b    	strb.w	r3, [r7, #0x3b]
 8005c2c: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8005c30: f083 0301    	eor	r3, r3, #0x1
 8005c34: b2db         	uxtb	r3, r3
 8005c36: 2b00         	cmp	r3, #0x0
 8005c38: d10e         	bne	0x8005c58 <usage_fault+0x8c> @ imm = #0x1c
 8005c3a: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8005dd0 <usage_fault+0x204>
 8005c3c: 6819         	ldr	r1, [r3]
 8005c3e: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x8005ddc <usage_fault+0x210>
 8005c40: 9302         	str	r3, [sp, #0x8]
 8005c42: 2300         	movs	r3, #0x0
 8005c44: 9301         	str	r3, [sp, #0x4]
 8005c46: 2300         	movs	r3, #0x0
 8005c48: 9300         	str	r3, [sp]
 8005c4a: 2300         	movs	r3, #0x0
 8005c4c: 2201         	movs	r2, #0x1
 8005c4e: 2000         	movs	r0, #0x0
 8005c50: f017 fc7d    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x178fa
 8005c54: 2300         	movs	r3, #0x0
 8005c56: 637b         	str	r3, [r7, #0x34]
; 	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 8005c58: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x8005dd8 <usage_fault+0x20c>
 8005c5a: 6a9b         	ldr	r3, [r3, #0x28]
 8005c5c: f003 7380    	and	r3, r3, #0x1000000
 8005c60: 2b00         	cmp	r3, #0x0
 8005c62: d01d         	beq	0x8005ca0 <usage_fault+0xd4> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
 8005c64: 231f         	movs	r3, #0x1f
 8005c66: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Unaligned memory access");
 8005c68: 2303         	movs	r3, #0x3
 8005c6a: 2b00         	cmp	r3, #0x0
 8005c6c: d018         	beq	0x8005ca0 <usage_fault+0xd4> @ imm = #0x30
 8005c6e: 2301         	movs	r3, #0x1
 8005c70: f887 3033    	strb.w	r3, [r7, #0x33]
 8005c74: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8005c78: f083 0301    	eor	r3, r3, #0x1
 8005c7c: b2db         	uxtb	r3, r3
 8005c7e: 2b00         	cmp	r3, #0x0
 8005c80: d10e         	bne	0x8005ca0 <usage_fault+0xd4> @ imm = #0x1c
 8005c82: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8005dd0 <usage_fault+0x204>
 8005c84: 6819         	ldr	r1, [r3]
 8005c86: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8005de0 <usage_fault+0x214>
 8005c88: 9302         	str	r3, [sp, #0x8]
 8005c8a: 2300         	movs	r3, #0x0
 8005c8c: 9301         	str	r3, [sp, #0x4]
 8005c8e: 2300         	movs	r3, #0x0
 8005c90: 9300         	str	r3, [sp]
 8005c92: 2300         	movs	r3, #0x0
 8005c94: 2201         	movs	r2, #0x1
 8005c96: 2000         	movs	r0, #0x0
 8005c98: f017 fc59    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x178b2
 8005c9c: 2300         	movs	r3, #0x0
 8005c9e: 62fb         	str	r3, [r7, #0x2c]
; 	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 8005ca0: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x8005dd8 <usage_fault+0x20c>
 8005ca2: 6a9b         	ldr	r3, [r3, #0x28]
 8005ca4: f403 2300    	and	r3, r3, #0x80000
 8005ca8: 2b00         	cmp	r3, #0x0
 8005caa: d01d         	beq	0x8005ce8 <usage_fault+0x11c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
 8005cac: 2321         	movs	r3, #0x21
 8005cae: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  No coprocessor instructions");
 8005cb0: 2303         	movs	r3, #0x3
 8005cb2: 2b00         	cmp	r3, #0x0
 8005cb4: d018         	beq	0x8005ce8 <usage_fault+0x11c> @ imm = #0x30
 8005cb6: 2301         	movs	r3, #0x1
 8005cb8: f887 302b    	strb.w	r3, [r7, #0x2b]
 8005cbc: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8005cc0: f083 0301    	eor	r3, r3, #0x1
 8005cc4: b2db         	uxtb	r3, r3
 8005cc6: 2b00         	cmp	r3, #0x0
 8005cc8: d10e         	bne	0x8005ce8 <usage_fault+0x11c> @ imm = #0x1c
 8005cca: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8005dd0 <usage_fault+0x204>
 8005ccc: 6819         	ldr	r1, [r3]
 8005cce: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8005de4 <usage_fault+0x218>
 8005cd0: 9302         	str	r3, [sp, #0x8]
 8005cd2: 2300         	movs	r3, #0x0
 8005cd4: 9301         	str	r3, [sp, #0x4]
 8005cd6: 2300         	movs	r3, #0x0
 8005cd8: 9300         	str	r3, [sp]
 8005cda: 2300         	movs	r3, #0x0
 8005cdc: 2201         	movs	r2, #0x1
 8005cde: 2000         	movs	r0, #0x0
 8005ce0: f017 fc35    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x1786a
 8005ce4: 2300         	movs	r3, #0x0
 8005ce6: 627b         	str	r3, [r7, #0x24]
; 	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 8005ce8: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8005dd8 <usage_fault+0x20c>
 8005cea: 6a9b         	ldr	r3, [r3, #0x28]
 8005cec: f403 2380    	and	r3, r3, #0x40000
 8005cf0: 2b00         	cmp	r3, #0x0
 8005cf2: d01d         	beq	0x8005d30 <usage_fault+0x164> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
 8005cf4: 2322         	movs	r3, #0x22
 8005cf6: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
 8005cf8: 2303         	movs	r3, #0x3
 8005cfa: 2b00         	cmp	r3, #0x0
 8005cfc: d018         	beq	0x8005d30 <usage_fault+0x164> @ imm = #0x30
 8005cfe: 2301         	movs	r3, #0x1
 8005d00: f887 3023    	strb.w	r3, [r7, #0x23]
 8005d04: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8005d08: f083 0301    	eor	r3, r3, #0x1
 8005d0c: b2db         	uxtb	r3, r3
 8005d0e: 2b00         	cmp	r3, #0x0
 8005d10: d10e         	bne	0x8005d30 <usage_fault+0x164> @ imm = #0x1c
 8005d12: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8005dd0 <usage_fault+0x204>
 8005d14: 6819         	ldr	r1, [r3]
 8005d16: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8005de8 <usage_fault+0x21c>
 8005d18: 9302         	str	r3, [sp, #0x8]
 8005d1a: 2300         	movs	r3, #0x0
 8005d1c: 9301         	str	r3, [sp, #0x4]
 8005d1e: 2300         	movs	r3, #0x0
 8005d20: 9300         	str	r3, [sp]
 8005d22: 2300         	movs	r3, #0x0
 8005d24: 2201         	movs	r2, #0x1
 8005d26: 2000         	movs	r0, #0x0
 8005d28: f017 fc11    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17822
 8005d2c: 2300         	movs	r3, #0x0
 8005d2e: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 8005d30: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8005dd8 <usage_fault+0x20c>
 8005d32: 6a9b         	ldr	r3, [r3, #0x28]
 8005d34: f403 3300    	and	r3, r3, #0x20000
 8005d38: 2b00         	cmp	r3, #0x0
 8005d3a: d01b         	beq	0x8005d74 <usage_fault+0x1a8> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
 8005d3c: 2323         	movs	r3, #0x23
 8005d3e: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal use of the EPSR");
 8005d40: 2303         	movs	r3, #0x3
 8005d42: 2b00         	cmp	r3, #0x0
 8005d44: d016         	beq	0x8005d74 <usage_fault+0x1a8> @ imm = #0x2c
 8005d46: 2301         	movs	r3, #0x1
 8005d48: 76fb         	strb	r3, [r7, #0x1b]
 8005d4a: 7efb         	ldrb	r3, [r7, #0x1b]
 8005d4c: f083 0301    	eor	r3, r3, #0x1
 8005d50: b2db         	uxtb	r3, r3
 8005d52: 2b00         	cmp	r3, #0x0
 8005d54: d10e         	bne	0x8005d74 <usage_fault+0x1a8> @ imm = #0x1c
 8005d56: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8005dd0 <usage_fault+0x204>
 8005d58: 6819         	ldr	r1, [r3]
 8005d5a: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8005dec <usage_fault+0x220>
 8005d5c: 9302         	str	r3, [sp, #0x8]
 8005d5e: 2300         	movs	r3, #0x0
 8005d60: 9301         	str	r3, [sp, #0x4]
 8005d62: 2300         	movs	r3, #0x0
 8005d64: 9300         	str	r3, [sp]
 8005d66: 2300         	movs	r3, #0x0
 8005d68: 2201         	movs	r2, #0x1
 8005d6a: 2000         	movs	r0, #0x0
 8005d6c: f017 fbef    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x177de
 8005d70: 2300         	movs	r3, #0x0
 8005d72: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 8005d74: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8005dd8 <usage_fault+0x20c>
 8005d76: 6a9b         	ldr	r3, [r3, #0x28]
 8005d78: f403 3380    	and	r3, r3, #0x10000
 8005d7c: 2b00         	cmp	r3, #0x0
 8005d7e: d01b         	beq	0x8005db8 <usage_fault+0x1ec> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
 8005d80: 2324         	movs	r3, #0x24
 8005d82: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Attempt to execute undefined instruction");
 8005d84: 2303         	movs	r3, #0x3
 8005d86: 2b00         	cmp	r3, #0x0
 8005d88: d016         	beq	0x8005db8 <usage_fault+0x1ec> @ imm = #0x2c
 8005d8a: 2301         	movs	r3, #0x1
 8005d8c: 74fb         	strb	r3, [r7, #0x13]
 8005d8e: 7cfb         	ldrb	r3, [r7, #0x13]
 8005d90: f083 0301    	eor	r3, r3, #0x1
 8005d94: b2db         	uxtb	r3, r3
 8005d96: 2b00         	cmp	r3, #0x0
 8005d98: d10e         	bne	0x8005db8 <usage_fault+0x1ec> @ imm = #0x1c
 8005d9a: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8005dd0 <usage_fault+0x204>
 8005d9c: 6819         	ldr	r1, [r3]
 8005d9e: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8005df0 <usage_fault+0x224>
 8005da0: 9302         	str	r3, [sp, #0x8]
 8005da2: 2300         	movs	r3, #0x0
 8005da4: 9301         	str	r3, [sp, #0x4]
 8005da6: 2300         	movs	r3, #0x0
 8005da8: 9300         	str	r3, [sp]
 8005daa: 2300         	movs	r3, #0x0
 8005dac: 2201         	movs	r2, #0x1
 8005dae: 2000         	movs	r0, #0x0
 8005db0: f017 fbcd    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x1779a
 8005db4: 2300         	movs	r3, #0x0
 8005db6: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 8005db8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8005dd8 <usage_fault+0x20c>
 8005dba: 6a9a         	ldr	r2, [r3, #0x28]
 8005dbc: 4906         	ldr	r1, [pc, #0x18]         @ 0x8005dd8 <usage_fault+0x20c>
 8005dbe: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8005df4 <usage_fault+0x228>
 8005dc0: 4313         	orrs	r3, r2
 8005dc2: 628b         	str	r3, [r1, #0x28]
; 	return reason;
 8005dc4: 6c7b         	ldr	r3, [r7, #0x44]
; }
 8005dc6: 4618         	mov	r0, r3
 8005dc8: 3748         	adds	r7, #0x48
 8005dca: 46bd         	mov	sp, r7
 8005dcc: bd80         	pop	{r7, pc}
 8005dce: bf00         	nop

08005dd0 <$d>:
 8005dd0: 6c 06 00 24  	.word	0x2400066c
 8005dd4: 84 a8 02 08  	.word	0x0802a884
 8005dd8: 00 ed 00 e0  	.word	0xe000ed00
 8005ddc: 9c a8 02 08  	.word	0x0802a89c
 8005de0: b0 a8 02 08  	.word	0x0802a8b0
 8005de4: cc a8 02 08  	.word	0x0802a8cc
 8005de8: ec a8 02 08  	.word	0x0802a8ec
 8005dec: 14 a9 02 08  	.word	0x0802a914
 8005df0: 30 a9 02 08  	.word	0x0802a930
 8005df4: 00 00 ff ff  	.word	0xffff0000

08005df8 <debug_monitor>:
; {
 8005df8: b580         	push	{r7, lr}
 8005dfa: b088         	sub	sp, #0x20
 8005dfc: af04         	add	r7, sp, #0x10
 8005dfe: 6078         	str	r0, [r7, #0x4]
 8005e00: 6039         	str	r1, [r7]
; 	*recoverable = false;
 8005e02: 683b         	ldr	r3, [r7]
 8005e04: 2200         	movs	r2, #0x0
 8005e06: 701a         	strb	r2, [r3]
; 	PR_FAULT_INFO(
 8005e08: 2303         	movs	r3, #0x3
 8005e0a: 2b00         	cmp	r3, #0x0
 8005e0c: d017         	beq	0x8005e3e <debug_monitor+0x46> @ imm = #0x2e
 8005e0e: 2301         	movs	r3, #0x1
 8005e10: 73fb         	strb	r3, [r7, #0xf]
 8005e12: 7bfb         	ldrb	r3, [r7, #0xf]
 8005e14: f083 0301    	eor	r3, r3, #0x1
 8005e18: b2db         	uxtb	r3, r3
 8005e1a: 2b00         	cmp	r3, #0x0
 8005e1c: d10f         	bne	0x8005e3e <debug_monitor+0x46> @ imm = #0x1e
 8005e1e: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8005e48 <debug_monitor+0x50>
 8005e20: 6819         	ldr	r1, [r3]
 8005e22: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8005e4c <debug_monitor+0x54>
 8005e24: 9302         	str	r3, [sp, #0x8]
 8005e26: 2300         	movs	r3, #0x0
 8005e28: 9301         	str	r3, [sp, #0x4]
 8005e2a: 2300         	movs	r3, #0x0
 8005e2c: 9300         	str	r3, [sp]
 8005e2e: 2300         	movs	r3, #0x0
 8005e30: 2201         	movs	r2, #0x1
 8005e32: 2000         	movs	r0, #0x0
 8005e34: f017 fb8b    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17716
 8005e38: 2300         	movs	r3, #0x0
 8005e3a: 60bb         	str	r3, [r7, #0x8]
; }
 8005e3c: bf00         	nop
 8005e3e: bf00         	nop
 8005e40: 3710         	adds	r7, #0x10
 8005e42: 46bd         	mov	sp, r7
 8005e44: bd80         	pop	{r7, pc}
 8005e46: bf00         	nop

08005e48 <$d>:
 8005e48: 6c 06 00 24  	.word	0x2400066c
 8005e4c: 5c a9 02 08  	.word	0x0802a95c

08005e50 <z_arm_is_synchronous_svc>:
; {
 8005e50: b480         	push	{r7}
 8005e52: b085         	sub	sp, #0x14
 8005e54: af00         	add	r7, sp, #0x0
 8005e56: 6078         	str	r0, [r7, #0x4]
; 	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
 8005e58: 687b         	ldr	r3, [r7, #0x4]
 8005e5a: 699b         	ldr	r3, [r3, #0x18]
 8005e5c: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
 8005e5e: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8005ecc <z_arm_is_synchronous_svc+0x7c>
 8005e60: 695b         	ldr	r3, [r3, #0x14]
 8005e62: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x8005ecc <z_arm_is_synchronous_svc+0x7c>
 8005e64: f443 7380    	orr	r3, r3, #0x100
 8005e68: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 8005e6a: f3bf 8f4f    	dsb	sy
; }
 8005e6e: bf00         	nop
; }
 8005e70: bf00         	nop
; }
 8005e72: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8005e74: f3bf 8f6f    	isb	sy
; }
 8005e78: bf00         	nop
; }
 8005e7a: bf00         	nop
; }
 8005e7c: bf00         	nop
; 	uint16_t fault_insn = *(ret_addr - 1);
 8005e7e: 68fb         	ldr	r3, [r7, #0xc]
 8005e80: f833 3c02    	ldrh	r3, [r3, #-2]
 8005e84: 817b         	strh	r3, [r7, #0xa]
; 	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
 8005e86: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8005ecc <z_arm_is_synchronous_svc+0x7c>
 8005e88: 695b         	ldr	r3, [r3, #0x14]
 8005e8a: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8005ecc <z_arm_is_synchronous_svc+0x7c>
 8005e8c: f423 7380    	bic	r3, r3, #0x100
 8005e90: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 8005e92: f3bf 8f4f    	dsb	sy
; }
 8005e96: bf00         	nop
; }
 8005e98: bf00         	nop
; }
 8005e9a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8005e9c: f3bf 8f6f    	isb	sy
; }
 8005ea0: bf00         	nop
; }
 8005ea2: bf00         	nop
; }
 8005ea4: bf00         	nop
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 8005ea6: 897b         	ldrh	r3, [r7, #0xa]
 8005ea8: f403 437f    	and	r3, r3, #0xff00
 8005eac: f5b3 4f5f    	cmp.w	r3, #0xdf00
 8005eb0: d105         	bne	0x8005ebe <z_arm_is_synchronous_svc+0x6e> @ imm = #0xa
; 		((fault_insn & 0x00ff) == _SVC_CALL_RUNTIME_EXCEPT)) {
 8005eb2: 897b         	ldrh	r3, [r7, #0xa]
 8005eb4: b2db         	uxtb	r3, r3
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 8005eb6: 2b02         	cmp	r3, #0x2
 8005eb8: d101         	bne	0x8005ebe <z_arm_is_synchronous_svc+0x6e> @ imm = #0x2
; 		return true;
 8005eba: 2301         	movs	r3, #0x1
 8005ebc: e000         	b	0x8005ec0 <z_arm_is_synchronous_svc+0x70> @ imm = #0x0
; 	return false;
 8005ebe: 2300         	movs	r3, #0x0
; }
 8005ec0: 4618         	mov	r0, r3
 8005ec2: 3714         	adds	r7, #0x14
 8005ec4: 46bd         	mov	sp, r7
 8005ec6: f85d 7b04    	ldr	r7, [sp], #4
 8005eca: 4770         	bx	lr

08005ecc <$d>:
 8005ecc: 00 ed 00 e0  	.word	0xe000ed00

08005ed0 <hard_fault>:
; {
 8005ed0: b580         	push	{r7, lr}
 8005ed2: b092         	sub	sp, #0x48
 8005ed4: af04         	add	r7, sp, #0x10
 8005ed6: 6078         	str	r0, [r7, #0x4]
 8005ed8: 6039         	str	r1, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8005eda: 2300         	movs	r3, #0x0
 8005edc: 62fb         	str	r3, [r7, #0x2c]
; 	PR_FAULT_INFO("***** HARD FAULT *****");
 8005ede: 2303         	movs	r3, #0x3
 8005ee0: 2b00         	cmp	r3, #0x0
 8005ee2: d018         	beq	0x8005f16 <hard_fault+0x46> @ imm = #0x30
 8005ee4: 2301         	movs	r3, #0x1
 8005ee6: f887 3033    	strb.w	r3, [r7, #0x33]
 8005eea: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8005eee: f083 0301    	eor	r3, r3, #0x1
 8005ef2: b2db         	uxtb	r3, r3
 8005ef4: 2b00         	cmp	r3, #0x0
 8005ef6: d10e         	bne	0x8005f16 <hard_fault+0x46> @ imm = #0x1c
 8005ef8: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8006088 <hard_fault+0x1b8>
 8005efa: 6819         	ldr	r1, [r3]
 8005efc: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x800608c <hard_fault+0x1bc>
 8005efe: 9302         	str	r3, [sp, #0x8]
 8005f00: 2300         	movs	r3, #0x0
 8005f02: 9301         	str	r3, [sp, #0x4]
 8005f04: 2300         	movs	r3, #0x0
 8005f06: 9300         	str	r3, [sp]
 8005f08: 2300         	movs	r3, #0x0
 8005f0a: 2201         	movs	r2, #0x1
 8005f0c: 2000         	movs	r0, #0x0
 8005f0e: f017 fb1e    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x1763c
 8005f12: 2300         	movs	r3, #0x0
 8005f14: 637b         	str	r3, [r7, #0x34]
; 	*recoverable = false;
 8005f16: 683b         	ldr	r3, [r7]
 8005f18: 2200         	movs	r2, #0x0
 8005f1a: 701a         	strb	r2, [r3]
; 	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 8005f1c: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8006090 <hard_fault+0x1c0>
 8005f1e: 6adb         	ldr	r3, [r3, #0x2c]
 8005f20: f003 0302    	and	r3, r3, #0x2
 8005f24: 2b00         	cmp	r3, #0x0
 8005f26: d01c         	beq	0x8005f62 <hard_fault+0x92> @ imm = #0x38
; 		PR_EXC("  Bus fault on vector table read");
 8005f28: 2303         	movs	r3, #0x3
 8005f2a: 2b00         	cmp	r3, #0x0
 8005f2c: f000 80a7    	beq.w	0x800607e <hard_fault+0x1ae> @ imm = #0x14e
 8005f30: 2301         	movs	r3, #0x1
 8005f32: 74fb         	strb	r3, [r7, #0x13]
 8005f34: 7cfb         	ldrb	r3, [r7, #0x13]
 8005f36: f083 0301    	eor	r3, r3, #0x1
 8005f3a: b2db         	uxtb	r3, r3
 8005f3c: 2b00         	cmp	r3, #0x0
 8005f3e: f040 809e    	bne.w	0x800607e <hard_fault+0x1ae> @ imm = #0x13c
 8005f42: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8006088 <hard_fault+0x1b8>
 8005f44: 6819         	ldr	r1, [r3]
 8005f46: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8006094 <hard_fault+0x1c4>
 8005f48: 9302         	str	r3, [sp, #0x8]
 8005f4a: 2300         	movs	r3, #0x0
 8005f4c: 9301         	str	r3, [sp, #0x4]
 8005f4e: 2300         	movs	r3, #0x0
 8005f50: 9300         	str	r3, [sp]
 8005f52: 2300         	movs	r3, #0x0
 8005f54: 2201         	movs	r2, #0x1
 8005f56: 2000         	movs	r0, #0x0
 8005f58: f017 faf9    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x175f2
 8005f5c: 2300         	movs	r3, #0x0
 8005f5e: 60fb         	str	r3, [r7, #0xc]
 8005f60: e08d         	b	0x800607e <hard_fault+0x1ae> @ imm = #0x11a
; 	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
 8005f62: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8006090 <hard_fault+0x1c0>
 8005f64: 6adb         	ldr	r3, [r3, #0x2c]
 8005f66: 2b00         	cmp	r3, #0x0
 8005f68: da1b         	bge	0x8005fa2 <hard_fault+0xd2> @ imm = #0x36
; 		PR_EXC("  Debug event");
 8005f6a: 2303         	movs	r3, #0x3
 8005f6c: 2b00         	cmp	r3, #0x0
 8005f6e: f000 8086    	beq.w	0x800607e <hard_fault+0x1ae> @ imm = #0x10c
 8005f72: 2301         	movs	r3, #0x1
 8005f74: 76fb         	strb	r3, [r7, #0x1b]
 8005f76: 7efb         	ldrb	r3, [r7, #0x1b]
 8005f78: f083 0301    	eor	r3, r3, #0x1
 8005f7c: b2db         	uxtb	r3, r3
 8005f7e: 2b00         	cmp	r3, #0x0
 8005f80: d17d         	bne	0x800607e <hard_fault+0x1ae> @ imm = #0xfa
 8005f82: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8006088 <hard_fault+0x1b8>
 8005f84: 6819         	ldr	r1, [r3]
 8005f86: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8006098 <hard_fault+0x1c8>
 8005f88: 9302         	str	r3, [sp, #0x8]
 8005f8a: 2300         	movs	r3, #0x0
 8005f8c: 9301         	str	r3, [sp, #0x4]
 8005f8e: 2300         	movs	r3, #0x0
 8005f90: 9300         	str	r3, [sp]
 8005f92: 2300         	movs	r3, #0x0
 8005f94: 2201         	movs	r2, #0x1
 8005f96: 2000         	movs	r0, #0x0
 8005f98: f017 fad9    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x175b2
 8005f9c: 2300         	movs	r3, #0x0
 8005f9e: 617b         	str	r3, [r7, #0x14]
 8005fa0: e06d         	b	0x800607e <hard_fault+0x1ae> @ imm = #0xda
; 	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 8005fa2: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8006090 <hard_fault+0x1c0>
 8005fa4: 6adb         	ldr	r3, [r3, #0x2c]
 8005fa6: f003 4380    	and	r3, r3, #0x40000000
 8005faa: 2b00         	cmp	r3, #0x0
 8005fac: d067         	beq	0x800607e <hard_fault+0x1ae> @ imm = #0xce
; 		PR_EXC("  Fault escalation (see below)");
 8005fae: 2303         	movs	r3, #0x3
 8005fb0: 2b00         	cmp	r3, #0x0
 8005fb2: d018         	beq	0x8005fe6 <hard_fault+0x116> @ imm = #0x30
 8005fb4: 2301         	movs	r3, #0x1
 8005fb6: f887 302b    	strb.w	r3, [r7, #0x2b]
 8005fba: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8005fbe: f083 0301    	eor	r3, r3, #0x1
 8005fc2: b2db         	uxtb	r3, r3
 8005fc4: 2b00         	cmp	r3, #0x0
 8005fc6: d10e         	bne	0x8005fe6 <hard_fault+0x116> @ imm = #0x1c
 8005fc8: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8006088 <hard_fault+0x1b8>
 8005fca: 6819         	ldr	r1, [r3]
 8005fcc: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800609c <hard_fault+0x1cc>
 8005fce: 9302         	str	r3, [sp, #0x8]
 8005fd0: 2300         	movs	r3, #0x0
 8005fd2: 9301         	str	r3, [sp, #0x4]
 8005fd4: 2300         	movs	r3, #0x0
 8005fd6: 9300         	str	r3, [sp]
 8005fd8: 2300         	movs	r3, #0x0
 8005fda: 2201         	movs	r2, #0x1
 8005fdc: 2000         	movs	r0, #0x0
 8005fde: f017 fab6    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x1756c
 8005fe2: 2300         	movs	r3, #0x0
 8005fe4: 627b         	str	r3, [r7, #0x24]
; 		if (z_arm_is_synchronous_svc(esf)) {
 8005fe6: 6878         	ldr	r0, [r7, #0x4]
 8005fe8: f7ff ff32    	bl	0x8005e50 <z_arm_is_synchronous_svc> @ imm = #-0x19c
 8005fec: 4603         	mov	r3, r0
 8005fee: 2b00         	cmp	r3, #0x0
 8005ff0: d022         	beq	0x8006038 <hard_fault+0x168> @ imm = #0x44
; 			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
 8005ff2: 2303         	movs	r3, #0x3
 8005ff4: 2b00         	cmp	r3, #0x0
 8005ff6: d01b         	beq	0x8006030 <hard_fault+0x160> @ imm = #0x36
 8005ff8: 2301         	movs	r3, #0x1
 8005ffa: f887 3023    	strb.w	r3, [r7, #0x23]
 8005ffe: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8006002: f083 0301    	eor	r3, r3, #0x1
 8006006: b2db         	uxtb	r3, r3
 8006008: 2b00         	cmp	r3, #0x0
 800600a: d111         	bne	0x8006030 <hard_fault+0x160> @ imm = #0x22
 800600c: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8006088 <hard_fault+0x1b8>
 800600e: 6819         	ldr	r1, [r3]
 8006010: 687b         	ldr	r3, [r7, #0x4]
 8006012: 681b         	ldr	r3, [r3]
 8006014: 9303         	str	r3, [sp, #0xc]
 8006016: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80060a0 <hard_fault+0x1d0>
 8006018: 9302         	str	r3, [sp, #0x8]
 800601a: 2300         	movs	r3, #0x0
 800601c: 9301         	str	r3, [sp, #0x4]
 800601e: 2300         	movs	r3, #0x0
 8006020: 9300         	str	r3, [sp]
 8006022: 2300         	movs	r3, #0x0
 8006024: 2201         	movs	r2, #0x1
 8006026: 2000         	movs	r0, #0x0
 8006028: f017 fa91    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x17522
 800602c: 2300         	movs	r3, #0x0
 800602e: 61fb         	str	r3, [r7, #0x1c]
; 			reason = esf->basic.r0;
 8006030: 687b         	ldr	r3, [r7, #0x4]
 8006032: 681b         	ldr	r3, [r3]
 8006034: 62fb         	str	r3, [r7, #0x2c]
 8006036: e022         	b	0x800607e <hard_fault+0x1ae> @ imm = #0x44
; 		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
 8006038: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8006090 <hard_fault+0x1c0>
 800603a: 6a9b         	ldr	r3, [r3, #0x28]
 800603c: b2db         	uxtb	r3, r3
 800603e: 2b00         	cmp	r3, #0x0
 8006040: d006         	beq	0x8006050 <hard_fault+0x180> @ imm = #0xc
; 			reason = mem_manage_fault(esf, 1, recoverable);
 8006042: 683a         	ldr	r2, [r7]
 8006044: 2101         	movs	r1, #0x1
 8006046: 6878         	ldr	r0, [r7, #0x4]
 8006048: f7ff fb2c    	bl	0x80056a4 <mem_manage_fault> @ imm = #-0x9a8
 800604c: 62f8         	str	r0, [r7, #0x2c]
 800604e: e016         	b	0x800607e <hard_fault+0x1ae> @ imm = #0x2c
; 		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
 8006050: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8006090 <hard_fault+0x1c0>
 8006052: 6a9b         	ldr	r3, [r3, #0x28]
 8006054: f403 437f    	and	r3, r3, #0xff00
 8006058: 2b00         	cmp	r3, #0x0
 800605a: d007         	beq	0x800606c <hard_fault+0x19c> @ imm = #0xe
; 			reason = bus_fault(esf, 1, recoverable);
 800605c: 683a         	ldr	r2, [r7]
 800605e: 2101         	movs	r1, #0x1
 8006060: 6878         	ldr	r0, [r7, #0x4]
 8006062: f7ff fc63    	bl	0x800592c <bus_fault>   @ imm = #-0x73a
 8006066: 4603         	mov	r3, r0
 8006068: 62fb         	str	r3, [r7, #0x2c]
 800606a: e008         	b	0x800607e <hard_fault+0x1ae> @ imm = #0x10
; 		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
 800606c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8006090 <hard_fault+0x1c0>
 800606e: 6a9b         	ldr	r3, [r3, #0x28]
 8006070: f5b3 3f80    	cmp.w	r3, #0x10000
 8006074: d303         	blo	0x800607e <hard_fault+0x1ae> @ imm = #0x6
; 			reason = usage_fault(esf);
 8006076: 6878         	ldr	r0, [r7, #0x4]
 8006078: f7ff fda8    	bl	0x8005bcc <usage_fault> @ imm = #-0x4b0
 800607c: 62f8         	str	r0, [r7, #0x2c]
; 	return reason;
 800607e: 6afb         	ldr	r3, [r7, #0x2c]
; }
 8006080: 4618         	mov	r0, r3
 8006082: 3738         	adds	r7, #0x38
 8006084: 46bd         	mov	sp, r7
 8006086: bd80         	pop	{r7, pc}

08006088 <$d>:
 8006088: 6c 06 00 24  	.word	0x2400066c
 800608c: 80 a9 02 08  	.word	0x0802a980
 8006090: 00 ed 00 e0  	.word	0xe000ed00
 8006094: 98 a9 02 08  	.word	0x0802a998
 8006098: bc a9 02 08  	.word	0x0802a9bc
 800609c: cc a9 02 08  	.word	0x0802a9cc
 80060a0: ec a9 02 08  	.word	0x0802a9ec

080060a4 <reserved_exception>:
; {
 80060a4: b580         	push	{r7, lr}
 80060a6: b08a         	sub	sp, #0x28
 80060a8: af06         	add	r7, sp, #0x18
 80060aa: 6078         	str	r0, [r7, #0x4]
 80060ac: 6039         	str	r1, [r7]
; 	PR_FAULT_INFO("***** %s %d) *****",
 80060ae: 2303         	movs	r3, #0x3
 80060b0: 2b00         	cmp	r3, #0x0
 80060b2: d021         	beq	0x80060f8 <reserved_exception+0x54> @ imm = #0x42
 80060b4: 2301         	movs	r3, #0x1
 80060b6: 73fb         	strb	r3, [r7, #0xf]
 80060b8: 7bfb         	ldrb	r3, [r7, #0xf]
 80060ba: f083 0301    	eor	r3, r3, #0x1
 80060be: b2db         	uxtb	r3, r3
 80060c0: 2b00         	cmp	r3, #0x0
 80060c2: d119         	bne	0x80060f8 <reserved_exception+0x54> @ imm = #0x32
 80060c4: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8006100 <reserved_exception+0x5c>
 80060c6: 6819         	ldr	r1, [r3]
 80060c8: 683b         	ldr	r3, [r7]
 80060ca: 2b0f         	cmp	r3, #0xf
 80060cc: dc01         	bgt	0x80060d2 <reserved_exception+0x2e> @ imm = #0x2
 80060ce: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8006104 <reserved_exception+0x60>
 80060d0: e000         	b	0x80060d4 <reserved_exception+0x30> @ imm = #0x0
 80060d2: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8006108 <reserved_exception+0x64>
 80060d4: 683a         	ldr	r2, [r7]
 80060d6: 3a10         	subs	r2, #0x10
 80060d8: 9204         	str	r2, [sp, #0x10]
 80060da: 9303         	str	r3, [sp, #0xc]
 80060dc: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800610c <reserved_exception+0x68>
 80060de: 9302         	str	r3, [sp, #0x8]
 80060e0: 2300         	movs	r3, #0x0
 80060e2: 9301         	str	r3, [sp, #0x4]
 80060e4: 2300         	movs	r3, #0x0
 80060e6: 9300         	str	r3, [sp]
 80060e8: 2300         	movs	r3, #0x0
 80060ea: 2201         	movs	r2, #0x1
 80060ec: 2000         	movs	r0, #0x0
 80060ee: f017 fa2e    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x1745c
 80060f2: 2300         	movs	r3, #0x0
 80060f4: 60bb         	str	r3, [r7, #0x8]
; }
 80060f6: bf00         	nop
 80060f8: bf00         	nop
 80060fa: 3710         	adds	r7, #0x10
 80060fc: 46bd         	mov	sp, r7
 80060fe: bd80         	pop	{r7, pc}

08006100 <$d>:
 8006100: 6c 06 00 24  	.word	0x2400066c
 8006104: 08 aa 02 08  	.word	0x0802aa08
 8006108: 20 aa 02 08  	.word	0x0802aa20
 800610c: 3c aa 02 08  	.word	0x0802aa3c

08006110 <fault_handle>:
; {
 8006110: b580         	push	{r7, lr}
 8006112: b086         	sub	sp, #0x18
 8006114: af00         	add	r7, sp, #0x0
 8006116: 60f8         	str	r0, [r7, #0xc]
 8006118: 60b9         	str	r1, [r7, #0x8]
 800611a: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 800611c: 2300         	movs	r3, #0x0
 800611e: 617b         	str	r3, [r7, #0x14]
; 	*recoverable = false;
 8006120: 687b         	ldr	r3, [r7, #0x4]
 8006122: 2200         	movs	r2, #0x0
 8006124: 701a         	strb	r2, [r3]
; 	switch (fault) {
 8006126: 68bb         	ldr	r3, [r7, #0x8]
 8006128: 3b03         	subs	r3, #0x3
 800612a: 2b09         	cmp	r3, #0x9
 800612c: d835         	bhi	0x800619a <fault_handle+0x8a> @ imm = #0x6a
 800612e: a201         	adr	r2, #4 <fault_handle+0x23>
 8006130: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08006134 <$d>:
 8006134: 5d 61 00 08  	.word	0x0800615d
 8006138: 69 61 00 08  	.word	0x08006169
 800613c: 77 61 00 08  	.word	0x08006177
 8006140: 87 61 00 08  	.word	0x08006187
 8006144: 9b 61 00 08  	.word	0x0800619b
 8006148: 9b 61 00 08  	.word	0x0800619b
 800614c: 9b 61 00 08  	.word	0x0800619b
 8006150: 9b 61 00 08  	.word	0x0800619b
 8006154: 9b 61 00 08  	.word	0x0800619b
 8006158: 91 61 00 08  	.word	0x08006191

0800615c <$t>:
; 		reason = hard_fault(esf, recoverable);
 800615c: 6879         	ldr	r1, [r7, #0x4]
 800615e: 68f8         	ldr	r0, [r7, #0xc]
 8006160: f7ff feb6    	bl	0x8005ed0 <hard_fault>  @ imm = #-0x294
 8006164: 6178         	str	r0, [r7, #0x14]
; 		break;
 8006166: e01d         	b	0x80061a4 <fault_handle+0x94> @ imm = #0x3a
; 		reason = mem_manage_fault(esf, 0, recoverable);
 8006168: 687a         	ldr	r2, [r7, #0x4]
 800616a: 2100         	movs	r1, #0x0
 800616c: 68f8         	ldr	r0, [r7, #0xc]
 800616e: f7ff fa99    	bl	0x80056a4 <mem_manage_fault> @ imm = #-0xace
 8006172: 6178         	str	r0, [r7, #0x14]
; 		break;
 8006174: e016         	b	0x80061a4 <fault_handle+0x94> @ imm = #0x2c
; 		reason = bus_fault(esf, 0, recoverable);
 8006176: 687a         	ldr	r2, [r7, #0x4]
 8006178: 2100         	movs	r1, #0x0
 800617a: 68f8         	ldr	r0, [r7, #0xc]
 800617c: f7ff fbd6    	bl	0x800592c <bus_fault>   @ imm = #-0x854
 8006180: 4603         	mov	r3, r0
 8006182: 617b         	str	r3, [r7, #0x14]
; 		break;
 8006184: e00e         	b	0x80061a4 <fault_handle+0x94> @ imm = #0x1c
; 		reason = usage_fault(esf);
 8006186: 68f8         	ldr	r0, [r7, #0xc]
 8006188: f7ff fd20    	bl	0x8005bcc <usage_fault> @ imm = #-0x5c0
 800618c: 6178         	str	r0, [r7, #0x14]
; 		break;
 800618e: e009         	b	0x80061a4 <fault_handle+0x94> @ imm = #0x12
; 		debug_monitor(esf, recoverable);
 8006190: 6879         	ldr	r1, [r7, #0x4]
 8006192: 68f8         	ldr	r0, [r7, #0xc]
 8006194: f7ff fe30    	bl	0x8005df8 <debug_monitor> @ imm = #-0x3a0
; 		break;
 8006198: e004         	b	0x80061a4 <fault_handle+0x94> @ imm = #0x8
; 		reserved_exception(esf, fault);
 800619a: 68b9         	ldr	r1, [r7, #0x8]
 800619c: 68f8         	ldr	r0, [r7, #0xc]
 800619e: f7ff ff81    	bl	0x80060a4 <reserved_exception> @ imm = #-0xfe
; 		break;
 80061a2: bf00         	nop
; 	if ((*recoverable) == false) {
 80061a4: 687b         	ldr	r3, [r7, #0x4]
 80061a6: 781b         	ldrb	r3, [r3]
 80061a8: f083 0301    	eor	r3, r3, #0x1
 80061ac: b2db         	uxtb	r3, r3
 80061ae: 2b00         	cmp	r3, #0x0
 80061b0: d003         	beq	0x80061ba <fault_handle+0xaa> @ imm = #0x6
; 		fault_show(esf, fault);
 80061b2: 68b9         	ldr	r1, [r7, #0x8]
 80061b4: 68f8         	ldr	r0, [r7, #0xc]
 80061b6: f017 f9e8    	bl	0x801d58a <fault_show>  @ imm = #0x173d0
; 	return reason;
 80061ba: 697b         	ldr	r3, [r7, #0x14]
; }
 80061bc: 4618         	mov	r0, r3
 80061be: 3718         	adds	r7, #0x18
 80061c0: 46bd         	mov	sp, r7
 80061c2: bd80         	pop	{r7, pc}

080061c4 <get_esf>:
; {
 80061c4: b580         	push	{r7, lr}
 80061c6: b08c         	sub	sp, #0x30
 80061c8: af04         	add	r7, sp, #0x10
 80061ca: 60f8         	str	r0, [r7, #0xc]
 80061cc: 60b9         	str	r1, [r7, #0x8]
 80061ce: 607a         	str	r2, [r7, #0x4]
 80061d0: 603b         	str	r3, [r7]
; 	bool alternative_state_exc = false;
 80061d2: 2300         	movs	r3, #0x0
 80061d4: 76fb         	strb	r3, [r7, #0x1b]
; 	struct arch_esf *ptr_esf = NULL;
 80061d6: 2300         	movs	r3, #0x0
 80061d8: 61fb         	str	r3, [r7, #0x1c]
; 	*nested_exc = false;
 80061da: 683b         	ldr	r3, [r7]
 80061dc: 2200         	movs	r2, #0x0
 80061de: 701a         	strb	r2, [r3]
; 	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
 80061e0: 687b         	ldr	r3, [r7, #0x4]
 80061e2: f003 437f    	and	r3, r3, #0xff000000
 80061e6: f1b3 4f7f    	cmp.w	r3, #0xff000000
 80061ea: d001         	beq	0x80061f0 <get_esf+0x2c> @ imm = #0x2
; 		return NULL;
 80061ec: 2300         	movs	r3, #0x0
 80061ee: e039         	b	0x8006264 <get_esf+0xa0> @ imm = #0x72
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 80061f0: 687b         	ldr	r3, [r7, #0x4]
 80061f2: f003 0308    	and	r3, r3, #0x8
 80061f6: 2b00         	cmp	r3, #0x0
 80061f8: d020         	beq	0x800623c <get_esf+0x78> @ imm = #0x40
; 		(!(exc_return & EXC_RETURN_SPSEL_PROCESS))) {
 80061fa: 687b         	ldr	r3, [r7, #0x4]
 80061fc: f003 0304    	and	r3, r3, #0x4
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 8006200: 2b00         	cmp	r3, #0x0
 8006202: d11b         	bne	0x800623c <get_esf+0x78> @ imm = #0x36
; 		PR_EXC("SPSEL in thread mode does not indicate PSP");
 8006204: 2303         	movs	r3, #0x3
 8006206: 2b00         	cmp	r3, #0x0
 8006208: d016         	beq	0x8006238 <get_esf+0x74> @ imm = #0x2c
 800620a: 2301         	movs	r3, #0x1
 800620c: 76bb         	strb	r3, [r7, #0x1a]
 800620e: 7ebb         	ldrb	r3, [r7, #0x1a]
 8006210: f083 0301    	eor	r3, r3, #0x1
 8006214: b2db         	uxtb	r3, r3
 8006216: 2b00         	cmp	r3, #0x0
 8006218: d10e         	bne	0x8006238 <get_esf+0x74> @ imm = #0x1c
 800621a: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800626c <get_esf+0xa8>
 800621c: 6819         	ldr	r1, [r3]
 800621e: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8006270 <get_esf+0xac>
 8006220: 9302         	str	r3, [sp, #0x8]
 8006222: 2300         	movs	r3, #0x0
 8006224: 9301         	str	r3, [sp, #0x4]
 8006226: 2300         	movs	r3, #0x0
 8006228: 9300         	str	r3, [sp]
 800622a: 2300         	movs	r3, #0x0
 800622c: 2201         	movs	r2, #0x1
 800622e: 2000         	movs	r0, #0x0
 8006230: f017 f98d    	bl	0x801d54e <z_log_msg_runtime_create> @ imm = #0x1731a
 8006234: 2300         	movs	r3, #0x0
 8006236: 617b         	str	r3, [r7, #0x14]
; 		return NULL;
 8006238: 2300         	movs	r3, #0x0
 800623a: e013         	b	0x8006264 <get_esf+0xa0> @ imm = #0x26
; 	if (!alternative_state_exc) {
 800623c: 7efb         	ldrb	r3, [r7, #0x1b]
 800623e: f083 0301    	eor	r3, r3, #0x1
 8006242: b2db         	uxtb	r3, r3
 8006244: 2b00         	cmp	r3, #0x0
 8006246: d00c         	beq	0x8006262 <get_esf+0x9e> @ imm = #0x18
; 		if (exc_return & EXC_RETURN_MODE_THREAD) {
 8006248: 687b         	ldr	r3, [r7, #0x4]
 800624a: f003 0308    	and	r3, r3, #0x8
 800624e: 2b00         	cmp	r3, #0x0
 8006250: d002         	beq	0x8006258 <get_esf+0x94> @ imm = #0x4
; 			ptr_esf =  (struct arch_esf *)psp;
 8006252: 68bb         	ldr	r3, [r7, #0x8]
 8006254: 61fb         	str	r3, [r7, #0x1c]
 8006256: e004         	b	0x8006262 <get_esf+0x9e> @ imm = #0x8
; 			ptr_esf = (struct arch_esf *)msp;
 8006258: 68fb         	ldr	r3, [r7, #0xc]
 800625a: 61fb         	str	r3, [r7, #0x1c]
; 			*nested_exc = true;
 800625c: 683b         	ldr	r3, [r7]
 800625e: 2201         	movs	r2, #0x1
 8006260: 701a         	strb	r2, [r3]
; 	return ptr_esf;
 8006262: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8006264: 4618         	mov	r0, r3
 8006266: 3720         	adds	r7, #0x20
 8006268: 46bd         	mov	sp, r7
 800626a: bd80         	pop	{r7, pc}

0800626c <$d>:
 800626c: 6c 06 00 24  	.word	0x2400066c
 8006270: 50 aa 02 08  	.word	0x0802aa50

08006274 <z_arm_fault>:
; {
 8006274: b580         	push	{r7, lr}
 8006276: b0a6         	sub	sp, #0x98
 8006278: af00         	add	r7, sp, #0x0
 800627a: 60f8         	str	r0, [r7, #0xc]
 800627c: 60b9         	str	r1, [r7, #0x8]
 800627e: 607a         	str	r2, [r7, #0x4]
 8006280: 603b         	str	r3, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8006282: 2300         	movs	r3, #0x0
 8006284: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 8006288: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8006340 <z_arm_fault+0xcc>
 800628a: 685b         	ldr	r3, [r3, #0x4]
 800628c: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8006290: f8c7 3090    	str.w	r3, [r7, #0x90]
 8006294: 2300         	movs	r3, #0x0
 8006296: f8c7 3080    	str.w	r3, [r7, #0x80]
 800629a: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800629e: 67fb         	str	r3, [r7, #0x7c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80062a0: 6ffb         	ldr	r3, [r7, #0x7c]
 80062a2: f383 8811    	msr	basepri, r3
; }
 80062a6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80062a8: f3bf 8f6f    	isb	sy
; }
 80062ac: bf00         	nop
; }
 80062ae: bf00         	nop
; 	 esf = get_esf(msp, psp, exc_return, &nested_exc);
 80062b0: f107 037a    	add.w	r3, r7, #0x7a
 80062b4: 687a         	ldr	r2, [r7, #0x4]
 80062b6: 68b9         	ldr	r1, [r7, #0x8]
 80062b8: 68f8         	ldr	r0, [r7, #0xc]
 80062ba: f7ff ff83    	bl	0x80061c4 <get_esf>     @ imm = #-0xfa
 80062be: f8c7 008c    	str.w	r0, [r7, #0x8c]
 80062c2: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80062c6: f8c7 3088    	str.w	r3, [r7, #0x88]
 80062ca: 687b         	ldr	r3, [r7, #0x4]
 80062cc: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 80062d0: bf00         	nop
; 	reason = fault_handle(esf, fault, &recoverable);
 80062d2: f107 037b    	add.w	r3, r7, #0x7b
 80062d6: 461a         	mov	r2, r3
 80062d8: f8d7 1090    	ldr.w	r1, [r7, #0x90]
 80062dc: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 80062e0: f7ff ff16    	bl	0x8006110 <fault_handle> @ imm = #-0x1d4
 80062e4: f8c7 0094    	str.w	r0, [r7, #0x94]
; 	if (recoverable) {
 80062e8: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 80062ec: 2b00         	cmp	r3, #0x0
 80062ee: d122         	bne	0x8006336 <z_arm_fault+0xc2> @ imm = #0x44
; 	memcpy(&esf_copy, esf, sizeof(struct arch_esf));
 80062f0: f107 0310    	add.w	r3, r7, #0x10
 80062f4: 2268         	movs	r2, #0x68
 80062f6: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 80062fa: 4618         	mov	r0, r3
 80062fc: f022 fefa    	bl	0x80290f4 <memcpy>      @ imm = #0x22df4
; 	if (nested_exc) {
 8006300: f897 307a    	ldrb.w	r3, [r7, #0x7a]
 8006304: 2b00         	cmp	r3, #0x0
 8006306: d00a         	beq	0x800631e <z_arm_fault+0xaa> @ imm = #0x14
; 		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
 8006308: 6afb         	ldr	r3, [r7, #0x2c]
 800630a: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 800630e: 2b00         	cmp	r3, #0x0
 8006310: d109         	bne	0x8006326 <z_arm_fault+0xb2> @ imm = #0x12
; 			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
 8006312: 6afa         	ldr	r2, [r7, #0x2c]
 8006314: f240 13ff    	movw	r3, #0x1ff
 8006318: 4313         	orrs	r3, r2
 800631a: 62fb         	str	r3, [r7, #0x2c]
 800631c: e003         	b	0x8006326 <z_arm_fault+0xb2> @ imm = #0x6
; 		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 800631e: 6afa         	ldr	r2, [r7, #0x2c]
 8006320: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8006344 <z_arm_fault+0xd0>
 8006322: 4013         	ands	r3, r2
 8006324: 62fb         	str	r3, [r7, #0x2c]
; 	z_arm_fatal_error(reason, &esf_copy);
 8006326: f107 0310    	add.w	r3, r7, #0x10
 800632a: 4619         	mov	r1, r3
 800632c: f8d7 0094    	ldr.w	r0, [r7, #0x94]
 8006330: f7ff f922    	bl	0x8005578 <z_arm_fatal_error> @ imm = #-0xdbc
 8006334: e000         	b	0x8006338 <z_arm_fault+0xc4> @ imm = #0x0
; 		return;
 8006336: bf00         	nop
; }
 8006338: 3798         	adds	r7, #0x98
 800633a: 46bd         	mov	sp, r7
 800633c: bd80         	pop	{r7, pc}
 800633e: bf00         	nop

08006340 <$d>:
 8006340: 00 ed 00 e0  	.word	0xe000ed00
 8006344: 00 fe ff ff  	.word	0xfffffe00

08006348 <z_arm_fault_init>:
; {
 8006348: b480         	push	{r7}
 800634a: af00         	add	r7, sp, #0x0
; 	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 800634c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8006370 <z_arm_fault_init+0x28>
 800634e: 695b         	ldr	r3, [r3, #0x14]
 8006350: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8006370 <z_arm_fault_init+0x28>
 8006352: f043 0310    	orr	r3, r3, #0x10
 8006356: 6153         	str	r3, [r2, #0x14]
; 	SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk;
 8006358: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8006370 <z_arm_fault_init+0x28>
 800635a: 695b         	ldr	r3, [r3, #0x14]
 800635c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8006370 <z_arm_fault_init+0x28>
 800635e: f023 0308    	bic	r3, r3, #0x8
 8006362: 6153         	str	r3, [r2, #0x14]
; }
 8006364: bf00         	nop
 8006366: 46bd         	mov	sp, r7
 8006368: f85d 7b04    	ldr	r7, [sp], #4
 800636c: 4770         	bx	lr
 800636e: bf00         	nop

08006370 <$d>:
 8006370: 00 ed 00 e0  	.word	0xe000ed00

08006374 <z_arm_usage_fault>:
; 	mrs r0, MSP
 8006374: f3ef 8008    	mrs	r0, msp
; 	mrs r1, PSP
 8006378: f3ef 8109    	mrs	r1, psp
; 	push {r0, lr}
 800637c: b501         	push	{r0, lr}
; 	mov r2, lr /* EXC_RETURN */
 800637e: 4672         	mov	r2, lr
; 	bl z_arm_fault
 8006380: f7ff ff78    	bl	0x8006274 <z_arm_fault> @ imm = #-0x110
; 	pop {r0, pc}
 8006384: bd01         	pop	{r0, pc}
 8006386: bf00         	nop

08006388 <z_arm_reset>:
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8006388: 2010         	movs	r0, #0x10
;     msr BASEPRI, r0
 800638a: f380 8811    	msr	basepri, r0
;     ldr r0, =z_interrupt_stacks
 800638e: 480b         	ldr	r0, [pc, #0x2c]         @ 0x80063bc <z_arm_reset+0x34>
;     ldr r1, =0xaa
 8006390: f04f 01aa    	mov.w	r1, #0xaa
;     ldr r2, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 8006394: f44f 6200    	mov.w	r2, #0x800
;     bl z_early_memset
 8006398: f020 f8e4    	bl	0x8026564 <z_early_memset> @ imm = #0x201c8
;     ldr r0, =z_interrupt_stacks
 800639c: 4807         	ldr	r0, [pc, #0x1c]         @ 0x80063bc <z_arm_reset+0x34>
;     ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 800639e: f44f 6100    	mov.w	r1, #0x800
;     adds r0, r0, r1
 80063a2: 1840         	adds	r0, r0, r1
;     msr PSP, r0
 80063a4: f380 8809    	msr	psp, r0
;     mrs r0, CONTROL
 80063a8: f3ef 8014    	mrs	r0, control
;     movs r1, #2
 80063ac: 2102         	movs	r1, #0x2
;     orrs r0, r1 /* CONTROL_SPSEL_Msk */
 80063ae: 4308         	orrs	r0, r1
;     msr CONTROL, r0
 80063b0: f380 8814    	msr	control, r0
;     isb
 80063b4: f3bf 8f6f    	isb	sy
;     bl z_prep_c
 80063b8: f017 f92b    	bl	0x801d612 <z_prep_c>    @ imm = #0x17256

080063bc <$d>:
 80063bc: 38 57 00 24  	.word	0x24005738

080063c0 <z_impl_k_thread_abort>:
; {
 80063c0: b580         	push	{r7, lr}
 80063c2: b084         	sub	sp, #0x10
 80063c4: af00         	add	r7, sp, #0x0
 80063c6: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80063c8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8006414 <z_impl_k_thread_abort+0x54>
 80063ca: 689b         	ldr	r3, [r3, #0x8]
 80063cc: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 80063ce: 68fb         	ldr	r3, [r7, #0xc]
; 	if (arch_current_thread() == thread) {
 80063d0: 687a         	ldr	r2, [r7, #0x4]
 80063d2: 429a         	cmp	r2, r3
 80063d4: d116         	bne	0x8006404 <z_impl_k_thread_abort+0x44> @ imm = #0x2c
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80063d6: f3ef 8305    	mrs	r3, ipsr
 80063da: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 80063dc: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 80063de: 2b00         	cmp	r3, #0x0
 80063e0: bf14         	ite	ne
 80063e2: 2301         	movne	r3, #0x1
 80063e4: 2300         	moveq	r3, #0x0
 80063e6: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 80063e8: 2b00         	cmp	r3, #0x0
 80063ea: d00b         	beq	0x8006404 <z_impl_k_thread_abort+0x44> @ imm = #0x16
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 80063ec: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8006418 <z_impl_k_thread_abort+0x58>
 80063ee: 685b         	ldr	r3, [r3, #0x4]
 80063f0: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8006418 <z_impl_k_thread_abort+0x58>
 80063f2: f043 5380    	orr	r3, r3, #0x10000000
 80063f6: 6053         	str	r3, [r2, #0x4]
; 			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
 80063f8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8006418 <z_impl_k_thread_abort+0x58>
 80063fa: 6a5b         	ldr	r3, [r3, #0x24]
 80063fc: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8006418 <z_impl_k_thread_abort+0x58>
 80063fe: f423 4300    	bic	r3, r3, #0x8000
 8006402: 6253         	str	r3, [r2, #0x24]
; 	z_thread_abort(thread);
 8006404: 6878         	ldr	r0, [r7, #0x4]
 8006406: f011 faeb    	bl	0x80179e0 <z_thread_abort> @ imm = #0x115d6
; }
 800640a: bf00         	nop
 800640c: 3710         	adds	r7, #0x10
 800640e: 46bd         	mov	sp, r7
 8006410: bd80         	pop	{r7, pc}
 8006412: bf00         	nop

08006414 <$d>:
 8006414: 60 20 00 24  	.word	0x24002060
 8006418: 00 ed 00 e0  	.word	0xe000ed00

0800641c <arch_swap>:
; {
 800641c: b480         	push	{r7}
 800641e: b089         	sub	sp, #0x24
 8006420: af00         	add	r7, sp, #0x0
 8006422: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8006424: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8006480 <arch_swap+0x64>
 8006426: 689b         	ldr	r3, [r3, #0x8]
 8006428: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800642a: 68fb         	ldr	r3, [r7, #0xc]
; 	arch_current_thread()->arch.basepri = key;
 800642c: 687a         	ldr	r2, [r7, #0x4]
 800642e: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8006432: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8006480 <arch_swap+0x64>
 8006434: 689b         	ldr	r3, [r3, #0x8]
 8006436: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 8006438: 693b         	ldr	r3, [r7, #0x10]
; 	arch_current_thread()->arch.swap_return_value = -EAGAIN;
 800643a: f06f 020a    	mvn	r2, #0xa
 800643e: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; 	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8006442: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8006484 <arch_swap+0x68>
 8006444: 685b         	ldr	r3, [r3, #0x4]
 8006446: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8006484 <arch_swap+0x68>
 8006448: f043 5380    	orr	r3, r3, #0x10000000
 800644c: 6053         	str	r3, [r2, #0x4]
 800644e: 2300         	movs	r3, #0x0
 8006450: 61bb         	str	r3, [r7, #0x18]
 8006452: 69bb         	ldr	r3, [r7, #0x18]
 8006454: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006456: 697b         	ldr	r3, [r7, #0x14]
 8006458: f383 8811    	msr	basepri, r3
; }
 800645c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800645e: f3bf 8f6f    	isb	sy
; }
 8006462: bf00         	nop
; }
 8006464: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8006466: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8006480 <arch_swap+0x64>
 8006468: 689b         	ldr	r3, [r3, #0x8]
 800646a: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 800646c: 69fb         	ldr	r3, [r7, #0x1c]
; 	return arch_current_thread()->arch.swap_return_value;
 800646e: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
; }
 8006472: 4618         	mov	r0, r3
 8006474: 3724         	adds	r7, #0x24
 8006476: 46bd         	mov	sp, r7
 8006478: f85d 7b04    	ldr	r7, [sp], #4
 800647c: 4770         	bx	lr
 800647e: bf00         	nop

08006480 <$d>:
 8006480: 60 20 00 24  	.word	0x24002060
 8006484: 00 ed 00 e0  	.word	0xe000ed00

08006488 <z_arm_pendsv>:
;     push {r0, lr}
 8006488: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_out
 800648a: f021 fe58    	bl	0x802813e <z_thread_mark_switched_out> @ imm = #0x21cb0
;     pop {r0, lr}
 800648e: e8bd 4001    	pop.w	{r0, lr}
;     ldr r1, =_kernel
 8006492: 4925         	ldr	r1, [pc, #0x94]         @ 0x8006528 <in_fp_endif+0x28>
;     ldr r2, [r1, #_kernel_offset_to_current]
 8006494: 688a         	ldr	r2, [r1, #0x8]
;     strb lr, [r2, #_thread_offset_to_mode_exc_return]
 8006496: f882 e111    	strb.w	lr, [r2, #0x111]
;     ldr r0, =_thread_offset_to_callee_saved
 800649a: f04f 0040    	mov.w	r0, #0x40
;     add r0, r2
 800649e: 4410         	add	r0, r2
;     mrs ip, PSP
 80064a0: f3ef 8c09    	mrs	r12, psp
;     stmia r0, {r4-r11, ip}
 80064a4: e880 1ff0    	stm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     tst lr, #_EXC_RETURN_FTYPE_Msk
 80064a8: f01e 0f10    	tst.w	lr, #0x10
;     bne out_fp_endif
 80064ac: d103         	bne	0x80064b6 <out_fp_endif> @ imm = #0x6
;     add r0, r2, #_thread_offset_to_preempt_float
 80064ae: f102 00d0    	add.w	r0, r2, #0xd0
;     vstmia r0, {s16-s31}
 80064b2: ec80 8a10    	<unknown>

080064b6 <out_fp_endif>:
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 80064b6: 2010         	movs	r0, #0x10
;     msr BASEPRI_MAX, r0
 80064b8: f380 8812    	msr	basepri_max, r0
;     isb /* Make the effect of disabling interrupts be realized immediately */
 80064bc: f3bf 8f6f    	isb	sy
;     ldr r7, =_SCS_ICSR
 80064c0: 4f1a         	ldr	r7, [pc, #0x68]         @ 0x800652c <in_fp_endif+0x2c>
;     ldr r6, =_SCS_ICSR_UNPENDSV
 80064c2: f04f 6600    	mov.w	r6, #0x8000000
;     ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
 80064c6: 6a0a         	ldr	r2, [r1, #0x20]
;     str r2, [r1, #_kernel_offset_to_current]
 80064c8: 608a         	str	r2, [r1, #0x8]
;     str r6, [r7, #0]
 80064ca: 603e         	str	r6, [r7]
;     ldr r4, =_thread_offset_to_tls
 80064cc: f04f 04c4    	mov.w	r4, #0xc4
;     adds r4, r2, r4
 80064d0: 1914         	adds	r4, r2, r4
;     ldr r0, [r4]
 80064d2: 6820         	ldr	r0, [r4]
;     ldr r4, =z_arm_tls_ptr
 80064d4: 4c16         	ldr	r4, [pc, #0x58]         @ 0x8006530 <in_fp_endif+0x30>
;     str r0, [r4]
 80064d6: 6020         	str	r0, [r4]
;     ldrsb lr, [r2, #_thread_offset_to_mode_exc_return]
 80064d8: f992 e111    	ldrsb.w	lr, [r2, #0x111]
;     ldr r0, [r2, #_thread_offset_to_basepri]
 80064dc: f8d2 00c8    	ldr.w	r0, [r2, #0xc8]
;     movs r3, #0
 80064e0: 2300         	movs	r3, #0x0
;     str r3, [r2, #_thread_offset_to_basepri]
 80064e2: f8c2 30c8    	str.w	r3, [r2, #0xc8]
;     msr BASEPRI, r0
 80064e6: f380 8811    	msr	basepri, r0
;     tst lr, #_EXC_RETURN_FTYPE_Msk
 80064ea: f01e 0f10    	tst.w	lr, #0x10
;     beq in_fp_active
 80064ee: d003         	beq	0x80064f8 <in_fp_active> @ imm = #0x6
;     movs.n r3, #0
 80064f0: 2300         	movs	r3, #0x0
;     vmsr fpscr, r3
 80064f2: eee1 3a10    	<unknown>
;     b in_fp_endif
 80064f6: e003         	b	0x8006500 <in_fp_endif> @ imm = #0x6

080064f8 <in_fp_active>:
;     add r0, r2, #_thread_offset_to_preempt_float
 80064f8: f102 00d0    	add.w	r0, r2, #0xd0
;     vldmia r0, {s16-s31}
 80064fc: ec90 8a10    	<unknown>

08006500 <in_fp_endif>:
;     mrs r3, CONTROL
 8006500: f3ef 8314    	mrs	r3, control
;     bic r3, #_CONTROL_FPCA_Msk
 8006504: f023 0304    	bic	r3, r3, #0x4
;     msr CONTROL, r3
 8006508: f383 8814    	msr	control, r3
;     isb
 800650c: f3bf 8f6f    	isb	sy
;     add r0, r2, #_thread_offset_to_callee_saved
 8006510: f102 0040    	add.w	r0, r2, #0x40
;     ldmia r0, {r4-r11, ip}
 8006514: e890 1ff0    	ldm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     msr PSP, ip
 8006518: f38c 8809    	msr	psp, r12
;     push {r0, lr}
 800651c: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_in
 800651e: f00f fe53    	bl	0x80161c8 <z_thread_mark_switched_in> @ imm = #0xfca6
;     pop {r0, lr}
 8006522: e8bd 4001    	pop.w	{r0, lr}
;     bx lr
 8006526: 4770         	bx	lr

08006528 <$d>:
 8006528: 60 20 00 24  	.word	0x24002060
 800652c: 04 ed 00 e0  	.word	0xe000ed04
 8006530: 58 28 00 24  	.word	0x24002858

08006534 <z_arm_svc>:
;     tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
 8006534: f01e 0f04    	tst.w	lr, #0x4
;     ite eq  /* if zero (equal), came from handler mode */
 8006538: bf0c         	ite	eq
;         mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 800653a: f3ef 8008    	mrseq	r0, msp
;         mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 800653e: f3ef 8009    	mrsne	r0, psp
;     ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 8006542: 6981         	ldr	r1, [r0, #0x18]
;     ldrb r1, [r1, #-2]
 8006544: f811 1c02    	ldrb	r1, [r1, #-2]
;     cmp r1, #2
 8006548: 2902         	cmp	r1, #0x2
;     beq _oops
 800654a: d0ff         	beq	0x800654c <_oops>       @ imm = #-0x2

0800654c <_oops>:
;     push {r0, lr}
 800654c: b501         	push	{r0, lr}
;     mov r2, lr /* EXC_RETURN */
 800654e: 4672         	mov	r2, lr
;     bl z_do_kernel_oops
 8006550: f016 ffc9    	bl	0x801d4e6 <z_do_kernel_oops> @ imm = #0x16f92
;     pop {r0, pc}
 8006554: bd01         	pop	{r0, pc}
 8006556: bf00         	nop

08006558 <__NVIC_EnableIRQ>:
; {
 8006558: b480         	push	{r7}
 800655a: b083         	sub	sp, #0xc
 800655c: af00         	add	r7, sp, #0x0
 800655e: 4603         	mov	r3, r0
 8006560: 80fb         	strh	r3, [r7, #0x6]
;   if ((int32_t)(IRQn) >= 0)
 8006562: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 8006566: 2b00         	cmp	r3, #0x0
 8006568: db0b         	blt	0x8006582 <__NVIC_EnableIRQ+0x2a> @ imm = #0x16
;     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800656a: 88fb         	ldrh	r3, [r7, #0x6]
 800656c: f003 021f    	and	r2, r3, #0x1f
 8006570: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006590 <__NVIC_EnableIRQ+0x38>
 8006572: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 8006576: 095b         	lsrs	r3, r3, #0x5
 8006578: 2001         	movs	r0, #0x1
 800657a: fa00 f202    	lsl.w	r2, r0, r2
 800657e: f841 2023    	str.w	r2, [r1, r3, lsl #2]
; }
 8006582: bf00         	nop
 8006584: 370c         	adds	r7, #0xc
 8006586: 46bd         	mov	sp, r7
 8006588: f85d 7b04    	ldr	r7, [sp], #4
 800658c: 4770         	bx	lr
 800658e: bf00         	nop

08006590 <$d>:
 8006590: 00 e1 00 e0  	.word	0xe000e100

08006594 <__NVIC_SetPriority>:
; {
 8006594: b480         	push	{r7}
 8006596: b083         	sub	sp, #0xc
 8006598: af00         	add	r7, sp, #0x0
 800659a: 4603         	mov	r3, r0
 800659c: 6039         	str	r1, [r7]
 800659e: 80fb         	strh	r3, [r7, #0x6]
;   if ((int32_t)(IRQn) >= 0)
 80065a0: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 80065a4: 2b00         	cmp	r3, #0x0
 80065a6: db0a         	blt	0x80065be <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80065a8: 683b         	ldr	r3, [r7]
 80065aa: b2da         	uxtb	r2, r3
 80065ac: 490c         	ldr	r1, [pc, #0x30]         @ 0x80065e0 <__NVIC_SetPriority+0x4c>
 80065ae: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 80065b2: 0112         	lsls	r2, r2, #0x4
 80065b4: b2d2         	uxtb	r2, r2
 80065b6: 440b         	add	r3, r1
 80065b8: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 80065bc: e00a         	b	0x80065d4 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80065be: 683b         	ldr	r3, [r7]
 80065c0: b2da         	uxtb	r2, r3
 80065c2: 4908         	ldr	r1, [pc, #0x20]         @ 0x80065e4 <__NVIC_SetPriority+0x50>
 80065c4: 88fb         	ldrh	r3, [r7, #0x6]
 80065c6: f003 030f    	and	r3, r3, #0xf
 80065ca: 3b04         	subs	r3, #0x4
 80065cc: 0112         	lsls	r2, r2, #0x4
 80065ce: b2d2         	uxtb	r2, r2
 80065d0: 440b         	add	r3, r1
 80065d2: 761a         	strb	r2, [r3, #0x18]
; }
 80065d4: bf00         	nop
 80065d6: 370c         	adds	r7, #0xc
 80065d8: 46bd         	mov	sp, r7
 80065da: f85d 7b04    	ldr	r7, [sp], #4
 80065de: 4770         	bx	lr

080065e0 <$d>:
 80065e0: 00 e1 00 e0  	.word	0xe000e100
 80065e4: 00 ed 00 e0  	.word	0xe000ed00

080065e8 <relocate_vector_table>:
; {
 80065e8: b480         	push	{r7}
 80065ea: af00         	add	r7, sp, #0x0
; 	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 80065ec: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8006614 <relocate_vector_table+0x2c>
 80065ee: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8006618 <relocate_vector_table+0x30>
 80065f0: f023 037f    	bic	r3, r3, #0x7f
 80065f4: 6093         	str	r3, [r2, #0x8]
;   __ASM volatile ("dsb 0xF":::"memory");
 80065f6: f3bf 8f4f    	dsb	sy
; }
 80065fa: bf00         	nop
; }
 80065fc: bf00         	nop
; }
 80065fe: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006600: f3bf 8f6f    	isb	sy
; }
 8006604: bf00         	nop
; }
 8006606: bf00         	nop
; }
 8006608: bf00         	nop
; }
 800660a: bf00         	nop
 800660c: 46bd         	mov	sp, r7
 800660e: f85d 7b04    	ldr	r7, [sp], #4
 8006612: 4770         	bx	lr

08006614 <$d>:
 8006614: 00 00 00 08  	.word	0x08000000
 8006618: 00 ed 00 e0  	.word	0xe000ed00

0800661c <z_arm_floating_point_init>:
; {
 800661c: b480         	push	{r7}
 800661e: b083         	sub	sp, #0xc
 8006620: af00         	add	r7, sp, #0x0
; 	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
 8006622: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8006678 <z_arm_floating_point_init+0x5c>
 8006624: f8d3 3088    	ldr.w	r3, [r3, #0x88]
 8006628: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x8006678 <z_arm_floating_point_init+0x5c>
 800662a: f423 0370    	bic	r3, r3, #0xf00000
 800662e: f8c2 3088    	str.w	r3, [r2, #0x88]
; 	SCB->CPACR |= CPACR_CP10_PRIV_ACCESS | CPACR_CP11_PRIV_ACCESS;
 8006632: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8006678 <z_arm_floating_point_init+0x5c>
 8006634: f8d3 3088    	ldr.w	r3, [r3, #0x88]
 8006638: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8006678 <z_arm_floating_point_init+0x5c>
 800663a: f443 03a0    	orr	r3, r3, #0x500000
 800663e: f8c2 3088    	str.w	r3, [r2, #0x88]
; 	FPU->FPCCR = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
 8006642: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800667c <z_arm_floating_point_init+0x60>
 8006644: f04f 4240    	mov.w	r2, #0xc0000000
 8006648: 605a         	str	r2, [r3, #0x4]
;   __ASM volatile ("dsb 0xF":::"memory");
 800664a: f3bf 8f4f    	dsb	sy
; }
 800664e: bf00         	nop
; }
 8006650: bf00         	nop
; }
 8006652: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006654: f3bf 8f6f    	isb	sy
; }
 8006658: bf00         	nop
; }
 800665a: bf00         	nop
; }
 800665c: bf00         	nop
 800665e: 2300         	movs	r3, #0x0
 8006660: 607b         	str	r3, [r7, #0x4]
;   __builtin_arm_set_fpscr(fpscr);
 8006662: 687b         	ldr	r3, [r7, #0x4]
 8006664: eee1 3a10    	<unknown>
; }
 8006668: bf00         	nop
; }
 800666a: bf00         	nop
 800666c: 370c         	adds	r7, #0xc
 800666e: 46bd         	mov	sp, r7
 8006670: f85d 7b04    	ldr	r7, [sp], #4
 8006674: 4770         	bx	lr
 8006676: bf00         	nop

08006678 <$d>:
 8006678: 00 ed 00 e0  	.word	0xe000ed00
 800667c: 30 ef 00 e0  	.word	0xe000ef30

08006680 <arch_new_thread>:
; {
 8006680: b480         	push	{r7}
 8006682: b087         	sub	sp, #0x1c
 8006684: af00         	add	r7, sp, #0x0
 8006686: 60f8         	str	r0, [r7, #0xc]
 8006688: 60b9         	str	r1, [r7, #0x8]
 800668a: 607a         	str	r2, [r7, #0x4]
 800668c: 603b         	str	r3, [r7]
; 	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
 800668e: 687b         	ldr	r3, [r7, #0x4]
 8006690: 3b20         	subs	r3, #0x20
 8006692: 617b         	str	r3, [r7, #0x14]
; 	iframe->pc = (uint32_t)z_thread_entry;
 8006694: 4a16         	ldr	r2, [pc, #0x58]         @ 0x80066f0 <arch_new_thread+0x70>
 8006696: 697b         	ldr	r3, [r7, #0x14]
 8006698: 619a         	str	r2, [r3, #0x18]
; 	iframe->pc &= 0xfffffffe;
 800669a: 697b         	ldr	r3, [r7, #0x14]
 800669c: 699b         	ldr	r3, [r3, #0x18]
 800669e: f023 0201    	bic	r2, r3, #0x1
 80066a2: 697b         	ldr	r3, [r7, #0x14]
 80066a4: 619a         	str	r2, [r3, #0x18]
; 	iframe->a1 = (uint32_t)entry;
 80066a6: 683a         	ldr	r2, [r7]
 80066a8: 697b         	ldr	r3, [r7, #0x14]
 80066aa: 601a         	str	r2, [r3]
; 	iframe->a2 = (uint32_t)p1;
 80066ac: 6a3a         	ldr	r2, [r7, #0x20]
 80066ae: 697b         	ldr	r3, [r7, #0x14]
 80066b0: 605a         	str	r2, [r3, #0x4]
; 	iframe->a3 = (uint32_t)p2;
 80066b2: 6a7a         	ldr	r2, [r7, #0x24]
 80066b4: 697b         	ldr	r3, [r7, #0x14]
 80066b6: 609a         	str	r2, [r3, #0x8]
; 	iframe->a4 = (uint32_t)p3;
 80066b8: 6aba         	ldr	r2, [r7, #0x28]
 80066ba: 697b         	ldr	r3, [r7, #0x14]
 80066bc: 60da         	str	r2, [r3, #0xc]
; 	iframe->xpsr =
 80066be: 697b         	ldr	r3, [r7, #0x14]
 80066c0: f04f 7280    	mov.w	r2, #0x1000000
 80066c4: 61da         	str	r2, [r3, #0x1c]
; 	thread->callee_saved.psp = (uint32_t)iframe;
 80066c6: 697a         	ldr	r2, [r7, #0x14]
 80066c8: 68fb         	ldr	r3, [r7, #0xc]
 80066ca: 661a         	str	r2, [r3, #0x60]
; 	thread->arch.basepri = 0;
 80066cc: 68fb         	ldr	r3, [r7, #0xc]
 80066ce: 2200         	movs	r2, #0x0
 80066d0: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; 	thread->arch.mode = 0;
 80066d4: 68fb         	ldr	r3, [r7, #0xc]
 80066d6: 2200         	movs	r2, #0x0
 80066d8: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	thread->arch.mode_exc_return = DEFAULT_EXC_RETURN;
 80066dc: 68fb         	ldr	r3, [r7, #0xc]
 80066de: 22fd         	movs	r2, #0xfd
 80066e0: f883 2111    	strb.w	r2, [r3, #0x111]
; }
 80066e4: bf00         	nop
 80066e6: 371c         	adds	r7, #0x1c
 80066e8: 46bd         	mov	sp, r7
 80066ea: f85d 7b04    	ldr	r7, [sp], #4
 80066ee: 4770         	bx	lr

080066f0 <$d>:
 80066f0: 15 42 00 08  	.word	0x08004215

080066f4 <arch_float_disable>:
; {
 80066f4: b480         	push	{r7}
 80066f6: b08d         	sub	sp, #0x34
 80066f8: af00         	add	r7, sp, #0x0
 80066fa: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80066fc: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800679c <arch_float_disable+0xa8>
 80066fe: 689b         	ldr	r3, [r3, #0x8]
 8006700: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8006702: 6abb         	ldr	r3, [r7, #0x28]
; 	if (thread != arch_current_thread()) {
 8006704: 687a         	ldr	r2, [r7, #0x4]
 8006706: 429a         	cmp	r2, r3
 8006708: d002         	beq	0x8006710 <arch_float_disable+0x1c> @ imm = #0x4
; 		return -EINVAL;
 800670a: f06f 0315    	mvn	r3, #0x15
 800670e: e03f         	b	0x8006790 <arch_float_disable+0x9c> @ imm = #0x7e
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8006710: f3ef 8305    	mrs	r3, ipsr
 8006714: 627b         	str	r3, [r7, #0x24]
;   return(result);
 8006716: 6a7b         	ldr	r3, [r7, #0x24]
; 	return (__get_IPSR()) ? (true) : (false);
 8006718: 2b00         	cmp	r3, #0x0
 800671a: bf14         	ite	ne
 800671c: 2301         	movne	r3, #0x1
 800671e: 2300         	moveq	r3, #0x0
 8006720: b2db         	uxtb	r3, r3
; 	if (arch_is_in_isr()) {
 8006722: 2b00         	cmp	r3, #0x0
 8006724: d002         	beq	0x800672c <arch_float_disable+0x38> @ imm = #0x4
; 		return -EINVAL;
 8006726: f06f 0315    	mvn	r3, #0x15
 800672a: e031         	b	0x8006790 <arch_float_disable+0x9c> @ imm = #0x62
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800672c: f3ef 8311    	mrs	r3, basepri
 8006730: 613b         	str	r3, [r7, #0x10]
;   return(result);
 8006732: 693b         	ldr	r3, [r7, #0x10]
; 	key = __get_BASEPRI();
 8006734: 60fb         	str	r3, [r7, #0xc]
 8006736: 2310         	movs	r3, #0x10
 8006738: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800673a: 68bb         	ldr	r3, [r7, #0x8]
 800673c: f383 8812    	msr	basepri_max, r3
; }
 8006740: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006742: f3bf 8f6f    	isb	sy
; }
 8006746: bf00         	nop
; 	return key;
 8006748: 68fb         	ldr	r3, [r7, #0xc]
; 	int key = arch_irq_lock();
 800674a: 62fb         	str	r3, [r7, #0x2c]
; 	thread->base.user_options &= ~K_FP_REGS;
 800674c: 687b         	ldr	r3, [r7, #0x4]
 800674e: 7b1b         	ldrb	r3, [r3, #0xc]
 8006750: f023 0302    	bic	r3, r3, #0x2
 8006754: b2da         	uxtb	r2, r3
 8006756: 687b         	ldr	r3, [r7, #0x4]
 8006758: 731a         	strb	r2, [r3, #0xc]
;   __ASM volatile ("MRS %0, control" : "=r" (result) );
 800675a: f3ef 8314    	mrs	r3, control
 800675e: 617b         	str	r3, [r7, #0x14]
;   return(result);
 8006760: 697b         	ldr	r3, [r7, #0x14]
; 	__set_CONTROL(__get_CONTROL() & (~CONTROL_FPCA_Msk));
 8006762: f023 0304    	bic	r3, r3, #0x4
 8006766: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 8006768: 69bb         	ldr	r3, [r7, #0x18]
 800676a: f383 8814    	msr	control, r3
;   __ASM volatile ("isb 0xF":::"memory");
 800676e: f3bf 8f6f    	isb	sy
; }
 8006772: bf00         	nop
; }
 8006774: bf00         	nop
; 	arch_irq_unlock(key);
 8006776: 6afb         	ldr	r3, [r7, #0x2c]
 8006778: 623b         	str	r3, [r7, #0x20]
 800677a: 6a3b         	ldr	r3, [r7, #0x20]
 800677c: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800677e: 69fb         	ldr	r3, [r7, #0x1c]
 8006780: f383 8811    	msr	basepri, r3
; }
 8006784: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006786: f3bf 8f6f    	isb	sy
; }
 800678a: bf00         	nop
; }
 800678c: bf00         	nop
; 	return 0;
 800678e: 2300         	movs	r3, #0x0
; }
 8006790: 4618         	mov	r0, r3
 8006792: 3734         	adds	r7, #0x34
 8006794: 46bd         	mov	sp, r7
 8006796: f85d 7b04    	ldr	r7, [sp], #4
 800679a: 4770         	bx	lr

0800679c <$d>:
 800679c: 60 20 00 24  	.word	0x24002060

080067a0 <arch_switch_to_main_thread>:
; {
 80067a0: b5f0         	push	{r4, r5, r6, r7, lr}
 80067a2: b087         	sub	sp, #0x1c
 80067a4: af00         	add	r7, sp, #0x0
 80067a6: 60f8         	str	r0, [r7, #0xc]
 80067a8: 60b9         	str	r1, [r7, #0x8]
 80067aa: 607a         	str	r2, [r7, #0x4]
; 	z_arm_prepare_switch_to_main();
 80067ac: f016 ff3f    	bl	0x801d62e <z_arm_prepare_switch_to_main> @ imm = #0x16e7e
 80067b0: 68fb         	ldr	r3, [r7, #0xc]
 80067b2: 617b         	str	r3, [r7, #0x14]
; 	_current_cpu->current = thread;
 80067b4: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x80067f0 <arch_switch_to_main_thread+0x50>
 80067b6: 697b         	ldr	r3, [r7, #0x14]
 80067b8: 6093         	str	r3, [r2, #0x8]
; }
 80067ba: bf00         	nop
; 	z_arm_tls_ptr = main_thread->tls;
 80067bc: 68fb         	ldr	r3, [r7, #0xc]
 80067be: f8d3 30c4    	ldr.w	r3, [r3, #0xc4]
 80067c2: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80067f4 <arch_switch_to_main_thread+0x54>
 80067c4: 6013         	str	r3, [r2]
; 	z_thread_mark_switched_in();
 80067c6: f00f fcff    	bl	0x80161c8 <z_thread_mark_switched_in> @ imm = #0xf9fe
; 	__asm__ volatile (
 80067ca: 687d         	ldr	r5, [r7, #0x4]
 80067cc: 68be         	ldr	r6, [r7, #0x8]
 80067ce: 462c         	mov	r4, r5
 80067d0: f386 8809    	msr	psp, r6
 80067d4: f04f 0000    	mov.w	r0, #0x0
 80067d8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80067f8 <arch_switch_to_main_thread+0x58>
 80067da: 4798         	blx	r3
 80067dc: 4620         	mov	r0, r4
 80067de: f04f 0100    	mov.w	r1, #0x0
 80067e2: f04f 0200    	mov.w	r2, #0x0
 80067e6: f04f 0300    	mov.w	r3, #0x0
 80067ea: 4c04         	ldr	r4, [pc, #0x10]         @ 0x80067fc <arch_switch_to_main_thread+0x5c>
 80067ec: 4720         	bx	r4
 80067ee: bf00         	nop

080067f0 <$d>:
 80067f0: 60 20 00 24  	.word	0x24002060
 80067f4: 58 28 00 24  	.word	0x24002858

080067f8 <$d>:
 80067f8: 73 d6 01 08  	.word	0x0801d673
 80067fc: 15 42 00 08  	.word	0x08004215

08006800 <z_arm_cpu_idle_init>:
; {
 8006800: b480         	push	{r7}
 8006802: af00         	add	r7, sp, #0x0
; 	SCB->SCR = SCB_SCR_SEVONPEND_Msk;
 8006804: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8006814 <z_arm_cpu_idle_init+0x14>
 8006806: 2210         	movs	r2, #0x10
 8006808: 611a         	str	r2, [r3, #0x10]
; }
 800680a: bf00         	nop
 800680c: 46bd         	mov	sp, r7
 800680e: f85d 7b04    	ldr	r7, [sp], #4
 8006812: 4770         	bx	lr

08006814 <$d>:
 8006814: 00 ed 00 e0  	.word	0xe000ed00

08006818 <__NVIC_SetPriority>:
; {
 8006818: b480         	push	{r7}
 800681a: b083         	sub	sp, #0xc
 800681c: af00         	add	r7, sp, #0x0
 800681e: 4603         	mov	r3, r0
 8006820: 6039         	str	r1, [r7]
 8006822: 80fb         	strh	r3, [r7, #0x6]
;   if ((int32_t)(IRQn) >= 0)
 8006824: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 8006828: 2b00         	cmp	r3, #0x0
 800682a: db0a         	blt	0x8006842 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800682c: 683b         	ldr	r3, [r7]
 800682e: b2da         	uxtb	r2, r3
 8006830: 490c         	ldr	r1, [pc, #0x30]         @ 0x8006864 <__NVIC_SetPriority+0x4c>
 8006832: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 8006836: 0112         	lsls	r2, r2, #0x4
 8006838: b2d2         	uxtb	r2, r2
 800683a: 440b         	add	r3, r1
 800683c: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8006840: e00a         	b	0x8006858 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8006842: 683b         	ldr	r3, [r7]
 8006844: b2da         	uxtb	r2, r3
 8006846: 4908         	ldr	r1, [pc, #0x20]         @ 0x8006868 <__NVIC_SetPriority+0x50>
 8006848: 88fb         	ldrh	r3, [r7, #0x6]
 800684a: f003 030f    	and	r3, r3, #0xf
 800684e: 3b04         	subs	r3, #0x4
 8006850: 0112         	lsls	r2, r2, #0x4
 8006852: b2d2         	uxtb	r2, r2
 8006854: 440b         	add	r3, r1
 8006856: 761a         	strb	r2, [r3, #0x18]
; }
 8006858: bf00         	nop
 800685a: 370c         	adds	r7, #0xc
 800685c: 46bd         	mov	sp, r7
 800685e: f85d 7b04    	ldr	r7, [sp], #4
 8006862: 4770         	bx	lr

08006864 <$d>:
 8006864: 00 e1 00 e0  	.word	0xe000e100
 8006868: 00 ed 00 e0  	.word	0xe000ed00

0800686c <_isr_wrapper>:
; {
 800686c: b580         	push	{r7, lr}
 800686e: b084         	sub	sp, #0x10
 8006870: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8006872: f3ef 8305    	mrs	r3, ipsr
 8006876: 607b         	str	r3, [r7, #0x4]
;   return(result);
 8006878: 687b         	ldr	r3, [r7, #0x4]
; 	int32_t irq_number = __get_IPSR();
 800687a: 60fb         	str	r3, [r7, #0xc]
; 	irq_number -= 16;
 800687c: 68fb         	ldr	r3, [r7, #0xc]
 800687e: 3b10         	subs	r3, #0x10
 8006880: 60fb         	str	r3, [r7, #0xc]
; 	struct _isr_table_entry *entry = &_sw_isr_table[irq_number];
 8006882: 68fb         	ldr	r3, [r7, #0xc]
 8006884: 00db         	lsls	r3, r3, #0x3
 8006886: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80068a4 <_isr_wrapper+0x38>
 8006888: 4413         	add	r3, r2
 800688a: 60bb         	str	r3, [r7, #0x8]
; 	(entry->isr)(entry->arg);
 800688c: 68bb         	ldr	r3, [r7, #0x8]
 800688e: 685b         	ldr	r3, [r3, #0x4]
 8006890: 68ba         	ldr	r2, [r7, #0x8]
 8006892: 6812         	ldr	r2, [r2]
 8006894: 4610         	mov	r0, r2
 8006896: 4798         	blx	r3
; 	z_arm_exc_exit();
 8006898: f7fe fee6    	bl	0x8005668 <z_arm_int_exit> @ imm = #-0x1234
; }
 800689c: bf00         	nop
 800689e: 3710         	adds	r7, #0x10
 80068a0: 46bd         	mov	sp, r7
 80068a2: bd80         	pop	{r7, pc}

080068a4 <$d>:
 80068a4: a8 9a 02 08  	.word	0x08029aa8

080068a8 <cbvprintf>:
; {
 80068a8: b580         	push	{r7, lr}
 80068aa: b08a         	sub	sp, #0x28
 80068ac: af00         	add	r7, sp, #0x0
 80068ae: 60f8         	str	r0, [r7, #0xc]
 80068b0: 60b9         	str	r1, [r7, #0x8]
 80068b2: 607a         	str	r2, [r7, #0x4]
 80068b4: 603b         	str	r3, [r7]
; 	struct cb_bits	s = {
 80068b6: f107 0310    	add.w	r3, r7, #0x10
 80068ba: 2200         	movs	r2, #0x0
 80068bc: 601a         	str	r2, [r3]
 80068be: 605a         	str	r2, [r3, #0x4]
 80068c0: 609a         	str	r2, [r3, #0x8]
 80068c2: 60da         	str	r2, [r3, #0xc]
 80068c4: 611a         	str	r2, [r3, #0x10]
 80068c6: 615a         	str	r2, [r3, #0x14]
 80068c8: 2302         	movs	r3, #0x2
 80068ca: 74bb         	strb	r3, [r7, #0x12]
 80068cc: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80068f0 <cbvprintf+0x48>
 80068ce: 617b         	str	r3, [r7, #0x14]
 80068d0: 68fb         	ldr	r3, [r7, #0xc]
 80068d2: 623b         	str	r3, [r7, #0x20]
 80068d4: 68bb         	ldr	r3, [r7, #0x8]
 80068d6: 627b         	str	r3, [r7, #0x24]
; 	return vfprintf(&s.f, fp, ap);
 80068d8: f107 0310    	add.w	r3, r7, #0x10
 80068dc: 683a         	ldr	r2, [r7]
 80068de: 6879         	ldr	r1, [r7, #0x4]
 80068e0: 4618         	mov	r0, r3
 80068e2: f012 f8d1    	bl	0x8018a88 <vfprintf>    @ imm = #0x121a2
 80068e6: 4603         	mov	r3, r0
; }
 80068e8: 4618         	mov	r0, r3
 80068ea: 3728         	adds	r7, #0x28
 80068ec: 46bd         	mov	sp, r7
 80068ee: bd80         	pop	{r7, pc}

080068f0 <$d>:
 80068f0: 0f d7 01 08  	.word	0x0801d70f

080068f4 <z_impl_zephyr_fputc>:
; {
 80068f4: b580         	push	{r7, lr}
 80068f6: b082         	sub	sp, #0x8
 80068f8: af00         	add	r7, sp, #0x0
 80068fa: 6078         	str	r0, [r7, #0x4]
 80068fc: 6039         	str	r1, [r7]
; 	(*_stdout_hook)(a);
 80068fe: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8006910 <z_impl_zephyr_fputc+0x1c>
 8006900: 681b         	ldr	r3, [r3]
 8006902: 6878         	ldr	r0, [r7, #0x4]
 8006904: 4798         	blx	r3
; 	return 0;
 8006906: 2300         	movs	r3, #0x0
; }
 8006908: 4618         	mov	r0, r3
 800690a: 3708         	adds	r7, #0x8
 800690c: 46bd         	mov	sp, r7
 800690e: bd80         	pop	{r7, pc}

08006910 <$d>:
 8006910: 5c 28 00 24  	.word	0x2400285c

08006914 <__stdout_hook_install>:
; {
 8006914: b480         	push	{r7}
 8006916: b083         	sub	sp, #0xc
 8006918: af00         	add	r7, sp, #0x0
 800691a: 6078         	str	r0, [r7, #0x4]
; 	_stdout_hook = hook;
 800691c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800693c <__stdout_hook_install+0x28>
 800691e: 687b         	ldr	r3, [r7, #0x4]
 8006920: 6013         	str	r3, [r2]
; 	__stdout.flags |= _FDEV_SETUP_WRITE;
 8006922: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8006940 <__stdout_hook_install+0x2c>
 8006924: 789b         	ldrb	r3, [r3, #0x2]
 8006926: f043 0302    	orr	r3, r3, #0x2
 800692a: b2da         	uxtb	r2, r3
 800692c: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8006940 <__stdout_hook_install+0x2c>
 800692e: 709a         	strb	r2, [r3, #0x2]
; }
 8006930: bf00         	nop
 8006932: 370c         	adds	r7, #0xc
 8006934: 46bd         	mov	sp, r7
 8006936: f85d 7b04    	ldr	r7, [sp], #4
 800693a: 4770         	bx	lr

0800693c <$d>:
 800693c: 5c 28 00 24  	.word	0x2400285c
 8006940: 70 06 00 24  	.word	0x24000670

08006944 <malloc_lock>:
; malloc_lock(void) {
 8006944: b580         	push	{r7, lr}
 8006946: b082         	sub	sp, #0x8
 8006948: af00         	add	r7, sp, #0x0
; 	lock_ret = sys_mutex_lock(&z_malloc_heap_mutex, K_FOREVER);
 800694a: f04f 32ff    	mov.w	r2, #0xffffffff
 800694e: f04f 33ff    	mov.w	r3, #0xffffffff
 8006952: 4804         	ldr	r0, [pc, #0x10]         @ 0x8006964 <malloc_lock+0x20>
 8006954: f016 ff29    	bl	0x801d7aa <sys_mutex_lock> @ imm = #0x16e52
 8006958: 6078         	str	r0, [r7, #0x4]
; }
 800695a: bf00         	nop
 800695c: 3708         	adds	r7, #0x8
 800695e: 46bd         	mov	sp, r7
 8006960: bd80         	pop	{r7, pc}
 8006962: bf00         	nop

08006964 <$d>:
 8006964: 80 06 00 24  	.word	0x24000680

08006968 <malloc_unlock>:
; {
 8006968: b580         	push	{r7, lr}
 800696a: af00         	add	r7, sp, #0x0
; 	(void) sys_mutex_unlock(&z_malloc_heap_mutex);
 800696c: 4802         	ldr	r0, [pc, #0x8]          @ 0x8006978 <malloc_unlock+0x10>
 800696e: f016 ff2d    	bl	0x801d7cc <sys_mutex_unlock> @ imm = #0x16e5a
; }
 8006972: bf00         	nop
 8006974: bd80         	pop	{r7, pc}
 8006976: bf00         	nop

08006978 <$d>:
 8006978: 80 06 00 24  	.word	0x24000680

0800697c <malloc>:
; {
 800697c: b580         	push	{r7, lr}
 800697e: b084         	sub	sp, #0x10
 8006980: af00         	add	r7, sp, #0x0
 8006982: 6078         	str	r0, [r7, #0x4]
; 	malloc_lock();
 8006984: f7ff ffde    	bl	0x8006944 <malloc_lock> @ imm = #-0x44
; 	void *ret = sys_heap_aligned_alloc(&z_malloc_heap,
 8006988: 687a         	ldr	r2, [r7, #0x4]
 800698a: 2108         	movs	r1, #0x8
 800698c: 480b         	ldr	r0, [pc, #0x2c]         @ 0x80069bc <malloc+0x40>
 800698e: f015 fc4e    	bl	0x801c22e <sys_heap_aligned_alloc> @ imm = #0x1589c
 8006992: 60f8         	str	r0, [r7, #0xc]
; 	if (ret == NULL && size != 0) {
 8006994: 68fb         	ldr	r3, [r7, #0xc]
 8006996: 2b00         	cmp	r3, #0x0
 8006998: d108         	bne	0x80069ac <malloc+0x30> @ imm = #0x10
 800699a: 687b         	ldr	r3, [r7, #0x4]
 800699c: 2b00         	cmp	r3, #0x0
 800699e: d005         	beq	0x80069ac <malloc+0x30> @ imm = #0xa
; 		errno = ENOMEM;
 80069a0: f022 fd98    	bl	0x80294d4 <__aeabi_read_tp> @ imm = #0x22b30
 80069a4: 4603         	mov	r3, r0
 80069a6: 4a06         	ldr	r2, [pc, #0x18]         @ 0x80069c0 <malloc+0x44>
 80069a8: 210c         	movs	r1, #0xc
 80069aa: 5099         	str	r1, [r3, r2]
; 	malloc_unlock();
 80069ac: f7ff ffdc    	bl	0x8006968 <malloc_unlock> @ imm = #-0x48
; 	return ret;
 80069b0: 68fb         	ldr	r3, [r7, #0xc]
; }
 80069b2: 4618         	mov	r0, r3
 80069b4: 3710         	adds	r7, #0x10
 80069b6: 46bd         	mov	sp, r7
 80069b8: bd80         	pop	{r7, pc}
 80069ba: bf00         	nop

080069bc <$d>:
 80069bc: 60 28 00 24  	.word	0x24002860
 80069c0: 0c 00 00 00  	.word	0x0000000c

080069c4 <malloc_prepare>:
; {
 80069c4: b580         	push	{r7, lr}
 80069c6: b082         	sub	sp, #0x8
 80069c8: af00         	add	r7, sp, #0x0
; 	void *heap_base = NULL;
 80069ca: 2300         	movs	r3, #0x0
 80069cc: 607b         	str	r3, [r7, #0x4]
; 	heap_base = UINT_TO_POINTER(HEAP_BASE);
 80069ce: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80069fc <malloc_prepare+0x38>
 80069d0: 3307         	adds	r3, #0x7
 80069d2: f023 0307    	bic	r3, r3, #0x7
 80069d6: 607b         	str	r3, [r7, #0x4]
; 	heap_size = HEAP_SIZE;
 80069d8: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80069fc <malloc_prepare+0x38>
 80069da: 3307         	adds	r3, #0x7
 80069dc: f023 0207    	bic	r2, r3, #0x7
 80069e0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8006a00 <malloc_prepare+0x3c>
 80069e2: 1a9b         	subs	r3, r3, r2
 80069e4: 603b         	str	r3, [r7]
; 	sys_heap_init(&z_malloc_heap, heap_base, heap_size);
 80069e6: 683a         	ldr	r2, [r7]
 80069e8: 6879         	ldr	r1, [r7, #0x4]
 80069ea: 4806         	ldr	r0, [pc, #0x18]         @ 0x8006a04 <malloc_prepare+0x40>
 80069ec: f015 fcc8    	bl	0x801c380 <sys_heap_init> @ imm = #0x15990
; 	return 0;
 80069f0: 2300         	movs	r3, #0x0
; }
 80069f2: 4618         	mov	r0, r3
 80069f4: 3708         	adds	r7, #0x8
 80069f6: 46bd         	mov	sp, r7
 80069f8: bd80         	pop	{r7, pc}
 80069fa: bf00         	nop

080069fc <$d>:
 80069fc: f8 71 00 24  	.word	0x240071f8
 8006a00: 00 00 05 24  	.word	0x24050000
 8006a04: 60 28 00 24  	.word	0x24002860

08006a08 <k_current_get>:
; {
 8006a08: b580         	push	{r7, lr}
 8006a0a: af00         	add	r7, sp, #0x0
; 	return z_tls_current;
 8006a0c: f022 fd62    	bl	0x80294d4 <__aeabi_read_tp> @ imm = #0x22ac4
 8006a10: 4603         	mov	r3, r0
 8006a12: 4a02         	ldr	r2, [pc, #0x8]          @ 0x8006a1c <k_current_get+0x14>
 8006a14: 589b         	ldr	r3, [r3, r2]
; }
 8006a16: 4618         	mov	r0, r3
 8006a18: bd80         	pop	{r7, pc}
 8006a1a: bf00         	nop

08006a1c <$d>:
 8006a1c: 08 00 00 00  	.word	0x00000008

08006a20 <net_buf_pool_get>:
; {
 8006a20: b480         	push	{r7}
 8006a22: b085         	sub	sp, #0x14
 8006a24: af00         	add	r7, sp, #0x0
 8006a26: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(net_buf_pool, id, &pool);
 8006a28: 687a         	ldr	r2, [r7, #0x4]
 8006a2a: 4613         	mov	r3, r2
 8006a2c: 00db         	lsls	r3, r3, #0x3
 8006a2e: 4413         	add	r3, r2
 8006a30: 009b         	lsls	r3, r3, #0x2
 8006a32: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8006a48 <net_buf_pool_get+0x28>
 8006a34: 4413         	add	r3, r2
 8006a36: 60fb         	str	r3, [r7, #0xc]
; 	return pool;
 8006a38: 68fb         	ldr	r3, [r7, #0xc]
; }
 8006a3a: 4618         	mov	r0, r3
 8006a3c: 3714         	adds	r7, #0x14
 8006a3e: 46bd         	mov	sp, r7
 8006a40: f85d 7b04    	ldr	r7, [sp], #4
 8006a44: 4770         	bx	lr
 8006a46: bf00         	nop

08006a48 <$d>:
 8006a48: 60 0c 00 24  	.word	0x24000c60

08006a4c <pool_id>:
; {
 8006a4c: b480         	push	{r7}
 8006a4e: b083         	sub	sp, #0xc
 8006a50: af00         	add	r7, sp, #0x0
 8006a52: 6078         	str	r0, [r7, #0x4]
; 	return pool - TYPE_SECTION_START(net_buf_pool);
 8006a54: 687b         	ldr	r3, [r7, #0x4]
 8006a56: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8006a70 <pool_id+0x24>
 8006a58: 1a9b         	subs	r3, r3, r2
 8006a5a: 109b         	asrs	r3, r3, #0x2
 8006a5c: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8006a74 <pool_id+0x28>
 8006a5e: fb02 f303    	mul	r3, r2, r3
; }
 8006a62: 4618         	mov	r0, r3
 8006a64: 370c         	adds	r7, #0xc
 8006a66: 46bd         	mov	sp, r7
 8006a68: f85d 7b04    	ldr	r7, [sp], #4
 8006a6c: 4770         	bx	lr
 8006a6e: bf00         	nop

08006a70 <$d>:
 8006a70: 60 0c 00 24  	.word	0x24000c60
 8006a74: 39 8e e3 38  	.word	0x38e38e39

08006a78 <net_buf_alloc_len>:
; {
 8006a78: b590         	push	{r4, r7, lr}
 8006a7a: b0a7         	sub	sp, #0x9c
 8006a7c: af04         	add	r7, sp, #0x10
 8006a7e: 60f8         	str	r0, [r7, #0xc]
 8006a80: 60b9         	str	r1, [r7, #0x8]
 8006a82: e9c7 2300    	strd	r2, r3, [r7]
; 	k_timepoint_t end = sys_timepoint_calc(timeout);
 8006a86: f107 0128    	add.w	r1, r7, #0x28
 8006a8a: e9d7 2300    	ldrd	r2, r3, [r7]
 8006a8e: 4608         	mov	r0, r1
 8006a90: f022 f9ac    	bl	0x8028dec <sys_timepoint_calc> @ imm = #0x22358
; 	key = k_spin_lock(&pool->lock);
 8006a94: 68fb         	ldr	r3, [r7, #0xc]
 8006a96: 3310         	adds	r3, #0x10
 8006a98: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8006a9a: f3ef 8311    	mrs	r3, basepri
 8006a9e: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 8006aa0: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 8006aa2: 667b         	str	r3, [r7, #0x64]
 8006aa4: 2310         	movs	r3, #0x10
 8006aa6: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8006aa8: 6e3b         	ldr	r3, [r7, #0x60]
 8006aaa: f383 8812    	msr	basepri_max, r3
; }
 8006aae: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006ab0: f3bf 8f6f    	isb	sy
; }
 8006ab4: bf00         	nop
; 	return key;
 8006ab6: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 8006ab8: 61fb         	str	r3, [r7, #0x1c]
 8006aba: 6efb         	ldr	r3, [r7, #0x6c]
 8006abc: 65fb         	str	r3, [r7, #0x5c]
; }
 8006abe: bf00         	nop
 8006ac0: 6efb         	ldr	r3, [r7, #0x6c]
 8006ac2: 65bb         	str	r3, [r7, #0x58]
; }
 8006ac4: bf00         	nop
; 	return k;
 8006ac6: 69fb         	ldr	r3, [r7, #0x1c]
 8006ac8: 627b         	str	r3, [r7, #0x24]
; 	if (pool->uninit_count) {
 8006aca: 68fb         	ldr	r3, [r7, #0xc]
 8006acc: 8a5b         	ldrh	r3, [r3, #0x12]
 8006ace: 2b00         	cmp	r3, #0x0
 8006ad0: d04b         	beq	0x8006b6a <net_buf_alloc_len+0xf2> @ imm = #0x96
; 		if (pool->uninit_count < pool->buf_count) {
 8006ad2: 68fb         	ldr	r3, [r7, #0xc]
 8006ad4: 8a5a         	ldrh	r2, [r3, #0x12]
 8006ad6: 68fb         	ldr	r3, [r7, #0xc]
 8006ad8: 8a1b         	ldrh	r3, [r3, #0x10]
 8006ada: 429a         	cmp	r2, r3
 8006adc: d222         	bhs	0x8006b24 <net_buf_alloc_len+0xac> @ imm = #0x44
; 			buf = k_lifo_get(&pool->free, K_NO_WAIT);
 8006ade: 68f9         	ldr	r1, [r7, #0xc]
 8006ae0: f04f 0200    	mov.w	r2, #0x0
 8006ae4: f04f 0300    	mov.w	r3, #0x0
 8006ae8: 4608         	mov	r0, r1
 8006aea: f016 fea5    	bl	0x801d838 <k_queue_get> @ imm = #0x16d4a
 8006aee: 6778         	str	r0, [r7, #0x74]
 8006af0: 6f79         	ldr	r1, [r7, #0x74]
 8006af2: f8c7 1084    	str.w	r1, [r7, #0x84]
; 			if (buf) {
 8006af6: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006afa: 2b00         	cmp	r3, #0x0
 8006afc: d012         	beq	0x8006b24 <net_buf_alloc_len+0xac> @ imm = #0x24
; 				k_spin_unlock(&pool->lock, key);
 8006afe: 68fb         	ldr	r3, [r7, #0xc]
 8006b00: 3310         	adds	r3, #0x10
 8006b02: 657b         	str	r3, [r7, #0x54]
 8006b04: 6a7b         	ldr	r3, [r7, #0x24]
 8006b06: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8006b08: 697b         	ldr	r3, [r7, #0x14]
 8006b0a: 653b         	str	r3, [r7, #0x50]
 8006b0c: 6d3b         	ldr	r3, [r7, #0x50]
 8006b0e: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006b10: 6cfb         	ldr	r3, [r7, #0x4c]
 8006b12: f383 8811    	msr	basepri, r3
; }
 8006b16: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006b18: f3bf 8f6f    	isb	sy
; }
 8006b1c: bf00         	nop
; }
 8006b1e: bf00         	nop
; }
 8006b20: bf00         	nop
; 				goto success;
 8006b22: e07a         	b	0x8006c1a <net_buf_alloc_len+0x1a2> @ imm = #0xf4
; 		uninit_count = pool->uninit_count--;
 8006b24: 68fb         	ldr	r3, [r7, #0xc]
 8006b26: 8a5b         	ldrh	r3, [r3, #0x12]
 8006b28: 1e5a         	subs	r2, r3, #0x1
 8006b2a: b291         	uxth	r1, r2
 8006b2c: 68fa         	ldr	r2, [r7, #0xc]
 8006b2e: 8251         	strh	r1, [r2, #0x12]
 8006b30: f8a7 3072    	strh.w	r3, [r7, #0x72]
; 		k_spin_unlock(&pool->lock, key);
 8006b34: 68fb         	ldr	r3, [r7, #0xc]
 8006b36: 3310         	adds	r3, #0x10
 8006b38: 64bb         	str	r3, [r7, #0x48]
 8006b3a: 6a7b         	ldr	r3, [r7, #0x24]
 8006b3c: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8006b3e: 69bb         	ldr	r3, [r7, #0x18]
 8006b40: 647b         	str	r3, [r7, #0x44]
 8006b42: 6c7b         	ldr	r3, [r7, #0x44]
 8006b44: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006b46: 6c3b         	ldr	r3, [r7, #0x40]
 8006b48: f383 8811    	msr	basepri, r3
; }
 8006b4c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006b4e: f3bf 8f6f    	isb	sy
; }
 8006b52: bf00         	nop
; }
 8006b54: bf00         	nop
; }
 8006b56: bf00         	nop
; 		buf = pool_get_uninit(pool, uninit_count);
 8006b58: f8b7 3072    	ldrh.w	r3, [r7, #0x72]
 8006b5c: 4619         	mov	r1, r3
 8006b5e: 68f8         	ldr	r0, [r7, #0xc]
 8006b60: f016 fed4    	bl	0x801d90c <pool_get_uninit> @ imm = #0x16da8
 8006b64: f8c7 0084    	str.w	r0, [r7, #0x84]
; 		goto success;
 8006b68: e057         	b	0x8006c1a <net_buf_alloc_len+0x1a2> @ imm = #0xae
; 	k_spin_unlock(&pool->lock, key);
 8006b6a: 68fb         	ldr	r3, [r7, #0xc]
 8006b6c: 3310         	adds	r3, #0x10
 8006b6e: 63fb         	str	r3, [r7, #0x3c]
 8006b70: 6a7b         	ldr	r3, [r7, #0x24]
 8006b72: 623b         	str	r3, [r7, #0x20]
; 	arch_irq_unlock(key.key);
 8006b74: 6a3b         	ldr	r3, [r7, #0x20]
 8006b76: 63bb         	str	r3, [r7, #0x38]
 8006b78: 6bbb         	ldr	r3, [r7, #0x38]
 8006b7a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006b7c: 6b7b         	ldr	r3, [r7, #0x34]
 8006b7e: f383 8811    	msr	basepri, r3
; }
 8006b82: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006b84: f3bf 8f6f    	isb	sy
; }
 8006b88: bf00         	nop
; }
 8006b8a: bf00         	nop
; }
 8006b8c: bf00         	nop
; 	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 8006b8e: e9d7 2300    	ldrd	r2, r3, [r7]
 8006b92: f04f 0000    	mov.w	r0, #0x0
 8006b96: f04f 0100    	mov.w	r1, #0x0
 8006b9a: 428b         	cmp	r3, r1
 8006b9c: bf08         	it	eq
 8006b9e: 4282         	cmpeq	r2, r0
 8006ba0: d02a         	beq	0x8006bf8 <net_buf_alloc_len+0x180> @ imm = #0x54
; 	    k_current_get() == k_work_queue_thread_get(&k_sys_work_q)) {
 8006ba2: f7ff ff31    	bl	0x8006a08 <k_current_get> @ imm = #-0x19e
 8006ba6: 4604         	mov	r4, r0
 8006ba8: 4841         	ldr	r0, [pc, #0x104]        @ 0x8006cb0 <net_buf_alloc_len+0x238>
 8006baa: f016 fe3a    	bl	0x801d822 <k_work_queue_thread_get> @ imm = #0x16c74
 8006bae: 4603         	mov	r3, r0
; 	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 8006bb0: 429c         	cmp	r4, r3
 8006bb2: d121         	bne	0x8006bf8 <net_buf_alloc_len+0x180> @ imm = #0x42
; 		LOG_WRN("Timeout discarded. No blocking in syswq");
 8006bb4: 2303         	movs	r3, #0x3
 8006bb6: 2b01         	cmp	r3, #0x1
 8006bb8: d918         	bls	0x8006bec <net_buf_alloc_len+0x174> @ imm = #0x30
 8006bba: 2301         	movs	r3, #0x1
 8006bbc: f887 3083    	strb.w	r3, [r7, #0x83]
 8006bc0: f897 3083    	ldrb.w	r3, [r7, #0x83]
 8006bc4: f083 0301    	eor	r3, r3, #0x1
 8006bc8: b2db         	uxtb	r3, r3
 8006bca: 2b00         	cmp	r3, #0x0
 8006bcc: d10e         	bne	0x8006bec <net_buf_alloc_len+0x174> @ imm = #0x1c
 8006bce: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8006cb4 <net_buf_alloc_len+0x23c>
 8006bd0: 6819         	ldr	r1, [r3]
 8006bd2: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8006cb8 <net_buf_alloc_len+0x240>
 8006bd4: 9302         	str	r3, [sp, #0x8]
 8006bd6: 2300         	movs	r3, #0x0
 8006bd8: 9301         	str	r3, [sp, #0x4]
 8006bda: 2300         	movs	r3, #0x0
 8006bdc: 9300         	str	r3, [sp]
 8006bde: 2300         	movs	r3, #0x0
 8006be0: 2202         	movs	r2, #0x2
 8006be2: 2000         	movs	r0, #0x0
 8006be4: f016 fdff    	bl	0x801d7e6 <z_log_msg_runtime_create> @ imm = #0x16bfe
 8006be8: 2300         	movs	r3, #0x0
 8006bea: 67fb         	str	r3, [r7, #0x7c]
; 		timeout = K_NO_WAIT;
 8006bec: f04f 0200    	mov.w	r2, #0x0
 8006bf0: f04f 0300    	mov.w	r3, #0x0
 8006bf4: e9c7 2300    	strd	r2, r3, [r7]
; 	buf = k_lifo_get(&pool->free, timeout);
 8006bf8: 68f9         	ldr	r1, [r7, #0xc]
 8006bfa: e9d7 2300    	ldrd	r2, r3, [r7]
 8006bfe: 4608         	mov	r0, r1
 8006c00: f016 fe1a    	bl	0x801d838 <k_queue_get> @ imm = #0x16c34
 8006c04: 67b8         	str	r0, [r7, #0x78]
 8006c06: 6fbb         	ldr	r3, [r7, #0x78]
 8006c08: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	if (!buf) {
 8006c0c: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c10: 2b00         	cmp	r3, #0x0
 8006c12: d101         	bne	0x8006c18 <net_buf_alloc_len+0x1a0> @ imm = #0x2
; 		return NULL;
 8006c14: 2300         	movs	r3, #0x0
 8006c16: e046         	b	0x8006ca6 <net_buf_alloc_len+0x22e> @ imm = #0x8c
; success:
 8006c18: bf00         	nop
; 	if (size) {
 8006c1a: 68bb         	ldr	r3, [r7, #0x8]
 8006c1c: 2b00         	cmp	r3, #0x0
 8006c1e: d01c         	beq	0x8006c5a <net_buf_alloc_len+0x1e2> @ imm = #0x38
; 		timeout = sys_timepoint_timeout(end);
 8006c20: 4639         	mov	r1, r7
 8006c22: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8006c26: 4608         	mov	r0, r1
 8006c28: f022 f945    	bl	0x8028eb6 <sys_timepoint_timeout> @ imm = #0x2228a
; 		buf->__buf = data_alloc(buf, &size, timeout);
 8006c2c: f107 0108    	add.w	r1, r7, #0x8
 8006c30: e9d7 2300    	ldrd	r2, r3, [r7]
 8006c34: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 8006c38: f016 feeb    	bl	0x801da12 <data_alloc>  @ imm = #0x16dd6
 8006c3c: 4602         	mov	r2, r0
 8006c3e: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c42: 615a         	str	r2, [r3, #0x14]
; 		if (!buf->__buf) {
 8006c44: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c48: 695b         	ldr	r3, [r3, #0x14]
 8006c4a: 2b00         	cmp	r3, #0x0
 8006c4c: d109         	bne	0x8006c62 <net_buf_alloc_len+0x1ea> @ imm = #0x12
; 			net_buf_destroy(buf);
 8006c4e: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 8006c52: f016 fe12    	bl	0x801d87a <net_buf_destroy> @ imm = #0x16c24
; 			return NULL;
 8006c56: 2300         	movs	r3, #0x0
 8006c58: e025         	b	0x8006ca6 <net_buf_alloc_len+0x22e> @ imm = #0x4a
; 		buf->__buf = NULL;
 8006c5a: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c5e: 2200         	movs	r2, #0x0
 8006c60: 615a         	str	r2, [r3, #0x14]
; 	buf->ref   = 1U;
 8006c62: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c66: 2201         	movs	r2, #0x1
 8006c68: 721a         	strb	r2, [r3, #0x8]
; 	buf->flags = 0U;
 8006c6a: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c6e: 2200         	movs	r2, #0x0
 8006c70: 725a         	strb	r2, [r3, #0x9]
; 	buf->frags = NULL;
 8006c72: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c76: 2200         	movs	r2, #0x0
 8006c78: 605a         	str	r2, [r3, #0x4]
; 	buf->size  = size;
 8006c7a: 68bb         	ldr	r3, [r7, #0x8]
 8006c7c: b29a         	uxth	r2, r3
 8006c7e: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c82: 825a         	strh	r2, [r3, #0x12]
; 	memset(buf->user_data, 0, buf->user_data_size);
 8006c84: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c88: f103 0018    	add.w	r0, r3, #0x18
 8006c8c: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c90: 7adb         	ldrb	r3, [r3, #0xb]
 8006c92: 461a         	mov	r2, r3
 8006c94: 2100         	movs	r1, #0x0
 8006c96: f022 fa3b    	bl	0x8029110 <memset>      @ imm = #0x22476
; 	net_buf_reset(buf);
 8006c9a: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 8006c9e: f016 fe60    	bl	0x801d962 <net_buf_reset> @ imm = #0x16cc0
; 	return buf;
 8006ca2: f8d7 3084    	ldr.w	r3, [r7, #0x84]
; }
 8006ca6: 4618         	mov	r0, r3
 8006ca8: 378c         	adds	r7, #0x8c
 8006caa: 46bd         	mov	sp, r7
 8006cac: bd90         	pop	{r4, r7, pc}
 8006cae: bf00         	nop

08006cb0 <$d>:
 8006cb0: d8 22 00 24  	.word	0x240022d8
 8006cb4: 94 06 00 24  	.word	0x24000694
 8006cb8: 84 aa 02 08  	.word	0x0802aa84

08006cbc <k_current_get>:
; {
 8006cbc: b580         	push	{r7, lr}
 8006cbe: af00         	add	r7, sp, #0x0
; 	return z_tls_current;
 8006cc0: f022 fc08    	bl	0x80294d4 <__aeabi_read_tp> @ imm = #0x22810
 8006cc4: 4603         	mov	r3, r0
 8006cc6: 4a02         	ldr	r2, [pc, #0x8]          @ 0x8006cd0 <k_current_get+0x14>
 8006cc8: 589b         	ldr	r3, [r3, r2]
; }
 8006cca: 4618         	mov	r0, r3
 8006ccc: bd80         	pop	{r7, pc}
 8006cce: bf00         	nop

08006cd0 <$d>:
 8006cd0: 08 00 00 00  	.word	0x00000008

08006cd4 <_zbus_init>:
; {
 8006cd4: b480         	push	{r7}
 8006cd6: b085         	sub	sp, #0x14
 8006cd8: af00         	add	r7, sp, #0x0
; 	const struct zbus_channel *curr = NULL;
 8006cda: 2300         	movs	r3, #0x0
 8006cdc: 607b         	str	r3, [r7, #0x4]
; 	const struct zbus_channel *prev = NULL;
 8006cde: 2300         	movs	r3, #0x0
 8006ce0: 60fb         	str	r3, [r7, #0xc]
; 	STRUCT_SECTION_FOREACH(zbus_channel_observation, observation) {
 8006ce2: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8006d68 <_zbus_init+0x94>
 8006ce4: 60bb         	str	r3, [r7, #0x8]
 8006ce6: e02e         	b	0x8006d46 <_zbus_init+0x72> @ imm = #0x5c
; 		curr = observation->chan;
 8006ce8: 68bb         	ldr	r3, [r7, #0x8]
 8006cea: 681b         	ldr	r3, [r3]
 8006cec: 607b         	str	r3, [r7, #0x4]
; 		if (prev != curr) {
 8006cee: 68fa         	ldr	r2, [r7, #0xc]
 8006cf0: 687b         	ldr	r3, [r7, #0x4]
 8006cf2: 429a         	cmp	r2, r3
 8006cf4: d01b         	beq	0x8006d2e <_zbus_init+0x5a> @ imm = #0x36
; 			if (prev == NULL) {
 8006cf6: 68fb         	ldr	r3, [r7, #0xc]
 8006cf8: 2b00         	cmp	r3, #0x0
 8006cfa: d108         	bne	0x8006d0e <_zbus_init+0x3a> @ imm = #0x10
; 				curr->data->observers_start_idx = 0;
 8006cfc: 687b         	ldr	r3, [r7, #0x4]
 8006cfe: 691b         	ldr	r3, [r3, #0x10]
 8006d00: 2200         	movs	r2, #0x0
 8006d02: 801a         	strh	r2, [r3]
; 				curr->data->observers_end_idx = 0;
 8006d04: 687b         	ldr	r3, [r7, #0x4]
 8006d06: 691b         	ldr	r3, [r3, #0x10]
 8006d08: 2200         	movs	r2, #0x0
 8006d0a: 805a         	strh	r2, [r3, #0x2]
 8006d0c: e00d         	b	0x8006d2a <_zbus_init+0x56> @ imm = #0x1a
; 				curr->data->observers_start_idx = prev->data->observers_end_idx;
 8006d0e: 68fb         	ldr	r3, [r7, #0xc]
 8006d10: 691a         	ldr	r2, [r3, #0x10]
 8006d12: 687b         	ldr	r3, [r7, #0x4]
 8006d14: 691b         	ldr	r3, [r3, #0x10]
 8006d16: f9b2 2002    	ldrsh.w	r2, [r2, #0x2]
 8006d1a: 801a         	strh	r2, [r3]
; 				curr->data->observers_end_idx = prev->data->observers_end_idx;
 8006d1c: 68fb         	ldr	r3, [r7, #0xc]
 8006d1e: 691a         	ldr	r2, [r3, #0x10]
 8006d20: 687b         	ldr	r3, [r7, #0x4]
 8006d22: 691b         	ldr	r3, [r3, #0x10]
 8006d24: f9b2 2002    	ldrsh.w	r2, [r2, #0x2]
 8006d28: 805a         	strh	r2, [r3, #0x2]
; 			prev = curr;
 8006d2a: 687b         	ldr	r3, [r7, #0x4]
 8006d2c: 60fb         	str	r3, [r7, #0xc]
; 		++(curr->data->observers_end_idx);
 8006d2e: 687b         	ldr	r3, [r7, #0x4]
 8006d30: 691b         	ldr	r3, [r3, #0x10]
 8006d32: f9b3 2002    	ldrsh.w	r2, [r3, #0x2]
 8006d36: b292         	uxth	r2, r2
 8006d38: 3201         	adds	r2, #0x1
 8006d3a: b292         	uxth	r2, r2
 8006d3c: b212         	sxth	r2, r2
 8006d3e: 805a         	strh	r2, [r3, #0x2]
; 	STRUCT_SECTION_FOREACH(zbus_channel_observation, observation) {
 8006d40: 68bb         	ldr	r3, [r7, #0x8]
 8006d42: 3308         	adds	r3, #0x8
 8006d44: 60bb         	str	r3, [r7, #0x8]
 8006d46: 68bb         	ldr	r3, [r7, #0x8]
 8006d48: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8006d6c <_zbus_init+0x98>
 8006d4a: 4293         	cmp	r3, r2
 8006d4c: bf34         	ite	lo
 8006d4e: 2301         	movlo	r3, #0x1
 8006d50: 2300         	movhs	r3, #0x0
 8006d52: b2db         	uxtb	r3, r3
 8006d54: 2b00         	cmp	r3, #0x0
 8006d56: d1c7         	bne	0x8006ce8 <_zbus_init+0x14> @ imm = #-0x72
; 	return 0;
 8006d58: 2300         	movs	r3, #0x0
; }
 8006d5a: 4618         	mov	r0, r3
 8006d5c: 3714         	adds	r7, #0x14
 8006d5e: 46bd         	mov	sp, r7
 8006d60: f85d 7b04    	ldr	r7, [sp], #4
 8006d64: 4770         	bx	lr
 8006d66: bf00         	nop

08006d68 <$d>:
 8006d68: 80 a2 02 08  	.word	0x0802a280
 8006d6c: 88 a2 02 08  	.word	0x0802a288

08006d70 <_zbus_vded_exec>:
; {
 8006d70: b590         	push	{r4, r7, lr}
 8006d72: b0a1         	sub	sp, #0x84
 8006d74: af06         	add	r7, sp, #0x18
 8006d76: 60f8         	str	r0, [r7, #0xc]
 8006d78: e9c7 2300    	strd	r2, r3, [r7]
; 	int err = 0;
 8006d7c: 2300         	movs	r3, #0x0
 8006d7e: 653b         	str	r3, [r7, #0x50]
; 	int last_error = 0;
 8006d80: 2300         	movs	r3, #0x0
 8006d82: 65fb         	str	r3, [r7, #0x5c]
; 	struct net_buf *buf = NULL;
 8006d84: 2300         	movs	r3, #0x0
 8006d86: 64fb         	str	r3, [r7, #0x4c]
; 	struct net_buf_pool *pool =
 8006d88: 4b9f         	ldr	r3, [pc, #0x27c]        @ 0x8007008 <_zbus_vded_exec+0x298>
 8006d8a: 64bb         	str	r3, [r7, #0x48]
; 	buf = _zbus_create_net_buf(pool, zbus_chan_msg_size(chan), sys_timepoint_timeout(end_time));
 8006d8c: 68fb         	ldr	r3, [r7, #0xc]
 8006d8e: 4618         	mov	r0, r3
 8006d90: f017 f877    	bl	0x801de82 <zbus_chan_msg_size> @ imm = #0x170ee
 8006d94: 4603         	mov	r3, r0
 8006d96: 461c         	mov	r4, r3
 8006d98: f107 0118    	add.w	r1, r7, #0x18
 8006d9c: e9d7 2300    	ldrd	r2, r3, [r7]
 8006da0: 4608         	mov	r0, r1
 8006da2: f022 f888    	bl	0x8028eb6 <sys_timepoint_timeout> @ imm = #0x22110
 8006da6: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8006daa: 4621         	mov	r1, r4
 8006dac: 6cb8         	ldr	r0, [r7, #0x48]
 8006dae: f017 f875    	bl	0x801de9c <_zbus_create_net_buf> @ imm = #0x170ea
 8006db2: 64f8         	str	r0, [r7, #0x4c]
; 	memcpy(net_buf_user_data(buf), &chan, sizeof(struct zbus_channel *));
 8006db4: 6cf8         	ldr	r0, [r7, #0x4c]
 8006db6: f017 f82a    	bl	0x801de0e <net_buf_user_data> @ imm = #0x17054
 8006dba: 4602         	mov	r2, r0
 8006dbc: 68fb         	ldr	r3, [r7, #0xc]
 8006dbe: 6013         	str	r3, [r2]
; 	net_buf_add_mem(buf, zbus_chan_msg(chan), zbus_chan_msg_size(chan));
 8006dc0: 68fb         	ldr	r3, [r7, #0xc]
 8006dc2: 4618         	mov	r0, r3
 8006dc4: f017 f851    	bl	0x801de6a <zbus_chan_msg> @ imm = #0x170a2
 8006dc8: 4604         	mov	r4, r0
 8006dca: 68fb         	ldr	r3, [r7, #0xc]
 8006dcc: 4618         	mov	r0, r3
 8006dce: f017 f858    	bl	0x801de82 <zbus_chan_msg_size> @ imm = #0x170b0
 8006dd2: 4603         	mov	r3, r0
 8006dd4: 461a         	mov	r2, r3
 8006dd6: 4621         	mov	r1, r4
 8006dd8: 6cf8         	ldr	r0, [r7, #0x4c]
 8006dda: f017 f824    	bl	0x801de26 <net_buf_add_mem> @ imm = #0x17048
; 	LOG_DBG("Notifing %s's observers. Starting VDED:", _ZBUS_CHAN_NAME(chan));
 8006dde: 2303         	movs	r3, #0x3
 8006de0: 2b03         	cmp	r3, #0x3
 8006de2: d91c         	bls	0x8006e1e <_zbus_vded_exec+0xae> @ imm = #0x38
 8006de4: 2301         	movs	r3, #0x1
 8006de6: f887 3047    	strb.w	r3, [r7, #0x47]
 8006dea: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8006dee: f083 0301    	eor	r3, r3, #0x1
 8006df2: b2db         	uxtb	r3, r3
 8006df4: 2b00         	cmp	r3, #0x0
 8006df6: d112         	bne	0x8006e1e <_zbus_vded_exec+0xae> @ imm = #0x24
 8006df8: 4b84         	ldr	r3, [pc, #0x210]        @ 0x800700c <_zbus_vded_exec+0x29c>
 8006dfa: 6819         	ldr	r1, [r3]
 8006dfc: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8007010 <_zbus_vded_exec+0x2a0>
 8006dfe: 9304         	str	r3, [sp, #0x10]
 8006e00: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8007014 <_zbus_vded_exec+0x2a4>
 8006e02: 9303         	str	r3, [sp, #0xc]
 8006e04: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8007018 <_zbus_vded_exec+0x2a8>
 8006e06: 9302         	str	r3, [sp, #0x8]
 8006e08: 2308         	movs	r3, #0x8
 8006e0a: 9301         	str	r3, [sp, #0x4]
 8006e0c: 2300         	movs	r3, #0x0
 8006e0e: 9300         	str	r3, [sp]
 8006e10: 2300         	movs	r3, #0x0
 8006e12: 2204         	movs	r2, #0x4
 8006e14: 2000         	movs	r0, #0x0
 8006e16: f016 ffdc    	bl	0x801ddd2 <z_log_msg_runtime_create> @ imm = #0x16fb8
 8006e1a: 2300         	movs	r3, #0x0
 8006e1c: 643b         	str	r3, [r7, #0x40]
; 	int __maybe_unused index = 0;
 8006e1e: 2300         	movs	r3, #0x0
 8006e20: 667b         	str	r3, [r7, #0x64]
; 	for (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx;
 8006e22: 68fb         	ldr	r3, [r7, #0xc]
 8006e24: 691b         	ldr	r3, [r3, #0x10]
 8006e26: 881b         	ldrh	r3, [r3]
 8006e28: f8a7 3062    	strh.w	r3, [r7, #0x62]
 8006e2c: 68fb         	ldr	r3, [r7, #0xc]
 8006e2e: 691b         	ldr	r3, [r3, #0x10]
 8006e30: 885b         	ldrh	r3, [r3, #0x2]
 8006e32: 87fb         	strh	r3, [r7, #0x3e]
 8006e34: e07c         	b	0x8006f30 <_zbus_vded_exec+0x1c0> @ imm = #0xf8
; 		STRUCT_SECTION_GET(zbus_channel_observation, i, &observation);
 8006e36: f9b7 3062    	ldrsh.w	r3, [r7, #0x62]
 8006e3a: 00db         	lsls	r3, r3, #0x3
 8006e3c: 4a77         	ldr	r2, [pc, #0x1dc]        @ 0x800701c <_zbus_vded_exec+0x2ac>
 8006e3e: 4413         	add	r3, r2
 8006e40: 617b         	str	r3, [r7, #0x14]
; 		STRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);
 8006e42: f9b7 3062    	ldrsh.w	r3, [r7, #0x62]
 8006e46: 4a76         	ldr	r2, [pc, #0x1d8]        @ 0x8007020 <_zbus_vded_exec+0x2b0>
 8006e48: 4413         	add	r3, r2
 8006e4a: 613b         	str	r3, [r7, #0x10]
; 		const struct zbus_observer *obs = observation->obs;
 8006e4c: 697b         	ldr	r3, [r7, #0x14]
 8006e4e: 685b         	ldr	r3, [r3, #0x4]
 8006e50: 637b         	str	r3, [r7, #0x34]
; 		if (!obs->data->enabled || observation_mask->enabled) {
 8006e52: 6b7b         	ldr	r3, [r7, #0x34]
 8006e54: 685b         	ldr	r3, [r3, #0x4]
 8006e56: 781b         	ldrb	r3, [r3]
 8006e58: f083 0301    	eor	r3, r3, #0x1
 8006e5c: b2db         	uxtb	r3, r3
 8006e5e: 2b00         	cmp	r3, #0x0
 8006e60: d15f         	bne	0x8006f22 <_zbus_vded_exec+0x1b2> @ imm = #0xbe
 8006e62: 693b         	ldr	r3, [r7, #0x10]
 8006e64: 781b         	ldrb	r3, [r3]
 8006e66: 2b00         	cmp	r3, #0x0
 8006e68: d15b         	bne	0x8006f22 <_zbus_vded_exec+0x1b2> @ imm = #0xb6
; 		err = _zbus_notify_observer(chan, obs, end_time, buf);
 8006e6a: 68f8         	ldr	r0, [r7, #0xc]
 8006e6c: 6cfb         	ldr	r3, [r7, #0x4c]
 8006e6e: 9300         	str	r3, [sp]
 8006e70: e9d7 2300    	ldrd	r2, r3, [r7]
 8006e74: 6b79         	ldr	r1, [r7, #0x34]
 8006e76: f017 f823    	bl	0x801dec0 <_zbus_notify_observer> @ imm = #0x17046
 8006e7a: 6538         	str	r0, [r7, #0x50]
; 		if (err) {
 8006e7c: 6d3b         	ldr	r3, [r7, #0x50]
 8006e7e: 2b00         	cmp	r3, #0x0
 8006e80: d02a         	beq	0x8006ed8 <_zbus_vded_exec+0x168> @ imm = #0x54
; 			last_error = err;
 8006e82: 6d3b         	ldr	r3, [r7, #0x50]
 8006e84: 65fb         	str	r3, [r7, #0x5c]
; 			LOG_ERR("could not deliver notification to observer %s. Error code %d",
 8006e86: 2303         	movs	r3, #0x3
 8006e88: 2b00         	cmp	r3, #0x0
 8006e8a: d01c         	beq	0x8006ec6 <_zbus_vded_exec+0x156> @ imm = #0x38
 8006e8c: 2301         	movs	r3, #0x1
 8006e8e: f887 3033    	strb.w	r3, [r7, #0x33]
 8006e92: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8006e96: f083 0301    	eor	r3, r3, #0x1
 8006e9a: b2db         	uxtb	r3, r3
 8006e9c: 2b00         	cmp	r3, #0x0
 8006e9e: d112         	bne	0x8006ec6 <_zbus_vded_exec+0x156> @ imm = #0x24
 8006ea0: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x800700c <_zbus_vded_exec+0x29c>
 8006ea2: 6819         	ldr	r1, [r3]
 8006ea4: 6d3b         	ldr	r3, [r7, #0x50]
 8006ea6: 9304         	str	r3, [sp, #0x10]
 8006ea8: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8007010 <_zbus_vded_exec+0x2a0>
 8006eaa: 9303         	str	r3, [sp, #0xc]
 8006eac: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8007024 <_zbus_vded_exec+0x2b4>
 8006eae: 9302         	str	r3, [sp, #0x8]
 8006eb0: 2300         	movs	r3, #0x0
 8006eb2: 9301         	str	r3, [sp, #0x4]
 8006eb4: 2300         	movs	r3, #0x0
 8006eb6: 9300         	str	r3, [sp]
 8006eb8: 2300         	movs	r3, #0x0
 8006eba: 2201         	movs	r2, #0x1
 8006ebc: 2000         	movs	r0, #0x0
 8006ebe: f016 ff88    	bl	0x801ddd2 <z_log_msg_runtime_create> @ imm = #0x16f10
 8006ec2: 2300         	movs	r3, #0x0
 8006ec4: 62fb         	str	r3, [r7, #0x2c]
; 			if (err == -ENOMEM) {
 8006ec6: 6d3b         	ldr	r3, [r7, #0x50]
 8006ec8: f113 0f0c    	cmn.w	r3, #0xc
 8006ecc: d104         	bne	0x8006ed8 <_zbus_vded_exec+0x168> @ imm = #0x8
; 					net_buf_unref(buf);
 8006ece: 6cf8         	ldr	r0, [r7, #0x4c]
 8006ed0: f016 fdd1    	bl	0x801da76 <net_buf_unref> @ imm = #0x16ba2
; 				return err;
 8006ed4: 6d3b         	ldr	r3, [r7, #0x50]
 8006ed6: e092         	b	0x8006ffe <_zbus_vded_exec+0x28e> @ imm = #0x124
; 		LOG_DBG(" %d -> %s", index++, _ZBUS_OBS_NAME(obs));
 8006ed8: 2303         	movs	r3, #0x3
 8006eda: 2b03         	cmp	r3, #0x3
 8006edc: d922         	bls	0x8006f24 <_zbus_vded_exec+0x1b4> @ imm = #0x44
 8006ede: 2301         	movs	r3, #0x1
 8006ee0: f887 302b    	strb.w	r3, [r7, #0x2b]
 8006ee4: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8006ee8: f083 0301    	eor	r3, r3, #0x1
 8006eec: b2db         	uxtb	r3, r3
 8006eee: 2b00         	cmp	r3, #0x0
 8006ef0: d118         	bne	0x8006f24 <_zbus_vded_exec+0x1b4> @ imm = #0x30
 8006ef2: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800700c <_zbus_vded_exec+0x29c>
 8006ef4: 6819         	ldr	r1, [r3]
 8006ef6: 6e7b         	ldr	r3, [r7, #0x64]
 8006ef8: 1c5a         	adds	r2, r3, #0x1
 8006efa: 667a         	str	r2, [r7, #0x64]
 8006efc: 4a44         	ldr	r2, [pc, #0x110]        @ 0x8007010 <_zbus_vded_exec+0x2a0>
 8006efe: 9205         	str	r2, [sp, #0x14]
 8006f00: 9304         	str	r3, [sp, #0x10]
 8006f02: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8007014 <_zbus_vded_exec+0x2a4>
 8006f04: 9303         	str	r3, [sp, #0xc]
 8006f06: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8007028 <_zbus_vded_exec+0x2b8>
 8006f08: 9302         	str	r3, [sp, #0x8]
 8006f0a: 2308         	movs	r3, #0x8
 8006f0c: 9301         	str	r3, [sp, #0x4]
 8006f0e: 2300         	movs	r3, #0x0
 8006f10: 9300         	str	r3, [sp]
 8006f12: 2300         	movs	r3, #0x0
 8006f14: 2204         	movs	r2, #0x4
 8006f16: 2000         	movs	r0, #0x0
 8006f18: f016 ff5b    	bl	0x801ddd2 <z_log_msg_runtime_create> @ imm = #0x16eb6
 8006f1c: 2300         	movs	r3, #0x0
 8006f1e: 627b         	str	r3, [r7, #0x24]
 8006f20: e000         	b	0x8006f24 <_zbus_vded_exec+0x1b4> @ imm = #0x0
; 			continue;
 8006f22: bf00         	nop
; 	     i < limit; ++i) {
 8006f24: f8b7 3062    	ldrh.w	r3, [r7, #0x62]
 8006f28: 3301         	adds	r3, #0x1
 8006f2a: b29b         	uxth	r3, r3
 8006f2c: f8a7 3062    	strh.w	r3, [r7, #0x62]
 8006f30: f9b7 2062    	ldrsh.w	r2, [r7, #0x62]
 8006f34: f9b7 303e    	ldrsh.w	r3, [r7, #0x3e]
 8006f38: 429a         	cmp	r2, r3
 8006f3a: f6ff af7c    	blt.w	0x8006e36 <_zbus_vded_exec+0xc6> @ imm = #-0x108
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&chan->data->observers, obs_nd, tmp, node) {
 8006f3e: 68fb         	ldr	r3, [r7, #0xc]
 8006f40: 691b         	ldr	r3, [r3, #0x10]
 8006f42: 3318         	adds	r3, #0x18
 8006f44: 4618         	mov	r0, r3
 8006f46: f016 fec5    	bl	0x801dcd4 <sys_slist_peek_head> @ imm = #0x16d8a
 8006f4a: 4603         	mov	r3, r0
 8006f4c: 2b00         	cmp	r3, #0x0
 8006f4e: d007         	beq	0x8006f60 <_zbus_vded_exec+0x1f0> @ imm = #0xe
 8006f50: 68fb         	ldr	r3, [r7, #0xc]
 8006f52: 691b         	ldr	r3, [r3, #0x10]
 8006f54: 3318         	adds	r3, #0x18
 8006f56: 4618         	mov	r0, r3
 8006f58: f016 febc    	bl	0x801dcd4 <sys_slist_peek_head> @ imm = #0x16d78
 8006f5c: 4603         	mov	r3, r0
 8006f5e: e000         	b	0x8006f62 <_zbus_vded_exec+0x1f2> @ imm = #0x0
 8006f60: 2300         	movs	r3, #0x0
 8006f62: 65bb         	str	r3, [r7, #0x58]
 8006f64: 6dbb         	ldr	r3, [r7, #0x58]
 8006f66: 2b00         	cmp	r3, #0x0
 8006f68: d00e         	beq	0x8006f88 <_zbus_vded_exec+0x218> @ imm = #0x1c
 8006f6a: 6dbb         	ldr	r3, [r7, #0x58]
 8006f6c: 4618         	mov	r0, r3
 8006f6e: f016 fec9    	bl	0x801dd04 <sys_slist_peek_next> @ imm = #0x16d92
 8006f72: 4603         	mov	r3, r0
 8006f74: 2b00         	cmp	r3, #0x0
 8006f76: d005         	beq	0x8006f84 <_zbus_vded_exec+0x214> @ imm = #0xa
 8006f78: 6dbb         	ldr	r3, [r7, #0x58]
 8006f7a: 4618         	mov	r0, r3
 8006f7c: f016 fec2    	bl	0x801dd04 <sys_slist_peek_next> @ imm = #0x16d84
 8006f80: 4603         	mov	r3, r0
 8006f82: e002         	b	0x8006f8a <_zbus_vded_exec+0x21a> @ imm = #0x4
 8006f84: 2300         	movs	r3, #0x0
 8006f86: e000         	b	0x8006f8a <_zbus_vded_exec+0x21a> @ imm = #0x0
 8006f88: 2300         	movs	r3, #0x0
 8006f8a: 657b         	str	r3, [r7, #0x54]
 8006f8c: e030         	b	0x8006ff0 <_zbus_vded_exec+0x280> @ imm = #0x60
; 		const struct zbus_observer *obs = obs_nd->obs;
 8006f8e: 6dbb         	ldr	r3, [r7, #0x58]
 8006f90: 685b         	ldr	r3, [r3, #0x4]
 8006f92: 63bb         	str	r3, [r7, #0x38]
; 		if (!obs->data->enabled) {
 8006f94: 6bbb         	ldr	r3, [r7, #0x38]
 8006f96: 685b         	ldr	r3, [r3, #0x4]
 8006f98: 781b         	ldrb	r3, [r3]
 8006f9a: f083 0301    	eor	r3, r3, #0x1
 8006f9e: b2db         	uxtb	r3, r3
 8006fa0: 2b00         	cmp	r3, #0x0
 8006fa2: d10e         	bne	0x8006fc2 <_zbus_vded_exec+0x252> @ imm = #0x1c
; 		err = _zbus_notify_observer(chan, obs, end_time, buf);
 8006fa4: 68f8         	ldr	r0, [r7, #0xc]
 8006fa6: 6cfb         	ldr	r3, [r7, #0x4c]
 8006fa8: 9300         	str	r3, [sp]
 8006faa: e9d7 2300    	ldrd	r2, r3, [r7]
 8006fae: 6bb9         	ldr	r1, [r7, #0x38]
 8006fb0: f016 ff86    	bl	0x801dec0 <_zbus_notify_observer> @ imm = #0x16f0c
 8006fb4: 6538         	str	r0, [r7, #0x50]
; 		if (err) {
 8006fb6: 6d3b         	ldr	r3, [r7, #0x50]
 8006fb8: 2b00         	cmp	r3, #0x0
 8006fba: d003         	beq	0x8006fc4 <_zbus_vded_exec+0x254> @ imm = #0x6
; 			last_error = err;
 8006fbc: 6d3b         	ldr	r3, [r7, #0x50]
 8006fbe: 65fb         	str	r3, [r7, #0x5c]
 8006fc0: e000         	b	0x8006fc4 <_zbus_vded_exec+0x254> @ imm = #0x0
; 			continue;
 8006fc2: bf00         	nop
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&chan->data->observers, obs_nd, tmp, node) {
 8006fc4: 6d7b         	ldr	r3, [r7, #0x54]
 8006fc6: 65bb         	str	r3, [r7, #0x58]
 8006fc8: 6dbb         	ldr	r3, [r7, #0x58]
 8006fca: 2b00         	cmp	r3, #0x0
 8006fcc: d00e         	beq	0x8006fec <_zbus_vded_exec+0x27c> @ imm = #0x1c
 8006fce: 6dbb         	ldr	r3, [r7, #0x58]
 8006fd0: 4618         	mov	r0, r3
 8006fd2: f016 fe97    	bl	0x801dd04 <sys_slist_peek_next> @ imm = #0x16d2e
 8006fd6: 4603         	mov	r3, r0
 8006fd8: 2b00         	cmp	r3, #0x0
 8006fda: d005         	beq	0x8006fe8 <_zbus_vded_exec+0x278> @ imm = #0xa
 8006fdc: 6dbb         	ldr	r3, [r7, #0x58]
 8006fde: 4618         	mov	r0, r3
 8006fe0: f016 fe90    	bl	0x801dd04 <sys_slist_peek_next> @ imm = #0x16d20
 8006fe4: 4603         	mov	r3, r0
 8006fe6: e002         	b	0x8006fee <_zbus_vded_exec+0x27e> @ imm = #0x4
 8006fe8: 2300         	movs	r3, #0x0
 8006fea: e000         	b	0x8006fee <_zbus_vded_exec+0x27e> @ imm = #0x0
 8006fec: 2300         	movs	r3, #0x0
 8006fee: 657b         	str	r3, [r7, #0x54]
 8006ff0: 6dbb         	ldr	r3, [r7, #0x58]
 8006ff2: 2b00         	cmp	r3, #0x0
 8006ff4: d1cb         	bne	0x8006f8e <_zbus_vded_exec+0x21e> @ imm = #-0x6a
; 	IF_ENABLED(CONFIG_ZBUS_MSG_SUBSCRIBER, (net_buf_unref(buf);))
 8006ff6: 6cf8         	ldr	r0, [r7, #0x4c]
 8006ff8: f016 fd3d    	bl	0x801da76 <net_buf_unref> @ imm = #0x16a7a
; 	return last_error;
 8006ffc: 6dfb         	ldr	r3, [r7, #0x5c]
; }
 8006ffe: 4618         	mov	r0, r3
 8007000: 376c         	adds	r7, #0x6c
 8007002: 46bd         	mov	sp, r7
 8007004: bd90         	pop	{r4, r7, pc}
 8007006: bf00         	nop

08007008 <$d>:
 8007008: 60 0c 00 24  	.word	0x24000c60
 800700c: 98 06 00 24  	.word	0x24000698
 8007010: c4 aa 02 08  	.word	0x0802aac4
 8007014: 30 ce 02 08  	.word	0x0802ce30
 8007018: c8 aa 02 08  	.word	0x0802aac8
 800701c: 80 a2 02 08  	.word	0x0802a280
 8007020: 84 0c 00 24  	.word	0x24000c84
 8007024: f4 aa 02 08  	.word	0x0802aaf4
 8007028: 34 ab 02 08  	.word	0x0802ab34

0800702c <chan_lock>:
; {
 800702c: b580         	push	{r7, lr}
 800702e: b094         	sub	sp, #0x50
 8007030: af00         	add	r7, sp, #0x0
 8007032: 60f8         	str	r0, [r7, #0xc]
 8007034: e9c7 2300    	strd	r2, r3, [r7]
; 	bool boosting = false;
 8007038: 2300         	movs	r3, #0x0
 800703a: f887 304f    	strb.w	r3, [r7, #0x4f]
; 	if (!k_is_in_isr()) {
 800703e: f020 ffc5    	bl	0x8027fcc <k_is_in_isr> @ imm = #0x20f8a
 8007042: 4603         	mov	r3, r0
 8007044: f083 0301    	eor	r3, r3, #0x1
 8007048: b2db         	uxtb	r3, r3
 800704a: 2b00         	cmp	r3, #0x0
 800704c: d055         	beq	0x80070fa <chan_lock+0xce> @ imm = #0xaa
; 		*prio = k_thread_priority_get(k_current_get());
 800704e: f7ff fe35    	bl	0x8006cbc <k_current_get> @ imm = #-0x396
 8007052: 4603         	mov	r3, r0
 8007054: 4618         	mov	r0, r3
 8007056: f016 fe66    	bl	0x801dd26 <k_thread_priority_get> @ imm = #0x16ccc
 800705a: 4602         	mov	r2, r0
 800705c: 6dbb         	ldr	r3, [r7, #0x58]
 800705e: 601a         	str	r2, [r3]
; 		K_SPINLOCK(&_zbus_chan_slock) {
 8007060: 2300         	movs	r3, #0x0
 8007062: 61fb         	str	r3, [r7, #0x1c]
 8007064: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800713c <chan_lock+0x110>
 8007066: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8007068: f3ef 8311    	mrs	r3, basepri
 800706c: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800706e: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 8007070: 63bb         	str	r3, [r7, #0x38]
 8007072: 2310         	movs	r3, #0x10
 8007074: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8007076: 6b7b         	ldr	r3, [r7, #0x34]
 8007078: f383 8812    	msr	basepri_max, r3
; }
 800707c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800707e: f3bf 8f6f    	isb	sy
; }
 8007082: bf00         	nop
; 	return key;
 8007084: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 8007086: 613b         	str	r3, [r7, #0x10]
 8007088: 6c3b         	ldr	r3, [r7, #0x40]
 800708a: 633b         	str	r3, [r7, #0x30]
; }
 800708c: bf00         	nop
 800708e: 6c3b         	ldr	r3, [r7, #0x40]
 8007090: 62fb         	str	r3, [r7, #0x2c]
; }
 8007092: bf00         	nop
; 	return k;
 8007094: 693b         	ldr	r3, [r7, #0x10]
 8007096: 61bb         	str	r3, [r7, #0x18]
; 		K_SPINLOCK(&_zbus_chan_slock) {
 8007098: e02c         	b	0x80070f4 <chan_lock+0xc8> @ imm = #0x58
; 			if (*prio > chan->data->highest_observer_priority) {
 800709a: 6dbb         	ldr	r3, [r7, #0x58]
 800709c: 681a         	ldr	r2, [r3]
 800709e: 68fb         	ldr	r3, [r7, #0xc]
 80070a0: 691b         	ldr	r3, [r3, #0x10]
 80070a2: 695b         	ldr	r3, [r3, #0x14]
 80070a4: 429a         	cmp	r2, r3
 80070a6: dd12         	ble	0x80070ce <chan_lock+0xa2> @ imm = #0x24
; 				int new_prio = chan->data->highest_observer_priority - 1;
 80070a8: 68fb         	ldr	r3, [r7, #0xc]
 80070aa: 691b         	ldr	r3, [r3, #0x10]
 80070ac: 695b         	ldr	r3, [r3, #0x14]
 80070ae: 3b01         	subs	r3, #0x1
 80070b0: 64bb         	str	r3, [r7, #0x48]
; 				new_prio = MAX(new_prio, 0);
 80070b2: 6cbb         	ldr	r3, [r7, #0x48]
 80070b4: ea23 73e3    	bic.w	r3, r3, r3, asr #31
 80070b8: 64bb         	str	r3, [r7, #0x48]
; 				k_thread_priority_set(k_current_get(), new_prio);
 80070ba: f7ff fdff    	bl	0x8006cbc <k_current_get> @ imm = #-0x402
 80070be: 4603         	mov	r3, r0
 80070c0: 6cb9         	ldr	r1, [r7, #0x48]
 80070c2: 4618         	mov	r0, r3
 80070c4: f016 fe3b    	bl	0x801dd3e <k_thread_priority_set> @ imm = #0x16c76
; 				boosting = true;
 80070c8: 2301         	movs	r3, #0x1
 80070ca: f887 304f    	strb.w	r3, [r7, #0x4f]
 80070ce: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800713c <chan_lock+0x110>
 80070d0: 62bb         	str	r3, [r7, #0x28]
 80070d2: 69bb         	ldr	r3, [r7, #0x18]
 80070d4: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 80070d6: 697b         	ldr	r3, [r7, #0x14]
 80070d8: 627b         	str	r3, [r7, #0x24]
 80070da: 6a7b         	ldr	r3, [r7, #0x24]
 80070dc: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80070de: 6a3b         	ldr	r3, [r7, #0x20]
 80070e0: f383 8811    	msr	basepri, r3
; }
 80070e4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80070e6: f3bf 8f6f    	isb	sy
; }
 80070ea: bf00         	nop
; }
 80070ec: bf00         	nop
; }
 80070ee: bf00         	nop
; 		K_SPINLOCK(&_zbus_chan_slock) {
 80070f0: 2301         	movs	r3, #0x1
 80070f2: 61fb         	str	r3, [r7, #0x1c]
 80070f4: 69fb         	ldr	r3, [r7, #0x1c]
 80070f6: 2b00         	cmp	r3, #0x0
 80070f8: d0cf         	beq	0x800709a <chan_lock+0x6e> @ imm = #-0x62
; 	int err = k_sem_take(&chan->data->sem, timeout);
 80070fa: 68fb         	ldr	r3, [r7, #0xc]
 80070fc: 691b         	ldr	r3, [r3, #0x10]
 80070fe: 1d19         	adds	r1, r3, #0x4
 8007100: e9d7 2300    	ldrd	r2, r3, [r7]
 8007104: 4608         	mov	r0, r1
 8007106: f016 fe37    	bl	0x801dd78 <k_sem_take>  @ imm = #0x16c6e
 800710a: 6478         	str	r0, [r7, #0x44]
; 	if (err) {
 800710c: 6c7b         	ldr	r3, [r7, #0x44]
 800710e: 2b00         	cmp	r3, #0x0
 8007110: d00e         	beq	0x8007130 <chan_lock+0x104> @ imm = #0x1c
; 		if (boosting) {
 8007112: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 8007116: 2b00         	cmp	r3, #0x0
 8007118: d008         	beq	0x800712c <chan_lock+0x100> @ imm = #0x10
; 			k_thread_priority_set(k_current_get(), *prio);
 800711a: f7ff fdcf    	bl	0x8006cbc <k_current_get> @ imm = #-0x462
 800711e: 4602         	mov	r2, r0
 8007120: 6dbb         	ldr	r3, [r7, #0x58]
 8007122: 681b         	ldr	r3, [r3]
 8007124: 4619         	mov	r1, r3
 8007126: 4610         	mov	r0, r2
 8007128: f016 fe09    	bl	0x801dd3e <k_thread_priority_set> @ imm = #0x16c12
; 		return err;
 800712c: 6c7b         	ldr	r3, [r7, #0x44]
 800712e: e000         	b	0x8007132 <chan_lock+0x106> @ imm = #0x0
; 	return 0;
 8007130: 2300         	movs	r3, #0x0
; }
 8007132: 4618         	mov	r0, r3
 8007134: 3750         	adds	r7, #0x50
 8007136: 46bd         	mov	sp, r7
 8007138: bd80         	pop	{r7, pc}
 800713a: bf00         	nop

0800713c <$d>:
 800713c: 6c 28 00 24  	.word	0x2400286c

08007140 <LL_SYSCFG_SetEXTISource>:
; {
 8007140: b480         	push	{r7}
 8007142: b087         	sub	sp, #0x1c
 8007144: af00         	add	r7, sp, #0x0
 8007146: 6078         	str	r0, [r7, #0x4]
 8007148: 6039         	str	r1, [r7]
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0x3U], (Line >> 16U), Port << ((POSITION_VAL(Line >> 16U)) & 31U));
 800714a: 4a18         	ldr	r2, [pc, #0x60]         @ 0x80071ac <LL_SYSCFG_SetEXTISource+0x6c>
 800714c: 683b         	ldr	r3, [r7]
 800714e: f003 0303    	and	r3, r3, #0x3
 8007152: 3302         	adds	r3, #0x2
 8007154: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 8007158: 683b         	ldr	r3, [r7]
 800715a: 0c1b         	lsrs	r3, r3, #0x10
 800715c: 43db         	mvns	r3, r3
 800715e: ea02 0103    	and.w	r1, r2, r3
 8007162: 683b         	ldr	r3, [r7]
 8007164: 0c1b         	lsrs	r3, r3, #0x10
 8007166: 613b         	str	r3, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007168: 693b         	ldr	r3, [r7, #0x10]
 800716a: fa93 f3a3    	rbit	r3, r3
 800716e: 60fb         	str	r3, [r7, #0xc]
;   return result;
 8007170: 68fb         	ldr	r3, [r7, #0xc]
 8007172: 617b         	str	r3, [r7, #0x14]
;   if (value == 0U)
 8007174: 697b         	ldr	r3, [r7, #0x14]
 8007176: 2b00         	cmp	r3, #0x0
 8007178: d101         	bne	0x800717e <LL_SYSCFG_SetEXTISource+0x3e> @ imm = #0x2
;     return 32U;
 800717a: 2320         	movs	r3, #0x20
 800717c: e003         	b	0x8007186 <LL_SYSCFG_SetEXTISource+0x46> @ imm = #0x6
;   return __builtin_clz(value);
 800717e: 697b         	ldr	r3, [r7, #0x14]
 8007180: fab3 f383    	clz	r3, r3
 8007184: b2db         	uxtb	r3, r3
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0x3U], (Line >> 16U), Port << ((POSITION_VAL(Line >> 16U)) & 31U));
 8007186: f003 031f    	and	r3, r3, #0x1f
 800718a: 687a         	ldr	r2, [r7, #0x4]
 800718c: 409a         	lsls	r2, r3
 800718e: 4807         	ldr	r0, [pc, #0x1c]         @ 0x80071ac <LL_SYSCFG_SetEXTISource+0x6c>
 8007190: 683b         	ldr	r3, [r7]
 8007192: f003 0303    	and	r3, r3, #0x3
 8007196: 430a         	orrs	r2, r1
 8007198: 3302         	adds	r3, #0x2
 800719a: f840 2023    	str.w	r2, [r0, r3, lsl #2]
; }
 800719e: bf00         	nop
 80071a0: 371c         	adds	r7, #0x1c
 80071a2: 46bd         	mov	sp, r7
 80071a4: f85d 7b04    	ldr	r7, [sp], #4
 80071a8: 4770         	bx	lr
 80071aa: bf00         	nop

080071ac <$d>:
 80071ac: 00 04 00 58  	.word	0x58000400

080071b0 <LL_SYSCFG_GetEXTISource>:
; {
 80071b0: b480         	push	{r7}
 80071b2: b087         	sub	sp, #0x1c
 80071b4: af00         	add	r7, sp, #0x0
 80071b6: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0x3U], (Line >> 16U)) >> (POSITION_VAL(Line >> 16U) & 31U));
 80071b8: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8007204 <LL_SYSCFG_GetEXTISource+0x54>
 80071ba: 687b         	ldr	r3, [r7, #0x4]
 80071bc: f003 0303    	and	r3, r3, #0x3
 80071c0: 3302         	adds	r3, #0x2
 80071c2: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 80071c6: 687b         	ldr	r3, [r7, #0x4]
 80071c8: 0c1b         	lsrs	r3, r3, #0x10
 80071ca: 401a         	ands	r2, r3
 80071cc: 687b         	ldr	r3, [r7, #0x4]
 80071ce: 0c1b         	lsrs	r3, r3, #0x10
 80071d0: 613b         	str	r3, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80071d2: 693b         	ldr	r3, [r7, #0x10]
 80071d4: fa93 f3a3    	rbit	r3, r3
 80071d8: 60fb         	str	r3, [r7, #0xc]
;   return result;
 80071da: 68fb         	ldr	r3, [r7, #0xc]
 80071dc: 617b         	str	r3, [r7, #0x14]
;   if (value == 0U)
 80071de: 697b         	ldr	r3, [r7, #0x14]
 80071e0: 2b00         	cmp	r3, #0x0
 80071e2: d101         	bne	0x80071e8 <LL_SYSCFG_GetEXTISource+0x38> @ imm = #0x2
;     return 32U;
 80071e4: 2320         	movs	r3, #0x20
 80071e6: e003         	b	0x80071f0 <LL_SYSCFG_GetEXTISource+0x40> @ imm = #0x6
;   return __builtin_clz(value);
 80071e8: 697b         	ldr	r3, [r7, #0x14]
 80071ea: fab3 f383    	clz	r3, r3
 80071ee: b2db         	uxtb	r3, r3
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0x3U], (Line >> 16U)) >> (POSITION_VAL(Line >> 16U) & 31U));
 80071f0: f003 031f    	and	r3, r3, #0x1f
 80071f4: fa22 f303    	lsr.w	r3, r2, r3
; }
 80071f8: 4618         	mov	r0, r3
 80071fa: 371c         	adds	r7, #0x1c
 80071fc: 46bd         	mov	sp, r7
 80071fe: f85d 7b04    	ldr	r7, [sp], #4
 8007202: 4770         	bx	lr

08007204 <$d>:
 8007204: 00 04 00 58  	.word	0x58000400

08007208 <stm32_exti_isr>:
; {
 8007208: b580         	push	{r7, lr}
 800720a: b088         	sub	sp, #0x20
 800720c: af00         	add	r7, sp, #0x0
 800720e: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = DEVICE_DT_GET(EXTI_NODE);
 8007210: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8007290 <stm32_exti_isr+0x88>
 8007212: 61bb         	str	r3, [r7, #0x18]
; 	struct stm32_exti_data *data = dev->data;
 8007214: 69bb         	ldr	r3, [r7, #0x18]
 8007216: 691b         	ldr	r3, [r3, #0x10]
 8007218: 617b         	str	r3, [r7, #0x14]
; 	const struct stm32_exti_range *range = exti_range;
 800721a: 687b         	ldr	r3, [r7, #0x4]
 800721c: 613b         	str	r3, [r7, #0x10]
; 	for (uint8_t i = 0; i <= range->len; i++) {
 800721e: 2300         	movs	r3, #0x0
 8007220: 77fb         	strb	r3, [r7, #0x1f]
 8007222: e02b         	b	0x800727c <stm32_exti_isr+0x74> @ imm = #0x56
; 		line_num = range->start + i;
 8007224: 693b         	ldr	r3, [r7, #0x10]
 8007226: 781b         	ldrb	r3, [r3]
 8007228: 461a         	mov	r2, r3
 800722a: 7ffb         	ldrb	r3, [r7, #0x1f]
 800722c: 4413         	add	r3, r2
 800722e: 60fb         	str	r3, [r7, #0xc]
; 		line = linenum_to_ll_exti_line(line_num);
 8007230: 68fb         	ldr	r3, [r7, #0xc]
 8007232: b2db         	uxtb	r3, r3
 8007234: 4618         	mov	r0, r3
 8007236: f017 f823    	bl	0x801e280 <linenum_to_ll_exti_line> @ imm = #0x17046
 800723a: 60b8         	str	r0, [r7, #0x8]
; 		if (stm32_exti_is_pending(line) != 0) {
 800723c: 68b8         	ldr	r0, [r7, #0x8]
 800723e: f017 f808    	bl	0x801e252 <stm32_exti_is_pending> @ imm = #0x17010
 8007242: 4603         	mov	r3, r0
 8007244: 2b00         	cmp	r3, #0x0
 8007246: d016         	beq	0x8007276 <stm32_exti_isr+0x6e> @ imm = #0x2c
; 			stm32_exti_clear_pending(line);
 8007248: 68b8         	ldr	r0, [r7, #0x8]
 800724a: f017 f80e    	bl	0x801e26a <stm32_exti_clear_pending> @ imm = #0x1701c
; 			if (!data->cb[line_num].cb) {
 800724e: 697b         	ldr	r3, [r7, #0x14]
 8007250: 68fa         	ldr	r2, [r7, #0xc]
 8007252: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 8007256: 2b00         	cmp	r3, #0x0
 8007258: d00c         	beq	0x8007274 <stm32_exti_isr+0x6c> @ imm = #0x18
; 			data->cb[line_num].cb(line, data->cb[line_num].data);
 800725a: 697b         	ldr	r3, [r7, #0x14]
 800725c: 68fa         	ldr	r2, [r7, #0xc]
 800725e: f853 2032    	ldr.w	r2, [r3, r2, lsl #3]
 8007262: 6979         	ldr	r1, [r7, #0x14]
 8007264: 68fb         	ldr	r3, [r7, #0xc]
 8007266: 00db         	lsls	r3, r3, #0x3
 8007268: 440b         	add	r3, r1
 800726a: 685b         	ldr	r3, [r3, #0x4]
 800726c: 4619         	mov	r1, r3
 800726e: 68b8         	ldr	r0, [r7, #0x8]
 8007270: 4790         	blx	r2
 8007272: e000         	b	0x8007276 <stm32_exti_isr+0x6e> @ imm = #0x0
; 				continue;
 8007274: bf00         	nop
; 	for (uint8_t i = 0; i <= range->len; i++) {
 8007276: 7ffb         	ldrb	r3, [r7, #0x1f]
 8007278: 3301         	adds	r3, #0x1
 800727a: 77fb         	strb	r3, [r7, #0x1f]
 800727c: 693b         	ldr	r3, [r7, #0x10]
 800727e: 785b         	ldrb	r3, [r3, #0x1]
 8007280: 7ffa         	ldrb	r2, [r7, #0x1f]
 8007282: 429a         	cmp	r2, r3
 8007284: d9ce         	bls	0x8007224 <stm32_exti_isr+0x1c> @ imm = #-0x64
; }
 8007286: bf00         	nop
 8007288: bf00         	nop
 800728a: 3720         	adds	r7, #0x20
 800728c: 46bd         	mov	sp, r7
 800728e: bd80         	pop	{r7, pc}

08007290 <$d>:
 8007290: e8 96 02 08  	.word	0x080296e8

08007294 <stm32_exti_enable_registers>:
; {
 8007294: b580         	push	{r7, lr}
 8007296: b084         	sub	sp, #0x10
 8007298: af00         	add	r7, sp, #0x0
; 	int ret = 0;
 800729a: 2300         	movs	r3, #0x0
 800729c: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800729e: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80072c4 <stm32_exti_enable_registers+0x30>
 80072a0: 60bb         	str	r3, [r7, #0x8]
; 	struct stm32_pclken pclken = {
 80072a2: 4a09         	ldr	r2, [pc, #0x24]         @ 0x80072c8 <stm32_exti_enable_registers+0x34>
 80072a4: 463b         	mov	r3, r7
 80072a6: e892 0003    	ldm.w	r2, {r0, r1}
 80072aa: e883 0003    	stm.w	r3, {r0, r1}
; 	ret = clock_control_on(clk, (clock_control_subsys_t) &pclken);
 80072ae: 463b         	mov	r3, r7
 80072b0: 4619         	mov	r1, r3
 80072b2: 68b8         	ldr	r0, [r7, #0x8]
 80072b4: f016 ff8f    	bl	0x801e1d6 <clock_control_on> @ imm = #0x16f1e
 80072b8: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 80072ba: 68fb         	ldr	r3, [r7, #0xc]
; }
 80072bc: 4618         	mov	r0, r3
 80072be: 3710         	adds	r7, #0x10
 80072c0: 46bd         	mov	sp, r7
 80072c2: bd80         	pop	{r7, pc}

080072c4 <$d>:
 80072c4: c0 96 02 08  	.word	0x080296c0
 80072c8: 44 ab 02 08  	.word	0x0802ab44

080072cc <stm32_fill_irq_table>:
; {
 80072cc: b480         	push	{r7}
 80072ce: b085         	sub	sp, #0x14
 80072d0: af00         	add	r7, sp, #0x0
 80072d2: 4603         	mov	r3, r0
 80072d4: 603a         	str	r2, [r7]
 80072d6: 71fb         	strb	r3, [r7, #0x7]
 80072d8: 460b         	mov	r3, r1
 80072da: 71bb         	strb	r3, [r7, #0x6]
; 	for (int i = 0; i < len; i++) {
 80072dc: 2300         	movs	r3, #0x0
 80072de: 60fb         	str	r3, [r7, #0xc]
 80072e0: e00b         	b	0x80072fa <stm32_fill_irq_table+0x2e> @ imm = #0x16
; 		exti_irq_table[start + i] = irqn;
 80072e2: f997 2007    	ldrsb.w	r2, [r7, #0x7]
 80072e6: 68fb         	ldr	r3, [r7, #0xc]
 80072e8: 4413         	add	r3, r2
 80072ea: 683a         	ldr	r2, [r7]
 80072ec: b211         	sxth	r1, r2
 80072ee: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8007314 <stm32_fill_irq_table+0x48>
 80072f0: f822 1013    	strh.w	r1, [r2, r3, lsl #1]
; 	for (int i = 0; i < len; i++) {
 80072f4: 68fb         	ldr	r3, [r7, #0xc]
 80072f6: 3301         	adds	r3, #0x1
 80072f8: 60fb         	str	r3, [r7, #0xc]
 80072fa: f997 3006    	ldrsb.w	r3, [r7, #0x6]
 80072fe: 68fa         	ldr	r2, [r7, #0xc]
 8007300: 429a         	cmp	r2, r3
 8007302: dbee         	blt	0x80072e2 <stm32_fill_irq_table+0x16> @ imm = #-0x24
; }
 8007304: bf00         	nop
 8007306: bf00         	nop
 8007308: 3714         	adds	r7, #0x14
 800730a: 46bd         	mov	sp, r7
 800730c: f85d 7b04    	ldr	r7, [sp], #4
 8007310: 4770         	bx	lr
 8007312: bf00         	nop

08007314 <$d>:
 8007314: 9c 06 00 24  	.word	0x2400069c

08007318 <stm32_exti_init>:
; {
 8007318: b580         	push	{r7, lr}
 800731a: b082         	sub	sp, #0x8
 800731c: af00         	add	r7, sp, #0x0
 800731e: 6078         	str	r0, [r7, #0x4]
; 	DT_FOREACH_PROP_ELEM(DT_NODELABEL(exti),
 8007320: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8007400 <stm32_exti_init+0xe8>
 8007322: 781b         	ldrb	r3, [r3]
 8007324: b25b         	sxtb	r3, r3
 8007326: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x8007400 <stm32_exti_init+0xe8>
 8007328: 7852         	ldrb	r2, [r2, #0x1]
 800732a: b251         	sxtb	r1, r2
 800732c: 2206         	movs	r2, #0x6
 800732e: 4618         	mov	r0, r3
 8007330: f7ff ffcc    	bl	0x80072cc <stm32_fill_irq_table> @ imm = #-0x68
 8007334: 2200         	movs	r2, #0x0
 8007336: 2100         	movs	r1, #0x0
 8007338: 2006         	movs	r0, #0x6
 800733a: f016 f94b    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x16296
 800733e: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8007404 <stm32_exti_init+0xec>
 8007340: 781b         	ldrb	r3, [r3]
 8007342: b25b         	sxtb	r3, r3
 8007344: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x8007404 <stm32_exti_init+0xec>
 8007346: 7852         	ldrb	r2, [r2, #0x1]
 8007348: b251         	sxtb	r1, r2
 800734a: 2207         	movs	r2, #0x7
 800734c: 4618         	mov	r0, r3
 800734e: f7ff ffbd    	bl	0x80072cc <stm32_fill_irq_table> @ imm = #-0x86
 8007352: 2200         	movs	r2, #0x0
 8007354: 2100         	movs	r1, #0x0
 8007356: 2007         	movs	r0, #0x7
 8007358: f016 f93c    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x16278
 800735c: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8007408 <stm32_exti_init+0xf0>
 800735e: 781b         	ldrb	r3, [r3]
 8007360: b25b         	sxtb	r3, r3
 8007362: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x8007408 <stm32_exti_init+0xf0>
 8007364: 7852         	ldrb	r2, [r2, #0x1]
 8007366: b251         	sxtb	r1, r2
 8007368: 2208         	movs	r2, #0x8
 800736a: 4618         	mov	r0, r3
 800736c: f7ff ffae    	bl	0x80072cc <stm32_fill_irq_table> @ imm = #-0xa4
 8007370: 2200         	movs	r2, #0x0
 8007372: 2100         	movs	r1, #0x0
 8007374: 2008         	movs	r0, #0x8
 8007376: f016 f92d    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x1625a
 800737a: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800740c <stm32_exti_init+0xf4>
 800737c: 781b         	ldrb	r3, [r3]
 800737e: b25b         	sxtb	r3, r3
 8007380: 4a22         	ldr	r2, [pc, #0x88]         @ 0x800740c <stm32_exti_init+0xf4>
 8007382: 7852         	ldrb	r2, [r2, #0x1]
 8007384: b251         	sxtb	r1, r2
 8007386: 2209         	movs	r2, #0x9
 8007388: 4618         	mov	r0, r3
 800738a: f7ff ff9f    	bl	0x80072cc <stm32_fill_irq_table> @ imm = #-0xc2
 800738e: 2200         	movs	r2, #0x0
 8007390: 2100         	movs	r1, #0x0
 8007392: 2009         	movs	r0, #0x9
 8007394: f016 f91e    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x1623c
 8007398: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8007410 <stm32_exti_init+0xf8>
 800739a: 781b         	ldrb	r3, [r3]
 800739c: b25b         	sxtb	r3, r3
 800739e: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x8007410 <stm32_exti_init+0xf8>
 80073a0: 7852         	ldrb	r2, [r2, #0x1]
 80073a2: b251         	sxtb	r1, r2
 80073a4: 220a         	movs	r2, #0xa
 80073a6: 4618         	mov	r0, r3
 80073a8: f7ff ff90    	bl	0x80072cc <stm32_fill_irq_table> @ imm = #-0xe0
 80073ac: 2200         	movs	r2, #0x0
 80073ae: 2100         	movs	r1, #0x0
 80073b0: 200a         	movs	r0, #0xa
 80073b2: f016 f90f    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x1621e
 80073b6: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8007414 <stm32_exti_init+0xfc>
 80073b8: 781b         	ldrb	r3, [r3]
 80073ba: b25b         	sxtb	r3, r3
 80073bc: 4a15         	ldr	r2, [pc, #0x54]         @ 0x8007414 <stm32_exti_init+0xfc>
 80073be: 7852         	ldrb	r2, [r2, #0x1]
 80073c0: b251         	sxtb	r1, r2
 80073c2: 2217         	movs	r2, #0x17
 80073c4: 4618         	mov	r0, r3
 80073c6: f7ff ff81    	bl	0x80072cc <stm32_fill_irq_table> @ imm = #-0xfe
 80073ca: 2200         	movs	r2, #0x0
 80073cc: 2100         	movs	r1, #0x0
 80073ce: 2017         	movs	r0, #0x17
 80073d0: f016 f900    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x16200
 80073d4: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8007418 <stm32_exti_init+0x100>
 80073d6: 781b         	ldrb	r3, [r3]
 80073d8: b25b         	sxtb	r3, r3
 80073da: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8007418 <stm32_exti_init+0x100>
 80073dc: 7852         	ldrb	r2, [r2, #0x1]
 80073de: b251         	sxtb	r1, r2
 80073e0: 2228         	movs	r2, #0x28
 80073e2: 4618         	mov	r0, r3
 80073e4: f7ff ff72    	bl	0x80072cc <stm32_fill_irq_table> @ imm = #-0x11c
 80073e8: 2200         	movs	r2, #0x0
 80073ea: 2100         	movs	r1, #0x0
 80073ec: 2028         	movs	r0, #0x28
 80073ee: f016 f8f1    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x161e2
; 	return stm32_exti_enable_registers();
 80073f2: f7ff ff4f    	bl	0x8007294 <stm32_exti_enable_registers> @ imm = #-0x162
 80073f6: 4603         	mov	r3, r0
; }
 80073f8: 4618         	mov	r0, r3
 80073fa: 3708         	adds	r7, #0x8
 80073fc: 46bd         	mov	sp, r7
 80073fe: bd80         	pop	{r7, pc}

08007400 <$d>:
 8007400: 40 ce 02 08  	.word	0x0802ce40
 8007404: 44 ce 02 08  	.word	0x0802ce44
 8007408: 48 ce 02 08  	.word	0x0802ce48
 800740c: 4c ce 02 08  	.word	0x0802ce4c
 8007410: 50 ce 02 08  	.word	0x0802ce50
 8007414: 54 ce 02 08  	.word	0x0802ce54
 8007418: 58 ce 02 08  	.word	0x0802ce58

0800741c <stm32_gpio_intc_enable_line>:
; {
 800741c: b580         	push	{r7, lr}
 800741e: b084         	sub	sp, #0x10
 8007420: af00         	add	r7, sp, #0x0
 8007422: 6078         	str	r0, [r7, #0x4]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 8007424: 6878         	ldr	r0, [r7, #0x4]
 8007426: f016 ff3a    	bl	0x801e29e <ll_exti_line_to_linenum> @ imm = #0x16e74
 800742a: 4603         	mov	r3, r0
 800742c: 60fb         	str	r3, [r7, #0xc]
; 	irqnum = exti_irq_table[line_num];
 800742e: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800744c <stm32_gpio_intc_enable_line+0x30>
 8007430: 68fb         	ldr	r3, [r7, #0xc]
 8007432: f932 3013    	ldrsh.w	r3, [r2, r3, lsl #1]
 8007436: 60bb         	str	r3, [r7, #0x8]
; 	LL_EXTI_EnableIT_0_31(line);
 8007438: 6878         	ldr	r0, [r7, #0x4]
 800743a: f016 fe34    	bl	0x801e0a6 <LL_EXTI_EnableIT_0_31> @ imm = #0x16c68
; 	irq_enable(irqnum);
 800743e: 68b8         	ldr	r0, [r7, #0x8]
 8007440: f016 f8bb    	bl	0x801d5ba <arch_irq_enable> @ imm = #0x16176
; }
 8007444: bf00         	nop
 8007446: 3710         	adds	r7, #0x10
 8007448: 46bd         	mov	sp, r7
 800744a: bd80         	pop	{r7, pc}

0800744c <$d>:
 800744c: 9c 06 00 24  	.word	0x2400069c

08007450 <stm32_gpio_intc_select_line_trigger>:
; {
 8007450: b580         	push	{r7, lr}
 8007452: b082         	sub	sp, #0x8
 8007454: af00         	add	r7, sp, #0x0
 8007456: 6078         	str	r0, [r7, #0x4]
 8007458: 6039         	str	r1, [r7]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 800745a: f44f 1180    	mov.w	r1, #0x100000
 800745e: 2000         	movs	r0, #0x0
 8007460: f016 fecb    	bl	0x801e1fa <z_stm32_hsem_lock> @ imm = #0x16d96
; 	switch (trg) {
 8007464: 683b         	ldr	r3, [r7]
 8007466: 2b03         	cmp	r3, #0x3
 8007468: d826         	bhi	0x80074b8 <stm32_gpio_intc_select_line_trigger+0x68> @ imm = #0x4c
 800746a: a201         	adr	r2, #4 <stm32_gpio_intc_select_line_trigger+0x1f>
 800746c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08007470 <$d>:
 8007470: 81 74 00 08  	.word	0x08007481
 8007474: 8f 74 00 08  	.word	0x0800748f
 8007478: 9d 74 00 08  	.word	0x0800749d
 800747c: ab 74 00 08  	.word	0x080074ab

08007480 <$t>:
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 8007480: 6878         	ldr	r0, [r7, #0x4]
 8007482: f016 fe4b    	bl	0x801e11c <LL_EXTI_DisableRisingTrig_0_31> @ imm = #0x16c96
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 8007486: 6878         	ldr	r0, [r7, #0x4]
 8007488: f016 fe6d    	bl	0x801e166 <LL_EXTI_DisableFallingTrig_0_31> @ imm = #0x16cda
; 		break;
 800748c: e015         	b	0x80074ba <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x2a
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 800748e: 6878         	ldr	r0, [r7, #0x4]
 8007490: f016 fe32    	bl	0x801e0f8 <LL_EXTI_EnableRisingTrig_0_31> @ imm = #0x16c64
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 8007494: 6878         	ldr	r0, [r7, #0x4]
 8007496: f016 fe66    	bl	0x801e166 <LL_EXTI_DisableFallingTrig_0_31> @ imm = #0x16ccc
; 		break;
 800749a: e00e         	b	0x80074ba <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x1c
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 800749c: 6878         	ldr	r0, [r7, #0x4]
 800749e: f016 fe50    	bl	0x801e142 <LL_EXTI_EnableFallingTrig_0_31> @ imm = #0x16ca0
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 80074a2: 6878         	ldr	r0, [r7, #0x4]
 80074a4: f016 fe3a    	bl	0x801e11c <LL_EXTI_DisableRisingTrig_0_31> @ imm = #0x16c74
; 		break;
 80074a8: e007         	b	0x80074ba <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0xe
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 80074aa: 6878         	ldr	r0, [r7, #0x4]
 80074ac: f016 fe24    	bl	0x801e0f8 <LL_EXTI_EnableRisingTrig_0_31> @ imm = #0x16c48
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 80074b0: 6878         	ldr	r0, [r7, #0x4]
 80074b2: f016 fe46    	bl	0x801e142 <LL_EXTI_EnableFallingTrig_0_31> @ imm = #0x16c8c
; 		break;
 80074b6: e000         	b	0x80074ba <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x0
; 		break;
 80074b8: bf00         	nop
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 80074ba: 2000         	movs	r0, #0x0
 80074bc: f016 fea8    	bl	0x801e210 <z_stm32_hsem_unlock> @ imm = #0x16d50
; }
 80074c0: bf00         	nop
 80074c2: 3708         	adds	r7, #0x8
 80074c4: 46bd         	mov	sp, r7
 80074c6: bd80         	pop	{r7, pc}

080074c8 <stm32_gpio_intc_set_irq_callback>:
; {
 80074c8: b580         	push	{r7, lr}
 80074ca: b088         	sub	sp, #0x20
 80074cc: af00         	add	r7, sp, #0x0
 80074ce: 60f8         	str	r0, [r7, #0xc]
 80074d0: 60b9         	str	r1, [r7, #0x8]
 80074d2: 607a         	str	r2, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 80074d4: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800753c <stm32_gpio_intc_set_irq_callback+0x74>
 80074d6: 61fb         	str	r3, [r7, #0x1c]
; 	struct stm32_exti_data *data = dev->data;
 80074d8: 69fb         	ldr	r3, [r7, #0x1c]
 80074da: 691b         	ldr	r3, [r3, #0x10]
 80074dc: 61bb         	str	r3, [r7, #0x18]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 80074de: 68f8         	ldr	r0, [r7, #0xc]
 80074e0: f016 fedd    	bl	0x801e29e <ll_exti_line_to_linenum> @ imm = #0x16dba
 80074e4: 4603         	mov	r3, r0
 80074e6: 617b         	str	r3, [r7, #0x14]
; 	if ((data->cb[line_num].cb == cb) && (data->cb[line_num].data == user)) {
 80074e8: 69bb         	ldr	r3, [r7, #0x18]
 80074ea: 697a         	ldr	r2, [r7, #0x14]
 80074ec: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 80074f0: 68ba         	ldr	r2, [r7, #0x8]
 80074f2: 429a         	cmp	r2, r3
 80074f4: d109         	bne	0x800750a <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x12
 80074f6: 69ba         	ldr	r2, [r7, #0x18]
 80074f8: 697b         	ldr	r3, [r7, #0x14]
 80074fa: 00db         	lsls	r3, r3, #0x3
 80074fc: 4413         	add	r3, r2
 80074fe: 685b         	ldr	r3, [r3, #0x4]
 8007500: 687a         	ldr	r2, [r7, #0x4]
 8007502: 429a         	cmp	r2, r3
 8007504: d101         	bne	0x800750a <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x2
; 		return 0;
 8007506: 2300         	movs	r3, #0x0
 8007508: e014         	b	0x8007534 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x28
; 	if (data->cb[line_num].cb != NULL) {
 800750a: 69bb         	ldr	r3, [r7, #0x18]
 800750c: 697a         	ldr	r2, [r7, #0x14]
 800750e: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 8007512: 2b00         	cmp	r3, #0x0
 8007514: d002         	beq	0x800751c <stm32_gpio_intc_set_irq_callback+0x54> @ imm = #0x4
; 		return -EBUSY;
 8007516: f06f 030f    	mvn	r3, #0xf
 800751a: e00b         	b	0x8007534 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x16
; 	data->cb[line_num].cb = cb;
 800751c: 69bb         	ldr	r3, [r7, #0x18]
 800751e: 697a         	ldr	r2, [r7, #0x14]
 8007520: 68b9         	ldr	r1, [r7, #0x8]
 8007522: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = user;
 8007526: 69ba         	ldr	r2, [r7, #0x18]
 8007528: 697b         	ldr	r3, [r7, #0x14]
 800752a: 00db         	lsls	r3, r3, #0x3
 800752c: 4413         	add	r3, r2
 800752e: 687a         	ldr	r2, [r7, #0x4]
 8007530: 605a         	str	r2, [r3, #0x4]
; 	return 0;
 8007532: 2300         	movs	r3, #0x0
; }
 8007534: 4618         	mov	r0, r3
 8007536: 3720         	adds	r7, #0x20
 8007538: 46bd         	mov	sp, r7
 800753a: bd80         	pop	{r7, pc}

0800753c <$d>:
 800753c: e8 96 02 08  	.word	0x080296e8

08007540 <stm32_gpio_intc_remove_irq_callback>:
; {
 8007540: b580         	push	{r7, lr}
 8007542: b086         	sub	sp, #0x18
 8007544: af00         	add	r7, sp, #0x0
 8007546: 6078         	str	r0, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 8007548: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800757c <stm32_gpio_intc_remove_irq_callback+0x3c>
 800754a: 617b         	str	r3, [r7, #0x14]
; 	struct stm32_exti_data *data = dev->data;
 800754c: 697b         	ldr	r3, [r7, #0x14]
 800754e: 691b         	ldr	r3, [r3, #0x10]
 8007550: 613b         	str	r3, [r7, #0x10]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 8007552: 6878         	ldr	r0, [r7, #0x4]
 8007554: f016 fea3    	bl	0x801e29e <ll_exti_line_to_linenum> @ imm = #0x16d46
 8007558: 4603         	mov	r3, r0
 800755a: 60fb         	str	r3, [r7, #0xc]
; 	data->cb[line_num].cb = NULL;
 800755c: 693b         	ldr	r3, [r7, #0x10]
 800755e: 68fa         	ldr	r2, [r7, #0xc]
 8007560: 2100         	movs	r1, #0x0
 8007562: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = NULL;
 8007566: 693a         	ldr	r2, [r7, #0x10]
 8007568: 68fb         	ldr	r3, [r7, #0xc]
 800756a: 00db         	lsls	r3, r3, #0x3
 800756c: 4413         	add	r3, r2
 800756e: 2200         	movs	r2, #0x0
 8007570: 605a         	str	r2, [r3, #0x4]
; }
 8007572: bf00         	nop
 8007574: 3718         	adds	r7, #0x18
 8007576: 46bd         	mov	sp, r7
 8007578: bd80         	pop	{r7, pc}
 800757a: bf00         	nop

0800757c <$d>:
 800757c: e8 96 02 08  	.word	0x080296e8

08007580 <z_impl_can_send>:
; {
 8007580: b590         	push	{r4, r7, lr}
 8007582: b097         	sub	sp, #0x5c
 8007584: af08         	add	r7, sp, #0x20
 8007586: 60f8         	str	r0, [r7, #0xc]
 8007588: 60b9         	str	r1, [r7, #0x8]
 800758a: e9c7 2300    	strd	r2, r3, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 800758e: 68fb         	ldr	r3, [r7, #0xc]
 8007590: 689b         	ldr	r3, [r3, #0x8]
 8007592: 62fb         	str	r3, [r7, #0x2c]
; 	CHECKIF(frame == NULL) {
 8007594: 68bb         	ldr	r3, [r7, #0x8]
 8007596: 2b00         	cmp	r3, #0x0
 8007598: d102         	bne	0x80075a0 <z_impl_can_send+0x20> @ imm = #0x4
; 		return -EINVAL;
 800759a: f06f 0315    	mvn	r3, #0x15
 800759e: e089         	b	0x80076b4 <z_impl_can_send+0x134> @ imm = #0x112
; 	if ((frame->flags & CAN_FRAME_IDE) != 0U) {
 80075a0: 68bb         	ldr	r3, [r7, #0x8]
 80075a2: 795b         	ldrb	r3, [r3, #0x5]
 80075a4: f003 0301    	and	r3, r3, #0x1
 80075a8: 2b00         	cmp	r3, #0x0
 80075aa: d003         	beq	0x80075b4 <z_impl_can_send+0x34> @ imm = #0x6
; 		id_mask = CAN_EXT_ID_MASK;
 80075ac: f06f 4360    	mvn	r3, #0xe0000000
 80075b0: 633b         	str	r3, [r7, #0x30]
 80075b2: e002         	b	0x80075ba <z_impl_can_send+0x3a> @ imm = #0x4
; 		id_mask = CAN_STD_ID_MASK;
 80075b4: f240 73ff    	movw	r3, #0x7ff
 80075b8: 633b         	str	r3, [r7, #0x30]
; 	CHECKIF((frame->id & ~(id_mask)) != 0U) {
 80075ba: 68bb         	ldr	r3, [r7, #0x8]
 80075bc: 681a         	ldr	r2, [r3]
 80075be: 6b3b         	ldr	r3, [r7, #0x30]
 80075c0: 43db         	mvns	r3, r3
 80075c2: 4013         	ands	r3, r2
 80075c4: 2b00         	cmp	r3, #0x0
 80075c6: d040         	beq	0x800764a <z_impl_can_send+0xca> @ imm = #0x80
; 		LOG_ERR("invalid frame with %s (%d-bit) CAN ID 0x%0*x",
 80075c8: 2303         	movs	r3, #0x3
 80075ca: 2b00         	cmp	r3, #0x0
 80075cc: d03a         	beq	0x8007644 <z_impl_can_send+0xc4> @ imm = #0x74
 80075ce: 2301         	movs	r3, #0x1
 80075d0: f887 302b    	strb.w	r3, [r7, #0x2b]
 80075d4: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80075d8: f083 0301    	eor	r3, r3, #0x1
 80075dc: b2db         	uxtb	r3, r3
 80075de: 2b00         	cmp	r3, #0x0
 80075e0: d130         	bne	0x8007644 <z_impl_can_send+0xc4> @ imm = #0x60
 80075e2: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80076bc <z_impl_can_send+0x13c>
 80075e4: 681c         	ldr	r4, [r3]
 80075e6: 68bb         	ldr	r3, [r7, #0x8]
 80075e8: 795b         	ldrb	r3, [r3, #0x5]
 80075ea: f003 0301    	and	r3, r3, #0x1
 80075ee: 2b00         	cmp	r3, #0x0
 80075f0: d001         	beq	0x80075f6 <z_impl_can_send+0x76> @ imm = #0x2
 80075f2: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80076c0 <z_impl_can_send+0x140>
 80075f4: e000         	b	0x80075f8 <z_impl_can_send+0x78> @ imm = #0x0
 80075f6: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80076c4 <z_impl_can_send+0x144>
 80075f8: 68ba         	ldr	r2, [r7, #0x8]
 80075fa: 7952         	ldrb	r2, [r2, #0x5]
 80075fc: f002 0201    	and	r2, r2, #0x1
 8007600: 2a00         	cmp	r2, #0x0
 8007602: d001         	beq	0x8007608 <z_impl_can_send+0x88> @ imm = #0x2
 8007604: 221d         	movs	r2, #0x1d
 8007606: e000         	b	0x800760a <z_impl_can_send+0x8a> @ imm = #0x0
 8007608: 220b         	movs	r2, #0xb
 800760a: 68b9         	ldr	r1, [r7, #0x8]
 800760c: 7949         	ldrb	r1, [r1, #0x5]
 800760e: f001 0101    	and	r1, r1, #0x1
 8007612: 2900         	cmp	r1, #0x0
 8007614: d001         	beq	0x800761a <z_impl_can_send+0x9a> @ imm = #0x2
 8007616: 2108         	movs	r1, #0x8
 8007618: e000         	b	0x800761c <z_impl_can_send+0x9c> @ imm = #0x0
 800761a: 2103         	movs	r1, #0x3
 800761c: 68b8         	ldr	r0, [r7, #0x8]
 800761e: 6800         	ldr	r0, [r0]
 8007620: 9006         	str	r0, [sp, #0x18]
 8007622: 9105         	str	r1, [sp, #0x14]
 8007624: 9204         	str	r2, [sp, #0x10]
 8007626: 9303         	str	r3, [sp, #0xc]
 8007628: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x80076c8 <z_impl_can_send+0x148>
 800762a: 9302         	str	r3, [sp, #0x8]
 800762c: 2300         	movs	r3, #0x0
 800762e: 9301         	str	r3, [sp, #0x4]
 8007630: 2300         	movs	r3, #0x0
 8007632: 9300         	str	r3, [sp]
 8007634: 2300         	movs	r3, #0x0
 8007636: 2201         	movs	r2, #0x1
 8007638: 4621         	mov	r1, r4
 800763a: 2000         	movs	r0, #0x0
 800763c: f016 ff0e    	bl	0x801e45c <z_log_msg_runtime_create> @ imm = #0x16e1c
 8007640: 2300         	movs	r3, #0x0
 8007642: 627b         	str	r3, [r7, #0x24]
; 		return -EINVAL;
 8007644: f06f 0315    	mvn	r3, #0x15
 8007648: e034         	b	0x80076b4 <z_impl_can_send+0x134> @ imm = #0x68
; 	if (callback == NULL) {
 800764a: 6cbb         	ldr	r3, [r7, #0x48]
 800764c: 2b00         	cmp	r3, #0x0
 800764e: d125         	bne	0x800769c <z_impl_can_send+0x11c> @ imm = #0x4a
; 		k_sem_init(&ctx.done, 0, 1);
 8007650: f107 0310    	add.w	r3, r7, #0x10
 8007654: 2201         	movs	r2, #0x1
 8007656: 2100         	movs	r1, #0x0
 8007658: 4618         	mov	r0, r3
 800765a: f016 fe7e    	bl	0x801e35a <k_sem_init>  @ imm = #0x16cfc
; 		err = api->send(dev, frame, timeout, can_tx_default_cb, &ctx);
 800765e: 6afb         	ldr	r3, [r7, #0x2c]
 8007660: 695c         	ldr	r4, [r3, #0x14]
 8007662: f107 0310    	add.w	r3, r7, #0x10
 8007666: 9301         	str	r3, [sp, #0x4]
 8007668: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80076cc <z_impl_can_send+0x14c>
 800766a: 9300         	str	r3, [sp]
 800766c: e9d7 2300    	ldrd	r2, r3, [r7]
 8007670: 68b9         	ldr	r1, [r7, #0x8]
 8007672: 68f8         	ldr	r0, [r7, #0xc]
 8007674: 47a0         	blx	r4
 8007676: 6378         	str	r0, [r7, #0x34]
; 		if (err != 0) {
 8007678: 6b7b         	ldr	r3, [r7, #0x34]
 800767a: 2b00         	cmp	r3, #0x0
 800767c: d001         	beq	0x8007682 <z_impl_can_send+0x102> @ imm = #0x2
; 			return err;
 800767e: 6b7b         	ldr	r3, [r7, #0x34]
 8007680: e018         	b	0x80076b4 <z_impl_can_send+0x134> @ imm = #0x30
; 		k_sem_take(&ctx.done, K_FOREVER);
 8007682: f04f 30ff    	mov.w	r0, #0xffffffff
 8007686: f04f 31ff    	mov.w	r1, #0xffffffff
 800768a: f107 0410    	add.w	r4, r7, #0x10
 800768e: 4602         	mov	r2, r0
 8007690: 460b         	mov	r3, r1
 8007692: 4620         	mov	r0, r4
 8007694: f016 fe71    	bl	0x801e37a <k_sem_take>  @ imm = #0x16ce2
; 		return ctx.status;
 8007698: 6a3b         	ldr	r3, [r7, #0x20]
 800769a: e00b         	b	0x80076b4 <z_impl_can_send+0x134> @ imm = #0x16
; 	return api->send(dev, frame, timeout, callback, user_data);
 800769c: 6afb         	ldr	r3, [r7, #0x2c]
 800769e: 695c         	ldr	r4, [r3, #0x14]
 80076a0: 6cfb         	ldr	r3, [r7, #0x4c]
 80076a2: 9301         	str	r3, [sp, #0x4]
 80076a4: 6cbb         	ldr	r3, [r7, #0x48]
 80076a6: 9300         	str	r3, [sp]
 80076a8: e9d7 2300    	ldrd	r2, r3, [r7]
 80076ac: 68b9         	ldr	r1, [r7, #0x8]
 80076ae: 68f8         	ldr	r0, [r7, #0xc]
 80076b0: 47a0         	blx	r4
 80076b2: 4603         	mov	r3, r0
; }
 80076b4: 4618         	mov	r0, r3
 80076b6: 373c         	adds	r7, #0x3c
 80076b8: 46bd         	mov	sp, r7
 80076ba: bd90         	pop	{r4, r7, pc}

080076bc <$d>:
 80076bc: bc 06 00 24  	.word	0x240006bc
 80076c0: 78 ab 02 08  	.word	0x0802ab78
 80076c4: 84 ab 02 08  	.word	0x0802ab84
 80076c8: 90 ab 02 08  	.word	0x0802ab90
 80076cc: 99 e4 01 08  	.word	0x0801e499

080076d0 <can_add_rx_filter>:
; {
 80076d0: b5f0         	push	{r4, r5, r6, r7, lr}
 80076d2: b093         	sub	sp, #0x4c
 80076d4: af0a         	add	r7, sp, #0x28
 80076d6: 60f8         	str	r0, [r7, #0xc]
 80076d8: 60b9         	str	r1, [r7, #0x8]
 80076da: 607a         	str	r2, [r7, #0x4]
 80076dc: 603b         	str	r3, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 80076de: 68fb         	ldr	r3, [r7, #0xc]
 80076e0: 689b         	ldr	r3, [r3, #0x8]
 80076e2: 613b         	str	r3, [r7, #0x10]
; 	CHECKIF(callback == NULL || filter == NULL) {
 80076e4: 68bb         	ldr	r3, [r7, #0x8]
 80076e6: 2b00         	cmp	r3, #0x0
 80076e8: d002         	beq	0x80076f0 <can_add_rx_filter+0x20> @ imm = #0x4
 80076ea: 683b         	ldr	r3, [r7]
 80076ec: 2b00         	cmp	r3, #0x0
 80076ee: d102         	bne	0x80076f6 <can_add_rx_filter+0x26> @ imm = #0x4
; 		return -EINVAL;
 80076f0: f06f 0315    	mvn	r3, #0x15
 80076f4: e06e         	b	0x80077d4 <can_add_rx_filter+0x104> @ imm = #0xdc
; 	if ((filter->flags & CAN_FILTER_IDE) != 0U) {
 80076f6: 683b         	ldr	r3, [r7]
 80076f8: 7a1b         	ldrb	r3, [r3, #0x8]
 80076fa: f003 0301    	and	r3, r3, #0x1
 80076fe: 2b00         	cmp	r3, #0x0
 8007700: d003         	beq	0x800770a <can_add_rx_filter+0x3a> @ imm = #0x6
; 		id_mask = CAN_EXT_ID_MASK;
 8007702: f06f 4360    	mvn	r3, #0xe0000000
 8007706: 617b         	str	r3, [r7, #0x14]
 8007708: e002         	b	0x8007710 <can_add_rx_filter+0x40> @ imm = #0x4
; 		id_mask = CAN_STD_ID_MASK;
 800770a: f240 73ff    	movw	r3, #0x7ff
 800770e: 617b         	str	r3, [r7, #0x14]
; 	CHECKIF(((filter->id & ~(id_mask)) != 0U) || ((filter->mask & ~(id_mask)) != 0U)) {
 8007710: 683b         	ldr	r3, [r7]
 8007712: 681a         	ldr	r2, [r3]
 8007714: 697b         	ldr	r3, [r7, #0x14]
 8007716: 43db         	mvns	r3, r3
 8007718: 4013         	ands	r3, r2
 800771a: 2b00         	cmp	r3, #0x0
 800771c: d106         	bne	0x800772c <can_add_rx_filter+0x5c> @ imm = #0xc
 800771e: 683b         	ldr	r3, [r7]
 8007720: 685a         	ldr	r2, [r3, #0x4]
 8007722: 697b         	ldr	r3, [r7, #0x14]
 8007724: 43db         	mvns	r3, r3
 8007726: 4013         	ands	r3, r2
 8007728: 2b00         	cmp	r3, #0x0
 800772a: d04b         	beq	0x80077c4 <can_add_rx_filter+0xf4> @ imm = #0x96
; 		LOG_ERR("invalid filter with %s (%d-bit) CAN ID 0x%0*x, CAN ID mask 0x%0*x",
 800772c: 2303         	movs	r3, #0x3
 800772e: 2b00         	cmp	r3, #0x0
 8007730: d045         	beq	0x80077be <can_add_rx_filter+0xee> @ imm = #0x8a
 8007732: 2301         	movs	r3, #0x1
 8007734: 76fb         	strb	r3, [r7, #0x1b]
 8007736: 7efb         	ldrb	r3, [r7, #0x1b]
 8007738: f083 0301    	eor	r3, r3, #0x1
 800773c: b2db         	uxtb	r3, r3
 800773e: 2b00         	cmp	r3, #0x0
 8007740: d13d         	bne	0x80077be <can_add_rx_filter+0xee> @ imm = #0x7a
 8007742: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80077dc <can_add_rx_filter+0x10c>
 8007744: 681e         	ldr	r6, [r3]
 8007746: 683b         	ldr	r3, [r7]
 8007748: 7a1b         	ldrb	r3, [r3, #0x8]
 800774a: f003 0301    	and	r3, r3, #0x1
 800774e: 2b00         	cmp	r3, #0x0
 8007750: d001         	beq	0x8007756 <can_add_rx_filter+0x86> @ imm = #0x2
 8007752: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80077e0 <can_add_rx_filter+0x110>
 8007754: e000         	b	0x8007758 <can_add_rx_filter+0x88> @ imm = #0x0
 8007756: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80077e4 <can_add_rx_filter+0x114>
 8007758: 683a         	ldr	r2, [r7]
 800775a: 7a12         	ldrb	r2, [r2, #0x8]
 800775c: f002 0201    	and	r2, r2, #0x1
 8007760: 2a00         	cmp	r2, #0x0
 8007762: d001         	beq	0x8007768 <can_add_rx_filter+0x98> @ imm = #0x2
 8007764: 221d         	movs	r2, #0x1d
 8007766: e000         	b	0x800776a <can_add_rx_filter+0x9a> @ imm = #0x0
 8007768: 220b         	movs	r2, #0xb
 800776a: 6839         	ldr	r1, [r7]
 800776c: 7a09         	ldrb	r1, [r1, #0x8]
 800776e: f001 0101    	and	r1, r1, #0x1
 8007772: 2900         	cmp	r1, #0x0
 8007774: d001         	beq	0x800777a <can_add_rx_filter+0xaa> @ imm = #0x2
 8007776: 2108         	movs	r1, #0x8
 8007778: e000         	b	0x800777c <can_add_rx_filter+0xac> @ imm = #0x0
 800777a: 2103         	movs	r1, #0x3
 800777c: 6838         	ldr	r0, [r7]
 800777e: 6800         	ldr	r0, [r0]
 8007780: 683c         	ldr	r4, [r7]
 8007782: 7a24         	ldrb	r4, [r4, #0x8]
 8007784: f004 0401    	and	r4, r4, #0x1
 8007788: 2c00         	cmp	r4, #0x0
 800778a: d001         	beq	0x8007790 <can_add_rx_filter+0xc0> @ imm = #0x2
 800778c: 2408         	movs	r4, #0x8
 800778e: e000         	b	0x8007792 <can_add_rx_filter+0xc2> @ imm = #0x0
 8007790: 2403         	movs	r4, #0x3
 8007792: 683d         	ldr	r5, [r7]
 8007794: 686d         	ldr	r5, [r5, #0x4]
 8007796: 9508         	str	r5, [sp, #0x20]
 8007798: 9407         	str	r4, [sp, #0x1c]
 800779a: 9006         	str	r0, [sp, #0x18]
 800779c: 9105         	str	r1, [sp, #0x14]
 800779e: 9204         	str	r2, [sp, #0x10]
 80077a0: 9303         	str	r3, [sp, #0xc]
 80077a2: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80077e8 <can_add_rx_filter+0x118>
 80077a4: 9302         	str	r3, [sp, #0x8]
 80077a6: 2300         	movs	r3, #0x0
 80077a8: 9301         	str	r3, [sp, #0x4]
 80077aa: 2300         	movs	r3, #0x0
 80077ac: 9300         	str	r3, [sp]
 80077ae: 2300         	movs	r3, #0x0
 80077b0: 2201         	movs	r2, #0x1
 80077b2: 4631         	mov	r1, r6
 80077b4: 2000         	movs	r0, #0x0
 80077b6: f016 fe51    	bl	0x801e45c <z_log_msg_runtime_create> @ imm = #0x16ca2
 80077ba: 2300         	movs	r3, #0x0
 80077bc: 61fb         	str	r3, [r7, #0x1c]
; 		return -EINVAL;
 80077be: f06f 0315    	mvn	r3, #0x15
 80077c2: e007         	b	0x80077d4 <can_add_rx_filter+0x104> @ imm = #0xe
; 	return api->add_rx_filter(dev, callback, user_data, filter);
 80077c4: 693b         	ldr	r3, [r7, #0x10]
 80077c6: 699c         	ldr	r4, [r3, #0x18]
 80077c8: 683b         	ldr	r3, [r7]
 80077ca: 687a         	ldr	r2, [r7, #0x4]
 80077cc: 68b9         	ldr	r1, [r7, #0x8]
 80077ce: 68f8         	ldr	r0, [r7, #0xc]
 80077d0: 47a0         	blx	r4
 80077d2: 4603         	mov	r3, r0
; }
 80077d4: 4618         	mov	r0, r3
 80077d6: 3724         	adds	r7, #0x24
 80077d8: 46bd         	mov	sp, r7
 80077da: bdf0         	pop	{r4, r5, r6, r7, pc}

080077dc <$d>:
 80077dc: bc 06 00 24  	.word	0x240006bc
 80077e0: 78 ab 02 08  	.word	0x0802ab78
 80077e4: 84 ab 02 08  	.word	0x0802ab84
 80077e8: c0 ab 02 08  	.word	0x0802abc0

080077ec <update_sample_pnt>:
; {
 80077ec: b480         	push	{r7}
 80077ee: b089         	sub	sp, #0x24
 80077f0: af00         	add	r7, sp, #0x0
 80077f2: 60f8         	str	r0, [r7, #0xc]
 80077f4: 60b9         	str	r1, [r7, #0x8]
 80077f6: 607a         	str	r2, [r7, #0x4]
 80077f8: 603b         	str	r3, [r7]
; 	uint16_t tseg1_max = max->phase_seg1 + max->prop_seg;
 80077fa: 6abb         	ldr	r3, [r7, #0x28]
 80077fc: 889a         	ldrh	r2, [r3, #0x4]
 80077fe: 6abb         	ldr	r3, [r7, #0x28]
 8007800: 885b         	ldrh	r3, [r3, #0x2]
 8007802: 4413         	add	r3, r2
 8007804: 837b         	strh	r3, [r7, #0x1a]
; 	uint16_t tseg1_min = min->phase_seg1 + min->prop_seg;
 8007806: 683b         	ldr	r3, [r7]
 8007808: 889a         	ldrh	r2, [r3, #0x4]
 800780a: 683b         	ldr	r3, [r7]
 800780c: 885b         	ldrh	r3, [r3, #0x2]
 800780e: 4413         	add	r3, r2
 8007810: 833b         	strh	r3, [r7, #0x18]
; 	tseg2 = total_tq - (total_tq * sample_pnt) / 1000;
 8007812: 68fb         	ldr	r3, [r7, #0xc]
 8007814: b29a         	uxth	r2, r3
 8007816: 68fb         	ldr	r3, [r7, #0xc]
 8007818: 68b9         	ldr	r1, [r7, #0x8]
 800781a: fb01 f303    	mul	r3, r1, r3
 800781e: 4953         	ldr	r1, [pc, #0x14c]        @ 0x800796c <update_sample_pnt+0x180>
 8007820: fba1 1303    	umull	r1, r3, r1, r3
 8007824: 099b         	lsrs	r3, r3, #0x6
 8007826: b29b         	uxth	r3, r3
 8007828: 1ad3         	subs	r3, r2, r3
 800782a: 83bb         	strh	r3, [r7, #0x1c]
; 	tseg2 = CLAMP(tseg2, min->phase_seg2, max->phase_seg2);
 800782c: 683b         	ldr	r3, [r7]
 800782e: 88db         	ldrh	r3, [r3, #0x6]
 8007830: 8bba         	ldrh	r2, [r7, #0x1c]
 8007832: 429a         	cmp	r2, r3
 8007834: d802         	bhi	0x800783c <update_sample_pnt+0x50> @ imm = #0x4
 8007836: 683b         	ldr	r3, [r7]
 8007838: 88db         	ldrh	r3, [r3, #0x6]
 800783a: e006         	b	0x800784a <update_sample_pnt+0x5e> @ imm = #0xc
 800783c: 6abb         	ldr	r3, [r7, #0x28]
 800783e: 88db         	ldrh	r3, [r3, #0x6]
 8007840: 8bba         	ldrh	r2, [r7, #0x1c]
 8007842: 4293         	cmp	r3, r2
 8007844: bf28         	it	hs
 8007846: 4613         	movhs	r3, r2
 8007848: b29b         	uxth	r3, r3
 800784a: 83bb         	strh	r3, [r7, #0x1c]
; 	tseg1 = total_tq - CAN_SYNC_SEG - tseg2;
 800784c: 68fb         	ldr	r3, [r7, #0xc]
 800784e: b29a         	uxth	r2, r3
 8007850: 8bbb         	ldrh	r3, [r7, #0x1c]
 8007852: 1ad3         	subs	r3, r2, r3
 8007854: b29b         	uxth	r3, r3
 8007856: 3b01         	subs	r3, #0x1
 8007858: 83fb         	strh	r3, [r7, #0x1e]
; 	if (tseg1 > tseg1_max) {
 800785a: 8bfa         	ldrh	r2, [r7, #0x1e]
 800785c: 8b7b         	ldrh	r3, [r7, #0x1a]
 800785e: 429a         	cmp	r2, r3
 8007860: d910         	bls	0x8007884 <update_sample_pnt+0x98> @ imm = #0x20
; 		tseg1 = tseg1_max;
 8007862: 8b7b         	ldrh	r3, [r7, #0x1a]
 8007864: 83fb         	strh	r3, [r7, #0x1e]
; 		tseg2 = total_tq - CAN_SYNC_SEG - tseg1;
 8007866: 68fb         	ldr	r3, [r7, #0xc]
 8007868: b29a         	uxth	r2, r3
 800786a: 8bfb         	ldrh	r3, [r7, #0x1e]
 800786c: 1ad3         	subs	r3, r2, r3
 800786e: b29b         	uxth	r3, r3
 8007870: 3b01         	subs	r3, #0x1
 8007872: 83bb         	strh	r3, [r7, #0x1c]
; 		if (tseg2 > max->phase_seg2) {
 8007874: 6abb         	ldr	r3, [r7, #0x28]
 8007876: 88db         	ldrh	r3, [r3, #0x6]
 8007878: 8bba         	ldrh	r2, [r7, #0x1c]
 800787a: 429a         	cmp	r2, r3
 800787c: d917         	bls	0x80078ae <update_sample_pnt+0xc2> @ imm = #0x2e
; 			return -ENOTSUP;
 800787e: f06f 0385    	mvn	r3, #0x85
 8007882: e06c         	b	0x800795e <update_sample_pnt+0x172> @ imm = #0xd8
; 	} else if (tseg1 < tseg1_min) {
 8007884: 8bfa         	ldrh	r2, [r7, #0x1e]
 8007886: 8b3b         	ldrh	r3, [r7, #0x18]
 8007888: 429a         	cmp	r2, r3
 800788a: d210         	bhs	0x80078ae <update_sample_pnt+0xc2> @ imm = #0x20
; 		tseg1 = tseg1_min;
 800788c: 8b3b         	ldrh	r3, [r7, #0x18]
 800788e: 83fb         	strh	r3, [r7, #0x1e]
; 		tseg2 = total_tq - CAN_SYNC_SEG - tseg1;
 8007890: 68fb         	ldr	r3, [r7, #0xc]
 8007892: b29a         	uxth	r2, r3
 8007894: 8bfb         	ldrh	r3, [r7, #0x1e]
 8007896: 1ad3         	subs	r3, r2, r3
 8007898: b29b         	uxth	r3, r3
 800789a: 3b01         	subs	r3, #0x1
 800789c: 83bb         	strh	r3, [r7, #0x1c]
; 		if (tseg2 < min->phase_seg2) {
 800789e: 683b         	ldr	r3, [r7]
 80078a0: 88db         	ldrh	r3, [r3, #0x6]
 80078a2: 8bba         	ldrh	r2, [r7, #0x1c]
 80078a4: 429a         	cmp	r2, r3
 80078a6: d202         	bhs	0x80078ae <update_sample_pnt+0xc2> @ imm = #0x4
; 			return -ENOTSUP;
 80078a8: f06f 0385    	mvn	r3, #0x85
 80078ac: e057         	b	0x800795e <update_sample_pnt+0x172> @ imm = #0xae
; 	res->phase_seg2 = tseg2;
 80078ae: 687b         	ldr	r3, [r7, #0x4]
 80078b0: 8bba         	ldrh	r2, [r7, #0x1c]
 80078b2: 80da         	strh	r2, [r3, #0x6]
; 	res->prop_seg = CLAMP(tseg1 / 2, min->prop_seg, max->prop_seg);
 80078b4: 8bfb         	ldrh	r3, [r7, #0x1e]
 80078b6: 085b         	lsrs	r3, r3, #0x1
 80078b8: b29a         	uxth	r2, r3
 80078ba: 683b         	ldr	r3, [r7]
 80078bc: 885b         	ldrh	r3, [r3, #0x2]
 80078be: 429a         	cmp	r2, r3
 80078c0: d802         	bhi	0x80078c8 <update_sample_pnt+0xdc> @ imm = #0x4
 80078c2: 683b         	ldr	r3, [r7]
 80078c4: 885b         	ldrh	r3, [r3, #0x2]
 80078c6: e008         	b	0x80078da <update_sample_pnt+0xee> @ imm = #0x10
 80078c8: 6abb         	ldr	r3, [r7, #0x28]
 80078ca: 885a         	ldrh	r2, [r3, #0x2]
 80078cc: 8bfb         	ldrh	r3, [r7, #0x1e]
 80078ce: 085b         	lsrs	r3, r3, #0x1
 80078d0: b29b         	uxth	r3, r3
 80078d2: 4293         	cmp	r3, r2
 80078d4: bf28         	it	hs
 80078d6: 4613         	movhs	r3, r2
 80078d8: b29b         	uxth	r3, r3
 80078da: 687a         	ldr	r2, [r7, #0x4]
 80078dc: 8053         	strh	r3, [r2, #0x2]
; 	res->phase_seg1 = tseg1 - res->prop_seg;
 80078de: 687b         	ldr	r3, [r7, #0x4]
 80078e0: 885b         	ldrh	r3, [r3, #0x2]
 80078e2: 8bfa         	ldrh	r2, [r7, #0x1e]
 80078e4: 1ad3         	subs	r3, r2, r3
 80078e6: b29a         	uxth	r2, r3
 80078e8: 687b         	ldr	r3, [r7, #0x4]
 80078ea: 809a         	strh	r2, [r3, #0x4]
; 	if (res->phase_seg1 > max->phase_seg1) {
 80078ec: 687b         	ldr	r3, [r7, #0x4]
 80078ee: 889a         	ldrh	r2, [r3, #0x4]
 80078f0: 6abb         	ldr	r3, [r7, #0x28]
 80078f2: 889b         	ldrh	r3, [r3, #0x4]
 80078f4: 429a         	cmp	r2, r3
 80078f6: d90b         	bls	0x8007910 <update_sample_pnt+0x124> @ imm = #0x16
; 		res->phase_seg1 = max->phase_seg1;
 80078f8: 6abb         	ldr	r3, [r7, #0x28]
 80078fa: 889a         	ldrh	r2, [r3, #0x4]
 80078fc: 687b         	ldr	r3, [r7, #0x4]
 80078fe: 809a         	strh	r2, [r3, #0x4]
; 		res->prop_seg = tseg1 - res->phase_seg1;
 8007900: 687b         	ldr	r3, [r7, #0x4]
 8007902: 889b         	ldrh	r3, [r3, #0x4]
 8007904: 8bfa         	ldrh	r2, [r7, #0x1e]
 8007906: 1ad3         	subs	r3, r2, r3
 8007908: b29a         	uxth	r2, r3
 800790a: 687b         	ldr	r3, [r7, #0x4]
 800790c: 805a         	strh	r2, [r3, #0x2]
 800790e: e010         	b	0x8007932 <update_sample_pnt+0x146> @ imm = #0x20
; 	} else if (res->phase_seg1 < min->phase_seg1) {
 8007910: 687b         	ldr	r3, [r7, #0x4]
 8007912: 889a         	ldrh	r2, [r3, #0x4]
 8007914: 683b         	ldr	r3, [r7]
 8007916: 889b         	ldrh	r3, [r3, #0x4]
 8007918: 429a         	cmp	r2, r3
 800791a: d20a         	bhs	0x8007932 <update_sample_pnt+0x146> @ imm = #0x14
; 		res->phase_seg1 = min->phase_seg1;
 800791c: 683b         	ldr	r3, [r7]
 800791e: 889a         	ldrh	r2, [r3, #0x4]
 8007920: 687b         	ldr	r3, [r7, #0x4]
 8007922: 809a         	strh	r2, [r3, #0x4]
; 		res->prop_seg = tseg1 - res->phase_seg1;
 8007924: 687b         	ldr	r3, [r7, #0x4]
 8007926: 889b         	ldrh	r3, [r3, #0x4]
 8007928: 8bfa         	ldrh	r2, [r7, #0x1e]
 800792a: 1ad3         	subs	r3, r2, r3
 800792c: b29a         	uxth	r2, r3
 800792e: 687b         	ldr	r3, [r7, #0x4]
 8007930: 805a         	strh	r2, [r3, #0x2]
; 	sample_pnt_res = (CAN_SYNC_SEG + tseg1) * 1000 / total_tq;
 8007932: 8bfb         	ldrh	r3, [r7, #0x1e]
 8007934: 3301         	adds	r3, #0x1
 8007936: f44f 727a    	mov.w	r2, #0x3e8
 800793a: fb02 f303    	mul	r3, r2, r3
 800793e: 461a         	mov	r2, r3
 8007940: 68fb         	ldr	r3, [r7, #0xc]
 8007942: fbb2 f3f3    	udiv	r3, r2, r3
 8007946: 617b         	str	r3, [r7, #0x14]
; 		sample_pnt_res - sample_pnt :
 8007948: 697a         	ldr	r2, [r7, #0x14]
 800794a: 68bb         	ldr	r3, [r7, #0x8]
 800794c: 429a         	cmp	r2, r3
 800794e: d903         	bls	0x8007958 <update_sample_pnt+0x16c> @ imm = #0x6
 8007950: 697a         	ldr	r2, [r7, #0x14]
 8007952: 68bb         	ldr	r3, [r7, #0x8]
 8007954: 1ad3         	subs	r3, r2, r3
 8007956: e002         	b	0x800795e <update_sample_pnt+0x172> @ imm = #0x4
; 		sample_pnt - sample_pnt_res;
 8007958: 68ba         	ldr	r2, [r7, #0x8]
 800795a: 697b         	ldr	r3, [r7, #0x14]
 800795c: 1ad3         	subs	r3, r2, r3
; }
 800795e: 4618         	mov	r0, r3
 8007960: 3724         	adds	r7, #0x24
 8007962: 46bd         	mov	sp, r7
 8007964: f85d 7b04    	ldr	r7, [sp], #4
 8007968: 4770         	bx	lr
 800796a: bf00         	nop

0800796c <$d>:
 800796c: d3 4d 62 10  	.word	0x10624dd3

08007970 <sample_point_for_bitrate>:
; {
 8007970: b480         	push	{r7}
 8007972: b085         	sub	sp, #0x14
 8007974: af00         	add	r7, sp, #0x0
 8007976: 6078         	str	r0, [r7, #0x4]
; 	if (bitrate > 800000) {
 8007978: 687b         	ldr	r3, [r7, #0x4]
 800797a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80079ac <sample_point_for_bitrate+0x3c>
 800797c: 4293         	cmp	r3, r2
 800797e: d903         	bls	0x8007988 <sample_point_for_bitrate+0x18> @ imm = #0x6
; 		sample_pnt = 750;
 8007980: f240 23ee    	movw	r3, #0x2ee
 8007984: 81fb         	strh	r3, [r7, #0xe]
 8007986: e00a         	b	0x800799e <sample_point_for_bitrate+0x2e> @ imm = #0x14
; 	} else if (bitrate > 500000) {
 8007988: 687b         	ldr	r3, [r7, #0x4]
 800798a: 4a09         	ldr	r2, [pc, #0x24]         @ 0x80079b0 <sample_point_for_bitrate+0x40>
 800798c: 4293         	cmp	r3, r2
 800798e: d903         	bls	0x8007998 <sample_point_for_bitrate+0x28> @ imm = #0x6
; 		sample_pnt = 800;
 8007990: f44f 7348    	mov.w	r3, #0x320
 8007994: 81fb         	strh	r3, [r7, #0xe]
 8007996: e002         	b	0x800799e <sample_point_for_bitrate+0x2e> @ imm = #0x4
; 		sample_pnt = 875;
 8007998: f240 336b    	movw	r3, #0x36b
 800799c: 81fb         	strh	r3, [r7, #0xe]
; 	return sample_pnt;
 800799e: 89fb         	ldrh	r3, [r7, #0xe]
; }
 80079a0: 4618         	mov	r0, r3
 80079a2: 3714         	adds	r7, #0x14
 80079a4: 46bd         	mov	sp, r7
 80079a6: f85d 7b04    	ldr	r7, [sp], #4
 80079aa: 4770         	bx	lr

080079ac <$d>:
 80079ac: 00 35 0c 00  	.word	0x000c3500
 80079b0: 20 a1 07 00  	.word	0x0007a120

080079b4 <can_calc_timing_internal>:
; {
 80079b4: b580         	push	{r7, lr}
 80079b6: b094         	sub	sp, #0x50
 80079b8: af06         	add	r7, sp, #0x18
 80079ba: 60f8         	str	r0, [r7, #0xc]
 80079bc: 60b9         	str	r1, [r7, #0x8]
 80079be: 607a         	str	r2, [r7, #0x4]
 80079c0: 603b         	str	r3, [r7]
; 	uint32_t total_tq = CAN_SYNC_SEG + max->prop_seg + max->phase_seg1 + max->phase_seg2;
 80079c2: 683b         	ldr	r3, [r7]
 80079c4: 885b         	ldrh	r3, [r3, #0x2]
 80079c6: 3301         	adds	r3, #0x1
 80079c8: 683a         	ldr	r2, [r7]
 80079ca: 8892         	ldrh	r2, [r2, #0x4]
 80079cc: 4413         	add	r3, r2
 80079ce: 683a         	ldr	r2, [r7]
 80079d0: 88d2         	ldrh	r2, [r2, #0x6]
 80079d2: 4413         	add	r3, r2
 80079d4: 62fb         	str	r3, [r7, #0x2c]
; 	struct can_timing tmp_res = { 0 };
 80079d6: f107 0314    	add.w	r3, r7, #0x14
 80079da: 2200         	movs	r2, #0x0
 80079dc: 601a         	str	r2, [r3]
 80079de: 605a         	str	r2, [r3, #0x4]
 80079e0: 811a         	strh	r2, [r3, #0x8]
; 	int err_min = INT_MAX;
 80079e2: f06f 4300    	mvn	r3, #0x80000000
 80079e6: 637b         	str	r3, [r7, #0x34]
; 	if (bitrate == 0 || sample_pnt >= 1000) {
 80079e8: 6c3b         	ldr	r3, [r7, #0x40]
 80079ea: 2b00         	cmp	r3, #0x0
 80079ec: d004         	beq	0x80079f8 <can_calc_timing_internal+0x44> @ imm = #0x8
 80079ee: f8b7 3044    	ldrh.w	r3, [r7, #0x44]
 80079f2: f5b3 7f7a    	cmp.w	r3, #0x3e8
 80079f6: d302         	blo	0x80079fe <can_calc_timing_internal+0x4a> @ imm = #0x4
; 		return -EINVAL;
 80079f8: f06f 0315    	mvn	r3, #0x15
 80079fc: e0b7         	b	0x8007b6e <can_calc_timing_internal+0x1ba> @ imm = #0x16e
; 	err = can_get_core_clock(dev, &core_clock);
 80079fe: f107 0310    	add.w	r3, r7, #0x10
 8007a02: 4619         	mov	r1, r3
 8007a04: 68f8         	ldr	r0, [r7, #0xc]
 8007a06: f016 fd03    	bl	0x801e410 <can_get_core_clock> @ imm = #0x16a06
 8007a0a: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 8007a0c: 6abb         	ldr	r3, [r7, #0x28]
 8007a0e: 2b00         	cmp	r3, #0x0
 8007a10: d002         	beq	0x8007a18 <can_calc_timing_internal+0x64> @ imm = #0x4
; 		return -EIO;
 8007a12: f06f 0304    	mvn	r3, #0x4
 8007a16: e0aa         	b	0x8007b6e <can_calc_timing_internal+0x1ba> @ imm = #0x154
; 	if (sample_pnt == 0U) {
 8007a18: f8b7 3044    	ldrh.w	r3, [r7, #0x44]
 8007a1c: 2b00         	cmp	r3, #0x0
 8007a1e: d105         	bne	0x8007a2c <can_calc_timing_internal+0x78> @ imm = #0xa
; 		sample_pnt = sample_point_for_bitrate(bitrate);
 8007a20: 6c38         	ldr	r0, [r7, #0x40]
 8007a22: f7ff ffa5    	bl	0x8007970 <sample_point_for_bitrate> @ imm = #-0xb6
 8007a26: 4603         	mov	r3, r0
 8007a28: f8a7 3044    	strh.w	r3, [r7, #0x44]
; 	for (prescaler = MAX(core_clock / (total_tq * bitrate), min->prescaler);
 8007a2c: 687b         	ldr	r3, [r7, #0x4]
 8007a2e: 891b         	ldrh	r3, [r3, #0x8]
 8007a30: 4618         	mov	r0, r3
 8007a32: 693a         	ldr	r2, [r7, #0x10]
 8007a34: 6afb         	ldr	r3, [r7, #0x2c]
 8007a36: 6c39         	ldr	r1, [r7, #0x40]
 8007a38: fb01 f303    	mul	r3, r1, r3
 8007a3c: fbb2 f3f3    	udiv	r3, r2, r3
 8007a40: 4283         	cmp	r3, r0
 8007a42: bf38         	it	lo
 8007a44: 4603         	movlo	r3, r0
 8007a46: 633b         	str	r3, [r7, #0x30]
 8007a48: e03e         	b	0x8007ac8 <can_calc_timing_internal+0x114> @ imm = #0x7c
; 		if (core_clock % (prescaler * bitrate)) {
 8007a4a: 693b         	ldr	r3, [r7, #0x10]
 8007a4c: 6b3a         	ldr	r2, [r7, #0x30]
 8007a4e: 6c39         	ldr	r1, [r7, #0x40]
 8007a50: fb01 f202    	mul	r2, r1, r2
 8007a54: fbb3 f1f2    	udiv	r1, r3, r2
 8007a58: fb01 f202    	mul	r2, r1, r2
 8007a5c: 1a9b         	subs	r3, r3, r2
 8007a5e: 2b00         	cmp	r3, #0x0
 8007a60: d12c         	bne	0x8007abc <can_calc_timing_internal+0x108> @ imm = #0x58
; 		total_tq = core_clock / (prescaler * bitrate);
 8007a62: 693a         	ldr	r2, [r7, #0x10]
 8007a64: 6b3b         	ldr	r3, [r7, #0x30]
 8007a66: 6c39         	ldr	r1, [r7, #0x40]
 8007a68: fb01 f303    	mul	r3, r1, r3
 8007a6c: fbb2 f3f3    	udiv	r3, r2, r3
 8007a70: 62fb         	str	r3, [r7, #0x2c]
; 		err = update_sample_pnt(total_tq, sample_pnt, &tmp_res, min, max);
 8007a72: f8b7 1044    	ldrh.w	r1, [r7, #0x44]
 8007a76: f107 0214    	add.w	r2, r7, #0x14
 8007a7a: 683b         	ldr	r3, [r7]
 8007a7c: 9300         	str	r3, [sp]
 8007a7e: 687b         	ldr	r3, [r7, #0x4]
 8007a80: 6af8         	ldr	r0, [r7, #0x2c]
 8007a82: f7ff feb3    	bl	0x80077ec <update_sample_pnt> @ imm = #-0x29a
 8007a86: 62b8         	str	r0, [r7, #0x28]
; 		if (err < 0) {
 8007a88: 6abb         	ldr	r3, [r7, #0x28]
 8007a8a: 2b00         	cmp	r3, #0x0
 8007a8c: db18         	blt	0x8007ac0 <can_calc_timing_internal+0x10c> @ imm = #0x30
; 		if (err < err_min) {
 8007a8e: 6aba         	ldr	r2, [r7, #0x28]
 8007a90: 6b7b         	ldr	r3, [r7, #0x34]
 8007a92: 429a         	cmp	r2, r3
 8007a94: da15         	bge	0x8007ac2 <can_calc_timing_internal+0x10e> @ imm = #0x2a
; 			err_min = err;
 8007a96: 6abb         	ldr	r3, [r7, #0x28]
 8007a98: 637b         	str	r3, [r7, #0x34]
; 			res->prop_seg = tmp_res.prop_seg;
 8007a9a: 8afa         	ldrh	r2, [r7, #0x16]
 8007a9c: 68bb         	ldr	r3, [r7, #0x8]
 8007a9e: 805a         	strh	r2, [r3, #0x2]
; 			res->phase_seg1 = tmp_res.phase_seg1;
 8007aa0: 8b3a         	ldrh	r2, [r7, #0x18]
 8007aa2: 68bb         	ldr	r3, [r7, #0x8]
 8007aa4: 809a         	strh	r2, [r3, #0x4]
; 			res->phase_seg2 = tmp_res.phase_seg2;
 8007aa6: 8b7a         	ldrh	r2, [r7, #0x1a]
 8007aa8: 68bb         	ldr	r3, [r7, #0x8]
 8007aaa: 80da         	strh	r2, [r3, #0x6]
; 			res->prescaler = (uint16_t)prescaler;
 8007aac: 6b3b         	ldr	r3, [r7, #0x30]
 8007aae: b29a         	uxth	r2, r3
 8007ab0: 68bb         	ldr	r3, [r7, #0x8]
 8007ab2: 811a         	strh	r2, [r3, #0x8]
; 			if (err == 0) {
 8007ab4: 6abb         	ldr	r3, [r7, #0x28]
 8007ab6: 2b00         	cmp	r3, #0x0
 8007ab8: d00d         	beq	0x8007ad6 <can_calc_timing_internal+0x122> @ imm = #0x1a
 8007aba: e002         	b	0x8007ac2 <can_calc_timing_internal+0x10e> @ imm = #0x4
; 			continue;
 8007abc: bf00         	nop
 8007abe: e000         	b	0x8007ac2 <can_calc_timing_internal+0x10e> @ imm = #0x0
; 			continue;
 8007ac0: bf00         	nop
; 	     prescaler++) {
 8007ac2: 6b3b         	ldr	r3, [r7, #0x30]
 8007ac4: 3301         	adds	r3, #0x1
 8007ac6: 633b         	str	r3, [r7, #0x30]
; 	     prescaler <= max->prescaler;
 8007ac8: 683b         	ldr	r3, [r7]
 8007aca: 891b         	ldrh	r3, [r3, #0x8]
 8007acc: 461a         	mov	r2, r3
 8007ace: 6b3b         	ldr	r3, [r7, #0x30]
 8007ad0: 4293         	cmp	r3, r2
 8007ad2: ddba         	ble	0x8007a4a <can_calc_timing_internal+0x96> @ imm = #-0x8c
 8007ad4: e000         	b	0x8007ad8 <can_calc_timing_internal+0x124> @ imm = #0x0
; 				break;
 8007ad6: bf00         	nop
; 	if (err_min != 0U) {
 8007ad8: 6b7b         	ldr	r3, [r7, #0x34]
 8007ada: 2b00         	cmp	r3, #0x0
 8007adc: d01f         	beq	0x8007b1e <can_calc_timing_internal+0x16a> @ imm = #0x3e
; 		LOG_DBG("Sample point error: %d 1/1000", err_min);
 8007ade: 2303         	movs	r3, #0x3
 8007ae0: 2b03         	cmp	r3, #0x3
 8007ae2: d91c         	bls	0x8007b1e <can_calc_timing_internal+0x16a> @ imm = #0x38
 8007ae4: 2301         	movs	r3, #0x1
 8007ae6: f887 3027    	strb.w	r3, [r7, #0x27]
 8007aea: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8007aee: f083 0301    	eor	r3, r3, #0x1
 8007af2: b2db         	uxtb	r3, r3
 8007af4: 2b00         	cmp	r3, #0x0
 8007af6: d112         	bne	0x8007b1e <can_calc_timing_internal+0x16a> @ imm = #0x24
 8007af8: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8007b78 <can_calc_timing_internal+0x1c4>
 8007afa: 6819         	ldr	r1, [r3]
 8007afc: 6b7b         	ldr	r3, [r7, #0x34]
 8007afe: 9304         	str	r3, [sp, #0x10]
 8007b00: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8007b7c <can_calc_timing_internal+0x1c8>
 8007b02: 9303         	str	r3, [sp, #0xc]
 8007b04: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8007b80 <can_calc_timing_internal+0x1cc>
 8007b06: 9302         	str	r3, [sp, #0x8]
 8007b08: 2308         	movs	r3, #0x8
 8007b0a: 9301         	str	r3, [sp, #0x4]
 8007b0c: 2300         	movs	r3, #0x0
 8007b0e: 9300         	str	r3, [sp]
 8007b10: 2300         	movs	r3, #0x0
 8007b12: 2204         	movs	r2, #0x4
 8007b14: 2000         	movs	r0, #0x0
 8007b16: f016 fca1    	bl	0x801e45c <z_log_msg_runtime_create> @ imm = #0x16942
 8007b1a: 2300         	movs	r3, #0x0
 8007b1c: 623b         	str	r3, [r7, #0x20]
; 	res->sjw = MIN(res->phase_seg1, res->phase_seg2 / 2);
 8007b1e: 68bb         	ldr	r3, [r7, #0x8]
 8007b20: 88db         	ldrh	r3, [r3, #0x6]
 8007b22: 085b         	lsrs	r3, r3, #0x1
 8007b24: b29a         	uxth	r2, r3
 8007b26: 68bb         	ldr	r3, [r7, #0x8]
 8007b28: 889b         	ldrh	r3, [r3, #0x4]
 8007b2a: 4293         	cmp	r3, r2
 8007b2c: bf28         	it	hs
 8007b2e: 4613         	movhs	r3, r2
 8007b30: b29a         	uxth	r2, r3
 8007b32: 68bb         	ldr	r3, [r7, #0x8]
 8007b34: 801a         	strh	r2, [r3]
; 	res->sjw = CLAMP(res->sjw, min->sjw, max->sjw);
 8007b36: 68bb         	ldr	r3, [r7, #0x8]
 8007b38: 881a         	ldrh	r2, [r3]
 8007b3a: 687b         	ldr	r3, [r7, #0x4]
 8007b3c: 881b         	ldrh	r3, [r3]
 8007b3e: 429a         	cmp	r2, r3
 8007b40: d802         	bhi	0x8007b48 <can_calc_timing_internal+0x194> @ imm = #0x4
 8007b42: 687b         	ldr	r3, [r7, #0x4]
 8007b44: 881b         	ldrh	r3, [r3]
 8007b46: e007         	b	0x8007b58 <can_calc_timing_internal+0x1a4> @ imm = #0xe
 8007b48: 683b         	ldr	r3, [r7]
 8007b4a: 881a         	ldrh	r2, [r3]
 8007b4c: 68bb         	ldr	r3, [r7, #0x8]
 8007b4e: 881b         	ldrh	r3, [r3]
 8007b50: 4293         	cmp	r3, r2
 8007b52: bf28         	it	hs
 8007b54: 4613         	movhs	r3, r2
 8007b56: b29b         	uxth	r3, r3
 8007b58: 68ba         	ldr	r2, [r7, #0x8]
 8007b5a: 8013         	strh	r3, [r2]
; 	return err_min == INT_MAX ? -ENOTSUP : err_min;
 8007b5c: 6b7b         	ldr	r3, [r7, #0x34]
 8007b5e: f06f 4200    	mvn	r2, #0x80000000
 8007b62: 4293         	cmp	r3, r2
 8007b64: d001         	beq	0x8007b6a <can_calc_timing_internal+0x1b6> @ imm = #0x2
 8007b66: 6b7b         	ldr	r3, [r7, #0x34]
 8007b68: e001         	b	0x8007b6e <can_calc_timing_internal+0x1ba> @ imm = #0x2
 8007b6a: f06f 0385    	mvn	r3, #0x85
; }
 8007b6e: 4618         	mov	r0, r3
 8007b70: 3738         	adds	r7, #0x38
 8007b72: 46bd         	mov	sp, r7
 8007b74: bd80         	pop	{r7, pc}
 8007b76: bf00         	nop

08007b78 <$d>:
 8007b78: bc 06 00 24  	.word	0x240006bc
 8007b7c: 5c ce 02 08  	.word	0x0802ce5c
 8007b80: 28 ac 02 08  	.word	0x0802ac28

08007b84 <z_impl_can_calc_timing>:
; {
 8007b84: b580         	push	{r7, lr}
 8007b86: b088         	sub	sp, #0x20
 8007b88: af02         	add	r7, sp, #0x8
 8007b8a: 60f8         	str	r0, [r7, #0xc]
 8007b8c: 60b9         	str	r1, [r7, #0x8]
 8007b8e: 607a         	str	r2, [r7, #0x4]
 8007b90: 807b         	strh	r3, [r7, #0x2]
; 	const struct can_timing *min = can_get_timing_min(dev);
 8007b92: 68f8         	ldr	r0, [r7, #0xc]
 8007b94: f016 fc4a    	bl	0x801e42c <can_get_timing_min> @ imm = #0x16894
 8007b98: 6178         	str	r0, [r7, #0x14]
; 	const struct can_timing *max = can_get_timing_max(dev);
 8007b9a: 68f8         	ldr	r0, [r7, #0xc]
 8007b9c: f016 fc52    	bl	0x801e444 <can_get_timing_max> @ imm = #0x168a4
 8007ba0: 6138         	str	r0, [r7, #0x10]
; 	if (bitrate > 1000000) {
 8007ba2: 687b         	ldr	r3, [r7, #0x4]
 8007ba4: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007bd0 <z_impl_can_calc_timing+0x4c>
 8007ba6: 4293         	cmp	r3, r2
 8007ba8: d902         	bls	0x8007bb0 <z_impl_can_calc_timing+0x2c> @ imm = #0x4
; 		return -EINVAL;
 8007baa: f06f 0315    	mvn	r3, #0x15
 8007bae: e00a         	b	0x8007bc6 <z_impl_can_calc_timing+0x42> @ imm = #0x14
; 	return can_calc_timing_internal(dev, res, min, max, bitrate, sample_pnt);
 8007bb0: 887b         	ldrh	r3, [r7, #0x2]
 8007bb2: 9301         	str	r3, [sp, #0x4]
 8007bb4: 687b         	ldr	r3, [r7, #0x4]
 8007bb6: 9300         	str	r3, [sp]
 8007bb8: 693b         	ldr	r3, [r7, #0x10]
 8007bba: 697a         	ldr	r2, [r7, #0x14]
 8007bbc: 68b9         	ldr	r1, [r7, #0x8]
 8007bbe: 68f8         	ldr	r0, [r7, #0xc]
 8007bc0: f7ff fef8    	bl	0x80079b4 <can_calc_timing_internal> @ imm = #-0x210
 8007bc4: 4603         	mov	r3, r0
; }
 8007bc6: 4618         	mov	r0, r3
 8007bc8: 3718         	adds	r7, #0x18
 8007bca: 46bd         	mov	sp, r7
 8007bcc: bd80         	pop	{r7, pc}
 8007bce: bf00         	nop

08007bd0 <$d>:
 8007bd0: 40 42 0f 00  	.word	0x000f4240

08007bd4 <can_dlc_to_bytes>:
; {
 8007bd4: b480         	push	{r7}
 8007bd6: b083         	sub	sp, #0xc
 8007bd8: af00         	add	r7, sp, #0x0
 8007bda: 4603         	mov	r3, r0
 8007bdc: 71fb         	strb	r3, [r7, #0x7]
; 	return dlc_table[MIN(dlc, ARRAY_SIZE(dlc_table) - 1)];
 8007bde: 79fb         	ldrb	r3, [r7, #0x7]
 8007be0: 2b0f         	cmp	r3, #0xf
 8007be2: bf28         	it	hs
 8007be4: 230f         	movhs	r3, #0xf
 8007be6: b2db         	uxtb	r3, r3
 8007be8: 461a         	mov	r2, r3
 8007bea: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8007bfc <can_dlc_to_bytes+0x28>
 8007bec: 5c9b         	ldrb	r3, [r3, r2]
; }
 8007bee: 4618         	mov	r0, r3
 8007bf0: 370c         	adds	r7, #0xc
 8007bf2: 46bd         	mov	sp, r7
 8007bf4: f85d 7b04    	ldr	r7, [sp], #4
 8007bf8: 4770         	bx	lr
 8007bfa: bf00         	nop

08007bfc <$d>:
 8007bfc: 90 ce 02 08  	.word	0x0802ce90

08007c00 <can_mcan_read_reg>:
; {
 8007c00: b580         	push	{r7, lr}
 8007c02: b08e         	sub	sp, #0x38
 8007c04: af06         	add	r7, sp, #0x18
 8007c06: 60f8         	str	r0, [r7, #0xc]
 8007c08: 460b         	mov	r3, r1
 8007c0a: 607a         	str	r2, [r7, #0x4]
 8007c0c: 817b         	strh	r3, [r7, #0xa]
; 	const struct can_mcan_config *config = dev->config;
 8007c0e: 68fb         	ldr	r3, [r7, #0xc]
 8007c10: 685b         	ldr	r3, [r3, #0x4]
 8007c12: 61fb         	str	r3, [r7, #0x1c]
; 	err = config->ops->read_reg(dev, reg, val);
 8007c14: 69fb         	ldr	r3, [r7, #0x1c]
 8007c16: 695b         	ldr	r3, [r3, #0x14]
 8007c18: 681b         	ldr	r3, [r3]
 8007c1a: 8979         	ldrh	r1, [r7, #0xa]
 8007c1c: 687a         	ldr	r2, [r7, #0x4]
 8007c1e: 68f8         	ldr	r0, [r7, #0xc]
 8007c20: 4798         	blx	r3
 8007c22: 61b8         	str	r0, [r7, #0x18]
; 	if (err != 0) {
 8007c24: 69bb         	ldr	r3, [r7, #0x18]
 8007c26: 2b00         	cmp	r3, #0x0
 8007c28: d01d         	beq	0x8007c66 <can_mcan_read_reg+0x66> @ imm = #0x3a
; 		LOG_ERR("failed to read reg 0x%03x (err %d)", reg, err);
 8007c2a: 2303         	movs	r3, #0x3
 8007c2c: 2b00         	cmp	r3, #0x0
 8007c2e: d01a         	beq	0x8007c66 <can_mcan_read_reg+0x66> @ imm = #0x34
 8007c30: 2301         	movs	r3, #0x1
 8007c32: 75fb         	strb	r3, [r7, #0x17]
 8007c34: 7dfb         	ldrb	r3, [r7, #0x17]
 8007c36: f083 0301    	eor	r3, r3, #0x1
 8007c3a: b2db         	uxtb	r3, r3
 8007c3c: 2b00         	cmp	r3, #0x0
 8007c3e: d112         	bne	0x8007c66 <can_mcan_read_reg+0x66> @ imm = #0x24
 8007c40: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8007c70 <can_mcan_read_reg+0x70>
 8007c42: 6819         	ldr	r1, [r3]
 8007c44: 897b         	ldrh	r3, [r7, #0xa]
 8007c46: 69ba         	ldr	r2, [r7, #0x18]
 8007c48: 9204         	str	r2, [sp, #0x10]
 8007c4a: 9303         	str	r3, [sp, #0xc]
 8007c4c: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8007c74 <can_mcan_read_reg+0x74>
 8007c4e: 9302         	str	r3, [sp, #0x8]
 8007c50: 2300         	movs	r3, #0x0
 8007c52: 9301         	str	r3, [sp, #0x4]
 8007c54: 2300         	movs	r3, #0x0
 8007c56: 9300         	str	r3, [sp]
 8007c58: 2300         	movs	r3, #0x0
 8007c5a: 2201         	movs	r2, #0x1
 8007c5c: 2000         	movs	r0, #0x0
 8007c5e: f016 fda8    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x16b50
 8007c62: 2300         	movs	r3, #0x0
 8007c64: 613b         	str	r3, [r7, #0x10]
; 	return err;
 8007c66: 69bb         	ldr	r3, [r7, #0x18]
; }
 8007c68: 4618         	mov	r0, r3
 8007c6a: 3720         	adds	r7, #0x20
 8007c6c: 46bd         	mov	sp, r7
 8007c6e: bd80         	pop	{r7, pc}

08007c70 <$d>:
 8007c70: c0 06 00 24  	.word	0x240006c0
 8007c74: 58 ac 02 08  	.word	0x0802ac58

08007c78 <can_mcan_write_reg>:
; {
 8007c78: b580         	push	{r7, lr}
 8007c7a: b08e         	sub	sp, #0x38
 8007c7c: af06         	add	r7, sp, #0x18
 8007c7e: 60f8         	str	r0, [r7, #0xc]
 8007c80: 460b         	mov	r3, r1
 8007c82: 607a         	str	r2, [r7, #0x4]
 8007c84: 817b         	strh	r3, [r7, #0xa]
; 	const struct can_mcan_config *config = dev->config;
 8007c86: 68fb         	ldr	r3, [r7, #0xc]
 8007c88: 685b         	ldr	r3, [r3, #0x4]
 8007c8a: 61fb         	str	r3, [r7, #0x1c]
; 	err = config->ops->write_reg(dev, reg, val);
 8007c8c: 69fb         	ldr	r3, [r7, #0x1c]
 8007c8e: 695b         	ldr	r3, [r3, #0x14]
 8007c90: 685b         	ldr	r3, [r3, #0x4]
 8007c92: 8979         	ldrh	r1, [r7, #0xa]
 8007c94: 687a         	ldr	r2, [r7, #0x4]
 8007c96: 68f8         	ldr	r0, [r7, #0xc]
 8007c98: 4798         	blx	r3
 8007c9a: 61b8         	str	r0, [r7, #0x18]
; 	if (err != 0) {
 8007c9c: 69bb         	ldr	r3, [r7, #0x18]
 8007c9e: 2b00         	cmp	r3, #0x0
 8007ca0: d01d         	beq	0x8007cde <can_mcan_write_reg+0x66> @ imm = #0x3a
; 		LOG_ERR("failed to write reg 0x%03x (err %d)", reg, err);
 8007ca2: 2303         	movs	r3, #0x3
 8007ca4: 2b00         	cmp	r3, #0x0
 8007ca6: d01a         	beq	0x8007cde <can_mcan_write_reg+0x66> @ imm = #0x34
 8007ca8: 2301         	movs	r3, #0x1
 8007caa: 75fb         	strb	r3, [r7, #0x17]
 8007cac: 7dfb         	ldrb	r3, [r7, #0x17]
 8007cae: f083 0301    	eor	r3, r3, #0x1
 8007cb2: b2db         	uxtb	r3, r3
 8007cb4: 2b00         	cmp	r3, #0x0
 8007cb6: d112         	bne	0x8007cde <can_mcan_write_reg+0x66> @ imm = #0x24
 8007cb8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8007ce8 <can_mcan_write_reg+0x70>
 8007cba: 6819         	ldr	r1, [r3]
 8007cbc: 897b         	ldrh	r3, [r7, #0xa]
 8007cbe: 69ba         	ldr	r2, [r7, #0x18]
 8007cc0: 9204         	str	r2, [sp, #0x10]
 8007cc2: 9303         	str	r3, [sp, #0xc]
 8007cc4: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8007cec <can_mcan_write_reg+0x74>
 8007cc6: 9302         	str	r3, [sp, #0x8]
 8007cc8: 2300         	movs	r3, #0x0
 8007cca: 9301         	str	r3, [sp, #0x4]
 8007ccc: 2300         	movs	r3, #0x0
 8007cce: 9300         	str	r3, [sp]
 8007cd0: 2300         	movs	r3, #0x0
 8007cd2: 2201         	movs	r2, #0x1
 8007cd4: 2000         	movs	r0, #0x0
 8007cd6: f016 fd6c    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x16ad8
 8007cda: 2300         	movs	r3, #0x0
 8007cdc: 613b         	str	r3, [r7, #0x10]
; 	return err;
 8007cde: 69bb         	ldr	r3, [r7, #0x18]
; }
 8007ce0: 4618         	mov	r0, r3
 8007ce2: 3720         	adds	r7, #0x20
 8007ce4: 46bd         	mov	sp, r7
 8007ce6: bd80         	pop	{r7, pc}

08007ce8 <$d>:
 8007ce8: c0 06 00 24  	.word	0x240006c0
 8007cec: 7c ac 02 08  	.word	0x0802ac7c

08007cf0 <can_mcan_exit_sleep_mode>:
; {
 8007cf0: b580         	push	{r7, lr}
 8007cf2: b086         	sub	sp, #0x18
 8007cf4: af00         	add	r7, sp, #0x0
 8007cf6: 6078         	str	r0, [r7, #0x4]
; 	struct can_mcan_data *data = dev->data;
 8007cf8: 687b         	ldr	r3, [r7, #0x4]
 8007cfa: 691b         	ldr	r3, [r3, #0x10]
 8007cfc: 613b         	str	r3, [r7, #0x10]
; 	k_mutex_lock(&data->lock, K_FOREVER);
 8007cfe: 693b         	ldr	r3, [r7, #0x10]
 8007d00: f103 0110    	add.w	r1, r3, #0x10
 8007d04: f04f 32ff    	mov.w	r2, #0xffffffff
 8007d08: f04f 33ff    	mov.w	r3, #0xffffffff
 8007d0c: 4608         	mov	r0, r1
 8007d0e: f016 fc85    	bl	0x801e61c <k_mutex_lock> @ imm = #0x1690a
; 	err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &cccr);
 8007d12: f107 0308    	add.w	r3, r7, #0x8
 8007d16: 461a         	mov	r2, r3
 8007d18: 2118         	movs	r1, #0x18
 8007d1a: 6878         	ldr	r0, [r7, #0x4]
 8007d1c: f7ff ff70    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x120
 8007d20: 6178         	str	r0, [r7, #0x14]
; 	if (err != 0) {
 8007d22: 697b         	ldr	r3, [r7, #0x14]
 8007d24: 2b00         	cmp	r3, #0x0
 8007d26: d147         	bne	0x8007db8 <can_mcan_exit_sleep_mode+0xc8> @ imm = #0x8e
; 	cccr &= ~CAN_MCAN_CCCR_CSR;
 8007d28: 68bb         	ldr	r3, [r7, #0x8]
 8007d2a: f023 0310    	bic	r3, r3, #0x10
 8007d2e: 60bb         	str	r3, [r7, #0x8]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_CCCR, cccr);
 8007d30: 68bb         	ldr	r3, [r7, #0x8]
 8007d32: 461a         	mov	r2, r3
 8007d34: 2118         	movs	r1, #0x18
 8007d36: 6878         	ldr	r0, [r7, #0x4]
 8007d38: f7ff ff9e    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0xc4
 8007d3c: 6178         	str	r0, [r7, #0x14]
; 	if (err != 0) {
 8007d3e: 697b         	ldr	r3, [r7, #0x14]
 8007d40: 2b00         	cmp	r3, #0x0
 8007d42: d13b         	bne	0x8007dbc <can_mcan_exit_sleep_mode+0xcc> @ imm = #0x76
; 	start_time = k_cycle_get_32();
 8007d44: f016 fc4e    	bl	0x801e5e4 <k_cycle_get_32> @ imm = #0x1689c
 8007d48: 60f8         	str	r0, [r7, #0xc]
; 	err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &cccr);
 8007d4a: f107 0308    	add.w	r3, r7, #0x8
 8007d4e: 461a         	mov	r2, r3
 8007d50: 2118         	movs	r1, #0x18
 8007d52: 6878         	ldr	r0, [r7, #0x4]
 8007d54: f7ff ff54    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x158
 8007d58: 6178         	str	r0, [r7, #0x14]
; 	if (err != 0) {
 8007d5a: 697b         	ldr	r3, [r7, #0x14]
 8007d5c: 2b00         	cmp	r3, #0x0
 8007d5e: d12f         	bne	0x8007dc0 <can_mcan_exit_sleep_mode+0xd0> @ imm = #0x5e
; 	while ((cccr & CAN_MCAN_CCCR_CSA) == CAN_MCAN_CCCR_CSA) {
 8007d60: e024         	b	0x8007dac <can_mcan_exit_sleep_mode+0xbc> @ imm = #0x48
; 		if (k_cycle_get_32() - start_time > k_ms_to_cyc_ceil32(CAN_INIT_TIMEOUT_MS)) {
 8007d62: f016 fc3f    	bl	0x801e5e4 <k_cycle_get_32> @ imm = #0x1687e
 8007d66: 4602         	mov	r2, r0
 8007d68: 68fb         	ldr	r3, [r7, #0xc]
 8007d6a: 1ad3         	subs	r3, r2, r3
 8007d6c: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x8007de0 <can_mcan_exit_sleep_mode+0xf0>
 8007d6e: 4293         	cmp	r3, r2
 8007d70: d911         	bls	0x8007d96 <can_mcan_exit_sleep_mode+0xa6> @ imm = #0x22
; 			cccr |= CAN_MCAN_CCCR_CSR;
 8007d72: 68bb         	ldr	r3, [r7, #0x8]
 8007d74: f043 0310    	orr	r3, r3, #0x10
 8007d78: 60bb         	str	r3, [r7, #0x8]
; 			err = can_mcan_write_reg(dev, CAN_MCAN_CCCR, cccr);
 8007d7a: 68bb         	ldr	r3, [r7, #0x8]
 8007d7c: 461a         	mov	r2, r3
 8007d7e: 2118         	movs	r1, #0x18
 8007d80: 6878         	ldr	r0, [r7, #0x4]
 8007d82: f7ff ff79    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x10e
 8007d86: 6178         	str	r0, [r7, #0x14]
; 			if (err != 0) {
 8007d88: 697b         	ldr	r3, [r7, #0x14]
 8007d8a: 2b00         	cmp	r3, #0x0
 8007d8c: d11a         	bne	0x8007dc4 <can_mcan_exit_sleep_mode+0xd4> @ imm = #0x34
; 			err = -EAGAIN;
 8007d8e: f06f 030a    	mvn	r3, #0xa
 8007d92: 617b         	str	r3, [r7, #0x14]
; 			goto unlock;
 8007d94: e019         	b	0x8007dca <can_mcan_exit_sleep_mode+0xda> @ imm = #0x32
; 		err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &cccr);
 8007d96: f107 0308    	add.w	r3, r7, #0x8
 8007d9a: 461a         	mov	r2, r3
 8007d9c: 2118         	movs	r1, #0x18
 8007d9e: 6878         	ldr	r0, [r7, #0x4]
 8007da0: f7ff ff2e    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x1a4
 8007da4: 6178         	str	r0, [r7, #0x14]
; 		if (err != 0) {
 8007da6: 697b         	ldr	r3, [r7, #0x14]
 8007da8: 2b00         	cmp	r3, #0x0
 8007daa: d10d         	bne	0x8007dc8 <can_mcan_exit_sleep_mode+0xd8> @ imm = #0x1a
; 	while ((cccr & CAN_MCAN_CCCR_CSA) == CAN_MCAN_CCCR_CSA) {
 8007dac: 68bb         	ldr	r3, [r7, #0x8]
 8007dae: f003 0308    	and	r3, r3, #0x8
 8007db2: 2b00         	cmp	r3, #0x0
 8007db4: d1d5         	bne	0x8007d62 <can_mcan_exit_sleep_mode+0x72> @ imm = #-0x56
; unlock:
 8007db6: e008         	b	0x8007dca <can_mcan_exit_sleep_mode+0xda> @ imm = #0x10
; 		goto unlock;
 8007db8: bf00         	nop
 8007dba: e006         	b	0x8007dca <can_mcan_exit_sleep_mode+0xda> @ imm = #0xc
; 		goto unlock;
 8007dbc: bf00         	nop
 8007dbe: e004         	b	0x8007dca <can_mcan_exit_sleep_mode+0xda> @ imm = #0x8
; 		goto unlock;
 8007dc0: bf00         	nop
 8007dc2: e002         	b	0x8007dca <can_mcan_exit_sleep_mode+0xda> @ imm = #0x4
; 				goto unlock;
 8007dc4: bf00         	nop
 8007dc6: e000         	b	0x8007dca <can_mcan_exit_sleep_mode+0xda> @ imm = #0x0
; 			goto unlock;
 8007dc8: bf00         	nop
; 	k_mutex_unlock(&data->lock);
 8007dca: 693b         	ldr	r3, [r7, #0x10]
 8007dcc: 3310         	adds	r3, #0x10
 8007dce: 4618         	mov	r0, r3
 8007dd0: f016 fc34    	bl	0x801e63c <k_mutex_unlock> @ imm = #0x16868
; 	return err;
 8007dd4: 6979         	ldr	r1, [r7, #0x14]
 8007dd6: 460b         	mov	r3, r1
; }
 8007dd8: 4618         	mov	r0, r3
 8007dda: 3718         	adds	r7, #0x18
 8007ddc: 46bd         	mov	sp, r7
 8007dde: bd80         	pop	{r7, pc}

08007de0 <$d>:
 8007de0: c0 3b 47 03  	.word	0x03473bc0

08007de4 <can_mcan_set_timing>:
; {
 8007de4: b580         	push	{r7, lr}
 8007de6: b086         	sub	sp, #0x18
 8007de8: af00         	add	r7, sp, #0x0
 8007dea: 6078         	str	r0, [r7, #0x4]
 8007dec: 6039         	str	r1, [r7]
; 	struct can_mcan_data *data = dev->data;
 8007dee: 687b         	ldr	r3, [r7, #0x4]
 8007df0: 691b         	ldr	r3, [r3, #0x10]
 8007df2: 617b         	str	r3, [r7, #0x14]
; 	uint32_t nbtp = 0U;
 8007df4: 2300         	movs	r3, #0x0
 8007df6: 613b         	str	r3, [r7, #0x10]
; 	if (data->common.started) {
 8007df8: 697b         	ldr	r3, [r7, #0x14]
 8007dfa: 791b         	ldrb	r3, [r3, #0x4]
 8007dfc: 2b00         	cmp	r3, #0x0
 8007dfe: d002         	beq	0x8007e06 <can_mcan_set_timing+0x22> @ imm = #0x4
; 		return -EBUSY;
 8007e00: f06f 010f    	mvn	r1, #0xf
 8007e04: e033         	b	0x8007e6e <can_mcan_set_timing+0x8a> @ imm = #0x66
; 	k_mutex_lock(&data->lock, K_FOREVER);
 8007e06: 697b         	ldr	r3, [r7, #0x14]
 8007e08: f103 0110    	add.w	r1, r3, #0x10
 8007e0c: f04f 32ff    	mov.w	r2, #0xffffffff
 8007e10: f04f 33ff    	mov.w	r3, #0xffffffff
 8007e14: 4608         	mov	r0, r1
 8007e16: f016 fc01    	bl	0x801e61c <k_mutex_lock> @ imm = #0x16802
; 	nbtp |= FIELD_PREP(CAN_MCAN_NBTP_NSJW, timing->sjw - 1UL) |
 8007e1a: 683b         	ldr	r3, [r7]
 8007e1c: 881b         	ldrh	r3, [r3]
 8007e1e: 3b01         	subs	r3, #0x1
 8007e20: 065a         	lsls	r2, r3, #0x19
; 		FIELD_PREP(CAN_MCAN_NBTP_NTSEG1, timing->phase_seg1 - 1UL) |
 8007e22: 683b         	ldr	r3, [r7]
 8007e24: 889b         	ldrh	r3, [r3, #0x4]
 8007e26: 3b01         	subs	r3, #0x1
 8007e28: 021b         	lsls	r3, r3, #0x8
 8007e2a: f403 437f    	and	r3, r3, #0xff00
; 	nbtp |= FIELD_PREP(CAN_MCAN_NBTP_NSJW, timing->sjw - 1UL) |
 8007e2e: 431a         	orrs	r2, r3
; 		FIELD_PREP(CAN_MCAN_NBTP_NTSEG2, timing->phase_seg2 - 1UL) |
 8007e30: 683b         	ldr	r3, [r7]
 8007e32: 88db         	ldrh	r3, [r3, #0x6]
 8007e34: 3b01         	subs	r3, #0x1
 8007e36: f003 037f    	and	r3, r3, #0x7f
; 		FIELD_PREP(CAN_MCAN_NBTP_NTSEG1, timing->phase_seg1 - 1UL) |
 8007e3a: 431a         	orrs	r2, r3
; 		FIELD_PREP(CAN_MCAN_NBTP_NBRP, timing->prescaler - 1UL);
 8007e3c: 683b         	ldr	r3, [r7]
 8007e3e: 891b         	ldrh	r3, [r3, #0x8]
 8007e40: 3b01         	subs	r3, #0x1
 8007e42: 0419         	lsls	r1, r3, #0x10
 8007e44: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007e78 <can_mcan_set_timing+0x94>
 8007e46: 400b         	ands	r3, r1
; 		FIELD_PREP(CAN_MCAN_NBTP_NTSEG2, timing->phase_seg2 - 1UL) |
 8007e48: 4313         	orrs	r3, r2
; 	nbtp |= FIELD_PREP(CAN_MCAN_NBTP_NSJW, timing->sjw - 1UL) |
 8007e4a: 693a         	ldr	r2, [r7, #0x10]
 8007e4c: 4313         	orrs	r3, r2
 8007e4e: 613b         	str	r3, [r7, #0x10]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_NBTP, nbtp);
 8007e50: 693a         	ldr	r2, [r7, #0x10]
 8007e52: 211c         	movs	r1, #0x1c
 8007e54: 6878         	ldr	r0, [r7, #0x4]
 8007e56: f7ff ff0f    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1e2
 8007e5a: 60f8         	str	r0, [r7, #0xc]
; 	if (err != 0) {
 8007e5c: 68fb         	ldr	r3, [r7, #0xc]
 8007e5e: 2b00         	cmp	r3, #0x0
; unlock:
 8007e60: bf00         	nop
; 	k_mutex_unlock(&data->lock);
 8007e62: 697b         	ldr	r3, [r7, #0x14]
 8007e64: 3310         	adds	r3, #0x10
 8007e66: 4618         	mov	r0, r3
 8007e68: f016 fbe8    	bl	0x801e63c <k_mutex_unlock> @ imm = #0x167d0
; 	return err;
 8007e6c: 68f9         	ldr	r1, [r7, #0xc]
; }
 8007e6e: 460b         	mov	r3, r1
 8007e70: 4618         	mov	r0, r3
 8007e72: 3718         	adds	r7, #0x18
 8007e74: 46bd         	mov	sp, r7
 8007e76: bd80         	pop	{r7, pc}

08007e78 <$d>:
 8007e78: 00 00 ff 01  	.word	0x01ff0000

08007e7c <can_mcan_start>:
; {
 8007e7c: b580         	push	{r7, lr}
 8007e7e: b08e         	sub	sp, #0x38
 8007e80: af04         	add	r7, sp, #0x10
 8007e82: 6078         	str	r0, [r7, #0x4]
; 	const struct can_mcan_config *config = dev->config;
 8007e84: 687b         	ldr	r3, [r7, #0x4]
 8007e86: 685b         	ldr	r3, [r3, #0x4]
 8007e88: 627b         	str	r3, [r7, #0x24]
; 	struct can_mcan_data *data = dev->data;
 8007e8a: 687b         	ldr	r3, [r7, #0x4]
 8007e8c: 691b         	ldr	r3, [r3, #0x10]
 8007e8e: 623b         	str	r3, [r7, #0x20]
; 	if (data->common.started) {
 8007e90: 6a3b         	ldr	r3, [r7, #0x20]
 8007e92: 791b         	ldrb	r3, [r3, #0x4]
 8007e94: 2b00         	cmp	r3, #0x0
 8007e96: d002         	beq	0x8007e9e <can_mcan_start+0x22> @ imm = #0x4
; 		return -EALREADY;
 8007e98: f06f 0377    	mvn	r3, #0x77
 8007e9c: e064         	b	0x8007f68 <can_mcan_start+0xec> @ imm = #0xc8
; 	if (config->common.phy != NULL) {
 8007e9e: 6a7b         	ldr	r3, [r7, #0x24]
 8007ea0: 681b         	ldr	r3, [r3]
 8007ea2: 2b00         	cmp	r3, #0x0
 8007ea4: d029         	beq	0x8007efa <can_mcan_start+0x7e> @ imm = #0x52
; 		err = can_transceiver_enable(config->common.phy, data->common.mode);
 8007ea6: 6a7b         	ldr	r3, [r7, #0x24]
 8007ea8: 681a         	ldr	r2, [r3]
 8007eaa: 6a3b         	ldr	r3, [r7, #0x20]
 8007eac: 681b         	ldr	r3, [r3]
 8007eae: 4619         	mov	r1, r3
 8007eb0: 4610         	mov	r0, r2
 8007eb2: f016 fc60    	bl	0x801e776 <can_transceiver_enable> @ imm = #0x168c0
 8007eb6: 61f8         	str	r0, [r7, #0x1c]
; 		if (err != 0) {
 8007eb8: 69fb         	ldr	r3, [r7, #0x1c]
 8007eba: 2b00         	cmp	r3, #0x0
 8007ebc: d01d         	beq	0x8007efa <can_mcan_start+0x7e> @ imm = #0x3a
; 			LOG_ERR("failed to enable CAN transceiver (err %d)", err);
 8007ebe: 2303         	movs	r3, #0x3
 8007ec0: 2b00         	cmp	r3, #0x0
 8007ec2: d018         	beq	0x8007ef6 <can_mcan_start+0x7a> @ imm = #0x30
 8007ec4: 2301         	movs	r3, #0x1
 8007ec6: 76fb         	strb	r3, [r7, #0x1b]
 8007ec8: 7efb         	ldrb	r3, [r7, #0x1b]
 8007eca: f083 0301    	eor	r3, r3, #0x1
 8007ece: b2db         	uxtb	r3, r3
 8007ed0: 2b00         	cmp	r3, #0x0
 8007ed2: d110         	bne	0x8007ef6 <can_mcan_start+0x7a> @ imm = #0x20
 8007ed4: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8007f70 <can_mcan_start+0xf4>
 8007ed6: 6819         	ldr	r1, [r3]
 8007ed8: 69fb         	ldr	r3, [r7, #0x1c]
 8007eda: 9303         	str	r3, [sp, #0xc]
 8007edc: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8007f74 <can_mcan_start+0xf8>
 8007ede: 9302         	str	r3, [sp, #0x8]
 8007ee0: 2300         	movs	r3, #0x0
 8007ee2: 9301         	str	r3, [sp, #0x4]
 8007ee4: 2300         	movs	r3, #0x0
 8007ee6: 9300         	str	r3, [sp]
 8007ee8: 2300         	movs	r3, #0x0
 8007eea: 2201         	movs	r2, #0x1
 8007eec: 2000         	movs	r0, #0x0
 8007eee: f016 fc60    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x168c0
 8007ef2: 2300         	movs	r3, #0x0
 8007ef4: 617b         	str	r3, [r7, #0x14]
; 			return err;
 8007ef6: 69fb         	ldr	r3, [r7, #0x1c]
 8007ef8: e036         	b	0x8007f68 <can_mcan_start+0xec> @ imm = #0x6c
; 	err = can_mcan_leave_init_mode(dev, K_MSEC(CAN_INIT_TIMEOUT_MS));
 8007efa: f44f 707a    	mov.w	r0, #0x3e8
 8007efe: f04f 0100    	mov.w	r1, #0x0
 8007f02: 4602         	mov	r2, r0
 8007f04: 460b         	mov	r3, r1
 8007f06: 6878         	ldr	r0, [r7, #0x4]
 8007f08: f016 fcf0    	bl	0x801e8ec <can_mcan_leave_init_mode> @ imm = #0x169e0
 8007f0c: 61f8         	str	r0, [r7, #0x1c]
; 	if (err != 0) {
 8007f0e: 69fb         	ldr	r3, [r7, #0x1c]
 8007f10: 2b00         	cmp	r3, #0x0
 8007f12: d025         	beq	0x8007f60 <can_mcan_start+0xe4> @ imm = #0x4a
; 		LOG_ERR("failed to leave init mode");
 8007f14: 2303         	movs	r3, #0x3
 8007f16: 2b00         	cmp	r3, #0x0
 8007f18: d016         	beq	0x8007f48 <can_mcan_start+0xcc> @ imm = #0x2c
 8007f1a: 2301         	movs	r3, #0x1
 8007f1c: 74fb         	strb	r3, [r7, #0x13]
 8007f1e: 7cfb         	ldrb	r3, [r7, #0x13]
 8007f20: f083 0301    	eor	r3, r3, #0x1
 8007f24: b2db         	uxtb	r3, r3
 8007f26: 2b00         	cmp	r3, #0x0
 8007f28: d10e         	bne	0x8007f48 <can_mcan_start+0xcc> @ imm = #0x1c
 8007f2a: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8007f70 <can_mcan_start+0xf4>
 8007f2c: 6819         	ldr	r1, [r3]
 8007f2e: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8007f78 <can_mcan_start+0xfc>
 8007f30: 9302         	str	r3, [sp, #0x8]
 8007f32: 2300         	movs	r3, #0x0
 8007f34: 9301         	str	r3, [sp, #0x4]
 8007f36: 2300         	movs	r3, #0x0
 8007f38: 9300         	str	r3, [sp]
 8007f3a: 2300         	movs	r3, #0x0
 8007f3c: 2201         	movs	r2, #0x1
 8007f3e: 2000         	movs	r0, #0x0
 8007f40: f016 fc37    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x1686e
 8007f44: 2300         	movs	r3, #0x0
 8007f46: 60fb         	str	r3, [r7, #0xc]
; 		if (config->common.phy != NULL) {
 8007f48: 6a7b         	ldr	r3, [r7, #0x24]
 8007f4a: 681b         	ldr	r3, [r3]
 8007f4c: 2b00         	cmp	r3, #0x0
 8007f4e: d004         	beq	0x8007f5a <can_mcan_start+0xde> @ imm = #0x8
; 			(void)can_transceiver_disable(config->common.phy);
 8007f50: 6a7b         	ldr	r3, [r7, #0x24]
 8007f52: 681b         	ldr	r3, [r3]
 8007f54: 4618         	mov	r0, r3
 8007f56: f016 fc1e    	bl	0x801e796 <can_transceiver_disable> @ imm = #0x1683c
; 		return -EIO;
 8007f5a: f06f 0304    	mvn	r3, #0x4
 8007f5e: e003         	b	0x8007f68 <can_mcan_start+0xec> @ imm = #0x6
; 	data->common.started = true;
 8007f60: 6a3b         	ldr	r3, [r7, #0x20]
 8007f62: 2201         	movs	r2, #0x1
 8007f64: 711a         	strb	r2, [r3, #0x4]
; 	return 0;
 8007f66: 2300         	movs	r3, #0x0
; }
 8007f68: 4618         	mov	r0, r3
 8007f6a: 3728         	adds	r7, #0x28
 8007f6c: 46bd         	mov	sp, r7
 8007f6e: bd80         	pop	{r7, pc}

08007f70 <$d>:
 8007f70: c0 06 00 24  	.word	0x240006c0
 8007f74: a0 ac 02 08  	.word	0x0802aca0
 8007f78: cc ac 02 08  	.word	0x0802accc

08007f7c <can_mcan_stop>:
; {
 8007f7c: b580         	push	{r7, lr}
 8007f7e: b090         	sub	sp, #0x40
 8007f80: af04         	add	r7, sp, #0x10
 8007f82: 6078         	str	r0, [r7, #0x4]
; 	const struct can_mcan_config *config = dev->config;
 8007f84: 687b         	ldr	r3, [r7, #0x4]
 8007f86: 685b         	ldr	r3, [r3, #0x4]
 8007f88: 62bb         	str	r3, [r7, #0x28]
; 	const struct can_mcan_callbacks *cbs = config->callbacks;
 8007f8a: 6abb         	ldr	r3, [r7, #0x28]
 8007f8c: 699b         	ldr	r3, [r3, #0x18]
 8007f8e: 627b         	str	r3, [r7, #0x24]
; 	struct can_mcan_data *data = dev->data;
 8007f90: 687b         	ldr	r3, [r7, #0x4]
 8007f92: 691b         	ldr	r3, [r3, #0x10]
 8007f94: 623b         	str	r3, [r7, #0x20]
; 	if (!data->common.started) {
 8007f96: 6a3b         	ldr	r3, [r7, #0x20]
 8007f98: 791b         	ldrb	r3, [r3, #0x4]
 8007f9a: f083 0301    	eor	r3, r3, #0x1
 8007f9e: b2db         	uxtb	r3, r3
 8007fa0: 2b00         	cmp	r3, #0x0
 8007fa2: d002         	beq	0x8007faa <can_mcan_stop+0x2e> @ imm = #0x4
; 		return -EALREADY;
 8007fa4: f06f 0377    	mvn	r3, #0x77
 8007fa8: e088         	b	0x80080bc <can_mcan_stop+0x140> @ imm = #0x110
; 	err = can_mcan_enter_init_mode(dev, K_MSEC(CAN_INIT_TIMEOUT_MS));
 8007faa: f44f 707a    	mov.w	r0, #0x3e8
 8007fae: f04f 0100    	mov.w	r1, #0x0
 8007fb2: 4602         	mov	r2, r0
 8007fb4: 460b         	mov	r3, r1
 8007fb6: 6878         	ldr	r0, [r7, #0x4]
 8007fb8: f016 fc19    	bl	0x801e7ee <can_mcan_enter_init_mode> @ imm = #0x16832
 8007fbc: 61f8         	str	r0, [r7, #0x1c]
; 	if (err != 0) {
 8007fbe: 69fb         	ldr	r3, [r7, #0x1c]
 8007fc0: 2b00         	cmp	r3, #0x0
 8007fc2: d01c         	beq	0x8007ffe <can_mcan_stop+0x82> @ imm = #0x38
; 		LOG_ERR("Failed to enter init mode");
 8007fc4: 2303         	movs	r3, #0x3
 8007fc6: 2b00         	cmp	r3, #0x0
 8007fc8: d016         	beq	0x8007ff8 <can_mcan_stop+0x7c> @ imm = #0x2c
 8007fca: 2301         	movs	r3, #0x1
 8007fcc: 73fb         	strb	r3, [r7, #0xf]
 8007fce: 7bfb         	ldrb	r3, [r7, #0xf]
 8007fd0: f083 0301    	eor	r3, r3, #0x1
 8007fd4: b2db         	uxtb	r3, r3
 8007fd6: 2b00         	cmp	r3, #0x0
 8007fd8: d10e         	bne	0x8007ff8 <can_mcan_stop+0x7c> @ imm = #0x1c
 8007fda: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x80080c4 <can_mcan_stop+0x148>
 8007fdc: 6819         	ldr	r1, [r3]
 8007fde: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x80080c8 <can_mcan_stop+0x14c>
 8007fe0: 9302         	str	r3, [sp, #0x8]
 8007fe2: 2300         	movs	r3, #0x0
 8007fe4: 9301         	str	r3, [sp, #0x4]
 8007fe6: 2300         	movs	r3, #0x0
 8007fe8: 9300         	str	r3, [sp]
 8007fea: 2300         	movs	r3, #0x0
 8007fec: 2201         	movs	r2, #0x1
 8007fee: 2000         	movs	r0, #0x0
 8007ff0: f016 fbdf    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x167be
 8007ff4: 2300         	movs	r3, #0x0
 8007ff6: 60bb         	str	r3, [r7, #0x8]
; 		return -EIO;
 8007ff8: f06f 0304    	mvn	r3, #0x4
 8007ffc: e05e         	b	0x80080bc <can_mcan_stop+0x140> @ imm = #0xbc
; 	if (config->common.phy != NULL) {
 8007ffe: 6abb         	ldr	r3, [r7, #0x28]
 8008000: 681b         	ldr	r3, [r3]
 8008002: 2b00         	cmp	r3, #0x0
 8008004: d026         	beq	0x8008054 <can_mcan_stop+0xd8> @ imm = #0x4c
; 		err = can_transceiver_disable(config->common.phy);
 8008006: 6abb         	ldr	r3, [r7, #0x28]
 8008008: 681b         	ldr	r3, [r3]
 800800a: 4618         	mov	r0, r3
 800800c: f016 fbc3    	bl	0x801e796 <can_transceiver_disable> @ imm = #0x16786
 8008010: 61f8         	str	r0, [r7, #0x1c]
; 		if (err != 0) {
 8008012: 69fb         	ldr	r3, [r7, #0x1c]
 8008014: 2b00         	cmp	r3, #0x0
 8008016: d01d         	beq	0x8008054 <can_mcan_stop+0xd8> @ imm = #0x3a
; 			LOG_ERR("failed to disable CAN transceiver (err %d)", err);
 8008018: 2303         	movs	r3, #0x3
 800801a: 2b00         	cmp	r3, #0x0
 800801c: d018         	beq	0x8008050 <can_mcan_stop+0xd4> @ imm = #0x30
 800801e: 2301         	movs	r3, #0x1
 8008020: 76fb         	strb	r3, [r7, #0x1b]
 8008022: 7efb         	ldrb	r3, [r7, #0x1b]
 8008024: f083 0301    	eor	r3, r3, #0x1
 8008028: b2db         	uxtb	r3, r3
 800802a: 2b00         	cmp	r3, #0x0
 800802c: d110         	bne	0x8008050 <can_mcan_stop+0xd4> @ imm = #0x20
 800802e: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80080c4 <can_mcan_stop+0x148>
 8008030: 6819         	ldr	r1, [r3]
 8008032: 69fb         	ldr	r3, [r7, #0x1c]
 8008034: 9303         	str	r3, [sp, #0xc]
 8008036: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80080cc <can_mcan_stop+0x150>
 8008038: 9302         	str	r3, [sp, #0x8]
 800803a: 2300         	movs	r3, #0x0
 800803c: 9301         	str	r3, [sp, #0x4]
 800803e: 2300         	movs	r3, #0x0
 8008040: 9300         	str	r3, [sp]
 8008042: 2300         	movs	r3, #0x0
 8008044: 2201         	movs	r2, #0x1
 8008046: 2000         	movs	r0, #0x0
 8008048: f016 fbb3    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x16766
 800804c: 2300         	movs	r3, #0x0
 800804e: 617b         	str	r3, [r7, #0x14]
; 			return err;
 8008050: 69fb         	ldr	r3, [r7, #0x1c]
 8008052: e033         	b	0x80080bc <can_mcan_stop+0x140> @ imm = #0x66
; 	can_mcan_enable_configuration_change(dev);
 8008054: 6878         	ldr	r0, [r7, #0x4]
 8008056: f016 fdef    	bl	0x801ec38 <can_mcan_enable_configuration_change> @ imm = #0x16bde
; 	data->common.started = false;
 800805a: 6a3b         	ldr	r3, [r7, #0x20]
 800805c: 2200         	movs	r2, #0x0
 800805e: 711a         	strb	r2, [r3, #0x4]
; 	for (tx_idx = 0U; tx_idx < cbs->num_tx; tx_idx++) {
 8008060: 2300         	movs	r3, #0x0
 8008062: 62fb         	str	r3, [r7, #0x2c]
 8008064: e023         	b	0x80080ae <can_mcan_stop+0x132> @ imm = #0x46
; 		tx_cb = cbs->tx[tx_idx].function;
 8008066: 6a7b         	ldr	r3, [r7, #0x24]
 8008068: 681a         	ldr	r2, [r3]
 800806a: 6afb         	ldr	r3, [r7, #0x2c]
 800806c: 00db         	lsls	r3, r3, #0x3
 800806e: 4413         	add	r3, r2
 8008070: 681b         	ldr	r3, [r3]
 8008072: 613b         	str	r3, [r7, #0x10]
; 		if (tx_cb != NULL) {
 8008074: 693b         	ldr	r3, [r7, #0x10]
 8008076: 2b00         	cmp	r3, #0x0
 8008078: d016         	beq	0x80080a8 <can_mcan_stop+0x12c> @ imm = #0x2c
; 			cbs->tx[tx_idx].function = NULL;
 800807a: 6a7b         	ldr	r3, [r7, #0x24]
 800807c: 681a         	ldr	r2, [r3]
 800807e: 6afb         	ldr	r3, [r7, #0x2c]
 8008080: 00db         	lsls	r3, r3, #0x3
 8008082: 4413         	add	r3, r2
 8008084: 2200         	movs	r2, #0x0
 8008086: 601a         	str	r2, [r3]
; 			tx_cb(dev, -ENETDOWN, cbs->tx[tx_idx].user_data);
 8008088: 6a7b         	ldr	r3, [r7, #0x24]
 800808a: 681a         	ldr	r2, [r3]
 800808c: 6afb         	ldr	r3, [r7, #0x2c]
 800808e: 00db         	lsls	r3, r3, #0x3
 8008090: 4413         	add	r3, r2
 8008092: 685a         	ldr	r2, [r3, #0x4]
 8008094: 693b         	ldr	r3, [r7, #0x10]
 8008096: f06f 0172    	mvn	r1, #0x72
 800809a: 6878         	ldr	r0, [r7, #0x4]
 800809c: 4798         	blx	r3
; 			k_sem_give(&data->tx_sem);
 800809e: 6a3b         	ldr	r3, [r7, #0x20]
 80080a0: 3324         	adds	r3, #0x24
 80080a2: 4618         	mov	r0, r3
 80080a4: f016 faf6    	bl	0x801e694 <k_sem_give>  @ imm = #0x165ec
; 	for (tx_idx = 0U; tx_idx < cbs->num_tx; tx_idx++) {
 80080a8: 6afb         	ldr	r3, [r7, #0x2c]
 80080aa: 3301         	adds	r3, #0x1
 80080ac: 62fb         	str	r3, [r7, #0x2c]
 80080ae: 6a7b         	ldr	r3, [r7, #0x24]
 80080b0: 7b1b         	ldrb	r3, [r3, #0xc]
 80080b2: 461a         	mov	r2, r3
 80080b4: 6afb         	ldr	r3, [r7, #0x2c]
 80080b6: 4293         	cmp	r3, r2
 80080b8: d3d5         	blo	0x8008066 <can_mcan_stop+0xea> @ imm = #-0x56
; 	return 0;
 80080ba: 2300         	movs	r3, #0x0
; }
 80080bc: 4618         	mov	r0, r3
 80080be: 3730         	adds	r7, #0x30
 80080c0: 46bd         	mov	sp, r7
 80080c2: bd80         	pop	{r7, pc}

080080c4 <$d>:
 80080c4: c0 06 00 24  	.word	0x240006c0
 80080c8: e8 ac 02 08  	.word	0x0802ace8
 80080cc: 04 ad 02 08  	.word	0x0802ad04

080080d0 <can_mcan_set_mode>:
; {
 80080d0: b590         	push	{r4, r7, lr}
 80080d2: b08f         	sub	sp, #0x3c
 80080d4: af04         	add	r7, sp, #0x10
 80080d6: 6078         	str	r0, [r7, #0x4]
 80080d8: 6039         	str	r1, [r7]
; 	can_mode_t supported = CAN_MODE_LOOPBACK | CAN_MODE_LISTENONLY;
 80080da: 2303         	movs	r3, #0x3
 80080dc: 623b         	str	r3, [r7, #0x20]
; 	struct can_mcan_data *data = dev->data;
 80080de: 687b         	ldr	r3, [r7, #0x4]
 80080e0: 691b         	ldr	r3, [r3, #0x10]
 80080e2: 61fb         	str	r3, [r7, #0x1c]
; 	if ((mode & ~(supported)) != 0U) {
 80080e4: 6a3b         	ldr	r3, [r7, #0x20]
 80080e6: 43da         	mvns	r2, r3
 80080e8: 683b         	ldr	r3, [r7]
 80080ea: 4013         	ands	r3, r2
 80080ec: 2b00         	cmp	r3, #0x0
 80080ee: d01e         	beq	0x800812e <can_mcan_set_mode+0x5e> @ imm = #0x3c
; 		LOG_ERR("unsupported mode: 0x%08x", mode);
 80080f0: 2303         	movs	r3, #0x3
 80080f2: 2b00         	cmp	r3, #0x0
 80080f4: d018         	beq	0x8008128 <can_mcan_set_mode+0x58> @ imm = #0x30
 80080f6: 2301         	movs	r3, #0x1
 80080f8: 76fb         	strb	r3, [r7, #0x1b]
 80080fa: 7efb         	ldrb	r3, [r7, #0x1b]
 80080fc: f083 0301    	eor	r3, r3, #0x1
 8008100: b2db         	uxtb	r3, r3
 8008102: 2b00         	cmp	r3, #0x0
 8008104: d110         	bne	0x8008128 <can_mcan_set_mode+0x58> @ imm = #0x20
 8008106: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8008214 <can_mcan_set_mode+0x144>
 8008108: 6819         	ldr	r1, [r3]
 800810a: 683b         	ldr	r3, [r7]
 800810c: 9303         	str	r3, [sp, #0xc]
 800810e: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8008218 <can_mcan_set_mode+0x148>
 8008110: 9302         	str	r3, [sp, #0x8]
 8008112: 2300         	movs	r3, #0x0
 8008114: 9301         	str	r3, [sp, #0x4]
 8008116: 2300         	movs	r3, #0x0
 8008118: 9300         	str	r3, [sp]
 800811a: 2300         	movs	r3, #0x0
 800811c: 2201         	movs	r2, #0x1
 800811e: 2000         	movs	r0, #0x0
 8008120: f016 fb47    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x1668e
 8008124: 2300         	movs	r3, #0x0
 8008126: 617b         	str	r3, [r7, #0x14]
; 		return -ENOTSUP;
 8008128: f06f 0385    	mvn	r3, #0x85
 800812c: e06d         	b	0x800820a <can_mcan_set_mode+0x13a> @ imm = #0xda
; 	if (data->common.started) {
 800812e: 69fb         	ldr	r3, [r7, #0x1c]
 8008130: 791b         	ldrb	r3, [r3, #0x4]
 8008132: 2b00         	cmp	r3, #0x0
 8008134: d002         	beq	0x800813c <can_mcan_set_mode+0x6c> @ imm = #0x4
; 		return -EBUSY;
 8008136: f06f 030f    	mvn	r3, #0xf
 800813a: e066         	b	0x800820a <can_mcan_set_mode+0x13a> @ imm = #0xcc
; 	k_mutex_lock(&data->lock, K_FOREVER);
 800813c: 69fb         	ldr	r3, [r7, #0x1c]
 800813e: f103 0410    	add.w	r4, r3, #0x10
 8008142: f04f 30ff    	mov.w	r0, #0xffffffff
 8008146: f04f 31ff    	mov.w	r1, #0xffffffff
 800814a: 4602         	mov	r2, r0
 800814c: 460b         	mov	r3, r1
 800814e: 4620         	mov	r0, r4
 8008150: f016 fa64    	bl	0x801e61c <k_mutex_lock> @ imm = #0x164c8
; 	err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &cccr);
 8008154: f107 0310    	add.w	r3, r7, #0x10
 8008158: 461a         	mov	r2, r3
 800815a: 2118         	movs	r1, #0x18
 800815c: 6878         	ldr	r0, [r7, #0x4]
 800815e: f7ff fd4f    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x562
 8008162: 6278         	str	r0, [r7, #0x24]
; 	if (err != 0) {
 8008164: 6a7b         	ldr	r3, [r7, #0x24]
 8008166: 2b00         	cmp	r3, #0x0
 8008168: d142         	bne	0x80081f0 <can_mcan_set_mode+0x120> @ imm = #0x84
; 	err = can_mcan_read_reg(dev, CAN_MCAN_TEST, &test);
 800816a: f107 030c    	add.w	r3, r7, #0xc
 800816e: 461a         	mov	r2, r3
 8008170: 2110         	movs	r1, #0x10
 8008172: 6878         	ldr	r0, [r7, #0x4]
 8008174: f7ff fd44    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x578
 8008178: 6278         	str	r0, [r7, #0x24]
; 	if (err != 0) {
 800817a: 6a7b         	ldr	r3, [r7, #0x24]
 800817c: 2b00         	cmp	r3, #0x0
 800817e: d139         	bne	0x80081f4 <can_mcan_set_mode+0x124> @ imm = #0x72
; 	if ((mode & CAN_MODE_LOOPBACK) != 0) {
 8008180: 683b         	ldr	r3, [r7]
 8008182: f003 0301    	and	r3, r3, #0x1
 8008186: 2b00         	cmp	r3, #0x0
 8008188: d008         	beq	0x800819c <can_mcan_set_mode+0xcc> @ imm = #0x10
; 		cccr |= CAN_MCAN_CCCR_TEST;
 800818a: 693b         	ldr	r3, [r7, #0x10]
 800818c: f043 0380    	orr	r3, r3, #0x80
 8008190: 613b         	str	r3, [r7, #0x10]
; 		test |= CAN_MCAN_TEST_LBCK;
 8008192: 68fb         	ldr	r3, [r7, #0xc]
 8008194: f043 0310    	orr	r3, r3, #0x10
 8008198: 60fb         	str	r3, [r7, #0xc]
 800819a: e003         	b	0x80081a4 <can_mcan_set_mode+0xd4> @ imm = #0x6
; 		cccr &= ~CAN_MCAN_CCCR_TEST;
 800819c: 693b         	ldr	r3, [r7, #0x10]
 800819e: f023 0380    	bic	r3, r3, #0x80
 80081a2: 613b         	str	r3, [r7, #0x10]
; 	if ((mode & CAN_MODE_LISTENONLY) != 0) {
 80081a4: 683b         	ldr	r3, [r7]
 80081a6: f003 0302    	and	r3, r3, #0x2
 80081aa: 2b00         	cmp	r3, #0x0
 80081ac: d004         	beq	0x80081b8 <can_mcan_set_mode+0xe8> @ imm = #0x8
; 		cccr |= CAN_MCAN_CCCR_MON;
 80081ae: 693b         	ldr	r3, [r7, #0x10]
 80081b0: f043 0320    	orr	r3, r3, #0x20
 80081b4: 613b         	str	r3, [r7, #0x10]
 80081b6: e003         	b	0x80081c0 <can_mcan_set_mode+0xf0> @ imm = #0x6
; 		cccr &= ~CAN_MCAN_CCCR_MON;
 80081b8: 693b         	ldr	r3, [r7, #0x10]
 80081ba: f023 0320    	bic	r3, r3, #0x20
 80081be: 613b         	str	r3, [r7, #0x10]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_CCCR, cccr);
 80081c0: 693b         	ldr	r3, [r7, #0x10]
 80081c2: 461a         	mov	r2, r3
 80081c4: 2118         	movs	r1, #0x18
 80081c6: 6878         	ldr	r0, [r7, #0x4]
 80081c8: f7ff fd56    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x554
 80081cc: 6278         	str	r0, [r7, #0x24]
; 	if (err != 0) {
 80081ce: 6a7b         	ldr	r3, [r7, #0x24]
 80081d0: 2b00         	cmp	r3, #0x0
 80081d2: d111         	bne	0x80081f8 <can_mcan_set_mode+0x128> @ imm = #0x22
; 	err = can_mcan_write_reg(dev, CAN_MCAN_TEST, test);
 80081d4: 68fb         	ldr	r3, [r7, #0xc]
 80081d6: 461a         	mov	r2, r3
 80081d8: 2110         	movs	r1, #0x10
 80081da: 6878         	ldr	r0, [r7, #0x4]
 80081dc: f7ff fd4c    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x568
 80081e0: 6278         	str	r0, [r7, #0x24]
; 	if (err != 0) {
 80081e2: 6a7b         	ldr	r3, [r7, #0x24]
 80081e4: 2b00         	cmp	r3, #0x0
 80081e6: d109         	bne	0x80081fc <can_mcan_set_mode+0x12c> @ imm = #0x12
; 	data->common.mode = mode;
 80081e8: 69fb         	ldr	r3, [r7, #0x1c]
 80081ea: 683a         	ldr	r2, [r7]
 80081ec: 601a         	str	r2, [r3]
 80081ee: e006         	b	0x80081fe <can_mcan_set_mode+0x12e> @ imm = #0xc
; 		goto unlock;
 80081f0: bf00         	nop
 80081f2: e004         	b	0x80081fe <can_mcan_set_mode+0x12e> @ imm = #0x8
; 		goto unlock;
 80081f4: bf00         	nop
 80081f6: e002         	b	0x80081fe <can_mcan_set_mode+0x12e> @ imm = #0x4
; 		goto unlock;
 80081f8: bf00         	nop
 80081fa: e000         	b	0x80081fe <can_mcan_set_mode+0x12e> @ imm = #0x0
; 		goto unlock;
 80081fc: bf00         	nop
; 	k_mutex_unlock(&data->lock);
 80081fe: 69fb         	ldr	r3, [r7, #0x1c]
 8008200: 3310         	adds	r3, #0x10
 8008202: 4618         	mov	r0, r3
 8008204: f016 fa1a    	bl	0x801e63c <k_mutex_unlock> @ imm = #0x16434
; 	return err;
 8008208: 6a7b         	ldr	r3, [r7, #0x24]
; }
 800820a: 4618         	mov	r0, r3
 800820c: 372c         	adds	r7, #0x2c
 800820e: 46bd         	mov	sp, r7
 8008210: bd90         	pop	{r4, r7, pc}
 8008212: bf00         	nop

08008214 <$d>:
 8008214: c0 06 00 24  	.word	0x240006c0
 8008218: 30 ad 02 08  	.word	0x0802ad30

0800821c <can_mcan_tx_event_handler>:
; {
 800821c: b580         	push	{r7, lr}
 800821e: b094         	sub	sp, #0x50
 8008220: af04         	add	r7, sp, #0x10
 8008222: 6078         	str	r0, [r7, #0x4]
; 	const struct can_mcan_config *config = dev->config;
 8008224: 687b         	ldr	r3, [r7, #0x4]
 8008226: 685b         	ldr	r3, [r3, #0x4]
 8008228: 63fb         	str	r3, [r7, #0x3c]
; 	const struct can_mcan_callbacks *cbs = config->callbacks;
 800822a: 6bfb         	ldr	r3, [r7, #0x3c]
 800822c: 699b         	ldr	r3, [r3, #0x18]
 800822e: 63bb         	str	r3, [r7, #0x38]
; 	struct can_mcan_data *data = dev->data;
 8008230: 687b         	ldr	r3, [r7, #0x4]
 8008232: 691b         	ldr	r3, [r3, #0x10]
 8008234: 637b         	str	r3, [r7, #0x34]
; 	err = can_mcan_read_reg(dev, CAN_MCAN_TXEFS, &txefs);
 8008236: f107 030c    	add.w	r3, r7, #0xc
 800823a: 461a         	mov	r2, r3
 800823c: 21f4         	movs	r1, #0xf4
 800823e: 6878         	ldr	r0, [r7, #0x4]
 8008240: f7ff fcde    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x644
 8008244: 6338         	str	r0, [r7, #0x30]
; 	if (err != 0) {
 8008246: 6b3b         	ldr	r3, [r7, #0x30]
 8008248: 2b00         	cmp	r3, #0x0
 800824a: d170         	bne	0x800832e <can_mcan_tx_event_handler+0x112> @ imm = #0xe0
; 	while ((txefs & CAN_MCAN_TXEFS_EFFL) != 0U) {
 800824c: e069         	b	0x8008322 <can_mcan_tx_event_handler+0x106> @ imm = #0xd2
; 		event_idx = FIELD_GET(CAN_MCAN_TXEFS_EFGI, txefs);
 800824e: 68fb         	ldr	r3, [r7, #0xc]
 8008250: f403 53f8    	and	r3, r3, #0x1f00
 8008254: 0a1b         	lsrs	r3, r3, #0x8
 8008256: 62fb         	str	r3, [r7, #0x2c]
; 					 config->mram_offsets[CAN_MCAN_MRAM_CFG_TX_EVENT_FIFO] +
 8008258: 6bfb         	ldr	r3, [r7, #0x3c]
 800825a: 8f1a         	ldrh	r2, [r3, #0x38]
; 		err = can_mcan_read_mram(dev,
 800825c: 6afb         	ldr	r3, [r7, #0x2c]
 800825e: b29b         	uxth	r3, r3
 8008260: 00db         	lsls	r3, r3, #0x3
 8008262: b29b         	uxth	r3, r3
 8008264: 4413         	add	r3, r2
 8008266: b299         	uxth	r1, r3
 8008268: f107 0210    	add.w	r2, r7, #0x10
 800826c: 2308         	movs	r3, #0x8
 800826e: 6878         	ldr	r0, [r7, #0x4]
 8008270: f016 fa3b    	bl	0x801e6ea <can_mcan_read_mram> @ imm = #0x16476
 8008274: 6338         	str	r0, [r7, #0x30]
; 		if (err != 0) {
 8008276: 6b3b         	ldr	r3, [r7, #0x30]
 8008278: 2b00         	cmp	r3, #0x0
 800827a: d01d         	beq	0x80082b8 <can_mcan_tx_event_handler+0x9c> @ imm = #0x3a
; 			LOG_ERR("failed to read tx event fifo (err %d)", err);
 800827c: 2303         	movs	r3, #0x3
 800827e: 2b00         	cmp	r3, #0x0
 8008280: d019         	beq	0x80082b6 <can_mcan_tx_event_handler+0x9a> @ imm = #0x32
 8008282: 2301         	movs	r3, #0x1
 8008284: 77fb         	strb	r3, [r7, #0x1f]
 8008286: 7ffb         	ldrb	r3, [r7, #0x1f]
 8008288: f083 0301    	eor	r3, r3, #0x1
 800828c: b2db         	uxtb	r3, r3
 800828e: 2b00         	cmp	r3, #0x0
 8008290: d111         	bne	0x80082b6 <can_mcan_tx_event_handler+0x9a> @ imm = #0x22
 8008292: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8008340 <can_mcan_tx_event_handler+0x124>
 8008294: 6819         	ldr	r1, [r3]
 8008296: 6b3b         	ldr	r3, [r7, #0x30]
 8008298: 9303         	str	r3, [sp, #0xc]
 800829a: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8008344 <can_mcan_tx_event_handler+0x128>
 800829c: 9302         	str	r3, [sp, #0x8]
 800829e: 2300         	movs	r3, #0x0
 80082a0: 9301         	str	r3, [sp, #0x4]
 80082a2: 2300         	movs	r3, #0x0
 80082a4: 9300         	str	r3, [sp]
 80082a6: 2300         	movs	r3, #0x0
 80082a8: 2201         	movs	r2, #0x1
 80082aa: 2000         	movs	r0, #0x0
 80082ac: f016 fa81    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x16502
 80082b0: 2300         	movs	r3, #0x0
 80082b2: 61bb         	str	r3, [r7, #0x18]
; 			return;
 80082b4: e040         	b	0x8008338 <can_mcan_tx_event_handler+0x11c> @ imm = #0x80
 80082b6: e03f         	b	0x8008338 <can_mcan_tx_event_handler+0x11c> @ imm = #0x7e
; 		tx_idx = tx_event.mm;
 80082b8: 7dfb         	ldrb	r3, [r7, #0x17]
 80082ba: 62bb         	str	r3, [r7, #0x28]
; 		err = can_mcan_write_reg(dev, CAN_MCAN_TXEFA, event_idx);
 80082bc: 6afa         	ldr	r2, [r7, #0x2c]
 80082be: 21f8         	movs	r1, #0xf8
 80082c0: 6878         	ldr	r0, [r7, #0x4]
 80082c2: f7ff fcd9    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x64e
 80082c6: 6338         	str	r0, [r7, #0x30]
; 		if (err != 0) {
 80082c8: 6b3b         	ldr	r3, [r7, #0x30]
 80082ca: 2b00         	cmp	r3, #0x0
 80082cc: d131         	bne	0x8008332 <can_mcan_tx_event_handler+0x116> @ imm = #0x62
; 		tx_cb = cbs->tx[tx_idx].function;
 80082ce: 6bbb         	ldr	r3, [r7, #0x38]
 80082d0: 681a         	ldr	r2, [r3]
 80082d2: 6abb         	ldr	r3, [r7, #0x28]
 80082d4: 00db         	lsls	r3, r3, #0x3
 80082d6: 4413         	add	r3, r2
 80082d8: 681b         	ldr	r3, [r3]
 80082da: 627b         	str	r3, [r7, #0x24]
; 		user_data = cbs->tx[tx_idx].user_data;
 80082dc: 6bbb         	ldr	r3, [r7, #0x38]
 80082de: 681a         	ldr	r2, [r3]
 80082e0: 6abb         	ldr	r3, [r7, #0x28]
 80082e2: 00db         	lsls	r3, r3, #0x3
 80082e4: 4413         	add	r3, r2
 80082e6: 685b         	ldr	r3, [r3, #0x4]
 80082e8: 623b         	str	r3, [r7, #0x20]
; 		cbs->tx[tx_idx].function = NULL;
 80082ea: 6bbb         	ldr	r3, [r7, #0x38]
 80082ec: 681a         	ldr	r2, [r3]
 80082ee: 6abb         	ldr	r3, [r7, #0x28]
 80082f0: 00db         	lsls	r3, r3, #0x3
 80082f2: 4413         	add	r3, r2
 80082f4: 2200         	movs	r2, #0x0
 80082f6: 601a         	str	r2, [r3]
; 		k_sem_give(&data->tx_sem);
 80082f8: 6b7b         	ldr	r3, [r7, #0x34]
 80082fa: 3324         	adds	r3, #0x24
 80082fc: 4618         	mov	r0, r3
 80082fe: f016 f9c9    	bl	0x801e694 <k_sem_give>  @ imm = #0x16392
; 		tx_cb(dev, 0, user_data);
 8008302: 6a7b         	ldr	r3, [r7, #0x24]
 8008304: 6a3a         	ldr	r2, [r7, #0x20]
 8008306: 2100         	movs	r1, #0x0
 8008308: 6878         	ldr	r0, [r7, #0x4]
 800830a: 4798         	blx	r3
; 		err = can_mcan_read_reg(dev, CAN_MCAN_TXEFS, &txefs);
 800830c: f107 030c    	add.w	r3, r7, #0xc
 8008310: 461a         	mov	r2, r3
 8008312: 21f4         	movs	r1, #0xf4
 8008314: 6878         	ldr	r0, [r7, #0x4]
 8008316: f7ff fc73    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x71a
 800831a: 6338         	str	r0, [r7, #0x30]
; 		if (err != 0) {
 800831c: 6b3b         	ldr	r3, [r7, #0x30]
 800831e: 2b00         	cmp	r3, #0x0
 8008320: d109         	bne	0x8008336 <can_mcan_tx_event_handler+0x11a> @ imm = #0x12
; 	while ((txefs & CAN_MCAN_TXEFS_EFFL) != 0U) {
 8008322: 68fb         	ldr	r3, [r7, #0xc]
 8008324: f003 033f    	and	r3, r3, #0x3f
 8008328: 2b00         	cmp	r3, #0x0
 800832a: d190         	bne	0x800824e <can_mcan_tx_event_handler+0x32> @ imm = #-0xe0
 800832c: e004         	b	0x8008338 <can_mcan_tx_event_handler+0x11c> @ imm = #0x8
; 		return;
 800832e: bf00         	nop
 8008330: e002         	b	0x8008338 <can_mcan_tx_event_handler+0x11c> @ imm = #0x4
; 			return;
 8008332: bf00         	nop
 8008334: e000         	b	0x8008338 <can_mcan_tx_event_handler+0x11c> @ imm = #0x0
; 			return;
 8008336: bf00         	nop
; }
 8008338: 3740         	adds	r7, #0x40
 800833a: 46bd         	mov	sp, r7
 800833c: bd80         	pop	{r7, pc}
 800833e: bf00         	nop

08008340 <$d>:
 8008340: c0 06 00 24  	.word	0x240006c0
 8008344: 4c ad 02 08  	.word	0x0802ad4c

08008348 <can_mcan_line_0_isr>:
; {
 8008348: b580         	push	{r7, lr}
 800834a: b090         	sub	sp, #0x40
 800834c: af04         	add	r7, sp, #0x10
 800834e: 6078         	str	r0, [r7, #0x4]
; 	const uint32_t events = CAN_MCAN_IR_BO | CAN_MCAN_IR_EP | CAN_MCAN_IR_EW |
 8008350: 4b56         	ldr	r3, [pc, #0x158]        @ 0x80084ac <can_mcan_line_0_isr+0x164>
 8008352: 62fb         	str	r3, [r7, #0x2c]
; 	struct can_mcan_data *data = dev->data;
 8008354: 687b         	ldr	r3, [r7, #0x4]
 8008356: 691b         	ldr	r3, [r3, #0x10]
 8008358: 62bb         	str	r3, [r7, #0x28]
; 	err = can_mcan_read_reg(dev, CAN_MCAN_IR, &ir);
 800835a: f107 0308    	add.w	r3, r7, #0x8
 800835e: 461a         	mov	r2, r3
 8008360: 2150         	movs	r1, #0x50
 8008362: 6878         	ldr	r0, [r7, #0x4]
 8008364: f7ff fc4c    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x768
 8008368: 6278         	str	r0, [r7, #0x24]
; 	if (err != 0) {
 800836a: 6a7b         	ldr	r3, [r7, #0x24]
 800836c: 2b00         	cmp	r3, #0x0
 800836e: f040 8094    	bne.w	0x800849a <can_mcan_line_0_isr+0x152> @ imm = #0x128
; 	while ((ir & events) != 0U) {
 8008372: e08b         	b	0x800848c <can_mcan_line_0_isr+0x144> @ imm = #0x116
; 		err = can_mcan_write_reg(dev, CAN_MCAN_IR, ir & events);
 8008374: 68ba         	ldr	r2, [r7, #0x8]
 8008376: 6afb         	ldr	r3, [r7, #0x2c]
 8008378: 4013         	ands	r3, r2
 800837a: 461a         	mov	r2, r3
 800837c: 2150         	movs	r1, #0x50
 800837e: 6878         	ldr	r0, [r7, #0x4]
 8008380: f7ff fc7a    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x70c
 8008384: 6278         	str	r0, [r7, #0x24]
; 		if (err != 0) {
 8008386: 6a7b         	ldr	r3, [r7, #0x24]
 8008388: 2b00         	cmp	r3, #0x0
 800838a: f040 8088    	bne.w	0x800849e <can_mcan_line_0_isr+0x156> @ imm = #0x110
; 		if ((ir & (CAN_MCAN_IR_BO | CAN_MCAN_IR_EP | CAN_MCAN_IR_EW)) != 0U) {
 800838e: 68bb         	ldr	r3, [r7, #0x8]
 8008390: f003 7360    	and	r3, r3, #0x3800000
 8008394: 2b00         	cmp	r3, #0x0
 8008396: d002         	beq	0x800839e <can_mcan_line_0_isr+0x56> @ imm = #0x4
; 			can_mcan_state_change_handler(dev);
 8008398: 6878         	ldr	r0, [r7, #0x4]
 800839a: f016 fb25    	bl	0x801e9e8 <can_mcan_state_change_handler> @ imm = #0x1664a
; 		if ((ir & CAN_MCAN_IR_TEFN) != 0U) {
 800839e: 68bb         	ldr	r3, [r7, #0x8]
 80083a0: f403 5380    	and	r3, r3, #0x1000
 80083a4: 2b00         	cmp	r3, #0x0
 80083a6: d002         	beq	0x80083ae <can_mcan_line_0_isr+0x66> @ imm = #0x4
; 			can_mcan_tx_event_handler(dev);
 80083a8: 6878         	ldr	r0, [r7, #0x4]
 80083aa: f7ff ff37    	bl	0x800821c <can_mcan_tx_event_handler> @ imm = #-0x192
; 		if ((ir & CAN_MCAN_IR_TEFL) != 0U) {
 80083ae: 68bb         	ldr	r3, [r7, #0x8]
 80083b0: f403 4300    	and	r3, r3, #0x8000
 80083b4: 2b00         	cmp	r3, #0x0
 80083b6: d020         	beq	0x80083fa <can_mcan_line_0_isr+0xb2> @ imm = #0x40
; 			LOG_ERR("TX FIFO element lost");
 80083b8: 2303         	movs	r3, #0x3
 80083ba: 2b00         	cmp	r3, #0x0
 80083bc: d018         	beq	0x80083f0 <can_mcan_line_0_isr+0xa8> @ imm = #0x30
 80083be: 2301         	movs	r3, #0x1
 80083c0: f887 3023    	strb.w	r3, [r7, #0x23]
 80083c4: f897 3023    	ldrb.w	r3, [r7, #0x23]
 80083c8: f083 0301    	eor	r3, r3, #0x1
 80083cc: b2db         	uxtb	r3, r3
 80083ce: 2b00         	cmp	r3, #0x0
 80083d0: d10e         	bne	0x80083f0 <can_mcan_line_0_isr+0xa8> @ imm = #0x1c
 80083d2: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x80084b0 <can_mcan_line_0_isr+0x168>
 80083d4: 6819         	ldr	r1, [r3]
 80083d6: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x80084b4 <can_mcan_line_0_isr+0x16c>
 80083d8: 9302         	str	r3, [sp, #0x8]
 80083da: 2300         	movs	r3, #0x0
 80083dc: 9301         	str	r3, [sp, #0x4]
 80083de: 2300         	movs	r3, #0x0
 80083e0: 9300         	str	r3, [sp]
 80083e2: 2300         	movs	r3, #0x0
 80083e4: 2201         	movs	r2, #0x1
 80083e6: 2000         	movs	r0, #0x0
 80083e8: f016 f9e3    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x163c6
 80083ec: 2300         	movs	r3, #0x0
 80083ee: 61fb         	str	r3, [r7, #0x1c]
; 			k_sem_give(&data->tx_sem);
 80083f0: 6abb         	ldr	r3, [r7, #0x28]
 80083f2: 3324         	adds	r3, #0x24
 80083f4: 4618         	mov	r0, r3
 80083f6: f016 f94d    	bl	0x801e694 <k_sem_give>  @ imm = #0x1629a
; 		if ((ir & CAN_MCAN_IR_ARA) != 0U) {
 80083fa: 68bb         	ldr	r3, [r7, #0x8]
 80083fc: f003 5300    	and	r3, r3, #0x20000000
 8008400: 2b00         	cmp	r3, #0x0
 8008402: d019         	beq	0x8008438 <can_mcan_line_0_isr+0xf0> @ imm = #0x32
; 			LOG_ERR("Access to reserved address");
 8008404: 2303         	movs	r3, #0x3
 8008406: 2b00         	cmp	r3, #0x0
 8008408: d016         	beq	0x8008438 <can_mcan_line_0_isr+0xf0> @ imm = #0x2c
 800840a: 2301         	movs	r3, #0x1
 800840c: 76fb         	strb	r3, [r7, #0x1b]
 800840e: 7efb         	ldrb	r3, [r7, #0x1b]
 8008410: f083 0301    	eor	r3, r3, #0x1
 8008414: b2db         	uxtb	r3, r3
 8008416: 2b00         	cmp	r3, #0x0
 8008418: d10e         	bne	0x8008438 <can_mcan_line_0_isr+0xf0> @ imm = #0x1c
 800841a: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80084b0 <can_mcan_line_0_isr+0x168>
 800841c: 6819         	ldr	r1, [r3]
 800841e: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80084b8 <can_mcan_line_0_isr+0x170>
 8008420: 9302         	str	r3, [sp, #0x8]
 8008422: 2300         	movs	r3, #0x0
 8008424: 9301         	str	r3, [sp, #0x4]
 8008426: 2300         	movs	r3, #0x0
 8008428: 9300         	str	r3, [sp]
 800842a: 2300         	movs	r3, #0x0
 800842c: 2201         	movs	r2, #0x1
 800842e: 2000         	movs	r0, #0x0
 8008430: f016 f9bf    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x1637e
 8008434: 2300         	movs	r3, #0x0
 8008436: 617b         	str	r3, [r7, #0x14]
; 		if ((ir & CAN_MCAN_IR_MRAF) != 0U) {
 8008438: 68bb         	ldr	r3, [r7, #0x8]
 800843a: f403 3300    	and	r3, r3, #0x20000
 800843e: 2b00         	cmp	r3, #0x0
 8008440: d019         	beq	0x8008476 <can_mcan_line_0_isr+0x12e> @ imm = #0x32
; 			LOG_ERR("Message RAM access failure");
 8008442: 2303         	movs	r3, #0x3
 8008444: 2b00         	cmp	r3, #0x0
 8008446: d016         	beq	0x8008476 <can_mcan_line_0_isr+0x12e> @ imm = #0x2c
 8008448: 2301         	movs	r3, #0x1
 800844a: 74fb         	strb	r3, [r7, #0x13]
 800844c: 7cfb         	ldrb	r3, [r7, #0x13]
 800844e: f083 0301    	eor	r3, r3, #0x1
 8008452: b2db         	uxtb	r3, r3
 8008454: 2b00         	cmp	r3, #0x0
 8008456: d10e         	bne	0x8008476 <can_mcan_line_0_isr+0x12e> @ imm = #0x1c
 8008458: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80084b0 <can_mcan_line_0_isr+0x168>
 800845a: 6819         	ldr	r1, [r3]
 800845c: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80084bc <can_mcan_line_0_isr+0x174>
 800845e: 9302         	str	r3, [sp, #0x8]
 8008460: 2300         	movs	r3, #0x0
 8008462: 9301         	str	r3, [sp, #0x4]
 8008464: 2300         	movs	r3, #0x0
 8008466: 9300         	str	r3, [sp]
 8008468: 2300         	movs	r3, #0x0
 800846a: 2201         	movs	r2, #0x1
 800846c: 2000         	movs	r0, #0x0
 800846e: f016 f9a0    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x16340
 8008472: 2300         	movs	r3, #0x0
 8008474: 60fb         	str	r3, [r7, #0xc]
; 		err = can_mcan_read_reg(dev, CAN_MCAN_IR, &ir);
 8008476: f107 0308    	add.w	r3, r7, #0x8
 800847a: 461a         	mov	r2, r3
 800847c: 2150         	movs	r1, #0x50
 800847e: 6878         	ldr	r0, [r7, #0x4]
 8008480: f7ff fbbe    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x884
 8008484: 6278         	str	r0, [r7, #0x24]
; 		if (err != 0) {
 8008486: 6a7b         	ldr	r3, [r7, #0x24]
 8008488: 2b00         	cmp	r3, #0x0
 800848a: d10a         	bne	0x80084a2 <can_mcan_line_0_isr+0x15a> @ imm = #0x14
; 	while ((ir & events) != 0U) {
 800848c: 68ba         	ldr	r2, [r7, #0x8]
 800848e: 6afb         	ldr	r3, [r7, #0x2c]
 8008490: 4013         	ands	r3, r2
 8008492: 2b00         	cmp	r3, #0x0
 8008494: f47f af6e    	bne.w	0x8008374 <can_mcan_line_0_isr+0x2c> @ imm = #-0x124
 8008498: e004         	b	0x80084a4 <can_mcan_line_0_isr+0x15c> @ imm = #0x8
; 		return;
 800849a: bf00         	nop
 800849c: e002         	b	0x80084a4 <can_mcan_line_0_isr+0x15c> @ imm = #0x4
; 			return;
 800849e: bf00         	nop
 80084a0: e000         	b	0x80084a4 <can_mcan_line_0_isr+0x15c> @ imm = #0x0
; 			return;
 80084a2: bf00         	nop
; }
 80084a4: 3730         	adds	r7, #0x30
 80084a6: 46bd         	mov	sp, r7
 80084a8: bd80         	pop	{r7, pc}
 80084aa: bf00         	nop

080084ac <$d>:
 80084ac: 00 90 82 3b  	.word	0x3b829000
 80084b0: c0 06 00 24  	.word	0x240006c0
 80084b4: 74 ad 02 08  	.word	0x0802ad74
 80084b8: 8c ad 02 08  	.word	0x0802ad8c
 80084bc: a8 ad 02 08  	.word	0x0802ada8

080084c0 <can_mcan_get_message>:
; {
 80084c0: b580         	push	{r7, lr}
 80084c2: b0a6         	sub	sp, #0x98
 80084c4: af06         	add	r7, sp, #0x18
 80084c6: 60f8         	str	r0, [r7, #0xc]
 80084c8: 4608         	mov	r0, r1
 80084ca: 4611         	mov	r1, r2
 80084cc: 461a         	mov	r2, r3
 80084ce: 4603         	mov	r3, r0
 80084d0: 817b         	strh	r3, [r7, #0xa]
 80084d2: 460b         	mov	r3, r1
 80084d4: 813b         	strh	r3, [r7, #0x8]
 80084d6: 4613         	mov	r3, r2
 80084d8: 80fb         	strh	r3, [r7, #0x6]
; 	const struct can_mcan_config *config = dev->config;
 80084da: 68fb         	ldr	r3, [r7, #0xc]
 80084dc: 685b         	ldr	r3, [r3, #0x4]
 80084de: 67fb         	str	r3, [r7, #0x7c]
; 	const struct can_mcan_callbacks *cbs = config->callbacks;
 80084e0: 6ffb         	ldr	r3, [r7, #0x7c]
 80084e2: 699b         	ldr	r3, [r3, #0x18]
 80084e4: 67bb         	str	r3, [r7, #0x78]
; 	struct can_frame frame = {0};
 80084e6: f107 0318    	add.w	r3, r7, #0x18
 80084ea: 2200         	movs	r2, #0x0
 80084ec: 601a         	str	r2, [r3]
 80084ee: 605a         	str	r2, [r3, #0x4]
 80084f0: 609a         	str	r2, [r3, #0x8]
 80084f2: 60da         	str	r2, [r3, #0xc]
; 	err = can_mcan_read_reg(dev, fifo_status_reg, &fifo_status);
 80084f4: f107 0214    	add.w	r2, r7, #0x14
 80084f8: 893b         	ldrh	r3, [r7, #0x8]
 80084fa: 4619         	mov	r1, r3
 80084fc: 68f8         	ldr	r0, [r7, #0xc]
 80084fe: f7ff fb7f    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x902
 8008502: 66f8         	str	r0, [r7, #0x6c]
; 	if (err != 0) {
 8008504: 6efb         	ldr	r3, [r7, #0x6c]
 8008506: 2b00         	cmp	r3, #0x0
 8008508: f040 81b2    	bne.w	0x8008870 <can_mcan_get_message+0x3b0> @ imm = #0x364
; 	while (FIELD_GET(CAN_MCAN_RXF0S_F0FL, fifo_status) != 0U) {
 800850c: e1a9         	b	0x8008862 <can_mcan_get_message+0x3a2> @ imm = #0x352
; 		get_idx = FIELD_GET(CAN_MCAN_RXF0S_F0GI, fifo_status);
 800850e: 697b         	ldr	r3, [r7, #0x14]
 8008510: f403 537c    	and	r3, r3, #0x3f00
 8008514: 0a1b         	lsrs	r3, r3, #0x8
 8008516: 66bb         	str	r3, [r7, #0x68]
; 		err = can_mcan_read_mram(dev, fifo_offset + get_idx *
 8008518: 6ebb         	ldr	r3, [r7, #0x68]
 800851a: b29b         	uxth	r3, r3
 800851c: 461a         	mov	r2, r3
 800851e: 00d2         	lsls	r2, r2, #0x3
 8008520: 4413         	add	r3, r2
 8008522: 00db         	lsls	r3, r3, #0x3
 8008524: b29a         	uxth	r2, r3
 8008526: 897b         	ldrh	r3, [r7, #0xa]
 8008528: 4413         	add	r3, r2
 800852a: b299         	uxth	r1, r3
 800852c: f107 0228    	add.w	r2, r7, #0x28
 8008530: 2308         	movs	r3, #0x8
 8008532: 68f8         	ldr	r0, [r7, #0xc]
 8008534: f016 f8d9    	bl	0x801e6ea <can_mcan_read_mram> @ imm = #0x161b2
 8008538: 66f8         	str	r0, [r7, #0x6c]
; 		if (err != 0) {
 800853a: 6efb         	ldr	r3, [r7, #0x6c]
 800853c: 2b00         	cmp	r3, #0x0
 800853e: d01f         	beq	0x8008580 <can_mcan_get_message+0xc0> @ imm = #0x3e
; 			LOG_ERR("failed to read Rx FIFO header (err %d)", err);
 8008540: 2303         	movs	r3, #0x3
 8008542: 2b00         	cmp	r3, #0x0
 8008544: d01b         	beq	0x800857e <can_mcan_get_message+0xbe> @ imm = #0x36
 8008546: 2301         	movs	r3, #0x1
 8008548: f887 3037    	strb.w	r3, [r7, #0x37]
 800854c: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8008550: f083 0301    	eor	r3, r3, #0x1
 8008554: b2db         	uxtb	r3, r3
 8008556: 2b00         	cmp	r3, #0x0
 8008558: d111         	bne	0x800857e <can_mcan_get_message+0xbe> @ imm = #0x22
 800855a: 4ba3         	ldr	r3, [pc, #0x28c]        @ 0x80087e8 <can_mcan_get_message+0x328>
 800855c: 6819         	ldr	r1, [r3]
 800855e: 6efb         	ldr	r3, [r7, #0x6c]
 8008560: 9303         	str	r3, [sp, #0xc]
 8008562: 4ba2         	ldr	r3, [pc, #0x288]        @ 0x80087ec <can_mcan_get_message+0x32c>
 8008564: 9302         	str	r3, [sp, #0x8]
 8008566: 2300         	movs	r3, #0x0
 8008568: 9301         	str	r3, [sp, #0x4]
 800856a: 2300         	movs	r3, #0x0
 800856c: 9300         	str	r3, [sp]
 800856e: 2300         	movs	r3, #0x0
 8008570: 2201         	movs	r2, #0x1
 8008572: 2000         	movs	r0, #0x0
 8008574: f016 f91d    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x1623a
 8008578: 2300         	movs	r3, #0x0
 800857a: 633b         	str	r3, [r7, #0x30]
; 			return;
 800857c: e17d         	b	0x800887a <can_mcan_get_message+0x3ba> @ imm = #0x2fa
 800857e: e17c         	b	0x800887a <can_mcan_get_message+0x3ba> @ imm = #0x2f8
; 		frame.dlc = hdr.dlc;
 8008580: f897 302e    	ldrb.w	r3, [r7, #0x2e]
 8008584: f3c3 0303    	ubfx	r3, r3, #0x0, #0x4
 8008588: b2db         	uxtb	r3, r3
 800858a: 773b         	strb	r3, [r7, #0x1c]
; 		if (hdr.rtr != 0) {
 800858c: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8008590: f003 0320    	and	r3, r3, #0x20
 8008594: b2db         	uxtb	r3, r3
 8008596: 2b00         	cmp	r3, #0x0
 8008598: d004         	beq	0x80085a4 <can_mcan_get_message+0xe4> @ imm = #0x8
; 			frame.flags |= CAN_FRAME_RTR;
 800859a: 7f7b         	ldrb	r3, [r7, #0x1d]
 800859c: f043 0302    	orr	r3, r3, #0x2
 80085a0: b2db         	uxtb	r3, r3
 80085a2: 777b         	strb	r3, [r7, #0x1d]
; 		if (hdr.fdf != 0) {
 80085a4: f897 302e    	ldrb.w	r3, [r7, #0x2e]
 80085a8: f003 0320    	and	r3, r3, #0x20
 80085ac: b2db         	uxtb	r3, r3
 80085ae: 2b00         	cmp	r3, #0x0
 80085b0: d004         	beq	0x80085bc <can_mcan_get_message+0xfc> @ imm = #0x8
; 			frame.flags |= CAN_FRAME_FDF;
 80085b2: 7f7b         	ldrb	r3, [r7, #0x1d]
 80085b4: f043 0304    	orr	r3, r3, #0x4
 80085b8: b2db         	uxtb	r3, r3
 80085ba: 777b         	strb	r3, [r7, #0x1d]
; 		if (hdr.brs != 0) {
 80085bc: f897 302e    	ldrb.w	r3, [r7, #0x2e]
 80085c0: f003 0310    	and	r3, r3, #0x10
 80085c4: b2db         	uxtb	r3, r3
 80085c6: 2b00         	cmp	r3, #0x0
 80085c8: d004         	beq	0x80085d4 <can_mcan_get_message+0x114> @ imm = #0x8
; 			frame.flags |= CAN_FRAME_BRS;
 80085ca: 7f7b         	ldrb	r3, [r7, #0x1d]
 80085cc: f043 0308    	orr	r3, r3, #0x8
 80085d0: b2db         	uxtb	r3, r3
 80085d2: 777b         	strb	r3, [r7, #0x1d]
; 		if (hdr.esi != 0) {
 80085d4: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80085d8: f023 037f    	bic	r3, r3, #0x7f
 80085dc: b2db         	uxtb	r3, r3
 80085de: 2b00         	cmp	r3, #0x0
 80085e0: d004         	beq	0x80085ec <can_mcan_get_message+0x12c> @ imm = #0x8
; 			frame.flags |= CAN_FRAME_ESI;
 80085e2: 7f7b         	ldrb	r3, [r7, #0x1d]
 80085e4: f043 0310    	orr	r3, r3, #0x10
 80085e8: b2db         	uxtb	r3, r3
 80085ea: 777b         	strb	r3, [r7, #0x1d]
; 		filt_idx = hdr.fidx;
 80085ec: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 80085f0: f3c3 0306    	ubfx	r3, r3, #0x0, #0x7
 80085f4: b2db         	uxtb	r3, r3
 80085f6: 667b         	str	r3, [r7, #0x64]
; 		if (hdr.xtd != 0) {
 80085f8: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80085fc: f003 0340    	and	r3, r3, #0x40
 8008600: b2db         	uxtb	r3, r3
 8008602: 2b00         	cmp	r3, #0x0
 8008604: d009         	beq	0x800861a <can_mcan_get_message+0x15a> @ imm = #0x12
; 			frame.id = hdr.ext_id;
 8008606: 6abb         	ldr	r3, [r7, #0x28]
 8008608: f3c3 031c    	ubfx	r3, r3, #0x0, #0x1d
 800860c: 61bb         	str	r3, [r7, #0x18]
; 			frame.flags |= CAN_FRAME_IDE;
 800860e: 7f7b         	ldrb	r3, [r7, #0x1d]
 8008610: f043 0301    	orr	r3, r3, #0x1
 8008614: b2db         	uxtb	r3, r3
 8008616: 777b         	strb	r3, [r7, #0x1d]
 8008618: e004         	b	0x8008624 <can_mcan_get_message+0x164> @ imm = #0x8
; 			frame.id = hdr.std_id;
 800861a: 8d7b         	ldrh	r3, [r7, #0x2a]
 800861c: f3c3 038a    	ubfx	r3, r3, #0x2, #0xb
 8008620: b29b         	uxth	r3, r3
 8008622: 61bb         	str	r3, [r7, #0x18]
; 		data_length = can_dlc_to_bytes(frame.dlc);
 8008624: 7f3b         	ldrb	r3, [r7, #0x1c]
 8008626: 4618         	mov	r0, r3
 8008628: f7ff fad4    	bl	0x8007bd4 <can_dlc_to_bytes> @ imm = #-0xa58
 800862c: 4603         	mov	r3, r0
 800862e: 663b         	str	r3, [r7, #0x60]
; 		if (data_length <= sizeof(frame.data)) {
 8008630: 6e3b         	ldr	r3, [r7, #0x60]
 8008632: 2b08         	cmp	r3, #0x8
 8008634: f200 80e4    	bhi.w	0x8008800 <can_mcan_get_message+0x340> @ imm = #0x1c8
; 			if ((frame.flags & CAN_FRAME_RTR) == 0U && data_length != 0U) {
 8008638: 7f7b         	ldrb	r3, [r7, #0x1d]
 800863a: f003 0302    	and	r3, r3, #0x2
 800863e: 2b00         	cmp	r3, #0x0
 8008640: d13e         	bne	0x80086c0 <can_mcan_get_message+0x200> @ imm = #0x7c
 8008642: 6e3b         	ldr	r3, [r7, #0x60]
 8008644: 2b00         	cmp	r3, #0x0
 8008646: d03b         	beq	0x80086c0 <can_mcan_get_message+0x200> @ imm = #0x76
; 				err = can_mcan_read_mram(dev, fifo_offset + get_idx *
 8008648: 6ebb         	ldr	r3, [r7, #0x68]
 800864a: b29b         	uxth	r3, r3
 800864c: 461a         	mov	r2, r3
 800864e: 00d2         	lsls	r2, r2, #0x3
 8008650: 4413         	add	r3, r2
 8008652: 00db         	lsls	r3, r3, #0x3
 8008654: b29a         	uxth	r2, r3
 8008656: 897b         	ldrh	r3, [r7, #0xa]
 8008658: 4413         	add	r3, r2
 800865a: b29b         	uxth	r3, r3
 800865c: 3308         	adds	r3, #0x8
 800865e: b299         	uxth	r1, r3
; 							 ROUND_UP(data_length, sizeof(uint32_t)));
 8008660: 6e3b         	ldr	r3, [r7, #0x60]
 8008662: 3303         	adds	r3, #0x3
; 				err = can_mcan_read_mram(dev, fifo_offset + get_idx *
 8008664: f023 0003    	bic	r0, r3, #0x3
 8008668: f107 0318    	add.w	r3, r7, #0x18
 800866c: f103 0208    	add.w	r2, r3, #0x8
 8008670: 4603         	mov	r3, r0
 8008672: 68f8         	ldr	r0, [r7, #0xc]
 8008674: f016 f839    	bl	0x801e6ea <can_mcan_read_mram> @ imm = #0x16072
 8008678: 66f8         	str	r0, [r7, #0x6c]
; 				if (err != 0) {
 800867a: 6efb         	ldr	r3, [r7, #0x6c]
 800867c: 2b00         	cmp	r3, #0x0
 800867e: d01f         	beq	0x80086c0 <can_mcan_get_message+0x200> @ imm = #0x3e
; 					LOG_ERR("failed to read Rx FIFO data (err %d)", err);
 8008680: 2303         	movs	r3, #0x3
 8008682: 2b00         	cmp	r3, #0x0
 8008684: d01b         	beq	0x80086be <can_mcan_get_message+0x1fe> @ imm = #0x36
 8008686: 2301         	movs	r3, #0x1
 8008688: f887 3057    	strb.w	r3, [r7, #0x57]
 800868c: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8008690: f083 0301    	eor	r3, r3, #0x1
 8008694: b2db         	uxtb	r3, r3
 8008696: 2b00         	cmp	r3, #0x0
 8008698: d111         	bne	0x80086be <can_mcan_get_message+0x1fe> @ imm = #0x22
 800869a: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x80087e8 <can_mcan_get_message+0x328>
 800869c: 6819         	ldr	r1, [r3]
 800869e: 6efb         	ldr	r3, [r7, #0x6c]
 80086a0: 9303         	str	r3, [sp, #0xc]
 80086a2: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x80087f0 <can_mcan_get_message+0x330>
 80086a4: 9302         	str	r3, [sp, #0x8]
 80086a6: 2300         	movs	r3, #0x0
 80086a8: 9301         	str	r3, [sp, #0x4]
 80086aa: 2300         	movs	r3, #0x0
 80086ac: 9300         	str	r3, [sp]
 80086ae: 2300         	movs	r3, #0x0
 80086b0: 2201         	movs	r2, #0x1
 80086b2: 2000         	movs	r0, #0x0
 80086b4: f016 f87d    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x160fa
 80086b8: 2300         	movs	r3, #0x0
 80086ba: 653b         	str	r3, [r7, #0x50]
; 					return;
 80086bc: e0dd         	b	0x800887a <can_mcan_get_message+0x3ba> @ imm = #0x1ba
 80086be: e0dc         	b	0x800887a <can_mcan_get_message+0x3ba> @ imm = #0x1b8
; 			if ((frame.flags & CAN_FRAME_IDE) != 0) {
 80086c0: 7f7b         	ldrb	r3, [r7, #0x1d]
 80086c2: f003 0301    	and	r3, r3, #0x1
 80086c6: 2b00         	cmp	r3, #0x0
 80086c8: d034         	beq	0x8008734 <can_mcan_get_message+0x274> @ imm = #0x68
; 				LOG_DBG("Frame on filter %d, ID: 0x%x",
 80086ca: 2303         	movs	r3, #0x3
 80086cc: 2b03         	cmp	r3, #0x3
 80086ce: d922         	bls	0x8008716 <can_mcan_get_message+0x256> @ imm = #0x44
 80086d0: 2301         	movs	r3, #0x1
 80086d2: f887 3047    	strb.w	r3, [r7, #0x47]
 80086d6: f897 3047    	ldrb.w	r3, [r7, #0x47]
 80086da: f083 0301    	eor	r3, r3, #0x1
 80086de: b2db         	uxtb	r3, r3
 80086e0: 2b00         	cmp	r3, #0x0
 80086e2: d118         	bne	0x8008716 <can_mcan_get_message+0x256> @ imm = #0x30
 80086e4: 4b40         	ldr	r3, [pc, #0x100]        @ 0x80087e8 <can_mcan_get_message+0x328>
 80086e6: 6819         	ldr	r1, [r3]
 80086e8: 6fbb         	ldr	r3, [r7, #0x78]
 80086ea: 7b5b         	ldrb	r3, [r3, #0xd]
 80086ec: 461a         	mov	r2, r3
 80086ee: 6e7b         	ldr	r3, [r7, #0x64]
 80086f0: 4413         	add	r3, r2
 80086f2: 69ba         	ldr	r2, [r7, #0x18]
 80086f4: 9205         	str	r2, [sp, #0x14]
 80086f6: 9304         	str	r3, [sp, #0x10]
 80086f8: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x80087f4 <can_mcan_get_message+0x334>
 80086fa: 9303         	str	r3, [sp, #0xc]
 80086fc: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x80087f8 <can_mcan_get_message+0x338>
 80086fe: 9302         	str	r3, [sp, #0x8]
 8008700: 2308         	movs	r3, #0x8
 8008702: 9301         	str	r3, [sp, #0x4]
 8008704: 2300         	movs	r3, #0x0
 8008706: 9300         	str	r3, [sp]
 8008708: 2300         	movs	r3, #0x0
 800870a: 2204         	movs	r2, #0x4
 800870c: 2000         	movs	r0, #0x0
 800870e: f016 f850    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x160a0
 8008712: 2300         	movs	r3, #0x0
 8008714: 643b         	str	r3, [r7, #0x40]
; 				cb = cbs->ext[filt_idx].function;
 8008716: 6fbb         	ldr	r3, [r7, #0x78]
 8008718: 689a         	ldr	r2, [r3, #0x8]
 800871a: 6e7b         	ldr	r3, [r7, #0x64]
 800871c: 00db         	lsls	r3, r3, #0x3
 800871e: 4413         	add	r3, r2
 8008720: 681b         	ldr	r3, [r3]
 8008722: 677b         	str	r3, [r7, #0x74]
; 				user_data = cbs->ext[filt_idx].user_data;
 8008724: 6fbb         	ldr	r3, [r7, #0x78]
 8008726: 689a         	ldr	r2, [r3, #0x8]
 8008728: 6e7b         	ldr	r3, [r7, #0x64]
 800872a: 00db         	lsls	r3, r3, #0x3
 800872c: 4413         	add	r3, r2
 800872e: 685b         	ldr	r3, [r3, #0x4]
 8008730: 673b         	str	r3, [r7, #0x70]
 8008732: e02f         	b	0x8008794 <can_mcan_get_message+0x2d4> @ imm = #0x5e
; 				LOG_DBG("Frame on filter %d, ID: 0x%x", filt_idx, frame.id);
 8008734: 2303         	movs	r3, #0x3
 8008736: 2b03         	cmp	r3, #0x3
 8008738: d91e         	bls	0x8008778 <can_mcan_get_message+0x2b8> @ imm = #0x3c
 800873a: 2301         	movs	r3, #0x1
 800873c: f887 304f    	strb.w	r3, [r7, #0x4f]
 8008740: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 8008744: f083 0301    	eor	r3, r3, #0x1
 8008748: b2db         	uxtb	r3, r3
 800874a: 2b00         	cmp	r3, #0x0
 800874c: d114         	bne	0x8008778 <can_mcan_get_message+0x2b8> @ imm = #0x28
 800874e: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80087e8 <can_mcan_get_message+0x328>
 8008750: 6819         	ldr	r1, [r3]
 8008752: 69bb         	ldr	r3, [r7, #0x18]
 8008754: 9305         	str	r3, [sp, #0x14]
 8008756: 6e7b         	ldr	r3, [r7, #0x64]
 8008758: 9304         	str	r3, [sp, #0x10]
 800875a: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80087f4 <can_mcan_get_message+0x334>
 800875c: 9303         	str	r3, [sp, #0xc]
 800875e: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80087f8 <can_mcan_get_message+0x338>
 8008760: 9302         	str	r3, [sp, #0x8]
 8008762: 2308         	movs	r3, #0x8
 8008764: 9301         	str	r3, [sp, #0x4]
 8008766: 2300         	movs	r3, #0x0
 8008768: 9300         	str	r3, [sp]
 800876a: 2300         	movs	r3, #0x0
 800876c: 2204         	movs	r2, #0x4
 800876e: 2000         	movs	r0, #0x0
 8008770: f016 f81f    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x1603e
 8008774: 2300         	movs	r3, #0x0
 8008776: 64bb         	str	r3, [r7, #0x48]
; 				cb = cbs->std[filt_idx].function;
 8008778: 6fbb         	ldr	r3, [r7, #0x78]
 800877a: 685a         	ldr	r2, [r3, #0x4]
 800877c: 6e7b         	ldr	r3, [r7, #0x64]
 800877e: 00db         	lsls	r3, r3, #0x3
 8008780: 4413         	add	r3, r2
 8008782: 681b         	ldr	r3, [r3]
 8008784: 677b         	str	r3, [r7, #0x74]
; 				user_data = cbs->std[filt_idx].user_data;
 8008786: 6fbb         	ldr	r3, [r7, #0x78]
 8008788: 685a         	ldr	r2, [r3, #0x4]
 800878a: 6e7b         	ldr	r3, [r7, #0x64]
 800878c: 00db         	lsls	r3, r3, #0x3
 800878e: 4413         	add	r3, r2
 8008790: 685b         	ldr	r3, [r3, #0x4]
 8008792: 673b         	str	r3, [r7, #0x70]
; 			if (cb) {
 8008794: 6f7b         	ldr	r3, [r7, #0x74]
 8008796: 2b00         	cmp	r3, #0x0
 8008798: d006         	beq	0x80087a8 <can_mcan_get_message+0x2e8> @ imm = #0xc
; 				cb(dev, &frame, user_data);
 800879a: f107 0118    	add.w	r1, r7, #0x18
 800879e: 6f7b         	ldr	r3, [r7, #0x74]
 80087a0: 6f3a         	ldr	r2, [r7, #0x70]
 80087a2: 68f8         	ldr	r0, [r7, #0xc]
 80087a4: 4798         	blx	r3
 80087a6: e047         	b	0x8008838 <can_mcan_get_message+0x378> @ imm = #0x8e
; 				LOG_DBG("cb missing");
 80087a8: 2303         	movs	r3, #0x3
 80087aa: 2b03         	cmp	r3, #0x3
 80087ac: d944         	bls	0x8008838 <can_mcan_get_message+0x378> @ imm = #0x88
 80087ae: 2301         	movs	r3, #0x1
 80087b0: f887 303f    	strb.w	r3, [r7, #0x3f]
 80087b4: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 80087b8: f083 0301    	eor	r3, r3, #0x1
 80087bc: b2db         	uxtb	r3, r3
 80087be: 2b00         	cmp	r3, #0x0
 80087c0: d13a         	bne	0x8008838 <can_mcan_get_message+0x378> @ imm = #0x74
 80087c2: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80087e8 <can_mcan_get_message+0x328>
 80087c4: 6819         	ldr	r1, [r3]
 80087c6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80087f4 <can_mcan_get_message+0x334>
 80087c8: 9303         	str	r3, [sp, #0xc]
 80087ca: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80087fc <can_mcan_get_message+0x33c>
 80087cc: 9302         	str	r3, [sp, #0x8]
 80087ce: 2308         	movs	r3, #0x8
 80087d0: 9301         	str	r3, [sp, #0x4]
 80087d2: 2300         	movs	r3, #0x0
 80087d4: 9300         	str	r3, [sp]
 80087d6: 2300         	movs	r3, #0x0
 80087d8: 2204         	movs	r2, #0x4
 80087da: 2000         	movs	r0, #0x0
 80087dc: f015 ffe9    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15fd2
 80087e0: 2300         	movs	r3, #0x0
 80087e2: 63bb         	str	r3, [r7, #0x38]
 80087e4: e028         	b	0x8008838 <can_mcan_get_message+0x378> @ imm = #0x50
 80087e6: bf00         	nop

080087e8 <$d>:
 80087e8: c0 06 00 24  	.word	0x240006c0
 80087ec: c4 ad 02 08  	.word	0x0802adc4
 80087f0: ec ad 02 08  	.word	0x0802adec
 80087f4: 78 ce 02 08  	.word	0x0802ce78
 80087f8: 14 ae 02 08  	.word	0x0802ae14
 80087fc: 38 ae 02 08  	.word	0x0802ae38

08008800 <$t>:
; 			LOG_ERR("Frame is too big");
 8008800: 2303         	movs	r3, #0x3
 8008802: 2b00         	cmp	r3, #0x0
 8008804: d018         	beq	0x8008838 <can_mcan_get_message+0x378> @ imm = #0x30
 8008806: 2301         	movs	r3, #0x1
 8008808: f887 305f    	strb.w	r3, [r7, #0x5f]
 800880c: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 8008810: f083 0301    	eor	r3, r3, #0x1
 8008814: b2db         	uxtb	r3, r3
 8008816: 2b00         	cmp	r3, #0x0
 8008818: d10e         	bne	0x8008838 <can_mcan_get_message+0x378> @ imm = #0x1c
 800881a: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8008880 <can_mcan_get_message+0x3c0>
 800881c: 6819         	ldr	r1, [r3]
 800881e: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8008884 <can_mcan_get_message+0x3c4>
 8008820: 9302         	str	r3, [sp, #0x8]
 8008822: 2300         	movs	r3, #0x0
 8008824: 9301         	str	r3, [sp, #0x4]
 8008826: 2300         	movs	r3, #0x0
 8008828: 9300         	str	r3, [sp]
 800882a: 2300         	movs	r3, #0x0
 800882c: 2201         	movs	r2, #0x1
 800882e: 2000         	movs	r0, #0x0
 8008830: f015 ffbf    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15f7e
 8008834: 2300         	movs	r3, #0x0
 8008836: 65bb         	str	r3, [r7, #0x58]
; 		err = can_mcan_write_reg(dev, fifo_ack_reg, get_idx);
 8008838: 88fb         	ldrh	r3, [r7, #0x6]
 800883a: 6eba         	ldr	r2, [r7, #0x68]
 800883c: 4619         	mov	r1, r3
 800883e: 68f8         	ldr	r0, [r7, #0xc]
 8008840: f7ff fa1a    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0xbcc
 8008844: 66f8         	str	r0, [r7, #0x6c]
; 		if (err != 0) {
 8008846: 6efb         	ldr	r3, [r7, #0x6c]
 8008848: 2b00         	cmp	r3, #0x0
 800884a: d113         	bne	0x8008874 <can_mcan_get_message+0x3b4> @ imm = #0x26
; 		err = can_mcan_read_reg(dev, fifo_status_reg, &fifo_status);
 800884c: f107 0214    	add.w	r2, r7, #0x14
 8008850: 893b         	ldrh	r3, [r7, #0x8]
 8008852: 4619         	mov	r1, r3
 8008854: 68f8         	ldr	r0, [r7, #0xc]
 8008856: f7ff f9d3    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0xc5a
 800885a: 66f8         	str	r0, [r7, #0x6c]
; 		if (err != 0) {
 800885c: 6efb         	ldr	r3, [r7, #0x6c]
 800885e: 2b00         	cmp	r3, #0x0
 8008860: d10a         	bne	0x8008878 <can_mcan_get_message+0x3b8> @ imm = #0x14
; 	while (FIELD_GET(CAN_MCAN_RXF0S_F0FL, fifo_status) != 0U) {
 8008862: 697b         	ldr	r3, [r7, #0x14]
 8008864: f003 037f    	and	r3, r3, #0x7f
 8008868: 2b00         	cmp	r3, #0x0
 800886a: f47f ae50    	bne.w	0x800850e <can_mcan_get_message+0x4e> @ imm = #-0x360
 800886e: e004         	b	0x800887a <can_mcan_get_message+0x3ba> @ imm = #0x8
; 		return;
 8008870: bf00         	nop
 8008872: e002         	b	0x800887a <can_mcan_get_message+0x3ba> @ imm = #0x4
; 			return;
 8008874: bf00         	nop
 8008876: e000         	b	0x800887a <can_mcan_get_message+0x3ba> @ imm = #0x0
; 			return;
 8008878: bf00         	nop
; }
 800887a: 3780         	adds	r7, #0x80
 800887c: 46bd         	mov	sp, r7
 800887e: bd80         	pop	{r7, pc}

08008880 <$d>:
 8008880: c0 06 00 24  	.word	0x240006c0
 8008884: 48 ae 02 08  	.word	0x0802ae48

08008888 <can_mcan_line_1_isr>:
; {
 8008888: b580         	push	{r7, lr}
 800888a: b098         	sub	sp, #0x60
 800888c: af06         	add	r7, sp, #0x18
 800888e: 6078         	str	r0, [r7, #0x4]
; 	const struct can_mcan_config *config = dev->config;
 8008890: 687b         	ldr	r3, [r7, #0x4]
 8008892: 685b         	ldr	r3, [r3, #0x4]
 8008894: 647b         	str	r3, [r7, #0x44]
; 	const uint32_t events =
 8008896: 2399         	movs	r3, #0x99
 8008898: 643b         	str	r3, [r7, #0x40]
; 	err = can_mcan_read_reg(dev, CAN_MCAN_IR, &ir);
 800889a: f107 0308    	add.w	r3, r7, #0x8
 800889e: 461a         	mov	r2, r3
 80088a0: 2150         	movs	r1, #0x50
 80088a2: 6878         	ldr	r0, [r7, #0x4]
 80088a4: f7ff f9ac    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0xca8
 80088a8: 63f8         	str	r0, [r7, #0x3c]
; 	if (err != 0) {
 80088aa: 6bfb         	ldr	r3, [r7, #0x3c]
 80088ac: 2b00         	cmp	r3, #0x0
 80088ae: f040 80fd    	bne.w	0x8008aac <can_mcan_line_1_isr+0x224> @ imm = #0x1fa
; 	if ((ir & CAN_MCAN_IR_PEA) != 0U) {
 80088b2: 68bb         	ldr	r3, [r7, #0x8]
 80088b4: f003 6300    	and	r3, r3, #0x8000000
 80088b8: 2b00         	cmp	r3, #0x0
 80088ba: d01f         	beq	0x80088fc <can_mcan_line_1_isr+0x74> @ imm = #0x3e
; 		LOG_DBG("Protocol error in arbitration phase: ir: 0x%x", ir);
 80088bc: 2303         	movs	r3, #0x3
 80088be: 2b03         	cmp	r3, #0x3
 80088c0: d91c         	bls	0x80088fc <can_mcan_line_1_isr+0x74> @ imm = #0x38
 80088c2: 2301         	movs	r3, #0x1
 80088c4: f887 303b    	strb.w	r3, [r7, #0x3b]
 80088c8: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 80088cc: f083 0301    	eor	r3, r3, #0x1
 80088d0: b2db         	uxtb	r3, r3
 80088d2: 2b00         	cmp	r3, #0x0
 80088d4: d112         	bne	0x80088fc <can_mcan_line_1_isr+0x74> @ imm = #0x24
 80088d6: 4b79         	ldr	r3, [pc, #0x1e4]        @ 0x8008abc <can_mcan_line_1_isr+0x234>
 80088d8: 6819         	ldr	r1, [r3]
 80088da: 68bb         	ldr	r3, [r7, #0x8]
 80088dc: 9304         	str	r3, [sp, #0x10]
 80088de: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8008ac0 <can_mcan_line_1_isr+0x238>
 80088e0: 9303         	str	r3, [sp, #0xc]
 80088e2: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8008ac4 <can_mcan_line_1_isr+0x23c>
 80088e4: 9302         	str	r3, [sp, #0x8]
 80088e6: 2308         	movs	r3, #0x8
 80088e8: 9301         	str	r3, [sp, #0x4]
 80088ea: 2300         	movs	r3, #0x0
 80088ec: 9300         	str	r3, [sp]
 80088ee: 2300         	movs	r3, #0x0
 80088f0: 2204         	movs	r2, #0x4
 80088f2: 2000         	movs	r0, #0x0
 80088f4: f015 ff5d    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15eba
 80088f8: 2300         	movs	r3, #0x0
 80088fa: 637b         	str	r3, [r7, #0x34]
; 	if ((ir & CAN_MCAN_IR_PED) != 0U) {
 80088fc: 68bb         	ldr	r3, [r7, #0x8]
 80088fe: f003 5380    	and	r3, r3, #0x10000000
 8008902: 2b00         	cmp	r3, #0x0
 8008904: f000 80cb    	beq.w	0x8008a9e <can_mcan_line_1_isr+0x216> @ imm = #0x196
; 		LOG_DBG("Protocol error in data phase: ir: 0x%x", ir);
 8008908: 2303         	movs	r3, #0x3
 800890a: 2b03         	cmp	r3, #0x3
 800890c: d91c         	bls	0x8008948 <can_mcan_line_1_isr+0xc0> @ imm = #0x38
 800890e: 2301         	movs	r3, #0x1
 8008910: f887 3033    	strb.w	r3, [r7, #0x33]
 8008914: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8008918: f083 0301    	eor	r3, r3, #0x1
 800891c: b2db         	uxtb	r3, r3
 800891e: 2b00         	cmp	r3, #0x0
 8008920: d112         	bne	0x8008948 <can_mcan_line_1_isr+0xc0> @ imm = #0x24
 8008922: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8008abc <can_mcan_line_1_isr+0x234>
 8008924: 6819         	ldr	r1, [r3]
 8008926: 68bb         	ldr	r3, [r7, #0x8]
 8008928: 9304         	str	r3, [sp, #0x10]
 800892a: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8008ac0 <can_mcan_line_1_isr+0x238>
 800892c: 9303         	str	r3, [sp, #0xc]
 800892e: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8008ac8 <can_mcan_line_1_isr+0x240>
 8008930: 9302         	str	r3, [sp, #0x8]
 8008932: 2308         	movs	r3, #0x8
 8008934: 9301         	str	r3, [sp, #0x4]
 8008936: 2300         	movs	r3, #0x0
 8008938: 9300         	str	r3, [sp]
 800893a: 2300         	movs	r3, #0x0
 800893c: 2204         	movs	r2, #0x4
 800893e: 2000         	movs	r0, #0x0
 8008940: f015 ff37    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15e6e
 8008944: 2300         	movs	r3, #0x0
 8008946: 62fb         	str	r3, [r7, #0x2c]
; 	while ((ir & events) != 0U) {
 8008948: e0a9         	b	0x8008a9e <can_mcan_line_1_isr+0x216> @ imm = #0x152
; 		err = can_mcan_write_reg(dev, CAN_MCAN_IR, events & ir);
 800894a: 68ba         	ldr	r2, [r7, #0x8]
 800894c: 6c3b         	ldr	r3, [r7, #0x40]
 800894e: 4013         	ands	r3, r2
 8008950: 461a         	mov	r2, r3
 8008952: 2150         	movs	r1, #0x50
 8008954: 6878         	ldr	r0, [r7, #0x4]
 8008956: f7ff f98f    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0xce2
 800895a: 63f8         	str	r0, [r7, #0x3c]
; 		if (err != 0) {
 800895c: 6bfb         	ldr	r3, [r7, #0x3c]
 800895e: 2b00         	cmp	r3, #0x0
 8008960: f040 80a6    	bne.w	0x8008ab0 <can_mcan_line_1_isr+0x228> @ imm = #0x14c
; 		if ((ir & CAN_MCAN_IR_RF0N) != 0U) {
 8008964: 68bb         	ldr	r3, [r7, #0x8]
 8008966: f003 0301    	and	r3, r3, #0x1
 800896a: 2b00         	cmp	r3, #0x0
 800896c: d024         	beq	0x80089b8 <can_mcan_line_1_isr+0x130> @ imm = #0x48
; 			LOG_DBG("RX FIFO0 INT");
 800896e: 2303         	movs	r3, #0x3
 8008970: 2b03         	cmp	r3, #0x3
 8008972: d91a         	bls	0x80089aa <can_mcan_line_1_isr+0x122> @ imm = #0x34
 8008974: 2301         	movs	r3, #0x1
 8008976: f887 302b    	strb.w	r3, [r7, #0x2b]
 800897a: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800897e: f083 0301    	eor	r3, r3, #0x1
 8008982: b2db         	uxtb	r3, r3
 8008984: 2b00         	cmp	r3, #0x0
 8008986: d110         	bne	0x80089aa <can_mcan_line_1_isr+0x122> @ imm = #0x20
 8008988: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x8008abc <can_mcan_line_1_isr+0x234>
 800898a: 6819         	ldr	r1, [r3]
 800898c: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x8008ac0 <can_mcan_line_1_isr+0x238>
 800898e: 9303         	str	r3, [sp, #0xc]
 8008990: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8008acc <can_mcan_line_1_isr+0x244>
 8008992: 9302         	str	r3, [sp, #0x8]
 8008994: 2308         	movs	r3, #0x8
 8008996: 9301         	str	r3, [sp, #0x4]
 8008998: 2300         	movs	r3, #0x0
 800899a: 9300         	str	r3, [sp]
 800899c: 2300         	movs	r3, #0x0
 800899e: 2204         	movs	r2, #0x4
 80089a0: 2000         	movs	r0, #0x0
 80089a2: f015 ff06    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15e0c
 80089a6: 2300         	movs	r3, #0x0
 80089a8: 627b         	str	r3, [r7, #0x24]
; 			can_mcan_get_message(dev, config->mram_offsets[CAN_MCAN_MRAM_CFG_RX_FIFO0],
 80089aa: 6c7b         	ldr	r3, [r7, #0x44]
 80089ac: 8e59         	ldrh	r1, [r3, #0x32]
 80089ae: 23a8         	movs	r3, #0xa8
 80089b0: 22a4         	movs	r2, #0xa4
 80089b2: 6878         	ldr	r0, [r7, #0x4]
 80089b4: f7ff fd84    	bl	0x80084c0 <can_mcan_get_message> @ imm = #-0x4f8
; 		if ((ir & CAN_MCAN_IR_RF1N) != 0U) {
 80089b8: 68bb         	ldr	r3, [r7, #0x8]
 80089ba: f003 0310    	and	r3, r3, #0x10
 80089be: 2b00         	cmp	r3, #0x0
 80089c0: d024         	beq	0x8008a0c <can_mcan_line_1_isr+0x184> @ imm = #0x48
; 			LOG_DBG("RX FIFO1 INT");
 80089c2: 2303         	movs	r3, #0x3
 80089c4: 2b03         	cmp	r3, #0x3
 80089c6: d91a         	bls	0x80089fe <can_mcan_line_1_isr+0x176> @ imm = #0x34
 80089c8: 2301         	movs	r3, #0x1
 80089ca: f887 3023    	strb.w	r3, [r7, #0x23]
 80089ce: f897 3023    	ldrb.w	r3, [r7, #0x23]
 80089d2: f083 0301    	eor	r3, r3, #0x1
 80089d6: b2db         	uxtb	r3, r3
 80089d8: 2b00         	cmp	r3, #0x0
 80089da: d110         	bne	0x80089fe <can_mcan_line_1_isr+0x176> @ imm = #0x20
 80089dc: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8008abc <can_mcan_line_1_isr+0x234>
 80089de: 6819         	ldr	r1, [r3]
 80089e0: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8008ac0 <can_mcan_line_1_isr+0x238>
 80089e2: 9303         	str	r3, [sp, #0xc]
 80089e4: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8008ad0 <can_mcan_line_1_isr+0x248>
 80089e6: 9302         	str	r3, [sp, #0x8]
 80089e8: 2308         	movs	r3, #0x8
 80089ea: 9301         	str	r3, [sp, #0x4]
 80089ec: 2300         	movs	r3, #0x0
 80089ee: 9300         	str	r3, [sp]
 80089f0: 2300         	movs	r3, #0x0
 80089f2: 2204         	movs	r2, #0x4
 80089f4: 2000         	movs	r0, #0x0
 80089f6: f015 fedc    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15db8
 80089fa: 2300         	movs	r3, #0x0
 80089fc: 61fb         	str	r3, [r7, #0x1c]
; 			can_mcan_get_message(dev, config->mram_offsets[CAN_MCAN_MRAM_CFG_RX_FIFO1],
 80089fe: 6c7b         	ldr	r3, [r7, #0x44]
 8008a00: 8e99         	ldrh	r1, [r3, #0x34]
 8008a02: 23b8         	movs	r3, #0xb8
 8008a04: 22b4         	movs	r2, #0xb4
 8008a06: 6878         	ldr	r0, [r7, #0x4]
 8008a08: f7ff fd5a    	bl	0x80084c0 <can_mcan_get_message> @ imm = #-0x54c
; 		if ((ir & CAN_MCAN_IR_RF0L) != 0U) {
 8008a0c: 68bb         	ldr	r3, [r7, #0x8]
 8008a0e: f003 0308    	and	r3, r3, #0x8
 8008a12: 2b00         	cmp	r3, #0x0
 8008a14: d019         	beq	0x8008a4a <can_mcan_line_1_isr+0x1c2> @ imm = #0x32
; 			LOG_ERR("Message lost on FIFO0");
 8008a16: 2303         	movs	r3, #0x3
 8008a18: 2b00         	cmp	r3, #0x0
 8008a1a: d016         	beq	0x8008a4a <can_mcan_line_1_isr+0x1c2> @ imm = #0x2c
 8008a1c: 2301         	movs	r3, #0x1
 8008a1e: 76fb         	strb	r3, [r7, #0x1b]
 8008a20: 7efb         	ldrb	r3, [r7, #0x1b]
 8008a22: f083 0301    	eor	r3, r3, #0x1
 8008a26: b2db         	uxtb	r3, r3
 8008a28: 2b00         	cmp	r3, #0x0
 8008a2a: d10e         	bne	0x8008a4a <can_mcan_line_1_isr+0x1c2> @ imm = #0x1c
 8008a2c: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8008abc <can_mcan_line_1_isr+0x234>
 8008a2e: 6819         	ldr	r1, [r3]
 8008a30: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8008ad4 <can_mcan_line_1_isr+0x24c>
 8008a32: 9302         	str	r3, [sp, #0x8]
 8008a34: 2300         	movs	r3, #0x0
 8008a36: 9301         	str	r3, [sp, #0x4]
 8008a38: 2300         	movs	r3, #0x0
 8008a3a: 9300         	str	r3, [sp]
 8008a3c: 2300         	movs	r3, #0x0
 8008a3e: 2201         	movs	r2, #0x1
 8008a40: 2000         	movs	r0, #0x0
 8008a42: f015 feb6    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15d6c
 8008a46: 2300         	movs	r3, #0x0
 8008a48: 617b         	str	r3, [r7, #0x14]
; 		if ((ir & CAN_MCAN_IR_RF1L) != 0U) {
 8008a4a: 68bb         	ldr	r3, [r7, #0x8]
 8008a4c: f003 0380    	and	r3, r3, #0x80
 8008a50: 2b00         	cmp	r3, #0x0
 8008a52: d019         	beq	0x8008a88 <can_mcan_line_1_isr+0x200> @ imm = #0x32
; 			LOG_ERR("Message lost on FIFO1");
 8008a54: 2303         	movs	r3, #0x3
 8008a56: 2b00         	cmp	r3, #0x0
 8008a58: d016         	beq	0x8008a88 <can_mcan_line_1_isr+0x200> @ imm = #0x2c
 8008a5a: 2301         	movs	r3, #0x1
 8008a5c: 74fb         	strb	r3, [r7, #0x13]
 8008a5e: 7cfb         	ldrb	r3, [r7, #0x13]
 8008a60: f083 0301    	eor	r3, r3, #0x1
 8008a64: b2db         	uxtb	r3, r3
 8008a66: 2b00         	cmp	r3, #0x0
 8008a68: d10e         	bne	0x8008a88 <can_mcan_line_1_isr+0x200> @ imm = #0x1c
 8008a6a: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8008abc <can_mcan_line_1_isr+0x234>
 8008a6c: 6819         	ldr	r1, [r3]
 8008a6e: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8008ad8 <can_mcan_line_1_isr+0x250>
 8008a70: 9302         	str	r3, [sp, #0x8]
 8008a72: 2300         	movs	r3, #0x0
 8008a74: 9301         	str	r3, [sp, #0x4]
 8008a76: 2300         	movs	r3, #0x0
 8008a78: 9300         	str	r3, [sp]
 8008a7a: 2300         	movs	r3, #0x0
 8008a7c: 2201         	movs	r2, #0x1
 8008a7e: 2000         	movs	r0, #0x0
 8008a80: f015 fe97    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15d2e
 8008a84: 2300         	movs	r3, #0x0
 8008a86: 60fb         	str	r3, [r7, #0xc]
; 		err = can_mcan_read_reg(dev, CAN_MCAN_IR, &ir);
 8008a88: f107 0308    	add.w	r3, r7, #0x8
 8008a8c: 461a         	mov	r2, r3
 8008a8e: 2150         	movs	r1, #0x50
 8008a90: 6878         	ldr	r0, [r7, #0x4]
 8008a92: f7ff f8b5    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0xe96
 8008a96: 63f8         	str	r0, [r7, #0x3c]
; 		if (err != 0) {
 8008a98: 6bfb         	ldr	r3, [r7, #0x3c]
 8008a9a: 2b00         	cmp	r3, #0x0
 8008a9c: d10a         	bne	0x8008ab4 <can_mcan_line_1_isr+0x22c> @ imm = #0x14
; 	while ((ir & events) != 0U) {
 8008a9e: 68ba         	ldr	r2, [r7, #0x8]
 8008aa0: 6c3b         	ldr	r3, [r7, #0x40]
 8008aa2: 4013         	ands	r3, r2
 8008aa4: 2b00         	cmp	r3, #0x0
 8008aa6: f47f af50    	bne.w	0x800894a <can_mcan_line_1_isr+0xc2> @ imm = #-0x160
 8008aaa: e004         	b	0x8008ab6 <can_mcan_line_1_isr+0x22e> @ imm = #0x8
; 		return;
 8008aac: bf00         	nop
 8008aae: e002         	b	0x8008ab6 <can_mcan_line_1_isr+0x22e> @ imm = #0x4
; 			return;
 8008ab0: bf00         	nop
 8008ab2: e000         	b	0x8008ab6 <can_mcan_line_1_isr+0x22e> @ imm = #0x0
; 			return;
 8008ab4: bf00         	nop
; }
 8008ab6: 3748         	adds	r7, #0x48
 8008ab8: 46bd         	mov	sp, r7
 8008aba: bd80         	pop	{r7, pc}

08008abc <$d>:
 8008abc: c0 06 00 24  	.word	0x240006c0
 8008ac0: a0 ce 02 08  	.word	0x0802cea0
 8008ac4: 5c ae 02 08  	.word	0x0802ae5c
 8008ac8: 90 ae 02 08  	.word	0x0802ae90
 8008acc: bc ae 02 08  	.word	0x0802aebc
 8008ad0: d0 ae 02 08  	.word	0x0802aed0
 8008ad4: e4 ae 02 08  	.word	0x0802aee4
 8008ad8: fc ae 02 08  	.word	0x0802aefc

08008adc <can_mcan_send>:
; {
 8008adc: b5b0         	push	{r4, r5, r7, lr}
 8008ade: b0a6         	sub	sp, #0x98
 8008ae0: af0a         	add	r7, sp, #0x28
 8008ae2: 60f8         	str	r0, [r7, #0xc]
 8008ae4: 60b9         	str	r1, [r7, #0x8]
 8008ae6: e9c7 2300    	strd	r2, r3, [r7]
; 	const struct can_mcan_config *config = dev->config;
 8008aea: 68fb         	ldr	r3, [r7, #0xc]
 8008aec: 685b         	ldr	r3, [r3, #0x4]
 8008aee: 653b         	str	r3, [r7, #0x50]
; 	const struct can_mcan_callbacks *cbs = config->callbacks;
 8008af0: 6d3b         	ldr	r3, [r7, #0x50]
 8008af2: 699b         	ldr	r3, [r3, #0x18]
 8008af4: 64fb         	str	r3, [r7, #0x4c]
; 	struct can_mcan_data *data = dev->data;
 8008af6: 68fb         	ldr	r3, [r7, #0xc]
 8008af8: 691b         	ldr	r3, [r3, #0x10]
 8008afa: 64bb         	str	r3, [r7, #0x48]
; 	size_t data_length = can_dlc_to_bytes(frame->dlc);
 8008afc: 68bb         	ldr	r3, [r7, #0x8]
 8008afe: 791b         	ldrb	r3, [r3, #0x4]
 8008b00: 4618         	mov	r0, r3
 8008b02: f7ff f867    	bl	0x8007bd4 <can_dlc_to_bytes> @ imm = #-0xf32
 8008b06: 4603         	mov	r3, r0
 8008b08: 657b         	str	r3, [r7, #0x54]
; 	struct can_mcan_tx_buffer_hdr tx_hdr = {
 8008b0a: f107 0318    	add.w	r3, r7, #0x18
 8008b0e: 2200         	movs	r2, #0x0
 8008b10: 601a         	str	r2, [r3]
 8008b12: 605a         	str	r2, [r3, #0x4]
; 		.rtr = (frame->flags & CAN_FRAME_RTR) != 0U ? 1U : 0U,
 8008b14: 68bb         	ldr	r3, [r7, #0x8]
 8008b16: 795b         	ldrb	r3, [r3, #0x5]
 8008b18: 085b         	lsrs	r3, r3, #0x1
 8008b1a: f003 0301    	and	r3, r3, #0x1
 8008b1e: b2da         	uxtb	r2, r3
; 	struct can_mcan_tx_buffer_hdr tx_hdr = {
 8008b20: 7efb         	ldrb	r3, [r7, #0x1b]
 8008b22: f362 1345    	bfi	r3, r2, #5, #1
 8008b26: 76fb         	strb	r3, [r7, #0x1b]
; 		.xtd = (frame->flags & CAN_FRAME_IDE) != 0U ? 1U : 0U,
 8008b28: 68bb         	ldr	r3, [r7, #0x8]
 8008b2a: 795b         	ldrb	r3, [r3, #0x5]
 8008b2c: f003 0301    	and	r3, r3, #0x1
 8008b30: b2da         	uxtb	r2, r3
; 	struct can_mcan_tx_buffer_hdr tx_hdr = {
 8008b32: 7efb         	ldrb	r3, [r7, #0x1b]
 8008b34: f362 1386    	bfi	r3, r2, #6, #1
 8008b38: 76fb         	strb	r3, [r7, #0x1b]
; 		.dlc = frame->dlc,
 8008b3a: 68bb         	ldr	r3, [r7, #0x8]
 8008b3c: 791b         	ldrb	r3, [r3, #0x4]
 8008b3e: f003 030f    	and	r3, r3, #0xf
 8008b42: b2da         	uxtb	r2, r3
; 	struct can_mcan_tx_buffer_hdr tx_hdr = {
 8008b44: 7fbb         	ldrb	r3, [r7, #0x1e]
 8008b46: f362 0303    	bfi	r3, r2, #0, #4
 8008b4a: 77bb         	strb	r3, [r7, #0x1e]
 8008b4c: 7fbb         	ldrb	r3, [r7, #0x1e]
 8008b4e: f043 0380    	orr	r3, r3, #0x80
 8008b52: 77bb         	strb	r3, [r7, #0x1e]
; 	uint32_t put_idx = -1;
 8008b54: f04f 33ff    	mov.w	r3, #0xffffffff
 8008b58: 65bb         	str	r3, [r7, #0x58]
; 	LOG_DBG("Sending %zu bytes. Id: 0x%x, ID type: %s %s %s %s", data_length, frame->id,
 8008b5a: 2303         	movs	r3, #0x3
 8008b5c: 2b03         	cmp	r3, #0x3
 8008b5e: d948         	bls	0x8008bf2 <can_mcan_send+0x116> @ imm = #0x90
 8008b60: 2301         	movs	r3, #0x1
 8008b62: f887 305e    	strb.w	r3, [r7, #0x5e]
 8008b66: f897 305e    	ldrb.w	r3, [r7, #0x5e]
 8008b6a: f083 0301    	eor	r3, r3, #0x1
 8008b6e: b2db         	uxtb	r3, r3
 8008b70: 2b00         	cmp	r3, #0x0
 8008b72: d13e         	bne	0x8008bf2 <can_mcan_send+0x116> @ imm = #0x7c
 8008b74: 4b9f         	ldr	r3, [pc, #0x27c]        @ 0x8008df4 <can_mcan_send+0x318>
 8008b76: 681d         	ldr	r5, [r3]
 8008b78: 68bb         	ldr	r3, [r7, #0x8]
 8008b7a: 681b         	ldr	r3, [r3]
 8008b7c: 68ba         	ldr	r2, [r7, #0x8]
 8008b7e: 7952         	ldrb	r2, [r2, #0x5]
 8008b80: f002 0201    	and	r2, r2, #0x1
 8008b84: 2a00         	cmp	r2, #0x0
 8008b86: d001         	beq	0x8008b8c <can_mcan_send+0xb0> @ imm = #0x2
 8008b88: 4a9b         	ldr	r2, [pc, #0x26c]        @ 0x8008df8 <can_mcan_send+0x31c>
 8008b8a: e000         	b	0x8008b8e <can_mcan_send+0xb2> @ imm = #0x0
 8008b8c: 4a9b         	ldr	r2, [pc, #0x26c]        @ 0x8008dfc <can_mcan_send+0x320>
 8008b8e: 68b9         	ldr	r1, [r7, #0x8]
 8008b90: 7949         	ldrb	r1, [r1, #0x5]
 8008b92: f001 0102    	and	r1, r1, #0x2
 8008b96: 2900         	cmp	r1, #0x0
 8008b98: d001         	beq	0x8008b9e <can_mcan_send+0xc2> @ imm = #0x2
 8008b9a: 4999         	ldr	r1, [pc, #0x264]        @ 0x8008e00 <can_mcan_send+0x324>
 8008b9c: e000         	b	0x8008ba0 <can_mcan_send+0xc4> @ imm = #0x0
 8008b9e: 4999         	ldr	r1, [pc, #0x264]        @ 0x8008e04 <can_mcan_send+0x328>
 8008ba0: 68b8         	ldr	r0, [r7, #0x8]
 8008ba2: 7940         	ldrb	r0, [r0, #0x5]
 8008ba4: f000 0004    	and	r0, r0, #0x4
 8008ba8: 2800         	cmp	r0, #0x0
 8008baa: d001         	beq	0x8008bb0 <can_mcan_send+0xd4> @ imm = #0x2
 8008bac: 4896         	ldr	r0, [pc, #0x258]        @ 0x8008e08 <can_mcan_send+0x32c>
 8008bae: e000         	b	0x8008bb2 <can_mcan_send+0xd6> @ imm = #0x0
 8008bb0: 4894         	ldr	r0, [pc, #0x250]        @ 0x8008e04 <can_mcan_send+0x328>
 8008bb2: 68bc         	ldr	r4, [r7, #0x8]
 8008bb4: 7964         	ldrb	r4, [r4, #0x5]
 8008bb6: f004 0408    	and	r4, r4, #0x8
 8008bba: 2c00         	cmp	r4, #0x0
 8008bbc: d001         	beq	0x8008bc2 <can_mcan_send+0xe6> @ imm = #0x2
 8008bbe: 4c93         	ldr	r4, [pc, #0x24c]        @ 0x8008e0c <can_mcan_send+0x330>
 8008bc0: e000         	b	0x8008bc4 <can_mcan_send+0xe8> @ imm = #0x0
 8008bc2: 4c90         	ldr	r4, [pc, #0x240]        @ 0x8008e04 <can_mcan_send+0x328>
 8008bc4: 9409         	str	r4, [sp, #0x24]
 8008bc6: 9008         	str	r0, [sp, #0x20]
 8008bc8: 9107         	str	r1, [sp, #0x1c]
 8008bca: 9206         	str	r2, [sp, #0x18]
 8008bcc: 9305         	str	r3, [sp, #0x14]
 8008bce: 6d7b         	ldr	r3, [r7, #0x54]
 8008bd0: 9304         	str	r3, [sp, #0x10]
 8008bd2: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x8008e10 <can_mcan_send+0x334>
 8008bd4: 9303         	str	r3, [sp, #0xc]
 8008bd6: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x8008e14 <can_mcan_send+0x338>
 8008bd8: 9302         	str	r3, [sp, #0x8]
 8008bda: 2308         	movs	r3, #0x8
 8008bdc: 9301         	str	r3, [sp, #0x4]
 8008bde: 2300         	movs	r3, #0x0
 8008be0: 9300         	str	r3, [sp]
 8008be2: 2300         	movs	r3, #0x0
 8008be4: 2204         	movs	r2, #0x4
 8008be6: 4629         	mov	r1, r5
 8008be8: 2000         	movs	r0, #0x0
 8008bea: f015 fde2    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15bc4
 8008bee: 2300         	movs	r3, #0x0
 8008bf0: 663b         	str	r3, [r7, #0x60]
; 	if ((frame->flags & ~(CAN_FRAME_IDE | CAN_FRAME_RTR)) != 0U) {
 8008bf2: 68bb         	ldr	r3, [r7, #0x8]
 8008bf4: 795b         	ldrb	r3, [r3, #0x5]
 8008bf6: 2b03         	cmp	r3, #0x3
 8008bf8: d921         	bls	0x8008c3e <can_mcan_send+0x162> @ imm = #0x42
; 		LOG_ERR("unsupported CAN frame flags 0x%02x", frame->flags);
 8008bfa: 2303         	movs	r3, #0x3
 8008bfc: 2b00         	cmp	r3, #0x0
 8008bfe: d01b         	beq	0x8008c38 <can_mcan_send+0x15c> @ imm = #0x36
 8008c00: 2301         	movs	r3, #0x1
 8008c02: f887 3027    	strb.w	r3, [r7, #0x27]
 8008c06: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8008c0a: f083 0301    	eor	r3, r3, #0x1
 8008c0e: b2db         	uxtb	r3, r3
 8008c10: 2b00         	cmp	r3, #0x0
 8008c12: d111         	bne	0x8008c38 <can_mcan_send+0x15c> @ imm = #0x22
 8008c14: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x8008df4 <can_mcan_send+0x318>
 8008c16: 6819         	ldr	r1, [r3]
 8008c18: 68bb         	ldr	r3, [r7, #0x8]
 8008c1a: 795b         	ldrb	r3, [r3, #0x5]
 8008c1c: 9303         	str	r3, [sp, #0xc]
 8008c1e: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x8008e18 <can_mcan_send+0x33c>
 8008c20: 9302         	str	r3, [sp, #0x8]
 8008c22: 2300         	movs	r3, #0x0
 8008c24: 9301         	str	r3, [sp, #0x4]
 8008c26: 2300         	movs	r3, #0x0
 8008c28: 9300         	str	r3, [sp]
 8008c2a: 2300         	movs	r3, #0x0
 8008c2c: 2201         	movs	r2, #0x1
 8008c2e: 2000         	movs	r0, #0x0
 8008c30: f015 fdbf    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15b7e
 8008c34: 2300         	movs	r3, #0x0
 8008c36: 623b         	str	r3, [r7, #0x20]
; 		return -ENOTSUP;
 8008c38: f06f 0385    	mvn	r3, #0x85
 8008c3c: e1ad         	b	0x8008f9a <can_mcan_send+0x4be> @ imm = #0x35a
; 	if (data_length > sizeof(frame->data)) {
 8008c3e: 6d7b         	ldr	r3, [r7, #0x54]
 8008c40: 2b08         	cmp	r3, #0x8
 8008c42: d922         	bls	0x8008c8a <can_mcan_send+0x1ae> @ imm = #0x44
; 		LOG_ERR("data length (%zu) > max frame data length (%zu)", data_length,
 8008c44: 2303         	movs	r3, #0x3
 8008c46: 2b00         	cmp	r3, #0x0
 8008c48: d01c         	beq	0x8008c84 <can_mcan_send+0x1a8> @ imm = #0x38
 8008c4a: 2301         	movs	r3, #0x1
 8008c4c: f887 302f    	strb.w	r3, [r7, #0x2f]
 8008c50: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8008c54: f083 0301    	eor	r3, r3, #0x1
 8008c58: b2db         	uxtb	r3, r3
 8008c5a: 2b00         	cmp	r3, #0x0
 8008c5c: d112         	bne	0x8008c84 <can_mcan_send+0x1a8> @ imm = #0x24
 8008c5e: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8008df4 <can_mcan_send+0x318>
 8008c60: 6819         	ldr	r1, [r3]
 8008c62: 2308         	movs	r3, #0x8
 8008c64: 9304         	str	r3, [sp, #0x10]
 8008c66: 6d7b         	ldr	r3, [r7, #0x54]
 8008c68: 9303         	str	r3, [sp, #0xc]
 8008c6a: 4b6c         	ldr	r3, [pc, #0x1b0]        @ 0x8008e1c <can_mcan_send+0x340>
 8008c6c: 9302         	str	r3, [sp, #0x8]
 8008c6e: 2300         	movs	r3, #0x0
 8008c70: 9301         	str	r3, [sp, #0x4]
 8008c72: 2300         	movs	r3, #0x0
 8008c74: 9300         	str	r3, [sp]
 8008c76: 2300         	movs	r3, #0x0
 8008c78: 2201         	movs	r2, #0x1
 8008c7a: 2000         	movs	r0, #0x0
 8008c7c: f015 fd99    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15b32
 8008c80: 2300         	movs	r3, #0x0
 8008c82: 62bb         	str	r3, [r7, #0x28]
; 		return -EINVAL;
 8008c84: f06f 0315    	mvn	r3, #0x15
 8008c88: e187         	b	0x8008f9a <can_mcan_send+0x4be> @ imm = #0x30e
; 	if ((frame->flags & CAN_FRAME_FDF) != 0U) {
 8008c8a: 68bb         	ldr	r3, [r7, #0x8]
 8008c8c: 795b         	ldrb	r3, [r3, #0x5]
 8008c8e: f003 0304    	and	r3, r3, #0x4
 8008c92: 2b00         	cmp	r3, #0x0
 8008c94: d025         	beq	0x8008ce2 <can_mcan_send+0x206> @ imm = #0x4a
; 		if (frame->dlc > CANFD_MAX_DLC) {
 8008c96: 68bb         	ldr	r3, [r7, #0x8]
 8008c98: 791b         	ldrb	r3, [r3, #0x4]
 8008c9a: 2b0f         	cmp	r3, #0xf
 8008c9c: d947         	bls	0x8008d2e <can_mcan_send+0x252> @ imm = #0x8e
; 			LOG_ERR("DLC of %d for CAN FD format frame", frame->dlc);
 8008c9e: 2303         	movs	r3, #0x3
 8008ca0: 2b00         	cmp	r3, #0x0
 8008ca2: d01b         	beq	0x8008cdc <can_mcan_send+0x200> @ imm = #0x36
 8008ca4: 2301         	movs	r3, #0x1
 8008ca6: f887 306b    	strb.w	r3, [r7, #0x6b]
 8008caa: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 8008cae: f083 0301    	eor	r3, r3, #0x1
 8008cb2: b2db         	uxtb	r3, r3
 8008cb4: 2b00         	cmp	r3, #0x0
 8008cb6: d111         	bne	0x8008cdc <can_mcan_send+0x200> @ imm = #0x22
 8008cb8: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8008df4 <can_mcan_send+0x318>
 8008cba: 6819         	ldr	r1, [r3]
 8008cbc: 68bb         	ldr	r3, [r7, #0x8]
 8008cbe: 791b         	ldrb	r3, [r3, #0x4]
 8008cc0: 9303         	str	r3, [sp, #0xc]
 8008cc2: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8008e20 <can_mcan_send+0x344>
 8008cc4: 9302         	str	r3, [sp, #0x8]
 8008cc6: 2300         	movs	r3, #0x0
 8008cc8: 9301         	str	r3, [sp, #0x4]
 8008cca: 2300         	movs	r3, #0x0
 8008ccc: 9300         	str	r3, [sp]
 8008cce: 2300         	movs	r3, #0x0
 8008cd0: 2201         	movs	r2, #0x1
 8008cd2: 2000         	movs	r0, #0x0
 8008cd4: f015 fd6d    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15ada
 8008cd8: 2300         	movs	r3, #0x0
 8008cda: 667b         	str	r3, [r7, #0x64]
; 			return -EINVAL;
 8008cdc: f06f 0315    	mvn	r3, #0x15
 8008ce0: e15b         	b	0x8008f9a <can_mcan_send+0x4be> @ imm = #0x2b6
; 		if (frame->dlc > CAN_MAX_DLC) {
 8008ce2: 68bb         	ldr	r3, [r7, #0x8]
 8008ce4: 791b         	ldrb	r3, [r3, #0x4]
 8008ce6: 2b08         	cmp	r3, #0x8
 8008ce8: d921         	bls	0x8008d2e <can_mcan_send+0x252> @ imm = #0x42
; 			LOG_ERR("DLC of %d for non-FD format frame", frame->dlc);
 8008cea: 2303         	movs	r3, #0x3
 8008cec: 2b00         	cmp	r3, #0x0
 8008cee: d01b         	beq	0x8008d28 <can_mcan_send+0x24c> @ imm = #0x36
 8008cf0: 2301         	movs	r3, #0x1
 8008cf2: f887 305f    	strb.w	r3, [r7, #0x5f]
 8008cf6: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 8008cfa: f083 0301    	eor	r3, r3, #0x1
 8008cfe: b2db         	uxtb	r3, r3
 8008d00: 2b00         	cmp	r3, #0x0
 8008d02: d111         	bne	0x8008d28 <can_mcan_send+0x24c> @ imm = #0x22
 8008d04: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8008df4 <can_mcan_send+0x318>
 8008d06: 6819         	ldr	r1, [r3]
 8008d08: 68bb         	ldr	r3, [r7, #0x8]
 8008d0a: 791b         	ldrb	r3, [r3, #0x4]
 8008d0c: 9303         	str	r3, [sp, #0xc]
 8008d0e: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8008e24 <can_mcan_send+0x348>
 8008d10: 9302         	str	r3, [sp, #0x8]
 8008d12: 2300         	movs	r3, #0x0
 8008d14: 9301         	str	r3, [sp, #0x4]
 8008d16: 2300         	movs	r3, #0x0
 8008d18: 9300         	str	r3, [sp]
 8008d1a: 2300         	movs	r3, #0x0
 8008d1c: 2201         	movs	r2, #0x1
 8008d1e: 2000         	movs	r0, #0x0
 8008d20: f015 fd47    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15a8e
 8008d24: 2300         	movs	r3, #0x0
 8008d26: 66fb         	str	r3, [r7, #0x6c]
; 			return -EINVAL;
 8008d28: f06f 0315    	mvn	r3, #0x15
 8008d2c: e135         	b	0x8008f9a <can_mcan_send+0x4be> @ imm = #0x26a
; 	if (!data->common.started) {
 8008d2e: 6cbb         	ldr	r3, [r7, #0x48]
 8008d30: 791b         	ldrb	r3, [r3, #0x4]
 8008d32: f083 0301    	eor	r3, r3, #0x1
 8008d36: b2db         	uxtb	r3, r3
 8008d38: 2b00         	cmp	r3, #0x0
 8008d3a: d002         	beq	0x8008d42 <can_mcan_send+0x266> @ imm = #0x4
; 		return -ENETDOWN;
 8008d3c: f06f 0372    	mvn	r3, #0x72
 8008d40: e12b         	b	0x8008f9a <can_mcan_send+0x4be> @ imm = #0x256
; 	err = can_mcan_read_psr(dev, &reg);
 8008d42: f107 0314    	add.w	r3, r7, #0x14
 8008d46: 4619         	mov	r1, r3
 8008d48: 68f8         	ldr	r0, [r7, #0xc]
 8008d4a: f015 fed0    	bl	0x801eaee <can_mcan_read_psr> @ imm = #0x15da0
 8008d4e: 6438         	str	r0, [r7, #0x40]
; 	if (err != 0) {
 8008d50: 6c3b         	ldr	r3, [r7, #0x40]
 8008d52: 2b00         	cmp	r3, #0x0
 8008d54: d001         	beq	0x8008d5a <can_mcan_send+0x27e> @ imm = #0x2
; 		return err;
 8008d56: 6c3b         	ldr	r3, [r7, #0x40]
 8008d58: e11f         	b	0x8008f9a <can_mcan_send+0x4be> @ imm = #0x23e
; 	if ((reg & CAN_MCAN_PSR_BO) != 0U) {
 8008d5a: 697b         	ldr	r3, [r7, #0x14]
 8008d5c: f003 0380    	and	r3, r3, #0x80
 8008d60: 2b00         	cmp	r3, #0x0
 8008d62: d002         	beq	0x8008d6a <can_mcan_send+0x28e> @ imm = #0x4
; 		return -ENETUNREACH;
 8008d64: f06f 0371    	mvn	r3, #0x71
 8008d68: e117         	b	0x8008f9a <can_mcan_send+0x4be> @ imm = #0x22e
; 	err = k_sem_take(&data->tx_sem, timeout);
 8008d6a: 6cbb         	ldr	r3, [r7, #0x48]
 8008d6c: f103 0124    	add.w	r1, r3, #0x24
 8008d70: e9d7 2300    	ldrd	r2, r3, [r7]
 8008d74: 4608         	mov	r0, r1
 8008d76: f015 fc7d    	bl	0x801e674 <k_sem_take>  @ imm = #0x158fa
 8008d7a: 6438         	str	r0, [r7, #0x40]
; 	if (err != 0) {
 8008d7c: 6c3b         	ldr	r3, [r7, #0x40]
 8008d7e: 2b00         	cmp	r3, #0x0
 8008d80: d002         	beq	0x8008d88 <can_mcan_send+0x2ac> @ imm = #0x4
; 		return -EAGAIN;
 8008d82: f06f 030a    	mvn	r3, #0xa
 8008d86: e108         	b	0x8008f9a <can_mcan_send+0x4be> @ imm = #0x210
; 	k_mutex_lock(&data->tx_mtx, K_FOREVER);
 8008d88: 6cbb         	ldr	r3, [r7, #0x48]
 8008d8a: f103 0434    	add.w	r4, r3, #0x34
 8008d8e: f04f 30ff    	mov.w	r0, #0xffffffff
 8008d92: f04f 31ff    	mov.w	r1, #0xffffffff
 8008d96: 4602         	mov	r2, r0
 8008d98: 460b         	mov	r3, r1
 8008d9a: 4620         	mov	r0, r4
 8008d9c: f015 fc3e    	bl	0x801e61c <k_mutex_lock> @ imm = #0x1587c
; 	for (int i = 0; i < cbs->num_tx; i++) {
 8008da0: 2300         	movs	r3, #0x0
 8008da2: 647b         	str	r3, [r7, #0x44]
 8008da4: e00d         	b	0x8008dc2 <can_mcan_send+0x2e6> @ imm = #0x1a
; 		if (cbs->tx[i].function == NULL) {
 8008da6: 6cfb         	ldr	r3, [r7, #0x4c]
 8008da8: 681a         	ldr	r2, [r3]
 8008daa: 6c7b         	ldr	r3, [r7, #0x44]
 8008dac: 00db         	lsls	r3, r3, #0x3
 8008dae: 4413         	add	r3, r2
 8008db0: 681b         	ldr	r3, [r3]
 8008db2: 2b00         	cmp	r3, #0x0
 8008db4: d102         	bne	0x8008dbc <can_mcan_send+0x2e0> @ imm = #0x4
; 			put_idx = i;
 8008db6: 6c7b         	ldr	r3, [r7, #0x44]
 8008db8: 65bb         	str	r3, [r7, #0x58]
; 			break;
 8008dba: e008         	b	0x8008dce <can_mcan_send+0x2f2> @ imm = #0x10
; 	for (int i = 0; i < cbs->num_tx; i++) {
 8008dbc: 6c7b         	ldr	r3, [r7, #0x44]
 8008dbe: 3301         	adds	r3, #0x1
 8008dc0: 647b         	str	r3, [r7, #0x44]
 8008dc2: 6cfb         	ldr	r3, [r7, #0x4c]
 8008dc4: 7b1b         	ldrb	r3, [r3, #0xc]
 8008dc6: 461a         	mov	r2, r3
 8008dc8: 6c7b         	ldr	r3, [r7, #0x44]
 8008dca: 4293         	cmp	r3, r2
 8008dcc: dbeb         	blt	0x8008da6 <can_mcan_send+0x2ca> @ imm = #-0x2a
; 	tx_hdr.mm = put_idx;
 8008dce: 6dbb         	ldr	r3, [r7, #0x58]
 8008dd0: b2db         	uxtb	r3, r3
 8008dd2: 77fb         	strb	r3, [r7, #0x1f]
; 	if ((frame->flags & CAN_FRAME_IDE) != 0U) {
 8008dd4: 68bb         	ldr	r3, [r7, #0x8]
 8008dd6: 795b         	ldrb	r3, [r3, #0x5]
 8008dd8: f003 0301    	and	r3, r3, #0x1
 8008ddc: 2b00         	cmp	r3, #0x0
 8008dde: d023         	beq	0x8008e28 <can_mcan_send+0x34c> @ imm = #0x46
; 		tx_hdr.ext_id = frame->id;
 8008de0: 68bb         	ldr	r3, [r7, #0x8]
 8008de2: 681b         	ldr	r3, [r3]
 8008de4: f023 4260    	bic	r2, r3, #0xe0000000
 8008de8: 69bb         	ldr	r3, [r7, #0x18]
 8008dea: f362 031c    	bfi	r3, r2, #0, #29
 8008dee: 61bb         	str	r3, [r7, #0x18]
 8008df0: e023         	b	0x8008e3a <can_mcan_send+0x35e> @ imm = #0x46
 8008df2: bf00         	nop

08008df4 <$d>:
 8008df4: c0 06 00 24  	.word	0x240006c0
 8008df8: 14 af 02 08  	.word	0x0802af14
 8008dfc: 20 af 02 08  	.word	0x0802af20
 8008e00: 2c af 02 08  	.word	0x0802af2c
 8008e04: 30 af 02 08  	.word	0x0802af30
 8008e08: 34 af 02 08  	.word	0x0802af34
 8008e0c: 40 af 02 08  	.word	0x0802af40
 8008e10: b4 ce 02 08  	.word	0x0802ceb4
 8008e14: 44 af 02 08  	.word	0x0802af44
 8008e18: 7c af 02 08  	.word	0x0802af7c
 8008e1c: a0 af 02 08  	.word	0x0802afa0
 8008e20: d0 af 02 08  	.word	0x0802afd0
 8008e24: f4 af 02 08  	.word	0x0802aff4

08008e28 <$t>:
; 		tx_hdr.std_id = frame->id & CAN_STD_ID_MASK;
 8008e28: 68bb         	ldr	r3, [r7, #0x8]
 8008e2a: 681b         	ldr	r3, [r3]
 8008e2c: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8008e30: b29a         	uxth	r2, r3
 8008e32: 8b7b         	ldrh	r3, [r7, #0x1a]
 8008e34: f362 038c    	bfi	r3, r2, #2, #11
 8008e38: 837b         	strh	r3, [r7, #0x1a]
; 	err = can_mcan_write_mram(dev, config->mram_offsets[CAN_MCAN_MRAM_CFG_TX_BUFFER] + put_idx *
 8008e3a: 6d3b         	ldr	r3, [r7, #0x50]
 8008e3c: 8f5a         	ldrh	r2, [r3, #0x3a]
 8008e3e: 6dbb         	ldr	r3, [r7, #0x58]
 8008e40: b29b         	uxth	r3, r3
 8008e42: 4619         	mov	r1, r3
 8008e44: 00c9         	lsls	r1, r1, #0x3
 8008e46: 440b         	add	r3, r1
 8008e48: 00db         	lsls	r3, r3, #0x3
 8008e4a: b29b         	uxth	r3, r3
 8008e4c: 4413         	add	r3, r2
 8008e4e: b299         	uxth	r1, r3
 8008e50: f107 0218    	add.w	r2, r7, #0x18
 8008e54: 2308         	movs	r3, #0x8
 8008e56: 68f8         	ldr	r0, [r7, #0xc]
 8008e58: f015 fc5f    	bl	0x801e71a <can_mcan_write_mram> @ imm = #0x158be
 8008e5c: 6438         	str	r0, [r7, #0x40]
; 	if (err != 0) {
 8008e5e: 6c3b         	ldr	r3, [r7, #0x40]
 8008e60: 2b00         	cmp	r3, #0x0
 8008e62: d01f         	beq	0x8008ea4 <can_mcan_send+0x3c8> @ imm = #0x3e
; 		LOG_ERR("failed to write Tx Buffer header (err %d)", err);
 8008e64: 2303         	movs	r3, #0x3
 8008e66: 2b00         	cmp	r3, #0x0
 8008e68: d01b         	beq	0x8008ea2 <can_mcan_send+0x3c6> @ imm = #0x36
 8008e6a: 2301         	movs	r3, #0x1
 8008e6c: f887 3037    	strb.w	r3, [r7, #0x37]
 8008e70: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8008e74: f083 0301    	eor	r3, r3, #0x1
 8008e78: b2db         	uxtb	r3, r3
 8008e7a: 2b00         	cmp	r3, #0x0
 8008e7c: d111         	bne	0x8008ea2 <can_mcan_send+0x3c6> @ imm = #0x22
 8008e7e: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8008fa4 <can_mcan_send+0x4c8>
 8008e80: 6819         	ldr	r1, [r3]
 8008e82: 6c3b         	ldr	r3, [r7, #0x40]
 8008e84: 9303         	str	r3, [sp, #0xc]
 8008e86: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8008fa8 <can_mcan_send+0x4cc>
 8008e88: 9302         	str	r3, [sp, #0x8]
 8008e8a: 2300         	movs	r3, #0x0
 8008e8c: 9301         	str	r3, [sp, #0x4]
 8008e8e: 2300         	movs	r3, #0x0
 8008e90: 9300         	str	r3, [sp]
 8008e92: 2300         	movs	r3, #0x0
 8008e94: 2201         	movs	r2, #0x1
 8008e96: 2000         	movs	r0, #0x0
 8008e98: f015 fc8b    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15916
 8008e9c: 2300         	movs	r3, #0x0
 8008e9e: 633b         	str	r3, [r7, #0x30]
; 		goto err_unlock;
 8008ea0: e070         	b	0x8008f84 <can_mcan_send+0x4a8> @ imm = #0xe0
 8008ea2: e06f         	b	0x8008f84 <can_mcan_send+0x4a8> @ imm = #0xde
; 	if ((frame->flags & CAN_FRAME_RTR) == 0U && data_length != 0U) {
 8008ea4: 68bb         	ldr	r3, [r7, #0x8]
 8008ea6: 795b         	ldrb	r3, [r3, #0x5]
 8008ea8: f003 0302    	and	r3, r3, #0x2
 8008eac: 2b00         	cmp	r3, #0x0
 8008eae: d13d         	bne	0x8008f2c <can_mcan_send+0x450> @ imm = #0x7a
 8008eb0: 6d7b         	ldr	r3, [r7, #0x54]
 8008eb2: 2b00         	cmp	r3, #0x0
 8008eb4: d03a         	beq	0x8008f2c <can_mcan_send+0x450> @ imm = #0x74
; 		err = can_mcan_write_mram(dev, config->mram_offsets[CAN_MCAN_MRAM_CFG_TX_BUFFER] +
 8008eb6: 6d3b         	ldr	r3, [r7, #0x50]
 8008eb8: 8f5a         	ldrh	r2, [r3, #0x3a]
 8008eba: 6dbb         	ldr	r3, [r7, #0x58]
 8008ebc: b29b         	uxth	r3, r3
 8008ebe: 4619         	mov	r1, r3
 8008ec0: 00c9         	lsls	r1, r1, #0x3
 8008ec2: 440b         	add	r3, r1
 8008ec4: 00db         	lsls	r3, r3, #0x3
 8008ec6: b29b         	uxth	r3, r3
 8008ec8: 4413         	add	r3, r2
 8008eca: b29b         	uxth	r3, r3
 8008ecc: 3308         	adds	r3, #0x8
 8008ece: b299         	uxth	r1, r3
; 					&frame->data_32, ROUND_UP(data_length, sizeof(uint32_t)));
 8008ed0: 68bb         	ldr	r3, [r7, #0x8]
 8008ed2: f103 0208    	add.w	r2, r3, #0x8
 8008ed6: 6d7b         	ldr	r3, [r7, #0x54]
 8008ed8: 3303         	adds	r3, #0x3
; 		err = can_mcan_write_mram(dev, config->mram_offsets[CAN_MCAN_MRAM_CFG_TX_BUFFER] +
 8008eda: f023 0303    	bic	r3, r3, #0x3
 8008ede: 68f8         	ldr	r0, [r7, #0xc]
 8008ee0: f015 fc1b    	bl	0x801e71a <can_mcan_write_mram> @ imm = #0x15836
 8008ee4: 6438         	str	r0, [r7, #0x40]
; 		if (err != 0) {
 8008ee6: 6c3b         	ldr	r3, [r7, #0x40]
 8008ee8: 2b00         	cmp	r3, #0x0
 8008eea: d01f         	beq	0x8008f2c <can_mcan_send+0x450> @ imm = #0x3e
; 			LOG_ERR("failed to write Tx Buffer data (err %d)", err);
 8008eec: 2303         	movs	r3, #0x3
 8008eee: 2b00         	cmp	r3, #0x0
 8008ef0: d01b         	beq	0x8008f2a <can_mcan_send+0x44e> @ imm = #0x36
 8008ef2: 2301         	movs	r3, #0x1
 8008ef4: f887 303f    	strb.w	r3, [r7, #0x3f]
 8008ef8: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8008efc: f083 0301    	eor	r3, r3, #0x1
 8008f00: b2db         	uxtb	r3, r3
 8008f02: 2b00         	cmp	r3, #0x0
 8008f04: d111         	bne	0x8008f2a <can_mcan_send+0x44e> @ imm = #0x22
 8008f06: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8008fa4 <can_mcan_send+0x4c8>
 8008f08: 6819         	ldr	r1, [r3]
 8008f0a: 6c3b         	ldr	r3, [r7, #0x40]
 8008f0c: 9303         	str	r3, [sp, #0xc]
 8008f0e: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8008fac <can_mcan_send+0x4d0>
 8008f10: 9302         	str	r3, [sp, #0x8]
 8008f12: 2300         	movs	r3, #0x0
 8008f14: 9301         	str	r3, [sp, #0x4]
 8008f16: 2300         	movs	r3, #0x0
 8008f18: 9300         	str	r3, [sp]
 8008f1a: 2300         	movs	r3, #0x0
 8008f1c: 2201         	movs	r2, #0x1
 8008f1e: 2000         	movs	r0, #0x0
 8008f20: f015 fc47    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x1588e
 8008f24: 2300         	movs	r3, #0x0
 8008f26: 63bb         	str	r3, [r7, #0x38]
; 			goto err_unlock;
 8008f28: e02c         	b	0x8008f84 <can_mcan_send+0x4a8> @ imm = #0x58
 8008f2a: e02b         	b	0x8008f84 <can_mcan_send+0x4a8> @ imm = #0x56
; 	cbs->tx[put_idx].function = callback;
 8008f2c: 6cfb         	ldr	r3, [r7, #0x4c]
 8008f2e: 681a         	ldr	r2, [r3]
 8008f30: 6dbb         	ldr	r3, [r7, #0x58]
 8008f32: 00db         	lsls	r3, r3, #0x3
 8008f34: 4413         	add	r3, r2
 8008f36: f8d7 2080    	ldr.w	r2, [r7, #0x80]
 8008f3a: 601a         	str	r2, [r3]
; 	cbs->tx[put_idx].user_data = user_data;
 8008f3c: 6cfb         	ldr	r3, [r7, #0x4c]
 8008f3e: 681a         	ldr	r2, [r3]
 8008f40: 6dbb         	ldr	r3, [r7, #0x58]
 8008f42: 00db         	lsls	r3, r3, #0x3
 8008f44: 4413         	add	r3, r2
 8008f46: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8008f4a: 605a         	str	r2, [r3, #0x4]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_TXBAR, BIT(put_idx));
 8008f4c: 2201         	movs	r2, #0x1
 8008f4e: 6dbb         	ldr	r3, [r7, #0x58]
 8008f50: fa02 f303    	lsl.w	r3, r2, r3
 8008f54: 461a         	mov	r2, r3
 8008f56: 21d0         	movs	r1, #0xd0
 8008f58: 68f8         	ldr	r0, [r7, #0xc]
 8008f5a: f7fe fe8d    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x12e6
 8008f5e: 6438         	str	r0, [r7, #0x40]
; 	if (err != 0) {
 8008f60: 6c3b         	ldr	r3, [r7, #0x40]
 8008f62: 2b00         	cmp	r3, #0x0
 8008f64: d007         	beq	0x8008f76 <can_mcan_send+0x49a> @ imm = #0xe
; 		cbs->tx[put_idx].function = NULL;
 8008f66: 6cfb         	ldr	r3, [r7, #0x4c]
 8008f68: 681a         	ldr	r2, [r3]
 8008f6a: 6dbb         	ldr	r3, [r7, #0x58]
 8008f6c: 00db         	lsls	r3, r3, #0x3
 8008f6e: 4413         	add	r3, r2
 8008f70: 2200         	movs	r2, #0x0
 8008f72: 601a         	str	r2, [r3]
; 		goto err_unlock;
 8008f74: e006         	b	0x8008f84 <can_mcan_send+0x4a8> @ imm = #0xc
; 	k_mutex_unlock(&data->tx_mtx);
 8008f76: 6cbb         	ldr	r3, [r7, #0x48]
 8008f78: 3334         	adds	r3, #0x34
 8008f7a: 4618         	mov	r0, r3
 8008f7c: f015 fb5e    	bl	0x801e63c <k_mutex_unlock> @ imm = #0x156bc
; 	return 0;
 8008f80: 2300         	movs	r3, #0x0
 8008f82: e00a         	b	0x8008f9a <can_mcan_send+0x4be> @ imm = #0x14
; 	k_mutex_unlock(&data->tx_mtx);
 8008f84: 6cbb         	ldr	r3, [r7, #0x48]
 8008f86: 3334         	adds	r3, #0x34
 8008f88: 4618         	mov	r0, r3
 8008f8a: f015 fb57    	bl	0x801e63c <k_mutex_unlock> @ imm = #0x156ae
; 	k_sem_give(&data->tx_sem);
 8008f8e: 6cbb         	ldr	r3, [r7, #0x48]
 8008f90: 3324         	adds	r3, #0x24
 8008f92: 4618         	mov	r0, r3
 8008f94: f015 fb7e    	bl	0x801e694 <k_sem_give>  @ imm = #0x156fc
; 	return err;
 8008f98: 6c3b         	ldr	r3, [r7, #0x40]
; }
 8008f9a: 4618         	mov	r0, r3
 8008f9c: 3770         	adds	r7, #0x70
 8008f9e: 46bd         	mov	sp, r7
 8008fa0: bdb0         	pop	{r4, r5, r7, pc}
 8008fa2: bf00         	nop

08008fa4 <$d>:
 8008fa4: c0 06 00 24  	.word	0x240006c0
 8008fa8: 18 b0 02 08  	.word	0x0802b018
 8008fac: 44 b0 02 08  	.word	0x0802b044

08008fb0 <can_mcan_add_rx_filter_std>:
; {
 8008fb0: b590         	push	{r4, r7, lr}
 8008fb2: b099         	sub	sp, #0x64
 8008fb4: af06         	add	r7, sp, #0x18
 8008fb6: 60f8         	str	r0, [r7, #0xc]
 8008fb8: 60b9         	str	r1, [r7, #0x8]
 8008fba: 607a         	str	r2, [r7, #0x4]
 8008fbc: 603b         	str	r3, [r7]
; 	const struct can_mcan_config *config = dev->config;
 8008fbe: 68fb         	ldr	r3, [r7, #0xc]
 8008fc0: 685b         	ldr	r3, [r3, #0x4]
 8008fc2: 63fb         	str	r3, [r7, #0x3c]
; 	const struct can_mcan_callbacks *cbs = config->callbacks;
 8008fc4: 6bfb         	ldr	r3, [r7, #0x3c]
 8008fc6: 699b         	ldr	r3, [r3, #0x18]
 8008fc8: 63bb         	str	r3, [r7, #0x38]
; 	struct can_mcan_data *data = dev->data;
 8008fca: 68fb         	ldr	r3, [r7, #0xc]
 8008fcc: 691b         	ldr	r3, [r3, #0x10]
 8008fce: 637b         	str	r3, [r7, #0x34]
; 	struct can_mcan_std_filter filter_element = {
 8008fd0: 2300         	movs	r3, #0x0
 8008fd2: 617b         	str	r3, [r7, #0x14]
; 		.sfid2 = filter->mask,
 8008fd4: 683b         	ldr	r3, [r7]
 8008fd6: 685b         	ldr	r3, [r3, #0x4]
 8008fd8: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8008fdc: b29a         	uxth	r2, r3
; 	struct can_mcan_std_filter filter_element = {
 8008fde: 8abb         	ldrh	r3, [r7, #0x14]
 8008fe0: f362 030a    	bfi	r3, r2, #0, #11
 8008fe4: 82bb         	strh	r3, [r7, #0x14]
; 		.sfid1 = filter->id,
 8008fe6: 683b         	ldr	r3, [r7]
 8008fe8: 681b         	ldr	r3, [r3]
 8008fea: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8008fee: b29a         	uxth	r2, r3
; 	struct can_mcan_std_filter filter_element = {
 8008ff0: 8afb         	ldrh	r3, [r7, #0x16]
 8008ff2: f362 030a    	bfi	r3, r2, #0, #11
 8008ff6: 82fb         	strh	r3, [r7, #0x16]
 8008ff8: 7dfb         	ldrb	r3, [r7, #0x17]
 8008ffa: 2202         	movs	r2, #0x2
 8008ffc: f362 1387    	bfi	r3, r2, #6, #2
 8009000: 75fb         	strb	r3, [r7, #0x17]
; 	int filter_id = -ENOSPC;
 8009002: f06f 031b    	mvn	r3, #0x1b
 8009006: 647b         	str	r3, [r7, #0x44]
; 	k_mutex_lock(&data->lock, K_FOREVER);
 8009008: 6b7b         	ldr	r3, [r7, #0x34]
 800900a: f103 0410    	add.w	r4, r3, #0x10
 800900e: f04f 30ff    	mov.w	r0, #0xffffffff
 8009012: f04f 31ff    	mov.w	r1, #0xffffffff
 8009016: 4602         	mov	r2, r0
 8009018: 460b         	mov	r3, r1
 800901a: 4620         	mov	r0, r4
 800901c: f015 fafe    	bl	0x801e61c <k_mutex_lock> @ imm = #0x155fc
; 	for (i = 0; i < cbs->num_std; i++) {
 8009020: 2300         	movs	r3, #0x0
 8009022: 643b         	str	r3, [r7, #0x40]
 8009024: e00d         	b	0x8009042 <can_mcan_add_rx_filter_std+0x92> @ imm = #0x1a
; 		if (cbs->std[i].function == NULL) {
 8009026: 6bbb         	ldr	r3, [r7, #0x38]
 8009028: 685a         	ldr	r2, [r3, #0x4]
 800902a: 6c3b         	ldr	r3, [r7, #0x40]
 800902c: 00db         	lsls	r3, r3, #0x3
 800902e: 4413         	add	r3, r2
 8009030: 681b         	ldr	r3, [r3]
 8009032: 2b00         	cmp	r3, #0x0
 8009034: d102         	bne	0x800903c <can_mcan_add_rx_filter_std+0x8c> @ imm = #0x4
; 			filter_id = i;
 8009036: 6c3b         	ldr	r3, [r7, #0x40]
 8009038: 647b         	str	r3, [r7, #0x44]
; 			break;
 800903a: e008         	b	0x800904e <can_mcan_add_rx_filter_std+0x9e> @ imm = #0x10
; 	for (i = 0; i < cbs->num_std; i++) {
 800903c: 6c3b         	ldr	r3, [r7, #0x40]
 800903e: 3301         	adds	r3, #0x1
 8009040: 643b         	str	r3, [r7, #0x40]
 8009042: 6bbb         	ldr	r3, [r7, #0x38]
 8009044: 7b5b         	ldrb	r3, [r3, #0xd]
 8009046: 461a         	mov	r2, r3
 8009048: 6c3b         	ldr	r3, [r7, #0x40]
 800904a: 4293         	cmp	r3, r2
 800904c: dbeb         	blt	0x8009026 <can_mcan_add_rx_filter_std+0x76> @ imm = #-0x2a
; 	if (filter_id == -ENOSPC) {
 800904e: 6c7b         	ldr	r3, [r7, #0x44]
 8009050: f113 0f1c    	cmn.w	r3, #0x1c
 8009054: d121         	bne	0x800909a <can_mcan_add_rx_filter_std+0xea> @ imm = #0x42
; 		LOG_WRN("No free standard id filter left");
 8009056: 2303         	movs	r3, #0x3
 8009058: 2b01         	cmp	r3, #0x1
 800905a: d916         	bls	0x800908a <can_mcan_add_rx_filter_std+0xda> @ imm = #0x2c
 800905c: 2301         	movs	r3, #0x1
 800905e: 77fb         	strb	r3, [r7, #0x1f]
 8009060: 7ffb         	ldrb	r3, [r7, #0x1f]
 8009062: f083 0301    	eor	r3, r3, #0x1
 8009066: b2db         	uxtb	r3, r3
 8009068: 2b00         	cmp	r3, #0x0
 800906a: d10e         	bne	0x800908a <can_mcan_add_rx_filter_std+0xda> @ imm = #0x1c
 800906c: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8009188 <can_mcan_add_rx_filter_std+0x1d8>
 800906e: 6819         	ldr	r1, [r3]
 8009070: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800918c <can_mcan_add_rx_filter_std+0x1dc>
 8009072: 9302         	str	r3, [sp, #0x8]
 8009074: 2300         	movs	r3, #0x0
 8009076: 9301         	str	r3, [sp, #0x4]
 8009078: 2300         	movs	r3, #0x0
 800907a: 9300         	str	r3, [sp]
 800907c: 2300         	movs	r3, #0x0
 800907e: 2202         	movs	r2, #0x2
 8009080: 2000         	movs	r0, #0x0
 8009082: f015 fb96    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x1572c
 8009086: 2300         	movs	r3, #0x0
 8009088: 61bb         	str	r3, [r7, #0x18]
; 		k_mutex_unlock(&data->lock);
 800908a: 6b7b         	ldr	r3, [r7, #0x34]
 800908c: 3310         	adds	r3, #0x10
 800908e: 4618         	mov	r0, r3
 8009090: f015 fad4    	bl	0x801e63c <k_mutex_unlock> @ imm = #0x155a8
; 		return -ENOSPC;
 8009094: f06f 031b    	mvn	r3, #0x1b
 8009098: e071         	b	0x800917e <can_mcan_add_rx_filter_std+0x1ce> @ imm = #0xe2
; 	filter_element.sfec = filter_id & 0x01 ? CAN_MCAN_XFEC_FIFO1 : CAN_MCAN_XFEC_FIFO0;
 800909a: 6c7b         	ldr	r3, [r7, #0x44]
 800909c: f003 0301    	and	r3, r3, #0x1
 80090a0: 2b00         	cmp	r3, #0x0
 80090a2: d001         	beq	0x80090a8 <can_mcan_add_rx_filter_std+0xf8> @ imm = #0x2
 80090a4: 2202         	movs	r2, #0x2
 80090a6: e000         	b	0x80090aa <can_mcan_add_rx_filter_std+0xfa> @ imm = #0x0
 80090a8: 2201         	movs	r2, #0x1
 80090aa: 7dfb         	ldrb	r3, [r7, #0x17]
 80090ac: f362 03c5    	bfi	r3, r2, #3, #3
 80090b0: 75fb         	strb	r3, [r7, #0x17]
; 	err = can_mcan_write_mram(dev, config->mram_offsets[CAN_MCAN_MRAM_CFG_STD_FILTER] +
 80090b2: 6bfb         	ldr	r3, [r7, #0x3c]
 80090b4: 8dda         	ldrh	r2, [r3, #0x2e]
 80090b6: 6c7b         	ldr	r3, [r7, #0x44]
 80090b8: b29b         	uxth	r3, r3
 80090ba: 009b         	lsls	r3, r3, #0x2
 80090bc: b29b         	uxth	r3, r3
 80090be: 4413         	add	r3, r2
 80090c0: b299         	uxth	r1, r3
 80090c2: f107 0214    	add.w	r2, r7, #0x14
 80090c6: 2304         	movs	r3, #0x4
 80090c8: 68f8         	ldr	r0, [r7, #0xc]
 80090ca: f015 fb26    	bl	0x801e71a <can_mcan_write_mram> @ imm = #0x1564c
 80090ce: 6338         	str	r0, [r7, #0x30]
; 	if (err != 0) {
 80090d0: 6b3b         	ldr	r3, [r7, #0x30]
 80090d2: 2b00         	cmp	r3, #0x0
 80090d4: d01f         	beq	0x8009116 <can_mcan_add_rx_filter_std+0x166> @ imm = #0x3e
; 		LOG_ERR("failed to write std filter element (err %d)", err);
 80090d6: 2303         	movs	r3, #0x3
 80090d8: 2b00         	cmp	r3, #0x0
 80090da: d01a         	beq	0x8009112 <can_mcan_add_rx_filter_std+0x162> @ imm = #0x34
 80090dc: 2301         	movs	r3, #0x1
 80090de: f887 3027    	strb.w	r3, [r7, #0x27]
 80090e2: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80090e6: f083 0301    	eor	r3, r3, #0x1
 80090ea: b2db         	uxtb	r3, r3
 80090ec: 2b00         	cmp	r3, #0x0
 80090ee: d110         	bne	0x8009112 <can_mcan_add_rx_filter_std+0x162> @ imm = #0x20
 80090f0: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8009188 <can_mcan_add_rx_filter_std+0x1d8>
 80090f2: 6819         	ldr	r1, [r3]
 80090f4: 6b3b         	ldr	r3, [r7, #0x30]
 80090f6: 9303         	str	r3, [sp, #0xc]
 80090f8: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8009190 <can_mcan_add_rx_filter_std+0x1e0>
 80090fa: 9302         	str	r3, [sp, #0x8]
 80090fc: 2300         	movs	r3, #0x0
 80090fe: 9301         	str	r3, [sp, #0x4]
 8009100: 2300         	movs	r3, #0x0
 8009102: 9300         	str	r3, [sp]
 8009104: 2300         	movs	r3, #0x0
 8009106: 2201         	movs	r2, #0x1
 8009108: 2000         	movs	r0, #0x0
 800910a: f015 fb52    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x156a4
 800910e: 2300         	movs	r3, #0x0
 8009110: 623b         	str	r3, [r7, #0x20]
; 		return err;
 8009112: 6b3b         	ldr	r3, [r7, #0x30]
 8009114: e033         	b	0x800917e <can_mcan_add_rx_filter_std+0x1ce> @ imm = #0x66
; 	k_mutex_unlock(&data->lock);
 8009116: 6b7b         	ldr	r3, [r7, #0x34]
 8009118: 3310         	adds	r3, #0x10
 800911a: 4618         	mov	r0, r3
 800911c: f015 fa8e    	bl	0x801e63c <k_mutex_unlock> @ imm = #0x1551c
; 	LOG_DBG("Attached std filter at %d", filter_id);
 8009120: 2303         	movs	r3, #0x3
 8009122: 2b03         	cmp	r3, #0x3
 8009124: d91c         	bls	0x8009160 <can_mcan_add_rx_filter_std+0x1b0> @ imm = #0x38
 8009126: 2301         	movs	r3, #0x1
 8009128: f887 302f    	strb.w	r3, [r7, #0x2f]
 800912c: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8009130: f083 0301    	eor	r3, r3, #0x1
 8009134: b2db         	uxtb	r3, r3
 8009136: 2b00         	cmp	r3, #0x0
 8009138: d112         	bne	0x8009160 <can_mcan_add_rx_filter_std+0x1b0> @ imm = #0x24
 800913a: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8009188 <can_mcan_add_rx_filter_std+0x1d8>
 800913c: 6819         	ldr	r1, [r3]
 800913e: 6c7b         	ldr	r3, [r7, #0x44]
 8009140: 9304         	str	r3, [sp, #0x10]
 8009142: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8009194 <can_mcan_add_rx_filter_std+0x1e4>
 8009144: 9303         	str	r3, [sp, #0xc]
 8009146: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8009198 <can_mcan_add_rx_filter_std+0x1e8>
 8009148: 9302         	str	r3, [sp, #0x8]
 800914a: 2308         	movs	r3, #0x8
 800914c: 9301         	str	r3, [sp, #0x4]
 800914e: 2300         	movs	r3, #0x0
 8009150: 9300         	str	r3, [sp]
 8009152: 2300         	movs	r3, #0x0
 8009154: 2204         	movs	r2, #0x4
 8009156: 2000         	movs	r0, #0x0
 8009158: f015 fb2b    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15656
 800915c: 2300         	movs	r3, #0x0
 800915e: 62bb         	str	r3, [r7, #0x28]
; 	cbs->std[filter_id].function = callback;
 8009160: 6bbb         	ldr	r3, [r7, #0x38]
 8009162: 685a         	ldr	r2, [r3, #0x4]
 8009164: 6c7b         	ldr	r3, [r7, #0x44]
 8009166: 00db         	lsls	r3, r3, #0x3
 8009168: 4413         	add	r3, r2
 800916a: 68ba         	ldr	r2, [r7, #0x8]
 800916c: 601a         	str	r2, [r3]
; 	cbs->std[filter_id].user_data = user_data;
 800916e: 6bbb         	ldr	r3, [r7, #0x38]
 8009170: 685a         	ldr	r2, [r3, #0x4]
 8009172: 6c7b         	ldr	r3, [r7, #0x44]
 8009174: 00db         	lsls	r3, r3, #0x3
 8009176: 4413         	add	r3, r2
 8009178: 687a         	ldr	r2, [r7, #0x4]
 800917a: 605a         	str	r2, [r3, #0x4]
; 	return filter_id;
 800917c: 6c7b         	ldr	r3, [r7, #0x44]
; }
 800917e: 4618         	mov	r0, r3
 8009180: 374c         	adds	r7, #0x4c
 8009182: 46bd         	mov	sp, r7
 8009184: bd90         	pop	{r4, r7, pc}
 8009186: bf00         	nop

08009188 <$d>:
 8009188: c0 06 00 24  	.word	0x240006c0
 800918c: 6c b0 02 08  	.word	0x0802b06c
 8009190: 8c b0 02 08  	.word	0x0802b08c
 8009194: c4 ce 02 08  	.word	0x0802cec4
 8009198: b8 b0 02 08  	.word	0x0802b0b8

0800919c <can_mcan_add_rx_filter_ext>:
; {
 800919c: b590         	push	{r4, r7, lr}
 800919e: b099         	sub	sp, #0x64
 80091a0: af06         	add	r7, sp, #0x18
 80091a2: 60f8         	str	r0, [r7, #0xc]
 80091a4: 60b9         	str	r1, [r7, #0x8]
 80091a6: 607a         	str	r2, [r7, #0x4]
 80091a8: 603b         	str	r3, [r7]
; 	const struct can_mcan_config *config = dev->config;
 80091aa: 68fb         	ldr	r3, [r7, #0xc]
 80091ac: 685b         	ldr	r3, [r3, #0x4]
 80091ae: 63fb         	str	r3, [r7, #0x3c]
; 	const struct can_mcan_callbacks *cbs = config->callbacks;
 80091b0: 6bfb         	ldr	r3, [r7, #0x3c]
 80091b2: 699b         	ldr	r3, [r3, #0x18]
 80091b4: 63bb         	str	r3, [r7, #0x38]
; 	struct can_mcan_data *data = dev->data;
 80091b6: 68fb         	ldr	r3, [r7, #0xc]
 80091b8: 691b         	ldr	r3, [r3, #0x10]
 80091ba: 637b         	str	r3, [r7, #0x34]
; 	struct can_mcan_ext_filter filter_element = {
 80091bc: f107 0310    	add.w	r3, r7, #0x10
 80091c0: 2200         	movs	r2, #0x0
 80091c2: 601a         	str	r2, [r3]
 80091c4: 605a         	str	r2, [r3, #0x4]
; 		.efid1 = filter->id,
 80091c6: 683b         	ldr	r3, [r7]
 80091c8: 681b         	ldr	r3, [r3]
 80091ca: f023 4260    	bic	r2, r3, #0xe0000000
; 	struct can_mcan_ext_filter filter_element = {
 80091ce: 693b         	ldr	r3, [r7, #0x10]
 80091d0: f362 031c    	bfi	r3, r2, #0, #29
 80091d4: 613b         	str	r3, [r7, #0x10]
; 		.efid2 = filter->mask,
 80091d6: 683b         	ldr	r3, [r7]
 80091d8: 685b         	ldr	r3, [r3, #0x4]
 80091da: f023 4260    	bic	r2, r3, #0xe0000000
; 	struct can_mcan_ext_filter filter_element = {
 80091de: 697b         	ldr	r3, [r7, #0x14]
 80091e0: f362 031c    	bfi	r3, r2, #0, #29
 80091e4: 617b         	str	r3, [r7, #0x14]
 80091e6: 7dfb         	ldrb	r3, [r7, #0x17]
 80091e8: 2202         	movs	r2, #0x2
 80091ea: f362 1387    	bfi	r3, r2, #6, #2
 80091ee: 75fb         	strb	r3, [r7, #0x17]
; 	int filter_id = -ENOSPC;
 80091f0: f06f 031b    	mvn	r3, #0x1b
 80091f4: 647b         	str	r3, [r7, #0x44]
; 	k_mutex_lock(&data->lock, K_FOREVER);
 80091f6: 6b7b         	ldr	r3, [r7, #0x34]
 80091f8: f103 0410    	add.w	r4, r3, #0x10
 80091fc: f04f 30ff    	mov.w	r0, #0xffffffff
 8009200: f04f 31ff    	mov.w	r1, #0xffffffff
 8009204: 4602         	mov	r2, r0
 8009206: 460b         	mov	r3, r1
 8009208: 4620         	mov	r0, r4
 800920a: f015 fa07    	bl	0x801e61c <k_mutex_lock> @ imm = #0x1540e
; 	for (i = 0; i < cbs->num_ext; i++) {
 800920e: 2300         	movs	r3, #0x0
 8009210: 643b         	str	r3, [r7, #0x40]
 8009212: e00d         	b	0x8009230 <can_mcan_add_rx_filter_ext+0x94> @ imm = #0x1a
; 		if (cbs->ext[i].function == NULL) {
 8009214: 6bbb         	ldr	r3, [r7, #0x38]
 8009216: 689a         	ldr	r2, [r3, #0x8]
 8009218: 6c3b         	ldr	r3, [r7, #0x40]
 800921a: 00db         	lsls	r3, r3, #0x3
 800921c: 4413         	add	r3, r2
 800921e: 681b         	ldr	r3, [r3]
 8009220: 2b00         	cmp	r3, #0x0
 8009222: d102         	bne	0x800922a <can_mcan_add_rx_filter_ext+0x8e> @ imm = #0x4
; 			filter_id = i;
 8009224: 6c3b         	ldr	r3, [r7, #0x40]
 8009226: 647b         	str	r3, [r7, #0x44]
; 			break;
 8009228: e008         	b	0x800923c <can_mcan_add_rx_filter_ext+0xa0> @ imm = #0x10
; 	for (i = 0; i < cbs->num_ext; i++) {
 800922a: 6c3b         	ldr	r3, [r7, #0x40]
 800922c: 3301         	adds	r3, #0x1
 800922e: 643b         	str	r3, [r7, #0x40]
 8009230: 6bbb         	ldr	r3, [r7, #0x38]
 8009232: 7b9b         	ldrb	r3, [r3, #0xe]
 8009234: 461a         	mov	r2, r3
 8009236: 6c3b         	ldr	r3, [r7, #0x40]
 8009238: 4293         	cmp	r3, r2
 800923a: dbeb         	blt	0x8009214 <can_mcan_add_rx_filter_ext+0x78> @ imm = #-0x2a
; 	if (filter_id == -ENOSPC) {
 800923c: 6c7b         	ldr	r3, [r7, #0x44]
 800923e: f113 0f1c    	cmn.w	r3, #0x1c
 8009242: d121         	bne	0x8009288 <can_mcan_add_rx_filter_ext+0xec> @ imm = #0x42
; 		LOG_WRN("No free extended id filter left");
 8009244: 2303         	movs	r3, #0x3
 8009246: 2b01         	cmp	r3, #0x1
 8009248: d916         	bls	0x8009278 <can_mcan_add_rx_filter_ext+0xdc> @ imm = #0x2c
 800924a: 2301         	movs	r3, #0x1
 800924c: 77fb         	strb	r3, [r7, #0x1f]
 800924e: 7ffb         	ldrb	r3, [r7, #0x1f]
 8009250: f083 0301    	eor	r3, r3, #0x1
 8009254: b2db         	uxtb	r3, r3
 8009256: 2b00         	cmp	r3, #0x0
 8009258: d10e         	bne	0x8009278 <can_mcan_add_rx_filter_ext+0xdc> @ imm = #0x1c
 800925a: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8009374 <can_mcan_add_rx_filter_ext+0x1d8>
 800925c: 6819         	ldr	r1, [r3]
 800925e: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8009378 <can_mcan_add_rx_filter_ext+0x1dc>
 8009260: 9302         	str	r3, [sp, #0x8]
 8009262: 2300         	movs	r3, #0x0
 8009264: 9301         	str	r3, [sp, #0x4]
 8009266: 2300         	movs	r3, #0x0
 8009268: 9300         	str	r3, [sp]
 800926a: 2300         	movs	r3, #0x0
 800926c: 2202         	movs	r2, #0x2
 800926e: 2000         	movs	r0, #0x0
 8009270: f015 fa9f    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x1553e
 8009274: 2300         	movs	r3, #0x0
 8009276: 61bb         	str	r3, [r7, #0x18]
; 		k_mutex_unlock(&data->lock);
 8009278: 6b7b         	ldr	r3, [r7, #0x34]
 800927a: 3310         	adds	r3, #0x10
 800927c: 4618         	mov	r0, r3
 800927e: f015 f9dd    	bl	0x801e63c <k_mutex_unlock> @ imm = #0x153ba
; 		return -ENOSPC;
 8009282: f06f 031b    	mvn	r3, #0x1b
 8009286: e071         	b	0x800936c <can_mcan_add_rx_filter_ext+0x1d0> @ imm = #0xe2
; 	filter_element.efec = filter_id & 0x01 ? CAN_MCAN_XFEC_FIFO1 : CAN_MCAN_XFEC_FIFO0;
 8009288: 6c7b         	ldr	r3, [r7, #0x44]
 800928a: f003 0301    	and	r3, r3, #0x1
 800928e: 2b00         	cmp	r3, #0x0
 8009290: d001         	beq	0x8009296 <can_mcan_add_rx_filter_ext+0xfa> @ imm = #0x2
 8009292: 2202         	movs	r2, #0x2
 8009294: e000         	b	0x8009298 <can_mcan_add_rx_filter_ext+0xfc> @ imm = #0x0
 8009296: 2201         	movs	r2, #0x1
 8009298: 7cfb         	ldrb	r3, [r7, #0x13]
 800929a: f362 1347    	bfi	r3, r2, #5, #3
 800929e: 74fb         	strb	r3, [r7, #0x13]
; 	err = can_mcan_write_mram(dev, config->mram_offsets[CAN_MCAN_MRAM_CFG_EXT_FILTER] +
 80092a0: 6bfb         	ldr	r3, [r7, #0x3c]
 80092a2: 8e1a         	ldrh	r2, [r3, #0x30]
 80092a4: 6c7b         	ldr	r3, [r7, #0x44]
 80092a6: b29b         	uxth	r3, r3
 80092a8: 00db         	lsls	r3, r3, #0x3
 80092aa: b29b         	uxth	r3, r3
 80092ac: 4413         	add	r3, r2
 80092ae: b299         	uxth	r1, r3
 80092b0: f107 0210    	add.w	r2, r7, #0x10
 80092b4: 2308         	movs	r3, #0x8
 80092b6: 68f8         	ldr	r0, [r7, #0xc]
 80092b8: f015 fa2f    	bl	0x801e71a <can_mcan_write_mram> @ imm = #0x1545e
 80092bc: 6338         	str	r0, [r7, #0x30]
; 	if (err != 0) {
 80092be: 6b3b         	ldr	r3, [r7, #0x30]
 80092c0: 2b00         	cmp	r3, #0x0
 80092c2: d01f         	beq	0x8009304 <can_mcan_add_rx_filter_ext+0x168> @ imm = #0x3e
; 		LOG_ERR("failed to write std filter element (err %d)", err);
 80092c4: 2303         	movs	r3, #0x3
 80092c6: 2b00         	cmp	r3, #0x0
 80092c8: d01a         	beq	0x8009300 <can_mcan_add_rx_filter_ext+0x164> @ imm = #0x34
 80092ca: 2301         	movs	r3, #0x1
 80092cc: f887 3027    	strb.w	r3, [r7, #0x27]
 80092d0: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80092d4: f083 0301    	eor	r3, r3, #0x1
 80092d8: b2db         	uxtb	r3, r3
 80092da: 2b00         	cmp	r3, #0x0
 80092dc: d110         	bne	0x8009300 <can_mcan_add_rx_filter_ext+0x164> @ imm = #0x20
 80092de: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8009374 <can_mcan_add_rx_filter_ext+0x1d8>
 80092e0: 6819         	ldr	r1, [r3]
 80092e2: 6b3b         	ldr	r3, [r7, #0x30]
 80092e4: 9303         	str	r3, [sp, #0xc]
 80092e6: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800937c <can_mcan_add_rx_filter_ext+0x1e0>
 80092e8: 9302         	str	r3, [sp, #0x8]
 80092ea: 2300         	movs	r3, #0x0
 80092ec: 9301         	str	r3, [sp, #0x4]
 80092ee: 2300         	movs	r3, #0x0
 80092f0: 9300         	str	r3, [sp]
 80092f2: 2300         	movs	r3, #0x0
 80092f4: 2201         	movs	r2, #0x1
 80092f6: 2000         	movs	r0, #0x0
 80092f8: f015 fa5b    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x154b6
 80092fc: 2300         	movs	r3, #0x0
 80092fe: 623b         	str	r3, [r7, #0x20]
; 		return err;
 8009300: 6b3b         	ldr	r3, [r7, #0x30]
 8009302: e033         	b	0x800936c <can_mcan_add_rx_filter_ext+0x1d0> @ imm = #0x66
; 	k_mutex_unlock(&data->lock);
 8009304: 6b7b         	ldr	r3, [r7, #0x34]
 8009306: 3310         	adds	r3, #0x10
 8009308: 4618         	mov	r0, r3
 800930a: f015 f997    	bl	0x801e63c <k_mutex_unlock> @ imm = #0x1532e
; 	LOG_DBG("Attached ext filter at %d", filter_id);
 800930e: 2303         	movs	r3, #0x3
 8009310: 2b03         	cmp	r3, #0x3
 8009312: d91c         	bls	0x800934e <can_mcan_add_rx_filter_ext+0x1b2> @ imm = #0x38
 8009314: 2301         	movs	r3, #0x1
 8009316: f887 302f    	strb.w	r3, [r7, #0x2f]
 800931a: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800931e: f083 0301    	eor	r3, r3, #0x1
 8009322: b2db         	uxtb	r3, r3
 8009324: 2b00         	cmp	r3, #0x0
 8009326: d112         	bne	0x800934e <can_mcan_add_rx_filter_ext+0x1b2> @ imm = #0x24
 8009328: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8009374 <can_mcan_add_rx_filter_ext+0x1d8>
 800932a: 6819         	ldr	r1, [r3]
 800932c: 6c7b         	ldr	r3, [r7, #0x44]
 800932e: 9304         	str	r3, [sp, #0x10]
 8009330: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8009380 <can_mcan_add_rx_filter_ext+0x1e4>
 8009332: 9303         	str	r3, [sp, #0xc]
 8009334: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8009384 <can_mcan_add_rx_filter_ext+0x1e8>
 8009336: 9302         	str	r3, [sp, #0x8]
 8009338: 2308         	movs	r3, #0x8
 800933a: 9301         	str	r3, [sp, #0x4]
 800933c: 2300         	movs	r3, #0x0
 800933e: 9300         	str	r3, [sp]
 8009340: 2300         	movs	r3, #0x0
 8009342: 2204         	movs	r2, #0x4
 8009344: 2000         	movs	r0, #0x0
 8009346: f015 fa34    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15468
 800934a: 2300         	movs	r3, #0x0
 800934c: 62bb         	str	r3, [r7, #0x28]
; 	cbs->ext[filter_id].function = callback;
 800934e: 6bbb         	ldr	r3, [r7, #0x38]
 8009350: 689a         	ldr	r2, [r3, #0x8]
 8009352: 6c7b         	ldr	r3, [r7, #0x44]
 8009354: 00db         	lsls	r3, r3, #0x3
 8009356: 4413         	add	r3, r2
 8009358: 68ba         	ldr	r2, [r7, #0x8]
 800935a: 601a         	str	r2, [r3]
; 	cbs->ext[filter_id].user_data = user_data;
 800935c: 6bbb         	ldr	r3, [r7, #0x38]
 800935e: 689a         	ldr	r2, [r3, #0x8]
 8009360: 6c7b         	ldr	r3, [r7, #0x44]
 8009362: 00db         	lsls	r3, r3, #0x3
 8009364: 4413         	add	r3, r2
 8009366: 687a         	ldr	r2, [r7, #0x4]
 8009368: 605a         	str	r2, [r3, #0x4]
; 	return filter_id;
 800936a: 6c7b         	ldr	r3, [r7, #0x44]
; }
 800936c: 4618         	mov	r0, r3
 800936e: 374c         	adds	r7, #0x4c
 8009370: 46bd         	mov	sp, r7
 8009372: bd90         	pop	{r4, r7, pc}

08009374 <$d>:
 8009374: c0 06 00 24  	.word	0x240006c0
 8009378: d8 b0 02 08  	.word	0x0802b0d8
 800937c: 8c b0 02 08  	.word	0x0802b08c
 8009380: e0 ce 02 08  	.word	0x0802cee0
 8009384: f8 b0 02 08  	.word	0x0802b0f8

08009388 <can_mcan_add_rx_filter>:
; {
 8009388: b580         	push	{r7, lr}
 800938a: b08e         	sub	sp, #0x38
 800938c: af04         	add	r7, sp, #0x10
 800938e: 60f8         	str	r0, [r7, #0xc]
 8009390: 60b9         	str	r1, [r7, #0x8]
 8009392: 607a         	str	r2, [r7, #0x4]
 8009394: 603b         	str	r3, [r7]
; 	const struct can_mcan_config *config = dev->config;
 8009396: 68fb         	ldr	r3, [r7, #0xc]
 8009398: 685b         	ldr	r3, [r3, #0x4]
 800939a: 623b         	str	r3, [r7, #0x20]
; 	const struct can_mcan_callbacks *cbs = config->callbacks;
 800939c: 6a3b         	ldr	r3, [r7, #0x20]
 800939e: 699b         	ldr	r3, [r3, #0x18]
 80093a0: 61fb         	str	r3, [r7, #0x1c]
; 	if ((filter->flags & ~(CAN_FILTER_IDE)) != 0U) {
 80093a2: 683b         	ldr	r3, [r7]
 80093a4: 7a1b         	ldrb	r3, [r3, #0x8]
 80093a6: 2b01         	cmp	r3, #0x1
 80093a8: d91f         	bls	0x80093ea <can_mcan_add_rx_filter+0x62> @ imm = #0x3e
; 		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
 80093aa: 2303         	movs	r3, #0x3
 80093ac: 2b00         	cmp	r3, #0x0
 80093ae: d019         	beq	0x80093e4 <can_mcan_add_rx_filter+0x5c> @ imm = #0x32
 80093b0: 2301         	movs	r3, #0x1
 80093b2: 76fb         	strb	r3, [r7, #0x1b]
 80093b4: 7efb         	ldrb	r3, [r7, #0x1b]
 80093b6: f083 0301    	eor	r3, r3, #0x1
 80093ba: b2db         	uxtb	r3, r3
 80093bc: 2b00         	cmp	r3, #0x0
 80093be: d111         	bne	0x80093e4 <can_mcan_add_rx_filter+0x5c> @ imm = #0x22
 80093c0: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8009430 <can_mcan_add_rx_filter+0xa8>
 80093c2: 6819         	ldr	r1, [r3]
 80093c4: 683b         	ldr	r3, [r7]
 80093c6: 7a1b         	ldrb	r3, [r3, #0x8]
 80093c8: 9303         	str	r3, [sp, #0xc]
 80093ca: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8009434 <can_mcan_add_rx_filter+0xac>
 80093cc: 9302         	str	r3, [sp, #0x8]
 80093ce: 2300         	movs	r3, #0x0
 80093d0: 9301         	str	r3, [sp, #0x4]
 80093d2: 2300         	movs	r3, #0x0
 80093d4: 9300         	str	r3, [sp]
 80093d6: 2300         	movs	r3, #0x0
 80093d8: 2201         	movs	r2, #0x1
 80093da: 2000         	movs	r0, #0x0
 80093dc: f015 f9e9    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x153d2
 80093e0: 2300         	movs	r3, #0x0
 80093e2: 617b         	str	r3, [r7, #0x14]
; 		return -ENOTSUP;
 80093e4: f06f 0385    	mvn	r3, #0x85
 80093e8: e01e         	b	0x8009428 <can_mcan_add_rx_filter+0xa0> @ imm = #0x3c
; 	if ((filter->flags & CAN_FILTER_IDE) != 0U) {
 80093ea: 683b         	ldr	r3, [r7]
 80093ec: 7a1b         	ldrb	r3, [r3, #0x8]
 80093ee: f003 0301    	and	r3, r3, #0x1
 80093f2: 2b00         	cmp	r3, #0x0
 80093f4: d010         	beq	0x8009418 <can_mcan_add_rx_filter+0x90> @ imm = #0x20
; 		filter_id = can_mcan_add_rx_filter_ext(dev, callback, user_data, filter);
 80093f6: 683b         	ldr	r3, [r7]
 80093f8: 687a         	ldr	r2, [r7, #0x4]
 80093fa: 68b9         	ldr	r1, [r7, #0x8]
 80093fc: 68f8         	ldr	r0, [r7, #0xc]
 80093fe: f7ff fecd    	bl	0x800919c <can_mcan_add_rx_filter_ext> @ imm = #-0x266
 8009402: 6278         	str	r0, [r7, #0x24]
; 		if (filter_id >= 0) {
 8009404: 6a7b         	ldr	r3, [r7, #0x24]
 8009406: 2b00         	cmp	r3, #0x0
 8009408: db0d         	blt	0x8009426 <can_mcan_add_rx_filter+0x9e> @ imm = #0x1a
; 			filter_id += cbs->num_std;
 800940a: 69fb         	ldr	r3, [r7, #0x1c]
 800940c: 7b5b         	ldrb	r3, [r3, #0xd]
 800940e: 461a         	mov	r2, r3
 8009410: 6a7b         	ldr	r3, [r7, #0x24]
 8009412: 4413         	add	r3, r2
 8009414: 627b         	str	r3, [r7, #0x24]
 8009416: e006         	b	0x8009426 <can_mcan_add_rx_filter+0x9e> @ imm = #0xc
; 		filter_id = can_mcan_add_rx_filter_std(dev, callback, user_data, filter);
 8009418: 683b         	ldr	r3, [r7]
 800941a: 687a         	ldr	r2, [r7, #0x4]
 800941c: 68b9         	ldr	r1, [r7, #0x8]
 800941e: 68f8         	ldr	r0, [r7, #0xc]
 8009420: f7ff fdc6    	bl	0x8008fb0 <can_mcan_add_rx_filter_std> @ imm = #-0x474
 8009424: 6278         	str	r0, [r7, #0x24]
; 	return filter_id;
 8009426: 6a7b         	ldr	r3, [r7, #0x24]
; }
 8009428: 4618         	mov	r0, r3
 800942a: 3728         	adds	r7, #0x28
 800942c: 46bd         	mov	sp, r7
 800942e: bd80         	pop	{r7, pc}

08009430 <$d>:
 8009430: c0 06 00 24  	.word	0x240006c0
 8009434: 18 b1 02 08  	.word	0x0802b118

08009438 <can_mcan_remove_rx_filter>:
; {
 8009438: b580         	push	{r7, lr}
 800943a: b092         	sub	sp, #0x48
 800943c: af04         	add	r7, sp, #0x10
 800943e: 6078         	str	r0, [r7, #0x4]
 8009440: 6039         	str	r1, [r7]
; 	const struct can_mcan_config *config = dev->config;
 8009442: 687b         	ldr	r3, [r7, #0x4]
 8009444: 685b         	ldr	r3, [r3, #0x4]
 8009446: 637b         	str	r3, [r7, #0x34]
; 	const struct can_mcan_callbacks *cbs = config->callbacks;
 8009448: 6b7b         	ldr	r3, [r7, #0x34]
 800944a: 699b         	ldr	r3, [r3, #0x18]
 800944c: 633b         	str	r3, [r7, #0x30]
; 	struct can_mcan_data *data = dev->data;
 800944e: 687b         	ldr	r3, [r7, #0x4]
 8009450: 691b         	ldr	r3, [r3, #0x10]
 8009452: 62fb         	str	r3, [r7, #0x2c]
; 	if (filter_id < 0) {
 8009454: 683b         	ldr	r3, [r7]
 8009456: 2b00         	cmp	r3, #0x0
 8009458: da1d         	bge	0x8009496 <can_mcan_remove_rx_filter+0x5e> @ imm = #0x3a
; 		LOG_ERR("filter ID %d out of bounds", filter_id);
 800945a: 2303         	movs	r3, #0x3
 800945c: 2b00         	cmp	r3, #0x0
 800945e: d019         	beq	0x8009494 <can_mcan_remove_rx_filter+0x5c> @ imm = #0x32
 8009460: 2301         	movs	r3, #0x1
 8009462: 73fb         	strb	r3, [r7, #0xf]
 8009464: 7bfb         	ldrb	r3, [r7, #0xf]
 8009466: f083 0301    	eor	r3, r3, #0x1
 800946a: b2db         	uxtb	r3, r3
 800946c: 2b00         	cmp	r3, #0x0
 800946e: d111         	bne	0x8009494 <can_mcan_remove_rx_filter+0x5c> @ imm = #0x22
 8009470: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8009618 <can_mcan_remove_rx_filter+0x1e0>
 8009472: 6819         	ldr	r1, [r3]
 8009474: 683b         	ldr	r3, [r7]
 8009476: 9303         	str	r3, [sp, #0xc]
 8009478: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x800961c <can_mcan_remove_rx_filter+0x1e4>
 800947a: 9302         	str	r3, [sp, #0x8]
 800947c: 2300         	movs	r3, #0x0
 800947e: 9301         	str	r3, [sp, #0x4]
 8009480: 2300         	movs	r3, #0x0
 8009482: 9300         	str	r3, [sp]
 8009484: 2300         	movs	r3, #0x0
 8009486: 2201         	movs	r2, #0x1
 8009488: 2000         	movs	r0, #0x0
 800948a: f015 f992    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x15324
 800948e: 2300         	movs	r3, #0x0
 8009490: 60bb         	str	r3, [r7, #0x8]
; 		return;
 8009492: e0bd         	b	0x8009610 <can_mcan_remove_rx_filter+0x1d8> @ imm = #0x17a
 8009494: e0bc         	b	0x8009610 <can_mcan_remove_rx_filter+0x1d8> @ imm = #0x178
; 	k_mutex_lock(&data->lock, K_FOREVER);
 8009496: 6afb         	ldr	r3, [r7, #0x2c]
 8009498: f103 0110    	add.w	r1, r3, #0x10
 800949c: f04f 32ff    	mov.w	r2, #0xffffffff
 80094a0: f04f 33ff    	mov.w	r3, #0xffffffff
 80094a4: 4608         	mov	r0, r1
 80094a6: f015 f8b9    	bl	0x801e61c <k_mutex_lock> @ imm = #0x15172
; 	if (filter_id >= cbs->num_std) {
 80094aa: 6b3b         	ldr	r3, [r7, #0x30]
 80094ac: 7b5b         	ldrb	r3, [r3, #0xd]
 80094ae: 461a         	mov	r2, r3
 80094b0: 683b         	ldr	r3, [r7]
 80094b2: 4293         	cmp	r3, r2
 80094b4: db69         	blt	0x800958a <can_mcan_remove_rx_filter+0x152> @ imm = #0xd2
; 		filter_id -= cbs->num_std;
 80094b6: 6b3b         	ldr	r3, [r7, #0x30]
 80094b8: 7b5b         	ldrb	r3, [r3, #0xd]
 80094ba: 461a         	mov	r2, r3
 80094bc: 683b         	ldr	r3, [r7]
 80094be: 1a9b         	subs	r3, r3, r2
 80094c0: 603b         	str	r3, [r7]
; 		if (filter_id >= cbs->num_ext) {
 80094c2: 6b3b         	ldr	r3, [r7, #0x30]
 80094c4: 7b9b         	ldrb	r3, [r3, #0xe]
 80094c6: 461a         	mov	r2, r3
 80094c8: 683b         	ldr	r3, [r7]
 80094ca: 4293         	cmp	r3, r2
 80094cc: db21         	blt	0x8009512 <can_mcan_remove_rx_filter+0xda> @ imm = #0x42
; 			LOG_ERR("filter ID %d out of bounds", filter_id);
 80094ce: 2303         	movs	r3, #0x3
 80094d0: 2b00         	cmp	r3, #0x0
 80094d2: d018         	beq	0x8009506 <can_mcan_remove_rx_filter+0xce> @ imm = #0x30
 80094d4: 2301         	movs	r3, #0x1
 80094d6: 75fb         	strb	r3, [r7, #0x17]
 80094d8: 7dfb         	ldrb	r3, [r7, #0x17]
 80094da: f083 0301    	eor	r3, r3, #0x1
 80094de: b2db         	uxtb	r3, r3
 80094e0: 2b00         	cmp	r3, #0x0
 80094e2: d110         	bne	0x8009506 <can_mcan_remove_rx_filter+0xce> @ imm = #0x20
 80094e4: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x8009618 <can_mcan_remove_rx_filter+0x1e0>
 80094e6: 6819         	ldr	r1, [r3]
 80094e8: 683b         	ldr	r3, [r7]
 80094ea: 9303         	str	r3, [sp, #0xc]
 80094ec: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800961c <can_mcan_remove_rx_filter+0x1e4>
 80094ee: 9302         	str	r3, [sp, #0x8]
 80094f0: 2300         	movs	r3, #0x0
 80094f2: 9301         	str	r3, [sp, #0x4]
 80094f4: 2300         	movs	r3, #0x0
 80094f6: 9300         	str	r3, [sp]
 80094f8: 2300         	movs	r3, #0x0
 80094fa: 2201         	movs	r2, #0x1
 80094fc: 2000         	movs	r0, #0x0
 80094fe: f015 f958    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x152b0
 8009502: 2300         	movs	r3, #0x0
 8009504: 613b         	str	r3, [r7, #0x10]
; 			k_mutex_unlock(&data->lock);
 8009506: 6afb         	ldr	r3, [r7, #0x2c]
 8009508: 3310         	adds	r3, #0x10
 800950a: 4618         	mov	r0, r3
 800950c: f015 f896    	bl	0x801e63c <k_mutex_unlock> @ imm = #0x1512c
; 			return;
 8009510: e07e         	b	0x8009610 <can_mcan_remove_rx_filter+0x1d8> @ imm = #0xfc
; 		cbs->ext[filter_id].function = NULL;
 8009512: 6b3b         	ldr	r3, [r7, #0x30]
 8009514: 689a         	ldr	r2, [r3, #0x8]
 8009516: 683b         	ldr	r3, [r7]
 8009518: 00db         	lsls	r3, r3, #0x3
 800951a: 4413         	add	r3, r2
 800951c: 2200         	movs	r2, #0x0
 800951e: 601a         	str	r2, [r3]
; 		cbs->ext[filter_id].user_data = NULL;
 8009520: 6b3b         	ldr	r3, [r7, #0x30]
 8009522: 689a         	ldr	r2, [r3, #0x8]
 8009524: 683b         	ldr	r3, [r7]
 8009526: 00db         	lsls	r3, r3, #0x3
 8009528: 4413         	add	r3, r2
 800952a: 2200         	movs	r2, #0x0
 800952c: 605a         	str	r2, [r3, #0x4]
; 		err = can_mcan_clear_mram(dev, config->mram_offsets[CAN_MCAN_MRAM_CFG_EXT_FILTER] +
 800952e: 6b7b         	ldr	r3, [r7, #0x34]
 8009530: 8e1a         	ldrh	r2, [r3, #0x30]
 8009532: 683b         	ldr	r3, [r7]
 8009534: b29b         	uxth	r3, r3
 8009536: 00db         	lsls	r3, r3, #0x3
 8009538: b29b         	uxth	r3, r3
 800953a: 4413         	add	r3, r2
 800953c: b29b         	uxth	r3, r3
 800953e: 2208         	movs	r2, #0x8
 8009540: 4619         	mov	r1, r3
 8009542: 6878         	ldr	r0, [r7, #0x4]
 8009544: f015 f901    	bl	0x801e74a <can_mcan_clear_mram> @ imm = #0x15202
 8009548: 62b8         	str	r0, [r7, #0x28]
; 		if (err != 0) {
 800954a: 6abb         	ldr	r3, [r7, #0x28]
 800954c: 2b00         	cmp	r3, #0x0
 800954e: d059         	beq	0x8009604 <can_mcan_remove_rx_filter+0x1cc> @ imm = #0xb2
; 			LOG_ERR("failed to clear ext filter element (err %d)", err);
 8009550: 2303         	movs	r3, #0x3
 8009552: 2b00         	cmp	r3, #0x0
 8009554: d056         	beq	0x8009604 <can_mcan_remove_rx_filter+0x1cc> @ imm = #0xac
 8009556: 2301         	movs	r3, #0x1
 8009558: 77fb         	strb	r3, [r7, #0x1f]
 800955a: 7ffb         	ldrb	r3, [r7, #0x1f]
 800955c: f083 0301    	eor	r3, r3, #0x1
 8009560: b2db         	uxtb	r3, r3
 8009562: 2b00         	cmp	r3, #0x0
 8009564: d14e         	bne	0x8009604 <can_mcan_remove_rx_filter+0x1cc> @ imm = #0x9c
 8009566: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8009618 <can_mcan_remove_rx_filter+0x1e0>
 8009568: 6819         	ldr	r1, [r3]
 800956a: 6abb         	ldr	r3, [r7, #0x28]
 800956c: 9303         	str	r3, [sp, #0xc]
 800956e: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8009620 <can_mcan_remove_rx_filter+0x1e8>
 8009570: 9302         	str	r3, [sp, #0x8]
 8009572: 2300         	movs	r3, #0x0
 8009574: 9301         	str	r3, [sp, #0x4]
 8009576: 2300         	movs	r3, #0x0
 8009578: 9300         	str	r3, [sp]
 800957a: 2300         	movs	r3, #0x0
 800957c: 2201         	movs	r2, #0x1
 800957e: 2000         	movs	r0, #0x0
 8009580: f015 f917    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x1522e
 8009584: 2300         	movs	r3, #0x0
 8009586: 61bb         	str	r3, [r7, #0x18]
 8009588: e03c         	b	0x8009604 <can_mcan_remove_rx_filter+0x1cc> @ imm = #0x78
; 		cbs->std[filter_id].function = NULL;
 800958a: 6b3b         	ldr	r3, [r7, #0x30]
 800958c: 685a         	ldr	r2, [r3, #0x4]
 800958e: 683b         	ldr	r3, [r7]
 8009590: 00db         	lsls	r3, r3, #0x3
 8009592: 4413         	add	r3, r2
 8009594: 2200         	movs	r2, #0x0
 8009596: 601a         	str	r2, [r3]
; 		cbs->std[filter_id].user_data = NULL;
 8009598: 6b3b         	ldr	r3, [r7, #0x30]
 800959a: 685a         	ldr	r2, [r3, #0x4]
 800959c: 683b         	ldr	r3, [r7]
 800959e: 00db         	lsls	r3, r3, #0x3
 80095a0: 4413         	add	r3, r2
 80095a2: 2200         	movs	r2, #0x0
 80095a4: 605a         	str	r2, [r3, #0x4]
; 		err = can_mcan_clear_mram(dev, config->mram_offsets[CAN_MCAN_MRAM_CFG_STD_FILTER] +
 80095a6: 6b7b         	ldr	r3, [r7, #0x34]
 80095a8: 8dda         	ldrh	r2, [r3, #0x2e]
 80095aa: 683b         	ldr	r3, [r7]
 80095ac: b29b         	uxth	r3, r3
 80095ae: 009b         	lsls	r3, r3, #0x2
 80095b0: b29b         	uxth	r3, r3
 80095b2: 4413         	add	r3, r2
 80095b4: b29b         	uxth	r3, r3
 80095b6: 2204         	movs	r2, #0x4
 80095b8: 4619         	mov	r1, r3
 80095ba: 6878         	ldr	r0, [r7, #0x4]
 80095bc: f015 f8c5    	bl	0x801e74a <can_mcan_clear_mram> @ imm = #0x1518a
 80095c0: 62b8         	str	r0, [r7, #0x28]
; 		if (err != 0) {
 80095c2: 6abb         	ldr	r3, [r7, #0x28]
 80095c4: 2b00         	cmp	r3, #0x0
 80095c6: d01d         	beq	0x8009604 <can_mcan_remove_rx_filter+0x1cc> @ imm = #0x3a
; 			LOG_ERR("failed to clear std filter element (err %d)", err);
 80095c8: 2303         	movs	r3, #0x3
 80095ca: 2b00         	cmp	r3, #0x0
 80095cc: d01a         	beq	0x8009604 <can_mcan_remove_rx_filter+0x1cc> @ imm = #0x34
 80095ce: 2301         	movs	r3, #0x1
 80095d0: f887 3027    	strb.w	r3, [r7, #0x27]
 80095d4: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80095d8: f083 0301    	eor	r3, r3, #0x1
 80095dc: b2db         	uxtb	r3, r3
 80095de: 2b00         	cmp	r3, #0x0
 80095e0: d110         	bne	0x8009604 <can_mcan_remove_rx_filter+0x1cc> @ imm = #0x20
 80095e2: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8009618 <can_mcan_remove_rx_filter+0x1e0>
 80095e4: 6819         	ldr	r1, [r3]
 80095e6: 6abb         	ldr	r3, [r7, #0x28]
 80095e8: 9303         	str	r3, [sp, #0xc]
 80095ea: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8009624 <can_mcan_remove_rx_filter+0x1ec>
 80095ec: 9302         	str	r3, [sp, #0x8]
 80095ee: 2300         	movs	r3, #0x0
 80095f0: 9301         	str	r3, [sp, #0x4]
 80095f2: 2300         	movs	r3, #0x0
 80095f4: 9300         	str	r3, [sp]
 80095f6: 2300         	movs	r3, #0x0
 80095f8: 2201         	movs	r2, #0x1
 80095fa: 2000         	movs	r0, #0x0
 80095fc: f015 f8d9    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x151b2
 8009600: 2300         	movs	r3, #0x0
 8009602: 623b         	str	r3, [r7, #0x20]
; 	k_mutex_unlock(&data->lock);
 8009604: 6afb         	ldr	r3, [r7, #0x2c]
 8009606: 3310         	adds	r3, #0x10
 8009608: 4618         	mov	r0, r3
 800960a: f015 f817    	bl	0x801e63c <k_mutex_unlock> @ imm = #0x1502e
 800960e: e7ff         	b	0x8009610 <can_mcan_remove_rx_filter+0x1d8> @ imm = #-0x2
; }
 8009610: 3738         	adds	r7, #0x38
 8009612: 46bd         	mov	sp, r7
 8009614: bd80         	pop	{r7, pc}
 8009616: bf00         	nop

08009618 <$d>:
 8009618: c0 06 00 24  	.word	0x240006c0
 800961c: 3c b1 02 08  	.word	0x0802b13c
 8009620: 58 b1 02 08  	.word	0x0802b158
 8009624: 84 b1 02 08  	.word	0x0802b184

08009628 <can_mcan_configure_mram>:
; {
 8009628: b580         	push	{r7, lr}
 800962a: b090         	sub	sp, #0x40
 800962c: af04         	add	r7, sp, #0x10
 800962e: 60f8         	str	r0, [r7, #0xc]
 8009630: 60b9         	str	r1, [r7, #0x8]
 8009632: 607a         	str	r2, [r7, #0x4]
; 	const struct can_mcan_config *config = dev->config;
 8009634: 68fb         	ldr	r3, [r7, #0xc]
 8009636: 685b         	ldr	r3, [r3, #0x4]
 8009638: 62fb         	str	r3, [r7, #0x2c]
; 	err = can_mcan_exit_sleep_mode(dev);
 800963a: 68f8         	ldr	r0, [r7, #0xc]
 800963c: f7fe fb58    	bl	0x8007cf0 <can_mcan_exit_sleep_mode> @ imm = #-0x1950
 8009640: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 8009642: 6abb         	ldr	r3, [r7, #0x28]
 8009644: 2b00         	cmp	r3, #0x0
 8009646: d01c         	beq	0x8009682 <can_mcan_configure_mram+0x5a> @ imm = #0x38
; 		LOG_ERR("Failed to exit sleep mode");
 8009648: 2303         	movs	r3, #0x3
 800964a: 2b00         	cmp	r3, #0x0
 800964c: d016         	beq	0x800967c <can_mcan_configure_mram+0x54> @ imm = #0x2c
 800964e: 2301         	movs	r3, #0x1
 8009650: 75fb         	strb	r3, [r7, #0x17]
 8009652: 7dfb         	ldrb	r3, [r7, #0x17]
 8009654: f083 0301    	eor	r3, r3, #0x1
 8009658: b2db         	uxtb	r3, r3
 800965a: 2b00         	cmp	r3, #0x0
 800965c: d10e         	bne	0x800967c <can_mcan_configure_mram+0x54> @ imm = #0x1c
 800965e: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x80098ac <can_mcan_configure_mram+0x284>
 8009660: 6819         	ldr	r1, [r3]
 8009662: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x80098b0 <can_mcan_configure_mram+0x288>
 8009664: 9302         	str	r3, [sp, #0x8]
 8009666: 2300         	movs	r3, #0x0
 8009668: 9301         	str	r3, [sp, #0x4]
 800966a: 2300         	movs	r3, #0x0
 800966c: 9300         	str	r3, [sp]
 800966e: 2300         	movs	r3, #0x0
 8009670: 2201         	movs	r2, #0x1
 8009672: 2000         	movs	r0, #0x0
 8009674: f015 f89d    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x1513a
 8009678: 2300         	movs	r3, #0x0
 800967a: 613b         	str	r3, [r7, #0x10]
; 		return -EIO;
 800967c: f06f 0304    	mvn	r3, #0x4
 8009680: e10f         	b	0x80098a2 <can_mcan_configure_mram+0x27a> @ imm = #0x21e
; 	err = can_mcan_enter_init_mode(dev, K_MSEC(CAN_INIT_TIMEOUT_MS));
 8009682: f44f 707a    	mov.w	r0, #0x3e8
 8009686: f04f 0100    	mov.w	r1, #0x0
 800968a: 4602         	mov	r2, r0
 800968c: 460b         	mov	r3, r1
 800968e: 68f8         	ldr	r0, [r7, #0xc]
 8009690: f015 f8ad    	bl	0x801e7ee <can_mcan_enter_init_mode> @ imm = #0x1515a
 8009694: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 8009696: 6abb         	ldr	r3, [r7, #0x28]
 8009698: 2b00         	cmp	r3, #0x0
 800969a: d01c         	beq	0x80096d6 <can_mcan_configure_mram+0xae> @ imm = #0x38
; 		LOG_ERR("Failed to enter init mode");
 800969c: 2303         	movs	r3, #0x3
 800969e: 2b00         	cmp	r3, #0x0
 80096a0: d016         	beq	0x80096d0 <can_mcan_configure_mram+0xa8> @ imm = #0x2c
 80096a2: 2301         	movs	r3, #0x1
 80096a4: 77fb         	strb	r3, [r7, #0x1f]
 80096a6: 7ffb         	ldrb	r3, [r7, #0x1f]
 80096a8: f083 0301    	eor	r3, r3, #0x1
 80096ac: b2db         	uxtb	r3, r3
 80096ae: 2b00         	cmp	r3, #0x0
 80096b0: d10e         	bne	0x80096d0 <can_mcan_configure_mram+0xa8> @ imm = #0x1c
 80096b2: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x80098ac <can_mcan_configure_mram+0x284>
 80096b4: 6819         	ldr	r1, [r3]
 80096b6: 4b7f         	ldr	r3, [pc, #0x1fc]        @ 0x80098b4 <can_mcan_configure_mram+0x28c>
 80096b8: 9302         	str	r3, [sp, #0x8]
 80096ba: 2300         	movs	r3, #0x0
 80096bc: 9301         	str	r3, [sp, #0x4]
 80096be: 2300         	movs	r3, #0x0
 80096c0: 9300         	str	r3, [sp]
 80096c2: 2300         	movs	r3, #0x0
 80096c4: 2201         	movs	r2, #0x1
 80096c6: 2000         	movs	r0, #0x0
 80096c8: f015 f873    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x150e6
 80096cc: 2300         	movs	r3, #0x0
 80096ce: 61bb         	str	r3, [r7, #0x18]
; 		return -EIO;
 80096d0: f06f 0304    	mvn	r3, #0x4
 80096d4: e0e5         	b	0x80098a2 <can_mcan_configure_mram+0x27a> @ imm = #0x1ca
; 	can_mcan_enable_configuration_change(dev);
 80096d6: 68f8         	ldr	r0, [r7, #0xc]
 80096d8: f015 faae    	bl	0x801ec38 <can_mcan_enable_configuration_change> @ imm = #0x1555c
; 	addr = mram - mrba + config->mram_offsets[CAN_MCAN_MRAM_CFG_STD_FILTER];
 80096dc: 687a         	ldr	r2, [r7, #0x4]
 80096de: 68bb         	ldr	r3, [r7, #0x8]
 80096e0: 1ad3         	subs	r3, r2, r3
 80096e2: 6afa         	ldr	r2, [r7, #0x2c]
 80096e4: 8dd2         	ldrh	r2, [r2, #0x2e]
 80096e6: 4413         	add	r3, r2
 80096e8: 627b         	str	r3, [r7, #0x24]
; 	reg = (addr & CAN_MCAN_SIDFC_FLSSA) | FIELD_PREP(CAN_MCAN_SIDFC_LSS,
 80096ea: 6a7a         	ldr	r2, [r7, #0x24]
 80096ec: f64f 73fc    	movw	r3, #0xfffc
 80096f0: 4013         	ands	r3, r2
 80096f2: 6afa         	ldr	r2, [r7, #0x2c]
 80096f4: 8bd2         	ldrh	r2, [r2, #0x1e]
 80096f6: 0412         	lsls	r2, r2, #0x10
 80096f8: f402 027f    	and	r2, r2, #0xff0000
 80096fc: 4313         	orrs	r3, r2
 80096fe: 623b         	str	r3, [r7, #0x20]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_SIDFC, reg);
 8009700: 6a3a         	ldr	r2, [r7, #0x20]
 8009702: 2184         	movs	r1, #0x84
 8009704: 68f8         	ldr	r0, [r7, #0xc]
 8009706: f7fe fab7    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1a92
 800970a: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 800970c: 6abb         	ldr	r3, [r7, #0x28]
 800970e: 2b00         	cmp	r3, #0x0
 8009710: d001         	beq	0x8009716 <can_mcan_configure_mram+0xee> @ imm = #0x2
; 		return err;
 8009712: 6abb         	ldr	r3, [r7, #0x28]
 8009714: e0c5         	b	0x80098a2 <can_mcan_configure_mram+0x27a> @ imm = #0x18a
; 	addr = mram - mrba + config->mram_offsets[CAN_MCAN_MRAM_CFG_EXT_FILTER];
 8009716: 687a         	ldr	r2, [r7, #0x4]
 8009718: 68bb         	ldr	r3, [r7, #0x8]
 800971a: 1ad3         	subs	r3, r2, r3
 800971c: 6afa         	ldr	r2, [r7, #0x2c]
 800971e: 8e12         	ldrh	r2, [r2, #0x30]
 8009720: 4413         	add	r3, r2
 8009722: 627b         	str	r3, [r7, #0x24]
; 	reg = (addr & CAN_MCAN_XIDFC_FLESA) | FIELD_PREP(CAN_MCAN_XIDFC_LSS,
 8009724: 6a7a         	ldr	r2, [r7, #0x24]
 8009726: f64f 73fc    	movw	r3, #0xfffc
 800972a: 4013         	ands	r3, r2
 800972c: 6afa         	ldr	r2, [r7, #0x2c]
 800972e: 8c12         	ldrh	r2, [r2, #0x20]
 8009730: 0412         	lsls	r2, r2, #0x10
 8009732: f402 02fe    	and	r2, r2, #0x7f0000
 8009736: 4313         	orrs	r3, r2
 8009738: 623b         	str	r3, [r7, #0x20]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_XIDFC, reg);
 800973a: 6a3a         	ldr	r2, [r7, #0x20]
 800973c: 2188         	movs	r1, #0x88
 800973e: 68f8         	ldr	r0, [r7, #0xc]
 8009740: f7fe fa9a    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1acc
 8009744: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 8009746: 6abb         	ldr	r3, [r7, #0x28]
 8009748: 2b00         	cmp	r3, #0x0
 800974a: d001         	beq	0x8009750 <can_mcan_configure_mram+0x128> @ imm = #0x2
; 		return err;
 800974c: 6abb         	ldr	r3, [r7, #0x28]
 800974e: e0a8         	b	0x80098a2 <can_mcan_configure_mram+0x27a> @ imm = #0x150
; 	addr = mram - mrba + config->mram_offsets[CAN_MCAN_MRAM_CFG_RX_FIFO0];
 8009750: 687a         	ldr	r2, [r7, #0x4]
 8009752: 68bb         	ldr	r3, [r7, #0x8]
 8009754: 1ad3         	subs	r3, r2, r3
 8009756: 6afa         	ldr	r2, [r7, #0x2c]
 8009758: 8e52         	ldrh	r2, [r2, #0x32]
 800975a: 4413         	add	r3, r2
 800975c: 627b         	str	r3, [r7, #0x24]
; 	reg = (addr & CAN_MCAN_RXF0C_F0SA) | FIELD_PREP(CAN_MCAN_RXF0C_F0S,
 800975e: 6a7a         	ldr	r2, [r7, #0x24]
 8009760: f64f 73fc    	movw	r3, #0xfffc
 8009764: 4013         	ands	r3, r2
 8009766: 6afa         	ldr	r2, [r7, #0x2c]
 8009768: 8c52         	ldrh	r2, [r2, #0x22]
 800976a: 0412         	lsls	r2, r2, #0x10
 800976c: f402 02fe    	and	r2, r2, #0x7f0000
 8009770: 4313         	orrs	r3, r2
 8009772: 623b         	str	r3, [r7, #0x20]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_RXF0C, reg);
 8009774: 6a3a         	ldr	r2, [r7, #0x20]
 8009776: 21a0         	movs	r1, #0xa0
 8009778: 68f8         	ldr	r0, [r7, #0xc]
 800977a: f7fe fa7d    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1b06
 800977e: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 8009780: 6abb         	ldr	r3, [r7, #0x28]
 8009782: 2b00         	cmp	r3, #0x0
 8009784: d001         	beq	0x800978a <can_mcan_configure_mram+0x162> @ imm = #0x2
; 		return err;
 8009786: 6abb         	ldr	r3, [r7, #0x28]
 8009788: e08b         	b	0x80098a2 <can_mcan_configure_mram+0x27a> @ imm = #0x116
; 	addr = mram - mrba + config->mram_offsets[CAN_MCAN_MRAM_CFG_RX_FIFO1];
 800978a: 687a         	ldr	r2, [r7, #0x4]
 800978c: 68bb         	ldr	r3, [r7, #0x8]
 800978e: 1ad3         	subs	r3, r2, r3
 8009790: 6afa         	ldr	r2, [r7, #0x2c]
 8009792: 8e92         	ldrh	r2, [r2, #0x34]
 8009794: 4413         	add	r3, r2
 8009796: 627b         	str	r3, [r7, #0x24]
; 	reg = (addr & CAN_MCAN_RXF1C_F1SA) | FIELD_PREP(CAN_MCAN_RXF1C_F1S,
 8009798: 6a7a         	ldr	r2, [r7, #0x24]
 800979a: f64f 73fc    	movw	r3, #0xfffc
 800979e: 4013         	ands	r3, r2
 80097a0: 6afa         	ldr	r2, [r7, #0x2c]
 80097a2: 8c92         	ldrh	r2, [r2, #0x24]
 80097a4: 0412         	lsls	r2, r2, #0x10
 80097a6: f402 02fe    	and	r2, r2, #0x7f0000
 80097aa: 4313         	orrs	r3, r2
 80097ac: 623b         	str	r3, [r7, #0x20]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_RXF1C, reg);
 80097ae: 6a3a         	ldr	r2, [r7, #0x20]
 80097b0: 21b0         	movs	r1, #0xb0
 80097b2: 68f8         	ldr	r0, [r7, #0xc]
 80097b4: f7fe fa60    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1b40
 80097b8: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 80097ba: 6abb         	ldr	r3, [r7, #0x28]
 80097bc: 2b00         	cmp	r3, #0x0
 80097be: d001         	beq	0x80097c4 <can_mcan_configure_mram+0x19c> @ imm = #0x2
; 		return err;
 80097c0: 6abb         	ldr	r3, [r7, #0x28]
 80097c2: e06e         	b	0x80098a2 <can_mcan_configure_mram+0x27a> @ imm = #0xdc
; 	addr = mram - mrba + config->mram_offsets[CAN_MCAN_MRAM_CFG_RX_BUFFER];
 80097c4: 687a         	ldr	r2, [r7, #0x4]
 80097c6: 68bb         	ldr	r3, [r7, #0x8]
 80097c8: 1ad3         	subs	r3, r2, r3
 80097ca: 6afa         	ldr	r2, [r7, #0x2c]
 80097cc: 8ed2         	ldrh	r2, [r2, #0x36]
 80097ce: 4413         	add	r3, r2
 80097d0: 627b         	str	r3, [r7, #0x24]
; 	reg = (addr & CAN_MCAN_RXBC_RBSA);
 80097d2: 6a7a         	ldr	r2, [r7, #0x24]
 80097d4: f64f 73fc    	movw	r3, #0xfffc
 80097d8: 4013         	ands	r3, r2
 80097da: 623b         	str	r3, [r7, #0x20]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_RXBC, reg);
 80097dc: 6a3a         	ldr	r2, [r7, #0x20]
 80097de: 21ac         	movs	r1, #0xac
 80097e0: 68f8         	ldr	r0, [r7, #0xc]
 80097e2: f7fe fa49    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1b6e
 80097e6: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 80097e8: 6abb         	ldr	r3, [r7, #0x28]
 80097ea: 2b00         	cmp	r3, #0x0
 80097ec: d001         	beq	0x80097f2 <can_mcan_configure_mram+0x1ca> @ imm = #0x2
; 		return err;
 80097ee: 6abb         	ldr	r3, [r7, #0x28]
 80097f0: e057         	b	0x80098a2 <can_mcan_configure_mram+0x27a> @ imm = #0xae
; 	addr = mram - mrba + config->mram_offsets[CAN_MCAN_MRAM_CFG_TX_EVENT_FIFO];
 80097f2: 687a         	ldr	r2, [r7, #0x4]
 80097f4: 68bb         	ldr	r3, [r7, #0x8]
 80097f6: 1ad3         	subs	r3, r2, r3
 80097f8: 6afa         	ldr	r2, [r7, #0x2c]
 80097fa: 8f12         	ldrh	r2, [r2, #0x38]
 80097fc: 4413         	add	r3, r2
 80097fe: 627b         	str	r3, [r7, #0x24]
; 	reg = (addr & CAN_MCAN_TXEFC_EFSA) | FIELD_PREP(CAN_MCAN_TXEFC_EFS,
 8009800: 6a7a         	ldr	r2, [r7, #0x24]
 8009802: f64f 73fc    	movw	r3, #0xfffc
 8009806: 4013         	ands	r3, r2
 8009808: 6afa         	ldr	r2, [r7, #0x2c]
 800980a: 8d12         	ldrh	r2, [r2, #0x28]
 800980c: 0412         	lsls	r2, r2, #0x10
 800980e: f402 127c    	and	r2, r2, #0x3f0000
 8009812: 4313         	orrs	r3, r2
 8009814: 623b         	str	r3, [r7, #0x20]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_TXEFC, reg);
 8009816: 6a3a         	ldr	r2, [r7, #0x20]
 8009818: 21f0         	movs	r1, #0xf0
 800981a: 68f8         	ldr	r0, [r7, #0xc]
 800981c: f7fe fa2c    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1ba8
 8009820: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 8009822: 6abb         	ldr	r3, [r7, #0x28]
 8009824: 2b00         	cmp	r3, #0x0
 8009826: d001         	beq	0x800982c <can_mcan_configure_mram+0x204> @ imm = #0x2
; 		return err;
 8009828: 6abb         	ldr	r3, [r7, #0x28]
 800982a: e03a         	b	0x80098a2 <can_mcan_configure_mram+0x27a> @ imm = #0x74
; 	addr = mram - mrba + config->mram_offsets[CAN_MCAN_MRAM_CFG_TX_BUFFER];
 800982c: 687a         	ldr	r2, [r7, #0x4]
 800982e: 68bb         	ldr	r3, [r7, #0x8]
 8009830: 1ad3         	subs	r3, r2, r3
 8009832: 6afa         	ldr	r2, [r7, #0x2c]
 8009834: 8f52         	ldrh	r2, [r2, #0x3a]
 8009836: 4413         	add	r3, r2
 8009838: 627b         	str	r3, [r7, #0x24]
; 	reg = (addr & CAN_MCAN_TXBC_TBSA) | FIELD_PREP(CAN_MCAN_TXBC_TFQS,
 800983a: 6a7a         	ldr	r2, [r7, #0x24]
 800983c: f64f 73fc    	movw	r3, #0xfffc
 8009840: 4013         	ands	r3, r2
 8009842: 6afa         	ldr	r2, [r7, #0x2c]
 8009844: 8d52         	ldrh	r2, [r2, #0x2a]
 8009846: 0612         	lsls	r2, r2, #0x18
 8009848: f002 527c    	and	r2, r2, #0x3f000000
 800984c: 4313         	orrs	r3, r2
 800984e: f043 4380    	orr	r3, r3, #0x40000000
 8009852: 623b         	str	r3, [r7, #0x20]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_TXBC, reg);
 8009854: 6a3a         	ldr	r2, [r7, #0x20]
 8009856: 21c0         	movs	r1, #0xc0
 8009858: 68f8         	ldr	r0, [r7, #0xc]
 800985a: f7fe fa0d    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1be6
 800985e: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 8009860: 6abb         	ldr	r3, [r7, #0x28]
 8009862: 2b00         	cmp	r3, #0x0
 8009864: d001         	beq	0x800986a <can_mcan_configure_mram+0x242> @ imm = #0x2
; 		return err;
 8009866: 6abb         	ldr	r3, [r7, #0x28]
 8009868: e01b         	b	0x80098a2 <can_mcan_configure_mram+0x27a> @ imm = #0x36
; 	reg = CAN_MCAN_TXESC_TBDS;
 800986a: 2307         	movs	r3, #0x7
 800986c: 623b         	str	r3, [r7, #0x20]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_TXESC, reg);
 800986e: 6a3a         	ldr	r2, [r7, #0x20]
 8009870: 21c8         	movs	r1, #0xc8
 8009872: 68f8         	ldr	r0, [r7, #0xc]
 8009874: f7fe fa00    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1c00
 8009878: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 800987a: 6abb         	ldr	r3, [r7, #0x28]
 800987c: 2b00         	cmp	r3, #0x0
 800987e: d001         	beq	0x8009884 <can_mcan_configure_mram+0x25c> @ imm = #0x2
; 		return err;
 8009880: 6abb         	ldr	r3, [r7, #0x28]
 8009882: e00e         	b	0x80098a2 <can_mcan_configure_mram+0x27a> @ imm = #0x1c
; 	reg = CAN_MCAN_RXESC_RBDS | CAN_MCAN_RXESC_F1DS | CAN_MCAN_RXESC_F0DS;
 8009884: f240 7377    	movw	r3, #0x777
 8009888: 623b         	str	r3, [r7, #0x20]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_RXESC, reg);
 800988a: 6a3a         	ldr	r2, [r7, #0x20]
 800988c: 21bc         	movs	r1, #0xbc
 800988e: 68f8         	ldr	r0, [r7, #0xc]
 8009890: f7fe f9f2    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1c1c
 8009894: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 8009896: 6abb         	ldr	r3, [r7, #0x28]
 8009898: 2b00         	cmp	r3, #0x0
 800989a: d001         	beq	0x80098a0 <can_mcan_configure_mram+0x278> @ imm = #0x2
; 		return err;
 800989c: 6abb         	ldr	r3, [r7, #0x28]
 800989e: e000         	b	0x80098a2 <can_mcan_configure_mram+0x27a> @ imm = #0x0
; 	return 0;
 80098a0: 2300         	movs	r3, #0x0
; }
 80098a2: 4618         	mov	r0, r3
 80098a4: 3730         	adds	r7, #0x30
 80098a6: 46bd         	mov	sp, r7
 80098a8: bd80         	pop	{r7, pc}
 80098aa: bf00         	nop

080098ac <$d>:
 80098ac: c0 06 00 24  	.word	0x240006c0
 80098b0: b0 b1 02 08  	.word	0x0802b1b0
 80098b4: e8 ac 02 08  	.word	0x0802ace8

080098b8 <can_mcan_init>:
; {
 80098b8: b580         	push	{r7, lr}
 80098ba: b0a0         	sub	sp, #0x80
 80098bc: af08         	add	r7, sp, #0x20
 80098be: 6078         	str	r0, [r7, #0x4]
; 	const struct can_mcan_config *config = dev->config;
 80098c0: 687b         	ldr	r3, [r7, #0x4]
 80098c2: 685b         	ldr	r3, [r3, #0x4]
 80098c4: 653b         	str	r3, [r7, #0x50]
; 	const struct can_mcan_callbacks *cbs = config->callbacks;
 80098c6: 6d3b         	ldr	r3, [r7, #0x50]
 80098c8: 699b         	ldr	r3, [r3, #0x18]
 80098ca: 64fb         	str	r3, [r7, #0x4c]
; 	struct can_mcan_data *data = dev->data;
 80098cc: 687b         	ldr	r3, [r7, #0x4]
 80098ce: 691b         	ldr	r3, [r3, #0x10]
 80098d0: 64bb         	str	r3, [r7, #0x48]
; 	struct can_timing timing = { 0 };
 80098d2: f107 030c    	add.w	r3, r7, #0xc
 80098d6: 2200         	movs	r2, #0x0
 80098d8: 601a         	str	r2, [r3]
 80098da: 605a         	str	r2, [r3, #0x4]
 80098dc: 811a         	strh	r2, [r3, #0x8]
; 	k_mutex_init(&data->lock);
 80098de: 6cbb         	ldr	r3, [r7, #0x48]
 80098e0: 3310         	adds	r3, #0x10
 80098e2: 4618         	mov	r0, r3
 80098e4: f014 fe8e    	bl	0x801e604 <k_mutex_init> @ imm = #0x14d1c
; 	k_mutex_init(&data->tx_mtx);
 80098e8: 6cbb         	ldr	r3, [r7, #0x48]
 80098ea: 3334         	adds	r3, #0x34
 80098ec: 4618         	mov	r0, r3
 80098ee: f014 fe89    	bl	0x801e604 <k_mutex_init> @ imm = #0x14d12
; 	k_sem_init(&data->tx_sem, cbs->num_tx, cbs->num_tx);
 80098f2: 6cbb         	ldr	r3, [r7, #0x48]
 80098f4: f103 0024    	add.w	r0, r3, #0x24
 80098f8: 6cfb         	ldr	r3, [r7, #0x4c]
 80098fa: 7b1b         	ldrb	r3, [r3, #0xc]
 80098fc: 4619         	mov	r1, r3
 80098fe: 6cfb         	ldr	r3, [r7, #0x4c]
 8009900: 7b1b         	ldrb	r3, [r3, #0xc]
 8009902: 461a         	mov	r2, r3
 8009904: f014 fea6    	bl	0x801e654 <k_sem_init>  @ imm = #0x14d4c
; 	if (config->common.phy != NULL) {
 8009908: 6d3b         	ldr	r3, [r7, #0x50]
 800990a: 681b         	ldr	r3, [r3]
 800990c: 2b00         	cmp	r3, #0x0
 800990e: d029         	beq	0x8009964 <can_mcan_init+0xac> @ imm = #0x52
; 		if (!device_is_ready(config->common.phy)) {
 8009910: 6d3b         	ldr	r3, [r7, #0x50]
 8009912: 681b         	ldr	r3, [r3]
 8009914: 4618         	mov	r0, r3
 8009916: f014 fe52    	bl	0x801e5be <device_is_ready> @ imm = #0x14ca4
 800991a: 4603         	mov	r3, r0
 800991c: f083 0301    	eor	r3, r3, #0x1
 8009920: b2db         	uxtb	r3, r3
 8009922: 2b00         	cmp	r3, #0x0
 8009924: d01e         	beq	0x8009964 <can_mcan_init+0xac> @ imm = #0x3c
; 			LOG_ERR("CAN transceiver not ready");
 8009926: 2303         	movs	r3, #0x3
 8009928: 2b00         	cmp	r3, #0x0
 800992a: d018         	beq	0x800995e <can_mcan_init+0xa6> @ imm = #0x30
 800992c: 2301         	movs	r3, #0x1
 800992e: f887 3057    	strb.w	r3, [r7, #0x57]
 8009932: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8009936: f083 0301    	eor	r3, r3, #0x1
 800993a: b2db         	uxtb	r3, r3
 800993c: 2b00         	cmp	r3, #0x0
 800993e: d10e         	bne	0x800995e <can_mcan_init+0xa6> @ imm = #0x1c
 8009940: 4b76         	ldr	r3, [pc, #0x1d8]        @ 0x8009b1c <can_mcan_init+0x264>
 8009942: 6819         	ldr	r1, [r3]
 8009944: 4b76         	ldr	r3, [pc, #0x1d8]        @ 0x8009b20 <can_mcan_init+0x268>
 8009946: 9302         	str	r3, [sp, #0x8]
 8009948: 2300         	movs	r3, #0x0
 800994a: 9301         	str	r3, [sp, #0x4]
 800994c: 2300         	movs	r3, #0x0
 800994e: 9300         	str	r3, [sp]
 8009950: 2300         	movs	r3, #0x0
 8009952: 2201         	movs	r2, #0x1
 8009954: 2000         	movs	r0, #0x0
 8009956: f014 ff2c    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x14e58
 800995a: 2300         	movs	r3, #0x0
 800995c: 65bb         	str	r3, [r7, #0x58]
; 			return -ENODEV;
 800995e: f06f 0312    	mvn	r3, #0x12
 8009962: e195         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x32a
; 	err = can_mcan_exit_sleep_mode(dev);
 8009964: 6878         	ldr	r0, [r7, #0x4]
 8009966: f7fe f9c3    	bl	0x8007cf0 <can_mcan_exit_sleep_mode> @ imm = #-0x1c7a
 800996a: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 800996c: 6dfb         	ldr	r3, [r7, #0x5c]
 800996e: 2b00         	cmp	r3, #0x0
 8009970: d01c         	beq	0x80099ac <can_mcan_init+0xf4> @ imm = #0x38
; 		LOG_ERR("Failed to exit sleep mode");
 8009972: 2303         	movs	r3, #0x3
 8009974: 2b00         	cmp	r3, #0x0
 8009976: d016         	beq	0x80099a6 <can_mcan_init+0xee> @ imm = #0x2c
 8009978: 2301         	movs	r3, #0x1
 800997a: 77fb         	strb	r3, [r7, #0x1f]
 800997c: 7ffb         	ldrb	r3, [r7, #0x1f]
 800997e: f083 0301    	eor	r3, r3, #0x1
 8009982: b2db         	uxtb	r3, r3
 8009984: 2b00         	cmp	r3, #0x0
 8009986: d10e         	bne	0x80099a6 <can_mcan_init+0xee> @ imm = #0x1c
 8009988: 4b64         	ldr	r3, [pc, #0x190]        @ 0x8009b1c <can_mcan_init+0x264>
 800998a: 6819         	ldr	r1, [r3]
 800998c: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8009b24 <can_mcan_init+0x26c>
 800998e: 9302         	str	r3, [sp, #0x8]
 8009990: 2300         	movs	r3, #0x0
 8009992: 9301         	str	r3, [sp, #0x4]
 8009994: 2300         	movs	r3, #0x0
 8009996: 9300         	str	r3, [sp]
 8009998: 2300         	movs	r3, #0x0
 800999a: 2201         	movs	r2, #0x1
 800999c: 2000         	movs	r0, #0x0
 800999e: f014 ff08    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x14e10
 80099a2: 2300         	movs	r3, #0x0
 80099a4: 61bb         	str	r3, [r7, #0x18]
; 		return -EIO;
 80099a6: f06f 0304    	mvn	r3, #0x4
 80099aa: e171         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x2e2
; 	err = can_mcan_enter_init_mode(dev, K_MSEC(CAN_INIT_TIMEOUT_MS));
 80099ac: f44f 707a    	mov.w	r0, #0x3e8
 80099b0: f04f 0100    	mov.w	r1, #0x0
 80099b4: 4602         	mov	r2, r0
 80099b6: 460b         	mov	r3, r1
 80099b8: 6878         	ldr	r0, [r7, #0x4]
 80099ba: f014 ff18    	bl	0x801e7ee <can_mcan_enter_init_mode> @ imm = #0x14e30
 80099be: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 80099c0: 6dfb         	ldr	r3, [r7, #0x5c]
 80099c2: 2b00         	cmp	r3, #0x0
 80099c4: d01e         	beq	0x8009a04 <can_mcan_init+0x14c> @ imm = #0x3c
; 		LOG_ERR("Failed to enter init mode");
 80099c6: 2303         	movs	r3, #0x3
 80099c8: 2b00         	cmp	r3, #0x0
 80099ca: d018         	beq	0x80099fe <can_mcan_init+0x146> @ imm = #0x30
 80099cc: 2301         	movs	r3, #0x1
 80099ce: f887 3027    	strb.w	r3, [r7, #0x27]
 80099d2: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80099d6: f083 0301    	eor	r3, r3, #0x1
 80099da: b2db         	uxtb	r3, r3
 80099dc: 2b00         	cmp	r3, #0x0
 80099de: d10e         	bne	0x80099fe <can_mcan_init+0x146> @ imm = #0x1c
 80099e0: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8009b1c <can_mcan_init+0x264>
 80099e2: 6819         	ldr	r1, [r3]
 80099e4: 4b50         	ldr	r3, [pc, #0x140]        @ 0x8009b28 <can_mcan_init+0x270>
 80099e6: 9302         	str	r3, [sp, #0x8]
 80099e8: 2300         	movs	r3, #0x0
 80099ea: 9301         	str	r3, [sp, #0x4]
 80099ec: 2300         	movs	r3, #0x0
 80099ee: 9300         	str	r3, [sp]
 80099f0: 2300         	movs	r3, #0x0
 80099f2: 2201         	movs	r2, #0x1
 80099f4: 2000         	movs	r0, #0x0
 80099f6: f014 fedc    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x14db8
 80099fa: 2300         	movs	r3, #0x0
 80099fc: 623b         	str	r3, [r7, #0x20]
; 		return -EIO;
 80099fe: f06f 0304    	mvn	r3, #0x4
 8009a02: e145         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x28a
; 	can_mcan_enable_configuration_change(dev);
 8009a04: 6878         	ldr	r0, [r7, #0x4]
 8009a06: f015 f917    	bl	0x801ec38 <can_mcan_enable_configuration_change> @ imm = #0x1522e
; 	err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &reg);
 8009a0a: f107 0308    	add.w	r3, r7, #0x8
 8009a0e: 461a         	mov	r2, r3
 8009a10: 2118         	movs	r1, #0x18
 8009a12: 6878         	ldr	r0, [r7, #0x4]
 8009a14: f7fe f8f4    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x1e18
 8009a18: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 8009a1a: 6dfb         	ldr	r3, [r7, #0x5c]
 8009a1c: 2b00         	cmp	r3, #0x0
 8009a1e: d001         	beq	0x8009a24 <can_mcan_init+0x16c> @ imm = #0x2
; 		return err;
 8009a20: 6dfb         	ldr	r3, [r7, #0x5c]
 8009a22: e135         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x26a
; 	reg &= ~(CAN_MCAN_CCCR_FDOE | CAN_MCAN_CCCR_BRSE | CAN_MCAN_CCCR_TEST | CAN_MCAN_CCCR_MON |
 8009a24: 68bb         	ldr	r3, [r7, #0x8]
 8009a26: f423 7369    	bic	r3, r3, #0x3a4
 8009a2a: 60bb         	str	r3, [r7, #0x8]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_CCCR, reg);
 8009a2c: 68bb         	ldr	r3, [r7, #0x8]
 8009a2e: 461a         	mov	r2, r3
 8009a30: 2118         	movs	r1, #0x18
 8009a32: 6878         	ldr	r0, [r7, #0x4]
 8009a34: f7fe f920    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1dc0
 8009a38: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 8009a3a: 6dfb         	ldr	r3, [r7, #0x5c]
 8009a3c: 2b00         	cmp	r3, #0x0
 8009a3e: d001         	beq	0x8009a44 <can_mcan_init+0x18c> @ imm = #0x2
; 		return err;
 8009a40: 6dfb         	ldr	r3, [r7, #0x5c]
 8009a42: e125         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x24a
; 	err = can_mcan_read_reg(dev, CAN_MCAN_TEST, &reg);
 8009a44: f107 0308    	add.w	r3, r7, #0x8
 8009a48: 461a         	mov	r2, r3
 8009a4a: 2110         	movs	r1, #0x10
 8009a4c: 6878         	ldr	r0, [r7, #0x4]
 8009a4e: f7fe f8d7    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x1e52
 8009a52: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 8009a54: 6dfb         	ldr	r3, [r7, #0x5c]
 8009a56: 2b00         	cmp	r3, #0x0
 8009a58: d001         	beq	0x8009a5e <can_mcan_init+0x1a6> @ imm = #0x2
; 		return err;
 8009a5a: 6dfb         	ldr	r3, [r7, #0x5c]
 8009a5c: e118         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x230
; 	reg &= ~(CAN_MCAN_TEST_LBCK);
 8009a5e: 68bb         	ldr	r3, [r7, #0x8]
 8009a60: f023 0310    	bic	r3, r3, #0x10
 8009a64: 60bb         	str	r3, [r7, #0x8]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_TEST, reg);
 8009a66: 68bb         	ldr	r3, [r7, #0x8]
 8009a68: 461a         	mov	r2, r3
 8009a6a: 2110         	movs	r1, #0x10
 8009a6c: 6878         	ldr	r0, [r7, #0x4]
 8009a6e: f7fe f903    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1dfa
 8009a72: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 8009a74: 6dfb         	ldr	r3, [r7, #0x5c]
 8009a76: 2b00         	cmp	r3, #0x0
 8009a78: d001         	beq	0x8009a7e <can_mcan_init+0x1c6> @ imm = #0x2
; 		return err;
 8009a7a: 6dfb         	ldr	r3, [r7, #0x5c]
 8009a7c: e108         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x210
; 	err = can_mcan_read_reg(dev, CAN_MCAN_GFC, &reg);
 8009a7e: f107 0308    	add.w	r3, r7, #0x8
 8009a82: 461a         	mov	r2, r3
 8009a84: 2180         	movs	r1, #0x80
 8009a86: 6878         	ldr	r0, [r7, #0x4]
 8009a88: f7fe f8ba    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x1e8c
 8009a8c: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 8009a8e: 6dfb         	ldr	r3, [r7, #0x5c]
 8009a90: 2b00         	cmp	r3, #0x0
 8009a92: d001         	beq	0x8009a98 <can_mcan_init+0x1e0> @ imm = #0x2
; 		return err;
 8009a94: 6dfb         	ldr	r3, [r7, #0x5c]
 8009a96: e0fb         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x1f6
; 	reg |= FIELD_PREP(CAN_MCAN_GFC_ANFE, 0x2) | FIELD_PREP(CAN_MCAN_GFC_ANFS, 0x2);
 8009a98: 68bb         	ldr	r3, [r7, #0x8]
 8009a9a: f043 0328    	orr	r3, r3, #0x28
 8009a9e: 60bb         	str	r3, [r7, #0x8]
; 		reg |= CAN_MCAN_GFC_RRFS | CAN_MCAN_GFC_RRFE;
 8009aa0: 68bb         	ldr	r3, [r7, #0x8]
 8009aa2: f043 0303    	orr	r3, r3, #0x3
 8009aa6: 60bb         	str	r3, [r7, #0x8]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_GFC, reg);
 8009aa8: 68bb         	ldr	r3, [r7, #0x8]
 8009aaa: 461a         	mov	r2, r3
 8009aac: 2180         	movs	r1, #0x80
 8009aae: 6878         	ldr	r0, [r7, #0x4]
 8009ab0: f7fe f8e2    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1e3c
 8009ab4: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 8009ab6: 6dfb         	ldr	r3, [r7, #0x5c]
 8009ab8: 2b00         	cmp	r3, #0x0
 8009aba: d001         	beq	0x8009ac0 <can_mcan_init+0x208> @ imm = #0x2
; 		return err;
 8009abc: 6dfb         	ldr	r3, [r7, #0x5c]
 8009abe: e0e7         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x1ce
; 	err = can_calc_timing(dev, &timing, config->common.bitrate,
 8009ac0: 6d3b         	ldr	r3, [r7, #0x50]
 8009ac2: 68da         	ldr	r2, [r3, #0xc]
; 			      config->common.sample_point);
 8009ac4: 6d3b         	ldr	r3, [r7, #0x50]
 8009ac6: 8a1b         	ldrh	r3, [r3, #0x10]
; 	err = can_calc_timing(dev, &timing, config->common.bitrate,
 8009ac8: f107 010c    	add.w	r1, r7, #0xc
 8009acc: 6878         	ldr	r0, [r7, #0x4]
 8009ace: f014 fdec    	bl	0x801e6aa <can_calc_timing> @ imm = #0x14bd8
 8009ad2: 65f8         	str	r0, [r7, #0x5c]
; 	if (err == -EINVAL) {
 8009ad4: 6dfb         	ldr	r3, [r7, #0x5c]
 8009ad6: f113 0f16    	cmn.w	r3, #0x16
 8009ada: d129         	bne	0x8009b30 <can_mcan_init+0x278> @ imm = #0x52
; 		LOG_ERR("Can't find timing for given param");
 8009adc: 2303         	movs	r3, #0x3
 8009ade: 2b00         	cmp	r3, #0x0
 8009ae0: d018         	beq	0x8009b14 <can_mcan_init+0x25c> @ imm = #0x30
 8009ae2: 2301         	movs	r3, #0x1
 8009ae4: f887 302f    	strb.w	r3, [r7, #0x2f]
 8009ae8: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8009aec: f083 0301    	eor	r3, r3, #0x1
 8009af0: b2db         	uxtb	r3, r3
 8009af2: 2b00         	cmp	r3, #0x0
 8009af4: d10e         	bne	0x8009b14 <can_mcan_init+0x25c> @ imm = #0x1c
 8009af6: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8009b1c <can_mcan_init+0x264>
 8009af8: 6819         	ldr	r1, [r3]
 8009afa: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8009b2c <can_mcan_init+0x274>
 8009afc: 9302         	str	r3, [sp, #0x8]
 8009afe: 2300         	movs	r3, #0x0
 8009b00: 9301         	str	r3, [sp, #0x4]
 8009b02: 2300         	movs	r3, #0x0
 8009b04: 9300         	str	r3, [sp]
 8009b06: 2300         	movs	r3, #0x0
 8009b08: 2201         	movs	r2, #0x1
 8009b0a: 2000         	movs	r0, #0x0
 8009b0c: f014 fe51    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x14ca2
 8009b10: 2300         	movs	r3, #0x0
 8009b12: 62bb         	str	r3, [r7, #0x28]
; 		return -EIO;
 8009b14: f06f 0304    	mvn	r3, #0x4
 8009b18: e0ba         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x174
 8009b1a: bf00         	nop

08009b1c <$d>:
 8009b1c: c0 06 00 24  	.word	0x240006c0
 8009b20: cc b1 02 08  	.word	0x0802b1cc
 8009b24: b0 b1 02 08  	.word	0x0802b1b0
 8009b28: e8 ac 02 08  	.word	0x0802ace8
 8009b2c: e8 b1 02 08  	.word	0x0802b1e8

08009b30 <$t>:
; 	LOG_DBG("Presc: %d, TS1: %d, TS2: %d", timing.prescaler, timing.phase_seg1,
 8009b30: 2303         	movs	r3, #0x3
 8009b32: 2b03         	cmp	r3, #0x3
 8009b34: d920         	bls	0x8009b78 <can_mcan_init+0x2c0> @ imm = #0x40
 8009b36: 2301         	movs	r3, #0x1
 8009b38: f887 3047    	strb.w	r3, [r7, #0x47]
 8009b3c: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8009b40: f083 0301    	eor	r3, r3, #0x1
 8009b44: b2db         	uxtb	r3, r3
 8009b46: 2b00         	cmp	r3, #0x0
 8009b48: d116         	bne	0x8009b78 <can_mcan_init+0x2c0> @ imm = #0x2c
 8009b4a: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8009c98 <can_mcan_init+0x3e0>
 8009b4c: 6819         	ldr	r1, [r3]
 8009b4e: 8abb         	ldrh	r3, [r7, #0x14]
 8009b50: 8a3a         	ldrh	r2, [r7, #0x10]
 8009b52: 8a78         	ldrh	r0, [r7, #0x12]
 8009b54: 9006         	str	r0, [sp, #0x18]
 8009b56: 9205         	str	r2, [sp, #0x14]
 8009b58: 9304         	str	r3, [sp, #0x10]
 8009b5a: 4b50         	ldr	r3, [pc, #0x140]        @ 0x8009c9c <can_mcan_init+0x3e4>
 8009b5c: 9303         	str	r3, [sp, #0xc]
 8009b5e: 4b50         	ldr	r3, [pc, #0x140]        @ 0x8009ca0 <can_mcan_init+0x3e8>
 8009b60: 9302         	str	r3, [sp, #0x8]
 8009b62: 2308         	movs	r3, #0x8
 8009b64: 9301         	str	r3, [sp, #0x4]
 8009b66: 2300         	movs	r3, #0x0
 8009b68: 9300         	str	r3, [sp]
 8009b6a: 2300         	movs	r3, #0x0
 8009b6c: 2204         	movs	r2, #0x4
 8009b6e: 2000         	movs	r0, #0x0
 8009b70: f014 fe1f    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x14c3e
 8009b74: 2300         	movs	r3, #0x0
 8009b76: 643b         	str	r3, [r7, #0x40]
; 	LOG_DBG("Sample-point err : %d", err);
 8009b78: 2303         	movs	r3, #0x3
 8009b7a: 2b03         	cmp	r3, #0x3
 8009b7c: d91c         	bls	0x8009bb8 <can_mcan_init+0x300> @ imm = #0x38
 8009b7e: 2301         	movs	r3, #0x1
 8009b80: f887 303f    	strb.w	r3, [r7, #0x3f]
 8009b84: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8009b88: f083 0301    	eor	r3, r3, #0x1
 8009b8c: b2db         	uxtb	r3, r3
 8009b8e: 2b00         	cmp	r3, #0x0
 8009b90: d112         	bne	0x8009bb8 <can_mcan_init+0x300> @ imm = #0x24
 8009b92: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8009c98 <can_mcan_init+0x3e0>
 8009b94: 6819         	ldr	r1, [r3]
 8009b96: 6dfb         	ldr	r3, [r7, #0x5c]
 8009b98: 9304         	str	r3, [sp, #0x10]
 8009b9a: 4b40         	ldr	r3, [pc, #0x100]        @ 0x8009c9c <can_mcan_init+0x3e4>
 8009b9c: 9303         	str	r3, [sp, #0xc]
 8009b9e: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8009ca4 <can_mcan_init+0x3ec>
 8009ba0: 9302         	str	r3, [sp, #0x8]
 8009ba2: 2308         	movs	r3, #0x8
 8009ba4: 9301         	str	r3, [sp, #0x4]
 8009ba6: 2300         	movs	r3, #0x0
 8009ba8: 9300         	str	r3, [sp]
 8009baa: 2300         	movs	r3, #0x0
 8009bac: 2204         	movs	r2, #0x4
 8009bae: 2000         	movs	r0, #0x0
 8009bb0: f014 fdff    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x14bfe
 8009bb4: 2300         	movs	r3, #0x0
 8009bb6: 63bb         	str	r3, [r7, #0x38]
; 	err = can_set_timing(dev, &timing);
 8009bb8: f107 030c    	add.w	r3, r7, #0xc
 8009bbc: 4619         	mov	r1, r3
 8009bbe: 6878         	ldr	r0, [r7, #0x4]
 8009bc0: f014 fd85    	bl	0x801e6ce <can_set_timing> @ imm = #0x14b0a
 8009bc4: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 8009bc6: 6dfb         	ldr	r3, [r7, #0x5c]
 8009bc8: 2b00         	cmp	r3, #0x0
 8009bca: d020         	beq	0x8009c0e <can_mcan_init+0x356> @ imm = #0x40
; 		LOG_ERR("failed to set timing (err %d)", err);
 8009bcc: 2303         	movs	r3, #0x3
 8009bce: 2b00         	cmp	r3, #0x0
 8009bd0: d01a         	beq	0x8009c08 <can_mcan_init+0x350> @ imm = #0x34
 8009bd2: 2301         	movs	r3, #0x1
 8009bd4: f887 3037    	strb.w	r3, [r7, #0x37]
 8009bd8: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8009bdc: f083 0301    	eor	r3, r3, #0x1
 8009be0: b2db         	uxtb	r3, r3
 8009be2: 2b00         	cmp	r3, #0x0
 8009be4: d110         	bne	0x8009c08 <can_mcan_init+0x350> @ imm = #0x20
 8009be6: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8009c98 <can_mcan_init+0x3e0>
 8009be8: 6819         	ldr	r1, [r3]
 8009bea: 6dfb         	ldr	r3, [r7, #0x5c]
 8009bec: 9303         	str	r3, [sp, #0xc]
 8009bee: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8009ca8 <can_mcan_init+0x3f0>
 8009bf0: 9302         	str	r3, [sp, #0x8]
 8009bf2: 2300         	movs	r3, #0x0
 8009bf4: 9301         	str	r3, [sp, #0x4]
 8009bf6: 2300         	movs	r3, #0x0
 8009bf8: 9300         	str	r3, [sp]
 8009bfa: 2300         	movs	r3, #0x0
 8009bfc: 2201         	movs	r2, #0x1
 8009bfe: 2000         	movs	r0, #0x0
 8009c00: f014 fdd7    	bl	0x801e7b2 <z_log_msg_runtime_create> @ imm = #0x14bae
 8009c04: 2300         	movs	r3, #0x0
 8009c06: 633b         	str	r3, [r7, #0x30]
; 		return -ENODEV;
 8009c08: f06f 0312    	mvn	r3, #0x12
 8009c0c: e040         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x80
; 	reg = CAN_MCAN_IE_BOE | CAN_MCAN_IE_EWE | CAN_MCAN_IE_EPE | CAN_MCAN_IE_MRAFE |
 8009c0e: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8009cac <can_mcan_init+0x3f4>
 8009c10: 60bb         	str	r3, [r7, #0x8]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_IE, reg);
 8009c12: 68bb         	ldr	r3, [r7, #0x8]
 8009c14: 461a         	mov	r2, r3
 8009c16: 2154         	movs	r1, #0x54
 8009c18: 6878         	ldr	r0, [r7, #0x4]
 8009c1a: f7fe f82d    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1fa6
 8009c1e: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 8009c20: 6dfb         	ldr	r3, [r7, #0x5c]
 8009c22: 2b00         	cmp	r3, #0x0
 8009c24: d001         	beq	0x8009c2a <can_mcan_init+0x372> @ imm = #0x2
; 		return err;
 8009c26: 6dfb         	ldr	r3, [r7, #0x5c]
 8009c28: e032         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x64
; 	reg = CAN_MCAN_ILS_RF0NL | CAN_MCAN_ILS_RF1NL | CAN_MCAN_ILS_RF0LL | CAN_MCAN_ILS_RF1LL;
 8009c2a: 2399         	movs	r3, #0x99
 8009c2c: 60bb         	str	r3, [r7, #0x8]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_ILS, reg);
 8009c2e: 68bb         	ldr	r3, [r7, #0x8]
 8009c30: 461a         	mov	r2, r3
 8009c32: 2158         	movs	r1, #0x58
 8009c34: 6878         	ldr	r0, [r7, #0x4]
 8009c36: f7fe f81f    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1fc2
 8009c3a: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 8009c3c: 6dfb         	ldr	r3, [r7, #0x5c]
 8009c3e: 2b00         	cmp	r3, #0x0
 8009c40: d001         	beq	0x8009c46 <can_mcan_init+0x38e> @ imm = #0x2
; 		return err;
 8009c42: 6dfb         	ldr	r3, [r7, #0x5c]
 8009c44: e024         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x48
; 	reg = CAN_MCAN_ILE_EINT0 | CAN_MCAN_ILE_EINT1;
 8009c46: 2303         	movs	r3, #0x3
 8009c48: 60bb         	str	r3, [r7, #0x8]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_ILE, reg);
 8009c4a: 68bb         	ldr	r3, [r7, #0x8]
 8009c4c: 461a         	mov	r2, r3
 8009c4e: 215c         	movs	r1, #0x5c
 8009c50: 6878         	ldr	r0, [r7, #0x4]
 8009c52: f7fe f811    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1fde
 8009c56: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 8009c58: 6dfb         	ldr	r3, [r7, #0x5c]
 8009c5a: 2b00         	cmp	r3, #0x0
 8009c5c: d001         	beq	0x8009c62 <can_mcan_init+0x3aa> @ imm = #0x2
; 		return err;
 8009c5e: 6dfb         	ldr	r3, [r7, #0x5c]
 8009c60: e016         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0x2c
; 	reg = CAN_MCAN_TXBTIE_TIE;
 8009c62: f04f 33ff    	mov.w	r3, #0xffffffff
 8009c66: 60bb         	str	r3, [r7, #0x8]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_TXBTIE, reg);
 8009c68: 68bb         	ldr	r3, [r7, #0x8]
 8009c6a: 461a         	mov	r2, r3
 8009c6c: 21e0         	movs	r1, #0xe0
 8009c6e: 6878         	ldr	r0, [r7, #0x4]
 8009c70: f7fe f802    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1ffc
 8009c74: 65f8         	str	r0, [r7, #0x5c]
; 	if (err != 0) {
 8009c76: 6dfb         	ldr	r3, [r7, #0x5c]
 8009c78: 2b00         	cmp	r3, #0x0
 8009c7a: d001         	beq	0x8009c80 <can_mcan_init+0x3c8> @ imm = #0x2
; 		return err;
 8009c7c: 6dfb         	ldr	r3, [r7, #0x5c]
 8009c7e: e007         	b	0x8009c90 <can_mcan_init+0x3d8> @ imm = #0xe
; 	return can_mcan_clear_mram(dev, 0, config->mram_size);
 8009c80: 6d3b         	ldr	r3, [r7, #0x50]
 8009c82: 6bdb         	ldr	r3, [r3, #0x3c]
 8009c84: 461a         	mov	r2, r3
 8009c86: 2100         	movs	r1, #0x0
 8009c88: 6878         	ldr	r0, [r7, #0x4]
 8009c8a: f014 fd5e    	bl	0x801e74a <can_mcan_clear_mram> @ imm = #0x14abc
 8009c8e: 4603         	mov	r3, r0
; }
 8009c90: 4618         	mov	r0, r3
 8009c92: 3760         	adds	r7, #0x60
 8009c94: 46bd         	mov	sp, r7
 8009c96: bd80         	pop	{r7, pc}

08009c98 <$d>:
 8009c98: c0 06 00 24  	.word	0x240006c0
 8009c9c: fc ce 02 08  	.word	0x0802cefc
 8009ca0: 0c b2 02 08  	.word	0x0802b20c
 8009ca4: 2c b2 02 08  	.word	0x0802b22c
 8009ca8: 48 b2 02 08  	.word	0x0802b248
 8009cac: 99 90 82 03  	.word	0x03829099

08009cb0 <can_stm32h7_get_core_clock>:
; {
 8009cb0: b580         	push	{r7, lr}
 8009cb2: b08a         	sub	sp, #0x28
 8009cb4: af04         	add	r7, sp, #0x10
 8009cb6: 6078         	str	r0, [r7, #0x4]
 8009cb8: 6039         	str	r1, [r7]
; 	const uint32_t rate_tmp = LL_RCC_GetFDCANClockFreq(LL_RCC_FDCAN_CLKSOURCE);
 8009cba: f04f 5040    	mov.w	r0, #0x30000000
 8009cbe: f00a fa21    	bl	0x8014104 <LL_RCC_GetFDCANClockFreq> @ imm = #0xa442
 8009cc2: 6178         	str	r0, [r7, #0x14]
; 	if (rate_tmp == LL_RCC_PERIPH_FREQUENCY_NO) {
 8009cc4: 697b         	ldr	r3, [r7, #0x14]
 8009cc6: 2b00         	cmp	r3, #0x0
 8009cc8: d11c         	bne	0x8009d04 <can_stm32h7_get_core_clock+0x54> @ imm = #0x38
; 		LOG_ERR("Can't read core clock");
 8009cca: 2303         	movs	r3, #0x3
 8009ccc: 2b00         	cmp	r3, #0x0
 8009cce: d016         	beq	0x8009cfe <can_stm32h7_get_core_clock+0x4e> @ imm = #0x2c
 8009cd0: 2301         	movs	r3, #0x1
 8009cd2: 73fb         	strb	r3, [r7, #0xf]
 8009cd4: 7bfb         	ldrb	r3, [r7, #0xf]
 8009cd6: f083 0301    	eor	r3, r3, #0x1
 8009cda: b2db         	uxtb	r3, r3
 8009cdc: 2b00         	cmp	r3, #0x0
 8009cde: d10e         	bne	0x8009cfe <can_stm32h7_get_core_clock+0x4e> @ imm = #0x1c
 8009ce0: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8009d38 <can_stm32h7_get_core_clock+0x88>
 8009ce2: 6819         	ldr	r1, [r3]
 8009ce4: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8009d3c <can_stm32h7_get_core_clock+0x8c>
 8009ce6: 9302         	str	r3, [sp, #0x8]
 8009ce8: 2300         	movs	r3, #0x0
 8009cea: 9301         	str	r3, [sp, #0x4]
 8009cec: 2300         	movs	r3, #0x0
 8009cee: 9300         	str	r3, [sp]
 8009cf0: 2300         	movs	r3, #0x0
 8009cf2: 2201         	movs	r2, #0x1
 8009cf4: 2000         	movs	r0, #0x0
 8009cf6: f015 f8bc    	bl	0x801ee72 <z_log_msg_runtime_create> @ imm = #0x15178
 8009cfa: 2300         	movs	r3, #0x0
 8009cfc: 60bb         	str	r3, [r7, #0x8]
; 		return -EIO;
 8009cfe: f06f 0304    	mvn	r3, #0x4
 8009d02: e014         	b	0x8009d2e <can_stm32h7_get_core_clock+0x7e> @ imm = #0x28
; 	cdiv = FIELD_GET(FDCANCCU_CCFG_CDIV, FDCAN_CCU->CCFG);
 8009d04: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8009d40 <can_stm32h7_get_core_clock+0x90>
 8009d06: 685b         	ldr	r3, [r3, #0x4]
 8009d08: f403 2370    	and	r3, r3, #0xf0000
 8009d0c: 0c1b         	lsrs	r3, r3, #0x10
 8009d0e: 613b         	str	r3, [r7, #0x10]
; 	if (cdiv == 0U) {
 8009d10: 693b         	ldr	r3, [r7, #0x10]
 8009d12: 2b00         	cmp	r3, #0x0
 8009d14: d103         	bne	0x8009d1e <can_stm32h7_get_core_clock+0x6e> @ imm = #0x6
; 		*rate = rate_tmp;
 8009d16: 683b         	ldr	r3, [r7]
 8009d18: 697a         	ldr	r2, [r7, #0x14]
 8009d1a: 601a         	str	r2, [r3]
 8009d1c: e006         	b	0x8009d2c <can_stm32h7_get_core_clock+0x7c> @ imm = #0xc
; 		*rate = rate_tmp / (cdiv << 1U);
 8009d1e: 693b         	ldr	r3, [r7, #0x10]
 8009d20: 005b         	lsls	r3, r3, #0x1
 8009d22: 697a         	ldr	r2, [r7, #0x14]
 8009d24: fbb2 f2f3    	udiv	r2, r2, r3
 8009d28: 683b         	ldr	r3, [r7]
 8009d2a: 601a         	str	r2, [r3]
; 	return 0;
 8009d2c: 2300         	movs	r3, #0x0
; }
 8009d2e: 4618         	mov	r0, r3
 8009d30: 3718         	adds	r7, #0x18
 8009d32: 46bd         	mov	sp, r7
 8009d34: bd80         	pop	{r7, pc}
 8009d36: bf00         	nop

08009d38 <$d>:
 8009d38: c4 06 00 24  	.word	0x240006c4
 8009d3c: 74 b2 02 08  	.word	0x0802b274
 8009d40: 00 a8 00 40  	.word	0x4000a800

08009d44 <can_stm32h7_clock_enable>:
; {
 8009d44: b580         	push	{r7, lr}
 8009d46: b090         	sub	sp, #0x40
 8009d48: af04         	add	r7, sp, #0x10
 8009d4a: 6078         	str	r0, [r7, #0x4]
; 	const struct can_mcan_config *mcan_cfg = dev->config;
 8009d4c: 687b         	ldr	r3, [r7, #0x4]
 8009d4e: 685b         	ldr	r3, [r3, #0x4]
 8009d50: 617b         	str	r3, [r7, #0x14]
; 	const struct can_stm32h7_config *stm32h7_cfg = mcan_cfg->custom;
 8009d52: 697b         	ldr	r3, [r7, #0x14]
 8009d54: 6c1b         	ldr	r3, [r3, #0x40]
 8009d56: 613b         	str	r3, [r7, #0x10]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8009d58: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8009e30 <can_stm32h7_clock_enable+0xec>
 8009d5a: 61bb         	str	r3, [r7, #0x18]
; 	uint32_t fdcan_clock = 0xffffffff;
 8009d5c: f04f 33ff    	mov.w	r3, #0xffffffff
 8009d60: 60fb         	str	r3, [r7, #0xc]
; 	if (!device_is_ready(clk)) {
 8009d62: 69b8         	ldr	r0, [r7, #0x18]
 8009d64: f014 ff9c    	bl	0x801eca0 <device_is_ready> @ imm = #0x14f38
 8009d68: 4603         	mov	r3, r0
 8009d6a: f083 0301    	eor	r3, r3, #0x1
 8009d6e: b2db         	uxtb	r3, r3
 8009d70: 2b00         	cmp	r3, #0x0
 8009d72: d01e         	beq	0x8009db2 <can_stm32h7_clock_enable+0x6e> @ imm = #0x3c
; 		LOG_ERR("clock control device not ready");
 8009d74: 2303         	movs	r3, #0x3
 8009d76: 2b00         	cmp	r3, #0x0
 8009d78: d018         	beq	0x8009dac <can_stm32h7_clock_enable+0x68> @ imm = #0x30
 8009d7a: 2301         	movs	r3, #0x1
 8009d7c: f887 302b    	strb.w	r3, [r7, #0x2b]
 8009d80: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8009d84: f083 0301    	eor	r3, r3, #0x1
 8009d88: b2db         	uxtb	r3, r3
 8009d8a: 2b00         	cmp	r3, #0x0
 8009d8c: d10e         	bne	0x8009dac <can_stm32h7_clock_enable+0x68> @ imm = #0x1c
 8009d8e: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8009e34 <can_stm32h7_clock_enable+0xf0>
 8009d90: 6819         	ldr	r1, [r3]
 8009d92: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8009e38 <can_stm32h7_clock_enable+0xf4>
 8009d94: 9302         	str	r3, [sp, #0x8]
 8009d96: 2300         	movs	r3, #0x0
 8009d98: 9301         	str	r3, [sp, #0x4]
 8009d9a: 2300         	movs	r3, #0x0
 8009d9c: 9300         	str	r3, [sp]
 8009d9e: 2300         	movs	r3, #0x0
 8009da0: 2201         	movs	r2, #0x1
 8009da2: 2000         	movs	r0, #0x0
 8009da4: f015 f865    	bl	0x801ee72 <z_log_msg_runtime_create> @ imm = #0x150ca
 8009da8: 2300         	movs	r3, #0x0
 8009daa: 62fb         	str	r3, [r7, #0x2c]
; 		return -ENODEV;
 8009dac: f06f 0312    	mvn	r3, #0x12
 8009db0: e03a         	b	0x8009e28 <can_stm32h7_clock_enable+0xe4> @ imm = #0x74
; 	ret = clock_control_on(clk, (clock_control_subsys_t)&stm32h7_cfg->pclken[0]);
 8009db2: 693b         	ldr	r3, [r7, #0x10]
 8009db4: 699b         	ldr	r3, [r3, #0x18]
 8009db6: 4619         	mov	r1, r3
 8009db8: 69b8         	ldr	r0, [r7, #0x18]
 8009dba: f015 f817    	bl	0x801edec <clock_control_on> @ imm = #0x1502e
 8009dbe: 61f8         	str	r0, [r7, #0x1c]
; 	if (ret != 0) {
 8009dc0: 69fb         	ldr	r3, [r7, #0x1c]
 8009dc2: 2b00         	cmp	r3, #0x0
 8009dc4: d01d         	beq	0x8009e02 <can_stm32h7_clock_enable+0xbe> @ imm = #0x3a
; 		LOG_ERR("failure enabling clock");
 8009dc6: 2303         	movs	r3, #0x3
 8009dc8: 2b00         	cmp	r3, #0x0
 8009dca: d018         	beq	0x8009dfe <can_stm32h7_clock_enable+0xba> @ imm = #0x30
 8009dcc: 2301         	movs	r3, #0x1
 8009dce: f887 3023    	strb.w	r3, [r7, #0x23]
 8009dd2: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8009dd6: f083 0301    	eor	r3, r3, #0x1
 8009dda: b2db         	uxtb	r3, r3
 8009ddc: 2b00         	cmp	r3, #0x0
 8009dde: d10e         	bne	0x8009dfe <can_stm32h7_clock_enable+0xba> @ imm = #0x1c
 8009de0: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8009e34 <can_stm32h7_clock_enable+0xf0>
 8009de2: 6819         	ldr	r1, [r3]
 8009de4: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8009e3c <can_stm32h7_clock_enable+0xf8>
 8009de6: 9302         	str	r3, [sp, #0x8]
 8009de8: 2300         	movs	r3, #0x0
 8009dea: 9301         	str	r3, [sp, #0x4]
 8009dec: 2300         	movs	r3, #0x0
 8009dee: 9300         	str	r3, [sp]
 8009df0: 2300         	movs	r3, #0x0
 8009df2: 2201         	movs	r2, #0x1
 8009df4: 2000         	movs	r0, #0x0
 8009df6: f015 f83c    	bl	0x801ee72 <z_log_msg_runtime_create> @ imm = #0x15078
 8009dfa: 2300         	movs	r3, #0x0
 8009dfc: 627b         	str	r3, [r7, #0x24]
; 		return ret;
 8009dfe: 69fb         	ldr	r3, [r7, #0x1c]
 8009e00: e012         	b	0x8009e28 <can_stm32h7_clock_enable+0xe4> @ imm = #0x24
; 	if (stm32h7_cfg->clock_divider != 0U) {
 8009e02: 693b         	ldr	r3, [r7, #0x10]
 8009e04: 7f1b         	ldrb	r3, [r3, #0x1c]
 8009e06: 2b00         	cmp	r3, #0x0
 8009e08: d00d         	beq	0x8009e26 <can_stm32h7_clock_enable+0xe2> @ imm = #0x1a
; 		can_mcan_enable_configuration_change(dev);
 8009e0a: 6878         	ldr	r0, [r7, #0x4]
 8009e0c: f014 ff14    	bl	0x801ec38 <can_mcan_enable_configuration_change> @ imm = #0x14e28
; 			FIELD_PREP(FDCANCCU_CCFG_CDIV, stm32h7_cfg->clock_divider >> 1U);
 8009e10: 693b         	ldr	r3, [r7, #0x10]
 8009e12: 7f1b         	ldrb	r3, [r3, #0x1c]
 8009e14: 085b         	lsrs	r3, r3, #0x1
 8009e16: b2db         	uxtb	r3, r3
 8009e18: 041b         	lsls	r3, r3, #0x10
 8009e1a: f403 2370    	and	r3, r3, #0xf0000
; 		FDCAN_CCU->CCFG = FDCANCCU_CCFG_BCC |
 8009e1e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8009e40 <can_stm32h7_clock_enable+0xfc>
 8009e20: f043 0340    	orr	r3, r3, #0x40
 8009e24: 6053         	str	r3, [r2, #0x4]
; 	return 0;
 8009e26: 2300         	movs	r3, #0x0
; }
 8009e28: 4618         	mov	r0, r3
 8009e2a: 3730         	adds	r7, #0x30
 8009e2c: 46bd         	mov	sp, r7
 8009e2e: bd80         	pop	{r7, pc}

08009e30 <$d>:
 8009e30: c0 96 02 08  	.word	0x080296c0
 8009e34: c4 06 00 24  	.word	0x240006c4
 8009e38: 8c b2 02 08  	.word	0x0802b28c
 8009e3c: ac b2 02 08  	.word	0x0802b2ac
 8009e40: 00 a8 00 40  	.word	0x4000a800

08009e44 <can_stm32h7_init>:
; {
 8009e44: b580         	push	{r7, lr}
 8009e46: b08c         	sub	sp, #0x30
 8009e48: af04         	add	r7, sp, #0x10
 8009e4a: 6078         	str	r0, [r7, #0x4]
; 	const struct can_mcan_config *mcan_cfg = dev->config;
 8009e4c: 687b         	ldr	r3, [r7, #0x4]
 8009e4e: 685b         	ldr	r3, [r3, #0x4]
 8009e50: 61fb         	str	r3, [r7, #0x1c]
; 	const struct can_stm32h7_config *stm32h7_cfg = mcan_cfg->custom;
 8009e52: 69fb         	ldr	r3, [r7, #0x1c]
 8009e54: 6c1b         	ldr	r3, [r3, #0x40]
 8009e56: 61bb         	str	r3, [r7, #0x18]
; 	ret = pinctrl_apply_state(stm32h7_cfg->pcfg, PINCTRL_STATE_DEFAULT);
 8009e58: 69bb         	ldr	r3, [r7, #0x18]
 8009e5a: 691b         	ldr	r3, [r3, #0x10]
 8009e5c: 2100         	movs	r1, #0x0
 8009e5e: 4618         	mov	r0, r3
 8009e60: f014 ffea    	bl	0x801ee38 <pinctrl_apply_state> @ imm = #0x14fd4
 8009e64: 6178         	str	r0, [r7, #0x14]
; 	if (ret != 0) {
 8009e66: 697b         	ldr	r3, [r7, #0x14]
 8009e68: 2b00         	cmp	r3, #0x0
 8009e6a: d01d         	beq	0x8009ea8 <can_stm32h7_init+0x64> @ imm = #0x3a
; 		LOG_ERR("CAN pinctrl setup failed (%d)", ret);
 8009e6c: 2303         	movs	r3, #0x3
 8009e6e: 2b00         	cmp	r3, #0x0
 8009e70: d018         	beq	0x8009ea4 <can_stm32h7_init+0x60> @ imm = #0x30
 8009e72: 2301         	movs	r3, #0x1
 8009e74: 74fb         	strb	r3, [r7, #0x13]
 8009e76: 7cfb         	ldrb	r3, [r7, #0x13]
 8009e78: f083 0301    	eor	r3, r3, #0x1
 8009e7c: b2db         	uxtb	r3, r3
 8009e7e: 2b00         	cmp	r3, #0x0
 8009e80: d110         	bne	0x8009ea4 <can_stm32h7_init+0x60> @ imm = #0x20
 8009e82: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8009ef8 <can_stm32h7_init+0xb4>
 8009e84: 6819         	ldr	r1, [r3]
 8009e86: 697b         	ldr	r3, [r7, #0x14]
 8009e88: 9303         	str	r3, [sp, #0xc]
 8009e8a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8009efc <can_stm32h7_init+0xb8>
 8009e8c: 9302         	str	r3, [sp, #0x8]
 8009e8e: 2300         	movs	r3, #0x0
 8009e90: 9301         	str	r3, [sp, #0x4]
 8009e92: 2300         	movs	r3, #0x0
 8009e94: 9300         	str	r3, [sp]
 8009e96: 2300         	movs	r3, #0x0
 8009e98: 2201         	movs	r2, #0x1
 8009e9a: 2000         	movs	r0, #0x0
 8009e9c: f014 ffe9    	bl	0x801ee72 <z_log_msg_runtime_create> @ imm = #0x14fd2
 8009ea0: 2300         	movs	r3, #0x0
 8009ea2: 60fb         	str	r3, [r7, #0xc]
; 		return ret;
 8009ea4: 697b         	ldr	r3, [r7, #0x14]
 8009ea6: e023         	b	0x8009ef0 <can_stm32h7_init+0xac> @ imm = #0x46
; 	ret = can_stm32h7_clock_enable(dev);
 8009ea8: 6878         	ldr	r0, [r7, #0x4]
 8009eaa: f7ff ff4b    	bl	0x8009d44 <can_stm32h7_clock_enable> @ imm = #-0x16a
 8009eae: 6178         	str	r0, [r7, #0x14]
; 	if (ret != 0) {
 8009eb0: 697b         	ldr	r3, [r7, #0x14]
 8009eb2: 2b00         	cmp	r3, #0x0
 8009eb4: d001         	beq	0x8009eba <can_stm32h7_init+0x76> @ imm = #0x2
; 		return ret;
 8009eb6: 697b         	ldr	r3, [r7, #0x14]
 8009eb8: e01a         	b	0x8009ef0 <can_stm32h7_init+0xac> @ imm = #0x34
; 	ret = can_mcan_configure_mram(dev, stm32h7_cfg->mrba, stm32h7_cfg->mram);
 8009eba: 69bb         	ldr	r3, [r7, #0x18]
 8009ebc: 6859         	ldr	r1, [r3, #0x4]
 8009ebe: 69bb         	ldr	r3, [r7, #0x18]
 8009ec0: 689b         	ldr	r3, [r3, #0x8]
 8009ec2: 461a         	mov	r2, r3
 8009ec4: 6878         	ldr	r0, [r7, #0x4]
 8009ec6: f7ff fbaf    	bl	0x8009628 <can_mcan_configure_mram> @ imm = #-0x8a2
 8009eca: 6178         	str	r0, [r7, #0x14]
; 	if (ret != 0) {
 8009ecc: 697b         	ldr	r3, [r7, #0x14]
 8009ece: 2b00         	cmp	r3, #0x0
 8009ed0: d001         	beq	0x8009ed6 <can_stm32h7_init+0x92> @ imm = #0x2
; 		return ret;
 8009ed2: 697b         	ldr	r3, [r7, #0x14]
 8009ed4: e00c         	b	0x8009ef0 <can_stm32h7_init+0xac> @ imm = #0x18
; 	ret = can_mcan_init(dev);
 8009ed6: 6878         	ldr	r0, [r7, #0x4]
 8009ed8: f7ff fcee    	bl	0x80098b8 <can_mcan_init> @ imm = #-0x624
 8009edc: 6178         	str	r0, [r7, #0x14]
; 	if (ret != 0) {
 8009ede: 697b         	ldr	r3, [r7, #0x14]
 8009ee0: 2b00         	cmp	r3, #0x0
 8009ee2: d001         	beq	0x8009ee8 <can_stm32h7_init+0xa4> @ imm = #0x2
; 		return ret;
 8009ee4: 697b         	ldr	r3, [r7, #0x14]
 8009ee6: e003         	b	0x8009ef0 <can_stm32h7_init+0xac> @ imm = #0x6
; 	stm32h7_cfg->config_irq();
 8009ee8: 69bb         	ldr	r3, [r7, #0x18]
 8009eea: 68db         	ldr	r3, [r3, #0xc]
 8009eec: 4798         	blx	r3
; 	return 0;
 8009eee: 2300         	movs	r3, #0x0
; }
 8009ef0: 4618         	mov	r0, r3
 8009ef2: 3720         	adds	r7, #0x20
 8009ef4: 46bd         	mov	sp, r7
 8009ef6: bd80         	pop	{r7, pc}

08009ef8 <$d>:
 8009ef8: c4 06 00 24  	.word	0x240006c4
 8009efc: c4 b2 02 08  	.word	0x0802b2c4

08009f00 <stm32h7_mcan_irq_config_0>:
; DT_INST_FOREACH_STATUS_OKAY(CAN_STM32H7_MCAN_INIT)
 8009f00: b580         	push	{r7, lr}
 8009f02: b086         	sub	sp, #0x18
 8009f04: af04         	add	r7, sp, #0x10
 8009f06: 2303         	movs	r3, #0x3
 8009f08: 2b03         	cmp	r3, #0x3
 8009f0a: d918         	bls	0x8009f3e <stm32h7_mcan_irq_config_0+0x3e> @ imm = #0x30
 8009f0c: 2301         	movs	r3, #0x1
 8009f0e: 71fb         	strb	r3, [r7, #0x7]
 8009f10: 79fb         	ldrb	r3, [r7, #0x7]
 8009f12: f083 0301    	eor	r3, r3, #0x1
 8009f16: b2db         	uxtb	r3, r3
 8009f18: 2b00         	cmp	r3, #0x0
 8009f1a: d110         	bne	0x8009f3e <stm32h7_mcan_irq_config_0+0x3e> @ imm = #0x20
 8009f1c: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8009f64 <stm32h7_mcan_irq_config_0+0x64>
 8009f1e: 6819         	ldr	r1, [r3]
 8009f20: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8009f68 <stm32h7_mcan_irq_config_0+0x68>
 8009f22: 9303         	str	r3, [sp, #0xc]
 8009f24: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8009f6c <stm32h7_mcan_irq_config_0+0x6c>
 8009f26: 9302         	str	r3, [sp, #0x8]
 8009f28: 2308         	movs	r3, #0x8
 8009f2a: 9301         	str	r3, [sp, #0x4]
 8009f2c: 2300         	movs	r3, #0x0
 8009f2e: 9300         	str	r3, [sp]
 8009f30: 2300         	movs	r3, #0x0
 8009f32: 2204         	movs	r2, #0x4
 8009f34: 2000         	movs	r0, #0x0
 8009f36: f014 ff9c    	bl	0x801ee72 <z_log_msg_runtime_create> @ imm = #0x14f38
 8009f3a: 2300         	movs	r3, #0x0
 8009f3c: 603b         	str	r3, [r7]
 8009f3e: 2200         	movs	r2, #0x0
 8009f40: 2100         	movs	r1, #0x0
 8009f42: 2013         	movs	r0, #0x13
 8009f44: f013 fb46    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x1368c
 8009f48: 2013         	movs	r0, #0x13
 8009f4a: f013 fb36    	bl	0x801d5ba <arch_irq_enable> @ imm = #0x1366c
 8009f4e: 2200         	movs	r2, #0x0
 8009f50: 2100         	movs	r1, #0x0
 8009f52: 2015         	movs	r0, #0x15
 8009f54: f013 fb3e    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x1367c
 8009f58: 2015         	movs	r0, #0x15
 8009f5a: f013 fb2e    	bl	0x801d5ba <arch_irq_enable> @ imm = #0x1365c
 8009f5e: 3708         	adds	r7, #0x8
 8009f60: 46bd         	mov	sp, r7
 8009f62: bd80         	pop	{r7, pc}

08009f64 <$d>:
 8009f64: c4 06 00 24  	.word	0x240006c4
 8009f68: f4 d0 02 08  	.word	0x0802d0f4
 8009f6c: f4 b2 02 08  	.word	0x0802b2f4

08009f70 <stm32h7_mcan_irq_config_1>:
 8009f70: b580         	push	{r7, lr}
 8009f72: b086         	sub	sp, #0x18
 8009f74: af04         	add	r7, sp, #0x10
 8009f76: 2303         	movs	r3, #0x3
 8009f78: 2b03         	cmp	r3, #0x3
 8009f7a: d918         	bls	0x8009fae <stm32h7_mcan_irq_config_1+0x3e> @ imm = #0x30
 8009f7c: 2301         	movs	r3, #0x1
 8009f7e: 71fb         	strb	r3, [r7, #0x7]
 8009f80: 79fb         	ldrb	r3, [r7, #0x7]
 8009f82: f083 0301    	eor	r3, r3, #0x1
 8009f86: b2db         	uxtb	r3, r3
 8009f88: 2b00         	cmp	r3, #0x0
 8009f8a: d110         	bne	0x8009fae <stm32h7_mcan_irq_config_1+0x3e> @ imm = #0x20
 8009f8c: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8009fd4 <stm32h7_mcan_irq_config_1+0x64>
 8009f8e: 6819         	ldr	r1, [r3]
 8009f90: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8009fd8 <stm32h7_mcan_irq_config_1+0x68>
 8009f92: 9303         	str	r3, [sp, #0xc]
 8009f94: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8009fdc <stm32h7_mcan_irq_config_1+0x6c>
 8009f96: 9302         	str	r3, [sp, #0x8]
 8009f98: 2308         	movs	r3, #0x8
 8009f9a: 9301         	str	r3, [sp, #0x4]
 8009f9c: 2300         	movs	r3, #0x0
 8009f9e: 9300         	str	r3, [sp]
 8009fa0: 2300         	movs	r3, #0x0
 8009fa2: 2204         	movs	r2, #0x4
 8009fa4: 2000         	movs	r0, #0x0
 8009fa6: f014 ff64    	bl	0x801ee72 <z_log_msg_runtime_create> @ imm = #0x14ec8
 8009faa: 2300         	movs	r3, #0x0
 8009fac: 603b         	str	r3, [r7]
 8009fae: 2200         	movs	r2, #0x0
 8009fb0: 2100         	movs	r1, #0x0
 8009fb2: 2014         	movs	r0, #0x14
 8009fb4: f013 fb0e    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x1361c
 8009fb8: 2014         	movs	r0, #0x14
 8009fba: f013 fafe    	bl	0x801d5ba <arch_irq_enable> @ imm = #0x135fc
 8009fbe: 2200         	movs	r2, #0x0
 8009fc0: 2100         	movs	r1, #0x0
 8009fc2: 2016         	movs	r0, #0x16
 8009fc4: f013 fb06    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x1360c
 8009fc8: 2016         	movs	r0, #0x16
 8009fca: f013 faf6    	bl	0x801d5ba <arch_irq_enable> @ imm = #0x135ec
 8009fce: 3708         	adds	r7, #0x8
 8009fd0: 46bd         	mov	sp, r7
 8009fd2: bd80         	pop	{r7, pc}

08009fd4 <$d>:
 8009fd4: c4 06 00 24  	.word	0x240006c4
 8009fd8: 10 d1 02 08  	.word	0x0802d110
 8009fdc: 20 b3 02 08  	.word	0x0802b320

08009fe0 <stm32h7_mcan_irq_config_2>:
 8009fe0: b580         	push	{r7, lr}
 8009fe2: b086         	sub	sp, #0x18
 8009fe4: af04         	add	r7, sp, #0x10
 8009fe6: 2303         	movs	r3, #0x3
 8009fe8: 2b03         	cmp	r3, #0x3
 8009fea: d918         	bls	0x800a01e <stm32h7_mcan_irq_config_2+0x3e> @ imm = #0x30
 8009fec: 2301         	movs	r3, #0x1
 8009fee: 71fb         	strb	r3, [r7, #0x7]
 8009ff0: 79fb         	ldrb	r3, [r7, #0x7]
 8009ff2: f083 0301    	eor	r3, r3, #0x1
 8009ff6: b2db         	uxtb	r3, r3
 8009ff8: 2b00         	cmp	r3, #0x0
 8009ffa: d110         	bne	0x800a01e <stm32h7_mcan_irq_config_2+0x3e> @ imm = #0x20
 8009ffc: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800a044 <stm32h7_mcan_irq_config_2+0x64>
 8009ffe: 6819         	ldr	r1, [r3]
 800a000: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800a048 <stm32h7_mcan_irq_config_2+0x68>
 800a002: 9303         	str	r3, [sp, #0xc]
 800a004: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800a04c <stm32h7_mcan_irq_config_2+0x6c>
 800a006: 9302         	str	r3, [sp, #0x8]
 800a008: 2308         	movs	r3, #0x8
 800a00a: 9301         	str	r3, [sp, #0x4]
 800a00c: 2300         	movs	r3, #0x0
 800a00e: 9300         	str	r3, [sp]
 800a010: 2300         	movs	r3, #0x0
 800a012: 2204         	movs	r2, #0x4
 800a014: 2000         	movs	r0, #0x0
 800a016: f014 ff2c    	bl	0x801ee72 <z_log_msg_runtime_create> @ imm = #0x14e58
 800a01a: 2300         	movs	r3, #0x0
 800a01c: 603b         	str	r3, [r7]
 800a01e: 2200         	movs	r2, #0x0
 800a020: 2100         	movs	r1, #0x0
 800a022: 209f         	movs	r0, #0x9f
 800a024: f013 fad6    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x135ac
 800a028: 209f         	movs	r0, #0x9f
 800a02a: f013 fac6    	bl	0x801d5ba <arch_irq_enable> @ imm = #0x1358c
 800a02e: 2200         	movs	r2, #0x0
 800a030: 2100         	movs	r1, #0x0
 800a032: 20a0         	movs	r0, #0xa0
 800a034: f013 face    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #0x1359c
 800a038: 20a0         	movs	r0, #0xa0
 800a03a: f013 fabe    	bl	0x801d5ba <arch_irq_enable> @ imm = #0x1357c
 800a03e: 3708         	adds	r7, #0x8
 800a040: 46bd         	mov	sp, r7
 800a042: bd80         	pop	{r7, pc}

0800a044 <$d>:
 800a044: c4 06 00 24  	.word	0x240006c4
 800a048: 2c d1 02 08  	.word	0x0802d12c
 800a04c: 4c b3 02 08  	.word	0x0802b34c

0800a050 <LL_AHB4_GRP1_EnableClock>:
; {
 800a050: b480         	push	{r7}
 800a052: b085         	sub	sp, #0x14
 800a054: af00         	add	r7, sp, #0x0
 800a056: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(RCC->AHB4ENR, Periphs);
 800a058: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800a084 <LL_AHB4_GRP1_EnableClock+0x34>
 800a05a: f8d3 20e0    	ldr.w	r2, [r3, #0xe0]
 800a05e: 4909         	ldr	r1, [pc, #0x24]         @ 0x800a084 <LL_AHB4_GRP1_EnableClock+0x34>
 800a060: 687b         	ldr	r3, [r7, #0x4]
 800a062: 4313         	orrs	r3, r2
 800a064: f8c1 30e0    	str.w	r3, [r1, #0xe0]
;   tmpreg = READ_BIT(RCC->AHB4ENR, Periphs);
 800a068: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a084 <LL_AHB4_GRP1_EnableClock+0x34>
 800a06a: f8d3 20e0    	ldr.w	r2, [r3, #0xe0]
 800a06e: 687b         	ldr	r3, [r7, #0x4]
 800a070: 4013         	ands	r3, r2
 800a072: 60fb         	str	r3, [r7, #0xc]
;   (void)tmpreg;
 800a074: 68fb         	ldr	r3, [r7, #0xc]
; }
 800a076: bf00         	nop
 800a078: 3714         	adds	r7, #0x14
 800a07a: 46bd         	mov	sp, r7
 800a07c: f85d 7b04    	ldr	r7, [sp], #4
 800a080: 4770         	bx	lr
 800a082: bf00         	nop

0800a084 <$d>:
 800a084: 00 44 02 58  	.word	0x58024400

0800a088 <LL_PWR_ConfigSupply>:
; {
 800a088: b480         	push	{r7}
 800a08a: b083         	sub	sp, #0xc
 800a08c: af00         	add	r7, sp, #0x0
 800a08e: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(PWR->CR3, (PWR_CR3_SCUEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS), SupplySource);
 800a090: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a0ac <LL_PWR_ConfigSupply+0x24>
 800a092: 68db         	ldr	r3, [r3, #0xc]
 800a094: f023 0207    	bic	r2, r3, #0x7
 800a098: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a0ac <LL_PWR_ConfigSupply+0x24>
 800a09a: 687b         	ldr	r3, [r7, #0x4]
 800a09c: 4313         	orrs	r3, r2
 800a09e: 60cb         	str	r3, [r1, #0xc]
; }
 800a0a0: bf00         	nop
 800a0a2: 370c         	adds	r7, #0xc
 800a0a4: 46bd         	mov	sp, r7
 800a0a6: f85d 7b04    	ldr	r7, [sp], #4
 800a0aa: 4770         	bx	lr

0800a0ac <$d>:
 800a0ac: 00 48 02 58  	.word	0x58024800

0800a0b0 <LL_PWR_SetRegulVoltageScaling>:
; {
 800a0b0: b480         	push	{r7}
 800a0b2: b083         	sub	sp, #0xc
 800a0b4: af00         	add	r7, sp, #0x0
 800a0b6: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);
 800a0b8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a0d4 <LL_PWR_SetRegulVoltageScaling+0x24>
 800a0ba: 699b         	ldr	r3, [r3, #0x18]
 800a0bc: f423 4240    	bic	r2, r3, #0xc000
 800a0c0: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a0d4 <LL_PWR_SetRegulVoltageScaling+0x24>
 800a0c2: 687b         	ldr	r3, [r7, #0x4]
 800a0c4: 4313         	orrs	r3, r2
 800a0c6: 618b         	str	r3, [r1, #0x18]
; }
 800a0c8: bf00         	nop
 800a0ca: 370c         	adds	r7, #0xc
 800a0cc: 46bd         	mov	sp, r7
 800a0ce: f85d 7b04    	ldr	r7, [sp], #4
 800a0d2: 4770         	bx	lr

0800a0d4 <$d>:
 800a0d4: 00 48 02 58  	.word	0x58024800

0800a0d8 <LL_PWR_IsActiveFlag_VOS>:
; {
 800a0d8: b480         	push	{r7}
 800a0da: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(PWR->D3CR, PWR_D3CR_VOSRDY) == (PWR_D3CR_VOSRDY)) ? 1UL : 0UL);
 800a0dc: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a0fc <LL_PWR_IsActiveFlag_VOS+0x24>
 800a0de: 699b         	ldr	r3, [r3, #0x18]
 800a0e0: f403 5300    	and	r3, r3, #0x2000
 800a0e4: f5b3 5f00    	cmp.w	r3, #0x2000
 800a0e8: d101         	bne	0x800a0ee <LL_PWR_IsActiveFlag_VOS+0x16> @ imm = #0x2
 800a0ea: 2301         	movs	r3, #0x1
 800a0ec: e000         	b	0x800a0f0 <LL_PWR_IsActiveFlag_VOS+0x18> @ imm = #0x0
 800a0ee: 2300         	movs	r3, #0x0
; }
 800a0f0: 4618         	mov	r0, r3
 800a0f2: 46bd         	mov	sp, r7
 800a0f4: f85d 7b04    	ldr	r7, [sp], #4
 800a0f8: 4770         	bx	lr
 800a0fa: bf00         	nop

0800a0fc <$d>:
 800a0fc: 00 48 02 58  	.word	0x58024800

0800a100 <LL_RCC_HSE_DisableBypass>:
; {
 800a100: b480         	push	{r7}
 800a102: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 800a104: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a11c <LL_RCC_HSE_DisableBypass+0x1c>
 800a106: 681b         	ldr	r3, [r3]
 800a108: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a11c <LL_RCC_HSE_DisableBypass+0x1c>
 800a10a: f423 2380    	bic	r3, r3, #0x40000
 800a10e: 6013         	str	r3, [r2]
; }
 800a110: bf00         	nop
 800a112: 46bd         	mov	sp, r7
 800a114: f85d 7b04    	ldr	r7, [sp], #4
 800a118: 4770         	bx	lr
 800a11a: bf00         	nop

0800a11c <$d>:
 800a11c: 00 44 02 58  	.word	0x58024400

0800a120 <LL_RCC_HSE_Enable>:
; {
 800a120: b480         	push	{r7}
 800a122: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSEON);
 800a124: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a13c <LL_RCC_HSE_Enable+0x1c>
 800a126: 681b         	ldr	r3, [r3]
 800a128: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a13c <LL_RCC_HSE_Enable+0x1c>
 800a12a: f443 3380    	orr	r3, r3, #0x10000
 800a12e: 6013         	str	r3, [r2]
; }
 800a130: bf00         	nop
 800a132: 46bd         	mov	sp, r7
 800a134: f85d 7b04    	ldr	r7, [sp], #4
 800a138: 4770         	bx	lr
 800a13a: bf00         	nop

0800a13c <$d>:
 800a13c: 00 44 02 58  	.word	0x58024400

0800a140 <LL_RCC_HSE_IsReady>:
; {
 800a140: b480         	push	{r7}
 800a142: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 800a144: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a164 <LL_RCC_HSE_IsReady+0x24>
 800a146: 681b         	ldr	r3, [r3]
 800a148: f403 3300    	and	r3, r3, #0x20000
 800a14c: f5b3 3f00    	cmp.w	r3, #0x20000
 800a150: d101         	bne	0x800a156 <LL_RCC_HSE_IsReady+0x16> @ imm = #0x2
 800a152: 2301         	movs	r3, #0x1
 800a154: e000         	b	0x800a158 <LL_RCC_HSE_IsReady+0x18> @ imm = #0x0
 800a156: 2300         	movs	r3, #0x0
; }
 800a158: 4618         	mov	r0, r3
 800a15a: 46bd         	mov	sp, r7
 800a15c: f85d 7b04    	ldr	r7, [sp], #4
 800a160: 4770         	bx	lr
 800a162: bf00         	nop

0800a164 <$d>:
 800a164: 00 44 02 58  	.word	0x58024400

0800a168 <LL_RCC_HSI_Enable>:
; {
 800a168: b480         	push	{r7}
 800a16a: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSION);
 800a16c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a184 <LL_RCC_HSI_Enable+0x1c>
 800a16e: 681b         	ldr	r3, [r3]
 800a170: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a184 <LL_RCC_HSI_Enable+0x1c>
 800a172: f043 0301    	orr	r3, r3, #0x1
 800a176: 6013         	str	r3, [r2]
; }
 800a178: bf00         	nop
 800a17a: 46bd         	mov	sp, r7
 800a17c: f85d 7b04    	ldr	r7, [sp], #4
 800a180: 4770         	bx	lr
 800a182: bf00         	nop

0800a184 <$d>:
 800a184: 00 44 02 58  	.word	0x58024400

0800a188 <LL_RCC_HSI_IsReady>:
; {
 800a188: b480         	push	{r7}
 800a18a: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 800a18c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a1a8 <LL_RCC_HSI_IsReady+0x20>
 800a18e: 681b         	ldr	r3, [r3]
 800a190: f003 0304    	and	r3, r3, #0x4
 800a194: 2b04         	cmp	r3, #0x4
 800a196: d101         	bne	0x800a19c <LL_RCC_HSI_IsReady+0x14> @ imm = #0x2
 800a198: 2301         	movs	r3, #0x1
 800a19a: e000         	b	0x800a19e <LL_RCC_HSI_IsReady+0x16> @ imm = #0x0
 800a19c: 2300         	movs	r3, #0x0
; }
 800a19e: 4618         	mov	r0, r3
 800a1a0: 46bd         	mov	sp, r7
 800a1a2: f85d 7b04    	ldr	r7, [sp], #4
 800a1a6: 4770         	bx	lr

0800a1a8 <$d>:
 800a1a8: 00 44 02 58  	.word	0x58024400

0800a1ac <LL_RCC_HSI_SetDivider>:
; {
 800a1ac: b480         	push	{r7}
 800a1ae: b083         	sub	sp, #0xc
 800a1b0: af00         	add	r7, sp, #0x0
 800a1b2: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CR, RCC_CR_HSIDIV, Divider);
 800a1b4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a1d0 <LL_RCC_HSI_SetDivider+0x24>
 800a1b6: 681b         	ldr	r3, [r3]
 800a1b8: f023 0218    	bic	r2, r3, #0x18
 800a1bc: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a1d0 <LL_RCC_HSI_SetDivider+0x24>
 800a1be: 687b         	ldr	r3, [r7, #0x4]
 800a1c0: 4313         	orrs	r3, r2
 800a1c2: 600b         	str	r3, [r1]
; }
 800a1c4: bf00         	nop
 800a1c6: 370c         	adds	r7, #0xc
 800a1c8: 46bd         	mov	sp, r7
 800a1ca: f85d 7b04    	ldr	r7, [sp], #4
 800a1ce: 4770         	bx	lr

0800a1d0 <$d>:
 800a1d0: 00 44 02 58  	.word	0x58024400

0800a1d4 <LL_RCC_HSI_SetCalibTrimming>:
; {
 800a1d4: b480         	push	{r7}
 800a1d6: b083         	sub	sp, #0xc
 800a1d8: af00         	add	r7, sp, #0x0
 800a1da: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
 800a1dc: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a1fc <LL_RCC_HSI_SetCalibTrimming+0x28>
 800a1de: 685b         	ldr	r3, [r3, #0x4]
 800a1e0: f023 42fe    	bic	r2, r3, #0x7f000000
 800a1e4: 687b         	ldr	r3, [r7, #0x4]
 800a1e6: 061b         	lsls	r3, r3, #0x18
 800a1e8: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a1fc <LL_RCC_HSI_SetCalibTrimming+0x28>
 800a1ea: 4313         	orrs	r3, r2
 800a1ec: 604b         	str	r3, [r1, #0x4]
; }
 800a1ee: bf00         	nop
 800a1f0: 370c         	adds	r7, #0xc
 800a1f2: 46bd         	mov	sp, r7
 800a1f4: f85d 7b04    	ldr	r7, [sp], #4
 800a1f8: 4770         	bx	lr
 800a1fa: bf00         	nop

0800a1fc <$d>:
 800a1fc: 00 44 02 58  	.word	0x58024400

0800a200 <LL_RCC_CSI_Enable>:
; {
 800a200: b480         	push	{r7}
 800a202: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_CSION);
 800a204: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a21c <LL_RCC_CSI_Enable+0x1c>
 800a206: 681b         	ldr	r3, [r3]
 800a208: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a21c <LL_RCC_CSI_Enable+0x1c>
 800a20a: f043 0380    	orr	r3, r3, #0x80
 800a20e: 6013         	str	r3, [r2]
; }
 800a210: bf00         	nop
 800a212: 46bd         	mov	sp, r7
 800a214: f85d 7b04    	ldr	r7, [sp], #4
 800a218: 4770         	bx	lr
 800a21a: bf00         	nop

0800a21c <$d>:
 800a21c: 00 44 02 58  	.word	0x58024400

0800a220 <LL_RCC_CSI_IsReady>:
; {
 800a220: b480         	push	{r7}
 800a222: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CR, RCC_CR_CSIRDY) == (RCC_CR_CSIRDY)) ? 1UL : 0UL);
 800a224: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a244 <LL_RCC_CSI_IsReady+0x24>
 800a226: 681b         	ldr	r3, [r3]
 800a228: f403 7380    	and	r3, r3, #0x100
 800a22c: f5b3 7f80    	cmp.w	r3, #0x100
 800a230: d101         	bne	0x800a236 <LL_RCC_CSI_IsReady+0x16> @ imm = #0x2
 800a232: 2301         	movs	r3, #0x1
 800a234: e000         	b	0x800a238 <LL_RCC_CSI_IsReady+0x18> @ imm = #0x0
 800a236: 2300         	movs	r3, #0x0
; }
 800a238: 4618         	mov	r0, r3
 800a23a: 46bd         	mov	sp, r7
 800a23c: f85d 7b04    	ldr	r7, [sp], #4
 800a240: 4770         	bx	lr
 800a242: bf00         	nop

0800a244 <$d>:
 800a244: 00 44 02 58  	.word	0x58024400

0800a248 <LL_RCC_HSI48_Enable>:
; {
 800a248: b480         	push	{r7}
 800a24a: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSI48ON);
 800a24c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a264 <LL_RCC_HSI48_Enable+0x1c>
 800a24e: 681b         	ldr	r3, [r3]
 800a250: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a264 <LL_RCC_HSI48_Enable+0x1c>
 800a252: f443 5380    	orr	r3, r3, #0x1000
 800a256: 6013         	str	r3, [r2]
; }
 800a258: bf00         	nop
 800a25a: 46bd         	mov	sp, r7
 800a25c: f85d 7b04    	ldr	r7, [sp], #4
 800a260: 4770         	bx	lr
 800a262: bf00         	nop

0800a264 <$d>:
 800a264: 00 44 02 58  	.word	0x58024400

0800a268 <LL_RCC_HSI48_IsReady>:
; {
 800a268: b480         	push	{r7}
 800a26a: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == (RCC_CR_HSI48RDY)) ? 1UL : 0UL);
 800a26c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a28c <LL_RCC_HSI48_IsReady+0x24>
 800a26e: 681b         	ldr	r3, [r3]
 800a270: f403 5300    	and	r3, r3, #0x2000
 800a274: f5b3 5f00    	cmp.w	r3, #0x2000
 800a278: d101         	bne	0x800a27e <LL_RCC_HSI48_IsReady+0x16> @ imm = #0x2
 800a27a: 2301         	movs	r3, #0x1
 800a27c: e000         	b	0x800a280 <LL_RCC_HSI48_IsReady+0x18> @ imm = #0x0
 800a27e: 2300         	movs	r3, #0x0
; }
 800a280: 4618         	mov	r0, r3
 800a282: 46bd         	mov	sp, r7
 800a284: f85d 7b04    	ldr	r7, [sp], #4
 800a288: 4770         	bx	lr
 800a28a: bf00         	nop

0800a28c <$d>:
 800a28c: 00 44 02 58  	.word	0x58024400

0800a290 <LL_RCC_LSI_Enable>:
; {
 800a290: b480         	push	{r7}
 800a292: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CSR, RCC_CSR_LSION);
 800a294: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a2ac <LL_RCC_LSI_Enable+0x1c>
 800a296: 6f5b         	ldr	r3, [r3, #0x74]
 800a298: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a2ac <LL_RCC_LSI_Enable+0x1c>
 800a29a: f043 0301    	orr	r3, r3, #0x1
 800a29e: 6753         	str	r3, [r2, #0x74]
; }
 800a2a0: bf00         	nop
 800a2a2: 46bd         	mov	sp, r7
 800a2a4: f85d 7b04    	ldr	r7, [sp], #4
 800a2a8: 4770         	bx	lr
 800a2aa: bf00         	nop

0800a2ac <$d>:
 800a2ac: 00 44 02 58  	.word	0x58024400

0800a2b0 <LL_RCC_LSI_IsReady>:
; {
 800a2b0: b480         	push	{r7}
 800a2b2: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 800a2b4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a2d0 <LL_RCC_LSI_IsReady+0x20>
 800a2b6: 6f5b         	ldr	r3, [r3, #0x74]
 800a2b8: f003 0302    	and	r3, r3, #0x2
 800a2bc: 2b02         	cmp	r3, #0x2
 800a2be: d101         	bne	0x800a2c4 <LL_RCC_LSI_IsReady+0x14> @ imm = #0x2
 800a2c0: 2301         	movs	r3, #0x1
 800a2c2: e000         	b	0x800a2c6 <LL_RCC_LSI_IsReady+0x16> @ imm = #0x0
 800a2c4: 2300         	movs	r3, #0x0
; }
 800a2c6: 4618         	mov	r0, r3
 800a2c8: 46bd         	mov	sp, r7
 800a2ca: f85d 7b04    	ldr	r7, [sp], #4
 800a2ce: 4770         	bx	lr

0800a2d0 <$d>:
 800a2d0: 00 44 02 58  	.word	0x58024400

0800a2d4 <LL_RCC_SetSysClkSource>:
; {
 800a2d4: b480         	push	{r7}
 800a2d6: b083         	sub	sp, #0xc
 800a2d8: af00         	add	r7, sp, #0x0
 800a2da: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 800a2dc: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a2f8 <LL_RCC_SetSysClkSource+0x24>
 800a2de: 691b         	ldr	r3, [r3, #0x10]
 800a2e0: f023 0207    	bic	r2, r3, #0x7
 800a2e4: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a2f8 <LL_RCC_SetSysClkSource+0x24>
 800a2e6: 687b         	ldr	r3, [r7, #0x4]
 800a2e8: 4313         	orrs	r3, r2
 800a2ea: 610b         	str	r3, [r1, #0x10]
; }
 800a2ec: bf00         	nop
 800a2ee: 370c         	adds	r7, #0xc
 800a2f0: 46bd         	mov	sp, r7
 800a2f2: f85d 7b04    	ldr	r7, [sp], #4
 800a2f6: 4770         	bx	lr

0800a2f8 <$d>:
 800a2f8: 00 44 02 58  	.word	0x58024400

0800a2fc <LL_RCC_GetSysClkSource>:
; {
 800a2fc: b480         	push	{r7}
 800a2fe: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800a300: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800a314 <LL_RCC_GetSysClkSource+0x18>
 800a302: 691b         	ldr	r3, [r3, #0x10]
 800a304: f003 0338    	and	r3, r3, #0x38
; }
 800a308: 4618         	mov	r0, r3
 800a30a: 46bd         	mov	sp, r7
 800a30c: f85d 7b04    	ldr	r7, [sp], #4
 800a310: 4770         	bx	lr
 800a312: bf00         	nop

0800a314 <$d>:
 800a314: 00 44 02 58  	.word	0x58024400

0800a318 <LL_RCC_SetSysPrescaler>:
; {
 800a318: b480         	push	{r7}
 800a31a: b083         	sub	sp, #0xc
 800a31c: af00         	add	r7, sp, #0x0
 800a31e: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, Prescaler);
 800a320: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a33c <LL_RCC_SetSysPrescaler+0x24>
 800a322: 699b         	ldr	r3, [r3, #0x18]
 800a324: f423 6270    	bic	r2, r3, #0xf00
 800a328: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a33c <LL_RCC_SetSysPrescaler+0x24>
 800a32a: 687b         	ldr	r3, [r7, #0x4]
 800a32c: 4313         	orrs	r3, r2
 800a32e: 618b         	str	r3, [r1, #0x18]
; }
 800a330: bf00         	nop
 800a332: 370c         	adds	r7, #0xc
 800a334: 46bd         	mov	sp, r7
 800a336: f85d 7b04    	ldr	r7, [sp], #4
 800a33a: 4770         	bx	lr

0800a33c <$d>:
 800a33c: 00 44 02 58  	.word	0x58024400

0800a340 <LL_RCC_SetAHBPrescaler>:
; {
 800a340: b480         	push	{r7}
 800a342: b083         	sub	sp, #0xc
 800a344: af00         	add	r7, sp, #0x0
 800a346: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, Prescaler);
 800a348: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a364 <LL_RCC_SetAHBPrescaler+0x24>
 800a34a: 699b         	ldr	r3, [r3, #0x18]
 800a34c: f023 020f    	bic	r2, r3, #0xf
 800a350: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a364 <LL_RCC_SetAHBPrescaler+0x24>
 800a352: 687b         	ldr	r3, [r7, #0x4]
 800a354: 4313         	orrs	r3, r2
 800a356: 618b         	str	r3, [r1, #0x18]
; }
 800a358: bf00         	nop
 800a35a: 370c         	adds	r7, #0xc
 800a35c: 46bd         	mov	sp, r7
 800a35e: f85d 7b04    	ldr	r7, [sp], #4
 800a362: 4770         	bx	lr

0800a364 <$d>:
 800a364: 00 44 02 58  	.word	0x58024400

0800a368 <LL_RCC_SetAPB1Prescaler>:
; {
 800a368: b480         	push	{r7}
 800a36a: b083         	sub	sp, #0xc
 800a36c: af00         	add	r7, sp, #0x0
 800a36e: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, Prescaler);
 800a370: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a38c <LL_RCC_SetAPB1Prescaler+0x24>
 800a372: 69db         	ldr	r3, [r3, #0x1c]
 800a374: f023 0270    	bic	r2, r3, #0x70
 800a378: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a38c <LL_RCC_SetAPB1Prescaler+0x24>
 800a37a: 687b         	ldr	r3, [r7, #0x4]
 800a37c: 4313         	orrs	r3, r2
 800a37e: 61cb         	str	r3, [r1, #0x1c]
; }
 800a380: bf00         	nop
 800a382: 370c         	adds	r7, #0xc
 800a384: 46bd         	mov	sp, r7
 800a386: f85d 7b04    	ldr	r7, [sp], #4
 800a38a: 4770         	bx	lr

0800a38c <$d>:
 800a38c: 00 44 02 58  	.word	0x58024400

0800a390 <LL_RCC_SetAPB2Prescaler>:
; {
 800a390: b480         	push	{r7}
 800a392: b083         	sub	sp, #0xc
 800a394: af00         	add	r7, sp, #0x0
 800a396: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, Prescaler);
 800a398: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a3b4 <LL_RCC_SetAPB2Prescaler+0x24>
 800a39a: 69db         	ldr	r3, [r3, #0x1c]
 800a39c: f423 62e0    	bic	r2, r3, #0x700
 800a3a0: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a3b4 <LL_RCC_SetAPB2Prescaler+0x24>
 800a3a2: 687b         	ldr	r3, [r7, #0x4]
 800a3a4: 4313         	orrs	r3, r2
 800a3a6: 61cb         	str	r3, [r1, #0x1c]
; }
 800a3a8: bf00         	nop
 800a3aa: 370c         	adds	r7, #0xc
 800a3ac: 46bd         	mov	sp, r7
 800a3ae: f85d 7b04    	ldr	r7, [sp], #4
 800a3b2: 4770         	bx	lr

0800a3b4 <$d>:
 800a3b4: 00 44 02 58  	.word	0x58024400

0800a3b8 <LL_RCC_SetAPB3Prescaler>:
; {
 800a3b8: b480         	push	{r7}
 800a3ba: b083         	sub	sp, #0xc
 800a3bc: af00         	add	r7, sp, #0x0
 800a3be: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, Prescaler);
 800a3c0: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a3dc <LL_RCC_SetAPB3Prescaler+0x24>
 800a3c2: 699b         	ldr	r3, [r3, #0x18]
 800a3c4: f023 0270    	bic	r2, r3, #0x70
 800a3c8: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a3dc <LL_RCC_SetAPB3Prescaler+0x24>
 800a3ca: 687b         	ldr	r3, [r7, #0x4]
 800a3cc: 4313         	orrs	r3, r2
 800a3ce: 618b         	str	r3, [r1, #0x18]
; }
 800a3d0: bf00         	nop
 800a3d2: 370c         	adds	r7, #0xc
 800a3d4: 46bd         	mov	sp, r7
 800a3d6: f85d 7b04    	ldr	r7, [sp], #4
 800a3da: 4770         	bx	lr

0800a3dc <$d>:
 800a3dc: 00 44 02 58  	.word	0x58024400

0800a3e0 <LL_RCC_SetAPB4Prescaler>:
; {
 800a3e0: b480         	push	{r7}
 800a3e2: b083         	sub	sp, #0xc
 800a3e4: af00         	add	r7, sp, #0x0
 800a3e6: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, Prescaler);
 800a3e8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a404 <LL_RCC_SetAPB4Prescaler+0x24>
 800a3ea: 6a1b         	ldr	r3, [r3, #0x20]
 800a3ec: f023 0270    	bic	r2, r3, #0x70
 800a3f0: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a404 <LL_RCC_SetAPB4Prescaler+0x24>
 800a3f2: 687b         	ldr	r3, [r7, #0x4]
 800a3f4: 4313         	orrs	r3, r2
 800a3f6: 620b         	str	r3, [r1, #0x20]
; }
 800a3f8: bf00         	nop
 800a3fa: 370c         	adds	r7, #0xc
 800a3fc: 46bd         	mov	sp, r7
 800a3fe: f85d 7b04    	ldr	r7, [sp], #4
 800a402: 4770         	bx	lr

0800a404 <$d>:
 800a404: 00 44 02 58  	.word	0x58024400

0800a408 <LL_RCC_PLL_SetSource>:
; {
 800a408: b480         	push	{r7}
 800a40a: b083         	sub	sp, #0xc
 800a40c: af00         	add	r7, sp, #0x0
 800a40e: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC, PLLSource);
 800a410: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a42c <LL_RCC_PLL_SetSource+0x24>
 800a412: 6a9b         	ldr	r3, [r3, #0x28]
 800a414: f023 0203    	bic	r2, r3, #0x3
 800a418: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a42c <LL_RCC_PLL_SetSource+0x24>
 800a41a: 687b         	ldr	r3, [r7, #0x4]
 800a41c: 4313         	orrs	r3, r2
 800a41e: 628b         	str	r3, [r1, #0x28]
; }
 800a420: bf00         	nop
 800a422: 370c         	adds	r7, #0xc
 800a424: 46bd         	mov	sp, r7
 800a426: f85d 7b04    	ldr	r7, [sp], #4
 800a42a: 4770         	bx	lr

0800a42c <$d>:
 800a42c: 00 44 02 58  	.word	0x58024400

0800a430 <LL_RCC_PLL_GetSource>:
; {
 800a430: b480         	push	{r7}
 800a432: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC));
 800a434: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800a448 <LL_RCC_PLL_GetSource+0x18>
 800a436: 6a9b         	ldr	r3, [r3, #0x28]
 800a438: f003 0303    	and	r3, r3, #0x3
; }
 800a43c: 4618         	mov	r0, r3
 800a43e: 46bd         	mov	sp, r7
 800a440: f85d 7b04    	ldr	r7, [sp], #4
 800a444: 4770         	bx	lr
 800a446: bf00         	nop

0800a448 <$d>:
 800a448: 00 44 02 58  	.word	0x58024400

0800a44c <LL_RCC_PLL1_Enable>:
; {
 800a44c: b480         	push	{r7}
 800a44e: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_PLL1ON);
 800a450: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a468 <LL_RCC_PLL1_Enable+0x1c>
 800a452: 681b         	ldr	r3, [r3]
 800a454: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a468 <LL_RCC_PLL1_Enable+0x1c>
 800a456: f043 7380    	orr	r3, r3, #0x1000000
 800a45a: 6013         	str	r3, [r2]
; }
 800a45c: bf00         	nop
 800a45e: 46bd         	mov	sp, r7
 800a460: f85d 7b04    	ldr	r7, [sp], #4
 800a464: 4770         	bx	lr
 800a466: bf00         	nop

0800a468 <$d>:
 800a468: 00 44 02 58  	.word	0x58024400

0800a46c <LL_RCC_PLL1_Disable>:
; {
 800a46c: b480         	push	{r7}
 800a46e: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);
 800a470: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a488 <LL_RCC_PLL1_Disable+0x1c>
 800a472: 681b         	ldr	r3, [r3]
 800a474: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a488 <LL_RCC_PLL1_Disable+0x1c>
 800a476: f023 7380    	bic	r3, r3, #0x1000000
 800a47a: 6013         	str	r3, [r2]
; }
 800a47c: bf00         	nop
 800a47e: 46bd         	mov	sp, r7
 800a480: f85d 7b04    	ldr	r7, [sp], #4
 800a484: 4770         	bx	lr
 800a486: bf00         	nop

0800a488 <$d>:
 800a488: 00 44 02 58  	.word	0x58024400

0800a48c <LL_RCC_PLL1_IsReady>:
; {
 800a48c: b480         	push	{r7}
 800a48e: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == (RCC_CR_PLL1RDY)) ? 1UL : 0UL);
 800a490: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a4b0 <LL_RCC_PLL1_IsReady+0x24>
 800a492: 681b         	ldr	r3, [r3]
 800a494: f003 7300    	and	r3, r3, #0x2000000
 800a498: f1b3 7f00    	cmp.w	r3, #0x2000000
 800a49c: d101         	bne	0x800a4a2 <LL_RCC_PLL1_IsReady+0x16> @ imm = #0x2
 800a49e: 2301         	movs	r3, #0x1
 800a4a0: e000         	b	0x800a4a4 <LL_RCC_PLL1_IsReady+0x18> @ imm = #0x0
 800a4a2: 2300         	movs	r3, #0x0
; }
 800a4a4: 4618         	mov	r0, r3
 800a4a6: 46bd         	mov	sp, r7
 800a4a8: f85d 7b04    	ldr	r7, [sp], #4
 800a4ac: 4770         	bx	lr
 800a4ae: bf00         	nop

0800a4b0 <$d>:
 800a4b0: 00 44 02 58  	.word	0x58024400

0800a4b4 <LL_RCC_PLL1P_Enable>:
; {
 800a4b4: b480         	push	{r7}
 800a4b6: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP1EN);
 800a4b8: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a4d0 <LL_RCC_PLL1P_Enable+0x1c>
 800a4ba: 6adb         	ldr	r3, [r3, #0x2c]
 800a4bc: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a4d0 <LL_RCC_PLL1P_Enable+0x1c>
 800a4be: f443 3380    	orr	r3, r3, #0x10000
 800a4c2: 62d3         	str	r3, [r2, #0x2c]
; }
 800a4c4: bf00         	nop
 800a4c6: 46bd         	mov	sp, r7
 800a4c8: f85d 7b04    	ldr	r7, [sp], #4
 800a4cc: 4770         	bx	lr
 800a4ce: bf00         	nop

0800a4d0 <$d>:
 800a4d0: 00 44 02 58  	.word	0x58024400

0800a4d4 <LL_RCC_PLL1Q_Enable>:
; {
 800a4d4: b480         	push	{r7}
 800a4d6: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ1EN);
 800a4d8: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a4f0 <LL_RCC_PLL1Q_Enable+0x1c>
 800a4da: 6adb         	ldr	r3, [r3, #0x2c]
 800a4dc: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a4f0 <LL_RCC_PLL1Q_Enable+0x1c>
 800a4de: f443 3300    	orr	r3, r3, #0x20000
 800a4e2: 62d3         	str	r3, [r2, #0x2c]
; }
 800a4e4: bf00         	nop
 800a4e6: 46bd         	mov	sp, r7
 800a4e8: f85d 7b04    	ldr	r7, [sp], #4
 800a4ec: 4770         	bx	lr
 800a4ee: bf00         	nop

0800a4f0 <$d>:
 800a4f0: 00 44 02 58  	.word	0x58024400

0800a4f4 <LL_RCC_PLL1R_Enable>:
; {
 800a4f4: b480         	push	{r7}
 800a4f6: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR1EN);
 800a4f8: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a510 <LL_RCC_PLL1R_Enable+0x1c>
 800a4fa: 6adb         	ldr	r3, [r3, #0x2c]
 800a4fc: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a510 <LL_RCC_PLL1R_Enable+0x1c>
 800a4fe: f443 2380    	orr	r3, r3, #0x40000
 800a502: 62d3         	str	r3, [r2, #0x2c]
; }
 800a504: bf00         	nop
 800a506: 46bd         	mov	sp, r7
 800a508: f85d 7b04    	ldr	r7, [sp], #4
 800a50c: 4770         	bx	lr
 800a50e: bf00         	nop

0800a510 <$d>:
 800a510: 00 44 02 58  	.word	0x58024400

0800a514 <LL_RCC_PLL1FRACN_Enable>:
; {
 800a514: b480         	push	{r7}
 800a516: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL1FRACEN);
 800a518: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a530 <LL_RCC_PLL1FRACN_Enable+0x1c>
 800a51a: 6adb         	ldr	r3, [r3, #0x2c]
 800a51c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a530 <LL_RCC_PLL1FRACN_Enable+0x1c>
 800a51e: f043 0301    	orr	r3, r3, #0x1
 800a522: 62d3         	str	r3, [r2, #0x2c]
; }
 800a524: bf00         	nop
 800a526: 46bd         	mov	sp, r7
 800a528: f85d 7b04    	ldr	r7, [sp], #4
 800a52c: 4770         	bx	lr
 800a52e: bf00         	nop

0800a530 <$d>:
 800a530: 00 44 02 58  	.word	0x58024400

0800a534 <LL_RCC_PLL1FRACN_Disable>:
; {
 800a534: b480         	push	{r7}
 800a536: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL1FRACEN);
 800a538: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a550 <LL_RCC_PLL1FRACN_Disable+0x1c>
 800a53a: 6adb         	ldr	r3, [r3, #0x2c]
 800a53c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a550 <LL_RCC_PLL1FRACN_Disable+0x1c>
 800a53e: f023 0301    	bic	r3, r3, #0x1
 800a542: 62d3         	str	r3, [r2, #0x2c]
; }
 800a544: bf00         	nop
 800a546: 46bd         	mov	sp, r7
 800a548: f85d 7b04    	ldr	r7, [sp], #4
 800a54c: 4770         	bx	lr
 800a54e: bf00         	nop

0800a550 <$d>:
 800a550: 00 44 02 58  	.word	0x58024400

0800a554 <LL_RCC_PLL1_SetVCOOutputRange>:
; {
 800a554: b480         	push	{r7}
 800a556: b083         	sub	sp, #0xc
 800a558: af00         	add	r7, sp, #0x0
 800a55a: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL1VCOSEL, VCORange << RCC_PLLCFGR_PLL1VCOSEL_Pos);
 800a55c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a57c <LL_RCC_PLL1_SetVCOOutputRange+0x28>
 800a55e: 6adb         	ldr	r3, [r3, #0x2c]
 800a560: f023 0202    	bic	r2, r3, #0x2
 800a564: 687b         	ldr	r3, [r7, #0x4]
 800a566: 005b         	lsls	r3, r3, #0x1
 800a568: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a57c <LL_RCC_PLL1_SetVCOOutputRange+0x28>
 800a56a: 4313         	orrs	r3, r2
 800a56c: 62cb         	str	r3, [r1, #0x2c]
; }
 800a56e: bf00         	nop
 800a570: 370c         	adds	r7, #0xc
 800a572: 46bd         	mov	sp, r7
 800a574: f85d 7b04    	ldr	r7, [sp], #4
 800a578: 4770         	bx	lr
 800a57a: bf00         	nop

0800a57c <$d>:
 800a57c: 00 44 02 58  	.word	0x58024400

0800a580 <LL_RCC_PLL1_SetVCOInputRange>:
; {
 800a580: b480         	push	{r7}
 800a582: b083         	sub	sp, #0xc
 800a584: af00         	add	r7, sp, #0x0
 800a586: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL1RGE, InputRange << RCC_PLLCFGR_PLL1RGE_Pos);
 800a588: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a5a8 <LL_RCC_PLL1_SetVCOInputRange+0x28>
 800a58a: 6adb         	ldr	r3, [r3, #0x2c]
 800a58c: f023 020c    	bic	r2, r3, #0xc
 800a590: 687b         	ldr	r3, [r7, #0x4]
 800a592: 009b         	lsls	r3, r3, #0x2
 800a594: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a5a8 <LL_RCC_PLL1_SetVCOInputRange+0x28>
 800a596: 4313         	orrs	r3, r2
 800a598: 62cb         	str	r3, [r1, #0x2c]
; }
 800a59a: bf00         	nop
 800a59c: 370c         	adds	r7, #0xc
 800a59e: 46bd         	mov	sp, r7
 800a5a0: f85d 7b04    	ldr	r7, [sp], #4
 800a5a4: 4770         	bx	lr
 800a5a6: bf00         	nop

0800a5a8 <$d>:
 800a5a8: 00 44 02 58  	.word	0x58024400

0800a5ac <LL_RCC_PLL1_SetN>:
; {
 800a5ac: b480         	push	{r7}
 800a5ae: b083         	sub	sp, #0xc
 800a5b0: af00         	add	r7, sp, #0x0
 800a5b2: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_N1, (N - 1UL) << RCC_PLL1DIVR_N1_Pos);
 800a5b4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a5d4 <LL_RCC_PLL1_SetN+0x28>
 800a5b6: 6b1a         	ldr	r2, [r3, #0x30]
 800a5b8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a5d8 <LL_RCC_PLL1_SetN+0x2c>
 800a5ba: 4013         	ands	r3, r2
 800a5bc: 687a         	ldr	r2, [r7, #0x4]
 800a5be: 3a01         	subs	r2, #0x1
 800a5c0: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a5d4 <LL_RCC_PLL1_SetN+0x28>
 800a5c2: 4313         	orrs	r3, r2
 800a5c4: 630b         	str	r3, [r1, #0x30]
; }
 800a5c6: bf00         	nop
 800a5c8: 370c         	adds	r7, #0xc
 800a5ca: 46bd         	mov	sp, r7
 800a5cc: f85d 7b04    	ldr	r7, [sp], #4
 800a5d0: 4770         	bx	lr
 800a5d2: bf00         	nop

0800a5d4 <$d>:
 800a5d4: 00 44 02 58  	.word	0x58024400
 800a5d8: 00 fe ff ff  	.word	0xfffffe00

0800a5dc <LL_RCC_PLL1_SetM>:
; {
 800a5dc: b480         	push	{r7}
 800a5de: b083         	sub	sp, #0xc
 800a5e0: af00         	add	r7, sp, #0x0
 800a5e2: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM1, M << RCC_PLLCKSELR_DIVM1_Pos);
 800a5e4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a604 <LL_RCC_PLL1_SetM+0x28>
 800a5e6: 6a9b         	ldr	r3, [r3, #0x28]
 800a5e8: f423 727c    	bic	r2, r3, #0x3f0
 800a5ec: 687b         	ldr	r3, [r7, #0x4]
 800a5ee: 011b         	lsls	r3, r3, #0x4
 800a5f0: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a604 <LL_RCC_PLL1_SetM+0x28>
 800a5f2: 4313         	orrs	r3, r2
 800a5f4: 628b         	str	r3, [r1, #0x28]
; }
 800a5f6: bf00         	nop
 800a5f8: 370c         	adds	r7, #0xc
 800a5fa: 46bd         	mov	sp, r7
 800a5fc: f85d 7b04    	ldr	r7, [sp], #4
 800a600: 4770         	bx	lr
 800a602: bf00         	nop

0800a604 <$d>:
 800a604: 00 44 02 58  	.word	0x58024400

0800a608 <LL_RCC_PLL1_SetP>:
; {
 800a608: b480         	push	{r7}
 800a60a: b083         	sub	sp, #0xc
 800a60c: af00         	add	r7, sp, #0x0
 800a60e: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_P1, (P - 1UL) << RCC_PLL1DIVR_P1_Pos);
 800a610: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a630 <LL_RCC_PLL1_SetP+0x28>
 800a612: 6b1b         	ldr	r3, [r3, #0x30]
 800a614: f423 427e    	bic	r2, r3, #0xfe00
 800a618: 687b         	ldr	r3, [r7, #0x4]
 800a61a: 3b01         	subs	r3, #0x1
 800a61c: 025b         	lsls	r3, r3, #0x9
 800a61e: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a630 <LL_RCC_PLL1_SetP+0x28>
 800a620: 4313         	orrs	r3, r2
 800a622: 630b         	str	r3, [r1, #0x30]
; }
 800a624: bf00         	nop
 800a626: 370c         	adds	r7, #0xc
 800a628: 46bd         	mov	sp, r7
 800a62a: f85d 7b04    	ldr	r7, [sp], #4
 800a62e: 4770         	bx	lr

0800a630 <$d>:
 800a630: 00 44 02 58  	.word	0x58024400

0800a634 <LL_RCC_PLL1_SetQ>:
; {
 800a634: b480         	push	{r7}
 800a636: b083         	sub	sp, #0xc
 800a638: af00         	add	r7, sp, #0x0
 800a63a: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_Q1, (Q - 1UL) << RCC_PLL1DIVR_Q1_Pos);
 800a63c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a65c <LL_RCC_PLL1_SetQ+0x28>
 800a63e: 6b1b         	ldr	r3, [r3, #0x30]
 800a640: f423 02fe    	bic	r2, r3, #0x7f0000
 800a644: 687b         	ldr	r3, [r7, #0x4]
 800a646: 3b01         	subs	r3, #0x1
 800a648: 041b         	lsls	r3, r3, #0x10
 800a64a: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a65c <LL_RCC_PLL1_SetQ+0x28>
 800a64c: 4313         	orrs	r3, r2
 800a64e: 630b         	str	r3, [r1, #0x30]
; }
 800a650: bf00         	nop
 800a652: 370c         	adds	r7, #0xc
 800a654: 46bd         	mov	sp, r7
 800a656: f85d 7b04    	ldr	r7, [sp], #4
 800a65a: 4770         	bx	lr

0800a65c <$d>:
 800a65c: 00 44 02 58  	.word	0x58024400

0800a660 <LL_RCC_PLL1_SetR>:
; {
 800a660: b480         	push	{r7}
 800a662: b083         	sub	sp, #0xc
 800a664: af00         	add	r7, sp, #0x0
 800a666: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL1DIVR, RCC_PLL1DIVR_R1, (R - 1UL) << RCC_PLL1DIVR_R1_Pos);
 800a668: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a688 <LL_RCC_PLL1_SetR+0x28>
 800a66a: 6b1b         	ldr	r3, [r3, #0x30]
 800a66c: f023 42fe    	bic	r2, r3, #0x7f000000
 800a670: 687b         	ldr	r3, [r7, #0x4]
 800a672: 3b01         	subs	r3, #0x1
 800a674: 061b         	lsls	r3, r3, #0x18
 800a676: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a688 <LL_RCC_PLL1_SetR+0x28>
 800a678: 4313         	orrs	r3, r2
 800a67a: 630b         	str	r3, [r1, #0x30]
; }
 800a67c: bf00         	nop
 800a67e: 370c         	adds	r7, #0xc
 800a680: 46bd         	mov	sp, r7
 800a682: f85d 7b04    	ldr	r7, [sp], #4
 800a686: 4770         	bx	lr

0800a688 <$d>:
 800a688: 00 44 02 58  	.word	0x58024400

0800a68c <LL_RCC_PLL1_SetFRACN>:
; {
 800a68c: b480         	push	{r7}
 800a68e: b083         	sub	sp, #0xc
 800a690: af00         	add	r7, sp, #0x0
 800a692: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL1FRACR, RCC_PLL1FRACR_FRACN1, FRACN << RCC_PLL1FRACR_FRACN1_Pos);
 800a694: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a6b4 <LL_RCC_PLL1_SetFRACN+0x28>
 800a696: 6b5a         	ldr	r2, [r3, #0x34]
 800a698: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a6b8 <LL_RCC_PLL1_SetFRACN+0x2c>
 800a69a: 4013         	ands	r3, r2
 800a69c: 687a         	ldr	r2, [r7, #0x4]
 800a69e: 00d2         	lsls	r2, r2, #0x3
 800a6a0: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a6b4 <LL_RCC_PLL1_SetFRACN+0x28>
 800a6a2: 4313         	orrs	r3, r2
 800a6a4: 634b         	str	r3, [r1, #0x34]
; }
 800a6a6: bf00         	nop
 800a6a8: 370c         	adds	r7, #0xc
 800a6aa: 46bd         	mov	sp, r7
 800a6ac: f85d 7b04    	ldr	r7, [sp], #4
 800a6b0: 4770         	bx	lr
 800a6b2: bf00         	nop

0800a6b4 <$d>:
 800a6b4: 00 44 02 58  	.word	0x58024400
 800a6b8: 07 00 ff ff  	.word	0xffff0007

0800a6bc <LL_RCC_PLL2_Enable>:
; {
 800a6bc: b480         	push	{r7}
 800a6be: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_PLL2ON);
 800a6c0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a6d8 <LL_RCC_PLL2_Enable+0x1c>
 800a6c2: 681b         	ldr	r3, [r3]
 800a6c4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a6d8 <LL_RCC_PLL2_Enable+0x1c>
 800a6c6: f043 6380    	orr	r3, r3, #0x4000000
 800a6ca: 6013         	str	r3, [r2]
; }
 800a6cc: bf00         	nop
 800a6ce: 46bd         	mov	sp, r7
 800a6d0: f85d 7b04    	ldr	r7, [sp], #4
 800a6d4: 4770         	bx	lr
 800a6d6: bf00         	nop

0800a6d8 <$d>:
 800a6d8: 00 44 02 58  	.word	0x58024400

0800a6dc <LL_RCC_PLL2_Disable>:
; {
 800a6dc: b480         	push	{r7}
 800a6de: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
 800a6e0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a6f8 <LL_RCC_PLL2_Disable+0x1c>
 800a6e2: 681b         	ldr	r3, [r3]
 800a6e4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a6f8 <LL_RCC_PLL2_Disable+0x1c>
 800a6e6: f023 6380    	bic	r3, r3, #0x4000000
 800a6ea: 6013         	str	r3, [r2]
; }
 800a6ec: bf00         	nop
 800a6ee: 46bd         	mov	sp, r7
 800a6f0: f85d 7b04    	ldr	r7, [sp], #4
 800a6f4: 4770         	bx	lr
 800a6f6: bf00         	nop

0800a6f8 <$d>:
 800a6f8: 00 44 02 58  	.word	0x58024400

0800a6fc <LL_RCC_PLL2_IsReady>:
; {
 800a6fc: b480         	push	{r7}
 800a6fe: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CR, RCC_CR_PLL2RDY) == (RCC_CR_PLL2RDY)) ? 1UL : 0UL);
 800a700: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a720 <LL_RCC_PLL2_IsReady+0x24>
 800a702: 681b         	ldr	r3, [r3]
 800a704: f003 6300    	and	r3, r3, #0x8000000
 800a708: f1b3 6f00    	cmp.w	r3, #0x8000000
 800a70c: d101         	bne	0x800a712 <LL_RCC_PLL2_IsReady+0x16> @ imm = #0x2
 800a70e: 2301         	movs	r3, #0x1
 800a710: e000         	b	0x800a714 <LL_RCC_PLL2_IsReady+0x18> @ imm = #0x0
 800a712: 2300         	movs	r3, #0x0
; }
 800a714: 4618         	mov	r0, r3
 800a716: 46bd         	mov	sp, r7
 800a718: f85d 7b04    	ldr	r7, [sp], #4
 800a71c: 4770         	bx	lr
 800a71e: bf00         	nop

0800a720 <$d>:
 800a720: 00 44 02 58  	.word	0x58024400

0800a724 <LL_RCC_PLL2P_Enable>:
; {
 800a724: b480         	push	{r7}
 800a726: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP2EN);
 800a728: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a740 <LL_RCC_PLL2P_Enable+0x1c>
 800a72a: 6adb         	ldr	r3, [r3, #0x2c]
 800a72c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a740 <LL_RCC_PLL2P_Enable+0x1c>
 800a72e: f443 2300    	orr	r3, r3, #0x80000
 800a732: 62d3         	str	r3, [r2, #0x2c]
; }
 800a734: bf00         	nop
 800a736: 46bd         	mov	sp, r7
 800a738: f85d 7b04    	ldr	r7, [sp], #4
 800a73c: 4770         	bx	lr
 800a73e: bf00         	nop

0800a740 <$d>:
 800a740: 00 44 02 58  	.word	0x58024400

0800a744 <LL_RCC_PLL2Q_Enable>:
; {
 800a744: b480         	push	{r7}
 800a746: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ2EN);
 800a748: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a760 <LL_RCC_PLL2Q_Enable+0x1c>
 800a74a: 6adb         	ldr	r3, [r3, #0x2c]
 800a74c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a760 <LL_RCC_PLL2Q_Enable+0x1c>
 800a74e: f443 1380    	orr	r3, r3, #0x100000
 800a752: 62d3         	str	r3, [r2, #0x2c]
; }
 800a754: bf00         	nop
 800a756: 46bd         	mov	sp, r7
 800a758: f85d 7b04    	ldr	r7, [sp], #4
 800a75c: 4770         	bx	lr
 800a75e: bf00         	nop

0800a760 <$d>:
 800a760: 00 44 02 58  	.word	0x58024400

0800a764 <LL_RCC_PLL2R_Enable>:
; {
 800a764: b480         	push	{r7}
 800a766: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR2EN);
 800a768: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a780 <LL_RCC_PLL2R_Enable+0x1c>
 800a76a: 6adb         	ldr	r3, [r3, #0x2c]
 800a76c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a780 <LL_RCC_PLL2R_Enable+0x1c>
 800a76e: f443 1300    	orr	r3, r3, #0x200000
 800a772: 62d3         	str	r3, [r2, #0x2c]
; }
 800a774: bf00         	nop
 800a776: 46bd         	mov	sp, r7
 800a778: f85d 7b04    	ldr	r7, [sp], #4
 800a77c: 4770         	bx	lr
 800a77e: bf00         	nop

0800a780 <$d>:
 800a780: 00 44 02 58  	.word	0x58024400

0800a784 <LL_RCC_PLL2FRACN_Enable>:
; {
 800a784: b480         	push	{r7}
 800a786: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL2FRACEN);
 800a788: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a7a0 <LL_RCC_PLL2FRACN_Enable+0x1c>
 800a78a: 6adb         	ldr	r3, [r3, #0x2c]
 800a78c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a7a0 <LL_RCC_PLL2FRACN_Enable+0x1c>
 800a78e: f043 0310    	orr	r3, r3, #0x10
 800a792: 62d3         	str	r3, [r2, #0x2c]
; }
 800a794: bf00         	nop
 800a796: 46bd         	mov	sp, r7
 800a798: f85d 7b04    	ldr	r7, [sp], #4
 800a79c: 4770         	bx	lr
 800a79e: bf00         	nop

0800a7a0 <$d>:
 800a7a0: 00 44 02 58  	.word	0x58024400

0800a7a4 <LL_RCC_PLL2FRACN_Disable>:
; {
 800a7a4: b480         	push	{r7}
 800a7a6: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL2FRACEN);
 800a7a8: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a7c0 <LL_RCC_PLL2FRACN_Disable+0x1c>
 800a7aa: 6adb         	ldr	r3, [r3, #0x2c]
 800a7ac: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a7c0 <LL_RCC_PLL2FRACN_Disable+0x1c>
 800a7ae: f023 0310    	bic	r3, r3, #0x10
 800a7b2: 62d3         	str	r3, [r2, #0x2c]
; }
 800a7b4: bf00         	nop
 800a7b6: 46bd         	mov	sp, r7
 800a7b8: f85d 7b04    	ldr	r7, [sp], #4
 800a7bc: 4770         	bx	lr
 800a7be: bf00         	nop

0800a7c0 <$d>:
 800a7c0: 00 44 02 58  	.word	0x58024400

0800a7c4 <LL_RCC_PLL2_SetVCOOutputRange>:
; {
 800a7c4: b480         	push	{r7}
 800a7c6: b083         	sub	sp, #0xc
 800a7c8: af00         	add	r7, sp, #0x0
 800a7ca: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL2VCOSEL, VCORange << RCC_PLLCFGR_PLL2VCOSEL_Pos);
 800a7cc: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a7ec <LL_RCC_PLL2_SetVCOOutputRange+0x28>
 800a7ce: 6adb         	ldr	r3, [r3, #0x2c]
 800a7d0: f023 0220    	bic	r2, r3, #0x20
 800a7d4: 687b         	ldr	r3, [r7, #0x4]
 800a7d6: 015b         	lsls	r3, r3, #0x5
 800a7d8: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a7ec <LL_RCC_PLL2_SetVCOOutputRange+0x28>
 800a7da: 4313         	orrs	r3, r2
 800a7dc: 62cb         	str	r3, [r1, #0x2c]
; }
 800a7de: bf00         	nop
 800a7e0: 370c         	adds	r7, #0xc
 800a7e2: 46bd         	mov	sp, r7
 800a7e4: f85d 7b04    	ldr	r7, [sp], #4
 800a7e8: 4770         	bx	lr
 800a7ea: bf00         	nop

0800a7ec <$d>:
 800a7ec: 00 44 02 58  	.word	0x58024400

0800a7f0 <LL_RCC_PLL2_SetVCOInputRange>:
; {
 800a7f0: b480         	push	{r7}
 800a7f2: b083         	sub	sp, #0xc
 800a7f4: af00         	add	r7, sp, #0x0
 800a7f6: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL2RGE, InputRange << RCC_PLLCFGR_PLL2RGE_Pos);
 800a7f8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a818 <LL_RCC_PLL2_SetVCOInputRange+0x28>
 800a7fa: 6adb         	ldr	r3, [r3, #0x2c]
 800a7fc: f023 02c0    	bic	r2, r3, #0xc0
 800a800: 687b         	ldr	r3, [r7, #0x4]
 800a802: 019b         	lsls	r3, r3, #0x6
 800a804: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a818 <LL_RCC_PLL2_SetVCOInputRange+0x28>
 800a806: 4313         	orrs	r3, r2
 800a808: 62cb         	str	r3, [r1, #0x2c]
; }
 800a80a: bf00         	nop
 800a80c: 370c         	adds	r7, #0xc
 800a80e: 46bd         	mov	sp, r7
 800a810: f85d 7b04    	ldr	r7, [sp], #4
 800a814: 4770         	bx	lr
 800a816: bf00         	nop

0800a818 <$d>:
 800a818: 00 44 02 58  	.word	0x58024400

0800a81c <LL_RCC_PLL2_SetN>:
; {
 800a81c: b480         	push	{r7}
 800a81e: b083         	sub	sp, #0xc
 800a820: af00         	add	r7, sp, #0x0
 800a822: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL2DIVR, RCC_PLL2DIVR_N2, (N - 1UL) << RCC_PLL2DIVR_N2_Pos);
 800a824: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a844 <LL_RCC_PLL2_SetN+0x28>
 800a826: 6b9a         	ldr	r2, [r3, #0x38]
 800a828: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a848 <LL_RCC_PLL2_SetN+0x2c>
 800a82a: 4013         	ands	r3, r2
 800a82c: 687a         	ldr	r2, [r7, #0x4]
 800a82e: 3a01         	subs	r2, #0x1
 800a830: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a844 <LL_RCC_PLL2_SetN+0x28>
 800a832: 4313         	orrs	r3, r2
 800a834: 638b         	str	r3, [r1, #0x38]
; }
 800a836: bf00         	nop
 800a838: 370c         	adds	r7, #0xc
 800a83a: 46bd         	mov	sp, r7
 800a83c: f85d 7b04    	ldr	r7, [sp], #4
 800a840: 4770         	bx	lr
 800a842: bf00         	nop

0800a844 <$d>:
 800a844: 00 44 02 58  	.word	0x58024400
 800a848: 00 fe ff ff  	.word	0xfffffe00

0800a84c <LL_RCC_PLL2_SetM>:
; {
 800a84c: b480         	push	{r7}
 800a84e: b083         	sub	sp, #0xc
 800a850: af00         	add	r7, sp, #0x0
 800a852: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM2, M << RCC_PLLCKSELR_DIVM2_Pos);
 800a854: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a874 <LL_RCC_PLL2_SetM+0x28>
 800a856: 6a9b         	ldr	r3, [r3, #0x28]
 800a858: f423 327c    	bic	r2, r3, #0x3f000
 800a85c: 687b         	ldr	r3, [r7, #0x4]
 800a85e: 031b         	lsls	r3, r3, #0xc
 800a860: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a874 <LL_RCC_PLL2_SetM+0x28>
 800a862: 4313         	orrs	r3, r2
 800a864: 628b         	str	r3, [r1, #0x28]
; }
 800a866: bf00         	nop
 800a868: 370c         	adds	r7, #0xc
 800a86a: 46bd         	mov	sp, r7
 800a86c: f85d 7b04    	ldr	r7, [sp], #4
 800a870: 4770         	bx	lr
 800a872: bf00         	nop

0800a874 <$d>:
 800a874: 00 44 02 58  	.word	0x58024400

0800a878 <LL_RCC_PLL2_SetP>:
; {
 800a878: b480         	push	{r7}
 800a87a: b083         	sub	sp, #0xc
 800a87c: af00         	add	r7, sp, #0x0
 800a87e: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL2DIVR, RCC_PLL2DIVR_P2, (P - 1UL) << RCC_PLL2DIVR_P2_Pos);
 800a880: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a8a0 <LL_RCC_PLL2_SetP+0x28>
 800a882: 6b9b         	ldr	r3, [r3, #0x38]
 800a884: f423 427e    	bic	r2, r3, #0xfe00
 800a888: 687b         	ldr	r3, [r7, #0x4]
 800a88a: 3b01         	subs	r3, #0x1
 800a88c: 025b         	lsls	r3, r3, #0x9
 800a88e: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a8a0 <LL_RCC_PLL2_SetP+0x28>
 800a890: 4313         	orrs	r3, r2
 800a892: 638b         	str	r3, [r1, #0x38]
; }
 800a894: bf00         	nop
 800a896: 370c         	adds	r7, #0xc
 800a898: 46bd         	mov	sp, r7
 800a89a: f85d 7b04    	ldr	r7, [sp], #4
 800a89e: 4770         	bx	lr

0800a8a0 <$d>:
 800a8a0: 00 44 02 58  	.word	0x58024400

0800a8a4 <LL_RCC_PLL2_SetQ>:
; {
 800a8a4: b480         	push	{r7}
 800a8a6: b083         	sub	sp, #0xc
 800a8a8: af00         	add	r7, sp, #0x0
 800a8aa: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL2DIVR, RCC_PLL2DIVR_Q2, (Q - 1UL) << RCC_PLL2DIVR_Q2_Pos);
 800a8ac: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a8cc <LL_RCC_PLL2_SetQ+0x28>
 800a8ae: 6b9b         	ldr	r3, [r3, #0x38]
 800a8b0: f423 02fe    	bic	r2, r3, #0x7f0000
 800a8b4: 687b         	ldr	r3, [r7, #0x4]
 800a8b6: 3b01         	subs	r3, #0x1
 800a8b8: 041b         	lsls	r3, r3, #0x10
 800a8ba: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a8cc <LL_RCC_PLL2_SetQ+0x28>
 800a8bc: 4313         	orrs	r3, r2
 800a8be: 638b         	str	r3, [r1, #0x38]
; }
 800a8c0: bf00         	nop
 800a8c2: 370c         	adds	r7, #0xc
 800a8c4: 46bd         	mov	sp, r7
 800a8c6: f85d 7b04    	ldr	r7, [sp], #4
 800a8ca: 4770         	bx	lr

0800a8cc <$d>:
 800a8cc: 00 44 02 58  	.word	0x58024400

0800a8d0 <LL_RCC_PLL2_SetR>:
; {
 800a8d0: b480         	push	{r7}
 800a8d2: b083         	sub	sp, #0xc
 800a8d4: af00         	add	r7, sp, #0x0
 800a8d6: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL2DIVR, RCC_PLL2DIVR_R2, (R - 1UL) << RCC_PLL2DIVR_R2_Pos);
 800a8d8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a8f8 <LL_RCC_PLL2_SetR+0x28>
 800a8da: 6b9b         	ldr	r3, [r3, #0x38]
 800a8dc: f023 42fe    	bic	r2, r3, #0x7f000000
 800a8e0: 687b         	ldr	r3, [r7, #0x4]
 800a8e2: 3b01         	subs	r3, #0x1
 800a8e4: 061b         	lsls	r3, r3, #0x18
 800a8e6: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a8f8 <LL_RCC_PLL2_SetR+0x28>
 800a8e8: 4313         	orrs	r3, r2
 800a8ea: 638b         	str	r3, [r1, #0x38]
; }
 800a8ec: bf00         	nop
 800a8ee: 370c         	adds	r7, #0xc
 800a8f0: 46bd         	mov	sp, r7
 800a8f2: f85d 7b04    	ldr	r7, [sp], #4
 800a8f6: 4770         	bx	lr

0800a8f8 <$d>:
 800a8f8: 00 44 02 58  	.word	0x58024400

0800a8fc <LL_RCC_PLL2_SetFRACN>:
; {
 800a8fc: b480         	push	{r7}
 800a8fe: b083         	sub	sp, #0xc
 800a900: af00         	add	r7, sp, #0x0
 800a902: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL2FRACR, RCC_PLL2FRACR_FRACN2, FRACN << RCC_PLL2FRACR_FRACN2_Pos);
 800a904: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a924 <LL_RCC_PLL2_SetFRACN+0x28>
 800a906: 6bda         	ldr	r2, [r3, #0x3c]
 800a908: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a928 <LL_RCC_PLL2_SetFRACN+0x2c>
 800a90a: 4013         	ands	r3, r2
 800a90c: 687a         	ldr	r2, [r7, #0x4]
 800a90e: 00d2         	lsls	r2, r2, #0x3
 800a910: 4904         	ldr	r1, [pc, #0x10]         @ 0x800a924 <LL_RCC_PLL2_SetFRACN+0x28>
 800a912: 4313         	orrs	r3, r2
 800a914: 63cb         	str	r3, [r1, #0x3c]
; }
 800a916: bf00         	nop
 800a918: 370c         	adds	r7, #0xc
 800a91a: 46bd         	mov	sp, r7
 800a91c: f85d 7b04    	ldr	r7, [sp], #4
 800a920: 4770         	bx	lr
 800a922: bf00         	nop

0800a924 <$d>:
 800a924: 00 44 02 58  	.word	0x58024400
 800a928: 07 00 ff ff  	.word	0xffff0007

0800a92c <LL_RCC_PLL3_Enable>:
; {
 800a92c: b480         	push	{r7}
 800a92e: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_PLL3ON);
 800a930: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a948 <LL_RCC_PLL3_Enable+0x1c>
 800a932: 681b         	ldr	r3, [r3]
 800a934: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a948 <LL_RCC_PLL3_Enable+0x1c>
 800a936: f043 5380    	orr	r3, r3, #0x10000000
 800a93a: 6013         	str	r3, [r2]
; }
 800a93c: bf00         	nop
 800a93e: 46bd         	mov	sp, r7
 800a940: f85d 7b04    	ldr	r7, [sp], #4
 800a944: 4770         	bx	lr
 800a946: bf00         	nop

0800a948 <$d>:
 800a948: 00 44 02 58  	.word	0x58024400

0800a94c <LL_RCC_PLL3_Disable>:
; {
 800a94c: b480         	push	{r7}
 800a94e: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
 800a950: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a968 <LL_RCC_PLL3_Disable+0x1c>
 800a952: 681b         	ldr	r3, [r3]
 800a954: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a968 <LL_RCC_PLL3_Disable+0x1c>
 800a956: f023 5380    	bic	r3, r3, #0x10000000
 800a95a: 6013         	str	r3, [r2]
; }
 800a95c: bf00         	nop
 800a95e: 46bd         	mov	sp, r7
 800a960: f85d 7b04    	ldr	r7, [sp], #4
 800a964: 4770         	bx	lr
 800a966: bf00         	nop

0800a968 <$d>:
 800a968: 00 44 02 58  	.word	0x58024400

0800a96c <LL_RCC_PLL3_IsReady>:
; {
 800a96c: b480         	push	{r7}
 800a96e: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CR, RCC_CR_PLL3RDY) == (RCC_CR_PLL3RDY)) ? 1UL : 0UL);
 800a970: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800a990 <LL_RCC_PLL3_IsReady+0x24>
 800a972: 681b         	ldr	r3, [r3]
 800a974: f003 5300    	and	r3, r3, #0x20000000
 800a978: f1b3 5f00    	cmp.w	r3, #0x20000000
 800a97c: d101         	bne	0x800a982 <LL_RCC_PLL3_IsReady+0x16> @ imm = #0x2
 800a97e: 2301         	movs	r3, #0x1
 800a980: e000         	b	0x800a984 <LL_RCC_PLL3_IsReady+0x18> @ imm = #0x0
 800a982: 2300         	movs	r3, #0x0
; }
 800a984: 4618         	mov	r0, r3
 800a986: 46bd         	mov	sp, r7
 800a988: f85d 7b04    	ldr	r7, [sp], #4
 800a98c: 4770         	bx	lr
 800a98e: bf00         	nop

0800a990 <$d>:
 800a990: 00 44 02 58  	.word	0x58024400

0800a994 <LL_RCC_PLL3P_Enable>:
; {
 800a994: b480         	push	{r7}
 800a996: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP3EN);
 800a998: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a9b0 <LL_RCC_PLL3P_Enable+0x1c>
 800a99a: 6adb         	ldr	r3, [r3, #0x2c]
 800a99c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a9b0 <LL_RCC_PLL3P_Enable+0x1c>
 800a99e: f443 0380    	orr	r3, r3, #0x400000
 800a9a2: 62d3         	str	r3, [r2, #0x2c]
; }
 800a9a4: bf00         	nop
 800a9a6: 46bd         	mov	sp, r7
 800a9a8: f85d 7b04    	ldr	r7, [sp], #4
 800a9ac: 4770         	bx	lr
 800a9ae: bf00         	nop

0800a9b0 <$d>:
 800a9b0: 00 44 02 58  	.word	0x58024400

0800a9b4 <LL_RCC_PLL3Q_Enable>:
; {
 800a9b4: b480         	push	{r7}
 800a9b6: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ3EN);
 800a9b8: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a9d0 <LL_RCC_PLL3Q_Enable+0x1c>
 800a9ba: 6adb         	ldr	r3, [r3, #0x2c]
 800a9bc: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a9d0 <LL_RCC_PLL3Q_Enable+0x1c>
 800a9be: f443 0300    	orr	r3, r3, #0x800000
 800a9c2: 62d3         	str	r3, [r2, #0x2c]
; }
 800a9c4: bf00         	nop
 800a9c6: 46bd         	mov	sp, r7
 800a9c8: f85d 7b04    	ldr	r7, [sp], #4
 800a9cc: 4770         	bx	lr
 800a9ce: bf00         	nop

0800a9d0 <$d>:
 800a9d0: 00 44 02 58  	.word	0x58024400

0800a9d4 <LL_RCC_PLL3R_Enable>:
; {
 800a9d4: b480         	push	{r7}
 800a9d6: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR3EN);
 800a9d8: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a9f0 <LL_RCC_PLL3R_Enable+0x1c>
 800a9da: 6adb         	ldr	r3, [r3, #0x2c]
 800a9dc: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a9f0 <LL_RCC_PLL3R_Enable+0x1c>
 800a9de: f043 7380    	orr	r3, r3, #0x1000000
 800a9e2: 62d3         	str	r3, [r2, #0x2c]
; }
 800a9e4: bf00         	nop
 800a9e6: 46bd         	mov	sp, r7
 800a9e8: f85d 7b04    	ldr	r7, [sp], #4
 800a9ec: 4770         	bx	lr
 800a9ee: bf00         	nop

0800a9f0 <$d>:
 800a9f0: 00 44 02 58  	.word	0x58024400

0800a9f4 <LL_RCC_PLL3FRACN_Enable>:
; {
 800a9f4: b480         	push	{r7}
 800a9f6: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL3FRACEN);
 800a9f8: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800aa10 <LL_RCC_PLL3FRACN_Enable+0x1c>
 800a9fa: 6adb         	ldr	r3, [r3, #0x2c]
 800a9fc: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800aa10 <LL_RCC_PLL3FRACN_Enable+0x1c>
 800a9fe: f443 7380    	orr	r3, r3, #0x100
 800aa02: 62d3         	str	r3, [r2, #0x2c]
; }
 800aa04: bf00         	nop
 800aa06: 46bd         	mov	sp, r7
 800aa08: f85d 7b04    	ldr	r7, [sp], #4
 800aa0c: 4770         	bx	lr
 800aa0e: bf00         	nop

0800aa10 <$d>:
 800aa10: 00 44 02 58  	.word	0x58024400

0800aa14 <LL_RCC_PLL3FRACN_Disable>:
; {
 800aa14: b480         	push	{r7}
 800aa16: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL3FRACEN);
 800aa18: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800aa30 <LL_RCC_PLL3FRACN_Disable+0x1c>
 800aa1a: 6adb         	ldr	r3, [r3, #0x2c]
 800aa1c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800aa30 <LL_RCC_PLL3FRACN_Disable+0x1c>
 800aa1e: f423 7380    	bic	r3, r3, #0x100
 800aa22: 62d3         	str	r3, [r2, #0x2c]
; }
 800aa24: bf00         	nop
 800aa26: 46bd         	mov	sp, r7
 800aa28: f85d 7b04    	ldr	r7, [sp], #4
 800aa2c: 4770         	bx	lr
 800aa2e: bf00         	nop

0800aa30 <$d>:
 800aa30: 00 44 02 58  	.word	0x58024400

0800aa34 <LL_RCC_PLL3_SetVCOOutputRange>:
; {
 800aa34: b480         	push	{r7}
 800aa36: b083         	sub	sp, #0xc
 800aa38: af00         	add	r7, sp, #0x0
 800aa3a: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL3VCOSEL, VCORange << RCC_PLLCFGR_PLL3VCOSEL_Pos);
 800aa3c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800aa5c <LL_RCC_PLL3_SetVCOOutputRange+0x28>
 800aa3e: 6adb         	ldr	r3, [r3, #0x2c]
 800aa40: f423 7200    	bic	r2, r3, #0x200
 800aa44: 687b         	ldr	r3, [r7, #0x4]
 800aa46: 025b         	lsls	r3, r3, #0x9
 800aa48: 4904         	ldr	r1, [pc, #0x10]         @ 0x800aa5c <LL_RCC_PLL3_SetVCOOutputRange+0x28>
 800aa4a: 4313         	orrs	r3, r2
 800aa4c: 62cb         	str	r3, [r1, #0x2c]
; }
 800aa4e: bf00         	nop
 800aa50: 370c         	adds	r7, #0xc
 800aa52: 46bd         	mov	sp, r7
 800aa54: f85d 7b04    	ldr	r7, [sp], #4
 800aa58: 4770         	bx	lr
 800aa5a: bf00         	nop

0800aa5c <$d>:
 800aa5c: 00 44 02 58  	.word	0x58024400

0800aa60 <LL_RCC_PLL3_SetVCOInputRange>:
; {
 800aa60: b480         	push	{r7}
 800aa62: b083         	sub	sp, #0xc
 800aa64: af00         	add	r7, sp, #0x0
 800aa66: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL3RGE, InputRange << RCC_PLLCFGR_PLL3RGE_Pos);
 800aa68: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800aa88 <LL_RCC_PLL3_SetVCOInputRange+0x28>
 800aa6a: 6adb         	ldr	r3, [r3, #0x2c]
 800aa6c: f423 6240    	bic	r2, r3, #0xc00
 800aa70: 687b         	ldr	r3, [r7, #0x4]
 800aa72: 029b         	lsls	r3, r3, #0xa
 800aa74: 4904         	ldr	r1, [pc, #0x10]         @ 0x800aa88 <LL_RCC_PLL3_SetVCOInputRange+0x28>
 800aa76: 4313         	orrs	r3, r2
 800aa78: 62cb         	str	r3, [r1, #0x2c]
; }
 800aa7a: bf00         	nop
 800aa7c: 370c         	adds	r7, #0xc
 800aa7e: 46bd         	mov	sp, r7
 800aa80: f85d 7b04    	ldr	r7, [sp], #4
 800aa84: 4770         	bx	lr
 800aa86: bf00         	nop

0800aa88 <$d>:
 800aa88: 00 44 02 58  	.word	0x58024400

0800aa8c <LL_RCC_PLL3_SetN>:
; {
 800aa8c: b480         	push	{r7}
 800aa8e: b083         	sub	sp, #0xc
 800aa90: af00         	add	r7, sp, #0x0
 800aa92: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL3DIVR, RCC_PLL3DIVR_N3, (N - 1UL) << RCC_PLL3DIVR_N3_Pos);
 800aa94: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800aab4 <LL_RCC_PLL3_SetN+0x28>
 800aa96: 6c1a         	ldr	r2, [r3, #0x40]
 800aa98: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800aab8 <LL_RCC_PLL3_SetN+0x2c>
 800aa9a: 4013         	ands	r3, r2
 800aa9c: 687a         	ldr	r2, [r7, #0x4]
 800aa9e: 3a01         	subs	r2, #0x1
 800aaa0: 4904         	ldr	r1, [pc, #0x10]         @ 0x800aab4 <LL_RCC_PLL3_SetN+0x28>
 800aaa2: 4313         	orrs	r3, r2
 800aaa4: 640b         	str	r3, [r1, #0x40]
; }
 800aaa6: bf00         	nop
 800aaa8: 370c         	adds	r7, #0xc
 800aaaa: 46bd         	mov	sp, r7
 800aaac: f85d 7b04    	ldr	r7, [sp], #4
 800aab0: 4770         	bx	lr
 800aab2: bf00         	nop

0800aab4 <$d>:
 800aab4: 00 44 02 58  	.word	0x58024400
 800aab8: 00 fe ff ff  	.word	0xfffffe00

0800aabc <LL_RCC_PLL3_SetM>:
; {
 800aabc: b480         	push	{r7}
 800aabe: b083         	sub	sp, #0xc
 800aac0: af00         	add	r7, sp, #0x0
 800aac2: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM3, M << RCC_PLLCKSELR_DIVM3_Pos);
 800aac4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800aae4 <LL_RCC_PLL3_SetM+0x28>
 800aac6: 6a9b         	ldr	r3, [r3, #0x28]
 800aac8: f023 727c    	bic	r2, r3, #0x3f00000
 800aacc: 687b         	ldr	r3, [r7, #0x4]
 800aace: 051b         	lsls	r3, r3, #0x14
 800aad0: 4904         	ldr	r1, [pc, #0x10]         @ 0x800aae4 <LL_RCC_PLL3_SetM+0x28>
 800aad2: 4313         	orrs	r3, r2
 800aad4: 628b         	str	r3, [r1, #0x28]
; }
 800aad6: bf00         	nop
 800aad8: 370c         	adds	r7, #0xc
 800aada: 46bd         	mov	sp, r7
 800aadc: f85d 7b04    	ldr	r7, [sp], #4
 800aae0: 4770         	bx	lr
 800aae2: bf00         	nop

0800aae4 <$d>:
 800aae4: 00 44 02 58  	.word	0x58024400

0800aae8 <LL_RCC_PLL3_SetP>:
; {
 800aae8: b480         	push	{r7}
 800aaea: b083         	sub	sp, #0xc
 800aaec: af00         	add	r7, sp, #0x0
 800aaee: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL3DIVR, RCC_PLL3DIVR_P3, (P - 1UL) << RCC_PLL3DIVR_P3_Pos);
 800aaf0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800ab10 <LL_RCC_PLL3_SetP+0x28>
 800aaf2: 6c1b         	ldr	r3, [r3, #0x40]
 800aaf4: f423 427e    	bic	r2, r3, #0xfe00
 800aaf8: 687b         	ldr	r3, [r7, #0x4]
 800aafa: 3b01         	subs	r3, #0x1
 800aafc: 025b         	lsls	r3, r3, #0x9
 800aafe: 4904         	ldr	r1, [pc, #0x10]         @ 0x800ab10 <LL_RCC_PLL3_SetP+0x28>
 800ab00: 4313         	orrs	r3, r2
 800ab02: 640b         	str	r3, [r1, #0x40]
; }
 800ab04: bf00         	nop
 800ab06: 370c         	adds	r7, #0xc
 800ab08: 46bd         	mov	sp, r7
 800ab0a: f85d 7b04    	ldr	r7, [sp], #4
 800ab0e: 4770         	bx	lr

0800ab10 <$d>:
 800ab10: 00 44 02 58  	.word	0x58024400

0800ab14 <LL_RCC_PLL3_SetQ>:
; {
 800ab14: b480         	push	{r7}
 800ab16: b083         	sub	sp, #0xc
 800ab18: af00         	add	r7, sp, #0x0
 800ab1a: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL3DIVR, RCC_PLL3DIVR_Q3, (Q - 1UL) << RCC_PLL3DIVR_Q3_Pos);
 800ab1c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800ab3c <LL_RCC_PLL3_SetQ+0x28>
 800ab1e: 6c1b         	ldr	r3, [r3, #0x40]
 800ab20: f423 02fe    	bic	r2, r3, #0x7f0000
 800ab24: 687b         	ldr	r3, [r7, #0x4]
 800ab26: 3b01         	subs	r3, #0x1
 800ab28: 041b         	lsls	r3, r3, #0x10
 800ab2a: 4904         	ldr	r1, [pc, #0x10]         @ 0x800ab3c <LL_RCC_PLL3_SetQ+0x28>
 800ab2c: 4313         	orrs	r3, r2
 800ab2e: 640b         	str	r3, [r1, #0x40]
; }
 800ab30: bf00         	nop
 800ab32: 370c         	adds	r7, #0xc
 800ab34: 46bd         	mov	sp, r7
 800ab36: f85d 7b04    	ldr	r7, [sp], #4
 800ab3a: 4770         	bx	lr

0800ab3c <$d>:
 800ab3c: 00 44 02 58  	.word	0x58024400

0800ab40 <LL_RCC_PLL3_SetR>:
; {
 800ab40: b480         	push	{r7}
 800ab42: b083         	sub	sp, #0xc
 800ab44: af00         	add	r7, sp, #0x0
 800ab46: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL3DIVR, RCC_PLL3DIVR_R3, (R - 1UL) << RCC_PLL3DIVR_R3_Pos);
 800ab48: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800ab68 <LL_RCC_PLL3_SetR+0x28>
 800ab4a: 6c1b         	ldr	r3, [r3, #0x40]
 800ab4c: f023 42fe    	bic	r2, r3, #0x7f000000
 800ab50: 687b         	ldr	r3, [r7, #0x4]
 800ab52: 3b01         	subs	r3, #0x1
 800ab54: 061b         	lsls	r3, r3, #0x18
 800ab56: 4904         	ldr	r1, [pc, #0x10]         @ 0x800ab68 <LL_RCC_PLL3_SetR+0x28>
 800ab58: 4313         	orrs	r3, r2
 800ab5a: 640b         	str	r3, [r1, #0x40]
; }
 800ab5c: bf00         	nop
 800ab5e: 370c         	adds	r7, #0xc
 800ab60: 46bd         	mov	sp, r7
 800ab62: f85d 7b04    	ldr	r7, [sp], #4
 800ab66: 4770         	bx	lr

0800ab68 <$d>:
 800ab68: 00 44 02 58  	.word	0x58024400

0800ab6c <LL_RCC_PLL3_SetFRACN>:
; {
 800ab6c: b480         	push	{r7}
 800ab6e: b083         	sub	sp, #0xc
 800ab70: af00         	add	r7, sp, #0x0
 800ab72: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->PLL3FRACR, RCC_PLL3FRACR_FRACN3, FRACN << RCC_PLL3FRACR_FRACN3_Pos);
 800ab74: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800ab94 <LL_RCC_PLL3_SetFRACN+0x28>
 800ab76: 6c5a         	ldr	r2, [r3, #0x44]
 800ab78: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800ab98 <LL_RCC_PLL3_SetFRACN+0x2c>
 800ab7a: 4013         	ands	r3, r2
 800ab7c: 687a         	ldr	r2, [r7, #0x4]
 800ab7e: 00d2         	lsls	r2, r2, #0x3
 800ab80: 4904         	ldr	r1, [pc, #0x10]         @ 0x800ab94 <LL_RCC_PLL3_SetFRACN+0x28>
 800ab82: 4313         	orrs	r3, r2
 800ab84: 644b         	str	r3, [r1, #0x44]
; }
 800ab86: bf00         	nop
 800ab88: 370c         	adds	r7, #0xc
 800ab8a: 46bd         	mov	sp, r7
 800ab8c: f85d 7b04    	ldr	r7, [sp], #4
 800ab90: 4770         	bx	lr
 800ab92: bf00         	nop

0800ab94 <$d>:
 800ab94: 00 44 02 58  	.word	0x58024400
 800ab98: 07 00 ff ff  	.word	0xffff0007

0800ab9c <get_pllsrc_frequency>:
; {
 800ab9c: b580         	push	{r7, lr}
 800ab9e: af00         	add	r7, sp, #0x0
; 	switch (LL_RCC_PLL_GetSource()) {
 800aba0: f7ff fc46    	bl	0x800a430 <LL_RCC_PLL_GetSource> @ imm = #-0x774
 800aba4: 4603         	mov	r3, r0
 800aba6: 2b02         	cmp	r3, #0x2
 800aba8: d00a         	beq	0x800abc0 <get_pllsrc_frequency+0x24> @ imm = #0x14
 800abaa: 2b02         	cmp	r3, #0x2
 800abac: d80a         	bhi	0x800abc4 <get_pllsrc_frequency+0x28> @ imm = #0x14
 800abae: 2b00         	cmp	r3, #0x0
 800abb0: d002         	beq	0x800abb8 <get_pllsrc_frequency+0x1c> @ imm = #0x4
 800abb2: 2b01         	cmp	r3, #0x1
 800abb4: d002         	beq	0x800abbc <get_pllsrc_frequency+0x20> @ imm = #0x4
 800abb6: e005         	b	0x800abc4 <get_pllsrc_frequency+0x28> @ imm = #0xa
; 		return STM32_HSI_FREQ;
 800abb8: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800abcc <get_pllsrc_frequency+0x30>
 800abba: e004         	b	0x800abc6 <get_pllsrc_frequency+0x2a> @ imm = #0x8
; 		return STM32_CSI_FREQ;
 800abbc: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800abd0 <get_pllsrc_frequency+0x34>
 800abbe: e002         	b	0x800abc6 <get_pllsrc_frequency+0x2a> @ imm = #0x4
; 		return STM32_HSE_FREQ;
 800abc0: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800abd4 <get_pllsrc_frequency+0x38>
 800abc2: e000         	b	0x800abc6 <get_pllsrc_frequency+0x2a> @ imm = #0x0
; 		return 0;
 800abc4: 2300         	movs	r3, #0x0
; }
 800abc6: 4618         	mov	r0, r3
 800abc8: bd80         	pop	{r7, pc}
 800abca: bf00         	nop

0800abcc <$d>:
 800abcc: 00 90 d0 03  	.word	0x03d09000
 800abd0: 00 09 3d 00  	.word	0x003d0900
 800abd4: 00 36 6e 01  	.word	0x016e3600

0800abd8 <get_hclk_frequency>:
; {
 800abd8: b580         	push	{r7, lr}
 800abda: b082         	sub	sp, #0x8
 800abdc: af00         	add	r7, sp, #0x0
; 	uint32_t sysclk = 0;
 800abde: 2300         	movs	r3, #0x0
 800abe0: 607b         	str	r3, [r7, #0x4]
; 	switch (LL_RCC_GetSysClkSource()) {
 800abe2: f7ff fb8b    	bl	0x800a2fc <LL_RCC_GetSysClkSource> @ imm = #-0x8ea
 800abe6: 4603         	mov	r3, r0
 800abe8: 2b18         	cmp	r3, #0x18
 800abea: d847         	bhi	0x800ac7c <get_hclk_frequency+0xa4> @ imm = #0x8e
 800abec: a201         	adr	r2, #4 <get_hclk_frequency+0x19>
 800abee: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 800abf2: bf00         	nop

0800abf4 <$d>:
 800abf4: 59 ac 00 08  	.word	0x0800ac59
 800abf8: 7d ac 00 08  	.word	0x0800ac7d
 800abfc: 7d ac 00 08  	.word	0x0800ac7d
 800ac00: 7d ac 00 08  	.word	0x0800ac7d
 800ac04: 7d ac 00 08  	.word	0x0800ac7d
 800ac08: 7d ac 00 08  	.word	0x0800ac7d
 800ac0c: 7d ac 00 08  	.word	0x0800ac7d
 800ac10: 7d ac 00 08  	.word	0x0800ac7d
 800ac14: 5f ac 00 08  	.word	0x0800ac5f
 800ac18: 7d ac 00 08  	.word	0x0800ac7d
 800ac1c: 7d ac 00 08  	.word	0x0800ac7d
 800ac20: 7d ac 00 08  	.word	0x0800ac7d
 800ac24: 7d ac 00 08  	.word	0x0800ac7d
 800ac28: 7d ac 00 08  	.word	0x0800ac7d
 800ac2c: 7d ac 00 08  	.word	0x0800ac7d
 800ac30: 7d ac 00 08  	.word	0x0800ac7d
 800ac34: 65 ac 00 08  	.word	0x0800ac65
 800ac38: 7d ac 00 08  	.word	0x0800ac7d
 800ac3c: 7d ac 00 08  	.word	0x0800ac7d
 800ac40: 7d ac 00 08  	.word	0x0800ac7d
 800ac44: 7d ac 00 08  	.word	0x0800ac7d
 800ac48: 7d ac 00 08  	.word	0x0800ac7d
 800ac4c: 7d ac 00 08  	.word	0x0800ac7d
 800ac50: 7d ac 00 08  	.word	0x0800ac7d
 800ac54: 6b ac 00 08  	.word	0x0800ac6b

0800ac58 <$t>:
; 		sysclk = STM32_HSI_FREQ/STM32_HSI_DIVISOR;
 800ac58: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800ac90 <get_hclk_frequency+0xb8>
 800ac5a: 607b         	str	r3, [r7, #0x4]
; 		break;
 800ac5c: e00e         	b	0x800ac7c <get_hclk_frequency+0xa4> @ imm = #0x1c
; 		sysclk = STM32_CSI_FREQ;
 800ac5e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800ac94 <get_hclk_frequency+0xbc>
 800ac60: 607b         	str	r3, [r7, #0x4]
; 		break;
 800ac62: e00b         	b	0x800ac7c <get_hclk_frequency+0xa4> @ imm = #0x16
; 		sysclk = STM32_HSE_FREQ;
 800ac64: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800ac98 <get_hclk_frequency+0xc0>
 800ac66: 607b         	str	r3, [r7, #0x4]
; 		break;
 800ac68: e008         	b	0x800ac7c <get_hclk_frequency+0xa4> @ imm = #0x10
; 		sysclk = get_pllout_frequency(get_pllsrc_frequency(),
 800ac6a: f7ff ff97    	bl	0x800ab9c <get_pllsrc_frequency> @ imm = #-0xd2
 800ac6e: 2301         	movs	r3, #0x1
 800ac70: 2222         	movs	r2, #0x22
 800ac72: 2104         	movs	r1, #0x4
 800ac74: f014 f9c5    	bl	0x801f002 <get_pllout_frequency> @ imm = #0x1438a
 800ac78: 6078         	str	r0, [r7, #0x4]
; 		break;
 800ac7a: bf00         	nop
; 	return get_bus_clock(sysclk, STM32_HPRE);
 800ac7c: 2102         	movs	r1, #0x2
 800ac7e: 6878         	ldr	r0, [r7, #0x4]
 800ac80: f014 f9b0    	bl	0x801efe4 <get_bus_clock> @ imm = #0x14360
 800ac84: 4603         	mov	r3, r0
; }
 800ac86: 4618         	mov	r0, r3
 800ac88: 3708         	adds	r7, #0x8
 800ac8a: 46bd         	mov	sp, r7
 800ac8c: bd80         	pop	{r7, pc}
 800ac8e: bf00         	nop

0800ac90 <$d>:
 800ac90: 00 90 d0 03  	.word	0x03d09000
 800ac94: 00 09 3d 00  	.word	0x003d0900
 800ac98: 00 36 6e 01  	.word	0x016e3600

0800ac9c <get_vco_input_range>:
; {
 800ac9c: b480         	push	{r7}
 800ac9e: b085         	sub	sp, #0x14
 800aca0: af00         	add	r7, sp, #0x0
 800aca2: 6078         	str	r0, [r7, #0x4]
 800aca4: 6039         	str	r1, [r7]
; 	vco_freq = PLLSRC_FREQ / m_div;
 800aca6: 4a1f         	ldr	r2, [pc, #0x7c]         @ 0x800ad24 <get_vco_input_range+0x88>
 800aca8: 687b         	ldr	r3, [r7, #0x4]
 800acaa: fbb2 f3f3    	udiv	r3, r2, r3
 800acae: 60fb         	str	r3, [r7, #0xc]
; 	if (MHZ(1) <= vco_freq && vco_freq <= MHZ(2)) {
 800acb0: 68fb         	ldr	r3, [r7, #0xc]
 800acb2: 4a1d         	ldr	r2, [pc, #0x74]         @ 0x800ad28 <get_vco_input_range+0x8c>
 800acb4: 4293         	cmp	r3, r2
 800acb6: d907         	bls	0x800acc8 <get_vco_input_range+0x2c> @ imm = #0xe
 800acb8: 68fb         	ldr	r3, [r7, #0xc]
 800acba: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x800ad2c <get_vco_input_range+0x90>
 800acbc: 4293         	cmp	r3, r2
 800acbe: d803         	bhi	0x800acc8 <get_vco_input_range+0x2c> @ imm = #0x6
; 		*range = LL_RCC_PLLINPUTRANGE_1_2;
 800acc0: 683b         	ldr	r3, [r7]
 800acc2: 2200         	movs	r2, #0x0
 800acc4: 601a         	str	r2, [r3]
 800acc6: e026         	b	0x800ad16 <get_vco_input_range+0x7a> @ imm = #0x4c
; 	} else if (MHZ(2) < vco_freq && vco_freq <= MHZ(4)) {
 800acc8: 68fb         	ldr	r3, [r7, #0xc]
 800acca: 4a18         	ldr	r2, [pc, #0x60]         @ 0x800ad2c <get_vco_input_range+0x90>
 800accc: 4293         	cmp	r3, r2
 800acce: d907         	bls	0x800ace0 <get_vco_input_range+0x44> @ imm = #0xe
 800acd0: 68fb         	ldr	r3, [r7, #0xc]
 800acd2: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800ad30 <get_vco_input_range+0x94>
 800acd4: 4293         	cmp	r3, r2
 800acd6: d803         	bhi	0x800ace0 <get_vco_input_range+0x44> @ imm = #0x6
; 		*range = LL_RCC_PLLINPUTRANGE_2_4;
 800acd8: 683b         	ldr	r3, [r7]
 800acda: 2201         	movs	r2, #0x1
 800acdc: 601a         	str	r2, [r3]
 800acde: e01a         	b	0x800ad16 <get_vco_input_range+0x7a> @ imm = #0x34
; 	} else if (MHZ(4) < vco_freq && vco_freq <= MHZ(8)) {
 800ace0: 68fb         	ldr	r3, [r7, #0xc]
 800ace2: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800ad30 <get_vco_input_range+0x94>
 800ace4: 4293         	cmp	r3, r2
 800ace6: d907         	bls	0x800acf8 <get_vco_input_range+0x5c> @ imm = #0xe
 800ace8: 68fb         	ldr	r3, [r7, #0xc]
 800acea: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800ad34 <get_vco_input_range+0x98>
 800acec: 4293         	cmp	r3, r2
 800acee: d803         	bhi	0x800acf8 <get_vco_input_range+0x5c> @ imm = #0x6
; 		*range = LL_RCC_PLLINPUTRANGE_4_8;
 800acf0: 683b         	ldr	r3, [r7]
 800acf2: 2202         	movs	r2, #0x2
 800acf4: 601a         	str	r2, [r3]
 800acf6: e00e         	b	0x800ad16 <get_vco_input_range+0x7a> @ imm = #0x1c
; 	} else if (MHZ(8) < vco_freq && vco_freq <= MHZ(16)) {
 800acf8: 68fb         	ldr	r3, [r7, #0xc]
 800acfa: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800ad34 <get_vco_input_range+0x98>
 800acfc: 4293         	cmp	r3, r2
 800acfe: d907         	bls	0x800ad10 <get_vco_input_range+0x74> @ imm = #0xe
 800ad00: 68fb         	ldr	r3, [r7, #0xc]
 800ad02: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800ad38 <get_vco_input_range+0x9c>
 800ad04: 4293         	cmp	r3, r2
 800ad06: d803         	bhi	0x800ad10 <get_vco_input_range+0x74> @ imm = #0x6
; 		*range = LL_RCC_PLLINPUTRANGE_8_16;
 800ad08: 683b         	ldr	r3, [r7]
 800ad0a: 2203         	movs	r2, #0x3
 800ad0c: 601a         	str	r2, [r3]
 800ad0e: e002         	b	0x800ad16 <get_vco_input_range+0x7a> @ imm = #0x4
; 		return -ERANGE;
 800ad10: f06f 0321    	mvn	r3, #0x21
 800ad14: e000         	b	0x800ad18 <get_vco_input_range+0x7c> @ imm = #0x0
; 	return 0;
 800ad16: 2300         	movs	r3, #0x0
; }
 800ad18: 4618         	mov	r0, r3
 800ad1a: 3714         	adds	r7, #0x14
 800ad1c: 46bd         	mov	sp, r7
 800ad1e: f85d 7b04    	ldr	r7, [sp], #4
 800ad22: 4770         	bx	lr

0800ad24 <$d>:
 800ad24: 00 90 d0 03  	.word	0x03d09000
 800ad28: 3f 42 0f 00  	.word	0x000f423f
 800ad2c: 80 84 1e 00  	.word	0x001e8480
 800ad30: 00 09 3d 00  	.word	0x003d0900
 800ad34: 00 12 7a 00  	.word	0x007a1200
 800ad38: 00 24 f4 00  	.word	0x00f42400

0800ad3c <stm32_clock_control_on>:
; {
 800ad3c: b580         	push	{r7, lr}
 800ad3e: b088         	sub	sp, #0x20
 800ad40: af00         	add	r7, sp, #0x0
 800ad42: 6078         	str	r0, [r7, #0x4]
 800ad44: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 800ad46: 683b         	ldr	r3, [r7]
 800ad48: 61fb         	str	r3, [r7, #0x1c]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 800ad4a: 69fb         	ldr	r3, [r7, #0x1c]
 800ad4c: 681b         	ldr	r3, [r3]
 800ad4e: 2bd3         	cmp	r3, #0xd3
 800ad50: d905         	bls	0x800ad5e <stm32_clock_control_on+0x22> @ imm = #0xa
 800ad52: 69fb         	ldr	r3, [r7, #0x1c]
 800ad54: 681b         	ldr	r3, [r3]
 800ad56: 2bf4         	cmp	r3, #0xf4
 800ad58: d801         	bhi	0x800ad5e <stm32_clock_control_on+0x22> @ imm = #0x2
 800ad5a: 2301         	movs	r3, #0x1
 800ad5c: e000         	b	0x800ad60 <stm32_clock_control_on+0x24> @ imm = #0x0
 800ad5e: 2300         	movs	r3, #0x0
 800ad60: 2b00         	cmp	r3, #0x0
 800ad62: d102         	bne	0x800ad6a <stm32_clock_control_on+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 800ad64: f06f 0385    	mvn	r3, #0x85
 800ad68: e022         	b	0x800adb0 <stm32_clock_control_on+0x74> @ imm = #0x44
; 	z_stm32_hsem_lock(CFG_HW_RCC_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 800ad6a: f44f 1180    	mov.w	r1, #0x100000
 800ad6e: 2000         	movs	r0, #0x0
 800ad70: f014 f923    	bl	0x801efba <z_stm32_hsem_lock> @ imm = #0x14246
; 	sys_set_bits(STM32H7_BUS_CLK_REG + pclken->bus, pclken->enr);
 800ad74: 69fb         	ldr	r3, [r7, #0x1c]
 800ad76: 681a         	ldr	r2, [r3]
 800ad78: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800adb8 <stm32_clock_control_on+0x7c>
 800ad7a: 4413         	add	r3, r2
 800ad7c: 69fa         	ldr	r2, [r7, #0x1c]
 800ad7e: 6852         	ldr	r2, [r2, #0x4]
 800ad80: 617b         	str	r3, [r7, #0x14]
 800ad82: 613a         	str	r2, [r7, #0x10]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 800ad84: 697b         	ldr	r3, [r7, #0x14]
 800ad86: 681b         	ldr	r3, [r3]
 800ad88: 60fb         	str	r3, [r7, #0xc]
; 	*(volatile uint32_t *)addr = temp | mask;
 800ad8a: 697b         	ldr	r3, [r7, #0x14]
 800ad8c: 6939         	ldr	r1, [r7, #0x10]
 800ad8e: 68fa         	ldr	r2, [r7, #0xc]
 800ad90: 430a         	orrs	r2, r1
 800ad92: 601a         	str	r2, [r3]
; }
 800ad94: bf00         	nop
; 	temp = sys_read32(STM32H7_BUS_CLK_REG + pclken->bus);
 800ad96: 69fb         	ldr	r3, [r7, #0x1c]
 800ad98: 681a         	ldr	r2, [r3]
 800ad9a: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800adb8 <stm32_clock_control_on+0x7c>
 800ad9c: 4413         	add	r3, r2
 800ad9e: 61bb         	str	r3, [r7, #0x18]
; 	return *(volatile uint32_t *)addr;
 800ada0: 69bb         	ldr	r3, [r7, #0x18]
 800ada2: 681b         	ldr	r3, [r3]
; 	temp = sys_read32(STM32H7_BUS_CLK_REG + pclken->bus);
 800ada4: 60bb         	str	r3, [r7, #0x8]
; 	UNUSED(temp);
 800ada6: 68bb         	ldr	r3, [r7, #0x8]
; 	z_stm32_hsem_unlock(CFG_HW_RCC_SEMID);
 800ada8: 2000         	movs	r0, #0x0
 800adaa: f014 f911    	bl	0x801efd0 <z_stm32_hsem_unlock> @ imm = #0x14222
; 	return 0;
 800adae: 2300         	movs	r3, #0x0
; }
 800adb0: 4618         	mov	r0, r3
 800adb2: 3720         	adds	r7, #0x20
 800adb4: 46bd         	mov	sp, r7
 800adb6: bd80         	pop	{r7, pc}

0800adb8 <$d>:
 800adb8: 00 44 02 58  	.word	0x58024400

0800adbc <stm32_clock_control_off>:
; {
 800adbc: b580         	push	{r7, lr}
 800adbe: b086         	sub	sp, #0x18
 800adc0: af00         	add	r7, sp, #0x0
 800adc2: 6078         	str	r0, [r7, #0x4]
 800adc4: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 800adc6: 683b         	ldr	r3, [r7]
 800adc8: 617b         	str	r3, [r7, #0x14]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 800adca: 697b         	ldr	r3, [r7, #0x14]
 800adcc: 681b         	ldr	r3, [r3]
 800adce: 2bd3         	cmp	r3, #0xd3
 800add0: d905         	bls	0x800adde <stm32_clock_control_off+0x22> @ imm = #0xa
 800add2: 697b         	ldr	r3, [r7, #0x14]
 800add4: 681b         	ldr	r3, [r3]
 800add6: 2bf4         	cmp	r3, #0xf4
 800add8: d801         	bhi	0x800adde <stm32_clock_control_off+0x22> @ imm = #0x2
 800adda: 2301         	movs	r3, #0x1
 800addc: e000         	b	0x800ade0 <stm32_clock_control_off+0x24> @ imm = #0x0
 800adde: 2300         	movs	r3, #0x0
 800ade0: 2b00         	cmp	r3, #0x0
 800ade2: d102         	bne	0x800adea <stm32_clock_control_off+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 800ade4: f06f 0385    	mvn	r3, #0x85
 800ade8: e01a         	b	0x800ae20 <stm32_clock_control_off+0x64> @ imm = #0x34
; 	z_stm32_hsem_lock(CFG_HW_RCC_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 800adea: f44f 1180    	mov.w	r1, #0x100000
 800adee: 2000         	movs	r0, #0x0
 800adf0: f014 f8e3    	bl	0x801efba <z_stm32_hsem_lock> @ imm = #0x141c6
; 	sys_clear_bits(STM32H7_BUS_CLK_REG + pclken->bus, pclken->enr);
 800adf4: 697b         	ldr	r3, [r7, #0x14]
 800adf6: 681a         	ldr	r2, [r3]
 800adf8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800ae28 <stm32_clock_control_off+0x6c>
 800adfa: 4413         	add	r3, r2
 800adfc: 697a         	ldr	r2, [r7, #0x14]
 800adfe: 6852         	ldr	r2, [r2, #0x4]
 800ae00: 613b         	str	r3, [r7, #0x10]
 800ae02: 60fa         	str	r2, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 800ae04: 693b         	ldr	r3, [r7, #0x10]
 800ae06: 681b         	ldr	r3, [r3]
 800ae08: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 800ae0a: 68fb         	ldr	r3, [r7, #0xc]
 800ae0c: 43d9         	mvns	r1, r3
 800ae0e: 693b         	ldr	r3, [r7, #0x10]
 800ae10: 68ba         	ldr	r2, [r7, #0x8]
 800ae12: 400a         	ands	r2, r1
 800ae14: 601a         	str	r2, [r3]
; }
 800ae16: bf00         	nop
; 	z_stm32_hsem_unlock(CFG_HW_RCC_SEMID);
 800ae18: 2000         	movs	r0, #0x0
 800ae1a: f014 f8d9    	bl	0x801efd0 <z_stm32_hsem_unlock> @ imm = #0x141b2
; 	return 0;
 800ae1e: 2300         	movs	r3, #0x0
; }
 800ae20: 4618         	mov	r0, r3
 800ae22: 3718         	adds	r7, #0x18
 800ae24: 46bd         	mov	sp, r7
 800ae26: bd80         	pop	{r7, pc}

0800ae28 <$d>:
 800ae28: 00 44 02 58  	.word	0x58024400

0800ae2c <stm32_clock_control_configure>:
; {
 800ae2c: b580         	push	{r7, lr}
 800ae2e: b08c         	sub	sp, #0x30
 800ae30: af00         	add	r7, sp, #0x0
 800ae32: 60f8         	str	r0, [r7, #0xc]
 800ae34: 60b9         	str	r1, [r7, #0x8]
 800ae36: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 800ae38: 68bb         	ldr	r3, [r7, #0x8]
 800ae3a: 62fb         	str	r3, [r7, #0x2c]
; 	err = enabled_clock(pclken->bus);
 800ae3c: 6afb         	ldr	r3, [r7, #0x2c]
 800ae3e: 681b         	ldr	r3, [r3]
 800ae40: 4618         	mov	r0, r3
 800ae42: f014 f92b    	bl	0x801f09c <enabled_clock> @ imm = #0x14256
 800ae46: 62b8         	str	r0, [r7, #0x28]
; 	if (err < 0) {
 800ae48: 6abb         	ldr	r3, [r7, #0x28]
 800ae4a: 2b00         	cmp	r3, #0x0
 800ae4c: da01         	bge	0x800ae52 <stm32_clock_control_configure+0x26> @ imm = #0x2
; 		return err;
 800ae4e: 6abb         	ldr	r3, [r7, #0x28]
 800ae50: e041         	b	0x800aed6 <stm32_clock_control_configure+0xaa> @ imm = #0x82
; 	z_stm32_hsem_lock(CFG_HW_RCC_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 800ae52: f44f 1180    	mov.w	r1, #0x100000
 800ae56: 2000         	movs	r0, #0x0
 800ae58: f014 f8af    	bl	0x801efba <z_stm32_hsem_lock> @ imm = #0x1415e
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 800ae5c: 6afb         	ldr	r3, [r7, #0x2c]
 800ae5e: 685b         	ldr	r3, [r3, #0x4]
 800ae60: b2da         	uxtb	r2, r3
 800ae62: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800aee0 <stm32_clock_control_configure+0xb4>
 800ae64: 4413         	add	r3, r2
; 		       STM32_CLOCK_MASK_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 800ae66: 6afa         	ldr	r2, [r7, #0x2c]
 800ae68: 6852         	ldr	r2, [r2, #0x4]
 800ae6a: 0b52         	lsrs	r2, r2, #0xd
 800ae6c: f002 0107    	and	r1, r2, #0x7
 800ae70: 6afa         	ldr	r2, [r7, #0x2c]
 800ae72: 6852         	ldr	r2, [r2, #0x4]
 800ae74: 0a12         	lsrs	r2, r2, #0x8
 800ae76: f002 021f    	and	r2, r2, #0x1f
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 800ae7a: fa01 f202    	lsl.w	r2, r1, r2
 800ae7e: 61bb         	str	r3, [r7, #0x18]
 800ae80: 617a         	str	r2, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 800ae82: 69bb         	ldr	r3, [r7, #0x18]
 800ae84: 681b         	ldr	r3, [r3]
 800ae86: 613b         	str	r3, [r7, #0x10]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 800ae88: 697b         	ldr	r3, [r7, #0x14]
 800ae8a: 43d9         	mvns	r1, r3
 800ae8c: 69bb         	ldr	r3, [r7, #0x18]
 800ae8e: 693a         	ldr	r2, [r7, #0x10]
 800ae90: 400a         	ands	r2, r1
 800ae92: 601a         	str	r2, [r3]
; }
 800ae94: bf00         	nop
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 800ae96: 6afb         	ldr	r3, [r7, #0x2c]
 800ae98: 685b         	ldr	r3, [r3, #0x4]
 800ae9a: b2da         	uxtb	r2, r3
 800ae9c: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800aee0 <stm32_clock_control_configure+0xb4>
 800ae9e: 4413         	add	r3, r2
; 		     STM32_CLOCK_VAL_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 800aea0: 6afa         	ldr	r2, [r7, #0x2c]
 800aea2: 6852         	ldr	r2, [r2, #0x4]
 800aea4: 0c12         	lsrs	r2, r2, #0x10
 800aea6: f002 0107    	and	r1, r2, #0x7
 800aeaa: 6afa         	ldr	r2, [r7, #0x2c]
 800aeac: 6852         	ldr	r2, [r2, #0x4]
 800aeae: 0a12         	lsrs	r2, r2, #0x8
 800aeb0: f002 021f    	and	r2, r2, #0x1f
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 800aeb4: fa01 f202    	lsl.w	r2, r1, r2
 800aeb8: 627b         	str	r3, [r7, #0x24]
 800aeba: 623a         	str	r2, [r7, #0x20]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 800aebc: 6a7b         	ldr	r3, [r7, #0x24]
 800aebe: 681b         	ldr	r3, [r3]
 800aec0: 61fb         	str	r3, [r7, #0x1c]
; 	*(volatile uint32_t *)addr = temp | mask;
 800aec2: 6a7b         	ldr	r3, [r7, #0x24]
 800aec4: 6a39         	ldr	r1, [r7, #0x20]
 800aec6: 69fa         	ldr	r2, [r7, #0x1c]
 800aec8: 430a         	orrs	r2, r1
 800aeca: 601a         	str	r2, [r3]
; }
 800aecc: bf00         	nop
; 	z_stm32_hsem_unlock(CFG_HW_RCC_SEMID);
 800aece: 2000         	movs	r0, #0x0
 800aed0: f014 f87e    	bl	0x801efd0 <z_stm32_hsem_unlock> @ imm = #0x140fc
; 	return 0;
 800aed4: 2300         	movs	r3, #0x0
; }
 800aed6: 4618         	mov	r0, r3
 800aed8: 3730         	adds	r7, #0x30
 800aeda: 46bd         	mov	sp, r7
 800aedc: bd80         	pop	{r7, pc}
 800aede: bf00         	nop

0800aee0 <$d>:
 800aee0: 00 44 02 58  	.word	0x58024400

0800aee4 <stm32_clock_control_get_subsys_rate>:
; {
 800aee4: b580         	push	{r7, lr}
 800aee6: b08a         	sub	sp, #0x28
 800aee8: af00         	add	r7, sp, #0x0
 800aeea: 60f8         	str	r0, [r7, #0xc]
 800aeec: 60b9         	str	r1, [r7, #0x8]
 800aeee: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 800aef0: 68bb         	ldr	r3, [r7, #0x8]
 800aef2: 627b         	str	r3, [r7, #0x24]
; 	uint32_t ahb_clock = get_bus_clock(SystemCoreClock, STM32_HPRE);
 800aef4: 4b90         	ldr	r3, [pc, #0x240]        @ 0x800b138 <stm32_clock_control_get_subsys_rate+0x254>
 800aef6: 681b         	ldr	r3, [r3]
 800aef8: 2102         	movs	r1, #0x2
 800aefa: 4618         	mov	r0, r3
 800aefc: f014 f872    	bl	0x801efe4 <get_bus_clock> @ imm = #0x140e4
 800af00: 6238         	str	r0, [r7, #0x20]
; 	uint32_t apb1_clock = get_bus_clock(ahb_clock, STM32_D2PPRE1);
 800af02: 2102         	movs	r1, #0x2
 800af04: 6a38         	ldr	r0, [r7, #0x20]
 800af06: f014 f86d    	bl	0x801efe4 <get_bus_clock> @ imm = #0x140da
 800af0a: 61f8         	str	r0, [r7, #0x1c]
; 	uint32_t apb2_clock = get_bus_clock(ahb_clock, STM32_D2PPRE2);
 800af0c: 2102         	movs	r1, #0x2
 800af0e: 6a38         	ldr	r0, [r7, #0x20]
 800af10: f014 f868    	bl	0x801efe4 <get_bus_clock> @ imm = #0x140d0
 800af14: 61b8         	str	r0, [r7, #0x18]
; 	uint32_t apb3_clock = get_bus_clock(ahb_clock, STM32_D1PPRE);
 800af16: 2102         	movs	r1, #0x2
 800af18: 6a38         	ldr	r0, [r7, #0x20]
 800af1a: f014 f863    	bl	0x801efe4 <get_bus_clock> @ imm = #0x140c6
 800af1e: 6178         	str	r0, [r7, #0x14]
; 	uint32_t apb4_clock = get_bus_clock(ahb_clock, STM32_D3PPRE);
 800af20: 2102         	movs	r1, #0x2
 800af22: 6a38         	ldr	r0, [r7, #0x20]
 800af24: f014 f85e    	bl	0x801efe4 <get_bus_clock> @ imm = #0x140bc
 800af28: 6138         	str	r0, [r7, #0x10]
; 	switch (pclken->bus) {
 800af2a: 6a7b         	ldr	r3, [r7, #0x24]
 800af2c: 681b         	ldr	r3, [r3]
 800af2e: 2bf4         	cmp	r3, #0xf4
 800af30: f200 80fa    	bhi.w	0x800b128 <stm32_clock_control_get_subsys_rate+0x244> @ imm = #0x1f4
 800af34: 2be8         	cmp	r3, #0xe8
 800af36: d204         	bhs	0x800af42 <stm32_clock_control_get_subsys_rate+0x5e> @ imm = #0x8
 800af38: 2b10         	cmp	r3, #0x10
 800af3a: d861         	bhi	0x800b000 <stm32_clock_control_get_subsys_rate+0x11c> @ imm = #0xc2
 800af3c: 2b00         	cmp	r3, #0x0
 800af3e: d138         	bne	0x800afb2 <stm32_clock_control_get_subsys_rate+0xce> @ imm = #0x70
 800af40: e0f2         	b	0x800b128 <stm32_clock_control_get_subsys_rate+0x244> @ imm = #0x1e4
 800af42: 3be8         	subs	r3, #0xe8
 800af44: 2b0c         	cmp	r3, #0xc
 800af46: f200 80ef    	bhi.w	0x800b128 <stm32_clock_control_get_subsys_rate+0x244> @ imm = #0x1de
 800af4a: a201         	adr	r2, #4 <stm32_clock_control_get_subsys_rate+0x6b>
 800af4c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800af50 <$d>:
 800af50: 15 b0 00 08  	.word	0x0800b015
 800af54: 29 b1 00 08  	.word	0x0800b129
 800af58: 29 b1 00 08  	.word	0x0800b129
 800af5c: 29 b1 00 08  	.word	0x0800b129
 800af60: 15 b0 00 08  	.word	0x0800b015
 800af64: 29 b1 00 08  	.word	0x0800b129
 800af68: 29 b1 00 08  	.word	0x0800b129
 800af6c: 29 b1 00 08  	.word	0x0800b129
 800af70: 1d b0 00 08  	.word	0x0800b01d
 800af74: 29 b1 00 08  	.word	0x0800b129
 800af78: 29 b1 00 08  	.word	0x0800b129
 800af7c: 29 b1 00 08  	.word	0x0800b129
 800af80: 2d b0 00 08  	.word	0x0800b02d

0800af84 <$t>:
 800af84: 3bd4         	subs	r3, #0xd4
 800af86: 2201         	movs	r2, #0x1
 800af88: 409a         	lsls	r2, r3
 800af8a: f241 1311    	movw	r3, #0x1111
 800af8e: 4013         	ands	r3, r2
 800af90: 2b00         	cmp	r3, #0x0
 800af92: bf14         	ite	ne
 800af94: 2301         	movne	r3, #0x1
 800af96: 2300         	moveq	r3, #0x0
 800af98: b2db         	uxtb	r3, r3
 800af9a: 2b00         	cmp	r3, #0x0
 800af9c: d136         	bne	0x800b00c <stm32_clock_control_get_subsys_rate+0x128> @ imm = #0x6c
 800af9e: f402 3380    	and	r3, r2, #0x10000
 800afa2: 2b00         	cmp	r3, #0x0
 800afa4: bf14         	ite	ne
 800afa6: 2301         	movne	r3, #0x1
 800afa8: 2300         	moveq	r3, #0x0
 800afaa: b2db         	uxtb	r3, r3
 800afac: 2b00         	cmp	r3, #0x0
 800afae: d139         	bne	0x800b024 <stm32_clock_control_get_subsys_rate+0x140> @ imm = #0x72
 800afb0: e0ba         	b	0x800b128 <stm32_clock_control_get_subsys_rate+0x244> @ imm = #0x174
 800afb2: 3b01         	subs	r3, #0x1
 800afb4: 2b0f         	cmp	r3, #0xf
 800afb6: f200 80b7    	bhi.w	0x800b128 <stm32_clock_control_get_subsys_rate+0x244> @ imm = #0x16e
 800afba: a201         	adr	r2, #4 <stm32_clock_control_get_subsys_rate+0xdb>
 800afbc: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800afc0 <$d>:
 800afc0: 35 b0 00 08  	.word	0x0800b035
 800afc4: 49 b0 00 08  	.word	0x0800b049
 800afc8: 51 b0 00 08  	.word	0x0800b051
 800afcc: 41 b0 00 08  	.word	0x0800b041
 800afd0: 5b b0 00 08  	.word	0x0800b05b
 800afd4: 29 b1 00 08  	.word	0x0800b129
 800afd8: 29 b1 00 08  	.word	0x0800b129
 800afdc: 63 b0 00 08  	.word	0x0800b063
 800afe0: 79 b0 00 08  	.word	0x0800b079
 800afe4: 8f b0 00 08  	.word	0x0800b08f
 800afe8: a5 b0 00 08  	.word	0x0800b0a5
 800afec: bb b0 00 08  	.word	0x0800b0bb
 800aff0: d1 b0 00 08  	.word	0x0800b0d1
 800aff4: e7 b0 00 08  	.word	0x0800b0e7
 800aff8: fd b0 00 08  	.word	0x0800b0fd
 800affc: 13 b1 00 08  	.word	0x0800b113

0800b000 <$t>:
 800b000: 2be4         	cmp	r3, #0xe4
 800b002: f200 8091    	bhi.w	0x800b128 <stm32_clock_control_get_subsys_rate+0x244> @ imm = #0x122
 800b006: 2bd4         	cmp	r3, #0xd4
 800b008: d2bc         	bhs	0x800af84 <stm32_clock_control_get_subsys_rate+0xa0> @ imm = #-0x88
 800b00a: e08d         	b	0x800b128 <stm32_clock_control_get_subsys_rate+0x244> @ imm = #0x11a
; 		*rate = ahb_clock;
 800b00c: 687b         	ldr	r3, [r7, #0x4]
 800b00e: 6a3a         	ldr	r2, [r7, #0x20]
 800b010: 601a         	str	r2, [r3]
; 		break;
 800b012: e08c         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0x118
; 		*rate = apb1_clock;
 800b014: 687b         	ldr	r3, [r7, #0x4]
 800b016: 69fa         	ldr	r2, [r7, #0x1c]
 800b018: 601a         	str	r2, [r3]
; 		break;
 800b01a: e088         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0x110
; 		*rate = apb2_clock;
 800b01c: 687b         	ldr	r3, [r7, #0x4]
 800b01e: 69ba         	ldr	r2, [r7, #0x18]
 800b020: 601a         	str	r2, [r3]
; 		break;
 800b022: e084         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0x108
; 		*rate = apb3_clock;
 800b024: 687b         	ldr	r3, [r7, #0x4]
 800b026: 697a         	ldr	r2, [r7, #0x14]
 800b028: 601a         	str	r2, [r3]
; 		break;
 800b02a: e080         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0x100
; 		*rate = apb4_clock;
 800b02c: 687b         	ldr	r3, [r7, #0x4]
 800b02e: 693a         	ldr	r2, [r7, #0x10]
 800b030: 601a         	str	r2, [r3]
; 		break;
 800b032: e07c         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0xf8
; 		*rate = get_hclk_frequency();
 800b034: f7ff fdd0    	bl	0x800abd8 <get_hclk_frequency> @ imm = #-0x460
 800b038: 4602         	mov	r2, r0
 800b03a: 687b         	ldr	r3, [r7, #0x4]
 800b03c: 601a         	str	r2, [r3]
; 		break;
 800b03e: e076         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0xec
; 		*rate = STM32_HSE_FREQ;
 800b040: 687b         	ldr	r3, [r7, #0x4]
 800b042: 4a3e         	ldr	r2, [pc, #0xf8]         @ 0x800b13c <stm32_clock_control_get_subsys_rate+0x258>
 800b044: 601a         	str	r2, [r3]
; 		break;
 800b046: e072         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0xe4
; 		*rate = STM32_LSE_FREQ;
 800b048: 687b         	ldr	r3, [r7, #0x4]
 800b04a: 2200         	movs	r2, #0x0
 800b04c: 601a         	str	r2, [r3]
; 		break;
 800b04e: e06e         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0xdc
; 		*rate = STM32_LSI_FREQ;
 800b050: 687b         	ldr	r3, [r7, #0x4]
 800b052: f44f 42fa    	mov.w	r2, #0x7d00
 800b056: 601a         	str	r2, [r3]
; 		break;
 800b058: e069         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0xd2
; 		*rate = STM32_HSI48_FREQ;
 800b05a: 687b         	ldr	r3, [r7, #0x4]
 800b05c: 4a38         	ldr	r2, [pc, #0xe0]         @ 0x800b140 <stm32_clock_control_get_subsys_rate+0x25c>
 800b05e: 601a         	str	r2, [r3]
; 		break;
 800b060: e065         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0xca
; 		*rate = get_pllout_frequency(get_pllsrc_frequency(),
 800b062: f7ff fd9b    	bl	0x800ab9c <get_pllsrc_frequency> @ imm = #-0x4ca
 800b066: 2301         	movs	r3, #0x1
 800b068: 2222         	movs	r2, #0x22
 800b06a: 2104         	movs	r1, #0x4
 800b06c: f013 ffc9    	bl	0x801f002 <get_pllout_frequency> @ imm = #0x13f92
 800b070: 4602         	mov	r2, r0
 800b072: 687b         	ldr	r3, [r7, #0x4]
 800b074: 601a         	str	r2, [r3]
; 		break;
 800b076: e05a         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0xb4
; 		*rate = get_pllout_frequency(get_pllsrc_frequency(),
 800b078: f7ff fd90    	bl	0x800ab9c <get_pllsrc_frequency> @ imm = #-0x4e0
 800b07c: 2302         	movs	r3, #0x2
 800b07e: 2222         	movs	r2, #0x22
 800b080: 2104         	movs	r1, #0x4
 800b082: f013 ffbe    	bl	0x801f002 <get_pllout_frequency> @ imm = #0x13f7c
 800b086: 4602         	mov	r2, r0
 800b088: 687b         	ldr	r3, [r7, #0x4]
 800b08a: 601a         	str	r2, [r3]
; 		break;
 800b08c: e04f         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0x9e
; 		*rate = get_pllout_frequency(get_pllsrc_frequency(),
 800b08e: f7ff fd85    	bl	0x800ab9c <get_pllsrc_frequency> @ imm = #-0x4f6
 800b092: 2302         	movs	r3, #0x2
 800b094: 2222         	movs	r2, #0x22
 800b096: 2104         	movs	r1, #0x4
 800b098: f013 ffb3    	bl	0x801f002 <get_pllout_frequency> @ imm = #0x13f66
 800b09c: 4602         	mov	r2, r0
 800b09e: 687b         	ldr	r3, [r7, #0x4]
 800b0a0: 601a         	str	r2, [r3]
; 		break;
 800b0a2: e044         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0x88
; 		*rate = get_pllout_frequency(get_pllsrc_frequency(),
 800b0a4: f7ff fd7a    	bl	0x800ab9c <get_pllsrc_frequency> @ imm = #-0x50c
 800b0a8: 2302         	movs	r3, #0x2
 800b0aa: 2281         	movs	r2, #0x81
 800b0ac: 2120         	movs	r1, #0x20
 800b0ae: f013 ffa8    	bl	0x801f002 <get_pllout_frequency> @ imm = #0x13f50
 800b0b2: 4602         	mov	r2, r0
 800b0b4: 687b         	ldr	r3, [r7, #0x4]
 800b0b6: 601a         	str	r2, [r3]
; 		break;
 800b0b8: e039         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0x72
; 		*rate = get_pllout_frequency(get_pllsrc_frequency(),
 800b0ba: f7ff fd6f    	bl	0x800ab9c <get_pllsrc_frequency> @ imm = #-0x522
 800b0be: 2302         	movs	r3, #0x2
 800b0c0: 2281         	movs	r2, #0x81
 800b0c2: 2120         	movs	r1, #0x20
 800b0c4: f013 ff9d    	bl	0x801f002 <get_pllout_frequency> @ imm = #0x13f3a
 800b0c8: 4602         	mov	r2, r0
 800b0ca: 687b         	ldr	r3, [r7, #0x4]
 800b0cc: 601a         	str	r2, [r3]
; 		break;
 800b0ce: e02e         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0x5c
; 		*rate = get_pllout_frequency(get_pllsrc_frequency(),
 800b0d0: f7ff fd64    	bl	0x800ab9c <get_pllsrc_frequency> @ imm = #-0x538
 800b0d4: 2302         	movs	r3, #0x2
 800b0d6: 2281         	movs	r2, #0x81
 800b0d8: 2120         	movs	r1, #0x20
 800b0da: f013 ff92    	bl	0x801f002 <get_pllout_frequency> @ imm = #0x13f24
 800b0de: 4602         	mov	r2, r0
 800b0e0: 687b         	ldr	r3, [r7, #0x4]
 800b0e2: 601a         	str	r2, [r3]
; 		break;
 800b0e4: e023         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0x46
; 		*rate = get_pllout_frequency(get_pllsrc_frequency(),
 800b0e6: f7ff fd59    	bl	0x800ab9c <get_pllsrc_frequency> @ imm = #-0x54e
 800b0ea: 2302         	movs	r3, #0x2
 800b0ec: 2281         	movs	r2, #0x81
 800b0ee: 2120         	movs	r1, #0x20
 800b0f0: f013 ff87    	bl	0x801f002 <get_pllout_frequency> @ imm = #0x13f0e
 800b0f4: 4602         	mov	r2, r0
 800b0f6: 687b         	ldr	r3, [r7, #0x4]
 800b0f8: 601a         	str	r2, [r3]
; 		break;
 800b0fa: e018         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0x30
; 		*rate = get_pllout_frequency(get_pllsrc_frequency(),
 800b0fc: f7ff fd4e    	bl	0x800ab9c <get_pllsrc_frequency> @ imm = #-0x564
 800b100: 2302         	movs	r3, #0x2
 800b102: 2281         	movs	r2, #0x81
 800b104: 2120         	movs	r1, #0x20
 800b106: f013 ff7c    	bl	0x801f002 <get_pllout_frequency> @ imm = #0x13ef8
 800b10a: 4602         	mov	r2, r0
 800b10c: 687b         	ldr	r3, [r7, #0x4]
 800b10e: 601a         	str	r2, [r3]
; 		break;
 800b110: e00d         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0x1a
; 		*rate = get_pllout_frequency(get_pllsrc_frequency(),
 800b112: f7ff fd43    	bl	0x800ab9c <get_pllsrc_frequency> @ imm = #-0x57a
 800b116: 2302         	movs	r3, #0x2
 800b118: 2281         	movs	r2, #0x81
 800b11a: 2120         	movs	r1, #0x20
 800b11c: f013 ff71    	bl	0x801f002 <get_pllout_frequency> @ imm = #0x13ee2
 800b120: 4602         	mov	r2, r0
 800b122: 687b         	ldr	r3, [r7, #0x4]
 800b124: 601a         	str	r2, [r3]
; 		break;
 800b126: e002         	b	0x800b12e <stm32_clock_control_get_subsys_rate+0x24a> @ imm = #0x4
; 		return -ENOTSUP;
 800b128: f06f 0385    	mvn	r3, #0x85
 800b12c: e000         	b	0x800b130 <stm32_clock_control_get_subsys_rate+0x24c> @ imm = #0x0
; 	return 0;
 800b12e: 2300         	movs	r3, #0x0
; }
 800b130: 4618         	mov	r0, r3
 800b132: 3728         	adds	r7, #0x28
 800b134: 46bd         	mov	sp, r7
 800b136: bd80         	pop	{r7, pc}

0800b138 <$d>:
 800b138: 4c 0b 00 24  	.word	0x24000b4c
 800b13c: 00 36 6e 01  	.word	0x016e3600
 800b140: 00 6c dc 02  	.word	0x02dc6c00

0800b144 <stm32_clock_control_init>:
; {
 800b144: b580         	push	{r7, lr}
 800b146: b086         	sub	sp, #0x18
 800b148: af00         	add	r7, sp, #0x0
 800b14a: 6078         	str	r0, [r7, #0x4]
; 	int r = 0;
 800b14c: 2300         	movs	r3, #0x0
 800b14e: 617b         	str	r3, [r7, #0x14]
; 	LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_HSEM);
 800b150: f04f 7000    	mov.w	r0, #0x2000000
 800b154: f7fe ff7c    	bl	0x800a050 <LL_AHB4_GRP1_EnableClock> @ imm = #-0x1108
; 	z_stm32_hsem_lock(CFG_HW_RCC_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 800b158: f44f 1180    	mov.w	r1, #0x100000
 800b15c: 2000         	movs	r0, #0x0
 800b15e: f013 ff2c    	bl	0x801efba <z_stm32_hsem_lock> @ imm = #0x13e58
; 	stm32_clock_control_mco_init();
 800b162: f013 ff23    	bl	0x801efac <stm32_clock_control_mco_init> @ imm = #0x13e46
; 	set_up_fixed_clock_sources();
 800b166: f013 ffd4    	bl	0x801f112 <set_up_fixed_clock_sources> @ imm = #0x13fa8
; 	r = set_up_plls();
 800b16a: f014 f827    	bl	0x801f1bc <set_up_plls> @ imm = #0x1404e
 800b16e: 6178         	str	r0, [r7, #0x14]
; 	if (r < 0) {
 800b170: 697b         	ldr	r3, [r7, #0x14]
 800b172: 2b00         	cmp	r3, #0x0
 800b174: da01         	bge	0x800b17a <stm32_clock_control_init+0x36> @ imm = #0x2
; 		return r;
 800b176: 697b         	ldr	r3, [r7, #0x14]
 800b178: e03d         	b	0x800b1f6 <stm32_clock_control_init+0xb2> @ imm = #0x7a
; 	prepare_regulator_voltage_scale();
 800b17a: f013 ff59    	bl	0x801f030 <prepare_regulator_voltage_scale> @ imm = #0x13eb2
; 	old_hclk_freq = get_hclk_frequency();
 800b17e: f7ff fd2b    	bl	0x800abd8 <get_hclk_frequency> @ imm = #-0x5aa
 800b182: 6138         	str	r0, [r7, #0x10]
; 	new_hclk_freq = get_bus_clock(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC,
 800b184: 2102         	movs	r1, #0x2
 800b186: 481e         	ldr	r0, [pc, #0x78]         @ 0x800b200 <stm32_clock_control_init+0xbc>
 800b188: f013 ff2c    	bl	0x801efe4 <get_bus_clock> @ imm = #0x13e58
 800b18c: 60f8         	str	r0, [r7, #0xc]
; 	if (new_hclk_freq > old_hclk_freq) {
 800b18e: 68fa         	ldr	r2, [r7, #0xc]
 800b190: 693b         	ldr	r3, [r7, #0x10]
 800b192: 429a         	cmp	r2, r3
 800b194: d902         	bls	0x800b19c <stm32_clock_control_init+0x58> @ imm = #0x4
; 		LL_SetFlashLatency(new_hclk_freq);
 800b196: 68f8         	ldr	r0, [r7, #0xc]
 800b198: f009 f82a    	bl	0x80141f0 <LL_SetFlashLatency> @ imm = #0x9054
; 	LL_RCC_SetSysPrescaler(sysclk_prescaler(STM32_D1CPRE));
 800b19c: 2000         	movs	r0, #0x0
 800b19e: f7ff f8bb    	bl	0x800a318 <LL_RCC_SetSysPrescaler> @ imm = #-0xe8a
; 	LL_RCC_SetAHBPrescaler(ahb_prescaler(STM32_HPRE));
 800b1a2: 2008         	movs	r0, #0x8
 800b1a4: f7ff f8cc    	bl	0x800a340 <LL_RCC_SetAHBPrescaler> @ imm = #-0xe68
; 	LL_RCC_SetAPB1Prescaler(apb1_prescaler(STM32_D2PPRE1));
 800b1a8: 2040         	movs	r0, #0x40
 800b1aa: f7ff f8dd    	bl	0x800a368 <LL_RCC_SetAPB1Prescaler> @ imm = #-0xe46
; 	LL_RCC_SetAPB2Prescaler(apb2_prescaler(STM32_D2PPRE2));
 800b1ae: f44f 6080    	mov.w	r0, #0x400
 800b1b2: f7ff f8ed    	bl	0x800a390 <LL_RCC_SetAPB2Prescaler> @ imm = #-0xe26
; 	LL_RCC_SetAPB3Prescaler(apb3_prescaler(STM32_D1PPRE));
 800b1b6: 2040         	movs	r0, #0x40
 800b1b8: f7ff f8fe    	bl	0x800a3b8 <LL_RCC_SetAPB3Prescaler> @ imm = #-0xe04
; 	LL_RCC_SetAPB4Prescaler(apb4_prescaler(STM32_D3PPRE));
 800b1bc: 2040         	movs	r0, #0x40
 800b1be: f7ff f90f    	bl	0x800a3e0 <LL_RCC_SetAPB4Prescaler> @ imm = #-0xde2
; 		LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL1);
 800b1c2: 2003         	movs	r0, #0x3
 800b1c4: f7ff f886    	bl	0x800a2d4 <LL_RCC_SetSysClkSource> @ imm = #-0xef4
; 		while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL1) {
 800b1c8: bf00         	nop
 800b1ca: f7ff f897    	bl	0x800a2fc <LL_RCC_GetSysClkSource> @ imm = #-0xed2
 800b1ce: 4603         	mov	r3, r0
 800b1d0: 2b18         	cmp	r3, #0x18
 800b1d2: d1fa         	bne	0x800b1ca <stm32_clock_control_init+0x86> @ imm = #-0xc
; 	if (new_hclk_freq <= old_hclk_freq) {
 800b1d4: 68fa         	ldr	r2, [r7, #0xc]
 800b1d6: 693b         	ldr	r3, [r7, #0x10]
 800b1d8: 429a         	cmp	r2, r3
 800b1da: d802         	bhi	0x800b1e2 <stm32_clock_control_init+0x9e> @ imm = #0x4
; 		LL_SetFlashLatency(new_hclk_freq);
 800b1dc: 68f8         	ldr	r0, [r7, #0xc]
 800b1de: f009 f807    	bl	0x80141f0 <LL_SetFlashLatency> @ imm = #0x900e
; 	optimize_regulator_voltage_scale(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC);
 800b1e2: 4807         	ldr	r0, [pc, #0x1c]         @ 0x800b200 <stm32_clock_control_init+0xbc>
 800b1e4: f013 ff35    	bl	0x801f052 <optimize_regulator_voltage_scale> @ imm = #0x13e6a
; 	z_stm32_hsem_unlock(CFG_HW_RCC_SEMID);
 800b1e8: 2000         	movs	r0, #0x0
 800b1ea: f013 fef1    	bl	0x801efd0 <z_stm32_hsem_unlock> @ imm = #0x13de2
; 	SystemCoreClock = CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC;
 800b1ee: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800b204 <stm32_clock_control_init+0xc0>
 800b1f0: 4a03         	ldr	r2, [pc, #0xc]          @ 0x800b200 <stm32_clock_control_init+0xbc>
 800b1f2: 601a         	str	r2, [r3]
; 	return r;
 800b1f4: 697b         	ldr	r3, [r7, #0x14]
; }
 800b1f6: 4618         	mov	r0, r3
 800b1f8: 3718         	adds	r7, #0x18
 800b1fa: 46bd         	mov	sp, r7
 800b1fc: bd80         	pop	{r7, pc}
 800b1fe: bf00         	nop

0800b200 <$d>:
 800b200: 80 55 c8 20  	.word	0x20c85580
 800b204: 4c 0b 00 24  	.word	0x24000b4c

0800b208 <console_out>:
; {
 800b208: b580         	push	{r7, lr}
 800b20a: b082         	sub	sp, #0x8
 800b20c: af00         	add	r7, sp, #0x0
 800b20e: 6078         	str	r0, [r7, #0x4]
; 	if (pm_device_runtime_get(uart_console_dev) < 0) {
 800b210: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800b25c <console_out+0x54>
 800b212: 4618         	mov	r0, r3
 800b214: f014 f8cd    	bl	0x801f3b2 <pm_device_runtime_get> @ imm = #0x1419a
 800b218: 4603         	mov	r3, r0
 800b21a: 2b00         	cmp	r3, #0x0
 800b21c: da01         	bge	0x800b222 <console_out+0x1a> @ imm = #0x2
; 		return c;
 800b21e: 6879         	ldr	r1, [r7, #0x4]
 800b220: e017         	b	0x800b252 <console_out+0x4a> @ imm = #0x2e
; 	if ('\n' == c) {
 800b222: 687b         	ldr	r3, [r7, #0x4]
 800b224: 2b0a         	cmp	r3, #0xa
 800b226: d104         	bne	0x800b232 <console_out+0x2a> @ imm = #0x8
; 		uart_poll_out(uart_console_dev, '\r');
 800b228: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800b25c <console_out+0x54>
 800b22a: 210d         	movs	r1, #0xd
 800b22c: 4618         	mov	r0, r3
 800b22e: f014 f8b1    	bl	0x801f394 <uart_poll_out> @ imm = #0x14162
; 	uart_poll_out(uart_console_dev, c);
 800b232: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800b25c <console_out+0x54>
 800b234: 687b         	ldr	r3, [r7, #0x4]
 800b236: b2db         	uxtb	r3, r3
 800b238: 4619         	mov	r1, r3
 800b23a: 4610         	mov	r0, r2
 800b23c: f014 f8aa    	bl	0x801f394 <uart_poll_out> @ imm = #0x14154
; 	(void)pm_device_runtime_put_async(uart_console_dev, K_MSEC(1));
 800b240: 4906         	ldr	r1, [pc, #0x18]         @ 0x800b25c <console_out+0x54>
 800b242: f04f 020a    	mov.w	r2, #0xa
 800b246: f04f 0300    	mov.w	r3, #0x0
 800b24a: 4608         	mov	r0, r1
 800b24c: f014 f8bc    	bl	0x801f3c8 <pm_device_runtime_put_async> @ imm = #0x14178
; 	return c;
 800b250: 6879         	ldr	r1, [r7, #0x4]
; }
 800b252: 460b         	mov	r3, r1
 800b254: 4618         	mov	r0, r3
 800b256: 3708         	adds	r7, #0x8
 800b258: 46bd         	mov	sp, r7
 800b25a: bd80         	pop	{r7, pc}

0800b25c <$d>:
 800b25c: 3c 98 02 08  	.word	0x0802983c

0800b260 <uart_console_hook_install>:
; {
 800b260: b580         	push	{r7, lr}
 800b262: af00         	add	r7, sp, #0x0
; 	__stdout_hook_install(console_out);
 800b264: 4803         	ldr	r0, [pc, #0xc]          @ 0x800b274 <uart_console_hook_install+0x14>
 800b266: f7fb fb55    	bl	0x8006914 <__stdout_hook_install> @ imm = #-0x4956
; 	__printk_hook_install(console_out);
 800b26a: 4802         	ldr	r0, [pc, #0x8]          @ 0x800b274 <uart_console_hook_install+0x14>
 800b26c: f7f8 ffb6    	bl	0x80041dc <__printk_hook_install> @ imm = #-0x7094
; }
 800b270: bf00         	nop
 800b272: bd80         	pop	{r7, pc}

0800b274 <$d>:
 800b274: 09 b2 00 08  	.word	0x0800b209

0800b278 <uart_console_init>:
; {
 800b278: b580         	push	{r7, lr}
 800b27a: af00         	add	r7, sp, #0x0
; 	if (!device_is_ready(uart_console_dev)) {
 800b27c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800b2a0 <uart_console_init+0x28>
 800b27e: 4618         	mov	r0, r3
 800b280: f014 f869    	bl	0x801f356 <device_is_ready> @ imm = #0x140d2
 800b284: 4603         	mov	r3, r0
 800b286: f083 0301    	eor	r3, r3, #0x1
 800b28a: b2db         	uxtb	r3, r3
 800b28c: 2b00         	cmp	r3, #0x0
 800b28e: d002         	beq	0x800b296 <uart_console_init+0x1e> @ imm = #0x4
; 		return -ENODEV;
 800b290: f06f 0312    	mvn	r3, #0x12
 800b294: e002         	b	0x800b29c <uart_console_init+0x24> @ imm = #0x4
; 	uart_console_hook_install();
 800b296: f7ff ffe3    	bl	0x800b260 <uart_console_hook_install> @ imm = #-0x3a
; 	return 0;
 800b29a: 2300         	movs	r3, #0x0
; }
 800b29c: 4618         	mov	r0, r3
 800b29e: bd80         	pop	{r7, pc}

0800b2a0 <$d>:
 800b2a0: 3c 98 02 08  	.word	0x0802983c

0800b2a4 <LL_DMA_SetDataLength>:
; {
 800b2a4: b480         	push	{r7}
 800b2a6: b087         	sub	sp, #0x1c
 800b2a8: af00         	add	r7, sp, #0x0
 800b2aa: 60f8         	str	r0, [r7, #0xc]
 800b2ac: 60b9         	str	r1, [r7, #0x8]
 800b2ae: 607a         	str	r2, [r7, #0x4]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800b2b0: 68fb         	ldr	r3, [r7, #0xc]
 800b2b2: 617b         	str	r3, [r7, #0x14]
;   MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->NDTR, DMA_SxNDT, NbData);
 800b2b4: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800b2ec <LL_DMA_SetDataLength+0x48>
 800b2b6: 68bb         	ldr	r3, [r7, #0x8]
 800b2b8: 4413         	add	r3, r2
 800b2ba: 781b         	ldrb	r3, [r3]
 800b2bc: 461a         	mov	r2, r3
 800b2be: 697b         	ldr	r3, [r7, #0x14]
 800b2c0: 4413         	add	r3, r2
 800b2c2: 685a         	ldr	r2, [r3, #0x4]
 800b2c4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800b2f0 <LL_DMA_SetDataLength+0x4c>
 800b2c6: 4013         	ands	r3, r2
 800b2c8: 4908         	ldr	r1, [pc, #0x20]         @ 0x800b2ec <LL_DMA_SetDataLength+0x48>
 800b2ca: 68ba         	ldr	r2, [r7, #0x8]
 800b2cc: 440a         	add	r2, r1
 800b2ce: 7812         	ldrb	r2, [r2]
 800b2d0: 4611         	mov	r1, r2
 800b2d2: 697a         	ldr	r2, [r7, #0x14]
 800b2d4: 440a         	add	r2, r1
 800b2d6: 4611         	mov	r1, r2
 800b2d8: 687a         	ldr	r2, [r7, #0x4]
 800b2da: 4313         	orrs	r3, r2
 800b2dc: 604b         	str	r3, [r1, #0x4]
; }
 800b2de: bf00         	nop
 800b2e0: 371c         	adds	r7, #0x1c
 800b2e2: 46bd         	mov	sp, r7
 800b2e4: f85d 7b04    	ldr	r7, [sp], #4
 800b2e8: 4770         	bx	lr
 800b2ea: bf00         	nop

0800b2ec <$d>:
 800b2ec: 48 d1 02 08  	.word	0x0802d148
 800b2f0: 00 00 ff ff  	.word	0xffff0000

0800b2f4 <LL_DMA_GetDataLength>:
; {
 800b2f4: b480         	push	{r7}
 800b2f6: b085         	sub	sp, #0x14
 800b2f8: af00         	add	r7, sp, #0x0
 800b2fa: 6078         	str	r0, [r7, #0x4]
 800b2fc: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800b2fe: 687b         	ldr	r3, [r7, #0x4]
 800b300: 60fb         	str	r3, [r7, #0xc]
;   return (READ_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->NDTR, DMA_SxNDT));
 800b302: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800b320 <LL_DMA_GetDataLength+0x2c>
 800b304: 683b         	ldr	r3, [r7]
 800b306: 4413         	add	r3, r2
 800b308: 781b         	ldrb	r3, [r3]
 800b30a: 461a         	mov	r2, r3
 800b30c: 68fb         	ldr	r3, [r7, #0xc]
 800b30e: 4413         	add	r3, r2
 800b310: 685b         	ldr	r3, [r3, #0x4]
 800b312: b29b         	uxth	r3, r3
; }
 800b314: 4618         	mov	r0, r3
 800b316: 3714         	adds	r7, #0x14
 800b318: 46bd         	mov	sp, r7
 800b31a: f85d 7b04    	ldr	r7, [sp], #4
 800b31e: 4770         	bx	lr

0800b320 <$d>:
 800b320: 48 d1 02 08  	.word	0x0802d148

0800b324 <LL_DMA_DisableFifoMode>:
; {
 800b324: b480         	push	{r7}
 800b326: b085         	sub	sp, #0x14
 800b328: af00         	add	r7, sp, #0x0
 800b32a: 6078         	str	r0, [r7, #0x4]
 800b32c: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800b32e: 687b         	ldr	r3, [r7, #0x4]
 800b330: 60fb         	str	r3, [r7, #0xc]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->FCR, DMA_SxFCR_DMDIS);
 800b332: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b364 <LL_DMA_DisableFifoMode+0x40>
 800b334: 683b         	ldr	r3, [r7]
 800b336: 4413         	add	r3, r2
 800b338: 781b         	ldrb	r3, [r3]
 800b33a: 461a         	mov	r2, r3
 800b33c: 68fb         	ldr	r3, [r7, #0xc]
 800b33e: 4413         	add	r3, r2
 800b340: 695b         	ldr	r3, [r3, #0x14]
 800b342: 4908         	ldr	r1, [pc, #0x20]         @ 0x800b364 <LL_DMA_DisableFifoMode+0x40>
 800b344: 683a         	ldr	r2, [r7]
 800b346: 440a         	add	r2, r1
 800b348: 7812         	ldrb	r2, [r2]
 800b34a: 4611         	mov	r1, r2
 800b34c: 68fa         	ldr	r2, [r7, #0xc]
 800b34e: 440a         	add	r2, r1
 800b350: f023 0304    	bic	r3, r3, #0x4
 800b354: 6153         	str	r3, [r2, #0x14]
; }
 800b356: bf00         	nop
 800b358: 3714         	adds	r7, #0x14
 800b35a: 46bd         	mov	sp, r7
 800b35c: f85d 7b04    	ldr	r7, [sp], #4
 800b360: 4770         	bx	lr
 800b362: bf00         	nop

0800b364 <$d>:
 800b364: 48 d1 02 08  	.word	0x0802d148

0800b368 <LL_DMA_EnableFifoMode>:
; {
 800b368: b480         	push	{r7}
 800b36a: b085         	sub	sp, #0x14
 800b36c: af00         	add	r7, sp, #0x0
 800b36e: 6078         	str	r0, [r7, #0x4]
 800b370: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800b372: 687b         	ldr	r3, [r7, #0x4]
 800b374: 60fb         	str	r3, [r7, #0xc]
;   SET_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->FCR, DMA_SxFCR_DMDIS);
 800b376: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b3a8 <LL_DMA_EnableFifoMode+0x40>
 800b378: 683b         	ldr	r3, [r7]
 800b37a: 4413         	add	r3, r2
 800b37c: 781b         	ldrb	r3, [r3]
 800b37e: 461a         	mov	r2, r3
 800b380: 68fb         	ldr	r3, [r7, #0xc]
 800b382: 4413         	add	r3, r2
 800b384: 695b         	ldr	r3, [r3, #0x14]
 800b386: 4908         	ldr	r1, [pc, #0x20]         @ 0x800b3a8 <LL_DMA_EnableFifoMode+0x40>
 800b388: 683a         	ldr	r2, [r7]
 800b38a: 440a         	add	r2, r1
 800b38c: 7812         	ldrb	r2, [r2]
 800b38e: 4611         	mov	r1, r2
 800b390: 68fa         	ldr	r2, [r7, #0xc]
 800b392: 440a         	add	r2, r1
 800b394: f043 0304    	orr	r3, r3, #0x4
 800b398: 6153         	str	r3, [r2, #0x14]
; }
 800b39a: bf00         	nop
 800b39c: 3714         	adds	r7, #0x14
 800b39e: 46bd         	mov	sp, r7
 800b3a0: f85d 7b04    	ldr	r7, [sp], #4
 800b3a4: 4770         	bx	lr
 800b3a6: bf00         	nop

0800b3a8 <$d>:
 800b3a8: 48 d1 02 08  	.word	0x0802d148

0800b3ac <LL_DMA_SetMemoryAddress>:
; {
 800b3ac: b480         	push	{r7}
 800b3ae: b087         	sub	sp, #0x1c
 800b3b0: af00         	add	r7, sp, #0x0
 800b3b2: 60f8         	str	r0, [r7, #0xc]
 800b3b4: 60b9         	str	r1, [r7, #0x8]
 800b3b6: 607a         	str	r2, [r7, #0x4]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800b3b8: 68fb         	ldr	r3, [r7, #0xc]
 800b3ba: 617b         	str	r3, [r7, #0x14]
;   WRITE_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->M0AR, MemoryAddress);
 800b3bc: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800b3dc <LL_DMA_SetMemoryAddress+0x30>
 800b3be: 68bb         	ldr	r3, [r7, #0x8]
 800b3c0: 4413         	add	r3, r2
 800b3c2: 781b         	ldrb	r3, [r3]
 800b3c4: 461a         	mov	r2, r3
 800b3c6: 697b         	ldr	r3, [r7, #0x14]
 800b3c8: 4413         	add	r3, r2
 800b3ca: 461a         	mov	r2, r3
 800b3cc: 687b         	ldr	r3, [r7, #0x4]
 800b3ce: 60d3         	str	r3, [r2, #0xc]
; }
 800b3d0: bf00         	nop
 800b3d2: 371c         	adds	r7, #0x1c
 800b3d4: 46bd         	mov	sp, r7
 800b3d6: f85d 7b04    	ldr	r7, [sp], #4
 800b3da: 4770         	bx	lr

0800b3dc <$d>:
 800b3dc: 48 d1 02 08  	.word	0x0802d148

0800b3e0 <LL_DMA_SetPeriphAddress>:
; {
 800b3e0: b480         	push	{r7}
 800b3e2: b087         	sub	sp, #0x1c
 800b3e4: af00         	add	r7, sp, #0x0
 800b3e6: 60f8         	str	r0, [r7, #0xc]
 800b3e8: 60b9         	str	r1, [r7, #0x8]
 800b3ea: 607a         	str	r2, [r7, #0x4]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800b3ec: 68fb         	ldr	r3, [r7, #0xc]
 800b3ee: 617b         	str	r3, [r7, #0x14]
;   WRITE_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->PAR, PeriphAddress);
 800b3f0: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800b410 <LL_DMA_SetPeriphAddress+0x30>
 800b3f2: 68bb         	ldr	r3, [r7, #0x8]
 800b3f4: 4413         	add	r3, r2
 800b3f6: 781b         	ldrb	r3, [r3]
 800b3f8: 461a         	mov	r2, r3
 800b3fa: 697b         	ldr	r3, [r7, #0x14]
 800b3fc: 4413         	add	r3, r2
 800b3fe: 461a         	mov	r2, r3
 800b400: 687b         	ldr	r3, [r7, #0x4]
 800b402: 6093         	str	r3, [r2, #0x8]
; }
 800b404: bf00         	nop
 800b406: 371c         	adds	r7, #0x1c
 800b408: 46bd         	mov	sp, r7
 800b40a: f85d 7b04    	ldr	r7, [sp], #4
 800b40e: 4770         	bx	lr

0800b410 <$d>:
 800b410: 48 d1 02 08  	.word	0x0802d148

0800b414 <LL_DMA_EnableIT_HT>:
; {
 800b414: b480         	push	{r7}
 800b416: b085         	sub	sp, #0x14
 800b418: af00         	add	r7, sp, #0x0
 800b41a: 6078         	str	r0, [r7, #0x4]
 800b41c: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800b41e: 687b         	ldr	r3, [r7, #0x4]
 800b420: 60fb         	str	r3, [r7, #0xc]
;   SET_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_HTIE);
 800b422: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b454 <LL_DMA_EnableIT_HT+0x40>
 800b424: 683b         	ldr	r3, [r7]
 800b426: 4413         	add	r3, r2
 800b428: 781b         	ldrb	r3, [r3]
 800b42a: 461a         	mov	r2, r3
 800b42c: 68fb         	ldr	r3, [r7, #0xc]
 800b42e: 4413         	add	r3, r2
 800b430: 681b         	ldr	r3, [r3]
 800b432: 4908         	ldr	r1, [pc, #0x20]         @ 0x800b454 <LL_DMA_EnableIT_HT+0x40>
 800b434: 683a         	ldr	r2, [r7]
 800b436: 440a         	add	r2, r1
 800b438: 7812         	ldrb	r2, [r2]
 800b43a: 4611         	mov	r1, r2
 800b43c: 68fa         	ldr	r2, [r7, #0xc]
 800b43e: 440a         	add	r2, r1
 800b440: f043 0308    	orr	r3, r3, #0x8
 800b444: 6013         	str	r3, [r2]
; }
 800b446: bf00         	nop
 800b448: 3714         	adds	r7, #0x14
 800b44a: 46bd         	mov	sp, r7
 800b44c: f85d 7b04    	ldr	r7, [sp], #4
 800b450: 4770         	bx	lr
 800b452: bf00         	nop

0800b454 <$d>:
 800b454: 48 d1 02 08  	.word	0x0802d148

0800b458 <LL_DMA_EnableIT_TC>:
; {
 800b458: b480         	push	{r7}
 800b45a: b085         	sub	sp, #0x14
 800b45c: af00         	add	r7, sp, #0x0
 800b45e: 6078         	str	r0, [r7, #0x4]
 800b460: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800b462: 687b         	ldr	r3, [r7, #0x4]
 800b464: 60fb         	str	r3, [r7, #0xc]
;   SET_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_TCIE);
 800b466: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b498 <LL_DMA_EnableIT_TC+0x40>
 800b468: 683b         	ldr	r3, [r7]
 800b46a: 4413         	add	r3, r2
 800b46c: 781b         	ldrb	r3, [r3]
 800b46e: 461a         	mov	r2, r3
 800b470: 68fb         	ldr	r3, [r7, #0xc]
 800b472: 4413         	add	r3, r2
 800b474: 681b         	ldr	r3, [r3]
 800b476: 4908         	ldr	r1, [pc, #0x20]         @ 0x800b498 <LL_DMA_EnableIT_TC+0x40>
 800b478: 683a         	ldr	r2, [r7]
 800b47a: 440a         	add	r2, r1
 800b47c: 7812         	ldrb	r2, [r2]
 800b47e: 4611         	mov	r1, r2
 800b480: 68fa         	ldr	r2, [r7, #0xc]
 800b482: 440a         	add	r2, r1
 800b484: f043 0310    	orr	r3, r3, #0x10
 800b488: 6013         	str	r3, [r2]
; }
 800b48a: bf00         	nop
 800b48c: 3714         	adds	r7, #0x14
 800b48e: 46bd         	mov	sp, r7
 800b490: f85d 7b04    	ldr	r7, [sp], #4
 800b494: 4770         	bx	lr
 800b496: bf00         	nop

0800b498 <$d>:
 800b498: 48 d1 02 08  	.word	0x0802d148

0800b49c <LL_DMA_EnableIT_FE>:
; {
 800b49c: b480         	push	{r7}
 800b49e: b085         	sub	sp, #0x14
 800b4a0: af00         	add	r7, sp, #0x0
 800b4a2: 6078         	str	r0, [r7, #0x4]
 800b4a4: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800b4a6: 687b         	ldr	r3, [r7, #0x4]
 800b4a8: 60fb         	str	r3, [r7, #0xc]
;   SET_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->FCR, DMA_SxFCR_FEIE);
 800b4aa: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b4dc <LL_DMA_EnableIT_FE+0x40>
 800b4ac: 683b         	ldr	r3, [r7]
 800b4ae: 4413         	add	r3, r2
 800b4b0: 781b         	ldrb	r3, [r3]
 800b4b2: 461a         	mov	r2, r3
 800b4b4: 68fb         	ldr	r3, [r7, #0xc]
 800b4b6: 4413         	add	r3, r2
 800b4b8: 695b         	ldr	r3, [r3, #0x14]
 800b4ba: 4908         	ldr	r1, [pc, #0x20]         @ 0x800b4dc <LL_DMA_EnableIT_FE+0x40>
 800b4bc: 683a         	ldr	r2, [r7]
 800b4be: 440a         	add	r2, r1
 800b4c0: 7812         	ldrb	r2, [r2]
 800b4c2: 4611         	mov	r1, r2
 800b4c4: 68fa         	ldr	r2, [r7, #0xc]
 800b4c6: 440a         	add	r2, r1
 800b4c8: f043 0380    	orr	r3, r3, #0x80
 800b4cc: 6153         	str	r3, [r2, #0x14]
; }
 800b4ce: bf00         	nop
 800b4d0: 3714         	adds	r7, #0x14
 800b4d2: 46bd         	mov	sp, r7
 800b4d4: f85d 7b04    	ldr	r7, [sp], #4
 800b4d8: 4770         	bx	lr
 800b4da: bf00         	nop

0800b4dc <$d>:
 800b4dc: 48 d1 02 08  	.word	0x0802d148

0800b4e0 <LL_DMA_DisableIT_TC>:
; {
 800b4e0: b480         	push	{r7}
 800b4e2: b085         	sub	sp, #0x14
 800b4e4: af00         	add	r7, sp, #0x0
 800b4e6: 6078         	str	r0, [r7, #0x4]
 800b4e8: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800b4ea: 687b         	ldr	r3, [r7, #0x4]
 800b4ec: 60fb         	str	r3, [r7, #0xc]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_TCIE);
 800b4ee: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b520 <LL_DMA_DisableIT_TC+0x40>
 800b4f0: 683b         	ldr	r3, [r7]
 800b4f2: 4413         	add	r3, r2
 800b4f4: 781b         	ldrb	r3, [r3]
 800b4f6: 461a         	mov	r2, r3
 800b4f8: 68fb         	ldr	r3, [r7, #0xc]
 800b4fa: 4413         	add	r3, r2
 800b4fc: 681b         	ldr	r3, [r3]
 800b4fe: 4908         	ldr	r1, [pc, #0x20]         @ 0x800b520 <LL_DMA_DisableIT_TC+0x40>
 800b500: 683a         	ldr	r2, [r7]
 800b502: 440a         	add	r2, r1
 800b504: 7812         	ldrb	r2, [r2]
 800b506: 4611         	mov	r1, r2
 800b508: 68fa         	ldr	r2, [r7, #0xc]
 800b50a: 440a         	add	r2, r1
 800b50c: f023 0310    	bic	r3, r3, #0x10
 800b510: 6013         	str	r3, [r2]
; }
 800b512: bf00         	nop
 800b514: 3714         	adds	r7, #0x14
 800b516: 46bd         	mov	sp, r7
 800b518: f85d 7b04    	ldr	r7, [sp], #4
 800b51c: 4770         	bx	lr
 800b51e: bf00         	nop

0800b520 <$d>:
 800b520: 48 d1 02 08  	.word	0x0802d148

0800b524 <LL_DMA_DisableIT_FE>:
; {
 800b524: b480         	push	{r7}
 800b526: b085         	sub	sp, #0x14
 800b528: af00         	add	r7, sp, #0x0
 800b52a: 6078         	str	r0, [r7, #0x4]
 800b52c: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800b52e: 687b         	ldr	r3, [r7, #0x4]
 800b530: 60fb         	str	r3, [r7, #0xc]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->FCR, DMA_SxFCR_FEIE);
 800b532: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b564 <LL_DMA_DisableIT_FE+0x40>
 800b534: 683b         	ldr	r3, [r7]
 800b536: 4413         	add	r3, r2
 800b538: 781b         	ldrb	r3, [r3]
 800b53a: 461a         	mov	r2, r3
 800b53c: 68fb         	ldr	r3, [r7, #0xc]
 800b53e: 4413         	add	r3, r2
 800b540: 695b         	ldr	r3, [r3, #0x14]
 800b542: 4908         	ldr	r1, [pc, #0x20]         @ 0x800b564 <LL_DMA_DisableIT_FE+0x40>
 800b544: 683a         	ldr	r2, [r7]
 800b546: 440a         	add	r2, r1
 800b548: 7812         	ldrb	r2, [r2]
 800b54a: 4611         	mov	r1, r2
 800b54c: 68fa         	ldr	r2, [r7, #0xc]
 800b54e: 440a         	add	r2, r1
 800b550: f023 0380    	bic	r3, r3, #0x80
 800b554: 6153         	str	r3, [r2, #0x14]
; }
 800b556: bf00         	nop
 800b558: 3714         	adds	r7, #0x14
 800b55a: 46bd         	mov	sp, r7
 800b55c: f85d 7b04    	ldr	r7, [sp], #4
 800b560: 4770         	bx	lr
 800b562: bf00         	nop

0800b564 <$d>:
 800b564: 48 d1 02 08  	.word	0x0802d148

0800b568 <dma_stm32_irq_handler>:
; {
 800b568: b590         	push	{r4, r7, lr}
 800b56a: b08f         	sub	sp, #0x3c
 800b56c: af04         	add	r7, sp, #0x10
 800b56e: 6078         	str	r0, [r7, #0x4]
 800b570: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 800b572: 687b         	ldr	r3, [r7, #0x4]
 800b574: 685b         	ldr	r3, [r3, #0x4]
 800b576: 627b         	str	r3, [r7, #0x24]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 800b578: 6a7b         	ldr	r3, [r7, #0x24]
 800b57a: 691b         	ldr	r3, [r3, #0x10]
 800b57c: 623b         	str	r3, [r7, #0x20]
; 	stream = &config->streams[id];
 800b57e: 6a7b         	ldr	r3, [r7, #0x24]
 800b580: 69da         	ldr	r2, [r3, #0x1c]
 800b582: 683b         	ldr	r3, [r7]
 800b584: 015b         	lsls	r3, r3, #0x5
 800b586: 4413         	add	r3, r2
 800b588: 61fb         	str	r3, [r7, #0x1c]
; 	if ((stream->hal_override != true) && (stream->busy == false)) {
 800b58a: 69fb         	ldr	r3, [r7, #0x1c]
 800b58c: 7a5b         	ldrb	r3, [r3, #0x9]
 800b58e: f083 0301    	eor	r3, r3, #0x1
 800b592: b2db         	uxtb	r3, r3
 800b594: 2b00         	cmp	r3, #0x0
 800b596: d00c         	beq	0x800b5b2 <dma_stm32_irq_handler+0x4a> @ imm = #0x18
 800b598: 69fb         	ldr	r3, [r7, #0x1c]
 800b59a: 7a9b         	ldrb	r3, [r3, #0xa]
 800b59c: b2db         	uxtb	r3, r3
 800b59e: f083 0301    	eor	r3, r3, #0x1
 800b5a2: b2db         	uxtb	r3, r3
 800b5a4: 2b00         	cmp	r3, #0x0
 800b5a6: d004         	beq	0x800b5b2 <dma_stm32_irq_handler+0x4a> @ imm = #0x8
; 		dma_stm32_clear_stream_irq(dev, id);
 800b5a8: 6839         	ldr	r1, [r7]
 800b5aa: 6878         	ldr	r0, [r7, #0x4]
 800b5ac: f013 ff76    	bl	0x801f49c <dma_stm32_clear_stream_irq> @ imm = #0x13eec
; 		return;
 800b5b0: e09b         	b	0x800b6ea <dma_stm32_irq_handler+0x182> @ imm = #0x136
; 	callback_arg = stream->mux_channel;
 800b5b2: 69fb         	ldr	r3, [r7, #0x1c]
 800b5b4: 685b         	ldr	r3, [r3, #0x4]
 800b5b6: 61bb         	str	r3, [r7, #0x18]
; 	if (stm32_dma_is_ht_irq_active(dma, id)) {
 800b5b8: 6839         	ldr	r1, [r7]
 800b5ba: 6a38         	ldr	r0, [r7, #0x20]
 800b5bc: f014 ffaa    	bl	0x8020514 <stm32_dma_is_ht_irq_active> @ imm = #0x14f54
 800b5c0: 4603         	mov	r3, r0
 800b5c2: 2b00         	cmp	r3, #0x0
 800b5c4: d013         	beq	0x800b5ee <dma_stm32_irq_handler+0x86> @ imm = #0x26
; 		if (!stream->hal_override) {
 800b5c6: 69fb         	ldr	r3, [r7, #0x1c]
 800b5c8: 7a5b         	ldrb	r3, [r3, #0x9]
 800b5ca: f083 0301    	eor	r3, r3, #0x1
 800b5ce: b2db         	uxtb	r3, r3
 800b5d0: 2b00         	cmp	r3, #0x0
 800b5d2: d003         	beq	0x800b5dc <dma_stm32_irq_handler+0x74> @ imm = #0x6
; 			dma_stm32_clear_ht(dma, id);
 800b5d4: 6839         	ldr	r1, [r7]
 800b5d6: 6a38         	ldr	r0, [r7, #0x20]
 800b5d8: f000 ff3e    	bl	0x800c458 <dma_stm32_clear_ht> @ imm = #0xe7c
; 		stream->dma_callback(dev, stream->user_data, callback_arg, DMA_STATUS_BLOCK);
 800b5dc: 69fb         	ldr	r3, [r7, #0x1c]
 800b5de: 699c         	ldr	r4, [r3, #0x18]
 800b5e0: 69fb         	ldr	r3, [r7, #0x1c]
 800b5e2: 6959         	ldr	r1, [r3, #0x14]
 800b5e4: 2301         	movs	r3, #0x1
 800b5e6: 69ba         	ldr	r2, [r7, #0x18]
 800b5e8: 6878         	ldr	r0, [r7, #0x4]
 800b5ea: 47a0         	blx	r4
 800b5ec: e07d         	b	0x800b6ea <dma_stm32_irq_handler+0x182> @ imm = #0xfa
; 	} else if (stm32_dma_is_tc_irq_active(dma, id)) {
 800b5ee: 6839         	ldr	r1, [r7]
 800b5f0: 6a38         	ldr	r0, [r7, #0x20]
 800b5f2: f014 ff6e    	bl	0x80204d2 <stm32_dma_is_tc_irq_active> @ imm = #0x14edc
 800b5f6: 4603         	mov	r3, r0
 800b5f8: 2b00         	cmp	r3, #0x0
 800b5fa: d01d         	beq	0x800b638 <dma_stm32_irq_handler+0xd0> @ imm = #0x3a
; 		if (!stream->cyclic) {
 800b5fc: 69fb         	ldr	r3, [r7, #0x1c]
 800b5fe: 7f1b         	ldrb	r3, [r3, #0x1c]
 800b600: f083 0301    	eor	r3, r3, #0x1
 800b604: b2db         	uxtb	r3, r3
 800b606: 2b00         	cmp	r3, #0x0
 800b608: d002         	beq	0x800b610 <dma_stm32_irq_handler+0xa8> @ imm = #0x4
; 			stream->busy = false;
 800b60a: 69fb         	ldr	r3, [r7, #0x1c]
 800b60c: 2200         	movs	r2, #0x0
 800b60e: 729a         	strb	r2, [r3, #0xa]
; 		if (!stream->hal_override) {
 800b610: 69fb         	ldr	r3, [r7, #0x1c]
 800b612: 7a5b         	ldrb	r3, [r3, #0x9]
 800b614: f083 0301    	eor	r3, r3, #0x1
 800b618: b2db         	uxtb	r3, r3
 800b61a: 2b00         	cmp	r3, #0x0
 800b61c: d003         	beq	0x800b626 <dma_stm32_irq_handler+0xbe> @ imm = #0x6
; 			dma_stm32_clear_tc(dma, id);
 800b61e: 6839         	ldr	r1, [r7]
 800b620: 6a38         	ldr	r0, [r7, #0x20]
 800b622: f000 ff2b    	bl	0x800c47c <dma_stm32_clear_tc> @ imm = #0xe56
; 		stream->dma_callback(dev, stream->user_data, callback_arg, DMA_STATUS_COMPLETE);
 800b626: 69fb         	ldr	r3, [r7, #0x1c]
 800b628: 699c         	ldr	r4, [r3, #0x18]
 800b62a: 69fb         	ldr	r3, [r7, #0x1c]
 800b62c: 6959         	ldr	r1, [r3, #0x14]
 800b62e: 2300         	movs	r3, #0x0
 800b630: 69ba         	ldr	r2, [r7, #0x18]
 800b632: 6878         	ldr	r0, [r7, #0x4]
 800b634: 47a0         	blx	r4
 800b636: e058         	b	0x800b6ea <dma_stm32_irq_handler+0x182> @ imm = #0xb0
; 	} else if (stm32_dma_is_unexpected_irq_happened(dma, id)) {
 800b638: 6839         	ldr	r1, [r7]
 800b63a: 6a38         	ldr	r0, [r7, #0x20]
 800b63c: f001 f82c    	bl	0x800c698 <stm32_dma_is_unexpected_irq_happened> @ imm = #0x1058
 800b640: 4603         	mov	r3, r0
 800b642: 2b00         	cmp	r3, #0x0
 800b644: d023         	beq	0x800b68e <dma_stm32_irq_handler+0x126> @ imm = #0x46
; 		LOG_ERR("Unexpected irq happened.");
 800b646: 2303         	movs	r3, #0x3
 800b648: 2b00         	cmp	r3, #0x0
 800b64a: d016         	beq	0x800b67a <dma_stm32_irq_handler+0x112> @ imm = #0x2c
 800b64c: 2301         	movs	r3, #0x1
 800b64e: 73fb         	strb	r3, [r7, #0xf]
 800b650: 7bfb         	ldrb	r3, [r7, #0xf]
 800b652: f083 0301    	eor	r3, r3, #0x1
 800b656: b2db         	uxtb	r3, r3
 800b658: 2b00         	cmp	r3, #0x0
 800b65a: d10e         	bne	0x800b67a <dma_stm32_irq_handler+0x112> @ imm = #0x1c
 800b65c: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800b6f0 <dma_stm32_irq_handler+0x188>
 800b65e: 6819         	ldr	r1, [r3]
 800b660: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800b6f4 <dma_stm32_irq_handler+0x18c>
 800b662: 9302         	str	r3, [sp, #0x8]
 800b664: 2300         	movs	r3, #0x0
 800b666: 9301         	str	r3, [sp, #0x4]
 800b668: 2300         	movs	r3, #0x0
 800b66a: 9300         	str	r3, [sp]
 800b66c: 2300         	movs	r3, #0x0
 800b66e: 2201         	movs	r2, #0x1
 800b670: 2000         	movs	r0, #0x0
 800b672: f013 fee2    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13dc4
 800b676: 2300         	movs	r3, #0x0
 800b678: 60bb         	str	r3, [r7, #0x8]
; 		stream->dma_callback(dev, stream->user_data,
 800b67a: 69fb         	ldr	r3, [r7, #0x1c]
 800b67c: 699c         	ldr	r4, [r3, #0x18]
 800b67e: 69fb         	ldr	r3, [r7, #0x1c]
 800b680: 6959         	ldr	r1, [r3, #0x14]
 800b682: f06f 0304    	mvn	r3, #0x4
 800b686: 69ba         	ldr	r2, [r7, #0x18]
 800b688: 6878         	ldr	r0, [r7, #0x4]
 800b68a: 47a0         	blx	r4
 800b68c: e02d         	b	0x800b6ea <dma_stm32_irq_handler+0x182> @ imm = #0x5a
; 		LOG_ERR("Transfer Error.");
 800b68e: 2303         	movs	r3, #0x3
 800b690: 2b00         	cmp	r3, #0x0
 800b692: d016         	beq	0x800b6c2 <dma_stm32_irq_handler+0x15a> @ imm = #0x2c
 800b694: 2301         	movs	r3, #0x1
 800b696: 75fb         	strb	r3, [r7, #0x17]
 800b698: 7dfb         	ldrb	r3, [r7, #0x17]
 800b69a: f083 0301    	eor	r3, r3, #0x1
 800b69e: b2db         	uxtb	r3, r3
 800b6a0: 2b00         	cmp	r3, #0x0
 800b6a2: d10e         	bne	0x800b6c2 <dma_stm32_irq_handler+0x15a> @ imm = #0x1c
 800b6a4: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800b6f0 <dma_stm32_irq_handler+0x188>
 800b6a6: 6819         	ldr	r1, [r3]
 800b6a8: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800b6f8 <dma_stm32_irq_handler+0x190>
 800b6aa: 9302         	str	r3, [sp, #0x8]
 800b6ac: 2300         	movs	r3, #0x0
 800b6ae: 9301         	str	r3, [sp, #0x4]
 800b6b0: 2300         	movs	r3, #0x0
 800b6b2: 9300         	str	r3, [sp]
 800b6b4: 2300         	movs	r3, #0x0
 800b6b6: 2201         	movs	r2, #0x1
 800b6b8: 2000         	movs	r0, #0x0
 800b6ba: f013 febe    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13d7c
 800b6be: 2300         	movs	r3, #0x0
 800b6c0: 613b         	str	r3, [r7, #0x10]
; 		stream->busy = false;
 800b6c2: 69fb         	ldr	r3, [r7, #0x1c]
 800b6c4: 2200         	movs	r2, #0x0
 800b6c6: 729a         	strb	r2, [r3, #0xa]
; 		dma_stm32_dump_stream_irq(dev, id);
 800b6c8: 6839         	ldr	r1, [r7]
 800b6ca: 6878         	ldr	r0, [r7, #0x4]
 800b6cc: f013 fed3    	bl	0x801f476 <dma_stm32_dump_stream_irq> @ imm = #0x13da6
; 		dma_stm32_clear_stream_irq(dev, id);
 800b6d0: 6839         	ldr	r1, [r7]
 800b6d2: 6878         	ldr	r0, [r7, #0x4]
 800b6d4: f013 fee2    	bl	0x801f49c <dma_stm32_clear_stream_irq> @ imm = #0x13dc4
; 		stream->dma_callback(dev, stream->user_data,
 800b6d8: 69fb         	ldr	r3, [r7, #0x1c]
 800b6da: 699c         	ldr	r4, [r3, #0x18]
 800b6dc: 69fb         	ldr	r3, [r7, #0x1c]
 800b6de: 6959         	ldr	r1, [r3, #0x14]
 800b6e0: f06f 0304    	mvn	r3, #0x4
 800b6e4: 69ba         	ldr	r2, [r7, #0x18]
 800b6e6: 6878         	ldr	r0, [r7, #0x4]
 800b6e8: 47a0         	blx	r4
; }
 800b6ea: 372c         	adds	r7, #0x2c
 800b6ec: 46bd         	mov	sp, r7
 800b6ee: bd90         	pop	{r4, r7, pc}

0800b6f0 <$d>:
 800b6f0: c8 06 00 24  	.word	0x240006c8
 800b6f4: 84 b3 02 08  	.word	0x0802b384
 800b6f8: a0 b3 02 08  	.word	0x0802b3a0

0800b6fc <dma_stm32_get_priority>:
; {
 800b6fc: b580         	push	{r7, lr}
 800b6fe: b088         	sub	sp, #0x20
 800b700: af04         	add	r7, sp, #0x10
 800b702: 4603         	mov	r3, r0
 800b704: 6039         	str	r1, [r7]
 800b706: 71fb         	strb	r3, [r7, #0x7]
; 	switch (priority) {
 800b708: 79fb         	ldrb	r3, [r7, #0x7]
 800b70a: 2b03         	cmp	r3, #0x3
 800b70c: d81d         	bhi	0x800b74a <dma_stm32_get_priority+0x4e> @ imm = #0x3a
 800b70e: a201         	adr	r2, #4 <dma_stm32_get_priority+0x17>
 800b710: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800b714 <$d>:
 800b714: 25 b7 00 08  	.word	0x0800b725
 800b718: 2d b7 00 08  	.word	0x0800b72d
 800b71c: 37 b7 00 08  	.word	0x0800b737
 800b720: 41 b7 00 08  	.word	0x0800b741

0800b724 <$t>:
; 		*ll_priority = LL_DMA_PRIORITY_LOW;
 800b724: 683b         	ldr	r3, [r7]
 800b726: 2200         	movs	r2, #0x0
 800b728: 601a         	str	r2, [r3]
; 		break;
 800b72a: e02d         	b	0x800b788 <dma_stm32_get_priority+0x8c> @ imm = #0x5a
; 		*ll_priority = LL_DMA_PRIORITY_MEDIUM;
 800b72c: 683b         	ldr	r3, [r7]
 800b72e: f44f 3280    	mov.w	r2, #0x10000
 800b732: 601a         	str	r2, [r3]
; 		break;
 800b734: e028         	b	0x800b788 <dma_stm32_get_priority+0x8c> @ imm = #0x50
; 		*ll_priority = LL_DMA_PRIORITY_HIGH;
 800b736: 683b         	ldr	r3, [r7]
 800b738: f44f 3200    	mov.w	r2, #0x20000
 800b73c: 601a         	str	r2, [r3]
; 		break;
 800b73e: e023         	b	0x800b788 <dma_stm32_get_priority+0x8c> @ imm = #0x46
; 		*ll_priority = LL_DMA_PRIORITY_VERYHIGH;
 800b740: 683b         	ldr	r3, [r7]
 800b742: f44f 3240    	mov.w	r2, #0x30000
 800b746: 601a         	str	r2, [r3]
; 		break;
 800b748: e01e         	b	0x800b788 <dma_stm32_get_priority+0x8c> @ imm = #0x3c
; 		LOG_ERR("Priority error. %d", priority);
 800b74a: 2303         	movs	r3, #0x3
 800b74c: 2b00         	cmp	r3, #0x0
 800b74e: d018         	beq	0x800b782 <dma_stm32_get_priority+0x86> @ imm = #0x30
 800b750: 2301         	movs	r3, #0x1
 800b752: 73fb         	strb	r3, [r7, #0xf]
 800b754: 7bfb         	ldrb	r3, [r7, #0xf]
 800b756: f083 0301    	eor	r3, r3, #0x1
 800b75a: b2db         	uxtb	r3, r3
 800b75c: 2b00         	cmp	r3, #0x0
 800b75e: d110         	bne	0x800b782 <dma_stm32_get_priority+0x86> @ imm = #0x20
 800b760: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800b794 <dma_stm32_get_priority+0x98>
 800b762: 6819         	ldr	r1, [r3]
 800b764: 79fb         	ldrb	r3, [r7, #0x7]
 800b766: 9303         	str	r3, [sp, #0xc]
 800b768: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b798 <dma_stm32_get_priority+0x9c>
 800b76a: 9302         	str	r3, [sp, #0x8]
 800b76c: 2300         	movs	r3, #0x0
 800b76e: 9301         	str	r3, [sp, #0x4]
 800b770: 2300         	movs	r3, #0x0
 800b772: 9300         	str	r3, [sp]
 800b774: 2300         	movs	r3, #0x0
 800b776: 2201         	movs	r2, #0x1
 800b778: 2000         	movs	r0, #0x0
 800b77a: f013 fe5e    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13cbc
 800b77e: 2300         	movs	r3, #0x0
 800b780: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 800b782: f06f 0315    	mvn	r3, #0x15
 800b786: e000         	b	0x800b78a <dma_stm32_get_priority+0x8e> @ imm = #0x0
; 	return 0;
 800b788: 2300         	movs	r3, #0x0
; }
 800b78a: 4618         	mov	r0, r3
 800b78c: 3710         	adds	r7, #0x10
 800b78e: 46bd         	mov	sp, r7
 800b790: bd80         	pop	{r7, pc}
 800b792: bf00         	nop

0800b794 <$d>:
 800b794: c8 06 00 24  	.word	0x240006c8
 800b798: b0 b3 02 08  	.word	0x0802b3b0

0800b79c <dma_stm32_get_direction>:
; {
 800b79c: b580         	push	{r7, lr}
 800b79e: b088         	sub	sp, #0x20
 800b7a0: af04         	add	r7, sp, #0x10
 800b7a2: 4603         	mov	r3, r0
 800b7a4: 6039         	str	r1, [r7]
 800b7a6: 71fb         	strb	r3, [r7, #0x7]
; 	switch (direction) {
 800b7a8: 79fb         	ldrb	r3, [r7, #0x7]
 800b7aa: 2b02         	cmp	r3, #0x2
 800b7ac: d00e         	beq	0x800b7cc <dma_stm32_get_direction+0x30> @ imm = #0x1c
 800b7ae: 2b02         	cmp	r3, #0x2
 800b7b0: dc10         	bgt	0x800b7d4 <dma_stm32_get_direction+0x38> @ imm = #0x20
 800b7b2: 2b00         	cmp	r3, #0x0
 800b7b4: d002         	beq	0x800b7bc <dma_stm32_get_direction+0x20> @ imm = #0x4
 800b7b6: 2b01         	cmp	r3, #0x1
 800b7b8: d004         	beq	0x800b7c4 <dma_stm32_get_direction+0x28> @ imm = #0x8
 800b7ba: e00b         	b	0x800b7d4 <dma_stm32_get_direction+0x38> @ imm = #0x16
; 		*ll_direction = LL_DMA_DIRECTION_MEMORY_TO_MEMORY;
 800b7bc: 683b         	ldr	r3, [r7]
 800b7be: 2280         	movs	r2, #0x80
 800b7c0: 601a         	str	r2, [r3]
; 		break;
 800b7c2: e026         	b	0x800b812 <dma_stm32_get_direction+0x76> @ imm = #0x4c
; 		*ll_direction = LL_DMA_DIRECTION_MEMORY_TO_PERIPH;
 800b7c4: 683b         	ldr	r3, [r7]
 800b7c6: 2240         	movs	r2, #0x40
 800b7c8: 601a         	str	r2, [r3]
; 		break;
 800b7ca: e022         	b	0x800b812 <dma_stm32_get_direction+0x76> @ imm = #0x44
; 		*ll_direction = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
 800b7cc: 683b         	ldr	r3, [r7]
 800b7ce: 2200         	movs	r2, #0x0
 800b7d0: 601a         	str	r2, [r3]
; 		break;
 800b7d2: e01e         	b	0x800b812 <dma_stm32_get_direction+0x76> @ imm = #0x3c
; 		LOG_ERR("Direction error. %d", direction);
 800b7d4: 2303         	movs	r3, #0x3
 800b7d6: 2b00         	cmp	r3, #0x0
 800b7d8: d018         	beq	0x800b80c <dma_stm32_get_direction+0x70> @ imm = #0x30
 800b7da: 2301         	movs	r3, #0x1
 800b7dc: 73fb         	strb	r3, [r7, #0xf]
 800b7de: 7bfb         	ldrb	r3, [r7, #0xf]
 800b7e0: f083 0301    	eor	r3, r3, #0x1
 800b7e4: b2db         	uxtb	r3, r3
 800b7e6: 2b00         	cmp	r3, #0x0
 800b7e8: d110         	bne	0x800b80c <dma_stm32_get_direction+0x70> @ imm = #0x20
 800b7ea: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800b81c <dma_stm32_get_direction+0x80>
 800b7ec: 6819         	ldr	r1, [r3]
 800b7ee: 79fb         	ldrb	r3, [r7, #0x7]
 800b7f0: 9303         	str	r3, [sp, #0xc]
 800b7f2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b820 <dma_stm32_get_direction+0x84>
 800b7f4: 9302         	str	r3, [sp, #0x8]
 800b7f6: 2300         	movs	r3, #0x0
 800b7f8: 9301         	str	r3, [sp, #0x4]
 800b7fa: 2300         	movs	r3, #0x0
 800b7fc: 9300         	str	r3, [sp]
 800b7fe: 2300         	movs	r3, #0x0
 800b800: 2201         	movs	r2, #0x1
 800b802: 2000         	movs	r0, #0x0
 800b804: f013 fe19    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13c32
 800b808: 2300         	movs	r3, #0x0
 800b80a: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 800b80c: f06f 0315    	mvn	r3, #0x15
 800b810: e000         	b	0x800b814 <dma_stm32_get_direction+0x78> @ imm = #0x0
; 	return 0;
 800b812: 2300         	movs	r3, #0x0
; }
 800b814: 4618         	mov	r0, r3
 800b816: 3710         	adds	r7, #0x10
 800b818: 46bd         	mov	sp, r7
 800b81a: bd80         	pop	{r7, pc}

0800b81c <$d>:
 800b81c: c8 06 00 24  	.word	0x240006c8
 800b820: c4 b3 02 08  	.word	0x0802b3c4

0800b824 <dma_stm32_get_memory_increment>:
; {
 800b824: b580         	push	{r7, lr}
 800b826: b088         	sub	sp, #0x20
 800b828: af04         	add	r7, sp, #0x10
 800b82a: 4603         	mov	r3, r0
 800b82c: 6039         	str	r1, [r7]
 800b82e: 71fb         	strb	r3, [r7, #0x7]
; 	switch (increment) {
 800b830: 79fb         	ldrb	r3, [r7, #0x7]
 800b832: 2b02         	cmp	r3, #0x2
 800b834: d00b         	beq	0x800b84e <dma_stm32_get_memory_increment+0x2a> @ imm = #0x16
 800b836: 2b02         	cmp	r3, #0x2
 800b838: dc10         	bgt	0x800b85c <dma_stm32_get_memory_increment+0x38> @ imm = #0x20
 800b83a: 2b00         	cmp	r3, #0x0
 800b83c: d002         	beq	0x800b844 <dma_stm32_get_memory_increment+0x20> @ imm = #0x4
 800b83e: 2b01         	cmp	r3, #0x1
 800b840: d009         	beq	0x800b856 <dma_stm32_get_memory_increment+0x32> @ imm = #0x12
 800b842: e00b         	b	0x800b85c <dma_stm32_get_memory_increment+0x38> @ imm = #0x16
; 		*ll_increment = LL_DMA_MEMORY_INCREMENT;
 800b844: 683b         	ldr	r3, [r7]
 800b846: f44f 6280    	mov.w	r2, #0x400
 800b84a: 601a         	str	r2, [r3]
; 		break;
 800b84c: e025         	b	0x800b89a <dma_stm32_get_memory_increment+0x76> @ imm = #0x4a
; 		*ll_increment = LL_DMA_MEMORY_NOINCREMENT;
 800b84e: 683b         	ldr	r3, [r7]
 800b850: 2200         	movs	r2, #0x0
 800b852: 601a         	str	r2, [r3]
; 		break;
 800b854: e021         	b	0x800b89a <dma_stm32_get_memory_increment+0x76> @ imm = #0x42
; 		return -ENOTSUP;
 800b856: f06f 0385    	mvn	r3, #0x85
 800b85a: e01f         	b	0x800b89c <dma_stm32_get_memory_increment+0x78> @ imm = #0x3e
; 		LOG_ERR("Memory increment error. %d", increment);
 800b85c: 2303         	movs	r3, #0x3
 800b85e: 2b00         	cmp	r3, #0x0
 800b860: d018         	beq	0x800b894 <dma_stm32_get_memory_increment+0x70> @ imm = #0x30
 800b862: 2301         	movs	r3, #0x1
 800b864: 73fb         	strb	r3, [r7, #0xf]
 800b866: 7bfb         	ldrb	r3, [r7, #0xf]
 800b868: f083 0301    	eor	r3, r3, #0x1
 800b86c: b2db         	uxtb	r3, r3
 800b86e: 2b00         	cmp	r3, #0x0
 800b870: d110         	bne	0x800b894 <dma_stm32_get_memory_increment+0x70> @ imm = #0x20
 800b872: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800b8a4 <dma_stm32_get_memory_increment+0x80>
 800b874: 6819         	ldr	r1, [r3]
 800b876: 79fb         	ldrb	r3, [r7, #0x7]
 800b878: 9303         	str	r3, [sp, #0xc]
 800b87a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b8a8 <dma_stm32_get_memory_increment+0x84>
 800b87c: 9302         	str	r3, [sp, #0x8]
 800b87e: 2300         	movs	r3, #0x0
 800b880: 9301         	str	r3, [sp, #0x4]
 800b882: 2300         	movs	r3, #0x0
 800b884: 9300         	str	r3, [sp]
 800b886: 2300         	movs	r3, #0x0
 800b888: 2201         	movs	r2, #0x1
 800b88a: 2000         	movs	r0, #0x0
 800b88c: f013 fdd5    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13baa
 800b890: 2300         	movs	r3, #0x0
 800b892: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 800b894: f06f 0315    	mvn	r3, #0x15
 800b898: e000         	b	0x800b89c <dma_stm32_get_memory_increment+0x78> @ imm = #0x0
; 	return 0;
 800b89a: 2300         	movs	r3, #0x0
; }
 800b89c: 4618         	mov	r0, r3
 800b89e: 3710         	adds	r7, #0x10
 800b8a0: 46bd         	mov	sp, r7
 800b8a2: bd80         	pop	{r7, pc}

0800b8a4 <$d>:
 800b8a4: c8 06 00 24  	.word	0x240006c8
 800b8a8: d8 b3 02 08  	.word	0x0802b3d8

0800b8ac <dma_stm32_get_periph_increment>:
; {
 800b8ac: b580         	push	{r7, lr}
 800b8ae: b088         	sub	sp, #0x20
 800b8b0: af04         	add	r7, sp, #0x10
 800b8b2: 4603         	mov	r3, r0
 800b8b4: 6039         	str	r1, [r7]
 800b8b6: 71fb         	strb	r3, [r7, #0x7]
; 	switch (increment) {
 800b8b8: 79fb         	ldrb	r3, [r7, #0x7]
 800b8ba: 2b02         	cmp	r3, #0x2
 800b8bc: d00b         	beq	0x800b8d6 <dma_stm32_get_periph_increment+0x2a> @ imm = #0x16
 800b8be: 2b02         	cmp	r3, #0x2
 800b8c0: dc10         	bgt	0x800b8e4 <dma_stm32_get_periph_increment+0x38> @ imm = #0x20
 800b8c2: 2b00         	cmp	r3, #0x0
 800b8c4: d002         	beq	0x800b8cc <dma_stm32_get_periph_increment+0x20> @ imm = #0x4
 800b8c6: 2b01         	cmp	r3, #0x1
 800b8c8: d009         	beq	0x800b8de <dma_stm32_get_periph_increment+0x32> @ imm = #0x12
 800b8ca: e00b         	b	0x800b8e4 <dma_stm32_get_periph_increment+0x38> @ imm = #0x16
; 		*ll_increment = LL_DMA_PERIPH_INCREMENT;
 800b8cc: 683b         	ldr	r3, [r7]
 800b8ce: f44f 7200    	mov.w	r2, #0x200
 800b8d2: 601a         	str	r2, [r3]
; 		break;
 800b8d4: e025         	b	0x800b922 <dma_stm32_get_periph_increment+0x76> @ imm = #0x4a
; 		*ll_increment = LL_DMA_PERIPH_NOINCREMENT;
 800b8d6: 683b         	ldr	r3, [r7]
 800b8d8: 2200         	movs	r2, #0x0
 800b8da: 601a         	str	r2, [r3]
; 		break;
 800b8dc: e021         	b	0x800b922 <dma_stm32_get_periph_increment+0x76> @ imm = #0x42
; 		return -ENOTSUP;
 800b8de: f06f 0385    	mvn	r3, #0x85
 800b8e2: e01f         	b	0x800b924 <dma_stm32_get_periph_increment+0x78> @ imm = #0x3e
; 		LOG_ERR("Periph increment error. %d", increment);
 800b8e4: 2303         	movs	r3, #0x3
 800b8e6: 2b00         	cmp	r3, #0x0
 800b8e8: d018         	beq	0x800b91c <dma_stm32_get_periph_increment+0x70> @ imm = #0x30
 800b8ea: 2301         	movs	r3, #0x1
 800b8ec: 73fb         	strb	r3, [r7, #0xf]
 800b8ee: 7bfb         	ldrb	r3, [r7, #0xf]
 800b8f0: f083 0301    	eor	r3, r3, #0x1
 800b8f4: b2db         	uxtb	r3, r3
 800b8f6: 2b00         	cmp	r3, #0x0
 800b8f8: d110         	bne	0x800b91c <dma_stm32_get_periph_increment+0x70> @ imm = #0x20
 800b8fa: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800b92c <dma_stm32_get_periph_increment+0x80>
 800b8fc: 6819         	ldr	r1, [r3]
 800b8fe: 79fb         	ldrb	r3, [r7, #0x7]
 800b900: 9303         	str	r3, [sp, #0xc]
 800b902: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b930 <dma_stm32_get_periph_increment+0x84>
 800b904: 9302         	str	r3, [sp, #0x8]
 800b906: 2300         	movs	r3, #0x0
 800b908: 9301         	str	r3, [sp, #0x4]
 800b90a: 2300         	movs	r3, #0x0
 800b90c: 9300         	str	r3, [sp]
 800b90e: 2300         	movs	r3, #0x0
 800b910: 2201         	movs	r2, #0x1
 800b912: 2000         	movs	r0, #0x0
 800b914: f013 fd91    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13b22
 800b918: 2300         	movs	r3, #0x0
 800b91a: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 800b91c: f06f 0315    	mvn	r3, #0x15
 800b920: e000         	b	0x800b924 <dma_stm32_get_periph_increment+0x78> @ imm = #0x0
; 	return 0;
 800b922: 2300         	movs	r3, #0x0
; }
 800b924: 4618         	mov	r0, r3
 800b926: 3710         	adds	r7, #0x10
 800b928: 46bd         	mov	sp, r7
 800b92a: bd80         	pop	{r7, pc}

0800b92c <$d>:
 800b92c: c8 06 00 24  	.word	0x240006c8
 800b930: f4 b3 02 08  	.word	0x0802b3f4

0800b934 <dma_stm32_configure>:
; {
 800b934: b580         	push	{r7, lr}
 800b936: b0bc         	sub	sp, #0xf0
 800b938: af06         	add	r7, sp, #0x18
 800b93a: 60f8         	str	r0, [r7, #0xc]
 800b93c: 60b9         	str	r1, [r7, #0x8]
 800b93e: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_stm32_config *dev_config = dev->config;
 800b940: 68fb         	ldr	r3, [r7, #0xc]
 800b942: 685b         	ldr	r3, [r3, #0x4]
 800b944: f8c7 30c0    	str.w	r3, [r7, #0xc0]
; 				&dev_config->streams[id - STM32_DMA_STREAM_OFFSET];
 800b948: f8d7 30c0    	ldr.w	r3, [r7, #0xc0]
 800b94c: 69da         	ldr	r2, [r3, #0x1c]
 800b94e: 68b9         	ldr	r1, [r7, #0x8]
 800b950: f06f 4378    	mvn	r3, #0xf8000000
 800b954: 440b         	add	r3, r1
 800b956: 015b         	lsls	r3, r3, #0x5
; 	struct dma_stm32_stream *stream =
 800b958: 4413         	add	r3, r2
 800b95a: f8c7 30c4    	str.w	r3, [r7, #0xc4]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)dev_config->base;
 800b95e: f8d7 30c0    	ldr.w	r3, [r7, #0xc0]
 800b962: 691b         	ldr	r3, [r3, #0x10]
 800b964: f8c7 30c8    	str.w	r3, [r7, #0xc8]
; 	LL_DMA_StructInit(&DMA_InitStruct);
 800b968: f107 0310    	add.w	r3, r7, #0x10
 800b96c: 4618         	mov	r0, r3
 800b96e: f01a fca1    	bl	0x80262b4 <LL_DMA_StructInit> @ imm = #0x1a942
; 	id = id - STM32_DMA_STREAM_OFFSET;
 800b972: 68bb         	ldr	r3, [r7, #0x8]
 800b974: 3b01         	subs	r3, #0x1
 800b976: 60bb         	str	r3, [r7, #0x8]
; 	if (id >= dev_config->max_streams) {
 800b978: f8d7 30c0    	ldr.w	r3, [r7, #0xc0]
 800b97c: 695b         	ldr	r3, [r3, #0x14]
 800b97e: 68ba         	ldr	r2, [r7, #0x8]
 800b980: 429a         	cmp	r2, r3
 800b982: d320         	blo	0x800b9c6 <dma_stm32_configure+0x92> @ imm = #0x40
; 		LOG_ERR("cannot configure the dma stream %d.", id);
 800b984: 2303         	movs	r3, #0x3
 800b986: 2b00         	cmp	r3, #0x0
 800b988: d01a         	beq	0x800b9c0 <dma_stm32_configure+0x8c> @ imm = #0x34
 800b98a: 2301         	movs	r3, #0x1
 800b98c: f887 3063    	strb.w	r3, [r7, #0x63]
 800b990: f897 3063    	ldrb.w	r3, [r7, #0x63]
 800b994: f083 0301    	eor	r3, r3, #0x1
 800b998: b2db         	uxtb	r3, r3
 800b99a: 2b00         	cmp	r3, #0x0
 800b99c: d110         	bne	0x800b9c0 <dma_stm32_configure+0x8c> @ imm = #0x20
 800b99e: 4b9b         	ldr	r3, [pc, #0x26c]        @ 0x800bc0c <dma_stm32_configure+0x2d8>
 800b9a0: 6819         	ldr	r1, [r3]
 800b9a2: 68bb         	ldr	r3, [r7, #0x8]
 800b9a4: 9303         	str	r3, [sp, #0xc]
 800b9a6: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x800bc10 <dma_stm32_configure+0x2dc>
 800b9a8: 9302         	str	r3, [sp, #0x8]
 800b9aa: 2300         	movs	r3, #0x0
 800b9ac: 9301         	str	r3, [sp, #0x4]
 800b9ae: 2300         	movs	r3, #0x0
 800b9b0: 9300         	str	r3, [sp]
 800b9b2: 2300         	movs	r3, #0x0
 800b9b4: 2201         	movs	r2, #0x1
 800b9b6: 2000         	movs	r0, #0x0
 800b9b8: f013 fd3f    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13a7e
 800b9bc: 2300         	movs	r3, #0x0
 800b9be: 65fb         	str	r3, [r7, #0x5c]
; 		return -EINVAL;
 800b9c0: f06f 0315    	mvn	r3, #0x15
 800b9c4: e3ba         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x774
; 	if (stream->busy) {
 800b9c6: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800b9ca: 7a9b         	ldrb	r3, [r3, #0xa]
 800b9cc: b2db         	uxtb	r3, r3
 800b9ce: 2b00         	cmp	r3, #0x0
 800b9d0: d020         	beq	0x800ba14 <dma_stm32_configure+0xe0> @ imm = #0x40
; 		LOG_ERR("dma stream %d is busy.", id);
 800b9d2: 2303         	movs	r3, #0x3
 800b9d4: 2b00         	cmp	r3, #0x0
 800b9d6: d01a         	beq	0x800ba0e <dma_stm32_configure+0xda> @ imm = #0x34
 800b9d8: 2301         	movs	r3, #0x1
 800b9da: f887 306b    	strb.w	r3, [r7, #0x6b]
 800b9de: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 800b9e2: f083 0301    	eor	r3, r3, #0x1
 800b9e6: b2db         	uxtb	r3, r3
 800b9e8: 2b00         	cmp	r3, #0x0
 800b9ea: d110         	bne	0x800ba0e <dma_stm32_configure+0xda> @ imm = #0x20
 800b9ec: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x800bc0c <dma_stm32_configure+0x2d8>
 800b9ee: 6819         	ldr	r1, [r3]
 800b9f0: 68bb         	ldr	r3, [r7, #0x8]
 800b9f2: 9303         	str	r3, [sp, #0xc]
 800b9f4: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x800bc14 <dma_stm32_configure+0x2e0>
 800b9f6: 9302         	str	r3, [sp, #0x8]
 800b9f8: 2300         	movs	r3, #0x0
 800b9fa: 9301         	str	r3, [sp, #0x4]
 800b9fc: 2300         	movs	r3, #0x0
 800b9fe: 9300         	str	r3, [sp]
 800ba00: 2300         	movs	r3, #0x0
 800ba02: 2201         	movs	r2, #0x1
 800ba04: 2000         	movs	r0, #0x0
 800ba06: f013 fd18    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13a30
 800ba0a: 2300         	movs	r3, #0x0
 800ba0c: 667b         	str	r3, [r7, #0x64]
; 		return -EBUSY;
 800ba0e: f06f 030f    	mvn	r3, #0xf
 800ba12: e393         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x726
; 	if (dma_stm32_disable_stream(dma, id) != 0) {
 800ba14: 68b9         	ldr	r1, [r7, #0x8]
 800ba16: f8d7 00c8    	ldr.w	r0, [r7, #0xc8]
 800ba1a: f013 fd5a    	bl	0x801f4d2 <dma_stm32_disable_stream> @ imm = #0x13ab4
 800ba1e: 4603         	mov	r3, r0
 800ba20: 2b00         	cmp	r3, #0x0
 800ba22: d020         	beq	0x800ba66 <dma_stm32_configure+0x132> @ imm = #0x40
; 		LOG_ERR("could not disable dma stream %d.", id);
 800ba24: 2303         	movs	r3, #0x3
 800ba26: 2b00         	cmp	r3, #0x0
 800ba28: d01a         	beq	0x800ba60 <dma_stm32_configure+0x12c> @ imm = #0x34
 800ba2a: 2301         	movs	r3, #0x1
 800ba2c: f887 3073    	strb.w	r3, [r7, #0x73]
 800ba30: f897 3073    	ldrb.w	r3, [r7, #0x73]
 800ba34: f083 0301    	eor	r3, r3, #0x1
 800ba38: b2db         	uxtb	r3, r3
 800ba3a: 2b00         	cmp	r3, #0x0
 800ba3c: d110         	bne	0x800ba60 <dma_stm32_configure+0x12c> @ imm = #0x20
 800ba3e: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x800bc0c <dma_stm32_configure+0x2d8>
 800ba40: 6819         	ldr	r1, [r3]
 800ba42: 68bb         	ldr	r3, [r7, #0x8]
 800ba44: 9303         	str	r3, [sp, #0xc]
 800ba46: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800bc18 <dma_stm32_configure+0x2e4>
 800ba48: 9302         	str	r3, [sp, #0x8]
 800ba4a: 2300         	movs	r3, #0x0
 800ba4c: 9301         	str	r3, [sp, #0x4]
 800ba4e: 2300         	movs	r3, #0x0
 800ba50: 9300         	str	r3, [sp]
 800ba52: 2300         	movs	r3, #0x0
 800ba54: 2201         	movs	r2, #0x1
 800ba56: 2000         	movs	r0, #0x0
 800ba58: f013 fcef    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x139de
 800ba5c: 2300         	movs	r3, #0x0
 800ba5e: 66fb         	str	r3, [r7, #0x6c]
; 		return -EBUSY;
 800ba60: f06f 030f    	mvn	r3, #0xf
 800ba64: e36a         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x6d4
; 	dma_stm32_clear_stream_irq(dev, id);
 800ba66: 68b9         	ldr	r1, [r7, #0x8]
 800ba68: 68f8         	ldr	r0, [r7, #0xc]
 800ba6a: f013 fd17    	bl	0x801f49c <dma_stm32_clear_stream_irq> @ imm = #0x13a2e
; 	if (config->linked_channel == STM32_DMA_HAL_OVERRIDE) {
 800ba6e: 687b         	ldr	r3, [r7, #0x4]
 800ba70: 885b         	ldrh	r3, [r3, #0x2]
 800ba72: f403 637e    	and	r3, r3, #0xfe0
 800ba76: b29b         	uxth	r3, r3
 800ba78: f5b3 6f7e    	cmp.w	r3, #0xfe0
 800ba7c: d117         	bne	0x800baae <dma_stm32_configure+0x17a> @ imm = #0x2e
; 		stream->busy = true;
 800ba7e: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800ba82: 2201         	movs	r2, #0x1
 800ba84: 729a         	strb	r2, [r3, #0xa]
; 		stream->hal_override = true;
 800ba86: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800ba8a: 2201         	movs	r2, #0x1
 800ba8c: 725a         	strb	r2, [r3, #0x9]
; 		stream->dma_callback = config->dma_callback;
 800ba8e: 687b         	ldr	r3, [r7, #0x4]
 800ba90: 699a         	ldr	r2, [r3, #0x18]
 800ba92: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800ba96: 619a         	str	r2, [r3, #0x18]
; 		stream->user_data = config->user_data;
 800ba98: 687b         	ldr	r3, [r7, #0x4]
 800ba9a: 695a         	ldr	r2, [r3, #0x14]
 800ba9c: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800baa0: 615a         	str	r2, [r3, #0x14]
; 		stream->cyclic = false;
 800baa2: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800baa6: 2200         	movs	r2, #0x0
 800baa8: 771a         	strb	r2, [r3, #0x1c]
; 		return 0;
 800baaa: 2300         	movs	r3, #0x0
 800baac: e346         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x68c
; 	if (config->head_block->block_size > DMA_STM32_MAX_DATA_ITEMS) {
 800baae: 687b         	ldr	r3, [r7, #0x4]
 800bab0: 691b         	ldr	r3, [r3, #0x10]
 800bab2: 695b         	ldr	r3, [r3, #0x14]
 800bab4: f5b3 3f80    	cmp.w	r3, #0x10000
 800bab8: d322         	blo	0x800bb00 <dma_stm32_configure+0x1cc> @ imm = #0x44
; 		LOG_ERR("Data size too big: %d\n",
 800baba: 2303         	movs	r3, #0x3
 800babc: 2b00         	cmp	r3, #0x0
 800babe: d01c         	beq	0x800bafa <dma_stm32_configure+0x1c6> @ imm = #0x38
 800bac0: 2301         	movs	r3, #0x1
 800bac2: f887 307b    	strb.w	r3, [r7, #0x7b]
 800bac6: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 800baca: f083 0301    	eor	r3, r3, #0x1
 800bace: b2db         	uxtb	r3, r3
 800bad0: 2b00         	cmp	r3, #0x0
 800bad2: d112         	bne	0x800bafa <dma_stm32_configure+0x1c6> @ imm = #0x24
 800bad4: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800bc0c <dma_stm32_configure+0x2d8>
 800bad6: 6819         	ldr	r1, [r3]
 800bad8: 687b         	ldr	r3, [r7, #0x4]
 800bada: 691b         	ldr	r3, [r3, #0x10]
 800badc: 695b         	ldr	r3, [r3, #0x14]
 800bade: 9303         	str	r3, [sp, #0xc]
 800bae0: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x800bc1c <dma_stm32_configure+0x2e8>
 800bae2: 9302         	str	r3, [sp, #0x8]
 800bae4: 2300         	movs	r3, #0x0
 800bae6: 9301         	str	r3, [sp, #0x4]
 800bae8: 2300         	movs	r3, #0x0
 800baea: 9300         	str	r3, [sp]
 800baec: 2300         	movs	r3, #0x0
 800baee: 2201         	movs	r2, #0x1
 800baf0: 2000         	movs	r0, #0x0
 800baf2: f013 fca2    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13944
 800baf6: 2300         	movs	r3, #0x0
 800baf8: 677b         	str	r3, [r7, #0x74]
; 		return -EINVAL;
 800bafa: f06f 0315    	mvn	r3, #0x15
 800bafe: e31d         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x63a
; 	if ((config->channel_direction == MEMORY_TO_MEMORY) &&
 800bb00: 687b         	ldr	r3, [r7, #0x4]
 800bb02: 785b         	ldrb	r3, [r3, #0x1]
 800bb04: f003 0307    	and	r3, r3, #0x7
 800bb08: b2db         	uxtb	r3, r3
 800bb0a: 2b00         	cmp	r3, #0x0
 800bb0c: d12a         	bne	0x800bb64 <dma_stm32_configure+0x230> @ imm = #0x54
; 		(!dev_config->support_m2m)) {
 800bb0e: f8d7 30c0    	ldr.w	r3, [r7, #0xc0]
 800bb12: 7b1b         	ldrb	r3, [r3, #0xc]
 800bb14: f083 0301    	eor	r3, r3, #0x1
 800bb18: b2db         	uxtb	r3, r3
; 	if ((config->channel_direction == MEMORY_TO_MEMORY) &&
 800bb1a: 2b00         	cmp	r3, #0x0
 800bb1c: d022         	beq	0x800bb64 <dma_stm32_configure+0x230> @ imm = #0x44
; 		LOG_ERR("Memcopy not supported for device %s",
 800bb1e: 2303         	movs	r3, #0x3
 800bb20: 2b00         	cmp	r3, #0x0
 800bb22: d01c         	beq	0x800bb5e <dma_stm32_configure+0x22a> @ imm = #0x38
 800bb24: 2301         	movs	r3, #0x1
 800bb26: f887 30d2    	strb.w	r3, [r7, #0xd2]
 800bb2a: f897 30d2    	ldrb.w	r3, [r7, #0xd2]
 800bb2e: f083 0301    	eor	r3, r3, #0x1
 800bb32: b2db         	uxtb	r3, r3
 800bb34: 2b00         	cmp	r3, #0x0
 800bb36: d112         	bne	0x800bb5e <dma_stm32_configure+0x22a> @ imm = #0x24
 800bb38: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x800bc0c <dma_stm32_configure+0x2d8>
 800bb3a: 6819         	ldr	r1, [r3]
 800bb3c: 68fb         	ldr	r3, [r7, #0xc]
 800bb3e: 681b         	ldr	r3, [r3]
 800bb40: 9303         	str	r3, [sp, #0xc]
 800bb42: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x800bc20 <dma_stm32_configure+0x2ec>
 800bb44: 9302         	str	r3, [sp, #0x8]
 800bb46: 2300         	movs	r3, #0x0
 800bb48: 9301         	str	r3, [sp, #0x4]
 800bb4a: 2300         	movs	r3, #0x0
 800bb4c: 9300         	str	r3, [sp]
 800bb4e: 2300         	movs	r3, #0x0
 800bb50: 2201         	movs	r2, #0x1
 800bb52: 2000         	movs	r0, #0x0
 800bb54: f013 fc71    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x138e2
 800bb58: 2300         	movs	r3, #0x0
 800bb5a: f8c7 30cc    	str.w	r3, [r7, #0xcc]
; 		return -ENOTSUP;
 800bb5e: f06f 0385    	mvn	r3, #0x85
 800bb62: e2eb         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x5d6
; 	if ((config->dest_data_size != config->source_data_size)) {
 800bb64: 687b         	ldr	r3, [r7, #0x4]
 800bb66: 88da         	ldrh	r2, [r3, #0x6]
 800bb68: 687b         	ldr	r3, [r7, #0x4]
 800bb6a: 889b         	ldrh	r3, [r3, #0x4]
 800bb6c: 429a         	cmp	r2, r3
 800bb6e: d01e         	beq	0x800bbae <dma_stm32_configure+0x27a> @ imm = #0x3c
; 		LOG_ERR("source and dest data size differ.");
 800bb70: 2303         	movs	r3, #0x3
 800bb72: 2b00         	cmp	r3, #0x0
 800bb74: d018         	beq	0x800bba8 <dma_stm32_configure+0x274> @ imm = #0x30
 800bb76: 2301         	movs	r3, #0x1
 800bb78: f887 3083    	strb.w	r3, [r7, #0x83]
 800bb7c: f897 3083    	ldrb.w	r3, [r7, #0x83]
 800bb80: f083 0301    	eor	r3, r3, #0x1
 800bb84: b2db         	uxtb	r3, r3
 800bb86: 2b00         	cmp	r3, #0x0
 800bb88: d10e         	bne	0x800bba8 <dma_stm32_configure+0x274> @ imm = #0x1c
 800bb8a: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800bc0c <dma_stm32_configure+0x2d8>
 800bb8c: 6819         	ldr	r1, [r3]
 800bb8e: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800bc24 <dma_stm32_configure+0x2f0>
 800bb90: 9302         	str	r3, [sp, #0x8]
 800bb92: 2300         	movs	r3, #0x0
 800bb94: 9301         	str	r3, [sp, #0x4]
 800bb96: 2300         	movs	r3, #0x0
 800bb98: 9300         	str	r3, [sp]
 800bb9a: 2300         	movs	r3, #0x0
 800bb9c: 2201         	movs	r2, #0x1
 800bb9e: 2000         	movs	r0, #0x0
 800bba0: f013 fc4b    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13896
 800bba4: 2300         	movs	r3, #0x0
 800bba6: 67fb         	str	r3, [r7, #0x7c]
; 		return -EINVAL;
 800bba8: f06f 0315    	mvn	r3, #0x15
 800bbac: e2c6         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x58c
; 	if (config->source_data_size != 4U &&
 800bbae: 687b         	ldr	r3, [r7, #0x4]
 800bbb0: 889b         	ldrh	r3, [r3, #0x4]
 800bbb2: 2b04         	cmp	r3, #0x4
 800bbb4: d03a         	beq	0x800bc2c <dma_stm32_configure+0x2f8> @ imm = #0x74
; 	    config->source_data_size != 2U &&
 800bbb6: 687b         	ldr	r3, [r7, #0x4]
 800bbb8: 889b         	ldrh	r3, [r3, #0x4]
; 	if (config->source_data_size != 4U &&
 800bbba: 2b02         	cmp	r3, #0x2
 800bbbc: d036         	beq	0x800bc2c <dma_stm32_configure+0x2f8> @ imm = #0x6c
; 	    config->source_data_size != 1U) {
 800bbbe: 687b         	ldr	r3, [r7, #0x4]
 800bbc0: 889b         	ldrh	r3, [r3, #0x4]
; 	    config->source_data_size != 2U &&
 800bbc2: 2b01         	cmp	r3, #0x1
 800bbc4: d032         	beq	0x800bc2c <dma_stm32_configure+0x2f8> @ imm = #0x64
; 		LOG_ERR("source and dest unit size error, %d",
 800bbc6: 2303         	movs	r3, #0x3
 800bbc8: 2b00         	cmp	r3, #0x0
 800bbca: d01c         	beq	0x800bc06 <dma_stm32_configure+0x2d2> @ imm = #0x38
 800bbcc: 2301         	movs	r3, #0x1
 800bbce: f887 30d3    	strb.w	r3, [r7, #0xd3]
 800bbd2: f897 30d3    	ldrb.w	r3, [r7, #0xd3]
 800bbd6: f083 0301    	eor	r3, r3, #0x1
 800bbda: b2db         	uxtb	r3, r3
 800bbdc: 2b00         	cmp	r3, #0x0
 800bbde: d112         	bne	0x800bc06 <dma_stm32_configure+0x2d2> @ imm = #0x24
 800bbe0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800bc0c <dma_stm32_configure+0x2d8>
 800bbe2: 6819         	ldr	r1, [r3]
 800bbe4: 687b         	ldr	r3, [r7, #0x4]
 800bbe6: 889b         	ldrh	r3, [r3, #0x4]
 800bbe8: 9303         	str	r3, [sp, #0xc]
 800bbea: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800bc28 <dma_stm32_configure+0x2f4>
 800bbec: 9302         	str	r3, [sp, #0x8]
 800bbee: 2300         	movs	r3, #0x0
 800bbf0: 9301         	str	r3, [sp, #0x4]
 800bbf2: 2300         	movs	r3, #0x0
 800bbf4: 9300         	str	r3, [sp]
 800bbf6: 2300         	movs	r3, #0x0
 800bbf8: 2201         	movs	r2, #0x1
 800bbfa: 2000         	movs	r0, #0x0
 800bbfc: f013 fc1d    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x1383a
 800bc00: 2300         	movs	r3, #0x0
 800bc02: f8c7 30d4    	str.w	r3, [r7, #0xd4]
; 		return -EINVAL;
 800bc06: f06f 0315    	mvn	r3, #0x15
 800bc0a: e297         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x52e

0800bc0c <$d>:
 800bc0c: c8 06 00 24  	.word	0x240006c8
 800bc10: 10 b4 02 08  	.word	0x0802b410
 800bc14: 34 b4 02 08  	.word	0x0802b434
 800bc18: 4c b4 02 08  	.word	0x0802b44c
 800bc1c: 70 b4 02 08  	.word	0x0802b470
 800bc20: 88 b4 02 08  	.word	0x0802b488
 800bc24: ac b4 02 08  	.word	0x0802b4ac
 800bc28: d0 b4 02 08  	.word	0x0802b4d0

0800bc2c <$t>:
; 	if (config->head_block->source_reload_en !=
 800bc2c: 687b         	ldr	r3, [r7, #0x4]
 800bc2e: 691b         	ldr	r3, [r3, #0x10]
 800bc30: 7f1b         	ldrb	r3, [r3, #0x1c]
 800bc32: f3c3 1380    	ubfx	r3, r3, #0x6, #0x1
 800bc36: b2da         	uxtb	r2, r3
; 		config->head_block->dest_reload_en) {
 800bc38: 687b         	ldr	r3, [r7, #0x4]
 800bc3a: 691b         	ldr	r3, [r3, #0x10]
 800bc3c: 7f1b         	ldrb	r3, [r3, #0x1c]
 800bc3e: f3c3 13c0    	ubfx	r3, r3, #0x7, #0x1
 800bc42: b2db         	uxtb	r3, r3
; 	if (config->head_block->source_reload_en !=
 800bc44: 429a         	cmp	r2, r3
 800bc46: d01f         	beq	0x800bc88 <dma_stm32_configure+0x354> @ imm = #0x3e
; 		LOG_ERR("source_reload_en and dest_reload_en must "
 800bc48: 2303         	movs	r3, #0x3
 800bc4a: 2b00         	cmp	r3, #0x0
 800bc4c: d019         	beq	0x800bc82 <dma_stm32_configure+0x34e> @ imm = #0x32
 800bc4e: 2301         	movs	r3, #0x1
 800bc50: f887 308b    	strb.w	r3, [r7, #0x8b]
 800bc54: f897 308b    	ldrb.w	r3, [r7, #0x8b]
 800bc58: f083 0301    	eor	r3, r3, #0x1
 800bc5c: b2db         	uxtb	r3, r3
 800bc5e: 2b00         	cmp	r3, #0x0
 800bc60: d10f         	bne	0x800bc82 <dma_stm32_configure+0x34e> @ imm = #0x1e
 800bc62: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x800bed4 <dma_stm32_configure+0x5a0>
 800bc64: 6819         	ldr	r1, [r3]
 800bc66: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x800bed8 <dma_stm32_configure+0x5a4>
 800bc68: 9302         	str	r3, [sp, #0x8]
 800bc6a: 2300         	movs	r3, #0x0
 800bc6c: 9301         	str	r3, [sp, #0x4]
 800bc6e: 2300         	movs	r3, #0x0
 800bc70: 9300         	str	r3, [sp]
 800bc72: 2300         	movs	r3, #0x0
 800bc74: 2201         	movs	r2, #0x1
 800bc76: 2000         	movs	r0, #0x0
 800bc78: f013 fbdf    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x137be
 800bc7c: 2300         	movs	r3, #0x0
 800bc7e: f8c7 3084    	str.w	r3, [r7, #0x84]
; 		return -EINVAL;
 800bc82: f06f 0315    	mvn	r3, #0x15
 800bc86: e259         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x4b2
; 	stream->busy		= true;
 800bc88: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800bc8c: 2201         	movs	r2, #0x1
 800bc8e: 729a         	strb	r2, [r3, #0xa]
; 	stream->dma_callback	= config->dma_callback;
 800bc90: 687b         	ldr	r3, [r7, #0x4]
 800bc92: 699a         	ldr	r2, [r3, #0x18]
 800bc94: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800bc98: 619a         	str	r2, [r3, #0x18]
; 	stream->direction	= config->channel_direction;
 800bc9a: 687b         	ldr	r3, [r7, #0x4]
 800bc9c: 785b         	ldrb	r3, [r3, #0x1]
 800bc9e: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 800bca2: b2db         	uxtb	r3, r3
 800bca4: 461a         	mov	r2, r3
 800bca6: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800bcaa: 601a         	str	r2, [r3]
; 	stream->user_data       = config->user_data;
 800bcac: 687b         	ldr	r3, [r7, #0x4]
 800bcae: 695a         	ldr	r2, [r3, #0x14]
 800bcb0: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800bcb4: 615a         	str	r2, [r3, #0x14]
; 	stream->src_size	= config->source_data_size;
 800bcb6: 687b         	ldr	r3, [r7, #0x4]
 800bcb8: 889b         	ldrh	r3, [r3, #0x4]
 800bcba: 461a         	mov	r2, r3
 800bcbc: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800bcc0: 60da         	str	r2, [r3, #0xc]
; 	stream->dst_size	= config->dest_data_size;
 800bcc2: 687b         	ldr	r3, [r7, #0x4]
 800bcc4: 88db         	ldrh	r3, [r3, #0x6]
 800bcc6: 461a         	mov	r2, r3
 800bcc8: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800bccc: 611a         	str	r2, [r3, #0x10]
; 	stream->cyclic		= config->head_block->source_reload_en;
 800bcce: 687b         	ldr	r3, [r7, #0x4]
 800bcd0: 691b         	ldr	r3, [r3, #0x10]
 800bcd2: 7f1b         	ldrb	r3, [r3, #0x1c]
 800bcd4: f3c3 1380    	ubfx	r3, r3, #0x6, #0x1
 800bcd8: b2db         	uxtb	r3, r3
 800bcda: 2b00         	cmp	r3, #0x0
 800bcdc: bf14         	ite	ne
 800bcde: 2301         	movne	r3, #0x1
 800bce0: 2300         	moveq	r3, #0x0
 800bce2: b2da         	uxtb	r2, r3
 800bce4: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800bce8: 771a         	strb	r2, [r3, #0x1c]
; 	if (config->head_block->source_address == 0) {
 800bcea: 687b         	ldr	r3, [r7, #0x4]
 800bcec: 691b         	ldr	r3, [r3, #0x10]
 800bcee: 681b         	ldr	r3, [r3]
 800bcf0: 2b00         	cmp	r3, #0x0
 800bcf2: d11c         	bne	0x800bd2e <dma_stm32_configure+0x3fa> @ imm = #0x38
; 		LOG_WRN("source_buffer address is null.");
 800bcf4: 2303         	movs	r3, #0x3
 800bcf6: 2b01         	cmp	r3, #0x1
 800bcf8: d919         	bls	0x800bd2e <dma_stm32_configure+0x3fa> @ imm = #0x32
 800bcfa: 2301         	movs	r3, #0x1
 800bcfc: f887 30bb    	strb.w	r3, [r7, #0xbb]
 800bd00: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 800bd04: f083 0301    	eor	r3, r3, #0x1
 800bd08: b2db         	uxtb	r3, r3
 800bd0a: 2b00         	cmp	r3, #0x0
 800bd0c: d10f         	bne	0x800bd2e <dma_stm32_configure+0x3fa> @ imm = #0x1e
 800bd0e: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x800bed4 <dma_stm32_configure+0x5a0>
 800bd10: 6819         	ldr	r1, [r3]
 800bd12: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x800bedc <dma_stm32_configure+0x5a8>
 800bd14: 9302         	str	r3, [sp, #0x8]
 800bd16: 2300         	movs	r3, #0x0
 800bd18: 9301         	str	r3, [sp, #0x4]
 800bd1a: 2300         	movs	r3, #0x0
 800bd1c: 9300         	str	r3, [sp]
 800bd1e: 2300         	movs	r3, #0x0
 800bd20: 2202         	movs	r2, #0x2
 800bd22: 2000         	movs	r0, #0x0
 800bd24: f013 fb89    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13712
 800bd28: 2300         	movs	r3, #0x0
 800bd2a: f8c7 30b4    	str.w	r3, [r7, #0xb4]
; 	if (config->head_block->dest_address == 0) {
 800bd2e: 687b         	ldr	r3, [r7, #0x4]
 800bd30: 691b         	ldr	r3, [r3, #0x10]
 800bd32: 685b         	ldr	r3, [r3, #0x4]
 800bd34: 2b00         	cmp	r3, #0x0
 800bd36: d11c         	bne	0x800bd72 <dma_stm32_configure+0x43e> @ imm = #0x38
; 		LOG_WRN("dest_buffer address is null.");
 800bd38: 2303         	movs	r3, #0x3
 800bd3a: 2b01         	cmp	r3, #0x1
 800bd3c: d919         	bls	0x800bd72 <dma_stm32_configure+0x43e> @ imm = #0x32
 800bd3e: 2301         	movs	r3, #0x1
 800bd40: f887 30b3    	strb.w	r3, [r7, #0xb3]
 800bd44: f897 30b3    	ldrb.w	r3, [r7, #0xb3]
 800bd48: f083 0301    	eor	r3, r3, #0x1
 800bd4c: b2db         	uxtb	r3, r3
 800bd4e: 2b00         	cmp	r3, #0x0
 800bd50: d10f         	bne	0x800bd72 <dma_stm32_configure+0x43e> @ imm = #0x1e
 800bd52: 4b60         	ldr	r3, [pc, #0x180]        @ 0x800bed4 <dma_stm32_configure+0x5a0>
 800bd54: 6819         	ldr	r1, [r3]
 800bd56: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800bee0 <dma_stm32_configure+0x5ac>
 800bd58: 9302         	str	r3, [sp, #0x8]
 800bd5a: 2300         	movs	r3, #0x0
 800bd5c: 9301         	str	r3, [sp, #0x4]
 800bd5e: 2300         	movs	r3, #0x0
 800bd60: 9300         	str	r3, [sp]
 800bd62: 2300         	movs	r3, #0x0
 800bd64: 2202         	movs	r2, #0x2
 800bd66: 2000         	movs	r0, #0x0
 800bd68: f013 fb67    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x136ce
 800bd6c: 2300         	movs	r3, #0x0
 800bd6e: f8c7 30ac    	str.w	r3, [r7, #0xac]
; 	if (stream->direction == MEMORY_TO_PERIPHERAL) {
 800bd72: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800bd76: 681b         	ldr	r3, [r3]
 800bd78: 2b01         	cmp	r3, #0x1
 800bd7a: d108         	bne	0x800bd8e <dma_stm32_configure+0x45a> @ imm = #0x10
; 					config->head_block->source_address;
 800bd7c: 687b         	ldr	r3, [r7, #0x4]
 800bd7e: 691b         	ldr	r3, [r3, #0x10]
 800bd80: 681b         	ldr	r3, [r3]
; 		DMA_InitStruct.MemoryOrM2MDstAddress =
 800bd82: 617b         	str	r3, [r7, #0x14]
; 					config->head_block->dest_address;
 800bd84: 687b         	ldr	r3, [r7, #0x4]
 800bd86: 691b         	ldr	r3, [r3, #0x10]
 800bd88: 685b         	ldr	r3, [r3, #0x4]
; 		DMA_InitStruct.PeriphOrM2MSrcAddress =
 800bd8a: 613b         	str	r3, [r7, #0x10]
 800bd8c: e007         	b	0x800bd9e <dma_stm32_configure+0x46a> @ imm = #0xe
; 					config->head_block->source_address;
 800bd8e: 687b         	ldr	r3, [r7, #0x4]
 800bd90: 691b         	ldr	r3, [r3, #0x10]
 800bd92: 681b         	ldr	r3, [r3]
; 		DMA_InitStruct.PeriphOrM2MSrcAddress =
 800bd94: 613b         	str	r3, [r7, #0x10]
; 					config->head_block->dest_address;
 800bd96: 687b         	ldr	r3, [r7, #0x4]
 800bd98: 691b         	ldr	r3, [r3, #0x10]
 800bd9a: 685b         	ldr	r3, [r3, #0x4]
; 		DMA_InitStruct.MemoryOrM2MDstAddress =
 800bd9c: 617b         	str	r3, [r7, #0x14]
; 	uint16_t memory_addr_adj = 0, periph_addr_adj = 0;
 800bd9e: 2300         	movs	r3, #0x0
 800bda0: f8a7 30bc    	strh.w	r3, [r7, #0xbc]
 800bda4: 2300         	movs	r3, #0x0
 800bda6: f8a7 30be    	strh.w	r3, [r7, #0xbe]
; 	ret = dma_stm32_get_priority(config->channel_priority,
 800bdaa: 687b         	ldr	r3, [r7, #0x4]
 800bdac: 681b         	ldr	r3, [r3]
 800bdae: f3c3 33c3    	ubfx	r3, r3, #0xf, #0x4
 800bdb2: b2db         	uxtb	r3, r3
 800bdb4: 461a         	mov	r2, r3
 800bdb6: f107 0310    	add.w	r3, r7, #0x10
 800bdba: 3328         	adds	r3, #0x28
 800bdbc: 4619         	mov	r1, r3
 800bdbe: 4610         	mov	r0, r2
 800bdc0: f7ff fc9c    	bl	0x800b6fc <dma_stm32_get_priority> @ imm = #-0x6c8
 800bdc4: f8c7 00a8    	str.w	r0, [r7, #0xa8]
; 	if (ret < 0) {
 800bdc8: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800bdcc: 2b00         	cmp	r3, #0x0
 800bdce: da02         	bge	0x800bdd6 <dma_stm32_configure+0x4a2> @ imm = #0x4
; 		return ret;
 800bdd0: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800bdd4: e1b2         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x364
; 	ret = dma_stm32_get_direction(config->channel_direction,
 800bdd6: 687b         	ldr	r3, [r7, #0x4]
 800bdd8: 785b         	ldrb	r3, [r3, #0x1]
 800bdda: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 800bdde: b2db         	uxtb	r3, r3
 800bde0: 461a         	mov	r2, r3
 800bde2: f107 0310    	add.w	r3, r7, #0x10
 800bde6: 3308         	adds	r3, #0x8
 800bde8: 4619         	mov	r1, r3
 800bdea: 4610         	mov	r0, r2
 800bdec: f7ff fcd6    	bl	0x800b79c <dma_stm32_get_direction> @ imm = #-0x654
 800bdf0: f8c7 00a8    	str.w	r0, [r7, #0xa8]
; 	if (ret < 0) {
 800bdf4: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800bdf8: 2b00         	cmp	r3, #0x0
 800bdfa: da02         	bge	0x800be02 <dma_stm32_configure+0x4ce> @ imm = #0x4
; 		return ret;
 800bdfc: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800be00: e19c         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x338
; 	switch (config->channel_direction) {
 800be02: 687b         	ldr	r3, [r7, #0x4]
 800be04: 785b         	ldrb	r3, [r3, #0x1]
 800be06: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 800be0a: b2db         	uxtb	r3, r3
 800be0c: 2b02         	cmp	r3, #0x2
 800be0e: d006         	beq	0x800be1e <dma_stm32_configure+0x4ea> @ imm = #0xc
 800be10: 2b02         	cmp	r3, #0x2
 800be12: dc26         	bgt	0x800be62 <dma_stm32_configure+0x52e> @ imm = #0x4c
 800be14: 2b00         	cmp	r3, #0x0
 800be16: d002         	beq	0x800be1e <dma_stm32_configure+0x4ea> @ imm = #0x4
 800be18: 2b01         	cmp	r3, #0x1
 800be1a: d011         	beq	0x800be40 <dma_stm32_configure+0x50c> @ imm = #0x22
 800be1c: e021         	b	0x800be62 <dma_stm32_configure+0x52e> @ imm = #0x42
; 		memory_addr_adj = config->head_block->dest_addr_adj;
 800be1e: 687b         	ldr	r3, [r7, #0x4]
 800be20: 691b         	ldr	r3, [r3, #0x10]
 800be22: 7f1b         	ldrb	r3, [r3, #0x1c]
 800be24: f3c3 1301    	ubfx	r3, r3, #0x4, #0x2
 800be28: b2db         	uxtb	r3, r3
 800be2a: f8a7 30bc    	strh.w	r3, [r7, #0xbc]
; 		periph_addr_adj = config->head_block->source_addr_adj;
 800be2e: 687b         	ldr	r3, [r7, #0x4]
 800be30: 691b         	ldr	r3, [r3, #0x10]
 800be32: 7f1b         	ldrb	r3, [r3, #0x1c]
 800be34: f3c3 0381    	ubfx	r3, r3, #0x2, #0x2
 800be38: b2db         	uxtb	r3, r3
 800be3a: f8a7 30be    	strh.w	r3, [r7, #0xbe]
; 		break;
 800be3e: e036         	b	0x800beae <dma_stm32_configure+0x57a> @ imm = #0x6c
; 		memory_addr_adj = config->head_block->source_addr_adj;
 800be40: 687b         	ldr	r3, [r7, #0x4]
 800be42: 691b         	ldr	r3, [r3, #0x10]
 800be44: 7f1b         	ldrb	r3, [r3, #0x1c]
 800be46: f3c3 0381    	ubfx	r3, r3, #0x2, #0x2
 800be4a: b2db         	uxtb	r3, r3
 800be4c: f8a7 30bc    	strh.w	r3, [r7, #0xbc]
; 		periph_addr_adj = config->head_block->dest_addr_adj;
 800be50: 687b         	ldr	r3, [r7, #0x4]
 800be52: 691b         	ldr	r3, [r3, #0x10]
 800be54: 7f1b         	ldrb	r3, [r3, #0x1c]
 800be56: f3c3 1301    	ubfx	r3, r3, #0x4, #0x2
 800be5a: b2db         	uxtb	r3, r3
 800be5c: f8a7 30be    	strh.w	r3, [r7, #0xbe]
; 		break;
 800be60: e025         	b	0x800beae <dma_stm32_configure+0x57a> @ imm = #0x4a
; 		LOG_ERR("Channel direction error (%d).",
 800be62: 2303         	movs	r3, #0x3
 800be64: 2b00         	cmp	r3, #0x0
 800be66: d01f         	beq	0x800bea8 <dma_stm32_configure+0x574> @ imm = #0x3e
 800be68: 2301         	movs	r3, #0x1
 800be6a: f887 3093    	strb.w	r3, [r7, #0x93]
 800be6e: f897 3093    	ldrb.w	r3, [r7, #0x93]
 800be72: f083 0301    	eor	r3, r3, #0x1
 800be76: b2db         	uxtb	r3, r3
 800be78: 2b00         	cmp	r3, #0x0
 800be7a: d115         	bne	0x800bea8 <dma_stm32_configure+0x574> @ imm = #0x2a
 800be7c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800bed4 <dma_stm32_configure+0x5a0>
 800be7e: 6819         	ldr	r1, [r3]
 800be80: 687b         	ldr	r3, [r7, #0x4]
 800be82: 785b         	ldrb	r3, [r3, #0x1]
 800be84: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 800be88: b2db         	uxtb	r3, r3
 800be8a: 9303         	str	r3, [sp, #0xc]
 800be8c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800bee4 <dma_stm32_configure+0x5b0>
 800be8e: 9302         	str	r3, [sp, #0x8]
 800be90: 2300         	movs	r3, #0x0
 800be92: 9301         	str	r3, [sp, #0x4]
 800be94: 2300         	movs	r3, #0x0
 800be96: 9300         	str	r3, [sp]
 800be98: 2300         	movs	r3, #0x0
 800be9a: 2201         	movs	r2, #0x1
 800be9c: 2000         	movs	r0, #0x0
 800be9e: f013 facc    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13598
 800bea2: 2300         	movs	r3, #0x0
 800bea4: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		return -EINVAL;
 800bea8: f06f 0315    	mvn	r3, #0x15
 800beac: e146         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x28c
; 	ret = dma_stm32_get_memory_increment(memory_addr_adj,
 800beae: f8b7 30bc    	ldrh.w	r3, [r7, #0xbc]
 800beb2: b2da         	uxtb	r2, r3
 800beb4: f107 0310    	add.w	r3, r7, #0x10
 800beb8: 3314         	adds	r3, #0x14
 800beba: 4619         	mov	r1, r3
 800bebc: 4610         	mov	r0, r2
 800bebe: f7ff fcb1    	bl	0x800b824 <dma_stm32_get_memory_increment> @ imm = #-0x69e
 800bec2: f8c7 00a8    	str.w	r0, [r7, #0xa8]
; 	if (ret < 0) {
 800bec6: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800beca: 2b00         	cmp	r3, #0x0
 800becc: da0c         	bge	0x800bee8 <dma_stm32_configure+0x5b4> @ imm = #0x18
; 		return ret;
 800bece: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800bed2: e133         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x266

0800bed4 <$d>:
 800bed4: c8 06 00 24  	.word	0x240006c8
 800bed8: f4 b4 02 08  	.word	0x0802b4f4
 800bedc: 2c b5 02 08  	.word	0x0802b52c
 800bee0: 4c b5 02 08  	.word	0x0802b54c
 800bee4: 6c b5 02 08  	.word	0x0802b56c

0800bee8 <$t>:
; 	LOG_DBG("Channel (%d) memory inc (%x).",
 800bee8: 2303         	movs	r3, #0x3
 800beea: 2b03         	cmp	r3, #0x3
 800beec: d91f         	bls	0x800bf2e <dma_stm32_configure+0x5fa> @ imm = #0x3e
 800beee: 2301         	movs	r3, #0x1
 800bef0: f887 30a7    	strb.w	r3, [r7, #0xa7]
 800bef4: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 800bef8: f083 0301    	eor	r3, r3, #0x1
 800befc: b2db         	uxtb	r3, r3
 800befe: 2b00         	cmp	r3, #0x0
 800bf00: d115         	bne	0x800bf2e <dma_stm32_configure+0x5fa> @ imm = #0x2a
 800bf02: 4b90         	ldr	r3, [pc, #0x240]        @ 0x800c144 <dma_stm32_configure+0x810>
 800bf04: 6819         	ldr	r1, [r3]
 800bf06: 6a7b         	ldr	r3, [r7, #0x24]
 800bf08: 9305         	str	r3, [sp, #0x14]
 800bf0a: 68bb         	ldr	r3, [r7, #0x8]
 800bf0c: 9304         	str	r3, [sp, #0x10]
 800bf0e: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x800c148 <dma_stm32_configure+0x814>
 800bf10: 9303         	str	r3, [sp, #0xc]
 800bf12: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x800c14c <dma_stm32_configure+0x818>
 800bf14: 9302         	str	r3, [sp, #0x8]
 800bf16: 2308         	movs	r3, #0x8
 800bf18: 9301         	str	r3, [sp, #0x4]
 800bf1a: 2300         	movs	r3, #0x0
 800bf1c: 9300         	str	r3, [sp]
 800bf1e: 2300         	movs	r3, #0x0
 800bf20: 2204         	movs	r2, #0x4
 800bf22: 2000         	movs	r0, #0x0
 800bf24: f013 fa89    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13512
 800bf28: 2300         	movs	r3, #0x0
 800bf2a: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; 	ret = dma_stm32_get_periph_increment(periph_addr_adj,
 800bf2e: f8b7 30be    	ldrh.w	r3, [r7, #0xbe]
 800bf32: b2da         	uxtb	r2, r3
 800bf34: f107 0310    	add.w	r3, r7, #0x10
 800bf38: 3310         	adds	r3, #0x10
 800bf3a: 4619         	mov	r1, r3
 800bf3c: 4610         	mov	r0, r2
 800bf3e: f7ff fcb5    	bl	0x800b8ac <dma_stm32_get_periph_increment> @ imm = #-0x696
 800bf42: f8c7 00a8    	str.w	r0, [r7, #0xa8]
; 	if (ret < 0) {
 800bf46: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800bf4a: 2b00         	cmp	r3, #0x0
 800bf4c: da02         	bge	0x800bf54 <dma_stm32_configure+0x620> @ imm = #0x4
; 		return ret;
 800bf4e: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800bf52: e0f3         	b	0x800c13c <dma_stm32_configure+0x808> @ imm = #0x1e6
; 	LOG_DBG("Channel (%d) peripheral inc (%x).",
 800bf54: 2303         	movs	r3, #0x3
 800bf56: 2b03         	cmp	r3, #0x3
 800bf58: d91f         	bls	0x800bf9a <dma_stm32_configure+0x666> @ imm = #0x3e
 800bf5a: 2301         	movs	r3, #0x1
 800bf5c: f887 309f    	strb.w	r3, [r7, #0x9f]
 800bf60: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 800bf64: f083 0301    	eor	r3, r3, #0x1
 800bf68: b2db         	uxtb	r3, r3
 800bf6a: 2b00         	cmp	r3, #0x0
 800bf6c: d115         	bne	0x800bf9a <dma_stm32_configure+0x666> @ imm = #0x2a
 800bf6e: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x800c144 <dma_stm32_configure+0x810>
 800bf70: 6819         	ldr	r1, [r3]
 800bf72: 6a3b         	ldr	r3, [r7, #0x20]
 800bf74: 9305         	str	r3, [sp, #0x14]
 800bf76: 68bb         	ldr	r3, [r7, #0x8]
 800bf78: 9304         	str	r3, [sp, #0x10]
 800bf7a: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x800c148 <dma_stm32_configure+0x814>
 800bf7c: 9303         	str	r3, [sp, #0xc]
 800bf7e: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800c150 <dma_stm32_configure+0x81c>
 800bf80: 9302         	str	r3, [sp, #0x8]
 800bf82: 2308         	movs	r3, #0x8
 800bf84: 9301         	str	r3, [sp, #0x4]
 800bf86: 2300         	movs	r3, #0x0
 800bf88: 9300         	str	r3, [sp]
 800bf8a: 2300         	movs	r3, #0x0
 800bf8c: 2204         	movs	r2, #0x4
 800bf8e: 2000         	movs	r0, #0x0
 800bf90: f013 fa53    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x134a6
 800bf94: 2300         	movs	r3, #0x0
 800bf96: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	if (stream->cyclic) {
 800bf9a: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800bf9e: 7f1b         	ldrb	r3, [r3, #0x1c]
 800bfa0: 2b00         	cmp	r3, #0x0
 800bfa2: d003         	beq	0x800bfac <dma_stm32_configure+0x678> @ imm = #0x6
; 		DMA_InitStruct.Mode = LL_DMA_MODE_CIRCULAR;
 800bfa4: f44f 7380    	mov.w	r3, #0x100
 800bfa8: 61fb         	str	r3, [r7, #0x1c]
 800bfaa: e001         	b	0x800bfb0 <dma_stm32_configure+0x67c> @ imm = #0x2
; 		DMA_InitStruct.Mode = LL_DMA_MODE_NORMAL;
 800bfac: 2300         	movs	r3, #0x0
 800bfae: 61fb         	str	r3, [r7, #0x1c]
; 	stream->source_periph = (stream->direction == PERIPHERAL_TO_MEMORY);
 800bfb0: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800bfb4: 681b         	ldr	r3, [r3]
 800bfb6: 2b02         	cmp	r3, #0x2
 800bfb8: bf0c         	ite	eq
 800bfba: 2301         	moveq	r3, #0x1
 800bfbc: 2300         	movne	r3, #0x0
 800bfbe: b2da         	uxtb	r2, r3
 800bfc0: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800bfc4: 721a         	strb	r2, [r3, #0x8]
; 	int index = find_lsb_set(config->source_data_size) - 1;
 800bfc6: 687b         	ldr	r3, [r7, #0x4]
 800bfc8: 889b         	ldrh	r3, [r3, #0x4]
 800bfca: 657b         	str	r3, [r7, #0x54]
; 	return __builtin_ffs(op);
 800bfcc: 6d7b         	ldr	r3, [r7, #0x54]
 800bfce: fa93 f2a3    	rbit	r2, r3
 800bfd2: fab2 f282    	clz	r2, r2
 800bfd6: 2b00         	cmp	r3, #0x0
 800bfd8: d101         	bne	0x800bfde <dma_stm32_configure+0x6aa> @ imm = #0x2
 800bfda: f04f 32ff    	mov.w	r2, #0xffffffff
 800bfde: 1c53         	adds	r3, r2, #0x1
; 	int index = find_lsb_set(config->source_data_size) - 1;
 800bfe0: 3b01         	subs	r3, #0x1
 800bfe2: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	DMA_InitStruct.PeriphOrM2MSrcDataSize = table_p_size[index];
 800bfe6: 4a5b         	ldr	r2, [pc, #0x16c]        @ 0x800c154 <dma_stm32_configure+0x820>
 800bfe8: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800bfec: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800bff0: 62bb         	str	r3, [r7, #0x28]
; 	index = find_lsb_set(config->dest_data_size) - 1;
 800bff2: 687b         	ldr	r3, [r7, #0x4]
 800bff4: 88db         	ldrh	r3, [r3, #0x6]
 800bff6: 65bb         	str	r3, [r7, #0x58]
; 	return __builtin_ffs(op);
 800bff8: 6dbb         	ldr	r3, [r7, #0x58]
 800bffa: fa93 f2a3    	rbit	r2, r3
 800bffe: fab2 f282    	clz	r2, r2
 800c002: 2b00         	cmp	r3, #0x0
 800c004: d101         	bne	0x800c00a <dma_stm32_configure+0x6d6> @ imm = #0x2
 800c006: f04f 32ff    	mov.w	r2, #0xffffffff
 800c00a: 1c53         	adds	r3, r2, #0x1
; 	index = find_lsb_set(config->dest_data_size) - 1;
 800c00c: 3b01         	subs	r3, #0x1
 800c00e: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	DMA_InitStruct.MemoryOrM2MDstDataSize = table_m_size[index];
 800c012: 4a51         	ldr	r2, [pc, #0x144]        @ 0x800c158 <dma_stm32_configure+0x824>
 800c014: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800c018: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c01c: 62fb         	str	r3, [r7, #0x2c]
; 	DMA_InitStruct.MemBurst = stm32_dma_get_mburst(config,
 800c01e: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800c022: 7a1b         	ldrb	r3, [r3, #0x8]
 800c024: 4619         	mov	r1, r3
 800c026: 6878         	ldr	r0, [r7, #0x4]
 800c028: f000 fb7a    	bl	0x800c720 <stm32_dma_get_mburst> @ imm = #0x6f4
 800c02c: 4603         	mov	r3, r0
 800c02e: 647b         	str	r3, [r7, #0x44]
; 	DMA_InitStruct.PeriphBurst = stm32_dma_get_pburst(config,
 800c030: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800c034: 7a1b         	ldrb	r3, [r3, #0x8]
 800c036: 4619         	mov	r1, r3
 800c038: 6878         	ldr	r0, [r7, #0x4]
 800c03a: f000 fbd7    	bl	0x800c7ec <stm32_dma_get_pburst> @ imm = #0x7ae
 800c03e: 4603         	mov	r3, r0
 800c040: 64bb         	str	r3, [r7, #0x48]
; 					config->head_block->fifo_mode_control);
 800c042: 687b         	ldr	r3, [r7, #0x4]
 800c044: 691b         	ldr	r3, [r3, #0x10]
 800c046: 7f5b         	ldrb	r3, [r3, #0x1d]
 800c048: f3c3 0303    	ubfx	r3, r3, #0x0, #0x4
 800c04c: b2db         	uxtb	r3, r3
; 	DMA_InitStruct.FIFOThreshold = stm32_dma_get_fifo_threshold(
 800c04e: 4618         	mov	r0, r3
 800c050: f000 fc32    	bl	0x800c8b8 <stm32_dma_get_fifo_threshold> @ imm = #0x864
 800c054: 4603         	mov	r3, r0
 800c056: 643b         	str	r3, [r7, #0x40]
; 	if (stm32_dma_check_fifo_mburst(&DMA_InitStruct)) {
 800c058: f107 0310    	add.w	r3, r7, #0x10
 800c05c: 4618         	mov	r0, r3
 800c05e: f014 fae6    	bl	0x802062e <stm32_dma_check_fifo_mburst> @ imm = #0x145cc
 800c062: 4603         	mov	r3, r0
 800c064: 2b00         	cmp	r3, #0x0
 800c066: d002         	beq	0x800c06e <dma_stm32_configure+0x73a> @ imm = #0x4
; 		DMA_InitStruct.FIFOMode = LL_DMA_FIFOMODE_ENABLE;
 800c068: 2304         	movs	r3, #0x4
 800c06a: 63fb         	str	r3, [r7, #0x3c]
 800c06c: e001         	b	0x800c072 <dma_stm32_configure+0x73e> @ imm = #0x2
; 		DMA_InitStruct.FIFOMode = LL_DMA_FIFOMODE_DISABLE;
 800c06e: 2300         	movs	r3, #0x0
 800c070: 63fb         	str	r3, [r7, #0x3c]
; 	if (stream->source_periph) {
 800c072: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800c076: 7a1b         	ldrb	r3, [r3, #0x8]
 800c078: 2b00         	cmp	r3, #0x0
 800c07a: d008         	beq	0x800c08e <dma_stm32_configure+0x75a> @ imm = #0x10
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 800c07c: 687b         	ldr	r3, [r7, #0x4]
 800c07e: 691b         	ldr	r3, [r3, #0x10]
 800c080: 695b         	ldr	r3, [r3, #0x14]
; 					config->source_data_size;
 800c082: 687a         	ldr	r2, [r7, #0x4]
 800c084: 8892         	ldrh	r2, [r2, #0x4]
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 800c086: fbb3 f3f2    	udiv	r3, r3, r2
 800c08a: 633b         	str	r3, [r7, #0x30]
 800c08c: e007         	b	0x800c09e <dma_stm32_configure+0x76a> @ imm = #0xe
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 800c08e: 687b         	ldr	r3, [r7, #0x4]
 800c090: 691b         	ldr	r3, [r3, #0x10]
 800c092: 695b         	ldr	r3, [r3, #0x14]
; 					config->dest_data_size;
 800c094: 687a         	ldr	r2, [r7, #0x4]
 800c096: 88d2         	ldrh	r2, [r2, #0x6]
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 800c098: fbb3 f3f2    	udiv	r3, r3, r2
 800c09c: 633b         	str	r3, [r7, #0x30]
; 	DMA_InitStruct.PeriphRequest = config->dma_slot;
 800c09e: 687b         	ldr	r3, [r7, #0x4]
 800c0a0: 781b         	ldrb	r3, [r3]
 800c0a2: 637b         	str	r3, [r7, #0x34]
; 	LL_DMA_Init(dma, dma_stm32_id_to_stream(id), &DMA_InitStruct);
 800c0a4: 68b8         	ldr	r0, [r7, #0x8]
 800c0a6: f000 f9c7    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #0x38e
 800c0aa: 4601         	mov	r1, r0
 800c0ac: f107 0310    	add.w	r3, r7, #0x10
 800c0b0: 461a         	mov	r2, r3
 800c0b2: f8d7 00c8    	ldr.w	r0, [r7, #0xc8]
 800c0b6: f01a f89d    	bl	0x80261f4 <LL_DMA_Init> @ imm = #0x1a13a
; 	LL_DMA_EnableIT_TC(dma, dma_stm32_id_to_stream(id));
 800c0ba: 68b8         	ldr	r0, [r7, #0x8]
 800c0bc: f000 f9bc    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #0x378
 800c0c0: 4603         	mov	r3, r0
 800c0c2: 4619         	mov	r1, r3
 800c0c4: f8d7 00c8    	ldr.w	r0, [r7, #0xc8]
 800c0c8: f7ff f9c6    	bl	0x800b458 <LL_DMA_EnableIT_TC> @ imm = #-0xc74
; 	if (stream->cyclic) {
 800c0cc: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800c0d0: 7f1b         	ldrb	r3, [r3, #0x1c]
 800c0d2: 2b00         	cmp	r3, #0x0
 800c0d4: d008         	beq	0x800c0e8 <dma_stm32_configure+0x7b4> @ imm = #0x10
; 		LL_DMA_EnableIT_HT(dma, dma_stm32_id_to_stream(id));
 800c0d6: 68b8         	ldr	r0, [r7, #0x8]
 800c0d8: f000 f9ae    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #0x35c
 800c0dc: 4603         	mov	r3, r0
 800c0de: 4619         	mov	r1, r3
 800c0e0: f8d7 00c8    	ldr.w	r0, [r7, #0xc8]
 800c0e4: f7ff f996    	bl	0x800b414 <LL_DMA_EnableIT_HT> @ imm = #-0xcd4
; 	if (DMA_InitStruct.FIFOMode == LL_DMA_FIFOMODE_ENABLE) {
 800c0e8: 6bfb         	ldr	r3, [r7, #0x3c]
 800c0ea: 2b04         	cmp	r3, #0x4
 800c0ec: d112         	bne	0x800c114 <dma_stm32_configure+0x7e0> @ imm = #0x24
; 		LL_DMA_EnableFifoMode(dma, dma_stm32_id_to_stream(id));
 800c0ee: 68b8         	ldr	r0, [r7, #0x8]
 800c0f0: f000 f9a2    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #0x344
 800c0f4: 4603         	mov	r3, r0
 800c0f6: 4619         	mov	r1, r3
 800c0f8: f8d7 00c8    	ldr.w	r0, [r7, #0xc8]
 800c0fc: f7ff f934    	bl	0x800b368 <LL_DMA_EnableFifoMode> @ imm = #-0xd98
; 		LL_DMA_EnableIT_FE(dma, dma_stm32_id_to_stream(id));
 800c100: 68b8         	ldr	r0, [r7, #0x8]
 800c102: f000 f999    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #0x332
 800c106: 4603         	mov	r3, r0
 800c108: 4619         	mov	r1, r3
 800c10a: f8d7 00c8    	ldr.w	r0, [r7, #0xc8]
 800c10e: f7ff f9c5    	bl	0x800b49c <LL_DMA_EnableIT_FE> @ imm = #-0xc76
 800c112: e011         	b	0x800c138 <dma_stm32_configure+0x804> @ imm = #0x22
; 		LL_DMA_DisableFifoMode(dma, dma_stm32_id_to_stream(id));
 800c114: 68b8         	ldr	r0, [r7, #0x8]
 800c116: f000 f98f    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #0x31e
 800c11a: 4603         	mov	r3, r0
 800c11c: 4619         	mov	r1, r3
 800c11e: f8d7 00c8    	ldr.w	r0, [r7, #0xc8]
 800c122: f7ff f8ff    	bl	0x800b324 <LL_DMA_DisableFifoMode> @ imm = #-0xe02
; 		LL_DMA_DisableIT_FE(dma, dma_stm32_id_to_stream(id));
 800c126: 68b8         	ldr	r0, [r7, #0x8]
 800c128: f000 f986    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #0x30c
 800c12c: 4603         	mov	r3, r0
 800c12e: 4619         	mov	r1, r3
 800c130: f8d7 00c8    	ldr.w	r0, [r7, #0xc8]
 800c134: f7ff f9f6    	bl	0x800b524 <LL_DMA_DisableIT_FE> @ imm = #-0xc14
; 	return ret;
 800c138: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
; }
 800c13c: 4618         	mov	r0, r3
 800c13e: 37d8         	adds	r7, #0xd8
 800c140: 46bd         	mov	sp, r7
 800c142: bd80         	pop	{r7, pc}

0800c144 <$d>:
 800c144: c8 06 00 24  	.word	0x240006c8
 800c148: d0 d1 02 08  	.word	0x0802d1d0
 800c14c: 8c b5 02 08  	.word	0x0802b58c
 800c150: b0 b5 02 08  	.word	0x0802b5b0
 800c154: 5c d1 02 08  	.word	0x0802d15c
 800c158: 50 d1 02 08  	.word	0x0802d150

0800c15c <dma_stm32_init>:
; {
 800c15c: b580         	push	{r7, lr}
 800c15e: b08e         	sub	sp, #0x38
 800c160: af04         	add	r7, sp, #0x10
 800c162: 6078         	str	r0, [r7, #0x4]
; 	const struct dma_stm32_config *config = dev->config;
 800c164: 687b         	ldr	r3, [r7, #0x4]
 800c166: 685b         	ldr	r3, [r3, #0x4]
 800c168: 623b         	str	r3, [r7, #0x20]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800c16a: 4b40         	ldr	r3, [pc, #0x100]        @ 0x800c26c <dma_stm32_init+0x110>
 800c16c: 61fb         	str	r3, [r7, #0x1c]
; 	if (!device_is_ready(clk)) {
 800c16e: 69f8         	ldr	r0, [r7, #0x1c]
 800c170: f013 f937    	bl	0x801f3e2 <device_is_ready> @ imm = #0x1326e
 800c174: 4603         	mov	r3, r0
 800c176: f083 0301    	eor	r3, r3, #0x1
 800c17a: b2db         	uxtb	r3, r3
 800c17c: 2b00         	cmp	r3, #0x0
 800c17e: d01c         	beq	0x800c1ba <dma_stm32_init+0x5e> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 800c180: 2303         	movs	r3, #0x3
 800c182: 2b00         	cmp	r3, #0x0
 800c184: d016         	beq	0x800c1b4 <dma_stm32_init+0x58> @ imm = #0x2c
 800c186: 2301         	movs	r3, #0x1
 800c188: 74fb         	strb	r3, [r7, #0x13]
 800c18a: 7cfb         	ldrb	r3, [r7, #0x13]
 800c18c: f083 0301    	eor	r3, r3, #0x1
 800c190: b2db         	uxtb	r3, r3
 800c192: 2b00         	cmp	r3, #0x0
 800c194: d10e         	bne	0x800c1b4 <dma_stm32_init+0x58> @ imm = #0x1c
 800c196: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800c270 <dma_stm32_init+0x114>
 800c198: 6819         	ldr	r1, [r3]
 800c19a: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800c274 <dma_stm32_init+0x118>
 800c19c: 9302         	str	r3, [sp, #0x8]
 800c19e: 2300         	movs	r3, #0x0
 800c1a0: 9301         	str	r3, [sp, #0x4]
 800c1a2: 2300         	movs	r3, #0x0
 800c1a4: 9300         	str	r3, [sp]
 800c1a6: 2300         	movs	r3, #0x0
 800c1a8: 2201         	movs	r2, #0x1
 800c1aa: 2000         	movs	r0, #0x0
 800c1ac: f013 f945    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x1328a
 800c1b0: 2300         	movs	r3, #0x0
 800c1b2: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800c1b4: f06f 0312    	mvn	r3, #0x12
 800c1b8: e053         	b	0x800c262 <dma_stm32_init+0x106> @ imm = #0xa6
; 		(clock_control_subsys_t) &config->pclken) != 0) {
 800c1ba: 6a3b         	ldr	r3, [r7, #0x20]
; 	if (clock_control_on(clk,
 800c1bc: 4619         	mov	r1, r3
 800c1be: 69f8         	ldr	r0, [r7, #0x1c]
 800c1c0: f013 f929    	bl	0x801f416 <clock_control_on> @ imm = #0x13252
 800c1c4: 4603         	mov	r3, r0
 800c1c6: 2b00         	cmp	r3, #0x0
 800c1c8: d01c         	beq	0x800c204 <dma_stm32_init+0xa8> @ imm = #0x38
; 		LOG_ERR("clock op failed\n");
 800c1ca: 2303         	movs	r3, #0x3
 800c1cc: 2b00         	cmp	r3, #0x0
 800c1ce: d016         	beq	0x800c1fe <dma_stm32_init+0xa2> @ imm = #0x2c
 800c1d0: 2301         	movs	r3, #0x1
 800c1d2: 76fb         	strb	r3, [r7, #0x1b]
 800c1d4: 7efb         	ldrb	r3, [r7, #0x1b]
 800c1d6: f083 0301    	eor	r3, r3, #0x1
 800c1da: b2db         	uxtb	r3, r3
 800c1dc: 2b00         	cmp	r3, #0x0
 800c1de: d10e         	bne	0x800c1fe <dma_stm32_init+0xa2> @ imm = #0x1c
 800c1e0: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800c270 <dma_stm32_init+0x114>
 800c1e2: 6819         	ldr	r1, [r3]
 800c1e4: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800c278 <dma_stm32_init+0x11c>
 800c1e6: 9302         	str	r3, [sp, #0x8]
 800c1e8: 2300         	movs	r3, #0x0
 800c1ea: 9301         	str	r3, [sp, #0x4]
 800c1ec: 2300         	movs	r3, #0x0
 800c1ee: 9300         	str	r3, [sp]
 800c1f0: 2300         	movs	r3, #0x0
 800c1f2: 2201         	movs	r2, #0x1
 800c1f4: 2000         	movs	r0, #0x0
 800c1f6: f013 f920    	bl	0x801f43a <z_log_msg_runtime_create> @ imm = #0x13240
 800c1fa: 2300         	movs	r3, #0x0
 800c1fc: 617b         	str	r3, [r7, #0x14]
; 		return -EIO;
 800c1fe: f06f 0304    	mvn	r3, #0x4
 800c202: e02e         	b	0x800c262 <dma_stm32_init+0x106> @ imm = #0x5c
; 	config->config_irq(dev);
 800c204: 6a3b         	ldr	r3, [r7, #0x20]
 800c206: 689b         	ldr	r3, [r3, #0x8]
 800c208: 6878         	ldr	r0, [r7, #0x4]
 800c20a: 4798         	blx	r3
; 	for (uint32_t i = 0; i < config->max_streams; i++) {
 800c20c: 2300         	movs	r3, #0x0
 800c20e: 627b         	str	r3, [r7, #0x24]
 800c210: e015         	b	0x800c23e <dma_stm32_init+0xe2> @ imm = #0x2a
; 		config->streams[i].busy = false;
 800c212: 6a3b         	ldr	r3, [r7, #0x20]
 800c214: 69da         	ldr	r2, [r3, #0x1c]
 800c216: 6a7b         	ldr	r3, [r7, #0x24]
 800c218: 015b         	lsls	r3, r3, #0x5
 800c21a: 4413         	add	r3, r2
 800c21c: 2200         	movs	r2, #0x0
 800c21e: 729a         	strb	r2, [r3, #0xa]
; 		config->streams[i].mux_channel = i + config->offset;
 800c220: 6a3b         	ldr	r3, [r7, #0x20]
 800c222: 7e1b         	ldrb	r3, [r3, #0x18]
 800c224: 461a         	mov	r2, r3
 800c226: 6a7b         	ldr	r3, [r7, #0x24]
 800c228: 18d1         	adds	r1, r2, r3
 800c22a: 6a3b         	ldr	r3, [r7, #0x20]
 800c22c: 69da         	ldr	r2, [r3, #0x1c]
 800c22e: 6a7b         	ldr	r3, [r7, #0x24]
 800c230: 015b         	lsls	r3, r3, #0x5
 800c232: 4413         	add	r3, r2
 800c234: 460a         	mov	r2, r1
 800c236: 605a         	str	r2, [r3, #0x4]
; 	for (uint32_t i = 0; i < config->max_streams; i++) {
 800c238: 6a7b         	ldr	r3, [r7, #0x24]
 800c23a: 3301         	adds	r3, #0x1
 800c23c: 627b         	str	r3, [r7, #0x24]
 800c23e: 6a3b         	ldr	r3, [r7, #0x20]
 800c240: 695b         	ldr	r3, [r3, #0x14]
 800c242: 6a7a         	ldr	r2, [r7, #0x24]
 800c244: 429a         	cmp	r2, r3
 800c246: d3e4         	blo	0x800c212 <dma_stm32_init+0xb6> @ imm = #-0x38
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.magic = 0;
 800c248: 687b         	ldr	r3, [r7, #0x4]
 800c24a: 691b         	ldr	r3, [r3, #0x10]
 800c24c: 2200         	movs	r2, #0x0
 800c24e: 601a         	str	r2, [r3]
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.dma_channels = 0;
 800c250: 687b         	ldr	r3, [r7, #0x4]
 800c252: 691b         	ldr	r3, [r3, #0x10]
 800c254: 2200         	movs	r2, #0x0
 800c256: 605a         	str	r2, [r3, #0x4]
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.atomic = 0;
 800c258: 687b         	ldr	r3, [r7, #0x4]
 800c25a: 691b         	ldr	r3, [r3, #0x10]
 800c25c: 2200         	movs	r2, #0x0
 800c25e: 609a         	str	r2, [r3, #0x8]
; 	return 0;
 800c260: 2300         	movs	r3, #0x0
; }
 800c262: 4618         	mov	r0, r3
 800c264: 3728         	adds	r7, #0x28
 800c266: 46bd         	mov	sp, r7
 800c268: bd80         	pop	{r7, pc}
 800c26a: bf00         	nop

0800c26c <$d>:
 800c26c: c0 96 02 08  	.word	0x080296c0
 800c270: c8 06 00 24  	.word	0x240006c8
 800c274: d8 b5 02 08  	.word	0x0802b5d8
 800c278: f8 b5 02 08  	.word	0x0802b5f8

0800c27c <LL_DMA_EnableStream>:
; {
 800c27c: b480         	push	{r7}
 800c27e: b085         	sub	sp, #0x14
 800c280: af00         	add	r7, sp, #0x0
 800c282: 6078         	str	r0, [r7, #0x4]
 800c284: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800c286: 687b         	ldr	r3, [r7, #0x4]
 800c288: 60fb         	str	r3, [r7, #0xc]
;   SET_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_EN);
 800c28a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800c2bc <LL_DMA_EnableStream+0x40>
 800c28c: 683b         	ldr	r3, [r7]
 800c28e: 4413         	add	r3, r2
 800c290: 781b         	ldrb	r3, [r3]
 800c292: 461a         	mov	r2, r3
 800c294: 68fb         	ldr	r3, [r7, #0xc]
 800c296: 4413         	add	r3, r2
 800c298: 681b         	ldr	r3, [r3]
 800c29a: 4908         	ldr	r1, [pc, #0x20]         @ 0x800c2bc <LL_DMA_EnableStream+0x40>
 800c29c: 683a         	ldr	r2, [r7]
 800c29e: 440a         	add	r2, r1
 800c2a0: 7812         	ldrb	r2, [r2]
 800c2a2: 4611         	mov	r1, r2
 800c2a4: 68fa         	ldr	r2, [r7, #0xc]
 800c2a6: 440a         	add	r2, r1
 800c2a8: f043 0301    	orr	r3, r3, #0x1
 800c2ac: 6013         	str	r3, [r2]
; }
 800c2ae: bf00         	nop
 800c2b0: 3714         	adds	r7, #0x14
 800c2b2: 46bd         	mov	sp, r7
 800c2b4: f85d 7b04    	ldr	r7, [sp], #4
 800c2b8: 4770         	bx	lr
 800c2ba: bf00         	nop

0800c2bc <$d>:
 800c2bc: e4 d1 02 08  	.word	0x0802d1e4

0800c2c0 <LL_DMA_DisableStream>:
; {
 800c2c0: b480         	push	{r7}
 800c2c2: b085         	sub	sp, #0x14
 800c2c4: af00         	add	r7, sp, #0x0
 800c2c6: 6078         	str	r0, [r7, #0x4]
 800c2c8: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800c2ca: 687b         	ldr	r3, [r7, #0x4]
 800c2cc: 60fb         	str	r3, [r7, #0xc]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_EN);
 800c2ce: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800c300 <LL_DMA_DisableStream+0x40>
 800c2d0: 683b         	ldr	r3, [r7]
 800c2d2: 4413         	add	r3, r2
 800c2d4: 781b         	ldrb	r3, [r3]
 800c2d6: 461a         	mov	r2, r3
 800c2d8: 68fb         	ldr	r3, [r7, #0xc]
 800c2da: 4413         	add	r3, r2
 800c2dc: 681b         	ldr	r3, [r3]
 800c2de: 4908         	ldr	r1, [pc, #0x20]         @ 0x800c300 <LL_DMA_DisableStream+0x40>
 800c2e0: 683a         	ldr	r2, [r7]
 800c2e2: 440a         	add	r2, r1
 800c2e4: 7812         	ldrb	r2, [r2]
 800c2e6: 4611         	mov	r1, r2
 800c2e8: 68fa         	ldr	r2, [r7, #0xc]
 800c2ea: 440a         	add	r2, r1
 800c2ec: f023 0301    	bic	r3, r3, #0x1
 800c2f0: 6013         	str	r3, [r2]
; }
 800c2f2: bf00         	nop
 800c2f4: 3714         	adds	r7, #0x14
 800c2f6: 46bd         	mov	sp, r7
 800c2f8: f85d 7b04    	ldr	r7, [sp], #4
 800c2fc: 4770         	bx	lr
 800c2fe: bf00         	nop

0800c300 <$d>:
 800c300: e4 d1 02 08  	.word	0x0802d1e4

0800c304 <LL_DMA_IsEnabledStream>:
; {
 800c304: b480         	push	{r7}
 800c306: b085         	sub	sp, #0x14
 800c308: af00         	add	r7, sp, #0x0
 800c30a: 6078         	str	r0, [r7, #0x4]
 800c30c: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800c30e: 687b         	ldr	r3, [r7, #0x4]
 800c310: 60fb         	str	r3, [r7, #0xc]
;   return ((READ_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_EN) == (DMA_SxCR_EN)) ? 1UL : 0UL);
 800c312: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800c33c <LL_DMA_IsEnabledStream+0x38>
 800c314: 683b         	ldr	r3, [r7]
 800c316: 4413         	add	r3, r2
 800c318: 781b         	ldrb	r3, [r3]
 800c31a: 461a         	mov	r2, r3
 800c31c: 68fb         	ldr	r3, [r7, #0xc]
 800c31e: 4413         	add	r3, r2
 800c320: 681b         	ldr	r3, [r3]
 800c322: f003 0301    	and	r3, r3, #0x1
 800c326: 2b01         	cmp	r3, #0x1
 800c328: d101         	bne	0x800c32e <LL_DMA_IsEnabledStream+0x2a> @ imm = #0x2
 800c32a: 2301         	movs	r3, #0x1
 800c32c: e000         	b	0x800c330 <LL_DMA_IsEnabledStream+0x2c> @ imm = #0x0
 800c32e: 2300         	movs	r3, #0x0
; }
 800c330: 4618         	mov	r0, r3
 800c332: 3714         	adds	r7, #0x14
 800c334: 46bd         	mov	sp, r7
 800c336: f85d 7b04    	ldr	r7, [sp], #4
 800c33a: 4770         	bx	lr

0800c33c <$d>:
 800c33c: e4 d1 02 08  	.word	0x0802d1e4

0800c340 <LL_DMA_DisableIT_FE>:
; {
 800c340: b480         	push	{r7}
 800c342: b085         	sub	sp, #0x14
 800c344: af00         	add	r7, sp, #0x0
 800c346: 6078         	str	r0, [r7, #0x4]
 800c348: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800c34a: 687b         	ldr	r3, [r7, #0x4]
 800c34c: 60fb         	str	r3, [r7, #0xc]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->FCR, DMA_SxFCR_FEIE);
 800c34e: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800c380 <LL_DMA_DisableIT_FE+0x40>
 800c350: 683b         	ldr	r3, [r7]
 800c352: 4413         	add	r3, r2
 800c354: 781b         	ldrb	r3, [r3]
 800c356: 461a         	mov	r2, r3
 800c358: 68fb         	ldr	r3, [r7, #0xc]
 800c35a: 4413         	add	r3, r2
 800c35c: 695b         	ldr	r3, [r3, #0x14]
 800c35e: 4908         	ldr	r1, [pc, #0x20]         @ 0x800c380 <LL_DMA_DisableIT_FE+0x40>
 800c360: 683a         	ldr	r2, [r7]
 800c362: 440a         	add	r2, r1
 800c364: 7812         	ldrb	r2, [r2]
 800c366: 4611         	mov	r1, r2
 800c368: 68fa         	ldr	r2, [r7, #0xc]
 800c36a: 440a         	add	r2, r1
 800c36c: f023 0380    	bic	r3, r3, #0x80
 800c370: 6153         	str	r3, [r2, #0x14]
; }
 800c372: bf00         	nop
 800c374: 3714         	adds	r7, #0x14
 800c376: 46bd         	mov	sp, r7
 800c378: f85d 7b04    	ldr	r7, [sp], #4
 800c37c: 4770         	bx	lr
 800c37e: bf00         	nop

0800c380 <$d>:
 800c380: e4 d1 02 08  	.word	0x0802d1e4

0800c384 <LL_DMA_IsEnabledIT_HT>:
; {
 800c384: b480         	push	{r7}
 800c386: b085         	sub	sp, #0x14
 800c388: af00         	add	r7, sp, #0x0
 800c38a: 6078         	str	r0, [r7, #0x4]
 800c38c: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800c38e: 687b         	ldr	r3, [r7, #0x4]
 800c390: 60fb         	str	r3, [r7, #0xc]
;   return ((READ_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_HTIE) == DMA_SxCR_HTIE) ? 1UL : 0UL);
 800c392: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800c3bc <LL_DMA_IsEnabledIT_HT+0x38>
 800c394: 683b         	ldr	r3, [r7]
 800c396: 4413         	add	r3, r2
 800c398: 781b         	ldrb	r3, [r3]
 800c39a: 461a         	mov	r2, r3
 800c39c: 68fb         	ldr	r3, [r7, #0xc]
 800c39e: 4413         	add	r3, r2
 800c3a0: 681b         	ldr	r3, [r3]
 800c3a2: f003 0308    	and	r3, r3, #0x8
 800c3a6: 2b08         	cmp	r3, #0x8
 800c3a8: d101         	bne	0x800c3ae <LL_DMA_IsEnabledIT_HT+0x2a> @ imm = #0x2
 800c3aa: 2301         	movs	r3, #0x1
 800c3ac: e000         	b	0x800c3b0 <LL_DMA_IsEnabledIT_HT+0x2c> @ imm = #0x0
 800c3ae: 2300         	movs	r3, #0x0
; }
 800c3b0: 4618         	mov	r0, r3
 800c3b2: 3714         	adds	r7, #0x14
 800c3b4: 46bd         	mov	sp, r7
 800c3b6: f85d 7b04    	ldr	r7, [sp], #4
 800c3ba: 4770         	bx	lr

0800c3bc <$d>:
 800c3bc: e4 d1 02 08  	.word	0x0802d1e4

0800c3c0 <LL_DMA_IsEnabledIT_TC>:
; {
 800c3c0: b480         	push	{r7}
 800c3c2: b085         	sub	sp, #0x14
 800c3c4: af00         	add	r7, sp, #0x0
 800c3c6: 6078         	str	r0, [r7, #0x4]
 800c3c8: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800c3ca: 687b         	ldr	r3, [r7, #0x4]
 800c3cc: 60fb         	str	r3, [r7, #0xc]
;   return ((READ_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_TCIE) == DMA_SxCR_TCIE) ? 1UL : 0UL);
 800c3ce: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800c3f8 <LL_DMA_IsEnabledIT_TC+0x38>
 800c3d0: 683b         	ldr	r3, [r7]
 800c3d2: 4413         	add	r3, r2
 800c3d4: 781b         	ldrb	r3, [r3]
 800c3d6: 461a         	mov	r2, r3
 800c3d8: 68fb         	ldr	r3, [r7, #0xc]
 800c3da: 4413         	add	r3, r2
 800c3dc: 681b         	ldr	r3, [r3]
 800c3de: f003 0310    	and	r3, r3, #0x10
 800c3e2: 2b10         	cmp	r3, #0x10
 800c3e4: d101         	bne	0x800c3ea <LL_DMA_IsEnabledIT_TC+0x2a> @ imm = #0x2
 800c3e6: 2301         	movs	r3, #0x1
 800c3e8: e000         	b	0x800c3ec <LL_DMA_IsEnabledIT_TC+0x2c> @ imm = #0x0
 800c3ea: 2300         	movs	r3, #0x0
; }
 800c3ec: 4618         	mov	r0, r3
 800c3ee: 3714         	adds	r7, #0x14
 800c3f0: 46bd         	mov	sp, r7
 800c3f2: f85d 7b04    	ldr	r7, [sp], #4
 800c3f6: 4770         	bx	lr

0800c3f8 <$d>:
 800c3f8: e4 d1 02 08  	.word	0x0802d1e4

0800c3fc <LL_DMA_IsEnabledIT_FE>:
; {
 800c3fc: b480         	push	{r7}
 800c3fe: b085         	sub	sp, #0x14
 800c400: af00         	add	r7, sp, #0x0
 800c402: 6078         	str	r0, [r7, #0x4]
 800c404: 6039         	str	r1, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 800c406: 687b         	ldr	r3, [r7, #0x4]
 800c408: 60fb         	str	r3, [r7, #0xc]
;   return ((READ_BIT(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->FCR, DMA_SxFCR_FEIE) == DMA_SxFCR_FEIE) ? 1UL : 0UL);
 800c40a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800c434 <LL_DMA_IsEnabledIT_FE+0x38>
 800c40c: 683b         	ldr	r3, [r7]
 800c40e: 4413         	add	r3, r2
 800c410: 781b         	ldrb	r3, [r3]
 800c412: 461a         	mov	r2, r3
 800c414: 68fb         	ldr	r3, [r7, #0xc]
 800c416: 4413         	add	r3, r2
 800c418: 695b         	ldr	r3, [r3, #0x14]
 800c41a: f003 0380    	and	r3, r3, #0x80
 800c41e: 2b80         	cmp	r3, #0x80
 800c420: d101         	bne	0x800c426 <LL_DMA_IsEnabledIT_FE+0x2a> @ imm = #0x2
 800c422: 2301         	movs	r3, #0x1
 800c424: e000         	b	0x800c428 <LL_DMA_IsEnabledIT_FE+0x2c> @ imm = #0x0
 800c426: 2300         	movs	r3, #0x0
; }
 800c428: 4618         	mov	r0, r3
 800c42a: 3714         	adds	r7, #0x14
 800c42c: 46bd         	mov	sp, r7
 800c42e: f85d 7b04    	ldr	r7, [sp], #4
 800c432: 4770         	bx	lr

0800c434 <$d>:
 800c434: e4 d1 02 08  	.word	0x0802d1e4

0800c438 <dma_stm32_id_to_stream>:
; {
 800c438: b480         	push	{r7}
 800c43a: b083         	sub	sp, #0xc
 800c43c: af00         	add	r7, sp, #0x0
 800c43e: 6078         	str	r0, [r7, #0x4]
; 	return stream_nr[id];
 800c440: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800c454 <dma_stm32_id_to_stream+0x1c>
 800c442: 687b         	ldr	r3, [r7, #0x4]
 800c444: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 800c448: 4618         	mov	r0, r3
 800c44a: 370c         	adds	r7, #0xc
 800c44c: 46bd         	mov	sp, r7
 800c44e: f85d 7b04    	ldr	r7, [sp], #4
 800c452: 4770         	bx	lr

0800c454 <$d>:
 800c454: ec d1 02 08  	.word	0x0802d1ec

0800c458 <dma_stm32_clear_ht>:
; {
 800c458: b580         	push	{r7, lr}
 800c45a: b082         	sub	sp, #0x8
 800c45c: af00         	add	r7, sp, #0x0
 800c45e: 6078         	str	r0, [r7, #0x4]
 800c460: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800c462: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800c478 <dma_stm32_clear_ht+0x20>
 800c464: 683b         	ldr	r3, [r7]
 800c466: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c46a: 6878         	ldr	r0, [r7, #0x4]
 800c46c: 4798         	blx	r3
; }
 800c46e: bf00         	nop
 800c470: 3708         	adds	r7, #0x8
 800c472: 46bd         	mov	sp, r7
 800c474: bd80         	pop	{r7, pc}
 800c476: bf00         	nop

0800c478 <$d>:
 800c478: 0c d2 02 08  	.word	0x0802d20c

0800c47c <dma_stm32_clear_tc>:
; {
 800c47c: b580         	push	{r7, lr}
 800c47e: b082         	sub	sp, #0x8
 800c480: af00         	add	r7, sp, #0x0
 800c482: 6078         	str	r0, [r7, #0x4]
 800c484: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800c486: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800c49c <dma_stm32_clear_tc+0x20>
 800c488: 683b         	ldr	r3, [r7]
 800c48a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c48e: 6878         	ldr	r0, [r7, #0x4]
 800c490: 4798         	blx	r3
; }
 800c492: bf00         	nop
 800c494: 3708         	adds	r7, #0x8
 800c496: 46bd         	mov	sp, r7
 800c498: bd80         	pop	{r7, pc}
 800c49a: bf00         	nop

0800c49c <$d>:
 800c49c: 2c d2 02 08  	.word	0x0802d22c

0800c4a0 <dma_stm32_is_ht_active>:
; {
 800c4a0: b580         	push	{r7, lr}
 800c4a2: b082         	sub	sp, #0x8
 800c4a4: af00         	add	r7, sp, #0x0
 800c4a6: 6078         	str	r0, [r7, #0x4]
 800c4a8: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800c4aa: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800c4cc <dma_stm32_is_ht_active+0x2c>
 800c4ac: 683b         	ldr	r3, [r7]
 800c4ae: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c4b2: 6878         	ldr	r0, [r7, #0x4]
 800c4b4: 4798         	blx	r3
 800c4b6: 4603         	mov	r3, r0
 800c4b8: 2b00         	cmp	r3, #0x0
 800c4ba: bf14         	ite	ne
 800c4bc: 2301         	movne	r3, #0x1
 800c4be: 2300         	moveq	r3, #0x0
 800c4c0: b2db         	uxtb	r3, r3
; }
 800c4c2: 4618         	mov	r0, r3
 800c4c4: 3708         	adds	r7, #0x8
 800c4c6: 46bd         	mov	sp, r7
 800c4c8: bd80         	pop	{r7, pc}
 800c4ca: bf00         	nop

0800c4cc <$d>:
 800c4cc: 4c d2 02 08  	.word	0x0802d24c

0800c4d0 <dma_stm32_is_tc_active>:
; {
 800c4d0: b580         	push	{r7, lr}
 800c4d2: b082         	sub	sp, #0x8
 800c4d4: af00         	add	r7, sp, #0x0
 800c4d6: 6078         	str	r0, [r7, #0x4]
 800c4d8: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800c4da: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800c4fc <dma_stm32_is_tc_active+0x2c>
 800c4dc: 683b         	ldr	r3, [r7]
 800c4de: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c4e2: 6878         	ldr	r0, [r7, #0x4]
 800c4e4: 4798         	blx	r3
 800c4e6: 4603         	mov	r3, r0
 800c4e8: 2b00         	cmp	r3, #0x0
 800c4ea: bf14         	ite	ne
 800c4ec: 2301         	movne	r3, #0x1
 800c4ee: 2300         	moveq	r3, #0x0
 800c4f0: b2db         	uxtb	r3, r3
; }
 800c4f2: 4618         	mov	r0, r3
 800c4f4: 3708         	adds	r7, #0x8
 800c4f6: 46bd         	mov	sp, r7
 800c4f8: bd80         	pop	{r7, pc}
 800c4fa: bf00         	nop

0800c4fc <$d>:
 800c4fc: 6c d2 02 08  	.word	0x0802d26c

0800c500 <dma_stm32_clear_te>:
; {
 800c500: b580         	push	{r7, lr}
 800c502: b082         	sub	sp, #0x8
 800c504: af00         	add	r7, sp, #0x0
 800c506: 6078         	str	r0, [r7, #0x4]
 800c508: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800c50a: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800c520 <dma_stm32_clear_te+0x20>
 800c50c: 683b         	ldr	r3, [r7]
 800c50e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c512: 6878         	ldr	r0, [r7, #0x4]
 800c514: 4798         	blx	r3
; }
 800c516: bf00         	nop
 800c518: 3708         	adds	r7, #0x8
 800c51a: 46bd         	mov	sp, r7
 800c51c: bd80         	pop	{r7, pc}
 800c51e: bf00         	nop

0800c520 <$d>:
 800c520: 8c d2 02 08  	.word	0x0802d28c

0800c524 <dma_stm32_clear_dme>:
; {
 800c524: b580         	push	{r7, lr}
 800c526: b082         	sub	sp, #0x8
 800c528: af00         	add	r7, sp, #0x0
 800c52a: 6078         	str	r0, [r7, #0x4]
 800c52c: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800c52e: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800c544 <dma_stm32_clear_dme+0x20>
 800c530: 683b         	ldr	r3, [r7]
 800c532: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c536: 6878         	ldr	r0, [r7, #0x4]
 800c538: 4798         	blx	r3
; }
 800c53a: bf00         	nop
 800c53c: 3708         	adds	r7, #0x8
 800c53e: 46bd         	mov	sp, r7
 800c540: bd80         	pop	{r7, pc}
 800c542: bf00         	nop

0800c544 <$d>:
 800c544: ac d2 02 08  	.word	0x0802d2ac

0800c548 <dma_stm32_clear_fe>:
; {
 800c548: b580         	push	{r7, lr}
 800c54a: b082         	sub	sp, #0x8
 800c54c: af00         	add	r7, sp, #0x0
 800c54e: 6078         	str	r0, [r7, #0x4]
 800c550: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800c552: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800c568 <dma_stm32_clear_fe+0x20>
 800c554: 683b         	ldr	r3, [r7]
 800c556: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c55a: 6878         	ldr	r0, [r7, #0x4]
 800c55c: 4798         	blx	r3
; }
 800c55e: bf00         	nop
 800c560: 3708         	adds	r7, #0x8
 800c562: 46bd         	mov	sp, r7
 800c564: bd80         	pop	{r7, pc}
 800c566: bf00         	nop

0800c568 <$d>:
 800c568: cc d2 02 08  	.word	0x0802d2cc

0800c56c <dma_stm32_is_te_active>:
; {
 800c56c: b580         	push	{r7, lr}
 800c56e: b082         	sub	sp, #0x8
 800c570: af00         	add	r7, sp, #0x0
 800c572: 6078         	str	r0, [r7, #0x4]
 800c574: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800c576: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800c598 <dma_stm32_is_te_active+0x2c>
 800c578: 683b         	ldr	r3, [r7]
 800c57a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c57e: 6878         	ldr	r0, [r7, #0x4]
 800c580: 4798         	blx	r3
 800c582: 4603         	mov	r3, r0
 800c584: 2b00         	cmp	r3, #0x0
 800c586: bf14         	ite	ne
 800c588: 2301         	movne	r3, #0x1
 800c58a: 2300         	moveq	r3, #0x0
 800c58c: b2db         	uxtb	r3, r3
; }
 800c58e: 4618         	mov	r0, r3
 800c590: 3708         	adds	r7, #0x8
 800c592: 46bd         	mov	sp, r7
 800c594: bd80         	pop	{r7, pc}
 800c596: bf00         	nop

0800c598 <$d>:
 800c598: ec d2 02 08  	.word	0x0802d2ec

0800c59c <dma_stm32_is_dme_active>:
; {
 800c59c: b580         	push	{r7, lr}
 800c59e: b082         	sub	sp, #0x8
 800c5a0: af00         	add	r7, sp, #0x0
 800c5a2: 6078         	str	r0, [r7, #0x4]
 800c5a4: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800c5a6: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800c5c8 <dma_stm32_is_dme_active+0x2c>
 800c5a8: 683b         	ldr	r3, [r7]
 800c5aa: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c5ae: 6878         	ldr	r0, [r7, #0x4]
 800c5b0: 4798         	blx	r3
 800c5b2: 4603         	mov	r3, r0
 800c5b4: 2b00         	cmp	r3, #0x0
 800c5b6: bf14         	ite	ne
 800c5b8: 2301         	movne	r3, #0x1
 800c5ba: 2300         	moveq	r3, #0x0
 800c5bc: b2db         	uxtb	r3, r3
; }
 800c5be: 4618         	mov	r0, r3
 800c5c0: 3708         	adds	r7, #0x8
 800c5c2: 46bd         	mov	sp, r7
 800c5c4: bd80         	pop	{r7, pc}
 800c5c6: bf00         	nop

0800c5c8 <$d>:
 800c5c8: 0c d3 02 08  	.word	0x0802d30c

0800c5cc <dma_stm32_is_fe_active>:
; {
 800c5cc: b580         	push	{r7, lr}
 800c5ce: b082         	sub	sp, #0x8
 800c5d0: af00         	add	r7, sp, #0x0
 800c5d2: 6078         	str	r0, [r7, #0x4]
 800c5d4: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800c5d6: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800c5f8 <dma_stm32_is_fe_active+0x2c>
 800c5d8: 683b         	ldr	r3, [r7]
 800c5da: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800c5de: 6878         	ldr	r0, [r7, #0x4]
 800c5e0: 4798         	blx	r3
 800c5e2: 4603         	mov	r3, r0
 800c5e4: 2b00         	cmp	r3, #0x0
 800c5e6: bf14         	ite	ne
 800c5e8: 2301         	movne	r3, #0x1
 800c5ea: 2300         	moveq	r3, #0x0
 800c5ec: b2db         	uxtb	r3, r3
; }
 800c5ee: 4618         	mov	r0, r3
 800c5f0: 3708         	adds	r7, #0x8
 800c5f2: 46bd         	mov	sp, r7
 800c5f4: bd80         	pop	{r7, pc}
 800c5f6: bf00         	nop

0800c5f8 <$d>:
 800c5f8: 2c d3 02 08  	.word	0x0802d32c

0800c5fc <stm32_dma_dump_stream_irq>:
; {
 800c5fc: b5f0         	push	{r4, r5, r6, r7, lr}
 800c5fe: b08f         	sub	sp, #0x3c
 800c600: af08         	add	r7, sp, #0x20
 800c602: 60f8         	str	r0, [r7, #0xc]
 800c604: 60b9         	str	r1, [r7, #0x8]
; 	LOG_INF("tc: %d, ht: %d, te: %d, dme: %d, fe: %d",
 800c606: 2303         	movs	r3, #0x3
 800c608: 2b02         	cmp	r3, #0x2
 800c60a: d93c         	bls	0x800c686 <stm32_dma_dump_stream_irq+0x8a> @ imm = #0x78
 800c60c: 2301         	movs	r3, #0x1
 800c60e: 74fb         	strb	r3, [r7, #0x13]
 800c610: 7cfb         	ldrb	r3, [r7, #0x13]
 800c612: f083 0301    	eor	r3, r3, #0x1
 800c616: b2db         	uxtb	r3, r3
 800c618: 2b00         	cmp	r3, #0x0
 800c61a: d134         	bne	0x800c686 <stm32_dma_dump_stream_irq+0x8a> @ imm = #0x68
 800c61c: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800c690 <stm32_dma_dump_stream_irq+0x94>
 800c61e: 681c         	ldr	r4, [r3]
 800c620: 68b9         	ldr	r1, [r7, #0x8]
 800c622: 68f8         	ldr	r0, [r7, #0xc]
 800c624: f7ff ff54    	bl	0x800c4d0 <dma_stm32_is_tc_active> @ imm = #-0x158
 800c628: 4603         	mov	r3, r0
 800c62a: 461d         	mov	r5, r3
 800c62c: 68b9         	ldr	r1, [r7, #0x8]
 800c62e: 68f8         	ldr	r0, [r7, #0xc]
 800c630: f7ff ff36    	bl	0x800c4a0 <dma_stm32_is_ht_active> @ imm = #-0x194
 800c634: 4603         	mov	r3, r0
 800c636: 461e         	mov	r6, r3
 800c638: 68b9         	ldr	r1, [r7, #0x8]
 800c63a: 68f8         	ldr	r0, [r7, #0xc]
 800c63c: f7ff ff96    	bl	0x800c56c <dma_stm32_is_te_active> @ imm = #-0xd4
 800c640: 4603         	mov	r3, r0
 800c642: 607b         	str	r3, [r7, #0x4]
 800c644: 68b9         	ldr	r1, [r7, #0x8]
 800c646: 68f8         	ldr	r0, [r7, #0xc]
 800c648: f7ff ffa8    	bl	0x800c59c <dma_stm32_is_dme_active> @ imm = #-0xb0
 800c64c: 4603         	mov	r3, r0
 800c64e: 603b         	str	r3, [r7]
 800c650: 68b9         	ldr	r1, [r7, #0x8]
 800c652: 68f8         	ldr	r0, [r7, #0xc]
 800c654: f7ff ffba    	bl	0x800c5cc <dma_stm32_is_fe_active> @ imm = #-0x8c
 800c658: 4603         	mov	r3, r0
 800c65a: 9307         	str	r3, [sp, #0x1c]
 800c65c: 683a         	ldr	r2, [r7]
 800c65e: 9206         	str	r2, [sp, #0x18]
 800c660: 687b         	ldr	r3, [r7, #0x4]
 800c662: 9305         	str	r3, [sp, #0x14]
 800c664: 9604         	str	r6, [sp, #0x10]
 800c666: 9503         	str	r5, [sp, #0xc]
 800c668: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800c694 <stm32_dma_dump_stream_irq+0x98>
 800c66a: 9302         	str	r3, [sp, #0x8]
 800c66c: 2300         	movs	r3, #0x0
 800c66e: 9301         	str	r3, [sp, #0x4]
 800c670: 2300         	movs	r3, #0x0
 800c672: 9300         	str	r3, [sp]
 800c674: 2300         	movs	r3, #0x0
 800c676: 2203         	movs	r2, #0x3
 800c678: 4621         	mov	r1, r4
 800c67a: 2000         	movs	r0, #0x0
 800c67c: f013 ff0b    	bl	0x8020496 <z_log_msg_runtime_create> @ imm = #0x13e16
 800c680: 2300         	movs	r3, #0x0
 800c682: 617b         	str	r3, [r7, #0x14]
; }
 800c684: bf00         	nop
 800c686: bf00         	nop
 800c688: 371c         	adds	r7, #0x1c
 800c68a: 46bd         	mov	sp, r7
 800c68c: bdf0         	pop	{r4, r5, r6, r7, pc}
 800c68e: bf00         	nop

0800c690 <$d>:
 800c690: cc 06 00 24  	.word	0x240006cc
 800c694: 3c b6 02 08  	.word	0x0802b63c

0800c698 <stm32_dma_is_unexpected_irq_happened>:
; {
 800c698: b580         	push	{r7, lr}
 800c69a: b088         	sub	sp, #0x20
 800c69c: af04         	add	r7, sp, #0x10
 800c69e: 6078         	str	r0, [r7, #0x4]
 800c6a0: 6039         	str	r1, [r7]
; 	if (LL_DMA_IsEnabledIT_FE(dma, dma_stm32_id_to_stream(id)) &&
 800c6a2: 6838         	ldr	r0, [r7]
 800c6a4: f7ff fec8    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x270
 800c6a8: 4603         	mov	r3, r0
 800c6aa: 4619         	mov	r1, r3
 800c6ac: 6878         	ldr	r0, [r7, #0x4]
 800c6ae: f7ff fea5    	bl	0x800c3fc <LL_DMA_IsEnabledIT_FE> @ imm = #-0x2b6
 800c6b2: 4603         	mov	r3, r0
 800c6b4: 2b00         	cmp	r3, #0x0
 800c6b6: d02a         	beq	0x800c70e <stm32_dma_is_unexpected_irq_happened+0x76> @ imm = #0x54
; 	    dma_stm32_is_fe_active(dma, id)) {
 800c6b8: 6839         	ldr	r1, [r7]
 800c6ba: 6878         	ldr	r0, [r7, #0x4]
 800c6bc: f7ff ff86    	bl	0x800c5cc <dma_stm32_is_fe_active> @ imm = #-0xf4
 800c6c0: 4603         	mov	r3, r0
; 	if (LL_DMA_IsEnabledIT_FE(dma, dma_stm32_id_to_stream(id)) &&
 800c6c2: 2b00         	cmp	r3, #0x0
 800c6c4: d023         	beq	0x800c70e <stm32_dma_is_unexpected_irq_happened+0x76> @ imm = #0x46
; 		LOG_ERR("FiFo error.");
 800c6c6: 2303         	movs	r3, #0x3
 800c6c8: 2b00         	cmp	r3, #0x0
 800c6ca: d016         	beq	0x800c6fa <stm32_dma_is_unexpected_irq_happened+0x62> @ imm = #0x2c
 800c6cc: 2301         	movs	r3, #0x1
 800c6ce: 73fb         	strb	r3, [r7, #0xf]
 800c6d0: 7bfb         	ldrb	r3, [r7, #0xf]
 800c6d2: f083 0301    	eor	r3, r3, #0x1
 800c6d6: b2db         	uxtb	r3, r3
 800c6d8: 2b00         	cmp	r3, #0x0
 800c6da: d10e         	bne	0x800c6fa <stm32_dma_is_unexpected_irq_happened+0x62> @ imm = #0x1c
 800c6dc: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800c718 <stm32_dma_is_unexpected_irq_happened+0x80>
 800c6de: 6819         	ldr	r1, [r3]
 800c6e0: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800c71c <stm32_dma_is_unexpected_irq_happened+0x84>
 800c6e2: 9302         	str	r3, [sp, #0x8]
 800c6e4: 2300         	movs	r3, #0x0
 800c6e6: 9301         	str	r3, [sp, #0x4]
 800c6e8: 2300         	movs	r3, #0x0
 800c6ea: 9300         	str	r3, [sp]
 800c6ec: 2300         	movs	r3, #0x0
 800c6ee: 2201         	movs	r2, #0x1
 800c6f0: 2000         	movs	r0, #0x0
 800c6f2: f013 fed0    	bl	0x8020496 <z_log_msg_runtime_create> @ imm = #0x13da0
 800c6f6: 2300         	movs	r3, #0x0
 800c6f8: 60bb         	str	r3, [r7, #0x8]
; 		stm32_dma_dump_stream_irq(dma, id);
 800c6fa: 6839         	ldr	r1, [r7]
 800c6fc: 6878         	ldr	r0, [r7, #0x4]
 800c6fe: f7ff ff7d    	bl	0x800c5fc <stm32_dma_dump_stream_irq> @ imm = #-0x106
; 		stm32_dma_clear_stream_irq(dma, id);
 800c702: 6839         	ldr	r1, [r7]
 800c704: 6878         	ldr	r0, [r7, #0x4]
 800c706: f013 ff26    	bl	0x8020556 <stm32_dma_clear_stream_irq> @ imm = #0x13e4c
; 		return true;
 800c70a: 2301         	movs	r3, #0x1
 800c70c: e000         	b	0x800c710 <stm32_dma_is_unexpected_irq_happened+0x78> @ imm = #0x0
; 	return false;
 800c70e: 2300         	movs	r3, #0x0
; }
 800c710: 4618         	mov	r0, r3
 800c712: 3710         	adds	r7, #0x10
 800c714: 46bd         	mov	sp, r7
 800c716: bd80         	pop	{r7, pc}

0800c718 <$d>:
 800c718: cc 06 00 24  	.word	0x240006cc
 800c71c: 64 b6 02 08  	.word	0x0802b664

0800c720 <stm32_dma_get_mburst>:
; {
 800c720: b580         	push	{r7, lr}
 800c722: b08a         	sub	sp, #0x28
 800c724: af04         	add	r7, sp, #0x10
 800c726: 6078         	str	r0, [r7, #0x4]
 800c728: 460b         	mov	r3, r1
 800c72a: 70fb         	strb	r3, [r7, #0x3]
; 	if (source_periph) {
 800c72c: 78fb         	ldrb	r3, [r7, #0x3]
 800c72e: 2b00         	cmp	r3, #0x0
 800c730: d003         	beq	0x800c73a <stm32_dma_get_mburst+0x1a> @ imm = #0x6
; 		memory_burst = config->dest_burst_length;
 800c732: 687b         	ldr	r3, [r7, #0x4]
 800c734: 895b         	ldrh	r3, [r3, #0xa]
 800c736: 617b         	str	r3, [r7, #0x14]
 800c738: e002         	b	0x800c740 <stm32_dma_get_mburst+0x20> @ imm = #0x4
; 		memory_burst = config->source_burst_length;
 800c73a: 687b         	ldr	r3, [r7, #0x4]
 800c73c: 891b         	ldrh	r3, [r3, #0x8]
 800c73e: 617b         	str	r3, [r7, #0x14]
; 	switch (memory_burst) {
 800c740: 697b         	ldr	r3, [r7, #0x14]
 800c742: 3b01         	subs	r3, #0x1
 800c744: 2b0f         	cmp	r3, #0xf
 800c746: d82e         	bhi	0x800c7a6 <stm32_dma_get_mburst+0x86> @ imm = #0x5c
 800c748: a201         	adr	r2, #4 <stm32_dma_get_mburst+0x2d>
 800c74a: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 800c74e: bf00         	nop

0800c750 <$d>:
 800c750: 91 c7 00 08  	.word	0x0800c791
 800c754: a7 c7 00 08  	.word	0x0800c7a7
 800c758: a7 c7 00 08  	.word	0x0800c7a7
 800c75c: 95 c7 00 08  	.word	0x0800c795
 800c760: a7 c7 00 08  	.word	0x0800c7a7
 800c764: a7 c7 00 08  	.word	0x0800c7a7
 800c768: a7 c7 00 08  	.word	0x0800c7a7
 800c76c: 9b c7 00 08  	.word	0x0800c79b
 800c770: a7 c7 00 08  	.word	0x0800c7a7
 800c774: a7 c7 00 08  	.word	0x0800c7a7
 800c778: a7 c7 00 08  	.word	0x0800c7a7
 800c77c: a7 c7 00 08  	.word	0x0800c7a7
 800c780: a7 c7 00 08  	.word	0x0800c7a7
 800c784: a7 c7 00 08  	.word	0x0800c7a7
 800c788: a7 c7 00 08  	.word	0x0800c7a7
 800c78c: a1 c7 00 08  	.word	0x0800c7a1

0800c790 <$t>:
; 		return LL_DMA_MBURST_SINGLE;
 800c790: 2300         	movs	r3, #0x0
 800c792: e023         	b	0x800c7dc <stm32_dma_get_mburst+0xbc> @ imm = #0x46
; 		return LL_DMA_MBURST_INC4;
 800c794: f44f 0300    	mov.w	r3, #0x800000
 800c798: e020         	b	0x800c7dc <stm32_dma_get_mburst+0xbc> @ imm = #0x40
; 		return LL_DMA_MBURST_INC8;
 800c79a: f04f 7380    	mov.w	r3, #0x1000000
 800c79e: e01d         	b	0x800c7dc <stm32_dma_get_mburst+0xbc> @ imm = #0x3a
; 		return LL_DMA_MBURST_INC16;
 800c7a0: f04f 73c0    	mov.w	r3, #0x1800000
 800c7a4: e01a         	b	0x800c7dc <stm32_dma_get_mburst+0xbc> @ imm = #0x34
; 		LOG_ERR("Memory burst size error,"
 800c7a6: 2303         	movs	r3, #0x3
 800c7a8: 2b00         	cmp	r3, #0x0
 800c7aa: d016         	beq	0x800c7da <stm32_dma_get_mburst+0xba> @ imm = #0x2c
 800c7ac: 2301         	movs	r3, #0x1
 800c7ae: 74fb         	strb	r3, [r7, #0x13]
 800c7b0: 7cfb         	ldrb	r3, [r7, #0x13]
 800c7b2: f083 0301    	eor	r3, r3, #0x1
 800c7b6: b2db         	uxtb	r3, r3
 800c7b8: 2b00         	cmp	r3, #0x0
 800c7ba: d10e         	bne	0x800c7da <stm32_dma_get_mburst+0xba> @ imm = #0x1c
 800c7bc: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800c7e4 <stm32_dma_get_mburst+0xc4>
 800c7be: 6819         	ldr	r1, [r3]
 800c7c0: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800c7e8 <stm32_dma_get_mburst+0xc8>
 800c7c2: 9302         	str	r3, [sp, #0x8]
 800c7c4: 2300         	movs	r3, #0x0
 800c7c6: 9301         	str	r3, [sp, #0x4]
 800c7c8: 2300         	movs	r3, #0x0
 800c7ca: 9300         	str	r3, [sp]
 800c7cc: 2300         	movs	r3, #0x0
 800c7ce: 2201         	movs	r2, #0x1
 800c7d0: 2000         	movs	r0, #0x0
 800c7d2: f013 fe60    	bl	0x8020496 <z_log_msg_runtime_create> @ imm = #0x13cc0
 800c7d6: 2300         	movs	r3, #0x0
 800c7d8: 60fb         	str	r3, [r7, #0xc]
; 		return LL_DMA_MBURST_SINGLE;
 800c7da: 2300         	movs	r3, #0x0
; }
 800c7dc: 4618         	mov	r0, r3
 800c7de: 3718         	adds	r7, #0x18
 800c7e0: 46bd         	mov	sp, r7
 800c7e2: bd80         	pop	{r7, pc}

0800c7e4 <$d>:
 800c7e4: cc 06 00 24  	.word	0x240006cc
 800c7e8: 70 b6 02 08  	.word	0x0802b670

0800c7ec <stm32_dma_get_pburst>:
; {
 800c7ec: b580         	push	{r7, lr}
 800c7ee: b08a         	sub	sp, #0x28
 800c7f0: af04         	add	r7, sp, #0x10
 800c7f2: 6078         	str	r0, [r7, #0x4]
 800c7f4: 460b         	mov	r3, r1
 800c7f6: 70fb         	strb	r3, [r7, #0x3]
; 	if (source_periph) {
 800c7f8: 78fb         	ldrb	r3, [r7, #0x3]
 800c7fa: 2b00         	cmp	r3, #0x0
 800c7fc: d003         	beq	0x800c806 <stm32_dma_get_pburst+0x1a> @ imm = #0x6
; 		periph_burst = config->source_burst_length;
 800c7fe: 687b         	ldr	r3, [r7, #0x4]
 800c800: 891b         	ldrh	r3, [r3, #0x8]
 800c802: 617b         	str	r3, [r7, #0x14]
 800c804: e002         	b	0x800c80c <stm32_dma_get_pburst+0x20> @ imm = #0x4
; 		periph_burst = config->dest_burst_length;
 800c806: 687b         	ldr	r3, [r7, #0x4]
 800c808: 895b         	ldrh	r3, [r3, #0xa]
 800c80a: 617b         	str	r3, [r7, #0x14]
; 	switch (periph_burst) {
 800c80c: 697b         	ldr	r3, [r7, #0x14]
 800c80e: 3b01         	subs	r3, #0x1
 800c810: 2b0f         	cmp	r3, #0xf
 800c812: d82e         	bhi	0x800c872 <stm32_dma_get_pburst+0x86> @ imm = #0x5c
 800c814: a201         	adr	r2, #4 <stm32_dma_get_pburst+0x2d>
 800c816: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 800c81a: bf00         	nop

0800c81c <$d>:
 800c81c: 5d c8 00 08  	.word	0x0800c85d
 800c820: 73 c8 00 08  	.word	0x0800c873
 800c824: 73 c8 00 08  	.word	0x0800c873
 800c828: 61 c8 00 08  	.word	0x0800c861
 800c82c: 73 c8 00 08  	.word	0x0800c873
 800c830: 73 c8 00 08  	.word	0x0800c873
 800c834: 73 c8 00 08  	.word	0x0800c873
 800c838: 67 c8 00 08  	.word	0x0800c867
 800c83c: 73 c8 00 08  	.word	0x0800c873
 800c840: 73 c8 00 08  	.word	0x0800c873
 800c844: 73 c8 00 08  	.word	0x0800c873
 800c848: 73 c8 00 08  	.word	0x0800c873
 800c84c: 73 c8 00 08  	.word	0x0800c873
 800c850: 73 c8 00 08  	.word	0x0800c873
 800c854: 73 c8 00 08  	.word	0x0800c873
 800c858: 6d c8 00 08  	.word	0x0800c86d

0800c85c <$t>:
; 		return LL_DMA_PBURST_SINGLE;
 800c85c: 2300         	movs	r3, #0x0
 800c85e: e023         	b	0x800c8a8 <stm32_dma_get_pburst+0xbc> @ imm = #0x46
; 		return LL_DMA_PBURST_INC4;
 800c860: f44f 1300    	mov.w	r3, #0x200000
 800c864: e020         	b	0x800c8a8 <stm32_dma_get_pburst+0xbc> @ imm = #0x40
; 		return LL_DMA_PBURST_INC8;
 800c866: f44f 0380    	mov.w	r3, #0x400000
 800c86a: e01d         	b	0x800c8a8 <stm32_dma_get_pburst+0xbc> @ imm = #0x3a
; 		return LL_DMA_PBURST_INC16;
 800c86c: f44f 03c0    	mov.w	r3, #0x600000
 800c870: e01a         	b	0x800c8a8 <stm32_dma_get_pburst+0xbc> @ imm = #0x34
; 		LOG_ERR("Peripheral burst size error,"
 800c872: 2303         	movs	r3, #0x3
 800c874: 2b00         	cmp	r3, #0x0
 800c876: d016         	beq	0x800c8a6 <stm32_dma_get_pburst+0xba> @ imm = #0x2c
 800c878: 2301         	movs	r3, #0x1
 800c87a: 74fb         	strb	r3, [r7, #0x13]
 800c87c: 7cfb         	ldrb	r3, [r7, #0x13]
 800c87e: f083 0301    	eor	r3, r3, #0x1
 800c882: b2db         	uxtb	r3, r3
 800c884: 2b00         	cmp	r3, #0x0
 800c886: d10e         	bne	0x800c8a6 <stm32_dma_get_pburst+0xba> @ imm = #0x1c
 800c888: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800c8b0 <stm32_dma_get_pburst+0xc4>
 800c88a: 6819         	ldr	r1, [r3]
 800c88c: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800c8b4 <stm32_dma_get_pburst+0xc8>
 800c88e: 9302         	str	r3, [sp, #0x8]
 800c890: 2300         	movs	r3, #0x0
 800c892: 9301         	str	r3, [sp, #0x4]
 800c894: 2300         	movs	r3, #0x0
 800c896: 9300         	str	r3, [sp]
 800c898: 2300         	movs	r3, #0x0
 800c89a: 2201         	movs	r2, #0x1
 800c89c: 2000         	movs	r0, #0x0
 800c89e: f013 fdfa    	bl	0x8020496 <z_log_msg_runtime_create> @ imm = #0x13bf4
 800c8a2: 2300         	movs	r3, #0x0
 800c8a4: 60fb         	str	r3, [r7, #0xc]
; 		return LL_DMA_PBURST_SINGLE;
 800c8a6: 2300         	movs	r3, #0x0
; }
 800c8a8: 4618         	mov	r0, r3
 800c8aa: 3718         	adds	r7, #0x18
 800c8ac: 46bd         	mov	sp, r7
 800c8ae: bd80         	pop	{r7, pc}

0800c8b0 <$d>:
 800c8b0: cc 06 00 24  	.word	0x240006cc
 800c8b4: a8 b6 02 08  	.word	0x0802b6a8

0800c8b8 <stm32_dma_get_fifo_threshold>:
; {
 800c8b8: b580         	push	{r7, lr}
 800c8ba: b088         	sub	sp, #0x20
 800c8bc: af04         	add	r7, sp, #0x10
 800c8be: 4603         	mov	r3, r0
 800c8c0: 80fb         	strh	r3, [r7, #0x6]
; 	switch (fifo_mode_control) {
 800c8c2: 88fb         	ldrh	r3, [r7, #0x6]
 800c8c4: 2b03         	cmp	r3, #0x3
 800c8c6: d813         	bhi	0x800c8f0 <stm32_dma_get_fifo_threshold+0x38> @ imm = #0x26
 800c8c8: a201         	adr	r2, #4 <stm32_dma_get_fifo_threshold+0x15>
 800c8ca: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 800c8ce: bf00         	nop

0800c8d0 <$d>:
 800c8d0: e1 c8 00 08  	.word	0x0800c8e1
 800c8d4: e5 c8 00 08  	.word	0x0800c8e5
 800c8d8: e9 c8 00 08  	.word	0x0800c8e9
 800c8dc: ed c8 00 08  	.word	0x0800c8ed

0800c8e0 <$t>:
; 		return LL_DMA_FIFOTHRESHOLD_1_4;
 800c8e0: 2300         	movs	r3, #0x0
 800c8e2: e020         	b	0x800c926 <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x40
; 		return LL_DMA_FIFOTHRESHOLD_1_2;
 800c8e4: 2301         	movs	r3, #0x1
 800c8e6: e01e         	b	0x800c926 <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x3c
; 		return LL_DMA_FIFOTHRESHOLD_3_4;
 800c8e8: 2302         	movs	r3, #0x2
 800c8ea: e01c         	b	0x800c926 <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x38
; 		return LL_DMA_FIFOTHRESHOLD_FULL;
 800c8ec: 2303         	movs	r3, #0x3
 800c8ee: e01a         	b	0x800c926 <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x34
; 		LOG_WRN("FIFO threshold parameter error, reset to 1/4");
 800c8f0: 2303         	movs	r3, #0x3
 800c8f2: 2b01         	cmp	r3, #0x1
 800c8f4: d916         	bls	0x800c924 <stm32_dma_get_fifo_threshold+0x6c> @ imm = #0x2c
 800c8f6: 2301         	movs	r3, #0x1
 800c8f8: 73fb         	strb	r3, [r7, #0xf]
 800c8fa: 7bfb         	ldrb	r3, [r7, #0xf]
 800c8fc: f083 0301    	eor	r3, r3, #0x1
 800c900: b2db         	uxtb	r3, r3
 800c902: 2b00         	cmp	r3, #0x0
 800c904: d10e         	bne	0x800c924 <stm32_dma_get_fifo_threshold+0x6c> @ imm = #0x1c
 800c906: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800c930 <stm32_dma_get_fifo_threshold+0x78>
 800c908: 6819         	ldr	r1, [r3]
 800c90a: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800c934 <stm32_dma_get_fifo_threshold+0x7c>
 800c90c: 9302         	str	r3, [sp, #0x8]
 800c90e: 2300         	movs	r3, #0x0
 800c910: 9301         	str	r3, [sp, #0x4]
 800c912: 2300         	movs	r3, #0x0
 800c914: 9300         	str	r3, [sp]
 800c916: 2300         	movs	r3, #0x0
 800c918: 2202         	movs	r2, #0x2
 800c91a: 2000         	movs	r0, #0x0
 800c91c: f013 fdbb    	bl	0x8020496 <z_log_msg_runtime_create> @ imm = #0x13b76
 800c920: 2300         	movs	r3, #0x0
 800c922: 60bb         	str	r3, [r7, #0x8]
; 		return LL_DMA_FIFOTHRESHOLD_1_4;
 800c924: 2300         	movs	r3, #0x0
; }
 800c926: 4618         	mov	r0, r3
 800c928: 3710         	adds	r7, #0x10
 800c92a: 46bd         	mov	sp, r7
 800c92c: bd80         	pop	{r7, pc}
 800c92e: bf00         	nop

0800c930 <$d>:
 800c930: cc 06 00 24  	.word	0x240006cc
 800c934: e4 b6 02 08  	.word	0x0802b6e4

0800c938 <get_dma_fops>:
; {
 800c938: b480         	push	{r7}
 800c93a: b083         	sub	sp, #0xc
 800c93c: af00         	add	r7, sp, #0x0
 800c93e: 6078         	str	r0, [r7, #0x4]
; 	if (dev_config->base == DT_REG_ADDR(DT_NODELABEL(dmamux1))) {
 800c940: 687b         	ldr	r3, [r7, #0x4]
 800c942: 689b         	ldr	r3, [r3, #0x8]
 800c944: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800c95c <get_dma_fops+0x24>
 800c946: 4293         	cmp	r3, r2
 800c948: d101         	bne	0x800c94e <get_dma_fops+0x16> @ imm = #0x2
; 		return &dmamux1;
 800c94a: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800c960 <get_dma_fops+0x28>
 800c94c: e000         	b	0x800c950 <get_dma_fops+0x18> @ imm = #0x0
; 	return (void *)0;
 800c94e: 2300         	movs	r3, #0x0
; }
 800c950: 4618         	mov	r0, r3
 800c952: 370c         	adds	r7, #0xc
 800c954: 46bd         	mov	sp, r7
 800c956: f85d 7b04    	ldr	r7, [sp], #4
 800c95a: 4770         	bx	lr

0800c95c <$d>:
 800c95c: 00 08 02 40  	.word	0x40020800
 800c960: 4c d3 02 08  	.word	0x0802d34c

0800c964 <dmamux_stm32_configure>:
; {
 800c964: b580         	push	{r7, lr}
 800c966: b092         	sub	sp, #0x48
 800c968: af04         	add	r7, sp, #0x10
 800c96a: 60f8         	str	r0, [r7, #0xc]
 800c96c: 60b9         	str	r1, [r7, #0x8]
 800c96e: 607a         	str	r2, [r7, #0x4]
; 	const struct dmamux_stm32_config *dev_config = dev->config;
 800c970: 68fb         	ldr	r3, [r7, #0xc]
 800c972: 685b         	ldr	r3, [r3, #0x4]
 800c974: 637b         	str	r3, [r7, #0x34]
; 	const struct dmamux_stm32_dma_fops *dma_device = get_dma_fops(dev_config);
 800c976: 6b78         	ldr	r0, [r7, #0x34]
 800c978: f7ff ffde    	bl	0x800c938 <get_dma_fops> @ imm = #-0x44
 800c97c: 6338         	str	r0, [r7, #0x30]
; 	int request_id = config->dma_slot;
 800c97e: 687b         	ldr	r3, [r7, #0x4]
 800c980: 781b         	ldrb	r3, [r3]
 800c982: 62fb         	str	r3, [r7, #0x2c]
; 	if (request_id > dev_config->req_nb + dev_config->gen_nb) {
 800c984: 6b7b         	ldr	r3, [r7, #0x34]
 800c986: 7b9b         	ldrb	r3, [r3, #0xe]
 800c988: 461a         	mov	r2, r3
 800c98a: 6b7b         	ldr	r3, [r7, #0x34]
 800c98c: 7b5b         	ldrb	r3, [r3, #0xd]
 800c98e: 4413         	add	r3, r2
 800c990: 6afa         	ldr	r2, [r7, #0x2c]
 800c992: 429a         	cmp	r2, r3
 800c994: dd1e         	ble	0x800c9d4 <dmamux_stm32_configure+0x70> @ imm = #0x3c
; 		LOG_ERR("request ID %d is not valid.", request_id);
 800c996: 2303         	movs	r3, #0x3
 800c998: 2b00         	cmp	r3, #0x0
 800c99a: d018         	beq	0x800c9ce <dmamux_stm32_configure+0x6a> @ imm = #0x30
 800c99c: 2301         	movs	r3, #0x1
 800c99e: 75fb         	strb	r3, [r7, #0x17]
 800c9a0: 7dfb         	ldrb	r3, [r7, #0x17]
 800c9a2: f083 0301    	eor	r3, r3, #0x1
 800c9a6: b2db         	uxtb	r3, r3
 800c9a8: 2b00         	cmp	r3, #0x0
 800c9aa: d110         	bne	0x800c9ce <dmamux_stm32_configure+0x6a> @ imm = #0x20
 800c9ac: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x800caa0 <dmamux_stm32_configure+0x13c>
 800c9ae: 6819         	ldr	r1, [r3]
 800c9b0: 6afb         	ldr	r3, [r7, #0x2c]
 800c9b2: 9303         	str	r3, [sp, #0xc]
 800c9b4: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x800caa4 <dmamux_stm32_configure+0x140>
 800c9b6: 9302         	str	r3, [sp, #0x8]
 800c9b8: 2300         	movs	r3, #0x0
 800c9ba: 9301         	str	r3, [sp, #0x4]
 800c9bc: 2300         	movs	r3, #0x0
 800c9be: 9300         	str	r3, [sp]
 800c9c0: 2300         	movs	r3, #0x0
 800c9c2: 2201         	movs	r2, #0x1
 800c9c4: 2000         	movs	r0, #0x0
 800c9c6: f013 fed9    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x13db2
 800c9ca: 2300         	movs	r3, #0x0
 800c9cc: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 800c9ce: f06f 0315    	mvn	r3, #0x15
 800c9d2: e061         	b	0x800ca98 <dmamux_stm32_configure+0x134> @ imm = #0xc2
; 	if (id >= dev_config->channel_nb) {
 800c9d4: 6b7b         	ldr	r3, [r7, #0x34]
 800c9d6: 7b1b         	ldrb	r3, [r3, #0xc]
 800c9d8: 461a         	mov	r2, r3
 800c9da: 68bb         	ldr	r3, [r7, #0x8]
 800c9dc: 4293         	cmp	r3, r2
 800c9de: d31e         	blo	0x800ca1e <dmamux_stm32_configure+0xba> @ imm = #0x3c
; 		LOG_ERR("channel ID %d is too big.", id);
 800c9e0: 2303         	movs	r3, #0x3
 800c9e2: 2b00         	cmp	r3, #0x0
 800c9e4: d018         	beq	0x800ca18 <dmamux_stm32_configure+0xb4> @ imm = #0x30
 800c9e6: 2301         	movs	r3, #0x1
 800c9e8: 77fb         	strb	r3, [r7, #0x1f]
 800c9ea: 7ffb         	ldrb	r3, [r7, #0x1f]
 800c9ec: f083 0301    	eor	r3, r3, #0x1
 800c9f0: b2db         	uxtb	r3, r3
 800c9f2: 2b00         	cmp	r3, #0x0
 800c9f4: d110         	bne	0x800ca18 <dmamux_stm32_configure+0xb4> @ imm = #0x20
 800c9f6: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800caa0 <dmamux_stm32_configure+0x13c>
 800c9f8: 6819         	ldr	r1, [r3]
 800c9fa: 68bb         	ldr	r3, [r7, #0x8]
 800c9fc: 9303         	str	r3, [sp, #0xc]
 800c9fe: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800caa8 <dmamux_stm32_configure+0x144>
 800ca00: 9302         	str	r3, [sp, #0x8]
 800ca02: 2300         	movs	r3, #0x0
 800ca04: 9301         	str	r3, [sp, #0x4]
 800ca06: 2300         	movs	r3, #0x0
 800ca08: 9300         	str	r3, [sp]
 800ca0a: 2300         	movs	r3, #0x0
 800ca0c: 2201         	movs	r2, #0x1
 800ca0e: 2000         	movs	r0, #0x0
 800ca10: f013 feb4    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x13d68
 800ca14: 2300         	movs	r3, #0x0
 800ca16: 61bb         	str	r3, [r7, #0x18]
; 		return -EINVAL;
 800ca18: f06f 0315    	mvn	r3, #0x15
 800ca1c: e03c         	b	0x800ca98 <dmamux_stm32_configure+0x134> @ imm = #0x78
; 	if (dma_device->configure(dev_config->mux_channels[id].dev_dma,
 800ca1e: 6b3b         	ldr	r3, [r7, #0x30]
 800ca20: 681b         	ldr	r3, [r3]
 800ca22: 6b7a         	ldr	r2, [r7, #0x34]
 800ca24: 6911         	ldr	r1, [r2, #0x10]
 800ca26: 68ba         	ldr	r2, [r7, #0x8]
 800ca28: 00d2         	lsls	r2, r2, #0x3
 800ca2a: 440a         	add	r2, r1
 800ca2c: 6810         	ldr	r0, [r2]
; 			dev_config->mux_channels[id].dma_id, config) != 0) {
 800ca2e: 6b7a         	ldr	r2, [r7, #0x34]
 800ca30: 6911         	ldr	r1, [r2, #0x10]
 800ca32: 68ba         	ldr	r2, [r7, #0x8]
 800ca34: 00d2         	lsls	r2, r2, #0x3
 800ca36: 440a         	add	r2, r1
 800ca38: 7912         	ldrb	r2, [r2, #0x4]
; 	if (dma_device->configure(dev_config->mux_channels[id].dev_dma,
 800ca3a: 4611         	mov	r1, r2
 800ca3c: 687a         	ldr	r2, [r7, #0x4]
 800ca3e: 4798         	blx	r3
 800ca40: 4603         	mov	r3, r0
 800ca42: 2b00         	cmp	r3, #0x0
 800ca44: d01e         	beq	0x800ca84 <dmamux_stm32_configure+0x120> @ imm = #0x3c
; 		LOG_ERR("cannot configure the dmamux.");
 800ca46: 2303         	movs	r3, #0x3
 800ca48: 2b00         	cmp	r3, #0x0
 800ca4a: d018         	beq	0x800ca7e <dmamux_stm32_configure+0x11a> @ imm = #0x30
 800ca4c: 2301         	movs	r3, #0x1
 800ca4e: f887 3027    	strb.w	r3, [r7, #0x27]
 800ca52: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800ca56: f083 0301    	eor	r3, r3, #0x1
 800ca5a: b2db         	uxtb	r3, r3
 800ca5c: 2b00         	cmp	r3, #0x0
 800ca5e: d10e         	bne	0x800ca7e <dmamux_stm32_configure+0x11a> @ imm = #0x1c
 800ca60: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800caa0 <dmamux_stm32_configure+0x13c>
 800ca62: 6819         	ldr	r1, [r3]
 800ca64: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800caac <dmamux_stm32_configure+0x148>
 800ca66: 9302         	str	r3, [sp, #0x8]
 800ca68: 2300         	movs	r3, #0x0
 800ca6a: 9301         	str	r3, [sp, #0x4]
 800ca6c: 2300         	movs	r3, #0x0
 800ca6e: 9300         	str	r3, [sp]
 800ca70: 2300         	movs	r3, #0x0
 800ca72: 2201         	movs	r2, #0x1
 800ca74: 2000         	movs	r0, #0x0
 800ca76: f013 fe81    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x13d02
 800ca7a: 2300         	movs	r3, #0x0
 800ca7c: 623b         	str	r3, [r7, #0x20]
; 		return -EINVAL;
 800ca7e: f06f 0315    	mvn	r3, #0x15
 800ca82: e009         	b	0x800ca98 <dmamux_stm32_configure+0x134> @ imm = #0x12
; 			(DMAMUX_Channel_TypeDef *)dev_config->base;
 800ca84: 6b7b         	ldr	r3, [r7, #0x34]
 800ca86: 689b         	ldr	r3, [r3, #0x8]
; 	DMAMUX_Channel_TypeDef *dmamux =
 800ca88: 62bb         	str	r3, [r7, #0x28]
; 	LL_DMAMUX_SetRequestID(dmamux, id, request_id);
 800ca8a: 6afb         	ldr	r3, [r7, #0x2c]
 800ca8c: 461a         	mov	r2, r3
 800ca8e: 68b9         	ldr	r1, [r7, #0x8]
 800ca90: 6ab8         	ldr	r0, [r7, #0x28]
 800ca92: f013 fe38    	bl	0x8020706 <LL_DMAMUX_SetRequestID> @ imm = #0x13c70
; 	return 0;
 800ca96: 2300         	movs	r3, #0x0
; }
 800ca98: 4618         	mov	r0, r3
 800ca9a: 3738         	adds	r7, #0x38
 800ca9c: 46bd         	mov	sp, r7
 800ca9e: bd80         	pop	{r7, pc}

0800caa0 <$d>:
 800caa0: d0 06 00 24  	.word	0x240006d0
 800caa4: 24 b7 02 08  	.word	0x0802b724
 800caa8: 40 b7 02 08  	.word	0x0802b740
 800caac: 5c b7 02 08  	.word	0x0802b75c

0800cab0 <dmamux_stm32_start>:
; {
 800cab0: b580         	push	{r7, lr}
 800cab2: b08c         	sub	sp, #0x30
 800cab4: af04         	add	r7, sp, #0x10
 800cab6: 6078         	str	r0, [r7, #0x4]
 800cab8: 6039         	str	r1, [r7]
; 	const struct dmamux_stm32_config *dev_config = dev->config;
 800caba: 687b         	ldr	r3, [r7, #0x4]
 800cabc: 685b         	ldr	r3, [r3, #0x4]
 800cabe: 61fb         	str	r3, [r7, #0x1c]
; 	const struct dmamux_stm32_dma_fops *dma_device = get_dma_fops(dev_config);
 800cac0: 69f8         	ldr	r0, [r7, #0x1c]
 800cac2: f7ff ff39    	bl	0x800c938 <get_dma_fops> @ imm = #-0x18e
 800cac6: 61b8         	str	r0, [r7, #0x18]
; 	if (id >= dev_config->channel_nb) {
 800cac8: 69fb         	ldr	r3, [r7, #0x1c]
 800caca: 7b1b         	ldrb	r3, [r3, #0xc]
 800cacc: 461a         	mov	r2, r3
 800cace: 683b         	ldr	r3, [r7]
 800cad0: 4293         	cmp	r3, r2
 800cad2: d31e         	blo	0x800cb12 <dmamux_stm32_start+0x62> @ imm = #0x3c
; 		LOG_ERR("channel ID %d is too big.", id);
 800cad4: 2303         	movs	r3, #0x3
 800cad6: 2b00         	cmp	r3, #0x0
 800cad8: d018         	beq	0x800cb0c <dmamux_stm32_start+0x5c> @ imm = #0x30
 800cada: 2301         	movs	r3, #0x1
 800cadc: 73fb         	strb	r3, [r7, #0xf]
 800cade: 7bfb         	ldrb	r3, [r7, #0xf]
 800cae0: f083 0301    	eor	r3, r3, #0x1
 800cae4: b2db         	uxtb	r3, r3
 800cae6: 2b00         	cmp	r3, #0x0
 800cae8: d110         	bne	0x800cb0c <dmamux_stm32_start+0x5c> @ imm = #0x20
 800caea: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800cb80 <dmamux_stm32_start+0xd0>
 800caec: 6819         	ldr	r1, [r3]
 800caee: 683b         	ldr	r3, [r7]
 800caf0: 9303         	str	r3, [sp, #0xc]
 800caf2: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800cb84 <dmamux_stm32_start+0xd4>
 800caf4: 9302         	str	r3, [sp, #0x8]
 800caf6: 2300         	movs	r3, #0x0
 800caf8: 9301         	str	r3, [sp, #0x4]
 800cafa: 2300         	movs	r3, #0x0
 800cafc: 9300         	str	r3, [sp]
 800cafe: 2300         	movs	r3, #0x0
 800cb00: 2201         	movs	r2, #0x1
 800cb02: 2000         	movs	r0, #0x0
 800cb04: f013 fe3a    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x13c74
 800cb08: 2300         	movs	r3, #0x0
 800cb0a: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 800cb0c: f06f 0315    	mvn	r3, #0x15
 800cb10: e032         	b	0x800cb78 <dmamux_stm32_start+0xc8> @ imm = #0x64
; 	if (dma_device->start(dev_config->mux_channels[id].dev_dma,
 800cb12: 69bb         	ldr	r3, [r7, #0x18]
 800cb14: 685b         	ldr	r3, [r3, #0x4]
 800cb16: 69fa         	ldr	r2, [r7, #0x1c]
 800cb18: 6911         	ldr	r1, [r2, #0x10]
 800cb1a: 683a         	ldr	r2, [r7]
 800cb1c: 00d2         	lsls	r2, r2, #0x3
 800cb1e: 440a         	add	r2, r1
 800cb20: 6810         	ldr	r0, [r2]
; 		dev_config->mux_channels[id].dma_id) != 0) {
 800cb22: 69fa         	ldr	r2, [r7, #0x1c]
 800cb24: 6911         	ldr	r1, [r2, #0x10]
 800cb26: 683a         	ldr	r2, [r7]
 800cb28: 00d2         	lsls	r2, r2, #0x3
 800cb2a: 440a         	add	r2, r1
 800cb2c: 7912         	ldrb	r2, [r2, #0x4]
; 	if (dma_device->start(dev_config->mux_channels[id].dev_dma,
 800cb2e: 4611         	mov	r1, r2
 800cb30: 4798         	blx	r3
 800cb32: 4603         	mov	r3, r0
 800cb34: 2b00         	cmp	r3, #0x0
 800cb36: d01e         	beq	0x800cb76 <dmamux_stm32_start+0xc6> @ imm = #0x3c
; 		LOG_ERR("cannot start the dmamux channel %d.", id);
 800cb38: 2303         	movs	r3, #0x3
 800cb3a: 2b00         	cmp	r3, #0x0
 800cb3c: d018         	beq	0x800cb70 <dmamux_stm32_start+0xc0> @ imm = #0x30
 800cb3e: 2301         	movs	r3, #0x1
 800cb40: 75fb         	strb	r3, [r7, #0x17]
 800cb42: 7dfb         	ldrb	r3, [r7, #0x17]
 800cb44: f083 0301    	eor	r3, r3, #0x1
 800cb48: b2db         	uxtb	r3, r3
 800cb4a: 2b00         	cmp	r3, #0x0
 800cb4c: d110         	bne	0x800cb70 <dmamux_stm32_start+0xc0> @ imm = #0x20
 800cb4e: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800cb80 <dmamux_stm32_start+0xd0>
 800cb50: 6819         	ldr	r1, [r3]
 800cb52: 683b         	ldr	r3, [r7]
 800cb54: 9303         	str	r3, [sp, #0xc]
 800cb56: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800cb88 <dmamux_stm32_start+0xd8>
 800cb58: 9302         	str	r3, [sp, #0x8]
 800cb5a: 2300         	movs	r3, #0x0
 800cb5c: 9301         	str	r3, [sp, #0x4]
 800cb5e: 2300         	movs	r3, #0x0
 800cb60: 9300         	str	r3, [sp]
 800cb62: 2300         	movs	r3, #0x0
 800cb64: 2201         	movs	r2, #0x1
 800cb66: 2000         	movs	r0, #0x0
 800cb68: f013 fe08    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x13c10
 800cb6c: 2300         	movs	r3, #0x0
 800cb6e: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 800cb70: f06f 0315    	mvn	r3, #0x15
 800cb74: e000         	b	0x800cb78 <dmamux_stm32_start+0xc8> @ imm = #0x0
; 	return 0;
 800cb76: 2300         	movs	r3, #0x0
; }
 800cb78: 4618         	mov	r0, r3
 800cb7a: 3720         	adds	r7, #0x20
 800cb7c: 46bd         	mov	sp, r7
 800cb7e: bd80         	pop	{r7, pc}

0800cb80 <$d>:
 800cb80: d0 06 00 24  	.word	0x240006d0
 800cb84: 40 b7 02 08  	.word	0x0802b740
 800cb88: 7c b7 02 08  	.word	0x0802b77c

0800cb8c <dmamux_stm32_stop>:
; {
 800cb8c: b580         	push	{r7, lr}
 800cb8e: b08c         	sub	sp, #0x30
 800cb90: af04         	add	r7, sp, #0x10
 800cb92: 6078         	str	r0, [r7, #0x4]
 800cb94: 6039         	str	r1, [r7]
; 	const struct dmamux_stm32_config *dev_config = dev->config;
 800cb96: 687b         	ldr	r3, [r7, #0x4]
 800cb98: 685b         	ldr	r3, [r3, #0x4]
 800cb9a: 61fb         	str	r3, [r7, #0x1c]
; 	const struct dmamux_stm32_dma_fops *dma_device = get_dma_fops(dev_config);
 800cb9c: 69f8         	ldr	r0, [r7, #0x1c]
 800cb9e: f7ff fecb    	bl	0x800c938 <get_dma_fops> @ imm = #-0x26a
 800cba2: 61b8         	str	r0, [r7, #0x18]
; 	if (id >= dev_config->channel_nb) {
 800cba4: 69fb         	ldr	r3, [r7, #0x1c]
 800cba6: 7b1b         	ldrb	r3, [r3, #0xc]
 800cba8: 461a         	mov	r2, r3
 800cbaa: 683b         	ldr	r3, [r7]
 800cbac: 4293         	cmp	r3, r2
 800cbae: d31e         	blo	0x800cbee <dmamux_stm32_stop+0x62> @ imm = #0x3c
; 		LOG_ERR("channel ID %d is too big.", id);
 800cbb0: 2303         	movs	r3, #0x3
 800cbb2: 2b00         	cmp	r3, #0x0
 800cbb4: d018         	beq	0x800cbe8 <dmamux_stm32_stop+0x5c> @ imm = #0x30
 800cbb6: 2301         	movs	r3, #0x1
 800cbb8: 73fb         	strb	r3, [r7, #0xf]
 800cbba: 7bfb         	ldrb	r3, [r7, #0xf]
 800cbbc: f083 0301    	eor	r3, r3, #0x1
 800cbc0: b2db         	uxtb	r3, r3
 800cbc2: 2b00         	cmp	r3, #0x0
 800cbc4: d110         	bne	0x800cbe8 <dmamux_stm32_stop+0x5c> @ imm = #0x20
 800cbc6: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800cc5c <dmamux_stm32_stop+0xd0>
 800cbc8: 6819         	ldr	r1, [r3]
 800cbca: 683b         	ldr	r3, [r7]
 800cbcc: 9303         	str	r3, [sp, #0xc]
 800cbce: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800cc60 <dmamux_stm32_stop+0xd4>
 800cbd0: 9302         	str	r3, [sp, #0x8]
 800cbd2: 2300         	movs	r3, #0x0
 800cbd4: 9301         	str	r3, [sp, #0x4]
 800cbd6: 2300         	movs	r3, #0x0
 800cbd8: 9300         	str	r3, [sp]
 800cbda: 2300         	movs	r3, #0x0
 800cbdc: 2201         	movs	r2, #0x1
 800cbde: 2000         	movs	r0, #0x0
 800cbe0: f013 fdcc    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x13b98
 800cbe4: 2300         	movs	r3, #0x0
 800cbe6: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 800cbe8: f06f 0315    	mvn	r3, #0x15
 800cbec: e032         	b	0x800cc54 <dmamux_stm32_stop+0xc8> @ imm = #0x64
; 	if (dma_device->stop(dev_config->mux_channels[id].dev_dma,
 800cbee: 69bb         	ldr	r3, [r7, #0x18]
 800cbf0: 689b         	ldr	r3, [r3, #0x8]
 800cbf2: 69fa         	ldr	r2, [r7, #0x1c]
 800cbf4: 6911         	ldr	r1, [r2, #0x10]
 800cbf6: 683a         	ldr	r2, [r7]
 800cbf8: 00d2         	lsls	r2, r2, #0x3
 800cbfa: 440a         	add	r2, r1
 800cbfc: 6810         	ldr	r0, [r2]
; 		dev_config->mux_channels[id].dma_id) != 0) {
 800cbfe: 69fa         	ldr	r2, [r7, #0x1c]
 800cc00: 6911         	ldr	r1, [r2, #0x10]
 800cc02: 683a         	ldr	r2, [r7]
 800cc04: 00d2         	lsls	r2, r2, #0x3
 800cc06: 440a         	add	r2, r1
 800cc08: 7912         	ldrb	r2, [r2, #0x4]
; 	if (dma_device->stop(dev_config->mux_channels[id].dev_dma,
 800cc0a: 4611         	mov	r1, r2
 800cc0c: 4798         	blx	r3
 800cc0e: 4603         	mov	r3, r0
 800cc10: 2b00         	cmp	r3, #0x0
 800cc12: d01e         	beq	0x800cc52 <dmamux_stm32_stop+0xc6> @ imm = #0x3c
; 		LOG_ERR("cannot stop the dmamux channel %d.", id);
 800cc14: 2303         	movs	r3, #0x3
 800cc16: 2b00         	cmp	r3, #0x0
 800cc18: d018         	beq	0x800cc4c <dmamux_stm32_stop+0xc0> @ imm = #0x30
 800cc1a: 2301         	movs	r3, #0x1
 800cc1c: 75fb         	strb	r3, [r7, #0x17]
 800cc1e: 7dfb         	ldrb	r3, [r7, #0x17]
 800cc20: f083 0301    	eor	r3, r3, #0x1
 800cc24: b2db         	uxtb	r3, r3
 800cc26: 2b00         	cmp	r3, #0x0
 800cc28: d110         	bne	0x800cc4c <dmamux_stm32_stop+0xc0> @ imm = #0x20
 800cc2a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800cc5c <dmamux_stm32_stop+0xd0>
 800cc2c: 6819         	ldr	r1, [r3]
 800cc2e: 683b         	ldr	r3, [r7]
 800cc30: 9303         	str	r3, [sp, #0xc]
 800cc32: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800cc64 <dmamux_stm32_stop+0xd8>
 800cc34: 9302         	str	r3, [sp, #0x8]
 800cc36: 2300         	movs	r3, #0x0
 800cc38: 9301         	str	r3, [sp, #0x4]
 800cc3a: 2300         	movs	r3, #0x0
 800cc3c: 9300         	str	r3, [sp]
 800cc3e: 2300         	movs	r3, #0x0
 800cc40: 2201         	movs	r2, #0x1
 800cc42: 2000         	movs	r0, #0x0
 800cc44: f013 fd9a    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x13b34
 800cc48: 2300         	movs	r3, #0x0
 800cc4a: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 800cc4c: f06f 0315    	mvn	r3, #0x15
 800cc50: e000         	b	0x800cc54 <dmamux_stm32_stop+0xc8> @ imm = #0x0
; 	return 0;
 800cc52: 2300         	movs	r3, #0x0
; }
 800cc54: 4618         	mov	r0, r3
 800cc56: 3720         	adds	r7, #0x20
 800cc58: 46bd         	mov	sp, r7
 800cc5a: bd80         	pop	{r7, pc}

0800cc5c <$d>:
 800cc5c: d0 06 00 24  	.word	0x240006d0
 800cc60: 40 b7 02 08  	.word	0x0802b740
 800cc64: a0 b7 02 08  	.word	0x0802b7a0

0800cc68 <dmamux_stm32_reload>:
; {
 800cc68: b590         	push	{r4, r7, lr}
 800cc6a: b08f         	sub	sp, #0x3c
 800cc6c: af04         	add	r7, sp, #0x10
 800cc6e: 60f8         	str	r0, [r7, #0xc]
 800cc70: 60b9         	str	r1, [r7, #0x8]
 800cc72: 607a         	str	r2, [r7, #0x4]
 800cc74: 603b         	str	r3, [r7]
; 	const struct dmamux_stm32_config *dev_config = dev->config;
 800cc76: 68fb         	ldr	r3, [r7, #0xc]
 800cc78: 685b         	ldr	r3, [r3, #0x4]
 800cc7a: 627b         	str	r3, [r7, #0x24]
; 	const struct dmamux_stm32_dma_fops *dma_device = get_dma_fops(dev_config);
 800cc7c: 6a78         	ldr	r0, [r7, #0x24]
 800cc7e: f7ff fe5b    	bl	0x800c938 <get_dma_fops> @ imm = #-0x34a
 800cc82: 6238         	str	r0, [r7, #0x20]
; 	if (id >= dev_config->channel_nb) {
 800cc84: 6a7b         	ldr	r3, [r7, #0x24]
 800cc86: 7b1b         	ldrb	r3, [r3, #0xc]
 800cc88: 461a         	mov	r2, r3
 800cc8a: 68bb         	ldr	r3, [r7, #0x8]
 800cc8c: 4293         	cmp	r3, r2
 800cc8e: d31e         	blo	0x800ccce <dmamux_stm32_reload+0x66> @ imm = #0x3c
; 		LOG_ERR("channel ID %d is too big.", id);
 800cc90: 2303         	movs	r3, #0x3
 800cc92: 2b00         	cmp	r3, #0x0
 800cc94: d018         	beq	0x800ccc8 <dmamux_stm32_reload+0x60> @ imm = #0x30
 800cc96: 2301         	movs	r3, #0x1
 800cc98: 75fb         	strb	r3, [r7, #0x17]
 800cc9a: 7dfb         	ldrb	r3, [r7, #0x17]
 800cc9c: f083 0301    	eor	r3, r3, #0x1
 800cca0: b2db         	uxtb	r3, r3
 800cca2: 2b00         	cmp	r3, #0x0
 800cca4: d110         	bne	0x800ccc8 <dmamux_stm32_reload+0x60> @ imm = #0x20
 800cca6: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800cd44 <dmamux_stm32_reload+0xdc>
 800cca8: 6819         	ldr	r1, [r3]
 800ccaa: 68bb         	ldr	r3, [r7, #0x8]
 800ccac: 9303         	str	r3, [sp, #0xc]
 800ccae: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800cd48 <dmamux_stm32_reload+0xe0>
 800ccb0: 9302         	str	r3, [sp, #0x8]
 800ccb2: 2300         	movs	r3, #0x0
 800ccb4: 9301         	str	r3, [sp, #0x4]
 800ccb6: 2300         	movs	r3, #0x0
 800ccb8: 9300         	str	r3, [sp]
 800ccba: 2300         	movs	r3, #0x0
 800ccbc: 2201         	movs	r2, #0x1
 800ccbe: 2000         	movs	r0, #0x0
 800ccc0: f013 fd5c    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x13ab8
 800ccc4: 2300         	movs	r3, #0x0
 800ccc6: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 800ccc8: f06f 0315    	mvn	r3, #0x15
 800cccc: e036         	b	0x800cd3c <dmamux_stm32_reload+0xd4> @ imm = #0x6c
; 	if (dma_device->reload(dev_config->mux_channels[id].dev_dma,
 800ccce: 6a3b         	ldr	r3, [r7, #0x20]
 800ccd0: 68dc         	ldr	r4, [r3, #0xc]
 800ccd2: 6a7b         	ldr	r3, [r7, #0x24]
 800ccd4: 691a         	ldr	r2, [r3, #0x10]
 800ccd6: 68bb         	ldr	r3, [r7, #0x8]
 800ccd8: 00db         	lsls	r3, r3, #0x3
 800ccda: 4413         	add	r3, r2
 800ccdc: 6818         	ldr	r0, [r3]
; 		dev_config->mux_channels[id].dma_id,
 800ccde: 6a7b         	ldr	r3, [r7, #0x24]
 800cce0: 691a         	ldr	r2, [r3, #0x10]
 800cce2: 68bb         	ldr	r3, [r7, #0x8]
 800cce4: 00db         	lsls	r3, r3, #0x3
 800cce6: 4413         	add	r3, r2
 800cce8: 791b         	ldrb	r3, [r3, #0x4]
; 	if (dma_device->reload(dev_config->mux_channels[id].dev_dma,
 800ccea: 4619         	mov	r1, r3
 800ccec: 6bbb         	ldr	r3, [r7, #0x38]
 800ccee: 9300         	str	r3, [sp]
 800ccf0: 683b         	ldr	r3, [r7]
 800ccf2: 687a         	ldr	r2, [r7, #0x4]
 800ccf4: 47a0         	blx	r4
 800ccf6: 4603         	mov	r3, r0
 800ccf8: 2b00         	cmp	r3, #0x0
 800ccfa: d01e         	beq	0x800cd3a <dmamux_stm32_reload+0xd2> @ imm = #0x3c
; 		LOG_ERR("cannot reload the dmamux channel %d.", id);
 800ccfc: 2303         	movs	r3, #0x3
 800ccfe: 2b00         	cmp	r3, #0x0
 800cd00: d018         	beq	0x800cd34 <dmamux_stm32_reload+0xcc> @ imm = #0x30
 800cd02: 2301         	movs	r3, #0x1
 800cd04: 77fb         	strb	r3, [r7, #0x1f]
 800cd06: 7ffb         	ldrb	r3, [r7, #0x1f]
 800cd08: f083 0301    	eor	r3, r3, #0x1
 800cd0c: b2db         	uxtb	r3, r3
 800cd0e: 2b00         	cmp	r3, #0x0
 800cd10: d110         	bne	0x800cd34 <dmamux_stm32_reload+0xcc> @ imm = #0x20
 800cd12: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800cd44 <dmamux_stm32_reload+0xdc>
 800cd14: 6819         	ldr	r1, [r3]
 800cd16: 68bb         	ldr	r3, [r7, #0x8]
 800cd18: 9303         	str	r3, [sp, #0xc]
 800cd1a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800cd4c <dmamux_stm32_reload+0xe4>
 800cd1c: 9302         	str	r3, [sp, #0x8]
 800cd1e: 2300         	movs	r3, #0x0
 800cd20: 9301         	str	r3, [sp, #0x4]
 800cd22: 2300         	movs	r3, #0x0
 800cd24: 9300         	str	r3, [sp]
 800cd26: 2300         	movs	r3, #0x0
 800cd28: 2201         	movs	r2, #0x1
 800cd2a: 2000         	movs	r0, #0x0
 800cd2c: f013 fd26    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x13a4c
 800cd30: 2300         	movs	r3, #0x0
 800cd32: 61bb         	str	r3, [r7, #0x18]
; 		return -EINVAL;
 800cd34: f06f 0315    	mvn	r3, #0x15
 800cd38: e000         	b	0x800cd3c <dmamux_stm32_reload+0xd4> @ imm = #0x0
; 	return 0;
 800cd3a: 2300         	movs	r3, #0x0
; }
 800cd3c: 4618         	mov	r0, r3
 800cd3e: 372c         	adds	r7, #0x2c
 800cd40: 46bd         	mov	sp, r7
 800cd42: bd90         	pop	{r4, r7, pc}

0800cd44 <$d>:
 800cd44: d0 06 00 24  	.word	0x240006d0
 800cd48: 40 b7 02 08  	.word	0x0802b740
 800cd4c: c4 b7 02 08  	.word	0x0802b7c4

0800cd50 <dmamux_stm32_get_status>:
; {
 800cd50: b580         	push	{r7, lr}
 800cd52: b08e         	sub	sp, #0x38
 800cd54: af04         	add	r7, sp, #0x10
 800cd56: 60f8         	str	r0, [r7, #0xc]
 800cd58: 60b9         	str	r1, [r7, #0x8]
 800cd5a: 607a         	str	r2, [r7, #0x4]
; 	const struct dmamux_stm32_config *dev_config = dev->config;
 800cd5c: 68fb         	ldr	r3, [r7, #0xc]
 800cd5e: 685b         	ldr	r3, [r3, #0x4]
 800cd60: 627b         	str	r3, [r7, #0x24]
; 	const struct dmamux_stm32_dma_fops *dma_device = get_dma_fops(dev_config);
 800cd62: 6a78         	ldr	r0, [r7, #0x24]
 800cd64: f7ff fde8    	bl	0x800c938 <get_dma_fops> @ imm = #-0x430
 800cd68: 6238         	str	r0, [r7, #0x20]
; 	if (id >= dev_config->channel_nb) {
 800cd6a: 6a7b         	ldr	r3, [r7, #0x24]
 800cd6c: 7b1b         	ldrb	r3, [r3, #0xc]
 800cd6e: 461a         	mov	r2, r3
 800cd70: 68bb         	ldr	r3, [r7, #0x8]
 800cd72: 4293         	cmp	r3, r2
 800cd74: d31e         	blo	0x800cdb4 <dmamux_stm32_get_status+0x64> @ imm = #0x3c
; 		LOG_ERR("channel ID %d is too big.", id);
 800cd76: 2303         	movs	r3, #0x3
 800cd78: 2b00         	cmp	r3, #0x0
 800cd7a: d018         	beq	0x800cdae <dmamux_stm32_get_status+0x5e> @ imm = #0x30
 800cd7c: 2301         	movs	r3, #0x1
 800cd7e: 75fb         	strb	r3, [r7, #0x17]
 800cd80: 7dfb         	ldrb	r3, [r7, #0x17]
 800cd82: f083 0301    	eor	r3, r3, #0x1
 800cd86: b2db         	uxtb	r3, r3
 800cd88: 2b00         	cmp	r3, #0x0
 800cd8a: d110         	bne	0x800cdae <dmamux_stm32_get_status+0x5e> @ imm = #0x20
 800cd8c: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800ce24 <dmamux_stm32_get_status+0xd4>
 800cd8e: 6819         	ldr	r1, [r3]
 800cd90: 68bb         	ldr	r3, [r7, #0x8]
 800cd92: 9303         	str	r3, [sp, #0xc]
 800cd94: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800ce28 <dmamux_stm32_get_status+0xd8>
 800cd96: 9302         	str	r3, [sp, #0x8]
 800cd98: 2300         	movs	r3, #0x0
 800cd9a: 9301         	str	r3, [sp, #0x4]
 800cd9c: 2300         	movs	r3, #0x0
 800cd9e: 9300         	str	r3, [sp]
 800cda0: 2300         	movs	r3, #0x0
 800cda2: 2201         	movs	r2, #0x1
 800cda4: 2000         	movs	r0, #0x0
 800cda6: f013 fce9    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x139d2
 800cdaa: 2300         	movs	r3, #0x0
 800cdac: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 800cdae: f06f 0315    	mvn	r3, #0x15
 800cdb2: e033         	b	0x800ce1c <dmamux_stm32_get_status+0xcc> @ imm = #0x66
; 	if (dma_device->get_status(dev_config->mux_channels[id].dev_dma,
 800cdb4: 6a3b         	ldr	r3, [r7, #0x20]
 800cdb6: 691b         	ldr	r3, [r3, #0x10]
 800cdb8: 6a7a         	ldr	r2, [r7, #0x24]
 800cdba: 6911         	ldr	r1, [r2, #0x10]
 800cdbc: 68ba         	ldr	r2, [r7, #0x8]
 800cdbe: 00d2         	lsls	r2, r2, #0x3
 800cdc0: 440a         	add	r2, r1
 800cdc2: 6810         	ldr	r0, [r2]
; 		dev_config->mux_channels[id].dma_id, stat) != 0) {
 800cdc4: 6a7a         	ldr	r2, [r7, #0x24]
 800cdc6: 6911         	ldr	r1, [r2, #0x10]
 800cdc8: 68ba         	ldr	r2, [r7, #0x8]
 800cdca: 00d2         	lsls	r2, r2, #0x3
 800cdcc: 440a         	add	r2, r1
 800cdce: 7912         	ldrb	r2, [r2, #0x4]
; 	if (dma_device->get_status(dev_config->mux_channels[id].dev_dma,
 800cdd0: 4611         	mov	r1, r2
 800cdd2: 687a         	ldr	r2, [r7, #0x4]
 800cdd4: 4798         	blx	r3
 800cdd6: 4603         	mov	r3, r0
 800cdd8: 2b00         	cmp	r3, #0x0
 800cdda: d01e         	beq	0x800ce1a <dmamux_stm32_get_status+0xca> @ imm = #0x3c
; 		LOG_ERR("cannot get the status of dmamux channel %d.", id);
 800cddc: 2303         	movs	r3, #0x3
 800cdde: 2b00         	cmp	r3, #0x0
 800cde0: d018         	beq	0x800ce14 <dmamux_stm32_get_status+0xc4> @ imm = #0x30
 800cde2: 2301         	movs	r3, #0x1
 800cde4: 77fb         	strb	r3, [r7, #0x1f]
 800cde6: 7ffb         	ldrb	r3, [r7, #0x1f]
 800cde8: f083 0301    	eor	r3, r3, #0x1
 800cdec: b2db         	uxtb	r3, r3
 800cdee: 2b00         	cmp	r3, #0x0
 800cdf0: d110         	bne	0x800ce14 <dmamux_stm32_get_status+0xc4> @ imm = #0x20
 800cdf2: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800ce24 <dmamux_stm32_get_status+0xd4>
 800cdf4: 6819         	ldr	r1, [r3]
 800cdf6: 68bb         	ldr	r3, [r7, #0x8]
 800cdf8: 9303         	str	r3, [sp, #0xc]
 800cdfa: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800ce2c <dmamux_stm32_get_status+0xdc>
 800cdfc: 9302         	str	r3, [sp, #0x8]
 800cdfe: 2300         	movs	r3, #0x0
 800ce00: 9301         	str	r3, [sp, #0x4]
 800ce02: 2300         	movs	r3, #0x0
 800ce04: 9300         	str	r3, [sp]
 800ce06: 2300         	movs	r3, #0x0
 800ce08: 2201         	movs	r2, #0x1
 800ce0a: 2000         	movs	r0, #0x0
 800ce0c: f013 fcb6    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x1396c
 800ce10: 2300         	movs	r3, #0x0
 800ce12: 61bb         	str	r3, [r7, #0x18]
; 		return -EINVAL;
 800ce14: f06f 0315    	mvn	r3, #0x15
 800ce18: e000         	b	0x800ce1c <dmamux_stm32_get_status+0xcc> @ imm = #0x0
; 	return 0;
 800ce1a: 2300         	movs	r3, #0x0
; }
 800ce1c: 4618         	mov	r0, r3
 800ce1e: 3728         	adds	r7, #0x28
 800ce20: 46bd         	mov	sp, r7
 800ce22: bd80         	pop	{r7, pc}

0800ce24 <$d>:
 800ce24: d0 06 00 24  	.word	0x240006d0
 800ce28: 40 b7 02 08  	.word	0x0802b740
 800ce2c: ec b7 02 08  	.word	0x0802b7ec

0800ce30 <dmamux_stm32_init>:
; {
 800ce30: b580         	push	{r7, lr}
 800ce32: b08c         	sub	sp, #0x30
 800ce34: af04         	add	r7, sp, #0x10
 800ce36: 6078         	str	r0, [r7, #0x4]
; 	const struct dmamux_stm32_config *config = dev->config;
 800ce38: 687b         	ldr	r3, [r7, #0x4]
 800ce3a: 685b         	ldr	r3, [r3, #0x4]
 800ce3c: 61fb         	str	r3, [r7, #0x1c]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800ce3e: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x800cf1c <dmamux_stm32_init+0xec>
 800ce40: 61bb         	str	r3, [r7, #0x18]
; 	if (!device_is_ready(clk)) {
 800ce42: 69b8         	ldr	r0, [r7, #0x18]
 800ce44: f013 fc7c    	bl	0x8020740 <device_is_ready> @ imm = #0x138f8
 800ce48: 4603         	mov	r3, r0
 800ce4a: f083 0301    	eor	r3, r3, #0x1
 800ce4e: b2db         	uxtb	r3, r3
 800ce50: 2b00         	cmp	r3, #0x0
 800ce52: d01c         	beq	0x800ce8e <dmamux_stm32_init+0x5e> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 800ce54: 2303         	movs	r3, #0x3
 800ce56: 2b00         	cmp	r3, #0x0
 800ce58: d016         	beq	0x800ce88 <dmamux_stm32_init+0x58> @ imm = #0x2c
 800ce5a: 2301         	movs	r3, #0x1
 800ce5c: 73fb         	strb	r3, [r7, #0xf]
 800ce5e: 7bfb         	ldrb	r3, [r7, #0xf]
 800ce60: f083 0301    	eor	r3, r3, #0x1
 800ce64: b2db         	uxtb	r3, r3
 800ce66: 2b00         	cmp	r3, #0x0
 800ce68: d10e         	bne	0x800ce88 <dmamux_stm32_init+0x58> @ imm = #0x1c
 800ce6a: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x800cf20 <dmamux_stm32_init+0xf0>
 800ce6c: 6819         	ldr	r1, [r3]
 800ce6e: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x800cf24 <dmamux_stm32_init+0xf4>
 800ce70: 9302         	str	r3, [sp, #0x8]
 800ce72: 2300         	movs	r3, #0x0
 800ce74: 9301         	str	r3, [sp, #0x4]
 800ce76: 2300         	movs	r3, #0x0
 800ce78: 9300         	str	r3, [sp]
 800ce7a: 2300         	movs	r3, #0x0
 800ce7c: 2201         	movs	r2, #0x1
 800ce7e: 2000         	movs	r0, #0x0
 800ce80: f013 fc7c    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x138f8
 800ce84: 2300         	movs	r3, #0x0
 800ce86: 60bb         	str	r3, [r7, #0x8]
; 		return -ENODEV;
 800ce88: f06f 0312    	mvn	r3, #0x12
 800ce8c: e042         	b	0x800cf14 <dmamux_stm32_init+0xe4> @ imm = #0x84
; 		(clock_control_subsys_t) &config->pclken) != 0) {
 800ce8e: 69fb         	ldr	r3, [r7, #0x1c]
; 	if (clock_control_on(clk,
 800ce90: 4619         	mov	r1, r3
 800ce92: 69b8         	ldr	r0, [r7, #0x18]
 800ce94: f013 fc60    	bl	0x8020758 <clock_control_on> @ imm = #0x138c0
 800ce98: 4603         	mov	r3, r0
 800ce9a: 2b00         	cmp	r3, #0x0
 800ce9c: d01c         	beq	0x800ced8 <dmamux_stm32_init+0xa8> @ imm = #0x38
; 		LOG_ERR("clock op failed\n");
 800ce9e: 2303         	movs	r3, #0x3
 800cea0: 2b00         	cmp	r3, #0x0
 800cea2: d016         	beq	0x800ced2 <dmamux_stm32_init+0xa2> @ imm = #0x2c
 800cea4: 2301         	movs	r3, #0x1
 800cea6: 75fb         	strb	r3, [r7, #0x17]
 800cea8: 7dfb         	ldrb	r3, [r7, #0x17]
 800ceaa: f083 0301    	eor	r3, r3, #0x1
 800ceae: b2db         	uxtb	r3, r3
 800ceb0: 2b00         	cmp	r3, #0x0
 800ceb2: d10e         	bne	0x800ced2 <dmamux_stm32_init+0xa2> @ imm = #0x1c
 800ceb4: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800cf20 <dmamux_stm32_init+0xf0>
 800ceb6: 6819         	ldr	r1, [r3]
 800ceb8: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800cf28 <dmamux_stm32_init+0xf8>
 800ceba: 9302         	str	r3, [sp, #0x8]
 800cebc: 2300         	movs	r3, #0x0
 800cebe: 9301         	str	r3, [sp, #0x4]
 800cec0: 2300         	movs	r3, #0x0
 800cec2: 9300         	str	r3, [sp]
 800cec4: 2300         	movs	r3, #0x0
 800cec6: 2201         	movs	r2, #0x1
 800cec8: 2000         	movs	r0, #0x0
 800ceca: f013 fc57    	bl	0x802077c <z_log_msg_runtime_create> @ imm = #0x138ae
 800cece: 2300         	movs	r3, #0x0
 800ced0: 613b         	str	r3, [r7, #0x10]
; 		return -EIO;
 800ced2: f06f 0304    	mvn	r3, #0x4
 800ced6: e01d         	b	0x800cf14 <dmamux_stm32_init+0xe4> @ imm = #0x3a
; 	if (config->base == DT_REG_ADDR(DT_NODELABEL(dmamux1))) {
 800ced8: 69fb         	ldr	r3, [r7, #0x1c]
 800ceda: 689b         	ldr	r3, [r3, #0x8]
 800cedc: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800cf2c <dmamux_stm32_init+0xfc>
 800cede: 4293         	cmp	r3, r2
 800cee0: d117         	bne	0x800cf12 <dmamux_stm32_init+0xe2> @ imm = #0x2e
; 		if (device_is_ready(DEVICE_DT_GET(DT_NODELABEL(dma1))) == false) {
 800cee2: 4813         	ldr	r0, [pc, #0x4c]         @ 0x800cf30 <dmamux_stm32_init+0x100>
 800cee4: f013 fc2c    	bl	0x8020740 <device_is_ready> @ imm = #0x13858
 800cee8: 4603         	mov	r3, r0
 800ceea: f083 0301    	eor	r3, r3, #0x1
 800ceee: b2db         	uxtb	r3, r3
 800cef0: 2b00         	cmp	r3, #0x0
 800cef2: d002         	beq	0x800cefa <dmamux_stm32_init+0xca> @ imm = #0x4
; 			return -ENODEV;
 800cef4: f06f 0312    	mvn	r3, #0x12
 800cef8: e00c         	b	0x800cf14 <dmamux_stm32_init+0xe4> @ imm = #0x18
; 		if (device_is_ready(DEVICE_DT_GET(DT_NODELABEL(dma2))) == false) {
 800cefa: 480e         	ldr	r0, [pc, #0x38]         @ 0x800cf34 <dmamux_stm32_init+0x104>
 800cefc: f013 fc20    	bl	0x8020740 <device_is_ready> @ imm = #0x13840
 800cf00: 4603         	mov	r3, r0
 800cf02: f083 0301    	eor	r3, r3, #0x1
 800cf06: b2db         	uxtb	r3, r3
 800cf08: 2b00         	cmp	r3, #0x0
 800cf0a: d002         	beq	0x800cf12 <dmamux_stm32_init+0xe2> @ imm = #0x4
; 			return -ENODEV;
 800cf0c: f06f 0312    	mvn	r3, #0x12
 800cf10: e000         	b	0x800cf14 <dmamux_stm32_init+0xe4> @ imm = #0x0
; 	return 0;
 800cf12: 2300         	movs	r3, #0x0
; }
 800cf14: 4618         	mov	r0, r3
 800cf16: 3720         	adds	r7, #0x20
 800cf18: 46bd         	mov	sp, r7
 800cf1a: bd80         	pop	{r7, pc}

0800cf1c <$d>:
 800cf1c: c0 96 02 08  	.word	0x080296c0
 800cf20: d0 06 00 24  	.word	0x240006d0
 800cf24: 18 b8 02 08  	.word	0x0802b818
 800cf28: 38 b8 02 08  	.word	0x0802b838
 800cf2c: 00 08 02 40  	.word	0x40020800
 800cf30: fc 96 02 08  	.word	0x080296fc
 800cf34: 10 97 02 08  	.word	0x08029710

0800cf38 <gpio_stm32_clock_request>:
; {
 800cf38: b580         	push	{r7, lr}
 800cf3a: b086         	sub	sp, #0x18
 800cf3c: af00         	add	r7, sp, #0x0
 800cf3e: 6078         	str	r0, [r7, #0x4]
 800cf40: 460b         	mov	r3, r1
 800cf42: 70fb         	strb	r3, [r7, #0x3]
; 	const struct gpio_stm32_config *cfg = dev->config;
 800cf44: 687b         	ldr	r3, [r7, #0x4]
 800cf46: 685b         	ldr	r3, [r3, #0x4]
 800cf48: 613b         	str	r3, [r7, #0x10]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800cf4a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800cf7c <gpio_stm32_clock_request+0x44>
 800cf4c: 60fb         	str	r3, [r7, #0xc]
; 	if (on) {
 800cf4e: 78fb         	ldrb	r3, [r7, #0x3]
 800cf50: 2b00         	cmp	r3, #0x0
 800cf52: d007         	beq	0x800cf64 <gpio_stm32_clock_request+0x2c> @ imm = #0xe
; 					(clock_control_subsys_t)&cfg->pclken);
 800cf54: 693b         	ldr	r3, [r7, #0x10]
 800cf56: 330c         	adds	r3, #0xc
; 		ret = clock_control_on(clk,
 800cf58: 4619         	mov	r1, r3
 800cf5a: 68f8         	ldr	r0, [r7, #0xc]
 800cf5c: f013 fe45    	bl	0x8020bea <clock_control_on> @ imm = #0x13c8a
 800cf60: 6178         	str	r0, [r7, #0x14]
 800cf62: e006         	b	0x800cf72 <gpio_stm32_clock_request+0x3a> @ imm = #0xc
; 					(clock_control_subsys_t)&cfg->pclken);
 800cf64: 693b         	ldr	r3, [r7, #0x10]
 800cf66: 330c         	adds	r3, #0xc
; 		ret = clock_control_off(clk,
 800cf68: 4619         	mov	r1, r3
 800cf6a: 68f8         	ldr	r0, [r7, #0xc]
 800cf6c: f013 fe4f    	bl	0x8020c0e <clock_control_off> @ imm = #0x13c9e
 800cf70: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 800cf72: 697b         	ldr	r3, [r7, #0x14]
; }
 800cf74: 4618         	mov	r0, r3
 800cf76: 3718         	adds	r7, #0x18
 800cf78: 46bd         	mov	sp, r7
 800cf7a: bd80         	pop	{r7, pc}

0800cf7c <$d>:
 800cf7c: c0 96 02 08  	.word	0x080296c0

0800cf80 <gpio_stm32_pin_interrupt_configure>:
; {
 800cf80: b580         	push	{r7, lr}
 800cf82: b08a         	sub	sp, #0x28
 800cf84: af00         	add	r7, sp, #0x0
 800cf86: 60f8         	str	r0, [r7, #0xc]
 800cf88: 607a         	str	r2, [r7, #0x4]
 800cf8a: 603b         	str	r3, [r7]
 800cf8c: 460b         	mov	r3, r1
 800cf8e: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 800cf90: 68fb         	ldr	r3, [r7, #0xc]
 800cf92: 685b         	ldr	r3, [r3, #0x4]
 800cf94: 61fb         	str	r3, [r7, #0x1c]
; 	struct gpio_stm32_data *data = dev->data;
 800cf96: 68fb         	ldr	r3, [r7, #0xc]
 800cf98: 691b         	ldr	r3, [r3, #0x10]
 800cf9a: 61bb         	str	r3, [r7, #0x18]
; 	const stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(cfg->port, pin);
 800cf9c: 69fb         	ldr	r3, [r7, #0x1c]
 800cf9e: 689b         	ldr	r3, [r3, #0x8]
 800cfa0: 461a         	mov	r2, r3
 800cfa2: 7afb         	ldrb	r3, [r7, #0xb]
 800cfa4: 4619         	mov	r1, r3
 800cfa6: 4610         	mov	r0, r2
 800cfa8: f011 f98f    	bl	0x801e2ca <stm32_gpio_intc_get_pin_irq_line> @ imm = #0x1131e
 800cfac: 6178         	str	r0, [r7, #0x14]
; 	uint32_t irq_trigger = 0;
 800cfae: 2300         	movs	r3, #0x0
 800cfb0: 627b         	str	r3, [r7, #0x24]
; 	int err = 0;
 800cfb2: 2300         	movs	r3, #0x0
 800cfb4: 623b         	str	r3, [r7, #0x20]
; 	if (mode == GPIO_INT_MODE_DISABLED) {
 800cfb6: 687b         	ldr	r3, [r7, #0x4]
 800cfb8: f5b3 1f00    	cmp.w	r3, #0x200000
 800cfbc: d108         	bne	0x800cfd0 <gpio_stm32_pin_interrupt_configure+0x50> @ imm = #0x10
; 		gpio_stm32_disable_pin_irqs(cfg->port, pin);
 800cfbe: 69fb         	ldr	r3, [r7, #0x1c]
 800cfc0: 689b         	ldr	r3, [r3, #0x8]
 800cfc2: 461a         	mov	r2, r3
 800cfc4: 7afb         	ldrb	r3, [r7, #0xb]
 800cfc6: 4619         	mov	r1, r3
 800cfc8: 4610         	mov	r0, r2
 800cfca: f013 ff97    	bl	0x8020efc <gpio_stm32_disable_pin_irqs> @ imm = #0x13f2e
; 		goto exit;
 800cfce: e040         	b	0x800d052 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x80
; 	if (mode == GPIO_INT_MODE_LEVEL) {
 800cfd0: 687b         	ldr	r3, [r7, #0x4]
 800cfd2: f5b3 0f80    	cmp.w	r3, #0x400000
 800cfd6: d103         	bne	0x800cfe0 <gpio_stm32_pin_interrupt_configure+0x60> @ imm = #0x6
; 			err = -ENOTSUP;
 800cfd8: f06f 0385    	mvn	r3, #0x85
 800cfdc: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 800cfde: e038         	b	0x800d052 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x70
; 		switch (trig) {
 800cfe0: 683b         	ldr	r3, [r7]
 800cfe2: f1b3 6fc0    	cmp.w	r3, #0x6000000
 800cfe6: d012         	beq	0x800d00e <gpio_stm32_pin_interrupt_configure+0x8e> @ imm = #0x24
 800cfe8: 683b         	ldr	r3, [r7]
 800cfea: f1b3 6fc0    	cmp.w	r3, #0x6000000
 800cfee: d811         	bhi	0x800d014 <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x22
 800cff0: 683b         	ldr	r3, [r7]
 800cff2: f1b3 7f00    	cmp.w	r3, #0x2000000
 800cff6: d004         	beq	0x800d002 <gpio_stm32_pin_interrupt_configure+0x82> @ imm = #0x8
 800cff8: 683b         	ldr	r3, [r7]
 800cffa: f1b3 6f80    	cmp.w	r3, #0x4000000
 800cffe: d003         	beq	0x800d008 <gpio_stm32_pin_interrupt_configure+0x88> @ imm = #0x6
 800d000: e008         	b	0x800d014 <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x10
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_FALLING;
 800d002: 2302         	movs	r3, #0x2
 800d004: 627b         	str	r3, [r7, #0x24]
; 			break;
 800d006: e009         	b	0x800d01c <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x12
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_RISING;
 800d008: 2301         	movs	r3, #0x1
 800d00a: 627b         	str	r3, [r7, #0x24]
; 			break;
 800d00c: e006         	b	0x800d01c <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0xc
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_BOTH;
 800d00e: 2303         	movs	r3, #0x3
 800d010: 627b         	str	r3, [r7, #0x24]
; 			break;
 800d012: e003         	b	0x800d01c <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x6
; 			err = -EINVAL;
 800d014: f06f 0315    	mvn	r3, #0x15
 800d018: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 800d01a: e01a         	b	0x800d052 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x34
; 	if (stm32_gpio_intc_set_irq_callback(irq_line, gpio_stm32_isr, data) != 0) {
 800d01c: 69ba         	ldr	r2, [r7, #0x18]
 800d01e: 490f         	ldr	r1, [pc, #0x3c]         @ 0x800d05c <gpio_stm32_pin_interrupt_configure+0xdc>
 800d020: 6978         	ldr	r0, [r7, #0x14]
 800d022: f7fa fa51    	bl	0x80074c8 <stm32_gpio_intc_set_irq_callback> @ imm = #-0x5b5e
 800d026: 4603         	mov	r3, r0
 800d028: 2b00         	cmp	r3, #0x0
 800d02a: d003         	beq	0x800d034 <gpio_stm32_pin_interrupt_configure+0xb4> @ imm = #0x6
; 		err = -EBUSY;
 800d02c: f06f 030f    	mvn	r3, #0xf
 800d030: 623b         	str	r3, [r7, #0x20]
; 		goto exit;
 800d032: e00e         	b	0x800d052 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x1c
; 	stm32_exti_set_line_src_port(pin, cfg->port);
 800d034: 69fb         	ldr	r3, [r7, #0x1c]
 800d036: 689b         	ldr	r3, [r3, #0x8]
 800d038: 461a         	mov	r2, r3
 800d03a: 7afb         	ldrb	r3, [r7, #0xb]
 800d03c: 4611         	mov	r1, r2
 800d03e: 4618         	mov	r0, r3
 800d040: f011 f95d    	bl	0x801e2fe <stm32_exti_set_line_src_port> @ imm = #0x112ba
; 	stm32_gpio_intc_select_line_trigger(irq_line, irq_trigger);
 800d044: 6a79         	ldr	r1, [r7, #0x24]
 800d046: 6978         	ldr	r0, [r7, #0x14]
 800d048: f7fa fa02    	bl	0x8007450 <stm32_gpio_intc_select_line_trigger> @ imm = #-0x5bfc
; 	stm32_gpio_intc_enable_line(irq_line);
 800d04c: 6978         	ldr	r0, [r7, #0x14]
 800d04e: f7fa f9e5    	bl	0x800741c <stm32_gpio_intc_enable_line> @ imm = #-0x5c36
; 	return err;
 800d052: 6a3b         	ldr	r3, [r7, #0x20]
; }
 800d054: 4618         	mov	r0, r3
 800d056: 3728         	adds	r7, #0x28
 800d058: 46bd         	mov	sp, r7
 800d05a: bd80         	pop	{r7, pc}

0800d05c <$d>:
 800d05c: bd 0d 02 08  	.word	0x08020dbd

0800d060 <gpio_stm32_init>:
; {
 800d060: b580         	push	{r7, lr}
 800d062: b084         	sub	sp, #0x10
 800d064: af00         	add	r7, sp, #0x0
 800d066: 6078         	str	r0, [r7, #0x4]
; 	struct gpio_stm32_data *data = dev->data;
 800d068: 687b         	ldr	r3, [r7, #0x4]
 800d06a: 691b         	ldr	r3, [r3, #0x10]
 800d06c: 60fb         	str	r3, [r7, #0xc]
; 	data->dev = dev;
 800d06e: 68fb         	ldr	r3, [r7, #0xc]
 800d070: 687a         	ldr	r2, [r7, #0x4]
 800d072: 605a         	str	r2, [r3, #0x4]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 800d074: 480e         	ldr	r0, [pc, #0x38]         @ 0x800d0b0 <gpio_stm32_init+0x50>
 800d076: f013 fc9d    	bl	0x80209b4 <device_is_ready> @ imm = #0x1393a
 800d07a: 4603         	mov	r3, r0
 800d07c: f083 0301    	eor	r3, r3, #0x1
 800d080: b2db         	uxtb	r3, r3
 800d082: 2b00         	cmp	r3, #0x0
 800d084: d002         	beq	0x800d08c <gpio_stm32_init+0x2c> @ imm = #0x4
; 		return -ENODEV;
 800d086: f06f 0312    	mvn	r3, #0x12
 800d08a: e00d         	b	0x800d0a8 <gpio_stm32_init+0x48> @ imm = #0x1a
; 	ret = gpio_stm32_clock_request(dev, !IS_ENABLED(CONFIG_PM_DEVICE_RUNTIME));
 800d08c: 2101         	movs	r1, #0x1
 800d08e: 6878         	ldr	r0, [r7, #0x4]
 800d090: f7ff ff52    	bl	0x800cf38 <gpio_stm32_clock_request> @ imm = #-0x15c
 800d094: 60b8         	str	r0, [r7, #0x8]
; 	if (ret < 0) {
 800d096: 68bb         	ldr	r3, [r7, #0x8]
 800d098: 2b00         	cmp	r3, #0x0
 800d09a: da01         	bge	0x800d0a0 <gpio_stm32_init+0x40> @ imm = #0x2
; 		return ret;
 800d09c: 68bb         	ldr	r3, [r7, #0x8]
 800d09e: e003         	b	0x800d0a8 <gpio_stm32_init+0x48> @ imm = #0x6
; 	(void)pm_device_runtime_enable(dev);
 800d0a0: 6878         	ldr	r0, [r7, #0x4]
 800d0a2: f013 fdc6    	bl	0x8020c32 <pm_device_runtime_enable> @ imm = #0x13b8c
; 	return 0;
 800d0a6: 2300         	movs	r3, #0x0
; }
 800d0a8: 4618         	mov	r0, r3
 800d0aa: 3710         	adds	r7, #0x10
 800d0ac: 46bd         	mov	sp, r7
 800d0ae: bd80         	pop	{r7, pc}

0800d0b0 <$d>:
 800d0b0: c0 96 02 08  	.word	0x080296c0

0800d0b4 <led_gpio_init>:
; {
 800d0b4: b580         	push	{r7, lr}
 800d0b6: b090         	sub	sp, #0x40
 800d0b8: af04         	add	r7, sp, #0x10
 800d0ba: 6078         	str	r0, [r7, #0x4]
; 	const struct led_gpio_config *config = dev->config;
 800d0bc: 687b         	ldr	r3, [r7, #0x4]
 800d0be: 685b         	ldr	r3, [r3, #0x4]
 800d0c0: 627b         	str	r3, [r7, #0x24]
; 	int err = 0;
 800d0c2: 2300         	movs	r3, #0x0
 800d0c4: 62fb         	str	r3, [r7, #0x2c]
; 	if (!config->num_leds) {
 800d0c6: 6a7b         	ldr	r3, [r7, #0x24]
 800d0c8: 681b         	ldr	r3, [r3]
 800d0ca: 2b00         	cmp	r3, #0x0
 800d0cc: d121         	bne	0x800d112 <led_gpio_init+0x5e> @ imm = #0x42
; 		LOG_ERR("%s: no LEDs found (DT child nodes missing)", dev->name);
 800d0ce: 2303         	movs	r3, #0x3
 800d0d0: 2b00         	cmp	r3, #0x0
 800d0d2: d01b         	beq	0x800d10c <led_gpio_init+0x58> @ imm = #0x36
 800d0d4: 2301         	movs	r3, #0x1
 800d0d6: f887 3023    	strb.w	r3, [r7, #0x23]
 800d0da: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800d0de: f083 0301    	eor	r3, r3, #0x1
 800d0e2: b2db         	uxtb	r3, r3
 800d0e4: 2b00         	cmp	r3, #0x0
 800d0e6: d111         	bne	0x800d10c <led_gpio_init+0x58> @ imm = #0x22
 800d0e8: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x800d1e0 <led_gpio_init+0x12c>
 800d0ea: 6819         	ldr	r1, [r3]
 800d0ec: 687b         	ldr	r3, [r7, #0x4]
 800d0ee: 681b         	ldr	r3, [r3]
 800d0f0: 9303         	str	r3, [sp, #0xc]
 800d0f2: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x800d1e4 <led_gpio_init+0x130>
 800d0f4: 9302         	str	r3, [sp, #0x8]
 800d0f6: 2300         	movs	r3, #0x0
 800d0f8: 9301         	str	r3, [sp, #0x4]
 800d0fa: 2300         	movs	r3, #0x0
 800d0fc: 9300         	str	r3, [sp]
 800d0fe: 2300         	movs	r3, #0x0
 800d100: 2201         	movs	r2, #0x1
 800d102: 2000         	movs	r0, #0x0
 800d104: f014 f9fd    	bl	0x8021502 <z_log_msg_runtime_create> @ imm = #0x143fa
 800d108: 2300         	movs	r3, #0x0
 800d10a: 61fb         	str	r3, [r7, #0x1c]
; 		err = -ENODEV;
 800d10c: f06f 0312    	mvn	r3, #0x12
 800d110: 62fb         	str	r3, [r7, #0x2c]
; 	for (size_t i = 0; (i < config->num_leds) && !err; i++) {
 800d112: 2300         	movs	r3, #0x0
 800d114: 62bb         	str	r3, [r7, #0x28]
 800d116: e056         	b	0x800d1c6 <led_gpio_init+0x112> @ imm = #0xac
; 		const struct gpio_dt_spec *led = &config->led[i];
 800d118: 6a7b         	ldr	r3, [r7, #0x24]
 800d11a: 685a         	ldr	r2, [r3, #0x4]
 800d11c: 6abb         	ldr	r3, [r7, #0x28]
 800d11e: 00db         	lsls	r3, r3, #0x3
 800d120: 4413         	add	r3, r2
 800d122: 61bb         	str	r3, [r7, #0x18]
; 		if (device_is_ready(led->port)) {
 800d124: 69bb         	ldr	r3, [r7, #0x18]
 800d126: 681b         	ldr	r3, [r3]
 800d128: 4618         	mov	r0, r3
 800d12a: f014 f8cc    	bl	0x80212c6 <device_is_ready> @ imm = #0x14198
 800d12e: 4603         	mov	r3, r0
 800d130: 2b00         	cmp	r3, #0x0
 800d132: d025         	beq	0x800d180 <led_gpio_init+0xcc> @ imm = #0x4a
; 			err = gpio_pin_configure_dt(led, GPIO_OUTPUT_INACTIVE);
 800d134: f44f 11b0    	mov.w	r1, #0x160000
 800d138: 69b8         	ldr	r0, [r7, #0x18]
 800d13a: f014 f91b    	bl	0x8021374 <gpio_pin_configure_dt> @ imm = #0x14236
 800d13e: 62f8         	str	r0, [r7, #0x2c]
; 			if (err) {
 800d140: 6afb         	ldr	r3, [r7, #0x2c]
 800d142: 2b00         	cmp	r3, #0x0
 800d144: d03c         	beq	0x800d1c0 <led_gpio_init+0x10c> @ imm = #0x78
; 				LOG_ERR("Cannot configure GPIO (err %d)", err);
 800d146: 2303         	movs	r3, #0x3
 800d148: 2b00         	cmp	r3, #0x0
 800d14a: d039         	beq	0x800d1c0 <led_gpio_init+0x10c> @ imm = #0x72
 800d14c: 2301         	movs	r3, #0x1
 800d14e: 73fb         	strb	r3, [r7, #0xf]
 800d150: 7bfb         	ldrb	r3, [r7, #0xf]
 800d152: f083 0301    	eor	r3, r3, #0x1
 800d156: b2db         	uxtb	r3, r3
 800d158: 2b00         	cmp	r3, #0x0
 800d15a: d131         	bne	0x800d1c0 <led_gpio_init+0x10c> @ imm = #0x62
 800d15c: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800d1e0 <led_gpio_init+0x12c>
 800d15e: 6819         	ldr	r1, [r3]
 800d160: 6afb         	ldr	r3, [r7, #0x2c]
 800d162: 9303         	str	r3, [sp, #0xc]
 800d164: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800d1e8 <led_gpio_init+0x134>
 800d166: 9302         	str	r3, [sp, #0x8]
 800d168: 2300         	movs	r3, #0x0
 800d16a: 9301         	str	r3, [sp, #0x4]
 800d16c: 2300         	movs	r3, #0x0
 800d16e: 9300         	str	r3, [sp]
 800d170: 2300         	movs	r3, #0x0
 800d172: 2201         	movs	r2, #0x1
 800d174: 2000         	movs	r0, #0x0
 800d176: f014 f9c4    	bl	0x8021502 <z_log_msg_runtime_create> @ imm = #0x14388
 800d17a: 2300         	movs	r3, #0x0
 800d17c: 60bb         	str	r3, [r7, #0x8]
 800d17e: e01f         	b	0x800d1c0 <led_gpio_init+0x10c> @ imm = #0x3e
; 			LOG_ERR("%s: GPIO device not ready", dev->name);
 800d180: 2303         	movs	r3, #0x3
 800d182: 2b00         	cmp	r3, #0x0
 800d184: d019         	beq	0x800d1ba <led_gpio_init+0x106> @ imm = #0x32
 800d186: 2301         	movs	r3, #0x1
 800d188: 75fb         	strb	r3, [r7, #0x17]
 800d18a: 7dfb         	ldrb	r3, [r7, #0x17]
 800d18c: f083 0301    	eor	r3, r3, #0x1
 800d190: b2db         	uxtb	r3, r3
 800d192: 2b00         	cmp	r3, #0x0
 800d194: d111         	bne	0x800d1ba <led_gpio_init+0x106> @ imm = #0x22
 800d196: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800d1e0 <led_gpio_init+0x12c>
 800d198: 6819         	ldr	r1, [r3]
 800d19a: 687b         	ldr	r3, [r7, #0x4]
 800d19c: 681b         	ldr	r3, [r3]
 800d19e: 9303         	str	r3, [sp, #0xc]
 800d1a0: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800d1ec <led_gpio_init+0x138>
 800d1a2: 9302         	str	r3, [sp, #0x8]
 800d1a4: 2300         	movs	r3, #0x0
 800d1a6: 9301         	str	r3, [sp, #0x4]
 800d1a8: 2300         	movs	r3, #0x0
 800d1aa: 9300         	str	r3, [sp]
 800d1ac: 2300         	movs	r3, #0x0
 800d1ae: 2201         	movs	r2, #0x1
 800d1b0: 2000         	movs	r0, #0x0
 800d1b2: f014 f9a6    	bl	0x8021502 <z_log_msg_runtime_create> @ imm = #0x1434c
 800d1b6: 2300         	movs	r3, #0x0
 800d1b8: 613b         	str	r3, [r7, #0x10]
; 			err = -ENODEV;
 800d1ba: f06f 0312    	mvn	r3, #0x12
 800d1be: 62fb         	str	r3, [r7, #0x2c]
; 	for (size_t i = 0; (i < config->num_leds) && !err; i++) {
 800d1c0: 6abb         	ldr	r3, [r7, #0x28]
 800d1c2: 3301         	adds	r3, #0x1
 800d1c4: 62bb         	str	r3, [r7, #0x28]
 800d1c6: 6a7b         	ldr	r3, [r7, #0x24]
 800d1c8: 681b         	ldr	r3, [r3]
 800d1ca: 6aba         	ldr	r2, [r7, #0x28]
 800d1cc: 429a         	cmp	r2, r3
 800d1ce: d202         	bhs	0x800d1d6 <led_gpio_init+0x122> @ imm = #0x4
 800d1d0: 6afb         	ldr	r3, [r7, #0x2c]
 800d1d2: 2b00         	cmp	r3, #0x0
 800d1d4: d0a0         	beq	0x800d118 <led_gpio_init+0x64> @ imm = #-0xc0
; 	return err;
 800d1d6: 6afb         	ldr	r3, [r7, #0x2c]
; }
 800d1d8: 4618         	mov	r0, r3
 800d1da: 3730         	adds	r7, #0x30
 800d1dc: 46bd         	mov	sp, r7
 800d1de: bd80         	pop	{r7, pc}

0800d1e0 <$d>:
 800d1e0: d4 06 00 24  	.word	0x240006d4
 800d1e4: 20 b9 02 08  	.word	0x0802b920
 800d1e8: 4c b9 02 08  	.word	0x0802b94c
 800d1ec: 6c b9 02 08  	.word	0x0802b96c

0800d1f0 <ws2812_strip_update_rgb>:
; {
 800d1f0: b580         	push	{r7, lr}
 800d1f2: b08e         	sub	sp, #0x38
 800d1f4: af00         	add	r7, sp, #0x0
 800d1f6: 60f8         	str	r0, [r7, #0xc]
 800d1f8: 60b9         	str	r1, [r7, #0x8]
 800d1fa: 607a         	str	r2, [r7, #0x4]
; 	const struct ws2812_spi_cfg *cfg = dev_cfg(dev);
 800d1fc: 68f8         	ldr	r0, [r7, #0xc]
 800d1fe: f014 fabe    	bl	0x802177e <dev_cfg>     @ imm = #0x1457c
 800d202: 62b8         	str	r0, [r7, #0x28]
; 	const uint8_t one = cfg->one_frame, zero = cfg->zero_frame;
 800d204: 6abb         	ldr	r3, [r7, #0x28]
 800d206: 7f1b         	ldrb	r3, [r3, #0x1c]
 800d208: f887 3027    	strb.w	r3, [r7, #0x27]
 800d20c: 6abb         	ldr	r3, [r7, #0x28]
 800d20e: 7f5b         	ldrb	r3, [r3, #0x1d]
 800d210: f887 3026    	strb.w	r3, [r7, #0x26]
; 		.buf = cfg->px_buf,
 800d214: 6abb         	ldr	r3, [r7, #0x28]
 800d216: 699b         	ldr	r3, [r3, #0x18]
; 	struct spi_buf buf = {
 800d218: 61bb         	str	r3, [r7, #0x18]
; 		.len = (cfg->length * 8 * cfg->num_colors),
 800d21a: 6abb         	ldr	r3, [r7, #0x28]
 800d21c: 6a5b         	ldr	r3, [r3, #0x24]
 800d21e: 6aba         	ldr	r2, [r7, #0x28]
 800d220: 7f92         	ldrb	r2, [r2, #0x1e]
 800d222: fb02 f303    	mul	r3, r2, r3
 800d226: 00db         	lsls	r3, r3, #0x3
; 	struct spi_buf buf = {
 800d228: 61fb         	str	r3, [r7, #0x1c]
; 	const struct spi_buf_set tx = {.buffers = &buf, .count = 1};
 800d22a: f107 0318    	add.w	r3, r7, #0x18
 800d22e: 613b         	str	r3, [r7, #0x10]
 800d230: 2301         	movs	r3, #0x1
 800d232: 617b         	str	r3, [r7, #0x14]
; 	uint8_t *px_buf = cfg->px_buf;
 800d234: 6abb         	ldr	r3, [r7, #0x28]
 800d236: 699b         	ldr	r3, [r3, #0x18]
 800d238: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < num_pixels; i++) {
 800d23a: 2300         	movs	r3, #0x0
 800d23c: 633b         	str	r3, [r7, #0x30]
 800d23e: e056         	b	0x800d2ee <ws2812_strip_update_rgb+0xfe> @ imm = #0xac
; 		for (j = 0; j < cfg->num_colors; j++) {
 800d240: 2300         	movs	r3, #0x0
 800d242: f887 302f    	strb.w	r3, [r7, #0x2f]
 800d246: e049         	b	0x800d2dc <ws2812_strip_update_rgb+0xec> @ imm = #0x92
; 			switch (cfg->color_mapping[j]) {
 800d248: 6abb         	ldr	r3, [r7, #0x28]
 800d24a: 6a1a         	ldr	r2, [r3, #0x20]
 800d24c: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800d250: 4413         	add	r3, r2
 800d252: 781b         	ldrb	r3, [r3]
 800d254: 2b03         	cmp	r3, #0x3
 800d256: d82d         	bhi	0x800d2b4 <ws2812_strip_update_rgb+0xc4> @ imm = #0x5a
 800d258: a201         	adr	r2, #4 <ws2812_strip_update_rgb+0x6d>
 800d25a: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 800d25e: bf00         	nop

0800d260 <$d>:
 800d260: 71 d2 00 08  	.word	0x0800d271
 800d264: 79 d2 00 08  	.word	0x0800d279
 800d268: 8d d2 00 08  	.word	0x0800d28d
 800d26c: a1 d2 00 08  	.word	0x0800d2a1

0800d270 <$t>:
; 				pixel = 0;
 800d270: 2300         	movs	r3, #0x0
 800d272: f887 302e    	strb.w	r3, [r7, #0x2e]
; 				break;
 800d276: e020         	b	0x800d2ba <ws2812_strip_update_rgb+0xca> @ imm = #0x40
; 				pixel = pixels[i].r;
 800d278: 6b3a         	ldr	r2, [r7, #0x30]
 800d27a: 4613         	mov	r3, r2
 800d27c: 005b         	lsls	r3, r3, #0x1
 800d27e: 4413         	add	r3, r2
 800d280: 68ba         	ldr	r2, [r7, #0x8]
 800d282: 4413         	add	r3, r2
 800d284: 781b         	ldrb	r3, [r3]
 800d286: f887 302e    	strb.w	r3, [r7, #0x2e]
; 				break;
 800d28a: e016         	b	0x800d2ba <ws2812_strip_update_rgb+0xca> @ imm = #0x2c
; 				pixel = pixels[i].g;
 800d28c: 6b3a         	ldr	r2, [r7, #0x30]
 800d28e: 4613         	mov	r3, r2
 800d290: 005b         	lsls	r3, r3, #0x1
 800d292: 4413         	add	r3, r2
 800d294: 68ba         	ldr	r2, [r7, #0x8]
 800d296: 4413         	add	r3, r2
 800d298: 785b         	ldrb	r3, [r3, #0x1]
 800d29a: f887 302e    	strb.w	r3, [r7, #0x2e]
; 				break;
 800d29e: e00c         	b	0x800d2ba <ws2812_strip_update_rgb+0xca> @ imm = #0x18
; 				pixel = pixels[i].b;
 800d2a0: 6b3a         	ldr	r2, [r7, #0x30]
 800d2a2: 4613         	mov	r3, r2
 800d2a4: 005b         	lsls	r3, r3, #0x1
 800d2a6: 4413         	add	r3, r2
 800d2a8: 68ba         	ldr	r2, [r7, #0x8]
 800d2aa: 4413         	add	r3, r2
 800d2ac: 789b         	ldrb	r3, [r3, #0x2]
 800d2ae: f887 302e    	strb.w	r3, [r7, #0x2e]
; 				break;
 800d2b2: e002         	b	0x800d2ba <ws2812_strip_update_rgb+0xca> @ imm = #0x4
; 				return -EINVAL;
 800d2b4: f06f 0315    	mvn	r3, #0x15
 800d2b8: e02b         	b	0x800d312 <ws2812_strip_update_rgb+0x122> @ imm = #0x56
; 			ws2812_spi_ser(px_buf, pixel, one, zero);
 800d2ba: f897 3026    	ldrb.w	r3, [r7, #0x26]
 800d2be: f897 2027    	ldrb.w	r2, [r7, #0x27]
 800d2c2: f897 102e    	ldrb.w	r1, [r7, #0x2e]
 800d2c6: 6b78         	ldr	r0, [r7, #0x34]
 800d2c8: f014 fa65    	bl	0x8021796 <ws2812_spi_ser> @ imm = #0x144ca
; 			px_buf += 8;
 800d2cc: 6b7b         	ldr	r3, [r7, #0x34]
 800d2ce: 3308         	adds	r3, #0x8
 800d2d0: 637b         	str	r3, [r7, #0x34]
; 		for (j = 0; j < cfg->num_colors; j++) {
 800d2d2: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800d2d6: 3301         	adds	r3, #0x1
 800d2d8: f887 302f    	strb.w	r3, [r7, #0x2f]
 800d2dc: 6abb         	ldr	r3, [r7, #0x28]
 800d2de: 7f9b         	ldrb	r3, [r3, #0x1e]
 800d2e0: f897 202f    	ldrb.w	r2, [r7, #0x2f]
 800d2e4: 429a         	cmp	r2, r3
 800d2e6: d3af         	blo	0x800d248 <ws2812_strip_update_rgb+0x58> @ imm = #-0xa2
; 	for (i = 0; i < num_pixels; i++) {
 800d2e8: 6b3b         	ldr	r3, [r7, #0x30]
 800d2ea: 3301         	adds	r3, #0x1
 800d2ec: 633b         	str	r3, [r7, #0x30]
 800d2ee: 6b3a         	ldr	r2, [r7, #0x30]
 800d2f0: 687b         	ldr	r3, [r7, #0x4]
 800d2f2: 429a         	cmp	r2, r3
 800d2f4: d3a4         	blo	0x800d240 <ws2812_strip_update_rgb+0x50> @ imm = #-0xb8
; 	rc = spi_write_dt(&cfg->bus, &tx);
 800d2f6: 6abb         	ldr	r3, [r7, #0x28]
 800d2f8: f107 0210    	add.w	r2, r7, #0x10
 800d2fc: 4611         	mov	r1, r2
 800d2fe: 4618         	mov	r0, r3
 800d300: f014 fa19    	bl	0x8021736 <spi_write_dt> @ imm = #0x14432
 800d304: 6238         	str	r0, [r7, #0x20]
; 	ws2812_reset_delay(cfg->reset_delay);
 800d306: 6abb         	ldr	r3, [r7, #0x28]
 800d308: 8d1b         	ldrh	r3, [r3, #0x28]
 800d30a: 4618         	mov	r0, r3
 800d30c: f014 fa71    	bl	0x80217f2 <ws2812_reset_delay> @ imm = #0x144e2
; 	return rc;
 800d310: 6a3b         	ldr	r3, [r7, #0x20]
; }
 800d312: 4618         	mov	r0, r3
 800d314: 3738         	adds	r7, #0x38
 800d316: 46bd         	mov	sp, r7
 800d318: bd80         	pop	{r7, pc}
 800d31a: bf00         	nop

0800d31c <ws2812_spi_init>:
; {
 800d31c: b580         	push	{r7, lr}
 800d31e: b08c         	sub	sp, #0x30
 800d320: af04         	add	r7, sp, #0x10
 800d322: 6078         	str	r0, [r7, #0x4]
; 	const struct ws2812_spi_cfg *cfg = dev_cfg(dev);
 800d324: 6878         	ldr	r0, [r7, #0x4]
 800d326: f014 fa2a    	bl	0x802177e <dev_cfg>     @ imm = #0x14454
 800d32a: 61f8         	str	r0, [r7, #0x1c]
; 	if (!spi_is_ready_dt(&cfg->bus)) {
 800d32c: 69fb         	ldr	r3, [r7, #0x1c]
 800d32e: 4618         	mov	r0, r3
 800d330: f014 f9b0    	bl	0x8021694 <spi_is_ready_dt> @ imm = #0x14360
 800d334: 4603         	mov	r3, r0
 800d336: f083 0301    	eor	r3, r3, #0x1
 800d33a: b2db         	uxtb	r3, r3
 800d33c: 2b00         	cmp	r3, #0x0
 800d33e: d020         	beq	0x800d382 <ws2812_spi_init+0x66> @ imm = #0x40
; 		LOG_ERR("SPI device %s not ready", cfg->bus.bus->name);
 800d340: 2304         	movs	r3, #0x4
 800d342: 2b00         	cmp	r3, #0x0
 800d344: d01a         	beq	0x800d37c <ws2812_spi_init+0x60> @ imm = #0x34
 800d346: 2301         	movs	r3, #0x1
 800d348: 74fb         	strb	r3, [r7, #0x13]
 800d34a: 7cfb         	ldrb	r3, [r7, #0x13]
 800d34c: f083 0301    	eor	r3, r3, #0x1
 800d350: b2db         	uxtb	r3, r3
 800d352: 2b00         	cmp	r3, #0x0
 800d354: d112         	bne	0x800d37c <ws2812_spi_init+0x60> @ imm = #0x24
 800d356: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800d3f4 <ws2812_spi_init+0xd8>
 800d358: 6819         	ldr	r1, [r3]
 800d35a: 69fb         	ldr	r3, [r7, #0x1c]
 800d35c: 681b         	ldr	r3, [r3]
 800d35e: 681b         	ldr	r3, [r3]
 800d360: 9303         	str	r3, [sp, #0xc]
 800d362: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800d3f8 <ws2812_spi_init+0xdc>
 800d364: 9302         	str	r3, [sp, #0x8]
 800d366: 2300         	movs	r3, #0x0
 800d368: 9301         	str	r3, [sp, #0x4]
 800d36a: 2300         	movs	r3, #0x0
 800d36c: 9300         	str	r3, [sp]
 800d36e: 2300         	movs	r3, #0x0
 800d370: 2201         	movs	r2, #0x1
 800d372: 2000         	movs	r0, #0x0
 800d374: f014 f937    	bl	0x80215e6 <z_log_msg_runtime_create> @ imm = #0x1426e
 800d378: 2300         	movs	r3, #0x0
 800d37a: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800d37c: f06f 0312    	mvn	r3, #0x12
 800d380: e033         	b	0x800d3ea <ws2812_spi_init+0xce> @ imm = #0x66
; 	for (i = 0; i < cfg->num_colors; i++) {
 800d382: 2300         	movs	r3, #0x0
 800d384: 76fb         	strb	r3, [r7, #0x1b]
 800d386: e02a         	b	0x800d3de <ws2812_spi_init+0xc2> @ imm = #0x54
; 		switch (cfg->color_mapping[i]) {
 800d388: 69fb         	ldr	r3, [r7, #0x1c]
 800d38a: 6a1a         	ldr	r2, [r3, #0x20]
 800d38c: 7efb         	ldrb	r3, [r7, #0x1b]
 800d38e: 4413         	add	r3, r2
 800d390: 781b         	ldrb	r3, [r3]
 800d392: 2b03         	cmp	r3, #0x3
 800d394: d91f         	bls	0x800d3d6 <ws2812_spi_init+0xba> @ imm = #0x3e
; 			LOG_ERR("%s: invalid channel to color mapping."
 800d396: 2304         	movs	r3, #0x4
 800d398: 2b00         	cmp	r3, #0x0
 800d39a: d019         	beq	0x800d3d0 <ws2812_spi_init+0xb4> @ imm = #0x32
 800d39c: 2301         	movs	r3, #0x1
 800d39e: 76bb         	strb	r3, [r7, #0x1a]
 800d3a0: 7ebb         	ldrb	r3, [r7, #0x1a]
 800d3a2: f083 0301    	eor	r3, r3, #0x1
 800d3a6: b2db         	uxtb	r3, r3
 800d3a8: 2b00         	cmp	r3, #0x0
 800d3aa: d111         	bne	0x800d3d0 <ws2812_spi_init+0xb4> @ imm = #0x22
 800d3ac: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800d3f4 <ws2812_spi_init+0xd8>
 800d3ae: 6819         	ldr	r1, [r3]
 800d3b0: 687b         	ldr	r3, [r7, #0x4]
 800d3b2: 681b         	ldr	r3, [r3]
 800d3b4: 9303         	str	r3, [sp, #0xc]
 800d3b6: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800d3fc <ws2812_spi_init+0xe0>
 800d3b8: 9302         	str	r3, [sp, #0x8]
 800d3ba: 2300         	movs	r3, #0x0
 800d3bc: 9301         	str	r3, [sp, #0x4]
 800d3be: 2300         	movs	r3, #0x0
 800d3c0: 9300         	str	r3, [sp]
 800d3c2: 2300         	movs	r3, #0x0
 800d3c4: 2201         	movs	r2, #0x1
 800d3c6: 2000         	movs	r0, #0x0
 800d3c8: f014 f90d    	bl	0x80215e6 <z_log_msg_runtime_create> @ imm = #0x1421a
 800d3cc: 2300         	movs	r3, #0x0
 800d3ce: 617b         	str	r3, [r7, #0x14]
; 			return -EINVAL;
 800d3d0: f06f 0315    	mvn	r3, #0x15
 800d3d4: e009         	b	0x800d3ea <ws2812_spi_init+0xce> @ imm = #0x12
; 			break;
 800d3d6: bf00         	nop
; 	for (i = 0; i < cfg->num_colors; i++) {
 800d3d8: 7efb         	ldrb	r3, [r7, #0x1b]
 800d3da: 3301         	adds	r3, #0x1
 800d3dc: 76fb         	strb	r3, [r7, #0x1b]
 800d3de: 69fb         	ldr	r3, [r7, #0x1c]
 800d3e0: 7f9b         	ldrb	r3, [r3, #0x1e]
 800d3e2: 7efa         	ldrb	r2, [r7, #0x1b]
 800d3e4: 429a         	cmp	r2, r3
 800d3e6: d3cf         	blo	0x800d388 <ws2812_spi_init+0x6c> @ imm = #-0x62
; 	return 0;
 800d3e8: 2300         	movs	r3, #0x0
; }
 800d3ea: 4618         	mov	r0, r3
 800d3ec: 3720         	adds	r7, #0x20
 800d3ee: 46bd         	mov	sp, r7
 800d3f0: bd80         	pop	{r7, pc}
 800d3f2: bf00         	nop

0800d3f4 <$d>:
 800d3f4: d8 06 00 24  	.word	0x240006d8
 800d3f8: 9c b9 02 08  	.word	0x0802b99c
 800d3fc: b4 b9 02 08  	.word	0x0802b9b4

0800d400 <stm32_pin_configure>:
; {
 800d400: b580         	push	{r7, lr}
 800d402: b086         	sub	sp, #0x18
 800d404: af00         	add	r7, sp, #0x0
 800d406: 60f8         	str	r0, [r7, #0xc]
 800d408: 60b9         	str	r1, [r7, #0x8]
 800d40a: 607a         	str	r2, [r7, #0x4]
; 	if (STM32_PORT(pin) >= gpio_ports_cnt) {
 800d40c: 68fb         	ldr	r3, [r7, #0xc]
 800d40e: 091b         	lsrs	r3, r3, #0x4
 800d410: 2210         	movs	r2, #0x10
 800d412: 4293         	cmp	r3, r2
 800d414: d302         	blo	0x800d41c <stm32_pin_configure+0x1c> @ imm = #0x4
; 		return -EINVAL;
 800d416: f06f 0315    	mvn	r3, #0x15
 800d41a: e01f         	b	0x800d45c <stm32_pin_configure+0x5c> @ imm = #0x3e
; 	port_device = gpio_ports[STM32_PORT(pin)];
 800d41c: 68fb         	ldr	r3, [r7, #0xc]
 800d41e: 091b         	lsrs	r3, r3, #0x4
 800d420: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800d464 <stm32_pin_configure+0x64>
 800d422: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800d426: 617b         	str	r3, [r7, #0x14]
; 	if ((port_device == NULL) || (!device_is_ready(port_device))) {
 800d428: 697b         	ldr	r3, [r7, #0x14]
 800d42a: 2b00         	cmp	r3, #0x0
 800d42c: d008         	beq	0x800d440 <stm32_pin_configure+0x40> @ imm = #0x10
 800d42e: 6978         	ldr	r0, [r7, #0x14]
 800d430: f014 fa26    	bl	0x8021880 <device_is_ready> @ imm = #0x1444c
 800d434: 4603         	mov	r3, r0
 800d436: f083 0301    	eor	r3, r3, #0x1
 800d43a: b2db         	uxtb	r3, r3
 800d43c: 2b00         	cmp	r3, #0x0
 800d43e: d002         	beq	0x800d446 <stm32_pin_configure+0x46> @ imm = #0x4
; 		return -ENODEV;
 800d440: f06f 0312    	mvn	r3, #0x12
 800d444: e00a         	b	0x800d45c <stm32_pin_configure+0x5c> @ imm = #0x14
; 	return gpio_stm32_configure(port_device, STM32_PIN(pin), pin_cgf, pin_func);
 800d446: 68fb         	ldr	r3, [r7, #0xc]
 800d448: b2db         	uxtb	r3, r3
 800d44a: f003 030f    	and	r3, r3, #0xf
 800d44e: b2d9         	uxtb	r1, r3
 800d450: 687b         	ldr	r3, [r7, #0x4]
 800d452: 68ba         	ldr	r2, [r7, #0x8]
 800d454: 6978         	ldr	r0, [r7, #0x14]
 800d456: f013 fe56    	bl	0x8021106 <gpio_stm32_configure> @ imm = #0x13cac
 800d45a: 4603         	mov	r3, r0
; }
 800d45c: 4618         	mov	r0, r3
 800d45e: 3718         	adds	r7, #0x18
 800d460: 46bd         	mov	sp, r7
 800d462: bd80         	pop	{r7, pc}

0800d464 <$d>:
 800d464: 40 d5 02 08  	.word	0x0802d540

0800d468 <bmi08x_bus_init_spi>:
; {
 800d468: b580         	push	{r7, lr}
 800d46a: b08a         	sub	sp, #0x28
 800d46c: af04         	add	r7, sp, #0x10
 800d46e: 6078         	str	r0, [r7, #0x4]
; 	ret = bmi08x_accel_byte_read(dev, 0x7F, &val);
 800d470: f107 030b    	add.w	r3, r7, #0xb
 800d474: 461a         	mov	r2, r3
 800d476: 217f         	movs	r1, #0x7f
 800d478: 6878         	ldr	r0, [r7, #0x4]
 800d47a: f014 fcf3    	bl	0x8021e64 <bmi08x_accel_byte_read> @ imm = #0x149e6
 800d47e: 6178         	str	r0, [r7, #0x14]
; 	if (ret < 0) {
 800d480: 697b         	ldr	r3, [r7, #0x14]
 800d482: 2b00         	cmp	r3, #0x0
 800d484: da1b         	bge	0x800d4be <bmi08x_bus_init_spi+0x56> @ imm = #0x36
; 		LOG_ERR("Cannot read from 0x7F..");
 800d486: 2303         	movs	r3, #0x3
 800d488: 2b00         	cmp	r3, #0x0
 800d48a: d016         	beq	0x800d4ba <bmi08x_bus_init_spi+0x52> @ imm = #0x2c
 800d48c: 2301         	movs	r3, #0x1
 800d48e: 74fb         	strb	r3, [r7, #0x13]
 800d490: 7cfb         	ldrb	r3, [r7, #0x13]
 800d492: f083 0301    	eor	r3, r3, #0x1
 800d496: b2db         	uxtb	r3, r3
 800d498: 2b00         	cmp	r3, #0x0
 800d49a: d10e         	bne	0x800d4ba <bmi08x_bus_init_spi+0x52> @ imm = #0x1c
 800d49c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800d4d0 <bmi08x_bus_init_spi+0x68>
 800d49e: 6819         	ldr	r1, [r3]
 800d4a0: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800d4d4 <bmi08x_bus_init_spi+0x6c>
 800d4a2: 9302         	str	r3, [sp, #0x8]
 800d4a4: 2300         	movs	r3, #0x0
 800d4a6: 9301         	str	r3, [sp, #0x4]
 800d4a8: 2300         	movs	r3, #0x0
 800d4aa: 9300         	str	r3, [sp]
 800d4ac: 2300         	movs	r3, #0x0
 800d4ae: 2201         	movs	r2, #0x1
 800d4b0: 2000         	movs	r0, #0x0
 800d4b2: f014 fb49    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x14692
 800d4b6: 2300         	movs	r3, #0x0
 800d4b8: 60fb         	str	r3, [r7, #0xc]
; 		return ret;
 800d4ba: 697b         	ldr	r3, [r7, #0x14]
 800d4bc: e003         	b	0x800d4c6 <bmi08x_bus_init_spi+0x5e> @ imm = #0x6
; 	k_usleep(100);
 800d4be: 2064         	movs	r0, #0x64
 800d4c0: f014 fb22    	bl	0x8021b08 <k_usleep>    @ imm = #0x14644
; 	return ret;
 800d4c4: 697b         	ldr	r3, [r7, #0x14]
; }
 800d4c6: 4618         	mov	r0, r3
 800d4c8: 3718         	adds	r7, #0x18
 800d4ca: 46bd         	mov	sp, r7
 800d4cc: bd80         	pop	{r7, pc}
 800d4ce: bf00         	nop

0800d4d0 <$d>:
 800d4d0: dc 06 00 24  	.word	0x240006dc
 800d4d4: 30 ba 02 08  	.word	0x0802ba30

0800d4d8 <bmi08x_acc_range_set>:
; {
 800d4d8: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800d4dc: b086         	sub	sp, #0x18
 800d4de: af00         	add	r7, sp, #0x0
 800d4e0: 6078         	str	r0, [r7, #0x4]
 800d4e2: 6039         	str	r1, [r7]
; 	struct bmi08x_accel_data *data = dev->data;
 800d4e4: 687b         	ldr	r3, [r7, #0x4]
 800d4e6: 691b         	ldr	r3, [r3, #0x10]
 800d4e8: 613b         	str	r3, [r7, #0x10]
; 	int32_t reg_val = -1;
 800d4ea: f04f 33ff    	mov.w	r3, #0xffffffff
 800d4ee: 617b         	str	r3, [r7, #0x14]
; 	if (data->accel_chip_id == BMI085_ACCEL_CHIP_ID) {
 800d4f0: 693b         	ldr	r3, [r7, #0x10]
 800d4f2: f893 3748    	ldrb.w	r3, [r3, #0x748]
 800d4f6: 2b1f         	cmp	r3, #0x1f
 800d4f8: d108         	bne	0x800d50c <bmi08x_acc_range_set+0x34> @ imm = #0x10
; 		reg_val = bmi08x_range_to_reg_val(range, bmi085_acc_range_map,
 800d4fa: 683b         	ldr	r3, [r7]
 800d4fc: b29b         	uxth	r3, r3
 800d4fe: 2204         	movs	r2, #0x4
 800d500: 492b         	ldr	r1, [pc, #0xac]         @ 0x800d5b0 <bmi08x_acc_range_set+0xd8>
 800d502: 4618         	mov	r0, r3
 800d504: f015 f822    	bl	0x802254c <bmi08x_range_to_reg_val> @ imm = #0x15044
 800d508: 6178         	str	r0, [r7, #0x14]
 800d50a: e010         	b	0x800d52e <bmi08x_acc_range_set+0x56> @ imm = #0x20
; 	} else if (data->accel_chip_id == BMI088_ACCEL_CHIP_ID) {
 800d50c: 693b         	ldr	r3, [r7, #0x10]
 800d50e: f893 3748    	ldrb.w	r3, [r3, #0x748]
 800d512: 2b1e         	cmp	r3, #0x1e
 800d514: d108         	bne	0x800d528 <bmi08x_acc_range_set+0x50> @ imm = #0x10
; 		reg_val = bmi08x_range_to_reg_val(range, bmi088_acc_range_map,
 800d516: 683b         	ldr	r3, [r7]
 800d518: b29b         	uxth	r3, r3
 800d51a: 2204         	movs	r2, #0x4
 800d51c: 4925         	ldr	r1, [pc, #0x94]         @ 0x800d5b4 <bmi08x_acc_range_set+0xdc>
 800d51e: 4618         	mov	r0, r3
 800d520: f015 f814    	bl	0x802254c <bmi08x_range_to_reg_val> @ imm = #0x15028
 800d524: 6178         	str	r0, [r7, #0x14]
 800d526: e002         	b	0x800d52e <bmi08x_acc_range_set+0x56> @ imm = #0x4
; 		return -ENODEV;
 800d528: f06f 0312    	mvn	r3, #0x12
 800d52c: e03b         	b	0x800d5a6 <bmi08x_acc_range_set+0xce> @ imm = #0x76
; 	if (reg_val < 0) {
 800d52e: 697b         	ldr	r3, [r7, #0x14]
 800d530: 2b00         	cmp	r3, #0x0
 800d532: da01         	bge	0x800d538 <bmi08x_acc_range_set+0x60> @ imm = #0x2
; 		return reg_val;
 800d534: 697b         	ldr	r3, [r7, #0x14]
 800d536: e036         	b	0x800d5a6 <bmi08x_acc_range_set+0xce> @ imm = #0x6c
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_RANGE, reg_val & 0xff);
 800d538: 697b         	ldr	r3, [r7, #0x14]
 800d53a: b2db         	uxtb	r3, r3
 800d53c: 461a         	mov	r2, r3
 800d53e: 2141         	movs	r1, #0x41
 800d540: 6878         	ldr	r0, [r7, #0x4]
 800d542: f014 fcc7    	bl	0x8021ed4 <bmi08x_accel_byte_write> @ imm = #0x1498e
 800d546: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 800d548: 68fb         	ldr	r3, [r7, #0xc]
 800d54a: 2b00         	cmp	r3, #0x0
 800d54c: da01         	bge	0x800d552 <bmi08x_acc_range_set+0x7a> @ imm = #0x2
; 		return ret;
 800d54e: 68fb         	ldr	r3, [r7, #0xc]
 800d550: e029         	b	0x800d5a6 <bmi08x_acc_range_set+0xce> @ imm = #0x52
; 	data->scale = BMI08X_ACC_SCALE(range);
 800d552: 683b         	ldr	r3, [r7]
 800d554: 17da         	asrs	r2, r3, #0x1f
 800d556: 4698         	mov	r8, r3
 800d558: 4691         	mov	r9, r2
 800d55a: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800d5b8 <bmi08x_acc_range_set+0xe0>
 800d55c: fb03 f209    	mul	r2, r3, r9
 800d560: 2300         	movs	r3, #0x0
 800d562: fb03 f308    	mul	r3, r3, r8
 800d566: 4413         	add	r3, r2
 800d568: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800d5b8 <bmi08x_acc_range_set+0xe0>
 800d56a: fba8 4502    	umull	r4, r5, r8, r2
 800d56e: 442b         	add	r3, r5
 800d570: 461d         	mov	r5, r3
 800d572: 4622         	mov	r2, r4
 800d574: 462b         	mov	r3, r5
 800d576: 2b00         	cmp	r3, #0x0
 800d578: da07         	bge	0x800d58a <bmi08x_acc_range_set+0xb2> @ imm = #0xe
 800d57a: f64f 71ff    	movw	r1, #0xffff
 800d57e: eb12 0a01    	adds.w	r10, r2, r1
 800d582: f143 0b00    	adc	r11, r3, #0x0
 800d586: 4652         	mov	r2, r10
 800d588: 465b         	mov	r3, r11
 800d58a: f04f 0000    	mov.w	r0, #0x0
 800d58e: f04f 0100    	mov.w	r1, #0x0
 800d592: 0c10         	lsrs	r0, r2, #0x10
 800d594: ea40 4003    	orr.w	r0, r0, r3, lsl #16
 800d598: 1419         	asrs	r1, r3, #0x10
 800d59a: 4602         	mov	r2, r0
 800d59c: 460b         	mov	r3, r1
 800d59e: b292         	uxth	r2, r2
 800d5a0: 693b         	ldr	r3, [r7, #0x10]
 800d5a2: 825a         	strh	r2, [r3, #0x12]
; 	return ret;
 800d5a4: 68fb         	ldr	r3, [r7, #0xc]
; }
 800d5a6: 4618         	mov	r0, r3
 800d5a8: 3718         	adds	r7, #0x18
 800d5aa: 46bd         	mov	sp, r7
 800d5ac: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800d5b0 <$d>:
 800d5b0: 90 d5 02 08  	.word	0x0802d590
 800d5b4: a0 d5 02 08  	.word	0x0802d5a0
 800d5b8: 74 46 2b 01  	.word	0x012b4674

0800d5bc <bmi08x_acc_config>:
; {
 800d5bc: b580         	push	{r7, lr}
 800d5be: b08a         	sub	sp, #0x28
 800d5c0: af04         	add	r7, sp, #0x10
 800d5c2: 60f8         	str	r0, [r7, #0xc]
 800d5c4: 607b         	str	r3, [r7, #0x4]
 800d5c6: 460b         	mov	r3, r1
 800d5c8: 817b         	strh	r3, [r7, #0xa]
 800d5ca: 4613         	mov	r3, r2
 800d5cc: 813b         	strh	r3, [r7, #0x8]
; 	switch (attr) {
 800d5ce: 893b         	ldrh	r3, [r7, #0x8]
 800d5d0: 2b00         	cmp	r3, #0x0
 800d5d2: d00b         	beq	0x800d5ec <bmi08x_acc_config+0x30> @ imm = #0x16
 800d5d4: 2b07         	cmp	r3, #0x7
 800d5d6: d11b         	bne	0x800d610 <bmi08x_acc_config+0x54> @ imm = #0x36
; 		return bmi08x_acc_range_set(dev, sensor_ms2_to_g(val));
 800d5d8: 6878         	ldr	r0, [r7, #0x4]
 800d5da: f7f3 f845    	bl	0x8000668 <sensor_ms2_to_g> @ imm = #-0xcf76
 800d5de: 4603         	mov	r3, r0
 800d5e0: 4619         	mov	r1, r3
 800d5e2: 68f8         	ldr	r0, [r7, #0xc]
 800d5e4: f7ff ff78    	bl	0x800d4d8 <bmi08x_acc_range_set> @ imm = #-0x110
 800d5e8: 4603         	mov	r3, r0
 800d5ea: e02f         	b	0x800d64c <bmi08x_acc_config+0x90> @ imm = #0x5e
; 		return bmi08x_acc_odr_set(dev, val->val1, val->val2 / 1000);
 800d5ec: 687b         	ldr	r3, [r7, #0x4]
 800d5ee: 681b         	ldr	r3, [r3]
 800d5f0: b299         	uxth	r1, r3
 800d5f2: 687b         	ldr	r3, [r7, #0x4]
 800d5f4: 685b         	ldr	r3, [r3, #0x4]
 800d5f6: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800d654 <bmi08x_acc_config+0x98>
 800d5f8: fb82 0203    	smull	r0, r2, r2, r3
 800d5fc: 1192         	asrs	r2, r2, #0x6
 800d5fe: 17db         	asrs	r3, r3, #0x1f
 800d600: 1ad3         	subs	r3, r2, r3
 800d602: b29b         	uxth	r3, r3
 800d604: 461a         	mov	r2, r3
 800d606: 68f8         	ldr	r0, [r7, #0xc]
 800d608: f014 fcb4    	bl	0x8021f74 <bmi08x_acc_odr_set> @ imm = #0x14968
 800d60c: 4603         	mov	r3, r0
 800d60e: e01d         	b	0x800d64c <bmi08x_acc_config+0x90> @ imm = #0x3a
; 		LOG_DBG("Accel attribute not supported.");
 800d610: 2303         	movs	r3, #0x3
 800d612: 2b03         	cmp	r3, #0x3
 800d614: d918         	bls	0x800d648 <bmi08x_acc_config+0x8c> @ imm = #0x30
 800d616: 2301         	movs	r3, #0x1
 800d618: 75fb         	strb	r3, [r7, #0x17]
 800d61a: 7dfb         	ldrb	r3, [r7, #0x17]
 800d61c: f083 0301    	eor	r3, r3, #0x1
 800d620: b2db         	uxtb	r3, r3
 800d622: 2b00         	cmp	r3, #0x0
 800d624: d110         	bne	0x800d648 <bmi08x_acc_config+0x8c> @ imm = #0x20
 800d626: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800d658 <bmi08x_acc_config+0x9c>
 800d628: 6819         	ldr	r1, [r3]
 800d62a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800d65c <bmi08x_acc_config+0xa0>
 800d62c: 9303         	str	r3, [sp, #0xc]
 800d62e: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800d660 <bmi08x_acc_config+0xa4>
 800d630: 9302         	str	r3, [sp, #0x8]
 800d632: 2308         	movs	r3, #0x8
 800d634: 9301         	str	r3, [sp, #0x4]
 800d636: 2300         	movs	r3, #0x0
 800d638: 9300         	str	r3, [sp]
 800d63a: 2300         	movs	r3, #0x0
 800d63c: 2204         	movs	r2, #0x4
 800d63e: 2000         	movs	r0, #0x0
 800d640: f014 fa82    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x14504
 800d644: 2300         	movs	r3, #0x0
 800d646: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800d648: f06f 0385    	mvn	r3, #0x85
; }
 800d64c: 4618         	mov	r0, r3
 800d64e: 3718         	adds	r7, #0x18
 800d650: 46bd         	mov	sp, r7
 800d652: bd80         	pop	{r7, pc}

0800d654 <$d>:
 800d654: d3 4d 62 10  	.word	0x10624dd3
 800d658: dc 06 00 24  	.word	0x240006dc
 800d65c: dc d5 02 08  	.word	0x0802d5dc
 800d660: 48 ba 02 08  	.word	0x0802ba48

0800d664 <bmi08x_attr_set>:
; {
 800d664: b580         	push	{r7, lr}
 800d666: b08a         	sub	sp, #0x28
 800d668: af04         	add	r7, sp, #0x10
 800d66a: 60f8         	str	r0, [r7, #0xc]
 800d66c: 607b         	str	r3, [r7, #0x4]
 800d66e: 460b         	mov	r3, r1
 800d670: 817b         	strh	r3, [r7, #0xa]
 800d672: 4613         	mov	r3, r2
 800d674: 813b         	strh	r3, [r7, #0x8]
; 	switch (chan) {
 800d676: 897b         	ldrh	r3, [r7, #0xa]
 800d678: 2b03         	cmp	r3, #0x3
 800d67a: d807         	bhi	0x800d68c <bmi08x_attr_set+0x28> @ imm = #0xe
; 		return bmi08x_acc_config(dev, chan, attr, val);
 800d67c: 893a         	ldrh	r2, [r7, #0x8]
 800d67e: 8979         	ldrh	r1, [r7, #0xa]
 800d680: 687b         	ldr	r3, [r7, #0x4]
 800d682: 68f8         	ldr	r0, [r7, #0xc]
 800d684: f7ff ff9a    	bl	0x800d5bc <bmi08x_acc_config> @ imm = #-0xcc
 800d688: 4603         	mov	r3, r0
 800d68a: e01d         	b	0x800d6c8 <bmi08x_attr_set+0x64> @ imm = #0x3a
; 		LOG_DBG("attr_set() not supported on this channel.");
 800d68c: 2303         	movs	r3, #0x3
 800d68e: 2b03         	cmp	r3, #0x3
 800d690: d918         	bls	0x800d6c4 <bmi08x_attr_set+0x60> @ imm = #0x30
 800d692: 2301         	movs	r3, #0x1
 800d694: 75fb         	strb	r3, [r7, #0x17]
 800d696: 7dfb         	ldrb	r3, [r7, #0x17]
 800d698: f083 0301    	eor	r3, r3, #0x1
 800d69c: b2db         	uxtb	r3, r3
 800d69e: 2b00         	cmp	r3, #0x0
 800d6a0: d110         	bne	0x800d6c4 <bmi08x_attr_set+0x60> @ imm = #0x20
 800d6a2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800d6d0 <bmi08x_attr_set+0x6c>
 800d6a4: 6819         	ldr	r1, [r3]
 800d6a6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800d6d4 <bmi08x_attr_set+0x70>
 800d6a8: 9303         	str	r3, [sp, #0xc]
 800d6aa: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800d6d8 <bmi08x_attr_set+0x74>
 800d6ac: 9302         	str	r3, [sp, #0x8]
 800d6ae: 2308         	movs	r3, #0x8
 800d6b0: 9301         	str	r3, [sp, #0x4]
 800d6b2: 2300         	movs	r3, #0x0
 800d6b4: 9300         	str	r3, [sp]
 800d6b6: 2300         	movs	r3, #0x0
 800d6b8: 2204         	movs	r2, #0x4
 800d6ba: 2000         	movs	r0, #0x0
 800d6bc: f014 fa44    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x14488
 800d6c0: 2300         	movs	r3, #0x0
 800d6c2: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800d6c4: f06f 0385    	mvn	r3, #0x85
; }
 800d6c8: 4618         	mov	r0, r3
 800d6ca: 3718         	adds	r7, #0x18
 800d6cc: 46bd         	mov	sp, r7
 800d6ce: bd80         	pop	{r7, pc}

0800d6d0 <$d>:
 800d6d0: dc 06 00 24  	.word	0x240006dc
 800d6d4: f0 d5 02 08  	.word	0x0802d5f0
 800d6d8: 6c ba 02 08  	.word	0x0802ba6c

0800d6dc <bmi08x_sample_fetch>:
; {
 800d6dc: b580         	push	{r7, lr}
 800d6de: b08c         	sub	sp, #0x30
 800d6e0: af04         	add	r7, sp, #0x10
 800d6e2: 6078         	str	r0, [r7, #0x4]
 800d6e4: 460b         	mov	r3, r1
 800d6e6: 807b         	strh	r3, [r7, #0x2]
; 	struct bmi08x_accel_data *data = dev->data;
 800d6e8: 687b         	ldr	r3, [r7, #0x4]
 800d6ea: 691b         	ldr	r3, [r3, #0x10]
 800d6ec: 61bb         	str	r3, [r7, #0x18]
; 	if (chan != SENSOR_CHAN_ALL && chan != SENSOR_CHAN_ACCEL_XYZ) {
 800d6ee: 887b         	ldrh	r3, [r7, #0x2]
 800d6f0: 2b3c         	cmp	r3, #0x3c
 800d6f2: d021         	beq	0x800d738 <bmi08x_sample_fetch+0x5c> @ imm = #0x42
 800d6f4: 887b         	ldrh	r3, [r7, #0x2]
 800d6f6: 2b03         	cmp	r3, #0x3
 800d6f8: d01e         	beq	0x800d738 <bmi08x_sample_fetch+0x5c> @ imm = #0x3c
; 		LOG_DBG("Unsupported sensor channel");
 800d6fa: 2303         	movs	r3, #0x3
 800d6fc: 2b03         	cmp	r3, #0x3
 800d6fe: d918         	bls	0x800d732 <bmi08x_sample_fetch+0x56> @ imm = #0x30
 800d700: 2301         	movs	r3, #0x1
 800d702: 75fb         	strb	r3, [r7, #0x17]
 800d704: 7dfb         	ldrb	r3, [r7, #0x17]
 800d706: f083 0301    	eor	r3, r3, #0x1
 800d70a: b2db         	uxtb	r3, r3
 800d70c: 2b00         	cmp	r3, #0x0
 800d70e: d110         	bne	0x800d732 <bmi08x_sample_fetch+0x56> @ imm = #0x20
 800d710: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800d79c <bmi08x_sample_fetch+0xc0>
 800d712: 6819         	ldr	r1, [r3]
 800d714: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800d7a0 <bmi08x_sample_fetch+0xc4>
 800d716: 9303         	str	r3, [sp, #0xc]
 800d718: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800d7a4 <bmi08x_sample_fetch+0xc8>
 800d71a: 9302         	str	r3, [sp, #0x8]
 800d71c: 2308         	movs	r3, #0x8
 800d71e: 9301         	str	r3, [sp, #0x4]
 800d720: 2300         	movs	r3, #0x0
 800d722: 9300         	str	r3, [sp]
 800d724: 2300         	movs	r3, #0x0
 800d726: 2204         	movs	r2, #0x4
 800d728: 2000         	movs	r0, #0x0
 800d72a: f014 fa0d    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x1441a
 800d72e: 2300         	movs	r3, #0x0
 800d730: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800d732: f06f 0385    	mvn	r3, #0x85
 800d736: e02d         	b	0x800d794 <bmi08x_sample_fetch+0xb8> @ imm = #0x5a
; 	pm_device_busy_set(dev);
 800d738: 6878         	ldr	r0, [r7, #0x4]
 800d73a: f014 f9f1    	bl	0x8021b20 <pm_device_busy_set> @ imm = #0x143e2
; 	ret = bmi08x_accel_read(dev, BMI08X_REG_ACCEL_X_LSB, (uint8_t *)data->acc_sample,
 800d73e: 69bb         	ldr	r3, [r7, #0x18]
 800d740: f103 020c    	add.w	r2, r3, #0xc
 800d744: 2306         	movs	r3, #0x6
 800d746: 2112         	movs	r1, #0x12
 800d748: 6878         	ldr	r0, [r7, #0x4]
 800d74a: f014 fb71    	bl	0x8021e30 <bmi08x_accel_read> @ imm = #0x146e2
 800d74e: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 800d750: 68fb         	ldr	r3, [r7, #0xc]
 800d752: 2b00         	cmp	r3, #0x0
 800d754: da04         	bge	0x800d760 <bmi08x_sample_fetch+0x84> @ imm = #0x8
; 		pm_device_busy_clear(dev);
 800d756: 6878         	ldr	r0, [r7, #0x4]
 800d758: f014 f9ec    	bl	0x8021b34 <pm_device_busy_clear> @ imm = #0x143d8
; 		return ret;
 800d75c: 68fb         	ldr	r3, [r7, #0xc]
 800d75e: e019         	b	0x800d794 <bmi08x_sample_fetch+0xb8> @ imm = #0x32
; 	for (i = 0; i < ARRAY_SIZE(data->acc_sample); i++) {
 800d760: 2300         	movs	r3, #0x0
 800d762: 61fb         	str	r3, [r7, #0x1c]
 800d764: e00f         	b	0x800d786 <bmi08x_sample_fetch+0xaa> @ imm = #0x1e
; 		data->acc_sample[i] = sys_le16_to_cpu(data->acc_sample[i]);
 800d766: 69ba         	ldr	r2, [r7, #0x18]
 800d768: 69fb         	ldr	r3, [r7, #0x1c]
 800d76a: 3304         	adds	r3, #0x4
 800d76c: 005b         	lsls	r3, r3, #0x1
 800d76e: 4413         	add	r3, r2
 800d770: 8899         	ldrh	r1, [r3, #0x4]
 800d772: 69ba         	ldr	r2, [r7, #0x18]
 800d774: 69fb         	ldr	r3, [r7, #0x1c]
 800d776: 3304         	adds	r3, #0x4
 800d778: 005b         	lsls	r3, r3, #0x1
 800d77a: 4413         	add	r3, r2
 800d77c: 460a         	mov	r2, r1
 800d77e: 809a         	strh	r2, [r3, #0x4]
; 	for (i = 0; i < ARRAY_SIZE(data->acc_sample); i++) {
 800d780: 69fb         	ldr	r3, [r7, #0x1c]
 800d782: 3301         	adds	r3, #0x1
 800d784: 61fb         	str	r3, [r7, #0x1c]
 800d786: 69fb         	ldr	r3, [r7, #0x1c]
 800d788: 2b02         	cmp	r3, #0x2
 800d78a: d9ec         	bls	0x800d766 <bmi08x_sample_fetch+0x8a> @ imm = #-0x28
; 	pm_device_busy_clear(dev);
 800d78c: 6878         	ldr	r0, [r7, #0x4]
 800d78e: f014 f9d1    	bl	0x8021b34 <pm_device_busy_clear> @ imm = #0x143a2
; 	return ret;
 800d792: 68fb         	ldr	r3, [r7, #0xc]
; }
 800d794: 4618         	mov	r0, r3
 800d796: 3720         	adds	r7, #0x20
 800d798: 46bd         	mov	sp, r7
 800d79a: bd80         	pop	{r7, pc}

0800d79c <$d>:
 800d79c: dc 06 00 24  	.word	0x240006dc
 800d7a0: 00 d6 02 08  	.word	0x0802d600
 800d7a4: 9c ba 02 08  	.word	0x0802ba9c

0800d7a8 <bmi08x_to_fixed_point>:
; {
 800d7a8: b480         	push	{r7}
 800d7aa: b085         	sub	sp, #0x14
 800d7ac: af00         	add	r7, sp, #0x0
 800d7ae: 4603         	mov	r3, r0
 800d7b0: 603a         	str	r2, [r7]
 800d7b2: 80fb         	strh	r3, [r7, #0x6]
 800d7b4: 460b         	mov	r3, r1
 800d7b6: 80bb         	strh	r3, [r7, #0x4]
; 	converted_val = raw_val * scale;
 800d7b8: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 800d7bc: 88ba         	ldrh	r2, [r7, #0x4]
 800d7be: fb02 f303    	mul	r3, r2, r3
 800d7c2: 60fb         	str	r3, [r7, #0xc]
; 	val->val1 = converted_val / 1000000;
 800d7c4: 68fb         	ldr	r3, [r7, #0xc]
 800d7c6: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800d7fc <bmi08x_to_fixed_point+0x54>
 800d7c8: fb82 1203    	smull	r1, r2, r2, r3
 800d7cc: 1492         	asrs	r2, r2, #0x12
 800d7ce: 17db         	asrs	r3, r3, #0x1f
 800d7d0: 1ad2         	subs	r2, r2, r3
 800d7d2: 683b         	ldr	r3, [r7]
 800d7d4: 601a         	str	r2, [r3]
; 	val->val2 = converted_val % 1000000;
 800d7d6: 68fa         	ldr	r2, [r7, #0xc]
 800d7d8: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800d7fc <bmi08x_to_fixed_point+0x54>
 800d7da: fb83 1302    	smull	r1, r3, r3, r2
 800d7de: 1499         	asrs	r1, r3, #0x12
 800d7e0: 17d3         	asrs	r3, r2, #0x1f
 800d7e2: 1acb         	subs	r3, r1, r3
 800d7e4: 4906         	ldr	r1, [pc, #0x18]         @ 0x800d800 <bmi08x_to_fixed_point+0x58>
 800d7e6: fb01 f303    	mul	r3, r1, r3
 800d7ea: 1ad3         	subs	r3, r2, r3
 800d7ec: 683a         	ldr	r2, [r7]
 800d7ee: 6053         	str	r3, [r2, #0x4]
; }
 800d7f0: bf00         	nop
 800d7f2: 3714         	adds	r7, #0x14
 800d7f4: 46bd         	mov	sp, r7
 800d7f6: f85d 7b04    	ldr	r7, [sp], #4
 800d7fa: 4770         	bx	lr

0800d7fc <$d>:
 800d7fc: 83 de 1b 43  	.word	0x431bde83
 800d800: 40 42 0f 00  	.word	0x000f4240

0800d804 <bmi08x_temp_channel_get>:
; {
 800d804: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800d808: b090         	sub	sp, #0x40
 800d80a: af04         	add	r7, sp, #0x10
 800d80c: 6078         	str	r0, [r7, #0x4]
 800d80e: 6039         	str	r1, [r7]
; 	uint16_t temp_raw = 0U;
 800d810: 2300         	movs	r3, #0x0
 800d812: 817b         	strh	r3, [r7, #0xa]
; 	int32_t temp_micro = 0;
 800d814: 2300         	movs	r3, #0x0
 800d816: 62bb         	str	r3, [r7, #0x28]
; 	int16_t temp_int11 = 0;
 800d818: 2300         	movs	r3, #0x0
 800d81a: 85fb         	strh	r3, [r7, #0x2e]
; 	ret = bmi08x_accel_word_read(dev, BMI08X_REG_TEMP_MSB, &temp_raw);
 800d81c: f107 030a    	add.w	r3, r7, #0xa
 800d820: 461a         	mov	r2, r3
 800d822: 2122         	movs	r1, #0x22
 800d824: 6878         	ldr	r0, [r7, #0x4]
 800d826: f014 fb34    	bl	0x8021e92 <bmi08x_accel_word_read> @ imm = #0x14668
 800d82a: 6278         	str	r0, [r7, #0x24]
; 	if (!ret) {
 800d82c: 6a7b         	ldr	r3, [r7, #0x24]
 800d82e: 2b00         	cmp	r3, #0x0
 800d830: d109         	bne	0x800d846 <bmi08x_temp_channel_get+0x42> @ imm = #0x12
; 		temp_int11 = (temp_raw & 0xFF) << 3;
 800d832: 897b         	ldrh	r3, [r7, #0xa]
 800d834: 00db         	lsls	r3, r3, #0x3
 800d836: b21b         	sxth	r3, r3
 800d838: f403 63ff    	and	r3, r3, #0x7f8
 800d83c: 85fb         	strh	r3, [r7, #0x2e]
; 	if (temp_raw == 0x80) {
 800d83e: 897b         	ldrh	r3, [r7, #0xa]
 800d840: 2b80         	cmp	r3, #0x80
 800d842: d13d         	bne	0x800d8c0 <bmi08x_temp_channel_get+0xbc> @ imm = #0x7a
 800d844: e01f         	b	0x800d886 <bmi08x_temp_channel_get+0x82> @ imm = #0x3e
; 		LOG_ERR("Error reading BMI08X_REG_TEMP_MSB. (err %d)", ret);
 800d846: 2303         	movs	r3, #0x3
 800d848: 2b00         	cmp	r3, #0x0
 800d84a: d01a         	beq	0x800d882 <bmi08x_temp_channel_get+0x7e> @ imm = #0x34
 800d84c: 2301         	movs	r3, #0x1
 800d84e: f887 3023    	strb.w	r3, [r7, #0x23]
 800d852: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800d856: f083 0301    	eor	r3, r3, #0x1
 800d85a: b2db         	uxtb	r3, r3
 800d85c: 2b00         	cmp	r3, #0x0
 800d85e: d110         	bne	0x800d882 <bmi08x_temp_channel_get+0x7e> @ imm = #0x20
 800d860: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x800d994 <bmi08x_temp_channel_get+0x190>
 800d862: 6819         	ldr	r1, [r3]
 800d864: 6a7b         	ldr	r3, [r7, #0x24]
 800d866: 9303         	str	r3, [sp, #0xc]
 800d868: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800d998 <bmi08x_temp_channel_get+0x194>
 800d86a: 9302         	str	r3, [sp, #0x8]
 800d86c: 2300         	movs	r3, #0x0
 800d86e: 9301         	str	r3, [sp, #0x4]
 800d870: 2300         	movs	r3, #0x0
 800d872: 9300         	str	r3, [sp]
 800d874: 2300         	movs	r3, #0x0
 800d876: 2201         	movs	r2, #0x1
 800d878: 2000         	movs	r0, #0x0
 800d87a: f014 f965    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x142ca
 800d87e: 2300         	movs	r3, #0x0
 800d880: 61fb         	str	r3, [r7, #0x1c]
; 		return ret;
 800d882: 6a7b         	ldr	r3, [r7, #0x24]
 800d884: e080         	b	0x800d988 <bmi08x_temp_channel_get+0x184> @ imm = #0x100
; 		LOG_ERR("BMI08X returned invalid temperature.");
 800d886: 2303         	movs	r3, #0x3
 800d888: 2b00         	cmp	r3, #0x0
 800d88a: d016         	beq	0x800d8ba <bmi08x_temp_channel_get+0xb6> @ imm = #0x2c
 800d88c: 2301         	movs	r3, #0x1
 800d88e: 74fb         	strb	r3, [r7, #0x13]
 800d890: 7cfb         	ldrb	r3, [r7, #0x13]
 800d892: f083 0301    	eor	r3, r3, #0x1
 800d896: b2db         	uxtb	r3, r3
 800d898: 2b00         	cmp	r3, #0x0
 800d89a: d10e         	bne	0x800d8ba <bmi08x_temp_channel_get+0xb6> @ imm = #0x1c
 800d89c: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x800d994 <bmi08x_temp_channel_get+0x190>
 800d89e: 6819         	ldr	r1, [r3]
 800d8a0: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800d99c <bmi08x_temp_channel_get+0x198>
 800d8a2: 9302         	str	r3, [sp, #0x8]
 800d8a4: 2300         	movs	r3, #0x0
 800d8a6: 9301         	str	r3, [sp, #0x4]
 800d8a8: 2300         	movs	r3, #0x0
 800d8aa: 9300         	str	r3, [sp]
 800d8ac: 2300         	movs	r3, #0x0
 800d8ae: 2201         	movs	r2, #0x1
 800d8b0: 2000         	movs	r0, #0x0
 800d8b2: f014 f949    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x14292
 800d8b6: 2300         	movs	r3, #0x0
 800d8b8: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODATA;
 800d8ba: f06f 033c    	mvn	r3, #0x3c
 800d8be: e063         	b	0x800d988 <bmi08x_temp_channel_get+0x184> @ imm = #0xc6
; 	ret = bmi08x_accel_word_read(dev, BMI08X_REG_TEMP_LSB, &temp_raw);
 800d8c0: f107 030a    	add.w	r3, r7, #0xa
 800d8c4: 461a         	mov	r2, r3
 800d8c6: 2123         	movs	r1, #0x23
 800d8c8: 6878         	ldr	r0, [r7, #0x4]
 800d8ca: f014 fae2    	bl	0x8021e92 <bmi08x_accel_word_read> @ imm = #0x145c4
 800d8ce: 6278         	str	r0, [r7, #0x24]
; 	if (!ret) {
 800d8d0: 6a7b         	ldr	r3, [r7, #0x24]
 800d8d2: 2b00         	cmp	r3, #0x0
 800d8d4: d10e         	bne	0x800d8f4 <bmi08x_temp_channel_get+0xf0> @ imm = #0x1c
; 		temp_int11 |= (temp_raw & 0xE0) >> 5;
 800d8d6: 897b         	ldrh	r3, [r7, #0xa]
 800d8d8: 115b         	asrs	r3, r3, #0x5
 800d8da: b21b         	sxth	r3, r3
 800d8dc: f003 0307    	and	r3, r3, #0x7
 800d8e0: b21a         	sxth	r2, r3
 800d8e2: 8dfb         	ldrh	r3, [r7, #0x2e]
 800d8e4: 4313         	orrs	r3, r2
 800d8e6: 85fb         	strh	r3, [r7, #0x2e]
; 	if (temp_int11 > 1023) {
 800d8e8: f9b7 302e    	ldrsh.w	r3, [r7, #0x2e]
 800d8ec: f5b3 6f80    	cmp.w	r3, #0x400
 800d8f0: db23         	blt	0x800d93a <bmi08x_temp_channel_get+0x136> @ imm = #0x46
 800d8f2: e01d         	b	0x800d930 <bmi08x_temp_channel_get+0x12c> @ imm = #0x3a
; 		LOG_ERR("Error reading BMI08X_REG_TEMP_LSB. (err %d)", ret);
 800d8f4: 2303         	movs	r3, #0x3
 800d8f6: 2b00         	cmp	r3, #0x0
 800d8f8: d018         	beq	0x800d92c <bmi08x_temp_channel_get+0x128> @ imm = #0x30
 800d8fa: 2301         	movs	r3, #0x1
 800d8fc: 76fb         	strb	r3, [r7, #0x1b]
 800d8fe: 7efb         	ldrb	r3, [r7, #0x1b]
 800d900: f083 0301    	eor	r3, r3, #0x1
 800d904: b2db         	uxtb	r3, r3
 800d906: 2b00         	cmp	r3, #0x0
 800d908: d110         	bne	0x800d92c <bmi08x_temp_channel_get+0x128> @ imm = #0x20
 800d90a: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800d994 <bmi08x_temp_channel_get+0x190>
 800d90c: 6819         	ldr	r1, [r3]
 800d90e: 6a7b         	ldr	r3, [r7, #0x24]
 800d910: 9303         	str	r3, [sp, #0xc]
 800d912: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800d9a0 <bmi08x_temp_channel_get+0x19c>
 800d914: 9302         	str	r3, [sp, #0x8]
 800d916: 2300         	movs	r3, #0x0
 800d918: 9301         	str	r3, [sp, #0x4]
 800d91a: 2300         	movs	r3, #0x0
 800d91c: 9300         	str	r3, [sp]
 800d91e: 2300         	movs	r3, #0x0
 800d920: 2201         	movs	r2, #0x1
 800d922: 2000         	movs	r0, #0x0
 800d924: f014 f910    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x14220
 800d928: 2300         	movs	r3, #0x0
 800d92a: 617b         	str	r3, [r7, #0x14]
; 		return ret;
 800d92c: 6a7b         	ldr	r3, [r7, #0x24]
 800d92e: e02b         	b	0x800d988 <bmi08x_temp_channel_get+0x184> @ imm = #0x56
; 		temp_int11 -= 2048;
 800d930: 8dfb         	ldrh	r3, [r7, #0x2e]
 800d932: f5a3 6300    	sub.w	r3, r3, #0x800
 800d936: b29b         	uxth	r3, r3
 800d938: 85fb         	strh	r3, [r7, #0x2e]
; 	temp_micro = temp_int11 * 125 + 23 * 1000000;
 800d93a: f9b7 202e    	ldrsh.w	r2, [r7, #0x2e]
 800d93e: 4613         	mov	r3, r2
 800d940: 015b         	lsls	r3, r3, #0x5
 800d942: 1a9b         	subs	r3, r3, r2
 800d944: 009b         	lsls	r3, r3, #0x2
 800d946: 441a         	add	r2, r3
 800d948: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800d9a4 <bmi08x_temp_channel_get+0x1a0>
 800d94a: 4413         	add	r3, r2
 800d94c: 62bb         	str	r3, [r7, #0x28]
; 	val->val1 = temp_micro / 1000000ULL;
 800d94e: 6abb         	ldr	r3, [r7, #0x28]
 800d950: 17da         	asrs	r2, r3, #0x1f
 800d952: 4698         	mov	r8, r3
 800d954: 4691         	mov	r9, r2
 800d956: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800d9a8 <bmi08x_temp_channel_get+0x1a4>
 800d958: f04f 0300    	mov.w	r3, #0x0
 800d95c: 4640         	mov	r0, r8
 800d95e: 4649         	mov	r1, r9
 800d960: f7f2 fd06    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0xd5f4
 800d964: 4602         	mov	r2, r0
 800d966: 460b         	mov	r3, r1
 800d968: 683b         	ldr	r3, [r7]
 800d96a: 601a         	str	r2, [r3]
; 	val->val2 = temp_micro % 1000000ULL;
 800d96c: 6abb         	ldr	r3, [r7, #0x28]
 800d96e: 17da         	asrs	r2, r3, #0x1f
 800d970: 461c         	mov	r4, r3
 800d972: 4615         	mov	r5, r2
 800d974: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800d9a8 <bmi08x_temp_channel_get+0x1a4>
 800d976: f04f 0300    	mov.w	r3, #0x0
 800d97a: 4620         	mov	r0, r4
 800d97c: 4629         	mov	r1, r5
 800d97e: f7f2 fcf7    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0xd612
 800d982: 683b         	ldr	r3, [r7]
 800d984: 605a         	str	r2, [r3, #0x4]
; 	return ret;
 800d986: 6a7b         	ldr	r3, [r7, #0x24]
; }
 800d988: 4618         	mov	r0, r3
 800d98a: 3730         	adds	r7, #0x30
 800d98c: 46bd         	mov	sp, r7
 800d98e: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 800d992: bf00         	nop

0800d994 <$d>:
 800d994: dc 06 00 24  	.word	0x240006dc
 800d998: bc ba 02 08  	.word	0x0802babc
 800d99c: e8 ba 02 08  	.word	0x0802bae8
 800d9a0: 10 bb 02 08  	.word	0x0802bb10
 800d9a4: c0 f3 5e 01  	.word	0x015ef3c0
 800d9a8: 40 42 0f 00  	.word	0x000f4240

0800d9ac <bmi08x_channel_get>:
; {
 800d9ac: b580         	push	{r7, lr}
 800d9ae: b08a         	sub	sp, #0x28
 800d9b0: af04         	add	r7, sp, #0x10
 800d9b2: 60f8         	str	r0, [r7, #0xc]
 800d9b4: 460b         	mov	r3, r1
 800d9b6: 607a         	str	r2, [r7, #0x4]
 800d9b8: 817b         	strh	r3, [r7, #0xa]
; 	switch ((int16_t)chan) {
 800d9ba: f9b7 300a    	ldrsh.w	r3, [r7, #0xa]
 800d9be: 2b03         	cmp	r3, #0x3
 800d9c0: dc02         	bgt	0x800d9c8 <bmi08x_channel_get+0x1c> @ imm = #0x4
 800d9c2: 2b00         	cmp	r3, #0x0
 800d9c4: da03         	bge	0x800d9ce <bmi08x_channel_get+0x22> @ imm = #0x6
 800d9c6: e010         	b	0x800d9ea <bmi08x_channel_get+0x3e> @ imm = #0x20
 800d9c8: 2b0c         	cmp	r3, #0xc
 800d9ca: d008         	beq	0x800d9de <bmi08x_channel_get+0x32> @ imm = #0x10
 800d9cc: e00d         	b	0x800d9ea <bmi08x_channel_get+0x3e> @ imm = #0x1a
; 		bmi08x_acc_channel_get(dev, chan, val);
 800d9ce: 897b         	ldrh	r3, [r7, #0xa]
 800d9d0: 687a         	ldr	r2, [r7, #0x4]
 800d9d2: 4619         	mov	r1, r3
 800d9d4: 68f8         	ldr	r0, [r7, #0xc]
 800d9d6: f014 fb33    	bl	0x8022040 <bmi08x_acc_channel_get> @ imm = #0x14666
; 		return 0;
 800d9da: 2300         	movs	r3, #0x0
 800d9dc: e023         	b	0x800da26 <bmi08x_channel_get+0x7a> @ imm = #0x46
; 		return bmi08x_temp_channel_get(dev, val);
 800d9de: 6879         	ldr	r1, [r7, #0x4]
 800d9e0: 68f8         	ldr	r0, [r7, #0xc]
 800d9e2: f7ff ff0f    	bl	0x800d804 <bmi08x_temp_channel_get> @ imm = #-0x1e2
 800d9e6: 4603         	mov	r3, r0
 800d9e8: e01d         	b	0x800da26 <bmi08x_channel_get+0x7a> @ imm = #0x3a
; 		LOG_DBG("Channel not supported.");
 800d9ea: 2303         	movs	r3, #0x3
 800d9ec: 2b03         	cmp	r3, #0x3
 800d9ee: d918         	bls	0x800da22 <bmi08x_channel_get+0x76> @ imm = #0x30
 800d9f0: 2301         	movs	r3, #0x1
 800d9f2: 75fb         	strb	r3, [r7, #0x17]
 800d9f4: 7dfb         	ldrb	r3, [r7, #0x17]
 800d9f6: f083 0301    	eor	r3, r3, #0x1
 800d9fa: b2db         	uxtb	r3, r3
 800d9fc: 2b00         	cmp	r3, #0x0
 800d9fe: d110         	bne	0x800da22 <bmi08x_channel_get+0x76> @ imm = #0x20
 800da00: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800da30 <bmi08x_channel_get+0x84>
 800da02: 6819         	ldr	r1, [r3]
 800da04: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800da34 <bmi08x_channel_get+0x88>
 800da06: 9303         	str	r3, [sp, #0xc]
 800da08: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800da38 <bmi08x_channel_get+0x8c>
 800da0a: 9302         	str	r3, [sp, #0x8]
 800da0c: 2308         	movs	r3, #0x8
 800da0e: 9301         	str	r3, [sp, #0x4]
 800da10: 2300         	movs	r3, #0x0
 800da12: 9300         	str	r3, [sp]
 800da14: 2300         	movs	r3, #0x0
 800da16: 2204         	movs	r2, #0x4
 800da18: 2000         	movs	r0, #0x0
 800da1a: f014 f895    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x1412a
 800da1e: 2300         	movs	r3, #0x0
 800da20: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800da22: f06f 0385    	mvn	r3, #0x85
; }
 800da26: 4618         	mov	r0, r3
 800da28: 3718         	adds	r7, #0x18
 800da2a: 46bd         	mov	sp, r7
 800da2c: bd80         	pop	{r7, pc}
 800da2e: bf00         	nop

0800da30 <$d>:
 800da30: dc 06 00 24  	.word	0x240006dc
 800da34: 14 d6 02 08  	.word	0x0802d614
 800da38: 3c bb 02 08  	.word	0x0802bb3c

0800da3c <bmi08x_accel_init>:
; {
 800da3c: b580         	push	{r7, lr}
 800da3e: b09e         	sub	sp, #0x78
 800da40: af04         	add	r7, sp, #0x10
 800da42: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_accel_config *config = dev->config;
 800da44: 687b         	ldr	r3, [r7, #0x4]
 800da46: 685b         	ldr	r3, [r3, #0x4]
 800da48: 65fb         	str	r3, [r7, #0x5c]
; 	struct bmi08x_accel_data *data = dev->data;
 800da4a: 687b         	ldr	r3, [r7, #0x4]
 800da4c: 691b         	ldr	r3, [r3, #0x10]
 800da4e: 65bb         	str	r3, [r7, #0x58]
; 	uint8_t val = 0U;
 800da50: 2300         	movs	r3, #0x0
 800da52: 72fb         	strb	r3, [r7, #0xb]
; 	ret = bmi08x_bus_check(dev);
 800da54: 6878         	ldr	r0, [r7, #0x4]
 800da56: f014 f9a6    	bl	0x8021da6 <bmi08x_bus_check> @ imm = #0x1434c
 800da5a: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800da5c: 6e7b         	ldr	r3, [r7, #0x64]
 800da5e: 2b00         	cmp	r3, #0x0
 800da60: da1e         	bge	0x800daa0 <bmi08x_accel_init+0x64> @ imm = #0x3c
; 		LOG_ERR("Bus not ready for '%s'", dev->name);
 800da62: 2303         	movs	r3, #0x3
 800da64: 2b00         	cmp	r3, #0x0
 800da66: d019         	beq	0x800da9c <bmi08x_accel_init+0x60> @ imm = #0x32
 800da68: 2301         	movs	r3, #0x1
 800da6a: 74fb         	strb	r3, [r7, #0x13]
 800da6c: 7cfb         	ldrb	r3, [r7, #0x13]
 800da6e: f083 0301    	eor	r3, r3, #0x1
 800da72: b2db         	uxtb	r3, r3
 800da74: 2b00         	cmp	r3, #0x0
 800da76: d111         	bne	0x800da9c <bmi08x_accel_init+0x60> @ imm = #0x22
 800da78: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x800dce4 <bmi08x_accel_init+0x2a8>
 800da7a: 6819         	ldr	r1, [r3]
 800da7c: 687b         	ldr	r3, [r7, #0x4]
 800da7e: 681b         	ldr	r3, [r3]
 800da80: 9303         	str	r3, [sp, #0xc]
 800da82: 4b99         	ldr	r3, [pc, #0x264]        @ 0x800dce8 <bmi08x_accel_init+0x2ac>
 800da84: 9302         	str	r3, [sp, #0x8]
 800da86: 2300         	movs	r3, #0x0
 800da88: 9301         	str	r3, [sp, #0x4]
 800da8a: 2300         	movs	r3, #0x0
 800da8c: 9300         	str	r3, [sp]
 800da8e: 2300         	movs	r3, #0x0
 800da90: 2201         	movs	r2, #0x1
 800da92: 2000         	movs	r0, #0x0
 800da94: f014 f858    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x140b0
 800da98: 2300         	movs	r3, #0x0
 800da9a: 60fb         	str	r3, [r7, #0xc]
; 		return ret;
 800da9c: 6e7b         	ldr	r3, [r7, #0x64]
 800da9e: e185         	b	0x800ddac <bmi08x_accel_init+0x370> @ imm = #0x30a
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_SOFTRESET, BMI08X_SOFT_RESET_CMD);
 800daa0: 22b6         	movs	r2, #0xb6
 800daa2: 217e         	movs	r1, #0x7e
 800daa4: 6878         	ldr	r0, [r7, #0x4]
 800daa6: f014 fa15    	bl	0x8021ed4 <bmi08x_accel_byte_write> @ imm = #0x1442a
 800daaa: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800daac: 6e7b         	ldr	r3, [r7, #0x64]
 800daae: 2b00         	cmp	r3, #0x0
 800dab0: da1b         	bge	0x800daea <bmi08x_accel_init+0xae> @ imm = #0x36
; 		LOG_ERR("Cannot reboot chip.");
 800dab2: 2303         	movs	r3, #0x3
 800dab4: 2b00         	cmp	r3, #0x0
 800dab6: d016         	beq	0x800dae6 <bmi08x_accel_init+0xaa> @ imm = #0x2c
 800dab8: 2301         	movs	r3, #0x1
 800daba: 76fb         	strb	r3, [r7, #0x1b]
 800dabc: 7efb         	ldrb	r3, [r7, #0x1b]
 800dabe: f083 0301    	eor	r3, r3, #0x1
 800dac2: b2db         	uxtb	r3, r3
 800dac4: 2b00         	cmp	r3, #0x0
 800dac6: d10e         	bne	0x800dae6 <bmi08x_accel_init+0xaa> @ imm = #0x1c
 800dac8: 4b86         	ldr	r3, [pc, #0x218]        @ 0x800dce4 <bmi08x_accel_init+0x2a8>
 800daca: 6819         	ldr	r1, [r3]
 800dacc: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x800dcec <bmi08x_accel_init+0x2b0>
 800dace: 9302         	str	r3, [sp, #0x8]
 800dad0: 2300         	movs	r3, #0x0
 800dad2: 9301         	str	r3, [sp, #0x4]
 800dad4: 2300         	movs	r3, #0x0
 800dad6: 9300         	str	r3, [sp]
 800dad8: 2300         	movs	r3, #0x0
 800dada: 2201         	movs	r2, #0x1
 800dadc: 2000         	movs	r0, #0x0
 800dade: f014 f833    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x14066
 800dae2: 2300         	movs	r3, #0x0
 800dae4: 617b         	str	r3, [r7, #0x14]
; 		return ret;
 800dae6: 6e7b         	ldr	r3, [r7, #0x64]
 800dae8: e160         	b	0x800ddac <bmi08x_accel_init+0x370> @ imm = #0x2c0
; 	k_msleep(BMI08X_ACCEL_SOFTRESET_DELAY_MS);
 800daea: 2001         	movs	r0, #0x1
 800daec: f013 ffd2    	bl	0x8021a94 <k_msleep>    @ imm = #0x13fa4
; 	ret = bmi08x_bus_init(dev);
 800daf0: 6878         	ldr	r0, [r7, #0x4]
 800daf2: f014 f96a    	bl	0x8021dca <bmi08x_bus_init> @ imm = #0x142d4
 800daf6: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800daf8: 6e7b         	ldr	r3, [r7, #0x64]
 800dafa: 2b00         	cmp	r3, #0x0
 800dafc: da20         	bge	0x800db40 <bmi08x_accel_init+0x104> @ imm = #0x40
; 		LOG_ERR("Can't initialize bus for %s", dev->name);
 800dafe: 2303         	movs	r3, #0x3
 800db00: 2b00         	cmp	r3, #0x0
 800db02: d01b         	beq	0x800db3c <bmi08x_accel_init+0x100> @ imm = #0x36
 800db04: 2301         	movs	r3, #0x1
 800db06: f887 3023    	strb.w	r3, [r7, #0x23]
 800db0a: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800db0e: f083 0301    	eor	r3, r3, #0x1
 800db12: b2db         	uxtb	r3, r3
 800db14: 2b00         	cmp	r3, #0x0
 800db16: d111         	bne	0x800db3c <bmi08x_accel_init+0x100> @ imm = #0x22
 800db18: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x800dce4 <bmi08x_accel_init+0x2a8>
 800db1a: 6819         	ldr	r1, [r3]
 800db1c: 687b         	ldr	r3, [r7, #0x4]
 800db1e: 681b         	ldr	r3, [r3]
 800db20: 9303         	str	r3, [sp, #0xc]
 800db22: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x800dcf0 <bmi08x_accel_init+0x2b4>
 800db24: 9302         	str	r3, [sp, #0x8]
 800db26: 2300         	movs	r3, #0x0
 800db28: 9301         	str	r3, [sp, #0x4]
 800db2a: 2300         	movs	r3, #0x0
 800db2c: 9300         	str	r3, [sp]
 800db2e: 2300         	movs	r3, #0x0
 800db30: 2201         	movs	r2, #0x1
 800db32: 2000         	movs	r0, #0x0
 800db34: f014 f808    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x14010
 800db38: 2300         	movs	r3, #0x0
 800db3a: 61fb         	str	r3, [r7, #0x1c]
; 		return ret;
 800db3c: 6e7b         	ldr	r3, [r7, #0x64]
 800db3e: e135         	b	0x800ddac <bmi08x_accel_init+0x370> @ imm = #0x26a
; 	ret = bmi08x_accel_byte_read(dev, BMI08X_REG_ACCEL_CHIP_ID, &val);
 800db40: f107 030b    	add.w	r3, r7, #0xb
 800db44: 461a         	mov	r2, r3
 800db46: 2100         	movs	r1, #0x0
 800db48: 6878         	ldr	r0, [r7, #0x4]
 800db4a: f014 f98b    	bl	0x8021e64 <bmi08x_accel_byte_read> @ imm = #0x14316
 800db4e: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800db50: 6e7b         	ldr	r3, [r7, #0x64]
 800db52: 2b00         	cmp	r3, #0x0
 800db54: da1d         	bge	0x800db92 <bmi08x_accel_init+0x156> @ imm = #0x3a
; 		LOG_ERR("Failed to read chip id.");
 800db56: 2303         	movs	r3, #0x3
 800db58: 2b00         	cmp	r3, #0x0
 800db5a: d018         	beq	0x800db8e <bmi08x_accel_init+0x152> @ imm = #0x30
 800db5c: 2301         	movs	r3, #0x1
 800db5e: f887 302b    	strb.w	r3, [r7, #0x2b]
 800db62: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800db66: f083 0301    	eor	r3, r3, #0x1
 800db6a: b2db         	uxtb	r3, r3
 800db6c: 2b00         	cmp	r3, #0x0
 800db6e: d10e         	bne	0x800db8e <bmi08x_accel_init+0x152> @ imm = #0x1c
 800db70: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800dce4 <bmi08x_accel_init+0x2a8>
 800db72: 6819         	ldr	r1, [r3]
 800db74: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x800dcf4 <bmi08x_accel_init+0x2b8>
 800db76: 9302         	str	r3, [sp, #0x8]
 800db78: 2300         	movs	r3, #0x0
 800db7a: 9301         	str	r3, [sp, #0x4]
 800db7c: 2300         	movs	r3, #0x0
 800db7e: 9300         	str	r3, [sp]
 800db80: 2300         	movs	r3, #0x0
 800db82: 2201         	movs	r2, #0x1
 800db84: 2000         	movs	r0, #0x0
 800db86: f013 ffdf    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x13fbe
 800db8a: 2300         	movs	r3, #0x0
 800db8c: 627b         	str	r3, [r7, #0x24]
; 		return ret;
 800db8e: 6e7b         	ldr	r3, [r7, #0x64]
 800db90: e10c         	b	0x800ddac <bmi08x_accel_init+0x370> @ imm = #0x218
; 	if ((val != BMI085_ACCEL_CHIP_ID) && (val != BMI088_ACCEL_CHIP_ID)) {
 800db92: 7afb         	ldrb	r3, [r7, #0xb]
 800db94: 2b1f         	cmp	r3, #0x1f
 800db96: d023         	beq	0x800dbe0 <bmi08x_accel_init+0x1a4> @ imm = #0x46
 800db98: 7afb         	ldrb	r3, [r7, #0xb]
 800db9a: 2b1e         	cmp	r3, #0x1e
 800db9c: d020         	beq	0x800dbe0 <bmi08x_accel_init+0x1a4> @ imm = #0x40
; 		LOG_ERR("Unsupported chip detected (0x%02x)!", val);
 800db9e: 2303         	movs	r3, #0x3
 800dba0: 2b00         	cmp	r3, #0x0
 800dba2: d01a         	beq	0x800dbda <bmi08x_accel_init+0x19e> @ imm = #0x34
 800dba4: 2301         	movs	r3, #0x1
 800dba6: f887 3063    	strb.w	r3, [r7, #0x63]
 800dbaa: f897 3063    	ldrb.w	r3, [r7, #0x63]
 800dbae: f083 0301    	eor	r3, r3, #0x1
 800dbb2: b2db         	uxtb	r3, r3
 800dbb4: 2b00         	cmp	r3, #0x0
 800dbb6: d110         	bne	0x800dbda <bmi08x_accel_init+0x19e> @ imm = #0x20
 800dbb8: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x800dce4 <bmi08x_accel_init+0x2a8>
 800dbba: 6819         	ldr	r1, [r3]
 800dbbc: 7afb         	ldrb	r3, [r7, #0xb]
 800dbbe: 9303         	str	r3, [sp, #0xc]
 800dbc0: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800dcf8 <bmi08x_accel_init+0x2bc>
 800dbc2: 9302         	str	r3, [sp, #0x8]
 800dbc4: 2300         	movs	r3, #0x0
 800dbc6: 9301         	str	r3, [sp, #0x4]
 800dbc8: 2300         	movs	r3, #0x0
 800dbca: 9300         	str	r3, [sp]
 800dbcc: 2300         	movs	r3, #0x0
 800dbce: 2201         	movs	r2, #0x1
 800dbd0: 2000         	movs	r0, #0x0
 800dbd2: f013 ffb9    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x13f72
 800dbd6: 2300         	movs	r3, #0x0
 800dbd8: 657b         	str	r3, [r7, #0x54]
; 		return -ENODEV;
 800dbda: f06f 0312    	mvn	r3, #0x12
 800dbde: e0e5         	b	0x800ddac <bmi08x_accel_init+0x370> @ imm = #0x1ca
; 	data->accel_chip_id = val;
 800dbe0: 7afa         	ldrb	r2, [r7, #0xb]
 800dbe2: 6dbb         	ldr	r3, [r7, #0x58]
 800dbe4: f883 2748    	strb.w	r2, [r3, #0x748]
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_PWR_CONF, BMI08X_ACCEL_PM_ACTIVE);
 800dbe8: 2200         	movs	r2, #0x0
 800dbea: 217c         	movs	r1, #0x7c
 800dbec: 6878         	ldr	r0, [r7, #0x4]
 800dbee: f014 f971    	bl	0x8021ed4 <bmi08x_accel_byte_write> @ imm = #0x142e2
 800dbf2: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800dbf4: 6e7b         	ldr	r3, [r7, #0x64]
 800dbf6: 2b00         	cmp	r3, #0x0
 800dbf8: da1d         	bge	0x800dc36 <bmi08x_accel_init+0x1fa> @ imm = #0x3a
; 		LOG_ERR("Failed to set conf power mode");
 800dbfa: 2303         	movs	r3, #0x3
 800dbfc: 2b00         	cmp	r3, #0x0
 800dbfe: d018         	beq	0x800dc32 <bmi08x_accel_init+0x1f6> @ imm = #0x30
 800dc00: 2301         	movs	r3, #0x1
 800dc02: f887 3033    	strb.w	r3, [r7, #0x33]
 800dc06: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800dc0a: f083 0301    	eor	r3, r3, #0x1
 800dc0e: b2db         	uxtb	r3, r3
 800dc10: 2b00         	cmp	r3, #0x0
 800dc12: d10e         	bne	0x800dc32 <bmi08x_accel_init+0x1f6> @ imm = #0x1c
 800dc14: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800dce4 <bmi08x_accel_init+0x2a8>
 800dc16: 6819         	ldr	r1, [r3]
 800dc18: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x800dcfc <bmi08x_accel_init+0x2c0>
 800dc1a: 9302         	str	r3, [sp, #0x8]
 800dc1c: 2300         	movs	r3, #0x0
 800dc1e: 9301         	str	r3, [sp, #0x4]
 800dc20: 2300         	movs	r3, #0x0
 800dc22: 9300         	str	r3, [sp]
 800dc24: 2300         	movs	r3, #0x0
 800dc26: 2201         	movs	r2, #0x1
 800dc28: 2000         	movs	r0, #0x0
 800dc2a: f013 ff8d    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x13f1a
 800dc2e: 2300         	movs	r3, #0x0
 800dc30: 62fb         	str	r3, [r7, #0x2c]
; 		return ret;
 800dc32: 6e7b         	ldr	r3, [r7, #0x64]
 800dc34: e0ba         	b	0x800ddac <bmi08x_accel_init+0x370> @ imm = #0x174
; 	k_msleep(BMI08X_POWER_CONFIG_DELAY);
 800dc36: 2005         	movs	r0, #0x5
 800dc38: f013 ff2c    	bl	0x8021a94 <k_msleep>    @ imm = #0x13e58
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_PWR_CTRL, BMI08X_ACCEL_POWER_ENABLE);
 800dc3c: 2204         	movs	r2, #0x4
 800dc3e: 217d         	movs	r1, #0x7d
 800dc40: 6878         	ldr	r0, [r7, #0x4]
 800dc42: f014 f947    	bl	0x8021ed4 <bmi08x_accel_byte_write> @ imm = #0x1428e
 800dc46: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800dc48: 6e7b         	ldr	r3, [r7, #0x64]
 800dc4a: 2b00         	cmp	r3, #0x0
 800dc4c: da1d         	bge	0x800dc8a <bmi08x_accel_init+0x24e> @ imm = #0x3a
; 		LOG_ERR("Failed to set ctrl power mode");
 800dc4e: 2303         	movs	r3, #0x3
 800dc50: 2b00         	cmp	r3, #0x0
 800dc52: d018         	beq	0x800dc86 <bmi08x_accel_init+0x24a> @ imm = #0x30
 800dc54: 2301         	movs	r3, #0x1
 800dc56: f887 303b    	strb.w	r3, [r7, #0x3b]
 800dc5a: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800dc5e: f083 0301    	eor	r3, r3, #0x1
 800dc62: b2db         	uxtb	r3, r3
 800dc64: 2b00         	cmp	r3, #0x0
 800dc66: d10e         	bne	0x800dc86 <bmi08x_accel_init+0x24a> @ imm = #0x1c
 800dc68: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800dce4 <bmi08x_accel_init+0x2a8>
 800dc6a: 6819         	ldr	r1, [r3]
 800dc6c: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800dd00 <bmi08x_accel_init+0x2c4>
 800dc6e: 9302         	str	r3, [sp, #0x8]
 800dc70: 2300         	movs	r3, #0x0
 800dc72: 9301         	str	r3, [sp, #0x4]
 800dc74: 2300         	movs	r3, #0x0
 800dc76: 9300         	str	r3, [sp]
 800dc78: 2300         	movs	r3, #0x0
 800dc7a: 2201         	movs	r2, #0x1
 800dc7c: 2000         	movs	r0, #0x0
 800dc7e: f013 ff63    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x13ec6
 800dc82: 2300         	movs	r3, #0x0
 800dc84: 637b         	str	r3, [r7, #0x34]
; 		return ret;
 800dc86: 6e7b         	ldr	r3, [r7, #0x64]
 800dc88: e090         	b	0x800ddac <bmi08x_accel_init+0x370> @ imm = #0x120
; 	k_msleep(BMI08X_POWER_CONFIG_DELAY);
 800dc8a: 2005         	movs	r0, #0x5
 800dc8c: f013 ff02    	bl	0x8021a94 <k_msleep>    @ imm = #0x13e04
; 	ret = bmi08x_acc_range_set(dev, config->accel_fs);
 800dc90: 6dfb         	ldr	r3, [r7, #0x5c]
 800dc92: f893 3029    	ldrb.w	r3, [r3, #0x29]
 800dc96: 4619         	mov	r1, r3
 800dc98: 6878         	ldr	r0, [r7, #0x4]
 800dc9a: f7ff fc1d    	bl	0x800d4d8 <bmi08x_acc_range_set> @ imm = #-0x7c6
 800dc9e: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800dca0: 6e7b         	ldr	r3, [r7, #0x64]
 800dca2: 2b00         	cmp	r3, #0x0
 800dca4: da30         	bge	0x800dd08 <bmi08x_accel_init+0x2cc> @ imm = #0x60
; 		LOG_ERR("Cannot set default range for accelerometer.");
 800dca6: 2303         	movs	r3, #0x3
 800dca8: 2b00         	cmp	r3, #0x0
 800dcaa: d018         	beq	0x800dcde <bmi08x_accel_init+0x2a2> @ imm = #0x30
 800dcac: 2301         	movs	r3, #0x1
 800dcae: f887 3043    	strb.w	r3, [r7, #0x43]
 800dcb2: f897 3043    	ldrb.w	r3, [r7, #0x43]
 800dcb6: f083 0301    	eor	r3, r3, #0x1
 800dcba: b2db         	uxtb	r3, r3
 800dcbc: 2b00         	cmp	r3, #0x0
 800dcbe: d10e         	bne	0x800dcde <bmi08x_accel_init+0x2a2> @ imm = #0x1c
 800dcc0: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800dce4 <bmi08x_accel_init+0x2a8>
 800dcc2: 6819         	ldr	r1, [r3]
 800dcc4: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800dd04 <bmi08x_accel_init+0x2c8>
 800dcc6: 9302         	str	r3, [sp, #0x8]
 800dcc8: 2300         	movs	r3, #0x0
 800dcca: 9301         	str	r3, [sp, #0x4]
 800dccc: 2300         	movs	r3, #0x0
 800dcce: 9300         	str	r3, [sp]
 800dcd0: 2300         	movs	r3, #0x0
 800dcd2: 2201         	movs	r2, #0x1
 800dcd4: 2000         	movs	r0, #0x0
 800dcd6: f013 ff37    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x13e6e
 800dcda: 2300         	movs	r3, #0x0
 800dcdc: 63fb         	str	r3, [r7, #0x3c]
; 		return ret;
 800dcde: 6e7b         	ldr	r3, [r7, #0x64]
 800dce0: e064         	b	0x800ddac <bmi08x_accel_init+0x370> @ imm = #0xc8
 800dce2: bf00         	nop

0800dce4 <$d>:
 800dce4: dc 06 00 24  	.word	0x240006dc
 800dce8: 58 bb 02 08  	.word	0x0802bb58
 800dcec: 70 bb 02 08  	.word	0x0802bb70
 800dcf0: 84 bb 02 08  	.word	0x0802bb84
 800dcf4: a0 bb 02 08  	.word	0x0802bba0
 800dcf8: b8 bb 02 08  	.word	0x0802bbb8
 800dcfc: dc bb 02 08  	.word	0x0802bbdc
 800dd00: fc bb 02 08  	.word	0x0802bbfc
 800dd04: 1c bc 02 08  	.word	0x0802bc1c

0800dd08 <$t>:
; 					    config->accel_hz);
 800dd08: 6dfb         	ldr	r3, [r7, #0x5c]
 800dd0a: f893 3028    	ldrb.w	r3, [r3, #0x28]
; 	ret = bmi08x_accel_reg_field_update(dev, BMI08X_REG_ACCEL_CONF, 0, BMI08X_ACCEL_ODR_MASK,
 800dd0e: 9300         	str	r3, [sp]
 800dd10: 230f         	movs	r3, #0xf
 800dd12: 2200         	movs	r2, #0x0
 800dd14: 2140         	movs	r1, #0x40
 800dd16: 6878         	ldr	r0, [r7, #0x4]
 800dd18: f014 f8f4    	bl	0x8021f04 <bmi08x_accel_reg_field_update> @ imm = #0x141e8
 800dd1c: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800dd1e: 6e7b         	ldr	r3, [r7, #0x64]
 800dd20: 2b00         	cmp	r3, #0x0
 800dd22: da1d         	bge	0x800dd60 <bmi08x_accel_init+0x324> @ imm = #0x3a
; 		LOG_ERR("Failed to set accel's default ODR.");
 800dd24: 2303         	movs	r3, #0x3
 800dd26: 2b00         	cmp	r3, #0x0
 800dd28: d018         	beq	0x800dd5c <bmi08x_accel_init+0x320> @ imm = #0x30
 800dd2a: 2301         	movs	r3, #0x1
 800dd2c: f887 304b    	strb.w	r3, [r7, #0x4b]
 800dd30: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 800dd34: f083 0301    	eor	r3, r3, #0x1
 800dd38: b2db         	uxtb	r3, r3
 800dd3a: 2b00         	cmp	r3, #0x0
 800dd3c: d10e         	bne	0x800dd5c <bmi08x_accel_init+0x320> @ imm = #0x1c
 800dd3e: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800ddb4 <bmi08x_accel_init+0x378>
 800dd40: 6819         	ldr	r1, [r3]
 800dd42: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800ddb8 <bmi08x_accel_init+0x37c>
 800dd44: 9302         	str	r3, [sp, #0x8]
 800dd46: 2300         	movs	r3, #0x0
 800dd48: 9301         	str	r3, [sp, #0x4]
 800dd4a: 2300         	movs	r3, #0x0
 800dd4c: 9300         	str	r3, [sp]
 800dd4e: 2300         	movs	r3, #0x0
 800dd50: 2201         	movs	r2, #0x1
 800dd52: 2000         	movs	r0, #0x0
 800dd54: f013 fef8    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x13df0
 800dd58: 2300         	movs	r3, #0x0
 800dd5a: 647b         	str	r3, [r7, #0x44]
; 		return ret;
 800dd5c: 6e7b         	ldr	r3, [r7, #0x64]
 800dd5e: e025         	b	0x800ddac <bmi08x_accel_init+0x370> @ imm = #0x4a
; 	ret = bmi08x_acc_trigger_mode_init(dev);
 800dd60: 6878         	ldr	r0, [r7, #0x4]
 800dd62: f000 fc61    	bl	0x800e628 <bmi08x_acc_trigger_mode_init> @ imm = #0x8c2
 800dd66: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800dd68: 6e7b         	ldr	r3, [r7, #0x64]
 800dd6a: 2b00         	cmp	r3, #0x0
 800dd6c: da1d         	bge	0x800ddaa <bmi08x_accel_init+0x36e> @ imm = #0x3a
; 		LOG_ERR("Cannot set up trigger mode.");
 800dd6e: 2303         	movs	r3, #0x3
 800dd70: 2b00         	cmp	r3, #0x0
 800dd72: d018         	beq	0x800dda6 <bmi08x_accel_init+0x36a> @ imm = #0x30
 800dd74: 2301         	movs	r3, #0x1
 800dd76: f887 3053    	strb.w	r3, [r7, #0x53]
 800dd7a: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800dd7e: f083 0301    	eor	r3, r3, #0x1
 800dd82: b2db         	uxtb	r3, r3
 800dd84: 2b00         	cmp	r3, #0x0
 800dd86: d10e         	bne	0x800dda6 <bmi08x_accel_init+0x36a> @ imm = #0x1c
 800dd88: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800ddb4 <bmi08x_accel_init+0x378>
 800dd8a: 6819         	ldr	r1, [r3]
 800dd8c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800ddbc <bmi08x_accel_init+0x380>
 800dd8e: 9302         	str	r3, [sp, #0x8]
 800dd90: 2300         	movs	r3, #0x0
 800dd92: 9301         	str	r3, [sp, #0x4]
 800dd94: 2300         	movs	r3, #0x0
 800dd96: 9300         	str	r3, [sp]
 800dd98: 2300         	movs	r3, #0x0
 800dd9a: 2201         	movs	r2, #0x1
 800dd9c: 2000         	movs	r0, #0x0
 800dd9e: f013 fed3    	bl	0x8021b48 <z_log_msg_runtime_create> @ imm = #0x13da6
 800dda2: 2300         	movs	r3, #0x0
 800dda4: 64fb         	str	r3, [r7, #0x4c]
; 		return ret;
 800dda6: 6e7b         	ldr	r3, [r7, #0x64]
 800dda8: e000         	b	0x800ddac <bmi08x_accel_init+0x370> @ imm = #0x0
; 	return ret;
 800ddaa: 6e7b         	ldr	r3, [r7, #0x64]
; }
 800ddac: 4618         	mov	r0, r3
 800ddae: 3768         	adds	r7, #0x68
 800ddb0: 46bd         	mov	sp, r7
 800ddb2: bd80         	pop	{r7, pc}

0800ddb4 <$d>:
 800ddb4: dc 06 00 24  	.word	0x240006dc
 800ddb8: 48 bc 02 08  	.word	0x0802bc48
 800ddbc: 6c bc 02 08  	.word	0x0802bc6c

0800ddc0 <bmi08x_gyr_range_set>:
; {
 800ddc0: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800ddc4: b08c         	sub	sp, #0x30
 800ddc6: af00         	add	r7, sp, #0x0
 800ddc8: 61f8         	str	r0, [r7, #0x1c]
 800ddca: 460b         	mov	r3, r1
 800ddcc: 837b         	strh	r3, [r7, #0x1a]
; 	struct bmi08x_gyro_data *bmi08x = dev->data;
 800ddce: 69fb         	ldr	r3, [r7, #0x1c]
 800ddd0: 691b         	ldr	r3, [r3, #0x10]
 800ddd2: 62fb         	str	r3, [r7, #0x2c]
; 		bmi08x_range_to_reg_val(range, bmi08x_gyr_range_map, BMI08X_GYR_RANGE_MAP_SIZE);
 800ddd4: 8b7b         	ldrh	r3, [r7, #0x1a]
 800ddd6: 2205         	movs	r2, #0x5
 800ddd8: 493d         	ldr	r1, [pc, #0xf4]         @ 0x800ded0 <bmi08x_gyr_range_set+0x110>
 800ddda: 4618         	mov	r0, r3
 800dddc: f014 fbb6    	bl	0x802254c <bmi08x_range_to_reg_val> @ imm = #0x1476c
 800dde0: 62b8         	str	r0, [r7, #0x28]
; 	if (reg_val < 0) {
 800dde2: 6abb         	ldr	r3, [r7, #0x28]
 800dde4: 2b00         	cmp	r3, #0x0
 800dde6: da01         	bge	0x800ddec <bmi08x_gyr_range_set+0x2c> @ imm = #0x2
; 		return reg_val;
 800dde8: 6abb         	ldr	r3, [r7, #0x28]
 800ddea: e06c         	b	0x800dec6 <bmi08x_gyr_range_set+0x106> @ imm = #0xd8
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_RANGE, reg_val);
 800ddec: 6abb         	ldr	r3, [r7, #0x28]
 800ddee: b2db         	uxtb	r3, r3
 800ddf0: 461a         	mov	r2, r3
 800ddf2: 210f         	movs	r1, #0xf
 800ddf4: 69f8         	ldr	r0, [r7, #0x1c]
 800ddf6: f014 fb0d    	bl	0x8022414 <bmi08x_gyro_byte_write> @ imm = #0x1461a
 800ddfa: 6278         	str	r0, [r7, #0x24]
; 	if (ret < 0) {
 800ddfc: 6a7b         	ldr	r3, [r7, #0x24]
 800ddfe: 2b00         	cmp	r3, #0x0
 800de00: da01         	bge	0x800de06 <bmi08x_gyr_range_set+0x46> @ imm = #0x2
; 		return ret;
 800de02: 6a7b         	ldr	r3, [r7, #0x24]
 800de04: e05f         	b	0x800dec6 <bmi08x_gyr_range_set+0x106> @ imm = #0xbe
; 	bmi08x->scale = BMI08X_GYR_SCALE(range);
 800de06: 8b7b         	ldrh	r3, [r7, #0x1a]
 800de08: 2200         	movs	r2, #0x0
 800de0a: 461c         	mov	r4, r3
 800de0c: 4615         	mov	r5, r2
 800de0e: 4622         	mov	r2, r4
 800de10: 462b         	mov	r3, r5
 800de12: 1891         	adds	r1, r2, r2
 800de14: 60b9         	str	r1, [r7, #0x8]
 800de16: 415b         	adcs	r3, r3
 800de18: 60fb         	str	r3, [r7, #0xc]
 800de1a: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800de1e: 1911         	adds	r1, r2, r4
 800de20: 6139         	str	r1, [r7, #0x10]
 800de22: 416b         	adcs	r3, r5
 800de24: 617b         	str	r3, [r7, #0x14]
 800de26: f04f 0200    	mov.w	r2, #0x0
 800de2a: f04f 0300    	mov.w	r3, #0x0
 800de2e: 6979         	ldr	r1, [r7, #0x14]
 800de30: 020b         	lsls	r3, r1, #0x8
 800de32: 6939         	ldr	r1, [r7, #0x10]
 800de34: ea43 6311    	orr.w	r3, r3, r1, lsr #24
 800de38: 6939         	ldr	r1, [r7, #0x10]
 800de3a: 020a         	lsls	r2, r1, #0x8
 800de3c: 4611         	mov	r1, r2
 800de3e: 461a         	mov	r2, r3
 800de40: 460b         	mov	r3, r1
 800de42: ebb3 0a04    	subs.w	r10, r3, r4
 800de46: 4613         	mov	r3, r2
 800de48: eb63 0b05    	sbc.w	r11, r3, r5
 800de4c: f04f 0200    	mov.w	r2, #0x0
 800de50: f04f 0300    	mov.w	r3, #0x0
 800de54: ea4f 13cb    	lsl.w	r3, r11, #0x7
 800de58: ea43 635a    	orr.w	r3, r3, r10, lsr #25
 800de5c: ea4f 12ca    	lsl.w	r2, r10, #0x7
 800de60: 4692         	mov	r10, r2
 800de62: 469b         	mov	r11, r3
 800de64: ebba 0804    	subs.w	r8, r10, r4
 800de68: eb6b 0905    	sbc.w	r9, r11, r5
 800de6c: f04f 0200    	mov.w	r2, #0x0
 800de70: f04f 0300    	mov.w	r3, #0x0
 800de74: ea4f 0389    	lsl.w	r3, r9, #0x2
 800de78: ea43 7398    	orr.w	r3, r3, r8, lsr #30
 800de7c: ea4f 0288    	lsl.w	r2, r8, #0x2
 800de80: 4690         	mov	r8, r2
 800de82: 4699         	mov	r9, r3
 800de84: ebb8 0304    	subs.w	r3, r8, r4
 800de88: 603b         	str	r3, [r7]
 800de8a: eb69 0305    	sbc.w	r3, r9, r5
 800de8e: 607b         	str	r3, [r7, #0x4]
 800de90: f04f 0200    	mov.w	r2, #0x0
 800de94: f04f 0300    	mov.w	r3, #0x0
 800de98: e9d7 4500    	ldrd	r4, r5, [r7]
 800de9c: 4629         	mov	r1, r5
 800de9e: 010b         	lsls	r3, r1, #0x4
 800dea0: 4621         	mov	r1, r4
 800dea2: ea43 7311    	orr.w	r3, r3, r1, lsr #28
 800dea6: 4621         	mov	r1, r4
 800dea8: 010a         	lsls	r2, r1, #0x4
 800deaa: 4610         	mov	r0, r2
 800deac: 4619         	mov	r1, r3
 800deae: f44f 0234    	mov.w	r2, #0xb40000
 800deb2: f04f 0300    	mov.w	r3, #0x0
 800deb6: f7f2 fa0b    	bl	0x80002d0 <__text_region_start> @ imm = #-0xdbea
 800deba: 4602         	mov	r2, r0
 800debc: 460b         	mov	r3, r1
 800debe: b292         	uxth	r2, r2
 800dec0: 6afb         	ldr	r3, [r7, #0x2c]
 800dec2: 825a         	strh	r2, [r3, #0x12]
; 	return ret;
 800dec4: 6a7b         	ldr	r3, [r7, #0x24]
; }
 800dec6: 4618         	mov	r0, r3
 800dec8: 3730         	adds	r7, #0x30
 800deca: 46bd         	mov	sp, r7
 800decc: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800ded0 <$d>:
 800ded0: 30 d6 02 08  	.word	0x0802d630

0800ded4 <bmi08x_gyr_config>:
; {
 800ded4: b580         	push	{r7, lr}
 800ded6: b08a         	sub	sp, #0x28
 800ded8: af04         	add	r7, sp, #0x10
 800deda: 60f8         	str	r0, [r7, #0xc]
 800dedc: 607b         	str	r3, [r7, #0x4]
 800dede: 460b         	mov	r3, r1
 800dee0: 817b         	strh	r3, [r7, #0xa]
 800dee2: 4613         	mov	r3, r2
 800dee4: 813b         	strh	r3, [r7, #0x8]
; 	switch (attr) {
 800dee6: 893b         	ldrh	r3, [r7, #0x8]
 800dee8: 2b00         	cmp	r3, #0x0
 800deea: d00c         	beq	0x800df06 <bmi08x_gyr_config+0x32> @ imm = #0x18
 800deec: 2b07         	cmp	r3, #0x7
 800deee: d11c         	bne	0x800df2a <bmi08x_gyr_config+0x56> @ imm = #0x38
; 		return bmi08x_gyr_range_set(dev, sensor_rad_to_degrees(val));
 800def0: 6878         	ldr	r0, [r7, #0x4]
 800def2: f7f2 fc49    	bl	0x8000788 <sensor_rad_to_degrees> @ imm = #-0xd76e
 800def6: 4603         	mov	r3, r0
 800def8: b29b         	uxth	r3, r3
 800defa: 4619         	mov	r1, r3
 800defc: 68f8         	ldr	r0, [r7, #0xc]
 800defe: f7ff ff5f    	bl	0x800ddc0 <bmi08x_gyr_range_set> @ imm = #-0x142
 800df02: 4603         	mov	r3, r0
 800df04: e02f         	b	0x800df66 <bmi08x_gyr_config+0x92> @ imm = #0x5e
; 		return bmi08x_gyr_odr_set(dev, val->val1, val->val2 / 1000);
 800df06: 687b         	ldr	r3, [r7, #0x4]
 800df08: 681b         	ldr	r3, [r3]
 800df0a: b299         	uxth	r1, r3
 800df0c: 687b         	ldr	r3, [r7, #0x4]
 800df0e: 685b         	ldr	r3, [r3, #0x4]
 800df10: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800df70 <bmi08x_gyr_config+0x9c>
 800df12: fb82 0203    	smull	r0, r2, r2, r3
 800df16: 1192         	asrs	r2, r2, #0x6
 800df18: 17db         	asrs	r3, r3, #0x1f
 800df1a: 1ad3         	subs	r3, r2, r3
 800df1c: b29b         	uxth	r3, r3
 800df1e: 461a         	mov	r2, r3
 800df20: 68f8         	ldr	r0, [r7, #0xc]
 800df22: f014 fa8f    	bl	0x8022444 <bmi08x_gyr_odr_set> @ imm = #0x1451e
 800df26: 4603         	mov	r3, r0
 800df28: e01d         	b	0x800df66 <bmi08x_gyr_config+0x92> @ imm = #0x3a
; 		LOG_DBG("Gyro attribute not supported.");
 800df2a: 2303         	movs	r3, #0x3
 800df2c: 2b03         	cmp	r3, #0x3
 800df2e: d918         	bls	0x800df62 <bmi08x_gyr_config+0x8e> @ imm = #0x30
 800df30: 2301         	movs	r3, #0x1
 800df32: 75fb         	strb	r3, [r7, #0x17]
 800df34: 7dfb         	ldrb	r3, [r7, #0x17]
 800df36: f083 0301    	eor	r3, r3, #0x1
 800df3a: b2db         	uxtb	r3, r3
 800df3c: 2b00         	cmp	r3, #0x0
 800df3e: d110         	bne	0x800df62 <bmi08x_gyr_config+0x8e> @ imm = #0x20
 800df40: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800df74 <bmi08x_gyr_config+0xa0>
 800df42: 6819         	ldr	r1, [r3]
 800df44: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800df78 <bmi08x_gyr_config+0xa4>
 800df46: 9303         	str	r3, [sp, #0xc]
 800df48: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800df7c <bmi08x_gyr_config+0xa8>
 800df4a: 9302         	str	r3, [sp, #0x8]
 800df4c: 2308         	movs	r3, #0x8
 800df4e: 9301         	str	r3, [sp, #0x4]
 800df50: 2300         	movs	r3, #0x0
 800df52: 9300         	str	r3, [sp]
 800df54: 2300         	movs	r3, #0x0
 800df56: 2204         	movs	r2, #0x4
 800df58: 2000         	movs	r0, #0x0
 800df5a: f014 f8ce    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x1419c
 800df5e: 2300         	movs	r3, #0x0
 800df60: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800df62: f06f 0385    	mvn	r3, #0x85
; }
 800df66: 4618         	mov	r0, r3
 800df68: 3718         	adds	r7, #0x18
 800df6a: 46bd         	mov	sp, r7
 800df6c: bd80         	pop	{r7, pc}
 800df6e: bf00         	nop

0800df70 <$d>:
 800df70: d3 4d 62 10  	.word	0x10624dd3
 800df74: e0 06 00 24  	.word	0x240006e0
 800df78: 70 d6 02 08  	.word	0x0802d670
 800df7c: a4 bc 02 08  	.word	0x0802bca4

0800df80 <bmi08x_attr_set>:
; {
 800df80: b580         	push	{r7, lr}
 800df82: b08a         	sub	sp, #0x28
 800df84: af04         	add	r7, sp, #0x10
 800df86: 60f8         	str	r0, [r7, #0xc]
 800df88: 607b         	str	r3, [r7, #0x4]
 800df8a: 460b         	mov	r3, r1
 800df8c: 817b         	strh	r3, [r7, #0xa]
 800df8e: 4613         	mov	r3, r2
 800df90: 813b         	strh	r3, [r7, #0x8]
; 	switch (chan) {
 800df92: 897b         	ldrh	r3, [r7, #0xa]
 800df94: 3b04         	subs	r3, #0x4
 800df96: 2b03         	cmp	r3, #0x3
 800df98: d807         	bhi	0x800dfaa <bmi08x_attr_set+0x2a> @ imm = #0xe
; 		return bmi08x_gyr_config(dev, chan, attr, val);
 800df9a: 893a         	ldrh	r2, [r7, #0x8]
 800df9c: 8979         	ldrh	r1, [r7, #0xa]
 800df9e: 687b         	ldr	r3, [r7, #0x4]
 800dfa0: 68f8         	ldr	r0, [r7, #0xc]
 800dfa2: f7ff ff97    	bl	0x800ded4 <bmi08x_gyr_config> @ imm = #-0xd2
 800dfa6: 4603         	mov	r3, r0
 800dfa8: e01d         	b	0x800dfe6 <bmi08x_attr_set+0x66> @ imm = #0x3a
; 		LOG_DBG("attr_set() not supported on this channel.");
 800dfaa: 2303         	movs	r3, #0x3
 800dfac: 2b03         	cmp	r3, #0x3
 800dfae: d918         	bls	0x800dfe2 <bmi08x_attr_set+0x62> @ imm = #0x30
 800dfb0: 2301         	movs	r3, #0x1
 800dfb2: 75fb         	strb	r3, [r7, #0x17]
 800dfb4: 7dfb         	ldrb	r3, [r7, #0x17]
 800dfb6: f083 0301    	eor	r3, r3, #0x1
 800dfba: b2db         	uxtb	r3, r3
 800dfbc: 2b00         	cmp	r3, #0x0
 800dfbe: d110         	bne	0x800dfe2 <bmi08x_attr_set+0x62> @ imm = #0x20
 800dfc0: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800dff0 <bmi08x_attr_set+0x70>
 800dfc2: 6819         	ldr	r1, [r3]
 800dfc4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800dff4 <bmi08x_attr_set+0x74>
 800dfc6: 9303         	str	r3, [sp, #0xc]
 800dfc8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800dff8 <bmi08x_attr_set+0x78>
 800dfca: 9302         	str	r3, [sp, #0x8]
 800dfcc: 2308         	movs	r3, #0x8
 800dfce: 9301         	str	r3, [sp, #0x4]
 800dfd0: 2300         	movs	r3, #0x0
 800dfd2: 9300         	str	r3, [sp]
 800dfd4: 2300         	movs	r3, #0x0
 800dfd6: 2204         	movs	r2, #0x4
 800dfd8: 2000         	movs	r0, #0x0
 800dfda: f014 f88e    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x1411c
 800dfde: 2300         	movs	r3, #0x0
 800dfe0: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800dfe2: f06f 0385    	mvn	r3, #0x85
; }
 800dfe6: 4618         	mov	r0, r3
 800dfe8: 3718         	adds	r7, #0x18
 800dfea: 46bd         	mov	sp, r7
 800dfec: bd80         	pop	{r7, pc}
 800dfee: bf00         	nop

0800dff0 <$d>:
 800dff0: e0 06 00 24  	.word	0x240006e0
 800dff4: 84 d6 02 08  	.word	0x0802d684
 800dff8: c8 bc 02 08  	.word	0x0802bcc8

0800dffc <bmi08x_sample_fetch>:
; {
 800dffc: b580         	push	{r7, lr}
 800dffe: b08c         	sub	sp, #0x30
 800e000: af04         	add	r7, sp, #0x10
 800e002: 6078         	str	r0, [r7, #0x4]
 800e004: 460b         	mov	r3, r1
 800e006: 807b         	strh	r3, [r7, #0x2]
; 	struct bmi08x_gyro_data *bmi08x = dev->data;
 800e008: 687b         	ldr	r3, [r7, #0x4]
 800e00a: 691b         	ldr	r3, [r3, #0x10]
 800e00c: 61bb         	str	r3, [r7, #0x18]
; 	if (chan != SENSOR_CHAN_ALL && chan != SENSOR_CHAN_GYRO_XYZ) {
 800e00e: 887b         	ldrh	r3, [r7, #0x2]
 800e010: 2b3c         	cmp	r3, #0x3c
 800e012: d021         	beq	0x800e058 <bmi08x_sample_fetch+0x5c> @ imm = #0x42
 800e014: 887b         	ldrh	r3, [r7, #0x2]
 800e016: 2b07         	cmp	r3, #0x7
 800e018: d01e         	beq	0x800e058 <bmi08x_sample_fetch+0x5c> @ imm = #0x3c
; 		LOG_DBG("Unsupported sensor channel");
 800e01a: 2303         	movs	r3, #0x3
 800e01c: 2b03         	cmp	r3, #0x3
 800e01e: d918         	bls	0x800e052 <bmi08x_sample_fetch+0x56> @ imm = #0x30
 800e020: 2301         	movs	r3, #0x1
 800e022: 75fb         	strb	r3, [r7, #0x17]
 800e024: 7dfb         	ldrb	r3, [r7, #0x17]
 800e026: f083 0301    	eor	r3, r3, #0x1
 800e02a: b2db         	uxtb	r3, r3
 800e02c: 2b00         	cmp	r3, #0x0
 800e02e: d110         	bne	0x800e052 <bmi08x_sample_fetch+0x56> @ imm = #0x20
 800e030: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800e0ac <bmi08x_sample_fetch+0xb0>
 800e032: 6819         	ldr	r1, [r3]
 800e034: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800e0b0 <bmi08x_sample_fetch+0xb4>
 800e036: 9303         	str	r3, [sp, #0xc]
 800e038: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800e0b4 <bmi08x_sample_fetch+0xb8>
 800e03a: 9302         	str	r3, [sp, #0x8]
 800e03c: 2308         	movs	r3, #0x8
 800e03e: 9301         	str	r3, [sp, #0x4]
 800e040: 2300         	movs	r3, #0x0
 800e042: 9300         	str	r3, [sp]
 800e044: 2300         	movs	r3, #0x0
 800e046: 2204         	movs	r2, #0x4
 800e048: 2000         	movs	r0, #0x0
 800e04a: f014 f856    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x140ac
 800e04e: 2300         	movs	r3, #0x0
 800e050: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800e052: f06f 0385    	mvn	r3, #0x85
 800e056: e024         	b	0x800e0a2 <bmi08x_sample_fetch+0xa6> @ imm = #0x48
; 	ret = bmi08x_gyro_read(dev, BMI08X_REG_GYRO_X_LSB, (uint8_t *)bmi08x->gyr_sample,
 800e058: 69bb         	ldr	r3, [r7, #0x18]
 800e05a: f103 020c    	add.w	r2, r3, #0xc
 800e05e: 2306         	movs	r3, #0x6
 800e060: 2102         	movs	r1, #0x2
 800e062: 6878         	ldr	r0, [r7, #0x4]
 800e064: f014 f9a5    	bl	0x80223b2 <bmi08x_gyro_read> @ imm = #0x1434a
 800e068: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 800e06a: 68fb         	ldr	r3, [r7, #0xc]
 800e06c: 2b00         	cmp	r3, #0x0
 800e06e: da01         	bge	0x800e074 <bmi08x_sample_fetch+0x78> @ imm = #0x2
; 		return ret;
 800e070: 68fb         	ldr	r3, [r7, #0xc]
 800e072: e016         	b	0x800e0a2 <bmi08x_sample_fetch+0xa6> @ imm = #0x2c
; 	for (i = 0; i < ARRAY_SIZE(bmi08x->gyr_sample); i++) {
 800e074: 2300         	movs	r3, #0x0
 800e076: 61fb         	str	r3, [r7, #0x1c]
 800e078: e00f         	b	0x800e09a <bmi08x_sample_fetch+0x9e> @ imm = #0x1e
; 		bmi08x->gyr_sample[i] = sys_le16_to_cpu(bmi08x->gyr_sample[i]);
 800e07a: 69ba         	ldr	r2, [r7, #0x18]
 800e07c: 69fb         	ldr	r3, [r7, #0x1c]
 800e07e: 3304         	adds	r3, #0x4
 800e080: 005b         	lsls	r3, r3, #0x1
 800e082: 4413         	add	r3, r2
 800e084: 8899         	ldrh	r1, [r3, #0x4]
 800e086: 69ba         	ldr	r2, [r7, #0x18]
 800e088: 69fb         	ldr	r3, [r7, #0x1c]
 800e08a: 3304         	adds	r3, #0x4
 800e08c: 005b         	lsls	r3, r3, #0x1
 800e08e: 4413         	add	r3, r2
 800e090: 460a         	mov	r2, r1
 800e092: 809a         	strh	r2, [r3, #0x4]
; 	for (i = 0; i < ARRAY_SIZE(bmi08x->gyr_sample); i++) {
 800e094: 69fb         	ldr	r3, [r7, #0x1c]
 800e096: 3301         	adds	r3, #0x1
 800e098: 61fb         	str	r3, [r7, #0x1c]
 800e09a: 69fb         	ldr	r3, [r7, #0x1c]
 800e09c: 2b02         	cmp	r3, #0x2
 800e09e: d9ec         	bls	0x800e07a <bmi08x_sample_fetch+0x7e> @ imm = #-0x28
; 	return ret;
 800e0a0: 68fb         	ldr	r3, [r7, #0xc]
; }
 800e0a2: 4618         	mov	r0, r3
 800e0a4: 3720         	adds	r7, #0x20
 800e0a6: 46bd         	mov	sp, r7
 800e0a8: bd80         	pop	{r7, pc}
 800e0aa: bf00         	nop

0800e0ac <$d>:
 800e0ac: e0 06 00 24  	.word	0x240006e0
 800e0b0: 94 d6 02 08  	.word	0x0802d694
 800e0b4: f8 bc 02 08  	.word	0x0802bcf8

0800e0b8 <bmi08x_to_fixed_point>:
; {
 800e0b8: b480         	push	{r7}
 800e0ba: b085         	sub	sp, #0x14
 800e0bc: af00         	add	r7, sp, #0x0
 800e0be: 4603         	mov	r3, r0
 800e0c0: 603a         	str	r2, [r7]
 800e0c2: 80fb         	strh	r3, [r7, #0x6]
 800e0c4: 460b         	mov	r3, r1
 800e0c6: 80bb         	strh	r3, [r7, #0x4]
; 	converted_val = raw_val * scale;
 800e0c8: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 800e0cc: 88ba         	ldrh	r2, [r7, #0x4]
 800e0ce: fb02 f303    	mul	r3, r2, r3
 800e0d2: 60fb         	str	r3, [r7, #0xc]
; 	val->val1 = converted_val / 1000000;
 800e0d4: 68fb         	ldr	r3, [r7, #0xc]
 800e0d6: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800e10c <bmi08x_to_fixed_point+0x54>
 800e0d8: fb82 1203    	smull	r1, r2, r2, r3
 800e0dc: 1492         	asrs	r2, r2, #0x12
 800e0de: 17db         	asrs	r3, r3, #0x1f
 800e0e0: 1ad2         	subs	r2, r2, r3
 800e0e2: 683b         	ldr	r3, [r7]
 800e0e4: 601a         	str	r2, [r3]
; 	val->val2 = converted_val % 1000000;
 800e0e6: 68fa         	ldr	r2, [r7, #0xc]
 800e0e8: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800e10c <bmi08x_to_fixed_point+0x54>
 800e0ea: fb83 1302    	smull	r1, r3, r3, r2
 800e0ee: 1499         	asrs	r1, r3, #0x12
 800e0f0: 17d3         	asrs	r3, r2, #0x1f
 800e0f2: 1acb         	subs	r3, r1, r3
 800e0f4: 4906         	ldr	r1, [pc, #0x18]         @ 0x800e110 <bmi08x_to_fixed_point+0x58>
 800e0f6: fb01 f303    	mul	r3, r1, r3
 800e0fa: 1ad3         	subs	r3, r2, r3
 800e0fc: 683a         	ldr	r2, [r7]
 800e0fe: 6053         	str	r3, [r2, #0x4]
; }
 800e100: bf00         	nop
 800e102: 3714         	adds	r7, #0x14
 800e104: 46bd         	mov	sp, r7
 800e106: f85d 7b04    	ldr	r7, [sp], #4
 800e10a: 4770         	bx	lr

0800e10c <$d>:
 800e10c: 83 de 1b 43  	.word	0x431bde83
 800e110: 40 42 0f 00  	.word	0x000f4240

0800e114 <bmi08x_channel_get>:
; {
 800e114: b580         	push	{r7, lr}
 800e116: b08a         	sub	sp, #0x28
 800e118: af04         	add	r7, sp, #0x10
 800e11a: 60f8         	str	r0, [r7, #0xc]
 800e11c: 460b         	mov	r3, r1
 800e11e: 607a         	str	r2, [r7, #0x4]
 800e120: 817b         	strh	r3, [r7, #0xa]
; 	switch ((int16_t)chan) {
 800e122: f9b7 300a    	ldrsh.w	r3, [r7, #0xa]
 800e126: 3b04         	subs	r3, #0x4
 800e128: 2b03         	cmp	r3, #0x3
 800e12a: d807         	bhi	0x800e13c <bmi08x_channel_get+0x28> @ imm = #0xe
; 		bmi08x_gyr_channel_get(dev, chan, val);
 800e12c: 897b         	ldrh	r3, [r7, #0xa]
 800e12e: 687a         	ldr	r2, [r7, #0x4]
 800e130: 4619         	mov	r1, r3
 800e132: 68f8         	ldr	r0, [r7, #0xc]
 800e134: f014 f9f3    	bl	0x802251e <bmi08x_gyr_channel_get> @ imm = #0x143e6
; 		return 0;
 800e138: 2300         	movs	r3, #0x0
 800e13a: e01d         	b	0x800e178 <bmi08x_channel_get+0x64> @ imm = #0x3a
; 		LOG_DBG("Channel not supported.");
 800e13c: 2303         	movs	r3, #0x3
 800e13e: 2b03         	cmp	r3, #0x3
 800e140: d918         	bls	0x800e174 <bmi08x_channel_get+0x60> @ imm = #0x30
 800e142: 2301         	movs	r3, #0x1
 800e144: 75fb         	strb	r3, [r7, #0x17]
 800e146: 7dfb         	ldrb	r3, [r7, #0x17]
 800e148: f083 0301    	eor	r3, r3, #0x1
 800e14c: b2db         	uxtb	r3, r3
 800e14e: 2b00         	cmp	r3, #0x0
 800e150: d110         	bne	0x800e174 <bmi08x_channel_get+0x60> @ imm = #0x20
 800e152: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800e180 <bmi08x_channel_get+0x6c>
 800e154: 6819         	ldr	r1, [r3]
 800e156: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800e184 <bmi08x_channel_get+0x70>
 800e158: 9303         	str	r3, [sp, #0xc]
 800e15a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800e188 <bmi08x_channel_get+0x74>
 800e15c: 9302         	str	r3, [sp, #0x8]
 800e15e: 2308         	movs	r3, #0x8
 800e160: 9301         	str	r3, [sp, #0x4]
 800e162: 2300         	movs	r3, #0x0
 800e164: 9300         	str	r3, [sp]
 800e166: 2300         	movs	r3, #0x0
 800e168: 2204         	movs	r2, #0x4
 800e16a: 2000         	movs	r0, #0x0
 800e16c: f013 ffc5    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x13f8a
 800e170: 2300         	movs	r3, #0x0
 800e172: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800e174: f06f 0385    	mvn	r3, #0x85
; }
 800e178: 4618         	mov	r0, r3
 800e17a: 3718         	adds	r7, #0x18
 800e17c: 46bd         	mov	sp, r7
 800e17e: bd80         	pop	{r7, pc}

0800e180 <$d>:
 800e180: e0 06 00 24  	.word	0x240006e0
 800e184: a8 d6 02 08  	.word	0x0802d6a8
 800e188: 18 bd 02 08  	.word	0x0802bd18

0800e18c <bmi08x_gyro_init>:
; {
 800e18c: b580         	push	{r7, lr}
 800e18e: b09e         	sub	sp, #0x78
 800e190: af04         	add	r7, sp, #0x10
 800e192: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_gyro_config *config = dev->config;
 800e194: 687b         	ldr	r3, [r7, #0x4]
 800e196: 685b         	ldr	r3, [r3, #0x4]
 800e198: 663b         	str	r3, [r7, #0x60]
; 	uint8_t val = 0U;
 800e19a: 2300         	movs	r3, #0x0
 800e19c: 73fb         	strb	r3, [r7, #0xf]
; 	ret = bmi08x_bus_check(dev);
 800e19e: 6878         	ldr	r0, [r7, #0x4]
 800e1a0: f014 f8da    	bl	0x8022358 <bmi08x_bus_check> @ imm = #0x141b4
 800e1a4: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800e1a6: 6e7b         	ldr	r3, [r7, #0x64]
 800e1a8: 2b00         	cmp	r3, #0x0
 800e1aa: da1e         	bge	0x800e1ea <bmi08x_gyro_init+0x5e> @ imm = #0x3c
; 		LOG_ERR("Bus not ready for '%s'", dev->name);
 800e1ac: 2303         	movs	r3, #0x3
 800e1ae: 2b00         	cmp	r3, #0x0
 800e1b0: d019         	beq	0x800e1e6 <bmi08x_gyro_init+0x5a> @ imm = #0x32
 800e1b2: 2301         	movs	r3, #0x1
 800e1b4: 75fb         	strb	r3, [r7, #0x17]
 800e1b6: 7dfb         	ldrb	r3, [r7, #0x17]
 800e1b8: f083 0301    	eor	r3, r3, #0x1
 800e1bc: b2db         	uxtb	r3, r3
 800e1be: 2b00         	cmp	r3, #0x0
 800e1c0: d111         	bne	0x800e1e6 <bmi08x_gyro_init+0x5a> @ imm = #0x22
 800e1c2: 4ba8         	ldr	r3, [pc, #0x2a0]        @ 0x800e464 <bmi08x_gyro_init+0x2d8>
 800e1c4: 6819         	ldr	r1, [r3]
 800e1c6: 687b         	ldr	r3, [r7, #0x4]
 800e1c8: 681b         	ldr	r3, [r3]
 800e1ca: 9303         	str	r3, [sp, #0xc]
 800e1cc: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x800e468 <bmi08x_gyro_init+0x2dc>
 800e1ce: 9302         	str	r3, [sp, #0x8]
 800e1d0: 2300         	movs	r3, #0x0
 800e1d2: 9301         	str	r3, [sp, #0x4]
 800e1d4: 2300         	movs	r3, #0x0
 800e1d6: 9300         	str	r3, [sp]
 800e1d8: 2300         	movs	r3, #0x0
 800e1da: 2201         	movs	r2, #0x1
 800e1dc: 2000         	movs	r0, #0x0
 800e1de: f013 ff8c    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x13f18
 800e1e2: 2300         	movs	r3, #0x0
 800e1e4: 613b         	str	r3, [r7, #0x10]
; 		return ret;
 800e1e6: 6e7b         	ldr	r3, [r7, #0x64]
 800e1e8: e179         	b	0x800e4de <bmi08x_gyro_init+0x352> @ imm = #0x2f2
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_SOFTRESET, BMI08X_SOFT_RESET_CMD);
 800e1ea: 22b6         	movs	r2, #0xb6
 800e1ec: 2114         	movs	r1, #0x14
 800e1ee: 6878         	ldr	r0, [r7, #0x4]
 800e1f0: f014 f910    	bl	0x8022414 <bmi08x_gyro_byte_write> @ imm = #0x14220
 800e1f4: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800e1f6: 6e7b         	ldr	r3, [r7, #0x64]
 800e1f8: 2b00         	cmp	r3, #0x0
 800e1fa: da1b         	bge	0x800e234 <bmi08x_gyro_init+0xa8> @ imm = #0x36
; 		LOG_ERR("Cannot reboot chip.");
 800e1fc: 2303         	movs	r3, #0x3
 800e1fe: 2b00         	cmp	r3, #0x0
 800e200: d016         	beq	0x800e230 <bmi08x_gyro_init+0xa4> @ imm = #0x2c
 800e202: 2301         	movs	r3, #0x1
 800e204: 77fb         	strb	r3, [r7, #0x1f]
 800e206: 7ffb         	ldrb	r3, [r7, #0x1f]
 800e208: f083 0301    	eor	r3, r3, #0x1
 800e20c: b2db         	uxtb	r3, r3
 800e20e: 2b00         	cmp	r3, #0x0
 800e210: d10e         	bne	0x800e230 <bmi08x_gyro_init+0xa4> @ imm = #0x1c
 800e212: 4b94         	ldr	r3, [pc, #0x250]        @ 0x800e464 <bmi08x_gyro_init+0x2d8>
 800e214: 6819         	ldr	r1, [r3]
 800e216: 4b95         	ldr	r3, [pc, #0x254]        @ 0x800e46c <bmi08x_gyro_init+0x2e0>
 800e218: 9302         	str	r3, [sp, #0x8]
 800e21a: 2300         	movs	r3, #0x0
 800e21c: 9301         	str	r3, [sp, #0x4]
 800e21e: 2300         	movs	r3, #0x0
 800e220: 9300         	str	r3, [sp]
 800e222: 2300         	movs	r3, #0x0
 800e224: 2201         	movs	r2, #0x1
 800e226: 2000         	movs	r0, #0x0
 800e228: f013 ff67    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x13ece
 800e22c: 2300         	movs	r3, #0x0
 800e22e: 61bb         	str	r3, [r7, #0x18]
; 		return ret;
 800e230: 6e7b         	ldr	r3, [r7, #0x64]
 800e232: e154         	b	0x800e4de <bmi08x_gyro_init+0x352> @ imm = #0x2a8
; 	k_msleep(BMI08X_GYRO_SOFTRESET_DELAY);
 800e234: 201e         	movs	r0, #0x1e
 800e236: f013 ff26    	bl	0x8022086 <k_msleep>    @ imm = #0x13e4c
; 	ret = bmi08x_gyro_byte_read(dev, BMI08X_REG_GYRO_CHIP_ID, &val);
 800e23a: f107 030f    	add.w	r3, r7, #0xf
 800e23e: 461a         	mov	r2, r3
 800e240: 2100         	movs	r1, #0x0
 800e242: 6878         	ldr	r0, [r7, #0x4]
 800e244: f014 f8cf    	bl	0x80223e6 <bmi08x_gyro_byte_read> @ imm = #0x1419e
 800e248: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800e24a: 6e7b         	ldr	r3, [r7, #0x64]
 800e24c: 2b00         	cmp	r3, #0x0
 800e24e: da1d         	bge	0x800e28c <bmi08x_gyro_init+0x100> @ imm = #0x3a
; 		LOG_ERR("Failed to read chip id.");
 800e250: 2303         	movs	r3, #0x3
 800e252: 2b00         	cmp	r3, #0x0
 800e254: d018         	beq	0x800e288 <bmi08x_gyro_init+0xfc> @ imm = #0x30
 800e256: 2301         	movs	r3, #0x1
 800e258: f887 3027    	strb.w	r3, [r7, #0x27]
 800e25c: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800e260: f083 0301    	eor	r3, r3, #0x1
 800e264: b2db         	uxtb	r3, r3
 800e266: 2b00         	cmp	r3, #0x0
 800e268: d10e         	bne	0x800e288 <bmi08x_gyro_init+0xfc> @ imm = #0x1c
 800e26a: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x800e464 <bmi08x_gyro_init+0x2d8>
 800e26c: 6819         	ldr	r1, [r3]
 800e26e: 4b80         	ldr	r3, [pc, #0x200]        @ 0x800e470 <bmi08x_gyro_init+0x2e4>
 800e270: 9302         	str	r3, [sp, #0x8]
 800e272: 2300         	movs	r3, #0x0
 800e274: 9301         	str	r3, [sp, #0x4]
 800e276: 2300         	movs	r3, #0x0
 800e278: 9300         	str	r3, [sp]
 800e27a: 2300         	movs	r3, #0x0
 800e27c: 2201         	movs	r2, #0x1
 800e27e: 2000         	movs	r0, #0x0
 800e280: f013 ff3b    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x13e76
 800e284: 2300         	movs	r3, #0x0
 800e286: 623b         	str	r3, [r7, #0x20]
; 		return ret;
 800e288: 6e7b         	ldr	r3, [r7, #0x64]
 800e28a: e128         	b	0x800e4de <bmi08x_gyro_init+0x352> @ imm = #0x250
; 	if (val != BMI08X_GYRO_CHIP_ID) {
 800e28c: 7bfb         	ldrb	r3, [r7, #0xf]
 800e28e: 2b0f         	cmp	r3, #0xf
 800e290: d020         	beq	0x800e2d4 <bmi08x_gyro_init+0x148> @ imm = #0x40
; 		LOG_ERR("Unsupported chip detected (0x%02x)!", val);
 800e292: 2303         	movs	r3, #0x3
 800e294: 2b00         	cmp	r3, #0x0
 800e296: d01a         	beq	0x800e2ce <bmi08x_gyro_init+0x142> @ imm = #0x34
 800e298: 2301         	movs	r3, #0x1
 800e29a: f887 302f    	strb.w	r3, [r7, #0x2f]
 800e29e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800e2a2: f083 0301    	eor	r3, r3, #0x1
 800e2a6: b2db         	uxtb	r3, r3
 800e2a8: 2b00         	cmp	r3, #0x0
 800e2aa: d110         	bne	0x800e2ce <bmi08x_gyro_init+0x142> @ imm = #0x20
 800e2ac: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x800e464 <bmi08x_gyro_init+0x2d8>
 800e2ae: 6819         	ldr	r1, [r3]
 800e2b0: 7bfb         	ldrb	r3, [r7, #0xf]
 800e2b2: 9303         	str	r3, [sp, #0xc]
 800e2b4: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x800e474 <bmi08x_gyro_init+0x2e8>
 800e2b6: 9302         	str	r3, [sp, #0x8]
 800e2b8: 2300         	movs	r3, #0x0
 800e2ba: 9301         	str	r3, [sp, #0x4]
 800e2bc: 2300         	movs	r3, #0x0
 800e2be: 9300         	str	r3, [sp]
 800e2c0: 2300         	movs	r3, #0x0
 800e2c2: 2201         	movs	r2, #0x1
 800e2c4: 2000         	movs	r0, #0x0
 800e2c6: f013 ff18    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x13e30
 800e2ca: 2300         	movs	r3, #0x0
 800e2cc: 62bb         	str	r3, [r7, #0x28]
; 		return -ENODEV;
 800e2ce: f06f 0312    	mvn	r3, #0x12
 800e2d2: e104         	b	0x800e4de <bmi08x_gyro_init+0x352> @ imm = #0x208
; 	ret = bmi08x_gyr_range_set(dev, config->gyro_fs);
 800e2d4: 6e3b         	ldr	r3, [r7, #0x60]
 800e2d6: 8d1b         	ldrh	r3, [r3, #0x28]
 800e2d8: 4619         	mov	r1, r3
 800e2da: 6878         	ldr	r0, [r7, #0x4]
 800e2dc: f7ff fd70    	bl	0x800ddc0 <bmi08x_gyr_range_set> @ imm = #-0x520
 800e2e0: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800e2e2: 6e7b         	ldr	r3, [r7, #0x64]
 800e2e4: 2b00         	cmp	r3, #0x0
 800e2e6: da1d         	bge	0x800e324 <bmi08x_gyro_init+0x198> @ imm = #0x3a
; 		LOG_ERR("Cannot set default range for gyroscope.");
 800e2e8: 2303         	movs	r3, #0x3
 800e2ea: 2b00         	cmp	r3, #0x0
 800e2ec: d018         	beq	0x800e320 <bmi08x_gyro_init+0x194> @ imm = #0x30
 800e2ee: 2301         	movs	r3, #0x1
 800e2f0: f887 3037    	strb.w	r3, [r7, #0x37]
 800e2f4: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800e2f8: f083 0301    	eor	r3, r3, #0x1
 800e2fc: b2db         	uxtb	r3, r3
 800e2fe: 2b00         	cmp	r3, #0x0
 800e300: d10e         	bne	0x800e320 <bmi08x_gyro_init+0x194> @ imm = #0x1c
 800e302: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800e464 <bmi08x_gyro_init+0x2d8>
 800e304: 6819         	ldr	r1, [r3]
 800e306: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800e478 <bmi08x_gyro_init+0x2ec>
 800e308: 9302         	str	r3, [sp, #0x8]
 800e30a: 2300         	movs	r3, #0x0
 800e30c: 9301         	str	r3, [sp, #0x4]
 800e30e: 2300         	movs	r3, #0x0
 800e310: 9300         	str	r3, [sp]
 800e312: 2300         	movs	r3, #0x0
 800e314: 2201         	movs	r2, #0x1
 800e316: 2000         	movs	r0, #0x0
 800e318: f013 feef    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x13dde
 800e31c: 2300         	movs	r3, #0x0
 800e31e: 633b         	str	r3, [r7, #0x30]
; 		return ret;
 800e320: 6e7b         	ldr	r3, [r7, #0x64]
 800e322: e0dc         	b	0x800e4de <bmi08x_gyro_init+0x352> @ imm = #0x1b8
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_BANDWIDTH, config->gyro_hz);
 800e324: 6e3b         	ldr	r3, [r7, #0x60]
 800e326: f893 3026    	ldrb.w	r3, [r3, #0x26]
 800e32a: 461a         	mov	r2, r3
 800e32c: 2110         	movs	r1, #0x10
 800e32e: 6878         	ldr	r0, [r7, #0x4]
 800e330: f014 f870    	bl	0x8022414 <bmi08x_gyro_byte_write> @ imm = #0x140e0
 800e334: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800e336: 6e7b         	ldr	r3, [r7, #0x64]
 800e338: 2b00         	cmp	r3, #0x0
 800e33a: da1d         	bge	0x800e378 <bmi08x_gyro_init+0x1ec> @ imm = #0x3a
; 		LOG_ERR("Failed to set gyro's default ODR.");
 800e33c: 2303         	movs	r3, #0x3
 800e33e: 2b00         	cmp	r3, #0x0
 800e340: d018         	beq	0x800e374 <bmi08x_gyro_init+0x1e8> @ imm = #0x30
 800e342: 2301         	movs	r3, #0x1
 800e344: f887 303f    	strb.w	r3, [r7, #0x3f]
 800e348: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800e34c: f083 0301    	eor	r3, r3, #0x1
 800e350: b2db         	uxtb	r3, r3
 800e352: 2b00         	cmp	r3, #0x0
 800e354: d10e         	bne	0x800e374 <bmi08x_gyro_init+0x1e8> @ imm = #0x1c
 800e356: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800e464 <bmi08x_gyro_init+0x2d8>
 800e358: 6819         	ldr	r1, [r3]
 800e35a: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800e47c <bmi08x_gyro_init+0x2f0>
 800e35c: 9302         	str	r3, [sp, #0x8]
 800e35e: 2300         	movs	r3, #0x0
 800e360: 9301         	str	r3, [sp, #0x4]
 800e362: 2300         	movs	r3, #0x0
 800e364: 9300         	str	r3, [sp]
 800e366: 2300         	movs	r3, #0x0
 800e368: 2201         	movs	r2, #0x1
 800e36a: 2000         	movs	r0, #0x0
 800e36c: f013 fec5    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x13d8a
 800e370: 2300         	movs	r3, #0x0
 800e372: 63bb         	str	r3, [r7, #0x38]
; 		return ret;
 800e374: 6e7b         	ldr	r3, [r7, #0x64]
 800e376: e0b2         	b	0x800e4de <bmi08x_gyro_init+0x352> @ imm = #0x164
; 	ret = bmi08x_gyr_trigger_mode_init(dev);
 800e378: 6878         	ldr	r0, [r7, #0x4]
 800e37a: f000 faed    	bl	0x800e958 <bmi08x_gyr_trigger_mode_init> @ imm = #0x5da
 800e37e: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800e380: 6e7b         	ldr	r3, [r7, #0x64]
 800e382: 2b00         	cmp	r3, #0x0
 800e384: da1d         	bge	0x800e3c2 <bmi08x_gyro_init+0x236> @ imm = #0x3a
; 		LOG_ERR("Cannot set up trigger mode.");
 800e386: 2303         	movs	r3, #0x3
 800e388: 2b00         	cmp	r3, #0x0
 800e38a: d018         	beq	0x800e3be <bmi08x_gyro_init+0x232> @ imm = #0x30
 800e38c: 2301         	movs	r3, #0x1
 800e38e: f887 3047    	strb.w	r3, [r7, #0x47]
 800e392: f897 3047    	ldrb.w	r3, [r7, #0x47]
 800e396: f083 0301    	eor	r3, r3, #0x1
 800e39a: b2db         	uxtb	r3, r3
 800e39c: 2b00         	cmp	r3, #0x0
 800e39e: d10e         	bne	0x800e3be <bmi08x_gyro_init+0x232> @ imm = #0x1c
 800e3a0: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x800e464 <bmi08x_gyro_init+0x2d8>
 800e3a2: 6819         	ldr	r1, [r3]
 800e3a4: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800e480 <bmi08x_gyro_init+0x2f4>
 800e3a6: 9302         	str	r3, [sp, #0x8]
 800e3a8: 2300         	movs	r3, #0x0
 800e3aa: 9301         	str	r3, [sp, #0x4]
 800e3ac: 2300         	movs	r3, #0x0
 800e3ae: 9300         	str	r3, [sp]
 800e3b0: 2300         	movs	r3, #0x0
 800e3b2: 2201         	movs	r2, #0x1
 800e3b4: 2000         	movs	r0, #0x0
 800e3b6: f013 fea0    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x13d40
 800e3ba: 2300         	movs	r3, #0x0
 800e3bc: 643b         	str	r3, [r7, #0x40]
; 		return ret;
 800e3be: 6e7b         	ldr	r3, [r7, #0x64]
 800e3c0: e08d         	b	0x800e4de <bmi08x_gyro_init+0x352> @ imm = #0x11a
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_INT_CTRL, 0x80);
 800e3c2: 2280         	movs	r2, #0x80
 800e3c4: 2115         	movs	r1, #0x15
 800e3c6: 6878         	ldr	r0, [r7, #0x4]
 800e3c8: f014 f824    	bl	0x8022414 <bmi08x_gyro_byte_write> @ imm = #0x14048
 800e3cc: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800e3ce: 6e7b         	ldr	r3, [r7, #0x64]
 800e3d0: 2b00         	cmp	r3, #0x0
 800e3d2: da1d         	bge	0x800e410 <bmi08x_gyro_init+0x284> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800e3d4: 2303         	movs	r3, #0x3
 800e3d6: 2b00         	cmp	r3, #0x0
 800e3d8: d018         	beq	0x800e40c <bmi08x_gyro_init+0x280> @ imm = #0x30
 800e3da: 2301         	movs	r3, #0x1
 800e3dc: f887 304f    	strb.w	r3, [r7, #0x4f]
 800e3e0: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 800e3e4: f083 0301    	eor	r3, r3, #0x1
 800e3e8: b2db         	uxtb	r3, r3
 800e3ea: 2b00         	cmp	r3, #0x0
 800e3ec: d10e         	bne	0x800e40c <bmi08x_gyro_init+0x280> @ imm = #0x1c
 800e3ee: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800e464 <bmi08x_gyro_init+0x2d8>
 800e3f0: 6819         	ldr	r1, [r3]
 800e3f2: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800e484 <bmi08x_gyro_init+0x2f8>
 800e3f4: 9302         	str	r3, [sp, #0x8]
 800e3f6: 2300         	movs	r3, #0x0
 800e3f8: 9301         	str	r3, [sp, #0x4]
 800e3fa: 2300         	movs	r3, #0x0
 800e3fc: 9300         	str	r3, [sp]
 800e3fe: 2300         	movs	r3, #0x0
 800e400: 2201         	movs	r2, #0x1
 800e402: 2000         	movs	r0, #0x0
 800e404: f013 fe79    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x13cf2
 800e408: 2300         	movs	r3, #0x0
 800e40a: 64bb         	str	r3, [r7, #0x48]
; 		return ret;
 800e40c: 6e7b         	ldr	r3, [r7, #0x64]
 800e40e: e066         	b	0x800e4de <bmi08x_gyro_init+0x352> @ imm = #0xcc
; 				     config->int3_4_conf_io);
 800e410: 6e3b         	ldr	r3, [r7, #0x60]
 800e412: f893 3025    	ldrb.w	r3, [r3, #0x25]
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_INT3_INT4_IO_CONF,
 800e416: 461a         	mov	r2, r3
 800e418: 2116         	movs	r1, #0x16
 800e41a: 6878         	ldr	r0, [r7, #0x4]
 800e41c: f013 fffa    	bl	0x8022414 <bmi08x_gyro_byte_write> @ imm = #0x13ff4
 800e420: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800e422: 6e7b         	ldr	r3, [r7, #0x64]
 800e424: 2b00         	cmp	r3, #0x0
 800e426: da2f         	bge	0x800e488 <bmi08x_gyro_init+0x2fc> @ imm = #0x5e
; 		LOG_ERR("Failed to map interrupts.");
 800e428: 2303         	movs	r3, #0x3
 800e42a: 2b00         	cmp	r3, #0x0
 800e42c: d018         	beq	0x800e460 <bmi08x_gyro_init+0x2d4> @ imm = #0x30
 800e42e: 2301         	movs	r3, #0x1
 800e430: f887 3057    	strb.w	r3, [r7, #0x57]
 800e434: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800e438: f083 0301    	eor	r3, r3, #0x1
 800e43c: b2db         	uxtb	r3, r3
 800e43e: 2b00         	cmp	r3, #0x0
 800e440: d10e         	bne	0x800e460 <bmi08x_gyro_init+0x2d4> @ imm = #0x1c
 800e442: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800e464 <bmi08x_gyro_init+0x2d8>
 800e444: 6819         	ldr	r1, [r3]
 800e446: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800e484 <bmi08x_gyro_init+0x2f8>
 800e448: 9302         	str	r3, [sp, #0x8]
 800e44a: 2300         	movs	r3, #0x0
 800e44c: 9301         	str	r3, [sp, #0x4]
 800e44e: 2300         	movs	r3, #0x0
 800e450: 9300         	str	r3, [sp]
 800e452: 2300         	movs	r3, #0x0
 800e454: 2201         	movs	r2, #0x1
 800e456: 2000         	movs	r0, #0x0
 800e458: f013 fe4f    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x13c9e
 800e45c: 2300         	movs	r3, #0x0
 800e45e: 653b         	str	r3, [r7, #0x50]
; 		return ret;
 800e460: 6e7b         	ldr	r3, [r7, #0x64]
 800e462: e03c         	b	0x800e4de <bmi08x_gyro_init+0x352> @ imm = #0x78

0800e464 <$d>:
 800e464: e0 06 00 24  	.word	0x240006e0
 800e468: 34 bd 02 08  	.word	0x0802bd34
 800e46c: 4c bd 02 08  	.word	0x0802bd4c
 800e470: 60 bd 02 08  	.word	0x0802bd60
 800e474: 78 bd 02 08  	.word	0x0802bd78
 800e478: 9c bd 02 08  	.word	0x0802bd9c
 800e47c: c4 bd 02 08  	.word	0x0802bdc4
 800e480: e8 bd 02 08  	.word	0x0802bde8
 800e484: 04 be 02 08  	.word	0x0802be04

0800e488 <$t>:
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_INT3_INT4_IO_MAP, config->int3_4_map);
 800e488: 6e3b         	ldr	r3, [r7, #0x60]
 800e48a: f893 3024    	ldrb.w	r3, [r3, #0x24]
 800e48e: 461a         	mov	r2, r3
 800e490: 2118         	movs	r1, #0x18
 800e492: 6878         	ldr	r0, [r7, #0x4]
 800e494: f013 ffbe    	bl	0x8022414 <bmi08x_gyro_byte_write> @ imm = #0x13f7c
 800e498: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800e49a: 6e7b         	ldr	r3, [r7, #0x64]
 800e49c: 2b00         	cmp	r3, #0x0
 800e49e: da1d         	bge	0x800e4dc <bmi08x_gyro_init+0x350> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800e4a0: 2303         	movs	r3, #0x3
 800e4a2: 2b00         	cmp	r3, #0x0
 800e4a4: d018         	beq	0x800e4d8 <bmi08x_gyro_init+0x34c> @ imm = #0x30
 800e4a6: 2301         	movs	r3, #0x1
 800e4a8: f887 305f    	strb.w	r3, [r7, #0x5f]
 800e4ac: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 800e4b0: f083 0301    	eor	r3, r3, #0x1
 800e4b4: b2db         	uxtb	r3, r3
 800e4b6: 2b00         	cmp	r3, #0x0
 800e4b8: d10e         	bne	0x800e4d8 <bmi08x_gyro_init+0x34c> @ imm = #0x1c
 800e4ba: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800e4e8 <bmi08x_gyro_init+0x35c>
 800e4bc: 6819         	ldr	r1, [r3]
 800e4be: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800e4ec <bmi08x_gyro_init+0x360>
 800e4c0: 9302         	str	r3, [sp, #0x8]
 800e4c2: 2300         	movs	r3, #0x0
 800e4c4: 9301         	str	r3, [sp, #0x4]
 800e4c6: 2300         	movs	r3, #0x0
 800e4c8: 9300         	str	r3, [sp]
 800e4ca: 2300         	movs	r3, #0x0
 800e4cc: 2201         	movs	r2, #0x1
 800e4ce: 2000         	movs	r0, #0x0
 800e4d0: f013 fe13    	bl	0x80220fa <z_log_msg_runtime_create> @ imm = #0x13c26
 800e4d4: 2300         	movs	r3, #0x0
 800e4d6: 65bb         	str	r3, [r7, #0x58]
; 		return ret;
 800e4d8: 6e7b         	ldr	r3, [r7, #0x64]
 800e4da: e000         	b	0x800e4de <bmi08x_gyro_init+0x352> @ imm = #0x0
; 	return ret;
 800e4dc: 6e7b         	ldr	r3, [r7, #0x64]
; }
 800e4de: 4618         	mov	r0, r3
 800e4e0: 3768         	adds	r7, #0x68
 800e4e2: 46bd         	mov	sp, r7
 800e4e4: bd80         	pop	{r7, pc}
 800e4e6: bf00         	nop

0800e4e8 <$d>:
 800e4e8: e0 06 00 24  	.word	0x240006e0
 800e4ec: 04 be 02 08  	.word	0x0802be04

0800e4f0 <bmi08x_freq_to_odr_val>:
; {
 800e4f0: b480         	push	{r7}
 800e4f2: b085         	sub	sp, #0x14
 800e4f4: af00         	add	r7, sp, #0x0
 800e4f6: 4603         	mov	r3, r0
 800e4f8: 460a         	mov	r2, r1
 800e4fa: 80fb         	strh	r3, [r7, #0x6]
 800e4fc: 4613         	mov	r3, r2
 800e4fe: 80bb         	strh	r3, [r7, #0x4]
; 	if (freq_int == 0U && freq_milli == 0U) {
 800e500: 88fb         	ldrh	r3, [r7, #0x6]
 800e502: 2b00         	cmp	r3, #0x0
 800e504: d105         	bne	0x800e512 <bmi08x_freq_to_odr_val+0x22> @ imm = #0xa
 800e506: 88bb         	ldrh	r3, [r7, #0x4]
 800e508: 2b00         	cmp	r3, #0x0
 800e50a: d102         	bne	0x800e512 <bmi08x_freq_to_odr_val+0x22> @ imm = #0x4
; 		return -EINVAL;
 800e50c: f06f 0315    	mvn	r3, #0x15
 800e510: e022         	b	0x800e558 <bmi08x_freq_to_odr_val+0x68> @ imm = #0x44
; 	for (i = 0; i < ARRAY_SIZE(bmi08x_odr_map); i++) {
 800e512: 2300         	movs	r3, #0x0
 800e514: 60fb         	str	r3, [r7, #0xc]
 800e516: e01a         	b	0x800e54e <bmi08x_freq_to_odr_val+0x5e> @ imm = #0x34
; 		if (freq_int < bmi08x_odr_map[i].freq_int ||
 800e518: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800e564 <bmi08x_freq_to_odr_val+0x74>
 800e51a: 68fb         	ldr	r3, [r7, #0xc]
 800e51c: f832 3023    	ldrh.w	r3, [r2, r3, lsl #2]
 800e520: 88fa         	ldrh	r2, [r7, #0x6]
 800e522: 429a         	cmp	r2, r3
 800e524: d30e         	blo	0x800e544 <bmi08x_freq_to_odr_val+0x54> @ imm = #0x1c
; 		    (freq_int == bmi08x_odr_map[i].freq_int &&
 800e526: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x800e564 <bmi08x_freq_to_odr_val+0x74>
 800e528: 68fb         	ldr	r3, [r7, #0xc]
 800e52a: f832 3023    	ldrh.w	r3, [r2, r3, lsl #2]
; 		if (freq_int < bmi08x_odr_map[i].freq_int ||
 800e52e: 88fa         	ldrh	r2, [r7, #0x6]
 800e530: 429a         	cmp	r2, r3
 800e532: d109         	bne	0x800e548 <bmi08x_freq_to_odr_val+0x58> @ imm = #0x12
; 		     freq_milli <= bmi08x_odr_map[i].freq_milli)) {
 800e534: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800e564 <bmi08x_freq_to_odr_val+0x74>
 800e536: 68fb         	ldr	r3, [r7, #0xc]
 800e538: 009b         	lsls	r3, r3, #0x2
 800e53a: 4413         	add	r3, r2
 800e53c: 885b         	ldrh	r3, [r3, #0x2]
; 		    (freq_int == bmi08x_odr_map[i].freq_int &&
 800e53e: 88ba         	ldrh	r2, [r7, #0x4]
 800e540: 429a         	cmp	r2, r3
 800e542: d801         	bhi	0x800e548 <bmi08x_freq_to_odr_val+0x58> @ imm = #0x2
; 			return i;
 800e544: 68fb         	ldr	r3, [r7, #0xc]
 800e546: e007         	b	0x800e558 <bmi08x_freq_to_odr_val+0x68> @ imm = #0xe
; 	for (i = 0; i < ARRAY_SIZE(bmi08x_odr_map); i++) {
 800e548: 68fb         	ldr	r3, [r7, #0xc]
 800e54a: 3301         	adds	r3, #0x1
 800e54c: 60fb         	str	r3, [r7, #0xc]
 800e54e: 68fb         	ldr	r3, [r7, #0xc]
 800e550: 2b0d         	cmp	r3, #0xd
 800e552: d9e1         	bls	0x800e518 <bmi08x_freq_to_odr_val+0x28> @ imm = #-0x3e
; 	return -EINVAL;
 800e554: f06f 0315    	mvn	r3, #0x15
; }
 800e558: 4618         	mov	r0, r3
 800e55a: 3714         	adds	r7, #0x14
 800e55c: 46bd         	mov	sp, r7
 800e55e: f85d 7b04    	ldr	r7, [sp], #4
 800e562: 4770         	bx	lr

0800e564 <$d>:
 800e564: bc d6 02 08  	.word	0x0802d6bc

0800e568 <z_impl_gpio_pin_interrupt_configure>:
; {
 800e568: b590         	push	{r4, r7, lr}
 800e56a: b08b         	sub	sp, #0x2c
 800e56c: af00         	add	r7, sp, #0x0
 800e56e: 60f8         	str	r0, [r7, #0xc]
 800e570: 460b         	mov	r3, r1
 800e572: 607a         	str	r2, [r7, #0x4]
 800e574: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 800e576: 68fb         	ldr	r3, [r7, #0xc]
 800e578: 689b         	ldr	r3, [r3, #0x8]
 800e57a: 627b         	str	r3, [r7, #0x24]
; 	__unused const struct gpio_driver_config *const cfg =
 800e57c: 68fb         	ldr	r3, [r7, #0xc]
 800e57e: 685b         	ldr	r3, [r3, #0x4]
 800e580: 623b         	str	r3, [r7, #0x20]
; 	const struct gpio_driver_data *const data =
 800e582: 68fb         	ldr	r3, [r7, #0xc]
 800e584: 691b         	ldr	r3, [r3, #0x10]
 800e586: 61fb         	str	r3, [r7, #0x1c]
; 	if (api->pin_interrupt_configure == NULL) {
 800e588: 6a7b         	ldr	r3, [r7, #0x24]
 800e58a: 699b         	ldr	r3, [r3, #0x18]
 800e58c: 2b00         	cmp	r3, #0x0
 800e58e: d102         	bne	0x800e596 <z_impl_gpio_pin_interrupt_configure+0x2e> @ imm = #0x4
; 		return -ENOSYS;
 800e590: f06f 0357    	mvn	r3, #0x57
 800e594: e021         	b	0x800e5da <z_impl_gpio_pin_interrupt_configure+0x72> @ imm = #0x42
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 800e596: 687b         	ldr	r3, [r7, #0x4]
 800e598: f403 0300    	and	r3, r3, #0x800000
 800e59c: 2b00         	cmp	r3, #0x0
 800e59e: d00c         	beq	0x800e5ba <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x18
; 	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
 800e5a0: 69fb         	ldr	r3, [r7, #0x1c]
 800e5a2: 681a         	ldr	r2, [r3]
 800e5a4: 7afb         	ldrb	r3, [r7, #0xb]
 800e5a6: 2101         	movs	r1, #0x1
 800e5a8: fa01 f303    	lsl.w	r3, r1, r3
 800e5ac: 4013         	ands	r3, r2
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 800e5ae: 2b00         	cmp	r3, #0x0
 800e5b0: d003         	beq	0x800e5ba <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x6
; 		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
 800e5b2: 687b         	ldr	r3, [r7, #0x4]
 800e5b4: f083 63c0    	eor	r3, r3, #0x6000000
 800e5b8: 607b         	str	r3, [r7, #0x4]
; 	trig = (enum gpio_int_trig)(flags & (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1 | GPIO_INT_WAKEUP));
 800e5ba: 687a         	ldr	r2, [r7, #0x4]
 800e5bc: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800e5e4 <z_impl_gpio_pin_interrupt_configure+0x7c>
 800e5be: 4013         	ands	r3, r2
 800e5c0: 61bb         	str	r3, [r7, #0x18]
; 	mode = (enum gpio_int_mode)(flags & (GPIO_INT_EDGE | GPIO_INT_DISABLE | GPIO_INT_ENABLE));
 800e5c2: 687b         	ldr	r3, [r7, #0x4]
 800e5c4: f003 73b0    	and	r3, r3, #0x1600000
 800e5c8: 617b         	str	r3, [r7, #0x14]
; 	return api->pin_interrupt_configure(port, pin, mode, trig);
 800e5ca: 6a7b         	ldr	r3, [r7, #0x24]
 800e5cc: 699c         	ldr	r4, [r3, #0x18]
 800e5ce: 7af9         	ldrb	r1, [r7, #0xb]
 800e5d0: 69bb         	ldr	r3, [r7, #0x18]
 800e5d2: 697a         	ldr	r2, [r7, #0x14]
 800e5d4: 68f8         	ldr	r0, [r7, #0xc]
 800e5d6: 47a0         	blx	r4
 800e5d8: 4603         	mov	r3, r0
; }
 800e5da: 4618         	mov	r0, r3
 800e5dc: 372c         	adds	r7, #0x2c
 800e5de: 46bd         	mov	sp, r7
 800e5e0: bd90         	pop	{r4, r7, pc}
 800e5e2: bf00         	nop

0800e5e4 <$d>:
 800e5e4: 40 00 00 06  	.word	0x06000040

0800e5e8 <bmi08x_acc_thread_main>:
; {
 800e5e8: b580         	push	{r7, lr}
 800e5ea: b086         	sub	sp, #0x18
 800e5ec: af00         	add	r7, sp, #0x0
 800e5ee: 60f8         	str	r0, [r7, #0xc]
 800e5f0: 60b9         	str	r1, [r7, #0x8]
 800e5f2: 607a         	str	r2, [r7, #0x4]
; 	k_thread_name_set(NULL, "bmi08x_acc_trig");
 800e5f4: 490b         	ldr	r1, [pc, #0x2c]         @ 0x800e624 <bmi08x_acc_thread_main+0x3c>
 800e5f6: 2000         	movs	r0, #0x0
 800e5f8: f014 f8cd    	bl	0x8022796 <k_thread_name_set> @ imm = #0x1419a
; 	const struct device *dev = (const struct device *)arg1;
 800e5fc: 68fb         	ldr	r3, [r7, #0xc]
 800e5fe: 617b         	str	r3, [r7, #0x14]
; 	struct bmi08x_accel_data *data = dev->data;
 800e600: 697b         	ldr	r3, [r7, #0x14]
 800e602: 691b         	ldr	r3, [r3, #0x10]
 800e604: 613b         	str	r3, [r7, #0x10]
; 		k_sem_take(&data->sem, K_FOREVER);
 800e606: 693b         	ldr	r3, [r7, #0x10]
 800e608: f503 61e6    	add.w	r1, r3, #0x730
 800e60c: f04f 32ff    	mov.w	r2, #0xffffffff
 800e610: f04f 33ff    	mov.w	r3, #0xffffffff
 800e614: 4608         	mov	r0, r1
 800e616: f014 f8dc    	bl	0x80227d2 <k_sem_take>  @ imm = #0x141b8
; 		bmi08x_handle_interrupts_acc((void *)dev);
 800e61a: 6978         	ldr	r0, [r7, #0x14]
 800e61c: f014 f92b    	bl	0x8022876 <bmi08x_handle_interrupts_acc> @ imm = #0x14256
; 	while (1) {
 800e620: bf00         	nop
 800e622: e7f0         	b	0x800e606 <bmi08x_acc_thread_main+0x1e> @ imm = #-0x20

0800e624 <$d>:
 800e624: 30 be 02 08  	.word	0x0802be30

0800e628 <bmi08x_acc_trigger_mode_init>:
; {
 800e628: b5b0         	push	{r4, r5, r7, lr}
 800e62a: b098         	sub	sp, #0x60
 800e62c: af08         	add	r7, sp, #0x20
 800e62e: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_accel_data *data = dev->data;
 800e630: 687b         	ldr	r3, [r7, #0x4]
 800e632: 691b         	ldr	r3, [r3, #0x10]
 800e634: 63fb         	str	r3, [r7, #0x3c]
; 	const struct bmi08x_accel_config *cfg = dev->config;
 800e636: 687b         	ldr	r3, [r7, #0x4]
 800e638: 685b         	ldr	r3, [r3, #0x4]
 800e63a: 63bb         	str	r3, [r7, #0x38]
; 	int ret = 0;
 800e63c: 2300         	movs	r3, #0x0
 800e63e: 637b         	str	r3, [r7, #0x34]
; 	if (!gpio_is_ready_dt(&cfg->int_gpio)) {
 800e640: 6bbb         	ldr	r3, [r7, #0x38]
 800e642: 331c         	adds	r3, #0x1c
 800e644: 4618         	mov	r0, r3
 800e646: f013 ffb5    	bl	0x80225b4 <gpio_is_ready_dt> @ imm = #0x13f6a
 800e64a: 4603         	mov	r3, r0
 800e64c: f083 0301    	eor	r3, r3, #0x1
 800e650: b2db         	uxtb	r3, r3
 800e652: 2b00         	cmp	r3, #0x0
 800e654: d01c         	beq	0x800e690 <bmi08x_acc_trigger_mode_init+0x68> @ imm = #0x38
; 		LOG_ERR("GPIO device not ready");
 800e656: 2303         	movs	r3, #0x3
 800e658: 2b00         	cmp	r3, #0x0
 800e65a: d016         	beq	0x800e68a <bmi08x_acc_trigger_mode_init+0x62> @ imm = #0x2c
 800e65c: 2301         	movs	r3, #0x1
 800e65e: 74fb         	strb	r3, [r7, #0x13]
 800e660: 7cfb         	ldrb	r3, [r7, #0x13]
 800e662: f083 0301    	eor	r3, r3, #0x1
 800e666: b2db         	uxtb	r3, r3
 800e668: 2b00         	cmp	r3, #0x0
 800e66a: d10e         	bne	0x800e68a <bmi08x_acc_trigger_mode_init+0x62> @ imm = #0x1c
 800e66c: 4b84         	ldr	r3, [pc, #0x210]        @ 0x800e880 <bmi08x_acc_trigger_mode_init+0x258>
 800e66e: 6819         	ldr	r1, [r3]
 800e670: 4b84         	ldr	r3, [pc, #0x210]        @ 0x800e884 <bmi08x_acc_trigger_mode_init+0x25c>
 800e672: 9302         	str	r3, [sp, #0x8]
 800e674: 2300         	movs	r3, #0x0
 800e676: 9301         	str	r3, [sp, #0x4]
 800e678: 2300         	movs	r3, #0x0
 800e67a: 9300         	str	r3, [sp]
 800e67c: 2300         	movs	r3, #0x0
 800e67e: 2201         	movs	r2, #0x1
 800e680: 2000         	movs	r0, #0x0
 800e682: f014 f8c1    	bl	0x8022808 <z_log_msg_runtime_create> @ imm = #0x14182
 800e686: 2300         	movs	r3, #0x0
 800e688: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800e68a: f06f 0312    	mvn	r3, #0x12
 800e68e: e0f2         	b	0x800e876 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0x1e4
; 	k_sem_init(&data->sem, 0, K_SEM_MAX_LIMIT);
 800e690: 6bfb         	ldr	r3, [r7, #0x3c]
 800e692: f503 63e6    	add.w	r3, r3, #0x730
 800e696: f04f 32ff    	mov.w	r2, #0xffffffff
 800e69a: 2100         	movs	r1, #0x0
 800e69c: 4618         	mov	r0, r3
 800e69e: f014 f888    	bl	0x80227b2 <k_sem_init>  @ imm = #0x14110
; 	k_thread_create(&data->thread, data->thread_stack,
 800e6a2: 6bfb         	ldr	r3, [r7, #0x3c]
 800e6a4: f503 64c3    	add.w	r4, r3, #0x618
 800e6a8: 6bfb         	ldr	r3, [r7, #0x3c]
 800e6aa: f103 0518    	add.w	r5, r3, #0x18
; 			NULL, NULL, K_PRIO_COOP(CONFIG_BMI08X_ACCEL_THREAD_PRIORITY), 0, K_NO_WAIT);
 800e6ae: f04f 0000    	mov.w	r0, #0x0
 800e6b2: f04f 0100    	mov.w	r1, #0x0
; 	k_thread_create(&data->thread, data->thread_stack,
 800e6b6: e9cd 0106    	strd	r0, r1, [sp, #24]
 800e6ba: 2300         	movs	r3, #0x0
 800e6bc: 9304         	str	r3, [sp, #0x10]
 800e6be: f06f 0305    	mvn	r3, #0x5
 800e6c2: 9303         	str	r3, [sp, #0xc]
 800e6c4: 2300         	movs	r3, #0x0
 800e6c6: 9302         	str	r3, [sp, #0x8]
 800e6c8: 2300         	movs	r3, #0x0
 800e6ca: 9301         	str	r3, [sp, #0x4]
 800e6cc: 687b         	ldr	r3, [r7, #0x4]
 800e6ce: 9300         	str	r3, [sp]
 800e6d0: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x800e888 <bmi08x_acc_trigger_mode_init+0x260>
 800e6d2: f44f 62c0    	mov.w	r2, #0x600
 800e6d6: 4629         	mov	r1, r5
 800e6d8: 4620         	mov	r0, r4
 800e6da: f014 f83c    	bl	0x8022756 <k_thread_create> @ imm = #0x14078
; 		uint8_t map_data = ((cfg->int2_map << BMI08X_ACCEL_INT2_DRDY_POS) |
 800e6de: 6bbb         	ldr	r3, [r7, #0x38]
 800e6e0: f893 3025    	ldrb.w	r3, [r3, #0x25]
 800e6e4: 019b         	lsls	r3, r3, #0x6
 800e6e6: b25a         	sxtb	r2, r3
; 				    (cfg->int1_map << BMI08X_ACCEL_INT1_DRDY_POS));
 800e6e8: 6bbb         	ldr	r3, [r7, #0x38]
 800e6ea: f893 3024    	ldrb.w	r3, [r3, #0x24]
 800e6ee: 009b         	lsls	r3, r3, #0x2
; 		uint8_t map_data = ((cfg->int2_map << BMI08X_ACCEL_INT2_DRDY_POS) |
 800e6f0: b25b         	sxtb	r3, r3
 800e6f2: 4313         	orrs	r3, r2
 800e6f4: b25b         	sxtb	r3, r3
 800e6f6: f887 3033    	strb.w	r3, [r7, #0x33]
; 		ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_INT1_INT2_MAP_DATA, map_data);
 800e6fa: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800e6fe: 461a         	mov	r2, r3
 800e700: 2158         	movs	r1, #0x58
 800e702: 6878         	ldr	r0, [r7, #0x4]
 800e704: f013 fbe6    	bl	0x8021ed4 <bmi08x_accel_byte_write> @ imm = #0x137cc
 800e708: 6378         	str	r0, [r7, #0x34]
; 		if (ret < 0) {
 800e70a: 6b7b         	ldr	r3, [r7, #0x34]
 800e70c: 2b00         	cmp	r3, #0x0
 800e70e: da1b         	bge	0x800e748 <bmi08x_acc_trigger_mode_init+0x120> @ imm = #0x36
; 			LOG_ERR("Failed to map interrupts.");
 800e710: 2303         	movs	r3, #0x3
 800e712: 2b00         	cmp	r3, #0x0
 800e714: d016         	beq	0x800e744 <bmi08x_acc_trigger_mode_init+0x11c> @ imm = #0x2c
 800e716: 2301         	movs	r3, #0x1
 800e718: 76fb         	strb	r3, [r7, #0x1b]
 800e71a: 7efb         	ldrb	r3, [r7, #0x1b]
 800e71c: f083 0301    	eor	r3, r3, #0x1
 800e720: b2db         	uxtb	r3, r3
 800e722: 2b00         	cmp	r3, #0x0
 800e724: d10e         	bne	0x800e744 <bmi08x_acc_trigger_mode_init+0x11c> @ imm = #0x1c
 800e726: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800e880 <bmi08x_acc_trigger_mode_init+0x258>
 800e728: 6819         	ldr	r1, [r3]
 800e72a: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800e88c <bmi08x_acc_trigger_mode_init+0x264>
 800e72c: 9302         	str	r3, [sp, #0x8]
 800e72e: 2300         	movs	r3, #0x0
 800e730: 9301         	str	r3, [sp, #0x4]
 800e732: 2300         	movs	r3, #0x0
 800e734: 9300         	str	r3, [sp]
 800e736: 2300         	movs	r3, #0x0
 800e738: 2201         	movs	r2, #0x1
 800e73a: 2000         	movs	r0, #0x0
 800e73c: f014 f864    	bl	0x8022808 <z_log_msg_runtime_create> @ imm = #0x140c8
 800e740: 2300         	movs	r3, #0x0
 800e742: 617b         	str	r3, [r7, #0x14]
; 			return ret;
 800e744: 6b7b         	ldr	r3, [r7, #0x34]
 800e746: e096         	b	0x800e876 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0x12c
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_INT1_IO_CONF, cfg->int1_conf_io);
 800e748: 6bbb         	ldr	r3, [r7, #0x38]
 800e74a: f893 3026    	ldrb.w	r3, [r3, #0x26]
 800e74e: 461a         	mov	r2, r3
 800e750: 2153         	movs	r1, #0x53
 800e752: 6878         	ldr	r0, [r7, #0x4]
 800e754: f013 fbbe    	bl	0x8021ed4 <bmi08x_accel_byte_write> @ imm = #0x1377c
 800e758: 6378         	str	r0, [r7, #0x34]
; 	if (ret < 0) {
 800e75a: 6b7b         	ldr	r3, [r7, #0x34]
 800e75c: 2b00         	cmp	r3, #0x0
 800e75e: da1d         	bge	0x800e79c <bmi08x_acc_trigger_mode_init+0x174> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800e760: 2303         	movs	r3, #0x3
 800e762: 2b00         	cmp	r3, #0x0
 800e764: d018         	beq	0x800e798 <bmi08x_acc_trigger_mode_init+0x170> @ imm = #0x30
 800e766: 2301         	movs	r3, #0x1
 800e768: f887 3023    	strb.w	r3, [r7, #0x23]
 800e76c: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800e770: f083 0301    	eor	r3, r3, #0x1
 800e774: b2db         	uxtb	r3, r3
 800e776: 2b00         	cmp	r3, #0x0
 800e778: d10e         	bne	0x800e798 <bmi08x_acc_trigger_mode_init+0x170> @ imm = #0x1c
 800e77a: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800e880 <bmi08x_acc_trigger_mode_init+0x258>
 800e77c: 6819         	ldr	r1, [r3]
 800e77e: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800e88c <bmi08x_acc_trigger_mode_init+0x264>
 800e780: 9302         	str	r3, [sp, #0x8]
 800e782: 2300         	movs	r3, #0x0
 800e784: 9301         	str	r3, [sp, #0x4]
 800e786: 2300         	movs	r3, #0x0
 800e788: 9300         	str	r3, [sp]
 800e78a: 2300         	movs	r3, #0x0
 800e78c: 2201         	movs	r2, #0x1
 800e78e: 2000         	movs	r0, #0x0
 800e790: f014 f83a    	bl	0x8022808 <z_log_msg_runtime_create> @ imm = #0x14074
 800e794: 2300         	movs	r3, #0x0
 800e796: 61fb         	str	r3, [r7, #0x1c]
; 		return ret;
 800e798: 6b7b         	ldr	r3, [r7, #0x34]
 800e79a: e06c         	b	0x800e876 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0xd8
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_INT2_IO_CONF, cfg->int2_conf_io);
 800e79c: 6bbb         	ldr	r3, [r7, #0x38]
 800e79e: f893 3027    	ldrb.w	r3, [r3, #0x27]
 800e7a2: 461a         	mov	r2, r3
 800e7a4: 2154         	movs	r1, #0x54
 800e7a6: 6878         	ldr	r0, [r7, #0x4]
 800e7a8: f013 fb94    	bl	0x8021ed4 <bmi08x_accel_byte_write> @ imm = #0x13728
 800e7ac: 6378         	str	r0, [r7, #0x34]
; 	if (ret < 0) {
 800e7ae: 6b7b         	ldr	r3, [r7, #0x34]
 800e7b0: 2b00         	cmp	r3, #0x0
 800e7b2: da1d         	bge	0x800e7f0 <bmi08x_acc_trigger_mode_init+0x1c8> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800e7b4: 2303         	movs	r3, #0x3
 800e7b6: 2b00         	cmp	r3, #0x0
 800e7b8: d018         	beq	0x800e7ec <bmi08x_acc_trigger_mode_init+0x1c4> @ imm = #0x30
 800e7ba: 2301         	movs	r3, #0x1
 800e7bc: f887 302b    	strb.w	r3, [r7, #0x2b]
 800e7c0: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800e7c4: f083 0301    	eor	r3, r3, #0x1
 800e7c8: b2db         	uxtb	r3, r3
 800e7ca: 2b00         	cmp	r3, #0x0
 800e7cc: d10e         	bne	0x800e7ec <bmi08x_acc_trigger_mode_init+0x1c4> @ imm = #0x1c
 800e7ce: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800e880 <bmi08x_acc_trigger_mode_init+0x258>
 800e7d0: 6819         	ldr	r1, [r3]
 800e7d2: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x800e88c <bmi08x_acc_trigger_mode_init+0x264>
 800e7d4: 9302         	str	r3, [sp, #0x8]
 800e7d6: 2300         	movs	r3, #0x0
 800e7d8: 9301         	str	r3, [sp, #0x4]
 800e7da: 2300         	movs	r3, #0x0
 800e7dc: 9300         	str	r3, [sp]
 800e7de: 2300         	movs	r3, #0x0
 800e7e0: 2201         	movs	r2, #0x1
 800e7e2: 2000         	movs	r0, #0x0
 800e7e4: f014 f810    	bl	0x8022808 <z_log_msg_runtime_create> @ imm = #0x14020
 800e7e8: 2300         	movs	r3, #0x0
 800e7ea: 627b         	str	r3, [r7, #0x24]
; 		return ret;
 800e7ec: 6b7b         	ldr	r3, [r7, #0x34]
 800e7ee: e042         	b	0x800e876 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0x84
; 	gpio_pin_configure_dt(&cfg->int_gpio, GPIO_INPUT);
 800e7f0: 6bbb         	ldr	r3, [r7, #0x38]
 800e7f2: 331c         	adds	r3, #0x1c
 800e7f4: f44f 3180    	mov.w	r1, #0x10000
 800e7f8: 4618         	mov	r0, r3
 800e7fa: f013 ff46    	bl	0x802268a <gpio_pin_configure_dt> @ imm = #0x13e8c
; 	gpio_init_callback(&data->gpio_cb, bmi08x_acc_gpio_callback, BIT(cfg->int_gpio.pin));
 800e7fe: 6bf8         	ldr	r0, [r7, #0x3c]
 800e800: 6bbb         	ldr	r3, [r7, #0x38]
 800e802: f893 3020    	ldrb.w	r3, [r3, #0x20]
 800e806: 461a         	mov	r2, r3
 800e808: 2301         	movs	r3, #0x1
 800e80a: 4093         	lsls	r3, r2
 800e80c: 461a         	mov	r2, r3
 800e80e: 4920         	ldr	r1, [pc, #0x80]         @ 0x800e890 <bmi08x_acc_trigger_mode_init+0x268>
 800e810: f013 ff51    	bl	0x80226b6 <gpio_init_callback> @ imm = #0x13ea2
; 	ret = gpio_add_callback(cfg->int_gpio.port, &data->gpio_cb);
 800e814: 6bbb         	ldr	r3, [r7, #0x38]
 800e816: 69db         	ldr	r3, [r3, #0x1c]
 800e818: 6bfa         	ldr	r2, [r7, #0x3c]
 800e81a: 4611         	mov	r1, r2
 800e81c: 4618         	mov	r0, r3
 800e81e: f013 ff5c    	bl	0x80226da <gpio_add_callback> @ imm = #0x13eb8
 800e822: 6378         	str	r0, [r7, #0x34]
; 	if (ret < 0) {
 800e824: 6b7b         	ldr	r3, [r7, #0x34]
 800e826: 2b00         	cmp	r3, #0x0
 800e828: da1d         	bge	0x800e866 <bmi08x_acc_trigger_mode_init+0x23e> @ imm = #0x3a
; 		LOG_ERR("Failed to set gpio callback.");
 800e82a: 2303         	movs	r3, #0x3
 800e82c: 2b00         	cmp	r3, #0x0
 800e82e: d018         	beq	0x800e862 <bmi08x_acc_trigger_mode_init+0x23a> @ imm = #0x30
 800e830: 2301         	movs	r3, #0x1
 800e832: f887 3032    	strb.w	r3, [r7, #0x32]
 800e836: f897 3032    	ldrb.w	r3, [r7, #0x32]
 800e83a: f083 0301    	eor	r3, r3, #0x1
 800e83e: b2db         	uxtb	r3, r3
 800e840: 2b00         	cmp	r3, #0x0
 800e842: d10e         	bne	0x800e862 <bmi08x_acc_trigger_mode_init+0x23a> @ imm = #0x1c
 800e844: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800e880 <bmi08x_acc_trigger_mode_init+0x258>
 800e846: 6819         	ldr	r1, [r3]
 800e848: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800e894 <bmi08x_acc_trigger_mode_init+0x26c>
 800e84a: 9302         	str	r3, [sp, #0x8]
 800e84c: 2300         	movs	r3, #0x0
 800e84e: 9301         	str	r3, [sp, #0x4]
 800e850: 2300         	movs	r3, #0x0
 800e852: 9300         	str	r3, [sp]
 800e854: 2300         	movs	r3, #0x0
 800e856: 2201         	movs	r2, #0x1
 800e858: 2000         	movs	r0, #0x0
 800e85a: f013 ffd5    	bl	0x8022808 <z_log_msg_runtime_create> @ imm = #0x13faa
 800e85e: 2300         	movs	r3, #0x0
 800e860: 62fb         	str	r3, [r7, #0x2c]
; 		return ret;
 800e862: 6b7b         	ldr	r3, [r7, #0x34]
 800e864: e007         	b	0x800e876 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0xe
; 	gpio_pin_interrupt_configure_dt(&cfg->int_gpio, GPIO_INT_EDGE_TO_ACTIVE);
 800e866: 6bbb         	ldr	r3, [r7, #0x38]
 800e868: 331c         	adds	r3, #0x1c
 800e86a: f04f 61b8    	mov.w	r1, #0x5c00000
 800e86e: 4618         	mov	r0, r3
 800e870: f013 feae    	bl	0x80225d0 <gpio_pin_interrupt_configure_dt> @ imm = #0x13d5c
; 	return ret;
 800e874: 6b7b         	ldr	r3, [r7, #0x34]
; }
 800e876: 4618         	mov	r0, r3
 800e878: 3740         	adds	r7, #0x40
 800e87a: 46bd         	mov	sp, r7
 800e87c: bdb0         	pop	{r4, r5, r7, pc}
 800e87e: bf00         	nop

0800e880 <$d>:
 800e880: e4 06 00 24  	.word	0x240006e4
 800e884: 40 be 02 08  	.word	0x0802be40
 800e888: e9 e5 00 08  	.word	0x0800e5e9
 800e88c: 58 be 02 08  	.word	0x0802be58
 800e890: 91 28 02 08  	.word	0x08022891
 800e894: 74 be 02 08  	.word	0x0802be74

0800e898 <z_impl_gpio_pin_interrupt_configure>:
; {
 800e898: b590         	push	{r4, r7, lr}
 800e89a: b08b         	sub	sp, #0x2c
 800e89c: af00         	add	r7, sp, #0x0
 800e89e: 60f8         	str	r0, [r7, #0xc]
 800e8a0: 460b         	mov	r3, r1
 800e8a2: 607a         	str	r2, [r7, #0x4]
 800e8a4: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 800e8a6: 68fb         	ldr	r3, [r7, #0xc]
 800e8a8: 689b         	ldr	r3, [r3, #0x8]
 800e8aa: 627b         	str	r3, [r7, #0x24]
; 	__unused const struct gpio_driver_config *const cfg =
 800e8ac: 68fb         	ldr	r3, [r7, #0xc]
 800e8ae: 685b         	ldr	r3, [r3, #0x4]
 800e8b0: 623b         	str	r3, [r7, #0x20]
; 	const struct gpio_driver_data *const data =
 800e8b2: 68fb         	ldr	r3, [r7, #0xc]
 800e8b4: 691b         	ldr	r3, [r3, #0x10]
 800e8b6: 61fb         	str	r3, [r7, #0x1c]
; 	if (api->pin_interrupt_configure == NULL) {
 800e8b8: 6a7b         	ldr	r3, [r7, #0x24]
 800e8ba: 699b         	ldr	r3, [r3, #0x18]
 800e8bc: 2b00         	cmp	r3, #0x0
 800e8be: d102         	bne	0x800e8c6 <z_impl_gpio_pin_interrupt_configure+0x2e> @ imm = #0x4
; 		return -ENOSYS;
 800e8c0: f06f 0357    	mvn	r3, #0x57
 800e8c4: e021         	b	0x800e90a <z_impl_gpio_pin_interrupt_configure+0x72> @ imm = #0x42
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 800e8c6: 687b         	ldr	r3, [r7, #0x4]
 800e8c8: f403 0300    	and	r3, r3, #0x800000
 800e8cc: 2b00         	cmp	r3, #0x0
 800e8ce: d00c         	beq	0x800e8ea <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x18
; 	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
 800e8d0: 69fb         	ldr	r3, [r7, #0x1c]
 800e8d2: 681a         	ldr	r2, [r3]
 800e8d4: 7afb         	ldrb	r3, [r7, #0xb]
 800e8d6: 2101         	movs	r1, #0x1
 800e8d8: fa01 f303    	lsl.w	r3, r1, r3
 800e8dc: 4013         	ands	r3, r2
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 800e8de: 2b00         	cmp	r3, #0x0
 800e8e0: d003         	beq	0x800e8ea <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x6
; 		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
 800e8e2: 687b         	ldr	r3, [r7, #0x4]
 800e8e4: f083 63c0    	eor	r3, r3, #0x6000000
 800e8e8: 607b         	str	r3, [r7, #0x4]
; 	trig = (enum gpio_int_trig)(flags & (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1 | GPIO_INT_WAKEUP));
 800e8ea: 687a         	ldr	r2, [r7, #0x4]
 800e8ec: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800e914 <z_impl_gpio_pin_interrupt_configure+0x7c>
 800e8ee: 4013         	ands	r3, r2
 800e8f0: 61bb         	str	r3, [r7, #0x18]
; 	mode = (enum gpio_int_mode)(flags & (GPIO_INT_EDGE | GPIO_INT_DISABLE | GPIO_INT_ENABLE));
 800e8f2: 687b         	ldr	r3, [r7, #0x4]
 800e8f4: f003 73b0    	and	r3, r3, #0x1600000
 800e8f8: 617b         	str	r3, [r7, #0x14]
; 	return api->pin_interrupt_configure(port, pin, mode, trig);
 800e8fa: 6a7b         	ldr	r3, [r7, #0x24]
 800e8fc: 699c         	ldr	r4, [r3, #0x18]
 800e8fe: 7af9         	ldrb	r1, [r7, #0xb]
 800e900: 69bb         	ldr	r3, [r7, #0x18]
 800e902: 697a         	ldr	r2, [r7, #0x14]
 800e904: 68f8         	ldr	r0, [r7, #0xc]
 800e906: 47a0         	blx	r4
 800e908: 4603         	mov	r3, r0
; }
 800e90a: 4618         	mov	r0, r3
 800e90c: 372c         	adds	r7, #0x2c
 800e90e: 46bd         	mov	sp, r7
 800e910: bd90         	pop	{r4, r7, pc}
 800e912: bf00         	nop

0800e914 <$d>:
 800e914: 40 00 00 06  	.word	0x06000040

0800e918 <bmi08x_gyr_thread_main>:
; {
 800e918: b580         	push	{r7, lr}
 800e91a: b086         	sub	sp, #0x18
 800e91c: af00         	add	r7, sp, #0x0
 800e91e: 60f8         	str	r0, [r7, #0xc]
 800e920: 60b9         	str	r1, [r7, #0x8]
 800e922: 607a         	str	r2, [r7, #0x4]
; 	k_thread_name_set(NULL, "bmi08x_gyr_trig");
 800e924: 490b         	ldr	r1, [pc, #0x2c]         @ 0x800e954 <bmi08x_gyr_thread_main+0x3c>
 800e926: 2000         	movs	r0, #0x0
 800e928: f014 f8e4    	bl	0x8022af4 <k_thread_name_set> @ imm = #0x141c8
; 	const struct device *dev = (const struct device *)arg1;
 800e92c: 68fb         	ldr	r3, [r7, #0xc]
 800e92e: 617b         	str	r3, [r7, #0x14]
; 	struct bmi08x_gyro_data *data = dev->data;
 800e930: 697b         	ldr	r3, [r7, #0x14]
 800e932: 691b         	ldr	r3, [r3, #0x10]
 800e934: 613b         	str	r3, [r7, #0x10]
; 		k_sem_take(&data->sem, K_FOREVER);
 800e936: 693b         	ldr	r3, [r7, #0x10]
 800e938: f503 61e6    	add.w	r1, r3, #0x730
 800e93c: f04f 32ff    	mov.w	r2, #0xffffffff
 800e940: f04f 33ff    	mov.w	r3, #0xffffffff
 800e944: 4608         	mov	r0, r1
 800e946: f014 f8f3    	bl	0x8022b30 <k_sem_take>  @ imm = #0x141e6
; 		bmi08x_handle_interrupts_gyr((void *)dev);
 800e94a: 6978         	ldr	r0, [r7, #0x14]
 800e94c: f014 f942    	bl	0x8022bd4 <bmi08x_handle_interrupts_gyr> @ imm = #0x14284
; 	while (1) {
 800e950: bf00         	nop
 800e952: e7f0         	b	0x800e936 <bmi08x_gyr_thread_main+0x1e> @ imm = #-0x20

0800e954 <$d>:
 800e954: 94 be 02 08  	.word	0x0802be94

0800e958 <bmi08x_gyr_trigger_mode_init>:
; {
 800e958: b5b0         	push	{r4, r5, r7, lr}
 800e95a: b092         	sub	sp, #0x48
 800e95c: af08         	add	r7, sp, #0x20
 800e95e: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = dev->data;
 800e960: 687b         	ldr	r3, [r7, #0x4]
 800e962: 691b         	ldr	r3, [r3, #0x10]
 800e964: 627b         	str	r3, [r7, #0x24]
; 	const struct bmi08x_gyro_config *cfg = dev->config;
 800e966: 687b         	ldr	r3, [r7, #0x4]
 800e968: 685b         	ldr	r3, [r3, #0x4]
 800e96a: 623b         	str	r3, [r7, #0x20]
; 	if (!gpio_is_ready_dt(&cfg->int_gpio)) {
 800e96c: 6a3b         	ldr	r3, [r7, #0x20]
 800e96e: 331c         	adds	r3, #0x1c
 800e970: 4618         	mov	r0, r3
 800e972: f013 ffce    	bl	0x8022912 <gpio_is_ready_dt> @ imm = #0x13f9c
 800e976: 4603         	mov	r3, r0
 800e978: f083 0301    	eor	r3, r3, #0x1
 800e97c: b2db         	uxtb	r3, r3
 800e97e: 2b00         	cmp	r3, #0x0
 800e980: d01c         	beq	0x800e9bc <bmi08x_gyr_trigger_mode_init+0x64> @ imm = #0x38
; 		LOG_ERR("GPIO device not ready");
 800e982: 2303         	movs	r3, #0x3
 800e984: 2b00         	cmp	r3, #0x0
 800e986: d016         	beq	0x800e9b6 <bmi08x_gyr_trigger_mode_init+0x5e> @ imm = #0x2c
 800e988: 2301         	movs	r3, #0x1
 800e98a: 74fb         	strb	r3, [r7, #0x13]
 800e98c: 7cfb         	ldrb	r3, [r7, #0x13]
 800e98e: f083 0301    	eor	r3, r3, #0x1
 800e992: b2db         	uxtb	r3, r3
 800e994: 2b00         	cmp	r3, #0x0
 800e996: d10e         	bne	0x800e9b6 <bmi08x_gyr_trigger_mode_init+0x5e> @ imm = #0x1c
 800e998: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800ea94 <bmi08x_gyr_trigger_mode_init+0x13c>
 800e99a: 6819         	ldr	r1, [r3]
 800e99c: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800ea98 <bmi08x_gyr_trigger_mode_init+0x140>
 800e99e: 9302         	str	r3, [sp, #0x8]
 800e9a0: 2300         	movs	r3, #0x0
 800e9a2: 9301         	str	r3, [sp, #0x4]
 800e9a4: 2300         	movs	r3, #0x0
 800e9a6: 9300         	str	r3, [sp]
 800e9a8: 2300         	movs	r3, #0x0
 800e9aa: 2201         	movs	r2, #0x1
 800e9ac: 2000         	movs	r0, #0x0
 800e9ae: f014 f8da    	bl	0x8022b66 <z_log_msg_runtime_create> @ imm = #0x141b4
 800e9b2: 2300         	movs	r3, #0x0
 800e9b4: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800e9b6: f06f 0312    	mvn	r3, #0x12
 800e9ba: e067         	b	0x800ea8c <bmi08x_gyr_trigger_mode_init+0x134> @ imm = #0xce
; 	k_sem_init(&data->sem, 0, K_SEM_MAX_LIMIT);
 800e9bc: 6a7b         	ldr	r3, [r7, #0x24]
 800e9be: f503 63e6    	add.w	r3, r3, #0x730
 800e9c2: f04f 32ff    	mov.w	r2, #0xffffffff
 800e9c6: 2100         	movs	r1, #0x0
 800e9c8: 4618         	mov	r0, r3
 800e9ca: f014 f8a1    	bl	0x8022b10 <k_sem_init>  @ imm = #0x14142
; 	k_thread_create(&data->thread, data->thread_stack,
 800e9ce: 6a7b         	ldr	r3, [r7, #0x24]
 800e9d0: f503 64c3    	add.w	r4, r3, #0x618
 800e9d4: 6a7b         	ldr	r3, [r7, #0x24]
 800e9d6: f103 0518    	add.w	r5, r3, #0x18
; 			NULL, NULL, K_PRIO_COOP(CONFIG_BMI08X_GYRO_THREAD_PRIORITY), 0, K_NO_WAIT);
 800e9da: f04f 0000    	mov.w	r0, #0x0
 800e9de: f04f 0100    	mov.w	r1, #0x0
; 	k_thread_create(&data->thread, data->thread_stack,
 800e9e2: e9cd 0106    	strd	r0, r1, [sp, #24]
 800e9e6: 2300         	movs	r3, #0x0
 800e9e8: 9304         	str	r3, [sp, #0x10]
 800e9ea: f06f 0305    	mvn	r3, #0x5
 800e9ee: 9303         	str	r3, [sp, #0xc]
 800e9f0: 2300         	movs	r3, #0x0
 800e9f2: 9302         	str	r3, [sp, #0x8]
 800e9f4: 2300         	movs	r3, #0x0
 800e9f6: 9301         	str	r3, [sp, #0x4]
 800e9f8: 687b         	ldr	r3, [r7, #0x4]
 800e9fa: 9300         	str	r3, [sp]
 800e9fc: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800ea9c <bmi08x_gyr_trigger_mode_init+0x144>
 800e9fe: f44f 62c0    	mov.w	r2, #0x600
 800ea02: 4629         	mov	r1, r5
 800ea04: 4620         	mov	r0, r4
 800ea06: f014 f855    	bl	0x8022ab4 <k_thread_create> @ imm = #0x140aa
; 	gpio_pin_configure_dt(&cfg->int_gpio, GPIO_INPUT);
 800ea0a: 6a3b         	ldr	r3, [r7, #0x20]
 800ea0c: 331c         	adds	r3, #0x1c
 800ea0e: f44f 3180    	mov.w	r1, #0x10000
 800ea12: 4618         	mov	r0, r3
 800ea14: f013 ffe8    	bl	0x80229e8 <gpio_pin_configure_dt> @ imm = #0x13fd0
; 	gpio_init_callback(&data->gpio_cb, bmi08x_gyr_gpio_callback, BIT(cfg->int_gpio.pin));
 800ea18: 6a78         	ldr	r0, [r7, #0x24]
 800ea1a: 6a3b         	ldr	r3, [r7, #0x20]
 800ea1c: f893 3020    	ldrb.w	r3, [r3, #0x20]
 800ea20: 461a         	mov	r2, r3
 800ea22: 2301         	movs	r3, #0x1
 800ea24: 4093         	lsls	r3, r2
 800ea26: 461a         	mov	r2, r3
 800ea28: 491d         	ldr	r1, [pc, #0x74]         @ 0x800eaa0 <bmi08x_gyr_trigger_mode_init+0x148>
 800ea2a: f013 fff3    	bl	0x8022a14 <gpio_init_callback> @ imm = #0x13fe6
; 	ret = gpio_add_callback(cfg->int_gpio.port, &data->gpio_cb);
 800ea2e: 6a3b         	ldr	r3, [r7, #0x20]
 800ea30: 69db         	ldr	r3, [r3, #0x1c]
 800ea32: 6a7a         	ldr	r2, [r7, #0x24]
 800ea34: 4611         	mov	r1, r2
 800ea36: 4618         	mov	r0, r3
 800ea38: f013 fffe    	bl	0x8022a38 <gpio_add_callback> @ imm = #0x13ffc
 800ea3c: 61f8         	str	r0, [r7, #0x1c]
; 	if (ret < 0) {
 800ea3e: 69fb         	ldr	r3, [r7, #0x1c]
 800ea40: 2b00         	cmp	r3, #0x0
 800ea42: da1b         	bge	0x800ea7c <bmi08x_gyr_trigger_mode_init+0x124> @ imm = #0x36
; 		LOG_ERR("Failed to set gpio callback.");
 800ea44: 2303         	movs	r3, #0x3
 800ea46: 2b00         	cmp	r3, #0x0
 800ea48: d016         	beq	0x800ea78 <bmi08x_gyr_trigger_mode_init+0x120> @ imm = #0x2c
 800ea4a: 2301         	movs	r3, #0x1
 800ea4c: 76fb         	strb	r3, [r7, #0x1b]
 800ea4e: 7efb         	ldrb	r3, [r7, #0x1b]
 800ea50: f083 0301    	eor	r3, r3, #0x1
 800ea54: b2db         	uxtb	r3, r3
 800ea56: 2b00         	cmp	r3, #0x0
 800ea58: d10e         	bne	0x800ea78 <bmi08x_gyr_trigger_mode_init+0x120> @ imm = #0x1c
 800ea5a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800ea94 <bmi08x_gyr_trigger_mode_init+0x13c>
 800ea5c: 6819         	ldr	r1, [r3]
 800ea5e: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800eaa4 <bmi08x_gyr_trigger_mode_init+0x14c>
 800ea60: 9302         	str	r3, [sp, #0x8]
 800ea62: 2300         	movs	r3, #0x0
 800ea64: 9301         	str	r3, [sp, #0x4]
 800ea66: 2300         	movs	r3, #0x0
 800ea68: 9300         	str	r3, [sp]
 800ea6a: 2300         	movs	r3, #0x0
 800ea6c: 2201         	movs	r2, #0x1
 800ea6e: 2000         	movs	r0, #0x0
 800ea70: f014 f879    	bl	0x8022b66 <z_log_msg_runtime_create> @ imm = #0x140f2
 800ea74: 2300         	movs	r3, #0x0
 800ea76: 617b         	str	r3, [r7, #0x14]
; 		return ret;
 800ea78: 69fb         	ldr	r3, [r7, #0x1c]
 800ea7a: e007         	b	0x800ea8c <bmi08x_gyr_trigger_mode_init+0x134> @ imm = #0xe
; 	gpio_pin_interrupt_configure_dt(&cfg->int_gpio, GPIO_INT_EDGE_TO_ACTIVE);
 800ea7c: 6a3b         	ldr	r3, [r7, #0x20]
 800ea7e: 331c         	adds	r3, #0x1c
 800ea80: f04f 61b8    	mov.w	r1, #0x5c00000
 800ea84: 4618         	mov	r0, r3
 800ea86: f013 ff52    	bl	0x802292e <gpio_pin_interrupt_configure_dt> @ imm = #0x13ea4
; 	return ret;
 800ea8a: 69fb         	ldr	r3, [r7, #0x1c]
; }
 800ea8c: 4618         	mov	r0, r3
 800ea8e: 3728         	adds	r7, #0x28
 800ea90: 46bd         	mov	sp, r7
 800ea92: bdb0         	pop	{r4, r5, r7, pc}

0800ea94 <$d>:
 800ea94: e8 06 00 24  	.word	0x240006e8
 800ea98: a4 be 02 08  	.word	0x0802bea4
 800ea9c: 19 e9 00 08  	.word	0x0800e919
 800eaa0: ef 2b 02 08  	.word	0x08022bef
 800eaa4: bc be 02 08  	.word	0x0802bebc

0800eaa8 <LL_USART_ConfigCharacter>:
; {
 800eaa8: b480         	push	{r7}
 800eaaa: b085         	sub	sp, #0x14
 800eaac: af00         	add	r7, sp, #0x0
 800eaae: 60f8         	str	r0, [r7, #0xc]
 800eab0: 60b9         	str	r1, [r7, #0x8]
 800eab2: 607a         	str	r2, [r7, #0x4]
 800eab4: 603b         	str	r3, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
 800eab6: 68fb         	ldr	r3, [r7, #0xc]
 800eab8: 681a         	ldr	r2, [r3]
 800eaba: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800eae8 <LL_USART_ConfigCharacter+0x40>
 800eabc: 4013         	ands	r3, r2
 800eabe: 6879         	ldr	r1, [r7, #0x4]
 800eac0: 68ba         	ldr	r2, [r7, #0x8]
 800eac2: 430a         	orrs	r2, r1
 800eac4: 431a         	orrs	r2, r3
 800eac6: 68fb         	ldr	r3, [r7, #0xc]
 800eac8: 601a         	str	r2, [r3]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 800eaca: 68fb         	ldr	r3, [r7, #0xc]
 800eacc: 685b         	ldr	r3, [r3, #0x4]
 800eace: f423 5240    	bic	r2, r3, #0x3000
 800ead2: 683b         	ldr	r3, [r7]
 800ead4: 431a         	orrs	r2, r3
 800ead6: 68fb         	ldr	r3, [r7, #0xc]
 800ead8: 605a         	str	r2, [r3, #0x4]
; }
 800eada: bf00         	nop
 800eadc: 3714         	adds	r7, #0x14
 800eade: 46bd         	mov	sp, r7
 800eae0: f85d 7b04    	ldr	r7, [sp], #4
 800eae4: 4770         	bx	lr
 800eae6: bf00         	nop

0800eae8 <$d>:
 800eae8: ff e9 ff ef  	.word	0xefffe9ff

0800eaec <LL_USART_SetBaudRate>:
; {
 800eaec: b480         	push	{r7}
 800eaee: b087         	sub	sp, #0x1c
 800eaf0: af00         	add	r7, sp, #0x0
 800eaf2: 60f8         	str	r0, [r7, #0xc]
 800eaf4: 60b9         	str	r1, [r7, #0x8]
 800eaf6: 607a         	str	r2, [r7, #0x4]
 800eaf8: 603b         	str	r3, [r7]
;   if (PrescalerValue > LL_USART_PRESCALER_DIV256)
 800eafa: 687b         	ldr	r3, [r7, #0x4]
 800eafc: 2b0b         	cmp	r3, #0xb
 800eafe: d83c         	bhi	0x800eb7a <LL_USART_SetBaudRate+0x8e> @ imm = #0x78
;   else if (BaudRate == 0U)
 800eb00: 6a3b         	ldr	r3, [r7, #0x20]
 800eb02: 2b00         	cmp	r3, #0x0
 800eb04: d039         	beq	0x800eb7a <LL_USART_SetBaudRate+0x8e> @ imm = #0x72
;   else if (OverSampling == LL_USART_OVERSAMPLING_8)
 800eb06: 683b         	ldr	r3, [r7]
 800eb08: f5b3 4f00    	cmp.w	r3, #0x8000
 800eb0c: d122         	bne	0x800eb54 <LL_USART_SetBaudRate+0x68> @ imm = #0x44
;     usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, (uint8_t)PrescalerValue, BaudRate));
 800eb0e: 687b         	ldr	r3, [r7, #0x4]
 800eb10: b2db         	uxtb	r3, r3
 800eb12: 461a         	mov	r2, r3
 800eb14: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800eb88 <LL_USART_SetBaudRate+0x9c>
 800eb16: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800eb1a: 68ba         	ldr	r2, [r7, #0x8]
 800eb1c: fbb2 f3f3    	udiv	r3, r2, r3
 800eb20: 005a         	lsls	r2, r3, #0x1
 800eb22: 6a3b         	ldr	r3, [r7, #0x20]
 800eb24: 085b         	lsrs	r3, r3, #0x1
 800eb26: 441a         	add	r2, r3
 800eb28: 6a3b         	ldr	r3, [r7, #0x20]
 800eb2a: fbb2 f3f3    	udiv	r3, r2, r3
 800eb2e: b29b         	uxth	r3, r3
 800eb30: 617b         	str	r3, [r7, #0x14]
;     brrtemp = usartdiv & 0xFFF0U;
 800eb32: 697a         	ldr	r2, [r7, #0x14]
 800eb34: f64f 73f0    	movw	r3, #0xfff0
 800eb38: 4013         	ands	r3, r2
 800eb3a: 613b         	str	r3, [r7, #0x10]
;     brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800eb3c: 697b         	ldr	r3, [r7, #0x14]
 800eb3e: 085b         	lsrs	r3, r3, #0x1
 800eb40: b29b         	uxth	r3, r3
 800eb42: f003 0307    	and	r3, r3, #0x7
 800eb46: 693a         	ldr	r2, [r7, #0x10]
 800eb48: 4313         	orrs	r3, r2
 800eb4a: 613b         	str	r3, [r7, #0x10]
;     USARTx->BRR = brrtemp;
 800eb4c: 68fb         	ldr	r3, [r7, #0xc]
 800eb4e: 693a         	ldr	r2, [r7, #0x10]
 800eb50: 60da         	str	r2, [r3, #0xc]
; }
 800eb52: e012         	b	0x800eb7a <LL_USART_SetBaudRate+0x8e> @ imm = #0x24
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, (uint8_t)PrescalerValue, BaudRate));
 800eb54: 687b         	ldr	r3, [r7, #0x4]
 800eb56: b2db         	uxtb	r3, r3
 800eb58: 461a         	mov	r2, r3
 800eb5a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800eb88 <LL_USART_SetBaudRate+0x9c>
 800eb5c: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800eb60: 68ba         	ldr	r2, [r7, #0x8]
 800eb62: fbb2 f2f3    	udiv	r2, r2, r3
 800eb66: 6a3b         	ldr	r3, [r7, #0x20]
 800eb68: 085b         	lsrs	r3, r3, #0x1
 800eb6a: 441a         	add	r2, r3
 800eb6c: 6a3b         	ldr	r3, [r7, #0x20]
 800eb6e: fbb2 f3f3    	udiv	r3, r2, r3
 800eb72: b29b         	uxth	r3, r3
 800eb74: 461a         	mov	r2, r3
 800eb76: 68fb         	ldr	r3, [r7, #0xc]
 800eb78: 60da         	str	r2, [r3, #0xc]
; }
 800eb7a: bf00         	nop
 800eb7c: 371c         	adds	r7, #0x1c
 800eb7e: 46bd         	mov	sp, r7
 800eb80: f85d 7b04    	ldr	r7, [sp], #4
 800eb84: 4770         	bx	lr
 800eb86: bf00         	nop

0800eb88 <$d>:
 800eb88: f4 d6 02 08  	.word	0x0802d6f4

0800eb8c <uart_stm32_set_baudrate>:
; {
 800eb8c: b580         	push	{r7, lr}
 800eb8e: b08c         	sub	sp, #0x30
 800eb90: af04         	add	r7, sp, #0x10
 800eb92: 6078         	str	r0, [r7, #0x4]
 800eb94: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800eb96: 687b         	ldr	r3, [r7, #0x4]
 800eb98: 685b         	ldr	r3, [r3, #0x4]
 800eb9a: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 800eb9c: 69bb         	ldr	r3, [r7, #0x18]
 800eb9e: 681b         	ldr	r3, [r3]
 800eba0: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = dev->data;
 800eba2: 687b         	ldr	r3, [r7, #0x4]
 800eba4: 691b         	ldr	r3, [r3, #0x10]
 800eba6: 61fb         	str	r3, [r7, #0x1c]
; 		if (clock_control_get_rate(data->clock,
 800eba8: 69fb         	ldr	r3, [r7, #0x1c]
 800ebaa: 6818         	ldr	r0, [r3]
; 					   (clock_control_subsys_t)&config->pclken[0],
 800ebac: 69bb         	ldr	r3, [r7, #0x18]
 800ebae: 68db         	ldr	r3, [r3, #0xc]
; 		if (clock_control_get_rate(data->clock,
 800ebb0: f107 0208    	add.w	r2, r7, #0x8
 800ebb4: 4619         	mov	r1, r3
 800ebb6: f014 f878    	bl	0x8022caa <clock_control_get_rate> @ imm = #0x140f0
 800ebba: 4603         	mov	r3, r0
 800ebbc: 2b00         	cmp	r3, #0x0
 800ebbe: da1a         	bge	0x800ebf6 <uart_stm32_set_baudrate+0x6a> @ imm = #0x34
; 			LOG_ERR("Failed call clock_control_get_rate(pclken[0])");
 800ebc0: 2303         	movs	r3, #0x3
 800ebc2: 2b00         	cmp	r3, #0x0
 800ebc4: d023         	beq	0x800ec0e <uart_stm32_set_baudrate+0x82> @ imm = #0x46
 800ebc6: 2301         	movs	r3, #0x1
 800ebc8: 74fb         	strb	r3, [r7, #0x13]
 800ebca: 7cfb         	ldrb	r3, [r7, #0x13]
 800ebcc: f083 0301    	eor	r3, r3, #0x1
 800ebd0: b2db         	uxtb	r3, r3
 800ebd2: 2b00         	cmp	r3, #0x0
 800ebd4: d11b         	bne	0x800ec0e <uart_stm32_set_baudrate+0x82> @ imm = #0x36
 800ebd6: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800ec14 <uart_stm32_set_baudrate+0x88>
 800ebd8: 6819         	ldr	r1, [r3]
 800ebda: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800ec18 <uart_stm32_set_baudrate+0x8c>
 800ebdc: 9302         	str	r3, [sp, #0x8]
 800ebde: 2300         	movs	r3, #0x0
 800ebe0: 9301         	str	r3, [sp, #0x4]
 800ebe2: 2300         	movs	r3, #0x0
 800ebe4: 9300         	str	r3, [sp]
 800ebe6: 2300         	movs	r3, #0x0
 800ebe8: 2201         	movs	r2, #0x1
 800ebea: 2000         	movs	r0, #0x0
 800ebec: f014 fe94    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x14d28
 800ebf0: 2300         	movs	r3, #0x0
 800ebf2: 60fb         	str	r3, [r7, #0xc]
; 			return;
 800ebf4: e00b         	b	0x800ec0e <uart_stm32_set_baudrate+0x82> @ imm = #0x16
; 		LL_USART_SetOverSampling(usart,
 800ebf6: 2100         	movs	r1, #0x0
 800ebf8: 6978         	ldr	r0, [r7, #0x14]
 800ebfa: f014 f9fe    	bl	0x8022ffa <LL_USART_SetOverSampling> @ imm = #0x143fc
; 		LL_USART_SetBaudRate(usart,
 800ebfe: 68b9         	ldr	r1, [r7, #0x8]
 800ec00: 683b         	ldr	r3, [r7]
 800ec02: 9300         	str	r3, [sp]
 800ec04: 2300         	movs	r3, #0x0
 800ec06: 2200         	movs	r2, #0x0
 800ec08: 6978         	ldr	r0, [r7, #0x14]
 800ec0a: f7ff ff6f    	bl	0x800eaec <LL_USART_SetBaudRate> @ imm = #-0x122
; }
 800ec0e: 3720         	adds	r7, #0x20
 800ec10: 46bd         	mov	sp, r7
 800ec12: bd80         	pop	{r7, pc}

0800ec14 <$d>:
 800ec14: ec 06 00 24  	.word	0x240006ec
 800ec18: e8 be 02 08  	.word	0x0802bee8

0800ec1c <uart_stm32_configure>:
; {
 800ec1c: b580         	push	{r7, lr}
 800ec1e: b08a         	sub	sp, #0x28
 800ec20: af00         	add	r7, sp, #0x0
 800ec22: 6078         	str	r0, [r7, #0x4]
 800ec24: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800ec26: 687b         	ldr	r3, [r7, #0x4]
 800ec28: 685b         	ldr	r3, [r3, #0x4]
 800ec2a: 627b         	str	r3, [r7, #0x24]
; 	USART_TypeDef *usart = config->usart;
 800ec2c: 6a7b         	ldr	r3, [r7, #0x24]
 800ec2e: 681b         	ldr	r3, [r3]
 800ec30: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 800ec32: 687b         	ldr	r3, [r7, #0x4]
 800ec34: 691b         	ldr	r3, [r3, #0x10]
 800ec36: 61fb         	str	r3, [r7, #0x1c]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 800ec38: 69fb         	ldr	r3, [r7, #0x1c]
 800ec3a: 685b         	ldr	r3, [r3, #0x4]
 800ec3c: 61bb         	str	r3, [r7, #0x18]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 800ec3e: 683b         	ldr	r3, [r7]
 800ec40: 791b         	ldrb	r3, [r3, #0x4]
 800ec42: 4618         	mov	r0, r3
 800ec44: f014 ff43    	bl	0x8023ace <uart_stm32_cfg2ll_parity> @ imm = #0x14e86
 800ec48: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 800ec4a: 683b         	ldr	r3, [r7]
 800ec4c: 795b         	ldrb	r3, [r3, #0x5]
 800ec4e: 4619         	mov	r1, r3
 800ec50: 6a78         	ldr	r0, [r7, #0x24]
 800ec52: f014 ff6b    	bl	0x8023b2c <uart_stm32_cfg2ll_stopbits> @ imm = #0x14ed6
 800ec56: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 800ec58: 683b         	ldr	r3, [r7]
 800ec5a: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 800ec5c: 683b         	ldr	r3, [r7]
 800ec5e: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 800ec60: 4619         	mov	r1, r3
 800ec62: 4610         	mov	r0, r2
 800ec64: f014 ffa2    	bl	0x8023bac <uart_stm32_cfg2ll_databits> @ imm = #0x14f44
 800ec68: 60f8         	str	r0, [r7, #0xc]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 800ec6a: 683b         	ldr	r3, [r7]
 800ec6c: 791b         	ldrb	r3, [r3, #0x4]
 800ec6e: 2b03         	cmp	r3, #0x3
 800ec70: d003         	beq	0x800ec7a <uart_stm32_configure+0x5e> @ imm = #0x6
; 	    (cfg->parity == UART_CFG_PARITY_SPACE)) {
 800ec72: 683b         	ldr	r3, [r7]
 800ec74: 791b         	ldrb	r3, [r3, #0x4]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 800ec76: 2b04         	cmp	r3, #0x4
 800ec78: d102         	bne	0x800ec80 <uart_stm32_configure+0x64> @ imm = #0x4
; 		return -ENOTSUP;
 800ec7a: f06f 0385    	mvn	r3, #0x85
 800ec7e: e09b         	b	0x800edb8 <uart_stm32_configure+0x19c> @ imm = #0x136
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 800ec80: 683b         	ldr	r3, [r7]
 800ec82: 791b         	ldrb	r3, [r3, #0x4]
 800ec84: 2b00         	cmp	r3, #0x0
 800ec86: d006         	beq	0x800ec96 <uart_stm32_configure+0x7a> @ imm = #0xc
; 	    (cfg->data_bits == UART_CFG_DATA_BITS_9)) {
 800ec88: 683b         	ldr	r3, [r7]
 800ec8a: 799b         	ldrb	r3, [r3, #0x6]
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 800ec8c: 2b04         	cmp	r3, #0x4
 800ec8e: d102         	bne	0x800ec96 <uart_stm32_configure+0x7a> @ imm = #0x4
; 		return -ENOTSUP;
 800ec90: f06f 0385    	mvn	r3, #0x85
 800ec94: e090         	b	0x800edb8 <uart_stm32_configure+0x19c> @ imm = #0x120
; 	if (uart_stm32_ll2cfg_stopbits(stopbits) != cfg->stop_bits) {
 800ec96: 6938         	ldr	r0, [r7, #0x10]
 800ec98: f014 ff68    	bl	0x8023b6c <uart_stm32_ll2cfg_stopbits> @ imm = #0x14ed0
 800ec9c: 4603         	mov	r3, r0
 800ec9e: 461a         	mov	r2, r3
 800eca0: 683b         	ldr	r3, [r7]
 800eca2: 795b         	ldrb	r3, [r3, #0x5]
 800eca4: 429a         	cmp	r2, r3
 800eca6: d002         	beq	0x800ecae <uart_stm32_configure+0x92> @ imm = #0x4
; 		return -ENOTSUP;
 800eca8: f06f 0385    	mvn	r3, #0x85
 800ecac: e084         	b	0x800edb8 <uart_stm32_configure+0x19c> @ imm = #0x108
; 	if (uart_stm32_ll2cfg_databits(databits, parity) != cfg->data_bits) {
 800ecae: 6979         	ldr	r1, [r7, #0x14]
 800ecb0: 68f8         	ldr	r0, [r7, #0xc]
 800ecb2: f014 ffa1    	bl	0x8023bf8 <uart_stm32_ll2cfg_databits> @ imm = #0x14f42
 800ecb6: 4603         	mov	r3, r0
 800ecb8: 461a         	mov	r2, r3
 800ecba: 683b         	ldr	r3, [r7]
 800ecbc: 799b         	ldrb	r3, [r3, #0x6]
 800ecbe: 429a         	cmp	r2, r3
 800ecc0: d002         	beq	0x800ecc8 <uart_stm32_configure+0xac> @ imm = #0x4
; 		return -ENOTSUP;
 800ecc2: f06f 0385    	mvn	r3, #0x85
 800ecc6: e077         	b	0x800edb8 <uart_stm32_configure+0x19c> @ imm = #0xee
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 800ecc8: 683b         	ldr	r3, [r7]
 800ecca: 79db         	ldrb	r3, [r3, #0x7]
 800eccc: 2b00         	cmp	r3, #0x0
 800ecce: d062         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0xc4
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 800ecd0: 683b         	ldr	r3, [r7]
 800ecd2: 79db         	ldrb	r3, [r3, #0x7]
 800ecd4: 2b01         	cmp	r3, #0x1
 800ecd6: d12b         	bne	0x800ed30 <uart_stm32_configure+0x114> @ imm = #0x56
 800ecd8: 6a3b         	ldr	r3, [r7, #0x20]
 800ecda: 4a39         	ldr	r2, [pc, #0xe4]         @ 0x800edc0 <uart_stm32_configure+0x1a4>
 800ecdc: 4293         	cmp	r3, r2
 800ecde: d05a         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0xb4
; 			IS_UART_HWFLOW_INSTANCE(usart))
 800ece0: 6a3b         	ldr	r3, [r7, #0x20]
 800ece2: 4a38         	ldr	r2, [pc, #0xe0]         @ 0x800edc4 <uart_stm32_configure+0x1a8>
 800ece4: 4293         	cmp	r3, r2
 800ece6: d056         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0xac
 800ece8: 6a3b         	ldr	r3, [r7, #0x20]
 800ecea: 4a37         	ldr	r2, [pc, #0xdc]         @ 0x800edc8 <uart_stm32_configure+0x1ac>
 800ecec: 4293         	cmp	r3, r2
 800ecee: d052         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0xa4
 800ecf0: 6a3b         	ldr	r3, [r7, #0x20]
 800ecf2: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x800edcc <uart_stm32_configure+0x1b0>
 800ecf4: 4293         	cmp	r3, r2
 800ecf6: d04e         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x9c
 800ecf8: 6a3b         	ldr	r3, [r7, #0x20]
 800ecfa: 4a35         	ldr	r2, [pc, #0xd4]         @ 0x800edd0 <uart_stm32_configure+0x1b4>
 800ecfc: 4293         	cmp	r3, r2
 800ecfe: d04a         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x94
 800ed00: 6a3b         	ldr	r3, [r7, #0x20]
 800ed02: 4a34         	ldr	r2, [pc, #0xd0]         @ 0x800edd4 <uart_stm32_configure+0x1b8>
 800ed04: 4293         	cmp	r3, r2
 800ed06: d046         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x8c
 800ed08: 6a3b         	ldr	r3, [r7, #0x20]
 800ed0a: 4a33         	ldr	r2, [pc, #0xcc]         @ 0x800edd8 <uart_stm32_configure+0x1bc>
 800ed0c: 4293         	cmp	r3, r2
 800ed0e: d042         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x84
 800ed10: 6a3b         	ldr	r3, [r7, #0x20]
 800ed12: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x800eddc <uart_stm32_configure+0x1c0>
 800ed14: 4293         	cmp	r3, r2
 800ed16: d03e         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x7c
 800ed18: 6a3b         	ldr	r3, [r7, #0x20]
 800ed1a: 4a31         	ldr	r2, [pc, #0xc4]         @ 0x800ede0 <uart_stm32_configure+0x1c4>
 800ed1c: 4293         	cmp	r3, r2
 800ed1e: d03a         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x74
 800ed20: 6a3b         	ldr	r3, [r7, #0x20]
 800ed22: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x800ede4 <uart_stm32_configure+0x1c8>
 800ed24: 4293         	cmp	r3, r2
 800ed26: d036         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x6c
 800ed28: 6a3b         	ldr	r3, [r7, #0x20]
 800ed2a: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x800ede8 <uart_stm32_configure+0x1cc>
 800ed2c: 4293         	cmp	r3, r2
 800ed2e: d032         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x64
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RS485 &&
 800ed30: 683b         	ldr	r3, [r7]
 800ed32: 79db         	ldrb	r3, [r3, #0x7]
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 800ed34: 2b03         	cmp	r3, #0x3
 800ed36: d12b         	bne	0x800ed90 <uart_stm32_configure+0x174> @ imm = #0x56
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RS485 &&
 800ed38: 6a3b         	ldr	r3, [r7, #0x20]
 800ed3a: 4a21         	ldr	r2, [pc, #0x84]         @ 0x800edc0 <uart_stm32_configure+0x1a4>
 800ed3c: 4293         	cmp	r3, r2
 800ed3e: d02a         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x54
; 			IS_UART_DRIVER_ENABLE_INSTANCE(usart))
 800ed40: 6a3b         	ldr	r3, [r7, #0x20]
 800ed42: 4a20         	ldr	r2, [pc, #0x80]         @ 0x800edc4 <uart_stm32_configure+0x1a8>
 800ed44: 4293         	cmp	r3, r2
 800ed46: d026         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x4c
 800ed48: 6a3b         	ldr	r3, [r7, #0x20]
 800ed4a: 4a1f         	ldr	r2, [pc, #0x7c]         @ 0x800edc8 <uart_stm32_configure+0x1ac>
 800ed4c: 4293         	cmp	r3, r2
 800ed4e: d022         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x44
 800ed50: 6a3b         	ldr	r3, [r7, #0x20]
 800ed52: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x800edcc <uart_stm32_configure+0x1b0>
 800ed54: 4293         	cmp	r3, r2
 800ed56: d01e         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x3c
 800ed58: 6a3b         	ldr	r3, [r7, #0x20]
 800ed5a: 4a1d         	ldr	r2, [pc, #0x74]         @ 0x800edd0 <uart_stm32_configure+0x1b4>
 800ed5c: 4293         	cmp	r3, r2
 800ed5e: d01a         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x34
 800ed60: 6a3b         	ldr	r3, [r7, #0x20]
 800ed62: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x800edd4 <uart_stm32_configure+0x1b8>
 800ed64: 4293         	cmp	r3, r2
 800ed66: d016         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x2c
 800ed68: 6a3b         	ldr	r3, [r7, #0x20]
 800ed6a: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800edd8 <uart_stm32_configure+0x1bc>
 800ed6c: 4293         	cmp	r3, r2
 800ed6e: d012         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x24
 800ed70: 6a3b         	ldr	r3, [r7, #0x20]
 800ed72: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x800eddc <uart_stm32_configure+0x1c0>
 800ed74: 4293         	cmp	r3, r2
 800ed76: d00e         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x1c
 800ed78: 6a3b         	ldr	r3, [r7, #0x20]
 800ed7a: 4a19         	ldr	r2, [pc, #0x64]         @ 0x800ede0 <uart_stm32_configure+0x1c4>
 800ed7c: 4293         	cmp	r3, r2
 800ed7e: d00a         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x14
 800ed80: 6a3b         	ldr	r3, [r7, #0x20]
 800ed82: 4a18         	ldr	r2, [pc, #0x60]         @ 0x800ede4 <uart_stm32_configure+0x1c8>
 800ed84: 4293         	cmp	r3, r2
 800ed86: d006         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0xc
 800ed88: 6a3b         	ldr	r3, [r7, #0x20]
 800ed8a: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800ede8 <uart_stm32_configure+0x1cc>
 800ed8c: 4293         	cmp	r3, r2
 800ed8e: d002         	beq	0x800ed96 <uart_stm32_configure+0x17a> @ imm = #0x4
; 		return -ENOTSUP;
 800ed90: f06f 0385    	mvn	r3, #0x85
 800ed94: e010         	b	0x800edb8 <uart_stm32_configure+0x19c> @ imm = #0x20
; 	LL_USART_Disable(usart);
 800ed96: 6a38         	ldr	r0, [r7, #0x20]
 800ed98: f014 f8a9    	bl	0x8022eee <LL_USART_Disable> @ imm = #0x14152
; 	uart_stm32_parameters_set(dev, cfg);
 800ed9c: 6839         	ldr	r1, [r7]
 800ed9e: 6878         	ldr	r0, [r7, #0x4]
 800eda0: f014 ff79    	bl	0x8023c96 <uart_stm32_parameters_set> @ imm = #0x14ef2
; 	LL_USART_Enable(usart);
 800eda4: 6a38         	ldr	r0, [r7, #0x20]
 800eda6: f014 f892    	bl	0x8022ece <LL_USART_Enable> @ imm = #0x14124
; 	*uart_cfg = *cfg;
 800edaa: 69bb         	ldr	r3, [r7, #0x18]
 800edac: 683a         	ldr	r2, [r7]
 800edae: e892 0003    	ldm.w	r2, {r0, r1}
 800edb2: e883 0003    	stm.w	r3, {r0, r1}
; 	return 0;
 800edb6: 2300         	movs	r3, #0x0
; };
 800edb8: 4618         	mov	r0, r3
 800edba: 3728         	adds	r7, #0x28
 800edbc: 46bd         	mov	sp, r7
 800edbe: bd80         	pop	{r7, pc}

0800edc0 <$d>:
 800edc0: 00 10 01 40  	.word	0x40011000
 800edc4: 00 44 00 40  	.word	0x40004400
 800edc8: 00 48 00 40  	.word	0x40004800
 800edcc: 00 4c 00 40  	.word	0x40004c00
 800edd0: 00 50 00 40  	.word	0x40005000
 800edd4: 00 14 01 40  	.word	0x40011400
 800edd8: 00 78 00 40  	.word	0x40007800
 800eddc: 00 7c 00 40  	.word	0x40007c00
 800ede0: 00 18 01 40  	.word	0x40011800
 800ede4: 00 1c 01 40  	.word	0x40011c00
 800ede8: 00 0c 00 58  	.word	0x58000c00

0800edec <uart_stm32_poll_in>:
; {
 800edec: b580         	push	{r7, lr}
 800edee: b082         	sub	sp, #0x8
 800edf0: af00         	add	r7, sp, #0x0
 800edf2: 6078         	str	r0, [r7, #0x4]
 800edf4: 6039         	str	r1, [r7]
; 	return uart_stm32_poll_in_visitor(dev, (void *)c, poll_in_u8);
 800edf6: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800ee0c <uart_stm32_poll_in+0x20>
 800edf8: 6839         	ldr	r1, [r7]
 800edfa: 6878         	ldr	r0, [r7, #0x4]
 800edfc: f015 f82d    	bl	0x8023e5a <uart_stm32_poll_in_visitor> @ imm = #0x1505a
 800ee00: 4603         	mov	r3, r0
; }
 800ee02: 4618         	mov	r0, r3
 800ee04: 3708         	adds	r7, #0x8
 800ee06: 46bd         	mov	sp, r7
 800ee08: bd80         	pop	{r7, pc}
 800ee0a: bf00         	nop

0800ee0c <$d>:
 800ee0c: 41 3f 02 08  	.word	0x08023f41

0800ee10 <uart_stm32_poll_out>:
; {
 800ee10: b580         	push	{r7, lr}
 800ee12: b082         	sub	sp, #0x8
 800ee14: af00         	add	r7, sp, #0x0
 800ee16: 6078         	str	r0, [r7, #0x4]
 800ee18: 460b         	mov	r3, r1
 800ee1a: 70fb         	strb	r3, [r7, #0x3]
; 	uart_stm32_poll_out_visitor(dev, c, poll_out_u8);
 800ee1c: 78fb         	ldrb	r3, [r7, #0x3]
 800ee1e: b29b         	uxth	r3, r3
 800ee20: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800ee34 <uart_stm32_poll_out+0x24>
 800ee22: 4619         	mov	r1, r3
 800ee24: 6878         	ldr	r0, [r7, #0x4]
 800ee26: f015 f83f    	bl	0x8023ea8 <uart_stm32_poll_out_visitor> @ imm = #0x1507e
; }
 800ee2a: bf00         	nop
 800ee2c: 3708         	adds	r7, #0x8
 800ee2e: 46bd         	mov	sp, r7
 800ee30: bd80         	pop	{r7, pc}
 800ee32: bf00         	nop

0800ee34 <$d>:
 800ee34: 61 3f 02 08  	.word	0x08023f61

0800ee38 <__uart_stm32_get_clock>:
; {
 800ee38: b480         	push	{r7}
 800ee3a: b085         	sub	sp, #0x14
 800ee3c: af00         	add	r7, sp, #0x0
 800ee3e: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800ee40: 687b         	ldr	r3, [r7, #0x4]
 800ee42: 691b         	ldr	r3, [r3, #0x10]
 800ee44: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800ee46: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800ee5c <__uart_stm32_get_clock+0x24>
 800ee48: 60bb         	str	r3, [r7, #0x8]
; 	data->clock = clk;
 800ee4a: 68fb         	ldr	r3, [r7, #0xc]
 800ee4c: 68ba         	ldr	r2, [r7, #0x8]
 800ee4e: 601a         	str	r2, [r3]
; }
 800ee50: bf00         	nop
 800ee52: 3714         	adds	r7, #0x14
 800ee54: 46bd         	mov	sp, r7
 800ee56: f85d 7b04    	ldr	r7, [sp], #4
 800ee5a: 4770         	bx	lr

0800ee5c <$d>:
 800ee5c: c0 96 02 08  	.word	0x080296c0

0800ee60 <uart_stm32_fifo_fill>:
; {
 800ee60: b590         	push	{r4, r7, lr}
 800ee62: b085         	sub	sp, #0x14
 800ee64: af00         	add	r7, sp, #0x0
 800ee66: 60f8         	str	r0, [r7, #0xc]
 800ee68: 60b9         	str	r1, [r7, #0x8]
 800ee6a: 607a         	str	r2, [r7, #0x4]
; 	if (uart_stm32_ll2cfg_databits(uart_stm32_get_databits(dev), uart_stm32_get_parity(dev)) ==
 800ee6c: 68f8         	ldr	r0, [r7, #0xc]
 800ee6e: f014 fdc9    	bl	0x8023a04 <uart_stm32_get_databits> @ imm = #0x14b92
 800ee72: 4604         	mov	r4, r0
 800ee74: 68f8         	ldr	r0, [r7, #0xc]
 800ee76: f014 fd7f    	bl	0x8023978 <uart_stm32_get_parity> @ imm = #0x14afe
 800ee7a: 4603         	mov	r3, r0
 800ee7c: 4619         	mov	r1, r3
 800ee7e: 4620         	mov	r0, r4
 800ee80: f014 feba    	bl	0x8023bf8 <uart_stm32_ll2cfg_databits> @ imm = #0x14d74
 800ee84: 4603         	mov	r3, r0
 800ee86: 2b04         	cmp	r3, #0x4
 800ee88: d102         	bne	0x800ee90 <uart_stm32_fifo_fill+0x30> @ imm = #0x4
; 		return -ENOTSUP;
 800ee8a: f06f 0385    	mvn	r3, #0x85
 800ee8e: e006         	b	0x800ee9e <uart_stm32_fifo_fill+0x3e> @ imm = #0xc
; 	return uart_stm32_fifo_fill_visitor(dev, (const void *)tx_data, size,
 800ee90: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800eea8 <uart_stm32_fifo_fill+0x48>
 800ee92: 687a         	ldr	r2, [r7, #0x4]
 800ee94: 68b9         	ldr	r1, [r7, #0x8]
 800ee96: 68f8         	ldr	r0, [r7, #0xc]
 800ee98: f015 f8dd    	bl	0x8024056 <uart_stm32_fifo_fill_visitor> @ imm = #0x151ba
 800ee9c: 4603         	mov	r3, r0
; }
 800ee9e: 4618         	mov	r0, r3
 800eea0: 3714         	adds	r7, #0x14
 800eea2: 46bd         	mov	sp, r7
 800eea4: bd90         	pop	{r4, r7, pc}
 800eea6: bf00         	nop

0800eea8 <$d>:
 800eea8: ef 40 02 08  	.word	0x080240ef

0800eeac <uart_stm32_fifo_read>:
; {
 800eeac: b590         	push	{r4, r7, lr}
 800eeae: b085         	sub	sp, #0x14
 800eeb0: af00         	add	r7, sp, #0x0
 800eeb2: 60f8         	str	r0, [r7, #0xc]
 800eeb4: 60b9         	str	r1, [r7, #0x8]
 800eeb6: 607a         	str	r2, [r7, #0x4]
; 	if (uart_stm32_ll2cfg_databits(uart_stm32_get_databits(dev), uart_stm32_get_parity(dev)) ==
 800eeb8: 68f8         	ldr	r0, [r7, #0xc]
 800eeba: f014 fda3    	bl	0x8023a04 <uart_stm32_get_databits> @ imm = #0x14b46
 800eebe: 4604         	mov	r4, r0
 800eec0: 68f8         	ldr	r0, [r7, #0xc]
 800eec2: f014 fd59    	bl	0x8023978 <uart_stm32_get_parity> @ imm = #0x14ab2
 800eec6: 4603         	mov	r3, r0
 800eec8: 4619         	mov	r1, r3
 800eeca: 4620         	mov	r0, r4
 800eecc: f014 fe94    	bl	0x8023bf8 <uart_stm32_ll2cfg_databits> @ imm = #0x14d28
 800eed0: 4603         	mov	r3, r0
 800eed2: 2b04         	cmp	r3, #0x4
 800eed4: d102         	bne	0x800eedc <uart_stm32_fifo_read+0x30> @ imm = #0x4
; 		return -ENOTSUP;
 800eed6: f06f 0385    	mvn	r3, #0x85
 800eeda: e006         	b	0x800eeea <uart_stm32_fifo_read+0x3e> @ imm = #0xc
; 	return uart_stm32_fifo_read_visitor(dev, (void *)rx_data, size,
 800eedc: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800eef4 <uart_stm32_fifo_read+0x48>
 800eede: 687a         	ldr	r2, [r7, #0x4]
 800eee0: 68b9         	ldr	r1, [r7, #0x8]
 800eee2: 68f8         	ldr	r0, [r7, #0xc]
 800eee4: f015 f917    	bl	0x8024116 <uart_stm32_fifo_read_visitor> @ imm = #0x1522e
 800eee8: 4603         	mov	r3, r0
; }
 800eeea: 4618         	mov	r0, r3
 800eeec: 3714         	adds	r7, #0x14
 800eeee: 46bd         	mov	sp, r7
 800eef0: bd90         	pop	{r4, r7, pc}
 800eef2: bf00         	nop

0800eef4 <$d>:
 800eef4: 79 41 02 08  	.word	0x08024179

0800eef8 <uart_stm32_irq_err_enable>:
; {
 800eef8: b580         	push	{r7, lr}
 800eefa: b084         	sub	sp, #0x10
 800eefc: af00         	add	r7, sp, #0x0
 800eefe: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800ef00: 687b         	ldr	r3, [r7, #0x4]
 800ef02: 685b         	ldr	r3, [r3, #0x4]
 800ef04: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 800ef06: 68fb         	ldr	r3, [r7, #0xc]
 800ef08: 681b         	ldr	r3, [r3]
 800ef0a: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_EnableIT_ERROR(usart);
 800ef0c: 68b8         	ldr	r0, [r7, #0x8]
 800ef0e: f014 fb45    	bl	0x802359c <LL_USART_EnableIT_ERROR> @ imm = #0x1468a
; 	if (IS_UART_LIN_INSTANCE(usart)) {
 800ef12: 68bb         	ldr	r3, [r7, #0x8]
 800ef14: 4a18         	ldr	r2, [pc, #0x60]         @ 0x800ef78 <uart_stm32_irq_err_enable+0x80>
 800ef16: 4293         	cmp	r3, r2
 800ef18: d023         	beq	0x800ef62 <uart_stm32_irq_err_enable+0x6a> @ imm = #0x46
 800ef1a: 68bb         	ldr	r3, [r7, #0x8]
 800ef1c: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800ef7c <uart_stm32_irq_err_enable+0x84>
 800ef1e: 4293         	cmp	r3, r2
 800ef20: d01f         	beq	0x800ef62 <uart_stm32_irq_err_enable+0x6a> @ imm = #0x3e
 800ef22: 68bb         	ldr	r3, [r7, #0x8]
 800ef24: 4a16         	ldr	r2, [pc, #0x58]         @ 0x800ef80 <uart_stm32_irq_err_enable+0x88>
 800ef26: 4293         	cmp	r3, r2
 800ef28: d01b         	beq	0x800ef62 <uart_stm32_irq_err_enable+0x6a> @ imm = #0x36
 800ef2a: 68bb         	ldr	r3, [r7, #0x8]
 800ef2c: 4a15         	ldr	r2, [pc, #0x54]         @ 0x800ef84 <uart_stm32_irq_err_enable+0x8c>
 800ef2e: 4293         	cmp	r3, r2
 800ef30: d017         	beq	0x800ef62 <uart_stm32_irq_err_enable+0x6a> @ imm = #0x2e
 800ef32: 68bb         	ldr	r3, [r7, #0x8]
 800ef34: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800ef88 <uart_stm32_irq_err_enable+0x90>
 800ef36: 4293         	cmp	r3, r2
 800ef38: d013         	beq	0x800ef62 <uart_stm32_irq_err_enable+0x6a> @ imm = #0x26
 800ef3a: 68bb         	ldr	r3, [r7, #0x8]
 800ef3c: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800ef8c <uart_stm32_irq_err_enable+0x94>
 800ef3e: 4293         	cmp	r3, r2
 800ef40: d00f         	beq	0x800ef62 <uart_stm32_irq_err_enable+0x6a> @ imm = #0x1e
 800ef42: 68bb         	ldr	r3, [r7, #0x8]
 800ef44: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800ef90 <uart_stm32_irq_err_enable+0x98>
 800ef46: 4293         	cmp	r3, r2
 800ef48: d00b         	beq	0x800ef62 <uart_stm32_irq_err_enable+0x6a> @ imm = #0x16
 800ef4a: 68bb         	ldr	r3, [r7, #0x8]
 800ef4c: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800ef94 <uart_stm32_irq_err_enable+0x9c>
 800ef4e: 4293         	cmp	r3, r2
 800ef50: d007         	beq	0x800ef62 <uart_stm32_irq_err_enable+0x6a> @ imm = #0xe
 800ef52: 68bb         	ldr	r3, [r7, #0x8]
 800ef54: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800ef98 <uart_stm32_irq_err_enable+0xa0>
 800ef56: 4293         	cmp	r3, r2
 800ef58: d003         	beq	0x800ef62 <uart_stm32_irq_err_enable+0x6a> @ imm = #0x6
 800ef5a: 68bb         	ldr	r3, [r7, #0x8]
 800ef5c: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x800ef9c <uart_stm32_irq_err_enable+0xa4>
 800ef5e: 4293         	cmp	r3, r2
 800ef60: d102         	bne	0x800ef68 <uart_stm32_irq_err_enable+0x70> @ imm = #0x4
; 		LL_USART_EnableIT_LBD(usart);
 800ef62: 68b8         	ldr	r0, [r7, #0x8]
 800ef64: f014 fb0a    	bl	0x802357c <LL_USART_EnableIT_LBD> @ imm = #0x14614
; 	LL_USART_EnableIT_PE(usart);
 800ef68: 68b8         	ldr	r0, [r7, #0x8]
 800ef6a: f014 fae6    	bl	0x802353a <LL_USART_EnableIT_PE> @ imm = #0x145cc
; }
 800ef6e: bf00         	nop
 800ef70: 3710         	adds	r7, #0x10
 800ef72: 46bd         	mov	sp, r7
 800ef74: bd80         	pop	{r7, pc}
 800ef76: bf00         	nop

0800ef78 <$d>:
 800ef78: 00 10 01 40  	.word	0x40011000
 800ef7c: 00 44 00 40  	.word	0x40004400
 800ef80: 00 48 00 40  	.word	0x40004800
 800ef84: 00 4c 00 40  	.word	0x40004c00
 800ef88: 00 50 00 40  	.word	0x40005000
 800ef8c: 00 14 01 40  	.word	0x40011400
 800ef90: 00 78 00 40  	.word	0x40007800
 800ef94: 00 7c 00 40  	.word	0x40007c00
 800ef98: 00 18 01 40  	.word	0x40011800
 800ef9c: 00 1c 01 40  	.word	0x40011c00

0800efa0 <uart_stm32_irq_err_disable>:
; {
 800efa0: b580         	push	{r7, lr}
 800efa2: b084         	sub	sp, #0x10
 800efa4: af00         	add	r7, sp, #0x0
 800efa6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800efa8: 687b         	ldr	r3, [r7, #0x4]
 800efaa: 685b         	ldr	r3, [r3, #0x4]
 800efac: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 800efae: 68fb         	ldr	r3, [r7, #0xc]
 800efb0: 681b         	ldr	r3, [r3]
 800efb2: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_DisableIT_ERROR(usart);
 800efb4: 68b8         	ldr	r0, [r7, #0x8]
 800efb6: f014 fba8    	bl	0x802370a <LL_USART_DisableIT_ERROR> @ imm = #0x14750
; 	if (IS_UART_LIN_INSTANCE(usart)) {
 800efba: 68bb         	ldr	r3, [r7, #0x8]
 800efbc: 4a18         	ldr	r2, [pc, #0x60]         @ 0x800f020 <uart_stm32_irq_err_disable+0x80>
 800efbe: 4293         	cmp	r3, r2
 800efc0: d023         	beq	0x800f00a <uart_stm32_irq_err_disable+0x6a> @ imm = #0x46
 800efc2: 68bb         	ldr	r3, [r7, #0x8]
 800efc4: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800f024 <uart_stm32_irq_err_disable+0x84>
 800efc6: 4293         	cmp	r3, r2
 800efc8: d01f         	beq	0x800f00a <uart_stm32_irq_err_disable+0x6a> @ imm = #0x3e
 800efca: 68bb         	ldr	r3, [r7, #0x8]
 800efcc: 4a16         	ldr	r2, [pc, #0x58]         @ 0x800f028 <uart_stm32_irq_err_disable+0x88>
 800efce: 4293         	cmp	r3, r2
 800efd0: d01b         	beq	0x800f00a <uart_stm32_irq_err_disable+0x6a> @ imm = #0x36
 800efd2: 68bb         	ldr	r3, [r7, #0x8]
 800efd4: 4a15         	ldr	r2, [pc, #0x54]         @ 0x800f02c <uart_stm32_irq_err_disable+0x8c>
 800efd6: 4293         	cmp	r3, r2
 800efd8: d017         	beq	0x800f00a <uart_stm32_irq_err_disable+0x6a> @ imm = #0x2e
 800efda: 68bb         	ldr	r3, [r7, #0x8]
 800efdc: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800f030 <uart_stm32_irq_err_disable+0x90>
 800efde: 4293         	cmp	r3, r2
 800efe0: d013         	beq	0x800f00a <uart_stm32_irq_err_disable+0x6a> @ imm = #0x26
 800efe2: 68bb         	ldr	r3, [r7, #0x8]
 800efe4: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800f034 <uart_stm32_irq_err_disable+0x94>
 800efe6: 4293         	cmp	r3, r2
 800efe8: d00f         	beq	0x800f00a <uart_stm32_irq_err_disable+0x6a> @ imm = #0x1e
 800efea: 68bb         	ldr	r3, [r7, #0x8]
 800efec: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800f038 <uart_stm32_irq_err_disable+0x98>
 800efee: 4293         	cmp	r3, r2
 800eff0: d00b         	beq	0x800f00a <uart_stm32_irq_err_disable+0x6a> @ imm = #0x16
 800eff2: 68bb         	ldr	r3, [r7, #0x8]
 800eff4: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800f03c <uart_stm32_irq_err_disable+0x9c>
 800eff6: 4293         	cmp	r3, r2
 800eff8: d007         	beq	0x800f00a <uart_stm32_irq_err_disable+0x6a> @ imm = #0xe
 800effa: 68bb         	ldr	r3, [r7, #0x8]
 800effc: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800f040 <uart_stm32_irq_err_disable+0xa0>
 800effe: 4293         	cmp	r3, r2
 800f000: d003         	beq	0x800f00a <uart_stm32_irq_err_disable+0x6a> @ imm = #0x6
 800f002: 68bb         	ldr	r3, [r7, #0x8]
 800f004: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x800f044 <uart_stm32_irq_err_disable+0xa4>
 800f006: 4293         	cmp	r3, r2
 800f008: d102         	bne	0x800f010 <uart_stm32_irq_err_disable+0x70> @ imm = #0x4
; 		LL_USART_DisableIT_LBD(usart);
 800f00a: 68b8         	ldr	r0, [r7, #0x8]
 800f00c: f014 fb6d    	bl	0x80236ea <LL_USART_DisableIT_LBD> @ imm = #0x146da
; 	LL_USART_DisableIT_PE(usart);
 800f010: 68b8         	ldr	r0, [r7, #0x8]
 800f012: f014 fb49    	bl	0x80236a8 <LL_USART_DisableIT_PE> @ imm = #0x14692
; }
 800f016: bf00         	nop
 800f018: 3710         	adds	r7, #0x10
 800f01a: 46bd         	mov	sp, r7
 800f01c: bd80         	pop	{r7, pc}
 800f01e: bf00         	nop

0800f020 <$d>:
 800f020: 00 10 01 40  	.word	0x40011000
 800f024: 00 44 00 40  	.word	0x40004400
 800f028: 00 48 00 40  	.word	0x40004800
 800f02c: 00 4c 00 40  	.word	0x40004c00
 800f030: 00 50 00 40  	.word	0x40005000
 800f034: 00 14 01 40  	.word	0x40011400
 800f038: 00 78 00 40  	.word	0x40007800
 800f03c: 00 7c 00 40  	.word	0x40007c00
 800f040: 00 18 01 40  	.word	0x40011800
 800f044: 00 1c 01 40  	.word	0x40011c00

0800f048 <async_evt_rx_rdy>:
; {
 800f048: b580         	push	{r7, lr}
 800f04a: b090         	sub	sp, #0x40
 800f04c: af06         	add	r7, sp, #0x18
 800f04e: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("rx_rdy: (%d %d)", data->dma_rx.offset, data->dma_rx.counter);
 800f050: 2303         	movs	r3, #0x3
 800f052: 2b03         	cmp	r3, #0x3
 800f054: d920         	bls	0x800f098 <async_evt_rx_rdy+0x50> @ imm = #0x40
 800f056: 2301         	movs	r3, #0x1
 800f058: f887 3027    	strb.w	r3, [r7, #0x27]
 800f05c: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800f060: f083 0301    	eor	r3, r3, #0x1
 800f064: b2db         	uxtb	r3, r3
 800f066: 2b00         	cmp	r3, #0x0
 800f068: d116         	bne	0x800f098 <async_evt_rx_rdy+0x50> @ imm = #0x2c
 800f06a: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800f0e8 <async_evt_rx_rdy+0xa0>
 800f06c: 6819         	ldr	r1, [r3]
 800f06e: 687b         	ldr	r3, [r7, #0x4]
 800f070: 6f5b         	ldr	r3, [r3, #0x74]
 800f072: 687a         	ldr	r2, [r7, #0x4]
 800f074: 6f92         	ldr	r2, [r2, #0x78]
 800f076: 9205         	str	r2, [sp, #0x14]
 800f078: 9304         	str	r3, [sp, #0x10]
 800f07a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800f0ec <async_evt_rx_rdy+0xa4>
 800f07c: 9303         	str	r3, [sp, #0xc]
 800f07e: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800f0f0 <async_evt_rx_rdy+0xa8>
 800f080: 9302         	str	r3, [sp, #0x8]
 800f082: 2308         	movs	r3, #0x8
 800f084: 9301         	str	r3, [sp, #0x4]
 800f086: 2300         	movs	r3, #0x0
 800f088: 9300         	str	r3, [sp]
 800f08a: 2300         	movs	r3, #0x0
 800f08c: 2204         	movs	r2, #0x4
 800f08e: 2000         	movs	r0, #0x0
 800f090: f014 fc42    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x14884
 800f094: 2300         	movs	r3, #0x0
 800f096: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800f098: f107 030c    	add.w	r3, r7, #0xc
 800f09c: 2200         	movs	r2, #0x0
 800f09e: 601a         	str	r2, [r3]
 800f0a0: 605a         	str	r2, [r3, #0x4]
 800f0a2: 609a         	str	r2, [r3, #0x8]
 800f0a4: 60da         	str	r2, [r3, #0xc]
 800f0a6: 611a         	str	r2, [r3, #0x10]
 800f0a8: 2302         	movs	r3, #0x2
 800f0aa: 733b         	strb	r3, [r7, #0xc]
; 		.data.rx.buf = data->dma_rx.buffer,
 800f0ac: 687b         	ldr	r3, [r7, #0x4]
 800f0ae: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event event = {
 800f0b0: 613b         	str	r3, [r7, #0x10]
; 		.data.rx.offset = data->dma_rx.offset
 800f0b2: 687b         	ldr	r3, [r7, #0x4]
 800f0b4: 6f5b         	ldr	r3, [r3, #0x74]
; 	struct uart_event event = {
 800f0b6: 617b         	str	r3, [r7, #0x14]
; 		.data.rx.len = data->dma_rx.counter - data->dma_rx.offset,
 800f0b8: 687b         	ldr	r3, [r7, #0x4]
 800f0ba: 6f9a         	ldr	r2, [r3, #0x78]
 800f0bc: 687b         	ldr	r3, [r7, #0x4]
 800f0be: 6f5b         	ldr	r3, [r3, #0x74]
 800f0c0: 1ad3         	subs	r3, r2, r3
; 	struct uart_event event = {
 800f0c2: 61bb         	str	r3, [r7, #0x18]
; 	data->dma_rx.offset = data->dma_rx.counter;
 800f0c4: 687b         	ldr	r3, [r7, #0x4]
 800f0c6: 6f9a         	ldr	r2, [r3, #0x78]
 800f0c8: 687b         	ldr	r3, [r7, #0x4]
 800f0ca: 675a         	str	r2, [r3, #0x74]
; 	if (event.data.rx.len > 0) {
 800f0cc: 69bb         	ldr	r3, [r7, #0x18]
 800f0ce: 2b00         	cmp	r3, #0x0
 800f0d0: d005         	beq	0x800f0de <async_evt_rx_rdy+0x96> @ imm = #0xa
; 		async_user_callback(data, &event);
 800f0d2: f107 030c    	add.w	r3, r7, #0xc
 800f0d6: 4619         	mov	r1, r3
 800f0d8: 6878         	ldr	r0, [r7, #0x4]
 800f0da: f015 f930    	bl	0x802433e <async_user_callback> @ imm = #0x15260
; }
 800f0de: bf00         	nop
 800f0e0: 3728         	adds	r7, #0x28
 800f0e2: 46bd         	mov	sp, r7
 800f0e4: bd80         	pop	{r7, pc}
 800f0e6: bf00         	nop

0800f0e8 <$d>:
 800f0e8: ec 06 00 24  	.word	0x240006ec
 800f0ec: 64 d8 02 08  	.word	0x0802d864
 800f0f0: 18 bf 02 08  	.word	0x0802bf18

0800f0f4 <async_evt_rx_err>:
; {
 800f0f4: b580         	push	{r7, lr}
 800f0f6: b090         	sub	sp, #0x40
 800f0f8: af06         	add	r7, sp, #0x18
 800f0fa: 6078         	str	r0, [r7, #0x4]
 800f0fc: 6039         	str	r1, [r7]
; 	LOG_DBG("rx error: %d", err_code);
 800f0fe: 2303         	movs	r3, #0x3
 800f100: 2b03         	cmp	r3, #0x3
 800f102: d91c         	bls	0x800f13e <async_evt_rx_err+0x4a> @ imm = #0x38
 800f104: 2301         	movs	r3, #0x1
 800f106: f887 3027    	strb.w	r3, [r7, #0x27]
 800f10a: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800f10e: f083 0301    	eor	r3, r3, #0x1
 800f112: b2db         	uxtb	r3, r3
 800f114: 2b00         	cmp	r3, #0x0
 800f116: d112         	bne	0x800f13e <async_evt_rx_err+0x4a> @ imm = #0x24
 800f118: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800f16c <async_evt_rx_err+0x78>
 800f11a: 6819         	ldr	r1, [r3]
 800f11c: 683b         	ldr	r3, [r7]
 800f11e: 9304         	str	r3, [sp, #0x10]
 800f120: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800f170 <async_evt_rx_err+0x7c>
 800f122: 9303         	str	r3, [sp, #0xc]
 800f124: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800f174 <async_evt_rx_err+0x80>
 800f126: 9302         	str	r3, [sp, #0x8]
 800f128: 2308         	movs	r3, #0x8
 800f12a: 9301         	str	r3, [sp, #0x4]
 800f12c: 2300         	movs	r3, #0x0
 800f12e: 9300         	str	r3, [sp]
 800f130: 2300         	movs	r3, #0x0
 800f132: 2204         	movs	r2, #0x4
 800f134: 2000         	movs	r0, #0x0
 800f136: f014 fbef    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x147de
 800f13a: 2300         	movs	r3, #0x0
 800f13c: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800f13e: 2306         	movs	r3, #0x6
 800f140: 733b         	strb	r3, [r7, #0xc]
 800f142: 683b         	ldr	r3, [r7]
 800f144: b2db         	uxtb	r3, r3
 800f146: 743b         	strb	r3, [r7, #0x10]
; 		.data.rx_stop.data.buf = data->dma_rx.buffer
 800f148: 687b         	ldr	r3, [r7, #0x4]
 800f14a: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event event = {
 800f14c: 617b         	str	r3, [r7, #0x14]
 800f14e: 2300         	movs	r3, #0x0
 800f150: 61bb         	str	r3, [r7, #0x18]
; 		.data.rx_stop.data.len = data->dma_rx.counter,
 800f152: 687b         	ldr	r3, [r7, #0x4]
 800f154: 6f9b         	ldr	r3, [r3, #0x78]
; 	struct uart_event event = {
 800f156: 61fb         	str	r3, [r7, #0x1c]
; 	async_user_callback(data, &event);
 800f158: f107 030c    	add.w	r3, r7, #0xc
 800f15c: 4619         	mov	r1, r3
 800f15e: 6878         	ldr	r0, [r7, #0x4]
 800f160: f015 f8ed    	bl	0x802433e <async_user_callback> @ imm = #0x151da
; }
 800f164: bf00         	nop
 800f166: 3728         	adds	r7, #0x28
 800f168: 46bd         	mov	sp, r7
 800f16a: bd80         	pop	{r7, pc}

0800f16c <$d>:
 800f16c: ec 06 00 24  	.word	0x240006ec
 800f170: ec d8 02 08  	.word	0x0802d8ec
 800f174: 2c bf 02 08  	.word	0x0802bf2c

0800f178 <async_evt_tx_done>:
; {
 800f178: b580         	push	{r7, lr}
 800f17a: b090         	sub	sp, #0x40
 800f17c: af06         	add	r7, sp, #0x18
 800f17e: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("tx done: %d", data->dma_tx.counter);
 800f180: 2303         	movs	r3, #0x3
 800f182: 2b03         	cmp	r3, #0x3
 800f184: d91e         	bls	0x800f1c4 <async_evt_tx_done+0x4c> @ imm = #0x3c
 800f186: 2301         	movs	r3, #0x1
 800f188: f887 3027    	strb.w	r3, [r7, #0x27]
 800f18c: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800f190: f083 0301    	eor	r3, r3, #0x1
 800f194: b2db         	uxtb	r3, r3
 800f196: 2b00         	cmp	r3, #0x0
 800f198: d114         	bne	0x800f1c4 <async_evt_tx_done+0x4c> @ imm = #0x28
 800f19a: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800f208 <async_evt_tx_done+0x90>
 800f19c: 6819         	ldr	r1, [r3]
 800f19e: 687b         	ldr	r3, [r7, #0x4]
 800f1a0: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 800f1a4: 9304         	str	r3, [sp, #0x10]
 800f1a6: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800f20c <async_evt_tx_done+0x94>
 800f1a8: 9303         	str	r3, [sp, #0xc]
 800f1aa: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800f210 <async_evt_tx_done+0x98>
 800f1ac: 9302         	str	r3, [sp, #0x8]
 800f1ae: 2308         	movs	r3, #0x8
 800f1b0: 9301         	str	r3, [sp, #0x4]
 800f1b2: 2300         	movs	r3, #0x0
 800f1b4: 9300         	str	r3, [sp]
 800f1b6: 2300         	movs	r3, #0x0
 800f1b8: 2204         	movs	r2, #0x4
 800f1ba: 2000         	movs	r0, #0x0
 800f1bc: f014 fbac    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x14758
 800f1c0: 2300         	movs	r3, #0x0
 800f1c2: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800f1c4: f107 030c    	add.w	r3, r7, #0xc
 800f1c8: 2200         	movs	r2, #0x0
 800f1ca: 601a         	str	r2, [r3]
 800f1cc: 605a         	str	r2, [r3, #0x4]
 800f1ce: 609a         	str	r2, [r3, #0x8]
 800f1d0: 60da         	str	r2, [r3, #0xc]
 800f1d2: 611a         	str	r2, [r3, #0x10]
; 		.data.tx.buf = data->dma_tx.buffer,
 800f1d4: 687b         	ldr	r3, [r7, #0x4]
 800f1d6: f8d3 3104    	ldr.w	r3, [r3, #0x104]
; 	struct uart_event event = {
 800f1da: 613b         	str	r3, [r7, #0x10]
; 		.data.tx.len = data->dma_tx.counter
 800f1dc: 687b         	ldr	r3, [r7, #0x4]
 800f1de: f8d3 3110    	ldr.w	r3, [r3, #0x110]
; 	struct uart_event event = {
 800f1e2: 617b         	str	r3, [r7, #0x14]
; 	data->dma_tx.buffer_length = 0;
 800f1e4: 687b         	ldr	r3, [r7, #0x4]
 800f1e6: 2200         	movs	r2, #0x0
 800f1e8: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.counter = 0;
 800f1ec: 687b         	ldr	r3, [r7, #0x4]
 800f1ee: 2200         	movs	r2, #0x0
 800f1f0: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	async_user_callback(data, &event);
 800f1f4: f107 030c    	add.w	r3, r7, #0xc
 800f1f8: 4619         	mov	r1, r3
 800f1fa: 6878         	ldr	r0, [r7, #0x4]
 800f1fc: f015 f89f    	bl	0x802433e <async_user_callback> @ imm = #0x1513e
; }
 800f200: bf00         	nop
 800f202: 3728         	adds	r7, #0x28
 800f204: 46bd         	mov	sp, r7
 800f206: bd80         	pop	{r7, pc}

0800f208 <$d>:
 800f208: ec 06 00 24  	.word	0x240006ec
 800f20c: 9c d8 02 08  	.word	0x0802d89c
 800f210: 40 bf 02 08  	.word	0x0802bf40

0800f214 <async_evt_tx_abort>:
; {
 800f214: b580         	push	{r7, lr}
 800f216: b090         	sub	sp, #0x40
 800f218: af06         	add	r7, sp, #0x18
 800f21a: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("tx abort: %d", data->dma_tx.counter);
 800f21c: 2303         	movs	r3, #0x3
 800f21e: 2b03         	cmp	r3, #0x3
 800f220: d91e         	bls	0x800f260 <async_evt_tx_abort+0x4c> @ imm = #0x3c
 800f222: 2301         	movs	r3, #0x1
 800f224: f887 3027    	strb.w	r3, [r7, #0x27]
 800f228: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800f22c: f083 0301    	eor	r3, r3, #0x1
 800f230: b2db         	uxtb	r3, r3
 800f232: 2b00         	cmp	r3, #0x0
 800f234: d114         	bne	0x800f260 <async_evt_tx_abort+0x4c> @ imm = #0x28
 800f236: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800f2a8 <async_evt_tx_abort+0x94>
 800f238: 6819         	ldr	r1, [r3]
 800f23a: 687b         	ldr	r3, [r7, #0x4]
 800f23c: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 800f240: 9304         	str	r3, [sp, #0x10]
 800f242: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800f2ac <async_evt_tx_abort+0x98>
 800f244: 9303         	str	r3, [sp, #0xc]
 800f246: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800f2b0 <async_evt_tx_abort+0x9c>
 800f248: 9302         	str	r3, [sp, #0x8]
 800f24a: 2308         	movs	r3, #0x8
 800f24c: 9301         	str	r3, [sp, #0x4]
 800f24e: 2300         	movs	r3, #0x0
 800f250: 9300         	str	r3, [sp]
 800f252: 2300         	movs	r3, #0x0
 800f254: 2204         	movs	r2, #0x4
 800f256: 2000         	movs	r0, #0x0
 800f258: f014 fb5e    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x146bc
 800f25c: 2300         	movs	r3, #0x0
 800f25e: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800f260: f107 030c    	add.w	r3, r7, #0xc
 800f264: 2200         	movs	r2, #0x0
 800f266: 601a         	str	r2, [r3]
 800f268: 605a         	str	r2, [r3, #0x4]
 800f26a: 609a         	str	r2, [r3, #0x8]
 800f26c: 60da         	str	r2, [r3, #0xc]
 800f26e: 611a         	str	r2, [r3, #0x10]
 800f270: 2301         	movs	r3, #0x1
 800f272: 733b         	strb	r3, [r7, #0xc]
; 		.data.tx.buf = data->dma_tx.buffer,
 800f274: 687b         	ldr	r3, [r7, #0x4]
 800f276: f8d3 3104    	ldr.w	r3, [r3, #0x104]
; 	struct uart_event event = {
 800f27a: 613b         	str	r3, [r7, #0x10]
; 		.data.tx.len = data->dma_tx.counter
 800f27c: 687b         	ldr	r3, [r7, #0x4]
 800f27e: f8d3 3110    	ldr.w	r3, [r3, #0x110]
; 	struct uart_event event = {
 800f282: 617b         	str	r3, [r7, #0x14]
; 	data->dma_tx.buffer_length = 0;
 800f284: 687b         	ldr	r3, [r7, #0x4]
 800f286: 2200         	movs	r2, #0x0
 800f288: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.counter = 0;
 800f28c: 687b         	ldr	r3, [r7, #0x4]
 800f28e: 2200         	movs	r2, #0x0
 800f290: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	async_user_callback(data, &event);
 800f294: f107 030c    	add.w	r3, r7, #0xc
 800f298: 4619         	mov	r1, r3
 800f29a: 6878         	ldr	r0, [r7, #0x4]
 800f29c: f015 f84f    	bl	0x802433e <async_user_callback> @ imm = #0x1509e
; }
 800f2a0: bf00         	nop
 800f2a2: 3728         	adds	r7, #0x28
 800f2a4: 46bd         	mov	sp, r7
 800f2a6: bd80         	pop	{r7, pc}

0800f2a8 <$d>:
 800f2a8: ec 06 00 24  	.word	0x240006ec
 800f2ac: 30 d9 02 08  	.word	0x0802d930
 800f2b0: 50 bf 02 08  	.word	0x0802bf50

0800f2b4 <async_timer_start>:
; {
 800f2b4: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800f2b8: b08a         	sub	sp, #0x28
 800f2ba: af06         	add	r7, sp, #0x18
 800f2bc: 6078         	str	r0, [r7, #0x4]
 800f2be: 6039         	str	r1, [r7]
; 	if ((timeout != SYS_FOREVER_US) && (timeout != 0)) {
 800f2c0: 683b         	ldr	r3, [r7]
 800f2c2: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800f2c6: d037         	beq	0x800f338 <async_timer_start+0x84> @ imm = #0x6e
 800f2c8: 683b         	ldr	r3, [r7]
 800f2ca: 2b00         	cmp	r3, #0x0
 800f2cc: d034         	beq	0x800f338 <async_timer_start+0x84> @ imm = #0x68
; 		LOG_DBG("async timer started for %d us", timeout);
 800f2ce: 2303         	movs	r3, #0x3
 800f2d0: 2b03         	cmp	r3, #0x3
 800f2d2: d91a         	bls	0x800f30a <async_timer_start+0x56> @ imm = #0x34
 800f2d4: 2301         	movs	r3, #0x1
 800f2d6: 73fb         	strb	r3, [r7, #0xf]
 800f2d8: 7bfb         	ldrb	r3, [r7, #0xf]
 800f2da: f083 0301    	eor	r3, r3, #0x1
 800f2de: b2db         	uxtb	r3, r3
 800f2e0: 2b00         	cmp	r3, #0x0
 800f2e2: d112         	bne	0x800f30a <async_timer_start+0x56> @ imm = #0x24
 800f2e4: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800f344 <async_timer_start+0x90>
 800f2e6: 6819         	ldr	r1, [r3]
 800f2e8: 683b         	ldr	r3, [r7]
 800f2ea: 9304         	str	r3, [sp, #0x10]
 800f2ec: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800f348 <async_timer_start+0x94>
 800f2ee: 9303         	str	r3, [sp, #0xc]
 800f2f0: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800f34c <async_timer_start+0x98>
 800f2f2: 9302         	str	r3, [sp, #0x8]
 800f2f4: 2308         	movs	r3, #0x8
 800f2f6: 9301         	str	r3, [sp, #0x4]
 800f2f8: 2300         	movs	r3, #0x0
 800f2fa: 9300         	str	r3, [sp]
 800f2fc: 2300         	movs	r3, #0x0
 800f2fe: 2204         	movs	r2, #0x4
 800f300: 2000         	movs	r0, #0x0
 800f302: f014 fb09    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x14612
 800f306: 2300         	movs	r3, #0x0
 800f308: 60bb         	str	r3, [r7, #0x8]
; 		k_work_reschedule(work, K_USEC(timeout));
 800f30a: 683b         	ldr	r3, [r7]
 800f30c: ea23 73e3    	bic.w	r3, r3, r3, asr #31
 800f310: 17da         	asrs	r2, r3, #0x1f
 800f312: 461c         	mov	r4, r3
 800f314: 4615         	mov	r5, r2
 800f316: f114 0863    	adds.w	r8, r4, #0x63
 800f31a: f145 0900    	adc	r9, r5, #0x0
 800f31e: f04f 0264    	mov.w	r2, #0x64
 800f322: f04f 0300    	mov.w	r3, #0x0
 800f326: 4640         	mov	r0, r8
 800f328: 4649         	mov	r1, r9
 800f32a: f7f1 f821    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0xefbe
 800f32e: 4602         	mov	r2, r0
 800f330: 460b         	mov	r3, r1
 800f332: 6878         	ldr	r0, [r7, #0x4]
 800f334: f006 fdac    	bl	0x8015e90 <k_work_reschedule> @ imm = #0x6b58
; }
 800f338: bf00         	nop
 800f33a: 3710         	adds	r7, #0x10
 800f33c: 46bd         	mov	sp, r7
 800f33e: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 800f342: bf00         	nop

0800f344 <$d>:
 800f344: ec 06 00 24  	.word	0x240006ec
 800f348: 88 d8 02 08  	.word	0x0802d888
 800f34c: 64 bf 02 08  	.word	0x0802bf64

0800f350 <uart_stm32_isr>:
; {
 800f350: b580         	push	{r7, lr}
 800f352: b08c         	sub	sp, #0x30
 800f354: af04         	add	r7, sp, #0x10
 800f356: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800f358: 687b         	ldr	r3, [r7, #0x4]
 800f35a: 691b         	ldr	r3, [r3, #0x10]
 800f35c: 61fb         	str	r3, [r7, #0x1c]
; 	const struct uart_stm32_config *config = dev->config;
 800f35e: 687b         	ldr	r3, [r7, #0x4]
 800f360: 685b         	ldr	r3, [r3, #0x4]
 800f362: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 800f364: 69bb         	ldr	r3, [r7, #0x18]
 800f366: 681b         	ldr	r3, [r3]
 800f368: 617b         	str	r3, [r7, #0x14]
; 	if (data->user_cb) {
 800f36a: 69fb         	ldr	r3, [r7, #0x1c]
 800f36c: 689b         	ldr	r3, [r3, #0x8]
 800f36e: 2b00         	cmp	r3, #0x0
 800f370: d006         	beq	0x800f380 <uart_stm32_isr+0x30> @ imm = #0xc
; 		data->user_cb(dev, data->user_data);
 800f372: 69fb         	ldr	r3, [r7, #0x1c]
 800f374: 689b         	ldr	r3, [r3, #0x8]
 800f376: 69fa         	ldr	r2, [r7, #0x1c]
 800f378: 68d2         	ldr	r2, [r2, #0xc]
 800f37a: 4611         	mov	r1, r2
 800f37c: 6878         	ldr	r0, [r7, #0x4]
 800f37e: 4798         	blx	r3
; 	if (LL_USART_IsEnabledIT_IDLE(usart) &&
 800f380: 6978         	ldr	r0, [r7, #0x14]
 800f382: f014 f9e5    	bl	0x8023750 <LL_USART_IsEnabledIT_IDLE> @ imm = #0x143ca
 800f386: 4603         	mov	r3, r0
 800f388: 2b00         	cmp	r3, #0x0
 800f38a: d036         	beq	0x800f3fa <uart_stm32_isr+0xaa> @ imm = #0x6c
; 			LL_USART_IsActiveFlag_IDLE(usart)) {
 800f38c: 6978         	ldr	r0, [r7, #0x14]
 800f38e: f013 ff8d    	bl	0x80232ac <LL_USART_IsActiveFlag_IDLE> @ imm = #0x13f1a
 800f392: 4603         	mov	r3, r0
; 	if (LL_USART_IsEnabledIT_IDLE(usart) &&
 800f394: 2b00         	cmp	r3, #0x0
 800f396: d030         	beq	0x800f3fa <uart_stm32_isr+0xaa> @ imm = #0x60
; 		LL_USART_ClearFlag_IDLE(usart);
 800f398: 6978         	ldr	r0, [r7, #0x14]
 800f39a: f014 f843    	bl	0x8023424 <LL_USART_ClearFlag_IDLE> @ imm = #0x14086
; 		LOG_DBG("idle interrupt occurred");
 800f39e: 2303         	movs	r3, #0x3
 800f3a0: 2b03         	cmp	r3, #0x3
 800f3a2: d918         	bls	0x800f3d6 <uart_stm32_isr+0x86> @ imm = #0x30
 800f3a4: 2301         	movs	r3, #0x1
 800f3a6: 74fb         	strb	r3, [r7, #0x13]
 800f3a8: 7cfb         	ldrb	r3, [r7, #0x13]
 800f3aa: f083 0301    	eor	r3, r3, #0x1
 800f3ae: b2db         	uxtb	r3, r3
 800f3b0: 2b00         	cmp	r3, #0x0
 800f3b2: d110         	bne	0x800f3d6 <uart_stm32_isr+0x86> @ imm = #0x20
 800f3b4: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800f44c <uart_stm32_isr+0xfc>
 800f3b6: 6819         	ldr	r1, [r3]
 800f3b8: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800f450 <uart_stm32_isr+0x100>
 800f3ba: 9303         	str	r3, [sp, #0xc]
 800f3bc: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800f454 <uart_stm32_isr+0x104>
 800f3be: 9302         	str	r3, [sp, #0x8]
 800f3c0: 2308         	movs	r3, #0x8
 800f3c2: 9301         	str	r3, [sp, #0x4]
 800f3c4: 2300         	movs	r3, #0x0
 800f3c6: 9300         	str	r3, [sp]
 800f3c8: 2300         	movs	r3, #0x0
 800f3ca: 2204         	movs	r2, #0x4
 800f3cc: 2000         	movs	r0, #0x0
 800f3ce: f014 faa3    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x14546
 800f3d2: 2300         	movs	r3, #0x0
 800f3d4: 60fb         	str	r3, [r7, #0xc]
; 		if (data->dma_rx.timeout == 0) {
 800f3d6: 69fb         	ldr	r3, [r7, #0x1c]
 800f3d8: 6fdb         	ldr	r3, [r3, #0x7c]
 800f3da: 2b00         	cmp	r3, #0x0
 800f3dc: d103         	bne	0x800f3e6 <uart_stm32_isr+0x96> @ imm = #0x6
; 			uart_stm32_dma_rx_flush(dev);
 800f3de: 6878         	ldr	r0, [r7, #0x4]
 800f3e0: f014 fff5    	bl	0x80243ce <uart_stm32_dma_rx_flush> @ imm = #0x14fea
; 		if (data->dma_rx.timeout == 0) {
 800f3e4: e02b         	b	0x800f43e <uart_stm32_isr+0xee> @ imm = #0x56
; 			async_timer_start(&data->dma_rx.timeout_work,
 800f3e6: 69fb         	ldr	r3, [r7, #0x1c]
 800f3e8: f103 0280    	add.w	r2, r3, #0x80
 800f3ec: 69fb         	ldr	r3, [r7, #0x1c]
 800f3ee: 6fdb         	ldr	r3, [r3, #0x7c]
 800f3f0: 4619         	mov	r1, r3
 800f3f2: 4610         	mov	r0, r2
 800f3f4: f7ff ff5e    	bl	0x800f2b4 <async_timer_start> @ imm = #-0x144
; 		if (data->dma_rx.timeout == 0) {
 800f3f8: e021         	b	0x800f43e <uart_stm32_isr+0xee> @ imm = #0x42
; 	} else if (LL_USART_IsEnabledIT_TC(usart) &&
 800f3fa: 6978         	ldr	r0, [r7, #0x14]
 800f3fc: f014 f9ce    	bl	0x802379c <LL_USART_IsEnabledIT_TC> @ imm = #0x1439c
 800f400: 4603         	mov	r3, r0
 800f402: 2b00         	cmp	r3, #0x0
 800f404: d00c         	beq	0x800f420 <uart_stm32_isr+0xd0> @ imm = #0x18
; 			LL_USART_IsActiveFlag_TC(usart)) {
 800f406: 6978         	ldr	r0, [r7, #0x14]
 800f408: f013 ff76    	bl	0x80232f8 <LL_USART_IsActiveFlag_TC> @ imm = #0x13eec
 800f40c: 4603         	mov	r3, r0
; 	} else if (LL_USART_IsEnabledIT_TC(usart) &&
 800f40e: 2b00         	cmp	r3, #0x0
 800f410: d006         	beq	0x800f420 <uart_stm32_isr+0xd0> @ imm = #0xc
; 		LL_USART_DisableIT_TC(usart);
 800f412: 6978         	ldr	r0, [r7, #0x14]
 800f414: f014 f927    	bl	0x8023666 <LL_USART_DisableIT_TC> @ imm = #0x1424e
; 		async_evt_tx_done(data);
 800f418: 69f8         	ldr	r0, [r7, #0x1c]
 800f41a: f7ff fead    	bl	0x800f178 <async_evt_tx_done> @ imm = #-0x2a6
 800f41e: e00e         	b	0x800f43e <uart_stm32_isr+0xee> @ imm = #0x1c
; 	} else if (LL_USART_IsEnabledIT_RXNE(usart) &&
 800f420: 6978         	ldr	r0, [r7, #0x14]
 800f422: f014 f9a8    	bl	0x8023776 <LL_USART_IsEnabledIT_RXNE_RXFNE> @ imm = #0x14350
 800f426: 4603         	mov	r3, r0
 800f428: 2b00         	cmp	r3, #0x0
 800f42a: d008         	beq	0x800f43e <uart_stm32_isr+0xee> @ imm = #0x10
; 			LL_USART_IsActiveFlag_RXNE(usart)) {
 800f42c: 6978         	ldr	r0, [r7, #0x14]
 800f42e: f013 ff50    	bl	0x80232d2 <LL_USART_IsActiveFlag_RXNE_RXFNE> @ imm = #0x13ea0
 800f432: 4603         	mov	r3, r0
; 	} else if (LL_USART_IsEnabledIT_RXNE(usart) &&
 800f434: 2b00         	cmp	r3, #0x0
 800f436: d002         	beq	0x800f43e <uart_stm32_isr+0xee> @ imm = #0x4
; 		LL_USART_RequestRxDataFlush(usart);
 800f438: 6978         	ldr	r0, [r7, #0x14]
 800f43a: f014 fa5d    	bl	0x80238f8 <LL_USART_RequestRxDataFlush> @ imm = #0x144ba
; 	uart_stm32_err_check(dev);
 800f43e: 6878         	ldr	r0, [r7, #0x4]
 800f440: f014 fd9e    	bl	0x8023f80 <uart_stm32_err_check> @ imm = #0x14b3c
; }
 800f444: bf00         	nop
 800f446: 3720         	adds	r7, #0x20
 800f448: 46bd         	mov	sp, r7
 800f44a: bd80         	pop	{r7, pc}

0800f44c <$d>:
 800f44c: ec 06 00 24  	.word	0x240006ec
 800f450: 78 d8 02 08  	.word	0x0802d878
 800f454: 88 bf 02 08  	.word	0x0802bf88

0800f458 <uart_stm32_async_rx_disable>:
; {
 800f458: b580         	push	{r7, lr}
 800f45a: b096         	sub	sp, #0x58
 800f45c: af04         	add	r7, sp, #0x10
 800f45e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800f460: 687b         	ldr	r3, [r7, #0x4]
 800f462: 685b         	ldr	r3, [r3, #0x4]
 800f464: 647b         	str	r3, [r7, #0x44]
; 	USART_TypeDef *usart = config->usart;
 800f466: 6c7b         	ldr	r3, [r7, #0x44]
 800f468: 681b         	ldr	r3, [r3]
 800f46a: 643b         	str	r3, [r7, #0x40]
; 	struct uart_stm32_data *data = dev->data;
 800f46c: 687b         	ldr	r3, [r7, #0x4]
 800f46e: 691b         	ldr	r3, [r3, #0x10]
 800f470: 63fb         	str	r3, [r7, #0x3c]
; 	struct uart_event disabled_event = {
 800f472: f107 0320    	add.w	r3, r7, #0x20
 800f476: 2200         	movs	r2, #0x0
 800f478: 601a         	str	r2, [r3]
 800f47a: 605a         	str	r2, [r3, #0x4]
 800f47c: 609a         	str	r2, [r3, #0x8]
 800f47e: 60da         	str	r2, [r3, #0xc]
 800f480: 611a         	str	r2, [r3, #0x10]
 800f482: 2305         	movs	r3, #0x5
 800f484: f887 3020    	strb.w	r3, [r7, #0x20]
; 	if (!data->dma_rx.enabled) {
 800f488: 6bfb         	ldr	r3, [r7, #0x3c]
 800f48a: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 800f48e: f083 0301    	eor	r3, r3, #0x1
 800f492: b2db         	uxtb	r3, r3
 800f494: 2b00         	cmp	r3, #0x0
 800f496: d008         	beq	0x800f4aa <uart_stm32_async_rx_disable+0x52> @ imm = #0x10
; 		async_user_callback(data, &disabled_event);
 800f498: f107 0320    	add.w	r3, r7, #0x20
 800f49c: 4619         	mov	r1, r3
 800f49e: 6bf8         	ldr	r0, [r7, #0x3c]
 800f4a0: f014 ff4d    	bl	0x802433e <async_user_callback> @ imm = #0x14e9a
; 		return -EFAULT;
 800f4a4: f06f 030d    	mvn	r3, #0xd
 800f4a8: e061         	b	0x800f56e <uart_stm32_async_rx_disable+0x116> @ imm = #0xc2
; 	LL_USART_DisableIT_IDLE(usart);
 800f4aa: 6c38         	ldr	r0, [r7, #0x40]
 800f4ac: f014 f899    	bl	0x80235e2 <LL_USART_DisableIT_IDLE> @ imm = #0x14132
; 	uart_stm32_dma_rx_flush(dev);
 800f4b0: 6878         	ldr	r0, [r7, #0x4]
 800f4b2: f014 ff8c    	bl	0x80243ce <uart_stm32_dma_rx_flush> @ imm = #0x14f18
; 	async_evt_rx_buf_release(data);
 800f4b6: 6bf8         	ldr	r0, [r7, #0x3c]
 800f4b8: f014 ff6e    	bl	0x8024398 <async_evt_rx_buf_release> @ imm = #0x14edc
; 	uart_stm32_dma_rx_disable(dev);
 800f4bc: 6878         	ldr	r0, [r7, #0x4]
 800f4be: f015 f800    	bl	0x80244c2 <uart_stm32_dma_rx_disable> @ imm = #0x15000
; 	(void)k_work_cancel_delayable(&data->dma_rx.timeout_work);
 800f4c2: 6bfb         	ldr	r3, [r7, #0x3c]
 800f4c4: 3380         	adds	r3, #0x80
 800f4c6: 4618         	mov	r0, r3
 800f4c8: f006 fcf6    	bl	0x8015eb8 <k_work_cancel_delayable> @ imm = #0x69ec
; 	dma_stop(data->dma_rx.dma_dev, data->dma_rx.dma_channel);
 800f4cc: 6bfb         	ldr	r3, [r7, #0x3c]
 800f4ce: 6a1a         	ldr	r2, [r3, #0x20]
 800f4d0: 6bfb         	ldr	r3, [r7, #0x3c]
 800f4d2: 6a5b         	ldr	r3, [r3, #0x24]
 800f4d4: 4619         	mov	r1, r3
 800f4d6: 4610         	mov	r0, r2
 800f4d8: f013 fc82    	bl	0x8022de0 <dma_stop>    @ imm = #0x13904
; 	if (data->rx_next_buffer) {
 800f4dc: 6bfb         	ldr	r3, [r7, #0x3c]
 800f4de: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 800f4e2: 2b00         	cmp	r3, #0x0
 800f4e4: d013         	beq	0x800f50e <uart_stm32_async_rx_disable+0xb6> @ imm = #0x26
; 		struct uart_event rx_next_buf_release_evt = {
 800f4e6: f107 030c    	add.w	r3, r7, #0xc
 800f4ea: 2200         	movs	r2, #0x0
 800f4ec: 601a         	str	r2, [r3]
 800f4ee: 605a         	str	r2, [r3, #0x4]
 800f4f0: 609a         	str	r2, [r3, #0x8]
 800f4f2: 60da         	str	r2, [r3, #0xc]
 800f4f4: 611a         	str	r2, [r3, #0x10]
 800f4f6: 2304         	movs	r3, #0x4
 800f4f8: 733b         	strb	r3, [r7, #0xc]
; 			.data.rx_buf.buf = data->rx_next_buffer,
 800f4fa: 6bfb         	ldr	r3, [r7, #0x3c]
 800f4fc: f8d3 3150    	ldr.w	r3, [r3, #0x150]
; 		struct uart_event rx_next_buf_release_evt = {
 800f500: 613b         	str	r3, [r7, #0x10]
; 		async_user_callback(data, &rx_next_buf_release_evt);
 800f502: f107 030c    	add.w	r3, r7, #0xc
 800f506: 4619         	mov	r1, r3
 800f508: 6bf8         	ldr	r0, [r7, #0x3c]
 800f50a: f014 ff18    	bl	0x802433e <async_user_callback> @ imm = #0x14e30
; 	data->rx_next_buffer = NULL;
 800f50e: 6bfb         	ldr	r3, [r7, #0x3c]
 800f510: 2200         	movs	r2, #0x0
 800f512: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800f516: 6bfb         	ldr	r3, [r7, #0x3c]
 800f518: 2200         	movs	r2, #0x0
 800f51a: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	LL_USART_EnableIT_RXNE(usart);
 800f51e: 6c38         	ldr	r0, [r7, #0x40]
 800f520: f013 ffc9    	bl	0x80234b6 <LL_USART_EnableIT_RXNE_RXFNE> @ imm = #0x13f92
; 	LOG_DBG("rx: disabled");
 800f524: 2303         	movs	r3, #0x3
 800f526: 2b03         	cmp	r3, #0x3
 800f528: d91a         	bls	0x800f560 <uart_stm32_async_rx_disable+0x108> @ imm = #0x34
 800f52a: 2301         	movs	r3, #0x1
 800f52c: f887 303b    	strb.w	r3, [r7, #0x3b]
 800f530: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800f534: f083 0301    	eor	r3, r3, #0x1
 800f538: b2db         	uxtb	r3, r3
 800f53a: 2b00         	cmp	r3, #0x0
 800f53c: d110         	bne	0x800f560 <uart_stm32_async_rx_disable+0x108> @ imm = #0x20
 800f53e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800f578 <uart_stm32_async_rx_disable+0x120>
 800f540: 6819         	ldr	r1, [r3]
 800f542: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800f57c <uart_stm32_async_rx_disable+0x124>
 800f544: 9303         	str	r3, [sp, #0xc]
 800f546: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800f580 <uart_stm32_async_rx_disable+0x128>
 800f548: 9302         	str	r3, [sp, #0x8]
 800f54a: 2308         	movs	r3, #0x8
 800f54c: 9301         	str	r3, [sp, #0x4]
 800f54e: 2300         	movs	r3, #0x0
 800f550: 9300         	str	r3, [sp]
 800f552: 2300         	movs	r3, #0x0
 800f554: 2204         	movs	r2, #0x4
 800f556: 2000         	movs	r0, #0x0
 800f558: f014 f9de    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x143bc
 800f55c: 2300         	movs	r3, #0x0
 800f55e: 637b         	str	r3, [r7, #0x34]
; 	async_user_callback(data, &disabled_event);
 800f560: f107 0320    	add.w	r3, r7, #0x20
 800f564: 4619         	mov	r1, r3
 800f566: 6bf8         	ldr	r0, [r7, #0x3c]
 800f568: f014 fee9    	bl	0x802433e <async_user_callback> @ imm = #0x14dd2
; 	return 0;
 800f56c: 2300         	movs	r3, #0x0
; }
 800f56e: 4618         	mov	r0, r3
 800f570: 3748         	adds	r7, #0x48
 800f572: 46bd         	mov	sp, r7
 800f574: bd80         	pop	{r7, pc}
 800f576: bf00         	nop

0800f578 <$d>:
 800f578: ec 06 00 24  	.word	0x240006ec
 800f57c: b0 d8 02 08  	.word	0x0802d8b0
 800f580: a4 bf 02 08  	.word	0x0802bfa4

0800f584 <uart_stm32_dma_replace_buffer>:
; {
 800f584: b590         	push	{r4, r7, lr}
 800f586: b08f         	sub	sp, #0x3c
 800f588: af06         	add	r7, sp, #0x18
 800f58a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800f58c: 687b         	ldr	r3, [r7, #0x4]
 800f58e: 685b         	ldr	r3, [r3, #0x4]
 800f590: 61fb         	str	r3, [r7, #0x1c]
; 	USART_TypeDef *usart = config->usart;
 800f592: 69fb         	ldr	r3, [r7, #0x1c]
 800f594: 681b         	ldr	r3, [r3]
 800f596: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = dev->data;
 800f598: 687b         	ldr	r3, [r7, #0x4]
 800f59a: 691b         	ldr	r3, [r3, #0x10]
 800f59c: 617b         	str	r3, [r7, #0x14]
; 	LOG_DBG("Replacing RX buffer: %d", data->rx_next_buffer_len);
 800f59e: 2303         	movs	r3, #0x3
 800f5a0: 2b03         	cmp	r3, #0x3
 800f5a2: d91c         	bls	0x800f5de <uart_stm32_dma_replace_buffer+0x5a> @ imm = #0x38
 800f5a4: 2301         	movs	r3, #0x1
 800f5a6: 74fb         	strb	r3, [r7, #0x13]
 800f5a8: 7cfb         	ldrb	r3, [r7, #0x13]
 800f5aa: f083 0301    	eor	r3, r3, #0x1
 800f5ae: b2db         	uxtb	r3, r3
 800f5b0: 2b00         	cmp	r3, #0x0
 800f5b2: d114         	bne	0x800f5de <uart_stm32_dma_replace_buffer+0x5a> @ imm = #0x28
 800f5b4: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800f660 <uart_stm32_dma_replace_buffer+0xdc>
 800f5b6: 6819         	ldr	r1, [r3]
 800f5b8: 697b         	ldr	r3, [r7, #0x14]
 800f5ba: f8d3 3154    	ldr.w	r3, [r3, #0x154]
 800f5be: 9304         	str	r3, [sp, #0x10]
 800f5c0: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800f664 <uart_stm32_dma_replace_buffer+0xe0>
 800f5c2: 9303         	str	r3, [sp, #0xc]
 800f5c4: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800f668 <uart_stm32_dma_replace_buffer+0xe4>
 800f5c6: 9302         	str	r3, [sp, #0x8]
 800f5c8: 2308         	movs	r3, #0x8
 800f5ca: 9301         	str	r3, [sp, #0x4]
 800f5cc: 2300         	movs	r3, #0x0
 800f5ce: 9300         	str	r3, [sp]
 800f5d0: 2300         	movs	r3, #0x0
 800f5d2: 2204         	movs	r2, #0x4
 800f5d4: 2000         	movs	r0, #0x0
 800f5d6: f014 f99f    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x1433e
 800f5da: 2300         	movs	r3, #0x0
 800f5dc: 60fb         	str	r3, [r7, #0xc]
; 	data->dma_rx.offset = 0;
 800f5de: 697b         	ldr	r3, [r7, #0x14]
 800f5e0: 2200         	movs	r2, #0x0
 800f5e2: 675a         	str	r2, [r3, #0x74]
; 	data->dma_rx.counter = 0;
 800f5e4: 697b         	ldr	r3, [r7, #0x14]
 800f5e6: 2200         	movs	r2, #0x0
 800f5e8: 679a         	str	r2, [r3, #0x78]
; 	data->dma_rx.buffer = data->rx_next_buffer;
 800f5ea: 697b         	ldr	r3, [r7, #0x14]
 800f5ec: f8d3 2150    	ldr.w	r2, [r3, #0x150]
 800f5f0: 697b         	ldr	r3, [r7, #0x14]
 800f5f2: 66da         	str	r2, [r3, #0x6c]
; 	data->dma_rx.buffer_length = data->rx_next_buffer_len;
 800f5f4: 697b         	ldr	r3, [r7, #0x14]
 800f5f6: f8d3 2154    	ldr.w	r2, [r3, #0x154]
 800f5fa: 697b         	ldr	r3, [r7, #0x14]
 800f5fc: 671a         	str	r2, [r3, #0x70]
; 	data->dma_rx.blk_cfg.block_size = data->dma_rx.buffer_length;
 800f5fe: 697b         	ldr	r3, [r7, #0x14]
 800f600: 6f1a         	ldr	r2, [r3, #0x70]
 800f602: 697b         	ldr	r3, [r7, #0x14]
 800f604: 661a         	str	r2, [r3, #0x60]
; 	data->dma_rx.blk_cfg.dest_address = (uint32_t)data->dma_rx.buffer;
 800f606: 697b         	ldr	r3, [r7, #0x14]
 800f608: 6edb         	ldr	r3, [r3, #0x6c]
 800f60a: 461a         	mov	r2, r3
 800f60c: 697b         	ldr	r3, [r7, #0x14]
 800f60e: 651a         	str	r2, [r3, #0x50]
; 	data->rx_next_buffer = NULL;
 800f610: 697b         	ldr	r3, [r7, #0x14]
 800f612: 2200         	movs	r2, #0x0
 800f614: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800f618: 697b         	ldr	r3, [r7, #0x14]
 800f61a: 2200         	movs	r2, #0x0
 800f61c: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	dma_reload(data->dma_rx.dma_dev, data->dma_rx.dma_channel,
 800f620: 697b         	ldr	r3, [r7, #0x14]
 800f622: 6a18         	ldr	r0, [r3, #0x20]
 800f624: 697b         	ldr	r3, [r7, #0x14]
 800f626: 6a59         	ldr	r1, [r3, #0x24]
 800f628: 697b         	ldr	r3, [r7, #0x14]
 800f62a: 6cda         	ldr	r2, [r3, #0x4c]
 800f62c: 697b         	ldr	r3, [r7, #0x14]
 800f62e: 6d1c         	ldr	r4, [r3, #0x50]
 800f630: 697b         	ldr	r3, [r7, #0x14]
 800f632: 6e1b         	ldr	r3, [r3, #0x60]
 800f634: 9300         	str	r3, [sp]
 800f636: 4623         	mov	r3, r4
 800f638: f013 fb66    	bl	0x8022d08 <dma_reload>  @ imm = #0x136cc
; 	dma_start(data->dma_rx.dma_dev, data->dma_rx.dma_channel);
 800f63c: 697b         	ldr	r3, [r7, #0x14]
 800f63e: 6a1a         	ldr	r2, [r3, #0x20]
 800f640: 697b         	ldr	r3, [r7, #0x14]
 800f642: 6a5b         	ldr	r3, [r3, #0x24]
 800f644: 4619         	mov	r1, r3
 800f646: 4610         	mov	r0, r2
 800f648: f013 fbbc    	bl	0x8022dc4 <dma_start>   @ imm = #0x13778
; 	LL_USART_ClearFlag_IDLE(usart);
 800f64c: 69b8         	ldr	r0, [r7, #0x18]
 800f64e: f013 fee9    	bl	0x8023424 <LL_USART_ClearFlag_IDLE> @ imm = #0x13dd2
; 	async_evt_rx_buf_request(data);
 800f652: 6978         	ldr	r0, [r7, #0x14]
 800f654: f014 fe88    	bl	0x8024368 <async_evt_rx_buf_request> @ imm = #0x14d10
; }
 800f658: bf00         	nop
 800f65a: 3724         	adds	r7, #0x24
 800f65c: 46bd         	mov	sp, r7
 800f65e: bd90         	pop	{r4, r7, pc}

0800f660 <$d>:
 800f660: ec 06 00 24  	.word	0x240006ec
 800f664: cc d8 02 08  	.word	0x0802d8cc
 800f668: b8 bf 02 08  	.word	0x0802bfb8

0800f66c <uart_stm32_async_tx>:
; {
 800f66c: b580         	push	{r7, lr}
 800f66e: b094         	sub	sp, #0x50
 800f670: af06         	add	r7, sp, #0x18
 800f672: 60f8         	str	r0, [r7, #0xc]
 800f674: 60b9         	str	r1, [r7, #0x8]
 800f676: 607a         	str	r2, [r7, #0x4]
 800f678: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800f67a: 68fb         	ldr	r3, [r7, #0xc]
 800f67c: 685b         	ldr	r3, [r3, #0x4]
 800f67e: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 800f680: 6b7b         	ldr	r3, [r7, #0x34]
 800f682: 681b         	ldr	r3, [r3]
 800f684: 633b         	str	r3, [r7, #0x30]
; 	struct uart_stm32_data *data = dev->data;
 800f686: 68fb         	ldr	r3, [r7, #0xc]
 800f688: 691b         	ldr	r3, [r3, #0x10]
 800f68a: 62fb         	str	r3, [r7, #0x2c]
; 	if (data->dma_tx.dma_dev == NULL) {
 800f68c: 6afb         	ldr	r3, [r7, #0x2c]
 800f68e: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800f692: 2b00         	cmp	r3, #0x0
 800f694: d102         	bne	0x800f69c <uart_stm32_async_tx+0x30> @ imm = #0x4
; 		return -ENODEV;
 800f696: f06f 0312    	mvn	r3, #0x12
 800f69a: e0ac         	b	0x800f7f6 <uart_stm32_async_tx+0x18a> @ imm = #0x158
; 	if (data->dma_tx.buffer_length != 0) {
 800f69c: 6afb         	ldr	r3, [r7, #0x2c]
 800f69e: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 800f6a2: 2b00         	cmp	r3, #0x0
 800f6a4: d002         	beq	0x800f6ac <uart_stm32_async_tx+0x40> @ imm = #0x4
; 		return -EBUSY;
 800f6a6: f06f 030f    	mvn	r3, #0xf
 800f6aa: e0a4         	b	0x800f7f6 <uart_stm32_async_tx+0x18a> @ imm = #0x148
; 	data->dma_tx.buffer = (uint8_t *)tx_data;
 800f6ac: 6afb         	ldr	r3, [r7, #0x2c]
 800f6ae: 68ba         	ldr	r2, [r7, #0x8]
 800f6b0: f8c3 2104    	str.w	r2, [r3, #0x104]
; 	data->dma_tx.buffer_length = buf_size;
 800f6b4: 6afb         	ldr	r3, [r7, #0x2c]
 800f6b6: 687a         	ldr	r2, [r7, #0x4]
 800f6b8: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.timeout = timeout;
 800f6bc: 6afb         	ldr	r3, [r7, #0x2c]
 800f6be: 683a         	ldr	r2, [r7]
 800f6c0: f8c3 2114    	str.w	r2, [r3, #0x114]
; 	LOG_DBG("tx: l=%d", data->dma_tx.buffer_length);
 800f6c4: 2303         	movs	r3, #0x3
 800f6c6: 2b03         	cmp	r3, #0x3
 800f6c8: d91e         	bls	0x800f708 <uart_stm32_async_tx+0x9c> @ imm = #0x3c
 800f6ca: 2301         	movs	r3, #0x1
 800f6cc: f887 302b    	strb.w	r3, [r7, #0x2b]
 800f6d0: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800f6d4: f083 0301    	eor	r3, r3, #0x1
 800f6d8: b2db         	uxtb	r3, r3
 800f6da: 2b00         	cmp	r3, #0x0
 800f6dc: d114         	bne	0x800f708 <uart_stm32_async_tx+0x9c> @ imm = #0x28
 800f6de: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800f800 <uart_stm32_async_tx+0x194>
 800f6e0: 6819         	ldr	r1, [r3]
 800f6e2: 6afb         	ldr	r3, [r7, #0x2c]
 800f6e4: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 800f6e8: 9304         	str	r3, [sp, #0x10]
 800f6ea: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800f804 <uart_stm32_async_tx+0x198>
 800f6ec: 9303         	str	r3, [sp, #0xc]
 800f6ee: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800f808 <uart_stm32_async_tx+0x19c>
 800f6f0: 9302         	str	r3, [sp, #0x8]
 800f6f2: 2308         	movs	r3, #0x8
 800f6f4: 9301         	str	r3, [sp, #0x4]
 800f6f6: 2300         	movs	r3, #0x0
 800f6f8: 9300         	str	r3, [sp]
 800f6fa: 2300         	movs	r3, #0x0
 800f6fc: 2204         	movs	r2, #0x4
 800f6fe: 2000         	movs	r0, #0x0
 800f700: f014 f90a    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x14214
 800f704: 2300         	movs	r3, #0x0
 800f706: 627b         	str	r3, [r7, #0x24]
; 	LL_USART_ClearFlag_TC(usart);
 800f708: 6b38         	ldr	r0, [r7, #0x30]
 800f70a: f013 fe98    	bl	0x802343e <LL_USART_ClearFlag_TC> @ imm = #0x13d30
; 	LL_USART_EnableIT_TC(usart);
 800f70e: 6b38         	ldr	r0, [r7, #0x30]
 800f710: f013 fef2    	bl	0x80234f8 <LL_USART_EnableIT_TC> @ imm = #0x13de4
; 	data->dma_tx.blk_cfg.source_address = (uint32_t)data->dma_tx.buffer;
 800f714: 6afb         	ldr	r3, [r7, #0x2c]
 800f716: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 800f71a: 461a         	mov	r2, r3
 800f71c: 6afb         	ldr	r3, [r7, #0x2c]
 800f71e: f8c3 20e4    	str.w	r2, [r3, #0xe4]
; 	data->dma_tx.blk_cfg.block_size = data->dma_tx.buffer_length;
 800f722: 6afb         	ldr	r3, [r7, #0x2c]
 800f724: f8d3 2108    	ldr.w	r2, [r3, #0x108]
 800f728: 6afb         	ldr	r3, [r7, #0x2c]
 800f72a: f8c3 20f8    	str.w	r2, [r3, #0xf8]
; 	ret = dma_config(data->dma_tx.dma_dev, data->dma_tx.dma_channel,
 800f72e: 6afb         	ldr	r3, [r7, #0x2c]
 800f730: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 800f734: 6afb         	ldr	r3, [r7, #0x2c]
 800f736: f8d3 10bc    	ldr.w	r1, [r3, #0xbc]
 800f73a: 6afb         	ldr	r3, [r7, #0x2c]
 800f73c: 33c0         	adds	r3, #0xc0
 800f73e: 461a         	mov	r2, r3
 800f740: f013 face    	bl	0x8022ce0 <dma_config>  @ imm = #0x1359c
 800f744: 6238         	str	r0, [r7, #0x20]
; 	if (ret != 0) {
 800f746: 6a3b         	ldr	r3, [r7, #0x20]
 800f748: 2b00         	cmp	r3, #0x0
 800f74a: d01c         	beq	0x800f786 <uart_stm32_async_tx+0x11a> @ imm = #0x38
; 		LOG_ERR("dma tx config error!");
 800f74c: 2303         	movs	r3, #0x3
 800f74e: 2b00         	cmp	r3, #0x0
 800f750: d016         	beq	0x800f780 <uart_stm32_async_tx+0x114> @ imm = #0x2c
 800f752: 2301         	movs	r3, #0x1
 800f754: 75fb         	strb	r3, [r7, #0x17]
 800f756: 7dfb         	ldrb	r3, [r7, #0x17]
 800f758: f083 0301    	eor	r3, r3, #0x1
 800f75c: b2db         	uxtb	r3, r3
 800f75e: 2b00         	cmp	r3, #0x0
 800f760: d10e         	bne	0x800f780 <uart_stm32_async_tx+0x114> @ imm = #0x1c
 800f762: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800f800 <uart_stm32_async_tx+0x194>
 800f764: 6819         	ldr	r1, [r3]
 800f766: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800f80c <uart_stm32_async_tx+0x1a0>
 800f768: 9302         	str	r3, [sp, #0x8]
 800f76a: 2300         	movs	r3, #0x0
 800f76c: 9301         	str	r3, [sp, #0x4]
 800f76e: 2300         	movs	r3, #0x0
 800f770: 9300         	str	r3, [sp]
 800f772: 2300         	movs	r3, #0x0
 800f774: 2201         	movs	r2, #0x1
 800f776: 2000         	movs	r0, #0x0
 800f778: f014 f8ce    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x1419c
 800f77c: 2300         	movs	r3, #0x0
 800f77e: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 800f780: f06f 0315    	mvn	r3, #0x15
 800f784: e037         	b	0x800f7f6 <uart_stm32_async_tx+0x18a> @ imm = #0x6e
; 	if (dma_start(data->dma_tx.dma_dev, data->dma_tx.dma_channel)) {
 800f786: 6afb         	ldr	r3, [r7, #0x2c]
 800f788: f8d3 20b8    	ldr.w	r2, [r3, #0xb8]
 800f78c: 6afb         	ldr	r3, [r7, #0x2c]
 800f78e: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 800f792: 4619         	mov	r1, r3
 800f794: 4610         	mov	r0, r2
 800f796: f013 fb15    	bl	0x8022dc4 <dma_start>   @ imm = #0x1362a
 800f79a: 4603         	mov	r3, r0
 800f79c: 2b00         	cmp	r3, #0x0
 800f79e: d01c         	beq	0x800f7da <uart_stm32_async_tx+0x16e> @ imm = #0x38
; 		LOG_ERR("UART err: TX DMA start failed!");
 800f7a0: 2303         	movs	r3, #0x3
 800f7a2: 2b00         	cmp	r3, #0x0
 800f7a4: d016         	beq	0x800f7d4 <uart_stm32_async_tx+0x168> @ imm = #0x2c
 800f7a6: 2301         	movs	r3, #0x1
 800f7a8: 77fb         	strb	r3, [r7, #0x1f]
 800f7aa: 7ffb         	ldrb	r3, [r7, #0x1f]
 800f7ac: f083 0301    	eor	r3, r3, #0x1
 800f7b0: b2db         	uxtb	r3, r3
 800f7b2: 2b00         	cmp	r3, #0x0
 800f7b4: d10e         	bne	0x800f7d4 <uart_stm32_async_tx+0x168> @ imm = #0x1c
 800f7b6: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800f800 <uart_stm32_async_tx+0x194>
 800f7b8: 6819         	ldr	r1, [r3]
 800f7ba: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800f810 <uart_stm32_async_tx+0x1a4>
 800f7bc: 9302         	str	r3, [sp, #0x8]
 800f7be: 2300         	movs	r3, #0x0
 800f7c0: 9301         	str	r3, [sp, #0x4]
 800f7c2: 2300         	movs	r3, #0x0
 800f7c4: 9300         	str	r3, [sp]
 800f7c6: 2300         	movs	r3, #0x0
 800f7c8: 2201         	movs	r2, #0x1
 800f7ca: 2000         	movs	r0, #0x0
 800f7cc: f014 f8a4    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x14148
 800f7d0: 2300         	movs	r3, #0x0
 800f7d2: 61bb         	str	r3, [r7, #0x18]
; 		return -EFAULT;
 800f7d4: f06f 030d    	mvn	r3, #0xd
 800f7d8: e00d         	b	0x800f7f6 <uart_stm32_async_tx+0x18a> @ imm = #0x1a
; 	async_timer_start(&data->dma_tx.timeout_work, data->dma_tx.timeout);
 800f7da: 6afb         	ldr	r3, [r7, #0x2c]
 800f7dc: f503 728c    	add.w	r2, r3, #0x118
 800f7e0: 6afb         	ldr	r3, [r7, #0x2c]
 800f7e2: f8d3 3114    	ldr.w	r3, [r3, #0x114]
 800f7e6: 4619         	mov	r1, r3
 800f7e8: 4610         	mov	r0, r2
 800f7ea: f7ff fd63    	bl	0x800f2b4 <async_timer_start> @ imm = #-0x53a
; 	uart_stm32_dma_tx_enable(dev);
 800f7ee: 68f8         	ldr	r0, [r7, #0xc]
 800f7f0: f014 fe30    	bl	0x8024454 <uart_stm32_dma_tx_enable> @ imm = #0x14c60
; 	return 0;
 800f7f4: 2300         	movs	r3, #0x0
; }
 800f7f6: 4618         	mov	r0, r3
 800f7f8: 3738         	adds	r7, #0x38
 800f7fa: 46bd         	mov	sp, r7
 800f7fc: bd80         	pop	{r7, pc}
 800f7fe: bf00         	nop

0800f800 <$d>:
 800f800: ec 06 00 24  	.word	0x240006ec
 800f804: 00 d9 02 08  	.word	0x0802d900
 800f808: d4 bf 02 08  	.word	0x0802bfd4
 800f80c: e4 bf 02 08  	.word	0x0802bfe4
 800f810: fc bf 02 08  	.word	0x0802bffc

0800f814 <uart_stm32_async_rx_enable>:
; {
 800f814: b580         	push	{r7, lr}
 800f816: b094         	sub	sp, #0x50
 800f818: af04         	add	r7, sp, #0x10
 800f81a: 60f8         	str	r0, [r7, #0xc]
 800f81c: 60b9         	str	r1, [r7, #0x8]
 800f81e: 607a         	str	r2, [r7, #0x4]
 800f820: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800f822: 68fb         	ldr	r3, [r7, #0xc]
 800f824: 685b         	ldr	r3, [r3, #0x4]
 800f826: 63fb         	str	r3, [r7, #0x3c]
; 	USART_TypeDef *usart = config->usart;
 800f828: 6bfb         	ldr	r3, [r7, #0x3c]
 800f82a: 681b         	ldr	r3, [r3]
 800f82c: 63bb         	str	r3, [r7, #0x38]
; 	struct uart_stm32_data *data = dev->data;
 800f82e: 68fb         	ldr	r3, [r7, #0xc]
 800f830: 691b         	ldr	r3, [r3, #0x10]
 800f832: 637b         	str	r3, [r7, #0x34]
; 	if (data->dma_rx.dma_dev == NULL) {
 800f834: 6b7b         	ldr	r3, [r7, #0x34]
 800f836: 6a1b         	ldr	r3, [r3, #0x20]
 800f838: 2b00         	cmp	r3, #0x0
 800f83a: d102         	bne	0x800f842 <uart_stm32_async_rx_enable+0x2e> @ imm = #0x4
; 		return -ENODEV;
 800f83c: f06f 0312    	mvn	r3, #0x12
 800f840: e0c0         	b	0x800f9c4 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x180
; 	if (data->dma_rx.enabled) {
 800f842: 6b7b         	ldr	r3, [r7, #0x34]
 800f844: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 800f848: 2b00         	cmp	r3, #0x0
 800f84a: d01c         	beq	0x800f886 <uart_stm32_async_rx_enable+0x72> @ imm = #0x38
; 		LOG_WRN("RX was already enabled");
 800f84c: 2303         	movs	r3, #0x3
 800f84e: 2b01         	cmp	r3, #0x1
 800f850: d916         	bls	0x800f880 <uart_stm32_async_rx_enable+0x6c> @ imm = #0x2c
 800f852: 2301         	movs	r3, #0x1
 800f854: 75fb         	strb	r3, [r7, #0x17]
 800f856: 7dfb         	ldrb	r3, [r7, #0x17]
 800f858: f083 0301    	eor	r3, r3, #0x1
 800f85c: b2db         	uxtb	r3, r3
 800f85e: 2b00         	cmp	r3, #0x0
 800f860: d10e         	bne	0x800f880 <uart_stm32_async_rx_enable+0x6c> @ imm = #0x1c
 800f862: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x800f9cc <uart_stm32_async_rx_enable+0x1b8>
 800f864: 6819         	ldr	r1, [r3]
 800f866: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x800f9d0 <uart_stm32_async_rx_enable+0x1bc>
 800f868: 9302         	str	r3, [sp, #0x8]
 800f86a: 2300         	movs	r3, #0x0
 800f86c: 9301         	str	r3, [sp, #0x4]
 800f86e: 2300         	movs	r3, #0x0
 800f870: 9300         	str	r3, [sp]
 800f872: 2300         	movs	r3, #0x0
 800f874: 2202         	movs	r2, #0x2
 800f876: 2000         	movs	r0, #0x0
 800f878: f014 f84e    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x1409c
 800f87c: 2300         	movs	r3, #0x0
 800f87e: 613b         	str	r3, [r7, #0x10]
; 		return -EBUSY;
 800f880: f06f 030f    	mvn	r3, #0xf
 800f884: e09e         	b	0x800f9c4 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x13c
; 	data->dma_rx.offset = 0;
 800f886: 6b7b         	ldr	r3, [r7, #0x34]
 800f888: 2200         	movs	r2, #0x0
 800f88a: 675a         	str	r2, [r3, #0x74]
; 	data->dma_rx.buffer = rx_buf;
 800f88c: 6b7b         	ldr	r3, [r7, #0x34]
 800f88e: 68ba         	ldr	r2, [r7, #0x8]
 800f890: 66da         	str	r2, [r3, #0x6c]
; 	data->dma_rx.buffer_length = buf_size;
 800f892: 6b7b         	ldr	r3, [r7, #0x34]
 800f894: 687a         	ldr	r2, [r7, #0x4]
 800f896: 671a         	str	r2, [r3, #0x70]
; 	data->dma_rx.counter = 0;
 800f898: 6b7b         	ldr	r3, [r7, #0x34]
 800f89a: 2200         	movs	r2, #0x0
 800f89c: 679a         	str	r2, [r3, #0x78]
; 	data->dma_rx.timeout = timeout;
 800f89e: 6b7b         	ldr	r3, [r7, #0x34]
 800f8a0: 683a         	ldr	r2, [r7]
 800f8a2: 67da         	str	r2, [r3, #0x7c]
; 	LL_USART_DisableIT_RXNE(usart);
 800f8a4: 6bb8         	ldr	r0, [r7, #0x38]
 800f8a6: f013 febd    	bl	0x8023624 <LL_USART_DisableIT_RXNE_RXFNE> @ imm = #0x13d7a
; 	data->dma_rx.blk_cfg.block_size = buf_size;
 800f8aa: 6b7b         	ldr	r3, [r7, #0x34]
 800f8ac: 687a         	ldr	r2, [r7, #0x4]
 800f8ae: 661a         	str	r2, [r3, #0x60]
; 	data->dma_rx.blk_cfg.dest_address = (uint32_t)data->dma_rx.buffer;
 800f8b0: 6b7b         	ldr	r3, [r7, #0x34]
 800f8b2: 6edb         	ldr	r3, [r3, #0x6c]
 800f8b4: 461a         	mov	r2, r3
 800f8b6: 6b7b         	ldr	r3, [r7, #0x34]
 800f8b8: 651a         	str	r2, [r3, #0x50]
; 	ret = dma_config(data->dma_rx.dma_dev, data->dma_rx.dma_channel,
 800f8ba: 6b7b         	ldr	r3, [r7, #0x34]
 800f8bc: 6a18         	ldr	r0, [r3, #0x20]
 800f8be: 6b7b         	ldr	r3, [r7, #0x34]
 800f8c0: 6a59         	ldr	r1, [r3, #0x24]
 800f8c2: 6b7b         	ldr	r3, [r7, #0x34]
 800f8c4: 3328         	adds	r3, #0x28
 800f8c6: 461a         	mov	r2, r3
 800f8c8: f013 fa0a    	bl	0x8022ce0 <dma_config>  @ imm = #0x13414
 800f8cc: 6338         	str	r0, [r7, #0x30]
; 	if (ret != 0) {
 800f8ce: 6b3b         	ldr	r3, [r7, #0x30]
 800f8d0: 2b00         	cmp	r3, #0x0
 800f8d2: d01c         	beq	0x800f90e <uart_stm32_async_rx_enable+0xfa> @ imm = #0x38
; 		LOG_ERR("UART ERR: RX DMA config failed!");
 800f8d4: 2303         	movs	r3, #0x3
 800f8d6: 2b00         	cmp	r3, #0x0
 800f8d8: d016         	beq	0x800f908 <uart_stm32_async_rx_enable+0xf4> @ imm = #0x2c
 800f8da: 2301         	movs	r3, #0x1
 800f8dc: 77fb         	strb	r3, [r7, #0x1f]
 800f8de: 7ffb         	ldrb	r3, [r7, #0x1f]
 800f8e0: f083 0301    	eor	r3, r3, #0x1
 800f8e4: b2db         	uxtb	r3, r3
 800f8e6: 2b00         	cmp	r3, #0x0
 800f8e8: d10e         	bne	0x800f908 <uart_stm32_async_rx_enable+0xf4> @ imm = #0x1c
 800f8ea: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x800f9cc <uart_stm32_async_rx_enable+0x1b8>
 800f8ec: 6819         	ldr	r1, [r3]
 800f8ee: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800f9d4 <uart_stm32_async_rx_enable+0x1c0>
 800f8f0: 9302         	str	r3, [sp, #0x8]
 800f8f2: 2300         	movs	r3, #0x0
 800f8f4: 9301         	str	r3, [sp, #0x4]
 800f8f6: 2300         	movs	r3, #0x0
 800f8f8: 9300         	str	r3, [sp]
 800f8fa: 2300         	movs	r3, #0x0
 800f8fc: 2201         	movs	r2, #0x1
 800f8fe: 2000         	movs	r0, #0x0
 800f900: f014 f80a    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x14014
 800f904: 2300         	movs	r3, #0x0
 800f906: 61bb         	str	r3, [r7, #0x18]
; 		return -EINVAL;
 800f908: f06f 0315    	mvn	r3, #0x15
 800f90c: e05a         	b	0x800f9c4 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0xb4
; 	if (dma_start(data->dma_rx.dma_dev, data->dma_rx.dma_channel)) {
 800f90e: 6b7b         	ldr	r3, [r7, #0x34]
 800f910: 6a1a         	ldr	r2, [r3, #0x20]
 800f912: 6b7b         	ldr	r3, [r7, #0x34]
 800f914: 6a5b         	ldr	r3, [r3, #0x24]
 800f916: 4619         	mov	r1, r3
 800f918: 4610         	mov	r0, r2
 800f91a: f013 fa53    	bl	0x8022dc4 <dma_start>   @ imm = #0x134a6
 800f91e: 4603         	mov	r3, r0
 800f920: 2b00         	cmp	r3, #0x0
 800f922: d01e         	beq	0x800f962 <uart_stm32_async_rx_enable+0x14e> @ imm = #0x3c
; 		LOG_ERR("UART ERR: RX DMA start failed!");
 800f924: 2303         	movs	r3, #0x3
 800f926: 2b00         	cmp	r3, #0x0
 800f928: d018         	beq	0x800f95c <uart_stm32_async_rx_enable+0x148> @ imm = #0x30
 800f92a: 2301         	movs	r3, #0x1
 800f92c: f887 3027    	strb.w	r3, [r7, #0x27]
 800f930: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800f934: f083 0301    	eor	r3, r3, #0x1
 800f938: b2db         	uxtb	r3, r3
 800f93a: 2b00         	cmp	r3, #0x0
 800f93c: d10e         	bne	0x800f95c <uart_stm32_async_rx_enable+0x148> @ imm = #0x1c
 800f93e: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800f9cc <uart_stm32_async_rx_enable+0x1b8>
 800f940: 6819         	ldr	r1, [r3]
 800f942: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800f9d8 <uart_stm32_async_rx_enable+0x1c4>
 800f944: 9302         	str	r3, [sp, #0x8]
 800f946: 2300         	movs	r3, #0x0
 800f948: 9301         	str	r3, [sp, #0x4]
 800f94a: 2300         	movs	r3, #0x0
 800f94c: 9300         	str	r3, [sp]
 800f94e: 2300         	movs	r3, #0x0
 800f950: 2201         	movs	r2, #0x1
 800f952: 2000         	movs	r0, #0x0
 800f954: f013 ffe0    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x13fc0
 800f958: 2300         	movs	r3, #0x0
 800f95a: 623b         	str	r3, [r7, #0x20]
; 		return -EFAULT;
 800f95c: f06f 030d    	mvn	r3, #0xd
 800f960: e030         	b	0x800f9c4 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x60
; 	LL_USART_RequestRxDataFlush(usart);
 800f962: 6bb8         	ldr	r0, [r7, #0x38]
 800f964: f013 ffc8    	bl	0x80238f8 <LL_USART_RequestRxDataFlush> @ imm = #0x13f90
; 	uart_stm32_dma_rx_enable(dev);
 800f968: 68f8         	ldr	r0, [r7, #0xc]
 800f96a: f014 fd93    	bl	0x8024494 <uart_stm32_dma_rx_enable> @ imm = #0x14b26
; 	LL_USART_ClearFlag_IDLE(usart);
 800f96e: 6bb8         	ldr	r0, [r7, #0x38]
 800f970: f013 fd58    	bl	0x8023424 <LL_USART_ClearFlag_IDLE> @ imm = #0x13ab0
; 	LL_USART_EnableIT_IDLE(usart);
 800f974: 6bb8         	ldr	r0, [r7, #0x38]
 800f976: f013 fd7d    	bl	0x8023474 <LL_USART_EnableIT_IDLE> @ imm = #0x13afa
; 	LL_USART_EnableIT_ERROR(usart);
 800f97a: 6bb8         	ldr	r0, [r7, #0x38]
 800f97c: f013 fe0e    	bl	0x802359c <LL_USART_EnableIT_ERROR> @ imm = #0x13c1c
; 	async_evt_rx_buf_request(data);
 800f980: 6b78         	ldr	r0, [r7, #0x34]
 800f982: f014 fcf1    	bl	0x8024368 <async_evt_rx_buf_request> @ imm = #0x149e2
; 	LOG_DBG("async rx enabled");
 800f986: 2303         	movs	r3, #0x3
 800f988: 2b03         	cmp	r3, #0x3
 800f98a: d91a         	bls	0x800f9c2 <uart_stm32_async_rx_enable+0x1ae> @ imm = #0x34
 800f98c: 2301         	movs	r3, #0x1
 800f98e: f887 302f    	strb.w	r3, [r7, #0x2f]
 800f992: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800f996: f083 0301    	eor	r3, r3, #0x1
 800f99a: b2db         	uxtb	r3, r3
 800f99c: 2b00         	cmp	r3, #0x0
 800f99e: d110         	bne	0x800f9c2 <uart_stm32_async_rx_enable+0x1ae> @ imm = #0x20
 800f9a0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800f9cc <uart_stm32_async_rx_enable+0x1b8>
 800f9a2: 6819         	ldr	r1, [r3]
 800f9a4: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800f9dc <uart_stm32_async_rx_enable+0x1c8>
 800f9a6: 9303         	str	r3, [sp, #0xc]
 800f9a8: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800f9e0 <uart_stm32_async_rx_enable+0x1cc>
 800f9aa: 9302         	str	r3, [sp, #0x8]
 800f9ac: 2308         	movs	r3, #0x8
 800f9ae: 9301         	str	r3, [sp, #0x4]
 800f9b0: 2300         	movs	r3, #0x0
 800f9b2: 9300         	str	r3, [sp]
 800f9b4: 2300         	movs	r3, #0x0
 800f9b6: 2204         	movs	r2, #0x4
 800f9b8: 2000         	movs	r0, #0x0
 800f9ba: f013 ffad    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x13f5a
 800f9be: 2300         	movs	r3, #0x0
 800f9c0: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800f9c2: 6b3b         	ldr	r3, [r7, #0x30]
; }
 800f9c4: 4618         	mov	r0, r3
 800f9c6: 3740         	adds	r7, #0x40
 800f9c8: 46bd         	mov	sp, r7
 800f9ca: bd80         	pop	{r7, pc}

0800f9cc <$d>:
 800f9cc: ec 06 00 24  	.word	0x240006ec
 800f9d0: 1c c0 02 08  	.word	0x0802c01c
 800f9d4: 34 c0 02 08  	.word	0x0802c034
 800f9d8: 54 c0 02 08  	.word	0x0802c054
 800f9dc: 14 d9 02 08  	.word	0x0802d914
 800f9e0: 74 c0 02 08  	.word	0x0802c074

0800f9e4 <uart_stm32_async_rx_timeout>:
; {
 800f9e4: b580         	push	{r7, lr}
 800f9e6: b08c         	sub	sp, #0x30
 800f9e8: af04         	add	r7, sp, #0x10
 800f9ea: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 800f9ec: 6878         	ldr	r0, [r7, #0x4]
 800f9ee: f013 f93f    	bl	0x8022c70 <k_work_delayable_from_work> @ imm = #0x1327e
 800f9f2: 61f8         	str	r0, [r7, #0x1c]
; 	struct uart_dma_stream *rx_stream = CONTAINER_OF(dwork,
 800f9f4: 69fb         	ldr	r3, [r7, #0x1c]
 800f9f6: 3b60         	subs	r3, #0x60
 800f9f8: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = CONTAINER_OF(rx_stream,
 800f9fa: 69bb         	ldr	r3, [r7, #0x18]
 800f9fc: 3b20         	subs	r3, #0x20
 800f9fe: 617b         	str	r3, [r7, #0x14]
; 	const struct device *dev = data->uart_dev;
 800fa00: 697b         	ldr	r3, [r7, #0x14]
 800fa02: 691b         	ldr	r3, [r3, #0x10]
 800fa04: 613b         	str	r3, [r7, #0x10]
; 	LOG_DBG("rx timeout");
 800fa06: 2303         	movs	r3, #0x3
 800fa08: 2b03         	cmp	r3, #0x3
 800fa0a: d918         	bls	0x800fa3e <uart_stm32_async_rx_timeout+0x5a> @ imm = #0x30
 800fa0c: 2301         	movs	r3, #0x1
 800fa0e: 73fb         	strb	r3, [r7, #0xf]
 800fa10: 7bfb         	ldrb	r3, [r7, #0xf]
 800fa12: f083 0301    	eor	r3, r3, #0x1
 800fa16: b2db         	uxtb	r3, r3
 800fa18: 2b00         	cmp	r3, #0x0
 800fa1a: d110         	bne	0x800fa3e <uart_stm32_async_rx_timeout+0x5a> @ imm = #0x20
 800fa1c: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800fa60 <uart_stm32_async_rx_timeout+0x7c>
 800fa1e: 6819         	ldr	r1, [r3]
 800fa20: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800fa64 <uart_stm32_async_rx_timeout+0x80>
 800fa22: 9303         	str	r3, [sp, #0xc]
 800fa24: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800fa68 <uart_stm32_async_rx_timeout+0x84>
 800fa26: 9302         	str	r3, [sp, #0x8]
 800fa28: 2308         	movs	r3, #0x8
 800fa2a: 9301         	str	r3, [sp, #0x4]
 800fa2c: 2300         	movs	r3, #0x0
 800fa2e: 9300         	str	r3, [sp]
 800fa30: 2300         	movs	r3, #0x0
 800fa32: 2204         	movs	r2, #0x4
 800fa34: 2000         	movs	r0, #0x0
 800fa36: f013 ff6f    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x13ede
 800fa3a: 2300         	movs	r3, #0x0
 800fa3c: 60bb         	str	r3, [r7, #0x8]
; 	if (data->dma_rx.counter == data->dma_rx.buffer_length) {
 800fa3e: 697b         	ldr	r3, [r7, #0x14]
 800fa40: 6f9a         	ldr	r2, [r3, #0x78]
 800fa42: 697b         	ldr	r3, [r7, #0x14]
 800fa44: 6f1b         	ldr	r3, [r3, #0x70]
 800fa46: 429a         	cmp	r2, r3
 800fa48: d103         	bne	0x800fa52 <uart_stm32_async_rx_timeout+0x6e> @ imm = #0x6
; 		uart_stm32_async_rx_disable(dev);
 800fa4a: 6938         	ldr	r0, [r7, #0x10]
 800fa4c: f7ff fd04    	bl	0x800f458 <uart_stm32_async_rx_disable> @ imm = #-0x5f8
; }
 800fa50: e002         	b	0x800fa58 <uart_stm32_async_rx_timeout+0x74> @ imm = #0x4
; 		uart_stm32_dma_rx_flush(dev);
 800fa52: 6938         	ldr	r0, [r7, #0x10]
 800fa54: f014 fcbb    	bl	0x80243ce <uart_stm32_dma_rx_flush> @ imm = #0x14976
; }
 800fa58: bf00         	nop
 800fa5a: 3720         	adds	r7, #0x20
 800fa5c: 46bd         	mov	sp, r7
 800fa5e: bd80         	pop	{r7, pc}

0800fa60 <$d>:
 800fa60: ec 06 00 24  	.word	0x240006ec
 800fa64: 44 d9 02 08  	.word	0x0802d944
 800fa68: 8c c0 02 08  	.word	0x0802c08c

0800fa6c <uart_stm32_async_tx_timeout>:
; {
 800fa6c: b580         	push	{r7, lr}
 800fa6e: b08c         	sub	sp, #0x30
 800fa70: af04         	add	r7, sp, #0x10
 800fa72: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 800fa74: 6878         	ldr	r0, [r7, #0x4]
 800fa76: f013 f8fb    	bl	0x8022c70 <k_work_delayable_from_work> @ imm = #0x131f6
 800fa7a: 61f8         	str	r0, [r7, #0x1c]
; 	struct uart_dma_stream *tx_stream = CONTAINER_OF(dwork,
 800fa7c: 69fb         	ldr	r3, [r7, #0x1c]
 800fa7e: 3b60         	subs	r3, #0x60
 800fa80: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = CONTAINER_OF(tx_stream,
 800fa82: 69bb         	ldr	r3, [r7, #0x18]
 800fa84: 3bb8         	subs	r3, #0xb8
 800fa86: 617b         	str	r3, [r7, #0x14]
; 	const struct device *dev = data->uart_dev;
 800fa88: 697b         	ldr	r3, [r7, #0x14]
 800fa8a: 691b         	ldr	r3, [r3, #0x10]
 800fa8c: 613b         	str	r3, [r7, #0x10]
; 	uart_stm32_async_tx_abort(dev);
 800fa8e: 6938         	ldr	r0, [r7, #0x10]
 800fa90: f014 fdb0    	bl	0x80245f4 <uart_stm32_async_tx_abort> @ imm = #0x14b60
; 	LOG_DBG("tx: async timeout");
 800fa94: 2303         	movs	r3, #0x3
 800fa96: 2b03         	cmp	r3, #0x3
 800fa98: d919         	bls	0x800face <uart_stm32_async_tx_timeout+0x62> @ imm = #0x32
 800fa9a: 2301         	movs	r3, #0x1
 800fa9c: 73fb         	strb	r3, [r7, #0xf]
 800fa9e: 7bfb         	ldrb	r3, [r7, #0xf]
 800faa0: f083 0301    	eor	r3, r3, #0x1
 800faa4: b2db         	uxtb	r3, r3
 800faa6: 2b00         	cmp	r3, #0x0
 800faa8: d111         	bne	0x800face <uart_stm32_async_tx_timeout+0x62> @ imm = #0x22
 800faaa: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800fad8 <uart_stm32_async_tx_timeout+0x6c>
 800faac: 6819         	ldr	r1, [r3]
 800faae: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800fadc <uart_stm32_async_tx_timeout+0x70>
 800fab0: 9303         	str	r3, [sp, #0xc]
 800fab2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800fae0 <uart_stm32_async_tx_timeout+0x74>
 800fab4: 9302         	str	r3, [sp, #0x8]
 800fab6: 2308         	movs	r3, #0x8
 800fab8: 9301         	str	r3, [sp, #0x4]
 800faba: 2300         	movs	r3, #0x0
 800fabc: 9300         	str	r3, [sp]
 800fabe: 2300         	movs	r3, #0x0
 800fac0: 2204         	movs	r2, #0x4
 800fac2: 2000         	movs	r0, #0x0
 800fac4: f013 ff28    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x13e50
 800fac8: 2300         	movs	r3, #0x0
 800faca: 60bb         	str	r3, [r7, #0x8]
; }
 800facc: bf00         	nop
 800face: bf00         	nop
 800fad0: 3720         	adds	r7, #0x20
 800fad2: 46bd         	mov	sp, r7
 800fad4: bd80         	pop	{r7, pc}
 800fad6: bf00         	nop

0800fad8 <$d>:
 800fad8: ec 06 00 24  	.word	0x240006ec
 800fadc: 60 d9 02 08  	.word	0x0802d960
 800fae0: 9c c0 02 08  	.word	0x0802c09c

0800fae4 <uart_stm32_async_rx_buf_rsp>:
; {
 800fae4: b580         	push	{r7, lr}
 800fae6: b094         	sub	sp, #0x50
 800fae8: af06         	add	r7, sp, #0x18
 800faea: 60f8         	str	r0, [r7, #0xc]
 800faec: 60b9         	str	r1, [r7, #0x8]
 800faee: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800faf0: 68fb         	ldr	r3, [r7, #0xc]
 800faf2: 691b         	ldr	r3, [r3, #0x10]
 800faf4: 633b         	str	r3, [r7, #0x30]
; 	int err = 0;
 800faf6: 2300         	movs	r3, #0x0
 800faf8: 637b         	str	r3, [r7, #0x34]
; 	LOG_DBG("replace buffer (%d)", len);
 800fafa: 2303         	movs	r3, #0x3
 800fafc: 2b03         	cmp	r3, #0x3
 800fafe: d91c         	bls	0x800fb3a <uart_stm32_async_rx_buf_rsp+0x56> @ imm = #0x38
 800fb00: 2301         	movs	r3, #0x1
 800fb02: f887 302f    	strb.w	r3, [r7, #0x2f]
 800fb06: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800fb0a: f083 0301    	eor	r3, r3, #0x1
 800fb0e: b2db         	uxtb	r3, r3
 800fb10: 2b00         	cmp	r3, #0x0
 800fb12: d112         	bne	0x800fb3a <uart_stm32_async_rx_buf_rsp+0x56> @ imm = #0x24
 800fb14: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800fbb8 <uart_stm32_async_rx_buf_rsp+0xd4>
 800fb16: 6819         	ldr	r1, [r3]
 800fb18: 687b         	ldr	r3, [r7, #0x4]
 800fb1a: 9304         	str	r3, [sp, #0x10]
 800fb1c: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800fbbc <uart_stm32_async_rx_buf_rsp+0xd8>
 800fb1e: 9303         	str	r3, [sp, #0xc]
 800fb20: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800fbc0 <uart_stm32_async_rx_buf_rsp+0xdc>
 800fb22: 9302         	str	r3, [sp, #0x8]
 800fb24: 2308         	movs	r3, #0x8
 800fb26: 9301         	str	r3, [sp, #0x4]
 800fb28: 2300         	movs	r3, #0x0
 800fb2a: 9300         	str	r3, [sp]
 800fb2c: 2300         	movs	r3, #0x0
 800fb2e: 2204         	movs	r2, #0x4
 800fb30: 2000         	movs	r0, #0x0
 800fb32: f013 fef1    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x13de2
 800fb36: 2300         	movs	r3, #0x0
 800fb38: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fb3a: f3ef 8311    	mrs	r3, basepri
 800fb3e: 623b         	str	r3, [r7, #0x20]
;   return(result);
 800fb40: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 800fb42: 61fb         	str	r3, [r7, #0x1c]
 800fb44: 2310         	movs	r3, #0x10
 800fb46: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800fb48: 69bb         	ldr	r3, [r7, #0x18]
 800fb4a: f383 8812    	msr	basepri_max, r3
; }
 800fb4e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fb50: f3bf 8f6f    	isb	sy
; }
 800fb54: bf00         	nop
; 	return key;
 800fb56: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = irq_lock();
 800fb58: 627b         	str	r3, [r7, #0x24]
; 	if (data->rx_next_buffer != NULL) {
 800fb5a: 6b3b         	ldr	r3, [r7, #0x30]
 800fb5c: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 800fb60: 2b00         	cmp	r3, #0x0
 800fb62: d003         	beq	0x800fb6c <uart_stm32_async_rx_buf_rsp+0x88> @ imm = #0x6
; 		err = -EBUSY;
 800fb64: f06f 030f    	mvn	r3, #0xf
 800fb68: 637b         	str	r3, [r7, #0x34]
 800fb6a: e013         	b	0x800fb94 <uart_stm32_async_rx_buf_rsp+0xb0> @ imm = #0x26
; 	} else if (!data->dma_rx.enabled) {
 800fb6c: 6b3b         	ldr	r3, [r7, #0x30]
 800fb6e: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 800fb72: f083 0301    	eor	r3, r3, #0x1
 800fb76: b2db         	uxtb	r3, r3
 800fb78: 2b00         	cmp	r3, #0x0
 800fb7a: d003         	beq	0x800fb84 <uart_stm32_async_rx_buf_rsp+0xa0> @ imm = #0x6
; 		err = -EACCES;
 800fb7c: f06f 030c    	mvn	r3, #0xc
 800fb80: 637b         	str	r3, [r7, #0x34]
 800fb82: e007         	b	0x800fb94 <uart_stm32_async_rx_buf_rsp+0xb0> @ imm = #0xe
; 		data->rx_next_buffer = buf;
 800fb84: 6b3b         	ldr	r3, [r7, #0x30]
 800fb86: 68ba         	ldr	r2, [r7, #0x8]
 800fb88: f8c3 2150    	str.w	r2, [r3, #0x150]
; 		data->rx_next_buffer_len = len;
 800fb8c: 6b3b         	ldr	r3, [r7, #0x30]
 800fb8e: 687a         	ldr	r2, [r7, #0x4]
 800fb90: f8c3 2154    	str.w	r2, [r3, #0x154]
 800fb94: 6a7b         	ldr	r3, [r7, #0x24]
 800fb96: 617b         	str	r3, [r7, #0x14]
 800fb98: 697b         	ldr	r3, [r7, #0x14]
 800fb9a: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800fb9c: 693b         	ldr	r3, [r7, #0x10]
 800fb9e: f383 8811    	msr	basepri, r3
; }
 800fba2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fba4: f3bf 8f6f    	isb	sy
; }
 800fba8: bf00         	nop
; }
 800fbaa: bf00         	nop
; 	return err;
 800fbac: 6b7b         	ldr	r3, [r7, #0x34]
; }
 800fbae: 4618         	mov	r0, r3
 800fbb0: 3738         	adds	r7, #0x38
 800fbb2: 46bd         	mov	sp, r7
 800fbb4: bd80         	pop	{r7, pc}
 800fbb6: bf00         	nop

0800fbb8 <$d>:
 800fbb8: ec 06 00 24  	.word	0x240006ec
 800fbbc: 7c d9 02 08  	.word	0x0802d97c
 800fbc0: b4 c0 02 08  	.word	0x0802c0b4

0800fbc4 <uart_stm32_async_init>:
; {
 800fbc4: b580         	push	{r7, lr}
 800fbc6: b086         	sub	sp, #0x18
 800fbc8: af00         	add	r7, sp, #0x0
 800fbca: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800fbcc: 687b         	ldr	r3, [r7, #0x4]
 800fbce: 685b         	ldr	r3, [r3, #0x4]
 800fbd0: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 800fbd2: 697b         	ldr	r3, [r7, #0x14]
 800fbd4: 681b         	ldr	r3, [r3]
 800fbd6: 613b         	str	r3, [r7, #0x10]
; 	struct uart_stm32_data *data = dev->data;
 800fbd8: 687b         	ldr	r3, [r7, #0x4]
 800fbda: 691b         	ldr	r3, [r3, #0x10]
 800fbdc: 60fb         	str	r3, [r7, #0xc]
; 	data->uart_dev = dev;
 800fbde: 68fb         	ldr	r3, [r7, #0xc]
 800fbe0: 687a         	ldr	r2, [r7, #0x4]
 800fbe2: 611a         	str	r2, [r3, #0x10]
; 	if (data->dma_rx.dma_dev != NULL) {
 800fbe4: 68fb         	ldr	r3, [r7, #0xc]
 800fbe6: 6a1b         	ldr	r3, [r3, #0x20]
 800fbe8: 2b00         	cmp	r3, #0x0
 800fbea: d00d         	beq	0x800fc08 <uart_stm32_async_init+0x44> @ imm = #0x1a
; 		if (!device_is_ready(data->dma_rx.dma_dev)) {
 800fbec: 68fb         	ldr	r3, [r7, #0xc]
 800fbee: 6a1b         	ldr	r3, [r3, #0x20]
 800fbf0: 4618         	mov	r0, r3
 800fbf2: f013 f831    	bl	0x8022c58 <device_is_ready> @ imm = #0x13062
 800fbf6: 4603         	mov	r3, r0
 800fbf8: f083 0301    	eor	r3, r3, #0x1
 800fbfc: b2db         	uxtb	r3, r3
 800fbfe: 2b00         	cmp	r3, #0x0
 800fc00: d002         	beq	0x800fc08 <uart_stm32_async_init+0x44> @ imm = #0x4
; 			return -ENODEV;
 800fc02: f06f 0312    	mvn	r3, #0x12
 800fc06: e0e0         	b	0x800fdca <uart_stm32_async_init+0x206> @ imm = #0x1c0
; 	if (data->dma_tx.dma_dev != NULL) {
 800fc08: 68fb         	ldr	r3, [r7, #0xc]
 800fc0a: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800fc0e: 2b00         	cmp	r3, #0x0
 800fc10: d00e         	beq	0x800fc30 <uart_stm32_async_init+0x6c> @ imm = #0x1c
; 		if (!device_is_ready(data->dma_tx.dma_dev)) {
 800fc12: 68fb         	ldr	r3, [r7, #0xc]
 800fc14: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800fc18: 4618         	mov	r0, r3
 800fc1a: f013 f81d    	bl	0x8022c58 <device_is_ready> @ imm = #0x1303a
 800fc1e: 4603         	mov	r3, r0
 800fc20: f083 0301    	eor	r3, r3, #0x1
 800fc24: b2db         	uxtb	r3, r3
 800fc26: 2b00         	cmp	r3, #0x0
 800fc28: d002         	beq	0x800fc30 <uart_stm32_async_init+0x6c> @ imm = #0x4
; 			return -ENODEV;
 800fc2a: f06f 0312    	mvn	r3, #0x12
 800fc2e: e0cc         	b	0x800fdca <uart_stm32_async_init+0x206> @ imm = #0x198
; 	uart_stm32_dma_rx_disable(dev);
 800fc30: 6878         	ldr	r0, [r7, #0x4]
 800fc32: f014 fc46    	bl	0x80244c2 <uart_stm32_dma_rx_disable> @ imm = #0x1488c
; 	uart_stm32_dma_tx_disable(dev);
 800fc36: 6878         	ldr	r0, [r7, #0x4]
 800fc38: f014 fc1c    	bl	0x8024474 <uart_stm32_dma_tx_disable> @ imm = #0x14838
; 	k_work_init_delayable(&data->dma_rx.timeout_work,
 800fc3c: 68fb         	ldr	r3, [r7, #0xc]
 800fc3e: 3380         	adds	r3, #0x80
 800fc40: 4964         	ldr	r1, [pc, #0x190]        @ 0x800fdd4 <uart_stm32_async_init+0x210>
 800fc42: 4618         	mov	r0, r3
 800fc44: f018 f8d4    	bl	0x8027df0 <k_work_init_delayable> @ imm = #0x181a8
; 	k_work_init_delayable(&data->dma_tx.timeout_work,
 800fc48: 68fb         	ldr	r3, [r7, #0xc]
 800fc4a: f503 738c    	add.w	r3, r3, #0x118
 800fc4e: 4962         	ldr	r1, [pc, #0x188]        @ 0x800fdd8 <uart_stm32_async_init+0x214>
 800fc50: 4618         	mov	r0, r3
 800fc52: f018 f8cd    	bl	0x8027df0 <k_work_init_delayable> @ imm = #0x1819a
; 	memset(&data->dma_rx.blk_cfg, 0, sizeof(data->dma_rx.blk_cfg));
 800fc56: 68fb         	ldr	r3, [r7, #0xc]
 800fc58: 334c         	adds	r3, #0x4c
 800fc5a: 2220         	movs	r2, #0x20
 800fc5c: 2100         	movs	r1, #0x0
 800fc5e: 4618         	mov	r0, r3
 800fc60: f019 fa56    	bl	0x8029110 <memset>      @ imm = #0x194ac
; 				LL_USART_DMA_GetRegAddr(usart,
 800fc64: 2101         	movs	r1, #0x1
 800fc66: 6938         	ldr	r0, [r7, #0x10]
 800fc68: f013 fe14    	bl	0x8023894 <LL_USART_DMA_GetRegAddr> @ imm = #0x13c28
 800fc6c: 4602         	mov	r2, r0
; 	data->dma_rx.blk_cfg.source_address =
 800fc6e: 68fb         	ldr	r3, [r7, #0xc]
 800fc70: 64da         	str	r2, [r3, #0x4c]
; 	data->dma_rx.blk_cfg.dest_address = 0; /* dest not ready */
 800fc72: 68fb         	ldr	r3, [r7, #0xc]
 800fc74: 2200         	movs	r2, #0x0
 800fc76: 651a         	str	r2, [r3, #0x50]
; 	if (data->dma_rx.src_addr_increment) {
 800fc78: 68fb         	ldr	r3, [r7, #0xc]
 800fc7a: f893 3045    	ldrb.w	r3, [r3, #0x45]
 800fc7e: 2b00         	cmp	r3, #0x0
 800fc80: d007         	beq	0x800fc92 <uart_stm32_async_init+0xce> @ imm = #0xe
; 		data->dma_rx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800fc82: 68fa         	ldr	r2, [r7, #0xc]
 800fc84: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800fc88: f36f 0383    	bfc	r3, #2, #2
 800fc8c: f882 3068    	strb.w	r3, [r2, #0x68]
 800fc90: e007         	b	0x800fca2 <uart_stm32_async_init+0xde> @ imm = #0xe
; 		data->dma_rx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800fc92: 68fa         	ldr	r2, [r7, #0xc]
 800fc94: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800fc98: 2102         	movs	r1, #0x2
 800fc9a: f361 0383    	bfi	r3, r1, #2, #2
 800fc9e: f882 3068    	strb.w	r3, [r2, #0x68]
; 	if (data->dma_rx.dst_addr_increment) {
 800fca2: 68fb         	ldr	r3, [r7, #0xc]
 800fca4: f893 3046    	ldrb.w	r3, [r3, #0x46]
 800fca8: 2b00         	cmp	r3, #0x0
 800fcaa: d007         	beq	0x800fcbc <uart_stm32_async_init+0xf8> @ imm = #0xe
; 		data->dma_rx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800fcac: 68fa         	ldr	r2, [r7, #0xc]
 800fcae: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800fcb2: f36f 1305    	bfc	r3, #4, #2
 800fcb6: f882 3068    	strb.w	r3, [r2, #0x68]
 800fcba: e007         	b	0x800fccc <uart_stm32_async_init+0x108> @ imm = #0xe
; 		data->dma_rx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800fcbc: 68fa         	ldr	r2, [r7, #0xc]
 800fcbe: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800fcc2: 2102         	movs	r1, #0x2
 800fcc4: f361 1305    	bfi	r3, r1, #4, #2
 800fcc8: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.source_reload_en  = 0;
 800fccc: 68fa         	ldr	r2, [r7, #0xc]
 800fcce: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800fcd2: f36f 1386    	bfc	r3, #6, #1
 800fcd6: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.dest_reload_en = 0;
 800fcda: 68fa         	ldr	r2, [r7, #0xc]
 800fcdc: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800fce0: f36f 13c7    	bfc	r3, #7, #1
 800fce4: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.fifo_mode_control = data->dma_rx.fifo_threshold;
 800fce8: 68fb         	ldr	r3, [r7, #0xc]
 800fcea: 6c9b         	ldr	r3, [r3, #0x48]
 800fcec: f003 030f    	and	r3, r3, #0xf
 800fcf0: b2d9         	uxtb	r1, r3
 800fcf2: 68fa         	ldr	r2, [r7, #0xc]
 800fcf4: f892 3069    	ldrb.w	r3, [r2, #0x69]
 800fcf8: f361 0303    	bfi	r3, r1, #0, #4
 800fcfc: f882 3069    	strb.w	r3, [r2, #0x69]
; 	data->dma_rx.dma_cfg.head_block = &data->dma_rx.blk_cfg;
 800fd00: 68fb         	ldr	r3, [r7, #0xc]
 800fd02: f103 024c    	add.w	r2, r3, #0x4c
 800fd06: 68fb         	ldr	r3, [r7, #0xc]
 800fd08: 639a         	str	r2, [r3, #0x38]
; 	data->dma_rx.dma_cfg.user_data = (void *)dev;
 800fd0a: 68fb         	ldr	r3, [r7, #0xc]
 800fd0c: 687a         	ldr	r2, [r7, #0x4]
 800fd0e: 63da         	str	r2, [r3, #0x3c]
; 	data->rx_next_buffer = NULL;
 800fd10: 68fb         	ldr	r3, [r7, #0xc]
 800fd12: 2200         	movs	r2, #0x0
 800fd14: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800fd18: 68fb         	ldr	r3, [r7, #0xc]
 800fd1a: 2200         	movs	r2, #0x0
 800fd1c: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	memset(&data->dma_tx.blk_cfg, 0, sizeof(data->dma_tx.blk_cfg));
 800fd20: 68fb         	ldr	r3, [r7, #0xc]
 800fd22: 33e4         	adds	r3, #0xe4
 800fd24: 2220         	movs	r2, #0x20
 800fd26: 2100         	movs	r1, #0x0
 800fd28: 4618         	mov	r0, r3
 800fd2a: f019 f9f1    	bl	0x8029110 <memset>      @ imm = #0x193e2
; 			LL_USART_DMA_GetRegAddr(usart,
 800fd2e: 2100         	movs	r1, #0x0
 800fd30: 6938         	ldr	r0, [r7, #0x10]
 800fd32: f013 fdaf    	bl	0x8023894 <LL_USART_DMA_GetRegAddr> @ imm = #0x13b5e
 800fd36: 4602         	mov	r2, r0
; 	data->dma_tx.blk_cfg.dest_address =
 800fd38: 68fb         	ldr	r3, [r7, #0xc]
 800fd3a: f8c3 20e8    	str.w	r2, [r3, #0xe8]
; 	data->dma_tx.blk_cfg.source_address = 0; /* not ready */
 800fd3e: 68fb         	ldr	r3, [r7, #0xc]
 800fd40: 2200         	movs	r2, #0x0
 800fd42: f8c3 20e4    	str.w	r2, [r3, #0xe4]
; 	if (data->dma_tx.src_addr_increment) {
 800fd46: 68fb         	ldr	r3, [r7, #0xc]
 800fd48: f893 30dd    	ldrb.w	r3, [r3, #0xdd]
 800fd4c: 2b00         	cmp	r3, #0x0
 800fd4e: d007         	beq	0x800fd60 <uart_stm32_async_init+0x19c> @ imm = #0xe
; 		data->dma_tx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800fd50: 68fa         	ldr	r2, [r7, #0xc]
 800fd52: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800fd56: f36f 0383    	bfc	r3, #2, #2
 800fd5a: f882 3100    	strb.w	r3, [r2, #0x100]
 800fd5e: e007         	b	0x800fd70 <uart_stm32_async_init+0x1ac> @ imm = #0xe
; 		data->dma_tx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800fd60: 68fa         	ldr	r2, [r7, #0xc]
 800fd62: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800fd66: 2102         	movs	r1, #0x2
 800fd68: f361 0383    	bfi	r3, r1, #2, #2
 800fd6c: f882 3100    	strb.w	r3, [r2, #0x100]
; 	if (data->dma_tx.dst_addr_increment) {
 800fd70: 68fb         	ldr	r3, [r7, #0xc]
 800fd72: f893 30de    	ldrb.w	r3, [r3, #0xde]
 800fd76: 2b00         	cmp	r3, #0x0
 800fd78: d007         	beq	0x800fd8a <uart_stm32_async_init+0x1c6> @ imm = #0xe
; 		data->dma_tx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800fd7a: 68fa         	ldr	r2, [r7, #0xc]
 800fd7c: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800fd80: f36f 1305    	bfc	r3, #4, #2
 800fd84: f882 3100    	strb.w	r3, [r2, #0x100]
 800fd88: e007         	b	0x800fd9a <uart_stm32_async_init+0x1d6> @ imm = #0xe
; 		data->dma_tx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800fd8a: 68fa         	ldr	r2, [r7, #0xc]
 800fd8c: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800fd90: 2102         	movs	r1, #0x2
 800fd92: f361 1305    	bfi	r3, r1, #4, #2
 800fd96: f882 3100    	strb.w	r3, [r2, #0x100]
; 	data->dma_tx.blk_cfg.fifo_mode_control = data->dma_tx.fifo_threshold;
 800fd9a: 68fb         	ldr	r3, [r7, #0xc]
 800fd9c: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 800fda0: f003 030f    	and	r3, r3, #0xf
 800fda4: b2d9         	uxtb	r1, r3
 800fda6: 68fa         	ldr	r2, [r7, #0xc]
 800fda8: f892 3101    	ldrb.w	r3, [r2, #0x101]
 800fdac: f361 0303    	bfi	r3, r1, #0, #4
 800fdb0: f882 3101    	strb.w	r3, [r2, #0x101]
; 	data->dma_tx.dma_cfg.head_block = &data->dma_tx.blk_cfg;
 800fdb4: 68fb         	ldr	r3, [r7, #0xc]
 800fdb6: f103 02e4    	add.w	r2, r3, #0xe4
 800fdba: 68fb         	ldr	r3, [r7, #0xc]
 800fdbc: f8c3 20d0    	str.w	r2, [r3, #0xd0]
; 	data->dma_tx.dma_cfg.user_data = (void *)dev;
 800fdc0: 68fb         	ldr	r3, [r7, #0xc]
 800fdc2: 687a         	ldr	r2, [r7, #0x4]
 800fdc4: f8c3 20d4    	str.w	r2, [r3, #0xd4]
; 	return 0;
 800fdc8: 2300         	movs	r3, #0x0
; }
 800fdca: 4618         	mov	r0, r3
 800fdcc: 3718         	adds	r7, #0x18
 800fdce: 46bd         	mov	sp, r7
 800fdd0: bd80         	pop	{r7, pc}
 800fdd2: bf00         	nop

0800fdd4 <$d>:
 800fdd4: e5 f9 00 08  	.word	0x0800f9e5
 800fdd8: 6d fa 00 08  	.word	0x0800fa6d

0800fddc <uart_stm32_clocks_enable>:
; {
 800fddc: b580         	push	{r7, lr}
 800fdde: b08e         	sub	sp, #0x38
 800fde0: af04         	add	r7, sp, #0x10
 800fde2: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800fde4: 687b         	ldr	r3, [r7, #0x4]
 800fde6: 685b         	ldr	r3, [r3, #0x4]
 800fde8: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 800fdea: 687b         	ldr	r3, [r7, #0x4]
 800fdec: 691b         	ldr	r3, [r3, #0x10]
 800fdee: 627b         	str	r3, [r7, #0x24]
; 	__uart_stm32_get_clock(dev);
 800fdf0: 6878         	ldr	r0, [r7, #0x4]
 800fdf2: f7ff f821    	bl	0x800ee38 <__uart_stm32_get_clock> @ imm = #-0xfbe
; 	if (!device_is_ready(data->clock)) {
 800fdf6: 6a7b         	ldr	r3, [r7, #0x24]
 800fdf8: 681b         	ldr	r3, [r3]
 800fdfa: 4618         	mov	r0, r3
 800fdfc: f012 ff2c    	bl	0x8022c58 <device_is_ready> @ imm = #0x12e58
 800fe00: 4603         	mov	r3, r0
 800fe02: f083 0301    	eor	r3, r3, #0x1
 800fe06: b2db         	uxtb	r3, r3
 800fe08: 2b00         	cmp	r3, #0x0
 800fe0a: d01c         	beq	0x800fe46 <uart_stm32_clocks_enable+0x6a> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 800fe0c: 2303         	movs	r3, #0x3
 800fe0e: 2b00         	cmp	r3, #0x0
 800fe10: d016         	beq	0x800fe40 <uart_stm32_clocks_enable+0x64> @ imm = #0x2c
 800fe12: 2301         	movs	r3, #0x1
 800fe14: 74fb         	strb	r3, [r7, #0x13]
 800fe16: 7cfb         	ldrb	r3, [r7, #0x13]
 800fe18: f083 0301    	eor	r3, r3, #0x1
 800fe1c: b2db         	uxtb	r3, r3
 800fe1e: 2b00         	cmp	r3, #0x0
 800fe20: d10e         	bne	0x800fe40 <uart_stm32_clocks_enable+0x64> @ imm = #0x1c
 800fe22: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800fea0 <uart_stm32_clocks_enable+0xc4>
 800fe24: 6819         	ldr	r1, [r3]
 800fe26: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800fea4 <uart_stm32_clocks_enable+0xc8>
 800fe28: 9302         	str	r3, [sp, #0x8]
 800fe2a: 2300         	movs	r3, #0x0
 800fe2c: 9301         	str	r3, [sp, #0x4]
 800fe2e: 2300         	movs	r3, #0x0
 800fe30: 9300         	str	r3, [sp]
 800fe32: 2300         	movs	r3, #0x0
 800fe34: 2201         	movs	r2, #0x1
 800fe36: 2000         	movs	r0, #0x0
 800fe38: f013 fd6e    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x13adc
 800fe3c: 2300         	movs	r3, #0x0
 800fe3e: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800fe40: f06f 0312    	mvn	r3, #0x12
 800fe44: e028         	b	0x800fe98 <uart_stm32_clocks_enable+0xbc> @ imm = #0x50
; 	err = clock_control_on(data->clock, (clock_control_subsys_t)&config->pclken[0]);
 800fe46: 6a7b         	ldr	r3, [r7, #0x24]
 800fe48: 681a         	ldr	r2, [r3]
 800fe4a: 6a3b         	ldr	r3, [r7, #0x20]
 800fe4c: 68db         	ldr	r3, [r3, #0xc]
 800fe4e: 4619         	mov	r1, r3
 800fe50: 4610         	mov	r0, r2
 800fe52: f012 ff18    	bl	0x8022c86 <clock_control_on> @ imm = #0x12e30
 800fe56: 61f8         	str	r0, [r7, #0x1c]
; 	if (err != 0) {
 800fe58: 69fb         	ldr	r3, [r7, #0x1c]
 800fe5a: 2b00         	cmp	r3, #0x0
 800fe5c: d01b         	beq	0x800fe96 <uart_stm32_clocks_enable+0xba> @ imm = #0x36
; 		LOG_ERR("Could not enable (LP)UART clock");
 800fe5e: 2303         	movs	r3, #0x3
 800fe60: 2b00         	cmp	r3, #0x0
 800fe62: d016         	beq	0x800fe92 <uart_stm32_clocks_enable+0xb6> @ imm = #0x2c
 800fe64: 2301         	movs	r3, #0x1
 800fe66: 76fb         	strb	r3, [r7, #0x1b]
 800fe68: 7efb         	ldrb	r3, [r7, #0x1b]
 800fe6a: f083 0301    	eor	r3, r3, #0x1
 800fe6e: b2db         	uxtb	r3, r3
 800fe70: 2b00         	cmp	r3, #0x0
 800fe72: d10e         	bne	0x800fe92 <uart_stm32_clocks_enable+0xb6> @ imm = #0x1c
 800fe74: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800fea0 <uart_stm32_clocks_enable+0xc4>
 800fe76: 6819         	ldr	r1, [r3]
 800fe78: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800fea8 <uart_stm32_clocks_enable+0xcc>
 800fe7a: 9302         	str	r3, [sp, #0x8]
 800fe7c: 2300         	movs	r3, #0x0
 800fe7e: 9301         	str	r3, [sp, #0x4]
 800fe80: 2300         	movs	r3, #0x0
 800fe82: 9300         	str	r3, [sp]
 800fe84: 2300         	movs	r3, #0x0
 800fe86: 2201         	movs	r2, #0x1
 800fe88: 2000         	movs	r0, #0x0
 800fe8a: f013 fd45    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x13a8a
 800fe8e: 2300         	movs	r3, #0x0
 800fe90: 617b         	str	r3, [r7, #0x14]
; 		return err;
 800fe92: 69fb         	ldr	r3, [r7, #0x1c]
 800fe94: e000         	b	0x800fe98 <uart_stm32_clocks_enable+0xbc> @ imm = #0x0
; 	return 0;
 800fe96: 2300         	movs	r3, #0x0
; }
 800fe98: 4618         	mov	r0, r3
 800fe9a: 3728         	adds	r7, #0x28
 800fe9c: 46bd         	mov	sp, r7
 800fe9e: bd80         	pop	{r7, pc}

0800fea0 <$d>:
 800fea0: ec 06 00 24  	.word	0x240006ec
 800fea4: cc c0 02 08  	.word	0x0802c0cc
 800fea8: ec c0 02 08  	.word	0x0802c0ec

0800feac <uart_stm32_registers_configure>:
; {
 800feac: b580         	push	{r7, lr}
 800feae: b08e         	sub	sp, #0x38
 800feb0: af04         	add	r7, sp, #0x10
 800feb2: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800feb4: 687b         	ldr	r3, [r7, #0x4]
 800feb6: 685b         	ldr	r3, [r3, #0x4]
 800feb8: 627b         	str	r3, [r7, #0x24]
; 	USART_TypeDef *usart = config->usart;
 800feba: 6a7b         	ldr	r3, [r7, #0x24]
 800febc: 681b         	ldr	r3, [r3]
 800febe: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 800fec0: 687b         	ldr	r3, [r7, #0x4]
 800fec2: 691b         	ldr	r3, [r3, #0x10]
 800fec4: 61fb         	str	r3, [r7, #0x1c]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 800fec6: 69fb         	ldr	r3, [r7, #0x1c]
 800fec8: 685b         	ldr	r3, [r3, #0x4]
 800feca: 61bb         	str	r3, [r7, #0x18]
; 	LL_USART_Disable(usart);
 800fecc: 6a38         	ldr	r0, [r7, #0x20]
 800fece: f013 f80e    	bl	0x8022eee <LL_USART_Disable> @ imm = #0x1301c
; 	if (!device_is_ready(config->reset.dev)) {
 800fed2: 6a7b         	ldr	r3, [r7, #0x24]
 800fed4: 685b         	ldr	r3, [r3, #0x4]
 800fed6: 4618         	mov	r0, r3
 800fed8: f012 febe    	bl	0x8022c58 <device_is_ready> @ imm = #0x12d7c
 800fedc: 4603         	mov	r3, r0
 800fede: f083 0301    	eor	r3, r3, #0x1
 800fee2: b2db         	uxtb	r3, r3
 800fee4: 2b00         	cmp	r3, #0x0
 800fee6: d01c         	beq	0x800ff22 <uart_stm32_registers_configure+0x76> @ imm = #0x38
; 		LOG_ERR("reset controller not ready");
 800fee8: 2303         	movs	r3, #0x3
 800feea: 2b00         	cmp	r3, #0x0
 800feec: d016         	beq	0x800ff1c <uart_stm32_registers_configure+0x70> @ imm = #0x2c
 800feee: 2301         	movs	r3, #0x1
 800fef0: 73fb         	strb	r3, [r7, #0xf]
 800fef2: 7bfb         	ldrb	r3, [r7, #0xf]
 800fef4: f083 0301    	eor	r3, r3, #0x1
 800fef8: b2db         	uxtb	r3, r3
 800fefa: 2b00         	cmp	r3, #0x0
 800fefc: d10e         	bne	0x800ff1c <uart_stm32_registers_configure+0x70> @ imm = #0x1c
 800fefe: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x801008c <uart_stm32_registers_configure+0x1e0>
 800ff00: 6819         	ldr	r1, [r3]
 800ff02: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8010090 <uart_stm32_registers_configure+0x1e4>
 800ff04: 9302         	str	r3, [sp, #0x8]
 800ff06: 2300         	movs	r3, #0x0
 800ff08: 9301         	str	r3, [sp, #0x4]
 800ff0a: 2300         	movs	r3, #0x0
 800ff0c: 9300         	str	r3, [sp]
 800ff0e: 2300         	movs	r3, #0x0
 800ff10: 2201         	movs	r2, #0x1
 800ff12: 2000         	movs	r0, #0x0
 800ff14: f013 fd00    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x13a00
 800ff18: 2300         	movs	r3, #0x0
 800ff1a: 60bb         	str	r3, [r7, #0x8]
; 		return -ENODEV;
 800ff1c: f06f 0312    	mvn	r3, #0x12
 800ff20: e0b0         	b	0x8010084 <uart_stm32_registers_configure+0x1d8> @ imm = #0x160
; 	(void)reset_line_toggle_dt(&config->reset);
 800ff22: 6a7b         	ldr	r3, [r7, #0x24]
 800ff24: 3304         	adds	r3, #0x4
 800ff26: 4618         	mov	r0, r3
 800ff28: f012 ffb2    	bl	0x8022e90 <reset_line_toggle_dt> @ imm = #0x12f64
; 	LL_USART_SetTransferDirection(usart, LL_USART_DIRECTION_TX_RX);
 800ff2c: 210c         	movs	r1, #0xc
 800ff2e: 6a38         	ldr	r0, [r7, #0x20]
 800ff30: f012 fffd    	bl	0x8022f2e <LL_USART_SetTransferDirection> @ imm = #0x12ffa
; 	uart_stm32_parameters_set(dev, uart_cfg);
 800ff34: 69b9         	ldr	r1, [r7, #0x18]
 800ff36: 6878         	ldr	r0, [r7, #0x4]
 800ff38: f013 fead    	bl	0x8023c96 <uart_stm32_parameters_set> @ imm = #0x13d5a
; 	if (config->single_wire) {
 800ff3c: 6a7b         	ldr	r3, [r7, #0x24]
 800ff3e: 7d1b         	ldrb	r3, [r3, #0x14]
 800ff40: 2b00         	cmp	r3, #0x0
 800ff42: d002         	beq	0x800ff4a <uart_stm32_registers_configure+0x9e> @ imm = #0x4
; 		LL_USART_EnableHalfDuplex(usart);
 800ff44: 6a38         	ldr	r0, [r7, #0x20]
 800ff46: f013 f8e6    	bl	0x8023116 <LL_USART_EnableHalfDuplex> @ imm = #0x131cc
; 	if (config->tx_rx_swap) {
 800ff4a: 6a7b         	ldr	r3, [r7, #0x24]
 800ff4c: 7d5b         	ldrb	r3, [r3, #0x15]
 800ff4e: 2b00         	cmp	r3, #0x0
 800ff50: d004         	beq	0x800ff5c <uart_stm32_registers_configure+0xb0> @ imm = #0x8
; 		LL_USART_SetTXRXSwap(usart, LL_USART_TXRX_SWAPPED);
 800ff52: f44f 4100    	mov.w	r1, #0x8000
 800ff56: 6a38         	ldr	r0, [r7, #0x20]
 800ff58: f013 f883    	bl	0x8023062 <LL_USART_SetTXRXSwap> @ imm = #0x13106
; 	if (config->rx_invert) {
 800ff5c: 6a7b         	ldr	r3, [r7, #0x24]
 800ff5e: 7d9b         	ldrb	r3, [r3, #0x16]
 800ff60: 2b00         	cmp	r3, #0x0
 800ff62: d004         	beq	0x800ff6e <uart_stm32_registers_configure+0xc2> @ imm = #0x8
; 		LL_USART_SetRXPinLevel(usart, LL_USART_RXPIN_LEVEL_INVERTED);
 800ff64: f44f 3180    	mov.w	r1, #0x10000
 800ff68: 6a38         	ldr	r0, [r7, #0x20]
 800ff6a: f013 f88d    	bl	0x8023088 <LL_USART_SetRXPinLevel> @ imm = #0x1311a
; 	if (config->tx_invert) {
 800ff6e: 6a7b         	ldr	r3, [r7, #0x24]
 800ff70: 7ddb         	ldrb	r3, [r3, #0x17]
 800ff72: 2b00         	cmp	r3, #0x0
 800ff74: d004         	beq	0x800ff80 <uart_stm32_registers_configure+0xd4> @ imm = #0x8
; 		LL_USART_SetTXPinLevel(usart, LL_USART_TXPIN_LEVEL_INVERTED);
 800ff76: f44f 3100    	mov.w	r1, #0x20000
 800ff7a: 6a38         	ldr	r0, [r7, #0x20]
 800ff7c: f013 f897    	bl	0x80230ae <LL_USART_SetTXPinLevel> @ imm = #0x1312e
; 	if (config->de_enable) {
 800ff80: 6a7b         	ldr	r3, [r7, #0x24]
 800ff82: 7e1b         	ldrb	r3, [r3, #0x18]
 800ff84: 2b00         	cmp	r3, #0x0
 800ff86: d064         	beq	0x8010052 <uart_stm32_registers_configure+0x1a6> @ imm = #0xc8
; 		if (!IS_UART_DRIVER_ENABLE_INSTANCE(usart)) {
 800ff88: 6a3b         	ldr	r3, [r7, #0x20]
 800ff8a: 4a42         	ldr	r2, [pc, #0x108]        @ 0x8010094 <uart_stm32_registers_configure+0x1e8>
 800ff8c: 4293         	cmp	r3, r2
 800ff8e: d047         	beq	0x8010020 <uart_stm32_registers_configure+0x174> @ imm = #0x8e
 800ff90: 6a3b         	ldr	r3, [r7, #0x20]
 800ff92: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8010098 <uart_stm32_registers_configure+0x1ec>
 800ff94: 4293         	cmp	r3, r2
 800ff96: d043         	beq	0x8010020 <uart_stm32_registers_configure+0x174> @ imm = #0x86
 800ff98: 6a3b         	ldr	r3, [r7, #0x20]
 800ff9a: 4a40         	ldr	r2, [pc, #0x100]        @ 0x801009c <uart_stm32_registers_configure+0x1f0>
 800ff9c: 4293         	cmp	r3, r2
 800ff9e: d03f         	beq	0x8010020 <uart_stm32_registers_configure+0x174> @ imm = #0x7e
 800ffa0: 6a3b         	ldr	r3, [r7, #0x20]
 800ffa2: 4a3f         	ldr	r2, [pc, #0xfc]         @ 0x80100a0 <uart_stm32_registers_configure+0x1f4>
 800ffa4: 4293         	cmp	r3, r2
 800ffa6: d03b         	beq	0x8010020 <uart_stm32_registers_configure+0x174> @ imm = #0x76
 800ffa8: 6a3b         	ldr	r3, [r7, #0x20]
 800ffaa: 4a3e         	ldr	r2, [pc, #0xf8]         @ 0x80100a4 <uart_stm32_registers_configure+0x1f8>
 800ffac: 4293         	cmp	r3, r2
 800ffae: d037         	beq	0x8010020 <uart_stm32_registers_configure+0x174> @ imm = #0x6e
 800ffb0: 6a3b         	ldr	r3, [r7, #0x20]
 800ffb2: 4a3d         	ldr	r2, [pc, #0xf4]         @ 0x80100a8 <uart_stm32_registers_configure+0x1fc>
 800ffb4: 4293         	cmp	r3, r2
 800ffb6: d033         	beq	0x8010020 <uart_stm32_registers_configure+0x174> @ imm = #0x66
 800ffb8: 6a3b         	ldr	r3, [r7, #0x20]
 800ffba: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x80100ac <uart_stm32_registers_configure+0x200>
 800ffbc: 4293         	cmp	r3, r2
 800ffbe: d02f         	beq	0x8010020 <uart_stm32_registers_configure+0x174> @ imm = #0x5e
 800ffc0: 6a3b         	ldr	r3, [r7, #0x20]
 800ffc2: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x80100b0 <uart_stm32_registers_configure+0x204>
 800ffc4: 4293         	cmp	r3, r2
 800ffc6: d02b         	beq	0x8010020 <uart_stm32_registers_configure+0x174> @ imm = #0x56
 800ffc8: 6a3b         	ldr	r3, [r7, #0x20]
 800ffca: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x80100b4 <uart_stm32_registers_configure+0x208>
 800ffcc: 4293         	cmp	r3, r2
 800ffce: d027         	beq	0x8010020 <uart_stm32_registers_configure+0x174> @ imm = #0x4e
 800ffd0: 6a3b         	ldr	r3, [r7, #0x20]
 800ffd2: 4a39         	ldr	r2, [pc, #0xe4]         @ 0x80100b8 <uart_stm32_registers_configure+0x20c>
 800ffd4: 4293         	cmp	r3, r2
 800ffd6: d023         	beq	0x8010020 <uart_stm32_registers_configure+0x174> @ imm = #0x46
 800ffd8: 6a3b         	ldr	r3, [r7, #0x20]
 800ffda: 4a38         	ldr	r2, [pc, #0xe0]         @ 0x80100bc <uart_stm32_registers_configure+0x210>
 800ffdc: 4293         	cmp	r3, r2
 800ffde: d01f         	beq	0x8010020 <uart_stm32_registers_configure+0x174> @ imm = #0x3e
; 			LOG_ERR("%s does not support driver enable", dev->name);
 800ffe0: 2303         	movs	r3, #0x3
 800ffe2: 2b00         	cmp	r3, #0x0
 800ffe4: d019         	beq	0x801001a <uart_stm32_registers_configure+0x16e> @ imm = #0x32
 800ffe6: 2301         	movs	r3, #0x1
 800ffe8: 75fb         	strb	r3, [r7, #0x17]
 800ffea: 7dfb         	ldrb	r3, [r7, #0x17]
 800ffec: f083 0301    	eor	r3, r3, #0x1
 800fff0: b2db         	uxtb	r3, r3
 800fff2: 2b00         	cmp	r3, #0x0
 800fff4: d111         	bne	0x801001a <uart_stm32_registers_configure+0x16e> @ imm = #0x22
 800fff6: 4b25         	ldr	r3, [pc, #0x94]         @ 0x801008c <uart_stm32_registers_configure+0x1e0>
 800fff8: 6819         	ldr	r1, [r3]
 800fffa: 687b         	ldr	r3, [r7, #0x4]
 800fffc: 681b         	ldr	r3, [r3]
 800fffe: 9303         	str	r3, [sp, #0xc]
 8010000: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x80100c0 <uart_stm32_registers_configure+0x214>
 8010002: 9302         	str	r3, [sp, #0x8]
 8010004: 2300         	movs	r3, #0x0
 8010006: 9301         	str	r3, [sp, #0x4]
 8010008: 2300         	movs	r3, #0x0
 801000a: 9300         	str	r3, [sp]
 801000c: 2300         	movs	r3, #0x0
 801000e: 2201         	movs	r2, #0x1
 8010010: 2000         	movs	r0, #0x0
 8010012: f013 fc81    	bl	0x8023918 <z_log_msg_runtime_create> @ imm = #0x13902
 8010016: 2300         	movs	r3, #0x0
 8010018: 613b         	str	r3, [r7, #0x10]
; 			return -EINVAL;
 801001a: f06f 0315    	mvn	r3, #0x15
 801001e: e031         	b	0x8010084 <uart_stm32_registers_configure+0x1d8> @ imm = #0x62
; 		uart_stm32_set_driver_enable(dev, true);
 8010020: 2101         	movs	r1, #0x1
 8010022: 6878         	ldr	r0, [r7, #0x4]
 8010024: f013 fd22    	bl	0x8023a6c <uart_stm32_set_driver_enable> @ imm = #0x13a44
; 		LL_USART_SetDEAssertionTime(usart, config->de_assert_time);
 8010028: 6a7b         	ldr	r3, [r7, #0x24]
 801002a: 7e5b         	ldrb	r3, [r3, #0x19]
 801002c: 4619         	mov	r1, r3
 801002e: 6a38         	ldr	r0, [r7, #0x20]
 8010030: f013 f895    	bl	0x802315e <LL_USART_SetDEAssertionTime> @ imm = #0x1312a
; 		LL_USART_SetDEDeassertionTime(usart, config->de_deassert_time);
 8010034: 6a7b         	ldr	r3, [r7, #0x24]
 8010036: 7e9b         	ldrb	r3, [r3, #0x1a]
 8010038: 4619         	mov	r1, r3
 801003a: 6a38         	ldr	r0, [r7, #0x20]
 801003c: f013 f87b    	bl	0x8023136 <LL_USART_SetDEDeassertionTime> @ imm = #0x130f6
; 		if (config->de_invert) {
 8010040: 6a7b         	ldr	r3, [r7, #0x24]
 8010042: 7edb         	ldrb	r3, [r3, #0x1b]
 8010044: 2b00         	cmp	r3, #0x0
 8010046: d004         	beq	0x8010052 <uart_stm32_registers_configure+0x1a6> @ imm = #0x8
; 			LL_USART_SetDESignalPolarity(usart, LL_USART_DE_POLARITY_LOW);
 8010048: f44f 4100    	mov.w	r1, #0x8000
 801004c: 6a38         	ldr	r0, [r7, #0x20]
 801004e: f013 f8ce    	bl	0x80231ee <LL_USART_SetDESignalPolarity> @ imm = #0x1319c
; 	if (config->fifo_enable) {
 8010052: 6a7b         	ldr	r3, [r7, #0x24]
 8010054: 7f1b         	ldrb	r3, [r3, #0x1c]
 8010056: 2b00         	cmp	r3, #0x0
 8010058: d002         	beq	0x8010060 <uart_stm32_registers_configure+0x1b4> @ imm = #0x4
; 		LL_USART_EnableFIFO(usart);
 801005a: 6a38         	ldr	r0, [r7, #0x20]
 801005c: f012 ff57    	bl	0x8022f0e <LL_USART_EnableFIFO> @ imm = #0x12eae
; 	LL_USART_Enable(usart);
 8010060: 6a38         	ldr	r0, [r7, #0x20]
 8010062: f012 ff34    	bl	0x8022ece <LL_USART_Enable> @ imm = #0x12e68
; 	while (!(LL_USART_IsActiveFlag_TEACK(usart))) {
 8010066: bf00         	nop
 8010068: 6a38         	ldr	r0, [r7, #0x20]
 801006a: f013 f97f    	bl	0x802336c <LL_USART_IsActiveFlag_TEACK> @ imm = #0x132fe
 801006e: 4603         	mov	r3, r0
 8010070: 2b00         	cmp	r3, #0x0
 8010072: d0f9         	beq	0x8010068 <uart_stm32_registers_configure+0x1bc> @ imm = #-0xe
; 	while (!(LL_USART_IsActiveFlag_REACK(usart))) {
 8010074: bf00         	nop
 8010076: 6a38         	ldr	r0, [r7, #0x20]
 8010078: f013 f98c    	bl	0x8023394 <LL_USART_IsActiveFlag_REACK> @ imm = #0x13318
 801007c: 4603         	mov	r3, r0
 801007e: 2b00         	cmp	r3, #0x0
 8010080: d0f9         	beq	0x8010076 <uart_stm32_registers_configure+0x1ca> @ imm = #-0xe
; 	return 0;
 8010082: 2300         	movs	r3, #0x0
; }
 8010084: 4618         	mov	r0, r3
 8010086: 3728         	adds	r7, #0x28
 8010088: 46bd         	mov	sp, r7
 801008a: bd80         	pop	{r7, pc}

0801008c <$d>:
 801008c: ec 06 00 24  	.word	0x240006ec
 8010090: 0c c1 02 08  	.word	0x0802c10c
 8010094: 00 10 01 40  	.word	0x40011000
 8010098: 00 44 00 40  	.word	0x40004400
 801009c: 00 48 00 40  	.word	0x40004800
 80100a0: 00 4c 00 40  	.word	0x40004c00
 80100a4: 00 50 00 40  	.word	0x40005000
 80100a8: 00 14 01 40  	.word	0x40011400
 80100ac: 00 78 00 40  	.word	0x40007800
 80100b0: 00 7c 00 40  	.word	0x40007c00
 80100b4: 00 18 01 40  	.word	0x40011800
 80100b8: 00 1c 01 40  	.word	0x40011c00
 80100bc: 00 0c 00 58  	.word	0x58000c00
 80100c0: 28 c1 02 08  	.word	0x0802c128

080100c4 <LL_SPI_SetTransferSize>:
; {
 80100c4: b480         	push	{r7}
 80100c6: b083         	sub	sp, #0xc
 80100c8: af00         	add	r7, sp, #0x0
 80100ca: 6078         	str	r0, [r7, #0x4]
 80100cc: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR2, SPI_CR2_TSIZE, Count);
 80100ce: 687b         	ldr	r3, [r7, #0x4]
 80100d0: 685a         	ldr	r2, [r3, #0x4]
 80100d2: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80100ec <LL_SPI_SetTransferSize+0x28>
 80100d4: 4013         	ands	r3, r2
 80100d6: 683a         	ldr	r2, [r7]
 80100d8: 431a         	orrs	r2, r3
 80100da: 687b         	ldr	r3, [r7, #0x4]
 80100dc: 605a         	str	r2, [r3, #0x4]
; }
 80100de: bf00         	nop
 80100e0: 370c         	adds	r7, #0xc
 80100e2: 46bd         	mov	sp, r7
 80100e4: f85d 7b04    	ldr	r7, [sp], #4
 80100e8: 4770         	bx	lr
 80100ea: bf00         	nop

080100ec <$d>:
 80100ec: 00 00 ff ff  	.word	0xffff0000

080100f0 <spi_context_cs_configure_all>:
; {
 80100f0: b580         	push	{r7, lr}
 80100f2: b08c         	sub	sp, #0x30
 80100f4: af06         	add	r7, sp, #0x18
 80100f6: 6078         	str	r0, [r7, #0x4]
; 	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
 80100f8: 687b         	ldr	r3, [r7, #0x4]
 80100fa: 689b         	ldr	r3, [r3, #0x8]
 80100fc: 617b         	str	r3, [r7, #0x14]
 80100fe: e03c         	b	0x801017a <spi_context_cs_configure_all+0x8a> @ imm = #0x78
; 		if (!device_is_ready(cs_gpio->port)) {
 8010100: 697b         	ldr	r3, [r7, #0x14]
 8010102: 681b         	ldr	r3, [r3]
 8010104: 4618         	mov	r0, r3
 8010106: f014 fb1f    	bl	0x8024748 <device_is_ready> @ imm = #0x1463e
 801010a: 4603         	mov	r3, r0
 801010c: f083 0301    	eor	r3, r3, #0x1
 8010110: b2db         	uxtb	r3, r3
 8010112: 2b00         	cmp	r3, #0x0
 8010114: d023         	beq	0x801015e <spi_context_cs_configure_all+0x6e> @ imm = #0x46
; 			LOG_ERR("CS GPIO port %s pin %d is not ready",
 8010116: 2303         	movs	r3, #0x3
 8010118: 2b00         	cmp	r3, #0x0
 801011a: d01d         	beq	0x8010158 <spi_context_cs_configure_all+0x68> @ imm = #0x3a
 801011c: 2301         	movs	r3, #0x1
 801011e: 73fb         	strb	r3, [r7, #0xf]
 8010120: 7bfb         	ldrb	r3, [r7, #0xf]
 8010122: f083 0301    	eor	r3, r3, #0x1
 8010126: b2db         	uxtb	r3, r3
 8010128: 2b00         	cmp	r3, #0x0
 801012a: d115         	bne	0x8010158 <spi_context_cs_configure_all+0x68> @ imm = #0x2a
 801012c: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8010198 <spi_context_cs_configure_all+0xa8>
 801012e: 6819         	ldr	r1, [r3]
 8010130: 697b         	ldr	r3, [r7, #0x14]
 8010132: 681b         	ldr	r3, [r3]
 8010134: 681b         	ldr	r3, [r3]
 8010136: 697a         	ldr	r2, [r7, #0x14]
 8010138: 7912         	ldrb	r2, [r2, #0x4]
 801013a: 9204         	str	r2, [sp, #0x10]
 801013c: 9303         	str	r3, [sp, #0xc]
 801013e: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x801019c <spi_context_cs_configure_all+0xac>
 8010140: 9302         	str	r3, [sp, #0x8]
 8010142: 2300         	movs	r3, #0x0
 8010144: 9301         	str	r3, [sp, #0x4]
 8010146: 2300         	movs	r3, #0x0
 8010148: 9300         	str	r3, [sp]
 801014a: 2300         	movs	r3, #0x0
 801014c: 2201         	movs	r2, #0x1
 801014e: 2000         	movs	r0, #0x0
 8010150: f014 fb06    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x1460c
 8010154: 2300         	movs	r3, #0x0
 8010156: 60bb         	str	r3, [r7, #0x8]
; 			return -ENODEV;
 8010158: f06f 0312    	mvn	r3, #0x12
 801015c: e017         	b	0x801018e <spi_context_cs_configure_all+0x9e> @ imm = #0x2e
; 		ret = gpio_pin_configure_dt(cs_gpio, GPIO_OUTPUT_INACTIVE);
 801015e: f44f 11b0    	mov.w	r1, #0x160000
 8010162: 6978         	ldr	r0, [r7, #0x14]
 8010164: f014 fe3a    	bl	0x8024ddc <gpio_pin_configure_dt> @ imm = #0x14c74
 8010168: 6138         	str	r0, [r7, #0x10]
; 		if (ret < 0) {
 801016a: 693b         	ldr	r3, [r7, #0x10]
 801016c: 2b00         	cmp	r3, #0x0
 801016e: da01         	bge	0x8010174 <spi_context_cs_configure_all+0x84> @ imm = #0x2
; 			return ret;
 8010170: 693b         	ldr	r3, [r7, #0x10]
 8010172: e00c         	b	0x801018e <spi_context_cs_configure_all+0x9e> @ imm = #0x18
; 	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
 8010174: 697b         	ldr	r3, [r7, #0x14]
 8010176: 3308         	adds	r3, #0x8
 8010178: 617b         	str	r3, [r7, #0x14]
 801017a: 687b         	ldr	r3, [r7, #0x4]
 801017c: 689a         	ldr	r2, [r3, #0x8]
 801017e: 687b         	ldr	r3, [r7, #0x4]
 8010180: 68db         	ldr	r3, [r3, #0xc]
 8010182: 00db         	lsls	r3, r3, #0x3
 8010184: 4413         	add	r3, r2
 8010186: 697a         	ldr	r2, [r7, #0x14]
 8010188: 429a         	cmp	r2, r3
 801018a: d3b9         	blo	0x8010100 <spi_context_cs_configure_all+0x10> @ imm = #-0x8e
; 	return 0;
 801018c: 2300         	movs	r3, #0x0
; }
 801018e: 4618         	mov	r0, r3
 8010190: 3718         	adds	r7, #0x18
 8010192: 46bd         	mov	sp, r7
 8010194: bd80         	pop	{r7, pc}
 8010196: bf00         	nop

08010198 <$d>:
 8010198: 10 07 00 24  	.word	0x24000710
 801019c: 9c c1 02 08  	.word	0x0802c19c

080101a0 <spi_context_buffers_setup>:
; {
 80101a0: b5f0         	push	{r4, r5, r6, r7, lr}
 80101a2: b097         	sub	sp, #0x5c
 80101a4: af0c         	add	r7, sp, #0x30
 80101a6: 6178         	str	r0, [r7, #0x14]
 80101a8: 6139         	str	r1, [r7, #0x10]
 80101aa: 60fa         	str	r2, [r7, #0xc]
 80101ac: 72fb         	strb	r3, [r7, #0xb]
; 	LOG_DBG("tx_bufs %p - rx_bufs %p - %u", tx_bufs, rx_bufs, dfs);
 80101ae: 2303         	movs	r3, #0x3
 80101b0: 2b03         	cmp	r3, #0x3
 80101b2: d920         	bls	0x80101f6 <spi_context_buffers_setup+0x56> @ imm = #0x40
 80101b4: 2301         	movs	r3, #0x1
 80101b6: f887 3023    	strb.w	r3, [r7, #0x23]
 80101ba: f897 3023    	ldrb.w	r3, [r7, #0x23]
 80101be: f083 0301    	eor	r3, r3, #0x1
 80101c2: b2db         	uxtb	r3, r3
 80101c4: 2b00         	cmp	r3, #0x0
 80101c6: d116         	bne	0x80101f6 <spi_context_buffers_setup+0x56> @ imm = #0x2c
 80101c8: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8010304 <spi_context_buffers_setup+0x164>
 80101ca: 6819         	ldr	r1, [r3]
 80101cc: 7afb         	ldrb	r3, [r7, #0xb]
 80101ce: 9306         	str	r3, [sp, #0x18]
 80101d0: 68fb         	ldr	r3, [r7, #0xc]
 80101d2: 9305         	str	r3, [sp, #0x14]
 80101d4: 693b         	ldr	r3, [r7, #0x10]
 80101d6: 9304         	str	r3, [sp, #0x10]
 80101d8: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8010308 <spi_context_buffers_setup+0x168>
 80101da: 9303         	str	r3, [sp, #0xc]
 80101dc: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x801030c <spi_context_buffers_setup+0x16c>
 80101de: 9302         	str	r3, [sp, #0x8]
 80101e0: 2308         	movs	r3, #0x8
 80101e2: 9301         	str	r3, [sp, #0x4]
 80101e4: 2300         	movs	r3, #0x0
 80101e6: 9300         	str	r3, [sp]
 80101e8: 2300         	movs	r3, #0x0
 80101ea: 2204         	movs	r2, #0x4
 80101ec: 2000         	movs	r0, #0x0
 80101ee: f014 fab7    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x1456e
 80101f2: 2300         	movs	r3, #0x0
 80101f4: 627b         	str	r3, [r7, #0x24]
; 	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
 80101f6: 693b         	ldr	r3, [r7, #0x10]
 80101f8: 2b00         	cmp	r3, #0x0
 80101fa: d002         	beq	0x8010202 <spi_context_buffers_setup+0x62> @ imm = #0x4
 80101fc: 693b         	ldr	r3, [r7, #0x10]
 80101fe: 681b         	ldr	r3, [r3]
 8010200: e000         	b	0x8010204 <spi_context_buffers_setup+0x64> @ imm = #0x0
 8010202: 2300         	movs	r3, #0x0
 8010204: 697a         	ldr	r2, [r7, #0x14]
 8010206: 6353         	str	r3, [r2, #0x34]
; 	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
 8010208: 697b         	ldr	r3, [r7, #0x14]
 801020a: 6b5b         	ldr	r3, [r3, #0x34]
 801020c: 2b00         	cmp	r3, #0x0
 801020e: d002         	beq	0x8010216 <spi_context_buffers_setup+0x76> @ imm = #0x4
 8010210: 693b         	ldr	r3, [r7, #0x10]
 8010212: 685b         	ldr	r3, [r3, #0x4]
 8010214: e000         	b	0x8010218 <spi_context_buffers_setup+0x78> @ imm = #0x0
 8010216: 2300         	movs	r3, #0x0
 8010218: 697a         	ldr	r2, [r7, #0x14]
 801021a: 6393         	str	r3, [r2, #0x38]
; 		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
 801021c: 697b         	ldr	r3, [r7, #0x14]
 801021e: f103 0034    	add.w	r0, r3, #0x34
 8010222: 697b         	ldr	r3, [r7, #0x14]
 8010224: f103 0138    	add.w	r1, r3, #0x38
 8010228: 697b         	ldr	r3, [r7, #0x14]
 801022a: f103 0248    	add.w	r2, r3, #0x48
 801022e: 7afb         	ldrb	r3, [r7, #0xb]
 8010230: f014 fff8    	bl	0x8025224 <spi_context_get_next_buf> @ imm = #0x14ff0
 8010234: 4602         	mov	r2, r0
; 	ctx->tx_buf = (const uint8_t *)
 8010236: 697b         	ldr	r3, [r7, #0x14]
 8010238: 645a         	str	r2, [r3, #0x44]
; 	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
 801023a: 68fb         	ldr	r3, [r7, #0xc]
 801023c: 2b00         	cmp	r3, #0x0
 801023e: d002         	beq	0x8010246 <spi_context_buffers_setup+0xa6> @ imm = #0x4
 8010240: 68fb         	ldr	r3, [r7, #0xc]
 8010242: 681b         	ldr	r3, [r3]
 8010244: e000         	b	0x8010248 <spi_context_buffers_setup+0xa8> @ imm = #0x0
 8010246: 2300         	movs	r3, #0x0
 8010248: 697a         	ldr	r2, [r7, #0x14]
 801024a: 63d3         	str	r3, [r2, #0x3c]
; 	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
 801024c: 697b         	ldr	r3, [r7, #0x14]
 801024e: 6bdb         	ldr	r3, [r3, #0x3c]
 8010250: 2b00         	cmp	r3, #0x0
 8010252: d002         	beq	0x801025a <spi_context_buffers_setup+0xba> @ imm = #0x4
 8010254: 68fb         	ldr	r3, [r7, #0xc]
 8010256: 685b         	ldr	r3, [r3, #0x4]
 8010258: e000         	b	0x801025c <spi_context_buffers_setup+0xbc> @ imm = #0x0
 801025a: 2300         	movs	r3, #0x0
 801025c: 697a         	ldr	r2, [r7, #0x14]
 801025e: 6413         	str	r3, [r2, #0x40]
; 		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
 8010260: 697b         	ldr	r3, [r7, #0x14]
 8010262: f103 003c    	add.w	r0, r3, #0x3c
 8010266: 697b         	ldr	r3, [r7, #0x14]
 8010268: f103 0140    	add.w	r1, r3, #0x40
 801026c: 697b         	ldr	r3, [r7, #0x14]
 801026e: f103 0250    	add.w	r2, r3, #0x50
 8010272: 7afb         	ldrb	r3, [r7, #0xb]
 8010274: f014 ffd6    	bl	0x8025224 <spi_context_get_next_buf> @ imm = #0x14fac
 8010278: 4602         	mov	r2, r0
; 	ctx->rx_buf = (uint8_t *)
 801027a: 697b         	ldr	r3, [r7, #0x14]
 801027c: 64da         	str	r2, [r3, #0x4c]
; 	ctx->sync_status = 0;
 801027e: 697b         	ldr	r3, [r7, #0x14]
 8010280: 2200         	movs	r2, #0x0
 8010282: 631a         	str	r2, [r3, #0x30]
; 	LOG_DBG("current_tx %p (%zu), current_rx %p (%zu),"
 8010284: 2303         	movs	r3, #0x3
 8010286: 2b03         	cmp	r3, #0x3
 8010288: d937         	bls	0x80102fa <spi_context_buffers_setup+0x15a> @ imm = #0x6e
 801028a: 2301         	movs	r3, #0x1
 801028c: f887 3022    	strb.w	r3, [r7, #0x22]
 8010290: f897 3022    	ldrb.w	r3, [r7, #0x22]
 8010294: f083 0301    	eor	r3, r3, #0x1
 8010298: b2db         	uxtb	r3, r3
 801029a: 2b00         	cmp	r3, #0x0
 801029c: d12d         	bne	0x80102fa <spi_context_buffers_setup+0x15a> @ imm = #0x5a
 801029e: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8010304 <spi_context_buffers_setup+0x164>
 80102a0: 681b         	ldr	r3, [r3]
 80102a2: 607b         	str	r3, [r7, #0x4]
 80102a4: 697b         	ldr	r3, [r7, #0x14]
 80102a6: 6b5b         	ldr	r3, [r3, #0x34]
 80102a8: 697a         	ldr	r2, [r7, #0x14]
 80102aa: 6b92         	ldr	r2, [r2, #0x38]
 80102ac: 603a         	str	r2, [r7]
 80102ae: 6979         	ldr	r1, [r7, #0x14]
 80102b0: 6bc9         	ldr	r1, [r1, #0x3c]
 80102b2: 6978         	ldr	r0, [r7, #0x14]
 80102b4: 6c00         	ldr	r0, [r0, #0x40]
 80102b6: 697c         	ldr	r4, [r7, #0x14]
 80102b8: 6c64         	ldr	r4, [r4, #0x44]
 80102ba: 697d         	ldr	r5, [r7, #0x14]
 80102bc: 6cad         	ldr	r5, [r5, #0x48]
 80102be: 697e         	ldr	r6, [r7, #0x14]
 80102c0: 6cf6         	ldr	r6, [r6, #0x4c]
 80102c2: 697a         	ldr	r2, [r7, #0x14]
 80102c4: 6d12         	ldr	r2, [r2, #0x50]
 80102c6: 920b         	str	r2, [sp, #0x2c]
 80102c8: 960a         	str	r6, [sp, #0x28]
 80102ca: 9509         	str	r5, [sp, #0x24]
 80102cc: 9408         	str	r4, [sp, #0x20]
 80102ce: 9007         	str	r0, [sp, #0x1c]
 80102d0: 9106         	str	r1, [sp, #0x18]
 80102d2: 683a         	ldr	r2, [r7]
 80102d4: 9205         	str	r2, [sp, #0x14]
 80102d6: 9304         	str	r3, [sp, #0x10]
 80102d8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8010308 <spi_context_buffers_setup+0x168>
 80102da: 9303         	str	r3, [sp, #0xc]
 80102dc: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8010310 <spi_context_buffers_setup+0x170>
 80102de: 9302         	str	r3, [sp, #0x8]
 80102e0: 2308         	movs	r3, #0x8
 80102e2: 9301         	str	r3, [sp, #0x4]
 80102e4: 2300         	movs	r3, #0x0
 80102e6: 9300         	str	r3, [sp]
 80102e8: 2300         	movs	r3, #0x0
 80102ea: 2204         	movs	r2, #0x4
 80102ec: 6879         	ldr	r1, [r7, #0x4]
 80102ee: 2000         	movs	r0, #0x0
 80102f0: f014 fa36    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x1446c
 80102f4: 2300         	movs	r3, #0x0
 80102f6: 61fb         	str	r3, [r7, #0x1c]
; }
 80102f8: bf00         	nop
 80102fa: bf00         	nop
 80102fc: 372c         	adds	r7, #0x2c
 80102fe: 46bd         	mov	sp, r7
 8010300: bdf0         	pop	{r4, r5, r6, r7, pc}
 8010302: bf00         	nop

08010304 <$d>:
 8010304: 10 07 00 24  	.word	0x24000710
 8010308: 98 da 02 08  	.word	0x0802da98
 801030c: c0 c1 02 08  	.word	0x0802c1c0
 8010310: e4 c1 02 08  	.word	0x0802c1e4

08010314 <spi_stm32_send_next_frame>:
; {
 8010314: b580         	push	{r7, lr}
 8010316: b09c         	sub	sp, #0x70
 8010318: af06         	add	r7, sp, #0x18
 801031a: 6078         	str	r0, [r7, #0x4]
 801031c: 6039         	str	r1, [r7]
; 	const uint8_t frame_size = SPI_WORD_SIZE_GET(data->ctx.config->operation);
 801031e: 683b         	ldr	r3, [r7]
 8010320: 681b         	ldr	r3, [r3]
 8010322: 889b         	ldrh	r3, [r3, #0x4]
 8010324: 095b         	lsrs	r3, r3, #0x5
 8010326: b2db         	uxtb	r3, r3
 8010328: f003 033f    	and	r3, r3, #0x3f
 801032c: f887 3053    	strb.w	r3, [r7, #0x53]
; 	uint32_t tx_frame = SPI_STM32_TX_NOP;
 8010330: 2300         	movs	r3, #0x0
 8010332: 657b         	str	r3, [r7, #0x54]
; 	if (frame_size == 8) {
 8010334: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8010338: 2b08         	cmp	r3, #0x8
 801033a: f040 80a8    	bne.w	0x801048e <spi_stm32_send_next_frame+0x17a> @ imm = #0x150
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 801033e: 683b         	ldr	r3, [r7]
 8010340: 647b         	str	r3, [r7, #0x44]
; 	return !!(ctx->tx_buf && ctx->tx_len);
 8010342: 6c7b         	ldr	r3, [r7, #0x44]
 8010344: 6c5b         	ldr	r3, [r3, #0x44]
 8010346: 2b00         	cmp	r3, #0x0
 8010348: d005         	beq	0x8010356 <spi_stm32_send_next_frame+0x42> @ imm = #0xa
 801034a: 6c7b         	ldr	r3, [r7, #0x44]
 801034c: 6c9b         	ldr	r3, [r3, #0x48]
 801034e: 2b00         	cmp	r3, #0x0
 8010350: d001         	beq	0x8010356 <spi_stm32_send_next_frame+0x42> @ imm = #0x2
 8010352: 2301         	movs	r3, #0x1
 8010354: e000         	b	0x8010358 <spi_stm32_send_next_frame+0x44> @ imm = #0x0
 8010356: 2300         	movs	r3, #0x0
 8010358: f003 0301    	and	r3, r3, #0x1
 801035c: b2db         	uxtb	r3, r3
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 801035e: 2b00         	cmp	r3, #0x0
 8010360: d005         	beq	0x801036e <spi_stm32_send_next_frame+0x5a> @ imm = #0xa
; 			tx_frame = UNALIGNED_GET((uint8_t *)(data->ctx.tx_buf));
 8010362: 683b         	ldr	r3, [r7]
 8010364: 6c5b         	ldr	r3, [r3, #0x44]
 8010366: 64bb         	str	r3, [r7, #0x48]
 8010368: 6cbb         	ldr	r3, [r7, #0x48]
 801036a: 781b         	ldrb	r3, [r3]
 801036c: 657b         	str	r3, [r7, #0x54]
; 		LL_SPI_TransmitData8(spi, tx_frame);
 801036e: 6d7b         	ldr	r3, [r7, #0x54]
 8010370: b2db         	uxtb	r3, r3
 8010372: 4619         	mov	r1, r3
 8010374: 6878         	ldr	r0, [r7, #0x4]
 8010376: f014 fcc4    	bl	0x8024d02 <LL_SPI_TransmitData8> @ imm = #0x14988
; 		spi_context_update_tx(&data->ctx, 1, 1);
 801037a: 683b         	ldr	r3, [r7]
 801037c: 643b         	str	r3, [r7, #0x40]
 801037e: 2301         	movs	r3, #0x1
 8010380: f887 303f    	strb.w	r3, [r7, #0x3f]
 8010384: 2301         	movs	r3, #0x1
 8010386: 63bb         	str	r3, [r7, #0x38]
; 	if (!ctx->tx_len) {
 8010388: 6c3b         	ldr	r3, [r7, #0x40]
 801038a: 6c9b         	ldr	r3, [r3, #0x48]
 801038c: 2b00         	cmp	r3, #0x0
 801038e: f000 811d    	beq.w	0x80105cc <spi_stm32_send_next_frame+0x2b8> @ imm = #0x23a
; 	if (len > ctx->tx_len) {
 8010392: 6c3b         	ldr	r3, [r7, #0x40]
 8010394: 6c9b         	ldr	r3, [r3, #0x48]
 8010396: 6bba         	ldr	r2, [r7, #0x38]
 8010398: 429a         	cmp	r2, r3
 801039a: d91d         	bls	0x80103d8 <spi_stm32_send_next_frame+0xc4> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 801039c: 2303         	movs	r3, #0x3
 801039e: 2b00         	cmp	r3, #0x0
 80103a0: d019         	beq	0x80103d6 <spi_stm32_send_next_frame+0xc2> @ imm = #0x32
 80103a2: 2301         	movs	r3, #0x1
 80103a4: f887 3037    	strb.w	r3, [r7, #0x37]
 80103a8: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80103ac: f083 0301    	eor	r3, r3, #0x1
 80103b0: b2db         	uxtb	r3, r3
 80103b2: 2b00         	cmp	r3, #0x0
 80103b4: d10f         	bne	0x80103d6 <spi_stm32_send_next_frame+0xc2> @ imm = #0x1e
 80103b6: 4b89         	ldr	r3, [pc, #0x224]        @ 0x80105dc <spi_stm32_send_next_frame+0x2c8>
 80103b8: 6819         	ldr	r1, [r3]
 80103ba: 4b89         	ldr	r3, [pc, #0x224]        @ 0x80105e0 <spi_stm32_send_next_frame+0x2cc>
 80103bc: 9302         	str	r3, [sp, #0x8]
 80103be: 2300         	movs	r3, #0x0
 80103c0: 9301         	str	r3, [sp, #0x4]
 80103c2: 2300         	movs	r3, #0x0
 80103c4: 9300         	str	r3, [sp]
 80103c6: 2300         	movs	r3, #0x0
 80103c8: 2201         	movs	r2, #0x1
 80103ca: 2000         	movs	r0, #0x0
 80103cc: f014 f9c8    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x14390
 80103d0: 2300         	movs	r3, #0x0
 80103d2: 633b         	str	r3, [r7, #0x30]
; 		return;
 80103d4: e0fd         	b	0x80105d2 <spi_stm32_send_next_frame+0x2be> @ imm = #0x1fa
 80103d6: e0fc         	b	0x80105d2 <spi_stm32_send_next_frame+0x2be> @ imm = #0x1f8
; 	ctx->tx_len -= len;
 80103d8: 6c3b         	ldr	r3, [r7, #0x40]
 80103da: 6c9a         	ldr	r2, [r3, #0x48]
 80103dc: 6bbb         	ldr	r3, [r7, #0x38]
 80103de: 1ad2         	subs	r2, r2, r3
 80103e0: 6c3b         	ldr	r3, [r7, #0x40]
 80103e2: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 80103e4: 6c3b         	ldr	r3, [r7, #0x40]
 80103e6: 6c9b         	ldr	r3, [r3, #0x48]
 80103e8: 2b00         	cmp	r3, #0x0
 80103ea: d11b         	bne	0x8010424 <spi_stm32_send_next_frame+0x110> @ imm = #0x36
; 		++ctx->current_tx;
 80103ec: 6c3b         	ldr	r3, [r7, #0x40]
 80103ee: 6b5b         	ldr	r3, [r3, #0x34]
 80103f0: f103 0208    	add.w	r2, r3, #0x8
 80103f4: 6c3b         	ldr	r3, [r7, #0x40]
 80103f6: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 80103f8: 6c3b         	ldr	r3, [r7, #0x40]
 80103fa: 6b9b         	ldr	r3, [r3, #0x38]
 80103fc: 1e5a         	subs	r2, r3, #0x1
 80103fe: 6c3b         	ldr	r3, [r7, #0x40]
 8010400: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 8010402: 6c3b         	ldr	r3, [r7, #0x40]
 8010404: f103 0034    	add.w	r0, r3, #0x34
 8010408: 6c3b         	ldr	r3, [r7, #0x40]
 801040a: f103 0138    	add.w	r1, r3, #0x38
 801040e: 6c3b         	ldr	r3, [r7, #0x40]
 8010410: f103 0248    	add.w	r2, r3, #0x48
 8010414: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8010418: f014 ff04    	bl	0x8025224 <spi_context_get_next_buf> @ imm = #0x14e08
 801041c: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 801041e: 6c3b         	ldr	r3, [r7, #0x40]
 8010420: 645a         	str	r2, [r3, #0x44]
 8010422: e00d         	b	0x8010440 <spi_stm32_send_next_frame+0x12c> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 8010424: 6c3b         	ldr	r3, [r7, #0x40]
 8010426: 6c5b         	ldr	r3, [r3, #0x44]
 8010428: 2b00         	cmp	r3, #0x0
 801042a: d009         	beq	0x8010440 <spi_stm32_send_next_frame+0x12c> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 801042c: 6c3b         	ldr	r3, [r7, #0x40]
 801042e: 6c5a         	ldr	r2, [r3, #0x44]
 8010430: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8010434: 6bb9         	ldr	r1, [r7, #0x38]
 8010436: fb01 f303    	mul	r3, r1, r3
 801043a: 441a         	add	r2, r3
 801043c: 6c3b         	ldr	r3, [r7, #0x40]
 801043e: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 8010440: 2303         	movs	r3, #0x3
 8010442: 2b03         	cmp	r3, #0x3
 8010444: f240 80c5    	bls.w	0x80105d2 <spi_stm32_send_next_frame+0x2be> @ imm = #0x18a
 8010448: 2301         	movs	r3, #0x1
 801044a: f887 302f    	strb.w	r3, [r7, #0x2f]
 801044e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8010452: f083 0301    	eor	r3, r3, #0x1
 8010456: b2db         	uxtb	r3, r3
 8010458: 2b00         	cmp	r3, #0x0
 801045a: f040 80ba    	bne.w	0x80105d2 <spi_stm32_send_next_frame+0x2be> @ imm = #0x174
 801045e: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x80105dc <spi_stm32_send_next_frame+0x2c8>
 8010460: 6819         	ldr	r1, [r3]
 8010462: 6c3b         	ldr	r3, [r7, #0x40]
 8010464: 6c5b         	ldr	r3, [r3, #0x44]
 8010466: 6c3a         	ldr	r2, [r7, #0x40]
 8010468: 6c92         	ldr	r2, [r2, #0x48]
 801046a: 9205         	str	r2, [sp, #0x14]
 801046c: 9304         	str	r3, [sp, #0x10]
 801046e: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x80105e4 <spi_stm32_send_next_frame+0x2d0>
 8010470: 9303         	str	r3, [sp, #0xc]
 8010472: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x80105e8 <spi_stm32_send_next_frame+0x2d4>
 8010474: 9302         	str	r3, [sp, #0x8]
 8010476: 2308         	movs	r3, #0x8
 8010478: 9301         	str	r3, [sp, #0x4]
 801047a: 2300         	movs	r3, #0x0
 801047c: 9300         	str	r3, [sp]
 801047e: 2300         	movs	r3, #0x0
 8010480: 2204         	movs	r2, #0x4
 8010482: 2000         	movs	r0, #0x0
 8010484: f014 f96c    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x142d8
 8010488: 2300         	movs	r3, #0x0
 801048a: 62bb         	str	r3, [r7, #0x28]
; }
 801048c: e0a1         	b	0x80105d2 <spi_stm32_send_next_frame+0x2be> @ imm = #0x142
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 801048e: 683b         	ldr	r3, [r7]
 8010490: 627b         	str	r3, [r7, #0x24]
; 	return !!(ctx->tx_buf && ctx->tx_len);
 8010492: 6a7b         	ldr	r3, [r7, #0x24]
 8010494: 6c5b         	ldr	r3, [r3, #0x44]
 8010496: 2b00         	cmp	r3, #0x0
 8010498: d005         	beq	0x80104a6 <spi_stm32_send_next_frame+0x192> @ imm = #0xa
 801049a: 6a7b         	ldr	r3, [r7, #0x24]
 801049c: 6c9b         	ldr	r3, [r3, #0x48]
 801049e: 2b00         	cmp	r3, #0x0
 80104a0: d001         	beq	0x80104a6 <spi_stm32_send_next_frame+0x192> @ imm = #0x2
 80104a2: 2301         	movs	r3, #0x1
 80104a4: e000         	b	0x80104a8 <spi_stm32_send_next_frame+0x194> @ imm = #0x0
 80104a6: 2300         	movs	r3, #0x0
 80104a8: f003 0301    	and	r3, r3, #0x1
 80104ac: b2db         	uxtb	r3, r3
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 80104ae: 2b00         	cmp	r3, #0x0
 80104b0: d006         	beq	0x80104c0 <spi_stm32_send_next_frame+0x1ac> @ imm = #0xc
; 			tx_frame = UNALIGNED_GET((uint16_t *)(data->ctx.tx_buf));
 80104b2: 683b         	ldr	r3, [r7]
 80104b4: 6c5b         	ldr	r3, [r3, #0x44]
 80104b6: 64fb         	str	r3, [r7, #0x4c]
 80104b8: 6cfb         	ldr	r3, [r7, #0x4c]
 80104ba: 881b         	ldrh	r3, [r3]
 80104bc: b29b         	uxth	r3, r3
 80104be: 657b         	str	r3, [r7, #0x54]
; 		LL_SPI_TransmitData16(spi, tx_frame);
 80104c0: 6d7b         	ldr	r3, [r7, #0x54]
 80104c2: b29b         	uxth	r3, r3
 80104c4: 4619         	mov	r1, r3
 80104c6: 6878         	ldr	r0, [r7, #0x4]
 80104c8: f014 fc2b    	bl	0x8024d22 <LL_SPI_TransmitData16> @ imm = #0x14856
; 		spi_context_update_tx(&data->ctx, 2, 1);
 80104cc: 683b         	ldr	r3, [r7]
 80104ce: 623b         	str	r3, [r7, #0x20]
 80104d0: 2302         	movs	r3, #0x2
 80104d2: 77fb         	strb	r3, [r7, #0x1f]
 80104d4: 2301         	movs	r3, #0x1
 80104d6: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->tx_len) {
 80104d8: 6a3b         	ldr	r3, [r7, #0x20]
 80104da: 6c9b         	ldr	r3, [r3, #0x48]
 80104dc: 2b00         	cmp	r3, #0x0
 80104de: d077         	beq	0x80105d0 <spi_stm32_send_next_frame+0x2bc> @ imm = #0xee
; 	if (len > ctx->tx_len) {
 80104e0: 6a3b         	ldr	r3, [r7, #0x20]
 80104e2: 6c9b         	ldr	r3, [r3, #0x48]
 80104e4: 69ba         	ldr	r2, [r7, #0x18]
 80104e6: 429a         	cmp	r2, r3
 80104e8: d91b         	bls	0x8010522 <spi_stm32_send_next_frame+0x20e> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 80104ea: 2303         	movs	r3, #0x3
 80104ec: 2b00         	cmp	r3, #0x0
 80104ee: d017         	beq	0x8010520 <spi_stm32_send_next_frame+0x20c> @ imm = #0x2e
 80104f0: 2301         	movs	r3, #0x1
 80104f2: 75fb         	strb	r3, [r7, #0x17]
 80104f4: 7dfb         	ldrb	r3, [r7, #0x17]
 80104f6: f083 0301    	eor	r3, r3, #0x1
 80104fa: b2db         	uxtb	r3, r3
 80104fc: 2b00         	cmp	r3, #0x0
 80104fe: d10f         	bne	0x8010520 <spi_stm32_send_next_frame+0x20c> @ imm = #0x1e
 8010500: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80105dc <spi_stm32_send_next_frame+0x2c8>
 8010502: 6819         	ldr	r1, [r3]
 8010504: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80105e0 <spi_stm32_send_next_frame+0x2cc>
 8010506: 9302         	str	r3, [sp, #0x8]
 8010508: 2300         	movs	r3, #0x0
 801050a: 9301         	str	r3, [sp, #0x4]
 801050c: 2300         	movs	r3, #0x0
 801050e: 9300         	str	r3, [sp]
 8010510: 2300         	movs	r3, #0x0
 8010512: 2201         	movs	r2, #0x1
 8010514: 2000         	movs	r0, #0x0
 8010516: f014 f923    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x14246
 801051a: 2300         	movs	r3, #0x0
 801051c: 613b         	str	r3, [r7, #0x10]
; 		return;
 801051e: e058         	b	0x80105d2 <spi_stm32_send_next_frame+0x2be> @ imm = #0xb0
 8010520: e057         	b	0x80105d2 <spi_stm32_send_next_frame+0x2be> @ imm = #0xae
; 	ctx->tx_len -= len;
 8010522: 6a3b         	ldr	r3, [r7, #0x20]
 8010524: 6c9a         	ldr	r2, [r3, #0x48]
 8010526: 69bb         	ldr	r3, [r7, #0x18]
 8010528: 1ad2         	subs	r2, r2, r3
 801052a: 6a3b         	ldr	r3, [r7, #0x20]
 801052c: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 801052e: 6a3b         	ldr	r3, [r7, #0x20]
 8010530: 6c9b         	ldr	r3, [r3, #0x48]
 8010532: 2b00         	cmp	r3, #0x0
 8010534: d11a         	bne	0x801056c <spi_stm32_send_next_frame+0x258> @ imm = #0x34
; 		++ctx->current_tx;
 8010536: 6a3b         	ldr	r3, [r7, #0x20]
 8010538: 6b5b         	ldr	r3, [r3, #0x34]
 801053a: f103 0208    	add.w	r2, r3, #0x8
 801053e: 6a3b         	ldr	r3, [r7, #0x20]
 8010540: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 8010542: 6a3b         	ldr	r3, [r7, #0x20]
 8010544: 6b9b         	ldr	r3, [r3, #0x38]
 8010546: 1e5a         	subs	r2, r3, #0x1
 8010548: 6a3b         	ldr	r3, [r7, #0x20]
 801054a: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 801054c: 6a3b         	ldr	r3, [r7, #0x20]
 801054e: f103 0034    	add.w	r0, r3, #0x34
 8010552: 6a3b         	ldr	r3, [r7, #0x20]
 8010554: f103 0138    	add.w	r1, r3, #0x38
 8010558: 6a3b         	ldr	r3, [r7, #0x20]
 801055a: f103 0248    	add.w	r2, r3, #0x48
 801055e: 7ffb         	ldrb	r3, [r7, #0x1f]
 8010560: f014 fe60    	bl	0x8025224 <spi_context_get_next_buf> @ imm = #0x14cc0
 8010564: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 8010566: 6a3b         	ldr	r3, [r7, #0x20]
 8010568: 645a         	str	r2, [r3, #0x44]
 801056a: e00c         	b	0x8010586 <spi_stm32_send_next_frame+0x272> @ imm = #0x18
; 	} else if (ctx->tx_buf) {
 801056c: 6a3b         	ldr	r3, [r7, #0x20]
 801056e: 6c5b         	ldr	r3, [r3, #0x44]
 8010570: 2b00         	cmp	r3, #0x0
 8010572: d008         	beq	0x8010586 <spi_stm32_send_next_frame+0x272> @ imm = #0x10
; 		ctx->tx_buf += dfs * len;
 8010574: 6a3b         	ldr	r3, [r7, #0x20]
 8010576: 6c5a         	ldr	r2, [r3, #0x44]
 8010578: 7ffb         	ldrb	r3, [r7, #0x1f]
 801057a: 69b9         	ldr	r1, [r7, #0x18]
 801057c: fb01 f303    	mul	r3, r1, r3
 8010580: 441a         	add	r2, r3
 8010582: 6a3b         	ldr	r3, [r7, #0x20]
 8010584: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 8010586: 2303         	movs	r3, #0x3
 8010588: 2b03         	cmp	r3, #0x3
 801058a: d922         	bls	0x80105d2 <spi_stm32_send_next_frame+0x2be> @ imm = #0x44
 801058c: 2301         	movs	r3, #0x1
 801058e: 73fb         	strb	r3, [r7, #0xf]
 8010590: 7bfb         	ldrb	r3, [r7, #0xf]
 8010592: f083 0301    	eor	r3, r3, #0x1
 8010596: b2db         	uxtb	r3, r3
 8010598: 2b00         	cmp	r3, #0x0
 801059a: d11a         	bne	0x80105d2 <spi_stm32_send_next_frame+0x2be> @ imm = #0x34
 801059c: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80105dc <spi_stm32_send_next_frame+0x2c8>
 801059e: 6819         	ldr	r1, [r3]
 80105a0: 6a3b         	ldr	r3, [r7, #0x20]
 80105a2: 6c5b         	ldr	r3, [r3, #0x44]
 80105a4: 6a3a         	ldr	r2, [r7, #0x20]
 80105a6: 6c92         	ldr	r2, [r2, #0x48]
 80105a8: 9205         	str	r2, [sp, #0x14]
 80105aa: 9304         	str	r3, [sp, #0x10]
 80105ac: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80105e4 <spi_stm32_send_next_frame+0x2d0>
 80105ae: 9303         	str	r3, [sp, #0xc]
 80105b0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80105e8 <spi_stm32_send_next_frame+0x2d4>
 80105b2: 9302         	str	r3, [sp, #0x8]
 80105b4: 2308         	movs	r3, #0x8
 80105b6: 9301         	str	r3, [sp, #0x4]
 80105b8: 2300         	movs	r3, #0x0
 80105ba: 9300         	str	r3, [sp]
 80105bc: 2300         	movs	r3, #0x0
 80105be: 2204         	movs	r2, #0x4
 80105c0: 2000         	movs	r0, #0x0
 80105c2: f014 f8cd    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x1419a
 80105c6: 2300         	movs	r3, #0x0
 80105c8: 60bb         	str	r3, [r7, #0x8]
; }
 80105ca: e002         	b	0x80105d2 <spi_stm32_send_next_frame+0x2be> @ imm = #0x4
; 		return;
 80105cc: bf00         	nop
 80105ce: e000         	b	0x80105d2 <spi_stm32_send_next_frame+0x2be> @ imm = #0x0
 80105d0: bf00         	nop
; }
 80105d2: bf00         	nop
 80105d4: 3758         	adds	r7, #0x58
 80105d6: 46bd         	mov	sp, r7
 80105d8: bd80         	pop	{r7, pc}
 80105da: bf00         	nop

080105dc <$d>:
 80105dc: 10 07 00 24  	.word	0x24000710
 80105e0: 38 c2 02 08  	.word	0x0802c238
 80105e4: 40 da 02 08  	.word	0x0802da40
 80105e8: 58 c2 02 08  	.word	0x0802c258

080105ec <spi_stm32_read_next_frame>:
; {
 80105ec: b580         	push	{r7, lr}
 80105ee: b09c         	sub	sp, #0x70
 80105f0: af06         	add	r7, sp, #0x18
 80105f2: 6078         	str	r0, [r7, #0x4]
 80105f4: 6039         	str	r1, [r7]
; 	const uint8_t frame_size = SPI_WORD_SIZE_GET(data->ctx.config->operation);
 80105f6: 683b         	ldr	r3, [r7]
 80105f8: 681b         	ldr	r3, [r3]
 80105fa: 889b         	ldrh	r3, [r3, #0x4]
 80105fc: 095b         	lsrs	r3, r3, #0x5
 80105fe: b2db         	uxtb	r3, r3
 8010600: f003 033f    	and	r3, r3, #0x3f
 8010604: f887 3057    	strb.w	r3, [r7, #0x57]
; 	uint32_t rx_frame = 0;
 8010608: 2300         	movs	r3, #0x0
 801060a: 653b         	str	r3, [r7, #0x50]
; 	if (frame_size == 8) {
 801060c: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8010610: 2b08         	cmp	r3, #0x8
 8010612: f040 80a8    	bne.w	0x8010766 <spi_stm32_read_next_frame+0x17a> @ imm = #0x150
; 		rx_frame = LL_SPI_ReceiveData8(spi);
 8010616: 6878         	ldr	r0, [r7, #0x4]
 8010618: f014 fb55    	bl	0x8024cc6 <LL_SPI_ReceiveData8> @ imm = #0x146aa
 801061c: 4603         	mov	r3, r0
 801061e: 653b         	str	r3, [r7, #0x50]
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 8010620: 683b         	ldr	r3, [r7]
 8010622: 647b         	str	r3, [r7, #0x44]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 8010624: 6c7b         	ldr	r3, [r7, #0x44]
 8010626: 6cdb         	ldr	r3, [r3, #0x4c]
 8010628: 2b00         	cmp	r3, #0x0
 801062a: d005         	beq	0x8010638 <spi_stm32_read_next_frame+0x4c> @ imm = #0xa
 801062c: 6c7b         	ldr	r3, [r7, #0x44]
 801062e: 6d1b         	ldr	r3, [r3, #0x50]
 8010630: 2b00         	cmp	r3, #0x0
 8010632: d001         	beq	0x8010638 <spi_stm32_read_next_frame+0x4c> @ imm = #0x2
 8010634: 2301         	movs	r3, #0x1
 8010636: e000         	b	0x801063a <spi_stm32_read_next_frame+0x4e> @ imm = #0x0
 8010638: 2300         	movs	r3, #0x0
 801063a: f003 0301    	and	r3, r3, #0x1
 801063e: b2db         	uxtb	r3, r3
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 8010640: 2b00         	cmp	r3, #0x0
 8010642: d006         	beq	0x8010652 <spi_stm32_read_next_frame+0x66> @ imm = #0xc
; 			UNALIGNED_PUT(rx_frame, (uint8_t *)data->ctx.rx_buf);
 8010644: 683b         	ldr	r3, [r7]
 8010646: 6cdb         	ldr	r3, [r3, #0x4c]
 8010648: 64bb         	str	r3, [r7, #0x48]
 801064a: 6d3b         	ldr	r3, [r7, #0x50]
 801064c: b2da         	uxtb	r2, r3
 801064e: 6cbb         	ldr	r3, [r7, #0x48]
 8010650: 701a         	strb	r2, [r3]
; 		spi_context_update_rx(&data->ctx, 1, 1);
 8010652: 683b         	ldr	r3, [r7]
 8010654: 643b         	str	r3, [r7, #0x40]
 8010656: 2301         	movs	r3, #0x1
 8010658: f887 303f    	strb.w	r3, [r7, #0x3f]
 801065c: 2301         	movs	r3, #0x1
 801065e: 63bb         	str	r3, [r7, #0x38]
; 	if (!ctx->rx_len) {
 8010660: 6c3b         	ldr	r3, [r7, #0x40]
 8010662: 6d1b         	ldr	r3, [r3, #0x50]
 8010664: 2b00         	cmp	r3, #0x0
 8010666: f000 811c    	beq.w	0x80108a2 <spi_stm32_read_next_frame+0x2b6> @ imm = #0x238
; 	if (len > ctx->rx_len) {
 801066a: 6c3b         	ldr	r3, [r7, #0x40]
 801066c: 6d1b         	ldr	r3, [r3, #0x50]
 801066e: 6bba         	ldr	r2, [r7, #0x38]
 8010670: 429a         	cmp	r2, r3
 8010672: d91d         	bls	0x80106b0 <spi_stm32_read_next_frame+0xc4> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 8010674: 2303         	movs	r3, #0x3
 8010676: 2b00         	cmp	r3, #0x0
 8010678: d019         	beq	0x80106ae <spi_stm32_read_next_frame+0xc2> @ imm = #0x32
 801067a: 2301         	movs	r3, #0x1
 801067c: f887 3037    	strb.w	r3, [r7, #0x37]
 8010680: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8010684: f083 0301    	eor	r3, r3, #0x1
 8010688: b2db         	uxtb	r3, r3
 801068a: 2b00         	cmp	r3, #0x0
 801068c: d10f         	bne	0x80106ae <spi_stm32_read_next_frame+0xc2> @ imm = #0x1e
 801068e: 4b88         	ldr	r3, [pc, #0x220]        @ 0x80108b0 <spi_stm32_read_next_frame+0x2c4>
 8010690: 6819         	ldr	r1, [r3]
 8010692: 4b88         	ldr	r3, [pc, #0x220]        @ 0x80108b4 <spi_stm32_read_next_frame+0x2c8>
 8010694: 9302         	str	r3, [sp, #0x8]
 8010696: 2300         	movs	r3, #0x0
 8010698: 9301         	str	r3, [sp, #0x4]
 801069a: 2300         	movs	r3, #0x0
 801069c: 9300         	str	r3, [sp]
 801069e: 2300         	movs	r3, #0x0
 80106a0: 2201         	movs	r2, #0x1
 80106a2: 2000         	movs	r0, #0x0
 80106a4: f014 f85c    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x140b8
 80106a8: 2300         	movs	r3, #0x0
 80106aa: 633b         	str	r3, [r7, #0x30]
; 		return;
 80106ac: e0fc         	b	0x80108a8 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x1f8
 80106ae: e0fb         	b	0x80108a8 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x1f6
; 	ctx->rx_len -= len;
 80106b0: 6c3b         	ldr	r3, [r7, #0x40]
 80106b2: 6d1a         	ldr	r2, [r3, #0x50]
 80106b4: 6bbb         	ldr	r3, [r7, #0x38]
 80106b6: 1ad2         	subs	r2, r2, r3
 80106b8: 6c3b         	ldr	r3, [r7, #0x40]
 80106ba: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 80106bc: 6c3b         	ldr	r3, [r7, #0x40]
 80106be: 6d1b         	ldr	r3, [r3, #0x50]
 80106c0: 2b00         	cmp	r3, #0x0
 80106c2: d11b         	bne	0x80106fc <spi_stm32_read_next_frame+0x110> @ imm = #0x36
; 		++ctx->current_rx;
 80106c4: 6c3b         	ldr	r3, [r7, #0x40]
 80106c6: 6bdb         	ldr	r3, [r3, #0x3c]
 80106c8: f103 0208    	add.w	r2, r3, #0x8
 80106cc: 6c3b         	ldr	r3, [r7, #0x40]
 80106ce: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 80106d0: 6c3b         	ldr	r3, [r7, #0x40]
 80106d2: 6c1b         	ldr	r3, [r3, #0x40]
 80106d4: 1e5a         	subs	r2, r3, #0x1
 80106d6: 6c3b         	ldr	r3, [r7, #0x40]
 80106d8: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 80106da: 6c3b         	ldr	r3, [r7, #0x40]
 80106dc: f103 003c    	add.w	r0, r3, #0x3c
 80106e0: 6c3b         	ldr	r3, [r7, #0x40]
 80106e2: f103 0140    	add.w	r1, r3, #0x40
 80106e6: 6c3b         	ldr	r3, [r7, #0x40]
 80106e8: f103 0250    	add.w	r2, r3, #0x50
 80106ec: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 80106f0: f014 fd98    	bl	0x8025224 <spi_context_get_next_buf> @ imm = #0x14b30
 80106f4: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 80106f6: 6c3b         	ldr	r3, [r7, #0x40]
 80106f8: 64da         	str	r2, [r3, #0x4c]
 80106fa: e00d         	b	0x8010718 <spi_stm32_read_next_frame+0x12c> @ imm = #0x1a
; 	} else if (ctx->rx_buf) {
 80106fc: 6c3b         	ldr	r3, [r7, #0x40]
 80106fe: 6cdb         	ldr	r3, [r3, #0x4c]
 8010700: 2b00         	cmp	r3, #0x0
 8010702: d009         	beq	0x8010718 <spi_stm32_read_next_frame+0x12c> @ imm = #0x12
; 		ctx->rx_buf += dfs * len;
 8010704: 6c3b         	ldr	r3, [r7, #0x40]
 8010706: 6cda         	ldr	r2, [r3, #0x4c]
 8010708: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 801070c: 6bb9         	ldr	r1, [r7, #0x38]
 801070e: fb01 f303    	mul	r3, r1, r3
 8010712: 441a         	add	r2, r3
 8010714: 6c3b         	ldr	r3, [r7, #0x40]
 8010716: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 8010718: 2303         	movs	r3, #0x3
 801071a: 2b03         	cmp	r3, #0x3
 801071c: f240 80c4    	bls.w	0x80108a8 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x188
 8010720: 2301         	movs	r3, #0x1
 8010722: f887 302f    	strb.w	r3, [r7, #0x2f]
 8010726: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 801072a: f083 0301    	eor	r3, r3, #0x1
 801072e: b2db         	uxtb	r3, r3
 8010730: 2b00         	cmp	r3, #0x0
 8010732: f040 80b9    	bne.w	0x80108a8 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x172
 8010736: 4b5e         	ldr	r3, [pc, #0x178]        @ 0x80108b0 <spi_stm32_read_next_frame+0x2c4>
 8010738: 6819         	ldr	r1, [r3]
 801073a: 6c3b         	ldr	r3, [r7, #0x40]
 801073c: 6cdb         	ldr	r3, [r3, #0x4c]
 801073e: 6c3a         	ldr	r2, [r7, #0x40]
 8010740: 6d12         	ldr	r2, [r2, #0x50]
 8010742: 9205         	str	r2, [sp, #0x14]
 8010744: 9304         	str	r3, [sp, #0x10]
 8010746: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x80108b8 <spi_stm32_read_next_frame+0x2cc>
 8010748: 9303         	str	r3, [sp, #0xc]
 801074a: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x80108bc <spi_stm32_read_next_frame+0x2d0>
 801074c: 9302         	str	r3, [sp, #0x8]
 801074e: 2308         	movs	r3, #0x8
 8010750: 9301         	str	r3, [sp, #0x4]
 8010752: 2300         	movs	r3, #0x0
 8010754: 9300         	str	r3, [sp]
 8010756: 2300         	movs	r3, #0x0
 8010758: 2204         	movs	r2, #0x4
 801075a: 2000         	movs	r0, #0x0
 801075c: f014 f800    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x14000
 8010760: 2300         	movs	r3, #0x0
 8010762: 62bb         	str	r3, [r7, #0x28]
; }
 8010764: e0a0         	b	0x80108a8 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x140
; 		rx_frame = LL_SPI_ReceiveData16(spi);
 8010766: 6878         	ldr	r0, [r7, #0x4]
 8010768: f014 fabb    	bl	0x8024ce2 <LL_SPI_ReceiveData16> @ imm = #0x14576
 801076c: 4603         	mov	r3, r0
 801076e: 653b         	str	r3, [r7, #0x50]
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 8010770: 683b         	ldr	r3, [r7]
 8010772: 627b         	str	r3, [r7, #0x24]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 8010774: 6a7b         	ldr	r3, [r7, #0x24]
 8010776: 6cdb         	ldr	r3, [r3, #0x4c]
 8010778: 2b00         	cmp	r3, #0x0
 801077a: d005         	beq	0x8010788 <spi_stm32_read_next_frame+0x19c> @ imm = #0xa
 801077c: 6a7b         	ldr	r3, [r7, #0x24]
 801077e: 6d1b         	ldr	r3, [r3, #0x50]
 8010780: 2b00         	cmp	r3, #0x0
 8010782: d001         	beq	0x8010788 <spi_stm32_read_next_frame+0x19c> @ imm = #0x2
 8010784: 2301         	movs	r3, #0x1
 8010786: e000         	b	0x801078a <spi_stm32_read_next_frame+0x19e> @ imm = #0x0
 8010788: 2300         	movs	r3, #0x0
 801078a: f003 0301    	and	r3, r3, #0x1
 801078e: b2db         	uxtb	r3, r3
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 8010790: 2b00         	cmp	r3, #0x0
 8010792: d006         	beq	0x80107a2 <spi_stm32_read_next_frame+0x1b6> @ imm = #0xc
; 			UNALIGNED_PUT(rx_frame, (uint16_t *)data->ctx.rx_buf);
 8010794: 683b         	ldr	r3, [r7]
 8010796: 6cdb         	ldr	r3, [r3, #0x4c]
 8010798: 64fb         	str	r3, [r7, #0x4c]
 801079a: 6d3b         	ldr	r3, [r7, #0x50]
 801079c: b29a         	uxth	r2, r3
 801079e: 6cfb         	ldr	r3, [r7, #0x4c]
 80107a0: 801a         	strh	r2, [r3]
; 		spi_context_update_rx(&data->ctx, 2, 1);
 80107a2: 683b         	ldr	r3, [r7]
 80107a4: 623b         	str	r3, [r7, #0x20]
 80107a6: 2302         	movs	r3, #0x2
 80107a8: 77fb         	strb	r3, [r7, #0x1f]
 80107aa: 2301         	movs	r3, #0x1
 80107ac: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->rx_len) {
 80107ae: 6a3b         	ldr	r3, [r7, #0x20]
 80107b0: 6d1b         	ldr	r3, [r3, #0x50]
 80107b2: 2b00         	cmp	r3, #0x0
 80107b4: d077         	beq	0x80108a6 <spi_stm32_read_next_frame+0x2ba> @ imm = #0xee
; 	if (len > ctx->rx_len) {
 80107b6: 6a3b         	ldr	r3, [r7, #0x20]
 80107b8: 6d1b         	ldr	r3, [r3, #0x50]
 80107ba: 69ba         	ldr	r2, [r7, #0x18]
 80107bc: 429a         	cmp	r2, r3
 80107be: d91b         	bls	0x80107f8 <spi_stm32_read_next_frame+0x20c> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 80107c0: 2303         	movs	r3, #0x3
 80107c2: 2b00         	cmp	r3, #0x0
 80107c4: d017         	beq	0x80107f6 <spi_stm32_read_next_frame+0x20a> @ imm = #0x2e
 80107c6: 2301         	movs	r3, #0x1
 80107c8: 75fb         	strb	r3, [r7, #0x17]
 80107ca: 7dfb         	ldrb	r3, [r7, #0x17]
 80107cc: f083 0301    	eor	r3, r3, #0x1
 80107d0: b2db         	uxtb	r3, r3
 80107d2: 2b00         	cmp	r3, #0x0
 80107d4: d10f         	bne	0x80107f6 <spi_stm32_read_next_frame+0x20a> @ imm = #0x1e
 80107d6: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80108b0 <spi_stm32_read_next_frame+0x2c4>
 80107d8: 6819         	ldr	r1, [r3]
 80107da: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80108b4 <spi_stm32_read_next_frame+0x2c8>
 80107dc: 9302         	str	r3, [sp, #0x8]
 80107de: 2300         	movs	r3, #0x0
 80107e0: 9301         	str	r3, [sp, #0x4]
 80107e2: 2300         	movs	r3, #0x0
 80107e4: 9300         	str	r3, [sp]
 80107e6: 2300         	movs	r3, #0x0
 80107e8: 2201         	movs	r2, #0x1
 80107ea: 2000         	movs	r0, #0x0
 80107ec: f013 ffb8    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x13f70
 80107f0: 2300         	movs	r3, #0x0
 80107f2: 613b         	str	r3, [r7, #0x10]
; 		return;
 80107f4: e058         	b	0x80108a8 <spi_stm32_read_next_frame+0x2bc> @ imm = #0xb0
 80107f6: e057         	b	0x80108a8 <spi_stm32_read_next_frame+0x2bc> @ imm = #0xae
; 	ctx->rx_len -= len;
 80107f8: 6a3b         	ldr	r3, [r7, #0x20]
 80107fa: 6d1a         	ldr	r2, [r3, #0x50]
 80107fc: 69bb         	ldr	r3, [r7, #0x18]
 80107fe: 1ad2         	subs	r2, r2, r3
 8010800: 6a3b         	ldr	r3, [r7, #0x20]
 8010802: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 8010804: 6a3b         	ldr	r3, [r7, #0x20]
 8010806: 6d1b         	ldr	r3, [r3, #0x50]
 8010808: 2b00         	cmp	r3, #0x0
 801080a: d11a         	bne	0x8010842 <spi_stm32_read_next_frame+0x256> @ imm = #0x34
; 		++ctx->current_rx;
 801080c: 6a3b         	ldr	r3, [r7, #0x20]
 801080e: 6bdb         	ldr	r3, [r3, #0x3c]
 8010810: f103 0208    	add.w	r2, r3, #0x8
 8010814: 6a3b         	ldr	r3, [r7, #0x20]
 8010816: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 8010818: 6a3b         	ldr	r3, [r7, #0x20]
 801081a: 6c1b         	ldr	r3, [r3, #0x40]
 801081c: 1e5a         	subs	r2, r3, #0x1
 801081e: 6a3b         	ldr	r3, [r7, #0x20]
 8010820: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 8010822: 6a3b         	ldr	r3, [r7, #0x20]
 8010824: f103 003c    	add.w	r0, r3, #0x3c
 8010828: 6a3b         	ldr	r3, [r7, #0x20]
 801082a: f103 0140    	add.w	r1, r3, #0x40
 801082e: 6a3b         	ldr	r3, [r7, #0x20]
 8010830: f103 0250    	add.w	r2, r3, #0x50
 8010834: 7ffb         	ldrb	r3, [r7, #0x1f]
 8010836: f014 fcf5    	bl	0x8025224 <spi_context_get_next_buf> @ imm = #0x149ea
 801083a: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 801083c: 6a3b         	ldr	r3, [r7, #0x20]
 801083e: 64da         	str	r2, [r3, #0x4c]
 8010840: e00c         	b	0x801085c <spi_stm32_read_next_frame+0x270> @ imm = #0x18
; 	} else if (ctx->rx_buf) {
 8010842: 6a3b         	ldr	r3, [r7, #0x20]
 8010844: 6cdb         	ldr	r3, [r3, #0x4c]
 8010846: 2b00         	cmp	r3, #0x0
 8010848: d008         	beq	0x801085c <spi_stm32_read_next_frame+0x270> @ imm = #0x10
; 		ctx->rx_buf += dfs * len;
 801084a: 6a3b         	ldr	r3, [r7, #0x20]
 801084c: 6cda         	ldr	r2, [r3, #0x4c]
 801084e: 7ffb         	ldrb	r3, [r7, #0x1f]
 8010850: 69b9         	ldr	r1, [r7, #0x18]
 8010852: fb01 f303    	mul	r3, r1, r3
 8010856: 441a         	add	r2, r3
 8010858: 6a3b         	ldr	r3, [r7, #0x20]
 801085a: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 801085c: 2303         	movs	r3, #0x3
 801085e: 2b03         	cmp	r3, #0x3
 8010860: d922         	bls	0x80108a8 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x44
 8010862: 2301         	movs	r3, #0x1
 8010864: 73fb         	strb	r3, [r7, #0xf]
 8010866: 7bfb         	ldrb	r3, [r7, #0xf]
 8010868: f083 0301    	eor	r3, r3, #0x1
 801086c: b2db         	uxtb	r3, r3
 801086e: 2b00         	cmp	r3, #0x0
 8010870: d11a         	bne	0x80108a8 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x34
 8010872: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80108b0 <spi_stm32_read_next_frame+0x2c4>
 8010874: 6819         	ldr	r1, [r3]
 8010876: 6a3b         	ldr	r3, [r7, #0x20]
 8010878: 6cdb         	ldr	r3, [r3, #0x4c]
 801087a: 6a3a         	ldr	r2, [r7, #0x20]
 801087c: 6d12         	ldr	r2, [r2, #0x50]
 801087e: 9205         	str	r2, [sp, #0x14]
 8010880: 9304         	str	r3, [sp, #0x10]
 8010882: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80108b8 <spi_stm32_read_next_frame+0x2cc>
 8010884: 9303         	str	r3, [sp, #0xc]
 8010886: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80108bc <spi_stm32_read_next_frame+0x2d0>
 8010888: 9302         	str	r3, [sp, #0x8]
 801088a: 2308         	movs	r3, #0x8
 801088c: 9301         	str	r3, [sp, #0x4]
 801088e: 2300         	movs	r3, #0x0
 8010890: 9300         	str	r3, [sp]
 8010892: 2300         	movs	r3, #0x0
 8010894: 2204         	movs	r2, #0x4
 8010896: 2000         	movs	r0, #0x0
 8010898: f013 ff62    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x13ec4
 801089c: 2300         	movs	r3, #0x0
 801089e: 60bb         	str	r3, [r7, #0x8]
; }
 80108a0: e002         	b	0x80108a8 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x4
; 		return;
 80108a2: bf00         	nop
 80108a4: e000         	b	0x80108a8 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x0
 80108a6: bf00         	nop
; }
 80108a8: bf00         	nop
 80108aa: 3758         	adds	r7, #0x58
 80108ac: 46bd         	mov	sp, r7
 80108ae: bd80         	pop	{r7, pc}

080108b0 <$d>:
 80108b0: 10 07 00 24  	.word	0x24000710
 80108b4: 38 c2 02 08  	.word	0x0802c238
 80108b8: 58 da 02 08  	.word	0x0802da58
 80108bc: 70 c2 02 08  	.word	0x0802c270

080108c0 <spi_stm32_get_err>:
; {
 80108c0: b580         	push	{r7, lr}
 80108c2: b08c         	sub	sp, #0x30
 80108c4: af06         	add	r7, sp, #0x18
 80108c6: 6078         	str	r0, [r7, #0x4]
; 	uint32_t sr = LL_SPI_ReadReg(spi, SR);
 80108c8: 687b         	ldr	r3, [r7, #0x4]
 80108ca: 695b         	ldr	r3, [r3, #0x14]
 80108cc: 617b         	str	r3, [r7, #0x14]
; 	if (sr & SPI_STM32_ERR_MSK) {
 80108ce: 697b         	ldr	r3, [r7, #0x14]
 80108d0: f403 7378    	and	r3, r3, #0x3e0
 80108d4: 2b00         	cmp	r3, #0x0
 80108d6: d02b         	beq	0x8010930 <spi_stm32_get_err+0x70> @ imm = #0x56
; 		LOG_ERR("%s: err=%d", __func__, sr & (uint32_t)SPI_STM32_ERR_MSK);
 80108d8: 2303         	movs	r3, #0x3
 80108da: 2b00         	cmp	r3, #0x0
 80108dc: d01c         	beq	0x8010918 <spi_stm32_get_err+0x58> @ imm = #0x38
 80108de: 2301         	movs	r3, #0x1
 80108e0: 74fb         	strb	r3, [r7, #0x13]
 80108e2: 7cfb         	ldrb	r3, [r7, #0x13]
 80108e4: f083 0301    	eor	r3, r3, #0x1
 80108e8: b2db         	uxtb	r3, r3
 80108ea: 2b00         	cmp	r3, #0x0
 80108ec: d114         	bne	0x8010918 <spi_stm32_get_err+0x58> @ imm = #0x28
 80108ee: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x801093c <spi_stm32_get_err+0x7c>
 80108f0: 6819         	ldr	r1, [r3]
 80108f2: 697b         	ldr	r3, [r7, #0x14]
 80108f4: f403 7378    	and	r3, r3, #0x3e0
 80108f8: 9304         	str	r3, [sp, #0x10]
 80108fa: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8010940 <spi_stm32_get_err+0x80>
 80108fc: 9303         	str	r3, [sp, #0xc]
 80108fe: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8010944 <spi_stm32_get_err+0x84>
 8010900: 9302         	str	r3, [sp, #0x8]
 8010902: 2300         	movs	r3, #0x0
 8010904: 9301         	str	r3, [sp, #0x4]
 8010906: 2300         	movs	r3, #0x0
 8010908: 9300         	str	r3, [sp]
 801090a: 2300         	movs	r3, #0x0
 801090c: 2201         	movs	r2, #0x1
 801090e: 2000         	movs	r0, #0x0
 8010910: f013 ff26    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x13e4c
 8010914: 2300         	movs	r3, #0x0
 8010916: 60fb         	str	r3, [r7, #0xc]
; 		if (LL_SPI_IsActiveFlag_OVR(spi)) {
 8010918: 6878         	ldr	r0, [r7, #0x4]
 801091a: f014 f95d    	bl	0x8024bd8 <LL_SPI_IsActiveFlag_OVR> @ imm = #0x142ba
 801091e: 4603         	mov	r3, r0
 8010920: 2b00         	cmp	r3, #0x0
 8010922: d002         	beq	0x801092a <spi_stm32_get_err+0x6a> @ imm = #0x4
; 			LL_SPI_ClearFlag_OVR(spi);
 8010924: 6878         	ldr	r0, [r7, #0x4]
 8010926: f014 f99e    	bl	0x8024c66 <LL_SPI_ClearFlag_OVR> @ imm = #0x1433c
; 		return -EIO;
 801092a: f06f 0304    	mvn	r3, #0x4
 801092e: e000         	b	0x8010932 <spi_stm32_get_err+0x72> @ imm = #0x0
; 	return 0;
 8010930: 2300         	movs	r3, #0x0
; }
 8010932: 4618         	mov	r0, r3
 8010934: 3718         	adds	r7, #0x18
 8010936: 46bd         	mov	sp, r7
 8010938: bd80         	pop	{r7, pc}
 801093a: bf00         	nop

0801093c <$d>:
 801093c: 10 07 00 24  	.word	0x24000710
 8010940: 70 da 02 08  	.word	0x0802da70
 8010944: 88 c2 02 08  	.word	0x0802c288

08010948 <spi_stm32_shift_s>:
; {
 8010948: b580         	push	{r7, lr}
 801094a: b0ac         	sub	sp, #0xb0
 801094c: af06         	add	r7, sp, #0x18
 801094e: 6078         	str	r0, [r7, #0x4]
 8010950: 6039         	str	r1, [r7]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 8010952: 6878         	ldr	r0, [r7, #0x4]
 8010954: f014 fc99    	bl	0x802528a <ll_func_tx_is_not_full> @ imm = #0x14932
 8010958: 4603         	mov	r3, r0
 801095a: 2b00         	cmp	r3, #0x0
 801095c: f000 814a    	beq.w	0x8010bf4 <spi_stm32_shift_s+0x2ac> @ imm = #0x294
 8010960: 683b         	ldr	r3, [r7]
 8010962: 67fb         	str	r3, [r7, #0x7c]
; 	return !!(ctx->tx_len);
 8010964: 6ffb         	ldr	r3, [r7, #0x7c]
 8010966: 6c9b         	ldr	r3, [r3, #0x48]
 8010968: 2b00         	cmp	r3, #0x0
 801096a: bf14         	ite	ne
 801096c: 2301         	movne	r3, #0x1
 801096e: 2300         	moveq	r3, #0x0
 8010970: b2db         	uxtb	r3, r3
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 8010972: 2b00         	cmp	r3, #0x0
 8010974: f000 813e    	beq.w	0x8010bf4 <spi_stm32_shift_s+0x2ac> @ imm = #0x27c
; 		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 8010978: 683b         	ldr	r3, [r7]
 801097a: 681b         	ldr	r3, [r3]
 801097c: 889b         	ldrh	r3, [r3, #0x4]
 801097e: 095b         	lsrs	r3, r3, #0x5
 8010980: f003 033f    	and	r3, r3, #0x3f
 8010984: 2b08         	cmp	r3, #0x8
 8010986: f040 809a    	bne.w	0x8010abe <spi_stm32_shift_s+0x176> @ imm = #0x134
; 			tx_frame = UNALIGNED_GET((uint8_t *)(data->ctx.tx_buf));
 801098a: 683b         	ldr	r3, [r7]
 801098c: 6c5b         	ldr	r3, [r3, #0x44]
 801098e: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8010992: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8010996: 781b         	ldrb	r3, [r3]
 8010998: f8a7 3092    	strh.w	r3, [r7, #0x92]
; 			LL_SPI_TransmitData8(spi, tx_frame);
 801099c: f8b7 3092    	ldrh.w	r3, [r7, #0x92]
 80109a0: b2db         	uxtb	r3, r3
 80109a2: 4619         	mov	r1, r3
 80109a4: 6878         	ldr	r0, [r7, #0x4]
 80109a6: f014 f9ac    	bl	0x8024d02 <LL_SPI_TransmitData8> @ imm = #0x14358
; 			spi_context_update_tx(&data->ctx, 1, 1);
 80109aa: 683b         	ldr	r3, [r7]
 80109ac: 67bb         	str	r3, [r7, #0x78]
 80109ae: 2301         	movs	r3, #0x1
 80109b0: f887 3077    	strb.w	r3, [r7, #0x77]
 80109b4: 2301         	movs	r3, #0x1
 80109b6: 673b         	str	r3, [r7, #0x70]
; 	if (!ctx->tx_len) {
 80109b8: 6fbb         	ldr	r3, [r7, #0x78]
 80109ba: 6c9b         	ldr	r3, [r3, #0x48]
 80109bc: 2b00         	cmp	r3, #0x0
 80109be: f000 8115    	beq.w	0x8010bec <spi_stm32_shift_s+0x2a4> @ imm = #0x22a
; 	if (len > ctx->tx_len) {
 80109c2: 6fbb         	ldr	r3, [r7, #0x78]
 80109c4: 6c9b         	ldr	r3, [r3, #0x48]
 80109c6: 6f3a         	ldr	r2, [r7, #0x70]
 80109c8: 429a         	cmp	r2, r3
 80109ca: d91d         	bls	0x8010a08 <spi_stm32_shift_s+0xc0> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 80109cc: 2303         	movs	r3, #0x3
 80109ce: 2b00         	cmp	r3, #0x0
 80109d0: d019         	beq	0x8010a06 <spi_stm32_shift_s+0xbe> @ imm = #0x32
 80109d2: 2301         	movs	r3, #0x1
 80109d4: f887 306f    	strb.w	r3, [r7, #0x6f]
 80109d8: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 80109dc: f083 0301    	eor	r3, r3, #0x1
 80109e0: b2db         	uxtb	r3, r3
 80109e2: 2b00         	cmp	r3, #0x0
 80109e4: d10f         	bne	0x8010a06 <spi_stm32_shift_s+0xbe> @ imm = #0x1e
 80109e6: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8010c20 <spi_stm32_shift_s+0x2d8>
 80109e8: 6819         	ldr	r1, [r3]
 80109ea: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8010c24 <spi_stm32_shift_s+0x2dc>
 80109ec: 9302         	str	r3, [sp, #0x8]
 80109ee: 2300         	movs	r3, #0x0
 80109f0: 9301         	str	r3, [sp, #0x4]
 80109f2: 2300         	movs	r3, #0x0
 80109f4: 9300         	str	r3, [sp]
 80109f6: 2300         	movs	r3, #0x0
 80109f8: 2201         	movs	r2, #0x1
 80109fa: 2000         	movs	r0, #0x0
 80109fc: f013 feb0    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x13d60
 8010a00: 2300         	movs	r3, #0x0
 8010a02: 66bb         	str	r3, [r7, #0x68]
; 		return;
 8010a04: e0f5         	b	0x8010bf2 <spi_stm32_shift_s+0x2aa> @ imm = #0x1ea
 8010a06: e0f4         	b	0x8010bf2 <spi_stm32_shift_s+0x2aa> @ imm = #0x1e8
; 	ctx->tx_len -= len;
 8010a08: 6fbb         	ldr	r3, [r7, #0x78]
 8010a0a: 6c9a         	ldr	r2, [r3, #0x48]
 8010a0c: 6f3b         	ldr	r3, [r7, #0x70]
 8010a0e: 1ad2         	subs	r2, r2, r3
 8010a10: 6fbb         	ldr	r3, [r7, #0x78]
 8010a12: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 8010a14: 6fbb         	ldr	r3, [r7, #0x78]
 8010a16: 6c9b         	ldr	r3, [r3, #0x48]
 8010a18: 2b00         	cmp	r3, #0x0
 8010a1a: d11b         	bne	0x8010a54 <spi_stm32_shift_s+0x10c> @ imm = #0x36
; 		++ctx->current_tx;
 8010a1c: 6fbb         	ldr	r3, [r7, #0x78]
 8010a1e: 6b5b         	ldr	r3, [r3, #0x34]
 8010a20: f103 0208    	add.w	r2, r3, #0x8
 8010a24: 6fbb         	ldr	r3, [r7, #0x78]
 8010a26: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 8010a28: 6fbb         	ldr	r3, [r7, #0x78]
 8010a2a: 6b9b         	ldr	r3, [r3, #0x38]
 8010a2c: 1e5a         	subs	r2, r3, #0x1
 8010a2e: 6fbb         	ldr	r3, [r7, #0x78]
 8010a30: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 8010a32: 6fbb         	ldr	r3, [r7, #0x78]
 8010a34: f103 0034    	add.w	r0, r3, #0x34
 8010a38: 6fbb         	ldr	r3, [r7, #0x78]
 8010a3a: f103 0138    	add.w	r1, r3, #0x38
 8010a3e: 6fbb         	ldr	r3, [r7, #0x78]
 8010a40: f103 0248    	add.w	r2, r3, #0x48
 8010a44: f897 3077    	ldrb.w	r3, [r7, #0x77]
 8010a48: f014 fbec    	bl	0x8025224 <spi_context_get_next_buf> @ imm = #0x147d8
 8010a4c: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 8010a4e: 6fbb         	ldr	r3, [r7, #0x78]
 8010a50: 645a         	str	r2, [r3, #0x44]
 8010a52: e00d         	b	0x8010a70 <spi_stm32_shift_s+0x128> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 8010a54: 6fbb         	ldr	r3, [r7, #0x78]
 8010a56: 6c5b         	ldr	r3, [r3, #0x44]
 8010a58: 2b00         	cmp	r3, #0x0
 8010a5a: d009         	beq	0x8010a70 <spi_stm32_shift_s+0x128> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 8010a5c: 6fbb         	ldr	r3, [r7, #0x78]
 8010a5e: 6c5a         	ldr	r2, [r3, #0x44]
 8010a60: f897 3077    	ldrb.w	r3, [r7, #0x77]
 8010a64: 6f39         	ldr	r1, [r7, #0x70]
 8010a66: fb01 f303    	mul	r3, r1, r3
 8010a6a: 441a         	add	r2, r3
 8010a6c: 6fbb         	ldr	r3, [r7, #0x78]
 8010a6e: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 8010a70: 2303         	movs	r3, #0x3
 8010a72: 2b03         	cmp	r3, #0x3
 8010a74: f240 80bd    	bls.w	0x8010bf2 <spi_stm32_shift_s+0x2aa> @ imm = #0x17a
 8010a78: 2301         	movs	r3, #0x1
 8010a7a: f887 3067    	strb.w	r3, [r7, #0x67]
 8010a7e: f897 3067    	ldrb.w	r3, [r7, #0x67]
 8010a82: f083 0301    	eor	r3, r3, #0x1
 8010a86: b2db         	uxtb	r3, r3
 8010a88: 2b00         	cmp	r3, #0x0
 8010a8a: f040 80b2    	bne.w	0x8010bf2 <spi_stm32_shift_s+0x2aa> @ imm = #0x164
 8010a8e: 4b64         	ldr	r3, [pc, #0x190]        @ 0x8010c20 <spi_stm32_shift_s+0x2d8>
 8010a90: 6819         	ldr	r1, [r3]
 8010a92: 6fbb         	ldr	r3, [r7, #0x78]
 8010a94: 6c5b         	ldr	r3, [r3, #0x44]
 8010a96: 6fba         	ldr	r2, [r7, #0x78]
 8010a98: 6c92         	ldr	r2, [r2, #0x48]
 8010a9a: 9205         	str	r2, [sp, #0x14]
 8010a9c: 9304         	str	r3, [sp, #0x10]
 8010a9e: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8010c28 <spi_stm32_shift_s+0x2e0>
 8010aa0: 9303         	str	r3, [sp, #0xc]
 8010aa2: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8010c2c <spi_stm32_shift_s+0x2e4>
 8010aa4: 9302         	str	r3, [sp, #0x8]
 8010aa6: 2308         	movs	r3, #0x8
 8010aa8: 9301         	str	r3, [sp, #0x4]
 8010aaa: 2300         	movs	r3, #0x0
 8010aac: 9300         	str	r3, [sp]
 8010aae: 2300         	movs	r3, #0x0
 8010ab0: 2204         	movs	r2, #0x4
 8010ab2: 2000         	movs	r0, #0x0
 8010ab4: f013 fe54    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x13ca8
 8010ab8: 2300         	movs	r3, #0x0
 8010aba: 663b         	str	r3, [r7, #0x60]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 8010abc: e09d         	b	0x8010bfa <spi_stm32_shift_s+0x2b2> @ imm = #0x13a
; 			tx_frame = UNALIGNED_GET((uint16_t *)(data->ctx.tx_buf));
 8010abe: 683b         	ldr	r3, [r7]
 8010ac0: 6c5b         	ldr	r3, [r3, #0x44]
 8010ac2: f8c7 3094    	str.w	r3, [r7, #0x94]
 8010ac6: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 8010aca: 881b         	ldrh	r3, [r3]
 8010acc: b29b         	uxth	r3, r3
 8010ace: f8a7 3092    	strh.w	r3, [r7, #0x92]
; 			LL_SPI_TransmitData16(spi, tx_frame);
 8010ad2: f8b7 3092    	ldrh.w	r3, [r7, #0x92]
 8010ad6: 4619         	mov	r1, r3
 8010ad8: 6878         	ldr	r0, [r7, #0x4]
 8010ada: f014 f922    	bl	0x8024d22 <LL_SPI_TransmitData16> @ imm = #0x14244
; 			spi_context_update_tx(&data->ctx, 2, 1);
 8010ade: 683b         	ldr	r3, [r7]
 8010ae0: 65fb         	str	r3, [r7, #0x5c]
 8010ae2: 2302         	movs	r3, #0x2
 8010ae4: f887 305b    	strb.w	r3, [r7, #0x5b]
 8010ae8: 2301         	movs	r3, #0x1
 8010aea: 657b         	str	r3, [r7, #0x54]
; 	if (!ctx->tx_len) {
 8010aec: 6dfb         	ldr	r3, [r7, #0x5c]
 8010aee: 6c9b         	ldr	r3, [r3, #0x48]
 8010af0: 2b00         	cmp	r3, #0x0
 8010af2: d07d         	beq	0x8010bf0 <spi_stm32_shift_s+0x2a8> @ imm = #0xfa
; 	if (len > ctx->tx_len) {
 8010af4: 6dfb         	ldr	r3, [r7, #0x5c]
 8010af6: 6c9b         	ldr	r3, [r3, #0x48]
 8010af8: 6d7a         	ldr	r2, [r7, #0x54]
 8010afa: 429a         	cmp	r2, r3
 8010afc: d91d         	bls	0x8010b3a <spi_stm32_shift_s+0x1f2> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 8010afe: 2303         	movs	r3, #0x3
 8010b00: 2b00         	cmp	r3, #0x0
 8010b02: d019         	beq	0x8010b38 <spi_stm32_shift_s+0x1f0> @ imm = #0x32
 8010b04: 2301         	movs	r3, #0x1
 8010b06: f887 3053    	strb.w	r3, [r7, #0x53]
 8010b0a: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8010b0e: f083 0301    	eor	r3, r3, #0x1
 8010b12: b2db         	uxtb	r3, r3
 8010b14: 2b00         	cmp	r3, #0x0
 8010b16: d10f         	bne	0x8010b38 <spi_stm32_shift_s+0x1f0> @ imm = #0x1e
 8010b18: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8010c20 <spi_stm32_shift_s+0x2d8>
 8010b1a: 6819         	ldr	r1, [r3]
 8010b1c: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8010c24 <spi_stm32_shift_s+0x2dc>
 8010b1e: 9302         	str	r3, [sp, #0x8]
 8010b20: 2300         	movs	r3, #0x0
 8010b22: 9301         	str	r3, [sp, #0x4]
 8010b24: 2300         	movs	r3, #0x0
 8010b26: 9300         	str	r3, [sp]
 8010b28: 2300         	movs	r3, #0x0
 8010b2a: 2201         	movs	r2, #0x1
 8010b2c: 2000         	movs	r0, #0x0
 8010b2e: f013 fe17    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x13c2e
 8010b32: 2300         	movs	r3, #0x0
 8010b34: 64fb         	str	r3, [r7, #0x4c]
; 		return;
 8010b36: e05c         	b	0x8010bf2 <spi_stm32_shift_s+0x2aa> @ imm = #0xb8
 8010b38: e05b         	b	0x8010bf2 <spi_stm32_shift_s+0x2aa> @ imm = #0xb6
; 	ctx->tx_len -= len;
 8010b3a: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b3c: 6c9a         	ldr	r2, [r3, #0x48]
 8010b3e: 6d7b         	ldr	r3, [r7, #0x54]
 8010b40: 1ad2         	subs	r2, r2, r3
 8010b42: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b44: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 8010b46: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b48: 6c9b         	ldr	r3, [r3, #0x48]
 8010b4a: 2b00         	cmp	r3, #0x0
 8010b4c: d11b         	bne	0x8010b86 <spi_stm32_shift_s+0x23e> @ imm = #0x36
; 		++ctx->current_tx;
 8010b4e: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b50: 6b5b         	ldr	r3, [r3, #0x34]
 8010b52: f103 0208    	add.w	r2, r3, #0x8
 8010b56: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b58: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 8010b5a: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b5c: 6b9b         	ldr	r3, [r3, #0x38]
 8010b5e: 1e5a         	subs	r2, r3, #0x1
 8010b60: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b62: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 8010b64: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b66: f103 0034    	add.w	r0, r3, #0x34
 8010b6a: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b6c: f103 0138    	add.w	r1, r3, #0x38
 8010b70: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b72: f103 0248    	add.w	r2, r3, #0x48
 8010b76: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8010b7a: f014 fb53    	bl	0x8025224 <spi_context_get_next_buf> @ imm = #0x146a6
 8010b7e: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 8010b80: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b82: 645a         	str	r2, [r3, #0x44]
 8010b84: e00d         	b	0x8010ba2 <spi_stm32_shift_s+0x25a> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 8010b86: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b88: 6c5b         	ldr	r3, [r3, #0x44]
 8010b8a: 2b00         	cmp	r3, #0x0
 8010b8c: d009         	beq	0x8010ba2 <spi_stm32_shift_s+0x25a> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 8010b8e: 6dfb         	ldr	r3, [r7, #0x5c]
 8010b90: 6c5a         	ldr	r2, [r3, #0x44]
 8010b92: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8010b96: 6d79         	ldr	r1, [r7, #0x54]
 8010b98: fb01 f303    	mul	r3, r1, r3
 8010b9c: 441a         	add	r2, r3
 8010b9e: 6dfb         	ldr	r3, [r7, #0x5c]
 8010ba0: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 8010ba2: 2303         	movs	r3, #0x3
 8010ba4: 2b03         	cmp	r3, #0x3
 8010ba6: d924         	bls	0x8010bf2 <spi_stm32_shift_s+0x2aa> @ imm = #0x48
 8010ba8: 2301         	movs	r3, #0x1
 8010baa: f887 304b    	strb.w	r3, [r7, #0x4b]
 8010bae: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8010bb2: f083 0301    	eor	r3, r3, #0x1
 8010bb6: b2db         	uxtb	r3, r3
 8010bb8: 2b00         	cmp	r3, #0x0
 8010bba: d11a         	bne	0x8010bf2 <spi_stm32_shift_s+0x2aa> @ imm = #0x34
 8010bbc: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8010c20 <spi_stm32_shift_s+0x2d8>
 8010bbe: 6819         	ldr	r1, [r3]
 8010bc0: 6dfb         	ldr	r3, [r7, #0x5c]
 8010bc2: 6c5b         	ldr	r3, [r3, #0x44]
 8010bc4: 6dfa         	ldr	r2, [r7, #0x5c]
 8010bc6: 6c92         	ldr	r2, [r2, #0x48]
 8010bc8: 9205         	str	r2, [sp, #0x14]
 8010bca: 9304         	str	r3, [sp, #0x10]
 8010bcc: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8010c28 <spi_stm32_shift_s+0x2e0>
 8010bce: 9303         	str	r3, [sp, #0xc]
 8010bd0: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8010c2c <spi_stm32_shift_s+0x2e4>
 8010bd2: 9302         	str	r3, [sp, #0x8]
 8010bd4: 2308         	movs	r3, #0x8
 8010bd6: 9301         	str	r3, [sp, #0x4]
 8010bd8: 2300         	movs	r3, #0x0
 8010bda: 9300         	str	r3, [sp]
 8010bdc: 2300         	movs	r3, #0x0
 8010bde: 2204         	movs	r2, #0x4
 8010be0: 2000         	movs	r0, #0x0
 8010be2: f013 fdbd    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x13b7a
 8010be6: 2300         	movs	r3, #0x0
 8010be8: 647b         	str	r3, [r7, #0x44]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 8010bea: e006         	b	0x8010bfa <spi_stm32_shift_s+0x2b2> @ imm = #0xc
; 		return;
 8010bec: bf00         	nop
 8010bee: e004         	b	0x8010bfa <spi_stm32_shift_s+0x2b2> @ imm = #0x8
 8010bf0: bf00         	nop
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 8010bf2: e002         	b	0x8010bfa <spi_stm32_shift_s+0x2b2> @ imm = #0x4
; 		ll_func_disable_int_tx_empty(spi);
 8010bf4: 6878         	ldr	r0, [r7, #0x4]
 8010bf6: f014 fb60    	bl	0x80252ba <ll_func_disable_int_tx_empty> @ imm = #0x146c0
; 	if (ll_func_rx_is_not_empty(spi) && spi_context_rx_buf_on(&data->ctx)) {
 8010bfa: 6878         	ldr	r0, [r7, #0x4]
 8010bfc: f014 fb51    	bl	0x80252a2 <ll_func_rx_is_not_empty> @ imm = #0x146a2
 8010c00: 4603         	mov	r3, r0
 8010c02: 2b00         	cmp	r3, #0x0
 8010c04: f000 8150    	beq.w	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0x2a0
 8010c08: 683b         	ldr	r3, [r7]
 8010c0a: 643b         	str	r3, [r7, #0x40]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 8010c0c: 6c3b         	ldr	r3, [r7, #0x40]
 8010c0e: 6cdb         	ldr	r3, [r3, #0x4c]
 8010c10: 2b00         	cmp	r3, #0x0
 8010c12: d00d         	beq	0x8010c30 <spi_stm32_shift_s+0x2e8> @ imm = #0x1a
 8010c14: 6c3b         	ldr	r3, [r7, #0x40]
 8010c16: 6d1b         	ldr	r3, [r3, #0x50]
 8010c18: 2b00         	cmp	r3, #0x0
 8010c1a: d009         	beq	0x8010c30 <spi_stm32_shift_s+0x2e8> @ imm = #0x12
 8010c1c: 2301         	movs	r3, #0x1
 8010c1e: e008         	b	0x8010c32 <spi_stm32_shift_s+0x2ea> @ imm = #0x10

08010c20 <$d>:
 8010c20: 10 07 00 24  	.word	0x24000710
 8010c24: 38 c2 02 08  	.word	0x0802c238
 8010c28: 40 da 02 08  	.word	0x0802da40
 8010c2c: 58 c2 02 08  	.word	0x0802c258

08010c30 <$t>:
 8010c30: 2300         	movs	r3, #0x0
 8010c32: f003 0301    	and	r3, r3, #0x1
 8010c36: b2db         	uxtb	r3, r3
; 	if (ll_func_rx_is_not_empty(spi) && spi_context_rx_buf_on(&data->ctx)) {
 8010c38: 2b00         	cmp	r3, #0x0
 8010c3a: f000 8135    	beq.w	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0x26a
; 		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 8010c3e: 683b         	ldr	r3, [r7]
 8010c40: 681b         	ldr	r3, [r3]
 8010c42: 889b         	ldrh	r3, [r3, #0x4]
 8010c44: 095b         	lsrs	r3, r3, #0x5
 8010c46: f003 033f    	and	r3, r3, #0x3f
 8010c4a: 2b08         	cmp	r3, #0x8
 8010c4c: f040 809a    	bne.w	0x8010d84 <spi_stm32_shift_s+0x43c> @ imm = #0x134
; 			rx_frame = LL_SPI_ReceiveData8(spi);
 8010c50: 6878         	ldr	r0, [r7, #0x4]
 8010c52: f014 f838    	bl	0x8024cc6 <LL_SPI_ReceiveData8> @ imm = #0x14070
 8010c56: 4603         	mov	r3, r0
 8010c58: f8a7 308a    	strh.w	r3, [r7, #0x8a]
; 			UNALIGNED_PUT(rx_frame, (uint8_t *)data->ctx.rx_buf);
 8010c5c: 683b         	ldr	r3, [r7]
 8010c5e: 6cdb         	ldr	r3, [r3, #0x4c]
 8010c60: f8c7 3080    	str.w	r3, [r7, #0x80]
 8010c64: f8b7 308a    	ldrh.w	r3, [r7, #0x8a]
 8010c68: b2da         	uxtb	r2, r3
 8010c6a: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8010c6e: 701a         	strb	r2, [r3]
; 			spi_context_update_rx(&data->ctx, 1, 1);
 8010c70: 683b         	ldr	r3, [r7]
 8010c72: 63fb         	str	r3, [r7, #0x3c]
 8010c74: 2301         	movs	r3, #0x1
 8010c76: f887 303b    	strb.w	r3, [r7, #0x3b]
 8010c7a: 2301         	movs	r3, #0x1
 8010c7c: 637b         	str	r3, [r7, #0x34]
; 	if (!ctx->rx_len) {
 8010c7e: 6bfb         	ldr	r3, [r7, #0x3c]
 8010c80: 6d1b         	ldr	r3, [r3, #0x50]
 8010c82: 2b00         	cmp	r3, #0x0
 8010c84: f000 810d    	beq.w	0x8010ea2 <spi_stm32_shift_s+0x55a> @ imm = #0x21a
; 	if (len > ctx->rx_len) {
 8010c88: 6bfb         	ldr	r3, [r7, #0x3c]
 8010c8a: 6d1b         	ldr	r3, [r3, #0x50]
 8010c8c: 6b7a         	ldr	r2, [r7, #0x34]
 8010c8e: 429a         	cmp	r2, r3
 8010c90: d91d         	bls	0x8010cce <spi_stm32_shift_s+0x386> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 8010c92: 2303         	movs	r3, #0x3
 8010c94: 2b00         	cmp	r3, #0x0
 8010c96: d019         	beq	0x8010ccc <spi_stm32_shift_s+0x384> @ imm = #0x32
 8010c98: 2301         	movs	r3, #0x1
 8010c9a: f887 3033    	strb.w	r3, [r7, #0x33]
 8010c9e: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8010ca2: f083 0301    	eor	r3, r3, #0x1
 8010ca6: b2db         	uxtb	r3, r3
 8010ca8: 2b00         	cmp	r3, #0x0
 8010caa: d10f         	bne	0x8010ccc <spi_stm32_shift_s+0x384> @ imm = #0x1e
 8010cac: 4b80         	ldr	r3, [pc, #0x200]        @ 0x8010eb0 <spi_stm32_shift_s+0x568>
 8010cae: 6819         	ldr	r1, [r3]
 8010cb0: 4b80         	ldr	r3, [pc, #0x200]        @ 0x8010eb4 <spi_stm32_shift_s+0x56c>
 8010cb2: 9302         	str	r3, [sp, #0x8]
 8010cb4: 2300         	movs	r3, #0x0
 8010cb6: 9301         	str	r3, [sp, #0x4]
 8010cb8: 2300         	movs	r3, #0x0
 8010cba: 9300         	str	r3, [sp]
 8010cbc: 2300         	movs	r3, #0x0
 8010cbe: 2201         	movs	r2, #0x1
 8010cc0: 2000         	movs	r0, #0x0
 8010cc2: f013 fd4d    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x13a9a
 8010cc6: 2300         	movs	r3, #0x0
 8010cc8: 62fb         	str	r3, [r7, #0x2c]
; 		return;
 8010cca: e0ed         	b	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0x1da
 8010ccc: e0ec         	b	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0x1d8
; 	ctx->rx_len -= len;
 8010cce: 6bfb         	ldr	r3, [r7, #0x3c]
 8010cd0: 6d1a         	ldr	r2, [r3, #0x50]
 8010cd2: 6b7b         	ldr	r3, [r7, #0x34]
 8010cd4: 1ad2         	subs	r2, r2, r3
 8010cd6: 6bfb         	ldr	r3, [r7, #0x3c]
 8010cd8: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 8010cda: 6bfb         	ldr	r3, [r7, #0x3c]
 8010cdc: 6d1b         	ldr	r3, [r3, #0x50]
 8010cde: 2b00         	cmp	r3, #0x0
 8010ce0: d11b         	bne	0x8010d1a <spi_stm32_shift_s+0x3d2> @ imm = #0x36
; 		++ctx->current_rx;
 8010ce2: 6bfb         	ldr	r3, [r7, #0x3c]
 8010ce4: 6bdb         	ldr	r3, [r3, #0x3c]
 8010ce6: f103 0208    	add.w	r2, r3, #0x8
 8010cea: 6bfb         	ldr	r3, [r7, #0x3c]
 8010cec: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 8010cee: 6bfb         	ldr	r3, [r7, #0x3c]
 8010cf0: 6c1b         	ldr	r3, [r3, #0x40]
 8010cf2: 1e5a         	subs	r2, r3, #0x1
 8010cf4: 6bfb         	ldr	r3, [r7, #0x3c]
 8010cf6: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 8010cf8: 6bfb         	ldr	r3, [r7, #0x3c]
 8010cfa: f103 003c    	add.w	r0, r3, #0x3c
 8010cfe: 6bfb         	ldr	r3, [r7, #0x3c]
 8010d00: f103 0140    	add.w	r1, r3, #0x40
 8010d04: 6bfb         	ldr	r3, [r7, #0x3c]
 8010d06: f103 0250    	add.w	r2, r3, #0x50
 8010d0a: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8010d0e: f014 fa89    	bl	0x8025224 <spi_context_get_next_buf> @ imm = #0x14512
 8010d12: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 8010d14: 6bfb         	ldr	r3, [r7, #0x3c]
 8010d16: 64da         	str	r2, [r3, #0x4c]
 8010d18: e00d         	b	0x8010d36 <spi_stm32_shift_s+0x3ee> @ imm = #0x1a
; 	} else if (ctx->rx_buf) {
 8010d1a: 6bfb         	ldr	r3, [r7, #0x3c]
 8010d1c: 6cdb         	ldr	r3, [r3, #0x4c]
 8010d1e: 2b00         	cmp	r3, #0x0
 8010d20: d009         	beq	0x8010d36 <spi_stm32_shift_s+0x3ee> @ imm = #0x12
; 		ctx->rx_buf += dfs * len;
 8010d22: 6bfb         	ldr	r3, [r7, #0x3c]
 8010d24: 6cda         	ldr	r2, [r3, #0x4c]
 8010d26: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8010d2a: 6b79         	ldr	r1, [r7, #0x34]
 8010d2c: fb01 f303    	mul	r3, r1, r3
 8010d30: 441a         	add	r2, r3
 8010d32: 6bfb         	ldr	r3, [r7, #0x3c]
 8010d34: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 8010d36: 2303         	movs	r3, #0x3
 8010d38: 2b03         	cmp	r3, #0x3
 8010d3a: f240 80b5    	bls.w	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0x16a
 8010d3e: 2301         	movs	r3, #0x1
 8010d40: f887 302b    	strb.w	r3, [r7, #0x2b]
 8010d44: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8010d48: f083 0301    	eor	r3, r3, #0x1
 8010d4c: b2db         	uxtb	r3, r3
 8010d4e: 2b00         	cmp	r3, #0x0
 8010d50: f040 80aa    	bne.w	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0x154
 8010d54: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8010eb0 <spi_stm32_shift_s+0x568>
 8010d56: 6819         	ldr	r1, [r3]
 8010d58: 6bfb         	ldr	r3, [r7, #0x3c]
 8010d5a: 6cdb         	ldr	r3, [r3, #0x4c]
 8010d5c: 6bfa         	ldr	r2, [r7, #0x3c]
 8010d5e: 6d12         	ldr	r2, [r2, #0x50]
 8010d60: 9205         	str	r2, [sp, #0x14]
 8010d62: 9304         	str	r3, [sp, #0x10]
 8010d64: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8010eb8 <spi_stm32_shift_s+0x570>
 8010d66: 9303         	str	r3, [sp, #0xc]
 8010d68: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8010ebc <spi_stm32_shift_s+0x574>
 8010d6a: 9302         	str	r3, [sp, #0x8]
 8010d6c: 2308         	movs	r3, #0x8
 8010d6e: 9301         	str	r3, [sp, #0x4]
 8010d70: 2300         	movs	r3, #0x0
 8010d72: 9300         	str	r3, [sp]
 8010d74: 2300         	movs	r3, #0x0
 8010d76: 2204         	movs	r2, #0x4
 8010d78: 2000         	movs	r0, #0x0
 8010d7a: f013 fcf1    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x139e2
 8010d7e: 2300         	movs	r3, #0x0
 8010d80: 627b         	str	r3, [r7, #0x24]
; }
 8010d82: e091         	b	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0x122
; 			rx_frame = LL_SPI_ReceiveData16(spi);
 8010d84: 6878         	ldr	r0, [r7, #0x4]
 8010d86: f013 ffac    	bl	0x8024ce2 <LL_SPI_ReceiveData16> @ imm = #0x13f58
 8010d8a: 4603         	mov	r3, r0
 8010d8c: f8a7 308a    	strh.w	r3, [r7, #0x8a]
; 			UNALIGNED_PUT(rx_frame, (uint16_t *)data->ctx.rx_buf);
 8010d90: 683b         	ldr	r3, [r7]
 8010d92: 6cdb         	ldr	r3, [r3, #0x4c]
 8010d94: f8c7 3084    	str.w	r3, [r7, #0x84]
 8010d98: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8010d9c: f8b7 208a    	ldrh.w	r2, [r7, #0x8a]
 8010da0: 801a         	strh	r2, [r3]
; 			spi_context_update_rx(&data->ctx, 2, 1);
 8010da2: 683b         	ldr	r3, [r7]
 8010da4: 623b         	str	r3, [r7, #0x20]
 8010da6: 2302         	movs	r3, #0x2
 8010da8: 77fb         	strb	r3, [r7, #0x1f]
 8010daa: 2301         	movs	r3, #0x1
 8010dac: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->rx_len) {
 8010dae: 6a3b         	ldr	r3, [r7, #0x20]
 8010db0: 6d1b         	ldr	r3, [r3, #0x50]
 8010db2: 2b00         	cmp	r3, #0x0
 8010db4: d077         	beq	0x8010ea6 <spi_stm32_shift_s+0x55e> @ imm = #0xee
; 	if (len > ctx->rx_len) {
 8010db6: 6a3b         	ldr	r3, [r7, #0x20]
 8010db8: 6d1b         	ldr	r3, [r3, #0x50]
 8010dba: 69ba         	ldr	r2, [r7, #0x18]
 8010dbc: 429a         	cmp	r2, r3
 8010dbe: d91b         	bls	0x8010df8 <spi_stm32_shift_s+0x4b0> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 8010dc0: 2303         	movs	r3, #0x3
 8010dc2: 2b00         	cmp	r3, #0x0
 8010dc4: d017         	beq	0x8010df6 <spi_stm32_shift_s+0x4ae> @ imm = #0x2e
 8010dc6: 2301         	movs	r3, #0x1
 8010dc8: 75fb         	strb	r3, [r7, #0x17]
 8010dca: 7dfb         	ldrb	r3, [r7, #0x17]
 8010dcc: f083 0301    	eor	r3, r3, #0x1
 8010dd0: b2db         	uxtb	r3, r3
 8010dd2: 2b00         	cmp	r3, #0x0
 8010dd4: d10f         	bne	0x8010df6 <spi_stm32_shift_s+0x4ae> @ imm = #0x1e
 8010dd6: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8010eb0 <spi_stm32_shift_s+0x568>
 8010dd8: 6819         	ldr	r1, [r3]
 8010dda: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8010eb4 <spi_stm32_shift_s+0x56c>
 8010ddc: 9302         	str	r3, [sp, #0x8]
 8010dde: 2300         	movs	r3, #0x0
 8010de0: 9301         	str	r3, [sp, #0x4]
 8010de2: 2300         	movs	r3, #0x0
 8010de4: 9300         	str	r3, [sp]
 8010de6: 2300         	movs	r3, #0x0
 8010de8: 2201         	movs	r2, #0x1
 8010dea: 2000         	movs	r0, #0x0
 8010dec: f013 fcb8    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x13970
 8010df0: 2300         	movs	r3, #0x0
 8010df2: 613b         	str	r3, [r7, #0x10]
; 		return;
 8010df4: e058         	b	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0xb0
 8010df6: e057         	b	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0xae
; 	ctx->rx_len -= len;
 8010df8: 6a3b         	ldr	r3, [r7, #0x20]
 8010dfa: 6d1a         	ldr	r2, [r3, #0x50]
 8010dfc: 69bb         	ldr	r3, [r7, #0x18]
 8010dfe: 1ad2         	subs	r2, r2, r3
 8010e00: 6a3b         	ldr	r3, [r7, #0x20]
 8010e02: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 8010e04: 6a3b         	ldr	r3, [r7, #0x20]
 8010e06: 6d1b         	ldr	r3, [r3, #0x50]
 8010e08: 2b00         	cmp	r3, #0x0
 8010e0a: d11a         	bne	0x8010e42 <spi_stm32_shift_s+0x4fa> @ imm = #0x34
; 		++ctx->current_rx;
 8010e0c: 6a3b         	ldr	r3, [r7, #0x20]
 8010e0e: 6bdb         	ldr	r3, [r3, #0x3c]
 8010e10: f103 0208    	add.w	r2, r3, #0x8
 8010e14: 6a3b         	ldr	r3, [r7, #0x20]
 8010e16: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 8010e18: 6a3b         	ldr	r3, [r7, #0x20]
 8010e1a: 6c1b         	ldr	r3, [r3, #0x40]
 8010e1c: 1e5a         	subs	r2, r3, #0x1
 8010e1e: 6a3b         	ldr	r3, [r7, #0x20]
 8010e20: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 8010e22: 6a3b         	ldr	r3, [r7, #0x20]
 8010e24: f103 003c    	add.w	r0, r3, #0x3c
 8010e28: 6a3b         	ldr	r3, [r7, #0x20]
 8010e2a: f103 0140    	add.w	r1, r3, #0x40
 8010e2e: 6a3b         	ldr	r3, [r7, #0x20]
 8010e30: f103 0250    	add.w	r2, r3, #0x50
 8010e34: 7ffb         	ldrb	r3, [r7, #0x1f]
 8010e36: f014 f9f5    	bl	0x8025224 <spi_context_get_next_buf> @ imm = #0x143ea
 8010e3a: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 8010e3c: 6a3b         	ldr	r3, [r7, #0x20]
 8010e3e: 64da         	str	r2, [r3, #0x4c]
 8010e40: e00c         	b	0x8010e5c <spi_stm32_shift_s+0x514> @ imm = #0x18
; 	} else if (ctx->rx_buf) {
 8010e42: 6a3b         	ldr	r3, [r7, #0x20]
 8010e44: 6cdb         	ldr	r3, [r3, #0x4c]
 8010e46: 2b00         	cmp	r3, #0x0
 8010e48: d008         	beq	0x8010e5c <spi_stm32_shift_s+0x514> @ imm = #0x10
; 		ctx->rx_buf += dfs * len;
 8010e4a: 6a3b         	ldr	r3, [r7, #0x20]
 8010e4c: 6cda         	ldr	r2, [r3, #0x4c]
 8010e4e: 7ffb         	ldrb	r3, [r7, #0x1f]
 8010e50: 69b9         	ldr	r1, [r7, #0x18]
 8010e52: fb01 f303    	mul	r3, r1, r3
 8010e56: 441a         	add	r2, r3
 8010e58: 6a3b         	ldr	r3, [r7, #0x20]
 8010e5a: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 8010e5c: 2303         	movs	r3, #0x3
 8010e5e: 2b03         	cmp	r3, #0x3
 8010e60: d922         	bls	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0x44
 8010e62: 2301         	movs	r3, #0x1
 8010e64: 73fb         	strb	r3, [r7, #0xf]
 8010e66: 7bfb         	ldrb	r3, [r7, #0xf]
 8010e68: f083 0301    	eor	r3, r3, #0x1
 8010e6c: b2db         	uxtb	r3, r3
 8010e6e: 2b00         	cmp	r3, #0x0
 8010e70: d11a         	bne	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0x34
 8010e72: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8010eb0 <spi_stm32_shift_s+0x568>
 8010e74: 6819         	ldr	r1, [r3]
 8010e76: 6a3b         	ldr	r3, [r7, #0x20]
 8010e78: 6cdb         	ldr	r3, [r3, #0x4c]
 8010e7a: 6a3a         	ldr	r2, [r7, #0x20]
 8010e7c: 6d12         	ldr	r2, [r2, #0x50]
 8010e7e: 9205         	str	r2, [sp, #0x14]
 8010e80: 9304         	str	r3, [sp, #0x10]
 8010e82: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8010eb8 <spi_stm32_shift_s+0x570>
 8010e84: 9303         	str	r3, [sp, #0xc]
 8010e86: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8010ebc <spi_stm32_shift_s+0x574>
 8010e88: 9302         	str	r3, [sp, #0x8]
 8010e8a: 2308         	movs	r3, #0x8
 8010e8c: 9301         	str	r3, [sp, #0x4]
 8010e8e: 2300         	movs	r3, #0x0
 8010e90: 9300         	str	r3, [sp]
 8010e92: 2300         	movs	r3, #0x0
 8010e94: 2204         	movs	r2, #0x4
 8010e96: 2000         	movs	r0, #0x0
 8010e98: f013 fc62    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x138c4
 8010e9c: 2300         	movs	r3, #0x0
 8010e9e: 60bb         	str	r3, [r7, #0x8]
; }
 8010ea0: e002         	b	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0x4
; 		return;
 8010ea2: bf00         	nop
 8010ea4: e000         	b	0x8010ea8 <spi_stm32_shift_s+0x560> @ imm = #0x0
 8010ea6: bf00         	nop
; }
 8010ea8: bf00         	nop
 8010eaa: 3798         	adds	r7, #0x98
 8010eac: 46bd         	mov	sp, r7
 8010eae: bd80         	pop	{r7, pc}

08010eb0 <$d>:
 8010eb0: 10 07 00 24  	.word	0x24000710
 8010eb4: 38 c2 02 08  	.word	0x0802c238
 8010eb8: 58 da 02 08  	.word	0x0802da58
 8010ebc: 70 c2 02 08  	.word	0x0802c270

08010ec0 <spi_stm32_configure>:
; {
 8010ec0: b5f0         	push	{r4, r5, r6, r7, lr}
 8010ec2: b0a5         	sub	sp, #0x94
 8010ec4: af0c         	add	r7, sp, #0x30
 8010ec6: 6078         	str	r0, [r7, #0x4]
 8010ec8: 6039         	str	r1, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 8010eca: 687b         	ldr	r3, [r7, #0x4]
 8010ecc: 685b         	ldr	r3, [r3, #0x4]
 8010ece: 643b         	str	r3, [r7, #0x40]
; 	struct spi_stm32_data *data = dev->data;
 8010ed0: 687b         	ldr	r3, [r7, #0x4]
 8010ed2: 691b         	ldr	r3, [r3, #0x10]
 8010ed4: 63fb         	str	r3, [r7, #0x3c]
; 	const uint32_t scaler[] = {
 8010ed6: 4ba4         	ldr	r3, [pc, #0x290]        @ 0x8011168 <spi_stm32_configure+0x2a8>
 8010ed8: f107 040c    	add.w	r4, r7, #0xc
 8010edc: 461d         	mov	r5, r3
 8010ede: cd0f         	ldm	r5!, {r0, r1, r2, r3}
 8010ee0: c40f         	stm	r4!, {r0, r1, r2, r3}
 8010ee2: e895 000f    	ldm.w	r5, {r0, r1, r2, r3}
 8010ee6: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
; 	SPI_TypeDef *spi = cfg->spi;
 8010eea: 6c3b         	ldr	r3, [r7, #0x40]
 8010eec: 681b         	ldr	r3, [r3]
 8010eee: 65fb         	str	r3, [r7, #0x5c]
; 	if (spi_context_configured(&data->ctx, config)) {
 8010ef0: 6bfb         	ldr	r3, [r7, #0x3c]
 8010ef2: 6839         	ldr	r1, [r7]
 8010ef4: 4618         	mov	r0, r3
 8010ef6: f014 f8cd    	bl	0x8025094 <spi_context_configured> @ imm = #0x1419a
 8010efa: 4603         	mov	r3, r0
 8010efc: 2b00         	cmp	r3, #0x0
 8010efe: d001         	beq	0x8010f04 <spi_stm32_configure+0x44> @ imm = #0x2
; 		return 0;
 8010f00: 2300         	movs	r3, #0x0
 8010f02: e1a6         	b	0x8011252 <spi_stm32_configure+0x392> @ imm = #0x34c
; 	if ((SPI_WORD_SIZE_GET(config->operation) != 8) &&
 8010f04: 683b         	ldr	r3, [r7]
 8010f06: 889b         	ldrh	r3, [r3, #0x4]
 8010f08: 095b         	lsrs	r3, r3, #0x5
 8010f0a: f003 033f    	and	r3, r3, #0x3f
 8010f0e: 2b08         	cmp	r3, #0x8
 8010f10: d009         	beq	0x8010f26 <spi_stm32_configure+0x66> @ imm = #0x12
; 	    (SPI_WORD_SIZE_GET(config->operation) != 16)) {
 8010f12: 683b         	ldr	r3, [r7]
 8010f14: 889b         	ldrh	r3, [r3, #0x4]
 8010f16: 095b         	lsrs	r3, r3, #0x5
 8010f18: f003 033f    	and	r3, r3, #0x3f
; 	if ((SPI_WORD_SIZE_GET(config->operation) != 8) &&
 8010f1c: 2b10         	cmp	r3, #0x10
 8010f1e: d002         	beq	0x8010f26 <spi_stm32_configure+0x66> @ imm = #0x4
; 		return -ENOTSUP;
 8010f20: f06f 0385    	mvn	r3, #0x85
 8010f24: e195         	b	0x8011252 <spi_stm32_configure+0x392> @ imm = #0x32a
; 	if ((config->operation & SPI_FRAME_FORMAT_TI) == SPI_FRAME_FORMAT_TI) {
 8010f26: 683b         	ldr	r3, [r7]
 8010f28: 889b         	ldrh	r3, [r3, #0x4]
 8010f2a: b21b         	sxth	r3, r3
 8010f2c: 2b00         	cmp	r3, #0x0
 8010f2e: da04         	bge	0x8010f3a <spi_stm32_configure+0x7a> @ imm = #0x8
; 		LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_TI);
 8010f30: f44f 2100    	mov.w	r1, #0x80000
 8010f34: 6df8         	ldr	r0, [r7, #0x5c]
 8010f36: f013 fd2d    	bl	0x8024994 <LL_SPI_SetStandard> @ imm = #0x13a5a
; 	if (IS_ENABLED(STM32_SPI_DOMAIN_CLOCK_SUPPORT) && (cfg->pclk_len > 1)) {
 8010f3a: 6c3b         	ldr	r3, [r7, #0x40]
 8010f3c: 691b         	ldr	r3, [r3, #0x10]
 8010f3e: 2b01         	cmp	r3, #0x1
 8010f40: d92a         	bls	0x8010f98 <spi_stm32_configure+0xd8> @ imm = #0x54
; 					   (clock_control_subsys_t)&cfg->pclken[1], &clock) < 0) {
 8010f42: 6c3b         	ldr	r3, [r7, #0x40]
 8010f44: 695b         	ldr	r3, [r3, #0x14]
 8010f46: 3308         	adds	r3, #0x8
; 		if (clock_control_get_rate(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 8010f48: f107 0208    	add.w	r2, r7, #0x8
 8010f4c: 4619         	mov	r1, r3
 8010f4e: 4887         	ldr	r0, [pc, #0x21c]        @ 0x801116c <spi_stm32_configure+0x2ac>
 8010f50: f014 f86a    	bl	0x8025028 <clock_control_get_rate> @ imm = #0x140d4
 8010f54: 4603         	mov	r3, r0
 8010f56: 2b00         	cmp	r3, #0x0
 8010f58: da48         	bge	0x8010fec <spi_stm32_configure+0x12c> @ imm = #0x90
; 			LOG_ERR("Failed call clock_control_get_rate(pclk[1])");
 8010f5a: 2303         	movs	r3, #0x3
 8010f5c: 2b00         	cmp	r3, #0x0
 8010f5e: d018         	beq	0x8010f92 <spi_stm32_configure+0xd2> @ imm = #0x30
 8010f60: 2301         	movs	r3, #0x1
 8010f62: f887 3053    	strb.w	r3, [r7, #0x53]
 8010f66: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8010f6a: f083 0301    	eor	r3, r3, #0x1
 8010f6e: b2db         	uxtb	r3, r3
 8010f70: 2b00         	cmp	r3, #0x0
 8010f72: d10e         	bne	0x8010f92 <spi_stm32_configure+0xd2> @ imm = #0x1c
 8010f74: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x8011170 <spi_stm32_configure+0x2b0>
 8010f76: 6819         	ldr	r1, [r3]
 8010f78: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x8011174 <spi_stm32_configure+0x2b4>
 8010f7a: 9302         	str	r3, [sp, #0x8]
 8010f7c: 2300         	movs	r3, #0x0
 8010f7e: 9301         	str	r3, [sp, #0x4]
 8010f80: 2300         	movs	r3, #0x0
 8010f82: 9300         	str	r3, [sp]
 8010f84: 2300         	movs	r3, #0x0
 8010f86: 2201         	movs	r2, #0x1
 8010f88: 2000         	movs	r0, #0x0
 8010f8a: f013 fbe9    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x137d2
 8010f8e: 2300         	movs	r3, #0x0
 8010f90: 64fb         	str	r3, [r7, #0x4c]
; 			return -EIO;
 8010f92: f06f 0304    	mvn	r3, #0x4
 8010f96: e15c         	b	0x8011252 <spi_stm32_configure+0x392> @ imm = #0x2b8
; 					   (clock_control_subsys_t)&cfg->pclken[0], &clock) < 0) {
 8010f98: 6c3b         	ldr	r3, [r7, #0x40]
 8010f9a: 695b         	ldr	r3, [r3, #0x14]
; 		if (clock_control_get_rate(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 8010f9c: f107 0208    	add.w	r2, r7, #0x8
 8010fa0: 4619         	mov	r1, r3
 8010fa2: 4872         	ldr	r0, [pc, #0x1c8]        @ 0x801116c <spi_stm32_configure+0x2ac>
 8010fa4: f014 f840    	bl	0x8025028 <clock_control_get_rate> @ imm = #0x14080
 8010fa8: 4603         	mov	r3, r0
 8010faa: 2b00         	cmp	r3, #0x0
 8010fac: da1e         	bge	0x8010fec <spi_stm32_configure+0x12c> @ imm = #0x3c
; 			LOG_ERR("Failed call clock_control_get_rate(pclk[0])");
 8010fae: 2303         	movs	r3, #0x3
 8010fb0: 2b00         	cmp	r3, #0x0
 8010fb2: d018         	beq	0x8010fe6 <spi_stm32_configure+0x126> @ imm = #0x30
 8010fb4: 2301         	movs	r3, #0x1
 8010fb6: f887 305b    	strb.w	r3, [r7, #0x5b]
 8010fba: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8010fbe: f083 0301    	eor	r3, r3, #0x1
 8010fc2: b2db         	uxtb	r3, r3
 8010fc4: 2b00         	cmp	r3, #0x0
 8010fc6: d10e         	bne	0x8010fe6 <spi_stm32_configure+0x126> @ imm = #0x1c
 8010fc8: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8011170 <spi_stm32_configure+0x2b0>
 8010fca: 6819         	ldr	r1, [r3]
 8010fcc: 4b6a         	ldr	r3, [pc, #0x1a8]        @ 0x8011178 <spi_stm32_configure+0x2b8>
 8010fce: 9302         	str	r3, [sp, #0x8]
 8010fd0: 2300         	movs	r3, #0x0
 8010fd2: 9301         	str	r3, [sp, #0x4]
 8010fd4: 2300         	movs	r3, #0x0
 8010fd6: 9300         	str	r3, [sp]
 8010fd8: 2300         	movs	r3, #0x0
 8010fda: 2201         	movs	r2, #0x1
 8010fdc: 2000         	movs	r0, #0x0
 8010fde: f013 fbbf    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x1377e
 8010fe2: 2300         	movs	r3, #0x0
 8010fe4: 657b         	str	r3, [r7, #0x54]
; 			return -EIO;
 8010fe6: f06f 0304    	mvn	r3, #0x4
 8010fea: e132         	b	0x8011252 <spi_stm32_configure+0x392> @ imm = #0x264
; 	for (br = 1; br <= ARRAY_SIZE(scaler); ++br) {
 8010fec: 2301         	movs	r3, #0x1
 8010fee: 64bb         	str	r3, [r7, #0x48]
 8010ff0: e00c         	b	0x801100c <spi_stm32_configure+0x14c> @ imm = #0x18
; 		uint32_t clk = clock >> br;
 8010ff2: 68ba         	ldr	r2, [r7, #0x8]
 8010ff4: 6cbb         	ldr	r3, [r7, #0x48]
 8010ff6: fa22 f303    	lsr.w	r3, r2, r3
 8010ffa: 647b         	str	r3, [r7, #0x44]
; 		if (clk <= config->frequency) {
 8010ffc: 683b         	ldr	r3, [r7]
 8010ffe: 681b         	ldr	r3, [r3]
 8011000: 6c7a         	ldr	r2, [r7, #0x44]
 8011002: 429a         	cmp	r2, r3
 8011004: d906         	bls	0x8011014 <spi_stm32_configure+0x154> @ imm = #0xc
; 	for (br = 1; br <= ARRAY_SIZE(scaler); ++br) {
 8011006: 6cbb         	ldr	r3, [r7, #0x48]
 8011008: 3301         	adds	r3, #0x1
 801100a: 64bb         	str	r3, [r7, #0x48]
 801100c: 6cbb         	ldr	r3, [r7, #0x48]
 801100e: 2b08         	cmp	r3, #0x8
 8011010: d9ef         	bls	0x8010ff2 <spi_stm32_configure+0x132> @ imm = #-0x22
 8011012: e000         	b	0x8011016 <spi_stm32_configure+0x156> @ imm = #0x0
; 			break;
 8011014: bf00         	nop
; 	if (br > ARRAY_SIZE(scaler)) {
 8011016: 6cbb         	ldr	r3, [r7, #0x48]
 8011018: 2b08         	cmp	r3, #0x8
 801101a: d928         	bls	0x801106e <spi_stm32_configure+0x1ae> @ imm = #0x50
; 		LOG_ERR("Unsupported frequency %uHz, max %uHz, min %uHz", config->frequency,
 801101c: 2303         	movs	r3, #0x3
 801101e: 2b00         	cmp	r3, #0x0
 8011020: d022         	beq	0x8011068 <spi_stm32_configure+0x1a8> @ imm = #0x44
 8011022: 2301         	movs	r3, #0x1
 8011024: f887 3033    	strb.w	r3, [r7, #0x33]
 8011028: f897 3033    	ldrb.w	r3, [r7, #0x33]
 801102c: f083 0301    	eor	r3, r3, #0x1
 8011030: b2db         	uxtb	r3, r3
 8011032: 2b00         	cmp	r3, #0x0
 8011034: d118         	bne	0x8011068 <spi_stm32_configure+0x1a8> @ imm = #0x30
 8011036: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8011170 <spi_stm32_configure+0x2b0>
 8011038: 6818         	ldr	r0, [r3]
 801103a: 683b         	ldr	r3, [r7]
 801103c: 681b         	ldr	r3, [r3]
 801103e: 68ba         	ldr	r2, [r7, #0x8]
 8011040: 0852         	lsrs	r2, r2, #0x1
 8011042: 68b9         	ldr	r1, [r7, #0x8]
 8011044: 0a09         	lsrs	r1, r1, #0x8
 8011046: 9105         	str	r1, [sp, #0x14]
 8011048: 9204         	str	r2, [sp, #0x10]
 801104a: 9303         	str	r3, [sp, #0xc]
 801104c: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x801117c <spi_stm32_configure+0x2bc>
 801104e: 9302         	str	r3, [sp, #0x8]
 8011050: 2300         	movs	r3, #0x0
 8011052: 9301         	str	r3, [sp, #0x4]
 8011054: 2300         	movs	r3, #0x0
 8011056: 9300         	str	r3, [sp]
 8011058: 2300         	movs	r3, #0x0
 801105a: 2201         	movs	r2, #0x1
 801105c: 4601         	mov	r1, r0
 801105e: 2000         	movs	r0, #0x0
 8011060: f013 fb7e    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x136fc
 8011064: 2300         	movs	r3, #0x0
 8011066: 62fb         	str	r3, [r7, #0x2c]
; 		return -EINVAL;
 8011068: f06f 0315    	mvn	r3, #0x15
 801106c: e0f1         	b	0x8011252 <spi_stm32_configure+0x392> @ imm = #0x1e2
; 	LL_SPI_Disable(spi);
 801106e: 6df8         	ldr	r0, [r7, #0x5c]
 8011070: f013 fbe2    	bl	0x8024838 <LL_SPI_Disable> @ imm = #0x137c4
; 	LL_SPI_SetBaudRatePrescaler(spi, scaler[br - 1]);
 8011074: 6cbb         	ldr	r3, [r7, #0x48]
 8011076: 3b01         	subs	r3, #0x1
 8011078: 009b         	lsls	r3, r3, #0x2
 801107a: 3360         	adds	r3, #0x60
 801107c: 443b         	add	r3, r7
 801107e: f853 3c54    	ldr	r3, [r3, #-84]
 8011082: 4619         	mov	r1, r3
 8011084: 6df8         	ldr	r0, [r7, #0x5c]
 8011086: f013 fccc    	bl	0x8024a22 <LL_SPI_SetBaudRatePrescaler> @ imm = #0x13998
; 	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPOL) {
 801108a: 683b         	ldr	r3, [r7]
 801108c: 889b         	ldrh	r3, [r3, #0x4]
 801108e: f003 0302    	and	r3, r3, #0x2
 8011092: 2b00         	cmp	r3, #0x0
 8011094: d005         	beq	0x80110a2 <spi_stm32_configure+0x1e2> @ imm = #0xa
; 		LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_HIGH);
 8011096: f04f 7100    	mov.w	r1, #0x2000000
 801109a: 6df8         	ldr	r0, [r7, #0x5c]
 801109c: f013 fca0    	bl	0x80249e0 <LL_SPI_SetClockPolarity> @ imm = #0x13940
 80110a0: e003         	b	0x80110aa <spi_stm32_configure+0x1ea> @ imm = #0x6
; 		LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_LOW);
 80110a2: 2100         	movs	r1, #0x0
 80110a4: 6df8         	ldr	r0, [r7, #0x5c]
 80110a6: f013 fc9b    	bl	0x80249e0 <LL_SPI_SetClockPolarity> @ imm = #0x13936
; 	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPHA) {
 80110aa: 683b         	ldr	r3, [r7]
 80110ac: 889b         	ldrh	r3, [r3, #0x4]
 80110ae: f003 0304    	and	r3, r3, #0x4
 80110b2: 2b00         	cmp	r3, #0x0
 80110b4: d005         	beq	0x80110c2 <spi_stm32_configure+0x202> @ imm = #0xa
; 		LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_2EDGE);
 80110b6: f04f 7180    	mov.w	r1, #0x1000000
 80110ba: 6df8         	ldr	r0, [r7, #0x5c]
 80110bc: f013 fc7d    	bl	0x80249ba <LL_SPI_SetClockPhase> @ imm = #0x138fa
 80110c0: e003         	b	0x80110ca <spi_stm32_configure+0x20a> @ imm = #0x6
; 		LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_1EDGE);
 80110c2: 2100         	movs	r1, #0x0
 80110c4: 6df8         	ldr	r0, [r7, #0x5c]
 80110c6: f013 fc78    	bl	0x80249ba <LL_SPI_SetClockPhase> @ imm = #0x138f0
; 	LL_SPI_SetTransferDirection(spi, LL_SPI_FULL_DUPLEX);
 80110ca: 2100         	movs	r1, #0x0
 80110cc: 6df8         	ldr	r0, [r7, #0x5c]
 80110ce: f013 fcce    	bl	0x8024a6e <LL_SPI_SetTransferDirection> @ imm = #0x1399c
; 	if (config->operation & SPI_TRANSFER_LSB) {
 80110d2: 683b         	ldr	r3, [r7]
 80110d4: 889b         	ldrh	r3, [r3, #0x4]
 80110d6: f003 0310    	and	r3, r3, #0x10
 80110da: 2b00         	cmp	r3, #0x0
 80110dc: d005         	beq	0x80110ea <spi_stm32_configure+0x22a> @ imm = #0xa
; 		LL_SPI_SetTransferBitOrder(spi, LL_SPI_LSB_FIRST);
 80110de: f44f 0100    	mov.w	r1, #0x800000
 80110e2: 6df8         	ldr	r0, [r7, #0x5c]
 80110e4: f013 fcb0    	bl	0x8024a48 <LL_SPI_SetTransferBitOrder> @ imm = #0x13960
 80110e8: e003         	b	0x80110f2 <spi_stm32_configure+0x232> @ imm = #0x6
; 		LL_SPI_SetTransferBitOrder(spi, LL_SPI_MSB_FIRST);
 80110ea: 2100         	movs	r1, #0x0
 80110ec: 6df8         	ldr	r0, [r7, #0x5c]
 80110ee: f013 fcab    	bl	0x8024a48 <LL_SPI_SetTransferBitOrder> @ imm = #0x13956
; 	LL_SPI_DisableCRC(spi);
 80110f2: 6df8         	ldr	r0, [r7, #0x5c]
 80110f4: f013 fd00    	bl	0x8024af8 <LL_SPI_DisableCRC> @ imm = #0x13a00
; 	if (spi_cs_is_gpio(config) || !IS_ENABLED(CONFIG_SPI_STM32_USE_HW_SS)) {
 80110f8: 6838         	ldr	r0, [r7]
 80110fa: f013 ff36    	bl	0x8024f6a <spi_cs_is_gpio> @ imm = #0x13e6c
 80110fe: 4603         	mov	r3, r0
 8011100: 2b00         	cmp	r3, #0x0
 8011102: d016         	beq	0x8011132 <spi_stm32_configure+0x272> @ imm = #0x2c
; 		if (SPI_OP_MODE_GET(config->operation) == SPI_OP_MODE_MASTER) {
 8011104: 683b         	ldr	r3, [r7]
 8011106: 889b         	ldrh	r3, [r3, #0x4]
 8011108: f003 0301    	and	r3, r3, #0x1
 801110c: 2b00         	cmp	r3, #0x0
 801110e: d10a         	bne	0x8011126 <spi_stm32_configure+0x266> @ imm = #0x14
; 			if (LL_SPI_GetNSSPolarity(spi) == LL_SPI_NSS_POLARITY_LOW) {
 8011110: 6df8         	ldr	r0, [r7, #0x5c]
 8011112: f013 fc78    	bl	0x8024a06 <LL_SPI_GetNSSPolarity> @ imm = #0x138f0
 8011116: 4603         	mov	r3, r0
 8011118: 2b00         	cmp	r3, #0x0
 801111a: d104         	bne	0x8011126 <spi_stm32_configure+0x266> @ imm = #0x8
; 				LL_SPI_SetInternalSSLevel(spi, LL_SPI_SS_LEVEL_HIGH);
 801111c: f44f 5180    	mov.w	r1, #0x1000
 8011120: 6df8         	ldr	r0, [r7, #0x5c]
 8011122: f013 fc00    	bl	0x8024926 <LL_SPI_SetInternalSSLevel> @ imm = #0x13800
; 		LL_SPI_SetNSSMode(spi, LL_SPI_NSS_SOFT);
 8011126: f04f 6180    	mov.w	r1, #0x4000000
 801112a: 6df8         	ldr	r0, [r7, #0x5c]
 801112c: f013 fcf4    	bl	0x8024b18 <LL_SPI_SetNSSMode> @ imm = #0x139e8
 8011130: e00f         	b	0x8011152 <spi_stm32_configure+0x292> @ imm = #0x1e
; 		if (config->operation & SPI_OP_MODE_SLAVE) {
 8011132: 683b         	ldr	r3, [r7]
 8011134: 889b         	ldrh	r3, [r3, #0x4]
 8011136: f003 0301    	and	r3, r3, #0x1
 801113a: 2b00         	cmp	r3, #0x0
 801113c: d004         	beq	0x8011148 <spi_stm32_configure+0x288> @ imm = #0x8
; 			LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_INPUT);
 801113e: 2100         	movs	r1, #0x0
 8011140: 6df8         	ldr	r0, [r7, #0x5c]
 8011142: f013 fce9    	bl	0x8024b18 <LL_SPI_SetNSSMode> @ imm = #0x139d2
 8011146: e004         	b	0x8011152 <spi_stm32_configure+0x292> @ imm = #0x8
; 			LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_OUTPUT);
 8011148: f04f 5100    	mov.w	r1, #0x20000000
 801114c: 6df8         	ldr	r0, [r7, #0x5c]
 801114e: f013 fce3    	bl	0x8024b18 <LL_SPI_SetNSSMode> @ imm = #0x139c6
; 	if (config->operation & SPI_OP_MODE_SLAVE) {
 8011152: 683b         	ldr	r3, [r7]
 8011154: 889b         	ldrh	r3, [r3, #0x4]
 8011156: f003 0301    	and	r3, r3, #0x1
 801115a: 2b00         	cmp	r3, #0x0
 801115c: d010         	beq	0x8011180 <spi_stm32_configure+0x2c0> @ imm = #0x20
; 		LL_SPI_SetMode(spi, LL_SPI_MODE_SLAVE);
 801115e: 2100         	movs	r1, #0x0
 8011160: 6df8         	ldr	r0, [r7, #0x5c]
 8011162: f013 fb8c    	bl	0x802487e <LL_SPI_SetMode> @ imm = #0x13718
 8011166: e010         	b	0x801118a <spi_stm32_configure+0x2ca> @ imm = #0x20

08011168 <$d>:
 8011168: 64 c3 02 08  	.word	0x0802c364
 801116c: c0 96 02 08  	.word	0x080296c0
 8011170: 10 07 00 24  	.word	0x24000710
 8011174: 94 c2 02 08  	.word	0x0802c294
 8011178: c0 c2 02 08  	.word	0x0802c2c0
 801117c: ec c2 02 08  	.word	0x0802c2ec

08011180 <$t>:
; 		LL_SPI_SetMode(spi, LL_SPI_MODE_MASTER);
 8011180: f44f 0180    	mov.w	r1, #0x400000
 8011184: 6df8         	ldr	r0, [r7, #0x5c]
 8011186: f013 fb7a    	bl	0x802487e <LL_SPI_SetMode> @ imm = #0x136f4
; 	if (SPI_WORD_SIZE_GET(config->operation) == 8) {
 801118a: 683b         	ldr	r3, [r7]
 801118c: 889b         	ldrh	r3, [r3, #0x4]
 801118e: 095b         	lsrs	r3, r3, #0x5
 8011190: f003 033f    	and	r3, r3, #0x3f
 8011194: 2b08         	cmp	r3, #0x8
 8011196: d104         	bne	0x80111a2 <spi_stm32_configure+0x2e2> @ imm = #0x8
; 		LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_8BIT);
 8011198: 2107         	movs	r1, #0x7
 801119a: 6df8         	ldr	r0, [r7, #0x5c]
 801119c: f013 fc86    	bl	0x8024aac <LL_SPI_SetDataWidth> @ imm = #0x1390c
 80111a0: e003         	b	0x80111aa <spi_stm32_configure+0x2ea> @ imm = #0x6
; 		LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_16BIT);
 80111a2: 210f         	movs	r1, #0xf
 80111a4: 6df8         	ldr	r0, [r7, #0x5c]
 80111a6: f013 fc81    	bl	0x8024aac <LL_SPI_SetDataWidth> @ imm = #0x13902
; 	LL_SPI_SetMasterSSIdleness(spi, cfg->mssi_clocks);
 80111aa: 6c3b         	ldr	r3, [r7, #0x40]
 80111ac: 68db         	ldr	r3, [r3, #0xc]
 80111ae: 4619         	mov	r1, r3
 80111b0: 6df8         	ldr	r0, [r7, #0x5c]
 80111b2: f013 fb85    	bl	0x80248c0 <LL_SPI_SetMasterSSIdleness> @ imm = #0x1370a
; 	LL_SPI_SetInterDataIdleness(spi, (cfg->midi_clocks << SPI_CFG2_MIDI_Pos));
 80111b6: 6c3b         	ldr	r3, [r7, #0x40]
 80111b8: 689b         	ldr	r3, [r3, #0x8]
 80111ba: 011b         	lsls	r3, r3, #0x4
 80111bc: 4619         	mov	r1, r3
 80111be: 6df8         	ldr	r0, [r7, #0x5c]
 80111c0: f013 fb91    	bl	0x80248e6 <LL_SPI_SetInterDataIdleness> @ imm = #0x13722
; 	ll_func_set_fifo_threshold_8bit(spi);
 80111c4: 6df8         	ldr	r0, [r7, #0x5c]
 80111c6: f014 f8a4    	bl	0x8025312 <ll_func_set_fifo_threshold_8bit> @ imm = #0x14148
; 	data->ctx.config = config;
 80111ca: 6bfb         	ldr	r3, [r7, #0x3c]
 80111cc: 683a         	ldr	r2, [r7]
 80111ce: 601a         	str	r2, [r3]
; 	LOG_DBG("Installed config %p: freq %uHz (div = %u),"
 80111d0: 2303         	movs	r3, #0x3
 80111d2: 2b03         	cmp	r3, #0x3
 80111d4: d93c         	bls	0x8011250 <spi_stm32_configure+0x390> @ imm = #0x78
 80111d6: 2301         	movs	r3, #0x1
 80111d8: f887 303b    	strb.w	r3, [r7, #0x3b]
 80111dc: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 80111e0: f083 0301    	eor	r3, r3, #0x1
 80111e4: b2db         	uxtb	r3, r3
 80111e6: 2b00         	cmp	r3, #0x0
 80111e8: d132         	bne	0x8011250 <spi_stm32_configure+0x390> @ imm = #0x64
 80111ea: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x801125c <spi_stm32_configure+0x39c>
 80111ec: 681e         	ldr	r6, [r3]
 80111ee: 68ba         	ldr	r2, [r7, #0x8]
 80111f0: 6cbb         	ldr	r3, [r7, #0x48]
 80111f2: fa22 f303    	lsr.w	r3, r2, r3
 80111f6: 2101         	movs	r1, #0x1
 80111f8: 6cba         	ldr	r2, [r7, #0x48]
 80111fa: fa01 f202    	lsl.w	r2, r1, r2
 80111fe: 6839         	ldr	r1, [r7]
 8011200: 8889         	ldrh	r1, [r1, #0x4]
 8011202: 0849         	lsrs	r1, r1, #0x1
 8011204: f001 0101    	and	r1, r1, #0x1
 8011208: 6838         	ldr	r0, [r7]
 801120a: 8880         	ldrh	r0, [r0, #0x4]
 801120c: 0880         	lsrs	r0, r0, #0x2
 801120e: f000 0001    	and	r0, r0, #0x1
 8011212: 683c         	ldr	r4, [r7]
 8011214: 88a4         	ldrh	r4, [r4, #0x4]
 8011216: 08e4         	lsrs	r4, r4, #0x3
 8011218: f004 0401    	and	r4, r4, #0x1
 801121c: 683d         	ldr	r5, [r7]
 801121e: 88ed         	ldrh	r5, [r5, #0x6]
 8011220: 950a         	str	r5, [sp, #0x28]
 8011222: 9409         	str	r4, [sp, #0x24]
 8011224: 9008         	str	r0, [sp, #0x20]
 8011226: 9107         	str	r1, [sp, #0x1c]
 8011228: 9206         	str	r2, [sp, #0x18]
 801122a: 9305         	str	r3, [sp, #0x14]
 801122c: 683b         	ldr	r3, [r7]
 801122e: 9304         	str	r3, [sp, #0x10]
 8011230: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8011260 <spi_stm32_configure+0x3a0>
 8011232: 9303         	str	r3, [sp, #0xc]
 8011234: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8011264 <spi_stm32_configure+0x3a4>
 8011236: 9302         	str	r3, [sp, #0x8]
 8011238: 2308         	movs	r3, #0x8
 801123a: 9301         	str	r3, [sp, #0x4]
 801123c: 2300         	movs	r3, #0x0
 801123e: 9300         	str	r3, [sp]
 8011240: 2300         	movs	r3, #0x0
 8011242: 2204         	movs	r2, #0x4
 8011244: 4631         	mov	r1, r6
 8011246: 2000         	movs	r0, #0x0
 8011248: f013 fa8a    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x13514
 801124c: 2300         	movs	r3, #0x0
 801124e: 637b         	str	r3, [r7, #0x34]
; 	return 0;
 8011250: 2300         	movs	r3, #0x0
; }
 8011252: 4618         	mov	r0, r3
 8011254: 3764         	adds	r7, #0x64
 8011256: 46bd         	mov	sp, r7
 8011258: bdf0         	pop	{r4, r5, r6, r7, pc}
 801125a: bf00         	nop

0801125c <$d>:
 801125c: 10 07 00 24  	.word	0x24000710
 8011260: 84 da 02 08  	.word	0x0802da84
 8011264: 1c c3 02 08  	.word	0x0802c31c

08011268 <spi_stm32_init>:
; {
 8011268: b580         	push	{r7, lr}
 801126a: b092         	sub	sp, #0x48
 801126c: af04         	add	r7, sp, #0x10
 801126e: 6078         	str	r0, [r7, #0x4]
; 	struct spi_stm32_data *data __attribute__((unused)) = dev->data;
 8011270: 687b         	ldr	r3, [r7, #0x4]
 8011272: 691b         	ldr	r3, [r3, #0x10]
 8011274: 637b         	str	r3, [r7, #0x34]
; 	const struct spi_stm32_config *cfg = dev->config;
 8011276: 687b         	ldr	r3, [r7, #0x4]
 8011278: 685b         	ldr	r3, [r3, #0x4]
 801127a: 633b         	str	r3, [r7, #0x30]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 801127c: 4861         	ldr	r0, [pc, #0x184]        @ 0x8011404 <spi_stm32_init+0x19c>
 801127e: f013 fa63    	bl	0x8024748 <device_is_ready> @ imm = #0x134c6
 8011282: 4603         	mov	r3, r0
 8011284: f083 0301    	eor	r3, r3, #0x1
 8011288: b2db         	uxtb	r3, r3
 801128a: 2b00         	cmp	r3, #0x0
 801128c: d01c         	beq	0x80112c8 <spi_stm32_init+0x60> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 801128e: 2303         	movs	r3, #0x3
 8011290: 2b00         	cmp	r3, #0x0
 8011292: d016         	beq	0x80112c2 <spi_stm32_init+0x5a> @ imm = #0x2c
 8011294: 2301         	movs	r3, #0x1
 8011296: 74fb         	strb	r3, [r7, #0x13]
 8011298: 7cfb         	ldrb	r3, [r7, #0x13]
 801129a: f083 0301    	eor	r3, r3, #0x1
 801129e: b2db         	uxtb	r3, r3
 80112a0: 2b00         	cmp	r3, #0x0
 80112a2: d10e         	bne	0x80112c2 <spi_stm32_init+0x5a> @ imm = #0x1c
 80112a4: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8011408 <spi_stm32_init+0x1a0>
 80112a6: 6819         	ldr	r1, [r3]
 80112a8: 4b58         	ldr	r3, [pc, #0x160]        @ 0x801140c <spi_stm32_init+0x1a4>
 80112aa: 9302         	str	r3, [sp, #0x8]
 80112ac: 2300         	movs	r3, #0x0
 80112ae: 9301         	str	r3, [sp, #0x4]
 80112b0: 2300         	movs	r3, #0x0
 80112b2: 9300         	str	r3, [sp]
 80112b4: 2300         	movs	r3, #0x0
 80112b6: 2201         	movs	r2, #0x1
 80112b8: 2000         	movs	r0, #0x0
 80112ba: f013 fa51    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x134a2
 80112be: 2300         	movs	r3, #0x0
 80112c0: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 80112c2: f06f 0312    	mvn	r3, #0x12
 80112c6: e098         	b	0x80113fa <spi_stm32_init+0x192> @ imm = #0x130
; 			       (clock_control_subsys_t)&cfg->pclken[0]);
 80112c8: 6b3b         	ldr	r3, [r7, #0x30]
 80112ca: 695b         	ldr	r3, [r3, #0x14]
; 	err = clock_control_on(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 80112cc: 4619         	mov	r1, r3
 80112ce: 484d         	ldr	r0, [pc, #0x134]        @ 0x8011404 <spi_stm32_init+0x19c>
 80112d0: f013 fe98    	bl	0x8025004 <clock_control_on> @ imm = #0x13d30
 80112d4: 62f8         	str	r0, [r7, #0x2c]
; 	if (err < 0) {
 80112d6: 6afb         	ldr	r3, [r7, #0x2c]
 80112d8: 2b00         	cmp	r3, #0x0
 80112da: da1b         	bge	0x8011314 <spi_stm32_init+0xac> @ imm = #0x36
; 		LOG_ERR("Could not enable SPI clock");
 80112dc: 2303         	movs	r3, #0x3
 80112de: 2b00         	cmp	r3, #0x0
 80112e0: d016         	beq	0x8011310 <spi_stm32_init+0xa8> @ imm = #0x2c
 80112e2: 2301         	movs	r3, #0x1
 80112e4: 76fb         	strb	r3, [r7, #0x1b]
 80112e6: 7efb         	ldrb	r3, [r7, #0x1b]
 80112e8: f083 0301    	eor	r3, r3, #0x1
 80112ec: b2db         	uxtb	r3, r3
 80112ee: 2b00         	cmp	r3, #0x0
 80112f0: d10e         	bne	0x8011310 <spi_stm32_init+0xa8> @ imm = #0x1c
 80112f2: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8011408 <spi_stm32_init+0x1a0>
 80112f4: 6819         	ldr	r1, [r3]
 80112f6: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8011410 <spi_stm32_init+0x1a8>
 80112f8: 9302         	str	r3, [sp, #0x8]
 80112fa: 2300         	movs	r3, #0x0
 80112fc: 9301         	str	r3, [sp, #0x4]
 80112fe: 2300         	movs	r3, #0x0
 8011300: 9300         	str	r3, [sp]
 8011302: 2300         	movs	r3, #0x0
 8011304: 2201         	movs	r2, #0x1
 8011306: 2000         	movs	r0, #0x0
 8011308: f013 fa2a    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x13454
 801130c: 2300         	movs	r3, #0x0
 801130e: 617b         	str	r3, [r7, #0x14]
; 		return err;
 8011310: 6afb         	ldr	r3, [r7, #0x2c]
 8011312: e072         	b	0x80113fa <spi_stm32_init+0x192> @ imm = #0xe4
; 	if (IS_ENABLED(STM32_SPI_DOMAIN_CLOCK_SUPPORT) && (cfg->pclk_len > 1)) {
 8011314: 6b3b         	ldr	r3, [r7, #0x30]
 8011316: 691b         	ldr	r3, [r3, #0x10]
 8011318: 2b01         	cmp	r3, #0x1
 801131a: d929         	bls	0x8011370 <spi_stm32_init+0x108> @ imm = #0x52
; 					      (clock_control_subsys_t)&cfg->pclken[1], NULL);
 801131c: 6b3b         	ldr	r3, [r7, #0x30]
 801131e: 695b         	ldr	r3, [r3, #0x14]
 8011320: 3308         	adds	r3, #0x8
; 		err = clock_control_configure(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 8011322: 2200         	movs	r2, #0x0
 8011324: 4619         	mov	r1, r3
 8011326: 4837         	ldr	r0, [pc, #0xdc]         @ 0x8011404 <spi_stm32_init+0x19c>
 8011328: f013 fe99    	bl	0x802505e <clock_control_configure> @ imm = #0x13d32
 801132c: 62f8         	str	r0, [r7, #0x2c]
; 		if (err < 0) {
 801132e: 6afb         	ldr	r3, [r7, #0x2c]
 8011330: 2b00         	cmp	r3, #0x0
 8011332: da1d         	bge	0x8011370 <spi_stm32_init+0x108> @ imm = #0x3a
; 			LOG_ERR("Could not select SPI domain clock");
 8011334: 2303         	movs	r3, #0x3
 8011336: 2b00         	cmp	r3, #0x0
 8011338: d018         	beq	0x801136c <spi_stm32_init+0x104> @ imm = #0x30
 801133a: 2301         	movs	r3, #0x1
 801133c: f887 302b    	strb.w	r3, [r7, #0x2b]
 8011340: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8011344: f083 0301    	eor	r3, r3, #0x1
 8011348: b2db         	uxtb	r3, r3
 801134a: 2b00         	cmp	r3, #0x0
 801134c: d10e         	bne	0x801136c <spi_stm32_init+0x104> @ imm = #0x1c
 801134e: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8011408 <spi_stm32_init+0x1a0>
 8011350: 6819         	ldr	r1, [r3]
 8011352: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8011414 <spi_stm32_init+0x1ac>
 8011354: 9302         	str	r3, [sp, #0x8]
 8011356: 2300         	movs	r3, #0x0
 8011358: 9301         	str	r3, [sp, #0x4]
 801135a: 2300         	movs	r3, #0x0
 801135c: 9300         	str	r3, [sp]
 801135e: 2300         	movs	r3, #0x0
 8011360: 2201         	movs	r2, #0x1
 8011362: 2000         	movs	r0, #0x0
 8011364: f013 f9fc    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x133f8
 8011368: 2300         	movs	r3, #0x0
 801136a: 627b         	str	r3, [r7, #0x24]
; 			return err;
 801136c: 6afb         	ldr	r3, [r7, #0x2c]
 801136e: e044         	b	0x80113fa <spi_stm32_init+0x192> @ imm = #0x88
; 	if (!spi_stm32_is_subghzspi(dev)) {
 8011370: 6878         	ldr	r0, [r7, #0x4]
 8011372: f014 fa42    	bl	0x80257fa <spi_stm32_is_subghzspi> @ imm = #0x14484
 8011376: 4603         	mov	r3, r0
 8011378: f083 0301    	eor	r3, r3, #0x1
 801137c: b2db         	uxtb	r3, r3
 801137e: 2b00         	cmp	r3, #0x0
 8011380: d029         	beq	0x80113d6 <spi_stm32_init+0x16e> @ imm = #0x52
; 		err = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
 8011382: 6b3b         	ldr	r3, [r7, #0x30]
 8011384: 685b         	ldr	r3, [r3, #0x4]
 8011386: 2100         	movs	r1, #0x0
 8011388: 4618         	mov	r0, r3
 801138a: f013 fe13    	bl	0x8024fb4 <pinctrl_apply_state> @ imm = #0x13c26
 801138e: 62f8         	str	r0, [r7, #0x2c]
; 		if (err < 0) {
 8011390: 6afb         	ldr	r3, [r7, #0x2c]
 8011392: 2b00         	cmp	r3, #0x0
 8011394: da1f         	bge	0x80113d6 <spi_stm32_init+0x16e> @ imm = #0x3e
; 			LOG_ERR("SPI pinctrl setup failed (%d)", err);
 8011396: 2303         	movs	r3, #0x3
 8011398: 2b00         	cmp	r3, #0x0
 801139a: d01a         	beq	0x80113d2 <spi_stm32_init+0x16a> @ imm = #0x34
 801139c: 2301         	movs	r3, #0x1
 801139e: f887 3023    	strb.w	r3, [r7, #0x23]
 80113a2: f897 3023    	ldrb.w	r3, [r7, #0x23]
 80113a6: f083 0301    	eor	r3, r3, #0x1
 80113aa: b2db         	uxtb	r3, r3
 80113ac: 2b00         	cmp	r3, #0x0
 80113ae: d110         	bne	0x80113d2 <spi_stm32_init+0x16a> @ imm = #0x20
 80113b0: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8011408 <spi_stm32_init+0x1a0>
 80113b2: 6819         	ldr	r1, [r3]
 80113b4: 6afb         	ldr	r3, [r7, #0x2c]
 80113b6: 9303         	str	r3, [sp, #0xc]
 80113b8: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8011418 <spi_stm32_init+0x1b0>
 80113ba: 9302         	str	r3, [sp, #0x8]
 80113bc: 2300         	movs	r3, #0x0
 80113be: 9301         	str	r3, [sp, #0x4]
 80113c0: 2300         	movs	r3, #0x0
 80113c2: 9300         	str	r3, [sp]
 80113c4: 2300         	movs	r3, #0x0
 80113c6: 2201         	movs	r2, #0x1
 80113c8: 2000         	movs	r0, #0x0
 80113ca: f013 f9c9    	bl	0x8024760 <z_log_msg_runtime_create> @ imm = #0x13392
 80113ce: 2300         	movs	r3, #0x0
 80113d0: 61fb         	str	r3, [r7, #0x1c]
; 			return err;
 80113d2: 6afb         	ldr	r3, [r7, #0x2c]
 80113d4: e011         	b	0x80113fa <spi_stm32_init+0x192> @ imm = #0x22
; 	err = spi_context_cs_configure_all(&data->ctx);
 80113d6: 6b7b         	ldr	r3, [r7, #0x34]
 80113d8: 4618         	mov	r0, r3
 80113da: f7fe fe89    	bl	0x80100f0 <spi_context_cs_configure_all> @ imm = #-0x12ee
 80113de: 62f8         	str	r0, [r7, #0x2c]
; 	if (err < 0) {
 80113e0: 6afb         	ldr	r3, [r7, #0x2c]
 80113e2: 2b00         	cmp	r3, #0x0
 80113e4: da01         	bge	0x80113ea <spi_stm32_init+0x182> @ imm = #0x2
; 		return err;
 80113e6: 6afb         	ldr	r3, [r7, #0x2c]
 80113e8: e007         	b	0x80113fa <spi_stm32_init+0x192> @ imm = #0xe
; 	spi_context_unlock_unconditionally(&data->ctx);
 80113ea: 6b7b         	ldr	r3, [r7, #0x34]
 80113ec: 4618         	mov	r0, r3
 80113ee: f013 fefc    	bl	0x80251ea <spi_context_unlock_unconditionally> @ imm = #0x13df8
; 	return pm_device_runtime_enable(dev);
 80113f2: 6878         	ldr	r0, [r7, #0x4]
 80113f4: f013 fdfb    	bl	0x8024fee <pm_device_runtime_enable> @ imm = #0x13bf6
 80113f8: 4603         	mov	r3, r0
; }
 80113fa: 4618         	mov	r0, r3
 80113fc: 3738         	adds	r7, #0x38
 80113fe: 46bd         	mov	sp, r7
 8011400: bd80         	pop	{r7, pc}
 8011402: bf00         	nop

08011404 <$d>:
 8011404: c0 96 02 08  	.word	0x080296c0
 8011408: 10 07 00 24  	.word	0x24000710
 801140c: 84 c3 02 08  	.word	0x0802c384
 8011410: a4 c3 02 08  	.word	0x0802c3a4
 8011414: c0 c3 02 08  	.word	0x0802c3c0
 8011418: e4 c3 02 08  	.word	0x0802c3e4

0801141c <__NVIC_SetPriority>:
; {
 801141c: b480         	push	{r7}
 801141e: b083         	sub	sp, #0xc
 8011420: af00         	add	r7, sp, #0x0
 8011422: 4603         	mov	r3, r0
 8011424: 6039         	str	r1, [r7]
 8011426: 80fb         	strh	r3, [r7, #0x6]
;   if ((int32_t)(IRQn) >= 0)
 8011428: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 801142c: 2b00         	cmp	r3, #0x0
 801142e: db0a         	blt	0x8011446 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8011430: 683b         	ldr	r3, [r7]
 8011432: b2da         	uxtb	r2, r3
 8011434: 490c         	ldr	r1, [pc, #0x30]         @ 0x8011468 <__NVIC_SetPriority+0x4c>
 8011436: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 801143a: 0112         	lsls	r2, r2, #0x4
 801143c: b2d2         	uxtb	r2, r2
 801143e: 440b         	add	r3, r1
 8011440: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8011444: e00a         	b	0x801145c <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8011446: 683b         	ldr	r3, [r7]
 8011448: b2da         	uxtb	r2, r3
 801144a: 4908         	ldr	r1, [pc, #0x20]         @ 0x801146c <__NVIC_SetPriority+0x50>
 801144c: 88fb         	ldrh	r3, [r7, #0x6]
 801144e: f003 030f    	and	r3, r3, #0xf
 8011452: 3b04         	subs	r3, #0x4
 8011454: 0112         	lsls	r2, r2, #0x4
 8011456: b2d2         	uxtb	r2, r2
 8011458: 440b         	add	r3, r1
 801145a: 761a         	strb	r2, [r3, #0x18]
; }
 801145c: bf00         	nop
 801145e: 370c         	adds	r7, #0xc
 8011460: 46bd         	mov	sp, r7
 8011462: f85d 7b04    	ldr	r7, [sp], #4
 8011466: 4770         	bx	lr

08011468 <$d>:
 8011468: 00 e1 00 e0  	.word	0xe000e100
 801146c: 00 ed 00 e0  	.word	0xe000ed00

08011470 <elapsed>:
; {
 8011470: b480         	push	{r7}
 8011472: b085         	sub	sp, #0x14
 8011474: af00         	add	r7, sp, #0x0
; 	uint32_t val1 = SysTick->VAL;	/* A */
 8011476: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x80114e0 <elapsed+0x70>
 8011478: 689b         	ldr	r3, [r3, #0x8]
 801147a: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ctrl = SysTick->CTRL;	/* B */
 801147c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80114e0 <elapsed+0x70>
 801147e: 681b         	ldr	r3, [r3]
 8011480: 607b         	str	r3, [r7, #0x4]
; 	uint32_t val2 = SysTick->VAL;	/* C */
 8011482: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80114e0 <elapsed+0x70>
 8011484: 689b         	ldr	r3, [r3, #0x8]
 8011486: 60bb         	str	r3, [r7, #0x8]
; 	if (val1 == 0) {
 8011488: 68fb         	ldr	r3, [r7, #0xc]
 801148a: 2b00         	cmp	r3, #0x0
 801148c: d102         	bne	0x8011494 <elapsed+0x24> @ imm = #0x4
; 		val1 = last_load;
 801148e: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80114e4 <elapsed+0x74>
 8011490: 681b         	ldr	r3, [r3]
 8011492: 60fb         	str	r3, [r7, #0xc]
; 	if (val2 == 0) {
 8011494: 68bb         	ldr	r3, [r7, #0x8]
 8011496: 2b00         	cmp	r3, #0x0
 8011498: d102         	bne	0x80114a0 <elapsed+0x30> @ imm = #0x4
; 		val2 = last_load;
 801149a: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80114e4 <elapsed+0x74>
 801149c: 681b         	ldr	r3, [r3]
 801149e: 60bb         	str	r3, [r7, #0x8]
; 	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
 80114a0: 687b         	ldr	r3, [r7, #0x4]
 80114a2: f403 3380    	and	r3, r3, #0x10000
 80114a6: 2b00         	cmp	r3, #0x0
 80114a8: d103         	bne	0x80114b2 <elapsed+0x42> @ imm = #0x6
; 	    || (val1 < val2)) {
 80114aa: 68fa         	ldr	r2, [r7, #0xc]
 80114ac: 68bb         	ldr	r3, [r7, #0x8]
 80114ae: 429a         	cmp	r2, r3
 80114b0: d208         	bhs	0x80114c4 <elapsed+0x54> @ imm = #0x10
; 		overflow_cyc += last_load;
 80114b2: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80114e8 <elapsed+0x78>
 80114b4: 681a         	ldr	r2, [r3]
 80114b6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80114e4 <elapsed+0x74>
 80114b8: 681b         	ldr	r3, [r3]
 80114ba: 4413         	add	r3, r2
 80114bc: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80114e8 <elapsed+0x78>
 80114be: 6013         	str	r3, [r2]
; 		(void)SysTick->CTRL;
 80114c0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80114e0 <elapsed+0x70>
 80114c2: 681b         	ldr	r3, [r3]
; 	return (last_load - val2) + overflow_cyc;
 80114c4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80114e4 <elapsed+0x74>
 80114c6: 681a         	ldr	r2, [r3]
 80114c8: 68bb         	ldr	r3, [r7, #0x8]
 80114ca: 1ad2         	subs	r2, r2, r3
 80114cc: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80114e8 <elapsed+0x78>
 80114ce: 681b         	ldr	r3, [r3]
 80114d0: 4413         	add	r3, r2
; }
 80114d2: 4618         	mov	r0, r3
 80114d4: 3714         	adds	r7, #0x14
 80114d6: 46bd         	mov	sp, r7
 80114d8: f85d 7b04    	ldr	r7, [sp], #4
 80114dc: 4770         	bx	lr
 80114de: bf00         	nop

080114e0 <$d>:
 80114e0: 10 e0 00 e0  	.word	0xe000e010
 80114e4: a4 30 00 24  	.word	0x240030a4
 80114e8: a8 30 00 24  	.word	0x240030a8

080114ec <sys_clock_isr>:
; {
 80114ec: 4668         	mov	r0, sp
 80114ee: f020 0107    	bic	r1, r0, #0x7
 80114f2: 468d         	mov	sp, r1
 80114f4: e92d 4fb1    	push.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 80114f8: b085         	sub	sp, #0x14
 80114fa: af00         	add	r7, sp, #0x0
; 	elapsed();
 80114fc: f7ff ffb8    	bl	0x8011470 <elapsed>     @ imm = #-0x90
; 	cycle_count += overflow_cyc;
 8011500: 4b22         	ldr	r3, [pc, #0x88]         @ 0x801158c <sys_clock_isr+0xa0>
 8011502: 681b         	ldr	r3, [r3]
 8011504: 2200         	movs	r2, #0x0
 8011506: 4698         	mov	r8, r3
 8011508: 4691         	mov	r9, r2
 801150a: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8011590 <sys_clock_isr+0xa4>
 801150c: e9d3 2300    	ldrd	r2, r3, [r3]
 8011510: eb18 0102    	adds.w	r1, r8, r2
 8011514: 6039         	str	r1, [r7]
 8011516: eb49 0303    	adc.w	r3, r9, r3
 801151a: 607b         	str	r3, [r7, #0x4]
 801151c: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8011590 <sys_clock_isr+0xa4>
 801151e: e9d7 1200    	ldrd	r1, r2, [r7]
 8011522: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0;
 8011526: 4b19         	ldr	r3, [pc, #0x64]         @ 0x801158c <sys_clock_isr+0xa0>
 8011528: 2200         	movs	r2, #0x0
 801152a: 601a         	str	r2, [r3]
; 		dcycles = cycle_count - announced_cycles;
 801152c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8011590 <sys_clock_isr+0xa4>
 801152e: e9d3 2300    	ldrd	r2, r3, [r3]
 8011532: 4611         	mov	r1, r2
 8011534: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8011594 <sys_clock_isr+0xa8>
 8011536: e9d3 2300    	ldrd	r2, r3, [r3]
 801153a: 4613         	mov	r3, r2
 801153c: 1acb         	subs	r3, r1, r3
 801153e: 60fb         	str	r3, [r7, #0xc]
; 		dticks = dcycles / CYC_PER_TICK;
 8011540: 68fb         	ldr	r3, [r7, #0xc]
 8011542: 4a15         	ldr	r2, [pc, #0x54]         @ 0x8011598 <sys_clock_isr+0xac>
 8011544: fba2 2303    	umull	r2, r3, r2, r3
 8011548: 0bdb         	lsrs	r3, r3, #0xf
 801154a: 60bb         	str	r3, [r7, #0x8]
; 		announced_cycles += dticks * CYC_PER_TICK;
 801154c: 68bb         	ldr	r3, [r7, #0x8]
 801154e: f24d 62d8    	movw	r2, #0xd6d8
 8011552: fb02 f303    	mul	r3, r2, r3
 8011556: 2200         	movs	r2, #0x0
 8011558: 461c         	mov	r4, r3
 801155a: 4615         	mov	r5, r2
 801155c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8011594 <sys_clock_isr+0xa8>
 801155e: e9d3 2300    	ldrd	r2, r3, [r3]
 8011562: eb14 0a02    	adds.w	r10, r4, r2
 8011566: eb45 0b03    	adc.w	r11, r5, r3
 801156a: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8011594 <sys_clock_isr+0xa8>
 801156c: e9c3 ab00    	strd	r10, r11, [r3]
; 		sys_clock_announce(dticks);
 8011570: 68bb         	ldr	r3, [r7, #0x8]
 8011572: 4618         	mov	r0, r3
 8011574: f006 fed2    	bl	0x801831c <sys_clock_announce> @ imm = #0x6da4
; 	z_arm_int_exit();
 8011578: f7f4 f876    	bl	0x8005668 <z_arm_int_exit> @ imm = #-0xbf14
; }
 801157c: bf00         	nop
 801157e: 3714         	adds	r7, #0x14
 8011580: 46bd         	mov	sp, r7
 8011582: e8bd 4fb1    	pop.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 8011586: 4685         	mov	sp, r0
 8011588: 4770         	bx	lr
 801158a: bf00         	nop

0801158c <$d>:
 801158c: a8 30 00 24  	.word	0x240030a8
 8011590: 38 1f 00 24  	.word	0x24001f38
 8011594: 40 1f 00 24  	.word	0x24001f40
 8011598: 41 28 85 98  	.word	0x98852841

0801159c <sys_clock_set_timeout>:
; {
 801159c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 80115a0: b09a         	sub	sp, #0x68
 80115a2: af00         	add	r7, sp, #0x0
 80115a4: 61f8         	str	r0, [r7, #0x1c]
 80115a6: 460b         	mov	r3, r1
 80115a8: 76fb         	strb	r3, [r7, #0x1b]
; 	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
 80115aa: 7efb         	ldrb	r3, [r7, #0x1b]
 80115ac: 2b00         	cmp	r3, #0x0
 80115ae: d00e         	beq	0x80115ce <sys_clock_set_timeout+0x32> @ imm = #0x1c
 80115b0: 69fb         	ldr	r3, [r7, #0x1c]
 80115b2: f1b3 3fff    	cmp.w	r3, #0xffffffff
 80115b6: d10a         	bne	0x80115ce <sys_clock_set_timeout+0x32> @ imm = #0x14
; 		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
 80115b8: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8011784 <sys_clock_set_timeout+0x1e8>
 80115ba: 681b         	ldr	r3, [r3]
 80115bc: 4a71         	ldr	r2, [pc, #0x1c4]        @ 0x8011784 <sys_clock_set_timeout+0x1e8>
 80115be: f023 0301    	bic	r3, r3, #0x1
 80115c2: 6013         	str	r3, [r2]
; 		last_load = TIMER_STOPPED;
 80115c4: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x8011788 <sys_clock_set_timeout+0x1ec>
 80115c6: f04f 427f    	mov.w	r2, #0xff000000
 80115ca: 601a         	str	r2, [r3]
 80115cc: e0d6         	b	0x801177c <sys_clock_set_timeout+0x1e0> @ imm = #0x1ac
; 	uint32_t last_load_ = last_load;
 80115ce: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8011788 <sys_clock_set_timeout+0x1ec>
 80115d0: 681b         	ldr	r3, [r3]
 80115d2: 667b         	str	r3, [r7, #0x64]
; 	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 80115d4: 69fb         	ldr	r3, [r7, #0x1c]
 80115d6: f1b3 3fff    	cmp.w	r3, #0xffffffff
 80115da: d001         	beq	0x80115e0 <sys_clock_set_timeout+0x44> @ imm = #0x2
 80115dc: 69fb         	ldr	r3, [r7, #0x1c]
 80115de: e001         	b	0x80115e4 <sys_clock_set_timeout+0x48> @ imm = #0x2
 80115e0: f44f 7398    	mov.w	r3, #0x130
 80115e4: 61fb         	str	r3, [r7, #0x1c]
; 	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
 80115e6: 69fb         	ldr	r3, [r7, #0x1c]
 80115e8: 2b01         	cmp	r3, #0x1
 80115ea: dd07         	ble	0x80115fc <sys_clock_set_timeout+0x60> @ imm = #0xe
 80115ec: 69fb         	ldr	r3, [r7, #0x1c]
 80115ee: f240 1231    	movw	r2, #0x131
 80115f2: 4293         	cmp	r3, r2
 80115f4: bfa8         	it	ge
 80115f6: 4613         	movge	r3, r2
 80115f8: 3b01         	subs	r3, #0x1
 80115fa: e000         	b	0x80115fe <sys_clock_set_timeout+0x62> @ imm = #0x0
 80115fc: 2300         	movs	r3, #0x0
 80115fe: 61fb         	str	r3, [r7, #0x1c]
 8011600: 4b62         	ldr	r3, [pc, #0x188]        @ 0x801178c <sys_clock_set_timeout+0x1f0>
 8011602: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8011604: f3ef 8311    	mrs	r3, basepri
 8011608: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 801160a: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 801160c: 647b         	str	r3, [r7, #0x44]
 801160e: 2310         	movs	r3, #0x10
 8011610: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8011612: 6c3b         	ldr	r3, [r7, #0x40]
 8011614: f383 8812    	msr	basepri_max, r3
; }
 8011618: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801161a: f3bf 8f6f    	isb	sy
; }
 801161e: bf00         	nop
; 	return key;
 8011620: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 8011622: 623b         	str	r3, [r7, #0x20]
 8011624: 6cfb         	ldr	r3, [r7, #0x4c]
 8011626: 63fb         	str	r3, [r7, #0x3c]
; }
 8011628: bf00         	nop
 801162a: 6cfb         	ldr	r3, [r7, #0x4c]
 801162c: 63bb         	str	r3, [r7, #0x38]
; }
 801162e: bf00         	nop
; 	return k;
 8011630: 6a3b         	ldr	r3, [r7, #0x20]
 8011632: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pending = elapsed();
 8011634: f7ff ff1c    	bl	0x8011470 <elapsed>     @ imm = #-0x1c8
 8011638: 6638         	str	r0, [r7, #0x60]
; 	val1 = SysTick->VAL;
 801163a: 4b52         	ldr	r3, [pc, #0x148]        @ 0x8011784 <sys_clock_set_timeout+0x1e8>
 801163c: 689b         	ldr	r3, [r3, #0x8]
 801163e: 65fb         	str	r3, [r7, #0x5c]
; 	cycle_count += pending;
 8011640: 6e3b         	ldr	r3, [r7, #0x60]
 8011642: 2200         	movs	r2, #0x0
 8011644: 469a         	mov	r10, r3
 8011646: 4693         	mov	r11, r2
 8011648: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8011790 <sys_clock_set_timeout+0x1f4>
 801164a: e9d3 2300    	ldrd	r2, r3, [r3]
 801164e: eb1a 0102    	adds.w	r1, r10, r2
 8011652: 6139         	str	r1, [r7, #0x10]
 8011654: eb4b 0303    	adc.w	r3, r11, r3
 8011658: 617b         	str	r3, [r7, #0x14]
 801165a: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x8011790 <sys_clock_set_timeout+0x1f4>
 801165c: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 8011660: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0U;
 8011664: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8011794 <sys_clock_set_timeout+0x1f8>
 8011666: 2200         	movs	r2, #0x0
 8011668: 601a         	str	r2, [r3]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 801166a: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8011790 <sys_clock_set_timeout+0x1f4>
 801166c: e9d3 2300    	ldrd	r2, r3, [r3]
 8011670: 4611         	mov	r1, r2
 8011672: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8011798 <sys_clock_set_timeout+0x1fc>
 8011674: e9d3 2300    	ldrd	r2, r3, [r3]
 8011678: 4613         	mov	r3, r2
 801167a: 1acb         	subs	r3, r1, r3
 801167c: 65bb         	str	r3, [r7, #0x58]
; 	if ((int32_t)unannounced < 0) {
 801167e: 6dbb         	ldr	r3, [r7, #0x58]
 8011680: 2b00         	cmp	r3, #0x0
 8011682: da04         	bge	0x801168e <sys_clock_set_timeout+0xf2> @ imm = #0x8
; 		last_load = MIN_DELAY;
 8011684: 4b40         	ldr	r3, [pc, #0x100]        @ 0x8011788 <sys_clock_set_timeout+0x1ec>
 8011686: f640 526d    	movw	r2, #0xd6d
 801168a: 601a         	str	r2, [r3]
 801168c: e02c         	b	0x80116e8 <sys_clock_set_timeout+0x14c> @ imm = #0x58
; 		delay = ticks * CYC_PER_TICK;
 801168e: 69fb         	ldr	r3, [r7, #0x1c]
 8011690: f24d 62d8    	movw	r2, #0xd6d8
 8011694: fb02 f303    	mul	r3, r2, r3
 8011698: 657b         	str	r3, [r7, #0x54]
; 		delay += unannounced;
 801169a: 6d7a         	ldr	r2, [r7, #0x54]
 801169c: 6dbb         	ldr	r3, [r7, #0x58]
 801169e: 4413         	add	r3, r2
 80116a0: 657b         	str	r3, [r7, #0x54]
; 		delay = DIV_ROUND_UP(delay, CYC_PER_TICK) * CYC_PER_TICK;
 80116a2: 6d7a         	ldr	r2, [r7, #0x54]
 80116a4: f24d 63d7    	movw	r3, #0xd6d7
 80116a8: 4413         	add	r3, r2
 80116aa: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x801179c <sys_clock_set_timeout+0x200>
 80116ac: fba2 2303    	umull	r2, r3, r2, r3
 80116b0: 0bdb         	lsrs	r3, r3, #0xf
 80116b2: f24d 62d8    	movw	r2, #0xd6d8
 80116b6: fb02 f303    	mul	r3, r2, r3
 80116ba: 657b         	str	r3, [r7, #0x54]
; 		delay -= unannounced;
 80116bc: 6d7a         	ldr	r2, [r7, #0x54]
 80116be: 6dbb         	ldr	r3, [r7, #0x58]
 80116c0: 1ad3         	subs	r3, r2, r3
 80116c2: 657b         	str	r3, [r7, #0x54]
; 		delay = MAX(delay, MIN_DELAY);
 80116c4: 6d7b         	ldr	r3, [r7, #0x54]
 80116c6: f640 526d    	movw	r2, #0xd6d
 80116ca: 4293         	cmp	r3, r2
 80116cc: bf38         	it	lo
 80116ce: 4613         	movlo	r3, r2
 80116d0: 657b         	str	r3, [r7, #0x54]
; 		if (delay > MAX_CYCLES) {
 80116d2: 6d7b         	ldr	r3, [r7, #0x54]
 80116d4: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x80117a0 <sys_clock_set_timeout+0x204>
 80116d6: 4293         	cmp	r3, r2
 80116d8: d903         	bls	0x80116e2 <sys_clock_set_timeout+0x146> @ imm = #0x6
; 			last_load = MAX_CYCLES;
 80116da: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8011788 <sys_clock_set_timeout+0x1ec>
 80116dc: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x80117a0 <sys_clock_set_timeout+0x204>
 80116de: 601a         	str	r2, [r3]
 80116e0: e002         	b	0x80116e8 <sys_clock_set_timeout+0x14c> @ imm = #0x4
; 			last_load = delay;
 80116e2: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x8011788 <sys_clock_set_timeout+0x1ec>
 80116e4: 6d7b         	ldr	r3, [r7, #0x54]
 80116e6: 6013         	str	r3, [r2]
; 	val2 = SysTick->VAL;
 80116e8: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8011784 <sys_clock_set_timeout+0x1e8>
 80116ea: 689b         	ldr	r3, [r3, #0x8]
 80116ec: 653b         	str	r3, [r7, #0x50]
; 	SysTick->LOAD = last_load - 1;
 80116ee: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8011788 <sys_clock_set_timeout+0x1ec>
 80116f0: 681b         	ldr	r3, [r3]
 80116f2: 4a24         	ldr	r2, [pc, #0x90]         @ 0x8011784 <sys_clock_set_timeout+0x1e8>
 80116f4: 3b01         	subs	r3, #0x1
 80116f6: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 80116f8: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8011784 <sys_clock_set_timeout+0x1e8>
 80116fa: 2200         	movs	r2, #0x0
 80116fc: 609a         	str	r2, [r3, #0x8]
; 	if (val1 < val2) {
 80116fe: 6dfa         	ldr	r2, [r7, #0x5c]
 8011700: 6d3b         	ldr	r3, [r7, #0x50]
 8011702: 429a         	cmp	r2, r3
 8011704: d216         	bhs	0x8011734 <sys_clock_set_timeout+0x198> @ imm = #0x2c
; 		cycle_count += (val1 + (last_load_ - val2));
 8011706: 6e7a         	ldr	r2, [r7, #0x64]
 8011708: 6d3b         	ldr	r3, [r7, #0x50]
 801170a: 1ad2         	subs	r2, r2, r3
 801170c: 6dfb         	ldr	r3, [r7, #0x5c]
 801170e: 4413         	add	r3, r2
 8011710: 2200         	movs	r2, #0x0
 8011712: 4698         	mov	r8, r3
 8011714: 4691         	mov	r9, r2
 8011716: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8011790 <sys_clock_set_timeout+0x1f4>
 8011718: e9d3 2300    	ldrd	r2, r3, [r3]
 801171c: eb18 0102    	adds.w	r1, r8, r2
 8011720: 60b9         	str	r1, [r7, #0x8]
 8011722: eb49 0303    	adc.w	r3, r9, r3
 8011726: 60fb         	str	r3, [r7, #0xc]
 8011728: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8011790 <sys_clock_set_timeout+0x1f4>
 801172a: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 801172e: e9c3 1200    	strd	r1, r2, [r3]
 8011732: e012         	b	0x801175a <sys_clock_set_timeout+0x1be> @ imm = #0x24
; 		cycle_count += (val1 - val2);
 8011734: 6dfa         	ldr	r2, [r7, #0x5c]
 8011736: 6d3b         	ldr	r3, [r7, #0x50]
 8011738: 1ad3         	subs	r3, r2, r3
 801173a: 2200         	movs	r2, #0x0
 801173c: 461c         	mov	r4, r3
 801173e: 4615         	mov	r5, r2
 8011740: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8011790 <sys_clock_set_timeout+0x1f4>
 8011742: e9d3 2300    	ldrd	r2, r3, [r3]
 8011746: 18a1         	adds	r1, r4, r2
 8011748: 6039         	str	r1, [r7]
 801174a: eb45 0303    	adc.w	r3, r5, r3
 801174e: 607b         	str	r3, [r7, #0x4]
 8011750: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8011790 <sys_clock_set_timeout+0x1f4>
 8011752: e9d7 1200    	ldrd	r1, r2, [r7]
 8011756: e9c3 1200    	strd	r1, r2, [r3]
 801175a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x801178c <sys_clock_set_timeout+0x1f0>
 801175c: 637b         	str	r3, [r7, #0x34]
 801175e: 6abb         	ldr	r3, [r7, #0x28]
 8011760: 627b         	str	r3, [r7, #0x24]
; 	arch_irq_unlock(key.key);
 8011762: 6a7b         	ldr	r3, [r7, #0x24]
 8011764: 633b         	str	r3, [r7, #0x30]
 8011766: 6b3b         	ldr	r3, [r7, #0x30]
 8011768: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801176a: 6afb         	ldr	r3, [r7, #0x2c]
 801176c: f383 8811    	msr	basepri, r3
; }
 8011770: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011772: f3bf 8f6f    	isb	sy
; }
 8011776: bf00         	nop
; }
 8011778: bf00         	nop
; }
 801177a: bf00         	nop
; }
 801177c: 3768         	adds	r7, #0x68
 801177e: 46bd         	mov	sp, r7
 8011780: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08011784 <$d>:
 8011784: 10 e0 00 e0  	.word	0xe000e010
 8011788: a4 30 00 24  	.word	0x240030a4
 801178c: a4 30 00 24  	.word	0x240030a4
 8011790: 38 1f 00 24  	.word	0x24001f38
 8011794: a8 30 00 24  	.word	0x240030a8
 8011798: 40 1f 00 24  	.word	0x24001f40
 801179c: 41 28 85 98  	.word	0x98852841
 80117a0: 80 20 ff 00  	.word	0x00ff2080

080117a4 <sys_clock_elapsed>:
; {
 80117a4: b580         	push	{r7, lr}
 80117a6: b08e         	sub	sp, #0x38
 80117a8: af00         	add	r7, sp, #0x0
 80117aa: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8011834 <sys_clock_elapsed+0x90>
 80117ac: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80117ae: f3ef 8311    	mrs	r3, basepri
 80117b2: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 80117b4: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 80117b6: 61bb         	str	r3, [r7, #0x18]
 80117b8: 2310         	movs	r3, #0x10
 80117ba: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80117bc: 697b         	ldr	r3, [r7, #0x14]
 80117be: f383 8812    	msr	basepri_max, r3
; }
 80117c2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80117c4: f3bf 8f6f    	isb	sy
; }
 80117c8: bf00         	nop
; 	return key;
 80117ca: 69bb         	ldr	r3, [r7, #0x18]
; 	k.key = arch_irq_lock();
 80117cc: 607b         	str	r3, [r7, #0x4]
 80117ce: 6a3b         	ldr	r3, [r7, #0x20]
 80117d0: 613b         	str	r3, [r7, #0x10]
; }
 80117d2: bf00         	nop
 80117d4: 6a3b         	ldr	r3, [r7, #0x20]
 80117d6: 60fb         	str	r3, [r7, #0xc]
; }
 80117d8: bf00         	nop
; 	return k;
 80117da: 687b         	ldr	r3, [r7, #0x4]
 80117dc: 60bb         	str	r3, [r7, #0x8]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 80117de: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8011838 <sys_clock_elapsed+0x94>
 80117e0: e9d3 2300    	ldrd	r2, r3, [r3]
 80117e4: 4611         	mov	r1, r2
 80117e6: 4b15         	ldr	r3, [pc, #0x54]         @ 0x801183c <sys_clock_elapsed+0x98>
 80117e8: e9d3 2300    	ldrd	r2, r3, [r3]
 80117ec: 4613         	mov	r3, r2
 80117ee: 1acb         	subs	r3, r1, r3
 80117f0: 637b         	str	r3, [r7, #0x34]
; 	uint32_t cyc = elapsed() + unannounced;
 80117f2: f7ff fe3d    	bl	0x8011470 <elapsed>     @ imm = #-0x386
 80117f6: 4602         	mov	r2, r0
 80117f8: 6b7b         	ldr	r3, [r7, #0x34]
 80117fa: 4413         	add	r3, r2
 80117fc: 633b         	str	r3, [r7, #0x30]
 80117fe: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8011834 <sys_clock_elapsed+0x90>
 8011800: 62fb         	str	r3, [r7, #0x2c]
 8011802: 68bb         	ldr	r3, [r7, #0x8]
 8011804: 603b         	str	r3, [r7]
; 	arch_irq_unlock(key.key);
 8011806: 683b         	ldr	r3, [r7]
 8011808: 62bb         	str	r3, [r7, #0x28]
 801180a: 6abb         	ldr	r3, [r7, #0x28]
 801180c: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801180e: 6a7b         	ldr	r3, [r7, #0x24]
 8011810: f383 8811    	msr	basepri, r3
; }
 8011814: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011816: f3bf 8f6f    	isb	sy
; }
 801181a: bf00         	nop
; }
 801181c: bf00         	nop
; }
 801181e: bf00         	nop
; 	return cyc / CYC_PER_TICK;
 8011820: 6b3b         	ldr	r3, [r7, #0x30]
 8011822: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8011840 <sys_clock_elapsed+0x9c>
 8011824: fba2 2303    	umull	r2, r3, r2, r3
 8011828: 0bdb         	lsrs	r3, r3, #0xf
; }
 801182a: 4618         	mov	r0, r3
 801182c: 3738         	adds	r7, #0x38
 801182e: 46bd         	mov	sp, r7
 8011830: bd80         	pop	{r7, pc}
 8011832: bf00         	nop

08011834 <$d>:
 8011834: a4 30 00 24  	.word	0x240030a4
 8011838: 38 1f 00 24  	.word	0x24001f38
 801183c: 40 1f 00 24  	.word	0x24001f40
 8011840: 41 28 85 98  	.word	0x98852841

08011844 <sys_clock_cycle_get_32>:
; {
 8011844: b580         	push	{r7, lr}
 8011846: b08e         	sub	sp, #0x38
 8011848: af00         	add	r7, sp, #0x0
 801184a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x80118c0 <sys_clock_cycle_get_32+0x7c>
 801184c: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801184e: f3ef 8311    	mrs	r3, basepri
 8011852: 623b         	str	r3, [r7, #0x20]
;   return(result);
 8011854: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 8011856: 61fb         	str	r3, [r7, #0x1c]
 8011858: 2310         	movs	r3, #0x10
 801185a: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801185c: 69bb         	ldr	r3, [r7, #0x18]
 801185e: f383 8812    	msr	basepri_max, r3
; }
 8011862: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011864: f3bf 8f6f    	isb	sy
; }
 8011868: bf00         	nop
; 	return key;
 801186a: 69fb         	ldr	r3, [r7, #0x1c]
; 	k.key = arch_irq_lock();
 801186c: 60bb         	str	r3, [r7, #0x8]
 801186e: 6a7b         	ldr	r3, [r7, #0x24]
 8011870: 617b         	str	r3, [r7, #0x14]
; }
 8011872: bf00         	nop
 8011874: 6a7b         	ldr	r3, [r7, #0x24]
 8011876: 613b         	str	r3, [r7, #0x10]
; }
 8011878: bf00         	nop
; 	return k;
 801187a: 68bb         	ldr	r3, [r7, #0x8]
 801187c: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ret = cycle_count;
 801187e: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80118c4 <sys_clock_cycle_get_32+0x80>
 8011880: e9d3 2300    	ldrd	r2, r3, [r3]
 8011884: 4613         	mov	r3, r2
 8011886: 637b         	str	r3, [r7, #0x34]
; 	ret += elapsed();
 8011888: f7ff fdf2    	bl	0x8011470 <elapsed>     @ imm = #-0x41c
 801188c: 4602         	mov	r2, r0
 801188e: 6b7b         	ldr	r3, [r7, #0x34]
 8011890: 4413         	add	r3, r2
 8011892: 637b         	str	r3, [r7, #0x34]
 8011894: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80118c0 <sys_clock_cycle_get_32+0x7c>
 8011896: 633b         	str	r3, [r7, #0x30]
 8011898: 68fb         	ldr	r3, [r7, #0xc]
 801189a: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 801189c: 687b         	ldr	r3, [r7, #0x4]
 801189e: 62fb         	str	r3, [r7, #0x2c]
 80118a0: 6afb         	ldr	r3, [r7, #0x2c]
 80118a2: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80118a4: 6abb         	ldr	r3, [r7, #0x28]
 80118a6: f383 8811    	msr	basepri, r3
; }
 80118aa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80118ac: f3bf 8f6f    	isb	sy
; }
 80118b0: bf00         	nop
; }
 80118b2: bf00         	nop
; }
 80118b4: bf00         	nop
; 	return ret;
 80118b6: 6b7b         	ldr	r3, [r7, #0x34]
; }
 80118b8: 4618         	mov	r0, r3
 80118ba: 3738         	adds	r7, #0x38
 80118bc: 46bd         	mov	sp, r7
 80118be: bd80         	pop	{r7, pc}

080118c0 <$d>:
 80118c0: a4 30 00 24  	.word	0x240030a4
 80118c4: 38 1f 00 24  	.word	0x24001f38

080118c8 <sys_clock_driver_init>:
; {
 80118c8: b580         	push	{r7, lr}
 80118ca: af00         	add	r7, sp, #0x0
; 	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
 80118cc: 2101         	movs	r1, #0x1
 80118ce: f04f 30ff    	mov.w	r0, #0xffffffff
 80118d2: f7ff fda3    	bl	0x801141c <__NVIC_SetPriority> @ imm = #-0x4ba
; 	last_load = CYC_PER_TICK;
 80118d6: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8011908 <sys_clock_driver_init+0x40>
 80118d8: f24d 62d8    	movw	r2, #0xd6d8
 80118dc: 601a         	str	r2, [r3]
; 	overflow_cyc = 0U;
 80118de: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x801190c <sys_clock_driver_init+0x44>
 80118e0: 2200         	movs	r2, #0x0
 80118e2: 601a         	str	r2, [r3]
; 	SysTick->LOAD = last_load - 1;
 80118e4: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8011908 <sys_clock_driver_init+0x40>
 80118e6: 681b         	ldr	r3, [r3]
 80118e8: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8011910 <sys_clock_driver_init+0x48>
 80118ea: 3b01         	subs	r3, #0x1
 80118ec: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 80118ee: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8011910 <sys_clock_driver_init+0x48>
 80118f0: 2200         	movs	r2, #0x0
 80118f2: 609a         	str	r2, [r3, #0x8]
; 	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
 80118f4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8011910 <sys_clock_driver_init+0x48>
 80118f6: 681b         	ldr	r3, [r3]
 80118f8: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8011910 <sys_clock_driver_init+0x48>
 80118fa: f043 0307    	orr	r3, r3, #0x7
 80118fe: 6013         	str	r3, [r2]
; 	return 0;
 8011900: 2300         	movs	r3, #0x0
; }
 8011902: 4618         	mov	r0, r3
 8011904: bd80         	pop	{r7, pc}
 8011906: bf00         	nop

08011908 <$d>:
 8011908: a4 30 00 24  	.word	0x240030a4
 801190c: a8 30 00 24  	.word	0x240030a8
 8011910: 10 e0 00 e0  	.word	0xe000e010

08011914 <to16t>:
; {
 8011914: b480         	push	{r7}
 8011916: b083         	sub	sp, #0xc
 8011918: af00         	add	r7, sp, #0x0
 801191a: ed87 0a01    	<unknown>
; 	if (value > INT16_MAX) {
 801191e: edd7 7a01    	<unknown>
 8011922: ed9f 7a11    	<unknown>
 8011926: eef4 7ac7    	<unknown>
 801192a: eef1 fa10    	<unknown>
 801192e: dd02         	ble	0x8011936 <to16t+0x22>  @ imm = #0x4
; 		return INT16_MAX;
 8011930: f647 73ff    	movw	r3, #0x7fff
 8011934: e011         	b	0x801195a <to16t+0x46>  @ imm = #0x22
; 	} else if (value < INT16_MIN) {
 8011936: edd7 7a01    	<unknown>
 801193a: ed9f 7a0c    	<unknown>
 801193e: eef4 7ac7    	<unknown>
 8011942: eef1 fa10    	<unknown>
 8011946: d501         	bpl	0x801194c <to16t+0x38>  @ imm = #0x2
; 		return INT16_MIN;
 8011948: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8011970 <to16t+0x5c>
 801194a: e006         	b	0x801195a <to16t+0x46>  @ imm = #0xc
; 		return (int16_t)value;
 801194c: edd7 7a01    	<unknown>
 8011950: eefd 7ae7    	<unknown>
 8011954: ee17 3a90    	<unknown>
 8011958: b21b         	sxth	r3, r3
; }
 801195a: 4618         	mov	r0, r3
 801195c: 370c         	adds	r7, #0xc
 801195e: 46bd         	mov	sp, r7
 8011960: f85d 7b04    	ldr	r7, [sp], #4
 8011964: 4770         	bx	lr
 8011966: bf00         	nop

08011968 <$d>:
 8011968: 00 fe ff 46  	.word	0x46fffe00
 801196c: 00 00 00 c7  	.word	0xc7000000
 8011970: 00 80 ff ff  	.word	0xffff8000

08011974 <canbus_id>:
; {
 8011974: b480         	push	{r7}
 8011976: b085         	sub	sp, #0x14
 8011978: af00         	add	r7, sp, #0x0
 801197a: 6078         	str	r0, [r7, #0x4]
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 801197c: 2300         	movs	r3, #0x0
 801197e: 60fb         	str	r3, [r7, #0xc]
 8011980: e00c         	b	0x801199c <canbus_id+0x28> @ imm = #0x18
; 		if (motor_devices[i] == dev) {
 8011982: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80119b0 <canbus_id+0x3c>
 8011984: 68fb         	ldr	r3, [r7, #0xc]
 8011986: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 801198a: 687a         	ldr	r2, [r7, #0x4]
 801198c: 429a         	cmp	r2, r3
 801198e: d102         	bne	0x8011996 <canbus_id+0x22> @ imm = #0x4
; 			return i;
 8011990: 68fb         	ldr	r3, [r7, #0xc]
 8011992: b29b         	uxth	r3, r3
 8011994: e006         	b	0x80119a4 <canbus_id+0x30> @ imm = #0xc
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 8011996: 68fb         	ldr	r3, [r7, #0xc]
 8011998: 3301         	adds	r3, #0x1
 801199a: 60fb         	str	r3, [r7, #0xc]
 801199c: 68fb         	ldr	r3, [r7, #0xc]
 801199e: 2b05         	cmp	r3, #0x5
 80119a0: d9ef         	bls	0x8011982 <canbus_id+0xe> @ imm = #-0x22
; 	return 0;
 80119a2: 2300         	movs	r3, #0x0
; }
 80119a4: 4618         	mov	r0, r3
 80119a6: 3714         	adds	r7, #0x14
 80119a8: 46bd         	mov	sp, r7
 80119aa: f85d 7b04    	ldr	r7, [sp], #4
 80119ae: 4770         	bx	lr

080119b0 <$d>:
 80119b0: c8 07 00 24  	.word	0x240007c8

080119b4 <dji_set_speed>:
; {
 80119b4: b580         	push	{r7, lr}
 80119b6: b086         	sub	sp, #0x18
 80119b8: af00         	add	r7, sp, #0x0
 80119ba: 6078         	str	r0, [r7, #0x4]
 80119bc: ed87 0a00    	<unknown>
; 	struct dji_motor_data *data = dev->data;
 80119c0: 687b         	ldr	r3, [r7, #0x4]
 80119c2: 691b         	ldr	r3, [r3, #0x10]
 80119c4: 613b         	str	r3, [r7, #0x10]
; 	const struct dji_motor_config *cfg = dev->config;
 80119c6: 687b         	ldr	r3, [r7, #0x4]
 80119c8: 685b         	ldr	r3, [r3, #0x4]
 80119ca: 60fb         	str	r3, [r7, #0xc]
; 	data->target_rpm = speed_rpm;
 80119cc: 693b         	ldr	r3, [r7, #0x10]
 80119ce: 683a         	ldr	r2, [r7]
 80119d0: 645a         	str	r2, [r3, #0x44]
; 	for (int i = 0; i < sizeof(cfg->common.controller) / sizeof(cfg->common.controller[0]);
 80119d2: 2300         	movs	r3, #0x0
 80119d4: 617b         	str	r3, [r7, #0x14]
 80119d6: e025         	b	0x8011a24 <dji_set_speed+0x70> @ imm = #0x4a
; 		if (cfg->common.controller[i] == NULL) {
 80119d8: 68fb         	ldr	r3, [r7, #0xc]
 80119da: 697a         	ldr	r2, [r7, #0x14]
 80119dc: 3204         	adds	r2, #0x4
 80119de: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 80119e2: 2b00         	cmp	r3, #0x0
 80119e4: d022         	beq	0x8011a2c <dji_set_speed+0x78> @ imm = #0x44
; 		if (strcmp(cfg->common.capabilities[i], "speed") == 0) {
 80119e6: 697a         	ldr	r2, [r7, #0x14]
 80119e8: 4613         	mov	r3, r2
 80119ea: 005b         	lsls	r3, r3, #0x1
 80119ec: 4413         	add	r3, r2
 80119ee: 009b         	lsls	r3, r3, #0x2
 80119f0: 3320         	adds	r3, #0x20
 80119f2: 68fa         	ldr	r2, [r7, #0xc]
 80119f4: 4413         	add	r3, r2
 80119f6: 4910         	ldr	r1, [pc, #0x40]         @ 0x8011a38 <dji_set_speed+0x84>
 80119f8: 4618         	mov	r0, r3
 80119fa: f7ee fcd3    	bl	0x80003a4 <strcmp>      @ imm = #-0x1165a
 80119fe: 4603         	mov	r3, r0
 8011a00: 2b00         	cmp	r3, #0x0
 8011a02: d10c         	bne	0x8011a1e <dji_set_speed+0x6a> @ imm = #0x18
; 			pid_calc(cfg->common.controller[i]);
 8011a04: 68fb         	ldr	r3, [r7, #0xc]
 8011a06: 697a         	ldr	r2, [r7, #0x14]
 8011a08: 3204         	adds	r2, #0x4
 8011a0a: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8011a0e: 4618         	mov	r0, r3
 8011a10: f014 f80d    	bl	0x8025a2e <pid_calc>    @ imm = #0x1401a
; 			data->current_mode_index = i;
 8011a14: 697b         	ldr	r3, [r7, #0x14]
 8011a16: b25a         	sxtb	r2, r3
 8011a18: 693b         	ldr	r3, [r7, #0x10]
 8011a1a: f883 2022    	strb.w	r2, [r3, #0x22]
; 	     i++) {
 8011a1e: 697b         	ldr	r3, [r7, #0x14]
 8011a20: 3301         	adds	r3, #0x1
 8011a22: 617b         	str	r3, [r7, #0x14]
; 	for (int i = 0; i < sizeof(cfg->common.controller) / sizeof(cfg->common.controller[0]);
 8011a24: 697b         	ldr	r3, [r7, #0x14]
 8011a26: 2b03         	cmp	r3, #0x3
 8011a28: d9d6         	bls	0x80119d8 <dji_set_speed+0x24> @ imm = #-0x54
 8011a2a: e000         	b	0x8011a2e <dji_set_speed+0x7a> @ imm = #0x0
; 			break;
 8011a2c: bf00         	nop
; 	return 0;
 8011a2e: 2300         	movs	r3, #0x0
; }
 8011a30: 4618         	mov	r0, r3
 8011a32: 3718         	adds	r7, #0x18
 8011a34: 46bd         	mov	sp, r7
 8011a36: bd80         	pop	{r7, pc}

08011a38 <$d>:
 8011a38: 48 c4 02 08  	.word	0x0802c448

08011a3c <dji_set_angle>:
; {
 8011a3c: b580         	push	{r7, lr}
 8011a3e: b086         	sub	sp, #0x18
 8011a40: af00         	add	r7, sp, #0x0
 8011a42: 6078         	str	r0, [r7, #0x4]
 8011a44: ed87 0a00    	<unknown>
; 	struct dji_motor_data *data = dev->data;
 8011a48: 687b         	ldr	r3, [r7, #0x4]
 8011a4a: 691b         	ldr	r3, [r3, #0x10]
 8011a4c: 613b         	str	r3, [r7, #0x10]
; 	const struct dji_motor_config *cfg = dev->config;
 8011a4e: 687b         	ldr	r3, [r7, #0x4]
 8011a50: 685b         	ldr	r3, [r3, #0x4]
 8011a52: 60fb         	str	r3, [r7, #0xc]
; 	data->target_angle = angle;
 8011a54: 693b         	ldr	r3, [r7, #0x10]
 8011a56: 683a         	ldr	r2, [r7]
 8011a58: 641a         	str	r2, [r3, #0x40]
; 	for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.controller); i++) {
 8011a5a: 2300         	movs	r3, #0x0
 8011a5c: 617b         	str	r3, [r7, #0x14]
 8011a5e: e025         	b	0x8011aac <dji_set_angle+0x70> @ imm = #0x4a
; 		if (cfg->common.controller[i] == NULL) {
 8011a60: 68fb         	ldr	r3, [r7, #0xc]
 8011a62: 697a         	ldr	r2, [r7, #0x14]
 8011a64: 3204         	adds	r2, #0x4
 8011a66: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8011a6a: 2b00         	cmp	r3, #0x0
 8011a6c: d022         	beq	0x8011ab4 <dji_set_angle+0x78> @ imm = #0x44
; 		if (strcmp(cfg->common.capabilities[i], "angle") == 0) {
 8011a6e: 697a         	ldr	r2, [r7, #0x14]
 8011a70: 4613         	mov	r3, r2
 8011a72: 005b         	lsls	r3, r3, #0x1
 8011a74: 4413         	add	r3, r2
 8011a76: 009b         	lsls	r3, r3, #0x2
 8011a78: 3320         	adds	r3, #0x20
 8011a7a: 68fa         	ldr	r2, [r7, #0xc]
 8011a7c: 4413         	add	r3, r2
 8011a7e: 4910         	ldr	r1, [pc, #0x40]         @ 0x8011ac0 <dji_set_angle+0x84>
 8011a80: 4618         	mov	r0, r3
 8011a82: f7ee fc8f    	bl	0x80003a4 <strcmp>      @ imm = #-0x116e2
 8011a86: 4603         	mov	r3, r0
 8011a88: 2b00         	cmp	r3, #0x0
 8011a8a: d10c         	bne	0x8011aa6 <dji_set_angle+0x6a> @ imm = #0x18
; 			pid_calc(cfg->common.controller[i]);
 8011a8c: 68fb         	ldr	r3, [r7, #0xc]
 8011a8e: 697a         	ldr	r2, [r7, #0x14]
 8011a90: 3204         	adds	r2, #0x4
 8011a92: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8011a96: 4618         	mov	r0, r3
 8011a98: f013 ffc9    	bl	0x8025a2e <pid_calc>    @ imm = #0x13f92
; 			data->current_mode_index = i;
 8011a9c: 697b         	ldr	r3, [r7, #0x14]
 8011a9e: b25a         	sxtb	r2, r3
 8011aa0: 693b         	ldr	r3, [r7, #0x10]
 8011aa2: f883 2022    	strb.w	r2, [r3, #0x22]
; 	for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.controller); i++) {
 8011aa6: 697b         	ldr	r3, [r7, #0x14]
 8011aa8: 3301         	adds	r3, #0x1
 8011aaa: 617b         	str	r3, [r7, #0x14]
 8011aac: 697b         	ldr	r3, [r7, #0x14]
 8011aae: 2b03         	cmp	r3, #0x3
 8011ab0: d9d6         	bls	0x8011a60 <dji_set_angle+0x24> @ imm = #-0x54
 8011ab2: e000         	b	0x8011ab6 <dji_set_angle+0x7a> @ imm = #0x0
; 			break;
 8011ab4: bf00         	nop
; 	return 0;
 8011ab6: 2300         	movs	r3, #0x0
; }
 8011ab8: 4618         	mov	r0, r3
 8011aba: 3718         	adds	r7, #0x18
 8011abc: 46bd         	mov	sp, r7
 8011abe: bd80         	pop	{r7, pc}

08011ac0 <$d>:
 8011ac0: 50 c4 02 08  	.word	0x0802c450

08011ac4 <dji_set_torque>:
; {
 8011ac4: b580         	push	{r7, lr}
 8011ac6: b086         	sub	sp, #0x18
 8011ac8: af00         	add	r7, sp, #0x0
 8011aca: 6078         	str	r0, [r7, #0x4]
 8011acc: ed87 0a00    	<unknown>
; 	struct dji_motor_data *data = dev->data;
 8011ad0: 687b         	ldr	r3, [r7, #0x4]
 8011ad2: 691b         	ldr	r3, [r3, #0x10]
 8011ad4: 613b         	str	r3, [r7, #0x10]
; 	const struct dji_motor_config *cfg = dev->config;
 8011ad6: 687b         	ldr	r3, [r7, #0x4]
 8011ad8: 685b         	ldr	r3, [r3, #0x4]
 8011ada: 60fb         	str	r3, [r7, #0xc]
; 	data->target_torque = torque;
 8011adc: 693b         	ldr	r3, [r7, #0x10]
 8011ade: 683a         	ldr	r2, [r7]
 8011ae0: 649a         	str	r2, [r3, #0x48]
; 	for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.controller); i++) {
 8011ae2: 2300         	movs	r3, #0x0
 8011ae4: 617b         	str	r3, [r7, #0x14]
 8011ae6: e02e         	b	0x8011b46 <dji_set_torque+0x82> @ imm = #0x5c
; 		if (cfg->common.controller[i] == NULL) {
 8011ae8: 68fb         	ldr	r3, [r7, #0xc]
 8011aea: 697a         	ldr	r2, [r7, #0x14]
 8011aec: 3204         	adds	r2, #0x4
 8011aee: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8011af2: 2b00         	cmp	r3, #0x0
 8011af4: d108         	bne	0x8011b08 <dji_set_torque+0x44> @ imm = #0x10
; 			data->current_mode_index = i + 1;
 8011af6: 697b         	ldr	r3, [r7, #0x14]
 8011af8: b2db         	uxtb	r3, r3
 8011afa: 3301         	adds	r3, #0x1
 8011afc: b2db         	uxtb	r3, r3
 8011afe: b25a         	sxtb	r2, r3
 8011b00: 693b         	ldr	r3, [r7, #0x10]
 8011b02: f883 2022    	strb.w	r2, [r3, #0x22]
; 			break;
 8011b06: e021         	b	0x8011b4c <dji_set_torque+0x88> @ imm = #0x42
; 		if (strcmp(cfg->common.capabilities[i], "torque") == 0) {
 8011b08: 697a         	ldr	r2, [r7, #0x14]
 8011b0a: 4613         	mov	r3, r2
 8011b0c: 005b         	lsls	r3, r3, #0x1
 8011b0e: 4413         	add	r3, r2
 8011b10: 009b         	lsls	r3, r3, #0x2
 8011b12: 3320         	adds	r3, #0x20
 8011b14: 68fa         	ldr	r2, [r7, #0xc]
 8011b16: 4413         	add	r3, r2
 8011b18: 490f         	ldr	r1, [pc, #0x3c]         @ 0x8011b58 <dji_set_torque+0x94>
 8011b1a: 4618         	mov	r0, r3
 8011b1c: f7ee fc42    	bl	0x80003a4 <strcmp>      @ imm = #-0x1177c
 8011b20: 4603         	mov	r3, r0
 8011b22: 2b00         	cmp	r3, #0x0
 8011b24: d10c         	bne	0x8011b40 <dji_set_torque+0x7c> @ imm = #0x18
; 			pid_calc(cfg->common.controller[i]);
 8011b26: 68fb         	ldr	r3, [r7, #0xc]
 8011b28: 697a         	ldr	r2, [r7, #0x14]
 8011b2a: 3204         	adds	r2, #0x4
 8011b2c: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8011b30: 4618         	mov	r0, r3
 8011b32: f013 ff7c    	bl	0x8025a2e <pid_calc>    @ imm = #0x13ef8
; 			data->current_mode_index = i;
 8011b36: 697b         	ldr	r3, [r7, #0x14]
 8011b38: b25a         	sxtb	r2, r3
 8011b3a: 693b         	ldr	r3, [r7, #0x10]
 8011b3c: f883 2022    	strb.w	r2, [r3, #0x22]
; 	for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.controller); i++) {
 8011b40: 697b         	ldr	r3, [r7, #0x14]
 8011b42: 3301         	adds	r3, #0x1
 8011b44: 617b         	str	r3, [r7, #0x14]
 8011b46: 697b         	ldr	r3, [r7, #0x14]
 8011b48: 2b03         	cmp	r3, #0x3
 8011b4a: d9cd         	bls	0x8011ae8 <dji_set_torque+0x24> @ imm = #-0x66
; 	return 0;
 8011b4c: 2300         	movs	r3, #0x0
; }
 8011b4e: 4618         	mov	r0, r3
 8011b50: 3718         	adds	r7, #0x18
 8011b52: 46bd         	mov	sp, r7
 8011b54: bd80         	pop	{r7, pc}
 8011b56: bf00         	nop

08011b58 <$d>:
 8011b58: 58 c4 02 08  	.word	0x0802c458

08011b5c <dji_control>:
; {
 8011b5c: b480         	push	{r7}
 8011b5e: b089         	sub	sp, #0x24
 8011b60: af00         	add	r7, sp, #0x0
 8011b62: 6078         	str	r0, [r7, #0x4]
 8011b64: 460b         	mov	r3, r1
 8011b66: 70fb         	strb	r3, [r7, #0x3]
; 	struct dji_motor_data *data = dev->data;
 8011b68: 687b         	ldr	r3, [r7, #0x4]
 8011b6a: 691b         	ldr	r3, [r3, #0x10]
 8011b6c: 61fb         	str	r3, [r7, #0x1c]
; 	const struct dji_motor_config *cfg = dev->config;
 8011b6e: 687b         	ldr	r3, [r7, #0x4]
 8011b70: 685b         	ldr	r3, [r3, #0x4]
 8011b72: 61bb         	str	r3, [r7, #0x18]
; 	frame.id = cfg->common.tx_id;
 8011b74: 69bb         	ldr	r3, [r7, #0x18]
 8011b76: 689b         	ldr	r3, [r3, #0x8]
 8011b78: 60bb         	str	r3, [r7, #0x8]
; 	switch (cmd) {
 8011b7a: 78fb         	ldrb	r3, [r7, #0x3]
 8011b7c: 2b04         	cmp	r3, #0x4
 8011b7e: d828         	bhi	0x8011bd2 <dji_control+0x76> @ imm = #0x50
 8011b80: a201         	adr	r2, #4 <dji_control+0x29>
 8011b82: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8011b86: bf00         	nop

08011b88 <$d>:
 8011b88: 9d 1b 01 08  	.word	0x08011b9d
 8011b8c: a7 1b 01 08  	.word	0x08011ba7
 8011b90: b1 1b 01 08  	.word	0x08011bb1
 8011b94: d1 1b 01 08  	.word	0x08011bd1
 8011b98: bf 1b 01 08  	.word	0x08011bbf

08011b9c <$t>:
; 		data->online = true;
 8011b9c: 69fb         	ldr	r3, [r7, #0x1c]
 8011b9e: 2201         	movs	r2, #0x1
 8011ba0: f883 2020    	strb.w	r2, [r3, #0x20]
; 		break;
 8011ba4: e015         	b	0x8011bd2 <dji_control+0x76> @ imm = #0x2a
; 		data->online = false;
 8011ba6: 69fb         	ldr	r3, [r7, #0x1c]
 8011ba8: 2200         	movs	r2, #0x0
 8011baa: f883 2020    	strb.w	r2, [r3, #0x20]
; 		break;
 8011bae: e010         	b	0x8011bd2 <dji_control+0x76> @ imm = #0x20
; 		data->RAWangle_add = 0;
 8011bb0: 69fb         	ldr	r3, [r7, #0x1c]
 8011bb2: 2200         	movs	r2, #0x0
 8011bb4: 639a         	str	r2, [r3, #0x38]
; 		data->RAWangle = 0;
 8011bb6: 69fb         	ldr	r3, [r7, #0x1c]
 8011bb8: 2200         	movs	r2, #0x0
 8011bba: 849a         	strh	r2, [r3, #0x24]
; 		break;
 8011bbc: e009         	b	0x8011bd2 <dji_control+0x76> @ imm = #0x12
; 		data->missed_times = 0;
 8011bbe: 69fb         	ldr	r3, [r7, #0x1c]
 8011bc0: 2200         	movs	r2, #0x0
 8011bc2: f883 203c    	strb.w	r2, [r3, #0x3c]
; 		data->online = true;
 8011bc6: 69fb         	ldr	r3, [r7, #0x1c]
 8011bc8: 2201         	movs	r2, #0x1
 8011bca: f883 2020    	strb.w	r2, [r3, #0x20]
; 		break;
 8011bce: e000         	b	0x8011bd2 <dji_control+0x76> @ imm = #0x0
; 		break;
 8011bd0: bf00         	nop
; }
 8011bd2: bf00         	nop
 8011bd4: 3724         	adds	r7, #0x24
 8011bd6: 46bd         	mov	sp, r7
 8011bd8: f85d 7b04    	ldr	r7, [sp], #4
 8011bdc: 4770         	bx	lr
 8011bde: bf00         	nop

08011be0 <dji_init>:
; {
 8011be0: b580         	push	{r7, lr}
 8011be2: b08e         	sub	sp, #0x38
 8011be4: af04         	add	r7, sp, #0x10
 8011be6: 6078         	str	r0, [r7, #0x4]
; 	if (dev) {
 8011be8: 687b         	ldr	r3, [r7, #0x4]
 8011bea: 2b00         	cmp	r3, #0x0
 8011bec: f000 8175    	beq.w	0x8011eda <dji_init+0x2fa> @ imm = #0x2ea
; 		const struct dji_motor_config *cfg = dev->config;
 8011bf0: 687b         	ldr	r3, [r7, #0x4]
 8011bf2: 685b         	ldr	r3, [r3, #0x4]
 8011bf4: 623b         	str	r3, [r7, #0x20]
; 		struct dji_motor_data *data = (struct dji_motor_data *)dev->data;
 8011bf6: 687b         	ldr	r3, [r7, #0x4]
 8011bf8: 691b         	ldr	r3, [r3, #0x10]
 8011bfa: 61fb         	str	r3, [r7, #0x1c]
; 		uint8_t frame_id = frames_id(cfg->common.tx_id);
 8011bfc: 6a3b         	ldr	r3, [r7, #0x20]
 8011bfe: 689b         	ldr	r3, [r3, #0x8]
 8011c00: 4618         	mov	r0, r3
 8011c02: f013 ff4a    	bl	0x8025a9a <frames_id>   @ imm = #0x13e94
 8011c06: 4603         	mov	r3, r0
 8011c08: 76fb         	strb	r3, [r7, #0x1b]
; 		uint8_t id = motor_id(dev);
 8011c0a: 6878         	ldr	r0, [r7, #0x4]
 8011c0c: f013 ff9c    	bl	0x8025b48 <motor_id>    @ imm = #0x13f38
 8011c10: 4603         	mov	r3, r0
 8011c12: 76bb         	strb	r3, [r7, #0x1a]
; 		data->ctrl_struct->mask[frame_id] |= id >= 4 ? 0xF0 : 0x0F;
 8011c14: 69fb         	ldr	r3, [r7, #0x1c]
 8011c16: 69da         	ldr	r2, [r3, #0x1c]
 8011c18: 7efb         	ldrb	r3, [r7, #0x1b]
 8011c1a: 4413         	add	r3, r2
 8011c1c: f893 303e    	ldrb.w	r3, [r3, #0x3e]
 8011c20: b25b         	sxtb	r3, r3
 8011c22: 7eba         	ldrb	r2, [r7, #0x1a]
 8011c24: 2a03         	cmp	r2, #0x3
 8011c26: d902         	bls	0x8011c2e <dji_init+0x4e> @ imm = #0x4
 8011c28: f06f 020f    	mvn	r2, #0xf
 8011c2c: e000         	b	0x8011c30 <dji_init+0x50> @ imm = #0x0
 8011c2e: 220f         	movs	r2, #0xf
 8011c30: 4313         	orrs	r3, r2
 8011c32: b259         	sxtb	r1, r3
 8011c34: 69fb         	ldr	r3, [r7, #0x1c]
 8011c36: 69da         	ldr	r2, [r3, #0x1c]
 8011c38: 7efb         	ldrb	r3, [r7, #0x1b]
 8011c3a: b2c9         	uxtb	r1, r1
 8011c3c: 4413         	add	r3, r2
 8011c3e: 460a         	mov	r2, r1
 8011c40: f883 203e    	strb.w	r2, [r3, #0x3e]
; 		data->ctrl_struct->mask[frame_id] ^= 1 << id;
 8011c44: 69fb         	ldr	r3, [r7, #0x1c]
 8011c46: 69da         	ldr	r2, [r3, #0x1c]
 8011c48: 7efb         	ldrb	r3, [r7, #0x1b]
 8011c4a: 4413         	add	r3, r2
 8011c4c: f893 303e    	ldrb.w	r3, [r3, #0x3e]
 8011c50: b25a         	sxtb	r2, r3
 8011c52: 7ebb         	ldrb	r3, [r7, #0x1a]
 8011c54: 2101         	movs	r1, #0x1
 8011c56: fa01 f303    	lsl.w	r3, r1, r3
 8011c5a: b25b         	sxtb	r3, r3
 8011c5c: 4053         	eors	r3, r2
 8011c5e: b259         	sxtb	r1, r3
 8011c60: 69fb         	ldr	r3, [r7, #0x1c]
 8011c62: 69da         	ldr	r2, [r3, #0x1c]
 8011c64: 7efb         	ldrb	r3, [r7, #0x1b]
 8011c66: b2c9         	uxtb	r1, r1
 8011c68: 4413         	add	r3, r2
 8011c6a: 460a         	mov	r2, r1
 8011c6c: f883 203e    	strb.w	r2, [r3, #0x3e]
; 		data->ctrl_struct->rx_ids[id] = cfg->common.rx_id;
 8011c70: 69fb         	ldr	r3, [r7, #0x1c]
 8011c72: 69d9         	ldr	r1, [r3, #0x1c]
 8011c74: 7ebb         	ldrb	r3, [r7, #0x1a]
 8011c76: 6a3a         	ldr	r2, [r7, #0x20]
 8011c78: 68d2         	ldr	r2, [r2, #0xc]
 8011c7a: 009b         	lsls	r3, r3, #0x2
 8011c7c: 440b         	add	r3, r1
 8011c7e: 605a         	str	r2, [r3, #0x4]
; 		data->online = true;
 8011c80: 69fb         	ldr	r3, [r7, #0x1c]
 8011c82: 2201         	movs	r2, #0x1
 8011c84: f883 2020    	strb.w	r2, [r3, #0x20]
; 		for (int i = 0;
 8011c88: 2300         	movs	r3, #0x0
 8011c8a: 627b         	str	r3, [r7, #0x24]
 8011c8c: e0a9         	b	0x8011de2 <dji_init+0x202> @ imm = #0x152
; 			if (cfg->common.controller[i] == NULL) {
 8011c8e: 6a3b         	ldr	r3, [r7, #0x20]
 8011c90: 6a7a         	ldr	r2, [r7, #0x24]
 8011c92: 3204         	adds	r2, #0x4
 8011c94: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8011c98: 2b00         	cmp	r3, #0x0
 8011c9a: f000 80a7    	beq.w	0x8011dec <dji_init+0x20c> @ imm = #0x14e
; 			if (strcmp(cfg->common.capabilities[i], "speed") == 0) {
 8011c9e: 6a7a         	ldr	r2, [r7, #0x24]
 8011ca0: 4613         	mov	r3, r2
 8011ca2: 005b         	lsls	r3, r3, #0x1
 8011ca4: 4413         	add	r3, r2
 8011ca6: 009b         	lsls	r3, r3, #0x2
 8011ca8: 3320         	adds	r3, #0x20
 8011caa: 6a3a         	ldr	r2, [r7, #0x20]
 8011cac: 4413         	add	r3, r2
 8011cae: 498d         	ldr	r1, [pc, #0x234]        @ 0x8011ee4 <dji_init+0x304>
 8011cb0: 4618         	mov	r0, r3
 8011cb2: f7ee fb77    	bl	0x80003a4 <strcmp>      @ imm = #-0x11912
 8011cb6: 4603         	mov	r3, r0
 8011cb8: 2b00         	cmp	r3, #0x0
 8011cba: d117         	bne	0x8011cec <dji_init+0x10c> @ imm = #0x2e
; 				pid_reg_input(cfg->common.controller[i], &data->common.rpm,
 8011cbc: 6a3b         	ldr	r3, [r7, #0x20]
 8011cbe: 6a7a         	ldr	r2, [r7, #0x24]
 8011cc0: 3204         	adds	r2, #0x4
 8011cc2: f853 0022    	ldr.w	r0, [r3, r2, lsl #2]
 8011cc6: 69fb         	ldr	r3, [r7, #0x1c]
 8011cc8: 1d19         	adds	r1, r3, #0x4
 8011cca: 69fb         	ldr	r3, [r7, #0x1c]
 8011ccc: 3344         	adds	r3, #0x44
 8011cce: 461a         	mov	r2, r3
 8011cd0: f013 feb8    	bl	0x8025a44 <pid_reg_input> @ imm = #0x13d70
; 				pid_reg_output(cfg->common.controller[i], &data->target_torque);
 8011cd4: 6a3b         	ldr	r3, [r7, #0x20]
 8011cd6: 6a7a         	ldr	r2, [r7, #0x24]
 8011cd8: 3204         	adds	r2, #0x4
 8011cda: f853 2022    	ldr.w	r2, [r3, r2, lsl #2]
 8011cde: 69fb         	ldr	r3, [r7, #0x1c]
 8011ce0: 3348         	adds	r3, #0x48
 8011ce2: 4619         	mov	r1, r3
 8011ce4: 4610         	mov	r0, r2
 8011ce6: f013 fecb    	bl	0x8025a80 <pid_reg_output> @ imm = #0x13d96
 8011cea: e06a         	b	0x8011dc2 <dji_init+0x1e2> @ imm = #0xd4
; 			} else if (strcmp(cfg->common.capabilities[i], "angle") == 0) {
 8011cec: 6a7a         	ldr	r2, [r7, #0x24]
 8011cee: 4613         	mov	r3, r2
 8011cf0: 005b         	lsls	r3, r3, #0x1
 8011cf2: 4413         	add	r3, r2
 8011cf4: 009b         	lsls	r3, r3, #0x2
 8011cf6: 3320         	adds	r3, #0x20
 8011cf8: 6a3a         	ldr	r2, [r7, #0x20]
 8011cfa: 4413         	add	r3, r2
 8011cfc: 497a         	ldr	r1, [pc, #0x1e8]        @ 0x8011ee8 <dji_init+0x308>
 8011cfe: 4618         	mov	r0, r3
 8011d00: f7ee fb50    	bl	0x80003a4 <strcmp>      @ imm = #-0x11960
 8011d04: 4603         	mov	r3, r0
 8011d06: 2b00         	cmp	r3, #0x0
 8011d08: d116         	bne	0x8011d38 <dji_init+0x158> @ imm = #0x2c
; 				pid_reg_input(cfg->common.controller[i], &data->common.angle,
 8011d0a: 6a3b         	ldr	r3, [r7, #0x20]
 8011d0c: 6a7a         	ldr	r2, [r7, #0x24]
 8011d0e: 3204         	adds	r2, #0x4
 8011d10: f853 0022    	ldr.w	r0, [r3, r2, lsl #2]
 8011d14: 69f9         	ldr	r1, [r7, #0x1c]
 8011d16: 69fb         	ldr	r3, [r7, #0x1c]
 8011d18: 3340         	adds	r3, #0x40
 8011d1a: 461a         	mov	r2, r3
 8011d1c: f013 fe92    	bl	0x8025a44 <pid_reg_input> @ imm = #0x13d24
; 				pid_reg_output(cfg->common.controller[i], &data->target_rpm);
 8011d20: 6a3b         	ldr	r3, [r7, #0x20]
 8011d22: 6a7a         	ldr	r2, [r7, #0x24]
 8011d24: 3204         	adds	r2, #0x4
 8011d26: f853 2022    	ldr.w	r2, [r3, r2, lsl #2]
 8011d2a: 69fb         	ldr	r3, [r7, #0x1c]
 8011d2c: 3344         	adds	r3, #0x44
 8011d2e: 4619         	mov	r1, r3
 8011d30: 4610         	mov	r0, r2
 8011d32: f013 fea5    	bl	0x8025a80 <pid_reg_output> @ imm = #0x13d4a
 8011d36: e044         	b	0x8011dc2 <dji_init+0x1e2> @ imm = #0x88
; 			} else if (strcmp(cfg->common.capabilities[i], "torque") == 0) {
 8011d38: 6a7a         	ldr	r2, [r7, #0x24]
 8011d3a: 4613         	mov	r3, r2
 8011d3c: 005b         	lsls	r3, r3, #0x1
 8011d3e: 4413         	add	r3, r2
 8011d40: 009b         	lsls	r3, r3, #0x2
 8011d42: 3320         	adds	r3, #0x20
 8011d44: 6a3a         	ldr	r2, [r7, #0x20]
 8011d46: 4413         	add	r3, r2
 8011d48: 4968         	ldr	r1, [pc, #0x1a0]        @ 0x8011eec <dji_init+0x30c>
 8011d4a: 4618         	mov	r0, r3
 8011d4c: f7ee fb2a    	bl	0x80003a4 <strcmp>      @ imm = #-0x119ac
 8011d50: 4603         	mov	r3, r0
 8011d52: 2b00         	cmp	r3, #0x0
 8011d54: d118         	bne	0x8011d88 <dji_init+0x1a8> @ imm = #0x30
; 				pid_reg_input(cfg->common.controller[i], &data->common.torque,
 8011d56: 6a3b         	ldr	r3, [r7, #0x20]
 8011d58: 6a7a         	ldr	r2, [r7, #0x24]
 8011d5a: 3204         	adds	r2, #0x4
 8011d5c: f853 0022    	ldr.w	r0, [r3, r2, lsl #2]
 8011d60: 69fb         	ldr	r3, [r7, #0x1c]
 8011d62: f103 0108    	add.w	r1, r3, #0x8
 8011d66: 69fb         	ldr	r3, [r7, #0x1c]
 8011d68: 3348         	adds	r3, #0x48
 8011d6a: 461a         	mov	r2, r3
 8011d6c: f013 fe6a    	bl	0x8025a44 <pid_reg_input> @ imm = #0x13cd4
; 				pid_reg_output(cfg->common.controller[i], &data->target_current);
 8011d70: 6a3b         	ldr	r3, [r7, #0x20]
 8011d72: 6a7a         	ldr	r2, [r7, #0x24]
 8011d74: 3204         	adds	r2, #0x4
 8011d76: f853 2022    	ldr.w	r2, [r3, r2, lsl #2]
 8011d7a: 69fb         	ldr	r3, [r7, #0x1c]
 8011d7c: 334c         	adds	r3, #0x4c
 8011d7e: 4619         	mov	r1, r3
 8011d80: 4610         	mov	r0, r2
 8011d82: f013 fe7d    	bl	0x8025a80 <pid_reg_output> @ imm = #0x13cfa
 8011d86: e01c         	b	0x8011dc2 <dji_init+0x1e2> @ imm = #0x38
; 				LOG_ERR("Unsupported motor mode");
 8011d88: 2304         	movs	r3, #0x4
 8011d8a: 2b00         	cmp	r3, #0x0
 8011d8c: d016         	beq	0x8011dbc <dji_init+0x1dc> @ imm = #0x2c
 8011d8e: 2301         	movs	r3, #0x1
 8011d90: 767b         	strb	r3, [r7, #0x19]
 8011d92: 7e7b         	ldrb	r3, [r7, #0x19]
 8011d94: f083 0301    	eor	r3, r3, #0x1
 8011d98: b2db         	uxtb	r3, r3
 8011d9a: 2b00         	cmp	r3, #0x0
 8011d9c: d10e         	bne	0x8011dbc <dji_init+0x1dc> @ imm = #0x1c
 8011d9e: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8011ef0 <dji_init+0x310>
 8011da0: 6819         	ldr	r1, [r3]
 8011da2: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8011ef4 <dji_init+0x314>
 8011da4: 9302         	str	r3, [sp, #0x8]
 8011da6: 2300         	movs	r3, #0x0
 8011da8: 9301         	str	r3, [sp, #0x4]
 8011daa: 2300         	movs	r3, #0x0
 8011dac: 9300         	str	r3, [sp]
 8011dae: 2300         	movs	r3, #0x0
 8011db0: 2201         	movs	r2, #0x1
 8011db2: 2000         	movs	r0, #0x0
 8011db4: f013 fd95    	bl	0x80258e2 <z_log_msg_runtime_create> @ imm = #0x13b2a
 8011db8: 2300         	movs	r3, #0x0
 8011dba: 617b         	str	r3, [r7, #0x14]
; 				return -1;
 8011dbc: f04f 33ff    	mov.w	r3, #0xffffffff
 8011dc0: e08c         	b	0x8011edc <dji_init+0x2fc> @ imm = #0x118
; 			pid_reg_time(cfg->common.controller[i], &(data->curr_time),
 8011dc2: 6a3b         	ldr	r3, [r7, #0x20]
 8011dc4: 6a7a         	ldr	r2, [r7, #0x24]
 8011dc6: 3204         	adds	r2, #0x4
 8011dc8: f853 0022    	ldr.w	r0, [r3, r2, lsl #2]
 8011dcc: 69fb         	ldr	r3, [r7, #0x1c]
 8011dce: f103 0130    	add.w	r1, r3, #0x30
 8011dd2: 69fb         	ldr	r3, [r7, #0x1c]
 8011dd4: 3334         	adds	r3, #0x34
 8011dd6: 461a         	mov	r2, r3
 8011dd8: f013 fe43    	bl	0x8025a62 <pid_reg_time> @ imm = #0x13c86
; 		     i < sizeof(cfg->common.controller) / sizeof(cfg->common.controller[0]); i++) {
 8011ddc: 6a7b         	ldr	r3, [r7, #0x24]
 8011dde: 3301         	adds	r3, #0x1
 8011de0: 627b         	str	r3, [r7, #0x24]
 8011de2: 6a7b         	ldr	r3, [r7, #0x24]
 8011de4: 2b03         	cmp	r3, #0x3
 8011de6: f67f af52    	bls.w	0x8011c8e <dji_init+0xae> @ imm = #-0x15c
 8011dea: e000         	b	0x8011dee <dji_init+0x20e> @ imm = #0x0
; 				break;
 8011dec: bf00         	nop
; 		data->current_mode_index = 0;
 8011dee: 69fb         	ldr	r3, [r7, #0x1c]
 8011df0: 2200         	movs	r2, #0x0
 8011df2: f883 2022    	strb.w	r2, [r3, #0x22]
; 		data->ctrl_struct->motor_devs[id] = (struct device *)dev;
 8011df6: 69fb         	ldr	r3, [r7, #0x1c]
 8011df8: 69da         	ldr	r2, [r3, #0x1c]
 8011dfa: 7ebb         	ldrb	r3, [r7, #0x1a]
 8011dfc: 3310         	adds	r3, #0x10
 8011dfe: 009b         	lsls	r3, r3, #0x2
 8011e00: 4413         	add	r3, r2
 8011e02: 687a         	ldr	r2, [r7, #0x4]
 8011e04: 605a         	str	r2, [r3, #0x4]
; 		data->prev_time = 0;
 8011e06: 69fb         	ldr	r3, [r7, #0x1c]
 8011e08: 2200         	movs	r2, #0x0
 8011e0a: 635a         	str	r2, [r3, #0x34]
; 		data->ctrl_struct->flags |= 1 << id;
 8011e0c: 69fb         	ldr	r3, [r7, #0x1c]
 8011e0e: 69db         	ldr	r3, [r3, #0x1c]
 8011e10: f893 303d    	ldrb.w	r3, [r3, #0x3d]
 8011e14: b25a         	sxtb	r2, r3
 8011e16: 7ebb         	ldrb	r3, [r7, #0x1a]
 8011e18: 2101         	movs	r1, #0x1
 8011e1a: fa01 f303    	lsl.w	r3, r1, r3
 8011e1e: b25b         	sxtb	r3, r3
 8011e20: 4313         	orrs	r3, r2
 8011e22: b25a         	sxtb	r2, r3
 8011e24: 69fb         	ldr	r3, [r7, #0x1c]
 8011e26: 69db         	ldr	r3, [r3, #0x1c]
 8011e28: b2d2         	uxtb	r2, r2
 8011e2a: f883 203d    	strb.w	r2, [r3, #0x3d]
; 		data->ctrl_struct->mapping[frame_id][id % 4] = id;
 8011e2e: 69fb         	ldr	r3, [r7, #0x1c]
 8011e30: 69d9         	ldr	r1, [r3, #0x1c]
 8011e32: 7efa         	ldrb	r2, [r7, #0x1b]
 8011e34: 7ebb         	ldrb	r3, [r7, #0x1a]
 8011e36: f003 0303    	and	r3, r3, #0x3
 8011e3a: 0092         	lsls	r2, r2, #0x2
 8011e3c: 440a         	add	r2, r1
 8011e3e: 4413         	add	r3, r2
 8011e40: 3329         	adds	r3, #0x29
 8011e42: 7eba         	ldrb	r2, [r7, #0x1a]
 8011e44: 701a         	strb	r2, [r3]
; 		if (cfg->is_gm6020) {
 8011e46: 6a3b         	ldr	r3, [r7, #0x20]
 8011e48: f893 3054    	ldrb.w	r3, [r3, #0x54]
 8011e4c: 2b00         	cmp	r3, #0x0
 8011e4e: d004         	beq	0x8011e5a <dji_init+0x27a> @ imm = #0x8
; 			data->convert_num = GM6020_CONVERT_NUM;
 8011e50: 69fb         	ldr	r3, [r7, #0x1c]
 8011e52: 2201         	movs	r2, #0x1
 8011e54: f883 2021    	strb.w	r2, [r3, #0x21]
 8011e58: e02d         	b	0x8011eb6 <dji_init+0x2d6> @ imm = #0x5a
; 		} else if (cfg->is_m3508) {
 8011e5a: 6a3b         	ldr	r3, [r7, #0x20]
 8011e5c: f893 3055    	ldrb.w	r3, [r3, #0x55]
 8011e60: 2b00         	cmp	r3, #0x0
 8011e62: d004         	beq	0x8011e6e <dji_init+0x28e> @ imm = #0x8
; 			data->convert_num = M3508_CONVERT_NUM;
 8011e64: 69fb         	ldr	r3, [r7, #0x1c]
 8011e66: 2200         	movs	r2, #0x0
 8011e68: f883 2021    	strb.w	r2, [r3, #0x21]
 8011e6c: e023         	b	0x8011eb6 <dji_init+0x2d6> @ imm = #0x46
; 		} else if (cfg->is_m2006) {
 8011e6e: 6a3b         	ldr	r3, [r7, #0x20]
 8011e70: f893 3056    	ldrb.w	r3, [r3, #0x56]
 8011e74: 2b00         	cmp	r3, #0x0
 8011e76: d004         	beq	0x8011e82 <dji_init+0x2a2> @ imm = #0x8
; 			data->convert_num = M2006_CONVERT_NUM;
 8011e78: 69fb         	ldr	r3, [r7, #0x1c]
 8011e7a: 2202         	movs	r2, #0x2
 8011e7c: f883 2021    	strb.w	r2, [r3, #0x21]
 8011e80: e019         	b	0x8011eb6 <dji_init+0x2d6> @ imm = #0x32
; 			LOG_ERR("Unsupported motor type");
 8011e82: 2304         	movs	r3, #0x4
 8011e84: 2b00         	cmp	r3, #0x0
 8011e86: d016         	beq	0x8011eb6 <dji_init+0x2d6> @ imm = #0x2c
 8011e88: 2301         	movs	r3, #0x1
 8011e8a: 74fb         	strb	r3, [r7, #0x13]
 8011e8c: 7cfb         	ldrb	r3, [r7, #0x13]
 8011e8e: f083 0301    	eor	r3, r3, #0x1
 8011e92: b2db         	uxtb	r3, r3
 8011e94: 2b00         	cmp	r3, #0x0
 8011e96: d10e         	bne	0x8011eb6 <dji_init+0x2d6> @ imm = #0x1c
 8011e98: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8011ef0 <dji_init+0x310>
 8011e9a: 6819         	ldr	r1, [r3]
 8011e9c: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8011ef8 <dji_init+0x318>
 8011e9e: 9302         	str	r3, [sp, #0x8]
 8011ea0: 2300         	movs	r3, #0x0
 8011ea2: 9301         	str	r3, [sp, #0x4]
 8011ea4: 2300         	movs	r3, #0x0
 8011ea6: 9300         	str	r3, [sp]
 8011ea8: 2300         	movs	r3, #0x0
 8011eaa: 2201         	movs	r2, #0x1
 8011eac: 2000         	movs	r0, #0x0
 8011eae: f013 fd18    	bl	0x80258e2 <z_log_msg_runtime_create> @ imm = #0x13a30
 8011eb2: 2300         	movs	r3, #0x0
 8011eb4: 60fb         	str	r3, [r7, #0xc]
; 		if (!device_is_ready(cfg->common.phy)) {
 8011eb6: 6a3b         	ldr	r3, [r7, #0x20]
 8011eb8: 681b         	ldr	r3, [r3]
 8011eba: 4618         	mov	r0, r3
 8011ebc: f013 fca8    	bl	0x8025810 <device_is_ready> @ imm = #0x13950
 8011ec0: 4603         	mov	r3, r0
 8011ec2: f083 0301    	eor	r3, r3, #0x1
 8011ec6: b2db         	uxtb	r3, r3
 8011ec8: 2b00         	cmp	r3, #0x0
 8011eca: d002         	beq	0x8011ed2 <dji_init+0x2f2> @ imm = #0x4
; 			return -1;
 8011ecc: f04f 33ff    	mov.w	r3, #0xffffffff
 8011ed0: e004         	b	0x8011edc <dji_init+0x2fc> @ imm = #0x8
; 		k_thread_start(dji_motor_ctrl_thread);
 8011ed2: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8011efc <dji_init+0x31c>
 8011ed4: 4618         	mov	r0, r3
 8011ed6: f013 fcae    	bl	0x8025836 <k_thread_start> @ imm = #0x1395c
; 	return 0;
 8011eda: 2300         	movs	r3, #0x0
; }
 8011edc: 4618         	mov	r0, r3
 8011ede: 3728         	adds	r7, #0x28
 8011ee0: 46bd         	mov	sp, r7
 8011ee2: bd80         	pop	{r7, pc}

08011ee4 <$d>:
 8011ee4: 48 c4 02 08  	.word	0x0802c448
 8011ee8: 50 c4 02 08  	.word	0x0802c450
 8011eec: 58 c4 02 08  	.word	0x0802c458
 8011ef0: c4 07 00 24  	.word	0x240007c4
 8011ef4: 60 c4 02 08  	.word	0x0802c460
 8011ef8: 78 c4 02 08  	.word	0x0802c478
 8011efc: 48 1f 00 24  	.word	0x24001f48

08011f00 <can_rx_callback>:
; {
 8011f00: b590         	push	{r4, r7, lr}
 8011f02: b09d         	sub	sp, #0x74
 8011f04: af06         	add	r7, sp, #0x18
 8011f06: 60f8         	str	r0, [r7, #0xc]
 8011f08: 60b9         	str	r1, [r7, #0x8]
 8011f0a: 607a         	str	r2, [r7, #0x4]
; 	uint32_t curr_time = k_cycle_get_32();
 8011f0c: f013 fc9e    	bl	0x802584c <k_cycle_get_32> @ imm = #0x1393c
 8011f10: 6578         	str	r0, [r7, #0x54]
; 	struct motor_controller *ctrl_struct = (struct motor_controller *)user_data;
 8011f12: 687b         	ldr	r3, [r7, #0x4]
 8011f14: 647b         	str	r3, [r7, #0x44]
; 	struct can_frame rx_frame = *frame;
 8011f16: 68bb         	ldr	r3, [r7, #0x8]
 8011f18: f107 0414    	add.w	r4, r7, #0x14
 8011f1c: cb0f         	ldm	r3, {r0, r1, r2, r3}
 8011f1e: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
; 	uint8_t id = (rx_frame.id & 0xF) - 1;
 8011f22: 697b         	ldr	r3, [r7, #0x14]
 8011f24: b2db         	uxtb	r3, r3
 8011f26: f003 030f    	and	r3, r3, #0xf
 8011f2a: b2db         	uxtb	r3, r3
 8011f2c: 3b01         	subs	r3, #0x1
 8011f2e: f887 304b    	strb.w	r3, [r7, #0x4b]
; 	if (ctrl_struct->rx_ids[id] != rx_frame.id && id > 4) {
 8011f32: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8011f36: 6c7a         	ldr	r2, [r7, #0x44]
 8011f38: 009b         	lsls	r3, r3, #0x2
 8011f3a: 4413         	add	r3, r2
 8011f3c: 685b         	ldr	r3, [r3, #0x4]
 8011f3e: 461a         	mov	r2, r3
 8011f40: 697b         	ldr	r3, [r7, #0x14]
 8011f42: 429a         	cmp	r2, r3
 8011f44: d008         	beq	0x8011f58 <can_rx_callback+0x58> @ imm = #0x10
 8011f46: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8011f4a: 2b04         	cmp	r3, #0x4
 8011f4c: d904         	bls	0x8011f58 <can_rx_callback+0x58> @ imm = #0x8
; 		id -= 4;
 8011f4e: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8011f52: 3b04         	subs	r3, #0x4
 8011f54: f887 304b    	strb.w	r3, [r7, #0x4b]
; 	if (ctrl_struct->rx_ids[id] != rx_frame.id) {
 8011f58: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8011f5c: 6c7a         	ldr	r2, [r7, #0x44]
 8011f5e: 009b         	lsls	r3, r3, #0x2
 8011f60: 4413         	add	r3, r2
 8011f62: 685b         	ldr	r3, [r3, #0x4]
 8011f64: 461a         	mov	r2, r3
 8011f66: 697b         	ldr	r3, [r7, #0x14]
 8011f68: 429a         	cmp	r2, r3
 8011f6a: d02a         	beq	0x8011fc2 <can_rx_callback+0xc2> @ imm = #0x54
; 		LOG_ERR("Unknown motor ID: %d, database: %d, received: %d", id,
 8011f6c: 2304         	movs	r3, #0x4
 8011f6e: 2b00         	cmp	r3, #0x0
 8011f70: d026         	beq	0x8011fc0 <can_rx_callback+0xc0> @ imm = #0x4c
 8011f72: 2301         	movs	r3, #0x1
 8011f74: f887 302a    	strb.w	r3, [r7, #0x2a]
 8011f78: f897 302a    	ldrb.w	r3, [r7, #0x2a]
 8011f7c: f083 0301    	eor	r3, r3, #0x1
 8011f80: b2db         	uxtb	r3, r3
 8011f82: 2b00         	cmp	r3, #0x0
 8011f84: d11c         	bne	0x8011fc0 <can_rx_callback+0xc0> @ imm = #0x38
 8011f86: 4b99         	ldr	r3, [pc, #0x264]        @ 0x80121ec <can_rx_callback+0x2ec>
 8011f88: 6818         	ldr	r0, [r3]
 8011f8a: f897 204b    	ldrb.w	r2, [r7, #0x4b]
 8011f8e: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8011f92: 6c79         	ldr	r1, [r7, #0x44]
 8011f94: 009b         	lsls	r3, r3, #0x2
 8011f96: 440b         	add	r3, r1
 8011f98: 685b         	ldr	r3, [r3, #0x4]
 8011f9a: 6979         	ldr	r1, [r7, #0x14]
 8011f9c: 9105         	str	r1, [sp, #0x14]
 8011f9e: 9304         	str	r3, [sp, #0x10]
 8011fa0: 9203         	str	r2, [sp, #0xc]
 8011fa2: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x80121f0 <can_rx_callback+0x2f0>
 8011fa4: 9302         	str	r3, [sp, #0x8]
 8011fa6: 2300         	movs	r3, #0x0
 8011fa8: 9301         	str	r3, [sp, #0x4]
 8011faa: 2300         	movs	r3, #0x0
 8011fac: 9300         	str	r3, [sp]
 8011fae: 2300         	movs	r3, #0x0
 8011fb0: 2201         	movs	r2, #0x1
 8011fb2: 4601         	mov	r1, r0
 8011fb4: 2000         	movs	r0, #0x0
 8011fb6: f013 fc94    	bl	0x80258e2 <z_log_msg_runtime_create> @ imm = #0x13928
 8011fba: 2300         	movs	r3, #0x0
 8011fbc: 627b         	str	r3, [r7, #0x24]
; 		return;
 8011fbe: e112         	b	0x80121e6 <can_rx_callback+0x2e6> @ imm = #0x224
 8011fc0: e111         	b	0x80121e6 <can_rx_callback+0x2e6> @ imm = #0x222
; 	int8_t bus_id = canbus_id(can_dev);
 8011fc2: 68f8         	ldr	r0, [r7, #0xc]
 8011fc4: f7ff fcd6    	bl	0x8011974 <canbus_id>   @ imm = #-0x654
 8011fc8: 4603         	mov	r3, r0
 8011fca: f887 3043    	strb.w	r3, [r7, #0x43]
; 	if (!ctrl_struct) {
 8011fce: 6c7b         	ldr	r3, [r7, #0x44]
 8011fd0: 2b00         	cmp	r3, #0x0
 8011fd2: f000 8103    	beq.w	0x80121dc <can_rx_callback+0x2dc> @ imm = #0x206
; 	struct dji_motor_data *motor_data = ctrl_struct->motor_devs[id]->data;
 8011fd6: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8011fda: 6c7a         	ldr	r2, [r7, #0x44]
 8011fdc: 3310         	adds	r3, #0x10
 8011fde: 009b         	lsls	r3, r3, #0x2
 8011fe0: 4413         	add	r3, r2
 8011fe2: 685b         	ldr	r3, [r3, #0x4]
 8011fe4: 691b         	ldr	r3, [r3, #0x10]
 8011fe6: 63fb         	str	r3, [r7, #0x3c]
; 	uint32_t prev_time = motor_data->curr_time;
 8011fe8: 6bfb         	ldr	r3, [r7, #0x3c]
 8011fea: 6b1b         	ldr	r3, [r3, #0x30]
 8011fec: 63bb         	str	r3, [r7, #0x38]
; 	if (!motor_data) {
 8011fee: 6bfb         	ldr	r3, [r7, #0x3c]
 8011ff0: 2b00         	cmp	r3, #0x0
 8011ff2: f000 80f5    	beq.w	0x80121e0 <can_rx_callback+0x2e0> @ imm = #0x1ea
; 	if (motor_data->missed_times > 3) {
 8011ff6: 6bfb         	ldr	r3, [r7, #0x3c]
 8011ff8: f993 303c    	ldrsb.w	r3, [r3, #0x3c]
 8011ffc: 2b03         	cmp	r3, #0x3
 8011ffe: dd55         	ble	0x80120ac <can_rx_callback+0x1ac> @ imm = #0xaa
; 		LOG_ERR("Motor %d is responding again, resuming...", id);
 8012000: 2304         	movs	r3, #0x4
 8012002: 2b00         	cmp	r3, #0x0
 8012004: d01b         	beq	0x801203e <can_rx_callback+0x13e> @ imm = #0x36
 8012006: 2301         	movs	r3, #0x1
 8012008: f887 3037    	strb.w	r3, [r7, #0x37]
 801200c: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8012010: f083 0301    	eor	r3, r3, #0x1
 8012014: b2db         	uxtb	r3, r3
 8012016: 2b00         	cmp	r3, #0x0
 8012018: d111         	bne	0x801203e <can_rx_callback+0x13e> @ imm = #0x22
 801201a: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x80121ec <can_rx_callback+0x2ec>
 801201c: 6819         	ldr	r1, [r3]
 801201e: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8012022: 9303         	str	r3, [sp, #0xc]
 8012024: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x80121f4 <can_rx_callback+0x2f4>
 8012026: 9302         	str	r3, [sp, #0x8]
 8012028: 2300         	movs	r3, #0x0
 801202a: 9301         	str	r3, [sp, #0x4]
 801202c: 2300         	movs	r3, #0x0
 801202e: 9300         	str	r3, [sp]
 8012030: 2300         	movs	r3, #0x0
 8012032: 2201         	movs	r2, #0x1
 8012034: 2000         	movs	r0, #0x0
 8012036: f013 fc54    	bl	0x80258e2 <z_log_msg_runtime_create> @ imm = #0x138a8
 801203a: 2300         	movs	r3, #0x0
 801203c: 633b         	str	r3, [r7, #0x30]
; 		motor_data->missed_times = 0;
 801203e: 6bfb         	ldr	r3, [r7, #0x3c]
 8012040: 2200         	movs	r2, #0x0
 8012042: f883 203c    	strb.w	r2, [r3, #0x3c]
; 		motor_data->online = true;
 8012046: 6bfb         	ldr	r3, [r7, #0x3c]
 8012048: 2201         	movs	r2, #0x1
 801204a: f883 2020    	strb.w	r2, [r3, #0x20]
; 			(const struct dji_motor_config *)ctrl_struct->motor_devs[id]->config;
 801204e: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8012052: 6c7a         	ldr	r2, [r7, #0x44]
 8012054: 3310         	adds	r3, #0x10
 8012056: 009b         	lsls	r3, r3, #0x2
 8012058: 4413         	add	r3, r2
 801205a: 685b         	ldr	r3, [r3, #0x4]
; 		const struct dji_motor_config *motor_cfg =
 801205c: 685b         	ldr	r3, [r3, #0x4]
 801205e: 62fb         	str	r3, [r7, #0x2c]
; 		ctrl_struct[bus_id].mask[frames_id(motor_cfg->common.tx_id)] ^= 1 << id;
 8012060: f997 3043    	ldrsb.w	r3, [r7, #0x43]
 8012064: 2274         	movs	r2, #0x74
 8012066: fb02 f303    	mul	r3, r2, r3
 801206a: 6c7a         	ldr	r2, [r7, #0x44]
 801206c: 18d4         	adds	r4, r2, r3
 801206e: 6afb         	ldr	r3, [r7, #0x2c]
 8012070: 689b         	ldr	r3, [r3, #0x8]
 8012072: 4618         	mov	r0, r3
 8012074: f013 fd11    	bl	0x8025a9a <frames_id>   @ imm = #0x13a22
 8012078: 4603         	mov	r3, r0
 801207a: 18e2         	adds	r2, r4, r3
 801207c: f892 203e    	ldrb.w	r2, [r2, #0x3e]
 8012080: b251         	sxtb	r1, r2
 8012082: f897 204b    	ldrb.w	r2, [r7, #0x4b]
 8012086: 2001         	movs	r0, #0x1
 8012088: fa00 f202    	lsl.w	r2, r0, r2
 801208c: b252         	sxtb	r2, r2
 801208e: 404a         	eors	r2, r1
 8012090: b250         	sxtb	r0, r2
 8012092: f997 2043    	ldrsb.w	r2, [r7, #0x43]
 8012096: 2174         	movs	r1, #0x74
 8012098: fb01 f202    	mul	r2, r1, r2
 801209c: 6c79         	ldr	r1, [r7, #0x44]
 801209e: 440a         	add	r2, r1
 80120a0: b2c1         	uxtb	r1, r0
 80120a2: 4413         	add	r3, r2
 80120a4: 460a         	mov	r2, r1
 80120a6: f883 203e    	strb.w	r2, [r3, #0x3e]
 80120aa: e00e         	b	0x80120ca <can_rx_callback+0x1ca> @ imm = #0x1c
; 	} else if (motor_data->missed_times > 0) {
 80120ac: 6bfb         	ldr	r3, [r7, #0x3c]
 80120ae: f993 303c    	ldrsb.w	r3, [r3, #0x3c]
 80120b2: 2b00         	cmp	r3, #0x0
 80120b4: dd09         	ble	0x80120ca <can_rx_callback+0x1ca> @ imm = #0x12
; 		motor_data->missed_times--;
 80120b6: 6bfb         	ldr	r3, [r7, #0x3c]
 80120b8: f993 303c    	ldrsb.w	r3, [r3, #0x3c]
 80120bc: b2db         	uxtb	r3, r3
 80120be: 3b01         	subs	r3, #0x1
 80120c0: b2db         	uxtb	r3, r3
 80120c2: b25a         	sxtb	r2, r3
 80120c4: 6bfb         	ldr	r3, [r7, #0x3c]
 80120c6: f883 203c    	strb.w	r2, [r3, #0x3c]
; 	motor_data->RAWprev_angle = motor_data->RAWangle;
 80120ca: 6bfb         	ldr	r3, [r7, #0x3c]
 80120cc: 8c9a         	ldrh	r2, [r3, #0x24]
 80120ce: 6bfb         	ldr	r3, [r7, #0x3c]
 80120d0: 84da         	strh	r2, [r3, #0x26]
; 	motor_data->RAWangle = COMBINE_HL8(rx_frame.data[0], rx_frame.data[1]);
 80120d2: 7f3b         	ldrb	r3, [r7, #0x1c]
 80120d4: 021b         	lsls	r3, r3, #0x8
 80120d6: b29b         	uxth	r3, r3
 80120d8: 7f7a         	ldrb	r2, [r7, #0x1d]
 80120da: 4413         	add	r3, r2
 80120dc: b29a         	uxth	r2, r3
 80120de: 6bfb         	ldr	r3, [r7, #0x3c]
 80120e0: 849a         	strh	r2, [r3, #0x24]
; 	motor_data->RAWrpm = COMBINE_HL8(rx_frame.data[2], rx_frame.data[3]);
 80120e2: 7fbb         	ldrb	r3, [r7, #0x1e]
 80120e4: 021b         	lsls	r3, r3, #0x8
 80120e6: b29b         	uxth	r3, r3
 80120e8: 7ffa         	ldrb	r2, [r7, #0x1f]
 80120ea: 4413         	add	r3, r2
 80120ec: b29b         	uxth	r3, r3
 80120ee: b21a         	sxth	r2, r3
 80120f0: 6bfb         	ldr	r3, [r7, #0x3c]
 80120f2: 859a         	strh	r2, [r3, #0x2c]
; 	motor_data->RAWcurrent = COMBINE_HL8(rx_frame.data[4], rx_frame.data[5]);
 80120f4: f897 3020    	ldrb.w	r3, [r7, #0x20]
 80120f8: 021b         	lsls	r3, r3, #0x8
 80120fa: f897 2021    	ldrb.w	r2, [r7, #0x21]
 80120fe: 441a         	add	r2, r3
 8012100: 6bfb         	ldr	r3, [r7, #0x3c]
 8012102: 629a         	str	r2, [r3, #0x28]
; 	motor_data->RAWtemp = rx_frame.data[6];
 8012104: f897 3022    	ldrb.w	r3, [r7, #0x22]
 8012108: b25a         	sxtb	r2, r3
 801210a: 6bfb         	ldr	r3, [r7, #0x3c]
 801210c: f883 202e    	strb.w	r2, [r3, #0x2e]
; 	ctrl_struct[bus_id].flags |= 1 << id;
 8012110: f997 3043    	ldrsb.w	r3, [r7, #0x43]
 8012114: 2274         	movs	r2, #0x74
 8012116: fb02 f303    	mul	r3, r2, r3
 801211a: 6c7a         	ldr	r2, [r7, #0x44]
 801211c: 4413         	add	r3, r2
 801211e: f893 303d    	ldrb.w	r3, [r3, #0x3d]
 8012122: b25a         	sxtb	r2, r3
 8012124: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8012128: 2101         	movs	r1, #0x1
 801212a: fa01 f303    	lsl.w	r3, r1, r3
 801212e: b25b         	sxtb	r3, r3
 8012130: 4313         	orrs	r3, r2
 8012132: b259         	sxtb	r1, r3
 8012134: f997 3043    	ldrsb.w	r3, [r7, #0x43]
 8012138: 2274         	movs	r2, #0x74
 801213a: fb02 f303    	mul	r3, r2, r3
 801213e: 6c7a         	ldr	r2, [r7, #0x44]
 8012140: 4413         	add	r3, r2
 8012142: b2ca         	uxtb	r2, r1
 8012144: f883 203d    	strb.w	r2, [r3, #0x3d]
; 	motor_data->curr_time = curr_time;
 8012148: 6bfb         	ldr	r3, [r7, #0x3c]
 801214a: 6d7a         	ldr	r2, [r7, #0x54]
 801214c: 631a         	str	r2, [r3, #0x30]
; 	motor_data->prev_time = prev_time;
 801214e: 6bfb         	ldr	r3, [r7, #0x3c]
 8012150: 6bba         	ldr	r2, [r7, #0x38]
 8012152: 635a         	str	r2, [r3, #0x34]
; 	bool full = false;
 8012154: 2300         	movs	r3, #0x0
 8012156: f887 3053    	strb.w	r3, [r7, #0x53]
; 	for (int i = 0; i < 5; i++) {
 801215a: 2300         	movs	r3, #0x0
 801215c: 64fb         	str	r3, [r7, #0x4c]
 801215e: e030         	b	0x80121c2 <can_rx_callback+0x2c2> @ imm = #0x60
; 		uint8_t combined = ctrl_struct[bus_id].mask[i] | ctrl_struct[bus_id].flags;
 8012160: f997 3043    	ldrsb.w	r3, [r7, #0x43]
 8012164: 2274         	movs	r2, #0x74
 8012166: fb02 f303    	mul	r3, r2, r3
 801216a: 6c7a         	ldr	r2, [r7, #0x44]
 801216c: 441a         	add	r2, r3
 801216e: 6cfb         	ldr	r3, [r7, #0x4c]
 8012170: 4413         	add	r3, r2
 8012172: 333e         	adds	r3, #0x3e
 8012174: 781a         	ldrb	r2, [r3]
 8012176: f997 3043    	ldrsb.w	r3, [r7, #0x43]
 801217a: 2174         	movs	r1, #0x74
 801217c: fb01 f303    	mul	r3, r1, r3
 8012180: 6c79         	ldr	r1, [r7, #0x44]
 8012182: 440b         	add	r3, r1
 8012184: f893 303d    	ldrb.w	r3, [r3, #0x3d]
 8012188: 4313         	orrs	r3, r2
 801218a: f887 302b    	strb.w	r3, [r7, #0x2b]
; 		if (combined == 0xF0 || combined == 0x0F) {
 801218e: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8012192: 2bf0         	cmp	r3, #0xf0
 8012194: d003         	beq	0x801219e <can_rx_callback+0x29e> @ imm = #0x6
 8012196: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 801219a: 2b0f         	cmp	r3, #0xf
 801219c: d10e         	bne	0x80121bc <can_rx_callback+0x2bc> @ imm = #0x1c
; 			ctrl_struct[bus_id].full[i] = true;
 801219e: f997 3043    	ldrsb.w	r3, [r7, #0x43]
 80121a2: 2274         	movs	r2, #0x74
 80121a4: fb02 f303    	mul	r3, r2, r3
 80121a8: 6c7a         	ldr	r2, [r7, #0x44]
 80121aa: 441a         	add	r2, r3
 80121ac: 6cfb         	ldr	r3, [r7, #0x4c]
 80121ae: 4413         	add	r3, r2
 80121b0: 3324         	adds	r3, #0x24
 80121b2: 2201         	movs	r2, #0x1
 80121b4: 701a         	strb	r2, [r3]
; 			full = true;
 80121b6: 2301         	movs	r3, #0x1
 80121b8: f887 3053    	strb.w	r3, [r7, #0x53]
; 	for (int i = 0; i < 5; i++) {
 80121bc: 6cfb         	ldr	r3, [r7, #0x4c]
 80121be: 3301         	adds	r3, #0x1
 80121c0: 64fb         	str	r3, [r7, #0x4c]
 80121c2: 6cfb         	ldr	r3, [r7, #0x4c]
 80121c4: 2b04         	cmp	r3, #0x4
 80121c6: ddcb         	ble	0x8012160 <can_rx_callback+0x260> @ imm = #-0x6a
; 	if (full) {
 80121c8: f897 3053    	ldrb.w	r3, [r7, #0x53]
 80121cc: 2b00         	cmp	r3, #0x0
 80121ce: d009         	beq	0x80121e4 <can_rx_callback+0x2e4> @ imm = #0x12
; 		k_sem_give(&ctrl_struct->thread_sem);
 80121d0: 6c7b         	ldr	r3, [r7, #0x44]
 80121d2: 3364         	adds	r3, #0x64
 80121d4: 4618         	mov	r0, r3
 80121d6: f013 fb79    	bl	0x80258cc <k_sem_give>  @ imm = #0x136f2
; 	return;
 80121da: e003         	b	0x80121e4 <can_rx_callback+0x2e4> @ imm = #0x6
; 		return;
 80121dc: bf00         	nop
 80121de: e002         	b	0x80121e6 <can_rx_callback+0x2e6> @ imm = #0x4
; 		return;
 80121e0: bf00         	nop
 80121e2: e000         	b	0x80121e6 <can_rx_callback+0x2e6> @ imm = #0x0
; 	return;
 80121e4: bf00         	nop
; }
 80121e6: 375c         	adds	r7, #0x5c
 80121e8: 46bd         	mov	sp, r7
 80121ea: bd90         	pop	{r4, r7, pc}

080121ec <$d>:
 80121ec: c4 07 00 24  	.word	0x240007c4
 80121f0: 90 c4 02 08  	.word	0x0802c490
 80121f4: c4 c4 02 08  	.word	0x0802c4c4

080121f8 <dji_timeout_handle>:
; {
 80121f8: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 80121fc: b08e         	sub	sp, #0x38
 80121fe: af04         	add	r7, sp, #0x10
 8012200: 60f8         	str	r0, [r7, #0xc]
 8012202: 60b9         	str	r1, [r7, #0x8]
 8012204: 607a         	str	r2, [r7, #0x4]
; 	struct dji_motor_data *motor_data = (struct dji_motor_data *)dev->data;
 8012206: 68fb         	ldr	r3, [r7, #0xc]
 8012208: 691b         	ldr	r3, [r3, #0x10]
 801220a: 627b         	str	r3, [r7, #0x24]
; 	const struct dji_motor_config *motor_cfg = (const struct dji_motor_config *)dev->config;
 801220c: 68fb         	ldr	r3, [r7, #0xc]
 801220e: 685b         	ldr	r3, [r3, #0x4]
 8012210: 623b         	str	r3, [r7, #0x20]
; 	if (motor_data->online == false) {
 8012212: 6a7b         	ldr	r3, [r7, #0x24]
 8012214: f893 3020    	ldrb.w	r3, [r3, #0x20]
 8012218: f083 0301    	eor	r3, r3, #0x1
 801221c: b2db         	uxtb	r3, r3
 801221e: 2b00         	cmp	r3, #0x0
 8012220: f040 808d    	bne.w	0x801233e <dji_timeout_handle+0x146> @ imm = #0x11a
; 	uint32_t prev_time = motor_data->curr_time;
 8012224: 6a7b         	ldr	r3, [r7, #0x24]
 8012226: 6b1b         	ldr	r3, [r3, #0x30]
 8012228: 61fb         	str	r3, [r7, #0x1c]
; 	if (k_cyc_to_us_near32(curr_time - prev_time) > 2000) {
 801222a: 68ba         	ldr	r2, [r7, #0x8]
 801222c: 69fb         	ldr	r3, [r7, #0x1c]
 801222e: 1ad3         	subs	r3, r2, r3
 8012230: f513 7f8a    	cmn.w	r3, #0x114
 8012234: d80b         	bhi	0x801224e <dji_timeout_handle+0x56> @ imm = #0x16
 8012236: 68ba         	ldr	r2, [r7, #0x8]
 8012238: 69fb         	ldr	r3, [r7, #0x1c]
 801223a: 1ad3         	subs	r3, r2, r3
 801223c: f203 1313    	addw	r3, r3, #0x113
 8012240: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8012348 <dji_timeout_handle+0x150>
 8012242: 4293         	cmp	r3, r2
 8012244: bf8c         	ite	hi
 8012246: 2301         	movhi	r3, #0x1
 8012248: 2300         	movls	r3, #0x0
 801224a: b2db         	uxtb	r3, r3
 801224c: e01c         	b	0x8012288 <dji_timeout_handle+0x90> @ imm = #0x38
 801224e: 68ba         	ldr	r2, [r7, #0x8]
 8012250: 69fb         	ldr	r3, [r7, #0x1c]
 8012252: 1ad3         	subs	r3, r2, r3
 8012254: 2200         	movs	r2, #0x0
 8012256: 461c         	mov	r4, r3
 8012258: 4615         	mov	r5, r2
 801225a: f240 1313    	movw	r3, #0x113
 801225e: eb14 0803    	adds.w	r8, r4, r3
 8012262: f145 0900    	adc	r9, r5, #0x0
 8012266: f240 2226    	movw	r2, #0x226
 801226a: f04f 0300    	mov.w	r3, #0x0
 801226e: 4640         	mov	r0, r8
 8012270: 4649         	mov	r1, r9
 8012272: f7ee f87d    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x11f06
 8012276: 4602         	mov	r2, r0
 8012278: 460b         	mov	r3, r1
 801227a: 4613         	mov	r3, r2
 801227c: f5b3 6ffa    	cmp.w	r3, #0x7d0
 8012280: bf8c         	ite	hi
 8012282: 2301         	movhi	r3, #0x1
 8012284: 2300         	movls	r3, #0x0
 8012286: b2db         	uxtb	r3, r3
 8012288: 2b00         	cmp	r3, #0x0
 801228a: d059         	beq	0x8012340 <dji_timeout_handle+0x148> @ imm = #0xb2
; 		motor_data->missed_times++;
 801228c: 6a7b         	ldr	r3, [r7, #0x24]
 801228e: f993 303c    	ldrsb.w	r3, [r3, #0x3c]
 8012292: b2db         	uxtb	r3, r3
 8012294: 3301         	adds	r3, #0x1
 8012296: b2db         	uxtb	r3, r3
 8012298: b25a         	sxtb	r2, r3
 801229a: 6a7b         	ldr	r3, [r7, #0x24]
 801229c: f883 203c    	strb.w	r2, [r3, #0x3c]
; 		if (motor_data->missed_times > 3) {
 80122a0: 6a7b         	ldr	r3, [r7, #0x24]
 80122a2: f993 303c    	ldrsb.w	r3, [r3, #0x3c]
 80122a6: 2b03         	cmp	r3, #0x3
 80122a8: dd4a         	ble	0x8012340 <dji_timeout_handle+0x148> @ imm = #0x94
; 			LOG_ERR("Motor %d is not responding", motor_cfg->common.id);
 80122aa: 2304         	movs	r3, #0x4
 80122ac: 2b00         	cmp	r3, #0x0
 80122ae: d019         	beq	0x80122e4 <dji_timeout_handle+0xec> @ imm = #0x32
 80122b0: 2301         	movs	r3, #0x1
 80122b2: 76fb         	strb	r3, [r7, #0x1b]
 80122b4: 7efb         	ldrb	r3, [r7, #0x1b]
 80122b6: f083 0301    	eor	r3, r3, #0x1
 80122ba: b2db         	uxtb	r3, r3
 80122bc: 2b00         	cmp	r3, #0x0
 80122be: d111         	bne	0x80122e4 <dji_timeout_handle+0xec> @ imm = #0x22
 80122c0: 4b22         	ldr	r3, [pc, #0x88]         @ 0x801234c <dji_timeout_handle+0x154>
 80122c2: 6819         	ldr	r1, [r3]
 80122c4: 6a3b         	ldr	r3, [r7, #0x20]
 80122c6: 791b         	ldrb	r3, [r3, #0x4]
 80122c8: 9303         	str	r3, [sp, #0xc]
 80122ca: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8012350 <dji_timeout_handle+0x158>
 80122cc: 9302         	str	r3, [sp, #0x8]
 80122ce: 2300         	movs	r3, #0x0
 80122d0: 9301         	str	r3, [sp, #0x4]
 80122d2: 2300         	movs	r3, #0x0
 80122d4: 9300         	str	r3, [sp]
 80122d6: 2300         	movs	r3, #0x0
 80122d8: 2201         	movs	r2, #0x1
 80122da: 2000         	movs	r0, #0x0
 80122dc: f013 fb01    	bl	0x80258e2 <z_log_msg_runtime_create> @ imm = #0x13602
 80122e0: 2300         	movs	r3, #0x0
 80122e2: 617b         	str	r3, [r7, #0x14]
; 			ctrl_struct[motor_data->canbus_id]
 80122e4: 6a7b         	ldr	r3, [r7, #0x24]
 80122e6: 7e1b         	ldrb	r3, [r3, #0x18]
 80122e8: 461a         	mov	r2, r3
 80122ea: 2374         	movs	r3, #0x74
 80122ec: fb02 f303    	mul	r3, r2, r3
 80122f0: 687a         	ldr	r2, [r7, #0x4]
 80122f2: 18d4         	adds	r4, r2, r3
; 				.mask[frames_id(motor_cfg->common.tx_id)] ^=
 80122f4: 6a3b         	ldr	r3, [r7, #0x20]
 80122f6: 689b         	ldr	r3, [r3, #0x8]
 80122f8: 4618         	mov	r0, r3
 80122fa: f013 fbce    	bl	0x8025a9a <frames_id>   @ imm = #0x1379c
 80122fe: 4603         	mov	r3, r0
 8012300: 18e2         	adds	r2, r4, r3
 8012302: f892 203e    	ldrb.w	r2, [r2, #0x3e]
 8012306: b251         	sxtb	r1, r2
; 				1 << (motor_cfg->common.id - 1);
 8012308: 6a3a         	ldr	r2, [r7, #0x20]
 801230a: 7912         	ldrb	r2, [r2, #0x4]
 801230c: 3a01         	subs	r2, #0x1
 801230e: 2001         	movs	r0, #0x1
 8012310: fa00 f202    	lsl.w	r2, r0, r2
; 				.mask[frames_id(motor_cfg->common.tx_id)] ^=
 8012314: b252         	sxtb	r2, r2
 8012316: 404a         	eors	r2, r1
 8012318: b250         	sxtb	r0, r2
; 			ctrl_struct[motor_data->canbus_id]
 801231a: 6a7a         	ldr	r2, [r7, #0x24]
 801231c: 7e12         	ldrb	r2, [r2, #0x18]
 801231e: 4611         	mov	r1, r2
 8012320: 2274         	movs	r2, #0x74
 8012322: fb01 f202    	mul	r2, r1, r2
 8012326: 6879         	ldr	r1, [r7, #0x4]
 8012328: 440a         	add	r2, r1
; 				.mask[frames_id(motor_cfg->common.tx_id)] ^=
 801232a: b2c1         	uxtb	r1, r0
 801232c: 4413         	add	r3, r2
 801232e: 460a         	mov	r2, r1
 8012330: f883 203e    	strb.w	r2, [r3, #0x3e]
; 			motor_data->online = false;
 8012334: 6a7b         	ldr	r3, [r7, #0x24]
 8012336: 2200         	movs	r2, #0x0
 8012338: f883 2020    	strb.w	r2, [r3, #0x20]
 801233c: e000         	b	0x8012340 <dji_timeout_handle+0x148> @ imm = #0x0
; 		return;
 801233e: bf00         	nop
; }
 8012340: 3728         	adds	r7, #0x28
 8012342: 46bd         	mov	sp, r7
 8012344: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

08012348 <$d>:
 8012348: 05 cb 10 00  	.word	0x0010cb05
 801234c: c4 07 00 24  	.word	0x240007c4
 8012350: f0 c4 02 08  	.word	0x0802c4f0

08012354 <motor_calc>:
; {
 8012354: b580         	push	{r7, lr}
 8012356: b088         	sub	sp, #0x20
 8012358: af00         	add	r7, sp, #0x0
 801235a: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev_temp = dev;
 801235c: 687b         	ldr	r3, [r7, #0x4]
 801235e: 617b         	str	r3, [r7, #0x14]
; 	struct dji_motor_data *data_temp = dev_temp->data;
 8012360: 697b         	ldr	r3, [r7, #0x14]
 8012362: 691b         	ldr	r3, [r3, #0x10]
 8012364: 613b         	str	r3, [r7, #0x10]
; 	const struct dji_motor_config *config_temp = dev_temp->config;
 8012366: 697b         	ldr	r3, [r7, #0x14]
 8012368: 685b         	ldr	r3, [r3, #0x4]
 801236a: 60fb         	str	r3, [r7, #0xc]
; 	data_temp->RAWangle_add += delta_degree(data_temp->RAWangle, data_temp->RAWprev_angle);
 801236c: 693b         	ldr	r3, [r7, #0x10]
 801236e: 8c9a         	ldrh	r2, [r3, #0x24]
 8012370: 693b         	ldr	r3, [r7, #0x10]
 8012372: 8cdb         	ldrh	r3, [r3, #0x26]
 8012374: 4619         	mov	r1, r3
 8012376: 4610         	mov	r0, r2
 8012378: f013 fc3c    	bl	0x8025bf4 <delta_degree> @ imm = #0x13878
 801237c: 4602         	mov	r2, r0
 801237e: 693b         	ldr	r3, [r7, #0x10]
 8012380: 6b9b         	ldr	r3, [r3, #0x38]
 8012382: 441a         	add	r2, r3
 8012384: 693b         	ldr	r3, [r7, #0x10]
 8012386: 639a         	str	r2, [r3, #0x38]
; 	data_temp->RAWangle_add %= (int)(8192 * config_temp->gear_ratio * 100);
 8012388: 693b         	ldr	r3, [r7, #0x10]
 801238a: 6b9b         	ldr	r3, [r3, #0x38]
 801238c: 68fa         	ldr	r2, [r7, #0xc]
 801238e: edd2 7a14    	<unknown>
 8012392: ed9f 7a6c    	<unknown>
 8012396: ee67 7a87    	<unknown>
 801239a: ed9f 7a6b    	<unknown>
 801239e: ee67 7a87    	<unknown>
 80123a2: eefd 7ae7    	<unknown>
 80123a6: ee17 1a90    	<unknown>
 80123aa: fb93 f2f1    	sdiv	r2, r3, r1
 80123ae: fb01 f202    	mul	r2, r1, r2
 80123b2: 1a9a         	subs	r2, r3, r2
 80123b4: 693b         	ldr	r3, [r7, #0x10]
 80123b6: 639a         	str	r2, [r3, #0x38]
; 	data_temp->common.angle = fmodf((float)(data_temp->RAWangle_add) *
 80123b8: 693b         	ldr	r3, [r7, #0x10]
 80123ba: 6b9b         	ldr	r3, [r3, #0x38]
 80123bc: ee07 3a90    	<unknown>
 80123c0: eeb8 7ae7    	<unknown>
; 						convert[data_temp->convert_num][ANGLE2DEGREE] /
 80123c4: 693b         	ldr	r3, [r7, #0x10]
 80123c6: f893 3021    	ldrb.w	r3, [r3, #0x21]
 80123ca: 4619         	mov	r1, r3
 80123cc: 4a5f         	ldr	r2, [pc, #0x17c]        @ 0x801254c <motor_calc+0x1f8>
 80123ce: 460b         	mov	r3, r1
 80123d0: 005b         	lsls	r3, r3, #0x1
 80123d2: 440b         	add	r3, r1
 80123d4: 00db         	lsls	r3, r3, #0x3
 80123d6: 4413         	add	r3, r2
 80123d8: 3310         	adds	r3, #0x10
 80123da: edd3 7a00    	<unknown>
; 	data_temp->common.angle = fmodf((float)(data_temp->RAWangle_add) *
 80123de: ee27 7a27    	<unknown>
; 						(4 * config_temp->gear_ratio),
 80123e2: 68fb         	ldr	r3, [r7, #0xc]
 80123e4: edd3 7a14    	<unknown>
 80123e8: eef1 6a00    	<unknown>
 80123ec: ee67 7aa6    	<unknown>
; 	data_temp->common.angle = fmodf((float)(data_temp->RAWangle_add) *
 80123f0: eec7 6a27    	<unknown>
 80123f4: eddf 0a56    	<unknown>
 80123f8: eeb0 0a66    	<unknown>
 80123fc: f007 fe7e    	bl	0x801a0fc <fmodf>       @ imm = #0x7cfc
 8012400: eef0 7a40    	<unknown>
 8012404: 693b         	ldr	r3, [r7, #0x10]
 8012406: edc3 7a00    	<unknown>
; 	data_temp->common.rpm = data_temp->RAWrpm * convert[data_temp->convert_num][SPEED2RPM] /
 801240a: 693b         	ldr	r3, [r7, #0x10]
 801240c: f9b3 302c    	ldrsh.w	r3, [r3, #0x2c]
 8012410: ee07 3a90    	<unknown>
 8012414: eeb8 7ae7    	<unknown>
 8012418: 693b         	ldr	r3, [r7, #0x10]
 801241a: f893 3021    	ldrb.w	r3, [r3, #0x21]
 801241e: 4619         	mov	r1, r3
 8012420: 4a4a         	ldr	r2, [pc, #0x128]        @ 0x801254c <motor_calc+0x1f8>
 8012422: 460b         	mov	r3, r1
 8012424: 005b         	lsls	r3, r3, #0x1
 8012426: 440b         	add	r3, r1
 8012428: 00db         	lsls	r3, r3, #0x3
 801242a: 4413         	add	r3, r2
 801242c: 3308         	adds	r3, #0x8
 801242e: edd3 7a00    	<unknown>
 8012432: ee67 6a27    	<unknown>
; 				config_temp->gear_ratio;
 8012436: 68fb         	ldr	r3, [r7, #0xc]
 8012438: ed93 7a14    	<unknown>
; 	data_temp->common.rpm = data_temp->RAWrpm * convert[data_temp->convert_num][SPEED2RPM] /
 801243c: eec6 7a87    	<unknown>
 8012440: 693b         	ldr	r3, [r7, #0x10]
 8012442: edc3 7a01    	<unknown>
; 	data_temp->common.torque = data_temp->RAWcurrent *
 8012446: 693b         	ldr	r3, [r7, #0x10]
 8012448: 6a9b         	ldr	r3, [r3, #0x28]
 801244a: ee07 3a90    	<unknown>
 801244e: eeb8 7ae7    	<unknown>
; 				   convert[data_temp->convert_num][CURRENT2TORQUE] *
 8012452: 693b         	ldr	r3, [r7, #0x10]
 8012454: f893 3021    	ldrb.w	r3, [r3, #0x21]
 8012458: 4619         	mov	r1, r3
 801245a: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x801254c <motor_calc+0x1f8>
 801245c: 460b         	mov	r3, r1
 801245e: 005b         	lsls	r3, r3, #0x1
 8012460: 440b         	add	r3, r1
 8012462: 00db         	lsls	r3, r3, #0x3
 8012464: 4413         	add	r3, r2
 8012466: edd3 7a00    	<unknown>
; 	data_temp->common.torque = data_temp->RAWcurrent *
 801246a: ee27 7a27    	<unknown>
; 				   config_temp->gear_ratio;
 801246e: 68fb         	ldr	r3, [r7, #0xc]
 8012470: edd3 7a14    	<unknown>
; 				   convert[data_temp->convert_num][CURRENT2TORQUE] *
 8012474: ee67 7a27    	<unknown>
; 	data_temp->common.torque = data_temp->RAWcurrent *
 8012478: 693b         	ldr	r3, [r7, #0x10]
 801247a: edc3 7a02    	<unknown>
; 	bool torque_proceeded = false;
 801247e: 2300         	movs	r3, #0x0
 8012480: 77fb         	strb	r3, [r7, #0x1f]
; 	for (int i = data_temp->current_mode_index;
 8012482: 693b         	ldr	r3, [r7, #0x10]
 8012484: f993 3022    	ldrsb.w	r3, [r3, #0x22]
 8012488: 61bb         	str	r3, [r7, #0x18]
 801248a: e050         	b	0x801252e <motor_calc+0x1da> @ imm = #0xa0
; 		if (config_temp->common.controller[i] == NULL) {
 801248c: 68fb         	ldr	r3, [r7, #0xc]
 801248e: 69ba         	ldr	r2, [r7, #0x18]
 8012490: 3204         	adds	r2, #0x4
 8012492: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8012496: 2b00         	cmp	r3, #0x0
 8012498: d11d         	bne	0x80124d6 <motor_calc+0x182> @ imm = #0x3a
; 			if (torque_proceeded) {
 801249a: 7ffb         	ldrb	r3, [r7, #0x1f]
 801249c: 2b00         	cmp	r3, #0x0
 801249e: d14a         	bne	0x8012536 <motor_calc+0x1e2> @ imm = #0x94
; 			data_temp->target_current = data_temp->target_torque /
 80124a0: 693b         	ldr	r3, [r7, #0x10]
 80124a2: edd3 6a12    	<unknown>
; 						    config_temp->gear_ratio *
 80124a6: 68fb         	ldr	r3, [r7, #0xc]
 80124a8: edd3 7a14    	<unknown>
; 			data_temp->target_current = data_temp->target_torque /
 80124ac: ee86 7aa7    	<unknown>
; 						    convert[data_temp->convert_num][TORQUE2CURRENT];
 80124b0: 693b         	ldr	r3, [r7, #0x10]
 80124b2: f893 3021    	ldrb.w	r3, [r3, #0x21]
 80124b6: 4619         	mov	r1, r3
 80124b8: 4a24         	ldr	r2, [pc, #0x90]         @ 0x801254c <motor_calc+0x1f8>
 80124ba: 460b         	mov	r3, r1
 80124bc: 005b         	lsls	r3, r3, #0x1
 80124be: 440b         	add	r3, r1
 80124c0: 00db         	lsls	r3, r3, #0x3
 80124c2: 4413         	add	r3, r2
 80124c4: 3304         	adds	r3, #0x4
 80124c6: edd3 7a00    	<unknown>
; 						    config_temp->gear_ratio *
 80124ca: ee67 7a27    	<unknown>
; 			data_temp->target_current = data_temp->target_torque /
 80124ce: 693b         	ldr	r3, [r7, #0x10]
 80124d0: edc3 7a13    	<unknown>
; 			break;
 80124d4: e032         	b	0x801253c <motor_calc+0x1e8> @ imm = #0x64
; 		pid_calc(config_temp->common.controller[i]);
 80124d6: 68fb         	ldr	r3, [r7, #0xc]
 80124d8: 69ba         	ldr	r2, [r7, #0x18]
 80124da: 3204         	adds	r2, #0x4
 80124dc: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 80124e0: 4618         	mov	r0, r3
 80124e2: f013 faa4    	bl	0x8025a2e <pid_calc>    @ imm = #0x13548
; 		if (strcmp(config_temp->common.capabilities[i], "torque") == 0) {
 80124e6: 69ba         	ldr	r2, [r7, #0x18]
 80124e8: 4613         	mov	r3, r2
 80124ea: 005b         	lsls	r3, r3, #0x1
 80124ec: 4413         	add	r3, r2
 80124ee: 009b         	lsls	r3, r3, #0x2
 80124f0: 3320         	adds	r3, #0x20
 80124f2: 68fa         	ldr	r2, [r7, #0xc]
 80124f4: 4413         	add	r3, r2
 80124f6: 4917         	ldr	r1, [pc, #0x5c]         @ 0x8012554 <motor_calc+0x200>
 80124f8: 4618         	mov	r0, r3
 80124fa: f7ed ff53    	bl	0x80003a4 <strcmp>      @ imm = #-0x1215a
 80124fe: 4603         	mov	r3, r0
 8012500: 2b00         	cmp	r3, #0x0
 8012502: d102         	bne	0x801250a <motor_calc+0x1b6> @ imm = #0x4
; 			torque_proceeded = true;
 8012504: 2301         	movs	r3, #0x1
 8012506: 77fb         	strb	r3, [r7, #0x1f]
 8012508: e00e         	b	0x8012528 <motor_calc+0x1d4> @ imm = #0x1c
; 		} else if (strcmp(config_temp->common.capabilities[i], "mit") == 0) {
 801250a: 69ba         	ldr	r2, [r7, #0x18]
 801250c: 4613         	mov	r3, r2
 801250e: 005b         	lsls	r3, r3, #0x1
 8012510: 4413         	add	r3, r2
 8012512: 009b         	lsls	r3, r3, #0x2
 8012514: 3320         	adds	r3, #0x20
 8012516: 68fa         	ldr	r2, [r7, #0xc]
 8012518: 4413         	add	r3, r2
 801251a: 490f         	ldr	r1, [pc, #0x3c]         @ 0x8012558 <motor_calc+0x204>
 801251c: 4618         	mov	r0, r3
 801251e: f7ed ff41    	bl	0x80003a4 <strcmp>      @ imm = #-0x1217e
 8012522: 4603         	mov	r3, r0
 8012524: 2b00         	cmp	r3, #0x0
 8012526: d008         	beq	0x801253a <motor_calc+0x1e6> @ imm = #0x10
; 	     i < SIZE_OF_ARRAY(config_temp->common.controller); i++) {
 8012528: 69bb         	ldr	r3, [r7, #0x18]
 801252a: 3301         	adds	r3, #0x1
 801252c: 61bb         	str	r3, [r7, #0x18]
 801252e: 69bb         	ldr	r3, [r7, #0x18]
 8012530: 2b03         	cmp	r3, #0x3
 8012532: d9ab         	bls	0x801248c <motor_calc+0x138> @ imm = #-0xaa
; }
 8012534: e002         	b	0x801253c <motor_calc+0x1e8> @ imm = #0x4
; 				break;
 8012536: bf00         	nop
 8012538: e000         	b	0x801253c <motor_calc+0x1e8> @ imm = #0x0
; 			break;
 801253a: bf00         	nop
; }
 801253c: bf00         	nop
 801253e: 3720         	adds	r7, #0x20
 8012540: 46bd         	mov	sp, r7
 8012542: bd80         	pop	{r7, pc}

08012544 <$d>:
 8012544: 00 00 00 46  	.word	0x46000000
 8012548: 00 00 c8 42  	.word	0x42c80000
 801254c: b4 da 02 08  	.word	0x0802dab4
 8012550: 00 00 b4 43  	.word	0x43b40000
 8012554: 58 c4 02 08  	.word	0x0802c458
 8012558: 0c c5 02 08  	.word	0x0802c50c

0801255c <can_send_entry>:
; {
 801255c: b590         	push	{r4, r7, lr}
 801255e: b09b         	sub	sp, #0x6c
 8012560: af04         	add	r7, sp, #0x10
 8012562: 60f8         	str	r0, [r7, #0xc]
 8012564: 60b9         	str	r1, [r7, #0x8]
 8012566: 607a         	str	r2, [r7, #0x4]
; 	k_sem_init(&(ctrl_struct[0].thread_sem), 0, 2);
 8012568: 68fb         	ldr	r3, [r7, #0xc]
 801256a: 3364         	adds	r3, #0x64
 801256c: 2202         	movs	r2, #0x2
 801256e: 2100         	movs	r1, #0x0
 8012570: 4618         	mov	r0, r3
 8012572: f013 f98b    	bl	0x802588c <k_sem_init>  @ imm = #0x13316
; 	struct device *can_dev = NULL;
 8012576: 2300         	movs	r3, #0x0
 8012578: 637b         	str	r3, [r7, #0x34]
; 	for (int i = 0; i < CAN_COUNT; i++) {
 801257a: 2300         	movs	r3, #0x0
 801257c: 64fb         	str	r3, [r7, #0x4c]
 801257e: e053         	b	0x8012628 <can_send_entry+0xcc> @ imm = #0xa6
; 		k_sem_init(&tx_queue_sem[i], 3, 3); // 初始化信号量
 8012580: 6cfb         	ldr	r3, [r7, #0x4c]
 8012582: 011b         	lsls	r3, r3, #0x4
 8012584: 4a44         	ldr	r2, [pc, #0x110]        @ 0x8012698 <can_send_entry+0x13c>
 8012586: 4413         	add	r3, r2
 8012588: 2203         	movs	r2, #0x3
 801258a: 2103         	movs	r1, #0x3
 801258c: 4618         	mov	r0, r3
 801258e: f013 f97d    	bl	0x802588c <k_sem_init>  @ imm = #0x132fa
; 		can_dev = (struct device *)ctrl_struct[i].can_dev;
 8012592: 6cfb         	ldr	r3, [r7, #0x4c]
 8012594: 2274         	movs	r2, #0x74
 8012596: fb02 f303    	mul	r3, r2, r3
 801259a: 68fa         	ldr	r2, [r7, #0xc]
 801259c: 4413         	add	r3, r2
 801259e: 681b         	ldr	r3, [r3]
 80125a0: 637b         	str	r3, [r7, #0x34]
; 		can_start(can_dev);
 80125a2: 6b78         	ldr	r0, [r7, #0x34]
 80125a4: f013 f9cb    	bl	0x802593e <can_start>   @ imm = #0x13396
; 		if (i != 0) {
 80125a8: 6cfb         	ldr	r3, [r7, #0x4c]
 80125aa: 2b00         	cmp	r3, #0x0
 80125ac: d00c         	beq	0x80125c8 <can_send_entry+0x6c> @ imm = #0x18
; 			ctrl_struct[i].thread_sem = ctrl_struct[0].thread_sem;
 80125ae: 6cfb         	ldr	r3, [r7, #0x4c]
 80125b0: 2274         	movs	r2, #0x74
 80125b2: fb02 f303    	mul	r3, r2, r3
 80125b6: 68fa         	ldr	r2, [r7, #0xc]
 80125b8: 441a         	add	r2, r3
 80125ba: 68fb         	ldr	r3, [r7, #0xc]
 80125bc: f102 0464    	add.w	r4, r2, #0x64
 80125c0: 3364         	adds	r3, #0x64
 80125c2: cb0f         	ldm	r3, {r0, r1, r2, r3}
 80125c4: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
; 		int err = can_add_rx_filter(can_dev, can_rx_callback, &ctrl_struct[i], &filter20x);
 80125c8: 6cfb         	ldr	r3, [r7, #0x4c]
 80125ca: 2274         	movs	r2, #0x74
 80125cc: fb02 f303    	mul	r3, r2, r3
 80125d0: 68fa         	ldr	r2, [r7, #0xc]
 80125d2: 441a         	add	r2, r3
 80125d4: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x801269c <can_send_entry+0x140>
 80125d6: 4932         	ldr	r1, [pc, #0xc8]         @ 0x80126a0 <can_send_entry+0x144>
 80125d8: 6b78         	ldr	r0, [r7, #0x34]
 80125da: f7f5 f879    	bl	0x80076d0 <can_add_rx_filter> @ imm = #-0xaf0e
 80125de: 6278         	str	r0, [r7, #0x24]
; 		if (err < 0) {
 80125e0: 6a7b         	ldr	r3, [r7, #0x24]
 80125e2: 2b00         	cmp	r3, #0x0
 80125e4: da1d         	bge	0x8012622 <can_send_entry+0xc6> @ imm = #0x3a
; 			LOG_ERR("Error adding CAN filter (err %d)", err);
 80125e6: 2304         	movs	r3, #0x4
 80125e8: 2b00         	cmp	r3, #0x0
 80125ea: d01a         	beq	0x8012622 <can_send_entry+0xc6> @ imm = #0x34
 80125ec: 2301         	movs	r3, #0x1
 80125ee: f887 3023    	strb.w	r3, [r7, #0x23]
 80125f2: f897 3023    	ldrb.w	r3, [r7, #0x23]
 80125f6: f083 0301    	eor	r3, r3, #0x1
 80125fa: b2db         	uxtb	r3, r3
 80125fc: 2b00         	cmp	r3, #0x0
 80125fe: d110         	bne	0x8012622 <can_send_entry+0xc6> @ imm = #0x20
 8012600: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x80126a4 <can_send_entry+0x148>
 8012602: 6819         	ldr	r1, [r3]
 8012604: 6a7b         	ldr	r3, [r7, #0x24]
 8012606: 9303         	str	r3, [sp, #0xc]
 8012608: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x80126a8 <can_send_entry+0x14c>
 801260a: 9302         	str	r3, [sp, #0x8]
 801260c: 2300         	movs	r3, #0x0
 801260e: 9301         	str	r3, [sp, #0x4]
 8012610: 2300         	movs	r3, #0x0
 8012612: 9300         	str	r3, [sp]
 8012614: 2300         	movs	r3, #0x0
 8012616: 2201         	movs	r2, #0x1
 8012618: 2000         	movs	r0, #0x0
 801261a: f013 f962    	bl	0x80258e2 <z_log_msg_runtime_create> @ imm = #0x132c4
 801261e: 2300         	movs	r3, #0x0
 8012620: 61fb         	str	r3, [r7, #0x1c]
; 	for (int i = 0; i < CAN_COUNT; i++) {
 8012622: 6cfb         	ldr	r3, [r7, #0x4c]
 8012624: 3301         	adds	r3, #0x1
 8012626: 64fb         	str	r3, [r7, #0x4c]
 8012628: 6cfb         	ldr	r3, [r7, #0x4c]
 801262a: 2b02         	cmp	r3, #0x2
 801262c: dda8         	ble	0x8012580 <can_send_entry+0x24> @ imm = #-0xb0
; 	int err = 0;
 801262e: 2300         	movs	r3, #0x0
 8012630: 64bb         	str	r3, [r7, #0x48]
; 	k_sleep(K_MSEC(60));
 8012632: f44f 7216    	mov.w	r2, #0x258
 8012636: f04f 0300    	mov.w	r3, #0x0
 801263a: 4610         	mov	r0, r2
 801263c: 4619         	mov	r1, r3
 801263e: f013 f90c    	bl	0x802585a <k_sleep>     @ imm = #0x13218
; 		for (int8_t i = 0; i < CAN_COUNT; i++) {
 8012642: 2300         	movs	r3, #0x0
 8012644: f887 3057    	strb.w	r3, [r7, #0x57]
 8012648: e119         	b	0x801287e <can_send_entry+0x322> @ imm = #0x232
; 			for (int j = 0; j < 5; j++) {
 801264a: 2300         	movs	r3, #0x0
 801264c: 653b         	str	r3, [r7, #0x50]
 801264e: e10b         	b	0x8012868 <can_send_entry+0x30c> @ imm = #0x216
; 				if (ctrl_struct[i].full[j] == 1) {
 8012650: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 8012654: 2274         	movs	r2, #0x74
 8012656: fb02 f303    	mul	r3, r2, r3
 801265a: 68fa         	ldr	r2, [r7, #0xc]
 801265c: 441a         	add	r2, r3
 801265e: 6d3b         	ldr	r3, [r7, #0x50]
 8012660: 4413         	add	r3, r2
 8012662: 3324         	adds	r3, #0x24
 8012664: 781b         	ldrb	r3, [r3]
 8012666: 2b00         	cmp	r3, #0x0
 8012668: f000 80fb    	beq.w	0x8012862 <can_send_entry+0x306> @ imm = #0x1f6
; 					uint8_t id_temp = ctrl_struct[i].mapping[0][0];
 801266c: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 8012670: 2274         	movs	r2, #0x74
 8012672: fb02 f303    	mul	r3, r2, r3
 8012676: 68fa         	ldr	r2, [r7, #0xc]
 8012678: 4413         	add	r3, r2
 801267a: f893 3029    	ldrb.w	r3, [r3, #0x29]
 801267e: f887 302f    	strb.w	r3, [r7, #0x2f]
; 					uint8_t data[8] = {0};
 8012682: 2300         	movs	r3, #0x0
 8012684: 617b         	str	r3, [r7, #0x14]
 8012686: 2300         	movs	r3, #0x0
 8012688: 61bb         	str	r3, [r7, #0x18]
; 					bool packed = false;
 801268a: 2300         	movs	r3, #0x0
 801268c: f887 3047    	strb.w	r3, [r7, #0x47]
; 					for (int k = 0; k < 4; k++) {
 8012690: 2300         	movs	r3, #0x0
 8012692: 643b         	str	r3, [r7, #0x40]
 8012694: e076         	b	0x8012784 <can_send_entry+0x228> @ imm = #0xec
 8012696: bf00         	nop

08012698 <$d>:
 8012698: ac 30 00 24  	.word	0x240030ac
 801269c: 1c db 02 08  	.word	0x0802db1c
 80126a0: 01 1f 01 08  	.word	0x08011f01
 80126a4: c4 07 00 24  	.word	0x240007c4
 80126a8: 10 c5 02 08  	.word	0x0802c510

080126ac <$t>:
; 						id_temp = ctrl_struct[i].mapping[j][k];
 80126ac: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 80126b0: 2274         	movs	r2, #0x74
 80126b2: fb02 f303    	mul	r3, r2, r3
 80126b6: 68fa         	ldr	r2, [r7, #0xc]
 80126b8: 441a         	add	r2, r3
 80126ba: 6d3b         	ldr	r3, [r7, #0x50]
 80126bc: 009b         	lsls	r3, r3, #0x2
 80126be: 441a         	add	r2, r3
 80126c0: 6c3b         	ldr	r3, [r7, #0x40]
 80126c2: 4413         	add	r3, r2
 80126c4: 3329         	adds	r3, #0x29
 80126c6: 781b         	ldrb	r3, [r3]
 80126c8: f887 302f    	strb.w	r3, [r7, #0x2f]
; 						if (id_temp < 8 &&
 80126cc: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 80126d0: 2b07         	cmp	r3, #0x7
 80126d2: d854         	bhi	0x801277e <can_send_entry+0x222> @ imm = #0xa8
; 						    (ctrl_struct[i].flags & (1 << id_temp))) {
 80126d4: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 80126d8: 2274         	movs	r2, #0x74
 80126da: fb02 f303    	mul	r3, r2, r3
 80126de: 68fa         	ldr	r2, [r7, #0xc]
 80126e0: 4413         	add	r3, r2
 80126e2: f893 303d    	ldrb.w	r3, [r3, #0x3d]
 80126e6: 461a         	mov	r2, r3
; 						if (id_temp < 8 &&
 80126e8: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 80126ec: fa42 f303    	asr.w	r3, r2, r3
 80126f0: f003 0301    	and	r3, r3, #0x1
 80126f4: 2b00         	cmp	r3, #0x0
 80126f6: d042         	beq	0x801277e <can_send_entry+0x222> @ imm = #0x84
; 								ctrl_struct[i].motor_devs[id_temp]);
 80126f8: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 80126fc: 2274         	movs	r2, #0x74
 80126fe: fb02 f303    	mul	r3, r2, r3
 8012702: 68fa         	ldr	r2, [r7, #0xc]
 8012704: 441a         	add	r2, r3
; 							motor_calc(
 8012706: f897 302f    	ldrb.w	r3, [r7, #0x2f]
; 								ctrl_struct[i].motor_devs[id_temp]);
 801270a: 3310         	adds	r3, #0x10
 801270c: 009b         	lsls	r3, r3, #0x2
 801270e: 4413         	add	r3, r2
 8012710: 685b         	ldr	r3, [r3, #0x4]
; 							motor_calc(
 8012712: 4618         	mov	r0, r3
 8012714: f7ff fe1e    	bl	0x8012354 <motor_calc>  @ imm = #-0x3c4
; 								ctrl_struct[i].motor_devs[id_temp],
 8012718: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 801271c: 2274         	movs	r2, #0x74
 801271e: fb02 f303    	mul	r3, r2, r3
 8012722: 68fa         	ldr	r2, [r7, #0xc]
 8012724: 441a         	add	r2, r3
; 							can_pack_add(
 8012726: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 801272a: 3310         	adds	r3, #0x10
 801272c: 009b         	lsls	r3, r3, #0x2
 801272e: 4413         	add	r3, r2
 8012730: 6859         	ldr	r1, [r3, #0x4]
 8012732: 6c3b         	ldr	r3, [r7, #0x40]
 8012734: b2da         	uxtb	r2, r3
 8012736: f107 0314    	add.w	r3, r7, #0x14
 801273a: 4618         	mov	r0, r3
 801273c: f013 fa86    	bl	0x8025c4c <can_pack_add> @ imm = #0x1350c
; 							ctrl_struct[i].flags ^= 1 << id_temp;
 8012740: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 8012744: 2274         	movs	r2, #0x74
 8012746: fb02 f303    	mul	r3, r2, r3
 801274a: 68fa         	ldr	r2, [r7, #0xc]
 801274c: 4413         	add	r3, r2
 801274e: f893 303d    	ldrb.w	r3, [r3, #0x3d]
 8012752: b25a         	sxtb	r2, r3
 8012754: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8012758: 2101         	movs	r1, #0x1
 801275a: fa01 f303    	lsl.w	r3, r1, r3
 801275e: b25b         	sxtb	r3, r3
 8012760: 4053         	eors	r3, r2
 8012762: b259         	sxtb	r1, r3
 8012764: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 8012768: 2274         	movs	r2, #0x74
 801276a: fb02 f303    	mul	r3, r2, r3
 801276e: 68fa         	ldr	r2, [r7, #0xc]
 8012770: 4413         	add	r3, r2
 8012772: b2ca         	uxtb	r2, r1
 8012774: f883 203d    	strb.w	r2, [r3, #0x3d]
; 							packed = true;
 8012778: 2301         	movs	r3, #0x1
 801277a: f887 3047    	strb.w	r3, [r7, #0x47]
; 					for (int k = 0; k < 4; k++) {
 801277e: 6c3b         	ldr	r3, [r7, #0x40]
 8012780: 3301         	adds	r3, #0x1
 8012782: 643b         	str	r3, [r7, #0x40]
 8012784: 6c3b         	ldr	r3, [r7, #0x40]
 8012786: 2b03         	cmp	r3, #0x3
 8012788: dd90         	ble	0x80126ac <can_send_entry+0x150> @ imm = #-0xe0
; 					if (packed) {
 801278a: f897 3047    	ldrb.w	r3, [r7, #0x47]
 801278e: 2b00         	cmp	r3, #0x0
 8012790: d067         	beq	0x8012862 <can_send_entry+0x306> @ imm = #0xce
; 						txframe.id = txframe_id(j);
 8012792: 6d38         	ldr	r0, [r7, #0x50]
 8012794: f013 f9ae    	bl	0x8025af4 <txframe_id>  @ imm = #0x1335c
 8012798: 4603         	mov	r3, r0
 801279a: 461a         	mov	r2, r3
 801279c: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8012910 <can_send_entry+0x3b4>
 801279e: 601a         	str	r2, [r3]
; 						txframe.dlc = 8;
 80127a0: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8012910 <can_send_entry+0x3b4>
 80127a2: 2208         	movs	r2, #0x8
 80127a4: 711a         	strb	r2, [r3, #0x4]
; 						txframe.flags = 0;
 80127a6: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x8012910 <can_send_entry+0x3b4>
 80127a8: 2200         	movs	r2, #0x0
 80127aa: 715a         	strb	r2, [r3, #0x5]
; 						memcpy(txframe.data, data, sizeof(data));
 80127ac: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8012910 <can_send_entry+0x3b4>
 80127ae: 3308         	adds	r3, #0x8
 80127b0: f107 0214    	add.w	r2, r7, #0x14
 80127b4: e892 0003    	ldm.w	r2, {r0, r1}
 80127b8: e883 0003    	stm.w	r3, {r0, r1}
; 						can_dev = (struct device *)ctrl_struct[i].can_dev;
 80127bc: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 80127c0: 2274         	movs	r2, #0x74
 80127c2: fb02 f303    	mul	r3, r2, r3
 80127c6: 68fa         	ldr	r2, [r7, #0xc]
 80127c8: 4413         	add	r3, r2
 80127ca: 681b         	ldr	r3, [r3]
 80127cc: 637b         	str	r3, [r7, #0x34]
; 						err = k_sem_take(&tx_queue_sem[i], K_NO_WAIT);
 80127ce: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 80127d2: 011b         	lsls	r3, r3, #0x4
 80127d4: 4a4f         	ldr	r2, [pc, #0x13c]        @ 0x8012914 <can_send_entry+0x3b8>
 80127d6: 1899         	adds	r1, r3, r2
 80127d8: f04f 0200    	mov.w	r2, #0x0
 80127dc: f04f 0300    	mov.w	r3, #0x0
 80127e0: 4608         	mov	r0, r1
 80127e2: f013 f863    	bl	0x80258ac <k_sem_take>  @ imm = #0x130c6
 80127e6: 64b8         	str	r0, [r7, #0x48]
; 						if (err == 0) {
 80127e8: 6cbb         	ldr	r3, [r7, #0x48]
 80127ea: 2b00         	cmp	r3, #0x0
 80127ec: d110         	bne	0x8012810 <can_send_entry+0x2b4> @ imm = #0x20
; 							err = can_send(can_dev, &txframe, K_NO_WAIT,
 80127ee: f04f 0200    	mov.w	r2, #0x0
 80127f2: f04f 0300    	mov.w	r3, #0x0
; 								       &tx_queue_sem[i]);
 80127f6: f997 1057    	ldrsb.w	r1, [r7, #0x57]
 80127fa: 0109         	lsls	r1, r1, #0x4
 80127fc: 4845         	ldr	r0, [pc, #0x114]        @ 0x8012914 <can_send_entry+0x3b8>
 80127fe: 4401         	add	r1, r0
; 							err = can_send(can_dev, &txframe, K_NO_WAIT,
 8012800: 9101         	str	r1, [sp, #0x4]
 8012802: 4945         	ldr	r1, [pc, #0x114]        @ 0x8012918 <can_send_entry+0x3bc>
 8012804: 9100         	str	r1, [sp]
 8012806: 4942         	ldr	r1, [pc, #0x108]        @ 0x8012910 <can_send_entry+0x3b4>
 8012808: 6b78         	ldr	r0, [r7, #0x34]
 801280a: f013 f8a4    	bl	0x8025956 <can_send>    @ imm = #0x13148
 801280e: 64b8         	str	r0, [r7, #0x48]
; 						if (err != 0 && err != -EAGAIN && err != -EBUSY) {
 8012810: 6cbb         	ldr	r3, [r7, #0x48]
 8012812: 2b00         	cmp	r3, #0x0
 8012814: d025         	beq	0x8012862 <can_send_entry+0x306> @ imm = #0x4a
 8012816: 6cbb         	ldr	r3, [r7, #0x48]
 8012818: f113 0f0b    	cmn.w	r3, #0xb
 801281c: d021         	beq	0x8012862 <can_send_entry+0x306> @ imm = #0x42
 801281e: 6cbb         	ldr	r3, [r7, #0x48]
 8012820: f113 0f10    	cmn.w	r3, #0x10
 8012824: d01d         	beq	0x8012862 <can_send_entry+0x306> @ imm = #0x3a
; 							LOG_ERR("Error sending CAN frame (err %d)",
 8012826: 2304         	movs	r3, #0x4
 8012828: 2b00         	cmp	r3, #0x0
 801282a: d01a         	beq	0x8012862 <can_send_entry+0x306> @ imm = #0x34
 801282c: 2301         	movs	r3, #0x1
 801282e: f887 302e    	strb.w	r3, [r7, #0x2e]
 8012832: f897 302e    	ldrb.w	r3, [r7, #0x2e]
 8012836: f083 0301    	eor	r3, r3, #0x1
 801283a: b2db         	uxtb	r3, r3
 801283c: 2b00         	cmp	r3, #0x0
 801283e: d110         	bne	0x8012862 <can_send_entry+0x306> @ imm = #0x20
 8012840: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x801291c <can_send_entry+0x3c0>
 8012842: 6819         	ldr	r1, [r3]
 8012844: 6cbb         	ldr	r3, [r7, #0x48]
 8012846: 9303         	str	r3, [sp, #0xc]
 8012848: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8012920 <can_send_entry+0x3c4>
 801284a: 9302         	str	r3, [sp, #0x8]
 801284c: 2300         	movs	r3, #0x0
 801284e: 9301         	str	r3, [sp, #0x4]
 8012850: 2300         	movs	r3, #0x0
 8012852: 9300         	str	r3, [sp]
 8012854: 2300         	movs	r3, #0x0
 8012856: 2201         	movs	r2, #0x1
 8012858: 2000         	movs	r0, #0x0
 801285a: f013 f842    	bl	0x80258e2 <z_log_msg_runtime_create> @ imm = #0x13084
 801285e: 2300         	movs	r3, #0x0
 8012860: 62bb         	str	r3, [r7, #0x28]
; 			for (int j = 0; j < 5; j++) {
 8012862: 6d3b         	ldr	r3, [r7, #0x50]
 8012864: 3301         	adds	r3, #0x1
 8012866: 653b         	str	r3, [r7, #0x50]
 8012868: 6d3b         	ldr	r3, [r7, #0x50]
 801286a: 2b04         	cmp	r3, #0x4
 801286c: f77f aef0    	ble.w	0x8012650 <can_send_entry+0xf4> @ imm = #-0x220
; 		for (int8_t i = 0; i < CAN_COUNT; i++) {
 8012870: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 8012874: b2db         	uxtb	r3, r3
 8012876: 3301         	adds	r3, #0x1
 8012878: b2db         	uxtb	r3, r3
 801287a: f887 3057    	strb.w	r3, [r7, #0x57]
 801287e: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 8012882: 2b02         	cmp	r3, #0x2
 8012884: f77f aee1    	ble.w	0x801264a <can_send_entry+0xee> @ imm = #-0x23e
; 		k_sem_take(&(ctrl_struct[0].thread_sem), K_MSEC(2));
 8012888: 68fb         	ldr	r3, [r7, #0xc]
 801288a: f103 0164    	add.w	r1, r3, #0x64
 801288e: f04f 0214    	mov.w	r2, #0x14
 8012892: f04f 0300    	mov.w	r3, #0x0
 8012896: 4608         	mov	r0, r1
 8012898: f013 f808    	bl	0x80258ac <k_sem_take>  @ imm = #0x13010
; 		int curr_time = k_cycle_get_32();
 801289c: f012 ffd6    	bl	0x802584c <k_cycle_get_32> @ imm = #0x12fac
 80128a0: 4603         	mov	r3, r0
 80128a2: 633b         	str	r3, [r7, #0x30]
; 		for (int i = 0; i < 2; i++) {
 80128a4: 2300         	movs	r3, #0x0
 80128a6: 63fb         	str	r3, [r7, #0x3c]
 80128a8: e02d         	b	0x8012906 <can_send_entry+0x3aa> @ imm = #0x5a
; 			for (int j = 0; j < 8; j++) {
 80128aa: 2300         	movs	r3, #0x0
 80128ac: 63bb         	str	r3, [r7, #0x38]
 80128ae: e024         	b	0x80128fa <can_send_entry+0x39e> @ imm = #0x48
; 				if (ctrl_struct[i].motor_devs[j]) {
 80128b0: 6bfb         	ldr	r3, [r7, #0x3c]
 80128b2: 2274         	movs	r2, #0x74
 80128b4: fb02 f303    	mul	r3, r2, r3
 80128b8: 68fa         	ldr	r2, [r7, #0xc]
 80128ba: 441a         	add	r2, r3
 80128bc: 6bbb         	ldr	r3, [r7, #0x38]
 80128be: 3310         	adds	r3, #0x10
 80128c0: 009b         	lsls	r3, r3, #0x2
 80128c2: 4413         	add	r3, r2
 80128c4: 685b         	ldr	r3, [r3, #0x4]
 80128c6: 2b00         	cmp	r3, #0x0
 80128c8: d014         	beq	0x80128f4 <can_send_entry+0x398> @ imm = #0x28
; 					dji_timeout_handle(ctrl_struct[i].motor_devs[i], curr_time,
 80128ca: 6bfb         	ldr	r3, [r7, #0x3c]
 80128cc: 2274         	movs	r2, #0x74
 80128ce: fb02 f303    	mul	r3, r2, r3
 80128d2: 68fa         	ldr	r2, [r7, #0xc]
 80128d4: 441a         	add	r2, r3
 80128d6: 6bfb         	ldr	r3, [r7, #0x3c]
 80128d8: 3310         	adds	r3, #0x10
 80128da: 009b         	lsls	r3, r3, #0x2
 80128dc: 4413         	add	r3, r2
 80128de: 6858         	ldr	r0, [r3, #0x4]
 80128e0: 6b39         	ldr	r1, [r7, #0x30]
; 							   &ctrl_struct[i]);
 80128e2: 6bfb         	ldr	r3, [r7, #0x3c]
 80128e4: 2274         	movs	r2, #0x74
 80128e6: fb02 f303    	mul	r3, r2, r3
; 					dji_timeout_handle(ctrl_struct[i].motor_devs[i], curr_time,
 80128ea: 68fa         	ldr	r2, [r7, #0xc]
 80128ec: 4413         	add	r3, r2
 80128ee: 461a         	mov	r2, r3
 80128f0: f7ff fc82    	bl	0x80121f8 <dji_timeout_handle> @ imm = #-0x6fc
; 			for (int j = 0; j < 8; j++) {
 80128f4: 6bbb         	ldr	r3, [r7, #0x38]
 80128f6: 3301         	adds	r3, #0x1
 80128f8: 63bb         	str	r3, [r7, #0x38]
 80128fa: 6bbb         	ldr	r3, [r7, #0x38]
 80128fc: 2b07         	cmp	r3, #0x7
 80128fe: ddd7         	ble	0x80128b0 <can_send_entry+0x354> @ imm = #-0x52
; 		for (int i = 0; i < 2; i++) {
 8012900: 6bfb         	ldr	r3, [r7, #0x3c]
 8012902: 3301         	adds	r3, #0x1
 8012904: 63fb         	str	r3, [r7, #0x3c]
 8012906: 6bfb         	ldr	r3, [r7, #0x3c]
 8012908: 2b01         	cmp	r3, #0x1
 801290a: ddce         	ble	0x80128aa <can_send_entry+0x34e> @ imm = #-0x64
; 	while (1) {
 801290c: e699         	b	0x8012642 <can_send_entry+0xe6> @ imm = #-0x2ce
 801290e: bf00         	nop

08012910 <$d>:
 8012910: dc 30 00 24  	.word	0x240030dc
 8012914: ac 30 00 24  	.word	0x240030ac
 8012918: d7 5b 02 08  	.word	0x08025bd7
 801291c: c4 07 00 24  	.word	0x240007c4
 8012920: 34 c5 02 08  	.word	0x0802c534

08012924 <float_equal>:
; static bool float_equal(float a, float b) { return fabsf(a - b) < 0.0001f; }
 8012924: b480         	push	{r7}
 8012926: b085         	sub	sp, #0x14
 8012928: af00         	add	r7, sp, #0x0
 801292a: ed87 0a01    	<unknown>
 801292e: edc7 0a00    	<unknown>
 8012932: ed97 7a01    	<unknown>
 8012936: edd7 7a00    	<unknown>
 801293a: ee77 7a67    	<unknown>
 801293e: edc7 7a03    	<unknown>
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 8012942: edd7 7a03    	<unknown>
 8012946: eef0 7ae7    	<unknown>
 801294a: edc7 7a02    	<unknown>
;     return result;
 801294e: edd7 7a02    	<unknown>
; static bool float_equal(float a, float b) { return fabsf(a - b) < 0.0001f; }
 8012952: ed9f 7a08    	<unknown>
 8012956: eef4 7ac7    	<unknown>
 801295a: eef1 fa10    	<unknown>
 801295e: bf4c         	ite	mi
 8012960: 2301         	movmi	r3, #0x1
 8012962: 2300         	movpl	r3, #0x0
 8012964: b2db         	uxtb	r3, r3
 8012966: 4618         	mov	r0, r3
 8012968: 3714         	adds	r7, #0x14
 801296a: 46bd         	mov	sp, r7
 801296c: f85d 7b04    	ldr	r7, [sp], #4
 8012970: 4770         	bx	lr
 8012972: bf00         	nop

08012974 <$d>:
 8012974: 17 b7 d1 38  	.word	0x38d1b717

08012978 <single_pid_calc>:
; static void single_pid_calc(const struct device *pid_dev) {
 8012978: b5b0         	push	{r4, r5, r7, lr}
 801297a: b08a         	sub	sp, #0x28
 801297c: af00         	add	r7, sp, #0x0
 801297e: 6078         	str	r0, [r7, #0x4]
;     const struct pid_single_config *pid_para = pid_dev->config;
 8012980: 6879         	ldr	r1, [r7, #0x4]
 8012982: 6849         	ldr	r1, [r1, #0x4]
 8012984: 6279         	str	r1, [r7, #0x24]
;     struct pid_single_data         *pid_data = pid_dev->data;
 8012986: 6879         	ldr	r1, [r7, #0x4]
 8012988: 6909         	ldr	r1, [r1, #0x10]
 801298a: 6239         	str	r1, [r7, #0x20]
;     if (pid_data->curr == NULL) {
 801298c: 6a39         	ldr	r1, [r7, #0x20]
 801298e: 6849         	ldr	r1, [r1, #0x4]
 8012990: 2900         	cmp	r1, #0x0
 8012992: f000 80a0    	beq.w	0x8012ad6 <single_pid_calc+0x15e> @ imm = #0x140
;     float kp     = pid_para->k_p;
 8012996: 6a79         	ldr	r1, [r7, #0x24]
 8012998: 6809         	ldr	r1, [r1]
 801299a: 61f9         	str	r1, [r7, #0x1c]
;     float ki     = pid_para->k_i;
 801299c: 6a79         	ldr	r1, [r7, #0x24]
 801299e: 6849         	ldr	r1, [r1, #0x4]
 80129a0: 61b9         	str	r1, [r7, #0x18]
;     float kd     = pid_para->k_d;
 80129a2: 6a79         	ldr	r1, [r7, #0x24]
 80129a4: 6889         	ldr	r1, [r1, #0x8]
 80129a6: 6179         	str	r1, [r7, #0x14]
;     float err    = *(pid_data->ref) - *(pid_data->curr);
 80129a8: 6a39         	ldr	r1, [r7, #0x20]
 80129aa: 6809         	ldr	r1, [r1]
 80129ac: ed91 7a00    	<unknown>
 80129b0: 6a39         	ldr	r1, [r7, #0x20]
 80129b2: 6849         	ldr	r1, [r1, #0x4]
 80129b4: edd1 7a00    	<unknown>
 80129b8: ee77 7a67    	<unknown>
 80129bc: edc7 7a04    	<unknown>
;     float deltaT = k_cyc_to_us_near32(*(pid_data->curr_time) - *(pid_data->prev_time));
 80129c0: 6a39         	ldr	r1, [r7, #0x20]
 80129c2: 6949         	ldr	r1, [r1, #0x14]
 80129c4: 6808         	ldr	r0, [r1]
 80129c6: 6a39         	ldr	r1, [r7, #0x20]
 80129c8: 6989         	ldr	r1, [r1, #0x18]
 80129ca: 6809         	ldr	r1, [r1]
 80129cc: 1a41         	subs	r1, r0, r1
 80129ce: 2900         	cmp	r1, #0x0
 80129d0: db12         	blt	0x80129f8 <single_pid_calc+0x80> @ imm = #0x24
 80129d2: 6a3b         	ldr	r3, [r7, #0x20]
 80129d4: 695b         	ldr	r3, [r3, #0x14]
 80129d6: 681a         	ldr	r2, [r3]
 80129d8: 6a3b         	ldr	r3, [r7, #0x20]
 80129da: 699b         	ldr	r3, [r3, #0x18]
 80129dc: 681b         	ldr	r3, [r3]
 80129de: 1ad3         	subs	r3, r2, r3
 80129e0: f203 1313    	addw	r3, r3, #0x113
 80129e4: 085b         	lsrs	r3, r3, #0x1
 80129e6: 4a3e         	ldr	r2, [pc, #0xf8]         @ 0x8012ae0 <single_pid_calc+0x168>
 80129e8: fba2 2303    	umull	r2, r3, r2, r3
 80129ec: 09db         	lsrs	r3, r3, #0x7
 80129ee: ee07 3a90    	<unknown>
 80129f2: eef8 7a67    	<unknown>
 80129f6: e01c         	b	0x8012a32 <single_pid_calc+0xba> @ imm = #0x38
 80129f8: 6a39         	ldr	r1, [r7, #0x20]
 80129fa: 6949         	ldr	r1, [r1, #0x14]
 80129fc: 6808         	ldr	r0, [r1]
 80129fe: 6a39         	ldr	r1, [r7, #0x20]
 8012a00: 6989         	ldr	r1, [r1, #0x18]
 8012a02: 6809         	ldr	r1, [r1]
 8012a04: 1a41         	subs	r1, r0, r1
 8012a06: 17c8         	asrs	r0, r1, #0x1f
 8012a08: 460a         	mov	r2, r1
 8012a0a: 4603         	mov	r3, r0
 8012a0c: f240 1113    	movw	r1, #0x113
 8012a10: 1854         	adds	r4, r2, r1
 8012a12: f143 0500    	adc	r5, r3, #0x0
 8012a16: f240 2226    	movw	r2, #0x226
 8012a1a: f04f 0300    	mov.w	r3, #0x0
 8012a1e: 4620         	mov	r0, r4
 8012a20: 4629         	mov	r1, r5
 8012a22: f7ed fca5    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x126b6
 8012a26: 4602         	mov	r2, r0
 8012a28: 460b         	mov	r3, r1
 8012a2a: ee07 2a90    	<unknown>
 8012a2e: eef8 7a67    	<unknown>
 8012a32: edc7 7a03    	<unknown>
;     if (!float_equal(ki, 0))
 8012a36: eddf 0a2b    	<unknown>
 8012a3a: ed97 0a06    	<unknown>
 8012a3e: f7ff ff71    	bl	0x8012924 <float_equal> @ imm = #-0x11e
 8012a42: 4603         	mov	r3, r0
 8012a44: f083 0301    	eor	r3, r3, #0x1
 8012a48: b2db         	uxtb	r3, r3
 8012a4a: 2b00         	cmp	r3, #0x0
 8012a4c: d015         	beq	0x8012a7a <single_pid_calc+0x102> @ imm = #0x2a
;         pid_data->err_integral += (err * deltaT) / (1000000 * ki);
 8012a4e: 6a3b         	ldr	r3, [r7, #0x20]
 8012a50: ed93 7a02    	<unknown>
 8012a54: edd7 6a04    	<unknown>
 8012a58: edd7 7a03    	<unknown>
 8012a5c: ee26 6aa7    	<unknown>
 8012a60: edd7 7a06    	<unknown>
 8012a64: eddf 6a20    	<unknown>
 8012a68: ee67 6aa6    	<unknown>
 8012a6c: eec6 7a26    	<unknown>
 8012a70: ee77 7a27    	<unknown>
 8012a74: 6a3b         	ldr	r3, [r7, #0x20]
 8012a76: edc3 7a02    	<unknown>
;     if (!float_equal(kd, 0)) {
 8012a7a: eddf 0a1a    	<unknown>
 8012a7e: ed97 0a05    	<unknown>
 8012a82: f7ff ff4f    	bl	0x8012924 <float_equal> @ imm = #-0x162
 8012a86: 4603         	mov	r3, r0
 8012a88: f083 0301    	eor	r3, r3, #0x1
 8012a8c: b2db         	uxtb	r3, r3
 8012a8e: 2b00         	cmp	r3, #0x0
 8012a90: d00c         	beq	0x8012aac <single_pid_calc+0x134> @ imm = #0x18
;         pid_data->err_derivate = kd * err / deltaT;
 8012a92: ed97 7a05    	<unknown>
 8012a96: edd7 7a04    	<unknown>
 8012a9a: ee67 6a27    	<unknown>
 8012a9e: ed97 7a03    	<unknown>
 8012aa2: eec6 7a87    	<unknown>
 8012aa6: 6a3b         	ldr	r3, [r7, #0x20]
 8012aa8: edc3 7a03    	<unknown>
;     *(pid_data->output) = kp * (err + pid_data->err_integral + pid_data->err_derivate);
 8012aac: 6a3b         	ldr	r3, [r7, #0x20]
 8012aae: ed93 7a02    	<unknown>
 8012ab2: edd7 7a04    	<unknown>
 8012ab6: ee37 7a27    	<unknown>
 8012aba: 6a3b         	ldr	r3, [r7, #0x20]
 8012abc: edd3 7a03    	<unknown>
 8012ac0: ee37 7a27    	<unknown>
 8012ac4: 6a3b         	ldr	r3, [r7, #0x20]
 8012ac6: 69db         	ldr	r3, [r3, #0x1c]
 8012ac8: edd7 7a07    	<unknown>
 8012acc: ee67 7a27    	<unknown>
 8012ad0: edc3 7a00    	<unknown>
;     return;
 8012ad4: e000         	b	0x8012ad8 <single_pid_calc+0x160> @ imm = #0x0
;         return;
 8012ad6: bf00         	nop
; }
 8012ad8: 3728         	adds	r7, #0x28
 8012ada: 46bd         	mov	sp, r7
 8012adc: bdb0         	pop	{r4, r5, r7, pc}
 8012ade: bf00         	nop

08012ae0 <$d>:
 8012ae0: 73 07 28 77  	.word	0x77280773
 8012ae4: 00 00 00 00  	.word	0x00000000
 8012ae8: 00 24 74 49  	.word	0x49742400

08012aec <uart_callback>:
; static void uart_callback(const struct device *dev, struct uart_event *evt, void *user_data) {
 8012aec: b580         	push	{r7, lr}
 8012aee: b096         	sub	sp, #0x58
 8012af0: af04         	add	r7, sp, #0x10
 8012af2: 60f8         	str	r0, [r7, #0xc]
 8012af4: 60b9         	str	r1, [r7, #0x8]
 8012af6: 607a         	str	r2, [r7, #0x4]
;     struct device           *sbus_dev = (struct device *)user_data;
 8012af8: 687b         	ldr	r3, [r7, #0x4]
 8012afa: 647b         	str	r3, [r7, #0x44]
;     struct sbus_driver_data *data     = sbus_dev->data;
 8012afc: 6c7b         	ldr	r3, [r7, #0x44]
 8012afe: 691b         	ldr	r3, [r3, #0x10]
 8012b00: 643b         	str	r3, [r7, #0x40]
;     switch (evt->type) {
 8012b02: 68bb         	ldr	r3, [r7, #0x8]
 8012b04: 781b         	ldrb	r3, [r3]
 8012b06: 3b02         	subs	r3, #0x2
 8012b08: 2b04         	cmp	r3, #0x4
 8012b0a: f200 80e9    	bhi.w	0x8012ce0 <uart_callback+0x1f4> @ imm = #0x1d2
 8012b0e: a201         	adr	r2, #4 <uart_callback+0x27>
 8012b10: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08012b14 <$d>:
 8012b14: 29 2b 01 08  	.word	0x08012b29
 8012b18: b5 2b 01 08  	.word	0x08012bb5
 8012b1c: f3 2b 01 08  	.word	0x08012bf3
 8012b20: e1 2c 01 08  	.word	0x08012ce1
 8012b24: 09 2c 01 08  	.word	0x08012c09

08012b28 <$t>:
;         uint8_t *p   = &(evt->data.rx.buf[evt->data.rx.offset]);
 8012b28: 68bb         	ldr	r3, [r7, #0x8]
 8012b2a: 685a         	ldr	r2, [r3, #0x4]
 8012b2c: 68bb         	ldr	r3, [r7, #0x8]
 8012b2e: 689b         	ldr	r3, [r3, #0x8]
 8012b30: 4413         	add	r3, r2
 8012b32: 627b         	str	r3, [r7, #0x24]
;         uint16_t len = evt->data.rx.len;
 8012b34: 68bb         	ldr	r3, [r7, #0x8]
 8012b36: 68db         	ldr	r3, [r3, #0xc]
 8012b38: 847b         	strh	r3, [r7, #0x22]
;         uint8_t *ptr_offset = p + find_begin(p, len);
 8012b3a: 8c7b         	ldrh	r3, [r7, #0x22]
 8012b3c: 4619         	mov	r1, r3
 8012b3e: 6a78         	ldr	r0, [r7, #0x24]
 8012b40: f013 fb11    	bl	0x8026166 <find_begin>  @ imm = #0x13622
 8012b44: 4603         	mov	r3, r0
 8012b46: 461a         	mov	r2, r3
 8012b48: 6a7b         	ldr	r3, [r7, #0x24]
 8012b4a: 4413         	add	r3, r2
 8012b4c: 61fb         	str	r3, [r7, #0x1c]
;         if (ptr_offset >= p && len >= 25 && ptr_offset < p + len) {
 8012b4e: 69fa         	ldr	r2, [r7, #0x1c]
 8012b50: 6a7b         	ldr	r3, [r7, #0x24]
 8012b52: 429a         	cmp	r2, r3
 8012b54: d30e         	blo	0x8012b74 <uart_callback+0x88> @ imm = #0x1c
 8012b56: 8c7b         	ldrh	r3, [r7, #0x22]
 8012b58: 2b18         	cmp	r3, #0x18
 8012b5a: d90b         	bls	0x8012b74 <uart_callback+0x88> @ imm = #0x16
 8012b5c: 8c7b         	ldrh	r3, [r7, #0x22]
 8012b5e: 6a7a         	ldr	r2, [r7, #0x24]
 8012b60: 4413         	add	r3, r2
 8012b62: 69fa         	ldr	r2, [r7, #0x1c]
 8012b64: 429a         	cmp	r2, r3
 8012b66: d205         	bhs	0x8012b74 <uart_callback+0x88> @ imm = #0xa
;             memcpy(data->data, ptr_offset, 25);
 8012b68: 6c3b         	ldr	r3, [r7, #0x40]
 8012b6a: 2219         	movs	r2, #0x19
 8012b6c: 69f9         	ldr	r1, [r7, #0x1c]
 8012b6e: 4618         	mov	r0, r3
 8012b70: f016 fac0    	bl	0x80290f4 <memcpy>      @ imm = #0x16580
;         void *new_buf = NULL;
 8012b74: 2300         	movs	r3, #0x0
 8012b76: 61bb         	str	r3, [r7, #0x18]
;         err           = k_mem_slab_alloc(&uart_slab, &new_buf, K_NO_WAIT);
 8012b78: f04f 0200    	mov.w	r2, #0x0
 8012b7c: f04f 0300    	mov.w	r3, #0x0
 8012b80: f107 0118    	add.w	r1, r7, #0x18
 8012b84: 485a         	ldr	r0, [pc, #0x168]        @ 0x8012cf0 <uart_callback+0x204>
 8012b86: f002 f803    	bl	0x8014b90 <k_mem_slab_alloc> @ imm = #0x2006
 8012b8a: 63f8         	str	r0, [r7, #0x3c]
;         if (err == 0 && new_buf != NULL && ((uintptr_t)new_buf & 0x3) == 0) {
 8012b8c: 6bfb         	ldr	r3, [r7, #0x3c]
 8012b8e: 2b00         	cmp	r3, #0x0
 8012b90: d10e         	bne	0x8012bb0 <uart_callback+0xc4> @ imm = #0x1c
 8012b92: 69bb         	ldr	r3, [r7, #0x18]
 8012b94: 2b00         	cmp	r3, #0x0
 8012b96: d00b         	beq	0x8012bb0 <uart_callback+0xc4> @ imm = #0x16
 8012b98: 69bb         	ldr	r3, [r7, #0x18]
 8012b9a: f003 0303    	and	r3, r3, #0x3
 8012b9e: 2b00         	cmp	r3, #0x0
 8012ba0: d106         	bne	0x8012bb0 <uart_callback+0xc4> @ imm = #0xc
;             err = uart_rx_buf_rsp(dev, new_buf, BUF_SIZE);
 8012ba2: 69bb         	ldr	r3, [r7, #0x18]
 8012ba4: 2240         	movs	r2, #0x40
 8012ba6: 4619         	mov	r1, r3
 8012ba8: 68f8         	ldr	r0, [r7, #0xc]
 8012baa: f013 f90a    	bl	0x8025dc2 <uart_rx_buf_rsp> @ imm = #0x13214
 8012bae: 63f8         	str	r0, [r7, #0x3c]
;         break;
 8012bb0: bf00         	nop
; }
 8012bb2: e098         	b	0x8012ce6 <uart_callback+0x1fa> @ imm = #0x130
;         uint8_t *buf = NULL; // 使用 void* 类型
 8012bb4: 2300         	movs	r3, #0x0
 8012bb6: 617b         	str	r3, [r7, #0x14]
;         err = k_mem_slab_alloc(&uart_slab, (void **)&buf, K_NO_WAIT);
 8012bb8: f04f 0200    	mov.w	r2, #0x0
 8012bbc: f04f 0300    	mov.w	r3, #0x0
 8012bc0: f107 0114    	add.w	r1, r7, #0x14
 8012bc4: 484a         	ldr	r0, [pc, #0x128]        @ 0x8012cf0 <uart_callback+0x204>
 8012bc6: f001 ffe3    	bl	0x8014b90 <k_mem_slab_alloc> @ imm = #0x1fc6
 8012bca: 63f8         	str	r0, [r7, #0x3c]
;         if (err == 0 && ((uintptr_t)buf & 0x3) == 0 && buf != NULL) {
 8012bcc: 6bfb         	ldr	r3, [r7, #0x3c]
 8012bce: 2b00         	cmp	r3, #0x0
 8012bd0: d10d         	bne	0x8012bee <uart_callback+0x102> @ imm = #0x1a
 8012bd2: 697b         	ldr	r3, [r7, #0x14]
 8012bd4: f003 0303    	and	r3, r3, #0x3
 8012bd8: 2b00         	cmp	r3, #0x0
 8012bda: d108         	bne	0x8012bee <uart_callback+0x102> @ imm = #0x10
 8012bdc: 697b         	ldr	r3, [r7, #0x14]
 8012bde: 2b00         	cmp	r3, #0x0
 8012be0: d005         	beq	0x8012bee <uart_callback+0x102> @ imm = #0xa
;             uart_rx_buf_rsp(dev, buf, BUF_SIZE);
 8012be2: 697b         	ldr	r3, [r7, #0x14]
 8012be4: 2240         	movs	r2, #0x40
 8012be6: 4619         	mov	r1, r3
 8012be8: 68f8         	ldr	r0, [r7, #0xc]
 8012bea: f013 f8ea    	bl	0x8025dc2 <uart_rx_buf_rsp> @ imm = #0x131d4
;         break;
 8012bee: bf00         	nop
; }
 8012bf0: e079         	b	0x8012ce6 <uart_callback+0x1fa> @ imm = #0xf2
;         void *buf = evt->data.rx_buf.buf;
 8012bf2: 68bb         	ldr	r3, [r7, #0x8]
 8012bf4: 685b         	ldr	r3, [r3, #0x4]
 8012bf6: 62bb         	str	r3, [r7, #0x28]
;         if (buf != NULL) {
 8012bf8: 6abb         	ldr	r3, [r7, #0x28]
 8012bfa: 2b00         	cmp	r3, #0x0
 8012bfc: d072         	beq	0x8012ce4 <uart_callback+0x1f8> @ imm = #0xe4
;             k_mem_slab_free(&uart_slab, buf);
 8012bfe: 6ab9         	ldr	r1, [r7, #0x28]
 8012c00: 483b         	ldr	r0, [pc, #0xec]         @ 0x8012cf0 <uart_callback+0x204>
 8012c02: f013 ff0f    	bl	0x8026a24 <k_mem_slab_free> @ imm = #0x13e1e
;         break;
 8012c06: e06d         	b	0x8012ce4 <uart_callback+0x1f8> @ imm = #0xda
;         uint8_t *buf = NULL;
 8012c08: 2300         	movs	r3, #0x0
 8012c0a: 613b         	str	r3, [r7, #0x10]
;         err          = k_mem_slab_alloc(&uart_slab, (void **)&buf, K_NO_WAIT);
 8012c0c: f04f 0200    	mov.w	r2, #0x0
 8012c10: f04f 0300    	mov.w	r3, #0x0
 8012c14: f107 0110    	add.w	r1, r7, #0x10
 8012c18: 4835         	ldr	r0, [pc, #0xd4]         @ 0x8012cf0 <uart_callback+0x204>
 8012c1a: f001 ffb9    	bl	0x8014b90 <k_mem_slab_alloc> @ imm = #0x1f72
 8012c1e: 63f8         	str	r0, [r7, #0x3c]
;         if (err == 0 && buf != NULL && ((uintptr_t)buf & 0x3) == 0) {
 8012c20: 6bfb         	ldr	r3, [r7, #0x3c]
 8012c22: 2b00         	cmp	r3, #0x0
 8012c24: d13c         	bne	0x8012ca0 <uart_callback+0x1b4> @ imm = #0x78
 8012c26: 693b         	ldr	r3, [r7, #0x10]
 8012c28: 2b00         	cmp	r3, #0x0
 8012c2a: d039         	beq	0x8012ca0 <uart_callback+0x1b4> @ imm = #0x72
 8012c2c: 693b         	ldr	r3, [r7, #0x10]
 8012c2e: f003 0303    	and	r3, r3, #0x3
 8012c32: 2b00         	cmp	r3, #0x0
 8012c34: d134         	bne	0x8012ca0 <uart_callback+0x1b4> @ imm = #0x68
;             memset(buf, 0, BUF_SIZE);
 8012c36: 693b         	ldr	r3, [r7, #0x10]
 8012c38: 2240         	movs	r2, #0x40
 8012c3a: 2100         	movs	r1, #0x0
 8012c3c: 4618         	mov	r0, r3
 8012c3e: f016 fa67    	bl	0x8029110 <memset>      @ imm = #0x164ce
;             err = uart_rx_enable(dev, buf, BUF_SIZE, 100);
 8012c42: 6939         	ldr	r1, [r7, #0x10]
 8012c44: 2364         	movs	r3, #0x64
 8012c46: 2240         	movs	r2, #0x40
 8012c48: 68f8         	ldr	r0, [r7, #0xc]
 8012c4a: f013 f8ec    	bl	0x8025e26 <uart_rx_enable> @ imm = #0x131d8
 8012c4e: 63f8         	str	r0, [r7, #0x3c]
;             if (err) {
 8012c50: 6bfb         	ldr	r3, [r7, #0x3c]
 8012c52: 2b00         	cmp	r3, #0x0
 8012c54: d042         	beq	0x8012cdc <uart_callback+0x1f0> @ imm = #0x84
;                 LOG_ERR("Failed to enable RX: %d", err);
 8012c56: 233c         	movs	r3, #0x3c
 8012c58: 2b00         	cmp	r3, #0x0
 8012c5a: d01a         	beq	0x8012c92 <uart_callback+0x1a6> @ imm = #0x34
 8012c5c: 2301         	movs	r3, #0x1
 8012c5e: f887 303b    	strb.w	r3, [r7, #0x3b]
 8012c62: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8012c66: f083 0301    	eor	r3, r3, #0x1
 8012c6a: b2db         	uxtb	r3, r3
 8012c6c: 2b00         	cmp	r3, #0x0
 8012c6e: d110         	bne	0x8012c92 <uart_callback+0x1a6> @ imm = #0x20
 8012c70: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8012cf4 <uart_callback+0x208>
 8012c72: 6819         	ldr	r1, [r3]
 8012c74: 6bfb         	ldr	r3, [r7, #0x3c]
 8012c76: 9303         	str	r3, [sp, #0xc]
 8012c78: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8012cf8 <uart_callback+0x20c>
 8012c7a: 9302         	str	r3, [sp, #0x8]
 8012c7c: 2300         	movs	r3, #0x0
 8012c7e: 9301         	str	r3, [sp, #0x4]
 8012c80: 2300         	movs	r3, #0x0
 8012c82: 9300         	str	r3, [sp]
 8012c84: 2300         	movs	r3, #0x0
 8012c86: 2201         	movs	r2, #0x1
 8012c88: 2000         	movs	r0, #0x0
 8012c8a: f013 f8ea    	bl	0x8025e62 <z_log_msg_runtime_create> @ imm = #0x131d4
 8012c8e: 2300         	movs	r3, #0x0
 8012c90: 637b         	str	r3, [r7, #0x34]
;                 k_mem_slab_free(&uart_slab, (void **)&buf);
 8012c92: f107 0310    	add.w	r3, r7, #0x10
 8012c96: 4619         	mov	r1, r3
 8012c98: 4815         	ldr	r0, [pc, #0x54]         @ 0x8012cf0 <uart_callback+0x204>
 8012c9a: f013 fec3    	bl	0x8026a24 <k_mem_slab_free> @ imm = #0x13d86
;             if (err) {
 8012c9e: e01d         	b	0x8012cdc <uart_callback+0x1f0> @ imm = #0x3a
;             LOG_ERR("Failed to allocate memory: %d", err);
 8012ca0: 233c         	movs	r3, #0x3c
 8012ca2: 2b00         	cmp	r3, #0x0
 8012ca4: d01a         	beq	0x8012cdc <uart_callback+0x1f0> @ imm = #0x34
 8012ca6: 2301         	movs	r3, #0x1
 8012ca8: f887 3033    	strb.w	r3, [r7, #0x33]
 8012cac: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8012cb0: f083 0301    	eor	r3, r3, #0x1
 8012cb4: b2db         	uxtb	r3, r3
 8012cb6: 2b00         	cmp	r3, #0x0
 8012cb8: d110         	bne	0x8012cdc <uart_callback+0x1f0> @ imm = #0x20
 8012cba: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8012cf4 <uart_callback+0x208>
 8012cbc: 6819         	ldr	r1, [r3]
 8012cbe: 6bfb         	ldr	r3, [r7, #0x3c]
 8012cc0: 9303         	str	r3, [sp, #0xc]
 8012cc2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8012cfc <uart_callback+0x210>
 8012cc4: 9302         	str	r3, [sp, #0x8]
 8012cc6: 2300         	movs	r3, #0x0
 8012cc8: 9301         	str	r3, [sp, #0x4]
 8012cca: 2300         	movs	r3, #0x0
 8012ccc: 9300         	str	r3, [sp]
 8012cce: 2300         	movs	r3, #0x0
 8012cd0: 2201         	movs	r2, #0x1
 8012cd2: 2000         	movs	r0, #0x0
 8012cd4: f013 f8c5    	bl	0x8025e62 <z_log_msg_runtime_create> @ imm = #0x1318a
 8012cd8: 2300         	movs	r3, #0x0
 8012cda: 62fb         	str	r3, [r7, #0x2c]
;         break;
 8012cdc: bf00         	nop
; }
 8012cde: e002         	b	0x8012ce6 <uart_callback+0x1fa> @ imm = #0x4
;     default: break;
 8012ce0: bf00         	nop
 8012ce2: e000         	b	0x8012ce6 <uart_callback+0x1fa> @ imm = #0x0
;         break;
 8012ce4: bf00         	nop
; }
 8012ce6: bf00         	nop
 8012ce8: 3748         	adds	r7, #0x48
 8012cea: 46bd         	mov	sp, r7
 8012cec: bd80         	pop	{r7, pc}
 8012cee: bf00         	nop

08012cf0 <$d>:
 8012cf0: 20 0c 00 24  	.word	0x24000c20
 8012cf4: 8c 32 00 24  	.word	0x2400328c
 8012cf8: 64 c6 02 08  	.word	0x0802c664
 8012cfc: 7c c6 02 08  	.word	0x0802c67c

08012d00 <sbus_init>:
; static int sbus_init(const struct device *dev) {
 8012d00: b590         	push	{r4, r7, lr}
 8012d02: b095         	sub	sp, #0x54
 8012d04: af04         	add	r7, sp, #0x10
 8012d06: 6078         	str	r0, [r7, #0x4]
;     if (!device_is_ready(uart_dev)) {
 8012d08: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x8012f04 <sbus_init+0x204>
 8012d0a: 681b         	ldr	r3, [r3]
 8012d0c: 4618         	mov	r0, r3
 8012d0e: f013 f802    	bl	0x8025d16 <device_is_ready> @ imm = #0x13004
 8012d12: 4603         	mov	r3, r0
 8012d14: f083 0301    	eor	r3, r3, #0x1
 8012d18: b2db         	uxtb	r3, r3
 8012d1a: 2b00         	cmp	r3, #0x0
 8012d1c: d01c         	beq	0x8012d58 <sbus_init+0x58> @ imm = #0x38
;         LOG_ERR("UART device not ready");
 8012d1e: 233c         	movs	r3, #0x3c
 8012d20: 2b00         	cmp	r3, #0x0
 8012d22: d016         	beq	0x8012d52 <sbus_init+0x52> @ imm = #0x2c
 8012d24: 2301         	movs	r3, #0x1
 8012d26: 76fb         	strb	r3, [r7, #0x1b]
 8012d28: 7efb         	ldrb	r3, [r7, #0x1b]
 8012d2a: f083 0301    	eor	r3, r3, #0x1
 8012d2e: b2db         	uxtb	r3, r3
 8012d30: 2b00         	cmp	r3, #0x0
 8012d32: d10e         	bne	0x8012d52 <sbus_init+0x52> @ imm = #0x1c
 8012d34: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8012f08 <sbus_init+0x208>
 8012d36: 6819         	ldr	r1, [r3]
 8012d38: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8012f0c <sbus_init+0x20c>
 8012d3a: 9302         	str	r3, [sp, #0x8]
 8012d3c: 2300         	movs	r3, #0x0
 8012d3e: 9301         	str	r3, [sp, #0x4]
 8012d40: 2300         	movs	r3, #0x0
 8012d42: 9300         	str	r3, [sp]
 8012d44: 2300         	movs	r3, #0x0
 8012d46: 2201         	movs	r2, #0x1
 8012d48: 2000         	movs	r0, #0x0
 8012d4a: f013 f88a    	bl	0x8025e62 <z_log_msg_runtime_create> @ imm = #0x13114
 8012d4e: 2300         	movs	r3, #0x0
 8012d50: 617b         	str	r3, [r7, #0x14]
;         return -ENODEV;
 8012d52: f06f 0312    	mvn	r3, #0x12
 8012d56: e0d0         	b	0x8012efa <sbus_init+0x1fa> @ imm = #0x1a0
;     err = uart_callback_set(uart_dev, uart_callback, (void *)dev);
 8012d58: 4b6a         	ldr	r3, [pc, #0x1a8]        @ 0x8012f04 <sbus_init+0x204>
 8012d5a: 681b         	ldr	r3, [r3]
 8012d5c: 687a         	ldr	r2, [r7, #0x4]
 8012d5e: 496c         	ldr	r1, [pc, #0x1b0]        @ 0x8012f10 <sbus_init+0x210>
 8012d60: 4618         	mov	r0, r3
 8012d62: f012 fffd    	bl	0x8025d60 <uart_callback_set> @ imm = #0x12ffa
 8012d66: 63f8         	str	r0, [r7, #0x3c]
;     if (err) {
 8012d68: 6bfb         	ldr	r3, [r7, #0x3c]
 8012d6a: 2b00         	cmp	r3, #0x0
 8012d6c: d01f         	beq	0x8012dae <sbus_init+0xae> @ imm = #0x3e
;         LOG_ERR("Failed to set callback: %d", err);
 8012d6e: 233c         	movs	r3, #0x3c
 8012d70: 2b00         	cmp	r3, #0x0
 8012d72: d01a         	beq	0x8012daa <sbus_init+0xaa> @ imm = #0x34
 8012d74: 2301         	movs	r3, #0x1
 8012d76: f887 3023    	strb.w	r3, [r7, #0x23]
 8012d7a: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8012d7e: f083 0301    	eor	r3, r3, #0x1
 8012d82: b2db         	uxtb	r3, r3
 8012d84: 2b00         	cmp	r3, #0x0
 8012d86: d110         	bne	0x8012daa <sbus_init+0xaa> @ imm = #0x20
 8012d88: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x8012f08 <sbus_init+0x208>
 8012d8a: 6819         	ldr	r1, [r3]
 8012d8c: 6bfb         	ldr	r3, [r7, #0x3c]
 8012d8e: 9303         	str	r3, [sp, #0xc]
 8012d90: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8012f14 <sbus_init+0x214>
 8012d92: 9302         	str	r3, [sp, #0x8]
 8012d94: 2300         	movs	r3, #0x0
 8012d96: 9301         	str	r3, [sp, #0x4]
 8012d98: 2300         	movs	r3, #0x0
 8012d9a: 9300         	str	r3, [sp]
 8012d9c: 2300         	movs	r3, #0x0
 8012d9e: 2201         	movs	r2, #0x1
 8012da0: 2000         	movs	r0, #0x0
 8012da2: f013 f85e    	bl	0x8025e62 <z_log_msg_runtime_create> @ imm = #0x130bc
 8012da6: 2300         	movs	r3, #0x0
 8012da8: 61fb         	str	r3, [r7, #0x1c]
;         return err;
 8012daa: 6bfb         	ldr	r3, [r7, #0x3c]
 8012dac: e0a5         	b	0x8012efa <sbus_init+0x1fa> @ imm = #0x14a
;     err = k_mem_slab_alloc(&uart_slab, (void **)&buf, K_NO_WAIT);
 8012dae: f04f 0000    	mov.w	r0, #0x0
 8012db2: f04f 0100    	mov.w	r1, #0x0
 8012db6: f107 0410    	add.w	r4, r7, #0x10
 8012dba: 4602         	mov	r2, r0
 8012dbc: 460b         	mov	r3, r1
 8012dbe: 4621         	mov	r1, r4
 8012dc0: 4855         	ldr	r0, [pc, #0x154]        @ 0x8012f18 <sbus_init+0x218>
 8012dc2: f001 fee5    	bl	0x8014b90 <k_mem_slab_alloc> @ imm = #0x1dca
 8012dc6: 63f8         	str	r0, [r7, #0x3c]
;     memset(buf, 0, BUF_SIZE);
 8012dc8: 693b         	ldr	r3, [r7, #0x10]
 8012dca: 2240         	movs	r2, #0x40
 8012dcc: 2100         	movs	r1, #0x0
 8012dce: 4618         	mov	r0, r3
 8012dd0: f016 f99e    	bl	0x8029110 <memset>      @ imm = #0x1633c
;     if (err) {
 8012dd4: 6bfb         	ldr	r3, [r7, #0x3c]
 8012dd6: 2b00         	cmp	r3, #0x0
 8012dd8: d01f         	beq	0x8012e1a <sbus_init+0x11a> @ imm = #0x3e
;         LOG_ERR("Failed to allocate memory: %d", err);
 8012dda: 233c         	movs	r3, #0x3c
 8012ddc: 2b00         	cmp	r3, #0x0
 8012dde: d01a         	beq	0x8012e16 <sbus_init+0x116> @ imm = #0x34
 8012de0: 2301         	movs	r3, #0x1
 8012de2: f887 302b    	strb.w	r3, [r7, #0x2b]
 8012de6: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8012dea: f083 0301    	eor	r3, r3, #0x1
 8012dee: b2db         	uxtb	r3, r3
 8012df0: 2b00         	cmp	r3, #0x0
 8012df2: d110         	bne	0x8012e16 <sbus_init+0x116> @ imm = #0x20
 8012df4: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8012f08 <sbus_init+0x208>
 8012df6: 6819         	ldr	r1, [r3]
 8012df8: 6bfb         	ldr	r3, [r7, #0x3c]
 8012dfa: 9303         	str	r3, [sp, #0xc]
 8012dfc: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x8012f1c <sbus_init+0x21c>
 8012dfe: 9302         	str	r3, [sp, #0x8]
 8012e00: 2300         	movs	r3, #0x0
 8012e02: 9301         	str	r3, [sp, #0x4]
 8012e04: 2300         	movs	r3, #0x0
 8012e06: 9300         	str	r3, [sp]
 8012e08: 2300         	movs	r3, #0x0
 8012e0a: 2201         	movs	r2, #0x1
 8012e0c: 2000         	movs	r0, #0x0
 8012e0e: f013 f828    	bl	0x8025e62 <z_log_msg_runtime_create> @ imm = #0x13050
 8012e12: 2300         	movs	r3, #0x0
 8012e14: 627b         	str	r3, [r7, #0x24]
;         return err;
 8012e16: 6bfb         	ldr	r3, [r7, #0x3c]
 8012e18: e06f         	b	0x8012efa <sbus_init+0x1fa> @ imm = #0xde
;     const struct uart_config config = {.baudrate  = 100000,
 8012e1a: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8012f20 <sbus_init+0x220>
 8012e1c: f107 0308    	add.w	r3, r7, #0x8
 8012e20: e892 0003    	ldm.w	r2, {r0, r1}
 8012e24: e883 0003    	stm.w	r3, {r0, r1}
;     err = uart_configure(uart_dev, &config);
 8012e28: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8012f04 <sbus_init+0x204>
 8012e2a: 681b         	ldr	r3, [r3]
 8012e2c: f107 0208    	add.w	r2, r7, #0x8
 8012e30: 4611         	mov	r1, r2
 8012e32: 4618         	mov	r0, r3
 8012e34: f012 ffe9    	bl	0x8025e0a <uart_configure> @ imm = #0x12fd2
 8012e38: 63f8         	str	r0, [r7, #0x3c]
;     if (err) {
 8012e3a: 6bfb         	ldr	r3, [r7, #0x3c]
 8012e3c: 2b00         	cmp	r3, #0x0
 8012e3e: d025         	beq	0x8012e8c <sbus_init+0x18c> @ imm = #0x4a
;         LOG_ERR("Failed to configure UART: %d", err);
 8012e40: 233c         	movs	r3, #0x3c
 8012e42: 2b00         	cmp	r3, #0x0
 8012e44: d01a         	beq	0x8012e7c <sbus_init+0x17c> @ imm = #0x34
 8012e46: 2301         	movs	r3, #0x1
 8012e48: f887 3033    	strb.w	r3, [r7, #0x33]
 8012e4c: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8012e50: f083 0301    	eor	r3, r3, #0x1
 8012e54: b2db         	uxtb	r3, r3
 8012e56: 2b00         	cmp	r3, #0x0
 8012e58: d110         	bne	0x8012e7c <sbus_init+0x17c> @ imm = #0x20
 8012e5a: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8012f08 <sbus_init+0x208>
 8012e5c: 6819         	ldr	r1, [r3]
 8012e5e: 6bfb         	ldr	r3, [r7, #0x3c]
 8012e60: 9303         	str	r3, [sp, #0xc]
 8012e62: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8012f24 <sbus_init+0x224>
 8012e64: 9302         	str	r3, [sp, #0x8]
 8012e66: 2300         	movs	r3, #0x0
 8012e68: 9301         	str	r3, [sp, #0x4]
 8012e6a: 2300         	movs	r3, #0x0
 8012e6c: 9300         	str	r3, [sp]
 8012e6e: 2300         	movs	r3, #0x0
 8012e70: 2201         	movs	r2, #0x1
 8012e72: 2000         	movs	r0, #0x0
 8012e74: f012 fff5    	bl	0x8025e62 <z_log_msg_runtime_create> @ imm = #0x12fea
 8012e78: 2300         	movs	r3, #0x0
 8012e7a: 62fb         	str	r3, [r7, #0x2c]
;         k_mem_slab_free(&uart_slab, (void **)&buf);
 8012e7c: f107 0310    	add.w	r3, r7, #0x10
 8012e80: 4619         	mov	r1, r3
 8012e82: 4825         	ldr	r0, [pc, #0x94]         @ 0x8012f18 <sbus_init+0x218>
 8012e84: f013 fdce    	bl	0x8026a24 <k_mem_slab_free> @ imm = #0x13b9c
;         return err;
 8012e88: 6bfb         	ldr	r3, [r7, #0x3c]
 8012e8a: e036         	b	0x8012efa <sbus_init+0x1fa> @ imm = #0x6c
;     uart_rx_disable(uart_dev);
 8012e8c: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8012f04 <sbus_init+0x204>
 8012e8e: 681b         	ldr	r3, [r3]
 8012e90: 4618         	mov	r0, r3
 8012e92: f012 ffda    	bl	0x8025e4a <uart_rx_disable> @ imm = #0x12fb4
;     err = uart_rx_enable(uart_dev, buf, BUF_SIZE, 100);
 8012e96: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8012f04 <sbus_init+0x204>
 8012e98: 6818         	ldr	r0, [r3]
 8012e9a: 6939         	ldr	r1, [r7, #0x10]
 8012e9c: 2364         	movs	r3, #0x64
 8012e9e: 2240         	movs	r2, #0x40
 8012ea0: f012 ffc1    	bl	0x8025e26 <uart_rx_enable> @ imm = #0x12f82
 8012ea4: 63f8         	str	r0, [r7, #0x3c]
;     if (err) {
 8012ea6: 6bfb         	ldr	r3, [r7, #0x3c]
 8012ea8: 2b00         	cmp	r3, #0x0
 8012eaa: d025         	beq	0x8012ef8 <sbus_init+0x1f8> @ imm = #0x4a
;         LOG_ERR("Failed to enable RX: %d", err);
 8012eac: 233c         	movs	r3, #0x3c
 8012eae: 2b00         	cmp	r3, #0x0
 8012eb0: d01a         	beq	0x8012ee8 <sbus_init+0x1e8> @ imm = #0x34
 8012eb2: 2301         	movs	r3, #0x1
 8012eb4: f887 303b    	strb.w	r3, [r7, #0x3b]
 8012eb8: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8012ebc: f083 0301    	eor	r3, r3, #0x1
 8012ec0: b2db         	uxtb	r3, r3
 8012ec2: 2b00         	cmp	r3, #0x0
 8012ec4: d110         	bne	0x8012ee8 <sbus_init+0x1e8> @ imm = #0x20
 8012ec6: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8012f08 <sbus_init+0x208>
 8012ec8: 6819         	ldr	r1, [r3]
 8012eca: 6bfb         	ldr	r3, [r7, #0x3c]
 8012ecc: 9303         	str	r3, [sp, #0xc]
 8012ece: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8012f28 <sbus_init+0x228>
 8012ed0: 9302         	str	r3, [sp, #0x8]
 8012ed2: 2300         	movs	r3, #0x0
 8012ed4: 9301         	str	r3, [sp, #0x4]
 8012ed6: 2300         	movs	r3, #0x0
 8012ed8: 9300         	str	r3, [sp]
 8012eda: 2300         	movs	r3, #0x0
 8012edc: 2201         	movs	r2, #0x1
 8012ede: 2000         	movs	r0, #0x0
 8012ee0: f012 ffbf    	bl	0x8025e62 <z_log_msg_runtime_create> @ imm = #0x12f7e
 8012ee4: 2300         	movs	r3, #0x0
 8012ee6: 637b         	str	r3, [r7, #0x34]
;         k_mem_slab_free(&uart_slab, (void **)&buf);
 8012ee8: f107 0310    	add.w	r3, r7, #0x10
 8012eec: 4619         	mov	r1, r3
 8012eee: 480a         	ldr	r0, [pc, #0x28]         @ 0x8012f18 <sbus_init+0x218>
 8012ef0: f013 fd98    	bl	0x8026a24 <k_mem_slab_free> @ imm = #0x13b30
;         return err;
 8012ef4: 6bfb         	ldr	r3, [r7, #0x3c]
 8012ef6: e000         	b	0x8012efa <sbus_init+0x1fa> @ imm = #0x0
;     return 0;
 8012ef8: 2300         	movs	r3, #0x0
; }
 8012efa: 4618         	mov	r0, r3
 8012efc: 3744         	adds	r7, #0x44
 8012efe: 46bd         	mov	sp, r7
 8012f00: bd90         	pop	{r4, r7, pc}
 8012f02: bf00         	nop

08012f04 <$d>:
 8012f04: 40 0b 00 24  	.word	0x24000b40
 8012f08: 8c 32 00 24  	.word	0x2400328c
 8012f0c: 9c c6 02 08  	.word	0x0802c69c
 8012f10: ed 2a 01 08  	.word	0x08012aed
 8012f14: b4 c6 02 08  	.word	0x0802c6b4
 8012f18: 20 0c 00 24  	.word	0x24000c20
 8012f1c: 7c c6 02 08  	.word	0x0802c67c
 8012f20: f0 c6 02 08  	.word	0x0802c6f0
 8012f24: d0 c6 02 08  	.word	0x0802c6d0
 8012f28: 64 c6 02 08  	.word	0x0802c664

08012f2c <sbus_getchannel_percentage>:
; float sbus_getchannel_percentage(const struct device *dev, uint8_t channelid) {
 8012f2c: b580         	push	{r7, lr}
 8012f2e: b086         	sub	sp, #0x18
 8012f30: af00         	add	r7, sp, #0x0
 8012f32: 6078         	str	r0, [r7, #0x4]
 8012f34: 460b         	mov	r3, r1
 8012f36: 70fb         	strb	r3, [r7, #0x3]
;     struct sbus_driver_data *data = dev->data;
 8012f38: 687b         	ldr	r3, [r7, #0x4]
 8012f3a: 691b         	ldr	r3, [r3, #0x10]
 8012f3c: 617b         	str	r3, [r7, #0x14]
;     sbus_parseframe(dev);
 8012f3e: 6878         	ldr	r0, [r7, #0x4]
 8012f40: f012 ffad    	bl	0x8025e9e <sbus_parseframe> @ imm = #0x12f5a
;     float scale = 2.0f / (SBUS_MAX - SBUS_MIN);
 8012f44: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8012f80 <sbus_getchannel_percentage+0x54>
 8012f46: 613b         	str	r3, [r7, #0x10]
;     float out   = (int16_t)(data->channels[channelid] - 1024) * scale;
 8012f48: 78fb         	ldrb	r3, [r7, #0x3]
 8012f4a: 697a         	ldr	r2, [r7, #0x14]
 8012f4c: 330c         	adds	r3, #0xc
 8012f4e: 005b         	lsls	r3, r3, #0x1
 8012f50: 4413         	add	r3, r2
 8012f52: 885b         	ldrh	r3, [r3, #0x2]
 8012f54: f5a3 6380    	sub.w	r3, r3, #0x400
 8012f58: b29b         	uxth	r3, r3
 8012f5a: b21b         	sxth	r3, r3
 8012f5c: ee07 3a90    	<unknown>
 8012f60: eef8 7ae7    	<unknown>
 8012f64: ed97 7a04    	<unknown>
 8012f68: ee67 7a27    	<unknown>
 8012f6c: edc7 7a03    	<unknown>
;     return out;
 8012f70: 68fb         	ldr	r3, [r7, #0xc]
 8012f72: ee07 3a90    	<unknown>
; }
 8012f76: eeb0 0a67    	<unknown>
 8012f7a: 3718         	adds	r7, #0x18
 8012f7c: 46bd         	mov	sp, r7
 8012f7e: bd80         	pop	{r7, pc}

08012f80 <$d>:
 8012f80: 9b 56 c3 3a  	.word	0x3ac3569b

08012f84 <arm_sin_cos_f32>:
;   in = theta * 0.00277777777778f;
 8012f84: eddf 7a3a    	<unknown>
 8012f88: eeb0 3a00    	<unknown>
;   findex = (float32_t)FAST_MATH_TABLE_SIZE * in;
 8012f8c: ed9f 7a39    	<unknown>
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8012f90: eef0 0a08    	<unknown>
;   in = theta * 0.00277777777778f;
 8012f94: ee60 7a27    	<unknown>
;   f1 =  sinTable_f32[indexC  ];
 8012f98: 4a37         	ldr	r2, [pc, #0xdc]         @ 0x8013078 <arm_sin_cos_f32+0xf4>
;   temp = Dn * (d1 + d2) - 2 * Df;
 8012f9a: ed9f 5a38    	<unknown>
;   if (theta < 0.0f)
 8012f9e: eeb5 0ac0    	<unknown>
;   if (in < 0.0f)
 8012fa2: eef0 7ae7    	<unknown>
;   if (theta < 0.0f)
 8012fa6: eef1 fa10    	<unknown>
;   in = in - (int32_t)in;
 8012faa: eef6 6ae7    	<unknown>
 8012fae: ee77 7ae6    	<unknown>
; {
 8012fb2: b500         	push	{lr}
;   findex = (float32_t)FAST_MATH_TABLE_SIZE * in;
 8012fb4: ee67 7a87    	<unknown>
;   indexS = ((uint16_t)findex) & 0x1ff;
 8012fb8: eebc 7ae7    	<unknown>
 8012fbc: ee17 3a10    	<unknown>
 8012fc0: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
;   fract = findex - (float32_t) indexS;
 8012fc4: ee07 3a10    	<unknown>
;   d1 = -sinTable_f32[indexS  ];
 8012fc8: eb02 0e83    	add.w	lr, r2, r3, lsl #2
;   indexC = (indexS + (FAST_MATH_TABLE_SIZE / 4)) & 0x1ff;
 8012fcc: f103 0c80    	add.w	r12, r3, #0x80
;   fract = findex - (float32_t) indexS;
 8012fd0: eeb8 7a47    	<unknown>
;   d2 = -sinTable_f32[indexS+1];
 8012fd4: edde 6a01    	<unknown>
;   d1 = -sinTable_f32[indexS  ];
 8012fd8: edde 4a00    	<unknown>
;   f1 =  sinTable_f32[indexC  ];
 8012fdc: f3cc 0c08    	ubfx	r12, r12, #0x0, #0x9
 8012fe0: eef0 5a66    	<unknown>
;   fract = findex - (float32_t) indexS;
 8012fe4: ee77 7ac7    	<unknown>
;   f1 =  sinTable_f32[indexC  ];
 8012fe8: eb02 038c    	add.w	r3, r2, r12, lsl #2
;   d1 = -sinTable_f32[indexS  ];
 8012fec: eeb1 7a64    	<unknown>
;   Df = f2 - f1; // delta between the values of the functions
 8012ff0: ee76 1ae4    	<unknown>
;   f2 =  sinTable_f32[indexC+1];
 8012ff4: edd3 3a01    	<unknown>
 8012ff8: eed7 5a03    	<unknown>
;   temp = Dn * (d1 + d2) - 2 * Df;
 8012ffc: ee37 4a66    	<unknown>
;   temp = fract * temp + d1 * Dn;
 8013000: ee67 6a05    	<unknown>
;   f1 =  sinTable_f32[indexC  ];
 8013004: ed93 7a00    	<unknown>
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8013008: eeb0 6a63    	<unknown>
;   Df = f2 - f1;          /* delta between the values of the functions */
 801300c: ee33 1ac7    	<unknown>
;   temp = Dn * (d1 + d2) - 2 * Df;
 8013010: ee71 2aa1    	<unknown>
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8013014: eea7 6a03    	<unknown>
;   temp = Dn * (d1 + d2) - 2 * Df;
 8013018: ee77 3a23    	<unknown>
;   temp = Dn * (d1 + d2) - 2 * Df;
 801301c: ee31 2a01    	<unknown>
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8013020: ee65 5a65    	<unknown>
;   temp = Dn * (d1 + d2) - 2 * Df;
 8013024: eed3 2a85    	<unknown>
;   temp = Dn * (d1 + d2) - 2 * Df;
 8013028: eef0 3a42    	<unknown>
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 801302c: eee1 5a20    	<unknown>
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8013030: ee25 6a46    	<unknown>
;   temp = Dn * (d1 + d2) - 2 * Df;
 8013034: eed4 3a05    	<unknown>
;   temp = fract * temp + d1 * Dn;
 8013038: ee27 3a05    	<unknown>
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 801303c: eea1 6aa0    	<unknown>
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8013040: eee7 5aa3    	<unknown>
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8013044: eea7 6aa2    	<unknown>
;   temp = fract * temp + d1 * Dn;
 8013048: eee7 6aa5    	<unknown>
;   temp = fract * temp + d1 * Dn;
 801304c: eef0 5a43    	<unknown>
 8013050: eee7 5a86    	<unknown>
;   *pCosVal = fract * temp + f1;
 8013054: eea7 7aa6    	<unknown>
;   *pSinVal = fract * temp + f1;
 8013058: eee7 4aa5    	<unknown>
;   *pCosVal = fract * temp + f1;
 801305c: ed81 7a00    	<unknown>
;     *pSinVal = -*pSinVal;
 8013060: bf48         	it	mi
 8013062: eef1 4a64    	<unknown>
;   *pSinVal = fract * temp + f1;
 8013066: edc0 4a00    	<unknown>
; }
 801306a: f85d fb04    	ldrmi	pc, [sp], #4
 801306e: bf00         	nop

08013070 <$d>:
 8013070: 61 0b 36 3b  	.word	0x3b360b61
 8013074: 00 00 00 44  	.word	0x44000000
 8013078: d8 dd 02 08  	.word	0x0802ddd8
 801307c: db 0f 49 3c  	.word	0x3c490fdb

08013080 <arm_atan2_f32>:
;     if (x > 0.0f)
 8013080: eef5 0ac0    	<unknown>
; {
 8013084: 4603         	mov	r3, r0
;     if (x > 0.0f)
 8013086: eef1 fa10    	<unknown>
 801308a: dc14         	bgt	0x80130b6 <arm_atan2_f32+0x36> @ imm = #0x28
;     if (x < 0.0f)
 801308c: d453         	bmi	0x8013136 <arm_atan2_f32+0xb6> @ imm = #0xa6
;     if (x == 0.0f)
 801308e: eef5 0a40    	<unknown>
 8013092: eef1 fa10    	<unknown>
 8013096: f040 8130    	bne.w	0x80132fa <arm_atan2_f32+0x27a> @ imm = #0x260
;         if (y > 0.0f)
 801309a: eeb5 0ac0    	<unknown>
 801309e: eef1 fa10    	<unknown>
 80130a2: f300 808e    	bgt.w	0x80131c2 <arm_atan2_f32+0x142> @ imm = #0x11c
;         if (y < 0.0f)
 80130a6: f140 8128    	bpl.w	0x80132fa <arm_atan2_f32+0x27a> @ imm = #0x250
 80130aa: eddf 7aaa    	<unknown>
;         return(ARM_MATH_SUCCESS);
 80130ae: 2000         	movs	r0, #0x0
;            *result=arm_atan_f32(y/x) - PI;
 80130b0: edc3 7a00    	<unknown>
 80130b4: 4770         	bx	lr
;         *result=arm_atan_f32(y/x);
 80130b6: eec0 7a20    	<unknown>
;    if (x < 0.0f)
 80130ba: eef5 7ac0    	<unknown>
 80130be: eef1 fa10    	<unknown>
 80130c2: f100 80a6    	bmi.w	0x8013212 <arm_atan2_f32+0x192> @ imm = #0x14c
;    int sign=0;
 80130c6: 2200         	movs	r2, #0x0
;    if (x > 1.0f)
 80130c8: eef7 6a00    	<unknown>
 80130cc: eef4 7ae6    	<unknown>
 80130d0: eef1 fa10    	<unknown>
 80130d4: dd78         	ble	0x80131c8 <arm_atan2_f32+0x148> @ imm = #0xf0
;       x = 1.0f / x;
 80130d6: ee86 7aa7    	<unknown>
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 80130da: eddf 2a9f    	<unknown>
 80130de: ed9f 3a9f    	<unknown>
 80130e2: eddf 3a9f    	<unknown>
 80130e6: ed9f 4a9f    	<unknown>
 80130ea: eddf 4a9f    	<unknown>
 80130ee: ed9f 5a9f    	<unknown>
 80130f2: eddf 5a9f    	<unknown>
 80130f6: ed9f 6a9f    	<unknown>
 80130fa: eddf 6a9f    	<unknown>
;       res = PIHALFF32 - arm_atan_limited_f32(x);
 80130fe: eddf 7a9f    	<unknown>
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 8013102: eea7 3a22    	<unknown>
 8013106: eee7 3a03    	<unknown>
 801310a: eea7 4a23    	<unknown>
 801310e: eee7 4a04    	<unknown>
 8013112: eea7 5a24    	<unknown>
 8013116: eee7 5a05    	<unknown>
 801311a: eea5 6a87    	<unknown>
 801311e: eee7 6a06    	<unknown>
;       res = PIHALFF32 - arm_atan_limited_f32(x);
 8013122: eee7 7a66    	<unknown>
;    if (sign)
 8013126: 2a00         	cmp	r2, #0x0
 8013128: d0c1         	beq	0x80130ae <arm_atan2_f32+0x2e> @ imm = #-0x7e
;      res = -res;
 801312a: eef1 7a67    	<unknown>
;         return(ARM_MATH_SUCCESS);
 801312e: 2000         	movs	r0, #0x0
;            *result=arm_atan_f32(y/x) - PI;
 8013130: edc3 7a00    	<unknown>
 8013134: 4770         	bx	lr
;         if (y > 0.0f)
 8013136: eeb5 0ac0    	<unknown>
 801313a: eef1 fa10    	<unknown>
 801313e: dd6c         	ble	0x801321a <arm_atan2_f32+0x19a> @ imm = #0xd8
;            *result=arm_atan_f32(y/x) + PI;
 8013140: eec0 7a20    	<unknown>
;    if (x < 0.0f)
 8013144: eef5 7ac0    	<unknown>
 8013148: eef1 fa10    	<unknown>
 801314c: f100 80d1    	bmi.w	0x80132f2 <arm_atan2_f32+0x272> @ imm = #0x1a2
;    int sign=0;
 8013150: 2200         	movs	r2, #0x0
;    if (x > 1.0f)
 8013152: eef7 6a00    	<unknown>
 8013156: eef4 7ae6    	<unknown>
 801315a: eef1 fa10    	<unknown>
 801315e: f340 80a0    	ble.w	0x80132a2 <arm_atan2_f32+0x222> @ imm = #0x140
;       x = 1.0f / x;
 8013162: ee86 7aa7    	<unknown>
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 8013166: eddf 2a7c    	<unknown>
 801316a: ed9f 3a7c    	<unknown>
 801316e: eddf 3a7c    	<unknown>
 8013172: ed9f 4a7c    	<unknown>
 8013176: eddf 4a7c    	<unknown>
 801317a: ed9f 5a7c    	<unknown>
 801317e: eddf 5a7c    	<unknown>
 8013182: ed9f 6a7c    	<unknown>
 8013186: eddf 6a7c    	<unknown>
;       res = PIHALFF32 - arm_atan_limited_f32(x);
 801318a: eddf 7a7c    	<unknown>
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 801318e: eea7 3a22    	<unknown>
 8013192: eee7 3a03    	<unknown>
 8013196: eea7 4a23    	<unknown>
 801319a: eee7 4a04    	<unknown>
 801319e: eea7 5a24    	<unknown>
 80131a2: eee7 5a05    	<unknown>
 80131a6: eea7 6a25    	<unknown>
 80131aa: eee7 6a06    	<unknown>
;       res = PIHALFF32 - arm_atan_limited_f32(x);
 80131ae: eee7 7a66    	<unknown>
;    if (sign)
 80131b2: b10a         	cbz	r2, 0x80131b8 <arm_atan2_f32+0x138> @ imm = #0x2
;      res = -res;
 80131b4: eef1 7a67    	<unknown>
;            *result=arm_atan_f32(y/x) + PI;
 80131b8: ed9f 7a71    	<unknown>
 80131bc: ee77 7a87    	<unknown>
 80131c0: e775         	b	0x80130ae <arm_atan2_f32+0x2e> @ imm = #-0x116
 80131c2: eddf 7a6e    	<unknown>
 80131c6: e772         	b	0x80130ae <arm_atan2_f32+0x2e> @ imm = #-0x11c
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 80131c8: ed9f 7a63    	<unknown>
 80131cc: eddf 3a63    	<unknown>
 80131d0: ed9f 4a63    	<unknown>
 80131d4: eee7 3a87    	<unknown>
 80131d8: eddf 4a62    	<unknown>
 80131dc: ed9f 5a62    	<unknown>
 80131e0: eddf 5a62    	<unknown>
 80131e4: ed9f 6a62    	<unknown>
 80131e8: eddf 6a62    	<unknown>
 80131ec: ed9f 7a62    	<unknown>
 80131f0: eea7 4aa3    	<unknown>
 80131f4: eee7 4a84    	<unknown>
 80131f8: eea7 5aa4    	<unknown>
 80131fc: eee7 5a85    	<unknown>
 8013200: eea7 6aa5    	<unknown>
 8013204: eee7 6a86    	<unknown>
 8013208: eea7 7aa6    	<unknown>
 801320c: ee67 7a87    	<unknown>
;     for(i=1;i<ATAN2_NB_COEFS_F32;i++)
 8013210: e789         	b	0x8013126 <arm_atan2_f32+0xa6> @ imm = #-0xee
;       x=-x;
 8013212: eef1 7a67    	<unknown>
;       sign=1;
 8013216: 2201         	movs	r2, #0x1
 8013218: e756         	b	0x80130c8 <arm_atan2_f32+0x48> @ imm = #-0x154
;         else if (y < 0.0f)
 801321a: d402         	bmi	0x8013222 <arm_atan2_f32+0x1a2> @ imm = #0x4
 801321c: eddf 7a58    	<unknown>
 8013220: e745         	b	0x80130ae <arm_atan2_f32+0x2e> @ imm = #-0x176
;            *result=arm_atan_f32(y/x) - PI;
 8013222: eec0 7a20    	<unknown>
;    if (x < 0.0f)
 8013226: eef5 7ac0    	<unknown>
 801322a: eef1 fa10    	<unknown>
 801322e: f100 808c    	bmi.w	0x801334a <arm_atan2_f32+0x2ca> @ imm = #0x118
;    int sign=0;
 8013232: 2200         	movs	r2, #0x0
;    if (x > 1.0f)
 8013234: eef7 6a00    	<unknown>
 8013238: eef4 7ae6    	<unknown>
 801323c: eef1 fa10    	<unknown>
 8013240: dd5e         	ble	0x8013300 <arm_atan2_f32+0x280> @ imm = #0xbc
;       x = 1.0f / x;
 8013242: ee86 7aa7    	<unknown>
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 8013246: eddf 2a44    	<unknown>
 801324a: ed9f 3a44    	<unknown>
 801324e: eddf 3a44    	<unknown>
 8013252: ed9f 4a44    	<unknown>
 8013256: eddf 4a44    	<unknown>
 801325a: ed9f 5a44    	<unknown>
 801325e: eddf 5a44    	<unknown>
 8013262: ed9f 6a44    	<unknown>
 8013266: eddf 6a44    	<unknown>
;       res = PIHALFF32 - arm_atan_limited_f32(x);
 801326a: eddf 7a44    	<unknown>
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 801326e: eea7 3a22    	<unknown>
 8013272: eee7 3a03    	<unknown>
 8013276: eea7 4a23    	<unknown>
 801327a: eee7 4a04    	<unknown>
 801327e: eea7 5a24    	<unknown>
 8013282: eee7 5a05    	<unknown>
 8013286: eea7 6a25    	<unknown>
 801328a: eee7 6a06    	<unknown>
;       res = PIHALFF32 - arm_atan_limited_f32(x);
 801328e: eee7 7a66    	<unknown>
;    if (sign)
 8013292: b10a         	cbz	r2, 0x8013298 <arm_atan2_f32+0x218> @ imm = #0x2
;      res = -res;
 8013294: eef1 7a67    	<unknown>
;            *result=arm_atan_f32(y/x) - PI;
 8013298: ed9f 7a39    	<unknown>
 801329c: ee77 7ac7    	<unknown>
 80132a0: e705         	b	0x80130ae <arm_atan2_f32+0x2e> @ imm = #-0x1f6
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 80132a2: ed9f 7a2d    	<unknown>
 80132a6: eddf 3a2d    	<unknown>
 80132aa: ed9f 4a2d    	<unknown>
 80132ae: eee7 3a87    	<unknown>
 80132b2: eddf 4a2c    	<unknown>
 80132b6: ed9f 5a2c    	<unknown>
 80132ba: eddf 5a2c    	<unknown>
 80132be: ed9f 6a2c    	<unknown>
 80132c2: eddf 6a2c    	<unknown>
 80132c6: ed9f 7a2c    	<unknown>
 80132ca: eea7 4aa3    	<unknown>
 80132ce: eee7 4a84    	<unknown>
 80132d2: eea7 5aa4    	<unknown>
 80132d6: eee7 5a85    	<unknown>
 80132da: eea7 6aa5    	<unknown>
 80132de: eee7 6a86    	<unknown>
 80132e2: eea7 7aa6    	<unknown>
 80132e6: ee67 7a87    	<unknown>
;    if (sign)
 80132ea: 2a00         	cmp	r2, #0x0
 80132ec: f43f af64    	beq.w	0x80131b8 <arm_atan2_f32+0x138> @ imm = #-0x138
 80132f0: e760         	b	0x80131b4 <arm_atan2_f32+0x134> @ imm = #-0x140
;       x=-x;
 80132f2: eef1 7a67    	<unknown>
;       sign=1;
 80132f6: 2201         	movs	r2, #0x1
 80132f8: e72b         	b	0x8013152 <arm_atan2_f32+0xd2> @ imm = #-0x1aa
;     return(ARM_MATH_NANINF);
 80132fa: f06f 0003    	mvn	r0, #0x3
; }
 80132fe: 4770         	bx	lr
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 8013300: ed9f 7a15    	<unknown>
 8013304: eddf 3a15    	<unknown>
 8013308: ed9f 4a15    	<unknown>
 801330c: eee7 3a87    	<unknown>
 8013310: eddf 4a14    	<unknown>
 8013314: ed9f 5a14    	<unknown>
 8013318: eddf 5a14    	<unknown>
 801331c: ed9f 6a14    	<unknown>
 8013320: eddf 6a14    	<unknown>
 8013324: ed9f 7a14    	<unknown>
 8013328: eea7 4aa3    	<unknown>
 801332c: eee7 4a84    	<unknown>
 8013330: eea7 5aa4    	<unknown>
 8013334: eee7 5a85    	<unknown>
 8013338: eea7 6aa5    	<unknown>
 801333c: eee7 6a86    	<unknown>
 8013340: eea7 7aa6    	<unknown>
 8013344: ee67 7a87    	<unknown>
;     for(i=1;i<ATAN2_NB_COEFS_F32;i++)
 8013348: e7a3         	b	0x8013292 <arm_atan2_f32+0x212> @ imm = #-0xba
;       x=-x;
 801334a: eef1 7a67    	<unknown>
;       sign=1;
 801334e: 2201         	movs	r2, #0x1
 8013350: e770         	b	0x8013234 <arm_atan2_f32+0x1b4> @ imm = #-0x120
 8013352: bf00         	nop

08013354 <$d>:
 8013354: db 0f c9 bf  	.word	0xbfc90fdb
 8013358: a5 92 04 bd  	.word	0xbd0492a5
 801335c: e7 45 09 3e  	.word	0x3e0945e7
 8013360: 08 b7 32 be  	.word	0xbe32b708
 8013364: eb fc a9 bc  	.word	0xbca9fceb
 8013368: 3c 69 5d 3e  	.word	0x3e5d693c
 801336c: 43 56 90 bb  	.word	0xbb905643
 8013370: e5 65 aa be  	.word	0xbeaa65e5
 8013374: c9 0c c0 b7  	.word	0xb7c00cc9
 8013378: 01 00 80 3f  	.word	0x3f800001
 801337c: db 0f c9 3f  	.word	0x3fc90fdb
 8013380: db 0f 49 40  	.word	0x40490fdb

08013384 <arm_mat_add_f32>:
; {
 8013384: b410         	push	{r4}
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 8013386: 8803         	ldrh	r3, [r0]
 8013388: f8b0 c002    	ldrh.w	r12, [r0, #0x2]
;   float32_t *pInB = pSrcB->pData;                /* input data matrix pointer B */
 801338c: 684c         	ldr	r4, [r1, #0x4]
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 801338e: fb0c f303    	mul	r3, r12, r3
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 8013392: 6851         	ldr	r1, [r2, #0x4]
;   float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A */
 8013394: 6842         	ldr	r2, [r0, #0x4]
;     while (blkCnt > 0U)
 8013396: b14b         	cbz	r3, 0x80133ac <arm_mat_add_f32+0x28> @ imm = #0x12
;       *pOut++ = *pInA++ + *pInB++;
 8013398: ecf2 7a01    	<unknown>
;     while (blkCnt > 0U)
 801339c: 3b01         	subs	r3, #0x1
;       *pOut++ = *pInA++ + *pInB++;
 801339e: ecb4 7a01    	<unknown>
 80133a2: ee77 7a87    	<unknown>
 80133a6: ece1 7a01    	<unknown>
;     while (blkCnt > 0U)
 80133aa: d1f5         	bne	0x8013398 <arm_mat_add_f32+0x14> @ imm = #-0x16
; }
 80133ac: 2000         	movs	r0, #0x0
 80133ae: f85d 4b04    	ldr	r4, [sp], #4
 80133b2: 4770         	bx	lr

080133b4 <arm_mat_init_f32>:
;   S->numRows = nRows;
 80133b4: 8001         	strh	r1, [r0]
;   S->numCols = nColumns;
 80133b6: 8042         	strh	r2, [r0, #0x2]
;   S->pData = pData;
 80133b8: 6043         	str	r3, [r0, #0x4]
; }
 80133ba: 4770         	bx	lr

080133bc <arm_mat_inverse_f32>:
; {
 80133bc: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
;   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
 80133c0: 8806         	ldrh	r6, [r0]
; {
 80133c2: b083         	sub	sp, #0xc
 80133c4: 4604         	mov	r4, r0
 80133c6: 460d         	mov	r5, r1
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 80133c8: 684f         	ldr	r7, [r1, #0x4]
;   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
 80133ca: f8b0 a002    	ldrh.w	r10, [r0, #0x2]
;     while (rowCnt > 0U)
 80133ce: b32e         	cbz	r6, 0x801341c <arm_mat_inverse_f32+0x60> @ imm = #0x4a
 80133d0: f04f 0800    	mov.w	r8, #0x0
;       *pTmp++ = 1.0f;
 80133d4: f04f 5b7e    	mov.w	r11, #0x3f800000
;   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
 80133d8: 46b1         	mov	r9, r6
;     while (rowCnt > 0U)
 80133da: 4644         	mov	r4, r8
 80133dc: 4680         	mov	r8, r0
 80133de: e010         	b	0x8013402 <arm_mat_inverse_f32+0x46> @ imm = #0x20
;       *pTmp++ = 1.0f;
 80133e0: 4417         	add	r7, r2
;         *pTmp++ = 0.0f;
 80133e2: f015 fe95    	bl	0x8029110 <memset>      @ imm = #0x15d2a
;       while (j > 0U)
 80133e6: f1b9 0901    	subs.w	r9, r9, #0x1
 80133ea: f104 0401    	add.w	r4, r4, #0x1
;       *pTmp++ = 1.0f;
 80133ee: f847 bb04    	str	r11, [r7], #4
;       while (j > 0U)
 80133f2: d012         	beq	0x801341a <arm_mat_inverse_f32+0x5e> @ imm = #0x24
 80133f4: ea4f 0289    	lsl.w	r2, r9, #0x2
;         *pTmp++ = 0.0f;
 80133f8: 4638         	mov	r0, r7
 80133fa: 2100         	movs	r1, #0x0
 80133fc: 4417         	add	r7, r2
 80133fe: f015 fe87    	bl	0x8029110 <memset>      @ imm = #0x15d0e
;       while (j > 0U)
 8013402: 00a2         	lsls	r2, r4, #0x2
;         *pTmp++ = 0.0f;
 8013404: 2100         	movs	r1, #0x0
 8013406: 4638         	mov	r0, r7
;       while (j > 0U)
 8013408: 2c00         	cmp	r4, #0x0
 801340a: d1e9         	bne	0x80133e0 <arm_mat_inverse_f32+0x24> @ imm = #-0x2e
;       while (j > 0U)
 801340c: f1b9 0901    	subs.w	r9, r9, #0x1
 8013410: f04f 0401    	mov.w	r4, #0x1
;       *pTmp++ = 1.0f;
 8013414: f847 bb04    	str	r11, [r7], #4
;       while (j > 0U)
 8013418: d1ec         	bne	0x80133f4 <arm_mat_inverse_f32+0x38> @ imm = #-0x28
 801341a: 4644         	mov	r4, r8
;     for(column = 0U; column < numCols; column++)
 801341c: f1ba 0f00    	cmp.w	r10, #0x0
 8013420: f000 8141    	beq.w	0x80136a6 <arm_mat_inverse_f32+0x2ea> @ imm = #0x282
 8013424: f04f 0800    	mov.w	r8, #0x0
;       pivot = 1.0f / pivot;
 8013428: eef7 5a00    	<unknown>
;     for(column = 0U; column < numCols; column++)
 801342c: 46c1         	mov	r9, r8
;   uint32_t selectedRow,pivotRow,i, rowNb, rowCnt, flag = 0U, j,column;      /* loop counters */
 801342e: f8cd 8004    	str.w	r8, [sp, #0x4]
;       pTmp = ELEM(pSrc,column,column) ;
 8013432: f8b4 c002    	ldrh.w	r12, [r4, #0x2]
 8013436: 464b         	mov	r3, r9
 8013438: 6862         	ldr	r2, [r4, #0x4]
 801343a: f10c 0e01    	add.w	lr, r12, #0x1
 801343e: ea4f 0e8e    	lsl.w	lr, lr, #0x2
 8013442: fb0e 2b09    	mla	r11, lr, r9, r2
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 8013446: f109 0901    	add.w	r9, r9, #0x1
 801344a: 454e         	cmp	r6, r9
;       pivot = *pTmp;
 801344c: ed9b 7a00    	<unknown>
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 8013450: f240 811b    	bls.w	0x801368a <arm_mat_inverse_f32+0x2ce> @ imm = #0x236
 8013454: fb09 300c    	mla	r0, r9, r12, r3
 8013458: f1ae 0e04    	sub.w	lr, lr, #0x4
 801345c: 4649         	mov	r1, r9
 801345e: 461f         	mov	r7, r3
 8013460: eb02 0080    	add.w	r0, r2, r0, lsl #2
;           newPivot = *pTmp;
 8013464: edd0 7a00    	<unknown>
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 8013468: 4470         	add	r0, lr
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 801346a: eeb0 6ac7    	<unknown>
 801346e: eef0 6ae7    	<unknown>
;             pivot = newPivot;
 8013472: eeb4 6ae6    	<unknown>
 8013476: eef1 fa10    	<unknown>
 801347a: bf48         	it	mi
 801347c: 460f         	movmi	r7, r1
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 801347e: f101 0101    	add.w	r1, r1, #0x1
;             pivot = newPivot;
 8013482: bf48         	it	mi
 8013484: eeb0 7a67    	<unknown>
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 8013488: 428e         	cmpmi	r6, r1
 801348a: d1eb         	bne	0x8013464 <arm_mat_inverse_f32+0xa8> @ imm = #-0x2a
;       if ((pivot != 0.0f) && (selectedRow != column))
 801348c: eeb5 7a40    	<unknown>
 8013490: eef1 fa10    	<unknown>
 8013494: d002         	beq	0x801349c <arm_mat_inverse_f32+0xe0> @ imm = #0x4
 8013496: 4547         	cmp	r7, r8
 8013498: f040 80ca    	bne.w	0x8013630 <arm_mat_inverse_f32+0x274> @ imm = #0x194
;       if ((flag != 1U) && (pivot == 0.0f))
 801349c: eeb5 7a40    	<unknown>
 80134a0: 9901         	ldr	r1, [sp, #0x4]
 80134a2: f081 0101    	eor	r1, r1, #0x1
 80134a6: eef1 fa10    	<unknown>
 80134aa: f001 0001    	and	r0, r1, #0x1
 80134ae: bf18         	it	ne
 80134b0: 2000         	movne	r0, #0x0
 80134b2: 2800         	cmp	r0, #0x0
 80134b4: f040 80f7    	bne.w	0x80136a6 <arm_mat_inverse_f32+0x2ea> @ imm = #0x1ee
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 80134b8: ebac 0003    	sub.w	r0, r12, r3
 80134bc: fb0c 3703    	mla	r7, r12, r3, r3
;       pivot = 1.0f / pivot;
 80134c0: eec5 7a87    	<unknown>
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 80134c4: 2800         	cmp	r0, #0x0
 80134c6: eb02 0287    	add.w	r2, r2, r7, lsl #2
 80134ca: dd09         	ble	0x80134e0 <arm_mat_inverse_f32+0x124> @ imm = #0x12
 80134cc: eb02 0080    	add.w	r0, r2, r0, lsl #2
 80134d0: ecb2 7a01    	<unknown>
 80134d4: ee27 7a27    	<unknown>
 80134d8: 4282         	cmp	r2, r0
 80134da: ed02 7a01    	<unknown>
 80134de: d1f7         	bne	0x80134d0 <arm_mat_inverse_f32+0x114> @ imm = #-0x12
;       SCALE_ROW_F32(pDst,0,pivot,pivotRow);
 80134e0: 886f         	ldrh	r7, [r5, #0x2]
 80134e2: 686a         	ldr	r2, [r5, #0x4]
 80134e4: 00b8         	lsls	r0, r7, #0x2
 80134e6: fb00 2203    	mla	r2, r0, r3, r2
 80134ea: b147         	cbz	r7, 0x80134fe <arm_mat_inverse_f32+0x142> @ imm = #0x10
 80134ec: 4410         	add	r0, r2
 80134ee: ecb2 7a01    	<unknown>
 80134f2: ee27 7a27    	<unknown>
 80134f6: 4282         	cmp	r2, r0
 80134f8: ed02 7a01    	<unknown>
 80134fc: d1f7         	bne	0x80134ee <arm_mat_inverse_f32+0x132> @ imm = #-0x12
;       for (;rowNb < pivotRow; rowNb++)
 80134fe: f1b8 0f00    	cmp.w	r8, #0x0
 8013502: d038         	beq	0x8013576 <arm_mat_inverse_f32+0x1ba> @ imm = #0x70
;       rowNb = 0;
 8013504: 2700         	movs	r7, #0x0
;            pTmp = ELEM(pSrc,rowNb,column) ;
 8013506: f8b4 c002    	ldrh.w	r12, [r4, #0x2]
 801350a: 6860         	ldr	r0, [r4, #0x4]
 801350c: fb07 320c    	mla	r2, r7, r12, r3
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 8013510: fb0c 3e03    	mla	lr, r12, r3, r3
 8013514: ebac 0c03    	sub.w	r12, r12, r3
;            pTmp = ELEM(pSrc,rowNb,column) ;
 8013518: eb00 0282    	add.w	r2, r0, r2, lsl #2
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 801351c: f1bc 0f00    	cmp.w	r12, #0x0
 8013520: eb00 008e    	add.w	r0, r0, lr, lsl #2
;            pivot = *pTmp;
 8013524: edd2 7a00    	<unknown>
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 8013528: dd0b         	ble	0x8013542 <arm_mat_inverse_f32+0x186> @ imm = #0x16
 801352a: eb02 0c8c    	add.w	r12, r2, r12, lsl #2
 801352e: ecb2 7a01    	<unknown>
 8013532: ecf0 6a01    	<unknown>
 8013536: 4562         	cmp	r2, r12
 8013538: eea6 7ae7    	<unknown>
 801353c: ed02 7a01    	<unknown>
 8013540: d1f5         	bne	0x801352e <arm_mat_inverse_f32+0x172> @ imm = #-0x16
;            MAS_ROW_F32(0     ,pDst,rowNb,pivot,pDst,pivotRow);
 8013542: f8b5 e002    	ldrh.w	lr, [r5, #0x2]
 8013546: 6868         	ldr	r0, [r5, #0x4]
 8013548: ea4f 0c8e    	lsl.w	r12, lr, #0x2
 801354c: fb0c 0207    	mla	r2, r12, r7, r0
 8013550: fb0c 0003    	mla	r0, r12, r3, r0
 8013554: f1be 0f00    	cmp.w	lr, #0x0
 8013558: d00a         	beq	0x8013570 <arm_mat_inverse_f32+0x1b4> @ imm = #0x14
 801355a: 4494         	add	r12, r2
 801355c: ecb2 7a01    	<unknown>
 8013560: ecf0 6a01    	<unknown>
 8013564: 4562         	cmp	r2, r12
 8013566: eea6 7ae7    	<unknown>
 801356a: ed02 7a01    	<unknown>
 801356e: d1f5         	bne	0x801355c <arm_mat_inverse_f32+0x1a0> @ imm = #-0x16
;       for (;rowNb < pivotRow; rowNb++)
 8013570: 3701         	adds	r7, #0x1
 8013572: 4547         	cmp	r7, r8
 8013574: d1c7         	bne	0x8013506 <arm_mat_inverse_f32+0x14a> @ imm = #-0x72
;       for (rowNb = pivotRow + 1; rowNb < numRows; rowNb++)
 8013576: 454e         	cmp	r6, r9
 8013578: d938         	bls	0x80135ec <arm_mat_inverse_f32+0x230> @ imm = #0x70
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 801357a: 464f         	mov	r7, r9
;            pTmp = ELEM(pSrc,rowNb,column) ;
 801357c: f8b4 c002    	ldrh.w	r12, [r4, #0x2]
 8013580: 6860         	ldr	r0, [r4, #0x4]
 8013582: fb07 320c    	mla	r2, r7, r12, r3
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 8013586: fb0c 3e03    	mla	lr, r12, r3, r3
 801358a: ebac 0c03    	sub.w	r12, r12, r3
;            pTmp = ELEM(pSrc,rowNb,column) ;
 801358e: eb00 0282    	add.w	r2, r0, r2, lsl #2
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 8013592: f1bc 0f00    	cmp.w	r12, #0x0
 8013596: eb00 008e    	add.w	r0, r0, lr, lsl #2
;            pivot = *pTmp;
 801359a: edd2 7a00    	<unknown>
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 801359e: dd0b         	ble	0x80135b8 <arm_mat_inverse_f32+0x1fc> @ imm = #0x16
 80135a0: eb02 0c8c    	add.w	r12, r2, r12, lsl #2
 80135a4: ecb2 7a01    	<unknown>
 80135a8: ecf0 6a01    	<unknown>
 80135ac: 4562         	cmp	r2, r12
 80135ae: eea6 7ae7    	<unknown>
 80135b2: ed02 7a01    	<unknown>
 80135b6: d1f5         	bne	0x80135a4 <arm_mat_inverse_f32+0x1e8> @ imm = #-0x16
;            MAS_ROW_F32(0     ,pDst,rowNb,pivot,pDst,pivotRow);
 80135b8: f8b5 e002    	ldrh.w	lr, [r5, #0x2]
 80135bc: 6868         	ldr	r0, [r5, #0x4]
 80135be: ea4f 0c8e    	lsl.w	r12, lr, #0x2
 80135c2: fb07 020c    	mla	r2, r7, r12, r0
 80135c6: fb03 000c    	mla	r0, r3, r12, r0
 80135ca: f1be 0f00    	cmp.w	lr, #0x0
 80135ce: d00a         	beq	0x80135e6 <arm_mat_inverse_f32+0x22a> @ imm = #0x14
 80135d0: 4494         	add	r12, r2
 80135d2: ecb2 7a01    	<unknown>
 80135d6: ecf0 6a01    	<unknown>
 80135da: 4562         	cmp	r2, r12
 80135dc: eea6 7ae7    	<unknown>
 80135e0: ed02 7a01    	<unknown>
 80135e4: d1f5         	bne	0x80135d2 <arm_mat_inverse_f32+0x216> @ imm = #-0x16
;       for (rowNb = pivotRow + 1; rowNb < numRows; rowNb++)
 80135e6: 3701         	adds	r7, #0x1
 80135e8: 42be         	cmp	r6, r7
 80135ea: d1c7         	bne	0x801357c <arm_mat_inverse_f32+0x1c0> @ imm = #-0x72
;     for(column = 0U; column < numCols; column++)
 80135ec: 45ca         	cmp	r10, r9
 80135ee: f108 0801    	add.w	r8, r8, #0x1
 80135f2: f47f af1e    	bne.w	0x8013432 <arm_mat_inverse_f32+0x76> @ imm = #-0x1c4
;     if ((flag != 1U) && (pivot == 0.0f))
 80135f6: eef5 7a40    	<unknown>
 80135fa: eef1 fa10    	<unknown>
 80135fe: d113         	bne	0x8013628 <arm_mat_inverse_f32+0x26c> @ imm = #0x26
 8013600: b191         	cbz	r1, 0x8013628 <arm_mat_inverse_f32+0x26c> @ imm = #0x24
;       for (i = 0; i < numRows * numCols; i++)
 8013602: fb0a f606    	mul	r6, r10, r6
;       pIn = pSrc->pData;
 8013606: 6862         	ldr	r2, [r4, #0x4]
;       for (i = 0; i < numRows * numCols; i++)
 8013608: 2e00         	cmp	r6, #0x0
 801360a: d04c         	beq	0x80136a6 <arm_mat_inverse_f32+0x2ea> @ imm = #0x98
 801360c: 2300         	movs	r3, #0x0
 801360e: e002         	b	0x8013616 <arm_mat_inverse_f32+0x25a> @ imm = #0x4
 8013610: 3301         	adds	r3, #0x1
 8013612: 42b3         	cmp	r3, r6
 8013614: d047         	beq	0x80136a6 <arm_mat_inverse_f32+0x2ea> @ imm = #0x8e
;         if (pIn[i] != 0.0f)
 8013616: ecf2 7a01    	<unknown>
 801361a: eef5 7a40    	<unknown>
 801361e: eef1 fa10    	<unknown>
 8013622: d0f5         	beq	0x8013610 <arm_mat_inverse_f32+0x254> @ imm = #-0x16
;       if (i == numRows * numCols)
 8013624: 429e         	cmp	r6, r3
 8013626: d03e         	beq	0x80136a6 <arm_mat_inverse_f32+0x2ea> @ imm = #0x7c
;     status = ARM_MATH_SUCCESS;
 8013628: 2000         	movs	r0, #0x0
; }
 801362a: b003         	add	sp, #0xc
 801362c: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
;             SWAP_ROWS_F32(pSrc,column, pivotRow,selectedRow);
 8013630: fb07 310c    	mla	r1, r7, r12, r3
 8013634: ebac 0c03    	sub.w	r12, r12, r3
 8013638: f1bc 0f00    	cmp.w	r12, #0x0
 801363c: eb02 0281    	add.w	r2, r2, r1, lsl #2
 8013640: dd0a         	ble	0x8013658 <arm_mat_inverse_f32+0x29c> @ imm = #0x14
 8013642: eb0b 0c8c    	add.w	r12, r11, r12, lsl #2
 8013646: 6810         	ldr	r0, [r2]
 8013648: f8db 1000    	ldr.w	r1, [r11]
 801364c: f84b 0b04    	str	r0, [r11], #4
 8013650: 45e3         	cmp	r11, r12
 8013652: f842 1b04    	str	r1, [r2], #4
 8013656: d1f6         	bne	0x8013646 <arm_mat_inverse_f32+0x28a> @ imm = #-0x14
;             SWAP_ROWS_F32(pDst,0, pivotRow,selectedRow);
 8013658: 8869         	ldrh	r1, [r5, #0x2]
 801365a: 686a         	ldr	r2, [r5, #0x4]
 801365c: ea4f 0c81    	lsl.w	r12, r1, #0x2
 8013660: fb0c 2707    	mla	r7, r12, r7, r2
 8013664: fb0c 2203    	mla	r2, r12, r3, r2
 8013668: b141         	cbz	r1, 0x801367c <arm_mat_inverse_f32+0x2c0> @ imm = #0x10
 801366a: 4494         	add	r12, r2
 801366c: 6838         	ldr	r0, [r7]
 801366e: 6811         	ldr	r1, [r2]
 8013670: f842 0b04    	str	r0, [r2], #4
 8013674: 4562         	cmp	r2, r12
 8013676: f847 1b04    	str	r1, [r7], #4
 801367a: d1f7         	bne	0x801366c <arm_mat_inverse_f32+0x2b0> @ imm = #-0x12
;             flag = 1U;
 801367c: 2201         	movs	r2, #0x1
;             pivot = newPivot;
 801367e: 2100         	movs	r1, #0x0
 8013680: f8b4 c002    	ldrh.w	r12, [r4, #0x2]
;             flag = 1U;
 8013684: 9201         	str	r2, [sp, #0x4]
 8013686: 6862         	ldr	r2, [r4, #0x4]
 8013688: e716         	b	0x80134b8 <arm_mat_inverse_f32+0xfc> @ imm = #-0x1d4
;       if ((flag != 1U) && (pivot == 0.0f))
 801368a: eeb5 7a40    	<unknown>
 801368e: 9901         	ldr	r1, [sp, #0x4]
 8013690: f081 0101    	eor	r1, r1, #0x1
 8013694: eef1 fa10    	<unknown>
 8013698: f001 0001    	and	r0, r1, #0x1
 801369c: bf18         	it	ne
 801369e: 2000         	movne	r0, #0x0
 80136a0: 2800         	cmp	r0, #0x0
 80136a2: f43f af09    	beq.w	0x80134b8 <arm_mat_inverse_f32+0xfc> @ imm = #-0x1ee
;         return ARM_MATH_SINGULAR;
 80136a6: f06f 0004    	mvn	r0, #0x4
; }
 80136aa: b003         	add	sp, #0xc
 80136ac: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}

080136b0 <arm_mat_mult_f32>:
; {
 80136b0: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 80136b4: 460e         	mov	r6, r1
;   float32_t *pIn2 = pSrcB->pData;                /* Input data matrix pointer B */
 80136b6: 684b         	ldr	r3, [r1, #0x4]
;   uint16_t numColsB = pSrcB->numCols;            /* Number of columns of input matrix B */
 80136b8: 8849         	ldrh	r1, [r1, #0x2]
;         colCnt = numColsA;
 80136ba: 8844         	ldrh	r4, [r0, #0x2]
 80136bc: 2901         	cmp	r1, #0x1
;   float32_t *pIn1 = pSrcA->pData;                /* Input data matrix pointer A */
 80136be: f8d0 e004    	ldr.w	lr, [r0, #0x4]
;   uint32_t col, i = 0U, row = numRowsA, colCnt;  /* Loop counters */
 80136c2: 8805         	ldrh	r5, [r0]
;       pInA = pInA + numColsA;
 80136c4: ea4f 0784    	lsl.w	r7, r4, #0x2
;   float32_t *pOut = pDst->pData;                 /* Output data matrix pointer */
 80136c8: 6852         	ldr	r2, [r2, #0x4]
;           pIn2 += numColsB;
 80136ca: ea4f 0081    	lsl.w	r0, r1, #0x2
 80136ce: d12e         	bne	0x801372e <arm_mat_mult_f32+0x7e> @ imm = #0x5c
 80136d0: eb02 0a00    	add.w	r10, r2, r0
 80136d4: f103 0804    	add.w	r8, r3, #0x4
;       px = pOut + i;
 80136d8: ebaa 0c00    	sub.w	r12, r10, r0
;       pIn2 = pSrcB->pData;
 80136dc: 46c1         	mov	r9, r8
;         while (colCnt > 0U)
 80136de: b1cc         	cbz	r4, 0x8013714 <arm_mat_mult_f32+0x64> @ imm = #0x32
;         colCnt = numColsA;
 80136e0: 4622         	mov	r2, r4
;         while (colCnt > 0U)
 80136e2: 4671         	mov	r1, lr
;         sum = 0.0f;
 80136e4: eddf 7a28    	<unknown>
;           sum += *pIn1++ * *pIn2;
 80136e8: edd3 6a00    	<unknown>
;         while (colCnt > 0U)
 80136ec: 3a01         	subs	r2, #0x1
;           sum += *pIn1++ * *pIn2;
 80136ee: ecb1 7a01    	<unknown>
;           pIn2 += numColsB;
 80136f2: 4403         	add	r3, r0
;           sum += *pIn1++ * *pIn2;
 80136f4: eee6 7a87    	<unknown>
;         while (colCnt > 0U)
 80136f8: d1f6         	bne	0x80136e8 <arm_mat_mult_f32+0x38> @ imm = #-0x14
;         *px++ = sum;
 80136fa: ecec 7a01    	<unknown>
;       } while (col > 0U);
 80136fe: 45d4         	cmp	r12, r10
;         pIn2 = pInB + (numColsB - col);
 8013700: 464b         	mov	r3, r9
;       } while (col > 0U);
 8013702: f109 0904    	add.w	r9, r9, #0x4
 8013706: d1ea         	bne	0x80136de <arm_mat_mult_f32+0x2e> @ imm = #-0x2c
;     } while (row > 0U);
 8013708: 3d01         	subs	r5, #0x1
;       pInA = pInA + numColsA;
 801370a: 44be         	add	lr, r7
;     } while (row > 0U);
 801370c: 4482         	add	r10, r0
 801370e: d00b         	beq	0x8013728 <arm_mat_mult_f32+0x78> @ imm = #0x16
;       pIn2 = pSrcB->pData;
 8013710: 6873         	ldr	r3, [r6, #0x4]
 8013712: e7e1         	b	0x80136d8 <arm_mat_mult_f32+0x28> @ imm = #-0x3e
;         sum = 0.0f;
 8013714: eddf 7a1c    	<unknown>
;         pIn2 = pInB + (numColsB - col);
 8013718: 464b         	mov	r3, r9
;       } while (col > 0U);
 801371a: f109 0904    	add.w	r9, r9, #0x4
;         *px++ = sum;
 801371e: ecec 7a01    	<unknown>
;       } while (col > 0U);
 8013722: 45d4         	cmp	r12, r10
 8013724: d1db         	bne	0x80136de <arm_mat_mult_f32+0x2e> @ imm = #-0x4a
 8013726: e7ef         	b	0x8013708 <arm_mat_mult_f32+0x58> @ imm = #-0x22
; }
 8013728: 2000         	movs	r0, #0x0
 801372a: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}
 801372e: eb02 0c00    	add.w	r12, r2, r0
 8013732: f103 0804    	add.w	r8, r3, #0x4
;       px = pOut + i;
 8013736: ebac 0900    	sub.w	r9, r12, r0
;       pIn2 = pSrcB->pData;
 801373a: 46c2         	mov	r10, r8
;         while (colCnt > 0U)
 801373c: b1cc         	cbz	r4, 0x8013772 <arm_mat_mult_f32+0xc2> @ imm = #0x32
;         colCnt = numColsA;
 801373e: 4622         	mov	r2, r4
;         while (colCnt > 0U)
 8013740: 4671         	mov	r1, lr
;         sum = 0.0f;
 8013742: eddf 7a11    	<unknown>
;           sum += *pIn1++ * *pIn2;
 8013746: ed93 7a00    	<unknown>
;         while (colCnt > 0U)
 801374a: 3a01         	subs	r2, #0x1
;           sum += *pIn1++ * *pIn2;
 801374c: ecf1 6a01    	<unknown>
;           pIn2 += numColsB;
 8013750: 4403         	add	r3, r0
;           sum += *pIn1++ * *pIn2;
 8013752: eee6 7a87    	<unknown>
;         while (colCnt > 0U)
 8013756: d1f6         	bne	0x8013746 <arm_mat_mult_f32+0x96> @ imm = #-0x14
;         *px++ = sum;
 8013758: ece9 7a01    	<unknown>
;       } while (col > 0U);
 801375c: 45e1         	cmp	r9, r12
;         pIn2 = pInB + (numColsB - col);
 801375e: 4653         	mov	r3, r10
;       } while (col > 0U);
 8013760: f10a 0a04    	add.w	r10, r10, #0x4
 8013764: d1ea         	bne	0x801373c <arm_mat_mult_f32+0x8c> @ imm = #-0x2c
;     } while (row > 0U);
 8013766: 3d01         	subs	r5, #0x1
;       pInA = pInA + numColsA;
 8013768: 44be         	add	lr, r7
;     } while (row > 0U);
 801376a: 4484         	add	r12, r0
 801376c: d0dc         	beq	0x8013728 <arm_mat_mult_f32+0x78> @ imm = #-0x48
;       pIn2 = pSrcB->pData;
 801376e: 6873         	ldr	r3, [r6, #0x4]
 8013770: e7e1         	b	0x8013736 <arm_mat_mult_f32+0x86> @ imm = #-0x3e
;         sum = 0.0f;
 8013772: eddf 7a05    	<unknown>
;         pIn2 = pInB + (numColsB - col);
 8013776: 4653         	mov	r3, r10
;       } while (col > 0U);
 8013778: f10a 0a04    	add.w	r10, r10, #0x4
;         *px++ = sum;
 801377c: ece9 7a01    	<unknown>
;       } while (col > 0U);
 8013780: 45e1         	cmp	r9, r12
 8013782: d1db         	bne	0x801373c <arm_mat_mult_f32+0x8c> @ imm = #-0x4a
 8013784: e7ef         	b	0x8013766 <arm_mat_mult_f32+0xb6> @ imm = #-0x22
 8013786: bf00         	nop

08013788 <$d>:
 8013788: 00 00 00 00  	.word	0x00000000

0801378c <arm_mat_sub_f32>:
; {
 801378c: b410         	push	{r4}
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 801378e: 8803         	ldrh	r3, [r0]
 8013790: f8b0 c002    	ldrh.w	r12, [r0, #0x2]
;   float32_t *pInB = pSrcB->pData;                /* input data matrix pointer B */
 8013794: 684c         	ldr	r4, [r1, #0x4]
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 8013796: fb0c f303    	mul	r3, r12, r3
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 801379a: 6851         	ldr	r1, [r2, #0x4]
;   float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A */
 801379c: 6842         	ldr	r2, [r0, #0x4]
;     while (blkCnt > 0U)
 801379e: b14b         	cbz	r3, 0x80137b4 <arm_mat_sub_f32+0x28> @ imm = #0x12
;       *pOut++ = (*pInA++) - (*pInB++);
 80137a0: ecf2 7a01    	<unknown>
;     while (blkCnt > 0U)
 80137a4: 3b01         	subs	r3, #0x1
;       *pOut++ = (*pInA++) - (*pInB++);
 80137a6: ecb4 7a01    	<unknown>
 80137aa: ee77 7ac7    	<unknown>
 80137ae: ece1 7a01    	<unknown>
;     while (blkCnt > 0U)
 80137b2: d1f5         	bne	0x80137a0 <arm_mat_sub_f32+0x14> @ imm = #-0x16
; }
 80137b4: 2000         	movs	r0, #0x0
 80137b6: f85d 4b04    	ldr	r4, [sp], #4
 80137ba: 4770         	bx	lr

080137bc <arm_mat_trans_f32>:
; {
 80137bc: b5f0         	push	{r4, r5, r6, r7, lr}
;       col = nCols;
 80137be: 8845         	ldrh	r5, [r0, #0x2]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 80137c0: 684b         	ldr	r3, [r1, #0x4]
;   uint16_t nRows = pSrc->numRows;                /* number of rows */
 80137c2: 8802         	ldrh	r2, [r0]
;   float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
 80137c4: 6844         	ldr	r4, [r0, #0x4]
;   uint32_t col, row = nRows, i = 0U;             /* Loop counters */
 80137c6: b1b5         	cbz	r5, 0x80137f6 <arm_mat_trans_f32+0x3a> @ imm = #0x2c
 80137c8: ea4f 0c82    	lsl.w	r12, r2, #0x2
 80137cc: 2a01         	cmp	r2, #0x1
 80137ce: 469e         	mov	lr, r3
 80137d0: ea4f 0685    	lsl.w	r6, r5, #0x2
 80137d4: eb03 070c    	add.w	r7, r3, r12
 80137d8: d114         	bne	0x8013804 <arm_mat_trans_f32+0x48> @ imm = #0x28
;       px = pOut + i;
 80137da: 4672         	mov	r2, lr
;       col = nCols;
 80137dc: 462b         	mov	r3, r5
;       px = pOut + i;
 80137de: 4621         	mov	r1, r4
;         *px = *pIn++;
 80137e0: f851 0b04    	ldr	r0, [r1], #4
;       while (col > 0U)
 80137e4: 3b01         	subs	r3, #0x1
;         *px = *pIn++;
 80137e6: 6010         	str	r0, [r2]
;         px += nRows;
 80137e8: 4462         	add	r2, r12
;       while (col > 0U)
 80137ea: d1f9         	bne	0x80137e0 <arm_mat_trans_f32+0x24> @ imm = #-0xe
;     } while (row > 0U);          /* row loop end */
 80137ec: f10e 0e04    	add.w	lr, lr, #0x4
;         *px = *pIn++;
 80137f0: 4434         	add	r4, r6
;     } while (row > 0U);          /* row loop end */
 80137f2: 45be         	cmp	lr, r7
 80137f4: d1f1         	bne	0x80137da <arm_mat_trans_f32+0x1e> @ imm = #-0x1e
; }
 80137f6: 2000         	movs	r0, #0x0
 80137f8: bdf0         	pop	{r4, r5, r6, r7, pc}
;     } while (row > 0U);          /* row loop end */
 80137fa: f10e 0e04    	add.w	lr, lr, #0x4
;         *px = *pIn++;
 80137fe: 4434         	add	r4, r6
;     } while (row > 0U);          /* row loop end */
 8013800: 45be         	cmp	lr, r7
 8013802: d0f8         	beq	0x80137f6 <arm_mat_trans_f32+0x3a> @ imm = #-0x10
;       px = pOut + i;
 8013804: 4672         	mov	r2, lr
;       col = nCols;
 8013806: 462b         	mov	r3, r5
;       px = pOut + i;
 8013808: 4621         	mov	r1, r4
;         *px = *pIn++;
 801380a: f851 0b04    	ldr	r0, [r1], #4
;       while (col > 0U)
 801380e: 3b01         	subs	r3, #0x1
;         *px = *pIn++;
 8013810: 6010         	str	r0, [r2]
;         px += nRows;
 8013812: 4462         	add	r2, r12
;       while (col > 0U)
 8013814: d1f9         	bne	0x801380a <arm_mat_trans_f32+0x4e> @ imm = #-0xe
 8013816: e7f0         	b	0x80137fa <arm_mat_trans_f32+0x3e> @ imm = #-0x20

08013818 <LL_DMA_ConfigTransfer>:
; {
 8013818: b480         	push	{r7}
 801381a: b087         	sub	sp, #0x1c
 801381c: af00         	add	r7, sp, #0x0
 801381e: 60f8         	str	r0, [r7, #0xc]
 8013820: 60b9         	str	r1, [r7, #0x8]
 8013822: 607a         	str	r2, [r7, #0x4]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 8013824: 68fb         	ldr	r3, [r7, #0xc]
 8013826: 617b         	str	r3, [r7, #0x14]
;   MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR,
 8013828: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8013860 <LL_DMA_ConfigTransfer+0x48>
 801382a: 68bb         	ldr	r3, [r7, #0x8]
 801382c: 4413         	add	r3, r2
 801382e: 781b         	ldrb	r3, [r3]
 8013830: 461a         	mov	r2, r3
 8013832: 697b         	ldr	r3, [r7, #0x14]
 8013834: 4413         	add	r3, r2
 8013836: 681a         	ldr	r2, [r3]
 8013838: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8013864 <LL_DMA_ConfigTransfer+0x4c>
 801383a: 4013         	ands	r3, r2
 801383c: 4908         	ldr	r1, [pc, #0x20]         @ 0x8013860 <LL_DMA_ConfigTransfer+0x48>
 801383e: 68ba         	ldr	r2, [r7, #0x8]
 8013840: 440a         	add	r2, r1
 8013842: 7812         	ldrb	r2, [r2]
 8013844: 4611         	mov	r1, r2
 8013846: 697a         	ldr	r2, [r7, #0x14]
 8013848: 440a         	add	r2, r1
 801384a: 4611         	mov	r1, r2
 801384c: 687a         	ldr	r2, [r7, #0x4]
 801384e: 4313         	orrs	r3, r2
 8013850: 600b         	str	r3, [r1]
; }
 8013852: bf00         	nop
 8013854: 371c         	adds	r7, #0x1c
 8013856: 46bd         	mov	sp, r7
 8013858: f85d 7b04    	ldr	r7, [sp], #4
 801385c: 4770         	bx	lr
 801385e: bf00         	nop

08013860 <$d>:
 8013860: dc e5 02 08  	.word	0x0802e5dc
 8013864: 1f 80 f0 ff  	.word	0xfff0801f

08013868 <LL_DMA_SetDataLength>:
; {
 8013868: b480         	push	{r7}
 801386a: b087         	sub	sp, #0x1c
 801386c: af00         	add	r7, sp, #0x0
 801386e: 60f8         	str	r0, [r7, #0xc]
 8013870: 60b9         	str	r1, [r7, #0x8]
 8013872: 607a         	str	r2, [r7, #0x4]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 8013874: 68fb         	ldr	r3, [r7, #0xc]
 8013876: 617b         	str	r3, [r7, #0x14]
;   MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->NDTR, DMA_SxNDT, NbData);
 8013878: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x80138b0 <LL_DMA_SetDataLength+0x48>
 801387a: 68bb         	ldr	r3, [r7, #0x8]
 801387c: 4413         	add	r3, r2
 801387e: 781b         	ldrb	r3, [r3]
 8013880: 461a         	mov	r2, r3
 8013882: 697b         	ldr	r3, [r7, #0x14]
 8013884: 4413         	add	r3, r2
 8013886: 685a         	ldr	r2, [r3, #0x4]
 8013888: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80138b4 <LL_DMA_SetDataLength+0x4c>
 801388a: 4013         	ands	r3, r2
 801388c: 4908         	ldr	r1, [pc, #0x20]         @ 0x80138b0 <LL_DMA_SetDataLength+0x48>
 801388e: 68ba         	ldr	r2, [r7, #0x8]
 8013890: 440a         	add	r2, r1
 8013892: 7812         	ldrb	r2, [r2]
 8013894: 4611         	mov	r1, r2
 8013896: 697a         	ldr	r2, [r7, #0x14]
 8013898: 440a         	add	r2, r1
 801389a: 4611         	mov	r1, r2
 801389c: 687a         	ldr	r2, [r7, #0x4]
 801389e: 4313         	orrs	r3, r2
 80138a0: 604b         	str	r3, [r1, #0x4]
; }
 80138a2: bf00         	nop
 80138a4: 371c         	adds	r7, #0x1c
 80138a6: 46bd         	mov	sp, r7
 80138a8: f85d 7b04    	ldr	r7, [sp], #4
 80138ac: 4770         	bx	lr
 80138ae: bf00         	nop

080138b0 <$d>:
 80138b0: dc e5 02 08  	.word	0x0802e5dc
 80138b4: 00 00 ff ff  	.word	0xffff0000

080138b8 <LL_DMA_SetPeriphRequest>:
; {
 80138b8: b480         	push	{r7}
 80138ba: b085         	sub	sp, #0x14
 80138bc: af00         	add	r7, sp, #0x0
 80138be: 60f8         	str	r0, [r7, #0xc]
 80138c0: 60b9         	str	r1, [r7, #0x8]
 80138c2: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMAMUX_Channel_TypeDef *)(uint32_t)((uint32_t)DMAMUX1_Channel0 + (DMAMUX_CCR_SIZE * (Stream)) + (uint32_t)(DMAMUX_CCR_SIZE * LL_DMA_INSTANCE_TO_DMAMUX_CHANNEL(DMAx))))->CCR, DMAMUX_CxCR_DMAREQ_ID, Request);
 80138c4: 68ba         	ldr	r2, [r7, #0x8]
 80138c6: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8013910 <LL_DMA_SetPeriphRequest+0x58>
 80138c8: 4413         	add	r3, r2
 80138ca: 009b         	lsls	r3, r3, #0x2
 80138cc: 68fa         	ldr	r2, [r7, #0xc]
 80138ce: 4911         	ldr	r1, [pc, #0x44]         @ 0x8013914 <LL_DMA_SetPeriphRequest+0x5c>
 80138d0: 428a         	cmp	r2, r1
 80138d2: d101         	bne	0x80138d8 <LL_DMA_SetPeriphRequest+0x20> @ imm = #0x2
 80138d4: 2200         	movs	r2, #0x0
 80138d6: e000         	b	0x80138da <LL_DMA_SetPeriphRequest+0x22> @ imm = #0x0
 80138d8: 2220         	movs	r2, #0x20
 80138da: 4413         	add	r3, r2
 80138dc: 681b         	ldr	r3, [r3]
 80138de: f023 02ff    	bic	r2, r3, #0xff
 80138e2: 68b9         	ldr	r1, [r7, #0x8]
 80138e4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8013910 <LL_DMA_SetPeriphRequest+0x58>
 80138e6: 440b         	add	r3, r1
 80138e8: 009b         	lsls	r3, r3, #0x2
 80138ea: 68f9         	ldr	r1, [r7, #0xc]
 80138ec: 4809         	ldr	r0, [pc, #0x24]         @ 0x8013914 <LL_DMA_SetPeriphRequest+0x5c>
 80138ee: 4281         	cmp	r1, r0
 80138f0: d101         	bne	0x80138f6 <LL_DMA_SetPeriphRequest+0x3e> @ imm = #0x2
 80138f2: 2100         	movs	r1, #0x0
 80138f4: e000         	b	0x80138f8 <LL_DMA_SetPeriphRequest+0x40> @ imm = #0x0
 80138f6: 2120         	movs	r1, #0x20
 80138f8: 440b         	add	r3, r1
 80138fa: 4619         	mov	r1, r3
 80138fc: 687b         	ldr	r3, [r7, #0x4]
 80138fe: 4313         	orrs	r3, r2
 8013900: 600b         	str	r3, [r1]
; }
 8013902: bf00         	nop
 8013904: 3714         	adds	r7, #0x14
 8013906: 46bd         	mov	sp, r7
 8013908: f85d 7b04    	ldr	r7, [sp], #4
 801390c: 4770         	bx	lr
 801390e: bf00         	nop

08013910 <$d>:
 8013910: 00 82 00 10  	.word	0x10008200
 8013914: 00 00 02 40  	.word	0x40020000

08013918 <LL_DMA_SetMemoryBurstxfer>:
; {
 8013918: b480         	push	{r7}
 801391a: b087         	sub	sp, #0x1c
 801391c: af00         	add	r7, sp, #0x0
 801391e: 60f8         	str	r0, [r7, #0xc]
 8013920: 60b9         	str	r1, [r7, #0x8]
 8013922: 607a         	str	r2, [r7, #0x4]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 8013924: 68fb         	ldr	r3, [r7, #0xc]
 8013926: 617b         	str	r3, [r7, #0x14]
;   MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_MBURST, Mburst);
 8013928: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8013960 <LL_DMA_SetMemoryBurstxfer+0x48>
 801392a: 68bb         	ldr	r3, [r7, #0x8]
 801392c: 4413         	add	r3, r2
 801392e: 781b         	ldrb	r3, [r3]
 8013930: 461a         	mov	r2, r3
 8013932: 697b         	ldr	r3, [r7, #0x14]
 8013934: 4413         	add	r3, r2
 8013936: 681b         	ldr	r3, [r3]
 8013938: f023 72c0    	bic	r2, r3, #0x1800000
 801393c: 4908         	ldr	r1, [pc, #0x20]         @ 0x8013960 <LL_DMA_SetMemoryBurstxfer+0x48>
 801393e: 68bb         	ldr	r3, [r7, #0x8]
 8013940: 440b         	add	r3, r1
 8013942: 781b         	ldrb	r3, [r3]
 8013944: 4619         	mov	r1, r3
 8013946: 697b         	ldr	r3, [r7, #0x14]
 8013948: 440b         	add	r3, r1
 801394a: 4619         	mov	r1, r3
 801394c: 687b         	ldr	r3, [r7, #0x4]
 801394e: 4313         	orrs	r3, r2
 8013950: 600b         	str	r3, [r1]
; }
 8013952: bf00         	nop
 8013954: 371c         	adds	r7, #0x1c
 8013956: 46bd         	mov	sp, r7
 8013958: f85d 7b04    	ldr	r7, [sp], #4
 801395c: 4770         	bx	lr
 801395e: bf00         	nop

08013960 <$d>:
 8013960: dc e5 02 08  	.word	0x0802e5dc

08013964 <LL_DMA_SetPeriphBurstxfer>:
; {
 8013964: b480         	push	{r7}
 8013966: b087         	sub	sp, #0x1c
 8013968: af00         	add	r7, sp, #0x0
 801396a: 60f8         	str	r0, [r7, #0xc]
 801396c: 60b9         	str	r1, [r7, #0x8]
 801396e: 607a         	str	r2, [r7, #0x4]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 8013970: 68fb         	ldr	r3, [r7, #0xc]
 8013972: 617b         	str	r3, [r7, #0x14]
;   MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->CR, DMA_SxCR_PBURST, Pburst);
 8013974: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x80139ac <LL_DMA_SetPeriphBurstxfer+0x48>
 8013976: 68bb         	ldr	r3, [r7, #0x8]
 8013978: 4413         	add	r3, r2
 801397a: 781b         	ldrb	r3, [r3]
 801397c: 461a         	mov	r2, r3
 801397e: 697b         	ldr	r3, [r7, #0x14]
 8013980: 4413         	add	r3, r2
 8013982: 681b         	ldr	r3, [r3]
 8013984: f423 02c0    	bic	r2, r3, #0x600000
 8013988: 4908         	ldr	r1, [pc, #0x20]         @ 0x80139ac <LL_DMA_SetPeriphBurstxfer+0x48>
 801398a: 68bb         	ldr	r3, [r7, #0x8]
 801398c: 440b         	add	r3, r1
 801398e: 781b         	ldrb	r3, [r3]
 8013990: 4619         	mov	r1, r3
 8013992: 697b         	ldr	r3, [r7, #0x14]
 8013994: 440b         	add	r3, r1
 8013996: 4619         	mov	r1, r3
 8013998: 687b         	ldr	r3, [r7, #0x4]
 801399a: 4313         	orrs	r3, r2
 801399c: 600b         	str	r3, [r1]
; }
 801399e: bf00         	nop
 80139a0: 371c         	adds	r7, #0x1c
 80139a2: 46bd         	mov	sp, r7
 80139a4: f85d 7b04    	ldr	r7, [sp], #4
 80139a8: 4770         	bx	lr
 80139aa: bf00         	nop

080139ac <$d>:
 80139ac: dc e5 02 08  	.word	0x0802e5dc

080139b0 <LL_DMA_ConfigFifo>:
; {
 80139b0: b480         	push	{r7}
 80139b2: b087         	sub	sp, #0x1c
 80139b4: af00         	add	r7, sp, #0x0
 80139b6: 60f8         	str	r0, [r7, #0xc]
 80139b8: 60b9         	str	r1, [r7, #0x8]
 80139ba: 607a         	str	r2, [r7, #0x4]
 80139bc: 603b         	str	r3, [r7]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 80139be: 68fb         	ldr	r3, [r7, #0xc]
 80139c0: 617b         	str	r3, [r7, #0x14]
;   MODIFY_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->FCR, DMA_SxFCR_FTH | DMA_SxFCR_DMDIS, FifoMode | FifoThreshold);
 80139c2: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x80139fc <LL_DMA_ConfigFifo+0x4c>
 80139c4: 68bb         	ldr	r3, [r7, #0x8]
 80139c6: 4413         	add	r3, r2
 80139c8: 781b         	ldrb	r3, [r3]
 80139ca: 461a         	mov	r2, r3
 80139cc: 697b         	ldr	r3, [r7, #0x14]
 80139ce: 4413         	add	r3, r2
 80139d0: 695b         	ldr	r3, [r3, #0x14]
 80139d2: f023 0207    	bic	r2, r3, #0x7
 80139d6: 6879         	ldr	r1, [r7, #0x4]
 80139d8: 683b         	ldr	r3, [r7]
 80139da: 430b         	orrs	r3, r1
 80139dc: 4807         	ldr	r0, [pc, #0x1c]         @ 0x80139fc <LL_DMA_ConfigFifo+0x4c>
 80139de: 68b9         	ldr	r1, [r7, #0x8]
 80139e0: 4401         	add	r1, r0
 80139e2: 7809         	ldrb	r1, [r1]
 80139e4: 4608         	mov	r0, r1
 80139e6: 6979         	ldr	r1, [r7, #0x14]
 80139e8: 4401         	add	r1, r0
 80139ea: 4313         	orrs	r3, r2
 80139ec: 614b         	str	r3, [r1, #0x14]
; }
 80139ee: bf00         	nop
 80139f0: 371c         	adds	r7, #0x1c
 80139f2: 46bd         	mov	sp, r7
 80139f4: f85d 7b04    	ldr	r7, [sp], #4
 80139f8: 4770         	bx	lr
 80139fa: bf00         	nop

080139fc <$d>:
 80139fc: dc e5 02 08  	.word	0x0802e5dc

08013a00 <LL_DMA_SetMemoryAddress>:
; {
 8013a00: b480         	push	{r7}
 8013a02: b087         	sub	sp, #0x1c
 8013a04: af00         	add	r7, sp, #0x0
 8013a06: 60f8         	str	r0, [r7, #0xc]
 8013a08: 60b9         	str	r1, [r7, #0x8]
 8013a0a: 607a         	str	r2, [r7, #0x4]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 8013a0c: 68fb         	ldr	r3, [r7, #0xc]
 8013a0e: 617b         	str	r3, [r7, #0x14]
;   WRITE_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->M0AR, MemoryAddress);
 8013a10: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8013a30 <LL_DMA_SetMemoryAddress+0x30>
 8013a12: 68bb         	ldr	r3, [r7, #0x8]
 8013a14: 4413         	add	r3, r2
 8013a16: 781b         	ldrb	r3, [r3]
 8013a18: 461a         	mov	r2, r3
 8013a1a: 697b         	ldr	r3, [r7, #0x14]
 8013a1c: 4413         	add	r3, r2
 8013a1e: 461a         	mov	r2, r3
 8013a20: 687b         	ldr	r3, [r7, #0x4]
 8013a22: 60d3         	str	r3, [r2, #0xc]
; }
 8013a24: bf00         	nop
 8013a26: 371c         	adds	r7, #0x1c
 8013a28: 46bd         	mov	sp, r7
 8013a2a: f85d 7b04    	ldr	r7, [sp], #4
 8013a2e: 4770         	bx	lr

08013a30 <$d>:
 8013a30: dc e5 02 08  	.word	0x0802e5dc

08013a34 <LL_DMA_SetPeriphAddress>:
; {
 8013a34: b480         	push	{r7}
 8013a36: b087         	sub	sp, #0x1c
 8013a38: af00         	add	r7, sp, #0x0
 8013a3a: 60f8         	str	r0, [r7, #0xc]
 8013a3c: 60b9         	str	r1, [r7, #0x8]
 8013a3e: 607a         	str	r2, [r7, #0x4]
;   uint32_t dma_base_addr = (uint32_t)DMAx;
 8013a40: 68fb         	ldr	r3, [r7, #0xc]
 8013a42: 617b         	str	r3, [r7, #0x14]
;   WRITE_REG(((DMA_Stream_TypeDef *)(dma_base_addr + LL_DMA_STR_OFFSET_TAB[Stream]))->PAR, PeriphAddress);
 8013a44: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8013a64 <LL_DMA_SetPeriphAddress+0x30>
 8013a46: 68bb         	ldr	r3, [r7, #0x8]
 8013a48: 4413         	add	r3, r2
 8013a4a: 781b         	ldrb	r3, [r3]
 8013a4c: 461a         	mov	r2, r3
 8013a4e: 697b         	ldr	r3, [r7, #0x14]
 8013a50: 4413         	add	r3, r2
 8013a52: 461a         	mov	r2, r3
 8013a54: 687b         	ldr	r3, [r7, #0x4]
 8013a56: 6093         	str	r3, [r2, #0x8]
; }
 8013a58: bf00         	nop
 8013a5a: 371c         	adds	r7, #0x1c
 8013a5c: 46bd         	mov	sp, r7
 8013a5e: f85d 7b04    	ldr	r7, [sp], #4
 8013a62: 4770         	bx	lr

08013a64 <$d>:
 8013a64: dc e5 02 08  	.word	0x0802e5dc

08013a68 <LL_RCC_HSE_IsReady>:
; {
 8013a68: b480         	push	{r7}
 8013a6a: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 8013a6c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8013a8c <LL_RCC_HSE_IsReady+0x24>
 8013a6e: 681b         	ldr	r3, [r3]
 8013a70: f403 3300    	and	r3, r3, #0x20000
 8013a74: f5b3 3f00    	cmp.w	r3, #0x20000
 8013a78: d101         	bne	0x8013a7e <LL_RCC_HSE_IsReady+0x16> @ imm = #0x2
 8013a7a: 2301         	movs	r3, #0x1
 8013a7c: e000         	b	0x8013a80 <LL_RCC_HSE_IsReady+0x18> @ imm = #0x0
 8013a7e: 2300         	movs	r3, #0x0
; }
 8013a80: 4618         	mov	r0, r3
 8013a82: 46bd         	mov	sp, r7
 8013a84: f85d 7b04    	ldr	r7, [sp], #4
 8013a88: 4770         	bx	lr
 8013a8a: bf00         	nop

08013a8c <$d>:
 8013a8c: 00 44 02 58  	.word	0x58024400

08013a90 <LL_RCC_HSI_IsReady>:
; {
 8013a90: b480         	push	{r7}
 8013a92: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8013a94: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8013ab0 <LL_RCC_HSI_IsReady+0x20>
 8013a96: 681b         	ldr	r3, [r3]
 8013a98: f003 0304    	and	r3, r3, #0x4
 8013a9c: 2b04         	cmp	r3, #0x4
 8013a9e: d101         	bne	0x8013aa4 <LL_RCC_HSI_IsReady+0x14> @ imm = #0x2
 8013aa0: 2301         	movs	r3, #0x1
 8013aa2: e000         	b	0x8013aa6 <LL_RCC_HSI_IsReady+0x16> @ imm = #0x0
 8013aa4: 2300         	movs	r3, #0x0
; }
 8013aa6: 4618         	mov	r0, r3
 8013aa8: 46bd         	mov	sp, r7
 8013aaa: f85d 7b04    	ldr	r7, [sp], #4
 8013aae: 4770         	bx	lr

08013ab0 <$d>:
 8013ab0: 00 44 02 58  	.word	0x58024400

08013ab4 <LL_RCC_HSI_GetDivider>:
; {
 8013ab4: b480         	push	{r7}
 8013ab6: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSIDIV));
 8013ab8: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8013acc <LL_RCC_HSI_GetDivider+0x18>
 8013aba: 681b         	ldr	r3, [r3]
 8013abc: f003 0318    	and	r3, r3, #0x18
; }
 8013ac0: 4618         	mov	r0, r3
 8013ac2: 46bd         	mov	sp, r7
 8013ac4: f85d 7b04    	ldr	r7, [sp], #4
 8013ac8: 4770         	bx	lr
 8013aca: bf00         	nop

08013acc <$d>:
 8013acc: 00 44 02 58  	.word	0x58024400

08013ad0 <LL_RCC_CSI_IsReady>:
; {
 8013ad0: b480         	push	{r7}
 8013ad2: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CR, RCC_CR_CSIRDY) == (RCC_CR_CSIRDY)) ? 1UL : 0UL);
 8013ad4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8013af4 <LL_RCC_CSI_IsReady+0x24>
 8013ad6: 681b         	ldr	r3, [r3]
 8013ad8: f403 7380    	and	r3, r3, #0x100
 8013adc: f5b3 7f80    	cmp.w	r3, #0x100
 8013ae0: d101         	bne	0x8013ae6 <LL_RCC_CSI_IsReady+0x16> @ imm = #0x2
 8013ae2: 2301         	movs	r3, #0x1
 8013ae4: e000         	b	0x8013ae8 <LL_RCC_CSI_IsReady+0x18> @ imm = #0x0
 8013ae6: 2300         	movs	r3, #0x0
; }
 8013ae8: 4618         	mov	r0, r3
 8013aea: 46bd         	mov	sp, r7
 8013aec: f85d 7b04    	ldr	r7, [sp], #4
 8013af0: 4770         	bx	lr
 8013af2: bf00         	nop

08013af4 <$d>:
 8013af4: 00 44 02 58  	.word	0x58024400

08013af8 <LL_RCC_GetFDCANClockSource>:
; {
 8013af8: b480         	push	{r7}
 8013afa: b083         	sub	sp, #0xc
 8013afc: af00         	add	r7, sp, #0x0
 8013afe: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(RCC->D2CCIP1R, RCC_D2CCIP1R_FDCANSEL));
 8013b00: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8013b14 <LL_RCC_GetFDCANClockSource+0x1c>
 8013b02: 6d1b         	ldr	r3, [r3, #0x50]
 8013b04: f003 5340    	and	r3, r3, #0x30000000
; }
 8013b08: 4618         	mov	r0, r3
 8013b0a: 370c         	adds	r7, #0xc
 8013b0c: 46bd         	mov	sp, r7
 8013b0e: f85d 7b04    	ldr	r7, [sp], #4
 8013b12: 4770         	bx	lr

08013b14 <$d>:
 8013b14: 00 44 02 58  	.word	0x58024400

08013b18 <LL_RCC_PLL_GetSource>:
; {
 8013b18: b480         	push	{r7}
 8013b1a: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_PLLSRC));
 8013b1c: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8013b30 <LL_RCC_PLL_GetSource+0x18>
 8013b1e: 6a9b         	ldr	r3, [r3, #0x28]
 8013b20: f003 0303    	and	r3, r3, #0x3
; }
 8013b24: 4618         	mov	r0, r3
 8013b26: 46bd         	mov	sp, r7
 8013b28: f85d 7b04    	ldr	r7, [sp], #4
 8013b2c: 4770         	bx	lr
 8013b2e: bf00         	nop

08013b30 <$d>:
 8013b30: 00 44 02 58  	.word	0x58024400

08013b34 <LL_RCC_PLL1_IsReady>:
; {
 8013b34: b480         	push	{r7}
 8013b36: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == (RCC_CR_PLL1RDY)) ? 1UL : 0UL);
 8013b38: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8013b58 <LL_RCC_PLL1_IsReady+0x24>
 8013b3a: 681b         	ldr	r3, [r3]
 8013b3c: f003 7300    	and	r3, r3, #0x2000000
 8013b40: f1b3 7f00    	cmp.w	r3, #0x2000000
 8013b44: d101         	bne	0x8013b4a <LL_RCC_PLL1_IsReady+0x16> @ imm = #0x2
 8013b46: 2301         	movs	r3, #0x1
 8013b48: e000         	b	0x8013b4c <LL_RCC_PLL1_IsReady+0x18> @ imm = #0x0
 8013b4a: 2300         	movs	r3, #0x0
; }
 8013b4c: 4618         	mov	r0, r3
 8013b4e: 46bd         	mov	sp, r7
 8013b50: f85d 7b04    	ldr	r7, [sp], #4
 8013b54: 4770         	bx	lr
 8013b56: bf00         	nop

08013b58 <$d>:
 8013b58: 00 44 02 58  	.word	0x58024400

08013b5c <LL_RCC_PLL1P_IsEnabled>:
; {
 8013b5c: b480         	push	{r7}
 8013b5e: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP1EN) == RCC_PLLCFGR_DIVP1EN) ? 1UL : 0UL);
 8013b60: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8013b80 <LL_RCC_PLL1P_IsEnabled+0x24>
 8013b62: 6adb         	ldr	r3, [r3, #0x2c]
 8013b64: f403 3380    	and	r3, r3, #0x10000
 8013b68: f5b3 3f80    	cmp.w	r3, #0x10000
 8013b6c: d101         	bne	0x8013b72 <LL_RCC_PLL1P_IsEnabled+0x16> @ imm = #0x2
 8013b6e: 2301         	movs	r3, #0x1
 8013b70: e000         	b	0x8013b74 <LL_RCC_PLL1P_IsEnabled+0x18> @ imm = #0x0
 8013b72: 2300         	movs	r3, #0x0
; }
 8013b74: 4618         	mov	r0, r3
 8013b76: 46bd         	mov	sp, r7
 8013b78: f85d 7b04    	ldr	r7, [sp], #4
 8013b7c: 4770         	bx	lr
 8013b7e: bf00         	nop

08013b80 <$d>:
 8013b80: 00 44 02 58  	.word	0x58024400

08013b84 <LL_RCC_PLL1Q_IsEnabled>:
; {
 8013b84: b480         	push	{r7}
 8013b86: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ1EN) == RCC_PLLCFGR_DIVQ1EN) ? 1UL : 0UL);
 8013b88: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8013ba8 <LL_RCC_PLL1Q_IsEnabled+0x24>
 8013b8a: 6adb         	ldr	r3, [r3, #0x2c]
 8013b8c: f403 3300    	and	r3, r3, #0x20000
 8013b90: f5b3 3f00    	cmp.w	r3, #0x20000
 8013b94: d101         	bne	0x8013b9a <LL_RCC_PLL1Q_IsEnabled+0x16> @ imm = #0x2
 8013b96: 2301         	movs	r3, #0x1
 8013b98: e000         	b	0x8013b9c <LL_RCC_PLL1Q_IsEnabled+0x18> @ imm = #0x0
 8013b9a: 2300         	movs	r3, #0x0
; }
 8013b9c: 4618         	mov	r0, r3
 8013b9e: 46bd         	mov	sp, r7
 8013ba0: f85d 7b04    	ldr	r7, [sp], #4
 8013ba4: 4770         	bx	lr
 8013ba6: bf00         	nop

08013ba8 <$d>:
 8013ba8: 00 44 02 58  	.word	0x58024400

08013bac <LL_RCC_PLL1R_IsEnabled>:
; {
 8013bac: b480         	push	{r7}
 8013bae: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR1EN) == RCC_PLLCFGR_DIVR1EN) ? 1UL : 0UL);
 8013bb0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8013bd0 <LL_RCC_PLL1R_IsEnabled+0x24>
 8013bb2: 6adb         	ldr	r3, [r3, #0x2c]
 8013bb4: f403 2380    	and	r3, r3, #0x40000
 8013bb8: f5b3 2f80    	cmp.w	r3, #0x40000
 8013bbc: d101         	bne	0x8013bc2 <LL_RCC_PLL1R_IsEnabled+0x16> @ imm = #0x2
 8013bbe: 2301         	movs	r3, #0x1
 8013bc0: e000         	b	0x8013bc4 <LL_RCC_PLL1R_IsEnabled+0x18> @ imm = #0x0
 8013bc2: 2300         	movs	r3, #0x0
; }
 8013bc4: 4618         	mov	r0, r3
 8013bc6: 46bd         	mov	sp, r7
 8013bc8: f85d 7b04    	ldr	r7, [sp], #4
 8013bcc: 4770         	bx	lr
 8013bce: bf00         	nop

08013bd0 <$d>:
 8013bd0: 00 44 02 58  	.word	0x58024400

08013bd4 <LL_RCC_PLL1FRACN_IsEnabled>:
; {
 8013bd4: b480         	push	{r7}
 8013bd6: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL1FRACEN) == RCC_PLLCFGR_PLL1FRACEN) ? 1UL : 0UL);
 8013bd8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8013bf4 <LL_RCC_PLL1FRACN_IsEnabled+0x20>
 8013bda: 6adb         	ldr	r3, [r3, #0x2c]
 8013bdc: f003 0301    	and	r3, r3, #0x1
 8013be0: 2b01         	cmp	r3, #0x1
 8013be2: d101         	bne	0x8013be8 <LL_RCC_PLL1FRACN_IsEnabled+0x14> @ imm = #0x2
 8013be4: 2301         	movs	r3, #0x1
 8013be6: e000         	b	0x8013bea <LL_RCC_PLL1FRACN_IsEnabled+0x16> @ imm = #0x0
 8013be8: 2300         	movs	r3, #0x0
; }
 8013bea: 4618         	mov	r0, r3
 8013bec: 46bd         	mov	sp, r7
 8013bee: f85d 7b04    	ldr	r7, [sp], #4
 8013bf2: 4770         	bx	lr

08013bf4 <$d>:
 8013bf4: 00 44 02 58  	.word	0x58024400

08013bf8 <LL_RCC_PLL1_GetN>:
; {
 8013bf8: b480         	push	{r7}
 8013bfa: af00         	add	r7, sp, #0x0
;   return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_N1) >>  RCC_PLL1DIVR_N1_Pos) + 1UL);
 8013bfc: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8013c10 <LL_RCC_PLL1_GetN+0x18>
 8013bfe: 6b1b         	ldr	r3, [r3, #0x30]
 8013c00: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8013c04: 3301         	adds	r3, #0x1
; }
 8013c06: 4618         	mov	r0, r3
 8013c08: 46bd         	mov	sp, r7
 8013c0a: f85d 7b04    	ldr	r7, [sp], #4
 8013c0e: 4770         	bx	lr

08013c10 <$d>:
 8013c10: 00 44 02 58  	.word	0x58024400

08013c14 <LL_RCC_PLL1_GetM>:
; {
 8013c14: b480         	push	{r7}
 8013c16: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM1) >>  RCC_PLLCKSELR_DIVM1_Pos);
 8013c18: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8013c2c <LL_RCC_PLL1_GetM+0x18>
 8013c1a: 6a9b         	ldr	r3, [r3, #0x28]
 8013c1c: 091b         	lsrs	r3, r3, #0x4
 8013c1e: f003 033f    	and	r3, r3, #0x3f
; }
 8013c22: 4618         	mov	r0, r3
 8013c24: 46bd         	mov	sp, r7
 8013c26: f85d 7b04    	ldr	r7, [sp], #4
 8013c2a: 4770         	bx	lr

08013c2c <$d>:
 8013c2c: 00 44 02 58  	.word	0x58024400

08013c30 <LL_RCC_PLL1_GetP>:
; {
 8013c30: b480         	push	{r7}
 8013c32: af00         	add	r7, sp, #0x0
;   return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_P1) >>  RCC_PLL1DIVR_P1_Pos) + 1UL);
 8013c34: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8013c4c <LL_RCC_PLL1_GetP+0x1c>
 8013c36: 6b1b         	ldr	r3, [r3, #0x30]
 8013c38: 0a5b         	lsrs	r3, r3, #0x9
 8013c3a: f003 037f    	and	r3, r3, #0x7f
 8013c3e: 3301         	adds	r3, #0x1
; }
 8013c40: 4618         	mov	r0, r3
 8013c42: 46bd         	mov	sp, r7
 8013c44: f85d 7b04    	ldr	r7, [sp], #4
 8013c48: 4770         	bx	lr
 8013c4a: bf00         	nop

08013c4c <$d>:
 8013c4c: 00 44 02 58  	.word	0x58024400

08013c50 <LL_RCC_PLL1_GetQ>:
; {
 8013c50: b480         	push	{r7}
 8013c52: af00         	add	r7, sp, #0x0
;   return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_Q1) >>  RCC_PLL1DIVR_Q1_Pos) + 1UL);
 8013c54: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8013c6c <LL_RCC_PLL1_GetQ+0x1c>
 8013c56: 6b1b         	ldr	r3, [r3, #0x30]
 8013c58: 0c1b         	lsrs	r3, r3, #0x10
 8013c5a: f003 037f    	and	r3, r3, #0x7f
 8013c5e: 3301         	adds	r3, #0x1
; }
 8013c60: 4618         	mov	r0, r3
 8013c62: 46bd         	mov	sp, r7
 8013c64: f85d 7b04    	ldr	r7, [sp], #4
 8013c68: 4770         	bx	lr
 8013c6a: bf00         	nop

08013c6c <$d>:
 8013c6c: 00 44 02 58  	.word	0x58024400

08013c70 <LL_RCC_PLL1_GetR>:
; {
 8013c70: b480         	push	{r7}
 8013c72: af00         	add	r7, sp, #0x0
;   return (uint32_t)((READ_BIT(RCC->PLL1DIVR, RCC_PLL1DIVR_R1) >>  RCC_PLL1DIVR_R1_Pos) + 1UL);
 8013c74: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8013c8c <LL_RCC_PLL1_GetR+0x1c>
 8013c76: 6b1b         	ldr	r3, [r3, #0x30]
 8013c78: 0e1b         	lsrs	r3, r3, #0x18
 8013c7a: f003 037f    	and	r3, r3, #0x7f
 8013c7e: 3301         	adds	r3, #0x1
; }
 8013c80: 4618         	mov	r0, r3
 8013c82: 46bd         	mov	sp, r7
 8013c84: f85d 7b04    	ldr	r7, [sp], #4
 8013c88: 4770         	bx	lr
 8013c8a: bf00         	nop

08013c8c <$d>:
 8013c8c: 00 44 02 58  	.word	0x58024400

08013c90 <LL_RCC_PLL1_GetFRACN>:
; {
 8013c90: b480         	push	{r7}
 8013c92: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_FRACN1) >>  RCC_PLL1FRACR_FRACN1_Pos);
 8013c94: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8013ca8 <LL_RCC_PLL1_GetFRACN+0x18>
 8013c96: 6b5b         	ldr	r3, [r3, #0x34]
 8013c98: 08db         	lsrs	r3, r3, #0x3
 8013c9a: f3c3 030c    	ubfx	r3, r3, #0x0, #0xd
; }
 8013c9e: 4618         	mov	r0, r3
 8013ca0: 46bd         	mov	sp, r7
 8013ca2: f85d 7b04    	ldr	r7, [sp], #4
 8013ca6: 4770         	bx	lr

08013ca8 <$d>:
 8013ca8: 00 44 02 58  	.word	0x58024400

08013cac <LL_RCC_PLL2_IsReady>:
; {
 8013cac: b480         	push	{r7}
 8013cae: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->CR, RCC_CR_PLL2RDY) == (RCC_CR_PLL2RDY)) ? 1UL : 0UL);
 8013cb0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8013cd0 <LL_RCC_PLL2_IsReady+0x24>
 8013cb2: 681b         	ldr	r3, [r3]
 8013cb4: f003 6300    	and	r3, r3, #0x8000000
 8013cb8: f1b3 6f00    	cmp.w	r3, #0x8000000
 8013cbc: d101         	bne	0x8013cc2 <LL_RCC_PLL2_IsReady+0x16> @ imm = #0x2
 8013cbe: 2301         	movs	r3, #0x1
 8013cc0: e000         	b	0x8013cc4 <LL_RCC_PLL2_IsReady+0x18> @ imm = #0x0
 8013cc2: 2300         	movs	r3, #0x0
; }
 8013cc4: 4618         	mov	r0, r3
 8013cc6: 46bd         	mov	sp, r7
 8013cc8: f85d 7b04    	ldr	r7, [sp], #4
 8013ccc: 4770         	bx	lr
 8013cce: bf00         	nop

08013cd0 <$d>:
 8013cd0: 00 44 02 58  	.word	0x58024400

08013cd4 <LL_RCC_PLL2P_IsEnabled>:
; {
 8013cd4: b480         	push	{r7}
 8013cd6: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVP2EN) == RCC_PLLCFGR_DIVP2EN) ? 1UL : 0UL);
 8013cd8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8013cf8 <LL_RCC_PLL2P_IsEnabled+0x24>
 8013cda: 6adb         	ldr	r3, [r3, #0x2c]
 8013cdc: f403 2300    	and	r3, r3, #0x80000
 8013ce0: f5b3 2f00    	cmp.w	r3, #0x80000
 8013ce4: d101         	bne	0x8013cea <LL_RCC_PLL2P_IsEnabled+0x16> @ imm = #0x2
 8013ce6: 2301         	movs	r3, #0x1
 8013ce8: e000         	b	0x8013cec <LL_RCC_PLL2P_IsEnabled+0x18> @ imm = #0x0
 8013cea: 2300         	movs	r3, #0x0
; }
 8013cec: 4618         	mov	r0, r3
 8013cee: 46bd         	mov	sp, r7
 8013cf0: f85d 7b04    	ldr	r7, [sp], #4
 8013cf4: 4770         	bx	lr
 8013cf6: bf00         	nop

08013cf8 <$d>:
 8013cf8: 00 44 02 58  	.word	0x58024400

08013cfc <LL_RCC_PLL2Q_IsEnabled>:
; {
 8013cfc: b480         	push	{r7}
 8013cfe: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVQ2EN) == RCC_PLLCFGR_DIVQ2EN) ? 1UL : 0UL);
 8013d00: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8013d20 <LL_RCC_PLL2Q_IsEnabled+0x24>
 8013d02: 6adb         	ldr	r3, [r3, #0x2c]
 8013d04: f403 1380    	and	r3, r3, #0x100000
 8013d08: f5b3 1f80    	cmp.w	r3, #0x100000
 8013d0c: d101         	bne	0x8013d12 <LL_RCC_PLL2Q_IsEnabled+0x16> @ imm = #0x2
 8013d0e: 2301         	movs	r3, #0x1
 8013d10: e000         	b	0x8013d14 <LL_RCC_PLL2Q_IsEnabled+0x18> @ imm = #0x0
 8013d12: 2300         	movs	r3, #0x0
; }
 8013d14: 4618         	mov	r0, r3
 8013d16: 46bd         	mov	sp, r7
 8013d18: f85d 7b04    	ldr	r7, [sp], #4
 8013d1c: 4770         	bx	lr
 8013d1e: bf00         	nop

08013d20 <$d>:
 8013d20: 00 44 02 58  	.word	0x58024400

08013d24 <LL_RCC_PLL2R_IsEnabled>:
; {
 8013d24: b480         	push	{r7}
 8013d26: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_DIVR2EN) == RCC_PLLCFGR_DIVR2EN) ? 1UL : 0UL);
 8013d28: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8013d48 <LL_RCC_PLL2R_IsEnabled+0x24>
 8013d2a: 6adb         	ldr	r3, [r3, #0x2c]
 8013d2c: f403 1300    	and	r3, r3, #0x200000
 8013d30: f5b3 1f00    	cmp.w	r3, #0x200000
 8013d34: d101         	bne	0x8013d3a <LL_RCC_PLL2R_IsEnabled+0x16> @ imm = #0x2
 8013d36: 2301         	movs	r3, #0x1
 8013d38: e000         	b	0x8013d3c <LL_RCC_PLL2R_IsEnabled+0x18> @ imm = #0x0
 8013d3a: 2300         	movs	r3, #0x0
; }
 8013d3c: 4618         	mov	r0, r3
 8013d3e: 46bd         	mov	sp, r7
 8013d40: f85d 7b04    	ldr	r7, [sp], #4
 8013d44: 4770         	bx	lr
 8013d46: bf00         	nop

08013d48 <$d>:
 8013d48: 00 44 02 58  	.word	0x58024400

08013d4c <LL_RCC_PLL2FRACN_IsEnabled>:
; {
 8013d4c: b480         	push	{r7}
 8013d4e: af00         	add	r7, sp, #0x0
;   return ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL2FRACEN) == RCC_PLLCFGR_PLL2FRACEN) ? 1UL : 0UL);
 8013d50: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8013d6c <LL_RCC_PLL2FRACN_IsEnabled+0x20>
 8013d52: 6adb         	ldr	r3, [r3, #0x2c]
 8013d54: f003 0310    	and	r3, r3, #0x10
 8013d58: 2b10         	cmp	r3, #0x10
 8013d5a: d101         	bne	0x8013d60 <LL_RCC_PLL2FRACN_IsEnabled+0x14> @ imm = #0x2
 8013d5c: 2301         	movs	r3, #0x1
 8013d5e: e000         	b	0x8013d62 <LL_RCC_PLL2FRACN_IsEnabled+0x16> @ imm = #0x0
 8013d60: 2300         	movs	r3, #0x0
; }
 8013d62: 4618         	mov	r0, r3
 8013d64: 46bd         	mov	sp, r7
 8013d66: f85d 7b04    	ldr	r7, [sp], #4
 8013d6a: 4770         	bx	lr

08013d6c <$d>:
 8013d6c: 00 44 02 58  	.word	0x58024400

08013d70 <LL_RCC_PLL2_GetN>:
; {
 8013d70: b480         	push	{r7}
 8013d72: af00         	add	r7, sp, #0x0
;   return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_N2) >>  RCC_PLL2DIVR_N2_Pos) + 1UL);
 8013d74: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8013d88 <LL_RCC_PLL2_GetN+0x18>
 8013d76: 6b9b         	ldr	r3, [r3, #0x38]
 8013d78: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8013d7c: 3301         	adds	r3, #0x1
; }
 8013d7e: 4618         	mov	r0, r3
 8013d80: 46bd         	mov	sp, r7
 8013d82: f85d 7b04    	ldr	r7, [sp], #4
 8013d86: 4770         	bx	lr

08013d88 <$d>:
 8013d88: 00 44 02 58  	.word	0x58024400

08013d8c <LL_RCC_PLL2_GetM>:
; {
 8013d8c: b480         	push	{r7}
 8013d8e: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->PLLCKSELR, RCC_PLLCKSELR_DIVM2) >>  RCC_PLLCKSELR_DIVM2_Pos);
 8013d90: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8013da4 <LL_RCC_PLL2_GetM+0x18>
 8013d92: 6a9b         	ldr	r3, [r3, #0x28]
 8013d94: 0b1b         	lsrs	r3, r3, #0xc
 8013d96: f003 033f    	and	r3, r3, #0x3f
; }
 8013d9a: 4618         	mov	r0, r3
 8013d9c: 46bd         	mov	sp, r7
 8013d9e: f85d 7b04    	ldr	r7, [sp], #4
 8013da2: 4770         	bx	lr

08013da4 <$d>:
 8013da4: 00 44 02 58  	.word	0x58024400

08013da8 <LL_RCC_PLL2_GetP>:
; {
 8013da8: b480         	push	{r7}
 8013daa: af00         	add	r7, sp, #0x0
;   return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_P2) >>  RCC_PLL2DIVR_P2_Pos) + 1UL);
 8013dac: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8013dc4 <LL_RCC_PLL2_GetP+0x1c>
 8013dae: 6b9b         	ldr	r3, [r3, #0x38]
 8013db0: 0a5b         	lsrs	r3, r3, #0x9
 8013db2: f003 037f    	and	r3, r3, #0x7f
 8013db6: 3301         	adds	r3, #0x1
; }
 8013db8: 4618         	mov	r0, r3
 8013dba: 46bd         	mov	sp, r7
 8013dbc: f85d 7b04    	ldr	r7, [sp], #4
 8013dc0: 4770         	bx	lr
 8013dc2: bf00         	nop

08013dc4 <$d>:
 8013dc4: 00 44 02 58  	.word	0x58024400

08013dc8 <LL_RCC_PLL2_GetQ>:
; {
 8013dc8: b480         	push	{r7}
 8013dca: af00         	add	r7, sp, #0x0
;   return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_Q2) >>  RCC_PLL2DIVR_Q2_Pos) + 1UL);
 8013dcc: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8013de4 <LL_RCC_PLL2_GetQ+0x1c>
 8013dce: 6b9b         	ldr	r3, [r3, #0x38]
 8013dd0: 0c1b         	lsrs	r3, r3, #0x10
 8013dd2: f003 037f    	and	r3, r3, #0x7f
 8013dd6: 3301         	adds	r3, #0x1
; }
 8013dd8: 4618         	mov	r0, r3
 8013dda: 46bd         	mov	sp, r7
 8013ddc: f85d 7b04    	ldr	r7, [sp], #4
 8013de0: 4770         	bx	lr
 8013de2: bf00         	nop

08013de4 <$d>:
 8013de4: 00 44 02 58  	.word	0x58024400

08013de8 <LL_RCC_PLL2_GetR>:
; {
 8013de8: b480         	push	{r7}
 8013dea: af00         	add	r7, sp, #0x0
;   return (uint32_t)((READ_BIT(RCC->PLL2DIVR, RCC_PLL2DIVR_R2) >>  RCC_PLL2DIVR_R2_Pos) + 1UL);
 8013dec: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8013e04 <LL_RCC_PLL2_GetR+0x1c>
 8013dee: 6b9b         	ldr	r3, [r3, #0x38]
 8013df0: 0e1b         	lsrs	r3, r3, #0x18
 8013df2: f003 037f    	and	r3, r3, #0x7f
 8013df6: 3301         	adds	r3, #0x1
; }
 8013df8: 4618         	mov	r0, r3
 8013dfa: 46bd         	mov	sp, r7
 8013dfc: f85d 7b04    	ldr	r7, [sp], #4
 8013e00: 4770         	bx	lr
 8013e02: bf00         	nop

08013e04 <$d>:
 8013e04: 00 44 02 58  	.word	0x58024400

08013e08 <LL_RCC_PLL2_GetFRACN>:
; {
 8013e08: b480         	push	{r7}
 8013e0a: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->PLL2FRACR, RCC_PLL2FRACR_FRACN2) >>  RCC_PLL2FRACR_FRACN2_Pos);
 8013e0c: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8013e20 <LL_RCC_PLL2_GetFRACN+0x18>
 8013e0e: 6bdb         	ldr	r3, [r3, #0x3c]
 8013e10: 08db         	lsrs	r3, r3, #0x3
 8013e12: f3c3 030c    	ubfx	r3, r3, #0x0, #0xd
; }
 8013e16: 4618         	mov	r0, r3
 8013e18: 46bd         	mov	sp, r7
 8013e1a: f85d 7b04    	ldr	r7, [sp], #4
 8013e1e: 4770         	bx	lr

08013e20 <$d>:
 8013e20: 00 44 02 58  	.word	0x58024400

08013e24 <LL_RCC_GetPLL1ClockFreq>:
; {
 8013e24: b580         	push	{r7, lr}
 8013e26: b08a         	sub	sp, #0x28
 8013e28: af02         	add	r7, sp, #0x8
 8013e2a: 6078         	str	r0, [r7, #0x4]
;   uint32_t pllinputfreq = LL_RCC_PERIPH_FREQUENCY_NO, pllsource;
 8013e2c: 2300         	movs	r3, #0x0
 8013e2e: 61fb         	str	r3, [r7, #0x1c]
;   uint32_t m, n, fracn = 0U;
 8013e30: 2300         	movs	r3, #0x0
 8013e32: 61bb         	str	r3, [r7, #0x18]
;   pllsource = LL_RCC_PLL_GetSource();
 8013e34: f7ff fe70    	bl	0x8013b18 <LL_RCC_PLL_GetSource> @ imm = #-0x320
 8013e38: 6178         	str	r0, [r7, #0x14]
;   switch (pllsource)
 8013e3a: 697b         	ldr	r3, [r7, #0x14]
 8013e3c: 2b02         	cmp	r3, #0x2
 8013e3e: d01f         	beq	0x8013e80 <LL_RCC_GetPLL1ClockFreq+0x5c> @ imm = #0x3e
 8013e40: 697b         	ldr	r3, [r7, #0x14]
 8013e42: 2b02         	cmp	r3, #0x2
 8013e44: d824         	bhi	0x8013e90 <LL_RCC_GetPLL1ClockFreq+0x6c> @ imm = #0x48
 8013e46: 697b         	ldr	r3, [r7, #0x14]
 8013e48: 2b00         	cmp	r3, #0x0
 8013e4a: d003         	beq	0x8013e54 <LL_RCC_GetPLL1ClockFreq+0x30> @ imm = #0x6
 8013e4c: 697b         	ldr	r3, [r7, #0x14]
 8013e4e: 2b01         	cmp	r3, #0x1
 8013e50: d00e         	beq	0x8013e70 <LL_RCC_GetPLL1ClockFreq+0x4c> @ imm = #0x1c
;       break;
 8013e52: e01d         	b	0x8013e90 <LL_RCC_GetPLL1ClockFreq+0x6c> @ imm = #0x3a
;       if (LL_RCC_HSI_IsReady() != 0U)
 8013e54: f7ff fe1c    	bl	0x8013a90 <LL_RCC_HSI_IsReady> @ imm = #-0x3c8
 8013e58: 4603         	mov	r3, r0
 8013e5a: 2b00         	cmp	r3, #0x0
 8013e5c: d01a         	beq	0x8013e94 <LL_RCC_GetPLL1ClockFreq+0x70> @ imm = #0x34
;         pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos);
 8013e5e: f7ff fe29    	bl	0x8013ab4 <LL_RCC_HSI_GetDivider> @ imm = #-0x3ae
 8013e62: 4603         	mov	r3, r0
 8013e64: 08db         	lsrs	r3, r3, #0x3
 8013e66: 4a38         	ldr	r2, [pc, #0xe0]         @ 0x8013f48 <LL_RCC_GetPLL1ClockFreq+0x124>
 8013e68: fa22 f303    	lsr.w	r3, r2, r3
 8013e6c: 61fb         	str	r3, [r7, #0x1c]
;       break;
 8013e6e: e011         	b	0x8013e94 <LL_RCC_GetPLL1ClockFreq+0x70> @ imm = #0x22
;       if (LL_RCC_CSI_IsReady() != 0U)
 8013e70: f7ff fe2e    	bl	0x8013ad0 <LL_RCC_CSI_IsReady> @ imm = #-0x3a4
 8013e74: 4603         	mov	r3, r0
 8013e76: 2b00         	cmp	r3, #0x0
 8013e78: d00e         	beq	0x8013e98 <LL_RCC_GetPLL1ClockFreq+0x74> @ imm = #0x1c
;         pllinputfreq = CSI_VALUE;
 8013e7a: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8013f4c <LL_RCC_GetPLL1ClockFreq+0x128>
 8013e7c: 61fb         	str	r3, [r7, #0x1c]
;       break;
 8013e7e: e00b         	b	0x8013e98 <LL_RCC_GetPLL1ClockFreq+0x74> @ imm = #0x16
;       if (LL_RCC_HSE_IsReady() != 0U)
 8013e80: f7ff fdf2    	bl	0x8013a68 <LL_RCC_HSE_IsReady> @ imm = #-0x41c
 8013e84: 4603         	mov	r3, r0
 8013e86: 2b00         	cmp	r3, #0x0
 8013e88: d008         	beq	0x8013e9c <LL_RCC_GetPLL1ClockFreq+0x78> @ imm = #0x10
;         pllinputfreq = HSE_VALUE;
 8013e8a: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8013f50 <LL_RCC_GetPLL1ClockFreq+0x12c>
 8013e8c: 61fb         	str	r3, [r7, #0x1c]
;       break;
 8013e8e: e005         	b	0x8013e9c <LL_RCC_GetPLL1ClockFreq+0x78> @ imm = #0xa
;       break;
 8013e90: bf00         	nop
 8013e92: e004         	b	0x8013e9e <LL_RCC_GetPLL1ClockFreq+0x7a> @ imm = #0x8
;       break;
 8013e94: bf00         	nop
 8013e96: e002         	b	0x8013e9e <LL_RCC_GetPLL1ClockFreq+0x7a> @ imm = #0x4
;       break;
 8013e98: bf00         	nop
 8013e9a: e000         	b	0x8013e9e <LL_RCC_GetPLL1ClockFreq+0x7a> @ imm = #0x0
;       break;
 8013e9c: bf00         	nop
;   PLL_Clocks->PLL_P_Frequency = 0U;
 8013e9e: 687b         	ldr	r3, [r7, #0x4]
 8013ea0: 2200         	movs	r2, #0x0
 8013ea2: 601a         	str	r2, [r3]
;   PLL_Clocks->PLL_Q_Frequency = 0U;
 8013ea4: 687b         	ldr	r3, [r7, #0x4]
 8013ea6: 2200         	movs	r2, #0x0
 8013ea8: 605a         	str	r2, [r3, #0x4]
;   PLL_Clocks->PLL_R_Frequency = 0U;
 8013eaa: 687b         	ldr	r3, [r7, #0x4]
 8013eac: 2200         	movs	r2, #0x0
 8013eae: 609a         	str	r2, [r3, #0x8]
;   m = LL_RCC_PLL1_GetM();
 8013eb0: f7ff feb0    	bl	0x8013c14 <LL_RCC_PLL1_GetM> @ imm = #-0x2a0
 8013eb4: 6138         	str	r0, [r7, #0x10]
;   n = LL_RCC_PLL1_GetN();
 8013eb6: f7ff fe9f    	bl	0x8013bf8 <LL_RCC_PLL1_GetN> @ imm = #-0x2c2
 8013eba: 60f8         	str	r0, [r7, #0xc]
;   if (LL_RCC_PLL1FRACN_IsEnabled() != 0U)
 8013ebc: f7ff fe8a    	bl	0x8013bd4 <LL_RCC_PLL1FRACN_IsEnabled> @ imm = #-0x2ec
 8013ec0: 4603         	mov	r3, r0
 8013ec2: 2b00         	cmp	r3, #0x0
 8013ec4: d002         	beq	0x8013ecc <LL_RCC_GetPLL1ClockFreq+0xa8> @ imm = #0x4
;     fracn = LL_RCC_PLL1_GetFRACN();
 8013ec6: f7ff fee3    	bl	0x8013c90 <LL_RCC_PLL1_GetFRACN> @ imm = #-0x23a
 8013eca: 61b8         	str	r0, [r7, #0x18]
;   if (m != 0U)
 8013ecc: 693b         	ldr	r3, [r7, #0x10]
 8013ece: 2b00         	cmp	r3, #0x0
 8013ed0: d035         	beq	0x8013f3e <LL_RCC_GetPLL1ClockFreq+0x11a> @ imm = #0x6a
;     if (LL_RCC_PLL1P_IsEnabled() != 0U)
 8013ed2: f7ff fe43    	bl	0x8013b5c <LL_RCC_PLL1P_IsEnabled> @ imm = #-0x37a
 8013ed6: 4603         	mov	r3, r0
 8013ed8: 2b00         	cmp	r3, #0x0
 8013eda: d00c         	beq	0x8013ef6 <LL_RCC_GetPLL1ClockFreq+0xd2> @ imm = #0x18
;       PLL_Clocks->PLL_P_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL1_GetP());
 8013edc: f7ff fea8    	bl	0x8013c30 <LL_RCC_PLL1_GetP> @ imm = #-0x2b0
 8013ee0: 4603         	mov	r3, r0
 8013ee2: 9300         	str	r3, [sp]
 8013ee4: 69bb         	ldr	r3, [r7, #0x18]
 8013ee6: 68fa         	ldr	r2, [r7, #0xc]
 8013ee8: 6939         	ldr	r1, [r7, #0x10]
 8013eea: 69f8         	ldr	r0, [r7, #0x1c]
 8013eec: f000 f8ca    	bl	0x8014084 <LL_RCC_CalcPLLClockFreq> @ imm = #0x194
 8013ef0: 4602         	mov	r2, r0
 8013ef2: 687b         	ldr	r3, [r7, #0x4]
 8013ef4: 601a         	str	r2, [r3]
;     if (LL_RCC_PLL1Q_IsEnabled() != 0U)
 8013ef6: f7ff fe45    	bl	0x8013b84 <LL_RCC_PLL1Q_IsEnabled> @ imm = #-0x376
 8013efa: 4603         	mov	r3, r0
 8013efc: 2b00         	cmp	r3, #0x0
 8013efe: d00c         	beq	0x8013f1a <LL_RCC_GetPLL1ClockFreq+0xf6> @ imm = #0x18
;       PLL_Clocks->PLL_Q_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL1_GetQ());
 8013f00: f7ff fea6    	bl	0x8013c50 <LL_RCC_PLL1_GetQ> @ imm = #-0x2b4
 8013f04: 4603         	mov	r3, r0
 8013f06: 9300         	str	r3, [sp]
 8013f08: 69bb         	ldr	r3, [r7, #0x18]
 8013f0a: 68fa         	ldr	r2, [r7, #0xc]
 8013f0c: 6939         	ldr	r1, [r7, #0x10]
 8013f0e: 69f8         	ldr	r0, [r7, #0x1c]
 8013f10: f000 f8b8    	bl	0x8014084 <LL_RCC_CalcPLLClockFreq> @ imm = #0x170
 8013f14: 4602         	mov	r2, r0
 8013f16: 687b         	ldr	r3, [r7, #0x4]
 8013f18: 605a         	str	r2, [r3, #0x4]
;     if (LL_RCC_PLL1R_IsEnabled() != 0U)
 8013f1a: f7ff fe47    	bl	0x8013bac <LL_RCC_PLL1R_IsEnabled> @ imm = #-0x372
 8013f1e: 4603         	mov	r3, r0
 8013f20: 2b00         	cmp	r3, #0x0
 8013f22: d00c         	beq	0x8013f3e <LL_RCC_GetPLL1ClockFreq+0x11a> @ imm = #0x18
;       PLL_Clocks->PLL_R_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL1_GetR());
 8013f24: f7ff fea4    	bl	0x8013c70 <LL_RCC_PLL1_GetR> @ imm = #-0x2b8
 8013f28: 4603         	mov	r3, r0
 8013f2a: 9300         	str	r3, [sp]
 8013f2c: 69bb         	ldr	r3, [r7, #0x18]
 8013f2e: 68fa         	ldr	r2, [r7, #0xc]
 8013f30: 6939         	ldr	r1, [r7, #0x10]
 8013f32: 69f8         	ldr	r0, [r7, #0x1c]
 8013f34: f000 f8a6    	bl	0x8014084 <LL_RCC_CalcPLLClockFreq> @ imm = #0x14c
 8013f38: 4602         	mov	r2, r0
 8013f3a: 687b         	ldr	r3, [r7, #0x4]
 8013f3c: 609a         	str	r2, [r3, #0x8]
; }
 8013f3e: bf00         	nop
 8013f40: 3720         	adds	r7, #0x20
 8013f42: 46bd         	mov	sp, r7
 8013f44: bd80         	pop	{r7, pc}
 8013f46: bf00         	nop

08013f48 <$d>:
 8013f48: 00 90 d0 03  	.word	0x03d09000
 8013f4c: 00 09 3d 00  	.word	0x003d0900
 8013f50: 00 36 6e 01  	.word	0x016e3600

08013f54 <LL_RCC_GetPLL2ClockFreq>:
; {
 8013f54: b580         	push	{r7, lr}
 8013f56: b08a         	sub	sp, #0x28
 8013f58: af02         	add	r7, sp, #0x8
 8013f5a: 6078         	str	r0, [r7, #0x4]
;   uint32_t pllinputfreq = LL_RCC_PERIPH_FREQUENCY_NO, pllsource;
 8013f5c: 2300         	movs	r3, #0x0
 8013f5e: 61fb         	str	r3, [r7, #0x1c]
;   uint32_t m, n, fracn = 0U;
 8013f60: 2300         	movs	r3, #0x0
 8013f62: 61bb         	str	r3, [r7, #0x18]
;   pllsource = LL_RCC_PLL_GetSource();
 8013f64: f7ff fdd8    	bl	0x8013b18 <LL_RCC_PLL_GetSource> @ imm = #-0x450
 8013f68: 6178         	str	r0, [r7, #0x14]
;   switch (pllsource)
 8013f6a: 697b         	ldr	r3, [r7, #0x14]
 8013f6c: 2b02         	cmp	r3, #0x2
 8013f6e: d01f         	beq	0x8013fb0 <LL_RCC_GetPLL2ClockFreq+0x5c> @ imm = #0x3e
 8013f70: 697b         	ldr	r3, [r7, #0x14]
 8013f72: 2b02         	cmp	r3, #0x2
 8013f74: d824         	bhi	0x8013fc0 <LL_RCC_GetPLL2ClockFreq+0x6c> @ imm = #0x48
 8013f76: 697b         	ldr	r3, [r7, #0x14]
 8013f78: 2b00         	cmp	r3, #0x0
 8013f7a: d003         	beq	0x8013f84 <LL_RCC_GetPLL2ClockFreq+0x30> @ imm = #0x6
 8013f7c: 697b         	ldr	r3, [r7, #0x14]
 8013f7e: 2b01         	cmp	r3, #0x1
 8013f80: d00e         	beq	0x8013fa0 <LL_RCC_GetPLL2ClockFreq+0x4c> @ imm = #0x1c
;       break;
 8013f82: e01d         	b	0x8013fc0 <LL_RCC_GetPLL2ClockFreq+0x6c> @ imm = #0x3a
;       if (LL_RCC_HSI_IsReady() != 0U)
 8013f84: f7ff fd84    	bl	0x8013a90 <LL_RCC_HSI_IsReady> @ imm = #-0x4f8
 8013f88: 4603         	mov	r3, r0
 8013f8a: 2b00         	cmp	r3, #0x0
 8013f8c: d01a         	beq	0x8013fc4 <LL_RCC_GetPLL2ClockFreq+0x70> @ imm = #0x34
;         pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos);
 8013f8e: f7ff fd91    	bl	0x8013ab4 <LL_RCC_HSI_GetDivider> @ imm = #-0x4de
 8013f92: 4603         	mov	r3, r0
 8013f94: 08db         	lsrs	r3, r3, #0x3
 8013f96: 4a38         	ldr	r2, [pc, #0xe0]         @ 0x8014078 <LL_RCC_GetPLL2ClockFreq+0x124>
 8013f98: fa22 f303    	lsr.w	r3, r2, r3
 8013f9c: 61fb         	str	r3, [r7, #0x1c]
;       break;
 8013f9e: e011         	b	0x8013fc4 <LL_RCC_GetPLL2ClockFreq+0x70> @ imm = #0x22
;       if (LL_RCC_CSI_IsReady() != 0U)
 8013fa0: f7ff fd96    	bl	0x8013ad0 <LL_RCC_CSI_IsReady> @ imm = #-0x4d4
 8013fa4: 4603         	mov	r3, r0
 8013fa6: 2b00         	cmp	r3, #0x0
 8013fa8: d00e         	beq	0x8013fc8 <LL_RCC_GetPLL2ClockFreq+0x74> @ imm = #0x1c
;         pllinputfreq = CSI_VALUE;
 8013faa: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x801407c <LL_RCC_GetPLL2ClockFreq+0x128>
 8013fac: 61fb         	str	r3, [r7, #0x1c]
;       break;
 8013fae: e00b         	b	0x8013fc8 <LL_RCC_GetPLL2ClockFreq+0x74> @ imm = #0x16
;       if (LL_RCC_HSE_IsReady() != 0U)
 8013fb0: f7ff fd5a    	bl	0x8013a68 <LL_RCC_HSE_IsReady> @ imm = #-0x54c
 8013fb4: 4603         	mov	r3, r0
 8013fb6: 2b00         	cmp	r3, #0x0
 8013fb8: d008         	beq	0x8013fcc <LL_RCC_GetPLL2ClockFreq+0x78> @ imm = #0x10
;         pllinputfreq = HSE_VALUE;
 8013fba: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8014080 <LL_RCC_GetPLL2ClockFreq+0x12c>
 8013fbc: 61fb         	str	r3, [r7, #0x1c]
;       break;
 8013fbe: e005         	b	0x8013fcc <LL_RCC_GetPLL2ClockFreq+0x78> @ imm = #0xa
;       break;
 8013fc0: bf00         	nop
 8013fc2: e004         	b	0x8013fce <LL_RCC_GetPLL2ClockFreq+0x7a> @ imm = #0x8
;       break;
 8013fc4: bf00         	nop
 8013fc6: e002         	b	0x8013fce <LL_RCC_GetPLL2ClockFreq+0x7a> @ imm = #0x4
;       break;
 8013fc8: bf00         	nop
 8013fca: e000         	b	0x8013fce <LL_RCC_GetPLL2ClockFreq+0x7a> @ imm = #0x0
;       break;
 8013fcc: bf00         	nop
;   PLL_Clocks->PLL_P_Frequency = 0U;
 8013fce: 687b         	ldr	r3, [r7, #0x4]
 8013fd0: 2200         	movs	r2, #0x0
 8013fd2: 601a         	str	r2, [r3]
;   PLL_Clocks->PLL_Q_Frequency = 0U;
 8013fd4: 687b         	ldr	r3, [r7, #0x4]
 8013fd6: 2200         	movs	r2, #0x0
 8013fd8: 605a         	str	r2, [r3, #0x4]
;   PLL_Clocks->PLL_R_Frequency = 0U;
 8013fda: 687b         	ldr	r3, [r7, #0x4]
 8013fdc: 2200         	movs	r2, #0x0
 8013fde: 609a         	str	r2, [r3, #0x8]
;   m = LL_RCC_PLL2_GetM();
 8013fe0: f7ff fed4    	bl	0x8013d8c <LL_RCC_PLL2_GetM> @ imm = #-0x258
 8013fe4: 6138         	str	r0, [r7, #0x10]
;   n = LL_RCC_PLL2_GetN();
 8013fe6: f7ff fec3    	bl	0x8013d70 <LL_RCC_PLL2_GetN> @ imm = #-0x27a
 8013fea: 60f8         	str	r0, [r7, #0xc]
;   if (LL_RCC_PLL2FRACN_IsEnabled() != 0U)
 8013fec: f7ff feae    	bl	0x8013d4c <LL_RCC_PLL2FRACN_IsEnabled> @ imm = #-0x2a4
 8013ff0: 4603         	mov	r3, r0
 8013ff2: 2b00         	cmp	r3, #0x0
 8013ff4: d002         	beq	0x8013ffc <LL_RCC_GetPLL2ClockFreq+0xa8> @ imm = #0x4
;     fracn = LL_RCC_PLL2_GetFRACN();
 8013ff6: f7ff ff07    	bl	0x8013e08 <LL_RCC_PLL2_GetFRACN> @ imm = #-0x1f2
 8013ffa: 61b8         	str	r0, [r7, #0x18]
;   if (m != 0U)
 8013ffc: 693b         	ldr	r3, [r7, #0x10]
 8013ffe: 2b00         	cmp	r3, #0x0
 8014000: d035         	beq	0x801406e <LL_RCC_GetPLL2ClockFreq+0x11a> @ imm = #0x6a
;     if (LL_RCC_PLL2P_IsEnabled() != 0U)
 8014002: f7ff fe67    	bl	0x8013cd4 <LL_RCC_PLL2P_IsEnabled> @ imm = #-0x332
 8014006: 4603         	mov	r3, r0
 8014008: 2b00         	cmp	r3, #0x0
 801400a: d00c         	beq	0x8014026 <LL_RCC_GetPLL2ClockFreq+0xd2> @ imm = #0x18
;       PLL_Clocks->PLL_P_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL2_GetP());
 801400c: f7ff fecc    	bl	0x8013da8 <LL_RCC_PLL2_GetP> @ imm = #-0x268
 8014010: 4603         	mov	r3, r0
 8014012: 9300         	str	r3, [sp]
 8014014: 69bb         	ldr	r3, [r7, #0x18]
 8014016: 68fa         	ldr	r2, [r7, #0xc]
 8014018: 6939         	ldr	r1, [r7, #0x10]
 801401a: 69f8         	ldr	r0, [r7, #0x1c]
 801401c: f000 f832    	bl	0x8014084 <LL_RCC_CalcPLLClockFreq> @ imm = #0x64
 8014020: 4602         	mov	r2, r0
 8014022: 687b         	ldr	r3, [r7, #0x4]
 8014024: 601a         	str	r2, [r3]
;     if (LL_RCC_PLL2Q_IsEnabled() != 0U)
 8014026: f7ff fe69    	bl	0x8013cfc <LL_RCC_PLL2Q_IsEnabled> @ imm = #-0x32e
 801402a: 4603         	mov	r3, r0
 801402c: 2b00         	cmp	r3, #0x0
 801402e: d00c         	beq	0x801404a <LL_RCC_GetPLL2ClockFreq+0xf6> @ imm = #0x18
;       PLL_Clocks->PLL_Q_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL2_GetQ());
 8014030: f7ff feca    	bl	0x8013dc8 <LL_RCC_PLL2_GetQ> @ imm = #-0x26c
 8014034: 4603         	mov	r3, r0
 8014036: 9300         	str	r3, [sp]
 8014038: 69bb         	ldr	r3, [r7, #0x18]
 801403a: 68fa         	ldr	r2, [r7, #0xc]
 801403c: 6939         	ldr	r1, [r7, #0x10]
 801403e: 69f8         	ldr	r0, [r7, #0x1c]
 8014040: f000 f820    	bl	0x8014084 <LL_RCC_CalcPLLClockFreq> @ imm = #0x40
 8014044: 4602         	mov	r2, r0
 8014046: 687b         	ldr	r3, [r7, #0x4]
 8014048: 605a         	str	r2, [r3, #0x4]
;     if (LL_RCC_PLL2R_IsEnabled() != 0U)
 801404a: f7ff fe6b    	bl	0x8013d24 <LL_RCC_PLL2R_IsEnabled> @ imm = #-0x32a
 801404e: 4603         	mov	r3, r0
 8014050: 2b00         	cmp	r3, #0x0
 8014052: d00c         	beq	0x801406e <LL_RCC_GetPLL2ClockFreq+0x11a> @ imm = #0x18
;       PLL_Clocks->PLL_R_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL2_GetR());
 8014054: f7ff fec8    	bl	0x8013de8 <LL_RCC_PLL2_GetR> @ imm = #-0x270
 8014058: 4603         	mov	r3, r0
 801405a: 9300         	str	r3, [sp]
 801405c: 69bb         	ldr	r3, [r7, #0x18]
 801405e: 68fa         	ldr	r2, [r7, #0xc]
 8014060: 6939         	ldr	r1, [r7, #0x10]
 8014062: 69f8         	ldr	r0, [r7, #0x1c]
 8014064: f000 f80e    	bl	0x8014084 <LL_RCC_CalcPLLClockFreq> @ imm = #0x1c
 8014068: 4602         	mov	r2, r0
 801406a: 687b         	ldr	r3, [r7, #0x4]
 801406c: 609a         	str	r2, [r3, #0x8]
; }
 801406e: bf00         	nop
 8014070: 3720         	adds	r7, #0x20
 8014072: 46bd         	mov	sp, r7
 8014074: bd80         	pop	{r7, pc}
 8014076: bf00         	nop

08014078 <$d>:
 8014078: 00 90 d0 03  	.word	0x03d09000
 801407c: 00 09 3d 00  	.word	0x003d0900
 8014080: 00 36 6e 01  	.word	0x016e3600

08014084 <LL_RCC_CalcPLLClockFreq>:
; {
 8014084: b480         	push	{r7}
 8014086: b087         	sub	sp, #0x1c
 8014088: af00         	add	r7, sp, #0x0
 801408a: 60f8         	str	r0, [r7, #0xc]
 801408c: 60b9         	str	r1, [r7, #0x8]
 801408e: 607a         	str	r2, [r7, #0x4]
 8014090: 603b         	str	r3, [r7]
;   freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN / (float_t)0x2000));
 8014092: 68fb         	ldr	r3, [r7, #0xc]
 8014094: ee07 3a90    	<unknown>
 8014098: eef8 6a67    	<unknown>
 801409c: 68bb         	ldr	r3, [r7, #0x8]
 801409e: ee07 3a90    	<unknown>
 80140a2: eef8 7a67    	<unknown>
 80140a6: ee86 7aa7    	<unknown>
 80140aa: 687b         	ldr	r3, [r7, #0x4]
 80140ac: ee07 3a90    	<unknown>
 80140b0: eef8 6a67    	<unknown>
 80140b4: 683b         	ldr	r3, [r7]
 80140b6: ee07 3a90    	<unknown>
 80140ba: eeb8 6a67    	<unknown>
 80140be: eddf 5a10    	<unknown>
 80140c2: eec6 7a25    	<unknown>
 80140c6: ee76 7aa7    	<unknown>
 80140ca: ee67 7a27    	<unknown>
 80140ce: edc7 7a05    	<unknown>
;   freq = freq / (float_t)PQR;
 80140d2: 6a3b         	ldr	r3, [r7, #0x20]
 80140d4: ee07 3a90    	<unknown>
 80140d8: eeb8 7a67    	<unknown>
 80140dc: edd7 6a05    	<unknown>
 80140e0: eec6 7a87    	<unknown>
 80140e4: edc7 7a05    	<unknown>
;   return (uint32_t)freq;
 80140e8: edd7 7a05    	<unknown>
 80140ec: eefc 7ae7    	<unknown>
 80140f0: ee17 3a90    	<unknown>
; }
 80140f4: 4618         	mov	r0, r3
 80140f6: 371c         	adds	r7, #0x1c
 80140f8: 46bd         	mov	sp, r7
 80140fa: f85d 7b04    	ldr	r7, [sp], #4
 80140fe: 4770         	bx	lr

08014100 <$d>:
 8014100: 00 00 00 46  	.word	0x46000000

08014104 <LL_RCC_GetFDCANClockFreq>:
; {
 8014104: b580         	push	{r7, lr}
 8014106: b086         	sub	sp, #0x18
 8014108: af00         	add	r7, sp, #0x0
 801410a: 6078         	str	r0, [r7, #0x4]
;   uint32_t fdcan_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
 801410c: 2300         	movs	r3, #0x0
 801410e: 617b         	str	r3, [r7, #0x14]
;   switch (LL_RCC_GetFDCANClockSource(FDCANxSource))
 8014110: 6878         	ldr	r0, [r7, #0x4]
 8014112: f7ff fcf1    	bl	0x8013af8 <LL_RCC_GetFDCANClockSource> @ imm = #-0x61e
 8014116: 4603         	mov	r3, r0
 8014118: f1b3 5f00    	cmp.w	r3, #0x20000000
 801411c: d01d         	beq	0x801415a <LL_RCC_GetFDCANClockFreq+0x56> @ imm = #0x3a
 801411e: f1b3 5f00    	cmp.w	r3, #0x20000000
 8014122: d827         	bhi	0x8014174 <LL_RCC_GetFDCANClockFreq+0x70> @ imm = #0x4e
 8014124: 2b00         	cmp	r3, #0x0
 8014126: d003         	beq	0x8014130 <LL_RCC_GetFDCANClockFreq+0x2c> @ imm = #0x6
 8014128: f1b3 5f80    	cmp.w	r3, #0x10000000
 801412c: d008         	beq	0x8014140 <LL_RCC_GetFDCANClockFreq+0x3c> @ imm = #0x10
;       break;
 801412e: e021         	b	0x8014174 <LL_RCC_GetFDCANClockFreq+0x70> @ imm = #0x42
;       if (LL_RCC_HSE_IsReady() != 0U)
 8014130: f7ff fc9a    	bl	0x8013a68 <LL_RCC_HSE_IsReady> @ imm = #-0x6cc
 8014134: 4603         	mov	r3, r0
 8014136: 2b00         	cmp	r3, #0x0
 8014138: d01e         	beq	0x8014178 <LL_RCC_GetFDCANClockFreq+0x74> @ imm = #0x3c
;         fdcan_frequency = HSE_VALUE;
 801413a: 4b14         	ldr	r3, [pc, #0x50]         @ 0x801418c <LL_RCC_GetFDCANClockFreq+0x88>
 801413c: 617b         	str	r3, [r7, #0x14]
;       break;
 801413e: e01b         	b	0x8014178 <LL_RCC_GetFDCANClockFreq+0x74> @ imm = #0x36
;       if (LL_RCC_PLL1_IsReady() != 0U)
 8014140: f7ff fcf8    	bl	0x8013b34 <LL_RCC_PLL1_IsReady> @ imm = #-0x610
 8014144: 4603         	mov	r3, r0
 8014146: 2b00         	cmp	r3, #0x0
 8014148: d018         	beq	0x801417c <LL_RCC_GetFDCANClockFreq+0x78> @ imm = #0x30
;         LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);
 801414a: f107 0308    	add.w	r3, r7, #0x8
 801414e: 4618         	mov	r0, r3
 8014150: f7ff fe68    	bl	0x8013e24 <LL_RCC_GetPLL1ClockFreq> @ imm = #-0x330
;         fdcan_frequency = PLL_Clocks.PLL_Q_Frequency;
 8014154: 68fb         	ldr	r3, [r7, #0xc]
 8014156: 617b         	str	r3, [r7, #0x14]
;       break;
 8014158: e010         	b	0x801417c <LL_RCC_GetFDCANClockFreq+0x78> @ imm = #0x20
;       if (LL_RCC_PLL2_IsReady() != 0U)
 801415a: f7ff fda7    	bl	0x8013cac <LL_RCC_PLL2_IsReady> @ imm = #-0x4b2
 801415e: 4603         	mov	r3, r0
 8014160: 2b00         	cmp	r3, #0x0
 8014162: d00d         	beq	0x8014180 <LL_RCC_GetFDCANClockFreq+0x7c> @ imm = #0x1a
;         LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);
 8014164: f107 0308    	add.w	r3, r7, #0x8
 8014168: 4618         	mov	r0, r3
 801416a: f7ff fef3    	bl	0x8013f54 <LL_RCC_GetPLL2ClockFreq> @ imm = #-0x21a
;         fdcan_frequency = PLL_Clocks.PLL_Q_Frequency;
 801416e: 68fb         	ldr	r3, [r7, #0xc]
 8014170: 617b         	str	r3, [r7, #0x14]
;       break;
 8014172: e005         	b	0x8014180 <LL_RCC_GetFDCANClockFreq+0x7c> @ imm = #0xa
;       break;
 8014174: bf00         	nop
 8014176: e004         	b	0x8014182 <LL_RCC_GetFDCANClockFreq+0x7e> @ imm = #0x8
;       break;
 8014178: bf00         	nop
 801417a: e002         	b	0x8014182 <LL_RCC_GetFDCANClockFreq+0x7e> @ imm = #0x4
;       break;
 801417c: bf00         	nop
 801417e: e000         	b	0x8014182 <LL_RCC_GetFDCANClockFreq+0x7e> @ imm = #0x0
;       break;
 8014180: bf00         	nop
;   return fdcan_frequency;
 8014182: 697b         	ldr	r3, [r7, #0x14]
; }
 8014184: 4618         	mov	r0, r3
 8014186: 3718         	adds	r7, #0x18
 8014188: 46bd         	mov	sp, r7
 801418a: bd80         	pop	{r7, pc}

0801418c <$d>:
 801418c: 00 36 6e 01  	.word	0x016e3600

08014190 <LL_FLASH_SetLatency>:
; {
 8014190: b480         	push	{r7}
 8014192: b083         	sub	sp, #0xc
 8014194: af00         	add	r7, sp, #0x0
 8014196: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 8014198: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80141b4 <LL_FLASH_SetLatency+0x24>
 801419a: 681b         	ldr	r3, [r3]
 801419c: f023 020f    	bic	r2, r3, #0xf
 80141a0: 4904         	ldr	r1, [pc, #0x10]         @ 0x80141b4 <LL_FLASH_SetLatency+0x24>
 80141a2: 687b         	ldr	r3, [r7, #0x4]
 80141a4: 4313         	orrs	r3, r2
 80141a6: 600b         	str	r3, [r1]
; }
 80141a8: bf00         	nop
 80141aa: 370c         	adds	r7, #0xc
 80141ac: 46bd         	mov	sp, r7
 80141ae: f85d 7b04    	ldr	r7, [sp], #4
 80141b2: 4770         	bx	lr

080141b4 <$d>:
 80141b4: 00 20 00 52  	.word	0x52002000

080141b8 <LL_FLASH_GetLatency>:
; {
 80141b8: b480         	push	{r7}
 80141ba: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
 80141bc: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80141d0 <LL_FLASH_GetLatency+0x18>
 80141be: 681b         	ldr	r3, [r3]
 80141c0: f003 030f    	and	r3, r3, #0xf
; }
 80141c4: 4618         	mov	r0, r3
 80141c6: 46bd         	mov	sp, r7
 80141c8: f85d 7b04    	ldr	r7, [sp], #4
 80141cc: 4770         	bx	lr
 80141ce: bf00         	nop

080141d0 <$d>:
 80141d0: 00 20 00 52  	.word	0x52002000

080141d4 <LL_PWR_GetRegulVoltageScaling>:
; {
 80141d4: b480         	push	{r7}
 80141d6: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(PWR->D3CR, PWR_D3CR_VOS));
 80141d8: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80141ec <LL_PWR_GetRegulVoltageScaling+0x18>
 80141da: 699b         	ldr	r3, [r3, #0x18]
 80141dc: f403 4340    	and	r3, r3, #0xc000
; }
 80141e0: 4618         	mov	r0, r3
 80141e2: 46bd         	mov	sp, r7
 80141e4: f85d 7b04    	ldr	r7, [sp], #4
 80141e8: 4770         	bx	lr
 80141ea: bf00         	nop

080141ec <$d>:
 80141ec: 00 48 02 58  	.word	0x58024800

080141f0 <LL_SetFlashLatency>:
; {
 80141f0: b580         	push	{r7, lr}
 80141f2: b086         	sub	sp, #0x18
 80141f4: af00         	add	r7, sp, #0x0
 80141f6: 6078         	str	r0, [r7, #0x4]
;   ErrorStatus status = SUCCESS;
 80141f8: 2300         	movs	r3, #0x0
 80141fa: 75fb         	strb	r3, [r7, #0x17]
;   uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */
 80141fc: 2300         	movs	r3, #0x0
 80141fe: 60fb         	str	r3, [r7, #0xc]
;   if (HCLK_Frequency == 0U)
 8014200: 687b         	ldr	r3, [r7, #0x4]
 8014202: 2b00         	cmp	r3, #0x0
 8014204: d102         	bne	0x801420c <LL_SetFlashLatency+0x1c> @ imm = #0x4
;     status = ERROR;
 8014206: 2301         	movs	r3, #0x1
 8014208: 75fb         	strb	r3, [r7, #0x17]
 801420a: e0a8         	b	0x801435e <LL_SetFlashLatency+0x16e> @ imm = #0x150
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE0)
 801420c: f7ff ffe2    	bl	0x80141d4 <LL_PWR_GetRegulVoltageScaling> @ imm = #-0x3c
 8014210: 4603         	mov	r3, r0
 8014212: 2b00         	cmp	r3, #0x0
 8014214: d126         	bne	0x8014264 <LL_SetFlashLatency+0x74> @ imm = #0x4c
;       if((HCLK_Frequency > UTILS_SCALE0_LATENCY2_FREQ) && (HCLK_Frequency <= UTILS_SCALE0_LATENCY3_FREQ))
 8014216: 687b         	ldr	r3, [r7, #0x4]
 8014218: 4a53         	ldr	r2, [pc, #0x14c]        @ 0x8014368 <LL_SetFlashLatency+0x178>
 801421a: 4293         	cmp	r3, r2
 801421c: d906         	bls	0x801422c <LL_SetFlashLatency+0x3c> @ imm = #0xc
 801421e: 687b         	ldr	r3, [r7, #0x4]
 8014220: 4a52         	ldr	r2, [pc, #0x148]        @ 0x801436c <LL_SetFlashLatency+0x17c>
 8014222: 4293         	cmp	r3, r2
 8014224: d802         	bhi	0x801422c <LL_SetFlashLatency+0x3c> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_3;
 8014226: 2303         	movs	r3, #0x3
 8014228: 60fb         	str	r3, [r7, #0xc]
 801422a: e01b         	b	0x8014264 <LL_SetFlashLatency+0x74> @ imm = #0x36
;       else if((HCLK_Frequency > UTILS_SCALE0_LATENCY1_FREQ) && (HCLK_Frequency <= UTILS_SCALE0_LATENCY2_FREQ))
 801422c: 687b         	ldr	r3, [r7, #0x4]
 801422e: 4a50         	ldr	r2, [pc, #0x140]        @ 0x8014370 <LL_SetFlashLatency+0x180>
 8014230: 4293         	cmp	r3, r2
 8014232: d906         	bls	0x8014242 <LL_SetFlashLatency+0x52> @ imm = #0xc
 8014234: 687b         	ldr	r3, [r7, #0x4]
 8014236: 4a4c         	ldr	r2, [pc, #0x130]        @ 0x8014368 <LL_SetFlashLatency+0x178>
 8014238: 4293         	cmp	r3, r2
 801423a: d802         	bhi	0x8014242 <LL_SetFlashLatency+0x52> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 801423c: 2302         	movs	r3, #0x2
 801423e: 60fb         	str	r3, [r7, #0xc]
 8014240: e010         	b	0x8014264 <LL_SetFlashLatency+0x74> @ imm = #0x20
;       else if((HCLK_Frequency > UTILS_SCALE0_LATENCY0_FREQ) && (HCLK_Frequency <= UTILS_SCALE0_LATENCY1_FREQ))
 8014242: 687b         	ldr	r3, [r7, #0x4]
 8014244: 4a4b         	ldr	r2, [pc, #0x12c]        @ 0x8014374 <LL_SetFlashLatency+0x184>
 8014246: 4293         	cmp	r3, r2
 8014248: d906         	bls	0x8014258 <LL_SetFlashLatency+0x68> @ imm = #0xc
 801424a: 687b         	ldr	r3, [r7, #0x4]
 801424c: 4a48         	ldr	r2, [pc, #0x120]        @ 0x8014370 <LL_SetFlashLatency+0x180>
 801424e: 4293         	cmp	r3, r2
 8014250: d802         	bhi	0x8014258 <LL_SetFlashLatency+0x68> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_1;
 8014252: 2301         	movs	r3, #0x1
 8014254: 60fb         	str	r3, [r7, #0xc]
 8014256: e005         	b	0x8014264 <LL_SetFlashLatency+0x74> @ imm = #0xa
;       else if(HCLK_Frequency <= UTILS_SCALE0_LATENCY0_FREQ)
 8014258: 687b         	ldr	r3, [r7, #0x4]
 801425a: 4a46         	ldr	r2, [pc, #0x118]        @ 0x8014374 <LL_SetFlashLatency+0x184>
 801425c: 4293         	cmp	r3, r2
 801425e: d901         	bls	0x8014264 <LL_SetFlashLatency+0x74> @ imm = #0x2
;         status = ERROR;
 8014260: 2301         	movs	r3, #0x1
 8014262: 75fb         	strb	r3, [r7, #0x17]
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)
 8014264: f7ff ffb6    	bl	0x80141d4 <LL_PWR_GetRegulVoltageScaling> @ imm = #-0x94
 8014268: 4603         	mov	r3, r0
 801426a: f5b3 4f40    	cmp.w	r3, #0xc000
 801426e: d11c         	bne	0x80142aa <LL_SetFlashLatency+0xba> @ imm = #0x38
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ) && (HCLK_Frequency <= UTILS_SCALE1_LATENCY2_FREQ))
 8014270: 687b         	ldr	r3, [r7, #0x4]
 8014272: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8014378 <LL_SetFlashLatency+0x188>
 8014274: 4293         	cmp	r3, r2
 8014276: d906         	bls	0x8014286 <LL_SetFlashLatency+0x96> @ imm = #0xc
 8014278: 687b         	ldr	r3, [r7, #0x4]
 801427a: 4a40         	ldr	r2, [pc, #0x100]        @ 0x801437c <LL_SetFlashLatency+0x18c>
 801427c: 4293         	cmp	r3, r2
 801427e: d802         	bhi	0x8014286 <LL_SetFlashLatency+0x96> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 8014280: 2302         	movs	r3, #0x2
 8014282: 60fb         	str	r3, [r7, #0xc]
 8014284: e050         	b	0x8014328 <LL_SetFlashLatency+0x138> @ imm = #0xa0
;       else if((HCLK_Frequency > UTILS_SCALE1_LATENCY0_FREQ) && (HCLK_Frequency <= UTILS_SCALE1_LATENCY1_FREQ))
 8014286: 687b         	ldr	r3, [r7, #0x4]
 8014288: 4a3d         	ldr	r2, [pc, #0xf4]         @ 0x8014380 <LL_SetFlashLatency+0x190>
 801428a: 4293         	cmp	r3, r2
 801428c: d906         	bls	0x801429c <LL_SetFlashLatency+0xac> @ imm = #0xc
 801428e: 687b         	ldr	r3, [r7, #0x4]
 8014290: 4a39         	ldr	r2, [pc, #0xe4]         @ 0x8014378 <LL_SetFlashLatency+0x188>
 8014292: 4293         	cmp	r3, r2
 8014294: d802         	bhi	0x801429c <LL_SetFlashLatency+0xac> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_1;
 8014296: 2301         	movs	r3, #0x1
 8014298: 60fb         	str	r3, [r7, #0xc]
 801429a: e045         	b	0x8014328 <LL_SetFlashLatency+0x138> @ imm = #0x8a
;       else if(HCLK_Frequency <= UTILS_SCALE1_LATENCY0_FREQ)
 801429c: 687b         	ldr	r3, [r7, #0x4]
 801429e: 4a38         	ldr	r2, [pc, #0xe0]         @ 0x8014380 <LL_SetFlashLatency+0x190>
 80142a0: 4293         	cmp	r3, r2
 80142a2: d941         	bls	0x8014328 <LL_SetFlashLatency+0x138> @ imm = #0x82
;         status = ERROR;
 80142a4: 2301         	movs	r3, #0x1
 80142a6: 75fb         	strb	r3, [r7, #0x17]
 80142a8: e03e         	b	0x8014328 <LL_SetFlashLatency+0x138> @ imm = #0x7c
;     else if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2)
 80142aa: f7ff ff93    	bl	0x80141d4 <LL_PWR_GetRegulVoltageScaling> @ imm = #-0xda
 80142ae: 4603         	mov	r3, r0
 80142b0: f5b3 4f00    	cmp.w	r3, #0x8000
 80142b4: d11c         	bne	0x80142f0 <LL_SetFlashLatency+0x100> @ imm = #0x38
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ) && (HCLK_Frequency <= UTILS_SCALE2_LATENCY2_FREQ))
 80142b6: 687b         	ldr	r3, [r7, #0x4]
 80142b8: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x8014384 <LL_SetFlashLatency+0x194>
 80142ba: 4293         	cmp	r3, r2
 80142bc: d906         	bls	0x80142cc <LL_SetFlashLatency+0xdc> @ imm = #0xc
 80142be: 687b         	ldr	r3, [r7, #0x4]
 80142c0: 4a31         	ldr	r2, [pc, #0xc4]         @ 0x8014388 <LL_SetFlashLatency+0x198>
 80142c2: 4293         	cmp	r3, r2
 80142c4: d802         	bhi	0x80142cc <LL_SetFlashLatency+0xdc> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 80142c6: 2302         	movs	r3, #0x2
 80142c8: 60fb         	str	r3, [r7, #0xc]
 80142ca: e02d         	b	0x8014328 <LL_SetFlashLatency+0x138> @ imm = #0x5a
;       else if((HCLK_Frequency > UTILS_SCALE2_LATENCY0_FREQ) && (HCLK_Frequency <= UTILS_SCALE2_LATENCY1_FREQ))
 80142cc: 687b         	ldr	r3, [r7, #0x4]
 80142ce: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x801438c <LL_SetFlashLatency+0x19c>
 80142d0: 4293         	cmp	r3, r2
 80142d2: d906         	bls	0x80142e2 <LL_SetFlashLatency+0xf2> @ imm = #0xc
 80142d4: 687b         	ldr	r3, [r7, #0x4]
 80142d6: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x8014384 <LL_SetFlashLatency+0x194>
 80142d8: 4293         	cmp	r3, r2
 80142da: d802         	bhi	0x80142e2 <LL_SetFlashLatency+0xf2> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_1;
 80142dc: 2301         	movs	r3, #0x1
 80142de: 60fb         	str	r3, [r7, #0xc]
 80142e0: e022         	b	0x8014328 <LL_SetFlashLatency+0x138> @ imm = #0x44
;       else if(HCLK_Frequency <= UTILS_SCALE2_LATENCY0_FREQ)
 80142e2: 687b         	ldr	r3, [r7, #0x4]
 80142e4: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x801438c <LL_SetFlashLatency+0x19c>
 80142e6: 4293         	cmp	r3, r2
 80142e8: d91e         	bls	0x8014328 <LL_SetFlashLatency+0x138> @ imm = #0x3c
;         status = ERROR;
 80142ea: 2301         	movs	r3, #0x1
 80142ec: 75fb         	strb	r3, [r7, #0x17]
 80142ee: e01b         	b	0x8014328 <LL_SetFlashLatency+0x138> @ imm = #0x36
;       if((HCLK_Frequency > UTILS_SCALE3_LATENCY1_FREQ) && (HCLK_Frequency <= UTILS_SCALE3_LATENCY2_FREQ))
 80142f0: 687b         	ldr	r3, [r7, #0x4]
 80142f2: 4a20         	ldr	r2, [pc, #0x80]         @ 0x8014374 <LL_SetFlashLatency+0x184>
 80142f4: 4293         	cmp	r3, r2
 80142f6: d906         	bls	0x8014306 <LL_SetFlashLatency+0x116> @ imm = #0xc
 80142f8: 687b         	ldr	r3, [r7, #0x4]
 80142fa: 4a25         	ldr	r2, [pc, #0x94]         @ 0x8014390 <LL_SetFlashLatency+0x1a0>
 80142fc: 4293         	cmp	r3, r2
 80142fe: d802         	bhi	0x8014306 <LL_SetFlashLatency+0x116> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 8014300: 2302         	movs	r3, #0x2
 8014302: 60fb         	str	r3, [r7, #0xc]
 8014304: e010         	b	0x8014328 <LL_SetFlashLatency+0x138> @ imm = #0x20
;       else if((HCLK_Frequency > UTILS_SCALE3_LATENCY0_FREQ) && (HCLK_Frequency <= UTILS_SCALE3_LATENCY1_FREQ))
 8014306: 687b         	ldr	r3, [r7, #0x4]
 8014308: 4a22         	ldr	r2, [pc, #0x88]         @ 0x8014394 <LL_SetFlashLatency+0x1a4>
 801430a: 4293         	cmp	r3, r2
 801430c: d906         	bls	0x801431c <LL_SetFlashLatency+0x12c> @ imm = #0xc
 801430e: 687b         	ldr	r3, [r7, #0x4]
 8014310: 4a18         	ldr	r2, [pc, #0x60]         @ 0x8014374 <LL_SetFlashLatency+0x184>
 8014312: 4293         	cmp	r3, r2
 8014314: d802         	bhi	0x801431c <LL_SetFlashLatency+0x12c> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_1;
 8014316: 2301         	movs	r3, #0x1
 8014318: 60fb         	str	r3, [r7, #0xc]
 801431a: e005         	b	0x8014328 <LL_SetFlashLatency+0x138> @ imm = #0xa
;       else if(HCLK_Frequency <= UTILS_SCALE3_LATENCY0_FREQ)
 801431c: 687b         	ldr	r3, [r7, #0x4]
 801431e: 4a1d         	ldr	r2, [pc, #0x74]         @ 0x8014394 <LL_SetFlashLatency+0x1a4>
 8014320: 4293         	cmp	r3, r2
 8014322: d901         	bls	0x8014328 <LL_SetFlashLatency+0x138> @ imm = #0x2
;         status = ERROR;
 8014324: 2301         	movs	r3, #0x1
 8014326: 75fb         	strb	r3, [r7, #0x17]
;     if(status == SUCCESS)
 8014328: 7dfb         	ldrb	r3, [r7, #0x17]
 801432a: 2b00         	cmp	r3, #0x0
 801432c: d117         	bne	0x801435e <LL_SetFlashLatency+0x16e> @ imm = #0x2e
;       LL_FLASH_SetLatency(latency);
 801432e: 68f8         	ldr	r0, [r7, #0xc]
 8014330: f7ff ff2e    	bl	0x8014190 <LL_FLASH_SetLatency> @ imm = #-0x1a4
;       timeout = 2;
 8014334: 2302         	movs	r3, #0x2
 8014336: 613b         	str	r3, [r7, #0x10]
;         getlatency = LL_FLASH_GetLatency();
 8014338: f7ff ff3e    	bl	0x80141b8 <LL_FLASH_GetLatency> @ imm = #-0x184
 801433c: 60b8         	str	r0, [r7, #0x8]
;         timeout--;
 801433e: 693b         	ldr	r3, [r7, #0x10]
 8014340: 3b01         	subs	r3, #0x1
 8014342: 613b         	str	r3, [r7, #0x10]
;       } while ((getlatency != latency) && (timeout > 0U));
 8014344: 68ba         	ldr	r2, [r7, #0x8]
 8014346: 68fb         	ldr	r3, [r7, #0xc]
 8014348: 429a         	cmp	r2, r3
 801434a: d002         	beq	0x8014352 <LL_SetFlashLatency+0x162> @ imm = #0x4
 801434c: 693b         	ldr	r3, [r7, #0x10]
 801434e: 2b00         	cmp	r3, #0x0
 8014350: d1f2         	bne	0x8014338 <LL_SetFlashLatency+0x148> @ imm = #-0x1c
;       if(getlatency != latency)
 8014352: 68ba         	ldr	r2, [r7, #0x8]
 8014354: 68fb         	ldr	r3, [r7, #0xc]
 8014356: 429a         	cmp	r2, r3
 8014358: d001         	beq	0x801435e <LL_SetFlashLatency+0x16e> @ imm = #0x2
;         status = ERROR;
 801435a: 2301         	movs	r3, #0x1
 801435c: 75fb         	strb	r3, [r7, #0x17]
;   return status;
 801435e: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 8014360: 4618         	mov	r0, r3
 8014362: 3718         	adds	r7, #0x18
 8014364: 46bd         	mov	sp, r7
 8014366: bd80         	pop	{r7, pc}

08014368 <$d>:
 8014368: 80 58 84 0c  	.word	0x0c845880
 801436c: c0 2a 64 10  	.word	0x10642ac0
 8014370: 00 3b 58 08  	.word	0x08583b00
 8014374: 80 1d 2c 04  	.word	0x042c1d80
 8014378: 40 6b ed 07  	.word	0x07ed6b40
 801437c: 00 c2 eb 0b  	.word	0x0bebc200
 8014380: c0 56 fe 03  	.word	0x03fe56c0
 8014384: 00 e1 f5 05  	.word	0x05f5e100
 8014388: 80 d1 f0 08  	.word	0x08f0d180
 801438c: 80 f0 fa 02  	.word	0x02faf080
 8014390: 40 ff 10 05  	.word	0x0510ff40
 8014394: c0 0e 16 02  	.word	0x02160ec0

08014398 <z_device_state_init>:
; {
 8014398: b580         	push	{r7, lr}
 801439a: b082         	sub	sp, #0x8
 801439c: af00         	add	r7, sp, #0x0
; 	STRUCT_SECTION_FOREACH(device, dev) {
 801439e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80143cc <z_device_state_init+0x34>
 80143a0: 607b         	str	r3, [r7, #0x4]
 80143a2: e005         	b	0x80143b0 <z_device_state_init+0x18> @ imm = #0xa
; 		k_object_init(dev);
 80143a4: 6878         	ldr	r0, [r7, #0x4]
 80143a6: f011 fff0    	bl	0x802638a <k_object_init> @ imm = #0x11fe0
; 	STRUCT_SECTION_FOREACH(device, dev) {
 80143aa: 687b         	ldr	r3, [r7, #0x4]
 80143ac: 3314         	adds	r3, #0x14
 80143ae: 607b         	str	r3, [r7, #0x4]
 80143b0: 687b         	ldr	r3, [r7, #0x4]
 80143b2: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80143d0 <z_device_state_init+0x38>
 80143b4: 4293         	cmp	r3, r2
 80143b6: bf34         	ite	lo
 80143b8: 2301         	movlo	r3, #0x1
 80143ba: 2300         	movhs	r3, #0x0
 80143bc: b2db         	uxtb	r3, r3
 80143be: 2b00         	cmp	r3, #0x0
 80143c0: d1f0         	bne	0x80143a4 <z_device_state_init+0xc> @ imm = #-0x20
; }
 80143c2: bf00         	nop
 80143c4: bf00         	nop
 80143c6: 3708         	adds	r7, #0x8
 80143c8: 46bd         	mov	sp, r7
 80143ca: bd80         	pop	{r7, pc}

080143cc <$d>:
 80143cc: c0 96 02 08  	.word	0x080296c0
 80143d0: a8 9a 02 08  	.word	0x08029aa8

080143d4 <k_sys_fatal_error_handler>:
; {
 80143d4: b580         	push	{r7, lr}
 80143d6: b088         	sub	sp, #0x20
 80143d8: af04         	add	r7, sp, #0x10
 80143da: 6078         	str	r0, [r7, #0x4]
 80143dc: 6039         	str	r1, [r7]
; 	LOG_PANIC();
 80143de: f012 f829    	bl	0x8026434 <log_panic>   @ imm = #0x12052
; 	LOG_ERR("Halting system");
 80143e2: 2303         	movs	r3, #0x3
 80143e4: 2b00         	cmp	r3, #0x0
 80143e6: d016         	beq	0x8014416 <k_sys_fatal_error_handler+0x42> @ imm = #0x2c
 80143e8: 2301         	movs	r3, #0x1
 80143ea: 73fb         	strb	r3, [r7, #0xf]
 80143ec: 7bfb         	ldrb	r3, [r7, #0xf]
 80143ee: f083 0301    	eor	r3, r3, #0x1
 80143f2: b2db         	uxtb	r3, r3
 80143f4: 2b00         	cmp	r3, #0x0
 80143f6: d10e         	bne	0x8014416 <k_sys_fatal_error_handler+0x42> @ imm = #0x1c
 80143f8: 4b08         	ldr	r3, [pc, #0x20]         @ 0x801441c <k_sys_fatal_error_handler+0x48>
 80143fa: 6819         	ldr	r1, [r3]
 80143fc: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8014420 <k_sys_fatal_error_handler+0x4c>
 80143fe: 9302         	str	r3, [sp, #0x8]
 8014400: 2300         	movs	r3, #0x0
 8014402: 9301         	str	r3, [sp, #0x4]
 8014404: 2300         	movs	r3, #0x0
 8014406: 9300         	str	r3, [sp]
 8014408: 2300         	movs	r3, #0x0
 801440a: 2201         	movs	r2, #0x1
 801440c: 2000         	movs	r0, #0x0
 801440e: f011 fff3    	bl	0x80263f8 <z_log_msg_runtime_create> @ imm = #0x11fe6
 8014412: 2300         	movs	r3, #0x0
 8014414: 60bb         	str	r3, [r7, #0x8]
; 	arch_system_halt(reason);
 8014416: 6878         	ldr	r0, [r7, #0x4]
 8014418: f012 f81e    	bl	0x8026458 <arch_system_halt> @ imm = #0x1203c

0801441c <$d>:
 801441c: 50 0b 00 24  	.word	0x24000b50
 8014420: 00 c7 02 08  	.word	0x0802c700

08014424 <thread_name_get>:
; {
 8014424: b580         	push	{r7, lr}
 8014426: b084         	sub	sp, #0x10
 8014428: af00         	add	r7, sp, #0x0
 801442a: 6078         	str	r0, [r7, #0x4]
; 	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
 801442c: 687b         	ldr	r3, [r7, #0x4]
 801442e: 2b00         	cmp	r3, #0x0
 8014430: d004         	beq	0x801443c <thread_name_get+0x18> @ imm = #0x8
 8014432: 6878         	ldr	r0, [r7, #0x4]
 8014434: f013 fde9    	bl	0x802800a <k_thread_name_get> @ imm = #0x13bd2
 8014438: 4603         	mov	r3, r0
 801443a: e000         	b	0x801443e <thread_name_get+0x1a> @ imm = #0x0
 801443c: 2300         	movs	r3, #0x0
 801443e: 60fb         	str	r3, [r7, #0xc]
; 	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
 8014440: 68fb         	ldr	r3, [r7, #0xc]
 8014442: 2b00         	cmp	r3, #0x0
 8014444: d003         	beq	0x801444e <thread_name_get+0x2a> @ imm = #0x6
 8014446: 68fb         	ldr	r3, [r7, #0xc]
 8014448: 781b         	ldrb	r3, [r3]
 801444a: 2b00         	cmp	r3, #0x0
 801444c: d101         	bne	0x8014452 <thread_name_get+0x2e> @ imm = #0x2
; 		thread_name = "unknown";
 801444e: 4b03         	ldr	r3, [pc, #0xc]          @ 0x801445c <thread_name_get+0x38>
 8014450: 60fb         	str	r3, [r7, #0xc]
; 	return thread_name;
 8014452: 68fb         	ldr	r3, [r7, #0xc]
; }
 8014454: 4618         	mov	r0, r3
 8014456: 3710         	adds	r7, #0x10
 8014458: 46bd         	mov	sp, r7
 801445a: bd80         	pop	{r7, pc}

0801445c <$d>:
 801445c: 10 c7 02 08  	.word	0x0802c710

08014460 <reason_to_str>:
; {
 8014460: b480         	push	{r7}
 8014462: b083         	sub	sp, #0xc
 8014464: af00         	add	r7, sp, #0x0
 8014466: 6078         	str	r0, [r7, #0x4]
; 	switch (reason) {
 8014468: 687b         	ldr	r3, [r7, #0x4]
 801446a: 2b04         	cmp	r3, #0x4
 801446c: d816         	bhi	0x801449c <reason_to_str+0x3c> @ imm = #0x2c
 801446e: a201         	adr	r2, #4 <reason_to_str+0x13>
 8014470: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08014474 <$d>:
 8014474: 89 44 01 08  	.word	0x08014489
 8014478: 8d 44 01 08  	.word	0x0801448d
 801447c: 91 44 01 08  	.word	0x08014491
 8014480: 95 44 01 08  	.word	0x08014495
 8014484: 99 44 01 08  	.word	0x08014499

08014488 <$t>:
; 		return "CPU exception";
 8014488: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80144ac <reason_to_str+0x4c>
 801448a: e008         	b	0x801449e <reason_to_str+0x3e> @ imm = #0x10
; 		return "Unhandled interrupt";
 801448c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80144b0 <reason_to_str+0x50>
 801448e: e006         	b	0x801449e <reason_to_str+0x3e> @ imm = #0xc
; 		return "Stack overflow";
 8014490: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80144b4 <reason_to_str+0x54>
 8014492: e004         	b	0x801449e <reason_to_str+0x3e> @ imm = #0x8
; 		return "Kernel oops";
 8014494: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80144b8 <reason_to_str+0x58>
 8014496: e002         	b	0x801449e <reason_to_str+0x3e> @ imm = #0x4
; 		return "Kernel panic";
 8014498: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80144bc <reason_to_str+0x5c>
 801449a: e000         	b	0x801449e <reason_to_str+0x3e> @ imm = #0x0
; 		return "Unknown error";
 801449c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80144c0 <reason_to_str+0x60>
; }
 801449e: 4618         	mov	r0, r3
 80144a0: 370c         	adds	r7, #0xc
 80144a2: 46bd         	mov	sp, r7
 80144a4: f85d 7b04    	ldr	r7, [sp], #4
 80144a8: 4770         	bx	lr
 80144aa: bf00         	nop

080144ac <$d>:
 80144ac: 18 c7 02 08  	.word	0x0802c718
 80144b0: 28 c7 02 08  	.word	0x0802c728
 80144b4: 3c c7 02 08  	.word	0x0802c73c
 80144b8: 4c c7 02 08  	.word	0x0802c74c
 80144bc: 58 c7 02 08  	.word	0x0802c758
 80144c0: 68 c7 02 08  	.word	0x0802c768

080144c4 <z_fatal_error>:
; {
 80144c4: b590         	push	{r4, r7, lr}
 80144c6: b099         	sub	sp, #0x64
 80144c8: af06         	add	r7, sp, #0x18
 80144ca: 6078         	str	r0, [r7, #0x4]
 80144cc: 6039         	str	r1, [r7]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80144ce: f3ef 8311    	mrs	r3, basepri
 80144d2: 623b         	str	r3, [r7, #0x20]
;   return(result);
 80144d4: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 80144d6: 61fb         	str	r3, [r7, #0x1c]
 80144d8: 2310         	movs	r3, #0x10
 80144da: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80144dc: 69bb         	ldr	r3, [r7, #0x18]
 80144de: f383 8812    	msr	basepri_max, r3
; }
 80144e2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80144e4: f3bf 8f6f    	isb	sy
; }
 80144e8: bf00         	nop
; 	return key;
 80144ea: 69fb         	ldr	r3, [r7, #0x1c]
; 	unsigned int key = arch_irq_lock();
 80144ec: 63bb         	str	r3, [r7, #0x38]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80144ee: 4b50         	ldr	r3, [pc, #0x140]        @ 0x8014630 <z_fatal_error+0x16c>
 80144f0: 689b         	ldr	r3, [r3, #0x8]
 80144f2: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 80144f4: 6a7b         	ldr	r3, [r7, #0x24]
; 	struct k_thread *thread = IS_ENABLED(CONFIG_MULTITHREADING) ? arch_current_thread() : NULL;
 80144f6: 643b         	str	r3, [r7, #0x40]
; 	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason, reason_to_str(reason),
 80144f8: 2303         	movs	r3, #0x3
 80144fa: 2b00         	cmp	r3, #0x0
 80144fc: d023         	beq	0x8014546 <z_fatal_error+0x82> @ imm = #0x46
 80144fe: 2301         	movs	r3, #0x1
 8014500: f887 303f    	strb.w	r3, [r7, #0x3f]
 8014504: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8014508: f083 0301    	eor	r3, r3, #0x1
 801450c: b2db         	uxtb	r3, r3
 801450e: 2b00         	cmp	r3, #0x0
 8014510: d119         	bne	0x8014546 <z_fatal_error+0x82> @ imm = #0x32
 8014512: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8014634 <z_fatal_error+0x170>
 8014514: 681c         	ldr	r4, [r3]
 8014516: 6878         	ldr	r0, [r7, #0x4]
 8014518: f7ff ffa2    	bl	0x8014460 <reason_to_str> @ imm = #-0xbc
 801451c: 4603         	mov	r3, r0
 801451e: 4a44         	ldr	r2, [pc, #0x110]        @ 0x8014630 <z_fatal_error+0x16c>
 8014520: 7c12         	ldrb	r2, [r2, #0x10]
 8014522: 9205         	str	r2, [sp, #0x14]
 8014524: 9304         	str	r3, [sp, #0x10]
 8014526: 687b         	ldr	r3, [r7, #0x4]
 8014528: 9303         	str	r3, [sp, #0xc]
 801452a: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8014638 <z_fatal_error+0x174>
 801452c: 9302         	str	r3, [sp, #0x8]
 801452e: 2300         	movs	r3, #0x0
 8014530: 9301         	str	r3, [sp, #0x4]
 8014532: 2300         	movs	r3, #0x0
 8014534: 9300         	str	r3, [sp]
 8014536: 2300         	movs	r3, #0x0
 8014538: 2201         	movs	r2, #0x1
 801453a: 4621         	mov	r1, r4
 801453c: 2000         	movs	r0, #0x0
 801453e: f011 ff5b    	bl	0x80263f8 <z_log_msg_runtime_create> @ imm = #0x11eb6
 8014542: 2300         	movs	r3, #0x0
 8014544: 647b         	str	r3, [r7, #0x44]
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 8014546: 683b         	ldr	r3, [r7]
 8014548: 2b00         	cmp	r3, #0x0
 801454a: d028         	beq	0x801459e <z_fatal_error+0xda> @ imm = #0x50
 801454c: 683b         	ldr	r3, [r7]
 801454e: 617b         	str	r3, [r7, #0x14]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 8014550: 697b         	ldr	r3, [r7, #0x14]
 8014552: 69db         	ldr	r3, [r3, #0x1c]
 8014554: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8014558: 2b00         	cmp	r3, #0x0
 801455a: bf14         	ite	ne
 801455c: 2301         	movne	r3, #0x1
 801455e: 2300         	moveq	r3, #0x0
 8014560: b2db         	uxtb	r3, r3
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 8014562: 2b00         	cmp	r3, #0x0
 8014564: d01b         	beq	0x801459e <z_fatal_error+0xda> @ imm = #0x36
; 		LOG_ERR("Fault during interrupt handling\n");
 8014566: 2303         	movs	r3, #0x3
 8014568: 2b00         	cmp	r3, #0x0
 801456a: d018         	beq	0x801459e <z_fatal_error+0xda> @ imm = #0x30
 801456c: 2301         	movs	r3, #0x1
 801456e: f887 3037    	strb.w	r3, [r7, #0x37]
 8014572: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8014576: f083 0301    	eor	r3, r3, #0x1
 801457a: b2db         	uxtb	r3, r3
 801457c: 2b00         	cmp	r3, #0x0
 801457e: d10e         	bne	0x801459e <z_fatal_error+0xda> @ imm = #0x1c
 8014580: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8014634 <z_fatal_error+0x170>
 8014582: 6819         	ldr	r1, [r3]
 8014584: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x801463c <z_fatal_error+0x178>
 8014586: 9302         	str	r3, [sp, #0x8]
 8014588: 2300         	movs	r3, #0x0
 801458a: 9301         	str	r3, [sp, #0x4]
 801458c: 2300         	movs	r3, #0x0
 801458e: 9300         	str	r3, [sp]
 8014590: 2300         	movs	r3, #0x0
 8014592: 2201         	movs	r2, #0x1
 8014594: 2000         	movs	r0, #0x0
 8014596: f011 ff2f    	bl	0x80263f8 <z_log_msg_runtime_create> @ imm = #0x11e5e
 801459a: 2300         	movs	r3, #0x0
 801459c: 633b         	str	r3, [r7, #0x30]
; 		LOG_ERR("Current thread: %p (%s)", thread, thread_name_get(thread));
 801459e: 2303         	movs	r3, #0x3
 80145a0: 2b00         	cmp	r3, #0x0
 80145a2: d020         	beq	0x80145e6 <z_fatal_error+0x122> @ imm = #0x40
 80145a4: 2301         	movs	r3, #0x1
 80145a6: f887 302f    	strb.w	r3, [r7, #0x2f]
 80145aa: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 80145ae: f083 0301    	eor	r3, r3, #0x1
 80145b2: b2db         	uxtb	r3, r3
 80145b4: 2b00         	cmp	r3, #0x0
 80145b6: d116         	bne	0x80145e6 <z_fatal_error+0x122> @ imm = #0x2c
 80145b8: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8014634 <z_fatal_error+0x170>
 80145ba: 681c         	ldr	r4, [r3]
 80145bc: 6c38         	ldr	r0, [r7, #0x40]
 80145be: f7ff ff31    	bl	0x8014424 <thread_name_get> @ imm = #-0x19e
 80145c2: 4603         	mov	r3, r0
 80145c4: 9304         	str	r3, [sp, #0x10]
 80145c6: 6c3b         	ldr	r3, [r7, #0x40]
 80145c8: 9303         	str	r3, [sp, #0xc]
 80145ca: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8014640 <z_fatal_error+0x17c>
 80145cc: 9302         	str	r3, [sp, #0x8]
 80145ce: 2300         	movs	r3, #0x0
 80145d0: 9301         	str	r3, [sp, #0x4]
 80145d2: 2300         	movs	r3, #0x0
 80145d4: 9300         	str	r3, [sp]
 80145d6: 2300         	movs	r3, #0x0
 80145d8: 2201         	movs	r2, #0x1
 80145da: 4621         	mov	r1, r4
 80145dc: 2000         	movs	r0, #0x0
 80145de: f011 ff0b    	bl	0x80263f8 <z_log_msg_runtime_create> @ imm = #0x11e16
 80145e2: 2300         	movs	r3, #0x0
 80145e4: 62bb         	str	r3, [r7, #0x28]
; 	coredump(reason, esf, thread);
 80145e6: 6c3a         	ldr	r2, [r7, #0x40]
 80145e8: 6839         	ldr	r1, [r7]
 80145ea: 6878         	ldr	r0, [r7, #0x4]
 80145ec: f011 ff28    	bl	0x8026440 <coredump>    @ imm = #0x11e50
; 	k_sys_fatal_error_handler(reason, esf);
 80145f0: 6839         	ldr	r1, [r7]
 80145f2: 6878         	ldr	r0, [r7, #0x4]
 80145f4: f7ff feee    	bl	0x80143d4 <k_sys_fatal_error_handler> @ imm = #-0x224
; 		if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 80145f8: 683b         	ldr	r3, [r7]
 80145fa: 2b00         	cmp	r3, #0x0
 80145fc: d006         	beq	0x801460c <z_fatal_error+0x148> @ imm = #0xc
 80145fe: 683b         	ldr	r3, [r7]
 8014600: 613b         	str	r3, [r7, #0x10]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 8014602: 693b         	ldr	r3, [r7, #0x10]
 8014604: 69db         	ldr	r3, [r3, #0x1c]
 8014606: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 801460a: 2b00         	cmp	r3, #0x0
 801460c: 6bbb         	ldr	r3, [r7, #0x38]
 801460e: 60fb         	str	r3, [r7, #0xc]
 8014610: 68fb         	ldr	r3, [r7, #0xc]
 8014612: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8014614: 68bb         	ldr	r3, [r7, #0x8]
 8014616: f383 8811    	msr	basepri, r3
; }
 801461a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801461c: f3bf 8f6f    	isb	sy
; }
 8014620: bf00         	nop
; }
 8014622: bf00         	nop
; 		k_thread_abort(thread);
 8014624: 6c38         	ldr	r0, [r7, #0x40]
 8014626: f011 fedc    	bl	0x80263e2 <k_thread_abort> @ imm = #0x11db8
; }
 801462a: 374c         	adds	r7, #0x4c
 801462c: 46bd         	mov	sp, r7
 801462e: bd90         	pop	{r4, r7, pc}

08014630 <$d>:
 8014630: 60 20 00 24  	.word	0x24002060
 8014634: 50 0b 00 24  	.word	0x24000b50
 8014638: 78 c7 02 08  	.word	0x0802c778
 801463c: a0 c7 02 08  	.word	0x0802c7a0
 8014640: c4 c7 02 08  	.word	0x0802c7c4

08014644 <__NVIC_SetPriority>:
; {
 8014644: b480         	push	{r7}
 8014646: b083         	sub	sp, #0xc
 8014648: af00         	add	r7, sp, #0x0
 801464a: 4603         	mov	r3, r0
 801464c: 6039         	str	r1, [r7]
 801464e: 80fb         	strh	r3, [r7, #0x6]
;   if ((int32_t)(IRQn) >= 0)
 8014650: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 8014654: 2b00         	cmp	r3, #0x0
 8014656: db0a         	blt	0x801466e <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8014658: 683b         	ldr	r3, [r7]
 801465a: b2da         	uxtb	r2, r3
 801465c: 490c         	ldr	r1, [pc, #0x30]         @ 0x8014690 <__NVIC_SetPriority+0x4c>
 801465e: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 8014662: 0112         	lsls	r2, r2, #0x4
 8014664: b2d2         	uxtb	r2, r2
 8014666: 440b         	add	r3, r1
 8014668: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 801466c: e00a         	b	0x8014684 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 801466e: 683b         	ldr	r3, [r7]
 8014670: b2da         	uxtb	r2, r3
 8014672: 4908         	ldr	r1, [pc, #0x20]         @ 0x8014694 <__NVIC_SetPriority+0x50>
 8014674: 88fb         	ldrh	r3, [r7, #0x6]
 8014676: f003 030f    	and	r3, r3, #0xf
 801467a: 3b04         	subs	r3, #0x4
 801467c: 0112         	lsls	r2, r2, #0x4
 801467e: b2d2         	uxtb	r2, r2
 8014680: 440b         	add	r3, r1
 8014682: 761a         	strb	r2, [r3, #0x18]
; }
 8014684: bf00         	nop
 8014686: 370c         	adds	r7, #0xc
 8014688: 46bd         	mov	sp, r7
 801468a: f85d 7b04    	ldr	r7, [sp], #4
 801468e: 4770         	bx	lr

08014690 <$d>:
 8014690: 00 e1 00 e0  	.word	0xe000e100
 8014694: 00 ed 00 e0  	.word	0xe000ed00

08014698 <z_add_thread_timeout>:
; {
 8014698: b580         	push	{r7, lr}
 801469a: b084         	sub	sp, #0x10
 801469c: af00         	add	r7, sp, #0x0
 801469e: 60f8         	str	r0, [r7, #0xc]
 80146a0: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 80146a4: 68fb         	ldr	r3, [r7, #0xc]
 80146a6: f103 0018    	add.w	r0, r3, #0x18
 80146aa: e9d7 2300    	ldrd	r2, r3, [r7]
 80146ae: 4903         	ldr	r1, [pc, #0xc]          @ 0x80146bc <z_add_thread_timeout+0x24>
 80146b0: f003 fcf2    	bl	0x8018098 <z_add_timeout> @ imm = #0x39e4
; }
 80146b4: bf00         	nop
 80146b6: 3710         	adds	r7, #0x10
 80146b8: 46bd         	mov	sp, r7
 80146ba: bd80         	pop	{r7, pc}

080146bc <$d>:
 80146bc: d3 88 02 08  	.word	0x080288d3

080146c0 <z_dummy_thread_init>:
; {
 80146c0: b580         	push	{r7, lr}
 80146c2: b084         	sub	sp, #0x10
 80146c4: af00         	add	r7, sp, #0x0
 80146c6: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 80146c8: 687b         	ldr	r3, [r7, #0x4]
 80146ca: 2201         	movs	r2, #0x1
 80146cc: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 80146ce: 687b         	ldr	r3, [r7, #0x4]
 80146d0: 2201         	movs	r2, #0x1
 80146d2: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 80146d4: 687b         	ldr	r3, [r7, #0x4]
 80146d6: 2200         	movs	r2, #0x0
 80146d8: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 80146dc: 687b         	ldr	r3, [r7, #0x4]
 80146de: 2200         	movs	r2, #0x0
 80146e0: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	k_thread_system_pool_assign(dummy_thread);
 80146e4: 6878         	ldr	r0, [r7, #0x4]
 80146e6: f004 f8c3    	bl	0x8018870 <k_thread_system_pool_assign> @ imm = #0x4186
 80146ea: 687b         	ldr	r3, [r7, #0x4]
 80146ec: 60fb         	str	r3, [r7, #0xc]
; 	_current_cpu->current = thread;
 80146ee: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8014700 <z_dummy_thread_init+0x40>
 80146f0: 68fb         	ldr	r3, [r7, #0xc]
 80146f2: 6093         	str	r3, [r2, #0x8]
; }
 80146f4: bf00         	nop
; }
 80146f6: bf00         	nop
 80146f8: 3710         	adds	r7, #0x10
 80146fa: 46bd         	mov	sp, r7
 80146fc: bd80         	pop	{r7, pc}
 80146fe: bf00         	nop

08014700 <$d>:
 8014700: 60 20 00 24  	.word	0x24002060

08014704 <z_init_static_threads>:
; {
 8014704: b5f0         	push	{r4, r5, r6, r7, lr}
 8014706: b08f         	sub	sp, #0x3c
 8014708: af06         	add	r7, sp, #0x18
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 801470a: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80147d0 <z_init_static_threads+0xcc>
 801470c: 61fb         	str	r3, [r7, #0x1c]
 801470e: e029         	b	0x8014764 <z_init_static_threads+0x60> @ imm = #0x52
; 		z_setup_new_thread(
 8014710: 69fb         	ldr	r3, [r7, #0x1c]
 8014712: 681e         	ldr	r6, [r3]
 8014714: 69fb         	ldr	r3, [r7, #0x1c]
 8014716: 685b         	ldr	r3, [r3, #0x4]
 8014718: 60fb         	str	r3, [r7, #0xc]
 801471a: 69fb         	ldr	r3, [r7, #0x1c]
 801471c: 689a         	ldr	r2, [r3, #0x8]
 801471e: 60ba         	str	r2, [r7, #0x8]
 8014720: 69fb         	ldr	r3, [r7, #0x1c]
 8014722: 68d8         	ldr	r0, [r3, #0xc]
 8014724: 6078         	str	r0, [r7, #0x4]
 8014726: 69fb         	ldr	r3, [r7, #0x1c]
 8014728: 691b         	ldr	r3, [r3, #0x10]
 801472a: 69fa         	ldr	r2, [r7, #0x1c]
 801472c: 6952         	ldr	r2, [r2, #0x14]
 801472e: 69f9         	ldr	r1, [r7, #0x1c]
 8014730: 6989         	ldr	r1, [r1, #0x18]
 8014732: 69f8         	ldr	r0, [r7, #0x1c]
 8014734: 69c0         	ldr	r0, [r0, #0x1c]
 8014736: 69fc         	ldr	r4, [r7, #0x1c]
 8014738: 6a24         	ldr	r4, [r4, #0x20]
 801473a: 69fd         	ldr	r5, [r7, #0x1c]
 801473c: 6a6d         	ldr	r5, [r5, #0x24]
 801473e: 9505         	str	r5, [sp, #0x14]
 8014740: 9404         	str	r4, [sp, #0x10]
 8014742: 9003         	str	r0, [sp, #0xc]
 8014744: 9102         	str	r1, [sp, #0x8]
 8014746: 9201         	str	r2, [sp, #0x4]
 8014748: 9300         	str	r3, [sp]
 801474a: 687b         	ldr	r3, [r7, #0x4]
 801474c: 68ba         	ldr	r2, [r7, #0x8]
 801474e: 68f9         	ldr	r1, [r7, #0xc]
 8014750: 4630         	mov	r0, r6
 8014752: f001 fc8f    	bl	0x8016074 <z_setup_new_thread> @ imm = #0x191e
; 		thread_data->init_thread->init_data = thread_data;
 8014756: 69fb         	ldr	r3, [r7, #0x1c]
 8014758: 681b         	ldr	r3, [r3]
 801475a: 69fa         	ldr	r2, [r7, #0x1c]
 801475c: 665a         	str	r2, [r3, #0x64]
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 801475e: 69fb         	ldr	r3, [r7, #0x1c]
 8014760: 3330         	adds	r3, #0x30
 8014762: 61fb         	str	r3, [r7, #0x1c]
 8014764: 69fb         	ldr	r3, [r7, #0x1c]
 8014766: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x80147d4 <z_init_static_threads+0xd0>
 8014768: 4293         	cmp	r3, r2
 801476a: bf34         	ite	lo
 801476c: 2301         	movlo	r3, #0x1
 801476e: 2300         	movhs	r3, #0x0
 8014770: b2db         	uxtb	r3, r3
 8014772: 2b00         	cmp	r3, #0x0
 8014774: d1cc         	bne	0x8014710 <z_init_static_threads+0xc> @ imm = #-0x68
; 	k_sched_lock();
 8014776: f002 fce5    	bl	0x8017144 <k_sched_lock> @ imm = #0x29ca
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 801477a: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80147d0 <z_init_static_threads+0xcc>
 801477c: 61bb         	str	r3, [r7, #0x18]
 801477e: e018         	b	0x80147b2 <z_init_static_threads+0xae> @ imm = #0x30
; 		k_timeout_t init_delay = Z_THREAD_INIT_DELAY(thread_data);
 8014780: 69bb         	ldr	r3, [r7, #0x18]
 8014782: e9d3 230a    	ldrd	r2, r3, [r3, #40]
 8014786: e9c7 2304    	strd	r2, r3, [r7, #16]
; 		if (!K_TIMEOUT_EQ(init_delay, K_FOREVER)) {
 801478a: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 801478e: f04f 30ff    	mov.w	r0, #0xffffffff
 8014792: f04f 31ff    	mov.w	r1, #0xffffffff
 8014796: 428b         	cmp	r3, r1
 8014798: bf08         	it	eq
 801479a: 4282         	cmpeq	r2, r0
 801479c: d006         	beq	0x80147ac <z_init_static_threads+0xa8> @ imm = #0xc
; 			thread_schedule_new(thread_data->init_thread,
 801479e: 69bb         	ldr	r3, [r7, #0x18]
 80147a0: 6819         	ldr	r1, [r3]
 80147a2: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 80147a6: 4608         	mov	r0, r1
 80147a8: f011 fe8b    	bl	0x80264c2 <thread_schedule_new> @ imm = #0x11d16
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 80147ac: 69bb         	ldr	r3, [r7, #0x18]
 80147ae: 3330         	adds	r3, #0x30
 80147b0: 61bb         	str	r3, [r7, #0x18]
 80147b2: 69bb         	ldr	r3, [r7, #0x18]
 80147b4: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80147d4 <z_init_static_threads+0xd0>
 80147b6: 4293         	cmp	r3, r2
 80147b8: bf34         	ite	lo
 80147ba: 2301         	movlo	r3, #0x1
 80147bc: 2300         	movhs	r3, #0x0
 80147be: b2db         	uxtb	r3, r3
 80147c0: 2b00         	cmp	r3, #0x0
 80147c2: d1dd         	bne	0x8014780 <z_init_static_threads+0x7c> @ imm = #-0x46
; 	k_sched_unlock();
 80147c4: f002 fcfe    	bl	0x80171c4 <k_sched_unlock> @ imm = #0x29fc
; }
 80147c8: bf00         	nop
 80147ca: 3724         	adds	r7, #0x24
 80147cc: 46bd         	mov	sp, r7
 80147ce: bdf0         	pop	{r4, r5, r6, r7, pc}

080147d0 <$d>:
 80147d0: c0 9f 02 08  	.word	0x08029fc0
 80147d4: 20 a0 02 08  	.word	0x0802a020

080147d8 <z_bss_zero>:
; {
 80147d8: b580         	push	{r7, lr}
 80147da: af00         	add	r7, sp, #0x0
; 	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
 80147dc: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80147f0 <z_bss_zero+0x18>
 80147de: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80147f4 <z_bss_zero+0x1c>
 80147e0: 1ad3         	subs	r3, r2, r3
 80147e2: 461a         	mov	r2, r3
 80147e4: 2100         	movs	r1, #0x0
 80147e6: 4803         	ldr	r0, [pc, #0xc]          @ 0x80147f4 <z_bss_zero+0x1c>
 80147e8: f011 febc    	bl	0x8026564 <z_early_memset> @ imm = #0x11d78
; }
 80147ec: bd80         	pop	{r7, pc}
 80147ee: bf00         	nop

080147f0 <$d>:
 80147f0: f4 32 00 24  	.word	0x240032f4
 80147f4: 88 0c 00 24  	.word	0x24000c88

080147f8 <z_sys_init_run_level>:
; {
 80147f8: b580         	push	{r7, lr}
 80147fa: b086         	sub	sp, #0x18
 80147fc: af00         	add	r7, sp, #0x0
 80147fe: 4603         	mov	r3, r0
 8014800: 71fb         	strb	r3, [r7, #0x7]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 8014802: 79fb         	ldrb	r3, [r7, #0x7]
 8014804: 4a11         	ldr	r2, [pc, #0x44]         @ 0x801484c <z_sys_init_run_level+0x54>
 8014806: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 801480a: 617b         	str	r3, [r7, #0x14]
 801480c: e011         	b	0x8014832 <z_sys_init_run_level+0x3a> @ imm = #0x22
; 		const struct device *dev = entry->dev;
 801480e: 697b         	ldr	r3, [r7, #0x14]
 8014810: 685b         	ldr	r3, [r3, #0x4]
 8014812: 613b         	str	r3, [r7, #0x10]
; 		if (dev != NULL) {
 8014814: 693b         	ldr	r3, [r7, #0x10]
 8014816: 2b00         	cmp	r3, #0x0
 8014818: d004         	beq	0x8014824 <z_sys_init_run_level+0x2c> @ imm = #0x8
; 			result = do_device_init(entry);
 801481a: 6978         	ldr	r0, [r7, #0x14]
 801481c: f011 fec0    	bl	0x80265a0 <do_device_init> @ imm = #0x11d80
 8014820: 60f8         	str	r0, [r7, #0xc]
 8014822: e003         	b	0x801482c <z_sys_init_run_level+0x34> @ imm = #0x6
; 			result = entry->init_fn.sys();
 8014824: 697b         	ldr	r3, [r7, #0x14]
 8014826: 681b         	ldr	r3, [r3]
 8014828: 4798         	blx	r3
 801482a: 60f8         	str	r0, [r7, #0xc]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 801482c: 697b         	ldr	r3, [r7, #0x14]
 801482e: 3308         	adds	r3, #0x8
 8014830: 617b         	str	r3, [r7, #0x14]
 8014832: 79fb         	ldrb	r3, [r7, #0x7]
 8014834: 3301         	adds	r3, #0x1
 8014836: 4a05         	ldr	r2, [pc, #0x14]         @ 0x801484c <z_sys_init_run_level+0x54>
 8014838: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 801483c: 697a         	ldr	r2, [r7, #0x14]
 801483e: 429a         	cmp	r2, r3
 8014840: d3e5         	blo	0x801480e <z_sys_init_run_level+0x16> @ imm = #-0x36
; }
 8014842: bf00         	nop
 8014844: bf00         	nop
 8014846: 3718         	adds	r7, #0x18
 8014848: 46bd         	mov	sp, r7
 801484a: bd80         	pop	{r7, pc}

0801484c <$d>:
 801484c: 54 0b 00 24  	.word	0x24000b54

08014850 <bg_thread_main>:
; {
 8014850: b580         	push	{r7, lr}
 8014852: b084         	sub	sp, #0x10
 8014854: af00         	add	r7, sp, #0x0
 8014856: 60f8         	str	r0, [r7, #0xc]
 8014858: 60b9         	str	r1, [r7, #0x8]
 801485a: 607a         	str	r2, [r7, #0x4]
; 	z_sys_post_kernel = true;
 801485c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x801488c <bg_thread_main+0x3c>
 801485e: 2201         	movs	r2, #0x1
 8014860: 701a         	strb	r2, [r3]
; 	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 8014862: 2003         	movs	r0, #0x3
 8014864: f7ff ffc8    	bl	0x80147f8 <z_sys_init_run_level> @ imm = #-0x70
; 	boot_banner();
 8014868: f004 f83c    	bl	0x80188e4 <boot_banner> @ imm = #0x4078
; 	z_init_static();
 801486c: f011 fece    	bl	0x802660c <z_init_static> @ imm = #0x11d9c
; 	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
 8014870: 2004         	movs	r0, #0x4
 8014872: f7ff ffc1    	bl	0x80147f8 <z_sys_init_run_level> @ imm = #-0x7e
; 	z_init_static_threads();
 8014876: f7ff ff45    	bl	0x8014704 <z_init_static_threads> @ imm = #-0x176
; 	(void)main();
 801487a: f7ee ffe3    	bl	0x8003844 <main>        @ imm = #-0x1103a
; 	z_thread_essential_clear(&z_main_thread);
 801487e: 4804         	ldr	r0, [pc, #0x10]         @ 0x8014890 <bg_thread_main+0x40>
 8014880: f011 fe4d    	bl	0x802651e <z_thread_essential_clear> @ imm = #0x11c9a
; } /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 8014884: bf00         	nop
 8014886: 3710         	adds	r7, #0x10
 8014888: 46bd         	mov	sp, r7
 801488a: bd80         	pop	{r7, pc}

0801488c <$d>:
 801488c: f2 32 00 24  	.word	0x240032f2
 8014890: a8 20 00 24  	.word	0x240020a8

08014894 <init_idle_thread>:
; {
 8014894: b580         	push	{r7, lr}
 8014896: b08c         	sub	sp, #0x30
 8014898: af06         	add	r7, sp, #0x18
 801489a: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = &z_idle_threads[i];
 801489c: 687b         	ldr	r3, [r7, #0x4]
 801489e: f44f 728c    	mov.w	r2, #0x118
 80148a2: fb02 f303    	mul	r3, r2, r3
 80148a6: 4a16         	ldr	r2, [pc, #0x58]         @ 0x8014900 <init_idle_thread+0x6c>
 80148a8: 4413         	add	r3, r2
 80148aa: 617b         	str	r3, [r7, #0x14]
; 	k_thread_stack_t *stack = z_idle_stacks[i];
 80148ac: 687a         	ldr	r2, [r7, #0x4]
 80148ae: 4613         	mov	r3, r2
 80148b0: 009b         	lsls	r3, r3, #0x2
 80148b2: 4413         	add	r3, r2
 80148b4: 019b         	lsls	r3, r3, #0x6
 80148b6: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x8014904 <init_idle_thread+0x70>
 80148b8: 4413         	add	r3, r2
 80148ba: 613b         	str	r3, [r7, #0x10]
; 	size_t stack_size = K_KERNEL_STACK_SIZEOF(z_idle_stacks[i]);
 80148bc: f44f 73a0    	mov.w	r3, #0x140
 80148c0: 60fb         	str	r3, [r7, #0xc]
; 	char *tname = "idle";
 80148c2: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8014908 <init_idle_thread+0x74>
 80148c4: 60bb         	str	r3, [r7, #0x8]
; 			  stack_size, idle, &_kernel.cpus[i],
 80148c6: 687b         	ldr	r3, [r7, #0x4]
 80148c8: 015b         	lsls	r3, r3, #0x5
 80148ca: 4a10         	ldr	r2, [pc, #0x40]         @ 0x801490c <init_idle_thread+0x78>
 80148cc: 4413         	add	r3, r2
; 	z_setup_new_thread(thread, stack,
 80148ce: 68ba         	ldr	r2, [r7, #0x8]
 80148d0: 9205         	str	r2, [sp, #0x14]
 80148d2: 2201         	movs	r2, #0x1
 80148d4: 9204         	str	r2, [sp, #0x10]
 80148d6: 220f         	movs	r2, #0xf
 80148d8: 9203         	str	r2, [sp, #0xc]
 80148da: 2200         	movs	r2, #0x0
 80148dc: 9202         	str	r2, [sp, #0x8]
 80148de: 2200         	movs	r2, #0x0
 80148e0: 9201         	str	r2, [sp, #0x4]
 80148e2: 9300         	str	r3, [sp]
 80148e4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8014910 <init_idle_thread+0x7c>
 80148e6: 68fa         	ldr	r2, [r7, #0xc]
 80148e8: 6939         	ldr	r1, [r7, #0x10]
 80148ea: 6978         	ldr	r0, [r7, #0x14]
 80148ec: f001 fbc2    	bl	0x8016074 <z_setup_new_thread> @ imm = #0x1784
; 	z_mark_thread_as_not_suspended(thread);
 80148f0: 6978         	ldr	r0, [r7, #0x14]
 80148f2: f011 fe03    	bl	0x80264fc <z_mark_thread_as_not_suspended> @ imm = #0x11c06
; }
 80148f6: bf00         	nop
 80148f8: 3718         	adds	r7, #0x18
 80148fa: 46bd         	mov	sp, r7
 80148fc: bd80         	pop	{r7, pc}
 80148fe: bf00         	nop

08014900 <$d>:
 8014900: c0 21 00 24  	.word	0x240021c0
 8014904: f8 55 00 24  	.word	0x240055f8
 8014908: e0 c7 02 08  	.word	0x0802c7e0
 801490c: 60 20 00 24  	.word	0x24002060
 8014910: 7f 6b 02 08  	.word	0x08026b7f

08014914 <z_init_cpu>:
; {
 8014914: b580         	push	{r7, lr}
 8014916: b082         	sub	sp, #0x8
 8014918: af00         	add	r7, sp, #0x0
 801491a: 6078         	str	r0, [r7, #0x4]
; 	init_idle_thread(id);
 801491c: 6878         	ldr	r0, [r7, #0x4]
 801491e: f7ff ffb9    	bl	0x8014894 <init_idle_thread> @ imm = #-0x8e
; 	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 8014922: 687b         	ldr	r3, [r7, #0x4]
 8014924: f44f 728c    	mov.w	r2, #0x118
 8014928: fb02 f303    	mul	r3, r2, r3
 801492c: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x801499c <z_init_cpu+0x88>
 801492e: 441a         	add	r2, r3
 8014930: 491b         	ldr	r1, [pc, #0x6c]         @ 0x80149a0 <z_init_cpu+0x8c>
 8014932: 687b         	ldr	r3, [r7, #0x4]
 8014934: 015b         	lsls	r3, r3, #0x5
 8014936: 440b         	add	r3, r1
 8014938: 330c         	adds	r3, #0xc
 801493a: 601a         	str	r2, [r3]
; 	_kernel.cpus[id].id = id;
 801493c: 687b         	ldr	r3, [r7, #0x4]
 801493e: b2d9         	uxtb	r1, r3
 8014940: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x80149a0 <z_init_cpu+0x8c>
 8014942: 687b         	ldr	r3, [r7, #0x4]
 8014944: 015b         	lsls	r3, r3, #0x5
 8014946: 4413         	add	r3, r2
 8014948: 3310         	adds	r3, #0x10
 801494a: 460a         	mov	r2, r1
 801494c: 701a         	strb	r2, [r3]
; 		(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 801494e: 687b         	ldr	r3, [r7, #0x4]
 8014950: 02db         	lsls	r3, r3, #0xb
 8014952: 4a14         	ldr	r2, [pc, #0x50]         @ 0x80149a4 <z_init_cpu+0x90>
 8014954: 4413         	add	r3, r2
 8014956: 4618         	mov	r0, r3
 8014958: f011 fd92    	bl	0x8026480 <K_KERNEL_STACK_BUFFER> @ imm = #0x11b24
 801495c: 4603         	mov	r3, r0
 801495e: f503 6200    	add.w	r2, r3, #0x800
; 	_kernel.cpus[id].irq_stack =
 8014962: 490f         	ldr	r1, [pc, #0x3c]         @ 0x80149a0 <z_init_cpu+0x8c>
 8014964: 687b         	ldr	r3, [r7, #0x4]
 8014966: 015b         	lsls	r3, r3, #0x5
 8014968: 440b         	add	r3, r1
 801496a: 3304         	adds	r3, #0x4
 801496c: 601a         	str	r2, [r3]
; 	_kernel.cpus[id].usage = &_kernel.usage[id];
 801496e: 687b         	ldr	r3, [r7, #0x4]
 8014970: 011b         	lsls	r3, r3, #0x4
 8014972: 3338         	adds	r3, #0x38
 8014974: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80149a0 <z_init_cpu+0x8c>
 8014976: 441a         	add	r2, r3
 8014978: 4909         	ldr	r1, [pc, #0x24]         @ 0x80149a0 <z_init_cpu+0x8c>
 801497a: 687b         	ldr	r3, [r7, #0x4]
 801497c: 015b         	lsls	r3, r3, #0x5
 801497e: 440b         	add	r3, r1
 8014980: 331c         	adds	r3, #0x1c
 8014982: 601a         	str	r2, [r3]
; 	_kernel.cpus[id].usage->track_usage =
 8014984: 4a06         	ldr	r2, [pc, #0x18]         @ 0x80149a0 <z_init_cpu+0x8c>
 8014986: 687b         	ldr	r3, [r7, #0x4]
 8014988: 015b         	lsls	r3, r3, #0x5
 801498a: 4413         	add	r3, r2
 801498c: 331c         	adds	r3, #0x1c
 801498e: 681b         	ldr	r3, [r3]
 8014990: 2201         	movs	r2, #0x1
 8014992: 721a         	strb	r2, [r3, #0x8]
; }
 8014994: bf00         	nop
 8014996: 3708         	adds	r7, #0x8
 8014998: 46bd         	mov	sp, r7
 801499a: bd80         	pop	{r7, pc}

0801499c <$d>:
 801499c: c0 21 00 24  	.word	0x240021c0
 80149a0: 60 20 00 24  	.word	0x24002060
 80149a4: 38 57 00 24  	.word	0x24005738

080149a8 <prepare_multithreading>:
; {
 80149a8: b580         	push	{r7, lr}
 80149aa: b088         	sub	sp, #0x20
 80149ac: af06         	add	r7, sp, #0x18
; 	z_sched_init();
 80149ae: f002 fce7    	bl	0x8017380 <z_sched_init> @ imm = #0x29ce
; 	_kernel.ready_q.cache = &z_main_thread;
 80149b2: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80149fc <prepare_multithreading+0x54>
 80149b4: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8014a00 <prepare_multithreading+0x58>
 80149b6: 621a         	str	r2, [r3, #0x20]
; 	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 80149b8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8014a04 <prepare_multithreading+0x5c>
 80149ba: 9305         	str	r3, [sp, #0x14]
 80149bc: 2301         	movs	r3, #0x1
 80149be: 9304         	str	r3, [sp, #0x10]
 80149c0: 2300         	movs	r3, #0x0
 80149c2: 9303         	str	r3, [sp, #0xc]
 80149c4: 2300         	movs	r3, #0x0
 80149c6: 9302         	str	r3, [sp, #0x8]
 80149c8: 2300         	movs	r3, #0x0
 80149ca: 9301         	str	r3, [sp, #0x4]
 80149cc: 2300         	movs	r3, #0x0
 80149ce: 9300         	str	r3, [sp]
 80149d0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8014a08 <prepare_multithreading+0x60>
 80149d2: f44f 6280    	mov.w	r2, #0x400
 80149d6: 490d         	ldr	r1, [pc, #0x34]         @ 0x8014a0c <prepare_multithreading+0x64>
 80149d8: 4809         	ldr	r0, [pc, #0x24]         @ 0x8014a00 <prepare_multithreading+0x58>
 80149da: f001 fb4b    	bl	0x8016074 <z_setup_new_thread> @ imm = #0x1696
 80149de: 6078         	str	r0, [r7, #0x4]
; 	z_mark_thread_as_not_suspended(&z_main_thread);
 80149e0: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8014a00 <prepare_multithreading+0x58>
 80149e2: f011 fd8b    	bl	0x80264fc <z_mark_thread_as_not_suspended> @ imm = #0x11b16
; 	z_ready_thread(&z_main_thread);
 80149e6: 4806         	ldr	r0, [pc, #0x18]         @ 0x8014a00 <prepare_multithreading+0x58>
 80149e8: f001 fe0c    	bl	0x8016604 <z_ready_thread> @ imm = #0x1c18
; 	z_init_cpu(0);
 80149ec: 2000         	movs	r0, #0x0
 80149ee: f7ff ff91    	bl	0x8014914 <z_init_cpu>  @ imm = #-0xde
; 	return stack_ptr;
 80149f2: 687b         	ldr	r3, [r7, #0x4]
; }
 80149f4: 4618         	mov	r0, r3
 80149f6: 3708         	adds	r7, #0x8
 80149f8: 46bd         	mov	sp, r7
 80149fa: bd80         	pop	{r7, pc}

080149fc <$d>:
 80149fc: 60 20 00 24  	.word	0x24002060
 8014a00: a8 20 00 24  	.word	0x240020a8
 8014a04: e8 c7 02 08  	.word	0x0802c7e8
 8014a08: 51 48 01 08  	.word	0x08014851
 8014a0c: f8 51 00 24  	.word	0x240051f8

08014a10 <switch_to_main_thread>:
; {
 8014a10: b580         	push	{r7, lr}
 8014a12: b082         	sub	sp, #0x8
 8014a14: af00         	add	r7, sp, #0x0
 8014a16: 6078         	str	r0, [r7, #0x4]
; 	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 8014a18: 4a02         	ldr	r2, [pc, #0x8]          @ 0x8014a24 <switch_to_main_thread+0x14>
 8014a1a: 6879         	ldr	r1, [r7, #0x4]
 8014a1c: 4802         	ldr	r0, [pc, #0x8]          @ 0x8014a28 <switch_to_main_thread+0x18>
 8014a1e: f7f1 febf    	bl	0x80067a0 <arch_switch_to_main_thread> @ imm = #-0xe282
 8014a22: bf00         	nop

08014a24 <$d>:
 8014a24: 51 48 01 08  	.word	0x08014851
 8014a28: a8 20 00 24  	.word	0x240020a8

08014a2c <z_cstart>:
; {
 8014a2c: b580         	push	{r7, lr}
 8014a2e: b082         	sub	sp, #0x8
 8014a30: af00         	add	r7, sp, #0x0
; 	gcov_static_init();
 8014a32: f011 fd85    	bl	0x8026540 <gcov_static_init> @ imm = #0x11b0a
; 	z_sys_init_run_level(INIT_LEVEL_EARLY);
 8014a36: 2000         	movs	r0, #0x0
 8014a38: f7ff fede    	bl	0x80147f8 <z_sys_init_run_level> @ imm = #-0x244
; 		(uint32_t)(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
 8014a3c: 482a         	ldr	r0, [pc, #0xa8]         @ 0x8014ae8 <z_cstart+0xbc>
 8014a3e: f011 fd1f    	bl	0x8026480 <K_KERNEL_STACK_BUFFER> @ imm = #0x11a3e
 8014a42: 4603         	mov	r3, r0
; 	uint32_t msp =
 8014a44: f503 6300    	add.w	r3, r3, #0x800
 8014a48: 607b         	str	r3, [r7, #0x4]
 8014a4a: 687b         	ldr	r3, [r7, #0x4]
 8014a4c: 603b         	str	r3, [r7]
;   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 8014a4e: 683b         	ldr	r3, [r7]
 8014a50: f383 8808    	msr	msp, r3
; }
 8014a54: bf00         	nop
; }
 8014a56: bf00         	nop
; 	NVIC_SetPriority(PendSV_IRQn, _EXC_PENDSV_PRIO);
 8014a58: 21ff         	movs	r1, #0xff
 8014a5a: f06f 0001    	mvn	r0, #0x1
 8014a5e: f7ff fdf1    	bl	0x8014644 <__NVIC_SetPriority> @ imm = #-0x41e
; 	NVIC_SetPriority(SVCall_IRQn, _EXC_SVC_PRIO);
 8014a62: 2100         	movs	r1, #0x0
 8014a64: f06f 0004    	mvn	r0, #0x4
 8014a68: f7ff fdec    	bl	0x8014644 <__NVIC_SetPriority> @ imm = #-0x428
; 	NVIC_SetPriority(MemoryManagement_IRQn, _EXC_FAULT_PRIO);
 8014a6c: 2100         	movs	r1, #0x0
 8014a6e: f06f 000b    	mvn	r0, #0xb
 8014a72: f7ff fde7    	bl	0x8014644 <__NVIC_SetPriority> @ imm = #-0x432
; 	NVIC_SetPriority(BusFault_IRQn, _EXC_FAULT_PRIO);
 8014a76: 2100         	movs	r1, #0x0
 8014a78: f06f 000a    	mvn	r0, #0xa
 8014a7c: f7ff fde2    	bl	0x8014644 <__NVIC_SetPriority> @ imm = #-0x43c
; 	NVIC_SetPriority(UsageFault_IRQn, _EXC_FAULT_PRIO);
 8014a80: 2100         	movs	r1, #0x0
 8014a82: f06f 0009    	mvn	r0, #0x9
 8014a86: f7ff fddd    	bl	0x8014644 <__NVIC_SetPriority> @ imm = #-0x446
; 	NVIC_SetPriority(DebugMonitor_IRQn, _EXC_FAULT_PRIO);
 8014a8a: 2100         	movs	r1, #0x0
 8014a8c: f06f 0003    	mvn	r0, #0x3
 8014a90: f7ff fdd8    	bl	0x8014644 <__NVIC_SetPriority> @ imm = #-0x450
; 	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 8014a94: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8014aec <z_cstart+0xc0>
 8014a96: 6a5b         	ldr	r3, [r3, #0x24]
 8014a98: 4a14         	ldr	r2, [pc, #0x50]         @ 0x8014aec <z_cstart+0xc0>
 8014a9a: f443 23e0    	orr	r3, r3, #0x70000
 8014a9e: 6253         	str	r3, [r2, #0x24]
; }
 8014aa0: bf00         	nop
; 	z_arm_fault_init();
 8014aa2: f7f1 fc51    	bl	0x8006348 <z_arm_fault_init> @ imm = #-0xe75e
; 	z_arm_cpu_idle_init();
 8014aa6: f7f1 feab    	bl	0x8006800 <z_arm_cpu_idle_init> @ imm = #-0xe2aa
; 	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 8014aaa: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8014aec <z_cstart+0xc0>
 8014aac: f04f 32ff    	mov.w	r2, #0xffffffff
 8014ab0: 629a         	str	r2, [r3, #0x28]
; 	SCB->HFSR = 0xffffffff;
 8014ab2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8014aec <z_cstart+0xc0>
 8014ab4: f04f 32ff    	mov.w	r2, #0xffffffff
 8014ab8: 62da         	str	r2, [r3, #0x2c]
; }
 8014aba: bf00         	nop
; }
 8014abc: bf00         	nop
; 	LOG_CORE_INIT();
 8014abe: f7ef fe47    	bl	0x8004750 <log_core_init> @ imm = #-0x10372
; 	z_dummy_thread_init(&_thread_dummy);
 8014ac2: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8014af0 <z_cstart+0xc4>
 8014ac4: f7ff fdfc    	bl	0x80146c0 <z_dummy_thread_init> @ imm = #-0x408
; 	z_device_state_init();
 8014ac8: f7ff fc66    	bl	0x8014398 <z_device_state_init> @ imm = #-0x734
; 	soc_early_init_hook();
 8014acc: f7ef fc28    	bl	0x8004320 <soc_early_init_hook> @ imm = #-0x107b0
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
 8014ad0: 2001         	movs	r0, #0x1
 8014ad2: f7ff fe91    	bl	0x80147f8 <z_sys_init_run_level> @ imm = #-0x2de
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 8014ad6: 2002         	movs	r0, #0x2
 8014ad8: f7ff fe8e    	bl	0x80147f8 <z_sys_init_run_level> @ imm = #-0x2e4
; 	switch_to_main_thread(prepare_multithreading());
 8014adc: f7ff ff64    	bl	0x80149a8 <prepare_multithreading> @ imm = #-0x138
 8014ae0: 4603         	mov	r3, r0
 8014ae2: 4618         	mov	r0, r3
 8014ae4: f7ff ff94    	bl	0x8014a10 <switch_to_main_thread> @ imm = #-0xd8

08014ae8 <$d>:
 8014ae8: 38 57 00 24  	.word	0x24005738
 8014aec: 00 ed 00 e0  	.word	0xe000ed00
 8014af0: 10 24 00 24  	.word	0x24002410

08014af4 <statics_init>:
; {
 8014af4: b580         	push	{r7, lr}
 8014af6: b082         	sub	sp, #0x8
 8014af8: af00         	add	r7, sp, #0x0
; 	STRUCT_SECTION_FOREACH(k_heap, heap) {
 8014afa: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8014b34 <statics_init+0x40>
 8014afc: 607b         	str	r3, [r7, #0x4]
 8014afe: e00a         	b	0x8014b16 <statics_init+0x22> @ imm = #0x14
; 			k_heap_init(heap, heap->heap.init_mem, heap->heap.init_bytes);
 8014b00: 687b         	ldr	r3, [r7, #0x4]
 8014b02: 6859         	ldr	r1, [r3, #0x4]
 8014b04: 687b         	ldr	r3, [r7, #0x4]
 8014b06: 689b         	ldr	r3, [r3, #0x8]
 8014b08: 461a         	mov	r2, r3
 8014b0a: 6878         	ldr	r0, [r7, #0x4]
 8014b0c: f011 fda1    	bl	0x8026652 <k_heap_init> @ imm = #0x11b42
; 	STRUCT_SECTION_FOREACH(k_heap, heap) {
 8014b10: 687b         	ldr	r3, [r7, #0x4]
 8014b12: 3314         	adds	r3, #0x14
 8014b14: 607b         	str	r3, [r7, #0x4]
 8014b16: 687b         	ldr	r3, [r7, #0x4]
 8014b18: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8014b38 <statics_init+0x44>
 8014b1a: 4293         	cmp	r3, r2
 8014b1c: bf34         	ite	lo
 8014b1e: 2301         	movlo	r3, #0x1
 8014b20: 2300         	movhs	r3, #0x0
 8014b22: b2db         	uxtb	r3, r3
 8014b24: 2b00         	cmp	r3, #0x0
 8014b26: d1eb         	bne	0x8014b00 <statics_init+0xc> @ imm = #-0x2a
; 	return 0;
 8014b28: 2300         	movs	r3, #0x0
; }
 8014b2a: 4618         	mov	r0, r3
 8014b2c: 3708         	adds	r7, #0x8
 8014b2e: 46bd         	mov	sp, r7
 8014b30: bd80         	pop	{r7, pc}
 8014b32: bf00         	nop

08014b34 <$d>:
 8014b34: 3c 0c 00 24  	.word	0x24000c3c
 8014b38: 50 0c 00 24  	.word	0x24000c50

08014b3c <init_mem_slab_obj_core_list>:
; {
 8014b3c: b580         	push	{r7, lr}
 8014b3e: b082         	sub	sp, #0x8
 8014b40: af00         	add	r7, sp, #0x0
; 	int rc = 0;
 8014b42: 2300         	movs	r3, #0x0
 8014b44: 607b         	str	r3, [r7, #0x4]
; 	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 8014b46: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8014b88 <init_mem_slab_obj_core_list+0x4c>
 8014b48: 603b         	str	r3, [r7]
 8014b4a: e00c         	b	0x8014b66 <init_mem_slab_obj_core_list+0x2a> @ imm = #0x18
; 		rc = create_free_list(slab);
 8014b4c: 6838         	ldr	r0, [r7]
 8014b4e: f011 ff03    	bl	0x8026958 <create_free_list> @ imm = #0x11e06
 8014b52: 6078         	str	r0, [r7, #0x4]
; 		if (rc < 0) {
 8014b54: 687b         	ldr	r3, [r7, #0x4]
 8014b56: 2b00         	cmp	r3, #0x0
 8014b58: db0f         	blt	0x8014b7a <init_mem_slab_obj_core_list+0x3e> @ imm = #0x1e
; 		k_object_init(slab);
 8014b5a: 6838         	ldr	r0, [r7]
 8014b5c: f011 feb9    	bl	0x80268d2 <k_object_init> @ imm = #0x11d72
; 	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 8014b60: 683b         	ldr	r3, [r7]
 8014b62: 331c         	adds	r3, #0x1c
 8014b64: 603b         	str	r3, [r7]
 8014b66: 683b         	ldr	r3, [r7]
 8014b68: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8014b8c <init_mem_slab_obj_core_list+0x50>
 8014b6a: 4293         	cmp	r3, r2
 8014b6c: bf34         	ite	lo
 8014b6e: 2301         	movlo	r3, #0x1
 8014b70: 2300         	movhs	r3, #0x0
 8014b72: b2db         	uxtb	r3, r3
 8014b74: 2b00         	cmp	r3, #0x0
 8014b76: d1e9         	bne	0x8014b4c <init_mem_slab_obj_core_list+0x10> @ imm = #-0x2e
; out:
 8014b78: e000         	b	0x8014b7c <init_mem_slab_obj_core_list+0x40> @ imm = #0x0
; 			goto out;
 8014b7a: bf00         	nop
; 	return rc;
 8014b7c: 687b         	ldr	r3, [r7, #0x4]
; }
 8014b7e: 4618         	mov	r0, r3
 8014b80: 3708         	adds	r7, #0x8
 8014b82: 46bd         	mov	sp, r7
 8014b84: bd80         	pop	{r7, pc}
 8014b86: bf00         	nop

08014b88 <$d>:
 8014b88: 20 0c 00 24  	.word	0x24000c20
 8014b8c: 3c 0c 00 24  	.word	0x24000c3c

08014b90 <k_mem_slab_alloc>:
; {
 8014b90: b580         	push	{r7, lr}
 8014b92: b094         	sub	sp, #0x50
 8014b94: af02         	add	r7, sp, #0x8
 8014b96: 60f8         	str	r0, [r7, #0xc]
 8014b98: 60b9         	str	r1, [r7, #0x8]
 8014b9a: e9c7 2300    	strd	r2, r3, [r7]
; 	k_spinlock_key_t key = k_spin_lock(&slab->lock);
 8014b9e: 68fb         	ldr	r3, [r7, #0xc]
 8014ba0: 3308         	adds	r3, #0x8
 8014ba2: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8014ba4: f3ef 8311    	mrs	r3, basepri
 8014ba8: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 8014baa: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 8014bac: 63bb         	str	r3, [r7, #0x38]
 8014bae: 2310         	movs	r3, #0x10
 8014bb0: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8014bb2: 6b7b         	ldr	r3, [r7, #0x34]
 8014bb4: f383 8812    	msr	basepri_max, r3
; }
 8014bb8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014bba: f3bf 8f6f    	isb	sy
; }
 8014bbe: bf00         	nop
; 	return key;
 8014bc0: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 8014bc2: 613b         	str	r3, [r7, #0x10]
 8014bc4: 6c3b         	ldr	r3, [r7, #0x40]
 8014bc6: 633b         	str	r3, [r7, #0x30]
; }
 8014bc8: bf00         	nop
 8014bca: 6c3b         	ldr	r3, [r7, #0x40]
 8014bcc: 62fb         	str	r3, [r7, #0x2c]
; }
 8014bce: bf00         	nop
; 	return k;
 8014bd0: 693b         	ldr	r3, [r7, #0x10]
 8014bd2: 61bb         	str	r3, [r7, #0x18]
; 	if (slab->free_list != NULL) {
 8014bd4: 68fb         	ldr	r3, [r7, #0xc]
 8014bd6: 68db         	ldr	r3, [r3, #0xc]
 8014bd8: 2b00         	cmp	r3, #0x0
 8014bda: d010         	beq	0x8014bfe <k_mem_slab_alloc+0x6e> @ imm = #0x20
; 		*mem = slab->free_list;
 8014bdc: 68fb         	ldr	r3, [r7, #0xc]
 8014bde: 68da         	ldr	r2, [r3, #0xc]
 8014be0: 68bb         	ldr	r3, [r7, #0x8]
 8014be2: 601a         	str	r2, [r3]
; 		slab->free_list = *(char **)(slab->free_list);
 8014be4: 68fb         	ldr	r3, [r7, #0xc]
 8014be6: 68db         	ldr	r3, [r3, #0xc]
 8014be8: 681a         	ldr	r2, [r3]
 8014bea: 68fb         	ldr	r3, [r7, #0xc]
 8014bec: 60da         	str	r2, [r3, #0xc]
; 		slab->info.num_used++;
 8014bee: 68fb         	ldr	r3, [r7, #0xc]
 8014bf0: 699b         	ldr	r3, [r3, #0x18]
 8014bf2: 1c5a         	adds	r2, r3, #0x1
 8014bf4: 68fb         	ldr	r3, [r7, #0xc]
 8014bf6: 619a         	str	r2, [r3, #0x18]
; 		result = 0;
 8014bf8: 2300         	movs	r3, #0x0
 8014bfa: 647b         	str	r3, [r7, #0x44]
 8014bfc: e029         	b	0x8014c52 <k_mem_slab_alloc+0xc2> @ imm = #0x52
; 	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
 8014bfe: e9d7 2300    	ldrd	r2, r3, [r7]
 8014c02: f04f 0000    	mov.w	r0, #0x0
 8014c06: f04f 0100    	mov.w	r1, #0x0
 8014c0a: 428b         	cmp	r3, r1
 8014c0c: bf08         	it	eq
 8014c0e: 4282         	cmpeq	r2, r0
 8014c10: d106         	bne	0x8014c20 <k_mem_slab_alloc+0x90> @ imm = #0xc
; 		*mem = NULL;
 8014c12: 68bb         	ldr	r3, [r7, #0x8]
 8014c14: 2200         	movs	r2, #0x0
 8014c16: 601a         	str	r2, [r3]
; 		result = -ENOMEM;
 8014c18: f06f 030b    	mvn	r3, #0xb
 8014c1c: 647b         	str	r3, [r7, #0x44]
 8014c1e: e018         	b	0x8014c52 <k_mem_slab_alloc+0xc2> @ imm = #0x30
; 		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
 8014c20: 68fb         	ldr	r3, [r7, #0xc]
 8014c22: f103 0008    	add.w	r0, r3, #0x8
 8014c26: 68f9         	ldr	r1, [r7, #0xc]
 8014c28: e9d7 2300    	ldrd	r2, r3, [r7]
 8014c2c: e9cd 2300    	strd	r2, r3, [sp]
 8014c30: 460a         	mov	r2, r1
 8014c32: 69b9         	ldr	r1, [r7, #0x18]
 8014c34: f002 f8e8    	bl	0x8016e08 <z_pend_curr> @ imm = #0x21d0
 8014c38: 6478         	str	r0, [r7, #0x44]
; 		if (result == 0) {
 8014c3a: 6c7b         	ldr	r3, [r7, #0x44]
 8014c3c: 2b00         	cmp	r3, #0x0
 8014c3e: d106         	bne	0x8014c4e <k_mem_slab_alloc+0xbe> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014c40: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8014c80 <k_mem_slab_alloc+0xf0>
 8014c42: 689b         	ldr	r3, [r3, #0x8]
 8014c44: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8014c46: 6abb         	ldr	r3, [r7, #0x28]
; 			*mem = arch_current_thread()->base.swap_data;
 8014c48: 695a         	ldr	r2, [r3, #0x14]
 8014c4a: 68bb         	ldr	r3, [r7, #0x8]
 8014c4c: 601a         	str	r2, [r3]
; 		return result;
 8014c4e: 6c7b         	ldr	r3, [r7, #0x44]
 8014c50: e012         	b	0x8014c78 <k_mem_slab_alloc+0xe8> @ imm = #0x24
; 	k_spin_unlock(&slab->lock, key);
 8014c52: 68fb         	ldr	r3, [r7, #0xc]
 8014c54: 3308         	adds	r3, #0x8
 8014c56: 627b         	str	r3, [r7, #0x24]
 8014c58: 69bb         	ldr	r3, [r7, #0x18]
 8014c5a: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8014c5c: 697b         	ldr	r3, [r7, #0x14]
 8014c5e: 623b         	str	r3, [r7, #0x20]
 8014c60: 6a3b         	ldr	r3, [r7, #0x20]
 8014c62: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8014c64: 69fb         	ldr	r3, [r7, #0x1c]
 8014c66: f383 8811    	msr	basepri, r3
; }
 8014c6a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014c6c: f3bf 8f6f    	isb	sy
; }
 8014c70: bf00         	nop
; }
 8014c72: bf00         	nop
; }
 8014c74: bf00         	nop
; 	return result;
 8014c76: 6c7b         	ldr	r3, [r7, #0x44]
; }
 8014c78: 4618         	mov	r0, r3
 8014c7a: 3748         	adds	r7, #0x48
 8014c7c: 46bd         	mov	sp, r7
 8014c7e: bd80         	pop	{r7, pc}

08014c80 <$d>:
 8014c80: 60 20 00 24  	.word	0x24002060

08014c84 <z_impl_k_msgq_put>:
; {
 8014c84: b580         	push	{r7, lr}
 8014c86: b09c         	sub	sp, #0x70
 8014c88: af02         	add	r7, sp, #0x8
 8014c8a: 60f8         	str	r0, [r7, #0xc]
 8014c8c: 60b9         	str	r1, [r7, #0x8]
 8014c8e: e9c7 2300    	strd	r2, r3, [r7]
; 	key = k_spin_lock(&msgq->lock);
 8014c92: 68fb         	ldr	r3, [r7, #0xc]
 8014c94: 3308         	adds	r3, #0x8
 8014c96: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8014c98: f3ef 8311    	mrs	r3, basepri
 8014c9c: 65bb         	str	r3, [r7, #0x58]
;   return(result);
 8014c9e: 6dbb         	ldr	r3, [r7, #0x58]
; 	key = __get_BASEPRI();
 8014ca0: 657b         	str	r3, [r7, #0x54]
 8014ca2: 2310         	movs	r3, #0x10
 8014ca4: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8014ca6: 6d3b         	ldr	r3, [r7, #0x50]
 8014ca8: f383 8812    	msr	basepri_max, r3
; }
 8014cac: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014cae: f3bf 8f6f    	isb	sy
; }
 8014cb2: bf00         	nop
; 	return key;
 8014cb4: 6d7b         	ldr	r3, [r7, #0x54]
; 	k.key = arch_irq_lock();
 8014cb6: 613b         	str	r3, [r7, #0x10]
 8014cb8: 6dfb         	ldr	r3, [r7, #0x5c]
 8014cba: 64fb         	str	r3, [r7, #0x4c]
; }
 8014cbc: bf00         	nop
 8014cbe: 6dfb         	ldr	r3, [r7, #0x5c]
 8014cc0: 64bb         	str	r3, [r7, #0x48]
; }
 8014cc2: bf00         	nop
; 	return k;
 8014cc4: 693b         	ldr	r3, [r7, #0x10]
 8014cc6: 61bb         	str	r3, [r7, #0x18]
; 	if (msgq->used_msgs < msgq->max_msgs) {
 8014cc8: 68fb         	ldr	r3, [r7, #0xc]
 8014cca: 6a1a         	ldr	r2, [r3, #0x20]
 8014ccc: 68fb         	ldr	r3, [r7, #0xc]
 8014cce: 68db         	ldr	r3, [r3, #0xc]
 8014cd0: 429a         	cmp	r2, r3
 8014cd2: d267         	bhs	0x8014da4 <z_impl_k_msgq_put+0x120> @ imm = #0xce
; 		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 8014cd4: 68fb         	ldr	r3, [r7, #0xc]
 8014cd6: 647b         	str	r3, [r7, #0x44]
; 	struct k_thread *thread = NULL;
 8014cd8: 2300         	movs	r3, #0x0
 8014cda: 643b         	str	r3, [r7, #0x40]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8014cdc: 6c7b         	ldr	r3, [r7, #0x44]
 8014cde: 63fb         	str	r3, [r7, #0x3c]
; 	struct k_thread *thread = NULL;
 8014ce0: 2300         	movs	r3, #0x0
 8014ce2: 63bb         	str	r3, [r7, #0x38]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8014ce4: 6bf8         	ldr	r0, [r7, #0x3c]
 8014ce6: f011 ff8d    	bl	0x8026c04 <sys_dlist_peek_head> @ imm = #0x11f1a
 8014cea: 6378         	str	r0, [r7, #0x34]
; 	if (n != NULL) {
 8014cec: 6b7b         	ldr	r3, [r7, #0x34]
 8014cee: 2b00         	cmp	r3, #0x0
 8014cf0: d001         	beq	0x8014cf6 <z_impl_k_msgq_put+0x72> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8014cf2: 6b7b         	ldr	r3, [r7, #0x34]
 8014cf4: 63bb         	str	r3, [r7, #0x38]
; 	return thread;
 8014cf6: 6bbb         	ldr	r3, [r7, #0x38]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8014cf8: 643b         	str	r3, [r7, #0x40]
; 		if (unlikely(thread != NULL)) {
 8014cfa: 6c3b         	ldr	r3, [r7, #0x40]
 8014cfc: 2b00         	cmp	r3, #0x0
 8014cfe: bf14         	ite	ne
 8014d00: 2301         	movne	r3, #0x1
 8014d02: 2300         	moveq	r3, #0x0
 8014d04: b2db         	uxtb	r3, r3
 8014d06: 2b00         	cmp	r3, #0x0
 8014d08: d005         	beq	0x8014d16 <z_impl_k_msgq_put+0x92> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 8014d0a: 6c38         	ldr	r0, [r7, #0x40]
 8014d0c: f011 ffc2    	bl	0x8026c94 <unpend_thread_no_timeout> @ imm = #0x11f84
; 			(void)z_abort_thread_timeout(thread);
 8014d10: 6c38         	ldr	r0, [r7, #0x40]
 8014d12: f011 ffa0    	bl	0x8026c56 <z_abort_thread_timeout> @ imm = #0x11f40
; 	return thread;
 8014d16: 6c3b         	ldr	r3, [r7, #0x40]
; 		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 8014d18: 663b         	str	r3, [r7, #0x60]
; 		if (unlikely(pending_thread != NULL)) {
 8014d1a: 6e3b         	ldr	r3, [r7, #0x60]
 8014d1c: 2b00         	cmp	r3, #0x0
 8014d1e: bf14         	ite	ne
 8014d20: 2301         	movne	r3, #0x1
 8014d22: 2300         	moveq	r3, #0x0
 8014d24: b2db         	uxtb	r3, r3
 8014d26: 2b00         	cmp	r3, #0x0
 8014d28: d01b         	beq	0x8014d62 <z_impl_k_msgq_put+0xde> @ imm = #0x36
; 			(void)memcpy(pending_thread->base.swap_data, data,
 8014d2a: 6e3b         	ldr	r3, [r7, #0x60]
 8014d2c: 6958         	ldr	r0, [r3, #0x14]
 8014d2e: 68fb         	ldr	r3, [r7, #0xc]
 8014d30: 689b         	ldr	r3, [r3, #0x8]
 8014d32: 461a         	mov	r2, r3
 8014d34: 68b9         	ldr	r1, [r7, #0x8]
 8014d36: f014 f9dd    	bl	0x80290f4 <memcpy>      @ imm = #0x143ba
 8014d3a: 6e3b         	ldr	r3, [r7, #0x60]
 8014d3c: 633b         	str	r3, [r7, #0x30]
 8014d3e: 2300         	movs	r3, #0x0
 8014d40: 62fb         	str	r3, [r7, #0x2c]
; 	thread->arch.swap_return_value = value;
 8014d42: 6b3b         	ldr	r3, [r7, #0x30]
 8014d44: 6afa         	ldr	r2, [r7, #0x2c]
 8014d46: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8014d4a: bf00         	nop
; 			z_ready_thread(pending_thread);
 8014d4c: 6e38         	ldr	r0, [r7, #0x60]
 8014d4e: f001 fc59    	bl	0x8016604 <z_ready_thread> @ imm = #0x18b2
; 			z_reschedule(&msgq->lock, key);
 8014d52: 68fb         	ldr	r3, [r7, #0xc]
 8014d54: 3308         	adds	r3, #0x8
 8014d56: 69b9         	ldr	r1, [r7, #0x18]
 8014d58: 4618         	mov	r0, r3
 8014d5a: f013 fdff    	bl	0x802895c <z_reschedule> @ imm = #0x13bfe
; 			return 0;
 8014d5e: 2300         	movs	r3, #0x0
 8014d60: e056         	b	0x8014e10 <z_impl_k_msgq_put+0x18c> @ imm = #0xac
; 			(void)memcpy(msgq->write_ptr, (char *)data, msgq->msg_size);
 8014d62: 68fb         	ldr	r3, [r7, #0xc]
 8014d64: 69d8         	ldr	r0, [r3, #0x1c]
 8014d66: 68fb         	ldr	r3, [r7, #0xc]
 8014d68: 689b         	ldr	r3, [r3, #0x8]
 8014d6a: 461a         	mov	r2, r3
 8014d6c: 68b9         	ldr	r1, [r7, #0x8]
 8014d6e: f014 f9c1    	bl	0x80290f4 <memcpy>      @ imm = #0x14382
; 			msgq->write_ptr += msgq->msg_size;
 8014d72: 68fb         	ldr	r3, [r7, #0xc]
 8014d74: 69da         	ldr	r2, [r3, #0x1c]
 8014d76: 68fb         	ldr	r3, [r7, #0xc]
 8014d78: 689b         	ldr	r3, [r3, #0x8]
 8014d7a: 441a         	add	r2, r3
 8014d7c: 68fb         	ldr	r3, [r7, #0xc]
 8014d7e: 61da         	str	r2, [r3, #0x1c]
; 			if (msgq->write_ptr == msgq->buffer_end) {
 8014d80: 68fb         	ldr	r3, [r7, #0xc]
 8014d82: 69da         	ldr	r2, [r3, #0x1c]
 8014d84: 68fb         	ldr	r3, [r7, #0xc]
 8014d86: 695b         	ldr	r3, [r3, #0x14]
 8014d88: 429a         	cmp	r2, r3
 8014d8a: d103         	bne	0x8014d94 <z_impl_k_msgq_put+0x110> @ imm = #0x6
; 				msgq->write_ptr = msgq->buffer_start;
 8014d8c: 68fb         	ldr	r3, [r7, #0xc]
 8014d8e: 691a         	ldr	r2, [r3, #0x10]
 8014d90: 68fb         	ldr	r3, [r7, #0xc]
 8014d92: 61da         	str	r2, [r3, #0x1c]
; 			msgq->used_msgs++;
 8014d94: 68fb         	ldr	r3, [r7, #0xc]
 8014d96: 6a1b         	ldr	r3, [r3, #0x20]
 8014d98: 1c5a         	adds	r2, r3, #0x1
 8014d9a: 68fb         	ldr	r3, [r7, #0xc]
 8014d9c: 621a         	str	r2, [r3, #0x20]
; 		result = 0;
 8014d9e: 2300         	movs	r3, #0x0
 8014da0: 667b         	str	r3, [r7, #0x64]
 8014da2: e022         	b	0x8014dea <z_impl_k_msgq_put+0x166> @ imm = #0x44
; 	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 8014da4: e9d7 2300    	ldrd	r2, r3, [r7]
 8014da8: f04f 0000    	mov.w	r0, #0x0
 8014dac: f04f 0100    	mov.w	r1, #0x0
 8014db0: 428b         	cmp	r3, r1
 8014db2: bf08         	it	eq
 8014db4: 4282         	cmpeq	r2, r0
 8014db6: d103         	bne	0x8014dc0 <z_impl_k_msgq_put+0x13c> @ imm = #0x6
; 		result = -ENOMSG;
 8014db8: f06f 0322    	mvn	r3, #0x22
 8014dbc: 667b         	str	r3, [r7, #0x64]
 8014dbe: e014         	b	0x8014dea <z_impl_k_msgq_put+0x166> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014dc0: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8014e18 <z_impl_k_msgq_put+0x194>
 8014dc2: 689b         	ldr	r3, [r3, #0x8]
 8014dc4: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8014dc6: 6abb         	ldr	r3, [r7, #0x28]
; 		arch_current_thread()->base.swap_data = (void *) data;
 8014dc8: 68ba         	ldr	r2, [r7, #0x8]
 8014dca: 615a         	str	r2, [r3, #0x14]
; 		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
 8014dcc: 68fb         	ldr	r3, [r7, #0xc]
 8014dce: f103 0008    	add.w	r0, r3, #0x8
 8014dd2: 68f9         	ldr	r1, [r7, #0xc]
 8014dd4: e9d7 2300    	ldrd	r2, r3, [r7]
 8014dd8: e9cd 2300    	strd	r2, r3, [sp]
 8014ddc: 460a         	mov	r2, r1
 8014dde: 69b9         	ldr	r1, [r7, #0x18]
 8014de0: f002 f812    	bl	0x8016e08 <z_pend_curr> @ imm = #0x2024
 8014de4: 6678         	str	r0, [r7, #0x64]
; 		return result;
 8014de6: 6e7b         	ldr	r3, [r7, #0x64]
 8014de8: e012         	b	0x8014e10 <z_impl_k_msgq_put+0x18c> @ imm = #0x24
; 	k_spin_unlock(&msgq->lock, key);
 8014dea: 68fb         	ldr	r3, [r7, #0xc]
 8014dec: 3308         	adds	r3, #0x8
 8014dee: 627b         	str	r3, [r7, #0x24]
 8014df0: 69bb         	ldr	r3, [r7, #0x18]
 8014df2: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8014df4: 697b         	ldr	r3, [r7, #0x14]
 8014df6: 623b         	str	r3, [r7, #0x20]
 8014df8: 6a3b         	ldr	r3, [r7, #0x20]
 8014dfa: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8014dfc: 69fb         	ldr	r3, [r7, #0x1c]
 8014dfe: f383 8811    	msr	basepri, r3
; }
 8014e02: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014e04: f3bf 8f6f    	isb	sy
; }
 8014e08: bf00         	nop
; }
 8014e0a: bf00         	nop
; }
 8014e0c: bf00         	nop
; 	return result;
 8014e0e: 6e7b         	ldr	r3, [r7, #0x64]
; }
 8014e10: 4618         	mov	r0, r3
 8014e12: 3768         	adds	r7, #0x68
 8014e14: 46bd         	mov	sp, r7
 8014e16: bd80         	pop	{r7, pc}

08014e18 <$d>:
 8014e18: 60 20 00 24  	.word	0x24002060

08014e1c <adjust_owner_prio>:
; {
 8014e1c: b5b0         	push	{r4, r5, r7, lr}
 8014e1e: b08c         	sub	sp, #0x30
 8014e20: af08         	add	r7, sp, #0x20
 8014e22: 6078         	str	r0, [r7, #0x4]
 8014e24: 6039         	str	r1, [r7]
; 	if (mutex->owner->base.prio != new_prio) {
 8014e26: 687b         	ldr	r3, [r7, #0x4]
 8014e28: 689b         	ldr	r3, [r3, #0x8]
 8014e2a: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8014e2e: 461a         	mov	r2, r3
 8014e30: 683b         	ldr	r3, [r7]
 8014e32: 4293         	cmp	r3, r2
 8014e34: d03a         	beq	0x8014eac <adjust_owner_prio+0x90> @ imm = #0x74
; 		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
 8014e36: 2303         	movs	r3, #0x3
 8014e38: 2b03         	cmp	r3, #0x3
 8014e3a: d92f         	bls	0x8014e9c <adjust_owner_prio+0x80> @ imm = #0x5e
 8014e3c: 2301         	movs	r3, #0x1
 8014e3e: 72fb         	strb	r3, [r7, #0xb]
 8014e40: 7afb         	ldrb	r3, [r7, #0xb]
 8014e42: f083 0301    	eor	r3, r3, #0x1
 8014e46: b2db         	uxtb	r3, r3
 8014e48: 2b00         	cmp	r3, #0x0
 8014e4a: d127         	bne	0x8014e9c <adjust_owner_prio+0x80> @ imm = #0x4e
 8014e4c: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8014eb8 <adjust_owner_prio+0x9c>
 8014e4e: 681d         	ldr	r5, [r3]
 8014e50: 687b         	ldr	r3, [r7, #0x4]
 8014e52: 689c         	ldr	r4, [r3, #0x8]
 8014e54: 687b         	ldr	r3, [r7, #0x4]
 8014e56: 689b         	ldr	r3, [r3, #0x8]
 8014e58: 4618         	mov	r0, r3
 8014e5a: f011 ffff    	bl	0x8026e5c <z_is_thread_ready> @ imm = #0x11ffe
 8014e5e: 4603         	mov	r3, r0
 8014e60: 2b00         	cmp	r3, #0x0
 8014e62: d001         	beq	0x8014e68 <adjust_owner_prio+0x4c> @ imm = #0x2
 8014e64: 2379         	movs	r3, #0x79
 8014e66: e000         	b	0x8014e6a <adjust_owner_prio+0x4e> @ imm = #0x0
 8014e68: 236e         	movs	r3, #0x6e
 8014e6a: 687a         	ldr	r2, [r7, #0x4]
 8014e6c: 6892         	ldr	r2, [r2, #0x8]
 8014e6e: f992 200e    	ldrsb.w	r2, [r2, #0xe]
 8014e72: 9207         	str	r2, [sp, #0x1c]
 8014e74: 683a         	ldr	r2, [r7]
 8014e76: 9206         	str	r2, [sp, #0x18]
 8014e78: 9305         	str	r3, [sp, #0x14]
 8014e7a: 9404         	str	r4, [sp, #0x10]
 8014e7c: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8014ebc <adjust_owner_prio+0xa0>
 8014e7e: 9303         	str	r3, [sp, #0xc]
 8014e80: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8014ec0 <adjust_owner_prio+0xa4>
 8014e82: 9302         	str	r3, [sp, #0x8]
 8014e84: 2308         	movs	r3, #0x8
 8014e86: 9301         	str	r3, [sp, #0x4]
 8014e88: 2300         	movs	r3, #0x0
 8014e8a: 9300         	str	r3, [sp]
 8014e8c: 2300         	movs	r3, #0x0
 8014e8e: 2204         	movs	r2, #0x4
 8014e90: 4629         	mov	r1, r5
 8014e92: 2000         	movs	r0, #0x0
 8014e94: f012 f889    	bl	0x8026faa <z_log_msg_runtime_create> @ imm = #0x12112
 8014e98: 2300         	movs	r3, #0x0
 8014e9a: 60fb         	str	r3, [r7, #0xc]
; 		return z_thread_prio_set(mutex->owner, new_prio);
 8014e9c: 687b         	ldr	r3, [r7, #0x4]
 8014e9e: 689b         	ldr	r3, [r3, #0x8]
 8014ea0: 6839         	ldr	r1, [r7]
 8014ea2: 4618         	mov	r0, r3
 8014ea4: f001 fff6    	bl	0x8016e94 <z_thread_prio_set> @ imm = #0x1fec
 8014ea8: 4603         	mov	r3, r0
 8014eaa: e000         	b	0x8014eae <adjust_owner_prio+0x92> @ imm = #0x0
; 	return false;
 8014eac: 2300         	movs	r3, #0x0
; }
 8014eae: 4618         	mov	r0, r3
 8014eb0: 3710         	adds	r7, #0x10
 8014eb2: 46bd         	mov	sp, r7
 8014eb4: bdb0         	pop	{r4, r5, r7, pc}
 8014eb6: bf00         	nop

08014eb8 <$d>:
 8014eb8: 6c 0b 00 24  	.word	0x24000b6c
 8014ebc: e4 e5 02 08  	.word	0x0802e5e4
 8014ec0: f0 c7 02 08  	.word	0x0802c7f0

08014ec4 <z_impl_k_mutex_lock>:
; {
 8014ec4: b580         	push	{r7, lr}
 8014ec6: b0be         	sub	sp, #0xf8
 8014ec8: af08         	add	r7, sp, #0x20
 8014eca: 60f8         	str	r0, [r7, #0xc]
 8014ecc: e9c7 2300    	strd	r2, r3, [r7]
; 	bool resched = false;
 8014ed0: 2300         	movs	r3, #0x0
 8014ed2: f887 30d7    	strb.w	r3, [r7, #0xd7]
 8014ed6: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8015170 <z_impl_k_mutex_lock+0x2ac>
 8014ed8: f8c7 3094    	str.w	r3, [r7, #0x94]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8014edc: f3ef 8311    	mrs	r3, basepri
 8014ee0: f8c7 3090    	str.w	r3, [r7, #0x90]
;   return(result);
 8014ee4: f8d7 3090    	ldr.w	r3, [r7, #0x90]
; 	key = __get_BASEPRI();
 8014ee8: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8014eec: 2310         	movs	r3, #0x10
 8014eee: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8014ef2: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8014ef6: f383 8812    	msr	basepri_max, r3
; }
 8014efa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014efc: f3bf 8f6f    	isb	sy
; }
 8014f00: bf00         	nop
; 	return key;
 8014f02: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	k.key = arch_irq_lock();
 8014f06: 617b         	str	r3, [r7, #0x14]
 8014f08: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 8014f0c: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 8014f10: bf00         	nop
 8014f12: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 8014f16: f8c7 3080    	str.w	r3, [r7, #0x80]
; }
 8014f1a: bf00         	nop
; 	return k;
 8014f1c: 697b         	ldr	r3, [r7, #0x14]
 8014f1e: 627b         	str	r3, [r7, #0x24]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == arch_current_thread()))) {
 8014f20: 68fb         	ldr	r3, [r7, #0xc]
 8014f22: 68db         	ldr	r3, [r3, #0xc]
 8014f24: 2b00         	cmp	r3, #0x0
 8014f26: bf0c         	ite	eq
 8014f28: 2301         	moveq	r3, #0x1
 8014f2a: 2300         	movne	r3, #0x0
 8014f2c: b2db         	uxtb	r3, r3
 8014f2e: 2b00         	cmp	r3, #0x0
 8014f30: d10c         	bne	0x8014f4c <z_impl_k_mutex_lock+0x88> @ imm = #0x18
 8014f32: 68fb         	ldr	r3, [r7, #0xc]
 8014f34: 689a         	ldr	r2, [r3, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014f36: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x8015174 <z_impl_k_mutex_lock+0x2b0>
 8014f38: 689b         	ldr	r3, [r3, #0x8]
 8014f3a: 67fb         	str	r3, [r7, #0x7c]
; 	return ret;
 8014f3c: 6ffb         	ldr	r3, [r7, #0x7c]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == arch_current_thread()))) {
 8014f3e: 429a         	cmp	r2, r3
 8014f40: bf0c         	ite	eq
 8014f42: 2301         	moveq	r3, #0x1
 8014f44: 2300         	movne	r3, #0x0
 8014f46: b2db         	uxtb	r3, r3
 8014f48: 2b00         	cmp	r3, #0x0
 8014f4a: d001         	beq	0x8014f50 <z_impl_k_mutex_lock+0x8c> @ imm = #0x2
 8014f4c: 2301         	movs	r3, #0x1
 8014f4e: e000         	b	0x8014f52 <z_impl_k_mutex_lock+0x8e> @ imm = #0x0
 8014f50: 2300         	movs	r3, #0x0
 8014f52: 2b00         	cmp	r3, #0x0
 8014f54: d059         	beq	0x801500a <z_impl_k_mutex_lock+0x146> @ imm = #0xb2
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 8014f56: 68fb         	ldr	r3, [r7, #0xc]
 8014f58: 68db         	ldr	r3, [r3, #0xc]
; 					arch_current_thread()->base.prio :
 8014f5a: 2b00         	cmp	r3, #0x0
 8014f5c: d106         	bne	0x8014f6c <z_impl_k_mutex_lock+0xa8> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014f5e: 4b85         	ldr	r3, [pc, #0x214]        @ 0x8015174 <z_impl_k_mutex_lock+0x2b0>
 8014f60: 689b         	ldr	r3, [r3, #0x8]
 8014f62: 67bb         	str	r3, [r7, #0x78]
; 	return ret;
 8014f64: 6fbb         	ldr	r3, [r7, #0x78]
; 					arch_current_thread()->base.prio :
 8014f66: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8014f6a: e001         	b	0x8014f70 <z_impl_k_mutex_lock+0xac> @ imm = #0x2
 8014f6c: 68fb         	ldr	r3, [r7, #0xc]
 8014f6e: 691b         	ldr	r3, [r3, #0x10]
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 8014f70: 68fa         	ldr	r2, [r7, #0xc]
 8014f72: 6113         	str	r3, [r2, #0x10]
; 		mutex->lock_count++;
 8014f74: 68fb         	ldr	r3, [r7, #0xc]
 8014f76: 68db         	ldr	r3, [r3, #0xc]
 8014f78: 1c5a         	adds	r2, r3, #0x1
 8014f7a: 68fb         	ldr	r3, [r7, #0xc]
 8014f7c: 60da         	str	r2, [r3, #0xc]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014f7e: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x8015174 <z_impl_k_mutex_lock+0x2b0>
 8014f80: 689b         	ldr	r3, [r3, #0x8]
 8014f82: 677b         	str	r3, [r7, #0x74]
; 	return ret;
 8014f84: 6f7a         	ldr	r2, [r7, #0x74]
; 		mutex->owner = arch_current_thread();
 8014f86: 68fb         	ldr	r3, [r7, #0xc]
 8014f88: 609a         	str	r2, [r3, #0x8]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 8014f8a: 2303         	movs	r3, #0x3
 8014f8c: 2b03         	cmp	r3, #0x3
 8014f8e: d929         	bls	0x8014fe4 <z_impl_k_mutex_lock+0x120> @ imm = #0x52
 8014f90: 2301         	movs	r3, #0x1
 8014f92: f887 309f    	strb.w	r3, [r7, #0x9f]
 8014f96: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 8014f9a: f083 0301    	eor	r3, r3, #0x1
 8014f9e: b2db         	uxtb	r3, r3
 8014fa0: 2b00         	cmp	r3, #0x0
 8014fa2: d11f         	bne	0x8014fe4 <z_impl_k_mutex_lock+0x120> @ imm = #0x3e
 8014fa4: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8015178 <z_impl_k_mutex_lock+0x2b4>
 8014fa6: 6818         	ldr	r0, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014fa8: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8015174 <z_impl_k_mutex_lock+0x2b0>
 8014faa: 689b         	ldr	r3, [r3, #0x8]
 8014fac: 673b         	str	r3, [r7, #0x70]
; 	return ret;
 8014fae: 6f3b         	ldr	r3, [r7, #0x70]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 8014fb0: 68fa         	ldr	r2, [r7, #0xc]
 8014fb2: 68d2         	ldr	r2, [r2, #0xc]
 8014fb4: 68f9         	ldr	r1, [r7, #0xc]
 8014fb6: 6909         	ldr	r1, [r1, #0x10]
 8014fb8: 9107         	str	r1, [sp, #0x1c]
 8014fba: 9206         	str	r2, [sp, #0x18]
 8014fbc: 68fa         	ldr	r2, [r7, #0xc]
 8014fbe: 9205         	str	r2, [sp, #0x14]
 8014fc0: 9304         	str	r3, [sp, #0x10]
 8014fc2: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x801517c <z_impl_k_mutex_lock+0x2b8>
 8014fc4: 9303         	str	r3, [sp, #0xc]
 8014fc6: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8015180 <z_impl_k_mutex_lock+0x2bc>
 8014fc8: 9302         	str	r3, [sp, #0x8]
 8014fca: 2308         	movs	r3, #0x8
 8014fcc: 9301         	str	r3, [sp, #0x4]
 8014fce: 2300         	movs	r3, #0x0
 8014fd0: 9300         	str	r3, [sp]
 8014fd2: 2300         	movs	r3, #0x0
 8014fd4: 2204         	movs	r2, #0x4
 8014fd6: 4601         	mov	r1, r0
 8014fd8: 2000         	movs	r0, #0x0
 8014fda: f011 ffe6    	bl	0x8026faa <z_log_msg_runtime_create> @ imm = #0x11fcc
 8014fde: 2300         	movs	r3, #0x0
 8014fe0: f8c7 3098    	str.w	r3, [r7, #0x98]
 8014fe4: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8015170 <z_impl_k_mutex_lock+0x2ac>
 8014fe6: 66fb         	str	r3, [r7, #0x6c]
 8014fe8: 6a7b         	ldr	r3, [r7, #0x24]
 8014fea: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8014fec: 69bb         	ldr	r3, [r7, #0x18]
 8014fee: 66bb         	str	r3, [r7, #0x68]
 8014ff0: 6ebb         	ldr	r3, [r7, #0x68]
 8014ff2: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8014ff4: 6e7b         	ldr	r3, [r7, #0x64]
 8014ff6: f383 8811    	msr	basepri, r3
; }
 8014ffa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014ffc: f3bf 8f6f    	isb	sy
; }
 8015000: bf00         	nop
; }
 8015002: bf00         	nop
; }
 8015004: bf00         	nop
; 		return 0;
 8015006: 2300         	movs	r3, #0x0
 8015008: e193         	b	0x8015332 <z_impl_k_mutex_lock+0x46e> @ imm = #0x326
; 	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
 801500a: e9d7 2300    	ldrd	r2, r3, [r7]
 801500e: f04f 0000    	mov.w	r0, #0x0
 8015012: f04f 0100    	mov.w	r1, #0x0
 8015016: 428b         	cmp	r3, r1
 8015018: bf08         	it	eq
 801501a: 4282         	cmpeq	r2, r0
 801501c: bf0c         	ite	eq
 801501e: 2301         	moveq	r3, #0x1
 8015020: 2300         	movne	r3, #0x0
 8015022: b2db         	uxtb	r3, r3
 8015024: 2b00         	cmp	r3, #0x0
 8015026: d013         	beq	0x8015050 <z_impl_k_mutex_lock+0x18c> @ imm = #0x26
 8015028: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8015170 <z_impl_k_mutex_lock+0x2ac>
 801502a: 663b         	str	r3, [r7, #0x60]
 801502c: 6a7b         	ldr	r3, [r7, #0x24]
 801502e: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8015030: 693b         	ldr	r3, [r7, #0x10]
 8015032: 65fb         	str	r3, [r7, #0x5c]
 8015034: 6dfb         	ldr	r3, [r7, #0x5c]
 8015036: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015038: 6dbb         	ldr	r3, [r7, #0x58]
 801503a: f383 8811    	msr	basepri, r3
; }
 801503e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015040: f3bf 8f6f    	isb	sy
; }
 8015044: bf00         	nop
; }
 8015046: bf00         	nop
; }
 8015048: bf00         	nop
; 		return -EBUSY;
 801504a: f06f 030f    	mvn	r3, #0xf
 801504e: e170         	b	0x8015332 <z_impl_k_mutex_lock+0x46e> @ imm = #0x2e0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015050: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8015174 <z_impl_k_mutex_lock+0x2b0>
 8015052: 689b         	ldr	r3, [r3, #0x8]
 8015054: 657b         	str	r3, [r7, #0x54]
; 	return ret;
 8015056: 6d7b         	ldr	r3, [r7, #0x54]
; 	new_prio = new_prio_for_inheritance(arch_current_thread()->base.prio,
 8015058: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 801505c: 461a         	mov	r2, r3
; 					    mutex->owner->base.prio);
 801505e: 68fb         	ldr	r3, [r7, #0xc]
 8015060: 689b         	ldr	r3, [r3, #0x8]
 8015062: f993 300e    	ldrsb.w	r3, [r3, #0xe]
; 	new_prio = new_prio_for_inheritance(arch_current_thread()->base.prio,
 8015066: 4619         	mov	r1, r3
 8015068: 4610         	mov	r0, r2
 801506a: f011 ffd2    	bl	0x8027012 <new_prio_for_inheritance> @ imm = #0x11fa4
 801506e: f8c7 00d0    	str.w	r0, [r7, #0xd0]
; 	LOG_DBG("adjusting prio up on mutex %p", mutex);
 8015072: 2303         	movs	r3, #0x3
 8015074: 2b03         	cmp	r3, #0x3
 8015076: d91d         	bls	0x80150b4 <z_impl_k_mutex_lock+0x1f0> @ imm = #0x3a
 8015078: 2301         	movs	r3, #0x1
 801507a: f887 30cf    	strb.w	r3, [r7, #0xcf]
 801507e: f897 30cf    	ldrb.w	r3, [r7, #0xcf]
 8015082: f083 0301    	eor	r3, r3, #0x1
 8015086: b2db         	uxtb	r3, r3
 8015088: 2b00         	cmp	r3, #0x0
 801508a: d113         	bne	0x80150b4 <z_impl_k_mutex_lock+0x1f0> @ imm = #0x26
 801508c: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8015178 <z_impl_k_mutex_lock+0x2b4>
 801508e: 6819         	ldr	r1, [r3]
 8015090: 68fb         	ldr	r3, [r7, #0xc]
 8015092: 9304         	str	r3, [sp, #0x10]
 8015094: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x801517c <z_impl_k_mutex_lock+0x2b8>
 8015096: 9303         	str	r3, [sp, #0xc]
 8015098: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8015184 <z_impl_k_mutex_lock+0x2c0>
 801509a: 9302         	str	r3, [sp, #0x8]
 801509c: 2308         	movs	r3, #0x8
 801509e: 9301         	str	r3, [sp, #0x4]
 80150a0: 2300         	movs	r3, #0x0
 80150a2: 9300         	str	r3, [sp]
 80150a4: 2300         	movs	r3, #0x0
 80150a6: 2204         	movs	r2, #0x4
 80150a8: 2000         	movs	r0, #0x0
 80150aa: f011 ff7e    	bl	0x8026faa <z_log_msg_runtime_create> @ imm = #0x11efc
 80150ae: 2300         	movs	r3, #0x0
 80150b0: f8c7 30c8    	str.w	r3, [r7, #0xc8]
; 	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
 80150b4: 68fb         	ldr	r3, [r7, #0xc]
 80150b6: 689b         	ldr	r3, [r3, #0x8]
 80150b8: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 80150bc: 4619         	mov	r1, r3
 80150be: f8d7 00d0    	ldr.w	r0, [r7, #0xd0]
 80150c2: f011 ff31    	bl	0x8026f28 <z_is_prio_higher> @ imm = #0x11e62
 80150c6: 4603         	mov	r3, r0
 80150c8: 2b00         	cmp	r3, #0x0
 80150ca: d007         	beq	0x80150dc <z_impl_k_mutex_lock+0x218> @ imm = #0xe
; 		resched = adjust_owner_prio(mutex, new_prio);
 80150cc: f8d7 10d0    	ldr.w	r1, [r7, #0xd0]
 80150d0: 68f8         	ldr	r0, [r7, #0xc]
 80150d2: f7ff fea3    	bl	0x8014e1c <adjust_owner_prio> @ imm = #-0x2ba
 80150d6: 4603         	mov	r3, r0
 80150d8: f887 30d7    	strb.w	r3, [r7, #0xd7]
; 	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
 80150dc: 68f9         	ldr	r1, [r7, #0xc]
 80150de: e9d7 2300    	ldrd	r2, r3, [r7]
 80150e2: e9cd 2300    	strd	r2, r3, [sp]
 80150e6: 460a         	mov	r2, r1
 80150e8: 6a79         	ldr	r1, [r7, #0x24]
 80150ea: 4821         	ldr	r0, [pc, #0x84]         @ 0x8015170 <z_impl_k_mutex_lock+0x2ac>
 80150ec: f001 fe8c    	bl	0x8016e08 <z_pend_curr> @ imm = #0x1d18
 80150f0: f8c7 00c4    	str.w	r0, [r7, #0xc4]
; 	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);
 80150f4: 2303         	movs	r3, #0x3
 80150f6: 2b03         	cmp	r3, #0x3
 80150f8: d920         	bls	0x801513c <z_impl_k_mutex_lock+0x278> @ imm = #0x40
 80150fa: 2301         	movs	r3, #0x1
 80150fc: f887 30c3    	strb.w	r3, [r7, #0xc3]
 8015100: f897 30c3    	ldrb.w	r3, [r7, #0xc3]
 8015104: f083 0301    	eor	r3, r3, #0x1
 8015108: b2db         	uxtb	r3, r3
 801510a: 2b00         	cmp	r3, #0x0
 801510c: d116         	bne	0x801513c <z_impl_k_mutex_lock+0x278> @ imm = #0x2c
 801510e: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8015178 <z_impl_k_mutex_lock+0x2b4>
 8015110: 6819         	ldr	r1, [r3]
 8015112: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8015116: 9305         	str	r3, [sp, #0x14]
 8015118: 68fb         	ldr	r3, [r7, #0xc]
 801511a: 9304         	str	r3, [sp, #0x10]
 801511c: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x801517c <z_impl_k_mutex_lock+0x2b8>
 801511e: 9303         	str	r3, [sp, #0xc]
 8015120: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8015188 <z_impl_k_mutex_lock+0x2c4>
 8015122: 9302         	str	r3, [sp, #0x8]
 8015124: 2308         	movs	r3, #0x8
 8015126: 9301         	str	r3, [sp, #0x4]
 8015128: 2300         	movs	r3, #0x0
 801512a: 9300         	str	r3, [sp]
 801512c: 2300         	movs	r3, #0x0
 801512e: 2204         	movs	r2, #0x4
 8015130: 2000         	movs	r0, #0x0
 8015132: f011 ff3a    	bl	0x8026faa <z_log_msg_runtime_create> @ imm = #0x11e74
 8015136: 2300         	movs	r3, #0x0
 8015138: f8c7 30bc    	str.w	r3, [r7, #0xbc]
; 	LOG_DBG("%p got mutex %p (y/n): %c", arch_current_thread(), mutex,
 801513c: 2303         	movs	r3, #0x3
 801513e: 2b03         	cmp	r3, #0x3
 8015140: d939         	bls	0x80151b6 <z_impl_k_mutex_lock+0x2f2> @ imm = #0x72
 8015142: 2301         	movs	r3, #0x1
 8015144: f887 30bb    	strb.w	r3, [r7, #0xbb]
 8015148: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 801514c: f083 0301    	eor	r3, r3, #0x1
 8015150: b2db         	uxtb	r3, r3
 8015152: 2b00         	cmp	r3, #0x0
 8015154: d12f         	bne	0x80151b6 <z_impl_k_mutex_lock+0x2f2> @ imm = #0x5e
 8015156: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8015178 <z_impl_k_mutex_lock+0x2b4>
 8015158: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801515a: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8015174 <z_impl_k_mutex_lock+0x2b0>
 801515c: 689b         	ldr	r3, [r3, #0x8]
 801515e: 653b         	str	r3, [r7, #0x50]
; 	return ret;
 8015160: 6d3b         	ldr	r3, [r7, #0x50]
; 	LOG_DBG("%p got mutex %p (y/n): %c", arch_current_thread(), mutex,
 8015162: f8d7 20c4    	ldr.w	r2, [r7, #0xc4]
 8015166: 2a00         	cmp	r2, #0x0
 8015168: d010         	beq	0x801518c <z_impl_k_mutex_lock+0x2c8> @ imm = #0x20
 801516a: 2279         	movs	r2, #0x79
 801516c: e00f         	b	0x801518e <z_impl_k_mutex_lock+0x2ca> @ imm = #0x1e
 801516e: bf00         	nop

08015170 <$d>:
 8015170: d0 32 00 24  	.word	0x240032d0
 8015174: 60 20 00 24  	.word	0x24002060
 8015178: 6c 0b 00 24  	.word	0x24000b6c
 801517c: f8 e5 02 08  	.word	0x0802e5f8
 8015180: 28 c8 02 08  	.word	0x0802c828
 8015184: 58 c8 02 08  	.word	0x0802c858
 8015188: 7c c8 02 08  	.word	0x0802c87c

0801518c <$t>:
 801518c: 226e         	movs	r2, #0x6e
 801518e: 9206         	str	r2, [sp, #0x18]
 8015190: 68fa         	ldr	r2, [r7, #0xc]
 8015192: 9205         	str	r2, [sp, #0x14]
 8015194: 9304         	str	r3, [sp, #0x10]
 8015196: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x801533c <z_impl_k_mutex_lock+0x478>
 8015198: 9303         	str	r3, [sp, #0xc]
 801519a: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8015340 <z_impl_k_mutex_lock+0x47c>
 801519c: 9302         	str	r3, [sp, #0x8]
 801519e: 2308         	movs	r3, #0x8
 80151a0: 9301         	str	r3, [sp, #0x4]
 80151a2: 2300         	movs	r3, #0x0
 80151a4: 9300         	str	r3, [sp]
 80151a6: 2300         	movs	r3, #0x0
 80151a8: 2204         	movs	r2, #0x4
 80151aa: 2000         	movs	r0, #0x0
 80151ac: f011 fefd    	bl	0x8026faa <z_log_msg_runtime_create> @ imm = #0x11dfa
 80151b0: 2300         	movs	r3, #0x0
 80151b2: f8c7 30b4    	str.w	r3, [r7, #0xb4]
; 	if (got_mutex == 0) {
 80151b6: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 80151ba: 2b00         	cmp	r3, #0x0
 80151bc: d101         	bne	0x80151c2 <z_impl_k_mutex_lock+0x2fe> @ imm = #0x2
; 		return 0;
 80151be: 2300         	movs	r3, #0x0
 80151c0: e0b7         	b	0x8015332 <z_impl_k_mutex_lock+0x46e> @ imm = #0x16e
; 	LOG_DBG("%p timeout on mutex %p", arch_current_thread(), mutex);
 80151c2: 2303         	movs	r3, #0x3
 80151c4: 2b03         	cmp	r3, #0x3
 80151c6: d922         	bls	0x801520e <z_impl_k_mutex_lock+0x34a> @ imm = #0x44
 80151c8: 2301         	movs	r3, #0x1
 80151ca: f887 30b3    	strb.w	r3, [r7, #0xb3]
 80151ce: f897 30b3    	ldrb.w	r3, [r7, #0xb3]
 80151d2: f083 0301    	eor	r3, r3, #0x1
 80151d6: b2db         	uxtb	r3, r3
 80151d8: 2b00         	cmp	r3, #0x0
 80151da: d118         	bne	0x801520e <z_impl_k_mutex_lock+0x34a> @ imm = #0x30
 80151dc: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8015344 <z_impl_k_mutex_lock+0x480>
 80151de: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80151e0: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8015348 <z_impl_k_mutex_lock+0x484>
 80151e2: 689b         	ldr	r3, [r3, #0x8]
 80151e4: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 80151e6: 6cfb         	ldr	r3, [r7, #0x4c]
; 	LOG_DBG("%p timeout on mutex %p", arch_current_thread(), mutex);
 80151e8: 68fa         	ldr	r2, [r7, #0xc]
 80151ea: 9205         	str	r2, [sp, #0x14]
 80151ec: 9304         	str	r3, [sp, #0x10]
 80151ee: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x801533c <z_impl_k_mutex_lock+0x478>
 80151f0: 9303         	str	r3, [sp, #0xc]
 80151f2: 4b56         	ldr	r3, [pc, #0x158]        @ 0x801534c <z_impl_k_mutex_lock+0x488>
 80151f4: 9302         	str	r3, [sp, #0x8]
 80151f6: 2308         	movs	r3, #0x8
 80151f8: 9301         	str	r3, [sp, #0x4]
 80151fa: 2300         	movs	r3, #0x0
 80151fc: 9300         	str	r3, [sp]
 80151fe: 2300         	movs	r3, #0x0
 8015200: 2204         	movs	r2, #0x4
 8015202: 2000         	movs	r0, #0x0
 8015204: f011 fed1    	bl	0x8026faa <z_log_msg_runtime_create> @ imm = #0x11da2
 8015208: 2300         	movs	r3, #0x0
 801520a: f8c7 30ac    	str.w	r3, [r7, #0xac]
 801520e: 4b50         	ldr	r3, [pc, #0x140]        @ 0x8015350 <z_impl_k_mutex_lock+0x48c>
 8015210: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015212: f3ef 8311    	mrs	r3, basepri
 8015216: 647b         	str	r3, [r7, #0x44]
;   return(result);
 8015218: 6c7b         	ldr	r3, [r7, #0x44]
; 	key = __get_BASEPRI();
 801521a: 643b         	str	r3, [r7, #0x40]
 801521c: 2310         	movs	r3, #0x10
 801521e: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015220: 6bfb         	ldr	r3, [r7, #0x3c]
 8015222: f383 8812    	msr	basepri_max, r3
; }
 8015226: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015228: f3bf 8f6f    	isb	sy
; }
 801522c: bf00         	nop
; 	return key;
 801522e: 6c3b         	ldr	r3, [r7, #0x40]
; 	k.key = arch_irq_lock();
 8015230: 61fb         	str	r3, [r7, #0x1c]
 8015232: 6cbb         	ldr	r3, [r7, #0x48]
 8015234: 63bb         	str	r3, [r7, #0x38]
; }
 8015236: bf00         	nop
 8015238: 6cbb         	ldr	r3, [r7, #0x48]
 801523a: 637b         	str	r3, [r7, #0x34]
; }
 801523c: bf00         	nop
; 	return k;
 801523e: 69fb         	ldr	r3, [r7, #0x1c]
 8015240: 627b         	str	r3, [r7, #0x24]
; 	if (likely(mutex->owner != NULL)) {
 8015242: 68fb         	ldr	r3, [r7, #0xc]
 8015244: 689b         	ldr	r3, [r3, #0x8]
 8015246: 2b00         	cmp	r3, #0x0
 8015248: bf14         	ite	ne
 801524a: 2301         	movne	r3, #0x1
 801524c: 2300         	moveq	r3, #0x0
 801524e: b2db         	uxtb	r3, r3
 8015250: 2b00         	cmp	r3, #0x0
 8015252: d052         	beq	0x80152fa <z_impl_k_mutex_lock+0x436> @ imm = #0xa4
; 		struct k_thread *waiter = z_waitq_head(&mutex->wait_q);
 8015254: 68fb         	ldr	r3, [r7, #0xc]
 8015256: 4618         	mov	r0, r3
 8015258: f011 fe9a    	bl	0x8026f90 <z_waitq_head> @ imm = #0x11d34
 801525c: f8c7 00a8    	str.w	r0, [r7, #0xa8]
; 			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
 8015260: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 8015264: 2b00         	cmp	r3, #0x0
 8015266: d00c         	beq	0x8015282 <z_impl_k_mutex_lock+0x3be> @ imm = #0x18
 8015268: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 801526c: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8015270: 461a         	mov	r2, r3
 8015272: 68fb         	ldr	r3, [r7, #0xc]
 8015274: 691b         	ldr	r3, [r3, #0x10]
 8015276: 4619         	mov	r1, r3
 8015278: 4610         	mov	r0, r2
 801527a: f011 feca    	bl	0x8027012 <new_prio_for_inheritance> @ imm = #0x11d94
 801527e: 4603         	mov	r3, r0
 8015280: e001         	b	0x8015286 <z_impl_k_mutex_lock+0x3c2> @ imm = #0x2
 8015282: 68fb         	ldr	r3, [r7, #0xc]
 8015284: 691b         	ldr	r3, [r3, #0x10]
; 		new_prio = (waiter != NULL) ?
 8015286: f8c7 30d0    	str.w	r3, [r7, #0xd0]
; 		LOG_DBG("adjusting prio down on mutex %p", mutex);
 801528a: 2303         	movs	r3, #0x3
 801528c: 2b03         	cmp	r3, #0x3
 801528e: d91d         	bls	0x80152cc <z_impl_k_mutex_lock+0x408> @ imm = #0x3a
 8015290: 2301         	movs	r3, #0x1
 8015292: f887 30a7    	strb.w	r3, [r7, #0xa7]
 8015296: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 801529a: f083 0301    	eor	r3, r3, #0x1
 801529e: b2db         	uxtb	r3, r3
 80152a0: 2b00         	cmp	r3, #0x0
 80152a2: d113         	bne	0x80152cc <z_impl_k_mutex_lock+0x408> @ imm = #0x26
 80152a4: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8015344 <z_impl_k_mutex_lock+0x480>
 80152a6: 6819         	ldr	r1, [r3]
 80152a8: 68fb         	ldr	r3, [r7, #0xc]
 80152aa: 9304         	str	r3, [sp, #0x10]
 80152ac: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x801533c <z_impl_k_mutex_lock+0x478>
 80152ae: 9303         	str	r3, [sp, #0xc]
 80152b0: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8015354 <z_impl_k_mutex_lock+0x490>
 80152b2: 9302         	str	r3, [sp, #0x8]
 80152b4: 2308         	movs	r3, #0x8
 80152b6: 9301         	str	r3, [sp, #0x4]
 80152b8: 2300         	movs	r3, #0x0
 80152ba: 9300         	str	r3, [sp]
 80152bc: 2300         	movs	r3, #0x0
 80152be: 2204         	movs	r2, #0x4
 80152c0: 2000         	movs	r0, #0x0
 80152c2: f011 fe72    	bl	0x8026faa <z_log_msg_runtime_create> @ imm = #0x11ce4
 80152c6: 2300         	movs	r3, #0x0
 80152c8: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; 		resched = adjust_owner_prio(mutex, new_prio) || resched;
 80152cc: f8d7 10d0    	ldr.w	r1, [r7, #0xd0]
 80152d0: 68f8         	ldr	r0, [r7, #0xc]
 80152d2: f7ff fda3    	bl	0x8014e1c <adjust_owner_prio> @ imm = #-0x4ba
 80152d6: 4603         	mov	r3, r0
 80152d8: 2b00         	cmp	r3, #0x0
 80152da: d103         	bne	0x80152e4 <z_impl_k_mutex_lock+0x420> @ imm = #0x6
 80152dc: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 80152e0: 2b00         	cmp	r3, #0x0
 80152e2: d001         	beq	0x80152e8 <z_impl_k_mutex_lock+0x424> @ imm = #0x2
 80152e4: 2301         	movs	r3, #0x1
 80152e6: e000         	b	0x80152ea <z_impl_k_mutex_lock+0x426> @ imm = #0x0
 80152e8: 2300         	movs	r3, #0x0
 80152ea: f887 30d7    	strb.w	r3, [r7, #0xd7]
 80152ee: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 80152f2: f003 0301    	and	r3, r3, #0x1
 80152f6: f887 30d7    	strb.w	r3, [r7, #0xd7]
; 	if (resched) {
 80152fa: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 80152fe: 2b00         	cmp	r3, #0x0
 8015300: d004         	beq	0x801530c <z_impl_k_mutex_lock+0x448> @ imm = #0x8
; 		z_reschedule(&lock, key);
 8015302: 6a79         	ldr	r1, [r7, #0x24]
 8015304: 4812         	ldr	r0, [pc, #0x48]         @ 0x8015350 <z_impl_k_mutex_lock+0x48c>
 8015306: f013 fb29    	bl	0x802895c <z_reschedule> @ imm = #0x13652
 801530a: e010         	b	0x801532e <z_impl_k_mutex_lock+0x46a> @ imm = #0x20
 801530c: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8015350 <z_impl_k_mutex_lock+0x48c>
 801530e: 633b         	str	r3, [r7, #0x30]
 8015310: 6a7b         	ldr	r3, [r7, #0x24]
 8015312: 623b         	str	r3, [r7, #0x20]
; 	arch_irq_unlock(key.key);
 8015314: 6a3b         	ldr	r3, [r7, #0x20]
 8015316: 62fb         	str	r3, [r7, #0x2c]
 8015318: 6afb         	ldr	r3, [r7, #0x2c]
 801531a: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801531c: 6abb         	ldr	r3, [r7, #0x28]
 801531e: f383 8811    	msr	basepri, r3
; }
 8015322: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015324: f3bf 8f6f    	isb	sy
; }
 8015328: bf00         	nop
; }
 801532a: bf00         	nop
; }
 801532c: bf00         	nop
; 	return -EAGAIN;
 801532e: f06f 030a    	mvn	r3, #0xa
; }
 8015332: 4618         	mov	r0, r3
 8015334: 37d8         	adds	r7, #0xd8
 8015336: 46bd         	mov	sp, r7
 8015338: bd80         	pop	{r7, pc}
 801533a: bf00         	nop

0801533c <$d>:
 801533c: f8 e5 02 08  	.word	0x0802e5f8
 8015340: a0 c8 02 08  	.word	0x0802c8a0
 8015344: 6c 0b 00 24  	.word	0x24000b6c
 8015348: 60 20 00 24  	.word	0x24002060
 801534c: c0 c8 02 08  	.word	0x0802c8c0
 8015350: d0 32 00 24  	.word	0x240032d0
 8015354: dc c8 02 08  	.word	0x0802c8dc

08015358 <z_impl_k_mutex_unlock>:
; {
 8015358: b580         	push	{r7, lr}
 801535a: b0a4         	sub	sp, #0x90
 801535c: af08         	add	r7, sp, #0x20
 801535e: 6078         	str	r0, [r7, #0x4]
; 	CHECKIF(mutex->owner == NULL) {
 8015360: 687b         	ldr	r3, [r7, #0x4]
 8015362: 689b         	ldr	r3, [r3, #0x8]
 8015364: 2b00         	cmp	r3, #0x0
 8015366: d102         	bne	0x801536e <z_impl_k_mutex_unlock+0x16> @ imm = #0x4
; 		return -EINVAL;
 8015368: f06f 0315    	mvn	r3, #0x15
 801536c: e0dc         	b	0x8015528 <z_impl_k_mutex_unlock+0x1d0> @ imm = #0x1b8
; 	CHECKIF(mutex->owner != arch_current_thread()) {
 801536e: 687b         	ldr	r3, [r7, #0x4]
 8015370: 689a         	ldr	r2, [r3, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015372: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x8015530 <z_impl_k_mutex_unlock+0x1d8>
 8015374: 689b         	ldr	r3, [r3, #0x8]
 8015376: 65bb         	str	r3, [r7, #0x58]
; 	return ret;
 8015378: 6dbb         	ldr	r3, [r7, #0x58]
; 	CHECKIF(mutex->owner != arch_current_thread()) {
 801537a: 429a         	cmp	r2, r3
 801537c: d002         	beq	0x8015384 <z_impl_k_mutex_unlock+0x2c> @ imm = #0x4
; 		return -EPERM;
 801537e: f04f 33ff    	mov.w	r3, #0xffffffff
 8015382: e0d1         	b	0x8015528 <z_impl_k_mutex_unlock+0x1d0> @ imm = #0x1a2
; 	LOG_DBG("mutex %p lock_count: %d", mutex, mutex->lock_count);
 8015384: 2303         	movs	r3, #0x3
 8015386: 2b03         	cmp	r3, #0x3
 8015388: d91f         	bls	0x80153ca <z_impl_k_mutex_unlock+0x72> @ imm = #0x3e
 801538a: 2301         	movs	r3, #0x1
 801538c: f887 306f    	strb.w	r3, [r7, #0x6f]
 8015390: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 8015394: f083 0301    	eor	r3, r3, #0x1
 8015398: b2db         	uxtb	r3, r3
 801539a: 2b00         	cmp	r3, #0x0
 801539c: d115         	bne	0x80153ca <z_impl_k_mutex_unlock+0x72> @ imm = #0x2a
 801539e: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8015534 <z_impl_k_mutex_unlock+0x1dc>
 80153a0: 6819         	ldr	r1, [r3]
 80153a2: 687b         	ldr	r3, [r7, #0x4]
 80153a4: 68db         	ldr	r3, [r3, #0xc]
 80153a6: 9305         	str	r3, [sp, #0x14]
 80153a8: 687b         	ldr	r3, [r7, #0x4]
 80153aa: 9304         	str	r3, [sp, #0x10]
 80153ac: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8015538 <z_impl_k_mutex_unlock+0x1e0>
 80153ae: 9303         	str	r3, [sp, #0xc]
 80153b0: 4b62         	ldr	r3, [pc, #0x188]        @ 0x801553c <z_impl_k_mutex_unlock+0x1e4>
 80153b2: 9302         	str	r3, [sp, #0x8]
 80153b4: 2308         	movs	r3, #0x8
 80153b6: 9301         	str	r3, [sp, #0x4]
 80153b8: 2300         	movs	r3, #0x0
 80153ba: 9300         	str	r3, [sp]
 80153bc: 2300         	movs	r3, #0x0
 80153be: 2204         	movs	r2, #0x4
 80153c0: 2000         	movs	r0, #0x0
 80153c2: f011 fdf2    	bl	0x8026faa <z_log_msg_runtime_create> @ imm = #0x11be4
 80153c6: 2300         	movs	r3, #0x0
 80153c8: 66bb         	str	r3, [r7, #0x68]
; 	if (mutex->lock_count > 1U) {
 80153ca: 687b         	ldr	r3, [r7, #0x4]
 80153cc: 68db         	ldr	r3, [r3, #0xc]
 80153ce: 2b01         	cmp	r3, #0x1
 80153d0: d905         	bls	0x80153de <z_impl_k_mutex_unlock+0x86> @ imm = #0xa
; 		mutex->lock_count--;
 80153d2: 687b         	ldr	r3, [r7, #0x4]
 80153d4: 68db         	ldr	r3, [r3, #0xc]
 80153d6: 1e5a         	subs	r2, r3, #0x1
 80153d8: 687b         	ldr	r3, [r7, #0x4]
 80153da: 60da         	str	r2, [r3, #0xc]
; 		goto k_mutex_unlock_return;
 80153dc: e0a3         	b	0x8015526 <z_impl_k_mutex_unlock+0x1ce> @ imm = #0x146
 80153de: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8015540 <z_impl_k_mutex_unlock+0x1e8>
 80153e0: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80153e2: f3ef 8311    	mrs	r3, basepri
 80153e6: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 80153e8: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 80153ea: 63bb         	str	r3, [r7, #0x38]
 80153ec: 2310         	movs	r3, #0x10
 80153ee: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80153f0: 6b7b         	ldr	r3, [r7, #0x34]
 80153f2: f383 8812    	msr	basepri_max, r3
; }
 80153f6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80153f8: f3bf 8f6f    	isb	sy
; }
 80153fc: bf00         	nop
; 	return key;
 80153fe: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 8015400: 60fb         	str	r3, [r7, #0xc]
 8015402: 6c3b         	ldr	r3, [r7, #0x40]
 8015404: 633b         	str	r3, [r7, #0x30]
; }
 8015406: bf00         	nop
 8015408: 6c3b         	ldr	r3, [r7, #0x40]
 801540a: 62fb         	str	r3, [r7, #0x2c]
; }
 801540c: bf00         	nop
; 	return k;
 801540e: 68fb         	ldr	r3, [r7, #0xc]
 8015410: 617b         	str	r3, [r7, #0x14]
; 	adjust_owner_prio(mutex, mutex->owner_orig_prio);
 8015412: 687b         	ldr	r3, [r7, #0x4]
 8015414: 691b         	ldr	r3, [r3, #0x10]
 8015416: 4619         	mov	r1, r3
 8015418: 6878         	ldr	r0, [r7, #0x4]
 801541a: f7ff fcff    	bl	0x8014e1c <adjust_owner_prio> @ imm = #-0x602
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 801541e: 687b         	ldr	r3, [r7, #0x4]
 8015420: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 8015422: 2300         	movs	r3, #0x0
 8015424: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8015426: 6d7b         	ldr	r3, [r7, #0x54]
 8015428: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 801542a: 2300         	movs	r3, #0x0
 801542c: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 801542e: 6cf8         	ldr	r0, [r7, #0x4c]
 8015430: f011 fc8d    	bl	0x8026d4e <sys_dlist_peek_head> @ imm = #0x1191a
 8015434: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8015436: 6c7b         	ldr	r3, [r7, #0x44]
 8015438: 2b00         	cmp	r3, #0x0
 801543a: d001         	beq	0x8015440 <z_impl_k_mutex_unlock+0xe8> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 801543c: 6c7b         	ldr	r3, [r7, #0x44]
 801543e: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 8015440: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8015442: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 8015444: 6d3b         	ldr	r3, [r7, #0x50]
 8015446: 2b00         	cmp	r3, #0x0
 8015448: bf14         	ite	ne
 801544a: 2301         	movne	r3, #0x1
 801544c: 2300         	moveq	r3, #0x0
 801544e: b2db         	uxtb	r3, r3
 8015450: 2b00         	cmp	r3, #0x0
 8015452: d005         	beq	0x8015460 <z_impl_k_mutex_unlock+0x108> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 8015454: 6d38         	ldr	r0, [r7, #0x50]
 8015456: f011 fd75    	bl	0x8026f44 <unpend_thread_no_timeout> @ imm = #0x11aea
; 			(void)z_abort_thread_timeout(thread);
 801545a: 6d38         	ldr	r0, [r7, #0x50]
 801545c: f011 fcc2    	bl	0x8026de4 <z_abort_thread_timeout> @ imm = #0x11984
; 	return thread;
 8015460: 6d3b         	ldr	r3, [r7, #0x50]
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 8015462: 667b         	str	r3, [r7, #0x64]
; 	mutex->owner = new_owner;
 8015464: 687b         	ldr	r3, [r7, #0x4]
 8015466: 6e7a         	ldr	r2, [r7, #0x64]
 8015468: 609a         	str	r2, [r3, #0x8]
; 	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
 801546a: 2303         	movs	r3, #0x3
 801546c: 2b03         	cmp	r3, #0x3
 801546e: d927         	bls	0x80154c0 <z_impl_k_mutex_unlock+0x168> @ imm = #0x4e
 8015470: 2301         	movs	r3, #0x1
 8015472: f887 3063    	strb.w	r3, [r7, #0x63]
 8015476: f897 3063    	ldrb.w	r3, [r7, #0x63]
 801547a: f083 0301    	eor	r3, r3, #0x1
 801547e: b2db         	uxtb	r3, r3
 8015480: 2b00         	cmp	r3, #0x0
 8015482: d11d         	bne	0x80154c0 <z_impl_k_mutex_unlock+0x168> @ imm = #0x3a
 8015484: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8015534 <z_impl_k_mutex_unlock+0x1dc>
 8015486: 6819         	ldr	r1, [r3]
 8015488: 6e7b         	ldr	r3, [r7, #0x64]
 801548a: 2b00         	cmp	r3, #0x0
 801548c: d003         	beq	0x8015496 <z_impl_k_mutex_unlock+0x13e> @ imm = #0x6
 801548e: 6e7b         	ldr	r3, [r7, #0x64]
 8015490: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8015494: e000         	b	0x8015498 <z_impl_k_mutex_unlock+0x140> @ imm = #0x0
 8015496: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8015544 <z_impl_k_mutex_unlock+0x1ec>
 8015498: 9306         	str	r3, [sp, #0x18]
 801549a: 6e7b         	ldr	r3, [r7, #0x64]
 801549c: 9305         	str	r3, [sp, #0x14]
 801549e: 687b         	ldr	r3, [r7, #0x4]
 80154a0: 9304         	str	r3, [sp, #0x10]
 80154a2: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8015538 <z_impl_k_mutex_unlock+0x1e0>
 80154a4: 9303         	str	r3, [sp, #0xc]
 80154a6: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8015548 <z_impl_k_mutex_unlock+0x1f0>
 80154a8: 9302         	str	r3, [sp, #0x8]
 80154aa: 2308         	movs	r3, #0x8
 80154ac: 9301         	str	r3, [sp, #0x4]
 80154ae: 2300         	movs	r3, #0x0
 80154b0: 9300         	str	r3, [sp]
 80154b2: 2300         	movs	r3, #0x0
 80154b4: 2204         	movs	r2, #0x4
 80154b6: 2000         	movs	r0, #0x0
 80154b8: f011 fd77    	bl	0x8026faa <z_log_msg_runtime_create> @ imm = #0x11aee
 80154bc: 2300         	movs	r3, #0x0
 80154be: 65fb         	str	r3, [r7, #0x5c]
; 	if (unlikely(new_owner != NULL)) {
 80154c0: 6e7b         	ldr	r3, [r7, #0x64]
 80154c2: 2b00         	cmp	r3, #0x0
 80154c4: bf14         	ite	ne
 80154c6: 2301         	movne	r3, #0x1
 80154c8: 2300         	moveq	r3, #0x0
 80154ca: b2db         	uxtb	r3, r3
 80154cc: 2b00         	cmp	r3, #0x0
 80154ce: d016         	beq	0x80154fe <z_impl_k_mutex_unlock+0x1a6> @ imm = #0x2c
; 		mutex->owner_orig_prio = new_owner->base.prio;
 80154d0: 6e7b         	ldr	r3, [r7, #0x64]
 80154d2: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 80154d6: 461a         	mov	r2, r3
 80154d8: 687b         	ldr	r3, [r7, #0x4]
 80154da: 611a         	str	r2, [r3, #0x10]
 80154dc: 6e7b         	ldr	r3, [r7, #0x64]
 80154de: 62bb         	str	r3, [r7, #0x28]
 80154e0: 2300         	movs	r3, #0x0
 80154e2: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 80154e4: 6abb         	ldr	r3, [r7, #0x28]
 80154e6: 6a7a         	ldr	r2, [r7, #0x24]
 80154e8: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 80154ec: bf00         	nop
; 		z_ready_thread(new_owner);
 80154ee: 6e78         	ldr	r0, [r7, #0x64]
 80154f0: f001 f888    	bl	0x8016604 <z_ready_thread> @ imm = #0x1110
; 		z_reschedule(&lock, key);
 80154f4: 6979         	ldr	r1, [r7, #0x14]
 80154f6: 4812         	ldr	r0, [pc, #0x48]         @ 0x8015540 <z_impl_k_mutex_unlock+0x1e8>
 80154f8: f013 fa30    	bl	0x802895c <z_reschedule> @ imm = #0x13460
 80154fc: e013         	b	0x8015526 <z_impl_k_mutex_unlock+0x1ce> @ imm = #0x26
; 		mutex->lock_count = 0U;
 80154fe: 687b         	ldr	r3, [r7, #0x4]
 8015500: 2200         	movs	r2, #0x0
 8015502: 60da         	str	r2, [r3, #0xc]
 8015504: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8015540 <z_impl_k_mutex_unlock+0x1e8>
 8015506: 623b         	str	r3, [r7, #0x20]
 8015508: 697b         	ldr	r3, [r7, #0x14]
 801550a: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 801550c: 693b         	ldr	r3, [r7, #0x10]
 801550e: 61fb         	str	r3, [r7, #0x1c]
 8015510: 69fb         	ldr	r3, [r7, #0x1c]
 8015512: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015514: 69bb         	ldr	r3, [r7, #0x18]
 8015516: f383 8811    	msr	basepri, r3
; }
 801551a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801551c: f3bf 8f6f    	isb	sy
; }
 8015520: bf00         	nop
; }
 8015522: bf00         	nop
; }
 8015524: bf00         	nop
; 	return 0;
 8015526: 2300         	movs	r3, #0x0
; }
 8015528: 4618         	mov	r0, r3
 801552a: 3770         	adds	r7, #0x70
 801552c: 46bd         	mov	sp, r7
 801552e: bd80         	pop	{r7, pc}

08015530 <$d>:
 8015530: 60 20 00 24  	.word	0x24002060
 8015534: 6c 0b 00 24  	.word	0x24000b6c
 8015538: 0c e6 02 08  	.word	0x0802e60c
 801553c: 00 c9 02 08  	.word	0x0802c900
 8015540: d0 32 00 24  	.word	0x240032d0
 8015544: 18 fc ff ff  	.word	0xfffffc18
 8015548: 1c c9 02 08  	.word	0x0802c91c

0801554c <z_impl_k_queue_get>:
; {
 801554c: b580         	push	{r7, lr}
 801554e: b09a         	sub	sp, #0x68
 8015550: af02         	add	r7, sp, #0x8
 8015552: 60f8         	str	r0, [r7, #0xc]
 8015554: e9c7 2300    	strd	r2, r3, [r7]
; 	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 8015558: 68fb         	ldr	r3, [r7, #0xc]
 801555a: 3308         	adds	r3, #0x8
 801555c: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801555e: f3ef 8311    	mrs	r3, basepri
 8015562: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 8015564: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 8015566: 64bb         	str	r3, [r7, #0x48]
 8015568: 2310         	movs	r3, #0x10
 801556a: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801556c: 6c7b         	ldr	r3, [r7, #0x44]
 801556e: f383 8812    	msr	basepri_max, r3
; }
 8015572: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015574: f3bf 8f6f    	isb	sy
; }
 8015578: bf00         	nop
; 	return key;
 801557a: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 801557c: 61bb         	str	r3, [r7, #0x18]
 801557e: 6d3b         	ldr	r3, [r7, #0x50]
 8015580: 643b         	str	r3, [r7, #0x40]
; }
 8015582: bf00         	nop
 8015584: 6d3b         	ldr	r3, [r7, #0x50]
 8015586: 63fb         	str	r3, [r7, #0x3c]
; }
 8015588: bf00         	nop
; 	return k;
 801558a: 69bb         	ldr	r3, [r7, #0x18]
 801558c: 61fb         	str	r3, [r7, #0x1c]
; 	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
 801558e: 68fb         	ldr	r3, [r7, #0xc]
 8015590: 4618         	mov	r0, r3
 8015592: f011 fe16    	bl	0x80271c2 <sys_sflist_is_empty> @ imm = #0x11c2c
 8015596: 4603         	mov	r3, r0
 8015598: f083 0301    	eor	r3, r3, #0x1
 801559c: b2db         	uxtb	r3, r3
 801559e: 2b00         	cmp	r3, #0x0
 80155a0: d01d         	beq	0x80155de <z_impl_k_queue_get+0x92> @ imm = #0x3a
; 		node = sys_sflist_get_not_empty(&queue->data_q);
 80155a2: 68fb         	ldr	r3, [r7, #0xc]
 80155a4: 4618         	mov	r0, r3
 80155a6: f011 fe8e    	bl	0x80272c6 <sys_sflist_get_not_empty> @ imm = #0x11d1c
 80155aa: 65b8         	str	r0, [r7, #0x58]
; 		data = z_queue_node_peek(node, true);
 80155ac: 2101         	movs	r1, #0x1
 80155ae: 6db8         	ldr	r0, [r7, #0x58]
 80155b0: f011 fef3    	bl	0x802739a <z_queue_node_peek> @ imm = #0x11de6
 80155b4: 6578         	str	r0, [r7, #0x54]
; 		k_spin_unlock(&queue->lock, key);
 80155b6: 68fb         	ldr	r3, [r7, #0xc]
 80155b8: 3308         	adds	r3, #0x8
 80155ba: 63bb         	str	r3, [r7, #0x38]
 80155bc: 69fb         	ldr	r3, [r7, #0x1c]
 80155be: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 80155c0: 697b         	ldr	r3, [r7, #0x14]
 80155c2: 637b         	str	r3, [r7, #0x34]
 80155c4: 6b7b         	ldr	r3, [r7, #0x34]
 80155c6: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80155c8: 6b3b         	ldr	r3, [r7, #0x30]
 80155ca: f383 8811    	msr	basepri, r3
; }
 80155ce: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80155d0: f3bf 8f6f    	isb	sy
; }
 80155d4: bf00         	nop
; }
 80155d6: bf00         	nop
; }
 80155d8: bf00         	nop
; 		return data;
 80155da: 6d7b         	ldr	r3, [r7, #0x54]
 80155dc: e036         	b	0x801564c <z_impl_k_queue_get+0x100> @ imm = #0x6c
; 	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 80155de: e9d7 2300    	ldrd	r2, r3, [r7]
 80155e2: f04f 0000    	mov.w	r0, #0x0
 80155e6: f04f 0100    	mov.w	r1, #0x0
 80155ea: 428b         	cmp	r3, r1
 80155ec: bf08         	it	eq
 80155ee: 4282         	cmpeq	r2, r0
 80155f0: d113         	bne	0x801561a <z_impl_k_queue_get+0xce> @ imm = #0x26
; 		k_spin_unlock(&queue->lock, key);
 80155f2: 68fb         	ldr	r3, [r7, #0xc]
 80155f4: 3308         	adds	r3, #0x8
 80155f6: 62fb         	str	r3, [r7, #0x2c]
 80155f8: 69fb         	ldr	r3, [r7, #0x1c]
 80155fa: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 80155fc: 693b         	ldr	r3, [r7, #0x10]
 80155fe: 62bb         	str	r3, [r7, #0x28]
 8015600: 6abb         	ldr	r3, [r7, #0x28]
 8015602: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015604: 6a7b         	ldr	r3, [r7, #0x24]
 8015606: f383 8811    	msr	basepri, r3
; }
 801560a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801560c: f3bf 8f6f    	isb	sy
; }
 8015610: bf00         	nop
; }
 8015612: bf00         	nop
; }
 8015614: bf00         	nop
; 		return NULL;
 8015616: 2300         	movs	r3, #0x0
 8015618: e018         	b	0x801564c <z_impl_k_queue_get+0x100> @ imm = #0x30
; 	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
 801561a: 68fb         	ldr	r3, [r7, #0xc]
 801561c: f103 0008    	add.w	r0, r3, #0x8
 8015620: 68fb         	ldr	r3, [r7, #0xc]
 8015622: f103 0108    	add.w	r1, r3, #0x8
 8015626: e9d7 2300    	ldrd	r2, r3, [r7]
 801562a: e9cd 2300    	strd	r2, r3, [sp]
 801562e: 460a         	mov	r2, r1
 8015630: 69f9         	ldr	r1, [r7, #0x1c]
 8015632: f001 fbe9    	bl	0x8016e08 <z_pend_curr> @ imm = #0x17d2
 8015636: 65f8         	str	r0, [r7, #0x5c]
; 	return (ret != 0) ? NULL : arch_current_thread()->base.swap_data;
 8015638: 6dfb         	ldr	r3, [r7, #0x5c]
 801563a: 2b00         	cmp	r3, #0x0
 801563c: d105         	bne	0x801564a <z_impl_k_queue_get+0xfe> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801563e: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8015654 <z_impl_k_queue_get+0x108>
 8015640: 689b         	ldr	r3, [r3, #0x8]
 8015642: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 8015644: 6a3b         	ldr	r3, [r7, #0x20]
; 	return (ret != 0) ? NULL : arch_current_thread()->base.swap_data;
 8015646: 695b         	ldr	r3, [r3, #0x14]
 8015648: e000         	b	0x801564c <z_impl_k_queue_get+0x100> @ imm = #0x0
 801564a: 2300         	movs	r3, #0x0
; }
 801564c: 4618         	mov	r0, r3
 801564e: 3760         	adds	r7, #0x60
 8015650: 46bd         	mov	sp, r7
 8015652: bd80         	pop	{r7, pc}

08015654 <$d>:
 8015654: 60 20 00 24  	.word	0x24002060

08015658 <z_impl_k_sem_give>:
; {
 8015658: b580         	push	{r7, lr}
 801565a: b098         	sub	sp, #0x60
 801565c: af00         	add	r7, sp, #0x0
 801565e: 6078         	str	r0, [r7, #0x4]
 8015660: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8015770 <z_impl_k_sem_give+0x118>
 8015662: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015664: f3ef 8311    	mrs	r3, basepri
 8015668: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 801566a: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 801566c: 63bb         	str	r3, [r7, #0x38]
 801566e: 2310         	movs	r3, #0x10
 8015670: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015672: 6b7b         	ldr	r3, [r7, #0x34]
 8015674: f383 8812    	msr	basepri_max, r3
; }
 8015678: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801567a: f3bf 8f6f    	isb	sy
; }
 801567e: bf00         	nop
; 	return key;
 8015680: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 8015682: 60fb         	str	r3, [r7, #0xc]
 8015684: 6c3b         	ldr	r3, [r7, #0x40]
 8015686: 633b         	str	r3, [r7, #0x30]
; }
 8015688: bf00         	nop
 801568a: 6c3b         	ldr	r3, [r7, #0x40]
 801568c: 62fb         	str	r3, [r7, #0x2c]
; }
 801568e: bf00         	nop
; 	return k;
 8015690: 68fb         	ldr	r3, [r7, #0xc]
 8015692: 617b         	str	r3, [r7, #0x14]
; 	bool resched = true;
 8015694: 2301         	movs	r3, #0x1
 8015696: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 801569a: 687b         	ldr	r3, [r7, #0x4]
 801569c: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 801569e: 2300         	movs	r3, #0x0
 80156a0: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 80156a2: 6d7b         	ldr	r3, [r7, #0x54]
 80156a4: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 80156a6: 2300         	movs	r3, #0x0
 80156a8: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 80156aa: 6cf8         	ldr	r0, [r7, #0x4c]
 80156ac: f011 ffbd    	bl	0x802762a <sys_dlist_peek_head> @ imm = #0x11f7a
 80156b0: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 80156b2: 6c7b         	ldr	r3, [r7, #0x44]
 80156b4: 2b00         	cmp	r3, #0x0
 80156b6: d001         	beq	0x80156bc <z_impl_k_sem_give+0x64> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 80156b8: 6c7b         	ldr	r3, [r7, #0x44]
 80156ba: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 80156bc: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 80156be: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 80156c0: 6d3b         	ldr	r3, [r7, #0x50]
 80156c2: 2b00         	cmp	r3, #0x0
 80156c4: bf14         	ite	ne
 80156c6: 2301         	movne	r3, #0x1
 80156c8: 2300         	moveq	r3, #0x0
 80156ca: b2db         	uxtb	r3, r3
 80156cc: 2b00         	cmp	r3, #0x0
 80156ce: d005         	beq	0x80156dc <z_impl_k_sem_give+0x84> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 80156d0: 6d38         	ldr	r0, [r7, #0x50]
 80156d2: f012 f808    	bl	0x80276e6 <unpend_thread_no_timeout> @ imm = #0x12010
; 			(void)z_abort_thread_timeout(thread);
 80156d6: 6d38         	ldr	r0, [r7, #0x50]
 80156d8: f011 ffda    	bl	0x8027690 <z_abort_thread_timeout> @ imm = #0x11fb4
; 	return thread;
 80156dc: 6d3b         	ldr	r3, [r7, #0x50]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 80156de: 65bb         	str	r3, [r7, #0x58]
; 	if (unlikely(thread != NULL)) {
 80156e0: 6dbb         	ldr	r3, [r7, #0x58]
 80156e2: 2b00         	cmp	r3, #0x0
 80156e4: bf14         	ite	ne
 80156e6: 2301         	movne	r3, #0x1
 80156e8: 2300         	moveq	r3, #0x0
 80156ea: b2db         	uxtb	r3, r3
 80156ec: 2b00         	cmp	r3, #0x0
 80156ee: d00c         	beq	0x801570a <z_impl_k_sem_give+0xb2> @ imm = #0x18
 80156f0: 6dbb         	ldr	r3, [r7, #0x58]
 80156f2: 62bb         	str	r3, [r7, #0x28]
 80156f4: 2300         	movs	r3, #0x0
 80156f6: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 80156f8: 6abb         	ldr	r3, [r7, #0x28]
 80156fa: 6a7a         	ldr	r2, [r7, #0x24]
 80156fc: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8015700: bf00         	nop
; 		z_ready_thread(thread);
 8015702: 6db8         	ldr	r0, [r7, #0x58]
 8015704: f000 ff7e    	bl	0x8016604 <z_ready_thread> @ imm = #0xefc
 8015708: e013         	b	0x8015732 <z_impl_k_sem_give+0xda> @ imm = #0x26
; 		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 801570a: 687b         	ldr	r3, [r7, #0x4]
 801570c: 689b         	ldr	r3, [r3, #0x8]
 801570e: 687a         	ldr	r2, [r7, #0x4]
 8015710: 6891         	ldr	r1, [r2, #0x8]
 8015712: 687a         	ldr	r2, [r7, #0x4]
 8015714: 68d2         	ldr	r2, [r2, #0xc]
 8015716: 4291         	cmp	r1, r2
 8015718: d001         	beq	0x801571e <z_impl_k_sem_give+0xc6> @ imm = #0x2
 801571a: 2201         	movs	r2, #0x1
 801571c: e000         	b	0x8015720 <z_impl_k_sem_give+0xc8> @ imm = #0x0
 801571e: 2200         	movs	r2, #0x0
 8015720: 441a         	add	r2, r3
 8015722: 687b         	ldr	r3, [r7, #0x4]
 8015724: 609a         	str	r2, [r3, #0x8]
; 		resched = handle_poll_events(sem);
 8015726: 6878         	ldr	r0, [r7, #0x4]
 8015728: f012 f819    	bl	0x802775e <handle_poll_events> @ imm = #0x12032
 801572c: 4603         	mov	r3, r0
 801572e: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	if (unlikely(resched)) {
 8015732: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 8015736: 2b00         	cmp	r3, #0x0
 8015738: d004         	beq	0x8015744 <z_impl_k_sem_give+0xec> @ imm = #0x8
; 		z_reschedule(&lock, key);
 801573a: 6979         	ldr	r1, [r7, #0x14]
 801573c: 480c         	ldr	r0, [pc, #0x30]         @ 0x8015770 <z_impl_k_sem_give+0x118>
 801573e: f013 f90d    	bl	0x802895c <z_reschedule> @ imm = #0x1321a
; }
 8015742: e010         	b	0x8015766 <z_impl_k_sem_give+0x10e> @ imm = #0x20
 8015744: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8015770 <z_impl_k_sem_give+0x118>
 8015746: 623b         	str	r3, [r7, #0x20]
 8015748: 697b         	ldr	r3, [r7, #0x14]
 801574a: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 801574c: 693b         	ldr	r3, [r7, #0x10]
 801574e: 61fb         	str	r3, [r7, #0x1c]
 8015750: 69fb         	ldr	r3, [r7, #0x1c]
 8015752: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015754: 69bb         	ldr	r3, [r7, #0x18]
 8015756: f383 8811    	msr	basepri, r3
; }
 801575a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801575c: f3bf 8f6f    	isb	sy
; }
 8015760: bf00         	nop
; }
 8015762: bf00         	nop
; }
 8015764: bf00         	nop
; }
 8015766: bf00         	nop
 8015768: 3760         	adds	r7, #0x60
 801576a: 46bd         	mov	sp, r7
 801576c: bd80         	pop	{r7, pc}
 801576e: bf00         	nop

08015770 <$d>:
 8015770: d0 32 00 24  	.word	0x240032d0

08015774 <z_impl_k_sem_take>:
; {
 8015774: b580         	push	{r7, lr}
 8015776: b098         	sub	sp, #0x60
 8015778: af02         	add	r7, sp, #0x8
 801577a: 60f8         	str	r0, [r7, #0xc]
 801577c: e9c7 2300    	strd	r2, r3, [r7]
 8015780: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8015858 <z_impl_k_sem_take+0xe4>
 8015782: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015784: f3ef 8311    	mrs	r3, basepri
 8015788: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 801578a: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 801578c: 64bb         	str	r3, [r7, #0x48]
 801578e: 2310         	movs	r3, #0x10
 8015790: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015792: 6c7b         	ldr	r3, [r7, #0x44]
 8015794: f383 8812    	msr	basepri_max, r3
; }
 8015798: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801579a: f3bf 8f6f    	isb	sy
; }
 801579e: bf00         	nop
; 	return key;
 80157a0: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 80157a2: 61bb         	str	r3, [r7, #0x18]
 80157a4: 6d3b         	ldr	r3, [r7, #0x50]
 80157a6: 643b         	str	r3, [r7, #0x40]
; }
 80157a8: bf00         	nop
 80157aa: 6d3b         	ldr	r3, [r7, #0x50]
 80157ac: 63fb         	str	r3, [r7, #0x3c]
; }
 80157ae: bf00         	nop
; 	return k;
 80157b0: 69bb         	ldr	r3, [r7, #0x18]
 80157b2: 623b         	str	r3, [r7, #0x20]
; 	if (likely(sem->count > 0U)) {
 80157b4: 68fb         	ldr	r3, [r7, #0xc]
 80157b6: 689b         	ldr	r3, [r3, #0x8]
 80157b8: 2b00         	cmp	r3, #0x0
 80157ba: bf14         	ite	ne
 80157bc: 2301         	movne	r3, #0x1
 80157be: 2300         	moveq	r3, #0x0
 80157c0: b2db         	uxtb	r3, r3
 80157c2: 2b00         	cmp	r3, #0x0
 80157c4: d018         	beq	0x80157f8 <z_impl_k_sem_take+0x84> @ imm = #0x30
; 		sem->count--;
 80157c6: 68fb         	ldr	r3, [r7, #0xc]
 80157c8: 689b         	ldr	r3, [r3, #0x8]
 80157ca: 1e5a         	subs	r2, r3, #0x1
 80157cc: 68fb         	ldr	r3, [r7, #0xc]
 80157ce: 609a         	str	r2, [r3, #0x8]
 80157d0: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8015858 <z_impl_k_sem_take+0xe4>
 80157d2: 63bb         	str	r3, [r7, #0x38]
 80157d4: 6a3b         	ldr	r3, [r7, #0x20]
 80157d6: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 80157d8: 69fb         	ldr	r3, [r7, #0x1c]
 80157da: 637b         	str	r3, [r7, #0x34]
 80157dc: 6b7b         	ldr	r3, [r7, #0x34]
 80157de: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80157e0: 6b3b         	ldr	r3, [r7, #0x30]
 80157e2: f383 8811    	msr	basepri, r3
; }
 80157e6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80157e8: f3bf 8f6f    	isb	sy
; }
 80157ec: bf00         	nop
; }
 80157ee: bf00         	nop
; }
 80157f0: bf00         	nop
; 		ret = 0;
 80157f2: 2300         	movs	r3, #0x0
 80157f4: 657b         	str	r3, [r7, #0x54]
; 		goto out;
 80157f6: e029         	b	0x801584c <z_impl_k_sem_take+0xd8> @ imm = #0x52
; 	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 80157f8: e9d7 2300    	ldrd	r2, r3, [r7]
 80157fc: f04f 0000    	mov.w	r0, #0x0
 8015800: f04f 0100    	mov.w	r1, #0x0
 8015804: 428b         	cmp	r3, r1
 8015806: bf08         	it	eq
 8015808: 4282         	cmpeq	r2, r0
 801580a: d114         	bne	0x8015836 <z_impl_k_sem_take+0xc2> @ imm = #0x28
 801580c: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8015858 <z_impl_k_sem_take+0xe4>
 801580e: 62fb         	str	r3, [r7, #0x2c]
 8015810: 6a3b         	ldr	r3, [r7, #0x20]
 8015812: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8015814: 697b         	ldr	r3, [r7, #0x14]
 8015816: 62bb         	str	r3, [r7, #0x28]
 8015818: 6abb         	ldr	r3, [r7, #0x28]
 801581a: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801581c: 6a7b         	ldr	r3, [r7, #0x24]
 801581e: f383 8811    	msr	basepri, r3
; }
 8015822: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015824: f3bf 8f6f    	isb	sy
; }
 8015828: bf00         	nop
; }
 801582a: bf00         	nop
; }
 801582c: bf00         	nop
; 		ret = -EBUSY;
 801582e: f06f 030f    	mvn	r3, #0xf
 8015832: 657b         	str	r3, [r7, #0x54]
 8015834: e00a         	b	0x801584c <z_impl_k_sem_take+0xd8> @ imm = #0x14
; 	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 8015836: 68f9         	ldr	r1, [r7, #0xc]
 8015838: e9d7 2300    	ldrd	r2, r3, [r7]
 801583c: e9cd 2300    	strd	r2, r3, [sp]
 8015840: 460a         	mov	r2, r1
 8015842: 6a39         	ldr	r1, [r7, #0x20]
 8015844: 4804         	ldr	r0, [pc, #0x10]         @ 0x8015858 <z_impl_k_sem_take+0xe4>
 8015846: f001 fadf    	bl	0x8016e08 <z_pend_curr> @ imm = #0x15be
 801584a: 6578         	str	r0, [r7, #0x54]
; 	return ret;
 801584c: 6d7b         	ldr	r3, [r7, #0x54]
; }
 801584e: 4618         	mov	r0, r3
 8015850: 3758         	adds	r7, #0x58
 8015852: 46bd         	mov	sp, r7
 8015854: bd80         	pop	{r7, pc}
 8015856: bf00         	nop

08015858 <$d>:
 8015858: d0 32 00 24  	.word	0x240032d0

0801585c <k_sys_work_q_init>:
; {
 801585c: b580         	push	{r7, lr}
 801585e: b084         	sub	sp, #0x10
 8015860: af02         	add	r7, sp, #0x8
; 	struct k_work_queue_config cfg = {
 8015862: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x801588c <k_sys_work_q_init+0x30>
 8015864: 463b         	mov	r3, r7
 8015866: e892 0003    	ldm.w	r2, {r0, r1}
 801586a: e883 0003    	stm.w	r3, {r0, r1}
; 	k_work_queue_start(&k_sys_work_q,
 801586e: 463b         	mov	r3, r7
 8015870: 9300         	str	r3, [sp]
 8015872: f04f 33ff    	mov.w	r3, #0xffffffff
 8015876: f44f 6280    	mov.w	r2, #0x400
 801587a: 4905         	ldr	r1, [pc, #0x14]         @ 0x8015890 <k_sys_work_q_init+0x34>
 801587c: 4805         	ldr	r0, [pc, #0x14]         @ 0x8015894 <k_sys_work_q_init+0x38>
 801587e: f000 f9d7    	bl	0x8015c30 <k_work_queue_start> @ imm = #0x3ae
; 	return 0;
 8015882: 2300         	movs	r3, #0x0
; }
 8015884: 4618         	mov	r0, r3
 8015886: 3708         	adds	r7, #0x8
 8015888: 46bd         	mov	sp, r7
 801588a: bd80         	pop	{r7, pc}

0801588c <$d>:
 801588c: 54 c9 02 08  	.word	0x0802c954
 8015890: 38 5f 00 24  	.word	0x24005f38
 8015894: d8 22 00 24  	.word	0x240022d8

08015898 <finalize_cancel_locked>:
; {
 8015898: b580         	push	{r7, lr}
 801589a: b086         	sub	sp, #0x18
 801589c: af00         	add	r7, sp, #0x0
 801589e: 6078         	str	r0, [r7, #0x4]
; 	sys_snode_t *prev = NULL;
 80158a0: 2300         	movs	r3, #0x0
 80158a2: 60fb         	str	r3, [r7, #0xc]
; 	flag_clear(&work->flags, K_WORK_CANCELING_BIT);
 80158a4: 687b         	ldr	r3, [r7, #0x4]
 80158a6: 330c         	adds	r3, #0xc
 80158a8: 2101         	movs	r1, #0x1
 80158aa: 4618         	mov	r0, r3
 80158ac: f012 f952    	bl	0x8027b54 <flag_clear>  @ imm = #0x122a4
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 80158b0: 4829         	ldr	r0, [pc, #0xa4]         @ 0x8015958 <finalize_cancel_locked+0xc0>
 80158b2: f011 ffc5    	bl	0x8027840 <sys_slist_peek_head> @ imm = #0x11f8a
 80158b6: 4603         	mov	r3, r0
 80158b8: 2b00         	cmp	r3, #0x0
 80158ba: d004         	beq	0x80158c6 <finalize_cancel_locked+0x2e> @ imm = #0x8
 80158bc: 4826         	ldr	r0, [pc, #0x98]         @ 0x8015958 <finalize_cancel_locked+0xc0>
 80158be: f011 ffbf    	bl	0x8027840 <sys_slist_peek_head> @ imm = #0x11f7e
 80158c2: 4603         	mov	r3, r0
 80158c4: e000         	b	0x80158c8 <finalize_cancel_locked+0x30> @ imm = #0x0
 80158c6: 2300         	movs	r3, #0x0
 80158c8: 617b         	str	r3, [r7, #0x14]
 80158ca: 697b         	ldr	r3, [r7, #0x14]
 80158cc: 2b00         	cmp	r3, #0x0
 80158ce: d00e         	beq	0x80158ee <finalize_cancel_locked+0x56> @ imm = #0x1c
 80158d0: 697b         	ldr	r3, [r7, #0x14]
 80158d2: 4618         	mov	r0, r3
 80158d4: f011 ffe9    	bl	0x80278aa <sys_slist_peek_next> @ imm = #0x11fd2
 80158d8: 4603         	mov	r3, r0
 80158da: 2b00         	cmp	r3, #0x0
 80158dc: d005         	beq	0x80158ea <finalize_cancel_locked+0x52> @ imm = #0xa
 80158de: 697b         	ldr	r3, [r7, #0x14]
 80158e0: 4618         	mov	r0, r3
 80158e2: f011 ffe2    	bl	0x80278aa <sys_slist_peek_next> @ imm = #0x11fc4
 80158e6: 4603         	mov	r3, r0
 80158e8: e002         	b	0x80158f0 <finalize_cancel_locked+0x58> @ imm = #0x4
 80158ea: 2300         	movs	r3, #0x0
 80158ec: e000         	b	0x80158f0 <finalize_cancel_locked+0x58> @ imm = #0x0
 80158ee: 2300         	movs	r3, #0x0
 80158f0: 613b         	str	r3, [r7, #0x10]
 80158f2: e028         	b	0x8015946 <finalize_cancel_locked+0xae> @ imm = #0x50
; 		if (wc->work == work) {
 80158f4: 697b         	ldr	r3, [r7, #0x14]
 80158f6: 685b         	ldr	r3, [r3, #0x4]
 80158f8: 687a         	ldr	r2, [r7, #0x4]
 80158fa: 429a         	cmp	r2, r3
 80158fc: d10b         	bne	0x8015916 <finalize_cancel_locked+0x7e> @ imm = #0x16
; 			sys_slist_remove(&pending_cancels, prev, &wc->node);
 80158fe: 697b         	ldr	r3, [r7, #0x14]
 8015900: 461a         	mov	r2, r3
 8015902: 68f9         	ldr	r1, [r7, #0xc]
 8015904: 4814         	ldr	r0, [pc, #0x50]         @ 0x8015958 <finalize_cancel_locked+0xc0>
 8015906: f012 f840    	bl	0x802798a <sys_slist_remove> @ imm = #0x12080
; 			k_sem_give(&wc->sem);
 801590a: 697b         	ldr	r3, [r7, #0x14]
 801590c: 3308         	adds	r3, #0x8
 801590e: 4618         	mov	r0, r3
 8015910: f012 f8e5    	bl	0x8027ade <k_sem_give>  @ imm = #0x121ca
; 			break;
 8015914: e01b         	b	0x801594e <finalize_cancel_locked+0xb6> @ imm = #0x36
; 		prev = &wc->node;
 8015916: 697b         	ldr	r3, [r7, #0x14]
 8015918: 60fb         	str	r3, [r7, #0xc]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 801591a: 693b         	ldr	r3, [r7, #0x10]
 801591c: 617b         	str	r3, [r7, #0x14]
 801591e: 697b         	ldr	r3, [r7, #0x14]
 8015920: 2b00         	cmp	r3, #0x0
 8015922: d00e         	beq	0x8015942 <finalize_cancel_locked+0xaa> @ imm = #0x1c
 8015924: 697b         	ldr	r3, [r7, #0x14]
 8015926: 4618         	mov	r0, r3
 8015928: f011 ffbf    	bl	0x80278aa <sys_slist_peek_next> @ imm = #0x11f7e
 801592c: 4603         	mov	r3, r0
 801592e: 2b00         	cmp	r3, #0x0
 8015930: d005         	beq	0x801593e <finalize_cancel_locked+0xa6> @ imm = #0xa
 8015932: 697b         	ldr	r3, [r7, #0x14]
 8015934: 4618         	mov	r0, r3
 8015936: f011 ffb8    	bl	0x80278aa <sys_slist_peek_next> @ imm = #0x11f70
 801593a: 4603         	mov	r3, r0
 801593c: e002         	b	0x8015944 <finalize_cancel_locked+0xac> @ imm = #0x4
 801593e: 2300         	movs	r3, #0x0
 8015940: e000         	b	0x8015944 <finalize_cancel_locked+0xac> @ imm = #0x0
 8015942: 2300         	movs	r3, #0x0
 8015944: 613b         	str	r3, [r7, #0x10]
 8015946: 697b         	ldr	r3, [r7, #0x14]
 8015948: 2b00         	cmp	r3, #0x0
 801594a: d1d3         	bne	0x80158f4 <finalize_cancel_locked+0x5c> @ imm = #-0x5a
; }
 801594c: bf00         	nop
 801594e: bf00         	nop
 8015950: 3718         	adds	r7, #0x18
 8015952: 46bd         	mov	sp, r7
 8015954: bd80         	pop	{r7, pc}
 8015956: bf00         	nop

08015958 <$d>:
 8015958: d0 32 00 24  	.word	0x240032d0

0801595c <queue_submit_locked>:
; {
 801595c: b580         	push	{r7, lr}
 801595e: b086         	sub	sp, #0x18
 8015960: af00         	add	r7, sp, #0x0
 8015962: 6078         	str	r0, [r7, #0x4]
 8015964: 6039         	str	r1, [r7]
; 	if (queue == NULL) {
 8015966: 687b         	ldr	r3, [r7, #0x4]
 8015968: 2b00         	cmp	r3, #0x0
 801596a: d102         	bne	0x8015972 <queue_submit_locked+0x16> @ imm = #0x4
; 		return -EINVAL;
 801596c: f06f 0315    	mvn	r3, #0x15
 8015970: e061         	b	0x8015a36 <queue_submit_locked+0xda> @ imm = #0xc2
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015972: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8015a40 <queue_submit_locked+0xe4>
 8015974: 689b         	ldr	r3, [r3, #0x8]
 8015976: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8015978: 68fa         	ldr	r2, [r7, #0xc]
; 	bool chained = (arch_current_thread() == &queue->thread) && !k_is_in_isr();
 801597a: 687b         	ldr	r3, [r7, #0x4]
 801597c: 429a         	cmp	r2, r3
 801597e: d109         	bne	0x8015994 <queue_submit_locked+0x38> @ imm = #0x12
 8015980: f012 fb24    	bl	0x8027fcc <k_is_in_isr> @ imm = #0x12648
 8015984: 4603         	mov	r3, r0
 8015986: f083 0301    	eor	r3, r3, #0x1
 801598a: b2db         	uxtb	r3, r3
 801598c: 2b00         	cmp	r3, #0x0
 801598e: d001         	beq	0x8015994 <queue_submit_locked+0x38> @ imm = #0x2
 8015990: 2301         	movs	r3, #0x1
 8015992: e000         	b	0x8015996 <queue_submit_locked+0x3a> @ imm = #0x0
 8015994: 2300         	movs	r3, #0x0
 8015996: 74fb         	strb	r3, [r7, #0x13]
 8015998: 7cfb         	ldrb	r3, [r7, #0x13]
 801599a: f003 0301    	and	r3, r3, #0x1
 801599e: 74fb         	strb	r3, [r7, #0x13]
; 	bool draining = flag_test(&queue->flags, K_WORK_QUEUE_DRAIN_BIT);
 80159a0: 687b         	ldr	r3, [r7, #0x4]
 80159a2: f503 7398    	add.w	r3, r3, #0x130
 80159a6: 2102         	movs	r1, #0x2
 80159a8: 4618         	mov	r0, r3
 80159aa: f012 f8fc    	bl	0x8027ba6 <flag_test>   @ imm = #0x121f8
 80159ae: 4603         	mov	r3, r0
 80159b0: 74bb         	strb	r3, [r7, #0x12]
; 	bool plugged = flag_test(&queue->flags, K_WORK_QUEUE_PLUGGED_BIT);
 80159b2: 687b         	ldr	r3, [r7, #0x4]
 80159b4: f503 7398    	add.w	r3, r3, #0x130
 80159b8: 2103         	movs	r1, #0x3
 80159ba: 4618         	mov	r0, r3
 80159bc: f012 f8f3    	bl	0x8027ba6 <flag_test>   @ imm = #0x121e6
 80159c0: 4603         	mov	r3, r0
 80159c2: 747b         	strb	r3, [r7, #0x11]
; 	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
 80159c4: 687b         	ldr	r3, [r7, #0x4]
 80159c6: f503 7398    	add.w	r3, r3, #0x130
 80159ca: 2100         	movs	r1, #0x0
 80159cc: 4618         	mov	r0, r3
 80159ce: f012 f8ea    	bl	0x8027ba6 <flag_test>   @ imm = #0x121d4
 80159d2: 4603         	mov	r3, r0
 80159d4: f083 0301    	eor	r3, r3, #0x1
 80159d8: b2db         	uxtb	r3, r3
 80159da: 2b00         	cmp	r3, #0x0
 80159dc: d003         	beq	0x80159e6 <queue_submit_locked+0x8a> @ imm = #0x6
; 		ret = -ENODEV;
 80159de: f06f 0312    	mvn	r3, #0x12
 80159e2: 617b         	str	r3, [r7, #0x14]
 80159e4: e026         	b	0x8015a34 <queue_submit_locked+0xd8> @ imm = #0x4c
; 	} else if (draining && !chained) {
 80159e6: 7cbb         	ldrb	r3, [r7, #0x12]
 80159e8: 2b00         	cmp	r3, #0x0
 80159ea: d009         	beq	0x8015a00 <queue_submit_locked+0xa4> @ imm = #0x12
 80159ec: 7cfb         	ldrb	r3, [r7, #0x13]
 80159ee: f083 0301    	eor	r3, r3, #0x1
 80159f2: b2db         	uxtb	r3, r3
 80159f4: 2b00         	cmp	r3, #0x0
 80159f6: d003         	beq	0x8015a00 <queue_submit_locked+0xa4> @ imm = #0x6
; 		ret = -EBUSY;
 80159f8: f06f 030f    	mvn	r3, #0xf
 80159fc: 617b         	str	r3, [r7, #0x14]
 80159fe: e019         	b	0x8015a34 <queue_submit_locked+0xd8> @ imm = #0x32
; 	} else if (plugged && !draining) {
 8015a00: 7c7b         	ldrb	r3, [r7, #0x11]
 8015a02: 2b00         	cmp	r3, #0x0
 8015a04: d009         	beq	0x8015a1a <queue_submit_locked+0xbe> @ imm = #0x12
 8015a06: 7cbb         	ldrb	r3, [r7, #0x12]
 8015a08: f083 0301    	eor	r3, r3, #0x1
 8015a0c: b2db         	uxtb	r3, r3
 8015a0e: 2b00         	cmp	r3, #0x0
 8015a10: d003         	beq	0x8015a1a <queue_submit_locked+0xbe> @ imm = #0x6
; 		ret = -EBUSY;
 8015a12: f06f 030f    	mvn	r3, #0xf
 8015a16: 617b         	str	r3, [r7, #0x14]
 8015a18: e00c         	b	0x8015a34 <queue_submit_locked+0xd8> @ imm = #0x18
; 		sys_slist_append(&queue->pending, &work->node);
 8015a1a: 687b         	ldr	r3, [r7, #0x4]
 8015a1c: f503 738c    	add.w	r3, r3, #0x118
 8015a20: 683a         	ldr	r2, [r7]
 8015a22: 4611         	mov	r1, r2
 8015a24: 4618         	mov	r0, r3
 8015a26: f011 ff51    	bl	0x80278cc <sys_slist_append> @ imm = #0x11ea2
; 		ret = 1;
 8015a2a: 2301         	movs	r3, #0x1
 8015a2c: 617b         	str	r3, [r7, #0x14]
; 		(void)notify_queue_locked(queue);
 8015a2e: 6878         	ldr	r0, [r7, #0x4]
 8015a30: f012 f93f    	bl	0x8027cb2 <notify_queue_locked> @ imm = #0x1227e
; 	return ret;
 8015a34: 697b         	ldr	r3, [r7, #0x14]
; }
 8015a36: 4618         	mov	r0, r3
 8015a38: 3718         	adds	r7, #0x18
 8015a3a: 46bd         	mov	sp, r7
 8015a3c: bd80         	pop	{r7, pc}
 8015a3e: bf00         	nop

08015a40 <$d>:
 8015a40: 60 20 00 24  	.word	0x24002060

08015a44 <work_queue_main>:
; {
 8015a44: b580         	push	{r7, lr}
 8015a46: b0a4         	sub	sp, #0x90
 8015a48: af04         	add	r7, sp, #0x10
 8015a4a: 60f8         	str	r0, [r7, #0xc]
 8015a4c: 60b9         	str	r1, [r7, #0x8]
 8015a4e: 607a         	str	r2, [r7, #0x4]
; 	struct k_work_q *queue = (struct k_work_q *)workq_ptr;
 8015a50: 68fb         	ldr	r3, [r7, #0xc]
 8015a52: 677b         	str	r3, [r7, #0x74]
; 		struct k_work *work = NULL;
 8015a54: 2300         	movs	r3, #0x0
 8015a56: 67fb         	str	r3, [r7, #0x7c]
; 		k_work_handler_t handler = NULL;
 8015a58: 2300         	movs	r3, #0x0
 8015a5a: 67bb         	str	r3, [r7, #0x78]
 8015a5c: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8015c2c <work_queue_main+0x1e8>
 8015a5e: 66bb         	str	r3, [r7, #0x68]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015a60: f3ef 8311    	mrs	r3, basepri
 8015a64: 667b         	str	r3, [r7, #0x64]
;   return(result);
 8015a66: 6e7b         	ldr	r3, [r7, #0x64]
; 	key = __get_BASEPRI();
 8015a68: 663b         	str	r3, [r7, #0x60]
 8015a6a: 2310         	movs	r3, #0x10
 8015a6c: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015a6e: 6dfb         	ldr	r3, [r7, #0x5c]
 8015a70: f383 8812    	msr	basepri_max, r3
; }
 8015a74: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015a76: f3bf 8f6f    	isb	sy
; }
 8015a7a: bf00         	nop
; 	return key;
 8015a7c: 6e3b         	ldr	r3, [r7, #0x60]
; 	k.key = arch_irq_lock();
 8015a7e: 613b         	str	r3, [r7, #0x10]
 8015a80: 6ebb         	ldr	r3, [r7, #0x68]
 8015a82: 65bb         	str	r3, [r7, #0x58]
; }
 8015a84: bf00         	nop
 8015a86: 6ebb         	ldr	r3, [r7, #0x68]
 8015a88: 657b         	str	r3, [r7, #0x54]
; }
 8015a8a: bf00         	nop
; 	return k;
 8015a8c: 693b         	ldr	r3, [r7, #0x10]
 8015a8e: 623b         	str	r3, [r7, #0x20]
; 		node = sys_slist_get(&queue->pending);
 8015a90: 6f7b         	ldr	r3, [r7, #0x74]
 8015a92: f503 738c    	add.w	r3, r3, #0x118
 8015a96: 4618         	mov	r0, r3
 8015a98: f011 ff63    	bl	0x8027962 <sys_slist_get> @ imm = #0x11ec6
 8015a9c: 6738         	str	r0, [r7, #0x70]
; 		if (node != NULL) {
 8015a9e: 6f3b         	ldr	r3, [r7, #0x70]
 8015aa0: 2b00         	cmp	r3, #0x0
 8015aa2: d018         	beq	0x8015ad6 <work_queue_main+0x92> @ imm = #0x30
; 			flag_set(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
 8015aa4: 6f7b         	ldr	r3, [r7, #0x74]
 8015aa6: f503 7398    	add.w	r3, r3, #0x130
 8015aaa: 2101         	movs	r1, #0x1
 8015aac: 4618         	mov	r0, r3
 8015aae: f012 f866    	bl	0x8027b7e <flag_set>    @ imm = #0x120cc
; 			work = CONTAINER_OF(node, struct k_work, node);
 8015ab2: 6f3b         	ldr	r3, [r7, #0x70]
 8015ab4: 67fb         	str	r3, [r7, #0x7c]
; 			flag_set(&work->flags, K_WORK_RUNNING_BIT);
 8015ab6: 6ffb         	ldr	r3, [r7, #0x7c]
 8015ab8: 330c         	adds	r3, #0xc
 8015aba: 2100         	movs	r1, #0x0
 8015abc: 4618         	mov	r0, r3
 8015abe: f012 f85e    	bl	0x8027b7e <flag_set>    @ imm = #0x120bc
; 			flag_clear(&work->flags, K_WORK_QUEUED_BIT);
 8015ac2: 6ffb         	ldr	r3, [r7, #0x7c]
 8015ac4: 330c         	adds	r3, #0xc
 8015ac6: 2102         	movs	r1, #0x2
 8015ac8: 4618         	mov	r0, r3
 8015aca: f012 f843    	bl	0x8027b54 <flag_clear>  @ imm = #0x12086
; 			handler = work->handler;
 8015ace: 6ffb         	ldr	r3, [r7, #0x7c]
 8015ad0: 685b         	ldr	r3, [r3, #0x4]
 8015ad2: 67bb         	str	r3, [r7, #0x78]
 8015ad4: e011         	b	0x8015afa <work_queue_main+0xb6> @ imm = #0x22
; 		} else if (flag_test_and_clear(&queue->flags, K_WORK_QUEUE_DRAIN_BIT)) {
 8015ad6: 6f7b         	ldr	r3, [r7, #0x74]
 8015ad8: f503 7398    	add.w	r3, r3, #0x130
 8015adc: 2102         	movs	r1, #0x2
 8015ade: 4618         	mov	r0, r3
 8015ae0: f012 f878    	bl	0x8027bd4 <flag_test_and_clear> @ imm = #0x120f0
 8015ae4: 4603         	mov	r3, r0
 8015ae6: 2b00         	cmp	r3, #0x0
 8015ae8: d007         	beq	0x8015afa <work_queue_main+0xb6> @ imm = #0xe
; 			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
 8015aea: 6f7b         	ldr	r3, [r7, #0x74]
 8015aec: f503 7394    	add.w	r3, r3, #0x128
 8015af0: 2200         	movs	r2, #0x0
 8015af2: 2101         	movs	r1, #0x1
 8015af4: 4618         	mov	r0, r3
 8015af6: f012 f815    	bl	0x8027b24 <z_sched_wake_all> @ imm = #0x1202a
; 		if (work == NULL) {
 8015afa: 6ffb         	ldr	r3, [r7, #0x7c]
 8015afc: 2b00         	cmp	r3, #0x0
 8015afe: d111         	bne	0x8015b24 <work_queue_main+0xe0> @ imm = #0x22
; 			(void)z_sched_wait(&lock, key, &queue->notifyq, K_FOREVER, NULL);
 8015b00: 6f7b         	ldr	r3, [r7, #0x74]
 8015b02: f503 7190    	add.w	r1, r3, #0x120
 8015b06: f04f 32ff    	mov.w	r2, #0xffffffff
 8015b0a: f04f 33ff    	mov.w	r3, #0xffffffff
 8015b0e: 2000         	movs	r0, #0x0
 8015b10: 9002         	str	r0, [sp, #0x8]
 8015b12: e9cd 2300    	strd	r2, r3, [sp]
 8015b16: 460a         	mov	r2, r1
 8015b18: 6a39         	ldr	r1, [r7, #0x20]
 8015b1a: 4844         	ldr	r0, [pc, #0x110]        @ 0x8015c2c <work_queue_main+0x1e8>
 8015b1c: f002 f83e    	bl	0x8017b9c <z_sched_wait> @ imm = #0x207c
; 			continue;
 8015b20: bf00         	nop
 8015b22: e797         	b	0x8015a54 <work_queue_main+0x10> @ imm = #-0xd2
 8015b24: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8015c2c <work_queue_main+0x1e8>
 8015b26: 63bb         	str	r3, [r7, #0x38]
 8015b28: 6a3b         	ldr	r3, [r7, #0x20]
 8015b2a: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8015b2c: 69bb         	ldr	r3, [r7, #0x18]
 8015b2e: 637b         	str	r3, [r7, #0x34]
 8015b30: 6b7b         	ldr	r3, [r7, #0x34]
 8015b32: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015b34: 6b3b         	ldr	r3, [r7, #0x30]
 8015b36: f383 8811    	msr	basepri, r3
; }
 8015b3a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015b3c: f3bf 8f6f    	isb	sy
; }
 8015b40: bf00         	nop
; }
 8015b42: bf00         	nop
; }
 8015b44: bf00         	nop
; 		handler(work);
 8015b46: 6fbb         	ldr	r3, [r7, #0x78]
 8015b48: 6ff8         	ldr	r0, [r7, #0x7c]
 8015b4a: 4798         	blx	r3
 8015b4c: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8015c2c <work_queue_main+0x1e8>
 8015b4e: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015b50: f3ef 8311    	mrs	r3, basepri
 8015b54: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 8015b56: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 8015b58: 64bb         	str	r3, [r7, #0x48]
 8015b5a: 2310         	movs	r3, #0x10
 8015b5c: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015b5e: 6c7b         	ldr	r3, [r7, #0x44]
 8015b60: f383 8812    	msr	basepri_max, r3
; }
 8015b64: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015b66: f3bf 8f6f    	isb	sy
; }
 8015b6a: bf00         	nop
; 	return key;
 8015b6c: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 8015b6e: 617b         	str	r3, [r7, #0x14]
 8015b70: 6d3b         	ldr	r3, [r7, #0x50]
 8015b72: 643b         	str	r3, [r7, #0x40]
; }
 8015b74: bf00         	nop
 8015b76: 6d3b         	ldr	r3, [r7, #0x50]
 8015b78: 63fb         	str	r3, [r7, #0x3c]
; }
 8015b7a: bf00         	nop
; 	return k;
 8015b7c: 697b         	ldr	r3, [r7, #0x14]
 8015b7e: 623b         	str	r3, [r7, #0x20]
; 		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
 8015b80: 6ffb         	ldr	r3, [r7, #0x7c]
 8015b82: 330c         	adds	r3, #0xc
 8015b84: 2100         	movs	r1, #0x0
 8015b86: 4618         	mov	r0, r3
 8015b88: f011 ffe4    	bl	0x8027b54 <flag_clear>  @ imm = #0x11fc8
; 		if (flag_test(&work->flags, K_WORK_FLUSHING_BIT)) {
 8015b8c: 6ffb         	ldr	r3, [r7, #0x7c]
 8015b8e: 330c         	adds	r3, #0xc
 8015b90: 2104         	movs	r1, #0x4
 8015b92: 4618         	mov	r0, r3
 8015b94: f012 f807    	bl	0x8027ba6 <flag_test>   @ imm = #0x1200e
 8015b98: 4603         	mov	r3, r0
 8015b9a: 2b00         	cmp	r3, #0x0
 8015b9c: d002         	beq	0x8015ba4 <work_queue_main+0x160> @ imm = #0x4
; 			finalize_flush_locked(work);
 8015b9e: 6ff8         	ldr	r0, [r7, #0x7c]
 8015ba0: f012 f848    	bl	0x8027c34 <finalize_flush_locked> @ imm = #0x12090
; 		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 8015ba4: 6ffb         	ldr	r3, [r7, #0x7c]
 8015ba6: 330c         	adds	r3, #0xc
 8015ba8: 2101         	movs	r1, #0x1
 8015baa: 4618         	mov	r0, r3
 8015bac: f011 fffb    	bl	0x8027ba6 <flag_test>   @ imm = #0x11ff6
 8015bb0: 4603         	mov	r3, r0
 8015bb2: 2b00         	cmp	r3, #0x0
 8015bb4: d002         	beq	0x8015bbc <work_queue_main+0x178> @ imm = #0x4
; 			finalize_cancel_locked(work);
 8015bb6: 6ff8         	ldr	r0, [r7, #0x7c]
 8015bb8: f7ff fe6e    	bl	0x8015898 <finalize_cancel_locked> @ imm = #-0x324
; 		flag_clear(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
 8015bbc: 6f7b         	ldr	r3, [r7, #0x74]
 8015bbe: f503 7398    	add.w	r3, r3, #0x130
 8015bc2: 2101         	movs	r1, #0x1
 8015bc4: 4618         	mov	r0, r3
 8015bc6: f011 ffc5    	bl	0x8027b54 <flag_clear>  @ imm = #0x11f8a
; 		yield = !flag_test(&queue->flags, K_WORK_QUEUE_NO_YIELD_BIT);
 8015bca: 6f7b         	ldr	r3, [r7, #0x74]
 8015bcc: f503 7398    	add.w	r3, r3, #0x130
 8015bd0: 2108         	movs	r1, #0x8
 8015bd2: 4618         	mov	r0, r3
 8015bd4: f011 ffe7    	bl	0x8027ba6 <flag_test>   @ imm = #0x11fce
 8015bd8: 4603         	mov	r3, r0
 8015bda: 2b00         	cmp	r3, #0x0
 8015bdc: bf14         	ite	ne
 8015bde: 2301         	movne	r3, #0x1
 8015be0: 2300         	moveq	r3, #0x0
 8015be2: b2db         	uxtb	r3, r3
 8015be4: f083 0301    	eor	r3, r3, #0x1
 8015be8: b2db         	uxtb	r3, r3
 8015bea: f887 306f    	strb.w	r3, [r7, #0x6f]
 8015bee: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 8015bf2: f003 0301    	and	r3, r3, #0x1
 8015bf6: f887 306f    	strb.w	r3, [r7, #0x6f]
 8015bfa: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8015c2c <work_queue_main+0x1e8>
 8015bfc: 62fb         	str	r3, [r7, #0x2c]
 8015bfe: 6a3b         	ldr	r3, [r7, #0x20]
 8015c00: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 8015c02: 69fb         	ldr	r3, [r7, #0x1c]
 8015c04: 62bb         	str	r3, [r7, #0x28]
 8015c06: 6abb         	ldr	r3, [r7, #0x28]
 8015c08: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015c0a: 6a7b         	ldr	r3, [r7, #0x24]
 8015c0c: f383 8811    	msr	basepri, r3
; }
 8015c10: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015c12: f3bf 8f6f    	isb	sy
; }
 8015c16: bf00         	nop
; }
 8015c18: bf00         	nop
; }
 8015c1a: bf00         	nop
; 		if (yield) {
 8015c1c: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 8015c20: 2b00         	cmp	r3, #0x0
 8015c22: f43f af17    	beq.w	0x8015a54 <work_queue_main+0x10> @ imm = #-0x1d2
; 			k_yield();
 8015c26: f011 ff3b    	bl	0x8027aa0 <k_yield>     @ imm = #0x11e76
; 	while (true) {
 8015c2a: e713         	b	0x8015a54 <work_queue_main+0x10> @ imm = #-0x1da

08015c2c <$d>:
 8015c2c: d0 32 00 24  	.word	0x240032d0

08015c30 <k_work_queue_start>:
; {
 8015c30: b580         	push	{r7, lr}
 8015c32: b08e         	sub	sp, #0x38
 8015c34: af08         	add	r7, sp, #0x20
 8015c36: 60f8         	str	r0, [r7, #0xc]
 8015c38: 60b9         	str	r1, [r7, #0x8]
 8015c3a: 607a         	str	r2, [r7, #0x4]
 8015c3c: 603b         	str	r3, [r7]
; 	uint32_t flags = K_WORK_QUEUE_STARTED;
 8015c3e: 2301         	movs	r3, #0x1
 8015c40: 617b         	str	r3, [r7, #0x14]
; 	sys_slist_init(&queue->pending);
 8015c42: 68fb         	ldr	r3, [r7, #0xc]
 8015c44: f503 738c    	add.w	r3, r3, #0x118
 8015c48: 4618         	mov	r0, r3
 8015c4a: f011 fdb3    	bl	0x80277b4 <sys_slist_init> @ imm = #0x11b66
; 	z_waitq_init(&queue->notifyq);
 8015c4e: 68fb         	ldr	r3, [r7, #0xc]
 8015c50: f503 7390    	add.w	r3, r3, #0x120
 8015c54: 4618         	mov	r0, r3
 8015c56: f011 ff59    	bl	0x8027b0c <z_waitq_init> @ imm = #0x11eb2
; 	z_waitq_init(&queue->drainq);
 8015c5a: 68fb         	ldr	r3, [r7, #0xc]
 8015c5c: f503 7394    	add.w	r3, r3, #0x128
 8015c60: 4618         	mov	r0, r3
 8015c62: f011 ff53    	bl	0x8027b0c <z_waitq_init> @ imm = #0x11ea6
; 	if ((cfg != NULL) && cfg->no_yield) {
 8015c66: 6a3b         	ldr	r3, [r7, #0x20]
 8015c68: 2b00         	cmp	r3, #0x0
 8015c6a: d007         	beq	0x8015c7c <k_work_queue_start+0x4c> @ imm = #0xe
 8015c6c: 6a3b         	ldr	r3, [r7, #0x20]
 8015c6e: 791b         	ldrb	r3, [r3, #0x4]
 8015c70: 2b00         	cmp	r3, #0x0
 8015c72: d003         	beq	0x8015c7c <k_work_queue_start+0x4c> @ imm = #0x6
; 		flags |= K_WORK_QUEUE_NO_YIELD;
 8015c74: 697b         	ldr	r3, [r7, #0x14]
 8015c76: f443 7380    	orr	r3, r3, #0x100
 8015c7a: 617b         	str	r3, [r7, #0x14]
; 	flags_set(&queue->flags, flags);
 8015c7c: 68fb         	ldr	r3, [r7, #0xc]
 8015c7e: f503 7398    	add.w	r3, r3, #0x130
 8015c82: 6979         	ldr	r1, [r7, #0x14]
 8015c84: 4618         	mov	r0, r3
 8015c86: f011 ffbb    	bl	0x8027c00 <flags_set>   @ imm = #0x11f76
; 	(void)k_thread_create(&queue->thread, stack, stack_size, work_queue_main, queue, NULL, NULL,
 8015c8a: 68f8         	ldr	r0, [r7, #0xc]
; 			      prio, 0, K_FOREVER);
 8015c8c: f04f 32ff    	mov.w	r2, #0xffffffff
 8015c90: f04f 33ff    	mov.w	r3, #0xffffffff
; 	(void)k_thread_create(&queue->thread, stack, stack_size, work_queue_main, queue, NULL, NULL,
 8015c94: e9cd 2306    	strd	r2, r3, [sp, #24]
 8015c98: 2300         	movs	r3, #0x0
 8015c9a: 9304         	str	r3, [sp, #0x10]
 8015c9c: 683b         	ldr	r3, [r7]
 8015c9e: 9303         	str	r3, [sp, #0xc]
 8015ca0: 2300         	movs	r3, #0x0
 8015ca2: 9302         	str	r3, [sp, #0x8]
 8015ca4: 2300         	movs	r3, #0x0
 8015ca6: 9301         	str	r3, [sp, #0x4]
 8015ca8: 68fb         	ldr	r3, [r7, #0xc]
 8015caa: 9300         	str	r3, [sp]
 8015cac: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8015d00 <k_work_queue_start+0xd0>
 8015cae: 687a         	ldr	r2, [r7, #0x4]
 8015cb0: 68b9         	ldr	r1, [r7, #0x8]
 8015cb2: f011 fed5    	bl	0x8027a60 <k_thread_create> @ imm = #0x11daa
; 	if ((cfg != NULL) && (cfg->name != NULL)) {
 8015cb6: 6a3b         	ldr	r3, [r7, #0x20]
 8015cb8: 2b00         	cmp	r3, #0x0
 8015cba: d00a         	beq	0x8015cd2 <k_work_queue_start+0xa2> @ imm = #0x14
 8015cbc: 6a3b         	ldr	r3, [r7, #0x20]
 8015cbe: 681b         	ldr	r3, [r3]
 8015cc0: 2b00         	cmp	r3, #0x0
 8015cc2: d006         	beq	0x8015cd2 <k_work_queue_start+0xa2> @ imm = #0xc
; 		k_thread_name_set(&queue->thread, cfg->name);
 8015cc4: 68fa         	ldr	r2, [r7, #0xc]
 8015cc6: 6a3b         	ldr	r3, [r7, #0x20]
 8015cc8: 681b         	ldr	r3, [r3]
 8015cca: 4619         	mov	r1, r3
 8015ccc: 4610         	mov	r0, r2
 8015cce: f011 fef8    	bl	0x8027ac2 <k_thread_name_set> @ imm = #0x11df0
; 	if ((cfg != NULL) && (cfg->essential)) {
 8015cd2: 6a3b         	ldr	r3, [r7, #0x20]
 8015cd4: 2b00         	cmp	r3, #0x0
 8015cd6: d00a         	beq	0x8015cee <k_work_queue_start+0xbe> @ imm = #0x14
 8015cd8: 6a3b         	ldr	r3, [r7, #0x20]
 8015cda: 795b         	ldrb	r3, [r3, #0x5]
 8015cdc: 2b00         	cmp	r3, #0x0
 8015cde: d006         	beq	0x8015cee <k_work_queue_start+0xbe> @ imm = #0xc
; 		queue->thread.base.user_options |= K_ESSENTIAL;
 8015ce0: 68fb         	ldr	r3, [r7, #0xc]
 8015ce2: 7b1b         	ldrb	r3, [r3, #0xc]
 8015ce4: f043 0301    	orr	r3, r3, #0x1
 8015ce8: b2da         	uxtb	r2, r3
 8015cea: 68fb         	ldr	r3, [r7, #0xc]
 8015cec: 731a         	strb	r2, [r3, #0xc]
; 	k_thread_start(&queue->thread);
 8015cee: 68fb         	ldr	r3, [r7, #0xc]
 8015cf0: 4618         	mov	r0, r3
 8015cf2: f011 feaa    	bl	0x8027a4a <k_thread_start> @ imm = #0x11d54
; }
 8015cf6: bf00         	nop
 8015cf8: 3718         	adds	r7, #0x18
 8015cfa: 46bd         	mov	sp, r7
 8015cfc: bd80         	pop	{r7, pc}
 8015cfe: bf00         	nop

08015d00 <$d>:
 8015d00: 45 5a 01 08  	.word	0x08015a45

08015d04 <work_timeout>:
; {
 8015d04: b580         	push	{r7, lr}
 8015d06: b092         	sub	sp, #0x48
 8015d08: af00         	add	r7, sp, #0x0
 8015d0a: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dw = CONTAINER_OF(to, struct k_work_delayable, timeout);
 8015d0c: 687b         	ldr	r3, [r7, #0x4]
 8015d0e: 3b10         	subs	r3, #0x10
 8015d10: 647b         	str	r3, [r7, #0x44]
; 	struct k_work *wp = &dw->work;
 8015d12: 6c7b         	ldr	r3, [r7, #0x44]
 8015d14: 643b         	str	r3, [r7, #0x40]
 8015d16: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8015d9c <work_timeout+0x98>
 8015d18: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015d1a: f3ef 8311    	mrs	r3, basepri
 8015d1e: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 8015d20: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 8015d22: 637b         	str	r3, [r7, #0x34]
 8015d24: 2310         	movs	r3, #0x10
 8015d26: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015d28: 6b3b         	ldr	r3, [r7, #0x30]
 8015d2a: f383 8812    	msr	basepri_max, r3
; }
 8015d2e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015d30: f3bf 8f6f    	isb	sy
; }
 8015d34: bf00         	nop
; 	return key;
 8015d36: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 8015d38: 60fb         	str	r3, [r7, #0xc]
 8015d3a: 6bfb         	ldr	r3, [r7, #0x3c]
 8015d3c: 62fb         	str	r3, [r7, #0x2c]
; }
 8015d3e: bf00         	nop
 8015d40: 6bfb         	ldr	r3, [r7, #0x3c]
 8015d42: 62bb         	str	r3, [r7, #0x28]
; }
 8015d44: bf00         	nop
; 	return k;
 8015d46: 68fb         	ldr	r3, [r7, #0xc]
 8015d48: 61bb         	str	r3, [r7, #0x18]
; 	struct k_work_q *queue = NULL;
 8015d4a: 2300         	movs	r3, #0x0
 8015d4c: 617b         	str	r3, [r7, #0x14]
; 	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
 8015d4e: 6c3b         	ldr	r3, [r7, #0x40]
 8015d50: 330c         	adds	r3, #0xc
 8015d52: 2103         	movs	r1, #0x3
 8015d54: 4618         	mov	r0, r3
 8015d56: f011 ff3d    	bl	0x8027bd4 <flag_test_and_clear> @ imm = #0x11e7a
 8015d5a: 4603         	mov	r3, r0
 8015d5c: 2b00         	cmp	r3, #0x0
 8015d5e: d008         	beq	0x8015d72 <work_timeout+0x6e> @ imm = #0x10
; 		queue = dw->queue;
 8015d60: 6c7b         	ldr	r3, [r7, #0x44]
 8015d62: 6a9b         	ldr	r3, [r3, #0x28]
 8015d64: 617b         	str	r3, [r7, #0x14]
; 		(void)submit_to_queue_locked(wp, &queue);
 8015d66: f107 0314    	add.w	r3, r7, #0x14
 8015d6a: 4619         	mov	r1, r3
 8015d6c: 6c38         	ldr	r0, [r7, #0x40]
 8015d6e: f011 ffb8    	bl	0x8027ce2 <submit_to_queue_locked> @ imm = #0x11f70
 8015d72: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8015d9c <work_timeout+0x98>
 8015d74: 627b         	str	r3, [r7, #0x24]
 8015d76: 69bb         	ldr	r3, [r7, #0x18]
 8015d78: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8015d7a: 693b         	ldr	r3, [r7, #0x10]
 8015d7c: 623b         	str	r3, [r7, #0x20]
 8015d7e: 6a3b         	ldr	r3, [r7, #0x20]
 8015d80: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015d82: 69fb         	ldr	r3, [r7, #0x1c]
 8015d84: f383 8811    	msr	basepri, r3
; }
 8015d88: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015d8a: f3bf 8f6f    	isb	sy
; }
 8015d8e: bf00         	nop
; }
 8015d90: bf00         	nop
; }
 8015d92: bf00         	nop
; }
 8015d94: bf00         	nop
 8015d96: 3748         	adds	r7, #0x48
 8015d98: 46bd         	mov	sp, r7
 8015d9a: bd80         	pop	{r7, pc}

08015d9c <$d>:
 8015d9c: d0 32 00 24  	.word	0x240032d0

08015da0 <schedule_for_queue_locked>:
; {
 8015da0: b580         	push	{r7, lr}
 8015da2: b086         	sub	sp, #0x18
 8015da4: af00         	add	r7, sp, #0x0
 8015da6: 60f8         	str	r0, [r7, #0xc]
 8015da8: 60b9         	str	r1, [r7, #0x8]
 8015daa: e9c7 2300    	strd	r2, r3, [r7]
; 	int ret = 1;
 8015dae: 2301         	movs	r3, #0x1
 8015db0: 617b         	str	r3, [r7, #0x14]
; 	struct k_work *work = &dwork->work;
 8015db2: 68bb         	ldr	r3, [r7, #0x8]
 8015db4: 613b         	str	r3, [r7, #0x10]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 8015db6: e9d7 2300    	ldrd	r2, r3, [r7]
 8015dba: f04f 0000    	mov.w	r0, #0x0
 8015dbe: f04f 0100    	mov.w	r1, #0x0
 8015dc2: 428b         	cmp	r3, r1
 8015dc4: bf08         	it	eq
 8015dc6: 4282         	cmpeq	r2, r0
 8015dc8: d105         	bne	0x8015dd6 <schedule_for_queue_locked+0x36> @ imm = #0xa
; 		return submit_to_queue_locked(work, queuep);
 8015dca: 68f9         	ldr	r1, [r7, #0xc]
 8015dcc: 6938         	ldr	r0, [r7, #0x10]
 8015dce: f011 ff88    	bl	0x8027ce2 <submit_to_queue_locked> @ imm = #0x11f10
 8015dd2: 4603         	mov	r3, r0
 8015dd4: e012         	b	0x8015dfc <schedule_for_queue_locked+0x5c> @ imm = #0x24
; 	flag_set(&work->flags, K_WORK_DELAYED_BIT);
 8015dd6: 693b         	ldr	r3, [r7, #0x10]
 8015dd8: 330c         	adds	r3, #0xc
 8015dda: 2103         	movs	r1, #0x3
 8015ddc: 4618         	mov	r0, r3
 8015dde: f011 fece    	bl	0x8027b7e <flag_set>    @ imm = #0x11d9c
; 	dwork->queue = *queuep;
 8015de2: 68fb         	ldr	r3, [r7, #0xc]
 8015de4: 681a         	ldr	r2, [r3]
 8015de6: 68bb         	ldr	r3, [r7, #0x8]
 8015de8: 629a         	str	r2, [r3, #0x28]
; 	z_add_timeout(&dwork->timeout, work_timeout, delay);
 8015dea: 68bb         	ldr	r3, [r7, #0x8]
 8015dec: f103 0010    	add.w	r0, r3, #0x10
 8015df0: e9d7 2300    	ldrd	r2, r3, [r7]
 8015df4: 4903         	ldr	r1, [pc, #0xc]          @ 0x8015e04 <schedule_for_queue_locked+0x64>
 8015df6: f002 f94f    	bl	0x8018098 <z_add_timeout> @ imm = #0x229e
; 	return ret;
 8015dfa: 697b         	ldr	r3, [r7, #0x14]
; }
 8015dfc: 4618         	mov	r0, r3
 8015dfe: 3718         	adds	r7, #0x18
 8015e00: 46bd         	mov	sp, r7
 8015e02: bd80         	pop	{r7, pc}

08015e04 <$d>:
 8015e04: 05 5d 01 08  	.word	0x08015d05

08015e08 <k_work_reschedule_for_queue>:
; {
 8015e08: b580         	push	{r7, lr}
 8015e0a: b092         	sub	sp, #0x48
 8015e0c: af00         	add	r7, sp, #0x0
 8015e0e: 60f8         	str	r0, [r7, #0xc]
 8015e10: 60b9         	str	r1, [r7, #0x8]
 8015e12: e9c7 2300    	strd	r2, r3, [r7]
 8015e16: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8015e8c <k_work_reschedule_for_queue+0x84>
 8015e18: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015e1a: f3ef 8311    	mrs	r3, basepri
 8015e1e: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8015e20: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 8015e22: 62fb         	str	r3, [r7, #0x2c]
 8015e24: 2310         	movs	r3, #0x10
 8015e26: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015e28: 6abb         	ldr	r3, [r7, #0x28]
 8015e2a: f383 8812    	msr	basepri_max, r3
; }
 8015e2e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015e30: f3bf 8f6f    	isb	sy
; }
 8015e34: bf00         	nop
; 	return key;
 8015e36: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 8015e38: 61bb         	str	r3, [r7, #0x18]
 8015e3a: 6b7b         	ldr	r3, [r7, #0x34]
 8015e3c: 627b         	str	r3, [r7, #0x24]
; }
 8015e3e: bf00         	nop
 8015e40: 6b7b         	ldr	r3, [r7, #0x34]
 8015e42: 623b         	str	r3, [r7, #0x20]
; }
 8015e44: bf00         	nop
; 	return k;
 8015e46: 69bb         	ldr	r3, [r7, #0x18]
 8015e48: 61fb         	str	r3, [r7, #0x1c]
; 	(void)unschedule_locked(dwork);
 8015e4a: 68b8         	ldr	r0, [r7, #0x8]
 8015e4c: f011 ffec    	bl	0x8027e28 <unschedule_locked> @ imm = #0x11fd8
; 	ret = schedule_for_queue_locked(&queue, dwork, delay);
 8015e50: f107 000c    	add.w	r0, r7, #0xc
 8015e54: e9d7 2300    	ldrd	r2, r3, [r7]
 8015e58: 68b9         	ldr	r1, [r7, #0x8]
 8015e5a: f7ff ffa1    	bl	0x8015da0 <schedule_for_queue_locked> @ imm = #-0xbe
 8015e5e: 6478         	str	r0, [r7, #0x44]
 8015e60: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8015e8c <k_work_reschedule_for_queue+0x84>
 8015e62: 643b         	str	r3, [r7, #0x40]
 8015e64: 69fb         	ldr	r3, [r7, #0x1c]
 8015e66: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8015e68: 697b         	ldr	r3, [r7, #0x14]
 8015e6a: 63fb         	str	r3, [r7, #0x3c]
 8015e6c: 6bfb         	ldr	r3, [r7, #0x3c]
 8015e6e: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015e70: 6bbb         	ldr	r3, [r7, #0x38]
 8015e72: f383 8811    	msr	basepri, r3
; }
 8015e76: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015e78: f3bf 8f6f    	isb	sy
; }
 8015e7c: bf00         	nop
; }
 8015e7e: bf00         	nop
; }
 8015e80: bf00         	nop
; 	return ret;
 8015e82: 6c7b         	ldr	r3, [r7, #0x44]
; }
 8015e84: 4618         	mov	r0, r3
 8015e86: 3748         	adds	r7, #0x48
 8015e88: 46bd         	mov	sp, r7
 8015e8a: bd80         	pop	{r7, pc}

08015e8c <$d>:
 8015e8c: d0 32 00 24  	.word	0x240032d0

08015e90 <k_work_reschedule>:
; {
 8015e90: b580         	push	{r7, lr}
 8015e92: b086         	sub	sp, #0x18
 8015e94: af00         	add	r7, sp, #0x0
 8015e96: 60f8         	str	r0, [r7, #0xc]
 8015e98: e9c7 2300    	strd	r2, r3, [r7]
; 	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
 8015e9c: e9d7 2300    	ldrd	r2, r3, [r7]
 8015ea0: 68f9         	ldr	r1, [r7, #0xc]
 8015ea2: 4804         	ldr	r0, [pc, #0x10]         @ 0x8015eb4 <k_work_reschedule+0x24>
 8015ea4: f7ff ffb0    	bl	0x8015e08 <k_work_reschedule_for_queue> @ imm = #-0xa0
 8015ea8: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 8015eaa: 697b         	ldr	r3, [r7, #0x14]
; }
 8015eac: 4618         	mov	r0, r3
 8015eae: 3718         	adds	r7, #0x18
 8015eb0: 46bd         	mov	sp, r7
 8015eb2: bd80         	pop	{r7, pc}

08015eb4 <$d>:
 8015eb4: d8 22 00 24  	.word	0x240022d8

08015eb8 <k_work_cancel_delayable>:
; {
 8015eb8: b580         	push	{r7, lr}
 8015eba: b090         	sub	sp, #0x40
 8015ebc: af00         	add	r7, sp, #0x0
 8015ebe: 6078         	str	r0, [r7, #0x4]
 8015ec0: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8015f28 <k_work_cancel_delayable+0x70>
 8015ec2: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015ec4: f3ef 8311    	mrs	r3, basepri
 8015ec8: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 8015eca: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 8015ecc: 627b         	str	r3, [r7, #0x24]
 8015ece: 2310         	movs	r3, #0x10
 8015ed0: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015ed2: 6a3b         	ldr	r3, [r7, #0x20]
 8015ed4: f383 8812    	msr	basepri_max, r3
; }
 8015ed8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015eda: f3bf 8f6f    	isb	sy
; }
 8015ede: bf00         	nop
; 	return key;
 8015ee0: 6a7b         	ldr	r3, [r7, #0x24]
; 	k.key = arch_irq_lock();
 8015ee2: 613b         	str	r3, [r7, #0x10]
 8015ee4: 6afb         	ldr	r3, [r7, #0x2c]
 8015ee6: 61fb         	str	r3, [r7, #0x1c]
; }
 8015ee8: bf00         	nop
 8015eea: 6afb         	ldr	r3, [r7, #0x2c]
 8015eec: 61bb         	str	r3, [r7, #0x18]
; }
 8015eee: bf00         	nop
; 	return k;
 8015ef0: 693b         	ldr	r3, [r7, #0x10]
 8015ef2: 617b         	str	r3, [r7, #0x14]
; 	int ret = cancel_delayable_async_locked(dwork);
 8015ef4: 6878         	ldr	r0, [r7, #0x4]
 8015ef6: f011 ffb8    	bl	0x8027e6a <cancel_delayable_async_locked> @ imm = #0x11f70
 8015efa: 63f8         	str	r0, [r7, #0x3c]
 8015efc: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8015f28 <k_work_cancel_delayable+0x70>
 8015efe: 63bb         	str	r3, [r7, #0x38]
 8015f00: 697b         	ldr	r3, [r7, #0x14]
 8015f02: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8015f04: 68fb         	ldr	r3, [r7, #0xc]
 8015f06: 637b         	str	r3, [r7, #0x34]
 8015f08: 6b7b         	ldr	r3, [r7, #0x34]
 8015f0a: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015f0c: 6b3b         	ldr	r3, [r7, #0x30]
 8015f0e: f383 8811    	msr	basepri, r3
; }
 8015f12: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015f14: f3bf 8f6f    	isb	sy
; }
 8015f18: bf00         	nop
; }
 8015f1a: bf00         	nop
; }
 8015f1c: bf00         	nop
; 	return ret;
 8015f1e: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 8015f20: 4618         	mov	r0, r3
 8015f22: 3740         	adds	r7, #0x40
 8015f24: 46bd         	mov	sp, r7
 8015f26: bd80         	pop	{r7, pc}

08015f28 <$d>:
 8015f28: d0 32 00 24  	.word	0x240032d0

08015f2c <z_add_thread_timeout>:
; {
 8015f2c: b580         	push	{r7, lr}
 8015f2e: b084         	sub	sp, #0x10
 8015f30: af00         	add	r7, sp, #0x0
 8015f32: 60f8         	str	r0, [r7, #0xc]
 8015f34: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 8015f38: 68fb         	ldr	r3, [r7, #0xc]
 8015f3a: f103 0018    	add.w	r0, r3, #0x18
 8015f3e: e9d7 2300    	ldrd	r2, r3, [r7]
 8015f42: 4903         	ldr	r1, [pc, #0xc]          @ 0x8015f50 <z_add_thread_timeout+0x24>
 8015f44: f002 f8a8    	bl	0x8018098 <z_add_timeout> @ imm = #0x2150
; }
 8015f48: bf00         	nop
 8015f4a: 3710         	adds	r7, #0x10
 8015f4c: 46bd         	mov	sp, r7
 8015f4e: bd80         	pop	{r7, pc}

08015f50 <$d>:
 8015f50: d3 88 02 08  	.word	0x080288d3

08015f54 <z_impl_k_thread_name_set>:
; {
 8015f54: b580         	push	{r7, lr}
 8015f56: b084         	sub	sp, #0x10
 8015f58: af00         	add	r7, sp, #0x0
 8015f5a: 6078         	str	r0, [r7, #0x4]
 8015f5c: 6039         	str	r1, [r7]
; 	if (thread == NULL) {
 8015f5e: 687b         	ldr	r3, [r7, #0x4]
 8015f60: 2b00         	cmp	r3, #0x0
 8015f62: d104         	bne	0x8015f6e <z_impl_k_thread_name_set+0x1a> @ imm = #0x8
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015f64: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8015f90 <z_impl_k_thread_name_set+0x3c>
 8015f66: 689b         	ldr	r3, [r3, #0x8]
 8015f68: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8015f6a: 68fb         	ldr	r3, [r7, #0xc]
; 		thread = arch_current_thread();
 8015f6c: 607b         	str	r3, [r7, #0x4]
; 	strncpy(thread->name, str, CONFIG_THREAD_MAX_NAME_LEN - 1);
 8015f6e: 687b         	ldr	r3, [r7, #0x4]
 8015f70: 3394         	adds	r3, #0x94
 8015f72: 221f         	movs	r2, #0x1f
 8015f74: 6839         	ldr	r1, [r7]
 8015f76: 4618         	mov	r0, r3
 8015f78: f013 f8d2    	bl	0x8029120 <strncpy>     @ imm = #0x131a4
; 	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 8015f7c: 687b         	ldr	r3, [r7, #0x4]
 8015f7e: 2200         	movs	r2, #0x0
 8015f80: f883 20b3    	strb.w	r2, [r3, #0xb3]
; 	return 0;
 8015f84: 2300         	movs	r3, #0x0
; }
 8015f86: 4618         	mov	r0, r3
 8015f88: 3710         	adds	r7, #0x10
 8015f8a: 46bd         	mov	sp, r7
 8015f8c: bd80         	pop	{r7, pc}
 8015f8e: bf00         	nop

08015f90 <$d>:
 8015f90: 60 20 00 24  	.word	0x24002060

08015f94 <setup_thread_stack>:
; {
 8015f94: b580         	push	{r7, lr}
 8015f96: b096         	sub	sp, #0x58
 8015f98: af0a         	add	r7, sp, #0x28
 8015f9a: 60f8         	str	r0, [r7, #0xc]
 8015f9c: 60b9         	str	r1, [r7, #0x8]
 8015f9e: 607a         	str	r2, [r7, #0x4]
; 	size_t delta = 0;
 8015fa0: 2300         	movs	r3, #0x0
 8015fa2: 62fb         	str	r3, [r7, #0x2c]
; 		stack_obj_size = K_KERNEL_STACK_LEN(stack_size);
 8015fa4: 687b         	ldr	r3, [r7, #0x4]
 8015fa6: 3307         	adds	r3, #0x7
 8015fa8: f023 0307    	bic	r3, r3, #0x7
 8015fac: 3307         	adds	r3, #0x7
 8015fae: f023 0307    	bic	r3, r3, #0x7
 8015fb2: 62bb         	str	r3, [r7, #0x28]
; 		stack_buf_start = K_KERNEL_STACK_BUFFER(stack);
 8015fb4: 68b8         	ldr	r0, [r7, #0x8]
 8015fb6: f011 ff88    	bl	0x8027eca <K_KERNEL_STACK_BUFFER> @ imm = #0x11f10
 8015fba: 6278         	str	r0, [r7, #0x24]
; 		stack_buf_size = stack_obj_size - K_KERNEL_STACK_RESERVED;
 8015fbc: 6abb         	ldr	r3, [r7, #0x28]
 8015fbe: 623b         	str	r3, [r7, #0x20]
; 	stack_ptr = (char *)stack + stack_obj_size;
 8015fc0: 68ba         	ldr	r2, [r7, #0x8]
 8015fc2: 6abb         	ldr	r3, [r7, #0x28]
 8015fc4: 4413         	add	r3, r2
 8015fc6: 61fb         	str	r3, [r7, #0x1c]
; 	LOG_DBG("stack %p for thread %p: obj_size=%zu buf_start=%p "
 8015fc8: 2303         	movs	r3, #0x3
 8015fca: 2b03         	cmp	r3, #0x3
 8015fcc: d924         	bls	0x8016018 <setup_thread_stack+0x84> @ imm = #0x48
 8015fce: 2301         	movs	r3, #0x1
 8015fd0: 76fb         	strb	r3, [r7, #0x1b]
 8015fd2: 7efb         	ldrb	r3, [r7, #0x1b]
 8015fd4: f083 0301    	eor	r3, r3, #0x1
 8015fd8: b2db         	uxtb	r3, r3
 8015fda: 2b00         	cmp	r3, #0x0
 8015fdc: d11c         	bne	0x8016018 <setup_thread_stack+0x84> @ imm = #0x38
 8015fde: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8016068 <setup_thread_stack+0xd4>
 8015fe0: 6819         	ldr	r1, [r3]
 8015fe2: 69fb         	ldr	r3, [r7, #0x1c]
 8015fe4: 9309         	str	r3, [sp, #0x24]
 8015fe6: 6a3b         	ldr	r3, [r7, #0x20]
 8015fe8: 9308         	str	r3, [sp, #0x20]
 8015fea: 6a7b         	ldr	r3, [r7, #0x24]
 8015fec: 9307         	str	r3, [sp, #0x1c]
 8015fee: 6abb         	ldr	r3, [r7, #0x28]
 8015ff0: 9306         	str	r3, [sp, #0x18]
 8015ff2: 68fb         	ldr	r3, [r7, #0xc]
 8015ff4: 9305         	str	r3, [sp, #0x14]
 8015ff6: 68bb         	ldr	r3, [r7, #0x8]
 8015ff8: 9304         	str	r3, [sp, #0x10]
 8015ffa: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x801606c <setup_thread_stack+0xd8>
 8015ffc: 9303         	str	r3, [sp, #0xc]
 8015ffe: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8016070 <setup_thread_stack+0xdc>
 8016000: 9302         	str	r3, [sp, #0x8]
 8016002: 2308         	movs	r3, #0x8
 8016004: 9301         	str	r3, [sp, #0x4]
 8016006: 2300         	movs	r3, #0x0
 8016008: 9300         	str	r3, [sp]
 801600a: 2300         	movs	r3, #0x0
 801600c: 2204         	movs	r2, #0x4
 801600e: 2000         	movs	r0, #0x0
 8016010: f011 ffbe    	bl	0x8027f90 <z_log_msg_runtime_create> @ imm = #0x11f7c
 8016014: 2300         	movs	r3, #0x0
 8016016: 617b         	str	r3, [r7, #0x14]
; 	memset(stack_buf_start, 0xaa, stack_buf_size);
 8016018: 6a3a         	ldr	r2, [r7, #0x20]
 801601a: 21aa         	movs	r1, #0xaa
 801601c: 6a78         	ldr	r0, [r7, #0x24]
 801601e: f013 f877    	bl	0x8029110 <memset>      @ imm = #0x130ee
; 	delta += arch_tls_stack_setup(new_thread, stack_ptr);
 8016022: 69f9         	ldr	r1, [r7, #0x1c]
 8016024: 68f8         	ldr	r0, [r7, #0xc]
 8016026: f007 fa74    	bl	0x801d512 <arch_tls_stack_setup> @ imm = #0x74e8
 801602a: 4602         	mov	r2, r0
 801602c: 6afb         	ldr	r3, [r7, #0x2c]
 801602e: 4413         	add	r3, r2
 8016030: 62fb         	str	r3, [r7, #0x2c]
; 	delta = ROUND_UP(delta, ARCH_STACK_PTR_ALIGN);
 8016032: 6afb         	ldr	r3, [r7, #0x2c]
 8016034: 3307         	adds	r3, #0x7
 8016036: f023 0307    	bic	r3, r3, #0x7
 801603a: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
 801603c: 6a7a         	ldr	r2, [r7, #0x24]
 801603e: 68fb         	ldr	r3, [r7, #0xc]
 8016040: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	new_thread->stack_info.size = stack_buf_size;
 8016044: 68fb         	ldr	r3, [r7, #0xc]
 8016046: 6a3a         	ldr	r2, [r7, #0x20]
 8016048: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	new_thread->stack_info.delta = delta;
 801604c: 68fb         	ldr	r3, [r7, #0xc]
 801604e: 6afa         	ldr	r2, [r7, #0x2c]
 8016050: f8c3 20bc    	str.w	r2, [r3, #0xbc]
; 	stack_ptr -= delta;
 8016054: 6afb         	ldr	r3, [r7, #0x2c]
 8016056: 425b         	rsbs	r3, r3, #0
 8016058: 69fa         	ldr	r2, [r7, #0x1c]
 801605a: 4413         	add	r3, r2
 801605c: 61fb         	str	r3, [r7, #0x1c]
; 	return stack_ptr;
 801605e: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8016060: 4618         	mov	r0, r3
 8016062: 3730         	adds	r7, #0x30
 8016064: 46bd         	mov	sp, r7
 8016066: bd80         	pop	{r7, pc}

08016068 <$d>:
 8016068: 70 0b 00 24  	.word	0x24000b70
 801606c: 24 e6 02 08  	.word	0x0802e624
 8016070: 64 c9 02 08  	.word	0x0802c964

08016074 <z_setup_new_thread>:
; {
 8016074: b580         	push	{r7, lr}
 8016076: b09c         	sub	sp, #0x70
 8016078: af04         	add	r7, sp, #0x10
 801607a: 60f8         	str	r0, [r7, #0xc]
 801607c: 60b9         	str	r1, [r7, #0x8]
 801607e: 607a         	str	r2, [r7, #0x4]
 8016080: 603b         	str	r3, [r7]
; 	z_waitq_init(&new_thread->join_queue);
 8016082: 68fb         	ldr	r3, [r7, #0xc]
 8016084: 3368         	adds	r3, #0x68
 8016086: 4618         	mov	r0, r3
 8016088: f011 ff76    	bl	0x8027f78 <z_waitq_init> @ imm = #0x11eec
; 	z_init_thread_base(&new_thread->base, prio, _THREAD_SUSPENDED, options);
 801608c: 68f8         	ldr	r0, [r7, #0xc]
 801608e: 6fbb         	ldr	r3, [r7, #0x78]
 8016090: 2210         	movs	r2, #0x10
 8016092: 6f79         	ldr	r1, [r7, #0x74]
 8016094: f011 fff2    	bl	0x802807c <z_init_thread_base> @ imm = #0x11fe4
; 	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
 8016098: 687a         	ldr	r2, [r7, #0x4]
 801609a: 68b9         	ldr	r1, [r7, #0x8]
 801609c: 68f8         	ldr	r0, [r7, #0xc]
 801609e: f7ff ff79    	bl	0x8015f94 <setup_thread_stack> @ imm = #-0x10e
 80160a2: 65f8         	str	r0, [r7, #0x5c]
; 	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 80160a4: 6f3b         	ldr	r3, [r7, #0x70]
 80160a6: 9302         	str	r3, [sp, #0x8]
 80160a8: 6efb         	ldr	r3, [r7, #0x6c]
 80160aa: 9301         	str	r3, [sp, #0x4]
 80160ac: 6ebb         	ldr	r3, [r7, #0x68]
 80160ae: 9300         	str	r3, [sp]
 80160b0: 683b         	ldr	r3, [r7]
 80160b2: 6dfa         	ldr	r2, [r7, #0x5c]
 80160b4: 68b9         	ldr	r1, [r7, #0x8]
 80160b6: 68f8         	ldr	r0, [r7, #0xc]
 80160b8: f7f0 fae2    	bl	0x8006680 <arch_new_thread> @ imm = #-0xfa3c
; 	new_thread->init_data = NULL;
 80160bc: 68fb         	ldr	r3, [r7, #0xc]
 80160be: 2200         	movs	r2, #0x0
 80160c0: 665a         	str	r2, [r3, #0x64]
; 	new_thread->no_wake_on_timeout = false;
 80160c2: 68fb         	ldr	r3, [r7, #0xc]
 80160c4: 2200         	movs	r2, #0x0
 80160c6: f883 207c    	strb.w	r2, [r3, #0x7c]
; 	new_thread->entry.pEntry = entry;
 80160ca: 68fb         	ldr	r3, [r7, #0xc]
 80160cc: 683a         	ldr	r2, [r7]
 80160ce: f8c3 2080    	str.w	r2, [r3, #0x80]
; 	new_thread->entry.parameter1 = p1;
 80160d2: 68fb         	ldr	r3, [r7, #0xc]
 80160d4: 6eba         	ldr	r2, [r7, #0x68]
 80160d6: f8c3 2084    	str.w	r2, [r3, #0x84]
; 	new_thread->entry.parameter2 = p2;
 80160da: 68fb         	ldr	r3, [r7, #0xc]
 80160dc: 6efa         	ldr	r2, [r7, #0x6c]
 80160de: f8c3 2088    	str.w	r2, [r3, #0x88]
; 	new_thread->entry.parameter3 = p3;
 80160e2: 68fb         	ldr	r3, [r7, #0xc]
 80160e4: 6f3a         	ldr	r2, [r7, #0x70]
 80160e6: f8c3 208c    	str.w	r2, [r3, #0x8c]
 80160ea: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80161c0 <z_setup_new_thread+0x14c>
 80160ec: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80160ee: f3ef 8311    	mrs	r3, basepri
 80160f2: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 80160f4: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 80160f6: 647b         	str	r3, [r7, #0x44]
 80160f8: 2310         	movs	r3, #0x10
 80160fa: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80160fc: 6c3b         	ldr	r3, [r7, #0x40]
 80160fe: f383 8812    	msr	basepri_max, r3
; }
 8016102: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016104: f3bf 8f6f    	isb	sy
; }
 8016108: bf00         	nop
; 	return key;
 801610a: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 801610c: 617b         	str	r3, [r7, #0x14]
 801610e: 6cfb         	ldr	r3, [r7, #0x4c]
 8016110: 63fb         	str	r3, [r7, #0x3c]
; }
 8016112: bf00         	nop
 8016114: 6cfb         	ldr	r3, [r7, #0x4c]
 8016116: 63bb         	str	r3, [r7, #0x38]
; }
 8016118: bf00         	nop
; 	return k;
 801611a: 697b         	ldr	r3, [r7, #0x14]
 801611c: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->next_thread = _kernel.threads;
 801611e: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x80161c4 <z_setup_new_thread+0x150>
 8016120: 6b1a         	ldr	r2, [r3, #0x30]
 8016122: 68fb         	ldr	r3, [r7, #0xc]
 8016124: f8c3 2090    	str.w	r2, [r3, #0x90]
; 	_kernel.threads = new_thread;
 8016128: 4a26         	ldr	r2, [pc, #0x98]         @ 0x80161c4 <z_setup_new_thread+0x150>
 801612a: 68fb         	ldr	r3, [r7, #0xc]
 801612c: 6313         	str	r3, [r2, #0x30]
 801612e: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80161c0 <z_setup_new_thread+0x14c>
 8016130: 65bb         	str	r3, [r7, #0x58]
 8016132: 6afb         	ldr	r3, [r7, #0x2c]
 8016134: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8016136: 693b         	ldr	r3, [r7, #0x10]
 8016138: 657b         	str	r3, [r7, #0x54]
 801613a: 6d7b         	ldr	r3, [r7, #0x54]
 801613c: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801613e: 6d3b         	ldr	r3, [r7, #0x50]
 8016140: f383 8811    	msr	basepri, r3
; }
 8016144: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016146: f3bf 8f6f    	isb	sy
; }
 801614a: bf00         	nop
; }
 801614c: bf00         	nop
; }
 801614e: bf00         	nop
; 	if (name != NULL) {
 8016150: 6ffb         	ldr	r3, [r7, #0x7c]
 8016152: 2b00         	cmp	r3, #0x0
 8016154: d00b         	beq	0x801616e <z_setup_new_thread+0xfa> @ imm = #0x16
; 		strncpy(new_thread->name, name,
 8016156: 68fb         	ldr	r3, [r7, #0xc]
 8016158: 3394         	adds	r3, #0x94
 801615a: 221f         	movs	r2, #0x1f
 801615c: 6ff9         	ldr	r1, [r7, #0x7c]
 801615e: 4618         	mov	r0, r3
 8016160: f012 ffde    	bl	0x8029120 <strncpy>     @ imm = #0x12fbc
; 		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 8016164: 68fb         	ldr	r3, [r7, #0xc]
 8016166: 2200         	movs	r2, #0x0
 8016168: f883 20b3    	strb.w	r2, [r3, #0xb3]
 801616c: e003         	b	0x8016176 <z_setup_new_thread+0x102> @ imm = #0x6
; 		new_thread->name[0] = '\0';
 801616e: 68fb         	ldr	r3, [r7, #0xc]
 8016170: 2200         	movs	r2, #0x0
 8016172: f883 2094    	strb.w	r2, [r3, #0x94]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016176: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80161c4 <z_setup_new_thread+0x150>
 8016178: 689b         	ldr	r3, [r3, #0x8]
 801617a: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 801617c: 6b7b         	ldr	r3, [r7, #0x34]
; 	if (!arch_current_thread()) {
 801617e: 2b00         	cmp	r3, #0x0
 8016180: d105         	bne	0x801618e <z_setup_new_thread+0x11a> @ imm = #0xa
; 		new_thread->resource_pool = NULL;
 8016182: 68fb         	ldr	r3, [r7, #0xc]
 8016184: 2200         	movs	r2, #0x0
 8016186: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 		return stack_ptr;
 801618a: 6dfb         	ldr	r3, [r7, #0x5c]
 801618c: e014         	b	0x80161b8 <z_setup_new_thread+0x144> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801618e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80161c4 <z_setup_new_thread+0x150>
 8016190: 689b         	ldr	r3, [r3, #0x8]
 8016192: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 8016194: 6b3b         	ldr	r3, [r7, #0x30]
; 	new_thread->resource_pool = arch_current_thread()->resource_pool;
 8016196: f8d3 20c0    	ldr.w	r2, [r3, #0xc0]
 801619a: 68fb         	ldr	r3, [r7, #0xc]
 801619c: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 	new_thread->base.usage = (struct k_cycle_stats) {};
 80161a0: 68fb         	ldr	r3, [r7, #0xc]
 80161a2: 3330         	adds	r3, #0x30
 80161a4: 2200         	movs	r2, #0x0
 80161a6: 601a         	str	r2, [r3]
 80161a8: 605a         	str	r2, [r3, #0x4]
 80161aa: 609a         	str	r2, [r3, #0x8]
 80161ac: 60da         	str	r2, [r3, #0xc]
; 	new_thread->base.usage.track_usage =
 80161ae: 68fb         	ldr	r3, [r7, #0xc]
 80161b0: 2201         	movs	r2, #0x1
 80161b2: f883 2038    	strb.w	r2, [r3, #0x38]
; 	return stack_ptr;
 80161b6: 6dfb         	ldr	r3, [r7, #0x5c]
; }
 80161b8: 4618         	mov	r0, r3
 80161ba: 3760         	adds	r7, #0x60
 80161bc: 46bd         	mov	sp, r7
 80161be: bd80         	pop	{r7, pc}

080161c0 <$d>:
 80161c0: e8 32 00 24  	.word	0x240032e8
 80161c4: 60 20 00 24  	.word	0x24002060

080161c8 <z_thread_mark_switched_in>:
; {
 80161c8: b580         	push	{r7, lr}
 80161ca: b082         	sub	sp, #0x8
 80161cc: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80161ce: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80161e4 <z_thread_mark_switched_in+0x1c>
 80161d0: 689b         	ldr	r3, [r3, #0x8]
 80161d2: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 80161d4: 687b         	ldr	r3, [r7, #0x4]
; 	z_sched_usage_start(arch_current_thread());
 80161d6: 4618         	mov	r0, r3
 80161d8: f002 f9ea    	bl	0x80185b0 <z_sched_usage_start> @ imm = #0x23d4
; }
 80161dc: bf00         	nop
 80161de: 3708         	adds	r7, #0x8
 80161e0: 46bd         	mov	sp, r7
 80161e2: bd80         	pop	{r7, pc}

080161e4 <$d>:
 80161e4: 60 20 00 24  	.word	0x24002060

080161e8 <z_add_thread_timeout>:
; {
 80161e8: b580         	push	{r7, lr}
 80161ea: b084         	sub	sp, #0x10
 80161ec: af00         	add	r7, sp, #0x0
 80161ee: 60f8         	str	r0, [r7, #0xc]
 80161f0: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 80161f4: 68fb         	ldr	r3, [r7, #0xc]
 80161f6: f103 0018    	add.w	r0, r3, #0x18
 80161fa: e9d7 2300    	ldrd	r2, r3, [r7]
 80161fe: 4903         	ldr	r1, [pc, #0xc]          @ 0x801620c <z_add_thread_timeout+0x24>
 8016200: f001 ff4a    	bl	0x8018098 <z_add_timeout> @ imm = #0x1e94
; }
 8016204: bf00         	nop
 8016206: 3710         	adds	r7, #0x10
 8016208: 46bd         	mov	sp, r7
 801620a: bd80         	pop	{r7, pc}

0801620c <$d>:
 801620c: d3 88 02 08  	.word	0x080288d3

08016210 <z_sched_lock>:
; {
 8016210: b480         	push	{r7}
 8016212: b083         	sub	sp, #0xc
 8016214: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016216: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8016234 <z_sched_lock+0x24>
 8016218: 689b         	ldr	r3, [r3, #0x8]
 801621a: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 801621c: 687b         	ldr	r3, [r7, #0x4]
; 	--arch_current_thread()->base.sched_locked;
 801621e: 7bda         	ldrb	r2, [r3, #0xf]
 8016220: 3a01         	subs	r2, #0x1
 8016222: b2d2         	uxtb	r2, r2
 8016224: 73da         	strb	r2, [r3, #0xf]
; }
 8016226: bf00         	nop
 8016228: 370c         	adds	r7, #0xc
 801622a: 46bd         	mov	sp, r7
 801622c: f85d 7b04    	ldr	r7, [sp], #4
 8016230: 4770         	bx	lr
 8016232: bf00         	nop

08016234 <$d>:
 8016234: 60 20 00 24  	.word	0x24002060

08016238 <z_dummy_thread_init>:
; {
 8016238: b580         	push	{r7, lr}
 801623a: b084         	sub	sp, #0x10
 801623c: af00         	add	r7, sp, #0x0
 801623e: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 8016240: 687b         	ldr	r3, [r7, #0x4]
 8016242: 2201         	movs	r2, #0x1
 8016244: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 8016246: 687b         	ldr	r3, [r7, #0x4]
 8016248: 2201         	movs	r2, #0x1
 801624a: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 801624c: 687b         	ldr	r3, [r7, #0x4]
 801624e: 2200         	movs	r2, #0x0
 8016250: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 8016254: 687b         	ldr	r3, [r7, #0x4]
 8016256: 2200         	movs	r2, #0x0
 8016258: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	k_thread_system_pool_assign(dummy_thread);
 801625c: 6878         	ldr	r0, [r7, #0x4]
 801625e: f002 fb07    	bl	0x8018870 <k_thread_system_pool_assign> @ imm = #0x260e
 8016262: 687b         	ldr	r3, [r7, #0x4]
 8016264: 60fb         	str	r3, [r7, #0xc]
; 	_current_cpu->current = thread;
 8016266: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8016278 <z_dummy_thread_init+0x40>
 8016268: 68fb         	ldr	r3, [r7, #0xc]
 801626a: 6093         	str	r3, [r2, #0x8]
; }
 801626c: bf00         	nop
; }
 801626e: bf00         	nop
 8016270: 3710         	adds	r7, #0x10
 8016272: 46bd         	mov	sp, r7
 8016274: bd80         	pop	{r7, pc}
 8016276: bf00         	nop

08016278 <$d>:
 8016278: 60 20 00 24  	.word	0x24002060

0801627c <move_thread_to_end_of_prio_q>:
; {
 801627c: b580         	push	{r7, lr}
 801627e: b09a         	sub	sp, #0x68
 8016280: af00         	add	r7, sp, #0x0
 8016282: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 8016284: 6878         	ldr	r0, [r7, #0x4]
 8016286: f012 f95c    	bl	0x8028542 <z_is_thread_queued> @ imm = #0x122b8
 801628a: 4603         	mov	r3, r0
 801628c: 2b00         	cmp	r3, #0x0
 801628e: d01d         	beq	0x80162cc <move_thread_to_end_of_prio_q+0x50> @ imm = #0x3a
 8016290: 687b         	ldr	r3, [r7, #0x4]
 8016292: 667b         	str	r3, [r7, #0x64]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 8016294: 6e7b         	ldr	r3, [r7, #0x64]
 8016296: 7b5b         	ldrb	r3, [r3, #0xd]
 8016298: f003 037f    	and	r3, r3, #0x7f
 801629c: b2da         	uxtb	r2, r3
 801629e: 6e7b         	ldr	r3, [r7, #0x64]
 80162a0: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 80162a2: 6e78         	ldr	r0, [r7, #0x64]
 80162a4: f012 fa38    	bl	0x8028718 <should_queue_thread> @ imm = #0x12470
 80162a8: 4603         	mov	r3, r0
 80162aa: 2b00         	cmp	r3, #0x0
 80162ac: d00d         	beq	0x80162ca <move_thread_to_end_of_prio_q+0x4e> @ imm = #0x1a
 80162ae: 6e7b         	ldr	r3, [r7, #0x64]
 80162b0: 663b         	str	r3, [r7, #0x60]
 80162b2: 6e3b         	ldr	r3, [r7, #0x60]
 80162b4: 65fb         	str	r3, [r7, #0x5c]
; 	return &_kernel.ready_q.runq;
 80162b6: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x8016454 <move_thread_to_end_of_prio_q+0x1d8>
 80162b8: 65bb         	str	r3, [r7, #0x58]
 80162ba: 6e3b         	ldr	r3, [r7, #0x60]
 80162bc: 657b         	str	r3, [r7, #0x54]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 80162be: 6d7b         	ldr	r3, [r7, #0x54]
 80162c0: 4618         	mov	r0, r3
 80162c2: f012 f85e    	bl	0x8028382 <sys_dlist_remove> @ imm = #0x120bc
; }
 80162c6: bf00         	nop
; }
 80162c8: bf00         	nop
; }
 80162ca: bf00         	nop
 80162cc: 687b         	ldr	r3, [r7, #0x4]
 80162ce: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 80162d0: 69fb         	ldr	r3, [r7, #0x1c]
 80162d2: 7b5b         	ldrb	r3, [r3, #0xd]
 80162d4: f063 037f    	orn	r3, r3, #0x7f
 80162d8: b2da         	uxtb	r2, r3
 80162da: 69fb         	ldr	r3, [r7, #0x1c]
 80162dc: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 80162de: 69f8         	ldr	r0, [r7, #0x1c]
 80162e0: f012 fa1a    	bl	0x8028718 <should_queue_thread> @ imm = #0x12434
 80162e4: 4603         	mov	r3, r0
 80162e6: 2b00         	cmp	r3, #0x0
 80162e8: d042         	beq	0x8016370 <move_thread_to_end_of_prio_q+0xf4> @ imm = #0x84
 80162ea: 69fb         	ldr	r3, [r7, #0x1c]
 80162ec: 61bb         	str	r3, [r7, #0x18]
 80162ee: 69bb         	ldr	r3, [r7, #0x18]
 80162f0: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 80162f2: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8016454 <move_thread_to_end_of_prio_q+0x1d8>
 80162f4: 613b         	str	r3, [r7, #0x10]
 80162f6: 69bb         	ldr	r3, [r7, #0x18]
 80162f8: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80162fa: 6938         	ldr	r0, [r7, #0x10]
 80162fc: f011 ffd4    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x11fa8
 8016300: 4603         	mov	r3, r0
 8016302: 2b00         	cmp	r3, #0x0
 8016304: d004         	beq	0x8016310 <move_thread_to_end_of_prio_q+0x94> @ imm = #0x8
 8016306: 6938         	ldr	r0, [r7, #0x10]
 8016308: f011 ffce    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x11f9c
 801630c: 4603         	mov	r3, r0
 801630e: e000         	b	0x8016312 <move_thread_to_end_of_prio_q+0x96> @ imm = #0x0
 8016310: 2300         	movs	r3, #0x0
 8016312: 60bb         	str	r3, [r7, #0x8]
 8016314: e023         	b	0x801635e <move_thread_to_end_of_prio_q+0xe2> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8016316: 68b9         	ldr	r1, [r7, #0x8]
 8016318: 68f8         	ldr	r0, [r7, #0xc]
 801631a: f012 f9e1    	bl	0x80286e0 <z_sched_prio_cmp> @ imm = #0x123c2
 801631e: 4603         	mov	r3, r0
 8016320: 2b00         	cmp	r3, #0x0
 8016322: dd06         	ble	0x8016332 <move_thread_to_end_of_prio_q+0xb6> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8016324: 68bb         	ldr	r3, [r7, #0x8]
 8016326: 68fa         	ldr	r2, [r7, #0xc]
 8016328: 4611         	mov	r1, r2
 801632a: 4618         	mov	r0, r3
 801632c: f012 f80f    	bl	0x802834e <sys_dlist_insert> @ imm = #0x1201e
; 			return;
 8016330: e01d         	b	0x801636e <move_thread_to_end_of_prio_q+0xf2> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8016332: 68bb         	ldr	r3, [r7, #0x8]
 8016334: 2b00         	cmp	r3, #0x0
 8016336: d010         	beq	0x801635a <move_thread_to_end_of_prio_q+0xde> @ imm = #0x20
 8016338: 68bb         	ldr	r3, [r7, #0x8]
 801633a: 4619         	mov	r1, r3
 801633c: 6938         	ldr	r0, [r7, #0x10]
 801633e: f011 ffd9    	bl	0x80282f4 <sys_dlist_peek_next> @ imm = #0x11fb2
 8016342: 4603         	mov	r3, r0
 8016344: 2b00         	cmp	r3, #0x0
 8016346: d006         	beq	0x8016356 <move_thread_to_end_of_prio_q+0xda> @ imm = #0xc
 8016348: 68bb         	ldr	r3, [r7, #0x8]
 801634a: 4619         	mov	r1, r3
 801634c: 6938         	ldr	r0, [r7, #0x10]
 801634e: f011 ffd1    	bl	0x80282f4 <sys_dlist_peek_next> @ imm = #0x11fa2
 8016352: 4603         	mov	r3, r0
 8016354: e002         	b	0x801635c <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x4
 8016356: 2300         	movs	r3, #0x0
 8016358: e000         	b	0x801635c <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x0
 801635a: 2300         	movs	r3, #0x0
 801635c: 60bb         	str	r3, [r7, #0x8]
 801635e: 68bb         	ldr	r3, [r7, #0x8]
 8016360: 2b00         	cmp	r3, #0x0
 8016362: d1d8         	bne	0x8016316 <move_thread_to_end_of_prio_q+0x9a> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8016364: 68fb         	ldr	r3, [r7, #0xc]
 8016366: 4619         	mov	r1, r3
 8016368: 6938         	ldr	r0, [r7, #0x10]
 801636a: f011 ffd6    	bl	0x802831a <sys_dlist_append> @ imm = #0x11fac
; }
 801636e: bf00         	nop
; }
 8016370: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016372: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8016458 <move_thread_to_end_of_prio_q+0x1dc>
 8016374: 689b         	ldr	r3, [r3, #0x8]
 8016376: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 8016378: 6a3b         	ldr	r3, [r7, #0x20]
; 	update_cache(thread == arch_current_thread());
 801637a: 687a         	ldr	r2, [r7, #0x4]
 801637c: 429a         	cmp	r2, r3
 801637e: bf0c         	ite	eq
 8016380: 2301         	moveq	r3, #0x1
 8016382: 2300         	movne	r3, #0x0
 8016384: b2db         	uxtb	r3, r3
 8016386: 653b         	str	r3, [r7, #0x50]
; 	return &_kernel.ready_q.runq;
 8016388: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8016454 <move_thread_to_end_of_prio_q+0x1d8>
 801638a: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 801638c: 2300         	movs	r3, #0x0
 801638e: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8016390: 6cf8         	ldr	r0, [r7, #0x4c]
 8016392: f011 ff89    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x11f12
 8016396: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8016398: 6c7b         	ldr	r3, [r7, #0x44]
 801639a: 2b00         	cmp	r3, #0x0
 801639c: d001         	beq	0x80163a2 <move_thread_to_end_of_prio_q+0x126> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 801639e: 6c7b         	ldr	r3, [r7, #0x44]
 80163a0: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 80163a2: 6cbb         	ldr	r3, [r7, #0x48]
; 	return _priq_run_best(curr_cpu_runq());
 80163a4: bf00         	nop
; 	struct k_thread *thread = runq_best();
 80163a6: 643b         	str	r3, [r7, #0x40]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 80163a8: 6c3b         	ldr	r3, [r7, #0x40]
 80163aa: 2b00         	cmp	r3, #0x0
 80163ac: d102         	bne	0x80163b4 <move_thread_to_end_of_prio_q+0x138> @ imm = #0x4
 80163ae: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8016458 <move_thread_to_end_of_prio_q+0x1dc>
 80163b0: 68db         	ldr	r3, [r3, #0xc]
 80163b2: e000         	b	0x80163b6 <move_thread_to_end_of_prio_q+0x13a> @ imm = #0x0
 80163b4: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *thread = next_up();
 80163b6: 63fb         	str	r3, [r7, #0x3c]
 80163b8: 6bfb         	ldr	r3, [r7, #0x3c]
 80163ba: 63bb         	str	r3, [r7, #0x38]
 80163bc: 6d3b         	ldr	r3, [r7, #0x50]
 80163be: 637b         	str	r3, [r7, #0x34]
; 	if (preempt_ok != 0) {
 80163c0: 6b7b         	ldr	r3, [r7, #0x34]
 80163c2: 2b00         	cmp	r3, #0x0
 80163c4: d001         	beq	0x80163ca <move_thread_to_end_of_prio_q+0x14e> @ imm = #0x2
; 		return true;
 80163c6: 2301         	movs	r3, #0x1
 80163c8: e026         	b	0x8016418 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80163ca: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8016458 <move_thread_to_end_of_prio_q+0x1dc>
 80163cc: 689b         	ldr	r3, [r3, #0x8]
 80163ce: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 80163d0: 6b3b         	ldr	r3, [r7, #0x30]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 80163d2: 4618         	mov	r0, r3
 80163d4: f012 f852    	bl	0x802847c <z_is_thread_prevented_from_running> @ imm = #0x120a4
 80163d8: 4603         	mov	r3, r0
 80163da: 2b00         	cmp	r3, #0x0
 80163dc: d001         	beq	0x80163e2 <move_thread_to_end_of_prio_q+0x166> @ imm = #0x2
; 		return true;
 80163de: 2301         	movs	r3, #0x1
 80163e0: e01a         	b	0x8016418 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80163e2: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8016458 <move_thread_to_end_of_prio_q+0x1dc>
 80163e4: 689b         	ldr	r3, [r3, #0x8]
 80163e6: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 80163e8: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 80163ea: 4618         	mov	r0, r3
 80163ec: f012 f817    	bl	0x802841e <thread_is_preemptible> @ imm = #0x1202e
 80163f0: 4603         	mov	r3, r0
 80163f2: 2b00         	cmp	r3, #0x0
 80163f4: d105         	bne	0x8016402 <move_thread_to_end_of_prio_q+0x186> @ imm = #0xa
 80163f6: 6bb8         	ldr	r0, [r7, #0x38]
 80163f8: f012 f822    	bl	0x8028440 <thread_is_metairq> @ imm = #0x12044
 80163fc: 4603         	mov	r3, r0
 80163fe: 2b00         	cmp	r3, #0x0
 8016400: d001         	beq	0x8016406 <move_thread_to_end_of_prio_q+0x18a> @ imm = #0x2
; 		return true;
 8016402: 2301         	movs	r3, #0x1
 8016404: e008         	b	0x8016418 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8016406: 6bb8         	ldr	r0, [r7, #0x38]
 8016408: f012 f84d    	bl	0x80284a6 <z_is_thread_timeout_active> @ imm = #0x1209a
 801640c: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 801640e: 2b00         	cmp	r3, #0x0
 8016410: d001         	beq	0x8016416 <move_thread_to_end_of_prio_q+0x19a> @ imm = #0x2
; 		return true;
 8016412: 2301         	movs	r3, #0x1
 8016414: e000         	b	0x8016418 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x0
; 	return false;
 8016416: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8016418: 2b00         	cmp	r3, #0x0
 801641a: d010         	beq	0x801643e <move_thread_to_end_of_prio_q+0x1c2> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801641c: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8016458 <move_thread_to_end_of_prio_q+0x1dc>
 801641e: 689b         	ldr	r3, [r3, #0x8]
 8016420: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8016422: 6abb         	ldr	r3, [r7, #0x28]
; 		if (thread != arch_current_thread()) {
 8016424: 6bfa         	ldr	r2, [r7, #0x3c]
 8016426: 429a         	cmp	r2, r3
 8016428: d002         	beq	0x8016430 <move_thread_to_end_of_prio_q+0x1b4> @ imm = #0x4
; 			z_reset_time_slice(thread);
 801642a: 6bf8         	ldr	r0, [r7, #0x3c]
 801642c: f001 fc5c    	bl	0x8017ce8 <z_reset_time_slice> @ imm = #0x18b8
; 		update_metairq_preempt(thread);
 8016430: 6bf8         	ldr	r0, [r7, #0x3c]
 8016432: f012 f9b8    	bl	0x80287a6 <update_metairq_preempt> @ imm = #0x12370
; 		_kernel.ready_q.cache = thread;
 8016436: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8016458 <move_thread_to_end_of_prio_q+0x1dc>
 8016438: 6bfb         	ldr	r3, [r7, #0x3c]
 801643a: 6213         	str	r3, [r2, #0x20]
; }
 801643c: e005         	b	0x801644a <move_thread_to_end_of_prio_q+0x1ce> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801643e: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8016458 <move_thread_to_end_of_prio_q+0x1dc>
 8016440: 689b         	ldr	r3, [r3, #0x8]
 8016442: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8016444: 6a7b         	ldr	r3, [r7, #0x24]
; 		_kernel.ready_q.cache = arch_current_thread();
 8016446: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8016458 <move_thread_to_end_of_prio_q+0x1dc>
 8016448: 6213         	str	r3, [r2, #0x20]
; }
 801644a: bf00         	nop
; }
 801644c: bf00         	nop
 801644e: 3768         	adds	r7, #0x68
 8016450: 46bd         	mov	sp, r7
 8016452: bd80         	pop	{r7, pc}

08016454 <$d>:
 8016454: 84 20 00 24  	.word	0x24002084
 8016458: 60 20 00 24  	.word	0x24002060

0801645c <ready_thread>:
; {
 801645c: b580         	push	{r7, lr}
 801645e: b094         	sub	sp, #0x50
 8016460: af00         	add	r7, sp, #0x0
 8016462: 6078         	str	r0, [r7, #0x4]
; 	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 8016464: 6878         	ldr	r0, [r7, #0x4]
 8016466: f012 f86c    	bl	0x8028542 <z_is_thread_queued> @ imm = #0x120d8
 801646a: 4603         	mov	r3, r0
 801646c: f083 0301    	eor	r3, r3, #0x1
 8016470: b2db         	uxtb	r3, r3
 8016472: 2b00         	cmp	r3, #0x0
 8016474: f000 80be    	beq.w	0x80165f4 <ready_thread+0x198> @ imm = #0x17c
 8016478: 6878         	ldr	r0, [r7, #0x4]
 801647a: f012 f82d    	bl	0x80284d8 <z_is_thread_ready> @ imm = #0x1205a
 801647e: 4603         	mov	r3, r0
 8016480: 2b00         	cmp	r3, #0x0
 8016482: f000 80b7    	beq.w	0x80165f4 <ready_thread+0x198> @ imm = #0x16e
 8016486: 687b         	ldr	r3, [r7, #0x4]
 8016488: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 801648a: 69fb         	ldr	r3, [r7, #0x1c]
 801648c: 7b5b         	ldrb	r3, [r3, #0xd]
 801648e: f063 037f    	orn	r3, r3, #0x7f
 8016492: b2da         	uxtb	r2, r3
 8016494: 69fb         	ldr	r3, [r7, #0x1c]
 8016496: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8016498: 69f8         	ldr	r0, [r7, #0x1c]
 801649a: f012 f93d    	bl	0x8028718 <should_queue_thread> @ imm = #0x1227a
 801649e: 4603         	mov	r3, r0
 80164a0: 2b00         	cmp	r3, #0x0
 80164a2: d042         	beq	0x801652a <ready_thread+0xce> @ imm = #0x84
 80164a4: 69fb         	ldr	r3, [r7, #0x1c]
 80164a6: 61bb         	str	r3, [r7, #0x18]
 80164a8: 69bb         	ldr	r3, [r7, #0x18]
 80164aa: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 80164ac: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x80165fc <ready_thread+0x1a0>
 80164ae: 613b         	str	r3, [r7, #0x10]
 80164b0: 69bb         	ldr	r3, [r7, #0x18]
 80164b2: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80164b4: 6938         	ldr	r0, [r7, #0x10]
 80164b6: f011 fef7    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x11dee
 80164ba: 4603         	mov	r3, r0
 80164bc: 2b00         	cmp	r3, #0x0
 80164be: d004         	beq	0x80164ca <ready_thread+0x6e> @ imm = #0x8
 80164c0: 6938         	ldr	r0, [r7, #0x10]
 80164c2: f011 fef1    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x11de2
 80164c6: 4603         	mov	r3, r0
 80164c8: e000         	b	0x80164cc <ready_thread+0x70> @ imm = #0x0
 80164ca: 2300         	movs	r3, #0x0
 80164cc: 60bb         	str	r3, [r7, #0x8]
 80164ce: e023         	b	0x8016518 <ready_thread+0xbc> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 80164d0: 68b9         	ldr	r1, [r7, #0x8]
 80164d2: 68f8         	ldr	r0, [r7, #0xc]
 80164d4: f012 f904    	bl	0x80286e0 <z_sched_prio_cmp> @ imm = #0x12208
 80164d8: 4603         	mov	r3, r0
 80164da: 2b00         	cmp	r3, #0x0
 80164dc: dd06         	ble	0x80164ec <ready_thread+0x90> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 80164de: 68bb         	ldr	r3, [r7, #0x8]
 80164e0: 68fa         	ldr	r2, [r7, #0xc]
 80164e2: 4611         	mov	r1, r2
 80164e4: 4618         	mov	r0, r3
 80164e6: f011 ff32    	bl	0x802834e <sys_dlist_insert> @ imm = #0x11e64
; 			return;
 80164ea: e01d         	b	0x8016528 <ready_thread+0xcc> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80164ec: 68bb         	ldr	r3, [r7, #0x8]
 80164ee: 2b00         	cmp	r3, #0x0
 80164f0: d010         	beq	0x8016514 <ready_thread+0xb8> @ imm = #0x20
 80164f2: 68bb         	ldr	r3, [r7, #0x8]
 80164f4: 4619         	mov	r1, r3
 80164f6: 6938         	ldr	r0, [r7, #0x10]
 80164f8: f011 fefc    	bl	0x80282f4 <sys_dlist_peek_next> @ imm = #0x11df8
 80164fc: 4603         	mov	r3, r0
 80164fe: 2b00         	cmp	r3, #0x0
 8016500: d006         	beq	0x8016510 <ready_thread+0xb4> @ imm = #0xc
 8016502: 68bb         	ldr	r3, [r7, #0x8]
 8016504: 4619         	mov	r1, r3
 8016506: 6938         	ldr	r0, [r7, #0x10]
 8016508: f011 fef4    	bl	0x80282f4 <sys_dlist_peek_next> @ imm = #0x11de8
 801650c: 4603         	mov	r3, r0
 801650e: e002         	b	0x8016516 <ready_thread+0xba> @ imm = #0x4
 8016510: 2300         	movs	r3, #0x0
 8016512: e000         	b	0x8016516 <ready_thread+0xba> @ imm = #0x0
 8016514: 2300         	movs	r3, #0x0
 8016516: 60bb         	str	r3, [r7, #0x8]
 8016518: 68bb         	ldr	r3, [r7, #0x8]
 801651a: 2b00         	cmp	r3, #0x0
 801651c: d1d8         	bne	0x80164d0 <ready_thread+0x74> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 801651e: 68fb         	ldr	r3, [r7, #0xc]
 8016520: 4619         	mov	r1, r3
 8016522: 6938         	ldr	r0, [r7, #0x10]
 8016524: f011 fef9    	bl	0x802831a <sys_dlist_append> @ imm = #0x11df2
; }
 8016528: bf00         	nop
; }
 801652a: bf00         	nop
 801652c: 2300         	movs	r3, #0x0
 801652e: 64fb         	str	r3, [r7, #0x4c]
; 	return &_kernel.ready_q.runq;
 8016530: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x80165fc <ready_thread+0x1a0>
 8016532: 64bb         	str	r3, [r7, #0x48]
; 	struct k_thread *thread = NULL;
 8016534: 2300         	movs	r3, #0x0
 8016536: 647b         	str	r3, [r7, #0x44]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8016538: 6cb8         	ldr	r0, [r7, #0x48]
 801653a: f011 feb5    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x11d6a
 801653e: 6438         	str	r0, [r7, #0x40]
; 	if (n != NULL) {
 8016540: 6c3b         	ldr	r3, [r7, #0x40]
 8016542: 2b00         	cmp	r3, #0x0
 8016544: d001         	beq	0x801654a <ready_thread+0xee> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8016546: 6c3b         	ldr	r3, [r7, #0x40]
 8016548: 647b         	str	r3, [r7, #0x44]
; 	return thread;
 801654a: 6c7b         	ldr	r3, [r7, #0x44]
; 	return _priq_run_best(curr_cpu_runq());
 801654c: bf00         	nop
; 	struct k_thread *thread = runq_best();
 801654e: 63fb         	str	r3, [r7, #0x3c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8016550: 6bfb         	ldr	r3, [r7, #0x3c]
 8016552: 2b00         	cmp	r3, #0x0
 8016554: d102         	bne	0x801655c <ready_thread+0x100> @ imm = #0x4
 8016556: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8016600 <ready_thread+0x1a4>
 8016558: 68db         	ldr	r3, [r3, #0xc]
 801655a: e000         	b	0x801655e <ready_thread+0x102> @ imm = #0x0
 801655c: 6bfb         	ldr	r3, [r7, #0x3c]
; 	struct k_thread *thread = next_up();
 801655e: 63bb         	str	r3, [r7, #0x38]
 8016560: 6bbb         	ldr	r3, [r7, #0x38]
 8016562: 637b         	str	r3, [r7, #0x34]
 8016564: 6cfb         	ldr	r3, [r7, #0x4c]
 8016566: 633b         	str	r3, [r7, #0x30]
; 	if (preempt_ok != 0) {
 8016568: 6b3b         	ldr	r3, [r7, #0x30]
 801656a: 2b00         	cmp	r3, #0x0
 801656c: d001         	beq	0x8016572 <ready_thread+0x116> @ imm = #0x2
; 		return true;
 801656e: 2301         	movs	r3, #0x1
 8016570: e026         	b	0x80165c0 <ready_thread+0x164> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016572: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8016600 <ready_thread+0x1a4>
 8016574: 689b         	ldr	r3, [r3, #0x8]
 8016576: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 8016578: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 801657a: 4618         	mov	r0, r3
 801657c: f011 ff7e    	bl	0x802847c <z_is_thread_prevented_from_running> @ imm = #0x11efc
 8016580: 4603         	mov	r3, r0
 8016582: 2b00         	cmp	r3, #0x0
 8016584: d001         	beq	0x801658a <ready_thread+0x12e> @ imm = #0x2
; 		return true;
 8016586: 2301         	movs	r3, #0x1
 8016588: e01a         	b	0x80165c0 <ready_thread+0x164> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801658a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8016600 <ready_thread+0x1a4>
 801658c: 689b         	ldr	r3, [r3, #0x8]
 801658e: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8016590: 6abb         	ldr	r3, [r7, #0x28]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 8016592: 4618         	mov	r0, r3
 8016594: f011 ff43    	bl	0x802841e <thread_is_preemptible> @ imm = #0x11e86
 8016598: 4603         	mov	r3, r0
 801659a: 2b00         	cmp	r3, #0x0
 801659c: d105         	bne	0x80165aa <ready_thread+0x14e> @ imm = #0xa
 801659e: 6b78         	ldr	r0, [r7, #0x34]
 80165a0: f011 ff4e    	bl	0x8028440 <thread_is_metairq> @ imm = #0x11e9c
 80165a4: 4603         	mov	r3, r0
 80165a6: 2b00         	cmp	r3, #0x0
 80165a8: d001         	beq	0x80165ae <ready_thread+0x152> @ imm = #0x2
; 		return true;
 80165aa: 2301         	movs	r3, #0x1
 80165ac: e008         	b	0x80165c0 <ready_thread+0x164> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 80165ae: 6b78         	ldr	r0, [r7, #0x34]
 80165b0: f011 ff79    	bl	0x80284a6 <z_is_thread_timeout_active> @ imm = #0x11ef2
 80165b4: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 80165b6: 2b00         	cmp	r3, #0x0
 80165b8: d001         	beq	0x80165be <ready_thread+0x162> @ imm = #0x2
; 		return true;
 80165ba: 2301         	movs	r3, #0x1
 80165bc: e000         	b	0x80165c0 <ready_thread+0x164> @ imm = #0x0
; 	return false;
 80165be: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 80165c0: 2b00         	cmp	r3, #0x0
 80165c2: d010         	beq	0x80165e6 <ready_thread+0x18a> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80165c4: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8016600 <ready_thread+0x1a4>
 80165c6: 689b         	ldr	r3, [r3, #0x8]
 80165c8: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 80165ca: 6a7b         	ldr	r3, [r7, #0x24]
; 		if (thread != arch_current_thread()) {
 80165cc: 6bba         	ldr	r2, [r7, #0x38]
 80165ce: 429a         	cmp	r2, r3
 80165d0: d002         	beq	0x80165d8 <ready_thread+0x17c> @ imm = #0x4
; 			z_reset_time_slice(thread);
 80165d2: 6bb8         	ldr	r0, [r7, #0x38]
 80165d4: f001 fb88    	bl	0x8017ce8 <z_reset_time_slice> @ imm = #0x1710
; 		update_metairq_preempt(thread);
 80165d8: 6bb8         	ldr	r0, [r7, #0x38]
 80165da: f012 f8e4    	bl	0x80287a6 <update_metairq_preempt> @ imm = #0x121c8
; 		_kernel.ready_q.cache = thread;
 80165de: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8016600 <ready_thread+0x1a4>
 80165e0: 6bbb         	ldr	r3, [r7, #0x38]
 80165e2: 6213         	str	r3, [r2, #0x20]
; }
 80165e4: e005         	b	0x80165f2 <ready_thread+0x196> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80165e6: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8016600 <ready_thread+0x1a4>
 80165e8: 689b         	ldr	r3, [r3, #0x8]
 80165ea: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 80165ec: 6a3b         	ldr	r3, [r7, #0x20]
; 		_kernel.ready_q.cache = arch_current_thread();
 80165ee: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8016600 <ready_thread+0x1a4>
 80165f0: 6213         	str	r3, [r2, #0x20]
; }
 80165f2: bf00         	nop
; }
 80165f4: bf00         	nop
 80165f6: 3750         	adds	r7, #0x50
 80165f8: 46bd         	mov	sp, r7
 80165fa: bd80         	pop	{r7, pc}

080165fc <$d>:
 80165fc: 84 20 00 24  	.word	0x24002084
 8016600: 60 20 00 24  	.word	0x24002060

08016604 <z_ready_thread>:
; {
 8016604: b580         	push	{r7, lr}
 8016606: b090         	sub	sp, #0x40
 8016608: af00         	add	r7, sp, #0x0
 801660a: 6078         	str	r0, [r7, #0x4]
; 	K_SPINLOCK(&_sched_spinlock) {
 801660c: 2300         	movs	r3, #0x0
 801660e: 61bb         	str	r3, [r7, #0x18]
 8016610: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8016690 <z_ready_thread+0x8c>
 8016612: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016614: f3ef 8311    	mrs	r3, basepri
 8016618: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 801661a: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 801661c: 637b         	str	r3, [r7, #0x34]
 801661e: 2310         	movs	r3, #0x10
 8016620: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016622: 6b3b         	ldr	r3, [r7, #0x30]
 8016624: f383 8812    	msr	basepri_max, r3
; }
 8016628: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801662a: f3bf 8f6f    	isb	sy
; }
 801662e: bf00         	nop
; 	return key;
 8016630: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 8016632: 60fb         	str	r3, [r7, #0xc]
 8016634: 6bfb         	ldr	r3, [r7, #0x3c]
 8016636: 62fb         	str	r3, [r7, #0x2c]
; }
 8016638: bf00         	nop
 801663a: 6bfb         	ldr	r3, [r7, #0x3c]
 801663c: 62bb         	str	r3, [r7, #0x28]
; }
 801663e: bf00         	nop
; 	return k;
 8016640: 68fb         	ldr	r3, [r7, #0xc]
 8016642: 617b         	str	r3, [r7, #0x14]
; 	K_SPINLOCK(&_sched_spinlock) {
 8016644: e01b         	b	0x801667e <z_ready_thread+0x7a> @ imm = #0x36
; 		if (thread_active_elsewhere(thread) == NULL) {
 8016646: 6878         	ldr	r0, [r7, #0x4]
 8016648: f012 f8b7    	bl	0x80287ba <thread_active_elsewhere> @ imm = #0x1216e
 801664c: 4603         	mov	r3, r0
 801664e: 2b00         	cmp	r3, #0x0
 8016650: d102         	bne	0x8016658 <z_ready_thread+0x54> @ imm = #0x4
; 			ready_thread(thread);
 8016652: 6878         	ldr	r0, [r7, #0x4]
 8016654: f7ff ff02    	bl	0x801645c <ready_thread> @ imm = #-0x1fc
 8016658: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8016690 <z_ready_thread+0x8c>
 801665a: 627b         	str	r3, [r7, #0x24]
 801665c: 697b         	ldr	r3, [r7, #0x14]
 801665e: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8016660: 693b         	ldr	r3, [r7, #0x10]
 8016662: 623b         	str	r3, [r7, #0x20]
 8016664: 6a3b         	ldr	r3, [r7, #0x20]
 8016666: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016668: 69fb         	ldr	r3, [r7, #0x1c]
 801666a: f383 8811    	msr	basepri, r3
; }
 801666e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016670: f3bf 8f6f    	isb	sy
; }
 8016674: bf00         	nop
; }
 8016676: bf00         	nop
; }
 8016678: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 801667a: 2301         	movs	r3, #0x1
 801667c: 61bb         	str	r3, [r7, #0x18]
 801667e: 69bb         	ldr	r3, [r7, #0x18]
 8016680: 2b00         	cmp	r3, #0x0
 8016682: d0e0         	beq	0x8016646 <z_ready_thread+0x42> @ imm = #-0x40
; }
 8016684: bf00         	nop
 8016686: bf00         	nop
 8016688: 3740         	adds	r7, #0x40
 801668a: 46bd         	mov	sp, r7
 801668c: bd80         	pop	{r7, pc}
 801668e: bf00         	nop

08016690 <$d>:
 8016690: d8 32 00 24  	.word	0x240032d8

08016694 <thread_halt_spin>:
; {
 8016694: b590         	push	{r4, r7, lr}
 8016696: b091         	sub	sp, #0x44
 8016698: af00         	add	r7, sp, #0x0
 801669a: 6078         	str	r0, [r7, #0x4]
 801669c: 6039         	str	r1, [r7]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801669e: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8016754 <thread_halt_spin+0xc0>
 80166a0: 689b         	ldr	r3, [r3, #0x8]
 80166a2: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 80166a4: 6bbb         	ldr	r3, [r7, #0x38]
; 	if (is_halting(arch_current_thread())) {
 80166a6: 4618         	mov	r0, r3
 80166a8: f012 f854    	bl	0x8028754 <is_halting>  @ imm = #0x120a8
 80166ac: 4603         	mov	r3, r0
 80166ae: 2b00         	cmp	r3, #0x0
 80166b0: d014         	beq	0x80166dc <thread_halt_spin+0x48> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80166b2: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8016754 <thread_halt_spin+0xc0>
 80166b4: 689b         	ldr	r3, [r3, #0x8]
 80166b6: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 80166b8: 6b3c         	ldr	r4, [r7, #0x30]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80166ba: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8016754 <thread_halt_spin+0xc0>
 80166bc: 689b         	ldr	r3, [r3, #0x8]
 80166be: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 80166c0: 6b7b         	ldr	r3, [r7, #0x34]
; 			    is_aborting(arch_current_thread()) ? _THREAD_DEAD : _THREAD_SUSPENDED);
 80166c2: 4618         	mov	r0, r3
 80166c4: f012 f833    	bl	0x802872e <is_aborting> @ imm = #0x12066
 80166c8: 4603         	mov	r3, r0
; 		halt_thread(arch_current_thread(),
 80166ca: 2b00         	cmp	r3, #0x0
 80166cc: d001         	beq	0x80166d2 <thread_halt_spin+0x3e> @ imm = #0x2
 80166ce: 2308         	movs	r3, #0x8
 80166d0: e000         	b	0x80166d4 <thread_halt_spin+0x40> @ imm = #0x0
 80166d2: 2310         	movs	r3, #0x10
 80166d4: 4619         	mov	r1, r3
 80166d6: 4620         	mov	r0, r4
 80166d8: f001 f89a    	bl	0x8017810 <halt_thread> @ imm = #0x1134
 80166dc: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8016758 <thread_halt_spin+0xc4>
 80166de: 62fb         	str	r3, [r7, #0x2c]
 80166e0: 683b         	ldr	r3, [r7]
 80166e2: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 80166e4: 68fb         	ldr	r3, [r7, #0xc]
 80166e6: 62bb         	str	r3, [r7, #0x28]
 80166e8: 6abb         	ldr	r3, [r7, #0x28]
 80166ea: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80166ec: 6a7b         	ldr	r3, [r7, #0x24]
 80166ee: f383 8811    	msr	basepri, r3
; }
 80166f2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80166f4: f3bf 8f6f    	isb	sy
; }
 80166f8: bf00         	nop
; }
 80166fa: bf00         	nop
; }
 80166fc: bf00         	nop
; 	while (is_halting(thread)) {
 80166fe: e01d         	b	0x801673c <thread_halt_spin+0xa8> @ imm = #0x3a
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016700: f3ef 8311    	mrs	r3, basepri
 8016704: 61bb         	str	r3, [r7, #0x18]
;   return(result);
 8016706: 69bb         	ldr	r3, [r7, #0x18]
; 	key = __get_BASEPRI();
 8016708: 617b         	str	r3, [r7, #0x14]
 801670a: 2310         	movs	r3, #0x10
 801670c: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801670e: 693b         	ldr	r3, [r7, #0x10]
 8016710: f383 8812    	msr	basepri_max, r3
; }
 8016714: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016716: f3bf 8f6f    	isb	sy
; }
 801671a: bf00         	nop
; 	return key;
 801671c: 697b         	ldr	r3, [r7, #0x14]
; 		unsigned int k = arch_irq_lock();
 801671e: 63fb         	str	r3, [r7, #0x3c]
; 		arch_spin_relax(); /* Requires interrupts be masked */
 8016720: f010 fa45    	bl	0x8026bae <arch_spin_relax> @ imm = #0x1048a
 8016724: 6bfb         	ldr	r3, [r7, #0x3c]
 8016726: 623b         	str	r3, [r7, #0x20]
 8016728: 6a3b         	ldr	r3, [r7, #0x20]
 801672a: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801672c: 69fb         	ldr	r3, [r7, #0x1c]
 801672e: f383 8811    	msr	basepri, r3
; }
 8016732: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016734: f3bf 8f6f    	isb	sy
; }
 8016738: bf00         	nop
; }
 801673a: bf00         	nop
; 	while (is_halting(thread)) {
 801673c: 6878         	ldr	r0, [r7, #0x4]
 801673e: f012 f809    	bl	0x8028754 <is_halting>  @ imm = #0x12012
 8016742: 4603         	mov	r3, r0
 8016744: 2b00         	cmp	r3, #0x0
 8016746: d1db         	bne	0x8016700 <thread_halt_spin+0x6c> @ imm = #-0x4a
; }
 8016748: bf00         	nop
 801674a: bf00         	nop
 801674c: 3744         	adds	r7, #0x44
 801674e: 46bd         	mov	sp, r7
 8016750: bd90         	pop	{r4, r7, pc}
 8016752: bf00         	nop

08016754 <$d>:
 8016754: 60 20 00 24  	.word	0x24002060
 8016758: d8 32 00 24  	.word	0x240032d8

0801675c <z_thread_halt>:
; {
 801675c: b580         	push	{r7, lr}
 801675e: b094         	sub	sp, #0x50
 8016760: af00         	add	r7, sp, #0x0
 8016762: 60f8         	str	r0, [r7, #0xc]
 8016764: 60b9         	str	r1, [r7, #0x8]
 8016766: 4613         	mov	r3, r2
 8016768: 71fb         	strb	r3, [r7, #0x7]
; 	_wait_q_t *wq = &thread->join_queue;
 801676a: 68fb         	ldr	r3, [r7, #0xc]
 801676c: 3368         	adds	r3, #0x68
 801676e: 64fb         	str	r3, [r7, #0x4c]
; 	struct _cpu *cpu = thread_active_elsewhere(thread);
 8016770: 68f8         	ldr	r0, [r7, #0xc]
 8016772: f012 f822    	bl	0x80287ba <thread_active_elsewhere> @ imm = #0x12044
 8016776: 64b8         	str	r0, [r7, #0x48]
; 	if (cpu != NULL) {
 8016778: 6cbb         	ldr	r3, [r7, #0x48]
 801677a: 2b00         	cmp	r3, #0x0
 801677c: d02f         	beq	0x80167de <z_thread_halt+0x82> @ imm = #0x5e
; 		thread->base.thread_state |= (terminate ? _THREAD_ABORTING
 801677e: 68fb         	ldr	r3, [r7, #0xc]
 8016780: 7b5b         	ldrb	r3, [r3, #0xd]
 8016782: 79fa         	ldrb	r2, [r7, #0x7]
 8016784: 2a00         	cmp	r2, #0x0
 8016786: d001         	beq	0x801678c <z_thread_halt+0x30> @ imm = #0x2
 8016788: 2220         	movs	r2, #0x20
 801678a: e000         	b	0x801678e <z_thread_halt+0x32> @ imm = #0x0
 801678c: 2240         	movs	r2, #0x40
 801678e: 4313         	orrs	r3, r2
 8016790: b2da         	uxtb	r2, r3
 8016792: 68fb         	ldr	r3, [r7, #0xc]
 8016794: 735a         	strb	r2, [r3, #0xd]
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8016796: f3ef 8305    	mrs	r3, ipsr
 801679a: 647b         	str	r3, [r7, #0x44]
;   return(result);
 801679c: 6c7b         	ldr	r3, [r7, #0x44]
; 	return (__get_IPSR()) ? (true) : (false);
 801679e: 2b00         	cmp	r3, #0x0
 80167a0: bf14         	ite	ne
 80167a2: 2301         	movne	r3, #0x1
 80167a4: 2300         	moveq	r3, #0x0
 80167a6: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 80167a8: 2b00         	cmp	r3, #0x0
 80167aa: d004         	beq	0x80167b6 <z_thread_halt+0x5a> @ imm = #0x8
; 			thread_halt_spin(thread, key);
 80167ac: 68b9         	ldr	r1, [r7, #0x8]
 80167ae: 68f8         	ldr	r0, [r7, #0xc]
 80167b0: f7ff ff70    	bl	0x8016694 <thread_halt_spin> @ imm = #-0x120
; }
 80167b4: e04f         	b	0x8016856 <z_thread_halt+0xfa> @ imm = #0x9e
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80167b6: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8016860 <z_thread_halt+0x104>
 80167b8: 689b         	ldr	r3, [r3, #0x8]
 80167ba: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 80167bc: 6bbb         	ldr	r3, [r7, #0x38]
; 			add_to_waitq_locked(arch_current_thread(), wq);
 80167be: 6cf9         	ldr	r1, [r7, #0x4c]
 80167c0: 4618         	mov	r0, r3
 80167c2: f012 f805    	bl	0x80287d0 <add_to_waitq_locked> @ imm = #0x1200a
 80167c6: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8016864 <z_thread_halt+0x108>
 80167c8: 643b         	str	r3, [r7, #0x40]
 80167ca: 68bb         	ldr	r3, [r7, #0x8]
 80167cc: 613b         	str	r3, [r7, #0x10]
 80167ce: 6c3b         	ldr	r3, [r7, #0x40]
 80167d0: 63fb         	str	r3, [r7, #0x3c]
; }
 80167d2: bf00         	nop
; 	return z_swap_irqlock(key.key);
 80167d4: 693b         	ldr	r3, [r7, #0x10]
 80167d6: 4618         	mov	r0, r3
 80167d8: f011 ff57    	bl	0x802868a <z_swap_irqlock> @ imm = #0x11eae
 80167dc: e03b         	b	0x8016856 <z_thread_halt+0xfa> @ imm = #0x76
; 		halt_thread(thread, terminate ? _THREAD_DEAD : _THREAD_SUSPENDED);
 80167de: 79fb         	ldrb	r3, [r7, #0x7]
 80167e0: 2b00         	cmp	r3, #0x0
 80167e2: d001         	beq	0x80167e8 <z_thread_halt+0x8c> @ imm = #0x2
 80167e4: 2308         	movs	r3, #0x8
 80167e6: e000         	b	0x80167ea <z_thread_halt+0x8e> @ imm = #0x0
 80167e8: 2310         	movs	r3, #0x10
 80167ea: 4619         	mov	r1, r3
 80167ec: 68f8         	ldr	r0, [r7, #0xc]
 80167ee: f001 f80f    	bl	0x8017810 <halt_thread> @ imm = #0x101e
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80167f2: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8016860 <z_thread_halt+0x104>
 80167f4: 689b         	ldr	r3, [r3, #0x8]
 80167f6: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 80167f8: 6b7b         	ldr	r3, [r7, #0x34]
; 		if ((thread == arch_current_thread()) && !arch_is_in_isr()) {
 80167fa: 68fa         	ldr	r2, [r7, #0xc]
 80167fc: 429a         	cmp	r2, r3
 80167fe: d119         	bne	0x8016834 <z_thread_halt+0xd8> @ imm = #0x32
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8016800: f3ef 8305    	mrs	r3, ipsr
 8016804: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8016806: 6b3b         	ldr	r3, [r7, #0x30]
; 	return (__get_IPSR()) ? (true) : (false);
 8016808: 2b00         	cmp	r3, #0x0
 801680a: bf14         	ite	ne
 801680c: 2301         	movne	r3, #0x1
 801680e: 2300         	moveq	r3, #0x0
 8016810: b2db         	uxtb	r3, r3
; 		if ((thread == arch_current_thread()) && !arch_is_in_isr()) {
 8016812: f083 0301    	eor	r3, r3, #0x1
 8016816: b2db         	uxtb	r3, r3
 8016818: 2b00         	cmp	r3, #0x0
 801681a: d00b         	beq	0x8016834 <z_thread_halt+0xd8> @ imm = #0x16
 801681c: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8016864 <z_thread_halt+0x108>
 801681e: 62fb         	str	r3, [r7, #0x2c]
 8016820: 68bb         	ldr	r3, [r7, #0x8]
 8016822: 617b         	str	r3, [r7, #0x14]
 8016824: 6afb         	ldr	r3, [r7, #0x2c]
 8016826: 62bb         	str	r3, [r7, #0x28]
; }
 8016828: bf00         	nop
; 	return z_swap_irqlock(key.key);
 801682a: 697b         	ldr	r3, [r7, #0x14]
 801682c: 4618         	mov	r0, r3
 801682e: f011 ff2c    	bl	0x802868a <z_swap_irqlock> @ imm = #0x11e58
; 			z_swap(&_sched_spinlock, key);
 8016832: e010         	b	0x8016856 <z_thread_halt+0xfa> @ imm = #0x20
 8016834: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8016864 <z_thread_halt+0x108>
 8016836: 627b         	str	r3, [r7, #0x24]
 8016838: 68bb         	ldr	r3, [r7, #0x8]
 801683a: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 801683c: 69bb         	ldr	r3, [r7, #0x18]
 801683e: 623b         	str	r3, [r7, #0x20]
 8016840: 6a3b         	ldr	r3, [r7, #0x20]
 8016842: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016844: 69fb         	ldr	r3, [r7, #0x1c]
 8016846: f383 8811    	msr	basepri, r3
; }
 801684a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801684c: f3bf 8f6f    	isb	sy
; }
 8016850: bf00         	nop
; }
 8016852: bf00         	nop
; }
 8016854: bf00         	nop
; }
 8016856: bf00         	nop
 8016858: 3750         	adds	r7, #0x50
 801685a: 46bd         	mov	sp, r7
 801685c: bd80         	pop	{r7, pc}
 801685e: bf00         	nop

08016860 <$d>:
 8016860: 60 20 00 24  	.word	0x24002060
 8016864: d8 32 00 24  	.word	0x240032d8

08016868 <z_impl_k_thread_suspend>:
; {
 8016868: b580         	push	{r7, lr}
 801686a: b0ac         	sub	sp, #0xb0
 801686c: af00         	add	r7, sp, #0x0
 801686e: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016870: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8016aac <z_impl_k_thread_suspend+0x244>
 8016872: 689b         	ldr	r3, [r3, #0x8]
 8016874: f8c7 30ac    	str.w	r3, [r7, #0xac]
; 	return ret;
 8016878: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
; 	if (thread == arch_current_thread() && !arch_is_in_isr() && !IS_ENABLED(CONFIG_SMP)) {
 801687c: 687a         	ldr	r2, [r7, #0x4]
 801687e: 429a         	cmp	r2, r3
 8016880: f040 80d7    	bne.w	0x8016a32 <z_impl_k_thread_suspend+0x1ca> @ imm = #0x1ae
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8016884: f3ef 8305    	mrs	r3, ipsr
 8016888: f8c7 30a8    	str.w	r3, [r7, #0xa8]
;   return(result);
 801688c: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
; 	return (__get_IPSR()) ? (true) : (false);
 8016890: 2b00         	cmp	r3, #0x0
 8016892: bf14         	ite	ne
 8016894: 2301         	movne	r3, #0x1
 8016896: 2300         	moveq	r3, #0x0
 8016898: b2db         	uxtb	r3, r3
; 	if (thread == arch_current_thread() && !arch_is_in_isr() && !IS_ENABLED(CONFIG_SMP)) {
 801689a: f083 0301    	eor	r3, r3, #0x1
 801689e: b2db         	uxtb	r3, r3
 80168a0: 2b00         	cmp	r3, #0x0
 80168a2: f000 80c6    	beq.w	0x8016a32 <z_impl_k_thread_suspend+0x1ca> @ imm = #0x18c
 80168a6: 4b82         	ldr	r3, [pc, #0x208]        @ 0x8016ab0 <z_impl_k_thread_suspend+0x248>
 80168a8: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80168aa: f3ef 8311    	mrs	r3, basepri
 80168ae: 657b         	str	r3, [r7, #0x54]
;   return(result);
 80168b0: 6d7b         	ldr	r3, [r7, #0x54]
; 	key = __get_BASEPRI();
 80168b2: 653b         	str	r3, [r7, #0x50]
 80168b4: 2310         	movs	r3, #0x10
 80168b6: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80168b8: 6cfb         	ldr	r3, [r7, #0x4c]
 80168ba: f383 8812    	msr	basepri_max, r3
; }
 80168be: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80168c0: f3bf 8f6f    	isb	sy
; }
 80168c4: bf00         	nop
; 	return key;
 80168c6: 6d3b         	ldr	r3, [r7, #0x50]
; 	k.key = arch_irq_lock();
 80168c8: 60fb         	str	r3, [r7, #0xc]
 80168ca: 6dbb         	ldr	r3, [r7, #0x58]
 80168cc: 64bb         	str	r3, [r7, #0x48]
; }
 80168ce: bf00         	nop
 80168d0: 6dbb         	ldr	r3, [r7, #0x58]
 80168d2: 647b         	str	r3, [r7, #0x44]
; }
 80168d4: bf00         	nop
; 	return k;
 80168d6: 68fb         	ldr	r3, [r7, #0xc]
 80168d8: 613b         	str	r3, [r7, #0x10]
; 		z_mark_thread_as_suspended(thread);
 80168da: 6878         	ldr	r0, [r7, #0x4]
 80168dc: f011 fe3e    	bl	0x802855c <z_mark_thread_as_suspended> @ imm = #0x11c7c
 80168e0: 687b         	ldr	r3, [r7, #0x4]
 80168e2: 66fb         	str	r3, [r7, #0x6c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 80168e4: 6efb         	ldr	r3, [r7, #0x6c]
 80168e6: 7b5b         	ldrb	r3, [r3, #0xd]
 80168e8: f003 037f    	and	r3, r3, #0x7f
 80168ec: b2da         	uxtb	r2, r3
 80168ee: 6efb         	ldr	r3, [r7, #0x6c]
 80168f0: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 80168f2: 6ef8         	ldr	r0, [r7, #0x6c]
 80168f4: f011 ff10    	bl	0x8028718 <should_queue_thread> @ imm = #0x11e20
 80168f8: 4603         	mov	r3, r0
 80168fa: 2b00         	cmp	r3, #0x0
 80168fc: d00d         	beq	0x801691a <z_impl_k_thread_suspend+0xb2> @ imm = #0x1a
 80168fe: 6efb         	ldr	r3, [r7, #0x6c]
 8016900: 66bb         	str	r3, [r7, #0x68]
 8016902: 6ebb         	ldr	r3, [r7, #0x68]
 8016904: 667b         	str	r3, [r7, #0x64]
; 	return &_kernel.ready_q.runq;
 8016906: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x8016ab4 <z_impl_k_thread_suspend+0x24c>
 8016908: 663b         	str	r3, [r7, #0x60]
 801690a: 6ebb         	ldr	r3, [r7, #0x68]
 801690c: 65fb         	str	r3, [r7, #0x5c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 801690e: 6dfb         	ldr	r3, [r7, #0x5c]
 8016910: 4618         	mov	r0, r3
 8016912: f011 fd36    	bl	0x8028382 <sys_dlist_remove> @ imm = #0x11a6c
; }
 8016916: bf00         	nop
; }
 8016918: bf00         	nop
; }
 801691a: bf00         	nop
 801691c: 2301         	movs	r3, #0x1
 801691e: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	return &_kernel.ready_q.runq;
 8016922: 4b64         	ldr	r3, [pc, #0x190]        @ 0x8016ab4 <z_impl_k_thread_suspend+0x24c>
 8016924: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	struct k_thread *thread = NULL;
 8016928: 2300         	movs	r3, #0x0
 801692a: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 801692e: f8d7 0098    	ldr.w	r0, [r7, #0x98]
 8016932: f011 fcb9    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x11972
 8016936: f8c7 0090    	str.w	r0, [r7, #0x90]
; 	if (n != NULL) {
 801693a: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 801693e: 2b00         	cmp	r3, #0x0
 8016940: d003         	beq	0x801694a <z_impl_k_thread_suspend+0xe2> @ imm = #0x6
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8016942: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 8016946: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	return thread;
 801694a: f8d7 3094    	ldr.w	r3, [r7, #0x94]
; 	return _priq_run_best(curr_cpu_runq());
 801694e: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8016950: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8016954: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8016958: 2b00         	cmp	r3, #0x0
 801695a: d102         	bne	0x8016962 <z_impl_k_thread_suspend+0xfa> @ imm = #0x4
 801695c: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8016aac <z_impl_k_thread_suspend+0x244>
 801695e: 68db         	ldr	r3, [r3, #0xc]
 8016960: e001         	b	0x8016966 <z_impl_k_thread_suspend+0xfe> @ imm = #0x2
 8016962: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	struct k_thread *thread = next_up();
 8016966: f8c7 3088    	str.w	r3, [r7, #0x88]
 801696a: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 801696e: f8c7 3084    	str.w	r3, [r7, #0x84]
 8016972: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 8016976: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	if (preempt_ok != 0) {
 801697a: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 801697e: 2b00         	cmp	r3, #0x0
 8016980: d001         	beq	0x8016986 <z_impl_k_thread_suspend+0x11e> @ imm = #0x2
; 		return true;
 8016982: 2301         	movs	r3, #0x1
 8016984: e028         	b	0x80169d8 <z_impl_k_thread_suspend+0x170> @ imm = #0x50
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016986: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8016aac <z_impl_k_thread_suspend+0x244>
 8016988: 689b         	ldr	r3, [r3, #0x8]
 801698a: 67fb         	str	r3, [r7, #0x7c]
; 	return ret;
 801698c: 6ffb         	ldr	r3, [r7, #0x7c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 801698e: 4618         	mov	r0, r3
 8016990: f011 fd74    	bl	0x802847c <z_is_thread_prevented_from_running> @ imm = #0x11ae8
 8016994: 4603         	mov	r3, r0
 8016996: 2b00         	cmp	r3, #0x0
 8016998: d001         	beq	0x801699e <z_impl_k_thread_suspend+0x136> @ imm = #0x2
; 		return true;
 801699a: 2301         	movs	r3, #0x1
 801699c: e01c         	b	0x80169d8 <z_impl_k_thread_suspend+0x170> @ imm = #0x38
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801699e: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8016aac <z_impl_k_thread_suspend+0x244>
 80169a0: 689b         	ldr	r3, [r3, #0x8]
 80169a2: 67bb         	str	r3, [r7, #0x78]
; 	return ret;
 80169a4: 6fbb         	ldr	r3, [r7, #0x78]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 80169a6: 4618         	mov	r0, r3
 80169a8: f011 fd39    	bl	0x802841e <thread_is_preemptible> @ imm = #0x11a72
 80169ac: 4603         	mov	r3, r0
 80169ae: 2b00         	cmp	r3, #0x0
 80169b0: d106         	bne	0x80169c0 <z_impl_k_thread_suspend+0x158> @ imm = #0xc
 80169b2: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 80169b6: f011 fd43    	bl	0x8028440 <thread_is_metairq> @ imm = #0x11a86
 80169ba: 4603         	mov	r3, r0
 80169bc: 2b00         	cmp	r3, #0x0
 80169be: d001         	beq	0x80169c4 <z_impl_k_thread_suspend+0x15c> @ imm = #0x2
; 		return true;
 80169c0: 2301         	movs	r3, #0x1
 80169c2: e009         	b	0x80169d8 <z_impl_k_thread_suspend+0x170> @ imm = #0x12
; 	    && z_is_thread_timeout_active(thread)) {
 80169c4: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 80169c8: f011 fd6d    	bl	0x80284a6 <z_is_thread_timeout_active> @ imm = #0x11ada
 80169cc: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 80169ce: 2b00         	cmp	r3, #0x0
 80169d0: d001         	beq	0x80169d6 <z_impl_k_thread_suspend+0x16e> @ imm = #0x2
; 		return true;
 80169d2: 2301         	movs	r3, #0x1
 80169d4: e000         	b	0x80169d8 <z_impl_k_thread_suspend+0x170> @ imm = #0x0
; 	return false;
 80169d6: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 80169d8: 2b00         	cmp	r3, #0x0
 80169da: d014         	beq	0x8016a06 <z_impl_k_thread_suspend+0x19e> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80169dc: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8016aac <z_impl_k_thread_suspend+0x244>
 80169de: 689b         	ldr	r3, [r3, #0x8]
 80169e0: 677b         	str	r3, [r7, #0x74]
; 	return ret;
 80169e2: 6f7b         	ldr	r3, [r7, #0x74]
; 		if (thread != arch_current_thread()) {
 80169e4: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 80169e8: 429a         	cmp	r2, r3
 80169ea: d003         	beq	0x80169f4 <z_impl_k_thread_suspend+0x18c> @ imm = #0x6
; 			z_reset_time_slice(thread);
 80169ec: f8d7 0088    	ldr.w	r0, [r7, #0x88]
 80169f0: f001 f97a    	bl	0x8017ce8 <z_reset_time_slice> @ imm = #0x12f4
; 		update_metairq_preempt(thread);
 80169f4: f8d7 0088    	ldr.w	r0, [r7, #0x88]
 80169f8: f011 fed5    	bl	0x80287a6 <update_metairq_preempt> @ imm = #0x11daa
; 		_kernel.ready_q.cache = thread;
 80169fc: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x8016aac <z_impl_k_thread_suspend+0x244>
 80169fe: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8016a02: 6213         	str	r3, [r2, #0x20]
; }
 8016a04: e005         	b	0x8016a12 <z_impl_k_thread_suspend+0x1aa> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016a06: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8016aac <z_impl_k_thread_suspend+0x244>
 8016a08: 689b         	ldr	r3, [r3, #0x8]
 8016a0a: 673b         	str	r3, [r7, #0x70]
; 	return ret;
 8016a0c: 6f3b         	ldr	r3, [r7, #0x70]
; 		_kernel.ready_q.cache = arch_current_thread();
 8016a0e: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x8016aac <z_impl_k_thread_suspend+0x244>
 8016a10: 6213         	str	r3, [r2, #0x20]
; }
 8016a12: bf00         	nop
 8016a14: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8016ab0 <z_impl_k_thread_suspend+0x248>
 8016a16: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 8016a1a: 693b         	ldr	r3, [r7, #0x10]
 8016a1c: 60bb         	str	r3, [r7, #0x8]
 8016a1e: f8d7 30a4    	ldr.w	r3, [r7, #0xa4]
 8016a22: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; }
 8016a26: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8016a28: 68bb         	ldr	r3, [r7, #0x8]
 8016a2a: 4618         	mov	r0, r3
 8016a2c: f011 fe2d    	bl	0x802868a <z_swap_irqlock> @ imm = #0x11c5a
 8016a30: e039         	b	0x8016aa6 <z_impl_k_thread_suspend+0x23e> @ imm = #0x72
; 	(void)z_abort_thread_timeout(thread);
 8016a32: 6878         	ldr	r0, [r7, #0x4]
 8016a34: f011 fce5    	bl	0x8028402 <z_abort_thread_timeout> @ imm = #0x119ca
 8016a38: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8016ab0 <z_impl_k_thread_suspend+0x248>
 8016a3a: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016a3c: f3ef 8311    	mrs	r3, basepri
 8016a40: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 8016a42: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 8016a44: 63bb         	str	r3, [r7, #0x38]
 8016a46: 2310         	movs	r3, #0x10
 8016a48: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016a4a: 6b7b         	ldr	r3, [r7, #0x34]
 8016a4c: f383 8812    	msr	basepri_max, r3
; }
 8016a50: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016a52: f3bf 8f6f    	isb	sy
; }
 8016a56: bf00         	nop
; 	return key;
 8016a58: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 8016a5a: 617b         	str	r3, [r7, #0x14]
 8016a5c: 6c3b         	ldr	r3, [r7, #0x40]
 8016a5e: 633b         	str	r3, [r7, #0x30]
; }
 8016a60: bf00         	nop
 8016a62: 6c3b         	ldr	r3, [r7, #0x40]
 8016a64: 62fb         	str	r3, [r7, #0x2c]
; }
 8016a66: bf00         	nop
; 	return k;
 8016a68: 697b         	ldr	r3, [r7, #0x14]
 8016a6a: 61fb         	str	r3, [r7, #0x1c]
; 	if ((thread->base.thread_state & _THREAD_SUSPENDED) != 0U) {
 8016a6c: 687b         	ldr	r3, [r7, #0x4]
 8016a6e: 7b5b         	ldrb	r3, [r3, #0xd]
 8016a70: f003 0310    	and	r3, r3, #0x10
 8016a74: 2b00         	cmp	r3, #0x0
 8016a76: d011         	beq	0x8016a9c <z_impl_k_thread_suspend+0x234> @ imm = #0x22
 8016a78: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8016ab0 <z_impl_k_thread_suspend+0x248>
 8016a7a: 62bb         	str	r3, [r7, #0x28]
 8016a7c: 69fb         	ldr	r3, [r7, #0x1c]
 8016a7e: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8016a80: 69bb         	ldr	r3, [r7, #0x18]
 8016a82: 627b         	str	r3, [r7, #0x24]
 8016a84: 6a7b         	ldr	r3, [r7, #0x24]
 8016a86: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016a88: 6a3b         	ldr	r3, [r7, #0x20]
 8016a8a: f383 8811    	msr	basepri, r3
; }
 8016a8e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016a90: f3bf 8f6f    	isb	sy
; }
 8016a94: bf00         	nop
; }
 8016a96: bf00         	nop
; }
 8016a98: bf00         	nop
; 		return;
 8016a9a: e004         	b	0x8016aa6 <z_impl_k_thread_suspend+0x23e> @ imm = #0x8
; 	z_thread_halt(thread, key, false);
 8016a9c: 2200         	movs	r2, #0x0
 8016a9e: 69f9         	ldr	r1, [r7, #0x1c]
 8016aa0: 6878         	ldr	r0, [r7, #0x4]
 8016aa2: f7ff fe5b    	bl	0x801675c <z_thread_halt> @ imm = #-0x34a
; }
 8016aa6: 37b0         	adds	r7, #0xb0
 8016aa8: 46bd         	mov	sp, r7
 8016aaa: bd80         	pop	{r7, pc}

08016aac <$d>:
 8016aac: 60 20 00 24  	.word	0x24002060
 8016ab0: d8 32 00 24  	.word	0x240032d8
 8016ab4: 84 20 00 24  	.word	0x24002084

08016ab8 <z_impl_k_thread_resume>:
; {
 8016ab8: b580         	push	{r7, lr}
 8016aba: b08e         	sub	sp, #0x38
 8016abc: af00         	add	r7, sp, #0x0
 8016abe: 6078         	str	r0, [r7, #0x4]
 8016ac0: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8016b44 <z_impl_k_thread_resume+0x8c>
 8016ac2: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016ac4: f3ef 8311    	mrs	r3, basepri
 8016ac8: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8016aca: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 8016acc: 62fb         	str	r3, [r7, #0x2c]
 8016ace: 2310         	movs	r3, #0x10
 8016ad0: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016ad2: 6abb         	ldr	r3, [r7, #0x28]
 8016ad4: f383 8812    	msr	basepri_max, r3
; }
 8016ad8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016ada: f3bf 8f6f    	isb	sy
; }
 8016ade: bf00         	nop
; 	return key;
 8016ae0: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 8016ae2: 60bb         	str	r3, [r7, #0x8]
 8016ae4: 6b7b         	ldr	r3, [r7, #0x34]
 8016ae6: 627b         	str	r3, [r7, #0x24]
; }
 8016ae8: bf00         	nop
 8016aea: 6b7b         	ldr	r3, [r7, #0x34]
 8016aec: 623b         	str	r3, [r7, #0x20]
; }
 8016aee: bf00         	nop
; 	return k;
 8016af0: 68bb         	ldr	r3, [r7, #0x8]
 8016af2: 613b         	str	r3, [r7, #0x10]
; 	if (!z_is_thread_suspended(thread)) {
 8016af4: 6878         	ldr	r0, [r7, #0x4]
 8016af6: f011 fcae    	bl	0x8028456 <z_is_thread_suspended> @ imm = #0x1195c
 8016afa: 4603         	mov	r3, r0
 8016afc: f083 0301    	eor	r3, r3, #0x1
 8016b00: b2db         	uxtb	r3, r3
 8016b02: 2b00         	cmp	r3, #0x0
 8016b04: d010         	beq	0x8016b28 <z_impl_k_thread_resume+0x70> @ imm = #0x20
 8016b06: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8016b44 <z_impl_k_thread_resume+0x8c>
 8016b08: 61fb         	str	r3, [r7, #0x1c]
 8016b0a: 693b         	ldr	r3, [r7, #0x10]
 8016b0c: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8016b0e: 68fb         	ldr	r3, [r7, #0xc]
 8016b10: 61bb         	str	r3, [r7, #0x18]
 8016b12: 69bb         	ldr	r3, [r7, #0x18]
 8016b14: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016b16: 697b         	ldr	r3, [r7, #0x14]
 8016b18: f383 8811    	msr	basepri, r3
; }
 8016b1c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016b1e: f3bf 8f6f    	isb	sy
; }
 8016b22: bf00         	nop
; }
 8016b24: bf00         	nop
; }
 8016b26: e009         	b	0x8016b3c <z_impl_k_thread_resume+0x84> @ imm = #0x12
; 	z_mark_thread_as_not_suspended(thread);
 8016b28: 6878         	ldr	r0, [r7, #0x4]
 8016b2a: f011 fd28    	bl	0x802857e <z_mark_thread_as_not_suspended> @ imm = #0x11a50
; 	ready_thread(thread);
 8016b2e: 6878         	ldr	r0, [r7, #0x4]
 8016b30: f7ff fc94    	bl	0x801645c <ready_thread> @ imm = #-0x6d8
; 	z_reschedule(&_sched_spinlock, key);
 8016b34: 6939         	ldr	r1, [r7, #0x10]
 8016b36: 4803         	ldr	r0, [pc, #0xc]          @ 0x8016b44 <z_impl_k_thread_resume+0x8c>
 8016b38: f011 ff10    	bl	0x802895c <z_reschedule> @ imm = #0x11e20
; }
 8016b3c: 3738         	adds	r7, #0x38
 8016b3e: 46bd         	mov	sp, r7
 8016b40: bd80         	pop	{r7, pc}
 8016b42: bf00         	nop

08016b44 <$d>:
 8016b44: d8 32 00 24  	.word	0x240032d8

08016b48 <unready_thread>:
; {
 8016b48: b580         	push	{r7, lr}
 8016b4a: b094         	sub	sp, #0x50
 8016b4c: af00         	add	r7, sp, #0x0
 8016b4e: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 8016b50: 6878         	ldr	r0, [r7, #0x4]
 8016b52: f011 fcf6    	bl	0x8028542 <z_is_thread_queued> @ imm = #0x119ec
 8016b56: 4603         	mov	r3, r0
 8016b58: 2b00         	cmp	r3, #0x0
 8016b5a: d01d         	beq	0x8016b98 <unready_thread+0x50> @ imm = #0x3a
 8016b5c: 687b         	ldr	r3, [r7, #0x4]
 8016b5e: 64fb         	str	r3, [r7, #0x4c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 8016b60: 6cfb         	ldr	r3, [r7, #0x4c]
 8016b62: 7b5b         	ldrb	r3, [r3, #0xd]
 8016b64: f003 037f    	and	r3, r3, #0x7f
 8016b68: b2da         	uxtb	r2, r3
 8016b6a: 6cfb         	ldr	r3, [r7, #0x4c]
 8016b6c: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8016b6e: 6cf8         	ldr	r0, [r7, #0x4c]
 8016b70: f011 fdd2    	bl	0x8028718 <should_queue_thread> @ imm = #0x11ba4
 8016b74: 4603         	mov	r3, r0
 8016b76: 2b00         	cmp	r3, #0x0
 8016b78: d00d         	beq	0x8016b96 <unready_thread+0x4e> @ imm = #0x1a
 8016b7a: 6cfb         	ldr	r3, [r7, #0x4c]
 8016b7c: 64bb         	str	r3, [r7, #0x48]
 8016b7e: 6cbb         	ldr	r3, [r7, #0x48]
 8016b80: 647b         	str	r3, [r7, #0x44]
; 	return &_kernel.ready_q.runq;
 8016b82: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8016c7c <unready_thread+0x134>
 8016b84: 643b         	str	r3, [r7, #0x40]
 8016b86: 6cbb         	ldr	r3, [r7, #0x48]
 8016b88: 63fb         	str	r3, [r7, #0x3c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8016b8a: 6bfb         	ldr	r3, [r7, #0x3c]
 8016b8c: 4618         	mov	r0, r3
 8016b8e: f011 fbf8    	bl	0x8028382 <sys_dlist_remove> @ imm = #0x117f0
; }
 8016b92: bf00         	nop
; }
 8016b94: bf00         	nop
; }
 8016b96: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016b98: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8016c80 <unready_thread+0x138>
 8016b9a: 689b         	ldr	r3, [r3, #0x8]
 8016b9c: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 8016b9e: 68bb         	ldr	r3, [r7, #0x8]
; 	update_cache(thread == arch_current_thread());
 8016ba0: 687a         	ldr	r2, [r7, #0x4]
 8016ba2: 429a         	cmp	r2, r3
 8016ba4: bf0c         	ite	eq
 8016ba6: 2301         	moveq	r3, #0x1
 8016ba8: 2300         	movne	r3, #0x0
 8016baa: b2db         	uxtb	r3, r3
 8016bac: 63bb         	str	r3, [r7, #0x38]
; 	return &_kernel.ready_q.runq;
 8016bae: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8016c7c <unready_thread+0x134>
 8016bb0: 637b         	str	r3, [r7, #0x34]
; 	struct k_thread *thread = NULL;
 8016bb2: 2300         	movs	r3, #0x0
 8016bb4: 633b         	str	r3, [r7, #0x30]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8016bb6: 6b78         	ldr	r0, [r7, #0x34]
 8016bb8: f011 fb76    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x116ec
 8016bbc: 62f8         	str	r0, [r7, #0x2c]
; 	if (n != NULL) {
 8016bbe: 6afb         	ldr	r3, [r7, #0x2c]
 8016bc0: 2b00         	cmp	r3, #0x0
 8016bc2: d001         	beq	0x8016bc8 <unready_thread+0x80> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8016bc4: 6afb         	ldr	r3, [r7, #0x2c]
 8016bc6: 633b         	str	r3, [r7, #0x30]
; 	return thread;
 8016bc8: 6b3b         	ldr	r3, [r7, #0x30]
; 	return _priq_run_best(curr_cpu_runq());
 8016bca: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8016bcc: 62bb         	str	r3, [r7, #0x28]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8016bce: 6abb         	ldr	r3, [r7, #0x28]
 8016bd0: 2b00         	cmp	r3, #0x0
 8016bd2: d102         	bne	0x8016bda <unready_thread+0x92> @ imm = #0x4
 8016bd4: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8016c80 <unready_thread+0x138>
 8016bd6: 68db         	ldr	r3, [r3, #0xc]
 8016bd8: e000         	b	0x8016bdc <unready_thread+0x94> @ imm = #0x0
 8016bda: 6abb         	ldr	r3, [r7, #0x28]
; 	struct k_thread *thread = next_up();
 8016bdc: 627b         	str	r3, [r7, #0x24]
 8016bde: 6a7b         	ldr	r3, [r7, #0x24]
 8016be0: 623b         	str	r3, [r7, #0x20]
 8016be2: 6bbb         	ldr	r3, [r7, #0x38]
 8016be4: 61fb         	str	r3, [r7, #0x1c]
; 	if (preempt_ok != 0) {
 8016be6: 69fb         	ldr	r3, [r7, #0x1c]
 8016be8: 2b00         	cmp	r3, #0x0
 8016bea: d001         	beq	0x8016bf0 <unready_thread+0xa8> @ imm = #0x2
; 		return true;
 8016bec: 2301         	movs	r3, #0x1
 8016bee: e026         	b	0x8016c3e <unready_thread+0xf6> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016bf0: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8016c80 <unready_thread+0x138>
 8016bf2: 689b         	ldr	r3, [r3, #0x8]
 8016bf4: 61bb         	str	r3, [r7, #0x18]
; 	return ret;
 8016bf6: 69bb         	ldr	r3, [r7, #0x18]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8016bf8: 4618         	mov	r0, r3
 8016bfa: f011 fc3f    	bl	0x802847c <z_is_thread_prevented_from_running> @ imm = #0x1187e
 8016bfe: 4603         	mov	r3, r0
 8016c00: 2b00         	cmp	r3, #0x0
 8016c02: d001         	beq	0x8016c08 <unready_thread+0xc0> @ imm = #0x2
; 		return true;
 8016c04: 2301         	movs	r3, #0x1
 8016c06: e01a         	b	0x8016c3e <unready_thread+0xf6> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016c08: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8016c80 <unready_thread+0x138>
 8016c0a: 689b         	ldr	r3, [r3, #0x8]
 8016c0c: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 8016c0e: 697b         	ldr	r3, [r7, #0x14]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 8016c10: 4618         	mov	r0, r3
 8016c12: f011 fc04    	bl	0x802841e <thread_is_preemptible> @ imm = #0x11808
 8016c16: 4603         	mov	r3, r0
 8016c18: 2b00         	cmp	r3, #0x0
 8016c1a: d105         	bne	0x8016c28 <unready_thread+0xe0> @ imm = #0xa
 8016c1c: 6a38         	ldr	r0, [r7, #0x20]
 8016c1e: f011 fc0f    	bl	0x8028440 <thread_is_metairq> @ imm = #0x1181e
 8016c22: 4603         	mov	r3, r0
 8016c24: 2b00         	cmp	r3, #0x0
 8016c26: d001         	beq	0x8016c2c <unready_thread+0xe4> @ imm = #0x2
; 		return true;
 8016c28: 2301         	movs	r3, #0x1
 8016c2a: e008         	b	0x8016c3e <unready_thread+0xf6> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8016c2c: 6a38         	ldr	r0, [r7, #0x20]
 8016c2e: f011 fc3a    	bl	0x80284a6 <z_is_thread_timeout_active> @ imm = #0x11874
 8016c32: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8016c34: 2b00         	cmp	r3, #0x0
 8016c36: d001         	beq	0x8016c3c <unready_thread+0xf4> @ imm = #0x2
; 		return true;
 8016c38: 2301         	movs	r3, #0x1
 8016c3a: e000         	b	0x8016c3e <unready_thread+0xf6> @ imm = #0x0
; 	return false;
 8016c3c: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8016c3e: 2b00         	cmp	r3, #0x0
 8016c40: d010         	beq	0x8016c64 <unready_thread+0x11c> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016c42: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8016c80 <unready_thread+0x138>
 8016c44: 689b         	ldr	r3, [r3, #0x8]
 8016c46: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 8016c48: 693b         	ldr	r3, [r7, #0x10]
; 		if (thread != arch_current_thread()) {
 8016c4a: 6a7a         	ldr	r2, [r7, #0x24]
 8016c4c: 429a         	cmp	r2, r3
 8016c4e: d002         	beq	0x8016c56 <unready_thread+0x10e> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8016c50: 6a78         	ldr	r0, [r7, #0x24]
 8016c52: f001 f849    	bl	0x8017ce8 <z_reset_time_slice> @ imm = #0x1092
; 		update_metairq_preempt(thread);
 8016c56: 6a78         	ldr	r0, [r7, #0x24]
 8016c58: f011 fda5    	bl	0x80287a6 <update_metairq_preempt> @ imm = #0x11b4a
; 		_kernel.ready_q.cache = thread;
 8016c5c: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8016c80 <unready_thread+0x138>
 8016c5e: 6a7b         	ldr	r3, [r7, #0x24]
 8016c60: 6213         	str	r3, [r2, #0x20]
; }
 8016c62: e005         	b	0x8016c70 <unready_thread+0x128> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016c64: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8016c80 <unready_thread+0x138>
 8016c66: 689b         	ldr	r3, [r3, #0x8]
 8016c68: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8016c6a: 68fb         	ldr	r3, [r7, #0xc]
; 		_kernel.ready_q.cache = arch_current_thread();
 8016c6c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8016c80 <unready_thread+0x138>
 8016c6e: 6213         	str	r3, [r2, #0x20]
; }
 8016c70: bf00         	nop
; }
 8016c72: bf00         	nop
 8016c74: 3750         	adds	r7, #0x50
 8016c76: 46bd         	mov	sp, r7
 8016c78: bd80         	pop	{r7, pc}
 8016c7a: bf00         	nop

08016c7c <$d>:
 8016c7c: 84 20 00 24  	.word	0x24002084
 8016c80: 60 20 00 24  	.word	0x24002060

08016c84 <z_unpend_thread_no_timeout>:
; {
 8016c84: b580         	push	{r7, lr}
 8016c86: b090         	sub	sp, #0x40
 8016c88: af00         	add	r7, sp, #0x0
 8016c8a: 6078         	str	r0, [r7, #0x4]
; 	K_SPINLOCK(&_sched_spinlock) {
 8016c8c: 2300         	movs	r3, #0x0
 8016c8e: 61bb         	str	r3, [r7, #0x18]
 8016c90: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8016d0c <z_unpend_thread_no_timeout+0x88>
 8016c92: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016c94: f3ef 8311    	mrs	r3, basepri
 8016c98: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 8016c9a: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 8016c9c: 637b         	str	r3, [r7, #0x34]
 8016c9e: 2310         	movs	r3, #0x10
 8016ca0: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016ca2: 6b3b         	ldr	r3, [r7, #0x30]
 8016ca4: f383 8812    	msr	basepri_max, r3
; }
 8016ca8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016caa: f3bf 8f6f    	isb	sy
; }
 8016cae: bf00         	nop
; 	return key;
 8016cb0: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 8016cb2: 60fb         	str	r3, [r7, #0xc]
 8016cb4: 6bfb         	ldr	r3, [r7, #0x3c]
 8016cb6: 62fb         	str	r3, [r7, #0x2c]
; }
 8016cb8: bf00         	nop
 8016cba: 6bfb         	ldr	r3, [r7, #0x3c]
 8016cbc: 62bb         	str	r3, [r7, #0x28]
; }
 8016cbe: bf00         	nop
; 	return k;
 8016cc0: 68fb         	ldr	r3, [r7, #0xc]
 8016cc2: 617b         	str	r3, [r7, #0x14]
; 	K_SPINLOCK(&_sched_spinlock) {
 8016cc4: e019         	b	0x8016cfa <z_unpend_thread_no_timeout+0x76> @ imm = #0x32
; 		if (thread->base.pended_on != NULL) {
 8016cc6: 687b         	ldr	r3, [r7, #0x4]
 8016cc8: 689b         	ldr	r3, [r3, #0x8]
 8016cca: 2b00         	cmp	r3, #0x0
 8016ccc: d002         	beq	0x8016cd4 <z_unpend_thread_no_timeout+0x50> @ imm = #0x4
; 			unpend_thread_no_timeout(thread);
 8016cce: 6878         	ldr	r0, [r7, #0x4]
 8016cd0: f011 fcb4    	bl	0x802863c <unpend_thread_no_timeout> @ imm = #0x11968
 8016cd4: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8016d0c <z_unpend_thread_no_timeout+0x88>
 8016cd6: 627b         	str	r3, [r7, #0x24]
 8016cd8: 697b         	ldr	r3, [r7, #0x14]
 8016cda: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8016cdc: 693b         	ldr	r3, [r7, #0x10]
 8016cde: 623b         	str	r3, [r7, #0x20]
 8016ce0: 6a3b         	ldr	r3, [r7, #0x20]
 8016ce2: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016ce4: 69fb         	ldr	r3, [r7, #0x1c]
 8016ce6: f383 8811    	msr	basepri, r3
; }
 8016cea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016cec: f3bf 8f6f    	isb	sy
; }
 8016cf0: bf00         	nop
; }
 8016cf2: bf00         	nop
; }
 8016cf4: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 8016cf6: 2301         	movs	r3, #0x1
 8016cf8: 61bb         	str	r3, [r7, #0x18]
 8016cfa: 69bb         	ldr	r3, [r7, #0x18]
 8016cfc: 2b00         	cmp	r3, #0x0
 8016cfe: d0e2         	beq	0x8016cc6 <z_unpend_thread_no_timeout+0x42> @ imm = #-0x3c
; }
 8016d00: bf00         	nop
 8016d02: bf00         	nop
 8016d04: 3740         	adds	r7, #0x40
 8016d06: 46bd         	mov	sp, r7
 8016d08: bd80         	pop	{r7, pc}
 8016d0a: bf00         	nop

08016d0c <$d>:
 8016d0c: d8 32 00 24  	.word	0x240032d8

08016d10 <z_sched_wake_thread>:
; {
 8016d10: b580         	push	{r7, lr}
 8016d12: b090         	sub	sp, #0x40
 8016d14: af00         	add	r7, sp, #0x0
 8016d16: 6078         	str	r0, [r7, #0x4]
 8016d18: 460b         	mov	r3, r1
 8016d1a: 70fb         	strb	r3, [r7, #0x3]
; 	K_SPINLOCK(&_sched_spinlock) {
 8016d1c: 2300         	movs	r3, #0x0
 8016d1e: 617b         	str	r3, [r7, #0x14]
 8016d20: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8016e04 <z_sched_wake_thread+0xf4>
 8016d22: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016d24: f3ef 8311    	mrs	r3, basepri
 8016d28: 637b         	str	r3, [r7, #0x34]
;   return(result);
 8016d2a: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 8016d2c: 633b         	str	r3, [r7, #0x30]
 8016d2e: 2310         	movs	r3, #0x10
 8016d30: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016d32: 6afb         	ldr	r3, [r7, #0x2c]
 8016d34: f383 8812    	msr	basepri_max, r3
; }
 8016d38: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016d3a: f3bf 8f6f    	isb	sy
; }
 8016d3e: bf00         	nop
; 	return key;
 8016d40: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 8016d42: 60bb         	str	r3, [r7, #0x8]
 8016d44: 6bbb         	ldr	r3, [r7, #0x38]
 8016d46: 62bb         	str	r3, [r7, #0x28]
; }
 8016d48: bf00         	nop
 8016d4a: 6bbb         	ldr	r3, [r7, #0x38]
 8016d4c: 627b         	str	r3, [r7, #0x24]
; }
 8016d4e: bf00         	nop
; 	return k;
 8016d50: 68bb         	ldr	r3, [r7, #0x8]
 8016d52: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 8016d54: e04d         	b	0x8016df2 <z_sched_wake_thread+0xe2> @ imm = #0x9a
; 		bool killed = (thread->base.thread_state &
 8016d56: 687b         	ldr	r3, [r7, #0x4]
 8016d58: 7b5b         	ldrb	r3, [r3, #0xd]
 8016d5a: f003 0328    	and	r3, r3, #0x28
 8016d5e: 2b00         	cmp	r3, #0x0
 8016d60: bf14         	ite	ne
 8016d62: 2301         	movne	r3, #0x1
 8016d64: 2300         	moveq	r3, #0x0
 8016d66: f887 303f    	strb.w	r3, [r7, #0x3f]
; 		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
 8016d6a: 687b         	ldr	r3, [r7, #0x4]
 8016d6c: f893 307c    	ldrb.w	r3, [r3, #0x7c]
 8016d70: 2b00         	cmp	r3, #0x0
 8016d72: d004         	beq	0x8016d7e <z_sched_wake_thread+0x6e> @ imm = #0x8
 8016d74: 78fb         	ldrb	r3, [r7, #0x3]
 8016d76: 2b00         	cmp	r3, #0x0
 8016d78: d001         	beq	0x8016d7e <z_sched_wake_thread+0x6e> @ imm = #0x2
 8016d7a: 2301         	movs	r3, #0x1
 8016d7c: e000         	b	0x8016d80 <z_sched_wake_thread+0x70> @ imm = #0x0
 8016d7e: 2300         	movs	r3, #0x0
 8016d80: f887 303e    	strb.w	r3, [r7, #0x3e]
 8016d84: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 8016d88: f003 0301    	and	r3, r3, #0x1
 8016d8c: f887 303e    	strb.w	r3, [r7, #0x3e]
; 		thread->no_wake_on_timeout = false;
 8016d90: 687b         	ldr	r3, [r7, #0x4]
 8016d92: 2200         	movs	r2, #0x0
 8016d94: f883 207c    	strb.w	r2, [r3, #0x7c]
; 		if (do_nothing) {
 8016d98: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 8016d9c: 2b00         	cmp	r3, #0x0
 8016d9e: d114         	bne	0x8016dca <z_sched_wake_thread+0xba> @ imm = #0x28
; 		if (!killed) {
 8016da0: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8016da4: f083 0301    	eor	r3, r3, #0x1
 8016da8: b2db         	uxtb	r3, r3
 8016daa: 2b00         	cmp	r3, #0x0
 8016dac: d00e         	beq	0x8016dcc <z_sched_wake_thread+0xbc> @ imm = #0x1c
; 			if (thread->base.pended_on != NULL) {
 8016dae: 687b         	ldr	r3, [r7, #0x4]
 8016db0: 689b         	ldr	r3, [r3, #0x8]
 8016db2: 2b00         	cmp	r3, #0x0
 8016db4: d002         	beq	0x8016dbc <z_sched_wake_thread+0xac> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 8016db6: 6878         	ldr	r0, [r7, #0x4]
 8016db8: f011 fc40    	bl	0x802863c <unpend_thread_no_timeout> @ imm = #0x11880
; 			z_mark_thread_as_not_suspended(thread);
 8016dbc: 6878         	ldr	r0, [r7, #0x4]
 8016dbe: f011 fbde    	bl	0x802857e <z_mark_thread_as_not_suspended> @ imm = #0x117bc
; 			ready_thread(thread);
 8016dc2: 6878         	ldr	r0, [r7, #0x4]
 8016dc4: f7ff fb4a    	bl	0x801645c <ready_thread> @ imm = #-0x96c
 8016dc8: e000         	b	0x8016dcc <z_sched_wake_thread+0xbc> @ imm = #0x0
; 			continue;
 8016dca: bf00         	nop
 8016dcc: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8016e04 <z_sched_wake_thread+0xf4>
 8016dce: 623b         	str	r3, [r7, #0x20]
 8016dd0: 693b         	ldr	r3, [r7, #0x10]
 8016dd2: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8016dd4: 68fb         	ldr	r3, [r7, #0xc]
 8016dd6: 61fb         	str	r3, [r7, #0x1c]
 8016dd8: 69fb         	ldr	r3, [r7, #0x1c]
 8016dda: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016ddc: 69bb         	ldr	r3, [r7, #0x18]
 8016dde: f383 8811    	msr	basepri, r3
; }
 8016de2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016de4: f3bf 8f6f    	isb	sy
; }
 8016de8: bf00         	nop
; }
 8016dea: bf00         	nop
; }
 8016dec: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 8016dee: 2301         	movs	r3, #0x1
 8016df0: 617b         	str	r3, [r7, #0x14]
 8016df2: 697b         	ldr	r3, [r7, #0x14]
 8016df4: 2b00         	cmp	r3, #0x0
 8016df6: d0ae         	beq	0x8016d56 <z_sched_wake_thread+0x46> @ imm = #-0xa4
; }
 8016df8: bf00         	nop
 8016dfa: bf00         	nop
 8016dfc: 3740         	adds	r7, #0x40
 8016dfe: 46bd         	mov	sp, r7
 8016e00: bd80         	pop	{r7, pc}
 8016e02: bf00         	nop

08016e04 <$d>:
 8016e04: d8 32 00 24  	.word	0x240032d8

08016e08 <z_pend_curr>:
; {
 8016e08: b580         	push	{r7, lr}
 8016e0a: b092         	sub	sp, #0x48
 8016e0c: af00         	add	r7, sp, #0x0
 8016e0e: 60f8         	str	r0, [r7, #0xc]
 8016e10: 60b9         	str	r1, [r7, #0x8]
 8016e12: 607a         	str	r2, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016e14: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8016e88 <z_pend_curr+0x80>
 8016e16: 689b         	ldr	r3, [r3, #0x8]
 8016e18: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 8016e1a: 69fb         	ldr	r3, [r7, #0x1c]
; 	pending_current = arch_current_thread();
 8016e1c: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8016e8c <z_pend_curr+0x84>
 8016e1e: 6013         	str	r3, [r2]
 8016e20: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8016e90 <z_pend_curr+0x88>
 8016e22: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016e24: f3ef 8311    	mrs	r3, basepri
 8016e28: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8016e2a: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 8016e2c: 62fb         	str	r3, [r7, #0x2c]
 8016e2e: 2310         	movs	r3, #0x10
 8016e30: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016e32: 6abb         	ldr	r3, [r7, #0x28]
 8016e34: f383 8812    	msr	basepri_max, r3
; }
 8016e38: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016e3a: f3bf 8f6f    	isb	sy
; }
 8016e3e: bf00         	nop
; 	return key;
 8016e40: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 8016e42: 61bb         	str	r3, [r7, #0x18]
 8016e44: 6b7b         	ldr	r3, [r7, #0x34]
 8016e46: 627b         	str	r3, [r7, #0x24]
; }
 8016e48: bf00         	nop
 8016e4a: 6b7b         	ldr	r3, [r7, #0x34]
 8016e4c: 623b         	str	r3, [r7, #0x20]
; }
 8016e4e: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016e50: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8016e88 <z_pend_curr+0x80>
 8016e52: 689b         	ldr	r3, [r3, #0x8]
 8016e54: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 8016e56: 6bb8         	ldr	r0, [r7, #0x38]
; 	pend_locked(arch_current_thread(), wait_q, timeout);
 8016e58: e9d7 2314    	ldrd	r2, r3, [r7, #80]
 8016e5c: 6879         	ldr	r1, [r7, #0x4]
 8016e5e: f011 fd24    	bl	0x80288aa <pend_locked> @ imm = #0x11a48
 8016e62: 68fb         	ldr	r3, [r7, #0xc]
 8016e64: 63fb         	str	r3, [r7, #0x3c]
; }
 8016e66: bf00         	nop
 8016e68: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8016e90 <z_pend_curr+0x88>
 8016e6a: 647b         	str	r3, [r7, #0x44]
 8016e6c: 68bb         	ldr	r3, [r7, #0x8]
 8016e6e: 617b         	str	r3, [r7, #0x14]
 8016e70: 6c7b         	ldr	r3, [r7, #0x44]
 8016e72: 643b         	str	r3, [r7, #0x40]
 8016e74: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8016e76: 697b         	ldr	r3, [r7, #0x14]
 8016e78: 4618         	mov	r0, r3
 8016e7a: f011 fc06    	bl	0x802868a <z_swap_irqlock> @ imm = #0x1180c
 8016e7e: 4603         	mov	r3, r0
; }
 8016e80: 4618         	mov	r0, r3
 8016e82: 3748         	adds	r7, #0x48
 8016e84: 46bd         	mov	sp, r7
 8016e86: bd80         	pop	{r7, pc}

08016e88 <$d>:
 8016e88: 60 20 00 24  	.word	0x24002060
 8016e8c: e4 32 00 24  	.word	0x240032e4
 8016e90: d8 32 00 24  	.word	0x240032d8

08016e94 <z_thread_prio_set>:
; {
 8016e94: b580         	push	{r7, lr}
 8016e96: b0a8         	sub	sp, #0xa0
 8016e98: af00         	add	r7, sp, #0x0
 8016e9a: 6078         	str	r0, [r7, #0x4]
 8016e9c: 6039         	str	r1, [r7]
; 	bool need_sched = 0;
 8016e9e: 2300         	movs	r3, #0x0
 8016ea0: f887 309f    	strb.w	r3, [r7, #0x9f]
; 	int old_prio = thread->base.prio;
 8016ea4: 687b         	ldr	r3, [r7, #0x4]
 8016ea6: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8016eaa: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	K_SPINLOCK(&_sched_spinlock) {
 8016eae: 2300         	movs	r3, #0x0
 8016eb0: 617b         	str	r3, [r7, #0x14]
 8016eb2: 4b95         	ldr	r3, [pc, #0x254]        @ 0x8017108 <z_thread_prio_set+0x274>
 8016eb4: f8c7 3094    	str.w	r3, [r7, #0x94]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016eb8: f3ef 8311    	mrs	r3, basepri
 8016ebc: f8c7 3090    	str.w	r3, [r7, #0x90]
;   return(result);
 8016ec0: f8d7 3090    	ldr.w	r3, [r7, #0x90]
; 	key = __get_BASEPRI();
 8016ec4: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8016ec8: 2310         	movs	r3, #0x10
 8016eca: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016ece: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8016ed2: f383 8812    	msr	basepri_max, r3
; }
 8016ed6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016ed8: f3bf 8f6f    	isb	sy
; }
 8016edc: bf00         	nop
; 	return key;
 8016ede: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	k.key = arch_irq_lock();
 8016ee2: 60bb         	str	r3, [r7, #0x8]
 8016ee4: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 8016ee8: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 8016eec: bf00         	nop
 8016eee: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 8016ef2: f8c7 3080    	str.w	r3, [r7, #0x80]
; }
 8016ef6: bf00         	nop
; 	return k;
 8016ef8: 68bb         	ldr	r3, [r7, #0x8]
 8016efa: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 8016efc: e0fa         	b	0x80170f4 <z_thread_prio_set+0x260> @ imm = #0x1f4
; 		need_sched = z_is_thread_ready(thread);
 8016efe: 6878         	ldr	r0, [r7, #0x4]
 8016f00: f011 faea    	bl	0x80284d8 <z_is_thread_ready> @ imm = #0x115d4
 8016f04: 4603         	mov	r3, r0
 8016f06: f887 309f    	strb.w	r3, [r7, #0x9f]
; 		if (need_sched) {
 8016f0a: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 8016f0e: 2b00         	cmp	r3, #0x0
 8016f10: f000 80d9    	beq.w	0x80170c6 <z_thread_prio_set+0x232> @ imm = #0x1b2
 8016f14: 687b         	ldr	r3, [r7, #0x4]
 8016f16: 667b         	str	r3, [r7, #0x64]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 8016f18: 6e7b         	ldr	r3, [r7, #0x64]
 8016f1a: 7b5b         	ldrb	r3, [r3, #0xd]
 8016f1c: f003 037f    	and	r3, r3, #0x7f
 8016f20: b2da         	uxtb	r2, r3
 8016f22: 6e7b         	ldr	r3, [r7, #0x64]
 8016f24: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8016f26: 6e78         	ldr	r0, [r7, #0x64]
 8016f28: f011 fbf6    	bl	0x8028718 <should_queue_thread> @ imm = #0x117ec
 8016f2c: 4603         	mov	r3, r0
 8016f2e: 2b00         	cmp	r3, #0x0
 8016f30: d00d         	beq	0x8016f4e <z_thread_prio_set+0xba> @ imm = #0x1a
 8016f32: 6e7b         	ldr	r3, [r7, #0x64]
 8016f34: 663b         	str	r3, [r7, #0x60]
 8016f36: 6e3b         	ldr	r3, [r7, #0x60]
 8016f38: 65fb         	str	r3, [r7, #0x5c]
; 	return &_kernel.ready_q.runq;
 8016f3a: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x801710c <z_thread_prio_set+0x278>
 8016f3c: 65bb         	str	r3, [r7, #0x58]
 8016f3e: 6e3b         	ldr	r3, [r7, #0x60]
 8016f40: 657b         	str	r3, [r7, #0x54]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8016f42: 6d7b         	ldr	r3, [r7, #0x54]
 8016f44: 4618         	mov	r0, r3
 8016f46: f011 fa1c    	bl	0x8028382 <sys_dlist_remove> @ imm = #0x11438
; }
 8016f4a: bf00         	nop
; }
 8016f4c: bf00         	nop
; }
 8016f4e: bf00         	nop
; 				thread->base.prio = prio;
 8016f50: 683b         	ldr	r3, [r7]
 8016f52: b25a         	sxtb	r2, r3
 8016f54: 687b         	ldr	r3, [r7, #0x4]
 8016f56: 739a         	strb	r2, [r3, #0xe]
 8016f58: 687b         	ldr	r3, [r7, #0x4]
 8016f5a: 67fb         	str	r3, [r7, #0x7c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 8016f5c: 6ffb         	ldr	r3, [r7, #0x7c]
 8016f5e: 7b5b         	ldrb	r3, [r3, #0xd]
 8016f60: f063 037f    	orn	r3, r3, #0x7f
 8016f64: b2da         	uxtb	r2, r3
 8016f66: 6ffb         	ldr	r3, [r7, #0x7c]
 8016f68: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8016f6a: 6ff8         	ldr	r0, [r7, #0x7c]
 8016f6c: f011 fbd4    	bl	0x8028718 <should_queue_thread> @ imm = #0x117a8
 8016f70: 4603         	mov	r3, r0
 8016f72: 2b00         	cmp	r3, #0x0
 8016f74: d042         	beq	0x8016ffc <z_thread_prio_set+0x168> @ imm = #0x84
 8016f76: 6ffb         	ldr	r3, [r7, #0x7c]
 8016f78: 67bb         	str	r3, [r7, #0x78]
 8016f7a: 6fbb         	ldr	r3, [r7, #0x78]
 8016f7c: 677b         	str	r3, [r7, #0x74]
; 	return &_kernel.ready_q.runq;
 8016f7e: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x801710c <z_thread_prio_set+0x278>
 8016f80: 673b         	str	r3, [r7, #0x70]
 8016f82: 6fbb         	ldr	r3, [r7, #0x78]
 8016f84: 66fb         	str	r3, [r7, #0x6c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8016f86: 6f38         	ldr	r0, [r7, #0x70]
 8016f88: f011 f98e    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x1131c
 8016f8c: 4603         	mov	r3, r0
 8016f8e: 2b00         	cmp	r3, #0x0
 8016f90: d004         	beq	0x8016f9c <z_thread_prio_set+0x108> @ imm = #0x8
 8016f92: 6f38         	ldr	r0, [r7, #0x70]
 8016f94: f011 f988    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x11310
 8016f98: 4603         	mov	r3, r0
 8016f9a: e000         	b	0x8016f9e <z_thread_prio_set+0x10a> @ imm = #0x0
 8016f9c: 2300         	movs	r3, #0x0
 8016f9e: 66bb         	str	r3, [r7, #0x68]
 8016fa0: e023         	b	0x8016fea <z_thread_prio_set+0x156> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8016fa2: 6eb9         	ldr	r1, [r7, #0x68]
 8016fa4: 6ef8         	ldr	r0, [r7, #0x6c]
 8016fa6: f011 fb9b    	bl	0x80286e0 <z_sched_prio_cmp> @ imm = #0x11736
 8016faa: 4603         	mov	r3, r0
 8016fac: 2b00         	cmp	r3, #0x0
 8016fae: dd06         	ble	0x8016fbe <z_thread_prio_set+0x12a> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8016fb0: 6ebb         	ldr	r3, [r7, #0x68]
 8016fb2: 6efa         	ldr	r2, [r7, #0x6c]
 8016fb4: 4611         	mov	r1, r2
 8016fb6: 4618         	mov	r0, r3
 8016fb8: f011 f9c9    	bl	0x802834e <sys_dlist_insert> @ imm = #0x11392
; 			return;
 8016fbc: e01d         	b	0x8016ffa <z_thread_prio_set+0x166> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8016fbe: 6ebb         	ldr	r3, [r7, #0x68]
 8016fc0: 2b00         	cmp	r3, #0x0
 8016fc2: d010         	beq	0x8016fe6 <z_thread_prio_set+0x152> @ imm = #0x20
 8016fc4: 6ebb         	ldr	r3, [r7, #0x68]
 8016fc6: 4619         	mov	r1, r3
 8016fc8: 6f38         	ldr	r0, [r7, #0x70]
 8016fca: f011 f993    	bl	0x80282f4 <sys_dlist_peek_next> @ imm = #0x11326
 8016fce: 4603         	mov	r3, r0
 8016fd0: 2b00         	cmp	r3, #0x0
 8016fd2: d006         	beq	0x8016fe2 <z_thread_prio_set+0x14e> @ imm = #0xc
 8016fd4: 6ebb         	ldr	r3, [r7, #0x68]
 8016fd6: 4619         	mov	r1, r3
 8016fd8: 6f38         	ldr	r0, [r7, #0x70]
 8016fda: f011 f98b    	bl	0x80282f4 <sys_dlist_peek_next> @ imm = #0x11316
 8016fde: 4603         	mov	r3, r0
 8016fe0: e002         	b	0x8016fe8 <z_thread_prio_set+0x154> @ imm = #0x4
 8016fe2: 2300         	movs	r3, #0x0
 8016fe4: e000         	b	0x8016fe8 <z_thread_prio_set+0x154> @ imm = #0x0
 8016fe6: 2300         	movs	r3, #0x0
 8016fe8: 66bb         	str	r3, [r7, #0x68]
 8016fea: 6ebb         	ldr	r3, [r7, #0x68]
 8016fec: 2b00         	cmp	r3, #0x0
 8016fee: d1d8         	bne	0x8016fa2 <z_thread_prio_set+0x10e> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8016ff0: 6efb         	ldr	r3, [r7, #0x6c]
 8016ff2: 4619         	mov	r1, r3
 8016ff4: 6f38         	ldr	r0, [r7, #0x70]
 8016ff6: f011 f990    	bl	0x802831a <sys_dlist_append> @ imm = #0x11320
; }
 8016ffa: bf00         	nop
; }
 8016ffc: bf00         	nop
 8016ffe: 2301         	movs	r3, #0x1
 8017000: 653b         	str	r3, [r7, #0x50]
; 	return &_kernel.ready_q.runq;
 8017002: 4b42         	ldr	r3, [pc, #0x108]        @ 0x801710c <z_thread_prio_set+0x278>
 8017004: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 8017006: 2300         	movs	r3, #0x0
 8017008: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 801700a: 6cf8         	ldr	r0, [r7, #0x4c]
 801700c: f011 f94c    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x11298
 8017010: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8017012: 6c7b         	ldr	r3, [r7, #0x44]
 8017014: 2b00         	cmp	r3, #0x0
 8017016: d001         	beq	0x801701c <z_thread_prio_set+0x188> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8017018: 6c7b         	ldr	r3, [r7, #0x44]
 801701a: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 801701c: 6cbb         	ldr	r3, [r7, #0x48]
; 	return _priq_run_best(curr_cpu_runq());
 801701e: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8017020: 643b         	str	r3, [r7, #0x40]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8017022: 6c3b         	ldr	r3, [r7, #0x40]
 8017024: 2b00         	cmp	r3, #0x0
 8017026: d102         	bne	0x801702e <z_thread_prio_set+0x19a> @ imm = #0x4
 8017028: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8017110 <z_thread_prio_set+0x27c>
 801702a: 68db         	ldr	r3, [r3, #0xc]
 801702c: e000         	b	0x8017030 <z_thread_prio_set+0x19c> @ imm = #0x0
 801702e: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *thread = next_up();
 8017030: 63fb         	str	r3, [r7, #0x3c]
 8017032: 6bfb         	ldr	r3, [r7, #0x3c]
 8017034: 63bb         	str	r3, [r7, #0x38]
 8017036: 6d3b         	ldr	r3, [r7, #0x50]
 8017038: 637b         	str	r3, [r7, #0x34]
; 	if (preempt_ok != 0) {
 801703a: 6b7b         	ldr	r3, [r7, #0x34]
 801703c: 2b00         	cmp	r3, #0x0
 801703e: d001         	beq	0x8017044 <z_thread_prio_set+0x1b0> @ imm = #0x2
; 		return true;
 8017040: 2301         	movs	r3, #0x1
 8017042: e026         	b	0x8017092 <z_thread_prio_set+0x1fe> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017044: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8017110 <z_thread_prio_set+0x27c>
 8017046: 689b         	ldr	r3, [r3, #0x8]
 8017048: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 801704a: 6b3b         	ldr	r3, [r7, #0x30]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 801704c: 4618         	mov	r0, r3
 801704e: f011 fa15    	bl	0x802847c <z_is_thread_prevented_from_running> @ imm = #0x1142a
 8017052: 4603         	mov	r3, r0
 8017054: 2b00         	cmp	r3, #0x0
 8017056: d001         	beq	0x801705c <z_thread_prio_set+0x1c8> @ imm = #0x2
; 		return true;
 8017058: 2301         	movs	r3, #0x1
 801705a: e01a         	b	0x8017092 <z_thread_prio_set+0x1fe> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801705c: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8017110 <z_thread_prio_set+0x27c>
 801705e: 689b         	ldr	r3, [r3, #0x8]
 8017060: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 8017062: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 8017064: 4618         	mov	r0, r3
 8017066: f011 f9da    	bl	0x802841e <thread_is_preemptible> @ imm = #0x113b4
 801706a: 4603         	mov	r3, r0
 801706c: 2b00         	cmp	r3, #0x0
 801706e: d105         	bne	0x801707c <z_thread_prio_set+0x1e8> @ imm = #0xa
 8017070: 6bb8         	ldr	r0, [r7, #0x38]
 8017072: f011 f9e5    	bl	0x8028440 <thread_is_metairq> @ imm = #0x113ca
 8017076: 4603         	mov	r3, r0
 8017078: 2b00         	cmp	r3, #0x0
 801707a: d001         	beq	0x8017080 <z_thread_prio_set+0x1ec> @ imm = #0x2
; 		return true;
 801707c: 2301         	movs	r3, #0x1
 801707e: e008         	b	0x8017092 <z_thread_prio_set+0x1fe> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8017080: 6bb8         	ldr	r0, [r7, #0x38]
 8017082: f011 fa10    	bl	0x80284a6 <z_is_thread_timeout_active> @ imm = #0x11420
 8017086: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8017088: 2b00         	cmp	r3, #0x0
 801708a: d001         	beq	0x8017090 <z_thread_prio_set+0x1fc> @ imm = #0x2
; 		return true;
 801708c: 2301         	movs	r3, #0x1
 801708e: e000         	b	0x8017092 <z_thread_prio_set+0x1fe> @ imm = #0x0
; 	return false;
 8017090: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8017092: 2b00         	cmp	r3, #0x0
 8017094: d010         	beq	0x80170b8 <z_thread_prio_set+0x224> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017096: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8017110 <z_thread_prio_set+0x27c>
 8017098: 689b         	ldr	r3, [r3, #0x8]
 801709a: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 801709c: 6abb         	ldr	r3, [r7, #0x28]
; 		if (thread != arch_current_thread()) {
 801709e: 6bfa         	ldr	r2, [r7, #0x3c]
 80170a0: 429a         	cmp	r2, r3
 80170a2: d002         	beq	0x80170aa <z_thread_prio_set+0x216> @ imm = #0x4
; 			z_reset_time_slice(thread);
 80170a4: 6bf8         	ldr	r0, [r7, #0x3c]
 80170a6: f000 fe1f    	bl	0x8017ce8 <z_reset_time_slice> @ imm = #0xc3e
; 		update_metairq_preempt(thread);
 80170aa: 6bf8         	ldr	r0, [r7, #0x3c]
 80170ac: f011 fb7b    	bl	0x80287a6 <update_metairq_preempt> @ imm = #0x116f6
; 		_kernel.ready_q.cache = thread;
 80170b0: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x8017110 <z_thread_prio_set+0x27c>
 80170b2: 6bfb         	ldr	r3, [r7, #0x3c]
 80170b4: 6213         	str	r3, [r2, #0x20]
; }
 80170b6: e00a         	b	0x80170ce <z_thread_prio_set+0x23a> @ imm = #0x14
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80170b8: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8017110 <z_thread_prio_set+0x27c>
 80170ba: 689b         	ldr	r3, [r3, #0x8]
 80170bc: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 80170be: 6a7b         	ldr	r3, [r7, #0x24]
; 		_kernel.ready_q.cache = arch_current_thread();
 80170c0: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x8017110 <z_thread_prio_set+0x27c>
 80170c2: 6213         	str	r3, [r2, #0x20]
; }
 80170c4: e003         	b	0x80170ce <z_thread_prio_set+0x23a> @ imm = #0x6
; 			thread->base.prio = prio;
 80170c6: 683b         	ldr	r3, [r7]
 80170c8: b25a         	sxtb	r2, r3
 80170ca: 687b         	ldr	r3, [r7, #0x4]
 80170cc: 739a         	strb	r2, [r3, #0xe]
 80170ce: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8017108 <z_thread_prio_set+0x274>
 80170d0: 623b         	str	r3, [r7, #0x20]
 80170d2: 693b         	ldr	r3, [r7, #0x10]
 80170d4: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 80170d6: 68fb         	ldr	r3, [r7, #0xc]
 80170d8: 61fb         	str	r3, [r7, #0x1c]
 80170da: 69fb         	ldr	r3, [r7, #0x1c]
 80170dc: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80170de: 69bb         	ldr	r3, [r7, #0x18]
 80170e0: f383 8811    	msr	basepri, r3
; }
 80170e4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80170e6: f3bf 8f6f    	isb	sy
; }
 80170ea: bf00         	nop
; }
 80170ec: bf00         	nop
; }
 80170ee: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 80170f0: 2301         	movs	r3, #0x1
 80170f2: 617b         	str	r3, [r7, #0x14]
 80170f4: 697b         	ldr	r3, [r7, #0x14]
 80170f6: 2b00         	cmp	r3, #0x0
 80170f8: f43f af01    	beq.w	0x8016efe <z_thread_prio_set+0x6a> @ imm = #-0x1fe
; 	return need_sched;
 80170fc: f897 309f    	ldrb.w	r3, [r7, #0x9f]
; }
 8017100: 4618         	mov	r0, r3
 8017102: 37a0         	adds	r7, #0xa0
 8017104: 46bd         	mov	sp, r7
 8017106: bd80         	pop	{r7, pc}

08017108 <$d>:
 8017108: d8 32 00 24  	.word	0x240032d8
 801710c: 84 20 00 24  	.word	0x24002084
 8017110: 60 20 00 24  	.word	0x24002060

08017114 <need_swap>:
; {
 8017114: b480         	push	{r7}
 8017116: b083         	sub	sp, #0xc
 8017118: af00         	add	r7, sp, #0x0
; 	new_thread = _kernel.ready_q.cache;
 801711a: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8017140 <need_swap+0x2c>
 801711c: 6a1b         	ldr	r3, [r3, #0x20]
 801711e: 607b         	str	r3, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017120: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8017140 <need_swap+0x2c>
 8017122: 689b         	ldr	r3, [r3, #0x8]
 8017124: 603b         	str	r3, [r7]
; 	return ret;
 8017126: 683b         	ldr	r3, [r7]
; 	return new_thread != arch_current_thread();
 8017128: 687a         	ldr	r2, [r7, #0x4]
 801712a: 429a         	cmp	r2, r3
 801712c: bf14         	ite	ne
 801712e: 2301         	movne	r3, #0x1
 8017130: 2300         	moveq	r3, #0x0
 8017132: b2db         	uxtb	r3, r3
; }
 8017134: 4618         	mov	r0, r3
 8017136: 370c         	adds	r7, #0xc
 8017138: 46bd         	mov	sp, r7
 801713a: f85d 7b04    	ldr	r7, [sp], #4
 801713e: 4770         	bx	lr

08017140 <$d>:
 8017140: 60 20 00 24  	.word	0x24002060

08017144 <k_sched_lock>:
; {
 8017144: b580         	push	{r7, lr}
 8017146: b08e         	sub	sp, #0x38
 8017148: af00         	add	r7, sp, #0x0
; 	K_SPINLOCK(&_sched_spinlock) {
 801714a: 2300         	movs	r3, #0x0
 801714c: 613b         	str	r3, [r7, #0x10]
 801714e: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80171c0 <k_sched_lock+0x7c>
 8017150: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8017152: f3ef 8311    	mrs	r3, basepri
 8017156: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8017158: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 801715a: 62fb         	str	r3, [r7, #0x2c]
 801715c: 2310         	movs	r3, #0x10
 801715e: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8017160: 6abb         	ldr	r3, [r7, #0x28]
 8017162: f383 8812    	msr	basepri_max, r3
; }
 8017166: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017168: f3bf 8f6f    	isb	sy
; }
 801716c: bf00         	nop
; 	return key;
 801716e: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 8017170: 607b         	str	r3, [r7, #0x4]
 8017172: 6b7b         	ldr	r3, [r7, #0x34]
 8017174: 627b         	str	r3, [r7, #0x24]
; }
 8017176: bf00         	nop
 8017178: 6b7b         	ldr	r3, [r7, #0x34]
 801717a: 623b         	str	r3, [r7, #0x20]
; }
 801717c: bf00         	nop
; 	return k;
 801717e: 687b         	ldr	r3, [r7, #0x4]
 8017180: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&_sched_spinlock) {
 8017182: e014         	b	0x80171ae <k_sched_lock+0x6a> @ imm = #0x28
; 		z_sched_lock();
 8017184: f7ff f844    	bl	0x8016210 <z_sched_lock> @ imm = #-0xf78
 8017188: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80171c0 <k_sched_lock+0x7c>
 801718a: 61fb         	str	r3, [r7, #0x1c]
 801718c: 68fb         	ldr	r3, [r7, #0xc]
 801718e: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8017190: 68bb         	ldr	r3, [r7, #0x8]
 8017192: 61bb         	str	r3, [r7, #0x18]
 8017194: 69bb         	ldr	r3, [r7, #0x18]
 8017196: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017198: 697b         	ldr	r3, [r7, #0x14]
 801719a: f383 8811    	msr	basepri, r3
; }
 801719e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80171a0: f3bf 8f6f    	isb	sy
; }
 80171a4: bf00         	nop
; }
 80171a6: bf00         	nop
; }
 80171a8: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 80171aa: 2301         	movs	r3, #0x1
 80171ac: 613b         	str	r3, [r7, #0x10]
 80171ae: 693b         	ldr	r3, [r7, #0x10]
 80171b0: 2b00         	cmp	r3, #0x0
 80171b2: d0e7         	beq	0x8017184 <k_sched_lock+0x40> @ imm = #-0x32
; }
 80171b4: bf00         	nop
 80171b6: bf00         	nop
 80171b8: 3738         	adds	r7, #0x38
 80171ba: 46bd         	mov	sp, r7
 80171bc: bd80         	pop	{r7, pc}
 80171be: bf00         	nop

080171c0 <$d>:
 80171c0: d8 32 00 24  	.word	0x240032d8

080171c4 <k_sched_unlock>:
; {
 80171c4: b580         	push	{r7, lr}
 80171c6: b0a4         	sub	sp, #0x90
 80171c8: af06         	add	r7, sp, #0x18
; 	K_SPINLOCK(&_sched_spinlock) {
 80171ca: 2300         	movs	r3, #0x0
 80171cc: 60fb         	str	r3, [r7, #0xc]
 80171ce: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8017368 <k_sched_unlock+0x1a4>
 80171d0: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80171d2: f3ef 8311    	mrs	r3, basepri
 80171d6: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 80171d8: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 80171da: 667b         	str	r3, [r7, #0x64]
 80171dc: 2310         	movs	r3, #0x10
 80171de: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80171e0: 6e3b         	ldr	r3, [r7, #0x60]
 80171e2: f383 8812    	msr	basepri_max, r3
; }
 80171e6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80171e8: f3bf 8f6f    	isb	sy
; }
 80171ec: bf00         	nop
; 	return key;
 80171ee: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 80171f0: 603b         	str	r3, [r7]
 80171f2: 6efb         	ldr	r3, [r7, #0x6c]
 80171f4: 65fb         	str	r3, [r7, #0x5c]
; }
 80171f6: bf00         	nop
 80171f8: 6efb         	ldr	r3, [r7, #0x6c]
 80171fa: 65bb         	str	r3, [r7, #0x58]
; }
 80171fc: bf00         	nop
; 	return k;
 80171fe: 683b         	ldr	r3, [r7]
 8017200: 60bb         	str	r3, [r7, #0x8]
; 	K_SPINLOCK(&_sched_spinlock) {
 8017202: e07e         	b	0x8017302 <k_sched_unlock+0x13e> @ imm = #0xfc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017204: 4b59         	ldr	r3, [pc, #0x164]        @ 0x801736c <k_sched_unlock+0x1a8>
 8017206: 689b         	ldr	r3, [r3, #0x8]
 8017208: 61bb         	str	r3, [r7, #0x18]
; 	return ret;
 801720a: 69bb         	ldr	r3, [r7, #0x18]
; 		++arch_current_thread()->base.sched_locked;
 801720c: 7bda         	ldrb	r2, [r3, #0xf]
 801720e: 3201         	adds	r2, #0x1
 8017210: b2d2         	uxtb	r2, r2
 8017212: 73da         	strb	r2, [r3, #0xf]
 8017214: 2300         	movs	r3, #0x0
 8017216: 64bb         	str	r3, [r7, #0x48]
; 	return &_kernel.ready_q.runq;
 8017218: 4b55         	ldr	r3, [pc, #0x154]        @ 0x8017370 <k_sched_unlock+0x1ac>
 801721a: 647b         	str	r3, [r7, #0x44]
; 	struct k_thread *thread = NULL;
 801721c: 2300         	movs	r3, #0x0
 801721e: 643b         	str	r3, [r7, #0x40]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8017220: 6c78         	ldr	r0, [r7, #0x44]
 8017222: f011 f841    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x11082
 8017226: 63f8         	str	r0, [r7, #0x3c]
; 	if (n != NULL) {
 8017228: 6bfb         	ldr	r3, [r7, #0x3c]
 801722a: 2b00         	cmp	r3, #0x0
 801722c: d001         	beq	0x8017232 <k_sched_unlock+0x6e> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 801722e: 6bfb         	ldr	r3, [r7, #0x3c]
 8017230: 643b         	str	r3, [r7, #0x40]
; 	return thread;
 8017232: 6c3b         	ldr	r3, [r7, #0x40]
; 	return _priq_run_best(curr_cpu_runq());
 8017234: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8017236: 63bb         	str	r3, [r7, #0x38]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8017238: 6bbb         	ldr	r3, [r7, #0x38]
 801723a: 2b00         	cmp	r3, #0x0
 801723c: d102         	bne	0x8017244 <k_sched_unlock+0x80> @ imm = #0x4
 801723e: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x801736c <k_sched_unlock+0x1a8>
 8017240: 68db         	ldr	r3, [r3, #0xc]
 8017242: e000         	b	0x8017246 <k_sched_unlock+0x82> @ imm = #0x0
 8017244: 6bbb         	ldr	r3, [r7, #0x38]
; 	struct k_thread *thread = next_up();
 8017246: 637b         	str	r3, [r7, #0x34]
 8017248: 6b7b         	ldr	r3, [r7, #0x34]
 801724a: 633b         	str	r3, [r7, #0x30]
 801724c: 6cbb         	ldr	r3, [r7, #0x48]
 801724e: 62fb         	str	r3, [r7, #0x2c]
; 	if (preempt_ok != 0) {
 8017250: 6afb         	ldr	r3, [r7, #0x2c]
 8017252: 2b00         	cmp	r3, #0x0
 8017254: d001         	beq	0x801725a <k_sched_unlock+0x96> @ imm = #0x2
; 		return true;
 8017256: 2301         	movs	r3, #0x1
 8017258: e026         	b	0x80172a8 <k_sched_unlock+0xe4> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801725a: 4b44         	ldr	r3, [pc, #0x110]        @ 0x801736c <k_sched_unlock+0x1a8>
 801725c: 689b         	ldr	r3, [r3, #0x8]
 801725e: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8017260: 6abb         	ldr	r3, [r7, #0x28]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8017262: 4618         	mov	r0, r3
 8017264: f011 f90a    	bl	0x802847c <z_is_thread_prevented_from_running> @ imm = #0x11214
 8017268: 4603         	mov	r3, r0
 801726a: 2b00         	cmp	r3, #0x0
 801726c: d001         	beq	0x8017272 <k_sched_unlock+0xae> @ imm = #0x2
; 		return true;
 801726e: 2301         	movs	r3, #0x1
 8017270: e01a         	b	0x80172a8 <k_sched_unlock+0xe4> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017272: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x801736c <k_sched_unlock+0x1a8>
 8017274: 689b         	ldr	r3, [r3, #0x8]
 8017276: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8017278: 6a7b         	ldr	r3, [r7, #0x24]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 801727a: 4618         	mov	r0, r3
 801727c: f011 f8cf    	bl	0x802841e <thread_is_preemptible> @ imm = #0x1119e
 8017280: 4603         	mov	r3, r0
 8017282: 2b00         	cmp	r3, #0x0
 8017284: d105         	bne	0x8017292 <k_sched_unlock+0xce> @ imm = #0xa
 8017286: 6b38         	ldr	r0, [r7, #0x30]
 8017288: f011 f8da    	bl	0x8028440 <thread_is_metairq> @ imm = #0x111b4
 801728c: 4603         	mov	r3, r0
 801728e: 2b00         	cmp	r3, #0x0
 8017290: d001         	beq	0x8017296 <k_sched_unlock+0xd2> @ imm = #0x2
; 		return true;
 8017292: 2301         	movs	r3, #0x1
 8017294: e008         	b	0x80172a8 <k_sched_unlock+0xe4> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8017296: 6b38         	ldr	r0, [r7, #0x30]
 8017298: f011 f905    	bl	0x80284a6 <z_is_thread_timeout_active> @ imm = #0x1120a
 801729c: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 801729e: 2b00         	cmp	r3, #0x0
 80172a0: d001         	beq	0x80172a6 <k_sched_unlock+0xe2> @ imm = #0x2
; 		return true;
 80172a2: 2301         	movs	r3, #0x1
 80172a4: e000         	b	0x80172a8 <k_sched_unlock+0xe4> @ imm = #0x0
; 	return false;
 80172a6: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 80172a8: 2b00         	cmp	r3, #0x0
 80172aa: d010         	beq	0x80172ce <k_sched_unlock+0x10a> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80172ac: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x801736c <k_sched_unlock+0x1a8>
 80172ae: 689b         	ldr	r3, [r3, #0x8]
 80172b0: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 80172b2: 6a3b         	ldr	r3, [r7, #0x20]
; 		if (thread != arch_current_thread()) {
 80172b4: 6b7a         	ldr	r2, [r7, #0x34]
 80172b6: 429a         	cmp	r2, r3
 80172b8: d002         	beq	0x80172c0 <k_sched_unlock+0xfc> @ imm = #0x4
; 			z_reset_time_slice(thread);
 80172ba: 6b78         	ldr	r0, [r7, #0x34]
 80172bc: f000 fd14    	bl	0x8017ce8 <z_reset_time_slice> @ imm = #0xa28
; 		update_metairq_preempt(thread);
 80172c0: 6b78         	ldr	r0, [r7, #0x34]
 80172c2: f011 fa70    	bl	0x80287a6 <update_metairq_preempt> @ imm = #0x114e0
; 		_kernel.ready_q.cache = thread;
 80172c6: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x801736c <k_sched_unlock+0x1a8>
 80172c8: 6b7b         	ldr	r3, [r7, #0x34]
 80172ca: 6213         	str	r3, [r2, #0x20]
; }
 80172cc: e005         	b	0x80172da <k_sched_unlock+0x116> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80172ce: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x801736c <k_sched_unlock+0x1a8>
 80172d0: 689b         	ldr	r3, [r3, #0x8]
 80172d2: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 80172d4: 69fb         	ldr	r3, [r7, #0x1c]
; 		_kernel.ready_q.cache = arch_current_thread();
 80172d6: 4a25         	ldr	r2, [pc, #0x94]         @ 0x801736c <k_sched_unlock+0x1a8>
 80172d8: 6213         	str	r3, [r2, #0x20]
; }
 80172da: bf00         	nop
 80172dc: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8017368 <k_sched_unlock+0x1a4>
 80172de: 657b         	str	r3, [r7, #0x54]
 80172e0: 68bb         	ldr	r3, [r7, #0x8]
 80172e2: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 80172e4: 687b         	ldr	r3, [r7, #0x4]
 80172e6: 653b         	str	r3, [r7, #0x50]
 80172e8: 6d3b         	ldr	r3, [r7, #0x50]
 80172ea: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80172ec: 6cfb         	ldr	r3, [r7, #0x4c]
 80172ee: f383 8811    	msr	basepri, r3
; }
 80172f2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80172f4: f3bf 8f6f    	isb	sy
; }
 80172f8: bf00         	nop
; }
 80172fa: bf00         	nop
; }
 80172fc: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 80172fe: 2301         	movs	r3, #0x1
 8017300: 60fb         	str	r3, [r7, #0xc]
 8017302: 68fb         	ldr	r3, [r7, #0xc]
 8017304: 2b00         	cmp	r3, #0x0
 8017306: f43f af7d    	beq.w	0x8017204 <k_sched_unlock+0x40> @ imm = #-0x106
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 801730a: 2303         	movs	r3, #0x3
 801730c: 2b03         	cmp	r3, #0x3
 801730e: d925         	bls	0x801735c <k_sched_unlock+0x198> @ imm = #0x4a
 8017310: 2301         	movs	r3, #0x1
 8017312: f887 3077    	strb.w	r3, [r7, #0x77]
 8017316: f897 3077    	ldrb.w	r3, [r7, #0x77]
 801731a: f083 0301    	eor	r3, r3, #0x1
 801731e: b2db         	uxtb	r3, r3
 8017320: 2b00         	cmp	r3, #0x0
 8017322: d11b         	bne	0x801735c <k_sched_unlock+0x198> @ imm = #0x36
 8017324: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8017374 <k_sched_unlock+0x1b0>
 8017326: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017328: 4b10         	ldr	r3, [pc, #0x40]         @ 0x801736c <k_sched_unlock+0x1a8>
 801732a: 689b         	ldr	r3, [r3, #0x8]
 801732c: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 801732e: 693b         	ldr	r3, [r7, #0x10]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017330: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x801736c <k_sched_unlock+0x1a8>
 8017332: 6892         	ldr	r2, [r2, #0x8]
 8017334: 617a         	str	r2, [r7, #0x14]
; 	return ret;
 8017336: 697a         	ldr	r2, [r7, #0x14]
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 8017338: 7bd2         	ldrb	r2, [r2, #0xf]
 801733a: 9205         	str	r2, [sp, #0x14]
 801733c: 9304         	str	r3, [sp, #0x10]
 801733e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8017378 <k_sched_unlock+0x1b4>
 8017340: 9303         	str	r3, [sp, #0xc]
 8017342: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x801737c <k_sched_unlock+0x1b8>
 8017344: 9302         	str	r3, [sp, #0x8]
 8017346: 2308         	movs	r3, #0x8
 8017348: 9301         	str	r3, [sp, #0x4]
 801734a: 2300         	movs	r3, #0x0
 801734c: 9300         	str	r3, [sp]
 801734e: 2300         	movs	r3, #0x0
 8017350: 2204         	movs	r2, #0x4
 8017352: 2000         	movs	r0, #0x0
 8017354: f011 f9a6    	bl	0x80286a4 <z_log_msg_runtime_create> @ imm = #0x1134c
 8017358: 2300         	movs	r3, #0x0
 801735a: 673b         	str	r3, [r7, #0x70]
; 	z_reschedule_unlocked();
 801735c: f011 f955    	bl	0x802860a <z_reschedule_unlocked> @ imm = #0x112aa
; }
 8017360: bf00         	nop
 8017362: 3778         	adds	r7, #0x78
 8017364: 46bd         	mov	sp, r7
 8017366: bd80         	pop	{r7, pc}

08017368 <$d>:
 8017368: d8 32 00 24  	.word	0x240032d8
 801736c: 60 20 00 24  	.word	0x24002060
 8017370: 84 20 00 24  	.word	0x24002084
 8017374: 74 0b 00 24  	.word	0x24000b74
 8017378: 38 e6 02 08  	.word	0x0802e638
 801737c: fc c9 02 08  	.word	0x0802c9fc

08017380 <z_sched_init>:
; {
 8017380: b580         	push	{r7, lr}
 8017382: af00         	add	r7, sp, #0x0
; 	init_ready_q(&_kernel.ready_q);
 8017384: 4802         	ldr	r0, [pc, #0x8]          @ 0x8017390 <z_sched_init+0x10>
 8017386: f011 fb5d    	bl	0x8028a44 <init_ready_q> @ imm = #0x116ba
; }
 801738a: bf00         	nop
 801738c: bd80         	pop	{r7, pc}
 801738e: bf00         	nop

08017390 <$d>:
 8017390: 80 20 00 24  	.word	0x24002080

08017394 <z_impl_k_thread_priority_set>:
; {
 8017394: b580         	push	{r7, lr}
 8017396: b084         	sub	sp, #0x10
 8017398: af00         	add	r7, sp, #0x0
 801739a: 6078         	str	r0, [r7, #0x4]
 801739c: 6039         	str	r1, [r7]
; 	bool need_sched = z_thread_prio_set((struct k_thread *)thread, prio);
 801739e: 6839         	ldr	r1, [r7]
 80173a0: 6878         	ldr	r0, [r7, #0x4]
 80173a2: f7ff fd77    	bl	0x8016e94 <z_thread_prio_set> @ imm = #-0x512
 80173a6: 4603         	mov	r3, r0
 80173a8: 73fb         	strb	r3, [r7, #0xf]
; 	if ((need_sched) && (IS_ENABLED(CONFIG_SMP) ||
 80173aa: 7bfb         	ldrb	r3, [r7, #0xf]
 80173ac: 2b00         	cmp	r3, #0x0
 80173ae: d008         	beq	0x80173c2 <z_impl_k_thread_priority_set+0x2e> @ imm = #0x10
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80173b0: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80173cc <z_impl_k_thread_priority_set+0x38>
 80173b2: 689b         	ldr	r3, [r3, #0x8]
 80173b4: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 80173b6: 68bb         	ldr	r3, [r7, #0x8]
; 			     (arch_current_thread()->base.sched_locked == 0U))) {
 80173b8: 7bdb         	ldrb	r3, [r3, #0xf]
; 	if ((need_sched) && (IS_ENABLED(CONFIG_SMP) ||
 80173ba: 2b00         	cmp	r3, #0x0
 80173bc: d101         	bne	0x80173c2 <z_impl_k_thread_priority_set+0x2e> @ imm = #0x2
; 		z_reschedule_unlocked();
 80173be: f011 f924    	bl	0x802860a <z_reschedule_unlocked> @ imm = #0x11248
; }
 80173c2: bf00         	nop
 80173c4: 3710         	adds	r7, #0x10
 80173c6: 46bd         	mov	sp, r7
 80173c8: bd80         	pop	{r7, pc}
 80173ca: bf00         	nop

080173cc <$d>:
 80173cc: 60 20 00 24  	.word	0x24002060

080173d0 <z_impl_k_yield>:
; {
 80173d0: b580         	push	{r7, lr}
 80173d2: b0a4         	sub	sp, #0x90
 80173d4: af00         	add	r7, sp, #0x0
 80173d6: 4b86         	ldr	r3, [pc, #0x218]        @ 0x80175f0 <z_impl_k_yield+0x220>
 80173d8: f8c7 308c    	str.w	r3, [r7, #0x8c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80173dc: f3ef 8311    	mrs	r3, basepri
 80173e0: f8c7 3088    	str.w	r3, [r7, #0x88]
;   return(result);
 80173e4: f8d7 3088    	ldr.w	r3, [r7, #0x88]
; 	key = __get_BASEPRI();
 80173e8: f8c7 3084    	str.w	r3, [r7, #0x84]
 80173ec: 2310         	movs	r3, #0x10
 80173ee: f8c7 3080    	str.w	r3, [r7, #0x80]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80173f2: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80173f6: f383 8812    	msr	basepri_max, r3
; }
 80173fa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80173fc: f3bf 8f6f    	isb	sy
; }
 8017400: bf00         	nop
; 	return key;
 8017402: f8d7 3084    	ldr.w	r3, [r7, #0x84]
; 	k.key = arch_irq_lock();
 8017406: 603b         	str	r3, [r7]
 8017408: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 801740c: 67fb         	str	r3, [r7, #0x7c]
; }
 801740e: bf00         	nop
 8017410: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8017414: 67bb         	str	r3, [r7, #0x78]
; }
 8017416: bf00         	nop
; 	return k;
 8017418: 683b         	ldr	r3, [r7]
 801741a: 60bb         	str	r3, [r7, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801741c: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x80175f4 <z_impl_k_yield+0x224>
 801741e: 689b         	ldr	r3, [r3, #0x8]
 8017420: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8017422: 68fb         	ldr	r3, [r7, #0xc]
 8017424: 623b         	str	r3, [r7, #0x20]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 8017426: 6a3b         	ldr	r3, [r7, #0x20]
 8017428: 7b5b         	ldrb	r3, [r3, #0xd]
 801742a: f003 037f    	and	r3, r3, #0x7f
 801742e: b2da         	uxtb	r2, r3
 8017430: 6a3b         	ldr	r3, [r7, #0x20]
 8017432: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8017434: 6a38         	ldr	r0, [r7, #0x20]
 8017436: f011 f96f    	bl	0x8028718 <should_queue_thread> @ imm = #0x112de
 801743a: 4603         	mov	r3, r0
 801743c: 2b00         	cmp	r3, #0x0
 801743e: d00d         	beq	0x801745c <z_impl_k_yield+0x8c> @ imm = #0x1a
 8017440: 6a3b         	ldr	r3, [r7, #0x20]
 8017442: 61fb         	str	r3, [r7, #0x1c]
 8017444: 69fb         	ldr	r3, [r7, #0x1c]
 8017446: 61bb         	str	r3, [r7, #0x18]
; 	return &_kernel.ready_q.runq;
 8017448: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x80175f8 <z_impl_k_yield+0x228>
 801744a: 617b         	str	r3, [r7, #0x14]
 801744c: 69fb         	ldr	r3, [r7, #0x1c]
 801744e: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8017450: 693b         	ldr	r3, [r7, #0x10]
 8017452: 4618         	mov	r0, r3
 8017454: f010 ff95    	bl	0x8028382 <sys_dlist_remove> @ imm = #0x10f2a
; }
 8017458: bf00         	nop
; }
 801745a: bf00         	nop
; }
 801745c: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801745e: 4b65         	ldr	r3, [pc, #0x194]        @ 0x80175f4 <z_impl_k_yield+0x224>
 8017460: 689b         	ldr	r3, [r3, #0x8]
 8017462: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8017464: 6a7b         	ldr	r3, [r7, #0x24]
 8017466: 63fb         	str	r3, [r7, #0x3c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 8017468: 6bfb         	ldr	r3, [r7, #0x3c]
 801746a: 7b5b         	ldrb	r3, [r3, #0xd]
 801746c: f063 037f    	orn	r3, r3, #0x7f
 8017470: b2da         	uxtb	r2, r3
 8017472: 6bfb         	ldr	r3, [r7, #0x3c]
 8017474: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8017476: 6bf8         	ldr	r0, [r7, #0x3c]
 8017478: f011 f94e    	bl	0x8028718 <should_queue_thread> @ imm = #0x1129c
 801747c: 4603         	mov	r3, r0
 801747e: 2b00         	cmp	r3, #0x0
 8017480: d042         	beq	0x8017508 <z_impl_k_yield+0x138> @ imm = #0x84
 8017482: 6bfb         	ldr	r3, [r7, #0x3c]
 8017484: 63bb         	str	r3, [r7, #0x38]
 8017486: 6bbb         	ldr	r3, [r7, #0x38]
 8017488: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 801748a: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x80175f8 <z_impl_k_yield+0x228>
 801748c: 633b         	str	r3, [r7, #0x30]
 801748e: 6bbb         	ldr	r3, [r7, #0x38]
 8017490: 62fb         	str	r3, [r7, #0x2c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8017492: 6b38         	ldr	r0, [r7, #0x30]
 8017494: f010 ff08    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x10e10
 8017498: 4603         	mov	r3, r0
 801749a: 2b00         	cmp	r3, #0x0
 801749c: d004         	beq	0x80174a8 <z_impl_k_yield+0xd8> @ imm = #0x8
 801749e: 6b38         	ldr	r0, [r7, #0x30]
 80174a0: f010 ff02    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x10e04
 80174a4: 4603         	mov	r3, r0
 80174a6: e000         	b	0x80174aa <z_impl_k_yield+0xda> @ imm = #0x0
 80174a8: 2300         	movs	r3, #0x0
 80174aa: 62bb         	str	r3, [r7, #0x28]
 80174ac: e023         	b	0x80174f6 <z_impl_k_yield+0x126> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 80174ae: 6ab9         	ldr	r1, [r7, #0x28]
 80174b0: 6af8         	ldr	r0, [r7, #0x2c]
 80174b2: f011 f915    	bl	0x80286e0 <z_sched_prio_cmp> @ imm = #0x1122a
 80174b6: 4603         	mov	r3, r0
 80174b8: 2b00         	cmp	r3, #0x0
 80174ba: dd06         	ble	0x80174ca <z_impl_k_yield+0xfa> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 80174bc: 6abb         	ldr	r3, [r7, #0x28]
 80174be: 6afa         	ldr	r2, [r7, #0x2c]
 80174c0: 4611         	mov	r1, r2
 80174c2: 4618         	mov	r0, r3
 80174c4: f010 ff43    	bl	0x802834e <sys_dlist_insert> @ imm = #0x10e86
; 			return;
 80174c8: e01d         	b	0x8017506 <z_impl_k_yield+0x136> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80174ca: 6abb         	ldr	r3, [r7, #0x28]
 80174cc: 2b00         	cmp	r3, #0x0
 80174ce: d010         	beq	0x80174f2 <z_impl_k_yield+0x122> @ imm = #0x20
 80174d0: 6abb         	ldr	r3, [r7, #0x28]
 80174d2: 4619         	mov	r1, r3
 80174d4: 6b38         	ldr	r0, [r7, #0x30]
 80174d6: f010 ff0d    	bl	0x80282f4 <sys_dlist_peek_next> @ imm = #0x10e1a
 80174da: 4603         	mov	r3, r0
 80174dc: 2b00         	cmp	r3, #0x0
 80174de: d006         	beq	0x80174ee <z_impl_k_yield+0x11e> @ imm = #0xc
 80174e0: 6abb         	ldr	r3, [r7, #0x28]
 80174e2: 4619         	mov	r1, r3
 80174e4: 6b38         	ldr	r0, [r7, #0x30]
 80174e6: f010 ff05    	bl	0x80282f4 <sys_dlist_peek_next> @ imm = #0x10e0a
 80174ea: 4603         	mov	r3, r0
 80174ec: e002         	b	0x80174f4 <z_impl_k_yield+0x124> @ imm = #0x4
 80174ee: 2300         	movs	r3, #0x0
 80174f0: e000         	b	0x80174f4 <z_impl_k_yield+0x124> @ imm = #0x0
 80174f2: 2300         	movs	r3, #0x0
 80174f4: 62bb         	str	r3, [r7, #0x28]
 80174f6: 6abb         	ldr	r3, [r7, #0x28]
 80174f8: 2b00         	cmp	r3, #0x0
 80174fa: d1d8         	bne	0x80174ae <z_impl_k_yield+0xde> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 80174fc: 6afb         	ldr	r3, [r7, #0x2c]
 80174fe: 4619         	mov	r1, r3
 8017500: 6b38         	ldr	r0, [r7, #0x30]
 8017502: f010 ff0a    	bl	0x802831a <sys_dlist_append> @ imm = #0x10e14
; }
 8017506: bf00         	nop
; }
 8017508: bf00         	nop
 801750a: 2301         	movs	r3, #0x1
 801750c: 66fb         	str	r3, [r7, #0x6c]
; 	return &_kernel.ready_q.runq;
 801750e: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x80175f8 <z_impl_k_yield+0x228>
 8017510: 66bb         	str	r3, [r7, #0x68]
; 	struct k_thread *thread = NULL;
 8017512: 2300         	movs	r3, #0x0
 8017514: 667b         	str	r3, [r7, #0x64]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8017516: 6eb8         	ldr	r0, [r7, #0x68]
 8017518: f010 fec6    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x10d8c
 801751c: 6638         	str	r0, [r7, #0x60]
; 	if (n != NULL) {
 801751e: 6e3b         	ldr	r3, [r7, #0x60]
 8017520: 2b00         	cmp	r3, #0x0
 8017522: d001         	beq	0x8017528 <z_impl_k_yield+0x158> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8017524: 6e3b         	ldr	r3, [r7, #0x60]
 8017526: 667b         	str	r3, [r7, #0x64]
; 	return thread;
 8017528: 6e7b         	ldr	r3, [r7, #0x64]
; 	return _priq_run_best(curr_cpu_runq());
 801752a: bf00         	nop
; 	struct k_thread *thread = runq_best();
 801752c: 65fb         	str	r3, [r7, #0x5c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 801752e: 6dfb         	ldr	r3, [r7, #0x5c]
 8017530: 2b00         	cmp	r3, #0x0
 8017532: d102         	bne	0x801753a <z_impl_k_yield+0x16a> @ imm = #0x4
 8017534: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x80175f4 <z_impl_k_yield+0x224>
 8017536: 68db         	ldr	r3, [r3, #0xc]
 8017538: e000         	b	0x801753c <z_impl_k_yield+0x16c> @ imm = #0x0
 801753a: 6dfb         	ldr	r3, [r7, #0x5c]
; 	struct k_thread *thread = next_up();
 801753c: 65bb         	str	r3, [r7, #0x58]
 801753e: 6dbb         	ldr	r3, [r7, #0x58]
 8017540: 657b         	str	r3, [r7, #0x54]
 8017542: 6efb         	ldr	r3, [r7, #0x6c]
 8017544: 653b         	str	r3, [r7, #0x50]
; 	if (preempt_ok != 0) {
 8017546: 6d3b         	ldr	r3, [r7, #0x50]
 8017548: 2b00         	cmp	r3, #0x0
 801754a: d001         	beq	0x8017550 <z_impl_k_yield+0x180> @ imm = #0x2
; 		return true;
 801754c: 2301         	movs	r3, #0x1
 801754e: e026         	b	0x801759e <z_impl_k_yield+0x1ce> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017550: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x80175f4 <z_impl_k_yield+0x224>
 8017552: 689b         	ldr	r3, [r3, #0x8]
 8017554: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 8017556: 6cfb         	ldr	r3, [r7, #0x4c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8017558: 4618         	mov	r0, r3
 801755a: f010 ff8f    	bl	0x802847c <z_is_thread_prevented_from_running> @ imm = #0x10f1e
 801755e: 4603         	mov	r3, r0
 8017560: 2b00         	cmp	r3, #0x0
 8017562: d001         	beq	0x8017568 <z_impl_k_yield+0x198> @ imm = #0x2
; 		return true;
 8017564: 2301         	movs	r3, #0x1
 8017566: e01a         	b	0x801759e <z_impl_k_yield+0x1ce> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017568: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80175f4 <z_impl_k_yield+0x224>
 801756a: 689b         	ldr	r3, [r3, #0x8]
 801756c: 64bb         	str	r3, [r7, #0x48]
; 	return ret;
 801756e: 6cbb         	ldr	r3, [r7, #0x48]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 8017570: 4618         	mov	r0, r3
 8017572: f010 ff54    	bl	0x802841e <thread_is_preemptible> @ imm = #0x10ea8
 8017576: 4603         	mov	r3, r0
 8017578: 2b00         	cmp	r3, #0x0
 801757a: d105         	bne	0x8017588 <z_impl_k_yield+0x1b8> @ imm = #0xa
 801757c: 6d78         	ldr	r0, [r7, #0x54]
 801757e: f010 ff5f    	bl	0x8028440 <thread_is_metairq> @ imm = #0x10ebe
 8017582: 4603         	mov	r3, r0
 8017584: 2b00         	cmp	r3, #0x0
 8017586: d001         	beq	0x801758c <z_impl_k_yield+0x1bc> @ imm = #0x2
; 		return true;
 8017588: 2301         	movs	r3, #0x1
 801758a: e008         	b	0x801759e <z_impl_k_yield+0x1ce> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 801758c: 6d78         	ldr	r0, [r7, #0x54]
 801758e: f010 ff8a    	bl	0x80284a6 <z_is_thread_timeout_active> @ imm = #0x10f14
 8017592: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8017594: 2b00         	cmp	r3, #0x0
 8017596: d001         	beq	0x801759c <z_impl_k_yield+0x1cc> @ imm = #0x2
; 		return true;
 8017598: 2301         	movs	r3, #0x1
 801759a: e000         	b	0x801759e <z_impl_k_yield+0x1ce> @ imm = #0x0
; 	return false;
 801759c: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 801759e: 2b00         	cmp	r3, #0x0
 80175a0: d010         	beq	0x80175c4 <z_impl_k_yield+0x1f4> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80175a2: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80175f4 <z_impl_k_yield+0x224>
 80175a4: 689b         	ldr	r3, [r3, #0x8]
 80175a6: 647b         	str	r3, [r7, #0x44]
; 	return ret;
 80175a8: 6c7b         	ldr	r3, [r7, #0x44]
; 		if (thread != arch_current_thread()) {
 80175aa: 6dba         	ldr	r2, [r7, #0x58]
 80175ac: 429a         	cmp	r2, r3
 80175ae: d002         	beq	0x80175b6 <z_impl_k_yield+0x1e6> @ imm = #0x4
; 			z_reset_time_slice(thread);
 80175b0: 6db8         	ldr	r0, [r7, #0x58]
 80175b2: f000 fb99    	bl	0x8017ce8 <z_reset_time_slice> @ imm = #0x732
; 		update_metairq_preempt(thread);
 80175b6: 6db8         	ldr	r0, [r7, #0x58]
 80175b8: f011 f8f5    	bl	0x80287a6 <update_metairq_preempt> @ imm = #0x111ea
; 		_kernel.ready_q.cache = thread;
 80175bc: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x80175f4 <z_impl_k_yield+0x224>
 80175be: 6dbb         	ldr	r3, [r7, #0x58]
 80175c0: 6213         	str	r3, [r2, #0x20]
; }
 80175c2: e005         	b	0x80175d0 <z_impl_k_yield+0x200> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80175c4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80175f4 <z_impl_k_yield+0x224>
 80175c6: 689b         	ldr	r3, [r3, #0x8]
 80175c8: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 80175ca: 6c3b         	ldr	r3, [r7, #0x40]
; 		_kernel.ready_q.cache = arch_current_thread();
 80175cc: 4a09         	ldr	r2, [pc, #0x24]         @ 0x80175f4 <z_impl_k_yield+0x224>
 80175ce: 6213         	str	r3, [r2, #0x20]
; }
 80175d0: bf00         	nop
 80175d2: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80175f0 <z_impl_k_yield+0x220>
 80175d4: 677b         	str	r3, [r7, #0x74]
 80175d6: 68bb         	ldr	r3, [r7, #0x8]
 80175d8: 607b         	str	r3, [r7, #0x4]
 80175da: 6f7b         	ldr	r3, [r7, #0x74]
 80175dc: 673b         	str	r3, [r7, #0x70]
; }
 80175de: bf00         	nop
; 	return z_swap_irqlock(key.key);
 80175e0: 687b         	ldr	r3, [r7, #0x4]
 80175e2: 4618         	mov	r0, r3
 80175e4: f011 f851    	bl	0x802868a <z_swap_irqlock> @ imm = #0x110a2
; }
 80175e8: bf00         	nop
 80175ea: 3790         	adds	r7, #0x90
 80175ec: 46bd         	mov	sp, r7
 80175ee: bd80         	pop	{r7, pc}

080175f0 <$d>:
 80175f0: d8 32 00 24  	.word	0x240032d8
 80175f4: 60 20 00 24  	.word	0x24002060
 80175f8: 84 20 00 24  	.word	0x24002084

080175fc <z_tick_sleep>:
; {
 80175fc: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8017600: b0a0         	sub	sp, #0x80
 8017602: af06         	add	r7, sp, #0x18
 8017604: e9c7 0100    	strd	r0, r1, [r7]
; 	LOG_DBG("thread %p for %lu ticks", arch_current_thread(), (unsigned long)ticks);
 8017608: 2303         	movs	r3, #0x3
 801760a: 2b03         	cmp	r3, #0x3
 801760c: d921         	bls	0x8017652 <z_tick_sleep+0x56> @ imm = #0x42
 801760e: 2301         	movs	r3, #0x1
 8017610: f887 3067    	strb.w	r3, [r7, #0x67]
 8017614: f897 3067    	ldrb.w	r3, [r7, #0x67]
 8017618: f083 0301    	eor	r3, r3, #0x1
 801761c: b2db         	uxtb	r3, r3
 801761e: 2b00         	cmp	r3, #0x0
 8017620: d117         	bne	0x8017652 <z_tick_sleep+0x56> @ imm = #0x2e
 8017622: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x8017754 <z_tick_sleep+0x158>
 8017624: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017626: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x8017758 <z_tick_sleep+0x15c>
 8017628: 689b         	ldr	r3, [r3, #0x8]
 801762a: 657b         	str	r3, [r7, #0x54]
; 	return ret;
 801762c: 6d7b         	ldr	r3, [r7, #0x54]
; 	LOG_DBG("thread %p for %lu ticks", arch_current_thread(), (unsigned long)ticks);
 801762e: 683a         	ldr	r2, [r7]
 8017630: 9205         	str	r2, [sp, #0x14]
 8017632: 9304         	str	r3, [sp, #0x10]
 8017634: 4b49         	ldr	r3, [pc, #0x124]        @ 0x801775c <z_tick_sleep+0x160>
 8017636: 9303         	str	r3, [sp, #0xc]
 8017638: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8017760 <z_tick_sleep+0x164>
 801763a: 9302         	str	r3, [sp, #0x8]
 801763c: 2308         	movs	r3, #0x8
 801763e: 9301         	str	r3, [sp, #0x4]
 8017640: 2300         	movs	r3, #0x0
 8017642: 9300         	str	r3, [sp]
 8017644: 2300         	movs	r3, #0x0
 8017646: 2204         	movs	r2, #0x4
 8017648: 2000         	movs	r0, #0x0
 801764a: f011 f82b    	bl	0x80286a4 <z_log_msg_runtime_create> @ imm = #0x11056
 801764e: 2300         	movs	r3, #0x0
 8017650: 65fb         	str	r3, [r7, #0x5c]
; 	if (ticks == 0) {
 8017652: e9d7 2300    	ldrd	r2, r3, [r7]
 8017656: 4313         	orrs	r3, r2
 8017658: d103         	bne	0x8017662 <z_tick_sleep+0x66> @ imm = #0x6
; 		k_yield();
 801765a: f010 fea9    	bl	0x80283b0 <k_yield>     @ imm = #0x10d52
; 		return 0;
 801765e: 2300         	movs	r3, #0x0
 8017660: e073         	b	0x801774a <z_tick_sleep+0x14e> @ imm = #0xe6
; 	if (Z_TICK_ABS(ticks) <= 0) {
 8017662: e9d7 2300    	ldrd	r2, r3, [r7]
 8017666: f06f 0001    	mvn	r0, #0x1
 801766a: f04f 31ff    	mov.w	r1, #0xffffffff
 801766e: 1a84         	subs	r4, r0, r2
 8017670: eb61 0503    	sbc.w	r5, r1, r3
 8017674: 2c01         	cmp	r4, #0x1
 8017676: f175 0300    	sbcs	r3, r5, #0x0
 801767a: da06         	bge	0x801768a <z_tick_sleep+0x8e> @ imm = #0xc
; 		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
 801767c: f011 fba4    	bl	0x8028dc8 <sys_clock_tick_get_32> @ imm = #0x11748
 8017680: 4602         	mov	r2, r0
 8017682: 683b         	ldr	r3, [r7]
 8017684: 4413         	add	r3, r2
 8017686: 663b         	str	r3, [r7, #0x60]
 8017688: e004         	b	0x8017694 <z_tick_sleep+0x98> @ imm = #0x8
; 		expected_wakeup_ticks = Z_TICK_ABS(ticks);
 801768a: 683a         	ldr	r2, [r7]
 801768c: f06f 0301    	mvn	r3, #0x1
 8017690: 1a9b         	subs	r3, r3, r2
 8017692: 663b         	str	r3, [r7, #0x60]
; 	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
 8017694: e9d7 2300    	ldrd	r2, r3, [r7]
 8017698: e9c7 2306    	strd	r2, r3, [r7, #24]
 801769c: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8017764 <z_tick_sleep+0x168>
 801769e: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80176a0: f3ef 8311    	mrs	r3, basepri
 80176a4: 637b         	str	r3, [r7, #0x34]
;   return(result);
 80176a6: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 80176a8: 633b         	str	r3, [r7, #0x30]
 80176aa: 2310         	movs	r3, #0x10
 80176ac: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80176ae: 6afb         	ldr	r3, [r7, #0x2c]
 80176b0: f383 8812    	msr	basepri_max, r3
; }
 80176b4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80176b6: f3bf 8f6f    	isb	sy
; }
 80176ba: bf00         	nop
; 	return key;
 80176bc: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 80176be: 613b         	str	r3, [r7, #0x10]
 80176c0: 6bbb         	ldr	r3, [r7, #0x38]
 80176c2: 62bb         	str	r3, [r7, #0x28]
; }
 80176c4: bf00         	nop
 80176c6: 6bbb         	ldr	r3, [r7, #0x38]
 80176c8: 627b         	str	r3, [r7, #0x24]
; }
 80176ca: bf00         	nop
; 	return k;
 80176cc: 693b         	ldr	r3, [r7, #0x10]
 80176ce: 617b         	str	r3, [r7, #0x14]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80176d0: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8017758 <z_tick_sleep+0x15c>
 80176d2: 689b         	ldr	r3, [r3, #0x8]
 80176d4: 63fb         	str	r3, [r7, #0x3c]
; 	return ret;
 80176d6: 6bfb         	ldr	r3, [r7, #0x3c]
; 	pending_current = arch_current_thread();
 80176d8: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x8017768 <z_tick_sleep+0x16c>
 80176da: 6013         	str	r3, [r2]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80176dc: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8017758 <z_tick_sleep+0x15c>
 80176de: 689b         	ldr	r3, [r3, #0x8]
 80176e0: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 80176e2: 6c3b         	ldr	r3, [r7, #0x40]
; 	unready_thread(arch_current_thread());
 80176e4: 4618         	mov	r0, r3
 80176e6: f7ff fa2f    	bl	0x8016b48 <unready_thread> @ imm = #-0xba2
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80176ea: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8017758 <z_tick_sleep+0x15c>
 80176ec: 689b         	ldr	r3, [r3, #0x8]
 80176ee: 647b         	str	r3, [r7, #0x44]
; 	return ret;
 80176f0: 6c79         	ldr	r1, [r7, #0x44]
; 	z_add_thread_timeout(arch_current_thread(), timeout);
 80176f2: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 80176f6: 4608         	mov	r0, r1
 80176f8: f7fe fd76    	bl	0x80161e8 <z_add_thread_timeout> @ imm = #-0x1514
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80176fc: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8017758 <z_tick_sleep+0x15c>
 80176fe: 689b         	ldr	r3, [r3, #0x8]
 8017700: 64bb         	str	r3, [r7, #0x48]
; 	return ret;
 8017702: 6cbb         	ldr	r3, [r7, #0x48]
; 	z_mark_thread_as_suspended(arch_current_thread());
 8017704: 4618         	mov	r0, r3
 8017706: f010 ff29    	bl	0x802855c <z_mark_thread_as_suspended> @ imm = #0x10e52
 801770a: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8017764 <z_tick_sleep+0x168>
 801770c: 653b         	str	r3, [r7, #0x50]
 801770e: 697b         	ldr	r3, [r7, #0x14]
 8017710: 60fb         	str	r3, [r7, #0xc]
 8017712: 6d3b         	ldr	r3, [r7, #0x50]
 8017714: 64fb         	str	r3, [r7, #0x4c]
; }
 8017716: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8017718: 68fb         	ldr	r3, [r7, #0xc]
 801771a: 4618         	mov	r0, r3
 801771c: f010 ffb5    	bl	0x802868a <z_swap_irqlock> @ imm = #0x10f6a
; 	uint32_t left_ticks = expected_wakeup_ticks - sys_clock_tick_get_32();
 8017720: f011 fb52    	bl	0x8028dc8 <sys_clock_tick_get_32> @ imm = #0x116a4
 8017724: 4602         	mov	r2, r0
 8017726: 6e3b         	ldr	r3, [r7, #0x60]
 8017728: 1a9b         	subs	r3, r3, r2
 801772a: 65bb         	str	r3, [r7, #0x58]
; 	ticks = (k_ticks_t)(int32_t)left_ticks;
 801772c: 6dbb         	ldr	r3, [r7, #0x58]
 801772e: 17da         	asrs	r2, r3, #0x1f
 8017730: 4698         	mov	r8, r3
 8017732: 4691         	mov	r9, r2
 8017734: e9c7 8900    	strd	r8, r9, [r7]
; 	if (ticks > 0) {
 8017738: e9d7 2300    	ldrd	r2, r3, [r7]
 801773c: 2a01         	cmp	r2, #0x1
 801773e: f173 0300    	sbcs	r3, r3, #0x0
 8017742: db01         	blt	0x8017748 <z_tick_sleep+0x14c> @ imm = #0x2
; 		return ticks;
 8017744: 683b         	ldr	r3, [r7]
 8017746: e000         	b	0x801774a <z_tick_sleep+0x14e> @ imm = #0x0
; 	return 0;
 8017748: 2300         	movs	r3, #0x0
; }
 801774a: 4618         	mov	r0, r3
 801774c: 3768         	adds	r7, #0x68
 801774e: 46bd         	mov	sp, r7
 8017750: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

08017754 <$d>:
 8017754: 74 0b 00 24  	.word	0x24000b74
 8017758: 60 20 00 24  	.word	0x24002060
 801775c: 48 e6 02 08  	.word	0x0802e648
 8017760: 1c ca 02 08  	.word	0x0802ca1c
 8017764: d8 32 00 24  	.word	0x240032d8
 8017768: e4 32 00 24  	.word	0x240032e4

0801776c <z_impl_k_sleep>:
; {
 801776c: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8017770: b086         	sub	sp, #0x18
 8017772: af00         	add	r7, sp, #0x0
 8017774: e9c7 0100    	strd	r0, r1, [r7]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8017778: e9d7 2300    	ldrd	r2, r3, [r7]
 801777c: f04f 30ff    	mov.w	r0, #0xffffffff
 8017780: f04f 31ff    	mov.w	r1, #0xffffffff
 8017784: 428b         	cmp	r3, r1
 8017786: bf08         	it	eq
 8017788: 4282         	cmpeq	r2, r0
 801778a: d109         	bne	0x80177a0 <z_impl_k_sleep+0x34> @ imm = #0x12
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801778c: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80177ec <z_impl_k_sleep+0x80>
 801778e: 689b         	ldr	r3, [r3, #0x8]
 8017790: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 8017792: 68bb         	ldr	r3, [r7, #0x8]
; 		k_thread_suspend(arch_current_thread());
 8017794: 4618         	mov	r0, r3
 8017796: f010 fe11    	bl	0x80283bc <k_thread_suspend> @ imm = #0x10c22
; 		return (int32_t) K_TICKS_FOREVER;
 801779a: f04f 33ff    	mov.w	r3, #0xffffffff
 801779e: e020         	b	0x80177e2 <z_impl_k_sleep+0x76> @ imm = #0x40
; 	ticks = timeout.ticks;
 80177a0: e9d7 2300    	ldrd	r2, r3, [r7]
 80177a4: e9c7 2304    	strd	r2, r3, [r7, #16]
; 	ticks = z_tick_sleep(ticks);
 80177a8: e9d7 0104    	ldrd	r0, r1, [r7, #16]
 80177ac: f7ff ff26    	bl	0x80175fc <z_tick_sleep> @ imm = #-0x1b4
 80177b0: 4603         	mov	r3, r0
 80177b2: 17da         	asrs	r2, r3, #0x1f
 80177b4: 4698         	mov	r8, r3
 80177b6: 4691         	mov	r9, r2
 80177b8: e9c7 8904    	strd	r8, r9, [r7, #16]
; 	int32_t ret = k_ticks_to_ms_ceil64(ticks);
 80177bc: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 80177c0: f112 0409    	adds.w	r4, r2, #0x9
 80177c4: f143 0500    	adc	r5, r3, #0x0
 80177c8: f04f 020a    	mov.w	r2, #0xa
 80177cc: f04f 0300    	mov.w	r3, #0x0
 80177d0: 4620         	mov	r0, r4
 80177d2: 4629         	mov	r1, r5
 80177d4: f7e8 fdcc    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x17468
 80177d8: 4602         	mov	r2, r0
 80177da: 460b         	mov	r3, r1
 80177dc: 4613         	mov	r3, r2
 80177de: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 80177e0: 68fb         	ldr	r3, [r7, #0xc]
; }
 80177e2: 4618         	mov	r0, r3
 80177e4: 3718         	adds	r7, #0x18
 80177e6: 46bd         	mov	sp, r7
 80177e8: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

080177ec <$d>:
 80177ec: 60 20 00 24  	.word	0x24002060

080177f0 <z_impl_k_sched_current_thread_query>:
; {
 80177f0: b480         	push	{r7}
 80177f2: b083         	sub	sp, #0xc
 80177f4: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80177f6: 4b05         	ldr	r3, [pc, #0x14]         @ 0x801780c <z_impl_k_sched_current_thread_query+0x1c>
 80177f8: 689b         	ldr	r3, [r3, #0x8]
 80177fa: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 80177fc: 687b         	ldr	r3, [r7, #0x4]
; }
 80177fe: 4618         	mov	r0, r3
 8017800: 370c         	adds	r7, #0xc
 8017802: 46bd         	mov	sp, r7
 8017804: f85d 7b04    	ldr	r7, [sp], #4
 8017808: 4770         	bx	lr
 801780a: bf00         	nop

0801780c <$d>:
 801780c: 60 20 00 24  	.word	0x24002060

08017810 <halt_thread>:
; {
 8017810: b580         	push	{r7, lr}
 8017812: b096         	sub	sp, #0x58
 8017814: af00         	add	r7, sp, #0x0
 8017816: 6078         	str	r0, [r7, #0x4]
 8017818: 460b         	mov	r3, r1
 801781a: 70fb         	strb	r3, [r7, #0x3]
; 	bool dummify = false;
 801781c: 2300         	movs	r3, #0x0
 801781e: f887 3057    	strb.w	r3, [r7, #0x57]
; 	if ((thread->base.thread_state & new_state) == 0U) {
 8017822: 687b         	ldr	r3, [r7, #0x4]
 8017824: 7b5a         	ldrb	r2, [r3, #0xd]
 8017826: 78fb         	ldrb	r3, [r7, #0x3]
 8017828: 4013         	ands	r3, r2
 801782a: b2db         	uxtb	r3, r3
 801782c: 2b00         	cmp	r3, #0x0
 801782e: f040 80cd    	bne.w	0x80179cc <halt_thread+0x1bc> @ imm = #0x19a
; 		thread->base.thread_state |= new_state;
 8017832: 687b         	ldr	r3, [r7, #0x4]
 8017834: 7b5a         	ldrb	r2, [r3, #0xd]
 8017836: 78fb         	ldrb	r3, [r7, #0x3]
 8017838: 4313         	orrs	r3, r2
 801783a: b2da         	uxtb	r2, r3
 801783c: 687b         	ldr	r3, [r7, #0x4]
 801783e: 735a         	strb	r2, [r3, #0xd]
; 		if (z_is_thread_queued(thread)) {
 8017840: 6878         	ldr	r0, [r7, #0x4]
 8017842: f010 fe7e    	bl	0x8028542 <z_is_thread_queued> @ imm = #0x10cfc
 8017846: 4603         	mov	r3, r0
 8017848: 2b00         	cmp	r3, #0x0
 801784a: d01d         	beq	0x8017888 <halt_thread+0x78> @ imm = #0x3a
 801784c: 687b         	ldr	r3, [r7, #0x4]
 801784e: 653b         	str	r3, [r7, #0x50]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 8017850: 6d3b         	ldr	r3, [r7, #0x50]
 8017852: 7b5b         	ldrb	r3, [r3, #0xd]
 8017854: f003 037f    	and	r3, r3, #0x7f
 8017858: b2da         	uxtb	r2, r3
 801785a: 6d3b         	ldr	r3, [r7, #0x50]
 801785c: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 801785e: 6d38         	ldr	r0, [r7, #0x50]
 8017860: f010 ff5a    	bl	0x8028718 <should_queue_thread> @ imm = #0x10eb4
 8017864: 4603         	mov	r3, r0
 8017866: 2b00         	cmp	r3, #0x0
 8017868: d00d         	beq	0x8017886 <halt_thread+0x76> @ imm = #0x1a
 801786a: 6d3b         	ldr	r3, [r7, #0x50]
 801786c: 64fb         	str	r3, [r7, #0x4c]
 801786e: 6cfb         	ldr	r3, [r7, #0x4c]
 8017870: 64bb         	str	r3, [r7, #0x48]
; 	return &_kernel.ready_q.runq;
 8017872: 4b58         	ldr	r3, [pc, #0x160]        @ 0x80179d4 <halt_thread+0x1c4>
 8017874: 647b         	str	r3, [r7, #0x44]
 8017876: 6cfb         	ldr	r3, [r7, #0x4c]
 8017878: 643b         	str	r3, [r7, #0x40]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 801787a: 6c3b         	ldr	r3, [r7, #0x40]
 801787c: 4618         	mov	r0, r3
 801787e: f010 fd80    	bl	0x8028382 <sys_dlist_remove> @ imm = #0x10b00
; }
 8017882: bf00         	nop
; }
 8017884: bf00         	nop
; }
 8017886: bf00         	nop
; 		if (new_state == _THREAD_DEAD) {
 8017888: 78fb         	ldrb	r3, [r7, #0x3]
 801788a: 2b08         	cmp	r3, #0x8
 801788c: d123         	bne	0x80178d6 <halt_thread+0xc6> @ imm = #0x46
; 			if (thread->base.pended_on != NULL) {
 801788e: 687b         	ldr	r3, [r7, #0x4]
 8017890: 689b         	ldr	r3, [r3, #0x8]
 8017892: 2b00         	cmp	r3, #0x0
 8017894: d002         	beq	0x801789c <halt_thread+0x8c> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 8017896: 6878         	ldr	r0, [r7, #0x4]
 8017898: f010 fed0    	bl	0x802863c <unpend_thread_no_timeout> @ imm = #0x10da0
; 			(void)z_abort_thread_timeout(thread);
 801789c: 6878         	ldr	r0, [r7, #0x4]
 801789e: f010 fdb0    	bl	0x8028402 <z_abort_thread_timeout> @ imm = #0x10b60
; 			unpend_all(&thread->join_queue);
 80178a2: 687b         	ldr	r3, [r7, #0x4]
 80178a4: 3368         	adds	r3, #0x68
 80178a6: 4618         	mov	r0, r3
 80178a8: f011 f90c    	bl	0x8028ac4 <unpend_all>  @ imm = #0x11218
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80178ac: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x80179d8 <halt_thread+0x1c8>
 80178ae: 689b         	ldr	r3, [r3, #0x8]
 80178b0: 63fb         	str	r3, [r7, #0x3c]
; 	return ret;
 80178b2: 6bfb         	ldr	r3, [r7, #0x3c]
; 			if (thread == arch_current_thread() && arch_is_in_isr()) {
 80178b4: 687a         	ldr	r2, [r7, #0x4]
 80178b6: 429a         	cmp	r2, r3
 80178b8: d10d         	bne	0x80178d6 <halt_thread+0xc6> @ imm = #0x1a
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80178ba: f3ef 8305    	mrs	r3, ipsr
 80178be: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 80178c0: 6bbb         	ldr	r3, [r7, #0x38]
; 	return (__get_IPSR()) ? (true) : (false);
 80178c2: 2b00         	cmp	r3, #0x0
 80178c4: bf14         	ite	ne
 80178c6: 2301         	movne	r3, #0x1
 80178c8: 2300         	moveq	r3, #0x0
 80178ca: b2db         	uxtb	r3, r3
; 			if (thread == arch_current_thread() && arch_is_in_isr()) {
 80178cc: 2b00         	cmp	r3, #0x0
 80178ce: d002         	beq	0x80178d6 <halt_thread+0xc6> @ imm = #0x4
; 				dummify = true;
 80178d0: 2301         	movs	r3, #0x1
 80178d2: f887 3057    	strb.w	r3, [r7, #0x57]
 80178d6: 2301         	movs	r3, #0x1
 80178d8: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 80178da: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x80179d4 <halt_thread+0x1c4>
 80178dc: 633b         	str	r3, [r7, #0x30]
; 	struct k_thread *thread = NULL;
 80178de: 2300         	movs	r3, #0x0
 80178e0: 62fb         	str	r3, [r7, #0x2c]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 80178e2: 6b38         	ldr	r0, [r7, #0x30]
 80178e4: f010 fce0    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x109c0
 80178e8: 62b8         	str	r0, [r7, #0x28]
; 	if (n != NULL) {
 80178ea: 6abb         	ldr	r3, [r7, #0x28]
 80178ec: 2b00         	cmp	r3, #0x0
 80178ee: d001         	beq	0x80178f4 <halt_thread+0xe4> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 80178f0: 6abb         	ldr	r3, [r7, #0x28]
 80178f2: 62fb         	str	r3, [r7, #0x2c]
; 	return thread;
 80178f4: 6afb         	ldr	r3, [r7, #0x2c]
; 	return _priq_run_best(curr_cpu_runq());
 80178f6: bf00         	nop
; 	struct k_thread *thread = runq_best();
 80178f8: 627b         	str	r3, [r7, #0x24]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 80178fa: 6a7b         	ldr	r3, [r7, #0x24]
 80178fc: 2b00         	cmp	r3, #0x0
 80178fe: d102         	bne	0x8017906 <halt_thread+0xf6> @ imm = #0x4
 8017900: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80179d8 <halt_thread+0x1c8>
 8017902: 68db         	ldr	r3, [r3, #0xc]
 8017904: e000         	b	0x8017908 <halt_thread+0xf8> @ imm = #0x0
 8017906: 6a7b         	ldr	r3, [r7, #0x24]
; 	struct k_thread *thread = next_up();
 8017908: 623b         	str	r3, [r7, #0x20]
 801790a: 6a3b         	ldr	r3, [r7, #0x20]
 801790c: 61fb         	str	r3, [r7, #0x1c]
 801790e: 6b7b         	ldr	r3, [r7, #0x34]
 8017910: 61bb         	str	r3, [r7, #0x18]
; 	if (preempt_ok != 0) {
 8017912: 69bb         	ldr	r3, [r7, #0x18]
 8017914: 2b00         	cmp	r3, #0x0
 8017916: d001         	beq	0x801791c <halt_thread+0x10c> @ imm = #0x2
; 		return true;
 8017918: 2301         	movs	r3, #0x1
 801791a: e026         	b	0x801796a <halt_thread+0x15a> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801791c: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x80179d8 <halt_thread+0x1c8>
 801791e: 689b         	ldr	r3, [r3, #0x8]
 8017920: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 8017922: 697b         	ldr	r3, [r7, #0x14]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8017924: 4618         	mov	r0, r3
 8017926: f010 fda9    	bl	0x802847c <z_is_thread_prevented_from_running> @ imm = #0x10b52
 801792a: 4603         	mov	r3, r0
 801792c: 2b00         	cmp	r3, #0x0
 801792e: d001         	beq	0x8017934 <halt_thread+0x124> @ imm = #0x2
; 		return true;
 8017930: 2301         	movs	r3, #0x1
 8017932: e01a         	b	0x801796a <halt_thread+0x15a> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017934: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x80179d8 <halt_thread+0x1c8>
 8017936: 689b         	ldr	r3, [r3, #0x8]
 8017938: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 801793a: 693b         	ldr	r3, [r7, #0x10]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 801793c: 4618         	mov	r0, r3
 801793e: f010 fd6e    	bl	0x802841e <thread_is_preemptible> @ imm = #0x10adc
 8017942: 4603         	mov	r3, r0
 8017944: 2b00         	cmp	r3, #0x0
 8017946: d105         	bne	0x8017954 <halt_thread+0x144> @ imm = #0xa
 8017948: 69f8         	ldr	r0, [r7, #0x1c]
 801794a: f010 fd79    	bl	0x8028440 <thread_is_metairq> @ imm = #0x10af2
 801794e: 4603         	mov	r3, r0
 8017950: 2b00         	cmp	r3, #0x0
 8017952: d001         	beq	0x8017958 <halt_thread+0x148> @ imm = #0x2
; 		return true;
 8017954: 2301         	movs	r3, #0x1
 8017956: e008         	b	0x801796a <halt_thread+0x15a> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8017958: 69f8         	ldr	r0, [r7, #0x1c]
 801795a: f010 fda4    	bl	0x80284a6 <z_is_thread_timeout_active> @ imm = #0x10b48
 801795e: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8017960: 2b00         	cmp	r3, #0x0
 8017962: d001         	beq	0x8017968 <halt_thread+0x158> @ imm = #0x2
; 		return true;
 8017964: 2301         	movs	r3, #0x1
 8017966: e000         	b	0x801796a <halt_thread+0x15a> @ imm = #0x0
; 	return false;
 8017968: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 801796a: 2b00         	cmp	r3, #0x0
 801796c: d010         	beq	0x8017990 <halt_thread+0x180> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801796e: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x80179d8 <halt_thread+0x1c8>
 8017970: 689b         	ldr	r3, [r3, #0x8]
 8017972: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8017974: 68fb         	ldr	r3, [r7, #0xc]
; 		if (thread != arch_current_thread()) {
 8017976: 6a3a         	ldr	r2, [r7, #0x20]
 8017978: 429a         	cmp	r2, r3
 801797a: d002         	beq	0x8017982 <halt_thread+0x172> @ imm = #0x4
; 			z_reset_time_slice(thread);
 801797c: 6a38         	ldr	r0, [r7, #0x20]
 801797e: f000 f9b3    	bl	0x8017ce8 <z_reset_time_slice> @ imm = #0x366
; 		update_metairq_preempt(thread);
 8017982: 6a38         	ldr	r0, [r7, #0x20]
 8017984: f010 ff0f    	bl	0x80287a6 <update_metairq_preempt> @ imm = #0x10e1e
; 		_kernel.ready_q.cache = thread;
 8017988: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x80179d8 <halt_thread+0x1c8>
 801798a: 6a3b         	ldr	r3, [r7, #0x20]
 801798c: 6213         	str	r3, [r2, #0x20]
; }
 801798e: e005         	b	0x801799c <halt_thread+0x18c> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017990: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80179d8 <halt_thread+0x1c8>
 8017992: 689b         	ldr	r3, [r3, #0x8]
 8017994: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 8017996: 68bb         	ldr	r3, [r7, #0x8]
; 		_kernel.ready_q.cache = arch_current_thread();
 8017998: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x80179d8 <halt_thread+0x1c8>
 801799a: 6213         	str	r3, [r2, #0x20]
; }
 801799c: bf00         	nop
; 		if (new_state == _THREAD_SUSPENDED) {
 801799e: 78fb         	ldrb	r3, [r7, #0x3]
 80179a0: 2b10         	cmp	r3, #0x10
 80179a2: d103         	bne	0x80179ac <halt_thread+0x19c> @ imm = #0x6
; 			clear_halting(thread);
 80179a4: 6878         	ldr	r0, [r7, #0x4]
 80179a6: f010 fee8    	bl	0x802877a <clear_halting> @ imm = #0x10dd0
; 			return;
 80179aa: e00f         	b	0x80179cc <halt_thread+0x1bc> @ imm = #0x1e
; 		arch_float_disable(thread);
 80179ac: 6878         	ldr	r0, [r7, #0x4]
 80179ae: f7ee fea1    	bl	0x80066f4 <arch_float_disable> @ imm = #-0x112be
; 		z_thread_monitor_exit(thread);
 80179b2: 6878         	ldr	r0, [r7, #0x4]
 80179b4: f000 fa4e    	bl	0x8017e54 <z_thread_monitor_exit> @ imm = #0x49c
; 		if (dummify && !IS_ENABLED(CONFIG_ARCH_POSIX)) {
 80179b8: f897 3057    	ldrb.w	r3, [r7, #0x57]
 80179bc: 2b00         	cmp	r3, #0x0
 80179be: d002         	beq	0x80179c6 <halt_thread+0x1b6> @ imm = #0x4
; 			z_dummy_thread_init(&_thread_dummy);
 80179c0: 4806         	ldr	r0, [pc, #0x18]         @ 0x80179dc <halt_thread+0x1cc>
 80179c2: f7fe fc39    	bl	0x8016238 <z_dummy_thread_init> @ imm = #-0x178e
; 		clear_halting(thread);
 80179c6: 6878         	ldr	r0, [r7, #0x4]
 80179c8: f010 fed7    	bl	0x802877a <clear_halting> @ imm = #0x10dae
; }
 80179cc: 3758         	adds	r7, #0x58
 80179ce: 46bd         	mov	sp, r7
 80179d0: bd80         	pop	{r7, pc}
 80179d2: bf00         	nop

080179d4 <$d>:
 80179d4: 84 20 00 24  	.word	0x24002084
 80179d8: 60 20 00 24  	.word	0x24002060
 80179dc: 10 24 00 24  	.word	0x24002410

080179e0 <z_thread_abort>:
; {
 80179e0: b580         	push	{r7, lr}
 80179e2: b094         	sub	sp, #0x50
 80179e4: af00         	add	r7, sp, #0x0
 80179e6: 6078         	str	r0, [r7, #0x4]
 80179e8: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8017aac <z_thread_abort+0xcc>
 80179ea: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80179ec: f3ef 8311    	mrs	r3, basepri
 80179f0: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 80179f2: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 80179f4: 647b         	str	r3, [r7, #0x44]
 80179f6: 2310         	movs	r3, #0x10
 80179f8: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80179fa: 6c3b         	ldr	r3, [r7, #0x40]
 80179fc: f383 8812    	msr	basepri_max, r3
; }
 8017a00: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017a02: f3bf 8f6f    	isb	sy
; }
 8017a06: bf00         	nop
; 	return key;
 8017a08: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 8017a0a: 60bb         	str	r3, [r7, #0x8]
 8017a0c: 6cfb         	ldr	r3, [r7, #0x4c]
 8017a0e: 63fb         	str	r3, [r7, #0x3c]
; }
 8017a10: bf00         	nop
 8017a12: 6cfb         	ldr	r3, [r7, #0x4c]
 8017a14: 63bb         	str	r3, [r7, #0x38]
; }
 8017a16: bf00         	nop
; 	return k;
 8017a18: 68bb         	ldr	r3, [r7, #0x8]
 8017a1a: 617b         	str	r3, [r7, #0x14]
; 	if (z_is_thread_essential(thread)) {
 8017a1c: 6878         	ldr	r0, [r7, #0x4]
 8017a1e: f010 fde1    	bl	0x80285e4 <z_is_thread_essential> @ imm = #0x10bc2
 8017a22: 4603         	mov	r3, r0
 8017a24: 2b00         	cmp	r3, #0x0
 8017a26: d020         	beq	0x8017a6a <z_thread_abort+0x8a> @ imm = #0x40
 8017a28: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8017aac <z_thread_abort+0xcc>
 8017a2a: 62fb         	str	r3, [r7, #0x2c]
 8017a2c: 697b         	ldr	r3, [r7, #0x14]
 8017a2e: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8017a30: 68fb         	ldr	r3, [r7, #0xc]
 8017a32: 62bb         	str	r3, [r7, #0x28]
 8017a34: 6abb         	ldr	r3, [r7, #0x28]
 8017a36: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017a38: 6a7b         	ldr	r3, [r7, #0x24]
 8017a3a: f383 8811    	msr	basepri, r3
; }
 8017a3e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017a40: f3bf 8f6f    	isb	sy
; }
 8017a44: bf00         	nop
; }
 8017a46: bf00         	nop
; }
 8017a48: bf00         	nop
 8017a4a: 2300         	movs	r3, #0x0
 8017a4c: 637b         	str	r3, [r7, #0x34]
 8017a4e: 6b7b         	ldr	r3, [r7, #0x34]
 8017a50: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017a52: 6b3b         	ldr	r3, [r7, #0x30]
 8017a54: f383 8811    	msr	basepri, r3
; }
 8017a58: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017a5a: f3bf 8f6f    	isb	sy
; }
 8017a5e: bf00         	nop
; }
 8017a60: bf00         	nop
; 		k_panic();
 8017a62: 2304         	movs	r3, #0x4
 8017a64: 4618         	mov	r0, r3
 8017a66: df02         	svc	#0x2
; 		return;
 8017a68: e01c         	b	0x8017aa4 <z_thread_abort+0xc4> @ imm = #0x38
; 	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 8017a6a: 687b         	ldr	r3, [r7, #0x4]
 8017a6c: 7b5b         	ldrb	r3, [r3, #0xd]
 8017a6e: f003 0308    	and	r3, r3, #0x8
 8017a72: 2b00         	cmp	r3, #0x0
 8017a74: d011         	beq	0x8017a9a <z_thread_abort+0xba> @ imm = #0x22
 8017a76: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8017aac <z_thread_abort+0xcc>
 8017a78: 623b         	str	r3, [r7, #0x20]
 8017a7a: 697b         	ldr	r3, [r7, #0x14]
 8017a7c: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8017a7e: 693b         	ldr	r3, [r7, #0x10]
 8017a80: 61fb         	str	r3, [r7, #0x1c]
 8017a82: 69fb         	ldr	r3, [r7, #0x1c]
 8017a84: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017a86: 69bb         	ldr	r3, [r7, #0x18]
 8017a88: f383 8811    	msr	basepri, r3
; }
 8017a8c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017a8e: f3bf 8f6f    	isb	sy
; }
 8017a92: bf00         	nop
; }
 8017a94: bf00         	nop
; }
 8017a96: bf00         	nop
; 		return;
 8017a98: e004         	b	0x8017aa4 <z_thread_abort+0xc4> @ imm = #0x8
; 	z_thread_halt(thread, key, true);
 8017a9a: 2201         	movs	r2, #0x1
 8017a9c: 6979         	ldr	r1, [r7, #0x14]
 8017a9e: 6878         	ldr	r0, [r7, #0x4]
 8017aa0: f7fe fe5c    	bl	0x801675c <z_thread_halt> @ imm = #-0x1348
; }
 8017aa4: 3750         	adds	r7, #0x50
 8017aa6: 46bd         	mov	sp, r7
 8017aa8: bd80         	pop	{r7, pc}
 8017aaa: bf00         	nop

08017aac <$d>:
 8017aac: d8 32 00 24  	.word	0x240032d8

08017ab0 <z_sched_wake>:
; {
 8017ab0: b580         	push	{r7, lr}
 8017ab2: b09c         	sub	sp, #0x70
 8017ab4: af00         	add	r7, sp, #0x0
 8017ab6: 60f8         	str	r0, [r7, #0xc]
 8017ab8: 60b9         	str	r1, [r7, #0x8]
 8017aba: 607a         	str	r2, [r7, #0x4]
; 	bool ret = false;
 8017abc: 2300         	movs	r3, #0x0
 8017abe: f887 306f    	strb.w	r3, [r7, #0x6f]
; 	K_SPINLOCK(&_sched_spinlock) {
 8017ac2: 2300         	movs	r3, #0x0
 8017ac4: 623b         	str	r3, [r7, #0x20]
 8017ac6: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8017b98 <z_sched_wake+0xe8>
 8017ac8: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8017aca: f3ef 8311    	mrs	r3, basepri
 8017ace: 663b         	str	r3, [r7, #0x60]
;   return(result);
 8017ad0: 6e3b         	ldr	r3, [r7, #0x60]
; 	key = __get_BASEPRI();
 8017ad2: 65fb         	str	r3, [r7, #0x5c]
 8017ad4: 2310         	movs	r3, #0x10
 8017ad6: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8017ad8: 6dbb         	ldr	r3, [r7, #0x58]
 8017ada: f383 8812    	msr	basepri_max, r3
; }
 8017ade: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017ae0: f3bf 8f6f    	isb	sy
; }
 8017ae4: bf00         	nop
; 	return key;
 8017ae6: 6dfb         	ldr	r3, [r7, #0x5c]
; 	k.key = arch_irq_lock();
 8017ae8: 617b         	str	r3, [r7, #0x14]
 8017aea: 6e7b         	ldr	r3, [r7, #0x64]
 8017aec: 657b         	str	r3, [r7, #0x54]
; }
 8017aee: bf00         	nop
 8017af0: 6e7b         	ldr	r3, [r7, #0x64]
 8017af2: 653b         	str	r3, [r7, #0x50]
; }
 8017af4: bf00         	nop
; 	return k;
 8017af6: 697b         	ldr	r3, [r7, #0x14]
 8017af8: 61fb         	str	r3, [r7, #0x1c]
; 	K_SPINLOCK(&_sched_spinlock) {
 8017afa: e043         	b	0x8017b84 <z_sched_wake+0xd4> @ imm = #0x86
; 		thread = _priq_wait_best(&wait_q->waitq);
 8017afc: 68fb         	ldr	r3, [r7, #0xc]
 8017afe: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 8017b00: 2300         	movs	r3, #0x0
 8017b02: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8017b04: 6cf8         	ldr	r0, [r7, #0x4c]
 8017b06: f010 fbcf    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #0x1079e
 8017b0a: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8017b0c: 6c7b         	ldr	r3, [r7, #0x44]
 8017b0e: 2b00         	cmp	r3, #0x0
 8017b10: d001         	beq	0x8017b16 <z_sched_wake+0x66> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8017b12: 6c7b         	ldr	r3, [r7, #0x44]
 8017b14: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 8017b16: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8017b18: 66bb         	str	r3, [r7, #0x68]
; 		if (thread != NULL) {
 8017b1a: 6ebb         	ldr	r3, [r7, #0x68]
 8017b1c: 2b00         	cmp	r3, #0x0
 8017b1e: d01e         	beq	0x8017b5e <z_sched_wake+0xae> @ imm = #0x3c
; 			z_thread_return_value_set_with_data(thread,
 8017b20: 68bb         	ldr	r3, [r7, #0x8]
 8017b22: 6eba         	ldr	r2, [r7, #0x68]
 8017b24: 643a         	str	r2, [r7, #0x40]
 8017b26: 63fb         	str	r3, [r7, #0x3c]
 8017b28: 687b         	ldr	r3, [r7, #0x4]
 8017b2a: 63bb         	str	r3, [r7, #0x38]
 8017b2c: 6c3b         	ldr	r3, [r7, #0x40]
 8017b2e: 637b         	str	r3, [r7, #0x34]
 8017b30: 6bfb         	ldr	r3, [r7, #0x3c]
 8017b32: 633b         	str	r3, [r7, #0x30]
; 	thread->arch.swap_return_value = value;
 8017b34: 6b7b         	ldr	r3, [r7, #0x34]
 8017b36: 6b3a         	ldr	r2, [r7, #0x30]
 8017b38: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8017b3c: bf00         	nop
; 	thread->base.swap_data = data;
 8017b3e: 6c3b         	ldr	r3, [r7, #0x40]
 8017b40: 6bba         	ldr	r2, [r7, #0x38]
 8017b42: 615a         	str	r2, [r3, #0x14]
; }
 8017b44: bf00         	nop
; 			unpend_thread_no_timeout(thread);
 8017b46: 6eb8         	ldr	r0, [r7, #0x68]
 8017b48: f010 fd78    	bl	0x802863c <unpend_thread_no_timeout> @ imm = #0x10af0
; 			(void)z_abort_thread_timeout(thread);
 8017b4c: 6eb8         	ldr	r0, [r7, #0x68]
 8017b4e: f010 fc58    	bl	0x8028402 <z_abort_thread_timeout> @ imm = #0x108b0
; 			ready_thread(thread);
 8017b52: 6eb8         	ldr	r0, [r7, #0x68]
 8017b54: f7fe fc82    	bl	0x801645c <ready_thread> @ imm = #-0x16fc
; 			ret = true;
 8017b58: 2301         	movs	r3, #0x1
 8017b5a: f887 306f    	strb.w	r3, [r7, #0x6f]
 8017b5e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8017b98 <z_sched_wake+0xe8>
 8017b60: 62fb         	str	r3, [r7, #0x2c]
 8017b62: 69fb         	ldr	r3, [r7, #0x1c]
 8017b64: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8017b66: 69bb         	ldr	r3, [r7, #0x18]
 8017b68: 62bb         	str	r3, [r7, #0x28]
 8017b6a: 6abb         	ldr	r3, [r7, #0x28]
 8017b6c: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017b6e: 6a7b         	ldr	r3, [r7, #0x24]
 8017b70: f383 8811    	msr	basepri, r3
; }
 8017b74: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017b76: f3bf 8f6f    	isb	sy
; }
 8017b7a: bf00         	nop
; }
 8017b7c: bf00         	nop
; }
 8017b7e: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 8017b80: 2301         	movs	r3, #0x1
 8017b82: 623b         	str	r3, [r7, #0x20]
 8017b84: 6a3b         	ldr	r3, [r7, #0x20]
 8017b86: 2b00         	cmp	r3, #0x0
 8017b88: d0b8         	beq	0x8017afc <z_sched_wake+0x4c> @ imm = #-0x90
; 	return ret;
 8017b8a: f897 306f    	ldrb.w	r3, [r7, #0x6f]
; }
 8017b8e: 4618         	mov	r0, r3
 8017b90: 3770         	adds	r7, #0x70
 8017b92: 46bd         	mov	sp, r7
 8017b94: bd80         	pop	{r7, pc}
 8017b96: bf00         	nop

08017b98 <$d>:
 8017b98: d8 32 00 24  	.word	0x240032d8

08017b9c <z_sched_wait>:
; {
 8017b9c: b580         	push	{r7, lr}
 8017b9e: b088         	sub	sp, #0x20
 8017ba0: af02         	add	r7, sp, #0x8
 8017ba2: 60f8         	str	r0, [r7, #0xc]
 8017ba4: 60b9         	str	r1, [r7, #0x8]
 8017ba6: 607a         	str	r2, [r7, #0x4]
; 	int ret = z_pend_curr(lock, key, wait_q, timeout);
 8017ba8: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 8017bac: e9cd 2300    	strd	r2, r3, [sp]
 8017bb0: 687a         	ldr	r2, [r7, #0x4]
 8017bb2: 68b9         	ldr	r1, [r7, #0x8]
 8017bb4: 68f8         	ldr	r0, [r7, #0xc]
 8017bb6: f7ff f927    	bl	0x8016e08 <z_pend_curr> @ imm = #-0xdb2
 8017bba: 6178         	str	r0, [r7, #0x14]
; 	if (data != NULL) {
 8017bbc: 6abb         	ldr	r3, [r7, #0x28]
 8017bbe: 2b00         	cmp	r3, #0x0
 8017bc0: d006         	beq	0x8017bd0 <z_sched_wait+0x34> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017bc2: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8017bdc <z_sched_wait+0x40>
 8017bc4: 689b         	ldr	r3, [r3, #0x8]
 8017bc6: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 8017bc8: 693b         	ldr	r3, [r7, #0x10]
; 		*data = arch_current_thread()->base.swap_data;
 8017bca: 695a         	ldr	r2, [r3, #0x14]
 8017bcc: 6abb         	ldr	r3, [r7, #0x28]
 8017bce: 601a         	str	r2, [r3]
; 	return ret;
 8017bd0: 697b         	ldr	r3, [r7, #0x14]
; }
 8017bd2: 4618         	mov	r0, r3
 8017bd4: 3718         	adds	r7, #0x18
 8017bd6: 46bd         	mov	sp, r7
 8017bd8: bd80         	pop	{r7, pc}
 8017bda: bf00         	nop

08017bdc <$d>:
 8017bdc: 60 20 00 24  	.word	0x24002060

08017be0 <z_is_idle_thread_object>:
; {
 8017be0: b480         	push	{r7}
 8017be2: b083         	sub	sp, #0xc
 8017be4: af00         	add	r7, sp, #0x0
 8017be6: 6078         	str	r0, [r7, #0x4]
; 	return thread == &z_idle_threads[0];
 8017be8: 687b         	ldr	r3, [r7, #0x4]
 8017bea: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8017c04 <z_is_idle_thread_object+0x24>
 8017bec: 4293         	cmp	r3, r2
 8017bee: bf0c         	ite	eq
 8017bf0: 2301         	moveq	r3, #0x1
 8017bf2: 2300         	movne	r3, #0x0
 8017bf4: b2db         	uxtb	r3, r3
; }
 8017bf6: 4618         	mov	r0, r3
 8017bf8: 370c         	adds	r7, #0xc
 8017bfa: 46bd         	mov	sp, r7
 8017bfc: f85d 7b04    	ldr	r7, [sp], #4
 8017c00: 4770         	bx	lr
 8017c02: bf00         	nop

08017c04 <$d>:
 8017c04: c0 21 00 24  	.word	0x240021c0

08017c08 <slice_time>:
; {
 8017c08: b480         	push	{r7}
 8017c0a: b085         	sub	sp, #0x14
 8017c0c: af00         	add	r7, sp, #0x0
 8017c0e: 6078         	str	r0, [r7, #0x4]
; 	int ret = slice_ticks;
 8017c10: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8017c24 <slice_time+0x1c>
 8017c12: 681b         	ldr	r3, [r3]
 8017c14: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8017c16: 68fb         	ldr	r3, [r7, #0xc]
; }
 8017c18: 4618         	mov	r0, r3
 8017c1a: 3714         	adds	r7, #0x14
 8017c1c: 46bd         	mov	sp, r7
 8017c1e: f85d 7b04    	ldr	r7, [sp], #4
 8017c22: 4770         	bx	lr

08017c24 <$d>:
 8017c24: d8 32 00 24  	.word	0x240032d8

08017c28 <thread_is_sliceable>:
; {
 8017c28: b580         	push	{r7, lr}
 8017c2a: b084         	sub	sp, #0x10
 8017c2c: af00         	add	r7, sp, #0x0
 8017c2e: 6078         	str	r0, [r7, #0x4]
; 	bool ret = thread_is_preemptible(thread)
 8017c30: 6878         	ldr	r0, [r7, #0x4]
 8017c32: f010 ff6e    	bl	0x8028b12 <thread_is_preemptible> @ imm = #0x10edc
 8017c36: 4603         	mov	r3, r0
; 		&& !z_is_idle_thread_object(thread);
 8017c38: 2b00         	cmp	r3, #0x0
 8017c3a: d029         	beq	0x8017c90 <thread_is_sliceable+0x68> @ imm = #0x52
; 		&& slice_time(thread) != 0
 8017c3c: 6878         	ldr	r0, [r7, #0x4]
 8017c3e: f7ff ffe3    	bl	0x8017c08 <slice_time>  @ imm = #-0x3a
 8017c42: 4603         	mov	r3, r0
 8017c44: 2b00         	cmp	r3, #0x0
 8017c46: d023         	beq	0x8017c90 <thread_is_sliceable+0x68> @ imm = #0x46
; 		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 8017c48: 687b         	ldr	r3, [r7, #0x4]
 8017c4a: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8017c4e: 461a         	mov	r2, r3
 8017c50: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8017ca8 <thread_is_sliceable+0x80>
 8017c52: 681b         	ldr	r3, [r3]
 8017c54: 4619         	mov	r1, r3
 8017c56: 4610         	mov	r0, r2
 8017c58: f010 ff93    	bl	0x8028b82 <z_is_prio_higher> @ imm = #0x10f26
 8017c5c: 4603         	mov	r3, r0
 8017c5e: f083 0301    	eor	r3, r3, #0x1
 8017c62: b2db         	uxtb	r3, r3
 8017c64: 2b00         	cmp	r3, #0x0
 8017c66: d013         	beq	0x8017c90 <thread_is_sliceable+0x68> @ imm = #0x26
; 		&& !z_is_thread_prevented_from_running(thread)
 8017c68: 6878         	ldr	r0, [r7, #0x4]
 8017c6a: f010 ff63    	bl	0x8028b34 <z_is_thread_prevented_from_running> @ imm = #0x10ec6
 8017c6e: 4603         	mov	r3, r0
 8017c70: f083 0301    	eor	r3, r3, #0x1
 8017c74: b2db         	uxtb	r3, r3
 8017c76: 2b00         	cmp	r3, #0x0
 8017c78: d00a         	beq	0x8017c90 <thread_is_sliceable+0x68> @ imm = #0x14
; 		&& !z_is_idle_thread_object(thread);
 8017c7a: 6878         	ldr	r0, [r7, #0x4]
 8017c7c: f7ff ffb0    	bl	0x8017be0 <z_is_idle_thread_object> @ imm = #-0xa0
 8017c80: 4603         	mov	r3, r0
 8017c82: f083 0301    	eor	r3, r3, #0x1
 8017c86: b2db         	uxtb	r3, r3
 8017c88: 2b00         	cmp	r3, #0x0
 8017c8a: d001         	beq	0x8017c90 <thread_is_sliceable+0x68> @ imm = #0x2
 8017c8c: 2301         	movs	r3, #0x1
 8017c8e: e000         	b	0x8017c92 <thread_is_sliceable+0x6a> @ imm = #0x0
 8017c90: 2300         	movs	r3, #0x0
; 	bool ret = thread_is_preemptible(thread)
 8017c92: 73fb         	strb	r3, [r7, #0xf]
 8017c94: 7bfb         	ldrb	r3, [r7, #0xf]
 8017c96: f003 0301    	and	r3, r3, #0x1
 8017c9a: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 8017c9c: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8017c9e: 4618         	mov	r0, r3
 8017ca0: 3710         	adds	r7, #0x10
 8017ca2: 46bd         	mov	sp, r7
 8017ca4: bd80         	pop	{r7, pc}
 8017ca6: bf00         	nop

08017ca8 <$d>:
 8017ca8: dc 32 00 24  	.word	0x240032dc

08017cac <slice_timeout>:
; {
 8017cac: b480         	push	{r7}
 8017cae: b085         	sub	sp, #0x14
 8017cb0: af00         	add	r7, sp, #0x0
 8017cb2: 6078         	str	r0, [r7, #0x4]
; 	int cpu = ARRAY_INDEX(slice_timeouts, timeout);
 8017cb4: 687b         	ldr	r3, [r7, #0x4]
 8017cb6: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8017cdc <slice_timeout+0x30>
 8017cb8: 1a9b         	subs	r3, r3, r2
 8017cba: 10db         	asrs	r3, r3, #0x3
 8017cbc: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8017ce0 <slice_timeout+0x34>
 8017cbe: fb02 f303    	mul	r3, r2, r3
 8017cc2: 60fb         	str	r3, [r7, #0xc]
; 	slice_expired[cpu] = true;
 8017cc4: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8017ce4 <slice_timeout+0x38>
 8017cc6: 68fb         	ldr	r3, [r7, #0xc]
 8017cc8: 4413         	add	r3, r2
 8017cca: 2201         	movs	r2, #0x1
 8017ccc: 701a         	strb	r2, [r3]
; }
 8017cce: bf00         	nop
 8017cd0: 3714         	adds	r7, #0x14
 8017cd2: 46bd         	mov	sp, r7
 8017cd4: f85d 7b04    	ldr	r7, [sp], #4
 8017cd8: 4770         	bx	lr
 8017cda: bf00         	nop

08017cdc <$d>:
 8017cdc: 28 25 00 24  	.word	0x24002528
 8017ce0: ab aa aa aa  	.word	0xaaaaaaab
 8017ce4: e0 32 00 24  	.word	0x240032e0

08017ce8 <z_reset_time_slice>:
; {
 8017ce8: e92d 4390    	push.w	{r4, r7, r8, r9, lr}
 8017cec: b085         	sub	sp, #0x14
 8017cee: af00         	add	r7, sp, #0x0
 8017cf0: 6078         	str	r0, [r7, #0x4]
; 	int cpu = _current_cpu->id;
 8017cf2: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8017d58 <z_reset_time_slice+0x70>
 8017cf4: 7c1b         	ldrb	r3, [r3, #0x10]
 8017cf6: 60fb         	str	r3, [r7, #0xc]
; 	z_abort_timeout(&slice_timeouts[cpu]);
 8017cf8: 68fa         	ldr	r2, [r7, #0xc]
 8017cfa: 4613         	mov	r3, r2
 8017cfc: 005b         	lsls	r3, r3, #0x1
 8017cfe: 4413         	add	r3, r2
 8017d00: 00db         	lsls	r3, r3, #0x3
 8017d02: 4a16         	ldr	r2, [pc, #0x58]         @ 0x8017d5c <z_reset_time_slice+0x74>
 8017d04: 4413         	add	r3, r2
 8017d06: 4618         	mov	r0, r3
 8017d08: f000 faba    	bl	0x8018280 <z_abort_timeout> @ imm = #0x574
; 	slice_expired[cpu] = false;
 8017d0c: 4a14         	ldr	r2, [pc, #0x50]         @ 0x8017d60 <z_reset_time_slice+0x78>
 8017d0e: 68fb         	ldr	r3, [r7, #0xc]
 8017d10: 4413         	add	r3, r2
 8017d12: 2200         	movs	r2, #0x0
 8017d14: 701a         	strb	r2, [r3]
; 	if (thread_is_sliceable(thread)) {
 8017d16: 6878         	ldr	r0, [r7, #0x4]
 8017d18: f7ff ff86    	bl	0x8017c28 <thread_is_sliceable> @ imm = #-0xf4
 8017d1c: 4603         	mov	r3, r0
 8017d1e: 2b00         	cmp	r3, #0x0
 8017d20: d014         	beq	0x8017d4c <z_reset_time_slice+0x64> @ imm = #0x28
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 8017d22: 68fa         	ldr	r2, [r7, #0xc]
 8017d24: 4613         	mov	r3, r2
 8017d26: 005b         	lsls	r3, r3, #0x1
 8017d28: 4413         	add	r3, r2
 8017d2a: 00db         	lsls	r3, r3, #0x3
 8017d2c: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8017d5c <z_reset_time_slice+0x74>
 8017d2e: 189c         	adds	r4, r3, r2
; 			      K_TICKS(slice_time(thread) - 1));
 8017d30: 6878         	ldr	r0, [r7, #0x4]
 8017d32: f7ff ff69    	bl	0x8017c08 <slice_time>  @ imm = #-0x12e
 8017d36: 4603         	mov	r3, r0
 8017d38: 3b01         	subs	r3, #0x1
 8017d3a: 17da         	asrs	r2, r3, #0x1f
 8017d3c: 4698         	mov	r8, r3
 8017d3e: 4691         	mov	r9, r2
 8017d40: 4642         	mov	r2, r8
 8017d42: 464b         	mov	r3, r9
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 8017d44: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8017d64 <z_reset_time_slice+0x7c>
 8017d46: 4620         	mov	r0, r4
 8017d48: f000 f9a6    	bl	0x8018098 <z_add_timeout> @ imm = #0x34c
; }
 8017d4c: bf00         	nop
 8017d4e: 3714         	adds	r7, #0x14
 8017d50: 46bd         	mov	sp, r7
 8017d52: e8bd 8390    	pop.w	{r4, r7, r8, r9, pc}
 8017d56: bf00         	nop

08017d58 <$d>:
 8017d58: 60 20 00 24  	.word	0x24002060
 8017d5c: 28 25 00 24  	.word	0x24002528
 8017d60: e0 32 00 24  	.word	0x240032e0
 8017d64: ad 7c 01 08  	.word	0x08017cad

08017d68 <z_time_slice>:
; {
 8017d68: b580         	push	{r7, lr}
 8017d6a: b092         	sub	sp, #0x48
 8017d6c: af00         	add	r7, sp, #0x0
 8017d6e: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8017e44 <z_time_slice+0xdc>
 8017d70: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8017d72: f3ef 8311    	mrs	r3, basepri
 8017d76: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 8017d78: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 8017d7a: 637b         	str	r3, [r7, #0x34]
 8017d7c: 2310         	movs	r3, #0x10
 8017d7e: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8017d80: 6b3b         	ldr	r3, [r7, #0x30]
 8017d82: f383 8812    	msr	basepri_max, r3
; }
 8017d86: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017d88: f3bf 8f6f    	isb	sy
; }
 8017d8c: bf00         	nop
; 	return key;
 8017d8e: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 8017d90: 603b         	str	r3, [r7]
 8017d92: 6bfb         	ldr	r3, [r7, #0x3c]
 8017d94: 62fb         	str	r3, [r7, #0x2c]
; }
 8017d96: bf00         	nop
 8017d98: 6bfb         	ldr	r3, [r7, #0x3c]
 8017d9a: 62bb         	str	r3, [r7, #0x28]
; }
 8017d9c: bf00         	nop
; 	return k;
 8017d9e: 683b         	ldr	r3, [r7]
 8017da0: 60fb         	str	r3, [r7, #0xc]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8017da2: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8017e48 <z_time_slice+0xe0>
 8017da4: 689b         	ldr	r3, [r3, #0x8]
 8017da6: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 8017da8: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *curr = arch_current_thread();
 8017daa: 647b         	str	r3, [r7, #0x44]
; 	if (pending_current == curr) {
 8017dac: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8017e4c <z_time_slice+0xe4>
 8017dae: 681b         	ldr	r3, [r3]
 8017db0: 6c7a         	ldr	r2, [r7, #0x44]
 8017db2: 429a         	cmp	r2, r3
 8017db4: d113         	bne	0x8017dde <z_time_slice+0x76> @ imm = #0x26
; 		z_reset_time_slice(curr);
 8017db6: 6c78         	ldr	r0, [r7, #0x44]
 8017db8: f7ff ff96    	bl	0x8017ce8 <z_reset_time_slice> @ imm = #-0xd4
 8017dbc: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8017e44 <z_time_slice+0xdc>
 8017dbe: 627b         	str	r3, [r7, #0x24]
 8017dc0: 68fb         	ldr	r3, [r7, #0xc]
 8017dc2: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 8017dc4: 687b         	ldr	r3, [r7, #0x4]
 8017dc6: 623b         	str	r3, [r7, #0x20]
 8017dc8: 6a3b         	ldr	r3, [r7, #0x20]
 8017dca: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017dcc: 69fb         	ldr	r3, [r7, #0x1c]
 8017dce: f383 8811    	msr	basepri, r3
; }
 8017dd2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017dd4: f3bf 8f6f    	isb	sy
; }
 8017dd8: bf00         	nop
; }
 8017dda: bf00         	nop
; }
 8017ddc: e02f         	b	0x8017e3e <z_time_slice+0xd6> @ imm = #0x5e
; 	pending_current = NULL;
 8017dde: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8017e4c <z_time_slice+0xe4>
 8017de0: 2200         	movs	r2, #0x0
 8017de2: 601a         	str	r2, [r3]
; 	if (slice_expired[_current_cpu->id] && thread_is_sliceable(curr)) {
 8017de4: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8017e48 <z_time_slice+0xe0>
 8017de6: 7c1b         	ldrb	r3, [r3, #0x10]
 8017de8: 461a         	mov	r2, r3
 8017dea: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8017e50 <z_time_slice+0xe8>
 8017dec: 5c9b         	ldrb	r3, [r3, r2]
 8017dee: 2b00         	cmp	r3, #0x0
 8017df0: d014         	beq	0x8017e1c <z_time_slice+0xb4> @ imm = #0x28
 8017df2: 6c78         	ldr	r0, [r7, #0x44]
 8017df4: f7ff ff18    	bl	0x8017c28 <thread_is_sliceable> @ imm = #-0x1d0
 8017df8: 4603         	mov	r3, r0
 8017dfa: 2b00         	cmp	r3, #0x0
 8017dfc: d00e         	beq	0x8017e1c <z_time_slice+0xb4> @ imm = #0x1c
; 		if (!z_is_thread_prevented_from_running(curr)) {
 8017dfe: 6c78         	ldr	r0, [r7, #0x44]
 8017e00: f010 fe98    	bl	0x8028b34 <z_is_thread_prevented_from_running> @ imm = #0x10d30
 8017e04: 4603         	mov	r3, r0
 8017e06: f083 0301    	eor	r3, r3, #0x1
 8017e0a: b2db         	uxtb	r3, r3
 8017e0c: 2b00         	cmp	r3, #0x0
 8017e0e: d002         	beq	0x8017e16 <z_time_slice+0xae> @ imm = #0x4
; 			move_thread_to_end_of_prio_q(curr);
 8017e10: 6c78         	ldr	r0, [r7, #0x44]
 8017e12: f7fe fa33    	bl	0x801627c <move_thread_to_end_of_prio_q> @ imm = #-0x1b9a
; 		z_reset_time_slice(curr);
 8017e16: 6c78         	ldr	r0, [r7, #0x44]
 8017e18: f7ff ff66    	bl	0x8017ce8 <z_reset_time_slice> @ imm = #-0x134
 8017e1c: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8017e44 <z_time_slice+0xdc>
 8017e1e: 61bb         	str	r3, [r7, #0x18]
 8017e20: 68fb         	ldr	r3, [r7, #0xc]
 8017e22: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8017e24: 68bb         	ldr	r3, [r7, #0x8]
 8017e26: 617b         	str	r3, [r7, #0x14]
 8017e28: 697b         	ldr	r3, [r7, #0x14]
 8017e2a: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017e2c: 693b         	ldr	r3, [r7, #0x10]
 8017e2e: f383 8811    	msr	basepri, r3
; }
 8017e32: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017e34: f3bf 8f6f    	isb	sy
; }
 8017e38: bf00         	nop
; }
 8017e3a: bf00         	nop
; }
 8017e3c: bf00         	nop
; }
 8017e3e: 3748         	adds	r7, #0x48
 8017e40: 46bd         	mov	sp, r7
 8017e42: bd80         	pop	{r7, pc}

08017e44 <$d>:
 8017e44: d8 32 00 24  	.word	0x240032d8
 8017e48: 60 20 00 24  	.word	0x24002060
 8017e4c: e4 32 00 24  	.word	0x240032e4
 8017e50: e0 32 00 24  	.word	0x240032e0

08017e54 <z_thread_monitor_exit>:
; {
 8017e54: b480         	push	{r7}
 8017e56: b091         	sub	sp, #0x44
 8017e58: af00         	add	r7, sp, #0x0
 8017e5a: 6078         	str	r0, [r7, #0x4]
 8017e5c: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8017f0c <z_thread_monitor_exit+0xb8>
 8017e5e: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8017e60: f3ef 8311    	mrs	r3, basepri
 8017e64: 637b         	str	r3, [r7, #0x34]
;   return(result);
 8017e66: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 8017e68: 633b         	str	r3, [r7, #0x30]
 8017e6a: 2310         	movs	r3, #0x10
 8017e6c: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8017e6e: 6afb         	ldr	r3, [r7, #0x2c]
 8017e70: f383 8812    	msr	basepri_max, r3
; }
 8017e74: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017e76: f3bf 8f6f    	isb	sy
; }
 8017e7a: bf00         	nop
; 	return key;
 8017e7c: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 8017e7e: 60fb         	str	r3, [r7, #0xc]
 8017e80: 6bbb         	ldr	r3, [r7, #0x38]
 8017e82: 62bb         	str	r3, [r7, #0x28]
; }
 8017e84: bf00         	nop
 8017e86: 6bbb         	ldr	r3, [r7, #0x38]
 8017e88: 627b         	str	r3, [r7, #0x24]
; }
 8017e8a: bf00         	nop
; 	return k;
 8017e8c: 68fb         	ldr	r3, [r7, #0xc]
 8017e8e: 617b         	str	r3, [r7, #0x14]
; 	if (thread == _kernel.threads) {
 8017e90: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8017f10 <z_thread_monitor_exit+0xbc>
 8017e92: 6b1b         	ldr	r3, [r3, #0x30]
 8017e94: 687a         	ldr	r2, [r7, #0x4]
 8017e96: 429a         	cmp	r2, r3
 8017e98: d106         	bne	0x8017ea8 <z_thread_monitor_exit+0x54> @ imm = #0xc
; 		_kernel.threads = _kernel.threads->next_thread;
 8017e9a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8017f10 <z_thread_monitor_exit+0xbc>
 8017e9c: 6b1b         	ldr	r3, [r3, #0x30]
 8017e9e: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 8017ea2: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8017f10 <z_thread_monitor_exit+0xbc>
 8017ea4: 6313         	str	r3, [r2, #0x30]
 8017ea6: e019         	b	0x8017edc <z_thread_monitor_exit+0x88> @ imm = #0x32
; 		prev_thread = _kernel.threads;
 8017ea8: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8017f10 <z_thread_monitor_exit+0xbc>
 8017eaa: 6b1b         	ldr	r3, [r3, #0x30]
 8017eac: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 8017eae: e003         	b	0x8017eb8 <z_thread_monitor_exit+0x64> @ imm = #0x6
; 			prev_thread = prev_thread->next_thread;
 8017eb0: 6bfb         	ldr	r3, [r7, #0x3c]
 8017eb2: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 8017eb6: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 8017eb8: 6bfb         	ldr	r3, [r7, #0x3c]
 8017eba: 2b00         	cmp	r3, #0x0
 8017ebc: d005         	beq	0x8017eca <z_thread_monitor_exit+0x76> @ imm = #0xa
; 			(thread != prev_thread->next_thread)) {
 8017ebe: 6bfb         	ldr	r3, [r7, #0x3c]
 8017ec0: f8d3 3090    	ldr.w	r3, [r3, #0x90]
; 		while ((prev_thread != NULL) &&
 8017ec4: 687a         	ldr	r2, [r7, #0x4]
 8017ec6: 429a         	cmp	r2, r3
 8017ec8: d1f2         	bne	0x8017eb0 <z_thread_monitor_exit+0x5c> @ imm = #-0x1c
; 		if (prev_thread != NULL) {
 8017eca: 6bfb         	ldr	r3, [r7, #0x3c]
 8017ecc: 2b00         	cmp	r3, #0x0
 8017ece: d005         	beq	0x8017edc <z_thread_monitor_exit+0x88> @ imm = #0xa
; 			prev_thread->next_thread = thread->next_thread;
 8017ed0: 687b         	ldr	r3, [r7, #0x4]
 8017ed2: f8d3 2090    	ldr.w	r2, [r3, #0x90]
 8017ed6: 6bfb         	ldr	r3, [r7, #0x3c]
 8017ed8: f8c3 2090    	str.w	r2, [r3, #0x90]
 8017edc: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8017f0c <z_thread_monitor_exit+0xb8>
 8017ede: 623b         	str	r3, [r7, #0x20]
 8017ee0: 697b         	ldr	r3, [r7, #0x14]
 8017ee2: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8017ee4: 693b         	ldr	r3, [r7, #0x10]
 8017ee6: 61fb         	str	r3, [r7, #0x1c]
 8017ee8: 69fb         	ldr	r3, [r7, #0x1c]
 8017eea: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017eec: 69bb         	ldr	r3, [r7, #0x18]
 8017eee: f383 8811    	msr	basepri, r3
; }
 8017ef2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017ef4: f3bf 8f6f    	isb	sy
; }
 8017ef8: bf00         	nop
; }
 8017efa: bf00         	nop
; }
 8017efc: bf00         	nop
; }
 8017efe: bf00         	nop
 8017f00: 3744         	adds	r7, #0x44
 8017f02: 46bd         	mov	sp, r7
 8017f04: f85d 7b04    	ldr	r7, [sp], #4
 8017f08: 4770         	bx	lr
 8017f0a: bf00         	nop

08017f0c <$d>:
 8017f0c: e8 32 00 24  	.word	0x240032e8
 8017f10: 60 20 00 24  	.word	0x24002060

08017f14 <k_thread_foreach_unlocked>:
; {
 8017f14: b580         	push	{r7, lr}
 8017f16: b09a         	sub	sp, #0x68
 8017f18: af00         	add	r7, sp, #0x0
 8017f1a: 6078         	str	r0, [r7, #0x4]
 8017f1c: 6039         	str	r1, [r7]
 8017f1e: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8017ff0 <k_thread_foreach_unlocked+0xdc>
 8017f20: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8017f22: f3ef 8311    	mrs	r3, basepri
 8017f26: 65fb         	str	r3, [r7, #0x5c]
;   return(result);
 8017f28: 6dfb         	ldr	r3, [r7, #0x5c]
; 	key = __get_BASEPRI();
 8017f2a: 65bb         	str	r3, [r7, #0x58]
 8017f2c: 2310         	movs	r3, #0x10
 8017f2e: 657b         	str	r3, [r7, #0x54]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8017f30: 6d7b         	ldr	r3, [r7, #0x54]
 8017f32: f383 8812    	msr	basepri_max, r3
; }
 8017f36: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017f38: f3bf 8f6f    	isb	sy
; }
 8017f3c: bf00         	nop
; 	return key;
 8017f3e: 6dbb         	ldr	r3, [r7, #0x58]
; 	k.key = arch_irq_lock();
 8017f40: 60bb         	str	r3, [r7, #0x8]
 8017f42: 6e3b         	ldr	r3, [r7, #0x60]
 8017f44: 653b         	str	r3, [r7, #0x50]
; }
 8017f46: bf00         	nop
 8017f48: 6e3b         	ldr	r3, [r7, #0x60]
 8017f4a: 64fb         	str	r3, [r7, #0x4c]
; }
 8017f4c: bf00         	nop
; 	return k;
 8017f4e: 68bb         	ldr	r3, [r7, #0x8]
 8017f50: 61bb         	str	r3, [r7, #0x18]
; 	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
 8017f52: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8017ff4 <k_thread_foreach_unlocked+0xe0>
 8017f54: 6b1b         	ldr	r3, [r3, #0x30]
 8017f56: 667b         	str	r3, [r7, #0x64]
 8017f58: e032         	b	0x8017fc0 <k_thread_foreach_unlocked+0xac> @ imm = #0x64
 8017f5a: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8017ff0 <k_thread_foreach_unlocked+0xdc>
 8017f5c: 633b         	str	r3, [r7, #0x30]
 8017f5e: 69bb         	ldr	r3, [r7, #0x18]
 8017f60: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8017f62: 693b         	ldr	r3, [r7, #0x10]
 8017f64: 62fb         	str	r3, [r7, #0x2c]
 8017f66: 6afb         	ldr	r3, [r7, #0x2c]
 8017f68: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017f6a: 6abb         	ldr	r3, [r7, #0x28]
 8017f6c: f383 8811    	msr	basepri, r3
; }
 8017f70: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017f72: f3bf 8f6f    	isb	sy
; }
 8017f76: bf00         	nop
; }
 8017f78: bf00         	nop
; }
 8017f7a: bf00         	nop
; 		user_cb(thread, user_data);
 8017f7c: 687b         	ldr	r3, [r7, #0x4]
 8017f7e: 6839         	ldr	r1, [r7]
 8017f80: 6e78         	ldr	r0, [r7, #0x64]
 8017f82: 4798         	blx	r3
 8017f84: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8017ff0 <k_thread_foreach_unlocked+0xdc>
 8017f86: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8017f88: f3ef 8311    	mrs	r3, basepri
 8017f8c: 647b         	str	r3, [r7, #0x44]
;   return(result);
 8017f8e: 6c7b         	ldr	r3, [r7, #0x44]
; 	key = __get_BASEPRI();
 8017f90: 643b         	str	r3, [r7, #0x40]
 8017f92: 2310         	movs	r3, #0x10
 8017f94: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8017f96: 6bfb         	ldr	r3, [r7, #0x3c]
 8017f98: f383 8812    	msr	basepri_max, r3
; }
 8017f9c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017f9e: f3bf 8f6f    	isb	sy
; }
 8017fa2: bf00         	nop
; 	return key;
 8017fa4: 6c3b         	ldr	r3, [r7, #0x40]
; 	k.key = arch_irq_lock();
 8017fa6: 60fb         	str	r3, [r7, #0xc]
 8017fa8: 6cbb         	ldr	r3, [r7, #0x48]
 8017faa: 63bb         	str	r3, [r7, #0x38]
; }
 8017fac: bf00         	nop
 8017fae: 6cbb         	ldr	r3, [r7, #0x48]
 8017fb0: 637b         	str	r3, [r7, #0x34]
; }
 8017fb2: bf00         	nop
; 	return k;
 8017fb4: 68fb         	ldr	r3, [r7, #0xc]
 8017fb6: 61bb         	str	r3, [r7, #0x18]
; 	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
 8017fb8: 6e7b         	ldr	r3, [r7, #0x64]
 8017fba: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 8017fbe: 667b         	str	r3, [r7, #0x64]
 8017fc0: 6e7b         	ldr	r3, [r7, #0x64]
 8017fc2: 2b00         	cmp	r3, #0x0
 8017fc4: d1c9         	bne	0x8017f5a <k_thread_foreach_unlocked+0x46> @ imm = #-0x6e
 8017fc6: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8017ff0 <k_thread_foreach_unlocked+0xdc>
 8017fc8: 627b         	str	r3, [r7, #0x24]
 8017fca: 69bb         	ldr	r3, [r7, #0x18]
 8017fcc: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8017fce: 697b         	ldr	r3, [r7, #0x14]
 8017fd0: 623b         	str	r3, [r7, #0x20]
 8017fd2: 6a3b         	ldr	r3, [r7, #0x20]
 8017fd4: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017fd6: 69fb         	ldr	r3, [r7, #0x1c]
 8017fd8: f383 8811    	msr	basepri, r3
; }
 8017fdc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017fde: f3bf 8f6f    	isb	sy
; }
 8017fe2: bf00         	nop
; }
 8017fe4: bf00         	nop
; }
 8017fe6: bf00         	nop
; }
 8017fe8: bf00         	nop
 8017fea: 3768         	adds	r7, #0x68
 8017fec: 46bd         	mov	sp, r7
 8017fee: bd80         	pop	{r7, pc}

08017ff0 <$d>:
 8017ff0: e8 32 00 24  	.word	0x240032e8
 8017ff4: 60 20 00 24  	.word	0x24002060

08017ff8 <z_data_copy>:
; {
 8017ff8: b580         	push	{r7, lr}
 8017ffa: af00         	add	r7, sp, #0x0
; 		       __data_region_end - __data_region_start);
 8017ffc: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8018020 <z_data_copy+0x28>
 8017ffe: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8018024 <z_data_copy+0x2c>
 8018000: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__data_region_start, &__data_region_load_start,
 8018002: 461a         	mov	r2, r3
 8018004: 4908         	ldr	r1, [pc, #0x20]         @ 0x8018028 <z_data_copy+0x30>
 8018006: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8018024 <z_data_copy+0x2c>
 8018008: f00e fabb    	bl	0x8026582 <z_early_memcpy> @ imm = #0xe576
; 		       __ramfunc_end - __ramfunc_region_start);
 801800c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x801802c <z_data_copy+0x34>
 801800e: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8018030 <z_data_copy+0x38>
 8018010: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__ramfunc_region_start, &__ramfunc_load_start,
 8018012: 461a         	mov	r2, r3
 8018014: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8018034 <z_data_copy+0x3c>
 8018016: 4806         	ldr	r0, [pc, #0x18]         @ 0x8018030 <z_data_copy+0x38>
 8018018: f00e fab3    	bl	0x8026582 <z_early_memcpy> @ imm = #0xe566
; }
 801801c: bf00         	nop
 801801e: bd80         	pop	{r7, pc}

08018020 <$d>:
 8018020: 85 0c 00 24  	.word	0x24000c85
 8018024: 00 00 00 24  	.word	0x24000000
 8018028: 08 ec 02 08  	.word	0x0802ec08
 801802c: 00 00 00 24  	.word	0x24000000
 8018030: 00 00 00 24  	.word	0x24000000
 8018034: 08 ec 02 08  	.word	0x0802ec08

08018038 <first>:
; {
 8018038: b580         	push	{r7, lr}
 801803a: b082         	sub	sp, #0x8
 801803c: af00         	add	r7, sp, #0x0
; 	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);
 801803e: 4804         	ldr	r0, [pc, #0x10]         @ 0x8018050 <first+0x18>
 8018040: f010 fde0    	bl	0x8028c04 <sys_dlist_peek_head> @ imm = #0x10bc0
 8018044: 6078         	str	r0, [r7, #0x4]
; 	return (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);
 8018046: 687b         	ldr	r3, [r7, #0x4]
; }
 8018048: 4618         	mov	r0, r3
 801804a: 3708         	adds	r7, #0x8
 801804c: 46bd         	mov	sp, r7
 801804e: bd80         	pop	{r7, pc}

08018050 <$d>:
 8018050: 78 0b 00 24  	.word	0x24000b78

08018054 <next>:
; {
 8018054: b580         	push	{r7, lr}
 8018056: b084         	sub	sp, #0x10
 8018058: af00         	add	r7, sp, #0x0
 801805a: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);
 801805c: 687b         	ldr	r3, [r7, #0x4]
 801805e: 4619         	mov	r1, r3
 8018060: 4804         	ldr	r0, [pc, #0x10]         @ 0x8018074 <next+0x20>
 8018062: f010 fdf5    	bl	0x8028c50 <sys_dlist_peek_next> @ imm = #0x10bea
 8018066: 60f8         	str	r0, [r7, #0xc]
; 	return (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);
 8018068: 68fb         	ldr	r3, [r7, #0xc]
; }
 801806a: 4618         	mov	r0, r3
 801806c: 3710         	adds	r7, #0x10
 801806e: 46bd         	mov	sp, r7
 8018070: bd80         	pop	{r7, pc}
 8018072: bf00         	nop

08018074 <$d>:
 8018074: 78 0b 00 24  	.word	0x24000b78

08018078 <elapsed>:
; {
 8018078: b580         	push	{r7, lr}
 801807a: af00         	add	r7, sp, #0x0
; 	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 801807c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8018094 <elapsed+0x1c>
 801807e: 681b         	ldr	r3, [r3]
 8018080: 2b00         	cmp	r3, #0x0
 8018082: d103         	bne	0x801808c <elapsed+0x14> @ imm = #0x6
 8018084: f7f9 fb8e    	bl	0x80117a4 <sys_clock_elapsed> @ imm = #-0x68e4
 8018088: 4603         	mov	r3, r0
 801808a: e000         	b	0x801808e <elapsed+0x16> @ imm = #0x0
 801808c: 2300         	movs	r3, #0x0
; }
 801808e: 4618         	mov	r0, r3
 8018090: bd80         	pop	{r7, pc}
 8018092: bf00         	nop

08018094 <$d>:
 8018094: e8 32 00 24  	.word	0x240032e8

08018098 <z_add_timeout>:
; {
 8018098: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 801809c: b0a1         	sub	sp, #0x84
 801809e: af00         	add	r7, sp, #0x0
 80180a0: 6378         	str	r0, [r7, #0x34]
 80180a2: 6339         	str	r1, [r7, #0x30]
 80180a4: e9c7 230a    	strd	r2, r3, [r7, #40]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 80180a8: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 80180ac: f04f 32ff    	mov.w	r2, #0xffffffff
 80180b0: f04f 33ff    	mov.w	r3, #0xffffffff
 80180b4: 4299         	cmp	r1, r3
 80180b6: bf08         	it	eq
 80180b8: 4290         	cmpeq	r0, r2
 80180ba: d100         	bne	0x80180be <z_add_timeout+0x26> @ imm = #0x0
 80180bc: e0d4         	b	0x8018268 <z_add_timeout+0x1d0> @ imm = #0x1a8
; 	to->fn = fn;
 80180be: 6b7a         	ldr	r2, [r7, #0x34]
 80180c0: 6b3b         	ldr	r3, [r7, #0x30]
 80180c2: 6093         	str	r3, [r2, #0x8]
; 	K_SPINLOCK(&timeout_lock) {
 80180c4: 2300         	movs	r3, #0x0
 80180c6: 64bb         	str	r3, [r7, #0x48]
 80180c8: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8018270 <z_add_timeout+0x1d8>
 80180ca: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80180cc: f3ef 8311    	mrs	r3, basepri
 80180d0: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 80180d2: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 80180d4: 667b         	str	r3, [r7, #0x64]
 80180d6: 2310         	movs	r3, #0x10
 80180d8: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80180da: 6e3b         	ldr	r3, [r7, #0x60]
 80180dc: f383 8812    	msr	basepri_max, r3
; }
 80180e0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80180e2: f3bf 8f6f    	isb	sy
; }
 80180e6: bf00         	nop
; 	return key;
 80180e8: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 80180ea: 63fb         	str	r3, [r7, #0x3c]
 80180ec: 6efb         	ldr	r3, [r7, #0x6c]
 80180ee: 65fb         	str	r3, [r7, #0x5c]
; }
 80180f0: bf00         	nop
 80180f2: 6efb         	ldr	r3, [r7, #0x6c]
 80180f4: 65bb         	str	r3, [r7, #0x58]
; }
 80180f6: bf00         	nop
; 	return k;
 80180f8: 6bfb         	ldr	r3, [r7, #0x3c]
 80180fa: 647b         	str	r3, [r7, #0x44]
; 	K_SPINLOCK(&timeout_lock) {
 80180fc: e0b0         	b	0x8018260 <z_add_timeout+0x1c8> @ imm = #0x160
; 		    (Z_TICK_ABS(timeout.ticks) >= 0)) {
 80180fe: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8018102: f06f 0001    	mvn	r0, #0x1
 8018106: f04f 31ff    	mov.w	r1, #0xffffffff
 801810a: 1a80         	subs	r0, r0, r2
 801810c: 6238         	str	r0, [r7, #0x20]
 801810e: eb61 0303    	sbc.w	r3, r1, r3
 8018112: 627b         	str	r3, [r7, #0x24]
; 		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 8018114: 6a7b         	ldr	r3, [r7, #0x24]
 8018116: 2b00         	cmp	r3, #0x0
 8018118: db24         	blt	0x8018164 <z_add_timeout+0xcc> @ imm = #0x48
; 			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 801811a: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 801811e: 4610         	mov	r0, r2
 8018120: 4619         	mov	r1, r3
 8018122: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8018274 <z_add_timeout+0x1dc>
 8018124: e9d3 2300    	ldrd	r2, r3, [r3]
 8018128: 1884         	adds	r4, r0, r2
 801812a: eb41 0503    	adc.w	r5, r1, r3
 801812e: f06f 0201    	mvn	r2, #0x1
 8018132: f04f 33ff    	mov.w	r3, #0xffffffff
 8018136: 1b12         	subs	r2, r2, r4
 8018138: 61ba         	str	r2, [r7, #0x18]
 801813a: eb63 0305    	sbc.w	r3, r3, r5
 801813e: 61fb         	str	r3, [r7, #0x1c]
 8018140: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8018144: e9c7 231c    	strd	r2, r3, [r7, #112]
; 			to->dticks = MAX(1, ticks);
 8018148: e9d7 231c    	ldrd	r2, r3, [r7, #112]
 801814c: 2a01         	cmp	r2, #0x1
 801814e: f173 0100    	sbcs	r1, r3, #0x0
 8018152: da03         	bge	0x801815c <z_add_timeout+0xc4> @ imm = #0x6
 8018154: f04f 0201    	mov.w	r2, #0x1
 8018158: f04f 0300    	mov.w	r3, #0x0
 801815c: 6b79         	ldr	r1, [r7, #0x34]
 801815e: e9c1 2304    	strd	r2, r3, [r1, #16]
 8018162: e016         	b	0x8018192 <z_add_timeout+0xfa> @ imm = #0x2c
; 			to->dticks = timeout.ticks + 1 + elapsed();
 8018164: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8018168: f112 0801    	adds.w	r8, r2, #0x1
 801816c: f143 0900    	adc	r9, r3, #0x0
 8018170: f7ff ff82    	bl	0x8018078 <elapsed>     @ imm = #-0xfc
 8018174: 4603         	mov	r3, r0
 8018176: 17da         	asrs	r2, r3, #0x1f
 8018178: 469a         	mov	r10, r3
 801817a: 4693         	mov	r11, r2
 801817c: eb18 030a    	adds.w	r3, r8, r10
 8018180: 613b         	str	r3, [r7, #0x10]
 8018182: eb49 030b    	adc.w	r3, r9, r11
 8018186: 617b         	str	r3, [r7, #0x14]
 8018188: 6b7b         	ldr	r3, [r7, #0x34]
 801818a: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 801818e: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 8018192: f7ff ff51    	bl	0x8018038 <first>       @ imm = #-0x15e
 8018196: 67f8         	str	r0, [r7, #0x7c]
 8018198: e033         	b	0x8018202 <z_add_timeout+0x16a> @ imm = #0x66
; 			if (t->dticks > to->dticks) {
 801819a: 6ffb         	ldr	r3, [r7, #0x7c]
 801819c: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 80181a0: 6b7b         	ldr	r3, [r7, #0x34]
 80181a2: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 80181a6: 4282         	cmp	r2, r0
 80181a8: 418b         	sbcs	r3, r1
 80181aa: da16         	bge	0x80181da <z_add_timeout+0x142> @ imm = #0x2c
; 				t->dticks -= to->dticks;
 80181ac: 6ffb         	ldr	r3, [r7, #0x7c]
 80181ae: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 80181b2: 6b7b         	ldr	r3, [r7, #0x34]
 80181b4: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 80181b8: 1a86         	subs	r6, r0, r2
 80181ba: 60be         	str	r6, [r7, #0x8]
 80181bc: eb61 0303    	sbc.w	r3, r1, r3
 80181c0: 60fb         	str	r3, [r7, #0xc]
 80181c2: 6ffb         	ldr	r3, [r7, #0x7c]
 80181c4: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 80181c8: e9c3 1204    	strd	r1, r2, [r3, #16]
; 				sys_dlist_insert(&t->node, &to->node);
 80181cc: 6ffa         	ldr	r2, [r7, #0x7c]
 80181ce: 6b7b         	ldr	r3, [r7, #0x34]
 80181d0: 4619         	mov	r1, r3
 80181d2: 4610         	mov	r0, r2
 80181d4: f010 fd69    	bl	0x8028caa <sys_dlist_insert> @ imm = #0x10ad2
; 				break;
 80181d8: e016         	b	0x8018208 <z_add_timeout+0x170> @ imm = #0x2c
; 			to->dticks -= t->dticks;
 80181da: 6b7b         	ldr	r3, [r7, #0x34]
 80181dc: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 80181e0: 6ffb         	ldr	r3, [r7, #0x7c]
 80181e2: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 80181e6: 1a86         	subs	r6, r0, r2
 80181e8: 603e         	str	r6, [r7]
 80181ea: eb61 0303    	sbc.w	r3, r1, r3
 80181ee: 607b         	str	r3, [r7, #0x4]
 80181f0: 6b7b         	ldr	r3, [r7, #0x34]
 80181f2: e9d7 1200    	ldrd	r1, r2, [r7]
 80181f6: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 80181fa: 6ff8         	ldr	r0, [r7, #0x7c]
 80181fc: f7ff ff2a    	bl	0x8018054 <next>        @ imm = #-0x1ac
 8018200: 67f8         	str	r0, [r7, #0x7c]
 8018202: 6ffb         	ldr	r3, [r7, #0x7c]
 8018204: 2b00         	cmp	r3, #0x0
 8018206: d1c8         	bne	0x801819a <z_add_timeout+0x102> @ imm = #-0x70
; 		if (t == NULL) {
 8018208: 6ffb         	ldr	r3, [r7, #0x7c]
 801820a: 2b00         	cmp	r3, #0x0
 801820c: d104         	bne	0x8018218 <z_add_timeout+0x180> @ imm = #0x8
; 			sys_dlist_append(&timeout_list, &to->node);
 801820e: 6b7b         	ldr	r3, [r7, #0x34]
 8018210: 4619         	mov	r1, r3
 8018212: 4819         	ldr	r0, [pc, #0x64]         @ 0x8018278 <z_add_timeout+0x1e0>
 8018214: f010 fd2f    	bl	0x8028c76 <sys_dlist_append> @ imm = #0x10a5e
; 		if (to == first() && announce_remaining == 0) {
 8018218: f7ff ff0e    	bl	0x8018038 <first>       @ imm = #-0x1e4
 801821c: 4602         	mov	r2, r0
 801821e: 6b7b         	ldr	r3, [r7, #0x34]
 8018220: 4293         	cmp	r3, r2
 8018222: d10a         	bne	0x801823a <z_add_timeout+0x1a2> @ imm = #0x14
 8018224: 4b15         	ldr	r3, [pc, #0x54]         @ 0x801827c <z_add_timeout+0x1e4>
 8018226: 681b         	ldr	r3, [r3]
 8018228: 2b00         	cmp	r3, #0x0
 801822a: d106         	bne	0x801823a <z_add_timeout+0x1a2> @ imm = #0xc
; 			sys_clock_set_timeout(next_timeout(), false);
 801822c: f010 fd8e    	bl	0x8028d4c <next_timeout> @ imm = #0x10b1c
 8018230: 4603         	mov	r3, r0
 8018232: 2100         	movs	r1, #0x0
 8018234: 4618         	mov	r0, r3
 8018236: f7f9 f9b1    	bl	0x801159c <sys_clock_set_timeout> @ imm = #-0x6c9e
 801823a: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8018270 <z_add_timeout+0x1d8>
 801823c: 657b         	str	r3, [r7, #0x54]
 801823e: 6c7b         	ldr	r3, [r7, #0x44]
 8018240: 643b         	str	r3, [r7, #0x40]
; 	arch_irq_unlock(key.key);
 8018242: 6c3b         	ldr	r3, [r7, #0x40]
 8018244: 653b         	str	r3, [r7, #0x50]
 8018246: 6d3b         	ldr	r3, [r7, #0x50]
 8018248: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801824a: 6cfb         	ldr	r3, [r7, #0x4c]
 801824c: f383 8811    	msr	basepri, r3
; }
 8018250: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8018252: f3bf 8f6f    	isb	sy
; }
 8018256: bf00         	nop
; }
 8018258: bf00         	nop
; }
 801825a: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 801825c: 2301         	movs	r3, #0x1
 801825e: 64bb         	str	r3, [r7, #0x48]
 8018260: 6cbb         	ldr	r3, [r7, #0x48]
 8018262: 2b00         	cmp	r3, #0x0
 8018264: f43f af4b    	beq.w	0x80180fe <z_add_timeout+0x66> @ imm = #-0x16a
; }
 8018268: 3784         	adds	r7, #0x84
 801826a: 46bd         	mov	sp, r7
 801826c: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}

08018270 <$d>:
 8018270: e8 32 00 24  	.word	0x240032e8
 8018274: 40 25 00 24  	.word	0x24002540
 8018278: 78 0b 00 24  	.word	0x24000b78
 801827c: e8 32 00 24  	.word	0x240032e8

08018280 <z_abort_timeout>:
; {
 8018280: b580         	push	{r7, lr}
 8018282: b090         	sub	sp, #0x40
 8018284: af00         	add	r7, sp, #0x0
 8018286: 6078         	str	r0, [r7, #0x4]
; 	int ret = -EINVAL;
 8018288: f06f 0315    	mvn	r3, #0x15
 801828c: 63fb         	str	r3, [r7, #0x3c]
; 	K_SPINLOCK(&timeout_lock) {
 801828e: 2300         	movs	r3, #0x0
 8018290: 617b         	str	r3, [r7, #0x14]
 8018292: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8018318 <z_abort_timeout+0x98>
 8018294: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8018296: f3ef 8311    	mrs	r3, basepri
 801829a: 637b         	str	r3, [r7, #0x34]
;   return(result);
 801829c: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 801829e: 633b         	str	r3, [r7, #0x30]
 80182a0: 2310         	movs	r3, #0x10
 80182a2: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80182a4: 6afb         	ldr	r3, [r7, #0x2c]
 80182a6: f383 8812    	msr	basepri_max, r3
; }
 80182aa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80182ac: f3bf 8f6f    	isb	sy
; }
 80182b0: bf00         	nop
; 	return key;
 80182b2: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 80182b4: 60bb         	str	r3, [r7, #0x8]
 80182b6: 6bbb         	ldr	r3, [r7, #0x38]
 80182b8: 62bb         	str	r3, [r7, #0x28]
; }
 80182ba: bf00         	nop
 80182bc: 6bbb         	ldr	r3, [r7, #0x38]
 80182be: 627b         	str	r3, [r7, #0x24]
; }
 80182c0: bf00         	nop
; 	return k;
 80182c2: 68bb         	ldr	r3, [r7, #0x8]
 80182c4: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&timeout_lock) {
 80182c6: e01e         	b	0x8018306 <z_abort_timeout+0x86> @ imm = #0x3c
; 		if (sys_dnode_is_linked(&to->node)) {
 80182c8: 687b         	ldr	r3, [r7, #0x4]
 80182ca: 4618         	mov	r0, r3
 80182cc: f010 fc77    	bl	0x8028bbe <sys_dnode_is_linked> @ imm = #0x108ee
 80182d0: 4603         	mov	r3, r0
 80182d2: 2b00         	cmp	r3, #0x0
 80182d4: d004         	beq	0x80182e0 <z_abort_timeout+0x60> @ imm = #0x8
; 			remove_timeout(to);
 80182d6: 6878         	ldr	r0, [r7, #0x4]
 80182d8: f010 fd18    	bl	0x8028d0c <remove_timeout> @ imm = #0x10a30
; 			ret = 0;
 80182dc: 2300         	movs	r3, #0x0
 80182de: 63fb         	str	r3, [r7, #0x3c]
 80182e0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8018318 <z_abort_timeout+0x98>
 80182e2: 623b         	str	r3, [r7, #0x20]
 80182e4: 693b         	ldr	r3, [r7, #0x10]
 80182e6: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 80182e8: 68fb         	ldr	r3, [r7, #0xc]
 80182ea: 61fb         	str	r3, [r7, #0x1c]
 80182ec: 69fb         	ldr	r3, [r7, #0x1c]
 80182ee: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80182f0: 69bb         	ldr	r3, [r7, #0x18]
 80182f2: f383 8811    	msr	basepri, r3
; }
 80182f6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80182f8: f3bf 8f6f    	isb	sy
; }
 80182fc: bf00         	nop
; }
 80182fe: bf00         	nop
; }
 8018300: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 8018302: 2301         	movs	r3, #0x1
 8018304: 617b         	str	r3, [r7, #0x14]
 8018306: 697b         	ldr	r3, [r7, #0x14]
 8018308: 2b00         	cmp	r3, #0x0
 801830a: d0dd         	beq	0x80182c8 <z_abort_timeout+0x48> @ imm = #-0x46
; 	return ret;
 801830c: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 801830e: 4618         	mov	r0, r3
 8018310: 3740         	adds	r7, #0x40
 8018312: 46bd         	mov	sp, r7
 8018314: bd80         	pop	{r7, pc}
 8018316: bf00         	nop

08018318 <$d>:
 8018318: e8 32 00 24  	.word	0x240032e8

0801831c <sys_clock_announce>:
; {
 801831c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8018320: b0a4         	sub	sp, #0x90
 8018322: af00         	add	r7, sp, #0x0
 8018324: 6278         	str	r0, [r7, #0x24]
 8018326: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x80184f4 <sys_clock_announce+0x1d8>
 8018328: f8c7 3084    	str.w	r3, [r7, #0x84]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801832c: f3ef 8311    	mrs	r3, basepri
 8018330: f8c7 3080    	str.w	r3, [r7, #0x80]
;   return(result);
 8018334: f8d7 3080    	ldr.w	r3, [r7, #0x80]
; 	key = __get_BASEPRI();
 8018338: 67fb         	str	r3, [r7, #0x7c]
 801833a: 2310         	movs	r3, #0x10
 801833c: 67bb         	str	r3, [r7, #0x78]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801833e: 6fbb         	ldr	r3, [r7, #0x78]
 8018340: f383 8812    	msr	basepri_max, r3
; }
 8018344: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8018346: f3bf 8f6f    	isb	sy
; }
 801834a: bf00         	nop
; 	return key;
 801834c: 6ffb         	ldr	r3, [r7, #0x7c]
; 	k.key = arch_irq_lock();
 801834e: 637b         	str	r3, [r7, #0x34]
 8018350: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8018354: 677b         	str	r3, [r7, #0x74]
; }
 8018356: bf00         	nop
 8018358: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 801835c: 673b         	str	r3, [r7, #0x70]
; }
 801835e: bf00         	nop
; 	return k;
 8018360: 6b7b         	ldr	r3, [r7, #0x34]
 8018362: 63fb         	str	r3, [r7, #0x3c]
; 	announce_remaining = ticks;
 8018364: 4a64         	ldr	r2, [pc, #0x190]        @ 0x80184f8 <sys_clock_announce+0x1dc>
 8018366: 6a7b         	ldr	r3, [r7, #0x24]
 8018368: 6013         	str	r3, [r2]
; 	for (t = first();
 801836a: f7ff fe65    	bl	0x8018038 <first>       @ imm = #-0x336
 801836e: f8c7 008c    	str.w	r0, [r7, #0x8c]
 8018372: e061         	b	0x8018438 <sys_clock_announce+0x11c> @ imm = #0xc2
; 		int dt = t->dticks;
 8018374: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8018378: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 801837c: 4613         	mov	r3, r2
 801837e: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		curr_tick += dt;
 8018382: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8018386: 17da         	asrs	r2, r3, #0x1f
 8018388: 469a         	mov	r10, r3
 801838a: 4693         	mov	r11, r2
 801838c: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x80184fc <sys_clock_announce+0x1e0>
 801838e: e9d3 2300    	ldrd	r2, r3, [r3]
 8018392: eb1a 0102    	adds.w	r1, r10, r2
 8018396: 6139         	str	r1, [r7, #0x10]
 8018398: eb4b 0303    	adc.w	r3, r11, r3
 801839c: 617b         	str	r3, [r7, #0x14]
 801839e: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x80184fc <sys_clock_announce+0x1e0>
 80183a0: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 80183a4: e9c3 1200    	strd	r1, r2, [r3]
; 		t->dticks = 0;
 80183a8: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 80183ac: f04f 0200    	mov.w	r2, #0x0
 80183b0: f04f 0300    	mov.w	r3, #0x0
 80183b4: e9c1 2304    	strd	r2, r3, [r1, #16]
; 		remove_timeout(t);
 80183b8: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 80183bc: f010 fca6    	bl	0x8028d0c <remove_timeout> @ imm = #0x1094c
 80183c0: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x80184f4 <sys_clock_announce+0x1d8>
 80183c2: 657b         	str	r3, [r7, #0x54]
 80183c4: 6bfb         	ldr	r3, [r7, #0x3c]
 80183c6: 633b         	str	r3, [r7, #0x30]
; 	arch_irq_unlock(key.key);
 80183c8: 6b3b         	ldr	r3, [r7, #0x30]
 80183ca: 653b         	str	r3, [r7, #0x50]
 80183cc: 6d3b         	ldr	r3, [r7, #0x50]
 80183ce: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80183d0: 6cfb         	ldr	r3, [r7, #0x4c]
 80183d2: f383 8811    	msr	basepri, r3
; }
 80183d6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80183d8: f3bf 8f6f    	isb	sy
; }
 80183dc: bf00         	nop
; }
 80183de: bf00         	nop
; }
 80183e0: bf00         	nop
; 		t->fn(t);
 80183e2: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80183e6: 689b         	ldr	r3, [r3, #0x8]
 80183e8: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 80183ec: 4798         	blx	r3
 80183ee: 4b41         	ldr	r3, [pc, #0x104]        @ 0x80184f4 <sys_clock_announce+0x1d8>
 80183f0: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80183f2: f3ef 8311    	mrs	r3, basepri
 80183f6: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 80183f8: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 80183fa: 667b         	str	r3, [r7, #0x64]
 80183fc: 2310         	movs	r3, #0x10
 80183fe: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8018400: 6e3b         	ldr	r3, [r7, #0x60]
 8018402: f383 8812    	msr	basepri_max, r3
; }
 8018406: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8018408: f3bf 8f6f    	isb	sy
; }
 801840c: bf00         	nop
; 	return key;
 801840e: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 8018410: 62fb         	str	r3, [r7, #0x2c]
 8018412: 6efb         	ldr	r3, [r7, #0x6c]
 8018414: 65fb         	str	r3, [r7, #0x5c]
; }
 8018416: bf00         	nop
 8018418: 6efb         	ldr	r3, [r7, #0x6c]
 801841a: 65bb         	str	r3, [r7, #0x58]
; }
 801841c: bf00         	nop
; 	return k;
 801841e: 6afb         	ldr	r3, [r7, #0x2c]
 8018420: 63fb         	str	r3, [r7, #0x3c]
; 		announce_remaining -= dt;
 8018422: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80184f8 <sys_clock_announce+0x1dc>
 8018424: 681a         	ldr	r2, [r3]
 8018426: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 801842a: 1ad2         	subs	r2, r2, r3
 801842c: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x80184f8 <sys_clock_announce+0x1dc>
 801842e: 601a         	str	r2, [r3]
; 	     t = first()) {
 8018430: f7ff fe02    	bl	0x8018038 <first>       @ imm = #-0x3fc
 8018434: f8c7 008c    	str.w	r0, [r7, #0x8c]
; 	     (t != NULL) && (t->dticks <= announce_remaining);
 8018438: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 801843c: 2b00         	cmp	r3, #0x0
 801843e: d00d         	beq	0x801845c <sys_clock_announce+0x140> @ imm = #0x1a
 8018440: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8018444: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8018448: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x80184f8 <sys_clock_announce+0x1dc>
 801844a: 681b         	ldr	r3, [r3]
 801844c: 17da         	asrs	r2, r3, #0x1f
 801844e: 61bb         	str	r3, [r7, #0x18]
 8018450: 61fa         	str	r2, [r7, #0x1c]
 8018452: 69bb         	ldr	r3, [r7, #0x18]
 8018454: 4283         	cmp	r3, r0
 8018456: 69fb         	ldr	r3, [r7, #0x1c]
 8018458: 418b         	sbcs	r3, r1
 801845a: da8b         	bge	0x8018374 <sys_clock_announce+0x58> @ imm = #-0xea
; 	if (t != NULL) {
 801845c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8018460: 2b00         	cmp	r3, #0x0
 8018462: d014         	beq	0x801848e <sys_clock_announce+0x172> @ imm = #0x28
; 		t->dticks -= announce_remaining;
 8018464: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8018468: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 801846c: 4922         	ldr	r1, [pc, #0x88]         @ 0x80184f8 <sys_clock_announce+0x1dc>
 801846e: 6809         	ldr	r1, [r1]
 8018470: 17c8         	asrs	r0, r1, #0x1f
 8018472: 4688         	mov	r8, r1
 8018474: 4681         	mov	r9, r0
 8018476: ebb2 0108    	subs.w	r1, r2, r8
 801847a: 60b9         	str	r1, [r7, #0x8]
 801847c: eb63 0309    	sbc.w	r3, r3, r9
 8018480: 60fb         	str	r3, [r7, #0xc]
 8018482: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8018486: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 801848a: e9c3 1204    	strd	r1, r2, [r3, #16]
; 	curr_tick += announce_remaining;
 801848e: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x80184f8 <sys_clock_announce+0x1dc>
 8018490: 681b         	ldr	r3, [r3]
 8018492: 17da         	asrs	r2, r3, #0x1f
 8018494: 461c         	mov	r4, r3
 8018496: 4615         	mov	r5, r2
 8018498: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80184fc <sys_clock_announce+0x1e0>
 801849a: e9d3 2300    	ldrd	r2, r3, [r3]
 801849e: 18a1         	adds	r1, r4, r2
 80184a0: 6039         	str	r1, [r7]
 80184a2: eb45 0303    	adc.w	r3, r5, r3
 80184a6: 607b         	str	r3, [r7, #0x4]
 80184a8: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80184fc <sys_clock_announce+0x1e0>
 80184aa: e9d7 1200    	ldrd	r1, r2, [r7]
 80184ae: e9c3 1200    	strd	r1, r2, [r3]
; 	announce_remaining = 0;
 80184b2: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80184f8 <sys_clock_announce+0x1dc>
 80184b4: 2200         	movs	r2, #0x0
 80184b6: 601a         	str	r2, [r3]
; 	sys_clock_set_timeout(next_timeout(), false);
 80184b8: f010 fc48    	bl	0x8028d4c <next_timeout> @ imm = #0x10890
 80184bc: 4603         	mov	r3, r0
 80184be: 2100         	movs	r1, #0x0
 80184c0: 4618         	mov	r0, r3
 80184c2: f7f9 f86b    	bl	0x801159c <sys_clock_set_timeout> @ imm = #-0x6f2a
 80184c6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80184f4 <sys_clock_announce+0x1d8>
 80184c8: 64bb         	str	r3, [r7, #0x48]
 80184ca: 6bfb         	ldr	r3, [r7, #0x3c]
 80184cc: 63bb         	str	r3, [r7, #0x38]
; 	arch_irq_unlock(key.key);
 80184ce: 6bbb         	ldr	r3, [r7, #0x38]
 80184d0: 647b         	str	r3, [r7, #0x44]
 80184d2: 6c7b         	ldr	r3, [r7, #0x44]
 80184d4: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80184d6: 6c3b         	ldr	r3, [r7, #0x40]
 80184d8: f383 8811    	msr	basepri, r3
; }
 80184dc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80184de: f3bf 8f6f    	isb	sy
; }
 80184e2: bf00         	nop
; }
 80184e4: bf00         	nop
; }
 80184e6: bf00         	nop
; 	z_time_slice();
 80184e8: f7ff fc3e    	bl	0x8017d68 <z_time_slice> @ imm = #-0x784
; }
 80184ec: 3790         	adds	r7, #0x90
 80184ee: 46bd         	mov	sp, r7
 80184f0: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

080184f4 <$d>:
 80184f4: e8 32 00 24  	.word	0x240032e8
 80184f8: e8 32 00 24  	.word	0x240032e8
 80184fc: 40 25 00 24  	.word	0x24002540

08018500 <sys_clock_tick_get>:
; {
 8018500: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8018504: b090         	sub	sp, #0x40
 8018506: af00         	add	r7, sp, #0x0
; 	uint64_t t = 0U;
 8018508: f04f 0200    	mov.w	r2, #0x0
 801850c: f04f 0300    	mov.w	r3, #0x0
 8018510: e9c7 230e    	strd	r2, r3, [r7, #56]
; 	K_SPINLOCK(&timeout_lock) {
 8018514: 2300         	movs	r3, #0x0
 8018516: 613b         	str	r3, [r7, #0x10]
 8018518: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80185a8 <sys_clock_tick_get+0xa8>
 801851a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801851c: f3ef 8311    	mrs	r3, basepri
 8018520: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8018522: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 8018524: 62fb         	str	r3, [r7, #0x2c]
 8018526: 2310         	movs	r3, #0x10
 8018528: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801852a: 6abb         	ldr	r3, [r7, #0x28]
 801852c: f383 8812    	msr	basepri_max, r3
; }
 8018530: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8018532: f3bf 8f6f    	isb	sy
; }
 8018536: bf00         	nop
; 	return key;
 8018538: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 801853a: 607b         	str	r3, [r7, #0x4]
 801853c: 6b7b         	ldr	r3, [r7, #0x34]
 801853e: 627b         	str	r3, [r7, #0x24]
; }
 8018540: bf00         	nop
 8018542: 6b7b         	ldr	r3, [r7, #0x34]
 8018544: 623b         	str	r3, [r7, #0x20]
; }
 8018546: bf00         	nop
; 	return k;
 8018548: 687b         	ldr	r3, [r7, #0x4]
 801854a: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&timeout_lock) {
 801854c: e021         	b	0x8018592 <sys_clock_tick_get+0x92> @ imm = #0x42
; 		t = curr_tick + elapsed();
 801854e: f7ff fd93    	bl	0x8018078 <elapsed>     @ imm = #-0x4da
 8018552: 4603         	mov	r3, r0
 8018554: 17da         	asrs	r2, r3, #0x1f
 8018556: 461c         	mov	r4, r3
 8018558: 4615         	mov	r5, r2
 801855a: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80185ac <sys_clock_tick_get+0xac>
 801855c: e9d3 2300    	ldrd	r2, r3, [r3]
 8018560: eb14 0802    	adds.w	r8, r4, r2
 8018564: eb45 0903    	adc.w	r9, r5, r3
 8018568: e9c7 890e    	strd	r8, r9, [r7, #56]
 801856c: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80185a8 <sys_clock_tick_get+0xa8>
 801856e: 61fb         	str	r3, [r7, #0x1c]
 8018570: 68fb         	ldr	r3, [r7, #0xc]
 8018572: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8018574: 68bb         	ldr	r3, [r7, #0x8]
 8018576: 61bb         	str	r3, [r7, #0x18]
 8018578: 69bb         	ldr	r3, [r7, #0x18]
 801857a: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801857c: 697b         	ldr	r3, [r7, #0x14]
 801857e: f383 8811    	msr	basepri, r3
; }
 8018582: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8018584: f3bf 8f6f    	isb	sy
; }
 8018588: bf00         	nop
; }
 801858a: bf00         	nop
; }
 801858c: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 801858e: 2301         	movs	r3, #0x1
 8018590: 613b         	str	r3, [r7, #0x10]
 8018592: 693b         	ldr	r3, [r7, #0x10]
 8018594: 2b00         	cmp	r3, #0x0
 8018596: d0da         	beq	0x801854e <sys_clock_tick_get+0x4e> @ imm = #-0x4c
; 	return t;
 8018598: e9d7 230e    	ldrd	r2, r3, [r7, #56]
; }
 801859c: 4610         	mov	r0, r2
 801859e: 4619         	mov	r1, r3
 80185a0: 3740         	adds	r7, #0x40
 80185a2: 46bd         	mov	sp, r7
 80185a4: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

080185a8 <$d>:
 80185a8: e8 32 00 24  	.word	0x240032e8
 80185ac: 40 25 00 24  	.word	0x24002540

080185b0 <z_sched_usage_start>:
; {
 80185b0: b580         	push	{r7, lr}
 80185b2: b082         	sub	sp, #0x8
 80185b4: af00         	add	r7, sp, #0x0
 80185b6: 6078         	str	r0, [r7, #0x4]
; 	_current_cpu->usage0 = usage_now();
 80185b8: f010 fcd2    	bl	0x8028f60 <usage_now>   @ imm = #0x109a4
 80185bc: 4603         	mov	r3, r0
 80185be: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80185cc <z_sched_usage_start+0x1c>
 80185c0: 6193         	str	r3, [r2, #0x18]
; }
 80185c2: bf00         	nop
 80185c4: 3708         	adds	r7, #0x8
 80185c6: 46bd         	mov	sp, r7
 80185c8: bd80         	pop	{r7, pc}
 80185ca: bf00         	nop

080185cc <$d>:
 80185cc: 60 20 00 24  	.word	0x24002060

080185d0 <z_sched_usage_stop>:
; {
 80185d0: b580         	push	{r7, lr}
 80185d2: b090         	sub	sp, #0x40
 80185d4: af00         	add	r7, sp, #0x0
 80185d6: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8018678 <z_sched_usage_stop+0xa8>
 80185d8: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80185da: f3ef 8311    	mrs	r3, basepri
 80185de: 62fb         	str	r3, [r7, #0x2c]
;   return(result);
 80185e0: 6afb         	ldr	r3, [r7, #0x2c]
; 	key = __get_BASEPRI();
 80185e2: 62bb         	str	r3, [r7, #0x28]
 80185e4: 2310         	movs	r3, #0x10
 80185e6: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80185e8: 6a7b         	ldr	r3, [r7, #0x24]
 80185ea: f383 8812    	msr	basepri_max, r3
; }
 80185ee: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80185f0: f3bf 8f6f    	isb	sy
; }
 80185f4: bf00         	nop
; 	return key;
 80185f6: 6abb         	ldr	r3, [r7, #0x28]
; 	k.key = arch_irq_lock();
 80185f8: 607b         	str	r3, [r7, #0x4]
 80185fa: 6b3b         	ldr	r3, [r7, #0x30]
 80185fc: 623b         	str	r3, [r7, #0x20]
; }
 80185fe: bf00         	nop
 8018600: 6b3b         	ldr	r3, [r7, #0x30]
 8018602: 61fb         	str	r3, [r7, #0x1c]
; }
 8018604: bf00         	nop
; 	return k;
 8018606: 687b         	ldr	r3, [r7, #0x4]
 8018608: 60fb         	str	r3, [r7, #0xc]
; 	struct _cpu     *cpu = _current_cpu;
 801860a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x801867c <z_sched_usage_stop+0xac>
 801860c: 63fb         	str	r3, [r7, #0x3c]
; 	uint32_t u0 = cpu->usage0;
 801860e: 6bfb         	ldr	r3, [r7, #0x3c]
 8018610: 699b         	ldr	r3, [r3, #0x18]
 8018612: 63bb         	str	r3, [r7, #0x38]
; 	if (u0 != 0) {
 8018614: 6bbb         	ldr	r3, [r7, #0x38]
 8018616: 2b00         	cmp	r3, #0x0
 8018618: d015         	beq	0x8018646 <z_sched_usage_stop+0x76> @ imm = #0x2a
; 		uint32_t cycles = usage_now() - u0;
 801861a: f010 fca1    	bl	0x8028f60 <usage_now>   @ imm = #0x10942
 801861e: 4602         	mov	r2, r0
 8018620: 6bbb         	ldr	r3, [r7, #0x38]
 8018622: 1ad3         	subs	r3, r2, r3
 8018624: 637b         	str	r3, [r7, #0x34]
; 		if (cpu->current->base.usage.track_usage) {
 8018626: 6bfb         	ldr	r3, [r7, #0x3c]
 8018628: 689b         	ldr	r3, [r3, #0x8]
 801862a: f893 3038    	ldrb.w	r3, [r3, #0x38]
 801862e: 2b00         	cmp	r3, #0x0
 8018630: d005         	beq	0x801863e <z_sched_usage_stop+0x6e> @ imm = #0xa
; 			sched_thread_update_usage(cpu->current, cycles);
 8018632: 6bfb         	ldr	r3, [r7, #0x3c]
 8018634: 689b         	ldr	r3, [r3, #0x8]
 8018636: 6b79         	ldr	r1, [r7, #0x34]
 8018638: 4618         	mov	r0, r3
 801863a: f010 fccc    	bl	0x8028fd6 <sched_thread_update_usage> @ imm = #0x10998
; 		sched_cpu_update_usage(cpu, cycles);
 801863e: 6b79         	ldr	r1, [r7, #0x34]
 8018640: 6bf8         	ldr	r0, [r7, #0x3c]
 8018642: f010 fc9d    	bl	0x8028f80 <sched_cpu_update_usage> @ imm = #0x1093a
; 	cpu->usage0 = 0;
 8018646: 6bfb         	ldr	r3, [r7, #0x3c]
 8018648: 2200         	movs	r2, #0x0
 801864a: 619a         	str	r2, [r3, #0x18]
 801864c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8018678 <z_sched_usage_stop+0xa8>
 801864e: 61bb         	str	r3, [r7, #0x18]
 8018650: 68fb         	ldr	r3, [r7, #0xc]
 8018652: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8018654: 68bb         	ldr	r3, [r7, #0x8]
 8018656: 617b         	str	r3, [r7, #0x14]
 8018658: 697b         	ldr	r3, [r7, #0x14]
 801865a: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801865c: 693b         	ldr	r3, [r7, #0x10]
 801865e: f383 8811    	msr	basepri, r3
; }
 8018662: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8018664: f3bf 8f6f    	isb	sy
; }
 8018668: bf00         	nop
; }
 801866a: bf00         	nop
; }
 801866c: bf00         	nop
; }
 801866e: bf00         	nop
 8018670: 3740         	adds	r7, #0x40
 8018672: 46bd         	mov	sp, r7
 8018674: bd80         	pop	{r7, pc}
 8018676: bf00         	nop

08018678 <$d>:
 8018678: ec 32 00 24  	.word	0x240032ec
 801867c: 60 20 00 24  	.word	0x24002060

08018680 <z_sched_cpu_usage>:
; {
 8018680: b5b0         	push	{r4, r5, r7, lr}
 8018682: b092         	sub	sp, #0x48
 8018684: af00         	add	r7, sp, #0x0
 8018686: 4603         	mov	r3, r0
 8018688: 6039         	str	r1, [r7]
 801868a: 71fb         	strb	r3, [r7, #0x7]
 801868c: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8018770 <z_sched_cpu_usage+0xf0>
 801868e: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8018690: f3ef 8311    	mrs	r3, basepri
 8018694: 637b         	str	r3, [r7, #0x34]
;   return(result);
 8018696: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 8018698: 633b         	str	r3, [r7, #0x30]
 801869a: 2310         	movs	r3, #0x10
 801869c: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801869e: 6afb         	ldr	r3, [r7, #0x2c]
 80186a0: f383 8812    	msr	basepri_max, r3
; }
 80186a4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80186a6: f3bf 8f6f    	isb	sy
; }
 80186aa: bf00         	nop
; 	return key;
 80186ac: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 80186ae: 60fb         	str	r3, [r7, #0xc]
 80186b0: 6bbb         	ldr	r3, [r7, #0x38]
 80186b2: 62bb         	str	r3, [r7, #0x28]
; }
 80186b4: bf00         	nop
 80186b6: 6bbb         	ldr	r3, [r7, #0x38]
 80186b8: 627b         	str	r3, [r7, #0x24]
; }
 80186ba: bf00         	nop
; 	return k;
 80186bc: 68fb         	ldr	r3, [r7, #0xc]
 80186be: 617b         	str	r3, [r7, #0x14]
; 	cpu = _current_cpu;
 80186c0: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8018774 <z_sched_cpu_usage+0xf4>
 80186c2: 647b         	str	r3, [r7, #0x44]
; 	if (&_kernel.cpus[cpu_id] == cpu) {
 80186c4: 79fb         	ldrb	r3, [r7, #0x7]
 80186c6: 015b         	lsls	r3, r3, #0x5
 80186c8: 4a2a         	ldr	r2, [pc, #0xa8]         @ 0x8018774 <z_sched_cpu_usage+0xf4>
 80186ca: 4413         	add	r3, r2
 80186cc: 6c7a         	ldr	r2, [r7, #0x44]
 80186ce: 429a         	cmp	r2, r3
 80186d0: d11a         	bne	0x8018708 <z_sched_cpu_usage+0x88> @ imm = #0x34
; 		uint32_t  now = usage_now();
 80186d2: f010 fc45    	bl	0x8028f60 <usage_now>   @ imm = #0x1088a
 80186d6: 6438         	str	r0, [r7, #0x40]
; 		uint32_t cycles = now - cpu->usage0;
 80186d8: 6c7b         	ldr	r3, [r7, #0x44]
 80186da: 699b         	ldr	r3, [r3, #0x18]
 80186dc: 6c3a         	ldr	r2, [r7, #0x40]
 80186de: 1ad3         	subs	r3, r2, r3
 80186e0: 63fb         	str	r3, [r7, #0x3c]
; 		if (cpu->current->base.usage.track_usage) {
 80186e2: 6c7b         	ldr	r3, [r7, #0x44]
 80186e4: 689b         	ldr	r3, [r3, #0x8]
 80186e6: f893 3038    	ldrb.w	r3, [r3, #0x38]
 80186ea: 2b00         	cmp	r3, #0x0
 80186ec: d005         	beq	0x80186fa <z_sched_cpu_usage+0x7a> @ imm = #0xa
; 			sched_thread_update_usage(cpu->current, cycles);
 80186ee: 6c7b         	ldr	r3, [r7, #0x44]
 80186f0: 689b         	ldr	r3, [r3, #0x8]
 80186f2: 6bf9         	ldr	r1, [r7, #0x3c]
 80186f4: 4618         	mov	r0, r3
 80186f6: f010 fc6e    	bl	0x8028fd6 <sched_thread_update_usage> @ imm = #0x108dc
; 		sched_cpu_update_usage(cpu, cycles);
 80186fa: 6bf9         	ldr	r1, [r7, #0x3c]
 80186fc: 6c78         	ldr	r0, [r7, #0x44]
 80186fe: f010 fc3f    	bl	0x8028f80 <sched_cpu_update_usage> @ imm = #0x1087e
; 		cpu->usage0 = now;
 8018702: 6c7b         	ldr	r3, [r7, #0x44]
 8018704: 6c3a         	ldr	r2, [r7, #0x40]
 8018706: 619a         	str	r2, [r3, #0x18]
; 	stats->total_cycles     = cpu->usage->total;
 8018708: 6c7b         	ldr	r3, [r7, #0x44]
 801870a: 69db         	ldr	r3, [r3, #0x1c]
 801870c: e9d3 2300    	ldrd	r2, r3, [r3]
 8018710: 6839         	ldr	r1, [r7]
 8018712: e9c1 2302    	strd	r2, r3, [r1, #8]
; 		_kernel.cpus[cpu_id].idle_thread->base.usage.total;
 8018716: 79fb         	ldrb	r3, [r7, #0x7]
 8018718: 4a16         	ldr	r2, [pc, #0x58]         @ 0x8018774 <z_sched_cpu_usage+0xf4>
 801871a: 015b         	lsls	r3, r3, #0x5
 801871c: 4413         	add	r3, r2
 801871e: 330c         	adds	r3, #0xc
 8018720: 681b         	ldr	r3, [r3]
 8018722: e9d3 230c    	ldrd	r2, r3, [r3, #48]
; 	stats->idle_cycles =
 8018726: 6839         	ldr	r1, [r7]
 8018728: e9c1 2304    	strd	r2, r3, [r1, #16]
; 	stats->execution_cycles = stats->total_cycles + stats->idle_cycles;
 801872c: 683b         	ldr	r3, [r7]
 801872e: e9d3 0102    	ldrd	r0, r1, [r3, #8]
 8018732: 683b         	ldr	r3, [r7]
 8018734: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8018738: 1884         	adds	r4, r0, r2
 801873a: eb41 0503    	adc.w	r5, r1, r3
 801873e: 683b         	ldr	r3, [r7]
 8018740: e9c3 4500    	strd	r4, r5, [r3]
 8018744: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8018770 <z_sched_cpu_usage+0xf0>
 8018746: 623b         	str	r3, [r7, #0x20]
 8018748: 697b         	ldr	r3, [r7, #0x14]
 801874a: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 801874c: 693b         	ldr	r3, [r7, #0x10]
 801874e: 61fb         	str	r3, [r7, #0x1c]
 8018750: 69fb         	ldr	r3, [r7, #0x1c]
 8018752: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8018754: 69bb         	ldr	r3, [r7, #0x18]
 8018756: f383 8811    	msr	basepri, r3
; }
 801875a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801875c: f3bf 8f6f    	isb	sy
; }
 8018760: bf00         	nop
; }
 8018762: bf00         	nop
; }
 8018764: bf00         	nop
; }
 8018766: bf00         	nop
 8018768: 3748         	adds	r7, #0x48
 801876a: 46bd         	mov	sp, r7
 801876c: bdb0         	pop	{r4, r5, r7, pc}
 801876e: bf00         	nop

08018770 <$d>:
 8018770: ec 32 00 24  	.word	0x240032ec
 8018774: 60 20 00 24  	.word	0x24002060

08018778 <z_sched_thread_usage>:
; {
 8018778: b580         	push	{r7, lr}
 801877a: b092         	sub	sp, #0x48
 801877c: af00         	add	r7, sp, #0x0
 801877e: 6078         	str	r0, [r7, #0x4]
 8018780: 6039         	str	r1, [r7]
 8018782: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8018844 <z_sched_thread_usage+0xcc>
 8018784: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8018786: f3ef 8311    	mrs	r3, basepri
 801878a: 637b         	str	r3, [r7, #0x34]
;   return(result);
 801878c: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 801878e: 633b         	str	r3, [r7, #0x30]
 8018790: 2310         	movs	r3, #0x10
 8018792: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8018794: 6afb         	ldr	r3, [r7, #0x2c]
 8018796: f383 8812    	msr	basepri_max, r3
; }
 801879a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801879c: f3bf 8f6f    	isb	sy
; }
 80187a0: bf00         	nop
; 	return key;
 80187a2: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 80187a4: 60fb         	str	r3, [r7, #0xc]
 80187a6: 6bbb         	ldr	r3, [r7, #0x38]
 80187a8: 62bb         	str	r3, [r7, #0x28]
; }
 80187aa: bf00         	nop
 80187ac: 6bbb         	ldr	r3, [r7, #0x38]
 80187ae: 627b         	str	r3, [r7, #0x24]
; }
 80187b0: bf00         	nop
; 	return k;
 80187b2: 68fb         	ldr	r3, [r7, #0xc]
 80187b4: 617b         	str	r3, [r7, #0x14]
; 	cpu = _current_cpu;
 80187b6: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8018848 <z_sched_thread_usage+0xd0>
 80187b8: 647b         	str	r3, [r7, #0x44]
; 	if (thread == cpu->current) {
 80187ba: 6c7b         	ldr	r3, [r7, #0x44]
 80187bc: 689b         	ldr	r3, [r3, #0x8]
 80187be: 687a         	ldr	r2, [r7, #0x4]
 80187c0: 429a         	cmp	r2, r3
 80187c2: d117         	bne	0x80187f4 <z_sched_thread_usage+0x7c> @ imm = #0x2e
; 		uint32_t now = usage_now();
 80187c4: f010 fbcc    	bl	0x8028f60 <usage_now>   @ imm = #0x10798
 80187c8: 6438         	str	r0, [r7, #0x40]
; 		uint32_t cycles = now - cpu->usage0;
 80187ca: 6c7b         	ldr	r3, [r7, #0x44]
 80187cc: 699b         	ldr	r3, [r3, #0x18]
 80187ce: 6c3a         	ldr	r2, [r7, #0x40]
 80187d0: 1ad3         	subs	r3, r2, r3
 80187d2: 63fb         	str	r3, [r7, #0x3c]
; 		if (thread->base.usage.track_usage) {
 80187d4: 687b         	ldr	r3, [r7, #0x4]
 80187d6: f893 3038    	ldrb.w	r3, [r3, #0x38]
 80187da: 2b00         	cmp	r3, #0x0
 80187dc: d003         	beq	0x80187e6 <z_sched_thread_usage+0x6e> @ imm = #0x6
; 			sched_thread_update_usage(thread, cycles);
 80187de: 6bf9         	ldr	r1, [r7, #0x3c]
 80187e0: 6878         	ldr	r0, [r7, #0x4]
 80187e2: f010 fbf8    	bl	0x8028fd6 <sched_thread_update_usage> @ imm = #0x107f0
; 		sched_cpu_update_usage(cpu, cycles);
 80187e6: 6bf9         	ldr	r1, [r7, #0x3c]
 80187e8: 6c78         	ldr	r0, [r7, #0x44]
 80187ea: f010 fbc9    	bl	0x8028f80 <sched_cpu_update_usage> @ imm = #0x10792
; 		cpu->usage0 = now;
 80187ee: 6c7b         	ldr	r3, [r7, #0x44]
 80187f0: 6c3a         	ldr	r2, [r7, #0x40]
 80187f2: 619a         	str	r2, [r3, #0x18]
; 	stats->execution_cycles = thread->base.usage.total;
 80187f4: 687b         	ldr	r3, [r7, #0x4]
 80187f6: e9d3 230c    	ldrd	r2, r3, [r3, #48]
 80187fa: 6839         	ldr	r1, [r7]
 80187fc: e9c1 2300    	strd	r2, r3, [r1]
; 	stats->total_cycles     = thread->base.usage.total;
 8018800: 687b         	ldr	r3, [r7, #0x4]
 8018802: e9d3 230c    	ldrd	r2, r3, [r3, #48]
 8018806: 6839         	ldr	r1, [r7]
 8018808: e9c1 2302    	strd	r2, r3, [r1, #8]
; 	stats->idle_cycles = 0;
 801880c: 6839         	ldr	r1, [r7]
 801880e: f04f 0200    	mov.w	r2, #0x0
 8018812: f04f 0300    	mov.w	r3, #0x0
 8018816: e9c1 2304    	strd	r2, r3, [r1, #16]
 801881a: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8018844 <z_sched_thread_usage+0xcc>
 801881c: 623b         	str	r3, [r7, #0x20]
 801881e: 697b         	ldr	r3, [r7, #0x14]
 8018820: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8018822: 693b         	ldr	r3, [r7, #0x10]
 8018824: 61fb         	str	r3, [r7, #0x1c]
 8018826: 69fb         	ldr	r3, [r7, #0x1c]
 8018828: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801882a: 69bb         	ldr	r3, [r7, #0x18]
 801882c: f383 8811    	msr	basepri, r3
; }
 8018830: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8018832: f3bf 8f6f    	isb	sy
; }
 8018836: bf00         	nop
; }
 8018838: bf00         	nop
; }
 801883a: bf00         	nop
; }
 801883c: bf00         	nop
 801883e: 3748         	adds	r7, #0x48
 8018840: 46bd         	mov	sp, r7
 8018842: bd80         	pop	{r7, pc}

08018844 <$d>:
 8018844: ec 32 00 24  	.word	0x240032ec
 8018848: 60 20 00 24  	.word	0x24002060

0801884c <k_aligned_alloc>:
; {
 801884c: b580         	push	{r7, lr}
 801884e: b084         	sub	sp, #0x10
 8018850: af00         	add	r7, sp, #0x0
 8018852: 6078         	str	r0, [r7, #0x4]
 8018854: 6039         	str	r1, [r7]
; 	void *ret = z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
 8018856: 683a         	ldr	r2, [r7]
 8018858: 6879         	ldr	r1, [r7, #0x4]
 801885a: 4804         	ldr	r0, [pc, #0x10]         @ 0x801886c <k_aligned_alloc+0x20>
 801885c: f010 fbee    	bl	0x802903c <z_heap_aligned_alloc> @ imm = #0x107dc
 8018860: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 8018862: 68fb         	ldr	r3, [r7, #0xc]
; }
 8018864: 4618         	mov	r0, r3
 8018866: 3710         	adds	r7, #0x10
 8018868: 46bd         	mov	sp, r7
 801886a: bd80         	pop	{r7, pc}

0801886c <$d>:
 801886c: 3c 0c 00 24  	.word	0x24000c3c

08018870 <k_thread_system_pool_assign>:
; {
 8018870: b480         	push	{r7}
 8018872: b083         	sub	sp, #0xc
 8018874: af00         	add	r7, sp, #0x0
 8018876: 6078         	str	r0, [r7, #0x4]
; 	thread->resource_pool = _SYSTEM_HEAP;
 8018878: 687b         	ldr	r3, [r7, #0x4]
 801887a: 4a04         	ldr	r2, [pc, #0x10]         @ 0x801888c <k_thread_system_pool_assign+0x1c>
 801887c: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; }
 8018880: bf00         	nop
 8018882: 370c         	adds	r7, #0xc
 8018884: 46bd         	mov	sp, r7
 8018886: f85d 7b04    	ldr	r7, [sp], #4
 801888a: 4770         	bx	lr

0801888c <$d>:
 801888c: 3c 0c 00 24  	.word	0x24000c3c

08018890 <z_thread_aligned_alloc>:
; {
 8018890: b580         	push	{r7, lr}
 8018892: b086         	sub	sp, #0x18
 8018894: af00         	add	r7, sp, #0x0
 8018896: 6078         	str	r0, [r7, #0x4]
 8018898: 6039         	str	r1, [r7]
; 	if (k_is_in_isr()) {
 801889a: f00f fb97    	bl	0x8027fcc <k_is_in_isr> @ imm = #0xf72e
 801889e: 4603         	mov	r3, r0
 80188a0: 2b00         	cmp	r3, #0x0
 80188a2: d002         	beq	0x80188aa <z_thread_aligned_alloc+0x1a> @ imm = #0x4
; 		heap = _SYSTEM_HEAP;
 80188a4: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80188dc <z_thread_aligned_alloc+0x4c>
 80188a6: 613b         	str	r3, [r7, #0x10]
 80188a8: e006         	b	0x80188b8 <z_thread_aligned_alloc+0x28> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80188aa: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80188e0 <z_thread_aligned_alloc+0x50>
 80188ac: 689b         	ldr	r3, [r3, #0x8]
 80188ae: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 80188b0: 68fb         	ldr	r3, [r7, #0xc]
; 		heap = arch_current_thread()->resource_pool;
 80188b2: f8d3 30c0    	ldr.w	r3, [r3, #0xc0]
 80188b6: 613b         	str	r3, [r7, #0x10]
; 	if (heap != NULL) {
 80188b8: 693b         	ldr	r3, [r7, #0x10]
 80188ba: 2b00         	cmp	r3, #0x0
 80188bc: d006         	beq	0x80188cc <z_thread_aligned_alloc+0x3c> @ imm = #0xc
; 		ret = z_heap_aligned_alloc(heap, align, size);
 80188be: 683a         	ldr	r2, [r7]
 80188c0: 6879         	ldr	r1, [r7, #0x4]
 80188c2: 6938         	ldr	r0, [r7, #0x10]
 80188c4: f010 fbba    	bl	0x802903c <z_heap_aligned_alloc> @ imm = #0x10774
 80188c8: 6178         	str	r0, [r7, #0x14]
 80188ca: e001         	b	0x80188d0 <z_thread_aligned_alloc+0x40> @ imm = #0x2
; 		ret = NULL;
 80188cc: 2300         	movs	r3, #0x0
 80188ce: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 80188d0: 697b         	ldr	r3, [r7, #0x14]
; }
 80188d2: 4618         	mov	r0, r3
 80188d4: 3718         	adds	r7, #0x18
 80188d6: 46bd         	mov	sp, r7
 80188d8: bd80         	pop	{r7, pc}
 80188da: bf00         	nop

080188dc <$d>:
 80188dc: 3c 0c 00 24  	.word	0x24000c3c
 80188e0: 60 20 00 24  	.word	0x24002060

080188e4 <boot_banner>:
; {
 80188e4: b580         	push	{r7, lr}
 80188e6: af00         	add	r7, sp, #0x0
; 	printk("*** " CONFIG_BOOT_BANNER_STRING " " BANNER_VERSION BANNER_POSTFIX " ***\n");
 80188e8: 4802         	ldr	r0, [pc, #0x8]          @ 0x80188f4 <boot_banner+0x10>
 80188ea: f003 fe56    	bl	0x801c59a <printk>      @ imm = #0x3cac
; }
 80188ee: bf00         	nop
 80188f0: bd80         	pop	{r7, pc}
 80188f2: bf00         	nop

080188f4 <$d>:
 80188f4: 38 ca 02 08  	.word	0x0802ca38

080188f8 <snprintf>:
 80188f8: b40c         	push	{r2, r3}
 80188fa: b530         	push	{r4, r5, lr}
 80188fc: b089         	sub	sp, #0x24
 80188fe: 4605         	mov	r5, r0
 8018900: 460c         	mov	r4, r1
 8018902: 221c         	movs	r2, #0x1c
 8018904: 2100         	movs	r1, #0x0
 8018906: a801         	add	r0, sp, #0x4
 8018908: f010 fc02    	bl	0x8029110 <memset>      @ imm = #0x10804
 801890c: 2302         	movs	r3, #0x2
 801890e: f88d 3006    	strb.w	r3, [sp, #0x6]
 8018912: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x801894c <snprintf+0x54>
 8018914: 9302         	str	r3, [sp, #0x8]
 8018916: 9505         	str	r5, [sp, #0x14]
 8018918: 4623         	mov	r3, r4
 801891a: b12c         	cbz	r4, 0x8018928 <snprintf+0x30> @ imm = #0xa
 801891c: f1b4 4f00    	cmp.w	r4, #0x80000000
 8018920: bf28         	it	hs
 8018922: f04f 4300    	movhs.w	r3, #0x80000000
 8018926: 3b01         	subs	r3, #0x1
 8018928: 441d         	add	r5, r3
 801892a: aa0d         	add	r2, sp, #0x34
 801892c: 990c         	ldr	r1, [sp, #0x30]
 801892e: 9506         	str	r5, [sp, #0x18]
 8018930: a801         	add	r0, sp, #0x4
 8018932: 9200         	str	r2, [sp]
 8018934: f000 f8a8    	bl	0x8018a88 <vfprintf>    @ imm = #0x150
 8018938: b114         	cbz	r4, 0x8018940 <snprintf+0x48> @ imm = #0x4
 801893a: 9b05         	ldr	r3, [sp, #0x14]
 801893c: 2200         	movs	r2, #0x0
 801893e: 701a         	strb	r2, [r3]
 8018940: b009         	add	sp, #0x24
 8018942: e8bd 4030    	pop.w	{r4, r5, lr}
 8018946: b002         	add	sp, #0x8
 8018948: 4770         	bx	lr
 801894a: bf00         	nop

0801894c <$d>:
 801894c: c5 94 02 08  	.word	0x080294c5

08018950 <skip_to_arg>:
 8018950: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 8018954: 2601         	movs	r6, #0x1
 8018956: 4607         	mov	r7, r0
 8018958: 42b2         	cmp	r2, r6
 801895a: dc01         	bgt	0x8018960 <skip_to_arg+0x10> @ imm = #0x2
 801895c: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 8018960: 463b         	mov	r3, r7
 8018962: 461f         	mov	r7, r3
 8018964: f813 4b01    	ldrb	r4, [r3], #1
 8018968: 2c00         	cmp	r4, #0x0
 801896a: d0f7         	beq	0x801895c <skip_to_arg+0xc> @ imm = #-0x12
 801896c: 2c25         	cmp	r4, #0x25
 801896e: d1f8         	bne	0x8018962 <skip_to_arg+0x12> @ imm = #-0x10
 8018970: 781c         	ldrb	r4, [r3]
 8018972: 2c25         	cmp	r4, #0x25
 8018974: f107 0702    	add.w	r7, r7, #0x2
 8018978: d0f2         	beq	0x8018960 <skip_to_arg+0x10> @ imm = #-0x1c
 801897a: 2300         	movs	r3, #0x0
 801897c: f8df 8104    	ldr.w	r8, [pc, #0x104]        @ 0x8018a84 <skip_to_arg+0x134>
 8018980: 469c         	mov	r12, r3
 8018982: 461d         	mov	r5, r3
 8018984: 2d1f         	cmp	r5, #0x1f
 8018986: d818         	bhi	0x80189ba <skip_to_arg+0x6a> @ imm = #0x30
 8018988: f1a4 0e20    	sub.w	lr, r4, #0x20
 801898c: f1be 0f10    	cmp.w	lr, #0x10
 8018990: d909         	bls	0x80189a6 <skip_to_arg+0x56> @ imm = #0x12
 8018992: f1a4 0e30    	sub.w	lr, r4, #0x30
 8018996: f1be 0f09    	cmp.w	lr, #0x9
 801899a: d81e         	bhi	0x80189da <skip_to_arg+0x8a> @ imm = #0x3c
 801899c: 240a         	movs	r4, #0xa
 801899e: fb04 e303    	mla	r3, r4, r3, lr
 80189a2: 2520         	movs	r5, #0x20
 80189a4: e004         	b	0x80189b0 <skip_to_arg+0x60> @ imm = #0x8
 80189a6: fa28 fe0e    	lsr.w	lr, r8, lr
 80189aa: f01e 0f01    	tst.w	lr, #0x1
 80189ae: d006         	beq	0x80189be <skip_to_arg+0x6e> @ imm = #0xc
 80189b0: f817 4b01    	ldrb	r4, [r7], #1
 80189b4: 2c00         	cmp	r4, #0x0
 80189b6: d1e5         	bne	0x8018984 <skip_to_arg+0x34> @ imm = #-0x36
 80189b8: e028         	b	0x8018a0c <skip_to_arg+0xbc> @ imm = #0x50
 80189ba: 2d7f         	cmp	r5, #0x7f
 80189bc: d81c         	bhi	0x80189f8 <skip_to_arg+0xa8> @ imm = #0x38
 80189be: f1a4 0e30    	sub.w	lr, r4, #0x30
 80189c2: f1be 0f09    	cmp.w	lr, #0x9
 80189c6: d9e9         	bls	0x801899c <skip_to_arg+0x4c> @ imm = #-0x2e
 80189c8: 2c24         	cmp	r4, #0x24
 80189ca: d110         	bne	0x80189ee <skip_to_arg+0x9e> @ imm = #0x20
 80189cc: f1bc 0f00    	cmp.w	r12, #0x0
 80189d0: d046         	beq	0x8018a60 <skip_to_arg+0x110> @ imm = #0x8c
 80189d2: 42b3         	cmp	r3, r6
 80189d4: d046         	beq	0x8018a64 <skip_to_arg+0x114> @ imm = #0x8c
 80189d6: 2300         	movs	r3, #0x0
 80189d8: e7ea         	b	0x80189b0 <skip_to_arg+0x60> @ imm = #-0x2c
 80189da: f024 0e04    	bic	lr, r4, #0x4
 80189de: f1be 0f2a    	cmp.w	lr, #0x2a
 80189e2: d0f8         	beq	0x80189d6 <skip_to_arg+0x86> @ imm = #-0x10
 80189e4: 2c6c         	cmp	r4, #0x6c
 80189e6: d109         	bne	0x80189fc <skip_to_arg+0xac> @ imm = #0x12
 80189e8: f045 0580    	orr	r5, r5, #0x80
 80189ec: e7e0         	b	0x80189b0 <skip_to_arg+0x60> @ imm = #-0x40
 80189ee: f024 0e04    	bic	lr, r4, #0x4
 80189f2: f1be 0f2a    	cmp.w	lr, #0x2a
 80189f6: d0ee         	beq	0x80189d6 <skip_to_arg+0x86> @ imm = #-0x24
 80189f8: 2c6c         	cmp	r4, #0x6c
 80189fa: d022         	beq	0x8018a42 <skip_to_arg+0xf2> @ imm = #0x44
 80189fc: 2c6c         	cmp	r4, #0x6c
 80189fe: d81b         	bhi	0x8018a38 <skip_to_arg+0xe8> @ imm = #0x36
 8018a00: 2c68         	cmp	r4, #0x68
 8018a02: d023         	beq	0x8018a4c <skip_to_arg+0xfc> @ imm = #0x46
 8018a04: 2c6a         	cmp	r4, #0x6a
 8018a06: d028         	beq	0x8018a5a <skip_to_arg+0x10a> @ imm = #0x50
 8018a08: 2c4c         	cmp	r4, #0x4c
 8018a0a: d026         	beq	0x8018a5a <skip_to_arg+0x10a> @ imm = #0x4c
 8018a0c: f1bc 0f00    	cmp.w	r12, #0x0
 8018a10: d0a4         	beq	0x801895c <skip_to_arg+0xc> @ imm = #-0xb8
 8018a12: 45b4         	cmp	r12, r6
 8018a14: d1a0         	bne	0x8018958 <skip_to_arg+0x8> @ imm = #-0xc0
 8018a16: f044 0720    	orr	r7, r4, #0x20
 8018a1a: f1a7 0c65    	sub.w	r12, r7, #0x65
 8018a1e: f1bc 0f02    	cmp.w	r12, #0x2
 8018a22: 680b         	ldr	r3, [r1]
 8018a24: d901         	bls	0x8018a2a <skip_to_arg+0xda> @ imm = #0x2
 8018a26: 2f61         	cmp	r7, #0x61
 8018a28: d11e         	bne	0x8018a68 <skip_to_arg+0x118> @ imm = #0x3c
 8018a2a: 3307         	adds	r3, #0x7
 8018a2c: f023 0307    	bic	r3, r3, #0x7
 8018a30: 3308         	adds	r3, #0x8
 8018a32: 600b         	str	r3, [r1]
 8018a34: 3601         	adds	r6, #0x1
 8018a36: e78e         	b	0x8018956 <skip_to_arg+0x6> @ imm = #-0xe4
 8018a38: 2c74         	cmp	r4, #0x74
 8018a3a: d0b9         	beq	0x80189b0 <skip_to_arg+0x60> @ imm = #-0x8e
 8018a3c: 2c7a         	cmp	r4, #0x7a
 8018a3e: d0b7         	beq	0x80189b0 <skip_to_arg+0x60> @ imm = #-0x92
 8018a40: e7e4         	b	0x8018a0c <skip_to_arg+0xbc> @ imm = #-0x38
 8018a42: 062c         	lsls	r4, r5, #0x18
 8018a44: bf48         	it	mi
 8018a46: f445 7500    	orrmi	r5, r5, #0x200
 8018a4a: e7cd         	b	0x80189e8 <skip_to_arg+0x98> @ imm = #-0x66
 8018a4c: 05ec         	lsls	r4, r5, #0x17
 8018a4e: bf48         	it	mi
 8018a50: f445 7500    	orrmi	r5, r5, #0x200
 8018a54: f445 7580    	orr	r5, r5, #0x100
 8018a58: e7aa         	b	0x80189b0 <skip_to_arg+0x60> @ imm = #-0xac
 8018a5a: f445 7520    	orr	r5, r5, #0x280
 8018a5e: e7a7         	b	0x80189b0 <skip_to_arg+0x60> @ imm = #-0xb2
 8018a60: 469c         	mov	r12, r3
 8018a62: e7b8         	b	0x80189d6 <skip_to_arg+0x86> @ imm = #-0x90
 8018a64: 2463         	movs	r4, #0x63
 8018a66: e7d6         	b	0x8018a16 <skip_to_arg+0xc6> @ imm = #-0x54
 8018a68: 2c69         	cmp	r4, #0x69
 8018a6a: d002         	beq	0x8018a72 <skip_to_arg+0x122> @ imm = #0x4
 8018a6c: d807         	bhi	0x8018a7e <skip_to_arg+0x12e> @ imm = #0xe
 8018a6e: 2c63         	cmp	r4, #0x63
 8018a70: d003         	beq	0x8018a7a <skip_to_arg+0x12a> @ imm = #0x6
 8018a72: 062f         	lsls	r7, r5, #0x18
 8018a74: d501         	bpl	0x8018a7a <skip_to_arg+0x12a> @ imm = #0x2
 8018a76: 05ac         	lsls	r4, r5, #0x16
 8018a78: d4d7         	bmi	0x8018a2a <skip_to_arg+0xda> @ imm = #-0x52
 8018a7a: 3304         	adds	r3, #0x4
 8018a7c: e7d9         	b	0x8018a32 <skip_to_arg+0xe2> @ imm = #-0x4e
 8018a7e: 2c73         	cmp	r4, #0x73
 8018a80: e7f6         	b	0x8018a70 <skip_to_arg+0x120> @ imm = #-0x14
 8018a82: bf00         	nop

08018a84 <$d>:
 8018a84: 89 28 01 00  	.word	0x00012889

08018a88 <vfprintf>:
 8018a88: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8018a8c: b093         	sub	sp, #0x4c
 8018a8e: 6843         	ldr	r3, [r0, #0x4]
 8018a90: 9301         	str	r3, [sp, #0x4]
 8018a92: 7883         	ldrb	r3, [r0, #0x2]
 8018a94: 4680         	mov	r8, r0
 8018a96: 0798         	lsls	r0, r3, #0x1e
 8018a98: e9cd 1206    	strd	r1, r2, [sp, #24]
 8018a9c: d517         	bpl	0x8018ace <vfprintf+0x46> @ imm = #0x2e
 8018a9e: 920b         	str	r2, [sp, #0x2c]
 8018aa0: 460b         	mov	r3, r1
 8018aa2: 2500         	movs	r5, #0x0
 8018aa4: 781f         	ldrb	r7, [r3]
 8018aa6: b1a7         	cbz	r7, 0x8018ad2 <vfprintf+0x4a> @ imm = #0x28
 8018aa8: 2f25         	cmp	r7, #0x25
 8018aaa: d016         	beq	0x8018ada <vfprintf+0x52> @ imm = #0x2c
 8018aac: 3301         	adds	r3, #0x1
 8018aae: 9305         	str	r3, [sp, #0x14]
 8018ab0: 9b01         	ldr	r3, [sp, #0x4]
 8018ab2: 4641         	mov	r1, r8
 8018ab4: 4638         	mov	r0, r7
 8018ab6: 4798         	blx	r3
 8018ab8: 2800         	cmp	r0, #0x0
 8018aba: f105 0501    	add.w	r5, r5, #0x1
 8018abe: f280 8435    	bge.w	0x801932c <vfprintf+0x8a4> @ imm = #0x86a
 8018ac2: f898 3002    	ldrb.w	r3, [r8, #0x2]
 8018ac6: f043 0304    	orr	r3, r3, #0x4
 8018aca: f888 3002    	strb.w	r3, [r8, #0x2]
 8018ace: f04f 35ff    	mov.w	r5, #0xffffffff
 8018ad2: 4628         	mov	r0, r5
 8018ad4: b013         	add	sp, #0x4c
 8018ad6: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8018ada: 785f         	ldrb	r7, [r3, #0x1]
 8018adc: 1c9a         	adds	r2, r3, #0x2
 8018ade: 2f25         	cmp	r7, #0x25
 8018ae0: 9205         	str	r2, [sp, #0x14]
 8018ae2: d0e5         	beq	0x8018ab0 <vfprintf+0x28> @ imm = #-0x36
 8018ae4: 2400         	movs	r4, #0x0
 8018ae6: 4626         	mov	r6, r4
 8018ae8: 46a2         	mov	r10, r4
 8018aea: 46a3         	mov	r11, r4
 8018aec: f1bb 0f1f    	cmp.w	r11, #0x1f
 8018af0: d832         	bhi	0x8018b58 <vfprintf+0xd0> @ imm = #0x64
 8018af2: f1a7 0320    	sub.w	r3, r7, #0x20
 8018af6: 2b10         	cmp	r3, #0x10
 8018af8: d80a         	bhi	0x8018b10 <vfprintf+0x88> @ imm = #0x14
 8018afa: e8df f003    	tbb	[pc, r3]

08018afe <$d>:
 8018afe: 24 09 09 2a  	.word	0x2a090924
 8018b02: 09 09 09 1b  	.word	0x1b090909
 8018b06: 09 09 09 22  	.word	0x22090909
 8018b0a: 09 27 09 09  	.word	0x09092709
 8018b0e: 19           	.byte	0x19

08018b0f <$d>:
 8018b0f: 00           	.byte	0x00

08018b10 <$t>:
 8018b10: f1a7 0330    	sub.w	r3, r7, #0x30
 8018b14: 2b09         	cmp	r3, #0x9
 8018b16: d92d         	bls	0x8018b74 <vfprintf+0xec> @ imm = #0x5a
 8018b18: 2f2a         	cmp	r7, #0x2a
 8018b1a: d139         	bne	0x8018b90 <vfprintf+0x108> @ imm = #0x72
 8018b1c: b954         	cbnz	r4, 0x8018b34 <vfprintf+0xac> @ imm = #0x14
 8018b1e: 9b0b         	ldr	r3, [sp, #0x2c]
 8018b20: f01b 0f40    	tst.w	r11, #0x40
 8018b24: f853 2b04    	ldr	r2, [r3], #4
 8018b28: 930b         	str	r3, [sp, #0x2c]
 8018b2a: d029         	beq	0x8018b80 <vfprintf+0xf8> @ imm = #0x52
 8018b2c: 4616         	mov	r6, r2
 8018b2e: e001         	b	0x8018b34 <vfprintf+0xac> @ imm = #0x2
 8018b30: f04b 0b01    	orr	r11, r11, #0x1
 8018b34: 9b05         	ldr	r3, [sp, #0x14]
 8018b36: f813 7b01    	ldrb	r7, [r3], #1
 8018b3a: 9305         	str	r3, [sp, #0x14]
 8018b3c: 2f00         	cmp	r7, #0x0
 8018b3e: d1d5         	bne	0x8018aec <vfprintf+0x64> @ imm = #-0x56
 8018b40: e05b         	b	0x8018bfa <vfprintf+0x172> @ imm = #0xb6
 8018b42: f04b 0b02    	orr	r11, r11, #0x2
 8018b46: f04b 0b04    	orr	r11, r11, #0x4
 8018b4a: e7f3         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0x1a
 8018b4c: f04b 0b08    	orr	r11, r11, #0x8
 8018b50: e7f0         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0x20
 8018b52: f04b 0b10    	orr	r11, r11, #0x10
 8018b56: e7ed         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0x26
 8018b58: f1bb 0f7f    	cmp.w	r11, #0x7f
 8018b5c: d83f         	bhi	0x8018bde <vfprintf+0x156> @ imm = #0x7e
 8018b5e: f1a7 0330    	sub.w	r3, r7, #0x30
 8018b62: 2b09         	cmp	r3, #0x9
 8018b64: d8d8         	bhi	0x8018b18 <vfprintf+0x90> @ imm = #-0x50
 8018b66: f01b 0f40    	tst.w	r11, #0x40
 8018b6a: d003         	beq	0x8018b74 <vfprintf+0xec> @ imm = #0x6
 8018b6c: 220a         	movs	r2, #0xa
 8018b6e: fb02 3606    	mla	r6, r2, r6, r3
 8018b72: e7df         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0x42
 8018b74: 220a         	movs	r2, #0xa
 8018b76: fb02 3a0a    	mla	r10, r2, r10, r3
 8018b7a: f04b 0b20    	orr	r11, r11, #0x20
 8018b7e: e7d9         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0x4e
 8018b80: f1b2 0a00    	subs.w	r10, r2, #0x0
 8018b84: daf9         	bge	0x8018b7a <vfprintf+0xf2> @ imm = #-0xe
 8018b86: f1ca 0a00    	rsb.w	r10, r10, #0x0
 8018b8a: f04b 0b28    	orr	r11, r11, #0x28
 8018b8e: e7d1         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0x5e
 8018b90: 2f2e         	cmp	r7, #0x2e
 8018b92: d105         	bne	0x8018ba0 <vfprintf+0x118> @ imm = #0xa
 8018b94: f01b 0f40    	tst.w	r11, #0x40
 8018b98: d19b         	bne	0x8018ad2 <vfprintf+0x4a> @ imm = #-0xca
 8018b9a: f04b 0b40    	orr	r11, r11, #0x40
 8018b9e: e7c9         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0x6e
 8018ba0: 2f24         	cmp	r7, #0x24
 8018ba2: d11c         	bne	0x8018bde <vfprintf+0x156> @ imm = #0x38
 8018ba4: 2c00         	cmp	r4, #0x0
 8018ba6: f000 8141    	beq.w	0x8018e2c <vfprintf+0x3a4> @ imm = #0x282
 8018baa: 9b07         	ldr	r3, [sp, #0x1c]
 8018bac: 930b         	str	r3, [sp, #0x2c]
 8018bae: f01b 0f40    	tst.w	r11, #0x40
 8018bb2: d10a         	bne	0x8018bca <vfprintf+0x142> @ imm = #0x14
 8018bb4: 4652         	mov	r2, r10
 8018bb6: 9806         	ldr	r0, [sp, #0x18]
 8018bb8: a90b         	add	r1, sp, #0x2c
 8018bba: f7ff fec9    	bl	0x8018950 <skip_to_arg> @ imm = #-0x26e
 8018bbe: 9b0b         	ldr	r3, [sp, #0x2c]
 8018bc0: 1d1a         	adds	r2, r3, #0x4
 8018bc2: f8d3 a000    	ldr.w	r10, [r3]
 8018bc6: 920b         	str	r2, [sp, #0x2c]
 8018bc8: e7b4         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0x98
 8018bca: 4632         	mov	r2, r6
 8018bcc: 9806         	ldr	r0, [sp, #0x18]
 8018bce: a90b         	add	r1, sp, #0x2c
 8018bd0: f7ff febe    	bl	0x8018950 <skip_to_arg> @ imm = #-0x284
 8018bd4: 9b0b         	ldr	r3, [sp, #0x2c]
 8018bd6: 1d1a         	adds	r2, r3, #0x4
 8018bd8: 681e         	ldr	r6, [r3]
 8018bda: 920b         	str	r2, [sp, #0x2c]
 8018bdc: e7aa         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0xac
 8018bde: 2f6c         	cmp	r7, #0x6c
 8018be0: f000 8111    	beq.w	0x8018e06 <vfprintf+0x37e> @ imm = #0x222
 8018be4: f200 8108    	bhi.w	0x8018df8 <vfprintf+0x370> @ imm = #0x210
 8018be8: 2f68         	cmp	r7, #0x68
 8018bea: f000 8114    	beq.w	0x8018e16 <vfprintf+0x38e> @ imm = #0x228
 8018bee: 2f6a         	cmp	r7, #0x6a
 8018bf0: f000 8119    	beq.w	0x8018e26 <vfprintf+0x39e> @ imm = #0x232
 8018bf4: 2f4c         	cmp	r7, #0x4c
 8018bf6: f000 8116    	beq.w	0x8018e26 <vfprintf+0x39e> @ imm = #0x22c
 8018bfa: b134         	cbz	r4, 0x8018c0a <vfprintf+0x182> @ imm = #0xc
 8018bfc: 9b07         	ldr	r3, [sp, #0x1c]
 8018bfe: 9806         	ldr	r0, [sp, #0x18]
 8018c00: 930b         	str	r3, [sp, #0x2c]
 8018c02: 4622         	mov	r2, r4
 8018c04: a90b         	add	r1, sp, #0x2c
 8018c06: f7ff fea3    	bl	0x8018950 <skip_to_arg> @ imm = #-0x2ba
 8018c0a: 2e00         	cmp	r6, #0x0
 8018c0c: f047 0920    	orr	r9, r7, #0x20
 8018c10: bfb8         	it	lt
 8018c12: f02b 0b40    	biclt	r11, r11, #0x40
 8018c16: f1a9 0365    	sub.w	r3, r9, #0x65
 8018c1a: bfbc         	itt	lt
 8018c1c: fa1f fb8b    	uxthlt.w	r11, r11
 8018c20: 2600         	movlt	r6, #0x0
 8018c22: 2b02         	cmp	r3, #0x2
 8018c24: f240 8107    	bls.w	0x8018e36 <vfprintf+0x3ae> @ imm = #0x20e
 8018c28: f1b9 0f61    	cmp.w	r9, #0x61
 8018c2c: f040 8264    	bne.w	0x80190f8 <vfprintf+0x670> @ imm = #0x4c8
 8018c30: 43ff         	mvns	r7, r7
 8018c32: f007 0320    	and	r3, r7, #0x20
 8018c36: 9304         	str	r3, [sp, #0x10]
 8018c38: 9b0b         	ldr	r3, [sp, #0x2c]
 8018c3a: 3307         	adds	r3, #0x7
 8018c3c: f023 0307    	bic	r3, r3, #0x7
 8018c40: f01b 0f40    	tst.w	r11, #0x40
 8018c44: f103 0208    	add.w	r2, r3, #0x8
 8018c48: bf08         	it	eq
 8018c4a: f04f 36ff    	moveq.w	r6, #0xffffffff
 8018c4e: ed93 0b00    	<unknown>
 8018c52: 920b         	str	r2, [sp, #0x2c]
 8018c54: 4631         	mov	r1, r6
 8018c56: 9a04         	ldr	r2, [sp, #0x10]
 8018c58: a80c         	add	r0, sp, #0x30
 8018c5a: f010 fb9c    	bl	0x8029396 <__dtox_engine> @ imm = #0x10738
 8018c5e: 3001         	adds	r0, #0x1
 8018c60: b2c3         	uxtb	r3, r0
 8018c62: 42b3         	cmp	r3, r6
 8018c64: f44b 54c0    	orr	r4, r11, #0x1800
 8018c68: 9302         	str	r3, [sp, #0x8]
 8018c6a: db01         	blt	0x8018c70 <vfprintf+0x1e8> @ imm = #0x2
 8018c6c: 9b02         	ldr	r3, [sp, #0x8]
 8018c6e: 1e5e         	subs	r6, r3, #0x1
 8018c70: 2301         	movs	r3, #0x1
 8018c72: 9f0c         	ldr	r7, [sp, #0x30]
 8018c74: 9303         	str	r3, [sp, #0xc]
 8018c76: 46a3         	mov	r11, r4
 8018c78: f04f 0970    	mov.w	r9, #0x70
 8018c7c: f107 0309    	add.w	r3, r7, #0x9
 8018c80: 2b12         	cmp	r3, #0x12
 8018c82: d90d         	bls	0x8018ca0 <vfprintf+0x218> @ imm = #0x1a
 8018c84: f107 0363    	add.w	r3, r7, #0x63
 8018c88: 2bc6         	cmp	r3, #0xc6
 8018c8a: f240 810d    	bls.w	0x8018ea8 <vfprintf+0x420> @ imm = #0x21a
 8018c8e: f207 33e7    	addw	r3, r7, #0x3e7
 8018c92: f240 72ce    	movw	r2, #0x7ce
 8018c96: 4293         	cmp	r3, r2
 8018c98: bf94         	ite	ls
 8018c9a: 2303         	movls	r3, #0x3
 8018c9c: 2304         	movhi	r3, #0x4
 8018c9e: 9303         	str	r3, [sp, #0xc]
 8018ca0: f89d 2034    	ldrb.w	r2, [sp, #0x34]
 8018ca4: f002 030c    	and	r3, r2, #0xc
 8018ca8: f012 0201    	ands	r2, r2, #0x1
 8018cac: f040 8117    	bne.w	0x8018ede <vfprintf+0x456> @ imm = #0x22e
 8018cb0: f01b 0f02    	tst.w	r11, #0x2
 8018cb4: f040 8110    	bne.w	0x8018ed8 <vfprintf+0x450> @ imm = #0x220
 8018cb8: f01b 0404    	ands	r4, r11, #0x4
 8018cbc: f000 80f6    	beq.w	0x8018eac <vfprintf+0x424> @ imm = #0x1ec
 8018cc0: 2b00         	cmp	r3, #0x0
 8018cc2: f040 810f    	bne.w	0x8018ee4 <vfprintf+0x45c> @ imm = #0x21e
 8018cc6: 2320         	movs	r3, #0x20
 8018cc8: f41b 5f40    	tst.w	r11, #0x3000
 8018ccc: d11f         	bne	0x8018d0e <vfprintf+0x286> @ imm = #0x3e
 8018cce: 9a02         	ldr	r2, [sp, #0x8]
 8018cd0: 3248         	adds	r2, #0x48
 8018cd2: 2e00         	cmp	r6, #0x0
 8018cd4: 446a         	add	r2, sp, r2
 8018cd6: bf08         	it	eq
 8018cd8: 2601         	moveq	r6, #0x1
 8018cda: 3a13         	subs	r2, #0x13
 8018cdc: 9902         	ldr	r1, [sp, #0x8]
 8018cde: b121         	cbz	r1, 0x8018cea <vfprintf+0x262> @ imm = #0x8
 8018ce0: f812 1d01    	ldrb	r1, [r2, #-1]!
 8018ce4: 2930         	cmp	r1, #0x30
 8018ce6: f000 8134    	beq.w	0x8018f52 <vfprintf+0x4ca> @ imm = #0x268
 8018cea: f01b 0f10    	tst.w	r11, #0x10
 8018cee: 9a02         	ldr	r2, [sp, #0x8]
 8018cf0: bf18         	it	ne
 8018cf2: 4632         	movne	r2, r6
 8018cf4: 1d39         	adds	r1, r7, #0x4
 8018cf6: f2c0 8131    	blt.w	0x8018f5c <vfprintf+0x4d4> @ imm = #0x262
 8018cfa: 42b7         	cmp	r7, r6
 8018cfc: f280 812e    	bge.w	0x8018f5c <vfprintf+0x4d4> @ imm = #0x25c
 8018d00: 42ba         	cmp	r2, r7
 8018d02: f44b 5b00    	orr	r11, r11, #0x2000
 8018d06: f340 812b    	ble.w	0x8018f60 <vfprintf+0x4d8> @ imm = #0x256
 8018d0a: 1c7e         	adds	r6, r7, #0x1
 8018d0c: 1b96         	subs	r6, r2, r6
 8018d0e: f41b 5200    	ands	r2, r11, #0x2000
 8018d12: 9208         	str	r2, [sp, #0x20]
 8018d14: f000 8126    	beq.w	0x8018f64 <vfprintf+0x4dc> @ imm = #0x24c
 8018d18: ea27 74e7    	bic.w	r4, r7, r7, asr #31
 8018d1c: 3401         	adds	r4, #0x1
 8018d1e: b103         	cbz	r3, 0x8018d22 <vfprintf+0x29a> @ imm = #0x0
 8018d20: 3401         	adds	r4, #0x1
 8018d22: 2e00         	cmp	r6, #0x0
 8018d24: f000 8126    	beq.w	0x8018f74 <vfprintf+0x4ec> @ imm = #0x24c
 8018d28: 1c72         	adds	r2, r6, #0x1
 8018d2a: 4414         	add	r4, r2
 8018d2c: 45a2         	cmp	r10, r4
 8018d2e: bfcc         	ite	gt
 8018d30: ebaa 0404    	subgt.w	r4, r10, r4
 8018d34: 2400         	movle	r4, #0x0
 8018d36: f01b 0f09    	tst.w	r11, #0x9
 8018d3a: d104         	bne	0x8018d46 <vfprintf+0x2be> @ imm = #0x8
 8018d3c: 442c         	add	r4, r5
 8018d3e: 42a5         	cmp	r5, r4
 8018d40: f040 811d    	bne.w	0x8018f7e <vfprintf+0x4f6> @ imm = #0x23a
 8018d44: 2400         	movs	r4, #0x0
 8018d46: b143         	cbz	r3, 0x8018d5a <vfprintf+0x2d2> @ imm = #0x10
 8018d48: 4618         	mov	r0, r3
 8018d4a: 4641         	mov	r1, r8
 8018d4c: 9b01         	ldr	r3, [sp, #0x4]
 8018d4e: 4798         	blx	r3
 8018d50: 2800         	cmp	r0, #0x0
 8018d52: f105 0501    	add.w	r5, r5, #0x1
 8018d56: f6ff aeb4    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x298
 8018d5a: f41b 6f00    	tst.w	r11, #0x800
 8018d5e: d013         	beq	0x8018d88 <vfprintf+0x300> @ imm = #0x26
 8018d60: 9b01         	ldr	r3, [sp, #0x4]
 8018d62: 4641         	mov	r1, r8
 8018d64: 2030         	movs	r0, #0x30
 8018d66: 4798         	blx	r3
 8018d68: 2800         	cmp	r0, #0x0
 8018d6a: f6ff aeaa    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x2ac
 8018d6e: 9b04         	ldr	r3, [sp, #0x10]
 8018d70: f1c3 0078    	rsb.w	r0, r3, #0x78
 8018d74: 4641         	mov	r1, r8
 8018d76: 9b01         	ldr	r3, [sp, #0x4]
 8018d78: f000 00f8    	and	r0, r0, #0xf8
 8018d7c: 4798         	blx	r3
 8018d7e: 2800         	cmp	r0, #0x0
 8018d80: f105 0502    	add.w	r5, r5, #0x2
 8018d84: f6ff ae9d    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x2c6
 8018d88: f01b 0f08    	tst.w	r11, #0x8
 8018d8c: d105         	bne	0x8018d9a <vfprintf+0x312> @ imm = #0xa
 8018d8e: 442c         	add	r4, r5
 8018d90: 42ac         	cmp	r4, r5
 8018d92: f040 8100    	bne.w	0x8018f96 <vfprintf+0x50e> @ imm = #0x200
 8018d96: 4625         	mov	r5, r4
 8018d98: 2400         	movs	r4, #0x0
 8018d9a: 9b08         	ldr	r3, [sp, #0x20]
 8018d9c: 2b00         	cmp	r3, #0x0
 8018d9e: f000 811a    	beq.w	0x8018fd6 <vfprintf+0x54e> @ imm = #0x234
 8018da2: ea27 7ae7    	bic.w	r10, r7, r7, asr #31
 8018da6: eba7 070a    	sub.w	r7, r7, r10
 8018daa: 4276         	rsbs	r6, r6, #0
 8018dac: 9b02         	ldr	r3, [sp, #0x8]
 8018dae: 42bb         	cmp	r3, r7
 8018db0: bf84         	itt	hi
 8018db2: ab0c         	addhi	r3, sp, #0x30
 8018db4: 18fb         	addhi	r3, r7, r3
 8018db6: f10a 3aff    	add.w	r10, r10, #0xffffffff
 8018dba: bf88         	it	hi
 8018dbc: 7958         	ldrbhi	r0, [r3, #0x5]
 8018dbe: 9b01         	ldr	r3, [sp, #0x4]
 8018dc0: bf98         	it	ls
 8018dc2: 2030         	movls	r0, #0x30
 8018dc4: 4556         	cmp	r6, r10
 8018dc6: f105 0901    	add.w	r9, r5, #0x1
 8018dca: 4641         	mov	r1, r8
 8018dcc: f300 80ed    	bgt.w	0x8018faa <vfprintf+0x522> @ imm = #0x1da
 8018dd0: 4798         	blx	r3
 8018dd2: 2800         	cmp	r0, #0x0
 8018dd4: f107 0701    	add.w	r7, r7, #0x1
 8018dd8: f6ff ae73    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x31a
 8018ddc: f1ba 3fff    	cmp.w	r10, #0xffffffff
 8018de0: d108         	bne	0x8018df4 <vfprintf+0x36c> @ imm = #0x10
 8018de2: 9b01         	ldr	r3, [sp, #0x4]
 8018de4: 4641         	mov	r1, r8
 8018de6: 202e         	movs	r0, #0x2e
 8018de8: 4798         	blx	r3
 8018dea: 2800         	cmp	r0, #0x0
 8018dec: f6ff ae69    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x32e
 8018df0: f105 0902    	add.w	r9, r5, #0x2
 8018df4: 464d         	mov	r5, r9
 8018df6: e7d9         	b	0x8018dac <vfprintf+0x324> @ imm = #-0x4e
 8018df8: 2f74         	cmp	r7, #0x74
 8018dfa: f43f ae9b    	beq.w	0x8018b34 <vfprintf+0xac> @ imm = #-0x2ca
 8018dfe: 2f7a         	cmp	r7, #0x7a
 8018e00: f43f ae98    	beq.w	0x8018b34 <vfprintf+0xac> @ imm = #-0x2d0
 8018e04: e6f9         	b	0x8018bfa <vfprintf+0x172> @ imm = #-0x20e
 8018e06: f01b 0f80    	tst.w	r11, #0x80
 8018e0a: bf18         	it	ne
 8018e0c: f44b 7b00    	orrne	r11, r11, #0x200
 8018e10: f04b 0b80    	orr	r11, r11, #0x80
 8018e14: e68e         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0x2e4
 8018e16: f41b 7f80    	tst.w	r11, #0x100
 8018e1a: bf18         	it	ne
 8018e1c: f44b 7b00    	orrne	r11, r11, #0x200
 8018e20: f44b 7b80    	orr	r11, r11, #0x100
 8018e24: e686         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0x2f4
 8018e26: f44b 7b20    	orr	r11, r11, #0x280
 8018e2a: e683         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0x2fa
 8018e2c: 4626         	mov	r6, r4
 8018e2e: 46b3         	mov	r11, r6
 8018e30: 4654         	mov	r4, r10
 8018e32: 46b2         	mov	r10, r6
 8018e34: e67e         	b	0x8018b34 <vfprintf+0xac> @ imm = #-0x304
 8018e36: 43ff         	mvns	r7, r7
 8018e38: f007 0320    	and	r3, r7, #0x20
 8018e3c: 9304         	str	r3, [sp, #0x10]
 8018e3e: 9b0b         	ldr	r3, [sp, #0x2c]
 8018e40: 3307         	adds	r3, #0x7
 8018e42: f023 0307    	bic	r3, r3, #0x7
 8018e46: f01b 0f40    	tst.w	r11, #0x40
 8018e4a: f103 0208    	add.w	r2, r3, #0x8
 8018e4e: bf08         	it	eq
 8018e50: 2606         	moveq	r6, #0x6
 8018e52: f1b9 0f65    	cmp.w	r9, #0x65
 8018e56: ed93 0b00    	<unknown>
 8018e5a: 920b         	str	r2, [sp, #0x2c]
 8018e5c: d111         	bne	0x8018e82 <vfprintf+0x3fa> @ imm = #0x22
 8018e5e: 1c71         	adds	r1, r6, #0x1
 8018e60: 2200         	movs	r2, #0x0
 8018e62: b2c9         	uxtb	r1, r1
 8018e64: f44b 5b80    	orr	r11, r11, #0x1000
 8018e68: 4613         	mov	r3, r2
 8018e6a: 2911         	cmp	r1, #0x11
 8018e6c: bf28         	it	hs
 8018e6e: 2111         	movhs	r1, #0x11
 8018e70: a80c         	add	r0, sp, #0x30
 8018e72: f000 fafb    	bl	0x801946c <__dtoa_engine> @ imm = #0x5f6
 8018e76: b2c3         	uxtb	r3, r0
 8018e78: 9302         	str	r3, [sp, #0x8]
 8018e7a: 2302         	movs	r3, #0x2
 8018e7c: 9f0c         	ldr	r7, [sp, #0x30]
 8018e7e: 9303         	str	r3, [sp, #0xc]
 8018e80: e6fc         	b	0x8018c7c <vfprintf+0x1f4> @ imm = #-0x208
 8018e82: f1b9 0f66    	cmp.w	r9, #0x66
 8018e86: d105         	bne	0x8018e94 <vfprintf+0x40c> @ imm = #0xa
 8018e88: f44b 5b00    	orr	r11, r11, #0x2000
 8018e8c: 4633         	mov	r3, r6
 8018e8e: 2201         	movs	r2, #0x1
 8018e90: 2111         	movs	r1, #0x11
 8018e92: e7ea         	b	0x8018e6a <vfprintf+0x3e2> @ imm = #-0x2c
 8018e94: b2f1         	uxtb	r1, r6
 8018e96: 2901         	cmp	r1, #0x1
 8018e98: f04f 0200    	mov.w	r2, #0x0
 8018e9c: bf38         	it	lo
 8018e9e: 2101         	movlo	r1, #0x1
 8018ea0: 4613         	mov	r3, r2
 8018ea2: f04f 0965    	mov.w	r9, #0x65
 8018ea6: e7e0         	b	0x8018e6a <vfprintf+0x3e2> @ imm = #-0x40
 8018ea8: 2302         	movs	r3, #0x2
 8018eaa: e6f8         	b	0x8018c9e <vfprintf+0x216> @ imm = #-0x210
 8018eac: 2b00         	cmp	r3, #0x0
 8018eae: f43f af0b    	beq.w	0x8018cc8 <vfprintf+0x240> @ imm = #-0x1ea
 8018eb2: f1ba 0f03    	cmp.w	r10, #0x3
 8018eb6: dc3b         	bgt	0x8018f30 <vfprintf+0x4a8> @ imm = #0x76
 8018eb8: f89d 3034    	ldrb.w	r3, [sp, #0x34]
 8018ebc: 4ea5         	ldr	r6, [pc, #0x294]        @ 0x8019154 <vfprintf+0x6cc>
 8018ebe: f013 0f08    	tst.w	r3, #0x8
 8018ec2: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8019158 <vfprintf+0x6d0>
 8018ec4: bf08         	it	eq
 8018ec6: 461e         	moveq	r6, r3
 8018ec8: 4637         	mov	r7, r6
 8018eca: 46b9         	mov	r9, r7
 8018ecc: f817 0b01    	ldrb	r0, [r7], #1
 8018ed0: bbb0         	cbnz	r0, 0x8018f40 <vfprintf+0x4b8> @ imm = #0x6c
 8018ed2: 1bae         	subs	r6, r5, r6
 8018ed4: 44b1         	add	r9, r6
 8018ed6: e07b         	b	0x8018fd0 <vfprintf+0x548> @ imm = #0xf6
 8018ed8: bb33         	cbnz	r3, 0x8018f28 <vfprintf+0x4a0> @ imm = #0x4c
 8018eda: 232b         	movs	r3, #0x2b
 8018edc: e6f4         	b	0x8018cc8 <vfprintf+0x240> @ imm = #-0x218
 8018ede: bb2b         	cbnz	r3, 0x8018f2c <vfprintf+0x4a4> @ imm = #0x4a
 8018ee0: 232d         	movs	r3, #0x2d
 8018ee2: e6f1         	b	0x8018cc8 <vfprintf+0x240> @ imm = #-0x21e
 8018ee4: 2220         	movs	r2, #0x20
 8018ee6: f1ba 0f04    	cmp.w	r10, #0x4
 8018eea: dd13         	ble	0x8018f14 <vfprintf+0x48c> @ imm = #0x26
 8018eec: f01b 0f08    	tst.w	r11, #0x8
 8018ef0: f1aa 0404    	sub.w	r4, r10, #0x4
 8018ef4: d10f         	bne	0x8018f16 <vfprintf+0x48e> @ imm = #0x1e
 8018ef6: 442c         	add	r4, r5
 8018ef8: 9b01         	ldr	r3, [sp, #0x4]
 8018efa: 9202         	str	r2, [sp, #0x8]
 8018efc: 4641         	mov	r1, r8
 8018efe: 2020         	movs	r0, #0x20
 8018f00: 4798         	blx	r3
 8018f02: 2800         	cmp	r0, #0x0
 8018f04: f105 0501    	add.w	r5, r5, #0x1
 8018f08: f6ff addb    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x44a
 8018f0c: 42a5         	cmp	r5, r4
 8018f0e: 9a02         	ldr	r2, [sp, #0x8]
 8018f10: d1f2         	bne	0x8018ef8 <vfprintf+0x470> @ imm = #-0x1c
 8018f12: b19a         	cbz	r2, 0x8018f3c <vfprintf+0x4b4> @ imm = #0x26
 8018f14: 2400         	movs	r4, #0x0
 8018f16: 9b01         	ldr	r3, [sp, #0x4]
 8018f18: 4641         	mov	r1, r8
 8018f1a: 4610         	mov	r0, r2
 8018f1c: 4798         	blx	r3
 8018f1e: 2800         	cmp	r0, #0x0
 8018f20: f105 0501    	add.w	r5, r5, #0x1
 8018f24: dac8         	bge	0x8018eb8 <vfprintf+0x430> @ imm = #-0x70
 8018f26: e5cc         	b	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x468
 8018f28: 222b         	movs	r2, #0x2b
 8018f2a: e7dc         	b	0x8018ee6 <vfprintf+0x45e> @ imm = #-0x48
 8018f2c: 222d         	movs	r2, #0x2d
 8018f2e: e7da         	b	0x8018ee6 <vfprintf+0x45e> @ imm = #-0x4c
 8018f30: f01b 0f08    	tst.w	r11, #0x8
 8018f34: f1aa 0403    	sub.w	r4, r10, #0x3
 8018f38: d1be         	bne	0x8018eb8 <vfprintf+0x430> @ imm = #-0x84
 8018f3a: e7dc         	b	0x8018ef6 <vfprintf+0x46e> @ imm = #-0x48
 8018f3c: 4614         	mov	r4, r2
 8018f3e: e7bb         	b	0x8018eb8 <vfprintf+0x430> @ imm = #-0x8a
 8018f40: 9b04         	ldr	r3, [sp, #0x10]
 8018f42: 1ac0         	subs	r0, r0, r3
 8018f44: 4641         	mov	r1, r8
 8018f46: 9b01         	ldr	r3, [sp, #0x4]
 8018f48: b2c0         	uxtb	r0, r0
 8018f4a: 4798         	blx	r3
 8018f4c: 2800         	cmp	r0, #0x0
 8018f4e: dabc         	bge	0x8018eca <vfprintf+0x442> @ imm = #-0x88
 8018f50: e5b7         	b	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x492
 8018f52: 9902         	ldr	r1, [sp, #0x8]
 8018f54: 3901         	subs	r1, #0x1
 8018f56: b2c9         	uxtb	r1, r1
 8018f58: 9102         	str	r1, [sp, #0x8]
 8018f5a: e6bf         	b	0x8018cdc <vfprintf+0x254> @ imm = #-0x282
 8018f5c: 1e56         	subs	r6, r2, #0x1
 8018f5e: e6d6         	b	0x8018d0e <vfprintf+0x286> @ imm = #-0x254
 8018f60: 2600         	movs	r6, #0x0
 8018f62: e6d4         	b	0x8018d0e <vfprintf+0x286> @ imm = #-0x258
 8018f64: f41b 6f00    	tst.w	r11, #0x800
 8018f68: 9a03         	ldr	r2, [sp, #0xc]
 8018f6a: bf0c         	ite	eq
 8018f6c: 2403         	moveq	r4, #0x3
 8018f6e: 2405         	movne	r4, #0x5
 8018f70: 4414         	add	r4, r2
 8018f72: e6d4         	b	0x8018d1e <vfprintf+0x296> @ imm = #-0x258
 8018f74: f01b 0f10    	tst.w	r11, #0x10
 8018f78: bf18         	it	ne
 8018f7a: 3401         	addne	r4, #0x1
 8018f7c: e6d6         	b	0x8018d2c <vfprintf+0x2a4> @ imm = #-0x254
 8018f7e: 9309         	str	r3, [sp, #0x24]
 8018f80: 4641         	mov	r1, r8
 8018f82: 9b01         	ldr	r3, [sp, #0x4]
 8018f84: 2020         	movs	r0, #0x20
 8018f86: 4798         	blx	r3
 8018f88: 2800         	cmp	r0, #0x0
 8018f8a: 9b09         	ldr	r3, [sp, #0x24]
 8018f8c: f105 0501    	add.w	r5, r5, #0x1
 8018f90: f6bf aed5    	bge.w	0x8018d3e <vfprintf+0x2b6> @ imm = #-0x256
 8018f94: e595         	b	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x4d6
 8018f96: 9b01         	ldr	r3, [sp, #0x4]
 8018f98: 4641         	mov	r1, r8
 8018f9a: 2030         	movs	r0, #0x30
 8018f9c: 4798         	blx	r3
 8018f9e: 2800         	cmp	r0, #0x0
 8018fa0: f105 0501    	add.w	r5, r5, #0x1
 8018fa4: f6bf aef4    	bge.w	0x8018d90 <vfprintf+0x308> @ imm = #-0x218
 8018fa8: e58b         	b	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x4ea
 8018faa: 4798         	blx	r3
 8018fac: 2800         	cmp	r0, #0x0
 8018fae: f6ff ad88    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x4f0
 8018fb2: f01b 0f10    	tst.w	r11, #0x10
 8018fb6: d00b         	beq	0x8018fd0 <vfprintf+0x548> @ imm = #0x16
 8018fb8: f1ba 3fff    	cmp.w	r10, #0xffffffff
 8018fbc: d108         	bne	0x8018fd0 <vfprintf+0x548> @ imm = #0x10
 8018fbe: f105 0902    	add.w	r9, r5, #0x2
 8018fc2: 4641         	mov	r1, r8
 8018fc4: 202e         	movs	r0, #0x2e
 8018fc6: 9b01         	ldr	r3, [sp, #0x4]
 8018fc8: 4798         	blx	r3
 8018fca: 2800         	cmp	r0, #0x0
 8018fcc: f6ff ad79    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x50e
 8018fd0: 464d         	mov	r5, r9
 8018fd2: 444c         	add	r4, r9
 8018fd4: e232         	b	0x801943c <vfprintf+0x9b4> @ imm = #0x464
 8018fd6: f89d 0035    	ldrb.w	r0, [sp, #0x35]
 8018fda: 9b01         	ldr	r3, [sp, #0x4]
 8018fdc: 4641         	mov	r1, r8
 8018fde: 4798         	blx	r3
 8018fe0: 2800         	cmp	r0, #0x0
 8018fe2: f6ff ad6e    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x524
 8018fe6: 2e00         	cmp	r6, #0x0
 8018fe8: dd69         	ble	0x80190be <vfprintf+0x636> @ imm = #0xd2
 8018fea: 9b01         	ldr	r3, [sp, #0x4]
 8018fec: 4641         	mov	r1, r8
 8018fee: 202e         	movs	r0, #0x2e
 8018ff0: 4798         	blx	r3
 8018ff2: 2800         	cmp	r0, #0x0
 8018ff4: f6ff ad65    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x536
 8018ff8: f04f 0a01    	mov.w	r10, #0x1
 8018ffc: 9b02         	ldr	r3, [sp, #0x8]
 8018ffe: 459a         	cmp	r10, r3
 8019000: bfbb         	ittet	lt
 8019002: ab0c         	addlt	r3, sp, #0x30
 8019004: 4453         	addlt	r3, r10
 8019006: 2030         	movge	r0, #0x30
 8019008: 7958         	ldrblt	r0, [r3, #0x5]
 801900a: 9b01         	ldr	r3, [sp, #0x4]
 801900c: 4641         	mov	r1, r8
 801900e: 4798         	blx	r3
 8019010: 2800         	cmp	r0, #0x0
 8019012: 46d3         	mov	r11, r10
 8019014: f6ff ad55    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x556
 8019018: f10a 0a01    	add.w	r10, r10, #0x1
 801901c: 4556         	cmp	r6, r10
 801901e: daed         	bge	0x8018ffc <vfprintf+0x574> @ imm = #-0x26
 8019020: 3502         	adds	r5, #0x2
 8019022: 445d         	add	r5, r11
 8019024: 9b04         	ldr	r3, [sp, #0x10]
 8019026: eba9 0003    	sub.w	r0, r9, r3
 801902a: 4641         	mov	r1, r8
 801902c: 9b01         	ldr	r3, [sp, #0x4]
 801902e: b2c0         	uxtb	r0, r0
 8019030: 4798         	blx	r3
 8019032: 2800         	cmp	r0, #0x0
 8019034: f6ff ad45    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x576
 8019038: 2f00         	cmp	r7, #0x0
 801903a: bfb4         	ite	lt
 801903c: 202d         	movlt	r0, #0x2d
 801903e: 202b         	movge	r0, #0x2b
 8019040: 9b01         	ldr	r3, [sp, #0x4]
 8019042: 4641         	mov	r1, r8
 8019044: bfb8         	it	lt
 8019046: 427f         	rsblt	r7, r7, #0
 8019048: 4798         	blx	r3
 801904a: 2800         	cmp	r0, #0x0
 801904c: f6ff ad39    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x58e
 8019050: 9b03         	ldr	r3, [sp, #0xc]
 8019052: 2b04         	cmp	r3, #0x4
 8019054: d141         	bne	0x80190da <vfprintf+0x652> @ imm = #0x82
 8019056: f44f 797a    	mov.w	r9, #0x3e8
 801905a: fbb7 f6f9    	udiv	r6, r7, r9
 801905e: f106 0030    	add.w	r0, r6, #0x30
 8019062: 9b01         	ldr	r3, [sp, #0x4]
 8019064: 4641         	mov	r1, r8
 8019066: b2c0         	uxtb	r0, r0
 8019068: 4798         	blx	r3
 801906a: 2800         	cmp	r0, #0x0
 801906c: f105 0503    	add.w	r5, r5, #0x3
 8019070: f6ff ad27    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x5b2
 8019074: fb09 7716    	mls	r7, r9, r6, r7
 8019078: f04f 0964    	mov.w	r9, #0x64
 801907c: fbb7 f6f9    	udiv	r6, r7, r9
 8019080: f106 0030    	add.w	r0, r6, #0x30
 8019084: 9b01         	ldr	r3, [sp, #0x4]
 8019086: 4641         	mov	r1, r8
 8019088: b2c0         	uxtb	r0, r0
 801908a: 4798         	blx	r3
 801908c: 2800         	cmp	r0, #0x0
 801908e: f105 0501    	add.w	r5, r5, #0x1
 8019092: f6ff ad16    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x5d4
 8019096: fb09 7716    	mls	r7, r9, r6, r7
 801909a: f04f 090a    	mov.w	r9, #0xa
 801909e: fbb7 f6f9    	udiv	r6, r7, r9
 80190a2: f106 0030    	add.w	r0, r6, #0x30
 80190a6: 9b01         	ldr	r3, [sp, #0x4]
 80190a8: 4641         	mov	r1, r8
 80190aa: b2c0         	uxtb	r0, r0
 80190ac: 4798         	blx	r3
 80190ae: 2800         	cmp	r0, #0x0
 80190b0: f105 0501    	add.w	r5, r5, #0x1
 80190b4: f6ff ad05    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x5f6
 80190b8: fb09 7716    	mls	r7, r9, r6, r7
 80190bc: e015         	b	0x80190ea <vfprintf+0x662> @ imm = #0x2a
 80190be: f01b 0f10    	tst.w	r11, #0x10
 80190c2: d101         	bne	0x80190c8 <vfprintf+0x640> @ imm = #0x2
 80190c4: 3501         	adds	r5, #0x1
 80190c6: e7ad         	b	0x8019024 <vfprintf+0x59c> @ imm = #-0xa6
 80190c8: 9b01         	ldr	r3, [sp, #0x4]
 80190ca: 4641         	mov	r1, r8
 80190cc: 202e         	movs	r0, #0x2e
 80190ce: 4798         	blx	r3
 80190d0: 2800         	cmp	r0, #0x0
 80190d2: f105 0502    	add.w	r5, r5, #0x2
 80190d6: daa5         	bge	0x8019024 <vfprintf+0x59c> @ imm = #-0xb6
 80190d8: e4f3         	b	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x61a
 80190da: 9b03         	ldr	r3, [sp, #0xc]
 80190dc: 2b03         	cmp	r3, #0x3
 80190de: f105 0502    	add.w	r5, r5, #0x2
 80190e2: d0c9         	beq	0x8019078 <vfprintf+0x5f0> @ imm = #-0x6e
 80190e4: 9b03         	ldr	r3, [sp, #0xc]
 80190e6: 2b01         	cmp	r3, #0x1
 80190e8: d1d7         	bne	0x801909a <vfprintf+0x612> @ imm = #-0x52
 80190ea: f107 0030    	add.w	r0, r7, #0x30
 80190ee: f105 0901    	add.w	r9, r5, #0x1
 80190f2: 4641         	mov	r1, r8
 80190f4: b2c0         	uxtb	r0, r0
 80190f6: e766         	b	0x8018fc6 <vfprintf+0x53e> @ imm = #-0x134
 80190f8: f1a7 0363    	sub.w	r3, r7, #0x63
 80190fc: 2b12         	cmp	r3, #0x12
 80190fe: f200 80fe    	bhi.w	0x80192fe <vfprintf+0x876> @ imm = #0x1fc
 8019102: e8df f013    	tbh	[pc, r3, lsl #1]

08019106 <$d>:
 8019106: 13 00 56 00  	.word	0x00560013
 801910a: fc 00 fc 00  	.word	0x00fc00fc
 801910e: fc 00 fc 00  	.word	0x00fc00fc
 8019112: 56 00 fc 00  	.word	0x00fc0056
 8019116: fc 00 fc 00  	.word	0x00fc00fc
 801911a: fc 00 fc 00  	.word	0x00fc00fc
 801911e: 16 01 f7 00  	.word	0x00f70116
 8019122: fc 00 fc 00  	.word	0x00fc00fc
 8019126: 2b 00 fc 00  	.word	0x00fc002b
 801912a: b8 00        	.short	0x00b8

0801912c <$t>:
 801912c: 9b0b         	ldr	r3, [sp, #0x2c]
 801912e: 1d1a         	adds	r2, r3, #0x4
 8019130: 681b         	ldr	r3, [r3]
 8019132: 920b         	str	r2, [sp, #0x2c]
 8019134: f88d 3030    	strb.w	r3, [sp, #0x30]
 8019138: 2401         	movs	r4, #0x1
 801913a: af0c         	add	r7, sp, #0x30
 801913c: f01b 0f08    	tst.w	r11, #0x8
 8019140: d02d         	beq	0x801919e <vfprintf+0x716> @ imm = #0x5a
 8019142: 193e         	adds	r6, r7, r4
 8019144: 46b9         	mov	r9, r7
 8019146: 45b1         	cmp	r9, r6
 8019148: d12b         	bne	0x80191a2 <vfprintf+0x71a> @ imm = #0x56
 801914a: 1bef         	subs	r7, r5, r7
 801914c: 44b9         	add	r9, r7
 801914e: ebaa 0404    	sub.w	r4, r10, r4
 8019152: e73d         	b	0x8018fd0 <vfprintf+0x548> @ imm = #-0x186

08019154 <$d>:
 8019154: fd eb 02 08  	.word	0x0802ebfd
 8019158: f9 eb 02 08  	.word	0x0802ebf9

0801915c <$t>:
 801915c: 9b0b         	ldr	r3, [sp, #0x2c]
 801915e: 1d1a         	adds	r2, r3, #0x4
 8019160: 920b         	str	r2, [sp, #0x2c]
 8019162: 681f         	ldr	r7, [r3]
 8019164: 4bab         	ldr	r3, [pc, #0x2ac]        @ 0x8019414 <vfprintf+0x98c>
 8019166: 2f00         	cmp	r7, #0x0
 8019168: bf08         	it	eq
 801916a: 461f         	moveq	r7, r3
 801916c: f01b 0f40    	tst.w	r11, #0x40
 8019170: bf14         	ite	ne
 8019172: 4631         	movne	r1, r6
 8019174: f04f 31ff    	moveq.w	r1, #0xffffffff
 8019178: 4638         	mov	r0, r7
 801917a: f00f ffe1    	bl	0x8029140 <strnlen>     @ imm = #0xffc2
 801917e: 4604         	mov	r4, r0
 8019180: e7dc         	b	0x801913c <vfprintf+0x6b4> @ imm = #-0x48
 8019182: 9b01         	ldr	r3, [sp, #0x4]
 8019184: 4641         	mov	r1, r8
 8019186: 2020         	movs	r0, #0x20
 8019188: 4798         	blx	r3
 801918a: 2800         	cmp	r0, #0x0
 801918c: f6ff ac99    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x6ce
 8019190: 3e01         	subs	r6, #0x1
 8019192: 42b4         	cmp	r4, r6
 8019194: d3f5         	blo	0x8019182 <vfprintf+0x6fa> @ imm = #-0x16
 8019196: 4455         	add	r5, r10
 8019198: 1bad         	subs	r5, r5, r6
 801919a: 46b2         	mov	r10, r6
 801919c: e7d1         	b	0x8019142 <vfprintf+0x6ba> @ imm = #-0x5e
 801919e: 4656         	mov	r6, r10
 80191a0: e7f7         	b	0x8019192 <vfprintf+0x70a> @ imm = #-0x12
 80191a2: f819 0b01    	ldrb	r0, [r9], #1
 80191a6: 9b01         	ldr	r3, [sp, #0x4]
 80191a8: 4641         	mov	r1, r8
 80191aa: 4798         	blx	r3
 80191ac: 2800         	cmp	r0, #0x0
 80191ae: daca         	bge	0x8019146 <vfprintf+0x6be> @ imm = #-0x6c
 80191b0: e487         	b	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x6f2
 80191b2: f01b 0f80    	tst.w	r11, #0x80
 80191b6: 9b0b         	ldr	r3, [sp, #0x2c]
 80191b8: d035         	beq	0x8019226 <vfprintf+0x79e> @ imm = #0x6a
 80191ba: f41b 7f00    	tst.w	r11, #0x200
 80191be: d02d         	beq	0x801921c <vfprintf+0x794> @ imm = #0x5a
 80191c0: 3307         	adds	r3, #0x7
 80191c2: f023 0307    	bic	r3, r3, #0x7
 80191c6: e9d3 0100    	ldrd	r0, r1, [r3]
 80191ca: f103 0208    	add.w	r2, r3, #0x8
 80191ce: 920b         	str	r2, [sp, #0x2c]
 80191d0: f02b 0910    	bic	r9, r11, #0x10
 80191d4: 2900         	cmp	r1, #0x0
 80191d6: fa1f f989    	uxth.w	r9, r9
 80191da: da36         	bge	0x801924a <vfprintf+0x7c2> @ imm = #0x6c
 80191dc: 4240         	rsbs	r0, r0, #0
 80191de: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80191e2: f449 6980    	orr	r9, r9, #0x400
 80191e6: f10d 0b30    	add.w	r11, sp, #0x30
 80191ea: 230a         	movs	r3, #0xa
 80191ec: 465a         	mov	r2, r11
 80191ee: f00f ffb3    	bl	0x8029158 <__ultoa_invert> @ imm = #0xff66
 80191f2: f019 0f40    	tst.w	r9, #0x40
 80191f6: eba0 0b0b    	sub.w	r11, r0, r11
 80191fa: d065         	beq	0x80192c8 <vfprintf+0x840> @ imm = #0xca
 80191fc: f029 0201    	bic	r2, r9, #0x1
 8019200: 455e         	cmp	r6, r11
 8019202: b292         	uxth	r2, r2
 8019204: f340 80b2    	ble.w	0x801936c <vfprintf+0x8e4> @ imm = #0x164
 8019208: 2f00         	cmp	r7, #0x0
 801920a: f000 80a9    	beq.w	0x8019360 <vfprintf+0x8d8> @ imm = #0x152
 801920e: f019 0310    	ands	r3, r9, #0x10
 8019212: 4634         	mov	r4, r6
 8019214: 4691         	mov	r9, r2
 8019216: d026         	beq	0x8019266 <vfprintf+0x7de> @ imm = #0x4c
 8019218: 3402         	adds	r4, #0x2
 801921a: e05c         	b	0x80192d6 <vfprintf+0x84e> @ imm = #0xb8
 801921c: 1d1a         	adds	r2, r3, #0x4
 801921e: 6818         	ldr	r0, [r3]
 8019220: 920b         	str	r2, [sp, #0x2c]
 8019222: 17c1         	asrs	r1, r0, #0x1f
 8019224: e7d4         	b	0x80191d0 <vfprintf+0x748> @ imm = #-0x58
 8019226: 1d1a         	adds	r2, r3, #0x4
 8019228: f41b 7f80    	tst.w	r11, #0x100
 801922c: 6819         	ldr	r1, [r3]
 801922e: 920b         	str	r2, [sp, #0x2c]
 8019230: d101         	bne	0x8019236 <vfprintf+0x7ae> @ imm = #0x2
 8019232: 4608         	mov	r0, r1
 8019234: e7f5         	b	0x8019222 <vfprintf+0x79a> @ imm = #-0x16
 8019236: f41b 7f00    	tst.w	r11, #0x200
 801923a: bf15         	itete	ne
 801923c: b248         	sxtbne	r0, r1
 801923e: b208         	sxtheq	r0, r1
 8019240: f341 11c0    	sbfxne	r1, r1, #0x7, #0x1
 8019244: f341 31c0    	sbfxeq	r1, r1, #0xf, #0x1
 8019248: e7c2         	b	0x80191d0 <vfprintf+0x748> @ imm = #-0x7c
 801924a: ea50 0301    	orrs.w	r3, r0, r1
 801924e: d1ca         	bne	0x80191e6 <vfprintf+0x75e> @ imm = #-0x6c
 8019250: f01b 0f40    	tst.w	r11, #0x40
 8019254: d0c7         	beq	0x80191e6 <vfprintf+0x75e> @ imm = #-0x72
 8019256: 2e00         	cmp	r6, #0x0
 8019258: d1c5         	bne	0x80191e6 <vfprintf+0x75e> @ imm = #-0x76
 801925a: f02b 0b11    	bic	r11, r11, #0x11
 801925e: fa1f f98b    	uxth.w	r9, r11
 8019262: 4634         	mov	r4, r6
 8019264: 46b3         	mov	r11, r6
 8019266: f240 4306    	movw	r3, #0x406
 801926a: ea19 0303    	ands.w	r3, r9, r3
 801926e: bf1c         	itt	ne
 8019270: 3401         	addne	r4, #0x1
 8019272: 2300         	movne	r3, #0x0
 8019274: e02f         	b	0x80192d6 <vfprintf+0x84e> @ imm = #0x5e
 8019276: f02b 0b10    	bic	r11, r11, #0x10
 801927a: fa1f fb8b    	uxth.w	r11, r11
 801927e: 230a         	movs	r3, #0xa
 8019280: f01b 0480    	ands	r4, r11, #0x80
 8019284: 9a0b         	ldr	r2, [sp, #0x2c]
 8019286: d057         	beq	0x8019338 <vfprintf+0x8b0> @ imm = #0xae
 8019288: f41b 7100    	ands	r1, r11, #0x200
 801928c: bf1d         	ittte	ne
 801928e: 3207         	addne	r2, #0x7
 8019290: f022 0207    	bicne	r2, r2, #0x7
 8019294: f102 0108    	addne.w	r1, r2, #0x8
 8019298: 1d10         	addeq	r0, r2, #0x4
 801929a: bf19         	ittee	ne
 801929c: 910b         	strne	r1, [sp, #0x2c]
 801929e: e9d2 0100    	ldrdne	r0, r1, [r2]
 80192a2: 900b         	streq	r0, [sp, #0x2c]
 80192a4: 6810         	ldreq	r0, [r2]
 80192a6: ea50 0201    	orrs.w	r2, r0, r1
 80192aa: d152         	bne	0x8019352 <vfprintf+0x8ca> @ imm = #0xa4
 80192ac: f02b 0916    	bic	r9, r11, #0x16
 80192b0: f01b 0f40    	tst.w	r11, #0x40
 80192b4: fa1f f989    	uxth.w	r9, r9
 80192b8: d04f         	beq	0x801935a <vfprintf+0x8d2> @ imm = #0x9e
 80192ba: 2e00         	cmp	r6, #0x0
 80192bc: d14d         	bne	0x801935a <vfprintf+0x8d2> @ imm = #0x9a
 80192be: f02b 0b17    	bic	r11, r11, #0x17
 80192c2: fa1f f98b    	uxth.w	r9, r11
 80192c6: 46b3         	mov	r11, r6
 80192c8: f019 0310    	ands	r3, r9, #0x10
 80192cc: d052         	beq	0x8019374 <vfprintf+0x8ec> @ imm = #0xa4
 80192ce: 2f00         	cmp	r7, #0x0
 80192d0: d14e         	bne	0x8019370 <vfprintf+0x8e8> @ imm = #0x9c
 80192d2: f10b 0401    	add.w	r4, r11, #0x1
 80192d6: f019 0f08    	tst.w	r9, #0x8
 80192da: d15e         	bne	0x801939a <vfprintf+0x912> @ imm = #0xbc
 80192dc: f019 0f01    	tst.w	r9, #0x1
 80192e0: d006         	beq	0x80192f0 <vfprintf+0x868> @ imm = #0xc
 80192e2: 45a2         	cmp	r10, r4
 80192e4: dd6e         	ble	0x80193c4 <vfprintf+0x93c> @ imm = #0xdc
 80192e6: ebaa 0404    	sub.w	r4, r10, r4
 80192ea: eb04 060b    	add.w	r6, r4, r11
 80192ee: 4654         	mov	r4, r10
 80192f0: 4622         	mov	r2, r4
 80192f2: e04d         	b	0x8019390 <vfprintf+0x908> @ imm = #0x9a
 80192f4: f04b 0b10    	orr	r11, r11, #0x10
 80192f8: 2310         	movs	r3, #0x10
 80192fa: 2778         	movs	r7, #0x78
 80192fc: e7c0         	b	0x8019280 <vfprintf+0x7f8> @ imm = #-0x80
 80192fe: f1b9 0f78    	cmp.w	r9, #0x78
 8019302: d104         	bne	0x801930e <vfprintf+0x886> @ imm = #0x8
 8019304: f1c7 0378    	rsb.w	r3, r7, #0x78
 8019308: f043 0310    	orr	r3, r3, #0x10
 801930c: e7b8         	b	0x8019280 <vfprintf+0x7f8> @ imm = #-0x90
 801930e: 9b01         	ldr	r3, [sp, #0x4]
 8019310: 4641         	mov	r1, r8
 8019312: 2025         	movs	r0, #0x25
 8019314: 4798         	blx	r3
 8019316: 2800         	cmp	r0, #0x0
 8019318: f6ff abd3    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x85a
 801931c: 9b01         	ldr	r3, [sp, #0x4]
 801931e: 4641         	mov	r1, r8
 8019320: 4638         	mov	r0, r7
 8019322: 4798         	blx	r3
 8019324: 2800         	cmp	r0, #0x0
 8019326: f6ff abcc    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x868
 801932a: 3502         	adds	r5, #0x2
 801932c: 9b05         	ldr	r3, [sp, #0x14]
 801932e: f7ff bbb9    	b.w	0x8018aa4 <vfprintf+0x1c> @ imm = #-0x88e
 8019332: 2308         	movs	r3, #0x8
 8019334: 2700         	movs	r7, #0x0
 8019336: e7a3         	b	0x8019280 <vfprintf+0x7f8> @ imm = #-0xba
 8019338: 1d11         	adds	r1, r2, #0x4
 801933a: 910b         	str	r1, [sp, #0x2c]
 801933c: f41b 7180    	ands	r1, r11, #0x100
 8019340: 6810         	ldr	r0, [r2]
 8019342: d0b0         	beq	0x80192a6 <vfprintf+0x81e> @ imm = #-0xa0
 8019344: f41b 7100    	ands	r1, r11, #0x200
 8019348: bf1a         	itte	ne
 801934a: b2c0         	uxtbne	r0, r0
 801934c: 4621         	movne	r1, r4
 801934e: b280         	uxtheq	r0, r0
 8019350: e7a9         	b	0x80192a6 <vfprintf+0x81e> @ imm = #-0xae
 8019352: f02b 0b06    	bic	r11, r11, #0x6
 8019356: fa1f f98b    	uxth.w	r9, r11
 801935a: f10d 0b30    	add.w	r11, sp, #0x30
 801935e: e745         	b	0x80191ec <vfprintf+0x764> @ imm = #-0x176
 8019360: f029 0911    	bic	r9, r9, #0x11
 8019364: fa1f f989    	uxth.w	r9, r9
 8019368: 4634         	mov	r4, r6
 801936a: e77c         	b	0x8019266 <vfprintf+0x7de> @ imm = #-0x108
 801936c: 4691         	mov	r9, r2
 801936e: e7ab         	b	0x80192c8 <vfprintf+0x840> @ imm = #-0xaa
 8019370: 465c         	mov	r4, r11
 8019372: e751         	b	0x8019218 <vfprintf+0x790> @ imm = #-0x15e
 8019374: 465c         	mov	r4, r11
 8019376: e776         	b	0x8019266 <vfprintf+0x7de> @ imm = #-0x114
 8019378: e9cd 2302    	strd	r2, r3, [sp, #8]
 801937c: 4641         	mov	r1, r8
 801937e: 9b01         	ldr	r3, [sp, #0x4]
 8019380: 2020         	movs	r0, #0x20
 8019382: 4798         	blx	r3
 8019384: 2800         	cmp	r0, #0x0
 8019386: f6ff ab9c    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x8c8
 801938a: 9a02         	ldr	r2, [sp, #0x8]
 801938c: 9b03         	ldr	r3, [sp, #0xc]
 801938e: 3201         	adds	r2, #0x1
 8019390: 4592         	cmp	r10, r2
 8019392: dcf1         	bgt	0x8019378 <vfprintf+0x8f0> @ imm = #-0x1e
 8019394: 1b2c         	subs	r4, r5, r4
 8019396: 18a5         	adds	r5, r4, r2
 8019398: 4614         	mov	r4, r2
 801939a: b1f3         	cbz	r3, 0x80193da <vfprintf+0x952> @ imm = #0x3c
 801939c: 9b01         	ldr	r3, [sp, #0x4]
 801939e: 4641         	mov	r1, r8
 80193a0: 2030         	movs	r0, #0x30
 80193a2: 4798         	blx	r3
 80193a4: 2800         	cmp	r0, #0x0
 80193a6: f6ff ab8c    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x8e8
 80193aa: b96f         	cbnz	r7, 0x80193c8 <vfprintf+0x940> @ imm = #0x1a
 80193ac: 3501         	adds	r5, #0x1
 80193ae: 46a9         	mov	r9, r5
 80193b0: 442e         	add	r6, r5
 80193b2: eba6 0309    	sub.w	r3, r6, r9
 80193b6: 455b         	cmp	r3, r11
 80193b8: dc21         	bgt	0x80193fe <vfprintf+0x976> @ imm = #0x42
 80193ba: 465d         	mov	r5, r11
 80193bc: ae0c         	add	r6, sp, #0x30
 80193be: bb5d         	cbnz	r5, 0x8019418 <vfprintf+0x990> @ imm = #0x56
 80193c0: 44d9         	add	r9, r11
 80193c2: e6c4         	b	0x801914e <vfprintf+0x6c6> @ imm = #-0x278
 80193c4: 465e         	mov	r6, r11
 80193c6: e793         	b	0x80192f0 <vfprintf+0x868> @ imm = #-0xda
 80193c8: 3502         	adds	r5, #0x2
 80193ca: 4641         	mov	r1, r8
 80193cc: 4638         	mov	r0, r7
 80193ce: 9b01         	ldr	r3, [sp, #0x4]
 80193d0: 4798         	blx	r3
 80193d2: 2800         	cmp	r0, #0x0
 80193d4: daeb         	bge	0x80193ae <vfprintf+0x926> @ imm = #-0x2a
 80193d6: f7ff bb74    	b.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x918
 80193da: f240 4306    	movw	r3, #0x406
 80193de: ea19 0f03    	tst.w	r9, r3
 80193e2: d0e4         	beq	0x80193ae <vfprintf+0x926> @ imm = #-0x38
 80193e4: f019 0f02    	tst.w	r9, #0x2
 80193e8: bf14         	ite	ne
 80193ea: 202b         	movne	r0, #0x2b
 80193ec: 2020         	moveq	r0, #0x20
 80193ee: f419 6f80    	tst.w	r9, #0x400
 80193f2: f105 0501    	add.w	r5, r5, #0x1
 80193f6: 4641         	mov	r1, r8
 80193f8: bf18         	it	ne
 80193fa: 202d         	movne	r0, #0x2d
 80193fc: e7e7         	b	0x80193ce <vfprintf+0x946> @ imm = #-0x32
 80193fe: 9b01         	ldr	r3, [sp, #0x4]
 8019400: 4641         	mov	r1, r8
 8019402: 2030         	movs	r0, #0x30
 8019404: 4798         	blx	r3
 8019406: 2800         	cmp	r0, #0x0
 8019408: f109 0901    	add.w	r9, r9, #0x1
 801940c: dad1         	bge	0x80193b2 <vfprintf+0x92a> @ imm = #-0x5e
 801940e: f7ff bb58    	b.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x950
 8019412: bf00         	nop

08019414 <$d>:
 8019414: 01 ec 02 08  	.word	0x0802ec01

08019418 <$t>:
 8019418: 3d01         	subs	r5, #0x1
 801941a: 9b01         	ldr	r3, [sp, #0x4]
 801941c: 5d70         	ldrb	r0, [r6, r5]
 801941e: 4641         	mov	r1, r8
 8019420: 4798         	blx	r3
 8019422: 2800         	cmp	r0, #0x0
 8019424: dacb         	bge	0x80193be <vfprintf+0x936> @ imm = #-0x6a
 8019426: f7ff bb4c    	b.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x968
 801942a: 9b01         	ldr	r3, [sp, #0x4]
 801942c: 4641         	mov	r1, r8
 801942e: 2020         	movs	r0, #0x20
 8019430: 4798         	blx	r3
 8019432: 2800         	cmp	r0, #0x0
 8019434: f105 0501    	add.w	r5, r5, #0x1
 8019438: f6ff ab43    	blt.w	0x8018ac2 <vfprintf+0x3a> @ imm = #-0x97a
 801943c: 1b63         	subs	r3, r4, r5
 801943e: 2b00         	cmp	r3, #0x0
 8019440: dcf3         	bgt	0x801942a <vfprintf+0x9a2> @ imm = #-0x1a
 8019442: e773         	b	0x801932c <vfprintf+0x8a4> @ imm = #-0x11a

08019444 <div10>:
 8019444: b51f         	push	{r0, r1, r2, r3, r4, lr}
 8019446: ab02         	add	r3, sp, #0x8
 8019448: 9300         	str	r3, [sp]
 801944a: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8019468 <div10+0x24>
 801944c: f04f 33cc    	mov.w	r3, #0xcccccccc
 8019450: f00f ff67    	bl	0x8029322 <__umul128>   @ imm = #0xfece
 8019454: e9dd 0102    	ldrd	r0, r1, [sp, #8]
 8019458: 08c0         	lsrs	r0, r0, #0x3
 801945a: ea40 7041    	orr.w	r0, r0, r1, lsl #29
 801945e: 08c9         	lsrs	r1, r1, #0x3
 8019460: b005         	add	sp, #0x14
 8019462: f85d fb04    	ldr	pc, [sp], #4
 8019466: bf00         	nop

08019468 <$d>:
 8019468: cd cc cc cc  	.word	0xcccccccd

0801946c <__dtoa_engine>:
 801946c: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8019470: ec55 4b10    	<unknown>
 8019474: b09d         	sub	sp, #0x74
 8019476: e9cd 320c    	strd	r3, r2, [sp, #48]
 801947a: 462a         	mov	r2, r5
 801947c: 910b         	str	r1, [sp, #0x2c]
 801947e: f3c5 0313    	ubfx	r3, r5, #0x0, #0x14
 8019482: 0d29         	lsrs	r1, r5, #0x14
 8019484: 0fd2         	lsrs	r2, r2, #0x1f
 8019486: f3c5 550a    	ubfx	r5, r5, #0x14, #0xb
 801948a: 9007         	str	r0, [sp, #0x1c]
 801948c: ed8d 0a05    	<unknown>
 8019490: 920a         	str	r2, [sp, #0x28]
 8019492: b975         	cbnz	r5, 0x80194b2 <__dtoa_engine+0x46> @ imm = #0x1c
 8019494: 4622         	mov	r2, r4
 8019496: 431a         	orrs	r2, r3
 8019498: d11b         	bne	0x80194d2 <__dtoa_engine+0x66> @ imm = #0x36
 801949a: 2330         	movs	r3, #0x30
 801949c: 7143         	strb	r3, [r0, #0x5]
 801949e: 9b0a         	ldr	r3, [sp, #0x28]
 80194a0: 6005         	str	r5, [r0]
 80194a2: f043 0302    	orr	r3, r3, #0x2
 80194a6: 7103         	strb	r3, [r0, #0x4]
 80194a8: 2701         	movs	r7, #0x1
 80194aa: 4638         	mov	r0, r7
 80194ac: b01d         	add	sp, #0x74
 80194ae: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80194b2: f240 72ff    	movw	r2, #0x7ff
 80194b6: 4295         	cmp	r5, r2
 80194b8: d14d         	bne	0x8019556 <__dtoa_engine+0xea> @ imm = #0x9a
 80194ba: 9a05         	ldr	r2, [sp, #0x14]
 80194bc: 4313         	orrs	r3, r2
 80194be: 9b0a         	ldr	r3, [sp, #0x28]
 80194c0: 9a07         	ldr	r2, [sp, #0x1c]
 80194c2: bf14         	ite	ne
 80194c4: f043 0308    	orrne	r3, r3, #0x8
 80194c8: f043 0304    	orreq	r3, r3, #0x4
 80194cc: 7113         	strb	r3, [r2, #0x4]
 80194ce: 2700         	movs	r7, #0x0
 80194d0: e7eb         	b	0x80194aa <__dtoa_engine+0x3e> @ imm = #-0x2a
 80194d2: 9a05         	ldr	r2, [sp, #0x14]
 80194d4: 4db2         	ldr	r5, [pc, #0x2c8]        @ 0x80197a0 <__dtoa_engine+0x334>
 80194d6: f002 0201    	and	r2, r2, #0x1
 80194da: 9209         	str	r2, [sp, #0x24]
 80194dc: 9a05         	ldr	r2, [sp, #0x14]
 80194de: ea4f 0883    	lsl.w	r8, r3, #0x2
 80194e2: ea48 7892    	orr.w	r8, r8, r2, lsr #30
 80194e6: 0097         	lsls	r7, r2, #0x2
 80194e8: 2201         	movs	r2, #0x1
 80194ea: 469a         	mov	r10, r3
 80194ec: 4616         	mov	r6, r2
 80194ee: f1c5 0b00    	rsb.w	r11, r5, #0x0
 80194f2: 4658         	mov	r0, r11
 80194f4: 9208         	str	r2, [sp, #0x20]
 80194f6: f000 fa17    	bl	0x8019928 <__log10Pow5> @ imm = #0x42e
 80194fa: f1b5 3fff    	cmp.w	r5, #0xffffffff
 80194fe: bfac         	ite	ge
 8019500: 4681         	movge	r9, r0
 8019502: f1a0 0901    	sublt.w	r9, r0, #0x1
 8019506: ebab 0b09    	sub.w	r11, r11, r9
 801950a: eb09 0305    	add.w	r3, r9, r5
 801950e: 4658         	mov	r0, r11
 8019510: 9306         	str	r3, [sp, #0x18]
 8019512: f000 fa0f    	bl	0x8019934 <__pow5bits>  @ imm = #0x41e
 8019516: a918         	add	r1, sp, #0x60
 8019518: f1a0 057d    	sub.w	r5, r0, #0x7d
 801951c: 4658         	mov	r0, r11
 801951e: f000 fa29    	bl	0x8019974 <__double_computePow5> @ imm = #0x452
 8019522: ab14         	add	r3, sp, #0x50
 8019524: 9a08         	ldr	r2, [sp, #0x20]
 8019526: 9301         	str	r3, [sp, #0x4]
 8019528: eba9 0505    	sub.w	r5, r9, r5
 801952c: ab12         	add	r3, sp, #0x48
 801952e: 9202         	str	r2, [sp, #0x8]
 8019530: 9300         	str	r3, [sp]
 8019532: 9805         	ldr	r0, [sp, #0x14]
 8019534: 462b         	mov	r3, r5
 8019536: aa18         	add	r2, sp, #0x60
 8019538: 4651         	mov	r1, r10
 801953a: f00f fe35    	bl	0x80291a8 <mulShiftAll64> @ imm = #0xfc6a
 801953e: f1b9 0f01    	cmp.w	r9, #0x1
 8019542: 4604         	mov	r4, r0
 8019544: 460d         	mov	r5, r1
 8019546: f200 80d8    	bhi.w	0x80196fa <__dtoa_engine+0x28e> @ imm = #0x1b0
 801954a: 9b09         	ldr	r3, [sp, #0x24]
 801954c: 2b00         	cmp	r3, #0x0
 801954e: f040 80cb    	bne.w	0x80196e8 <__dtoa_engine+0x27c> @ imm = #0x196
 8019552: 2701         	movs	r7, #0x1
 8019554: e06f         	b	0x8019636 <__dtoa_engine+0x1ca> @ imm = #0xde
 8019556: 9a05         	ldr	r2, [sp, #0x14]
 8019558: f002 0201    	and	r2, r2, #0x1
 801955c: 9209         	str	r2, [sp, #0x24]
 801955e: 9a05         	ldr	r2, [sp, #0x14]
 8019560: f443 1a80    	orr	r10, r3, #0x100000
 8019564: ea4f 088a    	lsl.w	r8, r10, #0x2
 8019568: 4313         	orrs	r3, r2
 801956a: f2a5 4535    	subw	r5, r5, #0x435
 801956e: ea48 7892    	orr.w	r8, r8, r2, lsr #30
 8019572: ea4f 0782    	lsl.w	r7, r2, #0x2
 8019576: d14b         	bne	0x8019610 <__dtoa_engine+0x1a4> @ imm = #0x96
 8019578: f240 73fe    	movw	r3, #0x7fe
 801957c: 4219         	tst	r1, r3
 801957e: bf0c         	ite	eq
 8019580: 2601         	moveq	r6, #0x1
 8019582: 2600         	movne	r6, #0x0
 8019584: 2d00         	cmp	r5, #0x0
 8019586: 4632         	mov	r2, r6
 8019588: dbb1         	blt	0x80194ee <__dtoa_engine+0x82> @ imm = #-0x9e
 801958a: 4628         	mov	r0, r5
 801958c: f000 f9c6    	bl	0x801991c <__log10Pow2> @ imm = #0x38c
 8019590: 4603         	mov	r3, r0
 8019592: 2d03         	cmp	r5, #0x3
 8019594: bfc8         	it	gt
 8019596: 3b01         	subgt	r3, #0x1
 8019598: 4618         	mov	r0, r3
 801959a: 9306         	str	r3, [sp, #0x18]
 801959c: f000 f9ca    	bl	0x8019934 <__pow5bits>  @ imm = #0x394
 80195a0: 9b06         	ldr	r3, [sp, #0x18]
 80195a2: 307c         	adds	r0, #0x7c
 80195a4: 1b5d         	subs	r5, r3, r5
 80195a6: 4405         	add	r5, r0
 80195a8: a918         	add	r1, sp, #0x60
 80195aa: 4618         	mov	r0, r3
 80195ac: f000 fa56    	bl	0x8019a5c <__double_computeInvPow5> @ imm = #0x4ac
 80195b0: ab14         	add	r3, sp, #0x50
 80195b2: 9301         	str	r3, [sp, #0x4]
 80195b4: ab12         	add	r3, sp, #0x48
 80195b6: 9300         	str	r3, [sp]
 80195b8: 9805         	ldr	r0, [sp, #0x14]
 80195ba: 9602         	str	r6, [sp, #0x8]
 80195bc: 462b         	mov	r3, r5
 80195be: aa18         	add	r2, sp, #0x60
 80195c0: 4651         	mov	r1, r10
 80195c2: f00f fdf1    	bl	0x80291a8 <mulShiftAll64> @ imm = #0xfbe2
 80195c6: 9b06         	ldr	r3, [sp, #0x18]
 80195c8: 2b15         	cmp	r3, #0x15
 80195ca: 4604         	mov	r4, r0
 80195cc: 460d         	mov	r5, r1
 80195ce: f200 8088    	bhi.w	0x80196e2 <__dtoa_engine+0x276> @ imm = #0x110
 80195d2: ab16         	add	r3, sp, #0x58
 80195d4: 4a73         	ldr	r2, [pc, #0x1cc]        @ 0x80197a4 <__dtoa_engine+0x338>
 80195d6: 9300         	str	r3, [sp]
 80195d8: 4638         	mov	r0, r7
 80195da: f04f 33cc    	mov.w	r3, #0xcccccccc
 80195de: 4641         	mov	r1, r8
 80195e0: f00f fe9f    	bl	0x8029322 <__umul128>   @ imm = #0xfd3e
 80195e4: 9b16         	ldr	r3, [sp, #0x58]
 80195e6: 9a17         	ldr	r2, [sp, #0x5c]
 80195e8: 089b         	lsrs	r3, r3, #0x2
 80195ea: ea43 7382    	orr.w	r3, r3, r2, lsl #30
 80195ee: eb03 0383    	add.w	r3, r3, r3, lsl #2
 80195f2: 42bb         	cmp	r3, r7
 80195f4: e9dd 9a12    	ldrd	r9, r10, [sp, #72]
 80195f8: d10c         	bne	0x8019614 <__dtoa_engine+0x1a8> @ imm = #0x18
 80195fa: 4638         	mov	r0, r7
 80195fc: 4641         	mov	r1, r8
 80195fe: f000 f9a1    	bl	0x8019944 <__pow5Factor> @ imm = #0x342
 8019602: 9b06         	ldr	r3, [sp, #0x18]
 8019604: 4283         	cmp	r3, r0
 8019606: bf8c         	ite	hi
 8019608: 2700         	movhi	r7, #0x0
 801960a: 2701         	movls	r7, #0x1
 801960c: 2600         	movs	r6, #0x0
 801960e: e012         	b	0x8019636 <__dtoa_engine+0x1ca> @ imm = #0x24
 8019610: 2601         	movs	r6, #0x1
 8019612: e7b7         	b	0x8019584 <__dtoa_engine+0x118> @ imm = #-0x92
 8019614: 9b09         	ldr	r3, [sp, #0x24]
 8019616: 2b00         	cmp	r3, #0x0
 8019618: d153         	bne	0x80196c2 <__dtoa_engine+0x256> @ imm = #0xa6
 801961a: 3f01         	subs	r7, #0x1
 801961c: f148 31ff    	adc	r1, r8, #0xffffffff
 8019620: 1bb8         	subs	r0, r7, r6
 8019622: f161 0100    	sbc	r1, r1, #0x0
 8019626: f000 f98d    	bl	0x8019944 <__pow5Factor> @ imm = #0x31a
 801962a: 9b06         	ldr	r3, [sp, #0x18]
 801962c: 9f09         	ldr	r7, [sp, #0x24]
 801962e: 4283         	cmp	r3, r0
 8019630: bf8c         	ite	hi
 8019632: 2600         	movhi	r6, #0x0
 8019634: 2601         	movls	r6, #0x1
 8019636: 9b0d         	ldr	r3, [sp, #0x34]
 8019638: 2b00         	cmp	r3, #0x0
 801963a: f040 8093    	bne.w	0x8019764 <__dtoa_engine+0x2f8> @ imm = #0x126
 801963e: f8dd b02c    	ldr.w	r11, [sp, #0x2c]
 8019642: f04f 0800    	mov.w	r8, #0x0
 8019646: f8cd 8020    	str.w	r8, [sp, #0x20]
 801964a: f8cd 8014    	str.w	r8, [sp, #0x14]
 801964e: f04f 0a0a    	mov.w	r10, #0xa
 8019652: e9dd 0112    	ldrd	r0, r1, [sp, #72]
 8019656: f7ff fef5    	bl	0x8019444 <div10>       @ imm = #-0x216
 801965a: 9b14         	ldr	r3, [sp, #0x50]
 801965c: 9310         	str	r3, [sp, #0x40]
 801965e: e9cd 010e    	strd	r0, r1, [sp, #56]
 8019662: 4618         	mov	r0, r3
 8019664: 9915         	ldr	r1, [sp, #0x54]
 8019666: f7ff feed    	bl	0x8019444 <div10>       @ imm = #-0x226
 801966a: 9b0e         	ldr	r3, [sp, #0x38]
 801966c: 9a0f         	ldr	r2, [sp, #0x3c]
 801966e: 9111         	str	r1, [sp, #0x44]
 8019670: 4298         	cmp	r0, r3
 8019672: 460b         	mov	r3, r1
 8019674: 4193         	sbcs	r3, r2
 8019676: 4681         	mov	r9, r0
 8019678: f080 808e    	bhs.w	0x8019798 <__dtoa_engine+0x32c> @ imm = #0x11c
 801967c: 4620         	mov	r0, r4
 801967e: 4629         	mov	r1, r5
 8019680: f7ff fee0    	bl	0x8019444 <div10>       @ imm = #-0x240
 8019684: 9a10         	ldr	r2, [sp, #0x40]
 8019686: fb0a f309    	mul	r3, r10, r9
 801968a: 4293         	cmp	r3, r2
 801968c: bf14         	ite	ne
 801968e: 2600         	movne	r6, #0x0
 8019690: f006 0601    	andeq	r6, r6, #0x1
 8019694: 9b0e         	ldr	r3, [sp, #0x38]
 8019696: 9312         	str	r3, [sp, #0x48]
 8019698: 9b0f         	ldr	r3, [sp, #0x3c]
 801969a: e9cd 3913    	strd	r3, r9, [sp, #76]
 801969e: 9b11         	ldr	r3, [sp, #0x44]
 80196a0: 9315         	str	r3, [sp, #0x54]
 80196a2: 9b08         	ldr	r3, [sp, #0x20]
 80196a4: f1b8 0f00    	cmp.w	r8, #0x0
 80196a8: bf14         	ite	ne
 80196aa: 2700         	movne	r7, #0x0
 80196ac: f007 0701    	andeq	r7, r7, #0x1
 80196b0: 3301         	adds	r3, #0x1
 80196b2: fb0a 4810    	mls	r8, r10, r0, r4
 80196b6: fa5f f888    	uxtb.w	r8, r8
 80196ba: 9308         	str	r3, [sp, #0x20]
 80196bc: 4604         	mov	r4, r0
 80196be: 460d         	mov	r5, r1
 80196c0: e7c7         	b	0x8019652 <__dtoa_engine+0x1e6> @ imm = #-0x72
 80196c2: 1cb8         	adds	r0, r7, #0x2
 80196c4: f148 0100    	adc	r1, r8, #0x0
 80196c8: f000 f93c    	bl	0x8019944 <__pow5Factor> @ imm = #0x278
 80196cc: 9b06         	ldr	r3, [sp, #0x18]
 80196ce: 4283         	cmp	r3, r0
 80196d0: bf8c         	ite	hi
 80196d2: 2000         	movhi	r0, #0x0
 80196d4: 2001         	movls	r0, #0x1
 80196d6: ebb9 0000    	subs.w	r0, r9, r0
 80196da: f16a 0200    	sbc	r2, r10, #0x0
 80196de: e9cd 0212    	strd	r0, r2, [sp, #72]
 80196e2: 2700         	movs	r7, #0x0
 80196e4: 463e         	mov	r6, r7
 80196e6: e7a6         	b	0x8019636 <__dtoa_engine+0x1ca> @ imm = #-0xb4
 80196e8: 9b12         	ldr	r3, [sp, #0x48]
 80196ea: 9a13         	ldr	r2, [sp, #0x4c]
 80196ec: 3b01         	subs	r3, #0x1
 80196ee: f142 32ff    	adc	r2, r2, #0xffffffff
 80196f2: e9cd 3212    	strd	r3, r2, [sp, #72]
 80196f6: 2701         	movs	r7, #0x1
 80196f8: e788         	b	0x801960c <__dtoa_engine+0x1a0> @ imm = #-0xf0
 80196fa: f1b9 0f3e    	cmp.w	r9, #0x3e
 80196fe: d8f0         	bhi	0x80196e2 <__dtoa_engine+0x276> @ imm = #-0x20
 8019700: f04f 33ff    	mov.w	r3, #0xffffffff
 8019704: f1a9 0020    	sub.w	r0, r9, #0x20
 8019708: fa03 f209    	lsl.w	r2, r3, r9
 801970c: fa03 f000    	lsl.w	r0, r3, r0
 8019710: f1c9 0120    	rsb.w	r1, r9, #0x20
 8019714: fa23 f101    	lsr.w	r1, r3, r1
 8019718: 4302         	orrs	r2, r0
 801971a: 430a         	orrs	r2, r1
 801971c: fa03 f309    	lsl.w	r3, r3, r9
 8019720: ea27 0703    	bic.w	r7, r7, r3
 8019724: ea28 0802    	bic.w	r8, r8, r2
 8019728: ea57 0708    	orrs.w	r7, r7, r8
 801972c: bf0c         	ite	eq
 801972e: 2701         	moveq	r7, #0x1
 8019730: 2700         	movne	r7, #0x0
 8019732: e76b         	b	0x801960c <__dtoa_engine+0x1a0> @ imm = #-0x12a
 8019734: fb00 fc02    	mul	r12, r0, r2
 8019738: fba1 1200    	umull	r1, r2, r1, r0
 801973c: 3301         	adds	r3, #0x1
 801973e: 4462         	add	r2, r12
 8019740: 428c         	cmp	r4, r1
 8019742: eb75 0c02    	sbcs.w	r12, r5, r2
 8019746: d2f5         	bhs	0x8019734 <__dtoa_engine+0x2c8> @ imm = #-0x16
 8019748: 9a06         	ldr	r2, [sp, #0x18]
 801974a: 4413         	add	r3, r2
 801974c: 9a0c         	ldr	r2, [sp, #0x30]
 801974e: 4413         	add	r3, r2
 8019750: 0fd2         	lsrs	r2, r2, #0x1f
 8019752: 4293         	cmp	r3, r2
 8019754: bfb8         	it	lt
 8019756: 4613         	movlt	r3, r2
 8019758: 9a0b         	ldr	r2, [sp, #0x2c]
 801975a: 429a         	cmp	r2, r3
 801975c: bfa8         	it	ge
 801975e: 461a         	movge	r2, r3
 8019760: 4693         	mov	r11, r2
 8019762: e76e         	b	0x8019642 <__dtoa_engine+0x1d6> @ imm = #-0x124
 8019764: 210a         	movs	r1, #0xa
 8019766: 2200         	movs	r2, #0x0
 8019768: 2301         	movs	r3, #0x1
 801976a: 4608         	mov	r0, r1
 801976c: e7e8         	b	0x8019740 <__dtoa_engine+0x2d4> @ imm = #-0x30
 801976e: fb0a f003    	mul	r0, r10, r3
 8019772: fba2 230a    	umull	r2, r3, r2, r10
 8019776: 3101         	adds	r1, #0x1
 8019778: 4403         	add	r3, r0
 801977a: 4294         	cmp	r4, r2
 801977c: eb75 0003    	sbcs.w	r0, r5, r3
 8019780: d2f5         	bhs	0x801976e <__dtoa_engine+0x302> @ imm = #-0x16
 8019782: 4559         	cmp	r1, r11
 8019784: dd10         	ble	0x80197a8 <__dtoa_engine+0x33c> @ imm = #0x20
 8019786: f1bb 0f00    	cmp.w	r11, #0x0
 801978a: d102         	bne	0x8019792 <__dtoa_engine+0x326> @ imm = #0x4
 801978c: ea54 0305    	orrs.w	r3, r4, r5
 8019790: d00a         	beq	0x80197a8 <__dtoa_engine+0x33c> @ imm = #0x14
 8019792: 2301         	movs	r3, #0x1
 8019794: 9305         	str	r3, [sp, #0x14]
 8019796: e771         	b	0x801967c <__dtoa_engine+0x210> @ imm = #-0x11e
 8019798: 220a         	movs	r2, #0xa
 801979a: 2300         	movs	r3, #0x0
 801979c: 2101         	movs	r1, #0x1
 801979e: e7ec         	b	0x801977a <__dtoa_engine+0x30e> @ imm = #-0x28

080197a0 <$d>:
 80197a0: cc fb ff ff  	.word	0xfffffbcc
 80197a4: cd cc cc cc  	.word	0xcccccccd

080197a8 <$t>:
 80197a8: b37e         	cbz	r6, 0x801980a <__dtoa_engine+0x39e> @ imm = #0x5e
 80197aa: f04f 0a0a    	mov.w	r10, #0xa
 80197ae: 9b14         	ldr	r3, [sp, #0x50]
 80197b0: 9915         	ldr	r1, [sp, #0x54]
 80197b2: 930f         	str	r3, [sp, #0x3c]
 80197b4: 4618         	mov	r0, r3
 80197b6: f7ff fe45    	bl	0x8019444 <div10>       @ imm = #-0x376
 80197ba: 9b0f         	ldr	r3, [sp, #0x3c]
 80197bc: 910e         	str	r1, [sp, #0x38]
 80197be: fb0a f200    	mul	r2, r10, r0
 80197c2: 429a         	cmp	r2, r3
 80197c4: 4681         	mov	r9, r0
 80197c6: d120         	bne	0x801980a <__dtoa_engine+0x39e> @ imm = #0x40
 80197c8: e9dd 0112    	ldrd	r0, r1, [sp, #72]
 80197cc: f7ff fe3a    	bl	0x8019444 <div10>       @ imm = #-0x38c
 80197d0: 9010         	str	r0, [sp, #0x40]
 80197d2: 910f         	str	r1, [sp, #0x3c]
 80197d4: 4620         	mov	r0, r4
 80197d6: 4629         	mov	r1, r5
 80197d8: f7ff fe34    	bl	0x8019444 <div10>       @ imm = #-0x398
 80197dc: 9b0f         	ldr	r3, [sp, #0x3c]
 80197de: 9a10         	ldr	r2, [sp, #0x40]
 80197e0: 9212         	str	r2, [sp, #0x48]
 80197e2: e9cd 3913    	strd	r3, r9, [sp, #76]
 80197e6: 9b0e         	ldr	r3, [sp, #0x38]
 80197e8: 9315         	str	r3, [sp, #0x54]
 80197ea: 9b08         	ldr	r3, [sp, #0x20]
 80197ec: f1b8 0f00    	cmp.w	r8, #0x0
 80197f0: bf14         	ite	ne
 80197f2: 2700         	movne	r7, #0x0
 80197f4: f007 0701    	andeq	r7, r7, #0x1
 80197f8: 3301         	adds	r3, #0x1
 80197fa: fb0a 4810    	mls	r8, r10, r0, r4
 80197fe: fa5f f888    	uxtb.w	r8, r8
 8019802: 9308         	str	r3, [sp, #0x20]
 8019804: 4604         	mov	r4, r0
 8019806: 460d         	mov	r5, r1
 8019808: e7d1         	b	0x80197ae <__dtoa_engine+0x342> @ imm = #-0x5e
 801980a: 9b06         	ldr	r3, [sp, #0x18]
 801980c: 9a08         	ldr	r2, [sp, #0x20]
 801980e: 4413         	add	r3, r2
 8019810: 4699         	mov	r9, r3
 8019812: 2f00         	cmp	r7, #0x0
 8019814: d05a         	beq	0x80198cc <__dtoa_engine+0x460> @ imm = #0xb4
 8019816: f1b8 0f05    	cmp.w	r8, #0x5
 801981a: d157         	bne	0x80198cc <__dtoa_engine+0x460> @ imm = #0xae
 801981c: f014 0301    	ands	r3, r4, #0x1
 8019820: d14a         	bne	0x80198b8 <__dtoa_engine+0x44c> @ imm = #0x94
 8019822: 9a05         	ldr	r2, [sp, #0x14]
 8019824: b932         	cbnz	r2, 0x8019834 <__dtoa_engine+0x3c8> @ imm = #0xc
 8019826: e9dd 2314    	ldrd	r2, r3, [sp, #80]
 801982a: 429d         	cmp	r5, r3
 801982c: bf08         	it	eq
 801982e: 4294         	cmpeq	r4, r2
 8019830: d05f         	beq	0x80198f2 <__dtoa_engine+0x486> @ imm = #0xbe
 8019832: 9b05         	ldr	r3, [sp, #0x14]
 8019834: 1918         	adds	r0, r3, r4
 8019836: f04f 040a    	mov.w	r4, #0xa
 801983a: f145 0100    	adc	r1, r5, #0x0
 801983e: 2200         	movs	r2, #0x0
 8019840: 2601         	movs	r6, #0x1
 8019842: 4625         	mov	r5, r4
 8019844: 42a0         	cmp	r0, r4
 8019846: eb71 0702    	sbcs.w	r7, r1, r2
 801984a: d255         	bhs	0x80198f8 <__dtoa_engine+0x48c> @ imm = #0xaa
 801984c: b1f3         	cbz	r3, 0x801988c <__dtoa_engine+0x420> @ imm = #0x3c
 801984e: 45b3         	cmp	r11, r6
 8019850: da1c         	bge	0x801988c <__dtoa_engine+0x420> @ imm = #0x38
 8019852: 9b0d         	ldr	r3, [sp, #0x34]
 8019854: b173         	cbz	r3, 0x8019874 <__dtoa_engine+0x408> @ imm = #0x1c
 8019856: 9a0c         	ldr	r2, [sp, #0x30]
 8019858: eb06 0309    	add.w	r3, r6, r9
 801985c: 441a         	add	r2, r3
 801985e: 4613         	mov	r3, r2
 8019860: 2a01         	cmp	r2, #0x1
 8019862: 9a0b         	ldr	r2, [sp, #0x2c]
 8019864: bfb8         	it	lt
 8019866: 2301         	movlt	r3, #0x1
 8019868: 429a         	cmp	r2, r3
 801986a: bfa8         	it	ge
 801986c: 461a         	movge	r2, r3
 801986e: 4296         	cmp	r6, r2
 8019870: 4693         	mov	r11, r2
 8019872: dd0b         	ble	0x801988c <__dtoa_engine+0x420> @ imm = #0x16
 8019874: 3005         	adds	r0, #0x5
 8019876: f04f 020a    	mov.w	r2, #0xa
 801987a: f04f 0300    	mov.w	r3, #0x0
 801987e: f141 0100    	adc	r1, r1, #0x0
 8019882: f7e6 fd75    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x19516
 8019886: f109 0901    	add.w	r9, r9, #0x1
 801988a: 3e01         	subs	r6, #0x1
 801988c: 455e         	cmp	r6, r11
 801988e: bfa8         	it	ge
 8019890: 465e         	movge	r6, r11
 8019892: b237         	sxth	r7, r6
 8019894: fa0f f989    	sxth.w	r9, r9
 8019898: 9b07         	ldr	r3, [sp, #0x1c]
 801989a: fa09 f686    	sxtah	r6, r9, r6
 801989e: f107 0805    	add.w	r8, r7, #0x5
 80198a2: 3e01         	subs	r6, #0x1
 80198a4: 4498         	add	r8, r3
 80198a6: f04f 0900    	mov.w	r9, #0x0
 80198aa: 45b9         	cmp	r9, r7
 80198ac: db2b         	blt	0x8019906 <__dtoa_engine+0x49a> @ imm = #0x56
 80198ae: 9b07         	ldr	r3, [sp, #0x1c]
 80198b0: 9a0a         	ldr	r2, [sp, #0x28]
 80198b2: 601e         	str	r6, [r3]
 80198b4: 711a         	strb	r2, [r3, #0x4]
 80198b6: e5f8         	b	0x80194aa <__dtoa_engine+0x3e> @ imm = #-0x410
 80198b8: 9b05         	ldr	r3, [sp, #0x14]
 80198ba: b92b         	cbnz	r3, 0x80198c8 <__dtoa_engine+0x45c> @ imm = #0xa
 80198bc: e9dd 2314    	ldrd	r2, r3, [sp, #80]
 80198c0: 429d         	cmp	r5, r3
 80198c2: bf08         	it	eq
 80198c4: 4294         	cmpeq	r4, r2
 80198c6: d009         	beq	0x80198dc <__dtoa_engine+0x470> @ imm = #0x12
 80198c8: 2301         	movs	r3, #0x1
 80198ca: e7b3         	b	0x8019834 <__dtoa_engine+0x3c8> @ imm = #-0x9a
 80198cc: 9b05         	ldr	r3, [sp, #0x14]
 80198ce: b953         	cbnz	r3, 0x80198e6 <__dtoa_engine+0x47a> @ imm = #0x14
 80198d0: e9dd 2314    	ldrd	r2, r3, [sp, #80]
 80198d4: 429d         	cmp	r5, r3
 80198d6: bf08         	it	eq
 80198d8: 4294         	cmpeq	r4, r2
 80198da: d104         	bne	0x80198e6 <__dtoa_engine+0x47a> @ imm = #0x8
 80198dc: 9b09         	ldr	r3, [sp, #0x24]
 80198de: 2b00         	cmp	r3, #0x0
 80198e0: d1f2         	bne	0x80198c8 <__dtoa_engine+0x45c> @ imm = #-0x1c
 80198e2: 2e00         	cmp	r6, #0x0
 80198e4: d0f0         	beq	0x80198c8 <__dtoa_engine+0x45c> @ imm = #-0x20
 80198e6: f1b8 0f04    	cmp.w	r8, #0x4
 80198ea: bf94         	ite	ls
 80198ec: 2300         	movls	r3, #0x0
 80198ee: 2301         	movhi	r3, #0x1
 80198f0: e7a0         	b	0x8019834 <__dtoa_engine+0x3c8> @ imm = #-0xc0
 80198f2: f04f 0804    	mov.w	r8, #0x4
 80198f6: e7f1         	b	0x80198dc <__dtoa_engine+0x470> @ imm = #-0x1e
 80198f8: fb05 f702    	mul	r7, r5, r2
 80198fc: fba4 4205    	umull	r4, r2, r4, r5
 8019900: 3601         	adds	r6, #0x1
 8019902: 443a         	add	r2, r7
 8019904: e79e         	b	0x8019844 <__dtoa_engine+0x3d8> @ imm = #-0xc4
 8019906: 220a         	movs	r2, #0xa
 8019908: 2300         	movs	r3, #0x0
 801990a: f7e6 fd31    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x1959e
 801990e: 3230         	adds	r2, #0x30
 8019910: f808 2d01    	strb	r2, [r8, #-1]!
 8019914: f109 0901    	add.w	r9, r9, #0x1
 8019918: e7c7         	b	0x80198aa <__dtoa_engine+0x43e> @ imm = #-0x72
 801991a: bf00         	nop

0801991c <__log10Pow2>:
 801991c: 4b01         	ldr	r3, [pc, #0x4]          @ 0x8019924 <__log10Pow2+0x8>
 801991e: 4358         	muls	r0, r3, r0
 8019920: 0c80         	lsrs	r0, r0, #0x12
 8019922: 4770         	bx	lr

08019924 <$d>:
 8019924: 41 34 01 00  	.word	0x00013441

08019928 <__log10Pow5>:
 8019928: 4b01         	ldr	r3, [pc, #0x4]          @ 0x8019930 <__log10Pow5+0x8>
 801992a: 4358         	muls	r0, r3, r0
 801992c: 0d00         	lsrs	r0, r0, #0x14
 801992e: 4770         	bx	lr

08019930 <$d>:
 8019930: fb 2e 0b 00  	.word	0x000b2efb

08019934 <__pow5bits>:
 8019934: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8019940 <__pow5bits+0xc>
 8019936: 4358         	muls	r0, r3, r0
 8019938: 0cc0         	lsrs	r0, r0, #0x13
 801993a: 3001         	adds	r0, #0x1
 801993c: 4770         	bx	lr
 801993e: bf00         	nop

08019940 <$d>:
 8019940: 4f 93 12 00  	.word	0x0012934f

08019944 <__pow5Factor>:
 8019944: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8019970 <__pow5Factor+0x2c>
 8019946: b570         	push	{r4, r5, r6, lr}
 8019948: 4603         	mov	r3, r0
 801994a: f04f 36cc    	mov.w	r6, #0xcccccccc
 801994e: 2000         	movs	r0, #0x0
 8019950: f04f 3533    	mov.w	r5, #0x33333333
 8019954: fb06 f403    	mul	r4, r6, r3
 8019958: fb02 4401    	mla	r4, r2, r1, r4
 801995c: fba3 3102    	umull	r3, r1, r3, r2
 8019960: 4421         	add	r1, r4
 8019962: 429d         	cmp	r5, r3
 8019964: eb75 0401    	sbcs.w	r4, r5, r1
 8019968: d301         	blo	0x801996e <__pow5Factor+0x2a> @ imm = #0x2
 801996a: 3001         	adds	r0, #0x1
 801996c: e7f2         	b	0x8019954 <__pow5Factor+0x10> @ imm = #-0x1c
 801996e: bd70         	pop	{r4, r5, r6, pc}

08019970 <$d>:
 8019970: cd cc cc cc  	.word	0xcccccccd

08019974 <__double_computePow5>:
 8019974: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8019978: 231a         	movs	r3, #0x1a
 801997a: 4e35         	ldr	r6, [pc, #0xd4]         @ 0x8019a50 <__double_computePow5+0xdc>
 801997c: fbb0 faf3    	udiv	r10, r0, r3
 8019980: fb03 031a    	mls	r3, r3, r10, r0
 8019984: b089         	sub	sp, #0x24
 8019986: 4604         	mov	r4, r0
 8019988: 460d         	mov	r5, r1
 801998a: eb06 160a    	add.w	r6, r6, r10, lsl #4
 801998e: b953         	cbnz	r3, 0x80199a6 <__double_computePow5+0x32> @ imm = #0x14
 8019990: e9d6 2300    	ldrd	r2, r3, [r6]
 8019994: e9c1 2300    	strd	r2, r3, [r1]
 8019998: e9d6 0102    	ldrd	r0, r1, [r6, #8]
 801999c: e9c5 0102    	strd	r0, r1, [r5, #8]
 80199a0: b009         	add	sp, #0x24
 80199a2: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80199a6: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x8019a54 <__double_computePow5+0xe0>
 80199a8: eb02 03c3    	add.w	r3, r2, r3, lsl #3
 80199ac: e9d3 8900    	ldrd	r8, r9, [r3]
 80199b0: ab04         	add	r3, sp, #0x10
 80199b2: 9300         	str	r3, [sp]
 80199b4: e9d6 2302    	ldrd	r2, r3, [r6, #8]
 80199b8: 4640         	mov	r0, r8
 80199ba: 4649         	mov	r1, r9
 80199bc: f00f fcb1    	bl	0x8029322 <__umul128>   @ imm = #0xf962
 80199c0: ab06         	add	r3, sp, #0x18
 80199c2: 9300         	str	r3, [sp]
 80199c4: e9d6 2300    	ldrd	r2, r3, [r6]
 80199c8: 4683         	mov	r11, r0
 80199ca: 460f         	mov	r7, r1
 80199cc: 4640         	mov	r0, r8
 80199ce: 4649         	mov	r1, r9
 80199d0: f00f fca7    	bl	0x8029322 <__umul128>   @ imm = #0xf94e
 80199d4: e9dd 6206    	ldrd	r6, r2, [sp, #24]
 80199d8: eb16 060b    	adds.w	r6, r6, r11
 80199dc: eb52 0807    	adcs.w	r8, r2, r7
 80199e0: f04f 0300    	mov.w	r3, #0x0
 80199e4: bf28         	it	hs
 80199e6: 2301         	movhs	r3, #0x1
 80199e8: 4681         	mov	r9, r0
 80199ea: b133         	cbz	r3, 0x80199fa <__double_computePow5+0x86> @ imm = #0xc
 80199ec: 9b04         	ldr	r3, [sp, #0x10]
 80199ee: 9a05         	ldr	r2, [sp, #0x14]
 80199f0: 3301         	adds	r3, #0x1
 80199f2: f142 0200    	adc	r2, r2, #0x0
 80199f6: e9cd 3204    	strd	r3, r2, [sp, #16]
 80199fa: 4620         	mov	r0, r4
 80199fc: 9103         	str	r1, [sp, #0xc]
 80199fe: f7ff ff99    	bl	0x8019934 <__pow5bits>  @ imm = #-0xce
 8019a02: 4607         	mov	r7, r0
 8019a04: 201a         	movs	r0, #0x1a
 8019a06: fb00 f00a    	mul	r0, r0, r10
 8019a0a: f7ff ff93    	bl	0x8019934 <__pow5bits>  @ imm = #-0xda
 8019a0e: 1a3f         	subs	r7, r7, r0
 8019a10: 4632         	mov	r2, r6
 8019a12: 4643         	mov	r3, r8
 8019a14: 9903         	ldr	r1, [sp, #0xc]
 8019a16: 9700         	str	r7, [sp]
 8019a18: 4648         	mov	r0, r9
 8019a1a: f00f fc9d    	bl	0x8029358 <__shiftright128> @ imm = #0xf93a
 8019a1e: ea4f 1c14    	lsr.w	r12, r4, #0x4
 8019a22: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8019a58 <__double_computePow5+0xe4>
 8019a24: 0064         	lsls	r4, r4, #0x1
 8019a26: f004 031e    	and	r3, r4, #0x1e
 8019a2a: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 8019a2e: 40dc         	lsrs	r4, r3
 8019a30: f004 0403    	and	r4, r4, #0x3
 8019a34: 1824         	adds	r4, r4, r0
 8019a36: f141 0100    	adc	r1, r1, #0x0
 8019a3a: e9c5 4100    	strd	r4, r1, [r5]
 8019a3e: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 8019a42: 9700         	str	r7, [sp]
 8019a44: 4630         	mov	r0, r6
 8019a46: 4641         	mov	r1, r8
 8019a48: f00f fc86    	bl	0x8029358 <__shiftright128> @ imm = #0xf90c
 8019a4c: e7a6         	b	0x801999c <__double_computePow5+0x28> @ imm = #-0xb4
 8019a4e: bf00         	nop

08019a50 <$d>:
 8019a50: 48 cb 02 08  	.word	0x0802cb48
 8019a54: 78 ca 02 08  	.word	0x0802ca78
 8019a58: 58 e6 02 08  	.word	0x0802e658

08019a5c <__double_computeInvPow5>:
 8019a5c: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8019a60: 271a         	movs	r7, #0x1a
 8019a62: f8df a0ec    	ldr.w	r10, [pc, #0xec]        @ 0x8019b50 <__double_computeInvPow5+0xf4>
 8019a66: f100 0519    	add.w	r5, r0, #0x19
 8019a6a: fbb5 f5f7    	udiv	r5, r5, r7
 8019a6e: 436f         	muls	r7, r5, r7
 8019a70: 1a3a         	subs	r2, r7, r0
 8019a72: ea4f 1b05    	lsl.w	r11, r5, #0x4
 8019a76: b089         	sub	sp, #0x24
 8019a78: 4604         	mov	r4, r0
 8019a7a: 460e         	mov	r6, r1
 8019a7c: eb0a 1505    	add.w	r5, r10, r5, lsl #4
 8019a80: d10a         	bne	0x8019a98 <__double_computeInvPow5+0x3c> @ imm = #0x14
 8019a82: e9d5 2300    	ldrd	r2, r3, [r5]
 8019a86: e9c1 2300    	strd	r2, r3, [r1]
 8019a8a: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 8019a8e: e9c6 0102    	strd	r0, r1, [r6, #8]
 8019a92: b009         	add	sp, #0x24
 8019a94: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8019a98: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8019b48 <__double_computeInvPow5+0xec>
 8019a9a: eb03 03c2    	add.w	r3, r3, r2, lsl #3
 8019a9e: e9d3 8900    	ldrd	r8, r9, [r3]
 8019aa2: ab04         	add	r3, sp, #0x10
 8019aa4: 9300         	str	r3, [sp]
 8019aa6: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 8019aaa: 4640         	mov	r0, r8
 8019aac: 4649         	mov	r1, r9
 8019aae: f00f fc38    	bl	0x8029322 <__umul128>   @ imm = #0xf870
 8019ab2: f85a 200b    	ldr.w	r2, [r10, r11]
 8019ab6: 686b         	ldr	r3, [r5, #0x4]
 8019ab8: 3a01         	subs	r2, #0x1
 8019aba: e9cd 0102    	strd	r0, r1, [sp, #8]
 8019abe: a906         	add	r1, sp, #0x18
 8019ac0: f163 0300    	sbc	r3, r3, #0x0
 8019ac4: 9100         	str	r1, [sp]
 8019ac6: 4640         	mov	r0, r8
 8019ac8: 4649         	mov	r1, r9
 8019aca: f00f fc2a    	bl	0x8029322 <__umul128>   @ imm = #0xf854
 8019ace: e9dd 5206    	ldrd	r5, r2, [sp, #24]
 8019ad2: 468a         	mov	r10, r1
 8019ad4: 9902         	ldr	r1, [sp, #0x8]
 8019ad6: 186d         	adds	r5, r5, r1
 8019ad8: 9903         	ldr	r1, [sp, #0xc]
 8019ada: eb52 0801    	adcs.w	r8, r2, r1
 8019ade: f04f 0300    	mov.w	r3, #0x0
 8019ae2: bf28         	it	hs
 8019ae4: 2301         	movhs	r3, #0x1
 8019ae6: 4681         	mov	r9, r0
 8019ae8: b133         	cbz	r3, 0x8019af8 <__double_computeInvPow5+0x9c> @ imm = #0xc
 8019aea: 9b04         	ldr	r3, [sp, #0x10]
 8019aec: 9a05         	ldr	r2, [sp, #0x14]
 8019aee: 3301         	adds	r3, #0x1
 8019af0: f142 0200    	adc	r2, r2, #0x0
 8019af4: e9cd 3204    	strd	r3, r2, [sp, #16]
 8019af8: 4638         	mov	r0, r7
 8019afa: f7ff ff1b    	bl	0x8019934 <__pow5bits>  @ imm = #-0x1ca
 8019afe: 4607         	mov	r7, r0
 8019b00: 4620         	mov	r0, r4
 8019b02: f7ff ff17    	bl	0x8019934 <__pow5bits>  @ imm = #-0x1d2
 8019b06: 1a3f         	subs	r7, r7, r0
 8019b08: 462a         	mov	r2, r5
 8019b0a: 4643         	mov	r3, r8
 8019b0c: 9700         	str	r7, [sp]
 8019b0e: 4648         	mov	r0, r9
 8019b10: 4651         	mov	r1, r10
 8019b12: f00f fc21    	bl	0x8029358 <__shiftright128> @ imm = #0xf842
 8019b16: ea4f 1c14    	lsr.w	r12, r4, #0x4
 8019b1a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8019b4c <__double_computeInvPow5+0xf0>
 8019b1c: 0064         	lsls	r4, r4, #0x1
 8019b1e: f004 031e    	and	r3, r4, #0x1e
 8019b22: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 8019b26: 40dc         	lsrs	r4, r3
 8019b28: f004 0403    	and	r4, r4, #0x3
 8019b2c: 3401         	adds	r4, #0x1
 8019b2e: 1824         	adds	r4, r4, r0
 8019b30: f141 0100    	adc	r1, r1, #0x0
 8019b34: e9c6 4100    	strd	r4, r1, [r6]
 8019b38: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 8019b3c: 9700         	str	r7, [sp]
 8019b3e: 4628         	mov	r0, r5
 8019b40: 4641         	mov	r1, r8
 8019b42: f00f fc09    	bl	0x8029358 <__shiftright128> @ imm = #0xf812
 8019b46: e7a2         	b	0x8019a8e <__double_computeInvPow5+0x32> @ imm = #-0xbc

08019b48 <$d>:
 8019b48: 78 ca 02 08  	.word	0x0802ca78
 8019b4c: ac e6 02 08  	.word	0x0802e6ac
 8019b50: 18 cc 02 08  	.word	0x0802cc18

08019b54 <acosf>:
 8019b54: ee10 3a10    	<unknown>
 8019b58: f023 4200    	bic	r2, r3, #0x80000000
 8019b5c: f1b2 5f7e    	cmp.w	r2, #0x3f800000
 8019b60: eef0 7a40    	<unknown>
 8019b64: d109         	bne	0x8019b7a <acosf+0x26>  @ imm = #0x12
 8019b66: 2b00         	cmp	r3, #0x0
 8019b68: f300 80c0    	bgt.w	0x8019cec <acosf+0x198> @ imm = #0x180
 8019b6c: eddf 7a61    	<unknown>
 8019b70: ed9f 0a61    	<unknown>
 8019b74: ee30 0a27    	<unknown>
 8019b78: 4770         	bx	lr
 8019b7a: d901         	bls	0x8019b80 <acosf+0x2c>  @ imm = #0x2
 8019b7c: f000 bd0e    	b.w	0x801a59c <__math_invalidf> @ imm = #0xa1c
 8019b80: f1b2 5f7c    	cmp.w	r2, #0x3f000000
 8019b84: d23e         	bhs	0x8019c04 <acosf+0xb0>  @ imm = #0x7c
 8019b86: f1b2 5f0c    	cmp.w	r2, #0x23000000
 8019b8a: ed9f 0a5c    	<unknown>
 8019b8e: eddf 6a5c    	<unknown>
 8019b92: d802         	bhi	0x8019b9a <acosf+0x46>  @ imm = #0x4
 8019b94: ee30 0a26    	<unknown>
 8019b98: 4770         	bx	lr
 8019b9a: ee27 7aa7    	<unknown>
 8019b9e: eddf 5a59    	<unknown>
 8019ba2: ed9f 6a59    	<unknown>
 8019ba6: ed9f 5a59    	<unknown>
 8019baa: ee07 6a25    	<unknown>
 8019bae: eddf 5a58    	<unknown>
 8019bb2: ee56 5a07    	<unknown>
 8019bb6: ed9f 6a57    	<unknown>
 8019bba: ee05 6a87    	<unknown>
 8019bbe: eddf 5a56    	<unknown>
 8019bc2: ee56 5a07    	<unknown>
 8019bc6: ed9f 6a55    	<unknown>
 8019bca: ee05 6a87    	<unknown>
 8019bce: eddf 5a54    	<unknown>
 8019bd2: ee17 5a25    	<unknown>
 8019bd6: eddf 5a53    	<unknown>
 8019bda: ee45 5a07    	<unknown>
 8019bde: ed9f 5a52    	<unknown>
 8019be2: ee15 5a87    	<unknown>
 8019be6: eef7 5a00    	<unknown>
 8019bea: ee45 5a07    	<unknown>
 8019bee: ee26 6a07    	<unknown>
 8019bf2: ee86 7a25    	<unknown>
 8019bf6: ee47 6a67    	<unknown>
 8019bfa: ee77 6ae6    	<unknown>
 8019bfe: ee30 0a66    	<unknown>
 8019c02: 4770         	bx	lr
 8019c04: 2b00         	cmp	r3, #0x0
 8019c06: ed9f 1a3f    	<unknown>
 8019c0a: eddf 2a3f    	<unknown>
 8019c0e: ed9f 3a40    	<unknown>
 8019c12: eddf 3a40    	<unknown>
 8019c16: ed9f 4a40    	<unknown>
 8019c1a: ed9f 7a40    	<unknown>
 8019c1e: eddf 1a40    	<unknown>
 8019c22: eddf 4a3a    	<unknown>
 8019c26: ed9f 5a3f    	<unknown>
 8019c2a: eddf 5a3f    	<unknown>
 8019c2e: eef7 6a00    	<unknown>
 8019c32: eeb6 6a00    	<unknown>
 8019c36: da28         	bge	0x8019c8a <acosf+0x136> @ imm = #0x50
 8019c38: ee30 0a26    	<unknown>
 8019c3c: ee20 0a06    	<unknown>
 8019c40: eeb1 6ac0    	<unknown>
 8019c44: ee40 2a01    	<unknown>
 8019c48: ee50 4a21    	<unknown>
 8019c4c: ee12 3a80    	<unknown>
 8019c50: ee04 5a80    	<unknown>
 8019c54: ee43 3a00    	<unknown>
 8019c58: ee55 5a00    	<unknown>
 8019c5c: ee13 4a80    	<unknown>
 8019c60: ee45 6a80    	<unknown>
 8019c64: ee04 7a00    	<unknown>
 8019c68: eddf 7a25    	<unknown>
 8019c6c: ee27 7a00    	<unknown>
 8019c70: ed9f 0a21    	<unknown>
 8019c74: eec7 5a26    	<unknown>
 8019c78: ee55 7a86    	<unknown>
 8019c7c: ee77 7a86    	<unknown>
 8019c80: ee77 7aa7    	<unknown>
 8019c84: ee30 0a67    	<unknown>
 8019c88: 4770         	bx	lr
 8019c8a: ee36 0ac0    	<unknown>
 8019c8e: ee20 0a06    	<unknown>
 8019c92: eeb1 2ac0    	<unknown>
 8019c96: ee40 2a01    	<unknown>
 8019c9a: ee50 4a21    	<unknown>
 8019c9e: ee12 3a80    	<unknown>
 8019ca2: ee04 5a80    	<unknown>
 8019ca6: ee43 3a00    	<unknown>
 8019caa: ee55 5a00    	<unknown>
 8019cae: ee13 4a80    	<unknown>
 8019cb2: ee12 3a10    	<unknown>
 8019cb6: ee04 7a00    	<unknown>
 8019cba: f423 637f    	bic	r3, r3, #0xff0
 8019cbe: f023 030f    	bic	r3, r3, #0xf
 8019cc2: ee06 3a10    	<unknown>
 8019cc6: ee45 6a80    	<unknown>
 8019cca: ee27 7a00    	<unknown>
 8019cce: ee06 0a46    	<unknown>
 8019cd2: eec7 5a26    	<unknown>
 8019cd6: ee36 7a02    	<unknown>
 8019cda: eec0 7a07    	<unknown>
 8019cde: ee45 7a82    	<unknown>
 8019ce2: ee37 0a86    	<unknown>
 8019ce6: ee30 0a00    	<unknown>
 8019cea: 4770         	bx	lr
 8019cec: ed9f 0a0f    	<unknown>
 8019cf0: 4770         	bx	lr
 8019cf2: bf00         	nop

08019cf4 <$d>:
 8019cf4: 68 21 22 34  	.word	0x34222168
 8019cf8: da 0f 49 40  	.word	0x40490fda
 8019cfc: da 0f c9 3f  	.word	0x3fc90fda
 8019d00: 68 21 a2 33  	.word	0x33a22168
 8019d04: 08 ef 11 38  	.word	0x3811ef08
 8019d08: 04 7f 4f 3a  	.word	0x3a4f7f04
 8019d0c: 61 33 30 3f  	.word	0x3f303361
 8019d10: 46 11 24 3d  	.word	0x3d241146
 8019d14: a8 0a 4e 3e  	.word	0x3e4e0aa8
 8019d18: 90 b0 a6 3e  	.word	0x3ea6b090
 8019d1c: ab aa 2a 3e  	.word	0x3e2aaaab
 8019d20: 2e c6 9d 3d  	.word	0x3d9dc62e
 8019d24: 2d 57 01 40  	.word	0x4001572d
 8019d28: 39 d1 19 40  	.word	0x4019d139
 8019d2c: 00 00 00 00  	.word	0x00000000

08019d30 <asinf>:
 8019d30: ee10 2a10    	<unknown>
 8019d34: f022 4300    	bic	r3, r2, #0x80000000
 8019d38: f1b3 5f7e    	cmp.w	r3, #0x3f800000
 8019d3c: eef0 7a40    	<unknown>
 8019d40: d10c         	bne	0x8019d5c <asinf+0x2c>  @ imm = #0x18
 8019d42: ed9f 7a5c    	<unknown>
 8019d46: eddf 6a5c    	<unknown>
 8019d4a: ee20 7a07    	<unknown>
 8019d4e: ee00 7a26    	<unknown>
 8019d52: eef0 7a47    	<unknown>
 8019d56: eeb0 0a67    	<unknown>
 8019d5a: 4770         	bx	lr
 8019d5c: d901         	bls	0x8019d62 <asinf+0x32>  @ imm = #0x2
 8019d5e: f000 bc1d    	b.w	0x801a59c <__math_invalidf> @ imm = #0x83a
 8019d62: f1b3 5f7c    	cmp.w	r3, #0x3f000000
 8019d66: eef7 6a00    	<unknown>
 8019d6a: d20b         	bhs	0x8019d84 <asinf+0x54>  @ imm = #0x16
 8019d6c: f1b3 5f48    	cmp.w	r3, #0x32000000
 8019d70: d250         	bhs	0x8019e14 <asinf+0xe4>  @ imm = #0xa0
 8019d72: ed9f 7a52    	<unknown>
 8019d76: ee30 7a07    	<unknown>
 8019d7a: eeb4 7ae6    	<unknown>
 8019d7e: eef1 fa10    	<unknown>
 8019d82: dce8         	bgt	0x8019d56 <asinf+0x26>  @ imm = #-0x30
 8019d84: eef0 7ae7    	<unknown>
 8019d88: ee76 7ae7    	<unknown>
 8019d8c: eeb6 7a00    	<unknown>
 8019d90: ee67 7a87    	<unknown>
 8019d94: ed9f 6a4a    	<unknown>
 8019d98: ed9f 7a4a    	<unknown>
 8019d9c: eddf 5a4a    	<unknown>
 8019da0: ee07 6a87    	<unknown>
 8019da4: ed9f 7a49    	<unknown>
 8019da8: ee16 7a27    	<unknown>
 8019dac: ed9f 6a48    	<unknown>
 8019db0: ee07 6a27    	<unknown>
 8019db4: ed9f 7a47    	<unknown>
 8019db8: ee16 7a27    	<unknown>
 8019dbc: ed9f 6a46    	<unknown>
 8019dc0: ee07 6a27    	<unknown>
 8019dc4: ed9f 7a45    	<unknown>
 8019dc8: ee17 7aa5    	<unknown>
 8019dcc: eddf 5a44    	<unknown>
 8019dd0: ee47 5a27    	<unknown>
 8019dd4: ed9f 7a43    	<unknown>
 8019dd8: ee15 7aa7    	<unknown>
 8019ddc: ee26 6a27    	<unknown>
 8019de0: ee47 6a27    	<unknown>
 8019de4: eeb1 7ae7    	<unknown>
 8019de8: 493f         	ldr	r1, [pc, #0xfc]         @ 0x8019ee8 <asinf+0x1b8>
 8019dea: 428b         	cmp	r3, r1
 8019dec: eec6 5a26    	<unknown>
 8019df0: d93f         	bls	0x8019e72 <asinf+0x142> @ imm = #0x7e
 8019df2: ee05 7a87    	<unknown>
 8019df6: eddf 7a3d    	<unknown>
 8019dfa: ee37 7a07    	<unknown>
 8019dfe: ee37 7a27    	<unknown>
 8019e02: eddf 7a2d    	<unknown>
 8019e06: ee77 7ac7    	<unknown>
 8019e0a: 2a00         	cmp	r2, #0x0
 8019e0c: bfd8         	it	le
 8019e0e: eef1 7a67    	<unknown>
 8019e12: e7a0         	ble	0x8019d56 <asinf+0x26>  @ imm = #-0xc0
 8019e14: ee20 7a00    	<unknown>
 8019e18: eddf 5a2a    	<unknown>
 8019e1c: ed9f 6a28    	<unknown>
 8019e20: ed9f 5a29    	<unknown>
 8019e24: ee07 6a25    	<unknown>
 8019e28: eddf 5a28    	<unknown>
 8019e2c: ee56 5a07    	<unknown>
 8019e30: ed9f 6a27    	<unknown>
 8019e34: ee05 6a87    	<unknown>
 8019e38: eddf 5a26    	<unknown>
 8019e3c: ee56 5a07    	<unknown>
 8019e40: ed9f 6a25    	<unknown>
 8019e44: ee05 6a87    	<unknown>
 8019e48: eddf 5a24    	<unknown>
 8019e4c: ee57 5a05    	<unknown>
 8019e50: ed9f 5a23    	<unknown>
 8019e54: ee05 5a87    	<unknown>
 8019e58: eddf 5a22    	<unknown>
 8019e5c: ee55 5a07    	<unknown>
 8019e60: ee26 6a07    	<unknown>
 8019e64: ee45 6a87    	<unknown>
 8019e68: ee86 7a26    	<unknown>
 8019e6c: ee47 7a00    	<unknown>
 8019e70: e771         	b	0x8019d56 <asinf+0x26>  @ imm = #-0x11e
 8019e72: ee17 3a10    	<unknown>
 8019e76: f423 637f    	bic	r3, r3, #0xff0
 8019e7a: f023 030f    	bic	r3, r3, #0xf
 8019e7e: ee06 3a90    	<unknown>
 8019e82: ee46 7ae6    	<unknown>
 8019e86: ee37 5a07    	<unknown>
 8019e8a: ee37 7a26    	<unknown>
 8019e8e: ee76 6aa6    	<unknown>
 8019e92: ee87 6a87    	<unknown>
 8019e96: ed9f 7a07    	<unknown>
 8019e9a: eddf 7a15    	<unknown>
 8019e9e: ee36 6a06    	<unknown>
 8019ea2: ee77 6ae6    	<unknown>
 8019ea6: ee37 7a46    	<unknown>
 8019eaa: ee15 7a25    	<unknown>
 8019eae: ee37 7a66    	<unknown>
 8019eb2: e7a8         	b	0x8019e06 <asinf+0xd6>  @ imm = #-0xb0

08019eb4 <$d>:
 8019eb4: 2e bd 3b b3  	.word	0xb33bbd2e
 8019eb8: db 0f c9 3f  	.word	0x3fc90fdb
 8019ebc: ca f2 49 71  	.word	0x7149f2ca
 8019ec0: 04 7f 4f 3a  	.word	0x3a4f7f04
 8019ec4: 08 ef 11 38  	.word	0x3811ef08
 8019ec8: 2e c6 9d 3d  	.word	0x3d9dc62e
 8019ecc: 46 11 24 3d  	.word	0x3d241146
 8019ed0: a8 0a 4e 3e  	.word	0x3e4e0aa8
 8019ed4: 90 b0 a6 3e  	.word	0x3ea6b090
 8019ed8: ab aa 2a 3e  	.word	0x3e2aaaab
 8019edc: 61 33 30 3f  	.word	0x3f303361
 8019ee0: 2d 57 01 40  	.word	0x4001572d
 8019ee4: 39 d1 19 40  	.word	0x4019d139
 8019ee8: 99 99 79 3f  	.word	0x3f799999
 8019eec: 2e bd 3b 33  	.word	0x333bbd2e
 8019ef0: db 0f 49 3f  	.word	0x3f490fdb

08019ef4 <atan2f>:
 8019ef4: ee10 2a90    	<unknown>
 8019ef8: f022 4100    	bic	r1, r2, #0x80000000
 8019efc: f1b1 4fff    	cmp.w	r1, #0x7f800000
 8019f00: b510         	push	{r4, lr}
 8019f02: eef0 7a40    	<unknown>
 8019f06: d806         	bhi	0x8019f16 <atan2f+0x22> @ imm = #0xc
 8019f08: ee10 0a10    	<unknown>
 8019f0c: f020 4300    	bic	r3, r0, #0x80000000
 8019f10: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8019f14: d904         	bls	0x8019f20 <atan2f+0x2c> @ imm = #0x8
 8019f16: ee77 7aa0    	<unknown>
 8019f1a: eeb0 0a67    	<unknown>
 8019f1e: bd10         	pop	{r4, pc}
 8019f20: f1b2 5f7e    	cmp.w	r2, #0x3f800000
 8019f24: d103         	bne	0x8019f2e <atan2f+0x3a> @ imm = #0x6
 8019f26: e8bd 4010    	pop.w	{r4, lr}
 8019f2a: f000 be69    	b.w	0x801ac00 <atanf>       @ imm = #0xcd2
 8019f2e: 1794         	asrs	r4, r2, #0x1e
 8019f30: f004 0402    	and	r4, r4, #0x2
 8019f34: ea44 74d0    	orr.w	r4, r4, r0, lsr #31
 8019f38: b98b         	cbnz	r3, 0x8019f5e <atan2f+0x6a> @ imm = #0x22
 8019f3a: 2c02         	cmp	r4, #0x2
 8019f3c: d008         	beq	0x8019f50 <atan2f+0x5c> @ imm = #0x10
 8019f3e: 2c03         	cmp	r4, #0x3
 8019f40: d1eb         	bne	0x8019f1a <atan2f+0x26> @ imm = #-0x2a
 8019f42: eddf 7a40    	<unknown>
 8019f46: ed9f 7a40    	<unknown>
 8019f4a: ee77 7ac7    	<unknown>
 8019f4e: e7e4         	b	0x8019f1a <atan2f+0x26> @ imm = #-0x38
 8019f50: eddf 7a3e    	<unknown>
 8019f54: ed9f 7a3c    	<unknown>
 8019f58: ee77 7a87    	<unknown>
 8019f5c: e7dd         	b	0x8019f1a <atan2f+0x26> @ imm = #-0x46
 8019f5e: b939         	cbnz	r1, 0x8019f70 <atan2f+0x7c> @ imm = #0xe
 8019f60: 2800         	cmp	r0, #0x0
 8019f62: da02         	bge	0x8019f6a <atan2f+0x76> @ imm = #0x4
 8019f64: eddf 7a3a    	<unknown>
 8019f68: e7ed         	b	0x8019f46 <atan2f+0x52> @ imm = #-0x26
 8019f6a: eddf 7a3a    	<unknown>
 8019f6e: e7f1         	b	0x8019f54 <atan2f+0x60> @ imm = #-0x1e
 8019f70: f1b1 4fff    	cmp.w	r1, #0x7f800000
 8019f74: d12c         	bne	0x8019fd0 <atan2f+0xdc> @ imm = #0x58
 8019f76: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8019f7a: d11d         	bne	0x8019fb8 <atan2f+0xc4> @ imm = #0x3a
 8019f7c: 2c02         	cmp	r4, #0x2
 8019f7e: eddf 7a32    	<unknown>
 8019f82: d00b         	beq	0x8019f9c <atan2f+0xa8> @ imm = #0x16
 8019f84: 2c03         	cmp	r4, #0x3
 8019f86: d010         	beq	0x8019faa <atan2f+0xb6> @ imm = #0x20
 8019f88: 2c01         	cmp	r4, #0x1
 8019f8a: d002         	beq	0x8019f92 <atan2f+0x9e> @ imm = #0x4
 8019f8c: ed9f 7a32    	<unknown>
 8019f90: e7e2         	b	0x8019f58 <atan2f+0x64> @ imm = #-0x3c
 8019f92: ed9f 7a32    	<unknown>
 8019f96: ee77 7a67    	<unknown>
 8019f9a: e7be         	b	0x8019f1a <atan2f+0x26> @ imm = #-0x84
 8019f9c: eddf 6a2e    	<unknown>
 8019fa0: eeb0 7a08    	<unknown>
 8019fa4: ee46 7a87    	<unknown>
 8019fa8: e7b7         	b	0x8019f1a <atan2f+0x26> @ imm = #-0x92
 8019faa: eddf 6a2b    	<unknown>
 8019fae: eeb8 7a08    	<unknown>
 8019fb2: ee56 7a87    	<unknown>
 8019fb6: e7b0         	b	0x8019f1a <atan2f+0x26> @ imm = #-0xa0
 8019fb8: 2c02         	cmp	r4, #0x2
 8019fba: d0c9         	beq	0x8019f50 <atan2f+0x5c> @ imm = #-0x6e
 8019fbc: 2c03         	cmp	r4, #0x3
 8019fbe: d0c0         	beq	0x8019f42 <atan2f+0x4e> @ imm = #-0x80
 8019fc0: eddf 7a27    	<unknown>
 8019fc4: ed9f 7a27    	<unknown>
 8019fc8: 2c01         	cmp	r4, #0x1
 8019fca: fe47 7a87    	<unknown>
 8019fce: e7a4         	b	0x8019f1a <atan2f+0x26> @ imm = #-0xb8
 8019fd0: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8019fd4: d0c4         	beq	0x8019f60 <atan2f+0x6c> @ imm = #-0x78
 8019fd6: 1a5b         	subs	r3, r3, r1
 8019fd8: f1b3 5ff4    	cmp.w	r3, #0x1e800000
 8019fdc: ea4f 51e3    	asr.w	r1, r3, #0x17
 8019fe0: db12         	blt	0x801a008 <atan2f+0x114> @ imm = #0x24
 8019fe2: eddf 7a1c    	<unknown>
 8019fe6: ed9f 7a20    	<unknown>
 8019fea: ee77 7ac7    	<unknown>
 8019fee: 2c01         	cmp	r4, #0x1
 8019ff0: d01a         	beq	0x801a028 <atan2f+0x134> @ imm = #0x34
 8019ff2: 2c02         	cmp	r4, #0x2
 8019ff4: d01f         	beq	0x801a036 <atan2f+0x142> @ imm = #0x3e
 8019ff6: 2c00         	cmp	r4, #0x0
 8019ff8: d08f         	beq	0x8019f1a <atan2f+0x26> @ imm = #-0xe2
 8019ffa: ed9f 7a1c    	<unknown>
 8019ffe: ee77 7a87    	<unknown>
 801a002: ed9f 7a12    	<unknown>
 801a006: e7a0         	b	0x8019f4a <atan2f+0x56> @ imm = #-0xc0
 801a008: 2a00         	cmp	r2, #0x0
 801a00a: da01         	bge	0x801a010 <atan2f+0x11c> @ imm = #0x2
 801a00c: 313c         	adds	r1, #0x3c
 801a00e: db08         	blt	0x801a022 <atan2f+0x12e> @ imm = #0x10
 801a010: ee87 0aa0    	<unknown>
 801a014: eeb0 0ac0    	<unknown>
 801a018: f000 fdf2    	bl	0x801ac00 <atanf>       @ imm = #0xbe4
 801a01c: eef0 7a40    	<unknown>
 801a020: e7e5         	b	0x8019fee <atan2f+0xfa> @ imm = #-0x36
 801a022: eddf 7a10    	<unknown>
 801a026: e7e2         	b	0x8019fee <atan2f+0xfa> @ imm = #-0x3c
 801a028: ee17 3a90    	<unknown>
 801a02c: f103 4300    	add.w	r3, r3, #0x80000000
 801a030: ee07 3a90    	<unknown>
 801a034: e771         	b	0x8019f1a <atan2f+0x26> @ imm = #-0x11e
 801a036: ed9f 7a0d    	<unknown>
 801a03a: ee77 7a87    	<unknown>
 801a03e: ed9f 7a03    	<unknown>
 801a042: e7a8         	b	0x8019f96 <atan2f+0xa2> @ imm = #-0xb0

0801a044 <$d>:
 801a044: db 0f 49 c0  	.word	0xc0490fdb
 801a048: 60 42 a2 0d  	.word	0x0da24260
 801a04c: db 0f 49 40  	.word	0x40490fdb
 801a050: db 0f c9 bf  	.word	0xbfc90fdb
 801a054: db 0f c9 3f  	.word	0x3fc90fdb
 801a058: db 0f 49 3f  	.word	0x3f490fdb
 801a05c: db 0f 49 bf  	.word	0xbf490fdb
 801a060: 00 00 00 80  	.word	0x80000000
 801a064: 00 00 00 00  	.word	0x00000000
 801a068: 2e bd 3b 33  	.word	0x333bbd2e
 801a06c: 2e bd bb 33  	.word	0x33bbbd2e

0801a070 <cosf>:
 801a070: ee10 3a10    	<unknown>
 801a074: b507         	push	{r0, r1, r2, lr}
 801a076: 4a1f         	ldr	r2, [pc, #0x7c]         @ 0x801a0f4 <cosf+0x84>
 801a078: f023 4300    	bic	r3, r3, #0x80000000
 801a07c: 4293         	cmp	r3, r2
 801a07e: d806         	bhi	0x801a08e <cosf+0x1e>   @ imm = #0xc
 801a080: eddf 0a1d    	<unknown>
 801a084: b003         	add	sp, #0xc
 801a086: f85d eb04    	ldr	lr, [sp], #4
 801a08a: f000 ba9b    	b.w	0x801a5c4 <__kernel_cosf> @ imm = #0x536
 801a08e: f1b3 4fff    	cmp.w	r3, #0x7f800000
 801a092: d304         	blo	0x801a09e <cosf+0x2e>   @ imm = #0x8
 801a094: b003         	add	sp, #0xc
 801a096: f85d eb04    	ldr	lr, [sp], #4
 801a09a: f000 ba7f    	b.w	0x801a59c <__math_invalidf> @ imm = #0x4fe
 801a09e: 4668         	mov	r0, sp
 801a0a0: f000 f8d0    	bl	0x801a244 <__rem_pio2f> @ imm = #0x1a0
 801a0a4: f000 0003    	and	r0, r0, #0x3
 801a0a8: 2801         	cmp	r0, #0x1
 801a0aa: d00b         	beq	0x801a0c4 <cosf+0x54>   @ imm = #0x16
 801a0ac: 2802         	cmp	r0, #0x2
 801a0ae: d012         	beq	0x801a0d6 <cosf+0x66>   @ imm = #0x24
 801a0b0: b9c0         	cbnz	r0, 0x801a0e4 <cosf+0x74> @ imm = #0x30
 801a0b2: eddd 0a01    	<unknown>
 801a0b6: ed9d 0a00    	<unknown>
 801a0ba: f000 fa83    	bl	0x801a5c4 <__kernel_cosf> @ imm = #0x506
 801a0be: b003         	add	sp, #0xc
 801a0c0: f85d fb04    	ldr	pc, [sp], #4
 801a0c4: eddd 0a01    	<unknown>
 801a0c8: ed9d 0a00    	<unknown>
 801a0cc: f000 fd50    	bl	0x801ab70 <__kernel_sinf> @ imm = #0xaa0
 801a0d0: eeb1 0a40    	<unknown>
 801a0d4: e7f3         	b	0x801a0be <cosf+0x4e>   @ imm = #-0x1a
 801a0d6: eddd 0a01    	<unknown>
 801a0da: ed9d 0a00    	<unknown>
 801a0de: f000 fa71    	bl	0x801a5c4 <__kernel_cosf> @ imm = #0x4e2
 801a0e2: e7f5         	b	0x801a0d0 <cosf+0x60>   @ imm = #-0x16
 801a0e4: eddd 0a01    	<unknown>
 801a0e8: ed9d 0a00    	<unknown>
 801a0ec: 2001         	movs	r0, #0x1
 801a0ee: f000 fd3f    	bl	0x801ab70 <__kernel_sinf> @ imm = #0xa7e
 801a0f2: e7e4         	b	0x801a0be <cosf+0x4e>   @ imm = #-0x38

0801a0f4 <$d>:
 801a0f4: d8 0f 49 3f  	.word	0x3f490fd8
 801a0f8: 00 00 00 00  	.word	0x00000000

0801a0fc <fmodf>:
 801a0fc: b5f8         	push	{r3, r4, r5, r6, r7, lr}
 801a0fe: ed2d 8b02    	<unknown>
 801a102: eeb0 8a40    	<unknown>
 801a106: eef0 8a60    	<unknown>
 801a10a: f000 fa0f    	bl	0x801a52c <__fpclassifyf> @ imm = #0x41e
 801a10e: b930         	cbnz	r0, 0x801a11e <fmodf+0x22> @ imm = #0xc
 801a110: ee38 8a28    	<unknown>
 801a114: eeb0 0a48    	<unknown>
 801a118: ecbd 8b02    	<unknown>
 801a11c: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
 801a11e: eeb0 0a68    	<unknown>
 801a122: f000 fa03    	bl	0x801a52c <__fpclassifyf> @ imm = #0x406
 801a126: 2800         	cmp	r0, #0x0
 801a128: d0f2         	beq	0x801a110 <fmodf+0x14>  @ imm = #-0x1c
 801a12a: eeb0 0a48    	<unknown>
 801a12e: f000 f9fd    	bl	0x801a52c <__fpclassifyf> @ imm = #0x3fa
 801a132: 2801         	cmp	r0, #0x1
 801a134: d107         	bne	0x801a146 <fmodf+0x4a>  @ imm = #0xe
 801a136: eeb0 0a48    	<unknown>
 801a13a: ecbd 8b02    	<unknown>
 801a13e: e8bd 40f8    	pop.w	{r3, r4, r5, r6, r7, lr}
 801a142: f000 ba2b    	b.w	0x801a59c <__math_invalidf> @ imm = #0x456
 801a146: ee18 4a90    	<unknown>
 801a14a: f034 4000    	bics	r0, r4, #0x80000000
 801a14e: d102         	bne	0x801a156 <fmodf+0x5a>  @ imm = #0x4
 801a150: eeb0 0a68    	<unknown>
 801a154: e7f1         	b	0x801a13a <fmodf+0x3e>  @ imm = #-0x1e
 801a156: ee18 3a10    	<unknown>
 801a15a: f023 4600    	bic	r6, r3, #0x80000000
 801a15e: 4286         	cmp	r6, r0
 801a160: dbd8         	blt	0x801a114 <fmodf+0x18>  @ imm = #-0x50
 801a162: f003 4500    	and	r5, r3, #0x80000000
 801a166: d105         	bne	0x801a174 <fmodf+0x78>  @ imm = #0xa
 801a168: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x801a240 <fmodf+0x144>
 801a16a: eb03 7355    	add.w	r3, r3, r5, lsr #29
 801a16e: ed93 8a00    	<unknown>
 801a172: e7cf         	b	0x801a114 <fmodf+0x18>  @ imm = #-0x62
 801a174: f013 4fff    	tst.w	r3, #0x7f800000
 801a178: d140         	bne	0x801a1fc <fmodf+0x100> @ imm = #0x80
 801a17a: 0232         	lsls	r2, r6, #0x8
 801a17c: f06f 017d    	mvn	r1, #0x7d
 801a180: 2a00         	cmp	r2, #0x0
 801a182: dc38         	bgt	0x801a1f6 <fmodf+0xfa>  @ imm = #0x70
 801a184: f014 4fff    	tst.w	r4, #0x7f800000
 801a188: d13e         	bne	0x801a208 <fmodf+0x10c> @ imm = #0x7c
 801a18a: 0207         	lsls	r7, r0, #0x8
 801a18c: f06f 027d    	mvn	r2, #0x7d
 801a190: 2f00         	cmp	r7, #0x0
 801a192: da36         	bge	0x801a202 <fmodf+0x106> @ imm = #0x6c
 801a194: f111 0f7e    	cmn.w	r1, #0x7e
 801a198: bfb9         	ittee	lt
 801a19a: f06f 037d    	mvnlt	r3, #0x7d
 801a19e: 1a5b         	sublt	r3, r3, r1
 801a1a0: f3c3 0316    	ubfxge	r3, r3, #0x0, #0x17
 801a1a4: f443 0300    	orrge	r3, r3, #0x800000
 801a1a8: bfb8         	it	lt
 801a1aa: fa06 f303    	lsllt.w	r3, r6, r3
 801a1ae: f112 0f7e    	cmn.w	r2, #0x7e
 801a1b2: bfb5         	itete	lt
 801a1b4: f06f 047d    	mvnlt	r4, #0x7d
 801a1b8: f3c4 0416    	ubfxge	r4, r4, #0x0, #0x17
 801a1bc: 1aa4         	sublt	r4, r4, r2
 801a1be: f444 0000    	orrge	r0, r4, #0x800000
 801a1c2: bfb8         	it	lt
 801a1c4: 40a0         	lsllt	r0, r4
 801a1c6: 1a89         	subs	r1, r1, r2
 801a1c8: 1a1c         	subs	r4, r3, r0
 801a1ca: bb01         	cbnz	r1, 0x801a20e <fmodf+0x112> @ imm = #0x40
 801a1cc: ea13 0324    	ands.w	r3, r3, r4, asr #32
 801a1d0: bf38         	it	lo
 801a1d2: 4623         	movlo	r3, r4
 801a1d4: 2b00         	cmp	r3, #0x0
 801a1d6: d0c7         	beq	0x801a168 <fmodf+0x6c>  @ imm = #-0x72
 801a1d8: f5b3 0f00    	cmp.w	r3, #0x800000
 801a1dc: db1f         	blt	0x801a21e <fmodf+0x122> @ imm = #0x3e
 801a1de: f112 0f7e    	cmn.w	r2, #0x7e
 801a1e2: db1f         	blt	0x801a224 <fmodf+0x128> @ imm = #0x3e
 801a1e4: f5a3 0300    	sub.w	r3, r3, #0x800000
 801a1e8: 432b         	orrs	r3, r5
 801a1ea: 327f         	adds	r2, #0x7f
 801a1ec: ea43 53c2    	orr.w	r3, r3, r2, lsl #23
 801a1f0: ee08 3a10    	<unknown>
 801a1f4: e78e         	b	0x801a114 <fmodf+0x18>  @ imm = #-0xe4
 801a1f6: 3901         	subs	r1, #0x1
 801a1f8: 0052         	lsls	r2, r2, #0x1
 801a1fa: e7c1         	b	0x801a180 <fmodf+0x84>  @ imm = #-0x7e
 801a1fc: 15f1         	asrs	r1, r6, #0x17
 801a1fe: 397f         	subs	r1, #0x7f
 801a200: e7c0         	b	0x801a184 <fmodf+0x88>  @ imm = #-0x80
 801a202: 3a01         	subs	r2, #0x1
 801a204: 007f         	lsls	r7, r7, #0x1
 801a206: e7c3         	b	0x801a190 <fmodf+0x94>  @ imm = #-0x7a
 801a208: 15c2         	asrs	r2, r0, #0x17
 801a20a: 3a7f         	subs	r2, #0x7f
 801a20c: e7c2         	b	0x801a194 <fmodf+0x98>  @ imm = #-0x7c
 801a20e: 2c00         	cmp	r4, #0x0
 801a210: da02         	bge	0x801a218 <fmodf+0x11c> @ imm = #0x4
 801a212: 005b         	lsls	r3, r3, #0x1
 801a214: 3901         	subs	r1, #0x1
 801a216: e7d7         	b	0x801a1c8 <fmodf+0xcc>  @ imm = #-0x52
 801a218: d0a6         	beq	0x801a168 <fmodf+0x6c>  @ imm = #-0xb4
 801a21a: 0063         	lsls	r3, r4, #0x1
 801a21c: e7fa         	b	0x801a214 <fmodf+0x118> @ imm = #-0xc
 801a21e: 005b         	lsls	r3, r3, #0x1
 801a220: 3a01         	subs	r2, #0x1
 801a222: e7d9         	b	0x801a1d8 <fmodf+0xdc>  @ imm = #-0x4e
 801a224: f1c2 22ff    	rsb.w	r2, r2, #0xff00ff00
 801a228: f502 027f    	add.w	r2, r2, #0xff0000
 801a22c: 3282         	adds	r2, #0x82
 801a22e: 4113         	asrs	r3, r2
 801a230: 432b         	orrs	r3, r5
 801a232: ee07 3a10    	<unknown>
 801a236: eef7 7a00    	<unknown>
 801a23a: ee27 8a27    	<unknown>
 801a23e: e769         	b	0x801a114 <fmodf+0x18>  @ imm = #-0x12e

0801a240 <$d>:
 801a240: 00 e7 02 08  	.word	0x0802e700

0801a244 <__rem_pio2f>:
 801a244: b5f0         	push	{r4, r5, r6, r7, lr}
 801a246: ee10 5a10    	<unknown>
 801a24a: 4a86         	ldr	r2, [pc, #0x218]        @ 0x801a464 <__rem_pio2f+0x220>
 801a24c: f025 4300    	bic	r3, r5, #0x80000000
 801a250: 4293         	cmp	r3, r2
 801a252: b087         	sub	sp, #0x1c
 801a254: 4604         	mov	r4, r0
 801a256: d805         	bhi	0x801a264 <__rem_pio2f+0x20> @ imm = #0xa
 801a258: 2300         	movs	r3, #0x0
 801a25a: ed80 0a00    	<unknown>
 801a25e: 6043         	str	r3, [r0, #0x4]
 801a260: 2000         	movs	r0, #0x0
 801a262: e022         	b	0x801a2aa <__rem_pio2f+0x66> @ imm = #0x44
 801a264: 4a80         	ldr	r2, [pc, #0x200]        @ 0x801a468 <__rem_pio2f+0x224>
 801a266: 4293         	cmp	r3, r2
 801a268: d83a         	bhi	0x801a2e0 <__rem_pio2f+0x9c> @ imm = #0x74
 801a26a: f025 4300    	bic	r3, r5, #0x80000000
 801a26e: 2d00         	cmp	r5, #0x0
 801a270: eddf 7a7e    	<unknown>
 801a274: 4a7e         	ldr	r2, [pc, #0x1f8]        @ 0x801a470 <__rem_pio2f+0x22c>
 801a276: f023 030f    	bic	r3, r3, #0xf
 801a27a: dd18         	ble	0x801a2ae <__rem_pio2f+0x6a> @ imm = #0x30
 801a27c: 4293         	cmp	r3, r2
 801a27e: ee30 0a67    	<unknown>
 801a282: bf09         	itett	eq
 801a284: eddf 7a7b    	<unknown>
 801a288: ed9f 7a7b    	<unknown>
 801a28c: ed9f 7a7b    	<unknown>
 801a290: ee30 0a67    	<unknown>
 801a294: ee70 7a47    	<unknown>
 801a298: ee30 0a67    	<unknown>
 801a29c: edc0 7a00    	<unknown>
 801a2a0: ee30 0a47    	<unknown>
 801a2a4: ed80 0a01    	<unknown>
 801a2a8: 2001         	moveq	r0, #0x1
 801a2aa: b007         	addne	sp, #0x1c
 801a2ac: bdf0         	popeq	{r4, r5, r6, r7, pc}
 801a2ae: 4293         	cmpeq	r3, r2
 801a2b0: ee30 0a27    	<unknown>
 801a2b4: bf09         	itett	eq
 801a2b6: eddf 7a6f    	<unknown>
 801a2ba: ed9f 7a6f    	<unknown>
 801a2be: ed9f 7a6f    	<unknown>
 801a2c2: ee30 0a27    	<unknown>
 801a2c6: ee70 7a07    	<unknown>
 801a2ca: ee30 0a67    	<unknown>
 801a2ce: edc0 7a00    	<unknown>
 801a2d2: ee30 0a07    	<unknown>
 801a2d6: ed80 0a01    	<unknown>
 801a2da: f04f 30ff    	moveq.w	r0, #0xffffffff
 801a2de: e7e4         	bne	0x801a2aa <__rem_pio2f+0x66> @ imm = #-0x38
 801a2e0: 4a67         	ldreq	r2, [pc, #0x19c]        @ 0x801a480 <__rem_pio2f+0x23c>
 801a2e2: 4293         	cmpeq	r3, r2
 801a2e4: d870         	bhi	0x801a3c8 <__rem_pio2f+0x184> @ imm = #0xe0
 801a2e6: eeb0 0ac0    	<unknown>
 801a2ea: ed9f 7a66    	<unknown>
 801a2ee: eef6 7a00    	<unknown>
 801a2f2: ee40 7a07    	<unknown>
 801a2f6: eefd 7ae7    	<unknown>
 801a2fa: eef8 6ae7    	<unknown>
 801a2fe: ee17 0a90    	<unknown>
 801a302: eddf 7a5a    	<unknown>
 801a306: ee06 0ae7    	<unknown>
 801a30a: 281f         	cmp	r0, #0x1f
 801a30c: eddf 7a5a    	<unknown>
 801a310: ee66 7aa7    	<unknown>
 801a314: ee30 7a67    	<unknown>
 801a318: ee17 6a10    	<unknown>
 801a31c: dc09         	bgt	0x801a332 <__rem_pio2f+0xee> @ imm = #0x12
 801a31e: 495a         	ldr	r1, [pc, #0x168]        @ 0x801a488 <__rem_pio2f+0x244>
 801a320: 1e47         	subs	r7, r0, #0x1
 801a322: f025 4200    	bic	r2, r5, #0x80000000
 801a326: f851 1027    	ldr.w	r1, [r1, r7, lsl #2]
 801a32a: f022 02ff    	bic	r2, r2, #0xff
 801a32e: 428a         	cmp	r2, r1
 801a330: d106         	bne	0x801a340 <__rem_pio2f+0xfc> @ imm = #0xc
 801a332: f3c6 51c7    	ubfx	r1, r6, #0x17, #0x8
 801a336: 15da         	asrs	r2, r3, #0x17
 801a338: ebc1 53d3    	rsb	r3, r1, r3, lsr #23
 801a33c: 2b08         	cmp	r3, #0x8
 801a33e: dc14         	bgt	0x801a36a <__rem_pio2f+0x126> @ imm = #0x28
 801a340: 6026         	str	r6, [r4]
 801a342: ed94 7a00    	<unknown>
 801a346: ee30 0a47    	<unknown>
 801a34a: 2d00         	cmp	r5, #0x0
 801a34c: ee30 0a67    	<unknown>
 801a350: ed84 0a01    	<unknown>
 801a354: daa9         	bge	0x801a2aa <__rem_pio2f+0x66> @ imm = #-0xae
 801a356: eeb1 7a47    	<unknown>
 801a35a: eeb1 0a40    	<unknown>
 801a35e: ed84 7a00    	<unknown>
 801a362: ed84 0a01    	<unknown>
 801a366: 4240         	rsbs	r0, r0, #0
 801a368: e79f         	b	0x801a2aa <__rem_pio2f+0x66> @ imm = #-0xc2
 801a36a: eddf 7a42    	<unknown>
 801a36e: ed9f 6a43    	<unknown>
 801a372: ee66 7aa7    	<unknown>
 801a376: ee30 7a67    	<unknown>
 801a37a: ee30 0a47    	<unknown>
 801a37e: ee70 7a67    	<unknown>
 801a382: ee56 7a86    	<unknown>
 801a386: ee37 6a67    	<unknown>
 801a38a: ee16 1a10    	<unknown>
 801a38e: f3c1 53c7    	ubfx	r3, r1, #0x17, #0x8
 801a392: 1ad3         	subs	r3, r2, r3
 801a394: 2b19         	cmp	r3, #0x19
 801a396: dc04         	bgt	0x801a3a2 <__rem_pio2f+0x15e> @ imm = #0x8
 801a398: ed84 6a00    	<unknown>
 801a39c: eeb0 0a47    	<unknown>
 801a3a0: e7cf         	b	0x801a342 <__rem_pio2f+0xfe> @ imm = #-0x62
 801a3a2: eddf 7a3a    	<unknown>
 801a3a6: ee66 7aa7    	<unknown>
 801a3aa: ee37 0a67    	<unknown>
 801a3ae: ee37 7a40    	<unknown>
 801a3b2: ee77 7a67    	<unknown>
 801a3b6: ed9f 7a36    	<unknown>
 801a3ba: ee56 7a87    	<unknown>
 801a3be: ee30 7a67    	<unknown>
 801a3c2: ed84 7a00    	<unknown>
 801a3c6: e7bc         	b	0x801a342 <__rem_pio2f+0xfe> @ imm = #-0x88
 801a3c8: f1b3 4fff    	cmp.w	r3, #0x7f800000
 801a3cc: d306         	blo	0x801a3dc <__rem_pio2f+0x198> @ imm = #0xc
 801a3ce: ee30 0a40    	<unknown>
 801a3d2: ed80 0a01    	<unknown>
 801a3d6: ed80 0a00    	<unknown>
 801a3da: e741         	b	0x801a260 <__rem_pio2f+0x1c> @ imm = #-0x17e
 801a3dc: 15da         	asrs	r2, r3, #0x17
 801a3de: 3a86         	subs	r2, #0x86
 801a3e0: eba3 53c2    	sub.w	r3, r3, r2, lsl #23
 801a3e4: ee07 3a90    	<unknown>
 801a3e8: eebd 7ae7    	<unknown>
 801a3ec: eddf 6a29    	<unknown>
 801a3f0: eeb8 7ac7    	<unknown>
 801a3f4: ee77 7ac7    	<unknown>
 801a3f8: ed8d 7a03    	<unknown>
 801a3fc: ee67 7aa6    	<unknown>
 801a400: eebd 7ae7    	<unknown>
 801a404: eeb8 7ac7    	<unknown>
 801a408: ee77 7ac7    	<unknown>
 801a40c: ed8d 7a04    	<unknown>
 801a410: ee67 7aa6    	<unknown>
 801a414: eef5 7a40    	<unknown>
 801a418: eef1 fa10    	<unknown>
 801a41c: edcd 7a05    	<unknown>
 801a420: d11e         	bne	0x801a460 <__rem_pio2f+0x21c> @ imm = #0x3c
 801a422: eeb5 7a40    	<unknown>
 801a426: eef1 fa10    	<unknown>
 801a42a: bf0c         	ite	eq
 801a42c: 2301         	moveq	r3, #0x1
 801a42e: 2302         	movne	r3, #0x2
 801a430: 4919         	ldr	r1, [pc, #0x64]         @ 0x801a498 <__rem_pio2f+0x254>
 801a432: 9101         	str	r1, [sp, #0x4]
 801a434: 2102         	movs	r1, #0x2
 801a436: 9100         	str	r1, [sp]
 801a438: a803         	add	r0, sp, #0xc
 801a43a: 4621         	mov	r1, r4
 801a43c: f000 f91a    	bl	0x801a674 <__kernel_rem_pio2f> @ imm = #0x234
 801a440: 2d00         	cmp	r5, #0x0
 801a442: f6bf af32    	bge.w	0x801a2aa <__rem_pio2f+0x66> @ imm = #-0x19c
 801a446: edd4 7a00    	<unknown>
 801a44a: eef1 7a67    	<unknown>
 801a44e: edc4 7a00    	<unknown>
 801a452: edd4 7a01    	<unknown>
 801a456: eef1 7a67    	<unknown>
 801a45a: edc4 7a01    	<unknown>
 801a45e: e782         	b	0x801a366 <__rem_pio2f+0x122> @ imm = #-0xfc
 801a460: 2303         	movs	r3, #0x3
 801a462: e7e5         	b	0x801a430 <__rem_pio2f+0x1ec> @ imm = #-0x36

0801a464 <$d>:
 801a464: d8 0f 49 3f  	.word	0x3f490fd8
 801a468: e3 cb 16 40  	.word	0x4016cbe3
 801a46c: 80 0f c9 3f  	.word	0x3fc90f80
 801a470: d0 0f c9 3f  	.word	0x3fc90fd0
 801a474: 00 44 35 37  	.word	0x37354400
 801a478: 43 44 35 37  	.word	0x37354443
 801a47c: 08 a3 85 2e  	.word	0x2e85a308
 801a480: 80 0f 49 43  	.word	0x43490f80
 801a484: 84 f9 22 3f  	.word	0x3f22f984
 801a488: 08 e7 02 08  	.word	0x0802e708
 801a48c: 00 a3 85 2e  	.word	0x2e85a300
 801a490: 32 31 8d 24  	.word	0x248d3132
 801a494: 00 00 80 43  	.word	0x43800000
 801a498: 88 e7 02 08  	.word	0x0802e788

0801a49c <sinf>:
 801a49c: ee10 3a10    	<unknown>
 801a4a0: b507         	push	{r0, r1, r2, lr}
 801a4a2: 4a20         	ldr	r2, [pc, #0x80]         @ 0x801a524 <sinf+0x88>
 801a4a4: f023 4300    	bic	r3, r3, #0x80000000
 801a4a8: 4293         	cmp	r3, r2
 801a4aa: d807         	bhi	0x801a4bc <sinf+0x20>   @ imm = #0xe
 801a4ac: eddf 0a1e    	<unknown>
 801a4b0: 2000         	movs	r0, #0x0
 801a4b2: b003         	add	sp, #0xc
 801a4b4: f85d eb04    	ldr	lr, [sp], #4
 801a4b8: f000 bb5a    	b.w	0x801ab70 <__kernel_sinf> @ imm = #0x6b4
 801a4bc: f1b3 4fff    	cmp.w	r3, #0x7f800000
 801a4c0: d304         	blo	0x801a4cc <sinf+0x30>   @ imm = #0x8
 801a4c2: b003         	add	sp, #0xc
 801a4c4: f85d eb04    	ldr	lr, [sp], #4
 801a4c8: f000 b868    	b.w	0x801a59c <__math_invalidf> @ imm = #0xd0
 801a4cc: 4668         	mov	r0, sp
 801a4ce: f7ff feb9    	bl	0x801a244 <__rem_pio2f> @ imm = #-0x28e
 801a4d2: f000 0003    	and	r0, r0, #0x3
 801a4d6: 2801         	cmp	r0, #0x1
 801a4d8: d00c         	beq	0x801a4f4 <sinf+0x58>   @ imm = #0x18
 801a4da: 2802         	cmp	r0, #0x2
 801a4dc: d011         	beq	0x801a502 <sinf+0x66>   @ imm = #0x22
 801a4de: b9d0         	cbnz	r0, 0x801a516 <sinf+0x7a> @ imm = #0x34
 801a4e0: eddd 0a01    	<unknown>
 801a4e4: ed9d 0a00    	<unknown>
 801a4e8: 2001         	movs	r0, #0x1
 801a4ea: f000 fb41    	bl	0x801ab70 <__kernel_sinf> @ imm = #0x682
 801a4ee: b003         	add	sp, #0xc
 801a4f0: f85d fb04    	ldr	pc, [sp], #4
 801a4f4: eddd 0a01    	<unknown>
 801a4f8: ed9d 0a00    	<unknown>
 801a4fc: f000 f862    	bl	0x801a5c4 <__kernel_cosf> @ imm = #0xc4
 801a500: e7f5         	b	0x801a4ee <sinf+0x52>   @ imm = #-0x16
 801a502: eddd 0a01    	<unknown>
 801a506: ed9d 0a00    	<unknown>
 801a50a: 2001         	movs	r0, #0x1
 801a50c: f000 fb30    	bl	0x801ab70 <__kernel_sinf> @ imm = #0x660
 801a510: eeb1 0a40    	<unknown>
 801a514: e7eb         	b	0x801a4ee <sinf+0x52>   @ imm = #-0x2a
 801a516: eddd 0a01    	<unknown>
 801a51a: ed9d 0a00    	<unknown>
 801a51e: f000 f851    	bl	0x801a5c4 <__kernel_cosf> @ imm = #0xa2
 801a522: e7f5         	b	0x801a510 <sinf+0x74>   @ imm = #-0x16

0801a524 <$d>:
 801a524: d8 0f 49 3f  	.word	0x3f490fd8
 801a528: 00 00 00 00  	.word	0x00000000

0801a52c <__fpclassifyf>:
 801a52c: ee10 3a10    	<unknown>
 801a530: f033 4000    	bics	r0, r3, #0x80000000
 801a534: d00d         	beq	0x801a552 <__fpclassifyf+0x26> @ imm = #0x1a
 801a536: f5a0 0300    	sub.w	r3, r0, #0x800000
 801a53a: f1b3 4ffe    	cmp.w	r3, #0x7f000000
 801a53e: d30a         	blo	0x801a556 <__fpclassifyf+0x2a> @ imm = #0x14
 801a540: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x801a560 <__fpclassifyf+0x34>
 801a542: 1e42         	subs	r2, r0, #0x1
 801a544: 429a         	cmp	r2, r3
 801a546: d908         	bls	0x801a55a <__fpclassifyf+0x2e> @ imm = #0x10
 801a548: f1a0 43ff    	sub.w	r3, r0, #0x7f800000
 801a54c: 4258         	rsbs	r0, r3, #0
 801a54e: 4158         	adcs	r0, r3
 801a550: 4770         	bx	lr
 801a552: 2002         	movs	r0, #0x2
 801a554: 4770         	bx	lr
 801a556: 2004         	movs	r0, #0x4
 801a558: 4770         	bx	lr
 801a55a: 2003         	movs	r0, #0x3
 801a55c: 4770         	bx	lr
 801a55e: bf00         	nop

0801a560 <$d>:
 801a560: fe ff 7f 00  	.word	0x007ffffe

0801a564 <__math_uflowf>:
 801a564: ed9f 0a04    	<unknown>
 801a568: eddf 7a04    	<unknown>
 801a56c: 2800         	cmp	r0, #0x0
 801a56e: fe40 7a27    	<unknown>
 801a572: ee27 0a80    	<unknown>
 801a576: 4770         	bx	lr

0801a578 <$d>:
 801a578: 00 00 80 00  	.word	0x00800000
 801a57c: 00 00 80 80  	.word	0x80800000

0801a580 <__math_oflowf>:
 801a580: ed9f 0a04    	<unknown>
 801a584: eddf 7a04    	<unknown>
 801a588: 2800         	cmp	r0, #0x0
 801a58a: fe40 7a27    	<unknown>
 801a58e: ee27 0a80    	<unknown>
 801a592: 4770         	bx	lr

0801a594 <$d>:
 801a594: ff ff 7f 7f  	.word	0x7f7fffff
 801a598: ff ff 7f ff  	.word	0xff7fffff

0801a59c <__math_invalidf>:
 801a59c: b508         	push	{r3, lr}
 801a59e: ed2d 8b02    	<unknown>
 801a5a2: eeb0 8a40    	<unknown>
 801a5a6: f7ff ffc1    	bl	0x801a52c <__fpclassifyf> @ imm = #-0x7e
 801a5aa: b920         	cbnz	r0, 0x801a5b6 <__math_invalidf+0x1a> @ imm = #0x8
 801a5ac: ee38 0a08    	<unknown>
 801a5b0: ecbd 8b02    	<unknown>
 801a5b4: bd08         	pop	{r3, pc}
 801a5b6: eddf 7a02    	<unknown>
 801a5ba: ee87 0aa7    	<unknown>
 801a5be: e7f7         	b	0x801a5b0 <__math_invalidf+0x14> @ imm = #-0x12

0801a5c0 <$d>:
 801a5c0: 00 00 00 00  	.word	0x00000000

0801a5c4 <__kernel_cosf>:
 801a5c4: ee10 3a10    	<unknown>
 801a5c8: f023 4300    	bic	r3, r3, #0x80000000
 801a5cc: f1b3 5f48    	cmp.w	r3, #0x32000000
 801a5d0: eeb7 7a00    	<unknown>
 801a5d4: d33b         	blo	0x801a64e <__kernel_cosf+0x8a> @ imm = #0x76
 801a5d6: ee60 6a00    	<unknown>
 801a5da: eddf 5a1e    	<unknown>
 801a5de: ed9f 6a1e    	<unknown>
 801a5e2: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x801a65c <__kernel_cosf+0x98>
 801a5e4: ee06 6aa5    	<unknown>
 801a5e8: 4293         	cmp	r3, r2
 801a5ea: eddf 5a1d    	<unknown>
 801a5ee: ee56 5a26    	<unknown>
 801a5f2: ed9f 6a1c    	<unknown>
 801a5f6: ee05 6aa6    	<unknown>
 801a5fa: eddf 5a1b    	<unknown>
 801a5fe: ee56 5a26    	<unknown>
 801a602: ed9f 6a1a    	<unknown>
 801a606: ee05 6aa6    	<unknown>
 801a60a: ee60 0a20    	<unknown>
 801a60e: ee26 6a26    	<unknown>
 801a612: eef6 7a00    	<unknown>
 801a616: ee56 0a26    	<unknown>
 801a61a: ee66 7aa7    	<unknown>
 801a61e: d804         	bhi	0x801a62a <__kernel_cosf+0x66> @ imm = #0x8
 801a620: ee77 7ae0    	<unknown>
 801a624: ee37 0a67    	<unknown>
 801a628: 4770         	bx	lr
 801a62a: 4a11         	ldr	r2, [pc, #0x44]         @ 0x801a670 <__kernel_cosf+0xac>
 801a62c: 4293         	cmp	r3, r2
 801a62e: bf9a         	itte	ls
 801a630: f103 437f    	addls.w	r3, r3, #0xff000000
 801a634: ee06 3a90    	<unknown>
 801a638: eef5 6a02    	<unknown>
 801a63c: ee77 7ae6    	<unknown>
 801a640: ee37 0a66    	<unknown>
 801a644: ee77 7ae0    	<unknown>
 801a648: ee30 0a67    	<unknown>
 801a64c: 4770         	bxls	lr
 801a64e: eeb0 0a47    	<unknown>
 801a652: 4770         	bxhi	lr

0801a654 <$d>:
 801a654: 4e d7 47 ad  	.word	0xad47d74e
 801a658: f6 74 0f 31  	.word	0x310f74f6
 801a65c: 99 99 99 3e  	.word	0x3e999999
 801a660: 7c f2 93 34  	.word	0x3493f27c
 801a664: 01 0d d0 37  	.word	0x37d00d01
 801a668: 61 0b b6 3a  	.word	0x3ab60b61
 801a66c: ab aa 2a 3d  	.word	0x3d2aaaab
 801a670: 00 00 48 3f  	.word	0x3f480000

0801a674 <__kernel_rem_pio2f>:
 801a674: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 801a678: ed2d 8b04    	<unknown>
 801a67c: b0d9         	sub	sp, #0x164
 801a67e: 4690         	mov	r8, r2
 801a680: 469b         	mov	r11, r3
 801a682: 9a66         	ldr	r2, [sp, #0x198]
 801a684: 4bbe         	ldr	r3, [pc, #0x2f8]        @ 0x801a980 <__kernel_rem_pio2f+0x30c>
 801a686: f8dd c19c    	ldr.w	r12, [sp, #0x19c]
 801a68a: f853 a022    	ldr.w	r10, [r3, r2, lsl #2]
 801a68e: 9001         	str	r0, [sp, #0x4]
 801a690: f118 0f04    	cmn.w	r8, #0x4
 801a694: 460f         	mov	r7, r1
 801a696: f10b 33ff    	add.w	r3, r11, #0xffffffff
 801a69a: db25         	blt	0x801a6e8 <__kernel_rem_pio2f+0x74> @ imm = #0x4a
 801a69c: f1b8 0203    	subs.w	r2, r8, #0x3
 801a6a0: bf48         	it	mi
 801a6a2: f108 0204    	addmi.w	r2, r8, #0x4
 801a6a6: 10d2         	asrs	r2, r2, #0x3
 801a6a8: 1c55         	adds	r5, r2, #0x1
 801a6aa: 00e9         	lsls	r1, r5, #0x3
 801a6ac: 1ad4         	subs	r4, r2, r3
 801a6ae: ed9f 7ab8    	<unknown>
 801a6b2: 9102         	str	r1, [sp, #0x8]
 801a6b4: eba8 05c5    	sub.w	r5, r8, r5, lsl #3
 801a6b8: eb0a 0603    	add.w	r6, r10, r3
 801a6bc: f10d 0970    	add.w	r9, sp, #0x70
 801a6c0: eb0c 0e84    	add.w	lr, r12, r4, lsl #2
 801a6c4: 2100         	movs	r1, #0x0
 801a6c6: 42b1         	cmp	r1, r6
 801a6c8: dd10         	ble	0x801a6ec <__kernel_rem_pio2f+0x78> @ imm = #0x20
 801a6ca: a91c         	add	r1, sp, #0x70
 801a6cc: eb01 018b    	add.w	r1, r1, r11, lsl #2
 801a6d0: f50d 7988    	add.w	r9, sp, #0x110
 801a6d4: 2600         	movs	r6, #0x0
 801a6d6: 4556         	cmp	r6, r10
 801a6d8: dc26         	bgt	0x801a728 <__kernel_rem_pio2f+0xb4> @ imm = #0x4c
 801a6da: f8dd e004    	ldr.w	lr, [sp, #0x4]
 801a6de: eddf 7aac    	<unknown>
 801a6e2: 460c         	mov	r4, r1
 801a6e4: 2000         	movs	r0, #0x0
 801a6e6: e016         	b	0x801a716 <__kernel_rem_pio2f+0xa2> @ imm = #0x2c
 801a6e8: 2200         	movs	r2, #0x0
 801a6ea: e7dd         	b	0x801a6a8 <__kernel_rem_pio2f+0x34> @ imm = #-0x46
 801a6ec: 42cc         	cmn	r4, r1
 801a6ee: bf5d         	ittte	pl
 801a6f0: f85e 0021    	ldrpl.w	r0, [lr, r1, lsl #2]
 801a6f4: ee07 0a90    	<unknown>
 801a6f8: eef8 7ae7    	<unknown>
 801a6fc: eef0 7a47    	<unknown>
 801a700: ece9 7a01    	<unknown>
 801a704: 3101         	addpl	r1, #0x1
 801a706: e7de         	bpl	0x801a6c6 <__kernel_rem_pio2f+0x52> @ imm = #-0x44
 801a708: ecfe 6a01    	<unknown>
 801a70c: ed94 7a00    	<unknown>
 801a710: ee46 7a87    	<unknown>
 801a714: 3001         	addmi	r0, #0x1
 801a716: 4298         	cmp	r0, r3
 801a718: f1a4 0404    	sub.w	r4, r4, #0x4
 801a71c: ddf4         	ble	0x801a708 <__kernel_rem_pio2f+0x94> @ imm = #-0x18
 801a71e: ece9 7a01    	<unknown>
 801a722: 3601         	adds	r6, #0x1
 801a724: 3104         	adds	r1, #0x4
 801a726: e7d6         	b	0x801a6d6 <__kernel_rem_pio2f+0x62> @ imm = #-0x54
 801a728: a908         	add	r1, sp, #0x20
 801a72a: eb01 018a    	add.w	r1, r1, r10, lsl #2
 801a72e: eb0c 0282    	add.w	r2, r12, r2, lsl #2
 801a732: eddf 8a96    	<unknown>
 801a736: ed9f 9a94    	<unknown>
 801a73a: 9104         	str	r1, [sp, #0x10]
 801a73c: 9203         	str	r2, [sp, #0xc]
 801a73e: 4654         	mov	r4, r10
 801a740: 00a2         	lsls	r2, r4, #0x2
 801a742: 9205         	str	r2, [sp, #0x14]
 801a744: aa58         	add	r2, sp, #0x160
 801a746: eb02 0284    	add.w	r2, r2, r4, lsl #2
 801a74a: ed12 0a14    	<unknown>
 801a74e: a944         	add	r1, sp, #0x110
 801a750: aa08         	add	r2, sp, #0x20
 801a752: eb01 0184    	add.w	r1, r1, r4, lsl #2
 801a756: 4616         	mov	r6, r2
 801a758: 4620         	mov	r0, r4
 801a75a: 2800         	cmp	r0, #0x0
 801a75c: f1a1 0104    	sub.w	r1, r1, #0x4
 801a760: dc4e         	bgt	0x801a800 <__kernel_rem_pio2f+0x18c> @ imm = #0x9c
 801a762: 4628         	mov	r0, r5
 801a764: e9cd 3206    	strd	r3, r2, [sp, #24]
 801a768: f000 fb2e    	bl	0x801adc8 <scalbnf>     @ imm = #0x65c
 801a76c: eef4 7a00    	<unknown>
 801a770: eeb0 8a40    	<unknown>
 801a774: eeb2 7a00    	<unknown>
 801a778: ee60 7a27    	<unknown>
 801a77c: fefb 7a67    	<unknown>
 801a780: ee07 8ac7    	<unknown>
 801a784: 2d00         	cmp	r5, #0x0
 801a786: e9dd 3206    	ldrd	r3, r2, [sp, #24]
 801a78a: eefd 7ac8    	<unknown>
 801a78e: ee17 9a90    	<unknown>
 801a792: eef8 7ae7    	<unknown>
 801a796: ee38 8a67    	<unknown>
 801a79a: dd43         	ble	0x801a824 <__kernel_rem_pio2f+0x1b0> @ imm = #0x86
 801a79c: 1e60         	subs	r0, r4, #0x1
 801a79e: a908         	add	r1, sp, #0x20
 801a7a0: f1c5 0c08    	rsb.w	r12, r5, #0x8
 801a7a4: f851 6020    	ldr.w	r6, [r1, r0, lsl #2]
 801a7a8: fa46 f10c    	asr.w	r1, r6, r12
 801a7ac: 4489         	add	r9, r1
 801a7ae: fa01 f10c    	lsl.w	r1, r1, r12
 801a7b2: 1a76         	subs	r6, r6, r1
 801a7b4: a908         	add	r1, sp, #0x20
 801a7b6: f841 6020    	str.w	r6, [r1, r0, lsl #2]
 801a7ba: f1c5 0107    	rsb.w	r1, r5, #0x7
 801a7be: 410e         	asrs	r6, r1
 801a7c0: 2e00         	cmp	r6, #0x0
 801a7c2: dd3e         	ble	0x801a842 <__kernel_rem_pio2f+0x1ce> @ imm = #0x7c
 801a7c4: f04f 0c00    	mov.w	r12, #0x0
 801a7c8: f109 0901    	add.w	r9, r9, #0x1
 801a7cc: 4660         	mov	r0, r12
 801a7ce: 4564         	cmp	r4, r12
 801a7d0: dc6a         	bgt	0x801a8a8 <__kernel_rem_pio2f+0x234> @ imm = #0xd4
 801a7d2: 2d00         	cmp	r5, #0x0
 801a7d4: dd05         	ble	0x801a7e2 <__kernel_rem_pio2f+0x16e> @ imm = #0xa
 801a7d6: 2d01         	cmp	r5, #0x1
 801a7d8: f000 8083    	beq.w	0x801a8e2 <__kernel_rem_pio2f+0x26e> @ imm = #0x106
 801a7dc: 2d02         	cmp	r5, #0x2
 801a7de: f000 808b    	beq.w	0x801a8f8 <__kernel_rem_pio2f+0x284> @ imm = #0x116
 801a7e2: 2e02         	cmp	r6, #0x2
 801a7e4: d12d         	bne	0x801a842 <__kernel_rem_pio2f+0x1ce> @ imm = #0x5a
 801a7e6: eeb7 0a00    	<unknown>
 801a7ea: ee30 8a48    	<unknown>
 801a7ee: b340         	cbz	r0, 0x801a842 <__kernel_rem_pio2f+0x1ce> @ imm = #0x50
 801a7f0: 4628         	mov	r0, r5
 801a7f2: 9306         	str	r3, [sp, #0x18]
 801a7f4: f000 fae8    	bl	0x801adc8 <scalbnf>     @ imm = #0x5d0
 801a7f8: 9b06         	ldr	r3, [sp, #0x18]
 801a7fa: ee38 8a40    	<unknown>
 801a7fe: e020         	b	0x801a842 <__kernel_rem_pio2f+0x1ce> @ imm = #0x40
 801a800: ee60 7a28    	<unknown>
 801a804: 3801         	subs	r0, #0x1
 801a806: eefd 7ae7    	<unknown>
 801a80a: eef8 7ae7    	<unknown>
 801a80e: ee07 0ac9    	<unknown>
 801a812: eebd 0ac0    	<unknown>
 801a816: eca6 0a01    	<unknown>
 801a81a: ed91 0a00    	<unknown>
 801a81e: ee37 0a80    	<unknown>
 801a822: e79a         	b	0x801a75a <__kernel_rem_pio2f+0xe6> @ imm = #-0xcc
 801a824: d105         	bne	0x801a832 <__kernel_rem_pio2f+0x1be> @ imm = #0xa
 801a826: 1e61         	subs	r1, r4, #0x1
 801a828: a808         	add	r0, sp, #0x20
 801a82a: f850 6021    	ldr.w	r6, [r0, r1, lsl #2]
 801a82e: 11f6         	asrs	r6, r6, #0x7
 801a830: e7c6         	b	0x801a7c0 <__kernel_rem_pio2f+0x14c> @ imm = #-0x74
 801a832: eef6 7a00    	<unknown>
 801a836: eeb4 8ae7    	<unknown>
 801a83a: eef1 fa10    	<unknown>
 801a83e: da31         	bge	0x801a8a4 <__kernel_rem_pio2f+0x230> @ imm = #0x62
 801a840: 2600         	movs	r6, #0x0
 801a842: eeb5 8a40    	<unknown>
 801a846: eef1 fa10    	<unknown>
 801a84a: f040 80a3    	bne.w	0x801a994 <__kernel_rem_pio2f+0x320> @ imm = #0x146
 801a84e: 1e61         	subs	r1, r4, #0x1
 801a850: 2000         	movs	r0, #0x0
 801a852: 4551         	cmp	r1, r10
 801a854: da57         	bge	0x801a906 <__kernel_rem_pio2f+0x292> @ imm = #0xae
 801a856: 2800         	cmp	r0, #0x0
 801a858: d071         	beq	0x801a93e <__kernel_rem_pio2f+0x2ca> @ imm = #0xe2
 801a85a: 3c01         	subs	r4, #0x1
 801a85c: ab08         	add	r3, sp, #0x20
 801a85e: 3d08         	subs	r5, #0x8
 801a860: f853 3024    	ldr.w	r3, [r3, r4, lsl #2]
 801a864: 2b00         	cmp	r3, #0x0
 801a866: d0f8         	beq	0x801a85a <__kernel_rem_pio2f+0x1e6> @ imm = #-0x10
 801a868: 4628         	mov	r0, r5
 801a86a: eeb7 0a00    	<unknown>
 801a86e: f000 faab    	bl	0x801adc8 <scalbnf>     @ imm = #0x556
 801a872: 1c63         	adds	r3, r4, #0x1
 801a874: aa44         	add	r2, sp, #0x110
 801a876: ed9f 7a45    	<unknown>
 801a87a: 0099         	lsls	r1, r3, #0x2
 801a87c: eb02 0283    	add.w	r2, r2, r3, lsl #2
 801a880: 4623         	mov	r3, r4
 801a882: 2b00         	cmp	r3, #0x0
 801a884: f280 80b4    	bge.w	0x801a9f0 <__kernel_rem_pio2f+0x37c> @ imm = #0x168
 801a888: 4623         	mov	r3, r4
 801a88a: 2b00         	cmp	r3, #0x0
 801a88c: f2c0 80d2    	blt.w	0x801aa34 <__kernel_rem_pio2f+0x3c0> @ imm = #0x1a4
 801a890: aa44         	add	r2, sp, #0x110
 801a892: eb02 0583    	add.w	r5, r2, r3, lsl #2
 801a896: f8df c0ec    	ldr.w	r12, [pc, #0xec]        @ 0x801a984 <__kernel_rem_pio2f+0x310>
 801a89a: eddf 7a3d    	<unknown>
 801a89e: 2000         	movs	r0, #0x0
 801a8a0: 1ae2         	subs	r2, r4, r3
 801a8a2: e0bc         	b	0x801aa1e <__kernel_rem_pio2f+0x3aa> @ imm = #0x178
 801a8a4: 2602         	movs	r6, #0x2
 801a8a6: e78d         	b	0x801a7c4 <__kernel_rem_pio2f+0x150> @ imm = #-0xe6
 801a8a8: 4696         	mov	lr, r2
 801a8aa: f85e 1b04    	ldr	r1, [lr], #4
 801a8ae: b960         	cbnz	r0, 0x801a8ca <__kernel_rem_pio2f+0x256> @ imm = #0x18
 801a8b0: b181         	cbz	r1, 0x801a8d4 <__kernel_rem_pio2f+0x260> @ imm = #0x20
 801a8b2: f10c 0c01    	add.w	r12, r12, #0x1
 801a8b6: f5c1 7180    	rsb.w	r1, r1, #0x100
 801a8ba: 4564         	cmp	r4, r12
 801a8bc: f84e 1c04    	str	r1, [lr, #-4]
 801a8c0: dd0d         	ble	0x801a8de <__kernel_rem_pio2f+0x26a> @ imm = #0x1a
 801a8c2: f8de 1000    	ldr.w	r1, [lr]
 801a8c6: f102 0e08    	add.w	lr, r2, #0x8
 801a8ca: f1c1 01ff    	rsb.w	r1, r1, #0xff
 801a8ce: f84e 1c04    	str	r1, [lr, #-4]
 801a8d2: 2101         	movs	r1, #0x1
 801a8d4: f10c 0c01    	add.w	r12, r12, #0x1
 801a8d8: 4672         	mov	r2, lr
 801a8da: 4608         	mov	r0, r1
 801a8dc: e777         	b	0x801a7ce <__kernel_rem_pio2f+0x15a> @ imm = #-0x112
 801a8de: 2001         	movs	r0, #0x1
 801a8e0: e777         	b	0x801a7d2 <__kernel_rem_pio2f+0x15e> @ imm = #-0x112
 801a8e2: 1e61         	subs	r1, r4, #0x1
 801a8e4: aa08         	add	r2, sp, #0x20
 801a8e6: f852 2021    	ldr.w	r2, [r2, r1, lsl #2]
 801a8ea: f002 027f    	and	r2, r2, #0x7f
 801a8ee: f10d 0c20    	add.w	r12, sp, #0x20
 801a8f2: f84c 2021    	str.w	r2, [r12, r1, lsl #2]
 801a8f6: e774         	b	0x801a7e2 <__kernel_rem_pio2f+0x16e> @ imm = #-0x118
 801a8f8: 1e61         	subs	r1, r4, #0x1
 801a8fa: aa08         	add	r2, sp, #0x20
 801a8fc: f852 2021    	ldr.w	r2, [r2, r1, lsl #2]
 801a900: f002 023f    	and	r2, r2, #0x3f
 801a904: e7f3         	b	0x801a8ee <__kernel_rem_pio2f+0x27a> @ imm = #-0x1a
 801a906: aa08         	add	r2, sp, #0x20
 801a908: f852 2021    	ldr.w	r2, [r2, r1, lsl #2]
 801a90c: 3901         	subs	r1, #0x1
 801a90e: 4310         	orrs	r0, r2
 801a910: e79f         	b	0x801a852 <__kernel_rem_pio2f+0x1de> @ imm = #-0xc2
 801a912: 3201         	adds	r2, #0x1
 801a914: f851 0d04    	ldr	r0, [r1, #-4]!
 801a918: 2800         	cmp	r0, #0x0
 801a91a: d0fa         	beq	0x801a912 <__kernel_rem_pio2f+0x29e> @ imm = #-0xc
 801a91c: 9905         	ldr	r1, [sp, #0x14]
 801a91e: f501 71b0    	add.w	r1, r1, #0x160
 801a922: 4469         	add	r1, sp, r1
 801a924: eb04 000b    	add.w	r0, r4, r11
 801a928: f10d 0c70    	add.w	r12, sp, #0x70
 801a92c: 1c66         	adds	r6, r4, #0x1
 801a92e: 394c         	subs	r1, #0x4c
 801a930: eb0c 0080    	add.w	r0, r12, r0, lsl #2
 801a934: 4422         	add	r2, r4
 801a936: 42b2         	cmp	r2, r6
 801a938: da04         	bge	0x801a944 <__kernel_rem_pio2f+0x2d0> @ imm = #0x8
 801a93a: 4614         	mov	r4, r2
 801a93c: e700         	b	0x801a740 <__kernel_rem_pio2f+0xcc> @ imm = #-0x200
 801a93e: 9904         	ldr	r1, [sp, #0x10]
 801a940: 2201         	movs	r2, #0x1
 801a942: e7e7         	b	0x801a914 <__kernel_rem_pio2f+0x2a0> @ imm = #-0x32
 801a944: 9c03         	ldr	r4, [sp, #0xc]
 801a946: f8dd c004    	ldr.w	r12, [sp, #0x4]
 801a94a: f854 4026    	ldr.w	r4, [r4, r6, lsl #2]
 801a94e: 9405         	str	r4, [sp, #0x14]
 801a950: ee07 4a90    	<unknown>
 801a954: eef8 7ae7    	<unknown>
 801a958: 2400         	movs	r4, #0x0
 801a95a: ece0 7a01    	<unknown>
 801a95e: eddf 7a0c    	<unknown>
 801a962: 4686         	mov	lr, r0
 801a964: 429c         	cmp	r4, r3
 801a966: dd03         	ble	0x801a970 <__kernel_rem_pio2f+0x2fc> @ imm = #0x6
 801a968: ece1 7a01    	<unknown>
 801a96c: 3601         	adds	r6, #0x1
 801a96e: e7e2         	b	0x801a936 <__kernel_rem_pio2f+0x2c2> @ imm = #-0x3c
 801a970: ecfc 6a01    	<unknown>
 801a974: ed3e 7a01    	<unknown>
 801a978: 3401         	adds	r4, #0x1
 801a97a: ee46 7a87    	<unknown>
 801a97e: e7f1         	b	0x801a964 <__kernel_rem_pio2f+0x2f0> @ imm = #-0x1e

0801a980 <$d>:
 801a980: cc ea 02 08  	.word	0x0802eacc
 801a984: a0 ea 02 08  	.word	0x0802eaa0
 801a988: 00 00 80 43  	.word	0x43800000
 801a98c: 00 00 80 3b  	.word	0x3b800000
 801a990: 00 00 00 00  	.word	0x00000000

0801a994 <$t>:
 801a994: 9b02         	ldr	r3, [sp, #0x8]
 801a996: eeb0 0a48    	<unknown>
 801a99a: eba3 0008    	sub.w	r0, r3, r8
 801a99e: f000 fa13    	bl	0x801adc8 <scalbnf>     @ imm = #0x426
 801a9a2: ed1f 7a07    	<unknown>
 801a9a6: eeb4 0ac7    	<unknown>
 801a9aa: eef1 fa10    	<unknown>
 801a9ae: db19         	blt	0x801a9e4 <__kernel_rem_pio2f+0x370> @ imm = #0x32
 801a9b0: ed5f 7a0a    	<unknown>
 801a9b4: ee60 7a27    	<unknown>
 801a9b8: aa08         	add	r2, sp, #0x20
 801a9ba: eefd 7ae7    	<unknown>
 801a9be: 3508         	adds	r5, #0x8
 801a9c0: eef8 7ae7    	<unknown>
 801a9c4: ee07 0ac7    	<unknown>
 801a9c8: eefd 7ae7    	<unknown>
 801a9cc: eebd 0ac0    	<unknown>
 801a9d0: ee10 3a10    	<unknown>
 801a9d4: f842 3024    	str.w	r3, [r2, r4, lsl #2]
 801a9d8: ee17 3a90    	<unknown>
 801a9dc: 3401         	adds	r4, #0x1
 801a9de: f842 3024    	str.w	r3, [r2, r4, lsl #2]
 801a9e2: e741         	b	0x801a868 <__kernel_rem_pio2f+0x1f4> @ imm = #-0x17e
 801a9e4: eebd 0ac0    	<unknown>
 801a9e8: aa08         	add	r2, sp, #0x20
 801a9ea: ee10 3a10    	<unknown>
 801a9ee: e7f6         	b	0x801a9de <__kernel_rem_pio2f+0x36a> @ imm = #-0x14
 801a9f0: a808         	add	r0, sp, #0x20
 801a9f2: f850 0023    	ldr.w	r0, [r0, r3, lsl #2]
 801a9f6: 9001         	str	r0, [sp, #0x4]
 801a9f8: ee07 0a90    	<unknown>
 801a9fc: eef8 7ae7    	<unknown>
 801aa00: 3b01         	subs	r3, #0x1
 801aa02: ee67 7a80    	<unknown>
 801aa06: ee20 0a07    	<unknown>
 801aa0a: ed62 7a01    	<unknown>
 801aa0e: e738         	b	0x801a882 <__kernel_rem_pio2f+0x20e> @ imm = #-0x190
 801aa10: ecfc 6a01    	<unknown>
 801aa14: ecb5 7a01    	<unknown>
 801aa18: ee46 7a87    	<unknown>
 801aa1c: 3001         	adds	r0, #0x1
 801aa1e: 4550         	cmp	r0, r10
 801aa20: dc01         	bgt	0x801aa26 <__kernel_rem_pio2f+0x3b2> @ imm = #0x2
 801aa22: 4282         	cmp	r2, r0
 801aa24: daf4         	bge	0x801aa10 <__kernel_rem_pio2f+0x39c> @ imm = #-0x18
 801aa26: a858         	add	r0, sp, #0x160
 801aa28: eb00 0282    	add.w	r2, r0, r2, lsl #2
 801aa2c: ed42 7a28    	<unknown>
 801aa30: 3b01         	subs	r3, #0x1
 801aa32: e72a         	b	0x801a88a <__kernel_rem_pio2f+0x216> @ imm = #-0x1ac
 801aa34: 9b66         	ldr	r3, [sp, #0x198]
 801aa36: 2b02         	cmp	r3, #0x2
 801aa38: dc09         	bgt	0x801aa4e <__kernel_rem_pio2f+0x3da> @ imm = #0x12
 801aa3a: 2b00         	cmp	r3, #0x0
 801aa3c: dc2b         	bgt	0x801aa96 <__kernel_rem_pio2f+0x422> @ imm = #0x56
 801aa3e: d044         	beq	0x801aaca <__kernel_rem_pio2f+0x456> @ imm = #0x88
 801aa40: f009 0007    	and	r0, r9, #0x7
 801aa44: b059         	add	sp, #0x164
 801aa46: ecbd 8b04    	<unknown>
 801aa4a: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 801aa4e: 9b66         	ldr	r3, [sp, #0x198]
 801aa50: 2b03         	cmp	r3, #0x3
 801aa52: d1f5         	bne	0x801aa40 <__kernel_rem_pio2f+0x3cc> @ imm = #-0x16
 801aa54: aa30         	add	r2, sp, #0xc0
 801aa56: 1f0b         	subs	r3, r1, #0x4
 801aa58: 4413         	add	r3, r2
 801aa5a: 461a         	mov	r2, r3
 801aa5c: 4620         	mov	r0, r4
 801aa5e: 2800         	cmp	r0, #0x0
 801aa60: f1a2 0204    	sub.w	r2, r2, #0x4
 801aa64: dc52         	bgt	0x801ab0c <__kernel_rem_pio2f+0x498> @ imm = #0xa4
 801aa66: 4622         	mov	r2, r4
 801aa68: 2a01         	cmp	r2, #0x1
 801aa6a: f1a3 0304    	sub.w	r3, r3, #0x4
 801aa6e: dc5d         	bgt	0x801ab2c <__kernel_rem_pio2f+0x4b8> @ imm = #0xba
 801aa70: ab30         	add	r3, sp, #0xc0
 801aa72: ed5f 7a39    	<unknown>
 801aa76: 440b         	add	r3, r1
 801aa78: 2c01         	cmp	r4, #0x1
 801aa7a: dc67         	bgt	0x801ab4c <__kernel_rem_pio2f+0x4d8> @ imm = #0xce
 801aa7c: eddd 6a30    	<unknown>
 801aa80: ed9d 7a31    	<unknown>
 801aa84: 2e00         	cmp	r6, #0x0
 801aa86: d167         	bne	0x801ab58 <__kernel_rem_pio2f+0x4e4> @ imm = #0xce
 801aa88: edc7 6a00    	<unknown>
 801aa8c: ed87 7a01    	<unknown>
 801aa90: edc7 7a02    	<unknown>
 801aa94: e7d4         	b	0x801aa40 <__kernel_rem_pio2f+0x3cc> @ imm = #-0x58
 801aa96: ab30         	add	r3, sp, #0xc0
 801aa98: ed1f 7a43    	<unknown>
 801aa9c: 440b         	add	r3, r1
 801aa9e: 4622         	mov	r2, r4
 801aaa0: 2a00         	cmp	r2, #0x0
 801aaa2: da24         	bge	0x801aaee <__kernel_rem_pio2f+0x47a> @ imm = #0x48
 801aaa4: b34e         	cbz	r6, 0x801aafa <__kernel_rem_pio2f+0x486> @ imm = #0x52
 801aaa6: eef1 7a47    	<unknown>
 801aaaa: edc7 7a00    	<unknown>
 801aaae: eddd 7a30    	<unknown>
 801aab2: ee77 7ac7    	<unknown>
 801aab6: aa31         	add	r2, sp, #0xc4
 801aab8: 2301         	movs	r3, #0x1
 801aaba: 429c         	cmp	r4, r3
 801aabc: da20         	bge	0x801ab00 <__kernel_rem_pio2f+0x48c> @ imm = #0x40
 801aabe: b10e         	cbz	r6, 0x801aac4 <__kernel_rem_pio2f+0x450> @ imm = #0x2
 801aac0: eef1 7a67    	<unknown>
 801aac4: edc7 7a01    	<unknown>
 801aac8: e7ba         	b	0x801aa40 <__kernel_rem_pio2f+0x3cc> @ imm = #-0x8c
 801aaca: ab30         	add	r3, sp, #0xc0
 801aacc: ed5f 7a50    	<unknown>
 801aad0: 440b         	add	r3, r1
 801aad2: 2c00         	cmp	r4, #0x0
 801aad4: da05         	bge	0x801aae2 <__kernel_rem_pio2f+0x46e> @ imm = #0xa
 801aad6: b10e         	cbz	r6, 0x801aadc <__kernel_rem_pio2f+0x468> @ imm = #0x2
 801aad8: eef1 7a67    	<unknown>
 801aadc: edc7 7a00    	<unknown>
 801aae0: e7ae         	b	0x801aa40 <__kernel_rem_pio2f+0x3cc> @ imm = #-0xa4
 801aae2: ed33 7a01    	<unknown>
 801aae6: 3c01         	subs	r4, #0x1
 801aae8: ee77 7a87    	<unknown>
 801aaec: e7f1         	b	0x801aad2 <__kernel_rem_pio2f+0x45e> @ imm = #-0x1e
 801aaee: ed73 7a01    	<unknown>
 801aaf2: 3a01         	subs	r2, #0x1
 801aaf4: ee37 7a27    	<unknown>
 801aaf8: e7d2         	b	0x801aaa0 <__kernel_rem_pio2f+0x42c> @ imm = #-0x5c
 801aafa: eef0 7a47    	<unknown>
 801aafe: e7d4         	b	0x801aaaa <__kernel_rem_pio2f+0x436> @ imm = #-0x58
 801ab00: ecb2 7a01    	<unknown>
 801ab04: 3301         	adds	r3, #0x1
 801ab06: ee77 7a87    	<unknown>
 801ab0a: e7d6         	b	0x801aaba <__kernel_rem_pio2f+0x446> @ imm = #-0x54
 801ab0c: edd2 7a00    	<unknown>
 801ab10: edd2 6a01    	<unknown>
 801ab14: ee37 7aa6    	<unknown>
 801ab18: 3801         	subs	r0, #0x1
 801ab1a: ee77 7ac7    	<unknown>
 801ab1e: ed82 7a00    	<unknown>
 801ab22: ee77 7aa6    	<unknown>
 801ab26: edc2 7a01    	<unknown>
 801ab2a: e798         	b	0x801aa5e <__kernel_rem_pio2f+0x3ea> @ imm = #-0xd0
 801ab2c: edd3 7a00    	<unknown>
 801ab30: edd3 6a01    	<unknown>
 801ab34: ee37 7aa6    	<unknown>
 801ab38: 3a01         	subs	r2, #0x1
 801ab3a: ee77 7ac7    	<unknown>
 801ab3e: ed83 7a00    	<unknown>
 801ab42: ee77 7aa6    	<unknown>
 801ab46: edc3 7a01    	<unknown>
 801ab4a: e78d         	b	0x801aa68 <__kernel_rem_pio2f+0x3f4> @ imm = #-0xe6
 801ab4c: ed33 7a01    	<unknown>
 801ab50: 3c01         	subs	r4, #0x1
 801ab52: ee77 7a87    	<unknown>
 801ab56: e78f         	b	0x801aa78 <__kernel_rem_pio2f+0x404> @ imm = #-0xe2
 801ab58: eef1 6a66    	<unknown>
 801ab5c: eeb1 7a47    	<unknown>
 801ab60: edc7 6a00    	<unknown>
 801ab64: ed87 7a01    	<unknown>
 801ab68: eef1 7a67    	<unknown>
 801ab6c: e790         	b	0x801aa90 <__kernel_rem_pio2f+0x41c> @ imm = #-0xe0
 801ab6e: bf00         	nop

0801ab70 <__kernel_sinf>:
 801ab70: ee10 3a10    	<unknown>
 801ab74: f023 4300    	bic	r3, r3, #0x80000000
 801ab78: f1b3 5f48    	cmp.w	r3, #0x32000000
 801ab7c: eef0 7a40    	<unknown>
 801ab80: d201         	bhs	0x801ab86 <__kernel_sinf+0x16> @ imm = #0x2
 801ab82: f000 b913    	b.w	0x801adac <__math_inexactf> @ imm = #0x226
 801ab86: ee60 6a00    	<unknown>
 801ab8a: ed9f 7a16    	<unknown>
 801ab8e: eddf 5a16    	<unknown>
 801ab92: ee56 5a87    	<unknown>
 801ab96: ed9f 7a15    	<unknown>
 801ab9a: ee05 7aa6    	<unknown>
 801ab9e: eddf 5a14    	<unknown>
 801aba2: ee57 5a26    	<unknown>
 801aba6: ed9f 7a13    	<unknown>
 801abaa: ee20 6a26    	<unknown>
 801abae: ee05 7aa6    	<unknown>
 801abb2: b940         	cbnz	r0, 0x801abc6 <__kernel_sinf+0x56> @ imm = #0x10
 801abb4: eddf 5a10    	<unknown>
 801abb8: ee56 5a87    	<unknown>
 801abbc: ee45 7a86    	<unknown>
 801abc0: eeb0 0a67    	<unknown>
 801abc4: 4770         	bx	lr
 801abc6: ee26 7a07    	<unknown>
 801abca: eef6 5a00    	<unknown>
 801abce: ee10 7aa5    	<unknown>
 801abd2: ee57 0a26    	<unknown>
 801abd6: ed9f 7a09    	<unknown>
 801abda: ee46 0a47    	<unknown>
 801abde: ee30 0a60    	<unknown>
 801abe2: 4770         	bx	lr

0801abe4 <$d>:
 801abe4: d3 c9 2e 2f  	.word	0x2f2ec9d3
 801abe8: 34 2f d7 32  	.word	0x32d72f34
 801abec: 1b ef 38 36  	.word	0x3638ef1b
 801abf0: 01 0d 50 39  	.word	0x39500d01
 801abf4: 89 88 08 3c  	.word	0x3c088889
 801abf8: ab aa 2a 3e  	.word	0x3e2aaaab
 801abfc: ab aa 2a be  	.word	0xbe2aaaab

0801ac00 <atanf>:
 801ac00: ee10 2a10    	<unknown>
 801ac04: f022 4300    	bic	r3, r2, #0x80000000
 801ac08: f1b3 4fa1    	cmp.w	r3, #0x50800000
 801ac0c: d312         	blo	0x801ac34 <atanf+0x34>  @ imm = #0x24
 801ac0e: f1b3 4fff    	cmp.w	r3, #0x7f800000
 801ac12: d902         	bls	0x801ac1a <atanf+0x1a>  @ imm = #0x4
 801ac14: ee30 0a00    	<unknown>
 801ac18: 4770         	bx	lr
 801ac1a: 2a00         	cmp	r2, #0x0
 801ac1c: ed9f 0a4f    	<unknown>
 801ac20: bfcb         	itete	gt
 801ac22: eddf 7a4f    	<unknown>
 801ac26: eddf 7a4f    	<unknown>
 801ac2a: ee37 0a80    	<unknown>
 801ac2e: ee37 0ac0    	<unknown>
 801ac32: 4770         	bxgt	lr
 801ac34: 494c         	ldrle	r1, [pc, #0x130]        @ 0x801ad68 <atanf+0x168>
 801ac36: 428b         	cmpgt	r3, r1
 801ac38: d811         	ble	0x801ac5e <atanf+0x5e>  @ imm = #0x22
 801ac3a: f1b3 5f44    	cmp.w	r3, #0x31000000
 801ac3e: d20b         	bhs	0x801ac58 <atanf+0x58>  @ imm = #0x16
 801ac40: eddf 7a4a    	<unknown>
 801ac44: ee70 7a27    	<unknown>
 801ac48: eeb7 7a00    	<unknown>
 801ac4c: eef4 7ac7    	<unknown>
 801ac50: eef1 fa10    	<unknown>
 801ac54: f300 8081    	bgt.w	0x801ad5a <atanf+0x15a> @ imm = #0x102
 801ac58: f04f 33ff    	mov.w	r3, #0xffffffff
 801ac5c: e015         	b	0x801ac8a <atanf+0x8a>  @ imm = #0x2a
 801ac5e: 4944         	ldr	r1, [pc, #0x110]        @ 0x801ad70 <atanf+0x170>
 801ac60: eef0 7ac0    	<unknown>
 801ac64: 428b         	cmp	r3, r1
 801ac66: d84f         	bhi	0x801ad08 <atanf+0x108> @ imm = #0x9e
 801ac68: f5a1 01d0    	sub.w	r1, r1, #0x680000
 801ac6c: 428b         	cmp	r3, r1
 801ac6e: eeb7 7a00    	<unknown>
 801ac72: d841         	bhi	0x801acf8 <atanf+0xf8>  @ imm = #0x82
 801ac74: ee77 6aa7    	<unknown>
 801ac78: 2300         	movs	r3, #0x0
 801ac7a: ee36 7ac7    	<unknown>
 801ac7e: eef0 6a00    	<unknown>
 801ac82: ee77 7aa6    	<unknown>
 801ac86: ee87 0a27    	<unknown>
 801ac8a: 1c59         	adds	r1, r3, #0x1
 801ac8c: ee60 6a00    	<unknown>
 801ac90: eddf 7a38    	<unknown>
 801ac94: ed9f 6a38    	<unknown>
 801ac98: eddf 5a38    	<unknown>
 801ac9c: ee26 7aa6    	<unknown>
 801aca0: ee07 6a27    	<unknown>
 801aca4: eddf 7a36    	<unknown>
 801aca8: ee46 7a07    	<unknown>
 801acac: ed9f 6a35    	<unknown>
 801acb0: ee07 6a87    	<unknown>
 801acb4: eddf 7a34    	<unknown>
 801acb8: ee46 7a07    	<unknown>
 801acbc: ed9f 6a33    	<unknown>
 801acc0: ee07 6a87    	<unknown>
 801acc4: eddf 7a32    	<unknown>
 801acc8: ee57 5a27    	<unknown>
 801accc: eddf 7a31    	<unknown>
 801acd0: ee55 7a87    	<unknown>
 801acd4: eddf 5a30    	<unknown>
 801acd8: ee57 5a87    	<unknown>
 801acdc: eddf 7a2f    	<unknown>
 801ace0: ee55 7a87    	<unknown>
 801ace4: ee67 7a87    	<unknown>
 801ace8: ee46 7a26    	<unknown>
 801acec: ee67 7a80    	<unknown>
 801acf0: d11f         	bne	0x801ad32 <atanf+0x132> @ imm = #0x3e
 801acf2: ee30 0a67    	<unknown>
 801acf6: 4770         	bx	lr
 801acf8: ee77 6ac7    	<unknown>
 801acfc: ee77 7a87    	<unknown>
 801ad00: 2301         	movs	r3, #0x1
 801ad02: ee86 0aa7    	<unknown>
 801ad06: e7c0         	b	0x801ac8a <atanf+0x8a>  @ imm = #-0x80
 801ad08: 4925         	ldr	r1, [pc, #0x94]         @ 0x801ada0 <atanf+0x1a0>
 801ad0a: 428b         	cmp	r3, r1
 801ad0c: d80b         	bhi	0x801ad26 <atanf+0x126> @ imm = #0x16
 801ad0e: eef7 6a08    	<unknown>
 801ad12: eeb7 7a00    	<unknown>
 801ad16: ee07 7aa6    	<unknown>
 801ad1a: 2302         	movs	r3, #0x2
 801ad1c: ee37 6ae6    	<unknown>
 801ad20: ee86 0a07    	<unknown>
 801ad24: e7b1         	b	0x801ac8a <atanf+0x8a>  @ imm = #-0x9e
 801ad26: eebf 7a00    	<unknown>
 801ad2a: ee87 0a27    	<unknown>
 801ad2e: 2303         	movs	r3, #0x3
 801ad30: e7ab         	b	0x801ac8a <atanf+0x8a>  @ imm = #-0xaa
 801ad32: 491c         	ldr	r1, [pc, #0x70]         @ 0x801ada4 <atanf+0x1a4>
 801ad34: 481c         	ldr	r0, [pc, #0x70]         @ 0x801ada8 <atanf+0x1a8>
 801ad36: eb01 0183    	add.w	r1, r1, r3, lsl #2
 801ad3a: eb00 0383    	add.w	r3, r0, r3, lsl #2
 801ad3e: ed93 7a00    	<unknown>
 801ad42: ee77 7ac7    	<unknown>
 801ad46: 2a00         	cmp	r2, #0x0
 801ad48: ee77 7ac0    	<unknown>
 801ad4c: ed91 0a00    	<unknown>
 801ad50: ee30 0a67    	<unknown>
 801ad54: bfb8         	it	lt
 801ad56: eeb1 0a40    	<unknown>
 801ad5a: 4770         	bxlt	lr

0801ad5c <$d>:
 801ad5c: 68 21 a2 33  	.word	0x33a22168
 801ad60: da 0f c9 3f  	.word	0x3fc90fda
 801ad64: da 0f c9 bf  	.word	0xbfc90fda
 801ad68: ff ff df 3e  	.word	0x3edfffff
 801ad6c: ca f2 49 71  	.word	0x7149f2ca
 801ad70: ff ff 97 3f  	.word	0x3f97ffff
 801ad74: d7 69 85 3c  	.word	0x3c8569d7
 801ad78: 59 da 4b 3d  	.word	0x3d4bda59
 801ad7c: 6b f1 6e 3d  	.word	0x3d6ef16b
 801ad80: 35 6b 88 3d  	.word	0x3d886b35
 801ad84: 6e 2e ba 3d  	.word	0x3dba2e6e
 801ad88: 25 49 12 3e  	.word	0x3e124925
 801ad8c: ab aa aa 3e  	.word	0x3eaaaaab
 801ad90: 21 a2 15 bd  	.word	0xbd15a221
 801ad94: 95 87 9d 3d  	.word	0x3d9d8795
 801ad98: 38 8e e3 3d  	.word	0x3de38e38
 801ad9c: cd cc 4c 3e  	.word	0x3e4ccccd
 801ada0: ff ff 1b 40  	.word	0x401bffff
 801ada4: e8 ea 02 08  	.word	0x0802eae8
 801ada8: d8 ea 02 08  	.word	0x0802ead8

0801adac <__math_inexactf>:
 801adac: ed9f 7a05    	<unknown>
 801adb0: eef7 7a00    	<unknown>
 801adb4: ee77 7a87    	<unknown>
 801adb8: b082         	sub	sp, #0x8
 801adba: edcd 7a01    	<unknown>
 801adbe: 9b01         	ldr	r3, [sp, #0x4]
 801adc0: b002         	add	sp, #0x8
 801adc2: 4770         	bx	lr

0801adc4 <$d>:
 801adc4: 00 00 80 00  	.word	0x00800000

0801adc8 <scalbnf>:
 801adc8: 4602         	mov	r2, r0
 801adca: ee10 0a10    	<unknown>
 801adce: f3c0 53c7    	ubfx	r3, r0, #0x17, #0x8
 801add2: f020 4100    	bic	r1, r0, #0x80000000
 801add6: b983         	cbnz	r3, 0x801adfa <scalbnf+0x32> @ imm = #0x20
 801add8: b3a9         	cbz	r1, 0x801ae46 <scalbnf+0x7e> @ imm = #0x6a
 801adda: eddf 7a1b    	<unknown>
 801adde: 491b         	ldr	r1, [pc, #0x6c]         @ 0x801ae4c <scalbnf+0x84>
 801ade0: ee60 7a27    	<unknown>
 801ade4: 428a         	cmp	r2, r1
 801ade6: ee17 0a90    	<unknown>
 801adea: f3c0 53c7    	ubfx	r3, r0, #0x17, #0x8
 801adee: f1a3 0319    	sub.w	r3, r3, #0x19
 801adf2: da07         	bge	0x801ae04 <scalbnf+0x3c> @ imm = #0xe
 801adf4: 0fc0         	lsrs	r0, r0, #0x1f
 801adf6: f7ff bbb5    	b.w	0x801a564 <__math_uflowf> @ imm = #-0x896
 801adfa: 2bff         	cmp	r3, #0xff
 801adfc: d102         	bne	0x801ae04 <scalbnf+0x3c> @ imm = #0x4
 801adfe: ee30 0a00    	<unknown>
 801ae02: 4770         	bx	lr
 801ae04: f24c 3150    	movw	r1, #0xc350
 801ae08: 428a         	cmp	r2, r1
 801ae0a: dd02         	ble	0x801ae12 <scalbnf+0x4a> @ imm = #0x4
 801ae0c: 0fc0         	lsrs	r0, r0, #0x1f
 801ae0e: f7ff bbb7    	b.w	0x801a580 <__math_oflowf> @ imm = #-0x892
 801ae12: 4413         	add	r3, r2
 801ae14: 2bfe         	cmp	r3, #0xfe
 801ae16: dcf9         	bgt	0x801ae0c <scalbnf+0x44> @ imm = #-0xe
 801ae18: 2b00         	cmp	r3, #0x0
 801ae1a: dd06         	ble	0x801ae2a <scalbnf+0x62> @ imm = #0xc
 801ae1c: f020 40ff    	bic	r0, r0, #0x7f800000
 801ae20: ea40 53c3    	orr.w	r3, r0, r3, lsl #23
 801ae24: ee00 3a10    	<unknown>
 801ae28: 4770         	bx	lr
 801ae2a: f113 0f18    	cmn.w	r3, #0x18
 801ae2e: dbe1         	blt	0x801adf4 <scalbnf+0x2c> @ imm = #-0x3e
 801ae30: 3319         	adds	r3, #0x19
 801ae32: f020 40ff    	bic	r0, r0, #0x7f800000
 801ae36: ea40 50c3    	orr.w	r0, r0, r3, lsl #23
 801ae3a: ed9f 0a05    	<unknown>
 801ae3e: ee07 0a90    	<unknown>
 801ae42: ee27 0a80    	<unknown>
 801ae46: 4770         	bx	lr

0801ae48 <$d>:
 801ae48: 00 00 00 4c  	.word	0x4c000000
 801ae4c: b0 3c ff ff  	.word	0xffff3cb0
 801ae50: 00 00 00 33  	.word	0x33000000

0801ae54 <_OffsetAbsSyms>:
; GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
 801ae54: b480         	push	{r7}
 801ae56: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 801ae58: bf00         	nop
 801ae5a: 46bd         	mov	sp, r7
 801ae5c: f85d 7b04    	ldr	r7, [sp], #4
 801ae60: 4770         	bx	lr

0801ae62 <z_impl_pid_calc>:
; static inline void z_impl_pid_calc(const struct device *dev) {
 801ae62: b580         	push	{r7, lr}
 801ae64: b084         	sub	sp, #0x10
 801ae66: af00         	add	r7, sp, #0x0
 801ae68: 6078         	str	r0, [r7, #0x4]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 801ae6a: 687b         	ldr	r3, [r7, #0x4]
 801ae6c: 689b         	ldr	r3, [r3, #0x8]
 801ae6e: 60fb         	str	r3, [r7, #0xc]
;     if (api->pid_calc != NULL) {
 801ae70: 68fb         	ldr	r3, [r7, #0xc]
 801ae72: 681b         	ldr	r3, [r3]
 801ae74: 2b00         	cmp	r3, #0x0
 801ae76: d003         	beq	0x801ae80 <z_impl_pid_calc+0x1e> @ imm = #0x6
;         api->pid_calc(dev);
 801ae78: 68fb         	ldr	r3, [r7, #0xc]
 801ae7a: 681b         	ldr	r3, [r3]
 801ae7c: 6878         	ldr	r0, [r7, #0x4]
 801ae7e: 4798         	blx	r3
; }
 801ae80: bf00         	nop
 801ae82: 3710         	adds	r7, #0x10
 801ae84: 46bd         	mov	sp, r7
 801ae86: bd80         	pop	{r7, pc}

0801ae88 <z_impl_pid_reg_input>:
; static inline void z_impl_pid_reg_input(const struct device *dev, float *curr, float *ref) {
 801ae88: b580         	push	{r7, lr}
 801ae8a: b086         	sub	sp, #0x18
 801ae8c: af00         	add	r7, sp, #0x0
 801ae8e: 60f8         	str	r0, [r7, #0xc]
 801ae90: 60b9         	str	r1, [r7, #0x8]
 801ae92: 607a         	str	r2, [r7, #0x4]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 801ae94: 68fb         	ldr	r3, [r7, #0xc]
 801ae96: 689b         	ldr	r3, [r3, #0x8]
 801ae98: 617b         	str	r3, [r7, #0x14]
;     if (api->pid_reg_input != NULL) {
 801ae9a: 697b         	ldr	r3, [r7, #0x14]
 801ae9c: 685b         	ldr	r3, [r3, #0x4]
 801ae9e: 2b00         	cmp	r3, #0x0
 801aea0: d005         	beq	0x801aeae <z_impl_pid_reg_input+0x26> @ imm = #0xa
;         api->pid_reg_input(dev, curr, ref);
 801aea2: 697b         	ldr	r3, [r7, #0x14]
 801aea4: 685b         	ldr	r3, [r3, #0x4]
 801aea6: 687a         	ldr	r2, [r7, #0x4]
 801aea8: 68b9         	ldr	r1, [r7, #0x8]
 801aeaa: 68f8         	ldr	r0, [r7, #0xc]
 801aeac: 4798         	blx	r3
; }
 801aeae: bf00         	nop
 801aeb0: 3718         	adds	r7, #0x18
 801aeb2: 46bd         	mov	sp, r7
 801aeb4: bd80         	pop	{r7, pc}

0801aeb6 <z_impl_pid_reg_output>:
; static inline void z_impl_pid_reg_output(const struct device *dev, float *output) {
 801aeb6: b580         	push	{r7, lr}
 801aeb8: b084         	sub	sp, #0x10
 801aeba: af00         	add	r7, sp, #0x0
 801aebc: 6078         	str	r0, [r7, #0x4]
 801aebe: 6039         	str	r1, [r7]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 801aec0: 687b         	ldr	r3, [r7, #0x4]
 801aec2: 689b         	ldr	r3, [r3, #0x8]
 801aec4: 60fb         	str	r3, [r7, #0xc]
;     if (api->pid_reg_output != NULL) {
 801aec6: 68fb         	ldr	r3, [r7, #0xc]
 801aec8: 691b         	ldr	r3, [r3, #0x10]
 801aeca: 2b00         	cmp	r3, #0x0
 801aecc: d004         	beq	0x801aed8 <z_impl_pid_reg_output+0x22> @ imm = #0x8
;         api->pid_reg_output(dev, output);
 801aece: 68fb         	ldr	r3, [r7, #0xc]
 801aed0: 691b         	ldr	r3, [r3, #0x10]
 801aed2: 6839         	ldr	r1, [r7]
 801aed4: 6878         	ldr	r0, [r7, #0x4]
 801aed6: 4798         	blx	r3
; }
 801aed8: bf00         	nop
 801aeda: 3710         	adds	r7, #0x10
 801aedc: 46bd         	mov	sp, r7
 801aede: bd80         	pop	{r7, pc}

0801aee0 <pid_calc>:
; {
 801aee0: b580         	push	{r7, lr}
 801aee2: b082         	sub	sp, #0x8
 801aee4: af00         	add	r7, sp, #0x0
 801aee6: 6078         	str	r0, [r7, #0x4]
; 	z_impl_pid_calc(dev);
 801aee8: 6878         	ldr	r0, [r7, #0x4]
 801aeea: f7ff ffba    	bl	0x801ae62 <z_impl_pid_calc> @ imm = #-0x8c
; }
 801aeee: bf00         	nop
 801aef0: 3708         	adds	r7, #0x8
 801aef2: 46bd         	mov	sp, r7
 801aef4: bd80         	pop	{r7, pc}

0801aef6 <pid_reg_input>:
; {
 801aef6: b580         	push	{r7, lr}
 801aef8: b084         	sub	sp, #0x10
 801aefa: af00         	add	r7, sp, #0x0
 801aefc: 60f8         	str	r0, [r7, #0xc]
 801aefe: 60b9         	str	r1, [r7, #0x8]
 801af00: 607a         	str	r2, [r7, #0x4]
; 	z_impl_pid_reg_input(dev, curr, ref);
 801af02: 687a         	ldr	r2, [r7, #0x4]
 801af04: 68b9         	ldr	r1, [r7, #0x8]
 801af06: 68f8         	ldr	r0, [r7, #0xc]
 801af08: f7ff ffbe    	bl	0x801ae88 <z_impl_pid_reg_input> @ imm = #-0x84
; }
 801af0c: bf00         	nop
 801af0e: 3710         	adds	r7, #0x10
 801af10: 46bd         	mov	sp, r7
 801af12: bd80         	pop	{r7, pc}

0801af14 <pid_reg_output>:
; {
 801af14: b580         	push	{r7, lr}
 801af16: b082         	sub	sp, #0x8
 801af18: af00         	add	r7, sp, #0x0
 801af1a: 6078         	str	r0, [r7, #0x4]
 801af1c: 6039         	str	r1, [r7]
; 	z_impl_pid_reg_output(dev, output);
 801af1e: 6839         	ldr	r1, [r7]
 801af20: 6878         	ldr	r0, [r7, #0x4]
 801af22: f7ff ffc8    	bl	0x801aeb6 <z_impl_pid_reg_output> @ imm = #-0x70
; }
 801af26: bf00         	nop
 801af28: 3708         	adds	r7, #0x8
 801af2a: 46bd         	mov	sp, r7
 801af2c: bd80         	pop	{r7, pc}

0801af2e <device_is_ready>:
; {
 801af2e: b580         	push	{r7, lr}
 801af30: b082         	sub	sp, #0x8
 801af32: af00         	add	r7, sp, #0x0
 801af34: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801af36: 6878         	ldr	r0, [r7, #0x4]
 801af38: f00b fa31    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0xb462
 801af3c: 4603         	mov	r3, r0
; }
 801af3e: 4618         	mov	r0, r3
 801af40: 3708         	adds	r7, #0x8
 801af42: 46bd         	mov	sp, r7
 801af44: bd80         	pop	{r7, pc}

0801af46 <arch_k_cycle_get_32>:
; {
 801af46: b580         	push	{r7, lr}
 801af48: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 801af4a: f7f6 fc7b    	bl	0x8011844 <sys_clock_cycle_get_32> @ imm = #-0x970a
 801af4e: 4603         	mov	r3, r0
; }
 801af50: 4618         	mov	r0, r3
 801af52: bd80         	pop	{r7, pc}

0801af54 <k_msleep>:
; {
 801af54: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 801af58: b082         	sub	sp, #0x8
 801af5a: af00         	add	r7, sp, #0x0
 801af5c: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 801af5e: 6879         	ldr	r1, [r7, #0x4]
 801af60: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 801af64: 17c8         	asrs	r0, r1, #0x1f
 801af66: 4688         	mov	r8, r1
 801af68: 4681         	mov	r9, r0
 801af6a: 4640         	mov	r0, r8
 801af6c: 4649         	mov	r1, r9
 801af6e: f04f 0400    	mov.w	r4, #0x0
 801af72: f04f 0500    	mov.w	r5, #0x0
 801af76: 008d         	lsls	r5, r1, #0x2
 801af78: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 801af7c: 0084         	lsls	r4, r0, #0x2
 801af7e: 4620         	mov	r0, r4
 801af80: 4629         	mov	r1, r5
 801af82: eb10 0208    	adds.w	r2, r0, r8
 801af86: eb41 0309    	adc.w	r3, r1, r9
 801af8a: eb12 0a02    	adds.w	r10, r2, r2
 801af8e: eb43 0b03    	adc.w	r11, r3, r3
 801af92: 4652         	mov	r2, r10
 801af94: 465b         	mov	r3, r11
 801af96: 4610         	mov	r0, r2
 801af98: 4619         	mov	r1, r3
 801af9a: f000 f82e    	bl	0x801affa <k_sleep>     @ imm = #0x5c
 801af9e: 4601         	mov	r1, r0
 801afa0: 460b         	mov	r3, r1
; }
 801afa2: 4618         	mov	r0, r3
 801afa4: 3708         	adds	r7, #0x8
 801afa6: 46bd         	mov	sp, r7
 801afa8: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0801afac <k_cycle_get_32>:
; {
 801afac: b580         	push	{r7, lr}
 801afae: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 801afb0: f7ff ffc9    	bl	0x801af46 <arch_k_cycle_get_32> @ imm = #-0x6e
 801afb4: 4603         	mov	r3, r0
; }
 801afb6: 4618         	mov	r0, r3
 801afb8: bd80         	pop	{r7, pc}

0801afba <k_thread_create>:
; {
 801afba: b580         	push	{r7, lr}
 801afbc: b08c         	sub	sp, #0x30
 801afbe: af08         	add	r7, sp, #0x20
 801afc0: 60f8         	str	r0, [r7, #0xc]
 801afc2: 60b9         	str	r1, [r7, #0x8]
 801afc4: 607a         	str	r2, [r7, #0x4]
 801afc6: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 801afc8: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 801afcc: e9cd 2306    	strd	r2, r3, [sp, #24]
 801afd0: 6abb         	ldr	r3, [r7, #0x28]
 801afd2: 9304         	str	r3, [sp, #0x10]
 801afd4: 6a7b         	ldr	r3, [r7, #0x24]
 801afd6: 9303         	str	r3, [sp, #0xc]
 801afd8: 6a3b         	ldr	r3, [r7, #0x20]
 801afda: 9302         	str	r3, [sp, #0x8]
 801afdc: 69fb         	ldr	r3, [r7, #0x1c]
 801afde: 9301         	str	r3, [sp, #0x4]
 801afe0: 69bb         	ldr	r3, [r7, #0x18]
 801afe2: 9300         	str	r3, [sp]
 801afe4: 683b         	ldr	r3, [r7]
 801afe6: 687a         	ldr	r2, [r7, #0x4]
 801afe8: 68b9         	ldr	r1, [r7, #0x8]
 801afea: 68f8         	ldr	r0, [r7, #0xc]
 801afec: f00d f819    	bl	0x8028022 <z_impl_k_thread_create> @ imm = #0xd032
 801aff0: 4603         	mov	r3, r0
; }
 801aff2: 4618         	mov	r0, r3
 801aff4: 3710         	adds	r7, #0x10
 801aff6: 46bd         	mov	sp, r7
 801aff8: bd80         	pop	{r7, pc}

0801affa <k_sleep>:
; {
 801affa: b580         	push	{r7, lr}
 801affc: b082         	sub	sp, #0x8
 801affe: af00         	add	r7, sp, #0x0
 801b000: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 801b004: e9d7 0100    	ldrd	r0, r1, [r7]
 801b008: f7fc fbb0    	bl	0x801776c <z_impl_k_sleep> @ imm = #-0x38a0
 801b00c: 4603         	mov	r3, r0
; }
 801b00e: 4618         	mov	r0, r3
 801b010: 3708         	adds	r7, #0x8
 801b012: 46bd         	mov	sp, r7
 801b014: bd80         	pop	{r7, pc}

0801b016 <z_impl_sbus_get_percent>:
; static inline float z_impl_sbus_get_percent(const struct device *dev, uint8_t channelid) {
 801b016: b580         	push	{r7, lr}
 801b018: b084         	sub	sp, #0x10
 801b01a: af00         	add	r7, sp, #0x0
 801b01c: 6078         	str	r0, [r7, #0x4]
 801b01e: 460b         	mov	r3, r1
 801b020: 70fb         	strb	r3, [r7, #0x3]
;     const struct sbus_driver_api *api = (const struct sbus_driver_api *)dev->api;
 801b022: 687b         	ldr	r3, [r7, #0x4]
 801b024: 689b         	ldr	r3, [r3, #0x8]
 801b026: 60fb         	str	r3, [r7, #0xc]
;     if (api->getchannel_percentage) {
 801b028: 68fb         	ldr	r3, [r7, #0xc]
 801b02a: 681b         	ldr	r3, [r3]
 801b02c: 2b00         	cmp	r3, #0x0
 801b02e: d009         	beq	0x801b044 <z_impl_sbus_get_percent+0x2e> @ imm = #0x12
;         float temp = api->getchannel_percentage(dev, channelid);
 801b030: 68fb         	ldr	r3, [r7, #0xc]
 801b032: 681b         	ldr	r3, [r3]
 801b034: 78fa         	ldrb	r2, [r7, #0x3]
 801b036: 4611         	mov	r1, r2
 801b038: 6878         	ldr	r0, [r7, #0x4]
 801b03a: 4798         	blx	r3
 801b03c: ed87 0a02    	<unknown>
;         return temp;
 801b040: 68bb         	ldr	r3, [r7, #0x8]
 801b042: e001         	b	0x801b048 <z_impl_sbus_get_percent+0x32> @ imm = #0x2
;     return 0.0f;
 801b044: f04f 0300    	mov.w	r3, #0x0
; }
 801b048: ee07 3a90    	<unknown>
 801b04c: eeb0 0a67    	<unknown>
 801b050: 3710         	adds	r7, #0x10
 801b052: 46bd         	mov	sp, r7
 801b054: bd80         	pop	{r7, pc}

0801b056 <sbus_get_percent>:
; {
 801b056: b580         	push	{r7, lr}
 801b058: b082         	sub	sp, #0x8
 801b05a: af00         	add	r7, sp, #0x0
 801b05c: 6078         	str	r0, [r7, #0x4]
 801b05e: 460b         	mov	r3, r1
 801b060: 70fb         	strb	r3, [r7, #0x3]
; 	return z_impl_sbus_get_percent(dev, channelid);
 801b062: 78fb         	ldrb	r3, [r7, #0x3]
 801b064: 4619         	mov	r1, r3
 801b066: 6878         	ldr	r0, [r7, #0x4]
 801b068: f7ff ffd5    	bl	0x801b016 <z_impl_sbus_get_percent> @ imm = #-0x56
 801b06c: eef0 7a40    	<unknown>
; }
 801b070: eeb0 0a67    	<unknown>
 801b074: 3708         	adds	r7, #0x8
 801b076: 46bd         	mov	sp, r7
 801b078: bd80         	pop	{r7, pc}

0801b07a <z_impl_gpio_pin_configure>:
; {
 801b07a: b580         	push	{r7, lr}
 801b07c: b088         	sub	sp, #0x20
 801b07e: af00         	add	r7, sp, #0x0
 801b080: 60f8         	str	r0, [r7, #0xc]
 801b082: 460b         	mov	r3, r1
 801b084: 607a         	str	r2, [r7, #0x4]
 801b086: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 801b088: 68fb         	ldr	r3, [r7, #0xc]
 801b08a: 689b         	ldr	r3, [r3, #0x8]
 801b08c: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 801b08e: 68fb         	ldr	r3, [r7, #0xc]
 801b090: 685b         	ldr	r3, [r3, #0x4]
 801b092: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 801b094: 68fb         	ldr	r3, [r7, #0xc]
 801b096: 691b         	ldr	r3, [r3, #0x10]
 801b098: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 801b09a: 687b         	ldr	r3, [r7, #0x4]
 801b09c: f403 1380    	and	r3, r3, #0x100000
 801b0a0: 2b00         	cmp	r3, #0x0
 801b0a2: d00d         	beq	0x801b0c0 <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 801b0a4: 687b         	ldr	r3, [r7, #0x4]
 801b0a6: f403 2340    	and	r3, r3, #0xc0000
 801b0aa: 2b00         	cmp	r3, #0x0
 801b0ac: d008         	beq	0x801b0c0 <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 801b0ae: 687b         	ldr	r3, [r7, #0x4]
 801b0b0: f003 0301    	and	r3, r3, #0x1
 801b0b4: 2b00         	cmp	r3, #0x0
 801b0b6: d003         	beq	0x801b0c0 <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 801b0b8: 687b         	ldr	r3, [r7, #0x4]
 801b0ba: f483 2340    	eor	r3, r3, #0xc0000
 801b0be: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 801b0c0: 687b         	ldr	r3, [r7, #0x4]
 801b0c2: f423 1380    	bic	r3, r3, #0x100000
 801b0c6: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 801b0c8: 687b         	ldr	r3, [r7, #0x4]
 801b0ca: f003 0301    	and	r3, r3, #0x1
 801b0ce: 2b00         	cmp	r3, #0x0
 801b0d0: d009         	beq	0x801b0e6 <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 801b0d2: 697b         	ldr	r3, [r7, #0x14]
 801b0d4: 681a         	ldr	r2, [r3]
 801b0d6: 7afb         	ldrb	r3, [r7, #0xb]
 801b0d8: 2101         	movs	r1, #0x1
 801b0da: fa01 f303    	lsl.w	r3, r1, r3
 801b0de: 431a         	orrs	r2, r3
 801b0e0: 697b         	ldr	r3, [r7, #0x14]
 801b0e2: 601a         	str	r2, [r3]
 801b0e4: e009         	b	0x801b0fa <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 801b0e6: 697b         	ldr	r3, [r7, #0x14]
 801b0e8: 681a         	ldr	r2, [r3]
 801b0ea: 7afb         	ldrb	r3, [r7, #0xb]
 801b0ec: 2101         	movs	r1, #0x1
 801b0ee: fa01 f303    	lsl.w	r3, r1, r3
 801b0f2: 43db         	mvns	r3, r3
 801b0f4: 401a         	ands	r2, r3
 801b0f6: 697b         	ldr	r3, [r7, #0x14]
 801b0f8: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 801b0fa: 69fb         	ldr	r3, [r7, #0x1c]
 801b0fc: 681b         	ldr	r3, [r3]
 801b0fe: 7af9         	ldrb	r1, [r7, #0xb]
 801b100: 687a         	ldr	r2, [r7, #0x4]
 801b102: 68f8         	ldr	r0, [r7, #0xc]
 801b104: 4798         	blx	r3
 801b106: 4603         	mov	r3, r0
; }
 801b108: 4618         	mov	r0, r3
 801b10a: 3720         	adds	r7, #0x20
 801b10c: 46bd         	mov	sp, r7
 801b10e: bd80         	pop	{r7, pc}

0801b110 <gpio_pin_configure_dt>:
; {
 801b110: b580         	push	{r7, lr}
 801b112: b082         	sub	sp, #0x8
 801b114: af00         	add	r7, sp, #0x0
 801b116: 6078         	str	r0, [r7, #0x4]
 801b118: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 801b11a: 687b         	ldr	r3, [r7, #0x4]
 801b11c: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 801b11e: 687b         	ldr	r3, [r7, #0x4]
 801b120: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 801b122: 687b         	ldr	r3, [r7, #0x4]
 801b124: 88db         	ldrh	r3, [r3, #0x6]
 801b126: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 801b128: 683b         	ldr	r3, [r7]
 801b12a: 4313         	orrs	r3, r2
 801b12c: 461a         	mov	r2, r3
 801b12e: f000 f805    	bl	0x801b13c <gpio_pin_configure> @ imm = #0xa
 801b132: 4603         	mov	r3, r0
; }
 801b134: 4618         	mov	r0, r3
 801b136: 3708         	adds	r7, #0x8
 801b138: 46bd         	mov	sp, r7
 801b13a: bd80         	pop	{r7, pc}

0801b13c <gpio_pin_configure>:
; {
 801b13c: b580         	push	{r7, lr}
 801b13e: b084         	sub	sp, #0x10
 801b140: af00         	add	r7, sp, #0x0
 801b142: 60f8         	str	r0, [r7, #0xc]
 801b144: 460b         	mov	r3, r1
 801b146: 607a         	str	r2, [r7, #0x4]
 801b148: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 801b14a: 7afb         	ldrb	r3, [r7, #0xb]
 801b14c: 687a         	ldr	r2, [r7, #0x4]
 801b14e: 4619         	mov	r1, r3
 801b150: 68f8         	ldr	r0, [r7, #0xc]
 801b152: f7ff ff92    	bl	0x801b07a <z_impl_gpio_pin_configure> @ imm = #-0xdc
 801b156: 4603         	mov	r3, r0
; }
 801b158: 4618         	mov	r0, r3
 801b15a: 3710         	adds	r7, #0x10
 801b15c: 46bd         	mov	sp, r7
 801b15e: bd80         	pop	{r7, pc}

0801b160 <sensor_trigger_set>:
; {
 801b160: b580         	push	{r7, lr}
 801b162: b086         	sub	sp, #0x18
 801b164: af00         	add	r7, sp, #0x0
 801b166: 60f8         	str	r0, [r7, #0xc]
 801b168: 60b9         	str	r1, [r7, #0x8]
 801b16a: 607a         	str	r2, [r7, #0x4]
; 	const struct sensor_driver_api *api =
 801b16c: 68fb         	ldr	r3, [r7, #0xc]
 801b16e: 689b         	ldr	r3, [r3, #0x8]
 801b170: 617b         	str	r3, [r7, #0x14]
; 	if (api->trigger_set == NULL) {
 801b172: 697b         	ldr	r3, [r7, #0x14]
 801b174: 689b         	ldr	r3, [r3, #0x8]
 801b176: 2b00         	cmp	r3, #0x0
 801b178: d102         	bne	0x801b180 <sensor_trigger_set+0x20> @ imm = #0x4
; 		return -ENOSYS;
 801b17a: f06f 0357    	mvn	r3, #0x57
 801b17e: e006         	b	0x801b18e <sensor_trigger_set+0x2e> @ imm = #0xc
; 	return api->trigger_set(dev, trig, handler);
 801b180: 697b         	ldr	r3, [r7, #0x14]
 801b182: 689b         	ldr	r3, [r3, #0x8]
 801b184: 687a         	ldr	r2, [r7, #0x4]
 801b186: 68b9         	ldr	r1, [r7, #0x8]
 801b188: 68f8         	ldr	r0, [r7, #0xc]
 801b18a: 4798         	blx	r3
 801b18c: 4603         	mov	r3, r0
; }
 801b18e: 4618         	mov	r0, r3
 801b190: 3718         	adds	r7, #0x18
 801b192: 46bd         	mov	sp, r7
 801b194: bd80         	pop	{r7, pc}

0801b196 <z_impl_sensor_sample_fetch>:
; {
 801b196: b580         	push	{r7, lr}
 801b198: b084         	sub	sp, #0x10
 801b19a: af00         	add	r7, sp, #0x0
 801b19c: 6078         	str	r0, [r7, #0x4]
; 	const struct sensor_driver_api *api =
 801b19e: 687b         	ldr	r3, [r7, #0x4]
 801b1a0: 689b         	ldr	r3, [r3, #0x8]
 801b1a2: 60fb         	str	r3, [r7, #0xc]
; 	return api->sample_fetch(dev, SENSOR_CHAN_ALL);
 801b1a4: 68fb         	ldr	r3, [r7, #0xc]
 801b1a6: 68db         	ldr	r3, [r3, #0xc]
 801b1a8: 213c         	movs	r1, #0x3c
 801b1aa: 6878         	ldr	r0, [r7, #0x4]
 801b1ac: 4798         	blx	r3
 801b1ae: 4603         	mov	r3, r0
; }
 801b1b0: 4618         	mov	r0, r3
 801b1b2: 3710         	adds	r7, #0x10
 801b1b4: 46bd         	mov	sp, r7
 801b1b6: bd80         	pop	{r7, pc}

0801b1b8 <z_impl_sensor_channel_get>:
; {
 801b1b8: b580         	push	{r7, lr}
 801b1ba: b086         	sub	sp, #0x18
 801b1bc: af00         	add	r7, sp, #0x0
 801b1be: 60f8         	str	r0, [r7, #0xc]
 801b1c0: 460b         	mov	r3, r1
 801b1c2: 607a         	str	r2, [r7, #0x4]
 801b1c4: 817b         	strh	r3, [r7, #0xa]
; 	const struct sensor_driver_api *api =
 801b1c6: 68fb         	ldr	r3, [r7, #0xc]
 801b1c8: 689b         	ldr	r3, [r3, #0x8]
 801b1ca: 617b         	str	r3, [r7, #0x14]
; 	return api->channel_get(dev, chan, val);
 801b1cc: 697b         	ldr	r3, [r7, #0x14]
 801b1ce: 691b         	ldr	r3, [r3, #0x10]
 801b1d0: 8979         	ldrh	r1, [r7, #0xa]
 801b1d2: 687a         	ldr	r2, [r7, #0x4]
 801b1d4: 68f8         	ldr	r0, [r7, #0xc]
 801b1d6: 4798         	blx	r3
 801b1d8: 4603         	mov	r3, r0
; }
 801b1da: 4618         	mov	r0, r3
 801b1dc: 3718         	adds	r7, #0x18
 801b1de: 46bd         	mov	sp, r7
 801b1e0: bd80         	pop	{r7, pc}

0801b1e2 <sensor_sample_fetch>:
; {
 801b1e2: b580         	push	{r7, lr}
 801b1e4: b082         	sub	sp, #0x8
 801b1e6: af00         	add	r7, sp, #0x0
 801b1e8: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_sensor_sample_fetch(dev);
 801b1ea: 6878         	ldr	r0, [r7, #0x4]
 801b1ec: f7ff ffd3    	bl	0x801b196 <z_impl_sensor_sample_fetch> @ imm = #-0x5a
 801b1f0: 4603         	mov	r3, r0
; }
 801b1f2: 4618         	mov	r0, r3
 801b1f4: 3708         	adds	r7, #0x8
 801b1f6: 46bd         	mov	sp, r7
 801b1f8: bd80         	pop	{r7, pc}

0801b1fa <sensor_channel_get>:
; {
 801b1fa: b580         	push	{r7, lr}
 801b1fc: b084         	sub	sp, #0x10
 801b1fe: af00         	add	r7, sp, #0x0
 801b200: 60f8         	str	r0, [r7, #0xc]
 801b202: 460b         	mov	r3, r1
 801b204: 607a         	str	r2, [r7, #0x4]
 801b206: 817b         	strh	r3, [r7, #0xa]
; 	return z_impl_sensor_channel_get(dev, chan, val);
 801b208: 897b         	ldrh	r3, [r7, #0xa]
 801b20a: 687a         	ldr	r2, [r7, #0x4]
 801b20c: 4619         	mov	r1, r3
 801b20e: 68f8         	ldr	r0, [r7, #0xc]
 801b210: f7ff ffd2    	bl	0x801b1b8 <z_impl_sensor_channel_get> @ imm = #-0x5c
 801b214: 4603         	mov	r3, r0
; }
 801b216: 4618         	mov	r0, r3
 801b218: 3710         	adds	r7, #0x10
 801b21a: 46bd         	mov	sp, r7
 801b21c: bd80         	pop	{r7, pc}

0801b21e <Kalman_Filter_xhatMinusUpdate>:
; {
 801b21e: b580         	push	{r7, lr}
 801b220: b082         	sub	sp, #0x8
 801b222: af00         	add	r7, sp, #0x0
 801b224: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq1) {
 801b226: 687b         	ldr	r3, [r7, #0x4]
 801b228: f893 3028    	ldrb.w	r3, [r3, #0x28]
 801b22c: 2b00         	cmp	r3, #0x0
 801b22e: d158         	bne	0x801b2e2 <Kalman_Filter_xhatMinusUpdate+0xc4> @ imm = #0xb0
; 		if (kf->uSize > 0) {
 801b230: 687b         	ldr	r3, [r7, #0x4]
 801b232: 7b5b         	ldrb	r3, [r3, #0xd]
 801b234: 2b00         	cmp	r3, #0x0
 801b236: d044         	beq	0x801b2c2 <Kalman_Filter_xhatMinusUpdate+0xa4> @ imm = #0x88
; 			kf->temp_vector.numRows = kf->xhatSize;
 801b238: 687b         	ldr	r3, [r7, #0x4]
 801b23a: 7b1b         	ldrb	r3, [r3, #0xc]
 801b23c: 461a         	mov	r2, r3
 801b23e: 687b         	ldr	r3, [r7, #0x4]
 801b240: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 			kf->temp_vector.numCols = 1;
 801b244: 687b         	ldr	r3, [r7, #0x4]
 801b246: 2201         	movs	r2, #0x1
 801b248: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 			kf->MatStatus = Matrix_Multiply(&kf->F, &kf->xhat, &kf->temp_vector);
 801b24c: 687b         	ldr	r3, [r7, #0x4]
 801b24e: f103 0060    	add.w	r0, r3, #0x60
 801b252: 687b         	ldr	r3, [r7, #0x4]
 801b254: f103 0130    	add.w	r1, r3, #0x30
 801b258: 687b         	ldr	r3, [r7, #0x4]
 801b25a: 33b8         	adds	r3, #0xb8
 801b25c: 461a         	mov	r2, r3
 801b25e: f7f8 fa27    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7bb2
 801b262: 4603         	mov	r3, r0
 801b264: 461a         	mov	r2, r3
 801b266: 687b         	ldr	r3, [r7, #0x4]
 801b268: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 			kf->temp_vector1.numRows = kf->xhatSize;
 801b26c: 687b         	ldr	r3, [r7, #0x4]
 801b26e: 7b1b         	ldrb	r3, [r3, #0xc]
 801b270: 461a         	mov	r2, r3
 801b272: 687b         	ldr	r3, [r7, #0x4]
 801b274: f8a3 20c0    	strh.w	r2, [r3, #0xc0]
; 			kf->temp_vector1.numCols = 1;
 801b278: 687b         	ldr	r3, [r7, #0x4]
 801b27a: 2201         	movs	r2, #0x1
 801b27c: f8a3 20c2    	strh.w	r2, [r3, #0xc2]
; 			kf->MatStatus = Matrix_Multiply(&kf->B, &kf->u, &kf->temp_vector1);
 801b280: 687b         	ldr	r3, [r7, #0x4]
 801b282: f103 0070    	add.w	r0, r3, #0x70
 801b286: 687b         	ldr	r3, [r7, #0x4]
 801b288: f103 0140    	add.w	r1, r3, #0x40
 801b28c: 687b         	ldr	r3, [r7, #0x4]
 801b28e: 33c0         	adds	r3, #0xc0
 801b290: 461a         	mov	r2, r3
 801b292: f7f8 fa0d    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7be6
 801b296: 4603         	mov	r3, r0
 801b298: 461a         	mov	r2, r3
 801b29a: 687b         	ldr	r3, [r7, #0x4]
 801b29c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 				Matrix_Add(&kf->temp_vector, &kf->temp_vector1, &kf->xhatminus);
 801b2a0: 687b         	ldr	r3, [r7, #0x4]
 801b2a2: f103 00b8    	add.w	r0, r3, #0xb8
 801b2a6: 687b         	ldr	r3, [r7, #0x4]
 801b2a8: f103 01c0    	add.w	r1, r3, #0xc0
 801b2ac: 687b         	ldr	r3, [r7, #0x4]
 801b2ae: 3338         	adds	r3, #0x38
 801b2b0: 461a         	mov	r2, r3
 801b2b2: f7f8 f867    	bl	0x8013384 <arm_mat_add_f32> @ imm = #-0x7f32
 801b2b6: 4603         	mov	r3, r0
 801b2b8: 461a         	mov	r2, r3
; 			kf->MatStatus =
 801b2ba: 687b         	ldr	r3, [r7, #0x4]
 801b2bc: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801b2c0: e00f         	b	0x801b2e2 <Kalman_Filter_xhatMinusUpdate+0xc4> @ imm = #0x1e
; 			kf->MatStatus = Matrix_Multiply(&kf->F, &kf->xhat, &kf->xhatminus);
 801b2c2: 687b         	ldr	r3, [r7, #0x4]
 801b2c4: f103 0060    	add.w	r0, r3, #0x60
 801b2c8: 687b         	ldr	r3, [r7, #0x4]
 801b2ca: f103 0130    	add.w	r1, r3, #0x30
 801b2ce: 687b         	ldr	r3, [r7, #0x4]
 801b2d0: 3338         	adds	r3, #0x38
 801b2d2: 461a         	mov	r2, r3
 801b2d4: f7f8 f9ec    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7c28
 801b2d8: 4603         	mov	r3, r0
 801b2da: 461a         	mov	r2, r3
 801b2dc: 687b         	ldr	r3, [r7, #0x4]
 801b2de: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801b2e2: bf00         	nop
 801b2e4: 3708         	adds	r7, #0x8
 801b2e6: 46bd         	mov	sp, r7
 801b2e8: bd80         	pop	{r7, pc}

0801b2ea <Kalman_Filter_PminusUpdate>:
; {
 801b2ea: b580         	push	{r7, lr}
 801b2ec: b082         	sub	sp, #0x8
 801b2ee: af00         	add	r7, sp, #0x0
 801b2f0: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq2) {
 801b2f2: 687b         	ldr	r3, [r7, #0x4]
 801b2f4: f893 3029    	ldrb.w	r3, [r3, #0x29]
 801b2f8: 2b00         	cmp	r3, #0x0
 801b2fa: d149         	bne	0x801b390 <Kalman_Filter_PminusUpdate+0xa6> @ imm = #0x92
; 		kf->MatStatus = Matrix_Transpose(&kf->F, &kf->FT);
 801b2fc: 687b         	ldr	r3, [r7, #0x4]
 801b2fe: f103 0260    	add.w	r2, r3, #0x60
 801b302: 687b         	ldr	r3, [r7, #0x4]
 801b304: 3368         	adds	r3, #0x68
 801b306: 4619         	mov	r1, r3
 801b308: 4610         	mov	r0, r2
 801b30a: f7f8 fa57    	bl	0x80137bc <arm_mat_trans_f32> @ imm = #-0x7b52
 801b30e: 4603         	mov	r3, r0
 801b310: 461a         	mov	r2, r3
 801b312: 687b         	ldr	r3, [r7, #0x4]
 801b314: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Multiply(&kf->F, &kf->P, &kf->Pminus);
 801b318: 687b         	ldr	r3, [r7, #0x4]
 801b31a: f103 0060    	add.w	r0, r3, #0x60
 801b31e: 687b         	ldr	r3, [r7, #0x4]
 801b320: f103 0150    	add.w	r1, r3, #0x50
 801b324: 687b         	ldr	r3, [r7, #0x4]
 801b326: 3358         	adds	r3, #0x58
 801b328: 461a         	mov	r2, r3
 801b32a: f7f8 f9c1    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7c7e
 801b32e: 4603         	mov	r3, r0
 801b330: 461a         	mov	r2, r3
 801b332: 687b         	ldr	r3, [r7, #0x4]
 801b334: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix.numRows = kf->Pminus.numRows;
 801b338: 687b         	ldr	r3, [r7, #0x4]
 801b33a: f8b3 2058    	ldrh.w	r2, [r3, #0x58]
 801b33e: 687b         	ldr	r3, [r7, #0x4]
 801b340: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->FT.numCols;
 801b344: 687b         	ldr	r3, [r7, #0x4]
 801b346: f8b3 206a    	ldrh.w	r2, [r3, #0x6a]
 801b34a: 687b         	ldr	r3, [r7, #0x4]
 801b34c: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->MatStatus = Matrix_Multiply(&kf->Pminus, &kf->FT,
 801b350: 687b         	ldr	r3, [r7, #0x4]
 801b352: f103 0058    	add.w	r0, r3, #0x58
 801b356: 687b         	ldr	r3, [r7, #0x4]
 801b358: f103 0168    	add.w	r1, r3, #0x68
 801b35c: 687b         	ldr	r3, [r7, #0x4]
 801b35e: 33a8         	adds	r3, #0xa8
 801b360: 461a         	mov	r2, r3
 801b362: f7f8 f9a5    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7cb6
 801b366: 4603         	mov	r3, r0
 801b368: 461a         	mov	r2, r3
 801b36a: 687b         	ldr	r3, [r7, #0x4]
 801b36c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Add(&kf->temp_matrix, &kf->Q, &kf->Pminus);
 801b370: 687b         	ldr	r3, [r7, #0x4]
 801b372: f103 00a8    	add.w	r0, r3, #0xa8
 801b376: 687b         	ldr	r3, [r7, #0x4]
 801b378: f103 0188    	add.w	r1, r3, #0x88
 801b37c: 687b         	ldr	r3, [r7, #0x4]
 801b37e: 3358         	adds	r3, #0x58
 801b380: 461a         	mov	r2, r3
 801b382: f7f7 ffff    	bl	0x8013384 <arm_mat_add_f32> @ imm = #-0x8002
 801b386: 4603         	mov	r3, r0
 801b388: 461a         	mov	r2, r3
 801b38a: 687b         	ldr	r3, [r7, #0x4]
 801b38c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801b390: bf00         	nop
 801b392: 3708         	adds	r7, #0x8
 801b394: 46bd         	mov	sp, r7
 801b396: bd80         	pop	{r7, pc}

0801b398 <Kalman_Filter_SetK>:
; {
 801b398: b580         	push	{r7, lr}
 801b39a: b082         	sub	sp, #0x8
 801b39c: af00         	add	r7, sp, #0x0
 801b39e: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq3) {
 801b3a0: 687b         	ldr	r3, [r7, #0x4]
 801b3a2: f893 302a    	ldrb.w	r3, [r3, #0x2a]
 801b3a6: 2b00         	cmp	r3, #0x0
 801b3a8: f040 809c    	bne.w	0x801b4e4 <Kalman_Filter_SetK+0x14c> @ imm = #0x138
; 		kf->MatStatus = Matrix_Transpose(&kf->H, &kf->HT); // z|x => x|z
 801b3ac: 687b         	ldr	r3, [r7, #0x4]
 801b3ae: f103 0278    	add.w	r2, r3, #0x78
 801b3b2: 687b         	ldr	r3, [r7, #0x4]
 801b3b4: 3380         	adds	r3, #0x80
 801b3b6: 4619         	mov	r1, r3
 801b3b8: 4610         	mov	r0, r2
 801b3ba: f7f8 f9ff    	bl	0x80137bc <arm_mat_trans_f32> @ imm = #-0x7c02
 801b3be: 4603         	mov	r3, r0
 801b3c0: 461a         	mov	r2, r3
 801b3c2: 687b         	ldr	r3, [r7, #0x4]
 801b3c4: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix.numRows = kf->H.numRows;
 801b3c8: 687b         	ldr	r3, [r7, #0x4]
 801b3ca: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 801b3ce: 687b         	ldr	r3, [r7, #0x4]
 801b3d0: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->Pminus.numCols;
 801b3d4: 687b         	ldr	r3, [r7, #0x4]
 801b3d6: f8b3 205a    	ldrh.w	r2, [r3, #0x5a]
 801b3da: 687b         	ldr	r3, [r7, #0x4]
 801b3dc: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->MatStatus = Matrix_Multiply(&kf->H, &kf->Pminus,
 801b3e0: 687b         	ldr	r3, [r7, #0x4]
 801b3e2: f103 0078    	add.w	r0, r3, #0x78
 801b3e6: 687b         	ldr	r3, [r7, #0x4]
 801b3e8: f103 0158    	add.w	r1, r3, #0x58
 801b3ec: 687b         	ldr	r3, [r7, #0x4]
 801b3ee: 33a8         	adds	r3, #0xa8
 801b3f0: 461a         	mov	r2, r3
 801b3f2: f7f8 f95d    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7d46
 801b3f6: 4603         	mov	r3, r0
 801b3f8: 461a         	mov	r2, r3
 801b3fa: 687b         	ldr	r3, [r7, #0x4]
 801b3fc: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix1.numRows = kf->temp_matrix.numRows;
 801b400: 687b         	ldr	r3, [r7, #0x4]
 801b402: f8b3 20a8    	ldrh.w	r2, [r3, #0xa8]
 801b406: 687b         	ldr	r3, [r7, #0x4]
 801b408: f8a3 20b0    	strh.w	r2, [r3, #0xb0]
; 		kf->temp_matrix1.numCols = kf->HT.numCols;
 801b40c: 687b         	ldr	r3, [r7, #0x4]
 801b40e: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 801b412: 687b         	ldr	r3, [r7, #0x4]
 801b414: f8a3 20b2    	strh.w	r2, [r3, #0xb2]
; 		kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->HT,
 801b418: 687b         	ldr	r3, [r7, #0x4]
 801b41a: f103 00a8    	add.w	r0, r3, #0xa8
 801b41e: 687b         	ldr	r3, [r7, #0x4]
 801b420: f103 0180    	add.w	r1, r3, #0x80
 801b424: 687b         	ldr	r3, [r7, #0x4]
 801b426: 33b0         	adds	r3, #0xb0
 801b428: 461a         	mov	r2, r3
 801b42a: f7f8 f941    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7d7e
 801b42e: 4603         	mov	r3, r0
 801b430: 461a         	mov	r2, r3
 801b432: 687b         	ldr	r3, [r7, #0x4]
 801b434: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->S.numRows = kf->R.numRows;
 801b438: 687b         	ldr	r3, [r7, #0x4]
 801b43a: f8b3 2090    	ldrh.w	r2, [r3, #0x90]
 801b43e: 687b         	ldr	r3, [r7, #0x4]
 801b440: f8a3 20a0    	strh.w	r2, [r3, #0xa0]
; 		kf->S.numCols = kf->R.numCols;
 801b444: 687b         	ldr	r3, [r7, #0x4]
 801b446: f8b3 2092    	ldrh.w	r2, [r3, #0x92]
 801b44a: 687b         	ldr	r3, [r7, #0x4]
 801b44c: f8a3 20a2    	strh.w	r2, [r3, #0xa2]
; 		kf->MatStatus = Matrix_Add(&kf->temp_matrix1, &kf->R, &kf->S); // S = H P'(k) HT + R
 801b450: 687b         	ldr	r3, [r7, #0x4]
 801b452: f103 00b0    	add.w	r0, r3, #0xb0
 801b456: 687b         	ldr	r3, [r7, #0x4]
 801b458: f103 0190    	add.w	r1, r3, #0x90
 801b45c: 687b         	ldr	r3, [r7, #0x4]
 801b45e: 33a0         	adds	r3, #0xa0
 801b460: 461a         	mov	r2, r3
 801b462: f7f7 ff8f    	bl	0x8013384 <arm_mat_add_f32> @ imm = #-0x80e2
 801b466: 4603         	mov	r3, r0
 801b468: 461a         	mov	r2, r3
 801b46a: 687b         	ldr	r3, [r7, #0x4]
 801b46c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 			&kf->S, &kf->temp_matrix1); // temp_matrix1 = inv(H·P'(k)·HT + R)
 801b470: 687b         	ldr	r3, [r7, #0x4]
 801b472: f103 02a0    	add.w	r2, r3, #0xa0
; 		kf->MatStatus = Matrix_Inverse(
 801b476: 687b         	ldr	r3, [r7, #0x4]
 801b478: 33b0         	adds	r3, #0xb0
 801b47a: 4619         	mov	r1, r3
 801b47c: 4610         	mov	r0, r2
 801b47e: f7f7 ff9d    	bl	0x80133bc <arm_mat_inverse_f32> @ imm = #-0x80c6
 801b482: 4603         	mov	r3, r0
 801b484: 461a         	mov	r2, r3
 801b486: 687b         	ldr	r3, [r7, #0x4]
 801b488: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix.numRows = kf->Pminus.numRows;
 801b48c: 687b         	ldr	r3, [r7, #0x4]
 801b48e: f8b3 2058    	ldrh.w	r2, [r3, #0x58]
 801b492: 687b         	ldr	r3, [r7, #0x4]
 801b494: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->HT.numCols;
 801b498: 687b         	ldr	r3, [r7, #0x4]
 801b49a: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 801b49e: 687b         	ldr	r3, [r7, #0x4]
 801b4a0: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->MatStatus = Matrix_Multiply(&kf->Pminus, &kf->HT,
 801b4a4: 687b         	ldr	r3, [r7, #0x4]
 801b4a6: f103 0058    	add.w	r0, r3, #0x58
 801b4aa: 687b         	ldr	r3, [r7, #0x4]
 801b4ac: f103 0180    	add.w	r1, r3, #0x80
 801b4b0: 687b         	ldr	r3, [r7, #0x4]
 801b4b2: 33a8         	adds	r3, #0xa8
 801b4b4: 461a         	mov	r2, r3
 801b4b6: f7f8 f8fb    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7e0a
 801b4ba: 4603         	mov	r3, r0
 801b4bc: 461a         	mov	r2, r3
 801b4be: 687b         	ldr	r3, [r7, #0x4]
 801b4c0: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->temp_matrix1, &kf->K);
 801b4c4: 687b         	ldr	r3, [r7, #0x4]
 801b4c6: f103 00a8    	add.w	r0, r3, #0xa8
 801b4ca: 687b         	ldr	r3, [r7, #0x4]
 801b4cc: f103 01b0    	add.w	r1, r3, #0xb0
 801b4d0: 687b         	ldr	r3, [r7, #0x4]
 801b4d2: 3398         	adds	r3, #0x98
 801b4d4: 461a         	mov	r2, r3
 801b4d6: f7f8 f8eb    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7e2a
 801b4da: 4603         	mov	r3, r0
 801b4dc: 461a         	mov	r2, r3
 801b4de: 687b         	ldr	r3, [r7, #0x4]
 801b4e0: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801b4e4: bf00         	nop
 801b4e6: 3708         	adds	r7, #0x8
 801b4e8: 46bd         	mov	sp, r7
 801b4ea: bd80         	pop	{r7, pc}

0801b4ec <Kalman_Filter_xhatUpdate>:
; {
 801b4ec: b580         	push	{r7, lr}
 801b4ee: b082         	sub	sp, #0x8
 801b4f0: af00         	add	r7, sp, #0x0
 801b4f2: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq4) {
 801b4f4: 687b         	ldr	r3, [r7, #0x4]
 801b4f6: f893 302b    	ldrb.w	r3, [r3, #0x2b]
 801b4fa: 2b00         	cmp	r3, #0x0
 801b4fc: d15d         	bne	0x801b5ba <Kalman_Filter_xhatUpdate+0xce> @ imm = #0xba
; 		kf->temp_vector.numRows = kf->H.numRows;
 801b4fe: 687b         	ldr	r3, [r7, #0x4]
 801b500: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 801b504: 687b         	ldr	r3, [r7, #0x4]
 801b506: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 		kf->temp_vector.numCols = 1;
 801b50a: 687b         	ldr	r3, [r7, #0x4]
 801b50c: 2201         	movs	r2, #0x1
 801b50e: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 		kf->MatStatus = Matrix_Multiply(&kf->H, &kf->xhatminus,
 801b512: 687b         	ldr	r3, [r7, #0x4]
 801b514: f103 0078    	add.w	r0, r3, #0x78
 801b518: 687b         	ldr	r3, [r7, #0x4]
 801b51a: f103 0138    	add.w	r1, r3, #0x38
 801b51e: 687b         	ldr	r3, [r7, #0x4]
 801b520: 33b8         	adds	r3, #0xb8
 801b522: 461a         	mov	r2, r3
 801b524: f7f8 f8c4    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7e78
 801b528: 4603         	mov	r3, r0
 801b52a: 461a         	mov	r2, r3
 801b52c: 687b         	ldr	r3, [r7, #0x4]
 801b52e: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_vector1.numRows = kf->z.numRows;
 801b532: 687b         	ldr	r3, [r7, #0x4]
 801b534: f8b3 2048    	ldrh.w	r2, [r3, #0x48]
 801b538: 687b         	ldr	r3, [r7, #0x4]
 801b53a: f8a3 20c0    	strh.w	r2, [r3, #0xc0]
; 		kf->temp_vector1.numCols = 1;
 801b53e: 687b         	ldr	r3, [r7, #0x4]
 801b540: 2201         	movs	r2, #0x1
 801b542: f8a3 20c2    	strh.w	r2, [r3, #0xc2]
; 			Matrix_Subtract(&kf->z, &kf->temp_vector,
 801b546: 687b         	ldr	r3, [r7, #0x4]
 801b548: f103 0048    	add.w	r0, r3, #0x48
 801b54c: 687b         	ldr	r3, [r7, #0x4]
 801b54e: f103 01b8    	add.w	r1, r3, #0xb8
 801b552: 687b         	ldr	r3, [r7, #0x4]
 801b554: 33c0         	adds	r3, #0xc0
 801b556: 461a         	mov	r2, r3
 801b558: f7f8 f918    	bl	0x801378c <arm_mat_sub_f32> @ imm = #-0x7dd0
 801b55c: 4603         	mov	r3, r0
 801b55e: 461a         	mov	r2, r3
; 		kf->MatStatus =
 801b560: 687b         	ldr	r3, [r7, #0x4]
 801b562: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_vector.numRows = kf->K.numRows;
 801b566: 687b         	ldr	r3, [r7, #0x4]
 801b568: f8b3 2098    	ldrh.w	r2, [r3, #0x98]
 801b56c: 687b         	ldr	r3, [r7, #0x4]
 801b56e: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 		kf->temp_vector.numCols = 1;
 801b572: 687b         	ldr	r3, [r7, #0x4]
 801b574: 2201         	movs	r2, #0x1
 801b576: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 			Matrix_Multiply(&kf->K, &kf->temp_vector1,
 801b57a: 687b         	ldr	r3, [r7, #0x4]
 801b57c: f103 0098    	add.w	r0, r3, #0x98
 801b580: 687b         	ldr	r3, [r7, #0x4]
 801b582: f103 01c0    	add.w	r1, r3, #0xc0
 801b586: 687b         	ldr	r3, [r7, #0x4]
 801b588: 33b8         	adds	r3, #0xb8
 801b58a: 461a         	mov	r2, r3
 801b58c: f7f8 f890    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7ee0
 801b590: 4603         	mov	r3, r0
 801b592: 461a         	mov	r2, r3
; 		kf->MatStatus =
 801b594: 687b         	ldr	r3, [r7, #0x4]
 801b596: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Add(&kf->xhatminus, &kf->temp_vector, &kf->xhat);
 801b59a: 687b         	ldr	r3, [r7, #0x4]
 801b59c: f103 0038    	add.w	r0, r3, #0x38
 801b5a0: 687b         	ldr	r3, [r7, #0x4]
 801b5a2: f103 01b8    	add.w	r1, r3, #0xb8
 801b5a6: 687b         	ldr	r3, [r7, #0x4]
 801b5a8: 3330         	adds	r3, #0x30
 801b5aa: 461a         	mov	r2, r3
 801b5ac: f7f7 feea    	bl	0x8013384 <arm_mat_add_f32> @ imm = #-0x822c
 801b5b0: 4603         	mov	r3, r0
 801b5b2: 461a         	mov	r2, r3
 801b5b4: 687b         	ldr	r3, [r7, #0x4]
 801b5b6: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801b5ba: bf00         	nop
 801b5bc: 3708         	adds	r7, #0x8
 801b5be: 46bd         	mov	sp, r7
 801b5c0: bd80         	pop	{r7, pc}

0801b5c2 <Kalman_Filter_P_Update>:
; {
 801b5c2: b580         	push	{r7, lr}
 801b5c4: b082         	sub	sp, #0x8
 801b5c6: af00         	add	r7, sp, #0x0
 801b5c8: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq5) {
 801b5ca: 687b         	ldr	r3, [r7, #0x4]
 801b5cc: f893 302c    	ldrb.w	r3, [r3, #0x2c]
 801b5d0: 2b00         	cmp	r3, #0x0
 801b5d2: d147         	bne	0x801b664 <Kalman_Filter_P_Update+0xa2> @ imm = #0x8e
; 		kf->temp_matrix.numRows = kf->K.numRows;
 801b5d4: 687b         	ldr	r3, [r7, #0x4]
 801b5d6: f8b3 2098    	ldrh.w	r2, [r3, #0x98]
 801b5da: 687b         	ldr	r3, [r7, #0x4]
 801b5dc: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->H.numCols;
 801b5e0: 687b         	ldr	r3, [r7, #0x4]
 801b5e2: f8b3 207a    	ldrh.w	r2, [r3, #0x7a]
 801b5e6: 687b         	ldr	r3, [r7, #0x4]
 801b5e8: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->temp_matrix1.numRows = kf->temp_matrix.numRows;
 801b5ec: 687b         	ldr	r3, [r7, #0x4]
 801b5ee: f8b3 20a8    	ldrh.w	r2, [r3, #0xa8]
 801b5f2: 687b         	ldr	r3, [r7, #0x4]
 801b5f4: f8a3 20b0    	strh.w	r2, [r3, #0xb0]
; 		kf->temp_matrix1.numCols = kf->Pminus.numCols;
 801b5f8: 687b         	ldr	r3, [r7, #0x4]
 801b5fa: f8b3 205a    	ldrh.w	r2, [r3, #0x5a]
 801b5fe: 687b         	ldr	r3, [r7, #0x4]
 801b600: f8a3 20b2    	strh.w	r2, [r3, #0xb2]
; 			Matrix_Multiply(&kf->K, &kf->H, &kf->temp_matrix); // temp_matrix = K(k)·H
 801b604: 687b         	ldr	r3, [r7, #0x4]
 801b606: f103 0098    	add.w	r0, r3, #0x98
 801b60a: 687b         	ldr	r3, [r7, #0x4]
 801b60c: f103 0178    	add.w	r1, r3, #0x78
 801b610: 687b         	ldr	r3, [r7, #0x4]
 801b612: 33a8         	adds	r3, #0xa8
 801b614: 461a         	mov	r2, r3
 801b616: f7f8 f84b    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7f6a
 801b61a: 4603         	mov	r3, r0
 801b61c: 461a         	mov	r2, r3
; 		kf->MatStatus =
 801b61e: 687b         	ldr	r3, [r7, #0x4]
 801b620: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->Pminus,
 801b624: 687b         	ldr	r3, [r7, #0x4]
 801b626: f103 00a8    	add.w	r0, r3, #0xa8
 801b62a: 687b         	ldr	r3, [r7, #0x4]
 801b62c: f103 0158    	add.w	r1, r3, #0x58
 801b630: 687b         	ldr	r3, [r7, #0x4]
 801b632: 33b0         	adds	r3, #0xb0
 801b634: 461a         	mov	r2, r3
 801b636: f7f8 f83b    	bl	0x80136b0 <arm_mat_mult_f32> @ imm = #-0x7f8a
 801b63a: 4603         	mov	r3, r0
 801b63c: 461a         	mov	r2, r3
 801b63e: 687b         	ldr	r3, [r7, #0x4]
 801b640: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Subtract(&kf->Pminus, &kf->temp_matrix1, &kf->P);
 801b644: 687b         	ldr	r3, [r7, #0x4]
 801b646: f103 0058    	add.w	r0, r3, #0x58
 801b64a: 687b         	ldr	r3, [r7, #0x4]
 801b64c: f103 01b0    	add.w	r1, r3, #0xb0
 801b650: 687b         	ldr	r3, [r7, #0x4]
 801b652: 3350         	adds	r3, #0x50
 801b654: 461a         	mov	r2, r3
 801b656: f7f8 f899    	bl	0x801378c <arm_mat_sub_f32> @ imm = #-0x7ece
 801b65a: 4603         	mov	r3, r0
 801b65c: 461a         	mov	r2, r3
 801b65e: 687b         	ldr	r3, [r7, #0x4]
 801b660: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801b664: bf00         	nop
 801b666: 3708         	adds	r7, #0x8
 801b668: 46bd         	mov	sp, r7
 801b66a: bd80         	pop	{r7, pc}

0801b66c <Norm3d>:
; {
 801b66c: b580         	push	{r7, lr}
 801b66e: b084         	sub	sp, #0x10
 801b670: af00         	add	r7, sp, #0x0
 801b672: 6078         	str	r0, [r7, #0x4]
; 	float len = Sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
 801b674: 687b         	ldr	r3, [r7, #0x4]
 801b676: ed93 7a00    	<unknown>
 801b67a: 687b         	ldr	r3, [r7, #0x4]
 801b67c: edd3 7a00    	<unknown>
 801b680: ee27 7a27    	<unknown>
 801b684: 687b         	ldr	r3, [r7, #0x4]
 801b686: 3304         	adds	r3, #0x4
 801b688: edd3 6a00    	<unknown>
 801b68c: 687b         	ldr	r3, [r7, #0x4]
 801b68e: 3304         	adds	r3, #0x4
 801b690: edd3 7a00    	<unknown>
 801b694: ee66 7aa7    	<unknown>
 801b698: ee37 7a27    	<unknown>
 801b69c: 687b         	ldr	r3, [r7, #0x4]
 801b69e: 3308         	adds	r3, #0x8
 801b6a0: edd3 6a00    	<unknown>
 801b6a4: 687b         	ldr	r3, [r7, #0x4]
 801b6a6: 3308         	adds	r3, #0x8
 801b6a8: edd3 7a00    	<unknown>
 801b6ac: ee66 7aa7    	<unknown>
 801b6b0: ee77 7a27    	<unknown>
 801b6b4: eeb0 0a67    	<unknown>
 801b6b8: f7e7 fb90    	bl	0x8002ddc <Sqrt>        @ imm = #-0x188e0
 801b6bc: ed87 0a03    	<unknown>
; 	v[0] /= len;
 801b6c0: 687b         	ldr	r3, [r7, #0x4]
 801b6c2: edd3 6a00    	<unknown>
 801b6c6: ed97 7a03    	<unknown>
 801b6ca: eec6 7a87    	<unknown>
 801b6ce: 687b         	ldr	r3, [r7, #0x4]
 801b6d0: edc3 7a00    	<unknown>
; 	v[1] /= len;
 801b6d4: 687b         	ldr	r3, [r7, #0x4]
 801b6d6: 3304         	adds	r3, #0x4
 801b6d8: edd3 6a00    	<unknown>
 801b6dc: 687b         	ldr	r3, [r7, #0x4]
 801b6de: 3304         	adds	r3, #0x4
 801b6e0: ed97 7a03    	<unknown>
 801b6e4: eec6 7a87    	<unknown>
 801b6e8: edc3 7a00    	<unknown>
; 	v[2] /= len;
 801b6ec: 687b         	ldr	r3, [r7, #0x4]
 801b6ee: 3308         	adds	r3, #0x8
 801b6f0: edd3 6a00    	<unknown>
 801b6f4: 687b         	ldr	r3, [r7, #0x4]
 801b6f6: 3308         	adds	r3, #0x8
 801b6f8: ed97 7a03    	<unknown>
 801b6fc: eec6 7a87    	<unknown>
 801b700: edc3 7a00    	<unknown>
; 	return v;
 801b704: 687b         	ldr	r3, [r7, #0x4]
; }
 801b706: 4618         	mov	r0, r3
 801b708: 3710         	adds	r7, #0x10
 801b70a: 46bd         	mov	sp, r7
 801b70c: bd80         	pop	{r7, pc}

0801b70e <Cross3d>:
; {
 801b70e: b480         	push	{r7}
 801b710: b085         	sub	sp, #0x14
 801b712: af00         	add	r7, sp, #0x0
 801b714: 60f8         	str	r0, [r7, #0xc]
 801b716: 60b9         	str	r1, [r7, #0x8]
 801b718: 607a         	str	r2, [r7, #0x4]
; 	res[0] = v1[1] * v2[2] - v1[2] * v2[1];
 801b71a: 68fb         	ldr	r3, [r7, #0xc]
 801b71c: 3304         	adds	r3, #0x4
 801b71e: ed93 7a00    	<unknown>
 801b722: 68bb         	ldr	r3, [r7, #0x8]
 801b724: 3308         	adds	r3, #0x8
 801b726: edd3 7a00    	<unknown>
 801b72a: ee27 7a27    	<unknown>
 801b72e: 68fb         	ldr	r3, [r7, #0xc]
 801b730: 3308         	adds	r3, #0x8
 801b732: edd3 6a00    	<unknown>
 801b736: 68bb         	ldr	r3, [r7, #0x8]
 801b738: 3304         	adds	r3, #0x4
 801b73a: edd3 7a00    	<unknown>
 801b73e: ee66 7aa7    	<unknown>
 801b742: ee77 7a67    	<unknown>
 801b746: 687b         	ldr	r3, [r7, #0x4]
 801b748: edc3 7a00    	<unknown>
; 	res[1] = v1[2] * v2[0] - v1[0] * v2[2];
 801b74c: 68fb         	ldr	r3, [r7, #0xc]
 801b74e: 3308         	adds	r3, #0x8
 801b750: ed93 7a00    	<unknown>
 801b754: 68bb         	ldr	r3, [r7, #0x8]
 801b756: edd3 7a00    	<unknown>
 801b75a: ee27 7a27    	<unknown>
 801b75e: 68fb         	ldr	r3, [r7, #0xc]
 801b760: edd3 6a00    	<unknown>
 801b764: 68bb         	ldr	r3, [r7, #0x8]
 801b766: 3308         	adds	r3, #0x8
 801b768: edd3 7a00    	<unknown>
 801b76c: ee66 7aa7    	<unknown>
 801b770: 687b         	ldr	r3, [r7, #0x4]
 801b772: 3304         	adds	r3, #0x4
 801b774: ee77 7a67    	<unknown>
 801b778: edc3 7a00    	<unknown>
; 	res[2] = v1[0] * v2[1] - v1[1] * v2[0];
 801b77c: 68fb         	ldr	r3, [r7, #0xc]
 801b77e: ed93 7a00    	<unknown>
 801b782: 68bb         	ldr	r3, [r7, #0x8]
 801b784: 3304         	adds	r3, #0x4
 801b786: edd3 7a00    	<unknown>
 801b78a: ee27 7a27    	<unknown>
 801b78e: 68fb         	ldr	r3, [r7, #0xc]
 801b790: 3304         	adds	r3, #0x4
 801b792: edd3 6a00    	<unknown>
 801b796: 68bb         	ldr	r3, [r7, #0x8]
 801b798: edd3 7a00    	<unknown>
 801b79c: ee66 7aa7    	<unknown>
 801b7a0: 687b         	ldr	r3, [r7, #0x4]
 801b7a2: 3308         	adds	r3, #0x8
 801b7a4: ee77 7a67    	<unknown>
 801b7a8: edc3 7a00    	<unknown>
; }
 801b7ac: bf00         	nop
 801b7ae: 3714         	adds	r7, #0x14
 801b7b0: 46bd         	mov	sp, r7
 801b7b2: f85d 7b04    	ldr	r7, [sp], #4
 801b7b6: 4770         	bx	lr

0801b7b8 <Dot3d>:
; {
 801b7b8: b480         	push	{r7}
 801b7ba: b083         	sub	sp, #0xc
 801b7bc: af00         	add	r7, sp, #0x0
 801b7be: 6078         	str	r0, [r7, #0x4]
 801b7c0: 6039         	str	r1, [r7]
; 	return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
 801b7c2: 687b         	ldr	r3, [r7, #0x4]
 801b7c4: ed93 7a00    	<unknown>
 801b7c8: 683b         	ldr	r3, [r7]
 801b7ca: edd3 7a00    	<unknown>
 801b7ce: ee27 7a27    	<unknown>
 801b7d2: 687b         	ldr	r3, [r7, #0x4]
 801b7d4: 3304         	adds	r3, #0x4
 801b7d6: edd3 6a00    	<unknown>
 801b7da: 683b         	ldr	r3, [r7]
 801b7dc: 3304         	adds	r3, #0x4
 801b7de: edd3 7a00    	<unknown>
 801b7e2: ee66 7aa7    	<unknown>
 801b7e6: ee37 7a27    	<unknown>
 801b7ea: 687b         	ldr	r3, [r7, #0x4]
 801b7ec: 3308         	adds	r3, #0x8
 801b7ee: edd3 6a00    	<unknown>
 801b7f2: 683b         	ldr	r3, [r7]
 801b7f4: 3308         	adds	r3, #0x8
 801b7f6: edd3 7a00    	<unknown>
 801b7fa: ee66 7aa7    	<unknown>
 801b7fe: ee77 7a27    	<unknown>
; }
 801b802: eeb0 0a67    	<unknown>
 801b806: 370c         	adds	r7, #0xc
 801b808: 46bd         	mov	sp, r7
 801b80a: f85d 7b04    	ldr	r7, [sp], #4
 801b80e: 4770         	bx	lr

0801b810 <z_impl_uart_tx>:
; {
 801b810: b590         	push	{r4, r7, lr}
 801b812: b087         	sub	sp, #0x1c
 801b814: af00         	add	r7, sp, #0x0
 801b816: 60f8         	str	r0, [r7, #0xc]
 801b818: 60b9         	str	r1, [r7, #0x8]
 801b81a: 607a         	str	r2, [r7, #0x4]
 801b81c: 603b         	str	r3, [r7]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 801b81e: 68fb         	ldr	r3, [r7, #0xc]
 801b820: 689b         	ldr	r3, [r3, #0x8]
 801b822: 617b         	str	r3, [r7, #0x14]
; 	return api->tx(dev, buf, len, timeout);
 801b824: 697b         	ldr	r3, [r7, #0x14]
 801b826: 685c         	ldr	r4, [r3, #0x4]
 801b828: 683b         	ldr	r3, [r7]
 801b82a: 687a         	ldr	r2, [r7, #0x4]
 801b82c: 68b9         	ldr	r1, [r7, #0x8]
 801b82e: 68f8         	ldr	r0, [r7, #0xc]
 801b830: 47a0         	blx	r4
 801b832: 4603         	mov	r3, r0
; }
 801b834: 4618         	mov	r0, r3
 801b836: 371c         	adds	r7, #0x1c
 801b838: 46bd         	mov	sp, r7
 801b83a: bd90         	pop	{r4, r7, pc}

0801b83c <uart_tx>:
; {
 801b83c: b580         	push	{r7, lr}
 801b83e: b084         	sub	sp, #0x10
 801b840: af00         	add	r7, sp, #0x0
 801b842: 60f8         	str	r0, [r7, #0xc]
 801b844: 60b9         	str	r1, [r7, #0x8]
 801b846: 607a         	str	r2, [r7, #0x4]
 801b848: 603b         	str	r3, [r7]
; 	return z_impl_uart_tx(dev, buf, len, timeout);
 801b84a: 683b         	ldr	r3, [r7]
 801b84c: 687a         	ldr	r2, [r7, #0x4]
 801b84e: 68b9         	ldr	r1, [r7, #0x8]
 801b850: 68f8         	ldr	r0, [r7, #0xc]
 801b852: f7ff ffdd    	bl	0x801b810 <z_impl_uart_tx> @ imm = #-0x46
 801b856: 4603         	mov	r3, r0
; }
 801b858: 4618         	mov	r0, r3
 801b85a: 3710         	adds	r7, #0x10
 801b85c: 46bd         	mov	sp, r7
 801b85e: bd80         	pop	{r7, pc}

0801b860 <console_feedback>:
; {
 801b860: b580         	push	{r7, lr}
 801b862: b084         	sub	sp, #0x10
 801b864: af00         	add	r7, sp, #0x0
 801b866: 60f8         	str	r0, [r7, #0xc]
 801b868: 60b9         	str	r1, [r7, #0x8]
 801b86a: 607a         	str	r2, [r7, #0x4]
; 		thread_analyzer_print(NULL);
 801b86c: 2000         	movs	r0, #0x0
 801b86e: f7e8 ff21    	bl	0x80046b4 <thread_analyzer_print> @ imm = #-0x171be
; 		k_msleep(500);
 801b872: f44f 70fa    	mov.w	r0, #0x1f4
 801b876: f7ff fb6d    	bl	0x801af54 <k_msleep>    @ imm = #-0x926
; 		thread_analyzer_print(NULL);
 801b87a: bf00         	nop
 801b87c: e7f6         	b	0x801b86c <console_feedback+0xc> @ imm = #-0x14

0801b87e <z_impl_motor_set_speed>:
; static inline int z_impl_motor_set_speed(const struct device *dev, float speed_rpm) {
 801b87e: b580         	push	{r7, lr}
 801b880: b084         	sub	sp, #0x10
 801b882: af00         	add	r7, sp, #0x0
 801b884: 6078         	str	r0, [r7, #0x4]
 801b886: ed87 0a00    	<unknown>
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 801b88a: 687b         	ldr	r3, [r7, #0x4]
 801b88c: 689b         	ldr	r3, [r3, #0x8]
 801b88e: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_set_speed == NULL) {
 801b890: 68fb         	ldr	r3, [r7, #0xc]
 801b892: 68db         	ldr	r3, [r3, #0xc]
 801b894: 2b00         	cmp	r3, #0x0
 801b896: d102         	bne	0x801b89e <z_impl_motor_set_speed+0x20> @ imm = #0x4
;         return -ENOSYS;
 801b898: f06f 0357    	mvn	r3, #0x57
 801b89c: e006         	b	0x801b8ac <z_impl_motor_set_speed+0x2e> @ imm = #0xc
;     return api->motor_set_speed(dev, speed_rpm);
 801b89e: 68fb         	ldr	r3, [r7, #0xc]
 801b8a0: 68db         	ldr	r3, [r3, #0xc]
 801b8a2: ed97 0a00    	<unknown>
 801b8a6: 6878         	ldr	r0, [r7, #0x4]
 801b8a8: 4798         	blx	r3
 801b8aa: 4603         	mov	r3, r0
; }
 801b8ac: 4618         	mov	r0, r3
 801b8ae: 3710         	adds	r7, #0x10
 801b8b0: 46bd         	mov	sp, r7
 801b8b2: bd80         	pop	{r7, pc}

0801b8b4 <z_impl_motor_set_angle>:
; static inline int z_impl_motor_set_angle(const struct device *dev, float angle) {
 801b8b4: b580         	push	{r7, lr}
 801b8b6: b084         	sub	sp, #0x10
 801b8b8: af00         	add	r7, sp, #0x0
 801b8ba: 6078         	str	r0, [r7, #0x4]
 801b8bc: ed87 0a00    	<unknown>
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 801b8c0: 687b         	ldr	r3, [r7, #0x4]
 801b8c2: 689b         	ldr	r3, [r3, #0x8]
 801b8c4: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_set_angle == NULL) {
 801b8c6: 68fb         	ldr	r3, [r7, #0xc]
 801b8c8: 695b         	ldr	r3, [r3, #0x14]
 801b8ca: 2b00         	cmp	r3, #0x0
 801b8cc: d102         	bne	0x801b8d4 <z_impl_motor_set_angle+0x20> @ imm = #0x4
;         return -ENOSYS;
 801b8ce: f06f 0357    	mvn	r3, #0x57
 801b8d2: e006         	b	0x801b8e2 <z_impl_motor_set_angle+0x2e> @ imm = #0xc
;     return api->motor_set_angle(dev, angle);
 801b8d4: 68fb         	ldr	r3, [r7, #0xc]
 801b8d6: 695b         	ldr	r3, [r3, #0x14]
 801b8d8: ed97 0a00    	<unknown>
 801b8dc: 6878         	ldr	r0, [r7, #0x4]
 801b8de: 4798         	blx	r3
 801b8e0: 4603         	mov	r3, r0
; }
 801b8e2: 4618         	mov	r0, r3
 801b8e4: 3710         	adds	r7, #0x10
 801b8e6: 46bd         	mov	sp, r7
 801b8e8: bd80         	pop	{r7, pc}

0801b8ea <motor_get_angle>:
; {
 801b8ea: b580         	push	{r7, lr}
 801b8ec: b082         	sub	sp, #0x8
 801b8ee: af00         	add	r7, sp, #0x0
 801b8f0: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_motor_get_angle(dev);
 801b8f2: 6878         	ldr	r0, [r7, #0x4]
 801b8f4: f7e8 f816    	bl	0x8003924 <z_impl_motor_get_angle> @ imm = #-0x17fd4
 801b8f8: eef0 7a40    	<unknown>
; }
 801b8fc: eeb0 0a67    	<unknown>
 801b900: 3708         	adds	r7, #0x8
 801b902: 46bd         	mov	sp, r7
 801b904: bd80         	pop	{r7, pc}

0801b906 <motor_set_speed>:
; {
 801b906: b580         	push	{r7, lr}
 801b908: b082         	sub	sp, #0x8
 801b90a: af00         	add	r7, sp, #0x0
 801b90c: 6078         	str	r0, [r7, #0x4]
 801b90e: ed87 0a00    	<unknown>
; 	return z_impl_motor_set_speed(dev, speed_rpm);
 801b912: ed97 0a00    	<unknown>
 801b916: 6878         	ldr	r0, [r7, #0x4]
 801b918: f7ff ffb1    	bl	0x801b87e <z_impl_motor_set_speed> @ imm = #-0x9e
 801b91c: 4603         	mov	r3, r0
; }
 801b91e: 4618         	mov	r0, r3
 801b920: 3708         	adds	r7, #0x8
 801b922: 46bd         	mov	sp, r7
 801b924: bd80         	pop	{r7, pc}

0801b926 <motor_set_angle>:
; {
 801b926: b580         	push	{r7, lr}
 801b928: b082         	sub	sp, #0x8
 801b92a: af00         	add	r7, sp, #0x0
 801b92c: 6078         	str	r0, [r7, #0x4]
 801b92e: ed87 0a00    	<unknown>
; 	return z_impl_motor_set_angle(dev, angle);
 801b932: ed97 0a00    	<unknown>
 801b936: 6878         	ldr	r0, [r7, #0x4]
 801b938: f7ff ffbc    	bl	0x801b8b4 <z_impl_motor_set_angle> @ imm = #-0x88
 801b93c: 4603         	mov	r3, r0
; }
 801b93e: 4618         	mov	r0, r3
 801b940: 3708         	adds	r7, #0x8
 801b942: 46bd         	mov	sp, r7
 801b944: bd80         	pop	{r7, pc}

0801b946 <big_heap_chunks>:
; {
 801b946: b480         	push	{r7}
 801b948: b083         	sub	sp, #0xc
 801b94a: af00         	add	r7, sp, #0x0
 801b94c: 6078         	str	r0, [r7, #0x4]
; 	return chunks > 0x7fffU;
 801b94e: 687b         	ldr	r3, [r7, #0x4]
 801b950: f647 72ff    	movw	r2, #0x7fff
 801b954: 4293         	cmp	r3, r2
 801b956: bf8c         	ite	hi
 801b958: 2301         	movhi	r3, #0x1
 801b95a: 2300         	movls	r3, #0x0
 801b95c: b2db         	uxtb	r3, r3
; }
 801b95e: 4618         	mov	r0, r3
 801b960: 370c         	adds	r7, #0xc
 801b962: 46bd         	mov	sp, r7
 801b964: f85d 7b04    	ldr	r7, [sp], #4
 801b968: 4770         	bx	lr

0801b96a <big_heap_bytes>:
; {
 801b96a: b580         	push	{r7, lr}
 801b96c: b082         	sub	sp, #0x8
 801b96e: af00         	add	r7, sp, #0x0
 801b970: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(bytes / CHUNK_UNIT);
 801b972: 687b         	ldr	r3, [r7, #0x4]
 801b974: 08db         	lsrs	r3, r3, #0x3
 801b976: 4618         	mov	r0, r3
 801b978: f7ff ffe5    	bl	0x801b946 <big_heap_chunks> @ imm = #-0x36
 801b97c: 4603         	mov	r3, r0
; }
 801b97e: 4618         	mov	r0, r3
 801b980: 3708         	adds	r7, #0x8
 801b982: 46bd         	mov	sp, r7
 801b984: bd80         	pop	{r7, pc}

0801b986 <big_heap>:
; {
 801b986: b580         	push	{r7, lr}
 801b988: b082         	sub	sp, #0x8
 801b98a: af00         	add	r7, sp, #0x0
 801b98c: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(h->end_chunk);
 801b98e: 687b         	ldr	r3, [r7, #0x4]
 801b990: 689b         	ldr	r3, [r3, #0x8]
 801b992: 4618         	mov	r0, r3
 801b994: f7ff ffd7    	bl	0x801b946 <big_heap_chunks> @ imm = #-0x52
 801b998: 4603         	mov	r3, r0
; }
 801b99a: 4618         	mov	r0, r3
 801b99c: 3708         	adds	r7, #0x8
 801b99e: 46bd         	mov	sp, r7
 801b9a0: bd80         	pop	{r7, pc}

0801b9a2 <chunk_buf>:
; {
 801b9a2: b480         	push	{r7}
 801b9a4: b083         	sub	sp, #0xc
 801b9a6: af00         	add	r7, sp, #0x0
 801b9a8: 6078         	str	r0, [r7, #0x4]
; 	return (chunk_unit_t *)h;
 801b9aa: 687b         	ldr	r3, [r7, #0x4]
; }
 801b9ac: 4618         	mov	r0, r3
 801b9ae: 370c         	adds	r7, #0xc
 801b9b0: 46bd         	mov	sp, r7
 801b9b2: f85d 7b04    	ldr	r7, [sp], #4
 801b9b6: 4770         	bx	lr

0801b9b8 <chunk_field>:
; {
 801b9b8: b580         	push	{r7, lr}
 801b9ba: b086         	sub	sp, #0x18
 801b9bc: af00         	add	r7, sp, #0x0
 801b9be: 60f8         	str	r0, [r7, #0xc]
 801b9c0: 60b9         	str	r1, [r7, #0x8]
 801b9c2: 4613         	mov	r3, r2
 801b9c4: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 801b9c6: 68f8         	ldr	r0, [r7, #0xc]
 801b9c8: f7ff ffeb    	bl	0x801b9a2 <chunk_buf>   @ imm = #-0x2a
 801b9cc: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 801b9ce: 68bb         	ldr	r3, [r7, #0x8]
 801b9d0: 00db         	lsls	r3, r3, #0x3
 801b9d2: 697a         	ldr	r2, [r7, #0x14]
 801b9d4: 4413         	add	r3, r2
 801b9d6: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 801b9d8: 68f8         	ldr	r0, [r7, #0xc]
 801b9da: f7ff ffd4    	bl	0x801b986 <big_heap>    @ imm = #-0x58
 801b9de: 4603         	mov	r3, r0
 801b9e0: 2b00         	cmp	r3, #0x0
 801b9e2: d005         	beq	0x801b9f0 <chunk_field+0x38> @ imm = #0xa
; 		return ((uint32_t *)cmem)[f];
 801b9e4: 79fb         	ldrb	r3, [r7, #0x7]
 801b9e6: 009b         	lsls	r3, r3, #0x2
 801b9e8: 693a         	ldr	r2, [r7, #0x10]
 801b9ea: 4413         	add	r3, r2
 801b9ec: 681b         	ldr	r3, [r3]
 801b9ee: e004         	b	0x801b9fa <chunk_field+0x42> @ imm = #0x8
; 		return ((uint16_t *)cmem)[f];
 801b9f0: 79fb         	ldrb	r3, [r7, #0x7]
 801b9f2: 005b         	lsls	r3, r3, #0x1
 801b9f4: 693a         	ldr	r2, [r7, #0x10]
 801b9f6: 4413         	add	r3, r2
 801b9f8: 881b         	ldrh	r3, [r3]
; }
 801b9fa: 4618         	mov	r0, r3
 801b9fc: 3718         	adds	r7, #0x18
 801b9fe: 46bd         	mov	sp, r7
 801ba00: bd80         	pop	{r7, pc}

0801ba02 <chunk_set>:
; {
 801ba02: b580         	push	{r7, lr}
 801ba04: b086         	sub	sp, #0x18
 801ba06: af00         	add	r7, sp, #0x0
 801ba08: 60f8         	str	r0, [r7, #0xc]
 801ba0a: 60b9         	str	r1, [r7, #0x8]
 801ba0c: 603b         	str	r3, [r7]
 801ba0e: 4613         	mov	r3, r2
 801ba10: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 801ba12: 68f8         	ldr	r0, [r7, #0xc]
 801ba14: f7ff ffc5    	bl	0x801b9a2 <chunk_buf>   @ imm = #-0x76
 801ba18: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 801ba1a: 68bb         	ldr	r3, [r7, #0x8]
 801ba1c: 00db         	lsls	r3, r3, #0x3
 801ba1e: 697a         	ldr	r2, [r7, #0x14]
 801ba20: 4413         	add	r3, r2
 801ba22: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 801ba24: 68f8         	ldr	r0, [r7, #0xc]
 801ba26: f7ff ffae    	bl	0x801b986 <big_heap>    @ imm = #-0xa4
 801ba2a: 4603         	mov	r3, r0
 801ba2c: 2b00         	cmp	r3, #0x0
 801ba2e: d006         	beq	0x801ba3e <chunk_set+0x3c> @ imm = #0xc
; 		((uint32_t *)cmem)[f] = val;
 801ba30: 79fb         	ldrb	r3, [r7, #0x7]
 801ba32: 009b         	lsls	r3, r3, #0x2
 801ba34: 693a         	ldr	r2, [r7, #0x10]
 801ba36: 4413         	add	r3, r2
 801ba38: 683a         	ldr	r2, [r7]
 801ba3a: 601a         	str	r2, [r3]
; }
 801ba3c: e006         	b	0x801ba4c <chunk_set+0x4a> @ imm = #0xc
; 		((uint16_t *)cmem)[f] = val;
 801ba3e: 79fb         	ldrb	r3, [r7, #0x7]
 801ba40: 005b         	lsls	r3, r3, #0x1
 801ba42: 693a         	ldr	r2, [r7, #0x10]
 801ba44: 4413         	add	r3, r2
 801ba46: 683a         	ldr	r2, [r7]
 801ba48: b292         	uxth	r2, r2
 801ba4a: 801a         	strh	r2, [r3]
; }
 801ba4c: bf00         	nop
 801ba4e: 3718         	adds	r7, #0x18
 801ba50: 46bd         	mov	sp, r7
 801ba52: bd80         	pop	{r7, pc}

0801ba54 <chunk_used>:
; {
 801ba54: b580         	push	{r7, lr}
 801ba56: b082         	sub	sp, #0x8
 801ba58: af00         	add	r7, sp, #0x0
 801ba5a: 6078         	str	r0, [r7, #0x4]
 801ba5c: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, SIZE_AND_USED) & 1U;
 801ba5e: 2201         	movs	r2, #0x1
 801ba60: 6839         	ldr	r1, [r7]
 801ba62: 6878         	ldr	r0, [r7, #0x4]
 801ba64: f7ff ffa8    	bl	0x801b9b8 <chunk_field> @ imm = #-0xb0
 801ba68: 4603         	mov	r3, r0
 801ba6a: f003 0301    	and	r3, r3, #0x1
 801ba6e: 2b00         	cmp	r3, #0x0
 801ba70: bf14         	ite	ne
 801ba72: 2301         	movne	r3, #0x1
 801ba74: 2300         	moveq	r3, #0x0
 801ba76: b2db         	uxtb	r3, r3
; }
 801ba78: 4618         	mov	r0, r3
 801ba7a: 3708         	adds	r7, #0x8
 801ba7c: 46bd         	mov	sp, r7
 801ba7e: bd80         	pop	{r7, pc}

0801ba80 <chunk_size>:
; {
 801ba80: b580         	push	{r7, lr}
 801ba82: b082         	sub	sp, #0x8
 801ba84: af00         	add	r7, sp, #0x0
 801ba86: 6078         	str	r0, [r7, #0x4]
 801ba88: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, SIZE_AND_USED) >> 1;
 801ba8a: 2201         	movs	r2, #0x1
 801ba8c: 6839         	ldr	r1, [r7]
 801ba8e: 6878         	ldr	r0, [r7, #0x4]
 801ba90: f7ff ff92    	bl	0x801b9b8 <chunk_field> @ imm = #-0xdc
 801ba94: 4603         	mov	r3, r0
 801ba96: 085b         	lsrs	r3, r3, #0x1
; }
 801ba98: 4618         	mov	r0, r3
 801ba9a: 3708         	adds	r7, #0x8
 801ba9c: 46bd         	mov	sp, r7
 801ba9e: bd80         	pop	{r7, pc}

0801baa0 <set_chunk_used>:
; {
 801baa0: b580         	push	{r7, lr}
 801baa2: b086         	sub	sp, #0x18
 801baa4: af00         	add	r7, sp, #0x0
 801baa6: 60f8         	str	r0, [r7, #0xc]
 801baa8: 60b9         	str	r1, [r7, #0x8]
 801baaa: 4613         	mov	r3, r2
 801baac: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 801baae: 68f8         	ldr	r0, [r7, #0xc]
 801bab0: f7ff ff77    	bl	0x801b9a2 <chunk_buf>   @ imm = #-0x112
 801bab4: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 801bab6: 68bb         	ldr	r3, [r7, #0x8]
 801bab8: 00db         	lsls	r3, r3, #0x3
 801baba: 697a         	ldr	r2, [r7, #0x14]
 801babc: 4413         	add	r3, r2
 801babe: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 801bac0: 68f8         	ldr	r0, [r7, #0xc]
 801bac2: f7ff ff60    	bl	0x801b986 <big_heap>    @ imm = #-0x140
 801bac6: 4603         	mov	r3, r0
 801bac8: 2b00         	cmp	r3, #0x0
 801baca: d014         	beq	0x801baf6 <set_chunk_used+0x56> @ imm = #0x28
; 		if (used) {
 801bacc: 79fb         	ldrb	r3, [r7, #0x7]
 801bace: 2b00         	cmp	r3, #0x0
 801bad0: d008         	beq	0x801bae4 <set_chunk_used+0x44> @ imm = #0x10
; 			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
 801bad2: 693b         	ldr	r3, [r7, #0x10]
 801bad4: 3304         	adds	r3, #0x4
 801bad6: 681a         	ldr	r2, [r3]
 801bad8: 693b         	ldr	r3, [r7, #0x10]
 801bada: 3304         	adds	r3, #0x4
 801badc: f042 0201    	orr	r2, r2, #0x1
 801bae0: 601a         	str	r2, [r3]
; }
 801bae2: e01e         	b	0x801bb22 <set_chunk_used+0x82> @ imm = #0x3c
; 			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
 801bae4: 693b         	ldr	r3, [r7, #0x10]
 801bae6: 3304         	adds	r3, #0x4
 801bae8: 681a         	ldr	r2, [r3]
 801baea: 693b         	ldr	r3, [r7, #0x10]
 801baec: 3304         	adds	r3, #0x4
 801baee: f022 0201    	bic	r2, r2, #0x1
 801baf2: 601a         	str	r2, [r3]
; }
 801baf4: e015         	b	0x801bb22 <set_chunk_used+0x82> @ imm = #0x2a
; 		if (used) {
 801baf6: 79fb         	ldrb	r3, [r7, #0x7]
 801baf8: 2b00         	cmp	r3, #0x0
 801bafa: d009         	beq	0x801bb10 <set_chunk_used+0x70> @ imm = #0x12
; 			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 801bafc: 693b         	ldr	r3, [r7, #0x10]
 801bafe: 3302         	adds	r3, #0x2
 801bb00: 881a         	ldrh	r2, [r3]
 801bb02: 693b         	ldr	r3, [r7, #0x10]
 801bb04: 3302         	adds	r3, #0x2
 801bb06: f042 0201    	orr	r2, r2, #0x1
 801bb0a: b292         	uxth	r2, r2
 801bb0c: 801a         	strh	r2, [r3]
; }
 801bb0e: e008         	b	0x801bb22 <set_chunk_used+0x82> @ imm = #0x10
; 			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
 801bb10: 693b         	ldr	r3, [r7, #0x10]
 801bb12: 3302         	adds	r3, #0x2
 801bb14: 881a         	ldrh	r2, [r3]
 801bb16: 693b         	ldr	r3, [r7, #0x10]
 801bb18: 3302         	adds	r3, #0x2
 801bb1a: f022 0201    	bic	r2, r2, #0x1
 801bb1e: b292         	uxth	r2, r2
 801bb20: 801a         	strh	r2, [r3]
; }
 801bb22: bf00         	nop
 801bb24: 3718         	adds	r7, #0x18
 801bb26: 46bd         	mov	sp, r7
 801bb28: bd80         	pop	{r7, pc}

0801bb2a <set_chunk_size>:
; {
 801bb2a: b580         	push	{r7, lr}
 801bb2c: b084         	sub	sp, #0x10
 801bb2e: af00         	add	r7, sp, #0x0
 801bb30: 60f8         	str	r0, [r7, #0xc]
 801bb32: 60b9         	str	r1, [r7, #0x8]
 801bb34: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, SIZE_AND_USED, size << 1);
 801bb36: 687b         	ldr	r3, [r7, #0x4]
 801bb38: 005b         	lsls	r3, r3, #0x1
 801bb3a: 2201         	movs	r2, #0x1
 801bb3c: 68b9         	ldr	r1, [r7, #0x8]
 801bb3e: 68f8         	ldr	r0, [r7, #0xc]
 801bb40: f7ff ff5f    	bl	0x801ba02 <chunk_set>   @ imm = #-0x142
; }
 801bb44: bf00         	nop
 801bb46: 3710         	adds	r7, #0x10
 801bb48: 46bd         	mov	sp, r7
 801bb4a: bd80         	pop	{r7, pc}

0801bb4c <prev_free_chunk>:
; {
 801bb4c: b580         	push	{r7, lr}
 801bb4e: b082         	sub	sp, #0x8
 801bb50: af00         	add	r7, sp, #0x0
 801bb52: 6078         	str	r0, [r7, #0x4]
 801bb54: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, FREE_PREV);
 801bb56: 2202         	movs	r2, #0x2
 801bb58: 6839         	ldr	r1, [r7]
 801bb5a: 6878         	ldr	r0, [r7, #0x4]
 801bb5c: f7ff ff2c    	bl	0x801b9b8 <chunk_field> @ imm = #-0x1a8
 801bb60: 4603         	mov	r3, r0
; }
 801bb62: 4618         	mov	r0, r3
 801bb64: 3708         	adds	r7, #0x8
 801bb66: 46bd         	mov	sp, r7
 801bb68: bd80         	pop	{r7, pc}

0801bb6a <next_free_chunk>:
; {
 801bb6a: b580         	push	{r7, lr}
 801bb6c: b082         	sub	sp, #0x8
 801bb6e: af00         	add	r7, sp, #0x0
 801bb70: 6078         	str	r0, [r7, #0x4]
 801bb72: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, FREE_NEXT);
 801bb74: 2203         	movs	r2, #0x3
 801bb76: 6839         	ldr	r1, [r7]
 801bb78: 6878         	ldr	r0, [r7, #0x4]
 801bb7a: f7ff ff1d    	bl	0x801b9b8 <chunk_field> @ imm = #-0x1c6
 801bb7e: 4603         	mov	r3, r0
; }
 801bb80: 4618         	mov	r0, r3
 801bb82: 3708         	adds	r7, #0x8
 801bb84: 46bd         	mov	sp, r7
 801bb86: bd80         	pop	{r7, pc}

0801bb88 <set_prev_free_chunk>:
; {
 801bb88: b580         	push	{r7, lr}
 801bb8a: b084         	sub	sp, #0x10
 801bb8c: af00         	add	r7, sp, #0x0
 801bb8e: 60f8         	str	r0, [r7, #0xc]
 801bb90: 60b9         	str	r1, [r7, #0x8]
 801bb92: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_PREV, prev);
 801bb94: 687b         	ldr	r3, [r7, #0x4]
 801bb96: 2202         	movs	r2, #0x2
 801bb98: 68b9         	ldr	r1, [r7, #0x8]
 801bb9a: 68f8         	ldr	r0, [r7, #0xc]
 801bb9c: f7ff ff31    	bl	0x801ba02 <chunk_set>   @ imm = #-0x19e
; }
 801bba0: bf00         	nop
 801bba2: 3710         	adds	r7, #0x10
 801bba4: 46bd         	mov	sp, r7
 801bba6: bd80         	pop	{r7, pc}

0801bba8 <set_next_free_chunk>:
; {
 801bba8: b580         	push	{r7, lr}
 801bbaa: b084         	sub	sp, #0x10
 801bbac: af00         	add	r7, sp, #0x0
 801bbae: 60f8         	str	r0, [r7, #0xc]
 801bbb0: 60b9         	str	r1, [r7, #0x8]
 801bbb2: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_NEXT, next);
 801bbb4: 687b         	ldr	r3, [r7, #0x4]
 801bbb6: 2203         	movs	r2, #0x3
 801bbb8: 68b9         	ldr	r1, [r7, #0x8]
 801bbba: 68f8         	ldr	r0, [r7, #0xc]
 801bbbc: f7ff ff21    	bl	0x801ba02 <chunk_set>   @ imm = #-0x1be
; }
 801bbc0: bf00         	nop
 801bbc2: 3710         	adds	r7, #0x10
 801bbc4: 46bd         	mov	sp, r7
 801bbc6: bd80         	pop	{r7, pc}

0801bbc8 <left_chunk>:
; {
 801bbc8: b580         	push	{r7, lr}
 801bbca: b082         	sub	sp, #0x8
 801bbcc: af00         	add	r7, sp, #0x0
 801bbce: 6078         	str	r0, [r7, #0x4]
 801bbd0: 6039         	str	r1, [r7]
; 	return c - chunk_field(h, c, LEFT_SIZE);
 801bbd2: 2200         	movs	r2, #0x0
 801bbd4: 6839         	ldr	r1, [r7]
 801bbd6: 6878         	ldr	r0, [r7, #0x4]
 801bbd8: f7ff feee    	bl	0x801b9b8 <chunk_field> @ imm = #-0x224
 801bbdc: 4602         	mov	r2, r0
 801bbde: 683b         	ldr	r3, [r7]
 801bbe0: 1a9b         	subs	r3, r3, r2
; }
 801bbe2: 4618         	mov	r0, r3
 801bbe4: 3708         	adds	r7, #0x8
 801bbe6: 46bd         	mov	sp, r7
 801bbe8: bd80         	pop	{r7, pc}

0801bbea <right_chunk>:
; {
 801bbea: b580         	push	{r7, lr}
 801bbec: b082         	sub	sp, #0x8
 801bbee: af00         	add	r7, sp, #0x0
 801bbf0: 6078         	str	r0, [r7, #0x4]
 801bbf2: 6039         	str	r1, [r7]
; 	return c + chunk_size(h, c);
 801bbf4: 6839         	ldr	r1, [r7]
 801bbf6: 6878         	ldr	r0, [r7, #0x4]
 801bbf8: f7ff ff42    	bl	0x801ba80 <chunk_size>  @ imm = #-0x17c
 801bbfc: 4602         	mov	r2, r0
 801bbfe: 683b         	ldr	r3, [r7]
 801bc00: 4413         	add	r3, r2
; }
 801bc02: 4618         	mov	r0, r3
 801bc04: 3708         	adds	r7, #0x8
 801bc06: 46bd         	mov	sp, r7
 801bc08: bd80         	pop	{r7, pc}

0801bc0a <set_left_chunk_size>:
; {
 801bc0a: b580         	push	{r7, lr}
 801bc0c: b084         	sub	sp, #0x10
 801bc0e: af00         	add	r7, sp, #0x0
 801bc10: 60f8         	str	r0, [r7, #0xc]
 801bc12: 60b9         	str	r1, [r7, #0x8]
 801bc14: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, LEFT_SIZE, size);
 801bc16: 687b         	ldr	r3, [r7, #0x4]
 801bc18: 2200         	movs	r2, #0x0
 801bc1a: 68b9         	ldr	r1, [r7, #0x8]
 801bc1c: 68f8         	ldr	r0, [r7, #0xc]
 801bc1e: f7ff fef0    	bl	0x801ba02 <chunk_set>   @ imm = #-0x220
; }
 801bc22: bf00         	nop
 801bc24: 3710         	adds	r7, #0x10
 801bc26: 46bd         	mov	sp, r7
 801bc28: bd80         	pop	{r7, pc}

0801bc2a <solo_free_header>:
; {
 801bc2a: b580         	push	{r7, lr}
 801bc2c: b082         	sub	sp, #0x8
 801bc2e: af00         	add	r7, sp, #0x0
 801bc30: 6078         	str	r0, [r7, #0x4]
 801bc32: 6039         	str	r1, [r7]
; 	return big_heap(h) && (chunk_size(h, c) == 1U);
 801bc34: 6878         	ldr	r0, [r7, #0x4]
 801bc36: f7ff fea6    	bl	0x801b986 <big_heap>    @ imm = #-0x2b4
 801bc3a: 4603         	mov	r3, r0
 801bc3c: 2b00         	cmp	r3, #0x0
 801bc3e: d008         	beq	0x801bc52 <solo_free_header+0x28> @ imm = #0x10
 801bc40: 6839         	ldr	r1, [r7]
 801bc42: 6878         	ldr	r0, [r7, #0x4]
 801bc44: f7ff ff1c    	bl	0x801ba80 <chunk_size>  @ imm = #-0x1c8
 801bc48: 4603         	mov	r3, r0
 801bc4a: 2b01         	cmp	r3, #0x1
 801bc4c: d101         	bne	0x801bc52 <solo_free_header+0x28> @ imm = #0x2
 801bc4e: 2301         	movs	r3, #0x1
 801bc50: e000         	b	0x801bc54 <solo_free_header+0x2a> @ imm = #0x0
 801bc52: 2300         	movs	r3, #0x0
 801bc54: f003 0301    	and	r3, r3, #0x1
 801bc58: b2db         	uxtb	r3, r3
; }
 801bc5a: 4618         	mov	r0, r3
 801bc5c: 3708         	adds	r7, #0x8
 801bc5e: 46bd         	mov	sp, r7
 801bc60: bd80         	pop	{r7, pc}

0801bc62 <chunk_header_bytes>:
; {
 801bc62: b580         	push	{r7, lr}
 801bc64: b082         	sub	sp, #0x8
 801bc66: af00         	add	r7, sp, #0x0
 801bc68: 6078         	str	r0, [r7, #0x4]
; 	return big_heap(h) ? 8 : 4;
 801bc6a: 6878         	ldr	r0, [r7, #0x4]
 801bc6c: f7ff fe8b    	bl	0x801b986 <big_heap>    @ imm = #-0x2ea
 801bc70: 4603         	mov	r3, r0
 801bc72: 2b00         	cmp	r3, #0x0
 801bc74: d001         	beq	0x801bc7a <chunk_header_bytes+0x18> @ imm = #0x2
 801bc76: 2308         	movs	r3, #0x8
 801bc78: e000         	b	0x801bc7c <chunk_header_bytes+0x1a> @ imm = #0x0
 801bc7a: 2304         	movs	r3, #0x4
; }
 801bc7c: 4618         	mov	r0, r3
 801bc7e: 3708         	adds	r7, #0x8
 801bc80: 46bd         	mov	sp, r7
 801bc82: bd80         	pop	{r7, pc}

0801bc84 <heap_footer_bytes>:
; {
 801bc84: b580         	push	{r7, lr}
 801bc86: b082         	sub	sp, #0x8
 801bc88: af00         	add	r7, sp, #0x0
 801bc8a: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_bytes(size) ? 8 : 4;
 801bc8c: 6878         	ldr	r0, [r7, #0x4]
 801bc8e: f7ff fe6c    	bl	0x801b96a <big_heap_bytes> @ imm = #-0x328
 801bc92: 4603         	mov	r3, r0
 801bc94: 2b00         	cmp	r3, #0x0
 801bc96: d001         	beq	0x801bc9c <heap_footer_bytes+0x18> @ imm = #0x2
 801bc98: 2308         	movs	r3, #0x8
 801bc9a: e000         	b	0x801bc9e <heap_footer_bytes+0x1a> @ imm = #0x0
 801bc9c: 2304         	movs	r3, #0x4
; }
 801bc9e: 4618         	mov	r0, r3
 801bca0: 3708         	adds	r7, #0x8
 801bca2: 46bd         	mov	sp, r7
 801bca4: bd80         	pop	{r7, pc}

0801bca6 <chunksz>:
; {
 801bca6: b480         	push	{r7}
 801bca8: b083         	sub	sp, #0xc
 801bcaa: af00         	add	r7, sp, #0x0
 801bcac: 6078         	str	r0, [r7, #0x4]
; 	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 801bcae: 687b         	ldr	r3, [r7, #0x4]
 801bcb0: 3307         	adds	r3, #0x7
 801bcb2: 08db         	lsrs	r3, r3, #0x3
; }
 801bcb4: 4618         	mov	r0, r3
 801bcb6: 370c         	adds	r7, #0xc
 801bcb8: 46bd         	mov	sp, r7
 801bcba: f85d 7b04    	ldr	r7, [sp], #4
 801bcbe: 4770         	bx	lr

0801bcc0 <bytes_to_chunksz>:
; {
 801bcc0: b580         	push	{r7, lr}
 801bcc2: b082         	sub	sp, #0x8
 801bcc4: af00         	add	r7, sp, #0x0
 801bcc6: 6078         	str	r0, [r7, #0x4]
 801bcc8: 6039         	str	r1, [r7]
; 	return chunksz(chunk_header_bytes(h) + bytes);
 801bcca: 6878         	ldr	r0, [r7, #0x4]
 801bccc: f7ff ffc9    	bl	0x801bc62 <chunk_header_bytes> @ imm = #-0x6e
 801bcd0: 4602         	mov	r2, r0
 801bcd2: 683b         	ldr	r3, [r7]
 801bcd4: 4413         	add	r3, r2
 801bcd6: 4618         	mov	r0, r3
 801bcd8: f7ff ffe5    	bl	0x801bca6 <chunksz>     @ imm = #-0x36
 801bcdc: 4603         	mov	r3, r0
; }
 801bcde: 4618         	mov	r0, r3
 801bce0: 3708         	adds	r7, #0x8
 801bce2: 46bd         	mov	sp, r7
 801bce4: bd80         	pop	{r7, pc}

0801bce6 <min_chunk_size>:
; {
 801bce6: b580         	push	{r7, lr}
 801bce8: b082         	sub	sp, #0x8
 801bcea: af00         	add	r7, sp, #0x0
 801bcec: 6078         	str	r0, [r7, #0x4]
; 	return bytes_to_chunksz(h, 1);
 801bcee: 2101         	movs	r1, #0x1
 801bcf0: 6878         	ldr	r0, [r7, #0x4]
 801bcf2: f7ff ffe5    	bl	0x801bcc0 <bytes_to_chunksz> @ imm = #-0x36
 801bcf6: 4603         	mov	r3, r0
; }
 801bcf8: 4618         	mov	r0, r3
 801bcfa: 3708         	adds	r7, #0x8
 801bcfc: 46bd         	mov	sp, r7
 801bcfe: bd80         	pop	{r7, pc}

0801bd00 <bucket_idx>:
; {
 801bd00: b580         	push	{r7, lr}
 801bd02: b084         	sub	sp, #0x10
 801bd04: af00         	add	r7, sp, #0x0
 801bd06: 6078         	str	r0, [r7, #0x4]
 801bd08: 6039         	str	r1, [r7]
; 	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
 801bd0a: 6878         	ldr	r0, [r7, #0x4]
 801bd0c: f7ff ffeb    	bl	0x801bce6 <min_chunk_size> @ imm = #-0x2a
 801bd10: 4602         	mov	r2, r0
 801bd12: 683b         	ldr	r3, [r7]
 801bd14: 1a9b         	subs	r3, r3, r2
 801bd16: 3301         	adds	r3, #0x1
 801bd18: 60fb         	str	r3, [r7, #0xc]
; 	return 31 - __builtin_clz(usable_sz);
 801bd1a: 68fb         	ldr	r3, [r7, #0xc]
 801bd1c: fab3 f383    	clz	r3, r3
 801bd20: f1c3 031f    	rsb.w	r3, r3, #0x1f
; }
 801bd24: 4618         	mov	r0, r3
 801bd26: 3710         	adds	r7, #0x10
 801bd28: 46bd         	mov	sp, r7
 801bd2a: bd80         	pop	{r7, pc}

0801bd2c <size_too_big>:
; {
 801bd2c: b480         	push	{r7}
 801bd2e: b083         	sub	sp, #0xc
 801bd30: af00         	add	r7, sp, #0x0
 801bd32: 6078         	str	r0, [r7, #0x4]
 801bd34: 6039         	str	r1, [r7]
; 	return (bytes / CHUNK_UNIT) >= h->end_chunk;
 801bd36: 683b         	ldr	r3, [r7]
 801bd38: 08da         	lsrs	r2, r3, #0x3
 801bd3a: 687b         	ldr	r3, [r7, #0x4]
 801bd3c: 689b         	ldr	r3, [r3, #0x8]
 801bd3e: 429a         	cmp	r2, r3
 801bd40: bf2c         	ite	hs
 801bd42: 2301         	movhs	r3, #0x1
 801bd44: 2300         	movlo	r3, #0x0
 801bd46: b2db         	uxtb	r3, r3
; }
 801bd48: 4618         	mov	r0, r3
 801bd4a: 370c         	adds	r7, #0xc
 801bd4c: 46bd         	mov	sp, r7
 801bd4e: f85d 7b04    	ldr	r7, [sp], #4
 801bd52: 4770         	bx	lr

0801bd54 <chunk_mem>:
; {
 801bd54: b590         	push	{r4, r7, lr}
 801bd56: b085         	sub	sp, #0x14
 801bd58: af00         	add	r7, sp, #0x0
 801bd5a: 6078         	str	r0, [r7, #0x4]
 801bd5c: 6039         	str	r1, [r7]
; 	chunk_unit_t *buf = chunk_buf(h);
 801bd5e: 6878         	ldr	r0, [r7, #0x4]
 801bd60: f7ff fe1f    	bl	0x801b9a2 <chunk_buf>   @ imm = #-0x3c2
 801bd64: 60f8         	str	r0, [r7, #0xc]
; 	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
 801bd66: 683b         	ldr	r3, [r7]
 801bd68: 00dc         	lsls	r4, r3, #0x3
 801bd6a: 6878         	ldr	r0, [r7, #0x4]
 801bd6c: f7ff ff79    	bl	0x801bc62 <chunk_header_bytes> @ imm = #-0x10e
 801bd70: 4603         	mov	r3, r0
 801bd72: 4423         	add	r3, r4
 801bd74: 68fa         	ldr	r2, [r7, #0xc]
 801bd76: 4413         	add	r3, r2
 801bd78: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 801bd7a: 68bb         	ldr	r3, [r7, #0x8]
; }
 801bd7c: 4618         	mov	r0, r3
 801bd7e: 3714         	adds	r7, #0x14
 801bd80: 46bd         	mov	sp, r7
 801bd82: bd90         	pop	{r4, r7, pc}

0801bd84 <free_list_remove_bidx>:
; {
 801bd84: b580         	push	{r7, lr}
 801bd86: b088         	sub	sp, #0x20
 801bd88: af00         	add	r7, sp, #0x0
 801bd8a: 60f8         	str	r0, [r7, #0xc]
 801bd8c: 60b9         	str	r1, [r7, #0x8]
 801bd8e: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap_bucket *b = &h->buckets[bidx];
 801bd90: 687b         	ldr	r3, [r7, #0x4]
 801bd92: 3304         	adds	r3, #0x4
 801bd94: 009b         	lsls	r3, r3, #0x2
 801bd96: 68fa         	ldr	r2, [r7, #0xc]
 801bd98: 4413         	add	r3, r2
 801bd9a: 61fb         	str	r3, [r7, #0x1c]
; 	if (next_free_chunk(h, c) == c) {
 801bd9c: 68b9         	ldr	r1, [r7, #0x8]
 801bd9e: 68f8         	ldr	r0, [r7, #0xc]
 801bda0: f7ff fee3    	bl	0x801bb6a <next_free_chunk> @ imm = #-0x23a
 801bda4: 4602         	mov	r2, r0
 801bda6: 68bb         	ldr	r3, [r7, #0x8]
 801bda8: 4293         	cmp	r3, r2
 801bdaa: d10d         	bne	0x801bdc8 <free_list_remove_bidx+0x44> @ imm = #0x1a
; 		h->avail_buckets &= ~BIT(bidx);
 801bdac: 68fb         	ldr	r3, [r7, #0xc]
 801bdae: 68da         	ldr	r2, [r3, #0xc]
 801bdb0: 2101         	movs	r1, #0x1
 801bdb2: 687b         	ldr	r3, [r7, #0x4]
 801bdb4: fa01 f303    	lsl.w	r3, r1, r3
 801bdb8: 43db         	mvns	r3, r3
 801bdba: 401a         	ands	r2, r3
 801bdbc: 68fb         	ldr	r3, [r7, #0xc]
 801bdbe: 60da         	str	r2, [r3, #0xc]
; 		b->next = 0;
 801bdc0: 69fb         	ldr	r3, [r7, #0x1c]
 801bdc2: 2200         	movs	r2, #0x0
 801bdc4: 601a         	str	r2, [r3]
; }
 801bdc6: e016         	b	0x801bdf6 <free_list_remove_bidx+0x72> @ imm = #0x2c
; 		chunkid_t first = prev_free_chunk(h, c),
 801bdc8: 68b9         	ldr	r1, [r7, #0x8]
 801bdca: 68f8         	ldr	r0, [r7, #0xc]
 801bdcc: f7ff febe    	bl	0x801bb4c <prev_free_chunk> @ imm = #-0x284
 801bdd0: 61b8         	str	r0, [r7, #0x18]
; 			  second = next_free_chunk(h, c);
 801bdd2: 68b9         	ldr	r1, [r7, #0x8]
 801bdd4: 68f8         	ldr	r0, [r7, #0xc]
 801bdd6: f7ff fec8    	bl	0x801bb6a <next_free_chunk> @ imm = #-0x270
 801bdda: 6178         	str	r0, [r7, #0x14]
; 		b->next = second;
 801bddc: 69fb         	ldr	r3, [r7, #0x1c]
 801bdde: 697a         	ldr	r2, [r7, #0x14]
 801bde0: 601a         	str	r2, [r3]
; 		set_next_free_chunk(h, first, second);
 801bde2: 697a         	ldr	r2, [r7, #0x14]
 801bde4: 69b9         	ldr	r1, [r7, #0x18]
 801bde6: 68f8         	ldr	r0, [r7, #0xc]
 801bde8: f7ff fede    	bl	0x801bba8 <set_next_free_chunk> @ imm = #-0x244
; 		set_prev_free_chunk(h, second, first);
 801bdec: 69ba         	ldr	r2, [r7, #0x18]
 801bdee: 6979         	ldr	r1, [r7, #0x14]
 801bdf0: 68f8         	ldr	r0, [r7, #0xc]
 801bdf2: f7ff fec9    	bl	0x801bb88 <set_prev_free_chunk> @ imm = #-0x26e
; }
 801bdf6: bf00         	nop
 801bdf8: 3720         	adds	r7, #0x20
 801bdfa: 46bd         	mov	sp, r7
 801bdfc: bd80         	pop	{r7, pc}

0801bdfe <free_list_remove>:
; {
 801bdfe: b580         	push	{r7, lr}
 801be00: b084         	sub	sp, #0x10
 801be02: af00         	add	r7, sp, #0x0
 801be04: 6078         	str	r0, [r7, #0x4]
 801be06: 6039         	str	r1, [r7]
; 	if (!solo_free_header(h, c)) {
 801be08: 6839         	ldr	r1, [r7]
 801be0a: 6878         	ldr	r0, [r7, #0x4]
 801be0c: f7ff ff0d    	bl	0x801bc2a <solo_free_header> @ imm = #-0x1e6
 801be10: 4603         	mov	r3, r0
 801be12: f083 0301    	eor	r3, r3, #0x1
 801be16: b2db         	uxtb	r3, r3
 801be18: 2b00         	cmp	r3, #0x0
 801be1a: d00e         	beq	0x801be3a <free_list_remove+0x3c> @ imm = #0x1c
; 		int bidx = bucket_idx(h, chunk_size(h, c));
 801be1c: 6839         	ldr	r1, [r7]
 801be1e: 6878         	ldr	r0, [r7, #0x4]
 801be20: f7ff fe2e    	bl	0x801ba80 <chunk_size>  @ imm = #-0x3a4
 801be24: 4603         	mov	r3, r0
 801be26: 4619         	mov	r1, r3
 801be28: 6878         	ldr	r0, [r7, #0x4]
 801be2a: f7ff ff69    	bl	0x801bd00 <bucket_idx>  @ imm = #-0x12e
 801be2e: 60f8         	str	r0, [r7, #0xc]
; 		free_list_remove_bidx(h, c, bidx);
 801be30: 68fa         	ldr	r2, [r7, #0xc]
 801be32: 6839         	ldr	r1, [r7]
 801be34: 6878         	ldr	r0, [r7, #0x4]
 801be36: f7ff ffa5    	bl	0x801bd84 <free_list_remove_bidx> @ imm = #-0xb6
; }
 801be3a: bf00         	nop
 801be3c: 3710         	adds	r7, #0x10
 801be3e: 46bd         	mov	sp, r7
 801be40: bd80         	pop	{r7, pc}

0801be42 <free_list_add_bidx>:
; {
 801be42: b580         	push	{r7, lr}
 801be44: b088         	sub	sp, #0x20
 801be46: af00         	add	r7, sp, #0x0
 801be48: 60f8         	str	r0, [r7, #0xc]
 801be4a: 60b9         	str	r1, [r7, #0x8]
 801be4c: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap_bucket *b = &h->buckets[bidx];
 801be4e: 687b         	ldr	r3, [r7, #0x4]
 801be50: 3304         	adds	r3, #0x4
 801be52: 009b         	lsls	r3, r3, #0x2
 801be54: 68fa         	ldr	r2, [r7, #0xc]
 801be56: 4413         	add	r3, r2
 801be58: 61fb         	str	r3, [r7, #0x1c]
; 	if (b->next == 0U) {
 801be5a: 69fb         	ldr	r3, [r7, #0x1c]
 801be5c: 681b         	ldr	r3, [r3]
 801be5e: 2b00         	cmp	r3, #0x0
 801be60: d116         	bne	0x801be90 <free_list_add_bidx+0x4e> @ imm = #0x2c
; 		h->avail_buckets |= BIT(bidx);
 801be62: 68fb         	ldr	r3, [r7, #0xc]
 801be64: 68da         	ldr	r2, [r3, #0xc]
 801be66: 2101         	movs	r1, #0x1
 801be68: 687b         	ldr	r3, [r7, #0x4]
 801be6a: fa01 f303    	lsl.w	r3, r1, r3
 801be6e: 431a         	orrs	r2, r3
 801be70: 68fb         	ldr	r3, [r7, #0xc]
 801be72: 60da         	str	r2, [r3, #0xc]
; 		b->next = c;
 801be74: 69fb         	ldr	r3, [r7, #0x1c]
 801be76: 68ba         	ldr	r2, [r7, #0x8]
 801be78: 601a         	str	r2, [r3]
; 		set_prev_free_chunk(h, c, c);
 801be7a: 68ba         	ldr	r2, [r7, #0x8]
 801be7c: 68b9         	ldr	r1, [r7, #0x8]
 801be7e: 68f8         	ldr	r0, [r7, #0xc]
 801be80: f7ff fe82    	bl	0x801bb88 <set_prev_free_chunk> @ imm = #-0x2fc
; 		set_next_free_chunk(h, c, c);
 801be84: 68ba         	ldr	r2, [r7, #0x8]
 801be86: 68b9         	ldr	r1, [r7, #0x8]
 801be88: 68f8         	ldr	r0, [r7, #0xc]
 801be8a: f7ff fe8d    	bl	0x801bba8 <set_next_free_chunk> @ imm = #-0x2e6
; }
 801be8e: e01b         	b	0x801bec8 <free_list_add_bidx+0x86> @ imm = #0x36
; 		chunkid_t second = b->next;
 801be90: 69fb         	ldr	r3, [r7, #0x1c]
 801be92: 681b         	ldr	r3, [r3]
 801be94: 61bb         	str	r3, [r7, #0x18]
; 		chunkid_t first = prev_free_chunk(h, second);
 801be96: 69b9         	ldr	r1, [r7, #0x18]
 801be98: 68f8         	ldr	r0, [r7, #0xc]
 801be9a: f7ff fe57    	bl	0x801bb4c <prev_free_chunk> @ imm = #-0x352
 801be9e: 6178         	str	r0, [r7, #0x14]
; 		set_prev_free_chunk(h, c, first);
 801bea0: 697a         	ldr	r2, [r7, #0x14]
 801bea2: 68b9         	ldr	r1, [r7, #0x8]
 801bea4: 68f8         	ldr	r0, [r7, #0xc]
 801bea6: f7ff fe6f    	bl	0x801bb88 <set_prev_free_chunk> @ imm = #-0x322
; 		set_next_free_chunk(h, c, second);
 801beaa: 69ba         	ldr	r2, [r7, #0x18]
 801beac: 68b9         	ldr	r1, [r7, #0x8]
 801beae: 68f8         	ldr	r0, [r7, #0xc]
 801beb0: f7ff fe7a    	bl	0x801bba8 <set_next_free_chunk> @ imm = #-0x30c
; 		set_next_free_chunk(h, first, c);
 801beb4: 68ba         	ldr	r2, [r7, #0x8]
 801beb6: 6979         	ldr	r1, [r7, #0x14]
 801beb8: 68f8         	ldr	r0, [r7, #0xc]
 801beba: f7ff fe75    	bl	0x801bba8 <set_next_free_chunk> @ imm = #-0x316
; 		set_prev_free_chunk(h, second, c);
 801bebe: 68ba         	ldr	r2, [r7, #0x8]
 801bec0: 69b9         	ldr	r1, [r7, #0x18]
 801bec2: 68f8         	ldr	r0, [r7, #0xc]
 801bec4: f7ff fe60    	bl	0x801bb88 <set_prev_free_chunk> @ imm = #-0x340
; }
 801bec8: bf00         	nop
 801beca: 3720         	adds	r7, #0x20
 801becc: 46bd         	mov	sp, r7
 801bece: bd80         	pop	{r7, pc}

0801bed0 <free_list_add>:
; {
 801bed0: b580         	push	{r7, lr}
 801bed2: b084         	sub	sp, #0x10
 801bed4: af00         	add	r7, sp, #0x0
 801bed6: 6078         	str	r0, [r7, #0x4]
 801bed8: 6039         	str	r1, [r7]
; 	if (!solo_free_header(h, c)) {
 801beda: 6839         	ldr	r1, [r7]
 801bedc: 6878         	ldr	r0, [r7, #0x4]
 801bede: f7ff fea4    	bl	0x801bc2a <solo_free_header> @ imm = #-0x2b8
 801bee2: 4603         	mov	r3, r0
 801bee4: f083 0301    	eor	r3, r3, #0x1
 801bee8: b2db         	uxtb	r3, r3
 801beea: 2b00         	cmp	r3, #0x0
 801beec: d00e         	beq	0x801bf0c <free_list_add+0x3c> @ imm = #0x1c
; 		int bidx = bucket_idx(h, chunk_size(h, c));
 801beee: 6839         	ldr	r1, [r7]
 801bef0: 6878         	ldr	r0, [r7, #0x4]
 801bef2: f7ff fdc5    	bl	0x801ba80 <chunk_size>  @ imm = #-0x476
 801bef6: 4603         	mov	r3, r0
 801bef8: 4619         	mov	r1, r3
 801befa: 6878         	ldr	r0, [r7, #0x4]
 801befc: f7ff ff00    	bl	0x801bd00 <bucket_idx>  @ imm = #-0x200
 801bf00: 60f8         	str	r0, [r7, #0xc]
; 		free_list_add_bidx(h, c, bidx);
 801bf02: 68fa         	ldr	r2, [r7, #0xc]
 801bf04: 6839         	ldr	r1, [r7]
 801bf06: 6878         	ldr	r0, [r7, #0x4]
 801bf08: f7ff ff9b    	bl	0x801be42 <free_list_add_bidx> @ imm = #-0xca
; }
 801bf0c: bf00         	nop
 801bf0e: 3710         	adds	r7, #0x10
 801bf10: 46bd         	mov	sp, r7
 801bf12: bd80         	pop	{r7, pc}

0801bf14 <split_chunks>:
; {
 801bf14: b580         	push	{r7, lr}
 801bf16: b088         	sub	sp, #0x20
 801bf18: af00         	add	r7, sp, #0x0
 801bf1a: 60f8         	str	r0, [r7, #0xc]
 801bf1c: 60b9         	str	r1, [r7, #0x8]
 801bf1e: 607a         	str	r2, [r7, #0x4]
; 	chunksz_t sz0 = chunk_size(h, lc);
 801bf20: 68b9         	ldr	r1, [r7, #0x8]
 801bf22: 68f8         	ldr	r0, [r7, #0xc]
 801bf24: f7ff fdac    	bl	0x801ba80 <chunk_size>  @ imm = #-0x4a8
 801bf28: 61f8         	str	r0, [r7, #0x1c]
; 	chunksz_t lsz = rc - lc;
 801bf2a: 687a         	ldr	r2, [r7, #0x4]
 801bf2c: 68bb         	ldr	r3, [r7, #0x8]
 801bf2e: 1ad3         	subs	r3, r2, r3
 801bf30: 61bb         	str	r3, [r7, #0x18]
; 	chunksz_t rsz = sz0 - lsz;
 801bf32: 69fa         	ldr	r2, [r7, #0x1c]
 801bf34: 69bb         	ldr	r3, [r7, #0x18]
 801bf36: 1ad3         	subs	r3, r2, r3
 801bf38: 617b         	str	r3, [r7, #0x14]
; 	set_chunk_size(h, lc, lsz);
 801bf3a: 69ba         	ldr	r2, [r7, #0x18]
 801bf3c: 68b9         	ldr	r1, [r7, #0x8]
 801bf3e: 68f8         	ldr	r0, [r7, #0xc]
 801bf40: f7ff fdf3    	bl	0x801bb2a <set_chunk_size> @ imm = #-0x41a
; 	set_chunk_size(h, rc, rsz);
 801bf44: 697a         	ldr	r2, [r7, #0x14]
 801bf46: 6879         	ldr	r1, [r7, #0x4]
 801bf48: 68f8         	ldr	r0, [r7, #0xc]
 801bf4a: f7ff fdee    	bl	0x801bb2a <set_chunk_size> @ imm = #-0x424
; 	set_left_chunk_size(h, rc, lsz);
 801bf4e: 69ba         	ldr	r2, [r7, #0x18]
 801bf50: 6879         	ldr	r1, [r7, #0x4]
 801bf52: 68f8         	ldr	r0, [r7, #0xc]
 801bf54: f7ff fe59    	bl	0x801bc0a <set_left_chunk_size> @ imm = #-0x34e
; 	set_left_chunk_size(h, right_chunk(h, rc), rsz);
 801bf58: 6879         	ldr	r1, [r7, #0x4]
 801bf5a: 68f8         	ldr	r0, [r7, #0xc]
 801bf5c: f7ff fe45    	bl	0x801bbea <right_chunk> @ imm = #-0x376
 801bf60: 4603         	mov	r3, r0
 801bf62: 697a         	ldr	r2, [r7, #0x14]
 801bf64: 4619         	mov	r1, r3
 801bf66: 68f8         	ldr	r0, [r7, #0xc]
 801bf68: f7ff fe4f    	bl	0x801bc0a <set_left_chunk_size> @ imm = #-0x362
; }
 801bf6c: bf00         	nop
 801bf6e: 3720         	adds	r7, #0x20
 801bf70: 46bd         	mov	sp, r7
 801bf72: bd80         	pop	{r7, pc}

0801bf74 <merge_chunks>:
; {
 801bf74: b590         	push	{r4, r7, lr}
 801bf76: b087         	sub	sp, #0x1c
 801bf78: af00         	add	r7, sp, #0x0
 801bf7a: 60f8         	str	r0, [r7, #0xc]
 801bf7c: 60b9         	str	r1, [r7, #0x8]
 801bf7e: 607a         	str	r2, [r7, #0x4]
; 	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
 801bf80: 68b9         	ldr	r1, [r7, #0x8]
 801bf82: 68f8         	ldr	r0, [r7, #0xc]
 801bf84: f7ff fd7c    	bl	0x801ba80 <chunk_size>  @ imm = #-0x508
 801bf88: 4604         	mov	r4, r0
 801bf8a: 6879         	ldr	r1, [r7, #0x4]
 801bf8c: 68f8         	ldr	r0, [r7, #0xc]
 801bf8e: f7ff fd77    	bl	0x801ba80 <chunk_size>  @ imm = #-0x512
 801bf92: 4603         	mov	r3, r0
 801bf94: 4423         	add	r3, r4
 801bf96: 617b         	str	r3, [r7, #0x14]
; 	set_chunk_size(h, lc, newsz);
 801bf98: 697a         	ldr	r2, [r7, #0x14]
 801bf9a: 68b9         	ldr	r1, [r7, #0x8]
 801bf9c: 68f8         	ldr	r0, [r7, #0xc]
 801bf9e: f7ff fdc4    	bl	0x801bb2a <set_chunk_size> @ imm = #-0x478
; 	set_left_chunk_size(h, right_chunk(h, rc), newsz);
 801bfa2: 6879         	ldr	r1, [r7, #0x4]
 801bfa4: 68f8         	ldr	r0, [r7, #0xc]
 801bfa6: f7ff fe20    	bl	0x801bbea <right_chunk> @ imm = #-0x3c0
 801bfaa: 4603         	mov	r3, r0
 801bfac: 697a         	ldr	r2, [r7, #0x14]
 801bfae: 4619         	mov	r1, r3
 801bfb0: 68f8         	ldr	r0, [r7, #0xc]
 801bfb2: f7ff fe2a    	bl	0x801bc0a <set_left_chunk_size> @ imm = #-0x3ac
; }
 801bfb6: bf00         	nop
 801bfb8: 371c         	adds	r7, #0x1c
 801bfba: 46bd         	mov	sp, r7
 801bfbc: bd90         	pop	{r4, r7, pc}

0801bfbe <free_chunk>:
; {
 801bfbe: b580         	push	{r7, lr}
 801bfc0: b082         	sub	sp, #0x8
 801bfc2: af00         	add	r7, sp, #0x0
 801bfc4: 6078         	str	r0, [r7, #0x4]
 801bfc6: 6039         	str	r1, [r7]
; 	if (!chunk_used(h, right_chunk(h, c))) {
 801bfc8: 6839         	ldr	r1, [r7]
 801bfca: 6878         	ldr	r0, [r7, #0x4]
 801bfcc: f7ff fe0d    	bl	0x801bbea <right_chunk> @ imm = #-0x3e6
 801bfd0: 4603         	mov	r3, r0
 801bfd2: 4619         	mov	r1, r3
 801bfd4: 6878         	ldr	r0, [r7, #0x4]
 801bfd6: f7ff fd3d    	bl	0x801ba54 <chunk_used>  @ imm = #-0x586
 801bfda: 4603         	mov	r3, r0
 801bfdc: f083 0301    	eor	r3, r3, #0x1
 801bfe0: b2db         	uxtb	r3, r3
 801bfe2: 2b00         	cmp	r3, #0x0
 801bfe4: d012         	beq	0x801c00c <free_chunk+0x4e> @ imm = #0x24
; 		free_list_remove(h, right_chunk(h, c));
 801bfe6: 6839         	ldr	r1, [r7]
 801bfe8: 6878         	ldr	r0, [r7, #0x4]
 801bfea: f7ff fdfe    	bl	0x801bbea <right_chunk> @ imm = #-0x404
 801bfee: 4603         	mov	r3, r0
 801bff0: 4619         	mov	r1, r3
 801bff2: 6878         	ldr	r0, [r7, #0x4]
 801bff4: f7ff ff03    	bl	0x801bdfe <free_list_remove> @ imm = #-0x1fa
; 		merge_chunks(h, c, right_chunk(h, c));
 801bff8: 6839         	ldr	r1, [r7]
 801bffa: 6878         	ldr	r0, [r7, #0x4]
 801bffc: f7ff fdf5    	bl	0x801bbea <right_chunk> @ imm = #-0x416
 801c000: 4603         	mov	r3, r0
 801c002: 461a         	mov	r2, r3
 801c004: 6839         	ldr	r1, [r7]
 801c006: 6878         	ldr	r0, [r7, #0x4]
 801c008: f7ff ffb4    	bl	0x801bf74 <merge_chunks> @ imm = #-0x98
; 	if (!chunk_used(h, left_chunk(h, c))) {
 801c00c: 6839         	ldr	r1, [r7]
 801c00e: 6878         	ldr	r0, [r7, #0x4]
 801c010: f7ff fdda    	bl	0x801bbc8 <left_chunk>  @ imm = #-0x44c
 801c014: 4603         	mov	r3, r0
 801c016: 4619         	mov	r1, r3
 801c018: 6878         	ldr	r0, [r7, #0x4]
 801c01a: f7ff fd1b    	bl	0x801ba54 <chunk_used>  @ imm = #-0x5ca
 801c01e: 4603         	mov	r3, r0
 801c020: f083 0301    	eor	r3, r3, #0x1
 801c024: b2db         	uxtb	r3, r3
 801c026: 2b00         	cmp	r3, #0x0
 801c028: d017         	beq	0x801c05a <free_chunk+0x9c> @ imm = #0x2e
; 		free_list_remove(h, left_chunk(h, c));
 801c02a: 6839         	ldr	r1, [r7]
 801c02c: 6878         	ldr	r0, [r7, #0x4]
 801c02e: f7ff fdcb    	bl	0x801bbc8 <left_chunk>  @ imm = #-0x46a
 801c032: 4603         	mov	r3, r0
 801c034: 4619         	mov	r1, r3
 801c036: 6878         	ldr	r0, [r7, #0x4]
 801c038: f7ff fee1    	bl	0x801bdfe <free_list_remove> @ imm = #-0x23e
; 		merge_chunks(h, left_chunk(h, c), c);
 801c03c: 6839         	ldr	r1, [r7]
 801c03e: 6878         	ldr	r0, [r7, #0x4]
 801c040: f7ff fdc2    	bl	0x801bbc8 <left_chunk>  @ imm = #-0x47c
 801c044: 4603         	mov	r3, r0
 801c046: 683a         	ldr	r2, [r7]
 801c048: 4619         	mov	r1, r3
 801c04a: 6878         	ldr	r0, [r7, #0x4]
 801c04c: f7ff ff92    	bl	0x801bf74 <merge_chunks> @ imm = #-0xdc
; 		c = left_chunk(h, c);
 801c050: 6839         	ldr	r1, [r7]
 801c052: 6878         	ldr	r0, [r7, #0x4]
 801c054: f7ff fdb8    	bl	0x801bbc8 <left_chunk>  @ imm = #-0x490
 801c058: 6038         	str	r0, [r7]
; 	free_list_add(h, c);
 801c05a: 6839         	ldr	r1, [r7]
 801c05c: 6878         	ldr	r0, [r7, #0x4]
 801c05e: f7ff ff37    	bl	0x801bed0 <free_list_add> @ imm = #-0x192
; }
 801c062: bf00         	nop
 801c064: 3708         	adds	r7, #0x8
 801c066: 46bd         	mov	sp, r7
 801c068: bd80         	pop	{r7, pc}

0801c06a <mem_to_chunkid>:
; {
 801c06a: b580         	push	{r7, lr}
 801c06c: b084         	sub	sp, #0x10
 801c06e: af00         	add	r7, sp, #0x0
 801c070: 6078         	str	r0, [r7, #0x4]
 801c072: 6039         	str	r1, [r7]
; 	uint8_t *mem = p, *base = (uint8_t *)chunk_buf(h);
 801c074: 683b         	ldr	r3, [r7]
 801c076: 60fb         	str	r3, [r7, #0xc]
 801c078: 6878         	ldr	r0, [r7, #0x4]
 801c07a: f7ff fc92    	bl	0x801b9a2 <chunk_buf>   @ imm = #-0x6dc
 801c07e: 60b8         	str	r0, [r7, #0x8]
; 	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 801c080: 6878         	ldr	r0, [r7, #0x4]
 801c082: f7ff fdee    	bl	0x801bc62 <chunk_header_bytes> @ imm = #-0x424
 801c086: 4603         	mov	r3, r0
 801c088: 425b         	rsbs	r3, r3, #0
 801c08a: 68fa         	ldr	r2, [r7, #0xc]
 801c08c: 441a         	add	r2, r3
 801c08e: 68bb         	ldr	r3, [r7, #0x8]
 801c090: 1ad3         	subs	r3, r2, r3
 801c092: 08db         	lsrs	r3, r3, #0x3
; }
 801c094: 4618         	mov	r0, r3
 801c096: 3710         	adds	r7, #0x10
 801c098: 46bd         	mov	sp, r7
 801c09a: bd80         	pop	{r7, pc}

0801c09c <sys_heap_free>:
; {
 801c09c: b580         	push	{r7, lr}
 801c09e: b084         	sub	sp, #0x10
 801c0a0: af00         	add	r7, sp, #0x0
 801c0a2: 6078         	str	r0, [r7, #0x4]
 801c0a4: 6039         	str	r1, [r7]
; 	if (mem == NULL) {
 801c0a6: 683b         	ldr	r3, [r7]
 801c0a8: 2b00         	cmp	r3, #0x0
 801c0aa: d011         	beq	0x801c0d0 <sys_heap_free+0x34> @ imm = #0x22
; 	struct z_heap *h = heap->heap;
 801c0ac: 687b         	ldr	r3, [r7, #0x4]
 801c0ae: 681b         	ldr	r3, [r3]
 801c0b0: 60fb         	str	r3, [r7, #0xc]
; 	chunkid_t c = mem_to_chunkid(h, mem);
 801c0b2: 6839         	ldr	r1, [r7]
 801c0b4: 68f8         	ldr	r0, [r7, #0xc]
 801c0b6: f7ff ffd8    	bl	0x801c06a <mem_to_chunkid> @ imm = #-0x50
 801c0ba: 60b8         	str	r0, [r7, #0x8]
; 	set_chunk_used(h, c, false);
 801c0bc: 2200         	movs	r2, #0x0
 801c0be: 68b9         	ldr	r1, [r7, #0x8]
 801c0c0: 68f8         	ldr	r0, [r7, #0xc]
 801c0c2: f7ff fced    	bl	0x801baa0 <set_chunk_used> @ imm = #-0x626
; 	free_chunk(h, c);
 801c0c6: 68b9         	ldr	r1, [r7, #0x8]
 801c0c8: 68f8         	ldr	r0, [r7, #0xc]
 801c0ca: f7ff ff78    	bl	0x801bfbe <free_chunk>  @ imm = #-0x110
 801c0ce: e000         	b	0x801c0d2 <sys_heap_free+0x36> @ imm = #0x0
; 		return; /* ISO C free() semantics */
 801c0d0: bf00         	nop
; }
 801c0d2: 3710         	adds	r7, #0x10
 801c0d4: 46bd         	mov	sp, r7
 801c0d6: bd80         	pop	{r7, pc}

0801c0d8 <alloc_chunk>:
; {
 801c0d8: b580         	push	{r7, lr}
 801c0da: b08a         	sub	sp, #0x28
 801c0dc: af00         	add	r7, sp, #0x0
 801c0de: 6078         	str	r0, [r7, #0x4]
 801c0e0: 6039         	str	r1, [r7]
; 	int bi = bucket_idx(h, sz);
 801c0e2: 6839         	ldr	r1, [r7]
 801c0e4: 6878         	ldr	r0, [r7, #0x4]
 801c0e6: f7ff fe0b    	bl	0x801bd00 <bucket_idx>  @ imm = #-0x3ea
 801c0ea: 6238         	str	r0, [r7, #0x20]
; 	struct z_heap_bucket *b = &h->buckets[bi];
 801c0ec: 6a3b         	ldr	r3, [r7, #0x20]
 801c0ee: 3304         	adds	r3, #0x4
 801c0f0: 009b         	lsls	r3, r3, #0x2
 801c0f2: 687a         	ldr	r2, [r7, #0x4]
 801c0f4: 4413         	add	r3, r2
 801c0f6: 61fb         	str	r3, [r7, #0x1c]
; 	if (b->next != 0U) {
 801c0f8: 69fb         	ldr	r3, [r7, #0x1c]
 801c0fa: 681b         	ldr	r3, [r3]
 801c0fc: 2b00         	cmp	r3, #0x0
 801c0fe: d028         	beq	0x801c152 <alloc_chunk+0x7a> @ imm = #0x50
; 		chunkid_t first = b->next;
 801c100: 69fb         	ldr	r3, [r7, #0x1c]
 801c102: 681b         	ldr	r3, [r3]
 801c104: 61bb         	str	r3, [r7, #0x18]
; 		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
 801c106: 2303         	movs	r3, #0x3
 801c108: 627b         	str	r3, [r7, #0x24]
; 			chunkid_t c = b->next;
 801c10a: 69fb         	ldr	r3, [r7, #0x1c]
 801c10c: 681b         	ldr	r3, [r3]
 801c10e: 617b         	str	r3, [r7, #0x14]
; 			if (chunk_size(h, c) >= sz) {
 801c110: 6979         	ldr	r1, [r7, #0x14]
 801c112: 6878         	ldr	r0, [r7, #0x4]
 801c114: f7ff fcb4    	bl	0x801ba80 <chunk_size>  @ imm = #-0x698
 801c118: 4602         	mov	r2, r0
 801c11a: 683b         	ldr	r3, [r7]
 801c11c: 4293         	cmp	r3, r2
 801c11e: d806         	bhi	0x801c12e <alloc_chunk+0x56> @ imm = #0xc
; 				free_list_remove_bidx(h, c, bi);
 801c120: 6a3a         	ldr	r2, [r7, #0x20]
 801c122: 6979         	ldr	r1, [r7, #0x14]
 801c124: 6878         	ldr	r0, [r7, #0x4]
 801c126: f7ff fe2d    	bl	0x801bd84 <free_list_remove_bidx> @ imm = #-0x3a6
; 				return c;
 801c12a: 697b         	ldr	r3, [r7, #0x14]
 801c12c: e032         	b	0x801c194 <alloc_chunk+0xbc> @ imm = #0x64
; 			b->next = next_free_chunk(h, c);
 801c12e: 6979         	ldr	r1, [r7, #0x14]
 801c130: 6878         	ldr	r0, [r7, #0x4]
 801c132: f7ff fd1a    	bl	0x801bb6a <next_free_chunk> @ imm = #-0x5cc
 801c136: 4602         	mov	r2, r0
 801c138: 69fb         	ldr	r3, [r7, #0x1c]
 801c13a: 601a         	str	r2, [r3]
; 		} while (--i && b->next != first);
 801c13c: 6a7b         	ldr	r3, [r7, #0x24]
 801c13e: 3b01         	subs	r3, #0x1
 801c140: 627b         	str	r3, [r7, #0x24]
 801c142: 6a7b         	ldr	r3, [r7, #0x24]
 801c144: 2b00         	cmp	r3, #0x0
 801c146: d004         	beq	0x801c152 <alloc_chunk+0x7a> @ imm = #0x8
 801c148: 69fb         	ldr	r3, [r7, #0x1c]
 801c14a: 681b         	ldr	r3, [r3]
 801c14c: 69ba         	ldr	r2, [r7, #0x18]
 801c14e: 429a         	cmp	r2, r3
 801c150: d1db         	bne	0x801c10a <alloc_chunk+0x32> @ imm = #-0x4a
; 	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
 801c152: 687b         	ldr	r3, [r7, #0x4]
 801c154: 68da         	ldr	r2, [r3, #0xc]
 801c156: 6a3b         	ldr	r3, [r7, #0x20]
 801c158: 3301         	adds	r3, #0x1
 801c15a: 2101         	movs	r1, #0x1
 801c15c: fa01 f303    	lsl.w	r3, r1, r3
 801c160: 425b         	rsbs	r3, r3, #0
 801c162: 4013         	ands	r3, r2
 801c164: 613b         	str	r3, [r7, #0x10]
; 	if (bmask != 0U) {
 801c166: 693b         	ldr	r3, [r7, #0x10]
 801c168: 2b00         	cmp	r3, #0x0
 801c16a: d012         	beq	0x801c192 <alloc_chunk+0xba> @ imm = #0x24
; 		int minbucket = __builtin_ctz(bmask);
 801c16c: 693b         	ldr	r3, [r7, #0x10]
 801c16e: fa93 f3a3    	rbit	r3, r3
 801c172: fab3 f383    	clz	r3, r3
 801c176: 60fb         	str	r3, [r7, #0xc]
; 		chunkid_t c = h->buckets[minbucket].next;
 801c178: 687b         	ldr	r3, [r7, #0x4]
 801c17a: 68fa         	ldr	r2, [r7, #0xc]
 801c17c: 3204         	adds	r2, #0x4
 801c17e: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 801c182: 60bb         	str	r3, [r7, #0x8]
; 		free_list_remove_bidx(h, c, minbucket);
 801c184: 68fa         	ldr	r2, [r7, #0xc]
 801c186: 68b9         	ldr	r1, [r7, #0x8]
 801c188: 6878         	ldr	r0, [r7, #0x4]
 801c18a: f7ff fdfb    	bl	0x801bd84 <free_list_remove_bidx> @ imm = #-0x40a
; 		return c;
 801c18e: 68bb         	ldr	r3, [r7, #0x8]
 801c190: e000         	b	0x801c194 <alloc_chunk+0xbc> @ imm = #0x0
; 	return 0;
 801c192: 2300         	movs	r3, #0x0
; }
 801c194: 4618         	mov	r0, r3
 801c196: 3728         	adds	r7, #0x28
 801c198: 46bd         	mov	sp, r7
 801c19a: bd80         	pop	{r7, pc}

0801c19c <sys_heap_alloc>:
; {
 801c19c: b580         	push	{r7, lr}
 801c19e: b086         	sub	sp, #0x18
 801c1a0: af00         	add	r7, sp, #0x0
 801c1a2: 6078         	str	r0, [r7, #0x4]
 801c1a4: 6039         	str	r1, [r7]
; 	struct z_heap *h = heap->heap;
 801c1a6: 687b         	ldr	r3, [r7, #0x4]
 801c1a8: 681b         	ldr	r3, [r3]
 801c1aa: 617b         	str	r3, [r7, #0x14]
; 	if ((bytes == 0U) || size_too_big(h, bytes)) {
 801c1ac: 683b         	ldr	r3, [r7]
 801c1ae: 2b00         	cmp	r3, #0x0
 801c1b0: d006         	beq	0x801c1c0 <sys_heap_alloc+0x24> @ imm = #0xc
 801c1b2: 6839         	ldr	r1, [r7]
 801c1b4: 6978         	ldr	r0, [r7, #0x14]
 801c1b6: f7ff fdb9    	bl	0x801bd2c <size_too_big> @ imm = #-0x48e
 801c1ba: 4603         	mov	r3, r0
 801c1bc: 2b00         	cmp	r3, #0x0
 801c1be: d001         	beq	0x801c1c4 <sys_heap_alloc+0x28> @ imm = #0x2
; 		return NULL;
 801c1c0: 2300         	movs	r3, #0x0
 801c1c2: e030         	b	0x801c226 <sys_heap_alloc+0x8a> @ imm = #0x60
; 	chunksz_t chunk_sz = bytes_to_chunksz(h, bytes);
 801c1c4: 6839         	ldr	r1, [r7]
 801c1c6: 6978         	ldr	r0, [r7, #0x14]
 801c1c8: f7ff fd7a    	bl	0x801bcc0 <bytes_to_chunksz> @ imm = #-0x50c
 801c1cc: 6138         	str	r0, [r7, #0x10]
; 	chunkid_t c = alloc_chunk(h, chunk_sz);
 801c1ce: 6939         	ldr	r1, [r7, #0x10]
 801c1d0: 6978         	ldr	r0, [r7, #0x14]
 801c1d2: f7ff ff81    	bl	0x801c0d8 <alloc_chunk> @ imm = #-0xfe
 801c1d6: 60f8         	str	r0, [r7, #0xc]
; 	if (c == 0U) {
 801c1d8: 68fb         	ldr	r3, [r7, #0xc]
 801c1da: 2b00         	cmp	r3, #0x0
 801c1dc: d101         	bne	0x801c1e2 <sys_heap_alloc+0x46> @ imm = #0x2
; 		return NULL;
 801c1de: 2300         	movs	r3, #0x0
 801c1e0: e021         	b	0x801c226 <sys_heap_alloc+0x8a> @ imm = #0x42
; 	if (chunk_size(h, c) > chunk_sz) {
 801c1e2: 68f9         	ldr	r1, [r7, #0xc]
 801c1e4: 6978         	ldr	r0, [r7, #0x14]
 801c1e6: f7ff fc4b    	bl	0x801ba80 <chunk_size>  @ imm = #-0x76a
 801c1ea: 4602         	mov	r2, r0
 801c1ec: 693b         	ldr	r3, [r7, #0x10]
 801c1ee: 4293         	cmp	r3, r2
 801c1f0: d20e         	bhs	0x801c210 <sys_heap_alloc+0x74> @ imm = #0x1c
; 		split_chunks(h, c, c + chunk_sz);
 801c1f2: 68fa         	ldr	r2, [r7, #0xc]
 801c1f4: 693b         	ldr	r3, [r7, #0x10]
 801c1f6: 4413         	add	r3, r2
 801c1f8: 461a         	mov	r2, r3
 801c1fa: 68f9         	ldr	r1, [r7, #0xc]
 801c1fc: 6978         	ldr	r0, [r7, #0x14]
 801c1fe: f7ff fe89    	bl	0x801bf14 <split_chunks> @ imm = #-0x2ee
; 		free_list_add(h, c + chunk_sz);
 801c202: 68fa         	ldr	r2, [r7, #0xc]
 801c204: 693b         	ldr	r3, [r7, #0x10]
 801c206: 4413         	add	r3, r2
 801c208: 4619         	mov	r1, r3
 801c20a: 6978         	ldr	r0, [r7, #0x14]
 801c20c: f7ff fe60    	bl	0x801bed0 <free_list_add> @ imm = #-0x340
; 	set_chunk_used(h, c, true);
 801c210: 2201         	movs	r2, #0x1
 801c212: 68f9         	ldr	r1, [r7, #0xc]
 801c214: 6978         	ldr	r0, [r7, #0x14]
 801c216: f7ff fc43    	bl	0x801baa0 <set_chunk_used> @ imm = #-0x77a
; 	mem = chunk_mem(h, c);
 801c21a: 68f9         	ldr	r1, [r7, #0xc]
 801c21c: 6978         	ldr	r0, [r7, #0x14]
 801c21e: f7ff fd99    	bl	0x801bd54 <chunk_mem>   @ imm = #-0x4ce
 801c222: 60b8         	str	r0, [r7, #0x8]
; 	return mem;
 801c224: 68bb         	ldr	r3, [r7, #0x8]
; }
 801c226: 4618         	mov	r0, r3
 801c228: 3718         	adds	r7, #0x18
 801c22a: 46bd         	mov	sp, r7
 801c22c: bd80         	pop	{r7, pc}

0801c22e <sys_heap_aligned_alloc>:
; {
 801c22e: b580         	push	{r7, lr}
 801c230: b08e         	sub	sp, #0x38
 801c232: af00         	add	r7, sp, #0x0
 801c234: 60f8         	str	r0, [r7, #0xc]
 801c236: 60b9         	str	r1, [r7, #0x8]
 801c238: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap *h = heap->heap;
 801c23a: 68fb         	ldr	r3, [r7, #0xc]
 801c23c: 681b         	ldr	r3, [r3]
 801c23e: 62fb         	str	r3, [r7, #0x2c]
; 	rew = align & -align;
 801c240: 68bb         	ldr	r3, [r7, #0x8]
 801c242: 425b         	rsbs	r3, r3, #0
 801c244: 68ba         	ldr	r2, [r7, #0x8]
 801c246: 4013         	ands	r3, r2
 801c248: 633b         	str	r3, [r7, #0x30]
; 	if (align != rew) {
 801c24a: 68ba         	ldr	r2, [r7, #0x8]
 801c24c: 6b3b         	ldr	r3, [r7, #0x30]
 801c24e: 429a         	cmp	r2, r3
 801c250: d012         	beq	0x801c278 <sys_heap_aligned_alloc+0x4a> @ imm = #0x24
; 		align -= rew;
 801c252: 68ba         	ldr	r2, [r7, #0x8]
 801c254: 6b3b         	ldr	r3, [r7, #0x30]
 801c256: 1ad3         	subs	r3, r2, r3
 801c258: 60bb         	str	r3, [r7, #0x8]
; 		gap = MIN(rew, chunk_header_bytes(h));
 801c25a: 6af8         	ldr	r0, [r7, #0x2c]
 801c25c: f7ff fd01    	bl	0x801bc62 <chunk_header_bytes> @ imm = #-0x5fe
 801c260: 4602         	mov	r2, r0
 801c262: 6b3b         	ldr	r3, [r7, #0x30]
 801c264: 4293         	cmp	r3, r2
 801c266: d304         	blo	0x801c272 <sys_heap_aligned_alloc+0x44> @ imm = #0x8
 801c268: 6af8         	ldr	r0, [r7, #0x2c]
 801c26a: f7ff fcfa    	bl	0x801bc62 <chunk_header_bytes> @ imm = #-0x60c
 801c26e: 4603         	mov	r3, r0
 801c270: e000         	b	0x801c274 <sys_heap_aligned_alloc+0x46> @ imm = #0x0
 801c272: 6b3b         	ldr	r3, [r7, #0x30]
 801c274: 637b         	str	r3, [r7, #0x34]
 801c276: e012         	b	0x801c29e <sys_heap_aligned_alloc+0x70> @ imm = #0x24
; 		if (align <= chunk_header_bytes(h)) {
 801c278: 6af8         	ldr	r0, [r7, #0x2c]
 801c27a: f7ff fcf2    	bl	0x801bc62 <chunk_header_bytes> @ imm = #-0x61c
 801c27e: 4602         	mov	r2, r0
 801c280: 68bb         	ldr	r3, [r7, #0x8]
 801c282: 4293         	cmp	r3, r2
 801c284: d805         	bhi	0x801c292 <sys_heap_aligned_alloc+0x64> @ imm = #0xa
; 			return sys_heap_alloc(heap, bytes);
 801c286: 6879         	ldr	r1, [r7, #0x4]
 801c288: 68f8         	ldr	r0, [r7, #0xc]
 801c28a: f7ff ff87    	bl	0x801c19c <sys_heap_alloc> @ imm = #-0xf2
 801c28e: 4603         	mov	r3, r0
 801c290: e072         	b	0x801c378 <sys_heap_aligned_alloc+0x14a> @ imm = #0xe4
; 		rew = 0;
 801c292: 2300         	movs	r3, #0x0
 801c294: 633b         	str	r3, [r7, #0x30]
; 		gap = chunk_header_bytes(h);
 801c296: 6af8         	ldr	r0, [r7, #0x2c]
 801c298: f7ff fce3    	bl	0x801bc62 <chunk_header_bytes> @ imm = #-0x63a
 801c29c: 6378         	str	r0, [r7, #0x34]
; 	if ((bytes == 0) || size_too_big(h, bytes)) {
 801c29e: 687b         	ldr	r3, [r7, #0x4]
 801c2a0: 2b00         	cmp	r3, #0x0
 801c2a2: d006         	beq	0x801c2b2 <sys_heap_aligned_alloc+0x84> @ imm = #0xc
 801c2a4: 6879         	ldr	r1, [r7, #0x4]
 801c2a6: 6af8         	ldr	r0, [r7, #0x2c]
 801c2a8: f7ff fd40    	bl	0x801bd2c <size_too_big> @ imm = #-0x580
 801c2ac: 4603         	mov	r3, r0
 801c2ae: 2b00         	cmp	r3, #0x0
 801c2b0: d001         	beq	0x801c2b6 <sys_heap_aligned_alloc+0x88> @ imm = #0x2
; 		return NULL;
 801c2b2: 2300         	movs	r3, #0x0
 801c2b4: e060         	b	0x801c378 <sys_heap_aligned_alloc+0x14a> @ imm = #0xc0
; 	chunksz_t padded_sz = bytes_to_chunksz(h, bytes + align - gap);
 801c2b6: 687a         	ldr	r2, [r7, #0x4]
 801c2b8: 68bb         	ldr	r3, [r7, #0x8]
 801c2ba: 441a         	add	r2, r3
 801c2bc: 6b7b         	ldr	r3, [r7, #0x34]
 801c2be: 1ad3         	subs	r3, r2, r3
 801c2c0: 4619         	mov	r1, r3
 801c2c2: 6af8         	ldr	r0, [r7, #0x2c]
 801c2c4: f7ff fcfc    	bl	0x801bcc0 <bytes_to_chunksz> @ imm = #-0x608
 801c2c8: 62b8         	str	r0, [r7, #0x28]
; 	chunkid_t c0 = alloc_chunk(h, padded_sz);
 801c2ca: 6ab9         	ldr	r1, [r7, #0x28]
 801c2cc: 6af8         	ldr	r0, [r7, #0x2c]
 801c2ce: f7ff ff03    	bl	0x801c0d8 <alloc_chunk> @ imm = #-0x1fa
 801c2d2: 6278         	str	r0, [r7, #0x24]
; 	if (c0 == 0) {
 801c2d4: 6a7b         	ldr	r3, [r7, #0x24]
 801c2d6: 2b00         	cmp	r3, #0x0
 801c2d8: d101         	bne	0x801c2de <sys_heap_aligned_alloc+0xb0> @ imm = #0x2
; 		return NULL;
 801c2da: 2300         	movs	r3, #0x0
 801c2dc: e04c         	b	0x801c378 <sys_heap_aligned_alloc+0x14a> @ imm = #0x98
; 	uint8_t *mem = chunk_mem(h, c0);
 801c2de: 6a79         	ldr	r1, [r7, #0x24]
 801c2e0: 6af8         	ldr	r0, [r7, #0x2c]
 801c2e2: f7ff fd37    	bl	0x801bd54 <chunk_mem>   @ imm = #-0x592
 801c2e6: 6238         	str	r0, [r7, #0x20]
; 	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
 801c2e8: 6a3a         	ldr	r2, [r7, #0x20]
 801c2ea: 6b3b         	ldr	r3, [r7, #0x30]
 801c2ec: 4413         	add	r3, r2
 801c2ee: 461a         	mov	r2, r3
 801c2f0: 68bb         	ldr	r3, [r7, #0x8]
 801c2f2: 4413         	add	r3, r2
 801c2f4: 1e5a         	subs	r2, r3, #0x1
 801c2f6: 68bb         	ldr	r3, [r7, #0x8]
 801c2f8: fbb2 f3f3    	udiv	r3, r2, r3
 801c2fc: 68ba         	ldr	r2, [r7, #0x8]
 801c2fe: fb03 f202    	mul	r2, r3, r2
 801c302: 6b3b         	ldr	r3, [r7, #0x30]
 801c304: 1ad3         	subs	r3, r2, r3
 801c306: 623b         	str	r3, [r7, #0x20]
; 	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
 801c308: 6a3a         	ldr	r2, [r7, #0x20]
 801c30a: 687b         	ldr	r3, [r7, #0x4]
 801c30c: 4413         	add	r3, r2
 801c30e: 3307         	adds	r3, #0x7
 801c310: f023 0307    	bic	r3, r3, #0x7
 801c314: 61fb         	str	r3, [r7, #0x1c]
; 	chunkid_t c = mem_to_chunkid(h, mem);
 801c316: 6a39         	ldr	r1, [r7, #0x20]
 801c318: 6af8         	ldr	r0, [r7, #0x2c]
 801c31a: f7ff fea6    	bl	0x801c06a <mem_to_chunkid> @ imm = #-0x2b4
 801c31e: 61b8         	str	r0, [r7, #0x18]
; 	chunkid_t c_end = end - chunk_buf(h);
 801c320: 6af8         	ldr	r0, [r7, #0x2c]
 801c322: f7ff fb3e    	bl	0x801b9a2 <chunk_buf>   @ imm = #-0x984
 801c326: 4602         	mov	r2, r0
 801c328: 69fb         	ldr	r3, [r7, #0x1c]
 801c32a: 1a9b         	subs	r3, r3, r2
 801c32c: 10db         	asrs	r3, r3, #0x3
 801c32e: 617b         	str	r3, [r7, #0x14]
; 	if (c > c0) {
 801c330: 69ba         	ldr	r2, [r7, #0x18]
 801c332: 6a7b         	ldr	r3, [r7, #0x24]
 801c334: 429a         	cmp	r2, r3
 801c336: d908         	bls	0x801c34a <sys_heap_aligned_alloc+0x11c> @ imm = #0x10
; 		split_chunks(h, c0, c);
 801c338: 69ba         	ldr	r2, [r7, #0x18]
 801c33a: 6a79         	ldr	r1, [r7, #0x24]
 801c33c: 6af8         	ldr	r0, [r7, #0x2c]
 801c33e: f7ff fde9    	bl	0x801bf14 <split_chunks> @ imm = #-0x42e
; 		free_list_add(h, c0);
 801c342: 6a79         	ldr	r1, [r7, #0x24]
 801c344: 6af8         	ldr	r0, [r7, #0x2c]
 801c346: f7ff fdc3    	bl	0x801bed0 <free_list_add> @ imm = #-0x47a
; 	if (right_chunk(h, c) > c_end) {
 801c34a: 69b9         	ldr	r1, [r7, #0x18]
 801c34c: 6af8         	ldr	r0, [r7, #0x2c]
 801c34e: f7ff fc4c    	bl	0x801bbea <right_chunk> @ imm = #-0x768
 801c352: 4602         	mov	r2, r0
 801c354: 697b         	ldr	r3, [r7, #0x14]
 801c356: 4293         	cmp	r3, r2
 801c358: d208         	bhs	0x801c36c <sys_heap_aligned_alloc+0x13e> @ imm = #0x10
; 		split_chunks(h, c, c_end);
 801c35a: 697a         	ldr	r2, [r7, #0x14]
 801c35c: 69b9         	ldr	r1, [r7, #0x18]
 801c35e: 6af8         	ldr	r0, [r7, #0x2c]
 801c360: f7ff fdd8    	bl	0x801bf14 <split_chunks> @ imm = #-0x450
; 		free_list_add(h, c_end);
 801c364: 6979         	ldr	r1, [r7, #0x14]
 801c366: 6af8         	ldr	r0, [r7, #0x2c]
 801c368: f7ff fdb2    	bl	0x801bed0 <free_list_add> @ imm = #-0x49c
; 	set_chunk_used(h, c, true);
 801c36c: 2201         	movs	r2, #0x1
 801c36e: 69b9         	ldr	r1, [r7, #0x18]
 801c370: 6af8         	ldr	r0, [r7, #0x2c]
 801c372: f7ff fb95    	bl	0x801baa0 <set_chunk_used> @ imm = #-0x8d6
; 	return mem;
 801c376: 6a3b         	ldr	r3, [r7, #0x20]
; }
 801c378: 4618         	mov	r0, r3
 801c37a: 3738         	adds	r7, #0x38
 801c37c: 46bd         	mov	sp, r7
 801c37e: bd80         	pop	{r7, pc}

0801c380 <sys_heap_init>:
; {
 801c380: b580         	push	{r7, lr}
 801c382: b08c         	sub	sp, #0x30
 801c384: af00         	add	r7, sp, #0x0
 801c386: 60f8         	str	r0, [r7, #0xc]
 801c388: 60b9         	str	r1, [r7, #0x8]
 801c38a: 607a         	str	r2, [r7, #0x4]
; 	bytes -= heap_footer_bytes(bytes);
 801c38c: 6878         	ldr	r0, [r7, #0x4]
 801c38e: f7ff fc79    	bl	0x801bc84 <heap_footer_bytes> @ imm = #-0x70e
 801c392: 4602         	mov	r2, r0
 801c394: 687b         	ldr	r3, [r7, #0x4]
 801c396: 1a9b         	subs	r3, r3, r2
 801c398: 607b         	str	r3, [r7, #0x4]
; 	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 801c39a: 68bb         	ldr	r3, [r7, #0x8]
 801c39c: 3307         	adds	r3, #0x7
 801c39e: f023 0307    	bic	r3, r3, #0x7
 801c3a2: 62bb         	str	r3, [r7, #0x28]
; 	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 801c3a4: 68ba         	ldr	r2, [r7, #0x8]
 801c3a6: 687b         	ldr	r3, [r7, #0x4]
 801c3a8: 4413         	add	r3, r2
 801c3aa: f023 0307    	bic	r3, r3, #0x7
 801c3ae: 627b         	str	r3, [r7, #0x24]
; 	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
 801c3b0: 6a7a         	ldr	r2, [r7, #0x24]
 801c3b2: 6abb         	ldr	r3, [r7, #0x28]
 801c3b4: 1ad3         	subs	r3, r2, r3
 801c3b6: 08db         	lsrs	r3, r3, #0x3
 801c3b8: 623b         	str	r3, [r7, #0x20]
; 	struct z_heap *h = (struct z_heap *)addr;
 801c3ba: 6abb         	ldr	r3, [r7, #0x28]
 801c3bc: 61fb         	str	r3, [r7, #0x1c]
; 	heap->heap = h;
 801c3be: 68fb         	ldr	r3, [r7, #0xc]
 801c3c0: 69fa         	ldr	r2, [r7, #0x1c]
 801c3c2: 601a         	str	r2, [r3]
; 	h->end_chunk = heap_sz;
 801c3c4: 69fb         	ldr	r3, [r7, #0x1c]
 801c3c6: 6a3a         	ldr	r2, [r7, #0x20]
 801c3c8: 609a         	str	r2, [r3, #0x8]
; 	h->avail_buckets = 0;
 801c3ca: 69fb         	ldr	r3, [r7, #0x1c]
 801c3cc: 2200         	movs	r2, #0x0
 801c3ce: 60da         	str	r2, [r3, #0xc]
; 	int nb_buckets = bucket_idx(h, heap_sz) + 1;
 801c3d0: 6a39         	ldr	r1, [r7, #0x20]
 801c3d2: 69f8         	ldr	r0, [r7, #0x1c]
 801c3d4: f7ff fc94    	bl	0x801bd00 <bucket_idx>  @ imm = #-0x6d8
 801c3d8: 4603         	mov	r3, r0
 801c3da: 3301         	adds	r3, #0x1
 801c3dc: 61bb         	str	r3, [r7, #0x18]
; 	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
 801c3de: 69bb         	ldr	r3, [r7, #0x18]
 801c3e0: 3304         	adds	r3, #0x4
 801c3e2: 009b         	lsls	r3, r3, #0x2
 801c3e4: 4618         	mov	r0, r3
 801c3e6: f7ff fc5e    	bl	0x801bca6 <chunksz>     @ imm = #-0x744
 801c3ea: 6178         	str	r0, [r7, #0x14]
; 	for (int i = 0; i < nb_buckets; i++) {
 801c3ec: 2300         	movs	r3, #0x0
 801c3ee: 62fb         	str	r3, [r7, #0x2c]
 801c3f0: e008         	b	0x801c404 <sys_heap_init+0x84> @ imm = #0x10
; 		h->buckets[i].next = 0;
 801c3f2: 69fb         	ldr	r3, [r7, #0x1c]
 801c3f4: 6afa         	ldr	r2, [r7, #0x2c]
 801c3f6: 3204         	adds	r2, #0x4
 801c3f8: 2100         	movs	r1, #0x0
 801c3fa: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 	for (int i = 0; i < nb_buckets; i++) {
 801c3fe: 6afb         	ldr	r3, [r7, #0x2c]
 801c400: 3301         	adds	r3, #0x1
 801c402: 62fb         	str	r3, [r7, #0x2c]
 801c404: 6afa         	ldr	r2, [r7, #0x2c]
 801c406: 69bb         	ldr	r3, [r7, #0x18]
 801c408: 429a         	cmp	r2, r3
 801c40a: dbf2         	blt	0x801c3f2 <sys_heap_init+0x72> @ imm = #-0x1c
; 	set_chunk_size(h, 0, chunk0_size);
 801c40c: 697a         	ldr	r2, [r7, #0x14]
 801c40e: 2100         	movs	r1, #0x0
 801c410: 69f8         	ldr	r0, [r7, #0x1c]
 801c412: f7ff fb8a    	bl	0x801bb2a <set_chunk_size> @ imm = #-0x8ec
; 	set_left_chunk_size(h, 0, 0);
 801c416: 2200         	movs	r2, #0x0
 801c418: 2100         	movs	r1, #0x0
 801c41a: 69f8         	ldr	r0, [r7, #0x1c]
 801c41c: f7ff fbf5    	bl	0x801bc0a <set_left_chunk_size> @ imm = #-0x816
; 	set_chunk_used(h, 0, true);
 801c420: 2201         	movs	r2, #0x1
 801c422: 2100         	movs	r1, #0x0
 801c424: 69f8         	ldr	r0, [r7, #0x1c]
 801c426: f7ff fb3b    	bl	0x801baa0 <set_chunk_used> @ imm = #-0x98a
; 	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
 801c42a: 6a3a         	ldr	r2, [r7, #0x20]
 801c42c: 697b         	ldr	r3, [r7, #0x14]
 801c42e: 1ad3         	subs	r3, r2, r3
 801c430: 461a         	mov	r2, r3
 801c432: 6979         	ldr	r1, [r7, #0x14]
 801c434: 69f8         	ldr	r0, [r7, #0x1c]
 801c436: f7ff fb78    	bl	0x801bb2a <set_chunk_size> @ imm = #-0x910
; 	set_left_chunk_size(h, chunk0_size, chunk0_size);
 801c43a: 697a         	ldr	r2, [r7, #0x14]
 801c43c: 6979         	ldr	r1, [r7, #0x14]
 801c43e: 69f8         	ldr	r0, [r7, #0x1c]
 801c440: f7ff fbe3    	bl	0x801bc0a <set_left_chunk_size> @ imm = #-0x83a
; 	set_chunk_size(h, heap_sz, 0);
 801c444: 2200         	movs	r2, #0x0
 801c446: 6a39         	ldr	r1, [r7, #0x20]
 801c448: 69f8         	ldr	r0, [r7, #0x1c]
 801c44a: f7ff fb6e    	bl	0x801bb2a <set_chunk_size> @ imm = #-0x924
; 	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
 801c44e: 6a3a         	ldr	r2, [r7, #0x20]
 801c450: 697b         	ldr	r3, [r7, #0x14]
 801c452: 1ad3         	subs	r3, r2, r3
 801c454: 461a         	mov	r2, r3
 801c456: 6a39         	ldr	r1, [r7, #0x20]
 801c458: 69f8         	ldr	r0, [r7, #0x1c]
 801c45a: f7ff fbd6    	bl	0x801bc0a <set_left_chunk_size> @ imm = #-0x854
; 	set_chunk_used(h, heap_sz, true);
 801c45e: 2201         	movs	r2, #0x1
 801c460: 6a39         	ldr	r1, [r7, #0x20]
 801c462: 69f8         	ldr	r0, [r7, #0x1c]
 801c464: f7ff fb1c    	bl	0x801baa0 <set_chunk_used> @ imm = #-0x9c8
; 	free_list_add(h, chunk0_size);
 801c468: 6979         	ldr	r1, [r7, #0x14]
 801c46a: 69f8         	ldr	r0, [r7, #0x1c]
 801c46c: f7ff fd30    	bl	0x801bed0 <free_list_add> @ imm = #-0x5a0
; }
 801c470: bf00         	nop
 801c472: 3730         	adds	r7, #0x30
 801c474: 46bd         	mov	sp, r7
 801c476: bd80         	pop	{r7, pc}

0801c478 <ptr_in_rodata>:
; {
 801c478: b580         	push	{r7, lr}
 801c47a: b082         	sub	sp, #0x8
 801c47c: af00         	add	r7, sp, #0x0
 801c47e: 6078         	str	r0, [r7, #0x4]
; 	return linker_is_in_rodata(addr);
 801c480: 6878         	ldr	r0, [r7, #0x4]
 801c482: f7e7 fab3    	bl	0x80039ec <linker_is_in_rodata> @ imm = #-0x18a9a
 801c486: 4603         	mov	r3, r0
; }
 801c488: 4618         	mov	r0, r3
 801c48a: 3708         	adds	r7, #0x8
 801c48c: 46bd         	mov	sp, r7
 801c48e: bd80         	pop	{r7, pc}

0801c490 <cbprintf_via_va_list>:
; {
 801c490: b590         	push	{r4, r7, lr}
 801c492: b087         	sub	sp, #0x1c
 801c494: af00         	add	r7, sp, #0x0
 801c496: 60f8         	str	r0, [r7, #0xc]
 801c498: 60b9         	str	r1, [r7, #0x8]
 801c49a: 607a         	str	r2, [r7, #0x4]
 801c49c: 603b         	str	r3, [r7]
; 	u.ptr = buf;
 801c49e: 6abb         	ldr	r3, [r7, #0x28]
 801c4a0: 617b         	str	r3, [r7, #0x14]
; 	return formatter(out, ctx, fmt, u.ap);
 801c4a2: 68bc         	ldr	r4, [r7, #0x8]
 801c4a4: 697b         	ldr	r3, [r7, #0x14]
 801c4a6: 683a         	ldr	r2, [r7]
 801c4a8: 6879         	ldr	r1, [r7, #0x4]
 801c4aa: 68f8         	ldr	r0, [r7, #0xc]
 801c4ac: 47a0         	blx	r4
 801c4ae: 4603         	mov	r3, r0
; }
 801c4b0: 4618         	mov	r0, r3
 801c4b2: 371c         	adds	r7, #0x1c
 801c4b4: 46bd         	mov	sp, r7
 801c4b6: bd90         	pop	{r4, r7, pc}

0801c4b8 <cbpprintf_external>:
; {
 801c4b8: b580         	push	{r7, lr}
 801c4ba: b090         	sub	sp, #0x40
 801c4bc: af02         	add	r7, sp, #0x8
 801c4be: 60f8         	str	r0, [r7, #0xc]
 801c4c0: 60b9         	str	r1, [r7, #0x8]
 801c4c2: 607a         	str	r2, [r7, #0x4]
 801c4c4: 603b         	str	r3, [r7]
; 	uint8_t *buf = packaged;
 801c4c6: 683b         	ldr	r3, [r7]
 801c4c8: 62fb         	str	r3, [r7, #0x2c]
; 	struct cbprintf_package_hdr_ext *hdr = packaged;
 801c4ca: 683b         	ldr	r3, [r7]
 801c4cc: 62bb         	str	r3, [r7, #0x28]
; 	if (buf == NULL) {
 801c4ce: 6afb         	ldr	r3, [r7, #0x2c]
 801c4d0: 2b00         	cmp	r3, #0x0
 801c4d2: d102         	bne	0x801c4da <cbpprintf_external+0x22> @ imm = #0x4
; 		return -EINVAL;
 801c4d4: f06f 0315    	mvn	r3, #0x15
 801c4d8: e043         	b	0x801c562 <cbpprintf_external+0xaa> @ imm = #0x86
; 	args_size = hdr->hdr.desc.len * sizeof(int);
 801c4da: 6abb         	ldr	r3, [r7, #0x28]
 801c4dc: 781b         	ldrb	r3, [r3]
 801c4de: 009b         	lsls	r3, r3, #0x2
 801c4e0: 627b         	str	r3, [r7, #0x24]
; 	s_nbr     = hdr->hdr.desc.str_cnt;
 801c4e2: 6abb         	ldr	r3, [r7, #0x28]
 801c4e4: 785b         	ldrb	r3, [r3, #0x1]
 801c4e6: 623b         	str	r3, [r7, #0x20]
; 	ros_nbr   = hdr->hdr.desc.ro_str_cnt;
 801c4e8: 6abb         	ldr	r3, [r7, #0x28]
 801c4ea: 789b         	ldrb	r3, [r3, #0x2]
 801c4ec: 61fb         	str	r3, [r7, #0x1c]
; 	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
 801c4ee: 6abb         	ldr	r3, [r7, #0x28]
 801c4f0: 78db         	ldrb	r3, [r3, #0x3]
 801c4f2: 61bb         	str	r3, [r7, #0x18]
; 	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
 801c4f4: 6a7a         	ldr	r2, [r7, #0x24]
 801c4f6: 69fb         	ldr	r3, [r7, #0x1c]
 801c4f8: 441a         	add	r2, r3
 801c4fa: 69bb         	ldr	r3, [r7, #0x18]
 801c4fc: 005b         	lsls	r3, r3, #0x1
 801c4fe: 4413         	add	r3, r2
 801c500: 6afa         	ldr	r2, [r7, #0x2c]
 801c502: 4413         	add	r3, r2
 801c504: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 801c506: 2300         	movs	r3, #0x0
 801c508: 633b         	str	r3, [r7, #0x30]
 801c50a: e018         	b	0x801c53e <cbpprintf_external+0x86> @ imm = #0x30
; 		s_idx = *(uint8_t *)s;
 801c50c: 6b7b         	ldr	r3, [r7, #0x34]
 801c50e: 781b         	ldrb	r3, [r3]
 801c510: 617b         	str	r3, [r7, #0x14]
; 		++s;
 801c512: 6b7b         	ldr	r3, [r7, #0x34]
 801c514: 3301         	adds	r3, #0x1
 801c516: 637b         	str	r3, [r7, #0x34]
; 		ps = (char **)(buf + s_idx * sizeof(int));
 801c518: 697b         	ldr	r3, [r7, #0x14]
 801c51a: 009b         	lsls	r3, r3, #0x2
 801c51c: 6afa         	ldr	r2, [r7, #0x2c]
 801c51e: 4413         	add	r3, r2
 801c520: 613b         	str	r3, [r7, #0x10]
; 		*ps = s;
 801c522: 693b         	ldr	r3, [r7, #0x10]
 801c524: 6b7a         	ldr	r2, [r7, #0x34]
 801c526: 601a         	str	r2, [r3]
; 		s += strlen(s) + 1;
 801c528: 6b78         	ldr	r0, [r7, #0x34]
 801c52a: f7e3 ff45    	bl	0x80003b8 <strlen>      @ imm = #-0x1c176
 801c52e: 4603         	mov	r3, r0
 801c530: 3301         	adds	r3, #0x1
 801c532: 6b7a         	ldr	r2, [r7, #0x34]
 801c534: 4413         	add	r3, r2
 801c536: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 801c538: 6b3b         	ldr	r3, [r7, #0x30]
 801c53a: 3301         	adds	r3, #0x1
 801c53c: 633b         	str	r3, [r7, #0x30]
 801c53e: 6b3a         	ldr	r2, [r7, #0x30]
 801c540: 6a3b         	ldr	r3, [r7, #0x20]
 801c542: 429a         	cmp	r2, r3
 801c544: d3e2         	blo	0x801c50c <cbpprintf_external+0x54> @ imm = #-0x3c
; 	buf += sizeof(*hdr);
 801c546: 6afb         	ldr	r3, [r7, #0x2c]
 801c548: 3308         	adds	r3, #0x8
 801c54a: 62fb         	str	r3, [r7, #0x2c]
; 	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
 801c54c: 6abb         	ldr	r3, [r7, #0x28]
 801c54e: 685a         	ldr	r2, [r3, #0x4]
 801c550: 6afb         	ldr	r3, [r7, #0x2c]
 801c552: 9300         	str	r3, [sp]
 801c554: 4613         	mov	r3, r2
 801c556: 687a         	ldr	r2, [r7, #0x4]
 801c558: 68b9         	ldr	r1, [r7, #0x8]
 801c55a: 68f8         	ldr	r0, [r7, #0xc]
 801c55c: f7ff ff98    	bl	0x801c490 <cbprintf_via_va_list> @ imm = #-0xd0
 801c560: 4603         	mov	r3, r0
; }
 801c562: 4618         	mov	r0, r3
 801c564: 3738         	adds	r7, #0x38
 801c566: 46bd         	mov	sp, r7
 801c568: bd80         	pop	{r7, pc}

0801c56a <arch_printk_char_out>:
; {
 801c56a: b480         	push	{r7}
 801c56c: b083         	sub	sp, #0xc
 801c56e: af00         	add	r7, sp, #0x0
 801c570: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801c572: 2300         	movs	r3, #0x0
; }
 801c574: 4618         	mov	r0, r3
 801c576: 370c         	adds	r7, #0xc
 801c578: 46bd         	mov	sp, r7
 801c57a: f85d 7b04    	ldr	r7, [sp], #4
 801c57e: 4770         	bx	lr

0801c580 <vprintk>:
; {
 801c580: b580         	push	{r7, lr}
 801c582: b08c         	sub	sp, #0x30
 801c584: af00         	add	r7, sp, #0x0
 801c586: 6078         	str	r0, [r7, #0x4]
 801c588: 6039         	str	r1, [r7]
; 		z_log_vprintk(fmt, ap);
 801c58a: 6839         	ldr	r1, [r7]
 801c58c: 6878         	ldr	r0, [r7, #0x4]
 801c58e: f000 f99d    	bl	0x801c8cc <z_log_vprintk> @ imm = #0x33a
; 		return;
 801c592: bf00         	nop
; }
 801c594: 3730         	adds	r7, #0x30
 801c596: 46bd         	mov	sp, r7
 801c598: bd80         	pop	{r7, pc}

0801c59a <printk>:
; {
 801c59a: b40f         	push	{r0, r1, r2, r3}
 801c59c: b580         	push	{r7, lr}
 801c59e: b082         	sub	sp, #0x8
 801c5a0: af00         	add	r7, sp, #0x0
; 	va_start(ap, fmt);
 801c5a2: f107 0314    	add.w	r3, r7, #0x14
 801c5a6: 607b         	str	r3, [r7, #0x4]
; 	vprintk(fmt, ap);
 801c5a8: 6879         	ldr	r1, [r7, #0x4]
 801c5aa: 6938         	ldr	r0, [r7, #0x10]
 801c5ac: f7ff ffe8    	bl	0x801c580 <vprintk>     @ imm = #-0x30
; }
 801c5b0: bf00         	nop
 801c5b2: 3708         	adds	r7, #0x8
 801c5b4: 46bd         	mov	sp, r7
 801c5b6: e8bd 4080    	pop.w	{r7, lr}
 801c5ba: b004         	add	sp, #0x10
 801c5bc: 4770         	bx	lr

0801c5be <k_sched_current_thread_query>:
; {
 801c5be: b580         	push	{r7, lr}
 801c5c0: af00         	add	r7, sp, #0x0
; 	return z_impl_k_sched_current_thread_query();
 801c5c2: f7fb f915    	bl	0x80177f0 <z_impl_k_sched_current_thread_query> @ imm = #-0x4dd6
 801c5c6: 4603         	mov	r3, r0
; }
 801c5c8: 4618         	mov	r0, r3
 801c5ca: bd80         	pop	{r7, pc}

0801c5cc <k_thread_abort>:
; {
 801c5cc: b580         	push	{r7, lr}
 801c5ce: b082         	sub	sp, #0x8
 801c5d0: af00         	add	r7, sp, #0x0
 801c5d2: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 801c5d4: 6878         	ldr	r0, [r7, #0x4]
 801c5d6: f7e9 fef3    	bl	0x80063c0 <z_impl_k_thread_abort> @ imm = #-0x1621a
; }
 801c5da: bf00         	nop
 801c5dc: 3708         	adds	r7, #0x8
 801c5de: 46bd         	mov	sp, r7
 801c5e0: bd80         	pop	{r7, pc}

0801c5e2 <_ConfigAbsSyms>:
; GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
 801c5e2: b480         	push	{r7}
 801c5e4: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 801c5e6: bf00         	nop
 801c5e8: 46bd         	mov	sp, r7
 801c5ea: f85d 7b04    	ldr	r7, [sp], #4
 801c5ee: 4770         	bx	lr

0801c5f0 <st_stm32_common_config>:
; {
 801c5f0: b580         	push	{r7, lr}
 801c5f2: af00         	add	r7, sp, #0x0
; 	LL_DBGMCU_DisableD1DebugInStopMode();
 801c5f4: f7e7 fe3a    	bl	0x800426c <LL_DBGMCU_DisableD1DebugInStopMode> @ imm = #-0x1838c
; 	LL_DBGMCU_DisableD1DebugInSleepMode();
 801c5f8: f7e7 fe28    	bl	0x800424c <LL_DBGMCU_DisableD1DebugInSleepMode> @ imm = #-0x183b0
; 	return 0;
 801c5fc: 2300         	movs	r3, #0x0
; }
 801c5fe: 4618         	mov	r0, r3
 801c600: bd80         	pop	{r7, pc}

0801c602 <K_KERNEL_STACK_BUFFER>:
; {
 801c602: b480         	push	{r7}
 801c604: b083         	sub	sp, #0xc
 801c606: af00         	add	r7, sp, #0x0
 801c608: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 801c60a: 687b         	ldr	r3, [r7, #0x4]
; }
 801c60c: 4618         	mov	r0, r3
 801c60e: 370c         	adds	r7, #0xc
 801c610: 46bd         	mov	sp, r7
 801c612: f85d 7b04    	ldr	r7, [sp], #4
 801c616: 4770         	bx	lr

0801c618 <k_thread_stack_space_get>:
; {
 801c618: b580         	push	{r7, lr}
 801c61a: b082         	sub	sp, #0x8
 801c61c: af00         	add	r7, sp, #0x0
 801c61e: 6078         	str	r0, [r7, #0x4]
 801c620: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
 801c622: 6839         	ldr	r1, [r7]
 801c624: 6878         	ldr	r0, [r7, #0x4]
 801c626: f00b fd75    	bl	0x8028114 <z_impl_k_thread_stack_space_get> @ imm = #0xbaea
 801c62a: 4603         	mov	r3, r0
; }
 801c62c: 4618         	mov	r0, r3
 801c62e: 3708         	adds	r7, #0x8
 801c630: 46bd         	mov	sp, r7
 801c632: bd80         	pop	{r7, pc}

0801c634 <z_log_msg_runtime_create>:
; {
 801c634: b580         	push	{r7, lr}
 801c636: b08a         	sub	sp, #0x28
 801c638: af04         	add	r7, sp, #0x10
 801c63a: 60b9         	str	r1, [r7, #0x8]
 801c63c: 607b         	str	r3, [r7, #0x4]
 801c63e: 4603         	mov	r3, r0
 801c640: 73fb         	strb	r3, [r7, #0xf]
 801c642: 4613         	mov	r3, r2
 801c644: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801c646: f107 032c    	add.w	r3, r7, #0x2c
 801c64a: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801c64c: 7bba         	ldrb	r2, [r7, #0xe]
 801c64e: 7bf8         	ldrb	r0, [r7, #0xf]
 801c650: 697b         	ldr	r3, [r7, #0x14]
 801c652: 9303         	str	r3, [sp, #0xc]
 801c654: 6abb         	ldr	r3, [r7, #0x28]
 801c656: 9302         	str	r3, [sp, #0x8]
 801c658: 6a7b         	ldr	r3, [r7, #0x24]
 801c65a: 9301         	str	r3, [sp, #0x4]
 801c65c: 6a3b         	ldr	r3, [r7, #0x20]
 801c65e: 9300         	str	r3, [sp]
 801c660: 687b         	ldr	r3, [r7, #0x4]
 801c662: 68b9         	ldr	r1, [r7, #0x8]
 801c664: f7e8 fa86    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x17af4
; }
 801c668: bf00         	nop
 801c66a: 3718         	adds	r7, #0x18
 801c66c: 46bd         	mov	sp, r7
 801c66e: bd80         	pop	{r7, pc}

0801c670 <isr_stacks>:
; {
 801c670: b580         	push	{r7, lr}
 801c672: b082         	sub	sp, #0x8
 801c674: af00         	add	r7, sp, #0x0
; 	return CONFIG_MP_MAX_NUM_CPUS;
 801c676: 2301         	movs	r3, #0x1
; 	unsigned int num_cpus = arch_num_cpus();
 801c678: 603b         	str	r3, [r7]
; 	for (int i = 0; i < num_cpus; i++) {
 801c67a: 2300         	movs	r3, #0x0
 801c67c: 607b         	str	r3, [r7, #0x4]
 801c67e: e005         	b	0x801c68c <isr_stacks+0x1c> @ imm = #0xa
; 		isr_stack(i);
 801c680: 6878         	ldr	r0, [r7, #0x4]
 801c682: f7e7 ffa7    	bl	0x80045d4 <isr_stack>   @ imm = #-0x180b2
; 	for (int i = 0; i < num_cpus; i++) {
 801c686: 687b         	ldr	r3, [r7, #0x4]
 801c688: 3301         	adds	r3, #0x1
 801c68a: 607b         	str	r3, [r7, #0x4]
 801c68c: 687b         	ldr	r3, [r7, #0x4]
 801c68e: 683a         	ldr	r2, [r7]
 801c690: 429a         	cmp	r2, r3
 801c692: d8f5         	bhi	0x801c680 <isr_stacks+0x10> @ imm = #-0x16
; }
 801c694: bf00         	nop
 801c696: bf00         	nop
 801c698: 3708         	adds	r7, #0x8
 801c69a: 46bd         	mov	sp, r7
 801c69c: bd80         	pop	{r7, pc}

0801c69e <atomic_add>:
; {
 801c69e: b490         	push	{r4, r7}
 801c6a0: b082         	sub	sp, #0x8
 801c6a2: af00         	add	r7, sp, #0x0
 801c6a4: 6078         	str	r0, [r7, #0x4]
 801c6a6: 6039         	str	r1, [r7]
; 	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 801c6a8: 683a         	ldr	r2, [r7]
 801c6aa: 687b         	ldr	r3, [r7, #0x4]
 801c6ac: f3bf 8f5b    	dmb	ish
 801c6b0: e853 1f00    	ldrex	r1, [r3]
 801c6b4: eb01 0002    	add.w	r0, r1, r2
 801c6b8: e843 0400    	strex	r4, r0, [r3]
 801c6bc: 2c00         	cmp	r4, #0x0
 801c6be: d1f7         	bne	0x801c6b0 <atomic_add+0x12> @ imm = #-0x12
 801c6c0: f3bf 8f5b    	dmb	ish
 801c6c4: 460b         	mov	r3, r1
; }
 801c6c6: 4618         	mov	r0, r3
 801c6c8: 3708         	adds	r7, #0x8
 801c6ca: 46bd         	mov	sp, r7
 801c6cc: bc90         	pop	{r4, r7}
 801c6ce: 4770         	bx	lr

0801c6d0 <atomic_sub>:
; {
 801c6d0: b490         	push	{r4, r7}
 801c6d2: b082         	sub	sp, #0x8
 801c6d4: af00         	add	r7, sp, #0x0
 801c6d6: 6078         	str	r0, [r7, #0x4]
 801c6d8: 6039         	str	r1, [r7]
; 	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 801c6da: 683a         	ldr	r2, [r7]
 801c6dc: 687b         	ldr	r3, [r7, #0x4]
 801c6de: f3bf 8f5b    	dmb	ish
 801c6e2: e853 1f00    	ldrex	r1, [r3]
 801c6e6: eba1 0002    	sub.w	r0, r1, r2
 801c6ea: e843 0400    	strex	r4, r0, [r3]
 801c6ee: 2c00         	cmp	r4, #0x0
 801c6f0: d1f7         	bne	0x801c6e2 <atomic_sub+0x12> @ imm = #-0x12
 801c6f2: f3bf 8f5b    	dmb	ish
 801c6f6: 460b         	mov	r3, r1
; }
 801c6f8: 4618         	mov	r0, r3
 801c6fa: 3708         	adds	r7, #0x8
 801c6fc: 46bd         	mov	sp, r7
 801c6fe: bc90         	pop	{r4, r7}
 801c700: 4770         	bx	lr

0801c702 <atomic_inc>:
; {
 801c702: b580         	push	{r7, lr}
 801c704: b082         	sub	sp, #0x8
 801c706: af00         	add	r7, sp, #0x0
 801c708: 6078         	str	r0, [r7, #0x4]
; 	return atomic_add(target, 1);
 801c70a: 2101         	movs	r1, #0x1
 801c70c: 6878         	ldr	r0, [r7, #0x4]
 801c70e: f7ff ffc6    	bl	0x801c69e <atomic_add>  @ imm = #-0x74
 801c712: 4603         	mov	r3, r0
; }
 801c714: 4618         	mov	r0, r3
 801c716: 3708         	adds	r7, #0x8
 801c718: 46bd         	mov	sp, r7
 801c71a: bd80         	pop	{r7, pc}

0801c71c <atomic_dec>:
; {
 801c71c: b580         	push	{r7, lr}
 801c71e: b082         	sub	sp, #0x8
 801c720: af00         	add	r7, sp, #0x0
 801c722: 6078         	str	r0, [r7, #0x4]
; 	return atomic_sub(target, 1);
 801c724: 2101         	movs	r1, #0x1
 801c726: 6878         	ldr	r0, [r7, #0x4]
 801c728: f7ff ffd2    	bl	0x801c6d0 <atomic_sub>  @ imm = #-0x5c
 801c72c: 4603         	mov	r3, r0
; }
 801c72e: 4618         	mov	r0, r3
 801c730: 3708         	adds	r7, #0x8
 801c732: 46bd         	mov	sp, r7
 801c734: bd80         	pop	{r7, pc}

0801c736 <z_log_item_is_msg>:
; {
 801c736: b480         	push	{r7}
 801c738: b083         	sub	sp, #0xc
 801c73a: af00         	add	r7, sp, #0x0
 801c73c: 6078         	str	r0, [r7, #0x4]
; 	return msg->generic.type == Z_LOG_MSG_LOG;
 801c73e: 687b         	ldr	r3, [r7, #0x4]
 801c740: 781b         	ldrb	r3, [r3]
 801c742: f003 0304    	and	r3, r3, #0x4
 801c746: b2db         	uxtb	r3, r3
 801c748: 2b00         	cmp	r3, #0x0
 801c74a: bf0c         	ite	eq
 801c74c: 2301         	moveq	r3, #0x1
 801c74e: 2300         	movne	r3, #0x0
 801c750: b2db         	uxtb	r3, r3
; }
 801c752: 4618         	mov	r0, r3
 801c754: 370c         	adds	r7, #0xc
 801c756: 46bd         	mov	sp, r7
 801c758: f85d 7b04    	ldr	r7, [sp], #4
 801c75c: 4770         	bx	lr

0801c75e <k_msleep>:
; {
 801c75e: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 801c762: b082         	sub	sp, #0x8
 801c764: af00         	add	r7, sp, #0x0
 801c766: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 801c768: 6879         	ldr	r1, [r7, #0x4]
 801c76a: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 801c76e: 17c8         	asrs	r0, r1, #0x1f
 801c770: 4688         	mov	r8, r1
 801c772: 4681         	mov	r9, r0
 801c774: 4640         	mov	r0, r8
 801c776: 4649         	mov	r1, r9
 801c778: f04f 0400    	mov.w	r4, #0x0
 801c77c: f04f 0500    	mov.w	r5, #0x0
 801c780: 008d         	lsls	r5, r1, #0x2
 801c782: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 801c786: 0084         	lsls	r4, r0, #0x2
 801c788: 4620         	mov	r0, r4
 801c78a: 4629         	mov	r1, r5
 801c78c: eb10 0208    	adds.w	r2, r0, r8
 801c790: eb41 0309    	adc.w	r3, r1, r9
 801c794: eb12 0a02    	adds.w	r10, r2, r2
 801c798: eb43 0b03    	adc.w	r11, r3, r3
 801c79c: 4652         	mov	r2, r10
 801c79e: 465b         	mov	r3, r11
 801c7a0: 4610         	mov	r0, r2
 801c7a2: 4619         	mov	r1, r3
 801c7a4: f000 f823    	bl	0x801c7ee <k_sleep>     @ imm = #0x46
 801c7a8: 4601         	mov	r1, r0
 801c7aa: 460b         	mov	r3, r1
; }
 801c7ac: 4618         	mov	r0, r3
 801c7ae: 3708         	adds	r7, #0x8
 801c7b0: 46bd         	mov	sp, r7
 801c7b2: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0801c7b6 <k_uptime_get>:
; {
 801c7b6: b580         	push	{r7, lr}
 801c7b8: af00         	add	r7, sp, #0x0
; 	return k_ticks_to_ms_floor64(k_uptime_ticks());
 801c7ba: f000 f826    	bl	0x801c80a <k_uptime_ticks> @ imm = #0x4c
 801c7be: 4602         	mov	r2, r0
 801c7c0: 460b         	mov	r3, r1
 801c7c2: 4610         	mov	r0, r2
 801c7c4: 4619         	mov	r1, r3
 801c7c6: f04f 020a    	mov.w	r2, #0xa
 801c7ca: f04f 0300    	mov.w	r3, #0x0
 801c7ce: f7e3 fdcf    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x1c462
 801c7d2: 4602         	mov	r2, r0
 801c7d4: 460b         	mov	r3, r1
; }
 801c7d6: 4610         	mov	r0, r2
 801c7d8: 4619         	mov	r1, r3
 801c7da: bd80         	pop	{r7, pc}

0801c7dc <k_uptime_get_32>:
; {
 801c7dc: b580         	push	{r7, lr}
 801c7de: af00         	add	r7, sp, #0x0
; 	return (uint32_t)k_uptime_get();
 801c7e0: f7ff ffe9    	bl	0x801c7b6 <k_uptime_get> @ imm = #-0x2e
 801c7e4: 4602         	mov	r2, r0
 801c7e6: 460b         	mov	r3, r1
 801c7e8: 4613         	mov	r3, r2
; }
 801c7ea: 4618         	mov	r0, r3
 801c7ec: bd80         	pop	{r7, pc}

0801c7ee <k_sleep>:
; {
 801c7ee: b580         	push	{r7, lr}
 801c7f0: b082         	sub	sp, #0x8
 801c7f2: af00         	add	r7, sp, #0x0
 801c7f4: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 801c7f8: e9d7 0100    	ldrd	r0, r1, [r7]
 801c7fc: f7fa ffb6    	bl	0x801776c <z_impl_k_sleep> @ imm = #-0x5094
 801c800: 4603         	mov	r3, r0
; }
 801c802: 4618         	mov	r0, r3
 801c804: 3708         	adds	r7, #0x8
 801c806: 46bd         	mov	sp, r7
 801c808: bd80         	pop	{r7, pc}

0801c80a <k_uptime_ticks>:
; {
 801c80a: b580         	push	{r7, lr}
 801c80c: af00         	add	r7, sp, #0x0
; 	return z_impl_k_uptime_ticks();
 801c80e: f00c fae4    	bl	0x8028dda <z_impl_k_uptime_ticks> @ imm = #0xc5c8
 801c812: 4602         	mov	r2, r0
 801c814: 460b         	mov	r3, r1
; }
 801c816: 4610         	mov	r0, r2
 801c818: 4619         	mov	r1, r3
 801c81a: bd80         	pop	{r7, pc}

0801c81c <log_backend_init>:
; {
 801c81c: b580         	push	{r7, lr}
 801c81e: b082         	sub	sp, #0x8
 801c820: af00         	add	r7, sp, #0x0
 801c822: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->init) {
 801c824: 687b         	ldr	r3, [r7, #0x4]
 801c826: 681b         	ldr	r3, [r3]
 801c828: 68db         	ldr	r3, [r3, #0xc]
 801c82a: 2b00         	cmp	r3, #0x0
 801c82c: d004         	beq	0x801c838 <log_backend_init+0x1c> @ imm = #0x8
; 		backend->api->init(backend);
 801c82e: 687b         	ldr	r3, [r7, #0x4]
 801c830: 681b         	ldr	r3, [r3]
 801c832: 68db         	ldr	r3, [r3, #0xc]
 801c834: 6878         	ldr	r0, [r7, #0x4]
 801c836: 4798         	blx	r3
; }
 801c838: bf00         	nop
 801c83a: 3708         	adds	r7, #0x8
 801c83c: 46bd         	mov	sp, r7
 801c83e: bd80         	pop	{r7, pc}

0801c840 <log_backend_is_ready>:
; {
 801c840: b580         	push	{r7, lr}
 801c842: b082         	sub	sp, #0x8
 801c844: af00         	add	r7, sp, #0x0
 801c846: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->is_ready != NULL) {
 801c848: 687b         	ldr	r3, [r7, #0x4]
 801c84a: 681b         	ldr	r3, [r3]
 801c84c: 691b         	ldr	r3, [r3, #0x10]
 801c84e: 2b00         	cmp	r3, #0x0
 801c850: d006         	beq	0x801c860 <log_backend_is_ready+0x20> @ imm = #0xc
; 		return backend->api->is_ready(backend);
 801c852: 687b         	ldr	r3, [r7, #0x4]
 801c854: 681b         	ldr	r3, [r3]
 801c856: 691b         	ldr	r3, [r3, #0x10]
 801c858: 6878         	ldr	r0, [r7, #0x4]
 801c85a: 4798         	blx	r3
 801c85c: 4603         	mov	r3, r0
 801c85e: e000         	b	0x801c862 <log_backend_is_ready+0x22> @ imm = #0x0
; 	return 0;
 801c860: 2300         	movs	r3, #0x0
; }
 801c862: 4618         	mov	r0, r3
 801c864: 3708         	adds	r7, #0x8
 801c866: 46bd         	mov	sp, r7
 801c868: bd80         	pop	{r7, pc}

0801c86a <log_backend_msg_process>:
; {
 801c86a: b580         	push	{r7, lr}
 801c86c: b082         	sub	sp, #0x8
 801c86e: af00         	add	r7, sp, #0x0
 801c870: 6078         	str	r0, [r7, #0x4]
 801c872: 6039         	str	r1, [r7]
; 	backend->api->process(backend, msg);
 801c874: 687b         	ldr	r3, [r7, #0x4]
 801c876: 681b         	ldr	r3, [r3]
 801c878: 681b         	ldr	r3, [r3]
 801c87a: 6839         	ldr	r1, [r7]
 801c87c: 6878         	ldr	r0, [r7, #0x4]
 801c87e: 4798         	blx	r3
; }
 801c880: bf00         	nop
 801c882: 3708         	adds	r7, #0x8
 801c884: 46bd         	mov	sp, r7
 801c886: bd80         	pop	{r7, pc}

0801c888 <log_backend_panic>:
; {
 801c888: b580         	push	{r7, lr}
 801c88a: b082         	sub	sp, #0x8
 801c88c: af00         	add	r7, sp, #0x0
 801c88e: 6078         	str	r0, [r7, #0x4]
; 	backend->api->panic(backend);
 801c890: 687b         	ldr	r3, [r7, #0x4]
 801c892: 681b         	ldr	r3, [r3]
 801c894: 689b         	ldr	r3, [r3, #0x8]
 801c896: 6878         	ldr	r0, [r7, #0x4]
 801c898: 4798         	blx	r3
; }
 801c89a: bf00         	nop
 801c89c: 3708         	adds	r7, #0x8
 801c89e: 46bd         	mov	sp, r7
 801c8a0: bd80         	pop	{r7, pc}

0801c8a2 <log_backend_is_active>:
; {
 801c8a2: b480         	push	{r7}
 801c8a4: b083         	sub	sp, #0xc
 801c8a6: af00         	add	r7, sp, #0x0
 801c8a8: 6078         	str	r0, [r7, #0x4]
; 	return backend->cb->active;
 801c8aa: 687b         	ldr	r3, [r7, #0x4]
 801c8ac: 685b         	ldr	r3, [r3, #0x4]
 801c8ae: 795b         	ldrb	r3, [r3, #0x5]
; }
 801c8b0: 4618         	mov	r0, r3
 801c8b2: 370c         	adds	r7, #0xc
 801c8b4: 46bd         	mov	sp, r7
 801c8b6: f85d 7b04    	ldr	r7, [sp], #4
 801c8ba: 4770         	bx	lr

0801c8bc <dummy_timestamp>:
; {
 801c8bc: b480         	push	{r7}
 801c8be: af00         	add	r7, sp, #0x0
; 	return 0;
 801c8c0: 2300         	movs	r3, #0x0
; }
 801c8c2: 4618         	mov	r0, r3
 801c8c4: 46bd         	mov	sp, r7
 801c8c6: f85d 7b04    	ldr	r7, [sp], #4
 801c8ca: 4770         	bx	lr

0801c8cc <z_log_vprintk>:
; {
 801c8cc: b580         	push	{r7, lr}
 801c8ce: b086         	sub	sp, #0x18
 801c8d0: af04         	add	r7, sp, #0x10
 801c8d2: 6078         	str	r0, [r7, #0x4]
 801c8d4: 6039         	str	r1, [r7]
; 	z_log_msg_runtime_vcreate(Z_LOG_LOCAL_DOMAIN_ID, NULL,
 801c8d6: 683b         	ldr	r3, [r7]
 801c8d8: 9303         	str	r3, [sp, #0xc]
 801c8da: 687b         	ldr	r3, [r7, #0x4]
 801c8dc: 9302         	str	r3, [sp, #0x8]
 801c8de: 2300         	movs	r3, #0x0
 801c8e0: 9301         	str	r3, [sp, #0x4]
 801c8e2: 2300         	movs	r3, #0x0
 801c8e4: 9300         	str	r3, [sp]
 801c8e6: 2300         	movs	r3, #0x0
 801c8e8: 2200         	movs	r2, #0x0
 801c8ea: 2100         	movs	r1, #0x0
 801c8ec: 2000         	movs	r0, #0x0
 801c8ee: f7e8 f941    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x17d7e
; }
 801c8f2: 3708         	adds	r7, #0x8
 801c8f4: 46bd         	mov	sp, r7
 801c8f6: bd80         	pop	{r7, pc}

0801c8f8 <default_lf_get_timestamp>:
; {
 801c8f8: b580         	push	{r7, lr}
 801c8fa: af00         	add	r7, sp, #0x0
; 		k_uptime_get() : k_uptime_get_32();
 801c8fc: f7ff ff6e    	bl	0x801c7dc <k_uptime_get_32> @ imm = #-0x124
 801c900: 4603         	mov	r3, r0
; }
 801c902: 4618         	mov	r0, r3
 801c904: bd80         	pop	{r7, pc}

0801c906 <activate_foreach_backend>:
; {
 801c906: b580         	push	{r7, lr}
 801c908: b086         	sub	sp, #0x18
 801c90a: af00         	add	r7, sp, #0x0
 801c90c: 6078         	str	r0, [r7, #0x4]
; 	uint32_t mask_cpy = mask;
 801c90e: 687b         	ldr	r3, [r7, #0x4]
 801c910: 617b         	str	r3, [r7, #0x14]
; 	while (mask_cpy) {
 801c912: e02b         	b	0x801c96c <activate_foreach_backend+0x66> @ imm = #0x56
; 		uint32_t i = __builtin_ctz(mask_cpy);
 801c914: 697b         	ldr	r3, [r7, #0x14]
 801c916: fa93 f3a3    	rbit	r3, r3
 801c91a: fab3 f383    	clz	r3, r3
 801c91e: 613b         	str	r3, [r7, #0x10]
; 		const struct log_backend *backend = log_backend_get(i);
 801c920: 6938         	ldr	r0, [r7, #0x10]
 801c922: f7e7 fef3    	bl	0x800470c <log_backend_get> @ imm = #-0x1821a
 801c926: 60f8         	str	r0, [r7, #0xc]
; 		mask_cpy &= ~BIT(i);
 801c928: 2201         	movs	r2, #0x1
 801c92a: 693b         	ldr	r3, [r7, #0x10]
 801c92c: fa02 f303    	lsl.w	r3, r2, r3
 801c930: 43db         	mvns	r3, r3
 801c932: 697a         	ldr	r2, [r7, #0x14]
 801c934: 4013         	ands	r3, r2
 801c936: 617b         	str	r3, [r7, #0x14]
; 		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
 801c938: 68fb         	ldr	r3, [r7, #0xc]
 801c93a: 7b1b         	ldrb	r3, [r3, #0xc]
 801c93c: 2b00         	cmp	r3, #0x0
 801c93e: d015         	beq	0x801c96c <activate_foreach_backend+0x66> @ imm = #0x2a
 801c940: 68f8         	ldr	r0, [r7, #0xc]
 801c942: f7ff ff7d    	bl	0x801c840 <log_backend_is_ready> @ imm = #-0x106
 801c946: 4603         	mov	r3, r0
 801c948: 2b00         	cmp	r3, #0x0
 801c94a: d10f         	bne	0x801c96c <activate_foreach_backend+0x66> @ imm = #0x1e
; 			mask &= ~BIT(i);
 801c94c: 2201         	movs	r2, #0x1
 801c94e: 693b         	ldr	r3, [r7, #0x10]
 801c950: fa02 f303    	lsl.w	r3, r2, r3
 801c954: 43db         	mvns	r3, r3
 801c956: 687a         	ldr	r2, [r7, #0x4]
 801c958: 4013         	ands	r3, r2
 801c95a: 607b         	str	r3, [r7, #0x4]
; 					   backend->cb->ctx,
 801c95c: 68fb         	ldr	r3, [r7, #0xc]
 801c95e: 685b         	ldr	r3, [r3, #0x4]
; 			log_backend_enable(backend,
 801c960: 681b         	ldr	r3, [r3]
 801c962: 2204         	movs	r2, #0x4
 801c964: 4619         	mov	r1, r3
 801c966: 68f8         	ldr	r0, [r7, #0xc]
 801c968: f000 f8ce    	bl	0x801cb08 <log_backend_enable> @ imm = #0x19c
; 	while (mask_cpy) {
 801c96c: 697b         	ldr	r3, [r7, #0x14]
 801c96e: 2b00         	cmp	r3, #0x0
 801c970: d1d0         	bne	0x801c914 <activate_foreach_backend+0xe> @ imm = #-0x60
; 	return mask;
 801c972: 687b         	ldr	r3, [r7, #0x4]
; }
 801c974: 4618         	mov	r0, r3
 801c976: 3718         	adds	r7, #0x18
 801c978: 46bd         	mov	sp, r7
 801c97a: bd80         	pop	{r7, pc}

0801c97c <msg_filter_check>:
; {
 801c97c: b580         	push	{r7, lr}
 801c97e: b082         	sub	sp, #0x8
 801c980: af00         	add	r7, sp, #0x0
 801c982: 6078         	str	r0, [r7, #0x4]
 801c984: 6039         	str	r1, [r7]
; 	if (!z_log_item_is_msg(msg)) {
 801c986: 6838         	ldr	r0, [r7]
 801c988: f7ff fed5    	bl	0x801c736 <z_log_item_is_msg> @ imm = #-0x256
 801c98c: 4603         	mov	r3, r0
 801c98e: f083 0301    	eor	r3, r3, #0x1
 801c992: b2db         	uxtb	r3, r3
 801c994: 2b00         	cmp	r3, #0x0
 801c996: d001         	beq	0x801c99c <msg_filter_check+0x20> @ imm = #0x2
; 		return true;
 801c998: 2301         	movs	r3, #0x1
 801c99a: e000         	b	0x801c99e <msg_filter_check+0x22> @ imm = #0x0
; 		return true;
 801c99c: 2301         	movs	r3, #0x1
; }
 801c99e: 4618         	mov	r0, r3
 801c9a0: 3708         	adds	r7, #0x8
 801c9a2: 46bd         	mov	sp, r7
 801c9a4: bd80         	pop	{r7, pc}

0801c9a6 <msg_commit>:
; {
 801c9a6: b580         	push	{r7, lr}
 801c9a8: b084         	sub	sp, #0x10
 801c9aa: af00         	add	r7, sp, #0x0
 801c9ac: 6078         	str	r0, [r7, #0x4]
 801c9ae: 6039         	str	r1, [r7]
; 	union log_msg_generic *m = (union log_msg_generic *)msg;
 801c9b0: 683b         	ldr	r3, [r7]
 801c9b2: 60fb         	str	r3, [r7, #0xc]
; 		msg_process(m);
 801c9b4: 68f8         	ldr	r0, [r7, #0xc]
 801c9b6: f7e7 ff95    	bl	0x80048e4 <msg_process> @ imm = #-0x180d6
; }
 801c9ba: 3710         	adds	r7, #0x10
 801c9bc: 46bd         	mov	sp, r7
 801c9be: bd80         	pop	{r7, pc}

0801c9c0 <z_log_get_tag>:
; {
 801c9c0: b480         	push	{r7}
 801c9c2: af00         	add	r7, sp, #0x0
; 	return CONFIG_LOG_TAG_MAX_LEN > 0 ? tag : NULL;
 801c9c4: 2300         	movs	r3, #0x0
; }
 801c9c6: 4618         	mov	r0, r3
 801c9c8: 46bd         	mov	sp, r7
 801c9ca: f85d 7b04    	ldr	r7, [sp], #4
 801c9ce: 4770         	bx	lr

0801c9d0 <enable_logger>:
; {
 801c9d0: b580         	push	{r7, lr}
 801c9d2: af00         	add	r7, sp, #0x0
; 		(void)z_log_init(false, false);
 801c9d4: 2100         	movs	r1, #0x0
 801c9d6: 2000         	movs	r0, #0x0
 801c9d8: f7e7 fed4    	bl	0x8004784 <z_log_init>  @ imm = #-0x18258
; 	return 0;
 801c9dc: 2300         	movs	r3, #0x0
; }
 801c9de: 4618         	mov	r0, r3
 801c9e0: bd80         	pop	{r7, pc}

0801c9e2 <z_log_is_local_domain>:
; {
 801c9e2: b480         	push	{r7}
 801c9e4: b083         	sub	sp, #0xc
 801c9e6: af00         	add	r7, sp, #0x0
 801c9e8: 4603         	mov	r3, r0
 801c9ea: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 801c9ec: 2301         	movs	r3, #0x1
; }
 801c9ee: 4618         	mov	r0, r3
 801c9f0: 370c         	adds	r7, #0xc
 801c9f2: 46bd         	mov	sp, r7
 801c9f4: f85d 7b04    	ldr	r7, [sp], #4
 801c9f8: 4770         	bx	lr

0801c9fa <log_backend_id_set>:
; {
 801c9fa: b480         	push	{r7}
 801c9fc: b083         	sub	sp, #0xc
 801c9fe: af00         	add	r7, sp, #0x0
 801ca00: 6078         	str	r0, [r7, #0x4]
 801ca02: 460b         	mov	r3, r1
 801ca04: 70fb         	strb	r3, [r7, #0x3]
; 	backend->cb->id = id;
 801ca06: 687b         	ldr	r3, [r7, #0x4]
 801ca08: 685b         	ldr	r3, [r3, #0x4]
 801ca0a: 78fa         	ldrb	r2, [r7, #0x3]
 801ca0c: 711a         	strb	r2, [r3, #0x4]
; }
 801ca0e: bf00         	nop
 801ca10: 370c         	adds	r7, #0xc
 801ca12: 46bd         	mov	sp, r7
 801ca14: f85d 7b04    	ldr	r7, [sp], #4
 801ca18: 4770         	bx	lr

0801ca1a <log_backend_activate>:
; {
 801ca1a: b480         	push	{r7}
 801ca1c: b083         	sub	sp, #0xc
 801ca1e: af00         	add	r7, sp, #0x0
 801ca20: 6078         	str	r0, [r7, #0x4]
 801ca22: 6039         	str	r1, [r7]
; 	backend->cb->ctx = ctx;
 801ca24: 687b         	ldr	r3, [r7, #0x4]
 801ca26: 685b         	ldr	r3, [r3, #0x4]
 801ca28: 683a         	ldr	r2, [r7]
 801ca2a: 601a         	str	r2, [r3]
; 	backend->cb->active = true;
 801ca2c: 687b         	ldr	r3, [r7, #0x4]
 801ca2e: 685b         	ldr	r3, [r3, #0x4]
 801ca30: 2201         	movs	r2, #0x1
 801ca32: 715a         	strb	r2, [r3, #0x5]
; }
 801ca34: bf00         	nop
 801ca36: 370c         	adds	r7, #0xc
 801ca38: 46bd         	mov	sp, r7
 801ca3a: f85d 7b04    	ldr	r7, [sp], #4
 801ca3e: 4770         	bx	lr

0801ca40 <log_link_sources_count>:
; {
 801ca40: b480         	push	{r7}
 801ca42: b083         	sub	sp, #0xc
 801ca44: af00         	add	r7, sp, #0x0
 801ca46: 6078         	str	r0, [r7, #0x4]
 801ca48: 6039         	str	r1, [r7]
; 	return link->ctrl_blk->source_cnt[domain_id];
 801ca4a: 687b         	ldr	r3, [r7, #0x4]
 801ca4c: 689a         	ldr	r2, [r3, #0x8]
 801ca4e: 683b         	ldr	r3, [r7]
 801ca50: 005b         	lsls	r3, r3, #0x1
 801ca52: 4413         	add	r3, r2
 801ca54: 889b         	ldrh	r3, [r3, #0x4]
; }
 801ca56: 4618         	mov	r0, r3
 801ca58: 370c         	adds	r7, #0xc
 801ca5a: 46bd         	mov	sp, r7
 801ca5c: f85d 7b04    	ldr	r7, [sp], #4
 801ca60: 4770         	bx	lr

0801ca62 <log_link_get_source_name>:
; {
 801ca62: b590         	push	{r4, r7, lr}
 801ca64: b087         	sub	sp, #0x1c
 801ca66: af02         	add	r7, sp, #0x8
 801ca68: 60f8         	str	r0, [r7, #0xc]
 801ca6a: 60b9         	str	r1, [r7, #0x8]
 801ca6c: 603b         	str	r3, [r7]
 801ca6e: 4613         	mov	r3, r2
 801ca70: 80fb         	strh	r3, [r7, #0x6]
; 	return link->api->get_source_name(link, domain_id, source_id,
 801ca72: 68fb         	ldr	r3, [r7, #0xc]
 801ca74: 681b         	ldr	r3, [r3]
 801ca76: 68dc         	ldr	r4, [r3, #0xc]
 801ca78: 88fa         	ldrh	r2, [r7, #0x6]
 801ca7a: 6a3b         	ldr	r3, [r7, #0x20]
 801ca7c: 9300         	str	r3, [sp]
 801ca7e: 683b         	ldr	r3, [r7]
 801ca80: 68b9         	ldr	r1, [r7, #0x8]
 801ca82: 68f8         	ldr	r0, [r7, #0xc]
 801ca84: 47a0         	blx	r4
 801ca86: 4603         	mov	r3, r0
; }
 801ca88: 4618         	mov	r0, r3
 801ca8a: 3714         	adds	r7, #0x14
 801ca8c: 46bd         	mov	sp, r7
 801ca8e: bd90         	pop	{r4, r7, pc}

0801ca90 <link_source_count>:
; {
 801ca90: b580         	push	{r7, lr}
 801ca92: b084         	sub	sp, #0x10
 801ca94: af00         	add	r7, sp, #0x0
 801ca96: 4603         	mov	r3, r0
 801ca98: 71fb         	strb	r3, [r7, #0x7]
; 	const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 801ca9a: f107 020b    	add.w	r2, r7, #0xb
 801ca9e: 79fb         	ldrb	r3, [r7, #0x7]
 801caa0: 4611         	mov	r1, r2
 801caa2: 4618         	mov	r0, r3
 801caa4: f7e7 ffb0    	bl	0x8004a08 <get_link_domain> @ imm = #-0x180a0
 801caa8: 60f8         	str	r0, [r7, #0xc]
; 	return log_link_sources_count(link, rel_domain_id);
 801caaa: 7afb         	ldrb	r3, [r7, #0xb]
 801caac: 4619         	mov	r1, r3
 801caae: 68f8         	ldr	r0, [r7, #0xc]
 801cab0: f7ff ffc6    	bl	0x801ca40 <log_link_sources_count> @ imm = #-0x74
 801cab4: 4603         	mov	r3, r0
; }
 801cab6: 4618         	mov	r0, r3
 801cab8: 3710         	adds	r7, #0x10
 801caba: 46bd         	mov	sp, r7
 801cabc: bd80         	pop	{r7, pc}

0801cabe <log_src_cnt_get>:
; {
 801cabe: b580         	push	{r7, lr}
 801cac0: b082         	sub	sp, #0x8
 801cac2: af00         	add	r7, sp, #0x0
 801cac4: 6078         	str	r0, [r7, #0x4]
; 	if (z_log_is_local_domain(domain_id)) {
 801cac6: 687b         	ldr	r3, [r7, #0x4]
 801cac8: b2db         	uxtb	r3, r3
 801caca: 4618         	mov	r0, r3
 801cacc: f7ff ff89    	bl	0x801c9e2 <z_log_is_local_domain> @ imm = #-0xee
 801cad0: 4603         	mov	r3, r0
 801cad2: 2b00         	cmp	r3, #0x0
 801cad4: d003         	beq	0x801cade <log_src_cnt_get+0x20> @ imm = #0x6
; 		return z_log_sources_count();
 801cad6: f7e7 ff7b    	bl	0x80049d0 <z_log_sources_count> @ imm = #-0x1810a
 801cada: 4603         	mov	r3, r0
 801cadc: e005         	b	0x801caea <log_src_cnt_get+0x2c> @ imm = #0xa
; 	return link_source_count(domain_id);
 801cade: 687b         	ldr	r3, [r7, #0x4]
 801cae0: b2db         	uxtb	r3, r3
 801cae2: 4618         	mov	r0, r3
 801cae4: f7ff ffd4    	bl	0x801ca90 <link_source_count> @ imm = #-0x58
 801cae8: 4603         	mov	r3, r0
; }
 801caea: 4618         	mov	r0, r3
 801caec: 3708         	adds	r7, #0x8
 801caee: 46bd         	mov	sp, r7
 801caf0: bd80         	pop	{r7, pc}

0801caf2 <backend_filter_set>:
; {
 801caf2: b480         	push	{r7}
 801caf4: b083         	sub	sp, #0xc
 801caf6: af00         	add	r7, sp, #0x0
 801caf8: 6078         	str	r0, [r7, #0x4]
 801cafa: 6039         	str	r1, [r7]
; 		return;
 801cafc: bf00         	nop
; }
 801cafe: 370c         	adds	r7, #0xc
 801cb00: 46bd         	mov	sp, r7
 801cb02: f85d 7b04    	ldr	r7, [sp], #4
 801cb06: 4770         	bx	lr

0801cb08 <log_backend_enable>:
; {
 801cb08: b580         	push	{r7, lr}
 801cb0a: b086         	sub	sp, #0x18
 801cb0c: af00         	add	r7, sp, #0x0
 801cb0e: 60f8         	str	r0, [r7, #0xc]
 801cb10: 60b9         	str	r1, [r7, #0x8]
 801cb12: 607a         	str	r2, [r7, #0x4]
; 	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;
 801cb14: 2301         	movs	r3, #0x1
 801cb16: 617b         	str	r3, [r7, #0x14]
; 	id += backend - log_backend_get(0);
 801cb18: 2000         	movs	r0, #0x0
 801cb1a: f7e7 ff63    	bl	0x80049e4 <log_backend_get> @ imm = #-0x1813a
 801cb1e: 4602         	mov	r2, r0
 801cb20: 68fb         	ldr	r3, [r7, #0xc]
 801cb22: 1a9b         	subs	r3, r3, r2
 801cb24: 111b         	asrs	r3, r3, #0x4
 801cb26: 461a         	mov	r2, r3
 801cb28: 697b         	ldr	r3, [r7, #0x14]
 801cb2a: 4413         	add	r3, r2
 801cb2c: 617b         	str	r3, [r7, #0x14]
; 	log_backend_id_set(backend, id);
 801cb2e: 697b         	ldr	r3, [r7, #0x14]
 801cb30: b2db         	uxtb	r3, r3
 801cb32: 4619         	mov	r1, r3
 801cb34: 68f8         	ldr	r0, [r7, #0xc]
 801cb36: f7ff ff60    	bl	0x801c9fa <log_backend_id_set> @ imm = #-0x140
; 	backend->cb->level = level;
 801cb3a: 68fb         	ldr	r3, [r7, #0xc]
 801cb3c: 685b         	ldr	r3, [r3, #0x4]
 801cb3e: 687a         	ldr	r2, [r7, #0x4]
 801cb40: b2d2         	uxtb	r2, r2
 801cb42: 719a         	strb	r2, [r3, #0x6]
; 	backend_filter_set(backend, level);
 801cb44: 6879         	ldr	r1, [r7, #0x4]
 801cb46: 68f8         	ldr	r0, [r7, #0xc]
 801cb48: f7ff ffd3    	bl	0x801caf2 <backend_filter_set> @ imm = #-0x5a
; 	log_backend_activate(backend, ctx);
 801cb4c: 68b9         	ldr	r1, [r7, #0x8]
 801cb4e: 68f8         	ldr	r0, [r7, #0xc]
 801cb50: f7ff ff63    	bl	0x801ca1a <log_backend_activate> @ imm = #-0x13a
; 	z_log_notify_backend_enabled();
 801cb54: f7e7 fef4    	bl	0x8004940 <z_log_notify_backend_enabled> @ imm = #-0x18218
; }
 801cb58: bf00         	nop
 801cb5a: 3718         	adds	r7, #0x18
 801cb5c: 46bd         	mov	sp, r7
 801cb5e: bd80         	pop	{r7, pc}

0801cb60 <z_snode_next_peek>:
; {
 801cb60: b480         	push	{r7}
 801cb62: b083         	sub	sp, #0xc
 801cb64: af00         	add	r7, sp, #0x0
 801cb66: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 801cb68: 687b         	ldr	r3, [r7, #0x4]
 801cb6a: 681b         	ldr	r3, [r3]
; }
 801cb6c: 4618         	mov	r0, r3
 801cb6e: 370c         	adds	r7, #0xc
 801cb70: 46bd         	mov	sp, r7
 801cb72: f85d 7b04    	ldr	r7, [sp], #4
 801cb76: 4770         	bx	lr

0801cb78 <z_snode_next_set>:
; {
 801cb78: b480         	push	{r7}
 801cb7a: b083         	sub	sp, #0xc
 801cb7c: af00         	add	r7, sp, #0x0
 801cb7e: 6078         	str	r0, [r7, #0x4]
 801cb80: 6039         	str	r1, [r7]
; 	parent->next = child;
 801cb82: 687b         	ldr	r3, [r7, #0x4]
 801cb84: 683a         	ldr	r2, [r7]
 801cb86: 601a         	str	r2, [r3]
; }
 801cb88: bf00         	nop
 801cb8a: 370c         	adds	r7, #0xc
 801cb8c: 46bd         	mov	sp, r7
 801cb8e: f85d 7b04    	ldr	r7, [sp], #4
 801cb92: 4770         	bx	lr

0801cb94 <z_slist_head_set>:
; {
 801cb94: b480         	push	{r7}
 801cb96: b083         	sub	sp, #0xc
 801cb98: af00         	add	r7, sp, #0x0
 801cb9a: 6078         	str	r0, [r7, #0x4]
 801cb9c: 6039         	str	r1, [r7]
; 	list->head = node;
 801cb9e: 687b         	ldr	r3, [r7, #0x4]
 801cba0: 683a         	ldr	r2, [r7]
 801cba2: 601a         	str	r2, [r3]
; }
 801cba4: bf00         	nop
 801cba6: 370c         	adds	r7, #0xc
 801cba8: 46bd         	mov	sp, r7
 801cbaa: f85d 7b04    	ldr	r7, [sp], #4
 801cbae: 4770         	bx	lr

0801cbb0 <z_slist_tail_set>:
; {
 801cbb0: b480         	push	{r7}
 801cbb2: b083         	sub	sp, #0xc
 801cbb4: af00         	add	r7, sp, #0x0
 801cbb6: 6078         	str	r0, [r7, #0x4]
 801cbb8: 6039         	str	r1, [r7]
; 	list->tail = node;
 801cbba: 687b         	ldr	r3, [r7, #0x4]
 801cbbc: 683a         	ldr	r2, [r7]
 801cbbe: 605a         	str	r2, [r3, #0x4]
; }
 801cbc0: bf00         	nop
 801cbc2: 370c         	adds	r7, #0xc
 801cbc4: 46bd         	mov	sp, r7
 801cbc6: f85d 7b04    	ldr	r7, [sp], #4
 801cbca: 4770         	bx	lr

0801cbcc <sys_slist_peek_head>:
; {
 801cbcc: b480         	push	{r7}
 801cbce: b083         	sub	sp, #0xc
 801cbd0: af00         	add	r7, sp, #0x0
 801cbd2: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 801cbd4: 687b         	ldr	r3, [r7, #0x4]
 801cbd6: 681b         	ldr	r3, [r3]
; }
 801cbd8: 4618         	mov	r0, r3
 801cbda: 370c         	adds	r7, #0xc
 801cbdc: 46bd         	mov	sp, r7
 801cbde: f85d 7b04    	ldr	r7, [sp], #4
 801cbe2: 4770         	bx	lr

0801cbe4 <sys_slist_peek_tail>:
; {
 801cbe4: b480         	push	{r7}
 801cbe6: b083         	sub	sp, #0xc
 801cbe8: af00         	add	r7, sp, #0x0
 801cbea: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 801cbec: 687b         	ldr	r3, [r7, #0x4]
 801cbee: 685b         	ldr	r3, [r3, #0x4]
; }
 801cbf0: 4618         	mov	r0, r3
 801cbf2: 370c         	adds	r7, #0xc
 801cbf4: 46bd         	mov	sp, r7
 801cbf6: f85d 7b04    	ldr	r7, [sp], #4
 801cbfa: 4770         	bx	lr

0801cbfc <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 801cbfc: b580         	push	{r7, lr}
 801cbfe: b082         	sub	sp, #0x8
 801cc00: af00         	add	r7, sp, #0x0
 801cc02: 6078         	str	r0, [r7, #0x4]
 801cc04: 6878         	ldr	r0, [r7, #0x4]
 801cc06: f7ff ffe1    	bl	0x801cbcc <sys_slist_peek_head> @ imm = #-0x3e
 801cc0a: 4603         	mov	r3, r0
 801cc0c: 2b00         	cmp	r3, #0x0
 801cc0e: bf0c         	ite	eq
 801cc10: 2301         	moveq	r3, #0x1
 801cc12: 2300         	movne	r3, #0x0
 801cc14: b2db         	uxtb	r3, r3
 801cc16: 4618         	mov	r0, r3
 801cc18: 3708         	adds	r7, #0x8
 801cc1a: 46bd         	mov	sp, r7
 801cc1c: bd80         	pop	{r7, pc}

0801cc1e <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 801cc1e: b580         	push	{r7, lr}
 801cc20: b082         	sub	sp, #0x8
 801cc22: af00         	add	r7, sp, #0x0
 801cc24: 6078         	str	r0, [r7, #0x4]
 801cc26: 6878         	ldr	r0, [r7, #0x4]
 801cc28: f7ff ff9a    	bl	0x801cb60 <z_snode_next_peek> @ imm = #-0xcc
 801cc2c: 4603         	mov	r3, r0
 801cc2e: 4618         	mov	r0, r3
 801cc30: 3708         	adds	r7, #0x8
 801cc32: 46bd         	mov	sp, r7
 801cc34: bd80         	pop	{r7, pc}

0801cc36 <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 801cc36: b580         	push	{r7, lr}
 801cc38: b082         	sub	sp, #0x8
 801cc3a: af00         	add	r7, sp, #0x0
 801cc3c: 6078         	str	r0, [r7, #0x4]
 801cc3e: 687b         	ldr	r3, [r7, #0x4]
 801cc40: 2b00         	cmp	r3, #0x0
 801cc42: d004         	beq	0x801cc4e <sys_slist_peek_next+0x18> @ imm = #0x8
 801cc44: 6878         	ldr	r0, [r7, #0x4]
 801cc46: f7ff ffea    	bl	0x801cc1e <sys_slist_peek_next_no_check> @ imm = #-0x2c
 801cc4a: 4603         	mov	r3, r0
 801cc4c: e000         	b	0x801cc50 <sys_slist_peek_next+0x1a> @ imm = #0x0
 801cc4e: 2300         	movs	r3, #0x0
 801cc50: 4618         	mov	r0, r3
 801cc52: 3708         	adds	r7, #0x8
 801cc54: 46bd         	mov	sp, r7
 801cc56: bd80         	pop	{r7, pc}

0801cc58 <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 801cc58: b580         	push	{r7, lr}
 801cc5a: b082         	sub	sp, #0x8
 801cc5c: af00         	add	r7, sp, #0x0
 801cc5e: 6078         	str	r0, [r7, #0x4]
 801cc60: 6039         	str	r1, [r7]
 801cc62: 6878         	ldr	r0, [r7, #0x4]
 801cc64: f7ff ffb2    	bl	0x801cbcc <sys_slist_peek_head> @ imm = #-0x9c
 801cc68: 4603         	mov	r3, r0
 801cc6a: 4619         	mov	r1, r3
 801cc6c: 6838         	ldr	r0, [r7]
 801cc6e: f7ff ff83    	bl	0x801cb78 <z_snode_next_set> @ imm = #-0xfa
 801cc72: 6839         	ldr	r1, [r7]
 801cc74: 6878         	ldr	r0, [r7, #0x4]
 801cc76: f7ff ff8d    	bl	0x801cb94 <z_slist_head_set> @ imm = #-0xe6
 801cc7a: 6878         	ldr	r0, [r7, #0x4]
 801cc7c: f7ff ffb2    	bl	0x801cbe4 <sys_slist_peek_tail> @ imm = #-0x9c
 801cc80: 4603         	mov	r3, r0
 801cc82: 2b00         	cmp	r3, #0x0
 801cc84: d107         	bne	0x801cc96 <sys_slist_prepend+0x3e> @ imm = #0xe
 801cc86: 6878         	ldr	r0, [r7, #0x4]
 801cc88: f7ff ffa0    	bl	0x801cbcc <sys_slist_peek_head> @ imm = #-0xc0
 801cc8c: 4603         	mov	r3, r0
 801cc8e: 4619         	mov	r1, r3
 801cc90: 6878         	ldr	r0, [r7, #0x4]
 801cc92: f7ff ff8d    	bl	0x801cbb0 <z_slist_tail_set> @ imm = #-0xe6
 801cc96: 3708         	adds	r7, #0x8
 801cc98: 46bd         	mov	sp, r7
 801cc9a: bd80         	pop	{r7, pc}

0801cc9c <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 801cc9c: b580         	push	{r7, lr}
 801cc9e: b084         	sub	sp, #0x10
 801cca0: af00         	add	r7, sp, #0x0
 801cca2: 6078         	str	r0, [r7, #0x4]
 801cca4: 6878         	ldr	r0, [r7, #0x4]
 801cca6: f7ff ff91    	bl	0x801cbcc <sys_slist_peek_head> @ imm = #-0xde
 801ccaa: 60f8         	str	r0, [r7, #0xc]
 801ccac: 68f8         	ldr	r0, [r7, #0xc]
 801ccae: f7ff ff57    	bl	0x801cb60 <z_snode_next_peek> @ imm = #-0x152
 801ccb2: 4603         	mov	r3, r0
 801ccb4: 4619         	mov	r1, r3
 801ccb6: 6878         	ldr	r0, [r7, #0x4]
 801ccb8: f7ff ff6c    	bl	0x801cb94 <z_slist_head_set> @ imm = #-0x128
 801ccbc: 6878         	ldr	r0, [r7, #0x4]
 801ccbe: f7ff ff91    	bl	0x801cbe4 <sys_slist_peek_tail> @ imm = #-0xde
 801ccc2: 4602         	mov	r2, r0
 801ccc4: 68fb         	ldr	r3, [r7, #0xc]
 801ccc6: 4293         	cmp	r3, r2
 801ccc8: d107         	bne	0x801ccda <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 801ccca: 6878         	ldr	r0, [r7, #0x4]
 801cccc: f7ff ff7e    	bl	0x801cbcc <sys_slist_peek_head> @ imm = #-0x104
 801ccd0: 4603         	mov	r3, r0
 801ccd2: 4619         	mov	r1, r3
 801ccd4: 6878         	ldr	r0, [r7, #0x4]
 801ccd6: f7ff ff6b    	bl	0x801cbb0 <z_slist_tail_set> @ imm = #-0x12a
 801ccda: 68fb         	ldr	r3, [r7, #0xc]
 801ccdc: 4618         	mov	r0, r3
 801ccde: 3710         	adds	r7, #0x10
 801cce0: 46bd         	mov	sp, r7
 801cce2: bd80         	pop	{r7, pc}

0801cce4 <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 801cce4: b580         	push	{r7, lr}
 801cce6: b082         	sub	sp, #0x8
 801cce8: af00         	add	r7, sp, #0x0
 801ccea: 6078         	str	r0, [r7, #0x4]
 801ccec: 6878         	ldr	r0, [r7, #0x4]
 801ccee: f7ff ff85    	bl	0x801cbfc <sys_slist_is_empty> @ imm = #-0xf6
 801ccf2: 4603         	mov	r3, r0
 801ccf4: 2b00         	cmp	r3, #0x0
 801ccf6: d104         	bne	0x801cd02 <sys_slist_get+0x1e> @ imm = #0x8
 801ccf8: 6878         	ldr	r0, [r7, #0x4]
 801ccfa: f7ff ffcf    	bl	0x801cc9c <sys_slist_get_not_empty> @ imm = #-0x62
 801ccfe: 4603         	mov	r3, r0
 801cd00: e000         	b	0x801cd04 <sys_slist_get+0x20> @ imm = #0x0
 801cd02: 2300         	movs	r3, #0x0
 801cd04: 4618         	mov	r0, r3
 801cd06: 3708         	adds	r7, #0x8
 801cd08: 46bd         	mov	sp, r7
 801cd0a: bd80         	pop	{r7, pc}

0801cd0c <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 801cd0c: b580         	push	{r7, lr}
 801cd0e: b084         	sub	sp, #0x10
 801cd10: af00         	add	r7, sp, #0x0
 801cd12: 60f8         	str	r0, [r7, #0xc]
 801cd14: 60b9         	str	r1, [r7, #0x8]
 801cd16: 607a         	str	r2, [r7, #0x4]
 801cd18: 68bb         	ldr	r3, [r7, #0x8]
 801cd1a: 2b00         	cmp	r3, #0x0
 801cd1c: d117         	bne	0x801cd4e <sys_slist_remove+0x42> @ imm = #0x2e
 801cd1e: 6878         	ldr	r0, [r7, #0x4]
 801cd20: f7ff ff1e    	bl	0x801cb60 <z_snode_next_peek> @ imm = #-0x1c4
 801cd24: 4603         	mov	r3, r0
 801cd26: 4619         	mov	r1, r3
 801cd28: 68f8         	ldr	r0, [r7, #0xc]
 801cd2a: f7ff ff33    	bl	0x801cb94 <z_slist_head_set> @ imm = #-0x19a
 801cd2e: 68f8         	ldr	r0, [r7, #0xc]
 801cd30: f7ff ff58    	bl	0x801cbe4 <sys_slist_peek_tail> @ imm = #-0x150
 801cd34: 4602         	mov	r2, r0
 801cd36: 687b         	ldr	r3, [r7, #0x4]
 801cd38: 4293         	cmp	r3, r2
 801cd3a: d11b         	bne	0x801cd74 <sys_slist_remove+0x68> @ imm = #0x36
 801cd3c: 68f8         	ldr	r0, [r7, #0xc]
 801cd3e: f7ff ff45    	bl	0x801cbcc <sys_slist_peek_head> @ imm = #-0x176
 801cd42: 4603         	mov	r3, r0
 801cd44: 4619         	mov	r1, r3
 801cd46: 68f8         	ldr	r0, [r7, #0xc]
 801cd48: f7ff ff32    	bl	0x801cbb0 <z_slist_tail_set> @ imm = #-0x19c
 801cd4c: e012         	b	0x801cd74 <sys_slist_remove+0x68> @ imm = #0x24
 801cd4e: 6878         	ldr	r0, [r7, #0x4]
 801cd50: f7ff ff06    	bl	0x801cb60 <z_snode_next_peek> @ imm = #-0x1f4
 801cd54: 4603         	mov	r3, r0
 801cd56: 4619         	mov	r1, r3
 801cd58: 68b8         	ldr	r0, [r7, #0x8]
 801cd5a: f7ff ff0d    	bl	0x801cb78 <z_snode_next_set> @ imm = #-0x1e6
 801cd5e: 68f8         	ldr	r0, [r7, #0xc]
 801cd60: f7ff ff40    	bl	0x801cbe4 <sys_slist_peek_tail> @ imm = #-0x180
 801cd64: 4602         	mov	r2, r0
 801cd66: 687b         	ldr	r3, [r7, #0x4]
 801cd68: 4293         	cmp	r3, r2
 801cd6a: d103         	bne	0x801cd74 <sys_slist_remove+0x68> @ imm = #0x6
 801cd6c: 68b9         	ldr	r1, [r7, #0x8]
 801cd6e: 68f8         	ldr	r0, [r7, #0xc]
 801cd70: f7ff ff1e    	bl	0x801cbb0 <z_slist_tail_set> @ imm = #-0x1c4
 801cd74: 2100         	movs	r1, #0x0
 801cd76: 6878         	ldr	r0, [r7, #0x4]
 801cd78: f7ff fefe    	bl	0x801cb78 <z_snode_next_set> @ imm = #-0x204
 801cd7c: 3710         	adds	r7, #0x10
 801cd7e: 46bd         	mov	sp, r7
 801cd80: bd80         	pop	{r7, pc}

0801cd82 <log_cache_get>:
; {
 801cd82: b590         	push	{r4, r7, lr}
 801cd84: b089         	sub	sp, #0x24
 801cd86: af00         	add	r7, sp, #0x0
 801cd88: 60f8         	str	r0, [r7, #0xc]
 801cd8a: 60b9         	str	r1, [r7, #0x8]
 801cd8c: 607a         	str	r2, [r7, #0x4]
; 	sys_snode_t *prev_node = NULL;
 801cd8e: 2300         	movs	r3, #0x0
 801cd90: 61fb         	str	r3, [r7, #0x1c]
; 	bool hit = false;
 801cd92: 2300         	movs	r3, #0x0
 801cd94: 75fb         	strb	r3, [r7, #0x17]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 801cd96: 68fb         	ldr	r3, [r7, #0xc]
 801cd98: 4618         	mov	r0, r3
 801cd9a: f7ff ff17    	bl	0x801cbcc <sys_slist_peek_head> @ imm = #-0x1d2
 801cd9e: 4603         	mov	r3, r0
 801cda0: 2b00         	cmp	r3, #0x0
 801cda2: d005         	beq	0x801cdb0 <log_cache_get+0x2e> @ imm = #0xa
 801cda4: 68fb         	ldr	r3, [r7, #0xc]
 801cda6: 4618         	mov	r0, r3
 801cda8: f7ff ff10    	bl	0x801cbcc <sys_slist_peek_head> @ imm = #-0x1e0
 801cdac: 4603         	mov	r3, r0
 801cdae: e000         	b	0x801cdb2 <log_cache_get+0x30> @ imm = #0x0
 801cdb0: 2300         	movs	r3, #0x0
 801cdb2: 61bb         	str	r3, [r7, #0x18]
 801cdb4: e02f         	b	0x801ce16 <log_cache_get+0x94> @ imm = #0x5e
; 		if (cache->cmp(entry->id, id)) {
 801cdb6: 68fb         	ldr	r3, [r7, #0xc]
 801cdb8: 691b         	ldr	r3, [r3, #0x10]
 801cdba: 69ba         	ldr	r2, [r7, #0x18]
 801cdbc: 6852         	ldr	r2, [r2, #0x4]
 801cdbe: 68b9         	ldr	r1, [r7, #0x8]
 801cdc0: 4610         	mov	r0, r2
 801cdc2: 4798         	blx	r3
 801cdc4: 4603         	mov	r3, r0
 801cdc6: 2b00         	cmp	r3, #0x0
 801cdc8: d007         	beq	0x801cdda <log_cache_get+0x58> @ imm = #0xe
; 			cache->hit++;
 801cdca: 68fb         	ldr	r3, [r7, #0xc]
 801cdcc: 695b         	ldr	r3, [r3, #0x14]
 801cdce: 1c5a         	adds	r2, r3, #0x1
 801cdd0: 68fb         	ldr	r3, [r7, #0xc]
 801cdd2: 615a         	str	r2, [r3, #0x14]
; 			hit = true;
 801cdd4: 2301         	movs	r3, #0x1
 801cdd6: 75fb         	strb	r3, [r7, #0x17]
; 			break;
 801cdd8: e022         	b	0x801ce20 <log_cache_get+0x9e> @ imm = #0x44
; 		if (&entry->node == sys_slist_peek_tail(&cache->active)) {
 801cdda: 69bc         	ldr	r4, [r7, #0x18]
 801cddc: 68fb         	ldr	r3, [r7, #0xc]
 801cdde: 4618         	mov	r0, r3
 801cde0: f7ff ff00    	bl	0x801cbe4 <sys_slist_peek_tail> @ imm = #-0x200
 801cde4: 4603         	mov	r3, r0
 801cde6: 429c         	cmp	r4, r3
 801cde8: d019         	beq	0x801ce1e <log_cache_get+0x9c> @ imm = #0x32
; 		prev_node = &entry->node;
 801cdea: 69bb         	ldr	r3, [r7, #0x18]
 801cdec: 61fb         	str	r3, [r7, #0x1c]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 801cdee: 69bb         	ldr	r3, [r7, #0x18]
 801cdf0: 2b00         	cmp	r3, #0x0
 801cdf2: d00e         	beq	0x801ce12 <log_cache_get+0x90> @ imm = #0x1c
 801cdf4: 69bb         	ldr	r3, [r7, #0x18]
 801cdf6: 4618         	mov	r0, r3
 801cdf8: f7ff ff1d    	bl	0x801cc36 <sys_slist_peek_next> @ imm = #-0x1c6
 801cdfc: 4603         	mov	r3, r0
 801cdfe: 2b00         	cmp	r3, #0x0
 801ce00: d005         	beq	0x801ce0e <log_cache_get+0x8c> @ imm = #0xa
 801ce02: 69bb         	ldr	r3, [r7, #0x18]
 801ce04: 4618         	mov	r0, r3
 801ce06: f7ff ff16    	bl	0x801cc36 <sys_slist_peek_next> @ imm = #-0x1d4
 801ce0a: 4603         	mov	r3, r0
 801ce0c: e002         	b	0x801ce14 <log_cache_get+0x92> @ imm = #0x4
 801ce0e: 2300         	movs	r3, #0x0
 801ce10: e000         	b	0x801ce14 <log_cache_get+0x92> @ imm = #0x0
 801ce12: 2300         	movs	r3, #0x0
 801ce14: 61bb         	str	r3, [r7, #0x18]
 801ce16: 69bb         	ldr	r3, [r7, #0x18]
 801ce18: 2b00         	cmp	r3, #0x0
 801ce1a: d1cc         	bne	0x801cdb6 <log_cache_get+0x34> @ imm = #-0x68
 801ce1c: e000         	b	0x801ce20 <log_cache_get+0x9e> @ imm = #0x0
; 			break;
 801ce1e: bf00         	nop
; 	if (hit) {
 801ce20: 7dfb         	ldrb	r3, [r7, #0x17]
 801ce22: 2b00         	cmp	r3, #0x0
 801ce24: d00c         	beq	0x801ce40 <log_cache_get+0xbe> @ imm = #0x18
; 		sys_slist_remove(&cache->active, prev_node, &entry->node);
 801ce26: 68fb         	ldr	r3, [r7, #0xc]
 801ce28: 69ba         	ldr	r2, [r7, #0x18]
 801ce2a: 69f9         	ldr	r1, [r7, #0x1c]
 801ce2c: 4618         	mov	r0, r3
 801ce2e: f7ff ff6d    	bl	0x801cd0c <sys_slist_remove> @ imm = #-0x126
; 		sys_slist_prepend(&cache->active, &entry->node);
 801ce32: 68fb         	ldr	r3, [r7, #0xc]
 801ce34: 69ba         	ldr	r2, [r7, #0x18]
 801ce36: 4611         	mov	r1, r2
 801ce38: 4618         	mov	r0, r3
 801ce3a: f7ff ff0d    	bl	0x801cc58 <sys_slist_prepend> @ imm = #-0x1e6
 801ce3e: e016         	b	0x801ce6e <log_cache_get+0xec> @ imm = #0x2c
; 		cache->miss++;
 801ce40: 68fb         	ldr	r3, [r7, #0xc]
 801ce42: 699b         	ldr	r3, [r3, #0x18]
 801ce44: 1c5a         	adds	r2, r3, #0x1
 801ce46: 68fb         	ldr	r3, [r7, #0xc]
 801ce48: 619a         	str	r2, [r3, #0x18]
; 		sys_snode_t *from_idle = sys_slist_get(&cache->idle);
 801ce4a: 68fb         	ldr	r3, [r7, #0xc]
 801ce4c: 3308         	adds	r3, #0x8
 801ce4e: 4618         	mov	r0, r3
 801ce50: f7ff ff48    	bl	0x801cce4 <sys_slist_get> @ imm = #-0x170
 801ce54: 6138         	str	r0, [r7, #0x10]
; 		if (from_idle) {
 801ce56: 693b         	ldr	r3, [r7, #0x10]
 801ce58: 2b00         	cmp	r3, #0x0
 801ce5a: d002         	beq	0x801ce62 <log_cache_get+0xe0> @ imm = #0x4
; 			entry = CONTAINER_OF(from_idle, struct log_cache_entry, node);
 801ce5c: 693b         	ldr	r3, [r7, #0x10]
 801ce5e: 61bb         	str	r3, [r7, #0x18]
 801ce60: e005         	b	0x801ce6e <log_cache_get+0xec> @ imm = #0xa
; 			sys_slist_remove(&cache->active, prev_node, &entry->node);
 801ce62: 68fb         	ldr	r3, [r7, #0xc]
 801ce64: 69ba         	ldr	r2, [r7, #0x18]
 801ce66: 69f9         	ldr	r1, [r7, #0x1c]
 801ce68: 4618         	mov	r0, r3
 801ce6a: f7ff ff4f    	bl	0x801cd0c <sys_slist_remove> @ imm = #-0x162
; 	*data = entry->data;
 801ce6e: 69bb         	ldr	r3, [r7, #0x18]
 801ce70: f103 0208    	add.w	r2, r3, #0x8
 801ce74: 687b         	ldr	r3, [r7, #0x4]
 801ce76: 601a         	str	r2, [r3]
; 	entry->id = id;
 801ce78: 69bb         	ldr	r3, [r7, #0x18]
 801ce7a: 68ba         	ldr	r2, [r7, #0x8]
 801ce7c: 605a         	str	r2, [r3, #0x4]
; 	return hit;
 801ce7e: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 801ce80: 4618         	mov	r0, r3
 801ce82: 3724         	adds	r7, #0x24
 801ce84: 46bd         	mov	sp, r7
 801ce86: bd90         	pop	{r4, r7, pc}

0801ce88 <log_cache_put>:
; {
 801ce88: b580         	push	{r7, lr}
 801ce8a: b084         	sub	sp, #0x10
 801ce8c: af00         	add	r7, sp, #0x0
 801ce8e: 6078         	str	r0, [r7, #0x4]
 801ce90: 6039         	str	r1, [r7]
; 	struct log_cache_entry *entry = CONTAINER_OF(data, struct log_cache_entry, data[0]);
 801ce92: 683b         	ldr	r3, [r7]
 801ce94: 3b08         	subs	r3, #0x8
 801ce96: 60fb         	str	r3, [r7, #0xc]
; 	sys_slist_prepend(&cache->active, &entry->node);
 801ce98: 687b         	ldr	r3, [r7, #0x4]
 801ce9a: 68fa         	ldr	r2, [r7, #0xc]
 801ce9c: 4611         	mov	r1, r2
 801ce9e: 4618         	mov	r0, r3
 801cea0: f7ff feda    	bl	0x801cc58 <sys_slist_prepend> @ imm = #-0x24c
; }
 801cea4: bf00         	nop
 801cea6: 3710         	adds	r7, #0x10
 801cea8: 46bd         	mov	sp, r7
 801ceaa: bd80         	pop	{r7, pc}

0801ceac <z_log_msg_runtime_create>:
; {
 801ceac: b580         	push	{r7, lr}
 801ceae: b08a         	sub	sp, #0x28
 801ceb0: af04         	add	r7, sp, #0x10
 801ceb2: 60b9         	str	r1, [r7, #0x8]
 801ceb4: 607b         	str	r3, [r7, #0x4]
 801ceb6: 4603         	mov	r3, r0
 801ceb8: 73fb         	strb	r3, [r7, #0xf]
 801ceba: 4613         	mov	r3, r2
 801cebc: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801cebe: f107 032c    	add.w	r3, r7, #0x2c
 801cec2: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801cec4: 7bba         	ldrb	r2, [r7, #0xe]
 801cec6: 7bf8         	ldrb	r0, [r7, #0xf]
 801cec8: 697b         	ldr	r3, [r7, #0x14]
 801ceca: 9303         	str	r3, [sp, #0xc]
 801cecc: 6abb         	ldr	r3, [r7, #0x28]
 801cece: 9302         	str	r3, [sp, #0x8]
 801ced0: 6a7b         	ldr	r3, [r7, #0x24]
 801ced2: 9301         	str	r3, [sp, #0x4]
 801ced4: 6a3b         	ldr	r3, [r7, #0x20]
 801ced6: 9300         	str	r3, [sp]
 801ced8: 687b         	ldr	r3, [r7, #0x4]
 801ceda: 68b9         	ldr	r1, [r7, #0x8]
 801cedc: f7e7 fe4a    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1836c
; }
 801cee0: bf00         	nop
 801cee2: 3718         	adds	r7, #0x18
 801cee4: 46bd         	mov	sp, r7
 801cee6: bd80         	pop	{r7, pc}

0801cee8 <log_msg_get_domain>:
; {
 801cee8: b480         	push	{r7}
 801ceea: b083         	sub	sp, #0xc
 801ceec: af00         	add	r7, sp, #0x0
 801ceee: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 801cef0: 687b         	ldr	r3, [r7, #0x4]
 801cef2: 781b         	ldrb	r3, [r3]
 801cef4: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 801cef8: b2db         	uxtb	r3, r3
; }
 801cefa: 4618         	mov	r0, r3
 801cefc: 370c         	adds	r7, #0xc
 801cefe: 46bd         	mov	sp, r7
 801cf00: f85d 7b04    	ldr	r7, [sp], #4
 801cf04: 4770         	bx	lr

0801cf06 <log_msg_get_source>:
; {
 801cf06: b480         	push	{r7}
 801cf08: b083         	sub	sp, #0xc
 801cf0a: af00         	add	r7, sp, #0x0
 801cf0c: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.source;
 801cf0e: 687b         	ldr	r3, [r7, #0x4]
 801cf10: 685b         	ldr	r3, [r3, #0x4]
; }
 801cf12: 4618         	mov	r0, r3
 801cf14: 370c         	adds	r7, #0xc
 801cf16: 46bd         	mov	sp, r7
 801cf18: f85d 7b04    	ldr	r7, [sp], #4
 801cf1c: 4770         	bx	lr

0801cf1e <log_source_id>:
; {
 801cf1e: b580         	push	{r7, lr}
 801cf20: b082         	sub	sp, #0x8
 801cf22: af00         	add	r7, sp, #0x0
 801cf24: 6078         	str	r0, [r7, #0x4]
; 		log_dynamic_source_id((struct log_source_dynamic_data *)source) :
 801cf26: 6878         	ldr	r0, [r7, #0x4]
 801cf28: f7e7 fe14    	bl	0x8004b54 <log_const_source_id> @ imm = #-0x183d8
 801cf2c: 4603         	mov	r3, r0
; }
 801cf2e: 4618         	mov	r0, r3
 801cf30: 3708         	adds	r7, #0x8
 801cf32: 46bd         	mov	sp, r7
 801cf34: bd80         	pop	{r7, pc}

0801cf36 <z_log_is_local_domain>:
; {
 801cf36: b480         	push	{r7}
 801cf38: b083         	sub	sp, #0xc
 801cf3a: af00         	add	r7, sp, #0x0
 801cf3c: 4603         	mov	r3, r0
 801cf3e: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 801cf40: 2301         	movs	r3, #0x1
; }
 801cf42: 4618         	mov	r0, r3
 801cf44: 370c         	adds	r7, #0xc
 801cf46: 46bd         	mov	sp, r7
 801cf48: f85d 7b04    	ldr	r7, [sp], #4
 801cf4c: 4770         	bx	lr

0801cf4e <z_log_msg_finalize>:
; {
 801cf4e: b580         	push	{r7, lr}
 801cf50: b086         	sub	sp, #0x18
 801cf52: af00         	add	r7, sp, #0x0
 801cf54: 60f8         	str	r0, [r7, #0xc]
 801cf56: 60b9         	str	r1, [r7, #0x8]
 801cf58: 607a         	str	r2, [r7, #0x4]
 801cf5a: 603b         	str	r3, [r7]
; 	if (!msg) {
 801cf5c: 68fb         	ldr	r3, [r7, #0xc]
 801cf5e: 2b00         	cmp	r3, #0x0
 801cf60: d103         	bne	0x801cf6a <z_log_msg_finalize+0x1c> @ imm = #0x6
; 		z_log_dropped(false);
 801cf62: 2000         	movs	r0, #0x0
 801cf64: f7e7 fcf8    	bl	0x8004958 <z_log_dropped> @ imm = #-0x18610
; 		return;
 801cf68: e01c         	b	0x801cfa4 <z_log_msg_finalize+0x56> @ imm = #0x38
; 	if (data) {
 801cf6a: 683b         	ldr	r3, [r7]
 801cf6c: 2b00         	cmp	r3, #0x0
 801cf6e: d010         	beq	0x801cf92 <z_log_msg_finalize+0x44> @ imm = #0x20
; 		uint8_t *d = msg->data + desc.package_len;
 801cf70: 68fb         	ldr	r3, [r7, #0xc]
 801cf72: 3310         	adds	r3, #0x10
 801cf74: 687a         	ldr	r2, [r7, #0x4]
 801cf76: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 801cf7a: b292         	uxth	r2, r2
 801cf7c: 4413         	add	r3, r2
 801cf7e: 617b         	str	r3, [r7, #0x14]
; 		memcpy(d, data, desc.data_len);
 801cf80: 88fb         	ldrh	r3, [r7, #0x6]
 801cf82: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 801cf86: b29b         	uxth	r3, r3
 801cf88: 461a         	mov	r2, r3
 801cf8a: 6839         	ldr	r1, [r7]
 801cf8c: 6978         	ldr	r0, [r7, #0x14]
 801cf8e: f00c f8b1    	bl	0x80290f4 <memcpy>      @ imm = #0xc162
; 	msg->hdr.desc = desc;
 801cf92: 68fb         	ldr	r3, [r7, #0xc]
 801cf94: 687a         	ldr	r2, [r7, #0x4]
 801cf96: 601a         	str	r2, [r3]
; 	msg->hdr.source = source;
 801cf98: 68fb         	ldr	r3, [r7, #0xc]
 801cf9a: 68ba         	ldr	r2, [r7, #0x8]
 801cf9c: 605a         	str	r2, [r3, #0x4]
; 	z_log_msg_commit(msg);
 801cf9e: 68f8         	ldr	r0, [r7, #0xc]
 801cfa0: f7e7 fcf0    	bl	0x8004984 <z_log_msg_commit> @ imm = #-0x18620
; }
 801cfa4: 3718         	adds	r7, #0x18
 801cfa6: 46bd         	mov	sp, r7
 801cfa8: bd80         	pop	{r7, pc}

0801cfaa <log_msg_get_source_id>:
; {
 801cfaa: b580         	push	{r7, lr}
 801cfac: b084         	sub	sp, #0x10
 801cfae: af00         	add	r7, sp, #0x0
 801cfb0: 6078         	str	r0, [r7, #0x4]
; 	if (!z_log_is_local_domain(log_msg_get_domain(msg))) {
 801cfb2: 6878         	ldr	r0, [r7, #0x4]
 801cfb4: f7ff ff98    	bl	0x801cee8 <log_msg_get_domain> @ imm = #-0xd0
 801cfb8: 4603         	mov	r3, r0
 801cfba: 4618         	mov	r0, r3
 801cfbc: f7ff ffbb    	bl	0x801cf36 <z_log_is_local_domain> @ imm = #-0x8a
 801cfc0: 4603         	mov	r3, r0
 801cfc2: f083 0301    	eor	r3, r3, #0x1
 801cfc6: b2db         	uxtb	r3, r3
 801cfc8: 2b00         	cmp	r3, #0x0
 801cfca: d005         	beq	0x801cfd8 <log_msg_get_source_id+0x2e> @ imm = #0xa
; 		return (int16_t)(uintptr_t)log_msg_get_source(msg);
 801cfcc: 6878         	ldr	r0, [r7, #0x4]
 801cfce: f7ff ff9a    	bl	0x801cf06 <log_msg_get_source> @ imm = #-0xcc
 801cfd2: 4603         	mov	r3, r0
 801cfd4: b21b         	sxth	r3, r3
 801cfd6: e00e         	b	0x801cff6 <log_msg_get_source_id+0x4c> @ imm = #0x1c
; 	void *source = (void *)log_msg_get_source(msg);
 801cfd8: 6878         	ldr	r0, [r7, #0x4]
 801cfda: f7ff ff94    	bl	0x801cf06 <log_msg_get_source> @ imm = #-0xd8
 801cfde: 60f8         	str	r0, [r7, #0xc]
; 	if (source != NULL) {
 801cfe0: 68fb         	ldr	r3, [r7, #0xc]
 801cfe2: 2b00         	cmp	r3, #0x0
 801cfe4: d005         	beq	0x801cff2 <log_msg_get_source_id+0x48> @ imm = #0xa
; 		return log_source_id(source);
 801cfe6: 68f8         	ldr	r0, [r7, #0xc]
 801cfe8: f7ff ff99    	bl	0x801cf1e <log_source_id> @ imm = #-0xce
 801cfec: 4603         	mov	r3, r0
 801cfee: b21b         	sxth	r3, r3
 801cff0: e001         	b	0x801cff6 <log_msg_get_source_id+0x4c> @ imm = #0x2
; 	return -1;
 801cff2: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 801cff6: 4618         	mov	r0, r3
 801cff8: 3710         	adds	r7, #0x10
 801cffa: 46bd         	mov	sp, r7
 801cffc: bd80         	pop	{r7, pc}

0801cffe <log_msg_get_domain>:
; {
 801cffe: b480         	push	{r7}
 801d000: b083         	sub	sp, #0xc
 801d002: af00         	add	r7, sp, #0x0
 801d004: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 801d006: 687b         	ldr	r3, [r7, #0x4]
 801d008: 781b         	ldrb	r3, [r3]
 801d00a: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 801d00e: b2db         	uxtb	r3, r3
; }
 801d010: 4618         	mov	r0, r3
 801d012: 370c         	adds	r7, #0xc
 801d014: 46bd         	mov	sp, r7
 801d016: f85d 7b04    	ldr	r7, [sp], #4
 801d01a: 4770         	bx	lr

0801d01c <log_msg_get_level>:
; {
 801d01c: b480         	push	{r7}
 801d01e: b083         	sub	sp, #0xc
 801d020: af00         	add	r7, sp, #0x0
 801d022: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.level;
 801d024: 687b         	ldr	r3, [r7, #0x4]
 801d026: 881b         	ldrh	r3, [r3]
 801d028: f3c3 1382    	ubfx	r3, r3, #0x6, #0x3
 801d02c: b2db         	uxtb	r3, r3
; }
 801d02e: 4618         	mov	r0, r3
 801d030: 370c         	adds	r7, #0xc
 801d032: 46bd         	mov	sp, r7
 801d034: f85d 7b04    	ldr	r7, [sp], #4
 801d038: 4770         	bx	lr

0801d03a <log_msg_get_timestamp>:
; {
 801d03a: b480         	push	{r7}
 801d03c: b083         	sub	sp, #0xc
 801d03e: af00         	add	r7, sp, #0x0
 801d040: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.timestamp;
 801d042: 687b         	ldr	r3, [r7, #0x4]
 801d044: 689b         	ldr	r3, [r3, #0x8]
; }
 801d046: 4618         	mov	r0, r3
 801d048: 370c         	adds	r7, #0xc
 801d04a: 46bd         	mov	sp, r7
 801d04c: f85d 7b04    	ldr	r7, [sp], #4
 801d050: 4770         	bx	lr

0801d052 <log_msg_get_tid>:
; {
 801d052: b480         	push	{r7}
 801d054: b083         	sub	sp, #0xc
 801d056: af00         	add	r7, sp, #0x0
 801d058: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 801d05a: 2300         	movs	r3, #0x0
; }
 801d05c: 4618         	mov	r0, r3
 801d05e: 370c         	adds	r7, #0xc
 801d060: 46bd         	mov	sp, r7
 801d062: f85d 7b04    	ldr	r7, [sp], #4
 801d066: 4770         	bx	lr

0801d068 <log_msg_get_data>:
; {
 801d068: b480         	push	{r7}
 801d06a: b083         	sub	sp, #0xc
 801d06c: af00         	add	r7, sp, #0x0
 801d06e: 6078         	str	r0, [r7, #0x4]
 801d070: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.data_len;
 801d072: 687b         	ldr	r3, [r7, #0x4]
 801d074: 885b         	ldrh	r3, [r3, #0x2]
 801d076: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 801d07a: b29b         	uxth	r3, r3
 801d07c: 461a         	mov	r2, r3
 801d07e: 683b         	ldr	r3, [r7]
 801d080: 601a         	str	r2, [r3]
; 	return msg->data + msg->hdr.desc.package_len;
 801d082: 687b         	ldr	r3, [r7, #0x4]
 801d084: 3310         	adds	r3, #0x10
 801d086: 687a         	ldr	r2, [r7, #0x4]
 801d088: 6812         	ldr	r2, [r2]
 801d08a: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 801d08e: b292         	uxth	r2, r2
 801d090: 4413         	add	r3, r2
; }
 801d092: 4618         	mov	r0, r3
 801d094: 370c         	adds	r7, #0xc
 801d096: 46bd         	mov	sp, r7
 801d098: f85d 7b04    	ldr	r7, [sp], #4
 801d09c: 4770         	bx	lr

0801d09e <log_msg_get_package>:
; {
 801d09e: b480         	push	{r7}
 801d0a0: b083         	sub	sp, #0xc
 801d0a2: af00         	add	r7, sp, #0x0
 801d0a4: 6078         	str	r0, [r7, #0x4]
 801d0a6: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.package_len;
 801d0a8: 687b         	ldr	r3, [r7, #0x4]
 801d0aa: 681b         	ldr	r3, [r3]
 801d0ac: f3c3 234a    	ubfx	r3, r3, #0x9, #0xb
 801d0b0: b29b         	uxth	r3, r3
 801d0b2: 461a         	mov	r2, r3
 801d0b4: 683b         	ldr	r3, [r7]
 801d0b6: 601a         	str	r2, [r3]
; 	return msg->data;
 801d0b8: 687b         	ldr	r3, [r7, #0x4]
 801d0ba: 3310         	adds	r3, #0x10
; }
 801d0bc: 4618         	mov	r0, r3
 801d0be: 370c         	adds	r7, #0xc
 801d0c0: 46bd         	mov	sp, r7
 801d0c2: f85d 7b04    	ldr	r7, [sp], #4
 801d0c6: 4770         	bx	lr

0801d0c8 <log_output_write>:
; {
 801d0c8: b580         	push	{r7, lr}
 801d0ca: b086         	sub	sp, #0x18
 801d0cc: af00         	add	r7, sp, #0x0
 801d0ce: 60f8         	str	r0, [r7, #0xc]
 801d0d0: 60b9         	str	r1, [r7, #0x8]
 801d0d2: 607a         	str	r2, [r7, #0x4]
 801d0d4: 603b         	str	r3, [r7]
; 	while (len != 0) {
 801d0d6: e00d         	b	0x801d0f4 <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 801d0d8: 68fb         	ldr	r3, [r7, #0xc]
 801d0da: 683a         	ldr	r2, [r7]
 801d0dc: 6879         	ldr	r1, [r7, #0x4]
 801d0de: 68b8         	ldr	r0, [r7, #0x8]
 801d0e0: 4798         	blx	r3
 801d0e2: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 801d0e4: 697b         	ldr	r3, [r7, #0x14]
 801d0e6: 687a         	ldr	r2, [r7, #0x4]
 801d0e8: 1ad3         	subs	r3, r2, r3
 801d0ea: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 801d0ec: 697b         	ldr	r3, [r7, #0x14]
 801d0ee: 68ba         	ldr	r2, [r7, #0x8]
 801d0f0: 4413         	add	r3, r2
 801d0f2: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 801d0f4: 687b         	ldr	r3, [r7, #0x4]
 801d0f6: 2b00         	cmp	r3, #0x0
 801d0f8: d1ee         	bne	0x801d0d8 <log_output_write+0x10> @ imm = #-0x24
; }
 801d0fa: bf00         	nop
 801d0fc: bf00         	nop
 801d0fe: 3718         	adds	r7, #0x18
 801d100: 46bd         	mov	sp, r7
 801d102: bd80         	pop	{r7, pc}

0801d104 <log_output_flush>:
; {
 801d104: b580         	push	{r7, lr}
 801d106: b082         	sub	sp, #0x8
 801d108: af00         	add	r7, sp, #0x0
 801d10a: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 801d10c: 687b         	ldr	r3, [r7, #0x4]
 801d10e: 6818         	ldr	r0, [r3]
 801d110: 687b         	ldr	r3, [r7, #0x4]
 801d112: 6899         	ldr	r1, [r3, #0x8]
 801d114: 687b         	ldr	r3, [r7, #0x4]
 801d116: 685b         	ldr	r3, [r3, #0x4]
 801d118: 681b         	ldr	r3, [r3]
 801d11a: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 801d11c: 687b         	ldr	r3, [r7, #0x4]
 801d11e: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 801d120: 685b         	ldr	r3, [r3, #0x4]
 801d122: f7ff ffd1    	bl	0x801d0c8 <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 801d126: 687b         	ldr	r3, [r7, #0x4]
 801d128: 685b         	ldr	r3, [r3, #0x4]
 801d12a: 2200         	movs	r2, #0x0
 801d12c: 601a         	str	r2, [r3]
; }
 801d12e: bf00         	nop
 801d130: 3708         	adds	r7, #0x8
 801d132: 46bd         	mov	sp, r7
 801d134: bd80         	pop	{r7, pc}

0801d136 <out_func>:
; {
 801d136: b580         	push	{r7, lr}
 801d138: b084         	sub	sp, #0x10
 801d13a: af00         	add	r7, sp, #0x0
 801d13c: 6078         	str	r0, [r7, #0x4]
 801d13e: 6039         	str	r1, [r7]
; 	const struct log_output *out_ctx = (const struct log_output *)ctx;
 801d140: 683b         	ldr	r3, [r7]
 801d142: 60fb         	str	r3, [r7, #0xc]
; 		char x = (char)c;
 801d144: 687b         	ldr	r3, [r7, #0x4]
 801d146: b2db         	uxtb	r3, r3
 801d148: 72fb         	strb	r3, [r7, #0xb]
; 		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
 801d14a: 68fb         	ldr	r3, [r7, #0xc]
 801d14c: 681b         	ldr	r3, [r3]
 801d14e: 68fa         	ldr	r2, [r7, #0xc]
 801d150: 6852         	ldr	r2, [r2, #0x4]
 801d152: 6852         	ldr	r2, [r2, #0x4]
 801d154: f107 000b    	add.w	r0, r7, #0xb
 801d158: 2101         	movs	r1, #0x1
 801d15a: 4798         	blx	r3
; 		return 0;
 801d15c: 2300         	movs	r3, #0x0
; }
 801d15e: 4618         	mov	r0, r3
 801d160: 3710         	adds	r7, #0x10
 801d162: 46bd         	mov	sp, r7
 801d164: bd80         	pop	{r7, pc}

0801d166 <cr_out_func>:
; {
 801d166: b580         	push	{r7, lr}
 801d168: b082         	sub	sp, #0x8
 801d16a: af00         	add	r7, sp, #0x0
 801d16c: 6078         	str	r0, [r7, #0x4]
 801d16e: 6039         	str	r1, [r7]
; 	if (c == '\n') {
 801d170: 687b         	ldr	r3, [r7, #0x4]
 801d172: 2b0a         	cmp	r3, #0xa
 801d174: d103         	bne	0x801d17e <cr_out_func+0x18> @ imm = #0x6
; 		out_func((int)'\r', ctx);
 801d176: 6839         	ldr	r1, [r7]
 801d178: 200d         	movs	r0, #0xd
 801d17a: f7ff ffdc    	bl	0x801d136 <out_func>    @ imm = #-0x48
; 	out_func(c, ctx);
 801d17e: 6839         	ldr	r1, [r7]
 801d180: 6878         	ldr	r0, [r7, #0x4]
 801d182: f7ff ffd8    	bl	0x801d136 <out_func>    @ imm = #-0x50
; 	return 0;
 801d186: 2300         	movs	r3, #0x0
; }
 801d188: 4618         	mov	r0, r3
 801d18a: 3708         	adds	r7, #0x8
 801d18c: 46bd         	mov	sp, r7
 801d18e: bd80         	pop	{r7, pc}

0801d190 <color_prefix>:
; {
 801d190: b580         	push	{r7, lr}
 801d192: b084         	sub	sp, #0x10
 801d194: af00         	add	r7, sp, #0x0
 801d196: 60f8         	str	r0, [r7, #0xc]
 801d198: 460b         	mov	r3, r1
 801d19a: 607a         	str	r2, [r7, #0x4]
 801d19c: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, true, level);
 801d19e: 7af9         	ldrb	r1, [r7, #0xb]
 801d1a0: 687b         	ldr	r3, [r7, #0x4]
 801d1a2: 2201         	movs	r2, #0x1
 801d1a4: 68f8         	ldr	r0, [r7, #0xc]
 801d1a6: f7e7 fe57    	bl	0x8004e58 <color_print> @ imm = #-0x18352
; }
 801d1aa: bf00         	nop
 801d1ac: 3710         	adds	r7, #0x10
 801d1ae: 46bd         	mov	sp, r7
 801d1b0: bd80         	pop	{r7, pc}

0801d1b2 <color_postfix>:
; {
 801d1b2: b580         	push	{r7, lr}
 801d1b4: b084         	sub	sp, #0x10
 801d1b6: af00         	add	r7, sp, #0x0
 801d1b8: 60f8         	str	r0, [r7, #0xc]
 801d1ba: 460b         	mov	r3, r1
 801d1bc: 607a         	str	r2, [r7, #0x4]
 801d1be: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, false, level);
 801d1c0: 7af9         	ldrb	r1, [r7, #0xb]
 801d1c2: 687b         	ldr	r3, [r7, #0x4]
 801d1c4: 2200         	movs	r2, #0x0
 801d1c6: 68f8         	ldr	r0, [r7, #0xc]
 801d1c8: f7e7 fe46    	bl	0x8004e58 <color_print> @ imm = #-0x18374
; }
 801d1cc: bf00         	nop
 801d1ce: 3710         	adds	r7, #0x10
 801d1d0: 46bd         	mov	sp, r7
 801d1d2: bd80         	pop	{r7, pc}

0801d1d4 <log_msg_hexdump>:
; {
 801d1d4: b580         	push	{r7, lr}
 801d1d6: b088         	sub	sp, #0x20
 801d1d8: af02         	add	r7, sp, #0x8
 801d1da: 60f8         	str	r0, [r7, #0xc]
 801d1dc: 60b9         	str	r1, [r7, #0x8]
 801d1de: 607a         	str	r2, [r7, #0x4]
 801d1e0: 603b         	str	r3, [r7]
; 		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
 801d1e2: 687b         	ldr	r3, [r7, #0x4]
 801d1e4: 2b10         	cmp	r3, #0x10
 801d1e6: bf28         	it	hs
 801d1e8: 2310         	movhs	r3, #0x10
 801d1ea: 617b         	str	r3, [r7, #0x14]
; 		hexdump_line_print(output, data, length,
 801d1ec: 6a3b         	ldr	r3, [r7, #0x20]
 801d1ee: 9300         	str	r3, [sp]
 801d1f0: 683b         	ldr	r3, [r7]
 801d1f2: 697a         	ldr	r2, [r7, #0x14]
 801d1f4: 68b9         	ldr	r1, [r7, #0x8]
 801d1f6: 68f8         	ldr	r0, [r7, #0xc]
 801d1f8: f7e7 fecc    	bl	0x8004f94 <hexdump_line_print> @ imm = #-0x18268
; 		data += length;
 801d1fc: 68ba         	ldr	r2, [r7, #0x8]
 801d1fe: 697b         	ldr	r3, [r7, #0x14]
 801d200: 4413         	add	r3, r2
 801d202: 60bb         	str	r3, [r7, #0x8]
; 		len -= length;
 801d204: 687a         	ldr	r2, [r7, #0x4]
 801d206: 697b         	ldr	r3, [r7, #0x14]
 801d208: 1ad3         	subs	r3, r2, r3
 801d20a: 607b         	str	r3, [r7, #0x4]
; 	} while (len);
 801d20c: 687b         	ldr	r3, [r7, #0x4]
 801d20e: 2b00         	cmp	r3, #0x0
 801d210: d1e7         	bne	0x801d1e2 <log_msg_hexdump+0xe> @ imm = #-0x32
; }
 801d212: bf00         	nop
 801d214: bf00         	nop
 801d216: 3718         	adds	r7, #0x18
 801d218: 46bd         	mov	sp, r7
 801d21a: bd80         	pop	{r7, pc}

0801d21c <postfix_print>:
; {
 801d21c: b580         	push	{r7, lr}
 801d21e: b084         	sub	sp, #0x10
 801d220: af00         	add	r7, sp, #0x0
 801d222: 60f8         	str	r0, [r7, #0xc]
 801d224: 60b9         	str	r1, [r7, #0x8]
 801d226: 4613         	mov	r3, r2
 801d228: 71fb         	strb	r3, [r7, #0x7]
; 	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
 801d22a: 68bb         	ldr	r3, [r7, #0x8]
 801d22c: f003 0301    	and	r3, r3, #0x1
 801d230: 2b00         	cmp	r3, #0x0
 801d232: bf14         	ite	ne
 801d234: 2301         	movne	r3, #0x1
 801d236: 2300         	moveq	r3, #0x0
 801d238: b2db         	uxtb	r3, r3
 801d23a: 79fa         	ldrb	r2, [r7, #0x7]
 801d23c: 4619         	mov	r1, r3
 801d23e: 68f8         	ldr	r0, [r7, #0xc]
 801d240: f7ff ffb7    	bl	0x801d1b2 <color_postfix> @ imm = #-0x92
; 	newline_print(output, flags);
 801d244: 68b9         	ldr	r1, [r7, #0x8]
 801d246: 68f8         	ldr	r0, [r7, #0xc]
 801d248: f7e7 fe82    	bl	0x8004f50 <newline_print> @ imm = #-0x182fc
; }
 801d24c: bf00         	nop
 801d24e: 3710         	adds	r7, #0x10
 801d250: 46bd         	mov	sp, r7
 801d252: bd80         	pop	{r7, pc}

0801d254 <log_output_msg_process>:
; {
 801d254: b580         	push	{r7, lr}
 801d256: b092         	sub	sp, #0x48
 801d258: af06         	add	r7, sp, #0x18
 801d25a: 60f8         	str	r0, [r7, #0xc]
 801d25c: 60b9         	str	r1, [r7, #0x8]
 801d25e: 607a         	str	r2, [r7, #0x4]
; 	log_timestamp_t timestamp = log_msg_get_timestamp(msg);
 801d260: 68b8         	ldr	r0, [r7, #0x8]
 801d262: f7ff feea    	bl	0x801d03a <log_msg_get_timestamp> @ imm = #-0x22c
 801d266: 62f8         	str	r0, [r7, #0x2c]
; 	uint8_t level = log_msg_get_level(msg);
 801d268: 68b8         	ldr	r0, [r7, #0x8]
 801d26a: f7ff fed7    	bl	0x801d01c <log_msg_get_level> @ imm = #-0x252
 801d26e: 4603         	mov	r3, r0
 801d270: f887 302b    	strb.w	r3, [r7, #0x2b]
; 	uint8_t domain_id = log_msg_get_domain(msg);
 801d274: 68b8         	ldr	r0, [r7, #0x8]
 801d276: f7ff fec2    	bl	0x801cffe <log_msg_get_domain> @ imm = #-0x27c
 801d27a: 4603         	mov	r3, r0
 801d27c: f887 302a    	strb.w	r3, [r7, #0x2a]
; 	int16_t source_id = log_msg_get_source_id(msg);
 801d280: 68b8         	ldr	r0, [r7, #0x8]
 801d282: f7ff fe92    	bl	0x801cfaa <log_msg_get_source_id> @ imm = #-0x2dc
 801d286: 4603         	mov	r3, r0
 801d288: 853b         	strh	r3, [r7, #0x28]
; 	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
 801d28a: f9b7 3028    	ldrsh.w	r3, [r7, #0x28]
 801d28e: 2b00         	cmp	r3, #0x0
 801d290: db09         	blt	0x801d2a6 <log_output_msg_process+0x52> @ imm = #0x12
 801d292: f897 302a    	ldrb.w	r3, [r7, #0x2a]
 801d296: f9b7 2028    	ldrsh.w	r2, [r7, #0x28]
 801d29a: 4611         	mov	r1, r2
 801d29c: 4618         	mov	r0, r3
 801d29e: f7e7 fc31    	bl	0x8004b04 <log_source_name_get> @ imm = #-0x1879e
 801d2a2: 4603         	mov	r3, r0
 801d2a4: e000         	b	0x801d2a8 <log_output_msg_process+0x54> @ imm = #0x0
 801d2a6: 2300         	movs	r3, #0x0
 801d2a8: 627b         	str	r3, [r7, #0x24]
; 	uint8_t *package = log_msg_get_package(msg, &plen);
 801d2aa: f107 0318    	add.w	r3, r7, #0x18
 801d2ae: 4619         	mov	r1, r3
 801d2b0: 68b8         	ldr	r0, [r7, #0x8]
 801d2b2: f7ff fef4    	bl	0x801d09e <log_msg_get_package> @ imm = #-0x218
 801d2b6: 6238         	str	r0, [r7, #0x20]
; 	uint8_t *data = log_msg_get_data(msg, &dlen);
 801d2b8: f107 0314    	add.w	r3, r7, #0x14
 801d2bc: 4619         	mov	r1, r3
 801d2be: 68b8         	ldr	r0, [r7, #0x8]
 801d2c0: f7ff fed2    	bl	0x801d068 <log_msg_get_data> @ imm = #-0x25c
 801d2c4: 61f8         	str	r0, [r7, #0x1c]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 801d2c6: 68b8         	ldr	r0, [r7, #0x8]
 801d2c8: f7ff fec3    	bl	0x801d052 <log_msg_get_tid> @ imm = #-0x27a
; 			   plen > 0 ? package : NULL, data, dlen, flags);
 801d2cc: 69bb         	ldr	r3, [r7, #0x18]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 801d2ce: 2b00         	cmp	r3, #0x0
 801d2d0: d001         	beq	0x801d2d6 <log_output_msg_process+0x82> @ imm = #0x2
 801d2d2: 6a3b         	ldr	r3, [r7, #0x20]
 801d2d4: e000         	b	0x801d2d8 <log_output_msg_process+0x84> @ imm = #0x0
 801d2d6: 2300         	movs	r3, #0x0
 801d2d8: 697a         	ldr	r2, [r7, #0x14]
 801d2da: 6879         	ldr	r1, [r7, #0x4]
 801d2dc: 9105         	str	r1, [sp, #0x14]
 801d2de: 9204         	str	r2, [sp, #0x10]
 801d2e0: 69fa         	ldr	r2, [r7, #0x1c]
 801d2e2: 9203         	str	r2, [sp, #0xc]
 801d2e4: 9302         	str	r3, [sp, #0x8]
 801d2e6: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 801d2ea: 9301         	str	r3, [sp, #0x4]
 801d2ec: 9000         	str	r0, [sp]
 801d2ee: 6a7b         	ldr	r3, [r7, #0x24]
 801d2f0: 2200         	movs	r2, #0x0
 801d2f2: 6af9         	ldr	r1, [r7, #0x2c]
 801d2f4: 68f8         	ldr	r0, [r7, #0xc]
 801d2f6: f7e7 ff47    	bl	0x8005188 <log_output_process> @ imm = #-0x18172
; }
 801d2fa: bf00         	nop
 801d2fc: 3730         	adds	r7, #0x30
 801d2fe: 46bd         	mov	sp, r7
 801d300: bd80         	pop	{r7, pc}

0801d302 <log_output_write>:
; {
 801d302: b580         	push	{r7, lr}
 801d304: b086         	sub	sp, #0x18
 801d306: af00         	add	r7, sp, #0x0
 801d308: 60f8         	str	r0, [r7, #0xc]
 801d30a: 60b9         	str	r1, [r7, #0x8]
 801d30c: 607a         	str	r2, [r7, #0x4]
 801d30e: 603b         	str	r3, [r7]
; 	while (len != 0) {
 801d310: e00d         	b	0x801d32e <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 801d312: 68fb         	ldr	r3, [r7, #0xc]
 801d314: 683a         	ldr	r2, [r7]
 801d316: 6879         	ldr	r1, [r7, #0x4]
 801d318: 68b8         	ldr	r0, [r7, #0x8]
 801d31a: 4798         	blx	r3
 801d31c: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 801d31e: 697b         	ldr	r3, [r7, #0x14]
 801d320: 687a         	ldr	r2, [r7, #0x4]
 801d322: 1ad3         	subs	r3, r2, r3
 801d324: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 801d326: 697b         	ldr	r3, [r7, #0x14]
 801d328: 68ba         	ldr	r2, [r7, #0x8]
 801d32a: 4413         	add	r3, r2
 801d32c: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 801d32e: 687b         	ldr	r3, [r7, #0x4]
 801d330: 2b00         	cmp	r3, #0x0
 801d332: d1ee         	bne	0x801d312 <log_output_write+0x10> @ imm = #-0x24
; }
 801d334: bf00         	nop
 801d336: bf00         	nop
 801d338: 3718         	adds	r7, #0x18
 801d33a: 46bd         	mov	sp, r7
 801d33c: bd80         	pop	{r7, pc}

0801d33e <log_output_flush>:
; {
 801d33e: b580         	push	{r7, lr}
 801d340: b082         	sub	sp, #0x8
 801d342: af00         	add	r7, sp, #0x0
 801d344: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 801d346: 687b         	ldr	r3, [r7, #0x4]
 801d348: 6818         	ldr	r0, [r3]
 801d34a: 687b         	ldr	r3, [r7, #0x4]
 801d34c: 6899         	ldr	r1, [r3, #0x8]
 801d34e: 687b         	ldr	r3, [r7, #0x4]
 801d350: 685b         	ldr	r3, [r3, #0x4]
 801d352: 681b         	ldr	r3, [r3]
 801d354: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 801d356: 687b         	ldr	r3, [r7, #0x4]
 801d358: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 801d35a: 685b         	ldr	r3, [r3, #0x4]
 801d35c: f7ff ffd1    	bl	0x801d302 <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 801d360: 687b         	ldr	r3, [r7, #0x4]
 801d362: 685b         	ldr	r3, [r3, #0x4]
 801d364: 2200         	movs	r2, #0x0
 801d366: 601a         	str	r2, [r3]
; }
 801d368: bf00         	nop
 801d36a: 3708         	adds	r7, #0x8
 801d36c: 46bd         	mov	sp, r7
 801d36e: bd80         	pop	{r7, pc}

0801d370 <log_output_ctx_set>:
; {
 801d370: b480         	push	{r7}
 801d372: b083         	sub	sp, #0xc
 801d374: af00         	add	r7, sp, #0x0
 801d376: 6078         	str	r0, [r7, #0x4]
 801d378: 6039         	str	r1, [r7]
; 	output->control_block->ctx = ctx;
 801d37a: 687b         	ldr	r3, [r7, #0x4]
 801d37c: 685b         	ldr	r3, [r3, #0x4]
 801d37e: 683a         	ldr	r2, [r7]
 801d380: 605a         	str	r2, [r3, #0x4]
; }
 801d382: bf00         	nop
 801d384: 370c         	adds	r7, #0xc
 801d386: 46bd         	mov	sp, r7
 801d388: f85d 7b04    	ldr	r7, [sp], #4
 801d38c: 4770         	bx	lr

0801d38e <log_backend_std_get_flags>:
; {
 801d38e: b480         	push	{r7}
 801d390: b083         	sub	sp, #0xc
 801d392: af00         	add	r7, sp, #0x0
; 	uint32_t flags = (LOG_OUTPUT_FLAG_LEVEL | LOG_OUTPUT_FLAG_TIMESTAMP);
 801d394: 230a         	movs	r3, #0xa
 801d396: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_COLORS;
 801d398: 687b         	ldr	r3, [r7, #0x4]
 801d39a: f043 0301    	orr	r3, r3, #0x1
 801d39e: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP;
 801d3a0: 687b         	ldr	r3, [r7, #0x4]
 801d3a2: f043 0304    	orr	r3, r3, #0x4
 801d3a6: 607b         	str	r3, [r7, #0x4]
; 	return flags;
 801d3a8: 687b         	ldr	r3, [r7, #0x4]
; }
 801d3aa: 4618         	mov	r0, r3
 801d3ac: 370c         	adds	r7, #0xc
 801d3ae: 46bd         	mov	sp, r7
 801d3b0: f85d 7b04    	ldr	r7, [sp], #4
 801d3b4: 4770         	bx	lr

0801d3b6 <log_backend_std_panic>:
; {
 801d3b6: b580         	push	{r7, lr}
 801d3b8: b082         	sub	sp, #0x8
 801d3ba: af00         	add	r7, sp, #0x0
 801d3bc: 6078         	str	r0, [r7, #0x4]
; 	log_output_flush(output);
 801d3be: 6878         	ldr	r0, [r7, #0x4]
 801d3c0: f7ff ffbd    	bl	0x801d33e <log_output_flush> @ imm = #-0x86
; }
 801d3c4: bf00         	nop
 801d3c6: 3708         	adds	r7, #0x8
 801d3c8: 46bd         	mov	sp, r7
 801d3ca: bd80         	pop	{r7, pc}

0801d3cc <z_impl_uart_poll_out>:
; {
 801d3cc: b580         	push	{r7, lr}
 801d3ce: b084         	sub	sp, #0x10
 801d3d0: af00         	add	r7, sp, #0x0
 801d3d2: 6078         	str	r0, [r7, #0x4]
 801d3d4: 460b         	mov	r3, r1
 801d3d6: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 801d3d8: 687b         	ldr	r3, [r7, #0x4]
 801d3da: 689b         	ldr	r3, [r3, #0x8]
 801d3dc: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 801d3de: 68fb         	ldr	r3, [r7, #0xc]
 801d3e0: 69db         	ldr	r3, [r3, #0x1c]
 801d3e2: 78fa         	ldrb	r2, [r7, #0x3]
 801d3e4: 4611         	mov	r1, r2
 801d3e6: 6878         	ldr	r0, [r7, #0x4]
 801d3e8: 4798         	blx	r3
; }
 801d3ea: bf00         	nop
 801d3ec: 3710         	adds	r7, #0x10
 801d3ee: 46bd         	mov	sp, r7
 801d3f0: bd80         	pop	{r7, pc}

0801d3f2 <uart_poll_out>:
; {
 801d3f2: b580         	push	{r7, lr}
 801d3f4: b082         	sub	sp, #0x8
 801d3f6: af00         	add	r7, sp, #0x0
 801d3f8: 6078         	str	r0, [r7, #0x4]
 801d3fa: 460b         	mov	r3, r1
 801d3fc: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 801d3fe: 78fb         	ldrb	r3, [r7, #0x3]
 801d400: 4619         	mov	r1, r3
 801d402: 6878         	ldr	r0, [r7, #0x4]
 801d404: f7ff ffe2    	bl	0x801d3cc <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 801d408: bf00         	nop
 801d40a: 3708         	adds	r7, #0x8
 801d40c: 46bd         	mov	sp, r7
 801d40e: bd80         	pop	{r7, pc}

0801d410 <pm_device_runtime_get>:
; {
 801d410: b480         	push	{r7}
 801d412: b083         	sub	sp, #0xc
 801d414: af00         	add	r7, sp, #0x0
 801d416: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801d418: 2300         	movs	r3, #0x0
; }
 801d41a: 4618         	mov	r0, r3
 801d41c: 370c         	adds	r7, #0xc
 801d41e: 46bd         	mov	sp, r7
 801d420: f85d 7b04    	ldr	r7, [sp], #4
 801d424: 4770         	bx	lr

0801d426 <pm_device_runtime_put_async>:
; {
 801d426: b480         	push	{r7}
 801d428: b085         	sub	sp, #0x14
 801d42a: af00         	add	r7, sp, #0x0
 801d42c: 60f8         	str	r0, [r7, #0xc]
 801d42e: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 801d432: 2300         	movs	r3, #0x0
; }
 801d434: 4618         	mov	r0, r3
 801d436: 3714         	adds	r7, #0x14
 801d438: 46bd         	mov	sp, r7
 801d43a: f85d 7b04    	ldr	r7, [sp], #4
 801d43e: 4770         	bx	lr

0801d440 <process>:
; {
 801d440: b580         	push	{r7, lr}
 801d442: b086         	sub	sp, #0x18
 801d444: af00         	add	r7, sp, #0x0
 801d446: 6078         	str	r0, [r7, #0x4]
 801d448: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 801d44a: 687b         	ldr	r3, [r7, #0x4]
 801d44c: 685b         	ldr	r3, [r3, #0x4]
 801d44e: 681b         	ldr	r3, [r3]
 801d450: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 801d452: 697b         	ldr	r3, [r7, #0x14]
 801d454: 685b         	ldr	r3, [r3, #0x4]
 801d456: 613b         	str	r3, [r7, #0x10]
; 	uint32_t flags = log_backend_std_get_flags();
 801d458: f7ff ff99    	bl	0x801d38e <log_backend_std_get_flags> @ imm = #-0xce
 801d45c: 60f8         	str	r0, [r7, #0xc]
; 	log_format_func_t log_output_func = log_format_func_t_get(data->log_format_current);
 801d45e: 693b         	ldr	r3, [r7, #0x10]
 801d460: 691b         	ldr	r3, [r3, #0x10]
 801d462: 4618         	mov	r0, r3
 801d464: f7e7 f964    	bl	0x8004730 <log_format_func_t_get> @ imm = #-0x18d38
 801d468: 60b8         	str	r0, [r7, #0x8]
; 	log_output_func(ctx->output, &msg->log, flags);
 801d46a: 697b         	ldr	r3, [r7, #0x14]
 801d46c: 6818         	ldr	r0, [r3]
 801d46e: 6839         	ldr	r1, [r7]
 801d470: 68bb         	ldr	r3, [r7, #0x8]
 801d472: 68fa         	ldr	r2, [r7, #0xc]
 801d474: 4798         	blx	r3
; }
 801d476: bf00         	nop
 801d478: 3718         	adds	r7, #0x18
 801d47a: 46bd         	mov	sp, r7
 801d47c: bd80         	pop	{r7, pc}

0801d47e <format_set>:
; {
 801d47e: b480         	push	{r7}
 801d480: b085         	sub	sp, #0x14
 801d482: af00         	add	r7, sp, #0x0
 801d484: 6078         	str	r0, [r7, #0x4]
 801d486: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 801d488: 687b         	ldr	r3, [r7, #0x4]
 801d48a: 685b         	ldr	r3, [r3, #0x4]
 801d48c: 681b         	ldr	r3, [r3]
 801d48e: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 801d490: 68fb         	ldr	r3, [r7, #0xc]
 801d492: 685b         	ldr	r3, [r3, #0x4]
 801d494: 60bb         	str	r3, [r7, #0x8]
; 	data->log_format_current = log_type;
 801d496: 68bb         	ldr	r3, [r7, #0x8]
 801d498: 683a         	ldr	r2, [r7]
 801d49a: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 801d49c: 2300         	movs	r3, #0x0
; }
 801d49e: 4618         	mov	r0, r3
 801d4a0: 3714         	adds	r7, #0x14
 801d4a2: 46bd         	mov	sp, r7
 801d4a4: f85d 7b04    	ldr	r7, [sp], #4
 801d4a8: 4770         	bx	lr

0801d4aa <z_log_msg_runtime_create>:
; {
 801d4aa: b580         	push	{r7, lr}
 801d4ac: b08a         	sub	sp, #0x28
 801d4ae: af04         	add	r7, sp, #0x10
 801d4b0: 60b9         	str	r1, [r7, #0x8]
 801d4b2: 607b         	str	r3, [r7, #0x4]
 801d4b4: 4603         	mov	r3, r0
 801d4b6: 73fb         	strb	r3, [r7, #0xf]
 801d4b8: 4613         	mov	r3, r2
 801d4ba: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801d4bc: f107 032c    	add.w	r3, r7, #0x2c
 801d4c0: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801d4c2: 7bba         	ldrb	r2, [r7, #0xe]
 801d4c4: 7bf8         	ldrb	r0, [r7, #0xf]
 801d4c6: 697b         	ldr	r3, [r7, #0x14]
 801d4c8: 9303         	str	r3, [sp, #0xc]
 801d4ca: 6abb         	ldr	r3, [r7, #0x28]
 801d4cc: 9302         	str	r3, [sp, #0x8]
 801d4ce: 6a7b         	ldr	r3, [r7, #0x24]
 801d4d0: 9301         	str	r3, [sp, #0x4]
 801d4d2: 6a3b         	ldr	r3, [r7, #0x20]
 801d4d4: 9300         	str	r3, [sp]
 801d4d6: 687b         	ldr	r3, [r7, #0x4]
 801d4d8: 68b9         	ldr	r1, [r7, #0x8]
 801d4da: f7e7 fb4b    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1896a
; }
 801d4de: bf00         	nop
 801d4e0: 3718         	adds	r7, #0x18
 801d4e2: 46bd         	mov	sp, r7
 801d4e4: bd80         	pop	{r7, pc}

0801d4e6 <z_do_kernel_oops>:
; {
 801d4e6: b580         	push	{r7, lr}
 801d4e8: b088         	sub	sp, #0x20
 801d4ea: af00         	add	r7, sp, #0x0
 801d4ec: 60f8         	str	r0, [r7, #0xc]
 801d4ee: 60b9         	str	r1, [r7, #0x8]
 801d4f0: 607a         	str	r2, [r7, #0x4]
; 	unsigned int reason = esf->basic.r0;
 801d4f2: 68fb         	ldr	r3, [r7, #0xc]
 801d4f4: 681b         	ldr	r3, [r3]
 801d4f6: 61fb         	str	r3, [r7, #0x1c]
 801d4f8: 68fb         	ldr	r3, [r7, #0xc]
 801d4fa: 61bb         	str	r3, [r7, #0x18]
 801d4fc: 687b         	ldr	r3, [r7, #0x4]
 801d4fe: 617b         	str	r3, [r7, #0x14]
; }
 801d500: bf00         	nop
; 	z_arm_fatal_error(reason, esf);
 801d502: 68f9         	ldr	r1, [r7, #0xc]
 801d504: 69f8         	ldr	r0, [r7, #0x1c]
 801d506: f7e8 f837    	bl	0x8005578 <z_arm_fatal_error> @ imm = #-0x17f92
; }
 801d50a: bf00         	nop
 801d50c: 3720         	adds	r7, #0x20
 801d50e: 46bd         	mov	sp, r7
 801d510: bd80         	pop	{r7, pc}

0801d512 <arch_tls_stack_setup>:
; {
 801d512: b580         	push	{r7, lr}
 801d514: b082         	sub	sp, #0x8
 801d516: af00         	add	r7, sp, #0x0
 801d518: 6078         	str	r0, [r7, #0x4]
 801d51a: 6039         	str	r1, [r7]
; 	stack_ptr -= z_tls_data_size();
 801d51c: f7e8 f878    	bl	0x8005610 <z_tls_data_size> @ imm = #-0x17f10
 801d520: 4603         	mov	r3, r0
 801d522: 425b         	rsbs	r3, r3, #0
 801d524: 683a         	ldr	r2, [r7]
 801d526: 4413         	add	r3, r2
 801d528: 603b         	str	r3, [r7]
; 	z_tls_copy(stack_ptr);
 801d52a: 6838         	ldr	r0, [r7]
 801d52c: f7e8 f87e    	bl	0x800562c <z_tls_copy>  @ imm = #-0x17f04
; 	stack_ptr -= sizeof(uintptr_t) * 2;
 801d530: 683b         	ldr	r3, [r7]
 801d532: 3b08         	subs	r3, #0x8
 801d534: 603b         	str	r3, [r7]
; 	new_thread->tls = POINTER_TO_UINT(stack_ptr);
 801d536: 683a         	ldr	r2, [r7]
 801d538: 687b         	ldr	r3, [r7, #0x4]
 801d53a: f8c3 20c4    	str.w	r2, [r3, #0xc4]
; 	return (z_tls_data_size() + (sizeof(uintptr_t) * 2));
 801d53e: f7e8 f867    	bl	0x8005610 <z_tls_data_size> @ imm = #-0x17f32
 801d542: 4603         	mov	r3, r0
 801d544: 3308         	adds	r3, #0x8
; }
 801d546: 4618         	mov	r0, r3
 801d548: 3708         	adds	r7, #0x8
 801d54a: 46bd         	mov	sp, r7
 801d54c: bd80         	pop	{r7, pc}

0801d54e <z_log_msg_runtime_create>:
; {
 801d54e: b580         	push	{r7, lr}
 801d550: b08a         	sub	sp, #0x28
 801d552: af04         	add	r7, sp, #0x10
 801d554: 60b9         	str	r1, [r7, #0x8]
 801d556: 607b         	str	r3, [r7, #0x4]
 801d558: 4603         	mov	r3, r0
 801d55a: 73fb         	strb	r3, [r7, #0xf]
 801d55c: 4613         	mov	r3, r2
 801d55e: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801d560: f107 032c    	add.w	r3, r7, #0x2c
 801d564: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801d566: 7bba         	ldrb	r2, [r7, #0xe]
 801d568: 7bf8         	ldrb	r0, [r7, #0xf]
 801d56a: 697b         	ldr	r3, [r7, #0x14]
 801d56c: 9303         	str	r3, [sp, #0xc]
 801d56e: 6abb         	ldr	r3, [r7, #0x28]
 801d570: 9302         	str	r3, [sp, #0x8]
 801d572: 6a7b         	ldr	r3, [r7, #0x24]
 801d574: 9301         	str	r3, [sp, #0x4]
 801d576: 6a3b         	ldr	r3, [r7, #0x20]
 801d578: 9300         	str	r3, [sp]
 801d57a: 687b         	ldr	r3, [r7, #0x4]
 801d57c: 68b9         	ldr	r1, [r7, #0x8]
 801d57e: f7e7 faf9    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x18a0e
; }
 801d582: bf00         	nop
 801d584: 3718         	adds	r7, #0x18
 801d586: 46bd         	mov	sp, r7
 801d588: bd80         	pop	{r7, pc}

0801d58a <fault_show>:
; {
 801d58a: b480         	push	{r7}
 801d58c: b083         	sub	sp, #0xc
 801d58e: af00         	add	r7, sp, #0x0
 801d590: 6078         	str	r0, [r7, #0x4]
 801d592: 6039         	str	r1, [r7]
; }
 801d594: bf00         	nop
 801d596: 370c         	adds	r7, #0xc
 801d598: 46bd         	mov	sp, r7
 801d59a: f85d 7b04    	ldr	r7, [sp], #4
 801d59e: 4770         	bx	lr

0801d5a0 <memory_fault_recoverable>:
; {
 801d5a0: b480         	push	{r7}
 801d5a2: b083         	sub	sp, #0xc
 801d5a4: af00         	add	r7, sp, #0x0
 801d5a6: 6078         	str	r0, [r7, #0x4]
 801d5a8: 460b         	mov	r3, r1
 801d5aa: 70fb         	strb	r3, [r7, #0x3]
; 	return false;
 801d5ac: 2300         	movs	r3, #0x0
; }
 801d5ae: 4618         	mov	r0, r3
 801d5b0: 370c         	adds	r7, #0xc
 801d5b2: 46bd         	mov	sp, r7
 801d5b4: f85d 7b04    	ldr	r7, [sp], #4
 801d5b8: 4770         	bx	lr

0801d5ba <arch_irq_enable>:
; {
 801d5ba: b580         	push	{r7, lr}
 801d5bc: b082         	sub	sp, #0x8
 801d5be: af00         	add	r7, sp, #0x0
 801d5c0: 6078         	str	r0, [r7, #0x4]
; 	NVIC_EnableIRQ((IRQn_Type)irq);
 801d5c2: 687b         	ldr	r3, [r7, #0x4]
 801d5c4: b21b         	sxth	r3, r3
 801d5c6: 4618         	mov	r0, r3
 801d5c8: f7e8 ffc6    	bl	0x8006558 <__NVIC_EnableIRQ> @ imm = #-0x17074
; }
 801d5cc: bf00         	nop
 801d5ce: 3708         	adds	r7, #0x8
 801d5d0: 46bd         	mov	sp, r7
 801d5d2: bd80         	pop	{r7, pc}

0801d5d4 <z_arm_irq_priority_set>:
; {
 801d5d4: b580         	push	{r7, lr}
 801d5d6: b084         	sub	sp, #0x10
 801d5d8: af00         	add	r7, sp, #0x0
 801d5da: 60f8         	str	r0, [r7, #0xc]
 801d5dc: 60b9         	str	r1, [r7, #0x8]
 801d5de: 607a         	str	r2, [r7, #0x4]
; 		prio += _IRQ_PRIO_OFFSET;
 801d5e0: 68bb         	ldr	r3, [r7, #0x8]
 801d5e2: 3301         	adds	r3, #0x1
 801d5e4: 60bb         	str	r3, [r7, #0x8]
; 	NVIC_SetPriority((IRQn_Type)irq, prio);
 801d5e6: 68fb         	ldr	r3, [r7, #0xc]
 801d5e8: b21b         	sxth	r3, r3
 801d5ea: 68b9         	ldr	r1, [r7, #0x8]
 801d5ec: 4618         	mov	r0, r3
 801d5ee: f7e8 ffd1    	bl	0x8006594 <__NVIC_SetPriority> @ imm = #-0x1705e
; }
 801d5f2: bf00         	nop
 801d5f4: 3710         	adds	r7, #0x10
 801d5f6: 46bd         	mov	sp, r7
 801d5f8: bd80         	pop	{r7, pc}

0801d5fa <z_irq_spurious>:
; {
 801d5fa: b580         	push	{r7, lr}
 801d5fc: b082         	sub	sp, #0x8
 801d5fe: af00         	add	r7, sp, #0x0
 801d600: 6078         	str	r0, [r7, #0x4]
; 	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 801d602: 2100         	movs	r1, #0x0
 801d604: 2001         	movs	r0, #0x1
 801d606: f7e7 ffb7    	bl	0x8005578 <z_arm_fatal_error> @ imm = #-0x18092
; }
 801d60a: bf00         	nop
 801d60c: 3708         	adds	r7, #0x8
 801d60e: 46bd         	mov	sp, r7
 801d610: bd80         	pop	{r7, pc}

0801d612 <z_prep_c>:
; {
 801d612: b580         	push	{r7, lr}
 801d614: af00         	add	r7, sp, #0x0
; 	relocate_vector_table();
 801d616: f7e8 ffe7    	bl	0x80065e8 <relocate_vector_table> @ imm = #-0x17032
; 	z_arm_floating_point_init();
 801d61a: f7e8 ffff    	bl	0x800661c <z_arm_floating_point_init> @ imm = #-0x17002
; 	z_bss_zero();
 801d61e: f7f7 f8db    	bl	0x80147d8 <z_bss_zero>  @ imm = #-0x8e4a
; 	z_data_copy();
 801d622: f7fa fce9    	bl	0x8017ff8 <z_data_copy> @ imm = #-0x562e
; 	z_arm_interrupt_init();
 801d626: f000 f85b    	bl	0x801d6e0 <z_arm_interrupt_init> @ imm = #0xb6
; 	z_cstart();
 801d62a: f7f7 f9ff    	bl	0x8014a2c <z_cstart>    @ imm = #-0x8c02

0801d62e <z_arm_prepare_switch_to_main>:
; {
 801d62e: b480         	push	{r7}
 801d630: b085         	sub	sp, #0x14
 801d632: af00         	add	r7, sp, #0x0
 801d634: 2300         	movs	r3, #0x0
 801d636: 607b         	str	r3, [r7, #0x4]
;   __builtin_arm_set_fpscr(fpscr);
 801d638: 687b         	ldr	r3, [r7, #0x4]
 801d63a: eee1 3a10    	<unknown>
; }
 801d63e: bf00         	nop
;   __ASM volatile ("MRS %0, control" : "=r" (result) );
 801d640: f3ef 8314    	mrs	r3, control
 801d644: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 801d646: 68bb         	ldr	r3, [r7, #0x8]
; 	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
 801d648: f023 0304    	bic	r3, r3, #0x4
 801d64c: 60fb         	str	r3, [r7, #0xc]
;   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 801d64e: 68fb         	ldr	r3, [r7, #0xc]
 801d650: f383 8814    	msr	control, r3
;   __ASM volatile ("isb 0xF":::"memory");
 801d654: f3bf 8f6f    	isb	sy
; }
 801d658: bf00         	nop
; }
 801d65a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801d65c: f3bf 8f6f    	isb	sy
; }
 801d660: bf00         	nop
; }
 801d662: bf00         	nop
; }
 801d664: bf00         	nop
; }
 801d666: bf00         	nop
 801d668: 3714         	adds	r7, #0x14
 801d66a: 46bd         	mov	sp, r7
 801d66c: f85d 7b04    	ldr	r7, [sp], #4
 801d670: 4770         	bx	lr

0801d672 <arch_irq_unlock_outlined>:
; {
 801d672: b480         	push	{r7}
 801d674: b085         	sub	sp, #0x14
 801d676: af00         	add	r7, sp, #0x0
 801d678: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("cpsie f" : : : "memory");
 801d67a: b661         	cpsie f
; }
 801d67c: bf00         	nop
;   __ASM volatile ("cpsie i" : : : "memory");
 801d67e: b662         	cpsie i
; }
 801d680: bf00         	nop
 801d682: 687b         	ldr	r3, [r7, #0x4]
 801d684: 60fb         	str	r3, [r7, #0xc]
 801d686: 68fb         	ldr	r3, [r7, #0xc]
 801d688: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801d68a: 68bb         	ldr	r3, [r7, #0x8]
 801d68c: f383 8811    	msr	basepri, r3
; }
 801d690: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801d692: f3bf 8f6f    	isb	sy
; }
 801d696: bf00         	nop
; }
 801d698: bf00         	nop
; }
 801d69a: bf00         	nop
 801d69c: 3714         	adds	r7, #0x14
 801d69e: 46bd         	mov	sp, r7
 801d6a0: f85d 7b04    	ldr	r7, [sp], #4
 801d6a4: 4770         	bx	lr

0801d6a6 <arch_cpu_idle>:
; {
 801d6a6: b480         	push	{r7}
 801d6a8: b083         	sub	sp, #0xc
 801d6aa: af00         	add	r7, sp, #0x0
;   __ASM volatile ("cpsid i" : : : "memory");
 801d6ac: b672         	cpsid i
; }
 801d6ae: bf00         	nop
 801d6b0: 2300         	movs	r3, #0x0
 801d6b2: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801d6b4: 687b         	ldr	r3, [r7, #0x4]
 801d6b6: f383 8811    	msr	basepri, r3
; }
 801d6ba: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801d6bc: f3bf 8f6f    	isb	sy
; }
 801d6c0: bf00         	nop
;   __ASM volatile ("dsb 0xF":::"memory");
 801d6c2: f3bf 8f4f    	dsb	sy
; }
 801d6c6: bf00         	nop
; 	SLEEP_IF_ALLOWED(__WFI);
 801d6c8: bf30         	wfi
;   __ASM volatile ("cpsie i" : : : "memory");
 801d6ca: b662         	cpsie i
; }
 801d6cc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801d6ce: f3bf 8f6f    	isb	sy
; }
 801d6d2: bf00         	nop
; }
 801d6d4: bf00         	nop
 801d6d6: 370c         	adds	r7, #0xc
 801d6d8: 46bd         	mov	sp, r7
 801d6da: f85d 7b04    	ldr	r7, [sp], #4
 801d6de: 4770         	bx	lr

0801d6e0 <z_arm_interrupt_init>:
; {
 801d6e0: b580         	push	{r7, lr}
 801d6e2: b082         	sub	sp, #0x8
 801d6e4: af00         	add	r7, sp, #0x0
; 	int irq = 0;
 801d6e6: 2300         	movs	r3, #0x0
 801d6e8: 607b         	str	r3, [r7, #0x4]
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 801d6ea: e008         	b	0x801d6fe <z_arm_interrupt_init+0x1e> @ imm = #0x10
; 		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
 801d6ec: 687b         	ldr	r3, [r7, #0x4]
 801d6ee: b21b         	sxth	r3, r3
 801d6f0: 2101         	movs	r1, #0x1
 801d6f2: 4618         	mov	r0, r3
 801d6f4: f7e9 f890    	bl	0x8006818 <__NVIC_SetPriority> @ imm = #-0x16ee0
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 801d6f8: 687b         	ldr	r3, [r7, #0x4]
 801d6fa: 3301         	adds	r3, #0x1
 801d6fc: 607b         	str	r3, [r7, #0x4]
 801d6fe: 687b         	ldr	r3, [r7, #0x4]
 801d700: 2ba2         	cmp	r3, #0xa2
 801d702: ddf3         	ble	0x801d6ec <z_arm_interrupt_init+0xc> @ imm = #-0x1a
; }
 801d704: bf00         	nop
 801d706: bf00         	nop
 801d708: 3708         	adds	r7, #0x8
 801d70a: 46bd         	mov	sp, r7
 801d70c: bd80         	pop	{r7, pc}

0801d70e <cbputc>:
; {
 801d70e: b580         	push	{r7, lr}
 801d710: b084         	sub	sp, #0x10
 801d712: af00         	add	r7, sp, #0x0
 801d714: 4603         	mov	r3, r0
 801d716: 6039         	str	r1, [r7]
 801d718: 71fb         	strb	r3, [r7, #0x7]
; 	struct cb_bits *s = (struct cb_bits *) _s;
 801d71a: 683b         	ldr	r3, [r7]
 801d71c: 60fb         	str	r3, [r7, #0xc]
; 	(*s->out) (c, s->ctx);
 801d71e: 68fb         	ldr	r3, [r7, #0xc]
 801d720: 691b         	ldr	r3, [r3, #0x10]
 801d722: 79f8         	ldrb	r0, [r7, #0x7]
 801d724: 68fa         	ldr	r2, [r7, #0xc]
 801d726: 6952         	ldr	r2, [r2, #0x14]
 801d728: 4611         	mov	r1, r2
 801d72a: 4798         	blx	r3
; 	return 0;
 801d72c: 2300         	movs	r3, #0x0
; }
 801d72e: 4618         	mov	r0, r3
 801d730: 3710         	adds	r7, #0x10
 801d732: 46bd         	mov	sp, r7
 801d734: bd80         	pop	{r7, pc}

0801d736 <zephyr_fputc>:
; {
 801d736: b580         	push	{r7, lr}
 801d738: b082         	sub	sp, #0x8
 801d73a: af00         	add	r7, sp, #0x0
 801d73c: 6078         	str	r0, [r7, #0x4]
 801d73e: 6039         	str	r1, [r7]
; 	return z_impl_zephyr_fputc(c, stream);
 801d740: 6839         	ldr	r1, [r7]
 801d742: 6878         	ldr	r0, [r7, #0x4]
 801d744: f7e9 f8d6    	bl	0x80068f4 <z_impl_zephyr_fputc> @ imm = #-0x16e54
 801d748: 4603         	mov	r3, r0
; }
 801d74a: 4618         	mov	r0, r3
 801d74c: 3708         	adds	r7, #0x8
 801d74e: 46bd         	mov	sp, r7
 801d750: bd80         	pop	{r7, pc}

0801d752 <picolibc_put>:
; {
 801d752: b580         	push	{r7, lr}
 801d754: b082         	sub	sp, #0x8
 801d756: af00         	add	r7, sp, #0x0
 801d758: 4603         	mov	r3, r0
 801d75a: 6039         	str	r1, [r7]
 801d75c: 71fb         	strb	r3, [r7, #0x7]
; 	zephyr_fputc(a, f);
 801d75e: 79fb         	ldrb	r3, [r7, #0x7]
 801d760: 6839         	ldr	r1, [r7]
 801d762: 4618         	mov	r0, r3
 801d764: f7ff ffe7    	bl	0x801d736 <zephyr_fputc> @ imm = #-0x32
; 	return 0;
 801d768: 2300         	movs	r3, #0x0
; }
 801d76a: 4618         	mov	r0, r3
 801d76c: 3708         	adds	r7, #0x8
 801d76e: 46bd         	mov	sp, r7
 801d770: bd80         	pop	{r7, pc}

0801d772 <k_mutex_lock>:
; {
 801d772: b580         	push	{r7, lr}
 801d774: b084         	sub	sp, #0x10
 801d776: af00         	add	r7, sp, #0x0
 801d778: 60f8         	str	r0, [r7, #0xc]
 801d77a: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_mutex_lock(mutex, timeout);
 801d77e: e9d7 2300    	ldrd	r2, r3, [r7]
 801d782: 68f8         	ldr	r0, [r7, #0xc]
 801d784: f7f7 fb9e    	bl	0x8014ec4 <z_impl_k_mutex_lock> @ imm = #-0x88c4
 801d788: 4603         	mov	r3, r0
; }
 801d78a: 4618         	mov	r0, r3
 801d78c: 3710         	adds	r7, #0x10
 801d78e: 46bd         	mov	sp, r7
 801d790: bd80         	pop	{r7, pc}

0801d792 <k_mutex_unlock>:
; {
 801d792: b580         	push	{r7, lr}
 801d794: b082         	sub	sp, #0x8
 801d796: af00         	add	r7, sp, #0x0
 801d798: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_unlock(mutex);
 801d79a: 6878         	ldr	r0, [r7, #0x4]
 801d79c: f7f7 fddc    	bl	0x8015358 <z_impl_k_mutex_unlock> @ imm = #-0x8448
 801d7a0: 4603         	mov	r3, r0
; }
 801d7a2: 4618         	mov	r0, r3
 801d7a4: 3708         	adds	r7, #0x8
 801d7a6: 46bd         	mov	sp, r7
 801d7a8: bd80         	pop	{r7, pc}

0801d7aa <sys_mutex_lock>:
; {
 801d7aa: b580         	push	{r7, lr}
 801d7ac: b084         	sub	sp, #0x10
 801d7ae: af00         	add	r7, sp, #0x0
 801d7b0: 60f8         	str	r0, [r7, #0xc]
 801d7b2: e9c7 2300    	strd	r2, r3, [r7]
; 	return k_mutex_lock(&mutex->kernel_mutex, timeout);
 801d7b6: 68f9         	ldr	r1, [r7, #0xc]
 801d7b8: e9d7 2300    	ldrd	r2, r3, [r7]
 801d7bc: 4608         	mov	r0, r1
 801d7be: f7ff ffd8    	bl	0x801d772 <k_mutex_lock> @ imm = #-0x50
 801d7c2: 4603         	mov	r3, r0
; }
 801d7c4: 4618         	mov	r0, r3
 801d7c6: 3710         	adds	r7, #0x10
 801d7c8: 46bd         	mov	sp, r7
 801d7ca: bd80         	pop	{r7, pc}

0801d7cc <sys_mutex_unlock>:
; {
 801d7cc: b580         	push	{r7, lr}
 801d7ce: b082         	sub	sp, #0x8
 801d7d0: af00         	add	r7, sp, #0x0
 801d7d2: 6078         	str	r0, [r7, #0x4]
; 	return k_mutex_unlock(&mutex->kernel_mutex);
 801d7d4: 687b         	ldr	r3, [r7, #0x4]
 801d7d6: 4618         	mov	r0, r3
 801d7d8: f7ff ffdb    	bl	0x801d792 <k_mutex_unlock> @ imm = #-0x4a
 801d7dc: 4603         	mov	r3, r0
; }
 801d7de: 4618         	mov	r0, r3
 801d7e0: 3708         	adds	r7, #0x8
 801d7e2: 46bd         	mov	sp, r7
 801d7e4: bd80         	pop	{r7, pc}

0801d7e6 <z_log_msg_runtime_create>:
; {
 801d7e6: b580         	push	{r7, lr}
 801d7e8: b08a         	sub	sp, #0x28
 801d7ea: af04         	add	r7, sp, #0x10
 801d7ec: 60b9         	str	r1, [r7, #0x8]
 801d7ee: 607b         	str	r3, [r7, #0x4]
 801d7f0: 4603         	mov	r3, r0
 801d7f2: 73fb         	strb	r3, [r7, #0xf]
 801d7f4: 4613         	mov	r3, r2
 801d7f6: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801d7f8: f107 032c    	add.w	r3, r7, #0x2c
 801d7fc: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801d7fe: 7bba         	ldrb	r2, [r7, #0xe]
 801d800: 7bf8         	ldrb	r0, [r7, #0xf]
 801d802: 697b         	ldr	r3, [r7, #0x14]
 801d804: 9303         	str	r3, [sp, #0xc]
 801d806: 6abb         	ldr	r3, [r7, #0x28]
 801d808: 9302         	str	r3, [sp, #0x8]
 801d80a: 6a7b         	ldr	r3, [r7, #0x24]
 801d80c: 9301         	str	r3, [sp, #0x4]
 801d80e: 6a3b         	ldr	r3, [r7, #0x20]
 801d810: 9300         	str	r3, [sp]
 801d812: 687b         	ldr	r3, [r7, #0x4]
 801d814: 68b9         	ldr	r1, [r7, #0x8]
 801d816: f7e7 f9ad    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x18ca6
; }
 801d81a: bf00         	nop
 801d81c: 3718         	adds	r7, #0x18
 801d81e: 46bd         	mov	sp, r7
 801d820: bd80         	pop	{r7, pc}

0801d822 <k_work_queue_thread_get>:
; {
 801d822: b480         	push	{r7}
 801d824: b083         	sub	sp, #0xc
 801d826: af00         	add	r7, sp, #0x0
 801d828: 6078         	str	r0, [r7, #0x4]
; 	return &queue->thread;
 801d82a: 687b         	ldr	r3, [r7, #0x4]
; }
 801d82c: 4618         	mov	r0, r3
 801d82e: 370c         	adds	r7, #0xc
 801d830: 46bd         	mov	sp, r7
 801d832: f85d 7b04    	ldr	r7, [sp], #4
 801d836: 4770         	bx	lr

0801d838 <k_queue_get>:
; {
 801d838: b580         	push	{r7, lr}
 801d83a: b084         	sub	sp, #0x10
 801d83c: af00         	add	r7, sp, #0x0
 801d83e: 60f8         	str	r0, [r7, #0xc]
 801d840: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_queue_get(queue, timeout);
 801d844: e9d7 2300    	ldrd	r2, r3, [r7]
 801d848: 68f8         	ldr	r0, [r7, #0xc]
 801d84a: f7f7 fe7f    	bl	0x801554c <z_impl_k_queue_get> @ imm = #-0x8302
 801d84e: 4603         	mov	r3, r0
; }
 801d850: 4618         	mov	r0, r3
 801d852: 3710         	adds	r7, #0x10
 801d854: 46bd         	mov	sp, r7
 801d856: bd80         	pop	{r7, pc}

0801d858 <net_buf_simple_reset>:
; {
 801d858: b480         	push	{r7}
 801d85a: b083         	sub	sp, #0xc
 801d85c: af00         	add	r7, sp, #0x0
 801d85e: 6078         	str	r0, [r7, #0x4]
; 	buf->len  = 0U;
 801d860: 687b         	ldr	r3, [r7, #0x4]
 801d862: 2200         	movs	r2, #0x0
 801d864: 809a         	strh	r2, [r3, #0x4]
; 	buf->data = buf->__buf;
 801d866: 687b         	ldr	r3, [r7, #0x4]
 801d868: 689a         	ldr	r2, [r3, #0x8]
 801d86a: 687b         	ldr	r3, [r7, #0x4]
 801d86c: 601a         	str	r2, [r3]
; }
 801d86e: bf00         	nop
 801d870: 370c         	adds	r7, #0xc
 801d872: 46bd         	mov	sp, r7
 801d874: f85d 7b04    	ldr	r7, [sp], #4
 801d878: 4770         	bx	lr

0801d87a <net_buf_destroy>:
; {
 801d87a: b580         	push	{r7, lr}
 801d87c: b084         	sub	sp, #0x10
 801d87e: af00         	add	r7, sp, #0x0
 801d880: 6078         	str	r0, [r7, #0x4]
; 	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 801d882: 687b         	ldr	r3, [r7, #0x4]
 801d884: 7a9b         	ldrb	r3, [r3, #0xa]
 801d886: 4618         	mov	r0, r3
 801d888: f7e9 f8ca    	bl	0x8006a20 <net_buf_pool_get> @ imm = #-0x16e6c
 801d88c: 60f8         	str	r0, [r7, #0xc]
; 	if (buf->__buf) {
 801d88e: 687b         	ldr	r3, [r7, #0x4]
 801d890: 695b         	ldr	r3, [r3, #0x14]
 801d892: 2b00         	cmp	r3, #0x0
 801d894: d011         	beq	0x801d8ba <net_buf_destroy+0x40> @ imm = #0x22
; 		if (!(buf->flags & NET_BUF_EXTERNAL_DATA)) {
 801d896: 687b         	ldr	r3, [r7, #0x4]
 801d898: 7a5b         	ldrb	r3, [r3, #0x9]
 801d89a: f003 0301    	and	r3, r3, #0x1
 801d89e: 2b00         	cmp	r3, #0x0
 801d8a0: d108         	bne	0x801d8b4 <net_buf_destroy+0x3a> @ imm = #0x10
; 			pool->alloc->cb->unref(buf, buf->__buf);
 801d8a2: 68fb         	ldr	r3, [r7, #0xc]
 801d8a4: 69db         	ldr	r3, [r3, #0x1c]
 801d8a6: 681b         	ldr	r3, [r3]
 801d8a8: 689b         	ldr	r3, [r3, #0x8]
 801d8aa: 687a         	ldr	r2, [r7, #0x4]
 801d8ac: 6952         	ldr	r2, [r2, #0x14]
 801d8ae: 4611         	mov	r1, r2
 801d8b0: 6878         	ldr	r0, [r7, #0x4]
 801d8b2: 4798         	blx	r3
; 		buf->__buf = NULL;
 801d8b4: 687b         	ldr	r3, [r7, #0x4]
 801d8b6: 2200         	movs	r2, #0x0
 801d8b8: 615a         	str	r2, [r3, #0x14]
; 	k_lifo_put(&pool->free, buf);
 801d8ba: 68fb         	ldr	r3, [r7, #0xc]
 801d8bc: 6879         	ldr	r1, [r7, #0x4]
 801d8be: 4618         	mov	r0, r3
 801d8c0: f009 fe70    	bl	0x80275a4 <k_queue_prepend> @ imm = #0x9ce0
; }
 801d8c4: bf00         	nop
 801d8c6: 3710         	adds	r7, #0x10
 801d8c8: 46bd         	mov	sp, r7
 801d8ca: bd80         	pop	{r7, pc}

0801d8cc <net_buf_add_mem>:
; {
 801d8cc: b580         	push	{r7, lr}
 801d8ce: b084         	sub	sp, #0x10
 801d8d0: af00         	add	r7, sp, #0x0
 801d8d2: 60f8         	str	r0, [r7, #0xc]
 801d8d4: 60b9         	str	r1, [r7, #0x8]
 801d8d6: 607a         	str	r2, [r7, #0x4]
; 	return net_buf_simple_add_mem(&buf->b, mem, len);
 801d8d8: 68fb         	ldr	r3, [r7, #0xc]
 801d8da: 330c         	adds	r3, #0xc
 801d8dc: 687a         	ldr	r2, [r7, #0x4]
 801d8de: 68b9         	ldr	r1, [r7, #0x8]
 801d8e0: 4618         	mov	r0, r3
 801d8e2: f000 f9af    	bl	0x801dc44 <net_buf_simple_add_mem> @ imm = #0x35e
 801d8e6: 4603         	mov	r3, r0
; }
 801d8e8: 4618         	mov	r0, r3
 801d8ea: 3710         	adds	r7, #0x10
 801d8ec: 46bd         	mov	sp, r7
 801d8ee: bd80         	pop	{r7, pc}

0801d8f0 <net_buf_headroom>:
; {
 801d8f0: b580         	push	{r7, lr}
 801d8f2: b082         	sub	sp, #0x8
 801d8f4: af00         	add	r7, sp, #0x0
 801d8f6: 6078         	str	r0, [r7, #0x4]
; 	return net_buf_simple_headroom(&buf->b);
 801d8f8: 687b         	ldr	r3, [r7, #0x4]
 801d8fa: 330c         	adds	r3, #0xc
 801d8fc: 4618         	mov	r0, r3
 801d8fe: f000 f9ce    	bl	0x801dc9e <net_buf_simple_headroom> @ imm = #0x39c
 801d902: 4603         	mov	r3, r0
; }
 801d904: 4618         	mov	r0, r3
 801d906: 3708         	adds	r7, #0x8
 801d908: 46bd         	mov	sp, r7
 801d90a: bd80         	pop	{r7, pc}

0801d90c <pool_get_uninit>:
; {
 801d90c: b580         	push	{r7, lr}
 801d90e: b086         	sub	sp, #0x18
 801d910: af00         	add	r7, sp, #0x0
 801d912: 6078         	str	r0, [r7, #0x4]
 801d914: 460b         	mov	r3, r1
 801d916: 807b         	strh	r3, [r7, #0x2]
; 	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 801d918: 687b         	ldr	r3, [r7, #0x4]
 801d91a: 7d1b         	ldrb	r3, [r3, #0x14]
 801d91c: 331b         	adds	r3, #0x1b
 801d91e: f023 0303    	bic	r3, r3, #0x3
 801d922: 617b         	str	r3, [r7, #0x14]
; 	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
 801d924: 687b         	ldr	r3, [r7, #0x4]
 801d926: 8a1b         	ldrh	r3, [r3, #0x10]
 801d928: 461a         	mov	r2, r3
 801d92a: 887b         	ldrh	r3, [r7, #0x2]
 801d92c: 1ad3         	subs	r3, r2, r3
 801d92e: 461a         	mov	r2, r3
 801d930: 697b         	ldr	r3, [r7, #0x14]
 801d932: fb02 f303    	mul	r3, r2, r3
 801d936: 613b         	str	r3, [r7, #0x10]
; 	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
 801d938: 687b         	ldr	r3, [r7, #0x4]
 801d93a: 6a1a         	ldr	r2, [r3, #0x20]
 801d93c: 693b         	ldr	r3, [r7, #0x10]
 801d93e: 4413         	add	r3, r2
 801d940: 60fb         	str	r3, [r7, #0xc]
; 	buf->pool_id = pool_id(pool);
 801d942: 6878         	ldr	r0, [r7, #0x4]
 801d944: f7e9 f882    	bl	0x8006a4c <pool_id>     @ imm = #-0x16efc
 801d948: 4603         	mov	r3, r0
 801d94a: b2da         	uxtb	r2, r3
 801d94c: 68fb         	ldr	r3, [r7, #0xc]
 801d94e: 729a         	strb	r2, [r3, #0xa]
; 	buf->user_data_size = pool->user_data_size;
 801d950: 687b         	ldr	r3, [r7, #0x4]
 801d952: 7d1a         	ldrb	r2, [r3, #0x14]
 801d954: 68fb         	ldr	r3, [r7, #0xc]
 801d956: 72da         	strb	r2, [r3, #0xb]
; 	return buf;
 801d958: 68fb         	ldr	r3, [r7, #0xc]
; }
 801d95a: 4618         	mov	r0, r3
 801d95c: 3718         	adds	r7, #0x18
 801d95e: 46bd         	mov	sp, r7
 801d960: bd80         	pop	{r7, pc}

0801d962 <net_buf_reset>:
; {
 801d962: b580         	push	{r7, lr}
 801d964: b082         	sub	sp, #0x8
 801d966: af00         	add	r7, sp, #0x0
 801d968: 6078         	str	r0, [r7, #0x4]
; 	net_buf_simple_reset(&buf->b);
 801d96a: 687b         	ldr	r3, [r7, #0x4]
 801d96c: 330c         	adds	r3, #0xc
 801d96e: 4618         	mov	r0, r3
 801d970: f7ff ff72    	bl	0x801d858 <net_buf_simple_reset> @ imm = #-0x11c
; }
 801d974: bf00         	nop
 801d976: 3708         	adds	r7, #0x8
 801d978: 46bd         	mov	sp, r7
 801d97a: bd80         	pop	{r7, pc}

0801d97c <generic_data_ref>:
; {
 801d97c: b480         	push	{r7}
 801d97e: b085         	sub	sp, #0x14
 801d980: af00         	add	r7, sp, #0x0
 801d982: 6078         	str	r0, [r7, #0x4]
 801d984: 6039         	str	r1, [r7]
; 	ref_count = data - sizeof(void *);
 801d986: 683b         	ldr	r3, [r7]
 801d988: 3b04         	subs	r3, #0x4
 801d98a: 60fb         	str	r3, [r7, #0xc]
; 	(*ref_count)++;
 801d98c: 68fb         	ldr	r3, [r7, #0xc]
 801d98e: 781b         	ldrb	r3, [r3]
 801d990: 3301         	adds	r3, #0x1
 801d992: b2da         	uxtb	r2, r3
 801d994: 68fb         	ldr	r3, [r7, #0xc]
 801d996: 701a         	strb	r2, [r3]
; 	return data;
 801d998: 683b         	ldr	r3, [r7]
; }
 801d99a: 4618         	mov	r0, r3
 801d99c: 3714         	adds	r7, #0x14
 801d99e: 46bd         	mov	sp, r7
 801d9a0: f85d 7b04    	ldr	r7, [sp], #4
 801d9a4: 4770         	bx	lr

0801d9a6 <heap_data_alloc>:
; {
 801d9a6: b580         	push	{r7, lr}
 801d9a8: b086         	sub	sp, #0x18
 801d9aa: af00         	add	r7, sp, #0x0
 801d9ac: 60f8         	str	r0, [r7, #0xc]
 801d9ae: 60b9         	str	r1, [r7, #0x8]
 801d9b0: e9c7 2300    	strd	r2, r3, [r7]
; 	ref_count = k_malloc(sizeof(void *) + *size);
 801d9b4: 68bb         	ldr	r3, [r7, #0x8]
 801d9b6: 681b         	ldr	r3, [r3]
 801d9b8: 3304         	adds	r3, #0x4
 801d9ba: 4618         	mov	r0, r3
 801d9bc: f00b fb8c    	bl	0x80290d8 <k_malloc>    @ imm = #0xb718
 801d9c0: 6178         	str	r0, [r7, #0x14]
; 	if (!ref_count) {
 801d9c2: 697b         	ldr	r3, [r7, #0x14]
 801d9c4: 2b00         	cmp	r3, #0x0
 801d9c6: d101         	bne	0x801d9cc <heap_data_alloc+0x26> @ imm = #0x2
; 		return NULL;
 801d9c8: 2300         	movs	r3, #0x0
 801d9ca: e004         	b	0x801d9d6 <heap_data_alloc+0x30> @ imm = #0x8
; 	*ref_count = 1U;
 801d9cc: 697b         	ldr	r3, [r7, #0x14]
 801d9ce: 2201         	movs	r2, #0x1
 801d9d0: 701a         	strb	r2, [r3]
; 	return ref_count + sizeof(void *);
 801d9d2: 697b         	ldr	r3, [r7, #0x14]
 801d9d4: 3304         	adds	r3, #0x4
; }
 801d9d6: 4618         	mov	r0, r3
 801d9d8: 3718         	adds	r7, #0x18
 801d9da: 46bd         	mov	sp, r7
 801d9dc: bd80         	pop	{r7, pc}

0801d9de <heap_data_unref>:
; {
 801d9de: b580         	push	{r7, lr}
 801d9e0: b084         	sub	sp, #0x10
 801d9e2: af00         	add	r7, sp, #0x0
 801d9e4: 6078         	str	r0, [r7, #0x4]
 801d9e6: 6039         	str	r1, [r7]
; 	ref_count = data - sizeof(void *);
 801d9e8: 683b         	ldr	r3, [r7]
 801d9ea: 3b04         	subs	r3, #0x4
 801d9ec: 60fb         	str	r3, [r7, #0xc]
; 	if (--(*ref_count)) {
 801d9ee: 68fb         	ldr	r3, [r7, #0xc]
 801d9f0: 781b         	ldrb	r3, [r3]
 801d9f2: 3b01         	subs	r3, #0x1
 801d9f4: b2da         	uxtb	r2, r3
 801d9f6: 68fb         	ldr	r3, [r7, #0xc]
 801d9f8: 701a         	strb	r2, [r3]
 801d9fa: 68fb         	ldr	r3, [r7, #0xc]
 801d9fc: 781b         	ldrb	r3, [r3]
 801d9fe: 2b00         	cmp	r3, #0x0
 801da00: d103         	bne	0x801da0a <heap_data_unref+0x2c> @ imm = #0x6
; 	k_free(ref_count);
 801da02: 68f8         	ldr	r0, [r7, #0xc]
 801da04: f00b fb50    	bl	0x80290a8 <k_free>      @ imm = #0xb6a0
 801da08: e000         	b	0x801da0c <heap_data_unref+0x2e> @ imm = #0x0
; 		return;
 801da0a: bf00         	nop
; }
 801da0c: 3710         	adds	r7, #0x10
 801da0e: 46bd         	mov	sp, r7
 801da10: bd80         	pop	{r7, pc}

0801da12 <data_alloc>:
; {
 801da12: b590         	push	{r4, r7, lr}
 801da14: b087         	sub	sp, #0x1c
 801da16: af00         	add	r7, sp, #0x0
 801da18: 60f8         	str	r0, [r7, #0xc]
 801da1a: 60b9         	str	r1, [r7, #0x8]
 801da1c: e9c7 2300    	strd	r2, r3, [r7]
; 	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 801da20: 68fb         	ldr	r3, [r7, #0xc]
 801da22: 7a9b         	ldrb	r3, [r3, #0xa]
 801da24: 4618         	mov	r0, r3
 801da26: f7e8 fffb    	bl	0x8006a20 <net_buf_pool_get> @ imm = #-0x1700a
 801da2a: 6178         	str	r0, [r7, #0x14]
; 	return pool->alloc->cb->alloc(buf, size, timeout);
 801da2c: 697b         	ldr	r3, [r7, #0x14]
 801da2e: 69db         	ldr	r3, [r3, #0x1c]
 801da30: 681b         	ldr	r3, [r3]
 801da32: 681c         	ldr	r4, [r3]
 801da34: e9d7 2300    	ldrd	r2, r3, [r7]
 801da38: 68b9         	ldr	r1, [r7, #0x8]
 801da3a: 68f8         	ldr	r0, [r7, #0xc]
 801da3c: 47a0         	blx	r4
 801da3e: 4603         	mov	r3, r0
; }
 801da40: 4618         	mov	r0, r3
 801da42: 371c         	adds	r7, #0x1c
 801da44: 46bd         	mov	sp, r7
 801da46: bd90         	pop	{r4, r7, pc}

0801da48 <data_ref>:
; {
 801da48: b580         	push	{r7, lr}
 801da4a: b084         	sub	sp, #0x10
 801da4c: af00         	add	r7, sp, #0x0
 801da4e: 6078         	str	r0, [r7, #0x4]
 801da50: 6039         	str	r1, [r7]
; 	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 801da52: 687b         	ldr	r3, [r7, #0x4]
 801da54: 7a9b         	ldrb	r3, [r3, #0xa]
 801da56: 4618         	mov	r0, r3
 801da58: f7e8 ffe2    	bl	0x8006a20 <net_buf_pool_get> @ imm = #-0x1703c
 801da5c: 60f8         	str	r0, [r7, #0xc]
; 	return pool->alloc->cb->ref(buf, data);
 801da5e: 68fb         	ldr	r3, [r7, #0xc]
 801da60: 69db         	ldr	r3, [r3, #0x1c]
 801da62: 681b         	ldr	r3, [r3]
 801da64: 685b         	ldr	r3, [r3, #0x4]
 801da66: 6839         	ldr	r1, [r7]
 801da68: 6878         	ldr	r0, [r7, #0x4]
 801da6a: 4798         	blx	r3
 801da6c: 4603         	mov	r3, r0
; }
 801da6e: 4618         	mov	r0, r3
 801da70: 3710         	adds	r7, #0x10
 801da72: 46bd         	mov	sp, r7
 801da74: bd80         	pop	{r7, pc}

0801da76 <net_buf_unref>:
; {
 801da76: b580         	push	{r7, lr}
 801da78: b084         	sub	sp, #0x10
 801da7a: af00         	add	r7, sp, #0x0
 801da7c: 6078         	str	r0, [r7, #0x4]
; 	while (buf) {
 801da7e: e026         	b	0x801dace <net_buf_unref+0x58> @ imm = #0x4c
; 		struct net_buf *frags = buf->frags;
 801da80: 687b         	ldr	r3, [r7, #0x4]
 801da82: 685b         	ldr	r3, [r3, #0x4]
 801da84: 60fb         	str	r3, [r7, #0xc]
; 		if (--buf->ref > 0) {
 801da86: 687b         	ldr	r3, [r7, #0x4]
 801da88: 7a1b         	ldrb	r3, [r3, #0x8]
 801da8a: 3b01         	subs	r3, #0x1
 801da8c: b2da         	uxtb	r2, r3
 801da8e: 687b         	ldr	r3, [r7, #0x4]
 801da90: 721a         	strb	r2, [r3, #0x8]
 801da92: 687b         	ldr	r3, [r7, #0x4]
 801da94: 7a1b         	ldrb	r3, [r3, #0x8]
 801da96: 2b00         	cmp	r3, #0x0
 801da98: d11d         	bne	0x801dad6 <net_buf_unref+0x60> @ imm = #0x3a
; 		buf->data = NULL;
 801da9a: 687b         	ldr	r3, [r7, #0x4]
 801da9c: 2200         	movs	r2, #0x0
 801da9e: 60da         	str	r2, [r3, #0xc]
; 		buf->frags = NULL;
 801daa0: 687b         	ldr	r3, [r7, #0x4]
 801daa2: 2200         	movs	r2, #0x0
 801daa4: 605a         	str	r2, [r3, #0x4]
; 		pool = net_buf_pool_get(buf->pool_id);
 801daa6: 687b         	ldr	r3, [r7, #0x4]
 801daa8: 7a9b         	ldrb	r3, [r3, #0xa]
 801daaa: 4618         	mov	r0, r3
 801daac: f7e8 ffb8    	bl	0x8006a20 <net_buf_pool_get> @ imm = #-0x17090
 801dab0: 60b8         	str	r0, [r7, #0x8]
; 		if (pool->destroy) {
 801dab2: 68bb         	ldr	r3, [r7, #0x8]
 801dab4: 699b         	ldr	r3, [r3, #0x18]
 801dab6: 2b00         	cmp	r3, #0x0
 801dab8: d004         	beq	0x801dac4 <net_buf_unref+0x4e> @ imm = #0x8
; 			pool->destroy(buf);
 801daba: 68bb         	ldr	r3, [r7, #0x8]
 801dabc: 699b         	ldr	r3, [r3, #0x18]
 801dabe: 6878         	ldr	r0, [r7, #0x4]
 801dac0: 4798         	blx	r3
 801dac2: e002         	b	0x801daca <net_buf_unref+0x54> @ imm = #0x4
; 			net_buf_destroy(buf);
 801dac4: 6878         	ldr	r0, [r7, #0x4]
 801dac6: f7ff fed8    	bl	0x801d87a <net_buf_destroy> @ imm = #-0x250
; 		buf = frags;
 801daca: 68fb         	ldr	r3, [r7, #0xc]
 801dacc: 607b         	str	r3, [r7, #0x4]
; 	while (buf) {
 801dace: 687b         	ldr	r3, [r7, #0x4]
 801dad0: 2b00         	cmp	r3, #0x0
 801dad2: d1d5         	bne	0x801da80 <net_buf_unref+0xa> @ imm = #-0x56
 801dad4: e000         	b	0x801dad8 <net_buf_unref+0x62> @ imm = #0x0
; 			return;
 801dad6: bf00         	nop
; }
 801dad8: 3710         	adds	r7, #0x10
 801dada: 46bd         	mov	sp, r7
 801dadc: bd80         	pop	{r7, pc}

0801dade <net_buf_clone>:
; {
 801dade: b590         	push	{r4, r7, lr}
 801dae0: b08b         	sub	sp, #0x2c
 801dae2: af00         	add	r7, sp, #0x0
 801dae4: 60f8         	str	r0, [r7, #0xc]
 801dae6: e9c7 2300    	strd	r2, r3, [r7]
; 	k_timepoint_t end = sys_timepoint_calc(timeout);
 801daea: f107 0118    	add.w	r1, r7, #0x18
 801daee: e9d7 2300    	ldrd	r2, r3, [r7]
 801daf2: 4608         	mov	r0, r1
 801daf4: f00b f97a    	bl	0x8028dec <sys_timepoint_calc> @ imm = #0xb2f4
; 	pool = net_buf_pool_get(buf->pool_id);
 801daf8: 68fb         	ldr	r3, [r7, #0xc]
 801dafa: 7a9b         	ldrb	r3, [r3, #0xa]
 801dafc: 4618         	mov	r0, r3
 801dafe: f7e8 ff8f    	bl	0x8006a20 <net_buf_pool_get> @ imm = #-0x170e2
 801db02: 6278         	str	r0, [r7, #0x24]
; 	clone = net_buf_alloc_len(pool, 0, timeout);
 801db04: e9d7 2300    	ldrd	r2, r3, [r7]
 801db08: 2100         	movs	r1, #0x0
 801db0a: 6a78         	ldr	r0, [r7, #0x24]
 801db0c: f7e8 ffb4    	bl	0x8006a78 <net_buf_alloc_len> @ imm = #-0x17098
 801db10: 6238         	str	r0, [r7, #0x20]
; 	if (!clone) {
 801db12: 6a3b         	ldr	r3, [r7, #0x20]
 801db14: 2b00         	cmp	r3, #0x0
 801db16: d101         	bne	0x801db1c <net_buf_clone+0x3e> @ imm = #0x2
; 		return NULL;
 801db18: 2300         	movs	r3, #0x0
 801db1a: e06a         	b	0x801dbf2 <net_buf_clone+0x114> @ imm = #0xd4
; 	if (pool->alloc->cb->ref && !(buf->flags & NET_BUF_EXTERNAL_DATA)) {
 801db1c: 6a7b         	ldr	r3, [r7, #0x24]
 801db1e: 69db         	ldr	r3, [r3, #0x1c]
 801db20: 681b         	ldr	r3, [r3]
 801db22: 685b         	ldr	r3, [r3, #0x4]
 801db24: 2b00         	cmp	r3, #0x0
 801db26: d021         	beq	0x801db6c <net_buf_clone+0x8e> @ imm = #0x42
 801db28: 68fb         	ldr	r3, [r7, #0xc]
 801db2a: 7a5b         	ldrb	r3, [r3, #0x9]
 801db2c: f003 0301    	and	r3, r3, #0x1
 801db30: 2b00         	cmp	r3, #0x0
 801db32: d11b         	bne	0x801db6c <net_buf_clone+0x8e> @ imm = #0x36
; 		clone->__buf = buf->__buf ? data_ref(buf, buf->__buf) : NULL;
 801db34: 68fb         	ldr	r3, [r7, #0xc]
 801db36: 695b         	ldr	r3, [r3, #0x14]
 801db38: 2b00         	cmp	r3, #0x0
 801db3a: d007         	beq	0x801db4c <net_buf_clone+0x6e> @ imm = #0xe
 801db3c: 68fb         	ldr	r3, [r7, #0xc]
 801db3e: 695b         	ldr	r3, [r3, #0x14]
 801db40: 4619         	mov	r1, r3
 801db42: 68f8         	ldr	r0, [r7, #0xc]
 801db44: f7ff ff80    	bl	0x801da48 <data_ref>    @ imm = #-0x100
 801db48: 4603         	mov	r3, r0
 801db4a: e000         	b	0x801db4e <net_buf_clone+0x70> @ imm = #0x0
 801db4c: 2300         	movs	r3, #0x0
 801db4e: 6a3a         	ldr	r2, [r7, #0x20]
 801db50: 6153         	str	r3, [r2, #0x14]
; 		clone->data = buf->data;
 801db52: 68fb         	ldr	r3, [r7, #0xc]
 801db54: 68da         	ldr	r2, [r3, #0xc]
 801db56: 6a3b         	ldr	r3, [r7, #0x20]
 801db58: 60da         	str	r2, [r3, #0xc]
; 		clone->len = buf->len;
 801db5a: 68fb         	ldr	r3, [r7, #0xc]
 801db5c: 8a1a         	ldrh	r2, [r3, #0x10]
 801db5e: 6a3b         	ldr	r3, [r7, #0x20]
 801db60: 821a         	strh	r2, [r3, #0x10]
; 		clone->size = buf->size;
 801db62: 68fb         	ldr	r3, [r7, #0xc]
 801db64: 8a5a         	ldrh	r2, [r3, #0x12]
 801db66: 6a3b         	ldr	r3, [r7, #0x20]
 801db68: 825a         	strh	r2, [r3, #0x12]
 801db6a: e036         	b	0x801dbda <net_buf_clone+0xfc> @ imm = #0x6c
; 		size_t size = buf->size;
 801db6c: 68fb         	ldr	r3, [r7, #0xc]
 801db6e: 8a5b         	ldrh	r3, [r3, #0x12]
 801db70: 617b         	str	r3, [r7, #0x14]
; 		timeout = sys_timepoint_timeout(end);
 801db72: 4639         	mov	r1, r7
 801db74: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 801db78: 4608         	mov	r0, r1
 801db7a: f00b f99c    	bl	0x8028eb6 <sys_timepoint_timeout> @ imm = #0xb338
; 		clone->__buf = data_alloc(clone, &size, timeout);
 801db7e: f107 0114    	add.w	r1, r7, #0x14
 801db82: e9d7 2300    	ldrd	r2, r3, [r7]
 801db86: 6a38         	ldr	r0, [r7, #0x20]
 801db88: f7ff ff43    	bl	0x801da12 <data_alloc>  @ imm = #-0x17a
 801db8c: 4602         	mov	r2, r0
 801db8e: 6a3b         	ldr	r3, [r7, #0x20]
 801db90: 615a         	str	r2, [r3, #0x14]
; 		if (!clone->__buf || size < buf->size) {
 801db92: 6a3b         	ldr	r3, [r7, #0x20]
 801db94: 695b         	ldr	r3, [r3, #0x14]
 801db96: 2b00         	cmp	r3, #0x0
 801db98: d005         	beq	0x801dba6 <net_buf_clone+0xc8> @ imm = #0xa
 801db9a: 68fb         	ldr	r3, [r7, #0xc]
 801db9c: 8a5b         	ldrh	r3, [r3, #0x12]
 801db9e: 461a         	mov	r2, r3
 801dba0: 697b         	ldr	r3, [r7, #0x14]
 801dba2: 429a         	cmp	r2, r3
 801dba4: d904         	bls	0x801dbb0 <net_buf_clone+0xd2> @ imm = #0x8
; 			net_buf_destroy(clone);
 801dba6: 6a38         	ldr	r0, [r7, #0x20]
 801dba8: f7ff fe67    	bl	0x801d87a <net_buf_destroy> @ imm = #-0x332
; 			return NULL;
 801dbac: 2300         	movs	r3, #0x0
 801dbae: e020         	b	0x801dbf2 <net_buf_clone+0x114> @ imm = #0x40
; 		clone->size = size;
 801dbb0: 697b         	ldr	r3, [r7, #0x14]
 801dbb2: b29a         	uxth	r2, r3
 801dbb4: 6a3b         	ldr	r3, [r7, #0x20]
 801dbb6: 825a         	strh	r2, [r3, #0x12]
; 		clone->data = clone->__buf + net_buf_headroom(buf);
 801dbb8: 6a3b         	ldr	r3, [r7, #0x20]
 801dbba: 695c         	ldr	r4, [r3, #0x14]
 801dbbc: 68f8         	ldr	r0, [r7, #0xc]
 801dbbe: f7ff fe97    	bl	0x801d8f0 <net_buf_headroom> @ imm = #-0x2d2
 801dbc2: 4603         	mov	r3, r0
 801dbc4: 18e2         	adds	r2, r4, r3
 801dbc6: 6a3b         	ldr	r3, [r7, #0x20]
 801dbc8: 60da         	str	r2, [r3, #0xc]
; 		net_buf_add_mem(clone, buf->data, buf->len);
 801dbca: 68fb         	ldr	r3, [r7, #0xc]
 801dbcc: 68d9         	ldr	r1, [r3, #0xc]
 801dbce: 68fb         	ldr	r3, [r7, #0xc]
 801dbd0: 8a1b         	ldrh	r3, [r3, #0x10]
 801dbd2: 461a         	mov	r2, r3
 801dbd4: 6a38         	ldr	r0, [r7, #0x20]
 801dbd6: f7ff fe79    	bl	0x801d8cc <net_buf_add_mem> @ imm = #-0x30e
; 	memcpy(clone->user_data, buf->user_data, clone->user_data_size);
 801dbda: 6a3b         	ldr	r3, [r7, #0x20]
 801dbdc: f103 0018    	add.w	r0, r3, #0x18
 801dbe0: 68fb         	ldr	r3, [r7, #0xc]
 801dbe2: f103 0118    	add.w	r1, r3, #0x18
 801dbe6: 6a3b         	ldr	r3, [r7, #0x20]
 801dbe8: 7adb         	ldrb	r3, [r3, #0xb]
 801dbea: 461a         	mov	r2, r3
 801dbec: f00b fa82    	bl	0x80290f4 <memcpy>      @ imm = #0xb504
; 	return clone;
 801dbf0: 6a3b         	ldr	r3, [r7, #0x20]
; }
 801dbf2: 4618         	mov	r0, r3
 801dbf4: 372c         	adds	r7, #0x2c
 801dbf6: 46bd         	mov	sp, r7
 801dbf8: bd90         	pop	{r4, r7, pc}

0801dbfa <net_buf_simple_tail>:
; {
 801dbfa: b480         	push	{r7}
 801dbfc: b083         	sub	sp, #0xc
 801dbfe: af00         	add	r7, sp, #0x0
 801dc00: 6078         	str	r0, [r7, #0x4]
; 	return buf->data + buf->len;
 801dc02: 687b         	ldr	r3, [r7, #0x4]
 801dc04: 681b         	ldr	r3, [r3]
 801dc06: 687a         	ldr	r2, [r7, #0x4]
 801dc08: 8892         	ldrh	r2, [r2, #0x4]
 801dc0a: 4413         	add	r3, r2
; }
 801dc0c: 4618         	mov	r0, r3
 801dc0e: 370c         	adds	r7, #0xc
 801dc10: 46bd         	mov	sp, r7
 801dc12: f85d 7b04    	ldr	r7, [sp], #4
 801dc16: 4770         	bx	lr

0801dc18 <net_buf_simple_add>:
; {
 801dc18: b580         	push	{r7, lr}
 801dc1a: b084         	sub	sp, #0x10
 801dc1c: af00         	add	r7, sp, #0x0
 801dc1e: 6078         	str	r0, [r7, #0x4]
 801dc20: 6039         	str	r1, [r7]
; 	uint8_t *tail = net_buf_simple_tail(buf);
 801dc22: 6878         	ldr	r0, [r7, #0x4]
 801dc24: f7ff ffe9    	bl	0x801dbfa <net_buf_simple_tail> @ imm = #-0x2e
 801dc28: 60f8         	str	r0, [r7, #0xc]
; 	buf->len += len;
 801dc2a: 687b         	ldr	r3, [r7, #0x4]
 801dc2c: 889a         	ldrh	r2, [r3, #0x4]
 801dc2e: 683b         	ldr	r3, [r7]
 801dc30: b29b         	uxth	r3, r3
 801dc32: 4413         	add	r3, r2
 801dc34: b29a         	uxth	r2, r3
 801dc36: 687b         	ldr	r3, [r7, #0x4]
 801dc38: 809a         	strh	r2, [r3, #0x4]
; 	return tail;
 801dc3a: 68fb         	ldr	r3, [r7, #0xc]
; }
 801dc3c: 4618         	mov	r0, r3
 801dc3e: 3710         	adds	r7, #0x10
 801dc40: 46bd         	mov	sp, r7
 801dc42: bd80         	pop	{r7, pc}

0801dc44 <net_buf_simple_add_mem>:
; {
 801dc44: b580         	push	{r7, lr}
 801dc46: b084         	sub	sp, #0x10
 801dc48: af00         	add	r7, sp, #0x0
 801dc4a: 60f8         	str	r0, [r7, #0xc]
 801dc4c: 60b9         	str	r1, [r7, #0x8]
 801dc4e: 607a         	str	r2, [r7, #0x4]
; 	return memcpy(net_buf_simple_add(buf, len), mem, len);
 801dc50: 6879         	ldr	r1, [r7, #0x4]
 801dc52: 68f8         	ldr	r0, [r7, #0xc]
 801dc54: f7ff ffe0    	bl	0x801dc18 <net_buf_simple_add> @ imm = #-0x40
 801dc58: 4603         	mov	r3, r0
 801dc5a: 687a         	ldr	r2, [r7, #0x4]
 801dc5c: 68b9         	ldr	r1, [r7, #0x8]
 801dc5e: 4618         	mov	r0, r3
 801dc60: f00b fa48    	bl	0x80290f4 <memcpy>      @ imm = #0xb490
 801dc64: 4603         	mov	r3, r0
; }
 801dc66: 4618         	mov	r0, r3
 801dc68: 3710         	adds	r7, #0x10
 801dc6a: 46bd         	mov	sp, r7
 801dc6c: bd80         	pop	{r7, pc}

0801dc6e <net_buf_simple_remove_mem>:
; {
 801dc6e: b480         	push	{r7}
 801dc70: b083         	sub	sp, #0xc
 801dc72: af00         	add	r7, sp, #0x0
 801dc74: 6078         	str	r0, [r7, #0x4]
 801dc76: 6039         	str	r1, [r7]
; 	buf->len -= len;
 801dc78: 687b         	ldr	r3, [r7, #0x4]
 801dc7a: 889a         	ldrh	r2, [r3, #0x4]
 801dc7c: 683b         	ldr	r3, [r7]
 801dc7e: b29b         	uxth	r3, r3
 801dc80: 1ad3         	subs	r3, r2, r3
 801dc82: b29a         	uxth	r2, r3
 801dc84: 687b         	ldr	r3, [r7, #0x4]
 801dc86: 809a         	strh	r2, [r3, #0x4]
; 	return buf->data + buf->len;
 801dc88: 687b         	ldr	r3, [r7, #0x4]
 801dc8a: 681b         	ldr	r3, [r3]
 801dc8c: 687a         	ldr	r2, [r7, #0x4]
 801dc8e: 8892         	ldrh	r2, [r2, #0x4]
 801dc90: 4413         	add	r3, r2
; }
 801dc92: 4618         	mov	r0, r3
 801dc94: 370c         	adds	r7, #0xc
 801dc96: 46bd         	mov	sp, r7
 801dc98: f85d 7b04    	ldr	r7, [sp], #4
 801dc9c: 4770         	bx	lr

0801dc9e <net_buf_simple_headroom>:
; {
 801dc9e: b480         	push	{r7}
 801dca0: b083         	sub	sp, #0xc
 801dca2: af00         	add	r7, sp, #0x0
 801dca4: 6078         	str	r0, [r7, #0x4]
; 	return buf->data - buf->__buf;
 801dca6: 687b         	ldr	r3, [r7, #0x4]
 801dca8: 681a         	ldr	r2, [r3]
 801dcaa: 687b         	ldr	r3, [r7, #0x4]
 801dcac: 689b         	ldr	r3, [r3, #0x8]
 801dcae: 1ad3         	subs	r3, r2, r3
; }
 801dcb0: 4618         	mov	r0, r3
 801dcb2: 370c         	adds	r7, #0xc
 801dcb4: 46bd         	mov	sp, r7
 801dcb6: f85d 7b04    	ldr	r7, [sp], #4
 801dcba: 4770         	bx	lr

0801dcbc <z_snode_next_peek>:
; {
 801dcbc: b480         	push	{r7}
 801dcbe: b083         	sub	sp, #0xc
 801dcc0: af00         	add	r7, sp, #0x0
 801dcc2: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 801dcc4: 687b         	ldr	r3, [r7, #0x4]
 801dcc6: 681b         	ldr	r3, [r3]
; }
 801dcc8: 4618         	mov	r0, r3
 801dcca: 370c         	adds	r7, #0xc
 801dccc: 46bd         	mov	sp, r7
 801dcce: f85d 7b04    	ldr	r7, [sp], #4
 801dcd2: 4770         	bx	lr

0801dcd4 <sys_slist_peek_head>:
; {
 801dcd4: b480         	push	{r7}
 801dcd6: b083         	sub	sp, #0xc
 801dcd8: af00         	add	r7, sp, #0x0
 801dcda: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 801dcdc: 687b         	ldr	r3, [r7, #0x4]
 801dcde: 681b         	ldr	r3, [r3]
; }
 801dce0: 4618         	mov	r0, r3
 801dce2: 370c         	adds	r7, #0xc
 801dce4: 46bd         	mov	sp, r7
 801dce6: f85d 7b04    	ldr	r7, [sp], #4
 801dcea: 4770         	bx	lr

0801dcec <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 801dcec: b580         	push	{r7, lr}
 801dcee: b082         	sub	sp, #0x8
 801dcf0: af00         	add	r7, sp, #0x0
 801dcf2: 6078         	str	r0, [r7, #0x4]
 801dcf4: 6878         	ldr	r0, [r7, #0x4]
 801dcf6: f7ff ffe1    	bl	0x801dcbc <z_snode_next_peek> @ imm = #-0x3e
 801dcfa: 4603         	mov	r3, r0
 801dcfc: 4618         	mov	r0, r3
 801dcfe: 3708         	adds	r7, #0x8
 801dd00: 46bd         	mov	sp, r7
 801dd02: bd80         	pop	{r7, pc}

0801dd04 <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 801dd04: b580         	push	{r7, lr}
 801dd06: b082         	sub	sp, #0x8
 801dd08: af00         	add	r7, sp, #0x0
 801dd0a: 6078         	str	r0, [r7, #0x4]
 801dd0c: 687b         	ldr	r3, [r7, #0x4]
 801dd0e: 2b00         	cmp	r3, #0x0
 801dd10: d004         	beq	0x801dd1c <sys_slist_peek_next+0x18> @ imm = #0x8
 801dd12: 6878         	ldr	r0, [r7, #0x4]
 801dd14: f7ff ffea    	bl	0x801dcec <sys_slist_peek_next_no_check> @ imm = #-0x2c
 801dd18: 4603         	mov	r3, r0
 801dd1a: e000         	b	0x801dd1e <sys_slist_peek_next+0x1a> @ imm = #0x0
 801dd1c: 2300         	movs	r3, #0x0
 801dd1e: 4618         	mov	r0, r3
 801dd20: 3708         	adds	r7, #0x8
 801dd22: 46bd         	mov	sp, r7
 801dd24: bd80         	pop	{r7, pc}

0801dd26 <k_thread_priority_get>:
; {
 801dd26: b580         	push	{r7, lr}
 801dd28: b082         	sub	sp, #0x8
 801dd2a: af00         	add	r7, sp, #0x0
 801dd2c: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_thread_priority_get(thread);
 801dd2e: 6878         	ldr	r0, [r7, #0x4]
 801dd30: f00a f95e    	bl	0x8027ff0 <z_impl_k_thread_priority_get> @ imm = #0xa2bc
 801dd34: 4603         	mov	r3, r0
; }
 801dd36: 4618         	mov	r0, r3
 801dd38: 3708         	adds	r7, #0x8
 801dd3a: 46bd         	mov	sp, r7
 801dd3c: bd80         	pop	{r7, pc}

0801dd3e <k_thread_priority_set>:
; {
 801dd3e: b580         	push	{r7, lr}
 801dd40: b082         	sub	sp, #0x8
 801dd42: af00         	add	r7, sp, #0x0
 801dd44: 6078         	str	r0, [r7, #0x4]
 801dd46: 6039         	str	r1, [r7]
; 	z_impl_k_thread_priority_set(thread, prio);
 801dd48: 6839         	ldr	r1, [r7]
 801dd4a: 6878         	ldr	r0, [r7, #0x4]
 801dd4c: f7f9 fb22    	bl	0x8017394 <z_impl_k_thread_priority_set> @ imm = #-0x69bc
; }
 801dd50: bf00         	nop
 801dd52: 3708         	adds	r7, #0x8
 801dd54: 46bd         	mov	sp, r7
 801dd56: bd80         	pop	{r7, pc}

0801dd58 <k_queue_get>:
; {
 801dd58: b580         	push	{r7, lr}
 801dd5a: b084         	sub	sp, #0x10
 801dd5c: af00         	add	r7, sp, #0x0
 801dd5e: 60f8         	str	r0, [r7, #0xc]
 801dd60: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_queue_get(queue, timeout);
 801dd64: e9d7 2300    	ldrd	r2, r3, [r7]
 801dd68: 68f8         	ldr	r0, [r7, #0xc]
 801dd6a: f7f7 fbef    	bl	0x801554c <z_impl_k_queue_get> @ imm = #-0x8822
 801dd6e: 4603         	mov	r3, r0
; }
 801dd70: 4618         	mov	r0, r3
 801dd72: 3710         	adds	r7, #0x10
 801dd74: 46bd         	mov	sp, r7
 801dd76: bd80         	pop	{r7, pc}

0801dd78 <k_sem_take>:
; {
 801dd78: b580         	push	{r7, lr}
 801dd7a: b084         	sub	sp, #0x10
 801dd7c: af00         	add	r7, sp, #0x0
 801dd7e: 60f8         	str	r0, [r7, #0xc]
 801dd80: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 801dd84: e9d7 2300    	ldrd	r2, r3, [r7]
 801dd88: 68f8         	ldr	r0, [r7, #0xc]
 801dd8a: f7f7 fcf3    	bl	0x8015774 <z_impl_k_sem_take> @ imm = #-0x861a
 801dd8e: 4603         	mov	r3, r0
; }
 801dd90: 4618         	mov	r0, r3
 801dd92: 3710         	adds	r7, #0x10
 801dd94: 46bd         	mov	sp, r7
 801dd96: bd80         	pop	{r7, pc}

0801dd98 <k_sem_give>:
; {
 801dd98: b580         	push	{r7, lr}
 801dd9a: b082         	sub	sp, #0x8
 801dd9c: af00         	add	r7, sp, #0x0
 801dd9e: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801dda0: 6878         	ldr	r0, [r7, #0x4]
 801dda2: f7f7 fc59    	bl	0x8015658 <z_impl_k_sem_give> @ imm = #-0x874e
; }
 801dda6: bf00         	nop
 801dda8: 3708         	adds	r7, #0x8
 801ddaa: 46bd         	mov	sp, r7
 801ddac: bd80         	pop	{r7, pc}

0801ddae <k_msgq_put>:
; {
 801ddae: b580         	push	{r7, lr}
 801ddb0: b084         	sub	sp, #0x10
 801ddb2: af00         	add	r7, sp, #0x0
 801ddb4: 60f8         	str	r0, [r7, #0xc]
 801ddb6: 60b9         	str	r1, [r7, #0x8]
 801ddb8: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_msgq_put(msgq, data, timeout);
 801ddbc: e9d7 2300    	ldrd	r2, r3, [r7]
 801ddc0: 68b9         	ldr	r1, [r7, #0x8]
 801ddc2: 68f8         	ldr	r0, [r7, #0xc]
 801ddc4: f7f6 ff5e    	bl	0x8014c84 <z_impl_k_msgq_put> @ imm = #-0x9144
 801ddc8: 4603         	mov	r3, r0
; }
 801ddca: 4618         	mov	r0, r3
 801ddcc: 3710         	adds	r7, #0x10
 801ddce: 46bd         	mov	sp, r7
 801ddd0: bd80         	pop	{r7, pc}

0801ddd2 <z_log_msg_runtime_create>:
; {
 801ddd2: b580         	push	{r7, lr}
 801ddd4: b08a         	sub	sp, #0x28
 801ddd6: af04         	add	r7, sp, #0x10
 801ddd8: 60b9         	str	r1, [r7, #0x8]
 801ddda: 607b         	str	r3, [r7, #0x4]
 801dddc: 4603         	mov	r3, r0
 801ddde: 73fb         	strb	r3, [r7, #0xf]
 801dde0: 4613         	mov	r3, r2
 801dde2: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801dde4: f107 032c    	add.w	r3, r7, #0x2c
 801dde8: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801ddea: 7bba         	ldrb	r2, [r7, #0xe]
 801ddec: 7bf8         	ldrb	r0, [r7, #0xf]
 801ddee: 697b         	ldr	r3, [r7, #0x14]
 801ddf0: 9303         	str	r3, [sp, #0xc]
 801ddf2: 6abb         	ldr	r3, [r7, #0x28]
 801ddf4: 9302         	str	r3, [sp, #0x8]
 801ddf6: 6a7b         	ldr	r3, [r7, #0x24]
 801ddf8: 9301         	str	r3, [sp, #0x4]
 801ddfa: 6a3b         	ldr	r3, [r7, #0x20]
 801ddfc: 9300         	str	r3, [sp]
 801ddfe: 687b         	ldr	r3, [r7, #0x4]
 801de00: 68b9         	ldr	r1, [r7, #0x8]
 801de02: f7e6 feb7    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x19292
; }
 801de06: bf00         	nop
 801de08: 3718         	adds	r7, #0x18
 801de0a: 46bd         	mov	sp, r7
 801de0c: bd80         	pop	{r7, pc}

0801de0e <net_buf_user_data>:
; {
 801de0e: b480         	push	{r7}
 801de10: b083         	sub	sp, #0xc
 801de12: af00         	add	r7, sp, #0x0
 801de14: 6078         	str	r0, [r7, #0x4]
; 	return (void *)buf->user_data;
 801de16: 687b         	ldr	r3, [r7, #0x4]
 801de18: 3318         	adds	r3, #0x18
; }
 801de1a: 4618         	mov	r0, r3
 801de1c: 370c         	adds	r7, #0xc
 801de1e: 46bd         	mov	sp, r7
 801de20: f85d 7b04    	ldr	r7, [sp], #4
 801de24: 4770         	bx	lr

0801de26 <net_buf_add_mem>:
; {
 801de26: b580         	push	{r7, lr}
 801de28: b084         	sub	sp, #0x10
 801de2a: af00         	add	r7, sp, #0x0
 801de2c: 60f8         	str	r0, [r7, #0xc]
 801de2e: 60b9         	str	r1, [r7, #0x8]
 801de30: 607a         	str	r2, [r7, #0x4]
; 	return net_buf_simple_add_mem(&buf->b, mem, len);
 801de32: 68fb         	ldr	r3, [r7, #0xc]
 801de34: 330c         	adds	r3, #0xc
 801de36: 687a         	ldr	r2, [r7, #0x4]
 801de38: 68b9         	ldr	r1, [r7, #0x8]
 801de3a: 4618         	mov	r0, r3
 801de3c: f7ff ff02    	bl	0x801dc44 <net_buf_simple_add_mem> @ imm = #-0x1fc
 801de40: 4603         	mov	r3, r0
; }
 801de42: 4618         	mov	r0, r3
 801de44: 3710         	adds	r7, #0x10
 801de46: 46bd         	mov	sp, r7
 801de48: bd80         	pop	{r7, pc}

0801de4a <net_buf_remove_mem>:
; {
 801de4a: b580         	push	{r7, lr}
 801de4c: b082         	sub	sp, #0x8
 801de4e: af00         	add	r7, sp, #0x0
 801de50: 6078         	str	r0, [r7, #0x4]
 801de52: 6039         	str	r1, [r7]
; 	return net_buf_simple_remove_mem(&buf->b, len);
 801de54: 687b         	ldr	r3, [r7, #0x4]
 801de56: 330c         	adds	r3, #0xc
 801de58: 6839         	ldr	r1, [r7]
 801de5a: 4618         	mov	r0, r3
 801de5c: f7ff ff07    	bl	0x801dc6e <net_buf_simple_remove_mem> @ imm = #-0x1f2
 801de60: 4603         	mov	r3, r0
; }
 801de62: 4618         	mov	r0, r3
 801de64: 3708         	adds	r7, #0x8
 801de66: 46bd         	mov	sp, r7
 801de68: bd80         	pop	{r7, pc}

0801de6a <zbus_chan_msg>:
; {
 801de6a: b480         	push	{r7}
 801de6c: b083         	sub	sp, #0xc
 801de6e: af00         	add	r7, sp, #0x0
 801de70: 6078         	str	r0, [r7, #0x4]
; 	return chan->message;
 801de72: 687b         	ldr	r3, [r7, #0x4]
 801de74: 681b         	ldr	r3, [r3]
; }
 801de76: 4618         	mov	r0, r3
 801de78: 370c         	adds	r7, #0xc
 801de7a: 46bd         	mov	sp, r7
 801de7c: f85d 7b04    	ldr	r7, [sp], #4
 801de80: 4770         	bx	lr

0801de82 <zbus_chan_msg_size>:
; {
 801de82: b480         	push	{r7}
 801de84: b083         	sub	sp, #0xc
 801de86: af00         	add	r7, sp, #0x0
 801de88: 6078         	str	r0, [r7, #0x4]
; 	return chan->message_size;
 801de8a: 687b         	ldr	r3, [r7, #0x4]
 801de8c: 685b         	ldr	r3, [r3, #0x4]
 801de8e: b29b         	uxth	r3, r3
; }
 801de90: 4618         	mov	r0, r3
 801de92: 370c         	adds	r7, #0xc
 801de94: 46bd         	mov	sp, r7
 801de96: f85d 7b04    	ldr	r7, [sp], #4
 801de9a: 4770         	bx	lr

0801de9c <_zbus_create_net_buf>:
; {
 801de9c: b580         	push	{r7, lr}
 801de9e: b084         	sub	sp, #0x10
 801dea0: af00         	add	r7, sp, #0x0
 801dea2: 60f8         	str	r0, [r7, #0xc]
 801dea4: 60b9         	str	r1, [r7, #0x8]
 801dea6: e9c7 2300    	strd	r2, r3, [r7]
; 	return net_buf_alloc_len(pool, size, timeout);
 801deaa: e9d7 2300    	ldrd	r2, r3, [r7]
 801deae: 68b9         	ldr	r1, [r7, #0x8]
 801deb0: 68f8         	ldr	r0, [r7, #0xc]
 801deb2: f7e8 fde1    	bl	0x8006a78 <net_buf_alloc_len> @ imm = #-0x1743e
 801deb6: 4603         	mov	r3, r0
; }
 801deb8: 4618         	mov	r0, r3
 801deba: 3710         	adds	r7, #0x10
 801debc: 46bd         	mov	sp, r7
 801debe: bd80         	pop	{r7, pc}

0801dec0 <_zbus_notify_observer>:
; {
 801dec0: b590         	push	{r4, r7, lr}
 801dec2: b08b         	sub	sp, #0x2c
 801dec4: af00         	add	r7, sp, #0x0
 801dec6: 60f8         	str	r0, [r7, #0xc]
 801dec8: 60b9         	str	r1, [r7, #0x8]
 801deca: e9c7 2300    	strd	r2, r3, [r7]
; 	switch (obs->type) {
 801dece: 68bb         	ldr	r3, [r7, #0x8]
 801ded0: 781b         	ldrb	r3, [r3]
 801ded2: 2b02         	cmp	r3, #0x2
 801ded4: d01e         	beq	0x801df14 <_zbus_notify_observer+0x54> @ imm = #0x3c
 801ded6: 2b02         	cmp	r3, #0x2
 801ded8: dc36         	bgt	0x801df48 <_zbus_notify_observer+0x88> @ imm = #0x6c
 801deda: 2b00         	cmp	r3, #0x0
 801dedc: d002         	beq	0x801dee4 <_zbus_notify_observer+0x24> @ imm = #0x4
 801dede: 2b01         	cmp	r3, #0x1
 801dee0: d006         	beq	0x801def0 <_zbus_notify_observer+0x30> @ imm = #0xc
 801dee2: e031         	b	0x801df48 <_zbus_notify_observer+0x88> @ imm = #0x62
; 		obs->callback(chan);
 801dee4: 68bb         	ldr	r3, [r7, #0x8]
 801dee6: 689b         	ldr	r3, [r3, #0x8]
 801dee8: 68fa         	ldr	r2, [r7, #0xc]
 801deea: 4610         	mov	r0, r2
 801deec: 4798         	blx	r3
; 		break;
 801deee: e02b         	b	0x801df48 <_zbus_notify_observer+0x88> @ imm = #0x56
; 		return k_msgq_put(obs->queue, &chan, sys_timepoint_timeout(end_time));
 801def0: 68bb         	ldr	r3, [r7, #0x8]
 801def2: 689c         	ldr	r4, [r3, #0x8]
 801def4: f107 0110    	add.w	r1, r7, #0x10
 801def8: e9d7 2300    	ldrd	r2, r3, [r7]
 801defc: 4608         	mov	r0, r1
 801defe: f00a ffda    	bl	0x8028eb6 <sys_timepoint_timeout> @ imm = #0xafb4
 801df02: f107 010c    	add.w	r1, r7, #0xc
 801df06: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 801df0a: 4620         	mov	r0, r4
 801df0c: f7ff ff4f    	bl	0x801ddae <k_msgq_put>  @ imm = #-0x162
 801df10: 4603         	mov	r3, r0
 801df12: e01a         	b	0x801df4a <_zbus_notify_observer+0x8a> @ imm = #0x34
; 		struct net_buf *cloned_buf = net_buf_clone(buf, sys_timepoint_timeout(end_time));
 801df14: f107 0118    	add.w	r1, r7, #0x18
 801df18: e9d7 2300    	ldrd	r2, r3, [r7]
 801df1c: 4608         	mov	r0, r1
 801df1e: f00a ffca    	bl	0x8028eb6 <sys_timepoint_timeout> @ imm = #0xaf94
 801df22: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 801df26: 6bb8         	ldr	r0, [r7, #0x38]
 801df28: f7ff fdd9    	bl	0x801dade <net_buf_clone> @ imm = #-0x44e
 801df2c: 6278         	str	r0, [r7, #0x24]
; 		if (cloned_buf == NULL) {
 801df2e: 6a7b         	ldr	r3, [r7, #0x24]
 801df30: 2b00         	cmp	r3, #0x0
 801df32: d102         	bne	0x801df3a <_zbus_notify_observer+0x7a> @ imm = #0x4
; 			return -ENOMEM;
 801df34: f06f 030b    	mvn	r3, #0xb
 801df38: e007         	b	0x801df4a <_zbus_notify_observer+0x8a> @ imm = #0xe
; 		k_fifo_put(obs->message_fifo, cloned_buf);
 801df3a: 68bb         	ldr	r3, [r7, #0x8]
 801df3c: 689b         	ldr	r3, [r3, #0x8]
 801df3e: 6a79         	ldr	r1, [r7, #0x24]
 801df40: 4618         	mov	r0, r3
 801df42: f009 fb1e    	bl	0x8027582 <k_queue_append> @ imm = #0x963c
; 		break;
 801df46: bf00         	nop
; 	return 0;
 801df48: 2300         	movs	r3, #0x0
; }
 801df4a: 4618         	mov	r0, r3
 801df4c: 372c         	adds	r7, #0x2c
 801df4e: 46bd         	mov	sp, r7
 801df50: bd90         	pop	{r4, r7, pc}

0801df52 <chan_unlock>:
; {
 801df52: b580         	push	{r7, lr}
 801df54: b082         	sub	sp, #0x8
 801df56: af00         	add	r7, sp, #0x0
 801df58: 6078         	str	r0, [r7, #0x4]
 801df5a: 6039         	str	r1, [r7]
; 	k_sem_give(&chan->data->sem);
 801df5c: 687b         	ldr	r3, [r7, #0x4]
 801df5e: 691b         	ldr	r3, [r3, #0x10]
 801df60: 3304         	adds	r3, #0x4
 801df62: 4618         	mov	r0, r3
 801df64: f7ff ff18    	bl	0x801dd98 <k_sem_give>  @ imm = #-0x1d0
; 	if (prio < ZBUS_MIN_THREAD_PRIORITY) {
 801df68: 683b         	ldr	r3, [r7]
 801df6a: 2b0d         	cmp	r3, #0xd
 801df6c: dc06         	bgt	0x801df7c <chan_unlock+0x2a> @ imm = #0xc
; 		k_thread_priority_set(k_current_get(), prio);
 801df6e: f7e8 fea5    	bl	0x8006cbc <k_current_get> @ imm = #-0x172b6
 801df72: 4603         	mov	r3, r0
 801df74: 6839         	ldr	r1, [r7]
 801df76: 4618         	mov	r0, r3
 801df78: f7ff fee1    	bl	0x801dd3e <k_thread_priority_set> @ imm = #-0x23e
; }
 801df7c: bf00         	nop
 801df7e: 3708         	adds	r7, #0x8
 801df80: 46bd         	mov	sp, r7
 801df82: bd80         	pop	{r7, pc}

0801df84 <zbus_chan_pub>:
; {
 801df84: b580         	push	{r7, lr}
 801df86: b08c         	sub	sp, #0x30
 801df88: af02         	add	r7, sp, #0x8
 801df8a: 60f8         	str	r0, [r7, #0xc]
 801df8c: 60b9         	str	r1, [r7, #0x8]
 801df8e: e9c7 2300    	strd	r2, r3, [r7]
; 	if (k_is_in_isr()) {
 801df92: f00a f81b    	bl	0x8027fcc <k_is_in_isr> @ imm = #0xa036
 801df96: 4603         	mov	r3, r0
 801df98: 2b00         	cmp	r3, #0x0
 801df9a: d005         	beq	0x801dfa8 <zbus_chan_pub+0x24> @ imm = #0xa
; 		timeout = K_NO_WAIT;
 801df9c: f04f 0200    	mov.w	r2, #0x0
 801dfa0: f04f 0300    	mov.w	r3, #0x0
 801dfa4: e9c7 2300    	strd	r2, r3, [r7]
; 	k_timepoint_t end_time = sys_timepoint_calc(timeout);
 801dfa8: f107 0118    	add.w	r1, r7, #0x18
 801dfac: e9d7 2300    	ldrd	r2, r3, [r7]
 801dfb0: 4608         	mov	r0, r1
 801dfb2: f00a ff1b    	bl	0x8028dec <sys_timepoint_calc> @ imm = #0xae36
; 	if (chan->validator != NULL && !chan->validator(msg, chan->message_size)) {
 801dfb6: 68fb         	ldr	r3, [r7, #0xc]
 801dfb8: 68db         	ldr	r3, [r3, #0xc]
 801dfba: 2b00         	cmp	r3, #0x0
 801dfbc: d00f         	beq	0x801dfde <zbus_chan_pub+0x5a> @ imm = #0x1e
 801dfbe: 68fb         	ldr	r3, [r7, #0xc]
 801dfc0: 68db         	ldr	r3, [r3, #0xc]
 801dfc2: 68fa         	ldr	r2, [r7, #0xc]
 801dfc4: 6852         	ldr	r2, [r2, #0x4]
 801dfc6: 4611         	mov	r1, r2
 801dfc8: 68b8         	ldr	r0, [r7, #0x8]
 801dfca: 4798         	blx	r3
 801dfcc: 4603         	mov	r3, r0
 801dfce: f083 0301    	eor	r3, r3, #0x1
 801dfd2: b2db         	uxtb	r3, r3
 801dfd4: 2b00         	cmp	r3, #0x0
 801dfd6: d002         	beq	0x801dfde <zbus_chan_pub+0x5a> @ imm = #0x4
; 		return -ENOMSG;
 801dfd8: f06f 0322    	mvn	r3, #0x22
 801dfdc: e023         	b	0x801e026 <zbus_chan_pub+0xa2> @ imm = #0x46
; 	int context_priority = ZBUS_MIN_THREAD_PRIORITY;
 801dfde: 230e         	movs	r3, #0xe
 801dfe0: 617b         	str	r3, [r7, #0x14]
; 	err = chan_lock(chan, timeout, &context_priority);
 801dfe2: f107 0314    	add.w	r3, r7, #0x14
 801dfe6: 9300         	str	r3, [sp]
 801dfe8: e9d7 2300    	ldrd	r2, r3, [r7]
 801dfec: 68f8         	ldr	r0, [r7, #0xc]
 801dfee: f7e9 f81d    	bl	0x800702c <chan_lock>   @ imm = #-0x16fc6
 801dff2: 6278         	str	r0, [r7, #0x24]
; 	if (err) {
 801dff4: 6a7b         	ldr	r3, [r7, #0x24]
 801dff6: 2b00         	cmp	r3, #0x0
 801dff8: d001         	beq	0x801dffe <zbus_chan_pub+0x7a> @ imm = #0x2
; 		return err;
 801dffa: 6a7b         	ldr	r3, [r7, #0x24]
 801dffc: e013         	b	0x801e026 <zbus_chan_pub+0xa2> @ imm = #0x26
; 	memcpy(chan->message, msg, chan->message_size);
 801dffe: 68fb         	ldr	r3, [r7, #0xc]
 801e000: 6818         	ldr	r0, [r3]
 801e002: 68fb         	ldr	r3, [r7, #0xc]
 801e004: 685b         	ldr	r3, [r3, #0x4]
 801e006: 461a         	mov	r2, r3
 801e008: 68b9         	ldr	r1, [r7, #0x8]
 801e00a: f00b f873    	bl	0x80290f4 <memcpy>      @ imm = #0xb0e6
; 	err = _zbus_vded_exec(chan, end_time);
 801e00e: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 801e012: 68f8         	ldr	r0, [r7, #0xc]
 801e014: f7e8 feac    	bl	0x8006d70 <_zbus_vded_exec> @ imm = #-0x172a8
 801e018: 6278         	str	r0, [r7, #0x24]
; 	chan_unlock(chan, context_priority);
 801e01a: 697b         	ldr	r3, [r7, #0x14]
 801e01c: 4619         	mov	r1, r3
 801e01e: 68f8         	ldr	r0, [r7, #0xc]
 801e020: f7ff ff97    	bl	0x801df52 <chan_unlock> @ imm = #-0xd2
; 	return err;
 801e024: 6a7b         	ldr	r3, [r7, #0x24]
; }
 801e026: 4618         	mov	r0, r3
 801e028: 3728         	adds	r7, #0x28
 801e02a: 46bd         	mov	sp, r7
 801e02c: bd80         	pop	{r7, pc}

0801e02e <zbus_sub_wait_msg>:
; {
 801e02e: b590         	push	{r4, r7, lr}
 801e030: b087         	sub	sp, #0x1c
 801e032: af00         	add	r7, sp, #0x0
 801e034: 60f8         	str	r0, [r7, #0xc]
 801e036: 60b9         	str	r1, [r7, #0x8]
 801e038: 607a         	str	r2, [r7, #0x4]
; 	struct net_buf *buf = k_fifo_get(sub->message_fifo, timeout);
 801e03a: 68fb         	ldr	r3, [r7, #0xc]
 801e03c: 689b         	ldr	r3, [r3, #0x8]
 801e03e: 4619         	mov	r1, r3
 801e040: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 801e044: 4608         	mov	r0, r1
 801e046: f7ff fe87    	bl	0x801dd58 <k_queue_get> @ imm = #-0x2f2
 801e04a: 6178         	str	r0, [r7, #0x14]
 801e04c: 697b         	ldr	r3, [r7, #0x14]
 801e04e: 613b         	str	r3, [r7, #0x10]
; 	if (buf == NULL) {
 801e050: 693b         	ldr	r3, [r7, #0x10]
 801e052: 2b00         	cmp	r3, #0x0
 801e054: d102         	bne	0x801e05c <zbus_sub_wait_msg+0x2e> @ imm = #0x4
; 		return -ENOMSG;
 801e056: f06f 0322    	mvn	r3, #0x22
 801e05a: e020         	b	0x801e09e <zbus_sub_wait_msg+0x70> @ imm = #0x40
; 	*chan = *((struct zbus_channel **)net_buf_user_data(buf));
 801e05c: 6938         	ldr	r0, [r7, #0x10]
 801e05e: f7ff fed6    	bl	0x801de0e <net_buf_user_data> @ imm = #-0x254
 801e062: 4603         	mov	r3, r0
 801e064: 681a         	ldr	r2, [r3]
 801e066: 68bb         	ldr	r3, [r7, #0x8]
 801e068: 601a         	str	r2, [r3]
; 	memcpy(msg, net_buf_remove_mem(buf, zbus_chan_msg_size(*chan)), zbus_chan_msg_size(*chan));
 801e06a: 68bb         	ldr	r3, [r7, #0x8]
 801e06c: 681b         	ldr	r3, [r3]
 801e06e: 4618         	mov	r0, r3
 801e070: f7ff ff07    	bl	0x801de82 <zbus_chan_msg_size> @ imm = #-0x1f2
 801e074: 4603         	mov	r3, r0
 801e076: 4619         	mov	r1, r3
 801e078: 6938         	ldr	r0, [r7, #0x10]
 801e07a: f7ff fee6    	bl	0x801de4a <net_buf_remove_mem> @ imm = #-0x234
 801e07e: 4604         	mov	r4, r0
 801e080: 68bb         	ldr	r3, [r7, #0x8]
 801e082: 681b         	ldr	r3, [r3]
 801e084: 4618         	mov	r0, r3
 801e086: f7ff fefc    	bl	0x801de82 <zbus_chan_msg_size> @ imm = #-0x208
 801e08a: 4603         	mov	r3, r0
 801e08c: 461a         	mov	r2, r3
 801e08e: 4621         	mov	r1, r4
 801e090: 6878         	ldr	r0, [r7, #0x4]
 801e092: f00b f82f    	bl	0x80290f4 <memcpy>      @ imm = #0xb05e
; 	net_buf_unref(buf);
 801e096: 6938         	ldr	r0, [r7, #0x10]
 801e098: f7ff fced    	bl	0x801da76 <net_buf_unref> @ imm = #-0x626
; 	return 0;
 801e09c: 2300         	movs	r3, #0x0
; }
 801e09e: 4618         	mov	r0, r3
 801e0a0: 371c         	adds	r7, #0x1c
 801e0a2: 46bd         	mov	sp, r7
 801e0a4: bd90         	pop	{r4, r7, pc}

0801e0a6 <LL_EXTI_EnableIT_0_31>:
; {
 801e0a6: b480         	push	{r7}
 801e0a8: b083         	sub	sp, #0xc
 801e0aa: af00         	add	r7, sp, #0x0
 801e0ac: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->IMR1, ExtiLine);
 801e0ae: f04f 43b0    	mov.w	r3, #0x58000000
 801e0b2: f8d3 2080    	ldr.w	r2, [r3, #0x80]
 801e0b6: f04f 41b0    	mov.w	r1, #0x58000000
 801e0ba: 687b         	ldr	r3, [r7, #0x4]
 801e0bc: 4313         	orrs	r3, r2
 801e0be: f8c1 3080    	str.w	r3, [r1, #0x80]
; }
 801e0c2: bf00         	nop
 801e0c4: 370c         	adds	r7, #0xc
 801e0c6: 46bd         	mov	sp, r7
 801e0c8: f85d 7b04    	ldr	r7, [sp], #4
 801e0cc: 4770         	bx	lr

0801e0ce <LL_EXTI_DisableIT_0_31>:
; {
 801e0ce: b480         	push	{r7}
 801e0d0: b083         	sub	sp, #0xc
 801e0d2: af00         	add	r7, sp, #0x0
 801e0d4: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->IMR1, ExtiLine);
 801e0d6: f04f 43b0    	mov.w	r3, #0x58000000
 801e0da: f8d3 2080    	ldr.w	r2, [r3, #0x80]
 801e0de: 687b         	ldr	r3, [r7, #0x4]
 801e0e0: 43db         	mvns	r3, r3
 801e0e2: f04f 41b0    	mov.w	r1, #0x58000000
 801e0e6: 4013         	ands	r3, r2
 801e0e8: f8c1 3080    	str.w	r3, [r1, #0x80]
; }
 801e0ec: bf00         	nop
 801e0ee: 370c         	adds	r7, #0xc
 801e0f0: 46bd         	mov	sp, r7
 801e0f2: f85d 7b04    	ldr	r7, [sp], #4
 801e0f6: 4770         	bx	lr

0801e0f8 <LL_EXTI_EnableRisingTrig_0_31>:
; {
 801e0f8: b480         	push	{r7}
 801e0fa: b083         	sub	sp, #0xc
 801e0fc: af00         	add	r7, sp, #0x0
 801e0fe: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->RTSR1, ExtiLine);
 801e100: f04f 43b0    	mov.w	r3, #0x58000000
 801e104: 681a         	ldr	r2, [r3]
 801e106: f04f 41b0    	mov.w	r1, #0x58000000
 801e10a: 687b         	ldr	r3, [r7, #0x4]
 801e10c: 4313         	orrs	r3, r2
 801e10e: 600b         	str	r3, [r1]
; }
 801e110: bf00         	nop
 801e112: 370c         	adds	r7, #0xc
 801e114: 46bd         	mov	sp, r7
 801e116: f85d 7b04    	ldr	r7, [sp], #4
 801e11a: 4770         	bx	lr

0801e11c <LL_EXTI_DisableRisingTrig_0_31>:
; {
 801e11c: b480         	push	{r7}
 801e11e: b083         	sub	sp, #0xc
 801e120: af00         	add	r7, sp, #0x0
 801e122: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->RTSR1, ExtiLine);
 801e124: f04f 43b0    	mov.w	r3, #0x58000000
 801e128: 681a         	ldr	r2, [r3]
 801e12a: 687b         	ldr	r3, [r7, #0x4]
 801e12c: 43db         	mvns	r3, r3
 801e12e: f04f 41b0    	mov.w	r1, #0x58000000
 801e132: 4013         	ands	r3, r2
 801e134: 600b         	str	r3, [r1]
; }
 801e136: bf00         	nop
 801e138: 370c         	adds	r7, #0xc
 801e13a: 46bd         	mov	sp, r7
 801e13c: f85d 7b04    	ldr	r7, [sp], #4
 801e140: 4770         	bx	lr

0801e142 <LL_EXTI_EnableFallingTrig_0_31>:
; {
 801e142: b480         	push	{r7}
 801e144: b083         	sub	sp, #0xc
 801e146: af00         	add	r7, sp, #0x0
 801e148: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->FTSR1, ExtiLine);
 801e14a: f04f 43b0    	mov.w	r3, #0x58000000
 801e14e: 685a         	ldr	r2, [r3, #0x4]
 801e150: f04f 41b0    	mov.w	r1, #0x58000000
 801e154: 687b         	ldr	r3, [r7, #0x4]
 801e156: 4313         	orrs	r3, r2
 801e158: 604b         	str	r3, [r1, #0x4]
; }
 801e15a: bf00         	nop
 801e15c: 370c         	adds	r7, #0xc
 801e15e: 46bd         	mov	sp, r7
 801e160: f85d 7b04    	ldr	r7, [sp], #4
 801e164: 4770         	bx	lr

0801e166 <LL_EXTI_DisableFallingTrig_0_31>:
; {
 801e166: b480         	push	{r7}
 801e168: b083         	sub	sp, #0xc
 801e16a: af00         	add	r7, sp, #0x0
 801e16c: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->FTSR1, ExtiLine);
 801e16e: f04f 43b0    	mov.w	r3, #0x58000000
 801e172: 685a         	ldr	r2, [r3, #0x4]
 801e174: 687b         	ldr	r3, [r7, #0x4]
 801e176: 43db         	mvns	r3, r3
 801e178: f04f 41b0    	mov.w	r1, #0x58000000
 801e17c: 4013         	ands	r3, r2
 801e17e: 604b         	str	r3, [r1, #0x4]
; }
 801e180: bf00         	nop
 801e182: 370c         	adds	r7, #0xc
 801e184: 46bd         	mov	sp, r7
 801e186: f85d 7b04    	ldr	r7, [sp], #4
 801e18a: 4770         	bx	lr

0801e18c <LL_EXTI_IsActiveFlag_0_31>:
; {
 801e18c: b480         	push	{r7}
 801e18e: b083         	sub	sp, #0xc
 801e190: af00         	add	r7, sp, #0x0
 801e192: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(EXTI->PR1, ExtiLine) == (ExtiLine)) ? 1U : 0U);
 801e194: f04f 43b0    	mov.w	r3, #0x58000000
 801e198: f8d3 2088    	ldr.w	r2, [r3, #0x88]
 801e19c: 687b         	ldr	r3, [r7, #0x4]
 801e19e: 4013         	ands	r3, r2
 801e1a0: 687a         	ldr	r2, [r7, #0x4]
 801e1a2: 429a         	cmp	r2, r3
 801e1a4: d101         	bne	0x801e1aa <LL_EXTI_IsActiveFlag_0_31+0x1e> @ imm = #0x2
 801e1a6: 2301         	movs	r3, #0x1
 801e1a8: e000         	b	0x801e1ac <LL_EXTI_IsActiveFlag_0_31+0x20> @ imm = #0x0
 801e1aa: 2300         	movs	r3, #0x0
; }
 801e1ac: 4618         	mov	r0, r3
 801e1ae: 370c         	adds	r7, #0xc
 801e1b0: 46bd         	mov	sp, r7
 801e1b2: f85d 7b04    	ldr	r7, [sp], #4
 801e1b6: 4770         	bx	lr

0801e1b8 <LL_EXTI_ClearFlag_0_31>:
; {
 801e1b8: b480         	push	{r7}
 801e1ba: b083         	sub	sp, #0xc
 801e1bc: af00         	add	r7, sp, #0x0
 801e1be: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(EXTI->PR1, ExtiLine);
 801e1c0: f04f 42b0    	mov.w	r2, #0x58000000
 801e1c4: 687b         	ldr	r3, [r7, #0x4]
 801e1c6: f8c2 3088    	str.w	r3, [r2, #0x88]
; }
 801e1ca: bf00         	nop
 801e1cc: 370c         	adds	r7, #0xc
 801e1ce: 46bd         	mov	sp, r7
 801e1d0: f85d 7b04    	ldr	r7, [sp], #4
 801e1d4: 4770         	bx	lr

0801e1d6 <clock_control_on>:
; {
 801e1d6: b580         	push	{r7, lr}
 801e1d8: b084         	sub	sp, #0x10
 801e1da: af00         	add	r7, sp, #0x0
 801e1dc: 6078         	str	r0, [r7, #0x4]
 801e1de: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801e1e0: 687b         	ldr	r3, [r7, #0x4]
 801e1e2: 689b         	ldr	r3, [r3, #0x8]
 801e1e4: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801e1e6: 68fb         	ldr	r3, [r7, #0xc]
 801e1e8: 681b         	ldr	r3, [r3]
 801e1ea: 6839         	ldr	r1, [r7]
 801e1ec: 6878         	ldr	r0, [r7, #0x4]
 801e1ee: 4798         	blx	r3
 801e1f0: 4603         	mov	r3, r0
; }
 801e1f2: 4618         	mov	r0, r3
 801e1f4: 3710         	adds	r7, #0x10
 801e1f6: 46bd         	mov	sp, r7
 801e1f8: bd80         	pop	{r7, pc}

0801e1fa <z_stm32_hsem_lock>:
; {
 801e1fa: b480         	push	{r7}
 801e1fc: b083         	sub	sp, #0xc
 801e1fe: af00         	add	r7, sp, #0x0
 801e200: 6078         	str	r0, [r7, #0x4]
 801e202: 6039         	str	r1, [r7]
; }
 801e204: bf00         	nop
 801e206: 370c         	adds	r7, #0xc
 801e208: 46bd         	mov	sp, r7
 801e20a: f85d 7b04    	ldr	r7, [sp], #4
 801e20e: 4770         	bx	lr

0801e210 <z_stm32_hsem_unlock>:
; {
 801e210: b480         	push	{r7}
 801e212: b083         	sub	sp, #0xc
 801e214: af00         	add	r7, sp, #0x0
 801e216: 6078         	str	r0, [r7, #0x4]
; }
 801e218: bf00         	nop
 801e21a: 370c         	adds	r7, #0xc
 801e21c: 46bd         	mov	sp, r7
 801e21e: f85d 7b04    	ldr	r7, [sp], #4
 801e222: 4770         	bx	lr

0801e224 <stm32_exti_linenum_to_src_cfg_line>:
; {
 801e224: b480         	push	{r7}
 801e226: b083         	sub	sp, #0xc
 801e228: af00         	add	r7, sp, #0x0
 801e22a: 4603         	mov	r3, r0
 801e22c: 71fb         	strb	r3, [r7, #0x7]
; 	return (0xF << ((linenum % 4 * 4) + 16)) | (linenum / 4);
 801e22e: 79fb         	ldrb	r3, [r7, #0x7]
 801e230: f003 0303    	and	r3, r3, #0x3
 801e234: 3304         	adds	r3, #0x4
 801e236: 009b         	lsls	r3, r3, #0x2
 801e238: 220f         	movs	r2, #0xf
 801e23a: fa02 f303    	lsl.w	r3, r2, r3
 801e23e: 79fa         	ldrb	r2, [r7, #0x7]
 801e240: 0892         	lsrs	r2, r2, #0x2
 801e242: b2d2         	uxtb	r2, r2
 801e244: 4313         	orrs	r3, r2
; }
 801e246: 4618         	mov	r0, r3
 801e248: 370c         	adds	r7, #0xc
 801e24a: 46bd         	mov	sp, r7
 801e24c: f85d 7b04    	ldr	r7, [sp], #4
 801e250: 4770         	bx	lr

0801e252 <stm32_exti_is_pending>:
; {
 801e252: b580         	push	{r7, lr}
 801e254: b082         	sub	sp, #0x8
 801e256: af00         	add	r7, sp, #0x0
 801e258: 6078         	str	r0, [r7, #0x4]
; 	return LL_EXTI_IsActiveFlag_0_31(line);
 801e25a: 6878         	ldr	r0, [r7, #0x4]
 801e25c: f7ff ff96    	bl	0x801e18c <LL_EXTI_IsActiveFlag_0_31> @ imm = #-0xd4
 801e260: 4603         	mov	r3, r0
; }
 801e262: 4618         	mov	r0, r3
 801e264: 3708         	adds	r7, #0x8
 801e266: 46bd         	mov	sp, r7
 801e268: bd80         	pop	{r7, pc}

0801e26a <stm32_exti_clear_pending>:
; {
 801e26a: b580         	push	{r7, lr}
 801e26c: b082         	sub	sp, #0x8
 801e26e: af00         	add	r7, sp, #0x0
 801e270: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_ClearFlag_0_31(line);
 801e272: 6878         	ldr	r0, [r7, #0x4]
 801e274: f7ff ffa0    	bl	0x801e1b8 <LL_EXTI_ClearFlag_0_31> @ imm = #-0xc0
; }
 801e278: bf00         	nop
 801e27a: 3708         	adds	r7, #0x8
 801e27c: 46bd         	mov	sp, r7
 801e27e: bd80         	pop	{r7, pc}

0801e280 <linenum_to_ll_exti_line>:
; {
 801e280: b480         	push	{r7}
 801e282: b083         	sub	sp, #0xc
 801e284: af00         	add	r7, sp, #0x0
 801e286: 4603         	mov	r3, r0
 801e288: 71fb         	strb	r3, [r7, #0x7]
; 	return BIT(linenum);
 801e28a: 79fb         	ldrb	r3, [r7, #0x7]
 801e28c: 2201         	movs	r2, #0x1
 801e28e: fa02 f303    	lsl.w	r3, r2, r3
; }
 801e292: 4618         	mov	r0, r3
 801e294: 370c         	adds	r7, #0xc
 801e296: 46bd         	mov	sp, r7
 801e298: f85d 7b04    	ldr	r7, [sp], #4
 801e29c: 4770         	bx	lr

0801e29e <ll_exti_line_to_linenum>:
; {
 801e29e: b480         	push	{r7}
 801e2a0: b083         	sub	sp, #0xc
 801e2a2: af00         	add	r7, sp, #0x0
 801e2a4: 6078         	str	r0, [r7, #0x4]
; 	return LOG2(line);
 801e2a6: 687b         	ldr	r3, [r7, #0x4]
 801e2a8: 2b00         	cmp	r3, #0x0
 801e2aa: d007         	beq	0x801e2bc <ll_exti_line_to_linenum+0x1e> @ imm = #0xe
 801e2ac: 687b         	ldr	r3, [r7, #0x4]
 801e2ae: fab3 f383    	clz	r3, r3
 801e2b2: b2db         	uxtb	r3, r3
 801e2b4: f1c3 031f    	rsb.w	r3, r3, #0x1f
 801e2b8: b2db         	uxtb	r3, r3
 801e2ba: e000         	b	0x801e2be <ll_exti_line_to_linenum+0x20> @ imm = #0x0
 801e2bc: 23ff         	movs	r3, #0xff
; }
 801e2be: 4618         	mov	r0, r3
 801e2c0: 370c         	adds	r7, #0xc
 801e2c2: 46bd         	mov	sp, r7
 801e2c4: f85d 7b04    	ldr	r7, [sp], #4
 801e2c8: 4770         	bx	lr

0801e2ca <stm32_gpio_intc_get_pin_irq_line>:
; {
 801e2ca: b580         	push	{r7, lr}
 801e2cc: b082         	sub	sp, #0x8
 801e2ce: af00         	add	r7, sp, #0x0
 801e2d0: 6078         	str	r0, [r7, #0x4]
 801e2d2: 460b         	mov	r3, r1
 801e2d4: 70fb         	strb	r3, [r7, #0x3]
; 	return linenum_to_ll_exti_line(pin);
 801e2d6: 78fb         	ldrb	r3, [r7, #0x3]
 801e2d8: 4618         	mov	r0, r3
 801e2da: f7ff ffd1    	bl	0x801e280 <linenum_to_ll_exti_line> @ imm = #-0x5e
 801e2de: 4603         	mov	r3, r0
; }
 801e2e0: 4618         	mov	r0, r3
 801e2e2: 3708         	adds	r7, #0x8
 801e2e4: 46bd         	mov	sp, r7
 801e2e6: bd80         	pop	{r7, pc}

0801e2e8 <stm32_gpio_intc_disable_line>:
; {
 801e2e8: b580         	push	{r7, lr}
 801e2ea: b082         	sub	sp, #0x8
 801e2ec: af00         	add	r7, sp, #0x0
 801e2ee: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_DisableIT_0_31(line);
 801e2f0: 6878         	ldr	r0, [r7, #0x4]
 801e2f2: f7ff feec    	bl	0x801e0ce <LL_EXTI_DisableIT_0_31> @ imm = #-0x228
; }
 801e2f6: bf00         	nop
 801e2f8: 3708         	adds	r7, #0x8
 801e2fa: 46bd         	mov	sp, r7
 801e2fc: bd80         	pop	{r7, pc}

0801e2fe <stm32_exti_set_line_src_port>:
; {
 801e2fe: b580         	push	{r7, lr}
 801e300: b084         	sub	sp, #0x10
 801e302: af00         	add	r7, sp, #0x0
 801e304: 4603         	mov	r3, r0
 801e306: 6039         	str	r1, [r7]
 801e308: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 801e30a: 79fb         	ldrb	r3, [r7, #0x7]
 801e30c: 4618         	mov	r0, r3
 801e30e: f7ff ff89    	bl	0x801e224 <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0xee
 801e312: 60f8         	str	r0, [r7, #0xc]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 801e314: f44f 1180    	mov.w	r1, #0x100000
 801e318: 2000         	movs	r0, #0x0
 801e31a: f7ff ff6e    	bl	0x801e1fa <z_stm32_hsem_lock> @ imm = #-0x124
; 	LL_SYSCFG_SetEXTISource(port, ll_line);
 801e31e: 68f9         	ldr	r1, [r7, #0xc]
 801e320: 6838         	ldr	r0, [r7]
 801e322: f7e8 ff0d    	bl	0x8007140 <LL_SYSCFG_SetEXTISource> @ imm = #-0x171e6
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 801e326: 2000         	movs	r0, #0x0
 801e328: f7ff ff72    	bl	0x801e210 <z_stm32_hsem_unlock> @ imm = #-0x11c
; }
 801e32c: bf00         	nop
 801e32e: 3710         	adds	r7, #0x10
 801e330: 46bd         	mov	sp, r7
 801e332: bd80         	pop	{r7, pc}

0801e334 <stm32_exti_get_line_src_port>:
; {
 801e334: b580         	push	{r7, lr}
 801e336: b084         	sub	sp, #0x10
 801e338: af00         	add	r7, sp, #0x0
 801e33a: 4603         	mov	r3, r0
 801e33c: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 801e33e: 79fb         	ldrb	r3, [r7, #0x7]
 801e340: 4618         	mov	r0, r3
 801e342: f7ff ff6f    	bl	0x801e224 <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0x122
 801e346: 60f8         	str	r0, [r7, #0xc]
; 	port = LL_SYSCFG_GetEXTISource(ll_line);
 801e348: 68f8         	ldr	r0, [r7, #0xc]
 801e34a: f7e8 ff31    	bl	0x80071b0 <LL_SYSCFG_GetEXTISource> @ imm = #-0x1719e
 801e34e: 60b8         	str	r0, [r7, #0x8]
; 	return port;
 801e350: 68bb         	ldr	r3, [r7, #0x8]
; }
 801e352: 4618         	mov	r0, r3
 801e354: 3710         	adds	r7, #0x10
 801e356: 46bd         	mov	sp, r7
 801e358: bd80         	pop	{r7, pc}

0801e35a <k_sem_init>:
; {
 801e35a: b580         	push	{r7, lr}
 801e35c: b084         	sub	sp, #0x10
 801e35e: af00         	add	r7, sp, #0x0
 801e360: 60f8         	str	r0, [r7, #0xc]
 801e362: 60b9         	str	r1, [r7, #0x8]
 801e364: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 801e366: 687a         	ldr	r2, [r7, #0x4]
 801e368: 68b9         	ldr	r1, [r7, #0x8]
 801e36a: 68f8         	ldr	r0, [r7, #0xc]
 801e36c: f009 f9d5    	bl	0x802771a <z_impl_k_sem_init> @ imm = #0x93aa
 801e370: 4603         	mov	r3, r0
; }
 801e372: 4618         	mov	r0, r3
 801e374: 3710         	adds	r7, #0x10
 801e376: 46bd         	mov	sp, r7
 801e378: bd80         	pop	{r7, pc}

0801e37a <k_sem_take>:
; {
 801e37a: b580         	push	{r7, lr}
 801e37c: b084         	sub	sp, #0x10
 801e37e: af00         	add	r7, sp, #0x0
 801e380: 60f8         	str	r0, [r7, #0xc]
 801e382: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 801e386: e9d7 2300    	ldrd	r2, r3, [r7]
 801e38a: 68f8         	ldr	r0, [r7, #0xc]
 801e38c: f7f7 f9f2    	bl	0x8015774 <z_impl_k_sem_take> @ imm = #-0x8c1c
 801e390: 4603         	mov	r3, r0
; }
 801e392: 4618         	mov	r0, r3
 801e394: 3710         	adds	r7, #0x10
 801e396: 46bd         	mov	sp, r7
 801e398: bd80         	pop	{r7, pc}

0801e39a <k_sem_give>:
; {
 801e39a: b580         	push	{r7, lr}
 801e39c: b082         	sub	sp, #0x8
 801e39e: af00         	add	r7, sp, #0x0
 801e3a0: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801e3a2: 6878         	ldr	r0, [r7, #0x4]
 801e3a4: f7f7 f958    	bl	0x8015658 <z_impl_k_sem_give> @ imm = #-0x8d50
; }
 801e3a8: bf00         	nop
 801e3aa: 3708         	adds	r7, #0x8
 801e3ac: 46bd         	mov	sp, r7
 801e3ae: bd80         	pop	{r7, pc}

0801e3b0 <z_impl_can_get_core_clock>:
; {
 801e3b0: b580         	push	{r7, lr}
 801e3b2: b084         	sub	sp, #0x10
 801e3b4: af00         	add	r7, sp, #0x0
 801e3b6: 6078         	str	r0, [r7, #0x4]
 801e3b8: 6039         	str	r1, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 801e3ba: 687b         	ldr	r3, [r7, #0x4]
 801e3bc: 689b         	ldr	r3, [r3, #0x8]
 801e3be: 60fb         	str	r3, [r7, #0xc]
; 	return api->get_core_clock(dev, rate);
 801e3c0: 68fb         	ldr	r3, [r7, #0xc]
 801e3c2: 6a9b         	ldr	r3, [r3, #0x28]
 801e3c4: 6839         	ldr	r1, [r7]
 801e3c6: 6878         	ldr	r0, [r7, #0x4]
 801e3c8: 4798         	blx	r3
 801e3ca: 4603         	mov	r3, r0
; }
 801e3cc: 4618         	mov	r0, r3
 801e3ce: 3710         	adds	r7, #0x10
 801e3d0: 46bd         	mov	sp, r7
 801e3d2: bd80         	pop	{r7, pc}

0801e3d4 <z_impl_can_get_timing_min>:
; {
 801e3d4: b480         	push	{r7}
 801e3d6: b085         	sub	sp, #0x14
 801e3d8: af00         	add	r7, sp, #0x0
 801e3da: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 801e3dc: 687b         	ldr	r3, [r7, #0x4]
 801e3de: 689b         	ldr	r3, [r3, #0x8]
 801e3e0: 60fb         	str	r3, [r7, #0xc]
; 	return &api->timing_min;
 801e3e2: 68fb         	ldr	r3, [r7, #0xc]
 801e3e4: 3330         	adds	r3, #0x30
; }
 801e3e6: 4618         	mov	r0, r3
 801e3e8: 3714         	adds	r7, #0x14
 801e3ea: 46bd         	mov	sp, r7
 801e3ec: f85d 7b04    	ldr	r7, [sp], #4
 801e3f0: 4770         	bx	lr

0801e3f2 <z_impl_can_get_timing_max>:
; {
 801e3f2: b480         	push	{r7}
 801e3f4: b085         	sub	sp, #0x14
 801e3f6: af00         	add	r7, sp, #0x0
 801e3f8: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 801e3fa: 687b         	ldr	r3, [r7, #0x4]
 801e3fc: 689b         	ldr	r3, [r3, #0x8]
 801e3fe: 60fb         	str	r3, [r7, #0xc]
; 	return &api->timing_max;
 801e400: 68fb         	ldr	r3, [r7, #0xc]
 801e402: 333a         	adds	r3, #0x3a
; }
 801e404: 4618         	mov	r0, r3
 801e406: 3714         	adds	r7, #0x14
 801e408: 46bd         	mov	sp, r7
 801e40a: f85d 7b04    	ldr	r7, [sp], #4
 801e40e: 4770         	bx	lr

0801e410 <can_get_core_clock>:
; {
 801e410: b580         	push	{r7, lr}
 801e412: b082         	sub	sp, #0x8
 801e414: af00         	add	r7, sp, #0x0
 801e416: 6078         	str	r0, [r7, #0x4]
 801e418: 6039         	str	r1, [r7]
; 	return z_impl_can_get_core_clock(dev, rate);
 801e41a: 6839         	ldr	r1, [r7]
 801e41c: 6878         	ldr	r0, [r7, #0x4]
 801e41e: f7ff ffc7    	bl	0x801e3b0 <z_impl_can_get_core_clock> @ imm = #-0x72
 801e422: 4603         	mov	r3, r0
; }
 801e424: 4618         	mov	r0, r3
 801e426: 3708         	adds	r7, #0x8
 801e428: 46bd         	mov	sp, r7
 801e42a: bd80         	pop	{r7, pc}

0801e42c <can_get_timing_min>:
; {
 801e42c: b580         	push	{r7, lr}
 801e42e: b082         	sub	sp, #0x8
 801e430: af00         	add	r7, sp, #0x0
 801e432: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_get_timing_min(dev);
 801e434: 6878         	ldr	r0, [r7, #0x4]
 801e436: f7ff ffcd    	bl	0x801e3d4 <z_impl_can_get_timing_min> @ imm = #-0x66
 801e43a: 4603         	mov	r3, r0
; }
 801e43c: 4618         	mov	r0, r3
 801e43e: 3708         	adds	r7, #0x8
 801e440: 46bd         	mov	sp, r7
 801e442: bd80         	pop	{r7, pc}

0801e444 <can_get_timing_max>:
; {
 801e444: b580         	push	{r7, lr}
 801e446: b082         	sub	sp, #0x8
 801e448: af00         	add	r7, sp, #0x0
 801e44a: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_get_timing_max(dev);
 801e44c: 6878         	ldr	r0, [r7, #0x4]
 801e44e: f7ff ffd0    	bl	0x801e3f2 <z_impl_can_get_timing_max> @ imm = #-0x60
 801e452: 4603         	mov	r3, r0
; }
 801e454: 4618         	mov	r0, r3
 801e456: 3708         	adds	r7, #0x8
 801e458: 46bd         	mov	sp, r7
 801e45a: bd80         	pop	{r7, pc}

0801e45c <z_log_msg_runtime_create>:
; {
 801e45c: b580         	push	{r7, lr}
 801e45e: b08a         	sub	sp, #0x28
 801e460: af04         	add	r7, sp, #0x10
 801e462: 60b9         	str	r1, [r7, #0x8]
 801e464: 607b         	str	r3, [r7, #0x4]
 801e466: 4603         	mov	r3, r0
 801e468: 73fb         	strb	r3, [r7, #0xf]
 801e46a: 4613         	mov	r3, r2
 801e46c: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801e46e: f107 032c    	add.w	r3, r7, #0x2c
 801e472: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801e474: 7bba         	ldrb	r2, [r7, #0xe]
 801e476: 7bf8         	ldrb	r0, [r7, #0xf]
 801e478: 697b         	ldr	r3, [r7, #0x14]
 801e47a: 9303         	str	r3, [sp, #0xc]
 801e47c: 6abb         	ldr	r3, [r7, #0x28]
 801e47e: 9302         	str	r3, [sp, #0x8]
 801e480: 6a7b         	ldr	r3, [r7, #0x24]
 801e482: 9301         	str	r3, [sp, #0x4]
 801e484: 6a3b         	ldr	r3, [r7, #0x20]
 801e486: 9300         	str	r3, [sp]
 801e488: 687b         	ldr	r3, [r7, #0x4]
 801e48a: 68b9         	ldr	r1, [r7, #0x8]
 801e48c: f7e6 fb72    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1991c
; }
 801e490: bf00         	nop
 801e492: 3718         	adds	r7, #0x18
 801e494: 46bd         	mov	sp, r7
 801e496: bd80         	pop	{r7, pc}

0801e498 <can_tx_default_cb>:
; {
 801e498: b580         	push	{r7, lr}
 801e49a: b086         	sub	sp, #0x18
 801e49c: af00         	add	r7, sp, #0x0
 801e49e: 60f8         	str	r0, [r7, #0xc]
 801e4a0: 60b9         	str	r1, [r7, #0x8]
 801e4a2: 607a         	str	r2, [r7, #0x4]
; 	struct can_tx_default_cb_ctx *ctx = user_data;
 801e4a4: 687b         	ldr	r3, [r7, #0x4]
 801e4a6: 617b         	str	r3, [r7, #0x14]
; 	ctx->status = error;
 801e4a8: 697b         	ldr	r3, [r7, #0x14]
 801e4aa: 68ba         	ldr	r2, [r7, #0x8]
 801e4ac: 611a         	str	r2, [r3, #0x10]
; 	k_sem_give(&ctx->done);
 801e4ae: 697b         	ldr	r3, [r7, #0x14]
 801e4b0: 4618         	mov	r0, r3
 801e4b2: f7ff ff72    	bl	0x801e39a <k_sem_give>  @ imm = #-0x11c
; }
 801e4b6: bf00         	nop
 801e4b8: 3718         	adds	r7, #0x18
 801e4ba: 46bd         	mov	sp, r7
 801e4bc: bd80         	pop	{r7, pc}

0801e4be <check_timing_in_range>:
; {
 801e4be: b480         	push	{r7}
 801e4c0: b085         	sub	sp, #0x14
 801e4c2: af00         	add	r7, sp, #0x0
 801e4c4: 60f8         	str	r0, [r7, #0xc]
 801e4c6: 60b9         	str	r1, [r7, #0x8]
 801e4c8: 607a         	str	r2, [r7, #0x4]
; 	if (!IN_RANGE(timing->sjw, min->sjw, max->sjw) ||
 801e4ca: 68fb         	ldr	r3, [r7, #0xc]
 801e4cc: 881a         	ldrh	r2, [r3]
 801e4ce: 68bb         	ldr	r3, [r7, #0x8]
 801e4d0: 881b         	ldrh	r3, [r3]
 801e4d2: 429a         	cmp	r2, r3
 801e4d4: d335         	blo	0x801e542 <check_timing_in_range+0x84> @ imm = #0x6a
 801e4d6: 68fb         	ldr	r3, [r7, #0xc]
 801e4d8: 881a         	ldrh	r2, [r3]
 801e4da: 687b         	ldr	r3, [r7, #0x4]
 801e4dc: 881b         	ldrh	r3, [r3]
 801e4de: 429a         	cmp	r2, r3
 801e4e0: d82f         	bhi	0x801e542 <check_timing_in_range+0x84> @ imm = #0x5e
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 801e4e2: 68fb         	ldr	r3, [r7, #0xc]
 801e4e4: 885a         	ldrh	r2, [r3, #0x2]
 801e4e6: 68bb         	ldr	r3, [r7, #0x8]
 801e4e8: 885b         	ldrh	r3, [r3, #0x2]
; 	if (!IN_RANGE(timing->sjw, min->sjw, max->sjw) ||
 801e4ea: 429a         	cmp	r2, r3
 801e4ec: d329         	blo	0x801e542 <check_timing_in_range+0x84> @ imm = #0x52
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 801e4ee: 68fb         	ldr	r3, [r7, #0xc]
 801e4f0: 885a         	ldrh	r2, [r3, #0x2]
 801e4f2: 687b         	ldr	r3, [r7, #0x4]
 801e4f4: 885b         	ldrh	r3, [r3, #0x2]
 801e4f6: 429a         	cmp	r2, r3
 801e4f8: d823         	bhi	0x801e542 <check_timing_in_range+0x84> @ imm = #0x46
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 801e4fa: 68fb         	ldr	r3, [r7, #0xc]
 801e4fc: 889a         	ldrh	r2, [r3, #0x4]
 801e4fe: 68bb         	ldr	r3, [r7, #0x8]
 801e500: 889b         	ldrh	r3, [r3, #0x4]
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 801e502: 429a         	cmp	r2, r3
 801e504: d31d         	blo	0x801e542 <check_timing_in_range+0x84> @ imm = #0x3a
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 801e506: 68fb         	ldr	r3, [r7, #0xc]
 801e508: 889a         	ldrh	r2, [r3, #0x4]
 801e50a: 687b         	ldr	r3, [r7, #0x4]
 801e50c: 889b         	ldrh	r3, [r3, #0x4]
 801e50e: 429a         	cmp	r2, r3
 801e510: d817         	bhi	0x801e542 <check_timing_in_range+0x84> @ imm = #0x2e
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 801e512: 68fb         	ldr	r3, [r7, #0xc]
 801e514: 88da         	ldrh	r2, [r3, #0x6]
 801e516: 68bb         	ldr	r3, [r7, #0x8]
 801e518: 88db         	ldrh	r3, [r3, #0x6]
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 801e51a: 429a         	cmp	r2, r3
 801e51c: d311         	blo	0x801e542 <check_timing_in_range+0x84> @ imm = #0x22
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 801e51e: 68fb         	ldr	r3, [r7, #0xc]
 801e520: 88da         	ldrh	r2, [r3, #0x6]
 801e522: 687b         	ldr	r3, [r7, #0x4]
 801e524: 88db         	ldrh	r3, [r3, #0x6]
 801e526: 429a         	cmp	r2, r3
 801e528: d80b         	bhi	0x801e542 <check_timing_in_range+0x84> @ imm = #0x16
; 	    !IN_RANGE(timing->prescaler, min->prescaler, max->prescaler)) {
 801e52a: 68fb         	ldr	r3, [r7, #0xc]
 801e52c: 891a         	ldrh	r2, [r3, #0x8]
 801e52e: 68bb         	ldr	r3, [r7, #0x8]
 801e530: 891b         	ldrh	r3, [r3, #0x8]
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 801e532: 429a         	cmp	r2, r3
 801e534: d305         	blo	0x801e542 <check_timing_in_range+0x84> @ imm = #0xa
; 	    !IN_RANGE(timing->prescaler, min->prescaler, max->prescaler)) {
 801e536: 68fb         	ldr	r3, [r7, #0xc]
 801e538: 891a         	ldrh	r2, [r3, #0x8]
 801e53a: 687b         	ldr	r3, [r7, #0x4]
 801e53c: 891b         	ldrh	r3, [r3, #0x8]
 801e53e: 429a         	cmp	r2, r3
 801e540: d902         	bls	0x801e548 <check_timing_in_range+0x8a> @ imm = #0x4
; 		return -ENOTSUP;
 801e542: f06f 0385    	mvn	r3, #0x85
 801e546: e00f         	b	0x801e568 <check_timing_in_range+0xaa> @ imm = #0x1e
; 	if ((timing->sjw > timing->phase_seg1) || (timing->sjw > timing->phase_seg2)) {
 801e548: 68fb         	ldr	r3, [r7, #0xc]
 801e54a: 881a         	ldrh	r2, [r3]
 801e54c: 68fb         	ldr	r3, [r7, #0xc]
 801e54e: 889b         	ldrh	r3, [r3, #0x4]
 801e550: 429a         	cmp	r2, r3
 801e552: d805         	bhi	0x801e560 <check_timing_in_range+0xa2> @ imm = #0xa
 801e554: 68fb         	ldr	r3, [r7, #0xc]
 801e556: 881a         	ldrh	r2, [r3]
 801e558: 68fb         	ldr	r3, [r7, #0xc]
 801e55a: 88db         	ldrh	r3, [r3, #0x6]
 801e55c: 429a         	cmp	r2, r3
 801e55e: d902         	bls	0x801e566 <check_timing_in_range+0xa8> @ imm = #0x4
; 		return -ENOTSUP;
 801e560: f06f 0385    	mvn	r3, #0x85
 801e564: e000         	b	0x801e568 <check_timing_in_range+0xaa> @ imm = #0x0
; 	return 0;
 801e566: 2300         	movs	r3, #0x0
; }
 801e568: 4618         	mov	r0, r3
 801e56a: 3714         	adds	r7, #0x14
 801e56c: 46bd         	mov	sp, r7
 801e56e: f85d 7b04    	ldr	r7, [sp], #4
 801e572: 4770         	bx	lr

0801e574 <z_impl_can_set_timing>:
; {
 801e574: b580         	push	{r7, lr}
 801e576: b086         	sub	sp, #0x18
 801e578: af00         	add	r7, sp, #0x0
 801e57a: 6078         	str	r0, [r7, #0x4]
 801e57c: 6039         	str	r1, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 801e57e: 687b         	ldr	r3, [r7, #0x4]
 801e580: 689b         	ldr	r3, [r3, #0x8]
 801e582: 617b         	str	r3, [r7, #0x14]
; 	const struct can_timing *min = can_get_timing_min(dev);
 801e584: 6878         	ldr	r0, [r7, #0x4]
 801e586: f7ff ff51    	bl	0x801e42c <can_get_timing_min> @ imm = #-0x15e
 801e58a: 6138         	str	r0, [r7, #0x10]
; 	const struct can_timing *max = can_get_timing_max(dev);
 801e58c: 6878         	ldr	r0, [r7, #0x4]
 801e58e: f7ff ff59    	bl	0x801e444 <can_get_timing_max> @ imm = #-0x14e
 801e592: 60f8         	str	r0, [r7, #0xc]
; 	err = check_timing_in_range(timing, min, max);
 801e594: 68fa         	ldr	r2, [r7, #0xc]
 801e596: 6939         	ldr	r1, [r7, #0x10]
 801e598: 6838         	ldr	r0, [r7]
 801e59a: f7ff ff90    	bl	0x801e4be <check_timing_in_range> @ imm = #-0xe0
 801e59e: 60b8         	str	r0, [r7, #0x8]
; 	if (err != 0) {
 801e5a0: 68bb         	ldr	r3, [r7, #0x8]
 801e5a2: 2b00         	cmp	r3, #0x0
 801e5a4: d001         	beq	0x801e5aa <z_impl_can_set_timing+0x36> @ imm = #0x2
; 		return err;
 801e5a6: 68bb         	ldr	r3, [r7, #0x8]
 801e5a8: e005         	b	0x801e5b6 <z_impl_can_set_timing+0x42> @ imm = #0xa
; 	return api->set_timing(dev, timing);
 801e5aa: 697b         	ldr	r3, [r7, #0x14]
 801e5ac: 691b         	ldr	r3, [r3, #0x10]
 801e5ae: 6839         	ldr	r1, [r7]
 801e5b0: 6878         	ldr	r0, [r7, #0x4]
 801e5b2: 4798         	blx	r3
 801e5b4: 4603         	mov	r3, r0
; }
 801e5b6: 4618         	mov	r0, r3
 801e5b8: 3718         	adds	r7, #0x18
 801e5ba: 46bd         	mov	sp, r7
 801e5bc: bd80         	pop	{r7, pc}

0801e5be <device_is_ready>:
; {
 801e5be: b580         	push	{r7, lr}
 801e5c0: b082         	sub	sp, #0x8
 801e5c2: af00         	add	r7, sp, #0x0
 801e5c4: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801e5c6: 6878         	ldr	r0, [r7, #0x4]
 801e5c8: f007 fee9    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x7dd2
 801e5cc: 4603         	mov	r3, r0
; }
 801e5ce: 4618         	mov	r0, r3
 801e5d0: 3708         	adds	r7, #0x8
 801e5d2: 46bd         	mov	sp, r7
 801e5d4: bd80         	pop	{r7, pc}

0801e5d6 <arch_k_cycle_get_32>:
; {
 801e5d6: b580         	push	{r7, lr}
 801e5d8: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 801e5da: f7f3 f933    	bl	0x8011844 <sys_clock_cycle_get_32> @ imm = #-0xcd9a
 801e5de: 4603         	mov	r3, r0
; }
 801e5e0: 4618         	mov	r0, r3
 801e5e2: bd80         	pop	{r7, pc}

0801e5e4 <k_cycle_get_32>:
; {
 801e5e4: b580         	push	{r7, lr}
 801e5e6: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 801e5e8: f7ff fff5    	bl	0x801e5d6 <arch_k_cycle_get_32> @ imm = #-0x16
 801e5ec: 4603         	mov	r3, r0
; }
 801e5ee: 4618         	mov	r0, r3
 801e5f0: bd80         	pop	{r7, pc}

0801e5f2 <k_uptime_ticks>:
; {
 801e5f2: b580         	push	{r7, lr}
 801e5f4: af00         	add	r7, sp, #0x0
; 	return z_impl_k_uptime_ticks();
 801e5f6: f00a fbf0    	bl	0x8028dda <z_impl_k_uptime_ticks> @ imm = #0xa7e0
 801e5fa: 4602         	mov	r2, r0
 801e5fc: 460b         	mov	r3, r1
; }
 801e5fe: 4610         	mov	r0, r2
 801e600: 4619         	mov	r1, r3
 801e602: bd80         	pop	{r7, pc}

0801e604 <k_mutex_init>:
; {
 801e604: b580         	push	{r7, lr}
 801e606: b082         	sub	sp, #0x8
 801e608: af00         	add	r7, sp, #0x0
 801e60a: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_init(mutex);
 801e60c: 6878         	ldr	r0, [r7, #0x4]
 801e60e: f008 fcea    	bl	0x8026fe6 <z_impl_k_mutex_init> @ imm = #0x89d4
 801e612: 4603         	mov	r3, r0
; }
 801e614: 4618         	mov	r0, r3
 801e616: 3708         	adds	r7, #0x8
 801e618: 46bd         	mov	sp, r7
 801e61a: bd80         	pop	{r7, pc}

0801e61c <k_mutex_lock>:
; {
 801e61c: b580         	push	{r7, lr}
 801e61e: b084         	sub	sp, #0x10
 801e620: af00         	add	r7, sp, #0x0
 801e622: 60f8         	str	r0, [r7, #0xc]
 801e624: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_mutex_lock(mutex, timeout);
 801e628: e9d7 2300    	ldrd	r2, r3, [r7]
 801e62c: 68f8         	ldr	r0, [r7, #0xc]
 801e62e: f7f6 fc49    	bl	0x8014ec4 <z_impl_k_mutex_lock> @ imm = #-0x976e
 801e632: 4603         	mov	r3, r0
; }
 801e634: 4618         	mov	r0, r3
 801e636: 3710         	adds	r7, #0x10
 801e638: 46bd         	mov	sp, r7
 801e63a: bd80         	pop	{r7, pc}

0801e63c <k_mutex_unlock>:
; {
 801e63c: b580         	push	{r7, lr}
 801e63e: b082         	sub	sp, #0x8
 801e640: af00         	add	r7, sp, #0x0
 801e642: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_unlock(mutex);
 801e644: 6878         	ldr	r0, [r7, #0x4]
 801e646: f7f6 fe87    	bl	0x8015358 <z_impl_k_mutex_unlock> @ imm = #-0x92f2
 801e64a: 4603         	mov	r3, r0
; }
 801e64c: 4618         	mov	r0, r3
 801e64e: 3708         	adds	r7, #0x8
 801e650: 46bd         	mov	sp, r7
 801e652: bd80         	pop	{r7, pc}

0801e654 <k_sem_init>:
; {
 801e654: b580         	push	{r7, lr}
 801e656: b084         	sub	sp, #0x10
 801e658: af00         	add	r7, sp, #0x0
 801e65a: 60f8         	str	r0, [r7, #0xc]
 801e65c: 60b9         	str	r1, [r7, #0x8]
 801e65e: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 801e660: 687a         	ldr	r2, [r7, #0x4]
 801e662: 68b9         	ldr	r1, [r7, #0x8]
 801e664: 68f8         	ldr	r0, [r7, #0xc]
 801e666: f009 f858    	bl	0x802771a <z_impl_k_sem_init> @ imm = #0x90b0
 801e66a: 4603         	mov	r3, r0
; }
 801e66c: 4618         	mov	r0, r3
 801e66e: 3710         	adds	r7, #0x10
 801e670: 46bd         	mov	sp, r7
 801e672: bd80         	pop	{r7, pc}

0801e674 <k_sem_take>:
; {
 801e674: b580         	push	{r7, lr}
 801e676: b084         	sub	sp, #0x10
 801e678: af00         	add	r7, sp, #0x0
 801e67a: 60f8         	str	r0, [r7, #0xc]
 801e67c: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 801e680: e9d7 2300    	ldrd	r2, r3, [r7]
 801e684: 68f8         	ldr	r0, [r7, #0xc]
 801e686: f7f7 f875    	bl	0x8015774 <z_impl_k_sem_take> @ imm = #-0x8f16
 801e68a: 4603         	mov	r3, r0
; }
 801e68c: 4618         	mov	r0, r3
 801e68e: 3710         	adds	r7, #0x10
 801e690: 46bd         	mov	sp, r7
 801e692: bd80         	pop	{r7, pc}

0801e694 <k_sem_give>:
; {
 801e694: b580         	push	{r7, lr}
 801e696: b082         	sub	sp, #0x8
 801e698: af00         	add	r7, sp, #0x0
 801e69a: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801e69c: 6878         	ldr	r0, [r7, #0x4]
 801e69e: f7f6 ffdb    	bl	0x8015658 <z_impl_k_sem_give> @ imm = #-0x904a
; }
 801e6a2: bf00         	nop
 801e6a4: 3708         	adds	r7, #0x8
 801e6a6: 46bd         	mov	sp, r7
 801e6a8: bd80         	pop	{r7, pc}

0801e6aa <can_calc_timing>:
; {
 801e6aa: b580         	push	{r7, lr}
 801e6ac: b084         	sub	sp, #0x10
 801e6ae: af00         	add	r7, sp, #0x0
 801e6b0: 60f8         	str	r0, [r7, #0xc]
 801e6b2: 60b9         	str	r1, [r7, #0x8]
 801e6b4: 607a         	str	r2, [r7, #0x4]
 801e6b6: 807b         	strh	r3, [r7, #0x2]
; 	return z_impl_can_calc_timing(dev, res, bitrate, sample_pnt);
 801e6b8: 887b         	ldrh	r3, [r7, #0x2]
 801e6ba: 687a         	ldr	r2, [r7, #0x4]
 801e6bc: 68b9         	ldr	r1, [r7, #0x8]
 801e6be: 68f8         	ldr	r0, [r7, #0xc]
 801e6c0: f7e9 fa60    	bl	0x8007b84 <z_impl_can_calc_timing> @ imm = #-0x16b40
 801e6c4: 4603         	mov	r3, r0
; }
 801e6c6: 4618         	mov	r0, r3
 801e6c8: 3710         	adds	r7, #0x10
 801e6ca: 46bd         	mov	sp, r7
 801e6cc: bd80         	pop	{r7, pc}

0801e6ce <can_set_timing>:
; {
 801e6ce: b580         	push	{r7, lr}
 801e6d0: b082         	sub	sp, #0x8
 801e6d2: af00         	add	r7, sp, #0x0
 801e6d4: 6078         	str	r0, [r7, #0x4]
 801e6d6: 6039         	str	r1, [r7]
; 	return z_impl_can_set_timing(dev, timing);
 801e6d8: 6839         	ldr	r1, [r7]
 801e6da: 6878         	ldr	r0, [r7, #0x4]
 801e6dc: f7ff ff4a    	bl	0x801e574 <z_impl_can_set_timing> @ imm = #-0x16c
 801e6e0: 4603         	mov	r3, r0
; }
 801e6e2: 4618         	mov	r0, r3
 801e6e4: 3708         	adds	r7, #0x8
 801e6e6: 46bd         	mov	sp, r7
 801e6e8: bd80         	pop	{r7, pc}

0801e6ea <can_mcan_read_mram>:
; {
 801e6ea: b590         	push	{r4, r7, lr}
 801e6ec: b087         	sub	sp, #0x1c
 801e6ee: af00         	add	r7, sp, #0x0
 801e6f0: 60f8         	str	r0, [r7, #0xc]
 801e6f2: 607a         	str	r2, [r7, #0x4]
 801e6f4: 603b         	str	r3, [r7]
 801e6f6: 460b         	mov	r3, r1
 801e6f8: 817b         	strh	r3, [r7, #0xa]
; 	const struct can_mcan_config *config = dev->config;
 801e6fa: 68fb         	ldr	r3, [r7, #0xc]
 801e6fc: 685b         	ldr	r3, [r3, #0x4]
 801e6fe: 617b         	str	r3, [r7, #0x14]
; 	return config->ops->read_mram(dev, offset, dst, len);
 801e700: 697b         	ldr	r3, [r7, #0x14]
 801e702: 695b         	ldr	r3, [r3, #0x14]
 801e704: 689c         	ldr	r4, [r3, #0x8]
 801e706: 8979         	ldrh	r1, [r7, #0xa]
 801e708: 683b         	ldr	r3, [r7]
 801e70a: 687a         	ldr	r2, [r7, #0x4]
 801e70c: 68f8         	ldr	r0, [r7, #0xc]
 801e70e: 47a0         	blx	r4
 801e710: 4603         	mov	r3, r0
; }
 801e712: 4618         	mov	r0, r3
 801e714: 371c         	adds	r7, #0x1c
 801e716: 46bd         	mov	sp, r7
 801e718: bd90         	pop	{r4, r7, pc}

0801e71a <can_mcan_write_mram>:
; {
 801e71a: b590         	push	{r4, r7, lr}
 801e71c: b087         	sub	sp, #0x1c
 801e71e: af00         	add	r7, sp, #0x0
 801e720: 60f8         	str	r0, [r7, #0xc]
 801e722: 607a         	str	r2, [r7, #0x4]
 801e724: 603b         	str	r3, [r7]
 801e726: 460b         	mov	r3, r1
 801e728: 817b         	strh	r3, [r7, #0xa]
; 	const struct can_mcan_config *config = dev->config;
 801e72a: 68fb         	ldr	r3, [r7, #0xc]
 801e72c: 685b         	ldr	r3, [r3, #0x4]
 801e72e: 617b         	str	r3, [r7, #0x14]
; 	return config->ops->write_mram(dev, offset, src, len);
 801e730: 697b         	ldr	r3, [r7, #0x14]
 801e732: 695b         	ldr	r3, [r3, #0x14]
 801e734: 68dc         	ldr	r4, [r3, #0xc]
 801e736: 8979         	ldrh	r1, [r7, #0xa]
 801e738: 683b         	ldr	r3, [r7]
 801e73a: 687a         	ldr	r2, [r7, #0x4]
 801e73c: 68f8         	ldr	r0, [r7, #0xc]
 801e73e: 47a0         	blx	r4
 801e740: 4603         	mov	r3, r0
; }
 801e742: 4618         	mov	r0, r3
 801e744: 371c         	adds	r7, #0x1c
 801e746: 46bd         	mov	sp, r7
 801e748: bd90         	pop	{r4, r7, pc}

0801e74a <can_mcan_clear_mram>:
; {
 801e74a: b580         	push	{r7, lr}
 801e74c: b086         	sub	sp, #0x18
 801e74e: af00         	add	r7, sp, #0x0
 801e750: 60f8         	str	r0, [r7, #0xc]
 801e752: 460b         	mov	r3, r1
 801e754: 607a         	str	r2, [r7, #0x4]
 801e756: 817b         	strh	r3, [r7, #0xa]
; 	const struct can_mcan_config *config = dev->config;
 801e758: 68fb         	ldr	r3, [r7, #0xc]
 801e75a: 685b         	ldr	r3, [r3, #0x4]
 801e75c: 617b         	str	r3, [r7, #0x14]
; 	return config->ops->clear_mram(dev, offset, len);
 801e75e: 697b         	ldr	r3, [r7, #0x14]
 801e760: 695b         	ldr	r3, [r3, #0x14]
 801e762: 691b         	ldr	r3, [r3, #0x10]
 801e764: 8979         	ldrh	r1, [r7, #0xa]
 801e766: 687a         	ldr	r2, [r7, #0x4]
 801e768: 68f8         	ldr	r0, [r7, #0xc]
 801e76a: 4798         	blx	r3
 801e76c: 4603         	mov	r3, r0
; }
 801e76e: 4618         	mov	r0, r3
 801e770: 3718         	adds	r7, #0x18
 801e772: 46bd         	mov	sp, r7
 801e774: bd80         	pop	{r7, pc}

0801e776 <can_transceiver_enable>:
; {
 801e776: b580         	push	{r7, lr}
 801e778: b082         	sub	sp, #0x8
 801e77a: af00         	add	r7, sp, #0x0
 801e77c: 6078         	str	r0, [r7, #0x4]
 801e77e: 6039         	str	r1, [r7]
; 	return DEVICE_API_GET(can_transceiver, dev)->enable(dev, mode);
 801e780: 687b         	ldr	r3, [r7, #0x4]
 801e782: 689b         	ldr	r3, [r3, #0x8]
 801e784: 681b         	ldr	r3, [r3]
 801e786: 6839         	ldr	r1, [r7]
 801e788: 6878         	ldr	r0, [r7, #0x4]
 801e78a: 4798         	blx	r3
 801e78c: 4603         	mov	r3, r0
; }
 801e78e: 4618         	mov	r0, r3
 801e790: 3708         	adds	r7, #0x8
 801e792: 46bd         	mov	sp, r7
 801e794: bd80         	pop	{r7, pc}

0801e796 <can_transceiver_disable>:
; {
 801e796: b580         	push	{r7, lr}
 801e798: b082         	sub	sp, #0x8
 801e79a: af00         	add	r7, sp, #0x0
 801e79c: 6078         	str	r0, [r7, #0x4]
; 	return DEVICE_API_GET(can_transceiver, dev)->disable(dev);
 801e79e: 687b         	ldr	r3, [r7, #0x4]
 801e7a0: 689b         	ldr	r3, [r3, #0x8]
 801e7a2: 685b         	ldr	r3, [r3, #0x4]
 801e7a4: 6878         	ldr	r0, [r7, #0x4]
 801e7a6: 4798         	blx	r3
 801e7a8: 4603         	mov	r3, r0
; }
 801e7aa: 4618         	mov	r0, r3
 801e7ac: 3708         	adds	r7, #0x8
 801e7ae: 46bd         	mov	sp, r7
 801e7b0: bd80         	pop	{r7, pc}

0801e7b2 <z_log_msg_runtime_create>:
; {
 801e7b2: b580         	push	{r7, lr}
 801e7b4: b08a         	sub	sp, #0x28
 801e7b6: af04         	add	r7, sp, #0x10
 801e7b8: 60b9         	str	r1, [r7, #0x8]
 801e7ba: 607b         	str	r3, [r7, #0x4]
 801e7bc: 4603         	mov	r3, r0
 801e7be: 73fb         	strb	r3, [r7, #0xf]
 801e7c0: 4613         	mov	r3, r2
 801e7c2: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801e7c4: f107 032c    	add.w	r3, r7, #0x2c
 801e7c8: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801e7ca: 7bba         	ldrb	r2, [r7, #0xe]
 801e7cc: 7bf8         	ldrb	r0, [r7, #0xf]
 801e7ce: 697b         	ldr	r3, [r7, #0x14]
 801e7d0: 9303         	str	r3, [sp, #0xc]
 801e7d2: 6abb         	ldr	r3, [r7, #0x28]
 801e7d4: 9302         	str	r3, [sp, #0x8]
 801e7d6: 6a7b         	ldr	r3, [r7, #0x24]
 801e7d8: 9301         	str	r3, [sp, #0x4]
 801e7da: 6a3b         	ldr	r3, [r7, #0x20]
 801e7dc: 9300         	str	r3, [sp]
 801e7de: 687b         	ldr	r3, [r7, #0x4]
 801e7e0: 68b9         	ldr	r1, [r7, #0x8]
 801e7e2: f7e6 f9c7    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x19c72
; }
 801e7e6: bf00         	nop
 801e7e8: 3718         	adds	r7, #0x18
 801e7ea: 46bd         	mov	sp, r7
 801e7ec: bd80         	pop	{r7, pc}

0801e7ee <can_mcan_enter_init_mode>:
; {
 801e7ee: b5b0         	push	{r4, r5, r7, lr}
 801e7f0: b08a         	sub	sp, #0x28
 801e7f2: af00         	add	r7, sp, #0x0
 801e7f4: 60f8         	str	r0, [r7, #0xc]
 801e7f6: e9c7 2300    	strd	r2, r3, [r7]
; 	struct can_mcan_data *data = dev->data;
 801e7fa: 68fb         	ldr	r3, [r7, #0xc]
 801e7fc: 691b         	ldr	r3, [r3, #0x10]
 801e7fe: 623b         	str	r3, [r7, #0x20]
; 	k_mutex_lock(&data->lock, K_FOREVER);
 801e800: 6a3b         	ldr	r3, [r7, #0x20]
 801e802: f103 0110    	add.w	r1, r3, #0x10
 801e806: f04f 32ff    	mov.w	r2, #0xffffffff
 801e80a: f04f 33ff    	mov.w	r3, #0xffffffff
 801e80e: 4608         	mov	r0, r1
 801e810: f7ff ff04    	bl	0x801e61c <k_mutex_lock> @ imm = #-0x1f8
; 	err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &cccr);
 801e814: f107 0314    	add.w	r3, r7, #0x14
 801e818: 461a         	mov	r2, r3
 801e81a: 2118         	movs	r1, #0x18
 801e81c: 68f8         	ldr	r0, [r7, #0xc]
 801e81e: f7e9 f9ef    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x16c22
 801e822: 6278         	str	r0, [r7, #0x24]
; 	if (err != 0) {
 801e824: 6a7b         	ldr	r3, [r7, #0x24]
 801e826: 2b00         	cmp	r3, #0x0
 801e828: d14c         	bne	0x801e8c4 <can_mcan_enter_init_mode+0xd6> @ imm = #0x98
; 	cccr |= CAN_MCAN_CCCR_INIT;
 801e82a: 697b         	ldr	r3, [r7, #0x14]
 801e82c: f043 0301    	orr	r3, r3, #0x1
 801e830: 617b         	str	r3, [r7, #0x14]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_CCCR, cccr);
 801e832: 697b         	ldr	r3, [r7, #0x14]
 801e834: 461a         	mov	r2, r3
 801e836: 2118         	movs	r1, #0x18
 801e838: 68f8         	ldr	r0, [r7, #0xc]
 801e83a: f7e9 fa1d    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x16bc6
 801e83e: 6278         	str	r0, [r7, #0x24]
; 	if (err != 0) {
 801e840: 6a7b         	ldr	r3, [r7, #0x24]
 801e842: 2b00         	cmp	r3, #0x0
 801e844: d140         	bne	0x801e8c8 <can_mcan_enter_init_mode+0xda> @ imm = #0x80
; 	start_time = k_uptime_ticks();
 801e846: f7ff fed4    	bl	0x801e5f2 <k_uptime_ticks> @ imm = #-0x258
 801e84a: e9c7 0106    	strd	r0, r1, [r7, #24]
; 	err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &cccr);
 801e84e: f107 0314    	add.w	r3, r7, #0x14
 801e852: 461a         	mov	r2, r3
 801e854: 2118         	movs	r1, #0x18
 801e856: 68f8         	ldr	r0, [r7, #0xc]
 801e858: f7e9 f9d2    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x16c5c
 801e85c: 6278         	str	r0, [r7, #0x24]
; 	if (err != 0) {
 801e85e: 6a7b         	ldr	r3, [r7, #0x24]
 801e860: 2b00         	cmp	r3, #0x0
 801e862: d133         	bne	0x801e8cc <can_mcan_enter_init_mode+0xde> @ imm = #0x66
; 	while ((cccr & CAN_MCAN_CCCR_INIT) == 0U) {
 801e864: e028         	b	0x801e8b8 <can_mcan_enter_init_mode+0xca> @ imm = #0x50
; 		if (k_uptime_ticks() - start_time > timeout.ticks) {
 801e866: f7ff fec4    	bl	0x801e5f2 <k_uptime_ticks> @ imm = #-0x278
 801e86a: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 801e86e: 1a84         	subs	r4, r0, r2
 801e870: eb61 0503    	sbc.w	r5, r1, r3
 801e874: e9d7 2300    	ldrd	r2, r3, [r7]
 801e878: 42a2         	cmp	r2, r4
 801e87a: 41ab         	sbcs	r3, r5
 801e87c: da11         	bge	0x801e8a2 <can_mcan_enter_init_mode+0xb4> @ imm = #0x22
; 			cccr &= ~CAN_MCAN_CCCR_INIT;
 801e87e: 697b         	ldr	r3, [r7, #0x14]
 801e880: f023 0301    	bic	r3, r3, #0x1
 801e884: 617b         	str	r3, [r7, #0x14]
; 			err = can_mcan_write_reg(dev, CAN_MCAN_CCCR, cccr);
 801e886: 697b         	ldr	r3, [r7, #0x14]
 801e888: 461a         	mov	r2, r3
 801e88a: 2118         	movs	r1, #0x18
 801e88c: 68f8         	ldr	r0, [r7, #0xc]
 801e88e: f7e9 f9f3    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x16c1a
 801e892: 6278         	str	r0, [r7, #0x24]
; 			if (err != 0) {
 801e894: 6a7b         	ldr	r3, [r7, #0x24]
 801e896: 2b00         	cmp	r3, #0x0
 801e898: d11a         	bne	0x801e8d0 <can_mcan_enter_init_mode+0xe2> @ imm = #0x34
; 			err = -EAGAIN;
 801e89a: f06f 030a    	mvn	r3, #0xa
 801e89e: 627b         	str	r3, [r7, #0x24]
; 			goto unlock;
 801e8a0: e019         	b	0x801e8d6 <can_mcan_enter_init_mode+0xe8> @ imm = #0x32
; 		err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &cccr);
 801e8a2: f107 0314    	add.w	r3, r7, #0x14
 801e8a6: 461a         	mov	r2, r3
 801e8a8: 2118         	movs	r1, #0x18
 801e8aa: 68f8         	ldr	r0, [r7, #0xc]
 801e8ac: f7e9 f9a8    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x16cb0
 801e8b0: 6278         	str	r0, [r7, #0x24]
; 		if (err != 0) {
 801e8b2: 6a7b         	ldr	r3, [r7, #0x24]
 801e8b4: 2b00         	cmp	r3, #0x0
 801e8b6: d10d         	bne	0x801e8d4 <can_mcan_enter_init_mode+0xe6> @ imm = #0x1a
; 	while ((cccr & CAN_MCAN_CCCR_INIT) == 0U) {
 801e8b8: 697b         	ldr	r3, [r7, #0x14]
 801e8ba: f003 0301    	and	r3, r3, #0x1
 801e8be: 2b00         	cmp	r3, #0x0
 801e8c0: d0d1         	beq	0x801e866 <can_mcan_enter_init_mode+0x78> @ imm = #-0x5e
; unlock:
 801e8c2: e008         	b	0x801e8d6 <can_mcan_enter_init_mode+0xe8> @ imm = #0x10
; 		goto unlock;
 801e8c4: bf00         	nop
 801e8c6: e006         	b	0x801e8d6 <can_mcan_enter_init_mode+0xe8> @ imm = #0xc
; 		goto unlock;
 801e8c8: bf00         	nop
 801e8ca: e004         	b	0x801e8d6 <can_mcan_enter_init_mode+0xe8> @ imm = #0x8
; 		goto unlock;
 801e8cc: bf00         	nop
 801e8ce: e002         	b	0x801e8d6 <can_mcan_enter_init_mode+0xe8> @ imm = #0x4
; 				goto unlock;
 801e8d0: bf00         	nop
 801e8d2: e000         	b	0x801e8d6 <can_mcan_enter_init_mode+0xe8> @ imm = #0x0
; 			goto unlock;
 801e8d4: bf00         	nop
; 	k_mutex_unlock(&data->lock);
 801e8d6: 6a3b         	ldr	r3, [r7, #0x20]
 801e8d8: 3310         	adds	r3, #0x10
 801e8da: 4618         	mov	r0, r3
 801e8dc: f7ff feae    	bl	0x801e63c <k_mutex_unlock> @ imm = #-0x2a4
; 	return err;
 801e8e0: 6a79         	ldr	r1, [r7, #0x24]
 801e8e2: 460b         	mov	r3, r1
; }
 801e8e4: 4618         	mov	r0, r3
 801e8e6: 3728         	adds	r7, #0x28
 801e8e8: 46bd         	mov	sp, r7
 801e8ea: bdb0         	pop	{r4, r5, r7, pc}

0801e8ec <can_mcan_leave_init_mode>:
; {
 801e8ec: b5b0         	push	{r4, r5, r7, lr}
 801e8ee: b08a         	sub	sp, #0x28
 801e8f0: af00         	add	r7, sp, #0x0
 801e8f2: 60f8         	str	r0, [r7, #0xc]
 801e8f4: e9c7 2300    	strd	r2, r3, [r7]
; 	struct can_mcan_data *data = dev->data;
 801e8f8: 68fb         	ldr	r3, [r7, #0xc]
 801e8fa: 691b         	ldr	r3, [r3, #0x10]
 801e8fc: 623b         	str	r3, [r7, #0x20]
; 	k_mutex_lock(&data->lock, K_FOREVER);
 801e8fe: 6a3b         	ldr	r3, [r7, #0x20]
 801e900: f103 0110    	add.w	r1, r3, #0x10
 801e904: f04f 32ff    	mov.w	r2, #0xffffffff
 801e908: f04f 33ff    	mov.w	r3, #0xffffffff
 801e90c: 4608         	mov	r0, r1
 801e90e: f7ff fe85    	bl	0x801e61c <k_mutex_lock> @ imm = #-0x2f6
; 	err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &cccr);
 801e912: f107 0314    	add.w	r3, r7, #0x14
 801e916: 461a         	mov	r2, r3
 801e918: 2118         	movs	r1, #0x18
 801e91a: 68f8         	ldr	r0, [r7, #0xc]
 801e91c: f7e9 f970    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x16d20
 801e920: 6278         	str	r0, [r7, #0x24]
; 	if (err != 0) {
 801e922: 6a7b         	ldr	r3, [r7, #0x24]
 801e924: 2b00         	cmp	r3, #0x0
 801e926: d13e         	bne	0x801e9a6 <can_mcan_leave_init_mode+0xba> @ imm = #0x7c
; 	cccr &= ~CAN_MCAN_CCCR_INIT;
 801e928: 697b         	ldr	r3, [r7, #0x14]
 801e92a: f023 0301    	bic	r3, r3, #0x1
 801e92e: 617b         	str	r3, [r7, #0x14]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_CCCR, cccr);
 801e930: 697b         	ldr	r3, [r7, #0x14]
 801e932: 461a         	mov	r2, r3
 801e934: 2118         	movs	r1, #0x18
 801e936: 68f8         	ldr	r0, [r7, #0xc]
 801e938: f7e9 f99e    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x16cc4
 801e93c: 6278         	str	r0, [r7, #0x24]
; 	if (err != 0) {
 801e93e: 6a7b         	ldr	r3, [r7, #0x24]
 801e940: 2b00         	cmp	r3, #0x0
 801e942: d132         	bne	0x801e9aa <can_mcan_leave_init_mode+0xbe> @ imm = #0x64
; 	start_time = k_uptime_ticks();
 801e944: f7ff fe55    	bl	0x801e5f2 <k_uptime_ticks> @ imm = #-0x356
 801e948: e9c7 0106    	strd	r0, r1, [r7, #24]
; 	err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &cccr);
 801e94c: f107 0314    	add.w	r3, r7, #0x14
 801e950: 461a         	mov	r2, r3
 801e952: 2118         	movs	r1, #0x18
 801e954: 68f8         	ldr	r0, [r7, #0xc]
 801e956: f7e9 f953    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x16d5a
 801e95a: 6278         	str	r0, [r7, #0x24]
; 	if (err != 0) {
 801e95c: 6a7b         	ldr	r3, [r7, #0x24]
 801e95e: 2b00         	cmp	r3, #0x0
 801e960: d125         	bne	0x801e9ae <can_mcan_leave_init_mode+0xc2> @ imm = #0x4a
; 	while ((cccr & CAN_MCAN_CCCR_INIT) != 0U) {
 801e962: e01a         	b	0x801e99a <can_mcan_leave_init_mode+0xae> @ imm = #0x34
; 		if (k_uptime_ticks() - start_time > timeout.ticks) {
 801e964: f7ff fe45    	bl	0x801e5f2 <k_uptime_ticks> @ imm = #-0x376
 801e968: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 801e96c: 1a84         	subs	r4, r0, r2
 801e96e: eb61 0503    	sbc.w	r5, r1, r3
 801e972: e9d7 2300    	ldrd	r2, r3, [r7]
 801e976: 42a2         	cmp	r2, r4
 801e978: 41ab         	sbcs	r3, r5
 801e97a: da03         	bge	0x801e984 <can_mcan_leave_init_mode+0x98> @ imm = #0x6
; 			err = -EAGAIN;
 801e97c: f06f 030a    	mvn	r3, #0xa
 801e980: 627b         	str	r3, [r7, #0x24]
; 			goto unlock;
 801e982: e017         	b	0x801e9b4 <can_mcan_leave_init_mode+0xc8> @ imm = #0x2e
; 		err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &cccr);
 801e984: f107 0314    	add.w	r3, r7, #0x14
 801e988: 461a         	mov	r2, r3
 801e98a: 2118         	movs	r1, #0x18
 801e98c: 68f8         	ldr	r0, [r7, #0xc]
 801e98e: f7e9 f937    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x16d92
 801e992: 6278         	str	r0, [r7, #0x24]
; 		if (err != 0) {
 801e994: 6a7b         	ldr	r3, [r7, #0x24]
 801e996: 2b00         	cmp	r3, #0x0
 801e998: d10b         	bne	0x801e9b2 <can_mcan_leave_init_mode+0xc6> @ imm = #0x16
; 	while ((cccr & CAN_MCAN_CCCR_INIT) != 0U) {
 801e99a: 697b         	ldr	r3, [r7, #0x14]
 801e99c: f003 0301    	and	r3, r3, #0x1
 801e9a0: 2b00         	cmp	r3, #0x0
 801e9a2: d1df         	bne	0x801e964 <can_mcan_leave_init_mode+0x78> @ imm = #-0x42
; unlock:
 801e9a4: e006         	b	0x801e9b4 <can_mcan_leave_init_mode+0xc8> @ imm = #0xc
; 		goto unlock;
 801e9a6: bf00         	nop
 801e9a8: e004         	b	0x801e9b4 <can_mcan_leave_init_mode+0xc8> @ imm = #0x8
; 		goto unlock;
 801e9aa: bf00         	nop
 801e9ac: e002         	b	0x801e9b4 <can_mcan_leave_init_mode+0xc8> @ imm = #0x4
; 		goto unlock;
 801e9ae: bf00         	nop
 801e9b0: e000         	b	0x801e9b4 <can_mcan_leave_init_mode+0xc8> @ imm = #0x0
; 			goto unlock;
 801e9b2: bf00         	nop
; 	k_mutex_unlock(&data->lock);
 801e9b4: 6a3b         	ldr	r3, [r7, #0x20]
 801e9b6: 3310         	adds	r3, #0x10
 801e9b8: 4618         	mov	r0, r3
 801e9ba: f7ff fe3f    	bl	0x801e63c <k_mutex_unlock> @ imm = #-0x382
; 	return err;
 801e9be: 6a79         	ldr	r1, [r7, #0x24]
 801e9c0: 460b         	mov	r3, r1
; }
 801e9c2: 4618         	mov	r0, r3
 801e9c4: 3728         	adds	r7, #0x28
 801e9c6: 46bd         	mov	sp, r7
 801e9c8: bdb0         	pop	{r4, r5, r7, pc}

0801e9ca <can_mcan_get_capabilities>:
; {
 801e9ca: b480         	push	{r7}
 801e9cc: b083         	sub	sp, #0xc
 801e9ce: af00         	add	r7, sp, #0x0
 801e9d0: 6078         	str	r0, [r7, #0x4]
 801e9d2: 6039         	str	r1, [r7]
; 	*cap = CAN_MODE_NORMAL | CAN_MODE_LOOPBACK | CAN_MODE_LISTENONLY;
 801e9d4: 683b         	ldr	r3, [r7]
 801e9d6: 2203         	movs	r2, #0x3
 801e9d8: 601a         	str	r2, [r3]
; 	return 0;
 801e9da: 2300         	movs	r3, #0x0
; }
 801e9dc: 4618         	mov	r0, r3
 801e9de: 370c         	adds	r7, #0xc
 801e9e0: 46bd         	mov	sp, r7
 801e9e2: f85d 7b04    	ldr	r7, [sp], #4
 801e9e6: 4770         	bx	lr

0801e9e8 <can_mcan_state_change_handler>:
; {
 801e9e8: b590         	push	{r4, r7, lr}
 801e9ea: b08f         	sub	sp, #0x3c
 801e9ec: af00         	add	r7, sp, #0x0
 801e9ee: 6078         	str	r0, [r7, #0x4]
; 	const struct can_mcan_config *config = dev->config;
 801e9f0: 687b         	ldr	r3, [r7, #0x4]
 801e9f2: 685b         	ldr	r3, [r3, #0x4]
 801e9f4: 633b         	str	r3, [r7, #0x30]
; 	struct can_mcan_data *data = dev->data;
 801e9f6: 687b         	ldr	r3, [r7, #0x4]
 801e9f8: 691b         	ldr	r3, [r3, #0x10]
 801e9fa: 62fb         	str	r3, [r7, #0x2c]
; 	const can_state_change_callback_t state_cb = data->common.state_change_cb;
 801e9fc: 6afb         	ldr	r3, [r7, #0x2c]
 801e9fe: 689b         	ldr	r3, [r3, #0x8]
 801ea00: 62bb         	str	r3, [r7, #0x28]
; 	void *state_cb_data = data->common.state_change_cb_user_data;
 801ea02: 6afb         	ldr	r3, [r7, #0x2c]
 801ea04: 68db         	ldr	r3, [r3, #0xc]
 801ea06: 627b         	str	r3, [r7, #0x24]
; 	const struct can_mcan_callbacks *cbs = config->callbacks;
 801ea08: 6b3b         	ldr	r3, [r7, #0x30]
 801ea0a: 699b         	ldr	r3, [r3, #0x18]
 801ea0c: 623b         	str	r3, [r7, #0x20]
; 	err = can_mcan_get_state(dev, &state, &err_cnt);
 801ea0e: f107 0214    	add.w	r2, r7, #0x14
 801ea12: f107 0313    	add.w	r3, r7, #0x13
 801ea16: 4619         	mov	r1, r3
 801ea18: 6878         	ldr	r0, [r7, #0x4]
 801ea1a: f000 f87d    	bl	0x801eb18 <can_mcan_get_state> @ imm = #0xfa
 801ea1e: 61f8         	str	r0, [r7, #0x1c]
; 	if (err != 0) {
 801ea20: 69fb         	ldr	r3, [r7, #0x1c]
 801ea22: 2b00         	cmp	r3, #0x0
 801ea24: d15b         	bne	0x801eade <can_mcan_state_change_handler+0xf6> @ imm = #0xb6
; 	if (state_cb != NULL) {
 801ea26: 6abb         	ldr	r3, [r7, #0x28]
 801ea28: 2b00         	cmp	r3, #0x0
 801ea2a: d005         	beq	0x801ea38 <can_mcan_state_change_handler+0x50> @ imm = #0xa
; 		state_cb(dev, state, err_cnt, state_cb_data);
 801ea2c: 7cf9         	ldrb	r1, [r7, #0x13]
 801ea2e: 6abc         	ldr	r4, [r7, #0x28]
 801ea30: 6a7b         	ldr	r3, [r7, #0x24]
 801ea32: 697a         	ldr	r2, [r7, #0x14]
 801ea34: 6878         	ldr	r0, [r7, #0x4]
 801ea36: 47a0         	blx	r4
; 	if (state == CAN_STATE_BUS_OFF) {
 801ea38: 7cfb         	ldrb	r3, [r7, #0x13]
 801ea3a: 2b03         	cmp	r3, #0x3
 801ea3c: d154         	bne	0x801eae8 <can_mcan_state_change_handler+0x100> @ imm = #0xa8
; 		err = can_mcan_write_reg(dev, CAN_MCAN_TXBCR, CAN_MCAN_TXBCR_CR);
 801ea3e: f04f 32ff    	mov.w	r2, #0xffffffff
 801ea42: 21d4         	movs	r1, #0xd4
 801ea44: 6878         	ldr	r0, [r7, #0x4]
 801ea46: f7e9 f917    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x16dd2
 801ea4a: 61f8         	str	r0, [r7, #0x1c]
; 		if (err != 0) {
 801ea4c: 69fb         	ldr	r3, [r7, #0x1c]
 801ea4e: 2b00         	cmp	r3, #0x0
 801ea50: d147         	bne	0x801eae2 <can_mcan_state_change_handler+0xfa> @ imm = #0x8e
; 		for (tx_idx = 0U; tx_idx < cbs->num_tx; tx_idx++) {
 801ea52: 2300         	movs	r3, #0x0
 801ea54: 637b         	str	r3, [r7, #0x34]
 801ea56: e023         	b	0x801eaa0 <can_mcan_state_change_handler+0xb8> @ imm = #0x46
; 			tx_cb = cbs->tx[tx_idx].function;
 801ea58: 6a3b         	ldr	r3, [r7, #0x20]
 801ea5a: 681a         	ldr	r2, [r3]
 801ea5c: 6b7b         	ldr	r3, [r7, #0x34]
 801ea5e: 00db         	lsls	r3, r3, #0x3
 801ea60: 4413         	add	r3, r2
 801ea62: 681b         	ldr	r3, [r3]
 801ea64: 61bb         	str	r3, [r7, #0x18]
; 			if (tx_cb != NULL) {
 801ea66: 69bb         	ldr	r3, [r7, #0x18]
 801ea68: 2b00         	cmp	r3, #0x0
 801ea6a: d016         	beq	0x801ea9a <can_mcan_state_change_handler+0xb2> @ imm = #0x2c
; 				cbs->tx[tx_idx].function = NULL;
 801ea6c: 6a3b         	ldr	r3, [r7, #0x20]
 801ea6e: 681a         	ldr	r2, [r3]
 801ea70: 6b7b         	ldr	r3, [r7, #0x34]
 801ea72: 00db         	lsls	r3, r3, #0x3
 801ea74: 4413         	add	r3, r2
 801ea76: 2200         	movs	r2, #0x0
 801ea78: 601a         	str	r2, [r3]
; 				tx_cb(dev, -ENETUNREACH, cbs->tx[tx_idx].user_data);
 801ea7a: 6a3b         	ldr	r3, [r7, #0x20]
 801ea7c: 681a         	ldr	r2, [r3]
 801ea7e: 6b7b         	ldr	r3, [r7, #0x34]
 801ea80: 00db         	lsls	r3, r3, #0x3
 801ea82: 4413         	add	r3, r2
 801ea84: 685a         	ldr	r2, [r3, #0x4]
 801ea86: 69bb         	ldr	r3, [r7, #0x18]
 801ea88: f06f 0171    	mvn	r1, #0x71
 801ea8c: 6878         	ldr	r0, [r7, #0x4]
 801ea8e: 4798         	blx	r3
; 				k_sem_give(&data->tx_sem);
 801ea90: 6afb         	ldr	r3, [r7, #0x2c]
 801ea92: 3324         	adds	r3, #0x24
 801ea94: 4618         	mov	r0, r3
 801ea96: f7ff fdfd    	bl	0x801e694 <k_sem_give>  @ imm = #-0x406
; 		for (tx_idx = 0U; tx_idx < cbs->num_tx; tx_idx++) {
 801ea9a: 6b7b         	ldr	r3, [r7, #0x34]
 801ea9c: 3301         	adds	r3, #0x1
 801ea9e: 637b         	str	r3, [r7, #0x34]
 801eaa0: 6a3b         	ldr	r3, [r7, #0x20]
 801eaa2: 7b1b         	ldrb	r3, [r3, #0xc]
 801eaa4: 461a         	mov	r2, r3
 801eaa6: 6b7b         	ldr	r3, [r7, #0x34]
 801eaa8: 4293         	cmp	r3, r2
 801eaaa: d3d5         	blo	0x801ea58 <can_mcan_state_change_handler+0x70> @ imm = #-0x56
; 			err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &cccr);
 801eaac: f107 030c    	add.w	r3, r7, #0xc
 801eab0: 461a         	mov	r2, r3
 801eab2: 2118         	movs	r1, #0x18
 801eab4: 6878         	ldr	r0, [r7, #0x4]
 801eab6: f7e9 f8a3    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x16eba
 801eaba: 61f8         	str	r0, [r7, #0x1c]
; 			if (err != 0) {
 801eabc: 69fb         	ldr	r3, [r7, #0x1c]
 801eabe: 2b00         	cmp	r3, #0x0
 801eac0: d111         	bne	0x801eae6 <can_mcan_state_change_handler+0xfe> @ imm = #0x22
; 			cccr &= ~CAN_MCAN_CCCR_INIT;
 801eac2: 68fb         	ldr	r3, [r7, #0xc]
 801eac4: f023 0301    	bic	r3, r3, #0x1
 801eac8: 60fb         	str	r3, [r7, #0xc]
; 			err = can_mcan_write_reg(dev, CAN_MCAN_CCCR, cccr);
 801eaca: 68fb         	ldr	r3, [r7, #0xc]
 801eacc: 461a         	mov	r2, r3
 801eace: 2118         	movs	r1, #0x18
 801ead0: 6878         	ldr	r0, [r7, #0x4]
 801ead2: f7e9 f8d1    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x16e5e
 801ead6: 61f8         	str	r0, [r7, #0x1c]
; 			if (err != 0) {
 801ead8: 69fb         	ldr	r3, [r7, #0x1c]
 801eada: 2b00         	cmp	r3, #0x0
 801eadc: e004         	b	0x801eae8 <can_mcan_state_change_handler+0x100> @ imm = #0x8
; 		return;
 801eade: bf00         	nop
 801eae0: e002         	b	0x801eae8 <can_mcan_state_change_handler+0x100> @ imm = #0x4
; 			return;
 801eae2: bf00         	nop
 801eae4: e000         	b	0x801eae8 <can_mcan_state_change_handler+0x100> @ imm = #0x0
; 				return;
 801eae6: bf00         	nop
; }
 801eae8: 373c         	adds	r7, #0x3c
 801eaea: 46bd         	mov	sp, r7
 801eaec: bd90         	pop	{r4, r7, pc}

0801eaee <can_mcan_read_psr>:
; {
 801eaee: b580         	push	{r7, lr}
 801eaf0: b084         	sub	sp, #0x10
 801eaf2: af00         	add	r7, sp, #0x0
 801eaf4: 6078         	str	r0, [r7, #0x4]
 801eaf6: 6039         	str	r1, [r7]
; 	int err = can_mcan_read_reg(dev, CAN_MCAN_PSR, val);
 801eaf8: 683a         	ldr	r2, [r7]
 801eafa: 2144         	movs	r1, #0x44
 801eafc: 6878         	ldr	r0, [r7, #0x4]
 801eafe: f7e9 f87f    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x16f02
 801eb02: 60f8         	str	r0, [r7, #0xc]
; 	if (err != 0) {
 801eb04: 68fb         	ldr	r3, [r7, #0xc]
 801eb06: 2b00         	cmp	r3, #0x0
 801eb08: d001         	beq	0x801eb0e <can_mcan_read_psr+0x20> @ imm = #0x2
; 		return err;
 801eb0a: 68fb         	ldr	r3, [r7, #0xc]
 801eb0c: e000         	b	0x801eb10 <can_mcan_read_psr+0x22> @ imm = #0x0
; 	return 0;
 801eb0e: 2300         	movs	r3, #0x0
; }
 801eb10: 4618         	mov	r0, r3
 801eb12: 3710         	adds	r7, #0x10
 801eb14: 46bd         	mov	sp, r7
 801eb16: bd80         	pop	{r7, pc}

0801eb18 <can_mcan_get_state>:
; {
 801eb18: b580         	push	{r7, lr}
 801eb1a: b088         	sub	sp, #0x20
 801eb1c: af00         	add	r7, sp, #0x0
 801eb1e: 60f8         	str	r0, [r7, #0xc]
 801eb20: 60b9         	str	r1, [r7, #0x8]
 801eb22: 607a         	str	r2, [r7, #0x4]
; 	struct can_mcan_data *data = dev->data;
 801eb24: 68fb         	ldr	r3, [r7, #0xc]
 801eb26: 691b         	ldr	r3, [r3, #0x10]
 801eb28: 61fb         	str	r3, [r7, #0x1c]
; 	if (state != NULL) {
 801eb2a: 68bb         	ldr	r3, [r7, #0x8]
 801eb2c: 2b00         	cmp	r3, #0x0
 801eb2e: d034         	beq	0x801eb9a <can_mcan_get_state+0x82> @ imm = #0x68
; 		err = can_mcan_read_psr(dev, &reg);
 801eb30: f107 0314    	add.w	r3, r7, #0x14
 801eb34: 4619         	mov	r1, r3
 801eb36: 68f8         	ldr	r0, [r7, #0xc]
 801eb38: f7ff ffd9    	bl	0x801eaee <can_mcan_read_psr> @ imm = #-0x4e
 801eb3c: 61b8         	str	r0, [r7, #0x18]
; 		if (err != 0) {
 801eb3e: 69bb         	ldr	r3, [r7, #0x18]
 801eb40: 2b00         	cmp	r3, #0x0
 801eb42: d001         	beq	0x801eb48 <can_mcan_get_state+0x30> @ imm = #0x2
; 			return err;
 801eb44: 69bb         	ldr	r3, [r7, #0x18]
 801eb46: e044         	b	0x801ebd2 <can_mcan_get_state+0xba> @ imm = #0x88
; 		if (!data->common.started) {
 801eb48: 69fb         	ldr	r3, [r7, #0x1c]
 801eb4a: 791b         	ldrb	r3, [r3, #0x4]
 801eb4c: f083 0301    	eor	r3, r3, #0x1
 801eb50: b2db         	uxtb	r3, r3
 801eb52: 2b00         	cmp	r3, #0x0
 801eb54: d003         	beq	0x801eb5e <can_mcan_get_state+0x46> @ imm = #0x6
; 			*state = CAN_STATE_STOPPED;
 801eb56: 68bb         	ldr	r3, [r7, #0x8]
 801eb58: 2204         	movs	r2, #0x4
 801eb5a: 701a         	strb	r2, [r3]
 801eb5c: e01d         	b	0x801eb9a <can_mcan_get_state+0x82> @ imm = #0x3a
; 		} else if ((reg & CAN_MCAN_PSR_BO) != 0U) {
 801eb5e: 697b         	ldr	r3, [r7, #0x14]
 801eb60: f003 0380    	and	r3, r3, #0x80
 801eb64: 2b00         	cmp	r3, #0x0
 801eb66: d003         	beq	0x801eb70 <can_mcan_get_state+0x58> @ imm = #0x6
; 			*state = CAN_STATE_BUS_OFF;
 801eb68: 68bb         	ldr	r3, [r7, #0x8]
 801eb6a: 2203         	movs	r2, #0x3
 801eb6c: 701a         	strb	r2, [r3]
 801eb6e: e014         	b	0x801eb9a <can_mcan_get_state+0x82> @ imm = #0x28
; 		} else if ((reg & CAN_MCAN_PSR_EP) != 0U) {
 801eb70: 697b         	ldr	r3, [r7, #0x14]
 801eb72: f003 0320    	and	r3, r3, #0x20
 801eb76: 2b00         	cmp	r3, #0x0
 801eb78: d003         	beq	0x801eb82 <can_mcan_get_state+0x6a> @ imm = #0x6
; 			*state = CAN_STATE_ERROR_PASSIVE;
 801eb7a: 68bb         	ldr	r3, [r7, #0x8]
 801eb7c: 2202         	movs	r2, #0x2
 801eb7e: 701a         	strb	r2, [r3]
 801eb80: e00b         	b	0x801eb9a <can_mcan_get_state+0x82> @ imm = #0x16
; 		} else if ((reg & CAN_MCAN_PSR_EW) != 0U) {
 801eb82: 697b         	ldr	r3, [r7, #0x14]
 801eb84: f003 0340    	and	r3, r3, #0x40
 801eb88: 2b00         	cmp	r3, #0x0
 801eb8a: d003         	beq	0x801eb94 <can_mcan_get_state+0x7c> @ imm = #0x6
; 			*state = CAN_STATE_ERROR_WARNING;
 801eb8c: 68bb         	ldr	r3, [r7, #0x8]
 801eb8e: 2201         	movs	r2, #0x1
 801eb90: 701a         	strb	r2, [r3]
 801eb92: e002         	b	0x801eb9a <can_mcan_get_state+0x82> @ imm = #0x4
; 			*state = CAN_STATE_ERROR_ACTIVE;
 801eb94: 68bb         	ldr	r3, [r7, #0x8]
 801eb96: 2200         	movs	r2, #0x0
 801eb98: 701a         	strb	r2, [r3]
; 	if (err_cnt != NULL) {
 801eb9a: 687b         	ldr	r3, [r7, #0x4]
 801eb9c: 2b00         	cmp	r3, #0x0
 801eb9e: d017         	beq	0x801ebd0 <can_mcan_get_state+0xb8> @ imm = #0x2e
; 		err = can_mcan_read_reg(dev, CAN_MCAN_ECR, &reg);
 801eba0: f107 0314    	add.w	r3, r7, #0x14
 801eba4: 461a         	mov	r2, r3
 801eba6: 2140         	movs	r1, #0x40
 801eba8: 68f8         	ldr	r0, [r7, #0xc]
 801ebaa: f7e9 f829    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x16fae
 801ebae: 61b8         	str	r0, [r7, #0x18]
; 		if (err != 0) {
 801ebb0: 69bb         	ldr	r3, [r7, #0x18]
 801ebb2: 2b00         	cmp	r3, #0x0
 801ebb4: d001         	beq	0x801ebba <can_mcan_get_state+0xa2> @ imm = #0x2
; 			return err;
 801ebb6: 69bb         	ldr	r3, [r7, #0x18]
 801ebb8: e00b         	b	0x801ebd2 <can_mcan_get_state+0xba> @ imm = #0x16
; 		err_cnt->tx_err_cnt = FIELD_GET(CAN_MCAN_ECR_TEC, reg);
 801ebba: 697b         	ldr	r3, [r7, #0x14]
 801ebbc: b2da         	uxtb	r2, r3
 801ebbe: 687b         	ldr	r3, [r7, #0x4]
 801ebc0: 701a         	strb	r2, [r3]
; 		err_cnt->rx_err_cnt = FIELD_GET(CAN_MCAN_ECR_REC, reg);
 801ebc2: 697b         	ldr	r3, [r7, #0x14]
 801ebc4: f403 43fe    	and	r3, r3, #0x7f00
 801ebc8: 0a1b         	lsrs	r3, r3, #0x8
 801ebca: b2da         	uxtb	r2, r3
 801ebcc: 687b         	ldr	r3, [r7, #0x4]
 801ebce: 705a         	strb	r2, [r3, #0x1]
; 	return 0;
 801ebd0: 2300         	movs	r3, #0x0
; }
 801ebd2: 4618         	mov	r0, r3
 801ebd4: 3720         	adds	r7, #0x20
 801ebd6: 46bd         	mov	sp, r7
 801ebd8: bd80         	pop	{r7, pc}

0801ebda <can_mcan_get_max_filters>:
; {
 801ebda: b480         	push	{r7}
 801ebdc: b085         	sub	sp, #0x14
 801ebde: af00         	add	r7, sp, #0x0
 801ebe0: 6078         	str	r0, [r7, #0x4]
 801ebe2: 460b         	mov	r3, r1
 801ebe4: 70fb         	strb	r3, [r7, #0x3]
; 	const struct can_mcan_config *config = dev->config;
 801ebe6: 687b         	ldr	r3, [r7, #0x4]
 801ebe8: 685b         	ldr	r3, [r3, #0x4]
 801ebea: 60fb         	str	r3, [r7, #0xc]
; 	const struct can_mcan_callbacks *cbs = config->callbacks;
 801ebec: 68fb         	ldr	r3, [r7, #0xc]
 801ebee: 699b         	ldr	r3, [r3, #0x18]
 801ebf0: 60bb         	str	r3, [r7, #0x8]
; 	if (ide) {
 801ebf2: 78fb         	ldrb	r3, [r7, #0x3]
 801ebf4: 2b00         	cmp	r3, #0x0
 801ebf6: d002         	beq	0x801ebfe <can_mcan_get_max_filters+0x24> @ imm = #0x4
; 		return cbs->num_ext;
 801ebf8: 68bb         	ldr	r3, [r7, #0x8]
 801ebfa: 7b9b         	ldrb	r3, [r3, #0xe]
 801ebfc: e001         	b	0x801ec02 <can_mcan_get_max_filters+0x28> @ imm = #0x2
; 		return cbs->num_std;
 801ebfe: 68bb         	ldr	r3, [r7, #0x8]
 801ec00: 7b5b         	ldrb	r3, [r3, #0xd]
; }
 801ec02: 4618         	mov	r0, r3
 801ec04: 3714         	adds	r7, #0x14
 801ec06: 46bd         	mov	sp, r7
 801ec08: f85d 7b04    	ldr	r7, [sp], #4
 801ec0c: 4770         	bx	lr

0801ec0e <can_mcan_set_state_change_callback>:
; {
 801ec0e: b480         	push	{r7}
 801ec10: b087         	sub	sp, #0x1c
 801ec12: af00         	add	r7, sp, #0x0
 801ec14: 60f8         	str	r0, [r7, #0xc]
 801ec16: 60b9         	str	r1, [r7, #0x8]
 801ec18: 607a         	str	r2, [r7, #0x4]
; 	struct can_mcan_data *data = dev->data;
 801ec1a: 68fb         	ldr	r3, [r7, #0xc]
 801ec1c: 691b         	ldr	r3, [r3, #0x10]
 801ec1e: 617b         	str	r3, [r7, #0x14]
; 	data->common.state_change_cb = callback;
 801ec20: 697b         	ldr	r3, [r7, #0x14]
 801ec22: 68ba         	ldr	r2, [r7, #0x8]
 801ec24: 609a         	str	r2, [r3, #0x8]
; 	data->common.state_change_cb_user_data = user_data;
 801ec26: 697b         	ldr	r3, [r7, #0x14]
 801ec28: 687a         	ldr	r2, [r7, #0x4]
 801ec2a: 60da         	str	r2, [r3, #0xc]
; }
 801ec2c: bf00         	nop
 801ec2e: 371c         	adds	r7, #0x1c
 801ec30: 46bd         	mov	sp, r7
 801ec32: f85d 7b04    	ldr	r7, [sp], #4
 801ec36: 4770         	bx	lr

0801ec38 <can_mcan_enable_configuration_change>:
; {
 801ec38: b580         	push	{r7, lr}
 801ec3a: b086         	sub	sp, #0x18
 801ec3c: af00         	add	r7, sp, #0x0
 801ec3e: 6078         	str	r0, [r7, #0x4]
; 	struct can_mcan_data *data = dev->data;
 801ec40: 687b         	ldr	r3, [r7, #0x4]
 801ec42: 691b         	ldr	r3, [r3, #0x10]
 801ec44: 617b         	str	r3, [r7, #0x14]
; 	k_mutex_lock(&data->lock, K_FOREVER);
 801ec46: 697b         	ldr	r3, [r7, #0x14]
 801ec48: f103 0110    	add.w	r1, r3, #0x10
 801ec4c: f04f 32ff    	mov.w	r2, #0xffffffff
 801ec50: f04f 33ff    	mov.w	r3, #0xffffffff
 801ec54: 4608         	mov	r0, r1
 801ec56: f7ff fce1    	bl	0x801e61c <k_mutex_lock> @ imm = #-0x63e
; 	err = can_mcan_read_reg(dev, CAN_MCAN_CCCR, &cccr);
 801ec5a: f107 030c    	add.w	r3, r7, #0xc
 801ec5e: 461a         	mov	r2, r3
 801ec60: 2118         	movs	r1, #0x18
 801ec62: 6878         	ldr	r0, [r7, #0x4]
 801ec64: f7e8 ffcc    	bl	0x8007c00 <can_mcan_read_reg> @ imm = #-0x17068
 801ec68: 6138         	str	r0, [r7, #0x10]
; 	if (err != 0) {
 801ec6a: 693b         	ldr	r3, [r7, #0x10]
 801ec6c: 2b00         	cmp	r3, #0x0
 801ec6e: d10d         	bne	0x801ec8c <can_mcan_enable_configuration_change+0x54> @ imm = #0x1a
; 	cccr |= CAN_MCAN_CCCR_CCE;
 801ec70: 68fb         	ldr	r3, [r7, #0xc]
 801ec72: f043 0302    	orr	r3, r3, #0x2
 801ec76: 60fb         	str	r3, [r7, #0xc]
; 	err = can_mcan_write_reg(dev, CAN_MCAN_CCCR, cccr);
 801ec78: 68fb         	ldr	r3, [r7, #0xc]
 801ec7a: 461a         	mov	r2, r3
 801ec7c: 2118         	movs	r1, #0x18
 801ec7e: 6878         	ldr	r0, [r7, #0x4]
 801ec80: f7e8 fffa    	bl	0x8007c78 <can_mcan_write_reg> @ imm = #-0x1700c
 801ec84: 6138         	str	r0, [r7, #0x10]
; 	if (err != 0) {
 801ec86: 693b         	ldr	r3, [r7, #0x10]
 801ec88: 2b00         	cmp	r3, #0x0
; unlock:
 801ec8a: e000         	b	0x801ec8e <can_mcan_enable_configuration_change+0x56> @ imm = #0x0
; 		goto unlock;
 801ec8c: bf00         	nop
; 	k_mutex_unlock(&data->lock);
 801ec8e: 697b         	ldr	r3, [r7, #0x14]
 801ec90: 3310         	adds	r3, #0x10
 801ec92: 4618         	mov	r0, r3
 801ec94: f7ff fcd2    	bl	0x801e63c <k_mutex_unlock> @ imm = #-0x65c
; }
 801ec98: bf00         	nop
 801ec9a: 3718         	adds	r7, #0x18
 801ec9c: 46bd         	mov	sp, r7
 801ec9e: bd80         	pop	{r7, pc}

0801eca0 <device_is_ready>:
; {
 801eca0: b580         	push	{r7, lr}
 801eca2: b082         	sub	sp, #0x8
 801eca4: af00         	add	r7, sp, #0x0
 801eca6: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801eca8: 6878         	ldr	r0, [r7, #0x4]
 801ecaa: f007 fb78    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x76f0
 801ecae: 4603         	mov	r3, r0
; }
 801ecb0: 4618         	mov	r0, r3
 801ecb2: 3708         	adds	r7, #0x8
 801ecb4: 46bd         	mov	sp, r7
 801ecb6: bd80         	pop	{r7, pc}

0801ecb8 <can_mcan_sys_read_reg>:
; {
 801ecb8: b480         	push	{r7}
 801ecba: b087         	sub	sp, #0x1c
 801ecbc: af00         	add	r7, sp, #0x0
 801ecbe: 60f8         	str	r0, [r7, #0xc]
 801ecc0: 460b         	mov	r3, r1
 801ecc2: 607a         	str	r2, [r7, #0x4]
 801ecc4: 817b         	strh	r3, [r7, #0xa]
; 	*val = sys_read32(base + reg);
 801ecc6: 897a         	ldrh	r2, [r7, #0xa]
 801ecc8: 68fb         	ldr	r3, [r7, #0xc]
 801ecca: 4413         	add	r3, r2
 801eccc: 617b         	str	r3, [r7, #0x14]
; 	return *(volatile uint32_t *)addr;
 801ecce: 697b         	ldr	r3, [r7, #0x14]
 801ecd0: 681a         	ldr	r2, [r3]
; 	*val = sys_read32(base + reg);
 801ecd2: 687b         	ldr	r3, [r7, #0x4]
 801ecd4: 601a         	str	r2, [r3]
; 	return 0;
 801ecd6: 2300         	movs	r3, #0x0
; }
 801ecd8: 4618         	mov	r0, r3
 801ecda: 371c         	adds	r7, #0x1c
 801ecdc: 46bd         	mov	sp, r7
 801ecde: f85d 7b04    	ldr	r7, [sp], #4
 801ece2: 4770         	bx	lr

0801ece4 <can_mcan_sys_write_reg>:
; {
 801ece4: b480         	push	{r7}
 801ece6: b087         	sub	sp, #0x1c
 801ece8: af00         	add	r7, sp, #0x0
 801ecea: 60f8         	str	r0, [r7, #0xc]
 801ecec: 460b         	mov	r3, r1
 801ecee: 607a         	str	r2, [r7, #0x4]
 801ecf0: 817b         	strh	r3, [r7, #0xa]
; 	sys_write32(val, base + reg);
 801ecf2: 897a         	ldrh	r2, [r7, #0xa]
 801ecf4: 68fb         	ldr	r3, [r7, #0xc]
 801ecf6: 4413         	add	r3, r2
 801ecf8: 687a         	ldr	r2, [r7, #0x4]
 801ecfa: 617a         	str	r2, [r7, #0x14]
 801ecfc: 613b         	str	r3, [r7, #0x10]
; 	*(volatile uint32_t *)addr = data;
 801ecfe: 693b         	ldr	r3, [r7, #0x10]
 801ed00: 697a         	ldr	r2, [r7, #0x14]
 801ed02: 601a         	str	r2, [r3]
; }
 801ed04: bf00         	nop
; 	return 0;
 801ed06: 2300         	movs	r3, #0x0
; }
 801ed08: 4618         	mov	r0, r3
 801ed0a: 371c         	adds	r7, #0x1c
 801ed0c: 46bd         	mov	sp, r7
 801ed0e: f85d 7b04    	ldr	r7, [sp], #4
 801ed12: 4770         	bx	lr

0801ed14 <can_mcan_sys_read_mram>:
; {
 801ed14: b480         	push	{r7}
 801ed16: b089         	sub	sp, #0x24
 801ed18: af00         	add	r7, sp, #0x0
 801ed1a: 60f8         	str	r0, [r7, #0xc]
 801ed1c: 607a         	str	r2, [r7, #0x4]
 801ed1e: 603b         	str	r3, [r7]
 801ed20: 460b         	mov	r3, r1
 801ed22: 817b         	strh	r3, [r7, #0xa]
; 	volatile uint32_t *src32 = (volatile uint32_t *)(base + offset);
 801ed24: 897a         	ldrh	r2, [r7, #0xa]
 801ed26: 68fb         	ldr	r3, [r7, #0xc]
 801ed28: 4413         	add	r3, r2
 801ed2a: 61fb         	str	r3, [r7, #0x1c]
; 	uint32_t *dst32 = (uint32_t *)dst;
 801ed2c: 687b         	ldr	r3, [r7, #0x4]
 801ed2e: 61bb         	str	r3, [r7, #0x18]
; 	size_t len32 = len / sizeof(uint32_t);
 801ed30: 683b         	ldr	r3, [r7]
 801ed32: 089b         	lsrs	r3, r3, #0x2
 801ed34: 617b         	str	r3, [r7, #0x14]
; 	while (len32-- > 0) {
 801ed36: e007         	b	0x801ed48 <can_mcan_sys_read_mram+0x34> @ imm = #0xe
; 		*dst32++ = *src32++;
 801ed38: 69fa         	ldr	r2, [r7, #0x1c]
 801ed3a: 1d13         	adds	r3, r2, #0x4
 801ed3c: 61fb         	str	r3, [r7, #0x1c]
 801ed3e: 69bb         	ldr	r3, [r7, #0x18]
 801ed40: 1d19         	adds	r1, r3, #0x4
 801ed42: 61b9         	str	r1, [r7, #0x18]
 801ed44: 6812         	ldr	r2, [r2]
 801ed46: 601a         	str	r2, [r3]
; 	while (len32-- > 0) {
 801ed48: 697b         	ldr	r3, [r7, #0x14]
 801ed4a: 1e5a         	subs	r2, r3, #0x1
 801ed4c: 617a         	str	r2, [r7, #0x14]
 801ed4e: 2b00         	cmp	r3, #0x0
 801ed50: d1f2         	bne	0x801ed38 <can_mcan_sys_read_mram+0x24> @ imm = #-0x1c
; 	return 0;
 801ed52: 2300         	movs	r3, #0x0
; }
 801ed54: 4618         	mov	r0, r3
 801ed56: 3724         	adds	r7, #0x24
 801ed58: 46bd         	mov	sp, r7
 801ed5a: f85d 7b04    	ldr	r7, [sp], #4
 801ed5e: 4770         	bx	lr

0801ed60 <can_mcan_sys_write_mram>:
; {
 801ed60: b480         	push	{r7}
 801ed62: b089         	sub	sp, #0x24
 801ed64: af00         	add	r7, sp, #0x0
 801ed66: 60f8         	str	r0, [r7, #0xc]
 801ed68: 607a         	str	r2, [r7, #0x4]
 801ed6a: 603b         	str	r3, [r7]
 801ed6c: 460b         	mov	r3, r1
 801ed6e: 817b         	strh	r3, [r7, #0xa]
; 	volatile uint32_t *dst32 = (volatile uint32_t *)(base + offset);
 801ed70: 897a         	ldrh	r2, [r7, #0xa]
 801ed72: 68fb         	ldr	r3, [r7, #0xc]
 801ed74: 4413         	add	r3, r2
 801ed76: 61fb         	str	r3, [r7, #0x1c]
; 	const uint32_t *src32 = (const uint32_t *)src;
 801ed78: 687b         	ldr	r3, [r7, #0x4]
 801ed7a: 61bb         	str	r3, [r7, #0x18]
; 	size_t len32 = len / sizeof(uint32_t);
 801ed7c: 683b         	ldr	r3, [r7]
 801ed7e: 089b         	lsrs	r3, r3, #0x2
 801ed80: 617b         	str	r3, [r7, #0x14]
; 	while (len32-- > 0) {
 801ed82: e007         	b	0x801ed94 <can_mcan_sys_write_mram+0x34> @ imm = #0xe
; 		*dst32++ = *src32++;
 801ed84: 69ba         	ldr	r2, [r7, #0x18]
 801ed86: 1d13         	adds	r3, r2, #0x4
 801ed88: 61bb         	str	r3, [r7, #0x18]
 801ed8a: 69fb         	ldr	r3, [r7, #0x1c]
 801ed8c: 1d19         	adds	r1, r3, #0x4
 801ed8e: 61f9         	str	r1, [r7, #0x1c]
 801ed90: 6812         	ldr	r2, [r2]
 801ed92: 601a         	str	r2, [r3]
; 	while (len32-- > 0) {
 801ed94: 697b         	ldr	r3, [r7, #0x14]
 801ed96: 1e5a         	subs	r2, r3, #0x1
 801ed98: 617a         	str	r2, [r7, #0x14]
 801ed9a: 2b00         	cmp	r3, #0x0
 801ed9c: d1f2         	bne	0x801ed84 <can_mcan_sys_write_mram+0x24> @ imm = #-0x1c
; 	return 0;
 801ed9e: 2300         	movs	r3, #0x0
; }
 801eda0: 4618         	mov	r0, r3
 801eda2: 3724         	adds	r7, #0x24
 801eda4: 46bd         	mov	sp, r7
 801eda6: f85d 7b04    	ldr	r7, [sp], #4
 801edaa: 4770         	bx	lr

0801edac <can_mcan_sys_clear_mram>:
; {
 801edac: b480         	push	{r7}
 801edae: b087         	sub	sp, #0x1c
 801edb0: af00         	add	r7, sp, #0x0
 801edb2: 60f8         	str	r0, [r7, #0xc]
 801edb4: 460b         	mov	r3, r1
 801edb6: 607a         	str	r2, [r7, #0x4]
 801edb8: 817b         	strh	r3, [r7, #0xa]
; 	volatile uint32_t *dst32 = (volatile uint32_t *)(base + offset);
 801edba: 897a         	ldrh	r2, [r7, #0xa]
 801edbc: 68fb         	ldr	r3, [r7, #0xc]
 801edbe: 4413         	add	r3, r2
 801edc0: 617b         	str	r3, [r7, #0x14]
; 	size_t len32 = len / sizeof(uint32_t);
 801edc2: 687b         	ldr	r3, [r7, #0x4]
 801edc4: 089b         	lsrs	r3, r3, #0x2
 801edc6: 613b         	str	r3, [r7, #0x10]
; 	while (len32-- > 0) {
 801edc8: e004         	b	0x801edd4 <can_mcan_sys_clear_mram+0x28> @ imm = #0x8
; 		*dst32++ = 0U;
 801edca: 697b         	ldr	r3, [r7, #0x14]
 801edcc: 1d1a         	adds	r2, r3, #0x4
 801edce: 617a         	str	r2, [r7, #0x14]
 801edd0: 2200         	movs	r2, #0x0
 801edd2: 601a         	str	r2, [r3]
; 	while (len32-- > 0) {
 801edd4: 693b         	ldr	r3, [r7, #0x10]
 801edd6: 1e5a         	subs	r2, r3, #0x1
 801edd8: 613a         	str	r2, [r7, #0x10]
 801edda: 2b00         	cmp	r3, #0x0
 801eddc: d1f5         	bne	0x801edca <can_mcan_sys_clear_mram+0x1e> @ imm = #-0x16
; 	return 0;
 801edde: 2300         	movs	r3, #0x0
; }
 801ede0: 4618         	mov	r0, r3
 801ede2: 371c         	adds	r7, #0x1c
 801ede4: 46bd         	mov	sp, r7
 801ede6: f85d 7b04    	ldr	r7, [sp], #4
 801edea: 4770         	bx	lr

0801edec <clock_control_on>:
; {
 801edec: b580         	push	{r7, lr}
 801edee: b084         	sub	sp, #0x10
 801edf0: af00         	add	r7, sp, #0x0
 801edf2: 6078         	str	r0, [r7, #0x4]
 801edf4: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801edf6: 687b         	ldr	r3, [r7, #0x4]
 801edf8: 689b         	ldr	r3, [r3, #0x8]
 801edfa: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801edfc: 68fb         	ldr	r3, [r7, #0xc]
 801edfe: 681b         	ldr	r3, [r3]
 801ee00: 6839         	ldr	r1, [r7]
 801ee02: 6878         	ldr	r0, [r7, #0x4]
 801ee04: 4798         	blx	r3
 801ee06: 4603         	mov	r3, r0
; }
 801ee08: 4618         	mov	r0, r3
 801ee0a: 3710         	adds	r7, #0x10
 801ee0c: 46bd         	mov	sp, r7
 801ee0e: bd80         	pop	{r7, pc}

0801ee10 <pinctrl_apply_state_direct>:
; {
 801ee10: b580         	push	{r7, lr}
 801ee12: b084         	sub	sp, #0x10
 801ee14: af00         	add	r7, sp, #0x0
 801ee16: 6078         	str	r0, [r7, #0x4]
 801ee18: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 801ee1a: 2300         	movs	r3, #0x0
 801ee1c: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 801ee1e: 683b         	ldr	r3, [r7]
 801ee20: 6818         	ldr	r0, [r3]
 801ee22: 683b         	ldr	r3, [r7]
 801ee24: 791b         	ldrb	r3, [r3, #0x4]
 801ee26: 68fa         	ldr	r2, [r7, #0xc]
 801ee28: 4619         	mov	r1, r3
 801ee2a: f002 fd35    	bl	0x8021898 <pinctrl_configure_pins> @ imm = #0x2a6a
 801ee2e: 4603         	mov	r3, r0
; }
 801ee30: 4618         	mov	r0, r3
 801ee32: 3710         	adds	r7, #0x10
 801ee34: 46bd         	mov	sp, r7
 801ee36: bd80         	pop	{r7, pc}

0801ee38 <pinctrl_apply_state>:
; {
 801ee38: b580         	push	{r7, lr}
 801ee3a: b084         	sub	sp, #0x10
 801ee3c: af00         	add	r7, sp, #0x0
 801ee3e: 6078         	str	r0, [r7, #0x4]
 801ee40: 460b         	mov	r3, r1
 801ee42: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 801ee44: f107 0208    	add.w	r2, r7, #0x8
 801ee48: 78fb         	ldrb	r3, [r7, #0x3]
 801ee4a: 4619         	mov	r1, r3
 801ee4c: 6878         	ldr	r0, [r7, #0x4]
 801ee4e: f002 fceb    	bl	0x8021828 <pinctrl_lookup_state> @ imm = #0x29d6
 801ee52: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 801ee54: 68fb         	ldr	r3, [r7, #0xc]
 801ee56: 2b00         	cmp	r3, #0x0
 801ee58: da01         	bge	0x801ee5e <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 801ee5a: 68fb         	ldr	r3, [r7, #0xc]
 801ee5c: e005         	b	0x801ee6a <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 801ee5e: 68bb         	ldr	r3, [r7, #0x8]
 801ee60: 4619         	mov	r1, r3
 801ee62: 6878         	ldr	r0, [r7, #0x4]
 801ee64: f7ff ffd4    	bl	0x801ee10 <pinctrl_apply_state_direct> @ imm = #-0x58
 801ee68: 4603         	mov	r3, r0
; }
 801ee6a: 4618         	mov	r0, r3
 801ee6c: 3710         	adds	r7, #0x10
 801ee6e: 46bd         	mov	sp, r7
 801ee70: bd80         	pop	{r7, pc}

0801ee72 <z_log_msg_runtime_create>:
; {
 801ee72: b580         	push	{r7, lr}
 801ee74: b08a         	sub	sp, #0x28
 801ee76: af04         	add	r7, sp, #0x10
 801ee78: 60b9         	str	r1, [r7, #0x8]
 801ee7a: 607b         	str	r3, [r7, #0x4]
 801ee7c: 4603         	mov	r3, r0
 801ee7e: 73fb         	strb	r3, [r7, #0xf]
 801ee80: 4613         	mov	r3, r2
 801ee82: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801ee84: f107 032c    	add.w	r3, r7, #0x2c
 801ee88: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801ee8a: 7bba         	ldrb	r2, [r7, #0xe]
 801ee8c: 7bf8         	ldrb	r0, [r7, #0xf]
 801ee8e: 697b         	ldr	r3, [r7, #0x14]
 801ee90: 9303         	str	r3, [sp, #0xc]
 801ee92: 6abb         	ldr	r3, [r7, #0x28]
 801ee94: 9302         	str	r3, [sp, #0x8]
 801ee96: 6a7b         	ldr	r3, [r7, #0x24]
 801ee98: 9301         	str	r3, [sp, #0x4]
 801ee9a: 6a3b         	ldr	r3, [r7, #0x20]
 801ee9c: 9300         	str	r3, [sp]
 801ee9e: 687b         	ldr	r3, [r7, #0x4]
 801eea0: 68b9         	ldr	r1, [r7, #0x8]
 801eea2: f7e5 fe67    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1a332
; }
 801eea6: bf00         	nop
 801eea8: 3718         	adds	r7, #0x18
 801eeaa: 46bd         	mov	sp, r7
 801eeac: bd80         	pop	{r7, pc}

0801eeae <can_stm32h7_read_reg>:
; {
 801eeae: b580         	push	{r7, lr}
 801eeb0: b086         	sub	sp, #0x18
 801eeb2: af00         	add	r7, sp, #0x0
 801eeb4: 60f8         	str	r0, [r7, #0xc]
 801eeb6: 460b         	mov	r3, r1
 801eeb8: 607a         	str	r2, [r7, #0x4]
 801eeba: 817b         	strh	r3, [r7, #0xa]
; 	const struct can_mcan_config *mcan_cfg = dev->config;
 801eebc: 68fb         	ldr	r3, [r7, #0xc]
 801eebe: 685b         	ldr	r3, [r3, #0x4]
 801eec0: 617b         	str	r3, [r7, #0x14]
; 	const struct can_stm32h7_config *stm32h7_cfg = mcan_cfg->custom;
 801eec2: 697b         	ldr	r3, [r7, #0x14]
 801eec4: 6c1b         	ldr	r3, [r3, #0x40]
 801eec6: 613b         	str	r3, [r7, #0x10]
; 	return can_mcan_sys_read_reg(stm32h7_cfg->base, reg, val);
 801eec8: 693b         	ldr	r3, [r7, #0x10]
 801eeca: 681b         	ldr	r3, [r3]
 801eecc: 8979         	ldrh	r1, [r7, #0xa]
 801eece: 687a         	ldr	r2, [r7, #0x4]
 801eed0: 4618         	mov	r0, r3
 801eed2: f7ff fef1    	bl	0x801ecb8 <can_mcan_sys_read_reg> @ imm = #-0x21e
 801eed6: 4603         	mov	r3, r0
; }
 801eed8: 4618         	mov	r0, r3
 801eeda: 3718         	adds	r7, #0x18
 801eedc: 46bd         	mov	sp, r7
 801eede: bd80         	pop	{r7, pc}

0801eee0 <can_stm32h7_write_reg>:
; {
 801eee0: b580         	push	{r7, lr}
 801eee2: b086         	sub	sp, #0x18
 801eee4: af00         	add	r7, sp, #0x0
 801eee6: 60f8         	str	r0, [r7, #0xc]
 801eee8: 460b         	mov	r3, r1
 801eeea: 607a         	str	r2, [r7, #0x4]
 801eeec: 817b         	strh	r3, [r7, #0xa]
; 	const struct can_mcan_config *mcan_cfg = dev->config;
 801eeee: 68fb         	ldr	r3, [r7, #0xc]
 801eef0: 685b         	ldr	r3, [r3, #0x4]
 801eef2: 617b         	str	r3, [r7, #0x14]
; 	const struct can_stm32h7_config *stm32h7_cfg = mcan_cfg->custom;
 801eef4: 697b         	ldr	r3, [r7, #0x14]
 801eef6: 6c1b         	ldr	r3, [r3, #0x40]
 801eef8: 613b         	str	r3, [r7, #0x10]
; 	return can_mcan_sys_write_reg(stm32h7_cfg->base, reg, val);
 801eefa: 693b         	ldr	r3, [r7, #0x10]
 801eefc: 681b         	ldr	r3, [r3]
 801eefe: 8979         	ldrh	r1, [r7, #0xa]
 801ef00: 687a         	ldr	r2, [r7, #0x4]
 801ef02: 4618         	mov	r0, r3
 801ef04: f7ff feee    	bl	0x801ece4 <can_mcan_sys_write_reg> @ imm = #-0x224
 801ef08: 4603         	mov	r3, r0
; }
 801ef0a: 4618         	mov	r0, r3
 801ef0c: 3718         	adds	r7, #0x18
 801ef0e: 46bd         	mov	sp, r7
 801ef10: bd80         	pop	{r7, pc}

0801ef12 <can_stm32h7_read_mram>:
; {
 801ef12: b580         	push	{r7, lr}
 801ef14: b086         	sub	sp, #0x18
 801ef16: af00         	add	r7, sp, #0x0
 801ef18: 60f8         	str	r0, [r7, #0xc]
 801ef1a: 607a         	str	r2, [r7, #0x4]
 801ef1c: 603b         	str	r3, [r7]
 801ef1e: 460b         	mov	r3, r1
 801ef20: 817b         	strh	r3, [r7, #0xa]
; 	const struct can_mcan_config *mcan_cfg = dev->config;
 801ef22: 68fb         	ldr	r3, [r7, #0xc]
 801ef24: 685b         	ldr	r3, [r3, #0x4]
 801ef26: 617b         	str	r3, [r7, #0x14]
; 	const struct can_stm32h7_config *stm32h7_cfg = mcan_cfg->custom;
 801ef28: 697b         	ldr	r3, [r7, #0x14]
 801ef2a: 6c1b         	ldr	r3, [r3, #0x40]
 801ef2c: 613b         	str	r3, [r7, #0x10]
; 	return can_mcan_sys_read_mram(stm32h7_cfg->mram, offset, dst, len);
 801ef2e: 693b         	ldr	r3, [r7, #0x10]
 801ef30: 6898         	ldr	r0, [r3, #0x8]
 801ef32: 8979         	ldrh	r1, [r7, #0xa]
 801ef34: 683b         	ldr	r3, [r7]
 801ef36: 687a         	ldr	r2, [r7, #0x4]
 801ef38: f7ff feec    	bl	0x801ed14 <can_mcan_sys_read_mram> @ imm = #-0x228
 801ef3c: 4603         	mov	r3, r0
; }
 801ef3e: 4618         	mov	r0, r3
 801ef40: 3718         	adds	r7, #0x18
 801ef42: 46bd         	mov	sp, r7
 801ef44: bd80         	pop	{r7, pc}

0801ef46 <can_stm32h7_write_mram>:
; {
 801ef46: b580         	push	{r7, lr}
 801ef48: b086         	sub	sp, #0x18
 801ef4a: af00         	add	r7, sp, #0x0
 801ef4c: 60f8         	str	r0, [r7, #0xc]
 801ef4e: 607a         	str	r2, [r7, #0x4]
 801ef50: 603b         	str	r3, [r7]
 801ef52: 460b         	mov	r3, r1
 801ef54: 817b         	strh	r3, [r7, #0xa]
; 	const struct can_mcan_config *mcan_cfg = dev->config;
 801ef56: 68fb         	ldr	r3, [r7, #0xc]
 801ef58: 685b         	ldr	r3, [r3, #0x4]
 801ef5a: 617b         	str	r3, [r7, #0x14]
; 	const struct can_stm32h7_config *stm32h7_cfg = mcan_cfg->custom;
 801ef5c: 697b         	ldr	r3, [r7, #0x14]
 801ef5e: 6c1b         	ldr	r3, [r3, #0x40]
 801ef60: 613b         	str	r3, [r7, #0x10]
; 	return can_mcan_sys_write_mram(stm32h7_cfg->mram, offset, src, len);
 801ef62: 693b         	ldr	r3, [r7, #0x10]
 801ef64: 6898         	ldr	r0, [r3, #0x8]
 801ef66: 8979         	ldrh	r1, [r7, #0xa]
 801ef68: 683b         	ldr	r3, [r7]
 801ef6a: 687a         	ldr	r2, [r7, #0x4]
 801ef6c: f7ff fef8    	bl	0x801ed60 <can_mcan_sys_write_mram> @ imm = #-0x210
 801ef70: 4603         	mov	r3, r0
; }
 801ef72: 4618         	mov	r0, r3
 801ef74: 3718         	adds	r7, #0x18
 801ef76: 46bd         	mov	sp, r7
 801ef78: bd80         	pop	{r7, pc}

0801ef7a <can_stm32h7_clear_mram>:
; {
 801ef7a: b580         	push	{r7, lr}
 801ef7c: b086         	sub	sp, #0x18
 801ef7e: af00         	add	r7, sp, #0x0
 801ef80: 60f8         	str	r0, [r7, #0xc]
 801ef82: 460b         	mov	r3, r1
 801ef84: 607a         	str	r2, [r7, #0x4]
 801ef86: 817b         	strh	r3, [r7, #0xa]
; 	const struct can_mcan_config *mcan_cfg = dev->config;
 801ef88: 68fb         	ldr	r3, [r7, #0xc]
 801ef8a: 685b         	ldr	r3, [r3, #0x4]
 801ef8c: 617b         	str	r3, [r7, #0x14]
; 	const struct can_stm32h7_config *stm32h7_cfg = mcan_cfg->custom;
 801ef8e: 697b         	ldr	r3, [r7, #0x14]
 801ef90: 6c1b         	ldr	r3, [r3, #0x40]
 801ef92: 613b         	str	r3, [r7, #0x10]
; 	return can_mcan_sys_clear_mram(stm32h7_cfg->mram, offset, len);
 801ef94: 693b         	ldr	r3, [r7, #0x10]
 801ef96: 689b         	ldr	r3, [r3, #0x8]
 801ef98: 8979         	ldrh	r1, [r7, #0xa]
 801ef9a: 687a         	ldr	r2, [r7, #0x4]
 801ef9c: 4618         	mov	r0, r3
 801ef9e: f7ff ff05    	bl	0x801edac <can_mcan_sys_clear_mram> @ imm = #-0x1f6
 801efa2: 4603         	mov	r3, r0
; }
 801efa4: 4618         	mov	r0, r3
 801efa6: 3718         	adds	r7, #0x18
 801efa8: 46bd         	mov	sp, r7
 801efaa: bd80         	pop	{r7, pc}

0801efac <stm32_clock_control_mco_init>:
; {
 801efac: b480         	push	{r7}
 801efae: af00         	add	r7, sp, #0x0
; }
 801efb0: bf00         	nop
 801efb2: 46bd         	mov	sp, r7
 801efb4: f85d 7b04    	ldr	r7, [sp], #4
 801efb8: 4770         	bx	lr

0801efba <z_stm32_hsem_lock>:
; {
 801efba: b480         	push	{r7}
 801efbc: b083         	sub	sp, #0xc
 801efbe: af00         	add	r7, sp, #0x0
 801efc0: 6078         	str	r0, [r7, #0x4]
 801efc2: 6039         	str	r1, [r7]
; }
 801efc4: bf00         	nop
 801efc6: 370c         	adds	r7, #0xc
 801efc8: 46bd         	mov	sp, r7
 801efca: f85d 7b04    	ldr	r7, [sp], #4
 801efce: 4770         	bx	lr

0801efd0 <z_stm32_hsem_unlock>:
; {
 801efd0: b480         	push	{r7}
 801efd2: b083         	sub	sp, #0xc
 801efd4: af00         	add	r7, sp, #0x0
 801efd6: 6078         	str	r0, [r7, #0x4]
; }
 801efd8: bf00         	nop
 801efda: 370c         	adds	r7, #0xc
 801efdc: 46bd         	mov	sp, r7
 801efde: f85d 7b04    	ldr	r7, [sp], #4
 801efe2: 4770         	bx	lr

0801efe4 <get_bus_clock>:
; {
 801efe4: b480         	push	{r7}
 801efe6: b083         	sub	sp, #0xc
 801efe8: af00         	add	r7, sp, #0x0
 801efea: 6078         	str	r0, [r7, #0x4]
 801efec: 6039         	str	r1, [r7]
; 	return clock / prescaler;
 801efee: 687a         	ldr	r2, [r7, #0x4]
 801eff0: 683b         	ldr	r3, [r7]
 801eff2: fbb2 f3f3    	udiv	r3, r2, r3
; }
 801eff6: 4618         	mov	r0, r3
 801eff8: 370c         	adds	r7, #0xc
 801effa: 46bd         	mov	sp, r7
 801effc: f85d 7b04    	ldr	r7, [sp], #4
 801f000: 4770         	bx	lr

0801f002 <get_pllout_frequency>:
; {
 801f002: b480         	push	{r7}
 801f004: b085         	sub	sp, #0x14
 801f006: af00         	add	r7, sp, #0x0
 801f008: 60f8         	str	r0, [r7, #0xc]
 801f00a: 60b9         	str	r1, [r7, #0x8]
 801f00c: 607a         	str	r2, [r7, #0x4]
 801f00e: 603b         	str	r3, [r7]
; 	return (pllsrc_freq / pllm_div) * plln_mul / pllout_div;
 801f010: 68bb         	ldr	r3, [r7, #0x8]
 801f012: 68fa         	ldr	r2, [r7, #0xc]
 801f014: fbb2 f3f3    	udiv	r3, r2, r3
 801f018: 687a         	ldr	r2, [r7, #0x4]
 801f01a: fb03 f202    	mul	r2, r3, r2
 801f01e: 683b         	ldr	r3, [r7]
 801f020: fbb2 f3f3    	udiv	r3, r2, r3
; }
 801f024: 4618         	mov	r0, r3
 801f026: 3714         	adds	r7, #0x14
 801f028: 46bd         	mov	sp, r7
 801f02a: f85d 7b04    	ldr	r7, [sp], #4
 801f02e: 4770         	bx	lr

0801f030 <prepare_regulator_voltage_scale>:
; {
 801f030: b580         	push	{r7, lr}
 801f032: af00         	add	r7, sp, #0x0
; 	LL_PWR_ConfigSupply(LL_PWR_LDO_SUPPLY);
 801f034: 2002         	movs	r0, #0x2
 801f036: f7eb f827    	bl	0x800a088 <LL_PWR_ConfigSupply> @ imm = #-0x14fb2
; 	LL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE0);
 801f03a: 2000         	movs	r0, #0x0
 801f03c: f7eb f838    	bl	0x800a0b0 <LL_PWR_SetRegulVoltageScaling> @ imm = #-0x14f90
; 	while (LL_PWR_IsActiveFlag_VOS() == 0) {
 801f040: bf00         	nop
 801f042: f7eb f849    	bl	0x800a0d8 <LL_PWR_IsActiveFlag_VOS> @ imm = #-0x14f6e
 801f046: 4603         	mov	r3, r0
 801f048: 2b00         	cmp	r3, #0x0
 801f04a: d0fa         	beq	0x801f042 <prepare_regulator_voltage_scale+0x12> @ imm = #-0xc
; 	return 0;
 801f04c: 2300         	movs	r3, #0x0
; }
 801f04e: 4618         	mov	r0, r3
 801f050: bd80         	pop	{r7, pc}

0801f052 <optimize_regulator_voltage_scale>:
; {
 801f052: b580         	push	{r7, lr}
 801f054: b082         	sub	sp, #0x8
 801f056: af00         	add	r7, sp, #0x0
 801f058: 6078         	str	r0, [r7, #0x4]
; 	LL_PWR_ConfigSupply(LL_PWR_LDO_SUPPLY);
 801f05a: 2002         	movs	r0, #0x2
 801f05c: f7eb f814    	bl	0x800a088 <LL_PWR_ConfigSupply> @ imm = #-0x14fd8
; 	LL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE0);
 801f060: 2000         	movs	r0, #0x0
 801f062: f7eb f825    	bl	0x800a0b0 <LL_PWR_SetRegulVoltageScaling> @ imm = #-0x14fb6
; 	while (LL_PWR_IsActiveFlag_VOS() == 0) {
 801f066: bf00         	nop
 801f068: f7eb f836    	bl	0x800a0d8 <LL_PWR_IsActiveFlag_VOS> @ imm = #-0x14f94
 801f06c: 4603         	mov	r3, r0
 801f06e: 2b00         	cmp	r3, #0x0
 801f070: d0fa         	beq	0x801f068 <optimize_regulator_voltage_scale+0x16> @ imm = #-0xc
; 	return 0;
 801f072: 2300         	movs	r3, #0x0
; }
 801f074: 4618         	mov	r0, r3
 801f076: 3708         	adds	r7, #0x8
 801f078: 46bd         	mov	sp, r7
 801f07a: bd80         	pop	{r7, pc}

0801f07c <get_vco_output_range>:
; {
 801f07c: b480         	push	{r7}
 801f07e: b083         	sub	sp, #0xc
 801f080: af00         	add	r7, sp, #0x0
 801f082: 6078         	str	r0, [r7, #0x4]
; 	if (vco_input_range == LL_RCC_PLLINPUTRANGE_1_2) {
 801f084: 687b         	ldr	r3, [r7, #0x4]
 801f086: 2b00         	cmp	r3, #0x0
 801f088: d101         	bne	0x801f08e <get_vco_output_range+0x12> @ imm = #0x2
; 		return LL_RCC_PLLVCORANGE_MEDIUM;
 801f08a: 2301         	movs	r3, #0x1
 801f08c: e000         	b	0x801f090 <get_vco_output_range+0x14> @ imm = #0x0
; 	return LL_RCC_PLLVCORANGE_WIDE;
 801f08e: 2300         	movs	r3, #0x0
; }
 801f090: 4618         	mov	r0, r3
 801f092: 370c         	adds	r7, #0xc
 801f094: 46bd         	mov	sp, r7
 801f096: f85d 7b04    	ldr	r7, [sp], #4
 801f09a: 4770         	bx	lr

0801f09c <enabled_clock>:
; {
 801f09c: b480         	push	{r7}
 801f09e: b083         	sub	sp, #0xc
 801f0a0: af00         	add	r7, sp, #0x0
 801f0a2: 6078         	str	r0, [r7, #0x4]
; 	if ((src_clk == STM32_SRC_SYSCLK) ||
 801f0a4: 687b         	ldr	r3, [r7, #0x4]
 801f0a6: 2b01         	cmp	r3, #0x1
 801f0a8: d029         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x52
; 	    ((src_clk == STM32_SRC_CKPER) && IS_ENABLED(STM32_CKPER_ENABLED)) ||
 801f0aa: 687b         	ldr	r3, [r7, #0x4]
 801f0ac: 2b04         	cmp	r3, #0x4
 801f0ae: d026         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x4c
; 	    ((src_clk == STM32_SRC_HSE) && IS_ENABLED(STM32_HSE_ENABLED)) ||
 801f0b0: 687b         	ldr	r3, [r7, #0x4]
 801f0b2: 2b06         	cmp	r3, #0x6
 801f0b4: d023         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x46
; 	    ((src_clk == STM32_SRC_HSI_KER) && IS_ENABLED(STM32_HSI_ENABLED)) ||
 801f0b6: 687b         	ldr	r3, [r7, #0x4]
 801f0b8: 2b07         	cmp	r3, #0x7
 801f0ba: d020         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x40
; 	    ((src_clk == STM32_SRC_HSI48) && IS_ENABLED(STM32_HSI48_ENABLED)) ||
 801f0bc: 687b         	ldr	r3, [r7, #0x4]
 801f0be: 2b05         	cmp	r3, #0x5
 801f0c0: d01d         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x3a
; 	    ((src_clk == STM32_SRC_LSE) && IS_ENABLED(STM32_LSE_ENABLED)) ||
 801f0c2: 687b         	ldr	r3, [r7, #0x4]
 801f0c4: 2b03         	cmp	r3, #0x3
 801f0c6: d01a         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x34
; 	    ((src_clk == STM32_SRC_LSI) && IS_ENABLED(STM32_LSI_ENABLED)) ||
 801f0c8: 687b         	ldr	r3, [r7, #0x4]
 801f0ca: 2b08         	cmp	r3, #0x8
 801f0cc: d017         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x2e
; 	    ((src_clk == STM32_SRC_PLL1_P) && IS_ENABLED(STM32_PLL_P_ENABLED)) ||
 801f0ce: 687b         	ldr	r3, [r7, #0x4]
 801f0d0: 2b09         	cmp	r3, #0x9
 801f0d2: d014         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x28
; 	    ((src_clk == STM32_SRC_PLL1_Q) && IS_ENABLED(STM32_PLL_Q_ENABLED)) ||
 801f0d4: 687b         	ldr	r3, [r7, #0x4]
 801f0d6: 2b0a         	cmp	r3, #0xa
 801f0d8: d011         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x22
; 	    ((src_clk == STM32_SRC_PLL1_R) && IS_ENABLED(STM32_PLL_R_ENABLED)) ||
 801f0da: 687b         	ldr	r3, [r7, #0x4]
 801f0dc: 2b0b         	cmp	r3, #0xb
 801f0de: d00e         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x1c
; 	    ((src_clk == STM32_SRC_PLL2_P) && IS_ENABLED(STM32_PLL2_P_ENABLED)) ||
 801f0e0: 687b         	ldr	r3, [r7, #0x4]
 801f0e2: 2b0c         	cmp	r3, #0xc
 801f0e4: d00b         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x16
; 	    ((src_clk == STM32_SRC_PLL2_Q) && IS_ENABLED(STM32_PLL2_Q_ENABLED)) ||
 801f0e6: 687b         	ldr	r3, [r7, #0x4]
 801f0e8: 2b0d         	cmp	r3, #0xd
 801f0ea: d008         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x10
; 	    ((src_clk == STM32_SRC_PLL2_R) && IS_ENABLED(STM32_PLL2_R_ENABLED)) ||
 801f0ec: 687b         	ldr	r3, [r7, #0x4]
 801f0ee: 2b0e         	cmp	r3, #0xe
 801f0f0: d005         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0xa
; 	    ((src_clk == STM32_SRC_PLL3_P) && IS_ENABLED(STM32_PLL3_P_ENABLED)) ||
 801f0f2: 687b         	ldr	r3, [r7, #0x4]
 801f0f4: 2b0f         	cmp	r3, #0xf
 801f0f6: d002         	beq	0x801f0fe <enabled_clock+0x62> @ imm = #0x4
; 	    ((src_clk == STM32_SRC_PLL3_Q) && IS_ENABLED(STM32_PLL3_Q_ENABLED)) ||
 801f0f8: 687b         	ldr	r3, [r7, #0x4]
 801f0fa: 2b10         	cmp	r3, #0x10
 801f0fc: d101         	bne	0x801f102 <enabled_clock+0x66> @ imm = #0x2
; 		return 0;
 801f0fe: 2300         	movs	r3, #0x0
 801f100: e001         	b	0x801f106 <enabled_clock+0x6a> @ imm = #0x2
; 	return -ENOTSUP;
 801f102: f06f 0385    	mvn	r3, #0x85
; }
 801f106: 4618         	mov	r0, r3
 801f108: 370c         	adds	r7, #0xc
 801f10a: 46bd         	mov	sp, r7
 801f10c: f85d 7b04    	ldr	r7, [sp], #4
 801f110: 4770         	bx	lr

0801f112 <set_up_fixed_clock_sources>:
; {
 801f112: b580         	push	{r7, lr}
 801f114: af00         	add	r7, sp, #0x0
; 			LL_RCC_HSE_DisableBypass();
 801f116: f7ea fff3    	bl	0x800a100 <LL_RCC_HSE_DisableBypass> @ imm = #-0x1501a
; 		LL_RCC_HSE_Enable();
 801f11a: f7eb f801    	bl	0x800a120 <LL_RCC_HSE_Enable> @ imm = #-0x14ffe
; 		while (LL_RCC_HSE_IsReady() != 1) {
 801f11e: bf00         	nop
 801f120: f7eb f80e    	bl	0x800a140 <LL_RCC_HSE_IsReady> @ imm = #-0x14fe4
 801f124: 4603         	mov	r3, r0
 801f126: 2b01         	cmp	r3, #0x1
 801f128: d1fa         	bne	0x801f120 <set_up_fixed_clock_sources+0xe> @ imm = #-0xc
; 			LL_RCC_HSI_SetCalibTrimming(RCC_HSICALIBRATION_DEFAULT);
 801f12a: 2040         	movs	r0, #0x40
 801f12c: f7eb f852    	bl	0x800a1d4 <LL_RCC_HSI_SetCalibTrimming> @ imm = #-0x14f5c
; 		if (LL_RCC_HSI_IsReady() != 1) {
 801f130: f7eb f82a    	bl	0x800a188 <LL_RCC_HSI_IsReady> @ imm = #-0x14fac
 801f134: 4603         	mov	r3, r0
 801f136: 2b01         	cmp	r3, #0x1
 801f138: d007         	beq	0x801f14a <set_up_fixed_clock_sources+0x38> @ imm = #0xe
; 			LL_RCC_HSI_Enable();
 801f13a: f7eb f815    	bl	0x800a168 <LL_RCC_HSI_Enable> @ imm = #-0x14fd6
; 			while (LL_RCC_HSI_IsReady() != 1) {
 801f13e: bf00         	nop
 801f140: f7eb f822    	bl	0x800a188 <LL_RCC_HSI_IsReady> @ imm = #-0x14fbc
 801f144: 4603         	mov	r3, r0
 801f146: 2b01         	cmp	r3, #0x1
 801f148: d1fa         	bne	0x801f140 <set_up_fixed_clock_sources+0x2e> @ imm = #-0xc
; 		LL_RCC_HSI_SetDivider(hsi_divider(STM32_HSI_DIVISOR));
 801f14a: 2000         	movs	r0, #0x0
 801f14c: f7eb f82e    	bl	0x800a1ac <LL_RCC_HSI_SetDivider> @ imm = #-0x14fa4
; 		LL_RCC_CSI_Enable();
 801f150: f7eb f856    	bl	0x800a200 <LL_RCC_CSI_Enable> @ imm = #-0x14f54
; 		while (LL_RCC_CSI_IsReady() != 1) {
 801f154: bf00         	nop
 801f156: f7eb f863    	bl	0x800a220 <LL_RCC_CSI_IsReady> @ imm = #-0x14f3a
 801f15a: 4603         	mov	r3, r0
 801f15c: 2b01         	cmp	r3, #0x1
 801f15e: d1fa         	bne	0x801f156 <set_up_fixed_clock_sources+0x44> @ imm = #-0xc
; 		LL_RCC_LSI_Enable();
 801f160: f7eb f896    	bl	0x800a290 <LL_RCC_LSI_Enable> @ imm = #-0x14ed4
; 		while (LL_RCC_LSI_IsReady() != 1) {
 801f164: bf00         	nop
 801f166: f7eb f8a3    	bl	0x800a2b0 <LL_RCC_LSI_IsReady> @ imm = #-0x14eba
 801f16a: 4603         	mov	r3, r0
 801f16c: 2b01         	cmp	r3, #0x1
 801f16e: d1fa         	bne	0x801f166 <set_up_fixed_clock_sources+0x54> @ imm = #-0xc
; 		LL_RCC_HSI48_Enable();
 801f170: f7eb f86a    	bl	0x800a248 <LL_RCC_HSI48_Enable> @ imm = #-0x14f2c
; 		while (LL_RCC_HSI48_IsReady() != 1) {
 801f174: bf00         	nop
 801f176: f7eb f877    	bl	0x800a268 <LL_RCC_HSI48_IsReady> @ imm = #-0x14f12
 801f17a: 4603         	mov	r3, r0
 801f17c: 2b01         	cmp	r3, #0x1
 801f17e: d1fa         	bne	0x801f176 <set_up_fixed_clock_sources+0x64> @ imm = #-0xc
; }
 801f180: bf00         	nop
 801f182: bf00         	nop
 801f184: bd80         	pop	{r7, pc}

0801f186 <stm32_clock_switch_to_hsi>:
; {
 801f186: b580         	push	{r7, lr}
 801f188: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_HSI_IsReady() != 1) {
 801f18a: f7ea fffd    	bl	0x800a188 <LL_RCC_HSI_IsReady> @ imm = #-0x15006
 801f18e: 4603         	mov	r3, r0
 801f190: 2b01         	cmp	r3, #0x1
 801f192: d007         	beq	0x801f1a4 <stm32_clock_switch_to_hsi+0x1e> @ imm = #0xe
; 		LL_RCC_HSI_Enable();
 801f194: f7ea ffe8    	bl	0x800a168 <LL_RCC_HSI_Enable> @ imm = #-0x15030
; 		while (LL_RCC_HSI_IsReady() != 1) {
 801f198: bf00         	nop
 801f19a: f7ea fff5    	bl	0x800a188 <LL_RCC_HSI_IsReady> @ imm = #-0x15016
 801f19e: 4603         	mov	r3, r0
 801f1a0: 2b01         	cmp	r3, #0x1
 801f1a2: d1fa         	bne	0x801f19a <stm32_clock_switch_to_hsi+0x14> @ imm = #-0xc
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI);
 801f1a4: 2000         	movs	r0, #0x0
 801f1a6: f7eb f895    	bl	0x800a2d4 <LL_RCC_SetSysClkSource> @ imm = #-0x14ed6
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI) {
 801f1aa: bf00         	nop
 801f1ac: f7eb f8a6    	bl	0x800a2fc <LL_RCC_GetSysClkSource> @ imm = #-0x14eb4
 801f1b0: 4603         	mov	r3, r0
 801f1b2: 2b00         	cmp	r3, #0x0
 801f1b4: d1fa         	bne	0x801f1ac <stm32_clock_switch_to_hsi+0x26> @ imm = #-0xc
; }
 801f1b6: bf00         	nop
 801f1b8: bf00         	nop
 801f1ba: bd80         	pop	{r7, pc}

0801f1bc <set_up_plls>:
; {
 801f1bc: b580         	push	{r7, lr}
 801f1be: b084         	sub	sp, #0x10
 801f1c0: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_GetSysClkSource() == LL_RCC_SYS_CLKSOURCE_STATUS_PLL1) {
 801f1c2: f7eb f89b    	bl	0x800a2fc <LL_RCC_GetSysClkSource> @ imm = #-0x14eca
 801f1c6: 4603         	mov	r3, r0
 801f1c8: 2b18         	cmp	r3, #0x18
 801f1ca: d104         	bne	0x801f1d6 <set_up_plls+0x1a> @ imm = #0x8
; 		stm32_clock_switch_to_hsi();
 801f1cc: f7ff ffdb    	bl	0x801f186 <stm32_clock_switch_to_hsi> @ imm = #-0x4a
; 		LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
 801f1d0: 2000         	movs	r0, #0x0
 801f1d2: f7eb f8b5    	bl	0x800a340 <LL_RCC_SetAHBPrescaler> @ imm = #-0x14e96
; 	LL_RCC_PLL1_Disable();
 801f1d6: f7eb f949    	bl	0x800a46c <LL_RCC_PLL1_Disable> @ imm = #-0x14d6e
; 	LL_RCC_PLL2_Disable();
 801f1da: f7eb fa7f    	bl	0x800a6dc <LL_RCC_PLL2_Disable> @ imm = #-0x14b02
; 	LL_RCC_PLL3_Disable();
 801f1de: f7eb fbb5    	bl	0x800a94c <LL_RCC_PLL3_Disable> @ imm = #-0x14896
; 		LL_RCC_PLL_SetSource(LL_RCC_PLLSOURCE_HSI);
 801f1e2: 2000         	movs	r0, #0x0
 801f1e4: f7eb f910    	bl	0x800a408 <LL_RCC_PLL_SetSource> @ imm = #-0x14de0
; 	r = get_vco_input_range(STM32_PLL_M_DIVISOR, &vco_input_range);
 801f1e8: 1d3b         	adds	r3, r7, #0x4
 801f1ea: 4619         	mov	r1, r3
 801f1ec: 2004         	movs	r0, #0x4
 801f1ee: f7eb fd55    	bl	0x800ac9c <get_vco_input_range> @ imm = #-0x14556
 801f1f2: 60f8         	str	r0, [r7, #0xc]
; 	if (r < 0) {
 801f1f4: 68fb         	ldr	r3, [r7, #0xc]
 801f1f6: 2b00         	cmp	r3, #0x0
 801f1f8: da01         	bge	0x801f1fe <set_up_plls+0x42> @ imm = #0x2
; 		return r;
 801f1fa: 68fb         	ldr	r3, [r7, #0xc]
 801f1fc: e0a7         	b	0x801f34e <set_up_plls+0x192> @ imm = #0x14e
; 	vco_output_range = get_vco_output_range(vco_input_range);
 801f1fe: 687b         	ldr	r3, [r7, #0x4]
 801f200: 4618         	mov	r0, r3
 801f202: f7ff ff3b    	bl	0x801f07c <get_vco_output_range> @ imm = #-0x18a
 801f206: 60b8         	str	r0, [r7, #0x8]
; 	LL_RCC_PLL1_SetM(STM32_PLL_M_DIVISOR);
 801f208: 2004         	movs	r0, #0x4
 801f20a: f7eb f9e7    	bl	0x800a5dc <LL_RCC_PLL1_SetM> @ imm = #-0x14c32
; 	LL_RCC_PLL1_SetVCOInputRange(vco_input_range);
 801f20e: 687b         	ldr	r3, [r7, #0x4]
 801f210: 4618         	mov	r0, r3
 801f212: f7eb f9b5    	bl	0x800a580 <LL_RCC_PLL1_SetVCOInputRange> @ imm = #-0x14c96
; 	LL_RCC_PLL1_SetVCOOutputRange(vco_output_range);
 801f216: 68b8         	ldr	r0, [r7, #0x8]
 801f218: f7eb f99c    	bl	0x800a554 <LL_RCC_PLL1_SetVCOOutputRange> @ imm = #-0x14cc8
; 	LL_RCC_PLL1_SetN(STM32_PLL_N_MULTIPLIER);
 801f21c: 2022         	movs	r0, #0x22
 801f21e: f7eb f9c5    	bl	0x800a5ac <LL_RCC_PLL1_SetN> @ imm = #-0x14c76
; 	LL_RCC_PLL1FRACN_Disable();
 801f222: f7eb f987    	bl	0x800a534 <LL_RCC_PLL1FRACN_Disable> @ imm = #-0x14cf2
; 		LL_RCC_PLL1_SetFRACN(STM32_PLL_FRACN_VALUE);
 801f226: f44f 6040    	mov.w	r0, #0xc00
 801f22a: f7eb fa2f    	bl	0x800a68c <LL_RCC_PLL1_SetFRACN> @ imm = #-0x14ba2
; 		LL_RCC_PLL1FRACN_Enable();
 801f22e: f7eb f971    	bl	0x800a514 <LL_RCC_PLL1FRACN_Enable> @ imm = #-0x14d1e
; 		LL_RCC_PLL1_SetP(STM32_PLL_P_DIVISOR);
 801f232: 2001         	movs	r0, #0x1
 801f234: f7eb f9e8    	bl	0x800a608 <LL_RCC_PLL1_SetP> @ imm = #-0x14c30
; 		LL_RCC_PLL1P_Enable();
 801f238: f7eb f93c    	bl	0x800a4b4 <LL_RCC_PLL1P_Enable> @ imm = #-0x14d88
; 		LL_RCC_PLL1_SetQ(STM32_PLL_Q_DIVISOR);
 801f23c: 2002         	movs	r0, #0x2
 801f23e: f7eb f9f9    	bl	0x800a634 <LL_RCC_PLL1_SetQ> @ imm = #-0x14c0e
; 		LL_RCC_PLL1Q_Enable();
 801f242: f7eb f947    	bl	0x800a4d4 <LL_RCC_PLL1Q_Enable> @ imm = #-0x14d72
; 		LL_RCC_PLL1_SetR(STM32_PLL_R_DIVISOR);
 801f246: 2002         	movs	r0, #0x2
 801f248: f7eb fa0a    	bl	0x800a660 <LL_RCC_PLL1_SetR> @ imm = #-0x14bec
; 		LL_RCC_PLL1R_Enable();
 801f24c: f7eb f952    	bl	0x800a4f4 <LL_RCC_PLL1R_Enable> @ imm = #-0x14d5c
; 	LL_RCC_PLL1_Enable();
 801f250: f7eb f8fc    	bl	0x800a44c <LL_RCC_PLL1_Enable> @ imm = #-0x14e08
; 	while (LL_RCC_PLL1_IsReady() != 1U) {
 801f254: bf00         	nop
 801f256: f7eb f919    	bl	0x800a48c <LL_RCC_PLL1_IsReady> @ imm = #-0x14dce
 801f25a: 4603         	mov	r3, r0
 801f25c: 2b01         	cmp	r3, #0x1
 801f25e: d1fa         	bne	0x801f256 <set_up_plls+0x9a> @ imm = #-0xc
; 	r = get_vco_input_range(STM32_PLL2_M_DIVISOR, &vco_input_range);
 801f260: 1d3b         	adds	r3, r7, #0x4
 801f262: 4619         	mov	r1, r3
 801f264: 2020         	movs	r0, #0x20
 801f266: f7eb fd19    	bl	0x800ac9c <get_vco_input_range> @ imm = #-0x145ce
 801f26a: 60f8         	str	r0, [r7, #0xc]
; 	if (r < 0) {
 801f26c: 68fb         	ldr	r3, [r7, #0xc]
 801f26e: 2b00         	cmp	r3, #0x0
 801f270: da01         	bge	0x801f276 <set_up_plls+0xba> @ imm = #0x2
; 		return r;
 801f272: 68fb         	ldr	r3, [r7, #0xc]
 801f274: e06b         	b	0x801f34e <set_up_plls+0x192> @ imm = #0xd6
; 	vco_output_range = get_vco_output_range(vco_input_range);
 801f276: 687b         	ldr	r3, [r7, #0x4]
 801f278: 4618         	mov	r0, r3
 801f27a: f7ff feff    	bl	0x801f07c <get_vco_output_range> @ imm = #-0x202
 801f27e: 60b8         	str	r0, [r7, #0x8]
; 	LL_RCC_PLL2_SetM(STM32_PLL2_M_DIVISOR);
 801f280: 2020         	movs	r0, #0x20
 801f282: f7eb fae3    	bl	0x800a84c <LL_RCC_PLL2_SetM> @ imm = #-0x14a3a
; 	LL_RCC_PLL2_SetVCOInputRange(vco_input_range);
 801f286: 687b         	ldr	r3, [r7, #0x4]
 801f288: 4618         	mov	r0, r3
 801f28a: f7eb fab1    	bl	0x800a7f0 <LL_RCC_PLL2_SetVCOInputRange> @ imm = #-0x14a9e
; 	LL_RCC_PLL2_SetVCOOutputRange(vco_output_range);
 801f28e: 68b8         	ldr	r0, [r7, #0x8]
 801f290: f7eb fa98    	bl	0x800a7c4 <LL_RCC_PLL2_SetVCOOutputRange> @ imm = #-0x14ad0
; 	LL_RCC_PLL2_SetN(STM32_PLL2_N_MULTIPLIER);
 801f294: 2081         	movs	r0, #0x81
 801f296: f7eb fac1    	bl	0x800a81c <LL_RCC_PLL2_SetN> @ imm = #-0x14a7e
; 	LL_RCC_PLL2FRACN_Disable();
 801f29a: f7eb fa83    	bl	0x800a7a4 <LL_RCC_PLL2FRACN_Disable> @ imm = #-0x14afa
; 		LL_RCC_PLL2_SetFRACN(STM32_PLL2_FRACN_VALUE);
 801f29e: 2000         	movs	r0, #0x0
 801f2a0: f7eb fb2c    	bl	0x800a8fc <LL_RCC_PLL2_SetFRACN> @ imm = #-0x149a8
; 		LL_RCC_PLL2FRACN_Enable();
 801f2a4: f7eb fa6e    	bl	0x800a784 <LL_RCC_PLL2FRACN_Enable> @ imm = #-0x14b24
; 		LL_RCC_PLL2_SetP(STM32_PLL2_P_DIVISOR);
 801f2a8: 2002         	movs	r0, #0x2
 801f2aa: f7eb fae5    	bl	0x800a878 <LL_RCC_PLL2_SetP> @ imm = #-0x14a36
; 		LL_RCC_PLL2P_Enable();
 801f2ae: f7eb fa39    	bl	0x800a724 <LL_RCC_PLL2P_Enable> @ imm = #-0x14b8e
; 		LL_RCC_PLL2_SetQ(STM32_PLL2_Q_DIVISOR);
 801f2b2: 2002         	movs	r0, #0x2
 801f2b4: f7eb faf6    	bl	0x800a8a4 <LL_RCC_PLL2_SetQ> @ imm = #-0x14a14
; 		LL_RCC_PLL2Q_Enable();
 801f2b8: f7eb fa44    	bl	0x800a744 <LL_RCC_PLL2Q_Enable> @ imm = #-0x14b78
; 		LL_RCC_PLL2_SetR(STM32_PLL2_R_DIVISOR);
 801f2bc: 2002         	movs	r0, #0x2
 801f2be: f7eb fb07    	bl	0x800a8d0 <LL_RCC_PLL2_SetR> @ imm = #-0x149f2
; 		LL_RCC_PLL2R_Enable();
 801f2c2: f7eb fa4f    	bl	0x800a764 <LL_RCC_PLL2R_Enable> @ imm = #-0x14b62
; 	LL_RCC_PLL2_Enable();
 801f2c6: f7eb f9f9    	bl	0x800a6bc <LL_RCC_PLL2_Enable> @ imm = #-0x14c0e
; 	while (LL_RCC_PLL2_IsReady() != 1U) {
 801f2ca: bf00         	nop
 801f2cc: f7eb fa16    	bl	0x800a6fc <LL_RCC_PLL2_IsReady> @ imm = #-0x14bd4
 801f2d0: 4603         	mov	r3, r0
 801f2d2: 2b01         	cmp	r3, #0x1
 801f2d4: d1fa         	bne	0x801f2cc <set_up_plls+0x110> @ imm = #-0xc
; 	r = get_vco_input_range(STM32_PLL3_M_DIVISOR, &vco_input_range);
 801f2d6: 1d3b         	adds	r3, r7, #0x4
 801f2d8: 4619         	mov	r1, r3
 801f2da: 2020         	movs	r0, #0x20
 801f2dc: f7eb fcde    	bl	0x800ac9c <get_vco_input_range> @ imm = #-0x14644
 801f2e0: 60f8         	str	r0, [r7, #0xc]
; 	if (r < 0) {
 801f2e2: 68fb         	ldr	r3, [r7, #0xc]
 801f2e4: 2b00         	cmp	r3, #0x0
 801f2e6: da01         	bge	0x801f2ec <set_up_plls+0x130> @ imm = #0x2
; 		return r;
 801f2e8: 68fb         	ldr	r3, [r7, #0xc]
 801f2ea: e030         	b	0x801f34e <set_up_plls+0x192> @ imm = #0x60
; 	vco_output_range = get_vco_output_range(vco_input_range);
 801f2ec: 687b         	ldr	r3, [r7, #0x4]
 801f2ee: 4618         	mov	r0, r3
 801f2f0: f7ff fec4    	bl	0x801f07c <get_vco_output_range> @ imm = #-0x278
 801f2f4: 60b8         	str	r0, [r7, #0x8]
; 	LL_RCC_PLL3_SetM(STM32_PLL3_M_DIVISOR);
 801f2f6: 2020         	movs	r0, #0x20
 801f2f8: f7eb fbe0    	bl	0x800aabc <LL_RCC_PLL3_SetM> @ imm = #-0x14840
; 	LL_RCC_PLL3_SetVCOInputRange(vco_input_range);
 801f2fc: 687b         	ldr	r3, [r7, #0x4]
 801f2fe: 4618         	mov	r0, r3
 801f300: f7eb fbae    	bl	0x800aa60 <LL_RCC_PLL3_SetVCOInputRange> @ imm = #-0x148a4
; 	LL_RCC_PLL3_SetVCOOutputRange(vco_output_range);
 801f304: 68b8         	ldr	r0, [r7, #0x8]
 801f306: f7eb fb95    	bl	0x800aa34 <LL_RCC_PLL3_SetVCOOutputRange> @ imm = #-0x148d6
; 	LL_RCC_PLL3_SetN(STM32_PLL3_N_MULTIPLIER);
 801f30a: 2081         	movs	r0, #0x81
 801f30c: f7eb fbbe    	bl	0x800aa8c <LL_RCC_PLL3_SetN> @ imm = #-0x14884
; 	LL_RCC_PLL3FRACN_Disable();
 801f310: f7eb fb80    	bl	0x800aa14 <LL_RCC_PLL3FRACN_Disable> @ imm = #-0x14900
; 		LL_RCC_PLL3_SetFRACN(STM32_PLL3_FRACN_VALUE);
 801f314: 2000         	movs	r0, #0x0
 801f316: f7eb fc29    	bl	0x800ab6c <LL_RCC_PLL3_SetFRACN> @ imm = #-0x147ae
; 		LL_RCC_PLL3FRACN_Enable();
 801f31a: f7eb fb6b    	bl	0x800a9f4 <LL_RCC_PLL3FRACN_Enable> @ imm = #-0x1492a
; 		LL_RCC_PLL3_SetP(STM32_PLL3_P_DIVISOR);
 801f31e: 2002         	movs	r0, #0x2
 801f320: f7eb fbe2    	bl	0x800aae8 <LL_RCC_PLL3_SetP> @ imm = #-0x1483c
; 		LL_RCC_PLL3P_Enable();
 801f324: f7eb fb36    	bl	0x800a994 <LL_RCC_PLL3P_Enable> @ imm = #-0x14994
; 		LL_RCC_PLL3_SetQ(STM32_PLL3_Q_DIVISOR);
 801f328: 2002         	movs	r0, #0x2
 801f32a: f7eb fbf3    	bl	0x800ab14 <LL_RCC_PLL3_SetQ> @ imm = #-0x1481a
; 		LL_RCC_PLL3Q_Enable();
 801f32e: f7eb fb41    	bl	0x800a9b4 <LL_RCC_PLL3Q_Enable> @ imm = #-0x1497e
; 		LL_RCC_PLL3_SetR(STM32_PLL3_R_DIVISOR);
 801f332: 2002         	movs	r0, #0x2
 801f334: f7eb fc04    	bl	0x800ab40 <LL_RCC_PLL3_SetR> @ imm = #-0x147f8
; 		LL_RCC_PLL3R_Enable();
 801f338: f7eb fb4c    	bl	0x800a9d4 <LL_RCC_PLL3R_Enable> @ imm = #-0x14968
; 	LL_RCC_PLL3_Enable();
 801f33c: f7eb faf6    	bl	0x800a92c <LL_RCC_PLL3_Enable> @ imm = #-0x14a14
; 	while (LL_RCC_PLL3_IsReady() != 1U) {
 801f340: bf00         	nop
 801f342: f7eb fb13    	bl	0x800a96c <LL_RCC_PLL3_IsReady> @ imm = #-0x149da
 801f346: 4603         	mov	r3, r0
 801f348: 2b01         	cmp	r3, #0x1
 801f34a: d1fa         	bne	0x801f342 <set_up_plls+0x186> @ imm = #-0xc
; 	return 0;
 801f34c: 2300         	movs	r3, #0x0
; }
 801f34e: 4618         	mov	r0, r3
 801f350: 3710         	adds	r7, #0x10
 801f352: 46bd         	mov	sp, r7
 801f354: bd80         	pop	{r7, pc}

0801f356 <device_is_ready>:
; {
 801f356: b580         	push	{r7, lr}
 801f358: b082         	sub	sp, #0x8
 801f35a: af00         	add	r7, sp, #0x0
 801f35c: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801f35e: 6878         	ldr	r0, [r7, #0x4]
 801f360: f007 f81d    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x703a
 801f364: 4603         	mov	r3, r0
; }
 801f366: 4618         	mov	r0, r3
 801f368: 3708         	adds	r7, #0x8
 801f36a: 46bd         	mov	sp, r7
 801f36c: bd80         	pop	{r7, pc}

0801f36e <z_impl_uart_poll_out>:
; {
 801f36e: b580         	push	{r7, lr}
 801f370: b084         	sub	sp, #0x10
 801f372: af00         	add	r7, sp, #0x0
 801f374: 6078         	str	r0, [r7, #0x4]
 801f376: 460b         	mov	r3, r1
 801f378: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 801f37a: 687b         	ldr	r3, [r7, #0x4]
 801f37c: 689b         	ldr	r3, [r3, #0x8]
 801f37e: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 801f380: 68fb         	ldr	r3, [r7, #0xc]
 801f382: 69db         	ldr	r3, [r3, #0x1c]
 801f384: 78fa         	ldrb	r2, [r7, #0x3]
 801f386: 4611         	mov	r1, r2
 801f388: 6878         	ldr	r0, [r7, #0x4]
 801f38a: 4798         	blx	r3
; }
 801f38c: bf00         	nop
 801f38e: 3710         	adds	r7, #0x10
 801f390: 46bd         	mov	sp, r7
 801f392: bd80         	pop	{r7, pc}

0801f394 <uart_poll_out>:
; {
 801f394: b580         	push	{r7, lr}
 801f396: b082         	sub	sp, #0x8
 801f398: af00         	add	r7, sp, #0x0
 801f39a: 6078         	str	r0, [r7, #0x4]
 801f39c: 460b         	mov	r3, r1
 801f39e: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 801f3a0: 78fb         	ldrb	r3, [r7, #0x3]
 801f3a2: 4619         	mov	r1, r3
 801f3a4: 6878         	ldr	r0, [r7, #0x4]
 801f3a6: f7ff ffe2    	bl	0x801f36e <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 801f3aa: bf00         	nop
 801f3ac: 3708         	adds	r7, #0x8
 801f3ae: 46bd         	mov	sp, r7
 801f3b0: bd80         	pop	{r7, pc}

0801f3b2 <pm_device_runtime_get>:
; {
 801f3b2: b480         	push	{r7}
 801f3b4: b083         	sub	sp, #0xc
 801f3b6: af00         	add	r7, sp, #0x0
 801f3b8: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801f3ba: 2300         	movs	r3, #0x0
; }
 801f3bc: 4618         	mov	r0, r3
 801f3be: 370c         	adds	r7, #0xc
 801f3c0: 46bd         	mov	sp, r7
 801f3c2: f85d 7b04    	ldr	r7, [sp], #4
 801f3c6: 4770         	bx	lr

0801f3c8 <pm_device_runtime_put_async>:
; {
 801f3c8: b480         	push	{r7}
 801f3ca: b085         	sub	sp, #0x14
 801f3cc: af00         	add	r7, sp, #0x0
 801f3ce: 60f8         	str	r0, [r7, #0xc]
 801f3d0: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 801f3d4: 2300         	movs	r3, #0x0
; }
 801f3d6: 4618         	mov	r0, r3
 801f3d8: 3714         	adds	r7, #0x14
 801f3da: 46bd         	mov	sp, r7
 801f3dc: f85d 7b04    	ldr	r7, [sp], #4
 801f3e0: 4770         	bx	lr

0801f3e2 <device_is_ready>:
; {
 801f3e2: b580         	push	{r7, lr}
 801f3e4: b082         	sub	sp, #0x8
 801f3e6: af00         	add	r7, sp, #0x0
 801f3e8: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801f3ea: 6878         	ldr	r0, [r7, #0x4]
 801f3ec: f006 ffd7    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x6fae
 801f3f0: 4603         	mov	r3, r0
; }
 801f3f2: 4618         	mov	r0, r3
 801f3f4: 3708         	adds	r7, #0x8
 801f3f6: 46bd         	mov	sp, r7
 801f3f8: bd80         	pop	{r7, pc}

0801f3fa <k_sleep>:
; {
 801f3fa: b580         	push	{r7, lr}
 801f3fc: b082         	sub	sp, #0x8
 801f3fe: af00         	add	r7, sp, #0x0
 801f400: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 801f404: e9d7 0100    	ldrd	r0, r1, [r7]
 801f408: f7f8 f9b0    	bl	0x801776c <z_impl_k_sleep> @ imm = #-0x7ca0
 801f40c: 4603         	mov	r3, r0
; }
 801f40e: 4618         	mov	r0, r3
 801f410: 3708         	adds	r7, #0x8
 801f412: 46bd         	mov	sp, r7
 801f414: bd80         	pop	{r7, pc}

0801f416 <clock_control_on>:
; {
 801f416: b580         	push	{r7, lr}
 801f418: b084         	sub	sp, #0x10
 801f41a: af00         	add	r7, sp, #0x0
 801f41c: 6078         	str	r0, [r7, #0x4]
 801f41e: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801f420: 687b         	ldr	r3, [r7, #0x4]
 801f422: 689b         	ldr	r3, [r3, #0x8]
 801f424: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801f426: 68fb         	ldr	r3, [r7, #0xc]
 801f428: 681b         	ldr	r3, [r3]
 801f42a: 6839         	ldr	r1, [r7]
 801f42c: 6878         	ldr	r0, [r7, #0x4]
 801f42e: 4798         	blx	r3
 801f430: 4603         	mov	r3, r0
; }
 801f432: 4618         	mov	r0, r3
 801f434: 3710         	adds	r7, #0x10
 801f436: 46bd         	mov	sp, r7
 801f438: bd80         	pop	{r7, pc}

0801f43a <z_log_msg_runtime_create>:
; {
 801f43a: b580         	push	{r7, lr}
 801f43c: b08a         	sub	sp, #0x28
 801f43e: af04         	add	r7, sp, #0x10
 801f440: 60b9         	str	r1, [r7, #0x8]
 801f442: 607b         	str	r3, [r7, #0x4]
 801f444: 4603         	mov	r3, r0
 801f446: 73fb         	strb	r3, [r7, #0xf]
 801f448: 4613         	mov	r3, r2
 801f44a: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801f44c: f107 032c    	add.w	r3, r7, #0x2c
 801f450: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801f452: 7bba         	ldrb	r2, [r7, #0xe]
 801f454: 7bf8         	ldrb	r0, [r7, #0xf]
 801f456: 697b         	ldr	r3, [r7, #0x14]
 801f458: 9303         	str	r3, [sp, #0xc]
 801f45a: 6abb         	ldr	r3, [r7, #0x28]
 801f45c: 9302         	str	r3, [sp, #0x8]
 801f45e: 6a7b         	ldr	r3, [r7, #0x24]
 801f460: 9301         	str	r3, [sp, #0x4]
 801f462: 6a3b         	ldr	r3, [r7, #0x20]
 801f464: 9300         	str	r3, [sp]
 801f466: 687b         	ldr	r3, [r7, #0x4]
 801f468: 68b9         	ldr	r1, [r7, #0x8]
 801f46a: f7e5 fb83    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1a8fa
; }
 801f46e: bf00         	nop
 801f470: 3718         	adds	r7, #0x18
 801f472: 46bd         	mov	sp, r7
 801f474: bd80         	pop	{r7, pc}

0801f476 <dma_stm32_dump_stream_irq>:
; {
 801f476: b580         	push	{r7, lr}
 801f478: b084         	sub	sp, #0x10
 801f47a: af00         	add	r7, sp, #0x0
 801f47c: 6078         	str	r0, [r7, #0x4]
 801f47e: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801f480: 687b         	ldr	r3, [r7, #0x4]
 801f482: 685b         	ldr	r3, [r3, #0x4]
 801f484: 60fb         	str	r3, [r7, #0xc]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801f486: 68fb         	ldr	r3, [r7, #0xc]
 801f488: 691b         	ldr	r3, [r3, #0x10]
 801f48a: 60bb         	str	r3, [r7, #0x8]
; 	stm32_dma_dump_stream_irq(dma, id);
 801f48c: 6839         	ldr	r1, [r7]
 801f48e: 68b8         	ldr	r0, [r7, #0x8]
 801f490: f7ed f8b4    	bl	0x800c5fc <stm32_dma_dump_stream_irq> @ imm = #-0x12e98
; }
 801f494: bf00         	nop
 801f496: 3710         	adds	r7, #0x10
 801f498: 46bd         	mov	sp, r7
 801f49a: bd80         	pop	{r7, pc}

0801f49c <dma_stm32_clear_stream_irq>:
; {
 801f49c: b580         	push	{r7, lr}
 801f49e: b084         	sub	sp, #0x10
 801f4a0: af00         	add	r7, sp, #0x0
 801f4a2: 6078         	str	r0, [r7, #0x4]
 801f4a4: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801f4a6: 687b         	ldr	r3, [r7, #0x4]
 801f4a8: 685b         	ldr	r3, [r3, #0x4]
 801f4aa: 60fb         	str	r3, [r7, #0xc]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801f4ac: 68fb         	ldr	r3, [r7, #0xc]
 801f4ae: 691b         	ldr	r3, [r3, #0x10]
 801f4b0: 60bb         	str	r3, [r7, #0x8]
; 	dma_stm32_clear_tc(dma, id);
 801f4b2: 6839         	ldr	r1, [r7]
 801f4b4: 68b8         	ldr	r0, [r7, #0x8]
 801f4b6: f7ec ffe1    	bl	0x800c47c <dma_stm32_clear_tc> @ imm = #-0x1303e
; 	dma_stm32_clear_ht(dma, id);
 801f4ba: 6839         	ldr	r1, [r7]
 801f4bc: 68b8         	ldr	r0, [r7, #0x8]
 801f4be: f7ec ffcb    	bl	0x800c458 <dma_stm32_clear_ht> @ imm = #-0x1306a
; 	stm32_dma_clear_stream_irq(dma, id);
 801f4c2: 6839         	ldr	r1, [r7]
 801f4c4: 68b8         	ldr	r0, [r7, #0x8]
 801f4c6: f001 f846    	bl	0x8020556 <stm32_dma_clear_stream_irq> @ imm = #0x108c
; }
 801f4ca: bf00         	nop
 801f4cc: 3710         	adds	r7, #0x10
 801f4ce: 46bd         	mov	sp, r7
 801f4d0: bd80         	pop	{r7, pc}

0801f4d2 <dma_stm32_disable_stream>:
; {
 801f4d2: b580         	push	{r7, lr}
 801f4d4: b084         	sub	sp, #0x10
 801f4d6: af00         	add	r7, sp, #0x0
 801f4d8: 6078         	str	r0, [r7, #0x4]
 801f4da: 6039         	str	r1, [r7]
; 	int count = 0;
 801f4dc: 2300         	movs	r3, #0x0
 801f4de: 60fb         	str	r3, [r7, #0xc]
; 		if (stm32_dma_disable_stream(dma, id) == 0) {
 801f4e0: 6839         	ldr	r1, [r7]
 801f4e2: 6878         	ldr	r0, [r7, #0x4]
 801f4e4: f001 f874    	bl	0x80205d0 <stm32_dma_disable_stream> @ imm = #0x10e8
 801f4e8: 4603         	mov	r3, r0
 801f4ea: 2b00         	cmp	r3, #0x0
 801f4ec: d101         	bne	0x801f4f2 <dma_stm32_disable_stream+0x20> @ imm = #0x2
; 			return 0;
 801f4ee: 2100         	movs	r1, #0x0
 801f4f0: e012         	b	0x801f518 <dma_stm32_disable_stream+0x46> @ imm = #0x24
; 		if (count++ > (5 * 1000)) {
 801f4f2: 68fb         	ldr	r3, [r7, #0xc]
 801f4f4: 1c5a         	adds	r2, r3, #0x1
 801f4f6: 60fa         	str	r2, [r7, #0xc]
 801f4f8: f241 3288    	movw	r2, #0x1388
 801f4fc: 4293         	cmp	r3, r2
 801f4fe: dd02         	ble	0x801f506 <dma_stm32_disable_stream+0x34> @ imm = #0x4
; 			return -EBUSY;
 801f500: f06f 010f    	mvn	r1, #0xf
 801f504: e008         	b	0x801f518 <dma_stm32_disable_stream+0x46> @ imm = #0x10
; 		k_sleep(K_MSEC(1));
 801f506: f04f 020a    	mov.w	r2, #0xa
 801f50a: f04f 0300    	mov.w	r3, #0x0
 801f50e: 4610         	mov	r0, r2
 801f510: 4619         	mov	r1, r3
 801f512: f7ff ff72    	bl	0x801f3fa <k_sleep>     @ imm = #-0x11c
; 	for (;;) {
 801f516: e7e3         	b	0x801f4e0 <dma_stm32_disable_stream+0xe> @ imm = #-0x3a
; }
 801f518: 460b         	mov	r3, r1
 801f51a: 4618         	mov	r0, r3
 801f51c: 3710         	adds	r7, #0x10
 801f51e: 46bd         	mov	sp, r7
 801f520: bd80         	pop	{r7, pc}

0801f522 <dma_stm32_reload>:
; {
 801f522: b580         	push	{r7, lr}
 801f524: b088         	sub	sp, #0x20
 801f526: af00         	add	r7, sp, #0x0
 801f528: 60f8         	str	r0, [r7, #0xc]
 801f52a: 60b9         	str	r1, [r7, #0x8]
 801f52c: 607a         	str	r2, [r7, #0x4]
 801f52e: 603b         	str	r3, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801f530: 68fb         	ldr	r3, [r7, #0xc]
 801f532: 685b         	ldr	r3, [r3, #0x4]
 801f534: 61fb         	str	r3, [r7, #0x1c]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801f536: 69fb         	ldr	r3, [r7, #0x1c]
 801f538: 691b         	ldr	r3, [r3, #0x10]
 801f53a: 61bb         	str	r3, [r7, #0x18]
; 	id = id - STM32_DMA_STREAM_OFFSET;
 801f53c: 68bb         	ldr	r3, [r7, #0x8]
 801f53e: 3b01         	subs	r3, #0x1
 801f540: 60bb         	str	r3, [r7, #0x8]
; 	if (id >= config->max_streams) {
 801f542: 69fb         	ldr	r3, [r7, #0x1c]
 801f544: 695b         	ldr	r3, [r3, #0x14]
 801f546: 68ba         	ldr	r2, [r7, #0x8]
 801f548: 429a         	cmp	r2, r3
 801f54a: d302         	blo	0x801f552 <dma_stm32_reload+0x30> @ imm = #0x4
; 		return -EINVAL;
 801f54c: f06f 0315    	mvn	r3, #0x15
 801f550: e069         	b	0x801f626 <dma_stm32_reload+0x104> @ imm = #0xd2
; 	stream = &config->streams[id];
 801f552: 69fb         	ldr	r3, [r7, #0x1c]
 801f554: 69da         	ldr	r2, [r3, #0x1c]
 801f556: 68bb         	ldr	r3, [r7, #0x8]
 801f558: 015b         	lsls	r3, r3, #0x5
 801f55a: 4413         	add	r3, r2
 801f55c: 617b         	str	r3, [r7, #0x14]
; 	if (dma_stm32_disable_stream(dma, id) != 0) {
 801f55e: 68b9         	ldr	r1, [r7, #0x8]
 801f560: 69b8         	ldr	r0, [r7, #0x18]
 801f562: f7ff ffb6    	bl	0x801f4d2 <dma_stm32_disable_stream> @ imm = #-0x94
 801f566: 4603         	mov	r3, r0
 801f568: 2b00         	cmp	r3, #0x0
 801f56a: d002         	beq	0x801f572 <dma_stm32_reload+0x50> @ imm = #0x4
; 		return -EBUSY;
 801f56c: f06f 030f    	mvn	r3, #0xf
 801f570: e059         	b	0x801f626 <dma_stm32_reload+0x104> @ imm = #0xb2
; 	switch (stream->direction) {
 801f572: 697b         	ldr	r3, [r7, #0x14]
 801f574: 681b         	ldr	r3, [r3]
 801f576: 2b02         	cmp	r3, #0x2
 801f578: d018         	beq	0x801f5ac <dma_stm32_reload+0x8a> @ imm = #0x30
 801f57a: 2b02         	cmp	r3, #0x2
 801f57c: d829         	bhi	0x801f5d2 <dma_stm32_reload+0xb0> @ imm = #0x52
 801f57e: 2b00         	cmp	r3, #0x0
 801f580: d014         	beq	0x801f5ac <dma_stm32_reload+0x8a> @ imm = #0x28
 801f582: 2b01         	cmp	r3, #0x1
 801f584: d125         	bne	0x801f5d2 <dma_stm32_reload+0xb0> @ imm = #0x4a
; 		LL_DMA_SetMemoryAddress(dma, dma_stm32_id_to_stream(id), src);
 801f586: 68b8         	ldr	r0, [r7, #0x8]
 801f588: f7ec ff56    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x13154
 801f58c: 4603         	mov	r3, r0
 801f58e: 687a         	ldr	r2, [r7, #0x4]
 801f590: 4619         	mov	r1, r3
 801f592: 69b8         	ldr	r0, [r7, #0x18]
 801f594: f7eb ff0a    	bl	0x800b3ac <LL_DMA_SetMemoryAddress> @ imm = #-0x141ec
; 		LL_DMA_SetPeriphAddress(dma, dma_stm32_id_to_stream(id), dst);
 801f598: 68b8         	ldr	r0, [r7, #0x8]
 801f59a: f7ec ff4d    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x13166
 801f59e: 4603         	mov	r3, r0
 801f5a0: 683a         	ldr	r2, [r7]
 801f5a2: 4619         	mov	r1, r3
 801f5a4: 69b8         	ldr	r0, [r7, #0x18]
 801f5a6: f7eb ff1b    	bl	0x800b3e0 <LL_DMA_SetPeriphAddress> @ imm = #-0x141ca
; 		break;
 801f5aa: e015         	b	0x801f5d8 <dma_stm32_reload+0xb6> @ imm = #0x2a
; 		LL_DMA_SetPeriphAddress(dma, dma_stm32_id_to_stream(id), src);
 801f5ac: 68b8         	ldr	r0, [r7, #0x8]
 801f5ae: f7ec ff43    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x1317a
 801f5b2: 4603         	mov	r3, r0
 801f5b4: 687a         	ldr	r2, [r7, #0x4]
 801f5b6: 4619         	mov	r1, r3
 801f5b8: 69b8         	ldr	r0, [r7, #0x18]
 801f5ba: f7eb ff11    	bl	0x800b3e0 <LL_DMA_SetPeriphAddress> @ imm = #-0x141de
; 		LL_DMA_SetMemoryAddress(dma, dma_stm32_id_to_stream(id), dst);
 801f5be: 68b8         	ldr	r0, [r7, #0x8]
 801f5c0: f7ec ff3a    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x1318c
 801f5c4: 4603         	mov	r3, r0
 801f5c6: 683a         	ldr	r2, [r7]
 801f5c8: 4619         	mov	r1, r3
 801f5ca: 69b8         	ldr	r0, [r7, #0x18]
 801f5cc: f7eb feee    	bl	0x800b3ac <LL_DMA_SetMemoryAddress> @ imm = #-0x14224
; 		break;
 801f5d0: e002         	b	0x801f5d8 <dma_stm32_reload+0xb6> @ imm = #0x4
; 		return -EINVAL;
 801f5d2: f06f 0315    	mvn	r3, #0x15
 801f5d6: e026         	b	0x801f626 <dma_stm32_reload+0x104> @ imm = #0x4c
; 	if (stream->source_periph) {
 801f5d8: 697b         	ldr	r3, [r7, #0x14]
 801f5da: 7a1b         	ldrb	r3, [r3, #0x8]
 801f5dc: 2b00         	cmp	r3, #0x0
 801f5de: d00d         	beq	0x801f5fc <dma_stm32_reload+0xda> @ imm = #0x1a
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 801f5e0: 68b8         	ldr	r0, [r7, #0x8]
 801f5e2: f7ec ff29    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x131ae
 801f5e6: 4601         	mov	r1, r0
; 				     size / stream->src_size);
 801f5e8: 697b         	ldr	r3, [r7, #0x14]
 801f5ea: 68db         	ldr	r3, [r3, #0xc]
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 801f5ec: 6aba         	ldr	r2, [r7, #0x28]
 801f5ee: fbb2 f3f3    	udiv	r3, r2, r3
 801f5f2: 461a         	mov	r2, r3
 801f5f4: 69b8         	ldr	r0, [r7, #0x18]
 801f5f6: f7eb fe55    	bl	0x800b2a4 <LL_DMA_SetDataLength> @ imm = #-0x14356
 801f5fa: e00c         	b	0x801f616 <dma_stm32_reload+0xf4> @ imm = #0x18
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 801f5fc: 68b8         	ldr	r0, [r7, #0x8]
 801f5fe: f7ec ff1b    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x131ca
 801f602: 4601         	mov	r1, r0
; 				     size / stream->dst_size);
 801f604: 697b         	ldr	r3, [r7, #0x14]
 801f606: 691b         	ldr	r3, [r3, #0x10]
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 801f608: 6aba         	ldr	r2, [r7, #0x28]
 801f60a: fbb2 f3f3    	udiv	r3, r2, r3
 801f60e: 461a         	mov	r2, r3
 801f610: 69b8         	ldr	r0, [r7, #0x18]
 801f612: f7eb fe47    	bl	0x800b2a4 <LL_DMA_SetDataLength> @ imm = #-0x14372
; 	stream->busy = true;
 801f616: 697b         	ldr	r3, [r7, #0x14]
 801f618: 2201         	movs	r2, #0x1
 801f61a: 729a         	strb	r2, [r3, #0xa]
; 	stm32_dma_enable_stream(dma, id);
 801f61c: 68b9         	ldr	r1, [r7, #0x8]
 801f61e: 69b8         	ldr	r0, [r7, #0x18]
 801f620: f000 ffae    	bl	0x8020580 <stm32_dma_enable_stream> @ imm = #0xf5c
; 	return 0;
 801f624: 2300         	movs	r3, #0x0
; }
 801f626: 4618         	mov	r0, r3
 801f628: 3720         	adds	r7, #0x20
 801f62a: 46bd         	mov	sp, r7
 801f62c: bd80         	pop	{r7, pc}

0801f62e <dma_stm32_start>:
; {
 801f62e: b580         	push	{r7, lr}
 801f630: b086         	sub	sp, #0x18
 801f632: af00         	add	r7, sp, #0x0
 801f634: 6078         	str	r0, [r7, #0x4]
 801f636: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801f638: 687b         	ldr	r3, [r7, #0x4]
 801f63a: 685b         	ldr	r3, [r3, #0x4]
 801f63c: 617b         	str	r3, [r7, #0x14]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801f63e: 697b         	ldr	r3, [r7, #0x14]
 801f640: 691b         	ldr	r3, [r3, #0x10]
 801f642: 613b         	str	r3, [r7, #0x10]
; 	id = id - STM32_DMA_STREAM_OFFSET;
 801f644: 683b         	ldr	r3, [r7]
 801f646: 3b01         	subs	r3, #0x1
 801f648: 603b         	str	r3, [r7]
; 	if (id >= config->max_streams) {
 801f64a: 697b         	ldr	r3, [r7, #0x14]
 801f64c: 695b         	ldr	r3, [r3, #0x14]
 801f64e: 683a         	ldr	r2, [r7]
 801f650: 429a         	cmp	r2, r3
 801f652: d302         	blo	0x801f65a <dma_stm32_start+0x2c> @ imm = #0x4
; 		return -EINVAL;
 801f654: f06f 0315    	mvn	r3, #0x15
 801f658: e01a         	b	0x801f690 <dma_stm32_start+0x62> @ imm = #0x34
; 	if (stm32_dma_is_enabled_stream(dma, id)) {
 801f65a: 6839         	ldr	r1, [r7]
 801f65c: 6938         	ldr	r0, [r7, #0x10]
 801f65e: f000 ffa0    	bl	0x80205a2 <stm32_dma_is_enabled_stream> @ imm = #0xf40
 801f662: 4603         	mov	r3, r0
 801f664: 2b00         	cmp	r3, #0x0
 801f666: d001         	beq	0x801f66c <dma_stm32_start+0x3e> @ imm = #0x2
; 		return 0;
 801f668: 2300         	movs	r3, #0x0
 801f66a: e011         	b	0x801f690 <dma_stm32_start+0x62> @ imm = #0x22
; 	stream = &config->streams[id];
 801f66c: 697b         	ldr	r3, [r7, #0x14]
 801f66e: 69da         	ldr	r2, [r3, #0x1c]
 801f670: 683b         	ldr	r3, [r7]
 801f672: 015b         	lsls	r3, r3, #0x5
 801f674: 4413         	add	r3, r2
 801f676: 60fb         	str	r3, [r7, #0xc]
; 	stream->busy = true;
 801f678: 68fb         	ldr	r3, [r7, #0xc]
 801f67a: 2201         	movs	r2, #0x1
 801f67c: 729a         	strb	r2, [r3, #0xa]
; 	dma_stm32_clear_stream_irq(dev, id);
 801f67e: 6839         	ldr	r1, [r7]
 801f680: 6878         	ldr	r0, [r7, #0x4]
 801f682: f7ff ff0b    	bl	0x801f49c <dma_stm32_clear_stream_irq> @ imm = #-0x1ea
; 	stm32_dma_enable_stream(dma, id);
 801f686: 6839         	ldr	r1, [r7]
 801f688: 6938         	ldr	r0, [r7, #0x10]
 801f68a: f000 ff79    	bl	0x8020580 <stm32_dma_enable_stream> @ imm = #0xef2
; 	return 0;
 801f68e: 2300         	movs	r3, #0x0
; }
 801f690: 4618         	mov	r0, r3
 801f692: 3718         	adds	r7, #0x18
 801f694: 46bd         	mov	sp, r7
 801f696: bd80         	pop	{r7, pc}

0801f698 <dma_stm32_stop>:
; {
 801f698: b580         	push	{r7, lr}
 801f69a: b086         	sub	sp, #0x18
 801f69c: af00         	add	r7, sp, #0x0
 801f69e: 6078         	str	r0, [r7, #0x4]
 801f6a0: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801f6a2: 687b         	ldr	r3, [r7, #0x4]
 801f6a4: 685b         	ldr	r3, [r3, #0x4]
 801f6a6: 617b         	str	r3, [r7, #0x14]
; 	struct dma_stm32_stream *stream = &config->streams[id - STM32_DMA_STREAM_OFFSET];
 801f6a8: 697b         	ldr	r3, [r7, #0x14]
 801f6aa: 69da         	ldr	r2, [r3, #0x1c]
 801f6ac: 6839         	ldr	r1, [r7]
 801f6ae: f06f 4378    	mvn	r3, #0xf8000000
 801f6b2: 440b         	add	r3, r1
 801f6b4: 015b         	lsls	r3, r3, #0x5
 801f6b6: 4413         	add	r3, r2
 801f6b8: 613b         	str	r3, [r7, #0x10]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801f6ba: 697b         	ldr	r3, [r7, #0x14]
 801f6bc: 691b         	ldr	r3, [r3, #0x10]
 801f6be: 60fb         	str	r3, [r7, #0xc]
; 	id = id - STM32_DMA_STREAM_OFFSET;
 801f6c0: 683b         	ldr	r3, [r7]
 801f6c2: 3b01         	subs	r3, #0x1
 801f6c4: 603b         	str	r3, [r7]
; 	if (id >= config->max_streams) {
 801f6c6: 697b         	ldr	r3, [r7, #0x14]
 801f6c8: 695b         	ldr	r3, [r3, #0x14]
 801f6ca: 683a         	ldr	r2, [r7]
 801f6cc: 429a         	cmp	r2, r3
 801f6ce: d302         	blo	0x801f6d6 <dma_stm32_stop+0x3e> @ imm = #0x4
; 		return -EINVAL;
 801f6d0: f06f 0315    	mvn	r3, #0x15
 801f6d4: e02c         	b	0x801f730 <dma_stm32_stop+0x98> @ imm = #0x58
; 	if (stream->hal_override) {
 801f6d6: 693b         	ldr	r3, [r7, #0x10]
 801f6d8: 7a5b         	ldrb	r3, [r3, #0x9]
 801f6da: 2b00         	cmp	r3, #0x0
 801f6dc: d004         	beq	0x801f6e8 <dma_stm32_stop+0x50> @ imm = #0x8
; 		stream->busy = false;
 801f6de: 693b         	ldr	r3, [r7, #0x10]
 801f6e0: 2200         	movs	r2, #0x0
 801f6e2: 729a         	strb	r2, [r3, #0xa]
; 		return 0;
 801f6e4: 2300         	movs	r3, #0x0
 801f6e6: e023         	b	0x801f730 <dma_stm32_stop+0x98> @ imm = #0x46
; 	if (!stm32_dma_is_enabled_stream(dma, id)) {
 801f6e8: 6839         	ldr	r1, [r7]
 801f6ea: 68f8         	ldr	r0, [r7, #0xc]
 801f6ec: f000 ff59    	bl	0x80205a2 <stm32_dma_is_enabled_stream> @ imm = #0xeb2
 801f6f0: 4603         	mov	r3, r0
 801f6f2: f083 0301    	eor	r3, r3, #0x1
 801f6f6: b2db         	uxtb	r3, r3
 801f6f8: 2b00         	cmp	r3, #0x0
 801f6fa: d001         	beq	0x801f700 <dma_stm32_stop+0x68> @ imm = #0x2
; 		return 0;
 801f6fc: 2300         	movs	r3, #0x0
 801f6fe: e017         	b	0x801f730 <dma_stm32_stop+0x98> @ imm = #0x2e
; 	LL_DMA_DisableIT_TC(dma, dma_stm32_id_to_stream(id));
 801f700: 6838         	ldr	r0, [r7]
 801f702: f7ec fe99    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x132ce
 801f706: 4603         	mov	r3, r0
 801f708: 4619         	mov	r1, r3
 801f70a: 68f8         	ldr	r0, [r7, #0xc]
 801f70c: f7eb fee8    	bl	0x800b4e0 <LL_DMA_DisableIT_TC> @ imm = #-0x14230
; 	stm32_dma_disable_fifo_irq(dma, id);
 801f710: 6839         	ldr	r1, [r7]
 801f712: 68f8         	ldr	r0, [r7, #0xc]
 801f714: f000 ff7a    	bl	0x802060c <stm32_dma_disable_fifo_irq> @ imm = #0xef4
; 	dma_stm32_clear_stream_irq(dev, id);
 801f718: 6839         	ldr	r1, [r7]
 801f71a: 6878         	ldr	r0, [r7, #0x4]
 801f71c: f7ff febe    	bl	0x801f49c <dma_stm32_clear_stream_irq> @ imm = #-0x284
; 	dma_stm32_disable_stream(dma, id);
 801f720: 6839         	ldr	r1, [r7]
 801f722: 68f8         	ldr	r0, [r7, #0xc]
 801f724: f7ff fed5    	bl	0x801f4d2 <dma_stm32_disable_stream> @ imm = #-0x256
; 	stream->busy = false;
 801f728: 693b         	ldr	r3, [r7, #0x10]
 801f72a: 2200         	movs	r2, #0x0
 801f72c: 729a         	strb	r2, [r3, #0xa]
; 	return 0;
 801f72e: 2300         	movs	r3, #0x0
; }
 801f730: 4618         	mov	r0, r3
 801f732: 3718         	adds	r7, #0x18
 801f734: 46bd         	mov	sp, r7
 801f736: bd80         	pop	{r7, pc}

0801f738 <dma_stm32_get_status>:
; {
 801f738: b580         	push	{r7, lr}
 801f73a: b088         	sub	sp, #0x20
 801f73c: af00         	add	r7, sp, #0x0
 801f73e: 60f8         	str	r0, [r7, #0xc]
 801f740: 60b9         	str	r1, [r7, #0x8]
 801f742: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_stm32_config *config = dev->config;
 801f744: 68fb         	ldr	r3, [r7, #0xc]
 801f746: 685b         	ldr	r3, [r3, #0x4]
 801f748: 61fb         	str	r3, [r7, #0x1c]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801f74a: 69fb         	ldr	r3, [r7, #0x1c]
 801f74c: 691b         	ldr	r3, [r3, #0x10]
 801f74e: 61bb         	str	r3, [r7, #0x18]
; 	id = id - STM32_DMA_STREAM_OFFSET;
 801f750: 68bb         	ldr	r3, [r7, #0x8]
 801f752: 3b01         	subs	r3, #0x1
 801f754: 60bb         	str	r3, [r7, #0x8]
; 	if (id >= config->max_streams) {
 801f756: 69fb         	ldr	r3, [r7, #0x1c]
 801f758: 695b         	ldr	r3, [r3, #0x14]
 801f75a: 68ba         	ldr	r2, [r7, #0x8]
 801f75c: 429a         	cmp	r2, r3
 801f75e: d302         	blo	0x801f766 <dma_stm32_get_status+0x2e> @ imm = #0x4
; 		return -EINVAL;
 801f760: f06f 0315    	mvn	r3, #0x15
 801f764: e01b         	b	0x801f79e <dma_stm32_get_status+0x66> @ imm = #0x36
; 	stream = &config->streams[id];
 801f766: 69fb         	ldr	r3, [r7, #0x1c]
 801f768: 69da         	ldr	r2, [r3, #0x1c]
 801f76a: 68bb         	ldr	r3, [r7, #0x8]
 801f76c: 015b         	lsls	r3, r3, #0x5
 801f76e: 4413         	add	r3, r2
 801f770: 617b         	str	r3, [r7, #0x14]
; 	stat->pending_length = LL_DMA_GetDataLength(dma, dma_stm32_id_to_stream(id));
 801f772: 68b8         	ldr	r0, [r7, #0x8]
 801f774: f7ec fe60    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x13340
 801f778: 4603         	mov	r3, r0
 801f77a: 4619         	mov	r1, r3
 801f77c: 69b8         	ldr	r0, [r7, #0x18]
 801f77e: f7eb fdb9    	bl	0x800b2f4 <LL_DMA_GetDataLength> @ imm = #-0x1448e
 801f782: 4602         	mov	r2, r0
 801f784: 687b         	ldr	r3, [r7, #0x4]
 801f786: 605a         	str	r2, [r3, #0x4]
; 	stat->dir = stream->direction;
 801f788: 697b         	ldr	r3, [r7, #0x14]
 801f78a: 681b         	ldr	r3, [r3]
 801f78c: b2da         	uxtb	r2, r3
 801f78e: 687b         	ldr	r3, [r7, #0x4]
 801f790: 705a         	strb	r2, [r3, #0x1]
; 	stat->busy = stream->busy;
 801f792: 697b         	ldr	r3, [r7, #0x14]
 801f794: 7a9b         	ldrb	r3, [r3, #0xa]
 801f796: b2da         	uxtb	r2, r3
 801f798: 687b         	ldr	r3, [r7, #0x4]
 801f79a: 701a         	strb	r2, [r3]
; 	return 0;
 801f79c: 2300         	movs	r3, #0x0
; }
 801f79e: 4618         	mov	r0, r3
 801f7a0: 3720         	adds	r7, #0x20
 801f7a2: 46bd         	mov	sp, r7
 801f7a4: bd80         	pop	{r7, pc}

0801f7a6 <dma_stm32_irq_0_0>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 0);
 801f7a6: b580         	push	{r7, lr}
 801f7a8: b082         	sub	sp, #0x8
 801f7aa: af00         	add	r7, sp, #0x0
 801f7ac: 6078         	str	r0, [r7, #0x4]
 801f7ae: 2100         	movs	r1, #0x0
 801f7b0: 6878         	ldr	r0, [r7, #0x4]
 801f7b2: f7eb fed9    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x1424e
 801f7b6: 3708         	adds	r7, #0x8
 801f7b8: 46bd         	mov	sp, r7
 801f7ba: bd80         	pop	{r7, pc}

0801f7bc <dma_stm32_irq_0_1>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 1);
 801f7bc: b580         	push	{r7, lr}
 801f7be: b082         	sub	sp, #0x8
 801f7c0: af00         	add	r7, sp, #0x0
 801f7c2: 6078         	str	r0, [r7, #0x4]
 801f7c4: 2101         	movs	r1, #0x1
 801f7c6: 6878         	ldr	r0, [r7, #0x4]
 801f7c8: f7eb fece    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x14264
 801f7cc: 3708         	adds	r7, #0x8
 801f7ce: 46bd         	mov	sp, r7
 801f7d0: bd80         	pop	{r7, pc}

0801f7d2 <dma_stm32_irq_0_2>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 2);
 801f7d2: b580         	push	{r7, lr}
 801f7d4: b082         	sub	sp, #0x8
 801f7d6: af00         	add	r7, sp, #0x0
 801f7d8: 6078         	str	r0, [r7, #0x4]
 801f7da: 2102         	movs	r1, #0x2
 801f7dc: 6878         	ldr	r0, [r7, #0x4]
 801f7de: f7eb fec3    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x1427a
 801f7e2: 3708         	adds	r7, #0x8
 801f7e4: 46bd         	mov	sp, r7
 801f7e6: bd80         	pop	{r7, pc}

0801f7e8 <dma_stm32_irq_0_3>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 3);
 801f7e8: b580         	push	{r7, lr}
 801f7ea: b082         	sub	sp, #0x8
 801f7ec: af00         	add	r7, sp, #0x0
 801f7ee: 6078         	str	r0, [r7, #0x4]
 801f7f0: 2103         	movs	r1, #0x3
 801f7f2: 6878         	ldr	r0, [r7, #0x4]
 801f7f4: f7eb feb8    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x14290
 801f7f8: 3708         	adds	r7, #0x8
 801f7fa: 46bd         	mov	sp, r7
 801f7fc: bd80         	pop	{r7, pc}

0801f7fe <dma_stm32_irq_0_4>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 4);
 801f7fe: b580         	push	{r7, lr}
 801f800: b082         	sub	sp, #0x8
 801f802: af00         	add	r7, sp, #0x0
 801f804: 6078         	str	r0, [r7, #0x4]
 801f806: 2104         	movs	r1, #0x4
 801f808: 6878         	ldr	r0, [r7, #0x4]
 801f80a: f7eb fead    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x142a6
 801f80e: 3708         	adds	r7, #0x8
 801f810: 46bd         	mov	sp, r7
 801f812: bd80         	pop	{r7, pc}

0801f814 <dma_stm32_irq_0_5>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 5);
 801f814: b580         	push	{r7, lr}
 801f816: b082         	sub	sp, #0x8
 801f818: af00         	add	r7, sp, #0x0
 801f81a: 6078         	str	r0, [r7, #0x4]
 801f81c: 2105         	movs	r1, #0x5
 801f81e: 6878         	ldr	r0, [r7, #0x4]
 801f820: f7eb fea2    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x142bc
 801f824: 3708         	adds	r7, #0x8
 801f826: 46bd         	mov	sp, r7
 801f828: bd80         	pop	{r7, pc}

0801f82a <dma_stm32_irq_0_6>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 6);
 801f82a: b580         	push	{r7, lr}
 801f82c: b082         	sub	sp, #0x8
 801f82e: af00         	add	r7, sp, #0x0
 801f830: 6078         	str	r0, [r7, #0x4]
 801f832: 2106         	movs	r1, #0x6
 801f834: 6878         	ldr	r0, [r7, #0x4]
 801f836: f7eb fe97    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x142d2
 801f83a: 3708         	adds	r7, #0x8
 801f83c: 46bd         	mov	sp, r7
 801f83e: bd80         	pop	{r7, pc}

0801f840 <dma_stm32_irq_0_7>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 7);
 801f840: b580         	push	{r7, lr}
 801f842: b082         	sub	sp, #0x8
 801f844: af00         	add	r7, sp, #0x0
 801f846: 6078         	str	r0, [r7, #0x4]
 801f848: 2107         	movs	r1, #0x7
 801f84a: 6878         	ldr	r0, [r7, #0x4]
 801f84c: f7eb fe8c    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x142e8
 801f850: 3708         	adds	r7, #0x8
 801f852: 46bd         	mov	sp, r7
 801f854: bd80         	pop	{r7, pc}

0801f856 <dma_stm32_config_irq_0>:
; {
 801f856: b580         	push	{r7, lr}
 801f858: b082         	sub	sp, #0x8
 801f85a: af00         	add	r7, sp, #0x0
 801f85c: 6078         	str	r0, [r7, #0x4]
; 	LISTIFY(
 801f85e: 2200         	movs	r2, #0x0
 801f860: 2100         	movs	r1, #0x0
 801f862: 200b         	movs	r0, #0xb
 801f864: f7fd feb6    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x2294
 801f868: 200b         	movs	r0, #0xb
 801f86a: f7fd fea6    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x22b4
 801f86e: 2200         	movs	r2, #0x0
 801f870: 2100         	movs	r1, #0x0
 801f872: 200c         	movs	r0, #0xc
 801f874: f7fd feae    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x22a4
 801f878: 200c         	movs	r0, #0xc
 801f87a: f7fd fe9e    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x22c4
 801f87e: 2200         	movs	r2, #0x0
 801f880: 2100         	movs	r1, #0x0
 801f882: 200d         	movs	r0, #0xd
 801f884: f7fd fea6    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x22b4
 801f888: 200d         	movs	r0, #0xd
 801f88a: f7fd fe96    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x22d4
 801f88e: 2200         	movs	r2, #0x0
 801f890: 2100         	movs	r1, #0x0
 801f892: 200e         	movs	r0, #0xe
 801f894: f7fd fe9e    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x22c4
 801f898: 200e         	movs	r0, #0xe
 801f89a: f7fd fe8e    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x22e4
 801f89e: 2200         	movs	r2, #0x0
 801f8a0: 2100         	movs	r1, #0x0
 801f8a2: 200f         	movs	r0, #0xf
 801f8a4: f7fd fe96    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x22d4
 801f8a8: 200f         	movs	r0, #0xf
 801f8aa: f7fd fe86    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x22f4
 801f8ae: 2200         	movs	r2, #0x0
 801f8b0: 2100         	movs	r1, #0x0
 801f8b2: 2010         	movs	r0, #0x10
 801f8b4: f7fd fe8e    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x22e4
 801f8b8: 2010         	movs	r0, #0x10
 801f8ba: f7fd fe7e    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x2304
 801f8be: 2200         	movs	r2, #0x0
 801f8c0: 2100         	movs	r1, #0x0
 801f8c2: 2011         	movs	r0, #0x11
 801f8c4: f7fd fe86    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x22f4
 801f8c8: 2011         	movs	r0, #0x11
 801f8ca: f7fd fe76    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x2314
 801f8ce: 2200         	movs	r2, #0x0
 801f8d0: 2100         	movs	r1, #0x0
 801f8d2: 202f         	movs	r0, #0x2f
 801f8d4: f7fd fe7e    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x2304
 801f8d8: 202f         	movs	r0, #0x2f
 801f8da: f7fd fe6e    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x2324
; }
 801f8de: bf00         	nop
 801f8e0: 3708         	adds	r7, #0x8
 801f8e2: 46bd         	mov	sp, r7
 801f8e4: bd80         	pop	{r7, pc}

0801f8e6 <dma_stm32_irq_1_0>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 0);
 801f8e6: b580         	push	{r7, lr}
 801f8e8: b082         	sub	sp, #0x8
 801f8ea: af00         	add	r7, sp, #0x0
 801f8ec: 6078         	str	r0, [r7, #0x4]
 801f8ee: 2100         	movs	r1, #0x0
 801f8f0: 6878         	ldr	r0, [r7, #0x4]
 801f8f2: f7eb fe39    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x1438e
 801f8f6: 3708         	adds	r7, #0x8
 801f8f8: 46bd         	mov	sp, r7
 801f8fa: bd80         	pop	{r7, pc}

0801f8fc <dma_stm32_irq_1_1>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 1);
 801f8fc: b580         	push	{r7, lr}
 801f8fe: b082         	sub	sp, #0x8
 801f900: af00         	add	r7, sp, #0x0
 801f902: 6078         	str	r0, [r7, #0x4]
 801f904: 2101         	movs	r1, #0x1
 801f906: 6878         	ldr	r0, [r7, #0x4]
 801f908: f7eb fe2e    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x143a4
 801f90c: 3708         	adds	r7, #0x8
 801f90e: 46bd         	mov	sp, r7
 801f910: bd80         	pop	{r7, pc}

0801f912 <dma_stm32_irq_1_2>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 2);
 801f912: b580         	push	{r7, lr}
 801f914: b082         	sub	sp, #0x8
 801f916: af00         	add	r7, sp, #0x0
 801f918: 6078         	str	r0, [r7, #0x4]
 801f91a: 2102         	movs	r1, #0x2
 801f91c: 6878         	ldr	r0, [r7, #0x4]
 801f91e: f7eb fe23    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x143ba
 801f922: 3708         	adds	r7, #0x8
 801f924: 46bd         	mov	sp, r7
 801f926: bd80         	pop	{r7, pc}

0801f928 <dma_stm32_irq_1_3>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 3);
 801f928: b580         	push	{r7, lr}
 801f92a: b082         	sub	sp, #0x8
 801f92c: af00         	add	r7, sp, #0x0
 801f92e: 6078         	str	r0, [r7, #0x4]
 801f930: 2103         	movs	r1, #0x3
 801f932: 6878         	ldr	r0, [r7, #0x4]
 801f934: f7eb fe18    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x143d0
 801f938: 3708         	adds	r7, #0x8
 801f93a: 46bd         	mov	sp, r7
 801f93c: bd80         	pop	{r7, pc}

0801f93e <dma_stm32_irq_1_4>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 4);
 801f93e: b580         	push	{r7, lr}
 801f940: b082         	sub	sp, #0x8
 801f942: af00         	add	r7, sp, #0x0
 801f944: 6078         	str	r0, [r7, #0x4]
 801f946: 2104         	movs	r1, #0x4
 801f948: 6878         	ldr	r0, [r7, #0x4]
 801f94a: f7eb fe0d    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x143e6
 801f94e: 3708         	adds	r7, #0x8
 801f950: 46bd         	mov	sp, r7
 801f952: bd80         	pop	{r7, pc}

0801f954 <dma_stm32_irq_1_5>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 5);
 801f954: b580         	push	{r7, lr}
 801f956: b082         	sub	sp, #0x8
 801f958: af00         	add	r7, sp, #0x0
 801f95a: 6078         	str	r0, [r7, #0x4]
 801f95c: 2105         	movs	r1, #0x5
 801f95e: 6878         	ldr	r0, [r7, #0x4]
 801f960: f7eb fe02    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x143fc
 801f964: 3708         	adds	r7, #0x8
 801f966: 46bd         	mov	sp, r7
 801f968: bd80         	pop	{r7, pc}

0801f96a <dma_stm32_irq_1_6>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 6);
 801f96a: b580         	push	{r7, lr}
 801f96c: b082         	sub	sp, #0x8
 801f96e: af00         	add	r7, sp, #0x0
 801f970: 6078         	str	r0, [r7, #0x4]
 801f972: 2106         	movs	r1, #0x6
 801f974: 6878         	ldr	r0, [r7, #0x4]
 801f976: f7eb fdf7    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x14412
 801f97a: 3708         	adds	r7, #0x8
 801f97c: 46bd         	mov	sp, r7
 801f97e: bd80         	pop	{r7, pc}

0801f980 <dma_stm32_irq_1_7>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 7);
 801f980: b580         	push	{r7, lr}
 801f982: b082         	sub	sp, #0x8
 801f984: af00         	add	r7, sp, #0x0
 801f986: 6078         	str	r0, [r7, #0x4]
 801f988: 2107         	movs	r1, #0x7
 801f98a: 6878         	ldr	r0, [r7, #0x4]
 801f98c: f7eb fdec    	bl	0x800b568 <dma_stm32_irq_handler> @ imm = #-0x14428
 801f990: 3708         	adds	r7, #0x8
 801f992: 46bd         	mov	sp, r7
 801f994: bd80         	pop	{r7, pc}

0801f996 <dma_stm32_config_irq_1>:
; {
 801f996: b580         	push	{r7, lr}
 801f998: b082         	sub	sp, #0x8
 801f99a: af00         	add	r7, sp, #0x0
 801f99c: 6078         	str	r0, [r7, #0x4]
; 	LISTIFY(
 801f99e: 2200         	movs	r2, #0x0
 801f9a0: 2100         	movs	r1, #0x0
 801f9a2: 2038         	movs	r0, #0x38
 801f9a4: f7fd fe16    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x23d4
 801f9a8: 2038         	movs	r0, #0x38
 801f9aa: f7fd fe06    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x23f4
 801f9ae: 2200         	movs	r2, #0x0
 801f9b0: 2100         	movs	r1, #0x0
 801f9b2: 2039         	movs	r0, #0x39
 801f9b4: f7fd fe0e    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x23e4
 801f9b8: 2039         	movs	r0, #0x39
 801f9ba: f7fd fdfe    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x2404
 801f9be: 2200         	movs	r2, #0x0
 801f9c0: 2100         	movs	r1, #0x0
 801f9c2: 203a         	movs	r0, #0x3a
 801f9c4: f7fd fe06    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x23f4
 801f9c8: 203a         	movs	r0, #0x3a
 801f9ca: f7fd fdf6    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x2414
 801f9ce: 2200         	movs	r2, #0x0
 801f9d0: 2100         	movs	r1, #0x0
 801f9d2: 203b         	movs	r0, #0x3b
 801f9d4: f7fd fdfe    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x2404
 801f9d8: 203b         	movs	r0, #0x3b
 801f9da: f7fd fdee    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x2424
 801f9de: 2200         	movs	r2, #0x0
 801f9e0: 2100         	movs	r1, #0x0
 801f9e2: 203c         	movs	r0, #0x3c
 801f9e4: f7fd fdf6    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x2414
 801f9e8: 203c         	movs	r0, #0x3c
 801f9ea: f7fd fde6    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x2434
 801f9ee: 2200         	movs	r2, #0x0
 801f9f0: 2100         	movs	r1, #0x0
 801f9f2: 2044         	movs	r0, #0x44
 801f9f4: f7fd fdee    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x2424
 801f9f8: 2044         	movs	r0, #0x44
 801f9fa: f7fd fdde    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x2444
 801f9fe: 2200         	movs	r2, #0x0
 801fa00: 2100         	movs	r1, #0x0
 801fa02: 2045         	movs	r0, #0x45
 801fa04: f7fd fde6    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x2434
 801fa08: 2045         	movs	r0, #0x45
 801fa0a: f7fd fdd6    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x2454
 801fa0e: 2200         	movs	r2, #0x0
 801fa10: 2100         	movs	r1, #0x0
 801fa12: 2046         	movs	r0, #0x46
 801fa14: f7fd fdde    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x2444
 801fa18: 2046         	movs	r0, #0x46
 801fa1a: f7fd fdce    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x2464
; }
 801fa1e: bf00         	nop
 801fa20: 3708         	adds	r7, #0x8
 801fa22: 46bd         	mov	sp, r7
 801fa24: bd80         	pop	{r7, pc}

0801fa26 <LL_DMA_IsActiveFlag_HT0>:
; {
 801fa26: b480         	push	{r7}
 801fa28: b083         	sub	sp, #0xc
 801fa2a: af00         	add	r7, sp, #0x0
 801fa2c: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_HTIF0) == (DMA_LISR_HTIF0)) ? 1UL : 0UL);
 801fa2e: 687b         	ldr	r3, [r7, #0x4]
 801fa30: 681b         	ldr	r3, [r3]
 801fa32: f003 0310    	and	r3, r3, #0x10
 801fa36: 2b10         	cmp	r3, #0x10
 801fa38: d101         	bne	0x801fa3e <LL_DMA_IsActiveFlag_HT0+0x18> @ imm = #0x2
 801fa3a: 2301         	movs	r3, #0x1
 801fa3c: e000         	b	0x801fa40 <LL_DMA_IsActiveFlag_HT0+0x1a> @ imm = #0x0
 801fa3e: 2300         	movs	r3, #0x0
; }
 801fa40: 4618         	mov	r0, r3
 801fa42: 370c         	adds	r7, #0xc
 801fa44: 46bd         	mov	sp, r7
 801fa46: f85d 7b04    	ldr	r7, [sp], #4
 801fa4a: 4770         	bx	lr

0801fa4c <LL_DMA_IsActiveFlag_HT1>:
; {
 801fa4c: b480         	push	{r7}
 801fa4e: b083         	sub	sp, #0xc
 801fa50: af00         	add	r7, sp, #0x0
 801fa52: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_HTIF1) == (DMA_LISR_HTIF1)) ? 1UL : 0UL);
 801fa54: 687b         	ldr	r3, [r7, #0x4]
 801fa56: 681b         	ldr	r3, [r3]
 801fa58: f403 6380    	and	r3, r3, #0x400
 801fa5c: f5b3 6f80    	cmp.w	r3, #0x400
 801fa60: d101         	bne	0x801fa66 <LL_DMA_IsActiveFlag_HT1+0x1a> @ imm = #0x2
 801fa62: 2301         	movs	r3, #0x1
 801fa64: e000         	b	0x801fa68 <LL_DMA_IsActiveFlag_HT1+0x1c> @ imm = #0x0
 801fa66: 2300         	movs	r3, #0x0
; }
 801fa68: 4618         	mov	r0, r3
 801fa6a: 370c         	adds	r7, #0xc
 801fa6c: 46bd         	mov	sp, r7
 801fa6e: f85d 7b04    	ldr	r7, [sp], #4
 801fa72: 4770         	bx	lr

0801fa74 <LL_DMA_IsActiveFlag_HT2>:
; {
 801fa74: b480         	push	{r7}
 801fa76: b083         	sub	sp, #0xc
 801fa78: af00         	add	r7, sp, #0x0
 801fa7a: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_HTIF2) == (DMA_LISR_HTIF2)) ? 1UL : 0UL);
 801fa7c: 687b         	ldr	r3, [r7, #0x4]
 801fa7e: 681b         	ldr	r3, [r3]
 801fa80: f403 1380    	and	r3, r3, #0x100000
 801fa84: f5b3 1f80    	cmp.w	r3, #0x100000
 801fa88: d101         	bne	0x801fa8e <LL_DMA_IsActiveFlag_HT2+0x1a> @ imm = #0x2
 801fa8a: 2301         	movs	r3, #0x1
 801fa8c: e000         	b	0x801fa90 <LL_DMA_IsActiveFlag_HT2+0x1c> @ imm = #0x0
 801fa8e: 2300         	movs	r3, #0x0
; }
 801fa90: 4618         	mov	r0, r3
 801fa92: 370c         	adds	r7, #0xc
 801fa94: 46bd         	mov	sp, r7
 801fa96: f85d 7b04    	ldr	r7, [sp], #4
 801fa9a: 4770         	bx	lr

0801fa9c <LL_DMA_IsActiveFlag_HT3>:
; {
 801fa9c: b480         	push	{r7}
 801fa9e: b083         	sub	sp, #0xc
 801faa0: af00         	add	r7, sp, #0x0
 801faa2: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_HTIF3) == (DMA_LISR_HTIF3)) ? 1UL : 0UL);
 801faa4: 687b         	ldr	r3, [r7, #0x4]
 801faa6: 681b         	ldr	r3, [r3]
 801faa8: f003 6380    	and	r3, r3, #0x4000000
 801faac: f1b3 6f80    	cmp.w	r3, #0x4000000
 801fab0: d101         	bne	0x801fab6 <LL_DMA_IsActiveFlag_HT3+0x1a> @ imm = #0x2
 801fab2: 2301         	movs	r3, #0x1
 801fab4: e000         	b	0x801fab8 <LL_DMA_IsActiveFlag_HT3+0x1c> @ imm = #0x0
 801fab6: 2300         	movs	r3, #0x0
; }
 801fab8: 4618         	mov	r0, r3
 801faba: 370c         	adds	r7, #0xc
 801fabc: 46bd         	mov	sp, r7
 801fabe: f85d 7b04    	ldr	r7, [sp], #4
 801fac2: 4770         	bx	lr

0801fac4 <LL_DMA_IsActiveFlag_HT4>:
; {
 801fac4: b480         	push	{r7}
 801fac6: b083         	sub	sp, #0xc
 801fac8: af00         	add	r7, sp, #0x0
 801faca: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_HTIF4) == (DMA_HISR_HTIF4)) ? 1UL : 0UL);
 801facc: 687b         	ldr	r3, [r7, #0x4]
 801face: 685b         	ldr	r3, [r3, #0x4]
 801fad0: f003 0310    	and	r3, r3, #0x10
 801fad4: 2b10         	cmp	r3, #0x10
 801fad6: d101         	bne	0x801fadc <LL_DMA_IsActiveFlag_HT4+0x18> @ imm = #0x2
 801fad8: 2301         	movs	r3, #0x1
 801fada: e000         	b	0x801fade <LL_DMA_IsActiveFlag_HT4+0x1a> @ imm = #0x0
 801fadc: 2300         	movs	r3, #0x0
; }
 801fade: 4618         	mov	r0, r3
 801fae0: 370c         	adds	r7, #0xc
 801fae2: 46bd         	mov	sp, r7
 801fae4: f85d 7b04    	ldr	r7, [sp], #4
 801fae8: 4770         	bx	lr

0801faea <LL_DMA_IsActiveFlag_HT5>:
; {
 801faea: b480         	push	{r7}
 801faec: b083         	sub	sp, #0xc
 801faee: af00         	add	r7, sp, #0x0
 801faf0: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_HTIF5) == (DMA_HISR_HTIF5)) ? 1UL : 0UL);
 801faf2: 687b         	ldr	r3, [r7, #0x4]
 801faf4: 685b         	ldr	r3, [r3, #0x4]
 801faf6: f403 6380    	and	r3, r3, #0x400
 801fafa: f5b3 6f80    	cmp.w	r3, #0x400
 801fafe: d101         	bne	0x801fb04 <LL_DMA_IsActiveFlag_HT5+0x1a> @ imm = #0x2
 801fb00: 2301         	movs	r3, #0x1
 801fb02: e000         	b	0x801fb06 <LL_DMA_IsActiveFlag_HT5+0x1c> @ imm = #0x0
 801fb04: 2300         	movs	r3, #0x0
; }
 801fb06: 4618         	mov	r0, r3
 801fb08: 370c         	adds	r7, #0xc
 801fb0a: 46bd         	mov	sp, r7
 801fb0c: f85d 7b04    	ldr	r7, [sp], #4
 801fb10: 4770         	bx	lr

0801fb12 <LL_DMA_IsActiveFlag_HT6>:
; {
 801fb12: b480         	push	{r7}
 801fb14: b083         	sub	sp, #0xc
 801fb16: af00         	add	r7, sp, #0x0
 801fb18: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_HTIF6) == (DMA_HISR_HTIF6)) ? 1UL : 0UL);
 801fb1a: 687b         	ldr	r3, [r7, #0x4]
 801fb1c: 685b         	ldr	r3, [r3, #0x4]
 801fb1e: f403 1380    	and	r3, r3, #0x100000
 801fb22: f5b3 1f80    	cmp.w	r3, #0x100000
 801fb26: d101         	bne	0x801fb2c <LL_DMA_IsActiveFlag_HT6+0x1a> @ imm = #0x2
 801fb28: 2301         	movs	r3, #0x1
 801fb2a: e000         	b	0x801fb2e <LL_DMA_IsActiveFlag_HT6+0x1c> @ imm = #0x0
 801fb2c: 2300         	movs	r3, #0x0
; }
 801fb2e: 4618         	mov	r0, r3
 801fb30: 370c         	adds	r7, #0xc
 801fb32: 46bd         	mov	sp, r7
 801fb34: f85d 7b04    	ldr	r7, [sp], #4
 801fb38: 4770         	bx	lr

0801fb3a <LL_DMA_IsActiveFlag_HT7>:
; {
 801fb3a: b480         	push	{r7}
 801fb3c: b083         	sub	sp, #0xc
 801fb3e: af00         	add	r7, sp, #0x0
 801fb40: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_HTIF7) == (DMA_HISR_HTIF7)) ? 1UL : 0UL);
 801fb42: 687b         	ldr	r3, [r7, #0x4]
 801fb44: 685b         	ldr	r3, [r3, #0x4]
 801fb46: f003 6380    	and	r3, r3, #0x4000000
 801fb4a: f1b3 6f80    	cmp.w	r3, #0x4000000
 801fb4e: d101         	bne	0x801fb54 <LL_DMA_IsActiveFlag_HT7+0x1a> @ imm = #0x2
 801fb50: 2301         	movs	r3, #0x1
 801fb52: e000         	b	0x801fb56 <LL_DMA_IsActiveFlag_HT7+0x1c> @ imm = #0x0
 801fb54: 2300         	movs	r3, #0x0
; }
 801fb56: 4618         	mov	r0, r3
 801fb58: 370c         	adds	r7, #0xc
 801fb5a: 46bd         	mov	sp, r7
 801fb5c: f85d 7b04    	ldr	r7, [sp], #4
 801fb60: 4770         	bx	lr

0801fb62 <LL_DMA_IsActiveFlag_TC0>:
; {
 801fb62: b480         	push	{r7}
 801fb64: b083         	sub	sp, #0xc
 801fb66: af00         	add	r7, sp, #0x0
 801fb68: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_TCIF0) == (DMA_LISR_TCIF0)) ? 1UL : 0UL);
 801fb6a: 687b         	ldr	r3, [r7, #0x4]
 801fb6c: 681b         	ldr	r3, [r3]
 801fb6e: f003 0320    	and	r3, r3, #0x20
 801fb72: 2b20         	cmp	r3, #0x20
 801fb74: d101         	bne	0x801fb7a <LL_DMA_IsActiveFlag_TC0+0x18> @ imm = #0x2
 801fb76: 2301         	movs	r3, #0x1
 801fb78: e000         	b	0x801fb7c <LL_DMA_IsActiveFlag_TC0+0x1a> @ imm = #0x0
 801fb7a: 2300         	movs	r3, #0x0
; }
 801fb7c: 4618         	mov	r0, r3
 801fb7e: 370c         	adds	r7, #0xc
 801fb80: 46bd         	mov	sp, r7
 801fb82: f85d 7b04    	ldr	r7, [sp], #4
 801fb86: 4770         	bx	lr

0801fb88 <LL_DMA_IsActiveFlag_TC1>:
; {
 801fb88: b480         	push	{r7}
 801fb8a: b083         	sub	sp, #0xc
 801fb8c: af00         	add	r7, sp, #0x0
 801fb8e: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_TCIF1) == (DMA_LISR_TCIF1)) ? 1UL : 0UL);
 801fb90: 687b         	ldr	r3, [r7, #0x4]
 801fb92: 681b         	ldr	r3, [r3]
 801fb94: f403 6300    	and	r3, r3, #0x800
 801fb98: f5b3 6f00    	cmp.w	r3, #0x800
 801fb9c: d101         	bne	0x801fba2 <LL_DMA_IsActiveFlag_TC1+0x1a> @ imm = #0x2
 801fb9e: 2301         	movs	r3, #0x1
 801fba0: e000         	b	0x801fba4 <LL_DMA_IsActiveFlag_TC1+0x1c> @ imm = #0x0
 801fba2: 2300         	movs	r3, #0x0
; }
 801fba4: 4618         	mov	r0, r3
 801fba6: 370c         	adds	r7, #0xc
 801fba8: 46bd         	mov	sp, r7
 801fbaa: f85d 7b04    	ldr	r7, [sp], #4
 801fbae: 4770         	bx	lr

0801fbb0 <LL_DMA_IsActiveFlag_TC2>:
; {
 801fbb0: b480         	push	{r7}
 801fbb2: b083         	sub	sp, #0xc
 801fbb4: af00         	add	r7, sp, #0x0
 801fbb6: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_TCIF2) == (DMA_LISR_TCIF2)) ? 1UL : 0UL);
 801fbb8: 687b         	ldr	r3, [r7, #0x4]
 801fbba: 681b         	ldr	r3, [r3]
 801fbbc: f403 1300    	and	r3, r3, #0x200000
 801fbc0: f5b3 1f00    	cmp.w	r3, #0x200000
 801fbc4: d101         	bne	0x801fbca <LL_DMA_IsActiveFlag_TC2+0x1a> @ imm = #0x2
 801fbc6: 2301         	movs	r3, #0x1
 801fbc8: e000         	b	0x801fbcc <LL_DMA_IsActiveFlag_TC2+0x1c> @ imm = #0x0
 801fbca: 2300         	movs	r3, #0x0
; }
 801fbcc: 4618         	mov	r0, r3
 801fbce: 370c         	adds	r7, #0xc
 801fbd0: 46bd         	mov	sp, r7
 801fbd2: f85d 7b04    	ldr	r7, [sp], #4
 801fbd6: 4770         	bx	lr

0801fbd8 <LL_DMA_IsActiveFlag_TC3>:
; {
 801fbd8: b480         	push	{r7}
 801fbda: b083         	sub	sp, #0xc
 801fbdc: af00         	add	r7, sp, #0x0
 801fbde: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_TCIF3) == (DMA_LISR_TCIF3)) ? 1UL : 0UL);
 801fbe0: 687b         	ldr	r3, [r7, #0x4]
 801fbe2: 681b         	ldr	r3, [r3]
 801fbe4: f003 6300    	and	r3, r3, #0x8000000
 801fbe8: f1b3 6f00    	cmp.w	r3, #0x8000000
 801fbec: d101         	bne	0x801fbf2 <LL_DMA_IsActiveFlag_TC3+0x1a> @ imm = #0x2
 801fbee: 2301         	movs	r3, #0x1
 801fbf0: e000         	b	0x801fbf4 <LL_DMA_IsActiveFlag_TC3+0x1c> @ imm = #0x0
 801fbf2: 2300         	movs	r3, #0x0
; }
 801fbf4: 4618         	mov	r0, r3
 801fbf6: 370c         	adds	r7, #0xc
 801fbf8: 46bd         	mov	sp, r7
 801fbfa: f85d 7b04    	ldr	r7, [sp], #4
 801fbfe: 4770         	bx	lr

0801fc00 <LL_DMA_IsActiveFlag_TC4>:
; {
 801fc00: b480         	push	{r7}
 801fc02: b083         	sub	sp, #0xc
 801fc04: af00         	add	r7, sp, #0x0
 801fc06: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_TCIF4) == (DMA_HISR_TCIF4)) ? 1UL : 0UL);
 801fc08: 687b         	ldr	r3, [r7, #0x4]
 801fc0a: 685b         	ldr	r3, [r3, #0x4]
 801fc0c: f003 0320    	and	r3, r3, #0x20
 801fc10: 2b20         	cmp	r3, #0x20
 801fc12: d101         	bne	0x801fc18 <LL_DMA_IsActiveFlag_TC4+0x18> @ imm = #0x2
 801fc14: 2301         	movs	r3, #0x1
 801fc16: e000         	b	0x801fc1a <LL_DMA_IsActiveFlag_TC4+0x1a> @ imm = #0x0
 801fc18: 2300         	movs	r3, #0x0
; }
 801fc1a: 4618         	mov	r0, r3
 801fc1c: 370c         	adds	r7, #0xc
 801fc1e: 46bd         	mov	sp, r7
 801fc20: f85d 7b04    	ldr	r7, [sp], #4
 801fc24: 4770         	bx	lr

0801fc26 <LL_DMA_IsActiveFlag_TC5>:
; {
 801fc26: b480         	push	{r7}
 801fc28: b083         	sub	sp, #0xc
 801fc2a: af00         	add	r7, sp, #0x0
 801fc2c: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_TCIF5) == (DMA_HISR_TCIF5)) ? 1UL : 0UL);
 801fc2e: 687b         	ldr	r3, [r7, #0x4]
 801fc30: 685b         	ldr	r3, [r3, #0x4]
 801fc32: f403 6300    	and	r3, r3, #0x800
 801fc36: f5b3 6f00    	cmp.w	r3, #0x800
 801fc3a: d101         	bne	0x801fc40 <LL_DMA_IsActiveFlag_TC5+0x1a> @ imm = #0x2
 801fc3c: 2301         	movs	r3, #0x1
 801fc3e: e000         	b	0x801fc42 <LL_DMA_IsActiveFlag_TC5+0x1c> @ imm = #0x0
 801fc40: 2300         	movs	r3, #0x0
; }
 801fc42: 4618         	mov	r0, r3
 801fc44: 370c         	adds	r7, #0xc
 801fc46: 46bd         	mov	sp, r7
 801fc48: f85d 7b04    	ldr	r7, [sp], #4
 801fc4c: 4770         	bx	lr

0801fc4e <LL_DMA_IsActiveFlag_TC6>:
; {
 801fc4e: b480         	push	{r7}
 801fc50: b083         	sub	sp, #0xc
 801fc52: af00         	add	r7, sp, #0x0
 801fc54: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_TCIF6) == (DMA_HISR_TCIF6)) ? 1UL : 0UL);
 801fc56: 687b         	ldr	r3, [r7, #0x4]
 801fc58: 685b         	ldr	r3, [r3, #0x4]
 801fc5a: f403 1300    	and	r3, r3, #0x200000
 801fc5e: f5b3 1f00    	cmp.w	r3, #0x200000
 801fc62: d101         	bne	0x801fc68 <LL_DMA_IsActiveFlag_TC6+0x1a> @ imm = #0x2
 801fc64: 2301         	movs	r3, #0x1
 801fc66: e000         	b	0x801fc6a <LL_DMA_IsActiveFlag_TC6+0x1c> @ imm = #0x0
 801fc68: 2300         	movs	r3, #0x0
; }
 801fc6a: 4618         	mov	r0, r3
 801fc6c: 370c         	adds	r7, #0xc
 801fc6e: 46bd         	mov	sp, r7
 801fc70: f85d 7b04    	ldr	r7, [sp], #4
 801fc74: 4770         	bx	lr

0801fc76 <LL_DMA_IsActiveFlag_TC7>:
; {
 801fc76: b480         	push	{r7}
 801fc78: b083         	sub	sp, #0xc
 801fc7a: af00         	add	r7, sp, #0x0
 801fc7c: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_TCIF7) == (DMA_HISR_TCIF7)) ? 1UL : 0UL);
 801fc7e: 687b         	ldr	r3, [r7, #0x4]
 801fc80: 685b         	ldr	r3, [r3, #0x4]
 801fc82: f003 6300    	and	r3, r3, #0x8000000
 801fc86: f1b3 6f00    	cmp.w	r3, #0x8000000
 801fc8a: d101         	bne	0x801fc90 <LL_DMA_IsActiveFlag_TC7+0x1a> @ imm = #0x2
 801fc8c: 2301         	movs	r3, #0x1
 801fc8e: e000         	b	0x801fc92 <LL_DMA_IsActiveFlag_TC7+0x1c> @ imm = #0x0
 801fc90: 2300         	movs	r3, #0x0
; }
 801fc92: 4618         	mov	r0, r3
 801fc94: 370c         	adds	r7, #0xc
 801fc96: 46bd         	mov	sp, r7
 801fc98: f85d 7b04    	ldr	r7, [sp], #4
 801fc9c: 4770         	bx	lr

0801fc9e <LL_DMA_IsActiveFlag_TE0>:
; {
 801fc9e: b480         	push	{r7}
 801fca0: b083         	sub	sp, #0xc
 801fca2: af00         	add	r7, sp, #0x0
 801fca4: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_TEIF0) == (DMA_LISR_TEIF0)) ? 1UL : 0UL);
 801fca6: 687b         	ldr	r3, [r7, #0x4]
 801fca8: 681b         	ldr	r3, [r3]
 801fcaa: f003 0308    	and	r3, r3, #0x8
 801fcae: 2b08         	cmp	r3, #0x8
 801fcb0: d101         	bne	0x801fcb6 <LL_DMA_IsActiveFlag_TE0+0x18> @ imm = #0x2
 801fcb2: 2301         	movs	r3, #0x1
 801fcb4: e000         	b	0x801fcb8 <LL_DMA_IsActiveFlag_TE0+0x1a> @ imm = #0x0
 801fcb6: 2300         	movs	r3, #0x0
; }
 801fcb8: 4618         	mov	r0, r3
 801fcba: 370c         	adds	r7, #0xc
 801fcbc: 46bd         	mov	sp, r7
 801fcbe: f85d 7b04    	ldr	r7, [sp], #4
 801fcc2: 4770         	bx	lr

0801fcc4 <LL_DMA_IsActiveFlag_TE1>:
; {
 801fcc4: b480         	push	{r7}
 801fcc6: b083         	sub	sp, #0xc
 801fcc8: af00         	add	r7, sp, #0x0
 801fcca: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_TEIF1) == (DMA_LISR_TEIF1)) ? 1UL : 0UL);
 801fccc: 687b         	ldr	r3, [r7, #0x4]
 801fcce: 681b         	ldr	r3, [r3]
 801fcd0: f403 7300    	and	r3, r3, #0x200
 801fcd4: f5b3 7f00    	cmp.w	r3, #0x200
 801fcd8: d101         	bne	0x801fcde <LL_DMA_IsActiveFlag_TE1+0x1a> @ imm = #0x2
 801fcda: 2301         	movs	r3, #0x1
 801fcdc: e000         	b	0x801fce0 <LL_DMA_IsActiveFlag_TE1+0x1c> @ imm = #0x0
 801fcde: 2300         	movs	r3, #0x0
; }
 801fce0: 4618         	mov	r0, r3
 801fce2: 370c         	adds	r7, #0xc
 801fce4: 46bd         	mov	sp, r7
 801fce6: f85d 7b04    	ldr	r7, [sp], #4
 801fcea: 4770         	bx	lr

0801fcec <LL_DMA_IsActiveFlag_TE2>:
; {
 801fcec: b480         	push	{r7}
 801fcee: b083         	sub	sp, #0xc
 801fcf0: af00         	add	r7, sp, #0x0
 801fcf2: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_TEIF2) == (DMA_LISR_TEIF2)) ? 1UL : 0UL);
 801fcf4: 687b         	ldr	r3, [r7, #0x4]
 801fcf6: 681b         	ldr	r3, [r3]
 801fcf8: f403 2300    	and	r3, r3, #0x80000
 801fcfc: f5b3 2f00    	cmp.w	r3, #0x80000
 801fd00: d101         	bne	0x801fd06 <LL_DMA_IsActiveFlag_TE2+0x1a> @ imm = #0x2
 801fd02: 2301         	movs	r3, #0x1
 801fd04: e000         	b	0x801fd08 <LL_DMA_IsActiveFlag_TE2+0x1c> @ imm = #0x0
 801fd06: 2300         	movs	r3, #0x0
; }
 801fd08: 4618         	mov	r0, r3
 801fd0a: 370c         	adds	r7, #0xc
 801fd0c: 46bd         	mov	sp, r7
 801fd0e: f85d 7b04    	ldr	r7, [sp], #4
 801fd12: 4770         	bx	lr

0801fd14 <LL_DMA_IsActiveFlag_TE3>:
; {
 801fd14: b480         	push	{r7}
 801fd16: b083         	sub	sp, #0xc
 801fd18: af00         	add	r7, sp, #0x0
 801fd1a: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_TEIF3) == (DMA_LISR_TEIF3)) ? 1UL : 0UL);
 801fd1c: 687b         	ldr	r3, [r7, #0x4]
 801fd1e: 681b         	ldr	r3, [r3]
 801fd20: f003 7300    	and	r3, r3, #0x2000000
 801fd24: f1b3 7f00    	cmp.w	r3, #0x2000000
 801fd28: d101         	bne	0x801fd2e <LL_DMA_IsActiveFlag_TE3+0x1a> @ imm = #0x2
 801fd2a: 2301         	movs	r3, #0x1
 801fd2c: e000         	b	0x801fd30 <LL_DMA_IsActiveFlag_TE3+0x1c> @ imm = #0x0
 801fd2e: 2300         	movs	r3, #0x0
; }
 801fd30: 4618         	mov	r0, r3
 801fd32: 370c         	adds	r7, #0xc
 801fd34: 46bd         	mov	sp, r7
 801fd36: f85d 7b04    	ldr	r7, [sp], #4
 801fd3a: 4770         	bx	lr

0801fd3c <LL_DMA_IsActiveFlag_TE4>:
; {
 801fd3c: b480         	push	{r7}
 801fd3e: b083         	sub	sp, #0xc
 801fd40: af00         	add	r7, sp, #0x0
 801fd42: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_TEIF4) == (DMA_HISR_TEIF4)) ? 1UL : 0UL);
 801fd44: 687b         	ldr	r3, [r7, #0x4]
 801fd46: 685b         	ldr	r3, [r3, #0x4]
 801fd48: f003 0308    	and	r3, r3, #0x8
 801fd4c: 2b08         	cmp	r3, #0x8
 801fd4e: d101         	bne	0x801fd54 <LL_DMA_IsActiveFlag_TE4+0x18> @ imm = #0x2
 801fd50: 2301         	movs	r3, #0x1
 801fd52: e000         	b	0x801fd56 <LL_DMA_IsActiveFlag_TE4+0x1a> @ imm = #0x0
 801fd54: 2300         	movs	r3, #0x0
; }
 801fd56: 4618         	mov	r0, r3
 801fd58: 370c         	adds	r7, #0xc
 801fd5a: 46bd         	mov	sp, r7
 801fd5c: f85d 7b04    	ldr	r7, [sp], #4
 801fd60: 4770         	bx	lr

0801fd62 <LL_DMA_IsActiveFlag_TE5>:
; {
 801fd62: b480         	push	{r7}
 801fd64: b083         	sub	sp, #0xc
 801fd66: af00         	add	r7, sp, #0x0
 801fd68: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_TEIF5) == (DMA_HISR_TEIF5)) ? 1UL : 0UL);
 801fd6a: 687b         	ldr	r3, [r7, #0x4]
 801fd6c: 685b         	ldr	r3, [r3, #0x4]
 801fd6e: f403 7300    	and	r3, r3, #0x200
 801fd72: f5b3 7f00    	cmp.w	r3, #0x200
 801fd76: d101         	bne	0x801fd7c <LL_DMA_IsActiveFlag_TE5+0x1a> @ imm = #0x2
 801fd78: 2301         	movs	r3, #0x1
 801fd7a: e000         	b	0x801fd7e <LL_DMA_IsActiveFlag_TE5+0x1c> @ imm = #0x0
 801fd7c: 2300         	movs	r3, #0x0
; }
 801fd7e: 4618         	mov	r0, r3
 801fd80: 370c         	adds	r7, #0xc
 801fd82: 46bd         	mov	sp, r7
 801fd84: f85d 7b04    	ldr	r7, [sp], #4
 801fd88: 4770         	bx	lr

0801fd8a <LL_DMA_IsActiveFlag_TE6>:
; {
 801fd8a: b480         	push	{r7}
 801fd8c: b083         	sub	sp, #0xc
 801fd8e: af00         	add	r7, sp, #0x0
 801fd90: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_TEIF6) == (DMA_HISR_TEIF6)) ? 1UL : 0UL);
 801fd92: 687b         	ldr	r3, [r7, #0x4]
 801fd94: 685b         	ldr	r3, [r3, #0x4]
 801fd96: f403 2300    	and	r3, r3, #0x80000
 801fd9a: f5b3 2f00    	cmp.w	r3, #0x80000
 801fd9e: d101         	bne	0x801fda4 <LL_DMA_IsActiveFlag_TE6+0x1a> @ imm = #0x2
 801fda0: 2301         	movs	r3, #0x1
 801fda2: e000         	b	0x801fda6 <LL_DMA_IsActiveFlag_TE6+0x1c> @ imm = #0x0
 801fda4: 2300         	movs	r3, #0x0
; }
 801fda6: 4618         	mov	r0, r3
 801fda8: 370c         	adds	r7, #0xc
 801fdaa: 46bd         	mov	sp, r7
 801fdac: f85d 7b04    	ldr	r7, [sp], #4
 801fdb0: 4770         	bx	lr

0801fdb2 <LL_DMA_IsActiveFlag_TE7>:
; {
 801fdb2: b480         	push	{r7}
 801fdb4: b083         	sub	sp, #0xc
 801fdb6: af00         	add	r7, sp, #0x0
 801fdb8: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_TEIF7) == (DMA_HISR_TEIF7)) ? 1UL : 0UL);
 801fdba: 687b         	ldr	r3, [r7, #0x4]
 801fdbc: 685b         	ldr	r3, [r3, #0x4]
 801fdbe: f003 7300    	and	r3, r3, #0x2000000
 801fdc2: f1b3 7f00    	cmp.w	r3, #0x2000000
 801fdc6: d101         	bne	0x801fdcc <LL_DMA_IsActiveFlag_TE7+0x1a> @ imm = #0x2
 801fdc8: 2301         	movs	r3, #0x1
 801fdca: e000         	b	0x801fdce <LL_DMA_IsActiveFlag_TE7+0x1c> @ imm = #0x0
 801fdcc: 2300         	movs	r3, #0x0
; }
 801fdce: 4618         	mov	r0, r3
 801fdd0: 370c         	adds	r7, #0xc
 801fdd2: 46bd         	mov	sp, r7
 801fdd4: f85d 7b04    	ldr	r7, [sp], #4
 801fdd8: 4770         	bx	lr

0801fdda <LL_DMA_IsActiveFlag_DME0>:
; {
 801fdda: b480         	push	{r7}
 801fddc: b083         	sub	sp, #0xc
 801fdde: af00         	add	r7, sp, #0x0
 801fde0: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_DMEIF0) == (DMA_LISR_DMEIF0)) ? 1UL : 0UL);
 801fde2: 687b         	ldr	r3, [r7, #0x4]
 801fde4: 681b         	ldr	r3, [r3]
 801fde6: f003 0304    	and	r3, r3, #0x4
 801fdea: 2b04         	cmp	r3, #0x4
 801fdec: d101         	bne	0x801fdf2 <LL_DMA_IsActiveFlag_DME0+0x18> @ imm = #0x2
 801fdee: 2301         	movs	r3, #0x1
 801fdf0: e000         	b	0x801fdf4 <LL_DMA_IsActiveFlag_DME0+0x1a> @ imm = #0x0
 801fdf2: 2300         	movs	r3, #0x0
; }
 801fdf4: 4618         	mov	r0, r3
 801fdf6: 370c         	adds	r7, #0xc
 801fdf8: 46bd         	mov	sp, r7
 801fdfa: f85d 7b04    	ldr	r7, [sp], #4
 801fdfe: 4770         	bx	lr

0801fe00 <LL_DMA_IsActiveFlag_DME1>:
; {
 801fe00: b480         	push	{r7}
 801fe02: b083         	sub	sp, #0xc
 801fe04: af00         	add	r7, sp, #0x0
 801fe06: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_DMEIF1) == (DMA_LISR_DMEIF1)) ? 1UL : 0UL);
 801fe08: 687b         	ldr	r3, [r7, #0x4]
 801fe0a: 681b         	ldr	r3, [r3]
 801fe0c: f403 7380    	and	r3, r3, #0x100
 801fe10: f5b3 7f80    	cmp.w	r3, #0x100
 801fe14: d101         	bne	0x801fe1a <LL_DMA_IsActiveFlag_DME1+0x1a> @ imm = #0x2
 801fe16: 2301         	movs	r3, #0x1
 801fe18: e000         	b	0x801fe1c <LL_DMA_IsActiveFlag_DME1+0x1c> @ imm = #0x0
 801fe1a: 2300         	movs	r3, #0x0
; }
 801fe1c: 4618         	mov	r0, r3
 801fe1e: 370c         	adds	r7, #0xc
 801fe20: 46bd         	mov	sp, r7
 801fe22: f85d 7b04    	ldr	r7, [sp], #4
 801fe26: 4770         	bx	lr

0801fe28 <LL_DMA_IsActiveFlag_DME2>:
; {
 801fe28: b480         	push	{r7}
 801fe2a: b083         	sub	sp, #0xc
 801fe2c: af00         	add	r7, sp, #0x0
 801fe2e: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_DMEIF2) == (DMA_LISR_DMEIF2)) ? 1UL : 0UL);
 801fe30: 687b         	ldr	r3, [r7, #0x4]
 801fe32: 681b         	ldr	r3, [r3]
 801fe34: f403 2380    	and	r3, r3, #0x40000
 801fe38: f5b3 2f80    	cmp.w	r3, #0x40000
 801fe3c: d101         	bne	0x801fe42 <LL_DMA_IsActiveFlag_DME2+0x1a> @ imm = #0x2
 801fe3e: 2301         	movs	r3, #0x1
 801fe40: e000         	b	0x801fe44 <LL_DMA_IsActiveFlag_DME2+0x1c> @ imm = #0x0
 801fe42: 2300         	movs	r3, #0x0
; }
 801fe44: 4618         	mov	r0, r3
 801fe46: 370c         	adds	r7, #0xc
 801fe48: 46bd         	mov	sp, r7
 801fe4a: f85d 7b04    	ldr	r7, [sp], #4
 801fe4e: 4770         	bx	lr

0801fe50 <LL_DMA_IsActiveFlag_DME3>:
; {
 801fe50: b480         	push	{r7}
 801fe52: b083         	sub	sp, #0xc
 801fe54: af00         	add	r7, sp, #0x0
 801fe56: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_DMEIF3) == (DMA_LISR_DMEIF3)) ? 1UL : 0UL);
 801fe58: 687b         	ldr	r3, [r7, #0x4]
 801fe5a: 681b         	ldr	r3, [r3]
 801fe5c: f003 7380    	and	r3, r3, #0x1000000
 801fe60: f1b3 7f80    	cmp.w	r3, #0x1000000
 801fe64: d101         	bne	0x801fe6a <LL_DMA_IsActiveFlag_DME3+0x1a> @ imm = #0x2
 801fe66: 2301         	movs	r3, #0x1
 801fe68: e000         	b	0x801fe6c <LL_DMA_IsActiveFlag_DME3+0x1c> @ imm = #0x0
 801fe6a: 2300         	movs	r3, #0x0
; }
 801fe6c: 4618         	mov	r0, r3
 801fe6e: 370c         	adds	r7, #0xc
 801fe70: 46bd         	mov	sp, r7
 801fe72: f85d 7b04    	ldr	r7, [sp], #4
 801fe76: 4770         	bx	lr

0801fe78 <LL_DMA_IsActiveFlag_DME4>:
; {
 801fe78: b480         	push	{r7}
 801fe7a: b083         	sub	sp, #0xc
 801fe7c: af00         	add	r7, sp, #0x0
 801fe7e: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_DMEIF4) == (DMA_HISR_DMEIF4)) ? 1UL : 0UL);
 801fe80: 687b         	ldr	r3, [r7, #0x4]
 801fe82: 685b         	ldr	r3, [r3, #0x4]
 801fe84: f003 0304    	and	r3, r3, #0x4
 801fe88: 2b04         	cmp	r3, #0x4
 801fe8a: d101         	bne	0x801fe90 <LL_DMA_IsActiveFlag_DME4+0x18> @ imm = #0x2
 801fe8c: 2301         	movs	r3, #0x1
 801fe8e: e000         	b	0x801fe92 <LL_DMA_IsActiveFlag_DME4+0x1a> @ imm = #0x0
 801fe90: 2300         	movs	r3, #0x0
; }
 801fe92: 4618         	mov	r0, r3
 801fe94: 370c         	adds	r7, #0xc
 801fe96: 46bd         	mov	sp, r7
 801fe98: f85d 7b04    	ldr	r7, [sp], #4
 801fe9c: 4770         	bx	lr

0801fe9e <LL_DMA_IsActiveFlag_DME5>:
; {
 801fe9e: b480         	push	{r7}
 801fea0: b083         	sub	sp, #0xc
 801fea2: af00         	add	r7, sp, #0x0
 801fea4: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_DMEIF5) == (DMA_HISR_DMEIF5)) ? 1UL : 0UL);
 801fea6: 687b         	ldr	r3, [r7, #0x4]
 801fea8: 685b         	ldr	r3, [r3, #0x4]
 801feaa: f403 7380    	and	r3, r3, #0x100
 801feae: f5b3 7f80    	cmp.w	r3, #0x100
 801feb2: d101         	bne	0x801feb8 <LL_DMA_IsActiveFlag_DME5+0x1a> @ imm = #0x2
 801feb4: 2301         	movs	r3, #0x1
 801feb6: e000         	b	0x801feba <LL_DMA_IsActiveFlag_DME5+0x1c> @ imm = #0x0
 801feb8: 2300         	movs	r3, #0x0
; }
 801feba: 4618         	mov	r0, r3
 801febc: 370c         	adds	r7, #0xc
 801febe: 46bd         	mov	sp, r7
 801fec0: f85d 7b04    	ldr	r7, [sp], #4
 801fec4: 4770         	bx	lr

0801fec6 <LL_DMA_IsActiveFlag_DME6>:
; {
 801fec6: b480         	push	{r7}
 801fec8: b083         	sub	sp, #0xc
 801feca: af00         	add	r7, sp, #0x0
 801fecc: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_DMEIF6) == (DMA_HISR_DMEIF6)) ? 1UL : 0UL);
 801fece: 687b         	ldr	r3, [r7, #0x4]
 801fed0: 685b         	ldr	r3, [r3, #0x4]
 801fed2: f403 2380    	and	r3, r3, #0x40000
 801fed6: f5b3 2f80    	cmp.w	r3, #0x40000
 801feda: d101         	bne	0x801fee0 <LL_DMA_IsActiveFlag_DME6+0x1a> @ imm = #0x2
 801fedc: 2301         	movs	r3, #0x1
 801fede: e000         	b	0x801fee2 <LL_DMA_IsActiveFlag_DME6+0x1c> @ imm = #0x0
 801fee0: 2300         	movs	r3, #0x0
; }
 801fee2: 4618         	mov	r0, r3
 801fee4: 370c         	adds	r7, #0xc
 801fee6: 46bd         	mov	sp, r7
 801fee8: f85d 7b04    	ldr	r7, [sp], #4
 801feec: 4770         	bx	lr

0801feee <LL_DMA_IsActiveFlag_DME7>:
; {
 801feee: b480         	push	{r7}
 801fef0: b083         	sub	sp, #0xc
 801fef2: af00         	add	r7, sp, #0x0
 801fef4: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_DMEIF7) == (DMA_HISR_DMEIF7)) ? 1UL : 0UL);
 801fef6: 687b         	ldr	r3, [r7, #0x4]
 801fef8: 685b         	ldr	r3, [r3, #0x4]
 801fefa: f003 7380    	and	r3, r3, #0x1000000
 801fefe: f1b3 7f80    	cmp.w	r3, #0x1000000
 801ff02: d101         	bne	0x801ff08 <LL_DMA_IsActiveFlag_DME7+0x1a> @ imm = #0x2
 801ff04: 2301         	movs	r3, #0x1
 801ff06: e000         	b	0x801ff0a <LL_DMA_IsActiveFlag_DME7+0x1c> @ imm = #0x0
 801ff08: 2300         	movs	r3, #0x0
; }
 801ff0a: 4618         	mov	r0, r3
 801ff0c: 370c         	adds	r7, #0xc
 801ff0e: 46bd         	mov	sp, r7
 801ff10: f85d 7b04    	ldr	r7, [sp], #4
 801ff14: 4770         	bx	lr

0801ff16 <LL_DMA_IsActiveFlag_FE0>:
; {
 801ff16: b480         	push	{r7}
 801ff18: b083         	sub	sp, #0xc
 801ff1a: af00         	add	r7, sp, #0x0
 801ff1c: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_FEIF0) == (DMA_LISR_FEIF0)) ? 1UL : 0UL);
 801ff1e: 687b         	ldr	r3, [r7, #0x4]
 801ff20: 681b         	ldr	r3, [r3]
 801ff22: f003 0301    	and	r3, r3, #0x1
 801ff26: 2b01         	cmp	r3, #0x1
 801ff28: d101         	bne	0x801ff2e <LL_DMA_IsActiveFlag_FE0+0x18> @ imm = #0x2
 801ff2a: 2301         	movs	r3, #0x1
 801ff2c: e000         	b	0x801ff30 <LL_DMA_IsActiveFlag_FE0+0x1a> @ imm = #0x0
 801ff2e: 2300         	movs	r3, #0x0
; }
 801ff30: 4618         	mov	r0, r3
 801ff32: 370c         	adds	r7, #0xc
 801ff34: 46bd         	mov	sp, r7
 801ff36: f85d 7b04    	ldr	r7, [sp], #4
 801ff3a: 4770         	bx	lr

0801ff3c <LL_DMA_IsActiveFlag_FE1>:
; {
 801ff3c: b480         	push	{r7}
 801ff3e: b083         	sub	sp, #0xc
 801ff40: af00         	add	r7, sp, #0x0
 801ff42: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_FEIF1) == (DMA_LISR_FEIF1)) ? 1UL : 0UL);
 801ff44: 687b         	ldr	r3, [r7, #0x4]
 801ff46: 681b         	ldr	r3, [r3]
 801ff48: f003 0340    	and	r3, r3, #0x40
 801ff4c: 2b40         	cmp	r3, #0x40
 801ff4e: d101         	bne	0x801ff54 <LL_DMA_IsActiveFlag_FE1+0x18> @ imm = #0x2
 801ff50: 2301         	movs	r3, #0x1
 801ff52: e000         	b	0x801ff56 <LL_DMA_IsActiveFlag_FE1+0x1a> @ imm = #0x0
 801ff54: 2300         	movs	r3, #0x0
; }
 801ff56: 4618         	mov	r0, r3
 801ff58: 370c         	adds	r7, #0xc
 801ff5a: 46bd         	mov	sp, r7
 801ff5c: f85d 7b04    	ldr	r7, [sp], #4
 801ff60: 4770         	bx	lr

0801ff62 <LL_DMA_IsActiveFlag_FE2>:
; {
 801ff62: b480         	push	{r7}
 801ff64: b083         	sub	sp, #0xc
 801ff66: af00         	add	r7, sp, #0x0
 801ff68: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_FEIF2) == (DMA_LISR_FEIF2)) ? 1UL : 0UL);
 801ff6a: 687b         	ldr	r3, [r7, #0x4]
 801ff6c: 681b         	ldr	r3, [r3]
 801ff6e: f403 3380    	and	r3, r3, #0x10000
 801ff72: f5b3 3f80    	cmp.w	r3, #0x10000
 801ff76: d101         	bne	0x801ff7c <LL_DMA_IsActiveFlag_FE2+0x1a> @ imm = #0x2
 801ff78: 2301         	movs	r3, #0x1
 801ff7a: e000         	b	0x801ff7e <LL_DMA_IsActiveFlag_FE2+0x1c> @ imm = #0x0
 801ff7c: 2300         	movs	r3, #0x0
; }
 801ff7e: 4618         	mov	r0, r3
 801ff80: 370c         	adds	r7, #0xc
 801ff82: 46bd         	mov	sp, r7
 801ff84: f85d 7b04    	ldr	r7, [sp], #4
 801ff88: 4770         	bx	lr

0801ff8a <LL_DMA_IsActiveFlag_FE3>:
; {
 801ff8a: b480         	push	{r7}
 801ff8c: b083         	sub	sp, #0xc
 801ff8e: af00         	add	r7, sp, #0x0
 801ff90: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->LISR, DMA_LISR_FEIF3) == (DMA_LISR_FEIF3)) ? 1UL : 0UL);
 801ff92: 687b         	ldr	r3, [r7, #0x4]
 801ff94: 681b         	ldr	r3, [r3]
 801ff96: f403 0380    	and	r3, r3, #0x400000
 801ff9a: f5b3 0f80    	cmp.w	r3, #0x400000
 801ff9e: d101         	bne	0x801ffa4 <LL_DMA_IsActiveFlag_FE3+0x1a> @ imm = #0x2
 801ffa0: 2301         	movs	r3, #0x1
 801ffa2: e000         	b	0x801ffa6 <LL_DMA_IsActiveFlag_FE3+0x1c> @ imm = #0x0
 801ffa4: 2300         	movs	r3, #0x0
; }
 801ffa6: 4618         	mov	r0, r3
 801ffa8: 370c         	adds	r7, #0xc
 801ffaa: 46bd         	mov	sp, r7
 801ffac: f85d 7b04    	ldr	r7, [sp], #4
 801ffb0: 4770         	bx	lr

0801ffb2 <LL_DMA_IsActiveFlag_FE4>:
; {
 801ffb2: b480         	push	{r7}
 801ffb4: b083         	sub	sp, #0xc
 801ffb6: af00         	add	r7, sp, #0x0
 801ffb8: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_FEIF4) == (DMA_HISR_FEIF4)) ? 1UL : 0UL);
 801ffba: 687b         	ldr	r3, [r7, #0x4]
 801ffbc: 685b         	ldr	r3, [r3, #0x4]
 801ffbe: f003 0301    	and	r3, r3, #0x1
 801ffc2: 2b01         	cmp	r3, #0x1
 801ffc4: d101         	bne	0x801ffca <LL_DMA_IsActiveFlag_FE4+0x18> @ imm = #0x2
 801ffc6: 2301         	movs	r3, #0x1
 801ffc8: e000         	b	0x801ffcc <LL_DMA_IsActiveFlag_FE4+0x1a> @ imm = #0x0
 801ffca: 2300         	movs	r3, #0x0
; }
 801ffcc: 4618         	mov	r0, r3
 801ffce: 370c         	adds	r7, #0xc
 801ffd0: 46bd         	mov	sp, r7
 801ffd2: f85d 7b04    	ldr	r7, [sp], #4
 801ffd6: 4770         	bx	lr

0801ffd8 <LL_DMA_IsActiveFlag_FE5>:
; {
 801ffd8: b480         	push	{r7}
 801ffda: b083         	sub	sp, #0xc
 801ffdc: af00         	add	r7, sp, #0x0
 801ffde: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_FEIF5) == (DMA_HISR_FEIF5)) ? 1UL : 0UL);
 801ffe0: 687b         	ldr	r3, [r7, #0x4]
 801ffe2: 685b         	ldr	r3, [r3, #0x4]
 801ffe4: f003 0340    	and	r3, r3, #0x40
 801ffe8: 2b40         	cmp	r3, #0x40
 801ffea: d101         	bne	0x801fff0 <LL_DMA_IsActiveFlag_FE5+0x18> @ imm = #0x2
 801ffec: 2301         	movs	r3, #0x1
 801ffee: e000         	b	0x801fff2 <LL_DMA_IsActiveFlag_FE5+0x1a> @ imm = #0x0
 801fff0: 2300         	movs	r3, #0x0
; }
 801fff2: 4618         	mov	r0, r3
 801fff4: 370c         	adds	r7, #0xc
 801fff6: 46bd         	mov	sp, r7
 801fff8: f85d 7b04    	ldr	r7, [sp], #4
 801fffc: 4770         	bx	lr

0801fffe <LL_DMA_IsActiveFlag_FE6>:
; {
 801fffe: b480         	push	{r7}
 8020000: b083         	sub	sp, #0xc
 8020002: af00         	add	r7, sp, #0x0
 8020004: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_FEIF6) == (DMA_HISR_FEIF6)) ? 1UL : 0UL);
 8020006: 687b         	ldr	r3, [r7, #0x4]
 8020008: 685b         	ldr	r3, [r3, #0x4]
 802000a: f403 3380    	and	r3, r3, #0x10000
 802000e: f5b3 3f80    	cmp.w	r3, #0x10000
 8020012: d101         	bne	0x8020018 <LL_DMA_IsActiveFlag_FE6+0x1a> @ imm = #0x2
 8020014: 2301         	movs	r3, #0x1
 8020016: e000         	b	0x802001a <LL_DMA_IsActiveFlag_FE6+0x1c> @ imm = #0x0
 8020018: 2300         	movs	r3, #0x0
; }
 802001a: 4618         	mov	r0, r3
 802001c: 370c         	adds	r7, #0xc
 802001e: 46bd         	mov	sp, r7
 8020020: f85d 7b04    	ldr	r7, [sp], #4
 8020024: 4770         	bx	lr

08020026 <LL_DMA_IsActiveFlag_FE7>:
; {
 8020026: b480         	push	{r7}
 8020028: b083         	sub	sp, #0xc
 802002a: af00         	add	r7, sp, #0x0
 802002c: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(DMAx->HISR, DMA_HISR_FEIF7) == (DMA_HISR_FEIF7)) ? 1UL : 0UL);
 802002e: 687b         	ldr	r3, [r7, #0x4]
 8020030: 685b         	ldr	r3, [r3, #0x4]
 8020032: f403 0380    	and	r3, r3, #0x400000
 8020036: f5b3 0f80    	cmp.w	r3, #0x400000
 802003a: d101         	bne	0x8020040 <LL_DMA_IsActiveFlag_FE7+0x1a> @ imm = #0x2
 802003c: 2301         	movs	r3, #0x1
 802003e: e000         	b	0x8020042 <LL_DMA_IsActiveFlag_FE7+0x1c> @ imm = #0x0
 8020040: 2300         	movs	r3, #0x0
; }
 8020042: 4618         	mov	r0, r3
 8020044: 370c         	adds	r7, #0xc
 8020046: 46bd         	mov	sp, r7
 8020048: f85d 7b04    	ldr	r7, [sp], #4
 802004c: 4770         	bx	lr

0802004e <LL_DMA_ClearFlag_HT0>:
; {
 802004e: b480         	push	{r7}
 8020050: b083         	sub	sp, #0xc
 8020052: af00         	add	r7, sp, #0x0
 8020054: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CHTIF0);
 8020056: 687b         	ldr	r3, [r7, #0x4]
 8020058: 2210         	movs	r2, #0x10
 802005a: 609a         	str	r2, [r3, #0x8]
; }
 802005c: bf00         	nop
 802005e: 370c         	adds	r7, #0xc
 8020060: 46bd         	mov	sp, r7
 8020062: f85d 7b04    	ldr	r7, [sp], #4
 8020066: 4770         	bx	lr

08020068 <LL_DMA_ClearFlag_HT1>:
; {
 8020068: b480         	push	{r7}
 802006a: b083         	sub	sp, #0xc
 802006c: af00         	add	r7, sp, #0x0
 802006e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CHTIF1);
 8020070: 687b         	ldr	r3, [r7, #0x4]
 8020072: f44f 6280    	mov.w	r2, #0x400
 8020076: 609a         	str	r2, [r3, #0x8]
; }
 8020078: bf00         	nop
 802007a: 370c         	adds	r7, #0xc
 802007c: 46bd         	mov	sp, r7
 802007e: f85d 7b04    	ldr	r7, [sp], #4
 8020082: 4770         	bx	lr

08020084 <LL_DMA_ClearFlag_HT2>:
; {
 8020084: b480         	push	{r7}
 8020086: b083         	sub	sp, #0xc
 8020088: af00         	add	r7, sp, #0x0
 802008a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CHTIF2);
 802008c: 687b         	ldr	r3, [r7, #0x4]
 802008e: f44f 1280    	mov.w	r2, #0x100000
 8020092: 609a         	str	r2, [r3, #0x8]
; }
 8020094: bf00         	nop
 8020096: 370c         	adds	r7, #0xc
 8020098: 46bd         	mov	sp, r7
 802009a: f85d 7b04    	ldr	r7, [sp], #4
 802009e: 4770         	bx	lr

080200a0 <LL_DMA_ClearFlag_HT3>:
; {
 80200a0: b480         	push	{r7}
 80200a2: b083         	sub	sp, #0xc
 80200a4: af00         	add	r7, sp, #0x0
 80200a6: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CHTIF3);
 80200a8: 687b         	ldr	r3, [r7, #0x4]
 80200aa: f04f 6280    	mov.w	r2, #0x4000000
 80200ae: 609a         	str	r2, [r3, #0x8]
; }
 80200b0: bf00         	nop
 80200b2: 370c         	adds	r7, #0xc
 80200b4: 46bd         	mov	sp, r7
 80200b6: f85d 7b04    	ldr	r7, [sp], #4
 80200ba: 4770         	bx	lr

080200bc <LL_DMA_ClearFlag_HT4>:
; {
 80200bc: b480         	push	{r7}
 80200be: b083         	sub	sp, #0xc
 80200c0: af00         	add	r7, sp, #0x0
 80200c2: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CHTIF4);
 80200c4: 687b         	ldr	r3, [r7, #0x4]
 80200c6: 2210         	movs	r2, #0x10
 80200c8: 60da         	str	r2, [r3, #0xc]
; }
 80200ca: bf00         	nop
 80200cc: 370c         	adds	r7, #0xc
 80200ce: 46bd         	mov	sp, r7
 80200d0: f85d 7b04    	ldr	r7, [sp], #4
 80200d4: 4770         	bx	lr

080200d6 <LL_DMA_ClearFlag_HT5>:
; {
 80200d6: b480         	push	{r7}
 80200d8: b083         	sub	sp, #0xc
 80200da: af00         	add	r7, sp, #0x0
 80200dc: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CHTIF5);
 80200de: 687b         	ldr	r3, [r7, #0x4]
 80200e0: f44f 6280    	mov.w	r2, #0x400
 80200e4: 60da         	str	r2, [r3, #0xc]
; }
 80200e6: bf00         	nop
 80200e8: 370c         	adds	r7, #0xc
 80200ea: 46bd         	mov	sp, r7
 80200ec: f85d 7b04    	ldr	r7, [sp], #4
 80200f0: 4770         	bx	lr

080200f2 <LL_DMA_ClearFlag_HT6>:
; {
 80200f2: b480         	push	{r7}
 80200f4: b083         	sub	sp, #0xc
 80200f6: af00         	add	r7, sp, #0x0
 80200f8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CHTIF6);
 80200fa: 687b         	ldr	r3, [r7, #0x4]
 80200fc: f44f 1280    	mov.w	r2, #0x100000
 8020100: 60da         	str	r2, [r3, #0xc]
; }
 8020102: bf00         	nop
 8020104: 370c         	adds	r7, #0xc
 8020106: 46bd         	mov	sp, r7
 8020108: f85d 7b04    	ldr	r7, [sp], #4
 802010c: 4770         	bx	lr

0802010e <LL_DMA_ClearFlag_HT7>:
; {
 802010e: b480         	push	{r7}
 8020110: b083         	sub	sp, #0xc
 8020112: af00         	add	r7, sp, #0x0
 8020114: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CHTIF7);
 8020116: 687b         	ldr	r3, [r7, #0x4]
 8020118: f04f 6280    	mov.w	r2, #0x4000000
 802011c: 60da         	str	r2, [r3, #0xc]
; }
 802011e: bf00         	nop
 8020120: 370c         	adds	r7, #0xc
 8020122: 46bd         	mov	sp, r7
 8020124: f85d 7b04    	ldr	r7, [sp], #4
 8020128: 4770         	bx	lr

0802012a <LL_DMA_ClearFlag_TC0>:
; {
 802012a: b480         	push	{r7}
 802012c: b083         	sub	sp, #0xc
 802012e: af00         	add	r7, sp, #0x0
 8020130: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CTCIF0);
 8020132: 687b         	ldr	r3, [r7, #0x4]
 8020134: 2220         	movs	r2, #0x20
 8020136: 609a         	str	r2, [r3, #0x8]
; }
 8020138: bf00         	nop
 802013a: 370c         	adds	r7, #0xc
 802013c: 46bd         	mov	sp, r7
 802013e: f85d 7b04    	ldr	r7, [sp], #4
 8020142: 4770         	bx	lr

08020144 <LL_DMA_ClearFlag_TC1>:
; {
 8020144: b480         	push	{r7}
 8020146: b083         	sub	sp, #0xc
 8020148: af00         	add	r7, sp, #0x0
 802014a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CTCIF1);
 802014c: 687b         	ldr	r3, [r7, #0x4]
 802014e: f44f 6200    	mov.w	r2, #0x800
 8020152: 609a         	str	r2, [r3, #0x8]
; }
 8020154: bf00         	nop
 8020156: 370c         	adds	r7, #0xc
 8020158: 46bd         	mov	sp, r7
 802015a: f85d 7b04    	ldr	r7, [sp], #4
 802015e: 4770         	bx	lr

08020160 <LL_DMA_ClearFlag_TC2>:
; {
 8020160: b480         	push	{r7}
 8020162: b083         	sub	sp, #0xc
 8020164: af00         	add	r7, sp, #0x0
 8020166: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CTCIF2);
 8020168: 687b         	ldr	r3, [r7, #0x4]
 802016a: f44f 1200    	mov.w	r2, #0x200000
 802016e: 609a         	str	r2, [r3, #0x8]
; }
 8020170: bf00         	nop
 8020172: 370c         	adds	r7, #0xc
 8020174: 46bd         	mov	sp, r7
 8020176: f85d 7b04    	ldr	r7, [sp], #4
 802017a: 4770         	bx	lr

0802017c <LL_DMA_ClearFlag_TC3>:
; {
 802017c: b480         	push	{r7}
 802017e: b083         	sub	sp, #0xc
 8020180: af00         	add	r7, sp, #0x0
 8020182: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CTCIF3);
 8020184: 687b         	ldr	r3, [r7, #0x4]
 8020186: f04f 6200    	mov.w	r2, #0x8000000
 802018a: 609a         	str	r2, [r3, #0x8]
; }
 802018c: bf00         	nop
 802018e: 370c         	adds	r7, #0xc
 8020190: 46bd         	mov	sp, r7
 8020192: f85d 7b04    	ldr	r7, [sp], #4
 8020196: 4770         	bx	lr

08020198 <LL_DMA_ClearFlag_TC4>:
; {
 8020198: b480         	push	{r7}
 802019a: b083         	sub	sp, #0xc
 802019c: af00         	add	r7, sp, #0x0
 802019e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CTCIF4);
 80201a0: 687b         	ldr	r3, [r7, #0x4]
 80201a2: 2220         	movs	r2, #0x20
 80201a4: 60da         	str	r2, [r3, #0xc]
; }
 80201a6: bf00         	nop
 80201a8: 370c         	adds	r7, #0xc
 80201aa: 46bd         	mov	sp, r7
 80201ac: f85d 7b04    	ldr	r7, [sp], #4
 80201b0: 4770         	bx	lr

080201b2 <LL_DMA_ClearFlag_TC5>:
; {
 80201b2: b480         	push	{r7}
 80201b4: b083         	sub	sp, #0xc
 80201b6: af00         	add	r7, sp, #0x0
 80201b8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CTCIF5);
 80201ba: 687b         	ldr	r3, [r7, #0x4]
 80201bc: f44f 6200    	mov.w	r2, #0x800
 80201c0: 60da         	str	r2, [r3, #0xc]
; }
 80201c2: bf00         	nop
 80201c4: 370c         	adds	r7, #0xc
 80201c6: 46bd         	mov	sp, r7
 80201c8: f85d 7b04    	ldr	r7, [sp], #4
 80201cc: 4770         	bx	lr

080201ce <LL_DMA_ClearFlag_TC6>:
; {
 80201ce: b480         	push	{r7}
 80201d0: b083         	sub	sp, #0xc
 80201d2: af00         	add	r7, sp, #0x0
 80201d4: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CTCIF6);
 80201d6: 687b         	ldr	r3, [r7, #0x4]
 80201d8: f44f 1200    	mov.w	r2, #0x200000
 80201dc: 60da         	str	r2, [r3, #0xc]
; }
 80201de: bf00         	nop
 80201e0: 370c         	adds	r7, #0xc
 80201e2: 46bd         	mov	sp, r7
 80201e4: f85d 7b04    	ldr	r7, [sp], #4
 80201e8: 4770         	bx	lr

080201ea <LL_DMA_ClearFlag_TC7>:
; {
 80201ea: b480         	push	{r7}
 80201ec: b083         	sub	sp, #0xc
 80201ee: af00         	add	r7, sp, #0x0
 80201f0: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CTCIF7);
 80201f2: 687b         	ldr	r3, [r7, #0x4]
 80201f4: f04f 6200    	mov.w	r2, #0x8000000
 80201f8: 60da         	str	r2, [r3, #0xc]
; }
 80201fa: bf00         	nop
 80201fc: 370c         	adds	r7, #0xc
 80201fe: 46bd         	mov	sp, r7
 8020200: f85d 7b04    	ldr	r7, [sp], #4
 8020204: 4770         	bx	lr

08020206 <LL_DMA_ClearFlag_TE0>:
; {
 8020206: b480         	push	{r7}
 8020208: b083         	sub	sp, #0xc
 802020a: af00         	add	r7, sp, #0x0
 802020c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CTEIF0);
 802020e: 687b         	ldr	r3, [r7, #0x4]
 8020210: 2208         	movs	r2, #0x8
 8020212: 609a         	str	r2, [r3, #0x8]
; }
 8020214: bf00         	nop
 8020216: 370c         	adds	r7, #0xc
 8020218: 46bd         	mov	sp, r7
 802021a: f85d 7b04    	ldr	r7, [sp], #4
 802021e: 4770         	bx	lr

08020220 <LL_DMA_ClearFlag_TE1>:
; {
 8020220: b480         	push	{r7}
 8020222: b083         	sub	sp, #0xc
 8020224: af00         	add	r7, sp, #0x0
 8020226: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CTEIF1);
 8020228: 687b         	ldr	r3, [r7, #0x4]
 802022a: f44f 7200    	mov.w	r2, #0x200
 802022e: 609a         	str	r2, [r3, #0x8]
; }
 8020230: bf00         	nop
 8020232: 370c         	adds	r7, #0xc
 8020234: 46bd         	mov	sp, r7
 8020236: f85d 7b04    	ldr	r7, [sp], #4
 802023a: 4770         	bx	lr

0802023c <LL_DMA_ClearFlag_TE2>:
; {
 802023c: b480         	push	{r7}
 802023e: b083         	sub	sp, #0xc
 8020240: af00         	add	r7, sp, #0x0
 8020242: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CTEIF2);
 8020244: 687b         	ldr	r3, [r7, #0x4]
 8020246: f44f 2200    	mov.w	r2, #0x80000
 802024a: 609a         	str	r2, [r3, #0x8]
; }
 802024c: bf00         	nop
 802024e: 370c         	adds	r7, #0xc
 8020250: 46bd         	mov	sp, r7
 8020252: f85d 7b04    	ldr	r7, [sp], #4
 8020256: 4770         	bx	lr

08020258 <LL_DMA_ClearFlag_TE3>:
; {
 8020258: b480         	push	{r7}
 802025a: b083         	sub	sp, #0xc
 802025c: af00         	add	r7, sp, #0x0
 802025e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CTEIF3);
 8020260: 687b         	ldr	r3, [r7, #0x4]
 8020262: f04f 7200    	mov.w	r2, #0x2000000
 8020266: 609a         	str	r2, [r3, #0x8]
; }
 8020268: bf00         	nop
 802026a: 370c         	adds	r7, #0xc
 802026c: 46bd         	mov	sp, r7
 802026e: f85d 7b04    	ldr	r7, [sp], #4
 8020272: 4770         	bx	lr

08020274 <LL_DMA_ClearFlag_TE4>:
; {
 8020274: b480         	push	{r7}
 8020276: b083         	sub	sp, #0xc
 8020278: af00         	add	r7, sp, #0x0
 802027a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CTEIF4);
 802027c: 687b         	ldr	r3, [r7, #0x4]
 802027e: 2208         	movs	r2, #0x8
 8020280: 60da         	str	r2, [r3, #0xc]
; }
 8020282: bf00         	nop
 8020284: 370c         	adds	r7, #0xc
 8020286: 46bd         	mov	sp, r7
 8020288: f85d 7b04    	ldr	r7, [sp], #4
 802028c: 4770         	bx	lr

0802028e <LL_DMA_ClearFlag_TE5>:
; {
 802028e: b480         	push	{r7}
 8020290: b083         	sub	sp, #0xc
 8020292: af00         	add	r7, sp, #0x0
 8020294: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CTEIF5);
 8020296: 687b         	ldr	r3, [r7, #0x4]
 8020298: f44f 7200    	mov.w	r2, #0x200
 802029c: 60da         	str	r2, [r3, #0xc]
; }
 802029e: bf00         	nop
 80202a0: 370c         	adds	r7, #0xc
 80202a2: 46bd         	mov	sp, r7
 80202a4: f85d 7b04    	ldr	r7, [sp], #4
 80202a8: 4770         	bx	lr

080202aa <LL_DMA_ClearFlag_TE6>:
; {
 80202aa: b480         	push	{r7}
 80202ac: b083         	sub	sp, #0xc
 80202ae: af00         	add	r7, sp, #0x0
 80202b0: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CTEIF6);
 80202b2: 687b         	ldr	r3, [r7, #0x4]
 80202b4: f44f 2200    	mov.w	r2, #0x80000
 80202b8: 60da         	str	r2, [r3, #0xc]
; }
 80202ba: bf00         	nop
 80202bc: 370c         	adds	r7, #0xc
 80202be: 46bd         	mov	sp, r7
 80202c0: f85d 7b04    	ldr	r7, [sp], #4
 80202c4: 4770         	bx	lr

080202c6 <LL_DMA_ClearFlag_TE7>:
; {
 80202c6: b480         	push	{r7}
 80202c8: b083         	sub	sp, #0xc
 80202ca: af00         	add	r7, sp, #0x0
 80202cc: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CTEIF7);
 80202ce: 687b         	ldr	r3, [r7, #0x4]
 80202d0: f04f 7200    	mov.w	r2, #0x2000000
 80202d4: 60da         	str	r2, [r3, #0xc]
; }
 80202d6: bf00         	nop
 80202d8: 370c         	adds	r7, #0xc
 80202da: 46bd         	mov	sp, r7
 80202dc: f85d 7b04    	ldr	r7, [sp], #4
 80202e0: 4770         	bx	lr

080202e2 <LL_DMA_ClearFlag_DME0>:
; {
 80202e2: b480         	push	{r7}
 80202e4: b083         	sub	sp, #0xc
 80202e6: af00         	add	r7, sp, #0x0
 80202e8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CDMEIF0);
 80202ea: 687b         	ldr	r3, [r7, #0x4]
 80202ec: 2204         	movs	r2, #0x4
 80202ee: 609a         	str	r2, [r3, #0x8]
; }
 80202f0: bf00         	nop
 80202f2: 370c         	adds	r7, #0xc
 80202f4: 46bd         	mov	sp, r7
 80202f6: f85d 7b04    	ldr	r7, [sp], #4
 80202fa: 4770         	bx	lr

080202fc <LL_DMA_ClearFlag_DME1>:
; {
 80202fc: b480         	push	{r7}
 80202fe: b083         	sub	sp, #0xc
 8020300: af00         	add	r7, sp, #0x0
 8020302: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CDMEIF1);
 8020304: 687b         	ldr	r3, [r7, #0x4]
 8020306: f44f 7280    	mov.w	r2, #0x100
 802030a: 609a         	str	r2, [r3, #0x8]
; }
 802030c: bf00         	nop
 802030e: 370c         	adds	r7, #0xc
 8020310: 46bd         	mov	sp, r7
 8020312: f85d 7b04    	ldr	r7, [sp], #4
 8020316: 4770         	bx	lr

08020318 <LL_DMA_ClearFlag_DME2>:
; {
 8020318: b480         	push	{r7}
 802031a: b083         	sub	sp, #0xc
 802031c: af00         	add	r7, sp, #0x0
 802031e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CDMEIF2);
 8020320: 687b         	ldr	r3, [r7, #0x4]
 8020322: f44f 2280    	mov.w	r2, #0x40000
 8020326: 609a         	str	r2, [r3, #0x8]
; }
 8020328: bf00         	nop
 802032a: 370c         	adds	r7, #0xc
 802032c: 46bd         	mov	sp, r7
 802032e: f85d 7b04    	ldr	r7, [sp], #4
 8020332: 4770         	bx	lr

08020334 <LL_DMA_ClearFlag_DME3>:
; {
 8020334: b480         	push	{r7}
 8020336: b083         	sub	sp, #0xc
 8020338: af00         	add	r7, sp, #0x0
 802033a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CDMEIF3);
 802033c: 687b         	ldr	r3, [r7, #0x4]
 802033e: f04f 7280    	mov.w	r2, #0x1000000
 8020342: 609a         	str	r2, [r3, #0x8]
; }
 8020344: bf00         	nop
 8020346: 370c         	adds	r7, #0xc
 8020348: 46bd         	mov	sp, r7
 802034a: f85d 7b04    	ldr	r7, [sp], #4
 802034e: 4770         	bx	lr

08020350 <LL_DMA_ClearFlag_DME4>:
; {
 8020350: b480         	push	{r7}
 8020352: b083         	sub	sp, #0xc
 8020354: af00         	add	r7, sp, #0x0
 8020356: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CDMEIF4);
 8020358: 687b         	ldr	r3, [r7, #0x4]
 802035a: 2204         	movs	r2, #0x4
 802035c: 60da         	str	r2, [r3, #0xc]
; }
 802035e: bf00         	nop
 8020360: 370c         	adds	r7, #0xc
 8020362: 46bd         	mov	sp, r7
 8020364: f85d 7b04    	ldr	r7, [sp], #4
 8020368: 4770         	bx	lr

0802036a <LL_DMA_ClearFlag_DME5>:
; {
 802036a: b480         	push	{r7}
 802036c: b083         	sub	sp, #0xc
 802036e: af00         	add	r7, sp, #0x0
 8020370: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CDMEIF5);
 8020372: 687b         	ldr	r3, [r7, #0x4]
 8020374: f44f 7280    	mov.w	r2, #0x100
 8020378: 60da         	str	r2, [r3, #0xc]
; }
 802037a: bf00         	nop
 802037c: 370c         	adds	r7, #0xc
 802037e: 46bd         	mov	sp, r7
 8020380: f85d 7b04    	ldr	r7, [sp], #4
 8020384: 4770         	bx	lr

08020386 <LL_DMA_ClearFlag_DME6>:
; {
 8020386: b480         	push	{r7}
 8020388: b083         	sub	sp, #0xc
 802038a: af00         	add	r7, sp, #0x0
 802038c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CDMEIF6);
 802038e: 687b         	ldr	r3, [r7, #0x4]
 8020390: f44f 2280    	mov.w	r2, #0x40000
 8020394: 60da         	str	r2, [r3, #0xc]
; }
 8020396: bf00         	nop
 8020398: 370c         	adds	r7, #0xc
 802039a: 46bd         	mov	sp, r7
 802039c: f85d 7b04    	ldr	r7, [sp], #4
 80203a0: 4770         	bx	lr

080203a2 <LL_DMA_ClearFlag_DME7>:
; {
 80203a2: b480         	push	{r7}
 80203a4: b083         	sub	sp, #0xc
 80203a6: af00         	add	r7, sp, #0x0
 80203a8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CDMEIF7);
 80203aa: 687b         	ldr	r3, [r7, #0x4]
 80203ac: f04f 7280    	mov.w	r2, #0x1000000
 80203b0: 60da         	str	r2, [r3, #0xc]
; }
 80203b2: bf00         	nop
 80203b4: 370c         	adds	r7, #0xc
 80203b6: 46bd         	mov	sp, r7
 80203b8: f85d 7b04    	ldr	r7, [sp], #4
 80203bc: 4770         	bx	lr

080203be <LL_DMA_ClearFlag_FE0>:
; {
 80203be: b480         	push	{r7}
 80203c0: b083         	sub	sp, #0xc
 80203c2: af00         	add	r7, sp, #0x0
 80203c4: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CFEIF0);
 80203c6: 687b         	ldr	r3, [r7, #0x4]
 80203c8: 2201         	movs	r2, #0x1
 80203ca: 609a         	str	r2, [r3, #0x8]
; }
 80203cc: bf00         	nop
 80203ce: 370c         	adds	r7, #0xc
 80203d0: 46bd         	mov	sp, r7
 80203d2: f85d 7b04    	ldr	r7, [sp], #4
 80203d6: 4770         	bx	lr

080203d8 <LL_DMA_ClearFlag_FE1>:
; {
 80203d8: b480         	push	{r7}
 80203da: b083         	sub	sp, #0xc
 80203dc: af00         	add	r7, sp, #0x0
 80203de: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CFEIF1);
 80203e0: 687b         	ldr	r3, [r7, #0x4]
 80203e2: 2240         	movs	r2, #0x40
 80203e4: 609a         	str	r2, [r3, #0x8]
; }
 80203e6: bf00         	nop
 80203e8: 370c         	adds	r7, #0xc
 80203ea: 46bd         	mov	sp, r7
 80203ec: f85d 7b04    	ldr	r7, [sp], #4
 80203f0: 4770         	bx	lr

080203f2 <LL_DMA_ClearFlag_FE2>:
; {
 80203f2: b480         	push	{r7}
 80203f4: b083         	sub	sp, #0xc
 80203f6: af00         	add	r7, sp, #0x0
 80203f8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CFEIF2);
 80203fa: 687b         	ldr	r3, [r7, #0x4]
 80203fc: f44f 3280    	mov.w	r2, #0x10000
 8020400: 609a         	str	r2, [r3, #0x8]
; }
 8020402: bf00         	nop
 8020404: 370c         	adds	r7, #0xc
 8020406: 46bd         	mov	sp, r7
 8020408: f85d 7b04    	ldr	r7, [sp], #4
 802040c: 4770         	bx	lr

0802040e <LL_DMA_ClearFlag_FE3>:
; {
 802040e: b480         	push	{r7}
 8020410: b083         	sub	sp, #0xc
 8020412: af00         	add	r7, sp, #0x0
 8020414: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR, DMA_LIFCR_CFEIF3);
 8020416: 687b         	ldr	r3, [r7, #0x4]
 8020418: f44f 0280    	mov.w	r2, #0x400000
 802041c: 609a         	str	r2, [r3, #0x8]
; }
 802041e: bf00         	nop
 8020420: 370c         	adds	r7, #0xc
 8020422: 46bd         	mov	sp, r7
 8020424: f85d 7b04    	ldr	r7, [sp], #4
 8020428: 4770         	bx	lr

0802042a <LL_DMA_ClearFlag_FE4>:
; {
 802042a: b480         	push	{r7}
 802042c: b083         	sub	sp, #0xc
 802042e: af00         	add	r7, sp, #0x0
 8020430: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CFEIF4);
 8020432: 687b         	ldr	r3, [r7, #0x4]
 8020434: 2201         	movs	r2, #0x1
 8020436: 60da         	str	r2, [r3, #0xc]
; }
 8020438: bf00         	nop
 802043a: 370c         	adds	r7, #0xc
 802043c: 46bd         	mov	sp, r7
 802043e: f85d 7b04    	ldr	r7, [sp], #4
 8020442: 4770         	bx	lr

08020444 <LL_DMA_ClearFlag_FE5>:
; {
 8020444: b480         	push	{r7}
 8020446: b083         	sub	sp, #0xc
 8020448: af00         	add	r7, sp, #0x0
 802044a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CFEIF5);
 802044c: 687b         	ldr	r3, [r7, #0x4]
 802044e: 2240         	movs	r2, #0x40
 8020450: 60da         	str	r2, [r3, #0xc]
; }
 8020452: bf00         	nop
 8020454: 370c         	adds	r7, #0xc
 8020456: 46bd         	mov	sp, r7
 8020458: f85d 7b04    	ldr	r7, [sp], #4
 802045c: 4770         	bx	lr

0802045e <LL_DMA_ClearFlag_FE6>:
; {
 802045e: b480         	push	{r7}
 8020460: b083         	sub	sp, #0xc
 8020462: af00         	add	r7, sp, #0x0
 8020464: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CFEIF6);
 8020466: 687b         	ldr	r3, [r7, #0x4]
 8020468: f44f 3280    	mov.w	r2, #0x10000
 802046c: 60da         	str	r2, [r3, #0xc]
; }
 802046e: bf00         	nop
 8020470: 370c         	adds	r7, #0xc
 8020472: 46bd         	mov	sp, r7
 8020474: f85d 7b04    	ldr	r7, [sp], #4
 8020478: 4770         	bx	lr

0802047a <LL_DMA_ClearFlag_FE7>:
; {
 802047a: b480         	push	{r7}
 802047c: b083         	sub	sp, #0xc
 802047e: af00         	add	r7, sp, #0x0
 8020480: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR, DMA_HIFCR_CFEIF7);
 8020482: 687b         	ldr	r3, [r7, #0x4]
 8020484: f44f 0280    	mov.w	r2, #0x400000
 8020488: 60da         	str	r2, [r3, #0xc]
; }
 802048a: bf00         	nop
 802048c: 370c         	adds	r7, #0xc
 802048e: 46bd         	mov	sp, r7
 8020490: f85d 7b04    	ldr	r7, [sp], #4
 8020494: 4770         	bx	lr

08020496 <z_log_msg_runtime_create>:
; {
 8020496: b580         	push	{r7, lr}
 8020498: b08a         	sub	sp, #0x28
 802049a: af04         	add	r7, sp, #0x10
 802049c: 60b9         	str	r1, [r7, #0x8]
 802049e: 607b         	str	r3, [r7, #0x4]
 80204a0: 4603         	mov	r3, r0
 80204a2: 73fb         	strb	r3, [r7, #0xf]
 80204a4: 4613         	mov	r3, r2
 80204a6: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80204a8: f107 032c    	add.w	r3, r7, #0x2c
 80204ac: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80204ae: 7bba         	ldrb	r2, [r7, #0xe]
 80204b0: 7bf8         	ldrb	r0, [r7, #0xf]
 80204b2: 697b         	ldr	r3, [r7, #0x14]
 80204b4: 9303         	str	r3, [sp, #0xc]
 80204b6: 6abb         	ldr	r3, [r7, #0x28]
 80204b8: 9302         	str	r3, [sp, #0x8]
 80204ba: 6a7b         	ldr	r3, [r7, #0x24]
 80204bc: 9301         	str	r3, [sp, #0x4]
 80204be: 6a3b         	ldr	r3, [r7, #0x20]
 80204c0: 9300         	str	r3, [sp]
 80204c2: 687b         	ldr	r3, [r7, #0x4]
 80204c4: 68b9         	ldr	r1, [r7, #0x8]
 80204c6: f7e4 fb55    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1b956
; }
 80204ca: bf00         	nop
 80204cc: 3718         	adds	r7, #0x18
 80204ce: 46bd         	mov	sp, r7
 80204d0: bd80         	pop	{r7, pc}

080204d2 <stm32_dma_is_tc_irq_active>:
; {
 80204d2: b580         	push	{r7, lr}
 80204d4: b082         	sub	sp, #0x8
 80204d6: af00         	add	r7, sp, #0x0
 80204d8: 6078         	str	r0, [r7, #0x4]
 80204da: 6039         	str	r1, [r7]
; 	return LL_DMA_IsEnabledIT_TC(dma, dma_stm32_id_to_stream(id)) &&
 80204dc: 6838         	ldr	r0, [r7]
 80204de: f7eb ffab    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x140aa
 80204e2: 4603         	mov	r3, r0
 80204e4: 4619         	mov	r1, r3
 80204e6: 6878         	ldr	r0, [r7, #0x4]
 80204e8: f7eb ff6a    	bl	0x800c3c0 <LL_DMA_IsEnabledIT_TC> @ imm = #-0x1412c
 80204ec: 4603         	mov	r3, r0
 80204ee: 2b00         	cmp	r3, #0x0
 80204f0: d008         	beq	0x8020504 <stm32_dma_is_tc_irq_active+0x32> @ imm = #0x10
; 	       dma_stm32_is_tc_active(dma, id);
 80204f2: 6839         	ldr	r1, [r7]
 80204f4: 6878         	ldr	r0, [r7, #0x4]
 80204f6: f7eb ffeb    	bl	0x800c4d0 <dma_stm32_is_tc_active> @ imm = #-0x1402a
 80204fa: 4603         	mov	r3, r0
; 	return LL_DMA_IsEnabledIT_TC(dma, dma_stm32_id_to_stream(id)) &&
 80204fc: 2b00         	cmp	r3, #0x0
 80204fe: d001         	beq	0x8020504 <stm32_dma_is_tc_irq_active+0x32> @ imm = #0x2
 8020500: 2301         	movs	r3, #0x1
 8020502: e000         	b	0x8020506 <stm32_dma_is_tc_irq_active+0x34> @ imm = #0x0
 8020504: 2300         	movs	r3, #0x0
 8020506: f003 0301    	and	r3, r3, #0x1
 802050a: b2db         	uxtb	r3, r3
; }
 802050c: 4618         	mov	r0, r3
 802050e: 3708         	adds	r7, #0x8
 8020510: 46bd         	mov	sp, r7
 8020512: bd80         	pop	{r7, pc}

08020514 <stm32_dma_is_ht_irq_active>:
; {
 8020514: b580         	push	{r7, lr}
 8020516: b082         	sub	sp, #0x8
 8020518: af00         	add	r7, sp, #0x0
 802051a: 6078         	str	r0, [r7, #0x4]
 802051c: 6039         	str	r1, [r7]
; 	return LL_DMA_IsEnabledIT_HT(dma, dma_stm32_id_to_stream(id)) &&
 802051e: 6838         	ldr	r0, [r7]
 8020520: f7eb ff8a    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x140ec
 8020524: 4603         	mov	r3, r0
 8020526: 4619         	mov	r1, r3
 8020528: 6878         	ldr	r0, [r7, #0x4]
 802052a: f7eb ff2b    	bl	0x800c384 <LL_DMA_IsEnabledIT_HT> @ imm = #-0x141aa
 802052e: 4603         	mov	r3, r0
 8020530: 2b00         	cmp	r3, #0x0
 8020532: d008         	beq	0x8020546 <stm32_dma_is_ht_irq_active+0x32> @ imm = #0x10
; 	       dma_stm32_is_ht_active(dma, id);
 8020534: 6839         	ldr	r1, [r7]
 8020536: 6878         	ldr	r0, [r7, #0x4]
 8020538: f7eb ffb2    	bl	0x800c4a0 <dma_stm32_is_ht_active> @ imm = #-0x1409c
 802053c: 4603         	mov	r3, r0
; 	return LL_DMA_IsEnabledIT_HT(dma, dma_stm32_id_to_stream(id)) &&
 802053e: 2b00         	cmp	r3, #0x0
 8020540: d001         	beq	0x8020546 <stm32_dma_is_ht_irq_active+0x32> @ imm = #0x2
 8020542: 2301         	movs	r3, #0x1
 8020544: e000         	b	0x8020548 <stm32_dma_is_ht_irq_active+0x34> @ imm = #0x0
 8020546: 2300         	movs	r3, #0x0
 8020548: f003 0301    	and	r3, r3, #0x1
 802054c: b2db         	uxtb	r3, r3
; }
 802054e: 4618         	mov	r0, r3
 8020550: 3708         	adds	r7, #0x8
 8020552: 46bd         	mov	sp, r7
 8020554: bd80         	pop	{r7, pc}

08020556 <stm32_dma_clear_stream_irq>:
; {
 8020556: b580         	push	{r7, lr}
 8020558: b082         	sub	sp, #0x8
 802055a: af00         	add	r7, sp, #0x0
 802055c: 6078         	str	r0, [r7, #0x4]
 802055e: 6039         	str	r1, [r7]
; 	dma_stm32_clear_te(dma, id);
 8020560: 6839         	ldr	r1, [r7]
 8020562: 6878         	ldr	r0, [r7, #0x4]
 8020564: f7eb ffcc    	bl	0x800c500 <dma_stm32_clear_te> @ imm = #-0x14068
; 	dma_stm32_clear_dme(dma, id);
 8020568: 6839         	ldr	r1, [r7]
 802056a: 6878         	ldr	r0, [r7, #0x4]
 802056c: f7eb ffda    	bl	0x800c524 <dma_stm32_clear_dme> @ imm = #-0x1404c
; 	dma_stm32_clear_fe(dma, id);
 8020570: 6839         	ldr	r1, [r7]
 8020572: 6878         	ldr	r0, [r7, #0x4]
 8020574: f7eb ffe8    	bl	0x800c548 <dma_stm32_clear_fe> @ imm = #-0x14030
; }
 8020578: bf00         	nop
 802057a: 3708         	adds	r7, #0x8
 802057c: 46bd         	mov	sp, r7
 802057e: bd80         	pop	{r7, pc}

08020580 <stm32_dma_enable_stream>:
; {
 8020580: b580         	push	{r7, lr}
 8020582: b082         	sub	sp, #0x8
 8020584: af00         	add	r7, sp, #0x0
 8020586: 6078         	str	r0, [r7, #0x4]
 8020588: 6039         	str	r1, [r7]
; 	LL_DMA_EnableStream(dma, dma_stm32_id_to_stream(id));
 802058a: 6838         	ldr	r0, [r7]
 802058c: f7eb ff54    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x14158
 8020590: 4603         	mov	r3, r0
 8020592: 4619         	mov	r1, r3
 8020594: 6878         	ldr	r0, [r7, #0x4]
 8020596: f7eb fe71    	bl	0x800c27c <LL_DMA_EnableStream> @ imm = #-0x1431e
; }
 802059a: bf00         	nop
 802059c: 3708         	adds	r7, #0x8
 802059e: 46bd         	mov	sp, r7
 80205a0: bd80         	pop	{r7, pc}

080205a2 <stm32_dma_is_enabled_stream>:
; {
 80205a2: b580         	push	{r7, lr}
 80205a4: b082         	sub	sp, #0x8
 80205a6: af00         	add	r7, sp, #0x0
 80205a8: 6078         	str	r0, [r7, #0x4]
 80205aa: 6039         	str	r1, [r7]
; 	if (LL_DMA_IsEnabledStream(dma, dma_stm32_id_to_stream(id)) == 1) {
 80205ac: 6838         	ldr	r0, [r7]
 80205ae: f7eb ff43    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x1417a
 80205b2: 4603         	mov	r3, r0
 80205b4: 4619         	mov	r1, r3
 80205b6: 6878         	ldr	r0, [r7, #0x4]
 80205b8: f7eb fea4    	bl	0x800c304 <LL_DMA_IsEnabledStream> @ imm = #-0x142b8
 80205bc: 4603         	mov	r3, r0
 80205be: 2b01         	cmp	r3, #0x1
 80205c0: d101         	bne	0x80205c6 <stm32_dma_is_enabled_stream+0x24> @ imm = #0x2
; 		return true;
 80205c2: 2301         	movs	r3, #0x1
 80205c4: e000         	b	0x80205c8 <stm32_dma_is_enabled_stream+0x26> @ imm = #0x0
; 	return false;
 80205c6: 2300         	movs	r3, #0x0
; }
 80205c8: 4618         	mov	r0, r3
 80205ca: 3708         	adds	r7, #0x8
 80205cc: 46bd         	mov	sp, r7
 80205ce: bd80         	pop	{r7, pc}

080205d0 <stm32_dma_disable_stream>:
; {
 80205d0: b580         	push	{r7, lr}
 80205d2: b082         	sub	sp, #0x8
 80205d4: af00         	add	r7, sp, #0x0
 80205d6: 6078         	str	r0, [r7, #0x4]
 80205d8: 6039         	str	r1, [r7]
; 	LL_DMA_DisableStream(dma, dma_stm32_id_to_stream(id));
 80205da: 6838         	ldr	r0, [r7]
 80205dc: f7eb ff2c    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x141a8
 80205e0: 4603         	mov	r3, r0
 80205e2: 4619         	mov	r1, r3
 80205e4: 6878         	ldr	r0, [r7, #0x4]
 80205e6: f7eb fe6b    	bl	0x800c2c0 <LL_DMA_DisableStream> @ imm = #-0x1432a
; 	while (stm32_dma_is_enabled_stream(dma, id)) {
 80205ea: bf00         	nop
 80205ec: 6839         	ldr	r1, [r7]
 80205ee: 6878         	ldr	r0, [r7, #0x4]
 80205f0: f7ff ffd7    	bl	0x80205a2 <stm32_dma_is_enabled_stream> @ imm = #-0x52
 80205f4: 4603         	mov	r3, r0
 80205f6: 2b00         	cmp	r3, #0x0
 80205f8: d1f8         	bne	0x80205ec <stm32_dma_disable_stream+0x1c> @ imm = #-0x10
; 	dma_stm32_clear_tc(dma, id);
 80205fa: 6839         	ldr	r1, [r7]
 80205fc: 6878         	ldr	r0, [r7, #0x4]
 80205fe: f7eb ff3d    	bl	0x800c47c <dma_stm32_clear_tc> @ imm = #-0x14186
; 	return 0;
 8020602: 2300         	movs	r3, #0x0
; }
 8020604: 4618         	mov	r0, r3
 8020606: 3708         	adds	r7, #0x8
 8020608: 46bd         	mov	sp, r7
 802060a: bd80         	pop	{r7, pc}

0802060c <stm32_dma_disable_fifo_irq>:
; {
 802060c: b580         	push	{r7, lr}
 802060e: b082         	sub	sp, #0x8
 8020610: af00         	add	r7, sp, #0x0
 8020612: 6078         	str	r0, [r7, #0x4]
 8020614: 6039         	str	r1, [r7]
; 	LL_DMA_DisableIT_FE(dma, dma_stm32_id_to_stream(id));
 8020616: 6838         	ldr	r0, [r7]
 8020618: f7eb ff0e    	bl	0x800c438 <dma_stm32_id_to_stream> @ imm = #-0x141e4
 802061c: 4603         	mov	r3, r0
 802061e: 4619         	mov	r1, r3
 8020620: 6878         	ldr	r0, [r7, #0x4]
 8020622: f7eb fe8d    	bl	0x800c340 <LL_DMA_DisableIT_FE> @ imm = #-0x142e6
; }
 8020626: bf00         	nop
 8020628: 3708         	adds	r7, #0x8
 802062a: 46bd         	mov	sp, r7
 802062c: bd80         	pop	{r7, pc}

0802062e <stm32_dma_check_fifo_mburst>:
; {
 802062e: b480         	push	{r7}
 8020630: b087         	sub	sp, #0x1c
 8020632: af00         	add	r7, sp, #0x0
 8020634: 6078         	str	r0, [r7, #0x4]
; 	uint32_t msize = DMAx->MemoryOrM2MDstDataSize;
 8020636: 687b         	ldr	r3, [r7, #0x4]
 8020638: 69db         	ldr	r3, [r3, #0x1c]
 802063a: 617b         	str	r3, [r7, #0x14]
; 	uint32_t fifo_level = DMAx->FIFOThreshold;
 802063c: 687b         	ldr	r3, [r7, #0x4]
 802063e: 6b1b         	ldr	r3, [r3, #0x30]
 8020640: 613b         	str	r3, [r7, #0x10]
; 	uint32_t mburst = DMAx->MemBurst;
 8020642: 687b         	ldr	r3, [r7, #0x4]
 8020644: 6b5b         	ldr	r3, [r3, #0x34]
 8020646: 60fb         	str	r3, [r7, #0xc]
; 	switch (msize) {
 8020648: 697b         	ldr	r3, [r7, #0x14]
 802064a: f5b3 4f80    	cmp.w	r3, #0x4000
 802064e: d049         	beq	0x80206e4 <stm32_dma_check_fifo_mburst+0xb6> @ imm = #0x92
 8020650: 697b         	ldr	r3, [r7, #0x14]
 8020652: f5b3 4f80    	cmp.w	r3, #0x4000
 8020656: d84f         	bhi	0x80206f8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x9e
 8020658: 697b         	ldr	r3, [r7, #0x14]
 802065a: 2b00         	cmp	r3, #0x0
 802065c: d004         	beq	0x8020668 <stm32_dma_check_fifo_mburst+0x3a> @ imm = #0x8
 802065e: 697b         	ldr	r3, [r7, #0x14]
 8020660: f5b3 5f00    	cmp.w	r3, #0x2000
 8020664: d024         	beq	0x80206b0 <stm32_dma_check_fifo_mburst+0x82> @ imm = #0x48
 8020666: e047         	b	0x80206f8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x8e
 8020668: 68fb         	ldr	r3, [r7, #0xc]
 802066a: f1b3 7fc0    	cmp.w	r3, #0x1800000
 802066e: d016         	beq	0x802069e <stm32_dma_check_fifo_mburst+0x70> @ imm = #0x2c
 8020670: 68fb         	ldr	r3, [r7, #0xc]
 8020672: f1b3 7fc0    	cmp.w	r3, #0x1800000
 8020676: d83e         	bhi	0x80206f6 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x7c
 8020678: 68fb         	ldr	r3, [r7, #0xc]
 802067a: f5b3 0f00    	cmp.w	r3, #0x800000
 802067e: d004         	beq	0x802068a <stm32_dma_check_fifo_mburst+0x5c> @ imm = #0x8
 8020680: 68fb         	ldr	r3, [r7, #0xc]
 8020682: f1b3 7f80    	cmp.w	r3, #0x1000000
 8020686: d002         	beq	0x802068e <stm32_dma_check_fifo_mburst+0x60> @ imm = #0x4
; 		break;
 8020688: e035         	b	0x80206f6 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x6a
; 			return true;
 802068a: 2301         	movs	r3, #0x1
 802068c: e035         	b	0x80206fa <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x6a
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_1_2 ||
 802068e: 693b         	ldr	r3, [r7, #0x10]
 8020690: 2b01         	cmp	r3, #0x1
 8020692: d002         	beq	0x802069a <stm32_dma_check_fifo_mburst+0x6c> @ imm = #0x4
 8020694: 693b         	ldr	r3, [r7, #0x10]
 8020696: 2b03         	cmp	r3, #0x3
 8020698: d106         	bne	0x80206a8 <stm32_dma_check_fifo_mburst+0x7a> @ imm = #0xc
; 				return true;
 802069a: 2301         	movs	r3, #0x1
 802069c: e02d         	b	0x80206fa <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x5a
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_FULL) {
 802069e: 693b         	ldr	r3, [r7, #0x10]
 80206a0: 2b03         	cmp	r3, #0x3
 80206a2: d103         	bne	0x80206ac <stm32_dma_check_fifo_mburst+0x7e> @ imm = #0x6
; 				return true;
 80206a4: 2301         	movs	r3, #0x1
 80206a6: e028         	b	0x80206fa <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x50
; 			break;
 80206a8: bf00         	nop
 80206aa: e024         	b	0x80206f6 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x48
; 			break;
 80206ac: bf00         	nop
; 		break;
 80206ae: e022         	b	0x80206f6 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x44
 80206b0: 68fb         	ldr	r3, [r7, #0xc]
 80206b2: f5b3 0f00    	cmp.w	r3, #0x800000
 80206b6: d004         	beq	0x80206c2 <stm32_dma_check_fifo_mburst+0x94> @ imm = #0x8
 80206b8: 68fb         	ldr	r3, [r7, #0xc]
 80206ba: f1b3 7f80    	cmp.w	r3, #0x1000000
 80206be: d008         	beq	0x80206d2 <stm32_dma_check_fifo_mburst+0xa4> @ imm = #0x10
; 		break;
 80206c0: e01a         	b	0x80206f8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x34
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_1_2 ||
 80206c2: 693b         	ldr	r3, [r7, #0x10]
 80206c4: 2b01         	cmp	r3, #0x1
 80206c6: d002         	beq	0x80206ce <stm32_dma_check_fifo_mburst+0xa0> @ imm = #0x4
 80206c8: 693b         	ldr	r3, [r7, #0x10]
 80206ca: 2b03         	cmp	r3, #0x3
 80206cc: d106         	bne	0x80206dc <stm32_dma_check_fifo_mburst+0xae> @ imm = #0xc
; 				return true;
 80206ce: 2301         	movs	r3, #0x1
 80206d0: e013         	b	0x80206fa <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x26
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_FULL) {
 80206d2: 693b         	ldr	r3, [r7, #0x10]
 80206d4: 2b03         	cmp	r3, #0x3
 80206d6: d103         	bne	0x80206e0 <stm32_dma_check_fifo_mburst+0xb2> @ imm = #0x6
; 				return true;
 80206d8: 2301         	movs	r3, #0x1
 80206da: e00e         	b	0x80206fa <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x1c
; 			break;
 80206dc: bf00         	nop
 80206de: e00b         	b	0x80206f8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x16
; 			break;
 80206e0: bf00         	nop
; 		break;
 80206e2: e009         	b	0x80206f8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x12
; 		if (mburst == LL_DMA_MBURST_INC4 &&
 80206e4: 68fb         	ldr	r3, [r7, #0xc]
 80206e6: f5b3 0f00    	cmp.w	r3, #0x800000
 80206ea: d105         	bne	0x80206f8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0xa
 80206ec: 693b         	ldr	r3, [r7, #0x10]
 80206ee: 2b03         	cmp	r3, #0x3
 80206f0: d102         	bne	0x80206f8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x4
; 			return true;
 80206f2: 2301         	movs	r3, #0x1
 80206f4: e001         	b	0x80206fa <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x2
; 		break;
 80206f6: bf00         	nop
; 	return false;
 80206f8: 2300         	movs	r3, #0x0
; }
 80206fa: 4618         	mov	r0, r3
 80206fc: 371c         	adds	r7, #0x1c
 80206fe: 46bd         	mov	sp, r7
 8020700: f85d 7b04    	ldr	r7, [sp], #4
 8020704: 4770         	bx	lr

08020706 <LL_DMAMUX_SetRequestID>:
; {
 8020706: b480         	push	{r7}
 8020708: b087         	sub	sp, #0x1c
 802070a: af00         	add	r7, sp, #0x0
 802070c: 60f8         	str	r0, [r7, #0xc]
 802070e: 60b9         	str	r1, [r7, #0x8]
 8020710: 607a         	str	r2, [r7, #0x4]
;   uint32_t dmamux_base_addr = (uint32_t)DMAMUXx;
 8020712: 68fb         	ldr	r3, [r7, #0xc]
 8020714: 617b         	str	r3, [r7, #0x14]
;   MODIFY_REG(((DMAMUX_Channel_TypeDef *)(dmamux_base_addr + (DMAMUX_CCR_SIZE * (Channel))))->CCR, DMAMUX_CxCR_DMAREQ_ID, Request);
 8020716: 68bb         	ldr	r3, [r7, #0x8]
 8020718: 009a         	lsls	r2, r3, #0x2
 802071a: 697b         	ldr	r3, [r7, #0x14]
 802071c: 4413         	add	r3, r2
 802071e: 681b         	ldr	r3, [r3]
 8020720: f023 02ff    	bic	r2, r3, #0xff
 8020724: 68bb         	ldr	r3, [r7, #0x8]
 8020726: 0099         	lsls	r1, r3, #0x2
 8020728: 697b         	ldr	r3, [r7, #0x14]
 802072a: 440b         	add	r3, r1
 802072c: 4619         	mov	r1, r3
 802072e: 687b         	ldr	r3, [r7, #0x4]
 8020730: 4313         	orrs	r3, r2
 8020732: 600b         	str	r3, [r1]
; }
 8020734: bf00         	nop
 8020736: 371c         	adds	r7, #0x1c
 8020738: 46bd         	mov	sp, r7
 802073a: f85d 7b04    	ldr	r7, [sp], #4
 802073e: 4770         	bx	lr

08020740 <device_is_ready>:
; {
 8020740: b580         	push	{r7, lr}
 8020742: b082         	sub	sp, #0x8
 8020744: af00         	add	r7, sp, #0x0
 8020746: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8020748: 6878         	ldr	r0, [r7, #0x4]
 802074a: f005 fe28    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x5c50
 802074e: 4603         	mov	r3, r0
; }
 8020750: 4618         	mov	r0, r3
 8020752: 3708         	adds	r7, #0x8
 8020754: 46bd         	mov	sp, r7
 8020756: bd80         	pop	{r7, pc}

08020758 <clock_control_on>:
; {
 8020758: b580         	push	{r7, lr}
 802075a: b084         	sub	sp, #0x10
 802075c: af00         	add	r7, sp, #0x0
 802075e: 6078         	str	r0, [r7, #0x4]
 8020760: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8020762: 687b         	ldr	r3, [r7, #0x4]
 8020764: 689b         	ldr	r3, [r3, #0x8]
 8020766: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8020768: 68fb         	ldr	r3, [r7, #0xc]
 802076a: 681b         	ldr	r3, [r3]
 802076c: 6839         	ldr	r1, [r7]
 802076e: 6878         	ldr	r0, [r7, #0x4]
 8020770: 4798         	blx	r3
 8020772: 4603         	mov	r3, r0
; }
 8020774: 4618         	mov	r0, r3
 8020776: 3710         	adds	r7, #0x10
 8020778: 46bd         	mov	sp, r7
 802077a: bd80         	pop	{r7, pc}

0802077c <z_log_msg_runtime_create>:
; {
 802077c: b580         	push	{r7, lr}
 802077e: b08a         	sub	sp, #0x28
 8020780: af04         	add	r7, sp, #0x10
 8020782: 60b9         	str	r1, [r7, #0x8]
 8020784: 607b         	str	r3, [r7, #0x4]
 8020786: 4603         	mov	r3, r0
 8020788: 73fb         	strb	r3, [r7, #0xf]
 802078a: 4613         	mov	r3, r2
 802078c: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 802078e: f107 032c    	add.w	r3, r7, #0x2c
 8020792: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8020794: 7bba         	ldrb	r2, [r7, #0xe]
 8020796: 7bf8         	ldrb	r0, [r7, #0xf]
 8020798: 697b         	ldr	r3, [r7, #0x14]
 802079a: 9303         	str	r3, [sp, #0xc]
 802079c: 6abb         	ldr	r3, [r7, #0x28]
 802079e: 9302         	str	r3, [sp, #0x8]
 80207a0: 6a7b         	ldr	r3, [r7, #0x24]
 80207a2: 9301         	str	r3, [sp, #0x4]
 80207a4: 6a3b         	ldr	r3, [r7, #0x20]
 80207a6: 9300         	str	r3, [sp]
 80207a8: 687b         	ldr	r3, [r7, #0x4]
 80207aa: 68b9         	ldr	r1, [r7, #0x8]
 80207ac: f7e4 f9e2    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1bc3c
; }
 80207b0: bf00         	nop
 80207b2: 3718         	adds	r7, #0x18
 80207b4: 46bd         	mov	sp, r7
 80207b6: bd80         	pop	{r7, pc}

080207b8 <z_snode_next_peek>:
; {
 80207b8: b480         	push	{r7}
 80207ba: b083         	sub	sp, #0xc
 80207bc: af00         	add	r7, sp, #0x0
 80207be: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 80207c0: 687b         	ldr	r3, [r7, #0x4]
 80207c2: 681b         	ldr	r3, [r3]
; }
 80207c4: 4618         	mov	r0, r3
 80207c6: 370c         	adds	r7, #0xc
 80207c8: 46bd         	mov	sp, r7
 80207ca: f85d 7b04    	ldr	r7, [sp], #4
 80207ce: 4770         	bx	lr

080207d0 <z_snode_next_set>:
; {
 80207d0: b480         	push	{r7}
 80207d2: b083         	sub	sp, #0xc
 80207d4: af00         	add	r7, sp, #0x0
 80207d6: 6078         	str	r0, [r7, #0x4]
 80207d8: 6039         	str	r1, [r7]
; 	parent->next = child;
 80207da: 687b         	ldr	r3, [r7, #0x4]
 80207dc: 683a         	ldr	r2, [r7]
 80207de: 601a         	str	r2, [r3]
; }
 80207e0: bf00         	nop
 80207e2: 370c         	adds	r7, #0xc
 80207e4: 46bd         	mov	sp, r7
 80207e6: f85d 7b04    	ldr	r7, [sp], #4
 80207ea: 4770         	bx	lr

080207ec <z_slist_head_set>:
; {
 80207ec: b480         	push	{r7}
 80207ee: b083         	sub	sp, #0xc
 80207f0: af00         	add	r7, sp, #0x0
 80207f2: 6078         	str	r0, [r7, #0x4]
 80207f4: 6039         	str	r1, [r7]
; 	list->head = node;
 80207f6: 687b         	ldr	r3, [r7, #0x4]
 80207f8: 683a         	ldr	r2, [r7]
 80207fa: 601a         	str	r2, [r3]
; }
 80207fc: bf00         	nop
 80207fe: 370c         	adds	r7, #0xc
 8020800: 46bd         	mov	sp, r7
 8020802: f85d 7b04    	ldr	r7, [sp], #4
 8020806: 4770         	bx	lr

08020808 <z_slist_tail_set>:
; {
 8020808: b480         	push	{r7}
 802080a: b083         	sub	sp, #0xc
 802080c: af00         	add	r7, sp, #0x0
 802080e: 6078         	str	r0, [r7, #0x4]
 8020810: 6039         	str	r1, [r7]
; 	list->tail = node;
 8020812: 687b         	ldr	r3, [r7, #0x4]
 8020814: 683a         	ldr	r2, [r7]
 8020816: 605a         	str	r2, [r3, #0x4]
; }
 8020818: bf00         	nop
 802081a: 370c         	adds	r7, #0xc
 802081c: 46bd         	mov	sp, r7
 802081e: f85d 7b04    	ldr	r7, [sp], #4
 8020822: 4770         	bx	lr

08020824 <sys_slist_peek_head>:
; {
 8020824: b480         	push	{r7}
 8020826: b083         	sub	sp, #0xc
 8020828: af00         	add	r7, sp, #0x0
 802082a: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 802082c: 687b         	ldr	r3, [r7, #0x4]
 802082e: 681b         	ldr	r3, [r3]
; }
 8020830: 4618         	mov	r0, r3
 8020832: 370c         	adds	r7, #0xc
 8020834: 46bd         	mov	sp, r7
 8020836: f85d 7b04    	ldr	r7, [sp], #4
 802083a: 4770         	bx	lr

0802083c <sys_slist_peek_tail>:
; {
 802083c: b480         	push	{r7}
 802083e: b083         	sub	sp, #0xc
 8020840: af00         	add	r7, sp, #0x0
 8020842: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 8020844: 687b         	ldr	r3, [r7, #0x4]
 8020846: 685b         	ldr	r3, [r3, #0x4]
; }
 8020848: 4618         	mov	r0, r3
 802084a: 370c         	adds	r7, #0xc
 802084c: 46bd         	mov	sp, r7
 802084e: f85d 7b04    	ldr	r7, [sp], #4
 8020852: 4770         	bx	lr

08020854 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 8020854: b580         	push	{r7, lr}
 8020856: b082         	sub	sp, #0x8
 8020858: af00         	add	r7, sp, #0x0
 802085a: 6078         	str	r0, [r7, #0x4]
 802085c: 6878         	ldr	r0, [r7, #0x4]
 802085e: f7ff ffe1    	bl	0x8020824 <sys_slist_peek_head> @ imm = #-0x3e
 8020862: 4603         	mov	r3, r0
 8020864: 2b00         	cmp	r3, #0x0
 8020866: bf0c         	ite	eq
 8020868: 2301         	moveq	r3, #0x1
 802086a: 2300         	movne	r3, #0x0
 802086c: b2db         	uxtb	r3, r3
 802086e: 4618         	mov	r0, r3
 8020870: 3708         	adds	r7, #0x8
 8020872: 46bd         	mov	sp, r7
 8020874: bd80         	pop	{r7, pc}

08020876 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8020876: b580         	push	{r7, lr}
 8020878: b082         	sub	sp, #0x8
 802087a: af00         	add	r7, sp, #0x0
 802087c: 6078         	str	r0, [r7, #0x4]
 802087e: 6878         	ldr	r0, [r7, #0x4]
 8020880: f7ff ff9a    	bl	0x80207b8 <z_snode_next_peek> @ imm = #-0xcc
 8020884: 4603         	mov	r3, r0
 8020886: 4618         	mov	r0, r3
 8020888: 3708         	adds	r7, #0x8
 802088a: 46bd         	mov	sp, r7
 802088c: bd80         	pop	{r7, pc}

0802088e <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 802088e: b580         	push	{r7, lr}
 8020890: b082         	sub	sp, #0x8
 8020892: af00         	add	r7, sp, #0x0
 8020894: 6078         	str	r0, [r7, #0x4]
 8020896: 687b         	ldr	r3, [r7, #0x4]
 8020898: 2b00         	cmp	r3, #0x0
 802089a: d004         	beq	0x80208a6 <sys_slist_peek_next+0x18> @ imm = #0x8
 802089c: 6878         	ldr	r0, [r7, #0x4]
 802089e: f7ff ffea    	bl	0x8020876 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 80208a2: 4603         	mov	r3, r0
 80208a4: e000         	b	0x80208a8 <sys_slist_peek_next+0x1a> @ imm = #0x0
 80208a6: 2300         	movs	r3, #0x0
 80208a8: 4618         	mov	r0, r3
 80208aa: 3708         	adds	r7, #0x8
 80208ac: 46bd         	mov	sp, r7
 80208ae: bd80         	pop	{r7, pc}

080208b0 <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 80208b0: b580         	push	{r7, lr}
 80208b2: b082         	sub	sp, #0x8
 80208b4: af00         	add	r7, sp, #0x0
 80208b6: 6078         	str	r0, [r7, #0x4]
 80208b8: 6039         	str	r1, [r7]
 80208ba: 6878         	ldr	r0, [r7, #0x4]
 80208bc: f7ff ffb2    	bl	0x8020824 <sys_slist_peek_head> @ imm = #-0x9c
 80208c0: 4603         	mov	r3, r0
 80208c2: 4619         	mov	r1, r3
 80208c4: 6838         	ldr	r0, [r7]
 80208c6: f7ff ff83    	bl	0x80207d0 <z_snode_next_set> @ imm = #-0xfa
 80208ca: 6839         	ldr	r1, [r7]
 80208cc: 6878         	ldr	r0, [r7, #0x4]
 80208ce: f7ff ff8d    	bl	0x80207ec <z_slist_head_set> @ imm = #-0xe6
 80208d2: 6878         	ldr	r0, [r7, #0x4]
 80208d4: f7ff ffb2    	bl	0x802083c <sys_slist_peek_tail> @ imm = #-0x9c
 80208d8: 4603         	mov	r3, r0
 80208da: 2b00         	cmp	r3, #0x0
 80208dc: d107         	bne	0x80208ee <sys_slist_prepend+0x3e> @ imm = #0xe
 80208de: 6878         	ldr	r0, [r7, #0x4]
 80208e0: f7ff ffa0    	bl	0x8020824 <sys_slist_peek_head> @ imm = #-0xc0
 80208e4: 4603         	mov	r3, r0
 80208e6: 4619         	mov	r1, r3
 80208e8: 6878         	ldr	r0, [r7, #0x4]
 80208ea: f7ff ff8d    	bl	0x8020808 <z_slist_tail_set> @ imm = #-0xe6
 80208ee: 3708         	adds	r7, #0x8
 80208f0: 46bd         	mov	sp, r7
 80208f2: bd80         	pop	{r7, pc}

080208f4 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 80208f4: b580         	push	{r7, lr}
 80208f6: b084         	sub	sp, #0x10
 80208f8: af00         	add	r7, sp, #0x0
 80208fa: 60f8         	str	r0, [r7, #0xc]
 80208fc: 60b9         	str	r1, [r7, #0x8]
 80208fe: 607a         	str	r2, [r7, #0x4]
 8020900: 68bb         	ldr	r3, [r7, #0x8]
 8020902: 2b00         	cmp	r3, #0x0
 8020904: d117         	bne	0x8020936 <sys_slist_remove+0x42> @ imm = #0x2e
 8020906: 6878         	ldr	r0, [r7, #0x4]
 8020908: f7ff ff56    	bl	0x80207b8 <z_snode_next_peek> @ imm = #-0x154
 802090c: 4603         	mov	r3, r0
 802090e: 4619         	mov	r1, r3
 8020910: 68f8         	ldr	r0, [r7, #0xc]
 8020912: f7ff ff6b    	bl	0x80207ec <z_slist_head_set> @ imm = #-0x12a
 8020916: 68f8         	ldr	r0, [r7, #0xc]
 8020918: f7ff ff90    	bl	0x802083c <sys_slist_peek_tail> @ imm = #-0xe0
 802091c: 4602         	mov	r2, r0
 802091e: 687b         	ldr	r3, [r7, #0x4]
 8020920: 4293         	cmp	r3, r2
 8020922: d11b         	bne	0x802095c <sys_slist_remove+0x68> @ imm = #0x36
 8020924: 68f8         	ldr	r0, [r7, #0xc]
 8020926: f7ff ff7d    	bl	0x8020824 <sys_slist_peek_head> @ imm = #-0x106
 802092a: 4603         	mov	r3, r0
 802092c: 4619         	mov	r1, r3
 802092e: 68f8         	ldr	r0, [r7, #0xc]
 8020930: f7ff ff6a    	bl	0x8020808 <z_slist_tail_set> @ imm = #-0x12c
 8020934: e012         	b	0x802095c <sys_slist_remove+0x68> @ imm = #0x24
 8020936: 6878         	ldr	r0, [r7, #0x4]
 8020938: f7ff ff3e    	bl	0x80207b8 <z_snode_next_peek> @ imm = #-0x184
 802093c: 4603         	mov	r3, r0
 802093e: 4619         	mov	r1, r3
 8020940: 68b8         	ldr	r0, [r7, #0x8]
 8020942: f7ff ff45    	bl	0x80207d0 <z_snode_next_set> @ imm = #-0x176
 8020946: 68f8         	ldr	r0, [r7, #0xc]
 8020948: f7ff ff78    	bl	0x802083c <sys_slist_peek_tail> @ imm = #-0x110
 802094c: 4602         	mov	r2, r0
 802094e: 687b         	ldr	r3, [r7, #0x4]
 8020950: 4293         	cmp	r3, r2
 8020952: d103         	bne	0x802095c <sys_slist_remove+0x68> @ imm = #0x6
 8020954: 68b9         	ldr	r1, [r7, #0x8]
 8020956: 68f8         	ldr	r0, [r7, #0xc]
 8020958: f7ff ff56    	bl	0x8020808 <z_slist_tail_set> @ imm = #-0x154
 802095c: 2100         	movs	r1, #0x0
 802095e: 6878         	ldr	r0, [r7, #0x4]
 8020960: f7ff ff36    	bl	0x80207d0 <z_snode_next_set> @ imm = #-0x194
 8020964: 3710         	adds	r7, #0x10
 8020966: 46bd         	mov	sp, r7
 8020968: bd80         	pop	{r7, pc}

0802096a <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 802096a: b580         	push	{r7, lr}
 802096c: b084         	sub	sp, #0x10
 802096e: af00         	add	r7, sp, #0x0
 8020970: 6078         	str	r0, [r7, #0x4]
 8020972: 6039         	str	r1, [r7]
 8020974: 2300         	movs	r3, #0x0
 8020976: 60fb         	str	r3, [r7, #0xc]
 8020978: 6878         	ldr	r0, [r7, #0x4]
 802097a: f7ff ff53    	bl	0x8020824 <sys_slist_peek_head> @ imm = #-0x15a
 802097e: 60b8         	str	r0, [r7, #0x8]
 8020980: e010         	b	0x80209a4 <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 8020982: 68ba         	ldr	r2, [r7, #0x8]
 8020984: 683b         	ldr	r3, [r7]
 8020986: 429a         	cmp	r2, r3
 8020988: d106         	bne	0x8020998 <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 802098a: 683a         	ldr	r2, [r7]
 802098c: 68f9         	ldr	r1, [r7, #0xc]
 802098e: 6878         	ldr	r0, [r7, #0x4]
 8020990: f7ff ffb0    	bl	0x80208f4 <sys_slist_remove> @ imm = #-0xa0
 8020994: 2301         	movs	r3, #0x1
 8020996: e009         	b	0x80209ac <sys_slist_find_and_remove+0x42> @ imm = #0x12
 8020998: 68bb         	ldr	r3, [r7, #0x8]
 802099a: 60fb         	str	r3, [r7, #0xc]
 802099c: 68b8         	ldr	r0, [r7, #0x8]
 802099e: f7ff ff76    	bl	0x802088e <sys_slist_peek_next> @ imm = #-0x114
 80209a2: 60b8         	str	r0, [r7, #0x8]
 80209a4: 68bb         	ldr	r3, [r7, #0x8]
 80209a6: 2b00         	cmp	r3, #0x0
 80209a8: d1eb         	bne	0x8020982 <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 80209aa: 2300         	movs	r3, #0x0
 80209ac: 4618         	mov	r0, r3
 80209ae: 3710         	adds	r7, #0x10
 80209b0: 46bd         	mov	sp, r7
 80209b2: bd80         	pop	{r7, pc}

080209b4 <device_is_ready>:
; {
 80209b4: b580         	push	{r7, lr}
 80209b6: b082         	sub	sp, #0x8
 80209b8: af00         	add	r7, sp, #0x0
 80209ba: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80209bc: 6878         	ldr	r0, [r7, #0x4]
 80209be: f005 fcee    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x59dc
 80209c2: 4603         	mov	r3, r0
; }
 80209c4: 4618         	mov	r0, r3
 80209c6: 3708         	adds	r7, #0x8
 80209c8: 46bd         	mov	sp, r7
 80209ca: bd80         	pop	{r7, pc}

080209cc <LL_GPIO_SetPinMode>:
; {
 80209cc: b480         	push	{r7}
 80209ce: b085         	sub	sp, #0x14
 80209d0: af00         	add	r7, sp, #0x0
 80209d2: 60f8         	str	r0, [r7, #0xc]
 80209d4: 60b9         	str	r1, [r7, #0x8]
 80209d6: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->MODER, ((Pin * Pin) * GPIO_MODER_MODE0), ((Pin * Pin) * Mode));
 80209d8: 68fb         	ldr	r3, [r7, #0xc]
 80209da: 6819         	ldr	r1, [r3]
 80209dc: 68bb         	ldr	r3, [r7, #0x8]
 80209de: fb03 f203    	mul	r2, r3, r3
 80209e2: 4613         	mov	r3, r2
 80209e4: 005b         	lsls	r3, r3, #0x1
 80209e6: 4413         	add	r3, r2
 80209e8: 43db         	mvns	r3, r3
 80209ea: ea01 0203    	and.w	r2, r1, r3
 80209ee: 68bb         	ldr	r3, [r7, #0x8]
 80209f0: fb03 f303    	mul	r3, r3, r3
 80209f4: 6879         	ldr	r1, [r7, #0x4]
 80209f6: fb01 f303    	mul	r3, r1, r3
 80209fa: 431a         	orrs	r2, r3
 80209fc: 68fb         	ldr	r3, [r7, #0xc]
 80209fe: 601a         	str	r2, [r3]
; }
 8020a00: bf00         	nop
 8020a02: 3714         	adds	r7, #0x14
 8020a04: 46bd         	mov	sp, r7
 8020a06: f85d 7b04    	ldr	r7, [sp], #4
 8020a0a: 4770         	bx	lr

08020a0c <LL_GPIO_SetPinOutputType>:
; {
 8020a0c: b480         	push	{r7}
 8020a0e: b085         	sub	sp, #0x14
 8020a10: af00         	add	r7, sp, #0x0
 8020a12: 60f8         	str	r0, [r7, #0xc]
 8020a14: 60b9         	str	r1, [r7, #0x8]
 8020a16: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8020a18: 68fb         	ldr	r3, [r7, #0xc]
 8020a1a: 685a         	ldr	r2, [r3, #0x4]
 8020a1c: 68bb         	ldr	r3, [r7, #0x8]
 8020a1e: 43db         	mvns	r3, r3
 8020a20: 401a         	ands	r2, r3
 8020a22: 68bb         	ldr	r3, [r7, #0x8]
 8020a24: 6879         	ldr	r1, [r7, #0x4]
 8020a26: fb01 f303    	mul	r3, r1, r3
 8020a2a: 431a         	orrs	r2, r3
 8020a2c: 68fb         	ldr	r3, [r7, #0xc]
 8020a2e: 605a         	str	r2, [r3, #0x4]
; }
 8020a30: bf00         	nop
 8020a32: 3714         	adds	r7, #0x14
 8020a34: 46bd         	mov	sp, r7
 8020a36: f85d 7b04    	ldr	r7, [sp], #4
 8020a3a: 4770         	bx	lr

08020a3c <LL_GPIO_SetPinSpeed>:
; {
 8020a3c: b480         	push	{r7}
 8020a3e: b085         	sub	sp, #0x14
 8020a40: af00         	add	r7, sp, #0x0
 8020a42: 60f8         	str	r0, [r7, #0xc]
 8020a44: 60b9         	str	r1, [r7, #0x8]
 8020a46: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OSPEEDR, ((Pin * Pin) * GPIO_OSPEEDR_OSPEED0), ((Pin * Pin) * Speed));
 8020a48: 68fb         	ldr	r3, [r7, #0xc]
 8020a4a: 6899         	ldr	r1, [r3, #0x8]
 8020a4c: 68bb         	ldr	r3, [r7, #0x8]
 8020a4e: fb03 f203    	mul	r2, r3, r3
 8020a52: 4613         	mov	r3, r2
 8020a54: 005b         	lsls	r3, r3, #0x1
 8020a56: 4413         	add	r3, r2
 8020a58: 43db         	mvns	r3, r3
 8020a5a: ea01 0203    	and.w	r2, r1, r3
 8020a5e: 68bb         	ldr	r3, [r7, #0x8]
 8020a60: fb03 f303    	mul	r3, r3, r3
 8020a64: 6879         	ldr	r1, [r7, #0x4]
 8020a66: fb01 f303    	mul	r3, r1, r3
 8020a6a: 431a         	orrs	r2, r3
 8020a6c: 68fb         	ldr	r3, [r7, #0xc]
 8020a6e: 609a         	str	r2, [r3, #0x8]
; }
 8020a70: bf00         	nop
 8020a72: 3714         	adds	r7, #0x14
 8020a74: 46bd         	mov	sp, r7
 8020a76: f85d 7b04    	ldr	r7, [sp], #4
 8020a7a: 4770         	bx	lr

08020a7c <LL_GPIO_SetPinPull>:
; {
 8020a7c: b480         	push	{r7}
 8020a7e: b085         	sub	sp, #0x14
 8020a80: af00         	add	r7, sp, #0x0
 8020a82: 60f8         	str	r0, [r7, #0xc]
 8020a84: 60b9         	str	r1, [r7, #0x8]
 8020a86: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->PUPDR, ((Pin * Pin) * GPIO_PUPDR_PUPD0), ((Pin * Pin) * Pull));
 8020a88: 68fb         	ldr	r3, [r7, #0xc]
 8020a8a: 68d9         	ldr	r1, [r3, #0xc]
 8020a8c: 68bb         	ldr	r3, [r7, #0x8]
 8020a8e: fb03 f203    	mul	r2, r3, r3
 8020a92: 4613         	mov	r3, r2
 8020a94: 005b         	lsls	r3, r3, #0x1
 8020a96: 4413         	add	r3, r2
 8020a98: 43db         	mvns	r3, r3
 8020a9a: ea01 0203    	and.w	r2, r1, r3
 8020a9e: 68bb         	ldr	r3, [r7, #0x8]
 8020aa0: fb03 f303    	mul	r3, r3, r3
 8020aa4: 6879         	ldr	r1, [r7, #0x4]
 8020aa6: fb01 f303    	mul	r3, r1, r3
 8020aaa: 431a         	orrs	r2, r3
 8020aac: 68fb         	ldr	r3, [r7, #0xc]
 8020aae: 60da         	str	r2, [r3, #0xc]
; }
 8020ab0: bf00         	nop
 8020ab2: 3714         	adds	r7, #0x14
 8020ab4: 46bd         	mov	sp, r7
 8020ab6: f85d 7b04    	ldr	r7, [sp], #4
 8020aba: 4770         	bx	lr

08020abc <LL_GPIO_SetAFPin_0_7>:
; {
 8020abc: b480         	push	{r7}
 8020abe: b085         	sub	sp, #0x14
 8020ac0: af00         	add	r7, sp, #0x0
 8020ac2: 60f8         	str	r0, [r7, #0xc]
 8020ac4: 60b9         	str	r1, [r7, #0x8]
 8020ac6: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[0], ((((Pin * Pin) * Pin) * Pin) * GPIO_AFRL_AFSEL0),
 8020ac8: 68fb         	ldr	r3, [r7, #0xc]
 8020aca: 6a19         	ldr	r1, [r3, #0x20]
 8020acc: 68bb         	ldr	r3, [r7, #0x8]
 8020ace: fb03 f303    	mul	r3, r3, r3
 8020ad2: 68ba         	ldr	r2, [r7, #0x8]
 8020ad4: fb02 f303    	mul	r3, r2, r3
 8020ad8: 68ba         	ldr	r2, [r7, #0x8]
 8020ada: fb03 f202    	mul	r2, r3, r2
 8020ade: 4613         	mov	r3, r2
 8020ae0: 011b         	lsls	r3, r3, #0x4
 8020ae2: 1a9b         	subs	r3, r3, r2
 8020ae4: 43db         	mvns	r3, r3
 8020ae6: ea01 0203    	and.w	r2, r1, r3
 8020aea: 68bb         	ldr	r3, [r7, #0x8]
 8020aec: fb03 f303    	mul	r3, r3, r3
 8020af0: 68b9         	ldr	r1, [r7, #0x8]
 8020af2: fb01 f303    	mul	r3, r1, r3
 8020af6: 68b9         	ldr	r1, [r7, #0x8]
 8020af8: fb01 f303    	mul	r3, r1, r3
 8020afc: 6879         	ldr	r1, [r7, #0x4]
 8020afe: fb01 f303    	mul	r3, r1, r3
 8020b02: 431a         	orrs	r2, r3
 8020b04: 68fb         	ldr	r3, [r7, #0xc]
 8020b06: 621a         	str	r2, [r3, #0x20]
; }
 8020b08: bf00         	nop
 8020b0a: 3714         	adds	r7, #0x14
 8020b0c: 46bd         	mov	sp, r7
 8020b0e: f85d 7b04    	ldr	r7, [sp], #4
 8020b12: 4770         	bx	lr

08020b14 <LL_GPIO_SetAFPin_8_15>:
; {
 8020b14: b480         	push	{r7}
 8020b16: b085         	sub	sp, #0x14
 8020b18: af00         	add	r7, sp, #0x0
 8020b1a: 60f8         	str	r0, [r7, #0xc]
 8020b1c: 60b9         	str	r1, [r7, #0x8]
 8020b1e: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[1], (((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * GPIO_AFRH_AFSEL8),
 8020b20: 68fb         	ldr	r3, [r7, #0xc]
 8020b22: 6a59         	ldr	r1, [r3, #0x24]
 8020b24: 68bb         	ldr	r3, [r7, #0x8]
 8020b26: 0a1b         	lsrs	r3, r3, #0x8
 8020b28: 68ba         	ldr	r2, [r7, #0x8]
 8020b2a: 0a12         	lsrs	r2, r2, #0x8
 8020b2c: fb02 f303    	mul	r3, r2, r3
 8020b30: 68ba         	ldr	r2, [r7, #0x8]
 8020b32: 0a12         	lsrs	r2, r2, #0x8
 8020b34: fb02 f303    	mul	r3, r2, r3
 8020b38: 68ba         	ldr	r2, [r7, #0x8]
 8020b3a: 0a12         	lsrs	r2, r2, #0x8
 8020b3c: fb03 f202    	mul	r2, r3, r2
 8020b40: 4613         	mov	r3, r2
 8020b42: 011b         	lsls	r3, r3, #0x4
 8020b44: 1a9b         	subs	r3, r3, r2
 8020b46: 43db         	mvns	r3, r3
 8020b48: ea01 0203    	and.w	r2, r1, r3
 8020b4c: 68bb         	ldr	r3, [r7, #0x8]
 8020b4e: 0a1b         	lsrs	r3, r3, #0x8
 8020b50: 68b9         	ldr	r1, [r7, #0x8]
 8020b52: 0a09         	lsrs	r1, r1, #0x8
 8020b54: fb01 f303    	mul	r3, r1, r3
 8020b58: 68b9         	ldr	r1, [r7, #0x8]
 8020b5a: 0a09         	lsrs	r1, r1, #0x8
 8020b5c: fb01 f303    	mul	r3, r1, r3
 8020b60: 68b9         	ldr	r1, [r7, #0x8]
 8020b62: 0a09         	lsrs	r1, r1, #0x8
 8020b64: fb01 f303    	mul	r3, r1, r3
 8020b68: 6879         	ldr	r1, [r7, #0x4]
 8020b6a: fb01 f303    	mul	r3, r1, r3
 8020b6e: 431a         	orrs	r2, r3
 8020b70: 68fb         	ldr	r3, [r7, #0xc]
 8020b72: 625a         	str	r2, [r3, #0x24]
; }
 8020b74: bf00         	nop
 8020b76: 3714         	adds	r7, #0x14
 8020b78: 46bd         	mov	sp, r7
 8020b7a: f85d 7b04    	ldr	r7, [sp], #4
 8020b7e: 4770         	bx	lr

08020b80 <LL_GPIO_ReadInputPort>:
; {
 8020b80: b480         	push	{r7}
 8020b82: b083         	sub	sp, #0xc
 8020b84: af00         	add	r7, sp, #0x0
 8020b86: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->IDR));
 8020b88: 687b         	ldr	r3, [r7, #0x4]
 8020b8a: 691b         	ldr	r3, [r3, #0x10]
; }
 8020b8c: 4618         	mov	r0, r3
 8020b8e: 370c         	adds	r7, #0xc
 8020b90: 46bd         	mov	sp, r7
 8020b92: f85d 7b04    	ldr	r7, [sp], #4
 8020b96: 4770         	bx	lr

08020b98 <LL_GPIO_WriteOutputPort>:
; {
 8020b98: b480         	push	{r7}
 8020b9a: b083         	sub	sp, #0xc
 8020b9c: af00         	add	r7, sp, #0x0
 8020b9e: 6078         	str	r0, [r7, #0x4]
 8020ba0: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->ODR, PortValue);
 8020ba2: 687b         	ldr	r3, [r7, #0x4]
 8020ba4: 683a         	ldr	r2, [r7]
 8020ba6: 615a         	str	r2, [r3, #0x14]
; }
 8020ba8: bf00         	nop
 8020baa: 370c         	adds	r7, #0xc
 8020bac: 46bd         	mov	sp, r7
 8020bae: f85d 7b04    	ldr	r7, [sp], #4
 8020bb2: 4770         	bx	lr

08020bb4 <LL_GPIO_ReadOutputPort>:
; {
 8020bb4: b480         	push	{r7}
 8020bb6: b083         	sub	sp, #0xc
 8020bb8: af00         	add	r7, sp, #0x0
 8020bba: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->ODR));
 8020bbc: 687b         	ldr	r3, [r7, #0x4]
 8020bbe: 695b         	ldr	r3, [r3, #0x14]
; }
 8020bc0: 4618         	mov	r0, r3
 8020bc2: 370c         	adds	r7, #0xc
 8020bc4: 46bd         	mov	sp, r7
 8020bc6: f85d 7b04    	ldr	r7, [sp], #4
 8020bca: 4770         	bx	lr

08020bcc <LL_GPIO_ResetOutputPin>:
; {
 8020bcc: b480         	push	{r7}
 8020bce: b083         	sub	sp, #0xc
 8020bd0: af00         	add	r7, sp, #0x0
 8020bd2: 6078         	str	r0, [r7, #0x4]
 8020bd4: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->BSRR, PinMask << 16U);
 8020bd6: 683b         	ldr	r3, [r7]
 8020bd8: 041a         	lsls	r2, r3, #0x10
 8020bda: 687b         	ldr	r3, [r7, #0x4]
 8020bdc: 619a         	str	r2, [r3, #0x18]
; }
 8020bde: bf00         	nop
 8020be0: 370c         	adds	r7, #0xc
 8020be2: 46bd         	mov	sp, r7
 8020be4: f85d 7b04    	ldr	r7, [sp], #4
 8020be8: 4770         	bx	lr

08020bea <clock_control_on>:
; {
 8020bea: b580         	push	{r7, lr}
 8020bec: b084         	sub	sp, #0x10
 8020bee: af00         	add	r7, sp, #0x0
 8020bf0: 6078         	str	r0, [r7, #0x4]
 8020bf2: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8020bf4: 687b         	ldr	r3, [r7, #0x4]
 8020bf6: 689b         	ldr	r3, [r3, #0x8]
 8020bf8: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8020bfa: 68fb         	ldr	r3, [r7, #0xc]
 8020bfc: 681b         	ldr	r3, [r3]
 8020bfe: 6839         	ldr	r1, [r7]
 8020c00: 6878         	ldr	r0, [r7, #0x4]
 8020c02: 4798         	blx	r3
 8020c04: 4603         	mov	r3, r0
; }
 8020c06: 4618         	mov	r0, r3
 8020c08: 3710         	adds	r7, #0x10
 8020c0a: 46bd         	mov	sp, r7
 8020c0c: bd80         	pop	{r7, pc}

08020c0e <clock_control_off>:
; {
 8020c0e: b580         	push	{r7, lr}
 8020c10: b084         	sub	sp, #0x10
 8020c12: af00         	add	r7, sp, #0x0
 8020c14: 6078         	str	r0, [r7, #0x4]
 8020c16: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8020c18: 687b         	ldr	r3, [r7, #0x4]
 8020c1a: 689b         	ldr	r3, [r3, #0x8]
 8020c1c: 60fb         	str	r3, [r7, #0xc]
; 	return api->off(dev, sys);
 8020c1e: 68fb         	ldr	r3, [r7, #0xc]
 8020c20: 685b         	ldr	r3, [r3, #0x4]
 8020c22: 6839         	ldr	r1, [r7]
 8020c24: 6878         	ldr	r0, [r7, #0x4]
 8020c26: 4798         	blx	r3
 8020c28: 4603         	mov	r3, r0
; }
 8020c2a: 4618         	mov	r0, r3
 8020c2c: 3710         	adds	r7, #0x10
 8020c2e: 46bd         	mov	sp, r7
 8020c30: bd80         	pop	{r7, pc}

08020c32 <pm_device_runtime_enable>:
; {
 8020c32: b480         	push	{r7}
 8020c34: b083         	sub	sp, #0xc
 8020c36: af00         	add	r7, sp, #0x0
 8020c38: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8020c3a: 2300         	movs	r3, #0x0
; }
 8020c3c: 4618         	mov	r0, r3
 8020c3e: 370c         	adds	r7, #0xc
 8020c40: 46bd         	mov	sp, r7
 8020c42: f85d 7b04    	ldr	r7, [sp], #4
 8020c46: 4770         	bx	lr

08020c48 <pm_device_runtime_get>:
; {
 8020c48: b480         	push	{r7}
 8020c4a: b083         	sub	sp, #0xc
 8020c4c: af00         	add	r7, sp, #0x0
 8020c4e: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8020c50: 2300         	movs	r3, #0x0
; }
 8020c52: 4618         	mov	r0, r3
 8020c54: 370c         	adds	r7, #0xc
 8020c56: 46bd         	mov	sp, r7
 8020c58: f85d 7b04    	ldr	r7, [sp], #4
 8020c5c: 4770         	bx	lr

08020c5e <pm_device_runtime_put>:
; {
 8020c5e: b480         	push	{r7}
 8020c60: b083         	sub	sp, #0xc
 8020c62: af00         	add	r7, sp, #0x0
 8020c64: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8020c66: 2300         	movs	r3, #0x0
; }
 8020c68: 4618         	mov	r0, r3
 8020c6a: 370c         	adds	r7, #0xc
 8020c6c: 46bd         	mov	sp, r7
 8020c6e: f85d 7b04    	ldr	r7, [sp], #4
 8020c72: 4770         	bx	lr

08020c74 <z_stm32_hsem_lock>:
; {
 8020c74: b480         	push	{r7}
 8020c76: b083         	sub	sp, #0xc
 8020c78: af00         	add	r7, sp, #0x0
 8020c7a: 6078         	str	r0, [r7, #0x4]
 8020c7c: 6039         	str	r1, [r7]
; }
 8020c7e: bf00         	nop
 8020c80: 370c         	adds	r7, #0xc
 8020c82: 46bd         	mov	sp, r7
 8020c84: f85d 7b04    	ldr	r7, [sp], #4
 8020c88: 4770         	bx	lr

08020c8a <z_stm32_hsem_unlock>:
; {
 8020c8a: b480         	push	{r7}
 8020c8c: b083         	sub	sp, #0xc
 8020c8e: af00         	add	r7, sp, #0x0
 8020c90: 6078         	str	r0, [r7, #0x4]
; }
 8020c92: bf00         	nop
 8020c94: 370c         	adds	r7, #0xc
 8020c96: 46bd         	mov	sp, r7
 8020c98: f85d 7b04    	ldr	r7, [sp], #4
 8020c9c: 4770         	bx	lr

08020c9e <gpio_manage_callback>:
; {
 8020c9e: b580         	push	{r7, lr}
 8020ca0: b084         	sub	sp, #0x10
 8020ca2: af00         	add	r7, sp, #0x0
 8020ca4: 60f8         	str	r0, [r7, #0xc]
 8020ca6: 60b9         	str	r1, [r7, #0x8]
 8020ca8: 4613         	mov	r3, r2
 8020caa: 71fb         	strb	r3, [r7, #0x7]
; 	if (!sys_slist_is_empty(callbacks)) {
 8020cac: 68f8         	ldr	r0, [r7, #0xc]
 8020cae: f7ff fdd1    	bl	0x8020854 <sys_slist_is_empty> @ imm = #-0x45e
 8020cb2: 4603         	mov	r3, r0
 8020cb4: f083 0301    	eor	r3, r3, #0x1
 8020cb8: b2db         	uxtb	r3, r3
 8020cba: 2b00         	cmp	r3, #0x0
 8020cbc: d013         	beq	0x8020ce6 <gpio_manage_callback+0x48> @ imm = #0x26
; 		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
 8020cbe: 68bb         	ldr	r3, [r7, #0x8]
 8020cc0: 4619         	mov	r1, r3
 8020cc2: 68f8         	ldr	r0, [r7, #0xc]
 8020cc4: f7ff fe51    	bl	0x802096a <sys_slist_find_and_remove> @ imm = #-0x35e
 8020cc8: 4603         	mov	r3, r0
 8020cca: f083 0301    	eor	r3, r3, #0x1
 8020cce: b2db         	uxtb	r3, r3
 8020cd0: 2b00         	cmp	r3, #0x0
 8020cd2: d011         	beq	0x8020cf8 <gpio_manage_callback+0x5a> @ imm = #0x22
; 			if (!set) {
 8020cd4: 79fb         	ldrb	r3, [r7, #0x7]
 8020cd6: f083 0301    	eor	r3, r3, #0x1
 8020cda: b2db         	uxtb	r3, r3
 8020cdc: 2b00         	cmp	r3, #0x0
 8020cde: d00b         	beq	0x8020cf8 <gpio_manage_callback+0x5a> @ imm = #0x16
; 				return -EINVAL;
 8020ce0: f06f 0315    	mvn	r3, #0x15
 8020ce4: e011         	b	0x8020d0a <gpio_manage_callback+0x6c> @ imm = #0x22
; 	} else if (!set) {
 8020ce6: 79fb         	ldrb	r3, [r7, #0x7]
 8020ce8: f083 0301    	eor	r3, r3, #0x1
 8020cec: b2db         	uxtb	r3, r3
 8020cee: 2b00         	cmp	r3, #0x0
 8020cf0: d002         	beq	0x8020cf8 <gpio_manage_callback+0x5a> @ imm = #0x4
; 		return -EINVAL;
 8020cf2: f06f 0315    	mvn	r3, #0x15
 8020cf6: e008         	b	0x8020d0a <gpio_manage_callback+0x6c> @ imm = #0x10
; 	if (set) {
 8020cf8: 79fb         	ldrb	r3, [r7, #0x7]
 8020cfa: 2b00         	cmp	r3, #0x0
 8020cfc: d004         	beq	0x8020d08 <gpio_manage_callback+0x6a> @ imm = #0x8
; 		sys_slist_prepend(callbacks, &callback->node);
 8020cfe: 68bb         	ldr	r3, [r7, #0x8]
 8020d00: 4619         	mov	r1, r3
 8020d02: 68f8         	ldr	r0, [r7, #0xc]
 8020d04: f7ff fdd4    	bl	0x80208b0 <sys_slist_prepend> @ imm = #-0x458
; 	return 0;
 8020d08: 2300         	movs	r3, #0x0
; }
 8020d0a: 4618         	mov	r0, r3
 8020d0c: 3710         	adds	r7, #0x10
 8020d0e: 46bd         	mov	sp, r7
 8020d10: bd80         	pop	{r7, pc}

08020d12 <gpio_fire_callbacks>:
; {
 8020d12: b580         	push	{r7, lr}
 8020d14: b086         	sub	sp, #0x18
 8020d16: af00         	add	r7, sp, #0x0
 8020d18: 60f8         	str	r0, [r7, #0xc]
 8020d1a: 60b9         	str	r1, [r7, #0x8]
 8020d1c: 607a         	str	r2, [r7, #0x4]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 8020d1e: 68f8         	ldr	r0, [r7, #0xc]
 8020d20: f7ff fd80    	bl	0x8020824 <sys_slist_peek_head> @ imm = #-0x500
 8020d24: 4603         	mov	r3, r0
 8020d26: 2b00         	cmp	r3, #0x0
 8020d28: d004         	beq	0x8020d34 <gpio_fire_callbacks+0x22> @ imm = #0x8
 8020d2a: 68f8         	ldr	r0, [r7, #0xc]
 8020d2c: f7ff fd7a    	bl	0x8020824 <sys_slist_peek_head> @ imm = #-0x50c
 8020d30: 4603         	mov	r3, r0
 8020d32: e000         	b	0x8020d36 <gpio_fire_callbacks+0x24> @ imm = #0x0
 8020d34: 2300         	movs	r3, #0x0
 8020d36: 617b         	str	r3, [r7, #0x14]
 8020d38: 697b         	ldr	r3, [r7, #0x14]
 8020d3a: 2b00         	cmp	r3, #0x0
 8020d3c: d00e         	beq	0x8020d5c <gpio_fire_callbacks+0x4a> @ imm = #0x1c
 8020d3e: 697b         	ldr	r3, [r7, #0x14]
 8020d40: 4618         	mov	r0, r3
 8020d42: f7ff fda4    	bl	0x802088e <sys_slist_peek_next> @ imm = #-0x4b8
 8020d46: 4603         	mov	r3, r0
 8020d48: 2b00         	cmp	r3, #0x0
 8020d4a: d005         	beq	0x8020d58 <gpio_fire_callbacks+0x46> @ imm = #0xa
 8020d4c: 697b         	ldr	r3, [r7, #0x14]
 8020d4e: 4618         	mov	r0, r3
 8020d50: f7ff fd9d    	bl	0x802088e <sys_slist_peek_next> @ imm = #-0x4c6
 8020d54: 4603         	mov	r3, r0
 8020d56: e002         	b	0x8020d5e <gpio_fire_callbacks+0x4c> @ imm = #0x4
 8020d58: 2300         	movs	r3, #0x0
 8020d5a: e000         	b	0x8020d5e <gpio_fire_callbacks+0x4c> @ imm = #0x0
 8020d5c: 2300         	movs	r3, #0x0
 8020d5e: 613b         	str	r3, [r7, #0x10]
 8020d60: e024         	b	0x8020dac <gpio_fire_callbacks+0x9a> @ imm = #0x48
; 		if (cb->pin_mask & pins) {
 8020d62: 697b         	ldr	r3, [r7, #0x14]
 8020d64: 689a         	ldr	r2, [r3, #0x8]
 8020d66: 687b         	ldr	r3, [r7, #0x4]
 8020d68: 4013         	ands	r3, r2
 8020d6a: 2b00         	cmp	r3, #0x0
 8020d6c: d008         	beq	0x8020d80 <gpio_fire_callbacks+0x6e> @ imm = #0x10
; 			cb->handler(port, cb, cb->pin_mask & pins);
 8020d6e: 697b         	ldr	r3, [r7, #0x14]
 8020d70: 685b         	ldr	r3, [r3, #0x4]
 8020d72: 697a         	ldr	r2, [r7, #0x14]
 8020d74: 6891         	ldr	r1, [r2, #0x8]
 8020d76: 687a         	ldr	r2, [r7, #0x4]
 8020d78: 400a         	ands	r2, r1
 8020d7a: 6979         	ldr	r1, [r7, #0x14]
 8020d7c: 68b8         	ldr	r0, [r7, #0x8]
 8020d7e: 4798         	blx	r3
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 8020d80: 693b         	ldr	r3, [r7, #0x10]
 8020d82: 617b         	str	r3, [r7, #0x14]
 8020d84: 697b         	ldr	r3, [r7, #0x14]
 8020d86: 2b00         	cmp	r3, #0x0
 8020d88: d00e         	beq	0x8020da8 <gpio_fire_callbacks+0x96> @ imm = #0x1c
 8020d8a: 697b         	ldr	r3, [r7, #0x14]
 8020d8c: 4618         	mov	r0, r3
 8020d8e: f7ff fd7e    	bl	0x802088e <sys_slist_peek_next> @ imm = #-0x504
 8020d92: 4603         	mov	r3, r0
 8020d94: 2b00         	cmp	r3, #0x0
 8020d96: d005         	beq	0x8020da4 <gpio_fire_callbacks+0x92> @ imm = #0xa
 8020d98: 697b         	ldr	r3, [r7, #0x14]
 8020d9a: 4618         	mov	r0, r3
 8020d9c: f7ff fd77    	bl	0x802088e <sys_slist_peek_next> @ imm = #-0x512
 8020da0: 4603         	mov	r3, r0
 8020da2: e002         	b	0x8020daa <gpio_fire_callbacks+0x98> @ imm = #0x4
 8020da4: 2300         	movs	r3, #0x0
 8020da6: e000         	b	0x8020daa <gpio_fire_callbacks+0x98> @ imm = #0x0
 8020da8: 2300         	movs	r3, #0x0
 8020daa: 613b         	str	r3, [r7, #0x10]
 8020dac: 697b         	ldr	r3, [r7, #0x14]
 8020dae: 2b00         	cmp	r3, #0x0
 8020db0: d1d7         	bne	0x8020d62 <gpio_fire_callbacks+0x50> @ imm = #-0x52
; }
 8020db2: bf00         	nop
 8020db4: bf00         	nop
 8020db6: 3718         	adds	r7, #0x18
 8020db8: 46bd         	mov	sp, r7
 8020dba: bd80         	pop	{r7, pc}

08020dbc <gpio_stm32_isr>:
; {
 8020dbc: b580         	push	{r7, lr}
 8020dbe: b084         	sub	sp, #0x10
 8020dc0: af00         	add	r7, sp, #0x0
 8020dc2: 6078         	str	r0, [r7, #0x4]
 8020dc4: 6039         	str	r1, [r7]
; 	struct gpio_stm32_data *data = arg;
 8020dc6: 683b         	ldr	r3, [r7]
 8020dc8: 60fb         	str	r3, [r7, #0xc]
; 	gpio_fire_callbacks(&data->cb, data->dev, pin);
 8020dca: 68fb         	ldr	r3, [r7, #0xc]
 8020dcc: f103 0008    	add.w	r0, r3, #0x8
 8020dd0: 68fb         	ldr	r3, [r7, #0xc]
 8020dd2: 685b         	ldr	r3, [r3, #0x4]
 8020dd4: 687a         	ldr	r2, [r7, #0x4]
 8020dd6: 4619         	mov	r1, r3
 8020dd8: f7ff ff9b    	bl	0x8020d12 <gpio_fire_callbacks> @ imm = #-0xca
; }
 8020ddc: bf00         	nop
 8020dde: 3710         	adds	r7, #0x10
 8020de0: 46bd         	mov	sp, r7
 8020de2: bd80         	pop	{r7, pc}

08020de4 <gpio_stm32_flags_to_conf>:
; {
 8020de4: b480         	push	{r7}
 8020de6: b083         	sub	sp, #0xc
 8020de8: af00         	add	r7, sp, #0x0
 8020dea: 6078         	str	r0, [r7, #0x4]
 8020dec: 6039         	str	r1, [r7]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 8020dee: 687b         	ldr	r3, [r7, #0x4]
 8020df0: f403 3300    	and	r3, r3, #0x20000
 8020df4: 2b00         	cmp	r3, #0x0
 8020df6: d032         	beq	0x8020e5e <gpio_stm32_flags_to_conf+0x7a> @ imm = #0x64
; 		*pincfg = STM32_PINCFG_MODE_OUTPUT;
 8020df8: 683b         	ldr	r3, [r7]
 8020dfa: 2210         	movs	r2, #0x10
 8020dfc: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_SINGLE_ENDED) != 0) {
 8020dfe: 687b         	ldr	r3, [r7, #0x4]
 8020e00: f003 0302    	and	r3, r3, #0x2
 8020e04: 2b00         	cmp	r3, #0x0
 8020e06: d00e         	beq	0x8020e26 <gpio_stm32_flags_to_conf+0x42> @ imm = #0x1c
; 			if (flags & GPIO_LINE_OPEN_DRAIN) {
 8020e08: 687b         	ldr	r3, [r7, #0x4]
 8020e0a: f003 0304    	and	r3, r3, #0x4
 8020e0e: 2b00         	cmp	r3, #0x0
 8020e10: d006         	beq	0x8020e20 <gpio_stm32_flags_to_conf+0x3c> @ imm = #0xc
; 				*pincfg |= STM32_PINCFG_OPEN_DRAIN;
 8020e12: 683b         	ldr	r3, [r7]
 8020e14: 681b         	ldr	r3, [r3]
 8020e16: f043 0240    	orr	r2, r3, #0x40
 8020e1a: 683b         	ldr	r3, [r7]
 8020e1c: 601a         	str	r2, [r3]
 8020e1e: e006         	b	0x8020e2e <gpio_stm32_flags_to_conf+0x4a> @ imm = #0xc
; 				return -ENOTSUP;
 8020e20: f06f 0385    	mvn	r3, #0x85
 8020e24: e044         	b	0x8020eb0 <gpio_stm32_flags_to_conf+0xcc> @ imm = #0x88
; 			*pincfg |= STM32_PINCFG_PUSH_PULL;
 8020e26: 683b         	ldr	r3, [r7]
 8020e28: 681a         	ldr	r2, [r3]
 8020e2a: 683b         	ldr	r3, [r7]
 8020e2c: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 8020e2e: 687b         	ldr	r3, [r7, #0x4]
 8020e30: f003 0310    	and	r3, r3, #0x10
 8020e34: 2b00         	cmp	r3, #0x0
 8020e36: d006         	beq	0x8020e46 <gpio_stm32_flags_to_conf+0x62> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 8020e38: 683b         	ldr	r3, [r7]
 8020e3a: 681b         	ldr	r3, [r3]
 8020e3c: f443 7200    	orr	r2, r3, #0x200
 8020e40: 683b         	ldr	r3, [r7]
 8020e42: 601a         	str	r2, [r3]
 8020e44: e033         	b	0x8020eae <gpio_stm32_flags_to_conf+0xca> @ imm = #0x66
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 8020e46: 687b         	ldr	r3, [r7, #0x4]
 8020e48: f003 0320    	and	r3, r3, #0x20
 8020e4c: 2b00         	cmp	r3, #0x0
 8020e4e: d02e         	beq	0x8020eae <gpio_stm32_flags_to_conf+0xca> @ imm = #0x5c
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 8020e50: 683b         	ldr	r3, [r7]
 8020e52: 681b         	ldr	r3, [r3]
 8020e54: f443 6280    	orr	r2, r3, #0x400
 8020e58: 683b         	ldr	r3, [r7]
 8020e5a: 601a         	str	r2, [r3]
 8020e5c: e027         	b	0x8020eae <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4e
; 	} else if  ((flags & GPIO_INPUT) != 0) {
 8020e5e: 687b         	ldr	r3, [r7, #0x4]
 8020e60: f403 3380    	and	r3, r3, #0x10000
 8020e64: 2b00         	cmp	r3, #0x0
 8020e66: d01f         	beq	0x8020ea8 <gpio_stm32_flags_to_conf+0xc4> @ imm = #0x3e
; 		*pincfg = STM32_PINCFG_MODE_INPUT;
 8020e68: 683b         	ldr	r3, [r7]
 8020e6a: 2200         	movs	r2, #0x0
 8020e6c: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 8020e6e: 687b         	ldr	r3, [r7, #0x4]
 8020e70: f003 0310    	and	r3, r3, #0x10
 8020e74: 2b00         	cmp	r3, #0x0
 8020e76: d006         	beq	0x8020e86 <gpio_stm32_flags_to_conf+0xa2> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 8020e78: 683b         	ldr	r3, [r7]
 8020e7a: 681b         	ldr	r3, [r3]
 8020e7c: f443 7200    	orr	r2, r3, #0x200
 8020e80: 683b         	ldr	r3, [r7]
 8020e82: 601a         	str	r2, [r3]
 8020e84: e013         	b	0x8020eae <gpio_stm32_flags_to_conf+0xca> @ imm = #0x26
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 8020e86: 687b         	ldr	r3, [r7, #0x4]
 8020e88: f003 0320    	and	r3, r3, #0x20
 8020e8c: 2b00         	cmp	r3, #0x0
 8020e8e: d006         	beq	0x8020e9e <gpio_stm32_flags_to_conf+0xba> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 8020e90: 683b         	ldr	r3, [r7]
 8020e92: 681b         	ldr	r3, [r3]
 8020e94: f443 6280    	orr	r2, r3, #0x400
 8020e98: 683b         	ldr	r3, [r7]
 8020e9a: 601a         	str	r2, [r3]
 8020e9c: e007         	b	0x8020eae <gpio_stm32_flags_to_conf+0xca> @ imm = #0xe
; 			*pincfg |= STM32_PINCFG_FLOATING;
 8020e9e: 683b         	ldr	r3, [r7]
 8020ea0: 681a         	ldr	r2, [r3]
 8020ea2: 683b         	ldr	r3, [r7]
 8020ea4: 601a         	str	r2, [r3]
 8020ea6: e002         	b	0x8020eae <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4
; 		*pincfg = STM32_PINCFG_MODE_ANALOG;
 8020ea8: 683b         	ldr	r3, [r7]
 8020eaa: 2230         	movs	r2, #0x30
 8020eac: 601a         	str	r2, [r3]
; 	return 0;
 8020eae: 2300         	movs	r3, #0x0
; }
 8020eb0: 4618         	mov	r0, r3
 8020eb2: 370c         	adds	r7, #0xc
 8020eb4: 46bd         	mov	sp, r7
 8020eb6: f85d 7b04    	ldr	r7, [sp], #4
 8020eba: 4770         	bx	lr

08020ebc <stm32_pinval_get>:
; {
 8020ebc: b480         	push	{r7}
 8020ebe: b085         	sub	sp, #0x14
 8020ec0: af00         	add	r7, sp, #0x0
 8020ec2: 4603         	mov	r3, r0
 8020ec4: 71fb         	strb	r3, [r7, #0x7]
; 	pinval = 1 << pin;
 8020ec6: 79fb         	ldrb	r3, [r7, #0x7]
 8020ec8: 2201         	movs	r2, #0x1
 8020eca: fa02 f303    	lsl.w	r3, r2, r3
 8020ece: 60fb         	str	r3, [r7, #0xc]
; 	return pinval;
 8020ed0: 68fb         	ldr	r3, [r7, #0xc]
; }
 8020ed2: 4618         	mov	r0, r3
 8020ed4: 3714         	adds	r7, #0x14
 8020ed6: 46bd         	mov	sp, r7
 8020ed8: f85d 7b04    	ldr	r7, [sp], #4
 8020edc: 4770         	bx	lr

08020ede <ll_gpio_set_pin_pull>:
; {
 8020ede: b580         	push	{r7, lr}
 8020ee0: b084         	sub	sp, #0x10
 8020ee2: af00         	add	r7, sp, #0x0
 8020ee4: 60f8         	str	r0, [r7, #0xc]
 8020ee6: 60b9         	str	r1, [r7, #0x8]
 8020ee8: 607a         	str	r2, [r7, #0x4]
; 	LL_GPIO_SetPinPull(GPIOx, Pin, Pull);
 8020eea: 687a         	ldr	r2, [r7, #0x4]
 8020eec: 68b9         	ldr	r1, [r7, #0x8]
 8020eee: 68f8         	ldr	r0, [r7, #0xc]
 8020ef0: f7ff fdc4    	bl	0x8020a7c <LL_GPIO_SetPinPull> @ imm = #-0x478
; }
 8020ef4: bf00         	nop
 8020ef6: 3710         	adds	r7, #0x10
 8020ef8: 46bd         	mov	sp, r7
 8020efa: bd80         	pop	{r7, pc}

08020efc <gpio_stm32_disable_pin_irqs>:
; {
 8020efc: b580         	push	{r7, lr}
 8020efe: b084         	sub	sp, #0x10
 8020f00: af00         	add	r7, sp, #0x0
 8020f02: 6078         	str	r0, [r7, #0x4]
 8020f04: 460b         	mov	r3, r1
 8020f06: 70fb         	strb	r3, [r7, #0x3]
; 	if (port != stm32_exti_get_line_src_port(pin)) {
 8020f08: 78fb         	ldrb	r3, [r7, #0x3]
 8020f0a: 4618         	mov	r0, r3
 8020f0c: f7fd fa12    	bl	0x801e334 <stm32_exti_get_line_src_port> @ imm = #-0x2bdc
 8020f10: 4602         	mov	r2, r0
 8020f12: 687b         	ldr	r3, [r7, #0x4]
 8020f14: 4293         	cmp	r3, r2
 8020f16: d110         	bne	0x8020f3a <gpio_stm32_disable_pin_irqs+0x3e> @ imm = #0x20
; 	stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(port, pin);
 8020f18: 78fb         	ldrb	r3, [r7, #0x3]
 8020f1a: 4619         	mov	r1, r3
 8020f1c: 6878         	ldr	r0, [r7, #0x4]
 8020f1e: f7fd f9d4    	bl	0x801e2ca <stm32_gpio_intc_get_pin_irq_line> @ imm = #-0x2c58
 8020f22: 60f8         	str	r0, [r7, #0xc]
; 	stm32_gpio_intc_disable_line(irq_line);
 8020f24: 68f8         	ldr	r0, [r7, #0xc]
 8020f26: f7fd f9df    	bl	0x801e2e8 <stm32_gpio_intc_disable_line> @ imm = #-0x2c42
; 	stm32_gpio_intc_remove_irq_callback(irq_line);
 8020f2a: 68f8         	ldr	r0, [r7, #0xc]
 8020f2c: f7e6 fb08    	bl	0x8007540 <stm32_gpio_intc_remove_irq_callback> @ imm = #-0x199f0
; 	stm32_gpio_intc_select_line_trigger(irq_line, STM32_GPIO_IRQ_TRIG_NONE);
 8020f30: 2100         	movs	r1, #0x0
 8020f32: 68f8         	ldr	r0, [r7, #0xc]
 8020f34: f7e6 fa8c    	bl	0x8007450 <stm32_gpio_intc_select_line_trigger> @ imm = #-0x19ae8
 8020f38: e000         	b	0x8020f3c <gpio_stm32_disable_pin_irqs+0x40> @ imm = #0x0
; 		return;
 8020f3a: bf00         	nop
; }
 8020f3c: 3710         	adds	r7, #0x10
 8020f3e: 46bd         	mov	sp, r7
 8020f40: bd80         	pop	{r7, pc}

08020f42 <gpio_stm32_configure_raw>:
; {
 8020f42: b580         	push	{r7, lr}
 8020f44: b08c         	sub	sp, #0x30
 8020f46: af00         	add	r7, sp, #0x0
 8020f48: 60f8         	str	r0, [r7, #0xc]
 8020f4a: 607a         	str	r2, [r7, #0x4]
 8020f4c: 603b         	str	r3, [r7]
 8020f4e: 460b         	mov	r3, r1
 8020f50: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8020f52: 68fb         	ldr	r3, [r7, #0xc]
 8020f54: 685b         	ldr	r3, [r3, #0x4]
 8020f56: 62fb         	str	r3, [r7, #0x2c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8020f58: 6afb         	ldr	r3, [r7, #0x2c]
 8020f5a: 685b         	ldr	r3, [r3, #0x4]
 8020f5c: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pin_ll = stm32_pinval_get(pin);
 8020f5e: 7afb         	ldrb	r3, [r7, #0xb]
 8020f60: 4618         	mov	r0, r3
 8020f62: f7ff ffab    	bl	0x8020ebc <stm32_pinval_get> @ imm = #-0xaa
 8020f66: 6278         	str	r0, [r7, #0x24]
; 	mode = conf & (STM32_MODER_MASK << STM32_MODER_SHIFT);
 8020f68: 687b         	ldr	r3, [r7, #0x4]
 8020f6a: f003 0330    	and	r3, r3, #0x30
 8020f6e: 623b         	str	r3, [r7, #0x20]
; 	otype = conf & (STM32_OTYPER_MASK << STM32_OTYPER_SHIFT);
 8020f70: 687b         	ldr	r3, [r7, #0x4]
 8020f72: f003 0340    	and	r3, r3, #0x40
 8020f76: 61fb         	str	r3, [r7, #0x1c]
; 	ospeed = conf & (STM32_OSPEEDR_MASK << STM32_OSPEEDR_SHIFT);
 8020f78: 687b         	ldr	r3, [r7, #0x4]
 8020f7a: f403 73c0    	and	r3, r3, #0x180
 8020f7e: 61bb         	str	r3, [r7, #0x18]
; 	pupd = conf & (STM32_PUPDR_MASK << STM32_PUPDR_SHIFT);
 8020f80: 687b         	ldr	r3, [r7, #0x4]
 8020f82: f403 63c0    	and	r3, r3, #0x600
 8020f86: 617b         	str	r3, [r7, #0x14]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8020f88: f44f 1180    	mov.w	r1, #0x100000
 8020f8c: 2000         	movs	r0, #0x0
 8020f8e: f7ff fe71    	bl	0x8020c74 <z_stm32_hsem_lock> @ imm = #-0x31e
; 	LL_GPIO_SetPinOutputType(gpio, pin_ll, otype >> STM32_OTYPER_SHIFT);
 8020f92: 69fb         	ldr	r3, [r7, #0x1c]
 8020f94: 099b         	lsrs	r3, r3, #0x6
 8020f96: 461a         	mov	r2, r3
 8020f98: 6a79         	ldr	r1, [r7, #0x24]
 8020f9a: 6ab8         	ldr	r0, [r7, #0x28]
 8020f9c: f7ff fd36    	bl	0x8020a0c <LL_GPIO_SetPinOutputType> @ imm = #-0x594
; 	LL_GPIO_SetPinSpeed(gpio, pin_ll, ospeed >> STM32_OSPEEDR_SHIFT);
 8020fa0: 69bb         	ldr	r3, [r7, #0x18]
 8020fa2: 09db         	lsrs	r3, r3, #0x7
 8020fa4: 461a         	mov	r2, r3
 8020fa6: 6a79         	ldr	r1, [r7, #0x24]
 8020fa8: 6ab8         	ldr	r0, [r7, #0x28]
 8020faa: f7ff fd47    	bl	0x8020a3c <LL_GPIO_SetPinSpeed> @ imm = #-0x572
; 	ll_gpio_set_pin_pull(gpio, pin_ll, pupd >> STM32_PUPDR_SHIFT);
 8020fae: 697b         	ldr	r3, [r7, #0x14]
 8020fb0: 0a5b         	lsrs	r3, r3, #0x9
 8020fb2: 461a         	mov	r2, r3
 8020fb4: 6a79         	ldr	r1, [r7, #0x24]
 8020fb6: 6ab8         	ldr	r0, [r7, #0x28]
 8020fb8: f7ff ff91    	bl	0x8020ede <ll_gpio_set_pin_pull> @ imm = #-0xde
; 	if (mode == STM32_MODER_ALT_MODE) {
 8020fbc: 6a3b         	ldr	r3, [r7, #0x20]
 8020fbe: 2b20         	cmp	r3, #0x20
 8020fc0: d10d         	bne	0x8020fde <gpio_stm32_configure_raw+0x9c> @ imm = #0x1a
; 		if (pin < 8) {
 8020fc2: 7afb         	ldrb	r3, [r7, #0xb]
 8020fc4: 2b07         	cmp	r3, #0x7
 8020fc6: d805         	bhi	0x8020fd4 <gpio_stm32_configure_raw+0x92> @ imm = #0xa
; 			LL_GPIO_SetAFPin_0_7(gpio, pin_ll, func);
 8020fc8: 683a         	ldr	r2, [r7]
 8020fca: 6a79         	ldr	r1, [r7, #0x24]
 8020fcc: 6ab8         	ldr	r0, [r7, #0x28]
 8020fce: f7ff fd75    	bl	0x8020abc <LL_GPIO_SetAFPin_0_7> @ imm = #-0x516
 8020fd2: e004         	b	0x8020fde <gpio_stm32_configure_raw+0x9c> @ imm = #0x8
; 			LL_GPIO_SetAFPin_8_15(gpio, pin_ll, func);
 8020fd4: 683a         	ldr	r2, [r7]
 8020fd6: 6a79         	ldr	r1, [r7, #0x24]
 8020fd8: 6ab8         	ldr	r0, [r7, #0x28]
 8020fda: f7ff fd9b    	bl	0x8020b14 <LL_GPIO_SetAFPin_8_15> @ imm = #-0x4ca
; 	LL_GPIO_SetPinMode(gpio, pin_ll, mode >> STM32_MODER_SHIFT);
 8020fde: 6a3b         	ldr	r3, [r7, #0x20]
 8020fe0: 091b         	lsrs	r3, r3, #0x4
 8020fe2: 461a         	mov	r2, r3
 8020fe4: 6a79         	ldr	r1, [r7, #0x24]
 8020fe6: 6ab8         	ldr	r0, [r7, #0x28]
 8020fe8: f7ff fcf0    	bl	0x80209cc <LL_GPIO_SetPinMode> @ imm = #-0x620
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 8020fec: 2000         	movs	r0, #0x0
 8020fee: f7ff fe4c    	bl	0x8020c8a <z_stm32_hsem_unlock> @ imm = #-0x368
; }
 8020ff2: bf00         	nop
 8020ff4: 3730         	adds	r7, #0x30
 8020ff6: 46bd         	mov	sp, r7
 8020ff8: bd80         	pop	{r7, pc}

08020ffa <gpio_stm32_port_get_raw>:
; {
 8020ffa: b580         	push	{r7, lr}
 8020ffc: b084         	sub	sp, #0x10
 8020ffe: af00         	add	r7, sp, #0x0
 8021000: 6078         	str	r0, [r7, #0x4]
 8021002: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8021004: 687b         	ldr	r3, [r7, #0x4]
 8021006: 685b         	ldr	r3, [r3, #0x4]
 8021008: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 802100a: 68fb         	ldr	r3, [r7, #0xc]
 802100c: 685b         	ldr	r3, [r3, #0x4]
 802100e: 60bb         	str	r3, [r7, #0x8]
; 	*value = LL_GPIO_ReadInputPort(gpio);
 8021010: 68b8         	ldr	r0, [r7, #0x8]
 8021012: f7ff fdb5    	bl	0x8020b80 <LL_GPIO_ReadInputPort> @ imm = #-0x496
 8021016: 4602         	mov	r2, r0
 8021018: 683b         	ldr	r3, [r7]
 802101a: 601a         	str	r2, [r3]
; 	return 0;
 802101c: 2300         	movs	r3, #0x0
; }
 802101e: 4618         	mov	r0, r3
 8021020: 3710         	adds	r7, #0x10
 8021022: 46bd         	mov	sp, r7
 8021024: bd80         	pop	{r7, pc}

08021026 <gpio_stm32_port_set_masked_raw>:
; {
 8021026: b580         	push	{r7, lr}
 8021028: b088         	sub	sp, #0x20
 802102a: af00         	add	r7, sp, #0x0
 802102c: 60f8         	str	r0, [r7, #0xc]
 802102e: 60b9         	str	r1, [r7, #0x8]
 8021030: 607a         	str	r2, [r7, #0x4]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8021032: 68fb         	ldr	r3, [r7, #0xc]
 8021034: 685b         	ldr	r3, [r3, #0x4]
 8021036: 61fb         	str	r3, [r7, #0x1c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8021038: 69fb         	ldr	r3, [r7, #0x1c]
 802103a: 685b         	ldr	r3, [r3, #0x4]
 802103c: 61bb         	str	r3, [r7, #0x18]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 802103e: f44f 1180    	mov.w	r1, #0x100000
 8021042: 2000         	movs	r0, #0x0
 8021044: f7ff fe16    	bl	0x8020c74 <z_stm32_hsem_lock> @ imm = #-0x3d4
; 	port_value = LL_GPIO_ReadOutputPort(gpio);
 8021048: 69b8         	ldr	r0, [r7, #0x18]
 802104a: f7ff fdb3    	bl	0x8020bb4 <LL_GPIO_ReadOutputPort> @ imm = #-0x49a
 802104e: 6178         	str	r0, [r7, #0x14]
; 	LL_GPIO_WriteOutputPort(gpio, (port_value & ~mask) | (mask & value));
 8021050: 68bb         	ldr	r3, [r7, #0x8]
 8021052: 43da         	mvns	r2, r3
 8021054: 697b         	ldr	r3, [r7, #0x14]
 8021056: 401a         	ands	r2, r3
 8021058: 68b9         	ldr	r1, [r7, #0x8]
 802105a: 687b         	ldr	r3, [r7, #0x4]
 802105c: 400b         	ands	r3, r1
 802105e: 4313         	orrs	r3, r2
 8021060: 4619         	mov	r1, r3
 8021062: 69b8         	ldr	r0, [r7, #0x18]
 8021064: f7ff fd98    	bl	0x8020b98 <LL_GPIO_WriteOutputPort> @ imm = #-0x4d0
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 8021068: 2000         	movs	r0, #0x0
 802106a: f7ff fe0e    	bl	0x8020c8a <z_stm32_hsem_unlock> @ imm = #-0x3e4
; 	return 0;
 802106e: 2300         	movs	r3, #0x0
; }
 8021070: 4618         	mov	r0, r3
 8021072: 3720         	adds	r7, #0x20
 8021074: 46bd         	mov	sp, r7
 8021076: bd80         	pop	{r7, pc}

08021078 <gpio_stm32_port_set_bits_raw>:
; {
 8021078: b480         	push	{r7}
 802107a: b085         	sub	sp, #0x14
 802107c: af00         	add	r7, sp, #0x0
 802107e: 6078         	str	r0, [r7, #0x4]
 8021080: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8021082: 687b         	ldr	r3, [r7, #0x4]
 8021084: 685b         	ldr	r3, [r3, #0x4]
 8021086: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8021088: 68fb         	ldr	r3, [r7, #0xc]
 802108a: 685b         	ldr	r3, [r3, #0x4]
 802108c: 60bb         	str	r3, [r7, #0x8]
; 	WRITE_REG(gpio->BSRR, pins);
 802108e: 68bb         	ldr	r3, [r7, #0x8]
 8021090: 683a         	ldr	r2, [r7]
 8021092: 619a         	str	r2, [r3, #0x18]
; 	return 0;
 8021094: 2300         	movs	r3, #0x0
; }
 8021096: 4618         	mov	r0, r3
 8021098: 3714         	adds	r7, #0x14
 802109a: 46bd         	mov	sp, r7
 802109c: f85d 7b04    	ldr	r7, [sp], #4
 80210a0: 4770         	bx	lr

080210a2 <gpio_stm32_port_clear_bits_raw>:
; {
 80210a2: b580         	push	{r7, lr}
 80210a4: b084         	sub	sp, #0x10
 80210a6: af00         	add	r7, sp, #0x0
 80210a8: 6078         	str	r0, [r7, #0x4]
 80210aa: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 80210ac: 687b         	ldr	r3, [r7, #0x4]
 80210ae: 685b         	ldr	r3, [r3, #0x4]
 80210b0: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 80210b2: 68fb         	ldr	r3, [r7, #0xc]
 80210b4: 685b         	ldr	r3, [r3, #0x4]
 80210b6: 60bb         	str	r3, [r7, #0x8]
; 	LL_GPIO_ResetOutputPin(gpio, pins);
 80210b8: 6839         	ldr	r1, [r7]
 80210ba: 68b8         	ldr	r0, [r7, #0x8]
 80210bc: f7ff fd86    	bl	0x8020bcc <LL_GPIO_ResetOutputPin> @ imm = #-0x4f4
; 	return 0;
 80210c0: 2300         	movs	r3, #0x0
; }
 80210c2: 4618         	mov	r0, r3
 80210c4: 3710         	adds	r7, #0x10
 80210c6: 46bd         	mov	sp, r7
 80210c8: bd80         	pop	{r7, pc}

080210ca <gpio_stm32_port_toggle_bits>:
; {
 80210ca: b580         	push	{r7, lr}
 80210cc: b084         	sub	sp, #0x10
 80210ce: af00         	add	r7, sp, #0x0
 80210d0: 6078         	str	r0, [r7, #0x4]
 80210d2: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 80210d4: 687b         	ldr	r3, [r7, #0x4]
 80210d6: 685b         	ldr	r3, [r3, #0x4]
 80210d8: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 80210da: 68fb         	ldr	r3, [r7, #0xc]
 80210dc: 685b         	ldr	r3, [r3, #0x4]
 80210de: 60bb         	str	r3, [r7, #0x8]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 80210e0: f44f 1180    	mov.w	r1, #0x100000
 80210e4: 2000         	movs	r0, #0x0
 80210e6: f7ff fdc5    	bl	0x8020c74 <z_stm32_hsem_lock> @ imm = #-0x476
; 	WRITE_REG(gpio->ODR, READ_REG(gpio->ODR) ^ pins);
 80210ea: 68bb         	ldr	r3, [r7, #0x8]
 80210ec: 695a         	ldr	r2, [r3, #0x14]
 80210ee: 683b         	ldr	r3, [r7]
 80210f0: 405a         	eors	r2, r3
 80210f2: 68bb         	ldr	r3, [r7, #0x8]
 80210f4: 615a         	str	r2, [r3, #0x14]
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 80210f6: 2000         	movs	r0, #0x0
 80210f8: f7ff fdc7    	bl	0x8020c8a <z_stm32_hsem_unlock> @ imm = #-0x472
; 	return 0;
 80210fc: 2300         	movs	r3, #0x0
; }
 80210fe: 4618         	mov	r0, r3
 8021100: 3710         	adds	r7, #0x10
 8021102: 46bd         	mov	sp, r7
 8021104: bd80         	pop	{r7, pc}

08021106 <gpio_stm32_configure>:
; {
 8021106: b580         	push	{r7, lr}
 8021108: b086         	sub	sp, #0x18
 802110a: af00         	add	r7, sp, #0x0
 802110c: 60f8         	str	r0, [r7, #0xc]
 802110e: 607a         	str	r2, [r7, #0x4]
 8021110: 603b         	str	r3, [r7]
 8021112: 460b         	mov	r3, r1
 8021114: 72fb         	strb	r3, [r7, #0xb]
; 	ret = pm_device_runtime_get(dev);
 8021116: 68f8         	ldr	r0, [r7, #0xc]
 8021118: f7ff fd96    	bl	0x8020c48 <pm_device_runtime_get> @ imm = #-0x4d4
 802111c: 6178         	str	r0, [r7, #0x14]
; 	if (ret < 0) {
 802111e: 697b         	ldr	r3, [r7, #0x14]
 8021120: 2b00         	cmp	r3, #0x0
 8021122: da01         	bge	0x8021128 <gpio_stm32_configure+0x22> @ imm = #0x2
; 		return ret;
 8021124: 697b         	ldr	r3, [r7, #0x14]
 8021126: e028         	b	0x802117a <gpio_stm32_configure+0x74> @ imm = #0x50
; 	gpio_stm32_configure_raw(dev, pin, conf, func);
 8021128: 7af9         	ldrb	r1, [r7, #0xb]
 802112a: 683b         	ldr	r3, [r7]
 802112c: 687a         	ldr	r2, [r7, #0x4]
 802112e: 68f8         	ldr	r0, [r7, #0xc]
 8021130: f7ff ff07    	bl	0x8020f42 <gpio_stm32_configure_raw> @ imm = #-0x1f2
; 	if (func == IS_GPIO_OUT) {
 8021134: 683b         	ldr	r3, [r7]
 8021136: 2b11         	cmp	r3, #0x11
 8021138: d11b         	bne	0x8021172 <gpio_stm32_configure+0x6c> @ imm = #0x36
; 		uint32_t gpio_out = conf & (STM32_ODR_MASK << STM32_ODR_SHIFT);
 802113a: 687b         	ldr	r3, [r7, #0x4]
 802113c: f403 6300    	and	r3, r3, #0x800
 8021140: 613b         	str	r3, [r7, #0x10]
; 		if (gpio_out == STM32_ODR_1) {
 8021142: 693b         	ldr	r3, [r7, #0x10]
 8021144: f5b3 6f00    	cmp.w	r3, #0x800
 8021148: d108         	bne	0x802115c <gpio_stm32_configure+0x56> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 802114a: 7afb         	ldrb	r3, [r7, #0xb]
 802114c: 2201         	movs	r2, #0x1
 802114e: fa02 f303    	lsl.w	r3, r2, r3
 8021152: 4619         	mov	r1, r3
 8021154: 68f8         	ldr	r0, [r7, #0xc]
 8021156: f7ff ff8f    	bl	0x8021078 <gpio_stm32_port_set_bits_raw> @ imm = #-0xe2
 802115a: e00a         	b	0x8021172 <gpio_stm32_configure+0x6c> @ imm = #0x14
; 		} else if (gpio_out == STM32_ODR_0) {
 802115c: 693b         	ldr	r3, [r7, #0x10]
 802115e: 2b00         	cmp	r3, #0x0
 8021160: d107         	bne	0x8021172 <gpio_stm32_configure+0x6c> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 8021162: 7afb         	ldrb	r3, [r7, #0xb]
 8021164: 2201         	movs	r2, #0x1
 8021166: fa02 f303    	lsl.w	r3, r2, r3
 802116a: 4619         	mov	r1, r3
 802116c: 68f8         	ldr	r0, [r7, #0xc]
 802116e: f7ff ff98    	bl	0x80210a2 <gpio_stm32_port_clear_bits_raw> @ imm = #-0xd0
; 	return pm_device_runtime_put(dev);
 8021172: 68f8         	ldr	r0, [r7, #0xc]
 8021174: f7ff fd73    	bl	0x8020c5e <pm_device_runtime_put> @ imm = #-0x51a
 8021178: 4603         	mov	r3, r0
; }
 802117a: 4618         	mov	r0, r3
 802117c: 3718         	adds	r7, #0x18
 802117e: 46bd         	mov	sp, r7
 8021180: bd80         	pop	{r7, pc}

08021182 <gpio_stm32_config>:
; {
 8021182: b580         	push	{r7, lr}
 8021184: b088         	sub	sp, #0x20
 8021186: af00         	add	r7, sp, #0x0
 8021188: 60f8         	str	r0, [r7, #0xc]
 802118a: 460b         	mov	r3, r1
 802118c: 607a         	str	r2, [r7, #0x4]
 802118e: 72fb         	strb	r3, [r7, #0xb]
; 	struct gpio_stm32_data *data = dev->data;
 8021190: 68fb         	ldr	r3, [r7, #0xc]
 8021192: 691b         	ldr	r3, [r3, #0x10]
 8021194: 61fb         	str	r3, [r7, #0x1c]
; 	err = gpio_stm32_flags_to_conf(flags, &pincfg);
 8021196: f107 0314    	add.w	r3, r7, #0x14
 802119a: 4619         	mov	r1, r3
 802119c: 6878         	ldr	r0, [r7, #0x4]
 802119e: f7ff fe21    	bl	0x8020de4 <gpio_stm32_flags_to_conf> @ imm = #-0x3be
 80211a2: 61b8         	str	r0, [r7, #0x18]
; 	if (err != 0) {
 80211a4: 69bb         	ldr	r3, [r7, #0x18]
 80211a6: 2b00         	cmp	r3, #0x0
 80211a8: d001         	beq	0x80211ae <gpio_stm32_config+0x2c> @ imm = #0x2
; 		return err;
 80211aa: 69bb         	ldr	r3, [r7, #0x18]
 80211ac: e071         	b	0x8021292 <gpio_stm32_config+0x110> @ imm = #0xe2
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 80211ae: 687b         	ldr	r3, [r7, #0x4]
 80211b0: f403 3300    	and	r3, r3, #0x20000
 80211b4: 2b00         	cmp	r3, #0x0
 80211b6: d104         	bne	0x80211c2 <gpio_stm32_config+0x40> @ imm = #0x8
 80211b8: 687b         	ldr	r3, [r7, #0x4]
 80211ba: f403 3380    	and	r3, r3, #0x10000
 80211be: 2b00         	cmp	r3, #0x0
 80211c0: d01a         	beq	0x80211f8 <gpio_stm32_config+0x76> @ imm = #0x34
; 	    !(data->pin_has_clock_enabled & BIT(pin))) {
 80211c2: 69fb         	ldr	r3, [r7, #0x1c]
 80211c4: 691a         	ldr	r2, [r3, #0x10]
 80211c6: 7afb         	ldrb	r3, [r7, #0xb]
 80211c8: fa22 f303    	lsr.w	r3, r2, r3
 80211cc: f003 0301    	and	r3, r3, #0x1
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 80211d0: 2b00         	cmp	r3, #0x0
 80211d2: d111         	bne	0x80211f8 <gpio_stm32_config+0x76> @ imm = #0x22
; 		err = pm_device_runtime_get(dev);
 80211d4: 68f8         	ldr	r0, [r7, #0xc]
 80211d6: f7ff fd37    	bl	0x8020c48 <pm_device_runtime_get> @ imm = #-0x592
 80211da: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 80211dc: 69bb         	ldr	r3, [r7, #0x18]
 80211de: 2b00         	cmp	r3, #0x0
 80211e0: da01         	bge	0x80211e6 <gpio_stm32_config+0x64> @ imm = #0x2
; 			return err;
 80211e2: 69bb         	ldr	r3, [r7, #0x18]
 80211e4: e055         	b	0x8021292 <gpio_stm32_config+0x110> @ imm = #0xaa
; 		data->pin_has_clock_enabled |= BIT(pin);
 80211e6: 69fb         	ldr	r3, [r7, #0x1c]
 80211e8: 691a         	ldr	r2, [r3, #0x10]
 80211ea: 7afb         	ldrb	r3, [r7, #0xb]
 80211ec: 2101         	movs	r1, #0x1
 80211ee: fa01 f303    	lsl.w	r3, r1, r3
 80211f2: 431a         	orrs	r2, r3
 80211f4: 69fb         	ldr	r3, [r7, #0x1c]
 80211f6: 611a         	str	r2, [r3, #0x10]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 80211f8: 687b         	ldr	r3, [r7, #0x4]
 80211fa: f403 3300    	and	r3, r3, #0x20000
 80211fe: 2b00         	cmp	r3, #0x0
 8021200: d01a         	beq	0x8021238 <gpio_stm32_config+0xb6> @ imm = #0x34
; 		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
 8021202: 687b         	ldr	r3, [r7, #0x4]
 8021204: f403 2300    	and	r3, r3, #0x80000
 8021208: 2b00         	cmp	r3, #0x0
 802120a: d008         	beq	0x802121e <gpio_stm32_config+0x9c> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 802120c: 7afb         	ldrb	r3, [r7, #0xb]
 802120e: 2201         	movs	r2, #0x1
 8021210: fa02 f303    	lsl.w	r3, r2, r3
 8021214: 4619         	mov	r1, r3
 8021216: 68f8         	ldr	r0, [r7, #0xc]
 8021218: f7ff ff2e    	bl	0x8021078 <gpio_stm32_port_set_bits_raw> @ imm = #-0x1a4
 802121c: e00c         	b	0x8021238 <gpio_stm32_config+0xb6> @ imm = #0x18
; 		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
 802121e: 687b         	ldr	r3, [r7, #0x4]
 8021220: f403 2380    	and	r3, r3, #0x40000
 8021224: 2b00         	cmp	r3, #0x0
 8021226: d007         	beq	0x8021238 <gpio_stm32_config+0xb6> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 8021228: 7afb         	ldrb	r3, [r7, #0xb]
 802122a: 2201         	movs	r2, #0x1
 802122c: fa02 f303    	lsl.w	r3, r2, r3
 8021230: 4619         	mov	r1, r3
 8021232: 68f8         	ldr	r0, [r7, #0xc]
 8021234: f7ff ff35    	bl	0x80210a2 <gpio_stm32_port_clear_bits_raw> @ imm = #-0x196
; 	gpio_stm32_configure_raw(dev, pin, pincfg, 0);
 8021238: 697a         	ldr	r2, [r7, #0x14]
 802123a: 7af9         	ldrb	r1, [r7, #0xb]
 802123c: 2300         	movs	r3, #0x0
 802123e: 68f8         	ldr	r0, [r7, #0xc]
 8021240: f7ff fe7f    	bl	0x8020f42 <gpio_stm32_configure_raw> @ imm = #-0x302
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 8021244: 687b         	ldr	r3, [r7, #0x4]
 8021246: f403 3300    	and	r3, r3, #0x20000
 802124a: 2b00         	cmp	r3, #0x0
 802124c: d120         	bne	0x8021290 <gpio_stm32_config+0x10e> @ imm = #0x40
 802124e: 687b         	ldr	r3, [r7, #0x4]
 8021250: f403 3380    	and	r3, r3, #0x10000
 8021254: 2b00         	cmp	r3, #0x0
 8021256: d11b         	bne	0x8021290 <gpio_stm32_config+0x10e> @ imm = #0x36
; 	    (data->pin_has_clock_enabled & BIT(pin))) {
 8021258: 69fb         	ldr	r3, [r7, #0x1c]
 802125a: 691a         	ldr	r2, [r3, #0x10]
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 802125c: 7afb         	ldrb	r3, [r7, #0xb]
 802125e: fa22 f303    	lsr.w	r3, r2, r3
 8021262: f003 0301    	and	r3, r3, #0x1
 8021266: 2b00         	cmp	r3, #0x0
 8021268: d012         	beq	0x8021290 <gpio_stm32_config+0x10e> @ imm = #0x24
; 		err = pm_device_runtime_put(dev);
 802126a: 68f8         	ldr	r0, [r7, #0xc]
 802126c: f7ff fcf7    	bl	0x8020c5e <pm_device_runtime_put> @ imm = #-0x612
 8021270: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 8021272: 69bb         	ldr	r3, [r7, #0x18]
 8021274: 2b00         	cmp	r3, #0x0
 8021276: da01         	bge	0x802127c <gpio_stm32_config+0xfa> @ imm = #0x2
; 			return err;
 8021278: 69bb         	ldr	r3, [r7, #0x18]
 802127a: e00a         	b	0x8021292 <gpio_stm32_config+0x110> @ imm = #0x14
; 		data->pin_has_clock_enabled &= ~BIT(pin);
 802127c: 69fb         	ldr	r3, [r7, #0x1c]
 802127e: 691a         	ldr	r2, [r3, #0x10]
 8021280: 7afb         	ldrb	r3, [r7, #0xb]
 8021282: 2101         	movs	r1, #0x1
 8021284: fa01 f303    	lsl.w	r3, r1, r3
 8021288: 43db         	mvns	r3, r3
 802128a: 401a         	ands	r2, r3
 802128c: 69fb         	ldr	r3, [r7, #0x1c]
 802128e: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 8021290: 2300         	movs	r3, #0x0
; }
 8021292: 4618         	mov	r0, r3
 8021294: 3720         	adds	r7, #0x20
 8021296: 46bd         	mov	sp, r7
 8021298: bd80         	pop	{r7, pc}

0802129a <gpio_stm32_manage_callback>:
; {
 802129a: b580         	push	{r7, lr}
 802129c: b086         	sub	sp, #0x18
 802129e: af00         	add	r7, sp, #0x0
 80212a0: 60f8         	str	r0, [r7, #0xc]
 80212a2: 60b9         	str	r1, [r7, #0x8]
 80212a4: 4613         	mov	r3, r2
 80212a6: 71fb         	strb	r3, [r7, #0x7]
; 	struct gpio_stm32_data *data = dev->data;
 80212a8: 68fb         	ldr	r3, [r7, #0xc]
 80212aa: 691b         	ldr	r3, [r3, #0x10]
 80212ac: 617b         	str	r3, [r7, #0x14]
; 	return gpio_manage_callback(&data->cb, callback, set);
 80212ae: 697b         	ldr	r3, [r7, #0x14]
 80212b0: 3308         	adds	r3, #0x8
 80212b2: 79fa         	ldrb	r2, [r7, #0x7]
 80212b4: 68b9         	ldr	r1, [r7, #0x8]
 80212b6: 4618         	mov	r0, r3
 80212b8: f7ff fcf1    	bl	0x8020c9e <gpio_manage_callback> @ imm = #-0x61e
 80212bc: 4603         	mov	r3, r0
; }
 80212be: 4618         	mov	r0, r3
 80212c0: 3718         	adds	r7, #0x18
 80212c2: 46bd         	mov	sp, r7
 80212c4: bd80         	pop	{r7, pc}

080212c6 <device_is_ready>:
; {
 80212c6: b580         	push	{r7, lr}
 80212c8: b082         	sub	sp, #0x8
 80212ca: af00         	add	r7, sp, #0x0
 80212cc: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80212ce: 6878         	ldr	r0, [r7, #0x4]
 80212d0: f005 f865    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x50ca
 80212d4: 4603         	mov	r3, r0
; }
 80212d6: 4618         	mov	r0, r3
 80212d8: 3708         	adds	r7, #0x8
 80212da: 46bd         	mov	sp, r7
 80212dc: bd80         	pop	{r7, pc}

080212de <z_impl_gpio_pin_configure>:
; {
 80212de: b580         	push	{r7, lr}
 80212e0: b088         	sub	sp, #0x20
 80212e2: af00         	add	r7, sp, #0x0
 80212e4: 60f8         	str	r0, [r7, #0xc]
 80212e6: 460b         	mov	r3, r1
 80212e8: 607a         	str	r2, [r7, #0x4]
 80212ea: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 80212ec: 68fb         	ldr	r3, [r7, #0xc]
 80212ee: 689b         	ldr	r3, [r3, #0x8]
 80212f0: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 80212f2: 68fb         	ldr	r3, [r7, #0xc]
 80212f4: 685b         	ldr	r3, [r3, #0x4]
 80212f6: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 80212f8: 68fb         	ldr	r3, [r7, #0xc]
 80212fa: 691b         	ldr	r3, [r3, #0x10]
 80212fc: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 80212fe: 687b         	ldr	r3, [r7, #0x4]
 8021300: f403 1380    	and	r3, r3, #0x100000
 8021304: 2b00         	cmp	r3, #0x0
 8021306: d00d         	beq	0x8021324 <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 8021308: 687b         	ldr	r3, [r7, #0x4]
 802130a: f403 2340    	and	r3, r3, #0xc0000
 802130e: 2b00         	cmp	r3, #0x0
 8021310: d008         	beq	0x8021324 <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 8021312: 687b         	ldr	r3, [r7, #0x4]
 8021314: f003 0301    	and	r3, r3, #0x1
 8021318: 2b00         	cmp	r3, #0x0
 802131a: d003         	beq	0x8021324 <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 802131c: 687b         	ldr	r3, [r7, #0x4]
 802131e: f483 2340    	eor	r3, r3, #0xc0000
 8021322: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 8021324: 687b         	ldr	r3, [r7, #0x4]
 8021326: f423 1380    	bic	r3, r3, #0x100000
 802132a: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 802132c: 687b         	ldr	r3, [r7, #0x4]
 802132e: f003 0301    	and	r3, r3, #0x1
 8021332: 2b00         	cmp	r3, #0x0
 8021334: d009         	beq	0x802134a <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 8021336: 697b         	ldr	r3, [r7, #0x14]
 8021338: 681a         	ldr	r2, [r3]
 802133a: 7afb         	ldrb	r3, [r7, #0xb]
 802133c: 2101         	movs	r1, #0x1
 802133e: fa01 f303    	lsl.w	r3, r1, r3
 8021342: 431a         	orrs	r2, r3
 8021344: 697b         	ldr	r3, [r7, #0x14]
 8021346: 601a         	str	r2, [r3]
 8021348: e009         	b	0x802135e <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 802134a: 697b         	ldr	r3, [r7, #0x14]
 802134c: 681a         	ldr	r2, [r3]
 802134e: 7afb         	ldrb	r3, [r7, #0xb]
 8021350: 2101         	movs	r1, #0x1
 8021352: fa01 f303    	lsl.w	r3, r1, r3
 8021356: 43db         	mvns	r3, r3
 8021358: 401a         	ands	r2, r3
 802135a: 697b         	ldr	r3, [r7, #0x14]
 802135c: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 802135e: 69fb         	ldr	r3, [r7, #0x1c]
 8021360: 681b         	ldr	r3, [r3]
 8021362: 7af9         	ldrb	r1, [r7, #0xb]
 8021364: 687a         	ldr	r2, [r7, #0x4]
 8021366: 68f8         	ldr	r0, [r7, #0xc]
 8021368: 4798         	blx	r3
 802136a: 4603         	mov	r3, r0
; }
 802136c: 4618         	mov	r0, r3
 802136e: 3720         	adds	r7, #0x20
 8021370: 46bd         	mov	sp, r7
 8021372: bd80         	pop	{r7, pc}

08021374 <gpio_pin_configure_dt>:
; {
 8021374: b580         	push	{r7, lr}
 8021376: b082         	sub	sp, #0x8
 8021378: af00         	add	r7, sp, #0x0
 802137a: 6078         	str	r0, [r7, #0x4]
 802137c: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 802137e: 687b         	ldr	r3, [r7, #0x4]
 8021380: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 8021382: 687b         	ldr	r3, [r7, #0x4]
 8021384: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 8021386: 687b         	ldr	r3, [r7, #0x4]
 8021388: 88db         	ldrh	r3, [r3, #0x6]
 802138a: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 802138c: 683b         	ldr	r3, [r7]
 802138e: 4313         	orrs	r3, r2
 8021390: 461a         	mov	r2, r3
 8021392: f000 f888    	bl	0x80214a6 <gpio_pin_configure> @ imm = #0x110
 8021396: 4603         	mov	r3, r0
; }
 8021398: 4618         	mov	r0, r3
 802139a: 3708         	adds	r7, #0x8
 802139c: 46bd         	mov	sp, r7
 802139e: bd80         	pop	{r7, pc}

080213a0 <z_impl_gpio_port_set_bits_raw>:
; {
 80213a0: b580         	push	{r7, lr}
 80213a2: b084         	sub	sp, #0x10
 80213a4: af00         	add	r7, sp, #0x0
 80213a6: 6078         	str	r0, [r7, #0x4]
 80213a8: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 80213aa: 687b         	ldr	r3, [r7, #0x4]
 80213ac: 689b         	ldr	r3, [r3, #0x8]
 80213ae: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_set_bits_raw(port, pins);
 80213b0: 68fb         	ldr	r3, [r7, #0xc]
 80213b2: 68db         	ldr	r3, [r3, #0xc]
 80213b4: 6839         	ldr	r1, [r7]
 80213b6: 6878         	ldr	r0, [r7, #0x4]
 80213b8: 4798         	blx	r3
 80213ba: 4603         	mov	r3, r0
; }
 80213bc: 4618         	mov	r0, r3
 80213be: 3710         	adds	r7, #0x10
 80213c0: 46bd         	mov	sp, r7
 80213c2: bd80         	pop	{r7, pc}

080213c4 <z_impl_gpio_port_clear_bits_raw>:
; {
 80213c4: b580         	push	{r7, lr}
 80213c6: b084         	sub	sp, #0x10
 80213c8: af00         	add	r7, sp, #0x0
 80213ca: 6078         	str	r0, [r7, #0x4]
 80213cc: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 80213ce: 687b         	ldr	r3, [r7, #0x4]
 80213d0: 689b         	ldr	r3, [r3, #0x8]
 80213d2: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_clear_bits_raw(port, pins);
 80213d4: 68fb         	ldr	r3, [r7, #0xc]
 80213d6: 691b         	ldr	r3, [r3, #0x10]
 80213d8: 6839         	ldr	r1, [r7]
 80213da: 6878         	ldr	r0, [r7, #0x4]
 80213dc: 4798         	blx	r3
 80213de: 4603         	mov	r3, r0
; }
 80213e0: 4618         	mov	r0, r3
 80213e2: 3710         	adds	r7, #0x10
 80213e4: 46bd         	mov	sp, r7
 80213e6: bd80         	pop	{r7, pc}

080213e8 <gpio_pin_set_raw>:
; {
 80213e8: b580         	push	{r7, lr}
 80213ea: b086         	sub	sp, #0x18
 80213ec: af00         	add	r7, sp, #0x0
 80213ee: 60f8         	str	r0, [r7, #0xc]
 80213f0: 460b         	mov	r3, r1
 80213f2: 607a         	str	r2, [r7, #0x4]
 80213f4: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 80213f6: 68fb         	ldr	r3, [r7, #0xc]
 80213f8: 685b         	ldr	r3, [r3, #0x4]
 80213fa: 613b         	str	r3, [r7, #0x10]
; 	if (value != 0)	{
 80213fc: 687b         	ldr	r3, [r7, #0x4]
 80213fe: 2b00         	cmp	r3, #0x0
 8021400: d009         	beq	0x8021416 <gpio_pin_set_raw+0x2e> @ imm = #0x12
; 		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 8021402: 7afb         	ldrb	r3, [r7, #0xb]
 8021404: 2201         	movs	r2, #0x1
 8021406: fa02 f303    	lsl.w	r3, r2, r3
 802140a: 4619         	mov	r1, r3
 802140c: 68f8         	ldr	r0, [r7, #0xc]
 802140e: f000 f85c    	bl	0x80214ca <gpio_port_set_bits_raw> @ imm = #0xb8
 8021412: 6178         	str	r0, [r7, #0x14]
 8021414: e008         	b	0x8021428 <gpio_pin_set_raw+0x40> @ imm = #0x10
; 		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 8021416: 7afb         	ldrb	r3, [r7, #0xb]
 8021418: 2201         	movs	r2, #0x1
 802141a: fa02 f303    	lsl.w	r3, r2, r3
 802141e: 4619         	mov	r1, r3
 8021420: 68f8         	ldr	r0, [r7, #0xc]
 8021422: f000 f860    	bl	0x80214e6 <gpio_port_clear_bits_raw> @ imm = #0xc0
 8021426: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 8021428: 697b         	ldr	r3, [r7, #0x14]
; }
 802142a: 4618         	mov	r0, r3
 802142c: 3718         	adds	r7, #0x18
 802142e: 46bd         	mov	sp, r7
 8021430: bd80         	pop	{r7, pc}

08021432 <gpio_pin_set>:
; {
 8021432: b580         	push	{r7, lr}
 8021434: b086         	sub	sp, #0x18
 8021436: af00         	add	r7, sp, #0x0
 8021438: 60f8         	str	r0, [r7, #0xc]
 802143a: 460b         	mov	r3, r1
 802143c: 607a         	str	r2, [r7, #0x4]
 802143e: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 8021440: 68fb         	ldr	r3, [r7, #0xc]
 8021442: 685b         	ldr	r3, [r3, #0x4]
 8021444: 617b         	str	r3, [r7, #0x14]
; 	const struct gpio_driver_data *const data =
 8021446: 68fb         	ldr	r3, [r7, #0xc]
 8021448: 691b         	ldr	r3, [r3, #0x10]
 802144a: 613b         	str	r3, [r7, #0x10]
; 	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
 802144c: 693b         	ldr	r3, [r7, #0x10]
 802144e: 681a         	ldr	r2, [r3]
 8021450: 7afb         	ldrb	r3, [r7, #0xb]
 8021452: 2101         	movs	r1, #0x1
 8021454: fa01 f303    	lsl.w	r3, r1, r3
 8021458: 4013         	ands	r3, r2
 802145a: 2b00         	cmp	r3, #0x0
 802145c: d006         	beq	0x802146c <gpio_pin_set+0x3a> @ imm = #0xc
; 		value = (value != 0) ? 0 : 1;
 802145e: 687b         	ldr	r3, [r7, #0x4]
 8021460: 2b00         	cmp	r3, #0x0
 8021462: bf0c         	ite	eq
 8021464: 2301         	moveq	r3, #0x1
 8021466: 2300         	movne	r3, #0x0
 8021468: b2db         	uxtb	r3, r3
 802146a: 607b         	str	r3, [r7, #0x4]
; 	return gpio_pin_set_raw(port, pin, value);
 802146c: 7afb         	ldrb	r3, [r7, #0xb]
 802146e: 687a         	ldr	r2, [r7, #0x4]
 8021470: 4619         	mov	r1, r3
 8021472: 68f8         	ldr	r0, [r7, #0xc]
 8021474: f7ff ffb8    	bl	0x80213e8 <gpio_pin_set_raw> @ imm = #-0x90
 8021478: 4603         	mov	r3, r0
; }
 802147a: 4618         	mov	r0, r3
 802147c: 3718         	adds	r7, #0x18
 802147e: 46bd         	mov	sp, r7
 8021480: bd80         	pop	{r7, pc}

08021482 <gpio_pin_set_dt>:
; {
 8021482: b580         	push	{r7, lr}
 8021484: b082         	sub	sp, #0x8
 8021486: af00         	add	r7, sp, #0x0
 8021488: 6078         	str	r0, [r7, #0x4]
 802148a: 6039         	str	r1, [r7]
; 	return gpio_pin_set(spec->port, spec->pin, value);
 802148c: 687b         	ldr	r3, [r7, #0x4]
 802148e: 6818         	ldr	r0, [r3]
 8021490: 687b         	ldr	r3, [r7, #0x4]
 8021492: 791b         	ldrb	r3, [r3, #0x4]
 8021494: 683a         	ldr	r2, [r7]
 8021496: 4619         	mov	r1, r3
 8021498: f7ff ffcb    	bl	0x8021432 <gpio_pin_set> @ imm = #-0x6a
 802149c: 4603         	mov	r3, r0
; }
 802149e: 4618         	mov	r0, r3
 80214a0: 3708         	adds	r7, #0x8
 80214a2: 46bd         	mov	sp, r7
 80214a4: bd80         	pop	{r7, pc}

080214a6 <gpio_pin_configure>:
; {
 80214a6: b580         	push	{r7, lr}
 80214a8: b084         	sub	sp, #0x10
 80214aa: af00         	add	r7, sp, #0x0
 80214ac: 60f8         	str	r0, [r7, #0xc]
 80214ae: 460b         	mov	r3, r1
 80214b0: 607a         	str	r2, [r7, #0x4]
 80214b2: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 80214b4: 7afb         	ldrb	r3, [r7, #0xb]
 80214b6: 687a         	ldr	r2, [r7, #0x4]
 80214b8: 4619         	mov	r1, r3
 80214ba: 68f8         	ldr	r0, [r7, #0xc]
 80214bc: f7ff ff0f    	bl	0x80212de <z_impl_gpio_pin_configure> @ imm = #-0x1e2
 80214c0: 4603         	mov	r3, r0
; }
 80214c2: 4618         	mov	r0, r3
 80214c4: 3710         	adds	r7, #0x10
 80214c6: 46bd         	mov	sp, r7
 80214c8: bd80         	pop	{r7, pc}

080214ca <gpio_port_set_bits_raw>:
; {
 80214ca: b580         	push	{r7, lr}
 80214cc: b082         	sub	sp, #0x8
 80214ce: af00         	add	r7, sp, #0x0
 80214d0: 6078         	str	r0, [r7, #0x4]
 80214d2: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_set_bits_raw(port, pins);
 80214d4: 6839         	ldr	r1, [r7]
 80214d6: 6878         	ldr	r0, [r7, #0x4]
 80214d8: f7ff ff62    	bl	0x80213a0 <z_impl_gpio_port_set_bits_raw> @ imm = #-0x13c
 80214dc: 4603         	mov	r3, r0
; }
 80214de: 4618         	mov	r0, r3
 80214e0: 3708         	adds	r7, #0x8
 80214e2: 46bd         	mov	sp, r7
 80214e4: bd80         	pop	{r7, pc}

080214e6 <gpio_port_clear_bits_raw>:
; {
 80214e6: b580         	push	{r7, lr}
 80214e8: b082         	sub	sp, #0x8
 80214ea: af00         	add	r7, sp, #0x0
 80214ec: 6078         	str	r0, [r7, #0x4]
 80214ee: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_clear_bits_raw(port, pins);
 80214f0: 6839         	ldr	r1, [r7]
 80214f2: 6878         	ldr	r0, [r7, #0x4]
 80214f4: f7ff ff66    	bl	0x80213c4 <z_impl_gpio_port_clear_bits_raw> @ imm = #-0x134
 80214f8: 4603         	mov	r3, r0
; }
 80214fa: 4618         	mov	r0, r3
 80214fc: 3708         	adds	r7, #0x8
 80214fe: 46bd         	mov	sp, r7
 8021500: bd80         	pop	{r7, pc}

08021502 <z_log_msg_runtime_create>:
; {
 8021502: b580         	push	{r7, lr}
 8021504: b08a         	sub	sp, #0x28
 8021506: af04         	add	r7, sp, #0x10
 8021508: 60b9         	str	r1, [r7, #0x8]
 802150a: 607b         	str	r3, [r7, #0x4]
 802150c: 4603         	mov	r3, r0
 802150e: 73fb         	strb	r3, [r7, #0xf]
 8021510: 4613         	mov	r3, r2
 8021512: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8021514: f107 032c    	add.w	r3, r7, #0x2c
 8021518: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 802151a: 7bba         	ldrb	r2, [r7, #0xe]
 802151c: 7bf8         	ldrb	r0, [r7, #0xf]
 802151e: 697b         	ldr	r3, [r7, #0x14]
 8021520: 9303         	str	r3, [sp, #0xc]
 8021522: 6abb         	ldr	r3, [r7, #0x28]
 8021524: 9302         	str	r3, [sp, #0x8]
 8021526: 6a7b         	ldr	r3, [r7, #0x24]
 8021528: 9301         	str	r3, [sp, #0x4]
 802152a: 6a3b         	ldr	r3, [r7, #0x20]
 802152c: 9300         	str	r3, [sp]
 802152e: 687b         	ldr	r3, [r7, #0x4]
 8021530: 68b9         	ldr	r1, [r7, #0x8]
 8021532: f7e3 fb1f    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1c9c2
; }
 8021536: bf00         	nop
 8021538: 3718         	adds	r7, #0x18
 802153a: 46bd         	mov	sp, r7
 802153c: bd80         	pop	{r7, pc}

0802153e <led_gpio_set_brightness>:
; {
 802153e: b580         	push	{r7, lr}
 8021540: b086         	sub	sp, #0x18
 8021542: af00         	add	r7, sp, #0x0
 8021544: 60f8         	str	r0, [r7, #0xc]
 8021546: 60b9         	str	r1, [r7, #0x8]
 8021548: 4613         	mov	r3, r2
 802154a: 71fb         	strb	r3, [r7, #0x7]
; 	const struct led_gpio_config *config = dev->config;
 802154c: 68fb         	ldr	r3, [r7, #0xc]
 802154e: 685b         	ldr	r3, [r3, #0x4]
 8021550: 617b         	str	r3, [r7, #0x14]
; 	if ((led >= config->num_leds) || (value > 100)) {
 8021552: 697b         	ldr	r3, [r7, #0x14]
 8021554: 681b         	ldr	r3, [r3]
 8021556: 68ba         	ldr	r2, [r7, #0x8]
 8021558: 429a         	cmp	r2, r3
 802155a: d202         	bhs	0x8021562 <led_gpio_set_brightness+0x24> @ imm = #0x4
 802155c: 79fb         	ldrb	r3, [r7, #0x7]
 802155e: 2b64         	cmp	r3, #0x64
 8021560: d902         	bls	0x8021568 <led_gpio_set_brightness+0x2a> @ imm = #0x4
; 		return -EINVAL;
 8021562: f06f 0315    	mvn	r3, #0x15
 8021566: e010         	b	0x802158a <led_gpio_set_brightness+0x4c> @ imm = #0x20
; 	led_gpio = &config->led[led];
 8021568: 697b         	ldr	r3, [r7, #0x14]
 802156a: 685a         	ldr	r2, [r3, #0x4]
 802156c: 68bb         	ldr	r3, [r7, #0x8]
 802156e: 00db         	lsls	r3, r3, #0x3
 8021570: 4413         	add	r3, r2
 8021572: 613b         	str	r3, [r7, #0x10]
; 	return gpio_pin_set_dt(led_gpio, value > 0);
 8021574: 79fb         	ldrb	r3, [r7, #0x7]
 8021576: 2b00         	cmp	r3, #0x0
 8021578: bf14         	ite	ne
 802157a: 2301         	movne	r3, #0x1
 802157c: 2300         	moveq	r3, #0x0
 802157e: b2db         	uxtb	r3, r3
 8021580: 4619         	mov	r1, r3
 8021582: 6938         	ldr	r0, [r7, #0x10]
 8021584: f7ff ff7d    	bl	0x8021482 <gpio_pin_set_dt> @ imm = #-0x106
 8021588: 4603         	mov	r3, r0
; }
 802158a: 4618         	mov	r0, r3
 802158c: 3718         	adds	r7, #0x18
 802158e: 46bd         	mov	sp, r7
 8021590: bd80         	pop	{r7, pc}

08021592 <led_gpio_on>:
; {
 8021592: b580         	push	{r7, lr}
 8021594: b082         	sub	sp, #0x8
 8021596: af00         	add	r7, sp, #0x0
 8021598: 6078         	str	r0, [r7, #0x4]
 802159a: 6039         	str	r1, [r7]
; 	return led_gpio_set_brightness(dev, led, 100);
 802159c: 2264         	movs	r2, #0x64
 802159e: 6839         	ldr	r1, [r7]
 80215a0: 6878         	ldr	r0, [r7, #0x4]
 80215a2: f7ff ffcc    	bl	0x802153e <led_gpio_set_brightness> @ imm = #-0x68
 80215a6: 4603         	mov	r3, r0
; }
 80215a8: 4618         	mov	r0, r3
 80215aa: 3708         	adds	r7, #0x8
 80215ac: 46bd         	mov	sp, r7
 80215ae: bd80         	pop	{r7, pc}

080215b0 <led_gpio_off>:
; {
 80215b0: b580         	push	{r7, lr}
 80215b2: b082         	sub	sp, #0x8
 80215b4: af00         	add	r7, sp, #0x0
 80215b6: 6078         	str	r0, [r7, #0x4]
 80215b8: 6039         	str	r1, [r7]
; 	return led_gpio_set_brightness(dev, led, 0);
 80215ba: 2200         	movs	r2, #0x0
 80215bc: 6839         	ldr	r1, [r7]
 80215be: 6878         	ldr	r0, [r7, #0x4]
 80215c0: f7ff ffbd    	bl	0x802153e <led_gpio_set_brightness> @ imm = #-0x86
 80215c4: 4603         	mov	r3, r0
; }
 80215c6: 4618         	mov	r0, r3
 80215c8: 3708         	adds	r7, #0x8
 80215ca: 46bd         	mov	sp, r7
 80215cc: bd80         	pop	{r7, pc}

080215ce <device_is_ready>:
; {
 80215ce: b580         	push	{r7, lr}
 80215d0: b082         	sub	sp, #0x8
 80215d2: af00         	add	r7, sp, #0x0
 80215d4: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80215d6: 6878         	ldr	r0, [r7, #0x4]
 80215d8: f004 fee1    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x4dc2
 80215dc: 4603         	mov	r3, r0
; }
 80215de: 4618         	mov	r0, r3
 80215e0: 3708         	adds	r7, #0x8
 80215e2: 46bd         	mov	sp, r7
 80215e4: bd80         	pop	{r7, pc}

080215e6 <z_log_msg_runtime_create>:
; {
 80215e6: b580         	push	{r7, lr}
 80215e8: b08a         	sub	sp, #0x28
 80215ea: af04         	add	r7, sp, #0x10
 80215ec: 60b9         	str	r1, [r7, #0x8]
 80215ee: 607b         	str	r3, [r7, #0x4]
 80215f0: 4603         	mov	r3, r0
 80215f2: 73fb         	strb	r3, [r7, #0xf]
 80215f4: 4613         	mov	r3, r2
 80215f6: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80215f8: f107 032c    	add.w	r3, r7, #0x2c
 80215fc: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80215fe: 7bba         	ldrb	r2, [r7, #0xe]
 8021600: 7bf8         	ldrb	r0, [r7, #0xf]
 8021602: 697b         	ldr	r3, [r7, #0x14]
 8021604: 9303         	str	r3, [sp, #0xc]
 8021606: 6abb         	ldr	r3, [r7, #0x28]
 8021608: 9302         	str	r3, [sp, #0x8]
 802160a: 6a7b         	ldr	r3, [r7, #0x24]
 802160c: 9301         	str	r3, [sp, #0x4]
 802160e: 6a3b         	ldr	r3, [r7, #0x20]
 8021610: 9300         	str	r3, [sp]
 8021612: 687b         	ldr	r3, [r7, #0x4]
 8021614: 68b9         	ldr	r1, [r7, #0x8]
 8021616: f7e3 faad    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1caa6
; }
 802161a: bf00         	nop
 802161c: 3718         	adds	r7, #0x18
 802161e: 46bd         	mov	sp, r7
 8021620: bd80         	pop	{r7, pc}

08021622 <k_usleep>:
; {
 8021622: b580         	push	{r7, lr}
 8021624: b082         	sub	sp, #0x8
 8021626: af00         	add	r7, sp, #0x0
 8021628: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_usleep(us);
 802162a: 6878         	ldr	r0, [r7, #0x4]
 802162c: f007 fa19    	bl	0x8028a62 <z_impl_k_usleep> @ imm = #0x7432
 8021630: 4603         	mov	r3, r0
; }
 8021632: 4618         	mov	r0, r3
 8021634: 3708         	adds	r7, #0x8
 8021636: 46bd         	mov	sp, r7
 8021638: bd80         	pop	{r7, pc}

0802163a <gpio_is_ready_dt>:
; {
 802163a: b580         	push	{r7, lr}
 802163c: b082         	sub	sp, #0x8
 802163e: af00         	add	r7, sp, #0x0
 8021640: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 8021642: 687b         	ldr	r3, [r7, #0x4]
 8021644: 681b         	ldr	r3, [r3]
 8021646: 4618         	mov	r0, r3
 8021648: f7ff ffc1    	bl	0x80215ce <device_is_ready> @ imm = #-0x7e
 802164c: 4603         	mov	r3, r0
; }
 802164e: 4618         	mov	r0, r3
 8021650: 3708         	adds	r7, #0x8
 8021652: 46bd         	mov	sp, r7
 8021654: bd80         	pop	{r7, pc}

08021656 <spi_cs_is_gpio>:
; {
 8021656: b480         	push	{r7}
 8021658: b083         	sub	sp, #0xc
 802165a: af00         	add	r7, sp, #0x0
 802165c: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 802165e: 687b         	ldr	r3, [r7, #0x4]
 8021660: 689b         	ldr	r3, [r3, #0x8]
 8021662: 2b00         	cmp	r3, #0x0
 8021664: bf14         	ite	ne
 8021666: 2301         	movne	r3, #0x1
 8021668: 2300         	moveq	r3, #0x0
 802166a: b2db         	uxtb	r3, r3
; }
 802166c: 4618         	mov	r0, r3
 802166e: 370c         	adds	r7, #0xc
 8021670: 46bd         	mov	sp, r7
 8021672: f85d 7b04    	ldr	r7, [sp], #4
 8021676: 4770         	bx	lr

08021678 <spi_cs_is_gpio_dt>:
; {
 8021678: b580         	push	{r7, lr}
 802167a: b082         	sub	sp, #0x8
 802167c: af00         	add	r7, sp, #0x0
 802167e: 6078         	str	r0, [r7, #0x4]
; 	return spi_cs_is_gpio(&spec->config);
 8021680: 687b         	ldr	r3, [r7, #0x4]
 8021682: 3304         	adds	r3, #0x4
 8021684: 4618         	mov	r0, r3
 8021686: f7ff ffe6    	bl	0x8021656 <spi_cs_is_gpio> @ imm = #-0x34
 802168a: 4603         	mov	r3, r0
; }
 802168c: 4618         	mov	r0, r3
 802168e: 3708         	adds	r7, #0x8
 8021690: 46bd         	mov	sp, r7
 8021692: bd80         	pop	{r7, pc}

08021694 <spi_is_ready_dt>:
; {
 8021694: b580         	push	{r7, lr}
 8021696: b082         	sub	sp, #0x8
 8021698: af00         	add	r7, sp, #0x0
 802169a: 6078         	str	r0, [r7, #0x4]
; 	if (!device_is_ready(spec->bus)) {
 802169c: 687b         	ldr	r3, [r7, #0x4]
 802169e: 681b         	ldr	r3, [r3]
 80216a0: 4618         	mov	r0, r3
 80216a2: f7ff ff94    	bl	0x80215ce <device_is_ready> @ imm = #-0xd8
 80216a6: 4603         	mov	r3, r0
 80216a8: f083 0301    	eor	r3, r3, #0x1
 80216ac: b2db         	uxtb	r3, r3
 80216ae: 2b00         	cmp	r3, #0x0
 80216b0: d001         	beq	0x80216b6 <spi_is_ready_dt+0x22> @ imm = #0x2
; 		return false;
 80216b2: 2300         	movs	r3, #0x0
 80216b4: e013         	b	0x80216de <spi_is_ready_dt+0x4a> @ imm = #0x26
; 	if (spi_cs_is_gpio_dt(spec) &&
 80216b6: 6878         	ldr	r0, [r7, #0x4]
 80216b8: f7ff ffde    	bl	0x8021678 <spi_cs_is_gpio_dt> @ imm = #-0x44
 80216bc: 4603         	mov	r3, r0
 80216be: 2b00         	cmp	r3, #0x0
 80216c0: d00c         	beq	0x80216dc <spi_is_ready_dt+0x48> @ imm = #0x18
; 	    !gpio_is_ready_dt(&spec->config.cs.gpio)) {
 80216c2: 687b         	ldr	r3, [r7, #0x4]
 80216c4: 330c         	adds	r3, #0xc
 80216c6: 4618         	mov	r0, r3
 80216c8: f7ff ffb7    	bl	0x802163a <gpio_is_ready_dt> @ imm = #-0x92
 80216cc: 4603         	mov	r3, r0
 80216ce: f083 0301    	eor	r3, r3, #0x1
 80216d2: b2db         	uxtb	r3, r3
; 	if (spi_cs_is_gpio_dt(spec) &&
 80216d4: 2b00         	cmp	r3, #0x0
 80216d6: d001         	beq	0x80216dc <spi_is_ready_dt+0x48> @ imm = #0x2
; 		return false;
 80216d8: 2300         	movs	r3, #0x0
 80216da: e000         	b	0x80216de <spi_is_ready_dt+0x4a> @ imm = #0x0
; 	return true;
 80216dc: 2301         	movs	r3, #0x1
; }
 80216de: 4618         	mov	r0, r3
 80216e0: 3708         	adds	r7, #0x8
 80216e2: 46bd         	mov	sp, r7
 80216e4: bd80         	pop	{r7, pc}

080216e6 <z_impl_spi_transceive>:
; {
 80216e6: b590         	push	{r4, r7, lr}
 80216e8: b087         	sub	sp, #0x1c
 80216ea: af00         	add	r7, sp, #0x0
 80216ec: 60f8         	str	r0, [r7, #0xc]
 80216ee: 60b9         	str	r1, [r7, #0x8]
 80216f0: 607a         	str	r2, [r7, #0x4]
 80216f2: 603b         	str	r3, [r7]
; 	const struct spi_driver_api *api =
 80216f4: 68fb         	ldr	r3, [r7, #0xc]
 80216f6: 689b         	ldr	r3, [r3, #0x8]
 80216f8: 617b         	str	r3, [r7, #0x14]
; 	ret = api->transceive(dev, config, tx_bufs, rx_bufs);
 80216fa: 697b         	ldr	r3, [r7, #0x14]
 80216fc: 681c         	ldr	r4, [r3]
 80216fe: 683b         	ldr	r3, [r7]
 8021700: 687a         	ldr	r2, [r7, #0x4]
 8021702: 68b9         	ldr	r1, [r7, #0x8]
 8021704: 68f8         	ldr	r0, [r7, #0xc]
 8021706: 47a0         	blx	r4
 8021708: 6138         	str	r0, [r7, #0x10]
; 	return ret;
 802170a: 693b         	ldr	r3, [r7, #0x10]
; }
 802170c: 4618         	mov	r0, r3
 802170e: 371c         	adds	r7, #0x1c
 8021710: 46bd         	mov	sp, r7
 8021712: bd90         	pop	{r4, r7, pc}

08021714 <spi_write>:
; {
 8021714: b580         	push	{r7, lr}
 8021716: b084         	sub	sp, #0x10
 8021718: af00         	add	r7, sp, #0x0
 802171a: 60f8         	str	r0, [r7, #0xc]
 802171c: 60b9         	str	r1, [r7, #0x8]
 802171e: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(dev, config, tx_bufs, NULL);
 8021720: 2300         	movs	r3, #0x0
 8021722: 687a         	ldr	r2, [r7, #0x4]
 8021724: 68b9         	ldr	r1, [r7, #0x8]
 8021726: 68f8         	ldr	r0, [r7, #0xc]
 8021728: f000 f817    	bl	0x802175a <spi_transceive> @ imm = #0x2e
 802172c: 4603         	mov	r3, r0
; }
 802172e: 4618         	mov	r0, r3
 8021730: 3710         	adds	r7, #0x10
 8021732: 46bd         	mov	sp, r7
 8021734: bd80         	pop	{r7, pc}

08021736 <spi_write_dt>:
; {
 8021736: b580         	push	{r7, lr}
 8021738: b082         	sub	sp, #0x8
 802173a: af00         	add	r7, sp, #0x0
 802173c: 6078         	str	r0, [r7, #0x4]
 802173e: 6039         	str	r1, [r7]
; 	return spi_write(spec->bus, &spec->config, tx_bufs);
 8021740: 687b         	ldr	r3, [r7, #0x4]
 8021742: 6818         	ldr	r0, [r3]
 8021744: 687b         	ldr	r3, [r7, #0x4]
 8021746: 3304         	adds	r3, #0x4
 8021748: 683a         	ldr	r2, [r7]
 802174a: 4619         	mov	r1, r3
 802174c: f7ff ffe2    	bl	0x8021714 <spi_write>   @ imm = #-0x3c
 8021750: 4603         	mov	r3, r0
; }
 8021752: 4618         	mov	r0, r3
 8021754: 3708         	adds	r7, #0x8
 8021756: 46bd         	mov	sp, r7
 8021758: bd80         	pop	{r7, pc}

0802175a <spi_transceive>:
; {
 802175a: b580         	push	{r7, lr}
 802175c: b084         	sub	sp, #0x10
 802175e: af00         	add	r7, sp, #0x0
 8021760: 60f8         	str	r0, [r7, #0xc]
 8021762: 60b9         	str	r1, [r7, #0x8]
 8021764: 607a         	str	r2, [r7, #0x4]
 8021766: 603b         	str	r3, [r7]
; 	return z_impl_spi_transceive(dev, config, tx_bufs, rx_bufs);
 8021768: 683b         	ldr	r3, [r7]
 802176a: 687a         	ldr	r2, [r7, #0x4]
 802176c: 68b9         	ldr	r1, [r7, #0x8]
 802176e: 68f8         	ldr	r0, [r7, #0xc]
 8021770: f7ff ffb9    	bl	0x80216e6 <z_impl_spi_transceive> @ imm = #-0x8e
 8021774: 4603         	mov	r3, r0
; }
 8021776: 4618         	mov	r0, r3
 8021778: 3710         	adds	r7, #0x10
 802177a: 46bd         	mov	sp, r7
 802177c: bd80         	pop	{r7, pc}

0802177e <dev_cfg>:
; {
 802177e: b480         	push	{r7}
 8021780: b083         	sub	sp, #0xc
 8021782: af00         	add	r7, sp, #0x0
 8021784: 6078         	str	r0, [r7, #0x4]
; 	return dev->config;
 8021786: 687b         	ldr	r3, [r7, #0x4]
 8021788: 685b         	ldr	r3, [r3, #0x4]
; }
 802178a: 4618         	mov	r0, r3
 802178c: 370c         	adds	r7, #0xc
 802178e: 46bd         	mov	sp, r7
 8021790: f85d 7b04    	ldr	r7, [sp], #4
 8021794: 4770         	bx	lr

08021796 <ws2812_spi_ser>:
; {
 8021796: b480         	push	{r7}
 8021798: b085         	sub	sp, #0x14
 802179a: af00         	add	r7, sp, #0x0
 802179c: 6078         	str	r0, [r7, #0x4]
 802179e: 4608         	mov	r0, r1
 80217a0: 4611         	mov	r1, r2
 80217a2: 461a         	mov	r2, r3
 80217a4: 4603         	mov	r3, r0
 80217a6: 70fb         	strb	r3, [r7, #0x3]
 80217a8: 460b         	mov	r3, r1
 80217aa: 70bb         	strb	r3, [r7, #0x2]
 80217ac: 4613         	mov	r3, r2
 80217ae: 707b         	strb	r3, [r7, #0x1]
; 	for (i = 0; i < 8; i++) {
 80217b0: 2300         	movs	r3, #0x0
 80217b2: 60fb         	str	r3, [r7, #0xc]
 80217b4: e013         	b	0x80217de <ws2812_spi_ser+0x48> @ imm = #0x26
; 		buf[i] = color & BIT(7 - i) ? one_frame : zero_frame;
 80217b6: 78fa         	ldrb	r2, [r7, #0x3]
 80217b8: 68fb         	ldr	r3, [r7, #0xc]
 80217ba: f1c3 0307    	rsb.w	r3, r3, #0x7
 80217be: fa22 f303    	lsr.w	r3, r2, r3
 80217c2: f003 0301    	and	r3, r3, #0x1
 80217c6: 2b00         	cmp	r3, #0x0
 80217c8: d001         	beq	0x80217ce <ws2812_spi_ser+0x38> @ imm = #0x2
 80217ca: 78bb         	ldrb	r3, [r7, #0x2]
 80217cc: e000         	b	0x80217d0 <ws2812_spi_ser+0x3a> @ imm = #0x0
 80217ce: 787b         	ldrb	r3, [r7, #0x1]
 80217d0: 68fa         	ldr	r2, [r7, #0xc]
 80217d2: 6879         	ldr	r1, [r7, #0x4]
 80217d4: 440a         	add	r2, r1
 80217d6: 7013         	strb	r3, [r2]
; 	for (i = 0; i < 8; i++) {
 80217d8: 68fb         	ldr	r3, [r7, #0xc]
 80217da: 3301         	adds	r3, #0x1
 80217dc: 60fb         	str	r3, [r7, #0xc]
 80217de: 68fb         	ldr	r3, [r7, #0xc]
 80217e0: 2b07         	cmp	r3, #0x7
 80217e2: dde8         	ble	0x80217b6 <ws2812_spi_ser+0x20> @ imm = #-0x30
; }
 80217e4: bf00         	nop
 80217e6: bf00         	nop
 80217e8: 3714         	adds	r7, #0x14
 80217ea: 46bd         	mov	sp, r7
 80217ec: f85d 7b04    	ldr	r7, [sp], #4
 80217f0: 4770         	bx	lr

080217f2 <ws2812_reset_delay>:
; {
 80217f2: b580         	push	{r7, lr}
 80217f4: b082         	sub	sp, #0x8
 80217f6: af00         	add	r7, sp, #0x0
 80217f8: 4603         	mov	r3, r0
 80217fa: 80fb         	strh	r3, [r7, #0x6]
; 	k_usleep(delay);
 80217fc: 88fb         	ldrh	r3, [r7, #0x6]
 80217fe: 4618         	mov	r0, r3
 8021800: f7ff ff0f    	bl	0x8021622 <k_usleep>    @ imm = #-0x1e2
; }
 8021804: bf00         	nop
 8021806: 3708         	adds	r7, #0x8
 8021808: 46bd         	mov	sp, r7
 802180a: bd80         	pop	{r7, pc}

0802180c <ws2812_strip_length>:
; {
 802180c: b580         	push	{r7, lr}
 802180e: b084         	sub	sp, #0x10
 8021810: af00         	add	r7, sp, #0x0
 8021812: 6078         	str	r0, [r7, #0x4]
; 	const struct ws2812_spi_cfg *cfg = dev_cfg(dev);
 8021814: 6878         	ldr	r0, [r7, #0x4]
 8021816: f7ff ffb2    	bl	0x802177e <dev_cfg>     @ imm = #-0x9c
 802181a: 60f8         	str	r0, [r7, #0xc]
; 	return cfg->length;
 802181c: 68fb         	ldr	r3, [r7, #0xc]
 802181e: 6a5b         	ldr	r3, [r3, #0x24]
; }
 8021820: 4618         	mov	r0, r3
 8021822: 3710         	adds	r7, #0x10
 8021824: 46bd         	mov	sp, r7
 8021826: bd80         	pop	{r7, pc}

08021828 <pinctrl_lookup_state>:
; {
 8021828: b480         	push	{r7}
 802182a: b085         	sub	sp, #0x14
 802182c: af00         	add	r7, sp, #0x0
 802182e: 60f8         	str	r0, [r7, #0xc]
 8021830: 460b         	mov	r3, r1
 8021832: 607a         	str	r2, [r7, #0x4]
 8021834: 72fb         	strb	r3, [r7, #0xb]
; 	*state = &config->states[0];
 8021836: 68fb         	ldr	r3, [r7, #0xc]
 8021838: 681a         	ldr	r2, [r3]
 802183a: 687b         	ldr	r3, [r7, #0x4]
 802183c: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 802183e: e00d         	b	0x802185c <pinctrl_lookup_state+0x34> @ imm = #0x1a
; 		if (id == (*state)->id) {
 8021840: 687b         	ldr	r3, [r7, #0x4]
 8021842: 681b         	ldr	r3, [r3]
 8021844: 795b         	ldrb	r3, [r3, #0x5]
 8021846: 7afa         	ldrb	r2, [r7, #0xb]
 8021848: 429a         	cmp	r2, r3
 802184a: d101         	bne	0x8021850 <pinctrl_lookup_state+0x28> @ imm = #0x2
; 			return 0;
 802184c: 2300         	movs	r3, #0x0
 802184e: e011         	b	0x8021874 <pinctrl_lookup_state+0x4c> @ imm = #0x22
; 		(*state)++;
 8021850: 687b         	ldr	r3, [r7, #0x4]
 8021852: 681b         	ldr	r3, [r3]
 8021854: f103 0208    	add.w	r2, r3, #0x8
 8021858: 687b         	ldr	r3, [r7, #0x4]
 802185a: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 802185c: 687b         	ldr	r3, [r7, #0x4]
 802185e: 681a         	ldr	r2, [r3]
 8021860: 68fb         	ldr	r3, [r7, #0xc]
 8021862: 6819         	ldr	r1, [r3]
 8021864: 68fb         	ldr	r3, [r7, #0xc]
 8021866: 791b         	ldrb	r3, [r3, #0x4]
 8021868: 00db         	lsls	r3, r3, #0x3
 802186a: 440b         	add	r3, r1
 802186c: 429a         	cmp	r2, r3
 802186e: d3e7         	blo	0x8021840 <pinctrl_lookup_state+0x18> @ imm = #-0x32
; 	return -ENOENT;
 8021870: f06f 0301    	mvn	r3, #0x1
; }
 8021874: 4618         	mov	r0, r3
 8021876: 3714         	adds	r7, #0x14
 8021878: 46bd         	mov	sp, r7
 802187a: f85d 7b04    	ldr	r7, [sp], #4
 802187e: 4770         	bx	lr

08021880 <device_is_ready>:
; {
 8021880: b580         	push	{r7, lr}
 8021882: b082         	sub	sp, #0x8
 8021884: af00         	add	r7, sp, #0x0
 8021886: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8021888: 6878         	ldr	r0, [r7, #0x4]
 802188a: f004 fd88    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x4b10
 802188e: 4603         	mov	r3, r0
; }
 8021890: 4618         	mov	r0, r3
 8021892: 3708         	adds	r7, #0x8
 8021894: 46bd         	mov	sp, r7
 8021896: bd80         	pop	{r7, pc}

08021898 <pinctrl_configure_pins>:
; {
 8021898: b580         	push	{r7, lr}
 802189a: b08a         	sub	sp, #0x28
 802189c: af00         	add	r7, sp, #0x0
 802189e: 60f8         	str	r0, [r7, #0xc]
 80218a0: 460b         	mov	r3, r1
 80218a2: 607a         	str	r2, [r7, #0x4]
 80218a4: 72fb         	strb	r3, [r7, #0xb]
; 	uint32_t pin_cgf = 0;
 80218a6: 2300         	movs	r3, #0x0
 80218a8: 627b         	str	r3, [r7, #0x24]
; 	int ret = 0;
 80218aa: 2300         	movs	r3, #0x0
 80218ac: 61fb         	str	r3, [r7, #0x1c]
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 80218ae: 2300         	movs	r3, #0x0
 80218b0: f887 3023    	strb.w	r3, [r7, #0x23]
 80218b4: e047         	b	0x8021946 <pinctrl_configure_pins+0xae> @ imm = #0x8e
; 		mux = pins[i].pinmux;
 80218b6: f897 3023    	ldrb.w	r3, [r7, #0x23]
 80218ba: 00db         	lsls	r3, r3, #0x3
 80218bc: 68fa         	ldr	r2, [r7, #0xc]
 80218be: 4413         	add	r3, r2
 80218c0: 681b         	ldr	r3, [r3]
 80218c2: 61bb         	str	r3, [r7, #0x18]
; 		if (STM32_DT_PINMUX_FUNC(mux) < STM32_ANALOG) {
 80218c4: 69bb         	ldr	r3, [r7, #0x18]
 80218c6: f003 0310    	and	r3, r3, #0x10
 80218ca: 2b00         	cmp	r3, #0x0
 80218cc: d109         	bne	0x80218e2 <pinctrl_configure_pins+0x4a> @ imm = #0x12
; 			pin_cgf = pins[i].pincfg | STM32_MODER_ALT_MODE;
 80218ce: f897 3023    	ldrb.w	r3, [r7, #0x23]
 80218d2: 00db         	lsls	r3, r3, #0x3
 80218d4: 68fa         	ldr	r2, [r7, #0xc]
 80218d6: 4413         	add	r3, r2
 80218d8: 685b         	ldr	r3, [r3, #0x4]
 80218da: f043 0320    	orr	r3, r3, #0x20
 80218de: 627b         	str	r3, [r7, #0x24]
 80218e0: e013         	b	0x802190a <pinctrl_configure_pins+0x72> @ imm = #0x26
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_ANALOG) {
 80218e2: 69bb         	ldr	r3, [r7, #0x18]
 80218e4: f003 031f    	and	r3, r3, #0x1f
 80218e8: 2b10         	cmp	r3, #0x10
 80218ea: d102         	bne	0x80218f2 <pinctrl_configure_pins+0x5a> @ imm = #0x4
; 			pin_cgf = STM32_MODER_ANALOG_MODE;
 80218ec: 2330         	movs	r3, #0x30
 80218ee: 627b         	str	r3, [r7, #0x24]
 80218f0: e00b         	b	0x802190a <pinctrl_configure_pins+0x72> @ imm = #0x16
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_GPIO) {
 80218f2: 69bb         	ldr	r3, [r7, #0x18]
 80218f4: f003 031f    	and	r3, r3, #0x1f
 80218f8: 2b11         	cmp	r3, #0x11
 80218fa: d106         	bne	0x802190a <pinctrl_configure_pins+0x72> @ imm = #0xc
; 			pin_cgf = pins[i].pincfg;
 80218fc: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8021900: 00db         	lsls	r3, r3, #0x3
 8021902: 68fa         	ldr	r2, [r7, #0xc]
 8021904: 4413         	add	r3, r2
 8021906: 685b         	ldr	r3, [r3, #0x4]
 8021908: 627b         	str	r3, [r7, #0x24]
; 		pin = STM32PIN(STM32_DT_PINMUX_PORT(mux),
 802190a: 69bb         	ldr	r3, [r7, #0x18]
 802190c: 0a5b         	lsrs	r3, r3, #0x9
 802190e: 011b         	lsls	r3, r3, #0x4
 8021910: f403 72f8    	and	r2, r3, #0x1f0
 8021914: 69bb         	ldr	r3, [r7, #0x18]
 8021916: 095b         	lsrs	r3, r3, #0x5
 8021918: f003 030f    	and	r3, r3, #0xf
 802191c: 4313         	orrs	r3, r2
 802191e: 617b         	str	r3, [r7, #0x14]
; 		ret = stm32_pin_configure(pin, pin_cgf, STM32_DT_PINMUX_FUNC(mux));
 8021920: 69bb         	ldr	r3, [r7, #0x18]
 8021922: f003 031f    	and	r3, r3, #0x1f
 8021926: 461a         	mov	r2, r3
 8021928: 6a79         	ldr	r1, [r7, #0x24]
 802192a: 6978         	ldr	r0, [r7, #0x14]
 802192c: f7eb fd68    	bl	0x800d400 <stm32_pin_configure> @ imm = #-0x14530
 8021930: 61f8         	str	r0, [r7, #0x1c]
; 		if (ret < 0) {
 8021932: 69fb         	ldr	r3, [r7, #0x1c]
 8021934: 2b00         	cmp	r3, #0x0
 8021936: da01         	bge	0x802193c <pinctrl_configure_pins+0xa4> @ imm = #0x2
; 			return ret;
 8021938: 69fb         	ldr	r3, [r7, #0x1c]
 802193a: e00a         	b	0x8021952 <pinctrl_configure_pins+0xba> @ imm = #0x14
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 802193c: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8021940: 3301         	adds	r3, #0x1
 8021942: f887 3023    	strb.w	r3, [r7, #0x23]
 8021946: f897 2023    	ldrb.w	r2, [r7, #0x23]
 802194a: 7afb         	ldrb	r3, [r7, #0xb]
 802194c: 429a         	cmp	r2, r3
 802194e: d3b2         	blo	0x80218b6 <pinctrl_configure_pins+0x1e> @ imm = #-0x9c
; 	return 0;
 8021950: 2300         	movs	r3, #0x0
; }
 8021952: 4618         	mov	r0, r3
 8021954: 3728         	adds	r7, #0x28
 8021956: 46bd         	mov	sp, r7
 8021958: bd80         	pop	{r7, pc}

0802195a <reset_stm32_status>:
; {
 802195a: b480         	push	{r7}
 802195c: b089         	sub	sp, #0x24
 802195e: af00         	add	r7, sp, #0x0
 8021960: 60f8         	str	r0, [r7, #0xc]
 8021962: 60b9         	str	r1, [r7, #0x8]
 8021964: 607a         	str	r2, [r7, #0x4]
; 	const struct reset_stm32_config *config = dev->config;
 8021966: 68fb         	ldr	r3, [r7, #0xc]
 8021968: 685b         	ldr	r3, [r3, #0x4]
 802196a: 61fb         	str	r3, [r7, #0x1c]
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 802196c: 69fb         	ldr	r3, [r7, #0x1c]
 802196e: 681a         	ldr	r2, [r3]
 8021970: 68bb         	ldr	r3, [r7, #0x8]
 8021972: 095b         	lsrs	r3, r3, #0x5
 8021974: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8021978: 441a         	add	r2, r3
 802197a: 68bb         	ldr	r3, [r7, #0x8]
 802197c: f003 031f    	and	r3, r3, #0x1f
 8021980: 61ba         	str	r2, [r7, #0x18]
 8021982: 617b         	str	r3, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8021984: 69bb         	ldr	r3, [r7, #0x18]
 8021986: 681b         	ldr	r3, [r3]
 8021988: 613b         	str	r3, [r7, #0x10]
; 	return temp & (1 << bit);
 802198a: 2201         	movs	r2, #0x1
 802198c: 697b         	ldr	r3, [r7, #0x14]
 802198e: fa02 f303    	lsl.w	r3, r2, r3
 8021992: 461a         	mov	r2, r3
 8021994: 693b         	ldr	r3, [r7, #0x10]
 8021996: 4013         	ands	r3, r2
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8021998: 2b00         	cmp	r3, #0x0
 802199a: bf14         	ite	ne
 802199c: 2301         	movne	r3, #0x1
 802199e: 2300         	moveq	r3, #0x0
 80219a0: b2db         	uxtb	r3, r3
 80219a2: 461a         	mov	r2, r3
 80219a4: 687b         	ldr	r3, [r7, #0x4]
 80219a6: 701a         	strb	r2, [r3]
; 	return 0;
 80219a8: 2300         	movs	r3, #0x0
; }
 80219aa: 4618         	mov	r0, r3
 80219ac: 3724         	adds	r7, #0x24
 80219ae: 46bd         	mov	sp, r7
 80219b0: f85d 7b04    	ldr	r7, [sp], #4
 80219b4: 4770         	bx	lr

080219b6 <reset_stm32_line_assert>:
; {
 80219b6: b480         	push	{r7}
 80219b8: b087         	sub	sp, #0x1c
 80219ba: af00         	add	r7, sp, #0x0
 80219bc: 6078         	str	r0, [r7, #0x4]
 80219be: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 80219c0: 687b         	ldr	r3, [r7, #0x4]
 80219c2: 685b         	ldr	r3, [r3, #0x4]
 80219c4: 617b         	str	r3, [r7, #0x14]
; 	sys_set_bit(config->base + STM32_RESET_SET_OFFSET(id),
 80219c6: 697b         	ldr	r3, [r7, #0x14]
 80219c8: 681a         	ldr	r2, [r3]
 80219ca: 683b         	ldr	r3, [r7]
 80219cc: 095b         	lsrs	r3, r3, #0x5
 80219ce: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 80219d2: 441a         	add	r2, r3
 80219d4: 683b         	ldr	r3, [r7]
 80219d6: f003 031f    	and	r3, r3, #0x1f
 80219da: 613a         	str	r2, [r7, #0x10]
 80219dc: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 80219de: 693b         	ldr	r3, [r7, #0x10]
 80219e0: 681b         	ldr	r3, [r3]
 80219e2: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp | (1 << bit);
 80219e4: 2201         	movs	r2, #0x1
 80219e6: 68fb         	ldr	r3, [r7, #0xc]
 80219e8: fa02 f303    	lsl.w	r3, r2, r3
 80219ec: 4619         	mov	r1, r3
 80219ee: 693b         	ldr	r3, [r7, #0x10]
 80219f0: 68ba         	ldr	r2, [r7, #0x8]
 80219f2: 430a         	orrs	r2, r1
 80219f4: 601a         	str	r2, [r3]
; }
 80219f6: bf00         	nop
; 	return 0;
 80219f8: 2300         	movs	r3, #0x0
; }
 80219fa: 4618         	mov	r0, r3
 80219fc: 371c         	adds	r7, #0x1c
 80219fe: 46bd         	mov	sp, r7
 8021a00: f85d 7b04    	ldr	r7, [sp], #4
 8021a04: 4770         	bx	lr

08021a06 <reset_stm32_line_deassert>:
; {
 8021a06: b480         	push	{r7}
 8021a08: b087         	sub	sp, #0x1c
 8021a0a: af00         	add	r7, sp, #0x0
 8021a0c: 6078         	str	r0, [r7, #0x4]
 8021a0e: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 8021a10: 687b         	ldr	r3, [r7, #0x4]
 8021a12: 685b         	ldr	r3, [r3, #0x4]
 8021a14: 617b         	str	r3, [r7, #0x14]
; 	sys_clear_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8021a16: 697b         	ldr	r3, [r7, #0x14]
 8021a18: 681a         	ldr	r2, [r3]
 8021a1a: 683b         	ldr	r3, [r7]
 8021a1c: 095b         	lsrs	r3, r3, #0x5
 8021a1e: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8021a22: 441a         	add	r2, r3
 8021a24: 683b         	ldr	r3, [r7]
 8021a26: f003 031f    	and	r3, r3, #0x1f
 8021a2a: 613a         	str	r2, [r7, #0x10]
 8021a2c: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8021a2e: 693b         	ldr	r3, [r7, #0x10]
 8021a30: 681b         	ldr	r3, [r3]
 8021a32: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~(1 << bit);
 8021a34: 2201         	movs	r2, #0x1
 8021a36: 68fb         	ldr	r3, [r7, #0xc]
 8021a38: fa02 f303    	lsl.w	r3, r2, r3
 8021a3c: 43db         	mvns	r3, r3
 8021a3e: 4619         	mov	r1, r3
 8021a40: 693b         	ldr	r3, [r7, #0x10]
 8021a42: 68ba         	ldr	r2, [r7, #0x8]
 8021a44: 400a         	ands	r2, r1
 8021a46: 601a         	str	r2, [r3]
; }
 8021a48: bf00         	nop
; 	return 0;
 8021a4a: 2300         	movs	r3, #0x0
; }
 8021a4c: 4618         	mov	r0, r3
 8021a4e: 371c         	adds	r7, #0x1c
 8021a50: 46bd         	mov	sp, r7
 8021a52: f85d 7b04    	ldr	r7, [sp], #4
 8021a56: 4770         	bx	lr

08021a58 <reset_stm32_line_toggle>:
; {
 8021a58: b580         	push	{r7, lr}
 8021a5a: b082         	sub	sp, #0x8
 8021a5c: af00         	add	r7, sp, #0x0
 8021a5e: 6078         	str	r0, [r7, #0x4]
 8021a60: 6039         	str	r1, [r7]
; 	reset_stm32_line_assert(dev, id);
 8021a62: 6839         	ldr	r1, [r7]
 8021a64: 6878         	ldr	r0, [r7, #0x4]
 8021a66: f7ff ffa6    	bl	0x80219b6 <reset_stm32_line_assert> @ imm = #-0xb4
; 	reset_stm32_line_deassert(dev, id);
 8021a6a: 6839         	ldr	r1, [r7]
 8021a6c: 6878         	ldr	r0, [r7, #0x4]
 8021a6e: f7ff ffca    	bl	0x8021a06 <reset_stm32_line_deassert> @ imm = #-0x6c
; 	return 0;
 8021a72: 2300         	movs	r3, #0x0
; }
 8021a74: 4618         	mov	r0, r3
 8021a76: 3708         	adds	r7, #0x8
 8021a78: 46bd         	mov	sp, r7
 8021a7a: bd80         	pop	{r7, pc}

08021a7c <device_is_ready>:
; {
 8021a7c: b580         	push	{r7, lr}
 8021a7e: b082         	sub	sp, #0x8
 8021a80: af00         	add	r7, sp, #0x0
 8021a82: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8021a84: 6878         	ldr	r0, [r7, #0x4]
 8021a86: f004 fc8a    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x4914
 8021a8a: 4603         	mov	r3, r0
; }
 8021a8c: 4618         	mov	r0, r3
 8021a8e: 3708         	adds	r7, #0x8
 8021a90: 46bd         	mov	sp, r7
 8021a92: bd80         	pop	{r7, pc}

08021a94 <k_msleep>:
; {
 8021a94: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8021a98: b082         	sub	sp, #0x8
 8021a9a: af00         	add	r7, sp, #0x0
 8021a9c: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 8021a9e: 6879         	ldr	r1, [r7, #0x4]
 8021aa0: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 8021aa4: 17c8         	asrs	r0, r1, #0x1f
 8021aa6: 4688         	mov	r8, r1
 8021aa8: 4681         	mov	r9, r0
 8021aaa: 4640         	mov	r0, r8
 8021aac: 4649         	mov	r1, r9
 8021aae: f04f 0400    	mov.w	r4, #0x0
 8021ab2: f04f 0500    	mov.w	r5, #0x0
 8021ab6: 008d         	lsls	r5, r1, #0x2
 8021ab8: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 8021abc: 0084         	lsls	r4, r0, #0x2
 8021abe: 4620         	mov	r0, r4
 8021ac0: 4629         	mov	r1, r5
 8021ac2: eb10 0208    	adds.w	r2, r0, r8
 8021ac6: eb41 0309    	adc.w	r3, r1, r9
 8021aca: eb12 0a02    	adds.w	r10, r2, r2
 8021ace: eb43 0b03    	adc.w	r11, r3, r3
 8021ad2: 4652         	mov	r2, r10
 8021ad4: 465b         	mov	r3, r11
 8021ad6: 4610         	mov	r0, r2
 8021ad8: 4619         	mov	r1, r3
 8021ada: f000 f807    	bl	0x8021aec <k_sleep>     @ imm = #0xe
 8021ade: 4601         	mov	r1, r0
 8021ae0: 460b         	mov	r3, r1
; }
 8021ae2: 4618         	mov	r0, r3
 8021ae4: 3708         	adds	r7, #0x8
 8021ae6: 46bd         	mov	sp, r7
 8021ae8: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08021aec <k_sleep>:
; {
 8021aec: b580         	push	{r7, lr}
 8021aee: b082         	sub	sp, #0x8
 8021af0: af00         	add	r7, sp, #0x0
 8021af2: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8021af6: e9d7 0100    	ldrd	r0, r1, [r7]
 8021afa: f7f5 fe37    	bl	0x801776c <z_impl_k_sleep> @ imm = #-0xa392
 8021afe: 4603         	mov	r3, r0
; }
 8021b00: 4618         	mov	r0, r3
 8021b02: 3708         	adds	r7, #0x8
 8021b04: 46bd         	mov	sp, r7
 8021b06: bd80         	pop	{r7, pc}

08021b08 <k_usleep>:
; {
 8021b08: b580         	push	{r7, lr}
 8021b0a: b082         	sub	sp, #0x8
 8021b0c: af00         	add	r7, sp, #0x0
 8021b0e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_usleep(us);
 8021b10: 6878         	ldr	r0, [r7, #0x4]
 8021b12: f006 ffa6    	bl	0x8028a62 <z_impl_k_usleep> @ imm = #0x6f4c
 8021b16: 4603         	mov	r3, r0
; }
 8021b18: 4618         	mov	r0, r3
 8021b1a: 3708         	adds	r7, #0x8
 8021b1c: 46bd         	mov	sp, r7
 8021b1e: bd80         	pop	{r7, pc}

08021b20 <pm_device_busy_set>:
; {
 8021b20: b480         	push	{r7}
 8021b22: b083         	sub	sp, #0xc
 8021b24: af00         	add	r7, sp, #0x0
 8021b26: 6078         	str	r0, [r7, #0x4]
; }
 8021b28: bf00         	nop
 8021b2a: 370c         	adds	r7, #0xc
 8021b2c: 46bd         	mov	sp, r7
 8021b2e: f85d 7b04    	ldr	r7, [sp], #4
 8021b32: 4770         	bx	lr

08021b34 <pm_device_busy_clear>:
; {
 8021b34: b480         	push	{r7}
 8021b36: b083         	sub	sp, #0xc
 8021b38: af00         	add	r7, sp, #0x0
 8021b3a: 6078         	str	r0, [r7, #0x4]
; }
 8021b3c: bf00         	nop
 8021b3e: 370c         	adds	r7, #0xc
 8021b40: 46bd         	mov	sp, r7
 8021b42: f85d 7b04    	ldr	r7, [sp], #4
 8021b46: 4770         	bx	lr

08021b48 <z_log_msg_runtime_create>:
; {
 8021b48: b580         	push	{r7, lr}
 8021b4a: b08a         	sub	sp, #0x28
 8021b4c: af04         	add	r7, sp, #0x10
 8021b4e: 60b9         	str	r1, [r7, #0x8]
 8021b50: 607b         	str	r3, [r7, #0x4]
 8021b52: 4603         	mov	r3, r0
 8021b54: 73fb         	strb	r3, [r7, #0xf]
 8021b56: 4613         	mov	r3, r2
 8021b58: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8021b5a: f107 032c    	add.w	r3, r7, #0x2c
 8021b5e: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8021b60: 7bba         	ldrb	r2, [r7, #0xe]
 8021b62: 7bf8         	ldrb	r0, [r7, #0xf]
 8021b64: 697b         	ldr	r3, [r7, #0x14]
 8021b66: 9303         	str	r3, [sp, #0xc]
 8021b68: 6abb         	ldr	r3, [r7, #0x28]
 8021b6a: 9302         	str	r3, [sp, #0x8]
 8021b6c: 6a7b         	ldr	r3, [r7, #0x24]
 8021b6e: 9301         	str	r3, [sp, #0x4]
 8021b70: 6a3b         	ldr	r3, [r7, #0x20]
 8021b72: 9300         	str	r3, [sp]
 8021b74: 687b         	ldr	r3, [r7, #0x4]
 8021b76: 68b9         	ldr	r1, [r7, #0x8]
 8021b78: f7e2 fffc    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1d008
; }
 8021b7c: bf00         	nop
 8021b7e: 3718         	adds	r7, #0x18
 8021b80: 46bd         	mov	sp, r7
 8021b82: bd80         	pop	{r7, pc}

08021b84 <gpio_is_ready_dt>:
; {
 8021b84: b580         	push	{r7, lr}
 8021b86: b082         	sub	sp, #0x8
 8021b88: af00         	add	r7, sp, #0x0
 8021b8a: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 8021b8c: 687b         	ldr	r3, [r7, #0x4]
 8021b8e: 681b         	ldr	r3, [r3]
 8021b90: 4618         	mov	r0, r3
 8021b92: f7ff ff73    	bl	0x8021a7c <device_is_ready> @ imm = #-0x11a
 8021b96: 4603         	mov	r3, r0
; }
 8021b98: 4618         	mov	r0, r3
 8021b9a: 3708         	adds	r7, #0x8
 8021b9c: 46bd         	mov	sp, r7
 8021b9e: bd80         	pop	{r7, pc}

08021ba0 <spi_cs_is_gpio>:
; {
 8021ba0: b480         	push	{r7}
 8021ba2: b083         	sub	sp, #0xc
 8021ba4: af00         	add	r7, sp, #0x0
 8021ba6: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 8021ba8: 687b         	ldr	r3, [r7, #0x4]
 8021baa: 689b         	ldr	r3, [r3, #0x8]
 8021bac: 2b00         	cmp	r3, #0x0
 8021bae: bf14         	ite	ne
 8021bb0: 2301         	movne	r3, #0x1
 8021bb2: 2300         	moveq	r3, #0x0
 8021bb4: b2db         	uxtb	r3, r3
; }
 8021bb6: 4618         	mov	r0, r3
 8021bb8: 370c         	adds	r7, #0xc
 8021bba: 46bd         	mov	sp, r7
 8021bbc: f85d 7b04    	ldr	r7, [sp], #4
 8021bc0: 4770         	bx	lr

08021bc2 <spi_cs_is_gpio_dt>:
; {
 8021bc2: b580         	push	{r7, lr}
 8021bc4: b082         	sub	sp, #0x8
 8021bc6: af00         	add	r7, sp, #0x0
 8021bc8: 6078         	str	r0, [r7, #0x4]
; 	return spi_cs_is_gpio(&spec->config);
 8021bca: 687b         	ldr	r3, [r7, #0x4]
 8021bcc: 3304         	adds	r3, #0x4
 8021bce: 4618         	mov	r0, r3
 8021bd0: f7ff ffe6    	bl	0x8021ba0 <spi_cs_is_gpio> @ imm = #-0x34
 8021bd4: 4603         	mov	r3, r0
; }
 8021bd6: 4618         	mov	r0, r3
 8021bd8: 3708         	adds	r7, #0x8
 8021bda: 46bd         	mov	sp, r7
 8021bdc: bd80         	pop	{r7, pc}

08021bde <spi_is_ready_dt>:
; {
 8021bde: b580         	push	{r7, lr}
 8021be0: b082         	sub	sp, #0x8
 8021be2: af00         	add	r7, sp, #0x0
 8021be4: 6078         	str	r0, [r7, #0x4]
; 	if (!device_is_ready(spec->bus)) {
 8021be6: 687b         	ldr	r3, [r7, #0x4]
 8021be8: 681b         	ldr	r3, [r3]
 8021bea: 4618         	mov	r0, r3
 8021bec: f7ff ff46    	bl	0x8021a7c <device_is_ready> @ imm = #-0x174
 8021bf0: 4603         	mov	r3, r0
 8021bf2: f083 0301    	eor	r3, r3, #0x1
 8021bf6: b2db         	uxtb	r3, r3
 8021bf8: 2b00         	cmp	r3, #0x0
 8021bfa: d001         	beq	0x8021c00 <spi_is_ready_dt+0x22> @ imm = #0x2
; 		return false;
 8021bfc: 2300         	movs	r3, #0x0
 8021bfe: e013         	b	0x8021c28 <spi_is_ready_dt+0x4a> @ imm = #0x26
; 	if (spi_cs_is_gpio_dt(spec) &&
 8021c00: 6878         	ldr	r0, [r7, #0x4]
 8021c02: f7ff ffde    	bl	0x8021bc2 <spi_cs_is_gpio_dt> @ imm = #-0x44
 8021c06: 4603         	mov	r3, r0
 8021c08: 2b00         	cmp	r3, #0x0
 8021c0a: d00c         	beq	0x8021c26 <spi_is_ready_dt+0x48> @ imm = #0x18
; 	    !gpio_is_ready_dt(&spec->config.cs.gpio)) {
 8021c0c: 687b         	ldr	r3, [r7, #0x4]
 8021c0e: 330c         	adds	r3, #0xc
 8021c10: 4618         	mov	r0, r3
 8021c12: f7ff ffb7    	bl	0x8021b84 <gpio_is_ready_dt> @ imm = #-0x92
 8021c16: 4603         	mov	r3, r0
 8021c18: f083 0301    	eor	r3, r3, #0x1
 8021c1c: b2db         	uxtb	r3, r3
; 	if (spi_cs_is_gpio_dt(spec) &&
 8021c1e: 2b00         	cmp	r3, #0x0
 8021c20: d001         	beq	0x8021c26 <spi_is_ready_dt+0x48> @ imm = #0x2
; 		return false;
 8021c22: 2300         	movs	r3, #0x0
 8021c24: e000         	b	0x8021c28 <spi_is_ready_dt+0x4a> @ imm = #0x0
; 	return true;
 8021c26: 2301         	movs	r3, #0x1
; }
 8021c28: 4618         	mov	r0, r3
 8021c2a: 3708         	adds	r7, #0x8
 8021c2c: 46bd         	mov	sp, r7
 8021c2e: bd80         	pop	{r7, pc}

08021c30 <z_impl_spi_transceive>:
; {
 8021c30: b590         	push	{r4, r7, lr}
 8021c32: b087         	sub	sp, #0x1c
 8021c34: af00         	add	r7, sp, #0x0
 8021c36: 60f8         	str	r0, [r7, #0xc]
 8021c38: 60b9         	str	r1, [r7, #0x8]
 8021c3a: 607a         	str	r2, [r7, #0x4]
 8021c3c: 603b         	str	r3, [r7]
; 	const struct spi_driver_api *api =
 8021c3e: 68fb         	ldr	r3, [r7, #0xc]
 8021c40: 689b         	ldr	r3, [r3, #0x8]
 8021c42: 617b         	str	r3, [r7, #0x14]
; 	ret = api->transceive(dev, config, tx_bufs, rx_bufs);
 8021c44: 697b         	ldr	r3, [r7, #0x14]
 8021c46: 681c         	ldr	r4, [r3]
 8021c48: 683b         	ldr	r3, [r7]
 8021c4a: 687a         	ldr	r2, [r7, #0x4]
 8021c4c: 68b9         	ldr	r1, [r7, #0x8]
 8021c4e: 68f8         	ldr	r0, [r7, #0xc]
 8021c50: 47a0         	blx	r4
 8021c52: 6138         	str	r0, [r7, #0x10]
; 	return ret;
 8021c54: 693b         	ldr	r3, [r7, #0x10]
; }
 8021c56: 4618         	mov	r0, r3
 8021c58: 371c         	adds	r7, #0x1c
 8021c5a: 46bd         	mov	sp, r7
 8021c5c: bd90         	pop	{r4, r7, pc}

08021c5e <spi_transceive_dt>:
; {
 8021c5e: b580         	push	{r7, lr}
 8021c60: b084         	sub	sp, #0x10
 8021c62: af00         	add	r7, sp, #0x0
 8021c64: 60f8         	str	r0, [r7, #0xc]
 8021c66: 60b9         	str	r1, [r7, #0x8]
 8021c68: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(spec->bus, &spec->config, tx_bufs, rx_bufs);
 8021c6a: 68fb         	ldr	r3, [r7, #0xc]
 8021c6c: 6818         	ldr	r0, [r3]
 8021c6e: 68fb         	ldr	r3, [r7, #0xc]
 8021c70: 1d19         	adds	r1, r3, #0x4
 8021c72: 687b         	ldr	r3, [r7, #0x4]
 8021c74: 68ba         	ldr	r2, [r7, #0x8]
 8021c76: f000 f828    	bl	0x8021cca <spi_transceive> @ imm = #0x50
 8021c7a: 4603         	mov	r3, r0
; }
 8021c7c: 4618         	mov	r0, r3
 8021c7e: 3710         	adds	r7, #0x10
 8021c80: 46bd         	mov	sp, r7
 8021c82: bd80         	pop	{r7, pc}

08021c84 <spi_write>:
; {
 8021c84: b580         	push	{r7, lr}
 8021c86: b084         	sub	sp, #0x10
 8021c88: af00         	add	r7, sp, #0x0
 8021c8a: 60f8         	str	r0, [r7, #0xc]
 8021c8c: 60b9         	str	r1, [r7, #0x8]
 8021c8e: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(dev, config, tx_bufs, NULL);
 8021c90: 2300         	movs	r3, #0x0
 8021c92: 687a         	ldr	r2, [r7, #0x4]
 8021c94: 68b9         	ldr	r1, [r7, #0x8]
 8021c96: 68f8         	ldr	r0, [r7, #0xc]
 8021c98: f000 f817    	bl	0x8021cca <spi_transceive> @ imm = #0x2e
 8021c9c: 4603         	mov	r3, r0
; }
 8021c9e: 4618         	mov	r0, r3
 8021ca0: 3710         	adds	r7, #0x10
 8021ca2: 46bd         	mov	sp, r7
 8021ca4: bd80         	pop	{r7, pc}

08021ca6 <spi_write_dt>:
; {
 8021ca6: b580         	push	{r7, lr}
 8021ca8: b082         	sub	sp, #0x8
 8021caa: af00         	add	r7, sp, #0x0
 8021cac: 6078         	str	r0, [r7, #0x4]
 8021cae: 6039         	str	r1, [r7]
; 	return spi_write(spec->bus, &spec->config, tx_bufs);
 8021cb0: 687b         	ldr	r3, [r7, #0x4]
 8021cb2: 6818         	ldr	r0, [r3]
 8021cb4: 687b         	ldr	r3, [r7, #0x4]
 8021cb6: 3304         	adds	r3, #0x4
 8021cb8: 683a         	ldr	r2, [r7]
 8021cba: 4619         	mov	r1, r3
 8021cbc: f7ff ffe2    	bl	0x8021c84 <spi_write>   @ imm = #-0x3c
 8021cc0: 4603         	mov	r3, r0
; }
 8021cc2: 4618         	mov	r0, r3
 8021cc4: 3708         	adds	r7, #0x8
 8021cc6: 46bd         	mov	sp, r7
 8021cc8: bd80         	pop	{r7, pc}

08021cca <spi_transceive>:
; {
 8021cca: b580         	push	{r7, lr}
 8021ccc: b084         	sub	sp, #0x10
 8021cce: af00         	add	r7, sp, #0x0
 8021cd0: 60f8         	str	r0, [r7, #0xc]
 8021cd2: 60b9         	str	r1, [r7, #0x8]
 8021cd4: 607a         	str	r2, [r7, #0x4]
 8021cd6: 603b         	str	r3, [r7]
; 	return z_impl_spi_transceive(dev, config, tx_bufs, rx_bufs);
 8021cd8: 683b         	ldr	r3, [r7]
 8021cda: 687a         	ldr	r2, [r7, #0x4]
 8021cdc: 68b9         	ldr	r1, [r7, #0x8]
 8021cde: 68f8         	ldr	r0, [r7, #0xc]
 8021ce0: f7ff ffa6    	bl	0x8021c30 <z_impl_spi_transceive> @ imm = #-0xb4
 8021ce4: 4603         	mov	r3, r0
; }
 8021ce6: 4618         	mov	r0, r3
 8021ce8: 3710         	adds	r7, #0x10
 8021cea: 46bd         	mov	sp, r7
 8021cec: bd80         	pop	{r7, pc}

08021cee <bmi08x_accel_transceive_spi>:
; {
 8021cee: b580         	push	{r7, lr}
 8021cf0: b092         	sub	sp, #0x48
 8021cf2: af00         	add	r7, sp, #0x0
 8021cf4: 60f8         	str	r0, [r7, #0xc]
 8021cf6: 607b         	str	r3, [r7, #0x4]
 8021cf8: 460b         	mov	r3, r1
 8021cfa: 72fb         	strb	r3, [r7, #0xb]
 8021cfc: 4613         	mov	r3, r2
 8021cfe: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_accel_config *bmi08x = dev->config;
 8021d00: 68fb         	ldr	r3, [r7, #0xc]
 8021d02: 685b         	ldr	r3, [r3, #0x4]
 8021d04: 647b         	str	r3, [r7, #0x44]
; 	const struct spi_buf tx_buf[2] = {{.buf = &reg, .len = 1}, {.buf = data, .len = length}};
 8021d06: f107 030b    	add.w	r3, r7, #0xb
 8021d0a: 637b         	str	r3, [r7, #0x34]
 8021d0c: 2301         	movs	r3, #0x1
 8021d0e: 63bb         	str	r3, [r7, #0x38]
 8021d10: 687b         	ldr	r3, [r7, #0x4]
 8021d12: 63fb         	str	r3, [r7, #0x3c]
 8021d14: 6d3b         	ldr	r3, [r7, #0x50]
 8021d16: 643b         	str	r3, [r7, #0x40]
; 	const struct spi_buf_set tx = {.buffers = tx_buf, .count = write ? 2 : 1};
 8021d18: f107 0334    	add.w	r3, r7, #0x34
 8021d1c: 62fb         	str	r3, [r7, #0x2c]
 8021d1e: 7abb         	ldrb	r3, [r7, #0xa]
 8021d20: 2b00         	cmp	r3, #0x0
 8021d22: d001         	beq	0x8021d28 <bmi08x_accel_transceive_spi+0x3a> @ imm = #0x2
 8021d24: 2302         	movs	r3, #0x2
 8021d26: e000         	b	0x8021d2a <bmi08x_accel_transceive_spi+0x3c> @ imm = #0x0
 8021d28: 2301         	movs	r3, #0x1
 8021d2a: 633b         	str	r3, [r7, #0x30]
; 	if (!write) {
 8021d2c: 7abb         	ldrb	r3, [r7, #0xa]
 8021d2e: f083 0301    	eor	r3, r3, #0x1
 8021d32: b2db         	uxtb	r3, r3
 8021d34: 2b00         	cmp	r3, #0x0
 8021d36: d017         	beq	0x8021d68 <bmi08x_accel_transceive_spi+0x7a> @ imm = #0x2e
; 		const struct spi_buf rx_buf[2] = {{.buf = &dummy, .len = 2},
 8021d38: f107 032a    	add.w	r3, r7, #0x2a
 8021d3c: 61bb         	str	r3, [r7, #0x18]
 8021d3e: 2302         	movs	r3, #0x2
 8021d40: 61fb         	str	r3, [r7, #0x1c]
 8021d42: 687b         	ldr	r3, [r7, #0x4]
 8021d44: 623b         	str	r3, [r7, #0x20]
 8021d46: 6d3b         	ldr	r3, [r7, #0x50]
 8021d48: 627b         	str	r3, [r7, #0x24]
; 		const struct spi_buf_set rx = {.buffers = rx_buf, .count = 2};
 8021d4a: f107 0318    	add.w	r3, r7, #0x18
 8021d4e: 613b         	str	r3, [r7, #0x10]
 8021d50: 2302         	movs	r3, #0x2
 8021d52: 617b         	str	r3, [r7, #0x14]
; 		return spi_transceive_dt(&bmi08x->bus.spi, &tx, &rx);
 8021d54: 6c7b         	ldr	r3, [r7, #0x44]
 8021d56: f107 0210    	add.w	r2, r7, #0x10
 8021d5a: f107 012c    	add.w	r1, r7, #0x2c
 8021d5e: 4618         	mov	r0, r3
 8021d60: f7ff ff7d    	bl	0x8021c5e <spi_transceive_dt> @ imm = #-0x106
 8021d64: 4603         	mov	r3, r0
 8021d66: e007         	b	0x8021d78 <bmi08x_accel_transceive_spi+0x8a> @ imm = #0xe
; 	return spi_write_dt(&bmi08x->bus.spi, &tx);
 8021d68: 6c7b         	ldr	r3, [r7, #0x44]
 8021d6a: f107 022c    	add.w	r2, r7, #0x2c
 8021d6e: 4611         	mov	r1, r2
 8021d70: 4618         	mov	r0, r3
 8021d72: f7ff ff98    	bl	0x8021ca6 <spi_write_dt> @ imm = #-0xd0
 8021d76: 4603         	mov	r3, r0
; }
 8021d78: 4618         	mov	r0, r3
 8021d7a: 3748         	adds	r7, #0x48
 8021d7c: 46bd         	mov	sp, r7
 8021d7e: bd80         	pop	{r7, pc}

08021d80 <bmi08x_bus_check_spi>:
; {
 8021d80: b580         	push	{r7, lr}
 8021d82: b082         	sub	sp, #0x8
 8021d84: af00         	add	r7, sp, #0x0
 8021d86: 6078         	str	r0, [r7, #0x4]
; 	return spi_is_ready_dt(&bus->spi) ? 0 : -ENODEV;
 8021d88: 687b         	ldr	r3, [r7, #0x4]
 8021d8a: 4618         	mov	r0, r3
 8021d8c: f7ff ff27    	bl	0x8021bde <spi_is_ready_dt> @ imm = #-0x1b2
 8021d90: 4603         	mov	r3, r0
 8021d92: 2b00         	cmp	r3, #0x0
 8021d94: d001         	beq	0x8021d9a <bmi08x_bus_check_spi+0x1a> @ imm = #0x2
 8021d96: 2300         	movs	r3, #0x0
 8021d98: e001         	b	0x8021d9e <bmi08x_bus_check_spi+0x1e> @ imm = #0x2
 8021d9a: f06f 0312    	mvn	r3, #0x12
; }
 8021d9e: 4618         	mov	r0, r3
 8021da0: 3708         	adds	r7, #0x8
 8021da2: 46bd         	mov	sp, r7
 8021da4: bd80         	pop	{r7, pc}

08021da6 <bmi08x_bus_check>:
; {
 8021da6: b580         	push	{r7, lr}
 8021da8: b084         	sub	sp, #0x10
 8021daa: af00         	add	r7, sp, #0x0
 8021dac: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_accel_config *config = dev->config;
 8021dae: 687b         	ldr	r3, [r7, #0x4]
 8021db0: 685b         	ldr	r3, [r3, #0x4]
 8021db2: 60fb         	str	r3, [r7, #0xc]
; 	return config->api->check(&config->bus);
 8021db4: 68fb         	ldr	r3, [r7, #0xc]
 8021db6: 699b         	ldr	r3, [r3, #0x18]
 8021db8: 681b         	ldr	r3, [r3]
 8021dba: 68fa         	ldr	r2, [r7, #0xc]
 8021dbc: 4610         	mov	r0, r2
 8021dbe: 4798         	blx	r3
 8021dc0: 4603         	mov	r3, r0
; }
 8021dc2: 4618         	mov	r0, r3
 8021dc4: 3710         	adds	r7, #0x10
 8021dc6: 46bd         	mov	sp, r7
 8021dc8: bd80         	pop	{r7, pc}

08021dca <bmi08x_bus_init>:
; {
 8021dca: b580         	push	{r7, lr}
 8021dcc: b084         	sub	sp, #0x10
 8021dce: af00         	add	r7, sp, #0x0
 8021dd0: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_accel_config *config = dev->config;
 8021dd2: 687b         	ldr	r3, [r7, #0x4]
 8021dd4: 685b         	ldr	r3, [r3, #0x4]
 8021dd6: 60fb         	str	r3, [r7, #0xc]
; 	if (config->api->bus_init) {
 8021dd8: 68fb         	ldr	r3, [r7, #0xc]
 8021dda: 699b         	ldr	r3, [r3, #0x18]
 8021ddc: 685b         	ldr	r3, [r3, #0x4]
 8021dde: 2b00         	cmp	r3, #0x0
 8021de0: d006         	beq	0x8021df0 <bmi08x_bus_init+0x26> @ imm = #0xc
; 		return config->api->bus_init(dev);
 8021de2: 68fb         	ldr	r3, [r7, #0xc]
 8021de4: 699b         	ldr	r3, [r3, #0x18]
 8021de6: 685b         	ldr	r3, [r3, #0x4]
 8021de8: 6878         	ldr	r0, [r7, #0x4]
 8021dea: 4798         	blx	r3
 8021dec: 4603         	mov	r3, r0
 8021dee: e000         	b	0x8021df2 <bmi08x_bus_init+0x28> @ imm = #0x0
; 	return 0;
 8021df0: 2300         	movs	r3, #0x0
; }
 8021df2: 4618         	mov	r0, r3
 8021df4: 3710         	adds	r7, #0x10
 8021df6: 46bd         	mov	sp, r7
 8021df8: bd80         	pop	{r7, pc}

08021dfa <bmi08x_accel_transceive>:
; {
 8021dfa: b590         	push	{r4, r7, lr}
 8021dfc: b089         	sub	sp, #0x24
 8021dfe: af02         	add	r7, sp, #0x8
 8021e00: 60f8         	str	r0, [r7, #0xc]
 8021e02: 607b         	str	r3, [r7, #0x4]
 8021e04: 460b         	mov	r3, r1
 8021e06: 72fb         	strb	r3, [r7, #0xb]
 8021e08: 4613         	mov	r3, r2
 8021e0a: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_accel_config *config = dev->config;
 8021e0c: 68fb         	ldr	r3, [r7, #0xc]
 8021e0e: 685b         	ldr	r3, [r3, #0x4]
 8021e10: 617b         	str	r3, [r7, #0x14]
; 	return config->api->transceive(dev, reg, write, data, length);
 8021e12: 697b         	ldr	r3, [r7, #0x14]
 8021e14: 699b         	ldr	r3, [r3, #0x18]
 8021e16: 689c         	ldr	r4, [r3, #0x8]
 8021e18: 7aba         	ldrb	r2, [r7, #0xa]
 8021e1a: 7af9         	ldrb	r1, [r7, #0xb]
 8021e1c: 6abb         	ldr	r3, [r7, #0x28]
 8021e1e: 9300         	str	r3, [sp]
 8021e20: 687b         	ldr	r3, [r7, #0x4]
 8021e22: 68f8         	ldr	r0, [r7, #0xc]
 8021e24: 47a0         	blx	r4
 8021e26: 4603         	mov	r3, r0
; }
 8021e28: 4618         	mov	r0, r3
 8021e2a: 371c         	adds	r7, #0x1c
 8021e2c: 46bd         	mov	sp, r7
 8021e2e: bd90         	pop	{r4, r7, pc}

08021e30 <bmi08x_accel_read>:
; {
 8021e30: b580         	push	{r7, lr}
 8021e32: b086         	sub	sp, #0x18
 8021e34: af02         	add	r7, sp, #0x8
 8021e36: 60f8         	str	r0, [r7, #0xc]
 8021e38: 607a         	str	r2, [r7, #0x4]
 8021e3a: 461a         	mov	r2, r3
 8021e3c: 460b         	mov	r3, r1
 8021e3e: 72fb         	strb	r3, [r7, #0xb]
 8021e40: 4613         	mov	r3, r2
 8021e42: 72bb         	strb	r3, [r7, #0xa]
; 	return bmi08x_accel_transceive(dev, reg_addr | BIT(7), false, data, len);
 8021e44: 7afb         	ldrb	r3, [r7, #0xb]
 8021e46: f063 037f    	orn	r3, r3, #0x7f
 8021e4a: b2d9         	uxtb	r1, r3
 8021e4c: 7abb         	ldrb	r3, [r7, #0xa]
 8021e4e: 9300         	str	r3, [sp]
 8021e50: 687b         	ldr	r3, [r7, #0x4]
 8021e52: 2200         	movs	r2, #0x0
 8021e54: 68f8         	ldr	r0, [r7, #0xc]
 8021e56: f7ff ffd0    	bl	0x8021dfa <bmi08x_accel_transceive> @ imm = #-0x60
 8021e5a: 4603         	mov	r3, r0
; }
 8021e5c: 4618         	mov	r0, r3
 8021e5e: 3710         	adds	r7, #0x10
 8021e60: 46bd         	mov	sp, r7
 8021e62: bd80         	pop	{r7, pc}

08021e64 <bmi08x_accel_byte_read>:
; {
 8021e64: b580         	push	{r7, lr}
 8021e66: b086         	sub	sp, #0x18
 8021e68: af02         	add	r7, sp, #0x8
 8021e6a: 60f8         	str	r0, [r7, #0xc]
 8021e6c: 460b         	mov	r3, r1
 8021e6e: 607a         	str	r2, [r7, #0x4]
 8021e70: 72fb         	strb	r3, [r7, #0xb]
; 	return bmi08x_accel_transceive(dev, reg_addr | BIT(7), false, byte, 1);
 8021e72: 7afb         	ldrb	r3, [r7, #0xb]
 8021e74: f063 037f    	orn	r3, r3, #0x7f
 8021e78: b2d9         	uxtb	r1, r3
 8021e7a: 2301         	movs	r3, #0x1
 8021e7c: 9300         	str	r3, [sp]
 8021e7e: 687b         	ldr	r3, [r7, #0x4]
 8021e80: 2200         	movs	r2, #0x0
 8021e82: 68f8         	ldr	r0, [r7, #0xc]
 8021e84: f7ff ffb9    	bl	0x8021dfa <bmi08x_accel_transceive> @ imm = #-0x8e
 8021e88: 4603         	mov	r3, r0
; }
 8021e8a: 4618         	mov	r0, r3
 8021e8c: 3710         	adds	r7, #0x10
 8021e8e: 46bd         	mov	sp, r7
 8021e90: bd80         	pop	{r7, pc}

08021e92 <bmi08x_accel_word_read>:
; {
 8021e92: b580         	push	{r7, lr}
 8021e94: b088         	sub	sp, #0x20
 8021e96: af02         	add	r7, sp, #0x8
 8021e98: 60f8         	str	r0, [r7, #0xc]
 8021e9a: 460b         	mov	r3, r1
 8021e9c: 607a         	str	r2, [r7, #0x4]
 8021e9e: 72fb         	strb	r3, [r7, #0xb]
; 	ret = bmi08x_accel_transceive(dev, reg_addr | BIT(7), false, word, 2);
 8021ea0: 7afb         	ldrb	r3, [r7, #0xb]
 8021ea2: f063 037f    	orn	r3, r3, #0x7f
 8021ea6: b2d9         	uxtb	r1, r3
 8021ea8: 2302         	movs	r3, #0x2
 8021eaa: 9300         	str	r3, [sp]
 8021eac: 687b         	ldr	r3, [r7, #0x4]
 8021eae: 2200         	movs	r2, #0x0
 8021eb0: 68f8         	ldr	r0, [r7, #0xc]
 8021eb2: f7ff ffa2    	bl	0x8021dfa <bmi08x_accel_transceive> @ imm = #-0xbc
 8021eb6: 6178         	str	r0, [r7, #0x14]
; 	if (ret != 0) {
 8021eb8: 697b         	ldr	r3, [r7, #0x14]
 8021eba: 2b00         	cmp	r3, #0x0
 8021ebc: d001         	beq	0x8021ec2 <bmi08x_accel_word_read+0x30> @ imm = #0x2
; 		return ret;
 8021ebe: 697b         	ldr	r3, [r7, #0x14]
 8021ec0: e004         	b	0x8021ecc <bmi08x_accel_word_read+0x3a> @ imm = #0x8
; 	*word = sys_le16_to_cpu(*word);
 8021ec2: 687b         	ldr	r3, [r7, #0x4]
 8021ec4: 881a         	ldrh	r2, [r3]
 8021ec6: 687b         	ldr	r3, [r7, #0x4]
 8021ec8: 801a         	strh	r2, [r3]
; 	return ret;
 8021eca: 697b         	ldr	r3, [r7, #0x14]
; }
 8021ecc: 4618         	mov	r0, r3
 8021ece: 3718         	adds	r7, #0x18
 8021ed0: 46bd         	mov	sp, r7
 8021ed2: bd80         	pop	{r7, pc}

08021ed4 <bmi08x_accel_byte_write>:
; {
 8021ed4: b580         	push	{r7, lr}
 8021ed6: b084         	sub	sp, #0x10
 8021ed8: af02         	add	r7, sp, #0x8
 8021eda: 6078         	str	r0, [r7, #0x4]
 8021edc: 460b         	mov	r3, r1
 8021ede: 70fb         	strb	r3, [r7, #0x3]
 8021ee0: 4613         	mov	r3, r2
 8021ee2: 70bb         	strb	r3, [r7, #0x2]
; 	return bmi08x_accel_transceive(dev, reg_addr & 0x7F, true, &byte, 1);
 8021ee4: 78fb         	ldrb	r3, [r7, #0x3]
 8021ee6: f003 037f    	and	r3, r3, #0x7f
 8021eea: b2d9         	uxtb	r1, r3
 8021eec: 1cbb         	adds	r3, r7, #0x2
 8021eee: 2201         	movs	r2, #0x1
 8021ef0: 9200         	str	r2, [sp]
 8021ef2: 2201         	movs	r2, #0x1
 8021ef4: 6878         	ldr	r0, [r7, #0x4]
 8021ef6: f7ff ff80    	bl	0x8021dfa <bmi08x_accel_transceive> @ imm = #-0x100
 8021efa: 4603         	mov	r3, r0
; }
 8021efc: 4618         	mov	r0, r3
 8021efe: 3708         	adds	r7, #0x8
 8021f00: 46bd         	mov	sp, r7
 8021f02: bd80         	pop	{r7, pc}

08021f04 <bmi08x_accel_reg_field_update>:
; {
 8021f04: b580         	push	{r7, lr}
 8021f06: b084         	sub	sp, #0x10
 8021f08: af00         	add	r7, sp, #0x0
 8021f0a: 6078         	str	r0, [r7, #0x4]
 8021f0c: 4608         	mov	r0, r1
 8021f0e: 4611         	mov	r1, r2
 8021f10: 461a         	mov	r2, r3
 8021f12: 4603         	mov	r3, r0
 8021f14: 70fb         	strb	r3, [r7, #0x3]
 8021f16: 460b         	mov	r3, r1
 8021f18: 70bb         	strb	r3, [r7, #0x2]
 8021f1a: 4613         	mov	r3, r2
 8021f1c: 707b         	strb	r3, [r7, #0x1]
; 	ret = bmi08x_accel_byte_read(dev, reg_addr, &old_val);
 8021f1e: f107 020b    	add.w	r2, r7, #0xb
 8021f22: 78fb         	ldrb	r3, [r7, #0x3]
 8021f24: 4619         	mov	r1, r3
 8021f26: 6878         	ldr	r0, [r7, #0x4]
 8021f28: f7ff ff9c    	bl	0x8021e64 <bmi08x_accel_byte_read> @ imm = #-0xc8
 8021f2c: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8021f2e: 68fb         	ldr	r3, [r7, #0xc]
 8021f30: 2b00         	cmp	r3, #0x0
 8021f32: da01         	bge	0x8021f38 <bmi08x_accel_reg_field_update+0x34> @ imm = #0x2
; 		return ret;
 8021f34: 68fb         	ldr	r3, [r7, #0xc]
 8021f36: e019         	b	0x8021f6c <bmi08x_accel_reg_field_update+0x68> @ imm = #0x32
; 	return bmi08x_accel_byte_write(dev, reg_addr, (old_val & ~mask) | ((val << pos) & mask));
 8021f38: f997 3001    	ldrsb.w	r3, [r7, #0x1]
 8021f3c: 43db         	mvns	r3, r3
 8021f3e: b25a         	sxtb	r2, r3
 8021f40: 7afb         	ldrb	r3, [r7, #0xb]
 8021f42: b25b         	sxtb	r3, r3
 8021f44: 4013         	ands	r3, r2
 8021f46: b25a         	sxtb	r2, r3
 8021f48: 7e39         	ldrb	r1, [r7, #0x18]
 8021f4a: 78bb         	ldrb	r3, [r7, #0x2]
 8021f4c: fa01 f303    	lsl.w	r3, r1, r3
 8021f50: b259         	sxtb	r1, r3
 8021f52: f997 3001    	ldrsb.w	r3, [r7, #0x1]
 8021f56: 400b         	ands	r3, r1
 8021f58: b25b         	sxtb	r3, r3
 8021f5a: 4313         	orrs	r3, r2
 8021f5c: b25b         	sxtb	r3, r3
 8021f5e: b2da         	uxtb	r2, r3
 8021f60: 78fb         	ldrb	r3, [r7, #0x3]
 8021f62: 4619         	mov	r1, r3
 8021f64: 6878         	ldr	r0, [r7, #0x4]
 8021f66: f7ff ffb5    	bl	0x8021ed4 <bmi08x_accel_byte_write> @ imm = #-0x96
 8021f6a: 4603         	mov	r3, r0
; }
 8021f6c: 4618         	mov	r0, r3
 8021f6e: 3710         	adds	r7, #0x10
 8021f70: 46bd         	mov	sp, r7
 8021f72: bd80         	pop	{r7, pc}

08021f74 <bmi08x_acc_odr_set>:
; {
 8021f74: b580         	push	{r7, lr}
 8021f76: b086         	sub	sp, #0x18
 8021f78: af02         	add	r7, sp, #0x8
 8021f7a: 6078         	str	r0, [r7, #0x4]
 8021f7c: 460b         	mov	r3, r1
 8021f7e: 807b         	strh	r3, [r7, #0x2]
 8021f80: 4613         	mov	r3, r2
 8021f82: 803b         	strh	r3, [r7]
; 	int odr = bmi08x_freq_to_odr_val(freq_int, freq_milli);
 8021f84: 883a         	ldrh	r2, [r7]
 8021f86: 887b         	ldrh	r3, [r7, #0x2]
 8021f88: 4611         	mov	r1, r2
 8021f8a: 4618         	mov	r0, r3
 8021f8c: f7ec fab0    	bl	0x800e4f0 <bmi08x_freq_to_odr_val> @ imm = #-0x13aa0
 8021f90: 60f8         	str	r0, [r7, #0xc]
; 	if (odr < BMI08X_ACCEL_ODR_12_5_HZ) {
 8021f92: 68fb         	ldr	r3, [r7, #0xc]
 8021f94: 2b04         	cmp	r3, #0x4
 8021f96: dc01         	bgt	0x8021f9c <bmi08x_acc_odr_set+0x28> @ imm = #0x2
; 		return odr;
 8021f98: 68fb         	ldr	r3, [r7, #0xc]
 8021f9a: e009         	b	0x8021fb0 <bmi08x_acc_odr_set+0x3c> @ imm = #0x12
; 	return bmi08x_accel_reg_field_update(dev, BMI08X_REG_ACCEL_CONF, 0, BMI08X_ACCEL_ODR_MASK,
 8021f9c: 68fb         	ldr	r3, [r7, #0xc]
 8021f9e: b2db         	uxtb	r3, r3
 8021fa0: 9300         	str	r3, [sp]
 8021fa2: 230f         	movs	r3, #0xf
 8021fa4: 2200         	movs	r2, #0x0
 8021fa6: 2140         	movs	r1, #0x40
 8021fa8: 6878         	ldr	r0, [r7, #0x4]
 8021faa: f7ff ffab    	bl	0x8021f04 <bmi08x_accel_reg_field_update> @ imm = #-0xaa
 8021fae: 4603         	mov	r3, r0
; }
 8021fb0: 4618         	mov	r0, r3
 8021fb2: 3710         	adds	r7, #0x10
 8021fb4: 46bd         	mov	sp, r7
 8021fb6: bd80         	pop	{r7, pc}

08021fb8 <bmi08x_channel_convert>:
; {
 8021fb8: b580         	push	{r7, lr}
 8021fba: b086         	sub	sp, #0x18
 8021fbc: af00         	add	r7, sp, #0x0
 8021fbe: 60ba         	str	r2, [r7, #0x8]
 8021fc0: 607b         	str	r3, [r7, #0x4]
 8021fc2: 4603         	mov	r3, r0
 8021fc4: 81fb         	strh	r3, [r7, #0xe]
 8021fc6: 460b         	mov	r3, r1
 8021fc8: 81bb         	strh	r3, [r7, #0xc]
; 	switch (chan) {
 8021fca: 89fb         	ldrh	r3, [r7, #0xe]
 8021fcc: 2b02         	cmp	r3, #0x2
 8021fce: d010         	beq	0x8021ff2 <bmi08x_channel_convert+0x3a> @ imm = #0x20
 8021fd0: 2b02         	cmp	r3, #0x2
 8021fd2: dc13         	bgt	0x8021ffc <bmi08x_channel_convert+0x44> @ imm = #0x26
 8021fd4: 2b00         	cmp	r3, #0x0
 8021fd6: d002         	beq	0x8021fde <bmi08x_channel_convert+0x26> @ imm = #0x4
 8021fd8: 2b01         	cmp	r3, #0x1
 8021fda: d005         	beq	0x8021fe8 <bmi08x_channel_convert+0x30> @ imm = #0xa
 8021fdc: e00e         	b	0x8021ffc <bmi08x_channel_convert+0x44> @ imm = #0x1c
; 		ofs_start = ofs_stop = 0U;
 8021fde: 2300         	movs	r3, #0x0
 8021fe0: 74bb         	strb	r3, [r7, #0x12]
 8021fe2: 7cbb         	ldrb	r3, [r7, #0x12]
 8021fe4: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 8021fe6: e00e         	b	0x8022006 <bmi08x_channel_convert+0x4e> @ imm = #0x1c
; 		ofs_start = ofs_stop = 1U;
 8021fe8: 2301         	movs	r3, #0x1
 8021fea: 74bb         	strb	r3, [r7, #0x12]
 8021fec: 7cbb         	ldrb	r3, [r7, #0x12]
 8021fee: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 8021ff0: e009         	b	0x8022006 <bmi08x_channel_convert+0x4e> @ imm = #0x12
; 		ofs_start = ofs_stop = 2U;
 8021ff2: 2302         	movs	r3, #0x2
 8021ff4: 74bb         	strb	r3, [r7, #0x12]
 8021ff6: 7cbb         	ldrb	r3, [r7, #0x12]
 8021ff8: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 8021ffa: e004         	b	0x8022006 <bmi08x_channel_convert+0x4e> @ imm = #0x8
; 		ofs_start = 0U;
 8021ffc: 2300         	movs	r3, #0x0
 8021ffe: 74fb         	strb	r3, [r7, #0x13]
; 		ofs_stop = 2U;
 8022000: 2302         	movs	r3, #0x2
 8022002: 74bb         	strb	r3, [r7, #0x12]
; 		break;
 8022004: bf00         	nop
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 8022006: 7cfb         	ldrb	r3, [r7, #0x13]
 8022008: 617b         	str	r3, [r7, #0x14]
 802200a: e010         	b	0x802202e <bmi08x_channel_convert+0x76> @ imm = #0x20
; 		bmi08x_to_fixed_point(raw_xyz[i], scale, val);
 802200c: 697b         	ldr	r3, [r7, #0x14]
 802200e: 005b         	lsls	r3, r3, #0x1
 8022010: 68ba         	ldr	r2, [r7, #0x8]
 8022012: 4413         	add	r3, r2
 8022014: 881b         	ldrh	r3, [r3]
 8022016: b21b         	sxth	r3, r3
 8022018: 89b9         	ldrh	r1, [r7, #0xc]
 802201a: 687a         	ldr	r2, [r7, #0x4]
 802201c: 4618         	mov	r0, r3
 802201e: f7eb fbc3    	bl	0x800d7a8 <bmi08x_to_fixed_point> @ imm = #-0x1487a
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 8022022: 697b         	ldr	r3, [r7, #0x14]
 8022024: 3301         	adds	r3, #0x1
 8022026: 617b         	str	r3, [r7, #0x14]
 8022028: 687b         	ldr	r3, [r7, #0x4]
 802202a: 3308         	adds	r3, #0x8
 802202c: 607b         	str	r3, [r7, #0x4]
 802202e: 7cbb         	ldrb	r3, [r7, #0x12]
 8022030: 697a         	ldr	r2, [r7, #0x14]
 8022032: 429a         	cmp	r2, r3
 8022034: ddea         	ble	0x802200c <bmi08x_channel_convert+0x54> @ imm = #-0x2c
; }
 8022036: bf00         	nop
 8022038: bf00         	nop
 802203a: 3718         	adds	r7, #0x18
 802203c: 46bd         	mov	sp, r7
 802203e: bd80         	pop	{r7, pc}

08022040 <bmi08x_acc_channel_get>:
; {
 8022040: b580         	push	{r7, lr}
 8022042: b086         	sub	sp, #0x18
 8022044: af00         	add	r7, sp, #0x0
 8022046: 60f8         	str	r0, [r7, #0xc]
 8022048: 460b         	mov	r3, r1
 802204a: 607a         	str	r2, [r7, #0x4]
 802204c: 817b         	strh	r3, [r7, #0xa]
; 	struct bmi08x_accel_data *data = dev->data;
 802204e: 68fb         	ldr	r3, [r7, #0xc]
 8022050: 691b         	ldr	r3, [r3, #0x10]
 8022052: 617b         	str	r3, [r7, #0x14]
; 	bmi08x_channel_convert(chan, data->scale, data->acc_sample, val);
 8022054: 697b         	ldr	r3, [r7, #0x14]
 8022056: 8a59         	ldrh	r1, [r3, #0x12]
 8022058: 697b         	ldr	r3, [r7, #0x14]
 802205a: f103 020c    	add.w	r2, r3, #0xc
 802205e: 8978         	ldrh	r0, [r7, #0xa]
 8022060: 687b         	ldr	r3, [r7, #0x4]
 8022062: f7ff ffa9    	bl	0x8021fb8 <bmi08x_channel_convert> @ imm = #-0xae
; }
 8022066: bf00         	nop
 8022068: 3718         	adds	r7, #0x18
 802206a: 46bd         	mov	sp, r7
 802206c: bd80         	pop	{r7, pc}

0802206e <device_is_ready>:
; {
 802206e: b580         	push	{r7, lr}
 8022070: b082         	sub	sp, #0x8
 8022072: af00         	add	r7, sp, #0x0
 8022074: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8022076: 6878         	ldr	r0, [r7, #0x4]
 8022078: f004 f991    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x4322
 802207c: 4603         	mov	r3, r0
; }
 802207e: 4618         	mov	r0, r3
 8022080: 3708         	adds	r7, #0x8
 8022082: 46bd         	mov	sp, r7
 8022084: bd80         	pop	{r7, pc}

08022086 <k_msleep>:
; {
 8022086: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 802208a: b082         	sub	sp, #0x8
 802208c: af00         	add	r7, sp, #0x0
 802208e: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 8022090: 6879         	ldr	r1, [r7, #0x4]
 8022092: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 8022096: 17c8         	asrs	r0, r1, #0x1f
 8022098: 4688         	mov	r8, r1
 802209a: 4681         	mov	r9, r0
 802209c: 4640         	mov	r0, r8
 802209e: 4649         	mov	r1, r9
 80220a0: f04f 0400    	mov.w	r4, #0x0
 80220a4: f04f 0500    	mov.w	r5, #0x0
 80220a8: 008d         	lsls	r5, r1, #0x2
 80220aa: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 80220ae: 0084         	lsls	r4, r0, #0x2
 80220b0: 4620         	mov	r0, r4
 80220b2: 4629         	mov	r1, r5
 80220b4: eb10 0208    	adds.w	r2, r0, r8
 80220b8: eb41 0309    	adc.w	r3, r1, r9
 80220bc: eb12 0a02    	adds.w	r10, r2, r2
 80220c0: eb43 0b03    	adc.w	r11, r3, r3
 80220c4: 4652         	mov	r2, r10
 80220c6: 465b         	mov	r3, r11
 80220c8: 4610         	mov	r0, r2
 80220ca: 4619         	mov	r1, r3
 80220cc: f000 f807    	bl	0x80220de <k_sleep>     @ imm = #0xe
 80220d0: 4601         	mov	r1, r0
 80220d2: 460b         	mov	r3, r1
; }
 80220d4: 4618         	mov	r0, r3
 80220d6: 3708         	adds	r7, #0x8
 80220d8: 46bd         	mov	sp, r7
 80220da: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

080220de <k_sleep>:
; {
 80220de: b580         	push	{r7, lr}
 80220e0: b082         	sub	sp, #0x8
 80220e2: af00         	add	r7, sp, #0x0
 80220e4: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 80220e8: e9d7 0100    	ldrd	r0, r1, [r7]
 80220ec: f7f5 fb3e    	bl	0x801776c <z_impl_k_sleep> @ imm = #-0xa984
 80220f0: 4603         	mov	r3, r0
; }
 80220f2: 4618         	mov	r0, r3
 80220f4: 3708         	adds	r7, #0x8
 80220f6: 46bd         	mov	sp, r7
 80220f8: bd80         	pop	{r7, pc}

080220fa <z_log_msg_runtime_create>:
; {
 80220fa: b580         	push	{r7, lr}
 80220fc: b08a         	sub	sp, #0x28
 80220fe: af04         	add	r7, sp, #0x10
 8022100: 60b9         	str	r1, [r7, #0x8]
 8022102: 607b         	str	r3, [r7, #0x4]
 8022104: 4603         	mov	r3, r0
 8022106: 73fb         	strb	r3, [r7, #0xf]
 8022108: 4613         	mov	r3, r2
 802210a: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 802210c: f107 032c    	add.w	r3, r7, #0x2c
 8022110: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8022112: 7bba         	ldrb	r2, [r7, #0xe]
 8022114: 7bf8         	ldrb	r0, [r7, #0xf]
 8022116: 697b         	ldr	r3, [r7, #0x14]
 8022118: 9303         	str	r3, [sp, #0xc]
 802211a: 6abb         	ldr	r3, [r7, #0x28]
 802211c: 9302         	str	r3, [sp, #0x8]
 802211e: 6a7b         	ldr	r3, [r7, #0x24]
 8022120: 9301         	str	r3, [sp, #0x4]
 8022122: 6a3b         	ldr	r3, [r7, #0x20]
 8022124: 9300         	str	r3, [sp]
 8022126: 687b         	ldr	r3, [r7, #0x4]
 8022128: 68b9         	ldr	r1, [r7, #0x8]
 802212a: f7e2 fd23    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1d5ba
; }
 802212e: bf00         	nop
 8022130: 3718         	adds	r7, #0x18
 8022132: 46bd         	mov	sp, r7
 8022134: bd80         	pop	{r7, pc}

08022136 <gpio_is_ready_dt>:
; {
 8022136: b580         	push	{r7, lr}
 8022138: b082         	sub	sp, #0x8
 802213a: af00         	add	r7, sp, #0x0
 802213c: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 802213e: 687b         	ldr	r3, [r7, #0x4]
 8022140: 681b         	ldr	r3, [r3]
 8022142: 4618         	mov	r0, r3
 8022144: f7ff ff93    	bl	0x802206e <device_is_ready> @ imm = #-0xda
 8022148: 4603         	mov	r3, r0
; }
 802214a: 4618         	mov	r0, r3
 802214c: 3708         	adds	r7, #0x8
 802214e: 46bd         	mov	sp, r7
 8022150: bd80         	pop	{r7, pc}

08022152 <spi_cs_is_gpio>:
; {
 8022152: b480         	push	{r7}
 8022154: b083         	sub	sp, #0xc
 8022156: af00         	add	r7, sp, #0x0
 8022158: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 802215a: 687b         	ldr	r3, [r7, #0x4]
 802215c: 689b         	ldr	r3, [r3, #0x8]
 802215e: 2b00         	cmp	r3, #0x0
 8022160: bf14         	ite	ne
 8022162: 2301         	movne	r3, #0x1
 8022164: 2300         	moveq	r3, #0x0
 8022166: b2db         	uxtb	r3, r3
; }
 8022168: 4618         	mov	r0, r3
 802216a: 370c         	adds	r7, #0xc
 802216c: 46bd         	mov	sp, r7
 802216e: f85d 7b04    	ldr	r7, [sp], #4
 8022172: 4770         	bx	lr

08022174 <spi_cs_is_gpio_dt>:
; {
 8022174: b580         	push	{r7, lr}
 8022176: b082         	sub	sp, #0x8
 8022178: af00         	add	r7, sp, #0x0
 802217a: 6078         	str	r0, [r7, #0x4]
; 	return spi_cs_is_gpio(&spec->config);
 802217c: 687b         	ldr	r3, [r7, #0x4]
 802217e: 3304         	adds	r3, #0x4
 8022180: 4618         	mov	r0, r3
 8022182: f7ff ffe6    	bl	0x8022152 <spi_cs_is_gpio> @ imm = #-0x34
 8022186: 4603         	mov	r3, r0
; }
 8022188: 4618         	mov	r0, r3
 802218a: 3708         	adds	r7, #0x8
 802218c: 46bd         	mov	sp, r7
 802218e: bd80         	pop	{r7, pc}

08022190 <spi_is_ready_dt>:
; {
 8022190: b580         	push	{r7, lr}
 8022192: b082         	sub	sp, #0x8
 8022194: af00         	add	r7, sp, #0x0
 8022196: 6078         	str	r0, [r7, #0x4]
; 	if (!device_is_ready(spec->bus)) {
 8022198: 687b         	ldr	r3, [r7, #0x4]
 802219a: 681b         	ldr	r3, [r3]
 802219c: 4618         	mov	r0, r3
 802219e: f7ff ff66    	bl	0x802206e <device_is_ready> @ imm = #-0x134
 80221a2: 4603         	mov	r3, r0
 80221a4: f083 0301    	eor	r3, r3, #0x1
 80221a8: b2db         	uxtb	r3, r3
 80221aa: 2b00         	cmp	r3, #0x0
 80221ac: d001         	beq	0x80221b2 <spi_is_ready_dt+0x22> @ imm = #0x2
; 		return false;
 80221ae: 2300         	movs	r3, #0x0
 80221b0: e013         	b	0x80221da <spi_is_ready_dt+0x4a> @ imm = #0x26
; 	if (spi_cs_is_gpio_dt(spec) &&
 80221b2: 6878         	ldr	r0, [r7, #0x4]
 80221b4: f7ff ffde    	bl	0x8022174 <spi_cs_is_gpio_dt> @ imm = #-0x44
 80221b8: 4603         	mov	r3, r0
 80221ba: 2b00         	cmp	r3, #0x0
 80221bc: d00c         	beq	0x80221d8 <spi_is_ready_dt+0x48> @ imm = #0x18
; 	    !gpio_is_ready_dt(&spec->config.cs.gpio)) {
 80221be: 687b         	ldr	r3, [r7, #0x4]
 80221c0: 330c         	adds	r3, #0xc
 80221c2: 4618         	mov	r0, r3
 80221c4: f7ff ffb7    	bl	0x8022136 <gpio_is_ready_dt> @ imm = #-0x92
 80221c8: 4603         	mov	r3, r0
 80221ca: f083 0301    	eor	r3, r3, #0x1
 80221ce: b2db         	uxtb	r3, r3
; 	if (spi_cs_is_gpio_dt(spec) &&
 80221d0: 2b00         	cmp	r3, #0x0
 80221d2: d001         	beq	0x80221d8 <spi_is_ready_dt+0x48> @ imm = #0x2
; 		return false;
 80221d4: 2300         	movs	r3, #0x0
 80221d6: e000         	b	0x80221da <spi_is_ready_dt+0x4a> @ imm = #0x0
; 	return true;
 80221d8: 2301         	movs	r3, #0x1
; }
 80221da: 4618         	mov	r0, r3
 80221dc: 3708         	adds	r7, #0x8
 80221de: 46bd         	mov	sp, r7
 80221e0: bd80         	pop	{r7, pc}

080221e2 <z_impl_spi_transceive>:
; {
 80221e2: b590         	push	{r4, r7, lr}
 80221e4: b087         	sub	sp, #0x1c
 80221e6: af00         	add	r7, sp, #0x0
 80221e8: 60f8         	str	r0, [r7, #0xc]
 80221ea: 60b9         	str	r1, [r7, #0x8]
 80221ec: 607a         	str	r2, [r7, #0x4]
 80221ee: 603b         	str	r3, [r7]
; 	const struct spi_driver_api *api =
 80221f0: 68fb         	ldr	r3, [r7, #0xc]
 80221f2: 689b         	ldr	r3, [r3, #0x8]
 80221f4: 617b         	str	r3, [r7, #0x14]
; 	ret = api->transceive(dev, config, tx_bufs, rx_bufs);
 80221f6: 697b         	ldr	r3, [r7, #0x14]
 80221f8: 681c         	ldr	r4, [r3]
 80221fa: 683b         	ldr	r3, [r7]
 80221fc: 687a         	ldr	r2, [r7, #0x4]
 80221fe: 68b9         	ldr	r1, [r7, #0x8]
 8022200: 68f8         	ldr	r0, [r7, #0xc]
 8022202: 47a0         	blx	r4
 8022204: 6138         	str	r0, [r7, #0x10]
; 	return ret;
 8022206: 693b         	ldr	r3, [r7, #0x10]
; }
 8022208: 4618         	mov	r0, r3
 802220a: 371c         	adds	r7, #0x1c
 802220c: 46bd         	mov	sp, r7
 802220e: bd90         	pop	{r4, r7, pc}

08022210 <spi_transceive_dt>:
; {
 8022210: b580         	push	{r7, lr}
 8022212: b084         	sub	sp, #0x10
 8022214: af00         	add	r7, sp, #0x0
 8022216: 60f8         	str	r0, [r7, #0xc]
 8022218: 60b9         	str	r1, [r7, #0x8]
 802221a: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(spec->bus, &spec->config, tx_bufs, rx_bufs);
 802221c: 68fb         	ldr	r3, [r7, #0xc]
 802221e: 6818         	ldr	r0, [r3]
 8022220: 68fb         	ldr	r3, [r7, #0xc]
 8022222: 1d19         	adds	r1, r3, #0x4
 8022224: 687b         	ldr	r3, [r7, #0x4]
 8022226: 68ba         	ldr	r2, [r7, #0x8]
 8022228: f000 f828    	bl	0x802227c <spi_transceive> @ imm = #0x50
 802222c: 4603         	mov	r3, r0
; }
 802222e: 4618         	mov	r0, r3
 8022230: 3710         	adds	r7, #0x10
 8022232: 46bd         	mov	sp, r7
 8022234: bd80         	pop	{r7, pc}

08022236 <spi_write>:
; {
 8022236: b580         	push	{r7, lr}
 8022238: b084         	sub	sp, #0x10
 802223a: af00         	add	r7, sp, #0x0
 802223c: 60f8         	str	r0, [r7, #0xc]
 802223e: 60b9         	str	r1, [r7, #0x8]
 8022240: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(dev, config, tx_bufs, NULL);
 8022242: 2300         	movs	r3, #0x0
 8022244: 687a         	ldr	r2, [r7, #0x4]
 8022246: 68b9         	ldr	r1, [r7, #0x8]
 8022248: 68f8         	ldr	r0, [r7, #0xc]
 802224a: f000 f817    	bl	0x802227c <spi_transceive> @ imm = #0x2e
 802224e: 4603         	mov	r3, r0
; }
 8022250: 4618         	mov	r0, r3
 8022252: 3710         	adds	r7, #0x10
 8022254: 46bd         	mov	sp, r7
 8022256: bd80         	pop	{r7, pc}

08022258 <spi_write_dt>:
; {
 8022258: b580         	push	{r7, lr}
 802225a: b082         	sub	sp, #0x8
 802225c: af00         	add	r7, sp, #0x0
 802225e: 6078         	str	r0, [r7, #0x4]
 8022260: 6039         	str	r1, [r7]
; 	return spi_write(spec->bus, &spec->config, tx_bufs);
 8022262: 687b         	ldr	r3, [r7, #0x4]
 8022264: 6818         	ldr	r0, [r3]
 8022266: 687b         	ldr	r3, [r7, #0x4]
 8022268: 3304         	adds	r3, #0x4
 802226a: 683a         	ldr	r2, [r7]
 802226c: 4619         	mov	r1, r3
 802226e: f7ff ffe2    	bl	0x8022236 <spi_write>   @ imm = #-0x3c
 8022272: 4603         	mov	r3, r0
; }
 8022274: 4618         	mov	r0, r3
 8022276: 3708         	adds	r7, #0x8
 8022278: 46bd         	mov	sp, r7
 802227a: bd80         	pop	{r7, pc}

0802227c <spi_transceive>:
; {
 802227c: b580         	push	{r7, lr}
 802227e: b084         	sub	sp, #0x10
 8022280: af00         	add	r7, sp, #0x0
 8022282: 60f8         	str	r0, [r7, #0xc]
 8022284: 60b9         	str	r1, [r7, #0x8]
 8022286: 607a         	str	r2, [r7, #0x4]
 8022288: 603b         	str	r3, [r7]
; 	return z_impl_spi_transceive(dev, config, tx_bufs, rx_bufs);
 802228a: 683b         	ldr	r3, [r7]
 802228c: 687a         	ldr	r2, [r7, #0x4]
 802228e: 68b9         	ldr	r1, [r7, #0x8]
 8022290: 68f8         	ldr	r0, [r7, #0xc]
 8022292: f7ff ffa6    	bl	0x80221e2 <z_impl_spi_transceive> @ imm = #-0xb4
 8022296: 4603         	mov	r3, r0
; }
 8022298: 4618         	mov	r0, r3
 802229a: 3710         	adds	r7, #0x10
 802229c: 46bd         	mov	sp, r7
 802229e: bd80         	pop	{r7, pc}

080222a0 <bmi08x_gyro_transceive_spi>:
; {
 80222a0: b580         	push	{r7, lr}
 80222a2: b092         	sub	sp, #0x48
 80222a4: af00         	add	r7, sp, #0x0
 80222a6: 60f8         	str	r0, [r7, #0xc]
 80222a8: 607b         	str	r3, [r7, #0x4]
 80222aa: 460b         	mov	r3, r1
 80222ac: 72fb         	strb	r3, [r7, #0xb]
 80222ae: 4613         	mov	r3, r2
 80222b0: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_gyro_config *bmi08x = dev->config;
 80222b2: 68fb         	ldr	r3, [r7, #0xc]
 80222b4: 685b         	ldr	r3, [r3, #0x4]
 80222b6: 647b         	str	r3, [r7, #0x44]
; 	const struct spi_buf tx_buf[2] = {{.buf = &reg, .len = 1}, {.buf = data, .len = length}};
 80222b8: f107 030b    	add.w	r3, r7, #0xb
 80222bc: 637b         	str	r3, [r7, #0x34]
 80222be: 2301         	movs	r3, #0x1
 80222c0: 63bb         	str	r3, [r7, #0x38]
 80222c2: 687b         	ldr	r3, [r7, #0x4]
 80222c4: 63fb         	str	r3, [r7, #0x3c]
 80222c6: 6d3b         	ldr	r3, [r7, #0x50]
 80222c8: 643b         	str	r3, [r7, #0x40]
; 	const struct spi_buf_set tx = {.buffers = tx_buf, .count = write ? 2 : 1};
 80222ca: f107 0334    	add.w	r3, r7, #0x34
 80222ce: 62fb         	str	r3, [r7, #0x2c]
 80222d0: 7abb         	ldrb	r3, [r7, #0xa]
 80222d2: 2b00         	cmp	r3, #0x0
 80222d4: d001         	beq	0x80222da <bmi08x_gyro_transceive_spi+0x3a> @ imm = #0x2
 80222d6: 2302         	movs	r3, #0x2
 80222d8: e000         	b	0x80222dc <bmi08x_gyro_transceive_spi+0x3c> @ imm = #0x0
 80222da: 2301         	movs	r3, #0x1
 80222dc: 633b         	str	r3, [r7, #0x30]
; 	if (!write) {
 80222de: 7abb         	ldrb	r3, [r7, #0xa]
 80222e0: f083 0301    	eor	r3, r3, #0x1
 80222e4: b2db         	uxtb	r3, r3
 80222e6: 2b00         	cmp	r3, #0x0
 80222e8: d017         	beq	0x802231a <bmi08x_gyro_transceive_spi+0x7a> @ imm = #0x2e
; 		const struct spi_buf rx_buf[2] = {{.buf = &dummy, .len = 1},
 80222ea: f107 032a    	add.w	r3, r7, #0x2a
 80222ee: 61bb         	str	r3, [r7, #0x18]
 80222f0: 2301         	movs	r3, #0x1
 80222f2: 61fb         	str	r3, [r7, #0x1c]
 80222f4: 687b         	ldr	r3, [r7, #0x4]
 80222f6: 623b         	str	r3, [r7, #0x20]
 80222f8: 6d3b         	ldr	r3, [r7, #0x50]
 80222fa: 627b         	str	r3, [r7, #0x24]
; 		const struct spi_buf_set rx = {.buffers = rx_buf, .count = 2};
 80222fc: f107 0318    	add.w	r3, r7, #0x18
 8022300: 613b         	str	r3, [r7, #0x10]
 8022302: 2302         	movs	r3, #0x2
 8022304: 617b         	str	r3, [r7, #0x14]
; 		return spi_transceive_dt(&bmi08x->bus.spi, &tx, &rx);
 8022306: 6c7b         	ldr	r3, [r7, #0x44]
 8022308: f107 0210    	add.w	r2, r7, #0x10
 802230c: f107 012c    	add.w	r1, r7, #0x2c
 8022310: 4618         	mov	r0, r3
 8022312: f7ff ff7d    	bl	0x8022210 <spi_transceive_dt> @ imm = #-0x106
 8022316: 4603         	mov	r3, r0
 8022318: e007         	b	0x802232a <bmi08x_gyro_transceive_spi+0x8a> @ imm = #0xe
; 	return spi_write_dt(&bmi08x->bus.spi, &tx);
 802231a: 6c7b         	ldr	r3, [r7, #0x44]
 802231c: f107 022c    	add.w	r2, r7, #0x2c
 8022320: 4611         	mov	r1, r2
 8022322: 4618         	mov	r0, r3
 8022324: f7ff ff98    	bl	0x8022258 <spi_write_dt> @ imm = #-0xd0
 8022328: 4603         	mov	r3, r0
; }
 802232a: 4618         	mov	r0, r3
 802232c: 3748         	adds	r7, #0x48
 802232e: 46bd         	mov	sp, r7
 8022330: bd80         	pop	{r7, pc}

08022332 <bmi08x_bus_check_spi>:
; {
 8022332: b580         	push	{r7, lr}
 8022334: b082         	sub	sp, #0x8
 8022336: af00         	add	r7, sp, #0x0
 8022338: 6078         	str	r0, [r7, #0x4]
; 	return spi_is_ready_dt(&bus->spi) ? 0 : -ENODEV;
 802233a: 687b         	ldr	r3, [r7, #0x4]
 802233c: 4618         	mov	r0, r3
 802233e: f7ff ff27    	bl	0x8022190 <spi_is_ready_dt> @ imm = #-0x1b2
 8022342: 4603         	mov	r3, r0
 8022344: 2b00         	cmp	r3, #0x0
 8022346: d001         	beq	0x802234c <bmi08x_bus_check_spi+0x1a> @ imm = #0x2
 8022348: 2300         	movs	r3, #0x0
 802234a: e001         	b	0x8022350 <bmi08x_bus_check_spi+0x1e> @ imm = #0x2
 802234c: f06f 0312    	mvn	r3, #0x12
; }
 8022350: 4618         	mov	r0, r3
 8022352: 3708         	adds	r7, #0x8
 8022354: 46bd         	mov	sp, r7
 8022356: bd80         	pop	{r7, pc}

08022358 <bmi08x_bus_check>:
; {
 8022358: b580         	push	{r7, lr}
 802235a: b084         	sub	sp, #0x10
 802235c: af00         	add	r7, sp, #0x0
 802235e: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_gyro_config *config = dev->config;
 8022360: 687b         	ldr	r3, [r7, #0x4]
 8022362: 685b         	ldr	r3, [r3, #0x4]
 8022364: 60fb         	str	r3, [r7, #0xc]
; 	return config->api->check(&config->bus);
 8022366: 68fb         	ldr	r3, [r7, #0xc]
 8022368: 699b         	ldr	r3, [r3, #0x18]
 802236a: 681b         	ldr	r3, [r3]
 802236c: 68fa         	ldr	r2, [r7, #0xc]
 802236e: 4610         	mov	r0, r2
 8022370: 4798         	blx	r3
 8022372: 4603         	mov	r3, r0
; }
 8022374: 4618         	mov	r0, r3
 8022376: 3710         	adds	r7, #0x10
 8022378: 46bd         	mov	sp, r7
 802237a: bd80         	pop	{r7, pc}

0802237c <bmi08x_gyro_transceive>:
; {
 802237c: b590         	push	{r4, r7, lr}
 802237e: b089         	sub	sp, #0x24
 8022380: af02         	add	r7, sp, #0x8
 8022382: 60f8         	str	r0, [r7, #0xc]
 8022384: 607b         	str	r3, [r7, #0x4]
 8022386: 460b         	mov	r3, r1
 8022388: 72fb         	strb	r3, [r7, #0xb]
 802238a: 4613         	mov	r3, r2
 802238c: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_gyro_config *cfg = dev->config;
 802238e: 68fb         	ldr	r3, [r7, #0xc]
 8022390: 685b         	ldr	r3, [r3, #0x4]
 8022392: 617b         	str	r3, [r7, #0x14]
; 	return cfg->api->transceive(dev, reg, write, data, length);
 8022394: 697b         	ldr	r3, [r7, #0x14]
 8022396: 699b         	ldr	r3, [r3, #0x18]
 8022398: 685c         	ldr	r4, [r3, #0x4]
 802239a: 7aba         	ldrb	r2, [r7, #0xa]
 802239c: 7af9         	ldrb	r1, [r7, #0xb]
 802239e: 6abb         	ldr	r3, [r7, #0x28]
 80223a0: 9300         	str	r3, [sp]
 80223a2: 687b         	ldr	r3, [r7, #0x4]
 80223a4: 68f8         	ldr	r0, [r7, #0xc]
 80223a6: 47a0         	blx	r4
 80223a8: 4603         	mov	r3, r0
; }
 80223aa: 4618         	mov	r0, r3
 80223ac: 371c         	adds	r7, #0x1c
 80223ae: 46bd         	mov	sp, r7
 80223b0: bd90         	pop	{r4, r7, pc}

080223b2 <bmi08x_gyro_read>:
; {
 80223b2: b580         	push	{r7, lr}
 80223b4: b086         	sub	sp, #0x18
 80223b6: af02         	add	r7, sp, #0x8
 80223b8: 60f8         	str	r0, [r7, #0xc]
 80223ba: 607a         	str	r2, [r7, #0x4]
 80223bc: 461a         	mov	r2, r3
 80223be: 460b         	mov	r3, r1
 80223c0: 72fb         	strb	r3, [r7, #0xb]
 80223c2: 4613         	mov	r3, r2
 80223c4: 72bb         	strb	r3, [r7, #0xa]
; 	return bmi08x_gyro_transceive(dev, reg_addr | BIT(7), false, data, len);
 80223c6: 7afb         	ldrb	r3, [r7, #0xb]
 80223c8: f063 037f    	orn	r3, r3, #0x7f
 80223cc: b2d9         	uxtb	r1, r3
 80223ce: 7abb         	ldrb	r3, [r7, #0xa]
 80223d0: 9300         	str	r3, [sp]
 80223d2: 687b         	ldr	r3, [r7, #0x4]
 80223d4: 2200         	movs	r2, #0x0
 80223d6: 68f8         	ldr	r0, [r7, #0xc]
 80223d8: f7ff ffd0    	bl	0x802237c <bmi08x_gyro_transceive> @ imm = #-0x60
 80223dc: 4603         	mov	r3, r0
; }
 80223de: 4618         	mov	r0, r3
 80223e0: 3710         	adds	r7, #0x10
 80223e2: 46bd         	mov	sp, r7
 80223e4: bd80         	pop	{r7, pc}

080223e6 <bmi08x_gyro_byte_read>:
; {
 80223e6: b580         	push	{r7, lr}
 80223e8: b086         	sub	sp, #0x18
 80223ea: af02         	add	r7, sp, #0x8
 80223ec: 60f8         	str	r0, [r7, #0xc]
 80223ee: 460b         	mov	r3, r1
 80223f0: 607a         	str	r2, [r7, #0x4]
 80223f2: 72fb         	strb	r3, [r7, #0xb]
; 	return bmi08x_gyro_transceive(dev, reg_addr | BIT(7), false, byte, 1);
 80223f4: 7afb         	ldrb	r3, [r7, #0xb]
 80223f6: f063 037f    	orn	r3, r3, #0x7f
 80223fa: b2d9         	uxtb	r1, r3
 80223fc: 2301         	movs	r3, #0x1
 80223fe: 9300         	str	r3, [sp]
 8022400: 687b         	ldr	r3, [r7, #0x4]
 8022402: 2200         	movs	r2, #0x0
 8022404: 68f8         	ldr	r0, [r7, #0xc]
 8022406: f7ff ffb9    	bl	0x802237c <bmi08x_gyro_transceive> @ imm = #-0x8e
 802240a: 4603         	mov	r3, r0
; }
 802240c: 4618         	mov	r0, r3
 802240e: 3710         	adds	r7, #0x10
 8022410: 46bd         	mov	sp, r7
 8022412: bd80         	pop	{r7, pc}

08022414 <bmi08x_gyro_byte_write>:
; {
 8022414: b580         	push	{r7, lr}
 8022416: b084         	sub	sp, #0x10
 8022418: af02         	add	r7, sp, #0x8
 802241a: 6078         	str	r0, [r7, #0x4]
 802241c: 460b         	mov	r3, r1
 802241e: 70fb         	strb	r3, [r7, #0x3]
 8022420: 4613         	mov	r3, r2
 8022422: 70bb         	strb	r3, [r7, #0x2]
; 	return bmi08x_gyro_transceive(dev, reg_addr & 0x7F, true, &byte, 1);
 8022424: 78fb         	ldrb	r3, [r7, #0x3]
 8022426: f003 037f    	and	r3, r3, #0x7f
 802242a: b2d9         	uxtb	r1, r3
 802242c: 1cbb         	adds	r3, r7, #0x2
 802242e: 2201         	movs	r2, #0x1
 8022430: 9200         	str	r2, [sp]
 8022432: 2201         	movs	r2, #0x1
 8022434: 6878         	ldr	r0, [r7, #0x4]
 8022436: f7ff ffa1    	bl	0x802237c <bmi08x_gyro_transceive> @ imm = #-0xbe
 802243a: 4603         	mov	r3, r0
; }
 802243c: 4618         	mov	r0, r3
 802243e: 3708         	adds	r7, #0x8
 8022440: 46bd         	mov	sp, r7
 8022442: bd80         	pop	{r7, pc}

08022444 <bmi08x_gyr_odr_set>:
; {
 8022444: b580         	push	{r7, lr}
 8022446: b084         	sub	sp, #0x10
 8022448: af00         	add	r7, sp, #0x0
 802244a: 6078         	str	r0, [r7, #0x4]
 802244c: 460b         	mov	r3, r1
 802244e: 807b         	strh	r3, [r7, #0x2]
 8022450: 4613         	mov	r3, r2
 8022452: 803b         	strh	r3, [r7]
; 	int odr = bmi08x_freq_to_odr_val(freq_int, freq_milli);
 8022454: 883a         	ldrh	r2, [r7]
 8022456: 887b         	ldrh	r3, [r7, #0x2]
 8022458: 4611         	mov	r1, r2
 802245a: 4618         	mov	r0, r3
 802245c: f7ec f848    	bl	0x800e4f0 <bmi08x_freq_to_odr_val> @ imm = #-0x13f70
 8022460: 60f8         	str	r0, [r7, #0xc]
; 	if (odr < 0) {
 8022462: 68fb         	ldr	r3, [r7, #0xc]
 8022464: 2b00         	cmp	r3, #0x0
 8022466: da01         	bge	0x802246c <bmi08x_gyr_odr_set+0x28> @ imm = #0x2
; 		return odr;
 8022468: 68fb         	ldr	r3, [r7, #0xc]
 802246a: e010         	b	0x802248e <bmi08x_gyr_odr_set+0x4a> @ imm = #0x20
; 	if (odr < BMI08X_GYRO_BW_532_ODR_2000_HZ || odr > BMI08X_GYRO_BW_32_ODR_100_HZ) {
 802246c: 68fb         	ldr	r3, [r7, #0xc]
 802246e: 2b00         	cmp	r3, #0x0
 8022470: db02         	blt	0x8022478 <bmi08x_gyr_odr_set+0x34> @ imm = #0x4
 8022472: 68fb         	ldr	r3, [r7, #0xc]
 8022474: 2b07         	cmp	r3, #0x7
 8022476: dd02         	ble	0x802247e <bmi08x_gyr_odr_set+0x3a> @ imm = #0x4
; 		return -ENOTSUP;
 8022478: f06f 0385    	mvn	r3, #0x85
 802247c: e007         	b	0x802248e <bmi08x_gyr_odr_set+0x4a> @ imm = #0xe
; 	return bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_BANDWIDTH, (uint8_t)odr);
 802247e: 68fb         	ldr	r3, [r7, #0xc]
 8022480: b2db         	uxtb	r3, r3
 8022482: 461a         	mov	r2, r3
 8022484: 2110         	movs	r1, #0x10
 8022486: 6878         	ldr	r0, [r7, #0x4]
 8022488: f7ff ffc4    	bl	0x8022414 <bmi08x_gyro_byte_write> @ imm = #-0x78
 802248c: 4603         	mov	r3, r0
; }
 802248e: 4618         	mov	r0, r3
 8022490: 3710         	adds	r7, #0x10
 8022492: 46bd         	mov	sp, r7
 8022494: bd80         	pop	{r7, pc}

08022496 <bmi08x_channel_convert>:
; {
 8022496: b580         	push	{r7, lr}
 8022498: b086         	sub	sp, #0x18
 802249a: af00         	add	r7, sp, #0x0
 802249c: 60ba         	str	r2, [r7, #0x8]
 802249e: 607b         	str	r3, [r7, #0x4]
 80224a0: 4603         	mov	r3, r0
 80224a2: 81fb         	strh	r3, [r7, #0xe]
 80224a4: 460b         	mov	r3, r1
 80224a6: 81bb         	strh	r3, [r7, #0xc]
; 	switch (chan) {
 80224a8: 89fb         	ldrh	r3, [r7, #0xe]
 80224aa: 2b06         	cmp	r3, #0x6
 80224ac: d010         	beq	0x80224d0 <bmi08x_channel_convert+0x3a> @ imm = #0x20
 80224ae: 2b06         	cmp	r3, #0x6
 80224b0: dc13         	bgt	0x80224da <bmi08x_channel_convert+0x44> @ imm = #0x26
 80224b2: 2b04         	cmp	r3, #0x4
 80224b4: d002         	beq	0x80224bc <bmi08x_channel_convert+0x26> @ imm = #0x4
 80224b6: 2b05         	cmp	r3, #0x5
 80224b8: d005         	beq	0x80224c6 <bmi08x_channel_convert+0x30> @ imm = #0xa
 80224ba: e00e         	b	0x80224da <bmi08x_channel_convert+0x44> @ imm = #0x1c
; 		ofs_start = ofs_stop = 0U;
 80224bc: 2300         	movs	r3, #0x0
 80224be: 74bb         	strb	r3, [r7, #0x12]
 80224c0: 7cbb         	ldrb	r3, [r7, #0x12]
 80224c2: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 80224c4: e00e         	b	0x80224e4 <bmi08x_channel_convert+0x4e> @ imm = #0x1c
; 		ofs_start = ofs_stop = 1U;
 80224c6: 2301         	movs	r3, #0x1
 80224c8: 74bb         	strb	r3, [r7, #0x12]
 80224ca: 7cbb         	ldrb	r3, [r7, #0x12]
 80224cc: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 80224ce: e009         	b	0x80224e4 <bmi08x_channel_convert+0x4e> @ imm = #0x12
; 		ofs_start = ofs_stop = 2U;
 80224d0: 2302         	movs	r3, #0x2
 80224d2: 74bb         	strb	r3, [r7, #0x12]
 80224d4: 7cbb         	ldrb	r3, [r7, #0x12]
 80224d6: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 80224d8: e004         	b	0x80224e4 <bmi08x_channel_convert+0x4e> @ imm = #0x8
; 		ofs_start = 0U;
 80224da: 2300         	movs	r3, #0x0
 80224dc: 74fb         	strb	r3, [r7, #0x13]
; 		ofs_stop = 2U;
 80224de: 2302         	movs	r3, #0x2
 80224e0: 74bb         	strb	r3, [r7, #0x12]
; 		break;
 80224e2: bf00         	nop
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 80224e4: 7cfb         	ldrb	r3, [r7, #0x13]
 80224e6: 617b         	str	r3, [r7, #0x14]
 80224e8: e010         	b	0x802250c <bmi08x_channel_convert+0x76> @ imm = #0x20
; 		bmi08x_to_fixed_point(raw_xyz[i], scale, val);
 80224ea: 697b         	ldr	r3, [r7, #0x14]
 80224ec: 005b         	lsls	r3, r3, #0x1
 80224ee: 68ba         	ldr	r2, [r7, #0x8]
 80224f0: 4413         	add	r3, r2
 80224f2: 881b         	ldrh	r3, [r3]
 80224f4: b21b         	sxth	r3, r3
 80224f6: 89b9         	ldrh	r1, [r7, #0xc]
 80224f8: 687a         	ldr	r2, [r7, #0x4]
 80224fa: 4618         	mov	r0, r3
 80224fc: f7eb fddc    	bl	0x800e0b8 <bmi08x_to_fixed_point> @ imm = #-0x14448
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 8022500: 697b         	ldr	r3, [r7, #0x14]
 8022502: 3301         	adds	r3, #0x1
 8022504: 617b         	str	r3, [r7, #0x14]
 8022506: 687b         	ldr	r3, [r7, #0x4]
 8022508: 3308         	adds	r3, #0x8
 802250a: 607b         	str	r3, [r7, #0x4]
 802250c: 7cbb         	ldrb	r3, [r7, #0x12]
 802250e: 697a         	ldr	r2, [r7, #0x14]
 8022510: 429a         	cmp	r2, r3
 8022512: ddea         	ble	0x80224ea <bmi08x_channel_convert+0x54> @ imm = #-0x2c
; }
 8022514: bf00         	nop
 8022516: bf00         	nop
 8022518: 3718         	adds	r7, #0x18
 802251a: 46bd         	mov	sp, r7
 802251c: bd80         	pop	{r7, pc}

0802251e <bmi08x_gyr_channel_get>:
; {
 802251e: b580         	push	{r7, lr}
 8022520: b086         	sub	sp, #0x18
 8022522: af00         	add	r7, sp, #0x0
 8022524: 60f8         	str	r0, [r7, #0xc]
 8022526: 460b         	mov	r3, r1
 8022528: 607a         	str	r2, [r7, #0x4]
 802252a: 817b         	strh	r3, [r7, #0xa]
; 	struct bmi08x_gyro_data *bmi08x = dev->data;
 802252c: 68fb         	ldr	r3, [r7, #0xc]
 802252e: 691b         	ldr	r3, [r3, #0x10]
 8022530: 617b         	str	r3, [r7, #0x14]
; 	bmi08x_channel_convert(chan, bmi08x->scale, bmi08x->gyr_sample, val);
 8022532: 697b         	ldr	r3, [r7, #0x14]
 8022534: 8a59         	ldrh	r1, [r3, #0x12]
 8022536: 697b         	ldr	r3, [r7, #0x14]
 8022538: f103 020c    	add.w	r2, r3, #0xc
 802253c: 8978         	ldrh	r0, [r7, #0xa]
 802253e: 687b         	ldr	r3, [r7, #0x4]
 8022540: f7ff ffa9    	bl	0x8022496 <bmi08x_channel_convert> @ imm = #-0xae
; }
 8022544: bf00         	nop
 8022546: 3718         	adds	r7, #0x18
 8022548: 46bd         	mov	sp, r7
 802254a: bd80         	pop	{r7, pc}

0802254c <bmi08x_range_to_reg_val>:
; {
 802254c: b480         	push	{r7}
 802254e: b085         	sub	sp, #0x14
 8022550: af00         	add	r7, sp, #0x0
 8022552: 4603         	mov	r3, r0
 8022554: 6039         	str	r1, [r7]
 8022556: 80fb         	strh	r3, [r7, #0x6]
 8022558: 4613         	mov	r3, r2
 802255a: 80bb         	strh	r3, [r7, #0x4]
; 	for (i = 0; i < range_map_size; i++) {
 802255c: 2300         	movs	r3, #0x0
 802255e: 60fb         	str	r3, [r7, #0xc]
 8022560: e010         	b	0x8022584 <bmi08x_range_to_reg_val+0x38> @ imm = #0x20
; 		if (range <= range_map[i].range) {
 8022562: 68fb         	ldr	r3, [r7, #0xc]
 8022564: 009b         	lsls	r3, r3, #0x2
 8022566: 683a         	ldr	r2, [r7]
 8022568: 4413         	add	r3, r2
 802256a: 881b         	ldrh	r3, [r3]
 802256c: 88fa         	ldrh	r2, [r7, #0x6]
 802256e: 429a         	cmp	r2, r3
 8022570: d805         	bhi	0x802257e <bmi08x_range_to_reg_val+0x32> @ imm = #0xa
; 			return range_map[i].reg_val;
 8022572: 68fb         	ldr	r3, [r7, #0xc]
 8022574: 009b         	lsls	r3, r3, #0x2
 8022576: 683a         	ldr	r2, [r7]
 8022578: 4413         	add	r3, r2
 802257a: 789b         	ldrb	r3, [r3, #0x2]
 802257c: e008         	b	0x8022590 <bmi08x_range_to_reg_val+0x44> @ imm = #0x10
; 	for (i = 0; i < range_map_size; i++) {
 802257e: 68fb         	ldr	r3, [r7, #0xc]
 8022580: 3301         	adds	r3, #0x1
 8022582: 60fb         	str	r3, [r7, #0xc]
 8022584: 88bb         	ldrh	r3, [r7, #0x4]
 8022586: 68fa         	ldr	r2, [r7, #0xc]
 8022588: 429a         	cmp	r2, r3
 802258a: dbea         	blt	0x8022562 <bmi08x_range_to_reg_val+0x16> @ imm = #-0x2c
; 	return -EINVAL;
 802258c: f06f 0315    	mvn	r3, #0x15
; }
 8022590: 4618         	mov	r0, r3
 8022592: 3714         	adds	r7, #0x14
 8022594: 46bd         	mov	sp, r7
 8022596: f85d 7b04    	ldr	r7, [sp], #4
 802259a: 4770         	bx	lr

0802259c <device_is_ready>:
; {
 802259c: b580         	push	{r7, lr}
 802259e: b082         	sub	sp, #0x8
 80225a0: af00         	add	r7, sp, #0x0
 80225a2: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80225a4: 6878         	ldr	r0, [r7, #0x4]
 80225a6: f003 fefa    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x3df4
 80225aa: 4603         	mov	r3, r0
; }
 80225ac: 4618         	mov	r0, r3
 80225ae: 3708         	adds	r7, #0x8
 80225b0: 46bd         	mov	sp, r7
 80225b2: bd80         	pop	{r7, pc}

080225b4 <gpio_is_ready_dt>:
; {
 80225b4: b580         	push	{r7, lr}
 80225b6: b082         	sub	sp, #0x8
 80225b8: af00         	add	r7, sp, #0x0
 80225ba: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 80225bc: 687b         	ldr	r3, [r7, #0x4]
 80225be: 681b         	ldr	r3, [r3]
 80225c0: 4618         	mov	r0, r3
 80225c2: f7ff ffeb    	bl	0x802259c <device_is_ready> @ imm = #-0x2a
 80225c6: 4603         	mov	r3, r0
; }
 80225c8: 4618         	mov	r0, r3
 80225ca: 3708         	adds	r7, #0x8
 80225cc: 46bd         	mov	sp, r7
 80225ce: bd80         	pop	{r7, pc}

080225d0 <gpio_pin_interrupt_configure_dt>:
; {
 80225d0: b580         	push	{r7, lr}
 80225d2: b082         	sub	sp, #0x8
 80225d4: af00         	add	r7, sp, #0x0
 80225d6: 6078         	str	r0, [r7, #0x4]
 80225d8: 6039         	str	r1, [r7]
; 	return gpio_pin_interrupt_configure(spec->port, spec->pin, flags);
 80225da: 687b         	ldr	r3, [r7, #0x4]
 80225dc: 6818         	ldr	r0, [r3]
 80225de: 687b         	ldr	r3, [r7, #0x4]
 80225e0: 791b         	ldrb	r3, [r3, #0x4]
 80225e2: 683a         	ldr	r2, [r7]
 80225e4: 4619         	mov	r1, r3
 80225e6: f000 f892    	bl	0x802270e <gpio_pin_interrupt_configure> @ imm = #0x124
 80225ea: 4603         	mov	r3, r0
; }
 80225ec: 4618         	mov	r0, r3
 80225ee: 3708         	adds	r7, #0x8
 80225f0: 46bd         	mov	sp, r7
 80225f2: bd80         	pop	{r7, pc}

080225f4 <z_impl_gpio_pin_configure>:
; {
 80225f4: b580         	push	{r7, lr}
 80225f6: b088         	sub	sp, #0x20
 80225f8: af00         	add	r7, sp, #0x0
 80225fa: 60f8         	str	r0, [r7, #0xc]
 80225fc: 460b         	mov	r3, r1
 80225fe: 607a         	str	r2, [r7, #0x4]
 8022600: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 8022602: 68fb         	ldr	r3, [r7, #0xc]
 8022604: 689b         	ldr	r3, [r3, #0x8]
 8022606: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 8022608: 68fb         	ldr	r3, [r7, #0xc]
 802260a: 685b         	ldr	r3, [r3, #0x4]
 802260c: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 802260e: 68fb         	ldr	r3, [r7, #0xc]
 8022610: 691b         	ldr	r3, [r3, #0x10]
 8022612: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 8022614: 687b         	ldr	r3, [r7, #0x4]
 8022616: f403 1380    	and	r3, r3, #0x100000
 802261a: 2b00         	cmp	r3, #0x0
 802261c: d00d         	beq	0x802263a <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 802261e: 687b         	ldr	r3, [r7, #0x4]
 8022620: f403 2340    	and	r3, r3, #0xc0000
 8022624: 2b00         	cmp	r3, #0x0
 8022626: d008         	beq	0x802263a <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 8022628: 687b         	ldr	r3, [r7, #0x4]
 802262a: f003 0301    	and	r3, r3, #0x1
 802262e: 2b00         	cmp	r3, #0x0
 8022630: d003         	beq	0x802263a <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 8022632: 687b         	ldr	r3, [r7, #0x4]
 8022634: f483 2340    	eor	r3, r3, #0xc0000
 8022638: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 802263a: 687b         	ldr	r3, [r7, #0x4]
 802263c: f423 1380    	bic	r3, r3, #0x100000
 8022640: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 8022642: 687b         	ldr	r3, [r7, #0x4]
 8022644: f003 0301    	and	r3, r3, #0x1
 8022648: 2b00         	cmp	r3, #0x0
 802264a: d009         	beq	0x8022660 <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 802264c: 697b         	ldr	r3, [r7, #0x14]
 802264e: 681a         	ldr	r2, [r3]
 8022650: 7afb         	ldrb	r3, [r7, #0xb]
 8022652: 2101         	movs	r1, #0x1
 8022654: fa01 f303    	lsl.w	r3, r1, r3
 8022658: 431a         	orrs	r2, r3
 802265a: 697b         	ldr	r3, [r7, #0x14]
 802265c: 601a         	str	r2, [r3]
 802265e: e009         	b	0x8022674 <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 8022660: 697b         	ldr	r3, [r7, #0x14]
 8022662: 681a         	ldr	r2, [r3]
 8022664: 7afb         	ldrb	r3, [r7, #0xb]
 8022666: 2101         	movs	r1, #0x1
 8022668: fa01 f303    	lsl.w	r3, r1, r3
 802266c: 43db         	mvns	r3, r3
 802266e: 401a         	ands	r2, r3
 8022670: 697b         	ldr	r3, [r7, #0x14]
 8022672: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 8022674: 69fb         	ldr	r3, [r7, #0x1c]
 8022676: 681b         	ldr	r3, [r3]
 8022678: 7af9         	ldrb	r1, [r7, #0xb]
 802267a: 687a         	ldr	r2, [r7, #0x4]
 802267c: 68f8         	ldr	r0, [r7, #0xc]
 802267e: 4798         	blx	r3
 8022680: 4603         	mov	r3, r0
; }
 8022682: 4618         	mov	r0, r3
 8022684: 3720         	adds	r7, #0x20
 8022686: 46bd         	mov	sp, r7
 8022688: bd80         	pop	{r7, pc}

0802268a <gpio_pin_configure_dt>:
; {
 802268a: b580         	push	{r7, lr}
 802268c: b082         	sub	sp, #0x8
 802268e: af00         	add	r7, sp, #0x0
 8022690: 6078         	str	r0, [r7, #0x4]
 8022692: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 8022694: 687b         	ldr	r3, [r7, #0x4]
 8022696: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 8022698: 687b         	ldr	r3, [r7, #0x4]
 802269a: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 802269c: 687b         	ldr	r3, [r7, #0x4]
 802269e: 88db         	ldrh	r3, [r3, #0x6]
 80226a0: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 80226a2: 683b         	ldr	r3, [r7]
 80226a4: 4313         	orrs	r3, r2
 80226a6: 461a         	mov	r2, r3
 80226a8: f000 f843    	bl	0x8022732 <gpio_pin_configure> @ imm = #0x86
 80226ac: 4603         	mov	r3, r0
; }
 80226ae: 4618         	mov	r0, r3
 80226b0: 3708         	adds	r7, #0x8
 80226b2: 46bd         	mov	sp, r7
 80226b4: bd80         	pop	{r7, pc}

080226b6 <gpio_init_callback>:
; {
 80226b6: b480         	push	{r7}
 80226b8: b085         	sub	sp, #0x14
 80226ba: af00         	add	r7, sp, #0x0
 80226bc: 60f8         	str	r0, [r7, #0xc]
 80226be: 60b9         	str	r1, [r7, #0x8]
 80226c0: 607a         	str	r2, [r7, #0x4]
; 	callback->handler = handler;
 80226c2: 68fb         	ldr	r3, [r7, #0xc]
 80226c4: 68ba         	ldr	r2, [r7, #0x8]
 80226c6: 605a         	str	r2, [r3, #0x4]
; 	callback->pin_mask = pin_mask;
 80226c8: 68fb         	ldr	r3, [r7, #0xc]
 80226ca: 687a         	ldr	r2, [r7, #0x4]
 80226cc: 609a         	str	r2, [r3, #0x8]
; }
 80226ce: bf00         	nop
 80226d0: 3714         	adds	r7, #0x14
 80226d2: 46bd         	mov	sp, r7
 80226d4: f85d 7b04    	ldr	r7, [sp], #4
 80226d8: 4770         	bx	lr

080226da <gpio_add_callback>:
; {
 80226da: b580         	push	{r7, lr}
 80226dc: b084         	sub	sp, #0x10
 80226de: af00         	add	r7, sp, #0x0
 80226e0: 6078         	str	r0, [r7, #0x4]
 80226e2: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 80226e4: 687b         	ldr	r3, [r7, #0x4]
 80226e6: 689b         	ldr	r3, [r3, #0x8]
 80226e8: 60fb         	str	r3, [r7, #0xc]
; 	if (api->manage_callback == NULL) {
 80226ea: 68fb         	ldr	r3, [r7, #0xc]
 80226ec: 69db         	ldr	r3, [r3, #0x1c]
 80226ee: 2b00         	cmp	r3, #0x0
 80226f0: d102         	bne	0x80226f8 <gpio_add_callback+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 80226f2: f06f 0357    	mvn	r3, #0x57
 80226f6: e006         	b	0x8022706 <gpio_add_callback+0x2c> @ imm = #0xc
; 	return api->manage_callback(port, callback, true);
 80226f8: 68fb         	ldr	r3, [r7, #0xc]
 80226fa: 69db         	ldr	r3, [r3, #0x1c]
 80226fc: 2201         	movs	r2, #0x1
 80226fe: 6839         	ldr	r1, [r7]
 8022700: 6878         	ldr	r0, [r7, #0x4]
 8022702: 4798         	blx	r3
 8022704: 4603         	mov	r3, r0
; }
 8022706: 4618         	mov	r0, r3
 8022708: 3710         	adds	r7, #0x10
 802270a: 46bd         	mov	sp, r7
 802270c: bd80         	pop	{r7, pc}

0802270e <gpio_pin_interrupt_configure>:
; {
 802270e: b580         	push	{r7, lr}
 8022710: b084         	sub	sp, #0x10
 8022712: af00         	add	r7, sp, #0x0
 8022714: 60f8         	str	r0, [r7, #0xc]
 8022716: 460b         	mov	r3, r1
 8022718: 607a         	str	r2, [r7, #0x4]
 802271a: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_interrupt_configure(port, pin, flags);
 802271c: 7afb         	ldrb	r3, [r7, #0xb]
 802271e: 687a         	ldr	r2, [r7, #0x4]
 8022720: 4619         	mov	r1, r3
 8022722: 68f8         	ldr	r0, [r7, #0xc]
 8022724: f7eb ff20    	bl	0x800e568 <z_impl_gpio_pin_interrupt_configure> @ imm = #-0x141c0
 8022728: 4603         	mov	r3, r0
; }
 802272a: 4618         	mov	r0, r3
 802272c: 3710         	adds	r7, #0x10
 802272e: 46bd         	mov	sp, r7
 8022730: bd80         	pop	{r7, pc}

08022732 <gpio_pin_configure>:
; {
 8022732: b580         	push	{r7, lr}
 8022734: b084         	sub	sp, #0x10
 8022736: af00         	add	r7, sp, #0x0
 8022738: 60f8         	str	r0, [r7, #0xc]
 802273a: 460b         	mov	r3, r1
 802273c: 607a         	str	r2, [r7, #0x4]
 802273e: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 8022740: 7afb         	ldrb	r3, [r7, #0xb]
 8022742: 687a         	ldr	r2, [r7, #0x4]
 8022744: 4619         	mov	r1, r3
 8022746: 68f8         	ldr	r0, [r7, #0xc]
 8022748: f7ff ff54    	bl	0x80225f4 <z_impl_gpio_pin_configure> @ imm = #-0x158
 802274c: 4603         	mov	r3, r0
; }
 802274e: 4618         	mov	r0, r3
 8022750: 3710         	adds	r7, #0x10
 8022752: 46bd         	mov	sp, r7
 8022754: bd80         	pop	{r7, pc}

08022756 <k_thread_create>:
; {
 8022756: b580         	push	{r7, lr}
 8022758: b08c         	sub	sp, #0x30
 802275a: af08         	add	r7, sp, #0x20
 802275c: 60f8         	str	r0, [r7, #0xc]
 802275e: 60b9         	str	r1, [r7, #0x8]
 8022760: 607a         	str	r2, [r7, #0x4]
 8022762: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 8022764: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8022768: e9cd 2306    	strd	r2, r3, [sp, #24]
 802276c: 6abb         	ldr	r3, [r7, #0x28]
 802276e: 9304         	str	r3, [sp, #0x10]
 8022770: 6a7b         	ldr	r3, [r7, #0x24]
 8022772: 9303         	str	r3, [sp, #0xc]
 8022774: 6a3b         	ldr	r3, [r7, #0x20]
 8022776: 9302         	str	r3, [sp, #0x8]
 8022778: 69fb         	ldr	r3, [r7, #0x1c]
 802277a: 9301         	str	r3, [sp, #0x4]
 802277c: 69bb         	ldr	r3, [r7, #0x18]
 802277e: 9300         	str	r3, [sp]
 8022780: 683b         	ldr	r3, [r7]
 8022782: 687a         	ldr	r2, [r7, #0x4]
 8022784: 68b9         	ldr	r1, [r7, #0x8]
 8022786: 68f8         	ldr	r0, [r7, #0xc]
 8022788: f005 fc4b    	bl	0x8028022 <z_impl_k_thread_create> @ imm = #0x5896
 802278c: 4603         	mov	r3, r0
; }
 802278e: 4618         	mov	r0, r3
 8022790: 3710         	adds	r7, #0x10
 8022792: 46bd         	mov	sp, r7
 8022794: bd80         	pop	{r7, pc}

08022796 <k_thread_name_set>:
; {
 8022796: b580         	push	{r7, lr}
 8022798: b082         	sub	sp, #0x8
 802279a: af00         	add	r7, sp, #0x0
 802279c: 6078         	str	r0, [r7, #0x4]
 802279e: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 80227a0: 6839         	ldr	r1, [r7]
 80227a2: 6878         	ldr	r0, [r7, #0x4]
 80227a4: f7f3 fbd6    	bl	0x8015f54 <z_impl_k_thread_name_set> @ imm = #-0xc854
 80227a8: 4603         	mov	r3, r0
; }
 80227aa: 4618         	mov	r0, r3
 80227ac: 3708         	adds	r7, #0x8
 80227ae: 46bd         	mov	sp, r7
 80227b0: bd80         	pop	{r7, pc}

080227b2 <k_sem_init>:
; {
 80227b2: b580         	push	{r7, lr}
 80227b4: b084         	sub	sp, #0x10
 80227b6: af00         	add	r7, sp, #0x0
 80227b8: 60f8         	str	r0, [r7, #0xc]
 80227ba: 60b9         	str	r1, [r7, #0x8]
 80227bc: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 80227be: 687a         	ldr	r2, [r7, #0x4]
 80227c0: 68b9         	ldr	r1, [r7, #0x8]
 80227c2: 68f8         	ldr	r0, [r7, #0xc]
 80227c4: f004 ffa9    	bl	0x802771a <z_impl_k_sem_init> @ imm = #0x4f52
 80227c8: 4603         	mov	r3, r0
; }
 80227ca: 4618         	mov	r0, r3
 80227cc: 3710         	adds	r7, #0x10
 80227ce: 46bd         	mov	sp, r7
 80227d0: bd80         	pop	{r7, pc}

080227d2 <k_sem_take>:
; {
 80227d2: b580         	push	{r7, lr}
 80227d4: b084         	sub	sp, #0x10
 80227d6: af00         	add	r7, sp, #0x0
 80227d8: 60f8         	str	r0, [r7, #0xc]
 80227da: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 80227de: e9d7 2300    	ldrd	r2, r3, [r7]
 80227e2: 68f8         	ldr	r0, [r7, #0xc]
 80227e4: f7f2 ffc6    	bl	0x8015774 <z_impl_k_sem_take> @ imm = #-0xd074
 80227e8: 4603         	mov	r3, r0
; }
 80227ea: 4618         	mov	r0, r3
 80227ec: 3710         	adds	r7, #0x10
 80227ee: 46bd         	mov	sp, r7
 80227f0: bd80         	pop	{r7, pc}

080227f2 <k_sem_give>:
; {
 80227f2: b580         	push	{r7, lr}
 80227f4: b082         	sub	sp, #0x8
 80227f6: af00         	add	r7, sp, #0x0
 80227f8: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 80227fa: 6878         	ldr	r0, [r7, #0x4]
 80227fc: f7f2 ff2c    	bl	0x8015658 <z_impl_k_sem_give> @ imm = #-0xd1a8
; }
 8022800: bf00         	nop
 8022802: 3708         	adds	r7, #0x8
 8022804: 46bd         	mov	sp, r7
 8022806: bd80         	pop	{r7, pc}

08022808 <z_log_msg_runtime_create>:
; {
 8022808: b580         	push	{r7, lr}
 802280a: b08a         	sub	sp, #0x28
 802280c: af04         	add	r7, sp, #0x10
 802280e: 60b9         	str	r1, [r7, #0x8]
 8022810: 607b         	str	r3, [r7, #0x4]
 8022812: 4603         	mov	r3, r0
 8022814: 73fb         	strb	r3, [r7, #0xf]
 8022816: 4613         	mov	r3, r2
 8022818: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 802281a: f107 032c    	add.w	r3, r7, #0x2c
 802281e: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8022820: 7bba         	ldrb	r2, [r7, #0xe]
 8022822: 7bf8         	ldrb	r0, [r7, #0xf]
 8022824: 697b         	ldr	r3, [r7, #0x14]
 8022826: 9303         	str	r3, [sp, #0xc]
 8022828: 6abb         	ldr	r3, [r7, #0x28]
 802282a: 9302         	str	r3, [sp, #0x8]
 802282c: 6a7b         	ldr	r3, [r7, #0x24]
 802282e: 9301         	str	r3, [sp, #0x4]
 8022830: 6a3b         	ldr	r3, [r7, #0x20]
 8022832: 9300         	str	r3, [sp]
 8022834: 687b         	ldr	r3, [r7, #0x4]
 8022836: 68b9         	ldr	r1, [r7, #0x8]
 8022838: f7e2 f99c    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1dcc8
; }
 802283c: bf00         	nop
 802283e: 3718         	adds	r7, #0x18
 8022840: 46bd         	mov	sp, r7
 8022842: bd80         	pop	{r7, pc}

08022844 <bmi08x_handle_drdy_acc>:
; {
 8022844: b580         	push	{r7, lr}
 8022846: b084         	sub	sp, #0x10
 8022848: af00         	add	r7, sp, #0x0
 802284a: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_accel_data *data = dev->data;
 802284c: 687b         	ldr	r3, [r7, #0x4]
 802284e: 691b         	ldr	r3, [r3, #0x10]
 8022850: 60fb         	str	r3, [r7, #0xc]
; 	if (data->handler_drdy_acc) {
 8022852: 68fb         	ldr	r3, [r7, #0xc]
 8022854: f8d3 3740    	ldr.w	r3, [r3, #0x740]
 8022858: 2b00         	cmp	r3, #0x0
 802285a: d008         	beq	0x802286e <bmi08x_handle_drdy_acc+0x2a> @ imm = #0x10
; 		data->handler_drdy_acc(dev, data->drdy_trig_acc);
 802285c: 68fb         	ldr	r3, [r7, #0xc]
 802285e: f8d3 3740    	ldr.w	r3, [r3, #0x740]
 8022862: 68fa         	ldr	r2, [r7, #0xc]
 8022864: f8d2 2744    	ldr.w	r2, [r2, #0x744]
 8022868: 4611         	mov	r1, r2
 802286a: 6878         	ldr	r0, [r7, #0x4]
 802286c: 4798         	blx	r3
; }
 802286e: bf00         	nop
 8022870: 3710         	adds	r7, #0x10
 8022872: 46bd         	mov	sp, r7
 8022874: bd80         	pop	{r7, pc}

08022876 <bmi08x_handle_interrupts_acc>:
; {
 8022876: b580         	push	{r7, lr}
 8022878: b084         	sub	sp, #0x10
 802287a: af00         	add	r7, sp, #0x0
 802287c: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = (const struct device *)arg;
 802287e: 687b         	ldr	r3, [r7, #0x4]
 8022880: 60fb         	str	r3, [r7, #0xc]
; 	bmi08x_handle_drdy_acc(dev);
 8022882: 68f8         	ldr	r0, [r7, #0xc]
 8022884: f7ff ffde    	bl	0x8022844 <bmi08x_handle_drdy_acc> @ imm = #-0x44
; }
 8022888: bf00         	nop
 802288a: 3710         	adds	r7, #0x10
 802288c: 46bd         	mov	sp, r7
 802288e: bd80         	pop	{r7, pc}

08022890 <bmi08x_acc_gpio_callback>:
; {
 8022890: b580         	push	{r7, lr}
 8022892: b086         	sub	sp, #0x18
 8022894: af00         	add	r7, sp, #0x0
 8022896: 60f8         	str	r0, [r7, #0xc]
 8022898: 60b9         	str	r1, [r7, #0x8]
 802289a: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_accel_data *data = CONTAINER_OF(cb, struct bmi08x_accel_data, gpio_cb);
 802289c: 68bb         	ldr	r3, [r7, #0x8]
 802289e: 617b         	str	r3, [r7, #0x14]
; 	k_sem_give(&data->sem);
 80228a0: 697b         	ldr	r3, [r7, #0x14]
 80228a2: f503 63e6    	add.w	r3, r3, #0x730
 80228a6: 4618         	mov	r0, r3
 80228a8: f7ff ffa3    	bl	0x80227f2 <k_sem_give>  @ imm = #-0xba
; }
 80228ac: bf00         	nop
 80228ae: 3718         	adds	r7, #0x18
 80228b0: 46bd         	mov	sp, r7
 80228b2: bd80         	pop	{r7, pc}

080228b4 <bmi08x_trigger_set_acc>:
; {
 80228b4: b480         	push	{r7}
 80228b6: b087         	sub	sp, #0x1c
 80228b8: af00         	add	r7, sp, #0x0
 80228ba: 60f8         	str	r0, [r7, #0xc]
 80228bc: 60b9         	str	r1, [r7, #0x8]
 80228be: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_accel_data *data = dev->data;
 80228c0: 68fb         	ldr	r3, [r7, #0xc]
 80228c2: 691b         	ldr	r3, [r3, #0x10]
 80228c4: 617b         	str	r3, [r7, #0x14]
; 	if ((trig->chan == SENSOR_CHAN_ACCEL_XYZ) && (trig->type == SENSOR_TRIG_DATA_READY)) {
 80228c6: 68bb         	ldr	r3, [r7, #0x8]
 80228c8: 885b         	ldrh	r3, [r3, #0x2]
 80228ca: 2b03         	cmp	r3, #0x3
 80228cc: d10d         	bne	0x80228ea <bmi08x_trigger_set_acc+0x36> @ imm = #0x1a
 80228ce: 68bb         	ldr	r3, [r7, #0x8]
 80228d0: 881b         	ldrh	r3, [r3]
 80228d2: 2b01         	cmp	r3, #0x1
 80228d4: d109         	bne	0x80228ea <bmi08x_trigger_set_acc+0x36> @ imm = #0x12
; 		data->drdy_trig_acc = trig;
 80228d6: 697b         	ldr	r3, [r7, #0x14]
 80228d8: 68ba         	ldr	r2, [r7, #0x8]
 80228da: f8c3 2744    	str.w	r2, [r3, #0x744]
; 		data->handler_drdy_acc = handler;
 80228de: 697b         	ldr	r3, [r7, #0x14]
 80228e0: 687a         	ldr	r2, [r7, #0x4]
 80228e2: f8c3 2740    	str.w	r2, [r3, #0x740]
; 		return 0;
 80228e6: 2300         	movs	r3, #0x0
 80228e8: e001         	b	0x80228ee <bmi08x_trigger_set_acc+0x3a> @ imm = #0x2
; 	return -ENOTSUP;
 80228ea: f06f 0385    	mvn	r3, #0x85
; }
 80228ee: 4618         	mov	r0, r3
 80228f0: 371c         	adds	r7, #0x1c
 80228f2: 46bd         	mov	sp, r7
 80228f4: f85d 7b04    	ldr	r7, [sp], #4
 80228f8: 4770         	bx	lr

080228fa <device_is_ready>:
; {
 80228fa: b580         	push	{r7, lr}
 80228fc: b082         	sub	sp, #0x8
 80228fe: af00         	add	r7, sp, #0x0
 8022900: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8022902: 6878         	ldr	r0, [r7, #0x4]
 8022904: f003 fd4b    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x3a96
 8022908: 4603         	mov	r3, r0
; }
 802290a: 4618         	mov	r0, r3
 802290c: 3708         	adds	r7, #0x8
 802290e: 46bd         	mov	sp, r7
 8022910: bd80         	pop	{r7, pc}

08022912 <gpio_is_ready_dt>:
; {
 8022912: b580         	push	{r7, lr}
 8022914: b082         	sub	sp, #0x8
 8022916: af00         	add	r7, sp, #0x0
 8022918: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 802291a: 687b         	ldr	r3, [r7, #0x4]
 802291c: 681b         	ldr	r3, [r3]
 802291e: 4618         	mov	r0, r3
 8022920: f7ff ffeb    	bl	0x80228fa <device_is_ready> @ imm = #-0x2a
 8022924: 4603         	mov	r3, r0
; }
 8022926: 4618         	mov	r0, r3
 8022928: 3708         	adds	r7, #0x8
 802292a: 46bd         	mov	sp, r7
 802292c: bd80         	pop	{r7, pc}

0802292e <gpio_pin_interrupt_configure_dt>:
; {
 802292e: b580         	push	{r7, lr}
 8022930: b082         	sub	sp, #0x8
 8022932: af00         	add	r7, sp, #0x0
 8022934: 6078         	str	r0, [r7, #0x4]
 8022936: 6039         	str	r1, [r7]
; 	return gpio_pin_interrupt_configure(spec->port, spec->pin, flags);
 8022938: 687b         	ldr	r3, [r7, #0x4]
 802293a: 6818         	ldr	r0, [r3]
 802293c: 687b         	ldr	r3, [r7, #0x4]
 802293e: 791b         	ldrb	r3, [r3, #0x4]
 8022940: 683a         	ldr	r2, [r7]
 8022942: 4619         	mov	r1, r3
 8022944: f000 f892    	bl	0x8022a6c <gpio_pin_interrupt_configure> @ imm = #0x124
 8022948: 4603         	mov	r3, r0
; }
 802294a: 4618         	mov	r0, r3
 802294c: 3708         	adds	r7, #0x8
 802294e: 46bd         	mov	sp, r7
 8022950: bd80         	pop	{r7, pc}

08022952 <z_impl_gpio_pin_configure>:
; {
 8022952: b580         	push	{r7, lr}
 8022954: b088         	sub	sp, #0x20
 8022956: af00         	add	r7, sp, #0x0
 8022958: 60f8         	str	r0, [r7, #0xc]
 802295a: 460b         	mov	r3, r1
 802295c: 607a         	str	r2, [r7, #0x4]
 802295e: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 8022960: 68fb         	ldr	r3, [r7, #0xc]
 8022962: 689b         	ldr	r3, [r3, #0x8]
 8022964: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 8022966: 68fb         	ldr	r3, [r7, #0xc]
 8022968: 685b         	ldr	r3, [r3, #0x4]
 802296a: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 802296c: 68fb         	ldr	r3, [r7, #0xc]
 802296e: 691b         	ldr	r3, [r3, #0x10]
 8022970: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 8022972: 687b         	ldr	r3, [r7, #0x4]
 8022974: f403 1380    	and	r3, r3, #0x100000
 8022978: 2b00         	cmp	r3, #0x0
 802297a: d00d         	beq	0x8022998 <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 802297c: 687b         	ldr	r3, [r7, #0x4]
 802297e: f403 2340    	and	r3, r3, #0xc0000
 8022982: 2b00         	cmp	r3, #0x0
 8022984: d008         	beq	0x8022998 <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 8022986: 687b         	ldr	r3, [r7, #0x4]
 8022988: f003 0301    	and	r3, r3, #0x1
 802298c: 2b00         	cmp	r3, #0x0
 802298e: d003         	beq	0x8022998 <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 8022990: 687b         	ldr	r3, [r7, #0x4]
 8022992: f483 2340    	eor	r3, r3, #0xc0000
 8022996: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 8022998: 687b         	ldr	r3, [r7, #0x4]
 802299a: f423 1380    	bic	r3, r3, #0x100000
 802299e: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 80229a0: 687b         	ldr	r3, [r7, #0x4]
 80229a2: f003 0301    	and	r3, r3, #0x1
 80229a6: 2b00         	cmp	r3, #0x0
 80229a8: d009         	beq	0x80229be <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 80229aa: 697b         	ldr	r3, [r7, #0x14]
 80229ac: 681a         	ldr	r2, [r3]
 80229ae: 7afb         	ldrb	r3, [r7, #0xb]
 80229b0: 2101         	movs	r1, #0x1
 80229b2: fa01 f303    	lsl.w	r3, r1, r3
 80229b6: 431a         	orrs	r2, r3
 80229b8: 697b         	ldr	r3, [r7, #0x14]
 80229ba: 601a         	str	r2, [r3]
 80229bc: e009         	b	0x80229d2 <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 80229be: 697b         	ldr	r3, [r7, #0x14]
 80229c0: 681a         	ldr	r2, [r3]
 80229c2: 7afb         	ldrb	r3, [r7, #0xb]
 80229c4: 2101         	movs	r1, #0x1
 80229c6: fa01 f303    	lsl.w	r3, r1, r3
 80229ca: 43db         	mvns	r3, r3
 80229cc: 401a         	ands	r2, r3
 80229ce: 697b         	ldr	r3, [r7, #0x14]
 80229d0: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 80229d2: 69fb         	ldr	r3, [r7, #0x1c]
 80229d4: 681b         	ldr	r3, [r3]
 80229d6: 7af9         	ldrb	r1, [r7, #0xb]
 80229d8: 687a         	ldr	r2, [r7, #0x4]
 80229da: 68f8         	ldr	r0, [r7, #0xc]
 80229dc: 4798         	blx	r3
 80229de: 4603         	mov	r3, r0
; }
 80229e0: 4618         	mov	r0, r3
 80229e2: 3720         	adds	r7, #0x20
 80229e4: 46bd         	mov	sp, r7
 80229e6: bd80         	pop	{r7, pc}

080229e8 <gpio_pin_configure_dt>:
; {
 80229e8: b580         	push	{r7, lr}
 80229ea: b082         	sub	sp, #0x8
 80229ec: af00         	add	r7, sp, #0x0
 80229ee: 6078         	str	r0, [r7, #0x4]
 80229f0: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 80229f2: 687b         	ldr	r3, [r7, #0x4]
 80229f4: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 80229f6: 687b         	ldr	r3, [r7, #0x4]
 80229f8: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 80229fa: 687b         	ldr	r3, [r7, #0x4]
 80229fc: 88db         	ldrh	r3, [r3, #0x6]
 80229fe: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 8022a00: 683b         	ldr	r3, [r7]
 8022a02: 4313         	orrs	r3, r2
 8022a04: 461a         	mov	r2, r3
 8022a06: f000 f843    	bl	0x8022a90 <gpio_pin_configure> @ imm = #0x86
 8022a0a: 4603         	mov	r3, r0
; }
 8022a0c: 4618         	mov	r0, r3
 8022a0e: 3708         	adds	r7, #0x8
 8022a10: 46bd         	mov	sp, r7
 8022a12: bd80         	pop	{r7, pc}

08022a14 <gpio_init_callback>:
; {
 8022a14: b480         	push	{r7}
 8022a16: b085         	sub	sp, #0x14
 8022a18: af00         	add	r7, sp, #0x0
 8022a1a: 60f8         	str	r0, [r7, #0xc]
 8022a1c: 60b9         	str	r1, [r7, #0x8]
 8022a1e: 607a         	str	r2, [r7, #0x4]
; 	callback->handler = handler;
 8022a20: 68fb         	ldr	r3, [r7, #0xc]
 8022a22: 68ba         	ldr	r2, [r7, #0x8]
 8022a24: 605a         	str	r2, [r3, #0x4]
; 	callback->pin_mask = pin_mask;
 8022a26: 68fb         	ldr	r3, [r7, #0xc]
 8022a28: 687a         	ldr	r2, [r7, #0x4]
 8022a2a: 609a         	str	r2, [r3, #0x8]
; }
 8022a2c: bf00         	nop
 8022a2e: 3714         	adds	r7, #0x14
 8022a30: 46bd         	mov	sp, r7
 8022a32: f85d 7b04    	ldr	r7, [sp], #4
 8022a36: 4770         	bx	lr

08022a38 <gpio_add_callback>:
; {
 8022a38: b580         	push	{r7, lr}
 8022a3a: b084         	sub	sp, #0x10
 8022a3c: af00         	add	r7, sp, #0x0
 8022a3e: 6078         	str	r0, [r7, #0x4]
 8022a40: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 8022a42: 687b         	ldr	r3, [r7, #0x4]
 8022a44: 689b         	ldr	r3, [r3, #0x8]
 8022a46: 60fb         	str	r3, [r7, #0xc]
; 	if (api->manage_callback == NULL) {
 8022a48: 68fb         	ldr	r3, [r7, #0xc]
 8022a4a: 69db         	ldr	r3, [r3, #0x1c]
 8022a4c: 2b00         	cmp	r3, #0x0
 8022a4e: d102         	bne	0x8022a56 <gpio_add_callback+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 8022a50: f06f 0357    	mvn	r3, #0x57
 8022a54: e006         	b	0x8022a64 <gpio_add_callback+0x2c> @ imm = #0xc
; 	return api->manage_callback(port, callback, true);
 8022a56: 68fb         	ldr	r3, [r7, #0xc]
 8022a58: 69db         	ldr	r3, [r3, #0x1c]
 8022a5a: 2201         	movs	r2, #0x1
 8022a5c: 6839         	ldr	r1, [r7]
 8022a5e: 6878         	ldr	r0, [r7, #0x4]
 8022a60: 4798         	blx	r3
 8022a62: 4603         	mov	r3, r0
; }
 8022a64: 4618         	mov	r0, r3
 8022a66: 3710         	adds	r7, #0x10
 8022a68: 46bd         	mov	sp, r7
 8022a6a: bd80         	pop	{r7, pc}

08022a6c <gpio_pin_interrupt_configure>:
; {
 8022a6c: b580         	push	{r7, lr}
 8022a6e: b084         	sub	sp, #0x10
 8022a70: af00         	add	r7, sp, #0x0
 8022a72: 60f8         	str	r0, [r7, #0xc]
 8022a74: 460b         	mov	r3, r1
 8022a76: 607a         	str	r2, [r7, #0x4]
 8022a78: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_interrupt_configure(port, pin, flags);
 8022a7a: 7afb         	ldrb	r3, [r7, #0xb]
 8022a7c: 687a         	ldr	r2, [r7, #0x4]
 8022a7e: 4619         	mov	r1, r3
 8022a80: 68f8         	ldr	r0, [r7, #0xc]
 8022a82: f7eb ff09    	bl	0x800e898 <z_impl_gpio_pin_interrupt_configure> @ imm = #-0x141ee
 8022a86: 4603         	mov	r3, r0
; }
 8022a88: 4618         	mov	r0, r3
 8022a8a: 3710         	adds	r7, #0x10
 8022a8c: 46bd         	mov	sp, r7
 8022a8e: bd80         	pop	{r7, pc}

08022a90 <gpio_pin_configure>:
; {
 8022a90: b580         	push	{r7, lr}
 8022a92: b084         	sub	sp, #0x10
 8022a94: af00         	add	r7, sp, #0x0
 8022a96: 60f8         	str	r0, [r7, #0xc]
 8022a98: 460b         	mov	r3, r1
 8022a9a: 607a         	str	r2, [r7, #0x4]
 8022a9c: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 8022a9e: 7afb         	ldrb	r3, [r7, #0xb]
 8022aa0: 687a         	ldr	r2, [r7, #0x4]
 8022aa2: 4619         	mov	r1, r3
 8022aa4: 68f8         	ldr	r0, [r7, #0xc]
 8022aa6: f7ff ff54    	bl	0x8022952 <z_impl_gpio_pin_configure> @ imm = #-0x158
 8022aaa: 4603         	mov	r3, r0
; }
 8022aac: 4618         	mov	r0, r3
 8022aae: 3710         	adds	r7, #0x10
 8022ab0: 46bd         	mov	sp, r7
 8022ab2: bd80         	pop	{r7, pc}

08022ab4 <k_thread_create>:
; {
 8022ab4: b580         	push	{r7, lr}
 8022ab6: b08c         	sub	sp, #0x30
 8022ab8: af08         	add	r7, sp, #0x20
 8022aba: 60f8         	str	r0, [r7, #0xc]
 8022abc: 60b9         	str	r1, [r7, #0x8]
 8022abe: 607a         	str	r2, [r7, #0x4]
 8022ac0: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 8022ac2: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8022ac6: e9cd 2306    	strd	r2, r3, [sp, #24]
 8022aca: 6abb         	ldr	r3, [r7, #0x28]
 8022acc: 9304         	str	r3, [sp, #0x10]
 8022ace: 6a7b         	ldr	r3, [r7, #0x24]
 8022ad0: 9303         	str	r3, [sp, #0xc]
 8022ad2: 6a3b         	ldr	r3, [r7, #0x20]
 8022ad4: 9302         	str	r3, [sp, #0x8]
 8022ad6: 69fb         	ldr	r3, [r7, #0x1c]
 8022ad8: 9301         	str	r3, [sp, #0x4]
 8022ada: 69bb         	ldr	r3, [r7, #0x18]
 8022adc: 9300         	str	r3, [sp]
 8022ade: 683b         	ldr	r3, [r7]
 8022ae0: 687a         	ldr	r2, [r7, #0x4]
 8022ae2: 68b9         	ldr	r1, [r7, #0x8]
 8022ae4: 68f8         	ldr	r0, [r7, #0xc]
 8022ae6: f005 fa9c    	bl	0x8028022 <z_impl_k_thread_create> @ imm = #0x5538
 8022aea: 4603         	mov	r3, r0
; }
 8022aec: 4618         	mov	r0, r3
 8022aee: 3710         	adds	r7, #0x10
 8022af0: 46bd         	mov	sp, r7
 8022af2: bd80         	pop	{r7, pc}

08022af4 <k_thread_name_set>:
; {
 8022af4: b580         	push	{r7, lr}
 8022af6: b082         	sub	sp, #0x8
 8022af8: af00         	add	r7, sp, #0x0
 8022afa: 6078         	str	r0, [r7, #0x4]
 8022afc: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 8022afe: 6839         	ldr	r1, [r7]
 8022b00: 6878         	ldr	r0, [r7, #0x4]
 8022b02: f7f3 fa27    	bl	0x8015f54 <z_impl_k_thread_name_set> @ imm = #-0xcbb2
 8022b06: 4603         	mov	r3, r0
; }
 8022b08: 4618         	mov	r0, r3
 8022b0a: 3708         	adds	r7, #0x8
 8022b0c: 46bd         	mov	sp, r7
 8022b0e: bd80         	pop	{r7, pc}

08022b10 <k_sem_init>:
; {
 8022b10: b580         	push	{r7, lr}
 8022b12: b084         	sub	sp, #0x10
 8022b14: af00         	add	r7, sp, #0x0
 8022b16: 60f8         	str	r0, [r7, #0xc]
 8022b18: 60b9         	str	r1, [r7, #0x8]
 8022b1a: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 8022b1c: 687a         	ldr	r2, [r7, #0x4]
 8022b1e: 68b9         	ldr	r1, [r7, #0x8]
 8022b20: 68f8         	ldr	r0, [r7, #0xc]
 8022b22: f004 fdfa    	bl	0x802771a <z_impl_k_sem_init> @ imm = #0x4bf4
 8022b26: 4603         	mov	r3, r0
; }
 8022b28: 4618         	mov	r0, r3
 8022b2a: 3710         	adds	r7, #0x10
 8022b2c: 46bd         	mov	sp, r7
 8022b2e: bd80         	pop	{r7, pc}

08022b30 <k_sem_take>:
; {
 8022b30: b580         	push	{r7, lr}
 8022b32: b084         	sub	sp, #0x10
 8022b34: af00         	add	r7, sp, #0x0
 8022b36: 60f8         	str	r0, [r7, #0xc]
 8022b38: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 8022b3c: e9d7 2300    	ldrd	r2, r3, [r7]
 8022b40: 68f8         	ldr	r0, [r7, #0xc]
 8022b42: f7f2 fe17    	bl	0x8015774 <z_impl_k_sem_take> @ imm = #-0xd3d2
 8022b46: 4603         	mov	r3, r0
; }
 8022b48: 4618         	mov	r0, r3
 8022b4a: 3710         	adds	r7, #0x10
 8022b4c: 46bd         	mov	sp, r7
 8022b4e: bd80         	pop	{r7, pc}

08022b50 <k_sem_give>:
; {
 8022b50: b580         	push	{r7, lr}
 8022b52: b082         	sub	sp, #0x8
 8022b54: af00         	add	r7, sp, #0x0
 8022b56: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 8022b58: 6878         	ldr	r0, [r7, #0x4]
 8022b5a: f7f2 fd7d    	bl	0x8015658 <z_impl_k_sem_give> @ imm = #-0xd506
; }
 8022b5e: bf00         	nop
 8022b60: 3708         	adds	r7, #0x8
 8022b62: 46bd         	mov	sp, r7
 8022b64: bd80         	pop	{r7, pc}

08022b66 <z_log_msg_runtime_create>:
; {
 8022b66: b580         	push	{r7, lr}
 8022b68: b08a         	sub	sp, #0x28
 8022b6a: af04         	add	r7, sp, #0x10
 8022b6c: 60b9         	str	r1, [r7, #0x8]
 8022b6e: 607b         	str	r3, [r7, #0x4]
 8022b70: 4603         	mov	r3, r0
 8022b72: 73fb         	strb	r3, [r7, #0xf]
 8022b74: 4613         	mov	r3, r2
 8022b76: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8022b78: f107 032c    	add.w	r3, r7, #0x2c
 8022b7c: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8022b7e: 7bba         	ldrb	r2, [r7, #0xe]
 8022b80: 7bf8         	ldrb	r0, [r7, #0xf]
 8022b82: 697b         	ldr	r3, [r7, #0x14]
 8022b84: 9303         	str	r3, [sp, #0xc]
 8022b86: 6abb         	ldr	r3, [r7, #0x28]
 8022b88: 9302         	str	r3, [sp, #0x8]
 8022b8a: 6a7b         	ldr	r3, [r7, #0x24]
 8022b8c: 9301         	str	r3, [sp, #0x4]
 8022b8e: 6a3b         	ldr	r3, [r7, #0x20]
 8022b90: 9300         	str	r3, [sp]
 8022b92: 687b         	ldr	r3, [r7, #0x4]
 8022b94: 68b9         	ldr	r1, [r7, #0x8]
 8022b96: f7e1 ffed    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1e026
; }
 8022b9a: bf00         	nop
 8022b9c: 3718         	adds	r7, #0x18
 8022b9e: 46bd         	mov	sp, r7
 8022ba0: bd80         	pop	{r7, pc}

08022ba2 <bmi08x_handle_drdy_gyr>:
; {
 8022ba2: b580         	push	{r7, lr}
 8022ba4: b084         	sub	sp, #0x10
 8022ba6: af00         	add	r7, sp, #0x0
 8022ba8: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = dev->data;
 8022baa: 687b         	ldr	r3, [r7, #0x4]
 8022bac: 691b         	ldr	r3, [r3, #0x10]
 8022bae: 60fb         	str	r3, [r7, #0xc]
; 	if (data->handler_drdy_gyr) {
 8022bb0: 68fb         	ldr	r3, [r7, #0xc]
 8022bb2: f8d3 3740    	ldr.w	r3, [r3, #0x740]
 8022bb6: 2b00         	cmp	r3, #0x0
 8022bb8: d008         	beq	0x8022bcc <bmi08x_handle_drdy_gyr+0x2a> @ imm = #0x10
; 		data->handler_drdy_gyr(dev, data->drdy_trig_gyr);
 8022bba: 68fb         	ldr	r3, [r7, #0xc]
 8022bbc: f8d3 3740    	ldr.w	r3, [r3, #0x740]
 8022bc0: 68fa         	ldr	r2, [r7, #0xc]
 8022bc2: f8d2 2744    	ldr.w	r2, [r2, #0x744]
 8022bc6: 4611         	mov	r1, r2
 8022bc8: 6878         	ldr	r0, [r7, #0x4]
 8022bca: 4798         	blx	r3
; }
 8022bcc: bf00         	nop
 8022bce: 3710         	adds	r7, #0x10
 8022bd0: 46bd         	mov	sp, r7
 8022bd2: bd80         	pop	{r7, pc}

08022bd4 <bmi08x_handle_interrupts_gyr>:
; {
 8022bd4: b580         	push	{r7, lr}
 8022bd6: b084         	sub	sp, #0x10
 8022bd8: af00         	add	r7, sp, #0x0
 8022bda: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = (const struct device *)arg;
 8022bdc: 687b         	ldr	r3, [r7, #0x4]
 8022bde: 60fb         	str	r3, [r7, #0xc]
; 	bmi08x_handle_drdy_gyr(dev);
 8022be0: 68f8         	ldr	r0, [r7, #0xc]
 8022be2: f7ff ffde    	bl	0x8022ba2 <bmi08x_handle_drdy_gyr> @ imm = #-0x44
; }
 8022be6: bf00         	nop
 8022be8: 3710         	adds	r7, #0x10
 8022bea: 46bd         	mov	sp, r7
 8022bec: bd80         	pop	{r7, pc}

08022bee <bmi08x_gyr_gpio_callback>:
; {
 8022bee: b580         	push	{r7, lr}
 8022bf0: b086         	sub	sp, #0x18
 8022bf2: af00         	add	r7, sp, #0x0
 8022bf4: 60f8         	str	r0, [r7, #0xc]
 8022bf6: 60b9         	str	r1, [r7, #0x8]
 8022bf8: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = CONTAINER_OF(cb, struct bmi08x_gyro_data, gpio_cb);
 8022bfa: 68bb         	ldr	r3, [r7, #0x8]
 8022bfc: 617b         	str	r3, [r7, #0x14]
; 	k_sem_give(&data->sem);
 8022bfe: 697b         	ldr	r3, [r7, #0x14]
 8022c00: f503 63e6    	add.w	r3, r3, #0x730
 8022c04: 4618         	mov	r0, r3
 8022c06: f7ff ffa3    	bl	0x8022b50 <k_sem_give>  @ imm = #-0xba
; }
 8022c0a: bf00         	nop
 8022c0c: 3718         	adds	r7, #0x18
 8022c0e: 46bd         	mov	sp, r7
 8022c10: bd80         	pop	{r7, pc}

08022c12 <bmi08x_trigger_set_gyr>:
; {
 8022c12: b480         	push	{r7}
 8022c14: b087         	sub	sp, #0x1c
 8022c16: af00         	add	r7, sp, #0x0
 8022c18: 60f8         	str	r0, [r7, #0xc]
 8022c1a: 60b9         	str	r1, [r7, #0x8]
 8022c1c: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = dev->data;
 8022c1e: 68fb         	ldr	r3, [r7, #0xc]
 8022c20: 691b         	ldr	r3, [r3, #0x10]
 8022c22: 617b         	str	r3, [r7, #0x14]
; 	if ((trig->chan == SENSOR_CHAN_GYRO_XYZ) && (trig->type == SENSOR_TRIG_DATA_READY)) {
 8022c24: 68bb         	ldr	r3, [r7, #0x8]
 8022c26: 885b         	ldrh	r3, [r3, #0x2]
 8022c28: 2b07         	cmp	r3, #0x7
 8022c2a: d10d         	bne	0x8022c48 <bmi08x_trigger_set_gyr+0x36> @ imm = #0x1a
 8022c2c: 68bb         	ldr	r3, [r7, #0x8]
 8022c2e: 881b         	ldrh	r3, [r3]
 8022c30: 2b01         	cmp	r3, #0x1
 8022c32: d109         	bne	0x8022c48 <bmi08x_trigger_set_gyr+0x36> @ imm = #0x12
; 		data->drdy_trig_gyr = trig;
 8022c34: 697b         	ldr	r3, [r7, #0x14]
 8022c36: 68ba         	ldr	r2, [r7, #0x8]
 8022c38: f8c3 2744    	str.w	r2, [r3, #0x744]
; 		data->handler_drdy_gyr = handler;
 8022c3c: 697b         	ldr	r3, [r7, #0x14]
 8022c3e: 687a         	ldr	r2, [r7, #0x4]
 8022c40: f8c3 2740    	str.w	r2, [r3, #0x740]
; 		return 0;
 8022c44: 2300         	movs	r3, #0x0
 8022c46: e001         	b	0x8022c4c <bmi08x_trigger_set_gyr+0x3a> @ imm = #0x2
; 	return -ENOTSUP;
 8022c48: f06f 0385    	mvn	r3, #0x85
; }
 8022c4c: 4618         	mov	r0, r3
 8022c4e: 371c         	adds	r7, #0x1c
 8022c50: 46bd         	mov	sp, r7
 8022c52: f85d 7b04    	ldr	r7, [sp], #4
 8022c56: 4770         	bx	lr

08022c58 <device_is_ready>:
; {
 8022c58: b580         	push	{r7, lr}
 8022c5a: b082         	sub	sp, #0x8
 8022c5c: af00         	add	r7, sp, #0x0
 8022c5e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8022c60: 6878         	ldr	r0, [r7, #0x4]
 8022c62: f003 fb9c    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x3738
 8022c66: 4603         	mov	r3, r0
; }
 8022c68: 4618         	mov	r0, r3
 8022c6a: 3708         	adds	r7, #0x8
 8022c6c: 46bd         	mov	sp, r7
 8022c6e: bd80         	pop	{r7, pc}

08022c70 <k_work_delayable_from_work>:
; {
 8022c70: b480         	push	{r7}
 8022c72: b083         	sub	sp, #0xc
 8022c74: af00         	add	r7, sp, #0x0
 8022c76: 6078         	str	r0, [r7, #0x4]
; 	return CONTAINER_OF(work, struct k_work_delayable, work);
 8022c78: 687b         	ldr	r3, [r7, #0x4]
; }
 8022c7a: 4618         	mov	r0, r3
 8022c7c: 370c         	adds	r7, #0xc
 8022c7e: 46bd         	mov	sp, r7
 8022c80: f85d 7b04    	ldr	r7, [sp], #4
 8022c84: 4770         	bx	lr

08022c86 <clock_control_on>:
; {
 8022c86: b580         	push	{r7, lr}
 8022c88: b084         	sub	sp, #0x10
 8022c8a: af00         	add	r7, sp, #0x0
 8022c8c: 6078         	str	r0, [r7, #0x4]
 8022c8e: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8022c90: 687b         	ldr	r3, [r7, #0x4]
 8022c92: 689b         	ldr	r3, [r3, #0x8]
 8022c94: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8022c96: 68fb         	ldr	r3, [r7, #0xc]
 8022c98: 681b         	ldr	r3, [r3]
 8022c9a: 6839         	ldr	r1, [r7]
 8022c9c: 6878         	ldr	r0, [r7, #0x4]
 8022c9e: 4798         	blx	r3
 8022ca0: 4603         	mov	r3, r0
; }
 8022ca2: 4618         	mov	r0, r3
 8022ca4: 3710         	adds	r7, #0x10
 8022ca6: 46bd         	mov	sp, r7
 8022ca8: bd80         	pop	{r7, pc}

08022caa <clock_control_get_rate>:
; {
 8022caa: b580         	push	{r7, lr}
 8022cac: b086         	sub	sp, #0x18
 8022cae: af00         	add	r7, sp, #0x0
 8022cb0: 60f8         	str	r0, [r7, #0xc]
 8022cb2: 60b9         	str	r1, [r7, #0x8]
 8022cb4: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 8022cb6: 68fb         	ldr	r3, [r7, #0xc]
 8022cb8: 689b         	ldr	r3, [r3, #0x8]
 8022cba: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 8022cbc: 697b         	ldr	r3, [r7, #0x14]
 8022cbe: 68db         	ldr	r3, [r3, #0xc]
 8022cc0: 2b00         	cmp	r3, #0x0
 8022cc2: d102         	bne	0x8022cca <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8022cc4: f06f 0357    	mvn	r3, #0x57
 8022cc8: e006         	b	0x8022cd8 <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 8022cca: 697b         	ldr	r3, [r7, #0x14]
 8022ccc: 68db         	ldr	r3, [r3, #0xc]
 8022cce: 687a         	ldr	r2, [r7, #0x4]
 8022cd0: 68b9         	ldr	r1, [r7, #0x8]
 8022cd2: 68f8         	ldr	r0, [r7, #0xc]
 8022cd4: 4798         	blx	r3
 8022cd6: 4603         	mov	r3, r0
; }
 8022cd8: 4618         	mov	r0, r3
 8022cda: 3718         	adds	r7, #0x18
 8022cdc: 46bd         	mov	sp, r7
 8022cde: bd80         	pop	{r7, pc}

08022ce0 <dma_config>:
; {
 8022ce0: b580         	push	{r7, lr}
 8022ce2: b086         	sub	sp, #0x18
 8022ce4: af00         	add	r7, sp, #0x0
 8022ce6: 60f8         	str	r0, [r7, #0xc]
 8022ce8: 60b9         	str	r1, [r7, #0x8]
 8022cea: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_driver_api *api =
 8022cec: 68fb         	ldr	r3, [r7, #0xc]
 8022cee: 689b         	ldr	r3, [r3, #0x8]
 8022cf0: 617b         	str	r3, [r7, #0x14]
; 	return api->config(dev, channel, config);
 8022cf2: 697b         	ldr	r3, [r7, #0x14]
 8022cf4: 681b         	ldr	r3, [r3]
 8022cf6: 687a         	ldr	r2, [r7, #0x4]
 8022cf8: 68b9         	ldr	r1, [r7, #0x8]
 8022cfa: 68f8         	ldr	r0, [r7, #0xc]
 8022cfc: 4798         	blx	r3
 8022cfe: 4603         	mov	r3, r0
; }
 8022d00: 4618         	mov	r0, r3
 8022d02: 3718         	adds	r7, #0x18
 8022d04: 46bd         	mov	sp, r7
 8022d06: bd80         	pop	{r7, pc}

08022d08 <dma_reload>:
; {
 8022d08: b590         	push	{r4, r7, lr}
 8022d0a: b089         	sub	sp, #0x24
 8022d0c: af02         	add	r7, sp, #0x8
 8022d0e: 60f8         	str	r0, [r7, #0xc]
 8022d10: 60b9         	str	r1, [r7, #0x8]
 8022d12: 607a         	str	r2, [r7, #0x4]
 8022d14: 603b         	str	r3, [r7]
; 	const struct dma_driver_api *api =
 8022d16: 68fb         	ldr	r3, [r7, #0xc]
 8022d18: 689b         	ldr	r3, [r3, #0x8]
 8022d1a: 617b         	str	r3, [r7, #0x14]
; 	if (api->reload) {
 8022d1c: 697b         	ldr	r3, [r7, #0x14]
 8022d1e: 685b         	ldr	r3, [r3, #0x4]
 8022d20: 2b00         	cmp	r3, #0x0
 8022d22: d00a         	beq	0x8022d3a <dma_reload+0x32> @ imm = #0x14
; 		return api->reload(dev, channel, src, dst, size);
 8022d24: 697b         	ldr	r3, [r7, #0x14]
 8022d26: 685c         	ldr	r4, [r3, #0x4]
 8022d28: 6abb         	ldr	r3, [r7, #0x28]
 8022d2a: 9300         	str	r3, [sp]
 8022d2c: 683b         	ldr	r3, [r7]
 8022d2e: 687a         	ldr	r2, [r7, #0x4]
 8022d30: 68b9         	ldr	r1, [r7, #0x8]
 8022d32: 68f8         	ldr	r0, [r7, #0xc]
 8022d34: 47a0         	blx	r4
 8022d36: 4603         	mov	r3, r0
 8022d38: e001         	b	0x8022d3e <dma_reload+0x36> @ imm = #0x2
; 	return -ENOSYS;
 8022d3a: f06f 0357    	mvn	r3, #0x57
; }
 8022d3e: 4618         	mov	r0, r3
 8022d40: 371c         	adds	r7, #0x1c
 8022d42: 46bd         	mov	sp, r7
 8022d44: bd90         	pop	{r4, r7, pc}

08022d46 <z_impl_dma_start>:
; {
 8022d46: b580         	push	{r7, lr}
 8022d48: b084         	sub	sp, #0x10
 8022d4a: af00         	add	r7, sp, #0x0
 8022d4c: 6078         	str	r0, [r7, #0x4]
 8022d4e: 6039         	str	r1, [r7]
; 	const struct dma_driver_api *api =
 8022d50: 687b         	ldr	r3, [r7, #0x4]
 8022d52: 689b         	ldr	r3, [r3, #0x8]
 8022d54: 60fb         	str	r3, [r7, #0xc]
; 	return api->start(dev, channel);
 8022d56: 68fb         	ldr	r3, [r7, #0xc]
 8022d58: 689b         	ldr	r3, [r3, #0x8]
 8022d5a: 6839         	ldr	r1, [r7]
 8022d5c: 6878         	ldr	r0, [r7, #0x4]
 8022d5e: 4798         	blx	r3
 8022d60: 4603         	mov	r3, r0
; }
 8022d62: 4618         	mov	r0, r3
 8022d64: 3710         	adds	r7, #0x10
 8022d66: 46bd         	mov	sp, r7
 8022d68: bd80         	pop	{r7, pc}

08022d6a <z_impl_dma_stop>:
; {
 8022d6a: b580         	push	{r7, lr}
 8022d6c: b084         	sub	sp, #0x10
 8022d6e: af00         	add	r7, sp, #0x0
 8022d70: 6078         	str	r0, [r7, #0x4]
 8022d72: 6039         	str	r1, [r7]
; 	const struct dma_driver_api *api =
 8022d74: 687b         	ldr	r3, [r7, #0x4]
 8022d76: 689b         	ldr	r3, [r3, #0x8]
 8022d78: 60fb         	str	r3, [r7, #0xc]
; 	return api->stop(dev, channel);
 8022d7a: 68fb         	ldr	r3, [r7, #0xc]
 8022d7c: 68db         	ldr	r3, [r3, #0xc]
 8022d7e: 6839         	ldr	r1, [r7]
 8022d80: 6878         	ldr	r0, [r7, #0x4]
 8022d82: 4798         	blx	r3
 8022d84: 4603         	mov	r3, r0
; }
 8022d86: 4618         	mov	r0, r3
 8022d88: 3710         	adds	r7, #0x10
 8022d8a: 46bd         	mov	sp, r7
 8022d8c: bd80         	pop	{r7, pc}

08022d8e <dma_get_status>:
; {
 8022d8e: b580         	push	{r7, lr}
 8022d90: b086         	sub	sp, #0x18
 8022d92: af00         	add	r7, sp, #0x0
 8022d94: 60f8         	str	r0, [r7, #0xc]
 8022d96: 60b9         	str	r1, [r7, #0x8]
 8022d98: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_driver_api *api =
 8022d9a: 68fb         	ldr	r3, [r7, #0xc]
 8022d9c: 689b         	ldr	r3, [r3, #0x8]
 8022d9e: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_status) {
 8022da0: 697b         	ldr	r3, [r7, #0x14]
 8022da2: 699b         	ldr	r3, [r3, #0x18]
 8022da4: 2b00         	cmp	r3, #0x0
 8022da6: d007         	beq	0x8022db8 <dma_get_status+0x2a> @ imm = #0xe
; 		return api->get_status(dev, channel, stat);
 8022da8: 697b         	ldr	r3, [r7, #0x14]
 8022daa: 699b         	ldr	r3, [r3, #0x18]
 8022dac: 687a         	ldr	r2, [r7, #0x4]
 8022dae: 68b9         	ldr	r1, [r7, #0x8]
 8022db0: 68f8         	ldr	r0, [r7, #0xc]
 8022db2: 4798         	blx	r3
 8022db4: 4603         	mov	r3, r0
 8022db6: e001         	b	0x8022dbc <dma_get_status+0x2e> @ imm = #0x2
; 	return -ENOSYS;
 8022db8: f06f 0357    	mvn	r3, #0x57
; }
 8022dbc: 4618         	mov	r0, r3
 8022dbe: 3718         	adds	r7, #0x18
 8022dc0: 46bd         	mov	sp, r7
 8022dc2: bd80         	pop	{r7, pc}

08022dc4 <dma_start>:
; {
 8022dc4: b580         	push	{r7, lr}
 8022dc6: b082         	sub	sp, #0x8
 8022dc8: af00         	add	r7, sp, #0x0
 8022dca: 6078         	str	r0, [r7, #0x4]
 8022dcc: 6039         	str	r1, [r7]
; 	return z_impl_dma_start(dev, channel);
 8022dce: 6839         	ldr	r1, [r7]
 8022dd0: 6878         	ldr	r0, [r7, #0x4]
 8022dd2: f7ff ffb8    	bl	0x8022d46 <z_impl_dma_start> @ imm = #-0x90
 8022dd6: 4603         	mov	r3, r0
; }
 8022dd8: 4618         	mov	r0, r3
 8022dda: 3708         	adds	r7, #0x8
 8022ddc: 46bd         	mov	sp, r7
 8022dde: bd80         	pop	{r7, pc}

08022de0 <dma_stop>:
; {
 8022de0: b580         	push	{r7, lr}
 8022de2: b082         	sub	sp, #0x8
 8022de4: af00         	add	r7, sp, #0x0
 8022de6: 6078         	str	r0, [r7, #0x4]
 8022de8: 6039         	str	r1, [r7]
; 	return z_impl_dma_stop(dev, channel);
 8022dea: 6839         	ldr	r1, [r7]
 8022dec: 6878         	ldr	r0, [r7, #0x4]
 8022dee: f7ff ffbc    	bl	0x8022d6a <z_impl_dma_stop> @ imm = #-0x88
 8022df2: 4603         	mov	r3, r0
; }
 8022df4: 4618         	mov	r0, r3
 8022df6: 3708         	adds	r7, #0x8
 8022df8: 46bd         	mov	sp, r7
 8022dfa: bd80         	pop	{r7, pc}

08022dfc <pinctrl_apply_state_direct>:
; {
 8022dfc: b580         	push	{r7, lr}
 8022dfe: b084         	sub	sp, #0x10
 8022e00: af00         	add	r7, sp, #0x0
 8022e02: 6078         	str	r0, [r7, #0x4]
 8022e04: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 8022e06: 2300         	movs	r3, #0x0
 8022e08: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 8022e0a: 683b         	ldr	r3, [r7]
 8022e0c: 6818         	ldr	r0, [r3]
 8022e0e: 683b         	ldr	r3, [r7]
 8022e10: 791b         	ldrb	r3, [r3, #0x4]
 8022e12: 68fa         	ldr	r2, [r7, #0xc]
 8022e14: 4619         	mov	r1, r3
 8022e16: f7fe fd3f    	bl	0x8021898 <pinctrl_configure_pins> @ imm = #-0x1582
 8022e1a: 4603         	mov	r3, r0
; }
 8022e1c: 4618         	mov	r0, r3
 8022e1e: 3710         	adds	r7, #0x10
 8022e20: 46bd         	mov	sp, r7
 8022e22: bd80         	pop	{r7, pc}

08022e24 <pinctrl_apply_state>:
; {
 8022e24: b580         	push	{r7, lr}
 8022e26: b084         	sub	sp, #0x10
 8022e28: af00         	add	r7, sp, #0x0
 8022e2a: 6078         	str	r0, [r7, #0x4]
 8022e2c: 460b         	mov	r3, r1
 8022e2e: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 8022e30: f107 0208    	add.w	r2, r7, #0x8
 8022e34: 78fb         	ldrb	r3, [r7, #0x3]
 8022e36: 4619         	mov	r1, r3
 8022e38: 6878         	ldr	r0, [r7, #0x4]
 8022e3a: f7fe fcf5    	bl	0x8021828 <pinctrl_lookup_state> @ imm = #-0x1616
 8022e3e: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8022e40: 68fb         	ldr	r3, [r7, #0xc]
 8022e42: 2b00         	cmp	r3, #0x0
 8022e44: da01         	bge	0x8022e4a <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 8022e46: 68fb         	ldr	r3, [r7, #0xc]
 8022e48: e005         	b	0x8022e56 <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 8022e4a: 68bb         	ldr	r3, [r7, #0x8]
 8022e4c: 4619         	mov	r1, r3
 8022e4e: 6878         	ldr	r0, [r7, #0x4]
 8022e50: f7ff ffd4    	bl	0x8022dfc <pinctrl_apply_state_direct> @ imm = #-0x58
 8022e54: 4603         	mov	r3, r0
; }
 8022e56: 4618         	mov	r0, r3
 8022e58: 3710         	adds	r7, #0x10
 8022e5a: 46bd         	mov	sp, r7
 8022e5c: bd80         	pop	{r7, pc}

08022e5e <z_impl_reset_line_toggle>:
; {
 8022e5e: b580         	push	{r7, lr}
 8022e60: b084         	sub	sp, #0x10
 8022e62: af00         	add	r7, sp, #0x0
 8022e64: 6078         	str	r0, [r7, #0x4]
 8022e66: 6039         	str	r1, [r7]
; 	const struct reset_driver_api *api = (const struct reset_driver_api *)dev->api;
 8022e68: 687b         	ldr	r3, [r7, #0x4]
 8022e6a: 689b         	ldr	r3, [r3, #0x8]
 8022e6c: 60fb         	str	r3, [r7, #0xc]
; 	if (api->line_toggle == NULL) {
 8022e6e: 68fb         	ldr	r3, [r7, #0xc]
 8022e70: 68db         	ldr	r3, [r3, #0xc]
 8022e72: 2b00         	cmp	r3, #0x0
 8022e74: d102         	bne	0x8022e7c <z_impl_reset_line_toggle+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 8022e76: f06f 0357    	mvn	r3, #0x57
 8022e7a: e005         	b	0x8022e88 <z_impl_reset_line_toggle+0x2a> @ imm = #0xa
; 	return api->line_toggle(dev, id);
 8022e7c: 68fb         	ldr	r3, [r7, #0xc]
 8022e7e: 68db         	ldr	r3, [r3, #0xc]
 8022e80: 6839         	ldr	r1, [r7]
 8022e82: 6878         	ldr	r0, [r7, #0x4]
 8022e84: 4798         	blx	r3
 8022e86: 4603         	mov	r3, r0
; }
 8022e88: 4618         	mov	r0, r3
 8022e8a: 3710         	adds	r7, #0x10
 8022e8c: 46bd         	mov	sp, r7
 8022e8e: bd80         	pop	{r7, pc}

08022e90 <reset_line_toggle_dt>:
; {
 8022e90: b580         	push	{r7, lr}
 8022e92: b082         	sub	sp, #0x8
 8022e94: af00         	add	r7, sp, #0x0
 8022e96: 6078         	str	r0, [r7, #0x4]
; 	return reset_line_toggle(spec->dev, spec->id);
 8022e98: 687b         	ldr	r3, [r7, #0x4]
 8022e9a: 681a         	ldr	r2, [r3]
 8022e9c: 687b         	ldr	r3, [r7, #0x4]
 8022e9e: 685b         	ldr	r3, [r3, #0x4]
 8022ea0: 4619         	mov	r1, r3
 8022ea2: 4610         	mov	r0, r2
 8022ea4: f000 f805    	bl	0x8022eb2 <reset_line_toggle> @ imm = #0xa
 8022ea8: 4603         	mov	r3, r0
; }
 8022eaa: 4618         	mov	r0, r3
 8022eac: 3708         	adds	r7, #0x8
 8022eae: 46bd         	mov	sp, r7
 8022eb0: bd80         	pop	{r7, pc}

08022eb2 <reset_line_toggle>:
; {
 8022eb2: b580         	push	{r7, lr}
 8022eb4: b082         	sub	sp, #0x8
 8022eb6: af00         	add	r7, sp, #0x0
 8022eb8: 6078         	str	r0, [r7, #0x4]
 8022eba: 6039         	str	r1, [r7]
; 	return z_impl_reset_line_toggle(dev, id);
 8022ebc: 6839         	ldr	r1, [r7]
 8022ebe: 6878         	ldr	r0, [r7, #0x4]
 8022ec0: f7ff ffcd    	bl	0x8022e5e <z_impl_reset_line_toggle> @ imm = #-0x66
 8022ec4: 4603         	mov	r3, r0
; }
 8022ec6: 4618         	mov	r0, r3
 8022ec8: 3708         	adds	r7, #0x8
 8022eca: 46bd         	mov	sp, r7
 8022ecc: bd80         	pop	{r7, pc}

08022ece <LL_USART_Enable>:
; {
 8022ece: b480         	push	{r7}
 8022ed0: b083         	sub	sp, #0xc
 8022ed2: af00         	add	r7, sp, #0x0
 8022ed4: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR1, USART_CR1_UE);
 8022ed6: 687b         	ldr	r3, [r7, #0x4]
 8022ed8: 681b         	ldr	r3, [r3]
 8022eda: f043 0201    	orr	r2, r3, #0x1
 8022ede: 687b         	ldr	r3, [r7, #0x4]
 8022ee0: 601a         	str	r2, [r3]
; }
 8022ee2: bf00         	nop
 8022ee4: 370c         	adds	r7, #0xc
 8022ee6: 46bd         	mov	sp, r7
 8022ee8: f85d 7b04    	ldr	r7, [sp], #4
 8022eec: 4770         	bx	lr

08022eee <LL_USART_Disable>:
; {
 8022eee: b480         	push	{r7}
 8022ef0: b083         	sub	sp, #0xc
 8022ef2: af00         	add	r7, sp, #0x0
 8022ef4: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
 8022ef6: 687b         	ldr	r3, [r7, #0x4]
 8022ef8: 681b         	ldr	r3, [r3]
 8022efa: f023 0201    	bic	r2, r3, #0x1
 8022efe: 687b         	ldr	r3, [r7, #0x4]
 8022f00: 601a         	str	r2, [r3]
; }
 8022f02: bf00         	nop
 8022f04: 370c         	adds	r7, #0xc
 8022f06: 46bd         	mov	sp, r7
 8022f08: f85d 7b04    	ldr	r7, [sp], #4
 8022f0c: 4770         	bx	lr

08022f0e <LL_USART_EnableFIFO>:
; {
 8022f0e: b480         	push	{r7}
 8022f10: b083         	sub	sp, #0xc
 8022f12: af00         	add	r7, sp, #0x0
 8022f14: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR1, USART_CR1_FIFOEN);
 8022f16: 687b         	ldr	r3, [r7, #0x4]
 8022f18: 681b         	ldr	r3, [r3]
 8022f1a: f043 5200    	orr	r2, r3, #0x20000000
 8022f1e: 687b         	ldr	r3, [r7, #0x4]
 8022f20: 601a         	str	r2, [r3]
; }
 8022f22: bf00         	nop
 8022f24: 370c         	adds	r7, #0xc
 8022f26: 46bd         	mov	sp, r7
 8022f28: f85d 7b04    	ldr	r7, [sp], #4
 8022f2c: 4770         	bx	lr

08022f2e <LL_USART_SetTransferDirection>:
; {
 8022f2e: b480         	push	{r7}
 8022f30: b089         	sub	sp, #0x24
 8022f32: af00         	add	r7, sp, #0x0
 8022f34: 6078         	str	r0, [r7, #0x4]
 8022f36: 6039         	str	r1, [r7]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8022f38: 687b         	ldr	r3, [r7, #0x4]
 8022f3a: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8022f3c: 68fb         	ldr	r3, [r7, #0xc]
 8022f3e: e853 3f00    	ldrex	r3, [r3]
 8022f42: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8022f44: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8022f46: f023 030c    	bic	r3, r3, #0xc
 8022f4a: 683a         	ldr	r2, [r7]
 8022f4c: 4313         	orrs	r3, r2
 8022f4e: 61fb         	str	r3, [r7, #0x1c]
 8022f50: 687b         	ldr	r3, [r7, #0x4]
 8022f52: 69fa         	ldr	r2, [r7, #0x1c]
 8022f54: 61ba         	str	r2, [r7, #0x18]
 8022f56: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8022f58: 6979         	ldr	r1, [r7, #0x14]
 8022f5a: 69ba         	ldr	r2, [r7, #0x18]
 8022f5c: e841 2300    	strex	r3, r2, [r1]
 8022f60: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8022f62: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8022f64: 2b00         	cmp	r3, #0x0
 8022f66: d1e7         	bne	0x8022f38 <LL_USART_SetTransferDirection+0xa> @ imm = #-0x32
; }
 8022f68: bf00         	nop
 8022f6a: bf00         	nop
 8022f6c: 3724         	adds	r7, #0x24
 8022f6e: 46bd         	mov	sp, r7
 8022f70: f85d 7b04    	ldr	r7, [sp], #4
 8022f74: 4770         	bx	lr

08022f76 <LL_USART_SetParity>:
; {
 8022f76: b480         	push	{r7}
 8022f78: b083         	sub	sp, #0xc
 8022f7a: af00         	add	r7, sp, #0x0
 8022f7c: 6078         	str	r0, [r7, #0x4]
 8022f7e: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
 8022f80: 687b         	ldr	r3, [r7, #0x4]
 8022f82: 681b         	ldr	r3, [r3]
 8022f84: f423 62c0    	bic	r2, r3, #0x600
 8022f88: 683b         	ldr	r3, [r7]
 8022f8a: 431a         	orrs	r2, r3
 8022f8c: 687b         	ldr	r3, [r7, #0x4]
 8022f8e: 601a         	str	r2, [r3]
; }
 8022f90: bf00         	nop
 8022f92: 370c         	adds	r7, #0xc
 8022f94: 46bd         	mov	sp, r7
 8022f96: f85d 7b04    	ldr	r7, [sp], #4
 8022f9a: 4770         	bx	lr

08022f9c <LL_USART_GetParity>:
; {
 8022f9c: b480         	push	{r7}
 8022f9e: b083         	sub	sp, #0xc
 8022fa0: af00         	add	r7, sp, #0x0
 8022fa2: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
 8022fa4: 687b         	ldr	r3, [r7, #0x4]
 8022fa6: 681b         	ldr	r3, [r3]
 8022fa8: f403 63c0    	and	r3, r3, #0x600
; }
 8022fac: 4618         	mov	r0, r3
 8022fae: 370c         	adds	r7, #0xc
 8022fb0: 46bd         	mov	sp, r7
 8022fb2: f85d 7b04    	ldr	r7, [sp], #4
 8022fb6: 4770         	bx	lr

08022fb8 <LL_USART_SetDataWidth>:
; {
 8022fb8: b480         	push	{r7}
 8022fba: b083         	sub	sp, #0xc
 8022fbc: af00         	add	r7, sp, #0x0
 8022fbe: 6078         	str	r0, [r7, #0x4]
 8022fc0: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
 8022fc2: 687b         	ldr	r3, [r7, #0x4]
 8022fc4: 681b         	ldr	r3, [r3]
 8022fc6: f023 2210    	bic	r2, r3, #0x10001000
 8022fca: 683b         	ldr	r3, [r7]
 8022fcc: 431a         	orrs	r2, r3
 8022fce: 687b         	ldr	r3, [r7, #0x4]
 8022fd0: 601a         	str	r2, [r3]
; }
 8022fd2: bf00         	nop
 8022fd4: 370c         	adds	r7, #0xc
 8022fd6: 46bd         	mov	sp, r7
 8022fd8: f85d 7b04    	ldr	r7, [sp], #4
 8022fdc: 4770         	bx	lr

08022fde <LL_USART_GetDataWidth>:
; {
 8022fde: b480         	push	{r7}
 8022fe0: b083         	sub	sp, #0xc
 8022fe2: af00         	add	r7, sp, #0x0
 8022fe4: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
 8022fe6: 687b         	ldr	r3, [r7, #0x4]
 8022fe8: 681b         	ldr	r3, [r3]
 8022fea: f003 2310    	and	r3, r3, #0x10001000
; }
 8022fee: 4618         	mov	r0, r3
 8022ff0: 370c         	adds	r7, #0xc
 8022ff2: 46bd         	mov	sp, r7
 8022ff4: f85d 7b04    	ldr	r7, [sp], #4
 8022ff8: 4770         	bx	lr

08022ffa <LL_USART_SetOverSampling>:
; {
 8022ffa: b480         	push	{r7}
 8022ffc: b083         	sub	sp, #0xc
 8022ffe: af00         	add	r7, sp, #0x0
 8023000: 6078         	str	r0, [r7, #0x4]
 8023002: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_OVER8, OverSampling);
 8023004: 687b         	ldr	r3, [r7, #0x4]
 8023006: 681b         	ldr	r3, [r3]
 8023008: f423 4200    	bic	r2, r3, #0x8000
 802300c: 683b         	ldr	r3, [r7]
 802300e: 431a         	orrs	r2, r3
 8023010: 687b         	ldr	r3, [r7, #0x4]
 8023012: 601a         	str	r2, [r3]
; }
 8023014: bf00         	nop
 8023016: 370c         	adds	r7, #0xc
 8023018: 46bd         	mov	sp, r7
 802301a: f85d 7b04    	ldr	r7, [sp], #4
 802301e: 4770         	bx	lr

08023020 <LL_USART_SetStopBitsLength>:
; {
 8023020: b480         	push	{r7}
 8023022: b083         	sub	sp, #0xc
 8023024: af00         	add	r7, sp, #0x0
 8023026: 6078         	str	r0, [r7, #0x4]
 8023028: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 802302a: 687b         	ldr	r3, [r7, #0x4]
 802302c: 685b         	ldr	r3, [r3, #0x4]
 802302e: f423 5240    	bic	r2, r3, #0x3000
 8023032: 683b         	ldr	r3, [r7]
 8023034: 431a         	orrs	r2, r3
 8023036: 687b         	ldr	r3, [r7, #0x4]
 8023038: 605a         	str	r2, [r3, #0x4]
; }
 802303a: bf00         	nop
 802303c: 370c         	adds	r7, #0xc
 802303e: 46bd         	mov	sp, r7
 8023040: f85d 7b04    	ldr	r7, [sp], #4
 8023044: 4770         	bx	lr

08023046 <LL_USART_GetStopBitsLength>:
; {
 8023046: b480         	push	{r7}
 8023048: b083         	sub	sp, #0xc
 802304a: af00         	add	r7, sp, #0x0
 802304c: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
 802304e: 687b         	ldr	r3, [r7, #0x4]
 8023050: 685b         	ldr	r3, [r3, #0x4]
 8023052: f403 5340    	and	r3, r3, #0x3000
; }
 8023056: 4618         	mov	r0, r3
 8023058: 370c         	adds	r7, #0xc
 802305a: 46bd         	mov	sp, r7
 802305c: f85d 7b04    	ldr	r7, [sp], #4
 8023060: 4770         	bx	lr

08023062 <LL_USART_SetTXRXSwap>:
; {
 8023062: b480         	push	{r7}
 8023064: b083         	sub	sp, #0xc
 8023066: af00         	add	r7, sp, #0x0
 8023068: 6078         	str	r0, [r7, #0x4]
 802306a: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR2, USART_CR2_SWAP, SwapConfig);
 802306c: 687b         	ldr	r3, [r7, #0x4]
 802306e: 685b         	ldr	r3, [r3, #0x4]
 8023070: f423 4200    	bic	r2, r3, #0x8000
 8023074: 683b         	ldr	r3, [r7]
 8023076: 431a         	orrs	r2, r3
 8023078: 687b         	ldr	r3, [r7, #0x4]
 802307a: 605a         	str	r2, [r3, #0x4]
; }
 802307c: bf00         	nop
 802307e: 370c         	adds	r7, #0xc
 8023080: 46bd         	mov	sp, r7
 8023082: f85d 7b04    	ldr	r7, [sp], #4
 8023086: 4770         	bx	lr

08023088 <LL_USART_SetRXPinLevel>:
; {
 8023088: b480         	push	{r7}
 802308a: b083         	sub	sp, #0xc
 802308c: af00         	add	r7, sp, #0x0
 802308e: 6078         	str	r0, [r7, #0x4]
 8023090: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR2, USART_CR2_RXINV, PinInvMethod);
 8023092: 687b         	ldr	r3, [r7, #0x4]
 8023094: 685b         	ldr	r3, [r3, #0x4]
 8023096: f423 3280    	bic	r2, r3, #0x10000
 802309a: 683b         	ldr	r3, [r7]
 802309c: 431a         	orrs	r2, r3
 802309e: 687b         	ldr	r3, [r7, #0x4]
 80230a0: 605a         	str	r2, [r3, #0x4]
; }
 80230a2: bf00         	nop
 80230a4: 370c         	adds	r7, #0xc
 80230a6: 46bd         	mov	sp, r7
 80230a8: f85d 7b04    	ldr	r7, [sp], #4
 80230ac: 4770         	bx	lr

080230ae <LL_USART_SetTXPinLevel>:
; {
 80230ae: b480         	push	{r7}
 80230b0: b083         	sub	sp, #0xc
 80230b2: af00         	add	r7, sp, #0x0
 80230b4: 6078         	str	r0, [r7, #0x4]
 80230b6: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR2, USART_CR2_TXINV, PinInvMethod);
 80230b8: 687b         	ldr	r3, [r7, #0x4]
 80230ba: 685b         	ldr	r3, [r3, #0x4]
 80230bc: f423 3200    	bic	r2, r3, #0x20000
 80230c0: 683b         	ldr	r3, [r7]
 80230c2: 431a         	orrs	r2, r3
 80230c4: 687b         	ldr	r3, [r7, #0x4]
 80230c6: 605a         	str	r2, [r3, #0x4]
; }
 80230c8: bf00         	nop
 80230ca: 370c         	adds	r7, #0xc
 80230cc: 46bd         	mov	sp, r7
 80230ce: f85d 7b04    	ldr	r7, [sp], #4
 80230d2: 4770         	bx	lr

080230d4 <LL_USART_SetHWFlowCtrl>:
; {
 80230d4: b480         	push	{r7}
 80230d6: b083         	sub	sp, #0xc
 80230d8: af00         	add	r7, sp, #0x0
 80230da: 6078         	str	r0, [r7, #0x4]
 80230dc: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 80230de: 687b         	ldr	r3, [r7, #0x4]
 80230e0: 689b         	ldr	r3, [r3, #0x8]
 80230e2: f423 7240    	bic	r2, r3, #0x300
 80230e6: 683b         	ldr	r3, [r7]
 80230e8: 431a         	orrs	r2, r3
 80230ea: 687b         	ldr	r3, [r7, #0x4]
 80230ec: 609a         	str	r2, [r3, #0x8]
; }
 80230ee: bf00         	nop
 80230f0: 370c         	adds	r7, #0xc
 80230f2: 46bd         	mov	sp, r7
 80230f4: f85d 7b04    	ldr	r7, [sp], #4
 80230f8: 4770         	bx	lr

080230fa <LL_USART_GetHWFlowCtrl>:
; {
 80230fa: b480         	push	{r7}
 80230fc: b083         	sub	sp, #0xc
 80230fe: af00         	add	r7, sp, #0x0
 8023100: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
 8023102: 687b         	ldr	r3, [r7, #0x4]
 8023104: 689b         	ldr	r3, [r3, #0x8]
 8023106: f403 7340    	and	r3, r3, #0x300
; }
 802310a: 4618         	mov	r0, r3
 802310c: 370c         	adds	r7, #0xc
 802310e: 46bd         	mov	sp, r7
 8023110: f85d 7b04    	ldr	r7, [sp], #4
 8023114: 4770         	bx	lr

08023116 <LL_USART_EnableHalfDuplex>:
; {
 8023116: b480         	push	{r7}
 8023118: b083         	sub	sp, #0xc
 802311a: af00         	add	r7, sp, #0x0
 802311c: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
 802311e: 687b         	ldr	r3, [r7, #0x4]
 8023120: 689b         	ldr	r3, [r3, #0x8]
 8023122: f043 0208    	orr	r2, r3, #0x8
 8023126: 687b         	ldr	r3, [r7, #0x4]
 8023128: 609a         	str	r2, [r3, #0x8]
; }
 802312a: bf00         	nop
 802312c: 370c         	adds	r7, #0xc
 802312e: 46bd         	mov	sp, r7
 8023130: f85d 7b04    	ldr	r7, [sp], #4
 8023134: 4770         	bx	lr

08023136 <LL_USART_SetDEDeassertionTime>:
; {
 8023136: b480         	push	{r7}
 8023138: b083         	sub	sp, #0xc
 802313a: af00         	add	r7, sp, #0x0
 802313c: 6078         	str	r0, [r7, #0x4]
 802313e: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_DEDT, Time << USART_CR1_DEDT_Pos);
 8023140: 687b         	ldr	r3, [r7, #0x4]
 8023142: 681b         	ldr	r3, [r3]
 8023144: f423 12f8    	bic	r2, r3, #0x1f0000
 8023148: 683b         	ldr	r3, [r7]
 802314a: 041b         	lsls	r3, r3, #0x10
 802314c: 431a         	orrs	r2, r3
 802314e: 687b         	ldr	r3, [r7, #0x4]
 8023150: 601a         	str	r2, [r3]
; }
 8023152: bf00         	nop
 8023154: 370c         	adds	r7, #0xc
 8023156: 46bd         	mov	sp, r7
 8023158: f85d 7b04    	ldr	r7, [sp], #4
 802315c: 4770         	bx	lr

0802315e <LL_USART_SetDEAssertionTime>:
; {
 802315e: b480         	push	{r7}
 8023160: b083         	sub	sp, #0xc
 8023162: af00         	add	r7, sp, #0x0
 8023164: 6078         	str	r0, [r7, #0x4]
 8023166: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_DEAT, Time << USART_CR1_DEAT_Pos);
 8023168: 687b         	ldr	r3, [r7, #0x4]
 802316a: 681b         	ldr	r3, [r3]
 802316c: f023 7278    	bic	r2, r3, #0x3e00000
 8023170: 683b         	ldr	r3, [r7]
 8023172: 055b         	lsls	r3, r3, #0x15
 8023174: 431a         	orrs	r2, r3
 8023176: 687b         	ldr	r3, [r7, #0x4]
 8023178: 601a         	str	r2, [r3]
; }
 802317a: bf00         	nop
 802317c: 370c         	adds	r7, #0xc
 802317e: 46bd         	mov	sp, r7
 8023180: f85d 7b04    	ldr	r7, [sp], #4
 8023184: 4770         	bx	lr

08023186 <LL_USART_EnableDEMode>:
; {
 8023186: b480         	push	{r7}
 8023188: b083         	sub	sp, #0xc
 802318a: af00         	add	r7, sp, #0x0
 802318c: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR3, USART_CR3_DEM);
 802318e: 687b         	ldr	r3, [r7, #0x4]
 8023190: 689b         	ldr	r3, [r3, #0x8]
 8023192: f443 4280    	orr	r2, r3, #0x4000
 8023196: 687b         	ldr	r3, [r7, #0x4]
 8023198: 609a         	str	r2, [r3, #0x8]
; }
 802319a: bf00         	nop
 802319c: 370c         	adds	r7, #0xc
 802319e: 46bd         	mov	sp, r7
 80231a0: f85d 7b04    	ldr	r7, [sp], #4
 80231a4: 4770         	bx	lr

080231a6 <LL_USART_DisableDEMode>:
; {
 80231a6: b480         	push	{r7}
 80231a8: b083         	sub	sp, #0xc
 80231aa: af00         	add	r7, sp, #0x0
 80231ac: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR3, USART_CR3_DEM);
 80231ae: 687b         	ldr	r3, [r7, #0x4]
 80231b0: 689b         	ldr	r3, [r3, #0x8]
 80231b2: f423 4280    	bic	r2, r3, #0x4000
 80231b6: 687b         	ldr	r3, [r7, #0x4]
 80231b8: 609a         	str	r2, [r3, #0x8]
; }
 80231ba: bf00         	nop
 80231bc: 370c         	adds	r7, #0xc
 80231be: 46bd         	mov	sp, r7
 80231c0: f85d 7b04    	ldr	r7, [sp], #4
 80231c4: 4770         	bx	lr

080231c6 <LL_USART_IsEnabledDEMode>:
; {
 80231c6: b480         	push	{r7}
 80231c8: b083         	sub	sp, #0xc
 80231ca: af00         	add	r7, sp, #0x0
 80231cc: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->CR3, USART_CR3_DEM) == (USART_CR3_DEM)) ? 1UL : 0UL);
 80231ce: 687b         	ldr	r3, [r7, #0x4]
 80231d0: 689b         	ldr	r3, [r3, #0x8]
 80231d2: f403 4380    	and	r3, r3, #0x4000
 80231d6: f5b3 4f80    	cmp.w	r3, #0x4000
 80231da: d101         	bne	0x80231e0 <LL_USART_IsEnabledDEMode+0x1a> @ imm = #0x2
 80231dc: 2301         	movs	r3, #0x1
 80231de: e000         	b	0x80231e2 <LL_USART_IsEnabledDEMode+0x1c> @ imm = #0x0
 80231e0: 2300         	movs	r3, #0x0
; }
 80231e2: 4618         	mov	r0, r3
 80231e4: 370c         	adds	r7, #0xc
 80231e6: 46bd         	mov	sp, r7
 80231e8: f85d 7b04    	ldr	r7, [sp], #4
 80231ec: 4770         	bx	lr

080231ee <LL_USART_SetDESignalPolarity>:
; {
 80231ee: b480         	push	{r7}
 80231f0: b083         	sub	sp, #0xc
 80231f2: af00         	add	r7, sp, #0x0
 80231f4: 6078         	str	r0, [r7, #0x4]
 80231f6: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR3, USART_CR3_DEP, Polarity);
 80231f8: 687b         	ldr	r3, [r7, #0x4]
 80231fa: 689b         	ldr	r3, [r3, #0x8]
 80231fc: f423 4200    	bic	r2, r3, #0x8000
 8023200: 683b         	ldr	r3, [r7]
 8023202: 431a         	orrs	r2, r3
 8023204: 687b         	ldr	r3, [r7, #0x4]
 8023206: 609a         	str	r2, [r3, #0x8]
; }
 8023208: bf00         	nop
 802320a: 370c         	adds	r7, #0xc
 802320c: 46bd         	mov	sp, r7
 802320e: f85d 7b04    	ldr	r7, [sp], #4
 8023212: 4770         	bx	lr

08023214 <LL_USART_IsActiveFlag_PE>:
; {
 8023214: b480         	push	{r7}
 8023216: b083         	sub	sp, #0xc
 8023218: af00         	add	r7, sp, #0x0
 802321a: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->ISR, USART_ISR_PE) == (USART_ISR_PE)) ? 1UL : 0UL);
 802321c: 687b         	ldr	r3, [r7, #0x4]
 802321e: 69db         	ldr	r3, [r3, #0x1c]
 8023220: f003 0301    	and	r3, r3, #0x1
 8023224: 2b01         	cmp	r3, #0x1
 8023226: d101         	bne	0x802322c <LL_USART_IsActiveFlag_PE+0x18> @ imm = #0x2
 8023228: 2301         	movs	r3, #0x1
 802322a: e000         	b	0x802322e <LL_USART_IsActiveFlag_PE+0x1a> @ imm = #0x0
 802322c: 2300         	movs	r3, #0x0
; }
 802322e: 4618         	mov	r0, r3
 8023230: 370c         	adds	r7, #0xc
 8023232: 46bd         	mov	sp, r7
 8023234: f85d 7b04    	ldr	r7, [sp], #4
 8023238: 4770         	bx	lr

0802323a <LL_USART_IsActiveFlag_FE>:
; {
 802323a: b480         	push	{r7}
 802323c: b083         	sub	sp, #0xc
 802323e: af00         	add	r7, sp, #0x0
 8023240: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->ISR, USART_ISR_FE) == (USART_ISR_FE)) ? 1UL : 0UL);
 8023242: 687b         	ldr	r3, [r7, #0x4]
 8023244: 69db         	ldr	r3, [r3, #0x1c]
 8023246: f003 0302    	and	r3, r3, #0x2
 802324a: 2b02         	cmp	r3, #0x2
 802324c: d101         	bne	0x8023252 <LL_USART_IsActiveFlag_FE+0x18> @ imm = #0x2
 802324e: 2301         	movs	r3, #0x1
 8023250: e000         	b	0x8023254 <LL_USART_IsActiveFlag_FE+0x1a> @ imm = #0x0
 8023252: 2300         	movs	r3, #0x0
; }
 8023254: 4618         	mov	r0, r3
 8023256: 370c         	adds	r7, #0xc
 8023258: 46bd         	mov	sp, r7
 802325a: f85d 7b04    	ldr	r7, [sp], #4
 802325e: 4770         	bx	lr

08023260 <LL_USART_IsActiveFlag_NE>:
; {
 8023260: b480         	push	{r7}
 8023262: b083         	sub	sp, #0xc
 8023264: af00         	add	r7, sp, #0x0
 8023266: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->ISR, USART_ISR_NE) == (USART_ISR_NE)) ? 1UL : 0UL);
 8023268: 687b         	ldr	r3, [r7, #0x4]
 802326a: 69db         	ldr	r3, [r3, #0x1c]
 802326c: f003 0304    	and	r3, r3, #0x4
 8023270: 2b04         	cmp	r3, #0x4
 8023272: d101         	bne	0x8023278 <LL_USART_IsActiveFlag_NE+0x18> @ imm = #0x2
 8023274: 2301         	movs	r3, #0x1
 8023276: e000         	b	0x802327a <LL_USART_IsActiveFlag_NE+0x1a> @ imm = #0x0
 8023278: 2300         	movs	r3, #0x0
; }
 802327a: 4618         	mov	r0, r3
 802327c: 370c         	adds	r7, #0xc
 802327e: 46bd         	mov	sp, r7
 8023280: f85d 7b04    	ldr	r7, [sp], #4
 8023284: 4770         	bx	lr

08023286 <LL_USART_IsActiveFlag_ORE>:
; {
 8023286: b480         	push	{r7}
 8023288: b083         	sub	sp, #0xc
 802328a: af00         	add	r7, sp, #0x0
 802328c: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
 802328e: 687b         	ldr	r3, [r7, #0x4]
 8023290: 69db         	ldr	r3, [r3, #0x1c]
 8023292: f003 0308    	and	r3, r3, #0x8
 8023296: 2b08         	cmp	r3, #0x8
 8023298: d101         	bne	0x802329e <LL_USART_IsActiveFlag_ORE+0x18> @ imm = #0x2
 802329a: 2301         	movs	r3, #0x1
 802329c: e000         	b	0x80232a0 <LL_USART_IsActiveFlag_ORE+0x1a> @ imm = #0x0
 802329e: 2300         	movs	r3, #0x0
; }
 80232a0: 4618         	mov	r0, r3
 80232a2: 370c         	adds	r7, #0xc
 80232a4: 46bd         	mov	sp, r7
 80232a6: f85d 7b04    	ldr	r7, [sp], #4
 80232aa: 4770         	bx	lr

080232ac <LL_USART_IsActiveFlag_IDLE>:
; {
 80232ac: b480         	push	{r7}
 80232ae: b083         	sub	sp, #0xc
 80232b0: af00         	add	r7, sp, #0x0
 80232b2: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->ISR, USART_ISR_IDLE) == (USART_ISR_IDLE)) ? 1UL : 0UL);
 80232b4: 687b         	ldr	r3, [r7, #0x4]
 80232b6: 69db         	ldr	r3, [r3, #0x1c]
 80232b8: f003 0310    	and	r3, r3, #0x10
 80232bc: 2b10         	cmp	r3, #0x10
 80232be: d101         	bne	0x80232c4 <LL_USART_IsActiveFlag_IDLE+0x18> @ imm = #0x2
 80232c0: 2301         	movs	r3, #0x1
 80232c2: e000         	b	0x80232c6 <LL_USART_IsActiveFlag_IDLE+0x1a> @ imm = #0x0
 80232c4: 2300         	movs	r3, #0x0
; }
 80232c6: 4618         	mov	r0, r3
 80232c8: 370c         	adds	r7, #0xc
 80232ca: 46bd         	mov	sp, r7
 80232cc: f85d 7b04    	ldr	r7, [sp], #4
 80232d0: 4770         	bx	lr

080232d2 <LL_USART_IsActiveFlag_RXNE_RXFNE>:
; {
 80232d2: b480         	push	{r7}
 80232d4: b083         	sub	sp, #0xc
 80232d6: af00         	add	r7, sp, #0x0
 80232d8: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->ISR, USART_ISR_RXNE_RXFNE) == (USART_ISR_RXNE_RXFNE)) ? 1UL : 0UL);
 80232da: 687b         	ldr	r3, [r7, #0x4]
 80232dc: 69db         	ldr	r3, [r3, #0x1c]
 80232de: f003 0320    	and	r3, r3, #0x20
 80232e2: 2b20         	cmp	r3, #0x20
 80232e4: d101         	bne	0x80232ea <LL_USART_IsActiveFlag_RXNE_RXFNE+0x18> @ imm = #0x2
 80232e6: 2301         	movs	r3, #0x1
 80232e8: e000         	b	0x80232ec <LL_USART_IsActiveFlag_RXNE_RXFNE+0x1a> @ imm = #0x0
 80232ea: 2300         	movs	r3, #0x0
; }
 80232ec: 4618         	mov	r0, r3
 80232ee: 370c         	adds	r7, #0xc
 80232f0: 46bd         	mov	sp, r7
 80232f2: f85d 7b04    	ldr	r7, [sp], #4
 80232f6: 4770         	bx	lr

080232f8 <LL_USART_IsActiveFlag_TC>:
; {
 80232f8: b480         	push	{r7}
 80232fa: b083         	sub	sp, #0xc
 80232fc: af00         	add	r7, sp, #0x0
 80232fe: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->ISR, USART_ISR_TC) == (USART_ISR_TC)) ? 1UL : 0UL);
 8023300: 687b         	ldr	r3, [r7, #0x4]
 8023302: 69db         	ldr	r3, [r3, #0x1c]
 8023304: f003 0340    	and	r3, r3, #0x40
 8023308: 2b40         	cmp	r3, #0x40
 802330a: d101         	bne	0x8023310 <LL_USART_IsActiveFlag_TC+0x18> @ imm = #0x2
 802330c: 2301         	movs	r3, #0x1
 802330e: e000         	b	0x8023312 <LL_USART_IsActiveFlag_TC+0x1a> @ imm = #0x0
 8023310: 2300         	movs	r3, #0x0
; }
 8023312: 4618         	mov	r0, r3
 8023314: 370c         	adds	r7, #0xc
 8023316: 46bd         	mov	sp, r7
 8023318: f85d 7b04    	ldr	r7, [sp], #4
 802331c: 4770         	bx	lr

0802331e <LL_USART_IsActiveFlag_TXE_TXFNF>:
; {
 802331e: b480         	push	{r7}
 8023320: b083         	sub	sp, #0xc
 8023322: af00         	add	r7, sp, #0x0
 8023324: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->ISR, USART_ISR_TXE_TXFNF) == (USART_ISR_TXE_TXFNF)) ? 1UL : 0UL);
 8023326: 687b         	ldr	r3, [r7, #0x4]
 8023328: 69db         	ldr	r3, [r3, #0x1c]
 802332a: f003 0380    	and	r3, r3, #0x80
 802332e: 2b80         	cmp	r3, #0x80
 8023330: d101         	bne	0x8023336 <LL_USART_IsActiveFlag_TXE_TXFNF+0x18> @ imm = #0x2
 8023332: 2301         	movs	r3, #0x1
 8023334: e000         	b	0x8023338 <LL_USART_IsActiveFlag_TXE_TXFNF+0x1a> @ imm = #0x0
 8023336: 2300         	movs	r3, #0x0
; }
 8023338: 4618         	mov	r0, r3
 802333a: 370c         	adds	r7, #0xc
 802333c: 46bd         	mov	sp, r7
 802333e: f85d 7b04    	ldr	r7, [sp], #4
 8023342: 4770         	bx	lr

08023344 <LL_USART_IsActiveFlag_LBD>:
; {
 8023344: b480         	push	{r7}
 8023346: b083         	sub	sp, #0xc
 8023348: af00         	add	r7, sp, #0x0
 802334a: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->ISR, USART_ISR_LBDF) == (USART_ISR_LBDF)) ? 1UL : 0UL);
 802334c: 687b         	ldr	r3, [r7, #0x4]
 802334e: 69db         	ldr	r3, [r3, #0x1c]
 8023350: f403 7380    	and	r3, r3, #0x100
 8023354: f5b3 7f80    	cmp.w	r3, #0x100
 8023358: d101         	bne	0x802335e <LL_USART_IsActiveFlag_LBD+0x1a> @ imm = #0x2
 802335a: 2301         	movs	r3, #0x1
 802335c: e000         	b	0x8023360 <LL_USART_IsActiveFlag_LBD+0x1c> @ imm = #0x0
 802335e: 2300         	movs	r3, #0x0
; }
 8023360: 4618         	mov	r0, r3
 8023362: 370c         	adds	r7, #0xc
 8023364: 46bd         	mov	sp, r7
 8023366: f85d 7b04    	ldr	r7, [sp], #4
 802336a: 4770         	bx	lr

0802336c <LL_USART_IsActiveFlag_TEACK>:
; {
 802336c: b480         	push	{r7}
 802336e: b083         	sub	sp, #0xc
 8023370: af00         	add	r7, sp, #0x0
 8023372: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->ISR, USART_ISR_TEACK) == (USART_ISR_TEACK)) ? 1UL : 0UL);
 8023374: 687b         	ldr	r3, [r7, #0x4]
 8023376: 69db         	ldr	r3, [r3, #0x1c]
 8023378: f403 1300    	and	r3, r3, #0x200000
 802337c: f5b3 1f00    	cmp.w	r3, #0x200000
 8023380: d101         	bne	0x8023386 <LL_USART_IsActiveFlag_TEACK+0x1a> @ imm = #0x2
 8023382: 2301         	movs	r3, #0x1
 8023384: e000         	b	0x8023388 <LL_USART_IsActiveFlag_TEACK+0x1c> @ imm = #0x0
 8023386: 2300         	movs	r3, #0x0
; }
 8023388: 4618         	mov	r0, r3
 802338a: 370c         	adds	r7, #0xc
 802338c: 46bd         	mov	sp, r7
 802338e: f85d 7b04    	ldr	r7, [sp], #4
 8023392: 4770         	bx	lr

08023394 <LL_USART_IsActiveFlag_REACK>:
; {
 8023394: b480         	push	{r7}
 8023396: b083         	sub	sp, #0xc
 8023398: af00         	add	r7, sp, #0x0
 802339a: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->ISR, USART_ISR_REACK) == (USART_ISR_REACK)) ? 1UL : 0UL);
 802339c: 687b         	ldr	r3, [r7, #0x4]
 802339e: 69db         	ldr	r3, [r3, #0x1c]
 80233a0: f403 0380    	and	r3, r3, #0x400000
 80233a4: f5b3 0f80    	cmp.w	r3, #0x400000
 80233a8: d101         	bne	0x80233ae <LL_USART_IsActiveFlag_REACK+0x1a> @ imm = #0x2
 80233aa: 2301         	movs	r3, #0x1
 80233ac: e000         	b	0x80233b0 <LL_USART_IsActiveFlag_REACK+0x1c> @ imm = #0x0
 80233ae: 2300         	movs	r3, #0x0
; }
 80233b0: 4618         	mov	r0, r3
 80233b2: 370c         	adds	r7, #0xc
 80233b4: 46bd         	mov	sp, r7
 80233b6: f85d 7b04    	ldr	r7, [sp], #4
 80233ba: 4770         	bx	lr

080233bc <LL_USART_ClearFlag_PE>:
; {
 80233bc: b480         	push	{r7}
 80233be: b083         	sub	sp, #0xc
 80233c0: af00         	add	r7, sp, #0x0
 80233c2: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->ICR, USART_ICR_PECF);
 80233c4: 687b         	ldr	r3, [r7, #0x4]
 80233c6: 2201         	movs	r2, #0x1
 80233c8: 621a         	str	r2, [r3, #0x20]
; }
 80233ca: bf00         	nop
 80233cc: 370c         	adds	r7, #0xc
 80233ce: 46bd         	mov	sp, r7
 80233d0: f85d 7b04    	ldr	r7, [sp], #4
 80233d4: 4770         	bx	lr

080233d6 <LL_USART_ClearFlag_FE>:
; {
 80233d6: b480         	push	{r7}
 80233d8: b083         	sub	sp, #0xc
 80233da: af00         	add	r7, sp, #0x0
 80233dc: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->ICR, USART_ICR_FECF);
 80233de: 687b         	ldr	r3, [r7, #0x4]
 80233e0: 2202         	movs	r2, #0x2
 80233e2: 621a         	str	r2, [r3, #0x20]
; }
 80233e4: bf00         	nop
 80233e6: 370c         	adds	r7, #0xc
 80233e8: 46bd         	mov	sp, r7
 80233ea: f85d 7b04    	ldr	r7, [sp], #4
 80233ee: 4770         	bx	lr

080233f0 <LL_USART_ClearFlag_NE>:
; {
 80233f0: b480         	push	{r7}
 80233f2: b083         	sub	sp, #0xc
 80233f4: af00         	add	r7, sp, #0x0
 80233f6: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->ICR, USART_ICR_NECF);
 80233f8: 687b         	ldr	r3, [r7, #0x4]
 80233fa: 2204         	movs	r2, #0x4
 80233fc: 621a         	str	r2, [r3, #0x20]
; }
 80233fe: bf00         	nop
 8023400: 370c         	adds	r7, #0xc
 8023402: 46bd         	mov	sp, r7
 8023404: f85d 7b04    	ldr	r7, [sp], #4
 8023408: 4770         	bx	lr

0802340a <LL_USART_ClearFlag_ORE>:
; {
 802340a: b480         	push	{r7}
 802340c: b083         	sub	sp, #0xc
 802340e: af00         	add	r7, sp, #0x0
 8023410: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->ICR, USART_ICR_ORECF);
 8023412: 687b         	ldr	r3, [r7, #0x4]
 8023414: 2208         	movs	r2, #0x8
 8023416: 621a         	str	r2, [r3, #0x20]
; }
 8023418: bf00         	nop
 802341a: 370c         	adds	r7, #0xc
 802341c: 46bd         	mov	sp, r7
 802341e: f85d 7b04    	ldr	r7, [sp], #4
 8023422: 4770         	bx	lr

08023424 <LL_USART_ClearFlag_IDLE>:
; {
 8023424: b480         	push	{r7}
 8023426: b083         	sub	sp, #0xc
 8023428: af00         	add	r7, sp, #0x0
 802342a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->ICR, USART_ICR_IDLECF);
 802342c: 687b         	ldr	r3, [r7, #0x4]
 802342e: 2210         	movs	r2, #0x10
 8023430: 621a         	str	r2, [r3, #0x20]
; }
 8023432: bf00         	nop
 8023434: 370c         	adds	r7, #0xc
 8023436: 46bd         	mov	sp, r7
 8023438: f85d 7b04    	ldr	r7, [sp], #4
 802343c: 4770         	bx	lr

0802343e <LL_USART_ClearFlag_TC>:
; {
 802343e: b480         	push	{r7}
 8023440: b083         	sub	sp, #0xc
 8023442: af00         	add	r7, sp, #0x0
 8023444: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8023446: 687b         	ldr	r3, [r7, #0x4]
 8023448: 2240         	movs	r2, #0x40
 802344a: 621a         	str	r2, [r3, #0x20]
; }
 802344c: bf00         	nop
 802344e: 370c         	adds	r7, #0xc
 8023450: 46bd         	mov	sp, r7
 8023452: f85d 7b04    	ldr	r7, [sp], #4
 8023456: 4770         	bx	lr

08023458 <LL_USART_ClearFlag_LBD>:
; {
 8023458: b480         	push	{r7}
 802345a: b083         	sub	sp, #0xc
 802345c: af00         	add	r7, sp, #0x0
 802345e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->ICR, USART_ICR_LBDCF);
 8023460: 687b         	ldr	r3, [r7, #0x4]
 8023462: f44f 7280    	mov.w	r2, #0x100
 8023466: 621a         	str	r2, [r3, #0x20]
; }
 8023468: bf00         	nop
 802346a: 370c         	adds	r7, #0xc
 802346c: 46bd         	mov	sp, r7
 802346e: f85d 7b04    	ldr	r7, [sp], #4
 8023472: 4770         	bx	lr

08023474 <LL_USART_EnableIT_IDLE>:
; {
 8023474: b480         	push	{r7}
 8023476: b089         	sub	sp, #0x24
 8023478: af00         	add	r7, sp, #0x0
 802347a: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 802347c: 687b         	ldr	r3, [r7, #0x4]
 802347e: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8023480: 68fb         	ldr	r3, [r7, #0xc]
 8023482: e853 3f00    	ldrex	r3, [r3]
 8023486: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8023488: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 802348a: f043 0310    	orr	r3, r3, #0x10
 802348e: 61fb         	str	r3, [r7, #0x1c]
 8023490: 687b         	ldr	r3, [r7, #0x4]
 8023492: 69fa         	ldr	r2, [r7, #0x1c]
 8023494: 61ba         	str	r2, [r7, #0x18]
 8023496: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8023498: 6979         	ldr	r1, [r7, #0x14]
 802349a: 69ba         	ldr	r2, [r7, #0x18]
 802349c: e841 2300    	strex	r3, r2, [r1]
 80234a0: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80234a2: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 80234a4: 2b00         	cmp	r3, #0x0
 80234a6: d1e9         	bne	0x802347c <LL_USART_EnableIT_IDLE+0x8> @ imm = #-0x2e
; }
 80234a8: bf00         	nop
 80234aa: bf00         	nop
 80234ac: 3724         	adds	r7, #0x24
 80234ae: 46bd         	mov	sp, r7
 80234b0: f85d 7b04    	ldr	r7, [sp], #4
 80234b4: 4770         	bx	lr

080234b6 <LL_USART_EnableIT_RXNE_RXFNE>:
; {
 80234b6: b480         	push	{r7}
 80234b8: b089         	sub	sp, #0x24
 80234ba: af00         	add	r7, sp, #0x0
 80234bc: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE);
 80234be: 687b         	ldr	r3, [r7, #0x4]
 80234c0: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80234c2: 68fb         	ldr	r3, [r7, #0xc]
 80234c4: e853 3f00    	ldrex	r3, [r3]
 80234c8: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80234ca: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE);
 80234cc: f043 0320    	orr	r3, r3, #0x20
 80234d0: 61fb         	str	r3, [r7, #0x1c]
 80234d2: 687b         	ldr	r3, [r7, #0x4]
 80234d4: 69fa         	ldr	r2, [r7, #0x1c]
 80234d6: 61ba         	str	r2, [r7, #0x18]
 80234d8: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80234da: 6979         	ldr	r1, [r7, #0x14]
 80234dc: 69ba         	ldr	r2, [r7, #0x18]
 80234de: e841 2300    	strex	r3, r2, [r1]
 80234e2: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80234e4: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE);
 80234e6: 2b00         	cmp	r3, #0x0
 80234e8: d1e9         	bne	0x80234be <LL_USART_EnableIT_RXNE_RXFNE+0x8> @ imm = #-0x2e
; }
 80234ea: bf00         	nop
 80234ec: bf00         	nop
 80234ee: 3724         	adds	r7, #0x24
 80234f0: 46bd         	mov	sp, r7
 80234f2: f85d 7b04    	ldr	r7, [sp], #4
 80234f6: 4770         	bx	lr

080234f8 <LL_USART_EnableIT_TC>:
; {
 80234f8: b480         	push	{r7}
 80234fa: b089         	sub	sp, #0x24
 80234fc: af00         	add	r7, sp, #0x0
 80234fe: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 8023500: 687b         	ldr	r3, [r7, #0x4]
 8023502: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8023504: 68fb         	ldr	r3, [r7, #0xc]
 8023506: e853 3f00    	ldrex	r3, [r3]
 802350a: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 802350c: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 802350e: f043 0340    	orr	r3, r3, #0x40
 8023512: 61fb         	str	r3, [r7, #0x1c]
 8023514: 687b         	ldr	r3, [r7, #0x4]
 8023516: 69fa         	ldr	r2, [r7, #0x1c]
 8023518: 61ba         	str	r2, [r7, #0x18]
 802351a: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802351c: 6979         	ldr	r1, [r7, #0x14]
 802351e: 69ba         	ldr	r2, [r7, #0x18]
 8023520: e841 2300    	strex	r3, r2, [r1]
 8023524: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8023526: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 8023528: 2b00         	cmp	r3, #0x0
 802352a: d1e9         	bne	0x8023500 <LL_USART_EnableIT_TC+0x8> @ imm = #-0x2e
; }
 802352c: bf00         	nop
 802352e: bf00         	nop
 8023530: 3724         	adds	r7, #0x24
 8023532: 46bd         	mov	sp, r7
 8023534: f85d 7b04    	ldr	r7, [sp], #4
 8023538: 4770         	bx	lr

0802353a <LL_USART_EnableIT_PE>:
; {
 802353a: b480         	push	{r7}
 802353c: b089         	sub	sp, #0x24
 802353e: af00         	add	r7, sp, #0x0
 8023540: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 8023542: 687b         	ldr	r3, [r7, #0x4]
 8023544: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8023546: 68fb         	ldr	r3, [r7, #0xc]
 8023548: e853 3f00    	ldrex	r3, [r3]
 802354c: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 802354e: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 8023550: f443 7380    	orr	r3, r3, #0x100
 8023554: 61fb         	str	r3, [r7, #0x1c]
 8023556: 687b         	ldr	r3, [r7, #0x4]
 8023558: 69fa         	ldr	r2, [r7, #0x1c]
 802355a: 61ba         	str	r2, [r7, #0x18]
 802355c: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802355e: 6979         	ldr	r1, [r7, #0x14]
 8023560: 69ba         	ldr	r2, [r7, #0x18]
 8023562: e841 2300    	strex	r3, r2, [r1]
 8023566: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8023568: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 802356a: 2b00         	cmp	r3, #0x0
 802356c: d1e9         	bne	0x8023542 <LL_USART_EnableIT_PE+0x8> @ imm = #-0x2e
; }
 802356e: bf00         	nop
 8023570: bf00         	nop
 8023572: 3724         	adds	r7, #0x24
 8023574: 46bd         	mov	sp, r7
 8023576: f85d 7b04    	ldr	r7, [sp], #4
 802357a: 4770         	bx	lr

0802357c <LL_USART_EnableIT_LBD>:
; {
 802357c: b480         	push	{r7}
 802357e: b083         	sub	sp, #0xc
 8023580: af00         	add	r7, sp, #0x0
 8023582: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR2, USART_CR2_LBDIE);
 8023584: 687b         	ldr	r3, [r7, #0x4]
 8023586: 685b         	ldr	r3, [r3, #0x4]
 8023588: f043 0240    	orr	r2, r3, #0x40
 802358c: 687b         	ldr	r3, [r7, #0x4]
 802358e: 605a         	str	r2, [r3, #0x4]
; }
 8023590: bf00         	nop
 8023592: 370c         	adds	r7, #0xc
 8023594: 46bd         	mov	sp, r7
 8023596: f85d 7b04    	ldr	r7, [sp], #4
 802359a: 4770         	bx	lr

0802359c <LL_USART_EnableIT_ERROR>:
; {
 802359c: b480         	push	{r7}
 802359e: b089         	sub	sp, #0x24
 80235a0: af00         	add	r7, sp, #0x0
 80235a2: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 80235a4: 687b         	ldr	r3, [r7, #0x4]
 80235a6: 3308         	adds	r3, #0x8
 80235a8: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80235aa: 68fb         	ldr	r3, [r7, #0xc]
 80235ac: e853 3f00    	ldrex	r3, [r3]
 80235b0: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80235b2: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 80235b4: f043 0301    	orr	r3, r3, #0x1
 80235b8: 61fb         	str	r3, [r7, #0x1c]
 80235ba: 687b         	ldr	r3, [r7, #0x4]
 80235bc: 3308         	adds	r3, #0x8
 80235be: 69fa         	ldr	r2, [r7, #0x1c]
 80235c0: 61ba         	str	r2, [r7, #0x18]
 80235c2: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80235c4: 6979         	ldr	r1, [r7, #0x14]
 80235c6: 69ba         	ldr	r2, [r7, #0x18]
 80235c8: e841 2300    	strex	r3, r2, [r1]
 80235cc: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80235ce: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 80235d0: 2b00         	cmp	r3, #0x0
 80235d2: d1e7         	bne	0x80235a4 <LL_USART_EnableIT_ERROR+0x8> @ imm = #-0x32
; }
 80235d4: bf00         	nop
 80235d6: bf00         	nop
 80235d8: 3724         	adds	r7, #0x24
 80235da: 46bd         	mov	sp, r7
 80235dc: f85d 7b04    	ldr	r7, [sp], #4
 80235e0: 4770         	bx	lr

080235e2 <LL_USART_DisableIT_IDLE>:
; {
 80235e2: b480         	push	{r7}
 80235e4: b089         	sub	sp, #0x24
 80235e6: af00         	add	r7, sp, #0x0
 80235e8: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 80235ea: 687b         	ldr	r3, [r7, #0x4]
 80235ec: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80235ee: 68fb         	ldr	r3, [r7, #0xc]
 80235f0: e853 3f00    	ldrex	r3, [r3]
 80235f4: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80235f6: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 80235f8: f023 0310    	bic	r3, r3, #0x10
 80235fc: 61fb         	str	r3, [r7, #0x1c]
 80235fe: 687b         	ldr	r3, [r7, #0x4]
 8023600: 69fa         	ldr	r2, [r7, #0x1c]
 8023602: 61ba         	str	r2, [r7, #0x18]
 8023604: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8023606: 6979         	ldr	r1, [r7, #0x14]
 8023608: 69ba         	ldr	r2, [r7, #0x18]
 802360a: e841 2300    	strex	r3, r2, [r1]
 802360e: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8023610: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8023612: 2b00         	cmp	r3, #0x0
 8023614: d1e9         	bne	0x80235ea <LL_USART_DisableIT_IDLE+0x8> @ imm = #-0x2e
; }
 8023616: bf00         	nop
 8023618: bf00         	nop
 802361a: 3724         	adds	r7, #0x24
 802361c: 46bd         	mov	sp, r7
 802361e: f85d 7b04    	ldr	r7, [sp], #4
 8023622: 4770         	bx	lr

08023624 <LL_USART_DisableIT_RXNE_RXFNE>:
; {
 8023624: b480         	push	{r7}
 8023626: b089         	sub	sp, #0x24
 8023628: af00         	add	r7, sp, #0x0
 802362a: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE);
 802362c: 687b         	ldr	r3, [r7, #0x4]
 802362e: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8023630: 68fb         	ldr	r3, [r7, #0xc]
 8023632: e853 3f00    	ldrex	r3, [r3]
 8023636: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8023638: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE);
 802363a: f023 0320    	bic	r3, r3, #0x20
 802363e: 61fb         	str	r3, [r7, #0x1c]
 8023640: 687b         	ldr	r3, [r7, #0x4]
 8023642: 69fa         	ldr	r2, [r7, #0x1c]
 8023644: 61ba         	str	r2, [r7, #0x18]
 8023646: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8023648: 6979         	ldr	r1, [r7, #0x14]
 802364a: 69ba         	ldr	r2, [r7, #0x18]
 802364c: e841 2300    	strex	r3, r2, [r1]
 8023650: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8023652: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8023654: 2b00         	cmp	r3, #0x0
 8023656: d1e9         	bne	0x802362c <LL_USART_DisableIT_RXNE_RXFNE+0x8> @ imm = #-0x2e
; }
 8023658: bf00         	nop
 802365a: bf00         	nop
 802365c: 3724         	adds	r7, #0x24
 802365e: 46bd         	mov	sp, r7
 8023660: f85d 7b04    	ldr	r7, [sp], #4
 8023664: 4770         	bx	lr

08023666 <LL_USART_DisableIT_TC>:
; {
 8023666: b480         	push	{r7}
 8023668: b089         	sub	sp, #0x24
 802366a: af00         	add	r7, sp, #0x0
 802366c: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 802366e: 687b         	ldr	r3, [r7, #0x4]
 8023670: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8023672: 68fb         	ldr	r3, [r7, #0xc]
 8023674: e853 3f00    	ldrex	r3, [r3]
 8023678: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 802367a: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 802367c: f023 0340    	bic	r3, r3, #0x40
 8023680: 61fb         	str	r3, [r7, #0x1c]
 8023682: 687b         	ldr	r3, [r7, #0x4]
 8023684: 69fa         	ldr	r2, [r7, #0x1c]
 8023686: 61ba         	str	r2, [r7, #0x18]
 8023688: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 802368a: 6979         	ldr	r1, [r7, #0x14]
 802368c: 69ba         	ldr	r2, [r7, #0x18]
 802368e: e841 2300    	strex	r3, r2, [r1]
 8023692: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8023694: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 8023696: 2b00         	cmp	r3, #0x0
 8023698: d1e9         	bne	0x802366e <LL_USART_DisableIT_TC+0x8> @ imm = #-0x2e
; }
 802369a: bf00         	nop
 802369c: bf00         	nop
 802369e: 3724         	adds	r7, #0x24
 80236a0: 46bd         	mov	sp, r7
 80236a2: f85d 7b04    	ldr	r7, [sp], #4
 80236a6: 4770         	bx	lr

080236a8 <LL_USART_DisableIT_PE>:
; {
 80236a8: b480         	push	{r7}
 80236aa: b089         	sub	sp, #0x24
 80236ac: af00         	add	r7, sp, #0x0
 80236ae: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 80236b0: 687b         	ldr	r3, [r7, #0x4]
 80236b2: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80236b4: 68fb         	ldr	r3, [r7, #0xc]
 80236b6: e853 3f00    	ldrex	r3, [r3]
 80236ba: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80236bc: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 80236be: f423 7380    	bic	r3, r3, #0x100
 80236c2: 61fb         	str	r3, [r7, #0x1c]
 80236c4: 687b         	ldr	r3, [r7, #0x4]
 80236c6: 69fa         	ldr	r2, [r7, #0x1c]
 80236c8: 61ba         	str	r2, [r7, #0x18]
 80236ca: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80236cc: 6979         	ldr	r1, [r7, #0x14]
 80236ce: 69ba         	ldr	r2, [r7, #0x18]
 80236d0: e841 2300    	strex	r3, r2, [r1]
 80236d4: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80236d6: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 80236d8: 2b00         	cmp	r3, #0x0
 80236da: d1e9         	bne	0x80236b0 <LL_USART_DisableIT_PE+0x8> @ imm = #-0x2e
; }
 80236dc: bf00         	nop
 80236de: bf00         	nop
 80236e0: 3724         	adds	r7, #0x24
 80236e2: 46bd         	mov	sp, r7
 80236e4: f85d 7b04    	ldr	r7, [sp], #4
 80236e8: 4770         	bx	lr

080236ea <LL_USART_DisableIT_LBD>:
; {
 80236ea: b480         	push	{r7}
 80236ec: b083         	sub	sp, #0xc
 80236ee: af00         	add	r7, sp, #0x0
 80236f0: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR2, USART_CR2_LBDIE);
 80236f2: 687b         	ldr	r3, [r7, #0x4]
 80236f4: 685b         	ldr	r3, [r3, #0x4]
 80236f6: f023 0240    	bic	r2, r3, #0x40
 80236fa: 687b         	ldr	r3, [r7, #0x4]
 80236fc: 605a         	str	r2, [r3, #0x4]
; }
 80236fe: bf00         	nop
 8023700: 370c         	adds	r7, #0xc
 8023702: 46bd         	mov	sp, r7
 8023704: f85d 7b04    	ldr	r7, [sp], #4
 8023708: 4770         	bx	lr

0802370a <LL_USART_DisableIT_ERROR>:
; {
 802370a: b480         	push	{r7}
 802370c: b089         	sub	sp, #0x24
 802370e: af00         	add	r7, sp, #0x0
 8023710: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8023712: 687b         	ldr	r3, [r7, #0x4]
 8023714: 3308         	adds	r3, #0x8
 8023716: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8023718: 68fb         	ldr	r3, [r7, #0xc]
 802371a: e853 3f00    	ldrex	r3, [r3]
 802371e: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8023720: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8023722: f023 0301    	bic	r3, r3, #0x1
 8023726: 61fb         	str	r3, [r7, #0x1c]
 8023728: 687b         	ldr	r3, [r7, #0x4]
 802372a: 3308         	adds	r3, #0x8
 802372c: 69fa         	ldr	r2, [r7, #0x1c]
 802372e: 61ba         	str	r2, [r7, #0x18]
 8023730: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8023732: 6979         	ldr	r1, [r7, #0x14]
 8023734: 69ba         	ldr	r2, [r7, #0x18]
 8023736: e841 2300    	strex	r3, r2, [r1]
 802373a: 613b         	str	r3, [r7, #0x10]
;    return(result);
 802373c: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 802373e: 2b00         	cmp	r3, #0x0
 8023740: d1e7         	bne	0x8023712 <LL_USART_DisableIT_ERROR+0x8> @ imm = #-0x32
; }
 8023742: bf00         	nop
 8023744: bf00         	nop
 8023746: 3724         	adds	r7, #0x24
 8023748: 46bd         	mov	sp, r7
 802374a: f85d 7b04    	ldr	r7, [sp], #4
 802374e: 4770         	bx	lr

08023750 <LL_USART_IsEnabledIT_IDLE>:
; {
 8023750: b480         	push	{r7}
 8023752: b083         	sub	sp, #0xc
 8023754: af00         	add	r7, sp, #0x0
 8023756: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE)) ? 1UL : 0UL);
 8023758: 687b         	ldr	r3, [r7, #0x4]
 802375a: 681b         	ldr	r3, [r3]
 802375c: f003 0310    	and	r3, r3, #0x10
 8023760: 2b10         	cmp	r3, #0x10
 8023762: d101         	bne	0x8023768 <LL_USART_IsEnabledIT_IDLE+0x18> @ imm = #0x2
 8023764: 2301         	movs	r3, #0x1
 8023766: e000         	b	0x802376a <LL_USART_IsEnabledIT_IDLE+0x1a> @ imm = #0x0
 8023768: 2300         	movs	r3, #0x0
; }
 802376a: 4618         	mov	r0, r3
 802376c: 370c         	adds	r7, #0xc
 802376e: 46bd         	mov	sp, r7
 8023770: f85d 7b04    	ldr	r7, [sp], #4
 8023774: 4770         	bx	lr

08023776 <LL_USART_IsEnabledIT_RXNE_RXFNE>:
; {
 8023776: b480         	push	{r7}
 8023778: b083         	sub	sp, #0xc
 802377a: af00         	add	r7, sp, #0x0
 802377c: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE) == (USART_CR1_RXNEIE_RXFNEIE)) ? 1UL : 0UL);
 802377e: 687b         	ldr	r3, [r7, #0x4]
 8023780: 681b         	ldr	r3, [r3]
 8023782: f003 0320    	and	r3, r3, #0x20
 8023786: 2b20         	cmp	r3, #0x20
 8023788: d101         	bne	0x802378e <LL_USART_IsEnabledIT_RXNE_RXFNE+0x18> @ imm = #0x2
 802378a: 2301         	movs	r3, #0x1
 802378c: e000         	b	0x8023790 <LL_USART_IsEnabledIT_RXNE_RXFNE+0x1a> @ imm = #0x0
 802378e: 2300         	movs	r3, #0x0
; }
 8023790: 4618         	mov	r0, r3
 8023792: 370c         	adds	r7, #0xc
 8023794: 46bd         	mov	sp, r7
 8023796: f85d 7b04    	ldr	r7, [sp], #4
 802379a: 4770         	bx	lr

0802379c <LL_USART_IsEnabledIT_TC>:
; {
 802379c: b480         	push	{r7}
 802379e: b083         	sub	sp, #0xc
 80237a0: af00         	add	r7, sp, #0x0
 80237a2: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(USARTx->CR1, USART_CR1_TCIE) == (USART_CR1_TCIE)) ? 1UL : 0UL);
 80237a4: 687b         	ldr	r3, [r7, #0x4]
 80237a6: 681b         	ldr	r3, [r3]
 80237a8: f003 0340    	and	r3, r3, #0x40
 80237ac: 2b40         	cmp	r3, #0x40
 80237ae: d101         	bne	0x80237b4 <LL_USART_IsEnabledIT_TC+0x18> @ imm = #0x2
 80237b0: 2301         	movs	r3, #0x1
 80237b2: e000         	b	0x80237b6 <LL_USART_IsEnabledIT_TC+0x1a> @ imm = #0x0
 80237b4: 2300         	movs	r3, #0x0
; }
 80237b6: 4618         	mov	r0, r3
 80237b8: 370c         	adds	r7, #0xc
 80237ba: 46bd         	mov	sp, r7
 80237bc: f85d 7b04    	ldr	r7, [sp], #4
 80237c0: 4770         	bx	lr

080237c2 <LL_USART_EnableDMAReq_RX>:
; {
 80237c2: b480         	push	{r7}
 80237c4: b089         	sub	sp, #0x24
 80237c6: af00         	add	r7, sp, #0x0
 80237c8: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 80237ca: 687b         	ldr	r3, [r7, #0x4]
 80237cc: 3308         	adds	r3, #0x8
 80237ce: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80237d0: 68fb         	ldr	r3, [r7, #0xc]
 80237d2: e853 3f00    	ldrex	r3, [r3]
 80237d6: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80237d8: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 80237da: f043 0340    	orr	r3, r3, #0x40
 80237de: 61fb         	str	r3, [r7, #0x1c]
 80237e0: 687b         	ldr	r3, [r7, #0x4]
 80237e2: 3308         	adds	r3, #0x8
 80237e4: 69fa         	ldr	r2, [r7, #0x1c]
 80237e6: 61ba         	str	r2, [r7, #0x18]
 80237e8: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80237ea: 6979         	ldr	r1, [r7, #0x14]
 80237ec: 69ba         	ldr	r2, [r7, #0x18]
 80237ee: e841 2300    	strex	r3, r2, [r1]
 80237f2: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80237f4: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 80237f6: 2b00         	cmp	r3, #0x0
 80237f8: d1e7         	bne	0x80237ca <LL_USART_EnableDMAReq_RX+0x8> @ imm = #-0x32
; }
 80237fa: bf00         	nop
 80237fc: bf00         	nop
 80237fe: 3724         	adds	r7, #0x24
 8023800: 46bd         	mov	sp, r7
 8023802: f85d 7b04    	ldr	r7, [sp], #4
 8023806: 4770         	bx	lr

08023808 <LL_USART_EnableDMAReq_TX>:
; {
 8023808: b480         	push	{r7}
 802380a: b089         	sub	sp, #0x24
 802380c: af00         	add	r7, sp, #0x0
 802380e: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 8023810: 687b         	ldr	r3, [r7, #0x4]
 8023812: 3308         	adds	r3, #0x8
 8023814: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8023816: 68fb         	ldr	r3, [r7, #0xc]
 8023818: e853 3f00    	ldrex	r3, [r3]
 802381c: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 802381e: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 8023820: f043 0380    	orr	r3, r3, #0x80
 8023824: 61fb         	str	r3, [r7, #0x1c]
 8023826: 687b         	ldr	r3, [r7, #0x4]
 8023828: 3308         	adds	r3, #0x8
 802382a: 69fa         	ldr	r2, [r7, #0x1c]
 802382c: 61ba         	str	r2, [r7, #0x18]
 802382e: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8023830: 6979         	ldr	r1, [r7, #0x14]
 8023832: 69ba         	ldr	r2, [r7, #0x18]
 8023834: e841 2300    	strex	r3, r2, [r1]
 8023838: 613b         	str	r3, [r7, #0x10]
;    return(result);
 802383a: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 802383c: 2b00         	cmp	r3, #0x0
 802383e: d1e7         	bne	0x8023810 <LL_USART_EnableDMAReq_TX+0x8> @ imm = #-0x32
; }
 8023840: bf00         	nop
 8023842: bf00         	nop
 8023844: 3724         	adds	r7, #0x24
 8023846: 46bd         	mov	sp, r7
 8023848: f85d 7b04    	ldr	r7, [sp], #4
 802384c: 4770         	bx	lr

0802384e <LL_USART_DisableDMAReq_TX>:
; {
 802384e: b480         	push	{r7}
 8023850: b089         	sub	sp, #0x24
 8023852: af00         	add	r7, sp, #0x0
 8023854: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 8023856: 687b         	ldr	r3, [r7, #0x4]
 8023858: 3308         	adds	r3, #0x8
 802385a: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802385c: 68fb         	ldr	r3, [r7, #0xc]
 802385e: e853 3f00    	ldrex	r3, [r3]
 8023862: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8023864: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 8023866: f023 0380    	bic	r3, r3, #0x80
 802386a: 61fb         	str	r3, [r7, #0x1c]
 802386c: 687b         	ldr	r3, [r7, #0x4]
 802386e: 3308         	adds	r3, #0x8
 8023870: 69fa         	ldr	r2, [r7, #0x1c]
 8023872: 61ba         	str	r2, [r7, #0x18]
 8023874: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8023876: 6979         	ldr	r1, [r7, #0x14]
 8023878: 69ba         	ldr	r2, [r7, #0x18]
 802387a: e841 2300    	strex	r3, r2, [r1]
 802387e: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8023880: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 8023882: 2b00         	cmp	r3, #0x0
 8023884: d1e7         	bne	0x8023856 <LL_USART_DisableDMAReq_TX+0x8> @ imm = #-0x32
; }
 8023886: bf00         	nop
 8023888: bf00         	nop
 802388a: 3724         	adds	r7, #0x24
 802388c: 46bd         	mov	sp, r7
 802388e: f85d 7b04    	ldr	r7, [sp], #4
 8023892: 4770         	bx	lr

08023894 <LL_USART_DMA_GetRegAddr>:
; {
 8023894: b480         	push	{r7}
 8023896: b085         	sub	sp, #0x14
 8023898: af00         	add	r7, sp, #0x0
 802389a: 6078         	str	r0, [r7, #0x4]
 802389c: 6039         	str	r1, [r7]
;   if (Direction == LL_USART_DMA_REG_DATA_TRANSMIT)
 802389e: 683b         	ldr	r3, [r7]
 80238a0: 2b00         	cmp	r3, #0x0
 80238a2: d103         	bne	0x80238ac <LL_USART_DMA_GetRegAddr+0x18> @ imm = #0x6
;     data_reg_addr = (uint32_t) &(USARTx->TDR);
 80238a4: 687b         	ldr	r3, [r7, #0x4]
 80238a6: 3328         	adds	r3, #0x28
 80238a8: 60fb         	str	r3, [r7, #0xc]
 80238aa: e002         	b	0x80238b2 <LL_USART_DMA_GetRegAddr+0x1e> @ imm = #0x4
;     data_reg_addr = (uint32_t) &(USARTx->RDR);
 80238ac: 687b         	ldr	r3, [r7, #0x4]
 80238ae: 3324         	adds	r3, #0x24
 80238b0: 60fb         	str	r3, [r7, #0xc]
;   return data_reg_addr;
 80238b2: 68fb         	ldr	r3, [r7, #0xc]
; }
 80238b4: 4618         	mov	r0, r3
 80238b6: 3714         	adds	r7, #0x14
 80238b8: 46bd         	mov	sp, r7
 80238ba: f85d 7b04    	ldr	r7, [sp], #4
 80238be: 4770         	bx	lr

080238c0 <LL_USART_ReceiveData8>:
; {
 80238c0: b480         	push	{r7}
 80238c2: b083         	sub	sp, #0xc
 80238c4: af00         	add	r7, sp, #0x0
 80238c6: 6078         	str	r0, [r7, #0x4]
;   return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR) & 0xFFU);
 80238c8: 687b         	ldr	r3, [r7, #0x4]
 80238ca: 6a5b         	ldr	r3, [r3, #0x24]
 80238cc: b2db         	uxtb	r3, r3
; }
 80238ce: 4618         	mov	r0, r3
 80238d0: 370c         	adds	r7, #0xc
 80238d2: 46bd         	mov	sp, r7
 80238d4: f85d 7b04    	ldr	r7, [sp], #4
 80238d8: 4770         	bx	lr

080238da <LL_USART_TransmitData8>:
; {
 80238da: b480         	push	{r7}
 80238dc: b083         	sub	sp, #0xc
 80238de: af00         	add	r7, sp, #0x0
 80238e0: 6078         	str	r0, [r7, #0x4]
 80238e2: 460b         	mov	r3, r1
 80238e4: 70fb         	strb	r3, [r7, #0x3]
;   USARTx->TDR = Value;
 80238e6: 78fa         	ldrb	r2, [r7, #0x3]
 80238e8: 687b         	ldr	r3, [r7, #0x4]
 80238ea: 629a         	str	r2, [r3, #0x28]
; }
 80238ec: bf00         	nop
 80238ee: 370c         	adds	r7, #0xc
 80238f0: 46bd         	mov	sp, r7
 80238f2: f85d 7b04    	ldr	r7, [sp], #4
 80238f6: 4770         	bx	lr

080238f8 <LL_USART_RequestRxDataFlush>:
; {
 80238f8: b480         	push	{r7}
 80238fa: b083         	sub	sp, #0xc
 80238fc: af00         	add	r7, sp, #0x0
 80238fe: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->RQR, (uint16_t)USART_RQR_RXFRQ);
 8023900: 687b         	ldr	r3, [r7, #0x4]
 8023902: 699b         	ldr	r3, [r3, #0x18]
 8023904: f043 0208    	orr	r2, r3, #0x8
 8023908: 687b         	ldr	r3, [r7, #0x4]
 802390a: 619a         	str	r2, [r3, #0x18]
; }
 802390c: bf00         	nop
 802390e: 370c         	adds	r7, #0xc
 8023910: 46bd         	mov	sp, r7
 8023912: f85d 7b04    	ldr	r7, [sp], #4
 8023916: 4770         	bx	lr

08023918 <z_log_msg_runtime_create>:
; {
 8023918: b580         	push	{r7, lr}
 802391a: b08a         	sub	sp, #0x28
 802391c: af04         	add	r7, sp, #0x10
 802391e: 60b9         	str	r1, [r7, #0x8]
 8023920: 607b         	str	r3, [r7, #0x4]
 8023922: 4603         	mov	r3, r0
 8023924: 73fb         	strb	r3, [r7, #0xf]
 8023926: 4613         	mov	r3, r2
 8023928: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 802392a: f107 032c    	add.w	r3, r7, #0x2c
 802392e: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8023930: 7bba         	ldrb	r2, [r7, #0xe]
 8023932: 7bf8         	ldrb	r0, [r7, #0xf]
 8023934: 697b         	ldr	r3, [r7, #0x14]
 8023936: 9303         	str	r3, [sp, #0xc]
 8023938: 6abb         	ldr	r3, [r7, #0x28]
 802393a: 9302         	str	r3, [sp, #0x8]
 802393c: 6a7b         	ldr	r3, [r7, #0x24]
 802393e: 9301         	str	r3, [sp, #0x4]
 8023940: 6a3b         	ldr	r3, [r7, #0x20]
 8023942: 9300         	str	r3, [sp]
 8023944: 687b         	ldr	r3, [r7, #0x4]
 8023946: 68b9         	ldr	r1, [r7, #0x8]
 8023948: f7e1 f914    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1edd8
; }
 802394c: bf00         	nop
 802394e: 3718         	adds	r7, #0x18
 8023950: 46bd         	mov	sp, r7
 8023952: bd80         	pop	{r7, pc}

08023954 <uart_stm32_set_parity>:
; {
 8023954: b580         	push	{r7, lr}
 8023956: b084         	sub	sp, #0x10
 8023958: af00         	add	r7, sp, #0x0
 802395a: 6078         	str	r0, [r7, #0x4]
 802395c: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 802395e: 687b         	ldr	r3, [r7, #0x4]
 8023960: 685b         	ldr	r3, [r3, #0x4]
 8023962: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetParity(config->usart, parity);
 8023964: 68fb         	ldr	r3, [r7, #0xc]
 8023966: 681b         	ldr	r3, [r3]
 8023968: 6839         	ldr	r1, [r7]
 802396a: 4618         	mov	r0, r3
 802396c: f7ff fb03    	bl	0x8022f76 <LL_USART_SetParity> @ imm = #-0x9fa
; }
 8023970: bf00         	nop
 8023972: 3710         	adds	r7, #0x10
 8023974: 46bd         	mov	sp, r7
 8023976: bd80         	pop	{r7, pc}

08023978 <uart_stm32_get_parity>:
; {
 8023978: b580         	push	{r7, lr}
 802397a: b084         	sub	sp, #0x10
 802397c: af00         	add	r7, sp, #0x0
 802397e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8023980: 687b         	ldr	r3, [r7, #0x4]
 8023982: 685b         	ldr	r3, [r3, #0x4]
 8023984: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetParity(config->usart);
 8023986: 68fb         	ldr	r3, [r7, #0xc]
 8023988: 681b         	ldr	r3, [r3]
 802398a: 4618         	mov	r0, r3
 802398c: f7ff fb06    	bl	0x8022f9c <LL_USART_GetParity> @ imm = #-0x9f4
 8023990: 4603         	mov	r3, r0
; }
 8023992: 4618         	mov	r0, r3
 8023994: 3710         	adds	r7, #0x10
 8023996: 46bd         	mov	sp, r7
 8023998: bd80         	pop	{r7, pc}

0802399a <uart_stm32_set_stopbits>:
; {
 802399a: b580         	push	{r7, lr}
 802399c: b084         	sub	sp, #0x10
 802399e: af00         	add	r7, sp, #0x0
 80239a0: 6078         	str	r0, [r7, #0x4]
 80239a2: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 80239a4: 687b         	ldr	r3, [r7, #0x4]
 80239a6: 685b         	ldr	r3, [r3, #0x4]
 80239a8: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetStopBitsLength(config->usart, stopbits);
 80239aa: 68fb         	ldr	r3, [r7, #0xc]
 80239ac: 681b         	ldr	r3, [r3]
 80239ae: 6839         	ldr	r1, [r7]
 80239b0: 4618         	mov	r0, r3
 80239b2: f7ff fb35    	bl	0x8023020 <LL_USART_SetStopBitsLength> @ imm = #-0x996
; }
 80239b6: bf00         	nop
 80239b8: 3710         	adds	r7, #0x10
 80239ba: 46bd         	mov	sp, r7
 80239bc: bd80         	pop	{r7, pc}

080239be <uart_stm32_get_stopbits>:
; {
 80239be: b580         	push	{r7, lr}
 80239c0: b084         	sub	sp, #0x10
 80239c2: af00         	add	r7, sp, #0x0
 80239c4: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80239c6: 687b         	ldr	r3, [r7, #0x4]
 80239c8: 685b         	ldr	r3, [r3, #0x4]
 80239ca: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetStopBitsLength(config->usart);
 80239cc: 68fb         	ldr	r3, [r7, #0xc]
 80239ce: 681b         	ldr	r3, [r3]
 80239d0: 4618         	mov	r0, r3
 80239d2: f7ff fb38    	bl	0x8023046 <LL_USART_GetStopBitsLength> @ imm = #-0x990
 80239d6: 4603         	mov	r3, r0
; }
 80239d8: 4618         	mov	r0, r3
 80239da: 3710         	adds	r7, #0x10
 80239dc: 46bd         	mov	sp, r7
 80239de: bd80         	pop	{r7, pc}

080239e0 <uart_stm32_set_databits>:
; {
 80239e0: b580         	push	{r7, lr}
 80239e2: b084         	sub	sp, #0x10
 80239e4: af00         	add	r7, sp, #0x0
 80239e6: 6078         	str	r0, [r7, #0x4]
 80239e8: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 80239ea: 687b         	ldr	r3, [r7, #0x4]
 80239ec: 685b         	ldr	r3, [r3, #0x4]
 80239ee: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetDataWidth(config->usart, databits);
 80239f0: 68fb         	ldr	r3, [r7, #0xc]
 80239f2: 681b         	ldr	r3, [r3]
 80239f4: 6839         	ldr	r1, [r7]
 80239f6: 4618         	mov	r0, r3
 80239f8: f7ff fade    	bl	0x8022fb8 <LL_USART_SetDataWidth> @ imm = #-0xa44
; }
 80239fc: bf00         	nop
 80239fe: 3710         	adds	r7, #0x10
 8023a00: 46bd         	mov	sp, r7
 8023a02: bd80         	pop	{r7, pc}

08023a04 <uart_stm32_get_databits>:
; {
 8023a04: b580         	push	{r7, lr}
 8023a06: b084         	sub	sp, #0x10
 8023a08: af00         	add	r7, sp, #0x0
 8023a0a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8023a0c: 687b         	ldr	r3, [r7, #0x4]
 8023a0e: 685b         	ldr	r3, [r3, #0x4]
 8023a10: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetDataWidth(config->usart);
 8023a12: 68fb         	ldr	r3, [r7, #0xc]
 8023a14: 681b         	ldr	r3, [r3]
 8023a16: 4618         	mov	r0, r3
 8023a18: f7ff fae1    	bl	0x8022fde <LL_USART_GetDataWidth> @ imm = #-0xa3e
 8023a1c: 4603         	mov	r3, r0
; }
 8023a1e: 4618         	mov	r0, r3
 8023a20: 3710         	adds	r7, #0x10
 8023a22: 46bd         	mov	sp, r7
 8023a24: bd80         	pop	{r7, pc}

08023a26 <uart_stm32_set_hwctrl>:
; {
 8023a26: b580         	push	{r7, lr}
 8023a28: b084         	sub	sp, #0x10
 8023a2a: af00         	add	r7, sp, #0x0
 8023a2c: 6078         	str	r0, [r7, #0x4]
 8023a2e: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8023a30: 687b         	ldr	r3, [r7, #0x4]
 8023a32: 685b         	ldr	r3, [r3, #0x4]
 8023a34: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetHWFlowCtrl(config->usart, hwctrl);
 8023a36: 68fb         	ldr	r3, [r7, #0xc]
 8023a38: 681b         	ldr	r3, [r3]
 8023a3a: 6839         	ldr	r1, [r7]
 8023a3c: 4618         	mov	r0, r3
 8023a3e: f7ff fb49    	bl	0x80230d4 <LL_USART_SetHWFlowCtrl> @ imm = #-0x96e
; }
 8023a42: bf00         	nop
 8023a44: 3710         	adds	r7, #0x10
 8023a46: 46bd         	mov	sp, r7
 8023a48: bd80         	pop	{r7, pc}

08023a4a <uart_stm32_get_hwctrl>:
; {
 8023a4a: b580         	push	{r7, lr}
 8023a4c: b084         	sub	sp, #0x10
 8023a4e: af00         	add	r7, sp, #0x0
 8023a50: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8023a52: 687b         	ldr	r3, [r7, #0x4]
 8023a54: 685b         	ldr	r3, [r3, #0x4]
 8023a56: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetHWFlowCtrl(config->usart);
 8023a58: 68fb         	ldr	r3, [r7, #0xc]
 8023a5a: 681b         	ldr	r3, [r3]
 8023a5c: 4618         	mov	r0, r3
 8023a5e: f7ff fb4c    	bl	0x80230fa <LL_USART_GetHWFlowCtrl> @ imm = #-0x968
 8023a62: 4603         	mov	r3, r0
; }
 8023a64: 4618         	mov	r0, r3
 8023a66: 3710         	adds	r7, #0x10
 8023a68: 46bd         	mov	sp, r7
 8023a6a: bd80         	pop	{r7, pc}

08023a6c <uart_stm32_set_driver_enable>:
; {
 8023a6c: b580         	push	{r7, lr}
 8023a6e: b084         	sub	sp, #0x10
 8023a70: af00         	add	r7, sp, #0x0
 8023a72: 6078         	str	r0, [r7, #0x4]
 8023a74: 460b         	mov	r3, r1
 8023a76: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_stm32_config *config = dev->config;
 8023a78: 687b         	ldr	r3, [r7, #0x4]
 8023a7a: 685b         	ldr	r3, [r3, #0x4]
 8023a7c: 60fb         	str	r3, [r7, #0xc]
; 	if (driver_enable) {
 8023a7e: 78fb         	ldrb	r3, [r7, #0x3]
 8023a80: 2b00         	cmp	r3, #0x0
 8023a82: d005         	beq	0x8023a90 <uart_stm32_set_driver_enable+0x24> @ imm = #0xa
; 		LL_USART_EnableDEMode(config->usart);
 8023a84: 68fb         	ldr	r3, [r7, #0xc]
 8023a86: 681b         	ldr	r3, [r3]
 8023a88: 4618         	mov	r0, r3
 8023a8a: f7ff fb7c    	bl	0x8023186 <LL_USART_EnableDEMode> @ imm = #-0x908
; }
 8023a8e: e004         	b	0x8023a9a <uart_stm32_set_driver_enable+0x2e> @ imm = #0x8
; 		LL_USART_DisableDEMode(config->usart);
 8023a90: 68fb         	ldr	r3, [r7, #0xc]
 8023a92: 681b         	ldr	r3, [r3]
 8023a94: 4618         	mov	r0, r3
 8023a96: f7ff fb86    	bl	0x80231a6 <LL_USART_DisableDEMode> @ imm = #-0x8f4
; }
 8023a9a: bf00         	nop
 8023a9c: 3710         	adds	r7, #0x10
 8023a9e: 46bd         	mov	sp, r7
 8023aa0: bd80         	pop	{r7, pc}

08023aa2 <uart_stm32_get_driver_enable>:
; {
 8023aa2: b580         	push	{r7, lr}
 8023aa4: b084         	sub	sp, #0x10
 8023aa6: af00         	add	r7, sp, #0x0
 8023aa8: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8023aaa: 687b         	ldr	r3, [r7, #0x4]
 8023aac: 685b         	ldr	r3, [r3, #0x4]
 8023aae: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsEnabledDEMode(config->usart);
 8023ab0: 68fb         	ldr	r3, [r7, #0xc]
 8023ab2: 681b         	ldr	r3, [r3]
 8023ab4: 4618         	mov	r0, r3
 8023ab6: f7ff fb86    	bl	0x80231c6 <LL_USART_IsEnabledDEMode> @ imm = #-0x8f4
 8023aba: 4603         	mov	r3, r0
 8023abc: 2b00         	cmp	r3, #0x0
 8023abe: bf14         	ite	ne
 8023ac0: 2301         	movne	r3, #0x1
 8023ac2: 2300         	moveq	r3, #0x0
 8023ac4: b2db         	uxtb	r3, r3
; }
 8023ac6: 4618         	mov	r0, r3
 8023ac8: 3710         	adds	r7, #0x10
 8023aca: 46bd         	mov	sp, r7
 8023acc: bd80         	pop	{r7, pc}

08023ace <uart_stm32_cfg2ll_parity>:
; {
 8023ace: b480         	push	{r7}
 8023ad0: b083         	sub	sp, #0xc
 8023ad2: af00         	add	r7, sp, #0x0
 8023ad4: 4603         	mov	r3, r0
 8023ad6: 71fb         	strb	r3, [r7, #0x7]
; 	switch (parity) {
 8023ad8: 79fb         	ldrb	r3, [r7, #0x7]
 8023ada: 2b01         	cmp	r3, #0x1
 8023adc: d002         	beq	0x8023ae4 <uart_stm32_cfg2ll_parity+0x16> @ imm = #0x4
 8023ade: 2b02         	cmp	r3, #0x2
 8023ae0: d003         	beq	0x8023aea <uart_stm32_cfg2ll_parity+0x1c> @ imm = #0x6
 8023ae2: e005         	b	0x8023af0 <uart_stm32_cfg2ll_parity+0x22> @ imm = #0xa
; 		return LL_USART_PARITY_ODD;
 8023ae4: f44f 63c0    	mov.w	r3, #0x600
 8023ae8: e003         	b	0x8023af2 <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x6
; 		return LL_USART_PARITY_EVEN;
 8023aea: f44f 6380    	mov.w	r3, #0x400
 8023aee: e000         	b	0x8023af2 <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x0
; 		return LL_USART_PARITY_NONE;
 8023af0: 2300         	movs	r3, #0x0
; }
 8023af2: 4618         	mov	r0, r3
 8023af4: 370c         	adds	r7, #0xc
 8023af6: 46bd         	mov	sp, r7
 8023af8: f85d 7b04    	ldr	r7, [sp], #4
 8023afc: 4770         	bx	lr

08023afe <uart_stm32_ll2cfg_parity>:
; {
 8023afe: b480         	push	{r7}
 8023b00: b083         	sub	sp, #0xc
 8023b02: af00         	add	r7, sp, #0x0
 8023b04: 6078         	str	r0, [r7, #0x4]
; 	switch (parity) {
 8023b06: 687b         	ldr	r3, [r7, #0x4]
 8023b08: f5b3 6f80    	cmp.w	r3, #0x400
 8023b0c: d005         	beq	0x8023b1a <uart_stm32_ll2cfg_parity+0x1c> @ imm = #0xa
 8023b0e: 687b         	ldr	r3, [r7, #0x4]
 8023b10: f5b3 6fc0    	cmp.w	r3, #0x600
 8023b14: d103         	bne	0x8023b1e <uart_stm32_ll2cfg_parity+0x20> @ imm = #0x6
; 		return UART_CFG_PARITY_ODD;
 8023b16: 2301         	movs	r3, #0x1
 8023b18: e002         	b	0x8023b20 <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x4
; 		return UART_CFG_PARITY_EVEN;
 8023b1a: 2302         	movs	r3, #0x2
 8023b1c: e000         	b	0x8023b20 <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x0
; 		return UART_CFG_PARITY_NONE;
 8023b1e: 2300         	movs	r3, #0x0
; }
 8023b20: 4618         	mov	r0, r3
 8023b22: 370c         	adds	r7, #0xc
 8023b24: 46bd         	mov	sp, r7
 8023b26: f85d 7b04    	ldr	r7, [sp], #4
 8023b2a: 4770         	bx	lr

08023b2c <uart_stm32_cfg2ll_stopbits>:
; {
 8023b2c: b480         	push	{r7}
 8023b2e: b083         	sub	sp, #0xc
 8023b30: af00         	add	r7, sp, #0x0
 8023b32: 6078         	str	r0, [r7, #0x4]
 8023b34: 460b         	mov	r3, r1
 8023b36: 70fb         	strb	r3, [r7, #0x3]
; 	switch (sb) {
 8023b38: 78fb         	ldrb	r3, [r7, #0x3]
 8023b3a: 2b02         	cmp	r3, #0x2
 8023b3c: d00b         	beq	0x8023b56 <uart_stm32_cfg2ll_stopbits+0x2a> @ imm = #0x16
 8023b3e: 2b02         	cmp	r3, #0x2
 8023b40: dc0c         	bgt	0x8023b5c <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0x18
 8023b42: 2b00         	cmp	r3, #0x0
 8023b44: d002         	beq	0x8023b4c <uart_stm32_cfg2ll_stopbits+0x20> @ imm = #0x4
 8023b46: 2b01         	cmp	r3, #0x1
 8023b48: d003         	beq	0x8023b52 <uart_stm32_cfg2ll_stopbits+0x26> @ imm = #0x6
 8023b4a: e007         	b	0x8023b5c <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0xe
; 		return LL_USART_STOPBITS_0_5;
 8023b4c: f44f 5380    	mov.w	r3, #0x1000
 8023b50: e006         	b	0x8023b60 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0xc
; 		return LL_USART_STOPBITS_1;
 8023b52: 2300         	movs	r3, #0x0
 8023b54: e004         	b	0x8023b60 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x8
; 		return LL_USART_STOPBITS_1_5;
 8023b56: f44f 5340    	mov.w	r3, #0x3000
 8023b5a: e001         	b	0x8023b60 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x2
; 		return LL_USART_STOPBITS_2;
 8023b5c: f44f 5300    	mov.w	r3, #0x2000
; }
 8023b60: 4618         	mov	r0, r3
 8023b62: 370c         	adds	r7, #0xc
 8023b64: 46bd         	mov	sp, r7
 8023b66: f85d 7b04    	ldr	r7, [sp], #4
 8023b6a: 4770         	bx	lr

08023b6c <uart_stm32_ll2cfg_stopbits>:
; {
 8023b6c: b480         	push	{r7}
 8023b6e: b083         	sub	sp, #0xc
 8023b70: af00         	add	r7, sp, #0x0
 8023b72: 6078         	str	r0, [r7, #0x4]
; 	switch (sb) {
 8023b74: 687b         	ldr	r3, [r7, #0x4]
 8023b76: f5b3 5f40    	cmp.w	r3, #0x3000
 8023b7a: d00e         	beq	0x8023b9a <uart_stm32_ll2cfg_stopbits+0x2e> @ imm = #0x1c
 8023b7c: 687b         	ldr	r3, [r7, #0x4]
 8023b7e: f5b3 5f40    	cmp.w	r3, #0x3000
 8023b82: d80c         	bhi	0x8023b9e <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0x18
 8023b84: 687b         	ldr	r3, [r7, #0x4]
 8023b86: 2b00         	cmp	r3, #0x0
 8023b88: d005         	beq	0x8023b96 <uart_stm32_ll2cfg_stopbits+0x2a> @ imm = #0xa
 8023b8a: 687b         	ldr	r3, [r7, #0x4]
 8023b8c: f5b3 5f80    	cmp.w	r3, #0x1000
 8023b90: d105         	bne	0x8023b9e <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0xa
; 		return UART_CFG_STOP_BITS_0_5;
 8023b92: 2300         	movs	r3, #0x0
 8023b94: e004         	b	0x8023ba0 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x8
; 		return UART_CFG_STOP_BITS_1;
 8023b96: 2301         	movs	r3, #0x1
 8023b98: e002         	b	0x8023ba0 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x4
; 		return UART_CFG_STOP_BITS_1_5;
 8023b9a: 2302         	movs	r3, #0x2
 8023b9c: e000         	b	0x8023ba0 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x0
; 		return UART_CFG_STOP_BITS_2;
 8023b9e: 2303         	movs	r3, #0x3
; }
 8023ba0: 4618         	mov	r0, r3
 8023ba2: 370c         	adds	r7, #0xc
 8023ba4: 46bd         	mov	sp, r7
 8023ba6: f85d 7b04    	ldr	r7, [sp], #4
 8023baa: 4770         	bx	lr

08023bac <uart_stm32_cfg2ll_databits>:
; {
 8023bac: b480         	push	{r7}
 8023bae: b083         	sub	sp, #0xc
 8023bb0: af00         	add	r7, sp, #0x0
 8023bb2: 4603         	mov	r3, r0
 8023bb4: 460a         	mov	r2, r1
 8023bb6: 71fb         	strb	r3, [r7, #0x7]
 8023bb8: 4613         	mov	r3, r2
 8023bba: 71bb         	strb	r3, [r7, #0x6]
; 	switch (db) {
 8023bbc: 79fb         	ldrb	r3, [r7, #0x7]
 8023bbe: 2b02         	cmp	r3, #0x2
 8023bc0: d002         	beq	0x8023bc8 <uart_stm32_cfg2ll_databits+0x1c> @ imm = #0x4
 8023bc2: 2b04         	cmp	r3, #0x4
 8023bc4: d008         	beq	0x8023bd8 <uart_stm32_cfg2ll_databits+0x2c> @ imm = #0x10
 8023bc6: e00a         	b	0x8023bde <uart_stm32_cfg2ll_databits+0x32> @ imm = #0x14
; 		if (p == UART_CFG_PARITY_NONE) {
 8023bc8: 79bb         	ldrb	r3, [r7, #0x6]
 8023bca: 2b00         	cmp	r3, #0x0
 8023bcc: d102         	bne	0x8023bd4 <uart_stm32_cfg2ll_databits+0x28> @ imm = #0x4
; 			return LL_USART_DATAWIDTH_7B;
 8023bce: f04f 5380    	mov.w	r3, #0x10000000
 8023bd2: e00b         	b	0x8023bec <uart_stm32_cfg2ll_databits+0x40> @ imm = #0x16
; 			return LL_USART_DATAWIDTH_8B;
 8023bd4: 2300         	movs	r3, #0x0
 8023bd6: e009         	b	0x8023bec <uart_stm32_cfg2ll_databits+0x40> @ imm = #0x12
; 		return LL_USART_DATAWIDTH_9B;
 8023bd8: f44f 5380    	mov.w	r3, #0x1000
 8023bdc: e006         	b	0x8023bec <uart_stm32_cfg2ll_databits+0x40> @ imm = #0xc
; 		if (p == UART_CFG_PARITY_NONE) {
 8023bde: 79bb         	ldrb	r3, [r7, #0x6]
 8023be0: 2b00         	cmp	r3, #0x0
 8023be2: d101         	bne	0x8023be8 <uart_stm32_cfg2ll_databits+0x3c> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_8B;
 8023be4: 2300         	movs	r3, #0x0
 8023be6: e001         	b	0x8023bec <uart_stm32_cfg2ll_databits+0x40> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_9B;
 8023be8: f44f 5380    	mov.w	r3, #0x1000
; }
 8023bec: 4618         	mov	r0, r3
 8023bee: 370c         	adds	r7, #0xc
 8023bf0: 46bd         	mov	sp, r7
 8023bf2: f85d 7b04    	ldr	r7, [sp], #4
 8023bf6: 4770         	bx	lr

08023bf8 <uart_stm32_ll2cfg_databits>:
; {
 8023bf8: b480         	push	{r7}
 8023bfa: b083         	sub	sp, #0xc
 8023bfc: af00         	add	r7, sp, #0x0
 8023bfe: 6078         	str	r0, [r7, #0x4]
 8023c00: 6039         	str	r1, [r7]
; 	switch (db) {
 8023c02: 687b         	ldr	r3, [r7, #0x4]
 8023c04: f5b3 5f80    	cmp.w	r3, #0x1000
 8023c08: d00a         	beq	0x8023c20 <uart_stm32_ll2cfg_databits+0x28> @ imm = #0x14
 8023c0a: 687b         	ldr	r3, [r7, #0x4]
 8023c0c: f1b3 5f80    	cmp.w	r3, #0x10000000
 8023c10: d10d         	bne	0x8023c2e <uart_stm32_ll2cfg_databits+0x36> @ imm = #0x1a
; 		if (p == LL_USART_PARITY_NONE) {
 8023c12: 683b         	ldr	r3, [r7]
 8023c14: 2b00         	cmp	r3, #0x0
 8023c16: d101         	bne	0x8023c1c <uart_stm32_ll2cfg_databits+0x24> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_7;
 8023c18: 2302         	movs	r3, #0x2
 8023c1a: e00e         	b	0x8023c3a <uart_stm32_ll2cfg_databits+0x42> @ imm = #0x1c
; 			return UART_CFG_DATA_BITS_6;
 8023c1c: 2301         	movs	r3, #0x1
 8023c1e: e00c         	b	0x8023c3a <uart_stm32_ll2cfg_databits+0x42> @ imm = #0x18
; 		if (p == LL_USART_PARITY_NONE) {
 8023c20: 683b         	ldr	r3, [r7]
 8023c22: 2b00         	cmp	r3, #0x0
 8023c24: d101         	bne	0x8023c2a <uart_stm32_ll2cfg_databits+0x32> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_9;
 8023c26: 2304         	movs	r3, #0x4
 8023c28: e007         	b	0x8023c3a <uart_stm32_ll2cfg_databits+0x42> @ imm = #0xe
; 			return UART_CFG_DATA_BITS_8;
 8023c2a: 2303         	movs	r3, #0x3
 8023c2c: e005         	b	0x8023c3a <uart_stm32_ll2cfg_databits+0x42> @ imm = #0xa
; 		if (p == LL_USART_PARITY_NONE) {
 8023c2e: 683b         	ldr	r3, [r7]
 8023c30: 2b00         	cmp	r3, #0x0
 8023c32: d101         	bne	0x8023c38 <uart_stm32_ll2cfg_databits+0x40> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_8;
 8023c34: 2303         	movs	r3, #0x3
 8023c36: e000         	b	0x8023c3a <uart_stm32_ll2cfg_databits+0x42> @ imm = #0x0
; 			return UART_CFG_DATA_BITS_7;
 8023c38: 2302         	movs	r3, #0x2
; }
 8023c3a: 4618         	mov	r0, r3
 8023c3c: 370c         	adds	r7, #0xc
 8023c3e: 46bd         	mov	sp, r7
 8023c40: f85d 7b04    	ldr	r7, [sp], #4
 8023c44: 4770         	bx	lr

08023c46 <uart_stm32_cfg2ll_hwctrl>:
; {
 8023c46: b480         	push	{r7}
 8023c48: b083         	sub	sp, #0xc
 8023c4a: af00         	add	r7, sp, #0x0
 8023c4c: 4603         	mov	r3, r0
 8023c4e: 71fb         	strb	r3, [r7, #0x7]
; 	if (fc == UART_CFG_FLOW_CTRL_RTS_CTS) {
 8023c50: 79fb         	ldrb	r3, [r7, #0x7]
 8023c52: 2b01         	cmp	r3, #0x1
 8023c54: d102         	bne	0x8023c5c <uart_stm32_cfg2ll_hwctrl+0x16> @ imm = #0x4
; 		return LL_USART_HWCONTROL_RTS_CTS;
 8023c56: f44f 7340    	mov.w	r3, #0x300
 8023c5a: e005         	b	0x8023c68 <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0xa
; 	} else if (fc == UART_CFG_FLOW_CTRL_RS485) {
 8023c5c: 79fb         	ldrb	r3, [r7, #0x7]
 8023c5e: 2b03         	cmp	r3, #0x3
 8023c60: d101         	bne	0x8023c66 <uart_stm32_cfg2ll_hwctrl+0x20> @ imm = #0x2
; 		return LL_USART_HWCONTROL_NONE;
 8023c62: 2300         	movs	r3, #0x0
 8023c64: e000         	b	0x8023c68 <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0x0
; 	return LL_USART_HWCONTROL_NONE;
 8023c66: 2300         	movs	r3, #0x0
; }
 8023c68: 4618         	mov	r0, r3
 8023c6a: 370c         	adds	r7, #0xc
 8023c6c: 46bd         	mov	sp, r7
 8023c6e: f85d 7b04    	ldr	r7, [sp], #4
 8023c72: 4770         	bx	lr

08023c74 <uart_stm32_ll2cfg_hwctrl>:
; {
 8023c74: b480         	push	{r7}
 8023c76: b083         	sub	sp, #0xc
 8023c78: af00         	add	r7, sp, #0x0
 8023c7a: 6078         	str	r0, [r7, #0x4]
; 	if (fc == LL_USART_HWCONTROL_RTS_CTS) {
 8023c7c: 687b         	ldr	r3, [r7, #0x4]
 8023c7e: f5b3 7f40    	cmp.w	r3, #0x300
 8023c82: d101         	bne	0x8023c88 <uart_stm32_ll2cfg_hwctrl+0x14> @ imm = #0x2
; 		return UART_CFG_FLOW_CTRL_RTS_CTS;
 8023c84: 2301         	movs	r3, #0x1
 8023c86: e000         	b	0x8023c8a <uart_stm32_ll2cfg_hwctrl+0x16> @ imm = #0x0
; 	return UART_CFG_FLOW_CTRL_NONE;
 8023c88: 2300         	movs	r3, #0x0
; }
 8023c8a: 4618         	mov	r0, r3
 8023c8c: 370c         	adds	r7, #0xc
 8023c8e: 46bd         	mov	sp, r7
 8023c90: f85d 7b04    	ldr	r7, [sp], #4
 8023c94: 4770         	bx	lr

08023c96 <uart_stm32_parameters_set>:
; {
 8023c96: b580         	push	{r7, lr}
 8023c98: b08a         	sub	sp, #0x28
 8023c9a: af00         	add	r7, sp, #0x0
 8023c9c: 6078         	str	r0, [r7, #0x4]
 8023c9e: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8023ca0: 687b         	ldr	r3, [r7, #0x4]
 8023ca2: 685b         	ldr	r3, [r3, #0x4]
 8023ca4: 627b         	str	r3, [r7, #0x24]
; 	struct uart_stm32_data *data = dev->data;
 8023ca6: 687b         	ldr	r3, [r7, #0x4]
 8023ca8: 691b         	ldr	r3, [r3, #0x10]
 8023caa: 623b         	str	r3, [r7, #0x20]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 8023cac: 6a3b         	ldr	r3, [r7, #0x20]
 8023cae: 685b         	ldr	r3, [r3, #0x4]
 8023cb0: 61fb         	str	r3, [r7, #0x1c]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 8023cb2: 683b         	ldr	r3, [r7]
 8023cb4: 791b         	ldrb	r3, [r3, #0x4]
 8023cb6: 4618         	mov	r0, r3
 8023cb8: f7ff ff09    	bl	0x8023ace <uart_stm32_cfg2ll_parity> @ imm = #-0x1ee
 8023cbc: 61b8         	str	r0, [r7, #0x18]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 8023cbe: 683b         	ldr	r3, [r7]
 8023cc0: 795b         	ldrb	r3, [r3, #0x5]
 8023cc2: 4619         	mov	r1, r3
 8023cc4: 6a78         	ldr	r0, [r7, #0x24]
 8023cc6: f7ff ff31    	bl	0x8023b2c <uart_stm32_cfg2ll_stopbits> @ imm = #-0x19e
 8023cca: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 8023ccc: 683b         	ldr	r3, [r7]
 8023cce: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 8023cd0: 683b         	ldr	r3, [r7]
 8023cd2: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 8023cd4: 4619         	mov	r1, r3
 8023cd6: 4610         	mov	r0, r2
 8023cd8: f7ff ff68    	bl	0x8023bac <uart_stm32_cfg2ll_databits> @ imm = #-0x130
 8023cdc: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t flowctrl = uart_stm32_cfg2ll_hwctrl(cfg->flow_ctrl);
 8023cde: 683b         	ldr	r3, [r7]
 8023ce0: 79db         	ldrb	r3, [r3, #0x7]
 8023ce2: 4618         	mov	r0, r3
 8023ce4: f7ff ffaf    	bl	0x8023c46 <uart_stm32_cfg2ll_hwctrl> @ imm = #-0xa2
 8023ce8: 60f8         	str	r0, [r7, #0xc]
; 	bool driver_enable = cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RS485;
 8023cea: 683b         	ldr	r3, [r7]
 8023cec: 79db         	ldrb	r3, [r3, #0x7]
 8023cee: 2b03         	cmp	r3, #0x3
 8023cf0: bf0c         	ite	eq
 8023cf2: 2301         	moveq	r3, #0x1
 8023cf4: 2300         	movne	r3, #0x0
 8023cf6: 72fb         	strb	r3, [r7, #0xb]
; 	if (cfg == uart_cfg) {
 8023cf8: 683a         	ldr	r2, [r7]
 8023cfa: 69fb         	ldr	r3, [r7, #0x1c]
 8023cfc: 429a         	cmp	r2, r3
 8023cfe: d111         	bne	0x8023d24 <uart_stm32_parameters_set+0x8e> @ imm = #0x22
; 		LL_USART_ConfigCharacter(config->usart,
 8023d00: 6a7b         	ldr	r3, [r7, #0x24]
 8023d02: 6818         	ldr	r0, [r3]
 8023d04: 697b         	ldr	r3, [r7, #0x14]
 8023d06: 69ba         	ldr	r2, [r7, #0x18]
 8023d08: 6939         	ldr	r1, [r7, #0x10]
 8023d0a: f7ea fecd    	bl	0x800eaa8 <LL_USART_ConfigCharacter> @ imm = #-0x15266
; 		uart_stm32_set_hwctrl(dev, flowctrl);
 8023d0e: 68f9         	ldr	r1, [r7, #0xc]
 8023d10: 6878         	ldr	r0, [r7, #0x4]
 8023d12: f7ff fe88    	bl	0x8023a26 <uart_stm32_set_hwctrl> @ imm = #-0x2f0
; 		uart_stm32_set_baudrate(dev, cfg->baudrate);
 8023d16: 683b         	ldr	r3, [r7]
 8023d18: 681b         	ldr	r3, [r3]
 8023d1a: 4619         	mov	r1, r3
 8023d1c: 6878         	ldr	r0, [r7, #0x4]
 8023d1e: f7ea ff35    	bl	0x800eb8c <uart_stm32_set_baudrate> @ imm = #-0x15196
; }
 8023d22: e048         	b	0x8023db6 <uart_stm32_parameters_set+0x120> @ imm = #0x90
; 		if (parity != uart_stm32_get_parity(dev)) {
 8023d24: 6878         	ldr	r0, [r7, #0x4]
 8023d26: f7ff fe27    	bl	0x8023978 <uart_stm32_get_parity> @ imm = #-0x3b2
 8023d2a: 4602         	mov	r2, r0
 8023d2c: 69bb         	ldr	r3, [r7, #0x18]
 8023d2e: 4293         	cmp	r3, r2
 8023d30: d003         	beq	0x8023d3a <uart_stm32_parameters_set+0xa4> @ imm = #0x6
; 			uart_stm32_set_parity(dev, parity);
 8023d32: 69b9         	ldr	r1, [r7, #0x18]
 8023d34: 6878         	ldr	r0, [r7, #0x4]
 8023d36: f7ff fe0d    	bl	0x8023954 <uart_stm32_set_parity> @ imm = #-0x3e6
; 		if (stopbits != uart_stm32_get_stopbits(dev)) {
 8023d3a: 6878         	ldr	r0, [r7, #0x4]
 8023d3c: f7ff fe3f    	bl	0x80239be <uart_stm32_get_stopbits> @ imm = #-0x382
 8023d40: 4602         	mov	r2, r0
 8023d42: 697b         	ldr	r3, [r7, #0x14]
 8023d44: 4293         	cmp	r3, r2
 8023d46: d003         	beq	0x8023d50 <uart_stm32_parameters_set+0xba> @ imm = #0x6
; 			uart_stm32_set_stopbits(dev, stopbits);
 8023d48: 6979         	ldr	r1, [r7, #0x14]
 8023d4a: 6878         	ldr	r0, [r7, #0x4]
 8023d4c: f7ff fe25    	bl	0x802399a <uart_stm32_set_stopbits> @ imm = #-0x3b6
; 		if (databits != uart_stm32_get_databits(dev)) {
 8023d50: 6878         	ldr	r0, [r7, #0x4]
 8023d52: f7ff fe57    	bl	0x8023a04 <uart_stm32_get_databits> @ imm = #-0x352
 8023d56: 4602         	mov	r2, r0
 8023d58: 693b         	ldr	r3, [r7, #0x10]
 8023d5a: 4293         	cmp	r3, r2
 8023d5c: d003         	beq	0x8023d66 <uart_stm32_parameters_set+0xd0> @ imm = #0x6
; 			uart_stm32_set_databits(dev, databits);
 8023d5e: 6939         	ldr	r1, [r7, #0x10]
 8023d60: 6878         	ldr	r0, [r7, #0x4]
 8023d62: f7ff fe3d    	bl	0x80239e0 <uart_stm32_set_databits> @ imm = #-0x386
; 		if (flowctrl != uart_stm32_get_hwctrl(dev)) {
 8023d66: 6878         	ldr	r0, [r7, #0x4]
 8023d68: f7ff fe6f    	bl	0x8023a4a <uart_stm32_get_hwctrl> @ imm = #-0x322
 8023d6c: 4602         	mov	r2, r0
 8023d6e: 68fb         	ldr	r3, [r7, #0xc]
 8023d70: 4293         	cmp	r3, r2
 8023d72: d003         	beq	0x8023d7c <uart_stm32_parameters_set+0xe6> @ imm = #0x6
; 			uart_stm32_set_hwctrl(dev, flowctrl);
 8023d74: 68f9         	ldr	r1, [r7, #0xc]
 8023d76: 6878         	ldr	r0, [r7, #0x4]
 8023d78: f7ff fe55    	bl	0x8023a26 <uart_stm32_set_hwctrl> @ imm = #-0x356
; 		if (driver_enable != uart_stm32_get_driver_enable(dev)) {
 8023d7c: 6878         	ldr	r0, [r7, #0x4]
 8023d7e: f7ff fe90    	bl	0x8023aa2 <uart_stm32_get_driver_enable> @ imm = #-0x2e0
 8023d82: 4603         	mov	r3, r0
 8023d84: 461a         	mov	r2, r3
 8023d86: 7afb         	ldrb	r3, [r7, #0xb]
 8023d88: 4293         	cmp	r3, r2
 8023d8a: d004         	beq	0x8023d96 <uart_stm32_parameters_set+0x100> @ imm = #0x8
; 			uart_stm32_set_driver_enable(dev, driver_enable);
 8023d8c: 7afb         	ldrb	r3, [r7, #0xb]
 8023d8e: 4619         	mov	r1, r3
 8023d90: 6878         	ldr	r0, [r7, #0x4]
 8023d92: f7ff fe6b    	bl	0x8023a6c <uart_stm32_set_driver_enable> @ imm = #-0x32a
; 		if (cfg->baudrate != uart_cfg->baudrate) {
 8023d96: 683b         	ldr	r3, [r7]
 8023d98: 681a         	ldr	r2, [r3]
 8023d9a: 69fb         	ldr	r3, [r7, #0x1c]
 8023d9c: 681b         	ldr	r3, [r3]
 8023d9e: 429a         	cmp	r2, r3
 8023da0: d009         	beq	0x8023db6 <uart_stm32_parameters_set+0x120> @ imm = #0x12
; 			uart_stm32_set_baudrate(dev, cfg->baudrate);
 8023da2: 683b         	ldr	r3, [r7]
 8023da4: 681b         	ldr	r3, [r3]
 8023da6: 4619         	mov	r1, r3
 8023da8: 6878         	ldr	r0, [r7, #0x4]
 8023daa: f7ea feef    	bl	0x800eb8c <uart_stm32_set_baudrate> @ imm = #-0x15222
; 			uart_cfg->baudrate = cfg->baudrate;
 8023dae: 683b         	ldr	r3, [r7]
 8023db0: 681a         	ldr	r2, [r3]
 8023db2: 69fb         	ldr	r3, [r7, #0x1c]
 8023db4: 601a         	str	r2, [r3]
; }
 8023db6: bf00         	nop
 8023db8: 3728         	adds	r7, #0x28
 8023dba: 46bd         	mov	sp, r7
 8023dbc: bd80         	pop	{r7, pc}

08023dbe <uart_stm32_config_get>:
; {
 8023dbe: b590         	push	{r4, r7, lr}
 8023dc0: b085         	sub	sp, #0x14
 8023dc2: af00         	add	r7, sp, #0x0
 8023dc4: 6078         	str	r0, [r7, #0x4]
 8023dc6: 6039         	str	r1, [r7]
; 	struct uart_stm32_data *data = dev->data;
 8023dc8: 687b         	ldr	r3, [r7, #0x4]
 8023dca: 691b         	ldr	r3, [r3, #0x10]
 8023dcc: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 8023dce: 68fb         	ldr	r3, [r7, #0xc]
 8023dd0: 685b         	ldr	r3, [r3, #0x4]
 8023dd2: 60bb         	str	r3, [r7, #0x8]
; 	cfg->baudrate = uart_cfg->baudrate;
 8023dd4: 68bb         	ldr	r3, [r7, #0x8]
 8023dd6: 681a         	ldr	r2, [r3]
 8023dd8: 683b         	ldr	r3, [r7]
 8023dda: 601a         	str	r2, [r3]
; 	cfg->parity = uart_stm32_ll2cfg_parity(uart_stm32_get_parity(dev));
 8023ddc: 6878         	ldr	r0, [r7, #0x4]
 8023dde: f7ff fdcb    	bl	0x8023978 <uart_stm32_get_parity> @ imm = #-0x46a
 8023de2: 4603         	mov	r3, r0
 8023de4: 4618         	mov	r0, r3
 8023de6: f7ff fe8a    	bl	0x8023afe <uart_stm32_ll2cfg_parity> @ imm = #-0x2ec
 8023dea: 4603         	mov	r3, r0
 8023dec: 461a         	mov	r2, r3
 8023dee: 683b         	ldr	r3, [r7]
 8023df0: 711a         	strb	r2, [r3, #0x4]
; 	cfg->stop_bits = uart_stm32_ll2cfg_stopbits(
 8023df2: 6878         	ldr	r0, [r7, #0x4]
 8023df4: f7ff fde3    	bl	0x80239be <uart_stm32_get_stopbits> @ imm = #-0x43a
 8023df8: 4603         	mov	r3, r0
 8023dfa: 4618         	mov	r0, r3
 8023dfc: f7ff feb6    	bl	0x8023b6c <uart_stm32_ll2cfg_stopbits> @ imm = #-0x294
 8023e00: 4603         	mov	r3, r0
 8023e02: 461a         	mov	r2, r3
 8023e04: 683b         	ldr	r3, [r7]
 8023e06: 715a         	strb	r2, [r3, #0x5]
; 	cfg->data_bits = uart_stm32_ll2cfg_databits(
 8023e08: 6878         	ldr	r0, [r7, #0x4]
 8023e0a: f7ff fdfb    	bl	0x8023a04 <uart_stm32_get_databits> @ imm = #-0x40a
 8023e0e: 4604         	mov	r4, r0
 8023e10: 6878         	ldr	r0, [r7, #0x4]
 8023e12: f7ff fdb1    	bl	0x8023978 <uart_stm32_get_parity> @ imm = #-0x49e
 8023e16: 4603         	mov	r3, r0
 8023e18: 4619         	mov	r1, r3
 8023e1a: 4620         	mov	r0, r4
 8023e1c: f7ff feec    	bl	0x8023bf8 <uart_stm32_ll2cfg_databits> @ imm = #-0x228
 8023e20: 4603         	mov	r3, r0
 8023e22: 461a         	mov	r2, r3
 8023e24: 683b         	ldr	r3, [r7]
 8023e26: 719a         	strb	r2, [r3, #0x6]
; 	cfg->flow_ctrl = uart_stm32_ll2cfg_hwctrl(
 8023e28: 6878         	ldr	r0, [r7, #0x4]
 8023e2a: f7ff fe0e    	bl	0x8023a4a <uart_stm32_get_hwctrl> @ imm = #-0x3e4
 8023e2e: 4603         	mov	r3, r0
 8023e30: 4618         	mov	r0, r3
 8023e32: f7ff ff1f    	bl	0x8023c74 <uart_stm32_ll2cfg_hwctrl> @ imm = #-0x1c2
 8023e36: 4603         	mov	r3, r0
 8023e38: 461a         	mov	r2, r3
 8023e3a: 683b         	ldr	r3, [r7]
 8023e3c: 71da         	strb	r2, [r3, #0x7]
; 	if (uart_stm32_get_driver_enable(dev)) {
 8023e3e: 6878         	ldr	r0, [r7, #0x4]
 8023e40: f7ff fe2f    	bl	0x8023aa2 <uart_stm32_get_driver_enable> @ imm = #-0x3a2
 8023e44: 4603         	mov	r3, r0
 8023e46: 2b00         	cmp	r3, #0x0
 8023e48: d002         	beq	0x8023e50 <uart_stm32_config_get+0x92> @ imm = #0x4
; 		cfg->flow_ctrl = UART_CFG_FLOW_CTRL_RS485;
 8023e4a: 683b         	ldr	r3, [r7]
 8023e4c: 2203         	movs	r2, #0x3
 8023e4e: 71da         	strb	r2, [r3, #0x7]
; 	return 0;
 8023e50: 2300         	movs	r3, #0x0
; }
 8023e52: 4618         	mov	r0, r3
 8023e54: 3714         	adds	r7, #0x14
 8023e56: 46bd         	mov	sp, r7
 8023e58: bd90         	pop	{r4, r7, pc}

08023e5a <uart_stm32_poll_in_visitor>:
; {
 8023e5a: b580         	push	{r7, lr}
 8023e5c: b086         	sub	sp, #0x18
 8023e5e: af00         	add	r7, sp, #0x0
 8023e60: 60f8         	str	r0, [r7, #0xc]
 8023e62: 60b9         	str	r1, [r7, #0x8]
 8023e64: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8023e66: 68fb         	ldr	r3, [r7, #0xc]
 8023e68: 685b         	ldr	r3, [r3, #0x4]
 8023e6a: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 8023e6c: 697b         	ldr	r3, [r7, #0x14]
 8023e6e: 681b         	ldr	r3, [r3]
 8023e70: 613b         	str	r3, [r7, #0x10]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 8023e72: 6938         	ldr	r0, [r7, #0x10]
 8023e74: f7ff fa07    	bl	0x8023286 <LL_USART_IsActiveFlag_ORE> @ imm = #-0xbf2
 8023e78: 4603         	mov	r3, r0
 8023e7a: 2b00         	cmp	r3, #0x0
 8023e7c: d002         	beq	0x8023e84 <uart_stm32_poll_in_visitor+0x2a> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 8023e7e: 6938         	ldr	r0, [r7, #0x10]
 8023e80: f7ff fac3    	bl	0x802340a <LL_USART_ClearFlag_ORE> @ imm = #-0xa7a
; 	if (!LL_USART_IsActiveFlag_RXNE(usart)) {
 8023e84: 6938         	ldr	r0, [r7, #0x10]
 8023e86: f7ff fa24    	bl	0x80232d2 <LL_USART_IsActiveFlag_RXNE_RXFNE> @ imm = #-0xbb8
 8023e8a: 4603         	mov	r3, r0
 8023e8c: 2b00         	cmp	r3, #0x0
 8023e8e: d102         	bne	0x8023e96 <uart_stm32_poll_in_visitor+0x3c> @ imm = #0x4
; 		return -1;
 8023e90: f04f 33ff    	mov.w	r3, #0xffffffff
 8023e94: e004         	b	0x8023ea0 <uart_stm32_poll_in_visitor+0x46> @ imm = #0x8
; 	get_fn(usart, in);
 8023e96: 687b         	ldr	r3, [r7, #0x4]
 8023e98: 68b9         	ldr	r1, [r7, #0x8]
 8023e9a: 6938         	ldr	r0, [r7, #0x10]
 8023e9c: 4798         	blx	r3
; 	return 0;
 8023e9e: 2300         	movs	r3, #0x0
; }
 8023ea0: 4618         	mov	r0, r3
 8023ea2: 3718         	adds	r7, #0x18
 8023ea4: 46bd         	mov	sp, r7
 8023ea6: bd80         	pop	{r7, pc}

08023ea8 <uart_stm32_poll_out_visitor>:
; {
 8023ea8: b580         	push	{r7, lr}
 8023eaa: b08e         	sub	sp, #0x38
 8023eac: af00         	add	r7, sp, #0x0
 8023eae: 60f8         	str	r0, [r7, #0xc]
 8023eb0: 460b         	mov	r3, r1
 8023eb2: 607a         	str	r2, [r7, #0x4]
 8023eb4: 817b         	strh	r3, [r7, #0xa]
; 	const struct uart_stm32_config *config = dev->config;
 8023eb6: 68fb         	ldr	r3, [r7, #0xc]
 8023eb8: 685b         	ldr	r3, [r3, #0x4]
 8023eba: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 8023ebc: 6b7b         	ldr	r3, [r7, #0x34]
 8023ebe: 681b         	ldr	r3, [r3]
 8023ec0: 633b         	str	r3, [r7, #0x30]
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 8023ec2: 6b38         	ldr	r0, [r7, #0x30]
 8023ec4: f7ff fa2b    	bl	0x802331e <LL_USART_IsActiveFlag_TXE_TXFNF> @ imm = #-0xbaa
 8023ec8: 4603         	mov	r3, r0
 8023eca: 2b00         	cmp	r3, #0x0
 8023ecc: d0f9         	beq	0x8023ec2 <uart_stm32_poll_out_visitor+0x1a> @ imm = #-0xe
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8023ece: f3ef 8311    	mrs	r3, basepri
 8023ed2: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 8023ed4: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 8023ed6: 627b         	str	r3, [r7, #0x24]
 8023ed8: 2310         	movs	r3, #0x10
 8023eda: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8023edc: 6a3b         	ldr	r3, [r7, #0x20]
 8023ede: f383 8812    	msr	basepri_max, r3
; }
 8023ee2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8023ee4: f3bf 8f6f    	isb	sy
; }
 8023ee8: bf00         	nop
; 	return key;
 8023eea: 6a7b         	ldr	r3, [r7, #0x24]
; 			key = irq_lock();
 8023eec: 62fb         	str	r3, [r7, #0x2c]
; 			if (LL_USART_IsActiveFlag_TXE(usart)) {
 8023eee: 6b38         	ldr	r0, [r7, #0x30]
 8023ef0: f7ff fa15    	bl	0x802331e <LL_USART_IsActiveFlag_TXE_TXFNF> @ imm = #-0xbd6
 8023ef4: 4603         	mov	r3, r0
 8023ef6: 2b00         	cmp	r3, #0x0
 8023ef8: d10c         	bne	0x8023f14 <uart_stm32_poll_out_visitor+0x6c> @ imm = #0x18
 8023efa: 6afb         	ldr	r3, [r7, #0x2c]
 8023efc: 61fb         	str	r3, [r7, #0x1c]
 8023efe: 69fb         	ldr	r3, [r7, #0x1c]
 8023f00: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8023f02: 69bb         	ldr	r3, [r7, #0x18]
 8023f04: f383 8811    	msr	basepri, r3
; }
 8023f08: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8023f0a: f3bf 8f6f    	isb	sy
; }
 8023f0e: bf00         	nop
; }
 8023f10: bf00         	nop
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 8023f12: e7d6         	b	0x8023ec2 <uart_stm32_poll_out_visitor+0x1a> @ imm = #-0x54
; 				break;
 8023f14: bf00         	nop
; 	set_fn(usart, out);
 8023f16: 897a         	ldrh	r2, [r7, #0xa]
 8023f18: 687b         	ldr	r3, [r7, #0x4]
 8023f1a: 4611         	mov	r1, r2
 8023f1c: 6b38         	ldr	r0, [r7, #0x30]
 8023f1e: 4798         	blx	r3
 8023f20: 6afb         	ldr	r3, [r7, #0x2c]
 8023f22: 617b         	str	r3, [r7, #0x14]
 8023f24: 697b         	ldr	r3, [r7, #0x14]
 8023f26: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8023f28: 693b         	ldr	r3, [r7, #0x10]
 8023f2a: f383 8811    	msr	basepri, r3
; }
 8023f2e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8023f30: f3bf 8f6f    	isb	sy
; }
 8023f34: bf00         	nop
; }
 8023f36: bf00         	nop
; }
 8023f38: bf00         	nop
 8023f3a: 3738         	adds	r7, #0x38
 8023f3c: 46bd         	mov	sp, r7
 8023f3e: bd80         	pop	{r7, pc}

08023f40 <poll_in_u8>:
; {
 8023f40: b580         	push	{r7, lr}
 8023f42: b082         	sub	sp, #0x8
 8023f44: af00         	add	r7, sp, #0x0
 8023f46: 6078         	str	r0, [r7, #0x4]
 8023f48: 6039         	str	r1, [r7]
; 	*((unsigned char *)in) = (unsigned char)LL_USART_ReceiveData8(usart);
 8023f4a: 6878         	ldr	r0, [r7, #0x4]
 8023f4c: f7ff fcb8    	bl	0x80238c0 <LL_USART_ReceiveData8> @ imm = #-0x690
 8023f50: 4603         	mov	r3, r0
 8023f52: 461a         	mov	r2, r3
 8023f54: 683b         	ldr	r3, [r7]
 8023f56: 701a         	strb	r2, [r3]
; }
 8023f58: bf00         	nop
 8023f5a: 3708         	adds	r7, #0x8
 8023f5c: 46bd         	mov	sp, r7
 8023f5e: bd80         	pop	{r7, pc}

08023f60 <poll_out_u8>:
; {
 8023f60: b580         	push	{r7, lr}
 8023f62: b082         	sub	sp, #0x8
 8023f64: af00         	add	r7, sp, #0x0
 8023f66: 6078         	str	r0, [r7, #0x4]
 8023f68: 460b         	mov	r3, r1
 8023f6a: 807b         	strh	r3, [r7, #0x2]
; 	LL_USART_TransmitData8(usart, (uint8_t)out);
 8023f6c: 887b         	ldrh	r3, [r7, #0x2]
 8023f6e: b2db         	uxtb	r3, r3
 8023f70: 4619         	mov	r1, r3
 8023f72: 6878         	ldr	r0, [r7, #0x4]
 8023f74: f7ff fcb1    	bl	0x80238da <LL_USART_TransmitData8> @ imm = #-0x69e
; }
 8023f78: bf00         	nop
 8023f7a: 3708         	adds	r7, #0x8
 8023f7c: 46bd         	mov	sp, r7
 8023f7e: bd80         	pop	{r7, pc}

08023f80 <uart_stm32_err_check>:
; {
 8023f80: b580         	push	{r7, lr}
 8023f82: b086         	sub	sp, #0x18
 8023f84: af00         	add	r7, sp, #0x0
 8023f86: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8023f88: 687b         	ldr	r3, [r7, #0x4]
 8023f8a: 685b         	ldr	r3, [r3, #0x4]
 8023f8c: 613b         	str	r3, [r7, #0x10]
; 	USART_TypeDef *usart = config->usart;
 8023f8e: 693b         	ldr	r3, [r7, #0x10]
 8023f90: 681b         	ldr	r3, [r3]
 8023f92: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t err = 0U;
 8023f94: 2300         	movs	r3, #0x0
 8023f96: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 8023f98: 68f8         	ldr	r0, [r7, #0xc]
 8023f9a: f7ff f974    	bl	0x8023286 <LL_USART_IsActiveFlag_ORE> @ imm = #-0xd18
 8023f9e: 4603         	mov	r3, r0
 8023fa0: 2b00         	cmp	r3, #0x0
 8023fa2: d003         	beq	0x8023fac <uart_stm32_err_check+0x2c> @ imm = #0x6
; 		err |= UART_ERROR_OVERRUN;
 8023fa4: 697b         	ldr	r3, [r7, #0x14]
 8023fa6: f043 0301    	orr	r3, r3, #0x1
 8023faa: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_PE(usart)) {
 8023fac: 68f8         	ldr	r0, [r7, #0xc]
 8023fae: f7ff f931    	bl	0x8023214 <LL_USART_IsActiveFlag_PE> @ imm = #-0xd9e
 8023fb2: 4603         	mov	r3, r0
 8023fb4: 2b00         	cmp	r3, #0x0
 8023fb6: d003         	beq	0x8023fc0 <uart_stm32_err_check+0x40> @ imm = #0x6
; 		err |= UART_ERROR_PARITY;
 8023fb8: 697b         	ldr	r3, [r7, #0x14]
 8023fba: f043 0302    	orr	r3, r3, #0x2
 8023fbe: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_FE(usart)) {
 8023fc0: 68f8         	ldr	r0, [r7, #0xc]
 8023fc2: f7ff f93a    	bl	0x802323a <LL_USART_IsActiveFlag_FE> @ imm = #-0xd8c
 8023fc6: 4603         	mov	r3, r0
 8023fc8: 2b00         	cmp	r3, #0x0
 8023fca: d003         	beq	0x8023fd4 <uart_stm32_err_check+0x54> @ imm = #0x6
; 		err |= UART_ERROR_FRAMING;
 8023fcc: 697b         	ldr	r3, [r7, #0x14]
 8023fce: f043 0304    	orr	r3, r3, #0x4
 8023fd2: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_NE(usart)) {
 8023fd4: 68f8         	ldr	r0, [r7, #0xc]
 8023fd6: f7ff f943    	bl	0x8023260 <LL_USART_IsActiveFlag_NE> @ imm = #-0xd7a
 8023fda: 4603         	mov	r3, r0
 8023fdc: 2b00         	cmp	r3, #0x0
 8023fde: d003         	beq	0x8023fe8 <uart_stm32_err_check+0x68> @ imm = #0x6
; 		err |= UART_ERROR_NOISE;
 8023fe0: 697b         	ldr	r3, [r7, #0x14]
 8023fe2: f043 0320    	orr	r3, r3, #0x20
 8023fe6: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_LBD(usart)) {
 8023fe8: 68f8         	ldr	r0, [r7, #0xc]
 8023fea: f7ff f9ab    	bl	0x8023344 <LL_USART_IsActiveFlag_LBD> @ imm = #-0xcaa
 8023fee: 4603         	mov	r3, r0
 8023ff0: 2b00         	cmp	r3, #0x0
 8023ff2: d003         	beq	0x8023ffc <uart_stm32_err_check+0x7c> @ imm = #0x6
; 		err |= UART_BREAK;
 8023ff4: 697b         	ldr	r3, [r7, #0x14]
 8023ff6: f043 0308    	orr	r3, r3, #0x8
 8023ffa: 617b         	str	r3, [r7, #0x14]
; 	if (err & UART_BREAK) {
 8023ffc: 697b         	ldr	r3, [r7, #0x14]
 8023ffe: f003 0308    	and	r3, r3, #0x8
 8024002: 2b00         	cmp	r3, #0x0
 8024004: d002         	beq	0x802400c <uart_stm32_err_check+0x8c> @ imm = #0x4
; 		LL_USART_ClearFlag_LBD(usart);
 8024006: 68f8         	ldr	r0, [r7, #0xc]
 8024008: f7ff fa26    	bl	0x8023458 <LL_USART_ClearFlag_LBD> @ imm = #-0xbb4
; 	if (err & UART_ERROR_OVERRUN) {
 802400c: 697b         	ldr	r3, [r7, #0x14]
 802400e: f003 0301    	and	r3, r3, #0x1
 8024012: 2b00         	cmp	r3, #0x0
 8024014: d002         	beq	0x802401c <uart_stm32_err_check+0x9c> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 8024016: 68f8         	ldr	r0, [r7, #0xc]
 8024018: f7ff f9f7    	bl	0x802340a <LL_USART_ClearFlag_ORE> @ imm = #-0xc12
; 	if (err & UART_ERROR_PARITY) {
 802401c: 697b         	ldr	r3, [r7, #0x14]
 802401e: f003 0302    	and	r3, r3, #0x2
 8024022: 2b00         	cmp	r3, #0x0
 8024024: d002         	beq	0x802402c <uart_stm32_err_check+0xac> @ imm = #0x4
; 		LL_USART_ClearFlag_PE(usart);
 8024026: 68f8         	ldr	r0, [r7, #0xc]
 8024028: f7ff f9c8    	bl	0x80233bc <LL_USART_ClearFlag_PE> @ imm = #-0xc70
; 	if (err & UART_ERROR_FRAMING) {
 802402c: 697b         	ldr	r3, [r7, #0x14]
 802402e: f003 0304    	and	r3, r3, #0x4
 8024032: 2b00         	cmp	r3, #0x0
 8024034: d002         	beq	0x802403c <uart_stm32_err_check+0xbc> @ imm = #0x4
; 		LL_USART_ClearFlag_FE(usart);
 8024036: 68f8         	ldr	r0, [r7, #0xc]
 8024038: f7ff f9cd    	bl	0x80233d6 <LL_USART_ClearFlag_FE> @ imm = #-0xc66
; 	if (err & UART_ERROR_NOISE) {
 802403c: 697b         	ldr	r3, [r7, #0x14]
 802403e: f003 0320    	and	r3, r3, #0x20
 8024042: 2b00         	cmp	r3, #0x0
 8024044: d002         	beq	0x802404c <uart_stm32_err_check+0xcc> @ imm = #0x4
; 		LL_USART_ClearFlag_NE(usart);
 8024046: 68f8         	ldr	r0, [r7, #0xc]
 8024048: f7ff f9d2    	bl	0x80233f0 <LL_USART_ClearFlag_NE> @ imm = #-0xc5c
; 	return err;
 802404c: 697b         	ldr	r3, [r7, #0x14]
; }
 802404e: 4618         	mov	r0, r3
 8024050: 3718         	adds	r7, #0x18
 8024052: 46bd         	mov	sp, r7
 8024054: bd80         	pop	{r7, pc}

08024056 <uart_stm32_fifo_fill_visitor>:
; {
 8024056: b580         	push	{r7, lr}
 8024058: b08e         	sub	sp, #0x38
 802405a: af00         	add	r7, sp, #0x0
 802405c: 60f8         	str	r0, [r7, #0xc]
 802405e: 60b9         	str	r1, [r7, #0x8]
 8024060: 607a         	str	r2, [r7, #0x4]
 8024062: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8024064: 68fb         	ldr	r3, [r7, #0xc]
 8024066: 685b         	ldr	r3, [r3, #0x4]
 8024068: 633b         	str	r3, [r7, #0x30]
; 	USART_TypeDef *usart = config->usart;
 802406a: 6b3b         	ldr	r3, [r7, #0x30]
 802406c: 681b         	ldr	r3, [r3]
 802406e: 62fb         	str	r3, [r7, #0x2c]
; 	int num_tx = 0U;
 8024070: 2300         	movs	r3, #0x0
 8024072: 637b         	str	r3, [r7, #0x34]
; 	if (!LL_USART_IsActiveFlag_TXE(usart)) {
 8024074: 6af8         	ldr	r0, [r7, #0x2c]
 8024076: f7ff f952    	bl	0x802331e <LL_USART_IsActiveFlag_TXE_TXFNF> @ imm = #-0xd5c
 802407a: 4603         	mov	r3, r0
 802407c: 2b00         	cmp	r3, #0x0
 802407e: d101         	bne	0x8024084 <uart_stm32_fifo_fill_visitor+0x2e> @ imm = #0x2
; 		return num_tx;
 8024080: 6b7b         	ldr	r3, [r7, #0x34]
 8024082: e030         	b	0x80240e6 <uart_stm32_fifo_fill_visitor+0x90> @ imm = #0x60
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8024084: f3ef 8311    	mrs	r3, basepri
 8024088: 627b         	str	r3, [r7, #0x24]
;   return(result);
 802408a: 6a7b         	ldr	r3, [r7, #0x24]
; 	key = __get_BASEPRI();
 802408c: 623b         	str	r3, [r7, #0x20]
 802408e: 2310         	movs	r3, #0x10
 8024090: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8024092: 69fb         	ldr	r3, [r7, #0x1c]
 8024094: f383 8812    	msr	basepri_max, r3
; }
 8024098: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 802409a: f3bf 8f6f    	isb	sy
; }
 802409e: bf00         	nop
; 	return key;
 80240a0: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = irq_lock();
 80240a2: 62bb         	str	r3, [r7, #0x28]
; 	while ((size - num_tx > 0) && LL_USART_IsActiveFlag_TXE(usart)) {
 80240a4: e007         	b	0x80240b6 <uart_stm32_fifo_fill_visitor+0x60> @ imm = #0xe
; 		fill_fn(usart, tx_data, num_tx);
 80240a6: 683b         	ldr	r3, [r7]
 80240a8: 6b7a         	ldr	r2, [r7, #0x34]
 80240aa: 68b9         	ldr	r1, [r7, #0x8]
 80240ac: 6af8         	ldr	r0, [r7, #0x2c]
 80240ae: 4798         	blx	r3
; 		num_tx++;
 80240b0: 6b7b         	ldr	r3, [r7, #0x34]
 80240b2: 3301         	adds	r3, #0x1
 80240b4: 637b         	str	r3, [r7, #0x34]
; 	while ((size - num_tx > 0) && LL_USART_IsActiveFlag_TXE(usart)) {
 80240b6: 687a         	ldr	r2, [r7, #0x4]
 80240b8: 6b7b         	ldr	r3, [r7, #0x34]
 80240ba: 1ad3         	subs	r3, r2, r3
 80240bc: 2b00         	cmp	r3, #0x0
 80240be: dd05         	ble	0x80240cc <uart_stm32_fifo_fill_visitor+0x76> @ imm = #0xa
 80240c0: 6af8         	ldr	r0, [r7, #0x2c]
 80240c2: f7ff f92c    	bl	0x802331e <LL_USART_IsActiveFlag_TXE_TXFNF> @ imm = #-0xda8
 80240c6: 4603         	mov	r3, r0
 80240c8: 2b00         	cmp	r3, #0x0
 80240ca: d1ec         	bne	0x80240a6 <uart_stm32_fifo_fill_visitor+0x50> @ imm = #-0x28
 80240cc: 6abb         	ldr	r3, [r7, #0x28]
 80240ce: 61bb         	str	r3, [r7, #0x18]
 80240d0: 69bb         	ldr	r3, [r7, #0x18]
 80240d2: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80240d4: 697b         	ldr	r3, [r7, #0x14]
 80240d6: f383 8811    	msr	basepri, r3
; }
 80240da: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80240dc: f3bf 8f6f    	isb	sy
; }
 80240e0: bf00         	nop
; }
 80240e2: bf00         	nop
; 	return num_tx;
 80240e4: 6b7b         	ldr	r3, [r7, #0x34]
; }
 80240e6: 4618         	mov	r0, r3
 80240e8: 3738         	adds	r7, #0x38
 80240ea: 46bd         	mov	sp, r7
 80240ec: bd80         	pop	{r7, pc}

080240ee <fifo_fill_with_u8>:
; {
 80240ee: b580         	push	{r7, lr}
 80240f0: b086         	sub	sp, #0x18
 80240f2: af00         	add	r7, sp, #0x0
 80240f4: 60f8         	str	r0, [r7, #0xc]
 80240f6: 60b9         	str	r1, [r7, #0x8]
 80240f8: 607a         	str	r2, [r7, #0x4]
; 	const uint8_t *data = (const uint8_t *)tx_data;
 80240fa: 68bb         	ldr	r3, [r7, #0x8]
 80240fc: 617b         	str	r3, [r7, #0x14]
; 	LL_USART_TransmitData8(usart, data[offset]);
 80240fe: 687b         	ldr	r3, [r7, #0x4]
 8024100: 697a         	ldr	r2, [r7, #0x14]
 8024102: 4413         	add	r3, r2
 8024104: 781b         	ldrb	r3, [r3]
 8024106: 4619         	mov	r1, r3
 8024108: 68f8         	ldr	r0, [r7, #0xc]
 802410a: f7ff fbe6    	bl	0x80238da <LL_USART_TransmitData8> @ imm = #-0x834
; }
 802410e: bf00         	nop
 8024110: 3718         	adds	r7, #0x18
 8024112: 46bd         	mov	sp, r7
 8024114: bd80         	pop	{r7, pc}

08024116 <uart_stm32_fifo_read_visitor>:
; {
 8024116: b580         	push	{r7, lr}
 8024118: b088         	sub	sp, #0x20
 802411a: af00         	add	r7, sp, #0x0
 802411c: 60f8         	str	r0, [r7, #0xc]
 802411e: 60b9         	str	r1, [r7, #0x8]
 8024120: 607a         	str	r2, [r7, #0x4]
 8024122: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8024124: 68fb         	ldr	r3, [r7, #0xc]
 8024126: 685b         	ldr	r3, [r3, #0x4]
 8024128: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 802412a: 69bb         	ldr	r3, [r7, #0x18]
 802412c: 681b         	ldr	r3, [r3]
 802412e: 617b         	str	r3, [r7, #0x14]
; 	int num_rx = 0U;
 8024130: 2300         	movs	r3, #0x0
 8024132: 61fb         	str	r3, [r7, #0x1c]
; 	while ((size - num_rx > 0) && LL_USART_IsActiveFlag_RXNE(usart)) {
 8024134: e010         	b	0x8024158 <uart_stm32_fifo_read_visitor+0x42> @ imm = #0x20
; 		read_fn(usart, rx_data, num_rx);
 8024136: 683b         	ldr	r3, [r7]
 8024138: 69fa         	ldr	r2, [r7, #0x1c]
 802413a: 68b9         	ldr	r1, [r7, #0x8]
 802413c: 6978         	ldr	r0, [r7, #0x14]
 802413e: 4798         	blx	r3
; 		num_rx++;
 8024140: 69fb         	ldr	r3, [r7, #0x1c]
 8024142: 3301         	adds	r3, #0x1
 8024144: 61fb         	str	r3, [r7, #0x1c]
; 		if (LL_USART_IsActiveFlag_ORE(usart)) {
 8024146: 6978         	ldr	r0, [r7, #0x14]
 8024148: f7ff f89d    	bl	0x8023286 <LL_USART_IsActiveFlag_ORE> @ imm = #-0xec6
 802414c: 4603         	mov	r3, r0
 802414e: 2b00         	cmp	r3, #0x0
 8024150: d002         	beq	0x8024158 <uart_stm32_fifo_read_visitor+0x42> @ imm = #0x4
; 			LL_USART_ClearFlag_ORE(usart);
 8024152: 6978         	ldr	r0, [r7, #0x14]
 8024154: f7ff f959    	bl	0x802340a <LL_USART_ClearFlag_ORE> @ imm = #-0xd4e
; 	while ((size - num_rx > 0) && LL_USART_IsActiveFlag_RXNE(usart)) {
 8024158: 687a         	ldr	r2, [r7, #0x4]
 802415a: 69fb         	ldr	r3, [r7, #0x1c]
 802415c: 1ad3         	subs	r3, r2, r3
 802415e: 2b00         	cmp	r3, #0x0
 8024160: dd05         	ble	0x802416e <uart_stm32_fifo_read_visitor+0x58> @ imm = #0xa
 8024162: 6978         	ldr	r0, [r7, #0x14]
 8024164: f7ff f8b5    	bl	0x80232d2 <LL_USART_IsActiveFlag_RXNE_RXFNE> @ imm = #-0xe96
 8024168: 4603         	mov	r3, r0
 802416a: 2b00         	cmp	r3, #0x0
 802416c: d1e3         	bne	0x8024136 <uart_stm32_fifo_read_visitor+0x20> @ imm = #-0x3a
; 	return num_rx;
 802416e: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8024170: 4618         	mov	r0, r3
 8024172: 3720         	adds	r7, #0x20
 8024174: 46bd         	mov	sp, r7
 8024176: bd80         	pop	{r7, pc}

08024178 <fifo_read_with_u8>:
; {
 8024178: b590         	push	{r4, r7, lr}
 802417a: b087         	sub	sp, #0x1c
 802417c: af00         	add	r7, sp, #0x0
 802417e: 60f8         	str	r0, [r7, #0xc]
 8024180: 60b9         	str	r1, [r7, #0x8]
 8024182: 607a         	str	r2, [r7, #0x4]
; 	uint8_t *data = (uint8_t *)rx_data;
 8024184: 68bb         	ldr	r3, [r7, #0x8]
 8024186: 617b         	str	r3, [r7, #0x14]
; 	data[offset] = LL_USART_ReceiveData8(usart);
 8024188: 687b         	ldr	r3, [r7, #0x4]
 802418a: 697a         	ldr	r2, [r7, #0x14]
 802418c: 18d4         	adds	r4, r2, r3
 802418e: 68f8         	ldr	r0, [r7, #0xc]
 8024190: f7ff fb96    	bl	0x80238c0 <LL_USART_ReceiveData8> @ imm = #-0x8d4
 8024194: 4603         	mov	r3, r0
 8024196: 7023         	strb	r3, [r4]
; }
 8024198: bf00         	nop
 802419a: 371c         	adds	r7, #0x1c
 802419c: 46bd         	mov	sp, r7
 802419e: bd90         	pop	{r4, r7, pc}

080241a0 <uart_stm32_irq_tx_enable>:
; {
 80241a0: b580         	push	{r7, lr}
 80241a2: b084         	sub	sp, #0x10
 80241a4: af00         	add	r7, sp, #0x0
 80241a6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80241a8: 687b         	ldr	r3, [r7, #0x4]
 80241aa: 685b         	ldr	r3, [r3, #0x4]
 80241ac: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableIT_TC(config->usart);
 80241ae: 68fb         	ldr	r3, [r7, #0xc]
 80241b0: 681b         	ldr	r3, [r3]
 80241b2: 4618         	mov	r0, r3
 80241b4: f7ff f9a0    	bl	0x80234f8 <LL_USART_EnableIT_TC> @ imm = #-0xcc0
; }
 80241b8: bf00         	nop
 80241ba: 3710         	adds	r7, #0x10
 80241bc: 46bd         	mov	sp, r7
 80241be: bd80         	pop	{r7, pc}

080241c0 <uart_stm32_irq_tx_disable>:
; {
 80241c0: b580         	push	{r7, lr}
 80241c2: b084         	sub	sp, #0x10
 80241c4: af00         	add	r7, sp, #0x0
 80241c6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80241c8: 687b         	ldr	r3, [r7, #0x4]
 80241ca: 685b         	ldr	r3, [r3, #0x4]
 80241cc: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableIT_TC(config->usart);
 80241ce: 68fb         	ldr	r3, [r7, #0xc]
 80241d0: 681b         	ldr	r3, [r3]
 80241d2: 4618         	mov	r0, r3
 80241d4: f7ff fa47    	bl	0x8023666 <LL_USART_DisableIT_TC> @ imm = #-0xb72
; }
 80241d8: bf00         	nop
 80241da: 3710         	adds	r7, #0x10
 80241dc: 46bd         	mov	sp, r7
 80241de: bd80         	pop	{r7, pc}

080241e0 <uart_stm32_irq_tx_ready>:
; {
 80241e0: b580         	push	{r7, lr}
 80241e2: b084         	sub	sp, #0x10
 80241e4: af00         	add	r7, sp, #0x0
 80241e6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80241e8: 687b         	ldr	r3, [r7, #0x4]
 80241ea: 685b         	ldr	r3, [r3, #0x4]
 80241ec: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_TXE(config->usart) &&
 80241ee: 68fb         	ldr	r3, [r7, #0xc]
 80241f0: 681b         	ldr	r3, [r3]
 80241f2: 4618         	mov	r0, r3
 80241f4: f7ff f893    	bl	0x802331e <LL_USART_IsActiveFlag_TXE_TXFNF> @ imm = #-0xeda
 80241f8: 4603         	mov	r3, r0
 80241fa: 2b00         	cmp	r3, #0x0
 80241fc: d009         	beq	0x8024212 <uart_stm32_irq_tx_ready+0x32> @ imm = #0x12
; 		LL_USART_IsEnabledIT_TC(config->usart);
 80241fe: 68fb         	ldr	r3, [r7, #0xc]
 8024200: 681b         	ldr	r3, [r3]
 8024202: 4618         	mov	r0, r3
 8024204: f7ff faca    	bl	0x802379c <LL_USART_IsEnabledIT_TC> @ imm = #-0xa6c
 8024208: 4603         	mov	r3, r0
; 	return LL_USART_IsActiveFlag_TXE(config->usart) &&
 802420a: 2b00         	cmp	r3, #0x0
 802420c: d001         	beq	0x8024212 <uart_stm32_irq_tx_ready+0x32> @ imm = #0x2
 802420e: 2301         	movs	r3, #0x1
 8024210: e000         	b	0x8024214 <uart_stm32_irq_tx_ready+0x34> @ imm = #0x0
 8024212: 2300         	movs	r3, #0x0
; }
 8024214: 4618         	mov	r0, r3
 8024216: 3710         	adds	r7, #0x10
 8024218: 46bd         	mov	sp, r7
 802421a: bd80         	pop	{r7, pc}

0802421c <uart_stm32_irq_tx_complete>:
; {
 802421c: b580         	push	{r7, lr}
 802421e: b084         	sub	sp, #0x10
 8024220: af00         	add	r7, sp, #0x0
 8024222: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8024224: 687b         	ldr	r3, [r7, #0x4]
 8024226: 685b         	ldr	r3, [r3, #0x4]
 8024228: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_TC(config->usart);
 802422a: 68fb         	ldr	r3, [r7, #0xc]
 802422c: 681b         	ldr	r3, [r3]
 802422e: 4618         	mov	r0, r3
 8024230: f7ff f862    	bl	0x80232f8 <LL_USART_IsActiveFlag_TC> @ imm = #-0xf3c
 8024234: 4603         	mov	r3, r0
; }
 8024236: 4618         	mov	r0, r3
 8024238: 3710         	adds	r7, #0x10
 802423a: 46bd         	mov	sp, r7
 802423c: bd80         	pop	{r7, pc}

0802423e <uart_stm32_irq_rx_enable>:
; {
 802423e: b580         	push	{r7, lr}
 8024240: b084         	sub	sp, #0x10
 8024242: af00         	add	r7, sp, #0x0
 8024244: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8024246: 687b         	ldr	r3, [r7, #0x4]
 8024248: 685b         	ldr	r3, [r3, #0x4]
 802424a: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableIT_RXNE(config->usart);
 802424c: 68fb         	ldr	r3, [r7, #0xc]
 802424e: 681b         	ldr	r3, [r3]
 8024250: 4618         	mov	r0, r3
 8024252: f7ff f930    	bl	0x80234b6 <LL_USART_EnableIT_RXNE_RXFNE> @ imm = #-0xda0
; }
 8024256: bf00         	nop
 8024258: 3710         	adds	r7, #0x10
 802425a: 46bd         	mov	sp, r7
 802425c: bd80         	pop	{r7, pc}

0802425e <uart_stm32_irq_rx_disable>:
; {
 802425e: b580         	push	{r7, lr}
 8024260: b084         	sub	sp, #0x10
 8024262: af00         	add	r7, sp, #0x0
 8024264: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8024266: 687b         	ldr	r3, [r7, #0x4]
 8024268: 685b         	ldr	r3, [r3, #0x4]
 802426a: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableIT_RXNE(config->usart);
 802426c: 68fb         	ldr	r3, [r7, #0xc]
 802426e: 681b         	ldr	r3, [r3]
 8024270: 4618         	mov	r0, r3
 8024272: f7ff f9d7    	bl	0x8023624 <LL_USART_DisableIT_RXNE_RXFNE> @ imm = #-0xc52
; }
 8024276: bf00         	nop
 8024278: 3710         	adds	r7, #0x10
 802427a: 46bd         	mov	sp, r7
 802427c: bd80         	pop	{r7, pc}

0802427e <uart_stm32_irq_rx_ready>:
; {
 802427e: b580         	push	{r7, lr}
 8024280: b084         	sub	sp, #0x10
 8024282: af00         	add	r7, sp, #0x0
 8024284: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8024286: 687b         	ldr	r3, [r7, #0x4]
 8024288: 685b         	ldr	r3, [r3, #0x4]
 802428a: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_RXNE(config->usart);
 802428c: 68fb         	ldr	r3, [r7, #0xc]
 802428e: 681b         	ldr	r3, [r3]
 8024290: 4618         	mov	r0, r3
 8024292: f7ff f81e    	bl	0x80232d2 <LL_USART_IsActiveFlag_RXNE_RXFNE> @ imm = #-0xfc4
 8024296: 4603         	mov	r3, r0
; }
 8024298: 4618         	mov	r0, r3
 802429a: 3710         	adds	r7, #0x10
 802429c: 46bd         	mov	sp, r7
 802429e: bd80         	pop	{r7, pc}

080242a0 <uart_stm32_irq_is_pending>:
; {
 80242a0: b580         	push	{r7, lr}
 80242a2: b084         	sub	sp, #0x10
 80242a4: af00         	add	r7, sp, #0x0
 80242a6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80242a8: 687b         	ldr	r3, [r7, #0x4]
 80242aa: 685b         	ldr	r3, [r3, #0x4]
 80242ac: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 80242ae: 68fb         	ldr	r3, [r7, #0xc]
 80242b0: 681b         	ldr	r3, [r3]
 80242b2: 60bb         	str	r3, [r7, #0x8]
; 	return ((LL_USART_IsActiveFlag_RXNE(usart) &&
 80242b4: 68b8         	ldr	r0, [r7, #0x8]
 80242b6: f7ff f80c    	bl	0x80232d2 <LL_USART_IsActiveFlag_RXNE_RXFNE> @ imm = #-0xfe8
 80242ba: 4603         	mov	r3, r0
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 80242bc: 2b00         	cmp	r3, #0x0
 80242be: d005         	beq	0x80242cc <uart_stm32_irq_is_pending+0x2c> @ imm = #0xa
 80242c0: 68b8         	ldr	r0, [r7, #0x8]
 80242c2: f7ff fa58    	bl	0x8023776 <LL_USART_IsEnabledIT_RXNE_RXFNE> @ imm = #-0xb50
 80242c6: 4603         	mov	r3, r0
; 	return ((LL_USART_IsActiveFlag_RXNE(usart) &&
 80242c8: 2b00         	cmp	r3, #0x0
 80242ca: d10b         	bne	0x80242e4 <uart_stm32_irq_is_pending+0x44> @ imm = #0x16
; 		(LL_USART_IsActiveFlag_TC(usart) &&
 80242cc: 68b8         	ldr	r0, [r7, #0x8]
 80242ce: f7ff f813    	bl	0x80232f8 <LL_USART_IsActiveFlag_TC> @ imm = #-0xfda
 80242d2: 4603         	mov	r3, r0
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 80242d4: 2b00         	cmp	r3, #0x0
 80242d6: d007         	beq	0x80242e8 <uart_stm32_irq_is_pending+0x48> @ imm = #0xe
; 		 LL_USART_IsEnabledIT_TC(usart)));
 80242d8: 68b8         	ldr	r0, [r7, #0x8]
 80242da: f7ff fa5f    	bl	0x802379c <LL_USART_IsEnabledIT_TC> @ imm = #-0xb42
 80242de: 4603         	mov	r3, r0
; 		(LL_USART_IsActiveFlag_TC(usart) &&
 80242e0: 2b00         	cmp	r3, #0x0
 80242e2: d001         	beq	0x80242e8 <uart_stm32_irq_is_pending+0x48> @ imm = #0x2
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 80242e4: 2301         	movs	r3, #0x1
 80242e6: e000         	b	0x80242ea <uart_stm32_irq_is_pending+0x4a> @ imm = #0x0
 80242e8: 2300         	movs	r3, #0x0
; }
 80242ea: 4618         	mov	r0, r3
 80242ec: 3710         	adds	r7, #0x10
 80242ee: 46bd         	mov	sp, r7
 80242f0: bd80         	pop	{r7, pc}

080242f2 <uart_stm32_irq_update>:
; {
 80242f2: b480         	push	{r7}
 80242f4: b083         	sub	sp, #0xc
 80242f6: af00         	add	r7, sp, #0x0
 80242f8: 6078         	str	r0, [r7, #0x4]
; 	return 1;
 80242fa: 2301         	movs	r3, #0x1
; }
 80242fc: 4618         	mov	r0, r3
 80242fe: 370c         	adds	r7, #0xc
 8024300: 46bd         	mov	sp, r7
 8024302: f85d 7b04    	ldr	r7, [sp], #4
 8024306: 4770         	bx	lr

08024308 <uart_stm32_irq_callback_set>:
; {
 8024308: b480         	push	{r7}
 802430a: b087         	sub	sp, #0x1c
 802430c: af00         	add	r7, sp, #0x0
 802430e: 60f8         	str	r0, [r7, #0xc]
 8024310: 60b9         	str	r1, [r7, #0x8]
 8024312: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 8024314: 68fb         	ldr	r3, [r7, #0xc]
 8024316: 691b         	ldr	r3, [r3, #0x10]
 8024318: 617b         	str	r3, [r7, #0x14]
; 	data->user_cb = cb;
 802431a: 697b         	ldr	r3, [r7, #0x14]
 802431c: 68ba         	ldr	r2, [r7, #0x8]
 802431e: 609a         	str	r2, [r3, #0x8]
; 	data->user_data = cb_data;
 8024320: 697b         	ldr	r3, [r7, #0x14]
 8024322: 687a         	ldr	r2, [r7, #0x4]
 8024324: 60da         	str	r2, [r3, #0xc]
; 	data->async_cb = NULL;
 8024326: 697b         	ldr	r3, [r7, #0x14]
 8024328: 2200         	movs	r2, #0x0
 802432a: 615a         	str	r2, [r3, #0x14]
; 	data->async_user_data = NULL;
 802432c: 697b         	ldr	r3, [r7, #0x14]
 802432e: 2200         	movs	r2, #0x0
 8024330: 619a         	str	r2, [r3, #0x18]
; }
 8024332: bf00         	nop
 8024334: 371c         	adds	r7, #0x1c
 8024336: 46bd         	mov	sp, r7
 8024338: f85d 7b04    	ldr	r7, [sp], #4
 802433c: 4770         	bx	lr

0802433e <async_user_callback>:
; {
 802433e: b580         	push	{r7, lr}
 8024340: b082         	sub	sp, #0x8
 8024342: af00         	add	r7, sp, #0x0
 8024344: 6078         	str	r0, [r7, #0x4]
 8024346: 6039         	str	r1, [r7]
; 	if (data->async_cb) {
 8024348: 687b         	ldr	r3, [r7, #0x4]
 802434a: 695b         	ldr	r3, [r3, #0x14]
 802434c: 2b00         	cmp	r3, #0x0
 802434e: d007         	beq	0x8024360 <async_user_callback+0x22> @ imm = #0xe
; 		data->async_cb(data->uart_dev, event, data->async_user_data);
 8024350: 687b         	ldr	r3, [r7, #0x4]
 8024352: 695b         	ldr	r3, [r3, #0x14]
 8024354: 687a         	ldr	r2, [r7, #0x4]
 8024356: 6910         	ldr	r0, [r2, #0x10]
 8024358: 687a         	ldr	r2, [r7, #0x4]
 802435a: 6992         	ldr	r2, [r2, #0x18]
 802435c: 6839         	ldr	r1, [r7]
 802435e: 4798         	blx	r3
; }
 8024360: bf00         	nop
 8024362: 3708         	adds	r7, #0x8
 8024364: 46bd         	mov	sp, r7
 8024366: bd80         	pop	{r7, pc}

08024368 <async_evt_rx_buf_request>:
; {
 8024368: b580         	push	{r7, lr}
 802436a: b088         	sub	sp, #0x20
 802436c: af00         	add	r7, sp, #0x0
 802436e: 6078         	str	r0, [r7, #0x4]
; 	struct uart_event evt = {
 8024370: f107 030c    	add.w	r3, r7, #0xc
 8024374: 2200         	movs	r2, #0x0
 8024376: 601a         	str	r2, [r3]
 8024378: 605a         	str	r2, [r3, #0x4]
 802437a: 609a         	str	r2, [r3, #0x8]
 802437c: 60da         	str	r2, [r3, #0xc]
 802437e: 611a         	str	r2, [r3, #0x10]
 8024380: 2303         	movs	r3, #0x3
 8024382: 733b         	strb	r3, [r7, #0xc]
; 	async_user_callback(data, &evt);
 8024384: f107 030c    	add.w	r3, r7, #0xc
 8024388: 4619         	mov	r1, r3
 802438a: 6878         	ldr	r0, [r7, #0x4]
 802438c: f7ff ffd7    	bl	0x802433e <async_user_callback> @ imm = #-0x52
; }
 8024390: bf00         	nop
 8024392: 3720         	adds	r7, #0x20
 8024394: 46bd         	mov	sp, r7
 8024396: bd80         	pop	{r7, pc}

08024398 <async_evt_rx_buf_release>:
; {
 8024398: b580         	push	{r7, lr}
 802439a: b088         	sub	sp, #0x20
 802439c: af00         	add	r7, sp, #0x0
 802439e: 6078         	str	r0, [r7, #0x4]
; 	struct uart_event evt = {
 80243a0: f107 030c    	add.w	r3, r7, #0xc
 80243a4: 2200         	movs	r2, #0x0
 80243a6: 601a         	str	r2, [r3]
 80243a8: 605a         	str	r2, [r3, #0x4]
 80243aa: 609a         	str	r2, [r3, #0x8]
 80243ac: 60da         	str	r2, [r3, #0xc]
 80243ae: 611a         	str	r2, [r3, #0x10]
 80243b0: 2304         	movs	r3, #0x4
 80243b2: 733b         	strb	r3, [r7, #0xc]
; 		.data.rx_buf.buf = data->dma_rx.buffer,
 80243b4: 687b         	ldr	r3, [r7, #0x4]
 80243b6: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event evt = {
 80243b8: 613b         	str	r3, [r7, #0x10]
; 	async_user_callback(data, &evt);
 80243ba: f107 030c    	add.w	r3, r7, #0xc
 80243be: 4619         	mov	r1, r3
 80243c0: 6878         	ldr	r0, [r7, #0x4]
 80243c2: f7ff ffbc    	bl	0x802433e <async_user_callback> @ imm = #-0x88
; }
 80243c6: bf00         	nop
 80243c8: 3720         	adds	r7, #0x20
 80243ca: 46bd         	mov	sp, r7
 80243cc: bd80         	pop	{r7, pc}

080243ce <uart_stm32_dma_rx_flush>:
; {
 80243ce: b580         	push	{r7, lr}
 80243d0: b08c         	sub	sp, #0x30
 80243d2: af00         	add	r7, sp, #0x0
 80243d4: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 80243d6: 687b         	ldr	r3, [r7, #0x4]
 80243d8: 691b         	ldr	r3, [r3, #0x10]
 80243da: 62fb         	str	r3, [r7, #0x2c]
; 	if (dma_get_status(data->dma_rx.dma_dev,
 80243dc: 6afb         	ldr	r3, [r7, #0x2c]
 80243de: 6a18         	ldr	r0, [r3, #0x20]
 80243e0: 6afb         	ldr	r3, [r7, #0x2c]
 80243e2: 6a5b         	ldr	r3, [r3, #0x24]
 80243e4: f107 0208    	add.w	r2, r7, #0x8
 80243e8: 4619         	mov	r1, r3
 80243ea: f7fe fcd0    	bl	0x8022d8e <dma_get_status> @ imm = #-0x1660
 80243ee: 4603         	mov	r3, r0
 80243f0: 2b00         	cmp	r3, #0x0
 80243f2: d10f         	bne	0x8024414 <uart_stm32_dma_rx_flush+0x46> @ imm = #0x1e
; 		size_t rx_rcv_len = data->dma_rx.buffer_length -
 80243f4: 6afb         	ldr	r3, [r7, #0x2c]
 80243f6: 6f1a         	ldr	r2, [r3, #0x70]
; 					stat.pending_length;
 80243f8: 68fb         	ldr	r3, [r7, #0xc]
; 		size_t rx_rcv_len = data->dma_rx.buffer_length -
 80243fa: 1ad3         	subs	r3, r2, r3
 80243fc: 62bb         	str	r3, [r7, #0x28]
; 		if (rx_rcv_len > data->dma_rx.offset) {
 80243fe: 6afb         	ldr	r3, [r7, #0x2c]
 8024400: 6f5b         	ldr	r3, [r3, #0x74]
 8024402: 6aba         	ldr	r2, [r7, #0x28]
 8024404: 429a         	cmp	r2, r3
 8024406: d905         	bls	0x8024414 <uart_stm32_dma_rx_flush+0x46> @ imm = #0xa
; 			data->dma_rx.counter = rx_rcv_len;
 8024408: 6afb         	ldr	r3, [r7, #0x2c]
 802440a: 6aba         	ldr	r2, [r7, #0x28]
 802440c: 679a         	str	r2, [r3, #0x78]
; 			async_evt_rx_rdy(data);
 802440e: 6af8         	ldr	r0, [r7, #0x2c]
 8024410: f7ea fe1a    	bl	0x800f048 <async_evt_rx_rdy> @ imm = #-0x153cc
; }
 8024414: bf00         	nop
 8024416: 3730         	adds	r7, #0x30
 8024418: 46bd         	mov	sp, r7
 802441a: bd80         	pop	{r7, pc}

0802441c <uart_stm32_async_callback_set>:
; {
 802441c: b480         	push	{r7}
 802441e: b087         	sub	sp, #0x1c
 8024420: af00         	add	r7, sp, #0x0
 8024422: 60f8         	str	r0, [r7, #0xc]
 8024424: 60b9         	str	r1, [r7, #0x8]
 8024426: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 8024428: 68fb         	ldr	r3, [r7, #0xc]
 802442a: 691b         	ldr	r3, [r3, #0x10]
 802442c: 617b         	str	r3, [r7, #0x14]
; 	data->async_cb = callback;
 802442e: 697b         	ldr	r3, [r7, #0x14]
 8024430: 68ba         	ldr	r2, [r7, #0x8]
 8024432: 615a         	str	r2, [r3, #0x14]
; 	data->async_user_data = user_data;
 8024434: 697b         	ldr	r3, [r7, #0x14]
 8024436: 687a         	ldr	r2, [r7, #0x4]
 8024438: 619a         	str	r2, [r3, #0x18]
; 	data->user_cb = NULL;
 802443a: 697b         	ldr	r3, [r7, #0x14]
 802443c: 2200         	movs	r2, #0x0
 802443e: 609a         	str	r2, [r3, #0x8]
; 	data->user_data = NULL;
 8024440: 697b         	ldr	r3, [r7, #0x14]
 8024442: 2200         	movs	r2, #0x0
 8024444: 60da         	str	r2, [r3, #0xc]
; 	return 0;
 8024446: 2300         	movs	r3, #0x0
; }
 8024448: 4618         	mov	r0, r3
 802444a: 371c         	adds	r7, #0x1c
 802444c: 46bd         	mov	sp, r7
 802444e: f85d 7b04    	ldr	r7, [sp], #4
 8024452: 4770         	bx	lr

08024454 <uart_stm32_dma_tx_enable>:
; {
 8024454: b580         	push	{r7, lr}
 8024456: b084         	sub	sp, #0x10
 8024458: af00         	add	r7, sp, #0x0
 802445a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 802445c: 687b         	ldr	r3, [r7, #0x4]
 802445e: 685b         	ldr	r3, [r3, #0x4]
 8024460: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableDMAReq_TX(config->usart);
 8024462: 68fb         	ldr	r3, [r7, #0xc]
 8024464: 681b         	ldr	r3, [r3]
 8024466: 4618         	mov	r0, r3
 8024468: f7ff f9ce    	bl	0x8023808 <LL_USART_EnableDMAReq_TX> @ imm = #-0xc64
; }
 802446c: bf00         	nop
 802446e: 3710         	adds	r7, #0x10
 8024470: 46bd         	mov	sp, r7
 8024472: bd80         	pop	{r7, pc}

08024474 <uart_stm32_dma_tx_disable>:
; {
 8024474: b580         	push	{r7, lr}
 8024476: b084         	sub	sp, #0x10
 8024478: af00         	add	r7, sp, #0x0
 802447a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 802447c: 687b         	ldr	r3, [r7, #0x4]
 802447e: 685b         	ldr	r3, [r3, #0x4]
 8024480: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableDMAReq_TX(config->usart);
 8024482: 68fb         	ldr	r3, [r7, #0xc]
 8024484: 681b         	ldr	r3, [r3]
 8024486: 4618         	mov	r0, r3
 8024488: f7ff f9e1    	bl	0x802384e <LL_USART_DisableDMAReq_TX> @ imm = #-0xc3e
; }
 802448c: bf00         	nop
 802448e: 3710         	adds	r7, #0x10
 8024490: 46bd         	mov	sp, r7
 8024492: bd80         	pop	{r7, pc}

08024494 <uart_stm32_dma_rx_enable>:
; {
 8024494: b580         	push	{r7, lr}
 8024496: b084         	sub	sp, #0x10
 8024498: af00         	add	r7, sp, #0x0
 802449a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 802449c: 687b         	ldr	r3, [r7, #0x4]
 802449e: 685b         	ldr	r3, [r3, #0x4]
 80244a0: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_stm32_data *data = dev->data;
 80244a2: 687b         	ldr	r3, [r7, #0x4]
 80244a4: 691b         	ldr	r3, [r3, #0x10]
 80244a6: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_EnableDMAReq_RX(config->usart);
 80244a8: 68fb         	ldr	r3, [r7, #0xc]
 80244aa: 681b         	ldr	r3, [r3]
 80244ac: 4618         	mov	r0, r3
 80244ae: f7ff f988    	bl	0x80237c2 <LL_USART_EnableDMAReq_RX> @ imm = #-0xcf0
; 	data->dma_rx.enabled = true;
 80244b2: 68bb         	ldr	r3, [r7, #0x8]
 80244b4: 2201         	movs	r2, #0x1
 80244b6: f883 20b0    	strb.w	r2, [r3, #0xb0]
; }
 80244ba: bf00         	nop
 80244bc: 3710         	adds	r7, #0x10
 80244be: 46bd         	mov	sp, r7
 80244c0: bd80         	pop	{r7, pc}

080244c2 <uart_stm32_dma_rx_disable>:
; {
 80244c2: b480         	push	{r7}
 80244c4: b085         	sub	sp, #0x14
 80244c6: af00         	add	r7, sp, #0x0
 80244c8: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 80244ca: 687b         	ldr	r3, [r7, #0x4]
 80244cc: 691b         	ldr	r3, [r3, #0x10]
 80244ce: 60fb         	str	r3, [r7, #0xc]
; 	data->dma_rx.enabled = false;
 80244d0: 68fb         	ldr	r3, [r7, #0xc]
 80244d2: 2200         	movs	r2, #0x0
 80244d4: f883 20b0    	strb.w	r2, [r3, #0xb0]
; }
 80244d8: bf00         	nop
 80244da: 3714         	adds	r7, #0x14
 80244dc: 46bd         	mov	sp, r7
 80244de: f85d 7b04    	ldr	r7, [sp], #4
 80244e2: 4770         	bx	lr

080244e4 <uart_stm32_dma_tx_cb>:
; {
 80244e4: b580         	push	{r7, lr}
 80244e6: b094         	sub	sp, #0x50
 80244e8: af00         	add	r7, sp, #0x0
 80244ea: 60f8         	str	r0, [r7, #0xc]
 80244ec: 60b9         	str	r1, [r7, #0x8]
 80244ee: 607a         	str	r2, [r7, #0x4]
 80244f0: 603b         	str	r3, [r7]
; 	const struct device *uart_dev = user_data;
 80244f2: 68bb         	ldr	r3, [r7, #0x8]
 80244f4: 64fb         	str	r3, [r7, #0x4c]
; 	struct uart_stm32_data *data = uart_dev->data;
 80244f6: 6cfb         	ldr	r3, [r7, #0x4c]
 80244f8: 691b         	ldr	r3, [r3, #0x10]
 80244fa: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80244fc: f3ef 8311    	mrs	r3, basepri
 8024500: 643b         	str	r3, [r7, #0x40]
;   return(result);
 8024502: 6c3b         	ldr	r3, [r7, #0x40]
; 	key = __get_BASEPRI();
 8024504: 63fb         	str	r3, [r7, #0x3c]
 8024506: 2310         	movs	r3, #0x10
 8024508: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 802450a: 6bbb         	ldr	r3, [r7, #0x38]
 802450c: f383 8812    	msr	basepri_max, r3
; }
 8024510: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8024512: f3bf 8f6f    	isb	sy
; }
 8024516: bf00         	nop
; 	return key;
 8024518: 6bfb         	ldr	r3, [r7, #0x3c]
; 	unsigned int key = irq_lock();
 802451a: 647b         	str	r3, [r7, #0x44]
; 	uart_stm32_dma_tx_disable(uart_dev);
 802451c: 6cf8         	ldr	r0, [r7, #0x4c]
 802451e: f7ff ffa9    	bl	0x8024474 <uart_stm32_dma_tx_disable> @ imm = #-0xae
; 	(void)k_work_cancel_delayable(&data->dma_tx.timeout_work);
 8024522: 6cbb         	ldr	r3, [r7, #0x48]
 8024524: f503 738c    	add.w	r3, r3, #0x118
 8024528: 4618         	mov	r0, r3
 802452a: f7f1 fcc5    	bl	0x8015eb8 <k_work_cancel_delayable> @ imm = #-0xe676
; 	if (!dma_get_status(data->dma_tx.dma_dev,
 802452e: 6cbb         	ldr	r3, [r7, #0x48]
 8024530: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 8024534: 6cbb         	ldr	r3, [r7, #0x48]
 8024536: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 802453a: f107 0210    	add.w	r2, r7, #0x10
 802453e: 4619         	mov	r1, r3
 8024540: f7fe fc25    	bl	0x8022d8e <dma_get_status> @ imm = #-0x17b6
 8024544: 4603         	mov	r3, r0
 8024546: 2b00         	cmp	r3, #0x0
 8024548: d107         	bne	0x802455a <uart_stm32_dma_tx_cb+0x76> @ imm = #0xe
; 		data->dma_tx.counter = data->dma_tx.buffer_length -
 802454a: 6cbb         	ldr	r3, [r7, #0x48]
 802454c: f8d3 2108    	ldr.w	r2, [r3, #0x108]
; 					stat.pending_length;
 8024550: 697b         	ldr	r3, [r7, #0x14]
; 		data->dma_tx.counter = data->dma_tx.buffer_length -
 8024552: 1ad2         	subs	r2, r2, r3
 8024554: 6cbb         	ldr	r3, [r7, #0x48]
 8024556: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	data->dma_tx.buffer_length = 0;
 802455a: 6cbb         	ldr	r3, [r7, #0x48]
 802455c: 2200         	movs	r2, #0x0
 802455e: f8c3 2108    	str.w	r2, [r3, #0x108]
 8024562: 6c7b         	ldr	r3, [r7, #0x44]
 8024564: 637b         	str	r3, [r7, #0x34]
 8024566: 6b7b         	ldr	r3, [r7, #0x34]
 8024568: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 802456a: 6b3b         	ldr	r3, [r7, #0x30]
 802456c: f383 8811    	msr	basepri, r3
; }
 8024570: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8024572: f3bf 8f6f    	isb	sy
; }
 8024576: bf00         	nop
; }
 8024578: bf00         	nop
; }
 802457a: bf00         	nop
 802457c: 3750         	adds	r7, #0x50
 802457e: 46bd         	mov	sp, r7
 8024580: bd80         	pop	{r7, pc}

08024582 <uart_stm32_dma_rx_cb>:
; {
 8024582: b580         	push	{r7, lr}
 8024584: b086         	sub	sp, #0x18
 8024586: af00         	add	r7, sp, #0x0
 8024588: 60f8         	str	r0, [r7, #0xc]
 802458a: 60b9         	str	r1, [r7, #0x8]
 802458c: 607a         	str	r2, [r7, #0x4]
 802458e: 603b         	str	r3, [r7]
; 	const struct device *uart_dev = user_data;
 8024590: 68bb         	ldr	r3, [r7, #0x8]
 8024592: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = uart_dev->data;
 8024594: 697b         	ldr	r3, [r7, #0x14]
 8024596: 691b         	ldr	r3, [r3, #0x10]
 8024598: 613b         	str	r3, [r7, #0x10]
; 	if (status < 0) {
 802459a: 683b         	ldr	r3, [r7]
 802459c: 2b00         	cmp	r3, #0x0
 802459e: da04         	bge	0x80245aa <uart_stm32_dma_rx_cb+0x28> @ imm = #0x8
; 		async_evt_rx_err(data, status);
 80245a0: 6839         	ldr	r1, [r7]
 80245a2: 6938         	ldr	r0, [r7, #0x10]
 80245a4: f7ea fda6    	bl	0x800f0f4 <async_evt_rx_err> @ imm = #-0x154b4
; 		return;
 80245a8: e021         	b	0x80245ee <uart_stm32_dma_rx_cb+0x6c> @ imm = #0x42
; 	(void)k_work_cancel_delayable(&data->dma_rx.timeout_work);
 80245aa: 693b         	ldr	r3, [r7, #0x10]
 80245ac: 3380         	adds	r3, #0x80
 80245ae: 4618         	mov	r0, r3
 80245b0: f7f1 fc82    	bl	0x8015eb8 <k_work_cancel_delayable> @ imm = #-0xe6fc
; 	data->dma_rx.counter = data->dma_rx.buffer_length;
 80245b4: 693b         	ldr	r3, [r7, #0x10]
 80245b6: 6f1a         	ldr	r2, [r3, #0x70]
 80245b8: 693b         	ldr	r3, [r7, #0x10]
 80245ba: 679a         	str	r2, [r3, #0x78]
; 	async_evt_rx_rdy(data);
 80245bc: 6938         	ldr	r0, [r7, #0x10]
 80245be: f7ea fd43    	bl	0x800f048 <async_evt_rx_rdy> @ imm = #-0x1557a
; 	if (data->rx_next_buffer != NULL) {
 80245c2: 693b         	ldr	r3, [r7, #0x10]
 80245c4: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 80245c8: 2b00         	cmp	r3, #0x0
 80245ca: d006         	beq	0x80245da <uart_stm32_dma_rx_cb+0x58> @ imm = #0xc
; 		async_evt_rx_buf_release(data);
 80245cc: 6938         	ldr	r0, [r7, #0x10]
 80245ce: f7ff fee3    	bl	0x8024398 <async_evt_rx_buf_release> @ imm = #-0x23a
; 		uart_stm32_dma_replace_buffer(uart_dev);
 80245d2: 6978         	ldr	r0, [r7, #0x14]
 80245d4: f7ea ffd6    	bl	0x800f584 <uart_stm32_dma_replace_buffer> @ imm = #-0x15054
 80245d8: e009         	b	0x80245ee <uart_stm32_dma_rx_cb+0x6c> @ imm = #0x12
; 		k_work_reschedule(&data->dma_rx.timeout_work, K_TICKS(1));
 80245da: 693b         	ldr	r3, [r7, #0x10]
 80245dc: f103 0180    	add.w	r1, r3, #0x80
 80245e0: f04f 0201    	mov.w	r2, #0x1
 80245e4: f04f 0300    	mov.w	r3, #0x0
 80245e8: 4608         	mov	r0, r1
 80245ea: f7f1 fc51    	bl	0x8015e90 <k_work_reschedule> @ imm = #-0xe75e
; }
 80245ee: 3718         	adds	r7, #0x18
 80245f0: 46bd         	mov	sp, r7
 80245f2: bd80         	pop	{r7, pc}

080245f4 <uart_stm32_async_tx_abort>:
; {
 80245f4: b580         	push	{r7, lr}
 80245f6: b08c         	sub	sp, #0x30
 80245f8: af00         	add	r7, sp, #0x0
 80245fa: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 80245fc: 687b         	ldr	r3, [r7, #0x4]
 80245fe: 691b         	ldr	r3, [r3, #0x10]
 8024600: 62fb         	str	r3, [r7, #0x2c]
; 	size_t tx_buffer_length = data->dma_tx.buffer_length;
 8024602: 6afb         	ldr	r3, [r7, #0x2c]
 8024604: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 8024608: 62bb         	str	r3, [r7, #0x28]
; 	if (tx_buffer_length == 0) {
 802460a: 6abb         	ldr	r3, [r7, #0x28]
 802460c: 2b00         	cmp	r3, #0x0
 802460e: d102         	bne	0x8024616 <uart_stm32_async_tx_abort+0x22> @ imm = #0x4
; 		return -EFAULT;
 8024610: f06f 030d    	mvn	r3, #0xd
 8024614: e027         	b	0x8024666 <uart_stm32_async_tx_abort+0x72> @ imm = #0x4e
; 	(void)k_work_cancel_delayable(&data->dma_tx.timeout_work);
 8024616: 6afb         	ldr	r3, [r7, #0x2c]
 8024618: f503 738c    	add.w	r3, r3, #0x118
 802461c: 4618         	mov	r0, r3
 802461e: f7f1 fc4b    	bl	0x8015eb8 <k_work_cancel_delayable> @ imm = #-0xe76a
; 	if (!dma_get_status(data->dma_tx.dma_dev,
 8024622: 6afb         	ldr	r3, [r7, #0x2c]
 8024624: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 8024628: 6afb         	ldr	r3, [r7, #0x2c]
 802462a: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 802462e: f107 0208    	add.w	r2, r7, #0x8
 8024632: 4619         	mov	r1, r3
 8024634: f7fe fbab    	bl	0x8022d8e <dma_get_status> @ imm = #-0x18aa
 8024638: 4603         	mov	r3, r0
 802463a: 2b00         	cmp	r3, #0x0
 802463c: d105         	bne	0x802464a <uart_stm32_async_tx_abort+0x56> @ imm = #0xa
; 		data->dma_tx.counter = tx_buffer_length - stat.pending_length;
 802463e: 68fb         	ldr	r3, [r7, #0xc]
 8024640: 6aba         	ldr	r2, [r7, #0x28]
 8024642: 1ad2         	subs	r2, r2, r3
 8024644: 6afb         	ldr	r3, [r7, #0x2c]
 8024646: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	dma_stop(data->dma_tx.dma_dev, data->dma_tx.dma_channel);
 802464a: 6afb         	ldr	r3, [r7, #0x2c]
 802464c: f8d3 20b8    	ldr.w	r2, [r3, #0xb8]
 8024650: 6afb         	ldr	r3, [r7, #0x2c]
 8024652: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 8024656: 4619         	mov	r1, r3
 8024658: 4610         	mov	r0, r2
 802465a: f7fe fbc1    	bl	0x8022de0 <dma_stop>    @ imm = #-0x187e
; 	async_evt_tx_abort(data);
 802465e: 6af8         	ldr	r0, [r7, #0x2c]
 8024660: f7ea fdd8    	bl	0x800f214 <async_evt_tx_abort> @ imm = #-0x15450
; 	return 0;
 8024664: 2300         	movs	r3, #0x0
; }
 8024666: 4618         	mov	r0, r3
 8024668: 3730         	adds	r7, #0x30
 802466a: 46bd         	mov	sp, r7
 802466c: bd80         	pop	{r7, pc}

0802466e <uart_stm32_init>:
; {
 802466e: b580         	push	{r7, lr}
 8024670: b084         	sub	sp, #0x10
 8024672: af00         	add	r7, sp, #0x0
 8024674: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8024676: 687b         	ldr	r3, [r7, #0x4]
 8024678: 685b         	ldr	r3, [r3, #0x4]
 802467a: 60fb         	str	r3, [r7, #0xc]
; 	err = uart_stm32_clocks_enable(dev);
 802467c: 6878         	ldr	r0, [r7, #0x4]
 802467e: f7eb fbad    	bl	0x800fddc <uart_stm32_clocks_enable> @ imm = #-0x148a6
 8024682: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 8024684: 68bb         	ldr	r3, [r7, #0x8]
 8024686: 2b00         	cmp	r3, #0x0
 8024688: da01         	bge	0x802468e <uart_stm32_init+0x20> @ imm = #0x2
; 		return err;
 802468a: 68bb         	ldr	r3, [r7, #0x8]
 802468c: e01c         	b	0x80246c8 <uart_stm32_init+0x5a> @ imm = #0x38
; 	err = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
 802468e: 68fb         	ldr	r3, [r7, #0xc]
 8024690: 6a1b         	ldr	r3, [r3, #0x20]
 8024692: 2100         	movs	r1, #0x0
 8024694: 4618         	mov	r0, r3
 8024696: f7fe fbc5    	bl	0x8022e24 <pinctrl_apply_state> @ imm = #-0x1876
 802469a: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 802469c: 68bb         	ldr	r3, [r7, #0x8]
 802469e: 2b00         	cmp	r3, #0x0
 80246a0: da01         	bge	0x80246a6 <uart_stm32_init+0x38> @ imm = #0x2
; 		return err;
 80246a2: 68bb         	ldr	r3, [r7, #0x8]
 80246a4: e010         	b	0x80246c8 <uart_stm32_init+0x5a> @ imm = #0x20
; 	err = uart_stm32_registers_configure(dev);
 80246a6: 6878         	ldr	r0, [r7, #0x4]
 80246a8: f7eb fc00    	bl	0x800feac <uart_stm32_registers_configure> @ imm = #-0x14800
 80246ac: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 80246ae: 68bb         	ldr	r3, [r7, #0x8]
 80246b0: 2b00         	cmp	r3, #0x0
 80246b2: da01         	bge	0x80246b8 <uart_stm32_init+0x4a> @ imm = #0x2
; 		return err;
 80246b4: 68bb         	ldr	r3, [r7, #0x8]
 80246b6: e007         	b	0x80246c8 <uart_stm32_init+0x5a> @ imm = #0xe
; 	config->irq_config_func(dev);
 80246b8: 68fb         	ldr	r3, [r7, #0xc]
 80246ba: 6a5b         	ldr	r3, [r3, #0x24]
 80246bc: 6878         	ldr	r0, [r7, #0x4]
 80246be: 4798         	blx	r3
; 	return uart_stm32_async_init(dev);
 80246c0: 6878         	ldr	r0, [r7, #0x4]
 80246c2: f7eb fa7f    	bl	0x800fbc4 <uart_stm32_async_init> @ imm = #-0x14b02
 80246c6: 4603         	mov	r3, r0
; }
 80246c8: 4618         	mov	r0, r3
 80246ca: 3710         	adds	r7, #0x10
 80246cc: 46bd         	mov	sp, r7
 80246ce: bd80         	pop	{r7, pc}

080246d0 <uart_stm32_irq_config_func_0>:
; DT_INST_FOREACH_STATUS_OKAY(STM32_UART_INIT)
 80246d0: b580         	push	{r7, lr}
 80246d2: b082         	sub	sp, #0x8
 80246d4: af00         	add	r7, sp, #0x0
 80246d6: 6078         	str	r0, [r7, #0x4]
 80246d8: 2200         	movs	r2, #0x0
 80246da: 2100         	movs	r1, #0x0
 80246dc: 2025         	movs	r0, #0x25
 80246de: f7f8 ff79    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x710e
 80246e2: 2025         	movs	r0, #0x25
 80246e4: f7f8 ff69    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x712e
 80246e8: 3708         	adds	r7, #0x8
 80246ea: 46bd         	mov	sp, r7
 80246ec: bd80         	pop	{r7, pc}

080246ee <uart_stm32_irq_config_func_1>:
 80246ee: b580         	push	{r7, lr}
 80246f0: b082         	sub	sp, #0x8
 80246f2: af00         	add	r7, sp, #0x0
 80246f4: 6078         	str	r0, [r7, #0x4]
 80246f6: 2200         	movs	r2, #0x0
 80246f8: 2100         	movs	r1, #0x0
 80246fa: 2035         	movs	r0, #0x35
 80246fc: f7f8 ff6a    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x712c
 8024700: 2035         	movs	r0, #0x35
 8024702: f7f8 ff5a    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x714c
 8024706: 3708         	adds	r7, #0x8
 8024708: 46bd         	mov	sp, r7
 802470a: bd80         	pop	{r7, pc}

0802470c <uart_stm32_irq_config_func_2>:
 802470c: b580         	push	{r7, lr}
 802470e: b082         	sub	sp, #0x8
 8024710: af00         	add	r7, sp, #0x0
 8024712: 6078         	str	r0, [r7, #0x4]
 8024714: 2200         	movs	r2, #0x0
 8024716: 2100         	movs	r1, #0x0
 8024718: 2052         	movs	r0, #0x52
 802471a: f7f8 ff5b    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x714a
 802471e: 2052         	movs	r0, #0x52
 8024720: f7f8 ff4b    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x716a
 8024724: 3708         	adds	r7, #0x8
 8024726: 46bd         	mov	sp, r7
 8024728: bd80         	pop	{r7, pc}

0802472a <uart_stm32_irq_config_func_3>:
 802472a: b580         	push	{r7, lr}
 802472c: b082         	sub	sp, #0x8
 802472e: af00         	add	r7, sp, #0x0
 8024730: 6078         	str	r0, [r7, #0x4]
 8024732: 2200         	movs	r2, #0x0
 8024734: 2100         	movs	r1, #0x0
 8024736: 209c         	movs	r0, #0x9c
 8024738: f7f8 ff4c    	bl	0x801d5d4 <z_arm_irq_priority_set> @ imm = #-0x7168
 802473c: 209c         	movs	r0, #0x9c
 802473e: f7f8 ff3c    	bl	0x801d5ba <arch_irq_enable> @ imm = #-0x7188
 8024742: 3708         	adds	r7, #0x8
 8024744: 46bd         	mov	sp, r7
 8024746: bd80         	pop	{r7, pc}

08024748 <device_is_ready>:
; {
 8024748: b580         	push	{r7, lr}
 802474a: b082         	sub	sp, #0x8
 802474c: af00         	add	r7, sp, #0x0
 802474e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8024750: 6878         	ldr	r0, [r7, #0x4]
 8024752: f001 fe24    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x1c48
 8024756: 4603         	mov	r3, r0
; }
 8024758: 4618         	mov	r0, r3
 802475a: 3708         	adds	r7, #0x8
 802475c: 46bd         	mov	sp, r7
 802475e: bd80         	pop	{r7, pc}

08024760 <z_log_msg_runtime_create>:
; {
 8024760: b580         	push	{r7, lr}
 8024762: b08a         	sub	sp, #0x28
 8024764: af04         	add	r7, sp, #0x10
 8024766: 60b9         	str	r1, [r7, #0x8]
 8024768: 607b         	str	r3, [r7, #0x4]
 802476a: 4603         	mov	r3, r0
 802476c: 73fb         	strb	r3, [r7, #0xf]
 802476e: 4613         	mov	r3, r2
 8024770: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8024772: f107 032c    	add.w	r3, r7, #0x2c
 8024776: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8024778: 7bba         	ldrb	r2, [r7, #0xe]
 802477a: 7bf8         	ldrb	r0, [r7, #0xf]
 802477c: 697b         	ldr	r3, [r7, #0x14]
 802477e: 9303         	str	r3, [sp, #0xc]
 8024780: 6abb         	ldr	r3, [r7, #0x28]
 8024782: 9302         	str	r3, [sp, #0x8]
 8024784: 6a7b         	ldr	r3, [r7, #0x24]
 8024786: 9301         	str	r3, [sp, #0x4]
 8024788: 6a3b         	ldr	r3, [r7, #0x20]
 802478a: 9300         	str	r3, [sp]
 802478c: 687b         	ldr	r3, [r7, #0x4]
 802478e: 68b9         	ldr	r1, [r7, #0x8]
 8024790: f7e0 f9f0    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x1fc20
; }
 8024794: bf00         	nop
 8024796: 3718         	adds	r7, #0x18
 8024798: 46bd         	mov	sp, r7
 802479a: bd80         	pop	{r7, pc}

0802479c <z_impl_k_sem_count_get>:
; {
 802479c: b480         	push	{r7}
 802479e: b083         	sub	sp, #0xc
 80247a0: af00         	add	r7, sp, #0x0
 80247a2: 6078         	str	r0, [r7, #0x4]
; 	return sem->count;
 80247a4: 687b         	ldr	r3, [r7, #0x4]
 80247a6: 689b         	ldr	r3, [r3, #0x8]
; }
 80247a8: 4618         	mov	r0, r3
 80247aa: 370c         	adds	r7, #0xc
 80247ac: 46bd         	mov	sp, r7
 80247ae: f85d 7b04    	ldr	r7, [sp], #4
 80247b2: 4770         	bx	lr

080247b4 <k_busy_wait>:
; {
 80247b4: b580         	push	{r7, lr}
 80247b6: b082         	sub	sp, #0x8
 80247b8: af00         	add	r7, sp, #0x0
 80247ba: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_busy_wait(usec_to_wait);
 80247bc: 6878         	ldr	r0, [r7, #0x4]
 80247be: f001 fdc4    	bl	0x802634a <z_impl_k_busy_wait> @ imm = #0x1b88
; }
 80247c2: bf00         	nop
 80247c4: 3708         	adds	r7, #0x8
 80247c6: 46bd         	mov	sp, r7
 80247c8: bd80         	pop	{r7, pc}

080247ca <k_sem_take>:
; {
 80247ca: b580         	push	{r7, lr}
 80247cc: b084         	sub	sp, #0x10
 80247ce: af00         	add	r7, sp, #0x0
 80247d0: 60f8         	str	r0, [r7, #0xc]
 80247d2: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 80247d6: e9d7 2300    	ldrd	r2, r3, [r7]
 80247da: 68f8         	ldr	r0, [r7, #0xc]
 80247dc: f7f0 ffca    	bl	0x8015774 <z_impl_k_sem_take> @ imm = #-0xf06c
 80247e0: 4603         	mov	r3, r0
; }
 80247e2: 4618         	mov	r0, r3
 80247e4: 3710         	adds	r7, #0x10
 80247e6: 46bd         	mov	sp, r7
 80247e8: bd80         	pop	{r7, pc}

080247ea <k_sem_give>:
; {
 80247ea: b580         	push	{r7, lr}
 80247ec: b082         	sub	sp, #0x8
 80247ee: af00         	add	r7, sp, #0x0
 80247f0: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 80247f2: 6878         	ldr	r0, [r7, #0x4]
 80247f4: f7f0 ff30    	bl	0x8015658 <z_impl_k_sem_give> @ imm = #-0xf1a0
; }
 80247f8: bf00         	nop
 80247fa: 3708         	adds	r7, #0x8
 80247fc: 46bd         	mov	sp, r7
 80247fe: bd80         	pop	{r7, pc}

08024800 <k_sem_count_get>:
; {
 8024800: b580         	push	{r7, lr}
 8024802: b082         	sub	sp, #0x8
 8024804: af00         	add	r7, sp, #0x0
 8024806: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_sem_count_get(sem);
 8024808: 6878         	ldr	r0, [r7, #0x4]
 802480a: f7ff ffc7    	bl	0x802479c <z_impl_k_sem_count_get> @ imm = #-0x72
 802480e: 4603         	mov	r3, r0
; }
 8024810: 4618         	mov	r0, r3
 8024812: 3708         	adds	r7, #0x8
 8024814: 46bd         	mov	sp, r7
 8024816: bd80         	pop	{r7, pc}

08024818 <LL_SPI_Enable>:
; {
 8024818: b480         	push	{r7}
 802481a: b083         	sub	sp, #0xc
 802481c: af00         	add	r7, sp, #0x0
 802481e: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(SPIx->CR1, SPI_CR1_SPE);
 8024820: 687b         	ldr	r3, [r7, #0x4]
 8024822: 681b         	ldr	r3, [r3]
 8024824: f043 0201    	orr	r2, r3, #0x1
 8024828: 687b         	ldr	r3, [r7, #0x4]
 802482a: 601a         	str	r2, [r3]
; }
 802482c: bf00         	nop
 802482e: 370c         	adds	r7, #0xc
 8024830: 46bd         	mov	sp, r7
 8024832: f85d 7b04    	ldr	r7, [sp], #4
 8024836: 4770         	bx	lr

08024838 <LL_SPI_Disable>:
; {
 8024838: b480         	push	{r7}
 802483a: b083         	sub	sp, #0xc
 802483c: af00         	add	r7, sp, #0x0
 802483e: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 8024840: 687b         	ldr	r3, [r7, #0x4]
 8024842: 681b         	ldr	r3, [r3]
 8024844: f023 0201    	bic	r2, r3, #0x1
 8024848: 687b         	ldr	r3, [r7, #0x4]
 802484a: 601a         	str	r2, [r3]
; }
 802484c: bf00         	nop
 802484e: 370c         	adds	r7, #0xc
 8024850: 46bd         	mov	sp, r7
 8024852: f85d 7b04    	ldr	r7, [sp], #4
 8024856: 4770         	bx	lr

08024858 <LL_SPI_IsEnabled>:
; {
 8024858: b480         	push	{r7}
 802485a: b083         	sub	sp, #0xc
 802485c: af00         	add	r7, sp, #0x0
 802485e: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->CR1, SPI_CR1_SPE) == (SPI_CR1_SPE)) ? 1UL : 0UL);
 8024860: 687b         	ldr	r3, [r7, #0x4]
 8024862: 681b         	ldr	r3, [r3]
 8024864: f003 0301    	and	r3, r3, #0x1
 8024868: 2b01         	cmp	r3, #0x1
 802486a: d101         	bne	0x8024870 <LL_SPI_IsEnabled+0x18> @ imm = #0x2
 802486c: 2301         	movs	r3, #0x1
 802486e: e000         	b	0x8024872 <LL_SPI_IsEnabled+0x1a> @ imm = #0x0
 8024870: 2300         	movs	r3, #0x0
; }
 8024872: 4618         	mov	r0, r3
 8024874: 370c         	adds	r7, #0xc
 8024876: 46bd         	mov	sp, r7
 8024878: f85d 7b04    	ldr	r7, [sp], #4
 802487c: 4770         	bx	lr

0802487e <LL_SPI_SetMode>:
; {
 802487e: b480         	push	{r7}
 8024880: b083         	sub	sp, #0xc
 8024882: af00         	add	r7, sp, #0x0
 8024884: 6078         	str	r0, [r7, #0x4]
 8024886: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CFG2, SPI_CFG2_MASTER, Mode);
 8024888: 687b         	ldr	r3, [r7, #0x4]
 802488a: 68db         	ldr	r3, [r3, #0xc]
 802488c: f423 0280    	bic	r2, r3, #0x400000
 8024890: 683b         	ldr	r3, [r7]
 8024892: 431a         	orrs	r2, r3
 8024894: 687b         	ldr	r3, [r7, #0x4]
 8024896: 60da         	str	r2, [r3, #0xc]
; }
 8024898: bf00         	nop
 802489a: 370c         	adds	r7, #0xc
 802489c: 46bd         	mov	sp, r7
 802489e: f85d 7b04    	ldr	r7, [sp], #4
 80248a2: 4770         	bx	lr

080248a4 <LL_SPI_GetMode>:
; {
 80248a4: b480         	push	{r7}
 80248a6: b083         	sub	sp, #0xc
 80248a8: af00         	add	r7, sp, #0x0
 80248aa: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SPIx->CFG2, SPI_CFG2_MASTER));
 80248ac: 687b         	ldr	r3, [r7, #0x4]
 80248ae: 68db         	ldr	r3, [r3, #0xc]
 80248b0: f403 0380    	and	r3, r3, #0x400000
; }
 80248b4: 4618         	mov	r0, r3
 80248b6: 370c         	adds	r7, #0xc
 80248b8: 46bd         	mov	sp, r7
 80248ba: f85d 7b04    	ldr	r7, [sp], #4
 80248be: 4770         	bx	lr

080248c0 <LL_SPI_SetMasterSSIdleness>:
; {
 80248c0: b480         	push	{r7}
 80248c2: b083         	sub	sp, #0xc
 80248c4: af00         	add	r7, sp, #0x0
 80248c6: 6078         	str	r0, [r7, #0x4]
 80248c8: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CFG2, SPI_CFG2_MSSI, MasterSSIdleness);
 80248ca: 687b         	ldr	r3, [r7, #0x4]
 80248cc: 68db         	ldr	r3, [r3, #0xc]
 80248ce: f023 020f    	bic	r2, r3, #0xf
 80248d2: 683b         	ldr	r3, [r7]
 80248d4: 431a         	orrs	r2, r3
 80248d6: 687b         	ldr	r3, [r7, #0x4]
 80248d8: 60da         	str	r2, [r3, #0xc]
; }
 80248da: bf00         	nop
 80248dc: 370c         	adds	r7, #0xc
 80248de: 46bd         	mov	sp, r7
 80248e0: f85d 7b04    	ldr	r7, [sp], #4
 80248e4: 4770         	bx	lr

080248e6 <LL_SPI_SetInterDataIdleness>:
; {
 80248e6: b480         	push	{r7}
 80248e8: b083         	sub	sp, #0xc
 80248ea: af00         	add	r7, sp, #0x0
 80248ec: 6078         	str	r0, [r7, #0x4]
 80248ee: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CFG2, SPI_CFG2_MIDI, MasterInterDataIdleness);
 80248f0: 687b         	ldr	r3, [r7, #0x4]
 80248f2: 68db         	ldr	r3, [r3, #0xc]
 80248f4: f023 02f0    	bic	r2, r3, #0xf0
 80248f8: 683b         	ldr	r3, [r7]
 80248fa: 431a         	orrs	r2, r3
 80248fc: 687b         	ldr	r3, [r7, #0x4]
 80248fe: 60da         	str	r2, [r3, #0xc]
; }
 8024900: bf00         	nop
 8024902: 370c         	adds	r7, #0xc
 8024904: 46bd         	mov	sp, r7
 8024906: f85d 7b04    	ldr	r7, [sp], #4
 802490a: 4770         	bx	lr

0802490c <LL_SPI_GetTransferSize>:
; {
 802490c: b480         	push	{r7}
 802490e: b083         	sub	sp, #0xc
 8024910: af00         	add	r7, sp, #0x0
 8024912: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SPIx->CR2, SPI_CR2_TSIZE));
 8024914: 687b         	ldr	r3, [r7, #0x4]
 8024916: 685b         	ldr	r3, [r3, #0x4]
 8024918: b29b         	uxth	r3, r3
; }
 802491a: 4618         	mov	r0, r3
 802491c: 370c         	adds	r7, #0xc
 802491e: 46bd         	mov	sp, r7
 8024920: f85d 7b04    	ldr	r7, [sp], #4
 8024924: 4770         	bx	lr

08024926 <LL_SPI_SetInternalSSLevel>:
; {
 8024926: b480         	push	{r7}
 8024928: b083         	sub	sp, #0xc
 802492a: af00         	add	r7, sp, #0x0
 802492c: 6078         	str	r0, [r7, #0x4]
 802492e: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_SSI, SSLevel);
 8024930: 687b         	ldr	r3, [r7, #0x4]
 8024932: 681b         	ldr	r3, [r3]
 8024934: f423 5280    	bic	r2, r3, #0x1000
 8024938: 683b         	ldr	r3, [r7]
 802493a: 431a         	orrs	r2, r3
 802493c: 687b         	ldr	r3, [r7, #0x4]
 802493e: 601a         	str	r2, [r3]
; }
 8024940: bf00         	nop
 8024942: 370c         	adds	r7, #0xc
 8024944: 46bd         	mov	sp, r7
 8024946: f85d 7b04    	ldr	r7, [sp], #4
 802494a: 4770         	bx	lr

0802494c <LL_SPI_StartMasterTransfer>:
; {
 802494c: b480         	push	{r7}
 802494e: b083         	sub	sp, #0xc
 8024950: af00         	add	r7, sp, #0x0
 8024952: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(SPIx->CR1, SPI_CR1_CSTART);
 8024954: 687b         	ldr	r3, [r7, #0x4]
 8024956: 681b         	ldr	r3, [r3]
 8024958: f443 7200    	orr	r2, r3, #0x200
 802495c: 687b         	ldr	r3, [r7, #0x4]
 802495e: 601a         	str	r2, [r3]
; }
 8024960: bf00         	nop
 8024962: 370c         	adds	r7, #0xc
 8024964: 46bd         	mov	sp, r7
 8024966: f85d 7b04    	ldr	r7, [sp], #4
 802496a: 4770         	bx	lr

0802496c <LL_SPI_IsActiveMasterTransfer>:
; {
 802496c: b480         	push	{r7}
 802496e: b083         	sub	sp, #0xc
 8024970: af00         	add	r7, sp, #0x0
 8024972: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->CR1, SPI_CR1_CSTART) == (SPI_CR1_CSTART)) ? 1UL : 0UL);
 8024974: 687b         	ldr	r3, [r7, #0x4]
 8024976: 681b         	ldr	r3, [r3]
 8024978: f403 7300    	and	r3, r3, #0x200
 802497c: f5b3 7f00    	cmp.w	r3, #0x200
 8024980: d101         	bne	0x8024986 <LL_SPI_IsActiveMasterTransfer+0x1a> @ imm = #0x2
 8024982: 2301         	movs	r3, #0x1
 8024984: e000         	b	0x8024988 <LL_SPI_IsActiveMasterTransfer+0x1c> @ imm = #0x0
 8024986: 2300         	movs	r3, #0x0
; }
 8024988: 4618         	mov	r0, r3
 802498a: 370c         	adds	r7, #0xc
 802498c: 46bd         	mov	sp, r7
 802498e: f85d 7b04    	ldr	r7, [sp], #4
 8024992: 4770         	bx	lr

08024994 <LL_SPI_SetStandard>:
; {
 8024994: b480         	push	{r7}
 8024996: b083         	sub	sp, #0xc
 8024998: af00         	add	r7, sp, #0x0
 802499a: 6078         	str	r0, [r7, #0x4]
 802499c: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CFG2, SPI_CFG2_SP, Standard);
 802499e: 687b         	ldr	r3, [r7, #0x4]
 80249a0: 68db         	ldr	r3, [r3, #0xc]
 80249a2: f423 1260    	bic	r2, r3, #0x380000
 80249a6: 683b         	ldr	r3, [r7]
 80249a8: 431a         	orrs	r2, r3
 80249aa: 687b         	ldr	r3, [r7, #0x4]
 80249ac: 60da         	str	r2, [r3, #0xc]
; }
 80249ae: bf00         	nop
 80249b0: 370c         	adds	r7, #0xc
 80249b2: 46bd         	mov	sp, r7
 80249b4: f85d 7b04    	ldr	r7, [sp], #4
 80249b8: 4770         	bx	lr

080249ba <LL_SPI_SetClockPhase>:
; {
 80249ba: b480         	push	{r7}
 80249bc: b083         	sub	sp, #0xc
 80249be: af00         	add	r7, sp, #0x0
 80249c0: 6078         	str	r0, [r7, #0x4]
 80249c2: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CFG2, SPI_CFG2_CPHA, ClockPhase);
 80249c4: 687b         	ldr	r3, [r7, #0x4]
 80249c6: 68db         	ldr	r3, [r3, #0xc]
 80249c8: f023 7280    	bic	r2, r3, #0x1000000
 80249cc: 683b         	ldr	r3, [r7]
 80249ce: 431a         	orrs	r2, r3
 80249d0: 687b         	ldr	r3, [r7, #0x4]
 80249d2: 60da         	str	r2, [r3, #0xc]
; }
 80249d4: bf00         	nop
 80249d6: 370c         	adds	r7, #0xc
 80249d8: 46bd         	mov	sp, r7
 80249da: f85d 7b04    	ldr	r7, [sp], #4
 80249de: 4770         	bx	lr

080249e0 <LL_SPI_SetClockPolarity>:
; {
 80249e0: b480         	push	{r7}
 80249e2: b083         	sub	sp, #0xc
 80249e4: af00         	add	r7, sp, #0x0
 80249e6: 6078         	str	r0, [r7, #0x4]
 80249e8: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CFG2, SPI_CFG2_CPOL, ClockPolarity);
 80249ea: 687b         	ldr	r3, [r7, #0x4]
 80249ec: 68db         	ldr	r3, [r3, #0xc]
 80249ee: f023 7200    	bic	r2, r3, #0x2000000
 80249f2: 683b         	ldr	r3, [r7]
 80249f4: 431a         	orrs	r2, r3
 80249f6: 687b         	ldr	r3, [r7, #0x4]
 80249f8: 60da         	str	r2, [r3, #0xc]
; }
 80249fa: bf00         	nop
 80249fc: 370c         	adds	r7, #0xc
 80249fe: 46bd         	mov	sp, r7
 8024a00: f85d 7b04    	ldr	r7, [sp], #4
 8024a04: 4770         	bx	lr

08024a06 <LL_SPI_GetNSSPolarity>:
; {
 8024a06: b480         	push	{r7}
 8024a08: b083         	sub	sp, #0xc
 8024a0a: af00         	add	r7, sp, #0x0
 8024a0c: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SPIx->CFG2, SPI_CFG2_SSIOP));
 8024a0e: 687b         	ldr	r3, [r7, #0x4]
 8024a10: 68db         	ldr	r3, [r3, #0xc]
 8024a12: f003 5380    	and	r3, r3, #0x10000000
; }
 8024a16: 4618         	mov	r0, r3
 8024a18: 370c         	adds	r7, #0xc
 8024a1a: 46bd         	mov	sp, r7
 8024a1c: f85d 7b04    	ldr	r7, [sp], #4
 8024a20: 4770         	bx	lr

08024a22 <LL_SPI_SetBaudRatePrescaler>:
; {
 8024a22: b480         	push	{r7}
 8024a24: b083         	sub	sp, #0xc
 8024a26: af00         	add	r7, sp, #0x0
 8024a28: 6078         	str	r0, [r7, #0x4]
 8024a2a: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CFG1, SPI_CFG1_MBR, Baudrate);
 8024a2c: 687b         	ldr	r3, [r7, #0x4]
 8024a2e: 689b         	ldr	r3, [r3, #0x8]
 8024a30: f023 42e0    	bic	r2, r3, #0x70000000
 8024a34: 683b         	ldr	r3, [r7]
 8024a36: 431a         	orrs	r2, r3
 8024a38: 687b         	ldr	r3, [r7, #0x4]
 8024a3a: 609a         	str	r2, [r3, #0x8]
; }
 8024a3c: bf00         	nop
 8024a3e: 370c         	adds	r7, #0xc
 8024a40: 46bd         	mov	sp, r7
 8024a42: f85d 7b04    	ldr	r7, [sp], #4
 8024a46: 4770         	bx	lr

08024a48 <LL_SPI_SetTransferBitOrder>:
; {
 8024a48: b480         	push	{r7}
 8024a4a: b083         	sub	sp, #0xc
 8024a4c: af00         	add	r7, sp, #0x0
 8024a4e: 6078         	str	r0, [r7, #0x4]
 8024a50: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CFG2, SPI_CFG2_LSBFRST, BitOrder);
 8024a52: 687b         	ldr	r3, [r7, #0x4]
 8024a54: 68db         	ldr	r3, [r3, #0xc]
 8024a56: f423 0200    	bic	r2, r3, #0x800000
 8024a5a: 683b         	ldr	r3, [r7]
 8024a5c: 431a         	orrs	r2, r3
 8024a5e: 687b         	ldr	r3, [r7, #0x4]
 8024a60: 60da         	str	r2, [r3, #0xc]
; }
 8024a62: bf00         	nop
 8024a64: 370c         	adds	r7, #0xc
 8024a66: 46bd         	mov	sp, r7
 8024a68: f85d 7b04    	ldr	r7, [sp], #4
 8024a6c: 4770         	bx	lr

08024a6e <LL_SPI_SetTransferDirection>:
; {
 8024a6e: b480         	push	{r7}
 8024a70: b083         	sub	sp, #0xc
 8024a72: af00         	add	r7, sp, #0x0
 8024a74: 6078         	str	r0, [r7, #0x4]
 8024a76: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_HDDIR,  TransferDirection & SPI_CR1_HDDIR);
 8024a78: 687b         	ldr	r3, [r7, #0x4]
 8024a7a: 681b         	ldr	r3, [r3]
 8024a7c: f423 6200    	bic	r2, r3, #0x800
 8024a80: 683b         	ldr	r3, [r7]
 8024a82: f403 6300    	and	r3, r3, #0x800
 8024a86: 431a         	orrs	r2, r3
 8024a88: 687b         	ldr	r3, [r7, #0x4]
 8024a8a: 601a         	str	r2, [r3]
;   MODIFY_REG(SPIx->CFG2, SPI_CFG2_COMM, TransferDirection & SPI_CFG2_COMM);
 8024a8c: 687b         	ldr	r3, [r7, #0x4]
 8024a8e: 68db         	ldr	r3, [r3, #0xc]
 8024a90: f423 22c0    	bic	r2, r3, #0x60000
 8024a94: 683b         	ldr	r3, [r7]
 8024a96: f403 23c0    	and	r3, r3, #0x60000
 8024a9a: 431a         	orrs	r2, r3
 8024a9c: 687b         	ldr	r3, [r7, #0x4]
 8024a9e: 60da         	str	r2, [r3, #0xc]
; }
 8024aa0: bf00         	nop
 8024aa2: 370c         	adds	r7, #0xc
 8024aa4: 46bd         	mov	sp, r7
 8024aa6: f85d 7b04    	ldr	r7, [sp], #4
 8024aaa: 4770         	bx	lr

08024aac <LL_SPI_SetDataWidth>:
; {
 8024aac: b480         	push	{r7}
 8024aae: b083         	sub	sp, #0xc
 8024ab0: af00         	add	r7, sp, #0x0
 8024ab2: 6078         	str	r0, [r7, #0x4]
 8024ab4: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CFG1, SPI_CFG1_DSIZE, DataWidth);
 8024ab6: 687b         	ldr	r3, [r7, #0x4]
 8024ab8: 689b         	ldr	r3, [r3, #0x8]
 8024aba: f023 021f    	bic	r2, r3, #0x1f
 8024abe: 683b         	ldr	r3, [r7]
 8024ac0: 431a         	orrs	r2, r3
 8024ac2: 687b         	ldr	r3, [r7, #0x4]
 8024ac4: 609a         	str	r2, [r3, #0x8]
; }
 8024ac6: bf00         	nop
 8024ac8: 370c         	adds	r7, #0xc
 8024aca: 46bd         	mov	sp, r7
 8024acc: f85d 7b04    	ldr	r7, [sp], #4
 8024ad0: 4770         	bx	lr

08024ad2 <LL_SPI_SetFIFOThreshold>:
; {
 8024ad2: b480         	push	{r7}
 8024ad4: b083         	sub	sp, #0xc
 8024ad6: af00         	add	r7, sp, #0x0
 8024ad8: 6078         	str	r0, [r7, #0x4]
 8024ada: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CFG1, SPI_CFG1_FTHLV, Threshold);
 8024adc: 687b         	ldr	r3, [r7, #0x4]
 8024ade: 689b         	ldr	r3, [r3, #0x8]
 8024ae0: f423 72f0    	bic	r2, r3, #0x1e0
 8024ae4: 683b         	ldr	r3, [r7]
 8024ae6: 431a         	orrs	r2, r3
 8024ae8: 687b         	ldr	r3, [r7, #0x4]
 8024aea: 609a         	str	r2, [r3, #0x8]
; }
 8024aec: bf00         	nop
 8024aee: 370c         	adds	r7, #0xc
 8024af0: 46bd         	mov	sp, r7
 8024af2: f85d 7b04    	ldr	r7, [sp], #4
 8024af6: 4770         	bx	lr

08024af8 <LL_SPI_DisableCRC>:
; {
 8024af8: b480         	push	{r7}
 8024afa: b083         	sub	sp, #0xc
 8024afc: af00         	add	r7, sp, #0x0
 8024afe: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CFG1, SPI_CFG1_CRCEN);
 8024b00: 687b         	ldr	r3, [r7, #0x4]
 8024b02: 689b         	ldr	r3, [r3, #0x8]
 8024b04: f423 0280    	bic	r2, r3, #0x400000
 8024b08: 687b         	ldr	r3, [r7, #0x4]
 8024b0a: 609a         	str	r2, [r3, #0x8]
; }
 8024b0c: bf00         	nop
 8024b0e: 370c         	adds	r7, #0xc
 8024b10: 46bd         	mov	sp, r7
 8024b12: f85d 7b04    	ldr	r7, [sp], #4
 8024b16: 4770         	bx	lr

08024b18 <LL_SPI_SetNSSMode>:
; {
 8024b18: b480         	push	{r7}
 8024b1a: b083         	sub	sp, #0xc
 8024b1c: af00         	add	r7, sp, #0x0
 8024b1e: 6078         	str	r0, [r7, #0x4]
 8024b20: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CFG2, SPI_CFG2_SSM | SPI_CFG2_SSOE, NSS);
 8024b22: 687b         	ldr	r3, [r7, #0x4]
 8024b24: 68db         	ldr	r3, [r3, #0xc]
 8024b26: f023 5210    	bic	r2, r3, #0x24000000
 8024b2a: 683b         	ldr	r3, [r7]
 8024b2c: 431a         	orrs	r2, r3
 8024b2e: 687b         	ldr	r3, [r7, #0x4]
 8024b30: 60da         	str	r2, [r3, #0xc]
; }
 8024b32: bf00         	nop
 8024b34: 370c         	adds	r7, #0xc
 8024b36: 46bd         	mov	sp, r7
 8024b38: f85d 7b04    	ldr	r7, [sp], #4
 8024b3c: 4770         	bx	lr

08024b3e <LL_SPI_IsActiveFlag_RXP>:
; {
 8024b3e: b480         	push	{r7}
 8024b40: b083         	sub	sp, #0xc
 8024b42: af00         	add	r7, sp, #0x0
 8024b44: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_RXP) == (SPI_SR_RXP)) ? 1UL : 0UL);
 8024b46: 687b         	ldr	r3, [r7, #0x4]
 8024b48: 695b         	ldr	r3, [r3, #0x14]
 8024b4a: f003 0301    	and	r3, r3, #0x1
 8024b4e: 2b01         	cmp	r3, #0x1
 8024b50: d101         	bne	0x8024b56 <LL_SPI_IsActiveFlag_RXP+0x18> @ imm = #0x2
 8024b52: 2301         	movs	r3, #0x1
 8024b54: e000         	b	0x8024b58 <LL_SPI_IsActiveFlag_RXP+0x1a> @ imm = #0x0
 8024b56: 2300         	movs	r3, #0x0
; }
 8024b58: 4618         	mov	r0, r3
 8024b5a: 370c         	adds	r7, #0xc
 8024b5c: 46bd         	mov	sp, r7
 8024b5e: f85d 7b04    	ldr	r7, [sp], #4
 8024b62: 4770         	bx	lr

08024b64 <LL_SPI_IsActiveFlag_TXP>:
; {
 8024b64: b480         	push	{r7}
 8024b66: b083         	sub	sp, #0xc
 8024b68: af00         	add	r7, sp, #0x0
 8024b6a: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_TXP) == (SPI_SR_TXP)) ? 1UL : 0UL);
 8024b6c: 687b         	ldr	r3, [r7, #0x4]
 8024b6e: 695b         	ldr	r3, [r3, #0x14]
 8024b70: f003 0302    	and	r3, r3, #0x2
 8024b74: 2b02         	cmp	r3, #0x2
 8024b76: d101         	bne	0x8024b7c <LL_SPI_IsActiveFlag_TXP+0x18> @ imm = #0x2
 8024b78: 2301         	movs	r3, #0x1
 8024b7a: e000         	b	0x8024b7e <LL_SPI_IsActiveFlag_TXP+0x1a> @ imm = #0x0
 8024b7c: 2300         	movs	r3, #0x0
; }
 8024b7e: 4618         	mov	r0, r3
 8024b80: 370c         	adds	r7, #0xc
 8024b82: 46bd         	mov	sp, r7
 8024b84: f85d 7b04    	ldr	r7, [sp], #4
 8024b88: 4770         	bx	lr

08024b8a <LL_SPI_IsActiveFlag_EOT>:
; {
 8024b8a: b480         	push	{r7}
 8024b8c: b083         	sub	sp, #0xc
 8024b8e: af00         	add	r7, sp, #0x0
 8024b90: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_EOT) == (SPI_SR_EOT)) ? 1UL : 0UL);
 8024b92: 687b         	ldr	r3, [r7, #0x4]
 8024b94: 695b         	ldr	r3, [r3, #0x14]
 8024b96: f003 0308    	and	r3, r3, #0x8
 8024b9a: 2b08         	cmp	r3, #0x8
 8024b9c: d101         	bne	0x8024ba2 <LL_SPI_IsActiveFlag_EOT+0x18> @ imm = #0x2
 8024b9e: 2301         	movs	r3, #0x1
 8024ba0: e000         	b	0x8024ba4 <LL_SPI_IsActiveFlag_EOT+0x1a> @ imm = #0x0
 8024ba2: 2300         	movs	r3, #0x0
; }
 8024ba4: 4618         	mov	r0, r3
 8024ba6: 370c         	adds	r7, #0xc
 8024ba8: 46bd         	mov	sp, r7
 8024baa: f85d 7b04    	ldr	r7, [sp], #4
 8024bae: 4770         	bx	lr

08024bb0 <LL_SPI_IsActiveFlag_MODF>:
; {
 8024bb0: b480         	push	{r7}
 8024bb2: b083         	sub	sp, #0xc
 8024bb4: af00         	add	r7, sp, #0x0
 8024bb6: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_MODF) == (SPI_SR_MODF)) ? 1UL : 0UL);
 8024bb8: 687b         	ldr	r3, [r7, #0x4]
 8024bba: 695b         	ldr	r3, [r3, #0x14]
 8024bbc: f403 7300    	and	r3, r3, #0x200
 8024bc0: f5b3 7f00    	cmp.w	r3, #0x200
 8024bc4: d101         	bne	0x8024bca <LL_SPI_IsActiveFlag_MODF+0x1a> @ imm = #0x2
 8024bc6: 2301         	movs	r3, #0x1
 8024bc8: e000         	b	0x8024bcc <LL_SPI_IsActiveFlag_MODF+0x1c> @ imm = #0x0
 8024bca: 2300         	movs	r3, #0x0
; }
 8024bcc: 4618         	mov	r0, r3
 8024bce: 370c         	adds	r7, #0xc
 8024bd0: 46bd         	mov	sp, r7
 8024bd2: f85d 7b04    	ldr	r7, [sp], #4
 8024bd6: 4770         	bx	lr

08024bd8 <LL_SPI_IsActiveFlag_OVR>:
; {
 8024bd8: b480         	push	{r7}
 8024bda: b083         	sub	sp, #0xc
 8024bdc: af00         	add	r7, sp, #0x0
 8024bde: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_OVR) == (SPI_SR_OVR)) ? 1UL : 0UL);
 8024be0: 687b         	ldr	r3, [r7, #0x4]
 8024be2: 695b         	ldr	r3, [r3, #0x14]
 8024be4: f003 0340    	and	r3, r3, #0x40
 8024be8: 2b40         	cmp	r3, #0x40
 8024bea: d101         	bne	0x8024bf0 <LL_SPI_IsActiveFlag_OVR+0x18> @ imm = #0x2
 8024bec: 2301         	movs	r3, #0x1
 8024bee: e000         	b	0x8024bf2 <LL_SPI_IsActiveFlag_OVR+0x1a> @ imm = #0x0
 8024bf0: 2300         	movs	r3, #0x0
; }
 8024bf2: 4618         	mov	r0, r3
 8024bf4: 370c         	adds	r7, #0xc
 8024bf6: 46bd         	mov	sp, r7
 8024bf8: f85d 7b04    	ldr	r7, [sp], #4
 8024bfc: 4770         	bx	lr

08024bfe <LL_SPI_IsActiveFlag_TXC>:
; {
 8024bfe: b480         	push	{r7}
 8024c00: b083         	sub	sp, #0xc
 8024c02: af00         	add	r7, sp, #0x0
 8024c04: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_TXC) == (SPI_SR_TXC)) ? 1UL : 0UL);
 8024c06: 687b         	ldr	r3, [r7, #0x4]
 8024c08: 695b         	ldr	r3, [r3, #0x14]
 8024c0a: f403 5380    	and	r3, r3, #0x1000
 8024c0e: f5b3 5f80    	cmp.w	r3, #0x1000
 8024c12: d101         	bne	0x8024c18 <LL_SPI_IsActiveFlag_TXC+0x1a> @ imm = #0x2
 8024c14: 2301         	movs	r3, #0x1
 8024c16: e000         	b	0x8024c1a <LL_SPI_IsActiveFlag_TXC+0x1c> @ imm = #0x0
 8024c18: 2300         	movs	r3, #0x0
; }
 8024c1a: 4618         	mov	r0, r3
 8024c1c: 370c         	adds	r7, #0xc
 8024c1e: 46bd         	mov	sp, r7
 8024c20: f85d 7b04    	ldr	r7, [sp], #4
 8024c24: 4770         	bx	lr

08024c26 <LL_SPI_ClearFlag_EOT>:
; {
 8024c26: b480         	push	{r7}
 8024c28: b083         	sub	sp, #0xc
 8024c2a: af00         	add	r7, sp, #0x0
 8024c2c: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(SPIx->IFCR, SPI_IFCR_EOTC);
 8024c2e: 687b         	ldr	r3, [r7, #0x4]
 8024c30: 699b         	ldr	r3, [r3, #0x18]
 8024c32: f043 0208    	orr	r2, r3, #0x8
 8024c36: 687b         	ldr	r3, [r7, #0x4]
 8024c38: 619a         	str	r2, [r3, #0x18]
; }
 8024c3a: bf00         	nop
 8024c3c: 370c         	adds	r7, #0xc
 8024c3e: 46bd         	mov	sp, r7
 8024c40: f85d 7b04    	ldr	r7, [sp], #4
 8024c44: 4770         	bx	lr

08024c46 <LL_SPI_ClearFlag_TXTF>:
; {
 8024c46: b480         	push	{r7}
 8024c48: b083         	sub	sp, #0xc
 8024c4a: af00         	add	r7, sp, #0x0
 8024c4c: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(SPIx->IFCR, SPI_IFCR_TXTFC);
 8024c4e: 687b         	ldr	r3, [r7, #0x4]
 8024c50: 699b         	ldr	r3, [r3, #0x18]
 8024c52: f043 0210    	orr	r2, r3, #0x10
 8024c56: 687b         	ldr	r3, [r7, #0x4]
 8024c58: 619a         	str	r2, [r3, #0x18]
; }
 8024c5a: bf00         	nop
 8024c5c: 370c         	adds	r7, #0xc
 8024c5e: 46bd         	mov	sp, r7
 8024c60: f85d 7b04    	ldr	r7, [sp], #4
 8024c64: 4770         	bx	lr

08024c66 <LL_SPI_ClearFlag_OVR>:
; {
 8024c66: b480         	push	{r7}
 8024c68: b083         	sub	sp, #0xc
 8024c6a: af00         	add	r7, sp, #0x0
 8024c6c: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(SPIx->IFCR, SPI_IFCR_OVRC);
 8024c6e: 687b         	ldr	r3, [r7, #0x4]
 8024c70: 699b         	ldr	r3, [r3, #0x18]
 8024c72: f043 0240    	orr	r2, r3, #0x40
 8024c76: 687b         	ldr	r3, [r7, #0x4]
 8024c78: 619a         	str	r2, [r3, #0x18]
; }
 8024c7a: bf00         	nop
 8024c7c: 370c         	adds	r7, #0xc
 8024c7e: 46bd         	mov	sp, r7
 8024c80: f85d 7b04    	ldr	r7, [sp], #4
 8024c84: 4770         	bx	lr

08024c86 <LL_SPI_ClearFlag_MODF>:
; {
 8024c86: b480         	push	{r7}
 8024c88: b083         	sub	sp, #0xc
 8024c8a: af00         	add	r7, sp, #0x0
 8024c8c: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(SPIx->IFCR, SPI_IFCR_MODFC);
 8024c8e: 687b         	ldr	r3, [r7, #0x4]
 8024c90: 699b         	ldr	r3, [r3, #0x18]
 8024c92: f443 7200    	orr	r2, r3, #0x200
 8024c96: 687b         	ldr	r3, [r7, #0x4]
 8024c98: 619a         	str	r2, [r3, #0x18]
; }
 8024c9a: bf00         	nop
 8024c9c: 370c         	adds	r7, #0xc
 8024c9e: 46bd         	mov	sp, r7
 8024ca0: f85d 7b04    	ldr	r7, [sp], #4
 8024ca4: 4770         	bx	lr

08024ca6 <LL_SPI_DisableIT_TXP>:
; {
 8024ca6: b480         	push	{r7}
 8024ca8: b083         	sub	sp, #0xc
 8024caa: af00         	add	r7, sp, #0x0
 8024cac: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->IER, SPI_IER_TXPIE);
 8024cae: 687b         	ldr	r3, [r7, #0x4]
 8024cb0: 691b         	ldr	r3, [r3, #0x10]
 8024cb2: f023 0202    	bic	r2, r3, #0x2
 8024cb6: 687b         	ldr	r3, [r7, #0x4]
 8024cb8: 611a         	str	r2, [r3, #0x10]
; }
 8024cba: bf00         	nop
 8024cbc: 370c         	adds	r7, #0xc
 8024cbe: 46bd         	mov	sp, r7
 8024cc0: f85d 7b04    	ldr	r7, [sp], #4
 8024cc4: 4770         	bx	lr

08024cc6 <LL_SPI_ReceiveData8>:
; {
 8024cc6: b480         	push	{r7}
 8024cc8: b083         	sub	sp, #0xc
 8024cca: af00         	add	r7, sp, #0x0
 8024ccc: 6078         	str	r0, [r7, #0x4]
;   return (*((__IO uint8_t *)&SPIx->RXDR));
 8024cce: 687b         	ldr	r3, [r7, #0x4]
 8024cd0: 3330         	adds	r3, #0x30
 8024cd2: 781b         	ldrb	r3, [r3]
 8024cd4: b2db         	uxtb	r3, r3
; }
 8024cd6: 4618         	mov	r0, r3
 8024cd8: 370c         	adds	r7, #0xc
 8024cda: 46bd         	mov	sp, r7
 8024cdc: f85d 7b04    	ldr	r7, [sp], #4
 8024ce0: 4770         	bx	lr

08024ce2 <LL_SPI_ReceiveData16>:
; {
 8024ce2: b480         	push	{r7}
 8024ce4: b085         	sub	sp, #0x14
 8024ce6: af00         	add	r7, sp, #0x0
 8024ce8: 6078         	str	r0, [r7, #0x4]
;   __IO uint16_t *spirxdr = (__IO uint16_t *)(&(SPIx->RXDR));
 8024cea: 687b         	ldr	r3, [r7, #0x4]
 8024cec: 3330         	adds	r3, #0x30
 8024cee: 60fb         	str	r3, [r7, #0xc]
;   return (*spirxdr);
 8024cf0: 68fb         	ldr	r3, [r7, #0xc]
 8024cf2: 881b         	ldrh	r3, [r3]
 8024cf4: b29b         	uxth	r3, r3
; }
 8024cf6: 4618         	mov	r0, r3
 8024cf8: 3714         	adds	r7, #0x14
 8024cfa: 46bd         	mov	sp, r7
 8024cfc: f85d 7b04    	ldr	r7, [sp], #4
 8024d00: 4770         	bx	lr

08024d02 <LL_SPI_TransmitData8>:
; {
 8024d02: b480         	push	{r7}
 8024d04: b083         	sub	sp, #0xc
 8024d06: af00         	add	r7, sp, #0x0
 8024d08: 6078         	str	r0, [r7, #0x4]
 8024d0a: 460b         	mov	r3, r1
 8024d0c: 70fb         	strb	r3, [r7, #0x3]
;   *((__IO uint8_t *)&SPIx->TXDR) = TxData;
 8024d0e: 687b         	ldr	r3, [r7, #0x4]
 8024d10: 3320         	adds	r3, #0x20
 8024d12: 78fa         	ldrb	r2, [r7, #0x3]
 8024d14: 701a         	strb	r2, [r3]
; }
 8024d16: bf00         	nop
 8024d18: 370c         	adds	r7, #0xc
 8024d1a: 46bd         	mov	sp, r7
 8024d1c: f85d 7b04    	ldr	r7, [sp], #4
 8024d20: 4770         	bx	lr

08024d22 <LL_SPI_TransmitData16>:
; {
 8024d22: b480         	push	{r7}
 8024d24: b085         	sub	sp, #0x14
 8024d26: af00         	add	r7, sp, #0x0
 8024d28: 6078         	str	r0, [r7, #0x4]
 8024d2a: 460b         	mov	r3, r1
 8024d2c: 807b         	strh	r3, [r7, #0x2]
;   __IO uint16_t *spitxdr = ((__IO uint16_t *)&SPIx->TXDR);
 8024d2e: 687b         	ldr	r3, [r7, #0x4]
 8024d30: 3320         	adds	r3, #0x20
 8024d32: 60fb         	str	r3, [r7, #0xc]
;   *spitxdr = TxData;
 8024d34: 68fb         	ldr	r3, [r7, #0xc]
 8024d36: 887a         	ldrh	r2, [r7, #0x2]
 8024d38: 801a         	strh	r2, [r3]
; }
 8024d3a: bf00         	nop
 8024d3c: 3714         	adds	r7, #0x14
 8024d3e: 46bd         	mov	sp, r7
 8024d40: f85d 7b04    	ldr	r7, [sp], #4
 8024d44: 4770         	bx	lr

08024d46 <z_impl_gpio_pin_configure>:
; {
 8024d46: b580         	push	{r7, lr}
 8024d48: b088         	sub	sp, #0x20
 8024d4a: af00         	add	r7, sp, #0x0
 8024d4c: 60f8         	str	r0, [r7, #0xc]
 8024d4e: 460b         	mov	r3, r1
 8024d50: 607a         	str	r2, [r7, #0x4]
 8024d52: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 8024d54: 68fb         	ldr	r3, [r7, #0xc]
 8024d56: 689b         	ldr	r3, [r3, #0x8]
 8024d58: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 8024d5a: 68fb         	ldr	r3, [r7, #0xc]
 8024d5c: 685b         	ldr	r3, [r3, #0x4]
 8024d5e: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 8024d60: 68fb         	ldr	r3, [r7, #0xc]
 8024d62: 691b         	ldr	r3, [r3, #0x10]
 8024d64: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 8024d66: 687b         	ldr	r3, [r7, #0x4]
 8024d68: f403 1380    	and	r3, r3, #0x100000
 8024d6c: 2b00         	cmp	r3, #0x0
 8024d6e: d00d         	beq	0x8024d8c <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 8024d70: 687b         	ldr	r3, [r7, #0x4]
 8024d72: f403 2340    	and	r3, r3, #0xc0000
 8024d76: 2b00         	cmp	r3, #0x0
 8024d78: d008         	beq	0x8024d8c <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 8024d7a: 687b         	ldr	r3, [r7, #0x4]
 8024d7c: f003 0301    	and	r3, r3, #0x1
 8024d80: 2b00         	cmp	r3, #0x0
 8024d82: d003         	beq	0x8024d8c <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 8024d84: 687b         	ldr	r3, [r7, #0x4]
 8024d86: f483 2340    	eor	r3, r3, #0xc0000
 8024d8a: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 8024d8c: 687b         	ldr	r3, [r7, #0x4]
 8024d8e: f423 1380    	bic	r3, r3, #0x100000
 8024d92: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 8024d94: 687b         	ldr	r3, [r7, #0x4]
 8024d96: f003 0301    	and	r3, r3, #0x1
 8024d9a: 2b00         	cmp	r3, #0x0
 8024d9c: d009         	beq	0x8024db2 <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 8024d9e: 697b         	ldr	r3, [r7, #0x14]
 8024da0: 681a         	ldr	r2, [r3]
 8024da2: 7afb         	ldrb	r3, [r7, #0xb]
 8024da4: 2101         	movs	r1, #0x1
 8024da6: fa01 f303    	lsl.w	r3, r1, r3
 8024daa: 431a         	orrs	r2, r3
 8024dac: 697b         	ldr	r3, [r7, #0x14]
 8024dae: 601a         	str	r2, [r3]
 8024db0: e009         	b	0x8024dc6 <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 8024db2: 697b         	ldr	r3, [r7, #0x14]
 8024db4: 681a         	ldr	r2, [r3]
 8024db6: 7afb         	ldrb	r3, [r7, #0xb]
 8024db8: 2101         	movs	r1, #0x1
 8024dba: fa01 f303    	lsl.w	r3, r1, r3
 8024dbe: 43db         	mvns	r3, r3
 8024dc0: 401a         	ands	r2, r3
 8024dc2: 697b         	ldr	r3, [r7, #0x14]
 8024dc4: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 8024dc6: 69fb         	ldr	r3, [r7, #0x1c]
 8024dc8: 681b         	ldr	r3, [r3]
 8024dca: 7af9         	ldrb	r1, [r7, #0xb]
 8024dcc: 687a         	ldr	r2, [r7, #0x4]
 8024dce: 68f8         	ldr	r0, [r7, #0xc]
 8024dd0: 4798         	blx	r3
 8024dd2: 4603         	mov	r3, r0
; }
 8024dd4: 4618         	mov	r0, r3
 8024dd6: 3720         	adds	r7, #0x20
 8024dd8: 46bd         	mov	sp, r7
 8024dda: bd80         	pop	{r7, pc}

08024ddc <gpio_pin_configure_dt>:
; {
 8024ddc: b580         	push	{r7, lr}
 8024dde: b082         	sub	sp, #0x8
 8024de0: af00         	add	r7, sp, #0x0
 8024de2: 6078         	str	r0, [r7, #0x4]
 8024de4: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 8024de6: 687b         	ldr	r3, [r7, #0x4]
 8024de8: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 8024dea: 687b         	ldr	r3, [r7, #0x4]
 8024dec: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 8024dee: 687b         	ldr	r3, [r7, #0x4]
 8024df0: 88db         	ldrh	r3, [r3, #0x6]
 8024df2: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 8024df4: 683b         	ldr	r3, [r7]
 8024df6: 4313         	orrs	r3, r2
 8024df8: 461a         	mov	r2, r3
 8024dfa: f000 f888    	bl	0x8024f0e <gpio_pin_configure> @ imm = #0x110
 8024dfe: 4603         	mov	r3, r0
; }
 8024e00: 4618         	mov	r0, r3
 8024e02: 3708         	adds	r7, #0x8
 8024e04: 46bd         	mov	sp, r7
 8024e06: bd80         	pop	{r7, pc}

08024e08 <z_impl_gpio_port_set_bits_raw>:
; {
 8024e08: b580         	push	{r7, lr}
 8024e0a: b084         	sub	sp, #0x10
 8024e0c: af00         	add	r7, sp, #0x0
 8024e0e: 6078         	str	r0, [r7, #0x4]
 8024e10: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 8024e12: 687b         	ldr	r3, [r7, #0x4]
 8024e14: 689b         	ldr	r3, [r3, #0x8]
 8024e16: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_set_bits_raw(port, pins);
 8024e18: 68fb         	ldr	r3, [r7, #0xc]
 8024e1a: 68db         	ldr	r3, [r3, #0xc]
 8024e1c: 6839         	ldr	r1, [r7]
 8024e1e: 6878         	ldr	r0, [r7, #0x4]
 8024e20: 4798         	blx	r3
 8024e22: 4603         	mov	r3, r0
; }
 8024e24: 4618         	mov	r0, r3
 8024e26: 3710         	adds	r7, #0x10
 8024e28: 46bd         	mov	sp, r7
 8024e2a: bd80         	pop	{r7, pc}

08024e2c <z_impl_gpio_port_clear_bits_raw>:
; {
 8024e2c: b580         	push	{r7, lr}
 8024e2e: b084         	sub	sp, #0x10
 8024e30: af00         	add	r7, sp, #0x0
 8024e32: 6078         	str	r0, [r7, #0x4]
 8024e34: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 8024e36: 687b         	ldr	r3, [r7, #0x4]
 8024e38: 689b         	ldr	r3, [r3, #0x8]
 8024e3a: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_clear_bits_raw(port, pins);
 8024e3c: 68fb         	ldr	r3, [r7, #0xc]
 8024e3e: 691b         	ldr	r3, [r3, #0x10]
 8024e40: 6839         	ldr	r1, [r7]
 8024e42: 6878         	ldr	r0, [r7, #0x4]
 8024e44: 4798         	blx	r3
 8024e46: 4603         	mov	r3, r0
; }
 8024e48: 4618         	mov	r0, r3
 8024e4a: 3710         	adds	r7, #0x10
 8024e4c: 46bd         	mov	sp, r7
 8024e4e: bd80         	pop	{r7, pc}

08024e50 <gpio_pin_set_raw>:
; {
 8024e50: b580         	push	{r7, lr}
 8024e52: b086         	sub	sp, #0x18
 8024e54: af00         	add	r7, sp, #0x0
 8024e56: 60f8         	str	r0, [r7, #0xc]
 8024e58: 460b         	mov	r3, r1
 8024e5a: 607a         	str	r2, [r7, #0x4]
 8024e5c: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 8024e5e: 68fb         	ldr	r3, [r7, #0xc]
 8024e60: 685b         	ldr	r3, [r3, #0x4]
 8024e62: 613b         	str	r3, [r7, #0x10]
; 	if (value != 0)	{
 8024e64: 687b         	ldr	r3, [r7, #0x4]
 8024e66: 2b00         	cmp	r3, #0x0
 8024e68: d009         	beq	0x8024e7e <gpio_pin_set_raw+0x2e> @ imm = #0x12
; 		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 8024e6a: 7afb         	ldrb	r3, [r7, #0xb]
 8024e6c: 2201         	movs	r2, #0x1
 8024e6e: fa02 f303    	lsl.w	r3, r2, r3
 8024e72: 4619         	mov	r1, r3
 8024e74: 68f8         	ldr	r0, [r7, #0xc]
 8024e76: f000 f85c    	bl	0x8024f32 <gpio_port_set_bits_raw> @ imm = #0xb8
 8024e7a: 6178         	str	r0, [r7, #0x14]
 8024e7c: e008         	b	0x8024e90 <gpio_pin_set_raw+0x40> @ imm = #0x10
; 		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 8024e7e: 7afb         	ldrb	r3, [r7, #0xb]
 8024e80: 2201         	movs	r2, #0x1
 8024e82: fa02 f303    	lsl.w	r3, r2, r3
 8024e86: 4619         	mov	r1, r3
 8024e88: 68f8         	ldr	r0, [r7, #0xc]
 8024e8a: f000 f860    	bl	0x8024f4e <gpio_port_clear_bits_raw> @ imm = #0xc0
 8024e8e: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 8024e90: 697b         	ldr	r3, [r7, #0x14]
; }
 8024e92: 4618         	mov	r0, r3
 8024e94: 3718         	adds	r7, #0x18
 8024e96: 46bd         	mov	sp, r7
 8024e98: bd80         	pop	{r7, pc}

08024e9a <gpio_pin_set>:
; {
 8024e9a: b580         	push	{r7, lr}
 8024e9c: b086         	sub	sp, #0x18
 8024e9e: af00         	add	r7, sp, #0x0
 8024ea0: 60f8         	str	r0, [r7, #0xc]
 8024ea2: 460b         	mov	r3, r1
 8024ea4: 607a         	str	r2, [r7, #0x4]
 8024ea6: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 8024ea8: 68fb         	ldr	r3, [r7, #0xc]
 8024eaa: 685b         	ldr	r3, [r3, #0x4]
 8024eac: 617b         	str	r3, [r7, #0x14]
; 	const struct gpio_driver_data *const data =
 8024eae: 68fb         	ldr	r3, [r7, #0xc]
 8024eb0: 691b         	ldr	r3, [r3, #0x10]
 8024eb2: 613b         	str	r3, [r7, #0x10]
; 	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
 8024eb4: 693b         	ldr	r3, [r7, #0x10]
 8024eb6: 681a         	ldr	r2, [r3]
 8024eb8: 7afb         	ldrb	r3, [r7, #0xb]
 8024eba: 2101         	movs	r1, #0x1
 8024ebc: fa01 f303    	lsl.w	r3, r1, r3
 8024ec0: 4013         	ands	r3, r2
 8024ec2: 2b00         	cmp	r3, #0x0
 8024ec4: d006         	beq	0x8024ed4 <gpio_pin_set+0x3a> @ imm = #0xc
; 		value = (value != 0) ? 0 : 1;
 8024ec6: 687b         	ldr	r3, [r7, #0x4]
 8024ec8: 2b00         	cmp	r3, #0x0
 8024eca: bf0c         	ite	eq
 8024ecc: 2301         	moveq	r3, #0x1
 8024ece: 2300         	movne	r3, #0x0
 8024ed0: b2db         	uxtb	r3, r3
 8024ed2: 607b         	str	r3, [r7, #0x4]
; 	return gpio_pin_set_raw(port, pin, value);
 8024ed4: 7afb         	ldrb	r3, [r7, #0xb]
 8024ed6: 687a         	ldr	r2, [r7, #0x4]
 8024ed8: 4619         	mov	r1, r3
 8024eda: 68f8         	ldr	r0, [r7, #0xc]
 8024edc: f7ff ffb8    	bl	0x8024e50 <gpio_pin_set_raw> @ imm = #-0x90
 8024ee0: 4603         	mov	r3, r0
; }
 8024ee2: 4618         	mov	r0, r3
 8024ee4: 3718         	adds	r7, #0x18
 8024ee6: 46bd         	mov	sp, r7
 8024ee8: bd80         	pop	{r7, pc}

08024eea <gpio_pin_set_dt>:
; {
 8024eea: b580         	push	{r7, lr}
 8024eec: b082         	sub	sp, #0x8
 8024eee: af00         	add	r7, sp, #0x0
 8024ef0: 6078         	str	r0, [r7, #0x4]
 8024ef2: 6039         	str	r1, [r7]
; 	return gpio_pin_set(spec->port, spec->pin, value);
 8024ef4: 687b         	ldr	r3, [r7, #0x4]
 8024ef6: 6818         	ldr	r0, [r3]
 8024ef8: 687b         	ldr	r3, [r7, #0x4]
 8024efa: 791b         	ldrb	r3, [r3, #0x4]
 8024efc: 683a         	ldr	r2, [r7]
 8024efe: 4619         	mov	r1, r3
 8024f00: f7ff ffcb    	bl	0x8024e9a <gpio_pin_set> @ imm = #-0x6a
 8024f04: 4603         	mov	r3, r0
; }
 8024f06: 4618         	mov	r0, r3
 8024f08: 3708         	adds	r7, #0x8
 8024f0a: 46bd         	mov	sp, r7
 8024f0c: bd80         	pop	{r7, pc}

08024f0e <gpio_pin_configure>:
; {
 8024f0e: b580         	push	{r7, lr}
 8024f10: b084         	sub	sp, #0x10
 8024f12: af00         	add	r7, sp, #0x0
 8024f14: 60f8         	str	r0, [r7, #0xc]
 8024f16: 460b         	mov	r3, r1
 8024f18: 607a         	str	r2, [r7, #0x4]
 8024f1a: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 8024f1c: 7afb         	ldrb	r3, [r7, #0xb]
 8024f1e: 687a         	ldr	r2, [r7, #0x4]
 8024f20: 4619         	mov	r1, r3
 8024f22: 68f8         	ldr	r0, [r7, #0xc]
 8024f24: f7ff ff0f    	bl	0x8024d46 <z_impl_gpio_pin_configure> @ imm = #-0x1e2
 8024f28: 4603         	mov	r3, r0
; }
 8024f2a: 4618         	mov	r0, r3
 8024f2c: 3710         	adds	r7, #0x10
 8024f2e: 46bd         	mov	sp, r7
 8024f30: bd80         	pop	{r7, pc}

08024f32 <gpio_port_set_bits_raw>:
; {
 8024f32: b580         	push	{r7, lr}
 8024f34: b082         	sub	sp, #0x8
 8024f36: af00         	add	r7, sp, #0x0
 8024f38: 6078         	str	r0, [r7, #0x4]
 8024f3a: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_set_bits_raw(port, pins);
 8024f3c: 6839         	ldr	r1, [r7]
 8024f3e: 6878         	ldr	r0, [r7, #0x4]
 8024f40: f7ff ff62    	bl	0x8024e08 <z_impl_gpio_port_set_bits_raw> @ imm = #-0x13c
 8024f44: 4603         	mov	r3, r0
; }
 8024f46: 4618         	mov	r0, r3
 8024f48: 3708         	adds	r7, #0x8
 8024f4a: 46bd         	mov	sp, r7
 8024f4c: bd80         	pop	{r7, pc}

08024f4e <gpio_port_clear_bits_raw>:
; {
 8024f4e: b580         	push	{r7, lr}
 8024f50: b082         	sub	sp, #0x8
 8024f52: af00         	add	r7, sp, #0x0
 8024f54: 6078         	str	r0, [r7, #0x4]
 8024f56: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_clear_bits_raw(port, pins);
 8024f58: 6839         	ldr	r1, [r7]
 8024f5a: 6878         	ldr	r0, [r7, #0x4]
 8024f5c: f7ff ff66    	bl	0x8024e2c <z_impl_gpio_port_clear_bits_raw> @ imm = #-0x134
 8024f60: 4603         	mov	r3, r0
; }
 8024f62: 4618         	mov	r0, r3
 8024f64: 3708         	adds	r7, #0x8
 8024f66: 46bd         	mov	sp, r7
 8024f68: bd80         	pop	{r7, pc}

08024f6a <spi_cs_is_gpio>:
; {
 8024f6a: b480         	push	{r7}
 8024f6c: b083         	sub	sp, #0xc
 8024f6e: af00         	add	r7, sp, #0x0
 8024f70: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 8024f72: 687b         	ldr	r3, [r7, #0x4]
 8024f74: 689b         	ldr	r3, [r3, #0x8]
 8024f76: 2b00         	cmp	r3, #0x0
 8024f78: bf14         	ite	ne
 8024f7a: 2301         	movne	r3, #0x1
 8024f7c: 2300         	moveq	r3, #0x0
 8024f7e: b2db         	uxtb	r3, r3
; }
 8024f80: 4618         	mov	r0, r3
 8024f82: 370c         	adds	r7, #0xc
 8024f84: 46bd         	mov	sp, r7
 8024f86: f85d 7b04    	ldr	r7, [sp], #4
 8024f8a: 4770         	bx	lr

08024f8c <pinctrl_apply_state_direct>:
; {
 8024f8c: b580         	push	{r7, lr}
 8024f8e: b084         	sub	sp, #0x10
 8024f90: af00         	add	r7, sp, #0x0
 8024f92: 6078         	str	r0, [r7, #0x4]
 8024f94: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 8024f96: 2300         	movs	r3, #0x0
 8024f98: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 8024f9a: 683b         	ldr	r3, [r7]
 8024f9c: 6818         	ldr	r0, [r3]
 8024f9e: 683b         	ldr	r3, [r7]
 8024fa0: 791b         	ldrb	r3, [r3, #0x4]
 8024fa2: 68fa         	ldr	r2, [r7, #0xc]
 8024fa4: 4619         	mov	r1, r3
 8024fa6: f7fc fc77    	bl	0x8021898 <pinctrl_configure_pins> @ imm = #-0x3712
 8024faa: 4603         	mov	r3, r0
; }
 8024fac: 4618         	mov	r0, r3
 8024fae: 3710         	adds	r7, #0x10
 8024fb0: 46bd         	mov	sp, r7
 8024fb2: bd80         	pop	{r7, pc}

08024fb4 <pinctrl_apply_state>:
; {
 8024fb4: b580         	push	{r7, lr}
 8024fb6: b084         	sub	sp, #0x10
 8024fb8: af00         	add	r7, sp, #0x0
 8024fba: 6078         	str	r0, [r7, #0x4]
 8024fbc: 460b         	mov	r3, r1
 8024fbe: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 8024fc0: f107 0208    	add.w	r2, r7, #0x8
 8024fc4: 78fb         	ldrb	r3, [r7, #0x3]
 8024fc6: 4619         	mov	r1, r3
 8024fc8: 6878         	ldr	r0, [r7, #0x4]
 8024fca: f7fc fc2d    	bl	0x8021828 <pinctrl_lookup_state> @ imm = #-0x37a6
 8024fce: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8024fd0: 68fb         	ldr	r3, [r7, #0xc]
 8024fd2: 2b00         	cmp	r3, #0x0
 8024fd4: da01         	bge	0x8024fda <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 8024fd6: 68fb         	ldr	r3, [r7, #0xc]
 8024fd8: e005         	b	0x8024fe6 <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 8024fda: 68bb         	ldr	r3, [r7, #0x8]
 8024fdc: 4619         	mov	r1, r3
 8024fde: 6878         	ldr	r0, [r7, #0x4]
 8024fe0: f7ff ffd4    	bl	0x8024f8c <pinctrl_apply_state_direct> @ imm = #-0x58
 8024fe4: 4603         	mov	r3, r0
; }
 8024fe6: 4618         	mov	r0, r3
 8024fe8: 3710         	adds	r7, #0x10
 8024fea: 46bd         	mov	sp, r7
 8024fec: bd80         	pop	{r7, pc}

08024fee <pm_device_runtime_enable>:
; {
 8024fee: b480         	push	{r7}
 8024ff0: b083         	sub	sp, #0xc
 8024ff2: af00         	add	r7, sp, #0x0
 8024ff4: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8024ff6: 2300         	movs	r3, #0x0
; }
 8024ff8: 4618         	mov	r0, r3
 8024ffa: 370c         	adds	r7, #0xc
 8024ffc: 46bd         	mov	sp, r7
 8024ffe: f85d 7b04    	ldr	r7, [sp], #4
 8025002: 4770         	bx	lr

08025004 <clock_control_on>:
; {
 8025004: b580         	push	{r7, lr}
 8025006: b084         	sub	sp, #0x10
 8025008: af00         	add	r7, sp, #0x0
 802500a: 6078         	str	r0, [r7, #0x4]
 802500c: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 802500e: 687b         	ldr	r3, [r7, #0x4]
 8025010: 689b         	ldr	r3, [r3, #0x8]
 8025012: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8025014: 68fb         	ldr	r3, [r7, #0xc]
 8025016: 681b         	ldr	r3, [r3]
 8025018: 6839         	ldr	r1, [r7]
 802501a: 6878         	ldr	r0, [r7, #0x4]
 802501c: 4798         	blx	r3
 802501e: 4603         	mov	r3, r0
; }
 8025020: 4618         	mov	r0, r3
 8025022: 3710         	adds	r7, #0x10
 8025024: 46bd         	mov	sp, r7
 8025026: bd80         	pop	{r7, pc}

08025028 <clock_control_get_rate>:
; {
 8025028: b580         	push	{r7, lr}
 802502a: b086         	sub	sp, #0x18
 802502c: af00         	add	r7, sp, #0x0
 802502e: 60f8         	str	r0, [r7, #0xc]
 8025030: 60b9         	str	r1, [r7, #0x8]
 8025032: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 8025034: 68fb         	ldr	r3, [r7, #0xc]
 8025036: 689b         	ldr	r3, [r3, #0x8]
 8025038: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 802503a: 697b         	ldr	r3, [r7, #0x14]
 802503c: 68db         	ldr	r3, [r3, #0xc]
 802503e: 2b00         	cmp	r3, #0x0
 8025040: d102         	bne	0x8025048 <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8025042: f06f 0357    	mvn	r3, #0x57
 8025046: e006         	b	0x8025056 <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 8025048: 697b         	ldr	r3, [r7, #0x14]
 802504a: 68db         	ldr	r3, [r3, #0xc]
 802504c: 687a         	ldr	r2, [r7, #0x4]
 802504e: 68b9         	ldr	r1, [r7, #0x8]
 8025050: 68f8         	ldr	r0, [r7, #0xc]
 8025052: 4798         	blx	r3
 8025054: 4603         	mov	r3, r0
; }
 8025056: 4618         	mov	r0, r3
 8025058: 3718         	adds	r7, #0x18
 802505a: 46bd         	mov	sp, r7
 802505c: bd80         	pop	{r7, pc}

0802505e <clock_control_configure>:
; {
 802505e: b580         	push	{r7, lr}
 8025060: b086         	sub	sp, #0x18
 8025062: af00         	add	r7, sp, #0x0
 8025064: 60f8         	str	r0, [r7, #0xc]
 8025066: 60b9         	str	r1, [r7, #0x8]
 8025068: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 802506a: 68fb         	ldr	r3, [r7, #0xc]
 802506c: 689b         	ldr	r3, [r3, #0x8]
 802506e: 617b         	str	r3, [r7, #0x14]
; 	if (api->configure == NULL) {
 8025070: 697b         	ldr	r3, [r7, #0x14]
 8025072: 699b         	ldr	r3, [r3, #0x18]
 8025074: 2b00         	cmp	r3, #0x0
 8025076: d102         	bne	0x802507e <clock_control_configure+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8025078: f06f 0357    	mvn	r3, #0x57
 802507c: e006         	b	0x802508c <clock_control_configure+0x2e> @ imm = #0xc
; 	return api->configure(dev, sys, data);
 802507e: 697b         	ldr	r3, [r7, #0x14]
 8025080: 699b         	ldr	r3, [r3, #0x18]
 8025082: 687a         	ldr	r2, [r7, #0x4]
 8025084: 68b9         	ldr	r1, [r7, #0x8]
 8025086: 68f8         	ldr	r0, [r7, #0xc]
 8025088: 4798         	blx	r3
 802508a: 4603         	mov	r3, r0
; }
 802508c: 4618         	mov	r0, r3
 802508e: 3718         	adds	r7, #0x18
 8025090: 46bd         	mov	sp, r7
 8025092: bd80         	pop	{r7, pc}

08025094 <spi_context_configured>:
; {
 8025094: b480         	push	{r7}
 8025096: b083         	sub	sp, #0xc
 8025098: af00         	add	r7, sp, #0x0
 802509a: 6078         	str	r0, [r7, #0x4]
 802509c: 6039         	str	r1, [r7]
; 	return !!(ctx->config == config);
 802509e: 687b         	ldr	r3, [r7, #0x4]
 80250a0: 681b         	ldr	r3, [r3]
 80250a2: 683a         	ldr	r2, [r7]
 80250a4: 429a         	cmp	r2, r3
 80250a6: bf0c         	ite	eq
 80250a8: 2301         	moveq	r3, #0x1
 80250aa: 2300         	movne	r3, #0x0
 80250ac: b2db         	uxtb	r3, r3
; }
 80250ae: 4618         	mov	r0, r3
 80250b0: 370c         	adds	r7, #0xc
 80250b2: 46bd         	mov	sp, r7
 80250b4: f85d 7b04    	ldr	r7, [sp], #4
 80250b8: 4770         	bx	lr

080250ba <spi_context_lock>:
; {
 80250ba: b580         	push	{r7, lr}
 80250bc: b084         	sub	sp, #0x10
 80250be: af00         	add	r7, sp, #0x0
 80250c0: 60f8         	str	r0, [r7, #0xc]
 80250c2: 607a         	str	r2, [r7, #0x4]
 80250c4: 603b         	str	r3, [r7]
 80250c6: 460b         	mov	r3, r1
 80250c8: 72fb         	strb	r3, [r7, #0xb]
; 	if ((spi_cfg->operation & SPI_LOCK_ON) &&
 80250ca: 69bb         	ldr	r3, [r7, #0x18]
 80250cc: 889b         	ldrh	r3, [r3, #0x4]
 80250ce: f403 5300    	and	r3, r3, #0x2000
 80250d2: 2b00         	cmp	r3, #0x0
 80250d4: d00d         	beq	0x80250f2 <spi_context_lock+0x38> @ imm = #0x1a
; 		(k_sem_count_get(&ctx->lock) == 0) &&
 80250d6: 68fb         	ldr	r3, [r7, #0xc]
 80250d8: 3310         	adds	r3, #0x10
 80250da: 4618         	mov	r0, r3
 80250dc: f7ff fb90    	bl	0x8024800 <k_sem_count_get> @ imm = #-0x8e0
 80250e0: 4603         	mov	r3, r0
; 	if ((spi_cfg->operation & SPI_LOCK_ON) &&
 80250e2: 2b00         	cmp	r3, #0x0
 80250e4: d105         	bne	0x80250f2 <spi_context_lock+0x38> @ imm = #0xa
; 		(ctx->owner == spi_cfg)) {
 80250e6: 68fb         	ldr	r3, [r7, #0xc]
 80250e8: 685b         	ldr	r3, [r3, #0x4]
; 		(k_sem_count_get(&ctx->lock) == 0) &&
 80250ea: 69ba         	ldr	r2, [r7, #0x18]
 80250ec: 429a         	cmp	r2, r3
 80250ee: d100         	bne	0x80250f2 <spi_context_lock+0x38> @ imm = #0x0
 80250f0: e00c         	b	0x802510c <spi_context_lock+0x52> @ imm = #0x18
; 	k_sem_take(&ctx->lock, K_FOREVER);
 80250f2: 68fb         	ldr	r3, [r7, #0xc]
 80250f4: f103 0110    	add.w	r1, r3, #0x10
 80250f8: f04f 32ff    	mov.w	r2, #0xffffffff
 80250fc: f04f 33ff    	mov.w	r3, #0xffffffff
 8025100: 4608         	mov	r0, r1
 8025102: f7ff fb62    	bl	0x80247ca <k_sem_take>  @ imm = #-0x93c
; 	ctx->owner = spi_cfg;
 8025106: 68fb         	ldr	r3, [r7, #0xc]
 8025108: 69ba         	ldr	r2, [r7, #0x18]
 802510a: 605a         	str	r2, [r3, #0x4]
; }
 802510c: 3710         	adds	r7, #0x10
 802510e: 46bd         	mov	sp, r7
 8025110: bd80         	pop	{r7, pc}

08025112 <spi_context_release>:
; {
 8025112: b580         	push	{r7, lr}
 8025114: b082         	sub	sp, #0x8
 8025116: af00         	add	r7, sp, #0x0
 8025118: 6078         	str	r0, [r7, #0x4]
 802511a: 6039         	str	r1, [r7]
; 	if (!(ctx->config->operation & SPI_LOCK_ON)) {
 802511c: 687b         	ldr	r3, [r7, #0x4]
 802511e: 681b         	ldr	r3, [r3]
 8025120: 889b         	ldrh	r3, [r3, #0x4]
 8025122: f403 5300    	and	r3, r3, #0x2000
 8025126: 2b00         	cmp	r3, #0x0
 8025128: d107         	bne	0x802513a <spi_context_release+0x28> @ imm = #0xe
; 		ctx->owner = NULL;
 802512a: 687b         	ldr	r3, [r7, #0x4]
 802512c: 2200         	movs	r2, #0x0
 802512e: 605a         	str	r2, [r3, #0x4]
; 		k_sem_give(&ctx->lock);
 8025130: 687b         	ldr	r3, [r7, #0x4]
 8025132: 3310         	adds	r3, #0x10
 8025134: 4618         	mov	r0, r3
 8025136: f7ff fb58    	bl	0x80247ea <k_sem_give>  @ imm = #-0x950
; }
 802513a: bf00         	nop
 802513c: 3708         	adds	r7, #0x8
 802513e: 46bd         	mov	sp, r7
 8025140: bd80         	pop	{r7, pc}

08025142 <_spi_context_cs_control>:
; {
 8025142: b580         	push	{r7, lr}
 8025144: b082         	sub	sp, #0x8
 8025146: af00         	add	r7, sp, #0x0
 8025148: 6078         	str	r0, [r7, #0x4]
 802514a: 460b         	mov	r3, r1
 802514c: 70fb         	strb	r3, [r7, #0x3]
 802514e: 4613         	mov	r3, r2
 8025150: 70bb         	strb	r3, [r7, #0x2]
; 	if (ctx->config && spi_cs_is_gpio(ctx->config)) {
 8025152: 687b         	ldr	r3, [r7, #0x4]
 8025154: 681b         	ldr	r3, [r3]
 8025156: 2b00         	cmp	r3, #0x0
 8025158: d034         	beq	0x80251c4 <_spi_context_cs_control+0x82> @ imm = #0x68
 802515a: 687b         	ldr	r3, [r7, #0x4]
 802515c: 681b         	ldr	r3, [r3]
 802515e: 4618         	mov	r0, r3
 8025160: f7ff ff03    	bl	0x8024f6a <spi_cs_is_gpio> @ imm = #-0x1fa
 8025164: 4603         	mov	r3, r0
 8025166: 2b00         	cmp	r3, #0x0
 8025168: d02c         	beq	0x80251c4 <_spi_context_cs_control+0x82> @ imm = #0x58
; 		if (on) {
 802516a: 78fb         	ldrb	r3, [r7, #0x3]
 802516c: 2b00         	cmp	r3, #0x0
 802516e: d00d         	beq	0x802518c <_spi_context_cs_control+0x4a> @ imm = #0x1a
; 			gpio_pin_set_dt(&ctx->config->cs.gpio, 1);
 8025170: 687b         	ldr	r3, [r7, #0x4]
 8025172: 681b         	ldr	r3, [r3]
 8025174: 3308         	adds	r3, #0x8
 8025176: 2101         	movs	r1, #0x1
 8025178: 4618         	mov	r0, r3
 802517a: f7ff feb6    	bl	0x8024eea <gpio_pin_set_dt> @ imm = #-0x294
; 			k_busy_wait(ctx->config->cs.delay);
 802517e: 687b         	ldr	r3, [r7, #0x4]
 8025180: 681b         	ldr	r3, [r3]
 8025182: 691b         	ldr	r3, [r3, #0x10]
 8025184: 4618         	mov	r0, r3
 8025186: f7ff fb15    	bl	0x80247b4 <k_busy_wait> @ imm = #-0x9d6
 802518a: e01b         	b	0x80251c4 <_spi_context_cs_control+0x82> @ imm = #0x36
; 			if (!force_off &&
 802518c: 78bb         	ldrb	r3, [r7, #0x2]
 802518e: f083 0301    	eor	r3, r3, #0x1
 8025192: b2db         	uxtb	r3, r3
 8025194: 2b00         	cmp	r3, #0x0
 8025196: d006         	beq	0x80251a6 <_spi_context_cs_control+0x64> @ imm = #0xc
; 			    ctx->config->operation & SPI_HOLD_ON_CS) {
 8025198: 687b         	ldr	r3, [r7, #0x4]
 802519a: 681b         	ldr	r3, [r3]
 802519c: 889b         	ldrh	r3, [r3, #0x4]
 802519e: f403 5380    	and	r3, r3, #0x1000
; 			if (!force_off &&
 80251a2: 2b00         	cmp	r3, #0x0
 80251a4: d10d         	bne	0x80251c2 <_spi_context_cs_control+0x80> @ imm = #0x1a
; 			k_busy_wait(ctx->config->cs.delay);
 80251a6: 687b         	ldr	r3, [r7, #0x4]
 80251a8: 681b         	ldr	r3, [r3]
 80251aa: 691b         	ldr	r3, [r3, #0x10]
 80251ac: 4618         	mov	r0, r3
 80251ae: f7ff fb01    	bl	0x80247b4 <k_busy_wait> @ imm = #-0x9fe
; 			gpio_pin_set_dt(&ctx->config->cs.gpio, 0);
 80251b2: 687b         	ldr	r3, [r7, #0x4]
 80251b4: 681b         	ldr	r3, [r3]
 80251b6: 3308         	adds	r3, #0x8
 80251b8: 2100         	movs	r1, #0x0
 80251ba: 4618         	mov	r0, r3
 80251bc: f7ff fe95    	bl	0x8024eea <gpio_pin_set_dt> @ imm = #-0x2d6
 80251c0: e000         	b	0x80251c4 <_spi_context_cs_control+0x82> @ imm = #0x0
; 				return;
 80251c2: bf00         	nop
; }
 80251c4: 3708         	adds	r7, #0x8
 80251c6: 46bd         	mov	sp, r7
 80251c8: bd80         	pop	{r7, pc}

080251ca <spi_context_cs_control>:
; {
 80251ca: b580         	push	{r7, lr}
 80251cc: b082         	sub	sp, #0x8
 80251ce: af00         	add	r7, sp, #0x0
 80251d0: 6078         	str	r0, [r7, #0x4]
 80251d2: 460b         	mov	r3, r1
 80251d4: 70fb         	strb	r3, [r7, #0x3]
; 	_spi_context_cs_control(ctx, on, false);
 80251d6: 78fb         	ldrb	r3, [r7, #0x3]
 80251d8: 2200         	movs	r2, #0x0
 80251da: 4619         	mov	r1, r3
 80251dc: 6878         	ldr	r0, [r7, #0x4]
 80251de: f7ff ffb0    	bl	0x8025142 <_spi_context_cs_control> @ imm = #-0xa0
; }
 80251e2: bf00         	nop
 80251e4: 3708         	adds	r7, #0x8
 80251e6: 46bd         	mov	sp, r7
 80251e8: bd80         	pop	{r7, pc}

080251ea <spi_context_unlock_unconditionally>:
; {
 80251ea: b580         	push	{r7, lr}
 80251ec: b082         	sub	sp, #0x8
 80251ee: af00         	add	r7, sp, #0x0
 80251f0: 6078         	str	r0, [r7, #0x4]
; 	_spi_context_cs_control(ctx, false, true);
 80251f2: 2201         	movs	r2, #0x1
 80251f4: 2100         	movs	r1, #0x0
 80251f6: 6878         	ldr	r0, [r7, #0x4]
 80251f8: f7ff ffa3    	bl	0x8025142 <_spi_context_cs_control> @ imm = #-0xba
; 	if (!k_sem_count_get(&ctx->lock)) {
 80251fc: 687b         	ldr	r3, [r7, #0x4]
 80251fe: 3310         	adds	r3, #0x10
 8025200: 4618         	mov	r0, r3
 8025202: f7ff fafd    	bl	0x8024800 <k_sem_count_get> @ imm = #-0xa06
 8025206: 4603         	mov	r3, r0
 8025208: 2b00         	cmp	r3, #0x0
 802520a: d107         	bne	0x802521c <spi_context_unlock_unconditionally+0x32> @ imm = #0xe
; 		ctx->owner = NULL;
 802520c: 687b         	ldr	r3, [r7, #0x4]
 802520e: 2200         	movs	r2, #0x0
 8025210: 605a         	str	r2, [r3, #0x4]
; 		k_sem_give(&ctx->lock);
 8025212: 687b         	ldr	r3, [r7, #0x4]
 8025214: 3310         	adds	r3, #0x10
 8025216: 4618         	mov	r0, r3
 8025218: f7ff fae7    	bl	0x80247ea <k_sem_give>  @ imm = #-0xa32
; }
 802521c: bf00         	nop
 802521e: 3708         	adds	r7, #0x8
 8025220: 46bd         	mov	sp, r7
 8025222: bd80         	pop	{r7, pc}

08025224 <spi_context_get_next_buf>:
; {
 8025224: b480         	push	{r7}
 8025226: b085         	sub	sp, #0x14
 8025228: af00         	add	r7, sp, #0x0
 802522a: 60f8         	str	r0, [r7, #0xc]
 802522c: 60b9         	str	r1, [r7, #0x8]
 802522e: 607a         	str	r2, [r7, #0x4]
 8025230: 70fb         	strb	r3, [r7, #0x3]
; 	while (*count) {
 8025232: e01c         	b	0x802526e <spi_context_get_next_buf+0x4a> @ imm = #0x38
; 		if (((*current)->len / dfs) != 0) {
 8025234: 68fb         	ldr	r3, [r7, #0xc]
 8025236: 681b         	ldr	r3, [r3]
 8025238: 685a         	ldr	r2, [r3, #0x4]
 802523a: 78fb         	ldrb	r3, [r7, #0x3]
 802523c: 429a         	cmp	r2, r3
 802523e: d30b         	blo	0x8025258 <spi_context_get_next_buf+0x34> @ imm = #0x16
; 			*buf_len = (*current)->len / dfs;
 8025240: 68fb         	ldr	r3, [r7, #0xc]
 8025242: 681b         	ldr	r3, [r3]
 8025244: 685a         	ldr	r2, [r3, #0x4]
 8025246: 78fb         	ldrb	r3, [r7, #0x3]
 8025248: fbb2 f2f3    	udiv	r2, r2, r3
 802524c: 687b         	ldr	r3, [r7, #0x4]
 802524e: 601a         	str	r2, [r3]
; 			return (*current)->buf;
 8025250: 68fb         	ldr	r3, [r7, #0xc]
 8025252: 681b         	ldr	r3, [r3]
 8025254: 681b         	ldr	r3, [r3]
 8025256: e012         	b	0x802527e <spi_context_get_next_buf+0x5a> @ imm = #0x24
; 		++(*current);
 8025258: 68fb         	ldr	r3, [r7, #0xc]
 802525a: 681b         	ldr	r3, [r3]
 802525c: f103 0208    	add.w	r2, r3, #0x8
 8025260: 68fb         	ldr	r3, [r7, #0xc]
 8025262: 601a         	str	r2, [r3]
; 		--(*count);
 8025264: 68bb         	ldr	r3, [r7, #0x8]
 8025266: 681b         	ldr	r3, [r3]
 8025268: 1e5a         	subs	r2, r3, #0x1
 802526a: 68bb         	ldr	r3, [r7, #0x8]
 802526c: 601a         	str	r2, [r3]
; 	while (*count) {
 802526e: 68bb         	ldr	r3, [r7, #0x8]
 8025270: 681b         	ldr	r3, [r3]
 8025272: 2b00         	cmp	r3, #0x0
 8025274: d1de         	bne	0x8025234 <spi_context_get_next_buf+0x10> @ imm = #-0x44
; 	*buf_len = 0;
 8025276: 687b         	ldr	r3, [r7, #0x4]
 8025278: 2200         	movs	r2, #0x0
 802527a: 601a         	str	r2, [r3]
; 	return NULL;
 802527c: 2300         	movs	r3, #0x0
; }
 802527e: 4618         	mov	r0, r3
 8025280: 3714         	adds	r7, #0x14
 8025282: 46bd         	mov	sp, r7
 8025284: f85d 7b04    	ldr	r7, [sp], #4
 8025288: 4770         	bx	lr

0802528a <ll_func_tx_is_not_full>:
; {
 802528a: b580         	push	{r7, lr}
 802528c: b082         	sub	sp, #0x8
 802528e: af00         	add	r7, sp, #0x0
 8025290: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_TXP(spi);
 8025292: 6878         	ldr	r0, [r7, #0x4]
 8025294: f7ff fc66    	bl	0x8024b64 <LL_SPI_IsActiveFlag_TXP> @ imm = #-0x734
 8025298: 4603         	mov	r3, r0
; }
 802529a: 4618         	mov	r0, r3
 802529c: 3708         	adds	r7, #0x8
 802529e: 46bd         	mov	sp, r7
 80252a0: bd80         	pop	{r7, pc}

080252a2 <ll_func_rx_is_not_empty>:
; {
 80252a2: b580         	push	{r7, lr}
 80252a4: b082         	sub	sp, #0x8
 80252a6: af00         	add	r7, sp, #0x0
 80252a8: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_RXP(spi);
 80252aa: 6878         	ldr	r0, [r7, #0x4]
 80252ac: f7ff fc47    	bl	0x8024b3e <LL_SPI_IsActiveFlag_RXP> @ imm = #-0x772
 80252b0: 4603         	mov	r3, r0
; }
 80252b2: 4618         	mov	r0, r3
 80252b4: 3708         	adds	r7, #0x8
 80252b6: 46bd         	mov	sp, r7
 80252b8: bd80         	pop	{r7, pc}

080252ba <ll_func_disable_int_tx_empty>:
; {
 80252ba: b580         	push	{r7, lr}
 80252bc: b082         	sub	sp, #0x8
 80252be: af00         	add	r7, sp, #0x0
 80252c0: 6078         	str	r0, [r7, #0x4]
; 	LL_SPI_DisableIT_TXP(spi);
 80252c2: 6878         	ldr	r0, [r7, #0x4]
 80252c4: f7ff fcef    	bl	0x8024ca6 <LL_SPI_DisableIT_TXP> @ imm = #-0x622
; }
 80252c8: bf00         	nop
 80252ca: 3708         	adds	r7, #0x8
 80252cc: 46bd         	mov	sp, r7
 80252ce: bd80         	pop	{r7, pc}

080252d0 <ll_func_spi_is_busy>:
; {
 80252d0: b580         	push	{r7, lr}
 80252d2: b082         	sub	sp, #0x8
 80252d4: af00         	add	r7, sp, #0x0
 80252d6: 6078         	str	r0, [r7, #0x4]
; 	if (LL_SPI_GetTransferSize(spi) == 0) {
 80252d8: 6878         	ldr	r0, [r7, #0x4]
 80252da: f7ff fb17    	bl	0x802490c <LL_SPI_GetTransferSize> @ imm = #-0x9d2
 80252de: 4603         	mov	r3, r0
 80252e0: 2b00         	cmp	r3, #0x0
 80252e2: d109         	bne	0x80252f8 <ll_func_spi_is_busy+0x28> @ imm = #0x12
; 		return LL_SPI_IsActiveFlag_TXC(spi) == 0;
 80252e4: 6878         	ldr	r0, [r7, #0x4]
 80252e6: f7ff fc8a    	bl	0x8024bfe <LL_SPI_IsActiveFlag_TXC> @ imm = #-0x6ec
 80252ea: 4603         	mov	r3, r0
 80252ec: 2b00         	cmp	r3, #0x0
 80252ee: bf0c         	ite	eq
 80252f0: 2301         	moveq	r3, #0x1
 80252f2: 2300         	movne	r3, #0x0
 80252f4: b2db         	uxtb	r3, r3
 80252f6: e008         	b	0x802530a <ll_func_spi_is_busy+0x3a> @ imm = #0x10
; 		return LL_SPI_IsActiveFlag_EOT(spi) == 0;
 80252f8: 6878         	ldr	r0, [r7, #0x4]
 80252fa: f7ff fc46    	bl	0x8024b8a <LL_SPI_IsActiveFlag_EOT> @ imm = #-0x774
 80252fe: 4603         	mov	r3, r0
 8025300: 2b00         	cmp	r3, #0x0
 8025302: bf0c         	ite	eq
 8025304: 2301         	moveq	r3, #0x1
 8025306: 2300         	movne	r3, #0x0
 8025308: b2db         	uxtb	r3, r3
; }
 802530a: 4618         	mov	r0, r3
 802530c: 3708         	adds	r7, #0x8
 802530e: 46bd         	mov	sp, r7
 8025310: bd80         	pop	{r7, pc}

08025312 <ll_func_set_fifo_threshold_8bit>:
; {
 8025312: b580         	push	{r7, lr}
 8025314: b082         	sub	sp, #0x8
 8025316: af00         	add	r7, sp, #0x0
 8025318: 6078         	str	r0, [r7, #0x4]
; 	LL_SPI_SetFIFOThreshold(spi, LL_SPI_FIFO_TH_01DATA);
 802531a: 2100         	movs	r1, #0x0
 802531c: 6878         	ldr	r0, [r7, #0x4]
 802531e: f7ff fbd8    	bl	0x8024ad2 <LL_SPI_SetFIFOThreshold> @ imm = #-0x850
; }
 8025322: bf00         	nop
 8025324: 3708         	adds	r7, #0x8
 8025326: 46bd         	mov	sp, r7
 8025328: bd80         	pop	{r7, pc}

0802532a <ll_func_disable_spi>:
; {
 802532a: b580         	push	{r7, lr}
 802532c: b082         	sub	sp, #0x8
 802532e: af00         	add	r7, sp, #0x0
 8025330: 6078         	str	r0, [r7, #0x4]
; 	while (ll_func_rx_is_not_empty(spi)) {
 8025332: e002         	b	0x802533a <ll_func_disable_spi+0x10> @ imm = #0x4
; 		(void) LL_SPI_ReceiveData8(spi);
 8025334: 6878         	ldr	r0, [r7, #0x4]
 8025336: f7ff fcc6    	bl	0x8024cc6 <LL_SPI_ReceiveData8> @ imm = #-0x674
; 	while (ll_func_rx_is_not_empty(spi)) {
 802533a: 6878         	ldr	r0, [r7, #0x4]
 802533c: f7ff ffb1    	bl	0x80252a2 <ll_func_rx_is_not_empty> @ imm = #-0x9e
 8025340: 4603         	mov	r3, r0
 8025342: 2b00         	cmp	r3, #0x0
 8025344: d1f6         	bne	0x8025334 <ll_func_disable_spi+0xa> @ imm = #-0x14
; 	LL_SPI_Disable(spi);
 8025346: 6878         	ldr	r0, [r7, #0x4]
 8025348: f7ff fa76    	bl	0x8024838 <LL_SPI_Disable> @ imm = #-0xb14
; 	while (LL_SPI_IsEnabled(spi)) {
 802534c: bf00         	nop
 802534e: 6878         	ldr	r0, [r7, #0x4]
 8025350: f7ff fa82    	bl	0x8024858 <LL_SPI_IsEnabled> @ imm = #-0xafc
 8025354: 4603         	mov	r3, r0
 8025356: 2b00         	cmp	r3, #0x0
 8025358: d1f9         	bne	0x802534e <ll_func_disable_spi+0x24> @ imm = #-0xe
; }
 802535a: bf00         	nop
 802535c: bf00         	nop
 802535e: 3708         	adds	r7, #0x8
 8025360: 46bd         	mov	sp, r7
 8025362: bd80         	pop	{r7, pc}

08025364 <spi_stm32_pm_policy_state_lock_get>:
; {
 8025364: b480         	push	{r7}
 8025366: b083         	sub	sp, #0xc
 8025368: af00         	add	r7, sp, #0x0
 802536a: 6078         	str	r0, [r7, #0x4]
; }
 802536c: bf00         	nop
 802536e: 370c         	adds	r7, #0xc
 8025370: 46bd         	mov	sp, r7
 8025372: f85d 7b04    	ldr	r7, [sp], #4
 8025376: 4770         	bx	lr

08025378 <spi_stm32_pm_policy_state_lock_put>:
; {
 8025378: b480         	push	{r7}
 802537a: b083         	sub	sp, #0xc
 802537c: af00         	add	r7, sp, #0x0
 802537e: 6078         	str	r0, [r7, #0x4]
; }
 8025380: bf00         	nop
 8025382: 370c         	adds	r7, #0xc
 8025384: 46bd         	mov	sp, r7
 8025386: f85d 7b04    	ldr	r7, [sp], #4
 802538a: 4770         	bx	lr

0802538c <spi_stm32_transfer_ongoing>:
; {
 802538c: b480         	push	{r7}
 802538e: b085         	sub	sp, #0x14
 8025390: af00         	add	r7, sp, #0x0
 8025392: 6078         	str	r0, [r7, #0x4]
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 8025394: 687b         	ldr	r3, [r7, #0x4]
 8025396: 60fb         	str	r3, [r7, #0xc]
; 	return !!(ctx->tx_len);
 8025398: 68fb         	ldr	r3, [r7, #0xc]
 802539a: 6c9b         	ldr	r3, [r3, #0x48]
 802539c: 2b00         	cmp	r3, #0x0
 802539e: bf14         	ite	ne
 80253a0: 2301         	movne	r3, #0x1
 80253a2: 2300         	moveq	r3, #0x0
 80253a4: b2db         	uxtb	r3, r3
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 80253a6: 2b00         	cmp	r3, #0x0
 80253a8: d10a         	bne	0x80253c0 <spi_stm32_transfer_ongoing+0x34> @ imm = #0x14
 80253aa: 687b         	ldr	r3, [r7, #0x4]
 80253ac: 60bb         	str	r3, [r7, #0x8]
; 	return !!(ctx->rx_len);
 80253ae: 68bb         	ldr	r3, [r7, #0x8]
 80253b0: 6d1b         	ldr	r3, [r3, #0x50]
 80253b2: 2b00         	cmp	r3, #0x0
 80253b4: bf14         	ite	ne
 80253b6: 2301         	movne	r3, #0x1
 80253b8: 2300         	moveq	r3, #0x0
 80253ba: b2db         	uxtb	r3, r3
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 80253bc: 2b00         	cmp	r3, #0x0
 80253be: d001         	beq	0x80253c4 <spi_stm32_transfer_ongoing+0x38> @ imm = #0x2
 80253c0: 2301         	movs	r3, #0x1
 80253c2: e000         	b	0x80253c6 <spi_stm32_transfer_ongoing+0x3a> @ imm = #0x0
 80253c4: 2300         	movs	r3, #0x0
 80253c6: f003 0301    	and	r3, r3, #0x1
 80253ca: b2db         	uxtb	r3, r3
; }
 80253cc: 4618         	mov	r0, r3
 80253ce: 3714         	adds	r7, #0x14
 80253d0: 46bd         	mov	sp, r7
 80253d2: f85d 7b04    	ldr	r7, [sp], #4
 80253d6: 4770         	bx	lr

080253d8 <spi_stm32_shift_fifo>:
; {
 80253d8: b580         	push	{r7, lr}
 80253da: b082         	sub	sp, #0x8
 80253dc: af00         	add	r7, sp, #0x0
 80253de: 6078         	str	r0, [r7, #0x4]
 80253e0: 6039         	str	r1, [r7]
; 	if (ll_func_rx_is_not_empty(spi)) {
 80253e2: 6878         	ldr	r0, [r7, #0x4]
 80253e4: f7ff ff5d    	bl	0x80252a2 <ll_func_rx_is_not_empty> @ imm = #-0x146
 80253e8: 4603         	mov	r3, r0
 80253ea: 2b00         	cmp	r3, #0x0
 80253ec: d003         	beq	0x80253f6 <spi_stm32_shift_fifo+0x1e> @ imm = #0x6
; 		spi_stm32_read_next_frame(spi, data);
 80253ee: 6839         	ldr	r1, [r7]
 80253f0: 6878         	ldr	r0, [r7, #0x4]
 80253f2: f7eb f8fb    	bl	0x80105ec <spi_stm32_read_next_frame> @ imm = #-0x14e0a
; 	if (ll_func_tx_is_not_full(spi)) {
 80253f6: 6878         	ldr	r0, [r7, #0x4]
 80253f8: f7ff ff47    	bl	0x802528a <ll_func_tx_is_not_full> @ imm = #-0x172
 80253fc: 4603         	mov	r3, r0
 80253fe: 2b00         	cmp	r3, #0x0
 8025400: d003         	beq	0x802540a <spi_stm32_shift_fifo+0x32> @ imm = #0x6
; 		spi_stm32_send_next_frame(spi, data);
 8025402: 6839         	ldr	r1, [r7]
 8025404: 6878         	ldr	r0, [r7, #0x4]
 8025406: f7ea ff85    	bl	0x8010314 <spi_stm32_send_next_frame> @ imm = #-0x150f6
; }
 802540a: bf00         	nop
 802540c: 3708         	adds	r7, #0x8
 802540e: 46bd         	mov	sp, r7
 8025410: bd80         	pop	{r7, pc}

08025412 <spi_stm32_shift_m>:
; {
 8025412: b580         	push	{r7, lr}
 8025414: b082         	sub	sp, #0x8
 8025416: af00         	add	r7, sp, #0x0
 8025418: 6078         	str	r0, [r7, #0x4]
 802541a: 6039         	str	r1, [r7]
; 	if (cfg->fifo_enabled) {
 802541c: 687b         	ldr	r3, [r7, #0x4]
 802541e: 7e1b         	ldrb	r3, [r3, #0x18]
 8025420: 2b00         	cmp	r3, #0x0
 8025422: d006         	beq	0x8025432 <spi_stm32_shift_m+0x20> @ imm = #0xc
; 		spi_stm32_shift_fifo(cfg->spi, data);
 8025424: 687b         	ldr	r3, [r7, #0x4]
 8025426: 681b         	ldr	r3, [r3]
 8025428: 6839         	ldr	r1, [r7]
 802542a: 4618         	mov	r0, r3
 802542c: f7ff ffd4    	bl	0x80253d8 <spi_stm32_shift_fifo> @ imm = #-0x58
; }
 8025430: e01d         	b	0x802546e <spi_stm32_shift_m+0x5c> @ imm = #0x3a
; 		while (!ll_func_tx_is_not_full(cfg->spi)) {
 8025432: bf00         	nop
 8025434: 687b         	ldr	r3, [r7, #0x4]
 8025436: 681b         	ldr	r3, [r3]
 8025438: 4618         	mov	r0, r3
 802543a: f7ff ff26    	bl	0x802528a <ll_func_tx_is_not_full> @ imm = #-0x1b4
 802543e: 4603         	mov	r3, r0
 8025440: 2b00         	cmp	r3, #0x0
 8025442: d0f7         	beq	0x8025434 <spi_stm32_shift_m+0x22> @ imm = #-0x12
; 		spi_stm32_send_next_frame(cfg->spi, data);
 8025444: 687b         	ldr	r3, [r7, #0x4]
 8025446: 681b         	ldr	r3, [r3]
 8025448: 6839         	ldr	r1, [r7]
 802544a: 4618         	mov	r0, r3
 802544c: f7ea ff62    	bl	0x8010314 <spi_stm32_send_next_frame> @ imm = #-0x1513c
; 		while (!ll_func_rx_is_not_empty(cfg->spi)) {
 8025450: bf00         	nop
 8025452: 687b         	ldr	r3, [r7, #0x4]
 8025454: 681b         	ldr	r3, [r3]
 8025456: 4618         	mov	r0, r3
 8025458: f7ff ff23    	bl	0x80252a2 <ll_func_rx_is_not_empty> @ imm = #-0x1ba
 802545c: 4603         	mov	r3, r0
 802545e: 2b00         	cmp	r3, #0x0
 8025460: d0f7         	beq	0x8025452 <spi_stm32_shift_m+0x40> @ imm = #-0x12
; 		spi_stm32_read_next_frame(cfg->spi, data);
 8025462: 687b         	ldr	r3, [r7, #0x4]
 8025464: 681b         	ldr	r3, [r3]
 8025466: 6839         	ldr	r1, [r7]
 8025468: 4618         	mov	r0, r3
 802546a: f7eb f8bf    	bl	0x80105ec <spi_stm32_read_next_frame> @ imm = #-0x14e82
; }
 802546e: bf00         	nop
 8025470: 3708         	adds	r7, #0x8
 8025472: 46bd         	mov	sp, r7
 8025474: bd80         	pop	{r7, pc}

08025476 <spi_stm32_shift_frames>:
; {
 8025476: b580         	push	{r7, lr}
 8025478: b084         	sub	sp, #0x10
 802547a: af00         	add	r7, sp, #0x0
 802547c: 6078         	str	r0, [r7, #0x4]
 802547e: 6039         	str	r1, [r7]
; 	uint16_t operation = data->ctx.config->operation;
 8025480: 683b         	ldr	r3, [r7]
 8025482: 681b         	ldr	r3, [r3]
 8025484: 889b         	ldrh	r3, [r3, #0x4]
 8025486: 81fb         	strh	r3, [r7, #0xe]
; 	if (SPI_OP_MODE_GET(operation) == SPI_OP_MODE_MASTER) {
 8025488: 89fb         	ldrh	r3, [r7, #0xe]
 802548a: f003 0301    	and	r3, r3, #0x1
 802548e: 2b00         	cmp	r3, #0x0
 8025490: d104         	bne	0x802549c <spi_stm32_shift_frames+0x26> @ imm = #0x8
; 		spi_stm32_shift_m(cfg, data);
 8025492: 6839         	ldr	r1, [r7]
 8025494: 6878         	ldr	r0, [r7, #0x4]
 8025496: f7ff ffbc    	bl	0x8025412 <spi_stm32_shift_m> @ imm = #-0x88
 802549a: e005         	b	0x80254a8 <spi_stm32_shift_frames+0x32> @ imm = #0xa
; 		spi_stm32_shift_s(cfg->spi, data);
 802549c: 687b         	ldr	r3, [r7, #0x4]
 802549e: 681b         	ldr	r3, [r3]
 80254a0: 6839         	ldr	r1, [r7]
 80254a2: 4618         	mov	r0, r3
 80254a4: f7eb fa50    	bl	0x8010948 <spi_stm32_shift_s> @ imm = #-0x14b60
; 	return spi_stm32_get_err(cfg->spi);
 80254a8: 687b         	ldr	r3, [r7, #0x4]
 80254aa: 681b         	ldr	r3, [r3]
 80254ac: 4618         	mov	r0, r3
 80254ae: f7eb fa07    	bl	0x80108c0 <spi_stm32_get_err> @ imm = #-0x14bf2
 80254b2: 4603         	mov	r3, r0
; }
 80254b4: 4618         	mov	r0, r3
 80254b6: 3710         	adds	r7, #0x10
 80254b8: 46bd         	mov	sp, r7
 80254ba: bd80         	pop	{r7, pc}

080254bc <spi_stm32_cs_control>:
; {
 80254bc: b580         	push	{r7, lr}
 80254be: b084         	sub	sp, #0x10
 80254c0: af00         	add	r7, sp, #0x0
 80254c2: 6078         	str	r0, [r7, #0x4]
 80254c4: 460b         	mov	r3, r1
 80254c6: 70fb         	strb	r3, [r7, #0x3]
; 	struct spi_stm32_data *data = dev->data;
 80254c8: 687b         	ldr	r3, [r7, #0x4]
 80254ca: 691b         	ldr	r3, [r3, #0x10]
 80254cc: 60fb         	str	r3, [r7, #0xc]
; 	spi_context_cs_control(&data->ctx, on);
 80254ce: 68fb         	ldr	r3, [r7, #0xc]
 80254d0: 78fa         	ldrb	r2, [r7, #0x3]
 80254d2: 4611         	mov	r1, r2
 80254d4: 4618         	mov	r0, r3
 80254d6: f7ff fe78    	bl	0x80251ca <spi_context_cs_control> @ imm = #-0x310
; }
 80254da: bf00         	nop
 80254dc: 3710         	adds	r7, #0x10
 80254de: 46bd         	mov	sp, r7
 80254e0: bd80         	pop	{r7, pc}

080254e2 <spi_stm32_complete>:
; {
 80254e2: b580         	push	{r7, lr}
 80254e4: b086         	sub	sp, #0x18
 80254e6: af00         	add	r7, sp, #0x0
 80254e8: 6078         	str	r0, [r7, #0x4]
 80254ea: 6039         	str	r1, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 80254ec: 687b         	ldr	r3, [r7, #0x4]
 80254ee: 685b         	ldr	r3, [r3, #0x4]
 80254f0: 617b         	str	r3, [r7, #0x14]
; 	SPI_TypeDef *spi = cfg->spi;
 80254f2: 697b         	ldr	r3, [r7, #0x14]
 80254f4: 681b         	ldr	r3, [r3]
 80254f6: 613b         	str	r3, [r7, #0x10]
; 	struct spi_stm32_data *data = dev->data;
 80254f8: 687b         	ldr	r3, [r7, #0x4]
 80254fa: 691b         	ldr	r3, [r3, #0x10]
 80254fc: 60fb         	str	r3, [r7, #0xc]
; 	while (ll_func_rx_is_not_empty(spi)) {
 80254fe: e002         	b	0x8025506 <spi_stm32_complete+0x24> @ imm = #0x4
; 		(void)LL_SPI_ReceiveData8(spi);
 8025500: 6938         	ldr	r0, [r7, #0x10]
 8025502: f7ff fbe0    	bl	0x8024cc6 <LL_SPI_ReceiveData8> @ imm = #-0x840
; 	while (ll_func_rx_is_not_empty(spi)) {
 8025506: 6938         	ldr	r0, [r7, #0x10]
 8025508: f7ff fecb    	bl	0x80252a2 <ll_func_rx_is_not_empty> @ imm = #-0x26a
 802550c: 4603         	mov	r3, r0
 802550e: 2b00         	cmp	r3, #0x0
 8025510: d1f6         	bne	0x8025500 <spi_stm32_complete+0x1e> @ imm = #-0x14
; 	if (LL_SPI_GetMode(spi) == LL_SPI_MODE_MASTER) {
 8025512: 6938         	ldr	r0, [r7, #0x10]
 8025514: f7ff f9c6    	bl	0x80248a4 <LL_SPI_GetMode> @ imm = #-0xc74
 8025518: 4603         	mov	r3, r0
 802551a: f5b3 0f80    	cmp.w	r3, #0x400000
 802551e: d10a         	bne	0x8025536 <spi_stm32_complete+0x54> @ imm = #0x14
; 		while (ll_func_spi_is_busy(spi)) {
 8025520: bf00         	nop
 8025522: 6938         	ldr	r0, [r7, #0x10]
 8025524: f7ff fed4    	bl	0x80252d0 <ll_func_spi_is_busy> @ imm = #-0x258
 8025528: 4603         	mov	r3, r0
 802552a: 2b00         	cmp	r3, #0x0
 802552c: d1f9         	bne	0x8025522 <spi_stm32_complete+0x40> @ imm = #-0xe
; 		spi_stm32_cs_control(dev, false);
 802552e: 2100         	movs	r1, #0x0
 8025530: 6878         	ldr	r0, [r7, #0x4]
 8025532: f7ff ffc3    	bl	0x80254bc <spi_stm32_cs_control> @ imm = #-0x7a
; 	if (LL_SPI_IsActiveFlag_MODF(spi)) {
 8025536: 6938         	ldr	r0, [r7, #0x10]
 8025538: f7ff fb3a    	bl	0x8024bb0 <LL_SPI_IsActiveFlag_MODF> @ imm = #-0x98c
 802553c: 4603         	mov	r3, r0
 802553e: 2b00         	cmp	r3, #0x0
 8025540: d002         	beq	0x8025548 <spi_stm32_complete+0x66> @ imm = #0x4
; 		LL_SPI_ClearFlag_MODF(spi);
 8025542: 6938         	ldr	r0, [r7, #0x10]
 8025544: f7ff fb9f    	bl	0x8024c86 <LL_SPI_ClearFlag_MODF> @ imm = #-0x8c2
; 	if (cfg->fifo_enabled) {
 8025548: 697b         	ldr	r3, [r7, #0x14]
 802554a: 7e1b         	ldrb	r3, [r3, #0x18]
 802554c: 2b00         	cmp	r3, #0x0
 802554e: d00c         	beq	0x802556a <spi_stm32_complete+0x88> @ imm = #0x18
; 		LL_SPI_ClearFlag_TXTF(spi);
 8025550: 6938         	ldr	r0, [r7, #0x10]
 8025552: f7ff fb78    	bl	0x8024c46 <LL_SPI_ClearFlag_TXTF> @ imm = #-0x910
; 		LL_SPI_ClearFlag_OVR(spi);
 8025556: 6938         	ldr	r0, [r7, #0x10]
 8025558: f7ff fb85    	bl	0x8024c66 <LL_SPI_ClearFlag_OVR> @ imm = #-0x8f6
; 		LL_SPI_ClearFlag_EOT(spi);
 802555c: 6938         	ldr	r0, [r7, #0x10]
 802555e: f7ff fb62    	bl	0x8024c26 <LL_SPI_ClearFlag_EOT> @ imm = #-0x93c
; 		LL_SPI_SetTransferSize(spi, 0);
 8025562: 2100         	movs	r1, #0x0
 8025564: 6938         	ldr	r0, [r7, #0x10]
 8025566: f7ea fdad    	bl	0x80100c4 <LL_SPI_SetTransferSize> @ imm = #-0x154a6
; 	if (!(data->ctx.config->operation & SPI_HOLD_ON_CS)) {
 802556a: 68fb         	ldr	r3, [r7, #0xc]
 802556c: 681b         	ldr	r3, [r3]
 802556e: 889b         	ldrh	r3, [r3, #0x4]
 8025570: f403 5380    	and	r3, r3, #0x1000
 8025574: 2b00         	cmp	r3, #0x0
 8025576: d102         	bne	0x802557e <spi_stm32_complete+0x9c> @ imm = #0x4
; 		ll_func_disable_spi(spi);
 8025578: 6938         	ldr	r0, [r7, #0x10]
 802557a: f7ff fed6    	bl	0x802532a <ll_func_disable_spi> @ imm = #-0x254
; 	spi_stm32_pm_policy_state_lock_put(dev);
 802557e: 6878         	ldr	r0, [r7, #0x4]
 8025580: f7ff fefa    	bl	0x8025378 <spi_stm32_pm_policy_state_lock_put> @ imm = #-0x20c
; }
 8025584: bf00         	nop
 8025586: 3718         	adds	r7, #0x18
 8025588: 46bd         	mov	sp, r7
 802558a: bd80         	pop	{r7, pc}

0802558c <spi_stm32_release>:
; {
 802558c: b580         	push	{r7, lr}
 802558e: b084         	sub	sp, #0x10
 8025590: af00         	add	r7, sp, #0x0
 8025592: 6078         	str	r0, [r7, #0x4]
 8025594: 6039         	str	r1, [r7]
; 	struct spi_stm32_data *data = dev->data;
 8025596: 687b         	ldr	r3, [r7, #0x4]
 8025598: 691b         	ldr	r3, [r3, #0x10]
 802559a: 60fb         	str	r3, [r7, #0xc]
; 	const struct spi_stm32_config *cfg = dev->config;
 802559c: 687b         	ldr	r3, [r7, #0x4]
 802559e: 685b         	ldr	r3, [r3, #0x4]
 80255a0: 60bb         	str	r3, [r7, #0x8]
; 	spi_context_unlock_unconditionally(&data->ctx);
 80255a2: 68fb         	ldr	r3, [r7, #0xc]
 80255a4: 4618         	mov	r0, r3
 80255a6: f7ff fe20    	bl	0x80251ea <spi_context_unlock_unconditionally> @ imm = #-0x3c0
; 	ll_func_disable_spi(cfg->spi);
 80255aa: 68bb         	ldr	r3, [r7, #0x8]
 80255ac: 681b         	ldr	r3, [r3]
 80255ae: 4618         	mov	r0, r3
 80255b0: f7ff febb    	bl	0x802532a <ll_func_disable_spi> @ imm = #-0x28a
; 	return 0;
 80255b4: 2300         	movs	r3, #0x0
; }
 80255b6: 4618         	mov	r0, r3
 80255b8: 3710         	adds	r7, #0x10
 80255ba: 46bd         	mov	sp, r7
 80255bc: bd80         	pop	{r7, pc}

080255be <spi_stm32_count_bufset_frames>:
; {
 80255be: b480         	push	{r7}
 80255c0: b087         	sub	sp, #0x1c
 80255c2: af00         	add	r7, sp, #0x0
 80255c4: 6078         	str	r0, [r7, #0x4]
 80255c6: 6039         	str	r1, [r7]
; 	if (bufs == NULL) {
 80255c8: 683b         	ldr	r3, [r7]
 80255ca: 2b00         	cmp	r3, #0x0
 80255cc: d101         	bne	0x80255d2 <spi_stm32_count_bufset_frames+0x14> @ imm = #0x2
; 		return 0;
 80255ce: 2300         	movs	r3, #0x0
 80255d0: e02c         	b	0x802562c <spi_stm32_count_bufset_frames+0x6e> @ imm = #0x58
; 	uint32_t num_bytes = 0;
 80255d2: 2300         	movs	r3, #0x0
 80255d4: 617b         	str	r3, [r7, #0x14]
; 	for (size_t i = 0; i < bufs->count; i++) {
 80255d6: 2300         	movs	r3, #0x0
 80255d8: 613b         	str	r3, [r7, #0x10]
 80255da: e00b         	b	0x80255f4 <spi_stm32_count_bufset_frames+0x36> @ imm = #0x16
; 		num_bytes += bufs->buffers[i].len;
 80255dc: 683b         	ldr	r3, [r7]
 80255de: 681a         	ldr	r2, [r3]
 80255e0: 693b         	ldr	r3, [r7, #0x10]
 80255e2: 00db         	lsls	r3, r3, #0x3
 80255e4: 4413         	add	r3, r2
 80255e6: 685b         	ldr	r3, [r3, #0x4]
 80255e8: 697a         	ldr	r2, [r7, #0x14]
 80255ea: 4413         	add	r3, r2
 80255ec: 617b         	str	r3, [r7, #0x14]
; 	for (size_t i = 0; i < bufs->count; i++) {
 80255ee: 693b         	ldr	r3, [r7, #0x10]
 80255f0: 3301         	adds	r3, #0x1
 80255f2: 613b         	str	r3, [r7, #0x10]
 80255f4: 683b         	ldr	r3, [r7]
 80255f6: 685b         	ldr	r3, [r3, #0x4]
 80255f8: 693a         	ldr	r2, [r7, #0x10]
 80255fa: 429a         	cmp	r2, r3
 80255fc: d3ee         	blo	0x80255dc <spi_stm32_count_bufset_frames+0x1e> @ imm = #-0x24
; 	uint8_t bytes_per_frame = SPI_WORD_SIZE_GET(config->operation) / 8;
 80255fe: 687b         	ldr	r3, [r7, #0x4]
 8025600: 889b         	ldrh	r3, [r3, #0x4]
 8025602: 095b         	lsrs	r3, r3, #0x5
 8025604: f003 033f    	and	r3, r3, #0x3f
 8025608: 08db         	lsrs	r3, r3, #0x3
 802560a: 73fb         	strb	r3, [r7, #0xf]
; 	if ((num_bytes % bytes_per_frame) != 0) {
 802560c: 7bfa         	ldrb	r2, [r7, #0xf]
 802560e: 697b         	ldr	r3, [r7, #0x14]
 8025610: fbb3 f1f2    	udiv	r1, r3, r2
 8025614: fb01 f202    	mul	r2, r1, r2
 8025618: 1a9b         	subs	r3, r3, r2
 802561a: 2b00         	cmp	r3, #0x0
 802561c: d002         	beq	0x8025624 <spi_stm32_count_bufset_frames+0x66> @ imm = #0x4
; 		return -EINVAL;
 802561e: f06f 0315    	mvn	r3, #0x15
 8025622: e003         	b	0x802562c <spi_stm32_count_bufset_frames+0x6e> @ imm = #0x6
; 	return num_bytes / bytes_per_frame;
 8025624: 7bfb         	ldrb	r3, [r7, #0xf]
 8025626: 697a         	ldr	r2, [r7, #0x14]
 8025628: fbb2 f3f3    	udiv	r3, r2, r3
; }
 802562c: 4618         	mov	r0, r3
 802562e: 371c         	adds	r7, #0x1c
 8025630: 46bd         	mov	sp, r7
 8025632: f85d 7b04    	ldr	r7, [sp], #4
 8025636: 4770         	bx	lr

08025638 <spi_stm32_count_total_frames>:
; {
 8025638: b580         	push	{r7, lr}
 802563a: b086         	sub	sp, #0x18
 802563c: af00         	add	r7, sp, #0x0
 802563e: 60f8         	str	r0, [r7, #0xc]
 8025640: 60b9         	str	r1, [r7, #0x8]
 8025642: 607a         	str	r2, [r7, #0x4]
; 	int tx_frames = spi_stm32_count_bufset_frames(config, tx_bufs);
 8025644: 68b9         	ldr	r1, [r7, #0x8]
 8025646: 68f8         	ldr	r0, [r7, #0xc]
 8025648: f7ff ffb9    	bl	0x80255be <spi_stm32_count_bufset_frames> @ imm = #-0x8e
 802564c: 6178         	str	r0, [r7, #0x14]
; 	if (tx_frames < 0) {
 802564e: 697b         	ldr	r3, [r7, #0x14]
 8025650: 2b00         	cmp	r3, #0x0
 8025652: da01         	bge	0x8025658 <spi_stm32_count_total_frames+0x20> @ imm = #0x2
; 		return tx_frames;
 8025654: 697b         	ldr	r3, [r7, #0x14]
 8025656: e019         	b	0x802568c <spi_stm32_count_total_frames+0x54> @ imm = #0x32
; 	int rx_frames = spi_stm32_count_bufset_frames(config, rx_bufs);
 8025658: 6879         	ldr	r1, [r7, #0x4]
 802565a: 68f8         	ldr	r0, [r7, #0xc]
 802565c: f7ff ffaf    	bl	0x80255be <spi_stm32_count_bufset_frames> @ imm = #-0xa2
 8025660: 6138         	str	r0, [r7, #0x10]
; 	if (rx_frames < 0) {
 8025662: 693b         	ldr	r3, [r7, #0x10]
 8025664: 2b00         	cmp	r3, #0x0
 8025666: da01         	bge	0x802566c <spi_stm32_count_total_frames+0x34> @ imm = #0x2
; 		return rx_frames;
 8025668: 693b         	ldr	r3, [r7, #0x10]
 802566a: e00f         	b	0x802568c <spi_stm32_count_total_frames+0x54> @ imm = #0x1e
; 	if (tx_frames > UINT16_MAX || rx_frames > UINT16_MAX) {
 802566c: 697b         	ldr	r3, [r7, #0x14]
 802566e: f5b3 3f80    	cmp.w	r3, #0x10000
 8025672: da03         	bge	0x802567c <spi_stm32_count_total_frames+0x44> @ imm = #0x6
 8025674: 693b         	ldr	r3, [r7, #0x10]
 8025676: f5b3 3f80    	cmp.w	r3, #0x10000
 802567a: db02         	blt	0x8025682 <spi_stm32_count_total_frames+0x4a> @ imm = #0x4
; 		return -EMSGSIZE;
 802567c: f06f 0379    	mvn	r3, #0x79
 8025680: e004         	b	0x802568c <spi_stm32_count_total_frames+0x54> @ imm = #0x8
; 	return MAX(rx_frames, tx_frames);
 8025682: 697a         	ldr	r2, [r7, #0x14]
 8025684: 693b         	ldr	r3, [r7, #0x10]
 8025686: 4293         	cmp	r3, r2
 8025688: bfb8         	it	lt
 802568a: 4613         	movlt	r3, r2
; }
 802568c: 4618         	mov	r0, r3
 802568e: 3718         	adds	r7, #0x18
 8025690: 46bd         	mov	sp, r7
 8025692: bd80         	pop	{r7, pc}

08025694 <transceive>:
; {
 8025694: b580         	push	{r7, lr}
 8025696: b08c         	sub	sp, #0x30
 8025698: af02         	add	r7, sp, #0x8
 802569a: 60f8         	str	r0, [r7, #0xc]
 802569c: 60b9         	str	r1, [r7, #0x8]
 802569e: 607a         	str	r2, [r7, #0x4]
 80256a0: 603b         	str	r3, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 80256a2: 68fb         	ldr	r3, [r7, #0xc]
 80256a4: 685b         	ldr	r3, [r3, #0x4]
 80256a6: 623b         	str	r3, [r7, #0x20]
; 	struct spi_stm32_data *data = dev->data;
 80256a8: 68fb         	ldr	r3, [r7, #0xc]
 80256aa: 691b         	ldr	r3, [r3, #0x10]
 80256ac: 61fb         	str	r3, [r7, #0x1c]
; 	SPI_TypeDef *spi = cfg->spi;
 80256ae: 6a3b         	ldr	r3, [r7, #0x20]
 80256b0: 681b         	ldr	r3, [r3]
 80256b2: 61bb         	str	r3, [r7, #0x18]
; 	if (!tx_bufs && !rx_bufs) {
 80256b4: 687b         	ldr	r3, [r7, #0x4]
 80256b6: 2b00         	cmp	r3, #0x0
 80256b8: d104         	bne	0x80256c4 <transceive+0x30> @ imm = #0x8
 80256ba: 683b         	ldr	r3, [r7]
 80256bc: 2b00         	cmp	r3, #0x0
 80256be: d101         	bne	0x80256c4 <transceive+0x30> @ imm = #0x2
; 		return 0;
 80256c0: 2300         	movs	r3, #0x0
 80256c2: e07e         	b	0x80257c2 <transceive+0x12e> @ imm = #0xfc
; 	if (asynchronous) {
 80256c4: f897 3030    	ldrb.w	r3, [r7, #0x30]
 80256c8: 2b00         	cmp	r3, #0x0
 80256ca: d002         	beq	0x80256d2 <transceive+0x3e> @ imm = #0x4
; 		return -ENOTSUP;
 80256cc: f06f 0385    	mvn	r3, #0x85
 80256d0: e077         	b	0x80257c2 <transceive+0x12e> @ imm = #0xee
; 	spi_context_lock(&data->ctx, asynchronous, cb, userdata, config);
 80256d2: 69f8         	ldr	r0, [r7, #0x1c]
 80256d4: f897 1030    	ldrb.w	r1, [r7, #0x30]
 80256d8: 68bb         	ldr	r3, [r7, #0x8]
 80256da: 9300         	str	r3, [sp]
 80256dc: 6bbb         	ldr	r3, [r7, #0x38]
 80256de: 6b7a         	ldr	r2, [r7, #0x34]
 80256e0: f7ff fceb    	bl	0x80250ba <spi_context_lock> @ imm = #-0x62a
; 	spi_stm32_pm_policy_state_lock_get(dev);
 80256e4: 68f8         	ldr	r0, [r7, #0xc]
 80256e6: f7ff fe3d    	bl	0x8025364 <spi_stm32_pm_policy_state_lock_get> @ imm = #-0x386
; 	ret = spi_stm32_configure(dev, config);
 80256ea: 68b9         	ldr	r1, [r7, #0x8]
 80256ec: 68f8         	ldr	r0, [r7, #0xc]
 80256ee: f7eb fbe7    	bl	0x8010ec0 <spi_stm32_configure> @ imm = #-0x14832
 80256f2: 6278         	str	r0, [r7, #0x24]
; 	if (ret) {
 80256f4: 6a7b         	ldr	r3, [r7, #0x24]
 80256f6: 2b00         	cmp	r3, #0x0
 80256f8: d15c         	bne	0x80257b4 <transceive+0x120> @ imm = #0xb8
; 	if (SPI_WORD_SIZE_GET(config->operation) == 8) {
 80256fa: 68bb         	ldr	r3, [r7, #0x8]
 80256fc: 889b         	ldrh	r3, [r3, #0x4]
 80256fe: 095b         	lsrs	r3, r3, #0x5
 8025700: f003 033f    	and	r3, r3, #0x3f
 8025704: 2b08         	cmp	r3, #0x8
 8025706: d106         	bne	0x8025716 <transceive+0x82> @ imm = #0xc
; 		spi_context_buffers_setup(&data->ctx, tx_bufs, rx_bufs, 1);
 8025708: 69f8         	ldr	r0, [r7, #0x1c]
 802570a: 2301         	movs	r3, #0x1
 802570c: 683a         	ldr	r2, [r7]
 802570e: 6879         	ldr	r1, [r7, #0x4]
 8025710: f7ea fd46    	bl	0x80101a0 <spi_context_buffers_setup> @ imm = #-0x15574
 8025714: e005         	b	0x8025722 <transceive+0x8e> @ imm = #0xa
; 		spi_context_buffers_setup(&data->ctx, tx_bufs, rx_bufs, 2);
 8025716: 69f8         	ldr	r0, [r7, #0x1c]
 8025718: 2302         	movs	r3, #0x2
 802571a: 683a         	ldr	r2, [r7]
 802571c: 6879         	ldr	r1, [r7, #0x4]
 802571e: f7ea fd3f    	bl	0x80101a0 <spi_context_buffers_setup> @ imm = #-0x15582
; 	if (cfg->fifo_enabled && SPI_OP_MODE_GET(config->operation) == SPI_OP_MODE_MASTER) {
 8025722: 6a3b         	ldr	r3, [r7, #0x20]
 8025724: 7e1b         	ldrb	r3, [r3, #0x18]
 8025726: 2b00         	cmp	r3, #0x0
 8025728: d016         	beq	0x8025758 <transceive+0xc4> @ imm = #0x2c
 802572a: 68bb         	ldr	r3, [r7, #0x8]
 802572c: 889b         	ldrh	r3, [r3, #0x4]
 802572e: f003 0301    	and	r3, r3, #0x1
 8025732: 2b00         	cmp	r3, #0x0
 8025734: d110         	bne	0x8025758 <transceive+0xc4> @ imm = #0x20
; 		int total_frames = spi_stm32_count_total_frames(config, tx_bufs, rx_bufs);
 8025736: 683a         	ldr	r2, [r7]
 8025738: 6879         	ldr	r1, [r7, #0x4]
 802573a: 68b8         	ldr	r0, [r7, #0x8]
 802573c: f7ff ff7c    	bl	0x8025638 <spi_stm32_count_total_frames> @ imm = #-0x108
 8025740: 6178         	str	r0, [r7, #0x14]
; 		if (total_frames < 0) {
 8025742: 697b         	ldr	r3, [r7, #0x14]
 8025744: 2b00         	cmp	r3, #0x0
 8025746: da02         	bge	0x802574e <transceive+0xba> @ imm = #0x4
; 			ret = total_frames;
 8025748: 697b         	ldr	r3, [r7, #0x14]
 802574a: 627b         	str	r3, [r7, #0x24]
; 			goto end;
 802574c: e033         	b	0x80257b6 <transceive+0x122> @ imm = #0x66
; 		LL_SPI_SetTransferSize(spi, (uint32_t)total_frames);
 802574e: 697b         	ldr	r3, [r7, #0x14]
 8025750: 4619         	mov	r1, r3
 8025752: 69b8         	ldr	r0, [r7, #0x18]
 8025754: f7ea fcb6    	bl	0x80100c4 <LL_SPI_SetTransferSize> @ imm = #-0x15694
; 	LL_SPI_Enable(spi);
 8025758: 69b8         	ldr	r0, [r7, #0x18]
 802575a: f7ff f85d    	bl	0x8024818 <LL_SPI_Enable> @ imm = #-0xf46
; 	if (LL_SPI_GetMode(spi) == LL_SPI_MODE_MASTER) {
 802575e: 69b8         	ldr	r0, [r7, #0x18]
 8025760: f7ff f8a0    	bl	0x80248a4 <LL_SPI_GetMode> @ imm = #-0xec0
 8025764: 4603         	mov	r3, r0
 8025766: f5b3 0f80    	cmp.w	r3, #0x400000
 802576a: d109         	bne	0x8025780 <transceive+0xec> @ imm = #0x12
; 		LL_SPI_StartMasterTransfer(spi);
 802576c: 69b8         	ldr	r0, [r7, #0x18]
 802576e: f7ff f8ed    	bl	0x802494c <LL_SPI_StartMasterTransfer> @ imm = #-0xe26
; 		while (!LL_SPI_IsActiveMasterTransfer(spi)) {
 8025772: bf00         	nop
 8025774: 69b8         	ldr	r0, [r7, #0x18]
 8025776: f7ff f8f9    	bl	0x802496c <LL_SPI_IsActiveMasterTransfer> @ imm = #-0xe0e
 802577a: 4603         	mov	r3, r0
 802577c: 2b00         	cmp	r3, #0x0
 802577e: d0f9         	beq	0x8025774 <transceive+0xe0> @ imm = #-0xe
; 	k_busy_wait(WAIT_1US);
 8025780: 2001         	movs	r0, #0x1
 8025782: f7ff f817    	bl	0x80247b4 <k_busy_wait> @ imm = #-0xfd2
; 	spi_stm32_cs_control(dev, true);
 8025786: 2101         	movs	r1, #0x1
 8025788: 68f8         	ldr	r0, [r7, #0xc]
 802578a: f7ff fe97    	bl	0x80254bc <spi_stm32_cs_control> @ imm = #-0x2d2
; 		ret = spi_stm32_shift_frames(cfg, data);
 802578e: 69f9         	ldr	r1, [r7, #0x1c]
 8025790: 6a38         	ldr	r0, [r7, #0x20]
 8025792: f7ff fe70    	bl	0x8025476 <spi_stm32_shift_frames> @ imm = #-0x320
 8025796: 6278         	str	r0, [r7, #0x24]
; 	} while (!ret && spi_stm32_transfer_ongoing(data));
 8025798: 6a7b         	ldr	r3, [r7, #0x24]
 802579a: 2b00         	cmp	r3, #0x0
 802579c: d105         	bne	0x80257aa <transceive+0x116> @ imm = #0xa
 802579e: 69f8         	ldr	r0, [r7, #0x1c]
 80257a0: f7ff fdf4    	bl	0x802538c <spi_stm32_transfer_ongoing> @ imm = #-0x418
 80257a4: 4603         	mov	r3, r0
 80257a6: 2b00         	cmp	r3, #0x0
 80257a8: d1f1         	bne	0x802578e <transceive+0xfa> @ imm = #-0x1e
; 	spi_stm32_complete(dev, ret);
 80257aa: 6a79         	ldr	r1, [r7, #0x24]
 80257ac: 68f8         	ldr	r0, [r7, #0xc]
 80257ae: f7ff fe98    	bl	0x80254e2 <spi_stm32_complete> @ imm = #-0x2d0
 80257b2: e000         	b	0x80257b6 <transceive+0x122> @ imm = #0x0
; 		goto end;
 80257b4: bf00         	nop
; 	spi_context_release(&data->ctx, ret);
 80257b6: 69fb         	ldr	r3, [r7, #0x1c]
 80257b8: 6a79         	ldr	r1, [r7, #0x24]
 80257ba: 4618         	mov	r0, r3
 80257bc: f7ff fca9    	bl	0x8025112 <spi_context_release> @ imm = #-0x6ae
; 	return ret;
 80257c0: 6a7b         	ldr	r3, [r7, #0x24]
; }
 80257c2: 4618         	mov	r0, r3
 80257c4: 3728         	adds	r7, #0x28
 80257c6: 46bd         	mov	sp, r7
 80257c8: bd80         	pop	{r7, pc}

080257ca <spi_stm32_transceive>:
; {
 80257ca: b580         	push	{r7, lr}
 80257cc: b088         	sub	sp, #0x20
 80257ce: af04         	add	r7, sp, #0x10
 80257d0: 60f8         	str	r0, [r7, #0xc]
 80257d2: 60b9         	str	r1, [r7, #0x8]
 80257d4: 607a         	str	r2, [r7, #0x4]
 80257d6: 603b         	str	r3, [r7]
; 	return transceive(dev, config, tx_bufs, rx_bufs, false, NULL, NULL);
 80257d8: 2300         	movs	r3, #0x0
 80257da: 9302         	str	r3, [sp, #0x8]
 80257dc: 2300         	movs	r3, #0x0
 80257de: 9301         	str	r3, [sp, #0x4]
 80257e0: 2300         	movs	r3, #0x0
 80257e2: 9300         	str	r3, [sp]
 80257e4: 683b         	ldr	r3, [r7]
 80257e6: 687a         	ldr	r2, [r7, #0x4]
 80257e8: 68b9         	ldr	r1, [r7, #0x8]
 80257ea: 68f8         	ldr	r0, [r7, #0xc]
 80257ec: f7ff ff52    	bl	0x8025694 <transceive>  @ imm = #-0x15c
 80257f0: 4603         	mov	r3, r0
; }
 80257f2: 4618         	mov	r0, r3
 80257f4: 3710         	adds	r7, #0x10
 80257f6: 46bd         	mov	sp, r7
 80257f8: bd80         	pop	{r7, pc}

080257fa <spi_stm32_is_subghzspi>:
; {
 80257fa: b480         	push	{r7}
 80257fc: b083         	sub	sp, #0xc
 80257fe: af00         	add	r7, sp, #0x0
 8025800: 6078         	str	r0, [r7, #0x4]
; 	return false;
 8025802: 2300         	movs	r3, #0x0
; }
 8025804: 4618         	mov	r0, r3
 8025806: 370c         	adds	r7, #0xc
 8025808: 46bd         	mov	sp, r7
 802580a: f85d 7b04    	ldr	r7, [sp], #4
 802580e: 4770         	bx	lr

08025810 <device_is_ready>:
; {
 8025810: b580         	push	{r7, lr}
 8025812: b082         	sub	sp, #0x8
 8025814: af00         	add	r7, sp, #0x0
 8025816: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8025818: 6878         	ldr	r0, [r7, #0x4]
 802581a: f000 fdc0    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0xb80
 802581e: 4603         	mov	r3, r0
; }
 8025820: 4618         	mov	r0, r3
 8025822: 3708         	adds	r7, #0x8
 8025824: 46bd         	mov	sp, r7
 8025826: bd80         	pop	{r7, pc}

08025828 <arch_k_cycle_get_32>:
; {
 8025828: b580         	push	{r7, lr}
 802582a: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 802582c: f7ec f80a    	bl	0x8011844 <sys_clock_cycle_get_32> @ imm = #-0x13fec
 8025830: 4603         	mov	r3, r0
; }
 8025832: 4618         	mov	r0, r3
 8025834: bd80         	pop	{r7, pc}

08025836 <k_thread_start>:
; {
 8025836: b580         	push	{r7, lr}
 8025838: b082         	sub	sp, #0x8
 802583a: af00         	add	r7, sp, #0x0
 802583c: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 802583e: 6878         	ldr	r0, [r7, #0x4]
 8025840: f000 f819    	bl	0x8025876 <k_thread_resume> @ imm = #0x32
; }
 8025844: bf00         	nop
 8025846: 3708         	adds	r7, #0x8
 8025848: 46bd         	mov	sp, r7
 802584a: bd80         	pop	{r7, pc}

0802584c <k_cycle_get_32>:
; {
 802584c: b580         	push	{r7, lr}
 802584e: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 8025850: f7ff ffea    	bl	0x8025828 <arch_k_cycle_get_32> @ imm = #-0x2c
 8025854: 4603         	mov	r3, r0
; }
 8025856: 4618         	mov	r0, r3
 8025858: bd80         	pop	{r7, pc}

0802585a <k_sleep>:
; {
 802585a: b580         	push	{r7, lr}
 802585c: b082         	sub	sp, #0x8
 802585e: af00         	add	r7, sp, #0x0
 8025860: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8025864: e9d7 0100    	ldrd	r0, r1, [r7]
 8025868: f7f1 ff80    	bl	0x801776c <z_impl_k_sleep> @ imm = #-0xe100
 802586c: 4603         	mov	r3, r0
; }
 802586e: 4618         	mov	r0, r3
 8025870: 3708         	adds	r7, #0x8
 8025872: 46bd         	mov	sp, r7
 8025874: bd80         	pop	{r7, pc}

08025876 <k_thread_resume>:
; {
 8025876: b580         	push	{r7, lr}
 8025878: b082         	sub	sp, #0x8
 802587a: af00         	add	r7, sp, #0x0
 802587c: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 802587e: 6878         	ldr	r0, [r7, #0x4]
 8025880: f7f1 f91a    	bl	0x8016ab8 <z_impl_k_thread_resume> @ imm = #-0xedcc
; }
 8025884: bf00         	nop
 8025886: 3708         	adds	r7, #0x8
 8025888: 46bd         	mov	sp, r7
 802588a: bd80         	pop	{r7, pc}

0802588c <k_sem_init>:
; {
 802588c: b580         	push	{r7, lr}
 802588e: b084         	sub	sp, #0x10
 8025890: af00         	add	r7, sp, #0x0
 8025892: 60f8         	str	r0, [r7, #0xc]
 8025894: 60b9         	str	r1, [r7, #0x8]
 8025896: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 8025898: 687a         	ldr	r2, [r7, #0x4]
 802589a: 68b9         	ldr	r1, [r7, #0x8]
 802589c: 68f8         	ldr	r0, [r7, #0xc]
 802589e: f001 ff3c    	bl	0x802771a <z_impl_k_sem_init> @ imm = #0x1e78
 80258a2: 4603         	mov	r3, r0
; }
 80258a4: 4618         	mov	r0, r3
 80258a6: 3710         	adds	r7, #0x10
 80258a8: 46bd         	mov	sp, r7
 80258aa: bd80         	pop	{r7, pc}

080258ac <k_sem_take>:
; {
 80258ac: b580         	push	{r7, lr}
 80258ae: b084         	sub	sp, #0x10
 80258b0: af00         	add	r7, sp, #0x0
 80258b2: 60f8         	str	r0, [r7, #0xc]
 80258b4: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 80258b8: e9d7 2300    	ldrd	r2, r3, [r7]
 80258bc: 68f8         	ldr	r0, [r7, #0xc]
 80258be: f7ef ff59    	bl	0x8015774 <z_impl_k_sem_take> @ imm = #-0x1014e
 80258c2: 4603         	mov	r3, r0
; }
 80258c4: 4618         	mov	r0, r3
 80258c6: 3710         	adds	r7, #0x10
 80258c8: 46bd         	mov	sp, r7
 80258ca: bd80         	pop	{r7, pc}

080258cc <k_sem_give>:
; {
 80258cc: b580         	push	{r7, lr}
 80258ce: b082         	sub	sp, #0x8
 80258d0: af00         	add	r7, sp, #0x0
 80258d2: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 80258d4: 6878         	ldr	r0, [r7, #0x4]
 80258d6: f7ef febf    	bl	0x8015658 <z_impl_k_sem_give> @ imm = #-0x10282
; }
 80258da: bf00         	nop
 80258dc: 3708         	adds	r7, #0x8
 80258de: 46bd         	mov	sp, r7
 80258e0: bd80         	pop	{r7, pc}

080258e2 <z_log_msg_runtime_create>:
; {
 80258e2: b580         	push	{r7, lr}
 80258e4: b08a         	sub	sp, #0x28
 80258e6: af04         	add	r7, sp, #0x10
 80258e8: 60b9         	str	r1, [r7, #0x8]
 80258ea: 607b         	str	r3, [r7, #0x4]
 80258ec: 4603         	mov	r3, r0
 80258ee: 73fb         	strb	r3, [r7, #0xf]
 80258f0: 4613         	mov	r3, r2
 80258f2: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80258f4: f107 032c    	add.w	r3, r7, #0x2c
 80258f8: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80258fa: 7bba         	ldrb	r2, [r7, #0xe]
 80258fc: 7bf8         	ldrb	r0, [r7, #0xf]
 80258fe: 697b         	ldr	r3, [r7, #0x14]
 8025900: 9303         	str	r3, [sp, #0xc]
 8025902: 6abb         	ldr	r3, [r7, #0x28]
 8025904: 9302         	str	r3, [sp, #0x8]
 8025906: 6a7b         	ldr	r3, [r7, #0x24]
 8025908: 9301         	str	r3, [sp, #0x4]
 802590a: 6a3b         	ldr	r3, [r7, #0x20]
 802590c: 9300         	str	r3, [sp]
 802590e: 687b         	ldr	r3, [r7, #0x4]
 8025910: 68b9         	ldr	r1, [r7, #0x8]
 8025912: f7df f92f    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x20da2
; }
 8025916: bf00         	nop
 8025918: 3718         	adds	r7, #0x18
 802591a: 46bd         	mov	sp, r7
 802591c: bd80         	pop	{r7, pc}

0802591e <z_impl_can_start>:
; {
 802591e: b580         	push	{r7, lr}
 8025920: b084         	sub	sp, #0x10
 8025922: af00         	add	r7, sp, #0x0
 8025924: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8025926: 687b         	ldr	r3, [r7, #0x4]
 8025928: 689b         	ldr	r3, [r3, #0x8]
 802592a: 60fb         	str	r3, [r7, #0xc]
; 	return api->start(dev);
 802592c: 68fb         	ldr	r3, [r7, #0xc]
 802592e: 685b         	ldr	r3, [r3, #0x4]
 8025930: 6878         	ldr	r0, [r7, #0x4]
 8025932: 4798         	blx	r3
 8025934: 4603         	mov	r3, r0
; }
 8025936: 4618         	mov	r0, r3
 8025938: 3710         	adds	r7, #0x10
 802593a: 46bd         	mov	sp, r7
 802593c: bd80         	pop	{r7, pc}

0802593e <can_start>:
; {
 802593e: b580         	push	{r7, lr}
 8025940: b082         	sub	sp, #0x8
 8025942: af00         	add	r7, sp, #0x0
 8025944: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_start(dev);
 8025946: 6878         	ldr	r0, [r7, #0x4]
 8025948: f7ff ffe9    	bl	0x802591e <z_impl_can_start> @ imm = #-0x2e
 802594c: 4603         	mov	r3, r0
; }
 802594e: 4618         	mov	r0, r3
 8025950: 3708         	adds	r7, #0x8
 8025952: 46bd         	mov	sp, r7
 8025954: bd80         	pop	{r7, pc}

08025956 <can_send>:
; {
 8025956: b580         	push	{r7, lr}
 8025958: b086         	sub	sp, #0x18
 802595a: af02         	add	r7, sp, #0x8
 802595c: 60f8         	str	r0, [r7, #0xc]
 802595e: 60b9         	str	r1, [r7, #0x8]
 8025960: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_can_send(dev, frame, timeout, callback, user_data);
 8025964: 69fb         	ldr	r3, [r7, #0x1c]
 8025966: 9301         	str	r3, [sp, #0x4]
 8025968: 69bb         	ldr	r3, [r7, #0x18]
 802596a: 9300         	str	r3, [sp]
 802596c: e9d7 2300    	ldrd	r2, r3, [r7]
 8025970: 68b9         	ldr	r1, [r7, #0x8]
 8025972: 68f8         	ldr	r0, [r7, #0xc]
 8025974: f7e1 fe04    	bl	0x8007580 <z_impl_can_send> @ imm = #-0x1e3f8
 8025978: 4603         	mov	r3, r0
; }
 802597a: 4618         	mov	r0, r3
 802597c: 3710         	adds	r7, #0x10
 802597e: 46bd         	mov	sp, r7
 8025980: bd80         	pop	{r7, pc}

08025982 <z_impl_pid_calc>:
; static inline void z_impl_pid_calc(const struct device *dev) {
 8025982: b580         	push	{r7, lr}
 8025984: b084         	sub	sp, #0x10
 8025986: af00         	add	r7, sp, #0x0
 8025988: 6078         	str	r0, [r7, #0x4]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 802598a: 687b         	ldr	r3, [r7, #0x4]
 802598c: 689b         	ldr	r3, [r3, #0x8]
 802598e: 60fb         	str	r3, [r7, #0xc]
;     if (api->pid_calc != NULL) {
 8025990: 68fb         	ldr	r3, [r7, #0xc]
 8025992: 681b         	ldr	r3, [r3]
 8025994: 2b00         	cmp	r3, #0x0
 8025996: d003         	beq	0x80259a0 <z_impl_pid_calc+0x1e> @ imm = #0x6
;         api->pid_calc(dev);
 8025998: 68fb         	ldr	r3, [r7, #0xc]
 802599a: 681b         	ldr	r3, [r3]
 802599c: 6878         	ldr	r0, [r7, #0x4]
 802599e: 4798         	blx	r3
; }
 80259a0: bf00         	nop
 80259a2: 3710         	adds	r7, #0x10
 80259a4: 46bd         	mov	sp, r7
 80259a6: bd80         	pop	{r7, pc}

080259a8 <z_impl_pid_reg_input>:
; static inline void z_impl_pid_reg_input(const struct device *dev, float *curr, float *ref) {
 80259a8: b580         	push	{r7, lr}
 80259aa: b086         	sub	sp, #0x18
 80259ac: af00         	add	r7, sp, #0x0
 80259ae: 60f8         	str	r0, [r7, #0xc]
 80259b0: 60b9         	str	r1, [r7, #0x8]
 80259b2: 607a         	str	r2, [r7, #0x4]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 80259b4: 68fb         	ldr	r3, [r7, #0xc]
 80259b6: 689b         	ldr	r3, [r3, #0x8]
 80259b8: 617b         	str	r3, [r7, #0x14]
;     if (api->pid_reg_input != NULL) {
 80259ba: 697b         	ldr	r3, [r7, #0x14]
 80259bc: 685b         	ldr	r3, [r3, #0x4]
 80259be: 2b00         	cmp	r3, #0x0
 80259c0: d005         	beq	0x80259ce <z_impl_pid_reg_input+0x26> @ imm = #0xa
;         api->pid_reg_input(dev, curr, ref);
 80259c2: 697b         	ldr	r3, [r7, #0x14]
 80259c4: 685b         	ldr	r3, [r3, #0x4]
 80259c6: 687a         	ldr	r2, [r7, #0x4]
 80259c8: 68b9         	ldr	r1, [r7, #0x8]
 80259ca: 68f8         	ldr	r0, [r7, #0xc]
 80259cc: 4798         	blx	r3
; }
 80259ce: bf00         	nop
 80259d0: 3718         	adds	r7, #0x18
 80259d2: 46bd         	mov	sp, r7
 80259d4: bd80         	pop	{r7, pc}

080259d6 <z_impl_pid_reg_time>:
;                                        uint32_t *prev_time) {
 80259d6: b580         	push	{r7, lr}
 80259d8: b086         	sub	sp, #0x18
 80259da: af00         	add	r7, sp, #0x0
 80259dc: 60f8         	str	r0, [r7, #0xc]
 80259de: 60b9         	str	r1, [r7, #0x8]
 80259e0: 607a         	str	r2, [r7, #0x4]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 80259e2: 68fb         	ldr	r3, [r7, #0xc]
 80259e4: 689b         	ldr	r3, [r3, #0x8]
 80259e6: 617b         	str	r3, [r7, #0x14]
;     if (api->pid_reg_time != NULL) {
 80259e8: 697b         	ldr	r3, [r7, #0x14]
 80259ea: 68db         	ldr	r3, [r3, #0xc]
 80259ec: 2b00         	cmp	r3, #0x0
 80259ee: d005         	beq	0x80259fc <z_impl_pid_reg_time+0x26> @ imm = #0xa
;         api->pid_reg_time(dev, curr_time, prev_time);
 80259f0: 697b         	ldr	r3, [r7, #0x14]
 80259f2: 68db         	ldr	r3, [r3, #0xc]
 80259f4: 687a         	ldr	r2, [r7, #0x4]
 80259f6: 68b9         	ldr	r1, [r7, #0x8]
 80259f8: 68f8         	ldr	r0, [r7, #0xc]
 80259fa: 4798         	blx	r3
; }
 80259fc: bf00         	nop
 80259fe: 3718         	adds	r7, #0x18
 8025a00: 46bd         	mov	sp, r7
 8025a02: bd80         	pop	{r7, pc}

08025a04 <z_impl_pid_reg_output>:
; static inline void z_impl_pid_reg_output(const struct device *dev, float *output) {
 8025a04: b580         	push	{r7, lr}
 8025a06: b084         	sub	sp, #0x10
 8025a08: af00         	add	r7, sp, #0x0
 8025a0a: 6078         	str	r0, [r7, #0x4]
 8025a0c: 6039         	str	r1, [r7]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 8025a0e: 687b         	ldr	r3, [r7, #0x4]
 8025a10: 689b         	ldr	r3, [r3, #0x8]
 8025a12: 60fb         	str	r3, [r7, #0xc]
;     if (api->pid_reg_output != NULL) {
 8025a14: 68fb         	ldr	r3, [r7, #0xc]
 8025a16: 691b         	ldr	r3, [r3, #0x10]
 8025a18: 2b00         	cmp	r3, #0x0
 8025a1a: d004         	beq	0x8025a26 <z_impl_pid_reg_output+0x22> @ imm = #0x8
;         api->pid_reg_output(dev, output);
 8025a1c: 68fb         	ldr	r3, [r7, #0xc]
 8025a1e: 691b         	ldr	r3, [r3, #0x10]
 8025a20: 6839         	ldr	r1, [r7]
 8025a22: 6878         	ldr	r0, [r7, #0x4]
 8025a24: 4798         	blx	r3
; }
 8025a26: bf00         	nop
 8025a28: 3710         	adds	r7, #0x10
 8025a2a: 46bd         	mov	sp, r7
 8025a2c: bd80         	pop	{r7, pc}

08025a2e <pid_calc>:
; {
 8025a2e: b580         	push	{r7, lr}
 8025a30: b082         	sub	sp, #0x8
 8025a32: af00         	add	r7, sp, #0x0
 8025a34: 6078         	str	r0, [r7, #0x4]
; 	z_impl_pid_calc(dev);
 8025a36: 6878         	ldr	r0, [r7, #0x4]
 8025a38: f7ff ffa3    	bl	0x8025982 <z_impl_pid_calc> @ imm = #-0xba
; }
 8025a3c: bf00         	nop
 8025a3e: 3708         	adds	r7, #0x8
 8025a40: 46bd         	mov	sp, r7
 8025a42: bd80         	pop	{r7, pc}

08025a44 <pid_reg_input>:
; {
 8025a44: b580         	push	{r7, lr}
 8025a46: b084         	sub	sp, #0x10
 8025a48: af00         	add	r7, sp, #0x0
 8025a4a: 60f8         	str	r0, [r7, #0xc]
 8025a4c: 60b9         	str	r1, [r7, #0x8]
 8025a4e: 607a         	str	r2, [r7, #0x4]
; 	z_impl_pid_reg_input(dev, curr, ref);
 8025a50: 687a         	ldr	r2, [r7, #0x4]
 8025a52: 68b9         	ldr	r1, [r7, #0x8]
 8025a54: 68f8         	ldr	r0, [r7, #0xc]
 8025a56: f7ff ffa7    	bl	0x80259a8 <z_impl_pid_reg_input> @ imm = #-0xb2
; }
 8025a5a: bf00         	nop
 8025a5c: 3710         	adds	r7, #0x10
 8025a5e: 46bd         	mov	sp, r7
 8025a60: bd80         	pop	{r7, pc}

08025a62 <pid_reg_time>:
; {
 8025a62: b580         	push	{r7, lr}
 8025a64: b084         	sub	sp, #0x10
 8025a66: af00         	add	r7, sp, #0x0
 8025a68: 60f8         	str	r0, [r7, #0xc]
 8025a6a: 60b9         	str	r1, [r7, #0x8]
 8025a6c: 607a         	str	r2, [r7, #0x4]
; 	z_impl_pid_reg_time(dev, curr_time, prev_time);
 8025a6e: 687a         	ldr	r2, [r7, #0x4]
 8025a70: 68b9         	ldr	r1, [r7, #0x8]
 8025a72: 68f8         	ldr	r0, [r7, #0xc]
 8025a74: f7ff ffaf    	bl	0x80259d6 <z_impl_pid_reg_time> @ imm = #-0xa2
; }
 8025a78: bf00         	nop
 8025a7a: 3710         	adds	r7, #0x10
 8025a7c: 46bd         	mov	sp, r7
 8025a7e: bd80         	pop	{r7, pc}

08025a80 <pid_reg_output>:
; {
 8025a80: b580         	push	{r7, lr}
 8025a82: b082         	sub	sp, #0x8
 8025a84: af00         	add	r7, sp, #0x0
 8025a86: 6078         	str	r0, [r7, #0x4]
 8025a88: 6039         	str	r1, [r7]
; 	z_impl_pid_reg_output(dev, output);
 8025a8a: 6839         	ldr	r1, [r7]
 8025a8c: 6878         	ldr	r0, [r7, #0x4]
 8025a8e: f7ff ffb9    	bl	0x8025a04 <z_impl_pid_reg_output> @ imm = #-0x8e
; }
 8025a92: bf00         	nop
 8025a94: 3708         	adds	r7, #0x8
 8025a96: 46bd         	mov	sp, r7
 8025a98: bd80         	pop	{r7, pc}

08025a9a <frames_id>:
; {
 8025a9a: b480         	push	{r7}
 8025a9c: b083         	sub	sp, #0xc
 8025a9e: af00         	add	r7, sp, #0x0
 8025aa0: 6078         	str	r0, [r7, #0x4]
; 	if (tx_id == 0x200) {
 8025aa2: 687b         	ldr	r3, [r7, #0x4]
 8025aa4: f5b3 7f00    	cmp.w	r3, #0x200
 8025aa8: d101         	bne	0x8025aae <frames_id+0x14> @ imm = #0x2
; 		return 0;
 8025aaa: 2300         	movs	r3, #0x0
 8025aac: e01c         	b	0x8025ae8 <frames_id+0x4e> @ imm = #0x38
; 	} else if (tx_id == 0x1FF) {
 8025aae: 687b         	ldr	r3, [r7, #0x4]
 8025ab0: f240 12ff    	movw	r2, #0x1ff
 8025ab4: 4293         	cmp	r3, r2
 8025ab6: d101         	bne	0x8025abc <frames_id+0x22> @ imm = #0x2
; 		return 1;
 8025ab8: 2301         	movs	r3, #0x1
 8025aba: e015         	b	0x8025ae8 <frames_id+0x4e> @ imm = #0x2a
; 	} else if (tx_id == 0x1FE) {
 8025abc: 687b         	ldr	r3, [r7, #0x4]
 8025abe: f5b3 7fff    	cmp.w	r3, #0x1fe
 8025ac2: d101         	bne	0x8025ac8 <frames_id+0x2e> @ imm = #0x2
; 		return 2;
 8025ac4: 2302         	movs	r3, #0x2
 8025ac6: e00f         	b	0x8025ae8 <frames_id+0x4e> @ imm = #0x1e
; 	} else if (tx_id == 0x2FE) {
 8025ac8: 687b         	ldr	r3, [r7, #0x4]
 8025aca: f240 22fe    	movw	r2, #0x2fe
 8025ace: 4293         	cmp	r3, r2
 8025ad0: d101         	bne	0x8025ad6 <frames_id+0x3c> @ imm = #0x2
; 		return 3;
 8025ad2: 2303         	movs	r3, #0x3
 8025ad4: e008         	b	0x8025ae8 <frames_id+0x4e> @ imm = #0x10
; 	} else if (tx_id == 0x2FF) {
 8025ad6: 687b         	ldr	r3, [r7, #0x4]
 8025ad8: f240 22ff    	movw	r2, #0x2ff
 8025adc: 4293         	cmp	r3, r2
 8025ade: d101         	bne	0x8025ae4 <frames_id+0x4a> @ imm = #0x2
; 		return 4;
 8025ae0: 2304         	movs	r3, #0x4
 8025ae2: e001         	b	0x8025ae8 <frames_id+0x4e> @ imm = #0x2
; 	return -1; // Return a default value if no match is found
 8025ae4: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 8025ae8: 4618         	mov	r0, r3
 8025aea: 370c         	adds	r7, #0xc
 8025aec: 46bd         	mov	sp, r7
 8025aee: f85d 7b04    	ldr	r7, [sp], #4
 8025af2: 4770         	bx	lr

08025af4 <txframe_id>:
; {
 8025af4: b480         	push	{r7}
 8025af6: b083         	sub	sp, #0xc
 8025af8: af00         	add	r7, sp, #0x0
 8025afa: 6078         	str	r0, [r7, #0x4]
; 	if (frames_id == 0) {
 8025afc: 687b         	ldr	r3, [r7, #0x4]
 8025afe: 2b00         	cmp	r3, #0x0
 8025b00: d102         	bne	0x8025b08 <txframe_id+0x14> @ imm = #0x4
; 		return 0x200;
 8025b02: f44f 7300    	mov.w	r3, #0x200
 8025b06: e019         	b	0x8025b3c <txframe_id+0x48> @ imm = #0x32
; 	} else if (frames_id == 1) {
 8025b08: 687b         	ldr	r3, [r7, #0x4]
 8025b0a: 2b01         	cmp	r3, #0x1
 8025b0c: d102         	bne	0x8025b14 <txframe_id+0x20> @ imm = #0x4
; 		return 0x1FF;
 8025b0e: f240 13ff    	movw	r3, #0x1ff
 8025b12: e013         	b	0x8025b3c <txframe_id+0x48> @ imm = #0x26
; 	} else if (frames_id == 2) {
 8025b14: 687b         	ldr	r3, [r7, #0x4]
 8025b16: 2b02         	cmp	r3, #0x2
 8025b18: d102         	bne	0x8025b20 <txframe_id+0x2c> @ imm = #0x4
; 		return 0x1FE;
 8025b1a: f44f 73ff    	mov.w	r3, #0x1fe
 8025b1e: e00d         	b	0x8025b3c <txframe_id+0x48> @ imm = #0x1a
; 	} else if (frames_id == 3) {
 8025b20: 687b         	ldr	r3, [r7, #0x4]
 8025b22: 2b03         	cmp	r3, #0x3
 8025b24: d102         	bne	0x8025b2c <txframe_id+0x38> @ imm = #0x4
; 		return 0x2FE;
 8025b26: f240 23fe    	movw	r3, #0x2fe
 8025b2a: e007         	b	0x8025b3c <txframe_id+0x48> @ imm = #0xe
; 	} else if (frames_id == 4) {
 8025b2c: 687b         	ldr	r3, [r7, #0x4]
 8025b2e: 2b04         	cmp	r3, #0x4
 8025b30: d102         	bne	0x8025b38 <txframe_id+0x44> @ imm = #0x4
; 		return 0x2FF;
 8025b32: f240 23ff    	movw	r3, #0x2ff
 8025b36: e001         	b	0x8025b3c <txframe_id+0x48> @ imm = #0x2
; 	return -1;
 8025b38: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 8025b3c: 4618         	mov	r0, r3
 8025b3e: 370c         	adds	r7, #0xc
 8025b40: 46bd         	mov	sp, r7
 8025b42: f85d 7b04    	ldr	r7, [sp], #4
 8025b46: 4770         	bx	lr

08025b48 <motor_id>:
; {
 8025b48: b480         	push	{r7}
 8025b4a: b085         	sub	sp, #0x14
 8025b4c: af00         	add	r7, sp, #0x0
 8025b4e: 6078         	str	r0, [r7, #0x4]
; 	const struct dji_motor_config *cfg = dev->config;
 8025b50: 687b         	ldr	r3, [r7, #0x4]
 8025b52: 685b         	ldr	r3, [r3, #0x4]
 8025b54: 60fb         	str	r3, [r7, #0xc]
; 	return cfg->common.id - 1;
 8025b56: 68fb         	ldr	r3, [r7, #0xc]
 8025b58: 791b         	ldrb	r3, [r3, #0x4]
 8025b5a: 3b01         	subs	r3, #0x1
 8025b5c: b29b         	uxth	r3, r3
; }
 8025b5e: 4618         	mov	r0, r3
 8025b60: 3714         	adds	r7, #0x14
 8025b62: 46bd         	mov	sp, r7
 8025b64: f85d 7b04    	ldr	r7, [sp], #4
 8025b68: 4770         	bx	lr

08025b6a <dji_get_angle>:
; {
 8025b6a: b480         	push	{r7}
 8025b6c: b085         	sub	sp, #0x14
 8025b6e: af00         	add	r7, sp, #0x0
 8025b70: 6078         	str	r0, [r7, #0x4]
; 	struct dji_motor_data *data = dev->data;
 8025b72: 687b         	ldr	r3, [r7, #0x4]
 8025b74: 691b         	ldr	r3, [r3, #0x10]
 8025b76: 60fb         	str	r3, [r7, #0xc]
; 	return data->common.angle;
 8025b78: 68fb         	ldr	r3, [r7, #0xc]
 8025b7a: 681b         	ldr	r3, [r3]
 8025b7c: ee07 3a90    	<unknown>
; }
 8025b80: eeb0 0a67    	<unknown>
 8025b84: 3714         	adds	r7, #0x14
 8025b86: 46bd         	mov	sp, r7
 8025b88: f85d 7b04    	ldr	r7, [sp], #4
 8025b8c: 4770         	bx	lr

08025b8e <dji_get_speed>:
; {
 8025b8e: b480         	push	{r7}
 8025b90: b085         	sub	sp, #0x14
 8025b92: af00         	add	r7, sp, #0x0
 8025b94: 6078         	str	r0, [r7, #0x4]
; 	struct dji_motor_data *data = dev->data;
 8025b96: 687b         	ldr	r3, [r7, #0x4]
 8025b98: 691b         	ldr	r3, [r3, #0x10]
 8025b9a: 60fb         	str	r3, [r7, #0xc]
; 	return data->common.rpm;
 8025b9c: 68fb         	ldr	r3, [r7, #0xc]
 8025b9e: 685b         	ldr	r3, [r3, #0x4]
 8025ba0: ee07 3a90    	<unknown>
; }
 8025ba4: eeb0 0a67    	<unknown>
 8025ba8: 3714         	adds	r7, #0x14
 8025baa: 46bd         	mov	sp, r7
 8025bac: f85d 7b04    	ldr	r7, [sp], #4
 8025bb0: 4770         	bx	lr

08025bb2 <dji_get_torque>:
; {
 8025bb2: b480         	push	{r7}
 8025bb4: b085         	sub	sp, #0x14
 8025bb6: af00         	add	r7, sp, #0x0
 8025bb8: 6078         	str	r0, [r7, #0x4]
; 	struct dji_motor_data *data = dev->data;
 8025bba: 687b         	ldr	r3, [r7, #0x4]
 8025bbc: 691b         	ldr	r3, [r3, #0x10]
 8025bbe: 60fb         	str	r3, [r7, #0xc]
; 	return data->common.torque;
 8025bc0: 68fb         	ldr	r3, [r7, #0xc]
 8025bc2: 689b         	ldr	r3, [r3, #0x8]
 8025bc4: ee07 3a90    	<unknown>
; }
 8025bc8: eeb0 0a67    	<unknown>
 8025bcc: 3714         	adds	r7, #0x14
 8025bce: 46bd         	mov	sp, r7
 8025bd0: f85d 7b04    	ldr	r7, [sp], #4
 8025bd4: 4770         	bx	lr

08025bd6 <can_tx_callback>:
; {
 8025bd6: b580         	push	{r7, lr}
 8025bd8: b086         	sub	sp, #0x18
 8025bda: af00         	add	r7, sp, #0x0
 8025bdc: 60f8         	str	r0, [r7, #0xc]
 8025bde: 60b9         	str	r1, [r7, #0x8]
 8025be0: 607a         	str	r2, [r7, #0x4]
; 	struct k_sem *queue_sem = user_data;
 8025be2: 687b         	ldr	r3, [r7, #0x4]
 8025be4: 617b         	str	r3, [r7, #0x14]
; 	k_sem_give(queue_sem);
 8025be6: 6978         	ldr	r0, [r7, #0x14]
 8025be8: f7ff fe70    	bl	0x80258cc <k_sem_give>  @ imm = #-0x320
; }
 8025bec: bf00         	nop
 8025bee: 3718         	adds	r7, #0x18
 8025bf0: 46bd         	mov	sp, r7
 8025bf2: bd80         	pop	{r7, pc}

08025bf4 <delta_degree>:
; {
 8025bf4: b480         	push	{r7}
 8025bf6: b085         	sub	sp, #0x14
 8025bf8: af00         	add	r7, sp, #0x0
 8025bfa: 4603         	mov	r3, r0
 8025bfc: 460a         	mov	r2, r1
 8025bfe: 80fb         	strh	r3, [r7, #0x6]
 8025c00: 4613         	mov	r3, r2
 8025c02: 80bb         	strh	r3, [r7, #0x4]
; 	int delta = angle - prev_angle;
 8025c04: 88fa         	ldrh	r2, [r7, #0x6]
 8025c06: 88bb         	ldrh	r3, [r7, #0x4]
 8025c08: 1ad3         	subs	r3, r2, r3
 8025c0a: 60fb         	str	r3, [r7, #0xc]
; 	if (angle < 2048 && prev_angle > 6144) {
 8025c0c: 88fb         	ldrh	r3, [r7, #0x6]
 8025c0e: f5b3 6f00    	cmp.w	r3, #0x800
 8025c12: d208         	bhs	0x8025c26 <delta_degree+0x32> @ imm = #0x10
 8025c14: 88bb         	ldrh	r3, [r7, #0x4]
 8025c16: f5b3 5fc0    	cmp.w	r3, #0x1800
 8025c1a: d904         	bls	0x8025c26 <delta_degree+0x32> @ imm = #0x8
; 		delta += 8192;
 8025c1c: 68fb         	ldr	r3, [r7, #0xc]
 8025c1e: f503 5300    	add.w	r3, r3, #0x2000
 8025c22: 60fb         	str	r3, [r7, #0xc]
 8025c24: e00b         	b	0x8025c3e <delta_degree+0x4a> @ imm = #0x16
; 	} else if (angle > 6144 && prev_angle < 2048) {
 8025c26: 88fb         	ldrh	r3, [r7, #0x6]
 8025c28: f5b3 5fc0    	cmp.w	r3, #0x1800
 8025c2c: d907         	bls	0x8025c3e <delta_degree+0x4a> @ imm = #0xe
 8025c2e: 88bb         	ldrh	r3, [r7, #0x4]
 8025c30: f5b3 6f00    	cmp.w	r3, #0x800
 8025c34: d203         	bhs	0x8025c3e <delta_degree+0x4a> @ imm = #0x6
; 		delta -= 8192;
 8025c36: 68fb         	ldr	r3, [r7, #0xc]
 8025c38: f5a3 5300    	sub.w	r3, r3, #0x2000
 8025c3c: 60fb         	str	r3, [r7, #0xc]
; 	return delta;
 8025c3e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8025c40: 4618         	mov	r0, r3
 8025c42: 3714         	adds	r7, #0x14
 8025c44: 46bd         	mov	sp, r7
 8025c46: f85d 7b04    	ldr	r7, [sp], #4
 8025c4a: 4770         	bx	lr

08025c4c <can_pack_add>:
; {
 8025c4c: b580         	push	{r7, lr}
 8025c4e: b086         	sub	sp, #0x18
 8025c50: af00         	add	r7, sp, #0x0
 8025c52: 60f8         	str	r0, [r7, #0xc]
 8025c54: 60b9         	str	r1, [r7, #0x8]
 8025c56: 4613         	mov	r3, r2
 8025c58: 71fb         	strb	r3, [r7, #0x7]
; 	struct dji_motor_data *data_temp = motor_dev->data;
 8025c5a: 68bb         	ldr	r3, [r7, #0x8]
 8025c5c: 691b         	ldr	r3, [r3, #0x10]
 8025c5e: 617b         	str	r3, [r7, #0x14]
; 	int16_t value = to16t(data_temp->target_current);
 8025c60: 697b         	ldr	r3, [r7, #0x14]
 8025c62: edd3 7a13    	<unknown>
 8025c66: eeb0 0a67    	<unknown>
 8025c6a: f7eb fe53    	bl	0x8011914 <to16t>       @ imm = #-0x1435a
 8025c6e: 4603         	mov	r3, r0
 8025c70: 827b         	strh	r3, [r7, #0x12]
; 	data[num * 2] = HIGH_BYTE(value);
 8025c72: f9b7 3012    	ldrsh.w	r3, [r7, #0x12]
 8025c76: 121b         	asrs	r3, r3, #0x8
 8025c78: b21a         	sxth	r2, r3
 8025c7a: 79fb         	ldrb	r3, [r7, #0x7]
 8025c7c: 005b         	lsls	r3, r3, #0x1
 8025c7e: 4619         	mov	r1, r3
 8025c80: 68fb         	ldr	r3, [r7, #0xc]
 8025c82: 440b         	add	r3, r1
 8025c84: b2d2         	uxtb	r2, r2
 8025c86: 701a         	strb	r2, [r3]
; 	data[num * 2 + 1] = LOW_BYTE(value);
 8025c88: 79fb         	ldrb	r3, [r7, #0x7]
 8025c8a: 005b         	lsls	r3, r3, #0x1
 8025c8c: 3301         	adds	r3, #0x1
 8025c8e: 68fa         	ldr	r2, [r7, #0xc]
 8025c90: 4413         	add	r3, r2
 8025c92: 8a7a         	ldrh	r2, [r7, #0x12]
 8025c94: b2d2         	uxtb	r2, r2
 8025c96: 701a         	strb	r2, [r3]
; }
 8025c98: bf00         	nop
 8025c9a: 3718         	adds	r7, #0x18
 8025c9c: 46bd         	mov	sp, r7
 8025c9e: bd80         	pop	{r7, pc}

08025ca0 <single_pid_reg_input>:
; static void single_pid_reg_input(const struct device *pid_dev, float *curr, float *ref) {
 8025ca0: b480         	push	{r7}
 8025ca2: b087         	sub	sp, #0x1c
 8025ca4: af00         	add	r7, sp, #0x0
 8025ca6: 60f8         	str	r0, [r7, #0xc]
 8025ca8: 60b9         	str	r1, [r7, #0x8]
 8025caa: 607a         	str	r2, [r7, #0x4]
;     struct pid_single_data *pid_data = pid_dev->data;
 8025cac: 68fb         	ldr	r3, [r7, #0xc]
 8025cae: 691b         	ldr	r3, [r3, #0x10]
 8025cb0: 617b         	str	r3, [r7, #0x14]
;     pid_data->curr                   = curr;
 8025cb2: 697b         	ldr	r3, [r7, #0x14]
 8025cb4: 68ba         	ldr	r2, [r7, #0x8]
 8025cb6: 605a         	str	r2, [r3, #0x4]
;     pid_data->ref                    = ref;
 8025cb8: 697b         	ldr	r3, [r7, #0x14]
 8025cba: 687a         	ldr	r2, [r7, #0x4]
 8025cbc: 601a         	str	r2, [r3]
;     return;
 8025cbe: bf00         	nop
; }
 8025cc0: 371c         	adds	r7, #0x1c
 8025cc2: 46bd         	mov	sp, r7
 8025cc4: f85d 7b04    	ldr	r7, [sp], #4
 8025cc8: 4770         	bx	lr

08025cca <single_pid_reg_time>:
;                                 uint32_t *prev_time) {
 8025cca: b480         	push	{r7}
 8025ccc: b087         	sub	sp, #0x1c
 8025cce: af00         	add	r7, sp, #0x0
 8025cd0: 60f8         	str	r0, [r7, #0xc]
 8025cd2: 60b9         	str	r1, [r7, #0x8]
 8025cd4: 607a         	str	r2, [r7, #0x4]
;     struct pid_single_data *pid_data = pid_dev->data;
 8025cd6: 68fb         	ldr	r3, [r7, #0xc]
 8025cd8: 691b         	ldr	r3, [r3, #0x10]
 8025cda: 617b         	str	r3, [r7, #0x14]
;     pid_data->curr_time              = curr_time;
 8025cdc: 697b         	ldr	r3, [r7, #0x14]
 8025cde: 68ba         	ldr	r2, [r7, #0x8]
 8025ce0: 615a         	str	r2, [r3, #0x14]
;     pid_data->prev_time              = prev_time;
 8025ce2: 697b         	ldr	r3, [r7, #0x14]
 8025ce4: 687a         	ldr	r2, [r7, #0x4]
 8025ce6: 619a         	str	r2, [r3, #0x18]
;     return;
 8025ce8: bf00         	nop
; }
 8025cea: 371c         	adds	r7, #0x1c
 8025cec: 46bd         	mov	sp, r7
 8025cee: f85d 7b04    	ldr	r7, [sp], #4
 8025cf2: 4770         	bx	lr

08025cf4 <single_pid_reg_output>:
; static void single_pid_reg_output(const struct device *pid_dev, float *output) {
 8025cf4: b480         	push	{r7}
 8025cf6: b085         	sub	sp, #0x14
 8025cf8: af00         	add	r7, sp, #0x0
 8025cfa: 6078         	str	r0, [r7, #0x4]
 8025cfc: 6039         	str	r1, [r7]
;     struct pid_single_data *pid_data = pid_dev->data;
 8025cfe: 687b         	ldr	r3, [r7, #0x4]
 8025d00: 691b         	ldr	r3, [r3, #0x10]
 8025d02: 60fb         	str	r3, [r7, #0xc]
;     pid_data->output                 = output;
 8025d04: 68fb         	ldr	r3, [r7, #0xc]
 8025d06: 683a         	ldr	r2, [r7]
 8025d08: 61da         	str	r2, [r3, #0x1c]
;     return;
 8025d0a: bf00         	nop
; }
 8025d0c: 3714         	adds	r7, #0x14
 8025d0e: 46bd         	mov	sp, r7
 8025d10: f85d 7b04    	ldr	r7, [sp], #4
 8025d14: 4770         	bx	lr

08025d16 <device_is_ready>:
; {
 8025d16: b580         	push	{r7, lr}
 8025d18: b082         	sub	sp, #0x8
 8025d1a: af00         	add	r7, sp, #0x0
 8025d1c: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8025d1e: 6878         	ldr	r0, [r7, #0x4]
 8025d20: f000 fb3d    	bl	0x802639e <z_impl_device_is_ready> @ imm = #0x67a
 8025d24: 4603         	mov	r3, r0
; }
 8025d26: 4618         	mov	r0, r3
 8025d28: 3708         	adds	r7, #0x8
 8025d2a: 46bd         	mov	sp, r7
 8025d2c: bd80         	pop	{r7, pc}

08025d2e <z_impl_uart_configure>:
; {
 8025d2e: b580         	push	{r7, lr}
 8025d30: b084         	sub	sp, #0x10
 8025d32: af00         	add	r7, sp, #0x0
 8025d34: 6078         	str	r0, [r7, #0x4]
 8025d36: 6039         	str	r1, [r7]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8025d38: 687b         	ldr	r3, [r7, #0x4]
 8025d3a: 689b         	ldr	r3, [r3, #0x8]
 8025d3c: 60fb         	str	r3, [r7, #0xc]
; 	if (api->configure == NULL) {
 8025d3e: 68fb         	ldr	r3, [r7, #0xc]
 8025d40: 6a5b         	ldr	r3, [r3, #0x24]
 8025d42: 2b00         	cmp	r3, #0x0
 8025d44: d102         	bne	0x8025d4c <z_impl_uart_configure+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 8025d46: f06f 0357    	mvn	r3, #0x57
 8025d4a: e005         	b	0x8025d58 <z_impl_uart_configure+0x2a> @ imm = #0xa
; 	return api->configure(dev, cfg);
 8025d4c: 68fb         	ldr	r3, [r7, #0xc]
 8025d4e: 6a5b         	ldr	r3, [r3, #0x24]
 8025d50: 6839         	ldr	r1, [r7]
 8025d52: 6878         	ldr	r0, [r7, #0x4]
 8025d54: 4798         	blx	r3
 8025d56: 4603         	mov	r3, r0
; }
 8025d58: 4618         	mov	r0, r3
 8025d5a: 3710         	adds	r7, #0x10
 8025d5c: 46bd         	mov	sp, r7
 8025d5e: bd80         	pop	{r7, pc}

08025d60 <uart_callback_set>:
; {
 8025d60: b580         	push	{r7, lr}
 8025d62: b086         	sub	sp, #0x18
 8025d64: af00         	add	r7, sp, #0x0
 8025d66: 60f8         	str	r0, [r7, #0xc]
 8025d68: 60b9         	str	r1, [r7, #0x8]
 8025d6a: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8025d6c: 68fb         	ldr	r3, [r7, #0xc]
 8025d6e: 689b         	ldr	r3, [r3, #0x8]
 8025d70: 617b         	str	r3, [r7, #0x14]
; 	if (api->callback_set == NULL) {
 8025d72: 697b         	ldr	r3, [r7, #0x14]
 8025d74: 681b         	ldr	r3, [r3]
 8025d76: 2b00         	cmp	r3, #0x0
 8025d78: d102         	bne	0x8025d80 <uart_callback_set+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8025d7a: f06f 0357    	mvn	r3, #0x57
 8025d7e: e006         	b	0x8025d8e <uart_callback_set+0x2e> @ imm = #0xc
; 	return api->callback_set(dev, callback, user_data);
 8025d80: 697b         	ldr	r3, [r7, #0x14]
 8025d82: 681b         	ldr	r3, [r3]
 8025d84: 687a         	ldr	r2, [r7, #0x4]
 8025d86: 68b9         	ldr	r1, [r7, #0x8]
 8025d88: 68f8         	ldr	r0, [r7, #0xc]
 8025d8a: 4798         	blx	r3
 8025d8c: 4603         	mov	r3, r0
; }
 8025d8e: 4618         	mov	r0, r3
 8025d90: 3718         	adds	r7, #0x18
 8025d92: 46bd         	mov	sp, r7
 8025d94: bd80         	pop	{r7, pc}

08025d96 <z_impl_uart_rx_enable>:
; {
 8025d96: b590         	push	{r4, r7, lr}
 8025d98: b087         	sub	sp, #0x1c
 8025d9a: af00         	add	r7, sp, #0x0
 8025d9c: 60f8         	str	r0, [r7, #0xc]
 8025d9e: 60b9         	str	r1, [r7, #0x8]
 8025da0: 607a         	str	r2, [r7, #0x4]
 8025da2: 603b         	str	r3, [r7]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8025da4: 68fb         	ldr	r3, [r7, #0xc]
 8025da6: 689b         	ldr	r3, [r3, #0x8]
 8025da8: 617b         	str	r3, [r7, #0x14]
; 	return api->rx_enable(dev, buf, len, timeout);
 8025daa: 697b         	ldr	r3, [r7, #0x14]
 8025dac: 68dc         	ldr	r4, [r3, #0xc]
 8025dae: 683b         	ldr	r3, [r7]
 8025db0: 687a         	ldr	r2, [r7, #0x4]
 8025db2: 68b9         	ldr	r1, [r7, #0x8]
 8025db4: 68f8         	ldr	r0, [r7, #0xc]
 8025db6: 47a0         	blx	r4
 8025db8: 4603         	mov	r3, r0
; }
 8025dba: 4618         	mov	r0, r3
 8025dbc: 371c         	adds	r7, #0x1c
 8025dbe: 46bd         	mov	sp, r7
 8025dc0: bd90         	pop	{r4, r7, pc}

08025dc2 <uart_rx_buf_rsp>:
; {
 8025dc2: b580         	push	{r7, lr}
 8025dc4: b086         	sub	sp, #0x18
 8025dc6: af00         	add	r7, sp, #0x0
 8025dc8: 60f8         	str	r0, [r7, #0xc]
 8025dca: 60b9         	str	r1, [r7, #0x8]
 8025dcc: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8025dce: 68fb         	ldr	r3, [r7, #0xc]
 8025dd0: 689b         	ldr	r3, [r3, #0x8]
 8025dd2: 617b         	str	r3, [r7, #0x14]
; 	return api->rx_buf_rsp(dev, buf, len);
 8025dd4: 697b         	ldr	r3, [r7, #0x14]
 8025dd6: 691b         	ldr	r3, [r3, #0x10]
 8025dd8: 687a         	ldr	r2, [r7, #0x4]
 8025dda: 68b9         	ldr	r1, [r7, #0x8]
 8025ddc: 68f8         	ldr	r0, [r7, #0xc]
 8025dde: 4798         	blx	r3
 8025de0: 4603         	mov	r3, r0
; }
 8025de2: 4618         	mov	r0, r3
 8025de4: 3718         	adds	r7, #0x18
 8025de6: 46bd         	mov	sp, r7
 8025de8: bd80         	pop	{r7, pc}

08025dea <z_impl_uart_rx_disable>:
; {
 8025dea: b580         	push	{r7, lr}
 8025dec: b084         	sub	sp, #0x10
 8025dee: af00         	add	r7, sp, #0x0
 8025df0: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8025df2: 687b         	ldr	r3, [r7, #0x4]
 8025df4: 689b         	ldr	r3, [r3, #0x8]
 8025df6: 60fb         	str	r3, [r7, #0xc]
; 	return api->rx_disable(dev);
 8025df8: 68fb         	ldr	r3, [r7, #0xc]
 8025dfa: 695b         	ldr	r3, [r3, #0x14]
 8025dfc: 6878         	ldr	r0, [r7, #0x4]
 8025dfe: 4798         	blx	r3
 8025e00: 4603         	mov	r3, r0
; }
 8025e02: 4618         	mov	r0, r3
 8025e04: 3710         	adds	r7, #0x10
 8025e06: 46bd         	mov	sp, r7
 8025e08: bd80         	pop	{r7, pc}

08025e0a <uart_configure>:
; {
 8025e0a: b580         	push	{r7, lr}
 8025e0c: b082         	sub	sp, #0x8
 8025e0e: af00         	add	r7, sp, #0x0
 8025e10: 6078         	str	r0, [r7, #0x4]
 8025e12: 6039         	str	r1, [r7]
; 	return z_impl_uart_configure(dev, cfg);
 8025e14: 6839         	ldr	r1, [r7]
 8025e16: 6878         	ldr	r0, [r7, #0x4]
 8025e18: f7ff ff89    	bl	0x8025d2e <z_impl_uart_configure> @ imm = #-0xee
 8025e1c: 4603         	mov	r3, r0
; }
 8025e1e: 4618         	mov	r0, r3
 8025e20: 3708         	adds	r7, #0x8
 8025e22: 46bd         	mov	sp, r7
 8025e24: bd80         	pop	{r7, pc}

08025e26 <uart_rx_enable>:
; {
 8025e26: b580         	push	{r7, lr}
 8025e28: b084         	sub	sp, #0x10
 8025e2a: af00         	add	r7, sp, #0x0
 8025e2c: 60f8         	str	r0, [r7, #0xc]
 8025e2e: 60b9         	str	r1, [r7, #0x8]
 8025e30: 607a         	str	r2, [r7, #0x4]
 8025e32: 603b         	str	r3, [r7]
; 	return z_impl_uart_rx_enable(dev, buf, len, timeout);
 8025e34: 683b         	ldr	r3, [r7]
 8025e36: 687a         	ldr	r2, [r7, #0x4]
 8025e38: 68b9         	ldr	r1, [r7, #0x8]
 8025e3a: 68f8         	ldr	r0, [r7, #0xc]
 8025e3c: f7ff ffab    	bl	0x8025d96 <z_impl_uart_rx_enable> @ imm = #-0xaa
 8025e40: 4603         	mov	r3, r0
; }
 8025e42: 4618         	mov	r0, r3
 8025e44: 3710         	adds	r7, #0x10
 8025e46: 46bd         	mov	sp, r7
 8025e48: bd80         	pop	{r7, pc}

08025e4a <uart_rx_disable>:
; {
 8025e4a: b580         	push	{r7, lr}
 8025e4c: b082         	sub	sp, #0x8
 8025e4e: af00         	add	r7, sp, #0x0
 8025e50: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_uart_rx_disable(dev);
 8025e52: 6878         	ldr	r0, [r7, #0x4]
 8025e54: f7ff ffc9    	bl	0x8025dea <z_impl_uart_rx_disable> @ imm = #-0x6e
 8025e58: 4603         	mov	r3, r0
; }
 8025e5a: 4618         	mov	r0, r3
 8025e5c: 3708         	adds	r7, #0x8
 8025e5e: 46bd         	mov	sp, r7
 8025e60: bd80         	pop	{r7, pc}

08025e62 <z_log_msg_runtime_create>:
; {
 8025e62: b580         	push	{r7, lr}
 8025e64: b08a         	sub	sp, #0x28
 8025e66: af04         	add	r7, sp, #0x10
 8025e68: 60b9         	str	r1, [r7, #0x8]
 8025e6a: 607b         	str	r3, [r7, #0x4]
 8025e6c: 4603         	mov	r3, r0
 8025e6e: 73fb         	strb	r3, [r7, #0xf]
 8025e70: 4613         	mov	r3, r2
 8025e72: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8025e74: f107 032c    	add.w	r3, r7, #0x2c
 8025e78: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8025e7a: 7bba         	ldrb	r2, [r7, #0xe]
 8025e7c: 7bf8         	ldrb	r0, [r7, #0xf]
 8025e7e: 697b         	ldr	r3, [r7, #0x14]
 8025e80: 9303         	str	r3, [sp, #0xc]
 8025e82: 6abb         	ldr	r3, [r7, #0x28]
 8025e84: 9302         	str	r3, [sp, #0x8]
 8025e86: 6a7b         	ldr	r3, [r7, #0x24]
 8025e88: 9301         	str	r3, [sp, #0x4]
 8025e8a: 6a3b         	ldr	r3, [r7, #0x20]
 8025e8c: 9300         	str	r3, [sp]
 8025e8e: 687b         	ldr	r3, [r7, #0x4]
 8025e90: 68b9         	ldr	r1, [r7, #0x8]
 8025e92: f7de fe6f    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x21322
; }
 8025e96: bf00         	nop
 8025e98: 3718         	adds	r7, #0x18
 8025e9a: 46bd         	mov	sp, r7
 8025e9c: bd80         	pop	{r7, pc}

08025e9e <sbus_parseframe>:
; void sbus_parseframe(const struct device *dev) { // 检查帧是否为空
 8025e9e: b480         	push	{r7}
 8025ea0: b085         	sub	sp, #0x14
 8025ea2: af00         	add	r7, sp, #0x0
 8025ea4: 6078         	str	r0, [r7, #0x4]
;     struct sbus_driver_data *data = dev->data;
 8025ea6: 687b         	ldr	r3, [r7, #0x4]
 8025ea8: 691b         	ldr	r3, [r3, #0x10]
 8025eaa: 60fb         	str	r3, [r7, #0xc]
;     data->channels[0] = (data->data[1] >> 0 | (data->data[2] << 8)) & 0x07FF;
 8025eac: 68fb         	ldr	r3, [r7, #0xc]
 8025eae: 785b         	ldrb	r3, [r3, #0x1]
 8025eb0: b21a         	sxth	r2, r3
 8025eb2: 68fb         	ldr	r3, [r7, #0xc]
 8025eb4: 789b         	ldrb	r3, [r3, #0x2]
 8025eb6: 021b         	lsls	r3, r3, #0x8
 8025eb8: b21b         	sxth	r3, r3
 8025eba: 4313         	orrs	r3, r2
 8025ebc: b21b         	sxth	r3, r3
 8025ebe: b29b         	uxth	r3, r3
 8025ec0: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8025ec4: b29a         	uxth	r2, r3
 8025ec6: 68fb         	ldr	r3, [r7, #0xc]
 8025ec8: 835a         	strh	r2, [r3, #0x1a]
;     data->channels[1] = (data->data[2] >> 3 | (data->data[3] << 5)) & 0x07FF;
 8025eca: 68fb         	ldr	r3, [r7, #0xc]
 8025ecc: 789b         	ldrb	r3, [r3, #0x2]
 8025ece: 08db         	lsrs	r3, r3, #0x3
 8025ed0: b2db         	uxtb	r3, r3
 8025ed2: b21a         	sxth	r2, r3
 8025ed4: 68fb         	ldr	r3, [r7, #0xc]
 8025ed6: 78db         	ldrb	r3, [r3, #0x3]
 8025ed8: 015b         	lsls	r3, r3, #0x5
 8025eda: b21b         	sxth	r3, r3
 8025edc: 4313         	orrs	r3, r2
 8025ede: b21b         	sxth	r3, r3
 8025ee0: b29b         	uxth	r3, r3
 8025ee2: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8025ee6: b29a         	uxth	r2, r3
 8025ee8: 68fb         	ldr	r3, [r7, #0xc]
 8025eea: 839a         	strh	r2, [r3, #0x1c]
;         (data->data[3] >> 6 | (data->data[4] << 2) | data->data[5] << 10) & 0x07FF;
 8025eec: 68fb         	ldr	r3, [r7, #0xc]
 8025eee: 78db         	ldrb	r3, [r3, #0x3]
 8025ef0: 099b         	lsrs	r3, r3, #0x6
 8025ef2: b2db         	uxtb	r3, r3
 8025ef4: b21a         	sxth	r2, r3
 8025ef6: 68fb         	ldr	r3, [r7, #0xc]
 8025ef8: 791b         	ldrb	r3, [r3, #0x4]
 8025efa: 009b         	lsls	r3, r3, #0x2
 8025efc: b21b         	sxth	r3, r3
 8025efe: 4313         	orrs	r3, r2
 8025f00: b21a         	sxth	r2, r3
 8025f02: 68fb         	ldr	r3, [r7, #0xc]
 8025f04: 795b         	ldrb	r3, [r3, #0x5]
 8025f06: 029b         	lsls	r3, r3, #0xa
 8025f08: b21b         	sxth	r3, r3
 8025f0a: 4313         	orrs	r3, r2
 8025f0c: b21b         	sxth	r3, r3
 8025f0e: b29b         	uxth	r3, r3
 8025f10: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8025f14: b29a         	uxth	r2, r3
;     data->channels[2] =
 8025f16: 68fb         	ldr	r3, [r7, #0xc]
 8025f18: 83da         	strh	r2, [r3, #0x1e]
;     data->channels[3] = (data->data[5] >> 1 | (data->data[6] << 7)) & 0x07FF;
 8025f1a: 68fb         	ldr	r3, [r7, #0xc]
 8025f1c: 795b         	ldrb	r3, [r3, #0x5]
 8025f1e: 085b         	lsrs	r3, r3, #0x1
 8025f20: b2db         	uxtb	r3, r3
 8025f22: b21a         	sxth	r2, r3
 8025f24: 68fb         	ldr	r3, [r7, #0xc]
 8025f26: 799b         	ldrb	r3, [r3, #0x6]
 8025f28: 01db         	lsls	r3, r3, #0x7
 8025f2a: b21b         	sxth	r3, r3
 8025f2c: 4313         	orrs	r3, r2
 8025f2e: b21b         	sxth	r3, r3
 8025f30: b29b         	uxth	r3, r3
 8025f32: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8025f36: b29a         	uxth	r2, r3
 8025f38: 68fb         	ldr	r3, [r7, #0xc]
 8025f3a: 841a         	strh	r2, [r3, #0x20]
;     data->channels[4] = (data->data[6] >> 4 | (data->data[7] << 4)) & 0x07FF;
 8025f3c: 68fb         	ldr	r3, [r7, #0xc]
 8025f3e: 799b         	ldrb	r3, [r3, #0x6]
 8025f40: 091b         	lsrs	r3, r3, #0x4
 8025f42: b2db         	uxtb	r3, r3
 8025f44: b21a         	sxth	r2, r3
 8025f46: 68fb         	ldr	r3, [r7, #0xc]
 8025f48: 79db         	ldrb	r3, [r3, #0x7]
 8025f4a: 011b         	lsls	r3, r3, #0x4
 8025f4c: b21b         	sxth	r3, r3
 8025f4e: 4313         	orrs	r3, r2
 8025f50: b21b         	sxth	r3, r3
 8025f52: b29b         	uxth	r3, r3
 8025f54: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8025f58: b29a         	uxth	r2, r3
 8025f5a: 68fb         	ldr	r3, [r7, #0xc]
 8025f5c: 845a         	strh	r2, [r3, #0x22]
;     data->channels[5] = (data->data[7] >> 7 | (data->data[8] << 1) | data->data[9] << 9) & 0x07FF;
 8025f5e: 68fb         	ldr	r3, [r7, #0xc]
 8025f60: 79db         	ldrb	r3, [r3, #0x7]
 8025f62: 09db         	lsrs	r3, r3, #0x7
 8025f64: b2db         	uxtb	r3, r3
 8025f66: b21a         	sxth	r2, r3
 8025f68: 68fb         	ldr	r3, [r7, #0xc]
 8025f6a: 7a1b         	ldrb	r3, [r3, #0x8]
 8025f6c: 005b         	lsls	r3, r3, #0x1
 8025f6e: b21b         	sxth	r3, r3
 8025f70: 4313         	orrs	r3, r2
 8025f72: b21a         	sxth	r2, r3
 8025f74: 68fb         	ldr	r3, [r7, #0xc]
 8025f76: 7a5b         	ldrb	r3, [r3, #0x9]
 8025f78: 025b         	lsls	r3, r3, #0x9
 8025f7a: b21b         	sxth	r3, r3
 8025f7c: 4313         	orrs	r3, r2
 8025f7e: b21b         	sxth	r3, r3
 8025f80: b29b         	uxth	r3, r3
 8025f82: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8025f86: b29a         	uxth	r2, r3
 8025f88: 68fb         	ldr	r3, [r7, #0xc]
 8025f8a: 849a         	strh	r2, [r3, #0x24]
;     data->channels[6] = (data->data[9] >> 2 | (data->data[10] << 6)) & 0x07FF;
 8025f8c: 68fb         	ldr	r3, [r7, #0xc]
 8025f8e: 7a5b         	ldrb	r3, [r3, #0x9]
 8025f90: 089b         	lsrs	r3, r3, #0x2
 8025f92: b2db         	uxtb	r3, r3
 8025f94: b21a         	sxth	r2, r3
 8025f96: 68fb         	ldr	r3, [r7, #0xc]
 8025f98: 7a9b         	ldrb	r3, [r3, #0xa]
 8025f9a: 019b         	lsls	r3, r3, #0x6
 8025f9c: b21b         	sxth	r3, r3
 8025f9e: 4313         	orrs	r3, r2
 8025fa0: b21b         	sxth	r3, r3
 8025fa2: b29b         	uxth	r3, r3
 8025fa4: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8025fa8: b29a         	uxth	r2, r3
 8025faa: 68fb         	ldr	r3, [r7, #0xc]
 8025fac: 84da         	strh	r2, [r3, #0x26]
;     data->channels[7] = (data->data[10] >> 5 | (data->data[11] << 3)) & 0x07FF;
 8025fae: 68fb         	ldr	r3, [r7, #0xc]
 8025fb0: 7a9b         	ldrb	r3, [r3, #0xa]
 8025fb2: 095b         	lsrs	r3, r3, #0x5
 8025fb4: b2db         	uxtb	r3, r3
 8025fb6: b21a         	sxth	r2, r3
 8025fb8: 68fb         	ldr	r3, [r7, #0xc]
 8025fba: 7adb         	ldrb	r3, [r3, #0xb]
 8025fbc: 00db         	lsls	r3, r3, #0x3
 8025fbe: b21b         	sxth	r3, r3
 8025fc0: 4313         	orrs	r3, r2
 8025fc2: b21b         	sxth	r3, r3
 8025fc4: b29b         	uxth	r3, r3
 8025fc6: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8025fca: b29a         	uxth	r2, r3
 8025fcc: 68fb         	ldr	r3, [r7, #0xc]
 8025fce: 851a         	strh	r2, [r3, #0x28]
;     data->channels[8] = (data->data[12] << 0 | (data->data[13] << 8)) & 0x07FF;
 8025fd0: 68fb         	ldr	r3, [r7, #0xc]
 8025fd2: 7b1b         	ldrb	r3, [r3, #0xc]
 8025fd4: b21a         	sxth	r2, r3
 8025fd6: 68fb         	ldr	r3, [r7, #0xc]
 8025fd8: 7b5b         	ldrb	r3, [r3, #0xd]
 8025fda: 021b         	lsls	r3, r3, #0x8
 8025fdc: b21b         	sxth	r3, r3
 8025fde: 4313         	orrs	r3, r2
 8025fe0: b21b         	sxth	r3, r3
 8025fe2: b29b         	uxth	r3, r3
 8025fe4: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8025fe8: b29a         	uxth	r2, r3
 8025fea: 68fb         	ldr	r3, [r7, #0xc]
 8025fec: 855a         	strh	r2, [r3, #0x2a]
;     data->channels[9] = (data->data[13] >> 3 | (data->data[14] << 5)) & 0x07FF;
 8025fee: 68fb         	ldr	r3, [r7, #0xc]
 8025ff0: 7b5b         	ldrb	r3, [r3, #0xd]
 8025ff2: 08db         	lsrs	r3, r3, #0x3
 8025ff4: b2db         	uxtb	r3, r3
 8025ff6: b21a         	sxth	r2, r3
 8025ff8: 68fb         	ldr	r3, [r7, #0xc]
 8025ffa: 7b9b         	ldrb	r3, [r3, #0xe]
 8025ffc: 015b         	lsls	r3, r3, #0x5
 8025ffe: b21b         	sxth	r3, r3
 8026000: 4313         	orrs	r3, r2
 8026002: b21b         	sxth	r3, r3
 8026004: b29b         	uxth	r3, r3
 8026006: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 802600a: b29a         	uxth	r2, r3
 802600c: 68fb         	ldr	r3, [r7, #0xc]
 802600e: 859a         	strh	r2, [r3, #0x2c]
;         (data->data[14] >> 6 | (data->data[16] << 2) | data->data[15] << 10) & 0x07FF;
 8026010: 68fb         	ldr	r3, [r7, #0xc]
 8026012: 7b9b         	ldrb	r3, [r3, #0xe]
 8026014: 099b         	lsrs	r3, r3, #0x6
 8026016: b2db         	uxtb	r3, r3
 8026018: b21a         	sxth	r2, r3
 802601a: 68fb         	ldr	r3, [r7, #0xc]
 802601c: 7c1b         	ldrb	r3, [r3, #0x10]
 802601e: 009b         	lsls	r3, r3, #0x2
 8026020: b21b         	sxth	r3, r3
 8026022: 4313         	orrs	r3, r2
 8026024: b21a         	sxth	r2, r3
 8026026: 68fb         	ldr	r3, [r7, #0xc]
 8026028: 7bdb         	ldrb	r3, [r3, #0xf]
 802602a: 029b         	lsls	r3, r3, #0xa
 802602c: b21b         	sxth	r3, r3
 802602e: 4313         	orrs	r3, r2
 8026030: b21b         	sxth	r3, r3
 8026032: b29b         	uxth	r3, r3
 8026034: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8026038: b29a         	uxth	r2, r3
;     data->channels[10] =
 802603a: 68fb         	ldr	r3, [r7, #0xc]
 802603c: 85da         	strh	r2, [r3, #0x2e]
;     data->channels[11] = (data->data[16] >> 1 | (data->data[17] << 7)) & 0x07FF;
 802603e: 68fb         	ldr	r3, [r7, #0xc]
 8026040: 7c1b         	ldrb	r3, [r3, #0x10]
 8026042: 085b         	lsrs	r3, r3, #0x1
 8026044: b2db         	uxtb	r3, r3
 8026046: b21a         	sxth	r2, r3
 8026048: 68fb         	ldr	r3, [r7, #0xc]
 802604a: 7c5b         	ldrb	r3, [r3, #0x11]
 802604c: 01db         	lsls	r3, r3, #0x7
 802604e: b21b         	sxth	r3, r3
 8026050: 4313         	orrs	r3, r2
 8026052: b21b         	sxth	r3, r3
 8026054: b29b         	uxth	r3, r3
 8026056: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 802605a: b29a         	uxth	r2, r3
 802605c: 68fb         	ldr	r3, [r7, #0xc]
 802605e: 861a         	strh	r2, [r3, #0x30]
;     data->channels[12] = (data->data[17] >> 4 | (data->data[18] << 4)) & 0x07FF;
 8026060: 68fb         	ldr	r3, [r7, #0xc]
 8026062: 7c5b         	ldrb	r3, [r3, #0x11]
 8026064: 091b         	lsrs	r3, r3, #0x4
 8026066: b2db         	uxtb	r3, r3
 8026068: b21a         	sxth	r2, r3
 802606a: 68fb         	ldr	r3, [r7, #0xc]
 802606c: 7c9b         	ldrb	r3, [r3, #0x12]
 802606e: 011b         	lsls	r3, r3, #0x4
 8026070: b21b         	sxth	r3, r3
 8026072: 4313         	orrs	r3, r2
 8026074: b21b         	sxth	r3, r3
 8026076: b29b         	uxth	r3, r3
 8026078: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 802607c: b29a         	uxth	r2, r3
 802607e: 68fb         	ldr	r3, [r7, #0xc]
 8026080: 865a         	strh	r2, [r3, #0x32]
;         (data->data[18] >> 7 | (data->data[19] << 1) | data->data[20] << 9) & 0x07FF;
 8026082: 68fb         	ldr	r3, [r7, #0xc]
 8026084: 7c9b         	ldrb	r3, [r3, #0x12]
 8026086: 09db         	lsrs	r3, r3, #0x7
 8026088: b2db         	uxtb	r3, r3
 802608a: b21a         	sxth	r2, r3
 802608c: 68fb         	ldr	r3, [r7, #0xc]
 802608e: 7cdb         	ldrb	r3, [r3, #0x13]
 8026090: 005b         	lsls	r3, r3, #0x1
 8026092: b21b         	sxth	r3, r3
 8026094: 4313         	orrs	r3, r2
 8026096: b21a         	sxth	r2, r3
 8026098: 68fb         	ldr	r3, [r7, #0xc]
 802609a: 7d1b         	ldrb	r3, [r3, #0x14]
 802609c: 025b         	lsls	r3, r3, #0x9
 802609e: b21b         	sxth	r3, r3
 80260a0: 4313         	orrs	r3, r2
 80260a2: b21b         	sxth	r3, r3
 80260a4: b29b         	uxth	r3, r3
 80260a6: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 80260aa: b29a         	uxth	r2, r3
;     data->channels[13] =
 80260ac: 68fb         	ldr	r3, [r7, #0xc]
 80260ae: 869a         	strh	r2, [r3, #0x34]
;     data->channels[14] = (data->data[20] >> 2 | (data->data[21] << 6)) & 0x07FF;
 80260b0: 68fb         	ldr	r3, [r7, #0xc]
 80260b2: 7d1b         	ldrb	r3, [r3, #0x14]
 80260b4: 089b         	lsrs	r3, r3, #0x2
 80260b6: b2db         	uxtb	r3, r3
 80260b8: b21a         	sxth	r2, r3
 80260ba: 68fb         	ldr	r3, [r7, #0xc]
 80260bc: 7d5b         	ldrb	r3, [r3, #0x15]
 80260be: 019b         	lsls	r3, r3, #0x6
 80260c0: b21b         	sxth	r3, r3
 80260c2: 4313         	orrs	r3, r2
 80260c4: b21b         	sxth	r3, r3
 80260c6: b29b         	uxth	r3, r3
 80260c8: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 80260cc: b29a         	uxth	r2, r3
 80260ce: 68fb         	ldr	r3, [r7, #0xc]
 80260d0: 86da         	strh	r2, [r3, #0x36]
;     data->channels[15] = (data->data[21] >> 5 | (data->data[22] << 3)) & 0x07FF;
 80260d2: 68fb         	ldr	r3, [r7, #0xc]
 80260d4: 7d5b         	ldrb	r3, [r3, #0x15]
 80260d6: 095b         	lsrs	r3, r3, #0x5
 80260d8: b2db         	uxtb	r3, r3
 80260da: b21a         	sxth	r2, r3
 80260dc: 68fb         	ldr	r3, [r7, #0xc]
 80260de: 7d9b         	ldrb	r3, [r3, #0x16]
 80260e0: 00db         	lsls	r3, r3, #0x3
 80260e2: b21b         	sxth	r3, r3
 80260e4: 4313         	orrs	r3, r2
 80260e6: b21b         	sxth	r3, r3
 80260e8: b29b         	uxth	r3, r3
 80260ea: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 80260ee: b29a         	uxth	r2, r3
 80260f0: 68fb         	ldr	r3, [r7, #0xc]
 80260f2: 871a         	strh	r2, [r3, #0x38]
;     data->frameLost          = (data->data[23] & 0x04) >> 2;
 80260f4: 68fb         	ldr	r3, [r7, #0xc]
 80260f6: 7ddb         	ldrb	r3, [r3, #0x17]
 80260f8: 109b         	asrs	r3, r3, #0x2
 80260fa: f003 0301    	and	r3, r3, #0x1
 80260fe: 2b00         	cmp	r3, #0x0
 8026100: bf14         	ite	ne
 8026102: 2301         	movne	r3, #0x1
 8026104: 2300         	moveq	r3, #0x0
 8026106: b2da         	uxtb	r2, r3
 8026108: 68fb         	ldr	r3, [r7, #0xc]
 802610a: f883 203a    	strb.w	r2, [r3, #0x3a]
;     data->failSafe           = (data->data[23] & 0x08) >> 3;
 802610e: 68fb         	ldr	r3, [r7, #0xc]
 8026110: 7ddb         	ldrb	r3, [r3, #0x17]
 8026112: 10db         	asrs	r3, r3, #0x3
 8026114: f003 0301    	and	r3, r3, #0x1
 8026118: 2b00         	cmp	r3, #0x0
 802611a: bf14         	ite	ne
 802611c: 2301         	movne	r3, #0x1
 802611e: 2300         	moveq	r3, #0x0
 8026120: b2da         	uxtb	r2, r3
 8026122: 68fb         	ldr	r3, [r7, #0xc]
 8026124: f883 203b    	strb.w	r2, [r3, #0x3b]
;     data->digitalChannels[0] = (data->data[23] & 0x01);
 8026128: 68fb         	ldr	r3, [r7, #0xc]
 802612a: 7ddb         	ldrb	r3, [r3, #0x17]
 802612c: f003 0301    	and	r3, r3, #0x1
 8026130: 2b00         	cmp	r3, #0x0
 8026132: bf14         	ite	ne
 8026134: 2301         	movne	r3, #0x1
 8026136: 2300         	moveq	r3, #0x0
 8026138: b2da         	uxtb	r2, r3
 802613a: 68fb         	ldr	r3, [r7, #0xc]
 802613c: f883 203c    	strb.w	r2, [r3, #0x3c]
;     data->digitalChannels[1] = (data->data[23] & 0x02) >> 1;
 8026140: 68fb         	ldr	r3, [r7, #0xc]
 8026142: 7ddb         	ldrb	r3, [r3, #0x17]
 8026144: 105b         	asrs	r3, r3, #0x1
 8026146: f003 0301    	and	r3, r3, #0x1
 802614a: 2b00         	cmp	r3, #0x0
 802614c: bf14         	ite	ne
 802614e: 2301         	movne	r3, #0x1
 8026150: 2300         	moveq	r3, #0x0
 8026152: b2da         	uxtb	r2, r3
 8026154: 68fb         	ldr	r3, [r7, #0xc]
 8026156: f883 203d    	strb.w	r2, [r3, #0x3d]
; }
 802615a: bf00         	nop
 802615c: 3714         	adds	r7, #0x14
 802615e: 46bd         	mov	sp, r7
 8026160: f85d 7b04    	ldr	r7, [sp], #4
 8026164: 4770         	bx	lr

08026166 <find_begin>:
; static int16_t find_begin(const uint8_t *data, uint16_t len) {
 8026166: b480         	push	{r7}
 8026168: b085         	sub	sp, #0x14
 802616a: af00         	add	r7, sp, #0x0
 802616c: 6078         	str	r0, [r7, #0x4]
 802616e: 460b         	mov	r3, r1
 8026170: 807b         	strh	r3, [r7, #0x2]
;     if (len < 25) {
 8026172: 887b         	ldrh	r3, [r7, #0x2]
 8026174: 2b18         	cmp	r3, #0x18
 8026176: d802         	bhi	0x802617e <find_begin+0x18> @ imm = #0x4
;         return -1;
 8026178: f04f 33ff    	mov.w	r3, #0xffffffff
 802617c: e01e         	b	0x80261bc <find_begin+0x56> @ imm = #0x3c
;     for (int i = len - 1; i >= 24; i--) {
 802617e: 887b         	ldrh	r3, [r7, #0x2]
 8026180: 3b01         	subs	r3, #0x1
 8026182: 60fb         	str	r3, [r7, #0xc]
 8026184: e015         	b	0x80261b2 <find_begin+0x4c> @ imm = #0x2a
;         if (data[i - 24] == 0x0F && data[i] == 0x00) {
 8026186: 68fb         	ldr	r3, [r7, #0xc]
 8026188: 3b18         	subs	r3, #0x18
 802618a: 687a         	ldr	r2, [r7, #0x4]
 802618c: 4413         	add	r3, r2
 802618e: 781b         	ldrb	r3, [r3]
 8026190: 2b0f         	cmp	r3, #0xf
 8026192: d10b         	bne	0x80261ac <find_begin+0x46> @ imm = #0x16
 8026194: 68fb         	ldr	r3, [r7, #0xc]
 8026196: 687a         	ldr	r2, [r7, #0x4]
 8026198: 4413         	add	r3, r2
 802619a: 781b         	ldrb	r3, [r3]
 802619c: 2b00         	cmp	r3, #0x0
 802619e: d105         	bne	0x80261ac <find_begin+0x46> @ imm = #0xa
;             return i - 24;
 80261a0: 68fb         	ldr	r3, [r7, #0xc]
 80261a2: b29b         	uxth	r3, r3
 80261a4: 3b18         	subs	r3, #0x18
 80261a6: b29b         	uxth	r3, r3
 80261a8: b21b         	sxth	r3, r3
 80261aa: e007         	b	0x80261bc <find_begin+0x56> @ imm = #0xe
;     for (int i = len - 1; i >= 24; i--) {
 80261ac: 68fb         	ldr	r3, [r7, #0xc]
 80261ae: 3b01         	subs	r3, #0x1
 80261b0: 60fb         	str	r3, [r7, #0xc]
 80261b2: 68fb         	ldr	r3, [r7, #0xc]
 80261b4: 2b17         	cmp	r3, #0x17
 80261b6: dce6         	bgt	0x8026186 <find_begin+0x20> @ imm = #-0x34
;     return -1;
 80261b8: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 80261bc: 4618         	mov	r0, r3
 80261be: 3714         	adds	r7, #0x14
 80261c0: 46bd         	mov	sp, r7
 80261c2: f85d 7b04    	ldr	r7, [sp], #4
 80261c6: 4770         	bx	lr

080261c8 <sbus_getchannel_digital>:
; int sbus_getchannel_digital(const struct device *dev, uint8_t channelid) {
 80261c8: b580         	push	{r7, lr}
 80261ca: b084         	sub	sp, #0x10
 80261cc: af00         	add	r7, sp, #0x0
 80261ce: 6078         	str	r0, [r7, #0x4]
 80261d0: 460b         	mov	r3, r1
 80261d2: 70fb         	strb	r3, [r7, #0x3]
;     struct sbus_driver_data *data = dev->data;
 80261d4: 687b         	ldr	r3, [r7, #0x4]
 80261d6: 691b         	ldr	r3, [r3, #0x10]
 80261d8: 60fb         	str	r3, [r7, #0xc]
;     sbus_parseframe(dev);
 80261da: 6878         	ldr	r0, [r7, #0x4]
 80261dc: f7ff fe5f    	bl	0x8025e9e <sbus_parseframe> @ imm = #-0x342
;     return data->channels[channelid];
 80261e0: 78fb         	ldrb	r3, [r7, #0x3]
 80261e2: 68fa         	ldr	r2, [r7, #0xc]
 80261e4: 330c         	adds	r3, #0xc
 80261e6: 005b         	lsls	r3, r3, #0x1
 80261e8: 4413         	add	r3, r2
 80261ea: 885b         	ldrh	r3, [r3, #0x2]
; }
 80261ec: 4618         	mov	r0, r3
 80261ee: 3710         	adds	r7, #0x10
 80261f0: 46bd         	mov	sp, r7
 80261f2: bd80         	pop	{r7, pc}

080261f4 <LL_DMA_Init>:
; {
 80261f4: b580         	push	{r7, lr}
 80261f6: b084         	sub	sp, #0x10
 80261f8: af00         	add	r7, sp, #0x0
 80261fa: 60f8         	str	r0, [r7, #0xc]
 80261fc: 60b9         	str	r1, [r7, #0x8]
 80261fe: 607a         	str	r2, [r7, #0x4]
;                         DMA_InitStruct->Direction               | \
 8026200: 687b         	ldr	r3, [r7, #0x4]
 8026202: 689a         	ldr	r2, [r3, #0x8]
;                         DMA_InitStruct->Mode                    | \
 8026204: 687b         	ldr	r3, [r7, #0x4]
 8026206: 68db         	ldr	r3, [r3, #0xc]
;                         DMA_InitStruct->Direction               | \
 8026208: 431a         	orrs	r2, r3
;                         DMA_InitStruct->PeriphOrM2MSrcIncMode   | \
 802620a: 687b         	ldr	r3, [r7, #0x4]
 802620c: 691b         	ldr	r3, [r3, #0x10]
;                         DMA_InitStruct->Mode                    | \
 802620e: 431a         	orrs	r2, r3
;                         DMA_InitStruct->MemoryOrM2MDstIncMode   | \
 8026210: 687b         	ldr	r3, [r7, #0x4]
 8026212: 695b         	ldr	r3, [r3, #0x14]
;                         DMA_InitStruct->PeriphOrM2MSrcIncMode   | \
 8026214: 431a         	orrs	r2, r3
;                         DMA_InitStruct->PeriphOrM2MSrcDataSize  | \
 8026216: 687b         	ldr	r3, [r7, #0x4]
 8026218: 699b         	ldr	r3, [r3, #0x18]
;                         DMA_InitStruct->MemoryOrM2MDstIncMode   | \
 802621a: 431a         	orrs	r2, r3
;                         DMA_InitStruct->MemoryOrM2MDstDataSize  | \
 802621c: 687b         	ldr	r3, [r7, #0x4]
 802621e: 69db         	ldr	r3, [r3, #0x1c]
;                         DMA_InitStruct->PeriphOrM2MSrcDataSize  | \
 8026220: 431a         	orrs	r2, r3
;                         DMA_InitStruct->Priority                | \
 8026222: 687b         	ldr	r3, [r7, #0x4]
 8026224: 6a9b         	ldr	r3, [r3, #0x28]
;                         DMA_InitStruct->MemoryOrM2MDstDataSize  | \
 8026226: 431a         	orrs	r2, r3
;                         DMA_InitStruct->DoubleBufferMode        | \
 8026228: 687b         	ldr	r3, [r7, #0x4]
 802622a: 6bdb         	ldr	r3, [r3, #0x3c]
;                         DMA_InitStruct->Priority                | \
 802622c: 431a         	orrs	r2, r3
;                         DMA_InitStruct->TargetMemInDoubleBufferMode);
 802622e: 687b         	ldr	r3, [r7, #0x4]
 8026230: 6c1b         	ldr	r3, [r3, #0x40]
;   LL_DMA_ConfigTransfer(DMAx, Stream,
 8026232: 4313         	orrs	r3, r2
 8026234: 461a         	mov	r2, r3
 8026236: 68b9         	ldr	r1, [r7, #0x8]
 8026238: 68f8         	ldr	r0, [r7, #0xc]
 802623a: f7ed faed    	bl	0x8013818 <LL_DMA_ConfigTransfer> @ imm = #-0x12a26
;   if (DMA_InitStruct->FIFOMode != LL_DMA_FIFOMODE_DISABLE)
 802623e: 687b         	ldr	r3, [r7, #0x4]
 8026240: 6adb         	ldr	r3, [r3, #0x2c]
 8026242: 2b00         	cmp	r3, #0x0
 8026244: d015         	beq	0x8026272 <LL_DMA_Init+0x7e> @ imm = #0x2a
;     LL_DMA_ConfigFifo(DMAx, Stream, DMA_InitStruct->FIFOMode, DMA_InitStruct->FIFOThreshold);
 8026246: 687b         	ldr	r3, [r7, #0x4]
 8026248: 6ada         	ldr	r2, [r3, #0x2c]
 802624a: 687b         	ldr	r3, [r7, #0x4]
 802624c: 6b1b         	ldr	r3, [r3, #0x30]
 802624e: 68b9         	ldr	r1, [r7, #0x8]
 8026250: 68f8         	ldr	r0, [r7, #0xc]
 8026252: f7ed fbad    	bl	0x80139b0 <LL_DMA_ConfigFifo> @ imm = #-0x128a6
;     LL_DMA_SetMemoryBurstxfer(DMAx, Stream, DMA_InitStruct->MemBurst);
 8026256: 687b         	ldr	r3, [r7, #0x4]
 8026258: 6b5b         	ldr	r3, [r3, #0x34]
 802625a: 461a         	mov	r2, r3
 802625c: 68b9         	ldr	r1, [r7, #0x8]
 802625e: 68f8         	ldr	r0, [r7, #0xc]
 8026260: f7ed fb5a    	bl	0x8013918 <LL_DMA_SetMemoryBurstxfer> @ imm = #-0x1294c
;     LL_DMA_SetPeriphBurstxfer(DMAx, Stream, DMA_InitStruct->PeriphBurst);
 8026264: 687b         	ldr	r3, [r7, #0x4]
 8026266: 6b9b         	ldr	r3, [r3, #0x38]
 8026268: 461a         	mov	r2, r3
 802626a: 68b9         	ldr	r1, [r7, #0x8]
 802626c: 68f8         	ldr	r0, [r7, #0xc]
 802626e: f7ed fb79    	bl	0x8013964 <LL_DMA_SetPeriphBurstxfer> @ imm = #-0x1290e
;   LL_DMA_SetMemoryAddress(DMAx, Stream, DMA_InitStruct->MemoryOrM2MDstAddress);
 8026272: 687b         	ldr	r3, [r7, #0x4]
 8026274: 685b         	ldr	r3, [r3, #0x4]
 8026276: 461a         	mov	r2, r3
 8026278: 68b9         	ldr	r1, [r7, #0x8]
 802627a: 68f8         	ldr	r0, [r7, #0xc]
 802627c: f7ed fbc0    	bl	0x8013a00 <LL_DMA_SetMemoryAddress> @ imm = #-0x12880
;   LL_DMA_SetPeriphAddress(DMAx, Stream, DMA_InitStruct->PeriphOrM2MSrcAddress);
 8026280: 687b         	ldr	r3, [r7, #0x4]
 8026282: 681b         	ldr	r3, [r3]
 8026284: 461a         	mov	r2, r3
 8026286: 68b9         	ldr	r1, [r7, #0x8]
 8026288: 68f8         	ldr	r0, [r7, #0xc]
 802628a: f7ed fbd3    	bl	0x8013a34 <LL_DMA_SetPeriphAddress> @ imm = #-0x1285a
;   LL_DMA_SetDataLength(DMAx, Stream, DMA_InitStruct->NbData);
 802628e: 687b         	ldr	r3, [r7, #0x4]
 8026290: 6a1b         	ldr	r3, [r3, #0x20]
 8026292: 461a         	mov	r2, r3
 8026294: 68b9         	ldr	r1, [r7, #0x8]
 8026296: 68f8         	ldr	r0, [r7, #0xc]
 8026298: f7ed fae6    	bl	0x8013868 <LL_DMA_SetDataLength> @ imm = #-0x12a34
;   LL_DMA_SetPeriphRequest(DMAx, Stream, DMA_InitStruct->PeriphRequest);
 802629c: 687b         	ldr	r3, [r7, #0x4]
 802629e: 6a5b         	ldr	r3, [r3, #0x24]
 80262a0: 461a         	mov	r2, r3
 80262a2: 68b9         	ldr	r1, [r7, #0x8]
 80262a4: 68f8         	ldr	r0, [r7, #0xc]
 80262a6: f7ed fb07    	bl	0x80138b8 <LL_DMA_SetPeriphRequest> @ imm = #-0x129f2
;   return (uint32_t)SUCCESS;
 80262aa: 2300         	movs	r3, #0x0
; }
 80262ac: 4618         	mov	r0, r3
 80262ae: 3710         	adds	r7, #0x10
 80262b0: 46bd         	mov	sp, r7
 80262b2: bd80         	pop	{r7, pc}

080262b4 <LL_DMA_StructInit>:
; {
 80262b4: b480         	push	{r7}
 80262b6: b083         	sub	sp, #0xc
 80262b8: af00         	add	r7, sp, #0x0
 80262ba: 6078         	str	r0, [r7, #0x4]
;   DMA_InitStruct->PeriphOrM2MSrcAddress       = 0x00000000U;
 80262bc: 687b         	ldr	r3, [r7, #0x4]
 80262be: 2200         	movs	r2, #0x0
 80262c0: 601a         	str	r2, [r3]
;   DMA_InitStruct->MemoryOrM2MDstAddress       = 0x00000000U;
 80262c2: 687b         	ldr	r3, [r7, #0x4]
 80262c4: 2200         	movs	r2, #0x0
 80262c6: 605a         	str	r2, [r3, #0x4]
;   DMA_InitStruct->Direction                   = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
 80262c8: 687b         	ldr	r3, [r7, #0x4]
 80262ca: 2200         	movs	r2, #0x0
 80262cc: 609a         	str	r2, [r3, #0x8]
;   DMA_InitStruct->Mode                        = LL_DMA_MODE_NORMAL;
 80262ce: 687b         	ldr	r3, [r7, #0x4]
 80262d0: 2200         	movs	r2, #0x0
 80262d2: 60da         	str	r2, [r3, #0xc]
;   DMA_InitStruct->PeriphOrM2MSrcIncMode       = LL_DMA_PERIPH_NOINCREMENT;
 80262d4: 687b         	ldr	r3, [r7, #0x4]
 80262d6: 2200         	movs	r2, #0x0
 80262d8: 611a         	str	r2, [r3, #0x10]
;   DMA_InitStruct->MemoryOrM2MDstIncMode       = LL_DMA_MEMORY_NOINCREMENT;
 80262da: 687b         	ldr	r3, [r7, #0x4]
 80262dc: 2200         	movs	r2, #0x0
 80262de: 615a         	str	r2, [r3, #0x14]
;   DMA_InitStruct->PeriphOrM2MSrcDataSize      = LL_DMA_PDATAALIGN_BYTE;
 80262e0: 687b         	ldr	r3, [r7, #0x4]
 80262e2: 2200         	movs	r2, #0x0
 80262e4: 619a         	str	r2, [r3, #0x18]
;   DMA_InitStruct->MemoryOrM2MDstDataSize      = LL_DMA_MDATAALIGN_BYTE;
 80262e6: 687b         	ldr	r3, [r7, #0x4]
 80262e8: 2200         	movs	r2, #0x0
 80262ea: 61da         	str	r2, [r3, #0x1c]
;   DMA_InitStruct->NbData                      = 0x00000000U;
 80262ec: 687b         	ldr	r3, [r7, #0x4]
 80262ee: 2200         	movs	r2, #0x0
 80262f0: 621a         	str	r2, [r3, #0x20]
;   DMA_InitStruct->PeriphRequest               = LL_DMAMUX1_REQ_MEM2MEM;
 80262f2: 687b         	ldr	r3, [r7, #0x4]
 80262f4: 2200         	movs	r2, #0x0
 80262f6: 625a         	str	r2, [r3, #0x24]
;   DMA_InitStruct->Priority                    = LL_DMA_PRIORITY_LOW;
 80262f8: 687b         	ldr	r3, [r7, #0x4]
 80262fa: 2200         	movs	r2, #0x0
 80262fc: 629a         	str	r2, [r3, #0x28]
;   DMA_InitStruct->FIFOMode                    = LL_DMA_FIFOMODE_DISABLE;
 80262fe: 687b         	ldr	r3, [r7, #0x4]
 8026300: 2200         	movs	r2, #0x0
 8026302: 62da         	str	r2, [r3, #0x2c]
;   DMA_InitStruct->FIFOThreshold               = LL_DMA_FIFOTHRESHOLD_1_4;
 8026304: 687b         	ldr	r3, [r7, #0x4]
 8026306: 2200         	movs	r2, #0x0
 8026308: 631a         	str	r2, [r3, #0x30]
;   DMA_InitStruct->MemBurst                    = LL_DMA_MBURST_SINGLE;
 802630a: 687b         	ldr	r3, [r7, #0x4]
 802630c: 2200         	movs	r2, #0x0
 802630e: 635a         	str	r2, [r3, #0x34]
;   DMA_InitStruct->PeriphBurst                 = LL_DMA_PBURST_SINGLE;
 8026310: 687b         	ldr	r3, [r7, #0x4]
 8026312: 2200         	movs	r2, #0x0
 8026314: 639a         	str	r2, [r3, #0x38]
;   DMA_InitStruct->DoubleBufferMode            = LL_DMA_DOUBLEBUFFER_MODE_DISABLE;
 8026316: 687b         	ldr	r3, [r7, #0x4]
 8026318: 2200         	movs	r2, #0x0
 802631a: 63da         	str	r2, [r3, #0x3c]
;   DMA_InitStruct->TargetMemInDoubleBufferMode = LL_DMA_CURRENTTARGETMEM0;
 802631c: 687b         	ldr	r3, [r7, #0x4]
 802631e: 2200         	movs	r2, #0x0
 8026320: 641a         	str	r2, [r3, #0x40]
; }
 8026322: bf00         	nop
 8026324: 370c         	adds	r7, #0xc
 8026326: 46bd         	mov	sp, r7
 8026328: f85d 7b04    	ldr	r7, [sp], #4
 802632c: 4770         	bx	lr

0802632e <arch_k_cycle_get_32>:
; {
 802632e: b580         	push	{r7, lr}
 8026330: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 8026332: f7eb fa87    	bl	0x8011844 <sys_clock_cycle_get_32> @ imm = #-0x14af2
 8026336: 4603         	mov	r3, r0
; }
 8026338: 4618         	mov	r0, r3
 802633a: bd80         	pop	{r7, pc}

0802633c <k_cycle_get_32>:
; {
 802633c: b580         	push	{r7, lr}
 802633e: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 8026340: f7ff fff5    	bl	0x802632e <arch_k_cycle_get_32> @ imm = #-0x16
 8026344: 4603         	mov	r3, r0
; }
 8026346: 4618         	mov	r0, r3
 8026348: bd80         	pop	{r7, pc}

0802634a <z_impl_k_busy_wait>:
; {
 802634a: b580         	push	{r7, lr}
 802634c: b086         	sub	sp, #0x18
 802634e: af00         	add	r7, sp, #0x0
 8026350: 6078         	str	r0, [r7, #0x4]
; 	if (usec_to_wait == 0U) {
 8026352: 687b         	ldr	r3, [r7, #0x4]
 8026354: 2b00         	cmp	r3, #0x0
 8026356: d012         	beq	0x802637e <z_impl_k_busy_wait+0x34> @ imm = #0x24
; 	uint32_t start_cycles = k_cycle_get_32();
 8026358: f7ff fff0    	bl	0x802633c <k_cycle_get_32> @ imm = #-0x20
 802635c: 6178         	str	r0, [r7, #0x14]
; 	uint32_t cycles_to_wait = k_us_to_cyc_ceil32(usec_to_wait);
 802635e: 687b         	ldr	r3, [r7, #0x4]
 8026360: f240 2226    	movw	r2, #0x226
 8026364: fb02 f303    	mul	r3, r2, r3
 8026368: 613b         	str	r3, [r7, #0x10]
; 		uint32_t current_cycles = k_cycle_get_32();
 802636a: f7ff ffe7    	bl	0x802633c <k_cycle_get_32> @ imm = #-0x32
 802636e: 60f8         	str	r0, [r7, #0xc]
; 		if ((current_cycles - start_cycles) >= cycles_to_wait) {
 8026370: 68fa         	ldr	r2, [r7, #0xc]
 8026372: 697b         	ldr	r3, [r7, #0x14]
 8026374: 1ad3         	subs	r3, r2, r3
 8026376: 693a         	ldr	r2, [r7, #0x10]
 8026378: 429a         	cmp	r2, r3
 802637a: d902         	bls	0x8026382 <z_impl_k_busy_wait+0x38> @ imm = #0x4
; 	for (;;) {
 802637c: e7f5         	b	0x802636a <z_impl_k_busy_wait+0x20> @ imm = #-0x16
; 		return;
 802637e: bf00         	nop
 8026380: e000         	b	0x8026384 <z_impl_k_busy_wait+0x3a> @ imm = #0x0
; 			break;
 8026382: bf00         	nop
; }
 8026384: 3718         	adds	r7, #0x18
 8026386: 46bd         	mov	sp, r7
 8026388: bd80         	pop	{r7, pc}

0802638a <k_object_init>:
; {
 802638a: b480         	push	{r7}
 802638c: b083         	sub	sp, #0xc
 802638e: af00         	add	r7, sp, #0x0
 8026390: 6078         	str	r0, [r7, #0x4]
; }
 8026392: bf00         	nop
 8026394: 370c         	adds	r7, #0xc
 8026396: 46bd         	mov	sp, r7
 8026398: f85d 7b04    	ldr	r7, [sp], #4
 802639c: 4770         	bx	lr

0802639e <z_impl_device_is_ready>:
; {
 802639e: b480         	push	{r7}
 80263a0: b083         	sub	sp, #0xc
 80263a2: af00         	add	r7, sp, #0x0
 80263a4: 6078         	str	r0, [r7, #0x4]
; 	if (dev == NULL) {
 80263a6: 687b         	ldr	r3, [r7, #0x4]
 80263a8: 2b00         	cmp	r3, #0x0
 80263aa: d101         	bne	0x80263b0 <z_impl_device_is_ready+0x12> @ imm = #0x2
; 		return false;
 80263ac: 2300         	movs	r3, #0x0
 80263ae: e012         	b	0x80263d6 <z_impl_device_is_ready+0x38> @ imm = #0x24
; 	return dev->state->initialized && (dev->state->init_res == 0U);
 80263b0: 687b         	ldr	r3, [r7, #0x4]
 80263b2: 68db         	ldr	r3, [r3, #0xc]
 80263b4: 785b         	ldrb	r3, [r3, #0x1]
 80263b6: f003 0301    	and	r3, r3, #0x1
 80263ba: b2db         	uxtb	r3, r3
 80263bc: 2b00         	cmp	r3, #0x0
 80263be: d006         	beq	0x80263ce <z_impl_device_is_ready+0x30> @ imm = #0xc
 80263c0: 687b         	ldr	r3, [r7, #0x4]
 80263c2: 68db         	ldr	r3, [r3, #0xc]
 80263c4: 781b         	ldrb	r3, [r3]
 80263c6: 2b00         	cmp	r3, #0x0
 80263c8: d101         	bne	0x80263ce <z_impl_device_is_ready+0x30> @ imm = #0x2
 80263ca: 2301         	movs	r3, #0x1
 80263cc: e000         	b	0x80263d0 <z_impl_device_is_ready+0x32> @ imm = #0x0
 80263ce: 2300         	movs	r3, #0x0
 80263d0: f003 0301    	and	r3, r3, #0x1
 80263d4: b2db         	uxtb	r3, r3
; }
 80263d6: 4618         	mov	r0, r3
 80263d8: 370c         	adds	r7, #0xc
 80263da: 46bd         	mov	sp, r7
 80263dc: f85d 7b04    	ldr	r7, [sp], #4
 80263e0: 4770         	bx	lr

080263e2 <k_thread_abort>:
; {
 80263e2: b580         	push	{r7, lr}
 80263e4: b082         	sub	sp, #0x8
 80263e6: af00         	add	r7, sp, #0x0
 80263e8: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 80263ea: 6878         	ldr	r0, [r7, #0x4]
 80263ec: f7df ffe8    	bl	0x80063c0 <z_impl_k_thread_abort> @ imm = #-0x20030
; }
 80263f0: bf00         	nop
 80263f2: 3708         	adds	r7, #0x8
 80263f4: 46bd         	mov	sp, r7
 80263f6: bd80         	pop	{r7, pc}

080263f8 <z_log_msg_runtime_create>:
; {
 80263f8: b580         	push	{r7, lr}
 80263fa: b08a         	sub	sp, #0x28
 80263fc: af04         	add	r7, sp, #0x10
 80263fe: 60b9         	str	r1, [r7, #0x8]
 8026400: 607b         	str	r3, [r7, #0x4]
 8026402: 4603         	mov	r3, r0
 8026404: 73fb         	strb	r3, [r7, #0xf]
 8026406: 4613         	mov	r3, r2
 8026408: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 802640a: f107 032c    	add.w	r3, r7, #0x2c
 802640e: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8026410: 7bba         	ldrb	r2, [r7, #0xe]
 8026412: 7bf8         	ldrb	r0, [r7, #0xf]
 8026414: 697b         	ldr	r3, [r7, #0x14]
 8026416: 9303         	str	r3, [sp, #0xc]
 8026418: 6abb         	ldr	r3, [r7, #0x28]
 802641a: 9302         	str	r3, [sp, #0x8]
 802641c: 6a7b         	ldr	r3, [r7, #0x24]
 802641e: 9301         	str	r3, [sp, #0x4]
 8026420: 6a3b         	ldr	r3, [r7, #0x20]
 8026422: 9300         	str	r3, [sp]
 8026424: 687b         	ldr	r3, [r7, #0x4]
 8026426: 68b9         	ldr	r1, [r7, #0x8]
 8026428: f7de fba4    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x218b8
; }
 802642c: bf00         	nop
 802642e: 3718         	adds	r7, #0x18
 8026430: 46bd         	mov	sp, r7
 8026432: bd80         	pop	{r7, pc}

08026434 <log_panic>:
; {
 8026434: b580         	push	{r7, lr}
 8026436: af00         	add	r7, sp, #0x0
; 	z_impl_log_panic();
 8026438: f7de fa22    	bl	0x8004880 <z_impl_log_panic> @ imm = #-0x21bbc
; }
 802643c: bf00         	nop
 802643e: bd80         	pop	{r7, pc}

08026440 <coredump>:
; {
 8026440: b480         	push	{r7}
 8026442: b085         	sub	sp, #0x14
 8026444: af00         	add	r7, sp, #0x0
 8026446: 60f8         	str	r0, [r7, #0xc]
 8026448: 60b9         	str	r1, [r7, #0x8]
 802644a: 607a         	str	r2, [r7, #0x4]
; }
 802644c: bf00         	nop
 802644e: 3714         	adds	r7, #0x14
 8026450: 46bd         	mov	sp, r7
 8026452: f85d 7b04    	ldr	r7, [sp], #4
 8026456: 4770         	bx	lr

08026458 <arch_system_halt>:
; {
 8026458: b480         	push	{r7}
 802645a: b087         	sub	sp, #0x1c
 802645c: af00         	add	r7, sp, #0x0
 802645e: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8026460: f3ef 8311    	mrs	r3, basepri
 8026464: 617b         	str	r3, [r7, #0x14]
;   return(result);
 8026466: 697b         	ldr	r3, [r7, #0x14]
; 	key = __get_BASEPRI();
 8026468: 613b         	str	r3, [r7, #0x10]
 802646a: 2310         	movs	r3, #0x10
 802646c: 60fb         	str	r3, [r7, #0xc]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 802646e: 68fb         	ldr	r3, [r7, #0xc]
 8026470: f383 8812    	msr	basepri_max, r3
; }
 8026474: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8026476: f3bf 8f6f    	isb	sy
; }
 802647a: bf00         	nop
; 	for (;;) {
 802647c: bf00         	nop
 802647e: e7fd         	b	0x802647c <arch_system_halt+0x24> @ imm = #-0x6

08026480 <K_KERNEL_STACK_BUFFER>:
; {
 8026480: b480         	push	{r7}
 8026482: b083         	sub	sp, #0xc
 8026484: af00         	add	r7, sp, #0x0
 8026486: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 8026488: 687b         	ldr	r3, [r7, #0x4]
; }
 802648a: 4618         	mov	r0, r3
 802648c: 370c         	adds	r7, #0xc
 802648e: 46bd         	mov	sp, r7
 8026490: f85d 7b04    	ldr	r7, [sp], #4
 8026494: 4770         	bx	lr

08026496 <k_thread_start>:
; {
 8026496: b580         	push	{r7, lr}
 8026498: b082         	sub	sp, #0x8
 802649a: af00         	add	r7, sp, #0x0
 802649c: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 802649e: 6878         	ldr	r0, [r7, #0x4]
 80264a0: f000 f804    	bl	0x80264ac <k_thread_resume> @ imm = #0x8
; }
 80264a4: bf00         	nop
 80264a6: 3708         	adds	r7, #0x8
 80264a8: 46bd         	mov	sp, r7
 80264aa: bd80         	pop	{r7, pc}

080264ac <k_thread_resume>:
; {
 80264ac: b580         	push	{r7, lr}
 80264ae: b082         	sub	sp, #0x8
 80264b0: af00         	add	r7, sp, #0x0
 80264b2: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 80264b4: 6878         	ldr	r0, [r7, #0x4]
 80264b6: f7f0 faff    	bl	0x8016ab8 <z_impl_k_thread_resume> @ imm = #-0xfa02
; }
 80264ba: bf00         	nop
 80264bc: 3708         	adds	r7, #0x8
 80264be: 46bd         	mov	sp, r7
 80264c0: bd80         	pop	{r7, pc}

080264c2 <thread_schedule_new>:
; {
 80264c2: b580         	push	{r7, lr}
 80264c4: b084         	sub	sp, #0x10
 80264c6: af00         	add	r7, sp, #0x0
 80264c8: 60f8         	str	r0, [r7, #0xc]
 80264ca: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 80264ce: e9d7 2300    	ldrd	r2, r3, [r7]
 80264d2: f04f 0000    	mov.w	r0, #0x0
 80264d6: f04f 0100    	mov.w	r1, #0x0
 80264da: 428b         	cmp	r3, r1
 80264dc: bf08         	it	eq
 80264de: 4282         	cmpeq	r2, r0
 80264e0: d103         	bne	0x80264ea <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 80264e2: 68f8         	ldr	r0, [r7, #0xc]
 80264e4: f7ff ffd7    	bl	0x8026496 <k_thread_start> @ imm = #-0x52
 80264e8: e004         	b	0x80264f4 <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 80264ea: e9d7 2300    	ldrd	r2, r3, [r7]
 80264ee: 68f8         	ldr	r0, [r7, #0xc]
 80264f0: f7ee f8d2    	bl	0x8014698 <z_add_thread_timeout> @ imm = #-0x11e5c
; }
 80264f4: bf00         	nop
 80264f6: 3710         	adds	r7, #0x10
 80264f8: 46bd         	mov	sp, r7
 80264fa: bd80         	pop	{r7, pc}

080264fc <z_mark_thread_as_not_suspended>:
; {
 80264fc: b480         	push	{r7}
 80264fe: b083         	sub	sp, #0xc
 8026500: af00         	add	r7, sp, #0x0
 8026502: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 8026504: 687b         	ldr	r3, [r7, #0x4]
 8026506: 7b5b         	ldrb	r3, [r3, #0xd]
 8026508: f023 0310    	bic	r3, r3, #0x10
 802650c: b2da         	uxtb	r2, r3
 802650e: 687b         	ldr	r3, [r7, #0x4]
 8026510: 735a         	strb	r2, [r3, #0xd]
; }
 8026512: bf00         	nop
 8026514: 370c         	adds	r7, #0xc
 8026516: 46bd         	mov	sp, r7
 8026518: f85d 7b04    	ldr	r7, [sp], #4
 802651c: 4770         	bx	lr

0802651e <z_thread_essential_clear>:
; {
 802651e: b480         	push	{r7}
 8026520: b083         	sub	sp, #0xc
 8026522: af00         	add	r7, sp, #0x0
 8026524: 6078         	str	r0, [r7, #0x4]
; 	thread->base.user_options &= ~K_ESSENTIAL;
 8026526: 687b         	ldr	r3, [r7, #0x4]
 8026528: 7b1b         	ldrb	r3, [r3, #0xc]
 802652a: f023 0301    	bic	r3, r3, #0x1
 802652e: b2da         	uxtb	r2, r3
 8026530: 687b         	ldr	r3, [r7, #0x4]
 8026532: 731a         	strb	r2, [r3, #0xc]
; }
 8026534: bf00         	nop
 8026536: 370c         	adds	r7, #0xc
 8026538: 46bd         	mov	sp, r7
 802653a: f85d 7b04    	ldr	r7, [sp], #4
 802653e: 4770         	bx	lr

08026540 <gcov_static_init>:
; static inline void gcov_static_init(void) { }
 8026540: b480         	push	{r7}
 8026542: af00         	add	r7, sp, #0x0
 8026544: bf00         	nop
 8026546: 46bd         	mov	sp, r7
 8026548: f85d 7b04    	ldr	r7, [sp], #4
 802654c: 4770         	bx	lr

0802654e <pm_device_runtime_auto_enable>:
; {
 802654e: b480         	push	{r7}
 8026550: b083         	sub	sp, #0xc
 8026552: af00         	add	r7, sp, #0x0
 8026554: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8026556: 2300         	movs	r3, #0x0
; }
 8026558: 4618         	mov	r0, r3
 802655a: 370c         	adds	r7, #0xc
 802655c: 46bd         	mov	sp, r7
 802655e: f85d 7b04    	ldr	r7, [sp], #4
 8026562: 4770         	bx	lr

08026564 <z_early_memset>:
; {
 8026564: b580         	push	{r7, lr}
 8026566: b084         	sub	sp, #0x10
 8026568: af00         	add	r7, sp, #0x0
 802656a: 60f8         	str	r0, [r7, #0xc]
 802656c: 60b9         	str	r1, [r7, #0x8]
 802656e: 607a         	str	r2, [r7, #0x4]
; 	(void) memset(dst, c, n);
 8026570: 687a         	ldr	r2, [r7, #0x4]
 8026572: 68b9         	ldr	r1, [r7, #0x8]
 8026574: 68f8         	ldr	r0, [r7, #0xc]
 8026576: f002 fdcb    	bl	0x8029110 <memset>      @ imm = #0x2b96
; }
 802657a: bf00         	nop
 802657c: 3710         	adds	r7, #0x10
 802657e: 46bd         	mov	sp, r7
 8026580: bd80         	pop	{r7, pc}

08026582 <z_early_memcpy>:
; {
 8026582: b580         	push	{r7, lr}
 8026584: b084         	sub	sp, #0x10
 8026586: af00         	add	r7, sp, #0x0
 8026588: 60f8         	str	r0, [r7, #0xc]
 802658a: 60b9         	str	r1, [r7, #0x8]
 802658c: 607a         	str	r2, [r7, #0x4]
; 	(void) memcpy(dst, src, n);
 802658e: 687a         	ldr	r2, [r7, #0x4]
 8026590: 68b9         	ldr	r1, [r7, #0x8]
 8026592: 68f8         	ldr	r0, [r7, #0xc]
 8026594: f002 fdae    	bl	0x80290f4 <memcpy>      @ imm = #0x2b5c
; }
 8026598: bf00         	nop
 802659a: 3710         	adds	r7, #0x10
 802659c: 46bd         	mov	sp, r7
 802659e: bd80         	pop	{r7, pc}

080265a0 <do_device_init>:
; {
 80265a0: b580         	push	{r7, lr}
 80265a2: b084         	sub	sp, #0x10
 80265a4: af00         	add	r7, sp, #0x0
 80265a6: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = entry->dev;
 80265a8: 687b         	ldr	r3, [r7, #0x4]
 80265aa: 685b         	ldr	r3, [r3, #0x4]
 80265ac: 60bb         	str	r3, [r7, #0x8]
; 	int rc = 0;
 80265ae: 2300         	movs	r3, #0x0
 80265b0: 60fb         	str	r3, [r7, #0xc]
; 	if (entry->init_fn.dev != NULL) {
 80265b2: 687b         	ldr	r3, [r7, #0x4]
 80265b4: 681b         	ldr	r3, [r3]
 80265b6: 2b00         	cmp	r3, #0x0
 80265b8: d017         	beq	0x80265ea <do_device_init+0x4a> @ imm = #0x2e
; 		rc = entry->init_fn.dev(dev);
 80265ba: 687b         	ldr	r3, [r7, #0x4]
 80265bc: 681b         	ldr	r3, [r3]
 80265be: 68b8         	ldr	r0, [r7, #0x8]
 80265c0: 4798         	blx	r3
 80265c2: 60f8         	str	r0, [r7, #0xc]
; 		if (rc != 0) {
 80265c4: 68fb         	ldr	r3, [r7, #0xc]
 80265c6: 2b00         	cmp	r3, #0x0
 80265c8: d00f         	beq	0x80265ea <do_device_init+0x4a> @ imm = #0x1e
; 			if (rc < 0) {
 80265ca: 68fb         	ldr	r3, [r7, #0xc]
 80265cc: 2b00         	cmp	r3, #0x0
 80265ce: da02         	bge	0x80265d6 <do_device_init+0x36> @ imm = #0x4
; 				rc = -rc;
 80265d0: 68fb         	ldr	r3, [r7, #0xc]
 80265d2: 425b         	rsbs	r3, r3, #0
 80265d4: 60fb         	str	r3, [r7, #0xc]
; 			if (rc > UINT8_MAX) {
 80265d6: 68fb         	ldr	r3, [r7, #0xc]
 80265d8: 2bff         	cmp	r3, #0xff
 80265da: dd01         	ble	0x80265e0 <do_device_init+0x40> @ imm = #0x2
; 				rc = UINT8_MAX;
 80265dc: 23ff         	movs	r3, #0xff
 80265de: 60fb         	str	r3, [r7, #0xc]
; 			dev->state->init_res = rc;
 80265e0: 68bb         	ldr	r3, [r7, #0x8]
 80265e2: 68db         	ldr	r3, [r3, #0xc]
 80265e4: 68fa         	ldr	r2, [r7, #0xc]
 80265e6: b2d2         	uxtb	r2, r2
 80265e8: 701a         	strb	r2, [r3]
; 	dev->state->initialized = true;
 80265ea: 68bb         	ldr	r3, [r7, #0x8]
 80265ec: 68da         	ldr	r2, [r3, #0xc]
 80265ee: 7853         	ldrb	r3, [r2, #0x1]
 80265f0: f043 0301    	orr	r3, r3, #0x1
 80265f4: 7053         	strb	r3, [r2, #0x1]
; 	if (rc == 0) {
 80265f6: 68fb         	ldr	r3, [r7, #0xc]
 80265f8: 2b00         	cmp	r3, #0x0
 80265fa: d102         	bne	0x8026602 <do_device_init+0x62> @ imm = #0x4
; 		(void)pm_device_runtime_auto_enable(dev);
 80265fc: 68b8         	ldr	r0, [r7, #0x8]
 80265fe: f7ff ffa6    	bl	0x802654e <pm_device_runtime_auto_enable> @ imm = #-0xb4
; 	return rc;
 8026602: 68fb         	ldr	r3, [r7, #0xc]
; }
 8026604: 4618         	mov	r0, r3
 8026606: 3710         	adds	r7, #0x10
 8026608: 46bd         	mov	sp, r7
 802660a: bd80         	pop	{r7, pc}

0802660c <z_init_static>:
; {
 802660c: b480         	push	{r7}
 802660e: af00         	add	r7, sp, #0x0
; }
 8026610: bf00         	nop
 8026612: 46bd         	mov	sp, r7
 8026614: f85d 7b04    	ldr	r7, [sp], #4
 8026618: 4770         	bx	lr

0802661a <sys_dlist_init>:
; {
 802661a: b480         	push	{r7}
 802661c: b083         	sub	sp, #0xc
 802661e: af00         	add	r7, sp, #0x0
 8026620: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8026622: 687b         	ldr	r3, [r7, #0x4]
 8026624: 687a         	ldr	r2, [r7, #0x4]
 8026626: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8026628: 687b         	ldr	r3, [r7, #0x4]
 802662a: 687a         	ldr	r2, [r7, #0x4]
 802662c: 605a         	str	r2, [r3, #0x4]
; }
 802662e: bf00         	nop
 8026630: 370c         	adds	r7, #0xc
 8026632: 46bd         	mov	sp, r7
 8026634: f85d 7b04    	ldr	r7, [sp], #4
 8026638: 4770         	bx	lr

0802663a <z_waitq_init>:
; {
 802663a: b580         	push	{r7, lr}
 802663c: b082         	sub	sp, #0x8
 802663e: af00         	add	r7, sp, #0x0
 8026640: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8026642: 687b         	ldr	r3, [r7, #0x4]
 8026644: 4618         	mov	r0, r3
 8026646: f7ff ffe8    	bl	0x802661a <sys_dlist_init> @ imm = #-0x30
; }
 802664a: bf00         	nop
 802664c: 3708         	adds	r7, #0x8
 802664e: 46bd         	mov	sp, r7
 8026650: bd80         	pop	{r7, pc}

08026652 <k_heap_init>:
; {
 8026652: b580         	push	{r7, lr}
 8026654: b084         	sub	sp, #0x10
 8026656: af00         	add	r7, sp, #0x0
 8026658: 60f8         	str	r0, [r7, #0xc]
 802665a: 60b9         	str	r1, [r7, #0x8]
 802665c: 607a         	str	r2, [r7, #0x4]
; 	z_waitq_init(&heap->wait_q);
 802665e: 68fb         	ldr	r3, [r7, #0xc]
 8026660: 330c         	adds	r3, #0xc
 8026662: 4618         	mov	r0, r3
 8026664: f7ff ffe9    	bl	0x802663a <z_waitq_init> @ imm = #-0x2e
; 	sys_heap_init(&heap->heap, mem, bytes);
 8026668: 68fb         	ldr	r3, [r7, #0xc]
 802666a: 687a         	ldr	r2, [r7, #0x4]
 802666c: 68b9         	ldr	r1, [r7, #0x8]
 802666e: 4618         	mov	r0, r3
 8026670: f7f5 fe86    	bl	0x801c380 <sys_heap_init> @ imm = #-0xa2f4
; }
 8026674: bf00         	nop
 8026676: 3710         	adds	r7, #0x10
 8026678: 46bd         	mov	sp, r7
 802667a: bd80         	pop	{r7, pc}

0802667c <k_heap_aligned_alloc>:
; {
 802667c: b580         	push	{r7, lr}
 802667e: b09e         	sub	sp, #0x78
 8026680: af02         	add	r7, sp, #0x8
 8026682: 60f8         	str	r0, [r7, #0xc]
 8026684: 60b9         	str	r1, [r7, #0x8]
 8026686: 607a         	str	r2, [r7, #0x4]
; 	k_timepoint_t end = sys_timepoint_calc(timeout);
 8026688: f107 0120    	add.w	r1, r7, #0x20
 802668c: e9d7 231e    	ldrd	r2, r3, [r7, #120]
 8026690: 4608         	mov	r0, r1
 8026692: f002 fbab    	bl	0x8028dec <sys_timepoint_calc> @ imm = #0x2756
; 	void *ret = NULL;
 8026696: 2300         	movs	r3, #0x0
 8026698: 66fb         	str	r3, [r7, #0x6c]
; 	k_spinlock_key_t key = k_spin_lock(&heap->lock);
 802669a: 68fb         	ldr	r3, [r7, #0xc]
 802669c: 3314         	adds	r3, #0x14
 802669e: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80266a0: f3ef 8311    	mrs	r3, basepri
 80266a4: 663b         	str	r3, [r7, #0x60]
;   return(result);
 80266a6: 6e3b         	ldr	r3, [r7, #0x60]
; 	key = __get_BASEPRI();
 80266a8: 65fb         	str	r3, [r7, #0x5c]
 80266aa: 2310         	movs	r3, #0x10
 80266ac: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80266ae: 6dbb         	ldr	r3, [r7, #0x58]
 80266b0: f383 8812    	msr	basepri_max, r3
; }
 80266b4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80266b6: f3bf 8f6f    	isb	sy
; }
 80266ba: bf00         	nop
; 	return key;
 80266bc: 6dfb         	ldr	r3, [r7, #0x5c]
; 	k.key = arch_irq_lock();
 80266be: 613b         	str	r3, [r7, #0x10]
 80266c0: 6e7b         	ldr	r3, [r7, #0x64]
 80266c2: 657b         	str	r3, [r7, #0x54]
; }
 80266c4: bf00         	nop
 80266c6: 6e7b         	ldr	r3, [r7, #0x64]
 80266c8: 653b         	str	r3, [r7, #0x50]
; }
 80266ca: bf00         	nop
; 	return k;
 80266cc: 693b         	ldr	r3, [r7, #0x10]
 80266ce: 61fb         	str	r3, [r7, #0x1c]
; 	bool blocked_alloc = false;
 80266d0: 2300         	movs	r3, #0x0
 80266d2: f887 306b    	strb.w	r3, [r7, #0x6b]
; 	while (ret == NULL) {
 80266d6: e04d         	b	0x8026774 <k_heap_aligned_alloc+0xf8> @ imm = #0x9a
; 		ret = sys_heap_aligned_alloc(&heap->heap, align, bytes);
 80266d8: 68fb         	ldr	r3, [r7, #0xc]
 80266da: 687a         	ldr	r2, [r7, #0x4]
 80266dc: 68b9         	ldr	r1, [r7, #0x8]
 80266de: 4618         	mov	r0, r3
 80266e0: f7f5 fda5    	bl	0x801c22e <sys_heap_aligned_alloc> @ imm = #-0xa4b6
 80266e4: 66f8         	str	r0, [r7, #0x6c]
; 		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
 80266e6: 6efb         	ldr	r3, [r7, #0x6c]
 80266e8: 2b00         	cmp	r3, #0x0
 80266ea: d146         	bne	0x802677a <k_heap_aligned_alloc+0xfe> @ imm = #0x8c
; 		    (ret != NULL) || K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 80266ec: e9d7 231e    	ldrd	r2, r3, [r7, #120]
 80266f0: f04f 0000    	mov.w	r0, #0x0
 80266f4: f04f 0100    	mov.w	r1, #0x0
 80266f8: 428b         	cmp	r3, r1
 80266fa: bf08         	it	eq
 80266fc: 4282         	cmpeq	r2, r0
 80266fe: d03c         	beq	0x802677a <k_heap_aligned_alloc+0xfe> @ imm = #0x78
; 		if (!blocked_alloc) {
 8026700: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 8026704: f083 0301    	eor	r3, r3, #0x1
 8026708: b2db         	uxtb	r3, r3
 802670a: 2b00         	cmp	r3, #0x0
 802670c: d100         	bne	0x8026710 <k_heap_aligned_alloc+0x94> @ imm = #0x0
 802670e: e002         	b	0x8026716 <k_heap_aligned_alloc+0x9a> @ imm = #0x4
; 			blocked_alloc = true;
 8026710: 2301         	movs	r3, #0x1
 8026712: f887 306b    	strb.w	r3, [r7, #0x6b]
; 		timeout = sys_timepoint_timeout(end);
 8026716: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 802671a: f107 0078    	add.w	r0, r7, #0x78
 802671e: f002 fbca    	bl	0x8028eb6 <sys_timepoint_timeout> @ imm = #0x2794
; 		(void) z_pend_curr(&heap->lock, key, &heap->wait_q, timeout);
 8026722: 68fb         	ldr	r3, [r7, #0xc]
 8026724: f103 0014    	add.w	r0, r3, #0x14
 8026728: 68fb         	ldr	r3, [r7, #0xc]
 802672a: f103 010c    	add.w	r1, r3, #0xc
 802672e: e9d7 231e    	ldrd	r2, r3, [r7, #120]
 8026732: e9cd 2300    	strd	r2, r3, [sp]
 8026736: 460a         	mov	r2, r1
 8026738: 69f9         	ldr	r1, [r7, #0x1c]
 802673a: f7f0 fb65    	bl	0x8016e08 <z_pend_curr> @ imm = #-0xf936
; 		key = k_spin_lock(&heap->lock);
 802673e: 68fb         	ldr	r3, [r7, #0xc]
 8026740: 3314         	adds	r3, #0x14
 8026742: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8026744: f3ef 8311    	mrs	r3, basepri
 8026748: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 802674a: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 802674c: 647b         	str	r3, [r7, #0x44]
 802674e: 2310         	movs	r3, #0x10
 8026750: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8026752: 6c3b         	ldr	r3, [r7, #0x40]
 8026754: f383 8812    	msr	basepri_max, r3
; }
 8026758: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 802675a: f3bf 8f6f    	isb	sy
; }
 802675e: bf00         	nop
; 	return key;
 8026760: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 8026762: 617b         	str	r3, [r7, #0x14]
 8026764: 6cfb         	ldr	r3, [r7, #0x4c]
 8026766: 63fb         	str	r3, [r7, #0x3c]
; }
 8026768: bf00         	nop
 802676a: 6cfb         	ldr	r3, [r7, #0x4c]
 802676c: 63bb         	str	r3, [r7, #0x38]
; }
 802676e: bf00         	nop
; 	return k;
 8026770: 697b         	ldr	r3, [r7, #0x14]
 8026772: 61fb         	str	r3, [r7, #0x1c]
; 	while (ret == NULL) {
 8026774: 6efb         	ldr	r3, [r7, #0x6c]
 8026776: 2b00         	cmp	r3, #0x0
 8026778: d0ae         	beq	0x80266d8 <k_heap_aligned_alloc+0x5c> @ imm = #-0xa4
; 	k_spin_unlock(&heap->lock, key);
 802677a: 68fb         	ldr	r3, [r7, #0xc]
 802677c: 3314         	adds	r3, #0x14
 802677e: 637b         	str	r3, [r7, #0x34]
 8026780: 69fb         	ldr	r3, [r7, #0x1c]
 8026782: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8026784: 69bb         	ldr	r3, [r7, #0x18]
 8026786: 633b         	str	r3, [r7, #0x30]
 8026788: 6b3b         	ldr	r3, [r7, #0x30]
 802678a: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 802678c: 6afb         	ldr	r3, [r7, #0x2c]
 802678e: f383 8811    	msr	basepri, r3
; }
 8026792: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8026794: f3bf 8f6f    	isb	sy
; }
 8026798: bf00         	nop
; }
 802679a: bf00         	nop
; }
 802679c: bf00         	nop
; 	return ret;
 802679e: 6efb         	ldr	r3, [r7, #0x6c]
; }
 80267a0: 4618         	mov	r0, r3
 80267a2: 3770         	adds	r7, #0x70
 80267a4: 46bd         	mov	sp, r7
 80267a6: bd80         	pop	{r7, pc}

080267a8 <k_heap_free>:
; {
 80267a8: b580         	push	{r7, lr}
 80267aa: b08e         	sub	sp, #0x38
 80267ac: af00         	add	r7, sp, #0x0
 80267ae: 6078         	str	r0, [r7, #0x4]
 80267b0: 6039         	str	r1, [r7]
; 	k_spinlock_key_t key = k_spin_lock(&heap->lock);
 80267b2: 687b         	ldr	r3, [r7, #0x4]
 80267b4: 3314         	adds	r3, #0x14
 80267b6: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80267b8: f3ef 8311    	mrs	r3, basepri
 80267bc: 633b         	str	r3, [r7, #0x30]
;   return(result);
 80267be: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 80267c0: 62fb         	str	r3, [r7, #0x2c]
 80267c2: 2310         	movs	r3, #0x10
 80267c4: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80267c6: 6abb         	ldr	r3, [r7, #0x28]
 80267c8: f383 8812    	msr	basepri_max, r3
; }
 80267cc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80267ce: f3bf 8f6f    	isb	sy
; }
 80267d2: bf00         	nop
; 	return key;
 80267d4: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 80267d6: 60bb         	str	r3, [r7, #0x8]
 80267d8: 6b7b         	ldr	r3, [r7, #0x34]
 80267da: 627b         	str	r3, [r7, #0x24]
; }
 80267dc: bf00         	nop
 80267de: 6b7b         	ldr	r3, [r7, #0x34]
 80267e0: 623b         	str	r3, [r7, #0x20]
; }
 80267e2: bf00         	nop
; 	return k;
 80267e4: 68bb         	ldr	r3, [r7, #0x8]
 80267e6: 613b         	str	r3, [r7, #0x10]
; 	sys_heap_free(&heap->heap, mem);
 80267e8: 687b         	ldr	r3, [r7, #0x4]
 80267ea: 6839         	ldr	r1, [r7]
 80267ec: 4618         	mov	r0, r3
 80267ee: f7f5 fc55    	bl	0x801c09c <sys_heap_free> @ imm = #-0xa756
; 	if (IS_ENABLED(CONFIG_MULTITHREADING) && (z_unpend_all(&heap->wait_q) != 0)) {
 80267f2: 687b         	ldr	r3, [r7, #0x4]
 80267f4: 330c         	adds	r3, #0xc
 80267f6: 4618         	mov	r0, r3
 80267f8: f002 f905    	bl	0x8028a06 <z_unpend_all> @ imm = #0x220a
 80267fc: 4603         	mov	r3, r0
 80267fe: 2b00         	cmp	r3, #0x0
 8026800: d006         	beq	0x8026810 <k_heap_free+0x68> @ imm = #0xc
; 		z_reschedule(&heap->lock, key);
 8026802: 687b         	ldr	r3, [r7, #0x4]
 8026804: 3314         	adds	r3, #0x14
 8026806: 6939         	ldr	r1, [r7, #0x10]
 8026808: 4618         	mov	r0, r3
 802680a: f002 f8a7    	bl	0x802895c <z_reschedule> @ imm = #0x214e
; }
 802680e: e011         	b	0x8026834 <k_heap_free+0x8c> @ imm = #0x22
; 		k_spin_unlock(&heap->lock, key);
 8026810: 687b         	ldr	r3, [r7, #0x4]
 8026812: 3314         	adds	r3, #0x14
 8026814: 61fb         	str	r3, [r7, #0x1c]
 8026816: 693b         	ldr	r3, [r7, #0x10]
 8026818: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 802681a: 68fb         	ldr	r3, [r7, #0xc]
 802681c: 61bb         	str	r3, [r7, #0x18]
 802681e: 69bb         	ldr	r3, [r7, #0x18]
 8026820: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8026822: 697b         	ldr	r3, [r7, #0x14]
 8026824: f383 8811    	msr	basepri, r3
; }
 8026828: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 802682a: f3bf 8f6f    	isb	sy
; }
 802682e: bf00         	nop
; }
 8026830: bf00         	nop
; }
 8026832: bf00         	nop
; }
 8026834: bf00         	nop
 8026836: 3738         	adds	r7, #0x38
 8026838: 46bd         	mov	sp, r7
 802683a: bd80         	pop	{r7, pc}

0802683c <sys_dnode_init>:
; {
 802683c: b480         	push	{r7}
 802683e: b083         	sub	sp, #0xc
 8026840: af00         	add	r7, sp, #0x0
 8026842: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8026844: 687b         	ldr	r3, [r7, #0x4]
 8026846: 2200         	movs	r2, #0x0
 8026848: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 802684a: 687b         	ldr	r3, [r7, #0x4]
 802684c: 2200         	movs	r2, #0x0
 802684e: 605a         	str	r2, [r3, #0x4]
; }
 8026850: bf00         	nop
 8026852: 370c         	adds	r7, #0xc
 8026854: 46bd         	mov	sp, r7
 8026856: f85d 7b04    	ldr	r7, [sp], #4
 802685a: 4770         	bx	lr

0802685c <sys_dlist_is_empty>:
; {
 802685c: b480         	push	{r7}
 802685e: b083         	sub	sp, #0xc
 8026860: af00         	add	r7, sp, #0x0
 8026862: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8026864: 687b         	ldr	r3, [r7, #0x4]
 8026866: 681b         	ldr	r3, [r3]
 8026868: 687a         	ldr	r2, [r7, #0x4]
 802686a: 429a         	cmp	r2, r3
 802686c: bf0c         	ite	eq
 802686e: 2301         	moveq	r3, #0x1
 8026870: 2300         	movne	r3, #0x0
 8026872: b2db         	uxtb	r3, r3
; }
 8026874: 4618         	mov	r0, r3
 8026876: 370c         	adds	r7, #0xc
 8026878: 46bd         	mov	sp, r7
 802687a: f85d 7b04    	ldr	r7, [sp], #4
 802687e: 4770         	bx	lr

08026880 <sys_dlist_peek_head>:
; {
 8026880: b580         	push	{r7, lr}
 8026882: b082         	sub	sp, #0x8
 8026884: af00         	add	r7, sp, #0x0
 8026886: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8026888: 6878         	ldr	r0, [r7, #0x4]
 802688a: f7ff ffe7    	bl	0x802685c <sys_dlist_is_empty> @ imm = #-0x32
 802688e: 4603         	mov	r3, r0
 8026890: 2b00         	cmp	r3, #0x0
 8026892: d102         	bne	0x802689a <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8026894: 687b         	ldr	r3, [r7, #0x4]
 8026896: 681b         	ldr	r3, [r3]
 8026898: e000         	b	0x802689c <sys_dlist_peek_head+0x1c> @ imm = #0x0
 802689a: 2300         	movs	r3, #0x0
; }
 802689c: 4618         	mov	r0, r3
 802689e: 3708         	adds	r7, #0x8
 80268a0: 46bd         	mov	sp, r7
 80268a2: bd80         	pop	{r7, pc}

080268a4 <sys_dlist_remove>:
; {
 80268a4: b580         	push	{r7, lr}
 80268a6: b084         	sub	sp, #0x10
 80268a8: af00         	add	r7, sp, #0x0
 80268aa: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 80268ac: 687b         	ldr	r3, [r7, #0x4]
 80268ae: 685b         	ldr	r3, [r3, #0x4]
 80268b0: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 80268b2: 687b         	ldr	r3, [r7, #0x4]
 80268b4: 681b         	ldr	r3, [r3]
 80268b6: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 80268b8: 68fb         	ldr	r3, [r7, #0xc]
 80268ba: 68ba         	ldr	r2, [r7, #0x8]
 80268bc: 601a         	str	r2, [r3]
; 	next->prev = prev;
 80268be: 68bb         	ldr	r3, [r7, #0x8]
 80268c0: 68fa         	ldr	r2, [r7, #0xc]
 80268c2: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 80268c4: 6878         	ldr	r0, [r7, #0x4]
 80268c6: f7ff ffb9    	bl	0x802683c <sys_dnode_init> @ imm = #-0x8e
; }
 80268ca: bf00         	nop
 80268cc: 3710         	adds	r7, #0x10
 80268ce: 46bd         	mov	sp, r7
 80268d0: bd80         	pop	{r7, pc}

080268d2 <k_object_init>:
; {
 80268d2: b480         	push	{r7}
 80268d4: b083         	sub	sp, #0xc
 80268d6: af00         	add	r7, sp, #0x0
 80268d8: 6078         	str	r0, [r7, #0x4]
; }
 80268da: bf00         	nop
 80268dc: 370c         	adds	r7, #0xc
 80268de: 46bd         	mov	sp, r7
 80268e0: f85d 7b04    	ldr	r7, [sp], #4
 80268e4: 4770         	bx	lr

080268e6 <z_abort_thread_timeout>:
; {
 80268e6: b580         	push	{r7, lr}
 80268e8: b082         	sub	sp, #0x8
 80268ea: af00         	add	r7, sp, #0x0
 80268ec: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 80268ee: 687b         	ldr	r3, [r7, #0x4]
 80268f0: 3318         	adds	r3, #0x18
 80268f2: 4618         	mov	r0, r3
 80268f4: f7f1 fcc4    	bl	0x8018280 <z_abort_timeout> @ imm = #-0xe678
 80268f8: 4603         	mov	r3, r0
; }
 80268fa: 4618         	mov	r0, r3
 80268fc: 3708         	adds	r7, #0x8
 80268fe: 46bd         	mov	sp, r7
 8026900: bd80         	pop	{r7, pc}

08026902 <z_mark_thread_as_not_pending>:
; {
 8026902: b480         	push	{r7}
 8026904: b083         	sub	sp, #0xc
 8026906: af00         	add	r7, sp, #0x0
 8026908: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 802690a: 687b         	ldr	r3, [r7, #0x4]
 802690c: 7b5b         	ldrb	r3, [r3, #0xd]
 802690e: f023 0302    	bic	r3, r3, #0x2
 8026912: b2da         	uxtb	r2, r3
 8026914: 687b         	ldr	r3, [r7, #0x4]
 8026916: 735a         	strb	r2, [r3, #0xd]
; }
 8026918: bf00         	nop
 802691a: 370c         	adds	r7, #0xc
 802691c: 46bd         	mov	sp, r7
 802691e: f85d 7b04    	ldr	r7, [sp], #4
 8026922: 4770         	bx	lr

08026924 <unpend_thread_no_timeout>:
; {
 8026924: b580         	push	{r7, lr}
 8026926: b086         	sub	sp, #0x18
 8026928: af00         	add	r7, sp, #0x0
 802692a: 6078         	str	r0, [r7, #0x4]
 802692c: 687b         	ldr	r3, [r7, #0x4]
 802692e: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8026930: 68fb         	ldr	r3, [r7, #0xc]
 8026932: 689b         	ldr	r3, [r3, #0x8]
 8026934: 617b         	str	r3, [r7, #0x14]
 8026936: 687b         	ldr	r3, [r7, #0x4]
 8026938: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 802693a: 693b         	ldr	r3, [r7, #0x10]
 802693c: 4618         	mov	r0, r3
 802693e: f7ff ffb1    	bl	0x80268a4 <sys_dlist_remove> @ imm = #-0x9e
; }
 8026942: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8026944: 6878         	ldr	r0, [r7, #0x4]
 8026946: f7ff ffdc    	bl	0x8026902 <z_mark_thread_as_not_pending> @ imm = #-0x48
; 	thread->base.pended_on = NULL;
 802694a: 687b         	ldr	r3, [r7, #0x4]
 802694c: 2200         	movs	r2, #0x0
 802694e: 609a         	str	r2, [r3, #0x8]
; }
 8026950: bf00         	nop
 8026952: 3718         	adds	r7, #0x18
 8026954: 46bd         	mov	sp, r7
 8026956: bd80         	pop	{r7, pc}

08026958 <create_free_list>:
; {
 8026958: b480         	push	{r7}
 802695a: b085         	sub	sp, #0x14
 802695c: af00         	add	r7, sp, #0x0
 802695e: 6078         	str	r0, [r7, #0x4]
; 	CHECKIF(((slab->info.block_size | (uintptr_t)slab->buffer) &
 8026960: 687b         	ldr	r3, [r7, #0x4]
 8026962: 695b         	ldr	r3, [r3, #0x14]
 8026964: 687a         	ldr	r2, [r7, #0x4]
 8026966: 6892         	ldr	r2, [r2, #0x8]
 8026968: 4313         	orrs	r3, r2
 802696a: f003 0303    	and	r3, r3, #0x3
 802696e: 2b00         	cmp	r3, #0x0
 8026970: d002         	beq	0x8026978 <create_free_list+0x20> @ imm = #0x4
; 		return -EINVAL;
 8026972: f06f 0315    	mvn	r3, #0x15
 8026976: e021         	b	0x80269bc <create_free_list+0x64> @ imm = #0x42
; 	slab->free_list = NULL;
 8026978: 687b         	ldr	r3, [r7, #0x4]
 802697a: 2200         	movs	r2, #0x0
 802697c: 60da         	str	r2, [r3, #0xc]
; 	p = slab->buffer + slab->info.block_size * (slab->info.num_blocks - 1);
 802697e: 687b         	ldr	r3, [r7, #0x4]
 8026980: 689a         	ldr	r2, [r3, #0x8]
 8026982: 687b         	ldr	r3, [r7, #0x4]
 8026984: 695b         	ldr	r3, [r3, #0x14]
 8026986: 6879         	ldr	r1, [r7, #0x4]
 8026988: 6909         	ldr	r1, [r1, #0x10]
 802698a: 3901         	subs	r1, #0x1
 802698c: fb01 f303    	mul	r3, r1, r3
 8026990: 4413         	add	r3, r2
 8026992: 60fb         	str	r3, [r7, #0xc]
; 	while (p >= slab->buffer) {
 8026994: e00c         	b	0x80269b0 <create_free_list+0x58> @ imm = #0x18
; 		*(char **)p = slab->free_list;
 8026996: 687b         	ldr	r3, [r7, #0x4]
 8026998: 68da         	ldr	r2, [r3, #0xc]
 802699a: 68fb         	ldr	r3, [r7, #0xc]
 802699c: 601a         	str	r2, [r3]
; 		slab->free_list = p;
 802699e: 687b         	ldr	r3, [r7, #0x4]
 80269a0: 68fa         	ldr	r2, [r7, #0xc]
 80269a2: 60da         	str	r2, [r3, #0xc]
; 		p -= slab->info.block_size;
 80269a4: 687b         	ldr	r3, [r7, #0x4]
 80269a6: 695b         	ldr	r3, [r3, #0x14]
 80269a8: 425b         	rsbs	r3, r3, #0
 80269aa: 68fa         	ldr	r2, [r7, #0xc]
 80269ac: 4413         	add	r3, r2
 80269ae: 60fb         	str	r3, [r7, #0xc]
; 	while (p >= slab->buffer) {
 80269b0: 687b         	ldr	r3, [r7, #0x4]
 80269b2: 689b         	ldr	r3, [r3, #0x8]
 80269b4: 68fa         	ldr	r2, [r7, #0xc]
 80269b6: 429a         	cmp	r2, r3
 80269b8: d2ed         	bhs	0x8026996 <create_free_list+0x3e> @ imm = #-0x26
; 	return 0;
 80269ba: 2300         	movs	r3, #0x0
; }
 80269bc: 4618         	mov	r0, r3
 80269be: 3714         	adds	r7, #0x14
 80269c0: 46bd         	mov	sp, r7
 80269c2: f85d 7b04    	ldr	r7, [sp], #4
 80269c6: 4770         	bx	lr

080269c8 <slab_ptr_is_good>:
; {
 80269c8: b480         	push	{r7}
 80269ca: b085         	sub	sp, #0x14
 80269cc: af00         	add	r7, sp, #0x0
 80269ce: 6078         	str	r0, [r7, #0x4]
 80269d0: 6039         	str	r1, [r7]
; 	const char *p = ptr;
 80269d2: 683b         	ldr	r3, [r7]
 80269d4: 60fb         	str	r3, [r7, #0xc]
; 	ptrdiff_t offset = p - slab->buffer;
 80269d6: 687b         	ldr	r3, [r7, #0x4]
 80269d8: 689b         	ldr	r3, [r3, #0x8]
 80269da: 68fa         	ldr	r2, [r7, #0xc]
 80269dc: 1ad3         	subs	r3, r2, r3
 80269de: 60bb         	str	r3, [r7, #0x8]
; 	       (offset < (slab->info.block_size * slab->info.num_blocks)) &&
 80269e0: 68bb         	ldr	r3, [r7, #0x8]
 80269e2: 2b00         	cmp	r3, #0x0
 80269e4: db14         	blt	0x8026a10 <slab_ptr_is_good+0x48> @ imm = #0x28
 80269e6: 687b         	ldr	r3, [r7, #0x4]
 80269e8: 695b         	ldr	r3, [r3, #0x14]
 80269ea: 687a         	ldr	r2, [r7, #0x4]
 80269ec: 6912         	ldr	r2, [r2, #0x10]
 80269ee: fb03 f202    	mul	r2, r3, r2
 80269f2: 68bb         	ldr	r3, [r7, #0x8]
; 	return (offset >= 0) &&
 80269f4: 429a         	cmp	r2, r3
 80269f6: d90b         	bls	0x8026a10 <slab_ptr_is_good+0x48> @ imm = #0x16
; 	       ((offset % slab->info.block_size) == 0);
 80269f8: 68bb         	ldr	r3, [r7, #0x8]
 80269fa: 687a         	ldr	r2, [r7, #0x4]
 80269fc: 6952         	ldr	r2, [r2, #0x14]
 80269fe: fbb3 f1f2    	udiv	r1, r3, r2
 8026a02: fb01 f202    	mul	r2, r1, r2
 8026a06: 1a9b         	subs	r3, r3, r2
; 	       (offset < (slab->info.block_size * slab->info.num_blocks)) &&
 8026a08: 2b00         	cmp	r3, #0x0
 8026a0a: d101         	bne	0x8026a10 <slab_ptr_is_good+0x48> @ imm = #0x2
 8026a0c: 2301         	movs	r3, #0x1
 8026a0e: e000         	b	0x8026a12 <slab_ptr_is_good+0x4a> @ imm = #0x0
 8026a10: 2300         	movs	r3, #0x0
 8026a12: f003 0301    	and	r3, r3, #0x1
 8026a16: b2db         	uxtb	r3, r3
; }
 8026a18: 4618         	mov	r0, r3
 8026a1a: 3714         	adds	r7, #0x14
 8026a1c: 46bd         	mov	sp, r7
 8026a1e: f85d 7b04    	ldr	r7, [sp], #4
 8026a22: 4770         	bx	lr

08026a24 <k_mem_slab_free>:
; {
 8026a24: b580         	push	{r7, lr}
 8026a26: b09c         	sub	sp, #0x70
 8026a28: af00         	add	r7, sp, #0x0
 8026a2a: 6078         	str	r0, [r7, #0x4]
 8026a2c: 6039         	str	r1, [r7]
; 	if (!slab_ptr_is_good(slab, mem)) {
 8026a2e: 6839         	ldr	r1, [r7]
 8026a30: 6878         	ldr	r0, [r7, #0x4]
 8026a32: f7ff ffc9    	bl	0x80269c8 <slab_ptr_is_good> @ imm = #-0x6e
 8026a36: 4603         	mov	r3, r0
 8026a38: f083 0301    	eor	r3, r3, #0x1
 8026a3c: b2db         	uxtb	r3, r3
 8026a3e: 2b00         	cmp	r3, #0x0
 8026a40: d00f         	beq	0x8026a62 <k_mem_slab_free+0x3e> @ imm = #0x1e
 8026a42: 2300         	movs	r3, #0x0
 8026a44: 66bb         	str	r3, [r7, #0x68]
 8026a46: 6ebb         	ldr	r3, [r7, #0x68]
 8026a48: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8026a4a: 6e7b         	ldr	r3, [r7, #0x64]
 8026a4c: f383 8811    	msr	basepri, r3
; }
 8026a50: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8026a52: f3bf 8f6f    	isb	sy
; }
 8026a56: bf00         	nop
; }
 8026a58: bf00         	nop
; 		k_panic();
 8026a5a: 2304         	movs	r3, #0x4
 8026a5c: 4618         	mov	r0, r3
 8026a5e: df02         	svc	#0x2
; 		return;
 8026a60: e084         	b	0x8026b6c <k_mem_slab_free+0x148> @ imm = #0x108
; 	k_spinlock_key_t key = k_spin_lock(&slab->lock);
 8026a62: 687b         	ldr	r3, [r7, #0x4]
 8026a64: 3308         	adds	r3, #0x8
 8026a66: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8026a68: f3ef 8311    	mrs	r3, basepri
 8026a6c: 65fb         	str	r3, [r7, #0x5c]
;   return(result);
 8026a6e: 6dfb         	ldr	r3, [r7, #0x5c]
; 	key = __get_BASEPRI();
 8026a70: 65bb         	str	r3, [r7, #0x58]
 8026a72: 2310         	movs	r3, #0x10
 8026a74: 657b         	str	r3, [r7, #0x54]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8026a76: 6d7b         	ldr	r3, [r7, #0x54]
 8026a78: f383 8812    	msr	basepri_max, r3
; }
 8026a7c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8026a7e: f3bf 8f6f    	isb	sy
; }
 8026a82: bf00         	nop
; 	return key;
 8026a84: 6dbb         	ldr	r3, [r7, #0x58]
; 	k.key = arch_irq_lock();
 8026a86: 60fb         	str	r3, [r7, #0xc]
 8026a88: 6e3b         	ldr	r3, [r7, #0x60]
 8026a8a: 653b         	str	r3, [r7, #0x50]
; }
 8026a8c: bf00         	nop
 8026a8e: 6e3b         	ldr	r3, [r7, #0x60]
 8026a90: 64fb         	str	r3, [r7, #0x4c]
; }
 8026a92: bf00         	nop
; 	return k;
 8026a94: 68fb         	ldr	r3, [r7, #0xc]
 8026a96: 617b         	str	r3, [r7, #0x14]
; 	if ((slab->free_list == NULL) && IS_ENABLED(CONFIG_MULTITHREADING)) {
 8026a98: 687b         	ldr	r3, [r7, #0x4]
 8026a9a: 68db         	ldr	r3, [r3, #0xc]
 8026a9c: 2b00         	cmp	r3, #0x0
 8026a9e: d147         	bne	0x8026b30 <k_mem_slab_free+0x10c> @ imm = #0x8e
; 		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
 8026aa0: 687b         	ldr	r3, [r7, #0x4]
 8026aa2: 64bb         	str	r3, [r7, #0x48]
; 	struct k_thread *thread = NULL;
 8026aa4: 2300         	movs	r3, #0x0
 8026aa6: 647b         	str	r3, [r7, #0x44]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8026aa8: 6cbb         	ldr	r3, [r7, #0x48]
 8026aaa: 643b         	str	r3, [r7, #0x40]
; 	struct k_thread *thread = NULL;
 8026aac: 2300         	movs	r3, #0x0
 8026aae: 63fb         	str	r3, [r7, #0x3c]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8026ab0: 6c38         	ldr	r0, [r7, #0x40]
 8026ab2: f7ff fee5    	bl	0x8026880 <sys_dlist_peek_head> @ imm = #-0x236
 8026ab6: 63b8         	str	r0, [r7, #0x38]
; 	if (n != NULL) {
 8026ab8: 6bbb         	ldr	r3, [r7, #0x38]
 8026aba: 2b00         	cmp	r3, #0x0
 8026abc: d001         	beq	0x8026ac2 <k_mem_slab_free+0x9e> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8026abe: 6bbb         	ldr	r3, [r7, #0x38]
 8026ac0: 63fb         	str	r3, [r7, #0x3c]
; 	return thread;
 8026ac2: 6bfb         	ldr	r3, [r7, #0x3c]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8026ac4: 647b         	str	r3, [r7, #0x44]
; 		if (unlikely(thread != NULL)) {
 8026ac6: 6c7b         	ldr	r3, [r7, #0x44]
 8026ac8: 2b00         	cmp	r3, #0x0
 8026aca: bf14         	ite	ne
 8026acc: 2301         	movne	r3, #0x1
 8026ace: 2300         	moveq	r3, #0x0
 8026ad0: b2db         	uxtb	r3, r3
 8026ad2: 2b00         	cmp	r3, #0x0
 8026ad4: d005         	beq	0x8026ae2 <k_mem_slab_free+0xbe> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 8026ad6: 6c78         	ldr	r0, [r7, #0x44]
 8026ad8: f7ff ff24    	bl	0x8026924 <unpend_thread_no_timeout> @ imm = #-0x1b8
; 			(void)z_abort_thread_timeout(thread);
 8026adc: 6c78         	ldr	r0, [r7, #0x44]
 8026ade: f7ff ff02    	bl	0x80268e6 <z_abort_thread_timeout> @ imm = #-0x1fc
; 	return thread;
 8026ae2: 6c7b         	ldr	r3, [r7, #0x44]
; 		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
 8026ae4: 66fb         	str	r3, [r7, #0x6c]
; 		if (unlikely(pending_thread != NULL)) {
 8026ae6: 6efb         	ldr	r3, [r7, #0x6c]
 8026ae8: 2b00         	cmp	r3, #0x0
 8026aea: bf14         	ite	ne
 8026aec: 2301         	movne	r3, #0x1
 8026aee: 2300         	moveq	r3, #0x0
 8026af0: b2db         	uxtb	r3, r3
 8026af2: 2b00         	cmp	r3, #0x0
 8026af4: d01c         	beq	0x8026b30 <k_mem_slab_free+0x10c> @ imm = #0x38
 8026af6: 6efb         	ldr	r3, [r7, #0x6c]
 8026af8: 637b         	str	r3, [r7, #0x34]
 8026afa: 2300         	movs	r3, #0x0
 8026afc: 633b         	str	r3, [r7, #0x30]
 8026afe: 683b         	ldr	r3, [r7]
 8026b00: 62fb         	str	r3, [r7, #0x2c]
 8026b02: 6b7b         	ldr	r3, [r7, #0x34]
 8026b04: 62bb         	str	r3, [r7, #0x28]
 8026b06: 6b3b         	ldr	r3, [r7, #0x30]
 8026b08: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 8026b0a: 6abb         	ldr	r3, [r7, #0x28]
 8026b0c: 6a7a         	ldr	r2, [r7, #0x24]
 8026b0e: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8026b12: bf00         	nop
; 	thread->base.swap_data = data;
 8026b14: 6b7b         	ldr	r3, [r7, #0x34]
 8026b16: 6afa         	ldr	r2, [r7, #0x2c]
 8026b18: 615a         	str	r2, [r3, #0x14]
; }
 8026b1a: bf00         	nop
; 			z_ready_thread(pending_thread);
 8026b1c: 6ef8         	ldr	r0, [r7, #0x6c]
 8026b1e: f7ef fd71    	bl	0x8016604 <z_ready_thread> @ imm = #-0x1051e
; 			z_reschedule(&slab->lock, key);
 8026b22: 687b         	ldr	r3, [r7, #0x4]
 8026b24: 3308         	adds	r3, #0x8
 8026b26: 6979         	ldr	r1, [r7, #0x14]
 8026b28: 4618         	mov	r0, r3
 8026b2a: f001 ff17    	bl	0x802895c <z_reschedule> @ imm = #0x1e2e
; 			return;
 8026b2e: e01d         	b	0x8026b6c <k_mem_slab_free+0x148> @ imm = #0x3a
; 	*(char **) mem = slab->free_list;
 8026b30: 687b         	ldr	r3, [r7, #0x4]
 8026b32: 68da         	ldr	r2, [r3, #0xc]
 8026b34: 683b         	ldr	r3, [r7]
 8026b36: 601a         	str	r2, [r3]
; 	slab->free_list = (char *) mem;
 8026b38: 687b         	ldr	r3, [r7, #0x4]
 8026b3a: 683a         	ldr	r2, [r7]
 8026b3c: 60da         	str	r2, [r3, #0xc]
; 	slab->info.num_used--;
 8026b3e: 687b         	ldr	r3, [r7, #0x4]
 8026b40: 699b         	ldr	r3, [r3, #0x18]
 8026b42: 1e5a         	subs	r2, r3, #0x1
 8026b44: 687b         	ldr	r3, [r7, #0x4]
 8026b46: 619a         	str	r2, [r3, #0x18]
; 	k_spin_unlock(&slab->lock, key);
 8026b48: 687b         	ldr	r3, [r7, #0x4]
 8026b4a: 3308         	adds	r3, #0x8
 8026b4c: 623b         	str	r3, [r7, #0x20]
 8026b4e: 697b         	ldr	r3, [r7, #0x14]
 8026b50: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8026b52: 693b         	ldr	r3, [r7, #0x10]
 8026b54: 61fb         	str	r3, [r7, #0x1c]
 8026b56: 69fb         	ldr	r3, [r7, #0x1c]
 8026b58: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8026b5a: 69bb         	ldr	r3, [r7, #0x18]
 8026b5c: f383 8811    	msr	basepri, r3
; }
 8026b60: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8026b62: f3bf 8f6f    	isb	sy
; }
 8026b66: bf00         	nop
; }
 8026b68: bf00         	nop
; }
 8026b6a: bf00         	nop
; }
 8026b6c: 3770         	adds	r7, #0x70
 8026b6e: 46bd         	mov	sp, r7
 8026b70: bd80         	pop	{r7, pc}

08026b72 <k_cpu_idle>:
; {
 8026b72: b580         	push	{r7, lr}
 8026b74: af00         	add	r7, sp, #0x0
; 	arch_cpu_idle();
 8026b76: f7f6 fd96    	bl	0x801d6a6 <arch_cpu_idle> @ imm = #-0x94d4
; }
 8026b7a: bf00         	nop
 8026b7c: bd80         	pop	{r7, pc}

08026b7e <idle>:
; {
 8026b7e: b580         	push	{r7, lr}
 8026b80: b088         	sub	sp, #0x20
 8026b82: af00         	add	r7, sp, #0x0
 8026b84: 60f8         	str	r0, [r7, #0xc]
 8026b86: 60b9         	str	r1, [r7, #0x8]
 8026b88: 607a         	str	r2, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8026b8a: f3ef 8311    	mrs	r3, basepri
 8026b8e: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 8026b90: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 8026b92: 61bb         	str	r3, [r7, #0x18]
 8026b94: 2310         	movs	r3, #0x10
 8026b96: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8026b98: 697b         	ldr	r3, [r7, #0x14]
 8026b9a: f383 8812    	msr	basepri_max, r3
; }
 8026b9e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8026ba0: f3bf 8f6f    	isb	sy
; }
 8026ba4: bf00         	nop
; 	return key;
 8026ba6: bf00         	nop
; 		k_cpu_idle();
 8026ba8: f7ff ffe3    	bl	0x8026b72 <k_cpu_idle>  @ imm = #-0x3a
; 		if (IS_ENABLED(CONFIG_SMP) && !IS_ENABLED(CONFIG_SCHED_IPI_SUPPORTED)) {
 8026bac: e7ed         	b	0x8026b8a <idle+0xc>    @ imm = #-0x26

08026bae <arch_spin_relax>:
; {
 8026bae: b480         	push	{r7}
 8026bb0: af00         	add	r7, sp, #0x0
; 	__asm__ volatile("nop");
 8026bb2: bf00         	nop
; }
 8026bb4: bf00         	nop
; }
 8026bb6: bf00         	nop
 8026bb8: 46bd         	mov	sp, r7
 8026bba: f85d 7b04    	ldr	r7, [sp], #4
 8026bbe: 4770         	bx	lr

08026bc0 <sys_dnode_init>:
; {
 8026bc0: b480         	push	{r7}
 8026bc2: b083         	sub	sp, #0xc
 8026bc4: af00         	add	r7, sp, #0x0
 8026bc6: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8026bc8: 687b         	ldr	r3, [r7, #0x4]
 8026bca: 2200         	movs	r2, #0x0
 8026bcc: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8026bce: 687b         	ldr	r3, [r7, #0x4]
 8026bd0: 2200         	movs	r2, #0x0
 8026bd2: 605a         	str	r2, [r3, #0x4]
; }
 8026bd4: bf00         	nop
 8026bd6: 370c         	adds	r7, #0xc
 8026bd8: 46bd         	mov	sp, r7
 8026bda: f85d 7b04    	ldr	r7, [sp], #4
 8026bde: 4770         	bx	lr

08026be0 <sys_dlist_is_empty>:
; {
 8026be0: b480         	push	{r7}
 8026be2: b083         	sub	sp, #0xc
 8026be4: af00         	add	r7, sp, #0x0
 8026be6: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8026be8: 687b         	ldr	r3, [r7, #0x4]
 8026bea: 681b         	ldr	r3, [r3]
 8026bec: 687a         	ldr	r2, [r7, #0x4]
 8026bee: 429a         	cmp	r2, r3
 8026bf0: bf0c         	ite	eq
 8026bf2: 2301         	moveq	r3, #0x1
 8026bf4: 2300         	movne	r3, #0x0
 8026bf6: b2db         	uxtb	r3, r3
; }
 8026bf8: 4618         	mov	r0, r3
 8026bfa: 370c         	adds	r7, #0xc
 8026bfc: 46bd         	mov	sp, r7
 8026bfe: f85d 7b04    	ldr	r7, [sp], #4
 8026c02: 4770         	bx	lr

08026c04 <sys_dlist_peek_head>:
; {
 8026c04: b580         	push	{r7, lr}
 8026c06: b082         	sub	sp, #0x8
 8026c08: af00         	add	r7, sp, #0x0
 8026c0a: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8026c0c: 6878         	ldr	r0, [r7, #0x4]
 8026c0e: f7ff ffe7    	bl	0x8026be0 <sys_dlist_is_empty> @ imm = #-0x32
 8026c12: 4603         	mov	r3, r0
 8026c14: 2b00         	cmp	r3, #0x0
 8026c16: d102         	bne	0x8026c1e <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8026c18: 687b         	ldr	r3, [r7, #0x4]
 8026c1a: 681b         	ldr	r3, [r3]
 8026c1c: e000         	b	0x8026c20 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8026c1e: 2300         	movs	r3, #0x0
; }
 8026c20: 4618         	mov	r0, r3
 8026c22: 3708         	adds	r7, #0x8
 8026c24: 46bd         	mov	sp, r7
 8026c26: bd80         	pop	{r7, pc}

08026c28 <sys_dlist_remove>:
; {
 8026c28: b580         	push	{r7, lr}
 8026c2a: b084         	sub	sp, #0x10
 8026c2c: af00         	add	r7, sp, #0x0
 8026c2e: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8026c30: 687b         	ldr	r3, [r7, #0x4]
 8026c32: 685b         	ldr	r3, [r3, #0x4]
 8026c34: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8026c36: 687b         	ldr	r3, [r7, #0x4]
 8026c38: 681b         	ldr	r3, [r3]
 8026c3a: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8026c3c: 68fb         	ldr	r3, [r7, #0xc]
 8026c3e: 68ba         	ldr	r2, [r7, #0x8]
 8026c40: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8026c42: 68bb         	ldr	r3, [r7, #0x8]
 8026c44: 68fa         	ldr	r2, [r7, #0xc]
 8026c46: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8026c48: 6878         	ldr	r0, [r7, #0x4]
 8026c4a: f7ff ffb9    	bl	0x8026bc0 <sys_dnode_init> @ imm = #-0x8e
; }
 8026c4e: bf00         	nop
 8026c50: 3710         	adds	r7, #0x10
 8026c52: 46bd         	mov	sp, r7
 8026c54: bd80         	pop	{r7, pc}

08026c56 <z_abort_thread_timeout>:
; {
 8026c56: b580         	push	{r7, lr}
 8026c58: b082         	sub	sp, #0x8
 8026c5a: af00         	add	r7, sp, #0x0
 8026c5c: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8026c5e: 687b         	ldr	r3, [r7, #0x4]
 8026c60: 3318         	adds	r3, #0x18
 8026c62: 4618         	mov	r0, r3
 8026c64: f7f1 fb0c    	bl	0x8018280 <z_abort_timeout> @ imm = #-0xe9e8
 8026c68: 4603         	mov	r3, r0
; }
 8026c6a: 4618         	mov	r0, r3
 8026c6c: 3708         	adds	r7, #0x8
 8026c6e: 46bd         	mov	sp, r7
 8026c70: bd80         	pop	{r7, pc}

08026c72 <z_mark_thread_as_not_pending>:
; {
 8026c72: b480         	push	{r7}
 8026c74: b083         	sub	sp, #0xc
 8026c76: af00         	add	r7, sp, #0x0
 8026c78: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8026c7a: 687b         	ldr	r3, [r7, #0x4]
 8026c7c: 7b5b         	ldrb	r3, [r3, #0xd]
 8026c7e: f023 0302    	bic	r3, r3, #0x2
 8026c82: b2da         	uxtb	r2, r3
 8026c84: 687b         	ldr	r3, [r7, #0x4]
 8026c86: 735a         	strb	r2, [r3, #0xd]
; }
 8026c88: bf00         	nop
 8026c8a: 370c         	adds	r7, #0xc
 8026c8c: 46bd         	mov	sp, r7
 8026c8e: f85d 7b04    	ldr	r7, [sp], #4
 8026c92: 4770         	bx	lr

08026c94 <unpend_thread_no_timeout>:
; {
 8026c94: b580         	push	{r7, lr}
 8026c96: b086         	sub	sp, #0x18
 8026c98: af00         	add	r7, sp, #0x0
 8026c9a: 6078         	str	r0, [r7, #0x4]
 8026c9c: 687b         	ldr	r3, [r7, #0x4]
 8026c9e: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8026ca0: 68fb         	ldr	r3, [r7, #0xc]
 8026ca2: 689b         	ldr	r3, [r3, #0x8]
 8026ca4: 617b         	str	r3, [r7, #0x14]
 8026ca6: 687b         	ldr	r3, [r7, #0x4]
 8026ca8: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8026caa: 693b         	ldr	r3, [r7, #0x10]
 8026cac: 4618         	mov	r0, r3
 8026cae: f7ff ffbb    	bl	0x8026c28 <sys_dlist_remove> @ imm = #-0x8a
; }
 8026cb2: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8026cb4: 6878         	ldr	r0, [r7, #0x4]
 8026cb6: f7ff ffdc    	bl	0x8026c72 <z_mark_thread_as_not_pending> @ imm = #-0x48
; 	thread->base.pended_on = NULL;
 8026cba: 687b         	ldr	r3, [r7, #0x4]
 8026cbc: 2200         	movs	r2, #0x0
 8026cbe: 609a         	str	r2, [r3, #0x8]
; }
 8026cc0: bf00         	nop
 8026cc2: 3718         	adds	r7, #0x18
 8026cc4: 46bd         	mov	sp, r7
 8026cc6: bd80         	pop	{r7, pc}

08026cc8 <sys_dlist_init>:
; {
 8026cc8: b480         	push	{r7}
 8026cca: b083         	sub	sp, #0xc
 8026ccc: af00         	add	r7, sp, #0x0
 8026cce: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8026cd0: 687b         	ldr	r3, [r7, #0x4]
 8026cd2: 687a         	ldr	r2, [r7, #0x4]
 8026cd4: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8026cd6: 687b         	ldr	r3, [r7, #0x4]
 8026cd8: 687a         	ldr	r2, [r7, #0x4]
 8026cda: 605a         	str	r2, [r3, #0x4]
; }
 8026cdc: bf00         	nop
 8026cde: 370c         	adds	r7, #0xc
 8026ce0: 46bd         	mov	sp, r7
 8026ce2: f85d 7b04    	ldr	r7, [sp], #4
 8026ce6: 4770         	bx	lr

08026ce8 <sys_dnode_init>:
; {
 8026ce8: b480         	push	{r7}
 8026cea: b083         	sub	sp, #0xc
 8026cec: af00         	add	r7, sp, #0x0
 8026cee: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8026cf0: 687b         	ldr	r3, [r7, #0x4]
 8026cf2: 2200         	movs	r2, #0x0
 8026cf4: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8026cf6: 687b         	ldr	r3, [r7, #0x4]
 8026cf8: 2200         	movs	r2, #0x0
 8026cfa: 605a         	str	r2, [r3, #0x4]
; }
 8026cfc: bf00         	nop
 8026cfe: 370c         	adds	r7, #0xc
 8026d00: 46bd         	mov	sp, r7
 8026d02: f85d 7b04    	ldr	r7, [sp], #4
 8026d06: 4770         	bx	lr

08026d08 <sys_dnode_is_linked>:
; {
 8026d08: b480         	push	{r7}
 8026d0a: b083         	sub	sp, #0xc
 8026d0c: af00         	add	r7, sp, #0x0
 8026d0e: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 8026d10: 687b         	ldr	r3, [r7, #0x4]
 8026d12: 681b         	ldr	r3, [r3]
 8026d14: 2b00         	cmp	r3, #0x0
 8026d16: bf14         	ite	ne
 8026d18: 2301         	movne	r3, #0x1
 8026d1a: 2300         	moveq	r3, #0x0
 8026d1c: b2db         	uxtb	r3, r3
; }
 8026d1e: 4618         	mov	r0, r3
 8026d20: 370c         	adds	r7, #0xc
 8026d22: 46bd         	mov	sp, r7
 8026d24: f85d 7b04    	ldr	r7, [sp], #4
 8026d28: 4770         	bx	lr

08026d2a <sys_dlist_is_empty>:
; {
 8026d2a: b480         	push	{r7}
 8026d2c: b083         	sub	sp, #0xc
 8026d2e: af00         	add	r7, sp, #0x0
 8026d30: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8026d32: 687b         	ldr	r3, [r7, #0x4]
 8026d34: 681b         	ldr	r3, [r3]
 8026d36: 687a         	ldr	r2, [r7, #0x4]
 8026d38: 429a         	cmp	r2, r3
 8026d3a: bf0c         	ite	eq
 8026d3c: 2301         	moveq	r3, #0x1
 8026d3e: 2300         	movne	r3, #0x0
 8026d40: b2db         	uxtb	r3, r3
; }
 8026d42: 4618         	mov	r0, r3
 8026d44: 370c         	adds	r7, #0xc
 8026d46: 46bd         	mov	sp, r7
 8026d48: f85d 7b04    	ldr	r7, [sp], #4
 8026d4c: 4770         	bx	lr

08026d4e <sys_dlist_peek_head>:
; {
 8026d4e: b580         	push	{r7, lr}
 8026d50: b082         	sub	sp, #0x8
 8026d52: af00         	add	r7, sp, #0x0
 8026d54: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8026d56: 6878         	ldr	r0, [r7, #0x4]
 8026d58: f7ff ffe7    	bl	0x8026d2a <sys_dlist_is_empty> @ imm = #-0x32
 8026d5c: 4603         	mov	r3, r0
 8026d5e: 2b00         	cmp	r3, #0x0
 8026d60: d102         	bne	0x8026d68 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8026d62: 687b         	ldr	r3, [r7, #0x4]
 8026d64: 681b         	ldr	r3, [r3]
 8026d66: e000         	b	0x8026d6a <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8026d68: 2300         	movs	r3, #0x0
; }
 8026d6a: 4618         	mov	r0, r3
 8026d6c: 3708         	adds	r7, #0x8
 8026d6e: 46bd         	mov	sp, r7
 8026d70: bd80         	pop	{r7, pc}

08026d72 <sys_dlist_remove>:
; {
 8026d72: b580         	push	{r7, lr}
 8026d74: b084         	sub	sp, #0x10
 8026d76: af00         	add	r7, sp, #0x0
 8026d78: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8026d7a: 687b         	ldr	r3, [r7, #0x4]
 8026d7c: 685b         	ldr	r3, [r3, #0x4]
 8026d7e: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8026d80: 687b         	ldr	r3, [r7, #0x4]
 8026d82: 681b         	ldr	r3, [r3]
 8026d84: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8026d86: 68fb         	ldr	r3, [r7, #0xc]
 8026d88: 68ba         	ldr	r2, [r7, #0x8]
 8026d8a: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8026d8c: 68bb         	ldr	r3, [r7, #0x8]
 8026d8e: 68fa         	ldr	r2, [r7, #0xc]
 8026d90: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8026d92: 6878         	ldr	r0, [r7, #0x4]
 8026d94: f7ff ffa8    	bl	0x8026ce8 <sys_dnode_init> @ imm = #-0xb0
; }
 8026d98: bf00         	nop
 8026d9a: 3710         	adds	r7, #0x10
 8026d9c: 46bd         	mov	sp, r7
 8026d9e: bd80         	pop	{r7, pc}

08026da0 <k_object_init>:
; {
 8026da0: b480         	push	{r7}
 8026da2: b083         	sub	sp, #0xc
 8026da4: af00         	add	r7, sp, #0x0
 8026da6: 6078         	str	r0, [r7, #0x4]
; }
 8026da8: bf00         	nop
 8026daa: 370c         	adds	r7, #0xc
 8026dac: 46bd         	mov	sp, r7
 8026dae: f85d 7b04    	ldr	r7, [sp], #4
 8026db2: 4770         	bx	lr

08026db4 <z_is_inactive_timeout>:
; {
 8026db4: b580         	push	{r7, lr}
 8026db6: b082         	sub	sp, #0x8
 8026db8: af00         	add	r7, sp, #0x0
 8026dba: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 8026dbc: 687b         	ldr	r3, [r7, #0x4]
 8026dbe: 4618         	mov	r0, r3
 8026dc0: f7ff ffa2    	bl	0x8026d08 <sys_dnode_is_linked> @ imm = #-0xbc
 8026dc4: 4603         	mov	r3, r0
 8026dc6: 2b00         	cmp	r3, #0x0
 8026dc8: bf14         	ite	ne
 8026dca: 2301         	movne	r3, #0x1
 8026dcc: 2300         	moveq	r3, #0x0
 8026dce: b2db         	uxtb	r3, r3
 8026dd0: f083 0301    	eor	r3, r3, #0x1
 8026dd4: b2db         	uxtb	r3, r3
 8026dd6: f003 0301    	and	r3, r3, #0x1
 8026dda: b2db         	uxtb	r3, r3
; }
 8026ddc: 4618         	mov	r0, r3
 8026dde: 3708         	adds	r7, #0x8
 8026de0: 46bd         	mov	sp, r7
 8026de2: bd80         	pop	{r7, pc}

08026de4 <z_abort_thread_timeout>:
; {
 8026de4: b580         	push	{r7, lr}
 8026de6: b082         	sub	sp, #0x8
 8026de8: af00         	add	r7, sp, #0x0
 8026dea: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8026dec: 687b         	ldr	r3, [r7, #0x4]
 8026dee: 3318         	adds	r3, #0x18
 8026df0: 4618         	mov	r0, r3
 8026df2: f7f1 fa45    	bl	0x8018280 <z_abort_timeout> @ imm = #-0xeb76
 8026df6: 4603         	mov	r3, r0
; }
 8026df8: 4618         	mov	r0, r3
 8026dfa: 3708         	adds	r7, #0x8
 8026dfc: 46bd         	mov	sp, r7
 8026dfe: bd80         	pop	{r7, pc}

08026e00 <z_is_thread_prevented_from_running>:
; {
 8026e00: b480         	push	{r7}
 8026e02: b085         	sub	sp, #0x14
 8026e04: af00         	add	r7, sp, #0x0
 8026e06: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 8026e08: 687b         	ldr	r3, [r7, #0x4]
 8026e0a: 7b5b         	ldrb	r3, [r3, #0xd]
 8026e0c: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 8026e0e: 7bfb         	ldrb	r3, [r7, #0xf]
 8026e10: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 8026e14: 2b00         	cmp	r3, #0x0
 8026e16: bf14         	ite	ne
 8026e18: 2301         	movne	r3, #0x1
 8026e1a: 2300         	moveq	r3, #0x0
 8026e1c: b2db         	uxtb	r3, r3
; }
 8026e1e: 4618         	mov	r0, r3
 8026e20: 3714         	adds	r7, #0x14
 8026e22: 46bd         	mov	sp, r7
 8026e24: f85d 7b04    	ldr	r7, [sp], #4
 8026e28: 4770         	bx	lr

08026e2a <z_is_thread_timeout_active>:
; {
 8026e2a: b580         	push	{r7, lr}
 8026e2c: b082         	sub	sp, #0x8
 8026e2e: af00         	add	r7, sp, #0x0
 8026e30: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 8026e32: 687b         	ldr	r3, [r7, #0x4]
 8026e34: 3318         	adds	r3, #0x18
 8026e36: 4618         	mov	r0, r3
 8026e38: f7ff ffbc    	bl	0x8026db4 <z_is_inactive_timeout> @ imm = #-0x88
 8026e3c: 4603         	mov	r3, r0
 8026e3e: 2b00         	cmp	r3, #0x0
 8026e40: bf14         	ite	ne
 8026e42: 2301         	movne	r3, #0x1
 8026e44: 2300         	moveq	r3, #0x0
 8026e46: b2db         	uxtb	r3, r3
 8026e48: f083 0301    	eor	r3, r3, #0x1
 8026e4c: b2db         	uxtb	r3, r3
 8026e4e: f003 0301    	and	r3, r3, #0x1
 8026e52: b2db         	uxtb	r3, r3
; }
 8026e54: 4618         	mov	r0, r3
 8026e56: 3708         	adds	r7, #0x8
 8026e58: 46bd         	mov	sp, r7
 8026e5a: bd80         	pop	{r7, pc}

08026e5c <z_is_thread_ready>:
; {
 8026e5c: b580         	push	{r7, lr}
 8026e5e: b082         	sub	sp, #0x8
 8026e60: af00         	add	r7, sp, #0x0
 8026e62: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 8026e64: 6878         	ldr	r0, [r7, #0x4]
 8026e66: f7ff ffcb    	bl	0x8026e00 <z_is_thread_prevented_from_running> @ imm = #-0x6a
 8026e6a: 4603         	mov	r3, r0
 8026e6c: f083 0301    	eor	r3, r3, #0x1
 8026e70: b2db         	uxtb	r3, r3
 8026e72: 2b00         	cmp	r3, #0x0
 8026e74: d00a         	beq	0x8026e8c <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 8026e76: 6878         	ldr	r0, [r7, #0x4]
 8026e78: f7ff ffd7    	bl	0x8026e2a <z_is_thread_timeout_active> @ imm = #-0x52
 8026e7c: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 8026e7e: f083 0301    	eor	r3, r3, #0x1
 8026e82: b2db         	uxtb	r3, r3
 8026e84: 2b00         	cmp	r3, #0x0
 8026e86: d001         	beq	0x8026e8c <z_is_thread_ready+0x30> @ imm = #0x2
 8026e88: 2301         	movs	r3, #0x1
 8026e8a: e000         	b	0x8026e8e <z_is_thread_ready+0x32> @ imm = #0x0
 8026e8c: 2300         	movs	r3, #0x0
 8026e8e: f003 0301    	and	r3, r3, #0x1
 8026e92: b2db         	uxtb	r3, r3
; }
 8026e94: 4618         	mov	r0, r3
 8026e96: 3708         	adds	r7, #0x8
 8026e98: 46bd         	mov	sp, r7
 8026e9a: bd80         	pop	{r7, pc}

08026e9c <z_mark_thread_as_not_pending>:
; {
 8026e9c: b480         	push	{r7}
 8026e9e: b083         	sub	sp, #0xc
 8026ea0: af00         	add	r7, sp, #0x0
 8026ea2: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8026ea4: 687b         	ldr	r3, [r7, #0x4]
 8026ea6: 7b5b         	ldrb	r3, [r3, #0xd]
 8026ea8: f023 0302    	bic	r3, r3, #0x2
 8026eac: b2da         	uxtb	r2, r3
 8026eae: 687b         	ldr	r3, [r7, #0x4]
 8026eb0: 735a         	strb	r2, [r3, #0xd]
; }
 8026eb2: bf00         	nop
 8026eb4: 370c         	adds	r7, #0xc
 8026eb6: 46bd         	mov	sp, r7
 8026eb8: f85d 7b04    	ldr	r7, [sp], #4
 8026ebc: 4770         	bx	lr

08026ebe <z_is_under_prio_ceiling>:
; {
 8026ebe: b480         	push	{r7}
 8026ec0: b083         	sub	sp, #0xc
 8026ec2: af00         	add	r7, sp, #0x0
 8026ec4: 6078         	str	r0, [r7, #0x4]
; 	return prio >= CONFIG_PRIORITY_CEILING;
 8026ec6: 687b         	ldr	r3, [r7, #0x4]
 8026ec8: f113 0f7f    	cmn.w	r3, #0x7f
 8026ecc: bfac         	ite	ge
 8026ece: 2301         	movge	r3, #0x1
 8026ed0: 2300         	movlt	r3, #0x0
 8026ed2: b2db         	uxtb	r3, r3
; }
 8026ed4: 4618         	mov	r0, r3
 8026ed6: 370c         	adds	r7, #0xc
 8026ed8: 46bd         	mov	sp, r7
 8026eda: f85d 7b04    	ldr	r7, [sp], #4
 8026ede: 4770         	bx	lr

08026ee0 <z_get_new_prio_with_ceiling>:
; {
 8026ee0: b580         	push	{r7, lr}
 8026ee2: b082         	sub	sp, #0x8
 8026ee4: af00         	add	r7, sp, #0x0
 8026ee6: 6078         	str	r0, [r7, #0x4]
; 	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
 8026ee8: 6878         	ldr	r0, [r7, #0x4]
 8026eea: f7ff ffe8    	bl	0x8026ebe <z_is_under_prio_ceiling> @ imm = #-0x30
 8026eee: 4603         	mov	r3, r0
 8026ef0: 2b00         	cmp	r3, #0x0
 8026ef2: d001         	beq	0x8026ef8 <z_get_new_prio_with_ceiling+0x18> @ imm = #0x2
 8026ef4: 687b         	ldr	r3, [r7, #0x4]
 8026ef6: e001         	b	0x8026efc <z_get_new_prio_with_ceiling+0x1c> @ imm = #0x2
 8026ef8: f06f 037e    	mvn	r3, #0x7e
; }
 8026efc: 4618         	mov	r0, r3
 8026efe: 3708         	adds	r7, #0x8
 8026f00: 46bd         	mov	sp, r7
 8026f02: bd80         	pop	{r7, pc}

08026f04 <z_is_prio1_higher_than_prio2>:
; {
 8026f04: b480         	push	{r7}
 8026f06: b083         	sub	sp, #0xc
 8026f08: af00         	add	r7, sp, #0x0
 8026f0a: 6078         	str	r0, [r7, #0x4]
 8026f0c: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 8026f0e: 687a         	ldr	r2, [r7, #0x4]
 8026f10: 683b         	ldr	r3, [r7]
 8026f12: 429a         	cmp	r2, r3
 8026f14: bfb4         	ite	lt
 8026f16: 2301         	movlt	r3, #0x1
 8026f18: 2300         	movge	r3, #0x0
 8026f1a: b2db         	uxtb	r3, r3
; }
 8026f1c: 4618         	mov	r0, r3
 8026f1e: 370c         	adds	r7, #0xc
 8026f20: 46bd         	mov	sp, r7
 8026f22: f85d 7b04    	ldr	r7, [sp], #4
 8026f26: 4770         	bx	lr

08026f28 <z_is_prio_higher>:
; {
 8026f28: b580         	push	{r7, lr}
 8026f2a: b082         	sub	sp, #0x8
 8026f2c: af00         	add	r7, sp, #0x0
 8026f2e: 6078         	str	r0, [r7, #0x4]
 8026f30: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 8026f32: 6839         	ldr	r1, [r7]
 8026f34: 6878         	ldr	r0, [r7, #0x4]
 8026f36: f7ff ffe5    	bl	0x8026f04 <z_is_prio1_higher_than_prio2> @ imm = #-0x36
 8026f3a: 4603         	mov	r3, r0
; }
 8026f3c: 4618         	mov	r0, r3
 8026f3e: 3708         	adds	r7, #0x8
 8026f40: 46bd         	mov	sp, r7
 8026f42: bd80         	pop	{r7, pc}

08026f44 <unpend_thread_no_timeout>:
; {
 8026f44: b580         	push	{r7, lr}
 8026f46: b086         	sub	sp, #0x18
 8026f48: af00         	add	r7, sp, #0x0
 8026f4a: 6078         	str	r0, [r7, #0x4]
 8026f4c: 687b         	ldr	r3, [r7, #0x4]
 8026f4e: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8026f50: 68fb         	ldr	r3, [r7, #0xc]
 8026f52: 689b         	ldr	r3, [r3, #0x8]
 8026f54: 617b         	str	r3, [r7, #0x14]
 8026f56: 687b         	ldr	r3, [r7, #0x4]
 8026f58: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8026f5a: 693b         	ldr	r3, [r7, #0x10]
 8026f5c: 4618         	mov	r0, r3
 8026f5e: f7ff ff08    	bl	0x8026d72 <sys_dlist_remove> @ imm = #-0x1f0
; }
 8026f62: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8026f64: 6878         	ldr	r0, [r7, #0x4]
 8026f66: f7ff ff99    	bl	0x8026e9c <z_mark_thread_as_not_pending> @ imm = #-0xce
; 	thread->base.pended_on = NULL;
 8026f6a: 687b         	ldr	r3, [r7, #0x4]
 8026f6c: 2200         	movs	r2, #0x0
 8026f6e: 609a         	str	r2, [r3, #0x8]
; }
 8026f70: bf00         	nop
 8026f72: 3718         	adds	r7, #0x18
 8026f74: 46bd         	mov	sp, r7
 8026f76: bd80         	pop	{r7, pc}

08026f78 <z_waitq_init>:
; {
 8026f78: b580         	push	{r7, lr}
 8026f7a: b082         	sub	sp, #0x8
 8026f7c: af00         	add	r7, sp, #0x0
 8026f7e: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8026f80: 687b         	ldr	r3, [r7, #0x4]
 8026f82: 4618         	mov	r0, r3
 8026f84: f7ff fea0    	bl	0x8026cc8 <sys_dlist_init> @ imm = #-0x2c0
; }
 8026f88: bf00         	nop
 8026f8a: 3708         	adds	r7, #0x8
 8026f8c: 46bd         	mov	sp, r7
 8026f8e: bd80         	pop	{r7, pc}

08026f90 <z_waitq_head>:
; {
 8026f90: b580         	push	{r7, lr}
 8026f92: b082         	sub	sp, #0x8
 8026f94: af00         	add	r7, sp, #0x0
 8026f96: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 8026f98: 687b         	ldr	r3, [r7, #0x4]
 8026f9a: 4618         	mov	r0, r3
 8026f9c: f7ff fed7    	bl	0x8026d4e <sys_dlist_peek_head> @ imm = #-0x252
 8026fa0: 4603         	mov	r3, r0
; }
 8026fa2: 4618         	mov	r0, r3
 8026fa4: 3708         	adds	r7, #0x8
 8026fa6: 46bd         	mov	sp, r7
 8026fa8: bd80         	pop	{r7, pc}

08026faa <z_log_msg_runtime_create>:
; {
 8026faa: b580         	push	{r7, lr}
 8026fac: b08a         	sub	sp, #0x28
 8026fae: af04         	add	r7, sp, #0x10
 8026fb0: 60b9         	str	r1, [r7, #0x8]
 8026fb2: 607b         	str	r3, [r7, #0x4]
 8026fb4: 4603         	mov	r3, r0
 8026fb6: 73fb         	strb	r3, [r7, #0xf]
 8026fb8: 4613         	mov	r3, r2
 8026fba: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8026fbc: f107 032c    	add.w	r3, r7, #0x2c
 8026fc0: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8026fc2: 7bba         	ldrb	r2, [r7, #0xe]
 8026fc4: 7bf8         	ldrb	r0, [r7, #0xf]
 8026fc6: 697b         	ldr	r3, [r7, #0x14]
 8026fc8: 9303         	str	r3, [sp, #0xc]
 8026fca: 6abb         	ldr	r3, [r7, #0x28]
 8026fcc: 9302         	str	r3, [sp, #0x8]
 8026fce: 6a7b         	ldr	r3, [r7, #0x24]
 8026fd0: 9301         	str	r3, [sp, #0x4]
 8026fd2: 6a3b         	ldr	r3, [r7, #0x20]
 8026fd4: 9300         	str	r3, [sp]
 8026fd6: 687b         	ldr	r3, [r7, #0x4]
 8026fd8: 68b9         	ldr	r1, [r7, #0x8]
 8026fda: f7dd fdcb    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x2246a
; }
 8026fde: bf00         	nop
 8026fe0: 3718         	adds	r7, #0x18
 8026fe2: 46bd         	mov	sp, r7
 8026fe4: bd80         	pop	{r7, pc}

08026fe6 <z_impl_k_mutex_init>:
; {
 8026fe6: b580         	push	{r7, lr}
 8026fe8: b082         	sub	sp, #0x8
 8026fea: af00         	add	r7, sp, #0x0
 8026fec: 6078         	str	r0, [r7, #0x4]
; 	mutex->owner = NULL;
 8026fee: 687b         	ldr	r3, [r7, #0x4]
 8026ff0: 2200         	movs	r2, #0x0
 8026ff2: 609a         	str	r2, [r3, #0x8]
; 	mutex->lock_count = 0U;
 8026ff4: 687b         	ldr	r3, [r7, #0x4]
 8026ff6: 2200         	movs	r2, #0x0
 8026ff8: 60da         	str	r2, [r3, #0xc]
; 	z_waitq_init(&mutex->wait_q);
 8026ffa: 687b         	ldr	r3, [r7, #0x4]
 8026ffc: 4618         	mov	r0, r3
 8026ffe: f7ff ffbb    	bl	0x8026f78 <z_waitq_init> @ imm = #-0x8a
; 	k_object_init(mutex);
 8027002: 6878         	ldr	r0, [r7, #0x4]
 8027004: f7ff fecc    	bl	0x8026da0 <k_object_init> @ imm = #-0x268
; 	return 0;
 8027008: 2300         	movs	r3, #0x0
; }
 802700a: 4618         	mov	r0, r3
 802700c: 3708         	adds	r7, #0x8
 802700e: 46bd         	mov	sp, r7
 8027010: bd80         	pop	{r7, pc}

08027012 <new_prio_for_inheritance>:
; {
 8027012: b580         	push	{r7, lr}
 8027014: b084         	sub	sp, #0x10
 8027016: af00         	add	r7, sp, #0x0
 8027018: 6078         	str	r0, [r7, #0x4]
 802701a: 6039         	str	r1, [r7]
; 	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
 802701c: 6839         	ldr	r1, [r7]
 802701e: 6878         	ldr	r0, [r7, #0x4]
 8027020: f7ff ff82    	bl	0x8026f28 <z_is_prio_higher> @ imm = #-0xfc
 8027024: 4603         	mov	r3, r0
 8027026: 2b00         	cmp	r3, #0x0
 8027028: d001         	beq	0x802702e <new_prio_for_inheritance+0x1c> @ imm = #0x2
 802702a: 687b         	ldr	r3, [r7, #0x4]
 802702c: e000         	b	0x8027030 <new_prio_for_inheritance+0x1e> @ imm = #0x0
 802702e: 683b         	ldr	r3, [r7]
 8027030: 60fb         	str	r3, [r7, #0xc]
; 	new_prio = z_get_new_prio_with_ceiling(new_prio);
 8027032: 68f8         	ldr	r0, [r7, #0xc]
 8027034: f7ff ff54    	bl	0x8026ee0 <z_get_new_prio_with_ceiling> @ imm = #-0x158
 8027038: 60f8         	str	r0, [r7, #0xc]
; 	return new_prio;
 802703a: 68fb         	ldr	r3, [r7, #0xc]
; }
 802703c: 4618         	mov	r0, r3
 802703e: 3710         	adds	r7, #0x10
 8027040: 46bd         	mov	sp, r7
 8027042: bd80         	pop	{r7, pc}

08027044 <sys_dnode_init>:
; {
 8027044: b480         	push	{r7}
 8027046: b083         	sub	sp, #0xc
 8027048: af00         	add	r7, sp, #0x0
 802704a: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 802704c: 687b         	ldr	r3, [r7, #0x4]
 802704e: 2200         	movs	r2, #0x0
 8027050: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8027052: 687b         	ldr	r3, [r7, #0x4]
 8027054: 2200         	movs	r2, #0x0
 8027056: 605a         	str	r2, [r3, #0x4]
; }
 8027058: bf00         	nop
 802705a: 370c         	adds	r7, #0xc
 802705c: 46bd         	mov	sp, r7
 802705e: f85d 7b04    	ldr	r7, [sp], #4
 8027062: 4770         	bx	lr

08027064 <sys_dlist_is_empty>:
; {
 8027064: b480         	push	{r7}
 8027066: b083         	sub	sp, #0xc
 8027068: af00         	add	r7, sp, #0x0
 802706a: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 802706c: 687b         	ldr	r3, [r7, #0x4]
 802706e: 681b         	ldr	r3, [r3]
 8027070: 687a         	ldr	r2, [r7, #0x4]
 8027072: 429a         	cmp	r2, r3
 8027074: bf0c         	ite	eq
 8027076: 2301         	moveq	r3, #0x1
 8027078: 2300         	movne	r3, #0x0
 802707a: b2db         	uxtb	r3, r3
; }
 802707c: 4618         	mov	r0, r3
 802707e: 370c         	adds	r7, #0xc
 8027080: 46bd         	mov	sp, r7
 8027082: f85d 7b04    	ldr	r7, [sp], #4
 8027086: 4770         	bx	lr

08027088 <sys_dlist_peek_head>:
; {
 8027088: b580         	push	{r7, lr}
 802708a: b082         	sub	sp, #0x8
 802708c: af00         	add	r7, sp, #0x0
 802708e: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8027090: 6878         	ldr	r0, [r7, #0x4]
 8027092: f7ff ffe7    	bl	0x8027064 <sys_dlist_is_empty> @ imm = #-0x32
 8027096: 4603         	mov	r3, r0
 8027098: 2b00         	cmp	r3, #0x0
 802709a: d102         	bne	0x80270a2 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 802709c: 687b         	ldr	r3, [r7, #0x4]
 802709e: 681b         	ldr	r3, [r3]
 80270a0: e000         	b	0x80270a4 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 80270a2: 2300         	movs	r3, #0x0
; }
 80270a4: 4618         	mov	r0, r3
 80270a6: 3708         	adds	r7, #0x8
 80270a8: 46bd         	mov	sp, r7
 80270aa: bd80         	pop	{r7, pc}

080270ac <sys_dlist_remove>:
; {
 80270ac: b580         	push	{r7, lr}
 80270ae: b084         	sub	sp, #0x10
 80270b0: af00         	add	r7, sp, #0x0
 80270b2: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 80270b4: 687b         	ldr	r3, [r7, #0x4]
 80270b6: 685b         	ldr	r3, [r3, #0x4]
 80270b8: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 80270ba: 687b         	ldr	r3, [r7, #0x4]
 80270bc: 681b         	ldr	r3, [r3]
 80270be: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 80270c0: 68fb         	ldr	r3, [r7, #0xc]
 80270c2: 68ba         	ldr	r2, [r7, #0x8]
 80270c4: 601a         	str	r2, [r3]
; 	next->prev = prev;
 80270c6: 68bb         	ldr	r3, [r7, #0x8]
 80270c8: 68fa         	ldr	r2, [r7, #0xc]
 80270ca: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 80270cc: 6878         	ldr	r0, [r7, #0x4]
 80270ce: f7ff ffb9    	bl	0x8027044 <sys_dnode_init> @ imm = #-0x8e
; }
 80270d2: bf00         	nop
 80270d4: 3710         	adds	r7, #0x10
 80270d6: 46bd         	mov	sp, r7
 80270d8: bd80         	pop	{r7, pc}

080270da <z_sfnode_next_peek>:
; {
 80270da: b480         	push	{r7}
 80270dc: b083         	sub	sp, #0xc
 80270de: af00         	add	r7, sp, #0x0
 80270e0: 6078         	str	r0, [r7, #0x4]
; 	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 80270e2: 687b         	ldr	r3, [r7, #0x4]
 80270e4: 681b         	ldr	r3, [r3]
 80270e6: f023 0303    	bic	r3, r3, #0x3
; }
 80270ea: 4618         	mov	r0, r3
 80270ec: 370c         	adds	r7, #0xc
 80270ee: 46bd         	mov	sp, r7
 80270f0: f85d 7b04    	ldr	r7, [sp], #4
 80270f4: 4770         	bx	lr

080270f6 <z_sfnode_next_set>:
; {
 80270f6: b580         	push	{r7, lr}
 80270f8: b084         	sub	sp, #0x10
 80270fa: af00         	add	r7, sp, #0x0
 80270fc: 6078         	str	r0, [r7, #0x4]
 80270fe: 6039         	str	r1, [r7]
; 	uint8_t cur_flags = sys_sfnode_flags_get(parent);
 8027100: 6878         	ldr	r0, [r7, #0x4]
 8027102: f000 f83f    	bl	0x8027184 <sys_sfnode_flags_get> @ imm = #0x7e
 8027106: 4603         	mov	r3, r0
 8027108: 73fb         	strb	r3, [r7, #0xf]
; 	parent->next_and_flags = cur_flags | (uintptr_t)child;
 802710a: 7bfa         	ldrb	r2, [r7, #0xf]
 802710c: 683b         	ldr	r3, [r7]
 802710e: 431a         	orrs	r2, r3
 8027110: 687b         	ldr	r3, [r7, #0x4]
 8027112: 601a         	str	r2, [r3]
; }
 8027114: bf00         	nop
 8027116: 3710         	adds	r7, #0x10
 8027118: 46bd         	mov	sp, r7
 802711a: bd80         	pop	{r7, pc}

0802711c <z_sflist_head_set>:
; {
 802711c: b480         	push	{r7}
 802711e: b083         	sub	sp, #0xc
 8027120: af00         	add	r7, sp, #0x0
 8027122: 6078         	str	r0, [r7, #0x4]
 8027124: 6039         	str	r1, [r7]
; 	list->head = node;
 8027126: 687b         	ldr	r3, [r7, #0x4]
 8027128: 683a         	ldr	r2, [r7]
 802712a: 601a         	str	r2, [r3]
; }
 802712c: bf00         	nop
 802712e: 370c         	adds	r7, #0xc
 8027130: 46bd         	mov	sp, r7
 8027132: f85d 7b04    	ldr	r7, [sp], #4
 8027136: 4770         	bx	lr

08027138 <z_sflist_tail_set>:
; {
 8027138: b480         	push	{r7}
 802713a: b083         	sub	sp, #0xc
 802713c: af00         	add	r7, sp, #0x0
 802713e: 6078         	str	r0, [r7, #0x4]
 8027140: 6039         	str	r1, [r7]
; 	list->tail = node;
 8027142: 687b         	ldr	r3, [r7, #0x4]
 8027144: 683a         	ldr	r2, [r7]
 8027146: 605a         	str	r2, [r3, #0x4]
; }
 8027148: bf00         	nop
 802714a: 370c         	adds	r7, #0xc
 802714c: 46bd         	mov	sp, r7
 802714e: f85d 7b04    	ldr	r7, [sp], #4
 8027152: 4770         	bx	lr

08027154 <sys_sflist_peek_head>:
; {
 8027154: b480         	push	{r7}
 8027156: b083         	sub	sp, #0xc
 8027158: af00         	add	r7, sp, #0x0
 802715a: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 802715c: 687b         	ldr	r3, [r7, #0x4]
 802715e: 681b         	ldr	r3, [r3]
; }
 8027160: 4618         	mov	r0, r3
 8027162: 370c         	adds	r7, #0xc
 8027164: 46bd         	mov	sp, r7
 8027166: f85d 7b04    	ldr	r7, [sp], #4
 802716a: 4770         	bx	lr

0802716c <sys_sflist_peek_tail>:
; {
 802716c: b480         	push	{r7}
 802716e: b083         	sub	sp, #0xc
 8027170: af00         	add	r7, sp, #0x0
 8027172: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 8027174: 687b         	ldr	r3, [r7, #0x4]
 8027176: 685b         	ldr	r3, [r3, #0x4]
; }
 8027178: 4618         	mov	r0, r3
 802717a: 370c         	adds	r7, #0xc
 802717c: 46bd         	mov	sp, r7
 802717e: f85d 7b04    	ldr	r7, [sp], #4
 8027182: 4770         	bx	lr

08027184 <sys_sfnode_flags_get>:
; {
 8027184: b480         	push	{r7}
 8027186: b083         	sub	sp, #0xc
 8027188: af00         	add	r7, sp, #0x0
 802718a: 6078         	str	r0, [r7, #0x4]
; 	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 802718c: 687b         	ldr	r3, [r7, #0x4]
 802718e: 681b         	ldr	r3, [r3]
 8027190: b2db         	uxtb	r3, r3
 8027192: f003 0303    	and	r3, r3, #0x3
 8027196: b2db         	uxtb	r3, r3
; }
 8027198: 4618         	mov	r0, r3
 802719a: 370c         	adds	r7, #0xc
 802719c: 46bd         	mov	sp, r7
 802719e: f85d 7b04    	ldr	r7, [sp], #4
 80271a2: 4770         	bx	lr

080271a4 <sys_sfnode_init>:
; {
 80271a4: b480         	push	{r7}
 80271a6: b083         	sub	sp, #0xc
 80271a8: af00         	add	r7, sp, #0x0
 80271aa: 6078         	str	r0, [r7, #0x4]
 80271ac: 460b         	mov	r3, r1
 80271ae: 70fb         	strb	r3, [r7, #0x3]
; 	node->next_and_flags = flags;
 80271b0: 78fa         	ldrb	r2, [r7, #0x3]
 80271b2: 687b         	ldr	r3, [r7, #0x4]
 80271b4: 601a         	str	r2, [r3]
; }
 80271b6: bf00         	nop
 80271b8: 370c         	adds	r7, #0xc
 80271ba: 46bd         	mov	sp, r7
 80271bc: f85d 7b04    	ldr	r7, [sp], #4
 80271c0: 4770         	bx	lr

080271c2 <sys_sflist_is_empty>:
; Z_GENLIST_IS_EMPTY(sflist)
 80271c2: b580         	push	{r7, lr}
 80271c4: b082         	sub	sp, #0x8
 80271c6: af00         	add	r7, sp, #0x0
 80271c8: 6078         	str	r0, [r7, #0x4]
 80271ca: 6878         	ldr	r0, [r7, #0x4]
 80271cc: f7ff ffc2    	bl	0x8027154 <sys_sflist_peek_head> @ imm = #-0x7c
 80271d0: 4603         	mov	r3, r0
 80271d2: 2b00         	cmp	r3, #0x0
 80271d4: bf0c         	ite	eq
 80271d6: 2301         	moveq	r3, #0x1
 80271d8: 2300         	movne	r3, #0x0
 80271da: b2db         	uxtb	r3, r3
 80271dc: 4618         	mov	r0, r3
 80271de: 3708         	adds	r7, #0x8
 80271e0: 46bd         	mov	sp, r7
 80271e2: bd80         	pop	{r7, pc}

080271e4 <sys_sflist_prepend>:
; Z_GENLIST_PREPEND(sflist, sfnode)
 80271e4: b580         	push	{r7, lr}
 80271e6: b082         	sub	sp, #0x8
 80271e8: af00         	add	r7, sp, #0x0
 80271ea: 6078         	str	r0, [r7, #0x4]
 80271ec: 6039         	str	r1, [r7]
 80271ee: 6878         	ldr	r0, [r7, #0x4]
 80271f0: f7ff ffb0    	bl	0x8027154 <sys_sflist_peek_head> @ imm = #-0xa0
 80271f4: 4603         	mov	r3, r0
 80271f6: 4619         	mov	r1, r3
 80271f8: 6838         	ldr	r0, [r7]
 80271fa: f7ff ff7c    	bl	0x80270f6 <z_sfnode_next_set> @ imm = #-0x108
 80271fe: 6839         	ldr	r1, [r7]
 8027200: 6878         	ldr	r0, [r7, #0x4]
 8027202: f7ff ff8b    	bl	0x802711c <z_sflist_head_set> @ imm = #-0xea
 8027206: 6878         	ldr	r0, [r7, #0x4]
 8027208: f7ff ffb0    	bl	0x802716c <sys_sflist_peek_tail> @ imm = #-0xa0
 802720c: 4603         	mov	r3, r0
 802720e: 2b00         	cmp	r3, #0x0
 8027210: d107         	bne	0x8027222 <sys_sflist_prepend+0x3e> @ imm = #0xe
 8027212: 6878         	ldr	r0, [r7, #0x4]
 8027214: f7ff ff9e    	bl	0x8027154 <sys_sflist_peek_head> @ imm = #-0xc4
 8027218: 4603         	mov	r3, r0
 802721a: 4619         	mov	r1, r3
 802721c: 6878         	ldr	r0, [r7, #0x4]
 802721e: f7ff ff8b    	bl	0x8027138 <z_sflist_tail_set> @ imm = #-0xea
 8027222: 3708         	adds	r7, #0x8
 8027224: 46bd         	mov	sp, r7
 8027226: bd80         	pop	{r7, pc}

08027228 <sys_sflist_append>:
; Z_GENLIST_APPEND(sflist, sfnode)
 8027228: b580         	push	{r7, lr}
 802722a: b082         	sub	sp, #0x8
 802722c: af00         	add	r7, sp, #0x0
 802722e: 6078         	str	r0, [r7, #0x4]
 8027230: 6039         	str	r1, [r7]
 8027232: 2100         	movs	r1, #0x0
 8027234: 6838         	ldr	r0, [r7]
 8027236: f7ff ff5e    	bl	0x80270f6 <z_sfnode_next_set> @ imm = #-0x144
 802723a: 6878         	ldr	r0, [r7, #0x4]
 802723c: f7ff ff96    	bl	0x802716c <sys_sflist_peek_tail> @ imm = #-0xd4
 8027240: 4603         	mov	r3, r0
 8027242: 2b00         	cmp	r3, #0x0
 8027244: d108         	bne	0x8027258 <sys_sflist_append+0x30> @ imm = #0x10
 8027246: 6839         	ldr	r1, [r7]
 8027248: 6878         	ldr	r0, [r7, #0x4]
 802724a: f7ff ff75    	bl	0x8027138 <z_sflist_tail_set> @ imm = #-0x116
 802724e: 6839         	ldr	r1, [r7]
 8027250: 6878         	ldr	r0, [r7, #0x4]
 8027252: f7ff ff63    	bl	0x802711c <z_sflist_head_set> @ imm = #-0x13a
 8027256: e00b         	b	0x8027270 <sys_sflist_append+0x48> @ imm = #0x16
 8027258: 6878         	ldr	r0, [r7, #0x4]
 802725a: f7ff ff87    	bl	0x802716c <sys_sflist_peek_tail> @ imm = #-0xf2
 802725e: 4603         	mov	r3, r0
 8027260: 6839         	ldr	r1, [r7]
 8027262: 4618         	mov	r0, r3
 8027264: f7ff ff47    	bl	0x80270f6 <z_sfnode_next_set> @ imm = #-0x172
 8027268: 6839         	ldr	r1, [r7]
 802726a: 6878         	ldr	r0, [r7, #0x4]
 802726c: f7ff ff64    	bl	0x8027138 <z_sflist_tail_set> @ imm = #-0x138
 8027270: 3708         	adds	r7, #0x8
 8027272: 46bd         	mov	sp, r7
 8027274: bd80         	pop	{r7, pc}

08027276 <sys_sflist_insert>:
; Z_GENLIST_INSERT(sflist, sfnode)
 8027276: b580         	push	{r7, lr}
 8027278: b084         	sub	sp, #0x10
 802727a: af00         	add	r7, sp, #0x0
 802727c: 60f8         	str	r0, [r7, #0xc]
 802727e: 60b9         	str	r1, [r7, #0x8]
 8027280: 607a         	str	r2, [r7, #0x4]
 8027282: 68bb         	ldr	r3, [r7, #0x8]
 8027284: 2b00         	cmp	r3, #0x0
 8027286: d104         	bne	0x8027292 <sys_sflist_insert+0x1c> @ imm = #0x8
 8027288: 6879         	ldr	r1, [r7, #0x4]
 802728a: 68f8         	ldr	r0, [r7, #0xc]
 802728c: f7ff ffaa    	bl	0x80271e4 <sys_sflist_prepend> @ imm = #-0xac
 8027290: e016         	b	0x80272c0 <sys_sflist_insert+0x4a> @ imm = #0x2c
 8027292: 68b8         	ldr	r0, [r7, #0x8]
 8027294: f7ff ff21    	bl	0x80270da <z_sfnode_next_peek> @ imm = #-0x1be
 8027298: 4603         	mov	r3, r0
 802729a: 2b00         	cmp	r3, #0x0
 802729c: d104         	bne	0x80272a8 <sys_sflist_insert+0x32> @ imm = #0x8
 802729e: 6879         	ldr	r1, [r7, #0x4]
 80272a0: 68f8         	ldr	r0, [r7, #0xc]
 80272a2: f7ff ffc1    	bl	0x8027228 <sys_sflist_append> @ imm = #-0x7e
 80272a6: e00b         	b	0x80272c0 <sys_sflist_insert+0x4a> @ imm = #0x16
 80272a8: 68b8         	ldr	r0, [r7, #0x8]
 80272aa: f7ff ff16    	bl	0x80270da <z_sfnode_next_peek> @ imm = #-0x1d4
 80272ae: 4603         	mov	r3, r0
 80272b0: 4619         	mov	r1, r3
 80272b2: 6878         	ldr	r0, [r7, #0x4]
 80272b4: f7ff ff1f    	bl	0x80270f6 <z_sfnode_next_set> @ imm = #-0x1c2
 80272b8: 6879         	ldr	r1, [r7, #0x4]
 80272ba: 68b8         	ldr	r0, [r7, #0x8]
 80272bc: f7ff ff1b    	bl	0x80270f6 <z_sfnode_next_set> @ imm = #-0x1ca
 80272c0: 3710         	adds	r7, #0x10
 80272c2: 46bd         	mov	sp, r7
 80272c4: bd80         	pop	{r7, pc}

080272c6 <sys_sflist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
 80272c6: b580         	push	{r7, lr}
 80272c8: b084         	sub	sp, #0x10
 80272ca: af00         	add	r7, sp, #0x0
 80272cc: 6078         	str	r0, [r7, #0x4]
 80272ce: 6878         	ldr	r0, [r7, #0x4]
 80272d0: f7ff ff40    	bl	0x8027154 <sys_sflist_peek_head> @ imm = #-0x180
 80272d4: 60f8         	str	r0, [r7, #0xc]
 80272d6: 68f8         	ldr	r0, [r7, #0xc]
 80272d8: f7ff feff    	bl	0x80270da <z_sfnode_next_peek> @ imm = #-0x202
 80272dc: 4603         	mov	r3, r0
 80272de: 4619         	mov	r1, r3
 80272e0: 6878         	ldr	r0, [r7, #0x4]
 80272e2: f7ff ff1b    	bl	0x802711c <z_sflist_head_set> @ imm = #-0x1ca
 80272e6: 6878         	ldr	r0, [r7, #0x4]
 80272e8: f7ff ff40    	bl	0x802716c <sys_sflist_peek_tail> @ imm = #-0x180
 80272ec: 4602         	mov	r2, r0
 80272ee: 68fb         	ldr	r3, [r7, #0xc]
 80272f0: 4293         	cmp	r3, r2
 80272f2: d107         	bne	0x8027304 <sys_sflist_get_not_empty+0x3e> @ imm = #0xe
 80272f4: 6878         	ldr	r0, [r7, #0x4]
 80272f6: f7ff ff2d    	bl	0x8027154 <sys_sflist_peek_head> @ imm = #-0x1a6
 80272fa: 4603         	mov	r3, r0
 80272fc: 4619         	mov	r1, r3
 80272fe: 6878         	ldr	r0, [r7, #0x4]
 8027300: f7ff ff1a    	bl	0x8027138 <z_sflist_tail_set> @ imm = #-0x1cc
 8027304: 68fb         	ldr	r3, [r7, #0xc]
 8027306: 4618         	mov	r0, r3
 8027308: 3710         	adds	r7, #0x10
 802730a: 46bd         	mov	sp, r7
 802730c: bd80         	pop	{r7, pc}

0802730e <z_abort_thread_timeout>:
; {
 802730e: b580         	push	{r7, lr}
 8027310: b082         	sub	sp, #0x8
 8027312: af00         	add	r7, sp, #0x0
 8027314: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8027316: 687b         	ldr	r3, [r7, #0x4]
 8027318: 3318         	adds	r3, #0x18
 802731a: 4618         	mov	r0, r3
 802731c: f7f0 ffb0    	bl	0x8018280 <z_abort_timeout> @ imm = #-0xf0a0
 8027320: 4603         	mov	r3, r0
; }
 8027322: 4618         	mov	r0, r3
 8027324: 3708         	adds	r7, #0x8
 8027326: 46bd         	mov	sp, r7
 8027328: bd80         	pop	{r7, pc}

0802732a <z_thread_malloc>:
; {
 802732a: b580         	push	{r7, lr}
 802732c: b082         	sub	sp, #0x8
 802732e: af00         	add	r7, sp, #0x0
 8027330: 6078         	str	r0, [r7, #0x4]
; 	return z_thread_aligned_alloc(0, size);
 8027332: 6879         	ldr	r1, [r7, #0x4]
 8027334: 2000         	movs	r0, #0x0
 8027336: f7f1 faab    	bl	0x8018890 <z_thread_aligned_alloc> @ imm = #-0xeaaa
 802733a: 4603         	mov	r3, r0
; }
 802733c: 4618         	mov	r0, r3
 802733e: 3708         	adds	r7, #0x8
 8027340: 46bd         	mov	sp, r7
 8027342: bd80         	pop	{r7, pc}

08027344 <z_mark_thread_as_not_pending>:
; {
 8027344: b480         	push	{r7}
 8027346: b083         	sub	sp, #0xc
 8027348: af00         	add	r7, sp, #0x0
 802734a: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 802734c: 687b         	ldr	r3, [r7, #0x4]
 802734e: 7b5b         	ldrb	r3, [r3, #0xd]
 8027350: f023 0302    	bic	r3, r3, #0x2
 8027354: b2da         	uxtb	r2, r3
 8027356: 687b         	ldr	r3, [r7, #0x4]
 8027358: 735a         	strb	r2, [r3, #0xd]
; }
 802735a: bf00         	nop
 802735c: 370c         	adds	r7, #0xc
 802735e: 46bd         	mov	sp, r7
 8027360: f85d 7b04    	ldr	r7, [sp], #4
 8027364: 4770         	bx	lr

08027366 <unpend_thread_no_timeout>:
; {
 8027366: b580         	push	{r7, lr}
 8027368: b086         	sub	sp, #0x18
 802736a: af00         	add	r7, sp, #0x0
 802736c: 6078         	str	r0, [r7, #0x4]
 802736e: 687b         	ldr	r3, [r7, #0x4]
 8027370: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8027372: 68fb         	ldr	r3, [r7, #0xc]
 8027374: 689b         	ldr	r3, [r3, #0x8]
 8027376: 617b         	str	r3, [r7, #0x14]
 8027378: 687b         	ldr	r3, [r7, #0x4]
 802737a: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 802737c: 693b         	ldr	r3, [r7, #0x10]
 802737e: 4618         	mov	r0, r3
 8027380: f7ff fe94    	bl	0x80270ac <sys_dlist_remove> @ imm = #-0x2d8
; }
 8027384: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8027386: 6878         	ldr	r0, [r7, #0x4]
 8027388: f7ff ffdc    	bl	0x8027344 <z_mark_thread_as_not_pending> @ imm = #-0x48
; 	thread->base.pended_on = NULL;
 802738c: 687b         	ldr	r3, [r7, #0x4]
 802738e: 2200         	movs	r2, #0x0
 8027390: 609a         	str	r2, [r3, #0x8]
; }
 8027392: bf00         	nop
 8027394: 3718         	adds	r7, #0x18
 8027396: 46bd         	mov	sp, r7
 8027398: bd80         	pop	{r7, pc}

0802739a <z_queue_node_peek>:
; {
 802739a: b580         	push	{r7, lr}
 802739c: b084         	sub	sp, #0x10
 802739e: af00         	add	r7, sp, #0x0
 80273a0: 6078         	str	r0, [r7, #0x4]
 80273a2: 460b         	mov	r3, r1
 80273a4: 70fb         	strb	r3, [r7, #0x3]
; 	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
 80273a6: 687b         	ldr	r3, [r7, #0x4]
 80273a8: 2b00         	cmp	r3, #0x0
 80273aa: d011         	beq	0x80273d0 <z_queue_node_peek+0x36> @ imm = #0x22
 80273ac: 6878         	ldr	r0, [r7, #0x4]
 80273ae: f7ff fee9    	bl	0x8027184 <sys_sfnode_flags_get> @ imm = #-0x22e
 80273b2: 4603         	mov	r3, r0
 80273b4: 2b00         	cmp	r3, #0x0
 80273b6: d00b         	beq	0x80273d0 <z_queue_node_peek+0x36> @ imm = #0x16
; 		anode = CONTAINER_OF(node, struct alloc_node, node);
 80273b8: 687b         	ldr	r3, [r7, #0x4]
 80273ba: 60bb         	str	r3, [r7, #0x8]
; 		ret = anode->data;
 80273bc: 68bb         	ldr	r3, [r7, #0x8]
 80273be: 685b         	ldr	r3, [r3, #0x4]
 80273c0: 60fb         	str	r3, [r7, #0xc]
; 		if (needs_free) {
 80273c2: 78fb         	ldrb	r3, [r7, #0x3]
 80273c4: 2b00         	cmp	r3, #0x0
 80273c6: d006         	beq	0x80273d6 <z_queue_node_peek+0x3c> @ imm = #0xc
; 			k_free(anode);
 80273c8: 68b8         	ldr	r0, [r7, #0x8]
 80273ca: f001 fe6d    	bl	0x80290a8 <k_free>      @ imm = #0x1cda
; 	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
 80273ce: e002         	b	0x80273d6 <z_queue_node_peek+0x3c> @ imm = #0x4
; 		ret = (void *)node;
 80273d0: 687b         	ldr	r3, [r7, #0x4]
 80273d2: 60fb         	str	r3, [r7, #0xc]
 80273d4: e000         	b	0x80273d8 <z_queue_node_peek+0x3e> @ imm = #0x0
; 	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
 80273d6: bf00         	nop
; 	return ret;
 80273d8: 68fb         	ldr	r3, [r7, #0xc]
; }
 80273da: 4618         	mov	r0, r3
 80273dc: 3710         	adds	r7, #0x10
 80273de: 46bd         	mov	sp, r7
 80273e0: bd80         	pop	{r7, pc}

080273e2 <prepare_thread_to_run>:
; {
 80273e2: b580         	push	{r7, lr}
 80273e4: b088         	sub	sp, #0x20
 80273e6: af00         	add	r7, sp, #0x0
 80273e8: 6078         	str	r0, [r7, #0x4]
 80273ea: 6039         	str	r1, [r7]
 80273ec: 687b         	ldr	r3, [r7, #0x4]
 80273ee: 61fb         	str	r3, [r7, #0x1c]
 80273f0: 2300         	movs	r3, #0x0
 80273f2: 61bb         	str	r3, [r7, #0x18]
 80273f4: 683b         	ldr	r3, [r7]
 80273f6: 617b         	str	r3, [r7, #0x14]
 80273f8: 69fb         	ldr	r3, [r7, #0x1c]
 80273fa: 613b         	str	r3, [r7, #0x10]
 80273fc: 69bb         	ldr	r3, [r7, #0x18]
 80273fe: 60fb         	str	r3, [r7, #0xc]
; 	thread->arch.swap_return_value = value;
 8027400: 693b         	ldr	r3, [r7, #0x10]
 8027402: 68fa         	ldr	r2, [r7, #0xc]
 8027404: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8027408: bf00         	nop
; 	thread->base.swap_data = data;
 802740a: 69fb         	ldr	r3, [r7, #0x1c]
 802740c: 697a         	ldr	r2, [r7, #0x14]
 802740e: 615a         	str	r2, [r3, #0x14]
; }
 8027410: bf00         	nop
; 	z_ready_thread(thread);
 8027412: 6878         	ldr	r0, [r7, #0x4]
 8027414: f7ef f8f6    	bl	0x8016604 <z_ready_thread> @ imm = #-0x10e14
; }
 8027418: bf00         	nop
 802741a: 3720         	adds	r7, #0x20
 802741c: 46bd         	mov	sp, r7
 802741e: bd80         	pop	{r7, pc}

08027420 <handle_poll_events>:
; {
 8027420: b480         	push	{r7}
 8027422: b083         	sub	sp, #0xc
 8027424: af00         	add	r7, sp, #0x0
 8027426: 6078         	str	r0, [r7, #0x4]
 8027428: 6039         	str	r1, [r7]
; }
 802742a: bf00         	nop
 802742c: 370c         	adds	r7, #0xc
 802742e: 46bd         	mov	sp, r7
 8027430: f85d 7b04    	ldr	r7, [sp], #4
 8027434: 4770         	bx	lr

08027436 <queue_insert>:
; {
 8027436: b580         	push	{r7, lr}
 8027438: b098         	sub	sp, #0x60
 802743a: af00         	add	r7, sp, #0x0
 802743c: 60f8         	str	r0, [r7, #0xc]
 802743e: 60b9         	str	r1, [r7, #0x8]
 8027440: 607a         	str	r2, [r7, #0x4]
 8027442: 70fb         	strb	r3, [r7, #0x3]
; 	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 8027444: 68fb         	ldr	r3, [r7, #0xc]
 8027446: 3308         	adds	r3, #0x8
 8027448: 657b         	str	r3, [r7, #0x54]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 802744a: f3ef 8311    	mrs	r3, basepri
 802744e: 653b         	str	r3, [r7, #0x50]
;   return(result);
 8027450: 6d3b         	ldr	r3, [r7, #0x50]
; 	key = __get_BASEPRI();
 8027452: 64fb         	str	r3, [r7, #0x4c]
 8027454: 2310         	movs	r3, #0x10
 8027456: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8027458: 6cbb         	ldr	r3, [r7, #0x48]
 802745a: f383 8812    	msr	basepri_max, r3
; }
 802745e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8027460: f3bf 8f6f    	isb	sy
; }
 8027464: bf00         	nop
; 	return key;
 8027466: 6cfb         	ldr	r3, [r7, #0x4c]
; 	k.key = arch_irq_lock();
 8027468: 61bb         	str	r3, [r7, #0x18]
 802746a: 6d7b         	ldr	r3, [r7, #0x54]
 802746c: 647b         	str	r3, [r7, #0x44]
; }
 802746e: bf00         	nop
 8027470: 6d7b         	ldr	r3, [r7, #0x54]
 8027472: 643b         	str	r3, [r7, #0x40]
; }
 8027474: bf00         	nop
; 	return k;
 8027476: 69bb         	ldr	r3, [r7, #0x18]
 8027478: 61fb         	str	r3, [r7, #0x1c]
; 	if (is_append) {
 802747a: f897 3068    	ldrb.w	r3, [r7, #0x68]
 802747e: 2b00         	cmp	r3, #0x0
 8027480: d004         	beq	0x802748c <queue_insert+0x56> @ imm = #0x8
; 		prev = sys_sflist_peek_tail(&queue->data_q);
 8027482: 68fb         	ldr	r3, [r7, #0xc]
 8027484: 4618         	mov	r0, r3
 8027486: f7ff fe71    	bl	0x802716c <sys_sflist_peek_tail> @ imm = #-0x31e
 802748a: 60b8         	str	r0, [r7, #0x8]
; 	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
 802748c: 68fb         	ldr	r3, [r7, #0xc]
 802748e: 3308         	adds	r3, #0x8
 8027490: 63fb         	str	r3, [r7, #0x3c]
; 	struct k_thread *thread = NULL;
 8027492: 2300         	movs	r3, #0x0
 8027494: 63bb         	str	r3, [r7, #0x38]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8027496: 6bfb         	ldr	r3, [r7, #0x3c]
 8027498: 637b         	str	r3, [r7, #0x34]
; 	struct k_thread *thread = NULL;
 802749a: 2300         	movs	r3, #0x0
 802749c: 633b         	str	r3, [r7, #0x30]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 802749e: 6b78         	ldr	r0, [r7, #0x34]
 80274a0: f7ff fdf2    	bl	0x8027088 <sys_dlist_peek_head> @ imm = #-0x41c
 80274a4: 62f8         	str	r0, [r7, #0x2c]
; 	if (n != NULL) {
 80274a6: 6afb         	ldr	r3, [r7, #0x2c]
 80274a8: 2b00         	cmp	r3, #0x0
 80274aa: d001         	beq	0x80274b0 <queue_insert+0x7a> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 80274ac: 6afb         	ldr	r3, [r7, #0x2c]
 80274ae: 633b         	str	r3, [r7, #0x30]
; 	return thread;
 80274b0: 6b3b         	ldr	r3, [r7, #0x30]
; 		thread = _priq_wait_best(&wait_q->waitq);
 80274b2: 63bb         	str	r3, [r7, #0x38]
; 		if (unlikely(thread != NULL)) {
 80274b4: 6bbb         	ldr	r3, [r7, #0x38]
 80274b6: 2b00         	cmp	r3, #0x0
 80274b8: bf14         	ite	ne
 80274ba: 2301         	movne	r3, #0x1
 80274bc: 2300         	moveq	r3, #0x0
 80274be: b2db         	uxtb	r3, r3
 80274c0: 2b00         	cmp	r3, #0x0
 80274c2: d005         	beq	0x80274d0 <queue_insert+0x9a> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 80274c4: 6bb8         	ldr	r0, [r7, #0x38]
 80274c6: f7ff ff4e    	bl	0x8027366 <unpend_thread_no_timeout> @ imm = #-0x164
; 			(void)z_abort_thread_timeout(thread);
 80274ca: 6bb8         	ldr	r0, [r7, #0x38]
 80274cc: f7ff ff1f    	bl	0x802730e <z_abort_thread_timeout> @ imm = #-0x1c2
; 	return thread;
 80274d0: 6bbb         	ldr	r3, [r7, #0x38]
; 	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
 80274d2: 65fb         	str	r3, [r7, #0x5c]
; 	if (unlikely(first_pending_thread != NULL)) {
 80274d4: 6dfb         	ldr	r3, [r7, #0x5c]
 80274d6: 2b00         	cmp	r3, #0x0
 80274d8: bf14         	ite	ne
 80274da: 2301         	movne	r3, #0x1
 80274dc: 2300         	moveq	r3, #0x0
 80274de: b2db         	uxtb	r3, r3
 80274e0: 2b00         	cmp	r3, #0x0
 80274e2: d00b         	beq	0x80274fc <queue_insert+0xc6> @ imm = #0x16
; 		prepare_thread_to_run(first_pending_thread, data);
 80274e4: 6879         	ldr	r1, [r7, #0x4]
 80274e6: 6df8         	ldr	r0, [r7, #0x5c]
 80274e8: f7ff ff7b    	bl	0x80273e2 <prepare_thread_to_run> @ imm = #-0x10a
; 		z_reschedule(&queue->lock, key);
 80274ec: 68fb         	ldr	r3, [r7, #0xc]
 80274ee: 3308         	adds	r3, #0x8
 80274f0: 69f9         	ldr	r1, [r7, #0x1c]
 80274f2: 4618         	mov	r0, r3
 80274f4: f001 fa32    	bl	0x802895c <z_reschedule> @ imm = #0x1464
; 		return 0;
 80274f8: 2300         	movs	r3, #0x0
 80274fa: e03e         	b	0x802757a <queue_insert+0x144> @ imm = #0x7c
; 	if (alloc) {
 80274fc: 78fb         	ldrb	r3, [r7, #0x3]
 80274fe: 2b00         	cmp	r3, #0x0
 8027500: d026         	beq	0x8027550 <queue_insert+0x11a> @ imm = #0x4c
; 		anode = z_thread_malloc(sizeof(*anode));
 8027502: 2008         	movs	r0, #0x8
 8027504: f7ff ff11    	bl	0x802732a <z_thread_malloc> @ imm = #-0x1de
 8027508: 65b8         	str	r0, [r7, #0x58]
; 		if (anode == NULL) {
 802750a: 6dbb         	ldr	r3, [r7, #0x58]
 802750c: 2b00         	cmp	r3, #0x0
 802750e: d114         	bne	0x802753a <queue_insert+0x104> @ imm = #0x28
; 			k_spin_unlock(&queue->lock, key);
 8027510: 68fb         	ldr	r3, [r7, #0xc]
 8027512: 3308         	adds	r3, #0x8
 8027514: 62bb         	str	r3, [r7, #0x28]
 8027516: 69fb         	ldr	r3, [r7, #0x1c]
 8027518: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 802751a: 697b         	ldr	r3, [r7, #0x14]
 802751c: 627b         	str	r3, [r7, #0x24]
 802751e: 6a7b         	ldr	r3, [r7, #0x24]
 8027520: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8027522: 6a3b         	ldr	r3, [r7, #0x20]
 8027524: f383 8811    	msr	basepri, r3
; }
 8027528: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 802752a: f3bf 8f6f    	isb	sy
; }
 802752e: bf00         	nop
; }
 8027530: bf00         	nop
; }
 8027532: bf00         	nop
; 			return -ENOMEM;
 8027534: f06f 030b    	mvn	r3, #0xb
 8027538: e01f         	b	0x802757a <queue_insert+0x144> @ imm = #0x3e
; 		anode->data = data;
 802753a: 6dbb         	ldr	r3, [r7, #0x58]
 802753c: 687a         	ldr	r2, [r7, #0x4]
 802753e: 605a         	str	r2, [r3, #0x4]
; 		sys_sfnode_init(&anode->node, 0x1);
 8027540: 6dbb         	ldr	r3, [r7, #0x58]
 8027542: 2101         	movs	r1, #0x1
 8027544: 4618         	mov	r0, r3
 8027546: f7ff fe2d    	bl	0x80271a4 <sys_sfnode_init> @ imm = #-0x3a6
; 		data = anode;
 802754a: 6dbb         	ldr	r3, [r7, #0x58]
 802754c: 607b         	str	r3, [r7, #0x4]
 802754e: e003         	b	0x8027558 <queue_insert+0x122> @ imm = #0x6
; 		sys_sfnode_init(data, 0x0);
 8027550: 2100         	movs	r1, #0x0
 8027552: 6878         	ldr	r0, [r7, #0x4]
 8027554: f7ff fe26    	bl	0x80271a4 <sys_sfnode_init> @ imm = #-0x3b4
; 	sys_sflist_insert(&queue->data_q, prev, data);
 8027558: 68fb         	ldr	r3, [r7, #0xc]
 802755a: 687a         	ldr	r2, [r7, #0x4]
 802755c: 68b9         	ldr	r1, [r7, #0x8]
 802755e: 4618         	mov	r0, r3
 8027560: f7ff fe89    	bl	0x8027276 <sys_sflist_insert> @ imm = #-0x2ee
; 	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
 8027564: 2104         	movs	r1, #0x4
 8027566: 68f8         	ldr	r0, [r7, #0xc]
 8027568: f7ff ff5a    	bl	0x8027420 <handle_poll_events> @ imm = #-0x14c
; 	z_reschedule(&queue->lock, key);
 802756c: 68fb         	ldr	r3, [r7, #0xc]
 802756e: 3308         	adds	r3, #0x8
 8027570: 69f9         	ldr	r1, [r7, #0x1c]
 8027572: 4618         	mov	r0, r3
 8027574: f001 f9f2    	bl	0x802895c <z_reschedule> @ imm = #0x13e4
; 	return 0;
 8027578: 2300         	movs	r3, #0x0
; }
 802757a: 4618         	mov	r0, r3
 802757c: 3760         	adds	r7, #0x60
 802757e: 46bd         	mov	sp, r7
 8027580: bd80         	pop	{r7, pc}

08027582 <k_queue_append>:
; {
 8027582: b580         	push	{r7, lr}
 8027584: b084         	sub	sp, #0x10
 8027586: af02         	add	r7, sp, #0x8
 8027588: 6078         	str	r0, [r7, #0x4]
 802758a: 6039         	str	r1, [r7]
; 	(void)queue_insert(queue, NULL, data, false, true);
 802758c: 2301         	movs	r3, #0x1
 802758e: 9300         	str	r3, [sp]
 8027590: 2300         	movs	r3, #0x0
 8027592: 683a         	ldr	r2, [r7]
 8027594: 2100         	movs	r1, #0x0
 8027596: 6878         	ldr	r0, [r7, #0x4]
 8027598: f7ff ff4d    	bl	0x8027436 <queue_insert> @ imm = #-0x166
; }
 802759c: bf00         	nop
 802759e: 3708         	adds	r7, #0x8
 80275a0: 46bd         	mov	sp, r7
 80275a2: bd80         	pop	{r7, pc}

080275a4 <k_queue_prepend>:
; {
 80275a4: b580         	push	{r7, lr}
 80275a6: b084         	sub	sp, #0x10
 80275a8: af02         	add	r7, sp, #0x8
 80275aa: 6078         	str	r0, [r7, #0x4]
 80275ac: 6039         	str	r1, [r7]
; 	(void)queue_insert(queue, NULL, data, false, false);
 80275ae: 2300         	movs	r3, #0x0
 80275b0: 9300         	str	r3, [sp]
 80275b2: 2300         	movs	r3, #0x0
 80275b4: 683a         	ldr	r2, [r7]
 80275b6: 2100         	movs	r1, #0x0
 80275b8: 6878         	ldr	r0, [r7, #0x4]
 80275ba: f7ff ff3c    	bl	0x8027436 <queue_insert> @ imm = #-0x188
; }
 80275be: bf00         	nop
 80275c0: 3708         	adds	r7, #0x8
 80275c2: 46bd         	mov	sp, r7
 80275c4: bd80         	pop	{r7, pc}

080275c6 <sys_dlist_init>:
; {
 80275c6: b480         	push	{r7}
 80275c8: b083         	sub	sp, #0xc
 80275ca: af00         	add	r7, sp, #0x0
 80275cc: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 80275ce: 687b         	ldr	r3, [r7, #0x4]
 80275d0: 687a         	ldr	r2, [r7, #0x4]
 80275d2: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 80275d4: 687b         	ldr	r3, [r7, #0x4]
 80275d6: 687a         	ldr	r2, [r7, #0x4]
 80275d8: 605a         	str	r2, [r3, #0x4]
; }
 80275da: bf00         	nop
 80275dc: 370c         	adds	r7, #0xc
 80275de: 46bd         	mov	sp, r7
 80275e0: f85d 7b04    	ldr	r7, [sp], #4
 80275e4: 4770         	bx	lr

080275e6 <sys_dnode_init>:
; {
 80275e6: b480         	push	{r7}
 80275e8: b083         	sub	sp, #0xc
 80275ea: af00         	add	r7, sp, #0x0
 80275ec: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 80275ee: 687b         	ldr	r3, [r7, #0x4]
 80275f0: 2200         	movs	r2, #0x0
 80275f2: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 80275f4: 687b         	ldr	r3, [r7, #0x4]
 80275f6: 2200         	movs	r2, #0x0
 80275f8: 605a         	str	r2, [r3, #0x4]
; }
 80275fa: bf00         	nop
 80275fc: 370c         	adds	r7, #0xc
 80275fe: 46bd         	mov	sp, r7
 8027600: f85d 7b04    	ldr	r7, [sp], #4
 8027604: 4770         	bx	lr

08027606 <sys_dlist_is_empty>:
; {
 8027606: b480         	push	{r7}
 8027608: b083         	sub	sp, #0xc
 802760a: af00         	add	r7, sp, #0x0
 802760c: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 802760e: 687b         	ldr	r3, [r7, #0x4]
 8027610: 681b         	ldr	r3, [r3]
 8027612: 687a         	ldr	r2, [r7, #0x4]
 8027614: 429a         	cmp	r2, r3
 8027616: bf0c         	ite	eq
 8027618: 2301         	moveq	r3, #0x1
 802761a: 2300         	movne	r3, #0x0
 802761c: b2db         	uxtb	r3, r3
; }
 802761e: 4618         	mov	r0, r3
 8027620: 370c         	adds	r7, #0xc
 8027622: 46bd         	mov	sp, r7
 8027624: f85d 7b04    	ldr	r7, [sp], #4
 8027628: 4770         	bx	lr

0802762a <sys_dlist_peek_head>:
; {
 802762a: b580         	push	{r7, lr}
 802762c: b082         	sub	sp, #0x8
 802762e: af00         	add	r7, sp, #0x0
 8027630: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8027632: 6878         	ldr	r0, [r7, #0x4]
 8027634: f7ff ffe7    	bl	0x8027606 <sys_dlist_is_empty> @ imm = #-0x32
 8027638: 4603         	mov	r3, r0
 802763a: 2b00         	cmp	r3, #0x0
 802763c: d102         	bne	0x8027644 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 802763e: 687b         	ldr	r3, [r7, #0x4]
 8027640: 681b         	ldr	r3, [r3]
 8027642: e000         	b	0x8027646 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8027644: 2300         	movs	r3, #0x0
; }
 8027646: 4618         	mov	r0, r3
 8027648: 3708         	adds	r7, #0x8
 802764a: 46bd         	mov	sp, r7
 802764c: bd80         	pop	{r7, pc}

0802764e <sys_dlist_remove>:
; {
 802764e: b580         	push	{r7, lr}
 8027650: b084         	sub	sp, #0x10
 8027652: af00         	add	r7, sp, #0x0
 8027654: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8027656: 687b         	ldr	r3, [r7, #0x4]
 8027658: 685b         	ldr	r3, [r3, #0x4]
 802765a: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 802765c: 687b         	ldr	r3, [r7, #0x4]
 802765e: 681b         	ldr	r3, [r3]
 8027660: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8027662: 68fb         	ldr	r3, [r7, #0xc]
 8027664: 68ba         	ldr	r2, [r7, #0x8]
 8027666: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8027668: 68bb         	ldr	r3, [r7, #0x8]
 802766a: 68fa         	ldr	r2, [r7, #0xc]
 802766c: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 802766e: 6878         	ldr	r0, [r7, #0x4]
 8027670: f7ff ffb9    	bl	0x80275e6 <sys_dnode_init> @ imm = #-0x8e
; }
 8027674: bf00         	nop
 8027676: 3710         	adds	r7, #0x10
 8027678: 46bd         	mov	sp, r7
 802767a: bd80         	pop	{r7, pc}

0802767c <k_object_init>:
; {
 802767c: b480         	push	{r7}
 802767e: b083         	sub	sp, #0xc
 8027680: af00         	add	r7, sp, #0x0
 8027682: 6078         	str	r0, [r7, #0x4]
; }
 8027684: bf00         	nop
 8027686: 370c         	adds	r7, #0xc
 8027688: 46bd         	mov	sp, r7
 802768a: f85d 7b04    	ldr	r7, [sp], #4
 802768e: 4770         	bx	lr

08027690 <z_abort_thread_timeout>:
; {
 8027690: b580         	push	{r7, lr}
 8027692: b082         	sub	sp, #0x8
 8027694: af00         	add	r7, sp, #0x0
 8027696: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8027698: 687b         	ldr	r3, [r7, #0x4]
 802769a: 3318         	adds	r3, #0x18
 802769c: 4618         	mov	r0, r3
 802769e: f7f0 fdef    	bl	0x8018280 <z_abort_timeout> @ imm = #-0xf422
 80276a2: 4603         	mov	r3, r0
; }
 80276a4: 4618         	mov	r0, r3
 80276a6: 3708         	adds	r7, #0x8
 80276a8: 46bd         	mov	sp, r7
 80276aa: bd80         	pop	{r7, pc}

080276ac <z_waitq_init>:
; {
 80276ac: b580         	push	{r7, lr}
 80276ae: b082         	sub	sp, #0x8
 80276b0: af00         	add	r7, sp, #0x0
 80276b2: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 80276b4: 687b         	ldr	r3, [r7, #0x4]
 80276b6: 4618         	mov	r0, r3
 80276b8: f7ff ff85    	bl	0x80275c6 <sys_dlist_init> @ imm = #-0xf6
; }
 80276bc: bf00         	nop
 80276be: 3708         	adds	r7, #0x8
 80276c0: 46bd         	mov	sp, r7
 80276c2: bd80         	pop	{r7, pc}

080276c4 <z_mark_thread_as_not_pending>:
; {
 80276c4: b480         	push	{r7}
 80276c6: b083         	sub	sp, #0xc
 80276c8: af00         	add	r7, sp, #0x0
 80276ca: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 80276cc: 687b         	ldr	r3, [r7, #0x4]
 80276ce: 7b5b         	ldrb	r3, [r3, #0xd]
 80276d0: f023 0302    	bic	r3, r3, #0x2
 80276d4: b2da         	uxtb	r2, r3
 80276d6: 687b         	ldr	r3, [r7, #0x4]
 80276d8: 735a         	strb	r2, [r3, #0xd]
; }
 80276da: bf00         	nop
 80276dc: 370c         	adds	r7, #0xc
 80276de: 46bd         	mov	sp, r7
 80276e0: f85d 7b04    	ldr	r7, [sp], #4
 80276e4: 4770         	bx	lr

080276e6 <unpend_thread_no_timeout>:
; {
 80276e6: b580         	push	{r7, lr}
 80276e8: b086         	sub	sp, #0x18
 80276ea: af00         	add	r7, sp, #0x0
 80276ec: 6078         	str	r0, [r7, #0x4]
 80276ee: 687b         	ldr	r3, [r7, #0x4]
 80276f0: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 80276f2: 68fb         	ldr	r3, [r7, #0xc]
 80276f4: 689b         	ldr	r3, [r3, #0x8]
 80276f6: 617b         	str	r3, [r7, #0x14]
 80276f8: 687b         	ldr	r3, [r7, #0x4]
 80276fa: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 80276fc: 693b         	ldr	r3, [r7, #0x10]
 80276fe: 4618         	mov	r0, r3
 8027700: f7ff ffa5    	bl	0x802764e <sys_dlist_remove> @ imm = #-0xb6
; }
 8027704: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8027706: 6878         	ldr	r0, [r7, #0x4]
 8027708: f7ff ffdc    	bl	0x80276c4 <z_mark_thread_as_not_pending> @ imm = #-0x48
; 	thread->base.pended_on = NULL;
 802770c: 687b         	ldr	r3, [r7, #0x4]
 802770e: 2200         	movs	r2, #0x0
 8027710: 609a         	str	r2, [r3, #0x8]
; }
 8027712: bf00         	nop
 8027714: 3718         	adds	r7, #0x18
 8027716: 46bd         	mov	sp, r7
 8027718: bd80         	pop	{r7, pc}

0802771a <z_impl_k_sem_init>:
; {
 802771a: b580         	push	{r7, lr}
 802771c: b084         	sub	sp, #0x10
 802771e: af00         	add	r7, sp, #0x0
 8027720: 60f8         	str	r0, [r7, #0xc]
 8027722: 60b9         	str	r1, [r7, #0x8]
 8027724: 607a         	str	r2, [r7, #0x4]
; 	CHECKIF(limit == 0U || initial_count > limit) {
 8027726: 687b         	ldr	r3, [r7, #0x4]
 8027728: 2b00         	cmp	r3, #0x0
 802772a: d003         	beq	0x8027734 <z_impl_k_sem_init+0x1a> @ imm = #0x6
 802772c: 68ba         	ldr	r2, [r7, #0x8]
 802772e: 687b         	ldr	r3, [r7, #0x4]
 8027730: 429a         	cmp	r2, r3
 8027732: d902         	bls	0x802773a <z_impl_k_sem_init+0x20> @ imm = #0x4
; 		return -EINVAL;
 8027734: f06f 0315    	mvn	r3, #0x15
 8027738: e00d         	b	0x8027756 <z_impl_k_sem_init+0x3c> @ imm = #0x1a
; 	sem->count = initial_count;
 802773a: 68fb         	ldr	r3, [r7, #0xc]
 802773c: 68ba         	ldr	r2, [r7, #0x8]
 802773e: 609a         	str	r2, [r3, #0x8]
; 	sem->limit = limit;
 8027740: 68fb         	ldr	r3, [r7, #0xc]
 8027742: 687a         	ldr	r2, [r7, #0x4]
 8027744: 60da         	str	r2, [r3, #0xc]
; 	z_waitq_init(&sem->wait_q);
 8027746: 68fb         	ldr	r3, [r7, #0xc]
 8027748: 4618         	mov	r0, r3
 802774a: f7ff ffaf    	bl	0x80276ac <z_waitq_init> @ imm = #-0xa2
; 	k_object_init(sem);
 802774e: 68f8         	ldr	r0, [r7, #0xc]
 8027750: f7ff ff94    	bl	0x802767c <k_object_init> @ imm = #-0xd8
; 	return 0;
 8027754: 2300         	movs	r3, #0x0
; }
 8027756: 4618         	mov	r0, r3
 8027758: 3710         	adds	r7, #0x10
 802775a: 46bd         	mov	sp, r7
 802775c: bd80         	pop	{r7, pc}

0802775e <handle_poll_events>:
; {
 802775e: b480         	push	{r7}
 8027760: b083         	sub	sp, #0xc
 8027762: af00         	add	r7, sp, #0x0
 8027764: 6078         	str	r0, [r7, #0x4]
; 	return false;
 8027766: 2300         	movs	r3, #0x0
; }
 8027768: 4618         	mov	r0, r3
 802776a: 370c         	adds	r7, #0xc
 802776c: 46bd         	mov	sp, r7
 802776e: f85d 7b04    	ldr	r7, [sp], #4
 8027772: 4770         	bx	lr

08027774 <sys_dlist_init>:
; {
 8027774: b480         	push	{r7}
 8027776: b083         	sub	sp, #0xc
 8027778: af00         	add	r7, sp, #0x0
 802777a: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 802777c: 687b         	ldr	r3, [r7, #0x4]
 802777e: 687a         	ldr	r2, [r7, #0x4]
 8027780: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8027782: 687b         	ldr	r3, [r7, #0x4]
 8027784: 687a         	ldr	r2, [r7, #0x4]
 8027786: 605a         	str	r2, [r3, #0x4]
; }
 8027788: bf00         	nop
 802778a: 370c         	adds	r7, #0xc
 802778c: 46bd         	mov	sp, r7
 802778e: f85d 7b04    	ldr	r7, [sp], #4
 8027792: 4770         	bx	lr

08027794 <sys_dnode_init>:
; {
 8027794: b480         	push	{r7}
 8027796: b083         	sub	sp, #0xc
 8027798: af00         	add	r7, sp, #0x0
 802779a: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 802779c: 687b         	ldr	r3, [r7, #0x4]
 802779e: 2200         	movs	r2, #0x0
 80277a0: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 80277a2: 687b         	ldr	r3, [r7, #0x4]
 80277a4: 2200         	movs	r2, #0x0
 80277a6: 605a         	str	r2, [r3, #0x4]
; }
 80277a8: bf00         	nop
 80277aa: 370c         	adds	r7, #0xc
 80277ac: 46bd         	mov	sp, r7
 80277ae: f85d 7b04    	ldr	r7, [sp], #4
 80277b2: 4770         	bx	lr

080277b4 <sys_slist_init>:
; {
 80277b4: b480         	push	{r7}
 80277b6: b083         	sub	sp, #0xc
 80277b8: af00         	add	r7, sp, #0x0
 80277ba: 6078         	str	r0, [r7, #0x4]
; 	list->head = NULL;
 80277bc: 687b         	ldr	r3, [r7, #0x4]
 80277be: 2200         	movs	r2, #0x0
 80277c0: 601a         	str	r2, [r3]
; 	list->tail = NULL;
 80277c2: 687b         	ldr	r3, [r7, #0x4]
 80277c4: 2200         	movs	r2, #0x0
 80277c6: 605a         	str	r2, [r3, #0x4]
; }
 80277c8: bf00         	nop
 80277ca: 370c         	adds	r7, #0xc
 80277cc: 46bd         	mov	sp, r7
 80277ce: f85d 7b04    	ldr	r7, [sp], #4
 80277d2: 4770         	bx	lr

080277d4 <z_snode_next_peek>:
; {
 80277d4: b480         	push	{r7}
 80277d6: b083         	sub	sp, #0xc
 80277d8: af00         	add	r7, sp, #0x0
 80277da: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 80277dc: 687b         	ldr	r3, [r7, #0x4]
 80277de: 681b         	ldr	r3, [r3]
; }
 80277e0: 4618         	mov	r0, r3
 80277e2: 370c         	adds	r7, #0xc
 80277e4: 46bd         	mov	sp, r7
 80277e6: f85d 7b04    	ldr	r7, [sp], #4
 80277ea: 4770         	bx	lr

080277ec <z_snode_next_set>:
; {
 80277ec: b480         	push	{r7}
 80277ee: b083         	sub	sp, #0xc
 80277f0: af00         	add	r7, sp, #0x0
 80277f2: 6078         	str	r0, [r7, #0x4]
 80277f4: 6039         	str	r1, [r7]
; 	parent->next = child;
 80277f6: 687b         	ldr	r3, [r7, #0x4]
 80277f8: 683a         	ldr	r2, [r7]
 80277fa: 601a         	str	r2, [r3]
; }
 80277fc: bf00         	nop
 80277fe: 370c         	adds	r7, #0xc
 8027800: 46bd         	mov	sp, r7
 8027802: f85d 7b04    	ldr	r7, [sp], #4
 8027806: 4770         	bx	lr

08027808 <z_slist_head_set>:
; {
 8027808: b480         	push	{r7}
 802780a: b083         	sub	sp, #0xc
 802780c: af00         	add	r7, sp, #0x0
 802780e: 6078         	str	r0, [r7, #0x4]
 8027810: 6039         	str	r1, [r7]
; 	list->head = node;
 8027812: 687b         	ldr	r3, [r7, #0x4]
 8027814: 683a         	ldr	r2, [r7]
 8027816: 601a         	str	r2, [r3]
; }
 8027818: bf00         	nop
 802781a: 370c         	adds	r7, #0xc
 802781c: 46bd         	mov	sp, r7
 802781e: f85d 7b04    	ldr	r7, [sp], #4
 8027822: 4770         	bx	lr

08027824 <z_slist_tail_set>:
; {
 8027824: b480         	push	{r7}
 8027826: b083         	sub	sp, #0xc
 8027828: af00         	add	r7, sp, #0x0
 802782a: 6078         	str	r0, [r7, #0x4]
 802782c: 6039         	str	r1, [r7]
; 	list->tail = node;
 802782e: 687b         	ldr	r3, [r7, #0x4]
 8027830: 683a         	ldr	r2, [r7]
 8027832: 605a         	str	r2, [r3, #0x4]
; }
 8027834: bf00         	nop
 8027836: 370c         	adds	r7, #0xc
 8027838: 46bd         	mov	sp, r7
 802783a: f85d 7b04    	ldr	r7, [sp], #4
 802783e: 4770         	bx	lr

08027840 <sys_slist_peek_head>:
; {
 8027840: b480         	push	{r7}
 8027842: b083         	sub	sp, #0xc
 8027844: af00         	add	r7, sp, #0x0
 8027846: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 8027848: 687b         	ldr	r3, [r7, #0x4]
 802784a: 681b         	ldr	r3, [r3]
; }
 802784c: 4618         	mov	r0, r3
 802784e: 370c         	adds	r7, #0xc
 8027850: 46bd         	mov	sp, r7
 8027852: f85d 7b04    	ldr	r7, [sp], #4
 8027856: 4770         	bx	lr

08027858 <sys_slist_peek_tail>:
; {
 8027858: b480         	push	{r7}
 802785a: b083         	sub	sp, #0xc
 802785c: af00         	add	r7, sp, #0x0
 802785e: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 8027860: 687b         	ldr	r3, [r7, #0x4]
 8027862: 685b         	ldr	r3, [r3, #0x4]
; }
 8027864: 4618         	mov	r0, r3
 8027866: 370c         	adds	r7, #0xc
 8027868: 46bd         	mov	sp, r7
 802786a: f85d 7b04    	ldr	r7, [sp], #4
 802786e: 4770         	bx	lr

08027870 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 8027870: b580         	push	{r7, lr}
 8027872: b082         	sub	sp, #0x8
 8027874: af00         	add	r7, sp, #0x0
 8027876: 6078         	str	r0, [r7, #0x4]
 8027878: 6878         	ldr	r0, [r7, #0x4]
 802787a: f7ff ffe1    	bl	0x8027840 <sys_slist_peek_head> @ imm = #-0x3e
 802787e: 4603         	mov	r3, r0
 8027880: 2b00         	cmp	r3, #0x0
 8027882: bf0c         	ite	eq
 8027884: 2301         	moveq	r3, #0x1
 8027886: 2300         	movne	r3, #0x0
 8027888: b2db         	uxtb	r3, r3
 802788a: 4618         	mov	r0, r3
 802788c: 3708         	adds	r7, #0x8
 802788e: 46bd         	mov	sp, r7
 8027890: bd80         	pop	{r7, pc}

08027892 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8027892: b580         	push	{r7, lr}
 8027894: b082         	sub	sp, #0x8
 8027896: af00         	add	r7, sp, #0x0
 8027898: 6078         	str	r0, [r7, #0x4]
 802789a: 6878         	ldr	r0, [r7, #0x4]
 802789c: f7ff ff9a    	bl	0x80277d4 <z_snode_next_peek> @ imm = #-0xcc
 80278a0: 4603         	mov	r3, r0
 80278a2: 4618         	mov	r0, r3
 80278a4: 3708         	adds	r7, #0x8
 80278a6: 46bd         	mov	sp, r7
 80278a8: bd80         	pop	{r7, pc}

080278aa <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 80278aa: b580         	push	{r7, lr}
 80278ac: b082         	sub	sp, #0x8
 80278ae: af00         	add	r7, sp, #0x0
 80278b0: 6078         	str	r0, [r7, #0x4]
 80278b2: 687b         	ldr	r3, [r7, #0x4]
 80278b4: 2b00         	cmp	r3, #0x0
 80278b6: d004         	beq	0x80278c2 <sys_slist_peek_next+0x18> @ imm = #0x8
 80278b8: 6878         	ldr	r0, [r7, #0x4]
 80278ba: f7ff ffea    	bl	0x8027892 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 80278be: 4603         	mov	r3, r0
 80278c0: e000         	b	0x80278c4 <sys_slist_peek_next+0x1a> @ imm = #0x0
 80278c2: 2300         	movs	r3, #0x0
 80278c4: 4618         	mov	r0, r3
 80278c6: 3708         	adds	r7, #0x8
 80278c8: 46bd         	mov	sp, r7
 80278ca: bd80         	pop	{r7, pc}

080278cc <sys_slist_append>:
; Z_GENLIST_APPEND(slist, snode)
 80278cc: b580         	push	{r7, lr}
 80278ce: b082         	sub	sp, #0x8
 80278d0: af00         	add	r7, sp, #0x0
 80278d2: 6078         	str	r0, [r7, #0x4]
 80278d4: 6039         	str	r1, [r7]
 80278d6: 2100         	movs	r1, #0x0
 80278d8: 6838         	ldr	r0, [r7]
 80278da: f7ff ff87    	bl	0x80277ec <z_snode_next_set> @ imm = #-0xf2
 80278de: 6878         	ldr	r0, [r7, #0x4]
 80278e0: f7ff ffba    	bl	0x8027858 <sys_slist_peek_tail> @ imm = #-0x8c
 80278e4: 4603         	mov	r3, r0
 80278e6: 2b00         	cmp	r3, #0x0
 80278e8: d108         	bne	0x80278fc <sys_slist_append+0x30> @ imm = #0x10
 80278ea: 6839         	ldr	r1, [r7]
 80278ec: 6878         	ldr	r0, [r7, #0x4]
 80278ee: f7ff ff99    	bl	0x8027824 <z_slist_tail_set> @ imm = #-0xce
 80278f2: 6839         	ldr	r1, [r7]
 80278f4: 6878         	ldr	r0, [r7, #0x4]
 80278f6: f7ff ff87    	bl	0x8027808 <z_slist_head_set> @ imm = #-0xf2
 80278fa: e00b         	b	0x8027914 <sys_slist_append+0x48> @ imm = #0x16
 80278fc: 6878         	ldr	r0, [r7, #0x4]
 80278fe: f7ff ffab    	bl	0x8027858 <sys_slist_peek_tail> @ imm = #-0xaa
 8027902: 4603         	mov	r3, r0
 8027904: 6839         	ldr	r1, [r7]
 8027906: 4618         	mov	r0, r3
 8027908: f7ff ff70    	bl	0x80277ec <z_snode_next_set> @ imm = #-0x120
 802790c: 6839         	ldr	r1, [r7]
 802790e: 6878         	ldr	r0, [r7, #0x4]
 8027910: f7ff ff88    	bl	0x8027824 <z_slist_tail_set> @ imm = #-0xf0
 8027914: 3708         	adds	r7, #0x8
 8027916: 46bd         	mov	sp, r7
 8027918: bd80         	pop	{r7, pc}

0802791a <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 802791a: b580         	push	{r7, lr}
 802791c: b084         	sub	sp, #0x10
 802791e: af00         	add	r7, sp, #0x0
 8027920: 6078         	str	r0, [r7, #0x4]
 8027922: 6878         	ldr	r0, [r7, #0x4]
 8027924: f7ff ff8c    	bl	0x8027840 <sys_slist_peek_head> @ imm = #-0xe8
 8027928: 60f8         	str	r0, [r7, #0xc]
 802792a: 68f8         	ldr	r0, [r7, #0xc]
 802792c: f7ff ff52    	bl	0x80277d4 <z_snode_next_peek> @ imm = #-0x15c
 8027930: 4603         	mov	r3, r0
 8027932: 4619         	mov	r1, r3
 8027934: 6878         	ldr	r0, [r7, #0x4]
 8027936: f7ff ff67    	bl	0x8027808 <z_slist_head_set> @ imm = #-0x132
 802793a: 6878         	ldr	r0, [r7, #0x4]
 802793c: f7ff ff8c    	bl	0x8027858 <sys_slist_peek_tail> @ imm = #-0xe8
 8027940: 4602         	mov	r2, r0
 8027942: 68fb         	ldr	r3, [r7, #0xc]
 8027944: 4293         	cmp	r3, r2
 8027946: d107         	bne	0x8027958 <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 8027948: 6878         	ldr	r0, [r7, #0x4]
 802794a: f7ff ff79    	bl	0x8027840 <sys_slist_peek_head> @ imm = #-0x10e
 802794e: 4603         	mov	r3, r0
 8027950: 4619         	mov	r1, r3
 8027952: 6878         	ldr	r0, [r7, #0x4]
 8027954: f7ff ff66    	bl	0x8027824 <z_slist_tail_set> @ imm = #-0x134
 8027958: 68fb         	ldr	r3, [r7, #0xc]
 802795a: 4618         	mov	r0, r3
 802795c: 3710         	adds	r7, #0x10
 802795e: 46bd         	mov	sp, r7
 8027960: bd80         	pop	{r7, pc}

08027962 <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 8027962: b580         	push	{r7, lr}
 8027964: b082         	sub	sp, #0x8
 8027966: af00         	add	r7, sp, #0x0
 8027968: 6078         	str	r0, [r7, #0x4]
 802796a: 6878         	ldr	r0, [r7, #0x4]
 802796c: f7ff ff80    	bl	0x8027870 <sys_slist_is_empty> @ imm = #-0x100
 8027970: 4603         	mov	r3, r0
 8027972: 2b00         	cmp	r3, #0x0
 8027974: d104         	bne	0x8027980 <sys_slist_get+0x1e> @ imm = #0x8
 8027976: 6878         	ldr	r0, [r7, #0x4]
 8027978: f7ff ffcf    	bl	0x802791a <sys_slist_get_not_empty> @ imm = #-0x62
 802797c: 4603         	mov	r3, r0
 802797e: e000         	b	0x8027982 <sys_slist_get+0x20> @ imm = #0x0
 8027980: 2300         	movs	r3, #0x0
 8027982: 4618         	mov	r0, r3
 8027984: 3708         	adds	r7, #0x8
 8027986: 46bd         	mov	sp, r7
 8027988: bd80         	pop	{r7, pc}

0802798a <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 802798a: b580         	push	{r7, lr}
 802798c: b084         	sub	sp, #0x10
 802798e: af00         	add	r7, sp, #0x0
 8027990: 60f8         	str	r0, [r7, #0xc]
 8027992: 60b9         	str	r1, [r7, #0x8]
 8027994: 607a         	str	r2, [r7, #0x4]
 8027996: 68bb         	ldr	r3, [r7, #0x8]
 8027998: 2b00         	cmp	r3, #0x0
 802799a: d117         	bne	0x80279cc <sys_slist_remove+0x42> @ imm = #0x2e
 802799c: 6878         	ldr	r0, [r7, #0x4]
 802799e: f7ff ff19    	bl	0x80277d4 <z_snode_next_peek> @ imm = #-0x1ce
 80279a2: 4603         	mov	r3, r0
 80279a4: 4619         	mov	r1, r3
 80279a6: 68f8         	ldr	r0, [r7, #0xc]
 80279a8: f7ff ff2e    	bl	0x8027808 <z_slist_head_set> @ imm = #-0x1a4
 80279ac: 68f8         	ldr	r0, [r7, #0xc]
 80279ae: f7ff ff53    	bl	0x8027858 <sys_slist_peek_tail> @ imm = #-0x15a
 80279b2: 4602         	mov	r2, r0
 80279b4: 687b         	ldr	r3, [r7, #0x4]
 80279b6: 4293         	cmp	r3, r2
 80279b8: d11b         	bne	0x80279f2 <sys_slist_remove+0x68> @ imm = #0x36
 80279ba: 68f8         	ldr	r0, [r7, #0xc]
 80279bc: f7ff ff40    	bl	0x8027840 <sys_slist_peek_head> @ imm = #-0x180
 80279c0: 4603         	mov	r3, r0
 80279c2: 4619         	mov	r1, r3
 80279c4: 68f8         	ldr	r0, [r7, #0xc]
 80279c6: f7ff ff2d    	bl	0x8027824 <z_slist_tail_set> @ imm = #-0x1a6
 80279ca: e012         	b	0x80279f2 <sys_slist_remove+0x68> @ imm = #0x24
 80279cc: 6878         	ldr	r0, [r7, #0x4]
 80279ce: f7ff ff01    	bl	0x80277d4 <z_snode_next_peek> @ imm = #-0x1fe
 80279d2: 4603         	mov	r3, r0
 80279d4: 4619         	mov	r1, r3
 80279d6: 68b8         	ldr	r0, [r7, #0x8]
 80279d8: f7ff ff08    	bl	0x80277ec <z_snode_next_set> @ imm = #-0x1f0
 80279dc: 68f8         	ldr	r0, [r7, #0xc]
 80279de: f7ff ff3b    	bl	0x8027858 <sys_slist_peek_tail> @ imm = #-0x18a
 80279e2: 4602         	mov	r2, r0
 80279e4: 687b         	ldr	r3, [r7, #0x4]
 80279e6: 4293         	cmp	r3, r2
 80279e8: d103         	bne	0x80279f2 <sys_slist_remove+0x68> @ imm = #0x6
 80279ea: 68b9         	ldr	r1, [r7, #0x8]
 80279ec: 68f8         	ldr	r0, [r7, #0xc]
 80279ee: f7ff ff19    	bl	0x8027824 <z_slist_tail_set> @ imm = #-0x1ce
 80279f2: 2100         	movs	r1, #0x0
 80279f4: 6878         	ldr	r0, [r7, #0x4]
 80279f6: f7ff fef9    	bl	0x80277ec <z_snode_next_set> @ imm = #-0x20e
 80279fa: 3710         	adds	r7, #0x10
 80279fc: 46bd         	mov	sp, r7
 80279fe: bd80         	pop	{r7, pc}

08027a00 <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8027a00: b580         	push	{r7, lr}
 8027a02: b084         	sub	sp, #0x10
 8027a04: af00         	add	r7, sp, #0x0
 8027a06: 6078         	str	r0, [r7, #0x4]
 8027a08: 6039         	str	r1, [r7]
 8027a0a: 2300         	movs	r3, #0x0
 8027a0c: 60fb         	str	r3, [r7, #0xc]
 8027a0e: 6878         	ldr	r0, [r7, #0x4]
 8027a10: f7ff ff16    	bl	0x8027840 <sys_slist_peek_head> @ imm = #-0x1d4
 8027a14: 60b8         	str	r0, [r7, #0x8]
 8027a16: e010         	b	0x8027a3a <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 8027a18: 68ba         	ldr	r2, [r7, #0x8]
 8027a1a: 683b         	ldr	r3, [r7]
 8027a1c: 429a         	cmp	r2, r3
 8027a1e: d106         	bne	0x8027a2e <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 8027a20: 683a         	ldr	r2, [r7]
 8027a22: 68f9         	ldr	r1, [r7, #0xc]
 8027a24: 6878         	ldr	r0, [r7, #0x4]
 8027a26: f7ff ffb0    	bl	0x802798a <sys_slist_remove> @ imm = #-0xa0
 8027a2a: 2301         	movs	r3, #0x1
 8027a2c: e009         	b	0x8027a42 <sys_slist_find_and_remove+0x42> @ imm = #0x12
 8027a2e: 68bb         	ldr	r3, [r7, #0x8]
 8027a30: 60fb         	str	r3, [r7, #0xc]
 8027a32: 68b8         	ldr	r0, [r7, #0x8]
 8027a34: f7ff ff39    	bl	0x80278aa <sys_slist_peek_next> @ imm = #-0x18e
 8027a38: 60b8         	str	r0, [r7, #0x8]
 8027a3a: 68bb         	ldr	r3, [r7, #0x8]
 8027a3c: 2b00         	cmp	r3, #0x0
 8027a3e: d1eb         	bne	0x8027a18 <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 8027a40: 2300         	movs	r3, #0x0
 8027a42: 4618         	mov	r0, r3
 8027a44: 3710         	adds	r7, #0x10
 8027a46: 46bd         	mov	sp, r7
 8027a48: bd80         	pop	{r7, pc}

08027a4a <k_thread_start>:
; {
 8027a4a: b580         	push	{r7, lr}
 8027a4c: b082         	sub	sp, #0x8
 8027a4e: af00         	add	r7, sp, #0x0
 8027a50: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 8027a52: 6878         	ldr	r0, [r7, #0x4]
 8027a54: f000 f82a    	bl	0x8027aac <k_thread_resume> @ imm = #0x54
; }
 8027a58: bf00         	nop
 8027a5a: 3708         	adds	r7, #0x8
 8027a5c: 46bd         	mov	sp, r7
 8027a5e: bd80         	pop	{r7, pc}

08027a60 <k_thread_create>:
; {
 8027a60: b580         	push	{r7, lr}
 8027a62: b08c         	sub	sp, #0x30
 8027a64: af08         	add	r7, sp, #0x20
 8027a66: 60f8         	str	r0, [r7, #0xc]
 8027a68: 60b9         	str	r1, [r7, #0x8]
 8027a6a: 607a         	str	r2, [r7, #0x4]
 8027a6c: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 8027a6e: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8027a72: e9cd 2306    	strd	r2, r3, [sp, #24]
 8027a76: 6abb         	ldr	r3, [r7, #0x28]
 8027a78: 9304         	str	r3, [sp, #0x10]
 8027a7a: 6a7b         	ldr	r3, [r7, #0x24]
 8027a7c: 9303         	str	r3, [sp, #0xc]
 8027a7e: 6a3b         	ldr	r3, [r7, #0x20]
 8027a80: 9302         	str	r3, [sp, #0x8]
 8027a82: 69fb         	ldr	r3, [r7, #0x1c]
 8027a84: 9301         	str	r3, [sp, #0x4]
 8027a86: 69bb         	ldr	r3, [r7, #0x18]
 8027a88: 9300         	str	r3, [sp]
 8027a8a: 683b         	ldr	r3, [r7]
 8027a8c: 687a         	ldr	r2, [r7, #0x4]
 8027a8e: 68b9         	ldr	r1, [r7, #0x8]
 8027a90: 68f8         	ldr	r0, [r7, #0xc]
 8027a92: f000 fac6    	bl	0x8028022 <z_impl_k_thread_create> @ imm = #0x58c
 8027a96: 4603         	mov	r3, r0
; }
 8027a98: 4618         	mov	r0, r3
 8027a9a: 3710         	adds	r7, #0x10
 8027a9c: 46bd         	mov	sp, r7
 8027a9e: bd80         	pop	{r7, pc}

08027aa0 <k_yield>:
; {
 8027aa0: b580         	push	{r7, lr}
 8027aa2: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 8027aa4: f7ef fc94    	bl	0x80173d0 <z_impl_k_yield> @ imm = #-0x106d8
; }
 8027aa8: bf00         	nop
 8027aaa: bd80         	pop	{r7, pc}

08027aac <k_thread_resume>:
; {
 8027aac: b580         	push	{r7, lr}
 8027aae: b082         	sub	sp, #0x8
 8027ab0: af00         	add	r7, sp, #0x0
 8027ab2: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 8027ab4: 6878         	ldr	r0, [r7, #0x4]
 8027ab6: f7ee ffff    	bl	0x8016ab8 <z_impl_k_thread_resume> @ imm = #-0x11002
; }
 8027aba: bf00         	nop
 8027abc: 3708         	adds	r7, #0x8
 8027abe: 46bd         	mov	sp, r7
 8027ac0: bd80         	pop	{r7, pc}

08027ac2 <k_thread_name_set>:
; {
 8027ac2: b580         	push	{r7, lr}
 8027ac4: b082         	sub	sp, #0x8
 8027ac6: af00         	add	r7, sp, #0x0
 8027ac8: 6078         	str	r0, [r7, #0x4]
 8027aca: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 8027acc: 6839         	ldr	r1, [r7]
 8027ace: 6878         	ldr	r0, [r7, #0x4]
 8027ad0: f7ee fa40    	bl	0x8015f54 <z_impl_k_thread_name_set> @ imm = #-0x11b80
 8027ad4: 4603         	mov	r3, r0
; }
 8027ad6: 4618         	mov	r0, r3
 8027ad8: 3708         	adds	r7, #0x8
 8027ada: 46bd         	mov	sp, r7
 8027adc: bd80         	pop	{r7, pc}

08027ade <k_sem_give>:
; {
 8027ade: b580         	push	{r7, lr}
 8027ae0: b082         	sub	sp, #0x8
 8027ae2: af00         	add	r7, sp, #0x0
 8027ae4: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 8027ae6: 6878         	ldr	r0, [r7, #0x4]
 8027ae8: f7ed fdb6    	bl	0x8015658 <z_impl_k_sem_give> @ imm = #-0x12494
; }
 8027aec: bf00         	nop
 8027aee: 3708         	adds	r7, #0x8
 8027af0: 46bd         	mov	sp, r7
 8027af2: bd80         	pop	{r7, pc}

08027af4 <z_init_timeout>:
; {
 8027af4: b580         	push	{r7, lr}
 8027af6: b082         	sub	sp, #0x8
 8027af8: af00         	add	r7, sp, #0x0
 8027afa: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 8027afc: 687b         	ldr	r3, [r7, #0x4]
 8027afe: 4618         	mov	r0, r3
 8027b00: f7ff fe48    	bl	0x8027794 <sys_dnode_init> @ imm = #-0x370
; }
 8027b04: bf00         	nop
 8027b06: 3708         	adds	r7, #0x8
 8027b08: 46bd         	mov	sp, r7
 8027b0a: bd80         	pop	{r7, pc}

08027b0c <z_waitq_init>:
; {
 8027b0c: b580         	push	{r7, lr}
 8027b0e: b082         	sub	sp, #0x8
 8027b10: af00         	add	r7, sp, #0x0
 8027b12: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8027b14: 687b         	ldr	r3, [r7, #0x4]
 8027b16: 4618         	mov	r0, r3
 8027b18: f7ff fe2c    	bl	0x8027774 <sys_dlist_init> @ imm = #-0x3a8
; }
 8027b1c: bf00         	nop
 8027b1e: 3708         	adds	r7, #0x8
 8027b20: 46bd         	mov	sp, r7
 8027b22: bd80         	pop	{r7, pc}

08027b24 <z_sched_wake_all>:
; {
 8027b24: b580         	push	{r7, lr}
 8027b26: b086         	sub	sp, #0x18
 8027b28: af00         	add	r7, sp, #0x0
 8027b2a: 60f8         	str	r0, [r7, #0xc]
 8027b2c: 60b9         	str	r1, [r7, #0x8]
 8027b2e: 607a         	str	r2, [r7, #0x4]
; 	bool woken = false;
 8027b30: 2300         	movs	r3, #0x0
 8027b32: 75fb         	strb	r3, [r7, #0x17]
; 	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 8027b34: e001         	b	0x8027b3a <z_sched_wake_all+0x16> @ imm = #0x2
; 		woken = true;
 8027b36: 2301         	movs	r3, #0x1
 8027b38: 75fb         	strb	r3, [r7, #0x17]
; 	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 8027b3a: 687a         	ldr	r2, [r7, #0x4]
 8027b3c: 68b9         	ldr	r1, [r7, #0x8]
 8027b3e: 68f8         	ldr	r0, [r7, #0xc]
 8027b40: f7ef ffb6    	bl	0x8017ab0 <z_sched_wake> @ imm = #-0x10094
 8027b44: 4603         	mov	r3, r0
 8027b46: 2b00         	cmp	r3, #0x0
 8027b48: d1f5         	bne	0x8027b36 <z_sched_wake_all+0x12> @ imm = #-0x16
; 	return woken;
 8027b4a: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 8027b4c: 4618         	mov	r0, r3
 8027b4e: 3718         	adds	r7, #0x18
 8027b50: 46bd         	mov	sp, r7
 8027b52: bd80         	pop	{r7, pc}

08027b54 <flag_clear>:
; {
 8027b54: b480         	push	{r7}
 8027b56: b083         	sub	sp, #0xc
 8027b58: af00         	add	r7, sp, #0x0
 8027b5a: 6078         	str	r0, [r7, #0x4]
 8027b5c: 6039         	str	r1, [r7]
; 	*flagp &= ~BIT(bit);
 8027b5e: 687b         	ldr	r3, [r7, #0x4]
 8027b60: 681a         	ldr	r2, [r3]
 8027b62: 2101         	movs	r1, #0x1
 8027b64: 683b         	ldr	r3, [r7]
 8027b66: fa01 f303    	lsl.w	r3, r1, r3
 8027b6a: 43db         	mvns	r3, r3
 8027b6c: 401a         	ands	r2, r3
 8027b6e: 687b         	ldr	r3, [r7, #0x4]
 8027b70: 601a         	str	r2, [r3]
; }
 8027b72: bf00         	nop
 8027b74: 370c         	adds	r7, #0xc
 8027b76: 46bd         	mov	sp, r7
 8027b78: f85d 7b04    	ldr	r7, [sp], #4
 8027b7c: 4770         	bx	lr

08027b7e <flag_set>:
; {
 8027b7e: b480         	push	{r7}
 8027b80: b083         	sub	sp, #0xc
 8027b82: af00         	add	r7, sp, #0x0
 8027b84: 6078         	str	r0, [r7, #0x4]
 8027b86: 6039         	str	r1, [r7]
; 	*flagp |= BIT(bit);
 8027b88: 687b         	ldr	r3, [r7, #0x4]
 8027b8a: 681a         	ldr	r2, [r3]
 8027b8c: 2101         	movs	r1, #0x1
 8027b8e: 683b         	ldr	r3, [r7]
 8027b90: fa01 f303    	lsl.w	r3, r1, r3
 8027b94: 431a         	orrs	r2, r3
 8027b96: 687b         	ldr	r3, [r7, #0x4]
 8027b98: 601a         	str	r2, [r3]
; }
 8027b9a: bf00         	nop
 8027b9c: 370c         	adds	r7, #0xc
 8027b9e: 46bd         	mov	sp, r7
 8027ba0: f85d 7b04    	ldr	r7, [sp], #4
 8027ba4: 4770         	bx	lr

08027ba6 <flag_test>:
; {
 8027ba6: b480         	push	{r7}
 8027ba8: b083         	sub	sp, #0xc
 8027baa: af00         	add	r7, sp, #0x0
 8027bac: 6078         	str	r0, [r7, #0x4]
 8027bae: 6039         	str	r1, [r7]
; 	return (*flagp & BIT(bit)) != 0U;
 8027bb0: 687b         	ldr	r3, [r7, #0x4]
 8027bb2: 681a         	ldr	r2, [r3]
 8027bb4: 683b         	ldr	r3, [r7]
 8027bb6: fa22 f303    	lsr.w	r3, r2, r3
 8027bba: f003 0301    	and	r3, r3, #0x1
 8027bbe: 2b00         	cmp	r3, #0x0
 8027bc0: bf14         	ite	ne
 8027bc2: 2301         	movne	r3, #0x1
 8027bc4: 2300         	moveq	r3, #0x0
 8027bc6: b2db         	uxtb	r3, r3
; }
 8027bc8: 4618         	mov	r0, r3
 8027bca: 370c         	adds	r7, #0xc
 8027bcc: 46bd         	mov	sp, r7
 8027bce: f85d 7b04    	ldr	r7, [sp], #4
 8027bd2: 4770         	bx	lr

08027bd4 <flag_test_and_clear>:
; {
 8027bd4: b580         	push	{r7, lr}
 8027bd6: b084         	sub	sp, #0x10
 8027bd8: af00         	add	r7, sp, #0x0
 8027bda: 6078         	str	r0, [r7, #0x4]
 8027bdc: 6039         	str	r1, [r7]
; 	bool ret = flag_test(flagp, bit);
 8027bde: 683b         	ldr	r3, [r7]
 8027be0: 4619         	mov	r1, r3
 8027be2: 6878         	ldr	r0, [r7, #0x4]
 8027be4: f7ff ffdf    	bl	0x8027ba6 <flag_test>   @ imm = #-0x42
 8027be8: 4603         	mov	r3, r0
 8027bea: 73fb         	strb	r3, [r7, #0xf]
; 	flag_clear(flagp, bit);
 8027bec: 683b         	ldr	r3, [r7]
 8027bee: 4619         	mov	r1, r3
 8027bf0: 6878         	ldr	r0, [r7, #0x4]
 8027bf2: f7ff ffaf    	bl	0x8027b54 <flag_clear>  @ imm = #-0xa2
; 	return ret;
 8027bf6: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8027bf8: 4618         	mov	r0, r3
 8027bfa: 3710         	adds	r7, #0x10
 8027bfc: 46bd         	mov	sp, r7
 8027bfe: bd80         	pop	{r7, pc}

08027c00 <flags_set>:
; {
 8027c00: b480         	push	{r7}
 8027c02: b083         	sub	sp, #0xc
 8027c04: af00         	add	r7, sp, #0x0
 8027c06: 6078         	str	r0, [r7, #0x4]
 8027c08: 6039         	str	r1, [r7]
; 	*flagp = flags;
 8027c0a: 687b         	ldr	r3, [r7, #0x4]
 8027c0c: 683a         	ldr	r2, [r7]
 8027c0e: 601a         	str	r2, [r3]
; }
 8027c10: bf00         	nop
 8027c12: 370c         	adds	r7, #0xc
 8027c14: 46bd         	mov	sp, r7
 8027c16: f85d 7b04    	ldr	r7, [sp], #4
 8027c1a: 4770         	bx	lr

08027c1c <flags_get>:
; {
 8027c1c: b480         	push	{r7}
 8027c1e: b083         	sub	sp, #0xc
 8027c20: af00         	add	r7, sp, #0x0
 8027c22: 6078         	str	r0, [r7, #0x4]
; 	return *flagp;
 8027c24: 687b         	ldr	r3, [r7, #0x4]
 8027c26: 681b         	ldr	r3, [r3]
; }
 8027c28: 4618         	mov	r0, r3
 8027c2a: 370c         	adds	r7, #0xc
 8027c2c: 46bd         	mov	sp, r7
 8027c2e: f85d 7b04    	ldr	r7, [sp], #4
 8027c32: 4770         	bx	lr

08027c34 <finalize_flush_locked>:
; {
 8027c34: b580         	push	{r7, lr}
 8027c36: b084         	sub	sp, #0x10
 8027c38: af00         	add	r7, sp, #0x0
 8027c3a: 6078         	str	r0, [r7, #0x4]
; 	struct z_work_flusher *flusher = CONTAINER_OF(work, struct z_work_flusher, work);
 8027c3c: 687b         	ldr	r3, [r7, #0x4]
 8027c3e: 60fb         	str	r3, [r7, #0xc]
; 	flag_clear(&work->flags, K_WORK_FLUSHING_BIT);
 8027c40: 687b         	ldr	r3, [r7, #0x4]
 8027c42: 330c         	adds	r3, #0xc
 8027c44: 2104         	movs	r1, #0x4
 8027c46: 4618         	mov	r0, r3
 8027c48: f7ff ff84    	bl	0x8027b54 <flag_clear>  @ imm = #-0xf8
; 	k_sem_give(&flusher->sem);
 8027c4c: 68fb         	ldr	r3, [r7, #0xc]
 8027c4e: 3310         	adds	r3, #0x10
 8027c50: 4618         	mov	r0, r3
 8027c52: f7ff ff44    	bl	0x8027ade <k_sem_give>  @ imm = #-0x178
; };
 8027c56: bf00         	nop
 8027c58: 3710         	adds	r7, #0x10
 8027c5a: 46bd         	mov	sp, r7
 8027c5c: bd80         	pop	{r7, pc}

08027c5e <work_busy_get_locked>:
; {
 8027c5e: b580         	push	{r7, lr}
 8027c60: b082         	sub	sp, #0x8
 8027c62: af00         	add	r7, sp, #0x0
 8027c64: 6078         	str	r0, [r7, #0x4]
; 	return flags_get(&work->flags) & K_WORK_MASK;
 8027c66: 687b         	ldr	r3, [r7, #0x4]
 8027c68: 330c         	adds	r3, #0xc
 8027c6a: 4618         	mov	r0, r3
 8027c6c: f7ff ffd6    	bl	0x8027c1c <flags_get>   @ imm = #-0x54
 8027c70: 4603         	mov	r3, r0
 8027c72: f003 031f    	and	r3, r3, #0x1f
; }
 8027c76: 4618         	mov	r0, r3
 8027c78: 3708         	adds	r7, #0x8
 8027c7a: 46bd         	mov	sp, r7
 8027c7c: bd80         	pop	{r7, pc}

08027c7e <queue_remove_locked>:
; {
 8027c7e: b580         	push	{r7, lr}
 8027c80: b082         	sub	sp, #0x8
 8027c82: af00         	add	r7, sp, #0x0
 8027c84: 6078         	str	r0, [r7, #0x4]
 8027c86: 6039         	str	r1, [r7]
; 	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
 8027c88: 683b         	ldr	r3, [r7]
 8027c8a: 330c         	adds	r3, #0xc
 8027c8c: 2102         	movs	r1, #0x2
 8027c8e: 4618         	mov	r0, r3
 8027c90: f7ff ffa0    	bl	0x8027bd4 <flag_test_and_clear> @ imm = #-0xc0
 8027c94: 4603         	mov	r3, r0
 8027c96: 2b00         	cmp	r3, #0x0
 8027c98: d007         	beq	0x8027caa <queue_remove_locked+0x2c> @ imm = #0xe
; 		(void)sys_slist_find_and_remove(&queue->pending, &work->node);
 8027c9a: 687b         	ldr	r3, [r7, #0x4]
 8027c9c: f503 738c    	add.w	r3, r3, #0x118
 8027ca0: 683a         	ldr	r2, [r7]
 8027ca2: 4611         	mov	r1, r2
 8027ca4: 4618         	mov	r0, r3
 8027ca6: f7ff feab    	bl	0x8027a00 <sys_slist_find_and_remove> @ imm = #-0x2aa
; }
 8027caa: bf00         	nop
 8027cac: 3708         	adds	r7, #0x8
 8027cae: 46bd         	mov	sp, r7
 8027cb0: bd80         	pop	{r7, pc}

08027cb2 <notify_queue_locked>:
; {
 8027cb2: b580         	push	{r7, lr}
 8027cb4: b084         	sub	sp, #0x10
 8027cb6: af00         	add	r7, sp, #0x0
 8027cb8: 6078         	str	r0, [r7, #0x4]
; 	bool rv = false;
 8027cba: 2300         	movs	r3, #0x0
 8027cbc: 73fb         	strb	r3, [r7, #0xf]
; 	if (queue != NULL) {
 8027cbe: 687b         	ldr	r3, [r7, #0x4]
 8027cc0: 2b00         	cmp	r3, #0x0
 8027cc2: d009         	beq	0x8027cd8 <notify_queue_locked+0x26> @ imm = #0x12
; 		rv = z_sched_wake(&queue->notifyq, 0, NULL);
 8027cc4: 687b         	ldr	r3, [r7, #0x4]
 8027cc6: f503 7390    	add.w	r3, r3, #0x120
 8027cca: 2200         	movs	r2, #0x0
 8027ccc: 2100         	movs	r1, #0x0
 8027cce: 4618         	mov	r0, r3
 8027cd0: f7ef feee    	bl	0x8017ab0 <z_sched_wake> @ imm = #-0x10224
 8027cd4: 4603         	mov	r3, r0
 8027cd6: 73fb         	strb	r3, [r7, #0xf]
; 	return rv;
 8027cd8: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8027cda: 4618         	mov	r0, r3
 8027cdc: 3710         	adds	r7, #0x10
 8027cde: 46bd         	mov	sp, r7
 8027ce0: bd80         	pop	{r7, pc}

08027ce2 <submit_to_queue_locked>:
; {
 8027ce2: b580         	push	{r7, lr}
 8027ce4: b084         	sub	sp, #0x10
 8027ce6: af00         	add	r7, sp, #0x0
 8027ce8: 6078         	str	r0, [r7, #0x4]
 8027cea: 6039         	str	r1, [r7]
; 	int ret = 0;
 8027cec: 2300         	movs	r3, #0x0
 8027cee: 60fb         	str	r3, [r7, #0xc]
; 	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 8027cf0: 687b         	ldr	r3, [r7, #0x4]
 8027cf2: 330c         	adds	r3, #0xc
 8027cf4: 2101         	movs	r1, #0x1
 8027cf6: 4618         	mov	r0, r3
 8027cf8: f7ff ff55    	bl	0x8027ba6 <flag_test>   @ imm = #-0x156
 8027cfc: 4603         	mov	r3, r0
 8027cfe: 2b00         	cmp	r3, #0x0
 8027d00: d003         	beq	0x8027d0a <submit_to_queue_locked+0x28> @ imm = #0x6
; 		ret = -EBUSY;
 8027d02: f06f 030f    	mvn	r3, #0xf
 8027d06: 60fb         	str	r3, [r7, #0xc]
 8027d08: e03b         	b	0x8027d82 <submit_to_queue_locked+0xa0> @ imm = #0x76
; 	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
 8027d0a: 687b         	ldr	r3, [r7, #0x4]
 8027d0c: 330c         	adds	r3, #0xc
 8027d0e: 2102         	movs	r1, #0x2
 8027d10: 4618         	mov	r0, r3
 8027d12: f7ff ff48    	bl	0x8027ba6 <flag_test>   @ imm = #-0x170
 8027d16: 4603         	mov	r3, r0
 8027d18: f083 0301    	eor	r3, r3, #0x1
 8027d1c: b2db         	uxtb	r3, r3
 8027d1e: 2b00         	cmp	r3, #0x0
 8027d20: d02f         	beq	0x8027d82 <submit_to_queue_locked+0xa0> @ imm = #0x5e
; 		ret = 1;
 8027d22: 2301         	movs	r3, #0x1
 8027d24: 60fb         	str	r3, [r7, #0xc]
; 		if (*queuep == NULL) {
 8027d26: 683b         	ldr	r3, [r7]
 8027d28: 681b         	ldr	r3, [r3]
 8027d2a: 2b00         	cmp	r3, #0x0
 8027d2c: d103         	bne	0x8027d36 <submit_to_queue_locked+0x54> @ imm = #0x6
; 			*queuep = work->queue;
 8027d2e: 687b         	ldr	r3, [r7, #0x4]
 8027d30: 689a         	ldr	r2, [r3, #0x8]
 8027d32: 683b         	ldr	r3, [r7]
 8027d34: 601a         	str	r2, [r3]
; 		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
 8027d36: 687b         	ldr	r3, [r7, #0x4]
 8027d38: 330c         	adds	r3, #0xc
 8027d3a: 2100         	movs	r1, #0x0
 8027d3c: 4618         	mov	r0, r3
 8027d3e: f7ff ff32    	bl	0x8027ba6 <flag_test>   @ imm = #-0x19c
 8027d42: 4603         	mov	r3, r0
 8027d44: 2b00         	cmp	r3, #0x0
 8027d46: d005         	beq	0x8027d54 <submit_to_queue_locked+0x72> @ imm = #0xa
; 			*queuep = work->queue;
 8027d48: 687b         	ldr	r3, [r7, #0x4]
 8027d4a: 689a         	ldr	r2, [r3, #0x8]
 8027d4c: 683b         	ldr	r3, [r7]
 8027d4e: 601a         	str	r2, [r3]
; 			ret = 2;
 8027d50: 2302         	movs	r3, #0x2
 8027d52: 60fb         	str	r3, [r7, #0xc]
; 		int rc = queue_submit_locked(*queuep, work);
 8027d54: 683b         	ldr	r3, [r7]
 8027d56: 681b         	ldr	r3, [r3]
 8027d58: 6879         	ldr	r1, [r7, #0x4]
 8027d5a: 4618         	mov	r0, r3
 8027d5c: f7ed fdfe    	bl	0x801595c <queue_submit_locked> @ imm = #-0x12404
 8027d60: 60b8         	str	r0, [r7, #0x8]
; 		if (rc < 0) {
 8027d62: 68bb         	ldr	r3, [r7, #0x8]
 8027d64: 2b00         	cmp	r3, #0x0
 8027d66: da02         	bge	0x8027d6e <submit_to_queue_locked+0x8c> @ imm = #0x4
; 			ret = rc;
 8027d68: 68bb         	ldr	r3, [r7, #0x8]
 8027d6a: 60fb         	str	r3, [r7, #0xc]
 8027d6c: e009         	b	0x8027d82 <submit_to_queue_locked+0xa0> @ imm = #0x12
; 			flag_set(&work->flags, K_WORK_QUEUED_BIT);
 8027d6e: 687b         	ldr	r3, [r7, #0x4]
 8027d70: 330c         	adds	r3, #0xc
 8027d72: 2102         	movs	r1, #0x2
 8027d74: 4618         	mov	r0, r3
 8027d76: f7ff ff02    	bl	0x8027b7e <flag_set>    @ imm = #-0x1fc
; 			work->queue = *queuep;
 8027d7a: 683b         	ldr	r3, [r7]
 8027d7c: 681a         	ldr	r2, [r3]
 8027d7e: 687b         	ldr	r3, [r7, #0x4]
 8027d80: 609a         	str	r2, [r3, #0x8]
; 	if (ret <= 0) {
 8027d82: 68fb         	ldr	r3, [r7, #0xc]
 8027d84: 2b00         	cmp	r3, #0x0
 8027d86: dc02         	bgt	0x8027d8e <submit_to_queue_locked+0xac> @ imm = #0x4
; 		*queuep = NULL;
 8027d88: 683b         	ldr	r3, [r7]
 8027d8a: 2200         	movs	r2, #0x0
 8027d8c: 601a         	str	r2, [r3]
; 	return ret;
 8027d8e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8027d90: 4618         	mov	r0, r3
 8027d92: 3710         	adds	r7, #0x10
 8027d94: 46bd         	mov	sp, r7
 8027d96: bd80         	pop	{r7, pc}

08027d98 <cancel_async_locked>:
; {
 8027d98: b580         	push	{r7, lr}
 8027d9a: b084         	sub	sp, #0x10
 8027d9c: af00         	add	r7, sp, #0x0
 8027d9e: 6078         	str	r0, [r7, #0x4]
; 	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 8027da0: 687b         	ldr	r3, [r7, #0x4]
 8027da2: 330c         	adds	r3, #0xc
 8027da4: 2101         	movs	r1, #0x1
 8027da6: 4618         	mov	r0, r3
 8027da8: f7ff fefd    	bl	0x8027ba6 <flag_test>   @ imm = #-0x206
 8027dac: 4603         	mov	r3, r0
 8027dae: f083 0301    	eor	r3, r3, #0x1
 8027db2: b2db         	uxtb	r3, r3
 8027db4: 2b00         	cmp	r3, #0x0
 8027db6: d005         	beq	0x8027dc4 <cancel_async_locked+0x2c> @ imm = #0xa
; 		queue_remove_locked(work->queue, work);
 8027db8: 687b         	ldr	r3, [r7, #0x4]
 8027dba: 689b         	ldr	r3, [r3, #0x8]
 8027dbc: 6879         	ldr	r1, [r7, #0x4]
 8027dbe: 4618         	mov	r0, r3
 8027dc0: f7ff ff5d    	bl	0x8027c7e <queue_remove_locked> @ imm = #-0x146
; 	int ret = work_busy_get_locked(work);
 8027dc4: 6878         	ldr	r0, [r7, #0x4]
 8027dc6: f7ff ff4a    	bl	0x8027c5e <work_busy_get_locked> @ imm = #-0x16c
 8027dca: 60f8         	str	r0, [r7, #0xc]
; 	if (ret != 0) {
 8027dcc: 68fb         	ldr	r3, [r7, #0xc]
 8027dce: 2b00         	cmp	r3, #0x0
 8027dd0: d009         	beq	0x8027de6 <cancel_async_locked+0x4e> @ imm = #0x12
; 		flag_set(&work->flags, K_WORK_CANCELING_BIT);
 8027dd2: 687b         	ldr	r3, [r7, #0x4]
 8027dd4: 330c         	adds	r3, #0xc
 8027dd6: 2101         	movs	r1, #0x1
 8027dd8: 4618         	mov	r0, r3
 8027dda: f7ff fed0    	bl	0x8027b7e <flag_set>    @ imm = #-0x260
; 		ret = work_busy_get_locked(work);
 8027dde: 6878         	ldr	r0, [r7, #0x4]
 8027de0: f7ff ff3d    	bl	0x8027c5e <work_busy_get_locked> @ imm = #-0x186
 8027de4: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 8027de6: 68fb         	ldr	r3, [r7, #0xc]
; }
 8027de8: 4618         	mov	r0, r3
 8027dea: 3710         	adds	r7, #0x10
 8027dec: 46bd         	mov	sp, r7
 8027dee: bd80         	pop	{r7, pc}

08027df0 <k_work_init_delayable>:
; {
 8027df0: b580         	push	{r7, lr}
 8027df2: b08e         	sub	sp, #0x38
 8027df4: af00         	add	r7, sp, #0x0
 8027df6: 6078         	str	r0, [r7, #0x4]
 8027df8: 6039         	str	r1, [r7]
; 	*dwork = (struct k_work_delayable){
 8027dfa: 687b         	ldr	r3, [r7, #0x4]
 8027dfc: 4618         	mov	r0, r3
 8027dfe: 2330         	movs	r3, #0x30
 8027e00: 461a         	mov	r2, r3
 8027e02: 2100         	movs	r1, #0x0
 8027e04: f001 f984    	bl	0x8029110 <memset>      @ imm = #0x1308
 8027e08: 687b         	ldr	r3, [r7, #0x4]
 8027e0a: 683a         	ldr	r2, [r7]
 8027e0c: 605a         	str	r2, [r3, #0x4]
 8027e0e: 687b         	ldr	r3, [r7, #0x4]
 8027e10: f44f 7280    	mov.w	r2, #0x100
 8027e14: 60da         	str	r2, [r3, #0xc]
; 	z_init_timeout(&dwork->timeout);
 8027e16: 687b         	ldr	r3, [r7, #0x4]
 8027e18: 3310         	adds	r3, #0x10
 8027e1a: 4618         	mov	r0, r3
 8027e1c: f7ff fe6a    	bl	0x8027af4 <z_init_timeout> @ imm = #-0x32c
; }
 8027e20: bf00         	nop
 8027e22: 3738         	adds	r7, #0x38
 8027e24: 46bd         	mov	sp, r7
 8027e26: bd80         	pop	{r7, pc}

08027e28 <unschedule_locked>:
; {
 8027e28: b580         	push	{r7, lr}
 8027e2a: b084         	sub	sp, #0x10
 8027e2c: af00         	add	r7, sp, #0x0
 8027e2e: 6078         	str	r0, [r7, #0x4]
; 	bool ret = false;
 8027e30: 2300         	movs	r3, #0x0
 8027e32: 73fb         	strb	r3, [r7, #0xf]
; 	struct k_work *work = &dwork->work;
 8027e34: 687b         	ldr	r3, [r7, #0x4]
 8027e36: 60bb         	str	r3, [r7, #0x8]
; 	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
 8027e38: 68bb         	ldr	r3, [r7, #0x8]
 8027e3a: 330c         	adds	r3, #0xc
 8027e3c: 2103         	movs	r1, #0x3
 8027e3e: 4618         	mov	r0, r3
 8027e40: f7ff fec8    	bl	0x8027bd4 <flag_test_and_clear> @ imm = #-0x270
 8027e44: 4603         	mov	r3, r0
 8027e46: 2b00         	cmp	r3, #0x0
 8027e48: d00a         	beq	0x8027e60 <unschedule_locked+0x38> @ imm = #0x14
; 		ret = z_abort_timeout(&dwork->timeout) == 0;
 8027e4a: 687b         	ldr	r3, [r7, #0x4]
 8027e4c: 3310         	adds	r3, #0x10
 8027e4e: 4618         	mov	r0, r3
 8027e50: f7f0 fa16    	bl	0x8018280 <z_abort_timeout> @ imm = #-0xfbd4
 8027e54: 4603         	mov	r3, r0
 8027e56: 2b00         	cmp	r3, #0x0
 8027e58: bf0c         	ite	eq
 8027e5a: 2301         	moveq	r3, #0x1
 8027e5c: 2300         	movne	r3, #0x0
 8027e5e: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 8027e60: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8027e62: 4618         	mov	r0, r3
 8027e64: 3710         	adds	r7, #0x10
 8027e66: 46bd         	mov	sp, r7
 8027e68: bd80         	pop	{r7, pc}

08027e6a <cancel_delayable_async_locked>:
; {
 8027e6a: b580         	push	{r7, lr}
 8027e6c: b082         	sub	sp, #0x8
 8027e6e: af00         	add	r7, sp, #0x0
 8027e70: 6078         	str	r0, [r7, #0x4]
; 	(void)unschedule_locked(dwork);
 8027e72: 6878         	ldr	r0, [r7, #0x4]
 8027e74: f7ff ffd8    	bl	0x8027e28 <unschedule_locked> @ imm = #-0x50
; 	return cancel_async_locked(&dwork->work);
 8027e78: 687b         	ldr	r3, [r7, #0x4]
 8027e7a: 4618         	mov	r0, r3
 8027e7c: f7ff ff8c    	bl	0x8027d98 <cancel_async_locked> @ imm = #-0xe8
 8027e80: 4603         	mov	r3, r0
; }
 8027e82: 4618         	mov	r0, r3
 8027e84: 3708         	adds	r7, #0x8
 8027e86: 46bd         	mov	sp, r7
 8027e88: bd80         	pop	{r7, pc}

08027e8a <sys_dlist_init>:
; {
 8027e8a: b480         	push	{r7}
 8027e8c: b083         	sub	sp, #0xc
 8027e8e: af00         	add	r7, sp, #0x0
 8027e90: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8027e92: 687b         	ldr	r3, [r7, #0x4]
 8027e94: 687a         	ldr	r2, [r7, #0x4]
 8027e96: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8027e98: 687b         	ldr	r3, [r7, #0x4]
 8027e9a: 687a         	ldr	r2, [r7, #0x4]
 8027e9c: 605a         	str	r2, [r3, #0x4]
; }
 8027e9e: bf00         	nop
 8027ea0: 370c         	adds	r7, #0xc
 8027ea2: 46bd         	mov	sp, r7
 8027ea4: f85d 7b04    	ldr	r7, [sp], #4
 8027ea8: 4770         	bx	lr

08027eaa <sys_dnode_init>:
; {
 8027eaa: b480         	push	{r7}
 8027eac: b083         	sub	sp, #0xc
 8027eae: af00         	add	r7, sp, #0x0
 8027eb0: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8027eb2: 687b         	ldr	r3, [r7, #0x4]
 8027eb4: 2200         	movs	r2, #0x0
 8027eb6: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8027eb8: 687b         	ldr	r3, [r7, #0x4]
 8027eba: 2200         	movs	r2, #0x0
 8027ebc: 605a         	str	r2, [r3, #0x4]
; }
 8027ebe: bf00         	nop
 8027ec0: 370c         	adds	r7, #0xc
 8027ec2: 46bd         	mov	sp, r7
 8027ec4: f85d 7b04    	ldr	r7, [sp], #4
 8027ec8: 4770         	bx	lr

08027eca <K_KERNEL_STACK_BUFFER>:
; {
 8027eca: b480         	push	{r7}
 8027ecc: b083         	sub	sp, #0xc
 8027ece: af00         	add	r7, sp, #0x0
 8027ed0: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 8027ed2: 687b         	ldr	r3, [r7, #0x4]
; }
 8027ed4: 4618         	mov	r0, r3
 8027ed6: 370c         	adds	r7, #0xc
 8027ed8: 46bd         	mov	sp, r7
 8027eda: f85d 7b04    	ldr	r7, [sp], #4
 8027ede: 4770         	bx	lr

08027ee0 <k_thread_start>:
; {
 8027ee0: b580         	push	{r7, lr}
 8027ee2: b082         	sub	sp, #0x8
 8027ee4: af00         	add	r7, sp, #0x0
 8027ee6: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 8027ee8: 6878         	ldr	r0, [r7, #0x4]
 8027eea: f000 f804    	bl	0x8027ef6 <k_thread_resume> @ imm = #0x8
; }
 8027eee: bf00         	nop
 8027ef0: 3708         	adds	r7, #0x8
 8027ef2: 46bd         	mov	sp, r7
 8027ef4: bd80         	pop	{r7, pc}

08027ef6 <k_thread_resume>:
; {
 8027ef6: b580         	push	{r7, lr}
 8027ef8: b082         	sub	sp, #0x8
 8027efa: af00         	add	r7, sp, #0x0
 8027efc: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 8027efe: 6878         	ldr	r0, [r7, #0x4]
 8027f00: f7ee fdda    	bl	0x8016ab8 <z_impl_k_thread_resume> @ imm = #-0x1144c
; }
 8027f04: bf00         	nop
 8027f06: 3708         	adds	r7, #0x8
 8027f08: 46bd         	mov	sp, r7
 8027f0a: bd80         	pop	{r7, pc}

08027f0c <z_init_timeout>:
; {
 8027f0c: b580         	push	{r7, lr}
 8027f0e: b082         	sub	sp, #0x8
 8027f10: af00         	add	r7, sp, #0x0
 8027f12: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 8027f14: 687b         	ldr	r3, [r7, #0x4]
 8027f16: 4618         	mov	r0, r3
 8027f18: f7ff ffc7    	bl	0x8027eaa <sys_dnode_init> @ imm = #-0x72
; }
 8027f1c: bf00         	nop
 8027f1e: 3708         	adds	r7, #0x8
 8027f20: 46bd         	mov	sp, r7
 8027f22: bd80         	pop	{r7, pc}

08027f24 <z_init_thread_timeout>:
; {
 8027f24: b580         	push	{r7, lr}
 8027f26: b082         	sub	sp, #0x8
 8027f28: af00         	add	r7, sp, #0x0
 8027f2a: 6078         	str	r0, [r7, #0x4]
; 	z_init_timeout(&thread_base->timeout);
 8027f2c: 687b         	ldr	r3, [r7, #0x4]
 8027f2e: 3318         	adds	r3, #0x18
 8027f30: 4618         	mov	r0, r3
 8027f32: f7ff ffeb    	bl	0x8027f0c <z_init_timeout> @ imm = #-0x2a
; }
 8027f36: bf00         	nop
 8027f38: 3708         	adds	r7, #0x8
 8027f3a: 46bd         	mov	sp, r7
 8027f3c: bd80         	pop	{r7, pc}

08027f3e <thread_schedule_new>:
; {
 8027f3e: b580         	push	{r7, lr}
 8027f40: b084         	sub	sp, #0x10
 8027f42: af00         	add	r7, sp, #0x0
 8027f44: 60f8         	str	r0, [r7, #0xc]
 8027f46: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 8027f4a: e9d7 2300    	ldrd	r2, r3, [r7]
 8027f4e: f04f 0000    	mov.w	r0, #0x0
 8027f52: f04f 0100    	mov.w	r1, #0x0
 8027f56: 428b         	cmp	r3, r1
 8027f58: bf08         	it	eq
 8027f5a: 4282         	cmpeq	r2, r0
 8027f5c: d103         	bne	0x8027f66 <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 8027f5e: 68f8         	ldr	r0, [r7, #0xc]
 8027f60: f7ff ffbe    	bl	0x8027ee0 <k_thread_start> @ imm = #-0x84
 8027f64: e004         	b	0x8027f70 <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 8027f66: e9d7 2300    	ldrd	r2, r3, [r7]
 8027f6a: 68f8         	ldr	r0, [r7, #0xc]
 8027f6c: f7ed ffde    	bl	0x8015f2c <z_add_thread_timeout> @ imm = #-0x12044
; }
 8027f70: bf00         	nop
 8027f72: 3710         	adds	r7, #0x10
 8027f74: 46bd         	mov	sp, r7
 8027f76: bd80         	pop	{r7, pc}

08027f78 <z_waitq_init>:
; {
 8027f78: b580         	push	{r7, lr}
 8027f7a: b082         	sub	sp, #0x8
 8027f7c: af00         	add	r7, sp, #0x0
 8027f7e: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8027f80: 687b         	ldr	r3, [r7, #0x4]
 8027f82: 4618         	mov	r0, r3
 8027f84: f7ff ff81    	bl	0x8027e8a <sys_dlist_init> @ imm = #-0xfe
; }
 8027f88: bf00         	nop
 8027f8a: 3708         	adds	r7, #0x8
 8027f8c: 46bd         	mov	sp, r7
 8027f8e: bd80         	pop	{r7, pc}

08027f90 <z_log_msg_runtime_create>:
; {
 8027f90: b580         	push	{r7, lr}
 8027f92: b08a         	sub	sp, #0x28
 8027f94: af04         	add	r7, sp, #0x10
 8027f96: 60b9         	str	r1, [r7, #0x8]
 8027f98: 607b         	str	r3, [r7, #0x4]
 8027f9a: 4603         	mov	r3, r0
 8027f9c: 73fb         	strb	r3, [r7, #0xf]
 8027f9e: 4613         	mov	r3, r2
 8027fa0: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8027fa2: f107 032c    	add.w	r3, r7, #0x2c
 8027fa6: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8027fa8: 7bba         	ldrb	r2, [r7, #0xe]
 8027faa: 7bf8         	ldrb	r0, [r7, #0xf]
 8027fac: 697b         	ldr	r3, [r7, #0x14]
 8027fae: 9303         	str	r3, [sp, #0xc]
 8027fb0: 6abb         	ldr	r3, [r7, #0x28]
 8027fb2: 9302         	str	r3, [sp, #0x8]
 8027fb4: 6a7b         	ldr	r3, [r7, #0x24]
 8027fb6: 9301         	str	r3, [sp, #0x4]
 8027fb8: 6a3b         	ldr	r3, [r7, #0x20]
 8027fba: 9300         	str	r3, [sp]
 8027fbc: 687b         	ldr	r3, [r7, #0x4]
 8027fbe: 68b9         	ldr	r1, [r7, #0x8]
 8027fc0: f7dc fdd8    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x23450
; }
 8027fc4: bf00         	nop
 8027fc6: 3718         	adds	r7, #0x18
 8027fc8: 46bd         	mov	sp, r7
 8027fca: bd80         	pop	{r7, pc}

08027fcc <k_is_in_isr>:
; {
 8027fcc: b480         	push	{r7}
 8027fce: b083         	sub	sp, #0xc
 8027fd0: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8027fd2: f3ef 8305    	mrs	r3, ipsr
 8027fd6: 607b         	str	r3, [r7, #0x4]
;   return(result);
 8027fd8: 687b         	ldr	r3, [r7, #0x4]
; 	return (__get_IPSR()) ? (true) : (false);
 8027fda: 2b00         	cmp	r3, #0x0
 8027fdc: bf14         	ite	ne
 8027fde: 2301         	movne	r3, #0x1
 8027fe0: 2300         	moveq	r3, #0x0
 8027fe2: b2db         	uxtb	r3, r3
; }
 8027fe4: 4618         	mov	r0, r3
 8027fe6: 370c         	adds	r7, #0xc
 8027fe8: 46bd         	mov	sp, r7
 8027fea: f85d 7b04    	ldr	r7, [sp], #4
 8027fee: 4770         	bx	lr

08027ff0 <z_impl_k_thread_priority_get>:
; {
 8027ff0: b480         	push	{r7}
 8027ff2: b083         	sub	sp, #0xc
 8027ff4: af00         	add	r7, sp, #0x0
 8027ff6: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.prio;
 8027ff8: 687b         	ldr	r3, [r7, #0x4]
 8027ffa: f993 300e    	ldrsb.w	r3, [r3, #0xe]
; }
 8027ffe: 4618         	mov	r0, r3
 8028000: 370c         	adds	r7, #0xc
 8028002: 46bd         	mov	sp, r7
 8028004: f85d 7b04    	ldr	r7, [sp], #4
 8028008: 4770         	bx	lr

0802800a <k_thread_name_get>:
; {
 802800a: b480         	push	{r7}
 802800c: b083         	sub	sp, #0xc
 802800e: af00         	add	r7, sp, #0x0
 8028010: 6078         	str	r0, [r7, #0x4]
; 	return (const char *)thread->name;
 8028012: 687b         	ldr	r3, [r7, #0x4]
 8028014: 3394         	adds	r3, #0x94
; }
 8028016: 4618         	mov	r0, r3
 8028018: 370c         	adds	r7, #0xc
 802801a: 46bd         	mov	sp, r7
 802801c: f85d 7b04    	ldr	r7, [sp], #4
 8028020: 4770         	bx	lr

08028022 <z_impl_k_thread_create>:
; {
 8028022: b580         	push	{r7, lr}
 8028024: b08a         	sub	sp, #0x28
 8028026: af06         	add	r7, sp, #0x18
 8028028: 60f8         	str	r0, [r7, #0xc]
 802802a: 60b9         	str	r1, [r7, #0x8]
 802802c: 607a         	str	r2, [r7, #0x4]
 802802e: 603b         	str	r3, [r7]
; 	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 8028030: 2300         	movs	r3, #0x0
 8028032: 9305         	str	r3, [sp, #0x14]
 8028034: 6abb         	ldr	r3, [r7, #0x28]
 8028036: 9304         	str	r3, [sp, #0x10]
 8028038: 6a7b         	ldr	r3, [r7, #0x24]
 802803a: 9303         	str	r3, [sp, #0xc]
 802803c: 6a3b         	ldr	r3, [r7, #0x20]
 802803e: 9302         	str	r3, [sp, #0x8]
 8028040: 69fb         	ldr	r3, [r7, #0x1c]
 8028042: 9301         	str	r3, [sp, #0x4]
 8028044: 69bb         	ldr	r3, [r7, #0x18]
 8028046: 9300         	str	r3, [sp]
 8028048: 683b         	ldr	r3, [r7]
 802804a: 687a         	ldr	r2, [r7, #0x4]
 802804c: 68b9         	ldr	r1, [r7, #0x8]
 802804e: 68f8         	ldr	r0, [r7, #0xc]
 8028050: f7ee f810    	bl	0x8016074 <z_setup_new_thread> @ imm = #-0x11fe0
; 	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
 8028054: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8028058: f04f 30ff    	mov.w	r0, #0xffffffff
 802805c: f04f 31ff    	mov.w	r1, #0xffffffff
 8028060: 428b         	cmp	r3, r1
 8028062: bf08         	it	eq
 8028064: 4282         	cmpeq	r2, r0
 8028066: d004         	beq	0x8028072 <z_impl_k_thread_create+0x50> @ imm = #0x8
; 		thread_schedule_new(new_thread, delay);
 8028068: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 802806c: 68f8         	ldr	r0, [r7, #0xc]
 802806e: f7ff ff66    	bl	0x8027f3e <thread_schedule_new> @ imm = #-0x134
; 	return new_thread;
 8028072: 68fb         	ldr	r3, [r7, #0xc]
; }
 8028074: 4618         	mov	r0, r3
 8028076: 3710         	adds	r7, #0x10
 8028078: 46bd         	mov	sp, r7
 802807a: bd80         	pop	{r7, pc}

0802807c <z_init_thread_base>:
; {
 802807c: b580         	push	{r7, lr}
 802807e: b084         	sub	sp, #0x10
 8028080: af00         	add	r7, sp, #0x0
 8028082: 60f8         	str	r0, [r7, #0xc]
 8028084: 60b9         	str	r1, [r7, #0x8]
 8028086: 607a         	str	r2, [r7, #0x4]
 8028088: 603b         	str	r3, [r7]
; 	thread_base->pended_on = NULL;
 802808a: 68fb         	ldr	r3, [r7, #0xc]
 802808c: 2200         	movs	r2, #0x0
 802808e: 609a         	str	r2, [r3, #0x8]
; 	thread_base->user_options = (uint8_t)options;
 8028090: 683b         	ldr	r3, [r7]
 8028092: b2da         	uxtb	r2, r3
 8028094: 68fb         	ldr	r3, [r7, #0xc]
 8028096: 731a         	strb	r2, [r3, #0xc]
; 	thread_base->thread_state = (uint8_t)initial_state;
 8028098: 687b         	ldr	r3, [r7, #0x4]
 802809a: b2da         	uxtb	r2, r3
 802809c: 68fb         	ldr	r3, [r7, #0xc]
 802809e: 735a         	strb	r2, [r3, #0xd]
; 	thread_base->prio = priority;
 80280a0: 68bb         	ldr	r3, [r7, #0x8]
 80280a2: b25a         	sxtb	r2, r3
 80280a4: 68fb         	ldr	r3, [r7, #0xc]
 80280a6: 739a         	strb	r2, [r3, #0xe]
; 	thread_base->sched_locked = 0U;
 80280a8: 68fb         	ldr	r3, [r7, #0xc]
 80280aa: 2200         	movs	r2, #0x0
 80280ac: 73da         	strb	r2, [r3, #0xf]
; 	z_init_thread_timeout(thread_base);
 80280ae: 68f8         	ldr	r0, [r7, #0xc]
 80280b0: f7ff ff38    	bl	0x8027f24 <z_init_thread_timeout> @ imm = #-0x190
; }
 80280b4: bf00         	nop
 80280b6: 3710         	adds	r7, #0x10
 80280b8: 46bd         	mov	sp, r7
 80280ba: bd80         	pop	{r7, pc}

080280bc <z_stack_space_get>:
; {
 80280bc: b480         	push	{r7}
 80280be: b089         	sub	sp, #0x24
 80280c0: af00         	add	r7, sp, #0x0
 80280c2: 60f8         	str	r0, [r7, #0xc]
 80280c4: 60b9         	str	r1, [r7, #0x8]
 80280c6: 607a         	str	r2, [r7, #0x4]
; 	size_t unused = 0;
 80280c8: 2300         	movs	r3, #0x0
 80280ca: 61fb         	str	r3, [r7, #0x1c]
; 	const uint8_t *checked_stack = stack_start;
 80280cc: 68fb         	ldr	r3, [r7, #0xc]
 80280ce: 617b         	str	r3, [r7, #0x14]
; 	const uint8_t *stack_pointer = (const uint8_t *)&stack_start;
 80280d0: f107 030c    	add.w	r3, r7, #0xc
 80280d4: 613b         	str	r3, [r7, #0x10]
; 	for (size_t i = 0; i < size; i++) {
 80280d6: 2300         	movs	r3, #0x0
 80280d8: 61bb         	str	r3, [r7, #0x18]
 80280da: e00b         	b	0x80280f4 <z_stack_space_get+0x38> @ imm = #0x16
; 		if ((checked_stack[i]) == 0xaaU) {
 80280dc: 697a         	ldr	r2, [r7, #0x14]
 80280de: 69bb         	ldr	r3, [r7, #0x18]
 80280e0: 4413         	add	r3, r2
 80280e2: 781b         	ldrb	r3, [r3]
 80280e4: 2baa         	cmp	r3, #0xaa
 80280e6: d10a         	bne	0x80280fe <z_stack_space_get+0x42> @ imm = #0x14
; 			unused++;
 80280e8: 69fb         	ldr	r3, [r7, #0x1c]
 80280ea: 3301         	adds	r3, #0x1
 80280ec: 61fb         	str	r3, [r7, #0x1c]
; 	for (size_t i = 0; i < size; i++) {
 80280ee: 69bb         	ldr	r3, [r7, #0x18]
 80280f0: 3301         	adds	r3, #0x1
 80280f2: 61bb         	str	r3, [r7, #0x18]
 80280f4: 69ba         	ldr	r2, [r7, #0x18]
 80280f6: 68bb         	ldr	r3, [r7, #0x8]
 80280f8: 429a         	cmp	r2, r3
 80280fa: d3ef         	blo	0x80280dc <z_stack_space_get+0x20> @ imm = #-0x22
 80280fc: e000         	b	0x8028100 <z_stack_space_get+0x44> @ imm = #0x0
; 			break;
 80280fe: bf00         	nop
; 	*unused_ptr = unused;
 8028100: 687b         	ldr	r3, [r7, #0x4]
 8028102: 69fa         	ldr	r2, [r7, #0x1c]
 8028104: 601a         	str	r2, [r3]
; 	return 0;
 8028106: 2300         	movs	r3, #0x0
; }
 8028108: 4618         	mov	r0, r3
 802810a: 3724         	adds	r7, #0x24
 802810c: 46bd         	mov	sp, r7
 802810e: f85d 7b04    	ldr	r7, [sp], #4
 8028112: 4770         	bx	lr

08028114 <z_impl_k_thread_stack_space_get>:
; {
 8028114: b580         	push	{r7, lr}
 8028116: b082         	sub	sp, #0x8
 8028118: af00         	add	r7, sp, #0x0
 802811a: 6078         	str	r0, [r7, #0x4]
 802811c: 6039         	str	r1, [r7]
; 	return z_stack_space_get((const uint8_t *)thread->stack_info.start,
 802811e: 687b         	ldr	r3, [r7, #0x4]
 8028120: f8d3 30b4    	ldr.w	r3, [r3, #0xb4]
 8028124: 4618         	mov	r0, r3
; 				 thread->stack_info.size, unused_ptr);
 8028126: 687b         	ldr	r3, [r7, #0x4]
 8028128: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
; 	return z_stack_space_get((const uint8_t *)thread->stack_info.start,
 802812c: 683a         	ldr	r2, [r7]
 802812e: 4619         	mov	r1, r3
 8028130: f7ff ffc4    	bl	0x80280bc <z_stack_space_get> @ imm = #-0x78
 8028134: 4603         	mov	r3, r0
; }
 8028136: 4618         	mov	r0, r3
 8028138: 3708         	adds	r7, #0x8
 802813a: 46bd         	mov	sp, r7
 802813c: bd80         	pop	{r7, pc}

0802813e <z_thread_mark_switched_out>:
; {
 802813e: b580         	push	{r7, lr}
 8028140: af00         	add	r7, sp, #0x0
; 	z_sched_usage_stop();
 8028142: f7f0 fa45    	bl	0x80185d0 <z_sched_usage_stop> @ imm = #-0xfb76
; }
 8028146: bf00         	nop
 8028148: bd80         	pop	{r7, pc}

0802814a <k_thread_runtime_stats_get>:
; {
 802814a: b580         	push	{r7, lr}
 802814c: b082         	sub	sp, #0x8
 802814e: af00         	add	r7, sp, #0x0
 8028150: 6078         	str	r0, [r7, #0x4]
 8028152: 6039         	str	r1, [r7]
; 	if ((thread == NULL) || (stats == NULL)) {
 8028154: 687b         	ldr	r3, [r7, #0x4]
 8028156: 2b00         	cmp	r3, #0x0
 8028158: d002         	beq	0x8028160 <k_thread_runtime_stats_get+0x16> @ imm = #0x4
 802815a: 683b         	ldr	r3, [r7]
 802815c: 2b00         	cmp	r3, #0x0
 802815e: d102         	bne	0x8028166 <k_thread_runtime_stats_get+0x1c> @ imm = #0x4
; 		return -EINVAL;
 8028160: f06f 0315    	mvn	r3, #0x15
 8028164: e004         	b	0x8028170 <k_thread_runtime_stats_get+0x26> @ imm = #0x8
; 	z_sched_thread_usage(thread, stats);
 8028166: 6839         	ldr	r1, [r7]
 8028168: 6878         	ldr	r0, [r7, #0x4]
 802816a: f7f0 fb05    	bl	0x8018778 <z_sched_thread_usage> @ imm = #-0xf9f6
; 	return 0;
 802816e: 2300         	movs	r3, #0x0
; }
 8028170: 4618         	mov	r0, r3
 8028172: 3708         	adds	r7, #0x8
 8028174: 46bd         	mov	sp, r7
 8028176: bd80         	pop	{r7, pc}

08028178 <k_thread_runtime_stats_all_get>:
; {
 8028178: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 802817c: b090         	sub	sp, #0x40
 802817e: af00         	add	r7, sp, #0x0
 8028180: 6078         	str	r0, [r7, #0x4]
; 	if (stats == NULL) {
 8028182: 687b         	ldr	r3, [r7, #0x4]
 8028184: 2b00         	cmp	r3, #0x0
 8028186: d102         	bne	0x802818e <k_thread_runtime_stats_all_get+0x16> @ imm = #0x4
; 		return -EINVAL;
 8028188: f06f 0315    	mvn	r3, #0x15
 802818c: e044         	b	0x8028218 <k_thread_runtime_stats_all_get+0xa0> @ imm = #0x88
; 	*stats = (k_thread_runtime_stats_t) {};
 802818e: 687b         	ldr	r3, [r7, #0x4]
 8028190: 461a         	mov	r2, r3
 8028192: 2300         	movs	r3, #0x0
 8028194: 6013         	str	r3, [r2]
 8028196: 6053         	str	r3, [r2, #0x4]
 8028198: 6093         	str	r3, [r2, #0x8]
 802819a: 60d3         	str	r3, [r2, #0xc]
 802819c: 6113         	str	r3, [r2, #0x10]
 802819e: 6153         	str	r3, [r2, #0x14]
; 	return CONFIG_MP_MAX_NUM_CPUS;
 80281a0: 2301         	movs	r3, #0x1
; 	unsigned int num_cpus = arch_num_cpus();
 80281a2: 63bb         	str	r3, [r7, #0x38]
; 	for (uint8_t i = 0; i < num_cpus; i++) {
 80281a4: 2300         	movs	r3, #0x0
 80281a6: f887 303f    	strb.w	r3, [r7, #0x3f]
 80281aa: e02f         	b	0x802820c <k_thread_runtime_stats_all_get+0x94> @ imm = #0x5e
; 		z_sched_cpu_usage(i, &tmp_stats);
 80281ac: f107 0220    	add.w	r2, r7, #0x20
 80281b0: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 80281b4: 4611         	mov	r1, r2
 80281b6: 4618         	mov	r0, r3
 80281b8: f7f0 fa62    	bl	0x8018680 <z_sched_cpu_usage> @ imm = #-0xfb3c
; 		stats->execution_cycles += tmp_stats.execution_cycles;
 80281bc: 687b         	ldr	r3, [r7, #0x4]
 80281be: e9d3 0100    	ldrd	r0, r1, [r3]
 80281c2: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 80281c6: 1884         	adds	r4, r0, r2
 80281c8: eb41 0503    	adc.w	r5, r1, r3
 80281cc: 687b         	ldr	r3, [r7, #0x4]
 80281ce: e9c3 4500    	strd	r4, r5, [r3]
; 		stats->total_cycles     += tmp_stats.total_cycles;
 80281d2: 687b         	ldr	r3, [r7, #0x4]
 80281d4: e9d3 0102    	ldrd	r0, r1, [r3, #8]
 80281d8: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 80281dc: eb10 0802    	adds.w	r8, r0, r2
 80281e0: eb41 0903    	adc.w	r9, r1, r3
 80281e4: 687b         	ldr	r3, [r7, #0x4]
 80281e6: e9c3 8902    	strd	r8, r9, [r3, #8]
; 		stats->idle_cycles      += tmp_stats.idle_cycles;
 80281ea: 687b         	ldr	r3, [r7, #0x4]
 80281ec: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 80281f0: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 80281f4: eb10 0a02    	adds.w	r10, r0, r2
 80281f8: eb41 0b03    	adc.w	r11, r1, r3
 80281fc: 687b         	ldr	r3, [r7, #0x4]
 80281fe: e9c3 ab04    	strd	r10, r11, [r3, #16]
; 	for (uint8_t i = 0; i < num_cpus; i++) {
 8028202: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8028206: 3301         	adds	r3, #0x1
 8028208: f887 303f    	strb.w	r3, [r7, #0x3f]
 802820c: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8028210: 6bba         	ldr	r2, [r7, #0x38]
 8028212: 429a         	cmp	r2, r3
 8028214: d8ca         	bhi	0x80281ac <k_thread_runtime_stats_all_get+0x34> @ imm = #-0x6c
; 	return 0;
 8028216: 2300         	movs	r3, #0x0
; }
 8028218: 4618         	mov	r0, r3
 802821a: 3740         	adds	r7, #0x40
 802821c: 46bd         	mov	sp, r7
 802821e: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08028222 <sys_dlist_init>:
; {
 8028222: b480         	push	{r7}
 8028224: b083         	sub	sp, #0xc
 8028226: af00         	add	r7, sp, #0x0
 8028228: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 802822a: 687b         	ldr	r3, [r7, #0x4]
 802822c: 687a         	ldr	r2, [r7, #0x4]
 802822e: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8028230: 687b         	ldr	r3, [r7, #0x4]
 8028232: 687a         	ldr	r2, [r7, #0x4]
 8028234: 605a         	str	r2, [r3, #0x4]
; }
 8028236: bf00         	nop
 8028238: 370c         	adds	r7, #0xc
 802823a: 46bd         	mov	sp, r7
 802823c: f85d 7b04    	ldr	r7, [sp], #4
 8028240: 4770         	bx	lr

08028242 <sys_dnode_init>:
; {
 8028242: b480         	push	{r7}
 8028244: b083         	sub	sp, #0xc
 8028246: af00         	add	r7, sp, #0x0
 8028248: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 802824a: 687b         	ldr	r3, [r7, #0x4]
 802824c: 2200         	movs	r2, #0x0
 802824e: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8028250: 687b         	ldr	r3, [r7, #0x4]
 8028252: 2200         	movs	r2, #0x0
 8028254: 605a         	str	r2, [r3, #0x4]
; }
 8028256: bf00         	nop
 8028258: 370c         	adds	r7, #0xc
 802825a: 46bd         	mov	sp, r7
 802825c: f85d 7b04    	ldr	r7, [sp], #4
 8028260: 4770         	bx	lr

08028262 <sys_dnode_is_linked>:
; {
 8028262: b480         	push	{r7}
 8028264: b083         	sub	sp, #0xc
 8028266: af00         	add	r7, sp, #0x0
 8028268: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 802826a: 687b         	ldr	r3, [r7, #0x4]
 802826c: 681b         	ldr	r3, [r3]
 802826e: 2b00         	cmp	r3, #0x0
 8028270: bf14         	ite	ne
 8028272: 2301         	movne	r3, #0x1
 8028274: 2300         	moveq	r3, #0x0
 8028276: b2db         	uxtb	r3, r3
; }
 8028278: 4618         	mov	r0, r3
 802827a: 370c         	adds	r7, #0xc
 802827c: 46bd         	mov	sp, r7
 802827e: f85d 7b04    	ldr	r7, [sp], #4
 8028282: 4770         	bx	lr

08028284 <sys_dlist_is_empty>:
; {
 8028284: b480         	push	{r7}
 8028286: b083         	sub	sp, #0xc
 8028288: af00         	add	r7, sp, #0x0
 802828a: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 802828c: 687b         	ldr	r3, [r7, #0x4]
 802828e: 681b         	ldr	r3, [r3]
 8028290: 687a         	ldr	r2, [r7, #0x4]
 8028292: 429a         	cmp	r2, r3
 8028294: bf0c         	ite	eq
 8028296: 2301         	moveq	r3, #0x1
 8028298: 2300         	movne	r3, #0x0
 802829a: b2db         	uxtb	r3, r3
; }
 802829c: 4618         	mov	r0, r3
 802829e: 370c         	adds	r7, #0xc
 80282a0: 46bd         	mov	sp, r7
 80282a2: f85d 7b04    	ldr	r7, [sp], #4
 80282a6: 4770         	bx	lr

080282a8 <sys_dlist_peek_head>:
; {
 80282a8: b580         	push	{r7, lr}
 80282aa: b082         	sub	sp, #0x8
 80282ac: af00         	add	r7, sp, #0x0
 80282ae: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 80282b0: 6878         	ldr	r0, [r7, #0x4]
 80282b2: f7ff ffe7    	bl	0x8028284 <sys_dlist_is_empty> @ imm = #-0x32
 80282b6: 4603         	mov	r3, r0
 80282b8: 2b00         	cmp	r3, #0x0
 80282ba: d102         	bne	0x80282c2 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 80282bc: 687b         	ldr	r3, [r7, #0x4]
 80282be: 681b         	ldr	r3, [r3]
 80282c0: e000         	b	0x80282c4 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 80282c2: 2300         	movs	r3, #0x0
; }
 80282c4: 4618         	mov	r0, r3
 80282c6: 3708         	adds	r7, #0x8
 80282c8: 46bd         	mov	sp, r7
 80282ca: bd80         	pop	{r7, pc}

080282cc <sys_dlist_peek_next_no_check>:
; {
 80282cc: b480         	push	{r7}
 80282ce: b083         	sub	sp, #0xc
 80282d0: af00         	add	r7, sp, #0x0
 80282d2: 6078         	str	r0, [r7, #0x4]
 80282d4: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 80282d6: 687b         	ldr	r3, [r7, #0x4]
 80282d8: 685b         	ldr	r3, [r3, #0x4]
 80282da: 683a         	ldr	r2, [r7]
 80282dc: 429a         	cmp	r2, r3
 80282de: d002         	beq	0x80282e6 <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 80282e0: 683b         	ldr	r3, [r7]
 80282e2: 681b         	ldr	r3, [r3]
 80282e4: e000         	b	0x80282e8 <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 80282e6: 2300         	movs	r3, #0x0
; }
 80282e8: 4618         	mov	r0, r3
 80282ea: 370c         	adds	r7, #0xc
 80282ec: 46bd         	mov	sp, r7
 80282ee: f85d 7b04    	ldr	r7, [sp], #4
 80282f2: 4770         	bx	lr

080282f4 <sys_dlist_peek_next>:
; {
 80282f4: b580         	push	{r7, lr}
 80282f6: b082         	sub	sp, #0x8
 80282f8: af00         	add	r7, sp, #0x0
 80282fa: 6078         	str	r0, [r7, #0x4]
 80282fc: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 80282fe: 683b         	ldr	r3, [r7]
 8028300: 2b00         	cmp	r3, #0x0
 8028302: d005         	beq	0x8028310 <sys_dlist_peek_next+0x1c> @ imm = #0xa
 8028304: 6839         	ldr	r1, [r7]
 8028306: 6878         	ldr	r0, [r7, #0x4]
 8028308: f7ff ffe0    	bl	0x80282cc <sys_dlist_peek_next_no_check> @ imm = #-0x40
 802830c: 4603         	mov	r3, r0
 802830e: e000         	b	0x8028312 <sys_dlist_peek_next+0x1e> @ imm = #0x0
 8028310: 2300         	movs	r3, #0x0
; }
 8028312: 4618         	mov	r0, r3
 8028314: 3708         	adds	r7, #0x8
 8028316: 46bd         	mov	sp, r7
 8028318: bd80         	pop	{r7, pc}

0802831a <sys_dlist_append>:
; {
 802831a: b480         	push	{r7}
 802831c: b085         	sub	sp, #0x14
 802831e: af00         	add	r7, sp, #0x0
 8028320: 6078         	str	r0, [r7, #0x4]
 8028322: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 8028324: 687b         	ldr	r3, [r7, #0x4]
 8028326: 685b         	ldr	r3, [r3, #0x4]
 8028328: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 802832a: 683b         	ldr	r3, [r7]
 802832c: 687a         	ldr	r2, [r7, #0x4]
 802832e: 601a         	str	r2, [r3]
; 	node->prev = tail;
 8028330: 683b         	ldr	r3, [r7]
 8028332: 68fa         	ldr	r2, [r7, #0xc]
 8028334: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 8028336: 68fb         	ldr	r3, [r7, #0xc]
 8028338: 683a         	ldr	r2, [r7]
 802833a: 601a         	str	r2, [r3]
; 	list->tail = node;
 802833c: 687b         	ldr	r3, [r7, #0x4]
 802833e: 683a         	ldr	r2, [r7]
 8028340: 605a         	str	r2, [r3, #0x4]
; }
 8028342: bf00         	nop
 8028344: 3714         	adds	r7, #0x14
 8028346: 46bd         	mov	sp, r7
 8028348: f85d 7b04    	ldr	r7, [sp], #4
 802834c: 4770         	bx	lr

0802834e <sys_dlist_insert>:
; {
 802834e: b480         	push	{r7}
 8028350: b085         	sub	sp, #0x14
 8028352: af00         	add	r7, sp, #0x0
 8028354: 6078         	str	r0, [r7, #0x4]
 8028356: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 8028358: 687b         	ldr	r3, [r7, #0x4]
 802835a: 685b         	ldr	r3, [r3, #0x4]
 802835c: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 802835e: 683b         	ldr	r3, [r7]
 8028360: 68fa         	ldr	r2, [r7, #0xc]
 8028362: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 8028364: 683b         	ldr	r3, [r7]
 8028366: 687a         	ldr	r2, [r7, #0x4]
 8028368: 601a         	str	r2, [r3]
; 	prev->next = node;
 802836a: 68fb         	ldr	r3, [r7, #0xc]
 802836c: 683a         	ldr	r2, [r7]
 802836e: 601a         	str	r2, [r3]
; 	successor->prev = node;
 8028370: 687b         	ldr	r3, [r7, #0x4]
 8028372: 683a         	ldr	r2, [r7]
 8028374: 605a         	str	r2, [r3, #0x4]
; }
 8028376: bf00         	nop
 8028378: 3714         	adds	r7, #0x14
 802837a: 46bd         	mov	sp, r7
 802837c: f85d 7b04    	ldr	r7, [sp], #4
 8028380: 4770         	bx	lr

08028382 <sys_dlist_remove>:
; {
 8028382: b580         	push	{r7, lr}
 8028384: b084         	sub	sp, #0x10
 8028386: af00         	add	r7, sp, #0x0
 8028388: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 802838a: 687b         	ldr	r3, [r7, #0x4]
 802838c: 685b         	ldr	r3, [r3, #0x4]
 802838e: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8028390: 687b         	ldr	r3, [r7, #0x4]
 8028392: 681b         	ldr	r3, [r3]
 8028394: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8028396: 68fb         	ldr	r3, [r7, #0xc]
 8028398: 68ba         	ldr	r2, [r7, #0x8]
 802839a: 601a         	str	r2, [r3]
; 	next->prev = prev;
 802839c: 68bb         	ldr	r3, [r7, #0x8]
 802839e: 68fa         	ldr	r2, [r7, #0xc]
 80283a0: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 80283a2: 6878         	ldr	r0, [r7, #0x4]
 80283a4: f7ff ff4d    	bl	0x8028242 <sys_dnode_init> @ imm = #-0x166
; }
 80283a8: bf00         	nop
 80283aa: 3710         	adds	r7, #0x10
 80283ac: 46bd         	mov	sp, r7
 80283ae: bd80         	pop	{r7, pc}

080283b0 <k_yield>:
; {
 80283b0: b580         	push	{r7, lr}
 80283b2: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 80283b4: f7ef f80c    	bl	0x80173d0 <z_impl_k_yield> @ imm = #-0x10fe8
; }
 80283b8: bf00         	nop
 80283ba: bd80         	pop	{r7, pc}

080283bc <k_thread_suspend>:
; {
 80283bc: b580         	push	{r7, lr}
 80283be: b082         	sub	sp, #0x8
 80283c0: af00         	add	r7, sp, #0x0
 80283c2: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_suspend(thread);
 80283c4: 6878         	ldr	r0, [r7, #0x4]
 80283c6: f7ee fa4f    	bl	0x8016868 <z_impl_k_thread_suspend> @ imm = #-0x11b62
; }
 80283ca: bf00         	nop
 80283cc: 3708         	adds	r7, #0x8
 80283ce: 46bd         	mov	sp, r7
 80283d0: bd80         	pop	{r7, pc}

080283d2 <z_is_inactive_timeout>:
; {
 80283d2: b580         	push	{r7, lr}
 80283d4: b082         	sub	sp, #0x8
 80283d6: af00         	add	r7, sp, #0x0
 80283d8: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 80283da: 687b         	ldr	r3, [r7, #0x4]
 80283dc: 4618         	mov	r0, r3
 80283de: f7ff ff40    	bl	0x8028262 <sys_dnode_is_linked> @ imm = #-0x180
 80283e2: 4603         	mov	r3, r0
 80283e4: 2b00         	cmp	r3, #0x0
 80283e6: bf14         	ite	ne
 80283e8: 2301         	movne	r3, #0x1
 80283ea: 2300         	moveq	r3, #0x0
 80283ec: b2db         	uxtb	r3, r3
 80283ee: f083 0301    	eor	r3, r3, #0x1
 80283f2: b2db         	uxtb	r3, r3
 80283f4: f003 0301    	and	r3, r3, #0x1
 80283f8: b2db         	uxtb	r3, r3
; }
 80283fa: 4618         	mov	r0, r3
 80283fc: 3708         	adds	r7, #0x8
 80283fe: 46bd         	mov	sp, r7
 8028400: bd80         	pop	{r7, pc}

08028402 <z_abort_thread_timeout>:
; {
 8028402: b580         	push	{r7, lr}
 8028404: b082         	sub	sp, #0x8
 8028406: af00         	add	r7, sp, #0x0
 8028408: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 802840a: 687b         	ldr	r3, [r7, #0x4]
 802840c: 3318         	adds	r3, #0x18
 802840e: 4618         	mov	r0, r3
 8028410: f7ef ff36    	bl	0x8018280 <z_abort_timeout> @ imm = #-0x10194
 8028414: 4603         	mov	r3, r0
; }
 8028416: 4618         	mov	r0, r3
 8028418: 3708         	adds	r7, #0x8
 802841a: 46bd         	mov	sp, r7
 802841c: bd80         	pop	{r7, pc}

0802841e <thread_is_preemptible>:
; {
 802841e: b480         	push	{r7}
 8028420: b083         	sub	sp, #0xc
 8028422: af00         	add	r7, sp, #0x0
 8028424: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 8028426: 687b         	ldr	r3, [r7, #0x4]
 8028428: 89db         	ldrh	r3, [r3, #0xe]
 802842a: 2b7f         	cmp	r3, #0x7f
 802842c: bf94         	ite	ls
 802842e: 2301         	movls	r3, #0x1
 8028430: 2300         	movhi	r3, #0x0
 8028432: b2db         	uxtb	r3, r3
; }
 8028434: 4618         	mov	r0, r3
 8028436: 370c         	adds	r7, #0xc
 8028438: 46bd         	mov	sp, r7
 802843a: f85d 7b04    	ldr	r7, [sp], #4
 802843e: 4770         	bx	lr

08028440 <thread_is_metairq>:
; {
 8028440: b480         	push	{r7}
 8028442: b083         	sub	sp, #0xc
 8028444: af00         	add	r7, sp, #0x0
 8028446: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8028448: 2300         	movs	r3, #0x0
; }
 802844a: 4618         	mov	r0, r3
 802844c: 370c         	adds	r7, #0xc
 802844e: 46bd         	mov	sp, r7
 8028450: f85d 7b04    	ldr	r7, [sp], #4
 8028454: 4770         	bx	lr

08028456 <z_is_thread_suspended>:
; {
 8028456: b480         	push	{r7}
 8028458: b083         	sub	sp, #0xc
 802845a: af00         	add	r7, sp, #0x0
 802845c: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_SUSPENDED) != 0U;
 802845e: 687b         	ldr	r3, [r7, #0x4]
 8028460: 7b5b         	ldrb	r3, [r3, #0xd]
 8028462: f003 0310    	and	r3, r3, #0x10
 8028466: 2b00         	cmp	r3, #0x0
 8028468: bf14         	ite	ne
 802846a: 2301         	movne	r3, #0x1
 802846c: 2300         	moveq	r3, #0x0
 802846e: b2db         	uxtb	r3, r3
; }
 8028470: 4618         	mov	r0, r3
 8028472: 370c         	adds	r7, #0xc
 8028474: 46bd         	mov	sp, r7
 8028476: f85d 7b04    	ldr	r7, [sp], #4
 802847a: 4770         	bx	lr

0802847c <z_is_thread_prevented_from_running>:
; {
 802847c: b480         	push	{r7}
 802847e: b085         	sub	sp, #0x14
 8028480: af00         	add	r7, sp, #0x0
 8028482: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 8028484: 687b         	ldr	r3, [r7, #0x4]
 8028486: 7b5b         	ldrb	r3, [r3, #0xd]
 8028488: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 802848a: 7bfb         	ldrb	r3, [r7, #0xf]
 802848c: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 8028490: 2b00         	cmp	r3, #0x0
 8028492: bf14         	ite	ne
 8028494: 2301         	movne	r3, #0x1
 8028496: 2300         	moveq	r3, #0x0
 8028498: b2db         	uxtb	r3, r3
; }
 802849a: 4618         	mov	r0, r3
 802849c: 3714         	adds	r7, #0x14
 802849e: 46bd         	mov	sp, r7
 80284a0: f85d 7b04    	ldr	r7, [sp], #4
 80284a4: 4770         	bx	lr

080284a6 <z_is_thread_timeout_active>:
; {
 80284a6: b580         	push	{r7, lr}
 80284a8: b082         	sub	sp, #0x8
 80284aa: af00         	add	r7, sp, #0x0
 80284ac: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 80284ae: 687b         	ldr	r3, [r7, #0x4]
 80284b0: 3318         	adds	r3, #0x18
 80284b2: 4618         	mov	r0, r3
 80284b4: f7ff ff8d    	bl	0x80283d2 <z_is_inactive_timeout> @ imm = #-0xe6
 80284b8: 4603         	mov	r3, r0
 80284ba: 2b00         	cmp	r3, #0x0
 80284bc: bf14         	ite	ne
 80284be: 2301         	movne	r3, #0x1
 80284c0: 2300         	moveq	r3, #0x0
 80284c2: b2db         	uxtb	r3, r3
 80284c4: f083 0301    	eor	r3, r3, #0x1
 80284c8: b2db         	uxtb	r3, r3
 80284ca: f003 0301    	and	r3, r3, #0x1
 80284ce: b2db         	uxtb	r3, r3
; }
 80284d0: 4618         	mov	r0, r3
 80284d2: 3708         	adds	r7, #0x8
 80284d4: 46bd         	mov	sp, r7
 80284d6: bd80         	pop	{r7, pc}

080284d8 <z_is_thread_ready>:
; {
 80284d8: b580         	push	{r7, lr}
 80284da: b082         	sub	sp, #0x8
 80284dc: af00         	add	r7, sp, #0x0
 80284de: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 80284e0: 6878         	ldr	r0, [r7, #0x4]
 80284e2: f7ff ffcb    	bl	0x802847c <z_is_thread_prevented_from_running> @ imm = #-0x6a
 80284e6: 4603         	mov	r3, r0
 80284e8: f083 0301    	eor	r3, r3, #0x1
 80284ec: b2db         	uxtb	r3, r3
 80284ee: 2b00         	cmp	r3, #0x0
 80284f0: d00a         	beq	0x8028508 <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 80284f2: 6878         	ldr	r0, [r7, #0x4]
 80284f4: f7ff ffd7    	bl	0x80284a6 <z_is_thread_timeout_active> @ imm = #-0x52
 80284f8: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 80284fa: f083 0301    	eor	r3, r3, #0x1
 80284fe: b2db         	uxtb	r3, r3
 8028500: 2b00         	cmp	r3, #0x0
 8028502: d001         	beq	0x8028508 <z_is_thread_ready+0x30> @ imm = #0x2
 8028504: 2301         	movs	r3, #0x1
 8028506: e000         	b	0x802850a <z_is_thread_ready+0x32> @ imm = #0x0
 8028508: 2300         	movs	r3, #0x0
 802850a: f003 0301    	and	r3, r3, #0x1
 802850e: b2db         	uxtb	r3, r3
; }
 8028510: 4618         	mov	r0, r3
 8028512: 3708         	adds	r7, #0x8
 8028514: 46bd         	mov	sp, r7
 8028516: bd80         	pop	{r7, pc}

08028518 <z_is_thread_state_set>:
; {
 8028518: b480         	push	{r7}
 802851a: b083         	sub	sp, #0xc
 802851c: af00         	add	r7, sp, #0x0
 802851e: 6078         	str	r0, [r7, #0x4]
 8028520: 6039         	str	r1, [r7]
; 	return (thread->base.thread_state & state) != 0U;
 8028522: 687b         	ldr	r3, [r7, #0x4]
 8028524: 7b5b         	ldrb	r3, [r3, #0xd]
 8028526: 461a         	mov	r2, r3
 8028528: 683b         	ldr	r3, [r7]
 802852a: 4013         	ands	r3, r2
 802852c: 2b00         	cmp	r3, #0x0
 802852e: bf14         	ite	ne
 8028530: 2301         	movne	r3, #0x1
 8028532: 2300         	moveq	r3, #0x0
 8028534: b2db         	uxtb	r3, r3
; }
 8028536: 4618         	mov	r0, r3
 8028538: 370c         	adds	r7, #0xc
 802853a: 46bd         	mov	sp, r7
 802853c: f85d 7b04    	ldr	r7, [sp], #4
 8028540: 4770         	bx	lr

08028542 <z_is_thread_queued>:
; {
 8028542: b580         	push	{r7, lr}
 8028544: b082         	sub	sp, #0x8
 8028546: af00         	add	r7, sp, #0x0
 8028548: 6078         	str	r0, [r7, #0x4]
; 	return z_is_thread_state_set(thread, _THREAD_QUEUED);
 802854a: 2180         	movs	r1, #0x80
 802854c: 6878         	ldr	r0, [r7, #0x4]
 802854e: f7ff ffe3    	bl	0x8028518 <z_is_thread_state_set> @ imm = #-0x3a
 8028552: 4603         	mov	r3, r0
; }
 8028554: 4618         	mov	r0, r3
 8028556: 3708         	adds	r7, #0x8
 8028558: 46bd         	mov	sp, r7
 802855a: bd80         	pop	{r7, pc}

0802855c <z_mark_thread_as_suspended>:
; {
 802855c: b480         	push	{r7}
 802855e: b083         	sub	sp, #0xc
 8028560: af00         	add	r7, sp, #0x0
 8028562: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_SUSPENDED;
 8028564: 687b         	ldr	r3, [r7, #0x4]
 8028566: 7b5b         	ldrb	r3, [r3, #0xd]
 8028568: f043 0310    	orr	r3, r3, #0x10
 802856c: b2da         	uxtb	r2, r3
 802856e: 687b         	ldr	r3, [r7, #0x4]
 8028570: 735a         	strb	r2, [r3, #0xd]
; }
 8028572: bf00         	nop
 8028574: 370c         	adds	r7, #0xc
 8028576: 46bd         	mov	sp, r7
 8028578: f85d 7b04    	ldr	r7, [sp], #4
 802857c: 4770         	bx	lr

0802857e <z_mark_thread_as_not_suspended>:
; {
 802857e: b480         	push	{r7}
 8028580: b083         	sub	sp, #0xc
 8028582: af00         	add	r7, sp, #0x0
 8028584: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 8028586: 687b         	ldr	r3, [r7, #0x4]
 8028588: 7b5b         	ldrb	r3, [r3, #0xd]
 802858a: f023 0310    	bic	r3, r3, #0x10
 802858e: b2da         	uxtb	r2, r3
 8028590: 687b         	ldr	r3, [r7, #0x4]
 8028592: 735a         	strb	r2, [r3, #0xd]
; }
 8028594: bf00         	nop
 8028596: 370c         	adds	r7, #0xc
 8028598: 46bd         	mov	sp, r7
 802859a: f85d 7b04    	ldr	r7, [sp], #4
 802859e: 4770         	bx	lr

080285a0 <z_mark_thread_as_pending>:
; {
 80285a0: b480         	push	{r7}
 80285a2: b083         	sub	sp, #0xc
 80285a4: af00         	add	r7, sp, #0x0
 80285a6: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_PENDING;
 80285a8: 687b         	ldr	r3, [r7, #0x4]
 80285aa: 7b5b         	ldrb	r3, [r3, #0xd]
 80285ac: f043 0302    	orr	r3, r3, #0x2
 80285b0: b2da         	uxtb	r2, r3
 80285b2: 687b         	ldr	r3, [r7, #0x4]
 80285b4: 735a         	strb	r2, [r3, #0xd]
; }
 80285b6: bf00         	nop
 80285b8: 370c         	adds	r7, #0xc
 80285ba: 46bd         	mov	sp, r7
 80285bc: f85d 7b04    	ldr	r7, [sp], #4
 80285c0: 4770         	bx	lr

080285c2 <z_mark_thread_as_not_pending>:
; {
 80285c2: b480         	push	{r7}
 80285c4: b083         	sub	sp, #0xc
 80285c6: af00         	add	r7, sp, #0x0
 80285c8: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 80285ca: 687b         	ldr	r3, [r7, #0x4]
 80285cc: 7b5b         	ldrb	r3, [r3, #0xd]
 80285ce: f023 0302    	bic	r3, r3, #0x2
 80285d2: b2da         	uxtb	r2, r3
 80285d4: 687b         	ldr	r3, [r7, #0x4]
 80285d6: 735a         	strb	r2, [r3, #0xd]
; }
 80285d8: bf00         	nop
 80285da: 370c         	adds	r7, #0xc
 80285dc: 46bd         	mov	sp, r7
 80285de: f85d 7b04    	ldr	r7, [sp], #4
 80285e2: 4770         	bx	lr

080285e4 <z_is_thread_essential>:
; {
 80285e4: b480         	push	{r7}
 80285e6: b083         	sub	sp, #0xc
 80285e8: af00         	add	r7, sp, #0x0
 80285ea: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
 80285ec: 687b         	ldr	r3, [r7, #0x4]
 80285ee: 7b1b         	ldrb	r3, [r3, #0xc]
 80285f0: f003 0301    	and	r3, r3, #0x1
 80285f4: 2b00         	cmp	r3, #0x0
 80285f6: bf14         	ite	ne
 80285f8: 2301         	movne	r3, #0x1
 80285fa: 2300         	moveq	r3, #0x0
 80285fc: b2db         	uxtb	r3, r3
; }
 80285fe: 4618         	mov	r0, r3
 8028600: 370c         	adds	r7, #0xc
 8028602: 46bd         	mov	sp, r7
 8028604: f85d 7b04    	ldr	r7, [sp], #4
 8028608: 4770         	bx	lr

0802860a <z_reschedule_unlocked>:
; {
 802860a: b580         	push	{r7, lr}
 802860c: b084         	sub	sp, #0x10
 802860e: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8028610: f3ef 8311    	mrs	r3, basepri
 8028614: 60fb         	str	r3, [r7, #0xc]
;   return(result);
 8028616: 68fb         	ldr	r3, [r7, #0xc]
; 	key = __get_BASEPRI();
 8028618: 60bb         	str	r3, [r7, #0x8]
 802861a: 2310         	movs	r3, #0x10
 802861c: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 802861e: 687b         	ldr	r3, [r7, #0x4]
 8028620: f383 8812    	msr	basepri_max, r3
; }
 8028624: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8028626: f3bf 8f6f    	isb	sy
; }
 802862a: bf00         	nop
; 	return key;
 802862c: 68bb         	ldr	r3, [r7, #0x8]
; 	(void) z_reschedule_irqlock(arch_irq_lock());
 802862e: 4618         	mov	r0, r3
 8028630: f000 f9c6    	bl	0x80289c0 <z_reschedule_irqlock> @ imm = #0x38c
; }
 8028634: bf00         	nop
 8028636: 3710         	adds	r7, #0x10
 8028638: 46bd         	mov	sp, r7
 802863a: bd80         	pop	{r7, pc}

0802863c <unpend_thread_no_timeout>:
; {
 802863c: b580         	push	{r7, lr}
 802863e: b086         	sub	sp, #0x18
 8028640: af00         	add	r7, sp, #0x0
 8028642: 6078         	str	r0, [r7, #0x4]
 8028644: 687b         	ldr	r3, [r7, #0x4]
 8028646: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8028648: 68fb         	ldr	r3, [r7, #0xc]
 802864a: 689b         	ldr	r3, [r3, #0x8]
 802864c: 617b         	str	r3, [r7, #0x14]
 802864e: 687b         	ldr	r3, [r7, #0x4]
 8028650: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8028652: 693b         	ldr	r3, [r7, #0x10]
 8028654: 4618         	mov	r0, r3
 8028656: f7ff fe94    	bl	0x8028382 <sys_dlist_remove> @ imm = #-0x2d8
; }
 802865a: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 802865c: 6878         	ldr	r0, [r7, #0x4]
 802865e: f7ff ffb0    	bl	0x80285c2 <z_mark_thread_as_not_pending> @ imm = #-0xa0
; 	thread->base.pended_on = NULL;
 8028662: 687b         	ldr	r3, [r7, #0x4]
 8028664: 2200         	movs	r2, #0x0
 8028666: 609a         	str	r2, [r3, #0x8]
; }
 8028668: bf00         	nop
 802866a: 3718         	adds	r7, #0x18
 802866c: 46bd         	mov	sp, r7
 802866e: bd80         	pop	{r7, pc}

08028670 <z_waitq_head>:
; {
 8028670: b580         	push	{r7, lr}
 8028672: b082         	sub	sp, #0x8
 8028674: af00         	add	r7, sp, #0x0
 8028676: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 8028678: 687b         	ldr	r3, [r7, #0x4]
 802867a: 4618         	mov	r0, r3
 802867c: f7ff fe14    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #-0x3d8
 8028680: 4603         	mov	r3, r0
; }
 8028682: 4618         	mov	r0, r3
 8028684: 3708         	adds	r7, #0x8
 8028686: 46bd         	mov	sp, r7
 8028688: bd80         	pop	{r7, pc}

0802868a <z_swap_irqlock>:
; {
 802868a: b580         	push	{r7, lr}
 802868c: b084         	sub	sp, #0x10
 802868e: af00         	add	r7, sp, #0x0
 8028690: 6078         	str	r0, [r7, #0x4]
; 	ret = arch_swap(key);
 8028692: 6878         	ldr	r0, [r7, #0x4]
 8028694: f7dd fec2    	bl	0x800641c <arch_swap>   @ imm = #-0x2227c
 8028698: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 802869a: 68fb         	ldr	r3, [r7, #0xc]
; }
 802869c: 4618         	mov	r0, r3
 802869e: 3710         	adds	r7, #0x10
 80286a0: 46bd         	mov	sp, r7
 80286a2: bd80         	pop	{r7, pc}

080286a4 <z_log_msg_runtime_create>:
; {
 80286a4: b580         	push	{r7, lr}
 80286a6: b08a         	sub	sp, #0x28
 80286a8: af04         	add	r7, sp, #0x10
 80286aa: 60b9         	str	r1, [r7, #0x8]
 80286ac: 607b         	str	r3, [r7, #0x4]
 80286ae: 4603         	mov	r3, r0
 80286b0: 73fb         	strb	r3, [r7, #0xf]
 80286b2: 4613         	mov	r3, r2
 80286b4: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80286b6: f107 032c    	add.w	r3, r7, #0x2c
 80286ba: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80286bc: 7bba         	ldrb	r2, [r7, #0xe]
 80286be: 7bf8         	ldrb	r0, [r7, #0xf]
 80286c0: 697b         	ldr	r3, [r7, #0x14]
 80286c2: 9303         	str	r3, [sp, #0xc]
 80286c4: 6abb         	ldr	r3, [r7, #0x28]
 80286c6: 9302         	str	r3, [sp, #0x8]
 80286c8: 6a7b         	ldr	r3, [r7, #0x24]
 80286ca: 9301         	str	r3, [sp, #0x4]
 80286cc: 6a3b         	ldr	r3, [r7, #0x20]
 80286ce: 9300         	str	r3, [sp]
 80286d0: 687b         	ldr	r3, [r7, #0x4]
 80286d2: 68b9         	ldr	r1, [r7, #0x8]
 80286d4: f7dc fa4e    	bl	0x8004b74 <z_log_msg_runtime_vcreate> @ imm = #-0x23b64
; }
 80286d8: bf00         	nop
 80286da: 3718         	adds	r7, #0x18
 80286dc: 46bd         	mov	sp, r7
 80286de: bd80         	pop	{r7, pc}

080286e0 <z_sched_prio_cmp>:
; {
 80286e0: b480         	push	{r7}
 80286e2: b085         	sub	sp, #0x14
 80286e4: af00         	add	r7, sp, #0x0
 80286e6: 6078         	str	r0, [r7, #0x4]
 80286e8: 6039         	str	r1, [r7]
; 	int32_t b1 = thread_1->base.prio;
 80286ea: 687b         	ldr	r3, [r7, #0x4]
 80286ec: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 80286f0: 60fb         	str	r3, [r7, #0xc]
; 	int32_t b2 = thread_2->base.prio;
 80286f2: 683b         	ldr	r3, [r7]
 80286f4: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 80286f8: 60bb         	str	r3, [r7, #0x8]
; 	if (b1 != b2) {
 80286fa: 68fa         	ldr	r2, [r7, #0xc]
 80286fc: 68bb         	ldr	r3, [r7, #0x8]
 80286fe: 429a         	cmp	r2, r3
 8028700: d003         	beq	0x802870a <z_sched_prio_cmp+0x2a> @ imm = #0x6
; 		return b2 - b1;
 8028702: 68ba         	ldr	r2, [r7, #0x8]
 8028704: 68fb         	ldr	r3, [r7, #0xc]
 8028706: 1ad3         	subs	r3, r2, r3
 8028708: e000         	b	0x802870c <z_sched_prio_cmp+0x2c> @ imm = #0x0
; 	return 0;
 802870a: 2300         	movs	r3, #0x0
; }
 802870c: 4618         	mov	r0, r3
 802870e: 3714         	adds	r7, #0x14
 8028710: 46bd         	mov	sp, r7
 8028712: f85d 7b04    	ldr	r7, [sp], #4
 8028716: 4770         	bx	lr

08028718 <should_queue_thread>:
; {
 8028718: b480         	push	{r7}
 802871a: b083         	sub	sp, #0xc
 802871c: af00         	add	r7, sp, #0x0
 802871e: 6078         	str	r0, [r7, #0x4]
; 	return !IS_ENABLED(CONFIG_SMP) || (thread != arch_current_thread());
 8028720: 2301         	movs	r3, #0x1
; }
 8028722: 4618         	mov	r0, r3
 8028724: 370c         	adds	r7, #0xc
 8028726: 46bd         	mov	sp, r7
 8028728: f85d 7b04    	ldr	r7, [sp], #4
 802872c: 4770         	bx	lr

0802872e <is_aborting>:
; {
 802872e: b480         	push	{r7}
 8028730: b083         	sub	sp, #0xc
 8028732: af00         	add	r7, sp, #0x0
 8028734: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_ABORTING) != 0U;
 8028736: 687b         	ldr	r3, [r7, #0x4]
 8028738: 7b5b         	ldrb	r3, [r3, #0xd]
 802873a: f003 0320    	and	r3, r3, #0x20
 802873e: 2b00         	cmp	r3, #0x0
 8028740: bf14         	ite	ne
 8028742: 2301         	movne	r3, #0x1
 8028744: 2300         	moveq	r3, #0x0
 8028746: b2db         	uxtb	r3, r3
; }
 8028748: 4618         	mov	r0, r3
 802874a: 370c         	adds	r7, #0xc
 802874c: 46bd         	mov	sp, r7
 802874e: f85d 7b04    	ldr	r7, [sp], #4
 8028752: 4770         	bx	lr

08028754 <is_halting>:
; {
 8028754: b480         	push	{r7}
 8028756: b083         	sub	sp, #0xc
 8028758: af00         	add	r7, sp, #0x0
 802875a: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state &
 802875c: 687b         	ldr	r3, [r7, #0x4]
 802875e: 7b5b         	ldrb	r3, [r3, #0xd]
 8028760: f003 0360    	and	r3, r3, #0x60
; 		(_THREAD_ABORTING | _THREAD_SUSPENDING)) != 0U;
 8028764: 2b00         	cmp	r3, #0x0
 8028766: bf14         	ite	ne
 8028768: 2301         	movne	r3, #0x1
 802876a: 2300         	moveq	r3, #0x0
 802876c: b2db         	uxtb	r3, r3
; }
 802876e: 4618         	mov	r0, r3
 8028770: 370c         	adds	r7, #0xc
 8028772: 46bd         	mov	sp, r7
 8028774: f85d 7b04    	ldr	r7, [sp], #4
 8028778: 4770         	bx	lr

0802877a <clear_halting>:
; {
 802877a: b480         	push	{r7}
 802877c: b083         	sub	sp, #0xc
 802877e: af00         	add	r7, sp, #0x0
 8028780: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("dmb 0xF":::"memory");
 8028782: f3bf 8f5f    	dmb	sy
; }
 8028786: bf00         	nop
; }
 8028788: bf00         	nop
; }
 802878a: bf00         	nop
; 	thread->base.thread_state &= ~(_THREAD_ABORTING | _THREAD_SUSPENDING);
 802878c: 687b         	ldr	r3, [r7, #0x4]
 802878e: 7b5b         	ldrb	r3, [r3, #0xd]
 8028790: f023 0360    	bic	r3, r3, #0x60
 8028794: b2da         	uxtb	r2, r3
 8028796: 687b         	ldr	r3, [r7, #0x4]
 8028798: 735a         	strb	r2, [r3, #0xd]
; }
 802879a: bf00         	nop
 802879c: 370c         	adds	r7, #0xc
 802879e: 46bd         	mov	sp, r7
 80287a0: f85d 7b04    	ldr	r7, [sp], #4
 80287a4: 4770         	bx	lr

080287a6 <update_metairq_preempt>:
; {
 80287a6: b480         	push	{r7}
 80287a8: b083         	sub	sp, #0xc
 80287aa: af00         	add	r7, sp, #0x0
 80287ac: 6078         	str	r0, [r7, #0x4]
; }
 80287ae: bf00         	nop
 80287b0: 370c         	adds	r7, #0xc
 80287b2: 46bd         	mov	sp, r7
 80287b4: f85d 7b04    	ldr	r7, [sp], #4
 80287b8: 4770         	bx	lr

080287ba <thread_active_elsewhere>:
; {
 80287ba: b480         	push	{r7}
 80287bc: b083         	sub	sp, #0xc
 80287be: af00         	add	r7, sp, #0x0
 80287c0: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 80287c2: 2300         	movs	r3, #0x0
; }
 80287c4: 4618         	mov	r0, r3
 80287c6: 370c         	adds	r7, #0xc
 80287c8: 46bd         	mov	sp, r7
 80287ca: f85d 7b04    	ldr	r7, [sp], #4
 80287ce: 4770         	bx	lr

080287d0 <add_to_waitq_locked>:
; {
 80287d0: b580         	push	{r7, lr}
 80287d2: b086         	sub	sp, #0x18
 80287d4: af00         	add	r7, sp, #0x0
 80287d6: 6078         	str	r0, [r7, #0x4]
 80287d8: 6039         	str	r1, [r7]
; 	unready_thread(thread);
 80287da: 6878         	ldr	r0, [r7, #0x4]
 80287dc: f7ee f9b4    	bl	0x8016b48 <unready_thread> @ imm = #-0x11c98
; 	z_mark_thread_as_pending(thread);
 80287e0: 6878         	ldr	r0, [r7, #0x4]
 80287e2: f7ff fedd    	bl	0x80285a0 <z_mark_thread_as_pending> @ imm = #-0x246
; 	if (wait_q != NULL) {
 80287e6: 683b         	ldr	r3, [r7]
 80287e8: 2b00         	cmp	r3, #0x0
 80287ea: d041         	beq	0x8028870 <add_to_waitq_locked+0xa0> @ imm = #0x82
; 		thread->base.pended_on = wait_q;
 80287ec: 687b         	ldr	r3, [r7, #0x4]
 80287ee: 683a         	ldr	r2, [r7]
 80287f0: 609a         	str	r2, [r3, #0x8]
; 		_priq_wait_add(&wait_q->waitq, thread);
 80287f2: 683b         	ldr	r3, [r7]
 80287f4: 617b         	str	r3, [r7, #0x14]
 80287f6: 687b         	ldr	r3, [r7, #0x4]
 80287f8: 613b         	str	r3, [r7, #0x10]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80287fa: 6978         	ldr	r0, [r7, #0x14]
 80287fc: f7ff fd54    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #-0x558
 8028800: 4603         	mov	r3, r0
 8028802: 2b00         	cmp	r3, #0x0
 8028804: d004         	beq	0x8028810 <add_to_waitq_locked+0x40> @ imm = #0x8
 8028806: 6978         	ldr	r0, [r7, #0x14]
 8028808: f7ff fd4e    	bl	0x80282a8 <sys_dlist_peek_head> @ imm = #-0x564
 802880c: 4603         	mov	r3, r0
 802880e: e000         	b	0x8028812 <add_to_waitq_locked+0x42> @ imm = #0x0
 8028810: 2300         	movs	r3, #0x0
 8028812: 60fb         	str	r3, [r7, #0xc]
 8028814: e024         	b	0x8028860 <add_to_waitq_locked+0x90> @ imm = #0x48
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8028816: 68f9         	ldr	r1, [r7, #0xc]
 8028818: 6938         	ldr	r0, [r7, #0x10]
 802881a: f7ff ff61    	bl	0x80286e0 <z_sched_prio_cmp> @ imm = #-0x13e
 802881e: 4603         	mov	r3, r0
 8028820: 2b00         	cmp	r3, #0x0
 8028822: dd07         	ble	0x8028834 <add_to_waitq_locked+0x64> @ imm = #0xe
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8028824: 68fb         	ldr	r3, [r7, #0xc]
 8028826: 693a         	ldr	r2, [r7, #0x10]
 8028828: 4611         	mov	r1, r2
 802882a: 4618         	mov	r0, r3
 802882c: f7ff fd8f    	bl	0x802834e <sys_dlist_insert> @ imm = #-0x4e2
; 			return;
 8028830: bf00         	nop
; }
 8028832: e01d         	b	0x8028870 <add_to_waitq_locked+0xa0> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8028834: 68fb         	ldr	r3, [r7, #0xc]
 8028836: 2b00         	cmp	r3, #0x0
 8028838: d010         	beq	0x802885c <add_to_waitq_locked+0x8c> @ imm = #0x20
 802883a: 68fb         	ldr	r3, [r7, #0xc]
 802883c: 4619         	mov	r1, r3
 802883e: 6978         	ldr	r0, [r7, #0x14]
 8028840: f7ff fd58    	bl	0x80282f4 <sys_dlist_peek_next> @ imm = #-0x550
 8028844: 4603         	mov	r3, r0
 8028846: 2b00         	cmp	r3, #0x0
 8028848: d006         	beq	0x8028858 <add_to_waitq_locked+0x88> @ imm = #0xc
 802884a: 68fb         	ldr	r3, [r7, #0xc]
 802884c: 4619         	mov	r1, r3
 802884e: 6978         	ldr	r0, [r7, #0x14]
 8028850: f7ff fd50    	bl	0x80282f4 <sys_dlist_peek_next> @ imm = #-0x560
 8028854: 4603         	mov	r3, r0
 8028856: e002         	b	0x802885e <add_to_waitq_locked+0x8e> @ imm = #0x4
 8028858: 2300         	movs	r3, #0x0
 802885a: e000         	b	0x802885e <add_to_waitq_locked+0x8e> @ imm = #0x0
 802885c: 2300         	movs	r3, #0x0
 802885e: 60fb         	str	r3, [r7, #0xc]
 8028860: 68fb         	ldr	r3, [r7, #0xc]
 8028862: 2b00         	cmp	r3, #0x0
 8028864: d1d7         	bne	0x8028816 <add_to_waitq_locked+0x46> @ imm = #-0x52
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8028866: 693b         	ldr	r3, [r7, #0x10]
 8028868: 4619         	mov	r1, r3
 802886a: 6978         	ldr	r0, [r7, #0x14]
 802886c: f7ff fd55    	bl	0x802831a <sys_dlist_append> @ imm = #-0x556
; }
 8028870: bf00         	nop
 8028872: 3718         	adds	r7, #0x18
 8028874: 46bd         	mov	sp, r7
 8028876: bd80         	pop	{r7, pc}

08028878 <add_thread_timeout>:
; {
 8028878: b580         	push	{r7, lr}
 802887a: b084         	sub	sp, #0x10
 802887c: af00         	add	r7, sp, #0x0
 802887e: 60f8         	str	r0, [r7, #0xc]
 8028880: e9c7 2300    	strd	r2, r3, [r7]
; 	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8028884: e9d7 2300    	ldrd	r2, r3, [r7]
 8028888: f04f 30ff    	mov.w	r0, #0xffffffff
 802888c: f04f 31ff    	mov.w	r1, #0xffffffff
 8028890: 428b         	cmp	r3, r1
 8028892: bf08         	it	eq
 8028894: 4282         	cmpeq	r2, r0
 8028896: d004         	beq	0x80288a2 <add_thread_timeout+0x2a> @ imm = #0x8
; 		z_add_thread_timeout(thread, timeout);
 8028898: e9d7 2300    	ldrd	r2, r3, [r7]
 802889c: 68f8         	ldr	r0, [r7, #0xc]
 802889e: f7ed fca3    	bl	0x80161e8 <z_add_thread_timeout> @ imm = #-0x126ba
; }
 80288a2: bf00         	nop
 80288a4: 3710         	adds	r7, #0x10
 80288a6: 46bd         	mov	sp, r7
 80288a8: bd80         	pop	{r7, pc}

080288aa <pend_locked>:
; {
 80288aa: b580         	push	{r7, lr}
 80288ac: b084         	sub	sp, #0x10
 80288ae: af00         	add	r7, sp, #0x0
 80288b0: 60f8         	str	r0, [r7, #0xc]
 80288b2: 60b9         	str	r1, [r7, #0x8]
 80288b4: e9c7 2300    	strd	r2, r3, [r7]
; 	add_to_waitq_locked(thread, wait_q);
 80288b8: 68b9         	ldr	r1, [r7, #0x8]
 80288ba: 68f8         	ldr	r0, [r7, #0xc]
 80288bc: f7ff ff88    	bl	0x80287d0 <add_to_waitq_locked> @ imm = #-0xf0
; 	add_thread_timeout(thread, timeout);
 80288c0: e9d7 2300    	ldrd	r2, r3, [r7]
 80288c4: 68f8         	ldr	r0, [r7, #0xc]
 80288c6: f7ff ffd7    	bl	0x8028878 <add_thread_timeout> @ imm = #-0x52
; }
 80288ca: bf00         	nop
 80288cc: 3710         	adds	r7, #0x10
 80288ce: 46bd         	mov	sp, r7
 80288d0: bd80         	pop	{r7, pc}

080288d2 <z_thread_timeout>:
; {
 80288d2: b580         	push	{r7, lr}
 80288d4: b084         	sub	sp, #0x10
 80288d6: af00         	add	r7, sp, #0x0
 80288d8: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = CONTAINER_OF(timeout,
 80288da: 687b         	ldr	r3, [r7, #0x4]
 80288dc: 3b18         	subs	r3, #0x18
 80288de: 60fb         	str	r3, [r7, #0xc]
; 	z_sched_wake_thread(thread, true);
 80288e0: 2101         	movs	r1, #0x1
 80288e2: 68f8         	ldr	r0, [r7, #0xc]
 80288e4: f7ee fa14    	bl	0x8016d10 <z_sched_wake_thread> @ imm = #-0x11bd8
; }
 80288e8: bf00         	nop
 80288ea: 3710         	adds	r7, #0x10
 80288ec: 46bd         	mov	sp, r7
 80288ee: bd80         	pop	{r7, pc}

080288f0 <z_unpend_thread>:
; {
 80288f0: b580         	push	{r7, lr}
 80288f2: b082         	sub	sp, #0x8
 80288f4: af00         	add	r7, sp, #0x0
 80288f6: 6078         	str	r0, [r7, #0x4]
; 	z_unpend_thread_no_timeout(thread);
 80288f8: 6878         	ldr	r0, [r7, #0x4]
 80288fa: f7ee f9c3    	bl	0x8016c84 <z_unpend_thread_no_timeout> @ imm = #-0x11c7a
; 	(void)z_abort_thread_timeout(thread);
 80288fe: 6878         	ldr	r0, [r7, #0x4]
 8028900: f7ff fd7f    	bl	0x8028402 <z_abort_thread_timeout> @ imm = #-0x502
; }
 8028904: bf00         	nop
 8028906: 3708         	adds	r7, #0x8
 8028908: 46bd         	mov	sp, r7
 802890a: bd80         	pop	{r7, pc}

0802890c <resched>:
; {
 802890c: b480         	push	{r7}
 802890e: b085         	sub	sp, #0x14
 8028910: af00         	add	r7, sp, #0x0
 8028912: 6078         	str	r0, [r7, #0x4]
 8028914: 687b         	ldr	r3, [r7, #0x4]
 8028916: 60fb         	str	r3, [r7, #0xc]
; 	return key == 0U;
 8028918: 68fb         	ldr	r3, [r7, #0xc]
 802891a: 2b00         	cmp	r3, #0x0
 802891c: bf0c         	ite	eq
 802891e: 2301         	moveq	r3, #0x1
 8028920: 2300         	movne	r3, #0x0
 8028922: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 8028924: 2b00         	cmp	r3, #0x0
 8028926: d00f         	beq	0x8028948 <resched+0x3c> @ imm = #0x1e
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8028928: f3ef 8305    	mrs	r3, ipsr
 802892c: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 802892e: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 8028930: 2b00         	cmp	r3, #0x0
 8028932: bf14         	ite	ne
 8028934: 2301         	movne	r3, #0x1
 8028936: 2300         	moveq	r3, #0x0
 8028938: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 802893a: f083 0301    	eor	r3, r3, #0x1
 802893e: b2db         	uxtb	r3, r3
 8028940: 2b00         	cmp	r3, #0x0
 8028942: d001         	beq	0x8028948 <resched+0x3c> @ imm = #0x2
 8028944: 2301         	movs	r3, #0x1
 8028946: e000         	b	0x802894a <resched+0x3e> @ imm = #0x0
 8028948: 2300         	movs	r3, #0x0
 802894a: f003 0301    	and	r3, r3, #0x1
 802894e: b2db         	uxtb	r3, r3
; }
 8028950: 4618         	mov	r0, r3
 8028952: 3714         	adds	r7, #0x14
 8028954: 46bd         	mov	sp, r7
 8028956: f85d 7b04    	ldr	r7, [sp], #4
 802895a: 4770         	bx	lr

0802895c <z_reschedule>:
; {
 802895c: b580         	push	{r7, lr}
 802895e: b08a         	sub	sp, #0x28
 8028960: af00         	add	r7, sp, #0x0
 8028962: 6078         	str	r0, [r7, #0x4]
 8028964: 6039         	str	r1, [r7]
; 	if (resched(key.key) && need_swap()) {
 8028966: 683b         	ldr	r3, [r7]
 8028968: 4618         	mov	r0, r3
 802896a: f7ff ffcf    	bl	0x802890c <resched>     @ imm = #-0x62
 802896e: 4603         	mov	r3, r0
 8028970: 2b00         	cmp	r3, #0x0
 8028972: d010         	beq	0x8028996 <z_reschedule+0x3a> @ imm = #0x20
 8028974: f7ee fbce    	bl	0x8017114 <need_swap>   @ imm = #-0x11864
 8028978: 4603         	mov	r3, r0
 802897a: 2b00         	cmp	r3, #0x0
 802897c: d00b         	beq	0x8028996 <z_reschedule+0x3a> @ imm = #0x16
 802897e: 687b         	ldr	r3, [r7, #0x4]
 8028980: 627b         	str	r3, [r7, #0x24]
 8028982: 683b         	ldr	r3, [r7]
 8028984: 60fb         	str	r3, [r7, #0xc]
 8028986: 6a7b         	ldr	r3, [r7, #0x24]
 8028988: 623b         	str	r3, [r7, #0x20]
; }
 802898a: bf00         	nop
; 	return z_swap_irqlock(key.key);
 802898c: 68fb         	ldr	r3, [r7, #0xc]
 802898e: 4618         	mov	r0, r3
 8028990: f7ff fe7b    	bl	0x802868a <z_swap_irqlock> @ imm = #-0x30a
; 		z_swap(lock, key);
 8028994: e010         	b	0x80289b8 <z_reschedule+0x5c> @ imm = #0x20
 8028996: 687b         	ldr	r3, [r7, #0x4]
 8028998: 61fb         	str	r3, [r7, #0x1c]
 802899a: 683b         	ldr	r3, [r7]
 802899c: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 802899e: 693b         	ldr	r3, [r7, #0x10]
 80289a0: 61bb         	str	r3, [r7, #0x18]
 80289a2: 69bb         	ldr	r3, [r7, #0x18]
 80289a4: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80289a6: 697b         	ldr	r3, [r7, #0x14]
 80289a8: f383 8811    	msr	basepri, r3
; }
 80289ac: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80289ae: f3bf 8f6f    	isb	sy
; }
 80289b2: bf00         	nop
; }
 80289b4: bf00         	nop
; }
 80289b6: bf00         	nop
; }
 80289b8: bf00         	nop
 80289ba: 3728         	adds	r7, #0x28
 80289bc: 46bd         	mov	sp, r7
 80289be: bd80         	pop	{r7, pc}

080289c0 <z_reschedule_irqlock>:
; {
 80289c0: b580         	push	{r7, lr}
 80289c2: b084         	sub	sp, #0x10
 80289c4: af00         	add	r7, sp, #0x0
 80289c6: 6078         	str	r0, [r7, #0x4]
; 	if (resched(key) && need_swap()) {
 80289c8: 6878         	ldr	r0, [r7, #0x4]
 80289ca: f7ff ff9f    	bl	0x802890c <resched>     @ imm = #-0xc2
 80289ce: 4603         	mov	r3, r0
 80289d0: 2b00         	cmp	r3, #0x0
 80289d2: d008         	beq	0x80289e6 <z_reschedule_irqlock+0x26> @ imm = #0x10
 80289d4: f7ee fb9e    	bl	0x8017114 <need_swap>   @ imm = #-0x118c4
 80289d8: 4603         	mov	r3, r0
 80289da: 2b00         	cmp	r3, #0x0
 80289dc: d003         	beq	0x80289e6 <z_reschedule_irqlock+0x26> @ imm = #0x6
; 		z_swap_irqlock(key);
 80289de: 6878         	ldr	r0, [r7, #0x4]
 80289e0: f7ff fe53    	bl	0x802868a <z_swap_irqlock> @ imm = #-0x35a
 80289e4: e00b         	b	0x80289fe <z_reschedule_irqlock+0x3e> @ imm = #0x16
 80289e6: 687b         	ldr	r3, [r7, #0x4]
 80289e8: 60fb         	str	r3, [r7, #0xc]
 80289ea: 68fb         	ldr	r3, [r7, #0xc]
 80289ec: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80289ee: 68bb         	ldr	r3, [r7, #0x8]
 80289f0: f383 8811    	msr	basepri, r3
; }
 80289f4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80289f6: f3bf 8f6f    	isb	sy
; }
 80289fa: bf00         	nop
; }
 80289fc: bf00         	nop
; }
 80289fe: bf00         	nop
 8028a00: 3710         	adds	r7, #0x10
 8028a02: 46bd         	mov	sp, r7
 8028a04: bd80         	pop	{r7, pc}

08028a06 <z_unpend_all>:
; {
 8028a06: b580         	push	{r7, lr}
 8028a08: b084         	sub	sp, #0x10
 8028a0a: af00         	add	r7, sp, #0x0
 8028a0c: 6078         	str	r0, [r7, #0x4]
; 	int need_sched = 0;
 8028a0e: 2300         	movs	r3, #0x0
 8028a10: 60fb         	str	r3, [r7, #0xc]
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 8028a12: 6878         	ldr	r0, [r7, #0x4]
 8028a14: f7ff fe2c    	bl	0x8028670 <z_waitq_head> @ imm = #-0x3a8
 8028a18: 60b8         	str	r0, [r7, #0x8]
 8028a1a: e00b         	b	0x8028a34 <z_unpend_all+0x2e> @ imm = #0x16
; 		z_unpend_thread(thread);
 8028a1c: 68b8         	ldr	r0, [r7, #0x8]
 8028a1e: f7ff ff67    	bl	0x80288f0 <z_unpend_thread> @ imm = #-0x132
; 		z_ready_thread(thread);
 8028a22: 68b8         	ldr	r0, [r7, #0x8]
 8028a24: f7ed fdee    	bl	0x8016604 <z_ready_thread> @ imm = #-0x12424
; 		need_sched = 1;
 8028a28: 2301         	movs	r3, #0x1
 8028a2a: 60fb         	str	r3, [r7, #0xc]
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 8028a2c: 6878         	ldr	r0, [r7, #0x4]
 8028a2e: f7ff fe1f    	bl	0x8028670 <z_waitq_head> @ imm = #-0x3c2
 8028a32: 60b8         	str	r0, [r7, #0x8]
 8028a34: 68bb         	ldr	r3, [r7, #0x8]
 8028a36: 2b00         	cmp	r3, #0x0
 8028a38: d1f0         	bne	0x8028a1c <z_unpend_all+0x16> @ imm = #-0x20
; 	return need_sched;
 8028a3a: 68fb         	ldr	r3, [r7, #0xc]
; }
 8028a3c: 4618         	mov	r0, r3
 8028a3e: 3710         	adds	r7, #0x10
 8028a40: 46bd         	mov	sp, r7
 8028a42: bd80         	pop	{r7, pc}

08028a44 <init_ready_q>:
; {
 8028a44: b580         	push	{r7, lr}
 8028a46: b084         	sub	sp, #0x10
 8028a48: af00         	add	r7, sp, #0x0
 8028a4a: 6078         	str	r0, [r7, #0x4]
; 	_priq_run_init(&ready_q->runq);
 8028a4c: 687b         	ldr	r3, [r7, #0x4]
 8028a4e: 3304         	adds	r3, #0x4
 8028a50: 60fb         	str	r3, [r7, #0xc]
; 	sys_dlist_init(pq);
 8028a52: 68f8         	ldr	r0, [r7, #0xc]
 8028a54: f7ff fbe5    	bl	0x8028222 <sys_dlist_init> @ imm = #-0x836
; }
 8028a58: bf00         	nop
; }
 8028a5a: bf00         	nop
 8028a5c: 3710         	adds	r7, #0x10
 8028a5e: 46bd         	mov	sp, r7
 8028a60: bd80         	pop	{r7, pc}

08028a62 <z_impl_k_usleep>:
; {
 8028a62: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8028a66: b084         	sub	sp, #0x10
 8028a68: af00         	add	r7, sp, #0x0
 8028a6a: 6078         	str	r0, [r7, #0x4]
; 	ticks = k_us_to_ticks_ceil64(us);
 8028a6c: 6879         	ldr	r1, [r7, #0x4]
 8028a6e: 17c8         	asrs	r0, r1, #0x1f
 8028a70: 460a         	mov	r2, r1
 8028a72: 4603         	mov	r3, r0
 8028a74: f112 0463    	adds.w	r4, r2, #0x63
 8028a78: f143 0500    	adc	r5, r3, #0x0
 8028a7c: f04f 0264    	mov.w	r2, #0x64
 8028a80: f04f 0300    	mov.w	r3, #0x0
 8028a84: 4620         	mov	r0, r4
 8028a86: 4629         	mov	r1, r5
 8028a88: f7d7 fc72    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x2871c
 8028a8c: 4602         	mov	r2, r0
 8028a8e: 460b         	mov	r3, r1
 8028a90: 4613         	mov	r3, r2
 8028a92: 60fb         	str	r3, [r7, #0xc]
; 	ticks = z_tick_sleep(ticks);
 8028a94: 68fb         	ldr	r3, [r7, #0xc]
 8028a96: 17da         	asrs	r2, r3, #0x1f
 8028a98: 4698         	mov	r8, r3
 8028a9a: 4691         	mov	r9, r2
 8028a9c: 4640         	mov	r0, r8
 8028a9e: 4649         	mov	r1, r9
 8028aa0: f7ee fdac    	bl	0x80175fc <z_tick_sleep> @ imm = #-0x114a8
 8028aa4: 60f8         	str	r0, [r7, #0xc]
; 	int32_t ret = k_ticks_to_us_ceil64(ticks);
 8028aa6: 68fb         	ldr	r3, [r7, #0xc]
 8028aa8: 17da         	asrs	r2, r3, #0x1f
 8028aaa: 469a         	mov	r10, r3
 8028aac: 4693         	mov	r11, r2
 8028aae: 4652         	mov	r2, r10
 8028ab0: 2364         	movs	r3, #0x64
 8028ab2: fb02 f303    	mul	r3, r2, r3
 8028ab6: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 8028ab8: 68bb         	ldr	r3, [r7, #0x8]
; }
 8028aba: 4618         	mov	r0, r3
 8028abc: 3710         	adds	r7, #0x10
 8028abe: 46bd         	mov	sp, r7
 8028ac0: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08028ac4 <unpend_all>:
; {
 8028ac4: b580         	push	{r7, lr}
 8028ac6: b086         	sub	sp, #0x18
 8028ac8: af00         	add	r7, sp, #0x0
 8028aca: 6078         	str	r0, [r7, #0x4]
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 8028acc: 6878         	ldr	r0, [r7, #0x4]
 8028ace: f7ff fdcf    	bl	0x8028670 <z_waitq_head> @ imm = #-0x462
 8028ad2: 6178         	str	r0, [r7, #0x14]
 8028ad4: e015         	b	0x8028b02 <unpend_all+0x3e> @ imm = #0x2a
; 		unpend_thread_no_timeout(thread);
 8028ad6: 6978         	ldr	r0, [r7, #0x14]
 8028ad8: f7ff fdb0    	bl	0x802863c <unpend_thread_no_timeout> @ imm = #-0x4a0
; 		(void)z_abort_thread_timeout(thread);
 8028adc: 6978         	ldr	r0, [r7, #0x14]
 8028ade: f7ff fc90    	bl	0x8028402 <z_abort_thread_timeout> @ imm = #-0x6e0
 8028ae2: 697b         	ldr	r3, [r7, #0x14]
 8028ae4: 613b         	str	r3, [r7, #0x10]
 8028ae6: 2300         	movs	r3, #0x0
 8028ae8: 60fb         	str	r3, [r7, #0xc]
; 	thread->arch.swap_return_value = value;
 8028aea: 693b         	ldr	r3, [r7, #0x10]
 8028aec: 68fa         	ldr	r2, [r7, #0xc]
 8028aee: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8028af2: bf00         	nop
; 		ready_thread(thread);
 8028af4: 6978         	ldr	r0, [r7, #0x14]
 8028af6: f7ed fcb1    	bl	0x801645c <ready_thread> @ imm = #-0x1269e
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 8028afa: 6878         	ldr	r0, [r7, #0x4]
 8028afc: f7ff fdb8    	bl	0x8028670 <z_waitq_head> @ imm = #-0x490
 8028b00: 6178         	str	r0, [r7, #0x14]
 8028b02: 697b         	ldr	r3, [r7, #0x14]
 8028b04: 2b00         	cmp	r3, #0x0
 8028b06: d1e6         	bne	0x8028ad6 <unpend_all+0x12> @ imm = #-0x34
; }
 8028b08: bf00         	nop
 8028b0a: bf00         	nop
 8028b0c: 3718         	adds	r7, #0x18
 8028b0e: 46bd         	mov	sp, r7
 8028b10: bd80         	pop	{r7, pc}

08028b12 <thread_is_preemptible>:
; {
 8028b12: b480         	push	{r7}
 8028b14: b083         	sub	sp, #0xc
 8028b16: af00         	add	r7, sp, #0x0
 8028b18: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 8028b1a: 687b         	ldr	r3, [r7, #0x4]
 8028b1c: 89db         	ldrh	r3, [r3, #0xe]
 8028b1e: 2b7f         	cmp	r3, #0x7f
 8028b20: bf94         	ite	ls
 8028b22: 2301         	movls	r3, #0x1
 8028b24: 2300         	movhi	r3, #0x0
 8028b26: b2db         	uxtb	r3, r3
; }
 8028b28: 4618         	mov	r0, r3
 8028b2a: 370c         	adds	r7, #0xc
 8028b2c: 46bd         	mov	sp, r7
 8028b2e: f85d 7b04    	ldr	r7, [sp], #4
 8028b32: 4770         	bx	lr

08028b34 <z_is_thread_prevented_from_running>:
; {
 8028b34: b480         	push	{r7}
 8028b36: b085         	sub	sp, #0x14
 8028b38: af00         	add	r7, sp, #0x0
 8028b3a: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 8028b3c: 687b         	ldr	r3, [r7, #0x4]
 8028b3e: 7b5b         	ldrb	r3, [r3, #0xd]
 8028b40: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 8028b42: 7bfb         	ldrb	r3, [r7, #0xf]
 8028b44: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 8028b48: 2b00         	cmp	r3, #0x0
 8028b4a: bf14         	ite	ne
 8028b4c: 2301         	movne	r3, #0x1
 8028b4e: 2300         	moveq	r3, #0x0
 8028b50: b2db         	uxtb	r3, r3
; }
 8028b52: 4618         	mov	r0, r3
 8028b54: 3714         	adds	r7, #0x14
 8028b56: 46bd         	mov	sp, r7
 8028b58: f85d 7b04    	ldr	r7, [sp], #4
 8028b5c: 4770         	bx	lr

08028b5e <z_is_prio1_higher_than_prio2>:
; {
 8028b5e: b480         	push	{r7}
 8028b60: b083         	sub	sp, #0xc
 8028b62: af00         	add	r7, sp, #0x0
 8028b64: 6078         	str	r0, [r7, #0x4]
 8028b66: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 8028b68: 687a         	ldr	r2, [r7, #0x4]
 8028b6a: 683b         	ldr	r3, [r7]
 8028b6c: 429a         	cmp	r2, r3
 8028b6e: bfb4         	ite	lt
 8028b70: 2301         	movlt	r3, #0x1
 8028b72: 2300         	movge	r3, #0x0
 8028b74: b2db         	uxtb	r3, r3
; }
 8028b76: 4618         	mov	r0, r3
 8028b78: 370c         	adds	r7, #0xc
 8028b7a: 46bd         	mov	sp, r7
 8028b7c: f85d 7b04    	ldr	r7, [sp], #4
 8028b80: 4770         	bx	lr

08028b82 <z_is_prio_higher>:
; {
 8028b82: b580         	push	{r7, lr}
 8028b84: b082         	sub	sp, #0x8
 8028b86: af00         	add	r7, sp, #0x0
 8028b88: 6078         	str	r0, [r7, #0x4]
 8028b8a: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 8028b8c: 6839         	ldr	r1, [r7]
 8028b8e: 6878         	ldr	r0, [r7, #0x4]
 8028b90: f7ff ffe5    	bl	0x8028b5e <z_is_prio1_higher_than_prio2> @ imm = #-0x36
 8028b94: 4603         	mov	r3, r0
; }
 8028b96: 4618         	mov	r0, r3
 8028b98: 3708         	adds	r7, #0x8
 8028b9a: 46bd         	mov	sp, r7
 8028b9c: bd80         	pop	{r7, pc}

08028b9e <sys_dnode_init>:
; {
 8028b9e: b480         	push	{r7}
 8028ba0: b083         	sub	sp, #0xc
 8028ba2: af00         	add	r7, sp, #0x0
 8028ba4: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8028ba6: 687b         	ldr	r3, [r7, #0x4]
 8028ba8: 2200         	movs	r2, #0x0
 8028baa: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8028bac: 687b         	ldr	r3, [r7, #0x4]
 8028bae: 2200         	movs	r2, #0x0
 8028bb0: 605a         	str	r2, [r3, #0x4]
; }
 8028bb2: bf00         	nop
 8028bb4: 370c         	adds	r7, #0xc
 8028bb6: 46bd         	mov	sp, r7
 8028bb8: f85d 7b04    	ldr	r7, [sp], #4
 8028bbc: 4770         	bx	lr

08028bbe <sys_dnode_is_linked>:
; {
 8028bbe: b480         	push	{r7}
 8028bc0: b083         	sub	sp, #0xc
 8028bc2: af00         	add	r7, sp, #0x0
 8028bc4: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 8028bc6: 687b         	ldr	r3, [r7, #0x4]
 8028bc8: 681b         	ldr	r3, [r3]
 8028bca: 2b00         	cmp	r3, #0x0
 8028bcc: bf14         	ite	ne
 8028bce: 2301         	movne	r3, #0x1
 8028bd0: 2300         	moveq	r3, #0x0
 8028bd2: b2db         	uxtb	r3, r3
; }
 8028bd4: 4618         	mov	r0, r3
 8028bd6: 370c         	adds	r7, #0xc
 8028bd8: 46bd         	mov	sp, r7
 8028bda: f85d 7b04    	ldr	r7, [sp], #4
 8028bde: 4770         	bx	lr

08028be0 <sys_dlist_is_empty>:
; {
 8028be0: b480         	push	{r7}
 8028be2: b083         	sub	sp, #0xc
 8028be4: af00         	add	r7, sp, #0x0
 8028be6: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8028be8: 687b         	ldr	r3, [r7, #0x4]
 8028bea: 681b         	ldr	r3, [r3]
 8028bec: 687a         	ldr	r2, [r7, #0x4]
 8028bee: 429a         	cmp	r2, r3
 8028bf0: bf0c         	ite	eq
 8028bf2: 2301         	moveq	r3, #0x1
 8028bf4: 2300         	movne	r3, #0x0
 8028bf6: b2db         	uxtb	r3, r3
; }
 8028bf8: 4618         	mov	r0, r3
 8028bfa: 370c         	adds	r7, #0xc
 8028bfc: 46bd         	mov	sp, r7
 8028bfe: f85d 7b04    	ldr	r7, [sp], #4
 8028c02: 4770         	bx	lr

08028c04 <sys_dlist_peek_head>:
; {
 8028c04: b580         	push	{r7, lr}
 8028c06: b082         	sub	sp, #0x8
 8028c08: af00         	add	r7, sp, #0x0
 8028c0a: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8028c0c: 6878         	ldr	r0, [r7, #0x4]
 8028c0e: f7ff ffe7    	bl	0x8028be0 <sys_dlist_is_empty> @ imm = #-0x32
 8028c12: 4603         	mov	r3, r0
 8028c14: 2b00         	cmp	r3, #0x0
 8028c16: d102         	bne	0x8028c1e <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8028c18: 687b         	ldr	r3, [r7, #0x4]
 8028c1a: 681b         	ldr	r3, [r3]
 8028c1c: e000         	b	0x8028c20 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8028c1e: 2300         	movs	r3, #0x0
; }
 8028c20: 4618         	mov	r0, r3
 8028c22: 3708         	adds	r7, #0x8
 8028c24: 46bd         	mov	sp, r7
 8028c26: bd80         	pop	{r7, pc}

08028c28 <sys_dlist_peek_next_no_check>:
; {
 8028c28: b480         	push	{r7}
 8028c2a: b083         	sub	sp, #0xc
 8028c2c: af00         	add	r7, sp, #0x0
 8028c2e: 6078         	str	r0, [r7, #0x4]
 8028c30: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 8028c32: 687b         	ldr	r3, [r7, #0x4]
 8028c34: 685b         	ldr	r3, [r3, #0x4]
 8028c36: 683a         	ldr	r2, [r7]
 8028c38: 429a         	cmp	r2, r3
 8028c3a: d002         	beq	0x8028c42 <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 8028c3c: 683b         	ldr	r3, [r7]
 8028c3e: 681b         	ldr	r3, [r3]
 8028c40: e000         	b	0x8028c44 <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 8028c42: 2300         	movs	r3, #0x0
; }
 8028c44: 4618         	mov	r0, r3
 8028c46: 370c         	adds	r7, #0xc
 8028c48: 46bd         	mov	sp, r7
 8028c4a: f85d 7b04    	ldr	r7, [sp], #4
 8028c4e: 4770         	bx	lr

08028c50 <sys_dlist_peek_next>:
; {
 8028c50: b580         	push	{r7, lr}
 8028c52: b082         	sub	sp, #0x8
 8028c54: af00         	add	r7, sp, #0x0
 8028c56: 6078         	str	r0, [r7, #0x4]
 8028c58: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 8028c5a: 683b         	ldr	r3, [r7]
 8028c5c: 2b00         	cmp	r3, #0x0
 8028c5e: d005         	beq	0x8028c6c <sys_dlist_peek_next+0x1c> @ imm = #0xa
 8028c60: 6839         	ldr	r1, [r7]
 8028c62: 6878         	ldr	r0, [r7, #0x4]
 8028c64: f7ff ffe0    	bl	0x8028c28 <sys_dlist_peek_next_no_check> @ imm = #-0x40
 8028c68: 4603         	mov	r3, r0
 8028c6a: e000         	b	0x8028c6e <sys_dlist_peek_next+0x1e> @ imm = #0x0
 8028c6c: 2300         	movs	r3, #0x0
; }
 8028c6e: 4618         	mov	r0, r3
 8028c70: 3708         	adds	r7, #0x8
 8028c72: 46bd         	mov	sp, r7
 8028c74: bd80         	pop	{r7, pc}

08028c76 <sys_dlist_append>:
; {
 8028c76: b480         	push	{r7}
 8028c78: b085         	sub	sp, #0x14
 8028c7a: af00         	add	r7, sp, #0x0
 8028c7c: 6078         	str	r0, [r7, #0x4]
 8028c7e: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 8028c80: 687b         	ldr	r3, [r7, #0x4]
 8028c82: 685b         	ldr	r3, [r3, #0x4]
 8028c84: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 8028c86: 683b         	ldr	r3, [r7]
 8028c88: 687a         	ldr	r2, [r7, #0x4]
 8028c8a: 601a         	str	r2, [r3]
; 	node->prev = tail;
 8028c8c: 683b         	ldr	r3, [r7]
 8028c8e: 68fa         	ldr	r2, [r7, #0xc]
 8028c90: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 8028c92: 68fb         	ldr	r3, [r7, #0xc]
 8028c94: 683a         	ldr	r2, [r7]
 8028c96: 601a         	str	r2, [r3]
; 	list->tail = node;
 8028c98: 687b         	ldr	r3, [r7, #0x4]
 8028c9a: 683a         	ldr	r2, [r7]
 8028c9c: 605a         	str	r2, [r3, #0x4]
; }
 8028c9e: bf00         	nop
 8028ca0: 3714         	adds	r7, #0x14
 8028ca2: 46bd         	mov	sp, r7
 8028ca4: f85d 7b04    	ldr	r7, [sp], #4
 8028ca8: 4770         	bx	lr

08028caa <sys_dlist_insert>:
; {
 8028caa: b480         	push	{r7}
 8028cac: b085         	sub	sp, #0x14
 8028cae: af00         	add	r7, sp, #0x0
 8028cb0: 6078         	str	r0, [r7, #0x4]
 8028cb2: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 8028cb4: 687b         	ldr	r3, [r7, #0x4]
 8028cb6: 685b         	ldr	r3, [r3, #0x4]
 8028cb8: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 8028cba: 683b         	ldr	r3, [r7]
 8028cbc: 68fa         	ldr	r2, [r7, #0xc]
 8028cbe: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 8028cc0: 683b         	ldr	r3, [r7]
 8028cc2: 687a         	ldr	r2, [r7, #0x4]
 8028cc4: 601a         	str	r2, [r3]
; 	prev->next = node;
 8028cc6: 68fb         	ldr	r3, [r7, #0xc]
 8028cc8: 683a         	ldr	r2, [r7]
 8028cca: 601a         	str	r2, [r3]
; 	successor->prev = node;
 8028ccc: 687b         	ldr	r3, [r7, #0x4]
 8028cce: 683a         	ldr	r2, [r7]
 8028cd0: 605a         	str	r2, [r3, #0x4]
; }
 8028cd2: bf00         	nop
 8028cd4: 3714         	adds	r7, #0x14
 8028cd6: 46bd         	mov	sp, r7
 8028cd8: f85d 7b04    	ldr	r7, [sp], #4
 8028cdc: 4770         	bx	lr

08028cde <sys_dlist_remove>:
; {
 8028cde: b580         	push	{r7, lr}
 8028ce0: b084         	sub	sp, #0x10
 8028ce2: af00         	add	r7, sp, #0x0
 8028ce4: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8028ce6: 687b         	ldr	r3, [r7, #0x4]
 8028ce8: 685b         	ldr	r3, [r3, #0x4]
 8028cea: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8028cec: 687b         	ldr	r3, [r7, #0x4]
 8028cee: 681b         	ldr	r3, [r3]
 8028cf0: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8028cf2: 68fb         	ldr	r3, [r7, #0xc]
 8028cf4: 68ba         	ldr	r2, [r7, #0x8]
 8028cf6: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8028cf8: 68bb         	ldr	r3, [r7, #0x8]
 8028cfa: 68fa         	ldr	r2, [r7, #0xc]
 8028cfc: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8028cfe: 6878         	ldr	r0, [r7, #0x4]
 8028d00: f7ff ff4d    	bl	0x8028b9e <sys_dnode_init> @ imm = #-0x166
; }
 8028d04: bf00         	nop
 8028d06: 3710         	adds	r7, #0x10
 8028d08: 46bd         	mov	sp, r7
 8028d0a: bd80         	pop	{r7, pc}

08028d0c <remove_timeout>:
; {
 8028d0c: b5f0         	push	{r4, r5, r6, r7, lr}
 8028d0e: b083         	sub	sp, #0xc
 8028d10: af00         	add	r7, sp, #0x0
 8028d12: 6078         	str	r0, [r7, #0x4]
; 	if (next(t) != NULL) {
 8028d14: 6878         	ldr	r0, [r7, #0x4]
 8028d16: f7ef f99d    	bl	0x8018054 <next>        @ imm = #-0x10cc6
 8028d1a: 4603         	mov	r3, r0
 8028d1c: 2b00         	cmp	r3, #0x0
 8028d1e: d00d         	beq	0x8028d3c <remove_timeout+0x30> @ imm = #0x1a
; 		next(t)->dticks += t->dticks;
 8028d20: 6878         	ldr	r0, [r7, #0x4]
 8028d22: f7ef f997    	bl	0x8018054 <next>        @ imm = #-0x10cd2
 8028d26: 4606         	mov	r6, r0
 8028d28: e9d6 0104    	ldrd	r0, r1, [r6, #16]
 8028d2c: 687b         	ldr	r3, [r7, #0x4]
 8028d2e: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8028d32: 1884         	adds	r4, r0, r2
 8028d34: eb41 0503    	adc.w	r5, r1, r3
 8028d38: e9c6 4504    	strd	r4, r5, [r6, #16]
; 	sys_dlist_remove(&t->node);
 8028d3c: 687b         	ldr	r3, [r7, #0x4]
 8028d3e: 4618         	mov	r0, r3
 8028d40: f7ff ffcd    	bl	0x8028cde <sys_dlist_remove> @ imm = #-0x66
; }
 8028d44: bf00         	nop
 8028d46: 370c         	adds	r7, #0xc
 8028d48: 46bd         	mov	sp, r7
 8028d4a: bdf0         	pop	{r4, r5, r6, r7, pc}

08028d4c <next_timeout>:
; {
 8028d4c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8028d50: b086         	sub	sp, #0x18
 8028d52: af00         	add	r7, sp, #0x0
; 	struct _timeout *to = first();
 8028d54: f7ef f970    	bl	0x8018038 <first>       @ imm = #-0x10d20
 8028d58: 6138         	str	r0, [r7, #0x10]
; 	int32_t ticks_elapsed = elapsed();
 8028d5a: f7ef f98d    	bl	0x8018078 <elapsed>     @ imm = #-0x10ce6
 8028d5e: 60f8         	str	r0, [r7, #0xc]
; 	if ((to == NULL) ||
 8028d60: 693b         	ldr	r3, [r7, #0x10]
 8028d62: 2b00         	cmp	r3, #0x0
 8028d64: d00f         	beq	0x8028d86 <next_timeout+0x3a> @ imm = #0x1e
; 	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 8028d66: 693b         	ldr	r3, [r7, #0x10]
 8028d68: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8028d6c: 68f9         	ldr	r1, [r7, #0xc]
 8028d6e: 17c8         	asrs	r0, r1, #0x1f
 8028d70: 468a         	mov	r10, r1
 8028d72: 4683         	mov	r11, r0
 8028d74: ebb2 040a    	subs.w	r4, r2, r10
 8028d78: eb63 050b    	sbc.w	r5, r3, r11
; 	if ((to == NULL) ||
 8028d7c: f1b4 4f00    	cmp.w	r4, #0x80000000
 8028d80: f175 0300    	sbcs	r3, r5, #0x0
 8028d84: db03         	blt	0x8028d8e <next_timeout+0x42> @ imm = #0x6
; 		ret = MAX_WAIT;
 8028d86: f06f 4300    	mvn	r3, #0x80000000
 8028d8a: 617b         	str	r3, [r7, #0x14]
 8028d8c: e016         	b	0x8028dbc <next_timeout+0x70> @ imm = #0x2c
; 		ret = MAX(0, to->dticks - ticks_elapsed);
 8028d8e: 693b         	ldr	r3, [r7, #0x10]
 8028d90: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8028d94: 68f9         	ldr	r1, [r7, #0xc]
 8028d96: 17c8         	asrs	r0, r1, #0x1f
 8028d98: 4688         	mov	r8, r1
 8028d9a: 4681         	mov	r9, r0
 8028d9c: ebb2 0108    	subs.w	r1, r2, r8
 8028da0: 6039         	str	r1, [r7]
 8028da2: eb63 0309    	sbc.w	r3, r3, r9
 8028da6: 607b         	str	r3, [r7, #0x4]
 8028da8: e9d7 2300    	ldrd	r2, r3, [r7]
 8028dac: 2b00         	cmp	r3, #0x0
 8028dae: da03         	bge	0x8028db8 <next_timeout+0x6c> @ imm = #0x6
 8028db0: f04f 0200    	mov.w	r2, #0x0
 8028db4: f04f 0300    	mov.w	r3, #0x0
 8028db8: 4613         	mov	r3, r2
 8028dba: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 8028dbc: 697b         	ldr	r3, [r7, #0x14]
; }
 8028dbe: 4618         	mov	r0, r3
 8028dc0: 3718         	adds	r7, #0x18
 8028dc2: 46bd         	mov	sp, r7
 8028dc4: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08028dc8 <sys_clock_tick_get_32>:
; {
 8028dc8: b580         	push	{r7, lr}
 8028dca: af00         	add	r7, sp, #0x0
; 	return (uint32_t)sys_clock_tick_get();
 8028dcc: f7ef fb98    	bl	0x8018500 <sys_clock_tick_get> @ imm = #-0x108d0
 8028dd0: 4602         	mov	r2, r0
 8028dd2: 460b         	mov	r3, r1
 8028dd4: 4613         	mov	r3, r2
; }
 8028dd6: 4618         	mov	r0, r3
 8028dd8: bd80         	pop	{r7, pc}

08028dda <z_impl_k_uptime_ticks>:
; {
 8028dda: b580         	push	{r7, lr}
 8028ddc: af00         	add	r7, sp, #0x0
; 	return sys_clock_tick_get();
 8028dde: f7ef fb8f    	bl	0x8018500 <sys_clock_tick_get> @ imm = #-0x108e2
 8028de2: 4602         	mov	r2, r0
 8028de4: 460b         	mov	r3, r1
; }
 8028de6: 4610         	mov	r0, r2
 8028de8: 4619         	mov	r1, r3
 8028dea: bd80         	pop	{r7, pc}

08028dec <sys_timepoint_calc>:
; {
 8028dec: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8028df0: b088         	sub	sp, #0x20
 8028df2: af00         	add	r7, sp, #0x0
 8028df4: 60f8         	str	r0, [r7, #0xc]
 8028df6: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8028dfa: e9d7 2300    	ldrd	r2, r3, [r7]
 8028dfe: f04f 30ff    	mov.w	r0, #0xffffffff
 8028e02: f04f 31ff    	mov.w	r1, #0xffffffff
 8028e06: 428b         	cmp	r3, r1
 8028e08: bf08         	it	eq
 8028e0a: 4282         	cmpeq	r2, r0
 8028e0c: d106         	bne	0x8028e1c <sys_timepoint_calc+0x30> @ imm = #0xc
; 		timepoint.tick = UINT64_MAX;
 8028e0e: f04f 32ff    	mov.w	r2, #0xffffffff
 8028e12: f04f 33ff    	mov.w	r3, #0xffffffff
 8028e16: e9c7 2304    	strd	r2, r3, [r7, #16]
 8028e1a: e042         	b	0x8028ea2 <sys_timepoint_calc+0xb6> @ imm = #0x84
; 	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 8028e1c: e9d7 2300    	ldrd	r2, r3, [r7]
 8028e20: f04f 0000    	mov.w	r0, #0x0
 8028e24: f04f 0100    	mov.w	r1, #0x0
 8028e28: 428b         	cmp	r3, r1
 8028e2a: bf08         	it	eq
 8028e2c: 4282         	cmpeq	r2, r0
 8028e2e: d106         	bne	0x8028e3e <sys_timepoint_calc+0x52> @ imm = #0xc
; 		timepoint.tick = 0;
 8028e30: f04f 0200    	mov.w	r2, #0x0
 8028e34: f04f 0300    	mov.w	r3, #0x0
 8028e38: e9c7 2304    	strd	r2, r3, [r7, #16]
 8028e3c: e031         	b	0x8028ea2 <sys_timepoint_calc+0xb6> @ imm = #0x62
; 		k_ticks_t dt = timeout.ticks;
 8028e3e: e9d7 2300    	ldrd	r2, r3, [r7]
 8028e42: e9c7 2306    	strd	r2, r3, [r7, #24]
; 		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
 8028e46: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8028e4a: f06f 0001    	mvn	r0, #0x1
 8028e4e: f04f 31ff    	mov.w	r1, #0xffffffff
 8028e52: 1a84         	subs	r4, r0, r2
 8028e54: eb61 0503    	sbc.w	r5, r1, r3
 8028e58: 2d00         	cmp	r5, #0x0
 8028e5a: db0e         	blt	0x8028e7a <sys_timepoint_calc+0x8e> @ imm = #0x1c
; 			timepoint.tick = Z_TICK_ABS(dt);
 8028e5c: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8028e60: f06f 0001    	mvn	r0, #0x1
 8028e64: f04f 31ff    	mov.w	r1, #0xffffffff
 8028e68: ebb0 0a02    	subs.w	r10, r0, r2
 8028e6c: eb61 0b03    	sbc.w	r11, r1, r3
 8028e70: 4652         	mov	r2, r10
 8028e72: 465b         	mov	r3, r11
 8028e74: e9c7 2304    	strd	r2, r3, [r7, #16]
 8028e78: e013         	b	0x8028ea2 <sys_timepoint_calc+0xb6> @ imm = #0x26
; 			timepoint.tick = sys_clock_tick_get() + MAX(1, dt);
 8028e7a: f7ef fb41    	bl	0x8018500 <sys_clock_tick_get> @ imm = #-0x1097e
 8028e7e: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8028e82: 2a01         	cmp	r2, #0x1
 8028e84: f173 0400    	sbcs	r4, r3, #0x0
 8028e88: da03         	bge	0x8028e92 <sys_timepoint_calc+0xa6> @ imm = #0x6
 8028e8a: f04f 0201    	mov.w	r2, #0x1
 8028e8e: f04f 0300    	mov.w	r3, #0x0
 8028e92: eb10 0802    	adds.w	r8, r0, r2
 8028e96: eb41 0903    	adc.w	r9, r1, r3
 8028e9a: 4642         	mov	r2, r8
 8028e9c: 464b         	mov	r3, r9
 8028e9e: e9c7 2304    	strd	r2, r3, [r7, #16]
; 	return timepoint;
 8028ea2: 68f9         	ldr	r1, [r7, #0xc]
 8028ea4: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8028ea8: e9c1 2300    	strd	r2, r3, [r1]
; }
 8028eac: 68f8         	ldr	r0, [r7, #0xc]
 8028eae: 3720         	adds	r7, #0x20
 8028eb0: 46bd         	mov	sp, r7
 8028eb2: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08028eb6 <sys_timepoint_timeout>:
; {
 8028eb6: b5b0         	push	{r4, r5, r7, lr}
 8028eb8: b088         	sub	sp, #0x20
 8028eba: af00         	add	r7, sp, #0x0
 8028ebc: 60f8         	str	r0, [r7, #0xc]
 8028ebe: e9c7 2300    	strd	r2, r3, [r7]
; 	if (timepoint.tick == UINT64_MAX) {
 8028ec2: e9d7 2300    	ldrd	r2, r3, [r7]
 8028ec6: f1b3 3fff    	cmp.w	r3, #0xffffffff
 8028eca: bf08         	it	eq
 8028ecc: f1b2 3fff    	cmpeq.w	r2, #0xffffffff
 8028ed0: d107         	bne	0x8028ee2 <sys_timepoint_timeout+0x2c> @ imm = #0xe
; 		return K_FOREVER;
 8028ed2: 68f9         	ldr	r1, [r7, #0xc]
 8028ed4: f04f 32ff    	mov.w	r2, #0xffffffff
 8028ed8: f04f 33ff    	mov.w	r3, #0xffffffff
 8028edc: e9c1 2300    	strd	r2, r3, [r1]
 8028ee0: e02c         	b	0x8028f3c <sys_timepoint_timeout+0x86> @ imm = #0x58
; 	if (timepoint.tick == 0) {
 8028ee2: e9d7 2300    	ldrd	r2, r3, [r7]
 8028ee6: 4313         	orrs	r3, r2
 8028ee8: d107         	bne	0x8028efa <sys_timepoint_timeout+0x44> @ imm = #0xe
; 		return K_NO_WAIT;
 8028eea: 68f9         	ldr	r1, [r7, #0xc]
 8028eec: f04f 0200    	mov.w	r2, #0x0
 8028ef0: f04f 0300    	mov.w	r3, #0x0
 8028ef4: e9c1 2300    	strd	r2, r3, [r1]
 8028ef8: e020         	b	0x8028f3c <sys_timepoint_timeout+0x86> @ imm = #0x40
; 	now = sys_clock_tick_get();
 8028efa: f7ef fb01    	bl	0x8018500 <sys_clock_tick_get> @ imm = #-0x109fe
 8028efe: 4602         	mov	r2, r0
 8028f00: 460b         	mov	r3, r1
 8028f02: e9c7 2306    	strd	r2, r3, [r7, #24]
; 	remaining = (timepoint.tick > now) ? (timepoint.tick - now) : 0;
 8028f06: e9d7 2300    	ldrd	r2, r3, [r7]
 8028f0a: e9d7 0106    	ldrd	r0, r1, [r7, #24]
 8028f0e: 4290         	cmp	r0, r2
 8028f10: eb71 0303    	sbcs.w	r3, r1, r3
 8028f14: d207         	bhs	0x8028f26 <sys_timepoint_timeout+0x70> @ imm = #0xe
 8028f16: e9d7 0100    	ldrd	r0, r1, [r7]
 8028f1a: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8028f1e: 1a84         	subs	r4, r0, r2
 8028f20: eb61 0503    	sbc.w	r5, r1, r3
 8028f24: e003         	b	0x8028f2e <sys_timepoint_timeout+0x78> @ imm = #0x6
 8028f26: f04f 0400    	mov.w	r4, #0x0
 8028f2a: f04f 0500    	mov.w	r5, #0x0
 8028f2e: e9c7 4504    	strd	r4, r5, [r7, #16]
; 	return K_TICKS(remaining);
 8028f32: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8028f36: 68f9         	ldr	r1, [r7, #0xc]
 8028f38: e9c1 2300    	strd	r2, r3, [r1]
; }
 8028f3c: 68f8         	ldr	r0, [r7, #0xc]
 8028f3e: 3720         	adds	r7, #0x20
 8028f40: 46bd         	mov	sp, r7
 8028f42: bdb0         	pop	{r4, r5, r7, pc}

08028f44 <arch_k_cycle_get_32>:
; {
 8028f44: b580         	push	{r7, lr}
 8028f46: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 8028f48: f7e8 fc7c    	bl	0x8011844 <sys_clock_cycle_get_32> @ imm = #-0x17708
 8028f4c: 4603         	mov	r3, r0
; }
 8028f4e: 4618         	mov	r0, r3
 8028f50: bd80         	pop	{r7, pc}

08028f52 <k_cycle_get_32>:
; {
 8028f52: b580         	push	{r7, lr}
 8028f54: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 8028f56: f7ff fff5    	bl	0x8028f44 <arch_k_cycle_get_32> @ imm = #-0x16
 8028f5a: 4603         	mov	r3, r0
; }
 8028f5c: 4618         	mov	r0, r3
 8028f5e: bd80         	pop	{r7, pc}

08028f60 <usage_now>:
; {
 8028f60: b580         	push	{r7, lr}
 8028f62: b082         	sub	sp, #0x8
 8028f64: af00         	add	r7, sp, #0x0
; 	now = k_cycle_get_32();
 8028f66: f7ff fff4    	bl	0x8028f52 <k_cycle_get_32> @ imm = #-0x18
 8028f6a: 6078         	str	r0, [r7, #0x4]
; 	return (now == 0) ? 1 : now;
 8028f6c: 687b         	ldr	r3, [r7, #0x4]
 8028f6e: 2b00         	cmp	r3, #0x0
 8028f70: d001         	beq	0x8028f76 <usage_now+0x16> @ imm = #0x2
 8028f72: 687b         	ldr	r3, [r7, #0x4]
 8028f74: e000         	b	0x8028f78 <usage_now+0x18> @ imm = #0x0
 8028f76: 2301         	movs	r3, #0x1
; }
 8028f78: 4618         	mov	r0, r3
 8028f7a: 3708         	adds	r7, #0x8
 8028f7c: 46bd         	mov	sp, r7
 8028f7e: bd80         	pop	{r7, pc}

08028f80 <sched_cpu_update_usage>:
; {
 8028f80: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 8028f84: b083         	sub	sp, #0xc
 8028f86: af00         	add	r7, sp, #0x0
 8028f88: 6078         	str	r0, [r7, #0x4]
 8028f8a: 6039         	str	r1, [r7]
; 	if (!cpu->usage->track_usage) {
 8028f8c: 687b         	ldr	r3, [r7, #0x4]
 8028f8e: 69db         	ldr	r3, [r3, #0x1c]
 8028f90: 7a1b         	ldrb	r3, [r3, #0x8]
 8028f92: f083 0301    	eor	r3, r3, #0x1
 8028f96: b2db         	uxtb	r3, r3
 8028f98: 2b00         	cmp	r3, #0x0
 8028f9a: d116         	bne	0x8028fca <sched_cpu_update_usage+0x4a> @ imm = #0x2c
; 	if (cpu->current != cpu->idle_thread) {
 8028f9c: 687b         	ldr	r3, [r7, #0x4]
 8028f9e: 689a         	ldr	r2, [r3, #0x8]
 8028fa0: 687b         	ldr	r3, [r7, #0x4]
 8028fa2: 68db         	ldr	r3, [r3, #0xc]
 8028fa4: 429a         	cmp	r2, r3
 8028fa6: d011         	beq	0x8028fcc <sched_cpu_update_usage+0x4c> @ imm = #0x22
; 		cpu->usage->total += cycles;
 8028fa8: 687b         	ldr	r3, [r7, #0x4]
 8028faa: 69db         	ldr	r3, [r3, #0x1c]
 8028fac: e9d3 2300    	ldrd	r2, r3, [r3]
 8028fb0: 6839         	ldr	r1, [r7]
 8028fb2: 2000         	movs	r0, #0x0
 8028fb4: 460c         	mov	r4, r1
 8028fb6: 4605         	mov	r5, r0
 8028fb8: 6879         	ldr	r1, [r7, #0x4]
 8028fba: 69c9         	ldr	r1, [r1, #0x1c]
 8028fbc: eb12 0804    	adds.w	r8, r2, r4
 8028fc0: eb43 0905    	adc.w	r9, r3, r5
 8028fc4: e9c1 8900    	strd	r8, r9, [r1]
 8028fc8: e000         	b	0x8028fcc <sched_cpu_update_usage+0x4c> @ imm = #0x0
; 		return;
 8028fca: bf00         	nop
; }
 8028fcc: 370c         	adds	r7, #0xc
 8028fce: 46bd         	mov	sp, r7
 8028fd0: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 8028fd4: 4770         	bx	lr

08028fd6 <sched_thread_update_usage>:
; {
 8028fd6: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 8028fda: b083         	sub	sp, #0xc
 8028fdc: af00         	add	r7, sp, #0x0
 8028fde: 6078         	str	r0, [r7, #0x4]
 8028fe0: 6039         	str	r1, [r7]
; 	thread->base.usage.total += cycles;
 8028fe2: 687b         	ldr	r3, [r7, #0x4]
 8028fe4: e9d3 230c    	ldrd	r2, r3, [r3, #48]
 8028fe8: 6839         	ldr	r1, [r7]
 8028fea: 2000         	movs	r0, #0x0
 8028fec: 460c         	mov	r4, r1
 8028fee: 4605         	mov	r5, r0
 8028ff0: eb12 0804    	adds.w	r8, r2, r4
 8028ff4: eb43 0905    	adc.w	r9, r3, r5
 8028ff8: 687b         	ldr	r3, [r7, #0x4]
 8028ffa: e9c3 890c    	strd	r8, r9, [r3, #48]
; }
 8028ffe: bf00         	nop
 8029000: 370c         	adds	r7, #0xc
 8029002: 46bd         	mov	sp, r7
 8029004: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 8029008: 4770         	bx	lr

0802900a <size_add_overflow>:
; {
 802900a: b480         	push	{r7}
 802900c: b085         	sub	sp, #0x14
 802900e: af00         	add	r7, sp, #0x0
 8029010: 60f8         	str	r0, [r7, #0xc]
 8029012: 60b9         	str	r1, [r7, #0x8]
 8029014: 607a         	str	r2, [r7, #0x4]
; 	return __builtin_add_overflow(a, b, result);
 8029016: 2100         	movs	r1, #0x0
 8029018: 68fb         	ldr	r3, [r7, #0xc]
 802901a: 68ba         	ldr	r2, [r7, #0x8]
 802901c: 189b         	adds	r3, r3, r2
 802901e: d300         	blo	0x8029022 <size_add_overflow+0x18> @ imm = #0x0
 8029020: 2101         	movs	r1, #0x1
 8029022: 461a         	mov	r2, r3
 8029024: 687b         	ldr	r3, [r7, #0x4]
 8029026: 601a         	str	r2, [r3]
 8029028: 460b         	mov	r3, r1
 802902a: f003 0301    	and	r3, r3, #0x1
 802902e: b2db         	uxtb	r3, r3
; }
 8029030: 4618         	mov	r0, r3
 8029032: 3714         	adds	r7, #0x14
 8029034: 46bd         	mov	sp, r7
 8029036: f85d 7b04    	ldr	r7, [sp], #4
 802903a: 4770         	bx	lr

0802903c <z_heap_aligned_alloc>:
; {
 802903c: b580         	push	{r7, lr}
 802903e: b08a         	sub	sp, #0x28
 8029040: af02         	add	r7, sp, #0x8
 8029042: 60f8         	str	r0, [r7, #0xc]
 8029044: 60b9         	str	r1, [r7, #0x8]
 8029046: 607a         	str	r2, [r7, #0x4]
; 	if (size_add_overflow(size, sizeof(heap_ref), &size)) {
 8029048: 687b         	ldr	r3, [r7, #0x4]
 802904a: 1d3a         	adds	r2, r7, #0x4
 802904c: 2104         	movs	r1, #0x4
 802904e: 4618         	mov	r0, r3
 8029050: f7ff ffdb    	bl	0x802900a <size_add_overflow> @ imm = #-0x4a
 8029054: 4603         	mov	r3, r0
 8029056: 2b00         	cmp	r3, #0x0
 8029058: d001         	beq	0x802905e <z_heap_aligned_alloc+0x22> @ imm = #0x2
; 		return NULL;
 802905a: 2300         	movs	r3, #0x0
 802905c: e020         	b	0x80290a0 <z_heap_aligned_alloc+0x64> @ imm = #0x40
; 	__align = align | sizeof(heap_ref);
 802905e: 68bb         	ldr	r3, [r7, #0x8]
 8029060: f043 0304    	orr	r3, r3, #0x4
 8029064: 61fb         	str	r3, [r7, #0x1c]
; 	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
 8029066: 687b         	ldr	r3, [r7, #0x4]
 8029068: f04f 0000    	mov.w	r0, #0x0
 802906c: f04f 0100    	mov.w	r1, #0x0
 8029070: e9cd 0100    	strd	r0, r1, [sp]
 8029074: 461a         	mov	r2, r3
 8029076: 69f9         	ldr	r1, [r7, #0x1c]
 8029078: 68f8         	ldr	r0, [r7, #0xc]
 802907a: f7fd faff    	bl	0x802667c <k_heap_aligned_alloc> @ imm = #-0x2a02
 802907e: 61b8         	str	r0, [r7, #0x18]
; 	if (mem == NULL) {
 8029080: 69bb         	ldr	r3, [r7, #0x18]
 8029082: 2b00         	cmp	r3, #0x0
 8029084: d101         	bne	0x802908a <z_heap_aligned_alloc+0x4e> @ imm = #0x2
; 		return NULL;
 8029086: 2300         	movs	r3, #0x0
 8029088: e00a         	b	0x80290a0 <z_heap_aligned_alloc+0x64> @ imm = #0x14
; 	heap_ref = mem;
 802908a: 69bb         	ldr	r3, [r7, #0x18]
 802908c: 617b         	str	r3, [r7, #0x14]
; 	*heap_ref = heap;
 802908e: 697b         	ldr	r3, [r7, #0x14]
 8029090: 68fa         	ldr	r2, [r7, #0xc]
 8029092: 601a         	str	r2, [r3]
; 	mem = ++heap_ref;
 8029094: 697b         	ldr	r3, [r7, #0x14]
 8029096: 3304         	adds	r3, #0x4
 8029098: 617b         	str	r3, [r7, #0x14]
 802909a: 697b         	ldr	r3, [r7, #0x14]
 802909c: 61bb         	str	r3, [r7, #0x18]
; 	return mem;
 802909e: 69bb         	ldr	r3, [r7, #0x18]
; }
 80290a0: 4618         	mov	r0, r3
 80290a2: 3720         	adds	r7, #0x20
 80290a4: 46bd         	mov	sp, r7
 80290a6: bd80         	pop	{r7, pc}

080290a8 <k_free>:
; {
 80290a8: b580         	push	{r7, lr}
 80290aa: b084         	sub	sp, #0x10
 80290ac: af00         	add	r7, sp, #0x0
 80290ae: 6078         	str	r0, [r7, #0x4]
; 	if (ptr != NULL) {
 80290b0: 687b         	ldr	r3, [r7, #0x4]
 80290b2: 2b00         	cmp	r3, #0x0
 80290b4: d00c         	beq	0x80290d0 <k_free+0x28> @ imm = #0x18
; 		heap_ref = ptr;
 80290b6: 687b         	ldr	r3, [r7, #0x4]
 80290b8: 60fb         	str	r3, [r7, #0xc]
; 		--heap_ref;
 80290ba: 68fb         	ldr	r3, [r7, #0xc]
 80290bc: 3b04         	subs	r3, #0x4
 80290be: 60fb         	str	r3, [r7, #0xc]
; 		ptr = heap_ref;
 80290c0: 68fb         	ldr	r3, [r7, #0xc]
 80290c2: 607b         	str	r3, [r7, #0x4]
; 		k_heap_free(*heap_ref, ptr);
 80290c4: 68fb         	ldr	r3, [r7, #0xc]
 80290c6: 681b         	ldr	r3, [r3]
 80290c8: 6879         	ldr	r1, [r7, #0x4]
 80290ca: 4618         	mov	r0, r3
 80290cc: f7fd fb6c    	bl	0x80267a8 <k_heap_free> @ imm = #-0x2928
; }
 80290d0: bf00         	nop
 80290d2: 3710         	adds	r7, #0x10
 80290d4: 46bd         	mov	sp, r7
 80290d6: bd80         	pop	{r7, pc}

080290d8 <k_malloc>:
; {
 80290d8: b580         	push	{r7, lr}
 80290da: b084         	sub	sp, #0x10
 80290dc: af00         	add	r7, sp, #0x0
 80290de: 6078         	str	r0, [r7, #0x4]
; 	void *ret = k_aligned_alloc(sizeof(void *), size);
 80290e0: 6879         	ldr	r1, [r7, #0x4]
 80290e2: 2004         	movs	r0, #0x4
 80290e4: f7ef fbb2    	bl	0x801884c <k_aligned_alloc> @ imm = #-0x1089c
 80290e8: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 80290ea: 68fb         	ldr	r3, [r7, #0xc]
; }
 80290ec: 4618         	mov	r0, r3
 80290ee: 3710         	adds	r7, #0x10
 80290f0: 46bd         	mov	sp, r7
 80290f2: bd80         	pop	{r7, pc}

080290f4 <memcpy>:
 80290f4: 440a         	add	r2, r1
 80290f6: 4291         	cmp	r1, r2
 80290f8: f100 33ff    	add.w	r3, r0, #0xffffffff
 80290fc: d100         	bne	0x8029100 <memcpy+0xc>  @ imm = #0x0
 80290fe: 4770         	bx	lr
 8029100: b510         	push	{r4, lr}
 8029102: f811 4b01    	ldrb	r4, [r1], #1
 8029106: f803 4f01    	strb	r4, [r3, #1]!
 802910a: 4291         	cmp	r1, r2
 802910c: d1f9         	bne	0x8029102 <memcpy+0xe>  @ imm = #-0xe
 802910e: bd10         	pop	{r4, pc}

08029110 <memset>:
 8029110: 4402         	add	r2, r0
 8029112: 4603         	mov	r3, r0
 8029114: 4293         	cmp	r3, r2
 8029116: d100         	bne	0x802911a <memset+0xa>  @ imm = #0x0
 8029118: 4770         	bx	lr
 802911a: f803 1b01    	strb	r1, [r3], #1
 802911e: e7f9         	b	0x8029114 <memset+0x4>  @ imm = #-0xe

08029120 <strncpy>:
 8029120: b510         	push	{r4, lr}
 8029122: 3901         	subs	r1, #0x1
 8029124: 4604         	mov	r4, r0
 8029126: b132         	cbz	r2, 0x8029136 <strncpy+0x16> @ imm = #0xc
 8029128: f811 3f01    	ldrb	r3, [r1, #1]!
 802912c: f800 3b01    	strb	r3, [r0], #1
 8029130: 3a01         	subs	r2, #0x1
 8029132: 2b00         	cmp	r3, #0x0
 8029134: d1f7         	bne	0x8029126 <strncpy+0x6> @ imm = #-0x12
 8029136: 2100         	movs	r1, #0x0
 8029138: f7ff ffea    	bl	0x8029110 <memset>      @ imm = #-0x2c
 802913c: 4620         	mov	r0, r4
 802913e: bd10         	pop	{r4, pc}

08029140 <strnlen>:
 8029140: b510         	push	{r4, lr}
 8029142: 4602         	mov	r2, r0
 8029144: 4401         	add	r1, r0
 8029146: 428a         	cmp	r2, r1
 8029148: 4613         	mov	r3, r2
 802914a: d003         	beq	0x8029154 <strnlen+0x14> @ imm = #0x6
 802914c: 781c         	ldrb	r4, [r3]
 802914e: 3201         	adds	r2, #0x1
 8029150: 2c00         	cmp	r4, #0x0
 8029152: d1f8         	bne	0x8029146 <strnlen+0x6> @ imm = #-0x10
 8029154: 1a18         	subs	r0, r3, r0
 8029156: bd10         	pop	{r4, pc}

08029158 <__ultoa_invert>:
 8029158: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 802915c: f1c3 0937    	rsb.w	r9, r3, #0x37
 8029160: 4607         	mov	r7, r0
 8029162: 4688         	mov	r8, r1
 8029164: fa5f f989    	uxtb.w	r9, r9
 8029168: f003 051f    	and	r5, r3, #0x1f
 802916c: 4616         	mov	r6, r2
 802916e: f04f 0a00    	mov.w	r10, #0x0
 8029172: 4638         	mov	r0, r7
 8029174: 4641         	mov	r1, r8
 8029176: 462a         	mov	r2, r5
 8029178: 4653         	mov	r3, r10
 802917a: f7d7 f8f9    	bl	0x8000370 <__aeabi_uldivmod> @ imm = #-0x28e0e
 802917e: b2d4         	uxtb	r4, r2
 8029180: 2c09         	cmp	r4, #0x9
 8029182: bf88         	it	hi
 8029184: 444c         	addhi	r4, r9
 8029186: 463a         	mov	r2, r7
 8029188: 4643         	mov	r3, r8
 802918a: bf88         	it	hi
 802918c: b2e4         	uxtbhi	r4, r4
 802918e: 42aa         	cmp	r2, r5
 8029190: f104 0430    	add.w	r4, r4, #0x30
 8029194: eb73 030a    	sbcs.w	r3, r3, r10
 8029198: f806 4b01    	strb	r4, [r6], #1
 802919c: 4607         	mov	r7, r0
 802919e: 4688         	mov	r8, r1
 80291a0: d2e7         	bhs	0x8029172 <__ultoa_invert+0x1a> @ imm = #-0x32
 80291a2: 4630         	mov	r0, r6
 80291a4: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}

080291a8 <mulShiftAll64>:
 80291a8: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80291ac: b089         	sub	sp, #0x24
 80291ae: 1806         	adds	r6, r0, r0
 80291b0: 4699         	mov	r9, r3
 80291b2: ab04         	add	r3, sp, #0x10
 80291b4: eb41 0401    	adc.w	r4, r1, r1
 80291b8: 9300         	str	r3, [sp]
 80291ba: 4615         	mov	r5, r2
 80291bc: 4630         	mov	r0, r6
 80291be: e9d2 2300    	ldrd	r2, r3, [r2]
 80291c2: 4621         	mov	r1, r4
 80291c4: f8dd b04c    	ldr.w	r11, [sp, #0x4c]
 80291c8: f000 f8ab    	bl	0x8029322 <__umul128>   @ imm = #0x156
 80291cc: ab06         	add	r3, sp, #0x18
 80291ce: 9300         	str	r3, [sp]
 80291d0: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 80291d4: 4607         	mov	r7, r0
 80291d6: 4688         	mov	r8, r1
 80291d8: 4630         	mov	r0, r6
 80291da: 4621         	mov	r1, r4
 80291dc: f000 f8a1    	bl	0x8029322 <__umul128>   @ imm = #0x142
 80291e0: e9dd 6304    	ldrd	r6, r3, [sp, #16]
 80291e4: 1984         	adds	r4, r0, r6
 80291e6: eb51 0603    	adcs.w	r6, r1, r3
 80291ea: 9b06         	ldr	r3, [sp, #0x18]
 80291ec: e9d5 0100    	ldrd	r0, r1, [r5]
 80291f0: f04f 0200    	mov.w	r2, #0x0
 80291f4: bf28         	it	hs
 80291f6: 2201         	movhs	r2, #0x1
 80291f8: 18d2         	adds	r2, r2, r3
 80291fa: 9b07         	ldr	r3, [sp, #0x1c]
 80291fc: f143 0300    	adc	r3, r3, #0x0
 8029200: 1838         	adds	r0, r7, r0
 8029202: eb48 0101    	adc.w	r1, r8, r1
 8029206: 42b8         	cmp	r0, r7
 8029208: eb71 0108    	sbcs.w	r1, r1, r8
 802920c: 68e9         	ldr	r1, [r5, #0xc]
 802920e: 9103         	str	r1, [sp, #0xc]
 8029210: 68a9         	ldr	r1, [r5, #0x8]
 8029212: bf34         	ite	lo
 8029214: 2001         	movlo	r0, #0x1
 8029216: 2000         	movhs	r0, #0x0
 8029218: eb14 0c01    	adds.w	r12, r4, r1
 802921c: 9903         	ldr	r1, [sp, #0xc]
 802921e: eb46 0101    	adc.w	r1, r6, r1
 8029222: eb10 000c    	adds.w	r0, r0, r12
 8029226: f141 0100    	adc	r1, r1, #0x0
 802922a: 42a0         	cmp	r0, r4
 802922c: eb71 0c06    	sbcs.w	r12, r1, r6
 8029230: bf34         	ite	lo
 8029232: f04f 0c01    	movlo.w	r12, #0x1
 8029236: f04f 0c00    	movhs.w	r12, #0x0
 802923a: e9cd 2306    	strd	r2, r3, [sp, #24]
 802923e: f1a9 0a41    	sub.w	r10, r9, #0x41
 8029242: eb1c 0202    	adds.w	r2, r12, r2
 8029246: f143 0300    	adc	r3, r3, #0x0
 802924a: f8cd a000    	str.w	r10, [sp]
 802924e: f000 f883    	bl	0x8029358 <__shiftright128> @ imm = #0x106
 8029252: 9b12         	ldr	r3, [sp, #0x48]
 8029254: e9c3 0100    	strd	r0, r1, [r3]
 8029258: 9b14         	ldr	r3, [sp, #0x50]
 802925a: 2b01         	cmp	r3, #0x1
 802925c: e9dd 2306    	ldrd	r2, r3, [sp, #24]
 8029260: d129         	bne	0x80292b6 <mulShiftAll64+0x10e> @ imm = #0x52
 8029262: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 8029266: e9d5 c500    	ldrd	r12, r5, [r5]
 802926a: 1a20         	subs	r0, r4, r0
 802926c: eb66 0101    	sbc.w	r1, r6, r1
 8029270: 4567         	cmp	r7, r12
 8029272: eb78 0505    	sbcs.w	r5, r8, r5
 8029276: bf34         	ite	lo
 8029278: 2501         	movlo	r5, #0x1
 802927a: 2500         	movhs	r5, #0x0
 802927c: 1b40         	subs	r0, r0, r5
 802927e: f161 0100    	sbc	r1, r1, #0x0
 8029282: 4284         	cmp	r4, r0
 8029284: eb76 0501    	sbcs.w	r5, r6, r1
 8029288: bf34         	ite	lo
 802928a: 2501         	movlo	r5, #0x1
 802928c: 2500         	movhs	r5, #0x0
 802928e: 1b52         	subs	r2, r2, r5
 8029290: f8cd a000    	str.w	r10, [sp]
 8029294: f163 0300    	sbc	r3, r3, #0x0
 8029298: f000 f85e    	bl	0x8029358 <__shiftright128> @ imm = #0xbc
 802929c: e9dd 2306    	ldrd	r2, r3, [sp, #24]
 80292a0: e9cb 0100    	strd	r0, r1, [r11]
 80292a4: f8cd a000    	str.w	r10, [sp]
 80292a8: 4620         	mov	r0, r4
 80292aa: 4631         	mov	r1, r6
 80292ac: f000 f854    	bl	0x8029358 <__shiftright128> @ imm = #0xa8
 80292b0: b009         	add	sp, #0x24
 80292b2: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80292b6: eb17 0e07    	adds.w	lr, r7, r7
 80292ba: eb48 0c08    	adc.w	r12, r8, r8
 80292be: 1920         	adds	r0, r4, r4
 80292c0: eb46 0106    	adc.w	r1, r6, r6
 80292c4: 45be         	cmp	lr, r7
 80292c6: eb7c 0808    	sbcs.w	r8, r12, r8
 80292ca: bf34         	ite	lo
 80292cc: 2701         	movlo	r7, #0x1
 80292ce: 2700         	movhs	r7, #0x0
 80292d0: 19c7         	adds	r7, r0, r7
 80292d2: f141 0800    	adc	r8, r1, #0x0
 80292d6: e9d5 0100    	ldrd	r0, r1, [r5]
 80292da: 4586         	cmp	lr, r0
 80292dc: eb7c 0c01    	sbcs.w	r12, r12, r1
 80292e0: e9d5 1502    	ldrd	r1, r5, [r5, #8]
 80292e4: bf34         	ite	lo
 80292e6: 2001         	movlo	r0, #0x1
 80292e8: 2000         	movhs	r0, #0x0
 80292ea: 1a38         	subs	r0, r7, r0
 80292ec: f168 0c00    	sbc	r12, r8, #0x0
 80292f0: 1a40         	subs	r0, r0, r1
 80292f2: eb6c 0105    	sbc.w	r1, r12, r5
 80292f6: 1892         	adds	r2, r2, r2
 80292f8: 415b         	adcs	r3, r3
 80292fa: 42a7         	cmp	r7, r4
 80292fc: eb78 0506    	sbcs.w	r5, r8, r6
 8029300: bf34         	ite	lo
 8029302: 2501         	movlo	r5, #0x1
 8029304: 2500         	movhs	r5, #0x0
 8029306: 1952         	adds	r2, r2, r5
 8029308: f143 0300    	adc	r3, r3, #0x0
 802930c: 4287         	cmp	r7, r0
 802930e: eb78 0801    	sbcs.w	r8, r8, r1
 8029312: bf34         	ite	lo
 8029314: 2501         	movlo	r5, #0x1
 8029316: 2500         	movhs	r5, #0x0
 8029318: 1b52         	subs	r2, r2, r5
 802931a: f1a9 0540    	sub.w	r5, r9, #0x40
 802931e: 9500         	str	r5, [sp]
 8029320: e7b8         	b	0x8029294 <mulShiftAll64+0xec> @ imm = #-0x90

08029322 <__umul128>:
 8029322: b5f0         	push	{r4, r5, r6, r7, lr}
 8029324: 460f         	mov	r7, r1
 8029326: 4604         	mov	r4, r0
 8029328: fba0 0102    	umull	r0, r1, r0, r2
 802932c: fba7 5202    	umull	r5, r2, r7, r2
 8029330: 1949         	adds	r1, r1, r5
 8029332: fba3 4504    	umull	r4, r5, r3, r4
 8029336: f142 0200    	adc	r2, r2, #0x0
 802933a: fba7 7303    	umull	r7, r3, r7, r3
 802933e: 1861         	adds	r1, r4, r1
 8029340: f145 0400    	adc	r4, r5, #0x0
 8029344: 19d2         	adds	r2, r2, r7
 8029346: 9e05         	ldr	r6, [sp, #0x14]
 8029348: f143 0300    	adc	r3, r3, #0x0
 802934c: 1912         	adds	r2, r2, r4
 802934e: f143 0300    	adc	r3, r3, #0x0
 8029352: e9c6 2300    	strd	r2, r3, [r6]
 8029356: bdf0         	pop	{r4, r5, r6, r7, pc}

08029358 <__shiftright128>:
 8029358: b5f0         	push	{r4, r5, r6, r7, lr}
 802935a: 9c05         	ldr	r4, [sp, #0x14]
 802935c: f1c4 0740    	rsb.w	r7, r4, #0x40
 8029360: f1c4 0620    	rsb.w	r6, r4, #0x20
 8029364: fa02 f606    	lsl.w	r6, r2, r6
 8029368: f1a4 0520    	sub.w	r5, r4, #0x20
 802936c: 40bb         	lsls	r3, r7
 802936e: fa22 f505    	lsr.w	r5, r2, r5
 8029372: 4333         	orrs	r3, r6
 8029374: f1c4 0620    	rsb.w	r6, r4, #0x20
 8029378: 432b         	orrs	r3, r5
 802937a: fa01 f606    	lsl.w	r6, r1, r6
 802937e: f1a4 0520    	sub.w	r5, r4, #0x20
 8029382: 40e0         	lsrs	r0, r4
 8029384: fa21 f505    	lsr.w	r5, r1, r5
 8029388: 4330         	orrs	r0, r6
 802938a: 40ba         	lsls	r2, r7
 802938c: 4328         	orrs	r0, r5
 802938e: 40e1         	lsrs	r1, r4
 8029390: 4310         	orrs	r0, r2
 8029392: 4319         	orrs	r1, r3
 8029394: bdf0         	pop	{r4, r5, r6, r7, pc}

08029396 <__dtox_engine>:
 8029396: e92d 43f0    	push.w	{r4, r5, r6, r7, r8, r9, lr}
 802939a: ec57 6b10    	<unknown>
 802939e: 463b         	mov	r3, r7
 80293a0: 4634         	mov	r4, r6
 80293a2: f3c3 550a    	ubfx	r5, r3, #0x14, #0xb
 80293a6: f3c3 0313    	ubfx	r3, r3, #0x0, #0x14
 80293aa: 0ffe         	lsrs	r6, r7, #0x1f
 80293ac: ea54 0c03    	orrs.w	r12, r4, r3
 80293b0: 7106         	strb	r6, [r0, #0x4]
 80293b2: f240 77ff    	movw	r7, #0x7ff
 80293b6: d007         	beq	0x80293c8 <__dtox_engine+0x32> @ imm = #0xe
 80293b8: 42bd         	cmp	r5, r7
 80293ba: d10c         	bne	0x80293d6 <__dtox_engine+0x40> @ imm = #0x18
 80293bc: f046 0608    	orr	r6, r6, #0x8
 80293c0: 7106         	strb	r6, [r0, #0x4]
 80293c2: 2000         	movs	r0, #0x0
 80293c4: e8bd 83f0    	pop.w	{r4, r5, r6, r7, r8, r9, pc}
 80293c8: 2d00         	cmp	r5, #0x0
 80293ca: d063         	beq	0x8029494 <__dtox_engine+0xfe> @ imm = #0xc6
 80293cc: 42bd         	cmp	r5, r7
 80293ce: d15e         	bne	0x802948e <__dtox_engine+0xf8> @ imm = #0xbc
 80293d0: f046 0604    	orr	r6, r6, #0x4
 80293d4: e7f4         	b	0x80293c0 <__dtox_engine+0x2a> @ imm = #-0x18
 80293d6: 2d00         	cmp	r5, #0x0
 80293d8: d159         	bne	0x802948e <__dtox_engine+0xf8> @ imm = #0xb2
 80293da: 2501         	movs	r5, #0x1
 80293dc: f2a5 35ff    	subw	r5, r5, #0x3ff
 80293e0: 2900         	cmp	r1, #0x0
 80293e2: 6005         	str	r5, [r0]
 80293e4: db59         	blt	0x802949a <__dtox_engine+0x104> @ imm = #0xb2
 80293e6: 290c         	cmp	r1, #0xc
 80293e8: dc59         	bgt	0x802949e <__dtox_engine+0x108> @ imm = #0xb2
 80293ea: f1c1 050d    	rsb.w	r5, r1, #0xd
 80293ee: 00ad         	lsls	r5, r5, #0x2
 80293f0: 2601         	movs	r6, #0x1
 80293f2: f105 3eff    	add.w	lr, r5, #0xffffffff
 80293f6: f1a5 0c21    	sub.w	r12, r5, #0x21
 80293fa: f1c5 0721    	rsb.w	r7, r5, #0x21
 80293fe: fa26 f707    	lsr.w	r7, r6, r7
 8029402: fa06 fc0c    	lsl.w	r12, r6, r12
 8029406: fa06 f60e    	lsl.w	r6, r6, lr
 802940a: ea4c 0c07    	orr.w	r12, r12, r7
 802940e: 19b7         	adds	r7, r6, r6
 8029410: eb4c 090c    	adc.w	r9, r12, r12
 8029414: f1d7 0800    	rsbs.w	r8, r7, #0x0
 8029418: eb69 0e49    	sbc.w	lr, r9, r9, lsl #1
 802941c: 3f01         	subs	r7, #0x1
 802941e: f149 39ff    	adc	r9, r9, #0xffffffff
 8029422: 4027         	ands	r7, r4
 8029424: ea09 0903    	and.w	r9, r9, r3
 8029428: 42be         	cmp	r6, r7
 802942a: eb7c 0909    	sbcs.w	r9, r12, r9
 802942e: db0f         	blt	0x8029450 <__dtox_engine+0xba> @ imm = #0x1e
 8029430: f1c5 0920    	rsb.w	r9, r5, #0x20
 8029434: f1b5 0720    	subs.w	r7, r5, #0x20
 8029438: fa03 f909    	lsl.w	r9, r3, r9
 802943c: fa24 f505    	lsr.w	r5, r4, r5
 8029440: ea45 0509    	orr.w	r5, r5, r9
 8029444: bf5c         	itt	pl
 8029446: fa43 f707    	asrpl.w	r7, r3, r7
 802944a: 433d         	orrpl	r5, r7
 802944c: 07ed         	lsls	r5, r5, #0x1f
 802944e: d503         	bpl	0x8029458 <__dtox_engine+0xc2> @ imm = #0x6
 8029450: 19a6         	adds	r6, r4, r6
 8029452: 4634         	mov	r4, r6
 8029454: eb43 030c    	adc.w	r3, r3, r12
 8029458: ea04 0408    	and.w	r4, r4, r8
 802945c: ea03 030e    	and.w	r3, r3, lr
 8029460: f100 0512    	add.w	r5, r0, #0x12
 8029464: 260d         	movs	r6, #0xd
 8029466: 4608         	mov	r0, r1
 8029468: f1c2 0227    	rsb.w	r2, r2, #0x27
 802946c: f04f 0e30    	mov.w	lr, #0x30
 8029470: f004 010f    	and	r1, r4, #0xf
 8029474: 0924         	lsrs	r4, r4, #0x4
 8029476: ea44 7403    	orr.w	r4, r4, r3, lsl #28
 802947a: f106 3cff    	add.w	r12, r6, #0xffffffff
 802947e: 111b         	asrs	r3, r3, #0x4
 8029480: 1e6f         	subs	r7, r5, #0x1
 8029482: b9b1         	cbnz	r1, 0x80294b2 <__dtox_engine+0x11c> @ imm = #0x2c
 8029484: 42b0         	cmp	r0, r6
 8029486: da0c         	bge	0x80294a2 <__dtox_engine+0x10c> @ imm = #0x18
 8029488: 4666         	mov	r6, r12
 802948a: 463d         	mov	r5, r7
 802948c: e7f0         	b	0x8029470 <__dtox_engine+0xda> @ imm = #-0x20
 802948e: f443 1380    	orr	r3, r3, #0x100000
 8029492: e7a3         	b	0x80293dc <__dtox_engine+0x46> @ imm = #-0xba
 8029494: 462c         	mov	r4, r5
 8029496: 462b         	mov	r3, r5
 8029498: e7a2         	b	0x80293e0 <__dtox_engine+0x4a> @ imm = #-0xbc
 802949a: 2100         	movs	r1, #0x0
 802949c: e7e0         	b	0x8029460 <__dtox_engine+0xca> @ imm = #-0x40
 802949e: 210d         	movs	r1, #0xd
 80294a0: e7de         	b	0x8029460 <__dtox_engine+0xca> @ imm = #-0x44
 80294a2: f885 e000    	strb.w	lr, [r5]
 80294a6: f11c 0101    	adds.w	r1, r12, #0x1
 80294aa: 4666         	mov	r6, r12
 80294ac: 463d         	mov	r5, r7
 80294ae: d1df         	bne	0x8029470 <__dtox_engine+0xda> @ imm = #-0x42
 80294b0: e788         	b	0x80293c4 <__dtox_engine+0x2e> @ imm = #-0xf0
 80294b2: 2909         	cmp	r1, #0x9
 80294b4: bfc8         	it	gt
 80294b6: 1889         	addgt	r1, r1, r2
 80294b8: 3130         	adds	r1, #0x30
 80294ba: 42b0         	cmp	r0, r6
 80294bc: 7029         	strb	r1, [r5]
 80294be: bfb8         	it	lt
 80294c0: 4630         	movlt	r0, r6
 80294c2: e7f0         	b	0x80294a6 <__dtox_engine+0x110> @ imm = #-0x20

080294c4 <__file_str_put>:
 80294c4: e9d1 3204    	ldrd	r3, r2, [r1, #16]
 80294c8: 4293         	cmp	r3, r2
 80294ca: bf1e         	ittt	ne
 80294cc: 1c5a         	addne	r2, r3, #0x1
 80294ce: 610a         	strne	r2, [r1, #0x10]
 80294d0: 7018         	strbne	r0, [r3]
 80294d2: 4770         	bx	lr

080294d4 <__aeabi_read_tp>:
; 	ldr r0, =z_arm_tls_ptr
 80294d4: 4801         	ldr	r0, [pc, #0x4]          @ 0x80294dc <__aeabi_read_tp+0x8>
; 	ldr r0, [r0]
 80294d6: 6800         	ldr	r0, [r0]
; 	bx lr
 80294d8: 4770         	bx	lr

080294da <$d>:
 80294da: 00 00        	.short	0x0000

080294dc <$d>:
 80294dc: 58 28 00 24  	.word	0x24002858
