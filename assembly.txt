
build/zephyr/zephyr.elf:	file format elf32-littlearm

Disassembly of section rom_start:

08000000 <_vector_start>:
 8000000: 00 35 00 20  	.word	0x20003500
 8000004: 51 38 00 08  	.word	0x08003851
 8000008: d9 2a 00 08  	.word	0x08002ad9
 800000c: 3d 38 00 08  	.word	0x0800383d
 8000010: 3d 38 00 08  	.word	0x0800383d
 8000014: 3d 38 00 08  	.word	0x0800383d
 8000018: 3d 38 00 08  	.word	0x0800383d
 800001c: 00 00 00 00  	.word	0x00000000
 8000020: 00 00 00 00  	.word	0x00000000
 8000024: 00 00 00 00  	.word	0x00000000
 8000028: 00 00 00 00  	.word	0x00000000
 800002c: ad 39 00 08  	.word	0x080039ad
 8000030: 3d 38 00 08  	.word	0x0800383d
 8000034: 00 00 00 00  	.word	0x00000000
 8000038: 3d 39 00 08  	.word	0x0800393d
 800003c: 51 94 00 08  	.word	0x08009451

08000040 <$d>:
 8000040: f9 3b 00 08  	.word	0x08003bf9
 8000044: f9 3b 00 08  	.word	0x08003bf9
 8000048: f9 3b 00 08  	.word	0x08003bf9
 800004c: f9 3b 00 08  	.word	0x08003bf9
 8000050: f9 3b 00 08  	.word	0x08003bf9
 8000054: f9 3b 00 08  	.word	0x08003bf9
 8000058: f9 3b 00 08  	.word	0x08003bf9
 800005c: f9 3b 00 08  	.word	0x08003bf9
 8000060: f9 3b 00 08  	.word	0x08003bf9
 8000064: f9 3b 00 08  	.word	0x08003bf9
 8000068: f9 3b 00 08  	.word	0x08003bf9
 800006c: f9 3b 00 08  	.word	0x08003bf9
 8000070: f9 3b 00 08  	.word	0x08003bf9
 8000074: f9 3b 00 08  	.word	0x08003bf9
 8000078: f9 3b 00 08  	.word	0x08003bf9
 800007c: f9 3b 00 08  	.word	0x08003bf9
 8000080: f9 3b 00 08  	.word	0x08003bf9
 8000084: f9 3b 00 08  	.word	0x08003bf9
 8000088: f9 3b 00 08  	.word	0x08003bf9
 800008c: f9 3b 00 08  	.word	0x08003bf9
 8000090: f9 3b 00 08  	.word	0x08003bf9
 8000094: f9 3b 00 08  	.word	0x08003bf9
 8000098: f9 3b 00 08  	.word	0x08003bf9
 800009c: f9 3b 00 08  	.word	0x08003bf9
 80000a0: f9 3b 00 08  	.word	0x08003bf9
 80000a4: f9 3b 00 08  	.word	0x08003bf9
 80000a8: f9 3b 00 08  	.word	0x08003bf9
 80000ac: f9 3b 00 08  	.word	0x08003bf9
 80000b0: f9 3b 00 08  	.word	0x08003bf9
 80000b4: f9 3b 00 08  	.word	0x08003bf9
 80000b8: f9 3b 00 08  	.word	0x08003bf9
 80000bc: f9 3b 00 08  	.word	0x08003bf9
 80000c0: f9 3b 00 08  	.word	0x08003bf9
 80000c4: f9 3b 00 08  	.word	0x08003bf9
 80000c8: f9 3b 00 08  	.word	0x08003bf9
 80000cc: f9 3b 00 08  	.word	0x08003bf9
 80000d0: f9 3b 00 08  	.word	0x08003bf9
 80000d4: f9 3b 00 08  	.word	0x08003bf9
 80000d8: f9 3b 00 08  	.word	0x08003bf9
 80000dc: f9 3b 00 08  	.word	0x08003bf9
 80000e0: f9 3b 00 08  	.word	0x08003bf9
 80000e4: f9 3b 00 08  	.word	0x08003bf9
 80000e8: f9 3b 00 08  	.word	0x08003bf9
 80000ec: f9 3b 00 08  	.word	0x08003bf9
 80000f0: f9 3b 00 08  	.word	0x08003bf9
 80000f4: f9 3b 00 08  	.word	0x08003bf9
 80000f8: f9 3b 00 08  	.word	0x08003bf9
 80000fc: f9 3b 00 08  	.word	0x08003bf9
 8000100: f9 3b 00 08  	.word	0x08003bf9
 8000104: f9 3b 00 08  	.word	0x08003bf9
 8000108: f9 3b 00 08  	.word	0x08003bf9
 800010c: f9 3b 00 08  	.word	0x08003bf9
 8000110: f9 3b 00 08  	.word	0x08003bf9
 8000114: f9 3b 00 08  	.word	0x08003bf9
 8000118: f9 3b 00 08  	.word	0x08003bf9
 800011c: f9 3b 00 08  	.word	0x08003bf9
 8000120: f9 3b 00 08  	.word	0x08003bf9
 8000124: f9 3b 00 08  	.word	0x08003bf9
 8000128: f9 3b 00 08  	.word	0x08003bf9
 800012c: f9 3b 00 08  	.word	0x08003bf9
 8000130: f9 3b 00 08  	.word	0x08003bf9
 8000134: f9 3b 00 08  	.word	0x08003bf9
 8000138: f9 3b 00 08  	.word	0x08003bf9
 800013c: f9 3b 00 08  	.word	0x08003bf9
 8000140: f9 3b 00 08  	.word	0x08003bf9
 8000144: f9 3b 00 08  	.word	0x08003bf9
 8000148: f9 3b 00 08  	.word	0x08003bf9
 800014c: f9 3b 00 08  	.word	0x08003bf9
 8000150: f9 3b 00 08  	.word	0x08003bf9
 8000154: f9 3b 00 08  	.word	0x08003bf9
 8000158: f9 3b 00 08  	.word	0x08003bf9
 800015c: f9 3b 00 08  	.word	0x08003bf9
 8000160: f9 3b 00 08  	.word	0x08003bf9
 8000164: f9 3b 00 08  	.word	0x08003bf9
 8000168: f9 3b 00 08  	.word	0x08003bf9
 800016c: f9 3b 00 08  	.word	0x08003bf9
 8000170: f9 3b 00 08  	.word	0x08003bf9
 8000174: f9 3b 00 08  	.word	0x08003bf9
 8000178: f9 3b 00 08  	.word	0x08003bf9
 800017c: f9 3b 00 08  	.word	0x08003bf9
 8000180: f9 3b 00 08  	.word	0x08003bf9
 8000184: f9 3b 00 08  	.word	0x08003bf9

Disassembly of section text:

08000188 <__text_region_start>:
 8000188: f081 4100    	eor	r1, r1, #0x80000000
 800018c: e002         	b	0x8000194 <__aeabi_dadd> @ imm = #0x4
 800018e: bf00         	nop

08000190 <__subdf3>:
 8000190: f083 4300    	eor	r3, r3, #0x80000000

08000194 <__aeabi_dadd>:
 8000194: b530         	push	{r4, r5, lr}
 8000196: ea4f 0441    	lsl.w	r4, r1, #0x1
 800019a: ea4f 0543    	lsl.w	r5, r3, #0x1
 800019e: ea94 0f05    	teq.w	r4, r5
 80001a2: bf08         	it	eq
 80001a4: ea90 0f02    	teqeq.w	r0, r2
 80001a8: bf1f         	itttt	ne
 80001aa: ea54 0c00    	orrsne.w	r12, r4, r0
 80001ae: ea55 0c02    	orrsne.w	r12, r5, r2
 80001b2: ea7f 5c64    	mvnsne.w	r12, r4, asr #21
 80001b6: ea7f 5c65    	mvnsne.w	r12, r5, asr #21
 80001ba: f000 80e2    	beq.w	0x8000382 <__aeabi_dadd+0x1ee> @ imm = #0x1c4
 80001be: ea4f 5454    	lsr.w	r4, r4, #0x15
 80001c2: ebd4 5555    	rsbs	r5, r4, r5, lsr #21
 80001c6: bfb8         	it	lt
 80001c8: 426d         	rsblt	r5, r5, #0
 80001ca: dd0c         	ble	0x80001e6 <__aeabi_dadd+0x52> @ imm = #0x18
 80001cc: 442c         	add	r4, r5
 80001ce: ea80 0202    	eor.w	r2, r0, r2
 80001d2: ea81 0303    	eor.w	r3, r1, r3
 80001d6: ea82 0000    	eor.w	r0, r2, r0
 80001da: ea83 0101    	eor.w	r1, r3, r1
 80001de: ea80 0202    	eor.w	r2, r0, r2
 80001e2: ea81 0303    	eor.w	r3, r1, r3
 80001e6: 2d36         	cmp	r5, #0x36
 80001e8: bf88         	it	hi
 80001ea: bd30         	pophi	{r4, r5, pc}
 80001ec: f011 4f00    	tst.w	r1, #0x80000000
 80001f0: ea4f 3101    	lsl.w	r1, r1, #0xc
 80001f4: f44f 1c80    	mov.w	r12, #0x100000
 80001f8: ea4c 3111    	orr.w	r1, r12, r1, lsr #12
 80001fc: d002         	beq	0x8000204 <__aeabi_dadd+0x70> @ imm = #0x4
 80001fe: 4240         	rsbs	r0, r0, #0
 8000200: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8000204: f013 4f00    	tst.w	r3, #0x80000000
 8000208: ea4f 3303    	lsl.w	r3, r3, #0xc
 800020c: ea4c 3313    	orr.w	r3, r12, r3, lsr #12
 8000210: d002         	beq	0x8000218 <__aeabi_dadd+0x84> @ imm = #0x4
 8000212: 4252         	rsbs	r2, r2, #0
 8000214: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 8000218: ea94 0f05    	teq.w	r4, r5
 800021c: f000 80a7    	beq.w	0x800036e <__aeabi_dadd+0x1da> @ imm = #0x14e
 8000220: f1a4 0401    	sub.w	r4, r4, #0x1
 8000224: f1d5 0e20    	rsbs.w	lr, r5, #0x20
 8000228: db0d         	blt	0x8000246 <__aeabi_dadd+0xb2> @ imm = #0x1a
 800022a: fa02 fc0e    	lsl.w	r12, r2, lr
 800022e: fa22 f205    	lsr.w	r2, r2, r5
 8000232: 1880         	adds	r0, r0, r2
 8000234: f141 0100    	adc	r1, r1, #0x0
 8000238: fa03 f20e    	lsl.w	r2, r3, lr
 800023c: 1880         	adds	r0, r0, r2
 800023e: fa43 f305    	asr.w	r3, r3, r5
 8000242: 4159         	adcs	r1, r3
 8000244: e00e         	b	0x8000264 <__aeabi_dadd+0xd0> @ imm = #0x1c
 8000246: f1a5 0520    	sub.w	r5, r5, #0x20
 800024a: f10e 0e20    	add.w	lr, lr, #0x20
 800024e: 2a01         	cmp	r2, #0x1
 8000250: fa03 fc0e    	lsl.w	r12, r3, lr
 8000254: bf28         	it	hs
 8000256: f04c 0c02    	orrhs	r12, r12, #0x2
 800025a: fa43 f305    	asr.w	r3, r3, r5
 800025e: 18c0         	adds	r0, r0, r3
 8000260: eb51 71e3    	adcs.w	r1, r1, r3, asr #31
 8000264: f001 4500    	and	r5, r1, #0x80000000
 8000268: d507         	bpl	0x800027a <__aeabi_dadd+0xe6> @ imm = #0xe
 800026a: f04f 0e00    	mov.w	lr, #0x0
 800026e: f1dc 0c00    	rsbs.w	r12, r12, #0x0
 8000272: eb7e 0000    	sbcs.w	r0, lr, r0
 8000276: eb6e 0101    	sbc.w	r1, lr, r1
 800027a: f5b1 1f80    	cmp.w	r1, #0x100000
 800027e: d31b         	blo	0x80002b8 <__aeabi_dadd+0x124> @ imm = #0x36
 8000280: f5b1 1f00    	cmp.w	r1, #0x200000
 8000284: d30c         	blo	0x80002a0 <__aeabi_dadd+0x10c> @ imm = #0x18
 8000286: 0849         	lsrs	r1, r1, #0x1
 8000288: ea5f 0030    	rrxs	r0, r0
 800028c: ea4f 0c3c    	rrx	r12, r12
 8000290: f104 0401    	add.w	r4, r4, #0x1
 8000294: ea4f 5244    	lsl.w	r2, r4, #0x15
 8000298: f512 0f80    	cmn.w	r2, #0x400000
 800029c: f080 809a    	bhs.w	0x80003d4 <__aeabi_dadd+0x240> @ imm = #0x134
 80002a0: f1bc 4f00    	cmp.w	r12, #0x80000000
 80002a4: bf08         	it	eq
 80002a6: ea5f 0c50    	lsrseq.w	r12, r0, #0x1
 80002aa: f150 0000    	adcs	r0, r0, #0x0
 80002ae: eb41 5104    	adc.w	r1, r1, r4, lsl #20
 80002b2: ea41 0105    	orr.w	r1, r1, r5
 80002b6: bd30         	pop	{r4, r5, pc}
 80002b8: ea5f 0c4c    	lsls.w	r12, r12, #0x1
 80002bc: 4140         	adcs	r0, r0
 80002be: eb41 0101    	adc.w	r1, r1, r1
 80002c2: 3c01         	subs	r4, #0x1
 80002c4: bf28         	it	hs
 80002c6: f5b1 1f80    	cmphs.w	r1, #0x100000
 80002ca: d2e9         	bhs	0x80002a0 <__aeabi_dadd+0x10c> @ imm = #-0x2e
 80002cc: f091 0f00    	teq.w	r1, #0x0
 80002d0: bf04         	itt	eq
 80002d2: 4601         	moveq	r1, r0
 80002d4: 2000         	moveq	r0, #0x0
 80002d6: fab1 f381    	clz	r3, r1
 80002da: bf08         	it	eq
 80002dc: 3320         	addeq	r3, #0x20
 80002de: f1a3 030b    	sub.w	r3, r3, #0xb
 80002e2: f1b3 0220    	subs.w	r2, r3, #0x20
 80002e6: da0c         	bge	0x8000302 <__aeabi_dadd+0x16e> @ imm = #0x18
 80002e8: 320c         	adds	r2, #0xc
 80002ea: dd08         	ble	0x80002fe <__aeabi_dadd+0x16a> @ imm = #0x10
 80002ec: f102 0c14    	add.w	r12, r2, #0x14
 80002f0: f1c2 020c    	rsb.w	r2, r2, #0xc
 80002f4: fa01 f00c    	lsl.w	r0, r1, r12
 80002f8: fa21 f102    	lsr.w	r1, r1, r2
 80002fc: e00c         	b	0x8000318 <__aeabi_dadd+0x184> @ imm = #0x18
 80002fe: f102 0214    	add.w	r2, r2, #0x14
 8000302: bfd8         	it	le
 8000304: f1c2 0c20    	rsble.w	r12, r2, #0x20
 8000308: fa01 f102    	lsl.w	r1, r1, r2
 800030c: fa20 fc0c    	lsr.w	r12, r0, r12
 8000310: bfdc         	itt	le
 8000312: ea41 010c    	orrle.w	r1, r1, r12
 8000316: 4090         	lslle	r0, r2
 8000318: 1ae4         	subs	r4, r4, r3
 800031a: bfa2         	ittt	ge
 800031c: eb01 5104    	addge.w	r1, r1, r4, lsl #20
 8000320: 4329         	orrge	r1, r5
 8000322: bd30         	popge	{r4, r5, pc}
 8000324: ea6f 0404    	mvn.w	r4, r4
 8000328: 3c1f         	subs	r4, #0x1f
 800032a: da1c         	bge	0x8000366 <__aeabi_dadd+0x1d2> @ imm = #0x38
 800032c: 340c         	adds	r4, #0xc
 800032e: dc0e         	bgt	0x800034e <__aeabi_dadd+0x1ba> @ imm = #0x1c
 8000330: f104 0414    	add.w	r4, r4, #0x14
 8000334: f1c4 0220    	rsb.w	r2, r4, #0x20
 8000338: fa20 f004    	lsr.w	r0, r0, r4
 800033c: fa01 f302    	lsl.w	r3, r1, r2
 8000340: ea40 0003    	orr.w	r0, r0, r3
 8000344: fa21 f304    	lsr.w	r3, r1, r4
 8000348: ea45 0103    	orr.w	r1, r5, r3
 800034c: bd30         	pop	{r4, r5, pc}
 800034e: f1c4 040c    	rsb.w	r4, r4, #0xc
 8000352: f1c4 0220    	rsb.w	r2, r4, #0x20
 8000356: fa20 f002    	lsr.w	r0, r0, r2
 800035a: fa01 f304    	lsl.w	r3, r1, r4
 800035e: ea40 0003    	orr.w	r0, r0, r3
 8000362: 4629         	mov	r1, r5
 8000364: bd30         	pop	{r4, r5, pc}
 8000366: fa21 f004    	lsr.w	r0, r1, r4
 800036a: 4629         	mov	r1, r5
 800036c: bd30         	pop	{r4, r5, pc}
 800036e: f094 0f00    	teq.w	r4, #0x0
 8000372: f483 1380    	eor	r3, r3, #0x100000
 8000376: bf06         	itte	eq
 8000378: f481 1180    	eoreq	r1, r1, #0x100000
 800037c: 3401         	addeq	r4, #0x1
 800037e: 3d01         	subne	r5, #0x1
 8000380: e74e         	b	0x8000220 <__aeabi_dadd+0x8c> @ imm = #-0x164
 8000382: ea7f 5c64    	mvns.w	r12, r4, asr #21
 8000386: bf18         	it	ne
 8000388: ea7f 5c65    	mvnsne.w	r12, r5, asr #21
 800038c: d029         	beq	0x80003e2 <__aeabi_dadd+0x24e> @ imm = #0x52
 800038e: ea94 0f05    	teq.w	r4, r5
 8000392: bf08         	it	eq
 8000394: ea90 0f02    	teqeq.w	r0, r2
 8000398: d005         	beq	0x80003a6 <__aeabi_dadd+0x212> @ imm = #0xa
 800039a: ea54 0c00    	orrs.w	r12, r4, r0
 800039e: bf04         	itt	eq
 80003a0: 4619         	moveq	r1, r3
 80003a2: 4610         	moveq	r0, r2
 80003a4: bd30         	pop	{r4, r5, pc}
 80003a6: ea91 0f03    	teq.w	r1, r3
 80003aa: bf1e         	ittt	ne
 80003ac: 2100         	movne	r1, #0x0
 80003ae: 2000         	movne	r0, #0x0
 80003b0: bd30         	popne	{r4, r5, pc}
 80003b2: ea5f 5c54    	lsrs.w	r12, r4, #0x15
 80003b6: d105         	bne	0x80003c4 <__aeabi_dadd+0x230> @ imm = #0xa
 80003b8: 0040         	lsls	r0, r0, #0x1
 80003ba: 4149         	adcs	r1, r1
 80003bc: bf28         	it	hs
 80003be: f041 4100    	orrhs	r1, r1, #0x80000000
 80003c2: bd30         	pop	{r4, r5, pc}
 80003c4: f514 0480    	adds.w	r4, r4, #0x400000
 80003c8: bf3c         	itt	lo
 80003ca: f501 1180    	addlo.w	r1, r1, #0x100000
 80003ce: bd30         	poplo	{r4, r5, pc}
 80003d0: f001 4500    	and	r5, r1, #0x80000000
 80003d4: f045 41fe    	orr	r1, r5, #0x7f000000
 80003d8: f441 0170    	orr	r1, r1, #0xf00000
 80003dc: f04f 0000    	mov.w	r0, #0x0
 80003e0: bd30         	pop	{r4, r5, pc}
 80003e2: ea7f 5c64    	mvns.w	r12, r4, asr #21
 80003e6: bf1a         	itte	ne
 80003e8: 4619         	movne	r1, r3
 80003ea: 4610         	movne	r0, r2
 80003ec: ea7f 5c65    	mvnseq.w	r12, r5, asr #21
 80003f0: bf1c         	itt	ne
 80003f2: 460b         	movne	r3, r1
 80003f4: 4602         	movne	r2, r0
 80003f6: ea50 3401    	orrs.w	r4, r0, r1, lsl #12
 80003fa: bf06         	itte	eq
 80003fc: ea52 3503    	orrseq.w	r5, r2, r3, lsl #12
 8000400: ea91 0f03    	teqeq.w	r1, r3
 8000404: f441 2100    	orrne	r1, r1, #0x80000
 8000408: bd30         	pop	{r4, r5, pc}
 800040a: bf00         	nop

0800040c <__floatunsidf>:
 800040c: f090 0f00    	teq.w	r0, #0x0
 8000410: bf04         	itt	eq
 8000412: 2100         	moveq	r1, #0x0
 8000414: 4770         	bxeq	lr
 8000416: b530         	push	{r4, r5, lr}
 8000418: f44f 6480    	mov.w	r4, #0x400
 800041c: f104 0432    	add.w	r4, r4, #0x32
 8000420: f04f 0500    	mov.w	r5, #0x0
 8000424: f04f 0100    	mov.w	r1, #0x0
 8000428: e750         	b	0x80002cc <__aeabi_dadd+0x138> @ imm = #-0x160
 800042a: bf00         	nop

0800042c <__floatsidf>:
 800042c: f090 0f00    	teq.w	r0, #0x0
 8000430: bf04         	itt	eq
 8000432: 2100         	moveq	r1, #0x0
 8000434: 4770         	bxeq	lr
 8000436: b530         	push	{r4, r5, lr}
 8000438: f44f 6480    	mov.w	r4, #0x400
 800043c: f104 0432    	add.w	r4, r4, #0x32
 8000440: f010 4500    	ands	r5, r0, #0x80000000
 8000444: bf48         	it	mi
 8000446: 4240         	rsbmi	r0, r0, #0
 8000448: f04f 0100    	mov.w	r1, #0x0
 800044c: e73e         	b	0x80002cc <__aeabi_dadd+0x138> @ imm = #-0x184
 800044e: bf00         	nop

08000450 <__extendsfdf2>:
 8000450: 0042         	lsls	r2, r0, #0x1
 8000452: ea4f 01e2    	asr.w	r1, r2, #0x3
 8000456: ea4f 0131    	rrx	r1, r1
 800045a: ea4f 7002    	lsl.w	r0, r2, #0x1c
 800045e: bf1f         	itttt	ne
 8000460: f012 437f    	andsne	r3, r2, #0xff000000
 8000464: f093 4f7f    	teqne.w	r3, #0xff000000
 8000468: f081 5160    	eorne	r1, r1, #0x38000000
 800046c: 4770         	bxne	lr
 800046e: f032 427f    	bics	r2, r2, #0xff000000
 8000472: bf08         	it	eq
 8000474: 4770         	bxeq	lr
 8000476: f093 4f7f    	teq.w	r3, #0xff000000
 800047a: bf04         	itt	eq
 800047c: f441 2100    	orreq	r1, r1, #0x80000
 8000480: 4770         	bxeq	lr
 8000482: b530         	push	{r4, r5, lr}
 8000484: f44f 7460    	mov.w	r4, #0x380
 8000488: f001 4500    	and	r5, r1, #0x80000000
 800048c: f021 4100    	bic	r1, r1, #0x80000000
 8000490: e71c         	b	0x80002cc <__aeabi_dadd+0x138> @ imm = #-0x1c8
 8000492: bf00         	nop

08000494 <__floatundidf>:
 8000494: ea50 0201    	orrs.w	r2, r0, r1
 8000498: bf08         	it	eq
 800049a: 4770         	bxeq	lr
 800049c: b530         	push	{r4, r5, lr}
 800049e: f04f 0500    	mov.w	r5, #0x0
 80004a2: e00a         	b	0x80004ba <__floatdidf+0x16> @ imm = #0x14

080004a4 <__floatdidf>:
 80004a4: ea50 0201    	orrs.w	r2, r0, r1
 80004a8: bf08         	it	eq
 80004aa: 4770         	bxeq	lr
 80004ac: b530         	push	{r4, r5, lr}
 80004ae: f011 4500    	ands	r5, r1, #0x80000000
 80004b2: d502         	bpl	0x80004ba <__floatdidf+0x16> @ imm = #0x4
 80004b4: 4240         	rsbs	r0, r0, #0
 80004b6: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80004ba: f44f 6480    	mov.w	r4, #0x400
 80004be: f104 0432    	add.w	r4, r4, #0x32
 80004c2: ea5f 5c91    	lsrs.w	r12, r1, #0x16
 80004c6: f43f aed8    	beq.w	0x800027a <__aeabi_dadd+0xe6> @ imm = #-0x250
 80004ca: f04f 0203    	mov.w	r2, #0x3
 80004ce: ea5f 0cdc    	lsrs.w	r12, r12, #0x3
 80004d2: bf18         	it	ne
 80004d4: 3203         	addne	r2, #0x3
 80004d6: ea5f 0cdc    	lsrs.w	r12, r12, #0x3
 80004da: bf18         	it	ne
 80004dc: 3203         	addne	r2, #0x3
 80004de: eb02 02dc    	add.w	r2, r2, r12, lsr #3
 80004e2: f1c2 0320    	rsb.w	r3, r2, #0x20
 80004e6: fa00 fc03    	lsl.w	r12, r0, r3
 80004ea: fa20 f002    	lsr.w	r0, r0, r2
 80004ee: fa01 fe03    	lsl.w	lr, r1, r3
 80004f2: ea40 000e    	orr.w	r0, r0, lr
 80004f6: fa21 f102    	lsr.w	r1, r1, r2
 80004fa: 4414         	add	r4, r2
 80004fc: e6bd         	b	0x800027a <__aeabi_dadd+0xe6> @ imm = #-0x286
 80004fe: bf00         	nop

08000500 <__aeabi_frsub>:
 8000500: f080 4000    	eor	r0, r0, #0x80000000
 8000504: e002         	b	0x800050c <__aeabi_fadd> @ imm = #0x4
 8000506: bf00         	nop

08000508 <__subsf3>:
 8000508: f081 4100    	eor	r1, r1, #0x80000000

0800050c <__aeabi_fadd>:
 800050c: 0042         	lsls	r2, r0, #0x1
 800050e: bf1f         	itttt	ne
 8000510: ea5f 0341    	lslsne.w	r3, r1, #0x1
 8000514: ea92 0f03    	teqne.w	r2, r3
 8000518: ea7f 6c22    	mvnsne.w	r12, r2, asr #24
 800051c: ea7f 6c23    	mvnsne.w	r12, r3, asr #24
 8000520: d06a         	beq	0x80005f8 <__aeabi_fadd+0xec> @ imm = #0xd4
 8000522: ea4f 6212    	lsr.w	r2, r2, #0x18
 8000526: ebd2 6313    	rsbs	r3, r2, r3, lsr #24
 800052a: bfc1         	itttt	gt
 800052c: 18d2         	addgt	r2, r2, r3
 800052e: 4041         	eorgt	r1, r0
 8000530: 4048         	eorgt	r0, r1
 8000532: 4041         	eorgt	r1, r0
 8000534: bfb8         	it	lt
 8000536: 425b         	rsblt	r3, r3, #0
 8000538: 2b19         	cmp	r3, #0x19
 800053a: bf88         	it	hi
 800053c: 4770         	bxhi	lr
 800053e: f010 4f00    	tst.w	r0, #0x80000000
 8000542: f440 0000    	orr	r0, r0, #0x800000
 8000546: f020 407f    	bic	r0, r0, #0xff000000
 800054a: bf18         	it	ne
 800054c: 4240         	rsbne	r0, r0, #0
 800054e: f011 4f00    	tst.w	r1, #0x80000000
 8000552: f441 0100    	orr	r1, r1, #0x800000
 8000556: f021 417f    	bic	r1, r1, #0xff000000
 800055a: bf18         	it	ne
 800055c: 4249         	rsbne	r1, r1, #0
 800055e: ea92 0f03    	teq.w	r2, r3
 8000562: d03f         	beq	0x80005e4 <__aeabi_fadd+0xd8> @ imm = #0x7e
 8000564: f1a2 0201    	sub.w	r2, r2, #0x1
 8000568: fa41 fc03    	asr.w	r12, r1, r3
 800056c: eb10 000c    	adds.w	r0, r0, r12
 8000570: f1c3 0320    	rsb.w	r3, r3, #0x20
 8000574: fa01 f103    	lsl.w	r1, r1, r3
 8000578: f000 4300    	and	r3, r0, #0x80000000
 800057c: d502         	bpl	0x8000584 <__aeabi_fadd+0x78> @ imm = #0x4
 800057e: 4249         	rsbs	r1, r1, #0
 8000580: eb60 0040    	sbc.w	r0, r0, r0, lsl #1
 8000584: f5b0 0f00    	cmp.w	r0, #0x800000
 8000588: d313         	blo	0x80005b2 <__aeabi_fadd+0xa6> @ imm = #0x26
 800058a: f1b0 7f80    	cmp.w	r0, #0x1000000
 800058e: d306         	blo	0x800059e <__aeabi_fadd+0x92> @ imm = #0xc
 8000590: 0840         	lsrs	r0, r0, #0x1
 8000592: ea4f 0131    	rrx	r1, r1
 8000596: f102 0201    	add.w	r2, r2, #0x1
 800059a: 2afe         	cmp	r2, #0xfe
 800059c: d251         	bhs	0x8000642 <__aeabi_fadd+0x136> @ imm = #0xa2
 800059e: f1b1 4f00    	cmp.w	r1, #0x80000000
 80005a2: eb40 50c2    	adc.w	r0, r0, r2, lsl #23
 80005a6: bf08         	it	eq
 80005a8: f020 0001    	biceq	r0, r0, #0x1
 80005ac: ea40 0003    	orr.w	r0, r0, r3
 80005b0: 4770         	bx	lr
 80005b2: 0049         	lsls	r1, r1, #0x1
 80005b4: eb40 0000    	adc.w	r0, r0, r0
 80005b8: 3a01         	subs	r2, #0x1
 80005ba: bf28         	it	hs
 80005bc: f5b0 0f00    	cmphs.w	r0, #0x800000
 80005c0: d2ed         	bhs	0x800059e <__aeabi_fadd+0x92> @ imm = #-0x26
 80005c2: fab0 fc80    	clz	r12, r0
 80005c6: f1ac 0c08    	sub.w	r12, r12, #0x8
 80005ca: ebb2 020c    	subs.w	r2, r2, r12
 80005ce: fa00 f00c    	lsl.w	r0, r0, r12
 80005d2: bfaa         	itet	ge
 80005d4: eb00 50c2    	addge.w	r0, r0, r2, lsl #23
 80005d8: 4252         	rsblt	r2, r2, #0
 80005da: 4318         	orrge	r0, r3
 80005dc: bfbc         	itt	lt
 80005de: 40d0         	lsrlt	r0, r2
 80005e0: 4318         	orrlt	r0, r3
 80005e2: 4770         	bx	lr
 80005e4: f092 0f00    	teq.w	r2, #0x0
 80005e8: f481 0100    	eor	r1, r1, #0x800000
 80005ec: bf06         	itte	eq
 80005ee: f480 0000    	eoreq	r0, r0, #0x800000
 80005f2: 3201         	addeq	r2, #0x1
 80005f4: 3b01         	subne	r3, #0x1
 80005f6: e7b5         	b	0x8000564 <__aeabi_fadd+0x58> @ imm = #-0x96
 80005f8: ea4f 0341    	lsl.w	r3, r1, #0x1
 80005fc: ea7f 6c22    	mvns.w	r12, r2, asr #24
 8000600: bf18         	it	ne
 8000602: ea7f 6c23    	mvnsne.w	r12, r3, asr #24
 8000606: d021         	beq	0x800064c <__aeabi_fadd+0x140> @ imm = #0x42
 8000608: ea92 0f03    	teq.w	r2, r3
 800060c: d004         	beq	0x8000618 <__aeabi_fadd+0x10c> @ imm = #0x8
 800060e: f092 0f00    	teq.w	r2, #0x0
 8000612: bf08         	it	eq
 8000614: 4608         	moveq	r0, r1
 8000616: 4770         	bx	lr
 8000618: ea90 0f01    	teq.w	r0, r1
 800061c: bf1c         	itt	ne
 800061e: 2000         	movne	r0, #0x0
 8000620: 4770         	bxne	lr
 8000622: f012 4f7f    	tst.w	r2, #0xff000000
 8000626: d104         	bne	0x8000632 <__aeabi_fadd+0x126> @ imm = #0x8
 8000628: 0040         	lsls	r0, r0, #0x1
 800062a: bf28         	it	hs
 800062c: f040 4000    	orrhs	r0, r0, #0x80000000
 8000630: 4770         	bx	lr
 8000632: f112 7200    	adds.w	r2, r2, #0x2000000
 8000636: bf3c         	itt	lo
 8000638: f500 0000    	addlo.w	r0, r0, #0x800000
 800063c: 4770         	bxlo	lr
 800063e: f000 4300    	and	r3, r0, #0x80000000
 8000642: f043 40fe    	orr	r0, r3, #0x7f000000
 8000646: f440 0000    	orr	r0, r0, #0x800000
 800064a: 4770         	bx	lr
 800064c: ea7f 6222    	mvns.w	r2, r2, asr #24
 8000650: bf16         	itet	ne
 8000652: 4608         	movne	r0, r1
 8000654: ea7f 6323    	mvnseq.w	r3, r3, asr #24
 8000658: 4601         	movne	r1, r0
 800065a: 0242         	lsls	r2, r0, #0x9
 800065c: bf06         	itte	eq
 800065e: ea5f 2341    	lslseq.w	r3, r1, #0x9
 8000662: ea90 0f01    	teqeq.w	r0, r1
 8000666: f440 0080    	orrne	r0, r0, #0x400000
 800066a: 4770         	bx	lr

0800066c <__floatunsisf>:
 800066c: f04f 0300    	mov.w	r3, #0x0
 8000670: e004         	b	0x800067c <__floatsisf+0x8> @ imm = #0x8
 8000672: bf00         	nop

08000674 <__floatsisf>:
 8000674: f010 4300    	ands	r3, r0, #0x80000000
 8000678: bf48         	it	mi
 800067a: 4240         	rsbmi	r0, r0, #0
 800067c: ea5f 0c00    	movs.w	r12, r0
 8000680: bf08         	it	eq
 8000682: 4770         	bxeq	lr
 8000684: f043 4396    	orr	r3, r3, #0x4b000000
 8000688: 4601         	mov	r1, r0
 800068a: f04f 0000    	mov.w	r0, #0x0
 800068e: e01c         	b	0x80006ca <__floatdisf+0x2a> @ imm = #0x38

08000690 <__floatundisf>:
 8000690: ea50 0201    	orrs.w	r2, r0, r1
 8000694: bf08         	it	eq
 8000696: 4770         	bxeq	lr
 8000698: f04f 0300    	mov.w	r3, #0x0
 800069c: e00a         	b	0x80006b4 <__floatdisf+0x14> @ imm = #0x14
 800069e: bf00         	nop

080006a0 <__floatdisf>:
 80006a0: ea50 0201    	orrs.w	r2, r0, r1
 80006a4: bf08         	it	eq
 80006a6: 4770         	bxeq	lr
 80006a8: f011 4300    	ands	r3, r1, #0x80000000
 80006ac: d502         	bpl	0x80006b4 <__floatdisf+0x14> @ imm = #0x4
 80006ae: 4240         	rsbs	r0, r0, #0
 80006b0: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80006b4: ea5f 0c01    	movs.w	r12, r1
 80006b8: bf02         	ittt	eq
 80006ba: 4684         	moveq	r12, r0
 80006bc: 4601         	moveq	r1, r0
 80006be: 2000         	moveq	r0, #0x0
 80006c0: f043 43b6    	orr	r3, r3, #0x5b000000
 80006c4: bf08         	it	eq
 80006c6: f1a3 5380    	subeq.w	r3, r3, #0x10000000
 80006ca: f5a3 0300    	sub.w	r3, r3, #0x800000
 80006ce: fabc f28c    	clz	r2, r12
 80006d2: 3a08         	subs	r2, #0x8
 80006d4: eba3 53c2    	sub.w	r3, r3, r2, lsl #23
 80006d8: db10         	blt	0x80006fc <__floatdisf+0x5c> @ imm = #0x20
 80006da: fa01 fc02    	lsl.w	r12, r1, r2
 80006de: 4463         	add	r3, r12
 80006e0: fa00 fc02    	lsl.w	r12, r0, r2
 80006e4: f1c2 0220    	rsb.w	r2, r2, #0x20
 80006e8: f1bc 4f00    	cmp.w	r12, #0x80000000
 80006ec: fa20 f202    	lsr.w	r2, r0, r2
 80006f0: eb43 0002    	adc.w	r0, r3, r2
 80006f4: bf08         	it	eq
 80006f6: f020 0001    	biceq	r0, r0, #0x1
 80006fa: 4770         	bx	lr
 80006fc: f102 0220    	add.w	r2, r2, #0x20
 8000700: fa01 fc02    	lsl.w	r12, r1, r2
 8000704: f1c2 0220    	rsb.w	r2, r2, #0x20
 8000708: ea50 004c    	orrs.w	r0, r0, r12, lsl #1
 800070c: fa21 f202    	lsr.w	r2, r1, r2
 8000710: eb43 0002    	adc.w	r0, r3, r2
 8000714: bf08         	it	eq
 8000716: ea20 70dc    	biceq.w	r0, r0, r12, lsr #31
 800071a: 4770         	bx	lr

0800071c <__mulsf3>:
 800071c: f04f 0cff    	mov.w	r12, #0xff
 8000720: ea1c 52d0    	ands.w	r2, r12, r0, lsr #23
 8000724: bf1e         	ittt	ne
 8000726: ea1c 53d1    	andsne.w	r3, r12, r1, lsr #23
 800072a: ea92 0f0c    	teqne.w	r2, r12
 800072e: ea93 0f0c    	teqne.w	r3, r12
 8000732: d06f         	beq	0x8000814 <__mulsf3+0xf8> @ imm = #0xde
 8000734: 441a         	add	r2, r3
 8000736: ea80 0c01    	eor.w	r12, r0, r1
 800073a: 0240         	lsls	r0, r0, #0x9
 800073c: bf18         	it	ne
 800073e: ea5f 2141    	lslsne.w	r1, r1, #0x9
 8000742: d01e         	beq	0x8000782 <__mulsf3+0x66> @ imm = #0x3c
 8000744: f04f 6300    	mov.w	r3, #0x8000000
 8000748: ea43 1050    	orr.w	r0, r3, r0, lsr #5
 800074c: ea43 1151    	orr.w	r1, r3, r1, lsr #5
 8000750: fba0 3101    	umull	r3, r1, r0, r1
 8000754: f00c 4000    	and	r0, r12, #0x80000000
 8000758: f5b1 0f00    	cmp.w	r1, #0x800000
 800075c: bf3e         	ittt	lo
 800075e: 0049         	lsllo	r1, r1, #0x1
 8000760: ea41 71d3    	orrlo.w	r1, r1, r3, lsr #31
 8000764: 005b         	lsllo	r3, r3, #0x1
 8000766: ea40 0001    	orr.w	r0, r0, r1
 800076a: f162 027f    	sbc	r2, r2, #0x7f
 800076e: 2afd         	cmp	r2, #0xfd
 8000770: d81d         	bhi	0x80007ae <__mulsf3+0x92> @ imm = #0x3a
 8000772: f1b3 4f00    	cmp.w	r3, #0x80000000
 8000776: eb40 50c2    	adc.w	r0, r0, r2, lsl #23
 800077a: bf08         	it	eq
 800077c: f020 0001    	biceq	r0, r0, #0x1
 8000780: 4770         	bx	lr
 8000782: f090 0f00    	teq.w	r0, #0x0
 8000786: f00c 4c00    	and	r12, r12, #0x80000000
 800078a: bf08         	it	eq
 800078c: 0249         	lsleq	r1, r1, #0x9
 800078e: ea4c 2050    	orr.w	r0, r12, r0, lsr #9
 8000792: ea40 2051    	orr.w	r0, r0, r1, lsr #9
 8000796: 3a7f         	subs	r2, #0x7f
 8000798: bfc2         	ittt	gt
 800079a: f1d2 03ff    	rsbsgt.w	r3, r2, #0xff
 800079e: ea40 50c2    	orrgt.w	r0, r0, r2, lsl #23
 80007a2: 4770         	bxgt	lr
 80007a4: f440 0000    	orr	r0, r0, #0x800000
 80007a8: f04f 0300    	mov.w	r3, #0x0
 80007ac: 3a01         	subs	r2, #0x1
 80007ae: dc5d         	bgt	0x800086c <__mulsf3+0x150> @ imm = #0xba
 80007b0: f112 0f19    	cmn.w	r2, #0x19
 80007b4: bfdc         	itt	le
 80007b6: f000 4000    	andle	r0, r0, #0x80000000
 80007ba: 4770         	bxle	lr
 80007bc: f1c2 0200    	rsb.w	r2, r2, #0x0
 80007c0: 0041         	lsls	r1, r0, #0x1
 80007c2: fa21 f102    	lsr.w	r1, r1, r2
 80007c6: f1c2 0220    	rsb.w	r2, r2, #0x20
 80007ca: fa00 fc02    	lsl.w	r12, r0, r2
 80007ce: ea5f 0031    	rrxs	r0, r1
 80007d2: f140 0000    	adc	r0, r0, #0x0
 80007d6: ea53 034c    	orrs.w	r3, r3, r12, lsl #1
 80007da: bf08         	it	eq
 80007dc: ea20 70dc    	biceq.w	r0, r0, r12, lsr #31
 80007e0: 4770         	bx	lr
 80007e2: f092 0f00    	teq.w	r2, #0x0
 80007e6: f000 4c00    	and	r12, r0, #0x80000000
 80007ea: bf02         	ittt	eq
 80007ec: 0040         	lsleq	r0, r0, #0x1
 80007ee: f410 0f00    	tsteq.w	r0, #0x800000
 80007f2: 3a01         	subeq	r2, #0x1
 80007f4: d0f9         	beq	0x80007ea <__mulsf3+0xce> @ imm = #-0xe
 80007f6: ea40 000c    	orr.w	r0, r0, r12
 80007fa: f093 0f00    	teq.w	r3, #0x0
 80007fe: f001 4c00    	and	r12, r1, #0x80000000
 8000802: bf02         	ittt	eq
 8000804: 0049         	lsleq	r1, r1, #0x1
 8000806: f411 0f00    	tsteq.w	r1, #0x800000
 800080a: 3b01         	subeq	r3, #0x1
 800080c: d0f9         	beq	0x8000802 <__mulsf3+0xe6> @ imm = #-0xe
 800080e: ea41 010c    	orr.w	r1, r1, r12
 8000812: e78f         	b	0x8000734 <__mulsf3+0x18> @ imm = #-0xe2
 8000814: ea0c 53d1    	and.w	r3, r12, r1, lsr #23
 8000818: ea92 0f0c    	teq.w	r2, r12
 800081c: bf18         	it	ne
 800081e: ea93 0f0c    	teqne.w	r3, r12
 8000822: d00a         	beq	0x800083a <__mulsf3+0x11e> @ imm = #0x14
 8000824: f030 4c00    	bics	r12, r0, #0x80000000
 8000828: bf18         	it	ne
 800082a: f031 4c00    	bicsne	r12, r1, #0x80000000
 800082e: d1d8         	bne	0x80007e2 <__mulsf3+0xc6> @ imm = #-0x50
 8000830: ea80 0001    	eor.w	r0, r0, r1
 8000834: f000 4000    	and	r0, r0, #0x80000000
 8000838: 4770         	bx	lr
 800083a: f090 0f00    	teq.w	r0, #0x0
 800083e: bf17         	itett	ne
 8000840: f090 4f00    	teqne.w	r0, #0x80000000
 8000844: 4608         	moveq	r0, r1
 8000846: f091 0f00    	teqne.w	r1, #0x0
 800084a: f091 4f00    	teqne.w	r1, #0x80000000
 800084e: d014         	beq	0x800087a <__mulsf3+0x15e> @ imm = #0x28
 8000850: ea92 0f0c    	teq.w	r2, r12
 8000854: d101         	bne	0x800085a <__mulsf3+0x13e> @ imm = #0x2
 8000856: 0242         	lsls	r2, r0, #0x9
 8000858: d10f         	bne	0x800087a <__mulsf3+0x15e> @ imm = #0x1e
 800085a: ea93 0f0c    	teq.w	r3, r12
 800085e: d103         	bne	0x8000868 <__mulsf3+0x14c> @ imm = #0x6
 8000860: 024b         	lsls	r3, r1, #0x9
 8000862: bf18         	it	ne
 8000864: 4608         	movne	r0, r1
 8000866: d108         	bne	0x800087a <__mulsf3+0x15e> @ imm = #0x10
 8000868: ea80 0001    	eor.w	r0, r0, r1
 800086c: f000 4000    	and	r0, r0, #0x80000000
 8000870: f040 40fe    	orr	r0, r0, #0x7f000000
 8000874: f440 0000    	orr	r0, r0, #0x800000
 8000878: 4770         	bx	lr
 800087a: f040 40fe    	orr	r0, r0, #0x7f000000
 800087e: f440 0040    	orr	r0, r0, #0xc00000
 8000882: 4770         	bx	lr

08000884 <__divsf3>:
 8000884: f04f 0cff    	mov.w	r12, #0xff
 8000888: ea1c 52d0    	ands.w	r2, r12, r0, lsr #23
 800088c: bf1e         	ittt	ne
 800088e: ea1c 53d1    	andsne.w	r3, r12, r1, lsr #23
 8000892: ea92 0f0c    	teqne.w	r2, r12
 8000896: ea93 0f0c    	teqne.w	r3, r12
 800089a: d069         	beq	0x8000970 <__divsf3+0xec> @ imm = #0xd2
 800089c: eba2 0203    	sub.w	r2, r2, r3
 80008a0: ea80 0c01    	eor.w	r12, r0, r1
 80008a4: 0249         	lsls	r1, r1, #0x9
 80008a6: ea4f 2040    	lsl.w	r0, r0, #0x9
 80008aa: d037         	beq	0x800091c <__divsf3+0x98> @ imm = #0x6e
 80008ac: f04f 5380    	mov.w	r3, #0x10000000
 80008b0: ea43 1111    	orr.w	r1, r3, r1, lsr #4
 80008b4: ea43 1310    	orr.w	r3, r3, r0, lsr #4
 80008b8: f00c 4000    	and	r0, r12, #0x80000000
 80008bc: 428b         	cmp	r3, r1
 80008be: bf38         	it	lo
 80008c0: 005b         	lsllo	r3, r3, #0x1
 80008c2: f142 027d    	adc	r2, r2, #0x7d
 80008c6: f44f 0c00    	mov.w	r12, #0x800000
 80008ca: 428b         	cmp	r3, r1
 80008cc: bf24         	itt	hs
 80008ce: 1a5b         	subhs	r3, r3, r1
 80008d0: ea40 000c    	orrhs.w	r0, r0, r12
 80008d4: ebb3 0f51    	cmp.w	r3, r1, lsr #1
 80008d8: bf24         	itt	hs
 80008da: eba3 0351    	subhs.w	r3, r3, r1, lsr #1
 80008de: ea40 005c    	orrhs.w	r0, r0, r12, lsr #1
 80008e2: ebb3 0f91    	cmp.w	r3, r1, lsr #2
 80008e6: bf24         	itt	hs
 80008e8: eba3 0391    	subhs.w	r3, r3, r1, lsr #2
 80008ec: ea40 009c    	orrhs.w	r0, r0, r12, lsr #2
 80008f0: ebb3 0fd1    	cmp.w	r3, r1, lsr #3
 80008f4: bf24         	itt	hs
 80008f6: eba3 03d1    	subhs.w	r3, r3, r1, lsr #3
 80008fa: ea40 00dc    	orrhs.w	r0, r0, r12, lsr #3
 80008fe: 011b         	lsls	r3, r3, #0x4
 8000900: bf18         	it	ne
 8000902: ea5f 1c1c    	lsrsne.w	r12, r12, #0x4
 8000906: d1e0         	bne	0x80008ca <__divsf3+0x46> @ imm = #-0x40
 8000908: 2afd         	cmp	r2, #0xfd
 800090a: f63f af50    	bhi.w	0x80007ae <__mulsf3+0x92> @ imm = #-0x160
 800090e: 428b         	cmp	r3, r1
 8000910: eb40 50c2    	adc.w	r0, r0, r2, lsl #23
 8000914: bf08         	it	eq
 8000916: f020 0001    	biceq	r0, r0, #0x1
 800091a: 4770         	bx	lr
 800091c: f00c 4c00    	and	r12, r12, #0x80000000
 8000920: ea4c 2050    	orr.w	r0, r12, r0, lsr #9
 8000924: 327f         	adds	r2, #0x7f
 8000926: bfc2         	ittt	gt
 8000928: f1d2 03ff    	rsbsgt.w	r3, r2, #0xff
 800092c: ea40 50c2    	orrgt.w	r0, r0, r2, lsl #23
 8000930: 4770         	bxgt	lr
 8000932: f440 0000    	orr	r0, r0, #0x800000
 8000936: f04f 0300    	mov.w	r3, #0x0
 800093a: 3a01         	subs	r2, #0x1
 800093c: e737         	b	0x80007ae <__mulsf3+0x92> @ imm = #-0x192
 800093e: f092 0f00    	teq.w	r2, #0x0
 8000942: f000 4c00    	and	r12, r0, #0x80000000
 8000946: bf02         	ittt	eq
 8000948: 0040         	lsleq	r0, r0, #0x1
 800094a: f410 0f00    	tsteq.w	r0, #0x800000
 800094e: 3a01         	subeq	r2, #0x1
 8000950: d0f9         	beq	0x8000946 <__divsf3+0xc2> @ imm = #-0xe
 8000952: ea40 000c    	orr.w	r0, r0, r12
 8000956: f093 0f00    	teq.w	r3, #0x0
 800095a: f001 4c00    	and	r12, r1, #0x80000000
 800095e: bf02         	ittt	eq
 8000960: 0049         	lsleq	r1, r1, #0x1
 8000962: f411 0f00    	tsteq.w	r1, #0x800000
 8000966: 3b01         	subeq	r3, #0x1
 8000968: d0f9         	beq	0x800095e <__divsf3+0xda> @ imm = #-0xe
 800096a: ea41 010c    	orr.w	r1, r1, r12
 800096e: e795         	b	0x800089c <__divsf3+0x18> @ imm = #-0xd6
 8000970: ea0c 53d1    	and.w	r3, r12, r1, lsr #23
 8000974: ea92 0f0c    	teq.w	r2, r12
 8000978: d108         	bne	0x800098c <__divsf3+0x108> @ imm = #0x10
 800097a: 0242         	lsls	r2, r0, #0x9
 800097c: f47f af7d    	bne.w	0x800087a <__mulsf3+0x15e> @ imm = #-0x106
 8000980: ea93 0f0c    	teq.w	r3, r12
 8000984: f47f af70    	bne.w	0x8000868 <__mulsf3+0x14c> @ imm = #-0x120
 8000988: 4608         	mov	r0, r1
 800098a: e776         	b	0x800087a <__mulsf3+0x15e> @ imm = #-0x114
 800098c: ea93 0f0c    	teq.w	r3, r12
 8000990: d104         	bne	0x800099c <__divsf3+0x118> @ imm = #0x8
 8000992: 024b         	lsls	r3, r1, #0x9
 8000994: f43f af4c    	beq.w	0x8000830 <__mulsf3+0x114> @ imm = #-0x168
 8000998: 4608         	mov	r0, r1
 800099a: e76e         	b	0x800087a <__mulsf3+0x15e> @ imm = #-0x124
 800099c: f030 4c00    	bics	r12, r0, #0x80000000
 80009a0: bf18         	it	ne
 80009a2: f031 4c00    	bicsne	r12, r1, #0x80000000
 80009a6: d1ca         	bne	0x800093e <__divsf3+0xba> @ imm = #-0x6c
 80009a8: f030 4200    	bics	r2, r0, #0x80000000
 80009ac: f47f af5c    	bne.w	0x8000868 <__mulsf3+0x14c> @ imm = #-0x148
 80009b0: f031 4300    	bics	r3, r1, #0x80000000
 80009b4: f47f af3c    	bne.w	0x8000830 <__mulsf3+0x114> @ imm = #-0x188
 80009b8: e75f         	b	0x800087a <__mulsf3+0x15e> @ imm = #-0x142
 80009ba: bf00         	nop

080009bc <__gtsf2>:
 80009bc: f04f 3cff    	mov.w	r12, #0xffffffff
 80009c0: e006         	b	0x80009d0 <__nesf2+0x4> @ imm = #0xc
 80009c2: bf00         	nop

080009c4 <__ltsf2>:
 80009c4: f04f 0c01    	mov.w	r12, #0x1
 80009c8: e002         	b	0x80009d0 <__nesf2+0x4> @ imm = #0x4
 80009ca: bf00         	nop

080009cc <__nesf2>:
 80009cc: f04f 0c01    	mov.w	r12, #0x1
 80009d0: f84d cd04    	str	r12, [sp, #-4]!
 80009d4: ea4f 0240    	lsl.w	r2, r0, #0x1
 80009d8: ea4f 0341    	lsl.w	r3, r1, #0x1
 80009dc: ea7f 6c22    	mvns.w	r12, r2, asr #24
 80009e0: bf18         	it	ne
 80009e2: ea7f 6c23    	mvnsne.w	r12, r3, asr #24
 80009e6: d011         	beq	0x8000a0c <__nesf2+0x40> @ imm = #0x22
 80009e8: b001         	add	sp, #0x4
 80009ea: ea52 0c53    	orrs.w	r12, r2, r3, lsr #1
 80009ee: bf18         	it	ne
 80009f0: ea90 0f01    	teqne.w	r0, r1
 80009f4: bf58         	it	pl
 80009f6: ebb2 0003    	subspl.w	r0, r2, r3
 80009fa: bf88         	it	hi
 80009fc: 17c8         	asrhi	r0, r1, #0x1f
 80009fe: bf38         	it	lo
 8000a00: ea6f 70e1    	mvnlo.w	r0, r1, asr #31
 8000a04: bf18         	it	ne
 8000a06: f040 0001    	orrne	r0, r0, #0x1
 8000a0a: 4770         	bx	lr
 8000a0c: ea7f 6c22    	mvns.w	r12, r2, asr #24
 8000a10: d102         	bne	0x8000a18 <__nesf2+0x4c> @ imm = #0x4
 8000a12: ea5f 2c40    	lsls.w	r12, r0, #0x9
 8000a16: d105         	bne	0x8000a24 <__nesf2+0x58> @ imm = #0xa
 8000a18: ea7f 6c23    	mvns.w	r12, r3, asr #24
 8000a1c: d1e4         	bne	0x80009e8 <__nesf2+0x1c> @ imm = #-0x38
 8000a1e: ea5f 2c41    	lsls.w	r12, r1, #0x9
 8000a22: d0e1         	beq	0x80009e8 <__nesf2+0x1c> @ imm = #-0x3e
 8000a24: f85d 0b04    	ldr	r0, [sp], #4
 8000a28: 4770         	bx	lr
 8000a2a: bf00         	nop

08000a2c <__aeabi_cfrcmple>:
 8000a2c: 4684         	mov	r12, r0
 8000a2e: 4608         	mov	r0, r1
 8000a30: 4661         	mov	r1, r12
 8000a32: e7ff         	b	0x8000a34 <__aeabi_cfcmple> @ imm = #-0x2

08000a34 <__aeabi_cfcmple>:
 8000a34: b50f         	push	{r0, r1, r2, r3, lr}
 8000a36: f7ff ffc9    	bl	0x80009cc <__nesf2>     @ imm = #-0x6e
 8000a3a: 2800         	cmp	r0, #0x0
 8000a3c: bf48         	it	mi
 8000a3e: f110 0f00    	cmnmi.w	r0, #0x0
 8000a42: bd0f         	pop	{r0, r1, r2, r3, pc}

08000a44 <__aeabi_fcmpeq>:
 8000a44: f84d ed08    	str	lr, [sp, #-8]!
 8000a48: f7ff fff4    	bl	0x8000a34 <__aeabi_cfcmple> @ imm = #-0x18
 8000a4c: bf0c         	ite	eq
 8000a4e: 2001         	moveq	r0, #0x1
 8000a50: 2000         	movne	r0, #0x0
 8000a52: f85d fb08    	ldr	pc, [sp], #8
 8000a56: bf00         	nop

08000a58 <__aeabi_fcmplt>:
 8000a58: f84d ed08    	str	lr, [sp, #-8]!
 8000a5c: f7ff ffea    	bl	0x8000a34 <__aeabi_cfcmple> @ imm = #-0x2c
 8000a60: bf34         	ite	lo
 8000a62: 2001         	movlo	r0, #0x1
 8000a64: 2000         	movhs	r0, #0x0
 8000a66: f85d fb08    	ldr	pc, [sp], #8
 8000a6a: bf00         	nop

08000a6c <__aeabi_fcmple>:
 8000a6c: f84d ed08    	str	lr, [sp, #-8]!
 8000a70: f7ff ffe0    	bl	0x8000a34 <__aeabi_cfcmple> @ imm = #-0x40
 8000a74: bf94         	ite	ls
 8000a76: 2001         	movls	r0, #0x1
 8000a78: 2000         	movhi	r0, #0x0
 8000a7a: f85d fb08    	ldr	pc, [sp], #8
 8000a7e: bf00         	nop

08000a80 <__aeabi_fcmpge>:
 8000a80: f84d ed08    	str	lr, [sp, #-8]!
 8000a84: f7ff ffd2    	bl	0x8000a2c <__aeabi_cfrcmple> @ imm = #-0x5c
 8000a88: bf94         	ite	ls
 8000a8a: 2001         	movls	r0, #0x1
 8000a8c: 2000         	movhi	r0, #0x0
 8000a8e: f85d fb08    	ldr	pc, [sp], #8
 8000a92: bf00         	nop

08000a94 <__aeabi_fcmpgt>:
 8000a94: f84d ed08    	str	lr, [sp, #-8]!
 8000a98: f7ff ffc8    	bl	0x8000a2c <__aeabi_cfrcmple> @ imm = #-0x70
 8000a9c: bf34         	ite	lo
 8000a9e: 2001         	movlo	r0, #0x1
 8000aa0: 2000         	movhs	r0, #0x0
 8000aa2: f85d fb08    	ldr	pc, [sp], #8
 8000aa6: bf00         	nop

08000aa8 <__fixsfsi>:
 8000aa8: ea4f 0240    	lsl.w	r2, r0, #0x1
 8000aac: f1b2 4ffe    	cmp.w	r2, #0x7f000000
 8000ab0: d30f         	blo	0x8000ad2 <__fixsfsi+0x2a> @ imm = #0x1e
 8000ab2: f04f 039e    	mov.w	r3, #0x9e
 8000ab6: ebb3 6212    	subs.w	r2, r3, r2, lsr #24
 8000aba: d90d         	bls	0x8000ad8 <__fixsfsi+0x30> @ imm = #0x1a
 8000abc: ea4f 2300    	lsl.w	r3, r0, #0x8
 8000ac0: f043 4300    	orr	r3, r3, #0x80000000
 8000ac4: f010 4f00    	tst.w	r0, #0x80000000
 8000ac8: fa23 f002    	lsr.w	r0, r3, r2
 8000acc: bf18         	it	ne
 8000ace: 4240         	rsbne	r0, r0, #0
 8000ad0: 4770         	bx	lr
 8000ad2: f04f 0000    	mov.w	r0, #0x0
 8000ad6: 4770         	bx	lr
 8000ad8: f112 0f61    	cmn.w	r2, #0x61
 8000adc: d101         	bne	0x8000ae2 <__fixsfsi+0x3a> @ imm = #0x2
 8000ade: 0242         	lsls	r2, r0, #0x9
 8000ae0: d105         	bne	0x8000aee <__fixsfsi+0x46> @ imm = #0xa
 8000ae2: f010 4000    	ands	r0, r0, #0x80000000
 8000ae6: bf08         	it	eq
 8000ae8: f06f 4000    	mvneq	r0, #0x80000000
 8000aec: 4770         	bx	lr
 8000aee: f04f 0000    	mov.w	r0, #0x0
 8000af2: 4770         	bx	lr

08000af4 <__aeabi_uldivmod>:
 8000af4: b953         	cbnz	r3, 0x8000b0c <__aeabi_uldivmod+0x18> @ imm = #0x14
 8000af6: b94a         	cbnz	r2, 0x8000b0c <__aeabi_uldivmod+0x18> @ imm = #0x12
 8000af8: 2900         	cmp	r1, #0x0
 8000afa: bf08         	it	eq
 8000afc: 2800         	cmpeq	r0, #0x0
 8000afe: bf1c         	itt	ne
 8000b00: f04f 31ff    	movne.w	r1, #0xffffffff
 8000b04: f04f 30ff    	movne.w	r0, #0xffffffff
 8000b08: f000 b80c    	b.w	0x8000b24 <__aeabi_ldiv0> @ imm = #0x18
 8000b0c: f1ad 0c08    	sub.w	r12, sp, #0x8
 8000b10: e96d ce04    	strd	r12, lr, [sp, #-16]!
 8000b14: f000 f81a    	bl	0x8000b4c <__udivmoddi4> @ imm = #0x34
 8000b18: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000b1c: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 8000b20: b004         	add	sp, #0x10
 8000b22: 4770         	bx	lr

08000b24 <__aeabi_ldiv0>:
 8000b24: 4770         	bx	lr
 8000b26: bf00         	nop

08000b28 <strcmp>:
 8000b28: f810 2b01    	ldrb	r2, [r0], #1
 8000b2c: f811 3b01    	ldrb	r3, [r1], #1
 8000b30: 2a01         	cmp	r2, #0x1
 8000b32: bf28         	it	hs
 8000b34: 429a         	cmphs	r2, r3
 8000b36: d0f7         	beq	0x8000b28 <strcmp>      @ imm = #-0x12
 8000b38: 1ad0         	subs	r0, r2, r3
 8000b3a: 4770         	bx	lr

08000b3c <strlen>:
 8000b3c: 4603         	mov	r3, r0
 8000b3e: f813 2b01    	ldrb	r2, [r3], #1
 8000b42: 2a00         	cmp	r2, #0x0
 8000b44: d1fb         	bne	0x8000b3e <strlen+0x2>  @ imm = #-0xa
 8000b46: 1a18         	subs	r0, r3, r0
 8000b48: 3801         	subs	r0, #0x1
 8000b4a: 4770         	bx	lr

08000b4c <__udivmoddi4>:
 8000b4c: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 8000b50: 4686         	mov	lr, r0
 8000b52: 468c         	mov	r12, r1
 8000b54: 4608         	mov	r0, r1
 8000b56: 9e08         	ldr	r6, [sp, #0x20]
 8000b58: 4615         	mov	r5, r2
 8000b5a: 4674         	mov	r4, lr
 8000b5c: 4619         	mov	r1, r3
 8000b5e: 2b00         	cmp	r3, #0x0
 8000b60: f040 80c2    	bne.w	0x8000ce8 <__udivmoddi4+0x19c> @ imm = #0x184
 8000b64: 4285         	cmp	r5, r0
 8000b66: fab2 f282    	clz	r2, r2
 8000b6a: d945         	bls	0x8000bf8 <__udivmoddi4+0xac> @ imm = #0x8a
 8000b6c: b14a         	cbz	r2, 0x8000b82 <__udivmoddi4+0x36> @ imm = #0x12
 8000b6e: f1c2 0320    	rsb.w	r3, r2, #0x20
 8000b72: fa00 fc02    	lsl.w	r12, r0, r2
 8000b76: fa2e f303    	lsr.w	r3, lr, r3
 8000b7a: 4095         	lsls	r5, r2
 8000b7c: ea43 0c0c    	orr.w	r12, r3, r12
 8000b80: 4094         	lsls	r4, r2
 8000b82: ea4f 4e15    	lsr.w	lr, r5, #0x10
 8000b86: b2a8         	uxth	r0, r5
 8000b88: fbbc f8fe    	udiv	r8, r12, lr
 8000b8c: 0c23         	lsrs	r3, r4, #0x10
 8000b8e: fb0e cc18    	mls	r12, lr, r8, r12
 8000b92: fb08 f900    	mul	r9, r8, r0
 8000b96: ea43 430c    	orr.w	r3, r3, r12, lsl #16
 8000b9a: 4599         	cmp	r9, r3
 8000b9c: d928         	bls	0x8000bf0 <__udivmoddi4+0xa4> @ imm = #0x50
 8000b9e: 18eb         	adds	r3, r5, r3
 8000ba0: f108 37ff    	add.w	r7, r8, #0xffffffff
 8000ba4: d204         	bhs	0x8000bb0 <__udivmoddi4+0x64> @ imm = #0x8
 8000ba6: 4599         	cmp	r9, r3
 8000ba8: d902         	bls	0x8000bb0 <__udivmoddi4+0x64> @ imm = #0x4
 8000baa: f1a8 0702    	sub.w	r7, r8, #0x2
 8000bae: 442b         	add	r3, r5
 8000bb0: eba3 0309    	sub.w	r3, r3, r9
 8000bb4: b2a4         	uxth	r4, r4
 8000bb6: fbb3 fcfe    	udiv	r12, r3, lr
 8000bba: fb0e 331c    	mls	r3, lr, r12, r3
 8000bbe: fb0c f000    	mul	r0, r12, r0
 8000bc2: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 8000bc6: 42a0         	cmp	r0, r4
 8000bc8: d914         	bls	0x8000bf4 <__udivmoddi4+0xa8> @ imm = #0x28
 8000bca: 192c         	adds	r4, r5, r4
 8000bcc: f10c 33ff    	add.w	r3, r12, #0xffffffff
 8000bd0: d204         	bhs	0x8000bdc <__udivmoddi4+0x90> @ imm = #0x8
 8000bd2: 42a0         	cmp	r0, r4
 8000bd4: d902         	bls	0x8000bdc <__udivmoddi4+0x90> @ imm = #0x4
 8000bd6: f1ac 0302    	sub.w	r3, r12, #0x2
 8000bda: 442c         	add	r4, r5
 8000bdc: 1a24         	subs	r4, r4, r0
 8000bde: ea43 4007    	orr.w	r0, r3, r7, lsl #16
 8000be2: b11e         	cbz	r6, 0x8000bec <__udivmoddi4+0xa0> @ imm = #0x6
 8000be4: 40d4         	lsrs	r4, r2
 8000be6: 2300         	movs	r3, #0x0
 8000be8: 6034         	str	r4, [r6]
 8000bea: 6073         	str	r3, [r6, #0x4]
 8000bec: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}
 8000bf0: 4647         	mov	r7, r8
 8000bf2: e7dd         	b	0x8000bb0 <__udivmoddi4+0x64> @ imm = #-0x46
 8000bf4: 4663         	mov	r3, r12
 8000bf6: e7f1         	b	0x8000bdc <__udivmoddi4+0x90> @ imm = #-0x1e
 8000bf8: bb92         	cbnz	r2, 0x8000c60 <__udivmoddi4+0x114> @ imm = #0x64
 8000bfa: 1b43         	subs	r3, r0, r5
 8000bfc: 2101         	movs	r1, #0x1
 8000bfe: ea4f 4e15    	lsr.w	lr, r5, #0x10
 8000c02: b2af         	uxth	r7, r5
 8000c04: fbb3 fcfe    	udiv	r12, r3, lr
 8000c08: 0c20         	lsrs	r0, r4, #0x10
 8000c0a: fb0e 331c    	mls	r3, lr, r12, r3
 8000c0e: fb0c f807    	mul	r8, r12, r7
 8000c12: ea40 4303    	orr.w	r3, r0, r3, lsl #16
 8000c16: 4598         	cmp	r8, r3
 8000c18: d962         	bls	0x8000ce0 <__udivmoddi4+0x194> @ imm = #0xc4
 8000c1a: 18eb         	adds	r3, r5, r3
 8000c1c: f10c 30ff    	add.w	r0, r12, #0xffffffff
 8000c20: d204         	bhs	0x8000c2c <__udivmoddi4+0xe0> @ imm = #0x8
 8000c22: 4598         	cmp	r8, r3
 8000c24: d902         	bls	0x8000c2c <__udivmoddi4+0xe0> @ imm = #0x4
 8000c26: f1ac 0002    	sub.w	r0, r12, #0x2
 8000c2a: 442b         	add	r3, r5
 8000c2c: eba3 0308    	sub.w	r3, r3, r8
 8000c30: b2a4         	uxth	r4, r4
 8000c32: fbb3 fcfe    	udiv	r12, r3, lr
 8000c36: fb0e 331c    	mls	r3, lr, r12, r3
 8000c3a: fb0c f707    	mul	r7, r12, r7
 8000c3e: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 8000c42: 42a7         	cmp	r7, r4
 8000c44: d94e         	bls	0x8000ce4 <__udivmoddi4+0x198> @ imm = #0x9c
 8000c46: 192c         	adds	r4, r5, r4
 8000c48: f10c 33ff    	add.w	r3, r12, #0xffffffff
 8000c4c: d204         	bhs	0x8000c58 <__udivmoddi4+0x10c> @ imm = #0x8
 8000c4e: 42a7         	cmp	r7, r4
 8000c50: d902         	bls	0x8000c58 <__udivmoddi4+0x10c> @ imm = #0x4
 8000c52: f1ac 0302    	sub.w	r3, r12, #0x2
 8000c56: 442c         	add	r4, r5
 8000c58: 1be4         	subs	r4, r4, r7
 8000c5a: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 8000c5e: e7c0         	b	0x8000be2 <__udivmoddi4+0x96> @ imm = #-0x80
 8000c60: f1c2 0320    	rsb.w	r3, r2, #0x20
 8000c64: fa20 f103    	lsr.w	r1, r0, r3
 8000c68: 4095         	lsls	r5, r2
 8000c6a: 4090         	lsls	r0, r2
 8000c6c: fa2e f303    	lsr.w	r3, lr, r3
 8000c70: 4303         	orrs	r3, r0
 8000c72: ea4f 4e15    	lsr.w	lr, r5, #0x10
 8000c76: b2af         	uxth	r7, r5
 8000c78: fbb1 fcfe    	udiv	r12, r1, lr
 8000c7c: fb0e 101c    	mls	r0, lr, r12, r1
 8000c80: 0c19         	lsrs	r1, r3, #0x10
 8000c82: fb0c f807    	mul	r8, r12, r7
 8000c86: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 8000c8a: 4588         	cmp	r8, r1
 8000c8c: fa04 f402    	lsl.w	r4, r4, r2
 8000c90: d922         	bls	0x8000cd8 <__udivmoddi4+0x18c> @ imm = #0x44
 8000c92: 1869         	adds	r1, r5, r1
 8000c94: f10c 30ff    	add.w	r0, r12, #0xffffffff
 8000c98: d204         	bhs	0x8000ca4 <__udivmoddi4+0x158> @ imm = #0x8
 8000c9a: 4588         	cmp	r8, r1
 8000c9c: d902         	bls	0x8000ca4 <__udivmoddi4+0x158> @ imm = #0x4
 8000c9e: f1ac 0002    	sub.w	r0, r12, #0x2
 8000ca2: 4429         	add	r1, r5
 8000ca4: eba1 0108    	sub.w	r1, r1, r8
 8000ca8: b29b         	uxth	r3, r3
 8000caa: fbb1 fcfe    	udiv	r12, r1, lr
 8000cae: fb0e 111c    	mls	r1, lr, r12, r1
 8000cb2: fb0c f707    	mul	r7, r12, r7
 8000cb6: ea43 4301    	orr.w	r3, r3, r1, lsl #16
 8000cba: 429f         	cmp	r7, r3
 8000cbc: d90e         	bls	0x8000cdc <__udivmoddi4+0x190> @ imm = #0x1c
 8000cbe: 18eb         	adds	r3, r5, r3
 8000cc0: f10c 31ff    	add.w	r1, r12, #0xffffffff
 8000cc4: d204         	bhs	0x8000cd0 <__udivmoddi4+0x184> @ imm = #0x8
 8000cc6: 429f         	cmp	r7, r3
 8000cc8: d902         	bls	0x8000cd0 <__udivmoddi4+0x184> @ imm = #0x4
 8000cca: f1ac 0102    	sub.w	r1, r12, #0x2
 8000cce: 442b         	add	r3, r5
 8000cd0: 1bdb         	subs	r3, r3, r7
 8000cd2: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 8000cd6: e792         	b	0x8000bfe <__udivmoddi4+0xb2> @ imm = #-0xdc
 8000cd8: 4660         	mov	r0, r12
 8000cda: e7e3         	b	0x8000ca4 <__udivmoddi4+0x158> @ imm = #-0x3a
 8000cdc: 4661         	mov	r1, r12
 8000cde: e7f7         	b	0x8000cd0 <__udivmoddi4+0x184> @ imm = #-0x12
 8000ce0: 4660         	mov	r0, r12
 8000ce2: e7a3         	b	0x8000c2c <__udivmoddi4+0xe0> @ imm = #-0xba
 8000ce4: 4663         	mov	r3, r12
 8000ce6: e7b7         	b	0x8000c58 <__udivmoddi4+0x10c> @ imm = #-0x92
 8000ce8: 4283         	cmp	r3, r0
 8000cea: d906         	bls	0x8000cfa <__udivmoddi4+0x1ae> @ imm = #0xc
 8000cec: b916         	cbnz	r6, 0x8000cf4 <__udivmoddi4+0x1a8> @ imm = #0x4
 8000cee: 2100         	movs	r1, #0x0
 8000cf0: 4608         	mov	r0, r1
 8000cf2: e77b         	b	0x8000bec <__udivmoddi4+0xa0> @ imm = #-0x10a
 8000cf4: e9c6 e000    	strd	lr, r0, [r6]
 8000cf8: e7f9         	b	0x8000cee <__udivmoddi4+0x1a2> @ imm = #-0xe
 8000cfa: fab3 f783    	clz	r7, r3
 8000cfe: b98f         	cbnz	r7, 0x8000d24 <__udivmoddi4+0x1d8> @ imm = #0x22
 8000d00: 4283         	cmp	r3, r0
 8000d02: d301         	blo	0x8000d08 <__udivmoddi4+0x1bc> @ imm = #0x2
 8000d04: 4572         	cmp	r2, lr
 8000d06: d808         	bhi	0x8000d1a <__udivmoddi4+0x1ce> @ imm = #0x10
 8000d08: ebbe 0402    	subs.w	r4, lr, r2
 8000d0c: eb60 0303    	sbc.w	r3, r0, r3
 8000d10: 2001         	movs	r0, #0x1
 8000d12: 469c         	mov	r12, r3
 8000d14: b91e         	cbnz	r6, 0x8000d1e <__udivmoddi4+0x1d2> @ imm = #0x6
 8000d16: 2100         	movs	r1, #0x0
 8000d18: e768         	b	0x8000bec <__udivmoddi4+0xa0> @ imm = #-0x130
 8000d1a: 4638         	mov	r0, r7
 8000d1c: e7fa         	b	0x8000d14 <__udivmoddi4+0x1c8> @ imm = #-0xc
 8000d1e: e9c6 4c00    	strd	r4, r12, [r6]
 8000d22: e7f8         	b	0x8000d16 <__udivmoddi4+0x1ca> @ imm = #-0x10
 8000d24: f1c7 0c20    	rsb.w	r12, r7, #0x20
 8000d28: 40bb         	lsls	r3, r7
 8000d2a: fa22 f40c    	lsr.w	r4, r2, r12
 8000d2e: 431c         	orrs	r4, r3
 8000d30: fa2e f10c    	lsr.w	r1, lr, r12
 8000d34: fa20 f30c    	lsr.w	r3, r0, r12
 8000d38: 40b8         	lsls	r0, r7
 8000d3a: 4301         	orrs	r1, r0
 8000d3c: ea4f 4914    	lsr.w	r9, r4, #0x10
 8000d40: fa0e f507    	lsl.w	r5, lr, r7
 8000d44: fbb3 f8f9    	udiv	r8, r3, r9
 8000d48: fa1f fe84    	uxth.w	lr, r4
 8000d4c: fb09 3018    	mls	r0, r9, r8, r3
 8000d50: 0c0b         	lsrs	r3, r1, #0x10
 8000d52: fb08 fa0e    	mul	r10, r8, lr
 8000d56: ea43 4300    	orr.w	r3, r3, r0, lsl #16
 8000d5a: 459a         	cmp	r10, r3
 8000d5c: fa02 f207    	lsl.w	r2, r2, r7
 8000d60: d940         	bls	0x8000de4 <__udivmoddi4+0x298> @ imm = #0x80
 8000d62: 18e3         	adds	r3, r4, r3
 8000d64: f108 30ff    	add.w	r0, r8, #0xffffffff
 8000d68: d204         	bhs	0x8000d74 <__udivmoddi4+0x228> @ imm = #0x8
 8000d6a: 459a         	cmp	r10, r3
 8000d6c: d902         	bls	0x8000d74 <__udivmoddi4+0x228> @ imm = #0x4
 8000d6e: f1a8 0002    	sub.w	r0, r8, #0x2
 8000d72: 4423         	add	r3, r4
 8000d74: eba3 030a    	sub.w	r3, r3, r10
 8000d78: b289         	uxth	r1, r1
 8000d7a: fbb3 f8f9    	udiv	r8, r3, r9
 8000d7e: fb09 3318    	mls	r3, r9, r8, r3
 8000d82: fb08 fe0e    	mul	lr, r8, lr
 8000d86: ea41 4103    	orr.w	r1, r1, r3, lsl #16
 8000d8a: 458e         	cmp	lr, r1
 8000d8c: d92c         	bls	0x8000de8 <__udivmoddi4+0x29c> @ imm = #0x58
 8000d8e: 1861         	adds	r1, r4, r1
 8000d90: f108 33ff    	add.w	r3, r8, #0xffffffff
 8000d94: d204         	bhs	0x8000da0 <__udivmoddi4+0x254> @ imm = #0x8
 8000d96: 458e         	cmp	lr, r1
 8000d98: d902         	bls	0x8000da0 <__udivmoddi4+0x254> @ imm = #0x4
 8000d9a: f1a8 0302    	sub.w	r3, r8, #0x2
 8000d9e: 4421         	add	r1, r4
 8000da0: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 8000da4: fba0 9802    	umull	r9, r8, r0, r2
 8000da8: eba1 010e    	sub.w	r1, r1, lr
 8000dac: 4541         	cmp	r1, r8
 8000dae: 46ce         	mov	lr, r9
 8000db0: 4643         	mov	r3, r8
 8000db2: d302         	blo	0x8000dba <__udivmoddi4+0x26e> @ imm = #0x4
 8000db4: d106         	bne	0x8000dc4 <__udivmoddi4+0x278> @ imm = #0xc
 8000db6: 454d         	cmp	r5, r9
 8000db8: d204         	bhs	0x8000dc4 <__udivmoddi4+0x278> @ imm = #0x8
 8000dba: ebb9 0e02    	subs.w	lr, r9, r2
 8000dbe: eb68 0304    	sbc.w	r3, r8, r4
 8000dc2: 3801         	subs	r0, #0x1
 8000dc4: 2e00         	cmp	r6, #0x0
 8000dc6: d0a6         	beq	0x8000d16 <__udivmoddi4+0x1ca> @ imm = #-0xb4
 8000dc8: ebb5 020e    	subs.w	r2, r5, lr
 8000dcc: eb61 0103    	sbc.w	r1, r1, r3
 8000dd0: fa01 fc0c    	lsl.w	r12, r1, r12
 8000dd4: fa22 f307    	lsr.w	r3, r2, r7
 8000dd8: ea4c 0303    	orr.w	r3, r12, r3
 8000ddc: 40f9         	lsrs	r1, r7
 8000dde: e9c6 3100    	strd	r3, r1, [r6]
 8000de2: e798         	b	0x8000d16 <__udivmoddi4+0x1ca> @ imm = #-0xd0
 8000de4: 4640         	mov	r0, r8
 8000de6: e7c5         	b	0x8000d74 <__udivmoddi4+0x228> @ imm = #-0x76
 8000de8: 4643         	mov	r3, r8
 8000dea: e7d9         	b	0x8000da0 <__udivmoddi4+0x254> @ imm = #-0x4e

08000dec <z_impl_motor_get_torque>:
; static inline float z_impl_motor_get_torque(const struct device *dev) {
 8000dec: b580         	push	{r7, lr}
 8000dee: b084         	sub	sp, #0x10
 8000df0: af00         	add	r7, sp, #0x0
 8000df2: 6078         	str	r0, [r7, #0x4]
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 8000df4: 687b         	ldr	r3, [r7, #0x4]
 8000df6: 689b         	ldr	r3, [r3, #0x8]
 8000df8: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_get_torque == NULL) {
 8000dfa: 68fb         	ldr	r3, [r7, #0xc]
 8000dfc: 685b         	ldr	r3, [r3, #0x4]
 8000dfe: 2b00         	cmp	r3, #0x0
 8000e00: d101         	bne	0x8000e06 <z_impl_motor_get_torque+0x1a> @ imm = #0x2
;         return -ENOSYS;
 8000e02: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8000e18 <z_impl_motor_get_torque+0x2c>
 8000e04: e004         	b	0x8000e10 <z_impl_motor_get_torque+0x24> @ imm = #0x8
;     return api->motor_get_torque(dev);
 8000e06: 68fb         	ldr	r3, [r7, #0xc]
 8000e08: 685b         	ldr	r3, [r3, #0x4]
 8000e0a: 6878         	ldr	r0, [r7, #0x4]
 8000e0c: 4798         	blx	r3
 8000e0e: 4603         	mov	r3, r0
; }
 8000e10: 4618         	mov	r0, r3
 8000e12: 3710         	adds	r7, #0x10
 8000e14: 46bd         	mov	sp, r7
 8000e16: bd80         	pop	{r7, pc}

08000e18 <$d>:
 8000e18: 00 00 b0 c2  	.word	0xc2b00000

08000e1c <z_impl_motor_get_speed>:
; static inline float z_impl_motor_get_speed(const struct device *dev) {
 8000e1c: b580         	push	{r7, lr}
 8000e1e: b084         	sub	sp, #0x10
 8000e20: af00         	add	r7, sp, #0x0
 8000e22: 6078         	str	r0, [r7, #0x4]
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 8000e24: 687b         	ldr	r3, [r7, #0x4]
 8000e26: 689b         	ldr	r3, [r3, #0x8]
 8000e28: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_get_speed == NULL) {
 8000e2a: 68fb         	ldr	r3, [r7, #0xc]
 8000e2c: 681b         	ldr	r3, [r3]
 8000e2e: 2b00         	cmp	r3, #0x0
 8000e30: d101         	bne	0x8000e36 <z_impl_motor_get_speed+0x1a> @ imm = #0x2
;         return -ENOSYS;
 8000e32: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8000e48 <z_impl_motor_get_speed+0x2c>
 8000e34: e004         	b	0x8000e40 <z_impl_motor_get_speed+0x24> @ imm = #0x8
;     return api->motor_get_speed(dev);
 8000e36: 68fb         	ldr	r3, [r7, #0xc]
 8000e38: 681b         	ldr	r3, [r3]
 8000e3a: 6878         	ldr	r0, [r7, #0x4]
 8000e3c: 4798         	blx	r3
 8000e3e: 4603         	mov	r3, r0
; }
 8000e40: 4618         	mov	r0, r3
 8000e42: 3710         	adds	r7, #0x10
 8000e44: 46bd         	mov	sp, r7
 8000e46: bd80         	pop	{r7, pc}

08000e48 <$d>:
 8000e48: 00 00 b0 c2  	.word	0xc2b00000

08000e4c <z_impl_motor_get_angle>:
; static inline float z_impl_motor_get_angle(const struct device *dev) {
 8000e4c: b580         	push	{r7, lr}
 8000e4e: b084         	sub	sp, #0x10
 8000e50: af00         	add	r7, sp, #0x0
 8000e52: 6078         	str	r0, [r7, #0x4]
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 8000e54: 687b         	ldr	r3, [r7, #0x4]
 8000e56: 689b         	ldr	r3, [r3, #0x8]
 8000e58: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_get_angle == NULL) {
 8000e5a: 68fb         	ldr	r3, [r7, #0xc]
 8000e5c: 689b         	ldr	r3, [r3, #0x8]
 8000e5e: 2b00         	cmp	r3, #0x0
 8000e60: d101         	bne	0x8000e66 <z_impl_motor_get_angle+0x1a> @ imm = #0x2
;         return -ENOSYS;
 8000e62: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8000e78 <z_impl_motor_get_angle+0x2c>
 8000e64: e004         	b	0x8000e70 <z_impl_motor_get_angle+0x24> @ imm = #0x8
;     return api->motor_get_angle(dev);
 8000e66: 68fb         	ldr	r3, [r7, #0xc]
 8000e68: 689b         	ldr	r3, [r3, #0x8]
 8000e6a: 6878         	ldr	r0, [r7, #0x4]
 8000e6c: 4798         	blx	r3
 8000e6e: 4603         	mov	r3, r0
; }
 8000e70: 4618         	mov	r0, r3
 8000e72: 3710         	adds	r7, #0x10
 8000e74: 46bd         	mov	sp, r7
 8000e76: bd80         	pop	{r7, pc}

08000e78 <$d>:
 8000e78: 00 00 b0 c2  	.word	0xc2b00000

08000e7c <z_impl_motor_set_zero>:
; static inline float z_impl_motor_set_zero(const struct device *dev) {
 8000e7c: b580         	push	{r7, lr}
 8000e7e: b084         	sub	sp, #0x10
 8000e80: af00         	add	r7, sp, #0x0
 8000e82: 6078         	str	r0, [r7, #0x4]
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 8000e84: 687b         	ldr	r3, [r7, #0x4]
 8000e86: 689b         	ldr	r3, [r3, #0x8]
 8000e88: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_set_zero == NULL) {
 8000e8a: 68fb         	ldr	r3, [r7, #0xc]
 8000e8c: 699b         	ldr	r3, [r3, #0x18]
 8000e8e: 2b00         	cmp	r3, #0x0
 8000e90: d101         	bne	0x8000e96 <z_impl_motor_set_zero+0x1a> @ imm = #0x2
;         return -ENOSYS;
 8000e92: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8000ea8 <z_impl_motor_set_zero+0x2c>
 8000e94: e004         	b	0x8000ea0 <z_impl_motor_set_zero+0x24> @ imm = #0x8
;     return api->motor_set_zero(dev);
 8000e96: 68fb         	ldr	r3, [r7, #0xc]
 8000e98: 699b         	ldr	r3, [r3, #0x18]
 8000e9a: 6878         	ldr	r0, [r7, #0x4]
 8000e9c: 4798         	blx	r3
 8000e9e: 4603         	mov	r3, r0
; }
 8000ea0: 4618         	mov	r0, r3
 8000ea2: 3710         	adds	r7, #0x10
 8000ea4: 46bd         	mov	sp, r7
 8000ea6: bd80         	pop	{r7, pc}

08000ea8 <$d>:
 8000ea8: 00 00 b0 c2  	.word	0xc2b00000

08000eac <console_feedback>:
; void console_feedback(void *arg1, void *arg2, void *arg3) {
 8000eac: b590         	push	{r4, r7, lr}
 8000eae: b09b         	sub	sp, #0x6c
 8000eb0: af06         	add	r7, sp, #0x18
 8000eb2: 60f8         	str	r0, [r7, #0xc]
 8000eb4: 60b9         	str	r1, [r7, #0x8]
 8000eb6: 607a         	str	r2, [r7, #0x4]
;         LOG_INF("rpm: motor1:%.2f\n", (double)motor_get_speed(motor1));
 8000eb8: 2304         	movs	r3, #0x4
 8000eba: 2b02         	cmp	r3, #0x2
 8000ebc: d924         	bls	0x8000f08 <console_feedback+0x5c> @ imm = #0x48
 8000ebe: 2301         	movs	r3, #0x1
 8000ec0: 74fb         	strb	r3, [r7, #0x13]
 8000ec2: 7cfb         	ldrb	r3, [r7, #0x13]
 8000ec4: f083 0301    	eor	r3, r3, #0x1
 8000ec8: b2db         	uxtb	r3, r3
 8000eca: 2b00         	cmp	r3, #0x0
 8000ecc: d11c         	bne	0x8000f08 <console_feedback+0x5c> @ imm = #0x38
 8000ece: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8001180 <console_feedback+0x2d4>
 8000ed0: 681c         	ldr	r4, [r3]
 8000ed2: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8001184 <console_feedback+0x2d8>
 8000ed4: 681b         	ldr	r3, [r3]
 8000ed6: 4618         	mov	r0, r3
 8000ed8: f00f fa8c    	bl	0x80103f4 <motor_get_speed> @ imm = #0xf518
 8000edc: 4603         	mov	r3, r0
 8000ede: 4618         	mov	r0, r3
 8000ee0: f7ff fab6    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xa94
 8000ee4: 4602         	mov	r2, r0
 8000ee6: 460b         	mov	r3, r1
 8000ee8: e9cd 2304    	strd	r2, r3, [sp, #16]
 8000eec: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8001188 <console_feedback+0x2dc>
 8000eee: 9302         	str	r3, [sp, #0x8]
 8000ef0: 2300         	movs	r3, #0x0
 8000ef2: 9301         	str	r3, [sp, #0x4]
 8000ef4: 2300         	movs	r3, #0x0
 8000ef6: 9300         	str	r3, [sp]
 8000ef8: 2300         	movs	r3, #0x0
 8000efa: 2203         	movs	r2, #0x3
 8000efc: 4621         	mov	r1, r4
 8000efe: 2000         	movs	r0, #0x0
 8000f00: f00f f9c2    	bl	0x8010288 <z_log_msg_runtime_create> @ imm = #0xf384
 8000f04: 2300         	movs	r3, #0x0
 8000f06: 61fb         	str	r3, [r7, #0x1c]
;         LOG_INF("torque: motor1:%.2f\n", (double)motor_get_torque(motor1));
 8000f08: 2304         	movs	r3, #0x4
 8000f0a: 2b02         	cmp	r3, #0x2
 8000f0c: d924         	bls	0x8000f58 <console_feedback+0xac> @ imm = #0x48
 8000f0e: 2301         	movs	r3, #0x1
 8000f10: 76fb         	strb	r3, [r7, #0x1b]
 8000f12: 7efb         	ldrb	r3, [r7, #0x1b]
 8000f14: f083 0301    	eor	r3, r3, #0x1
 8000f18: b2db         	uxtb	r3, r3
 8000f1a: 2b00         	cmp	r3, #0x0
 8000f1c: d11c         	bne	0x8000f58 <console_feedback+0xac> @ imm = #0x38
 8000f1e: 4b98         	ldr	r3, [pc, #0x260]        @ 0x8001180 <console_feedback+0x2d4>
 8000f20: 681c         	ldr	r4, [r3]
 8000f22: 4b98         	ldr	r3, [pc, #0x260]        @ 0x8001184 <console_feedback+0x2d8>
 8000f24: 681b         	ldr	r3, [r3]
 8000f26: 4618         	mov	r0, r3
 8000f28: f00f fa58    	bl	0x80103dc <motor_get_torque> @ imm = #0xf4b0
 8000f2c: 4603         	mov	r3, r0
 8000f2e: 4618         	mov	r0, r3
 8000f30: f7ff fa8e    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xae4
 8000f34: 4602         	mov	r2, r0
 8000f36: 460b         	mov	r3, r1
 8000f38: e9cd 2304    	strd	r2, r3, [sp, #16]
 8000f3c: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x800118c <console_feedback+0x2e0>
 8000f3e: 9302         	str	r3, [sp, #0x8]
 8000f40: 2300         	movs	r3, #0x0
 8000f42: 9301         	str	r3, [sp, #0x4]
 8000f44: 2300         	movs	r3, #0x0
 8000f46: 9300         	str	r3, [sp]
 8000f48: 2300         	movs	r3, #0x0
 8000f4a: 2203         	movs	r2, #0x3
 8000f4c: 4621         	mov	r1, r4
 8000f4e: 2000         	movs	r0, #0x0
 8000f50: f00f f99a    	bl	0x8010288 <z_log_msg_runtime_create> @ imm = #0xf334
 8000f54: 2300         	movs	r3, #0x0
 8000f56: 617b         	str	r3, [r7, #0x14]
;         LOG_INF("angle: motor1:%.2f\n", (double)motor_get_angle(motor1));
 8000f58: 2304         	movs	r3, #0x4
 8000f5a: 2b02         	cmp	r3, #0x2
 8000f5c: d926         	bls	0x8000fac <console_feedback+0x100> @ imm = #0x4c
 8000f5e: 2301         	movs	r3, #0x1
 8000f60: f887 3023    	strb.w	r3, [r7, #0x23]
 8000f64: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8000f68: f083 0301    	eor	r3, r3, #0x1
 8000f6c: b2db         	uxtb	r3, r3
 8000f6e: 2b00         	cmp	r3, #0x0
 8000f70: d11c         	bne	0x8000fac <console_feedback+0x100> @ imm = #0x38
 8000f72: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x8001180 <console_feedback+0x2d4>
 8000f74: 681c         	ldr	r4, [r3]
 8000f76: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x8001184 <console_feedback+0x2d8>
 8000f78: 681b         	ldr	r3, [r3]
 8000f7a: 4618         	mov	r0, r3
 8000f7c: f00f fa46    	bl	0x801040c <motor_get_angle> @ imm = #0xf48c
 8000f80: 4603         	mov	r3, r0
 8000f82: 4618         	mov	r0, r3
 8000f84: f7ff fa64    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xb38
 8000f88: 4602         	mov	r2, r0
 8000f8a: 460b         	mov	r3, r1
 8000f8c: e9cd 2304    	strd	r2, r3, [sp, #16]
 8000f90: 4b7f         	ldr	r3, [pc, #0x1fc]        @ 0x8001190 <console_feedback+0x2e4>
 8000f92: 9302         	str	r3, [sp, #0x8]
 8000f94: 2300         	movs	r3, #0x0
 8000f96: 9301         	str	r3, [sp, #0x4]
 8000f98: 2300         	movs	r3, #0x0
 8000f9a: 9300         	str	r3, [sp]
 8000f9c: 2300         	movs	r3, #0x0
 8000f9e: 2203         	movs	r2, #0x3
 8000fa0: 4621         	mov	r1, r4
 8000fa2: 2000         	movs	r0, #0x0
 8000fa4: f00f f970    	bl	0x8010288 <z_log_msg_runtime_create> @ imm = #0xf2e0
 8000fa8: 2300         	movs	r3, #0x0
 8000faa: 62fb         	str	r3, [r7, #0x2c]
;         LOG_INF("rpm: motor2:%.2f\n", (double)motor_get_speed(motor2));
 8000fac: 2304         	movs	r3, #0x4
 8000fae: 2b02         	cmp	r3, #0x2
 8000fb0: d926         	bls	0x8001000 <console_feedback+0x154> @ imm = #0x4c
 8000fb2: 2301         	movs	r3, #0x1
 8000fb4: f887 302b    	strb.w	r3, [r7, #0x2b]
 8000fb8: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8000fbc: f083 0301    	eor	r3, r3, #0x1
 8000fc0: b2db         	uxtb	r3, r3
 8000fc2: 2b00         	cmp	r3, #0x0
 8000fc4: d11c         	bne	0x8001000 <console_feedback+0x154> @ imm = #0x38
 8000fc6: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8001180 <console_feedback+0x2d4>
 8000fc8: 681c         	ldr	r4, [r3]
 8000fca: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8001194 <console_feedback+0x2e8>
 8000fcc: 681b         	ldr	r3, [r3]
 8000fce: 4618         	mov	r0, r3
 8000fd0: f00f fa10    	bl	0x80103f4 <motor_get_speed> @ imm = #0xf420
 8000fd4: 4603         	mov	r3, r0
 8000fd6: 4618         	mov	r0, r3
 8000fd8: f7ff fa3a    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xb8c
 8000fdc: 4602         	mov	r2, r0
 8000fde: 460b         	mov	r3, r1
 8000fe0: e9cd 2304    	strd	r2, r3, [sp, #16]
 8000fe4: 4b6c         	ldr	r3, [pc, #0x1b0]        @ 0x8001198 <console_feedback+0x2ec>
 8000fe6: 9302         	str	r3, [sp, #0x8]
 8000fe8: 2300         	movs	r3, #0x0
 8000fea: 9301         	str	r3, [sp, #0x4]
 8000fec: 2300         	movs	r3, #0x0
 8000fee: 9300         	str	r3, [sp]
 8000ff0: 2300         	movs	r3, #0x0
 8000ff2: 2203         	movs	r2, #0x3
 8000ff4: 4621         	mov	r1, r4
 8000ff6: 2000         	movs	r0, #0x0
 8000ff8: f00f f946    	bl	0x8010288 <z_log_msg_runtime_create> @ imm = #0xf28c
 8000ffc: 2300         	movs	r3, #0x0
 8000ffe: 627b         	str	r3, [r7, #0x24]
;         LOG_INF("torque: motor2:%.2f\n", (double)motor_get_torque(motor2));
 8001000: 2304         	movs	r3, #0x4
 8001002: 2b02         	cmp	r3, #0x2
 8001004: d926         	bls	0x8001054 <console_feedback+0x1a8> @ imm = #0x4c
 8001006: 2301         	movs	r3, #0x1
 8001008: f887 3033    	strb.w	r3, [r7, #0x33]
 800100c: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8001010: f083 0301    	eor	r3, r3, #0x1
 8001014: b2db         	uxtb	r3, r3
 8001016: 2b00         	cmp	r3, #0x0
 8001018: d11c         	bne	0x8001054 <console_feedback+0x1a8> @ imm = #0x38
 800101a: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8001180 <console_feedback+0x2d4>
 800101c: 681c         	ldr	r4, [r3]
 800101e: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8001194 <console_feedback+0x2e8>
 8001020: 681b         	ldr	r3, [r3]
 8001022: 4618         	mov	r0, r3
 8001024: f00f f9da    	bl	0x80103dc <motor_get_torque> @ imm = #0xf3b4
 8001028: 4603         	mov	r3, r0
 800102a: 4618         	mov	r0, r3
 800102c: f7ff fa10    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xbe0
 8001030: 4602         	mov	r2, r0
 8001032: 460b         	mov	r3, r1
 8001034: e9cd 2304    	strd	r2, r3, [sp, #16]
 8001038: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800119c <console_feedback+0x2f0>
 800103a: 9302         	str	r3, [sp, #0x8]
 800103c: 2300         	movs	r3, #0x0
 800103e: 9301         	str	r3, [sp, #0x4]
 8001040: 2300         	movs	r3, #0x0
 8001042: 9300         	str	r3, [sp]
 8001044: 2300         	movs	r3, #0x0
 8001046: 2203         	movs	r2, #0x3
 8001048: 4621         	mov	r1, r4
 800104a: 2000         	movs	r0, #0x0
 800104c: f00f f91c    	bl	0x8010288 <z_log_msg_runtime_create> @ imm = #0xf238
 8001050: 2300         	movs	r3, #0x0
 8001052: 63fb         	str	r3, [r7, #0x3c]
;         LOG_INF("angle: motor2:%.2f\n", (double)motor_get_angle(motor2));
 8001054: 2304         	movs	r3, #0x4
 8001056: 2b02         	cmp	r3, #0x2
 8001058: d926         	bls	0x80010a8 <console_feedback+0x1fc> @ imm = #0x4c
 800105a: 2301         	movs	r3, #0x1
 800105c: f887 303b    	strb.w	r3, [r7, #0x3b]
 8001060: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8001064: f083 0301    	eor	r3, r3, #0x1
 8001068: b2db         	uxtb	r3, r3
 800106a: 2b00         	cmp	r3, #0x0
 800106c: d11c         	bne	0x80010a8 <console_feedback+0x1fc> @ imm = #0x38
 800106e: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8001180 <console_feedback+0x2d4>
 8001070: 681c         	ldr	r4, [r3]
 8001072: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8001194 <console_feedback+0x2e8>
 8001074: 681b         	ldr	r3, [r3]
 8001076: 4618         	mov	r0, r3
 8001078: f00f f9c8    	bl	0x801040c <motor_get_angle> @ imm = #0xf390
 800107c: 4603         	mov	r3, r0
 800107e: 4618         	mov	r0, r3
 8001080: f7ff f9e6    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xc34
 8001084: 4602         	mov	r2, r0
 8001086: 460b         	mov	r3, r1
 8001088: e9cd 2304    	strd	r2, r3, [sp, #16]
 800108c: 4b44         	ldr	r3, [pc, #0x110]        @ 0x80011a0 <console_feedback+0x2f4>
 800108e: 9302         	str	r3, [sp, #0x8]
 8001090: 2300         	movs	r3, #0x0
 8001092: 9301         	str	r3, [sp, #0x4]
 8001094: 2300         	movs	r3, #0x0
 8001096: 9300         	str	r3, [sp]
 8001098: 2300         	movs	r3, #0x0
 800109a: 2203         	movs	r2, #0x3
 800109c: 4621         	mov	r1, r4
 800109e: 2000         	movs	r0, #0x0
 80010a0: f00f f8f2    	bl	0x8010288 <z_log_msg_runtime_create> @ imm = #0xf1e4
 80010a4: 2300         	movs	r3, #0x0
 80010a6: 637b         	str	r3, [r7, #0x34]
;         for (int i = 0; i < 4; i++) {
 80010a8: 2300         	movs	r3, #0x0
 80010aa: 64bb         	str	r3, [r7, #0x48]
 80010ac: e05f         	b	0x800116e <console_feedback+0x2c2> @ imm = #0xbe
;             LOG_INF("channel %d: %.2f%%\n", i, sbus_get_percent(sbus, i) * 100);
 80010ae: 2304         	movs	r3, #0x4
 80010b0: 2b02         	cmp	r3, #0x2
 80010b2: d930         	bls	0x8001116 <console_feedback+0x26a> @ imm = #0x60
 80010b4: 2301         	movs	r3, #0x1
 80010b6: f887 3042    	strb.w	r3, [r7, #0x42]
 80010ba: f897 3042    	ldrb.w	r3, [r7, #0x42]
 80010be: f083 0301    	eor	r3, r3, #0x1
 80010c2: b2db         	uxtb	r3, r3
 80010c4: 2b00         	cmp	r3, #0x0
 80010c6: d126         	bne	0x8001116 <console_feedback+0x26a> @ imm = #0x4c
 80010c8: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8001180 <console_feedback+0x2d4>
 80010ca: 681c         	ldr	r4, [r3]
 80010cc: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80011a4 <console_feedback+0x2f8>
 80010ce: 681b         	ldr	r3, [r3]
 80010d0: 6cba         	ldr	r2, [r7, #0x48]
 80010d2: b2d2         	uxtb	r2, r2
 80010d4: 4611         	mov	r1, r2
 80010d6: 4618         	mov	r0, r3
 80010d8: f00f fa03    	bl	0x80104e2 <sbus_get_percent> @ imm = #0xf406
 80010dc: 4603         	mov	r3, r0
 80010de: 4932         	ldr	r1, [pc, #0xc8]         @ 0x80011a8 <console_feedback+0x2fc>
 80010e0: 4618         	mov	r0, r3
 80010e2: f7ff fb1b    	bl	0x800071c <__mulsf3>    @ imm = #-0x9ca
 80010e6: 4603         	mov	r3, r0
 80010e8: 4618         	mov	r0, r3
 80010ea: f7ff f9b1    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xc9e
 80010ee: 4602         	mov	r2, r0
 80010f0: 460b         	mov	r3, r1
 80010f2: e9cd 2304    	strd	r2, r3, [sp, #16]
 80010f6: 6cbb         	ldr	r3, [r7, #0x48]
 80010f8: 9303         	str	r3, [sp, #0xc]
 80010fa: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x80011ac <console_feedback+0x300>
 80010fc: 9302         	str	r3, [sp, #0x8]
 80010fe: 2300         	movs	r3, #0x0
 8001100: 9301         	str	r3, [sp, #0x4]
 8001102: 2300         	movs	r3, #0x0
 8001104: 9300         	str	r3, [sp]
 8001106: 2300         	movs	r3, #0x0
 8001108: 2203         	movs	r2, #0x3
 800110a: 4621         	mov	r1, r4
 800110c: 2000         	movs	r0, #0x0
 800110e: f00f f8bb    	bl	0x8010288 <z_log_msg_runtime_create> @ imm = #0xf176
 8001112: 2300         	movs	r3, #0x0
 8001114: 647b         	str	r3, [r7, #0x44]
;             LOG_INF("channel %d: %d\n", i, sbus_get_digit(sbus, i));
 8001116: 2304         	movs	r3, #0x4
 8001118: 2b02         	cmp	r3, #0x2
 800111a: d925         	bls	0x8001168 <console_feedback+0x2bc> @ imm = #0x4a
 800111c: 2301         	movs	r3, #0x1
 800111e: f887 3043    	strb.w	r3, [r7, #0x43]
 8001122: f897 3043    	ldrb.w	r3, [r7, #0x43]
 8001126: f083 0301    	eor	r3, r3, #0x1
 800112a: b2db         	uxtb	r3, r3
 800112c: 2b00         	cmp	r3, #0x0
 800112e: d11b         	bne	0x8001168 <console_feedback+0x2bc> @ imm = #0x36
 8001130: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8001180 <console_feedback+0x2d4>
 8001132: 681c         	ldr	r4, [r3]
 8001134: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x80011a4 <console_feedback+0x2f8>
 8001136: 681b         	ldr	r3, [r3]
 8001138: 6cba         	ldr	r2, [r7, #0x48]
 800113a: b2d2         	uxtb	r2, r2
 800113c: 4611         	mov	r1, r2
 800113e: 4618         	mov	r0, r3
 8001140: f00f f9df    	bl	0x8010502 <sbus_get_digit> @ imm = #0xf3be
 8001144: 4603         	mov	r3, r0
 8001146: 9304         	str	r3, [sp, #0x10]
 8001148: 6cbb         	ldr	r3, [r7, #0x48]
 800114a: 9303         	str	r3, [sp, #0xc]
 800114c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80011b0 <console_feedback+0x304>
 800114e: 9302         	str	r3, [sp, #0x8]
 8001150: 2300         	movs	r3, #0x0
 8001152: 9301         	str	r3, [sp, #0x4]
 8001154: 2300         	movs	r3, #0x0
 8001156: 9300         	str	r3, [sp]
 8001158: 2300         	movs	r3, #0x0
 800115a: 2203         	movs	r2, #0x3
 800115c: 4621         	mov	r1, r4
 800115e: 2000         	movs	r0, #0x0
 8001160: f00f f892    	bl	0x8010288 <z_log_msg_runtime_create> @ imm = #0xf124
 8001164: 2300         	movs	r3, #0x0
 8001166: 64fb         	str	r3, [r7, #0x4c]
;         for (int i = 0; i < 4; i++) {
 8001168: 6cbb         	ldr	r3, [r7, #0x48]
 800116a: 3301         	adds	r3, #0x1
 800116c: 64bb         	str	r3, [r7, #0x48]
 800116e: 6cbb         	ldr	r3, [r7, #0x48]
 8001170: 2b03         	cmp	r3, #0x3
 8001172: dd9c         	ble	0x80010ae <console_feedback+0x202> @ imm = #-0xc8
;         k_msleep(500);
 8001174: f44f 70fa    	mov.w	r0, #0x1f4
 8001178: f00f f8a4    	bl	0x80102c4 <k_msleep>    @ imm = #0xf148
;         LOG_INF("rpm: motor1:%.2f\n", (double)motor_get_speed(motor1));
 800117c: e69c         	b	0x8000eb8 <console_feedback+0xc> @ imm = #-0x2c8
 800117e: bf00         	nop

08001180 <$d>:
 8001180: b0 02 00 20  	.word	0x200002b0
 8001184: b4 02 00 20  	.word	0x200002b4
 8001188: 90 97 01 08  	.word	0x08019790
 800118c: a4 97 01 08  	.word	0x080197a4
 8001190: bc 97 01 08  	.word	0x080197bc
 8001194: b8 02 00 20  	.word	0x200002b8
 8001198: d0 97 01 08  	.word	0x080197d0
 800119c: e4 97 01 08  	.word	0x080197e4
 80011a0: fc 97 01 08  	.word	0x080197fc
 80011a4: c0 02 00 20  	.word	0x200002c0
 80011a8: 00 00 c8 42  	.word	0x42c80000
 80011ac: 10 98 01 08  	.word	0x08019810
 80011b0: 24 98 01 08  	.word	0x08019824

080011b4 <chassis_calc>:
; static void chassis_calc(float vert_x, float vert_y) {
 80011b4: b590         	push	{r4, r7, lr}
 80011b6: b091         	sub	sp, #0x44
 80011b8: af06         	add	r7, sp, #0x18
 80011ba: 6078         	str	r0, [r7, #0x4]
 80011bc: 6039         	str	r1, [r7]
;     float vert_x_rpm = vert_x * 120;
 80011be: 4950         	ldr	r1, [pc, #0x140]        @ 0x8001300 <chassis_calc+0x14c>
 80011c0: 6878         	ldr	r0, [r7, #0x4]
 80011c2: f7ff faab    	bl	0x800071c <__mulsf3>    @ imm = #-0xaaa
 80011c6: 4603         	mov	r3, r0
 80011c8: 61fb         	str	r3, [r7, #0x1c]
;     float vert_y_rpm = vert_y * 120;
 80011ca: 494d         	ldr	r1, [pc, #0x134]        @ 0x8001300 <chassis_calc+0x14c>
 80011cc: 6838         	ldr	r0, [r7]
 80011ce: f7ff faa5    	bl	0x800071c <__mulsf3>    @ imm = #-0xab6
 80011d2: 4603         	mov	r3, r0
 80011d4: 61bb         	str	r3, [r7, #0x18]
;     motor_set_speed(motor1, vert_x_rpm);
 80011d6: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8001304 <chassis_calc+0x150>
 80011d8: 681b         	ldr	r3, [r3]
 80011da: 69f9         	ldr	r1, [r7, #0x1c]
 80011dc: 4618         	mov	r0, r3
 80011de: f00f f921    	bl	0x8010424 <motor_set_speed> @ imm = #0xf242
;     motor_set_speed(motor2, vert_y_rpm);
 80011e2: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8001308 <chassis_calc+0x154>
 80011e4: 681b         	ldr	r3, [r3]
 80011e6: 69b9         	ldr	r1, [r7, #0x18]
 80011e8: 4618         	mov	r0, r3
 80011ea: f00f f91b    	bl	0x8010424 <motor_set_speed> @ imm = #0xf236
;     motor_set_speed(motor3, (vert_x_rpm - vert_y_rpm) / sqrtf(2));
 80011ee: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x800130c <chassis_calc+0x158>
 80011f0: 681c         	ldr	r4, [r3]
 80011f2: 69b9         	ldr	r1, [r7, #0x18]
 80011f4: 69f8         	ldr	r0, [r7, #0x1c]
 80011f6: f7ff f987    	bl	0x8000508 <__subsf3>    @ imm = #-0xcf2
 80011fa: 4603         	mov	r3, r0
 80011fc: 4944         	ldr	r1, [pc, #0x110]        @ 0x8001310 <chassis_calc+0x15c>
 80011fe: 4618         	mov	r0, r3
 8001200: f7ff fb40    	bl	0x8000884 <__divsf3>    @ imm = #-0x980
 8001204: 4603         	mov	r3, r0
 8001206: 4619         	mov	r1, r3
 8001208: 4620         	mov	r0, r4
 800120a: f00f f90b    	bl	0x8010424 <motor_set_speed> @ imm = #0xf216
;     LOG_INF("rpm: motor1: %.2f\n", (double)vert_x_rpm);
 800120e: 2304         	movs	r3, #0x4
 8001210: 2b02         	cmp	r3, #0x2
 8001212: d920         	bls	0x8001256 <chassis_calc+0xa2> @ imm = #0x40
 8001214: 2301         	movs	r3, #0x1
 8001216: f887 3022    	strb.w	r3, [r7, #0x22]
 800121a: f897 3022    	ldrb.w	r3, [r7, #0x22]
 800121e: f083 0301    	eor	r3, r3, #0x1
 8001222: b2db         	uxtb	r3, r3
 8001224: 2b00         	cmp	r3, #0x0
 8001226: d116         	bne	0x8001256 <chassis_calc+0xa2> @ imm = #0x2c
 8001228: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8001314 <chassis_calc+0x160>
 800122a: 681c         	ldr	r4, [r3]
 800122c: 69f8         	ldr	r0, [r7, #0x1c]
 800122e: f7ff f90f    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xde2
 8001232: 4602         	mov	r2, r0
 8001234: 460b         	mov	r3, r1
 8001236: e9cd 2304    	strd	r2, r3, [sp, #16]
 800123a: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8001318 <chassis_calc+0x164>
 800123c: 9302         	str	r3, [sp, #0x8]
 800123e: 2300         	movs	r3, #0x0
 8001240: 9301         	str	r3, [sp, #0x4]
 8001242: 2300         	movs	r3, #0x0
 8001244: 9300         	str	r3, [sp]
 8001246: 2300         	movs	r3, #0x0
 8001248: 2203         	movs	r2, #0x3
 800124a: 4621         	mov	r1, r4
 800124c: 2000         	movs	r0, #0x0
 800124e: f00f f81b    	bl	0x8010288 <z_log_msg_runtime_create> @ imm = #0xf036
 8001252: 2300         	movs	r3, #0x0
 8001254: 627b         	str	r3, [r7, #0x24]
;     LOG_INF("rpm: motor2: %.2f\n", (double)vert_y_rpm);
 8001256: 2304         	movs	r3, #0x4
 8001258: 2b02         	cmp	r3, #0x2
 800125a: d920         	bls	0x800129e <chassis_calc+0xea> @ imm = #0x40
 800125c: 2301         	movs	r3, #0x1
 800125e: f887 3023    	strb.w	r3, [r7, #0x23]
 8001262: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8001266: f083 0301    	eor	r3, r3, #0x1
 800126a: b2db         	uxtb	r3, r3
 800126c: 2b00         	cmp	r3, #0x0
 800126e: d116         	bne	0x800129e <chassis_calc+0xea> @ imm = #0x2c
 8001270: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8001314 <chassis_calc+0x160>
 8001272: 681c         	ldr	r4, [r3]
 8001274: 69b8         	ldr	r0, [r7, #0x18]
 8001276: f7ff f8eb    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xe2a
 800127a: 4602         	mov	r2, r0
 800127c: 460b         	mov	r3, r1
 800127e: e9cd 2304    	strd	r2, r3, [sp, #16]
 8001282: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800131c <chassis_calc+0x168>
 8001284: 9302         	str	r3, [sp, #0x8]
 8001286: 2300         	movs	r3, #0x0
 8001288: 9301         	str	r3, [sp, #0x4]
 800128a: 2300         	movs	r3, #0x0
 800128c: 9300         	str	r3, [sp]
 800128e: 2300         	movs	r3, #0x0
 8001290: 2203         	movs	r2, #0x3
 8001292: 4621         	mov	r1, r4
 8001294: 2000         	movs	r0, #0x0
 8001296: f00e fff7    	bl	0x8010288 <z_log_msg_runtime_create> @ imm = #0xefee
 800129a: 2300         	movs	r3, #0x0
 800129c: 617b         	str	r3, [r7, #0x14]
;     LOG_INF("rpm: motor3: %.2f\n", (double)((vert_x_rpm - vert_y_rpm) / sqrtf(2)));
 800129e: 2304         	movs	r3, #0x4
 80012a0: 2b02         	cmp	r3, #0x2
 80012a2: d929         	bls	0x80012f8 <chassis_calc+0x144> @ imm = #0x52
 80012a4: 2301         	movs	r3, #0x1
 80012a6: 74fb         	strb	r3, [r7, #0x13]
 80012a8: 7cfb         	ldrb	r3, [r7, #0x13]
 80012aa: f083 0301    	eor	r3, r3, #0x1
 80012ae: b2db         	uxtb	r3, r3
 80012b0: 2b00         	cmp	r3, #0x0
 80012b2: d121         	bne	0x80012f8 <chassis_calc+0x144> @ imm = #0x42
 80012b4: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8001314 <chassis_calc+0x160>
 80012b6: 681c         	ldr	r4, [r3]
 80012b8: 69b9         	ldr	r1, [r7, #0x18]
 80012ba: 69f8         	ldr	r0, [r7, #0x1c]
 80012bc: f7ff f924    	bl	0x8000508 <__subsf3>    @ imm = #-0xdb8
 80012c0: 4603         	mov	r3, r0
 80012c2: 4913         	ldr	r1, [pc, #0x4c]         @ 0x8001310 <chassis_calc+0x15c>
 80012c4: 4618         	mov	r0, r3
 80012c6: f7ff fadd    	bl	0x8000884 <__divsf3>    @ imm = #-0xa46
 80012ca: 4603         	mov	r3, r0
 80012cc: 4618         	mov	r0, r3
 80012ce: f7ff f8bf    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xe82
 80012d2: 4602         	mov	r2, r0
 80012d4: 460b         	mov	r3, r1
 80012d6: e9cd 2304    	strd	r2, r3, [sp, #16]
 80012da: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8001320 <chassis_calc+0x16c>
 80012dc: 9302         	str	r3, [sp, #0x8]
 80012de: 2300         	movs	r3, #0x0
 80012e0: 9301         	str	r3, [sp, #0x4]
 80012e2: 2300         	movs	r3, #0x0
 80012e4: 9300         	str	r3, [sp]
 80012e6: 2300         	movs	r3, #0x0
 80012e8: 2203         	movs	r2, #0x3
 80012ea: 4621         	mov	r1, r4
 80012ec: 2000         	movs	r0, #0x0
 80012ee: f00e ffcb    	bl	0x8010288 <z_log_msg_runtime_create> @ imm = #0xef96
 80012f2: 2300         	movs	r3, #0x0
 80012f4: 60fb         	str	r3, [r7, #0xc]
; }
 80012f6: bf00         	nop
 80012f8: bf00         	nop
 80012fa: 372c         	adds	r7, #0x2c
 80012fc: 46bd         	mov	sp, r7
 80012fe: bd90         	pop	{r4, r7, pc}

08001300 <$d>:
 8001300: 00 00 f0 42  	.word	0x42f00000
 8001304: b4 02 00 20  	.word	0x200002b4
 8001308: b8 02 00 20  	.word	0x200002b8
 800130c: bc 02 00 20  	.word	0x200002bc
 8001310: f3 04 b5 3f  	.word	0x3fb504f3
 8001314: b0 02 00 20  	.word	0x200002b0
 8001318: 34 98 01 08  	.word	0x08019834
 800131c: 48 98 01 08  	.word	0x08019848
 8001320: 5c 98 01 08  	.word	0x0801985c

08001324 <main>:
; int main(void) {
 8001324: b590         	push	{r4, r7, lr}
 8001326: b0bd         	sub	sp, #0xf4
 8001328: af08         	add	r7, sp, #0x20
;     motor_set_zero(motor1);
 800132a: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x80013d8 <main+0xb4>
 800132c: 681b         	ldr	r3, [r3]
 800132e: 4618         	mov	r0, r3
 8001330: f00f f894    	bl	0x801045c <motor_set_zero> @ imm = #0xf128
;     motor_set_zero(motor2);
 8001334: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x80013dc <main+0xb8>
 8001336: 681b         	ldr	r3, [r3]
 8001338: 4618         	mov	r0, r3
 800133a: f00f f88f    	bl	0x801045c <motor_set_zero> @ imm = #0xf11e
;     motor_set_zero(motor3);
 800133e: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x80013e0 <main+0xbc>
 8001340: 681b         	ldr	r3, [r3]
 8001342: 4618         	mov	r0, r3
 8001344: f00f f88a    	bl	0x801045c <motor_set_zero> @ imm = #0xf114
;     motor_set_angle(motor1, 0);
 8001348: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80013d8 <main+0xb4>
 800134a: 681b         	ldr	r3, [r3]
 800134c: f04f 0100    	mov.w	r1, #0x0
 8001350: 4618         	mov	r0, r3
 8001352: f00f f875    	bl	0x8010440 <motor_set_angle> @ imm = #0xf0ea
;     motor_set_angle(motor2, 0);
 8001356: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80013dc <main+0xb8>
 8001358: 681b         	ldr	r3, [r3]
 800135a: f04f 0100    	mov.w	r1, #0x0
 800135e: 4618         	mov	r0, r3
 8001360: f00f f86e    	bl	0x8010440 <motor_set_angle> @ imm = #0xf0dc
;     motor_set_angle(motor3, 0);
 8001364: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80013e0 <main+0xbc>
 8001366: 681b         	ldr	r3, [r3]
 8001368: f04f 0100    	mov.w	r1, #0x0
 800136c: 4618         	mov	r0, r3
 800136e: f00f f867    	bl	0x8010440 <motor_set_angle> @ imm = #0xf0ce
;     feedback_tid = k_thread_create(&feedback_thread_data,
 8001372: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80013d8 <main+0xb4>
 8001374: 6819         	ldr	r1, [r3]
;                                    (void *)motor1, NULL, NULL, 0, 0, K_MSEC(300));
 8001376: f640 32b8    	movw	r2, #0xbb8
 800137a: f04f 0300    	mov.w	r3, #0x0
;     feedback_tid = k_thread_create(&feedback_thread_data,
 800137e: 4638         	mov	r0, r7
 8001380: e9cd 2306    	strd	r2, r3, [sp, #24]
 8001384: 2300         	movs	r3, #0x0
 8001386: 9304         	str	r3, [sp, #0x10]
 8001388: 2300         	movs	r3, #0x0
 800138a: 9303         	str	r3, [sp, #0xc]
 800138c: 2300         	movs	r3, #0x0
 800138e: 9302         	str	r3, [sp, #0x8]
 8001390: 2300         	movs	r3, #0x0
 8001392: 9301         	str	r3, [sp, #0x4]
 8001394: 9100         	str	r1, [sp]
 8001396: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80013e4 <main+0xc0>
 8001398: f44f 5280    	mov.w	r2, #0x1000
 800139c: 4912         	ldr	r1, [pc, #0x48]         @ 0x80013e8 <main+0xc4>
 800139e: f00e ffbd    	bl	0x801031c <k_thread_create> @ imm = #0xef7a
 80013a2: 4603         	mov	r3, r0
 80013a4: 4a11         	ldr	r2, [pc, #0x44]         @ 0x80013ec <main+0xc8>
 80013a6: 6013         	str	r3, [r2]
;         chassis_calc(sbus_get_percent(sbus, 1), sbus_get_percent(sbus, 3));
 80013a8: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80013f0 <main+0xcc>
 80013aa: 681b         	ldr	r3, [r3]
 80013ac: 2101         	movs	r1, #0x1
 80013ae: 4618         	mov	r0, r3
 80013b0: f00f f897    	bl	0x80104e2 <sbus_get_percent> @ imm = #0xf12e
 80013b4: 4604         	mov	r4, r0
 80013b6: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80013f0 <main+0xcc>
 80013b8: 681b         	ldr	r3, [r3]
 80013ba: 2103         	movs	r1, #0x3
 80013bc: 4618         	mov	r0, r3
 80013be: f00f f890    	bl	0x80104e2 <sbus_get_percent> @ imm = #0xf120
 80013c2: 4603         	mov	r3, r0
 80013c4: 4619         	mov	r1, r3
 80013c6: 4620         	mov	r0, r4
 80013c8: f7ff fef4    	bl	0x80011b4 <chassis_calc> @ imm = #-0x218
;         k_msleep(10);
 80013cc: 200a         	movs	r0, #0xa
 80013ce: f00e ff79    	bl	0x80102c4 <k_msleep>    @ imm = #0xeef2
;         chassis_calc(sbus_get_percent(sbus, 1), sbus_get_percent(sbus, 3));
 80013d2: bf00         	nop
 80013d4: e7e8         	b	0x80013a8 <main+0x84>   @ imm = #-0x30
 80013d6: bf00         	nop

080013d8 <$d>:
 80013d8: b4 02 00 20  	.word	0x200002b4
 80013dc: b8 02 00 20  	.word	0x200002b8
 80013e0: bc 02 00 20  	.word	0x200002bc
 80013e4: ad 0e 00 08  	.word	0x08000ead
 80013e8: 00 11 00 20  	.word	0x20001100
 80013ec: 88 0a 00 20  	.word	0x20000a88
 80013f0: c0 02 00 20  	.word	0x200002c0

080013f4 <linker_is_in_rodata>:
; {
 80013f4: b480         	push	{r7}
 80013f6: b083         	sub	sp, #0xc
 80013f8: af00         	add	r7, sp, #0x0
 80013fa: 6078         	str	r0, [r7, #0x4]
; 	return (((const char *)addr >= (const char *)RO_START) &&
 80013fc: 687b         	ldr	r3, [r7, #0x4]
 80013fe: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8001424 <linker_is_in_rodata+0x30>
 8001400: 4293         	cmp	r3, r2
 8001402: d305         	blo	0x8001410 <linker_is_in_rodata+0x1c> @ imm = #0xa
 8001404: 687b         	ldr	r3, [r7, #0x4]
 8001406: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8001428 <linker_is_in_rodata+0x34>
 8001408: 4293         	cmp	r3, r2
 800140a: d201         	bhs	0x8001410 <linker_is_in_rodata+0x1c> @ imm = #0x2
 800140c: 2301         	movs	r3, #0x1
 800140e: e000         	b	0x8001412 <linker_is_in_rodata+0x1e> @ imm = #0x0
 8001410: 2300         	movs	r3, #0x0
 8001412: f003 0301    	and	r3, r3, #0x1
 8001416: b2db         	uxtb	r3, r3
; }
 8001418: 4618         	mov	r0, r3
 800141a: 370c         	adds	r7, #0xc
 800141c: 46bd         	mov	sp, r7
 800141e: bc80         	pop	{r7}
 8001420: 4770         	bx	lr
 8001422: bf00         	nop

08001424 <$d>:
 8001424: 04 91 01 08  	.word	0x08019104
 8001428: 98 bf 01 08  	.word	0x0801bf98

0800142c <cbvprintf_package>:
; {
 800142c: b580         	push	{r7, lr}
 800142e: b0a4         	sub	sp, #0x90
 8001430: af00         	add	r7, sp, #0x0
 8001432: 60f8         	str	r0, [r7, #0xc]
 8001434: 60b9         	str	r1, [r7, #0x8]
 8001436: 607a         	str	r2, [r7, #0x4]
 8001438: 603b         	str	r3, [r7]
; 	uint8_t *buf0 = packaged;  /* buffer start (may be NULL) */
 800143a: 68fb         	ldr	r3, [r7, #0xc]
 800143c: 65fb         	str	r3, [r7, #0x5c]
; 	uintptr_t buf = (uintptr_t)buf0; /* current buffer position */
 800143e: 6dfb         	ldr	r3, [r7, #0x5c]
 8001440: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
 8001444: 2300         	movs	r3, #0x0
 8001446: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	unsigned int s_rw_cnt = 0; /* number of rw strings */
 800144a: 2300         	movs	r3, #0x0
 800144c: 67fb         	str	r3, [r7, #0x7c]
; 	unsigned int s_ro_cnt = 0; /* number of ro strings */
 800144e: 2300         	movs	r3, #0x0
 8001450: 67bb         	str	r3, [r7, #0x78]
; 	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
 8001452: f04f 33ff    	mov.w	r3, #0xffffffff
 8001456: 677b         	str	r3, [r7, #0x74]
; 	bool parsing = false;
 8001458: 2300         	movs	r3, #0x0
 800145a: f887 306b    	strb.w	r3, [r7, #0x6b]
; 	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
 800145e: 687b         	ldr	r3, [r7, #0x4]
 8001460: f003 0304    	and	r3, r3, #0x4
 8001464: 2b00         	cmp	r3, #0x0
 8001466: bf14         	ite	ne
 8001468: 2301         	movne	r3, #0x1
 800146a: 2300         	moveq	r3, #0x0
 800146c: f887 305b    	strb.w	r3, [r7, #0x5b]
; 	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
 8001470: 687b         	ldr	r3, [r7, #0x4]
 8001472: 08db         	lsrs	r3, r3, #0x3
 8001474: f003 0307    	and	r3, r3, #0x7
 8001478: 3301         	adds	r3, #0x1
 800147a: 667b         	str	r3, [r7, #0x64]
; 	bool is_str_arg = false;
 800147c: 2300         	movs	r3, #0x0
 800147e: f887 3063    	strb.w	r3, [r7, #0x63]
; 	union cbprintf_package_hdr *pkg_hdr = packaged;
 8001482: 68fb         	ldr	r3, [r7, #0xc]
 8001484: 657b         	str	r3, [r7, #0x54]
; 	if ((uintptr_t)packaged % sizeof(void *)) {
 8001486: 68fb         	ldr	r3, [r7, #0xc]
 8001488: f003 0303    	and	r3, r3, #0x3
 800148c: 2b00         	cmp	r3, #0x0
 800148e: d002         	beq	0x8001496 <cbvprintf_package+0x6a> @ imm = #0x4
; 		return -EFAULT;
 8001490: f06f 030d    	mvn	r3, #0xd
 8001494: e3a2         	b	0x8001bdc <cbvprintf_package+0x7b0> @ imm = #0x744
; 	buf += sizeof(*pkg_hdr);
 8001496: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800149a: 3304         	adds	r3, #0x4
 800149c: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	if (buf0 == NULL) {
 80014a0: 6dfb         	ldr	r3, [r7, #0x5c]
 80014a2: 2b00         	cmp	r3, #0x0
 80014a4: d10d         	bne	0x80014c2 <cbvprintf_package+0x96> @ imm = #0x1a
; 		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
 80014a6: 68bb         	ldr	r3, [r7, #0x8]
 80014a8: f003 0307    	and	r3, r3, #0x7
 80014ac: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80014b0: 4413         	add	r3, r2
 80014b2: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
 80014b6: 68bb         	ldr	r3, [r7, #0x8]
 80014b8: f003 0307    	and	r3, r3, #0x7
 80014bc: f1c3 0308    	rsb.w	r3, r3, #0x8
 80014c0: 60bb         	str	r3, [r7, #0x8]
; 	if ((buf0 != NULL) && (BUF_OFFSET + sizeof(char *)) > len) {
 80014c2: 6dfb         	ldr	r3, [r7, #0x5c]
 80014c4: 2b00         	cmp	r3, #0x0
 80014c6: d00a         	beq	0x80014de <cbvprintf_package+0xb2> @ imm = #0x14
 80014c8: 6dfb         	ldr	r3, [r7, #0x5c]
 80014ca: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80014ce: 1ad3         	subs	r3, r2, r3
 80014d0: 3304         	adds	r3, #0x4
 80014d2: 68ba         	ldr	r2, [r7, #0x8]
 80014d4: 429a         	cmp	r2, r3
 80014d6: d202         	bhs	0x80014de <cbvprintf_package+0xb2> @ imm = #0x4
; 		return -ENOSPC;
 80014d8: f06f 031b    	mvn	r3, #0x1b
 80014dc: e37e         	b	0x8001bdc <cbvprintf_package+0x7b0> @ imm = #0x6fc
; 	s = fmt;
 80014de: 683b         	ldr	r3, [r7]
 80014e0: 66fb         	str	r3, [r7, #0x6c]
; 	--fmt;
 80014e2: 683b         	ldr	r3, [r7]
 80014e4: 3b01         	subs	r3, #0x1
 80014e6: 603b         	str	r3, [r7]
; 	align = VA_STACK_ALIGN(char *);
 80014e8: 2304         	movs	r3, #0x4
 80014ea: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	size = sizeof(char *);
 80014ee: 2304         	movs	r3, #0x4
 80014f0: f8c7 3088    	str.w	r3, [r7, #0x88]
; 	goto process_string;
 80014f4: e197         	b	0x8001826 <cbvprintf_package+0x3fa> @ imm = #0x32e
; 			if (!parsing) {
 80014f6: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 80014fa: f083 0301    	eor	r3, r3, #0x1
 80014fe: b2db         	uxtb	r3, r3
 8001500: 2b00         	cmp	r3, #0x0
 8001502: d011         	beq	0x8001528 <cbvprintf_package+0xfc> @ imm = #0x22
; 				if (*fmt == '%') {
 8001504: 683b         	ldr	r3, [r7]
 8001506: 781b         	ldrb	r3, [r3]
 8001508: 2b25         	cmp	r3, #0x25
 800150a: f040 8278    	bne.w	0x80019fe <cbvprintf_package+0x5d2> @ imm = #0x4f0
; 					parsing = true;
 800150e: 2301         	movs	r3, #0x1
 8001510: f887 306b    	strb.w	r3, [r7, #0x6b]
; 					arg_idx++;
 8001514: 6f7b         	ldr	r3, [r7, #0x74]
 8001516: 3301         	adds	r3, #0x1
 8001518: 677b         	str	r3, [r7, #0x74]
; 					align = VA_STACK_ALIGN(int);
 800151a: 2304         	movs	r3, #0x4
 800151c: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(int);
 8001520: 2304         	movs	r3, #0x4
 8001522: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8001526: e26a         	b	0x80019fe <cbvprintf_package+0x5d2> @ imm = #0x4d4
; 			switch (*fmt) {
 8001528: 683b         	ldr	r3, [r7]
 800152a: 781b         	ldrb	r3, [r3]
 800152c: 2b7a         	cmp	r3, #0x7a
 800152e: f300 8149    	bgt.w	0x80017c4 <cbvprintf_package+0x398> @ imm = #0x292
 8001532: 2b4c         	cmp	r3, #0x4c
 8001534: da11         	bge	0x800155a <cbvprintf_package+0x12e> @ imm = #0x22
 8001536: 2b47         	cmp	r3, #0x47
 8001538: f300 8144    	bgt.w	0x80017c4 <cbvprintf_package+0x398> @ imm = #0x288
 800153c: 2b2a         	cmp	r3, #0x2a
 800153e: da71         	bge	0x8001624 <cbvprintf_package+0x1f8> @ imm = #0xe2
 8001540: 2b25         	cmp	r3, #0x25
 8001542: f000 8092    	beq.w	0x800166a <cbvprintf_package+0x23e> @ imm = #0x124
 8001546: 2b25         	cmp	r3, #0x25
 8001548: f300 813c    	bgt.w	0x80017c4 <cbvprintf_package+0x398> @ imm = #0x278
 800154c: 2b20         	cmp	r3, #0x20
 800154e: f000 8258    	beq.w	0x8001a02 <cbvprintf_package+0x5d6> @ imm = #0x4b0
 8001552: 2b23         	cmp	r3, #0x23
 8001554: f000 8255    	beq.w	0x8001a02 <cbvprintf_package+0x5d6> @ imm = #0x4aa
 8001558: e134         	b	0x80017c4 <cbvprintf_package+0x398> @ imm = #0x268
 800155a: 3b4c         	subs	r3, #0x4c
 800155c: 2b2e         	cmp	r3, #0x2e
 800155e: f200 8131    	bhi.w	0x80017c4 <cbvprintf_package+0x398> @ imm = #0x262
 8001562: a201         	adr	r2, #4 <cbvprintf_package+0x13b>
 8001564: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08001568 <$d>:
 8001568: 03 1a 00 08  	.word	0x08001a03
 800156c: c5 17 00 08  	.word	0x080017c5
 8001570: c5 17 00 08  	.word	0x080017c5
 8001574: c5 17 00 08  	.word	0x080017c5
 8001578: c5 17 00 08  	.word	0x080017c5
 800157c: c5 17 00 08  	.word	0x080017c5
 8001580: c5 17 00 08  	.word	0x080017c5
 8001584: c5 17 00 08  	.word	0x080017c5
 8001588: c5 17 00 08  	.word	0x080017c5
 800158c: c5 17 00 08  	.word	0x080017c5
 8001590: c5 17 00 08  	.word	0x080017c5
 8001594: c5 17 00 08  	.word	0x080017c5
 8001598: a3 16 00 08  	.word	0x080016a3
 800159c: c5 17 00 08  	.word	0x080017c5
 80015a0: c5 17 00 08  	.word	0x080017c5
 80015a4: c5 17 00 08  	.word	0x080017c5
 80015a8: c5 17 00 08  	.word	0x080017c5
 80015ac: c5 17 00 08  	.word	0x080017c5
 80015b0: c5 17 00 08  	.word	0x080017c5
 80015b4: c5 17 00 08  	.word	0x080017c5
 80015b8: c5 17 00 08  	.word	0x080017c5
 80015bc: f3 16 00 08  	.word	0x080016f3
 80015c0: c5 17 00 08  	.word	0x080017c5
 80015c4: a3 16 00 08  	.word	0x080016a3
 80015c8: a3 16 00 08  	.word	0x080016a3
 80015cc: f3 16 00 08  	.word	0x080016f3
 80015d0: f3 16 00 08  	.word	0x080016f3
 80015d4: f3 16 00 08  	.word	0x080016f3
 80015d8: 03 1a 00 08  	.word	0x08001a03
 80015dc: a3 16 00 08  	.word	0x080016a3
 80015e0: 79 16 00 08  	.word	0x08001679
 80015e4: c5 17 00 08  	.word	0x080017c5
 80015e8: 03 1a 00 08  	.word	0x08001a03
 80015ec: c5 17 00 08  	.word	0x080017c5
 80015f0: df 16 00 08  	.word	0x080016df
 80015f4: a3 16 00 08  	.word	0x080016a3
 80015f8: df 16 00 08  	.word	0x080016df
 80015fc: c5 17 00 08  	.word	0x080017c5
 8001600: c5 17 00 08  	.word	0x080017c5
 8001604: d9 16 00 08  	.word	0x080016d9
 8001608: 95 16 00 08  	.word	0x08001695
 800160c: a3 16 00 08  	.word	0x080016a3
 8001610: c5 17 00 08  	.word	0x080017c5
 8001614: c5 17 00 08  	.word	0x080017c5
 8001618: a3 16 00 08  	.word	0x080016a3
 800161c: c5 17 00 08  	.word	0x080017c5
 8001620: 87 16 00 08  	.word	0x08001687

08001624 <$t>:
 8001624: 3b2a         	subs	r3, #0x2a
 8001626: 2201         	movs	r2, #0x1
 8001628: fa02 f303    	lsl.w	r3, r2, r3
 800162c: f64f 72da    	movw	r2, #0xffda
 8001630: 401a         	ands	r2, r3
 8001632: 2a00         	cmp	r2, #0x0
 8001634: bf14         	ite	ne
 8001636: 2201         	movne	r2, #0x1
 8001638: 2200         	moveq	r2, #0x0
 800163a: b2d2         	uxtb	r2, r2
 800163c: 2a00         	cmp	r2, #0x0
 800163e: f040 81e0    	bne.w	0x8001a02 <cbvprintf_package+0x5d6> @ imm = #0x3c0
 8001642: f003 5262    	and	r2, r3, #0x38800000
 8001646: 2a00         	cmp	r2, #0x0
 8001648: bf14         	ite	ne
 800164a: 2201         	movne	r2, #0x1
 800164c: 2200         	moveq	r2, #0x0
 800164e: b2d2         	uxtb	r2, r2
 8001650: 2a00         	cmp	r2, #0x0
 8001652: d14e         	bne	0x80016f2 <cbvprintf_package+0x2c6> @ imm = #0x9c
 8001654: f003 0301    	and	r3, r3, #0x1
 8001658: 2b00         	cmp	r3, #0x0
 800165a: bf14         	ite	ne
 800165c: 2301         	movne	r3, #0x1
 800165e: 2300         	moveq	r3, #0x0
 8001660: b2db         	uxtb	r3, r3
 8001662: 2b00         	cmp	r3, #0x0
 8001664: f040 80b2    	bne.w	0x80017cc <cbvprintf_package+0x3a0> @ imm = #0x164
 8001668: e0ac         	b	0x80017c4 <cbvprintf_package+0x398> @ imm = #0x158
; 				parsing = false;
 800166a: 2300         	movs	r3, #0x0
 800166c: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				arg_idx--;
 8001670: 6f7b         	ldr	r3, [r7, #0x74]
 8001672: 3b01         	subs	r3, #0x1
 8001674: 677b         	str	r3, [r7, #0x74]
; 				continue;
 8001676: e1c5         	b	0x8001a04 <cbvprintf_package+0x5d8> @ imm = #0x38a
; 				align = VA_STACK_ALIGN(intmax_t);
 8001678: 2308         	movs	r3, #0x8
 800167a: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(intmax_t);
 800167e: 2308         	movs	r3, #0x8
 8001680: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8001684: e1be         	b	0x8001a04 <cbvprintf_package+0x5d8> @ imm = #0x37c
; 				align = VA_STACK_ALIGN(size_t);
 8001686: 2304         	movs	r3, #0x4
 8001688: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(size_t);
 800168c: 2304         	movs	r3, #0x4
 800168e: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8001692: e1b7         	b	0x8001a04 <cbvprintf_package+0x5d8> @ imm = #0x36e
; 				align = VA_STACK_ALIGN(ptrdiff_t);
 8001694: 2304         	movs	r3, #0x4
 8001696: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(ptrdiff_t);
 800169a: 2304         	movs	r3, #0x4
 800169c: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 80016a0: e1b0         	b	0x8001a04 <cbvprintf_package+0x5d8> @ imm = #0x360
; 				if (fmt[-1] == 'l') {
 80016a2: 683b         	ldr	r3, [r7]
 80016a4: 3b01         	subs	r3, #0x1
 80016a6: 781b         	ldrb	r3, [r3]
 80016a8: 2b6c         	cmp	r3, #0x6c
 80016aa: d111         	bne	0x80016d0 <cbvprintf_package+0x2a4> @ imm = #0x22
; 					if (fmt[-2] == 'l') {
 80016ac: 683b         	ldr	r3, [r7]
 80016ae: 3b02         	subs	r3, #0x2
 80016b0: 781b         	ldrb	r3, [r3]
 80016b2: 2b6c         	cmp	r3, #0x6c
 80016b4: d106         	bne	0x80016c4 <cbvprintf_package+0x298> @ imm = #0xc
; 						align = VA_STACK_ALIGN(long long);
 80016b6: 2308         	movs	r3, #0x8
 80016b8: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long long);
 80016bc: 2308         	movs	r3, #0x8
 80016be: f8c7 3088    	str.w	r3, [r7, #0x88]
 80016c2: e005         	b	0x80016d0 <cbvprintf_package+0x2a4> @ imm = #0xa
; 						align = VA_STACK_ALIGN(long);
 80016c4: 2304         	movs	r3, #0x4
 80016c6: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long);
 80016ca: 2304         	movs	r3, #0x4
 80016cc: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 80016d0: 2300         	movs	r3, #0x0
 80016d2: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 80016d6: e07a         	b	0x80017ce <cbvprintf_package+0x3a2> @ imm = #0xf4
; 				is_str_arg = true;
 80016d8: 2301         	movs	r3, #0x1
 80016da: f887 3063    	strb.w	r3, [r7, #0x63]
; 				align = VA_STACK_ALIGN(void *);
 80016de: 2304         	movs	r3, #0x4
 80016e0: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(void *);
 80016e4: 2304         	movs	r3, #0x4
 80016e6: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 80016ea: 2300         	movs	r3, #0x0
 80016ec: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 80016f0: e06d         	b	0x80017ce <cbvprintf_package+0x3a2> @ imm = #0xda
; 				if (fmt[-1] == 'L') {
 80016f2: 683b         	ldr	r3, [r7]
 80016f4: 3b01         	subs	r3, #0x1
 80016f6: 781b         	ldrb	r3, [r3]
 80016f8: 2b4c         	cmp	r3, #0x4c
 80016fa: d113         	bne	0x8001724 <cbvprintf_package+0x2f8> @ imm = #0x26
; 					v.ld = va_arg(ap, long double);
 80016fc: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8001700: 3307         	adds	r3, #0x7
 8001702: f023 0307    	bic	r3, r3, #0x7
 8001706: f103 0208    	add.w	r2, r3, #0x8
 800170a: f8c7 2098    	str.w	r2, [r7, #0x98]
 800170e: e9d3 2300    	ldrd	r2, r3, [r3]
 8001712: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(long double);
 8001716: 2308         	movs	r3, #0x8
 8001718: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(long double);
 800171c: 2308         	movs	r3, #0x8
 800171e: f8c7 3088    	str.w	r3, [r7, #0x88]
 8001722: e012         	b	0x800174a <cbvprintf_package+0x31e> @ imm = #0x24
; 					v.d = va_arg(ap, double);
 8001724: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8001728: 3307         	adds	r3, #0x7
 800172a: f023 0307    	bic	r3, r3, #0x7
 800172e: f103 0208    	add.w	r2, r3, #0x8
 8001732: f8c7 2098    	str.w	r2, [r7, #0x98]
 8001736: e9d3 2300    	ldrd	r2, r3, [r3]
 800173a: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(double);
 800173e: 2308         	movs	r3, #0x8
 8001740: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(double);
 8001744: 2308         	movs	r3, #0x8
 8001746: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				buf = ROUND_UP(buf, align);
 800174a: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 800174e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001752: 4413         	add	r3, r2
 8001754: 1e5a         	subs	r2, r3, #0x1
 8001756: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800175a: fbb2 f2f3    	udiv	r2, r2, r3
 800175e: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8001762: fb02 f303    	mul	r3, r2, r3
 8001766: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				if (buf0 != NULL) {
 800176a: 6dfb         	ldr	r3, [r7, #0x5c]
 800176c: 2b00         	cmp	r3, #0x0
 800176e: d01e         	beq	0x80017ae <cbvprintf_package+0x382> @ imm = #0x3c
; 					if (BUF_OFFSET + size > len) {
 8001770: 6dfb         	ldr	r3, [r7, #0x5c]
 8001772: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001776: 1ad2         	subs	r2, r2, r3
 8001778: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800177c: 4413         	add	r3, r2
 800177e: 68ba         	ldr	r2, [r7, #0x8]
 8001780: 429a         	cmp	r2, r3
 8001782: d202         	bhs	0x800178a <cbvprintf_package+0x35e> @ imm = #0x4
; 						return -ENOSPC;
 8001784: f06f 031b    	mvn	r3, #0x1b
 8001788: e228         	b	0x8001bdc <cbvprintf_package+0x7b0> @ imm = #0x450
; 					} else if (fmt[-1] == 'L') {
 800178a: 683b         	ldr	r3, [r7]
 800178c: 3b01         	subs	r3, #0x1
 800178e: 781b         	ldrb	r3, [r3]
 8001790: 2b4c         	cmp	r3, #0x4c
 8001792: d106         	bne	0x80017a2 <cbvprintf_package+0x376> @ imm = #0xc
; 						*(long double *)buf = v.ld;
 8001794: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8001798: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 800179c: e9c1 2300    	strd	r2, r3, [r1]
 80017a0: e005         	b	0x80017ae <cbvprintf_package+0x382> @ imm = #0xa
; 						*(double *)buf = v.d;
 80017a2: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 80017a6: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 80017aa: e9c1 2300    	strd	r2, r3, [r1]
; 				buf += size;
 80017ae: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80017b2: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80017b6: 4413         	add	r3, r2
 80017b8: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				parsing = false;
 80017bc: 2300         	movs	r3, #0x0
 80017be: f887 306b    	strb.w	r3, [r7, #0x6b]
 80017c2: e11f         	b	0x8001a04 <cbvprintf_package+0x5d8> @ imm = #0x23e
; 				parsing = false;
 80017c4: 2300         	movs	r3, #0x0
 80017c6: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				continue;
 80017ca: e11b         	b	0x8001a04 <cbvprintf_package+0x5d8> @ imm = #0x236
; 				break;
 80017cc: bf00         	nop
; 		buf = ROUND_UP(buf, align);
 80017ce: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 80017d2: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80017d6: 4413         	add	r3, r2
 80017d8: 1e5a         	subs	r2, r3, #0x1
 80017da: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 80017de: fbb2 f2f3    	udiv	r2, r2, r3
 80017e2: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 80017e6: fb02 f303    	mul	r3, r2, r3
 80017ea: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		if ((buf0 != NULL) && (BUF_OFFSET + size) > len) {
 80017ee: 6dfb         	ldr	r3, [r7, #0x5c]
 80017f0: 2b00         	cmp	r3, #0x0
 80017f2: d00c         	beq	0x800180e <cbvprintf_package+0x3e2> @ imm = #0x18
 80017f4: 6dfb         	ldr	r3, [r7, #0x5c]
 80017f6: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80017fa: 1ad2         	subs	r2, r2, r3
 80017fc: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8001800: 4413         	add	r3, r2
 8001802: 68ba         	ldr	r2, [r7, #0x8]
 8001804: 429a         	cmp	r2, r3
 8001806: d202         	bhs	0x800180e <cbvprintf_package+0x3e2> @ imm = #0x4
; 			return -ENOSPC;
 8001808: f06f 031b    	mvn	r3, #0x1b
 800180c: e1e6         	b	0x8001bdc <cbvprintf_package+0x7b0> @ imm = #0x3cc
; 		if (is_str_arg) {
 800180e: f897 3063    	ldrb.w	r3, [r7, #0x63]
 8001812: 2b00         	cmp	r3, #0x0
 8001814: f000 80a0    	beq.w	0x8001958 <cbvprintf_package+0x52c> @ imm = #0x140
; 			s = va_arg(ap, char *);
 8001818: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 800181c: 1d1a         	adds	r2, r3, #0x4
 800181e: f8c7 2098    	str.w	r2, [r7, #0x98]
 8001822: 681b         	ldr	r3, [r3]
 8001824: 66fb         	str	r3, [r7, #0x6c]
; 			if (buf0 != NULL) {
 8001826: 6dfb         	ldr	r3, [r7, #0x5c]
 8001828: 2b00         	cmp	r3, #0x0
 800182a: d003         	beq	0x8001834 <cbvprintf_package+0x408> @ imm = #0x6
; 				*(const char **)buf = s;
 800182c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001830: 6efa         	ldr	r2, [r7, #0x6c]
 8001832: 601a         	str	r2, [r3]
; 			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 8001834: 6e7b         	ldr	r3, [r7, #0x64]
 8001836: 1e5a         	subs	r2, r3, #0x1
 8001838: 667a         	str	r2, [r7, #0x64]
 800183a: 2b00         	cmp	r3, #0x0
 800183c: dc05         	bgt	0x800184a <cbvprintf_package+0x41e> @ imm = #0xa
 800183e: 6ef8         	ldr	r0, [r7, #0x6c]
 8001840: f00f f8f7    	bl	0x8010a32 <ptr_in_rodata> @ imm = #0xf1ee
 8001844: 4603         	mov	r3, r0
 8001846: 2b00         	cmp	r3, #0x0
 8001848: d001         	beq	0x800184e <cbvprintf_package+0x422> @ imm = #0x2
 800184a: 2301         	movs	r3, #0x1
 800184c: e000         	b	0x8001850 <cbvprintf_package+0x424> @ imm = #0x0
 800184e: 2300         	movs	r3, #0x0
 8001850: f887 3053    	strb.w	r3, [r7, #0x53]
; 			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);
 8001854: 687b         	ldr	r3, [r7, #0x4]
 8001856: f003 0302    	and	r3, r3, #0x2
 800185a: 2b00         	cmp	r3, #0x0
 800185c: bf14         	ite	ne
 800185e: 2301         	movne	r3, #0x1
 8001860: 2300         	moveq	r3, #0x0
 8001862: f887 3052    	strb.w	r3, [r7, #0x52]
; 			if (is_ro && !do_ro) {
 8001866: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800186a: 2b00         	cmp	r3, #0x0
 800186c: d006         	beq	0x800187c <cbvprintf_package+0x450> @ imm = #0xc
 800186e: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8001872: f083 0301    	eor	r3, r3, #0x1
 8001876: b2db         	uxtb	r3, r3
 8001878: 2b00         	cmp	r3, #0x0
 800187a: d164         	bne	0x8001946 <cbvprintf_package+0x51a> @ imm = #0xc8
; 				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
 800187c: 6dfb         	ldr	r3, [r7, #0x5c]
 800187e: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001882: 1ad3         	subs	r3, r2, r3
 8001884: 089b         	lsrs	r3, r3, #0x2
 8001886: 64fb         	str	r3, [r7, #0x4c]
; 				if (do_ro && s_ptr_idx > STR_POS_MASK) {
 8001888: f897 3052    	ldrb.w	r3, [r7, #0x52]
 800188c: 2b00         	cmp	r3, #0x0
 800188e: d005         	beq	0x800189c <cbvprintf_package+0x470> @ imm = #0xa
 8001890: 6cfb         	ldr	r3, [r7, #0x4c]
 8001892: 2b7f         	cmp	r3, #0x7f
 8001894: d902         	bls	0x800189c <cbvprintf_package+0x470> @ imm = #0x4
; 					return -EINVAL;
 8001896: f06f 0315    	mvn	r3, #0x15
 800189a: e19f         	b	0x8001bdc <cbvprintf_package+0x7b0> @ imm = #0x33e
; 				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
 800189c: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80018a0: 2b0f         	cmp	r3, #0xf
 80018a2: d902         	bls	0x80018aa <cbvprintf_package+0x47e> @ imm = #0x4
; 					return -EINVAL;
 80018a4: f06f 0315    	mvn	r3, #0x15
 80018a8: e198         	b	0x8001bdc <cbvprintf_package+0x7b0> @ imm = #0x330
; 				if (buf0 != NULL) {
 80018aa: 6dfb         	ldr	r3, [r7, #0x5c]
 80018ac: 2b00         	cmp	r3, #0x0
 80018ae: d02d         	beq	0x800190c <cbvprintf_package+0x4e0> @ imm = #0x5a
; 					str_ptr_pos[s_idx] = s_ptr_idx;
 80018b0: 6cfb         	ldr	r3, [r7, #0x4c]
 80018b2: b2d9         	uxtb	r1, r3
 80018b4: f107 0230    	add.w	r2, r7, #0x30
 80018b8: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80018bc: 4413         	add	r3, r2
 80018be: 460a         	mov	r2, r1
 80018c0: 701a         	strb	r2, [r3]
; 					str_ptr_arg[s_idx] = arg_idx;
 80018c2: 6f7b         	ldr	r3, [r7, #0x74]
 80018c4: b2d9         	uxtb	r1, r3
 80018c6: f107 0220    	add.w	r2, r7, #0x20
 80018ca: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80018ce: 4413         	add	r3, r2
 80018d0: 460a         	mov	r2, r1
 80018d2: 701a         	strb	r2, [r3]
; 					if (is_ro) {
 80018d4: f897 3053    	ldrb.w	r3, [r7, #0x53]
 80018d8: 2b00         	cmp	r3, #0x0
 80018da: d013         	beq	0x8001904 <cbvprintf_package+0x4d8> @ imm = #0x26
; 						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
 80018dc: f107 0230    	add.w	r2, r7, #0x30
 80018e0: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80018e4: 4413         	add	r3, r2
 80018e6: 781b         	ldrb	r3, [r3]
 80018e8: f063 037f    	orn	r3, r3, #0x7f
 80018ec: b2d9         	uxtb	r1, r3
 80018ee: f107 0230    	add.w	r2, r7, #0x30
 80018f2: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80018f6: 4413         	add	r3, r2
 80018f8: 460a         	mov	r2, r1
 80018fa: 701a         	strb	r2, [r3]
; 						s_ro_cnt++;
 80018fc: 6fbb         	ldr	r3, [r7, #0x78]
 80018fe: 3301         	adds	r3, #0x1
 8001900: 67bb         	str	r3, [r7, #0x78]
 8001902: e01b         	b	0x800193c <cbvprintf_package+0x510> @ imm = #0x36
; 						s_rw_cnt++;
 8001904: 6ffb         	ldr	r3, [r7, #0x7c]
 8001906: 3301         	adds	r3, #0x1
 8001908: 67fb         	str	r3, [r7, #0x7c]
 800190a: e017         	b	0x800193c <cbvprintf_package+0x510> @ imm = #0x2e
; 				} else if (is_ro) {
 800190c: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8001910: 2b00         	cmp	r3, #0x0
 8001912: d003         	beq	0x800191c <cbvprintf_package+0x4f0> @ imm = #0x6
; 					len += 1;
 8001914: 68bb         	ldr	r3, [r7, #0x8]
 8001916: 3301         	adds	r3, #0x1
 8001918: 60bb         	str	r3, [r7, #0x8]
 800191a: e00f         	b	0x800193c <cbvprintf_package+0x510> @ imm = #0x1e
; 				} else if (rws_pos_en) {
 800191c: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8001920: 2b00         	cmp	r3, #0x0
 8001922: d003         	beq	0x800192c <cbvprintf_package+0x500> @ imm = #0x6
; 					len += 2;
 8001924: 68bb         	ldr	r3, [r7, #0x8]
 8001926: 3302         	adds	r3, #0x2
 8001928: 60bb         	str	r3, [r7, #0x8]
 800192a: e007         	b	0x800193c <cbvprintf_package+0x510> @ imm = #0xe
; 					len += strlen(s) + 1 + 1;
 800192c: 6ef8         	ldr	r0, [r7, #0x6c]
 800192e: f7ff f905    	bl	0x8000b3c <strlen>      @ imm = #-0xdf6
 8001932: 4602         	mov	r2, r0
 8001934: 68bb         	ldr	r3, [r7, #0x8]
 8001936: 4413         	add	r3, r2
 8001938: 3302         	adds	r3, #0x2
 800193a: 60bb         	str	r3, [r7, #0x8]
; 				s_idx++;
 800193c: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8001940: 3301         	adds	r3, #0x1
 8001942: f8c7 3080    	str.w	r3, [r7, #0x80]
; 			buf += sizeof(char *);
 8001946: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800194a: 3304         	adds	r3, #0x4
 800194c: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 			is_str_arg = false;
 8001950: 2300         	movs	r3, #0x0
 8001952: f887 3063    	strb.w	r3, [r7, #0x63]
 8001956: e055         	b	0x8001a04 <cbvprintf_package+0x5d8> @ imm = #0xaa
; 		} else if (size == sizeof(int)) {
 8001958: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800195c: 2b04         	cmp	r3, #0x4
 800195e: d113         	bne	0x8001988 <cbvprintf_package+0x55c> @ imm = #0x26
; 			int v = va_arg(ap, int);
 8001960: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8001964: 1d1a         	adds	r2, r3, #0x4
 8001966: f8c7 2098    	str.w	r2, [r7, #0x98]
 800196a: 681b         	ldr	r3, [r3]
 800196c: 647b         	str	r3, [r7, #0x44]
; 			if (buf0 != NULL) {
 800196e: 6dfb         	ldr	r3, [r7, #0x5c]
 8001970: 2b00         	cmp	r3, #0x0
 8001972: d003         	beq	0x800197c <cbvprintf_package+0x550> @ imm = #0x6
; 				*(int *)buf = v;
 8001974: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001978: 6c7a         	ldr	r2, [r7, #0x44]
 800197a: 601a         	str	r2, [r3]
; 			buf += sizeof(int);
 800197c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001980: 3304         	adds	r3, #0x4
 8001982: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8001986: e03d         	b	0x8001a04 <cbvprintf_package+0x5d8> @ imm = #0x7a
; 		} else if (size == sizeof(long)) {
 8001988: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800198c: 2b04         	cmp	r3, #0x4
 800198e: d113         	bne	0x80019b8 <cbvprintf_package+0x58c> @ imm = #0x26
; 			long v = va_arg(ap, long);
 8001990: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8001994: 1d1a         	adds	r2, r3, #0x4
 8001996: f8c7 2098    	str.w	r2, [r7, #0x98]
 800199a: 681b         	ldr	r3, [r3]
 800199c: 64bb         	str	r3, [r7, #0x48]
; 			if (buf0 != NULL) {
 800199e: 6dfb         	ldr	r3, [r7, #0x5c]
 80019a0: 2b00         	cmp	r3, #0x0
 80019a2: d003         	beq	0x80019ac <cbvprintf_package+0x580> @ imm = #0x6
; 				*(long *)buf = v;
 80019a4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80019a8: 6cba         	ldr	r2, [r7, #0x48]
 80019aa: 601a         	str	r2, [r3]
; 			buf += sizeof(long);
 80019ac: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80019b0: 3304         	adds	r3, #0x4
 80019b2: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80019b6: e025         	b	0x8001a04 <cbvprintf_package+0x5d8> @ imm = #0x4a
; 		} else if (size == sizeof(long long)) {
 80019b8: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80019bc: 2b08         	cmp	r3, #0x8
 80019be: d11b         	bne	0x80019f8 <cbvprintf_package+0x5cc> @ imm = #0x36
; 			long long v = va_arg(ap, long long);
 80019c0: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 80019c4: 3307         	adds	r3, #0x7
 80019c6: f023 0307    	bic	r3, r3, #0x7
 80019ca: f103 0208    	add.w	r2, r3, #0x8
 80019ce: f8c7 2098    	str.w	r2, [r7, #0x98]
 80019d2: e9d3 2300    	ldrd	r2, r3, [r3]
 80019d6: e9c7 2304    	strd	r2, r3, [r7, #16]
; 			if (buf0 != NULL) {
 80019da: 6dfb         	ldr	r3, [r7, #0x5c]
 80019dc: 2b00         	cmp	r3, #0x0
 80019de: d005         	beq	0x80019ec <cbvprintf_package+0x5c0> @ imm = #0xa
; 					*(long long *)buf = v;
 80019e0: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 80019e4: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 80019e8: e9c1 2300    	strd	r2, r3, [r1]
; 			buf += sizeof(long long);
 80019ec: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80019f0: 3308         	adds	r3, #0x8
 80019f2: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80019f6: e005         	b	0x8001a04 <cbvprintf_package+0x5d8> @ imm = #0xa
; 			return -EINVAL;
 80019f8: f06f 0315    	mvn	r3, #0x15
 80019fc: e0ee         	b	0x8001bdc <cbvprintf_package+0x7b0> @ imm = #0x1dc
; 				continue;
 80019fe: bf00         	nop
 8001a00: e000         	b	0x8001a04 <cbvprintf_package+0x5d8> @ imm = #0x0
; 				continue;
 8001a02: bf00         	nop
; 			if (*++fmt == '\0') {
 8001a04: 683b         	ldr	r3, [r7]
 8001a06: 3301         	adds	r3, #0x1
 8001a08: 603b         	str	r3, [r7]
 8001a0a: 683b         	ldr	r3, [r7]
 8001a0c: 781b         	ldrb	r3, [r3]
 8001a0e: 2b00         	cmp	r3, #0x0
 8001a10: f47f ad71    	bne.w	0x80014f6 <cbvprintf_package+0xca> @ imm = #-0x51e
; 				break;
 8001a14: bf00         	nop
; 	if ((BUF_OFFSET / sizeof(int)) > 255) {
 8001a16: 6dfb         	ldr	r3, [r7, #0x5c]
 8001a18: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001a1c: 1ad3         	subs	r3, r2, r3
 8001a1e: f5b3 6f80    	cmp.w	r3, #0x400
 8001a22: d302         	blo	0x8001a2a <cbvprintf_package+0x5fe> @ imm = #0x4
; 		return -EINVAL;
 8001a24: f06f 0315    	mvn	r3, #0x15
 8001a28: e0d8         	b	0x8001bdc <cbvprintf_package+0x7b0> @ imm = #0x1b0
; 	if (buf0 == NULL) {
 8001a2a: 6dfb         	ldr	r3, [r7, #0x5c]
 8001a2c: 2b00         	cmp	r3, #0x0
 8001a2e: d107         	bne	0x8001a40 <cbvprintf_package+0x614> @ imm = #0xe
; 		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
 8001a30: 6dfb         	ldr	r3, [r7, #0x5c]
 8001a32: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001a36: 1ad2         	subs	r2, r2, r3
 8001a38: 68bb         	ldr	r3, [r7, #0x8]
 8001a3a: 4413         	add	r3, r2
 8001a3c: 3b08         	subs	r3, #0x8
 8001a3e: e0cd         	b	0x8001bdc <cbvprintf_package+0x7b0> @ imm = #0x19a
; 	*(char **)buf0 = NULL;
 8001a40: 6dfb         	ldr	r3, [r7, #0x5c]
 8001a42: 2200         	movs	r2, #0x0
 8001a44: 601a         	str	r2, [r3]
; 	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
 8001a46: 6dfb         	ldr	r3, [r7, #0x5c]
 8001a48: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001a4c: 1ad3         	subs	r3, r2, r3
 8001a4e: 089b         	lsrs	r3, r3, #0x2
 8001a50: b2da         	uxtb	r2, r3
 8001a52: 6d7b         	ldr	r3, [r7, #0x54]
 8001a54: 701a         	strb	r2, [r3]
; 	if (rws_pos_en) {
 8001a56: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8001a5a: 2b00         	cmp	r3, #0x0
 8001a5c: d007         	beq	0x8001a6e <cbvprintf_package+0x642> @ imm = #0xe
; 		pkg_hdr->desc.str_cnt = 0;
 8001a5e: 6d7b         	ldr	r3, [r7, #0x54]
 8001a60: 2200         	movs	r2, #0x0
 8001a62: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
 8001a64: 6ffb         	ldr	r3, [r7, #0x7c]
 8001a66: b2da         	uxtb	r2, r3
 8001a68: 6d7b         	ldr	r3, [r7, #0x54]
 8001a6a: 70da         	strb	r2, [r3, #0x3]
 8001a6c: e006         	b	0x8001a7c <cbvprintf_package+0x650> @ imm = #0xc
; 		pkg_hdr->desc.str_cnt = s_rw_cnt;
 8001a6e: 6ffb         	ldr	r3, [r7, #0x7c]
 8001a70: b2da         	uxtb	r2, r3
 8001a72: 6d7b         	ldr	r3, [r7, #0x54]
 8001a74: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = 0;
 8001a76: 6d7b         	ldr	r3, [r7, #0x54]
 8001a78: 2200         	movs	r2, #0x0
 8001a7a: 70da         	strb	r2, [r3, #0x3]
; 	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
 8001a7c: 6fbb         	ldr	r3, [r7, #0x78]
 8001a7e: b2da         	uxtb	r2, r3
 8001a80: 6d7b         	ldr	r3, [r7, #0x54]
 8001a82: 709a         	strb	r2, [r3, #0x2]
; 	if (s_ro_cnt != 0U) {
 8001a84: 6fbb         	ldr	r3, [r7, #0x78]
 8001a86: 2b00         	cmp	r3, #0x0
 8001a88: d032         	beq	0x8001af0 <cbvprintf_package+0x6c4> @ imm = #0x64
; 		for (i = 0; i < s_idx; i++) {
 8001a8a: 2300         	movs	r3, #0x0
 8001a8c: 673b         	str	r3, [r7, #0x70]
 8001a8e: e02a         	b	0x8001ae6 <cbvprintf_package+0x6ba> @ imm = #0x54
; 			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
 8001a90: f107 0230    	add.w	r2, r7, #0x30
 8001a94: 6f3b         	ldr	r3, [r7, #0x70]
 8001a96: 4413         	add	r3, r2
 8001a98: 781b         	ldrb	r3, [r3]
 8001a9a: b25b         	sxtb	r3, r3
 8001a9c: 2b00         	cmp	r3, #0x0
 8001a9e: da1e         	bge	0x8001ade <cbvprintf_package+0x6b2> @ imm = #0x3c
; 			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
 8001aa0: f107 0230    	add.w	r2, r7, #0x30
 8001aa4: 6f3b         	ldr	r3, [r7, #0x70]
 8001aa6: 4413         	add	r3, r2
 8001aa8: 781b         	ldrb	r3, [r3]
 8001aaa: f003 037f    	and	r3, r3, #0x7f
 8001aae: f887 3043    	strb.w	r3, [r7, #0x43]
; 			if ((BUF_OFFSET + 1) > len) {
 8001ab2: 6dfb         	ldr	r3, [r7, #0x5c]
 8001ab4: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001ab8: 1ad3         	subs	r3, r2, r3
 8001aba: 3301         	adds	r3, #0x1
 8001abc: 68ba         	ldr	r2, [r7, #0x8]
 8001abe: 429a         	cmp	r2, r3
 8001ac0: d202         	bhs	0x8001ac8 <cbvprintf_package+0x69c> @ imm = #0x4
; 				return -ENOSPC;
 8001ac2: f06f 031b    	mvn	r3, #0x1b
 8001ac6: e089         	b	0x8001bdc <cbvprintf_package+0x7b0> @ imm = #0x112
; 			*(uint8_t *)buf = pos;
 8001ac8: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001acc: f897 2043    	ldrb.w	r2, [r7, #0x43]
 8001ad0: 701a         	strb	r2, [r3]
; 			++buf;
 8001ad2: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001ad6: 3301         	adds	r3, #0x1
 8001ad8: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8001adc: e000         	b	0x8001ae0 <cbvprintf_package+0x6b4> @ imm = #0x0
; 				continue;
 8001ade: bf00         	nop
; 		for (i = 0; i < s_idx; i++) {
 8001ae0: 6f3b         	ldr	r3, [r7, #0x70]
 8001ae2: 3301         	adds	r3, #0x1
 8001ae4: 673b         	str	r3, [r7, #0x70]
 8001ae6: 6f3a         	ldr	r2, [r7, #0x70]
 8001ae8: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8001aec: 429a         	cmp	r2, r3
 8001aee: d3cf         	blo	0x8001a90 <cbvprintf_package+0x664> @ imm = #-0x62
; 	for (i = 0; i < s_idx; i++) {
 8001af0: 2300         	movs	r3, #0x0
 8001af2: 673b         	str	r3, [r7, #0x70]
 8001af4: e069         	b	0x8001bca <cbvprintf_package+0x79e> @ imm = #0xd2
; 		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
 8001af6: 6fbb         	ldr	r3, [r7, #0x78]
 8001af8: 2b00         	cmp	r3, #0x0
 8001afa: d007         	beq	0x8001b0c <cbvprintf_package+0x6e0> @ imm = #0xe
 8001afc: f107 0230    	add.w	r2, r7, #0x30
 8001b00: 6f3b         	ldr	r3, [r7, #0x70]
 8001b02: 4413         	add	r3, r2
 8001b04: 781b         	ldrb	r3, [r3]
 8001b06: b25b         	sxtb	r3, r3
 8001b08: 2b00         	cmp	r3, #0x0
 8001b0a: db5a         	blt	0x8001bc2 <cbvprintf_package+0x796> @ imm = #0xb4
; 		if (rws_pos_en) {
 8001b0c: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8001b10: 2b00         	cmp	r3, #0x0
 8001b12: d010         	beq	0x8001b36 <cbvprintf_package+0x70a> @ imm = #0x20
; 			size = 0;
 8001b14: 2300         	movs	r3, #0x0
 8001b16: f8c7 3088    	str.w	r3, [r7, #0x88]
; 			*(uint8_t *)buf = str_ptr_arg[i];
 8001b1a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001b1e: f107 0120    	add.w	r1, r7, #0x20
 8001b22: 6f3a         	ldr	r2, [r7, #0x70]
 8001b24: 440a         	add	r2, r1
 8001b26: 7812         	ldrb	r2, [r2]
 8001b28: 701a         	strb	r2, [r3]
; 			++buf;
 8001b2a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001b2e: 3301         	adds	r3, #0x1
 8001b30: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8001b34: e01a         	b	0x8001b6c <cbvprintf_package+0x740> @ imm = #0x34
; 			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
 8001b36: f107 0230    	add.w	r2, r7, #0x30
 8001b3a: 6f3b         	ldr	r3, [r7, #0x70]
 8001b3c: 4413         	add	r3, r2
 8001b3e: 781b         	ldrb	r3, [r3]
 8001b40: 009b         	lsls	r3, r3, #0x2
 8001b42: 6dfa         	ldr	r2, [r7, #0x5c]
 8001b44: 4413         	add	r3, r2
 8001b46: 681b         	ldr	r3, [r3]
 8001b48: 66fb         	str	r3, [r7, #0x6c]
; 			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
 8001b4a: f107 0230    	add.w	r2, r7, #0x30
 8001b4e: 6f3b         	ldr	r3, [r7, #0x70]
 8001b50: 4413         	add	r3, r2
 8001b52: 781b         	ldrb	r3, [r3]
 8001b54: 009b         	lsls	r3, r3, #0x2
 8001b56: 6dfa         	ldr	r2, [r7, #0x5c]
 8001b58: 4413         	add	r3, r2
 8001b5a: 2200         	movs	r2, #0x0
 8001b5c: 601a         	str	r2, [r3]
; 			size = strlen(s) + 1;
 8001b5e: 6ef8         	ldr	r0, [r7, #0x6c]
 8001b60: f7fe ffec    	bl	0x8000b3c <strlen>      @ imm = #-0x1028
 8001b64: 4603         	mov	r3, r0
 8001b66: 3301         	adds	r3, #0x1
 8001b68: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		if ((BUF_OFFSET + 1 + size) > len) {
 8001b6c: 6dfb         	ldr	r3, [r7, #0x5c]
 8001b6e: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001b72: 1ad2         	subs	r2, r2, r3
 8001b74: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8001b78: 4413         	add	r3, r2
 8001b7a: 3301         	adds	r3, #0x1
 8001b7c: 68ba         	ldr	r2, [r7, #0x8]
 8001b7e: 429a         	cmp	r2, r3
 8001b80: d202         	bhs	0x8001b88 <cbvprintf_package+0x75c> @ imm = #0x4
; 			return -ENOSPC;
 8001b82: f06f 031b    	mvn	r3, #0x1b
 8001b86: e029         	b	0x8001bdc <cbvprintf_package+0x7b0> @ imm = #0x52
; 		*(uint8_t *)buf = str_ptr_pos[i];
 8001b88: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001b8c: f107 0130    	add.w	r1, r7, #0x30
 8001b90: 6f3a         	ldr	r2, [r7, #0x70]
 8001b92: 440a         	add	r2, r1
 8001b94: 7812         	ldrb	r2, [r2]
 8001b96: 701a         	strb	r2, [r3]
; 		++buf;
 8001b98: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001b9c: 3301         	adds	r3, #0x1
 8001b9e: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		memcpy((void *)buf, (uint8_t *)s, size);
 8001ba2: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001ba6: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 8001baa: 6ef9         	ldr	r1, [r7, #0x6c]
 8001bac: 4618         	mov	r0, r3
 8001bae: f017 f8bc    	bl	0x8018d2a <memcpy>      @ imm = #0x17178
; 		buf += size;
 8001bb2: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001bb6: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8001bba: 4413         	add	r3, r2
 8001bbc: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8001bc0: e000         	b	0x8001bc4 <cbvprintf_package+0x798> @ imm = #0x0
; 			continue;
 8001bc2: bf00         	nop
; 	for (i = 0; i < s_idx; i++) {
 8001bc4: 6f3b         	ldr	r3, [r7, #0x70]
 8001bc6: 3301         	adds	r3, #0x1
 8001bc8: 673b         	str	r3, [r7, #0x70]
 8001bca: 6f3a         	ldr	r2, [r7, #0x70]
 8001bcc: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8001bd0: 429a         	cmp	r2, r3
 8001bd2: d390         	blo	0x8001af6 <cbvprintf_package+0x6ca> @ imm = #-0xe0
; 	return BUF_OFFSET;
 8001bd4: 6dfb         	ldr	r3, [r7, #0x5c]
 8001bd6: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001bda: 1ad3         	subs	r3, r2, r3
; }
 8001bdc: 4618         	mov	r0, r3
 8001bde: 3790         	adds	r7, #0x90
 8001be0: 46bd         	mov	sp, r7
 8001be2: bd80         	pop	{r7, pc}

08001be4 <__printk_hook_install>:
; {
 8001be4: b480         	push	{r7}
 8001be6: b083         	sub	sp, #0xc
 8001be8: af00         	add	r7, sp, #0x0
 8001bea: 6078         	str	r0, [r7, #0x4]
; 	_char_out = fn;
 8001bec: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8001bfc <__printk_hook_install+0x18>
 8001bee: 687b         	ldr	r3, [r7, #0x4]
 8001bf0: 6013         	str	r3, [r2]
; }
 8001bf2: bf00         	nop
 8001bf4: 370c         	adds	r7, #0xc
 8001bf6: 46bd         	mov	sp, r7
 8001bf8: bc80         	pop	{r7}
 8001bfa: 4770         	bx	lr

08001bfc <$d>:
 8001bfc: c4 02 00 20  	.word	0x200002c4

08001c00 <k_current_get>:
; {
 8001c00: b580         	push	{r7, lr}
 8001c02: af00         	add	r7, sp, #0x0
; 	return z_tls_current;
 8001c04: f017 fa74    	bl	0x80190f0 <__aeabi_read_tp> @ imm = #0x174e8
 8001c08: 4603         	mov	r3, r0
 8001c0a: 4a02         	ldr	r2, [pc, #0x8]          @ 0x8001c14 <k_current_get+0x14>
 8001c0c: 589b         	ldr	r3, [r3, r2]
; }
 8001c0e: 4618         	mov	r0, r3
 8001c10: bd80         	pop	{r7, pc}
 8001c12: bf00         	nop

08001c14 <$d>:
 8001c14: 08 00 00 00  	.word	0x00000008

08001c18 <z_thread_entry>:
; {
 8001c18: b580         	push	{r7, lr}
 8001c1a: b084         	sub	sp, #0x10
 8001c1c: af00         	add	r7, sp, #0x0
 8001c1e: 60f8         	str	r0, [r7, #0xc]
 8001c20: 60b9         	str	r1, [r7, #0x8]
 8001c22: 607a         	str	r2, [r7, #0x4]
 8001c24: 603b         	str	r3, [r7]
; 	z_tls_current = k_sched_current_thread_query();
 8001c26: f00e ffa6    	bl	0x8010b76 <k_sched_current_thread_query> @ imm = #0xef4c
 8001c2a: 4602         	mov	r2, r0
 8001c2c: f017 fa60    	bl	0x80190f0 <__aeabi_read_tp> @ imm = #0x174c0
 8001c30: 4603         	mov	r3, r0
 8001c32: 4906         	ldr	r1, [pc, #0x18]         @ 0x8001c4c <z_thread_entry+0x34>
 8001c34: 505a         	str	r2, [r3, r1]
; 	entry(p1, p2, p3);
 8001c36: 68fb         	ldr	r3, [r7, #0xc]
 8001c38: 683a         	ldr	r2, [r7]
 8001c3a: 6879         	ldr	r1, [r7, #0x4]
 8001c3c: 68b8         	ldr	r0, [r7, #0x8]
 8001c3e: 4798         	blx	r3
; 	k_thread_abort(k_current_get());
 8001c40: f7ff ffde    	bl	0x8001c00 <k_current_get> @ imm = #-0x44
 8001c44: 4603         	mov	r3, r0
 8001c46: 4618         	mov	r0, r3
 8001c48: f00e ff9c    	bl	0x8010b84 <k_thread_abort> @ imm = #0xef38

08001c4c <$d>:
 8001c4c: 08 00 00 00  	.word	0x00000008

08001c50 <LL_DBGMCU_DisableDBGStopMode>:
; {
 8001c50: b480         	push	{r7}
 8001c52: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8001c54: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8001c68 <LL_DBGMCU_DisableDBGStopMode+0x18>
 8001c56: 685b         	ldr	r3, [r3, #0x4]
 8001c58: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8001c68 <LL_DBGMCU_DisableDBGStopMode+0x18>
 8001c5a: f023 0302    	bic	r3, r3, #0x2
 8001c5e: 6053         	str	r3, [r2, #0x4]
; }
 8001c60: bf00         	nop
 8001c62: 46bd         	mov	sp, r7
 8001c64: bc80         	pop	{r7}
 8001c66: 4770         	bx	lr

08001c68 <$d>:
 8001c68: 00 20 04 e0  	.word	0xe0042000

08001c6c <LL_FLASH_EnablePrefetch>:
; {
 8001c6c: b480         	push	{r7}
 8001c6e: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_PRFTEN);
 8001c70: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8001c84 <LL_FLASH_EnablePrefetch+0x18>
 8001c72: 681b         	ldr	r3, [r3]
 8001c74: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8001c84 <LL_FLASH_EnablePrefetch+0x18>
 8001c76: f443 7380    	orr	r3, r3, #0x100
 8001c7a: 6013         	str	r3, [r2]
; }
 8001c7c: bf00         	nop
 8001c7e: 46bd         	mov	sp, r7
 8001c80: bc80         	pop	{r7}
 8001c82: 4770         	bx	lr

08001c84 <$d>:
 8001c84: 00 3c 02 40  	.word	0x40023c00

08001c88 <LL_FLASH_EnableInstCache>:
; {
 8001c88: b480         	push	{r7}
 8001c8a: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_ICEN);
 8001c8c: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8001ca0 <LL_FLASH_EnableInstCache+0x18>
 8001c8e: 681b         	ldr	r3, [r3]
 8001c90: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8001ca0 <LL_FLASH_EnableInstCache+0x18>
 8001c92: f443 7300    	orr	r3, r3, #0x200
 8001c96: 6013         	str	r3, [r2]
; }
 8001c98: bf00         	nop
 8001c9a: 46bd         	mov	sp, r7
 8001c9c: bc80         	pop	{r7}
 8001c9e: 4770         	bx	lr

08001ca0 <$d>:
 8001ca0: 00 3c 02 40  	.word	0x40023c00

08001ca4 <LL_FLASH_EnableDataCache>:
; {
 8001ca4: b480         	push	{r7}
 8001ca6: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_DCEN);
 8001ca8: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8001cbc <LL_FLASH_EnableDataCache+0x18>
 8001caa: 681b         	ldr	r3, [r3]
 8001cac: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8001cbc <LL_FLASH_EnableDataCache+0x18>
 8001cae: f443 6380    	orr	r3, r3, #0x400
 8001cb2: 6013         	str	r3, [r2]
; }
 8001cb4: bf00         	nop
 8001cb6: 46bd         	mov	sp, r7
 8001cb8: bc80         	pop	{r7}
 8001cba: 4770         	bx	lr

08001cbc <$d>:
 8001cbc: 00 3c 02 40  	.word	0x40023c00

08001cc0 <soc_early_init_hook>:
; {
 8001cc0: b580         	push	{r7, lr}
 8001cc2: af00         	add	r7, sp, #0x0
; 	LL_FLASH_EnablePrefetch();
 8001cc4: f7ff ffd2    	bl	0x8001c6c <LL_FLASH_EnablePrefetch> @ imm = #-0x5c
; 	LL_FLASH_EnableInstCache();
 8001cc8: f7ff ffde    	bl	0x8001c88 <LL_FLASH_EnableInstCache> @ imm = #-0x44
; 	LL_FLASH_EnableDataCache();
 8001ccc: f7ff ffea    	bl	0x8001ca4 <LL_FLASH_EnableDataCache> @ imm = #-0x2c
; 	SystemCoreClock = 16000000;
 8001cd0: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8001cdc <soc_early_init_hook+0x1c>
 8001cd2: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8001ce0 <soc_early_init_hook+0x20>
 8001cd4: 601a         	str	r2, [r3]
; }
 8001cd6: bf00         	nop
 8001cd8: bd80         	pop	{r7, pc}
 8001cda: bf00         	nop

08001cdc <$d>:
 8001cdc: 24 05 00 20  	.word	0x20000524
 8001ce0: 00 24 f4 00  	.word	0x00f42400

08001ce4 <log_backend_get>:
; {
 8001ce4: b480         	push	{r7}
 8001ce6: b085         	sub	sp, #0x14
 8001ce8: af00         	add	r7, sp, #0x0
 8001cea: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 8001cec: 687b         	ldr	r3, [r7, #0x4]
 8001cee: 011b         	lsls	r3, r3, #0x4
 8001cf0: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8001d04 <log_backend_get+0x20>
 8001cf2: 4413         	add	r3, r2
 8001cf4: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 8001cf6: 68fb         	ldr	r3, [r7, #0xc]
; }
 8001cf8: 4618         	mov	r0, r3
 8001cfa: 3714         	adds	r7, #0x14
 8001cfc: 46bd         	mov	sp, r7
 8001cfe: bc80         	pop	{r7}
 8001d00: 4770         	bx	lr
 8001d02: bf00         	nop

08001d04 <$d>:
 8001d04: 78 97 01 08  	.word	0x08019778

08001d08 <log_format_func_t_get>:
; {
 8001d08: b480         	push	{r7}
 8001d0a: b083         	sub	sp, #0xc
 8001d0c: af00         	add	r7, sp, #0x0
 8001d0e: 6078         	str	r0, [r7, #0x4]
; 	return format_table[log_type];
 8001d10: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8001d24 <log_format_func_t_get+0x1c>
 8001d12: 687b         	ldr	r3, [r7, #0x4]
 8001d14: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 8001d18: 4618         	mov	r0, r3
 8001d1a: 370c         	adds	r7, #0xc
 8001d1c: 46bd         	mov	sp, r7
 8001d1e: bc80         	pop	{r7}
 8001d20: 4770         	bx	lr
 8001d22: bf00         	nop

08001d24 <$d>:
 8001d24: 08 b4 01 08  	.word	0x0801b408

08001d28 <log_core_init>:
; {
 8001d28: b580         	push	{r7, lr}
 8001d2a: af00         	add	r7, sp, #0x0
; 	panic_mode = false;
 8001d2c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8001d4c <log_core_init+0x24>
 8001d2e: 2200         	movs	r2, #0x0
 8001d30: 701a         	strb	r2, [r3]
; 	dropped_cnt = 0;
 8001d32: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8001d50 <log_core_init+0x28>
 8001d34: 2200         	movs	r2, #0x0
 8001d36: 601a         	str	r2, [r3]
; 	buffered_cnt = 0;
 8001d38: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8001d54 <log_core_init+0x2c>
 8001d3a: 2200         	movs	r2, #0x0
 8001d3c: 601a         	str	r2, [r3]
; 		log_set_timestamp_func(default_lf_get_timestamp, 1000U);
 8001d3e: f44f 717a    	mov.w	r1, #0x3e8
 8001d42: 4805         	ldr	r0, [pc, #0x14]         @ 0x8001d58 <log_core_init+0x30>
 8001d44: f000 f86a    	bl	0x8001e1c <log_set_timestamp_func> @ imm = #0xd4
; }
 8001d48: bd80         	pop	{r7, pc}
 8001d4a: bf00         	nop

08001d4c <$d>:
 8001d4c: fc 10 00 20  	.word	0x200010fc
 8001d50: 94 0a 00 20  	.word	0x20000a94
 8001d54: 90 0a 00 20  	.word	0x20000a90
 8001d58: 09 0e 01 08  	.word	0x08010e09

08001d5c <z_log_init>:
; {
 8001d5c: b580         	push	{r7, lr}
 8001d5e: b086         	sub	sp, #0x18
 8001d60: af00         	add	r7, sp, #0x0
 8001d62: 4603         	mov	r3, r0
 8001d64: 460a         	mov	r2, r1
 8001d66: 71fb         	strb	r3, [r7, #0x7]
 8001d68: 4613         	mov	r3, r2
 8001d6a: 71bb         	strb	r3, [r7, #0x6]
; 	uint32_t mask = 0;
 8001d6c: 2300         	movs	r3, #0x0
 8001d6e: 617b         	str	r3, [r7, #0x14]
; 	if (atomic_inc(&initialized) != 0) {
 8001d70: 4827         	ldr	r0, [pc, #0x9c]         @ 0x8001e10 <z_log_init+0xb4>
 8001d72: f00e ff51    	bl	0x8010c18 <atomic_inc>  @ imm = #0xeea2
 8001d76: 4603         	mov	r3, r0
 8001d78: 2b00         	cmp	r3, #0x0
 8001d7a: d001         	beq	0x8001d80 <z_log_init+0x24> @ imm = #0x2
; 		return 0;
 8001d7c: 2300         	movs	r3, #0x0
 8001d7e: e042         	b	0x8001e06 <z_log_init+0xaa> @ imm = #0x84
; 	int backend_index = 0;
 8001d80: 2300         	movs	r3, #0x0
 8001d82: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8001d84: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8001e14 <z_log_init+0xb8>
 8001d86: 60fb         	str	r3, [r7, #0xc]
 8001d88: e022         	b	0x8001dd0 <z_log_init+0x74> @ imm = #0x44
; 		if (backend->autostart) {
 8001d8a: 68fb         	ldr	r3, [r7, #0xc]
 8001d8c: 7b1b         	ldrb	r3, [r3, #0xc]
 8001d8e: 2b00         	cmp	r3, #0x0
 8001d90: d018         	beq	0x8001dc4 <z_log_init+0x68> @ imm = #0x30
; 			log_backend_init(backend);
 8001d92: 68f8         	ldr	r0, [r7, #0xc]
 8001d94: f00e ffcc    	bl	0x8010d30 <log_backend_init> @ imm = #0xef98
; 			if (log_backend_is_ready(backend) == 0) {
 8001d98: 68f8         	ldr	r0, [r7, #0xc]
 8001d9a: f00e ffdb    	bl	0x8010d54 <log_backend_is_ready> @ imm = #0xefb6
 8001d9e: 4603         	mov	r3, r0
 8001da0: 2b00         	cmp	r3, #0x0
 8001da2: d108         	bne	0x8001db6 <z_log_init+0x5a> @ imm = #0x10
; 						   backend->cb->ctx,
 8001da4: 68fb         	ldr	r3, [r7, #0xc]
 8001da6: 685b         	ldr	r3, [r3, #0x4]
; 				log_backend_enable(backend,
 8001da8: 681b         	ldr	r3, [r3]
 8001daa: 2204         	movs	r2, #0x4
 8001dac: 4619         	mov	r1, r3
 8001dae: 68f8         	ldr	r0, [r7, #0xc]
 8001db0: f00f f92c    	bl	0x801100c <log_backend_enable> @ imm = #0xf258
 8001db4: e006         	b	0x8001dc4 <z_log_init+0x68> @ imm = #0xc
; 				mask |= BIT(backend_index);
 8001db6: 2201         	movs	r2, #0x1
 8001db8: 693b         	ldr	r3, [r7, #0x10]
 8001dba: fa02 f303    	lsl.w	r3, r2, r3
 8001dbe: 697a         	ldr	r2, [r7, #0x14]
 8001dc0: 4313         	orrs	r3, r2
 8001dc2: 617b         	str	r3, [r7, #0x14]
; 		++backend_index;
 8001dc4: 693b         	ldr	r3, [r7, #0x10]
 8001dc6: 3301         	adds	r3, #0x1
 8001dc8: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8001dca: 68fb         	ldr	r3, [r7, #0xc]
 8001dcc: 3310         	adds	r3, #0x10
 8001dce: 60fb         	str	r3, [r7, #0xc]
 8001dd0: 68fb         	ldr	r3, [r7, #0xc]
 8001dd2: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8001e18 <z_log_init+0xbc>
 8001dd4: 4293         	cmp	r3, r2
 8001dd6: bf34         	ite	lo
 8001dd8: 2301         	movlo	r3, #0x1
 8001dda: 2300         	movhs	r3, #0x0
 8001ddc: b2db         	uxtb	r3, r3
 8001dde: 2b00         	cmp	r3, #0x0
 8001de0: d1d3         	bne	0x8001d8a <z_log_init+0x2e> @ imm = #-0x5a
; 	if (blocking) {
 8001de2: 79fb         	ldrb	r3, [r7, #0x7]
 8001de4: 2b00         	cmp	r3, #0x0
 8001de6: d00d         	beq	0x8001e04 <z_log_init+0xa8> @ imm = #0x1a
; 		while (mask) {
 8001de8: e009         	b	0x8001dfe <z_log_init+0xa2> @ imm = #0x12
; 			mask = activate_foreach_backend(mask);
 8001dea: 6978         	ldr	r0, [r7, #0x14]
 8001dec: f00f f813    	bl	0x8010e16 <activate_foreach_backend> @ imm = #0xf026
 8001df0: 6178         	str	r0, [r7, #0x14]
; 			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
 8001df2: 79bb         	ldrb	r3, [r7, #0x6]
 8001df4: 2b00         	cmp	r3, #0x0
 8001df6: d002         	beq	0x8001dfe <z_log_init+0xa2> @ imm = #0x4
; 				k_msleep(10);
 8001df8: 200a         	movs	r0, #0xa
 8001dfa: f00e ff3a    	bl	0x8010c72 <k_msleep>    @ imm = #0xee74
; 		while (mask) {
 8001dfe: 697b         	ldr	r3, [r7, #0x14]
 8001e00: 2b00         	cmp	r3, #0x0
 8001e02: d1f2         	bne	0x8001dea <z_log_init+0x8e> @ imm = #-0x1c
; 	return mask;
 8001e04: 697b         	ldr	r3, [r7, #0x14]
; }
 8001e06: 4618         	mov	r0, r3
 8001e08: 3718         	adds	r7, #0x18
 8001e0a: 46bd         	mov	sp, r7
 8001e0c: bd80         	pop	{r7, pc}
 8001e0e: bf00         	nop

08001e10 <$d>:
 8001e10: 8c 0a 00 20  	.word	0x20000a8c
 8001e14: 78 97 01 08  	.word	0x08019778
 8001e18: 88 97 01 08  	.word	0x08019788

08001e1c <log_set_timestamp_func>:
; {
 8001e1c: b580         	push	{r7, lr}
 8001e1e: b082         	sub	sp, #0x8
 8001e20: af00         	add	r7, sp, #0x0
 8001e22: 6078         	str	r0, [r7, #0x4]
 8001e24: 6039         	str	r1, [r7]
; 	if (timestamp_getter == NULL) {
 8001e26: 687b         	ldr	r3, [r7, #0x4]
 8001e28: 2b00         	cmp	r3, #0x0
 8001e2a: d102         	bne	0x8001e32 <log_set_timestamp_func+0x16> @ imm = #0x4
; 		return -EINVAL;
 8001e2c: f06f 0315    	mvn	r3, #0x15
 8001e30: e009         	b	0x8001e46 <log_set_timestamp_func+0x2a> @ imm = #0x12
; 	timestamp_func = timestamp_getter;
 8001e32: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8001e50 <log_set_timestamp_func+0x34>
 8001e34: 687b         	ldr	r3, [r7, #0x4]
 8001e36: 6013         	str	r3, [r2]
; 	timestamp_freq = freq;
 8001e38: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8001e54 <log_set_timestamp_func+0x38>
 8001e3a: 683b         	ldr	r3, [r7]
 8001e3c: 6013         	str	r3, [r2]
; 		log_output_timestamp_freq_set(freq);
 8001e3e: 6838         	ldr	r0, [r7]
 8001e40: f000 fcea    	bl	0x8002818 <log_output_timestamp_freq_set> @ imm = #0x9d4
; 	return 0;
 8001e44: 2300         	movs	r3, #0x0
; }
 8001e46: 4618         	mov	r0, r3
 8001e48: 3708         	adds	r7, #0x8
 8001e4a: 46bd         	mov	sp, r7
 8001e4c: bd80         	pop	{r7, pc}
 8001e4e: bf00         	nop

08001e50 <$d>:
 8001e50: c8 02 00 20  	.word	0x200002c8
 8001e54: 98 0a 00 20  	.word	0x20000a98

08001e58 <z_impl_log_panic>:
; {
 8001e58: b580         	push	{r7, lr}
 8001e5a: b082         	sub	sp, #0x8
 8001e5c: af00         	add	r7, sp, #0x0
; 	if (panic_mode) {
 8001e5e: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8001eb0 <z_impl_log_panic+0x58>
 8001e60: 781b         	ldrb	r3, [r3]
 8001e62: 2b00         	cmp	r3, #0x0
 8001e64: d120         	bne	0x8001ea8 <z_impl_log_panic+0x50> @ imm = #0x40
; 	(void)z_log_init(true, false);
 8001e66: 2100         	movs	r1, #0x0
 8001e68: 2001         	movs	r0, #0x1
 8001e6a: f7ff ff77    	bl	0x8001d5c <z_log_init>  @ imm = #-0x112
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8001e6e: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8001eb4 <z_impl_log_panic+0x5c>
 8001e70: 607b         	str	r3, [r7, #0x4]
 8001e72: e00b         	b	0x8001e8c <z_impl_log_panic+0x34> @ imm = #0x16
; 		if (log_backend_is_active(backend)) {
 8001e74: 6878         	ldr	r0, [r7, #0x4]
 8001e76: f00e ff9e    	bl	0x8010db6 <log_backend_is_active> @ imm = #0xef3c
 8001e7a: 4603         	mov	r3, r0
 8001e7c: 2b00         	cmp	r3, #0x0
 8001e7e: d002         	beq	0x8001e86 <z_impl_log_panic+0x2e> @ imm = #0x4
; 			log_backend_panic(backend);
 8001e80: 6878         	ldr	r0, [r7, #0x4]
 8001e82: f00e ff8b    	bl	0x8010d9c <log_backend_panic> @ imm = #0xef16
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8001e86: 687b         	ldr	r3, [r7, #0x4]
 8001e88: 3310         	adds	r3, #0x10
 8001e8a: 607b         	str	r3, [r7, #0x4]
 8001e8c: 687b         	ldr	r3, [r7, #0x4]
 8001e8e: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8001eb8 <z_impl_log_panic+0x60>
 8001e90: 4293         	cmp	r3, r2
 8001e92: bf34         	ite	lo
 8001e94: 2301         	movlo	r3, #0x1
 8001e96: 2300         	movhs	r3, #0x0
 8001e98: b2db         	uxtb	r3, r3
 8001e9a: 2b00         	cmp	r3, #0x0
 8001e9c: d1ea         	bne	0x8001e74 <z_impl_log_panic+0x1c> @ imm = #-0x2c
; out:
 8001e9e: bf00         	nop
; 	panic_mode = true;
 8001ea0: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8001eb0 <z_impl_log_panic+0x58>
 8001ea2: 2201         	movs	r2, #0x1
 8001ea4: 701a         	strb	r2, [r3]
 8001ea6: e000         	b	0x8001eaa <z_impl_log_panic+0x52> @ imm = #0x0
; 		return;
 8001ea8: bf00         	nop
; }
 8001eaa: 3708         	adds	r7, #0x8
 8001eac: 46bd         	mov	sp, r7
 8001eae: bd80         	pop	{r7, pc}

08001eb0 <$d>:
 8001eb0: fc 10 00 20  	.word	0x200010fc
 8001eb4: 78 97 01 08  	.word	0x08019778
 8001eb8: 88 97 01 08  	.word	0x08019788

08001ebc <msg_process>:
; {
 8001ebc: b580         	push	{r7, lr}
 8001ebe: b084         	sub	sp, #0x10
 8001ec0: af00         	add	r7, sp, #0x0
 8001ec2: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8001ec4: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8001f10 <msg_process+0x54>
 8001ec6: 60fb         	str	r3, [r7, #0xc]
 8001ec8: e013         	b	0x8001ef2 <msg_process+0x36> @ imm = #0x26
; 		if (log_backend_is_active(backend) &&
 8001eca: 68f8         	ldr	r0, [r7, #0xc]
 8001ecc: f00e ff73    	bl	0x8010db6 <log_backend_is_active> @ imm = #0xeee6
 8001ed0: 4603         	mov	r3, r0
 8001ed2: 2b00         	cmp	r3, #0x0
 8001ed4: d00a         	beq	0x8001eec <msg_process+0x30> @ imm = #0x14
; 		    msg_filter_check(backend, msg)) {
 8001ed6: 6879         	ldr	r1, [r7, #0x4]
 8001ed8: 68f8         	ldr	r0, [r7, #0xc]
 8001eda: f00e ffd7    	bl	0x8010e8c <msg_filter_check> @ imm = #0xefae
 8001ede: 4603         	mov	r3, r0
; 		if (log_backend_is_active(backend) &&
 8001ee0: 2b00         	cmp	r3, #0x0
 8001ee2: d003         	beq	0x8001eec <msg_process+0x30> @ imm = #0x6
; 			log_backend_msg_process(backend, msg);
 8001ee4: 6879         	ldr	r1, [r7, #0x4]
 8001ee6: 68f8         	ldr	r0, [r7, #0xc]
 8001ee8: f00e ff49    	bl	0x8010d7e <log_backend_msg_process> @ imm = #0xee92
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8001eec: 68fb         	ldr	r3, [r7, #0xc]
 8001eee: 3310         	adds	r3, #0x10
 8001ef0: 60fb         	str	r3, [r7, #0xc]
 8001ef2: 68fb         	ldr	r3, [r7, #0xc]
 8001ef4: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8001f14 <msg_process+0x58>
 8001ef6: 4293         	cmp	r3, r2
 8001ef8: bf34         	ite	lo
 8001efa: 2301         	movlo	r3, #0x1
 8001efc: 2300         	movhs	r3, #0x0
 8001efe: b2db         	uxtb	r3, r3
 8001f00: 2b00         	cmp	r3, #0x0
 8001f02: d1e2         	bne	0x8001eca <msg_process+0xe> @ imm = #-0x3c
; }
 8001f04: bf00         	nop
 8001f06: bf00         	nop
 8001f08: 3710         	adds	r7, #0x10
 8001f0a: 46bd         	mov	sp, r7
 8001f0c: bd80         	pop	{r7, pc}
 8001f0e: bf00         	nop

08001f10 <$d>:
 8001f10: 78 97 01 08  	.word	0x08019778
 8001f14: 88 97 01 08  	.word	0x08019788

08001f18 <z_log_notify_backend_enabled>:
; {
 8001f18: b480         	push	{r7}
 8001f1a: af00         	add	r7, sp, #0x0
; 	backend_attached = true;
 8001f1c: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8001f2c <z_log_notify_backend_enabled+0x14>
 8001f1e: 2201         	movs	r2, #0x1
 8001f20: 701a         	strb	r2, [r3]
; }
 8001f22: bf00         	nop
 8001f24: 46bd         	mov	sp, r7
 8001f26: bc80         	pop	{r7}
 8001f28: 4770         	bx	lr
 8001f2a: bf00         	nop

08001f2c <$d>:
 8001f2c: fd 10 00 20  	.word	0x200010fd

08001f30 <z_log_dropped>:
; {
 8001f30: b580         	push	{r7, lr}
 8001f32: b082         	sub	sp, #0x8
 8001f34: af00         	add	r7, sp, #0x0
 8001f36: 4603         	mov	r3, r0
 8001f38: 71fb         	strb	r3, [r7, #0x7]
; 	atomic_inc(&dropped_cnt);
 8001f3a: 4806         	ldr	r0, [pc, #0x18]         @ 0x8001f54 <z_log_dropped+0x24>
 8001f3c: f00e fe6c    	bl	0x8010c18 <atomic_inc>  @ imm = #0xecd8
; 	if (buffered) {
 8001f40: 79fb         	ldrb	r3, [r7, #0x7]
 8001f42: 2b00         	cmp	r3, #0x0
 8001f44: d002         	beq	0x8001f4c <z_log_dropped+0x1c> @ imm = #0x4
; 		atomic_dec(&buffered_cnt);
 8001f46: 4804         	ldr	r0, [pc, #0x10]         @ 0x8001f58 <z_log_dropped+0x28>
 8001f48: f00e fe73    	bl	0x8010c32 <atomic_dec>  @ imm = #0xece6
; }
 8001f4c: bf00         	nop
 8001f4e: 3708         	adds	r7, #0x8
 8001f50: 46bd         	mov	sp, r7
 8001f52: bd80         	pop	{r7, pc}

08001f54 <$d>:
 8001f54: 94 0a 00 20  	.word	0x20000a94
 8001f58: 90 0a 00 20  	.word	0x20000a90

08001f5c <z_log_msg_commit>:
; {
 8001f5c: b580         	push	{r7, lr}
 8001f5e: b082         	sub	sp, #0x8
 8001f60: af00         	add	r7, sp, #0x0
 8001f62: 6078         	str	r0, [r7, #0x4]
; 	msg->hdr.timestamp = timestamp_func();
 8001f64: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8001f80 <z_log_msg_commit+0x24>
 8001f66: 681b         	ldr	r3, [r3]
 8001f68: 4798         	blx	r3
 8001f6a: 4602         	mov	r2, r0
 8001f6c: 687b         	ldr	r3, [r7, #0x4]
 8001f6e: 609a         	str	r2, [r3, #0x8]
; 	msg_commit(&log_buffer, msg);
 8001f70: 6879         	ldr	r1, [r7, #0x4]
 8001f72: 4804         	ldr	r0, [pc, #0x10]         @ 0x8001f84 <z_log_msg_commit+0x28>
 8001f74: f00e ff9f    	bl	0x8010eb6 <msg_commit>  @ imm = #0xef3e
; }
 8001f78: bf00         	nop
 8001f7a: 3708         	adds	r7, #0x8
 8001f7c: 46bd         	mov	sp, r7
 8001f7e: bd80         	pop	{r7, pc}

08001f80 <$d>:
 8001f80: c8 02 00 20  	.word	0x200002c8
 8001f84: 90 05 00 20  	.word	0x20000590

08001f88 <log_const_source_id>:
; {
 8001f88: b480         	push	{r7}
 8001f8a: b083         	sub	sp, #0xc
 8001f8c: af00         	add	r7, sp, #0x0
 8001f8e: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 8001f90: 687b         	ldr	r3, [r7, #0x4]
 8001f92: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8001fa4 <log_const_source_id+0x1c>
 8001f94: 1a9b         	subs	r3, r3, r2
 8001f96: 08db         	lsrs	r3, r3, #0x3
; }
 8001f98: 4618         	mov	r0, r3
 8001f9a: 370c         	adds	r7, #0xc
 8001f9c: 46bd         	mov	sp, r7
 8001f9e: bc80         	pop	{r7}
 8001fa0: 4770         	bx	lr
 8001fa2: bf00         	nop

08001fa4 <$d>:
 8001fa4: f8 96 01 08  	.word	0x080196f8

08001fa8 <z_log_sources_count>:
; {
 8001fa8: b580         	push	{r7, lr}
 8001faa: af00         	add	r7, sp, #0x0
; 	return log_const_source_id(TYPE_SECTION_END(log_const));
 8001fac: 4802         	ldr	r0, [pc, #0x8]          @ 0x8001fb8 <z_log_sources_count+0x10>
 8001fae: f7ff ffeb    	bl	0x8001f88 <log_const_source_id> @ imm = #-0x2a
 8001fb2: 4603         	mov	r3, r0
; }
 8001fb4: 4618         	mov	r0, r3
 8001fb6: bd80         	pop	{r7, pc}

08001fb8 <$d>:
 8001fb8: 78 97 01 08  	.word	0x08019778

08001fbc <log_backend_get>:
; {
 8001fbc: b480         	push	{r7}
 8001fbe: b085         	sub	sp, #0x14
 8001fc0: af00         	add	r7, sp, #0x0
 8001fc2: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 8001fc4: 687b         	ldr	r3, [r7, #0x4]
 8001fc6: 011b         	lsls	r3, r3, #0x4
 8001fc8: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8001fdc <log_backend_get+0x20>
 8001fca: 4413         	add	r3, r2
 8001fcc: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 8001fce: 68fb         	ldr	r3, [r7, #0xc]
; }
 8001fd0: 4618         	mov	r0, r3
 8001fd2: 3714         	adds	r7, #0x14
 8001fd4: 46bd         	mov	sp, r7
 8001fd6: bc80         	pop	{r7}
 8001fd8: 4770         	bx	lr
 8001fda: bf00         	nop

08001fdc <$d>:
 8001fdc: 78 97 01 08  	.word	0x08019778

08001fe0 <get_link_domain>:
; {
 8001fe0: b480         	push	{r7}
 8001fe2: b085         	sub	sp, #0x14
 8001fe4: af00         	add	r7, sp, #0x0
 8001fe6: 4603         	mov	r3, r0
 8001fe8: 6039         	str	r1, [r7]
 8001fea: 71fb         	strb	r3, [r7, #0x7]
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 8001fec: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8002050 <get_link_domain+0x70>
 8001fee: 60fb         	str	r3, [r7, #0xc]
 8001ff0: e01b         	b	0x800202a <get_link_domain+0x4a> @ imm = #0x36
; 		domain_max = link->ctrl_blk->domain_offset +
 8001ff2: 68fb         	ldr	r3, [r7, #0xc]
 8001ff4: 689b         	ldr	r3, [r3, #0x8]
 8001ff6: 689b         	ldr	r3, [r3, #0x8]
 8001ff8: b2da         	uxtb	r2, r3
; 				link->ctrl_blk->domain_cnt;
 8001ffa: 68fb         	ldr	r3, [r7, #0xc]
 8001ffc: 689b         	ldr	r3, [r3, #0x8]
 8001ffe: 681b         	ldr	r3, [r3]
; 		domain_max = link->ctrl_blk->domain_offset +
 8002000: b2db         	uxtb	r3, r3
 8002002: 4413         	add	r3, r2
 8002004: 72fb         	strb	r3, [r7, #0xb]
; 		if (domain_id < domain_max) {
 8002006: 79fa         	ldrb	r2, [r7, #0x7]
 8002008: 7afb         	ldrb	r3, [r7, #0xb]
 800200a: 429a         	cmp	r2, r3
 800200c: d20a         	bhs	0x8002024 <get_link_domain+0x44> @ imm = #0x14
; 			*rel_domain_id = domain_id - link->ctrl_blk->domain_offset;
 800200e: 68fb         	ldr	r3, [r7, #0xc]
 8002010: 689b         	ldr	r3, [r3, #0x8]
 8002012: 689b         	ldr	r3, [r3, #0x8]
 8002014: b2db         	uxtb	r3, r3
 8002016: 79fa         	ldrb	r2, [r7, #0x7]
 8002018: 1ad3         	subs	r3, r2, r3
 800201a: b2da         	uxtb	r2, r3
 800201c: 683b         	ldr	r3, [r7]
 800201e: 701a         	strb	r2, [r3]
; 			return link;
 8002020: 68fb         	ldr	r3, [r7, #0xc]
 8002022: e00f         	b	0x8002044 <get_link_domain+0x64> @ imm = #0x1e
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 8002024: 68fb         	ldr	r3, [r7, #0xc]
 8002026: 3318         	adds	r3, #0x18
 8002028: 60fb         	str	r3, [r7, #0xc]
 800202a: 68fb         	ldr	r3, [r7, #0xc]
 800202c: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8002054 <get_link_domain+0x74>
 800202e: 4293         	cmp	r3, r2
 8002030: bf34         	ite	lo
 8002032: 2301         	movlo	r3, #0x1
 8002034: 2300         	movhs	r3, #0x0
 8002036: b2db         	uxtb	r3, r3
 8002038: 2b00         	cmp	r3, #0x0
 800203a: d1da         	bne	0x8001ff2 <get_link_domain+0x12> @ imm = #-0x4c
; 	*rel_domain_id = 0;
 800203c: 683b         	ldr	r3, [r7]
 800203e: 2200         	movs	r2, #0x0
 8002040: 701a         	strb	r2, [r3]
; 	return NULL;
 8002042: 2300         	movs	r3, #0x0
; }
 8002044: 4618         	mov	r0, r3
 8002046: 3714         	adds	r7, #0x14
 8002048: 46bd         	mov	sp, r7
 800204a: bc80         	pop	{r7}
 800204c: 4770         	bx	lr
 800204e: bf00         	nop

08002050 <$d>:
 8002050: 88 97 01 08  	.word	0x08019788
 8002054: 88 97 01 08  	.word	0x08019788

08002058 <link_source_name_get>:
; {
 8002058: b580         	push	{r7, lr}
 800205a: b08a         	sub	sp, #0x28
 800205c: af02         	add	r7, sp, #0x8
 800205e: 4603         	mov	r3, r0
 8002060: 6039         	str	r1, [r7]
 8002062: 71fb         	strb	r3, [r7, #0x7]
; 	size_t cache_size = sname_cache.item_size;
 8002064: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80020d8 <link_source_name_get+0x80>
 8002066: 69db         	ldr	r3, [r3, #0x1c]
 8002068: 613b         	str	r3, [r7, #0x10]
; 	union log_source_ids id = {
 800206a: 79fb         	ldrb	r3, [r7, #0x7]
 800206c: 733b         	strb	r3, [r7, #0xc]
 800206e: 683b         	ldr	r3, [r7]
 8002070: b29b         	uxth	r3, r3
 8002072: 81fb         	strh	r3, [r7, #0xe]
; 	if (!log_cache_get(&sname_cache, id.raw, &cached)) {
 8002074: 68fb         	ldr	r3, [r7, #0xc]
 8002076: f107 0214    	add.w	r2, r7, #0x14
 800207a: 4619         	mov	r1, r3
 800207c: 4816         	ldr	r0, [pc, #0x58]         @ 0x80020d8 <link_source_name_get+0x80>
 800207e: f00f f8fc    	bl	0x801127a <log_cache_get> @ imm = #0xf1f8
 8002082: 4603         	mov	r3, r0
 8002084: f083 0301    	eor	r3, r3, #0x1
 8002088: b2db         	uxtb	r3, r3
 800208a: 2b00         	cmp	r3, #0x0
 800208c: d01f         	beq	0x80020ce <link_source_name_get+0x76> @ imm = #0x3e
; 		const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 800208e: f107 020b    	add.w	r2, r7, #0xb
 8002092: 79fb         	ldrb	r3, [r7, #0x7]
 8002094: 4611         	mov	r1, r2
 8002096: 4618         	mov	r0, r3
 8002098: f7ff ffa2    	bl	0x8001fe0 <get_link_domain> @ imm = #-0xbc
 800209c: 61f8         	str	r0, [r7, #0x1c]
; 		err = log_link_get_source_name(link, rel_domain_id, source_id,
 800209e: 7afb         	ldrb	r3, [r7, #0xb]
 80020a0: 4618         	mov	r0, r3
 80020a2: 683b         	ldr	r3, [r7]
 80020a4: b29a         	uxth	r2, r3
 80020a6: 6979         	ldr	r1, [r7, #0x14]
 80020a8: f107 0310    	add.w	r3, r7, #0x10
 80020ac: 9300         	str	r3, [sp]
 80020ae: 460b         	mov	r3, r1
 80020b0: 4601         	mov	r1, r0
 80020b2: 69f8         	ldr	r0, [r7, #0x1c]
 80020b4: f00e ff58    	bl	0x8010f68 <log_link_get_source_name> @ imm = #0xeeb0
 80020b8: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 80020ba: 69bb         	ldr	r3, [r7, #0x18]
 80020bc: 2b00         	cmp	r3, #0x0
 80020be: da01         	bge	0x80020c4 <link_source_name_get+0x6c> @ imm = #0x2
; 			return NULL;
 80020c0: 2300         	movs	r3, #0x0
 80020c2: e005         	b	0x80020d0 <link_source_name_get+0x78> @ imm = #0xa
; 		log_cache_put(&sname_cache, cached);
 80020c4: 697b         	ldr	r3, [r7, #0x14]
 80020c6: 4619         	mov	r1, r3
 80020c8: 4803         	ldr	r0, [pc, #0xc]          @ 0x80020d8 <link_source_name_get+0x80>
 80020ca: f00f f959    	bl	0x8011380 <log_cache_put> @ imm = #0xf2b2
; 	return (const char *)cached;
 80020ce: 697b         	ldr	r3, [r7, #0x14]
; }
 80020d0: 4618         	mov	r0, r3
 80020d2: 3720         	adds	r7, #0x20
 80020d4: 46bd         	mov	sp, r7
 80020d6: bd80         	pop	{r7, pc}

080020d8 <$d>:
 80020d8: 9c 0a 00 20  	.word	0x20000a9c

080020dc <log_source_name_get>:
; {
 80020dc: b580         	push	{r7, lr}
 80020de: b082         	sub	sp, #0x8
 80020e0: af00         	add	r7, sp, #0x0
 80020e2: 6078         	str	r0, [r7, #0x4]
 80020e4: 6039         	str	r1, [r7]
; 	if (z_log_is_local_domain(domain_id)) {
 80020e6: 687b         	ldr	r3, [r7, #0x4]
 80020e8: b2db         	uxtb	r3, r3
 80020ea: 4618         	mov	r0, r3
 80020ec: f00e ff00    	bl	0x8010ef0 <z_log_is_local_domain> @ imm = #0xee00
 80020f0: 4603         	mov	r3, r0
 80020f2: 2b00         	cmp	r3, #0x0
 80020f4: d00d         	beq	0x8002112 <log_source_name_get+0x36> @ imm = #0x1a
; 		if (source_id < log_src_cnt_get(domain_id)) {
 80020f6: 6878         	ldr	r0, [r7, #0x4]
 80020f8: f00e ff64    	bl	0x8010fc4 <log_src_cnt_get> @ imm = #0xeec8
 80020fc: 4602         	mov	r2, r0
 80020fe: 683b         	ldr	r3, [r7]
 8002100: 4293         	cmp	r3, r2
 8002102: d204         	bhs	0x800210e <log_source_name_get+0x32> @ imm = #0x8
; 			return TYPE_SECTION_START(log_const)[source_id].name;
 8002104: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8002128 <log_source_name_get+0x4c>
 8002106: 683b         	ldr	r3, [r7]
 8002108: f852 3033    	ldr.w	r3, [r2, r3, lsl #3]
 800210c: e008         	b	0x8002120 <log_source_name_get+0x44> @ imm = #0x10
; 			return NULL;
 800210e: 2300         	movs	r3, #0x0
 8002110: e006         	b	0x8002120 <log_source_name_get+0x44> @ imm = #0xc
; 	return link_source_name_get(domain_id, source_id);
 8002112: 687b         	ldr	r3, [r7, #0x4]
 8002114: b2db         	uxtb	r3, r3
 8002116: 6839         	ldr	r1, [r7]
 8002118: 4618         	mov	r0, r3
 800211a: f7ff ff9d    	bl	0x8002058 <link_source_name_get> @ imm = #-0xc6
 800211e: 4603         	mov	r3, r0
; }
 8002120: 4618         	mov	r0, r3
 8002122: 3708         	adds	r7, #0x8
 8002124: 46bd         	mov	sp, r7
 8002126: bd80         	pop	{r7, pc}

08002128 <$d>:
 8002128: f8 96 01 08  	.word	0x080196f8

0800212c <log_const_source_id>:
; {
 800212c: b480         	push	{r7}
 800212e: b083         	sub	sp, #0xc
 8002130: af00         	add	r7, sp, #0x0
 8002132: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 8002134: 687b         	ldr	r3, [r7, #0x4]
 8002136: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8002148 <log_const_source_id+0x1c>
 8002138: 1a9b         	subs	r3, r3, r2
 800213a: 08db         	lsrs	r3, r3, #0x3
; }
 800213c: 4618         	mov	r0, r3
 800213e: 370c         	adds	r7, #0xc
 8002140: 46bd         	mov	sp, r7
 8002142: bc80         	pop	{r7}
 8002144: 4770         	bx	lr
 8002146: bf00         	nop

08002148 <$d>:
 8002148: f8 96 01 08  	.word	0x080196f8

0800214c <z_log_msg_runtime_vcreate>:
; {
 800214c: b580         	push	{r7, lr}
 800214e: b090         	sub	sp, #0x40
 8002150: af04         	add	r7, sp, #0x10
 8002152: 60b9         	str	r1, [r7, #0x8]
 8002154: 607b         	str	r3, [r7, #0x4]
 8002156: 4603         	mov	r3, r0
 8002158: 73fb         	strb	r3, [r7, #0xf]
 800215a: 4613         	mov	r3, r2
 800215c: 73bb         	strb	r3, [r7, #0xe]
; 	if (fmt) {
 800215e: 6c3b         	ldr	r3, [r7, #0x40]
 8002160: 2b00         	cmp	r3, #0x0
 8002162: d00b         	beq	0x800217c <z_log_msg_runtime_vcreate+0x30> @ imm = #0x16
; 		va_copy(ap2, ap);
 8002164: 6c7b         	ldr	r3, [r7, #0x44]
 8002166: 613b         	str	r3, [r7, #0x10]
; 		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
 8002168: 693b         	ldr	r3, [r7, #0x10]
 800216a: 9300         	str	r3, [sp]
 800216c: 6c3b         	ldr	r3, [r7, #0x40]
 800216e: 6bfa         	ldr	r2, [r7, #0x3c]
 8002170: 2110         	movs	r1, #0x10
 8002172: 2000         	movs	r0, #0x0
 8002174: f7ff f95a    	bl	0x800142c <cbvprintf_package> @ imm = #-0xd4c
 8002178: 62f8         	str	r0, [r7, #0x2c]
 800217a: e001         	b	0x8002180 <z_log_msg_runtime_vcreate+0x34> @ imm = #0x2
; 		plen = 0;
 800217c: 2300         	movs	r3, #0x0
 800217e: 62fb         	str	r3, [r7, #0x2c]
; 	if (plen > Z_LOG_MSG_MAX_PACKAGE) {
 8002180: 6afb         	ldr	r3, [r7, #0x2c]
 8002182: f5b3 6f00    	cmp.w	r3, #0x800
 8002186: d31d         	blo	0x80021c4 <z_log_msg_runtime_vcreate+0x78> @ imm = #0x3a
; 		LOG_WRN("Message dropped because it exceeds size limitation (%u)",
 8002188: 2303         	movs	r3, #0x3
 800218a: 2b01         	cmp	r3, #0x1
 800218c: d973         	bls	0x8002276 <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xe6
 800218e: 2301         	movs	r3, #0x1
 8002190: 77fb         	strb	r3, [r7, #0x1f]
 8002192: 7ffb         	ldrb	r3, [r7, #0x1f]
 8002194: f083 0301    	eor	r3, r3, #0x1
 8002198: b2db         	uxtb	r3, r3
 800219a: 2b00         	cmp	r3, #0x0
 800219c: d16b         	bne	0x8002276 <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xd6
 800219e: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x800227c <z_log_msg_runtime_vcreate+0x130>
 80021a0: 6819         	ldr	r1, [r3]
 80021a2: f240 73ff    	movw	r3, #0x7ff
 80021a6: 9303         	str	r3, [sp, #0xc]
 80021a8: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8002280 <z_log_msg_runtime_vcreate+0x134>
 80021aa: 9302         	str	r3, [sp, #0x8]
 80021ac: 2300         	movs	r3, #0x0
 80021ae: 9301         	str	r3, [sp, #0x4]
 80021b0: 2300         	movs	r3, #0x0
 80021b2: 9300         	str	r3, [sp]
 80021b4: 2300         	movs	r3, #0x0
 80021b6: 2202         	movs	r2, #0x2
 80021b8: 2000         	movs	r0, #0x0
 80021ba: f00f f8f3    	bl	0x80113a4 <z_log_msg_runtime_create> @ imm = #0xf1e6
 80021be: 2300         	movs	r3, #0x0
 80021c0: 61bb         	str	r3, [r7, #0x18]
; 		return;
 80021c2: e058         	b	0x8002276 <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xb0
; 	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
 80021c4: 6afa         	ldr	r2, [r7, #0x2c]
 80021c6: 6bbb         	ldr	r3, [r7, #0x38]
 80021c8: 4413         	add	r3, r2
 80021ca: 3317         	adds	r3, #0x17
 80021cc: f023 0307    	bic	r3, r3, #0x7
 80021d0: 3303         	adds	r3, #0x3
 80021d2: 089b         	lsrs	r3, r3, #0x2
 80021d4: 62bb         	str	r3, [r7, #0x28]
; 	struct log_msg_desc desc =
 80021d6: 7d3b         	ldrb	r3, [r7, #0x14]
 80021d8: f36f 0300    	bfc	r3, #0, #1
 80021dc: 753b         	strb	r3, [r7, #0x14]
 80021de: 7d3b         	ldrb	r3, [r7, #0x14]
 80021e0: f36f 0341    	bfc	r3, #1, #1
 80021e4: 753b         	strb	r3, [r7, #0x14]
 80021e6: 7d3b         	ldrb	r3, [r7, #0x14]
 80021e8: f36f 0382    	bfc	r3, #2, #1
 80021ec: 753b         	strb	r3, [r7, #0x14]
 80021ee: 7bfb         	ldrb	r3, [r7, #0xf]
 80021f0: f003 0307    	and	r3, r3, #0x7
 80021f4: b2da         	uxtb	r2, r3
 80021f6: 7d3b         	ldrb	r3, [r7, #0x14]
 80021f8: f362 03c5    	bfi	r3, r2, #3, #3
 80021fc: 753b         	strb	r3, [r7, #0x14]
 80021fe: 7bbb         	ldrb	r3, [r7, #0xe]
 8002200: f003 0307    	and	r3, r3, #0x7
 8002204: b2da         	uxtb	r2, r3
 8002206: 8abb         	ldrh	r3, [r7, #0x14]
 8002208: f362 1388    	bfi	r3, r2, #6, #3
 800220c: 82bb         	strh	r3, [r7, #0x14]
 800220e: 6afb         	ldr	r3, [r7, #0x2c]
 8002210: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8002214: b29a         	uxth	r2, r3
 8002216: 697b         	ldr	r3, [r7, #0x14]
 8002218: f362 2353    	bfi	r3, r2, #9, #11
 800221c: 617b         	str	r3, [r7, #0x14]
 800221e: 6bbb         	ldr	r3, [r7, #0x38]
 8002220: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8002224: b29a         	uxth	r2, r3
 8002226: 8afb         	ldrh	r3, [r7, #0x16]
 8002228: f362 130f    	bfi	r3, r2, #4, #12
 800222c: 82fb         	strh	r3, [r7, #0x16]
; 		msg = alloca(msg_wlen * sizeof(int));
 800222e: 6abb         	ldr	r3, [r7, #0x28]
 8002230: 009b         	lsls	r3, r3, #0x2
 8002232: 3307         	adds	r3, #0x7
 8002234: 08db         	lsrs	r3, r3, #0x3
 8002236: 00db         	lsls	r3, r3, #0x3
 8002238: ebad 0d03    	sub.w	sp, sp, r3
 800223c: ab04         	add	r3, sp, #0x10
 800223e: 3307         	adds	r3, #0x7
 8002240: 08db         	lsrs	r3, r3, #0x3
 8002242: 00db         	lsls	r3, r3, #0x3
 8002244: 627b         	str	r3, [r7, #0x24]
; 		pkg = msg->data;
 8002246: 6a7b         	ldr	r3, [r7, #0x24]
 8002248: 3310         	adds	r3, #0x10
 800224a: 623b         	str	r3, [r7, #0x20]
; 	if (pkg && fmt) {
 800224c: 6a3b         	ldr	r3, [r7, #0x20]
 800224e: 2b00         	cmp	r3, #0x0
 8002250: d00b         	beq	0x800226a <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x16
 8002252: 6c3b         	ldr	r3, [r7, #0x40]
 8002254: 2b00         	cmp	r3, #0x0
 8002256: d008         	beq	0x800226a <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x10
; 		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
 8002258: 6af9         	ldr	r1, [r7, #0x2c]
 800225a: 6c7b         	ldr	r3, [r7, #0x44]
 800225c: 9300         	str	r3, [sp]
 800225e: 6c3b         	ldr	r3, [r7, #0x40]
 8002260: 6bfa         	ldr	r2, [r7, #0x3c]
 8002262: 6a38         	ldr	r0, [r7, #0x20]
 8002264: f7ff f8e2    	bl	0x800142c <cbvprintf_package> @ imm = #-0xe3c
 8002268: 62f8         	str	r0, [r7, #0x2c]
; 		z_log_msg_finalize(msg, source, desc, data);
 800226a: 687b         	ldr	r3, [r7, #0x4]
 800226c: 697a         	ldr	r2, [r7, #0x14]
 800226e: 68b9         	ldr	r1, [r7, #0x8]
 8002270: 6a78         	ldr	r0, [r7, #0x24]
 8002272: f00f f8e5    	bl	0x8011440 <z_log_msg_finalize> @ imm = #0xf1ca
; }
 8002276: 3730         	adds	r7, #0x30
 8002278: 46bd         	mov	sp, r7
 800227a: bd80         	pop	{r7, pc}

0800227c <$d>:
 800227c: cc 02 00 20  	.word	0x200002cc
 8002280: 9c 9a 01 08  	.word	0x08019a9c

08002284 <cbpprintf>:
; {
 8002284: b580         	push	{r7, lr}
 8002286: b084         	sub	sp, #0x10
 8002288: af00         	add	r7, sp, #0x0
 800228a: 60f8         	str	r0, [r7, #0xc]
 800228c: 60b9         	str	r1, [r7, #0x8]
 800228e: 607a         	str	r2, [r7, #0x4]
; 	return cbpprintf_external(out, cbvprintf, ctx, packaged);
 8002290: 687b         	ldr	r3, [r7, #0x4]
 8002292: 68ba         	ldr	r2, [r7, #0x8]
 8002294: 4904         	ldr	r1, [pc, #0x10]         @ 0x80022a8 <cbpprintf+0x24>
 8002296: 68f8         	ldr	r0, [r7, #0xc]
 8002298: f00e fbeb    	bl	0x8010a72 <cbpprintf_external> @ imm = #0xe7d6
 800229c: 4603         	mov	r3, r0
; }
 800229e: 4618         	mov	r0, r3
 80022a0: 3710         	adds	r7, #0x10
 80022a2: 46bd         	mov	sp, r7
 80022a4: bd80         	pop	{r7, pc}
 80022a6: bf00         	nop

080022a8 <$d>:
 80022a8: 85 3c 00 08  	.word	0x08003c85

080022ac <__ctype_lookup>:
; static __inline char __ctype_lookup(int c) { return (__CTYPE_PTR + 1)[c]; }
 80022ac: b480         	push	{r7}
 80022ae: b083         	sub	sp, #0xc
 80022b0: af00         	add	r7, sp, #0x0
 80022b2: 6078         	str	r0, [r7, #0x4]
 80022b4: 687b         	ldr	r3, [r7, #0x4]
 80022b6: 3301         	adds	r3, #0x1
 80022b8: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80022c8 <__ctype_lookup+0x1c>
 80022ba: 4413         	add	r3, r2
 80022bc: 781b         	ldrb	r3, [r3]
 80022be: 4618         	mov	r0, r3
 80022c0: 370c         	adds	r7, #0xc
 80022c2: 46bd         	mov	sp, r7
 80022c4: bc80         	pop	{r7}
 80022c6: 4770         	bx	lr

080022c8 <$d>:
 80022c8: 88 be 01 08  	.word	0x0801be88

080022cc <print_formatted>:
; {
 80022cc: b40e         	push	{r1, r2, r3}
 80022ce: b580         	push	{r7, lr}
 80022d0: b085         	sub	sp, #0x14
 80022d2: af00         	add	r7, sp, #0x0
 80022d4: 6078         	str	r0, [r7, #0x4]
; 	int length = 0;
 80022d6: 2300         	movs	r3, #0x0
 80022d8: 60fb         	str	r3, [r7, #0xc]
; 	va_start(args, fmt);
 80022da: f107 0320    	add.w	r3, r7, #0x20
 80022de: 60bb         	str	r3, [r7, #0x8]
; 	length = cbvprintf(out_func, (void *)output, fmt, args);
 80022e0: 68bb         	ldr	r3, [r7, #0x8]
 80022e2: 69fa         	ldr	r2, [r7, #0x1c]
 80022e4: 6879         	ldr	r1, [r7, #0x4]
 80022e6: 4806         	ldr	r0, [pc, #0x18]         @ 0x8002300 <print_formatted+0x34>
 80022e8: f001 fccc    	bl	0x8003c84 <cbvprintf>   @ imm = #0x1998
 80022ec: 60f8         	str	r0, [r7, #0xc]
; 	return length;
 80022ee: 68fb         	ldr	r3, [r7, #0xc]
; }
 80022f0: 4618         	mov	r0, r3
 80022f2: 3714         	adds	r7, #0x14
 80022f4: 46bd         	mov	sp, r7
 80022f6: e8bd 4080    	pop.w	{r7, lr}
 80022fa: b003         	add	sp, #0xc
 80022fc: 4770         	bx	lr
 80022fe: bf00         	nop

08002300 <$d>:
 8002300: 1d 16 01 08  	.word	0x0801161d

08002304 <timestamp_print>:
; {
 8002304: b580         	push	{r7, lr}
 8002306: b09a         	sub	sp, #0x68
 8002308: af04         	add	r7, sp, #0x10
 800230a: 60f8         	str	r0, [r7, #0xc]
 800230c: 60b9         	str	r1, [r7, #0x8]
 800230e: 607a         	str	r2, [r7, #0x4]
; 		IS_ENABLED(CONFIG_LOG_OUTPUT_FORMAT_LINUX_TIMESTAMP) |
 8002310: 68bb         	ldr	r3, [r7, #0x8]
 8002312: f003 0344    	and	r3, r3, #0x44
; 	bool format =
 8002316: 2b00         	cmp	r3, #0x0
 8002318: bf14         	ite	ne
 800231a: 2301         	movne	r3, #0x1
 800231c: 2300         	moveq	r3, #0x0
 800231e: f887 3037    	strb.w	r3, [r7, #0x37]
; 	if (!format) {
 8002322: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8002326: f083 0301    	eor	r3, r3, #0x1
 800232a: b2db         	uxtb	r3, r3
 800232c: 2b00         	cmp	r3, #0x0
 800232e: d006         	beq	0x800233e <timestamp_print+0x3a> @ imm = #0xc
; 		length = print_formatted(output, "[%08lu] ", timestamp);
 8002330: 687a         	ldr	r2, [r7, #0x4]
 8002332: 4938         	ldr	r1, [pc, #0xe0]         @ 0x8002414 <timestamp_print+0x110>
 8002334: 68f8         	ldr	r0, [r7, #0xc]
 8002336: f7ff ffc9    	bl	0x80022cc <print_formatted> @ imm = #-0x6e
 800233a: 63b8         	str	r0, [r7, #0x38]
 800233c: e065         	b	0x800240a <timestamp_print+0x106> @ imm = #0xca
; 	} else if (freq != 0U) {
 800233e: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8002418 <timestamp_print+0x114>
 8002340: 681b         	ldr	r3, [r3]
 8002342: 2b00         	cmp	r3, #0x0
 8002344: d05f         	beq	0x8002406 <timestamp_print+0x102> @ imm = #0xbe
; 		timestamp /= timestamp_div;
 8002346: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800241c <timestamp_print+0x118>
 8002348: 681b         	ldr	r3, [r3]
 800234a: 687a         	ldr	r2, [r7, #0x4]
 800234c: fbb2 f3f3    	udiv	r3, r2, r3
 8002350: 607b         	str	r3, [r7, #0x4]
; 		total_seconds = timestamp / freq;
 8002352: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8002418 <timestamp_print+0x114>
 8002354: 681b         	ldr	r3, [r3]
 8002356: 687a         	ldr	r2, [r7, #0x4]
 8002358: fbb2 f3f3    	udiv	r3, r2, r3
 800235c: 63fb         	str	r3, [r7, #0x3c]
; 		seconds = total_seconds;
 800235e: 6bfb         	ldr	r3, [r7, #0x3c]
 8002360: 653b         	str	r3, [r7, #0x50]
; 		hours = seconds / 3600U;
 8002362: 6d3b         	ldr	r3, [r7, #0x50]
 8002364: 4a2e         	ldr	r2, [pc, #0xb8]         @ 0x8002420 <timestamp_print+0x11c>
 8002366: fba2 2303    	umull	r2, r3, r2, r3
 800236a: 0adb         	lsrs	r3, r3, #0xb
 800236c: 643b         	str	r3, [r7, #0x40]
; 		seconds -= hours * 3600U;
 800236e: 6c3b         	ldr	r3, [r7, #0x40]
 8002370: f44f 6261    	mov.w	r2, #0xe10
 8002374: fb02 f303    	mul	r3, r2, r3
 8002378: 6d3a         	ldr	r2, [r7, #0x50]
 800237a: 1ad3         	subs	r3, r2, r3
 800237c: 653b         	str	r3, [r7, #0x50]
; 		mins = seconds / 60U;
 800237e: 6d3b         	ldr	r3, [r7, #0x50]
 8002380: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x8002424 <timestamp_print+0x120>
 8002382: fba2 2303    	umull	r2, r3, r2, r3
 8002386: 095b         	lsrs	r3, r3, #0x5
 8002388: 657b         	str	r3, [r7, #0x54]
; 		seconds -= mins * 60U;
 800238a: 6d7a         	ldr	r2, [r7, #0x54]
 800238c: 4613         	mov	r3, r2
 800238e: 011b         	lsls	r3, r3, #0x4
 8002390: 1a9b         	subs	r3, r3, r2
 8002392: 009b         	lsls	r3, r3, #0x2
 8002394: 461a         	mov	r2, r3
 8002396: 6d3b         	ldr	r3, [r7, #0x50]
 8002398: 1a9b         	subs	r3, r3, r2
 800239a: 653b         	str	r3, [r7, #0x50]
; 		remainder = timestamp % freq;
 800239c: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8002418 <timestamp_print+0x114>
 800239e: 681a         	ldr	r2, [r3]
 80023a0: 687b         	ldr	r3, [r7, #0x4]
 80023a2: fbb3 f1f2    	udiv	r1, r3, r2
 80023a6: fb01 f202    	mul	r2, r1, r2
 80023aa: 1a9b         	subs	r3, r3, r2
 80023ac: 64fb         	str	r3, [r7, #0x4c]
; 		ms = (remainder * 1000U) / freq;
 80023ae: 6cfb         	ldr	r3, [r7, #0x4c]
 80023b0: f44f 727a    	mov.w	r2, #0x3e8
 80023b4: fb03 f202    	mul	r2, r3, r2
 80023b8: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8002418 <timestamp_print+0x114>
 80023ba: 681b         	ldr	r3, [r3]
 80023bc: fbb2 f3f3    	udiv	r3, r2, r3
 80023c0: 64bb         	str	r3, [r7, #0x48]
; 		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 80023c2: 6cfb         	ldr	r3, [r7, #0x4c]
 80023c4: f44f 727a    	mov.w	r2, #0x3e8
 80023c8: fb03 f202    	mul	r2, r3, r2
 80023cc: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8002418 <timestamp_print+0x114>
 80023ce: 681b         	ldr	r3, [r3]
 80023d0: 6cb9         	ldr	r1, [r7, #0x48]
 80023d2: fb01 f303    	mul	r3, r1, r3
 80023d6: 1ad3         	subs	r3, r2, r3
 80023d8: f44f 727a    	mov.w	r2, #0x3e8
 80023dc: fb03 f202    	mul	r2, r3, r2
 80023e0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8002418 <timestamp_print+0x114>
 80023e2: 681b         	ldr	r3, [r3]
 80023e4: fbb2 f3f3    	udiv	r3, r2, r3
 80023e8: 647b         	str	r3, [r7, #0x44]
; 				length = print_formatted(output,
 80023ea: 6c7b         	ldr	r3, [r7, #0x44]
 80023ec: 9302         	str	r3, [sp, #0x8]
 80023ee: 6cbb         	ldr	r3, [r7, #0x48]
 80023f0: 9301         	str	r3, [sp, #0x4]
 80023f2: 6d3b         	ldr	r3, [r7, #0x50]
 80023f4: 9300         	str	r3, [sp]
 80023f6: 6d7b         	ldr	r3, [r7, #0x54]
 80023f8: 6c3a         	ldr	r2, [r7, #0x40]
 80023fa: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8002428 <timestamp_print+0x124>
 80023fc: 68f8         	ldr	r0, [r7, #0xc]
 80023fe: f7ff ff65    	bl	0x80022cc <print_formatted> @ imm = #-0x136
 8002402: 63b8         	str	r0, [r7, #0x38]
 8002404: e001         	b	0x800240a <timestamp_print+0x106> @ imm = #0x2
; 		length = 0;
 8002406: 2300         	movs	r3, #0x0
 8002408: 63bb         	str	r3, [r7, #0x38]
; 	return length;
 800240a: 6bbb         	ldr	r3, [r7, #0x38]
; }
 800240c: 4618         	mov	r0, r3
 800240e: 3758         	adds	r7, #0x58
 8002410: 46bd         	mov	sp, r7
 8002412: bd80         	pop	{r7, pc}

08002414 <$d>:
 8002414: f4 9a 01 08  	.word	0x08019af4
 8002418: bc 0a 00 20  	.word	0x20000abc
 800241c: c0 0a 00 20  	.word	0x20000ac0
 8002420: c5 b3 a2 91  	.word	0x91a2b3c5
 8002424: 89 88 88 88  	.word	0x88888889
 8002428: 00 9b 01 08  	.word	0x08019b00

0800242c <color_print>:
; {
 800242c: b580         	push	{r7, lr}
 800242e: b086         	sub	sp, #0x18
 8002430: af00         	add	r7, sp, #0x0
 8002432: 60f8         	str	r0, [r7, #0xc]
 8002434: 607b         	str	r3, [r7, #0x4]
 8002436: 460b         	mov	r3, r1
 8002438: 72fb         	strb	r3, [r7, #0xb]
 800243a: 4613         	mov	r3, r2
 800243c: 72bb         	strb	r3, [r7, #0xa]
; 	if (color) {
 800243e: 7afb         	ldrb	r3, [r7, #0xb]
 8002440: 2b00         	cmp	r3, #0x0
 8002442: d014         	beq	0x800246e <color_print+0x42> @ imm = #0x28
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8002444: 7abb         	ldrb	r3, [r7, #0xa]
 8002446: 2b00         	cmp	r3, #0x0
 8002448: d00a         	beq	0x8002460 <color_print+0x34> @ imm = #0x14
; 		const char *log_color = start && (colors[level] != NULL) ?
 800244a: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8002478 <color_print+0x4c>
 800244c: 687b         	ldr	r3, [r7, #0x4]
 800244e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8002452: 2b00         	cmp	r3, #0x0
 8002454: d004         	beq	0x8002460 <color_print+0x34> @ imm = #0x8
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8002456: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8002478 <color_print+0x4c>
 8002458: 687b         	ldr	r3, [r7, #0x4]
 800245a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800245e: e000         	b	0x8002462 <color_print+0x36> @ imm = #0x0
 8002460: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800247c <color_print+0x50>
; 		const char *log_color = start && (colors[level] != NULL) ?
 8002462: 617b         	str	r3, [r7, #0x14]
; 		print_formatted(output, "%s", log_color);
 8002464: 697a         	ldr	r2, [r7, #0x14]
 8002466: 4906         	ldr	r1, [pc, #0x18]         @ 0x8002480 <color_print+0x54>
 8002468: 68f8         	ldr	r0, [r7, #0xc]
 800246a: f7ff ff2f    	bl	0x80022cc <print_formatted> @ imm = #-0x1a2
; }
 800246e: bf00         	nop
 8002470: 3718         	adds	r7, #0x18
 8002472: 46bd         	mov	sp, r7
 8002474: bd80         	pop	{r7, pc}
 8002476: bf00         	nop

08002478 <$d>:
 8002478: 2c b4 01 08  	.word	0x0801b42c
 800247c: 1c 9b 01 08  	.word	0x08019b1c
 8002480: 24 9b 01 08  	.word	0x08019b24

08002484 <ids_print>:
; {
 8002484: b580         	push	{r7, lr}
 8002486: b084         	sub	sp, #0x10
 8002488: af00         	add	r7, sp, #0x0
 800248a: 6078         	str	r0, [r7, #0x4]
 800248c: 4608         	mov	r0, r1
 800248e: 4611         	mov	r1, r2
 8002490: 461a         	mov	r2, r3
 8002492: 4603         	mov	r3, r0
 8002494: 70fb         	strb	r3, [r7, #0x3]
 8002496: 460b         	mov	r3, r1
 8002498: 70bb         	strb	r3, [r7, #0x2]
 800249a: 4613         	mov	r3, r2
 800249c: 707b         	strb	r3, [r7, #0x1]
; 	int total = 0;
 800249e: 2300         	movs	r3, #0x0
 80024a0: 60fb         	str	r3, [r7, #0xc]
; 	if (level_on) {
 80024a2: 78fb         	ldrb	r3, [r7, #0x3]
 80024a4: 2b00         	cmp	r3, #0x0
 80024a6: d00c         	beq	0x80024c2 <ids_print+0x3e> @ imm = #0x18
; 		total += print_formatted(output, "<%s> ", severity[level]);
 80024a8: 4a19         	ldr	r2, [pc, #0x64]         @ 0x8002510 <ids_print+0x8c>
 80024aa: 6a7b         	ldr	r3, [r7, #0x24]
 80024ac: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80024b0: 461a         	mov	r2, r3
 80024b2: 4918         	ldr	r1, [pc, #0x60]         @ 0x8002514 <ids_print+0x90>
 80024b4: 6878         	ldr	r0, [r7, #0x4]
 80024b6: f7ff ff09    	bl	0x80022cc <print_formatted> @ imm = #-0x1ee
 80024ba: 4602         	mov	r2, r0
 80024bc: 68fb         	ldr	r3, [r7, #0xc]
 80024be: 4413         	add	r3, r2
 80024c0: 60fb         	str	r3, [r7, #0xc]
; 	if (domain) {
 80024c2: 69bb         	ldr	r3, [r7, #0x18]
 80024c4: 2b00         	cmp	r3, #0x0
 80024c6: d008         	beq	0x80024da <ids_print+0x56> @ imm = #0x10
; 		total += print_formatted(output, "%s/", domain);
 80024c8: 69ba         	ldr	r2, [r7, #0x18]
 80024ca: 4913         	ldr	r1, [pc, #0x4c]         @ 0x8002518 <ids_print+0x94>
 80024cc: 6878         	ldr	r0, [r7, #0x4]
 80024ce: f7ff fefd    	bl	0x80022cc <print_formatted> @ imm = #-0x206
 80024d2: 4602         	mov	r2, r0
 80024d4: 68fb         	ldr	r3, [r7, #0xc]
 80024d6: 4413         	add	r3, r2
 80024d8: 60fb         	str	r3, [r7, #0xc]
; 	if (source) {
 80024da: 69fb         	ldr	r3, [r7, #0x1c]
 80024dc: 2b00         	cmp	r3, #0x0
 80024de: d011         	beq	0x8002504 <ids_print+0x80> @ imm = #0x22
; 		total += print_formatted(output,
 80024e0: 78bb         	ldrb	r3, [r7, #0x2]
 80024e2: 2b00         	cmp	r3, #0x0
 80024e4: d004         	beq	0x80024f0 <ids_print+0x6c> @ imm = #0x8
; 				(func_on &&
 80024e6: 6a7b         	ldr	r3, [r7, #0x24]
 80024e8: 2b04         	cmp	r3, #0x4
 80024ea: d101         	bne	0x80024f0 <ids_print+0x6c> @ imm = #0x2
; 		total += print_formatted(output,
 80024ec: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800251c <ids_print+0x98>
 80024ee: e000         	b	0x80024f2 <ids_print+0x6e> @ imm = #0x0
 80024f0: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002520 <ids_print+0x9c>
 80024f2: 69fa         	ldr	r2, [r7, #0x1c]
 80024f4: 4619         	mov	r1, r3
 80024f6: 6878         	ldr	r0, [r7, #0x4]
 80024f8: f7ff fee8    	bl	0x80022cc <print_formatted> @ imm = #-0x230
 80024fc: 4602         	mov	r2, r0
 80024fe: 68fb         	ldr	r3, [r7, #0xc]
 8002500: 4413         	add	r3, r2
 8002502: 60fb         	str	r3, [r7, #0xc]
; 	return total;
 8002504: 68fb         	ldr	r3, [r7, #0xc]
; }
 8002506: 4618         	mov	r0, r3
 8002508: 3710         	adds	r7, #0x10
 800250a: 46bd         	mov	sp, r7
 800250c: bd80         	pop	{r7, pc}
 800250e: bf00         	nop

08002510 <$d>:
 8002510: 18 b4 01 08  	.word	0x0801b418
 8002514: 28 9b 01 08  	.word	0x08019b28
 8002518: 30 9b 01 08  	.word	0x08019b30
 800251c: 34 9b 01 08  	.word	0x08019b34
 8002520: 38 9b 01 08  	.word	0x08019b38

08002524 <newline_print>:
; {
 8002524: b580         	push	{r7, lr}
 8002526: b082         	sub	sp, #0x8
 8002528: af00         	add	r7, sp, #0x0
 800252a: 6078         	str	r0, [r7, #0x4]
 800252c: 6039         	str	r1, [r7]
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 800252e: 683b         	ldr	r3, [r7]
 8002530: f003 0310    	and	r3, r3, #0x10
 8002534: 2b00         	cmp	r3, #0x0
 8002536: d10e         	bne	0x8002556 <newline_print+0x32> @ imm = #0x1c
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 8002538: 683b         	ldr	r3, [r7]
 800253a: f003 0320    	and	r3, r3, #0x20
 800253e: 2b00         	cmp	r3, #0x0
 8002540: d004         	beq	0x800254c <newline_print+0x28> @ imm = #0x8
; 		print_formatted(ctx, "\n");
 8002542: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8002560 <newline_print+0x3c>
 8002544: 6878         	ldr	r0, [r7, #0x4]
 8002546: f7ff fec1    	bl	0x80022cc <print_formatted> @ imm = #-0x27e
 800254a: e005         	b	0x8002558 <newline_print+0x34> @ imm = #0xa
; 		print_formatted(ctx, "\r\n");
 800254c: 4905         	ldr	r1, [pc, #0x14]         @ 0x8002564 <newline_print+0x40>
 800254e: 6878         	ldr	r0, [r7, #0x4]
 8002550: f7ff febc    	bl	0x80022cc <print_formatted> @ imm = #-0x288
 8002554: e000         	b	0x8002558 <newline_print+0x34> @ imm = #0x0
; 		return;
 8002556: bf00         	nop
; }
 8002558: 3708         	adds	r7, #0x8
 800255a: 46bd         	mov	sp, r7
 800255c: bd80         	pop	{r7, pc}
 800255e: bf00         	nop

08002560 <$d>:
 8002560: 40 9b 01 08  	.word	0x08019b40
 8002564: 44 9b 01 08  	.word	0x08019b44

08002568 <hexdump_line_print>:
; {
 8002568: b580         	push	{r7, lr}
 800256a: b088         	sub	sp, #0x20
 800256c: af00         	add	r7, sp, #0x0
 800256e: 60f8         	str	r0, [r7, #0xc]
 8002570: 60b9         	str	r1, [r7, #0x8]
 8002572: 607a         	str	r2, [r7, #0x4]
 8002574: 603b         	str	r3, [r7]
; 	newline_print(output, flags);
 8002576: 6ab9         	ldr	r1, [r7, #0x28]
 8002578: 68f8         	ldr	r0, [r7, #0xc]
 800257a: f7ff ffd3    	bl	0x8002524 <newline_print> @ imm = #-0x5a
; 	for (int i = 0; i < prefix_offset; i++) {
 800257e: 2300         	movs	r3, #0x0
 8002580: 61fb         	str	r3, [r7, #0x1c]
 8002582: e006         	b	0x8002592 <hexdump_line_print+0x2a> @ imm = #0xc
; 		print_formatted(output, " ");
 8002584: 4937         	ldr	r1, [pc, #0xdc]         @ 0x8002664 <hexdump_line_print+0xfc>
 8002586: 68f8         	ldr	r0, [r7, #0xc]
 8002588: f7ff fea0    	bl	0x80022cc <print_formatted> @ imm = #-0x2c0
; 	for (int i = 0; i < prefix_offset; i++) {
 800258c: 69fb         	ldr	r3, [r7, #0x1c]
 800258e: 3301         	adds	r3, #0x1
 8002590: 61fb         	str	r3, [r7, #0x1c]
 8002592: 69fa         	ldr	r2, [r7, #0x1c]
 8002594: 683b         	ldr	r3, [r7]
 8002596: 429a         	cmp	r2, r3
 8002598: dbf4         	blt	0x8002584 <hexdump_line_print+0x1c> @ imm = #-0x18
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 800259a: 2300         	movs	r3, #0x0
 800259c: 61bb         	str	r3, [r7, #0x18]
 800259e: e020         	b	0x80025e2 <hexdump_line_print+0x7a> @ imm = #0x40
; 		if (i > 0 && !(i % 8)) {
 80025a0: 69bb         	ldr	r3, [r7, #0x18]
 80025a2: 2b00         	cmp	r3, #0x0
 80025a4: dd08         	ble	0x80025b8 <hexdump_line_print+0x50> @ imm = #0x10
 80025a6: 69bb         	ldr	r3, [r7, #0x18]
 80025a8: f003 0307    	and	r3, r3, #0x7
 80025ac: 2b00         	cmp	r3, #0x0
 80025ae: d103         	bne	0x80025b8 <hexdump_line_print+0x50> @ imm = #0x6
; 			print_formatted(output, " ");
 80025b0: 492c         	ldr	r1, [pc, #0xb0]         @ 0x8002664 <hexdump_line_print+0xfc>
 80025b2: 68f8         	ldr	r0, [r7, #0xc]
 80025b4: f7ff fe8a    	bl	0x80022cc <print_formatted> @ imm = #-0x2ec
; 		if (i < length) {
 80025b8: 69bb         	ldr	r3, [r7, #0x18]
 80025ba: 687a         	ldr	r2, [r7, #0x4]
 80025bc: 429a         	cmp	r2, r3
 80025be: d909         	bls	0x80025d4 <hexdump_line_print+0x6c> @ imm = #0x12
; 			print_formatted(output, "%02x ", data[i]);
 80025c0: 69bb         	ldr	r3, [r7, #0x18]
 80025c2: 68ba         	ldr	r2, [r7, #0x8]
 80025c4: 4413         	add	r3, r2
 80025c6: 781b         	ldrb	r3, [r3]
 80025c8: 461a         	mov	r2, r3
 80025ca: 4927         	ldr	r1, [pc, #0x9c]         @ 0x8002668 <hexdump_line_print+0x100>
 80025cc: 68f8         	ldr	r0, [r7, #0xc]
 80025ce: f7ff fe7d    	bl	0x80022cc <print_formatted> @ imm = #-0x306
 80025d2: e003         	b	0x80025dc <hexdump_line_print+0x74> @ imm = #0x6
; 			print_formatted(output, "   ");
 80025d4: 4925         	ldr	r1, [pc, #0x94]         @ 0x800266c <hexdump_line_print+0x104>
 80025d6: 68f8         	ldr	r0, [r7, #0xc]
 80025d8: f7ff fe78    	bl	0x80022cc <print_formatted> @ imm = #-0x310
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 80025dc: 69bb         	ldr	r3, [r7, #0x18]
 80025de: 3301         	adds	r3, #0x1
 80025e0: 61bb         	str	r3, [r7, #0x18]
 80025e2: 69bb         	ldr	r3, [r7, #0x18]
 80025e4: 2b0f         	cmp	r3, #0xf
 80025e6: dddb         	ble	0x80025a0 <hexdump_line_print+0x38> @ imm = #-0x4a
; 	print_formatted(output, "|");
 80025e8: 4921         	ldr	r1, [pc, #0x84]         @ 0x8002670 <hexdump_line_print+0x108>
 80025ea: 68f8         	ldr	r0, [r7, #0xc]
 80025ec: f7ff fe6e    	bl	0x80022cc <print_formatted> @ imm = #-0x324
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 80025f0: 2300         	movs	r3, #0x0
 80025f2: 617b         	str	r3, [r7, #0x14]
 80025f4: e02d         	b	0x8002652 <hexdump_line_print+0xea> @ imm = #0x5a
; 		if (i > 0 && !(i % 8)) {
 80025f6: 697b         	ldr	r3, [r7, #0x14]
 80025f8: 2b00         	cmp	r3, #0x0
 80025fa: dd08         	ble	0x800260e <hexdump_line_print+0xa6> @ imm = #0x10
 80025fc: 697b         	ldr	r3, [r7, #0x14]
 80025fe: f003 0307    	and	r3, r3, #0x7
 8002602: 2b00         	cmp	r3, #0x0
 8002604: d103         	bne	0x800260e <hexdump_line_print+0xa6> @ imm = #0x6
; 			print_formatted(output, " ");
 8002606: 4917         	ldr	r1, [pc, #0x5c]         @ 0x8002664 <hexdump_line_print+0xfc>
 8002608: 68f8         	ldr	r0, [r7, #0xc]
 800260a: f7ff fe5f    	bl	0x80022cc <print_formatted> @ imm = #-0x342
; 		if (i < length) {
 800260e: 697b         	ldr	r3, [r7, #0x14]
 8002610: 687a         	ldr	r2, [r7, #0x4]
 8002612: 429a         	cmp	r2, r3
 8002614: d916         	bls	0x8002644 <hexdump_line_print+0xdc> @ imm = #0x2c
; 			unsigned char c = (unsigned char)data[i];
 8002616: 697b         	ldr	r3, [r7, #0x14]
 8002618: 68ba         	ldr	r2, [r7, #0x8]
 800261a: 4413         	add	r3, r2
 800261c: 781b         	ldrb	r3, [r3]
 800261e: 74fb         	strb	r3, [r7, #0x13]
; 			      isprint((int)c) != 0 ? c : '.');
 8002620: 7cfb         	ldrb	r3, [r7, #0x13]
 8002622: 4618         	mov	r0, r3
 8002624: f7ff fe42    	bl	0x80022ac <__ctype_lookup> @ imm = #-0x37c
 8002628: 4603         	mov	r3, r0
 800262a: f003 0397    	and	r3, r3, #0x97
; 			print_formatted(output, "%c",
 800262e: 2b00         	cmp	r3, #0x0
 8002630: d001         	beq	0x8002636 <hexdump_line_print+0xce> @ imm = #0x2
 8002632: 7cfb         	ldrb	r3, [r7, #0x13]
 8002634: e000         	b	0x8002638 <hexdump_line_print+0xd0> @ imm = #0x0
 8002636: 232e         	movs	r3, #0x2e
 8002638: 461a         	mov	r2, r3
 800263a: 490e         	ldr	r1, [pc, #0x38]         @ 0x8002674 <hexdump_line_print+0x10c>
 800263c: 68f8         	ldr	r0, [r7, #0xc]
 800263e: f7ff fe45    	bl	0x80022cc <print_formatted> @ imm = #-0x376
 8002642: e003         	b	0x800264c <hexdump_line_print+0xe4> @ imm = #0x6
; 			print_formatted(output, " ");
 8002644: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8002664 <hexdump_line_print+0xfc>
 8002646: 68f8         	ldr	r0, [r7, #0xc]
 8002648: f7ff fe40    	bl	0x80022cc <print_formatted> @ imm = #-0x380
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 800264c: 697b         	ldr	r3, [r7, #0x14]
 800264e: 3301         	adds	r3, #0x1
 8002650: 617b         	str	r3, [r7, #0x14]
 8002652: 697b         	ldr	r3, [r7, #0x14]
 8002654: 2b0f         	cmp	r3, #0xf
 8002656: ddce         	ble	0x80025f6 <hexdump_line_print+0x8e> @ imm = #-0x64
; }
 8002658: bf00         	nop
 800265a: bf00         	nop
 800265c: 3720         	adds	r7, #0x20
 800265e: 46bd         	mov	sp, r7
 8002660: bd80         	pop	{r7, pc}
 8002662: bf00         	nop

08002664 <$d>:
 8002664: 48 9b 01 08  	.word	0x08019b48
 8002668: 4c 9b 01 08  	.word	0x08019b4c
 800266c: 54 9b 01 08  	.word	0x08019b54
 8002670: 58 9b 01 08  	.word	0x08019b58
 8002674: 5c 9b 01 08  	.word	0x08019b5c

08002678 <prefix_print>:
; {
 8002678: b590         	push	{r4, r7, lr}
 800267a: b08d         	sub	sp, #0x34
 800267c: af04         	add	r7, sp, #0x10
 800267e: 60f8         	str	r0, [r7, #0xc]
 8002680: 60b9         	str	r1, [r7, #0x8]
 8002682: 603b         	str	r3, [r7]
 8002684: 4613         	mov	r3, r2
 8002686: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t length = 0U;
 8002688: 2300         	movs	r3, #0x0
 800268a: 61fb         	str	r3, [r7, #0x1c]
; 	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
 800268c: 68bb         	ldr	r3, [r7, #0x8]
 800268e: f003 0302    	and	r3, r3, #0x2
 8002692: 2b00         	cmp	r3, #0x0
 8002694: bf14         	ite	ne
 8002696: 2301         	movne	r3, #0x1
 8002698: 2300         	moveq	r3, #0x0
 800269a: 76fb         	strb	r3, [r7, #0x1b]
; 	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
 800269c: 68bb         	ldr	r3, [r7, #0x8]
 800269e: f003 0301    	and	r3, r3, #0x1
 80026a2: 2b00         	cmp	r3, #0x0
 80026a4: bf14         	ite	ne
 80026a6: 2301         	movne	r3, #0x1
 80026a8: 2300         	moveq	r3, #0x0
 80026aa: 76bb         	strb	r3, [r7, #0x1a]
; 	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
 80026ac: 68bb         	ldr	r3, [r7, #0x8]
 80026ae: f003 0308    	and	r3, r3, #0x8
 80026b2: 2b00         	cmp	r3, #0x0
 80026b4: bf14         	ite	ne
 80026b6: 2301         	movne	r3, #0x1
 80026b8: 2300         	moveq	r3, #0x0
 80026ba: 767b         	strb	r3, [r7, #0x19]
; 	bool thread_on = IS_ENABLED(CONFIG_LOG_THREAD_ID_PREFIX) &&
 80026bc: 2300         	movs	r3, #0x0
 80026be: 74fb         	strb	r3, [r7, #0x13]
; 	bool source_off = flags & LOG_OUTPUT_FLAG_SKIP_SOURCE;
 80026c0: 68bb         	ldr	r3, [r7, #0x8]
 80026c2: f403 7380    	and	r3, r3, #0x100
 80026c6: 2b00         	cmp	r3, #0x0
 80026c8: bf14         	ite	ne
 80026ca: 2301         	movne	r3, #0x1
 80026cc: 2300         	moveq	r3, #0x0
 80026ce: 763b         	strb	r3, [r7, #0x18]
; 	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
 80026d0: f00e fbfe    	bl	0x8010ed0 <z_log_get_tag> @ imm = #0xe7fc
 80026d4: 6178         	str	r0, [r7, #0x14]
; 	if (tag) {
 80026d6: 697b         	ldr	r3, [r7, #0x14]
 80026d8: 2b00         	cmp	r3, #0x0
 80026da: d009         	beq	0x80026f0 <prefix_print+0x78> @ imm = #0x12
; 		length += print_formatted(output, "%s ", tag);
 80026dc: 697a         	ldr	r2, [r7, #0x14]
 80026de: 491e         	ldr	r1, [pc, #0x78]         @ 0x8002758 <prefix_print+0xe0>
 80026e0: 68f8         	ldr	r0, [r7, #0xc]
 80026e2: f7ff fdf3    	bl	0x80022cc <print_formatted> @ imm = #-0x41a
 80026e6: 4603         	mov	r3, r0
 80026e8: 461a         	mov	r2, r3
 80026ea: 69fb         	ldr	r3, [r7, #0x1c]
 80026ec: 4413         	add	r3, r2
 80026ee: 61fb         	str	r3, [r7, #0x1c]
; 	if (stamp) {
 80026f0: 7efb         	ldrb	r3, [r7, #0x1b]
 80026f2: 2b00         	cmp	r3, #0x0
 80026f4: d009         	beq	0x800270a <prefix_print+0x92> @ imm = #0x12
; 		length += timestamp_print(output, flags, timestamp);
 80026f6: 683a         	ldr	r2, [r7]
 80026f8: 68b9         	ldr	r1, [r7, #0x8]
 80026fa: 68f8         	ldr	r0, [r7, #0xc]
 80026fc: f7ff fe02    	bl	0x8002304 <timestamp_print> @ imm = #-0x3fc
 8002700: 4603         	mov	r3, r0
 8002702: 461a         	mov	r2, r3
 8002704: 69fb         	ldr	r3, [r7, #0x1c]
 8002706: 4413         	add	r3, r2
 8002708: 61fb         	str	r3, [r7, #0x1c]
; 		color_prefix(output, colors_on, level);
 800270a: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 800270e: 7ebb         	ldrb	r3, [r7, #0x1a]
 8002710: 4619         	mov	r1, r3
 8002712: 68f8         	ldr	r0, [r7, #0xc]
 8002714: f00e ffaf    	bl	0x8011676 <color_prefix> @ imm = #0xef5e
; 	length += ids_print(output, level_on, func_on, thread_on, domain,
 8002718: 7cfc         	ldrb	r4, [r7, #0x13]
 800271a: 7e3b         	ldrb	r3, [r7, #0x18]
 800271c: 2b00         	cmp	r3, #0x0
 800271e: d001         	beq	0x8002724 <prefix_print+0xac> @ imm = #0x2
 8002720: 2300         	movs	r3, #0x0
 8002722: e000         	b	0x8002726 <prefix_print+0xae> @ imm = #0x0
 8002724: 6b7b         	ldr	r3, [r7, #0x34]
 8002726: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 800272a: 79f8         	ldrb	r0, [r7, #0x7]
 800272c: 7e79         	ldrb	r1, [r7, #0x19]
 800272e: 9203         	str	r2, [sp, #0xc]
 8002730: 6bba         	ldr	r2, [r7, #0x38]
 8002732: 9202         	str	r2, [sp, #0x8]
 8002734: 9301         	str	r3, [sp, #0x4]
 8002736: 6b3b         	ldr	r3, [r7, #0x30]
 8002738: 9300         	str	r3, [sp]
 800273a: 4623         	mov	r3, r4
 800273c: 4602         	mov	r2, r0
 800273e: 68f8         	ldr	r0, [r7, #0xc]
 8002740: f7ff fea0    	bl	0x8002484 <ids_print>   @ imm = #-0x2c0
 8002744: 4603         	mov	r3, r0
 8002746: 461a         	mov	r2, r3
 8002748: 69fb         	ldr	r3, [r7, #0x1c]
 800274a: 4413         	add	r3, r2
 800274c: 61fb         	str	r3, [r7, #0x1c]
; 	return length;
 800274e: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8002750: 4618         	mov	r0, r3
 8002752: 3724         	adds	r7, #0x24
 8002754: 46bd         	mov	sp, r7
 8002756: bd90         	pop	{r4, r7, pc}

08002758 <$d>:
 8002758: 68 9b 01 08  	.word	0x08019b68

0800275c <log_output_process>:
; {
 800275c: b580         	push	{r7, lr}
 800275e: b08c         	sub	sp, #0x30
 8002760: af04         	add	r7, sp, #0x10
 8002762: 60f8         	str	r0, [r7, #0xc]
 8002764: 60b9         	str	r1, [r7, #0x8]
 8002766: 607a         	str	r2, [r7, #0x4]
 8002768: 603b         	str	r3, [r7]
; 	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
 800276a: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 800276e: 2b00         	cmp	r3, #0x0
 8002770: bf0c         	ite	eq
 8002772: 2301         	moveq	r3, #0x1
 8002774: 2300         	movne	r3, #0x0
 8002776: 75fb         	strb	r3, [r7, #0x17]
; 	if (!raw_string) {
 8002778: 7dfb         	ldrb	r3, [r7, #0x17]
 800277a: f083 0301    	eor	r3, r3, #0x1
 800277e: b2db         	uxtb	r3, r3
 8002780: 2b00         	cmp	r3, #0x0
 8002782: d012         	beq	0x80027aa <log_output_process+0x4e> @ imm = #0x24
; 		prefix_offset = prefix_print(output, flags, 0, timestamp,
 8002784: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8002788: 9303         	str	r3, [sp, #0xc]
 800278a: 6abb         	ldr	r3, [r7, #0x28]
 800278c: 9302         	str	r3, [sp, #0x8]
 800278e: 683b         	ldr	r3, [r7]
 8002790: 9301         	str	r3, [sp, #0x4]
 8002792: 687b         	ldr	r3, [r7, #0x4]
 8002794: 9300         	str	r3, [sp]
 8002796: 68bb         	ldr	r3, [r7, #0x8]
 8002798: 2200         	movs	r2, #0x0
 800279a: 6bf9         	ldr	r1, [r7, #0x3c]
 800279c: 68f8         	ldr	r0, [r7, #0xc]
 800279e: f7ff ff6b    	bl	0x8002678 <prefix_print> @ imm = #-0x12a
 80027a2: 61f8         	str	r0, [r7, #0x1c]
; 		cb = out_func;
 80027a4: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8002810 <log_output_process+0xb4>
 80027a6: 61bb         	str	r3, [r7, #0x18]
 80027a8: e008         	b	0x80027bc <log_output_process+0x60> @ imm = #0x10
; 		prefix_offset = 0;
 80027aa: 2300         	movs	r3, #0x0
 80027ac: 61fb         	str	r3, [r7, #0x1c]
; 		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
 80027ae: 683b         	ldr	r3, [r7]
 80027b0: 2b01         	cmp	r3, #0x1
 80027b2: d101         	bne	0x80027b8 <log_output_process+0x5c> @ imm = #0x2
 80027b4: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8002810 <log_output_process+0xb4>
 80027b6: e000         	b	0x80027ba <log_output_process+0x5e> @ imm = #0x0
 80027b8: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8002814 <log_output_process+0xb8>
 80027ba: 61bb         	str	r3, [r7, #0x18]
; 	if (package) {
 80027bc: 6b3b         	ldr	r3, [r7, #0x30]
 80027be: 2b00         	cmp	r3, #0x0
 80027c0: d005         	beq	0x80027ce <log_output_process+0x72> @ imm = #0xa
; 		int err = cbpprintf(cb, (void *)output, (void *)package);
 80027c2: 6b3a         	ldr	r2, [r7, #0x30]
 80027c4: 68f9         	ldr	r1, [r7, #0xc]
 80027c6: 69b8         	ldr	r0, [r7, #0x18]
 80027c8: f7ff fd5c    	bl	0x8002284 <cbpprintf>   @ imm = #-0x548
 80027cc: 6138         	str	r0, [r7, #0x10]
; 	if (data_len) {
 80027ce: 6bbb         	ldr	r3, [r7, #0x38]
 80027d0: 2b00         	cmp	r3, #0x0
 80027d2: d008         	beq	0x80027e6 <log_output_process+0x8a> @ imm = #0x10
; 		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
 80027d4: 69fa         	ldr	r2, [r7, #0x1c]
 80027d6: 6bfb         	ldr	r3, [r7, #0x3c]
 80027d8: 9300         	str	r3, [sp]
 80027da: 4613         	mov	r3, r2
 80027dc: 6bba         	ldr	r2, [r7, #0x38]
 80027de: 6b79         	ldr	r1, [r7, #0x34]
 80027e0: 68f8         	ldr	r0, [r7, #0xc]
 80027e2: f00e ff6a    	bl	0x80116ba <log_msg_hexdump> @ imm = #0xeed4
; 	if (!raw_string) {
 80027e6: 7dfb         	ldrb	r3, [r7, #0x17]
 80027e8: f083 0301    	eor	r3, r3, #0x1
 80027ec: b2db         	uxtb	r3, r3
 80027ee: 2b00         	cmp	r3, #0x0
 80027f0: d006         	beq	0x8002800 <log_output_process+0xa4> @ imm = #0xc
; 		postfix_print(output, flags, level);
 80027f2: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 80027f6: 461a         	mov	r2, r3
 80027f8: 6bf9         	ldr	r1, [r7, #0x3c]
 80027fa: 68f8         	ldr	r0, [r7, #0xc]
 80027fc: f00e ff81    	bl	0x8011702 <postfix_print> @ imm = #0xef02
; 	log_output_flush(output);
 8002800: 68f8         	ldr	r0, [r7, #0xc]
 8002802: f00e fef2    	bl	0x80115ea <log_output_flush> @ imm = #0xede4
; }
 8002806: bf00         	nop
 8002808: 3720         	adds	r7, #0x20
 800280a: 46bd         	mov	sp, r7
 800280c: bd80         	pop	{r7, pc}
 800280e: bf00         	nop

08002810 <$d>:
 8002810: 1d 16 01 08  	.word	0x0801161d
 8002814: 4d 16 01 08  	.word	0x0801164d

08002818 <log_output_timestamp_freq_set>:
; {
 8002818: b480         	push	{r7}
 800281a: b083         	sub	sp, #0xc
 800281c: af00         	add	r7, sp, #0x0
 800281e: 6078         	str	r0, [r7, #0x4]
; 	timestamp_div = 1U;
 8002820: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002850 <log_output_timestamp_freq_set+0x38>
 8002822: 2201         	movs	r2, #0x1
 8002824: 601a         	str	r2, [r3]
; 	while (frequency > 1000000) {
 8002826: e007         	b	0x8002838 <log_output_timestamp_freq_set+0x20> @ imm = #0xe
; 		frequency /= 2U;
 8002828: 687b         	ldr	r3, [r7, #0x4]
 800282a: 085b         	lsrs	r3, r3, #0x1
 800282c: 607b         	str	r3, [r7, #0x4]
; 		timestamp_div *= 2U;
 800282e: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8002850 <log_output_timestamp_freq_set+0x38>
 8002830: 681b         	ldr	r3, [r3]
 8002832: 005b         	lsls	r3, r3, #0x1
 8002834: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8002850 <log_output_timestamp_freq_set+0x38>
 8002836: 6013         	str	r3, [r2]
; 	while (frequency > 1000000) {
 8002838: 687b         	ldr	r3, [r7, #0x4]
 800283a: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8002854 <log_output_timestamp_freq_set+0x3c>
 800283c: 4293         	cmp	r3, r2
 800283e: d8f3         	bhi	0x8002828 <log_output_timestamp_freq_set+0x10> @ imm = #-0x1a
; 	freq = frequency;
 8002840: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8002858 <log_output_timestamp_freq_set+0x40>
 8002842: 687b         	ldr	r3, [r7, #0x4]
 8002844: 6013         	str	r3, [r2]
; }
 8002846: bf00         	nop
 8002848: 370c         	adds	r7, #0xc
 800284a: 46bd         	mov	sp, r7
 800284c: bc80         	pop	{r7}
 800284e: 4770         	bx	lr

08002850 <$d>:
 8002850: c0 0a 00 20  	.word	0x20000ac0
 8002854: 40 42 0f 00  	.word	0x000f4240
 8002858: bc 0a 00 20  	.word	0x20000abc

0800285c <char_out>:
; {
 800285c: b580         	push	{r7, lr}
 800285e: b088         	sub	sp, #0x20
 8002860: af00         	add	r7, sp, #0x0
 8002862: 60f8         	str	r0, [r7, #0xc]
 8002864: 60b9         	str	r1, [r7, #0x8]
 8002866: 607a         	str	r2, [r7, #0x4]
; 	const struct lbu_cb_ctx *cb_ctx = ctx;
 8002868: 687b         	ldr	r3, [r7, #0x4]
 800286a: 61bb         	str	r3, [r7, #0x18]
; 	struct lbu_data *lb_data = cb_ctx->data;
 800286c: 69bb         	ldr	r3, [r7, #0x18]
 800286e: 685b         	ldr	r3, [r3, #0x4]
 8002870: 617b         	str	r3, [r7, #0x14]
; 	const struct device *uart_dev = LBU_UART_DEV(cb_ctx);
 8002872: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80028c8 <char_out+0x6c>
 8002874: 613b         	str	r3, [r7, #0x10]
; 	if (pm_device_runtime_get(uart_dev) < 0) {
 8002876: 6938         	ldr	r0, [r7, #0x10]
 8002878: f00f f83b    	bl	0x80118f2 <pm_device_runtime_get> @ imm = #0xf076
 800287c: 4603         	mov	r3, r0
 800287e: 2b00         	cmp	r3, #0x0
 8002880: da01         	bge	0x8002886 <char_out+0x2a> @ imm = #0x2
; 		return length;
 8002882: 68b9         	ldr	r1, [r7, #0x8]
 8002884: e01a         	b	0x80028bc <char_out+0x60> @ imm = #0x34
; 		for (size_t i = 0; i < length; i++) {
 8002886: 2300         	movs	r3, #0x0
 8002888: 61fb         	str	r3, [r7, #0x1c]
 800288a: e00a         	b	0x80028a2 <char_out+0x46> @ imm = #0x14
; 			uart_poll_out(uart_dev, data[i]);
 800288c: 68fa         	ldr	r2, [r7, #0xc]
 800288e: 69fb         	ldr	r3, [r7, #0x1c]
 8002890: 4413         	add	r3, r2
 8002892: 781b         	ldrb	r3, [r3]
 8002894: 4619         	mov	r1, r3
 8002896: 6938         	ldr	r0, [r7, #0x10]
 8002898: f00f f81c    	bl	0x80118d4 <uart_poll_out> @ imm = #0xf038
; 		for (size_t i = 0; i < length; i++) {
 800289c: 69fb         	ldr	r3, [r7, #0x1c]
 800289e: 3301         	adds	r3, #0x1
 80028a0: 61fb         	str	r3, [r7, #0x1c]
 80028a2: 69fa         	ldr	r2, [r7, #0x1c]
 80028a4: 68bb         	ldr	r3, [r7, #0x8]
 80028a6: 429a         	cmp	r2, r3
 80028a8: d3f0         	blo	0x800288c <char_out+0x30> @ imm = #-0x20
; 		goto cleanup;
 80028aa: bf00         	nop
; 	(void)pm_device_runtime_put_async(uart_dev, K_MSEC(1));
 80028ac: f04f 020a    	mov.w	r2, #0xa
 80028b0: f04f 0300    	mov.w	r3, #0x0
 80028b4: 6938         	ldr	r0, [r7, #0x10]
 80028b6: f00f f826    	bl	0x8011906 <pm_device_runtime_put_async> @ imm = #0xf04c
; 	return length;
 80028ba: 68b9         	ldr	r1, [r7, #0x8]
; }
 80028bc: 460b         	mov	r3, r1
 80028be: 4618         	mov	r0, r3
 80028c0: 3720         	adds	r7, #0x20
 80028c2: 46bd         	mov	sp, r7
 80028c4: bd80         	pop	{r7, pc}
 80028c6: bf00         	nop

080028c8 <$d>:
 80028c8: 20 93 01 08  	.word	0x08019320

080028cc <log_backend_uart_init>:
; {
 80028cc: b580         	push	{r7, lr}
 80028ce: b086         	sub	sp, #0x18
 80028d0: af00         	add	r7, sp, #0x0
 80028d2: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 80028d4: 687b         	ldr	r3, [r7, #0x4]
 80028d6: 685b         	ldr	r3, [r3, #0x4]
 80028d8: 681b         	ldr	r3, [r3]
 80028da: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 80028dc: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80028f8 <log_backend_uart_init+0x2c>
 80028de: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 80028e0: 693b         	ldr	r3, [r7, #0x10]
 80028e2: 685b         	ldr	r3, [r3, #0x4]
 80028e4: 617b         	str	r3, [r7, #0x14]
; 	log_output_ctx_set(ctx->output, (void *)ctx);
 80028e6: 693b         	ldr	r3, [r7, #0x10]
 80028e8: 681b         	ldr	r3, [r3]
 80028ea: 6939         	ldr	r1, [r7, #0x10]
 80028ec: 4618         	mov	r0, r3
 80028ee: f00e ffb2    	bl	0x8011856 <log_output_ctx_set> @ imm = #0xef64
; }
 80028f2: 3718         	adds	r7, #0x18
 80028f4: 46bd         	mov	sp, r7
 80028f6: bd80         	pop	{r7, pc}

080028f8 <$d>:
 80028f8: 20 93 01 08  	.word	0x08019320

080028fc <panic>:
; {
 80028fc: b580         	push	{r7, lr}
 80028fe: b086         	sub	sp, #0x18
 8002900: af00         	add	r7, sp, #0x0
 8002902: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8002904: 687b         	ldr	r3, [r7, #0x4]
 8002906: 685b         	ldr	r3, [r3, #0x4]
 8002908: 681b         	ldr	r3, [r3]
 800290a: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 800290c: 697b         	ldr	r3, [r7, #0x14]
 800290e: 685b         	ldr	r3, [r3, #0x4]
 8002910: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 8002912: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8002930 <panic+0x34>
 8002914: 60fb         	str	r3, [r7, #0xc]
; 	data->in_panic = true;
 8002916: 693b         	ldr	r3, [r7, #0x10]
 8002918: 2201         	movs	r2, #0x1
 800291a: 751a         	strb	r2, [r3, #0x14]
; 	log_backend_std_panic(ctx->output);
 800291c: 697b         	ldr	r3, [r7, #0x14]
 800291e: 681b         	ldr	r3, [r3]
 8002920: 4618         	mov	r0, r3
 8002922: f00e ffb9    	bl	0x8011898 <log_backend_std_panic> @ imm = #0xef72
; }
 8002926: bf00         	nop
 8002928: 3718         	adds	r7, #0x18
 800292a: 46bd         	mov	sp, r7
 800292c: bd80         	pop	{r7, pc}
 800292e: bf00         	nop

08002930 <$d>:
 8002930: 20 93 01 08  	.word	0x08019320

08002934 <esf_dump>:
; {
 8002934: b580         	push	{r7, lr}
 8002936: b090         	sub	sp, #0x40
 8002938: af06         	add	r7, sp, #0x18
 800293a: 6078         	str	r0, [r7, #0x4]
; 	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
 800293c: 2303         	movs	r3, #0x3
 800293e: 2b00         	cmp	r3, #0x0
 8002940: d020         	beq	0x8002984 <esf_dump+0x50> @ imm = #0x40
 8002942: 2301         	movs	r3, #0x1
 8002944: 73bb         	strb	r3, [r7, #0xe]
 8002946: 7bbb         	ldrb	r3, [r7, #0xe]
 8002948: f083 0301    	eor	r3, r3, #0x1
 800294c: b2db         	uxtb	r3, r3
 800294e: 2b00         	cmp	r3, #0x0
 8002950: d118         	bne	0x8002984 <esf_dump+0x50> @ imm = #0x30
 8002952: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8002a4c <esf_dump+0x118>
 8002954: 6818         	ldr	r0, [r3]
 8002956: 687b         	ldr	r3, [r7, #0x4]
 8002958: 681b         	ldr	r3, [r3]
 800295a: 687a         	ldr	r2, [r7, #0x4]
 800295c: 6852         	ldr	r2, [r2, #0x4]
 800295e: 6879         	ldr	r1, [r7, #0x4]
 8002960: 6889         	ldr	r1, [r1, #0x8]
 8002962: 9105         	str	r1, [sp, #0x14]
 8002964: 9204         	str	r2, [sp, #0x10]
 8002966: 9303         	str	r3, [sp, #0xc]
 8002968: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8002a50 <esf_dump+0x11c>
 800296a: 9302         	str	r3, [sp, #0x8]
 800296c: 2300         	movs	r3, #0x0
 800296e: 9301         	str	r3, [sp, #0x4]
 8002970: 2300         	movs	r3, #0x0
 8002972: 9300         	str	r3, [sp]
 8002974: 2300         	movs	r3, #0x0
 8002976: 2201         	movs	r2, #0x1
 8002978: 4601         	mov	r1, r0
 800297a: 2000         	movs	r0, #0x0
 800297c: f00f f803    	bl	0x8011986 <z_log_msg_runtime_create> @ imm = #0xf006
 8002980: 2300         	movs	r3, #0x0
 8002982: 613b         	str	r3, [r7, #0x10]
; 	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
 8002984: 2303         	movs	r3, #0x3
 8002986: 2b00         	cmp	r3, #0x0
 8002988: d020         	beq	0x80029cc <esf_dump+0x98> @ imm = #0x40
 800298a: 2301         	movs	r3, #0x1
 800298c: 73fb         	strb	r3, [r7, #0xf]
 800298e: 7bfb         	ldrb	r3, [r7, #0xf]
 8002990: f083 0301    	eor	r3, r3, #0x1
 8002994: b2db         	uxtb	r3, r3
 8002996: 2b00         	cmp	r3, #0x0
 8002998: d118         	bne	0x80029cc <esf_dump+0x98> @ imm = #0x30
 800299a: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8002a4c <esf_dump+0x118>
 800299c: 6818         	ldr	r0, [r3]
 800299e: 687b         	ldr	r3, [r7, #0x4]
 80029a0: 68db         	ldr	r3, [r3, #0xc]
 80029a2: 687a         	ldr	r2, [r7, #0x4]
 80029a4: 6912         	ldr	r2, [r2, #0x10]
 80029a6: 6879         	ldr	r1, [r7, #0x4]
 80029a8: 6949         	ldr	r1, [r1, #0x14]
 80029aa: 9105         	str	r1, [sp, #0x14]
 80029ac: 9204         	str	r2, [sp, #0x10]
 80029ae: 9303         	str	r3, [sp, #0xc]
 80029b0: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8002a54 <esf_dump+0x120>
 80029b2: 9302         	str	r3, [sp, #0x8]
 80029b4: 2300         	movs	r3, #0x0
 80029b6: 9301         	str	r3, [sp, #0x4]
 80029b8: 2300         	movs	r3, #0x0
 80029ba: 9300         	str	r3, [sp]
 80029bc: 2300         	movs	r3, #0x0
 80029be: 2201         	movs	r2, #0x1
 80029c0: 4601         	mov	r1, r0
 80029c2: 2000         	movs	r0, #0x0
 80029c4: f00e ffdf    	bl	0x8011986 <z_log_msg_runtime_create> @ imm = #0xefbe
 80029c8: 2300         	movs	r3, #0x0
 80029ca: 623b         	str	r3, [r7, #0x20]
; 	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
 80029cc: 2303         	movs	r3, #0x3
 80029ce: 2b00         	cmp	r3, #0x0
 80029d0: d019         	beq	0x8002a06 <esf_dump+0xd2> @ imm = #0x32
 80029d2: 2301         	movs	r3, #0x1
 80029d4: 77fb         	strb	r3, [r7, #0x1f]
 80029d6: 7ffb         	ldrb	r3, [r7, #0x1f]
 80029d8: f083 0301    	eor	r3, r3, #0x1
 80029dc: b2db         	uxtb	r3, r3
 80029de: 2b00         	cmp	r3, #0x0
 80029e0: d111         	bne	0x8002a06 <esf_dump+0xd2> @ imm = #0x22
 80029e2: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8002a4c <esf_dump+0x118>
 80029e4: 6819         	ldr	r1, [r3]
 80029e6: 687b         	ldr	r3, [r7, #0x4]
 80029e8: 69db         	ldr	r3, [r3, #0x1c]
 80029ea: 9303         	str	r3, [sp, #0xc]
 80029ec: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8002a58 <esf_dump+0x124>
 80029ee: 9302         	str	r3, [sp, #0x8]
 80029f0: 2300         	movs	r3, #0x0
 80029f2: 9301         	str	r3, [sp, #0x4]
 80029f4: 2300         	movs	r3, #0x0
 80029f6: 9300         	str	r3, [sp]
 80029f8: 2300         	movs	r3, #0x0
 80029fa: 2201         	movs	r2, #0x1
 80029fc: 2000         	movs	r0, #0x0
 80029fe: f00e ffc2    	bl	0x8011986 <z_log_msg_runtime_create> @ imm = #0xef84
 8002a02: 2300         	movs	r3, #0x0
 8002a04: 61bb         	str	r3, [r7, #0x18]
; 	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
 8002a06: 2303         	movs	r3, #0x3
 8002a08: 2b00         	cmp	r3, #0x0
 8002a0a: d01a         	beq	0x8002a42 <esf_dump+0x10e> @ imm = #0x34
 8002a0c: 2301         	movs	r3, #0x1
 8002a0e: 75fb         	strb	r3, [r7, #0x17]
 8002a10: 7dfb         	ldrb	r3, [r7, #0x17]
 8002a12: f083 0301    	eor	r3, r3, #0x1
 8002a16: b2db         	uxtb	r3, r3
 8002a18: 2b00         	cmp	r3, #0x0
 8002a1a: d112         	bne	0x8002a42 <esf_dump+0x10e> @ imm = #0x24
 8002a1c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002a4c <esf_dump+0x118>
 8002a1e: 6819         	ldr	r1, [r3]
 8002a20: 687b         	ldr	r3, [r7, #0x4]
 8002a22: 699b         	ldr	r3, [r3, #0x18]
 8002a24: 9303         	str	r3, [sp, #0xc]
 8002a26: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8002a5c <esf_dump+0x128>
 8002a28: 9302         	str	r3, [sp, #0x8]
 8002a2a: 2300         	movs	r3, #0x0
 8002a2c: 9301         	str	r3, [sp, #0x4]
 8002a2e: 2300         	movs	r3, #0x0
 8002a30: 9300         	str	r3, [sp]
 8002a32: 2300         	movs	r3, #0x0
 8002a34: 2201         	movs	r2, #0x1
 8002a36: 2000         	movs	r0, #0x0
 8002a38: f00e ffa5    	bl	0x8011986 <z_log_msg_runtime_create> @ imm = #0xef4a
 8002a3c: 2300         	movs	r3, #0x0
 8002a3e: 627b         	str	r3, [r7, #0x24]
; }
 8002a40: bf00         	nop
 8002a42: bf00         	nop
 8002a44: 3728         	adds	r7, #0x28
 8002a46: 46bd         	mov	sp, r7
 8002a48: bd80         	pop	{r7, pc}
 8002a4a: bf00         	nop

08002a4c <$d>:
 8002a4c: d8 02 00 20  	.word	0x200002d8
 8002a50: a4 9b 01 08  	.word	0x08019ba4
 8002a54: d4 9b 01 08  	.word	0x08019bd4
 8002a58: 04 9c 01 08  	.word	0x08019c04
 8002a5c: 14 9c 01 08  	.word	0x08019c14

08002a60 <z_arm_fatal_error>:
; {
 8002a60: b580         	push	{r7, lr}
 8002a62: b08a         	sub	sp, #0x28
 8002a64: af04         	add	r7, sp, #0x10
 8002a66: 6078         	str	r0, [r7, #0x4]
 8002a68: 6039         	str	r1, [r7]
; 	if (esf != NULL) {
 8002a6a: 683b         	ldr	r3, [r7]
 8002a6c: 2b00         	cmp	r3, #0x0
 8002a6e: d002         	beq	0x8002a76 <z_arm_fatal_error+0x16> @ imm = #0x4
; 		esf_dump(esf);
 8002a70: 6838         	ldr	r0, [r7]
 8002a72: f7ff ff5f    	bl	0x8002934 <esf_dump>    @ imm = #-0x142
; 	if (reason == K_ERR_SPURIOUS_IRQ) {
 8002a76: 687b         	ldr	r3, [r7, #0x4]
 8002a78: 2b01         	cmp	r3, #0x1
 8002a7a: d121         	bne	0x8002ac0 <z_arm_fatal_error+0x60> @ imm = #0x42
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8002a7c: f3ef 8305    	mrs	r3, ipsr
 8002a80: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 8002a82: 68bb         	ldr	r3, [r7, #0x8]
; 		uint32_t irqn = __get_IPSR() - 16;
 8002a84: 3b10         	subs	r3, #0x10
 8002a86: 617b         	str	r3, [r7, #0x14]
; 		LOG_ERR("Unhandled IRQn: %d", irqn);
 8002a88: 2303         	movs	r3, #0x3
 8002a8a: 2b00         	cmp	r3, #0x0
 8002a8c: d018         	beq	0x8002ac0 <z_arm_fatal_error+0x60> @ imm = #0x30
 8002a8e: 2301         	movs	r3, #0x1
 8002a90: 74fb         	strb	r3, [r7, #0x13]
 8002a92: 7cfb         	ldrb	r3, [r7, #0x13]
 8002a94: f083 0301    	eor	r3, r3, #0x1
 8002a98: b2db         	uxtb	r3, r3
 8002a9a: 2b00         	cmp	r3, #0x0
 8002a9c: d110         	bne	0x8002ac0 <z_arm_fatal_error+0x60> @ imm = #0x20
 8002a9e: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8002ad0 <z_arm_fatal_error+0x70>
 8002aa0: 6819         	ldr	r1, [r3]
 8002aa2: 697b         	ldr	r3, [r7, #0x14]
 8002aa4: 9303         	str	r3, [sp, #0xc]
 8002aa6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002ad4 <z_arm_fatal_error+0x74>
 8002aa8: 9302         	str	r3, [sp, #0x8]
 8002aaa: 2300         	movs	r3, #0x0
 8002aac: 9301         	str	r3, [sp, #0x4]
 8002aae: 2300         	movs	r3, #0x0
 8002ab0: 9300         	str	r3, [sp]
 8002ab2: 2300         	movs	r3, #0x0
 8002ab4: 2201         	movs	r2, #0x1
 8002ab6: 2000         	movs	r0, #0x0
 8002ab8: f00e ff65    	bl	0x8011986 <z_log_msg_runtime_create> @ imm = #0xeeca
 8002abc: 2300         	movs	r3, #0x0
 8002abe: 60fb         	str	r3, [r7, #0xc]
; 	z_fatal_error(reason, esf);
 8002ac0: 6839         	ldr	r1, [r7]
 8002ac2: 6878         	ldr	r0, [r7, #0x4]
 8002ac4: f008 fcee    	bl	0x800b4a4 <z_fatal_error> @ imm = #0x89dc
; }
 8002ac8: bf00         	nop
 8002aca: 3718         	adds	r7, #0x18
 8002acc: 46bd         	mov	sp, r7
 8002ace: bd80         	pop	{r7, pc}

08002ad0 <$d>:
 8002ad0: d8 02 00 20  	.word	0x200002d8
 8002ad4: 44 9c 01 08  	.word	0x08019c44

08002ad8 <z_arm_nmi>:
; {
 8002ad8: b580         	push	{r7, lr}
 8002ada: af00         	add	r7, sp, #0x0
; 	handler();
 8002adc: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8002aec <z_arm_nmi+0x14>
 8002ade: 681b         	ldr	r3, [r3]
 8002ae0: 4798         	blx	r3
; 	z_arm_int_exit();
 8002ae2: f000 f835    	bl	0x8002b50 <z_arm_int_exit> @ imm = #0x6a
; }
 8002ae6: bf00         	nop
 8002ae8: bd80         	pop	{r7, pc}
 8002aea: bf00         	nop

08002aec <$d>:
 8002aec: dc 02 00 20  	.word	0x200002dc

08002af0 <z_SysNmiOnReset>:
;     wfi
 8002af0: bf30         	wfi
;     b z_SysNmiOnReset
 8002af2: f7ff bffd    	b.w	0x8002af0 <z_SysNmiOnReset> @ imm = #-0x6
 8002af6: bf00         	nop

08002af8 <z_tls_data_size>:
; {
 8002af8: b480         	push	{r7}
 8002afa: af00         	add	r7, sp, #0x0
; 	return (size_t)(uintptr_t)__tdata_size +
 8002afc: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8002b0c <z_tls_data_size+0x14>
; 	       (size_t)(uintptr_t)__tbss_size;
 8002afe: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8002b10 <z_tls_data_size+0x18>
; 	return (size_t)(uintptr_t)__tdata_size +
 8002b00: 4413         	add	r3, r2
; }
 8002b02: 4618         	mov	r0, r3
 8002b04: 46bd         	mov	sp, r7
 8002b06: bc80         	pop	{r7}
 8002b08: 4770         	bx	lr
 8002b0a: bf00         	nop

08002b0c <$d>:
 8002b0c: 00 00 00 00  	.word	0x00000000
 8002b10: 04 00 00 00  	.word	0x00000004

08002b14 <z_tls_copy>:
; {
 8002b14: b580         	push	{r7, lr}
 8002b16: b082         	sub	sp, #0x8
 8002b18: af00         	add	r7, sp, #0x0
 8002b1a: 6078         	str	r0, [r7, #0x4]
; 	memcpy(dest, __tdata_start, (size_t)(uintptr_t)__tdata_size);
 8002b1c: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8002b44 <z_tls_copy+0x30>
 8002b1e: 461a         	mov	r2, r3
 8002b20: 4909         	ldr	r1, [pc, #0x24]         @ 0x8002b48 <z_tls_copy+0x34>
 8002b22: 6878         	ldr	r0, [r7, #0x4]
 8002b24: f016 f901    	bl	0x8018d2a <memcpy>      @ imm = #0x16202
; 	dest += (size_t)(uintptr_t)__tdata_size;
 8002b28: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8002b44 <z_tls_copy+0x30>
 8002b2a: 687b         	ldr	r3, [r7, #0x4]
 8002b2c: 4413         	add	r3, r2
 8002b2e: 607b         	str	r3, [r7, #0x4]
; 	memset(dest, 0, (size_t)(uintptr_t)__tbss_size);
 8002b30: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8002b4c <z_tls_copy+0x38>
 8002b32: 461a         	mov	r2, r3
 8002b34: 2100         	movs	r1, #0x0
 8002b36: 6878         	ldr	r0, [r7, #0x4]
 8002b38: f016 f905    	bl	0x8018d46 <memset>      @ imm = #0x1620a
; }
 8002b3c: bf00         	nop
 8002b3e: 3708         	adds	r7, #0x8
 8002b40: 46bd         	mov	sp, r7
 8002b42: bd80         	pop	{r7, pc}

08002b44 <$d>:
 8002b44: 00 00 00 00  	.word	0x00000000
 8002b48: 88 97 01 08  	.word	0x08019788
 8002b4c: 04 00 00 00  	.word	0x00000004

08002b50 <z_arm_int_exit>:
; {
 8002b50: b480         	push	{r7}
 8002b52: af00         	add	r7, sp, #0x0
; 	if (_kernel.cpus->current->base.prio >= 0) {
 8002b54: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8002b80 <z_arm_int_exit+0x30>
 8002b56: 689b         	ldr	r3, [r3, #0x8]
 8002b58: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8002b5c: 2b00         	cmp	r3, #0x0
 8002b5e: db0b         	blt	0x8002b78 <z_arm_int_exit+0x28> @ imm = #0x16
; 		if (_kernel.ready_q.cache != _kernel.cpus->current) {
 8002b60: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8002b80 <z_arm_int_exit+0x30>
 8002b62: 69da         	ldr	r2, [r3, #0x1c]
 8002b64: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8002b80 <z_arm_int_exit+0x30>
 8002b66: 689b         	ldr	r3, [r3, #0x8]
 8002b68: 429a         	cmp	r2, r3
 8002b6a: d005         	beq	0x8002b78 <z_arm_int_exit+0x28> @ imm = #0xa
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8002b6c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8002b84 <z_arm_int_exit+0x34>
 8002b6e: 685b         	ldr	r3, [r3, #0x4]
 8002b70: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8002b84 <z_arm_int_exit+0x34>
 8002b72: f043 5380    	orr	r3, r3, #0x10000000
 8002b76: 6053         	str	r3, [r2, #0x4]
; }
 8002b78: bf00         	nop
 8002b7a: 46bd         	mov	sp, r7
 8002b7c: bc80         	pop	{r7}
 8002b7e: 4770         	bx	lr

08002b80 <$d>:
 8002b80: c8 06 00 20  	.word	0x200006c8
 8002b84: 00 ed 00 e0  	.word	0xe000ed00

08002b88 <mem_manage_fault>:
; {
 8002b88: b580         	push	{r7, lr}
 8002b8a: b09a         	sub	sp, #0x68
 8002b8c: af04         	add	r7, sp, #0x10
 8002b8e: 60f8         	str	r0, [r7, #0xc]
 8002b90: 60b9         	str	r1, [r7, #0x8]
 8002b92: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
 8002b94: 2310         	movs	r3, #0x10
 8002b96: 657b         	str	r3, [r7, #0x54]
; 	uint32_t mmfar = -EINVAL;
 8002b98: f06f 0315    	mvn	r3, #0x15
 8002b9c: 653b         	str	r3, [r7, #0x50]
; 	PR_FAULT_INFO("***** MPU FAULT *****");
 8002b9e: 2303         	movs	r3, #0x3
 8002ba0: 2b00         	cmp	r3, #0x0
 8002ba2: d018         	beq	0x8002bd6 <mem_manage_fault+0x4e> @ imm = #0x30
 8002ba4: 2301         	movs	r3, #0x1
 8002ba6: f887 304f    	strb.w	r3, [r7, #0x4f]
 8002baa: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 8002bae: f083 0301    	eor	r3, r3, #0x1
 8002bb2: b2db         	uxtb	r3, r3
 8002bb4: 2b00         	cmp	r3, #0x0
 8002bb6: d10e         	bne	0x8002bd6 <mem_manage_fault+0x4e> @ imm = #0x1c
 8002bb8: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x8002dec <mem_manage_fault+0x264>
 8002bba: 6819         	ldr	r1, [r3]
 8002bbc: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x8002df0 <mem_manage_fault+0x268>
 8002bbe: 9302         	str	r3, [sp, #0x8]
 8002bc0: 2300         	movs	r3, #0x0
 8002bc2: 9301         	str	r3, [sp, #0x4]
 8002bc4: 2300         	movs	r3, #0x0
 8002bc6: 9300         	str	r3, [sp]
 8002bc8: 2300         	movs	r3, #0x0
 8002bca: 2201         	movs	r2, #0x1
 8002bcc: 2000         	movs	r0, #0x0
 8002bce: f00e ff2c    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xee58
 8002bd2: 2300         	movs	r3, #0x0
 8002bd4: 64bb         	str	r3, [r7, #0x48]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 8002bd6: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8002df4 <mem_manage_fault+0x26c>
 8002bd8: 6a9b         	ldr	r3, [r3, #0x28]
 8002bda: f003 0310    	and	r3, r3, #0x10
 8002bde: 2b00         	cmp	r3, #0x0
 8002be0: d01d         	beq	0x8002c1e <mem_manage_fault+0x96> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_STACKING;
 8002be2: 2311         	movs	r3, #0x11
 8002be4: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error (context area might be"
 8002be6: 2303         	movs	r3, #0x3
 8002be8: 2b00         	cmp	r3, #0x0
 8002bea: d018         	beq	0x8002c1e <mem_manage_fault+0x96> @ imm = #0x30
 8002bec: 2301         	movs	r3, #0x1
 8002bee: f887 3047    	strb.w	r3, [r7, #0x47]
 8002bf2: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8002bf6: f083 0301    	eor	r3, r3, #0x1
 8002bfa: b2db         	uxtb	r3, r3
 8002bfc: 2b00         	cmp	r3, #0x0
 8002bfe: d10e         	bne	0x8002c1e <mem_manage_fault+0x96> @ imm = #0x1c
 8002c00: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x8002dec <mem_manage_fault+0x264>
 8002c02: 6819         	ldr	r1, [r3]
 8002c04: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x8002df8 <mem_manage_fault+0x270>
 8002c06: 9302         	str	r3, [sp, #0x8]
 8002c08: 2300         	movs	r3, #0x0
 8002c0a: 9301         	str	r3, [sp, #0x4]
 8002c0c: 2300         	movs	r3, #0x0
 8002c0e: 9300         	str	r3, [sp]
 8002c10: 2300         	movs	r3, #0x0
 8002c12: 2201         	movs	r2, #0x1
 8002c14: 2000         	movs	r0, #0x0
 8002c16: f00e ff08    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xee10
 8002c1a: 2300         	movs	r3, #0x0
 8002c1c: 643b         	str	r3, [r7, #0x40]
; 	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 8002c1e: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8002df4 <mem_manage_fault+0x26c>
 8002c20: 6a9b         	ldr	r3, [r3, #0x28]
 8002c22: f003 0308    	and	r3, r3, #0x8
 8002c26: 2b00         	cmp	r3, #0x0
 8002c28: d01d         	beq	0x8002c66 <mem_manage_fault+0xde> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_UNSTACKING;
 8002c2a: 2312         	movs	r3, #0x12
 8002c2c: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 8002c2e: 2303         	movs	r3, #0x3
 8002c30: 2b00         	cmp	r3, #0x0
 8002c32: d018         	beq	0x8002c66 <mem_manage_fault+0xde> @ imm = #0x30
 8002c34: 2301         	movs	r3, #0x1
 8002c36: f887 303f    	strb.w	r3, [r7, #0x3f]
 8002c3a: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8002c3e: f083 0301    	eor	r3, r3, #0x1
 8002c42: b2db         	uxtb	r3, r3
 8002c44: 2b00         	cmp	r3, #0x0
 8002c46: d10e         	bne	0x8002c66 <mem_manage_fault+0xde> @ imm = #0x1c
 8002c48: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8002dec <mem_manage_fault+0x264>
 8002c4a: 6819         	ldr	r1, [r3]
 8002c4c: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x8002dfc <mem_manage_fault+0x274>
 8002c4e: 9302         	str	r3, [sp, #0x8]
 8002c50: 2300         	movs	r3, #0x0
 8002c52: 9301         	str	r3, [sp, #0x4]
 8002c54: 2300         	movs	r3, #0x0
 8002c56: 9300         	str	r3, [sp]
 8002c58: 2300         	movs	r3, #0x0
 8002c5a: 2201         	movs	r2, #0x1
 8002c5c: 2000         	movs	r0, #0x0
 8002c5e: f00e fee4    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xedc8
 8002c62: 2300         	movs	r3, #0x0
 8002c64: 63bb         	str	r3, [r7, #0x38]
; 	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 8002c66: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8002df4 <mem_manage_fault+0x26c>
 8002c68: 6a9b         	ldr	r3, [r3, #0x28]
 8002c6a: f003 0302    	and	r3, r3, #0x2
 8002c6e: 2b00         	cmp	r3, #0x0
 8002c70: d04f         	beq	0x8002d12 <mem_manage_fault+0x18a> @ imm = #0x9e
; 		reason = K_ERR_ARM_MEM_DATA_ACCESS;
 8002c72: 2313         	movs	r3, #0x13
 8002c74: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Data Access Violation");
 8002c76: 2303         	movs	r3, #0x3
 8002c78: 2b00         	cmp	r3, #0x0
 8002c7a: d018         	beq	0x8002cae <mem_manage_fault+0x126> @ imm = #0x30
 8002c7c: 2301         	movs	r3, #0x1
 8002c7e: f887 3037    	strb.w	r3, [r7, #0x37]
 8002c82: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8002c86: f083 0301    	eor	r3, r3, #0x1
 8002c8a: b2db         	uxtb	r3, r3
 8002c8c: 2b00         	cmp	r3, #0x0
 8002c8e: d10e         	bne	0x8002cae <mem_manage_fault+0x126> @ imm = #0x1c
 8002c90: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8002dec <mem_manage_fault+0x264>
 8002c92: 6819         	ldr	r1, [r3]
 8002c94: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x8002e00 <mem_manage_fault+0x278>
 8002c96: 9302         	str	r3, [sp, #0x8]
 8002c98: 2300         	movs	r3, #0x0
 8002c9a: 9301         	str	r3, [sp, #0x4]
 8002c9c: 2300         	movs	r3, #0x0
 8002c9e: 9300         	str	r3, [sp]
 8002ca0: 2300         	movs	r3, #0x0
 8002ca2: 2201         	movs	r2, #0x1
 8002ca4: 2000         	movs	r0, #0x0
 8002ca6: f00e fec0    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xed80
 8002caa: 2300         	movs	r3, #0x0
 8002cac: 633b         	str	r3, [r7, #0x30]
; 		uint32_t temp = SCB->MMFAR;
 8002cae: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8002df4 <mem_manage_fault+0x26c>
 8002cb0: 6b5b         	ldr	r3, [r3, #0x34]
 8002cb2: 62fb         	str	r3, [r7, #0x2c]
; 		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 8002cb4: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8002df4 <mem_manage_fault+0x26c>
 8002cb6: 6a9b         	ldr	r3, [r3, #0x28]
 8002cb8: f003 0380    	and	r3, r3, #0x80
 8002cbc: 2b00         	cmp	r3, #0x0
 8002cbe: d028         	beq	0x8002d12 <mem_manage_fault+0x18a> @ imm = #0x50
; 			mmfar = temp;
 8002cc0: 6afb         	ldr	r3, [r7, #0x2c]
 8002cc2: 653b         	str	r3, [r7, #0x50]
; 			PR_EXC("  MMFAR Address: 0x%x", mmfar);
 8002cc4: 2303         	movs	r3, #0x3
 8002cc6: 2b00         	cmp	r3, #0x0
 8002cc8: d01a         	beq	0x8002d00 <mem_manage_fault+0x178> @ imm = #0x34
 8002cca: 2301         	movs	r3, #0x1
 8002ccc: f887 302b    	strb.w	r3, [r7, #0x2b]
 8002cd0: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8002cd4: f083 0301    	eor	r3, r3, #0x1
 8002cd8: b2db         	uxtb	r3, r3
 8002cda: 2b00         	cmp	r3, #0x0
 8002cdc: d110         	bne	0x8002d00 <mem_manage_fault+0x178> @ imm = #0x20
 8002cde: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8002dec <mem_manage_fault+0x264>
 8002ce0: 6819         	ldr	r1, [r3]
 8002ce2: 6d3b         	ldr	r3, [r7, #0x50]
 8002ce4: 9303         	str	r3, [sp, #0xc]
 8002ce6: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x8002e04 <mem_manage_fault+0x27c>
 8002ce8: 9302         	str	r3, [sp, #0x8]
 8002cea: 2300         	movs	r3, #0x0
 8002cec: 9301         	str	r3, [sp, #0x4]
 8002cee: 2300         	movs	r3, #0x0
 8002cf0: 9300         	str	r3, [sp]
 8002cf2: 2300         	movs	r3, #0x0
 8002cf4: 2201         	movs	r2, #0x1
 8002cf6: 2000         	movs	r0, #0x0
 8002cf8: f00e fe97    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xed2e
 8002cfc: 2300         	movs	r3, #0x0
 8002cfe: 627b         	str	r3, [r7, #0x24]
; 			if (from_hard_fault != 0) {
 8002d00: 68bb         	ldr	r3, [r7, #0x8]
 8002d02: 2b00         	cmp	r3, #0x0
 8002d04: d005         	beq	0x8002d12 <mem_manage_fault+0x18a> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 8002d06: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8002df4 <mem_manage_fault+0x26c>
 8002d08: 6a9b         	ldr	r3, [r3, #0x28]
 8002d0a: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x8002df4 <mem_manage_fault+0x26c>
 8002d0c: f023 0380    	bic	r3, r3, #0x80
 8002d10: 6293         	str	r3, [r2, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 8002d12: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8002df4 <mem_manage_fault+0x26c>
 8002d14: 6a9b         	ldr	r3, [r3, #0x28]
 8002d16: f003 0301    	and	r3, r3, #0x1
 8002d1a: 2b00         	cmp	r3, #0x0
 8002d1c: d01d         	beq	0x8002d5a <mem_manage_fault+0x1d2> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
 8002d1e: 2314         	movs	r3, #0x14
 8002d20: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction Access Violation");
 8002d22: 2303         	movs	r3, #0x3
 8002d24: 2b00         	cmp	r3, #0x0
 8002d26: d018         	beq	0x8002d5a <mem_manage_fault+0x1d2> @ imm = #0x30
 8002d28: 2301         	movs	r3, #0x1
 8002d2a: f887 3023    	strb.w	r3, [r7, #0x23]
 8002d2e: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8002d32: f083 0301    	eor	r3, r3, #0x1
 8002d36: b2db         	uxtb	r3, r3
 8002d38: 2b00         	cmp	r3, #0x0
 8002d3a: d10e         	bne	0x8002d5a <mem_manage_fault+0x1d2> @ imm = #0x1c
 8002d3c: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8002dec <mem_manage_fault+0x264>
 8002d3e: 6819         	ldr	r1, [r3]
 8002d40: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8002e08 <mem_manage_fault+0x280>
 8002d42: 9302         	str	r3, [sp, #0x8]
 8002d44: 2300         	movs	r3, #0x0
 8002d46: 9301         	str	r3, [sp, #0x4]
 8002d48: 2300         	movs	r3, #0x0
 8002d4a: 9300         	str	r3, [sp]
 8002d4c: 2300         	movs	r3, #0x0
 8002d4e: 2201         	movs	r2, #0x1
 8002d50: 2000         	movs	r0, #0x0
 8002d52: f00e fe6a    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xecd4
 8002d56: 2300         	movs	r3, #0x0
 8002d58: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 8002d5a: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8002df4 <mem_manage_fault+0x26c>
 8002d5c: 6a9b         	ldr	r3, [r3, #0x28]
 8002d5e: f003 0320    	and	r3, r3, #0x20
 8002d62: 2b00         	cmp	r3, #0x0
 8002d64: d01b         	beq	0x8002d9e <mem_manage_fault+0x216> @ imm = #0x36
; 		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
 8002d66: 2315         	movs	r3, #0x15
 8002d68: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO(
 8002d6a: 2303         	movs	r3, #0x3
 8002d6c: 2b00         	cmp	r3, #0x0
 8002d6e: d016         	beq	0x8002d9e <mem_manage_fault+0x216> @ imm = #0x2c
 8002d70: 2301         	movs	r3, #0x1
 8002d72: 76fb         	strb	r3, [r7, #0x1b]
 8002d74: 7efb         	ldrb	r3, [r7, #0x1b]
 8002d76: f083 0301    	eor	r3, r3, #0x1
 8002d7a: b2db         	uxtb	r3, r3
 8002d7c: 2b00         	cmp	r3, #0x0
 8002d7e: d10e         	bne	0x8002d9e <mem_manage_fault+0x216> @ imm = #0x1c
 8002d80: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8002dec <mem_manage_fault+0x264>
 8002d82: 6819         	ldr	r1, [r3]
 8002d84: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8002e0c <mem_manage_fault+0x284>
 8002d86: 9302         	str	r3, [sp, #0x8]
 8002d88: 2300         	movs	r3, #0x0
 8002d8a: 9301         	str	r3, [sp, #0x4]
 8002d8c: 2300         	movs	r3, #0x0
 8002d8e: 9300         	str	r3, [sp]
 8002d90: 2300         	movs	r3, #0x0
 8002d92: 2201         	movs	r2, #0x1
 8002d94: 2000         	movs	r0, #0x0
 8002d96: f00e fe48    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xec90
 8002d9a: 2300         	movs	r3, #0x0
 8002d9c: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 8002d9e: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8002df4 <mem_manage_fault+0x26c>
 8002da0: 6a9b         	ldr	r3, [r3, #0x28]
 8002da2: f003 0310    	and	r3, r3, #0x10
 8002da6: 2b00         	cmp	r3, #0x0
 8002da8: d101         	bne	0x8002dae <mem_manage_fault+0x226> @ imm = #0x2
; 		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
 8002daa: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8002df4 <mem_manage_fault+0x26c>
 8002dac: 6a9b         	ldr	r3, [r3, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 8002dae: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8002df4 <mem_manage_fault+0x26c>
 8002db0: 6a9b         	ldr	r3, [r3, #0x28]
 8002db2: f003 0320    	and	r3, r3, #0x20
 8002db6: 2b00         	cmp	r3, #0x0
 8002db8: d005         	beq	0x8002dc6 <mem_manage_fault+0x23e> @ imm = #0xa
; 		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
 8002dba: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8002df4 <mem_manage_fault+0x26c>
 8002dbc: 6a5b         	ldr	r3, [r3, #0x24]
 8002dbe: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8002df4 <mem_manage_fault+0x26c>
 8002dc0: f423 5300    	bic	r3, r3, #0x2000
 8002dc4: 6253         	str	r3, [r2, #0x24]
; 	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 8002dc6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002df4 <mem_manage_fault+0x26c>
 8002dc8: 6a9b         	ldr	r3, [r3, #0x28]
 8002dca: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8002df4 <mem_manage_fault+0x26c>
 8002dcc: f043 03ff    	orr	r3, r3, #0xff
 8002dd0: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 8002dd2: 2101         	movs	r1, #0x1
 8002dd4: 68f8         	ldr	r0, [r7, #0xc]
 8002dd6: f00e fe50    	bl	0x8011a7a <memory_fault_recoverable> @ imm = #0xeca0
 8002dda: 4603         	mov	r3, r0
 8002ddc: 461a         	mov	r2, r3
 8002dde: 687b         	ldr	r3, [r7, #0x4]
 8002de0: 701a         	strb	r2, [r3]
; 	return reason;
 8002de2: 6d7b         	ldr	r3, [r7, #0x54]
; }
 8002de4: 4618         	mov	r0, r3
 8002de6: 3758         	adds	r7, #0x58
 8002de8: 46bd         	mov	sp, r7
 8002dea: bd80         	pop	{r7, pc}

08002dec <$d>:
 8002dec: e0 02 00 20  	.word	0x200002e0
 8002df0: 58 9c 01 08  	.word	0x08019c58
 8002df4: 00 ed 00 e0  	.word	0xe000ed00
 8002df8: 70 9c 01 08  	.word	0x08019c70
 8002dfc: a4 9c 01 08  	.word	0x08019ca4
 8002e00: b8 9c 01 08  	.word	0x08019cb8
 8002e04: d0 9c 01 08  	.word	0x08019cd0
 8002e08: e8 9c 01 08  	.word	0x08019ce8
 8002e0c: 08 9d 01 08  	.word	0x08019d08

08002e10 <bus_fault>:
; {
 8002e10: b580         	push	{r7, lr}
 8002e12: b09a         	sub	sp, #0x68
 8002e14: af04         	add	r7, sp, #0x10
 8002e16: 60f8         	str	r0, [r7, #0xc]
 8002e18: 60b9         	str	r1, [r7, #0x8]
 8002e1a: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
 8002e1c: 2316         	movs	r3, #0x16
 8002e1e: 657b         	str	r3, [r7, #0x54]
; 	PR_FAULT_INFO("***** BUS FAULT *****");
 8002e20: 2303         	movs	r3, #0x3
 8002e22: 2b00         	cmp	r3, #0x0
 8002e24: d018         	beq	0x8002e58 <bus_fault+0x48> @ imm = #0x30
 8002e26: 2301         	movs	r3, #0x1
 8002e28: f887 3053    	strb.w	r3, [r7, #0x53]
 8002e2c: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8002e30: f083 0301    	eor	r3, r3, #0x1
 8002e34: b2db         	uxtb	r3, r3
 8002e36: 2b00         	cmp	r3, #0x0
 8002e38: d10e         	bne	0x8002e58 <bus_fault+0x48> @ imm = #0x1c
 8002e3a: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8003088 <bus_fault+0x278>
 8002e3c: 6819         	ldr	r1, [r3]
 8002e3e: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x800308c <bus_fault+0x27c>
 8002e40: 9302         	str	r3, [sp, #0x8]
 8002e42: 2300         	movs	r3, #0x0
 8002e44: 9301         	str	r3, [sp, #0x4]
 8002e46: 2300         	movs	r3, #0x0
 8002e48: 9300         	str	r3, [sp]
 8002e4a: 2300         	movs	r3, #0x0
 8002e4c: 2201         	movs	r2, #0x1
 8002e4e: 2000         	movs	r0, #0x0
 8002e50: f00e fdeb    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xebd6
 8002e54: 2300         	movs	r3, #0x0
 8002e56: 64fb         	str	r3, [r7, #0x4c]
; 	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 8002e58: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8003090 <bus_fault+0x280>
 8002e5a: 6a9b         	ldr	r3, [r3, #0x28]
 8002e5c: f403 5380    	and	r3, r3, #0x1000
 8002e60: 2b00         	cmp	r3, #0x0
 8002e62: d01d         	beq	0x8002ea0 <bus_fault+0x90> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_STACKING;
 8002e64: 2317         	movs	r3, #0x17
 8002e66: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error");
 8002e68: 2303         	movs	r3, #0x3
 8002e6a: 2b00         	cmp	r3, #0x0
 8002e6c: d018         	beq	0x8002ea0 <bus_fault+0x90> @ imm = #0x30
 8002e6e: 2301         	movs	r3, #0x1
 8002e70: f887 304b    	strb.w	r3, [r7, #0x4b]
 8002e74: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8002e78: f083 0301    	eor	r3, r3, #0x1
 8002e7c: b2db         	uxtb	r3, r3
 8002e7e: 2b00         	cmp	r3, #0x0
 8002e80: d10e         	bne	0x8002ea0 <bus_fault+0x90> @ imm = #0x1c
 8002e82: 4b81         	ldr	r3, [pc, #0x204]        @ 0x8003088 <bus_fault+0x278>
 8002e84: 6819         	ldr	r1, [r3]
 8002e86: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x8003094 <bus_fault+0x284>
 8002e88: 9302         	str	r3, [sp, #0x8]
 8002e8a: 2300         	movs	r3, #0x0
 8002e8c: 9301         	str	r3, [sp, #0x4]
 8002e8e: 2300         	movs	r3, #0x0
 8002e90: 9300         	str	r3, [sp]
 8002e92: 2300         	movs	r3, #0x0
 8002e94: 2201         	movs	r2, #0x1
 8002e96: 2000         	movs	r0, #0x0
 8002e98: f00e fdc7    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xeb8e
 8002e9c: 2300         	movs	r3, #0x0
 8002e9e: 647b         	str	r3, [r7, #0x44]
; 	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 8002ea0: 4b7b         	ldr	r3, [pc, #0x1ec]        @ 0x8003090 <bus_fault+0x280>
 8002ea2: 6a9b         	ldr	r3, [r3, #0x28]
 8002ea4: f403 6300    	and	r3, r3, #0x800
 8002ea8: 2b00         	cmp	r3, #0x0
 8002eaa: d01d         	beq	0x8002ee8 <bus_fault+0xd8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_UNSTACKING;
 8002eac: 2318         	movs	r3, #0x18
 8002eae: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 8002eb0: 2303         	movs	r3, #0x3
 8002eb2: 2b00         	cmp	r3, #0x0
 8002eb4: d018         	beq	0x8002ee8 <bus_fault+0xd8> @ imm = #0x30
 8002eb6: 2301         	movs	r3, #0x1
 8002eb8: f887 3043    	strb.w	r3, [r7, #0x43]
 8002ebc: f897 3043    	ldrb.w	r3, [r7, #0x43]
 8002ec0: f083 0301    	eor	r3, r3, #0x1
 8002ec4: b2db         	uxtb	r3, r3
 8002ec6: 2b00         	cmp	r3, #0x0
 8002ec8: d10e         	bne	0x8002ee8 <bus_fault+0xd8> @ imm = #0x1c
 8002eca: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x8003088 <bus_fault+0x278>
 8002ecc: 6819         	ldr	r1, [r3]
 8002ece: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8003098 <bus_fault+0x288>
 8002ed0: 9302         	str	r3, [sp, #0x8]
 8002ed2: 2300         	movs	r3, #0x0
 8002ed4: 9301         	str	r3, [sp, #0x4]
 8002ed6: 2300         	movs	r3, #0x0
 8002ed8: 9300         	str	r3, [sp]
 8002eda: 2300         	movs	r3, #0x0
 8002edc: 2201         	movs	r2, #0x1
 8002ede: 2000         	movs	r0, #0x0
 8002ee0: f00e fda3    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xeb46
 8002ee4: 2300         	movs	r3, #0x0
 8002ee6: 63fb         	str	r3, [r7, #0x3c]
; 	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 8002ee8: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8003090 <bus_fault+0x280>
 8002eea: 6a9b         	ldr	r3, [r3, #0x28]
 8002eec: f403 7300    	and	r3, r3, #0x200
 8002ef0: 2b00         	cmp	r3, #0x0
 8002ef2: d04d         	beq	0x8002f90 <bus_fault+0x180> @ imm = #0x9a
; 		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
 8002ef4: 2319         	movs	r3, #0x19
 8002ef6: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Precise data bus error");
 8002ef8: 2303         	movs	r3, #0x3
 8002efa: 2b00         	cmp	r3, #0x0
 8002efc: d018         	beq	0x8002f30 <bus_fault+0x120> @ imm = #0x30
 8002efe: 2301         	movs	r3, #0x1
 8002f00: f887 303b    	strb.w	r3, [r7, #0x3b]
 8002f04: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8002f08: f083 0301    	eor	r3, r3, #0x1
 8002f0c: b2db         	uxtb	r3, r3
 8002f0e: 2b00         	cmp	r3, #0x0
 8002f10: d10e         	bne	0x8002f30 <bus_fault+0x120> @ imm = #0x1c
 8002f12: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8003088 <bus_fault+0x278>
 8002f14: 6819         	ldr	r1, [r3]
 8002f16: 4b61         	ldr	r3, [pc, #0x184]        @ 0x800309c <bus_fault+0x28c>
 8002f18: 9302         	str	r3, [sp, #0x8]
 8002f1a: 2300         	movs	r3, #0x0
 8002f1c: 9301         	str	r3, [sp, #0x4]
 8002f1e: 2300         	movs	r3, #0x0
 8002f20: 9300         	str	r3, [sp]
 8002f22: 2300         	movs	r3, #0x0
 8002f24: 2201         	movs	r2, #0x1
 8002f26: 2000         	movs	r0, #0x0
 8002f28: f00e fd7f    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xeafe
 8002f2c: 2300         	movs	r3, #0x0
 8002f2e: 637b         	str	r3, [r7, #0x34]
; 		STORE_xFAR(bfar, SCB->BFAR);
 8002f30: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8003090 <bus_fault+0x280>
 8002f32: 6b9b         	ldr	r3, [r3, #0x38]
 8002f34: 633b         	str	r3, [r7, #0x30]
; 		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 8002f36: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8003090 <bus_fault+0x280>
 8002f38: 6a9b         	ldr	r3, [r3, #0x28]
 8002f3a: f403 4300    	and	r3, r3, #0x8000
 8002f3e: 2b00         	cmp	r3, #0x0
 8002f40: d026         	beq	0x8002f90 <bus_fault+0x180> @ imm = #0x4c
; 			PR_EXC("  BFAR Address: 0x%x", bfar);
 8002f42: 2303         	movs	r3, #0x3
 8002f44: 2b00         	cmp	r3, #0x0
 8002f46: d01a         	beq	0x8002f7e <bus_fault+0x16e> @ imm = #0x34
 8002f48: 2301         	movs	r3, #0x1
 8002f4a: f887 302f    	strb.w	r3, [r7, #0x2f]
 8002f4e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8002f52: f083 0301    	eor	r3, r3, #0x1
 8002f56: b2db         	uxtb	r3, r3
 8002f58: 2b00         	cmp	r3, #0x0
 8002f5a: d110         	bne	0x8002f7e <bus_fault+0x16e> @ imm = #0x20
 8002f5c: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x8003088 <bus_fault+0x278>
 8002f5e: 6819         	ldr	r1, [r3]
 8002f60: 6b3b         	ldr	r3, [r7, #0x30]
 8002f62: 9303         	str	r3, [sp, #0xc]
 8002f64: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x80030a0 <bus_fault+0x290>
 8002f66: 9302         	str	r3, [sp, #0x8]
 8002f68: 2300         	movs	r3, #0x0
 8002f6a: 9301         	str	r3, [sp, #0x4]
 8002f6c: 2300         	movs	r3, #0x0
 8002f6e: 9300         	str	r3, [sp]
 8002f70: 2300         	movs	r3, #0x0
 8002f72: 2201         	movs	r2, #0x1
 8002f74: 2000         	movs	r0, #0x0
 8002f76: f00e fd58    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xeab0
 8002f7a: 2300         	movs	r3, #0x0
 8002f7c: 62bb         	str	r3, [r7, #0x28]
; 			if (from_hard_fault != 0) {
 8002f7e: 68bb         	ldr	r3, [r7, #0x8]
 8002f80: 2b00         	cmp	r3, #0x0
 8002f82: d005         	beq	0x8002f90 <bus_fault+0x180> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 8002f84: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8003090 <bus_fault+0x280>
 8002f86: 6a9b         	ldr	r3, [r3, #0x28]
 8002f88: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8003090 <bus_fault+0x280>
 8002f8a: f423 4300    	bic	r3, r3, #0x8000
 8002f8e: 6293         	str	r3, [r2, #0x28]
; 	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 8002f90: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x8003090 <bus_fault+0x280>
 8002f92: 6a9b         	ldr	r3, [r3, #0x28]
 8002f94: f403 6380    	and	r3, r3, #0x400
 8002f98: 2b00         	cmp	r3, #0x0
 8002f9a: d01d         	beq	0x8002fd8 <bus_fault+0x1c8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
 8002f9c: 231a         	movs	r3, #0x1a
 8002f9e: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Imprecise data bus error");
 8002fa0: 2303         	movs	r3, #0x3
 8002fa2: 2b00         	cmp	r3, #0x0
 8002fa4: d018         	beq	0x8002fd8 <bus_fault+0x1c8> @ imm = #0x30
 8002fa6: 2301         	movs	r3, #0x1
 8002fa8: f887 3027    	strb.w	r3, [r7, #0x27]
 8002fac: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8002fb0: f083 0301    	eor	r3, r3, #0x1
 8002fb4: b2db         	uxtb	r3, r3
 8002fb6: 2b00         	cmp	r3, #0x0
 8002fb8: d10e         	bne	0x8002fd8 <bus_fault+0x1c8> @ imm = #0x1c
 8002fba: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8003088 <bus_fault+0x278>
 8002fbc: 6819         	ldr	r1, [r3]
 8002fbe: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x80030a4 <bus_fault+0x294>
 8002fc0: 9302         	str	r3, [sp, #0x8]
 8002fc2: 2300         	movs	r3, #0x0
 8002fc4: 9301         	str	r3, [sp, #0x4]
 8002fc6: 2300         	movs	r3, #0x0
 8002fc8: 9300         	str	r3, [sp]
 8002fca: 2300         	movs	r3, #0x0
 8002fcc: 2201         	movs	r2, #0x1
 8002fce: 2000         	movs	r0, #0x0
 8002fd0: f00e fd2b    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xea56
 8002fd4: 2300         	movs	r3, #0x0
 8002fd6: 623b         	str	r3, [r7, #0x20]
; 	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 8002fd8: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8003090 <bus_fault+0x280>
 8002fda: 6a9b         	ldr	r3, [r3, #0x28]
 8002fdc: f403 7380    	and	r3, r3, #0x100
 8002fe0: 2b00         	cmp	r3, #0x0
 8002fe2: d01c         	beq	0x800301e <bus_fault+0x20e> @ imm = #0x38
; 		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
 8002fe4: 231b         	movs	r3, #0x1b
 8002fe6: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction bus error");
 8002fe8: 2303         	movs	r3, #0x3
 8002fea: 2b00         	cmp	r3, #0x0
 8002fec: d039         	beq	0x8003062 <bus_fault+0x252> @ imm = #0x72
 8002fee: 2301         	movs	r3, #0x1
 8002ff0: 75fb         	strb	r3, [r7, #0x17]
 8002ff2: 7dfb         	ldrb	r3, [r7, #0x17]
 8002ff4: f083 0301    	eor	r3, r3, #0x1
 8002ff8: b2db         	uxtb	r3, r3
 8002ffa: 2b00         	cmp	r3, #0x0
 8002ffc: d131         	bne	0x8003062 <bus_fault+0x252> @ imm = #0x62
 8002ffe: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8003088 <bus_fault+0x278>
 8003000: 6819         	ldr	r1, [r3]
 8003002: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x80030a8 <bus_fault+0x298>
 8003004: 9302         	str	r3, [sp, #0x8]
 8003006: 2300         	movs	r3, #0x0
 8003008: 9301         	str	r3, [sp, #0x4]
 800300a: 2300         	movs	r3, #0x0
 800300c: 9300         	str	r3, [sp]
 800300e: 2300         	movs	r3, #0x0
 8003010: 2201         	movs	r2, #0x1
 8003012: 2000         	movs	r0, #0x0
 8003014: f00e fd09    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xea12
 8003018: 2300         	movs	r3, #0x0
 800301a: 613b         	str	r3, [r7, #0x10]
 800301c: e021         	b	0x8003062 <bus_fault+0x252> @ imm = #0x42
; 	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
 800301e: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8003090 <bus_fault+0x280>
 8003020: 6a9b         	ldr	r3, [r3, #0x28]
 8003022: f403 5300    	and	r3, r3, #0x2000
 8003026: 2b00         	cmp	r3, #0x0
 8003028: d01b         	beq	0x8003062 <bus_fault+0x252> @ imm = #0x36
; 		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
 800302a: 231c         	movs	r3, #0x1c
 800302c: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Floating-point lazy state preservation error");
 800302e: 2303         	movs	r3, #0x3
 8003030: 2b00         	cmp	r3, #0x0
 8003032: d016         	beq	0x8003062 <bus_fault+0x252> @ imm = #0x2c
 8003034: 2301         	movs	r3, #0x1
 8003036: 77fb         	strb	r3, [r7, #0x1f]
 8003038: 7ffb         	ldrb	r3, [r7, #0x1f]
 800303a: f083 0301    	eor	r3, r3, #0x1
 800303e: b2db         	uxtb	r3, r3
 8003040: 2b00         	cmp	r3, #0x0
 8003042: d10e         	bne	0x8003062 <bus_fault+0x252> @ imm = #0x1c
 8003044: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8003088 <bus_fault+0x278>
 8003046: 6819         	ldr	r1, [r3]
 8003048: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80030ac <bus_fault+0x29c>
 800304a: 9302         	str	r3, [sp, #0x8]
 800304c: 2300         	movs	r3, #0x0
 800304e: 9301         	str	r3, [sp, #0x4]
 8003050: 2300         	movs	r3, #0x0
 8003052: 9300         	str	r3, [sp]
 8003054: 2300         	movs	r3, #0x0
 8003056: 2201         	movs	r2, #0x1
 8003058: 2000         	movs	r0, #0x0
 800305a: f00e fce6    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe9cc
 800305e: 2300         	movs	r3, #0x0
 8003060: 61bb         	str	r3, [r7, #0x18]
; 	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 8003062: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8003090 <bus_fault+0x280>
 8003064: 6a9b         	ldr	r3, [r3, #0x28]
 8003066: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8003090 <bus_fault+0x280>
 8003068: f443 437f    	orr	r3, r3, #0xff00
 800306c: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 800306e: 2101         	movs	r1, #0x1
 8003070: 68f8         	ldr	r0, [r7, #0xc]
 8003072: f00e fd02    	bl	0x8011a7a <memory_fault_recoverable> @ imm = #0xea04
 8003076: 4603         	mov	r3, r0
 8003078: 461a         	mov	r2, r3
 800307a: 687b         	ldr	r3, [r7, #0x4]
 800307c: 701a         	strb	r2, [r3]
; 	return reason;
 800307e: 6d7b         	ldr	r3, [r7, #0x54]
; }
 8003080: 4618         	mov	r0, r3
 8003082: 3758         	adds	r7, #0x58
 8003084: 46bd         	mov	sp, r7
 8003086: bd80         	pop	{r7, pc}

08003088 <$d>:
 8003088: e0 02 00 20  	.word	0x200002e0
 800308c: 38 9d 01 08  	.word	0x08019d38
 8003090: 00 ed 00 e0  	.word	0xe000ed00
 8003094: 50 9d 01 08  	.word	0x08019d50
 8003098: a4 9c 01 08  	.word	0x08019ca4
 800309c: 64 9d 01 08  	.word	0x08019d64
 80030a0: 80 9d 01 08  	.word	0x08019d80
 80030a4: 98 9d 01 08  	.word	0x08019d98
 80030a8: b4 9d 01 08  	.word	0x08019db4
 80030ac: 08 9d 01 08  	.word	0x08019d08

080030b0 <usage_fault>:
; {
 80030b0: b580         	push	{r7, lr}
 80030b2: b096         	sub	sp, #0x58
 80030b4: af04         	add	r7, sp, #0x10
 80030b6: 6078         	str	r0, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
 80030b8: 231d         	movs	r3, #0x1d
 80030ba: 647b         	str	r3, [r7, #0x44]
; 	PR_FAULT_INFO("***** USAGE FAULT *****");
 80030bc: 2303         	movs	r3, #0x3
 80030be: 2b00         	cmp	r3, #0x0
 80030c0: d018         	beq	0x80030f4 <usage_fault+0x44> @ imm = #0x30
 80030c2: 2301         	movs	r3, #0x1
 80030c4: f887 3043    	strb.w	r3, [r7, #0x43]
 80030c8: f897 3043    	ldrb.w	r3, [r7, #0x43]
 80030cc: f083 0301    	eor	r3, r3, #0x1
 80030d0: b2db         	uxtb	r3, r3
 80030d2: 2b00         	cmp	r3, #0x0
 80030d4: d10e         	bne	0x80030f4 <usage_fault+0x44> @ imm = #0x1c
 80030d6: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x80032b8 <usage_fault+0x208>
 80030d8: 6819         	ldr	r1, [r3]
 80030da: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x80032bc <usage_fault+0x20c>
 80030dc: 9302         	str	r3, [sp, #0x8]
 80030de: 2300         	movs	r3, #0x0
 80030e0: 9301         	str	r3, [sp, #0x4]
 80030e2: 2300         	movs	r3, #0x0
 80030e4: 9300         	str	r3, [sp]
 80030e6: 2300         	movs	r3, #0x0
 80030e8: 2201         	movs	r2, #0x1
 80030ea: 2000         	movs	r0, #0x0
 80030ec: f00e fc9d    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe93a
 80030f0: 2300         	movs	r3, #0x0
 80030f2: 63fb         	str	r3, [r7, #0x3c]
; 	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 80030f4: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x80032c0 <usage_fault+0x210>
 80030f6: 6a9b         	ldr	r3, [r3, #0x28]
 80030f8: f003 7300    	and	r3, r3, #0x2000000
 80030fc: 2b00         	cmp	r3, #0x0
 80030fe: d01d         	beq	0x800313c <usage_fault+0x8c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_DIV_0;
 8003100: 231e         	movs	r3, #0x1e
 8003102: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Division by zero");
 8003104: 2303         	movs	r3, #0x3
 8003106: 2b00         	cmp	r3, #0x0
 8003108: d018         	beq	0x800313c <usage_fault+0x8c> @ imm = #0x30
 800310a: 2301         	movs	r3, #0x1
 800310c: f887 303b    	strb.w	r3, [r7, #0x3b]
 8003110: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8003114: f083 0301    	eor	r3, r3, #0x1
 8003118: b2db         	uxtb	r3, r3
 800311a: 2b00         	cmp	r3, #0x0
 800311c: d10e         	bne	0x800313c <usage_fault+0x8c> @ imm = #0x1c
 800311e: 4b66         	ldr	r3, [pc, #0x198]        @ 0x80032b8 <usage_fault+0x208>
 8003120: 6819         	ldr	r1, [r3]
 8003122: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x80032c4 <usage_fault+0x214>
 8003124: 9302         	str	r3, [sp, #0x8]
 8003126: 2300         	movs	r3, #0x0
 8003128: 9301         	str	r3, [sp, #0x4]
 800312a: 2300         	movs	r3, #0x0
 800312c: 9300         	str	r3, [sp]
 800312e: 2300         	movs	r3, #0x0
 8003130: 2201         	movs	r2, #0x1
 8003132: 2000         	movs	r0, #0x0
 8003134: f00e fc79    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe8f2
 8003138: 2300         	movs	r3, #0x0
 800313a: 637b         	str	r3, [r7, #0x34]
; 	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 800313c: 4b60         	ldr	r3, [pc, #0x180]        @ 0x80032c0 <usage_fault+0x210>
 800313e: 6a9b         	ldr	r3, [r3, #0x28]
 8003140: f003 7380    	and	r3, r3, #0x1000000
 8003144: 2b00         	cmp	r3, #0x0
 8003146: d01d         	beq	0x8003184 <usage_fault+0xd4> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
 8003148: 231f         	movs	r3, #0x1f
 800314a: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Unaligned memory access");
 800314c: 2303         	movs	r3, #0x3
 800314e: 2b00         	cmp	r3, #0x0
 8003150: d018         	beq	0x8003184 <usage_fault+0xd4> @ imm = #0x30
 8003152: 2301         	movs	r3, #0x1
 8003154: f887 3033    	strb.w	r3, [r7, #0x33]
 8003158: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800315c: f083 0301    	eor	r3, r3, #0x1
 8003160: b2db         	uxtb	r3, r3
 8003162: 2b00         	cmp	r3, #0x0
 8003164: d10e         	bne	0x8003184 <usage_fault+0xd4> @ imm = #0x1c
 8003166: 4b54         	ldr	r3, [pc, #0x150]        @ 0x80032b8 <usage_fault+0x208>
 8003168: 6819         	ldr	r1, [r3]
 800316a: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x80032c8 <usage_fault+0x218>
 800316c: 9302         	str	r3, [sp, #0x8]
 800316e: 2300         	movs	r3, #0x0
 8003170: 9301         	str	r3, [sp, #0x4]
 8003172: 2300         	movs	r3, #0x0
 8003174: 9300         	str	r3, [sp]
 8003176: 2300         	movs	r3, #0x0
 8003178: 2201         	movs	r2, #0x1
 800317a: 2000         	movs	r0, #0x0
 800317c: f00e fc55    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe8aa
 8003180: 2300         	movs	r3, #0x0
 8003182: 62fb         	str	r3, [r7, #0x2c]
; 	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 8003184: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x80032c0 <usage_fault+0x210>
 8003186: 6a9b         	ldr	r3, [r3, #0x28]
 8003188: f403 2300    	and	r3, r3, #0x80000
 800318c: 2b00         	cmp	r3, #0x0
 800318e: d01d         	beq	0x80031cc <usage_fault+0x11c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
 8003190: 2321         	movs	r3, #0x21
 8003192: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  No coprocessor instructions");
 8003194: 2303         	movs	r3, #0x3
 8003196: 2b00         	cmp	r3, #0x0
 8003198: d018         	beq	0x80031cc <usage_fault+0x11c> @ imm = #0x30
 800319a: 2301         	movs	r3, #0x1
 800319c: f887 302b    	strb.w	r3, [r7, #0x2b]
 80031a0: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80031a4: f083 0301    	eor	r3, r3, #0x1
 80031a8: b2db         	uxtb	r3, r3
 80031aa: 2b00         	cmp	r3, #0x0
 80031ac: d10e         	bne	0x80031cc <usage_fault+0x11c> @ imm = #0x1c
 80031ae: 4b42         	ldr	r3, [pc, #0x108]        @ 0x80032b8 <usage_fault+0x208>
 80031b0: 6819         	ldr	r1, [r3]
 80031b2: 4b46         	ldr	r3, [pc, #0x118]        @ 0x80032cc <usage_fault+0x21c>
 80031b4: 9302         	str	r3, [sp, #0x8]
 80031b6: 2300         	movs	r3, #0x0
 80031b8: 9301         	str	r3, [sp, #0x4]
 80031ba: 2300         	movs	r3, #0x0
 80031bc: 9300         	str	r3, [sp]
 80031be: 2300         	movs	r3, #0x0
 80031c0: 2201         	movs	r2, #0x1
 80031c2: 2000         	movs	r0, #0x0
 80031c4: f00e fc31    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe862
 80031c8: 2300         	movs	r3, #0x0
 80031ca: 627b         	str	r3, [r7, #0x24]
; 	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 80031cc: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x80032c0 <usage_fault+0x210>
 80031ce: 6a9b         	ldr	r3, [r3, #0x28]
 80031d0: f403 2380    	and	r3, r3, #0x40000
 80031d4: 2b00         	cmp	r3, #0x0
 80031d6: d01d         	beq	0x8003214 <usage_fault+0x164> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
 80031d8: 2322         	movs	r3, #0x22
 80031da: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
 80031dc: 2303         	movs	r3, #0x3
 80031de: 2b00         	cmp	r3, #0x0
 80031e0: d018         	beq	0x8003214 <usage_fault+0x164> @ imm = #0x30
 80031e2: 2301         	movs	r3, #0x1
 80031e4: f887 3023    	strb.w	r3, [r7, #0x23]
 80031e8: f897 3023    	ldrb.w	r3, [r7, #0x23]
 80031ec: f083 0301    	eor	r3, r3, #0x1
 80031f0: b2db         	uxtb	r3, r3
 80031f2: 2b00         	cmp	r3, #0x0
 80031f4: d10e         	bne	0x8003214 <usage_fault+0x164> @ imm = #0x1c
 80031f6: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x80032b8 <usage_fault+0x208>
 80031f8: 6819         	ldr	r1, [r3]
 80031fa: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80032d0 <usage_fault+0x220>
 80031fc: 9302         	str	r3, [sp, #0x8]
 80031fe: 2300         	movs	r3, #0x0
 8003200: 9301         	str	r3, [sp, #0x4]
 8003202: 2300         	movs	r3, #0x0
 8003204: 9300         	str	r3, [sp]
 8003206: 2300         	movs	r3, #0x0
 8003208: 2201         	movs	r2, #0x1
 800320a: 2000         	movs	r0, #0x0
 800320c: f00e fc0d    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe81a
 8003210: 2300         	movs	r3, #0x0
 8003212: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 8003214: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80032c0 <usage_fault+0x210>
 8003216: 6a9b         	ldr	r3, [r3, #0x28]
 8003218: f403 3300    	and	r3, r3, #0x20000
 800321c: 2b00         	cmp	r3, #0x0
 800321e: d01b         	beq	0x8003258 <usage_fault+0x1a8> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
 8003220: 2323         	movs	r3, #0x23
 8003222: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal use of the EPSR");
 8003224: 2303         	movs	r3, #0x3
 8003226: 2b00         	cmp	r3, #0x0
 8003228: d016         	beq	0x8003258 <usage_fault+0x1a8> @ imm = #0x2c
 800322a: 2301         	movs	r3, #0x1
 800322c: 76fb         	strb	r3, [r7, #0x1b]
 800322e: 7efb         	ldrb	r3, [r7, #0x1b]
 8003230: f083 0301    	eor	r3, r3, #0x1
 8003234: b2db         	uxtb	r3, r3
 8003236: 2b00         	cmp	r3, #0x0
 8003238: d10e         	bne	0x8003258 <usage_fault+0x1a8> @ imm = #0x1c
 800323a: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80032b8 <usage_fault+0x208>
 800323c: 6819         	ldr	r1, [r3]
 800323e: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80032d4 <usage_fault+0x224>
 8003240: 9302         	str	r3, [sp, #0x8]
 8003242: 2300         	movs	r3, #0x0
 8003244: 9301         	str	r3, [sp, #0x4]
 8003246: 2300         	movs	r3, #0x0
 8003248: 9300         	str	r3, [sp]
 800324a: 2300         	movs	r3, #0x0
 800324c: 2201         	movs	r2, #0x1
 800324e: 2000         	movs	r0, #0x0
 8003250: f00e fbeb    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe7d6
 8003254: 2300         	movs	r3, #0x0
 8003256: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 8003258: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80032c0 <usage_fault+0x210>
 800325a: 6a9b         	ldr	r3, [r3, #0x28]
 800325c: f403 3380    	and	r3, r3, #0x10000
 8003260: 2b00         	cmp	r3, #0x0
 8003262: d01b         	beq	0x800329c <usage_fault+0x1ec> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
 8003264: 2324         	movs	r3, #0x24
 8003266: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Attempt to execute undefined instruction");
 8003268: 2303         	movs	r3, #0x3
 800326a: 2b00         	cmp	r3, #0x0
 800326c: d016         	beq	0x800329c <usage_fault+0x1ec> @ imm = #0x2c
 800326e: 2301         	movs	r3, #0x1
 8003270: 74fb         	strb	r3, [r7, #0x13]
 8003272: 7cfb         	ldrb	r3, [r7, #0x13]
 8003274: f083 0301    	eor	r3, r3, #0x1
 8003278: b2db         	uxtb	r3, r3
 800327a: 2b00         	cmp	r3, #0x0
 800327c: d10e         	bne	0x800329c <usage_fault+0x1ec> @ imm = #0x1c
 800327e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80032b8 <usage_fault+0x208>
 8003280: 6819         	ldr	r1, [r3]
 8003282: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80032d8 <usage_fault+0x228>
 8003284: 9302         	str	r3, [sp, #0x8]
 8003286: 2300         	movs	r3, #0x0
 8003288: 9301         	str	r3, [sp, #0x4]
 800328a: 2300         	movs	r3, #0x0
 800328c: 9300         	str	r3, [sp]
 800328e: 2300         	movs	r3, #0x0
 8003290: 2201         	movs	r2, #0x1
 8003292: 2000         	movs	r0, #0x0
 8003294: f00e fbc9    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe792
 8003298: 2300         	movs	r3, #0x0
 800329a: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 800329c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80032c0 <usage_fault+0x210>
 800329e: 6a9b         	ldr	r3, [r3, #0x28]
 80032a0: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80032c0 <usage_fault+0x210>
 80032a2: ea6f 4303    	mvn.w	r3, r3, lsl #16
 80032a6: ea6f 4313    	mvn.w	r3, r3, lsr #16
 80032aa: 6293         	str	r3, [r2, #0x28]
; 	return reason;
 80032ac: 6c7b         	ldr	r3, [r7, #0x44]
; }
 80032ae: 4618         	mov	r0, r3
 80032b0: 3748         	adds	r7, #0x48
 80032b2: 46bd         	mov	sp, r7
 80032b4: bd80         	pop	{r7, pc}
 80032b6: bf00         	nop

080032b8 <$d>:
 80032b8: e0 02 00 20  	.word	0x200002e0
 80032bc: cc 9d 01 08  	.word	0x08019dcc
 80032c0: 00 ed 00 e0  	.word	0xe000ed00
 80032c4: e4 9d 01 08  	.word	0x08019de4
 80032c8: f8 9d 01 08  	.word	0x08019df8
 80032cc: 14 9e 01 08  	.word	0x08019e14
 80032d0: 34 9e 01 08  	.word	0x08019e34
 80032d4: 5c 9e 01 08  	.word	0x08019e5c
 80032d8: 78 9e 01 08  	.word	0x08019e78

080032dc <debug_monitor>:
; {
 80032dc: b580         	push	{r7, lr}
 80032de: b088         	sub	sp, #0x20
 80032e0: af04         	add	r7, sp, #0x10
 80032e2: 6078         	str	r0, [r7, #0x4]
 80032e4: 6039         	str	r1, [r7]
; 	*recoverable = false;
 80032e6: 683b         	ldr	r3, [r7]
 80032e8: 2200         	movs	r2, #0x0
 80032ea: 701a         	strb	r2, [r3]
; 	PR_FAULT_INFO(
 80032ec: 2303         	movs	r3, #0x3
 80032ee: 2b00         	cmp	r3, #0x0
 80032f0: d017         	beq	0x8003322 <debug_monitor+0x46> @ imm = #0x2e
 80032f2: 2301         	movs	r3, #0x1
 80032f4: 73fb         	strb	r3, [r7, #0xf]
 80032f6: 7bfb         	ldrb	r3, [r7, #0xf]
 80032f8: f083 0301    	eor	r3, r3, #0x1
 80032fc: b2db         	uxtb	r3, r3
 80032fe: 2b00         	cmp	r3, #0x0
 8003300: d10f         	bne	0x8003322 <debug_monitor+0x46> @ imm = #0x1e
 8003302: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800332c <debug_monitor+0x50>
 8003304: 6819         	ldr	r1, [r3]
 8003306: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8003330 <debug_monitor+0x54>
 8003308: 9302         	str	r3, [sp, #0x8]
 800330a: 2300         	movs	r3, #0x0
 800330c: 9301         	str	r3, [sp, #0x4]
 800330e: 2300         	movs	r3, #0x0
 8003310: 9300         	str	r3, [sp]
 8003312: 2300         	movs	r3, #0x0
 8003314: 2201         	movs	r2, #0x1
 8003316: 2000         	movs	r0, #0x0
 8003318: f00e fb87    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe70e
 800331c: 2300         	movs	r3, #0x0
 800331e: 60bb         	str	r3, [r7, #0x8]
; }
 8003320: bf00         	nop
 8003322: bf00         	nop
 8003324: 3710         	adds	r7, #0x10
 8003326: 46bd         	mov	sp, r7
 8003328: bd80         	pop	{r7, pc}
 800332a: bf00         	nop

0800332c <$d>:
 800332c: e0 02 00 20  	.word	0x200002e0
 8003330: a4 9e 01 08  	.word	0x08019ea4

08003334 <z_arm_is_synchronous_svc>:
; {
 8003334: b480         	push	{r7}
 8003336: b085         	sub	sp, #0x14
 8003338: af00         	add	r7, sp, #0x0
 800333a: 6078         	str	r0, [r7, #0x4]
; 	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
 800333c: 687b         	ldr	r3, [r7, #0x4]
 800333e: 699b         	ldr	r3, [r3, #0x18]
 8003340: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
 8003342: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x80033b0 <z_arm_is_synchronous_svc+0x7c>
 8003344: 695b         	ldr	r3, [r3, #0x14]
 8003346: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x80033b0 <z_arm_is_synchronous_svc+0x7c>
 8003348: f443 7380    	orr	r3, r3, #0x100
 800334c: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 800334e: f3bf 8f4f    	dsb	sy
; }
 8003352: bf00         	nop
; }
 8003354: bf00         	nop
; }
 8003356: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8003358: f3bf 8f6f    	isb	sy
; }
 800335c: bf00         	nop
; }
 800335e: bf00         	nop
; }
 8003360: bf00         	nop
; 	uint16_t fault_insn = *(ret_addr - 1);
 8003362: 68fb         	ldr	r3, [r7, #0xc]
 8003364: f833 3c02    	ldrh	r3, [r3, #-2]
 8003368: 817b         	strh	r3, [r7, #0xa]
; 	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
 800336a: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80033b0 <z_arm_is_synchronous_svc+0x7c>
 800336c: 695b         	ldr	r3, [r3, #0x14]
 800336e: 4a10         	ldr	r2, [pc, #0x40]         @ 0x80033b0 <z_arm_is_synchronous_svc+0x7c>
 8003370: f423 7380    	bic	r3, r3, #0x100
 8003374: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 8003376: f3bf 8f4f    	dsb	sy
; }
 800337a: bf00         	nop
; }
 800337c: bf00         	nop
; }
 800337e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8003380: f3bf 8f6f    	isb	sy
; }
 8003384: bf00         	nop
; }
 8003386: bf00         	nop
; }
 8003388: bf00         	nop
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 800338a: 897b         	ldrh	r3, [r7, #0xa]
 800338c: f403 437f    	and	r3, r3, #0xff00
 8003390: f5b3 4f5f    	cmp.w	r3, #0xdf00
 8003394: d105         	bne	0x80033a2 <z_arm_is_synchronous_svc+0x6e> @ imm = #0xa
; 		((fault_insn & 0x00ff) == _SVC_CALL_RUNTIME_EXCEPT)) {
 8003396: 897b         	ldrh	r3, [r7, #0xa]
 8003398: b2db         	uxtb	r3, r3
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 800339a: 2b02         	cmp	r3, #0x2
 800339c: d101         	bne	0x80033a2 <z_arm_is_synchronous_svc+0x6e> @ imm = #0x2
; 		return true;
 800339e: 2301         	movs	r3, #0x1
 80033a0: e000         	b	0x80033a4 <z_arm_is_synchronous_svc+0x70> @ imm = #0x0
; 	return false;
 80033a2: 2300         	movs	r3, #0x0
; }
 80033a4: 4618         	mov	r0, r3
 80033a6: 3714         	adds	r7, #0x14
 80033a8: 46bd         	mov	sp, r7
 80033aa: bc80         	pop	{r7}
 80033ac: 4770         	bx	lr
 80033ae: bf00         	nop

080033b0 <$d>:
 80033b0: 00 ed 00 e0  	.word	0xe000ed00

080033b4 <hard_fault>:
; {
 80033b4: b580         	push	{r7, lr}
 80033b6: b092         	sub	sp, #0x48
 80033b8: af04         	add	r7, sp, #0x10
 80033ba: 6078         	str	r0, [r7, #0x4]
 80033bc: 6039         	str	r1, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 80033be: 2300         	movs	r3, #0x0
 80033c0: 62fb         	str	r3, [r7, #0x2c]
; 	PR_FAULT_INFO("***** HARD FAULT *****");
 80033c2: 2303         	movs	r3, #0x3
 80033c4: 2b00         	cmp	r3, #0x0
 80033c6: d018         	beq	0x80033fa <hard_fault+0x46> @ imm = #0x30
 80033c8: 2301         	movs	r3, #0x1
 80033ca: f887 3033    	strb.w	r3, [r7, #0x33]
 80033ce: f897 3033    	ldrb.w	r3, [r7, #0x33]
 80033d2: f083 0301    	eor	r3, r3, #0x1
 80033d6: b2db         	uxtb	r3, r3
 80033d8: 2b00         	cmp	r3, #0x0
 80033da: d10e         	bne	0x80033fa <hard_fault+0x46> @ imm = #0x1c
 80033dc: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x800356c <hard_fault+0x1b8>
 80033de: 6819         	ldr	r1, [r3]
 80033e0: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8003570 <hard_fault+0x1bc>
 80033e2: 9302         	str	r3, [sp, #0x8]
 80033e4: 2300         	movs	r3, #0x0
 80033e6: 9301         	str	r3, [sp, #0x4]
 80033e8: 2300         	movs	r3, #0x0
 80033ea: 9300         	str	r3, [sp]
 80033ec: 2300         	movs	r3, #0x0
 80033ee: 2201         	movs	r2, #0x1
 80033f0: 2000         	movs	r0, #0x0
 80033f2: f00e fb1a    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe634
 80033f6: 2300         	movs	r3, #0x0
 80033f8: 637b         	str	r3, [r7, #0x34]
; 	*recoverable = false;
 80033fa: 683b         	ldr	r3, [r7]
 80033fc: 2200         	movs	r2, #0x0
 80033fe: 701a         	strb	r2, [r3]
; 	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 8003400: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8003574 <hard_fault+0x1c0>
 8003402: 6adb         	ldr	r3, [r3, #0x2c]
 8003404: f003 0302    	and	r3, r3, #0x2
 8003408: 2b00         	cmp	r3, #0x0
 800340a: d01c         	beq	0x8003446 <hard_fault+0x92> @ imm = #0x38
; 		PR_EXC("  Bus fault on vector table read");
 800340c: 2303         	movs	r3, #0x3
 800340e: 2b00         	cmp	r3, #0x0
 8003410: f000 80a7    	beq.w	0x8003562 <hard_fault+0x1ae> @ imm = #0x14e
 8003414: 2301         	movs	r3, #0x1
 8003416: 74fb         	strb	r3, [r7, #0x13]
 8003418: 7cfb         	ldrb	r3, [r7, #0x13]
 800341a: f083 0301    	eor	r3, r3, #0x1
 800341e: b2db         	uxtb	r3, r3
 8003420: 2b00         	cmp	r3, #0x0
 8003422: f040 809e    	bne.w	0x8003562 <hard_fault+0x1ae> @ imm = #0x13c
 8003426: 4b51         	ldr	r3, [pc, #0x144]        @ 0x800356c <hard_fault+0x1b8>
 8003428: 6819         	ldr	r1, [r3]
 800342a: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8003578 <hard_fault+0x1c4>
 800342c: 9302         	str	r3, [sp, #0x8]
 800342e: 2300         	movs	r3, #0x0
 8003430: 9301         	str	r3, [sp, #0x4]
 8003432: 2300         	movs	r3, #0x0
 8003434: 9300         	str	r3, [sp]
 8003436: 2300         	movs	r3, #0x0
 8003438: 2201         	movs	r2, #0x1
 800343a: 2000         	movs	r0, #0x0
 800343c: f00e faf5    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe5ea
 8003440: 2300         	movs	r3, #0x0
 8003442: 60fb         	str	r3, [r7, #0xc]
 8003444: e08d         	b	0x8003562 <hard_fault+0x1ae> @ imm = #0x11a
; 	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
 8003446: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8003574 <hard_fault+0x1c0>
 8003448: 6adb         	ldr	r3, [r3, #0x2c]
 800344a: 2b00         	cmp	r3, #0x0
 800344c: da1b         	bge	0x8003486 <hard_fault+0xd2> @ imm = #0x36
; 		PR_EXC("  Debug event");
 800344e: 2303         	movs	r3, #0x3
 8003450: 2b00         	cmp	r3, #0x0
 8003452: f000 8086    	beq.w	0x8003562 <hard_fault+0x1ae> @ imm = #0x10c
 8003456: 2301         	movs	r3, #0x1
 8003458: 76fb         	strb	r3, [r7, #0x1b]
 800345a: 7efb         	ldrb	r3, [r7, #0x1b]
 800345c: f083 0301    	eor	r3, r3, #0x1
 8003460: b2db         	uxtb	r3, r3
 8003462: 2b00         	cmp	r3, #0x0
 8003464: d17d         	bne	0x8003562 <hard_fault+0x1ae> @ imm = #0xfa
 8003466: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800356c <hard_fault+0x1b8>
 8003468: 6819         	ldr	r1, [r3]
 800346a: 4b44         	ldr	r3, [pc, #0x110]        @ 0x800357c <hard_fault+0x1c8>
 800346c: 9302         	str	r3, [sp, #0x8]
 800346e: 2300         	movs	r3, #0x0
 8003470: 9301         	str	r3, [sp, #0x4]
 8003472: 2300         	movs	r3, #0x0
 8003474: 9300         	str	r3, [sp]
 8003476: 2300         	movs	r3, #0x0
 8003478: 2201         	movs	r2, #0x1
 800347a: 2000         	movs	r0, #0x0
 800347c: f00e fad5    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe5aa
 8003480: 2300         	movs	r3, #0x0
 8003482: 617b         	str	r3, [r7, #0x14]
 8003484: e06d         	b	0x8003562 <hard_fault+0x1ae> @ imm = #0xda
; 	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 8003486: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8003574 <hard_fault+0x1c0>
 8003488: 6adb         	ldr	r3, [r3, #0x2c]
 800348a: f003 4380    	and	r3, r3, #0x40000000
 800348e: 2b00         	cmp	r3, #0x0
 8003490: d067         	beq	0x8003562 <hard_fault+0x1ae> @ imm = #0xce
; 		PR_EXC("  Fault escalation (see below)");
 8003492: 2303         	movs	r3, #0x3
 8003494: 2b00         	cmp	r3, #0x0
 8003496: d018         	beq	0x80034ca <hard_fault+0x116> @ imm = #0x30
 8003498: 2301         	movs	r3, #0x1
 800349a: f887 302b    	strb.w	r3, [r7, #0x2b]
 800349e: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80034a2: f083 0301    	eor	r3, r3, #0x1
 80034a6: b2db         	uxtb	r3, r3
 80034a8: 2b00         	cmp	r3, #0x0
 80034aa: d10e         	bne	0x80034ca <hard_fault+0x116> @ imm = #0x1c
 80034ac: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800356c <hard_fault+0x1b8>
 80034ae: 6819         	ldr	r1, [r3]
 80034b0: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8003580 <hard_fault+0x1cc>
 80034b2: 9302         	str	r3, [sp, #0x8]
 80034b4: 2300         	movs	r3, #0x0
 80034b6: 9301         	str	r3, [sp, #0x4]
 80034b8: 2300         	movs	r3, #0x0
 80034ba: 9300         	str	r3, [sp]
 80034bc: 2300         	movs	r3, #0x0
 80034be: 2201         	movs	r2, #0x1
 80034c0: 2000         	movs	r0, #0x0
 80034c2: f00e fab2    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe564
 80034c6: 2300         	movs	r3, #0x0
 80034c8: 627b         	str	r3, [r7, #0x24]
; 		if (z_arm_is_synchronous_svc(esf)) {
 80034ca: 6878         	ldr	r0, [r7, #0x4]
 80034cc: f7ff ff32    	bl	0x8003334 <z_arm_is_synchronous_svc> @ imm = #-0x19c
 80034d0: 4603         	mov	r3, r0
 80034d2: 2b00         	cmp	r3, #0x0
 80034d4: d022         	beq	0x800351c <hard_fault+0x168> @ imm = #0x44
; 			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
 80034d6: 2303         	movs	r3, #0x3
 80034d8: 2b00         	cmp	r3, #0x0
 80034da: d01b         	beq	0x8003514 <hard_fault+0x160> @ imm = #0x36
 80034dc: 2301         	movs	r3, #0x1
 80034de: f887 3023    	strb.w	r3, [r7, #0x23]
 80034e2: f897 3023    	ldrb.w	r3, [r7, #0x23]
 80034e6: f083 0301    	eor	r3, r3, #0x1
 80034ea: b2db         	uxtb	r3, r3
 80034ec: 2b00         	cmp	r3, #0x0
 80034ee: d111         	bne	0x8003514 <hard_fault+0x160> @ imm = #0x22
 80034f0: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800356c <hard_fault+0x1b8>
 80034f2: 6819         	ldr	r1, [r3]
 80034f4: 687b         	ldr	r3, [r7, #0x4]
 80034f6: 681b         	ldr	r3, [r3]
 80034f8: 9303         	str	r3, [sp, #0xc]
 80034fa: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8003584 <hard_fault+0x1d0>
 80034fc: 9302         	str	r3, [sp, #0x8]
 80034fe: 2300         	movs	r3, #0x0
 8003500: 9301         	str	r3, [sp, #0x4]
 8003502: 2300         	movs	r3, #0x0
 8003504: 9300         	str	r3, [sp]
 8003506: 2300         	movs	r3, #0x0
 8003508: 2201         	movs	r2, #0x1
 800350a: 2000         	movs	r0, #0x0
 800350c: f00e fa8d    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe51a
 8003510: 2300         	movs	r3, #0x0
 8003512: 61fb         	str	r3, [r7, #0x1c]
; 			reason = esf->basic.r0;
 8003514: 687b         	ldr	r3, [r7, #0x4]
 8003516: 681b         	ldr	r3, [r3]
 8003518: 62fb         	str	r3, [r7, #0x2c]
 800351a: e022         	b	0x8003562 <hard_fault+0x1ae> @ imm = #0x44
; 		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
 800351c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8003574 <hard_fault+0x1c0>
 800351e: 6a9b         	ldr	r3, [r3, #0x28]
 8003520: b2db         	uxtb	r3, r3
 8003522: 2b00         	cmp	r3, #0x0
 8003524: d006         	beq	0x8003534 <hard_fault+0x180> @ imm = #0xc
; 			reason = mem_manage_fault(esf, 1, recoverable);
 8003526: 683a         	ldr	r2, [r7]
 8003528: 2101         	movs	r1, #0x1
 800352a: 6878         	ldr	r0, [r7, #0x4]
 800352c: f7ff fb2c    	bl	0x8002b88 <mem_manage_fault> @ imm = #-0x9a8
 8003530: 62f8         	str	r0, [r7, #0x2c]
 8003532: e016         	b	0x8003562 <hard_fault+0x1ae> @ imm = #0x2c
; 		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
 8003534: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8003574 <hard_fault+0x1c0>
 8003536: 6a9b         	ldr	r3, [r3, #0x28]
 8003538: f403 437f    	and	r3, r3, #0xff00
 800353c: 2b00         	cmp	r3, #0x0
 800353e: d007         	beq	0x8003550 <hard_fault+0x19c> @ imm = #0xe
; 			reason = bus_fault(esf, 1, recoverable);
 8003540: 683a         	ldr	r2, [r7]
 8003542: 2101         	movs	r1, #0x1
 8003544: 6878         	ldr	r0, [r7, #0x4]
 8003546: f7ff fc63    	bl	0x8002e10 <bus_fault>   @ imm = #-0x73a
 800354a: 4603         	mov	r3, r0
 800354c: 62fb         	str	r3, [r7, #0x2c]
 800354e: e008         	b	0x8003562 <hard_fault+0x1ae> @ imm = #0x10
; 		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
 8003550: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8003574 <hard_fault+0x1c0>
 8003552: 6a9b         	ldr	r3, [r3, #0x28]
 8003554: f5b3 3f80    	cmp.w	r3, #0x10000
 8003558: d303         	blo	0x8003562 <hard_fault+0x1ae> @ imm = #0x6
; 			reason = usage_fault(esf);
 800355a: 6878         	ldr	r0, [r7, #0x4]
 800355c: f7ff fda8    	bl	0x80030b0 <usage_fault> @ imm = #-0x4b0
 8003560: 62f8         	str	r0, [r7, #0x2c]
; 	return reason;
 8003562: 6afb         	ldr	r3, [r7, #0x2c]
; }
 8003564: 4618         	mov	r0, r3
 8003566: 3738         	adds	r7, #0x38
 8003568: 46bd         	mov	sp, r7
 800356a: bd80         	pop	{r7, pc}

0800356c <$d>:
 800356c: e0 02 00 20  	.word	0x200002e0
 8003570: c8 9e 01 08  	.word	0x08019ec8
 8003574: 00 ed 00 e0  	.word	0xe000ed00
 8003578: e0 9e 01 08  	.word	0x08019ee0
 800357c: 04 9f 01 08  	.word	0x08019f04
 8003580: 14 9f 01 08  	.word	0x08019f14
 8003584: 34 9f 01 08  	.word	0x08019f34

08003588 <reserved_exception>:
; {
 8003588: b580         	push	{r7, lr}
 800358a: b08a         	sub	sp, #0x28
 800358c: af06         	add	r7, sp, #0x18
 800358e: 6078         	str	r0, [r7, #0x4]
 8003590: 6039         	str	r1, [r7]
; 	PR_FAULT_INFO("***** %s %d) *****",
 8003592: 2303         	movs	r3, #0x3
 8003594: 2b00         	cmp	r3, #0x0
 8003596: d021         	beq	0x80035dc <reserved_exception+0x54> @ imm = #0x42
 8003598: 2301         	movs	r3, #0x1
 800359a: 73fb         	strb	r3, [r7, #0xf]
 800359c: 7bfb         	ldrb	r3, [r7, #0xf]
 800359e: f083 0301    	eor	r3, r3, #0x1
 80035a2: b2db         	uxtb	r3, r3
 80035a4: 2b00         	cmp	r3, #0x0
 80035a6: d119         	bne	0x80035dc <reserved_exception+0x54> @ imm = #0x32
 80035a8: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80035e4 <reserved_exception+0x5c>
 80035aa: 6819         	ldr	r1, [r3]
 80035ac: 683b         	ldr	r3, [r7]
 80035ae: 2b0f         	cmp	r3, #0xf
 80035b0: dc01         	bgt	0x80035b6 <reserved_exception+0x2e> @ imm = #0x2
 80035b2: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80035e8 <reserved_exception+0x60>
 80035b4: e000         	b	0x80035b8 <reserved_exception+0x30> @ imm = #0x0
 80035b6: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80035ec <reserved_exception+0x64>
 80035b8: 683a         	ldr	r2, [r7]
 80035ba: 3a10         	subs	r2, #0x10
 80035bc: 9204         	str	r2, [sp, #0x10]
 80035be: 9303         	str	r3, [sp, #0xc]
 80035c0: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80035f0 <reserved_exception+0x68>
 80035c2: 9302         	str	r3, [sp, #0x8]
 80035c4: 2300         	movs	r3, #0x0
 80035c6: 9301         	str	r3, [sp, #0x4]
 80035c8: 2300         	movs	r3, #0x0
 80035ca: 9300         	str	r3, [sp]
 80035cc: 2300         	movs	r3, #0x0
 80035ce: 2201         	movs	r2, #0x1
 80035d0: 2000         	movs	r0, #0x0
 80035d2: f00e fa2a    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe454
 80035d6: 2300         	movs	r3, #0x0
 80035d8: 60bb         	str	r3, [r7, #0x8]
; }
 80035da: bf00         	nop
 80035dc: bf00         	nop
 80035de: 3710         	adds	r7, #0x10
 80035e0: 46bd         	mov	sp, r7
 80035e2: bd80         	pop	{r7, pc}

080035e4 <$d>:
 80035e4: e0 02 00 20  	.word	0x200002e0
 80035e8: 50 9f 01 08  	.word	0x08019f50
 80035ec: 68 9f 01 08  	.word	0x08019f68
 80035f0: 84 9f 01 08  	.word	0x08019f84

080035f4 <fault_handle>:
; {
 80035f4: b580         	push	{r7, lr}
 80035f6: b086         	sub	sp, #0x18
 80035f8: af00         	add	r7, sp, #0x0
 80035fa: 60f8         	str	r0, [r7, #0xc]
 80035fc: 60b9         	str	r1, [r7, #0x8]
 80035fe: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8003600: 2300         	movs	r3, #0x0
 8003602: 617b         	str	r3, [r7, #0x14]
; 	*recoverable = false;
 8003604: 687b         	ldr	r3, [r7, #0x4]
 8003606: 2200         	movs	r2, #0x0
 8003608: 701a         	strb	r2, [r3]
; 	switch (fault) {
 800360a: 68bb         	ldr	r3, [r7, #0x8]
 800360c: 3b03         	subs	r3, #0x3
 800360e: 2b09         	cmp	r3, #0x9
 8003610: d835         	bhi	0x800367e <fault_handle+0x8a> @ imm = #0x6a
 8003612: a201         	adr	r2, #4 <fault_handle+0x23>
 8003614: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08003618 <$d>:
 8003618: 41 36 00 08  	.word	0x08003641
 800361c: 4d 36 00 08  	.word	0x0800364d
 8003620: 5b 36 00 08  	.word	0x0800365b
 8003624: 6b 36 00 08  	.word	0x0800366b
 8003628: 7f 36 00 08  	.word	0x0800367f
 800362c: 7f 36 00 08  	.word	0x0800367f
 8003630: 7f 36 00 08  	.word	0x0800367f
 8003634: 7f 36 00 08  	.word	0x0800367f
 8003638: 7f 36 00 08  	.word	0x0800367f
 800363c: 75 36 00 08  	.word	0x08003675

08003640 <$t>:
; 		reason = hard_fault(esf, recoverable);
 8003640: 6879         	ldr	r1, [r7, #0x4]
 8003642: 68f8         	ldr	r0, [r7, #0xc]
 8003644: f7ff feb6    	bl	0x80033b4 <hard_fault>  @ imm = #-0x294
 8003648: 6178         	str	r0, [r7, #0x14]
; 		break;
 800364a: e01d         	b	0x8003688 <fault_handle+0x94> @ imm = #0x3a
; 		reason = mem_manage_fault(esf, 0, recoverable);
 800364c: 687a         	ldr	r2, [r7, #0x4]
 800364e: 2100         	movs	r1, #0x0
 8003650: 68f8         	ldr	r0, [r7, #0xc]
 8003652: f7ff fa99    	bl	0x8002b88 <mem_manage_fault> @ imm = #-0xace
 8003656: 6178         	str	r0, [r7, #0x14]
; 		break;
 8003658: e016         	b	0x8003688 <fault_handle+0x94> @ imm = #0x2c
; 		reason = bus_fault(esf, 0, recoverable);
 800365a: 687a         	ldr	r2, [r7, #0x4]
 800365c: 2100         	movs	r1, #0x0
 800365e: 68f8         	ldr	r0, [r7, #0xc]
 8003660: f7ff fbd6    	bl	0x8002e10 <bus_fault>   @ imm = #-0x854
 8003664: 4603         	mov	r3, r0
 8003666: 617b         	str	r3, [r7, #0x14]
; 		break;
 8003668: e00e         	b	0x8003688 <fault_handle+0x94> @ imm = #0x1c
; 		reason = usage_fault(esf);
 800366a: 68f8         	ldr	r0, [r7, #0xc]
 800366c: f7ff fd20    	bl	0x80030b0 <usage_fault> @ imm = #-0x5c0
 8003670: 6178         	str	r0, [r7, #0x14]
; 		break;
 8003672: e009         	b	0x8003688 <fault_handle+0x94> @ imm = #0x12
; 		debug_monitor(esf, recoverable);
 8003674: 6879         	ldr	r1, [r7, #0x4]
 8003676: 68f8         	ldr	r0, [r7, #0xc]
 8003678: f7ff fe30    	bl	0x80032dc <debug_monitor> @ imm = #-0x3a0
; 		break;
 800367c: e004         	b	0x8003688 <fault_handle+0x94> @ imm = #0x8
; 		reserved_exception(esf, fault);
 800367e: 68b9         	ldr	r1, [r7, #0x8]
 8003680: 68f8         	ldr	r0, [r7, #0xc]
 8003682: f7ff ff81    	bl	0x8003588 <reserved_exception> @ imm = #-0xfe
; 		break;
 8003686: bf00         	nop
; 	if ((*recoverable) == false) {
 8003688: 687b         	ldr	r3, [r7, #0x4]
 800368a: 781b         	ldrb	r3, [r3]
 800368c: f083 0301    	eor	r3, r3, #0x1
 8003690: b2db         	uxtb	r3, r3
 8003692: 2b00         	cmp	r3, #0x0
 8003694: d003         	beq	0x800369e <fault_handle+0xaa> @ imm = #0x6
; 		fault_show(esf, fault);
 8003696: 68b9         	ldr	r1, [r7, #0x8]
 8003698: 68f8         	ldr	r0, [r7, #0xc]
 800369a: f00e f9e4    	bl	0x8011a66 <fault_show>  @ imm = #0xe3c8
; 	return reason;
 800369e: 697b         	ldr	r3, [r7, #0x14]
; }
 80036a0: 4618         	mov	r0, r3
 80036a2: 3718         	adds	r7, #0x18
 80036a4: 46bd         	mov	sp, r7
 80036a6: bd80         	pop	{r7, pc}

080036a8 <get_esf>:
; {
 80036a8: b580         	push	{r7, lr}
 80036aa: b08c         	sub	sp, #0x30
 80036ac: af04         	add	r7, sp, #0x10
 80036ae: 60f8         	str	r0, [r7, #0xc]
 80036b0: 60b9         	str	r1, [r7, #0x8]
 80036b2: 607a         	str	r2, [r7, #0x4]
 80036b4: 603b         	str	r3, [r7]
; 	bool alternative_state_exc = false;
 80036b6: 2300         	movs	r3, #0x0
 80036b8: 76fb         	strb	r3, [r7, #0x1b]
; 	struct arch_esf *ptr_esf = NULL;
 80036ba: 2300         	movs	r3, #0x0
 80036bc: 61fb         	str	r3, [r7, #0x1c]
; 	*nested_exc = false;
 80036be: 683b         	ldr	r3, [r7]
 80036c0: 2200         	movs	r2, #0x0
 80036c2: 701a         	strb	r2, [r3]
; 	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
 80036c4: 687b         	ldr	r3, [r7, #0x4]
 80036c6: f003 437f    	and	r3, r3, #0xff000000
 80036ca: f1b3 4f7f    	cmp.w	r3, #0xff000000
 80036ce: d001         	beq	0x80036d4 <get_esf+0x2c> @ imm = #0x2
; 		return NULL;
 80036d0: 2300         	movs	r3, #0x0
 80036d2: e039         	b	0x8003748 <get_esf+0xa0> @ imm = #0x72
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 80036d4: 687b         	ldr	r3, [r7, #0x4]
 80036d6: f003 0308    	and	r3, r3, #0x8
 80036da: 2b00         	cmp	r3, #0x0
 80036dc: d020         	beq	0x8003720 <get_esf+0x78> @ imm = #0x40
; 		(!(exc_return & EXC_RETURN_SPSEL_PROCESS))) {
 80036de: 687b         	ldr	r3, [r7, #0x4]
 80036e0: f003 0304    	and	r3, r3, #0x4
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 80036e4: 2b00         	cmp	r3, #0x0
 80036e6: d11b         	bne	0x8003720 <get_esf+0x78> @ imm = #0x36
; 		PR_EXC("SPSEL in thread mode does not indicate PSP");
 80036e8: 2303         	movs	r3, #0x3
 80036ea: 2b00         	cmp	r3, #0x0
 80036ec: d016         	beq	0x800371c <get_esf+0x74> @ imm = #0x2c
 80036ee: 2301         	movs	r3, #0x1
 80036f0: 76bb         	strb	r3, [r7, #0x1a]
 80036f2: 7ebb         	ldrb	r3, [r7, #0x1a]
 80036f4: f083 0301    	eor	r3, r3, #0x1
 80036f8: b2db         	uxtb	r3, r3
 80036fa: 2b00         	cmp	r3, #0x0
 80036fc: d10e         	bne	0x800371c <get_esf+0x74> @ imm = #0x1c
 80036fe: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8003750 <get_esf+0xa8>
 8003700: 6819         	ldr	r1, [r3]
 8003702: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8003754 <get_esf+0xac>
 8003704: 9302         	str	r3, [sp, #0x8]
 8003706: 2300         	movs	r3, #0x0
 8003708: 9301         	str	r3, [sp, #0x4]
 800370a: 2300         	movs	r3, #0x0
 800370c: 9300         	str	r3, [sp]
 800370e: 2300         	movs	r3, #0x0
 8003710: 2201         	movs	r2, #0x1
 8003712: 2000         	movs	r0, #0x0
 8003714: f00e f989    	bl	0x8011a2a <z_log_msg_runtime_create> @ imm = #0xe312
 8003718: 2300         	movs	r3, #0x0
 800371a: 617b         	str	r3, [r7, #0x14]
; 		return NULL;
 800371c: 2300         	movs	r3, #0x0
 800371e: e013         	b	0x8003748 <get_esf+0xa0> @ imm = #0x26
; 	if (!alternative_state_exc) {
 8003720: 7efb         	ldrb	r3, [r7, #0x1b]
 8003722: f083 0301    	eor	r3, r3, #0x1
 8003726: b2db         	uxtb	r3, r3
 8003728: 2b00         	cmp	r3, #0x0
 800372a: d00c         	beq	0x8003746 <get_esf+0x9e> @ imm = #0x18
; 		if (exc_return & EXC_RETURN_MODE_THREAD) {
 800372c: 687b         	ldr	r3, [r7, #0x4]
 800372e: f003 0308    	and	r3, r3, #0x8
 8003732: 2b00         	cmp	r3, #0x0
 8003734: d002         	beq	0x800373c <get_esf+0x94> @ imm = #0x4
; 			ptr_esf =  (struct arch_esf *)psp;
 8003736: 68bb         	ldr	r3, [r7, #0x8]
 8003738: 61fb         	str	r3, [r7, #0x1c]
 800373a: e004         	b	0x8003746 <get_esf+0x9e> @ imm = #0x8
; 			ptr_esf = (struct arch_esf *)msp;
 800373c: 68fb         	ldr	r3, [r7, #0xc]
 800373e: 61fb         	str	r3, [r7, #0x1c]
; 			*nested_exc = true;
 8003740: 683b         	ldr	r3, [r7]
 8003742: 2201         	movs	r2, #0x1
 8003744: 701a         	strb	r2, [r3]
; 	return ptr_esf;
 8003746: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8003748: 4618         	mov	r0, r3
 800374a: 3720         	adds	r7, #0x20
 800374c: 46bd         	mov	sp, r7
 800374e: bd80         	pop	{r7, pc}

08003750 <$d>:
 8003750: e0 02 00 20  	.word	0x200002e0
 8003754: 98 9f 01 08  	.word	0x08019f98

08003758 <z_arm_fault>:
; {
 8003758: b580         	push	{r7, lr}
 800375a: b094         	sub	sp, #0x50
 800375c: af00         	add	r7, sp, #0x0
 800375e: 60f8         	str	r0, [r7, #0xc]
 8003760: 60b9         	str	r1, [r7, #0x8]
 8003762: 607a         	str	r2, [r7, #0x4]
 8003764: 603b         	str	r3, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8003766: 2300         	movs	r3, #0x0
 8003768: 64fb         	str	r3, [r7, #0x4c]
; 	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 800376a: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8003810 <z_arm_fault+0xb8>
 800376c: 685b         	ldr	r3, [r3, #0x4]
 800376e: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8003772: 64bb         	str	r3, [r7, #0x48]
 8003774: 2300         	movs	r3, #0x0
 8003776: 63bb         	str	r3, [r7, #0x38]
 8003778: 6bbb         	ldr	r3, [r7, #0x38]
 800377a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800377c: 6b7b         	ldr	r3, [r7, #0x34]
 800377e: f383 8811    	msr	basepri, r3
; }
 8003782: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8003784: f3bf 8f6f    	isb	sy
; }
 8003788: bf00         	nop
; }
 800378a: bf00         	nop
; 	 esf = get_esf(msp, psp, exc_return, &nested_exc);
 800378c: f107 0332    	add.w	r3, r7, #0x32
 8003790: 687a         	ldr	r2, [r7, #0x4]
 8003792: 68b9         	ldr	r1, [r7, #0x8]
 8003794: 68f8         	ldr	r0, [r7, #0xc]
 8003796: f7ff ff87    	bl	0x80036a8 <get_esf>     @ imm = #-0xf2
 800379a: 6478         	str	r0, [r7, #0x44]
 800379c: 6c7b         	ldr	r3, [r7, #0x44]
 800379e: 643b         	str	r3, [r7, #0x40]
 80037a0: 687b         	ldr	r3, [r7, #0x4]
 80037a2: 63fb         	str	r3, [r7, #0x3c]
; }
 80037a4: bf00         	nop
; 	reason = fault_handle(esf, fault, &recoverable);
 80037a6: f107 0333    	add.w	r3, r7, #0x33
 80037aa: 461a         	mov	r2, r3
 80037ac: 6cb9         	ldr	r1, [r7, #0x48]
 80037ae: 6c78         	ldr	r0, [r7, #0x44]
 80037b0: f7ff ff20    	bl	0x80035f4 <fault_handle> @ imm = #-0x1c0
 80037b4: 64f8         	str	r0, [r7, #0x4c]
; 	if (recoverable) {
 80037b6: f897 3033    	ldrb.w	r3, [r7, #0x33]
 80037ba: 2b00         	cmp	r3, #0x0
 80037bc: d123         	bne	0x8003806 <z_arm_fault+0xae> @ imm = #0x46
; 	memcpy(&esf_copy, esf, sizeof(struct arch_esf));
 80037be: f107 0310    	add.w	r3, r7, #0x10
 80037c2: 2220         	movs	r2, #0x20
 80037c4: 6c79         	ldr	r1, [r7, #0x44]
 80037c6: 4618         	mov	r0, r3
 80037c8: f015 faaf    	bl	0x8018d2a <memcpy>      @ imm = #0x1555e
; 	if (nested_exc) {
 80037cc: f897 3032    	ldrb.w	r3, [r7, #0x32]
 80037d0: 2b00         	cmp	r3, #0x0
 80037d2: d00b         	beq	0x80037ec <z_arm_fault+0x94> @ imm = #0x16
; 		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
 80037d4: 6afb         	ldr	r3, [r7, #0x2c]
 80037d6: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 80037da: 2b00         	cmp	r3, #0x0
 80037dc: d10c         	bne	0x80037f8 <z_arm_fault+0xa0> @ imm = #0x18
; 			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
 80037de: 6afb         	ldr	r3, [r7, #0x2c]
 80037e0: ea6f 2353    	mvn.w	r3, r3, lsr #9
 80037e4: ea6f 2343    	mvn.w	r3, r3, lsl #9
 80037e8: 62fb         	str	r3, [r7, #0x2c]
 80037ea: e005         	b	0x80037f8 <z_arm_fault+0xa0> @ imm = #0xa
; 		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 80037ec: 6afb         	ldr	r3, [r7, #0x2c]
 80037ee: f423 73ff    	bic	r3, r3, #0x1fe
 80037f2: f023 0301    	bic	r3, r3, #0x1
 80037f6: 62fb         	str	r3, [r7, #0x2c]
; 	z_arm_fatal_error(reason, &esf_copy);
 80037f8: f107 0310    	add.w	r3, r7, #0x10
 80037fc: 4619         	mov	r1, r3
 80037fe: 6cf8         	ldr	r0, [r7, #0x4c]
 8003800: f7ff f92e    	bl	0x8002a60 <z_arm_fatal_error> @ imm = #-0xda4
 8003804: e000         	b	0x8003808 <z_arm_fault+0xb0> @ imm = #0x0
; 		return;
 8003806: bf00         	nop
; }
 8003808: 3750         	adds	r7, #0x50
 800380a: 46bd         	mov	sp, r7
 800380c: bd80         	pop	{r7, pc}
 800380e: bf00         	nop

08003810 <$d>:
 8003810: 00 ed 00 e0  	.word	0xe000ed00

08003814 <z_arm_fault_init>:
; {
 8003814: b480         	push	{r7}
 8003816: af00         	add	r7, sp, #0x0
; 	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 8003818: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8003838 <z_arm_fault_init+0x24>
 800381a: 695b         	ldr	r3, [r3, #0x14]
 800381c: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8003838 <z_arm_fault_init+0x24>
 800381e: f043 0310    	orr	r3, r3, #0x10
 8003822: 6153         	str	r3, [r2, #0x14]
; 	SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk;
 8003824: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8003838 <z_arm_fault_init+0x24>
 8003826: 695b         	ldr	r3, [r3, #0x14]
 8003828: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8003838 <z_arm_fault_init+0x24>
 800382a: f023 0308    	bic	r3, r3, #0x8
 800382e: 6153         	str	r3, [r2, #0x14]
; }
 8003830: bf00         	nop
 8003832: 46bd         	mov	sp, r7
 8003834: bc80         	pop	{r7}
 8003836: 4770         	bx	lr

08003838 <$d>:
 8003838: 00 ed 00 e0  	.word	0xe000ed00

0800383c <z_arm_usage_fault>:
; 	mrs r0, MSP
 800383c: f3ef 8008    	mrs	r0, msp
; 	mrs r1, PSP
 8003840: f3ef 8109    	mrs	r1, psp
; 	push {r0, lr}
 8003844: b501         	push	{r0, lr}
; 	mov r2, lr /* EXC_RETURN */
 8003846: 4672         	mov	r2, lr
; 	bl z_arm_fault
 8003848: f7ff ff86    	bl	0x8003758 <z_arm_fault> @ imm = #-0xf4
; 	pop {r0, pc}
 800384c: bd01         	pop	{r0, pc}
 800384e: bf00         	nop

08003850 <z_arm_reset>:
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8003850: 2010         	movs	r0, #0x10
;     msr BASEPRI, r0
 8003852: f380 8811    	msr	basepri, r0
;     ldr r0, =z_interrupt_stacks
 8003856: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8003884 <z_arm_reset+0x34>
;     ldr r1, =0xaa
 8003858: f04f 01aa    	mov.w	r1, #0xaa
;     ldr r2, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 800385c: f44f 6200    	mov.w	r2, #0x800
;     bl z_early_memset
 8003860: f013 fb8c    	bl	0x8016f7c <z_early_memset> @ imm = #0x13718
;     ldr r0, =z_interrupt_stacks
 8003864: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8003884 <z_arm_reset+0x34>
;     ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 8003866: f44f 6100    	mov.w	r1, #0x800
;     adds r0, r0, r1
 800386a: 1840         	adds	r0, r0, r1
;     msr PSP, r0
 800386c: f380 8809    	msr	psp, r0
;     mrs r0, CONTROL
 8003870: f3ef 8014    	mrs	r0, control
;     movs r1, #2
 8003874: 2102         	movs	r1, #0x2
;     orrs r0, r1 /* CONTROL_SPSEL_Msk */
 8003876: 4308         	orrs	r0, r1
;     msr CONTROL, r0
 8003878: f380 8814    	msr	control, r0
;     isb
 800387c: f3bf 8f6f    	isb	sy
;     bl z_prep_c
 8003880: f00e f933    	bl	0x8011aea <z_prep_c>    @ imm = #0xe266

08003884 <$d>:
 8003884: 40 36 00 20  	.word	0x20003640

08003888 <z_impl_k_thread_abort>:
; {
 8003888: b580         	push	{r7, lr}
 800388a: b084         	sub	sp, #0x10
 800388c: af00         	add	r7, sp, #0x0
 800388e: 6078         	str	r0, [r7, #0x4]
; 	if (_current == thread) {
 8003890: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80038d8 <z_impl_k_thread_abort+0x50>
 8003892: 689b         	ldr	r3, [r3, #0x8]
 8003894: 687a         	ldr	r2, [r7, #0x4]
 8003896: 429a         	cmp	r2, r3
 8003898: d116         	bne	0x80038c8 <z_impl_k_thread_abort+0x40> @ imm = #0x2c
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800389a: f3ef 8305    	mrs	r3, ipsr
 800389e: 60fb         	str	r3, [r7, #0xc]
;   return(result);
 80038a0: 68fb         	ldr	r3, [r7, #0xc]
; 	return (__get_IPSR()) ? (true) : (false);
 80038a2: 2b00         	cmp	r3, #0x0
 80038a4: bf14         	ite	ne
 80038a6: 2301         	movne	r3, #0x1
 80038a8: 2300         	moveq	r3, #0x0
 80038aa: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 80038ac: 2b00         	cmp	r3, #0x0
 80038ae: d00b         	beq	0x80038c8 <z_impl_k_thread_abort+0x40> @ imm = #0x16
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 80038b0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80038dc <z_impl_k_thread_abort+0x54>
 80038b2: 685b         	ldr	r3, [r3, #0x4]
 80038b4: 4a09         	ldr	r2, [pc, #0x24]         @ 0x80038dc <z_impl_k_thread_abort+0x54>
 80038b6: f043 5380    	orr	r3, r3, #0x10000000
 80038ba: 6053         	str	r3, [r2, #0x4]
; 			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
 80038bc: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80038dc <z_impl_k_thread_abort+0x54>
 80038be: 6a5b         	ldr	r3, [r3, #0x24]
 80038c0: 4a06         	ldr	r2, [pc, #0x18]         @ 0x80038dc <z_impl_k_thread_abort+0x54>
 80038c2: f423 4300    	bic	r3, r3, #0x8000
 80038c6: 6253         	str	r3, [r2, #0x24]
; 	z_thread_abort(thread);
 80038c8: 6878         	ldr	r0, [r7, #0x4]
 80038ca: f00a fcff    	bl	0x800e2cc <z_thread_abort> @ imm = #0xa9fe
; }
 80038ce: bf00         	nop
 80038d0: 3710         	adds	r7, #0x10
 80038d2: 46bd         	mov	sp, r7
 80038d4: bd80         	pop	{r7, pc}
 80038d6: bf00         	nop

080038d8 <$d>:
 80038d8: c8 06 00 20  	.word	0x200006c8
 80038dc: 00 ed 00 e0  	.word	0xe000ed00

080038e0 <arch_swap>:
; {
 80038e0: b480         	push	{r7}
 80038e2: b085         	sub	sp, #0x14
 80038e4: af00         	add	r7, sp, #0x0
 80038e6: 6078         	str	r0, [r7, #0x4]
; 	_current->arch.basepri = key;
 80038e8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8003934 <arch_swap+0x54>
 80038ea: 689b         	ldr	r3, [r3, #0x8]
 80038ec: 687a         	ldr	r2, [r7, #0x4]
 80038ee: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; 	_current->arch.swap_return_value = -EAGAIN;
 80038f2: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8003934 <arch_swap+0x54>
 80038f4: 689b         	ldr	r3, [r3, #0x8]
 80038f6: f06f 020a    	mvn	r2, #0xa
 80038fa: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; 	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 80038fe: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8003938 <arch_swap+0x58>
 8003900: 685b         	ldr	r3, [r3, #0x4]
 8003902: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8003938 <arch_swap+0x58>
 8003904: f043 5380    	orr	r3, r3, #0x10000000
 8003908: 6053         	str	r3, [r2, #0x4]
 800390a: 2300         	movs	r3, #0x0
 800390c: 60fb         	str	r3, [r7, #0xc]
 800390e: 68fb         	ldr	r3, [r7, #0xc]
 8003910: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003912: 68bb         	ldr	r3, [r7, #0x8]
 8003914: f383 8811    	msr	basepri, r3
; }
 8003918: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800391a: f3bf 8f6f    	isb	sy
; }
 800391e: bf00         	nop
; }
 8003920: bf00         	nop
; 	return _current->arch.swap_return_value;
 8003922: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8003934 <arch_swap+0x54>
 8003924: 689b         	ldr	r3, [r3, #0x8]
 8003926: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
; }
 800392a: 4618         	mov	r0, r3
 800392c: 3714         	adds	r7, #0x14
 800392e: 46bd         	mov	sp, r7
 8003930: bc80         	pop	{r7}
 8003932: 4770         	bx	lr

08003934 <$d>:
 8003934: c8 06 00 20  	.word	0x200006c8
 8003938: 00 ed 00 e0  	.word	0xe000ed00

0800393c <z_arm_pendsv>:
;     push {r0, lr}
 800393c: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_out
 800393e: f014 fbe8    	bl	0x8018112 <z_thread_mark_switched_out> @ imm = #0x147d0
;     pop {r0, lr}
 8003942: e8bd 4001    	pop.w	{r0, lr}
;     ldr r1, =_kernel
 8003946: 4916         	ldr	r1, [pc, #0x58]         @ 0x80039a0 <z_arm_pendsv+0x64>
;     ldr r2, [r1, #_kernel_offset_to_current]
 8003948: 688a         	ldr	r2, [r1, #0x8]
;     ldr r0, =_thread_offset_to_callee_saved
 800394a: f04f 0040    	mov.w	r0, #0x40
;     add r0, r2
 800394e: 4410         	add	r0, r2
;     mrs ip, PSP
 8003950: f3ef 8c09    	mrs	r12, psp
;     stmia r0, {r4-r11, ip}
 8003954: e880 1ff0    	stm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8003958: 2010         	movs	r0, #0x10
;     msr BASEPRI_MAX, r0
 800395a: f380 8812    	msr	basepri_max, r0
;     isb /* Make the effect of disabling interrupts be realized immediately */
 800395e: f3bf 8f6f    	isb	sy
;     ldr r7, =_SCS_ICSR
 8003962: 4f10         	ldr	r7, [pc, #0x40]         @ 0x80039a4 <z_arm_pendsv+0x68>
;     ldr r6, =_SCS_ICSR_UNPENDSV
 8003964: f04f 6600    	mov.w	r6, #0x8000000
;     ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
 8003968: 69ca         	ldr	r2, [r1, #0x1c]
;     str r2, [r1, #_kernel_offset_to_current]
 800396a: 608a         	str	r2, [r1, #0x8]
;     str r6, [r7, #0]
 800396c: 603e         	str	r6, [r7]
;     ldr r4, =_thread_offset_to_tls
 800396e: f04f 04c4    	mov.w	r4, #0xc4
;     adds r4, r2, r4
 8003972: 1914         	adds	r4, r2, r4
;     ldr r0, [r4]
 8003974: 6820         	ldr	r0, [r4]
;     ldr r4, =z_arm_tls_ptr
 8003976: 4c0c         	ldr	r4, [pc, #0x30]         @ 0x80039a8 <z_arm_pendsv+0x6c>
;     str r0, [r4]
 8003978: 6020         	str	r0, [r4]
;     ldr r0, [r2, #_thread_offset_to_basepri]
 800397a: f8d2 00c8    	ldr.w	r0, [r2, #0xc8]
;     movs r3, #0
 800397e: 2300         	movs	r3, #0x0
;     str r3, [r2, #_thread_offset_to_basepri]
 8003980: f8c2 30c8    	str.w	r3, [r2, #0xc8]
;     msr BASEPRI, r0
 8003984: f380 8811    	msr	basepri, r0
;     add r0, r2, #_thread_offset_to_callee_saved
 8003988: f102 0040    	add.w	r0, r2, #0x40
;     ldmia r0, {r4-r11, ip}
 800398c: e890 1ff0    	ldm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     msr PSP, ip
 8003990: f38c 8809    	msr	psp, r12
;     push {r0, lr}
 8003994: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_in
 8003996: f009 fa51    	bl	0x800ce3c <z_thread_mark_switched_in> @ imm = #0x94a2
;     pop {r0, lr}
 800399a: e8bd 4001    	pop.w	{r0, lr}
;     bx lr
 800399e: 4770         	bx	lr

080039a0 <$d>:
 80039a0: c8 06 00 20  	.word	0x200006c8
 80039a4: 04 ed 00 e0  	.word	0xe000ed04
 80039a8: ec 0a 00 20  	.word	0x20000aec

080039ac <z_arm_svc>:
;     tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
 80039ac: f01e 0f04    	tst.w	lr, #0x4
;     ite eq  /* if zero (equal), came from handler mode */
 80039b0: bf0c         	ite	eq
;         mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 80039b2: f3ef 8008    	mrseq	r0, msp
;         mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 80039b6: f3ef 8009    	mrsne	r0, psp
;     ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 80039ba: 6981         	ldr	r1, [r0, #0x18]
;     ldrb r1, [r1, #-2]
 80039bc: f811 1c02    	ldrb	r1, [r1, #-2]
;     cmp r1, #2
 80039c0: 2902         	cmp	r1, #0x2
;     beq _oops
 80039c2: d0ff         	beq	0x80039c4 <_oops>       @ imm = #-0x2

080039c4 <_oops>:
;     push {r0, lr}
 80039c4: b501         	push	{r0, lr}
;     mov r2, lr /* EXC_RETURN */
 80039c6: 4672         	mov	r2, lr
;     bl z_do_kernel_oops
 80039c8: f00d fffb    	bl	0x80119c2 <z_do_kernel_oops> @ imm = #0xdff6
;     pop {r0, pc}
 80039cc: bd01         	pop	{r0, pc}
 80039ce: bf00         	nop

080039d0 <__NVIC_EnableIRQ>:
; {
 80039d0: b480         	push	{r7}
 80039d2: b083         	sub	sp, #0xc
 80039d4: af00         	add	r7, sp, #0x0
 80039d6: 4603         	mov	r3, r0
 80039d8: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 80039da: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80039de: 2b00         	cmp	r3, #0x0
 80039e0: db0b         	blt	0x80039fa <__NVIC_EnableIRQ+0x2a> @ imm = #0x16
;     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80039e2: 79fb         	ldrb	r3, [r7, #0x7]
 80039e4: f003 021f    	and	r2, r3, #0x1f
 80039e8: 4906         	ldr	r1, [pc, #0x18]         @ 0x8003a04 <__NVIC_EnableIRQ+0x34>
 80039ea: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80039ee: 095b         	lsrs	r3, r3, #0x5
 80039f0: 2001         	movs	r0, #0x1
 80039f2: fa00 f202    	lsl.w	r2, r0, r2
 80039f6: f841 2023    	str.w	r2, [r1, r3, lsl #2]
; }
 80039fa: bf00         	nop
 80039fc: 370c         	adds	r7, #0xc
 80039fe: 46bd         	mov	sp, r7
 8003a00: bc80         	pop	{r7}
 8003a02: 4770         	bx	lr

08003a04 <$d>:
 8003a04: 00 e1 00 e0  	.word	0xe000e100

08003a08 <__NVIC_SetPriority>:
; {
 8003a08: b480         	push	{r7}
 8003a0a: b083         	sub	sp, #0xc
 8003a0c: af00         	add	r7, sp, #0x0
 8003a0e: 4603         	mov	r3, r0
 8003a10: 6039         	str	r1, [r7]
 8003a12: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8003a14: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8003a18: 2b00         	cmp	r3, #0x0
 8003a1a: db0a         	blt	0x8003a32 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003a1c: 683b         	ldr	r3, [r7]
 8003a1e: b2da         	uxtb	r2, r3
 8003a20: 490c         	ldr	r1, [pc, #0x30]         @ 0x8003a54 <__NVIC_SetPriority+0x4c>
 8003a22: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8003a26: 0112         	lsls	r2, r2, #0x4
 8003a28: b2d2         	uxtb	r2, r2
 8003a2a: 440b         	add	r3, r1
 8003a2c: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8003a30: e00a         	b	0x8003a48 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003a32: 683b         	ldr	r3, [r7]
 8003a34: b2da         	uxtb	r2, r3
 8003a36: 4908         	ldr	r1, [pc, #0x20]         @ 0x8003a58 <__NVIC_SetPriority+0x50>
 8003a38: 79fb         	ldrb	r3, [r7, #0x7]
 8003a3a: f003 030f    	and	r3, r3, #0xf
 8003a3e: 3b04         	subs	r3, #0x4
 8003a40: 0112         	lsls	r2, r2, #0x4
 8003a42: b2d2         	uxtb	r2, r2
 8003a44: 440b         	add	r3, r1
 8003a46: 761a         	strb	r2, [r3, #0x18]
; }
 8003a48: bf00         	nop
 8003a4a: 370c         	adds	r7, #0xc
 8003a4c: 46bd         	mov	sp, r7
 8003a4e: bc80         	pop	{r7}
 8003a50: 4770         	bx	lr
 8003a52: bf00         	nop

08003a54 <$d>:
 8003a54: 00 e1 00 e0  	.word	0xe000e100
 8003a58: 00 ed 00 e0  	.word	0xe000ed00

08003a5c <relocate_vector_table>:
; {
 8003a5c: b480         	push	{r7}
 8003a5e: af00         	add	r7, sp, #0x0
; 	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 8003a60: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8003a88 <relocate_vector_table+0x2c>
 8003a62: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8003a8c <relocate_vector_table+0x30>
 8003a64: f023 037f    	bic	r3, r3, #0x7f
 8003a68: 6093         	str	r3, [r2, #0x8]
;   __ASM volatile ("dsb 0xF":::"memory");
 8003a6a: f3bf 8f4f    	dsb	sy
; }
 8003a6e: bf00         	nop
; }
 8003a70: bf00         	nop
; }
 8003a72: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8003a74: f3bf 8f6f    	isb	sy
; }
 8003a78: bf00         	nop
; }
 8003a7a: bf00         	nop
; }
 8003a7c: bf00         	nop
; }
 8003a7e: bf00         	nop
 8003a80: 46bd         	mov	sp, r7
 8003a82: bc80         	pop	{r7}
 8003a84: 4770         	bx	lr
 8003a86: bf00         	nop

08003a88 <$d>:
 8003a88: 00 00 00 08  	.word	0x08000000
 8003a8c: 00 ed 00 e0  	.word	0xe000ed00

08003a90 <z_arm_floating_point_init>:
; {
 8003a90: b480         	push	{r7}
 8003a92: b083         	sub	sp, #0xc
 8003a94: af00         	add	r7, sp, #0x0
; 	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
 8003a96: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8003acc <z_arm_floating_point_init+0x3c>
 8003a98: f8d3 3088    	ldr.w	r3, [r3, #0x88]
 8003a9c: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8003acc <z_arm_floating_point_init+0x3c>
 8003a9e: f423 0370    	bic	r3, r3, #0xf00000
 8003aa2: f8c2 3088    	str.w	r3, [r2, #0x88]
;   __ASM volatile ("MRS %0, control" : "=r" (result) );
 8003aa6: f3ef 8314    	mrs	r3, control
 8003aaa: 603b         	str	r3, [r7]
;   return(result);
 8003aac: 683b         	ldr	r3, [r7]
; 	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
 8003aae: f023 0304    	bic	r3, r3, #0x4
 8003ab2: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 8003ab4: 687b         	ldr	r3, [r7, #0x4]
 8003ab6: f383 8814    	msr	control, r3
;   __ASM volatile ("isb 0xF":::"memory");
 8003aba: f3bf 8f6f    	isb	sy
; }
 8003abe: bf00         	nop
; }
 8003ac0: bf00         	nop
; }
 8003ac2: bf00         	nop
 8003ac4: 370c         	adds	r7, #0xc
 8003ac6: 46bd         	mov	sp, r7
 8003ac8: bc80         	pop	{r7}
 8003aca: 4770         	bx	lr

08003acc <$d>:
 8003acc: 00 ed 00 e0  	.word	0xe000ed00

08003ad0 <arch_new_thread>:
; {
 8003ad0: b480         	push	{r7}
 8003ad2: b087         	sub	sp, #0x1c
 8003ad4: af00         	add	r7, sp, #0x0
 8003ad6: 60f8         	str	r0, [r7, #0xc]
 8003ad8: 60b9         	str	r1, [r7, #0x8]
 8003ada: 607a         	str	r2, [r7, #0x4]
 8003adc: 603b         	str	r3, [r7]
; 	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
 8003ade: 687b         	ldr	r3, [r7, #0x4]
 8003ae0: 3b20         	subs	r3, #0x20
 8003ae2: 617b         	str	r3, [r7, #0x14]
; 	iframe->pc = (uint32_t)z_thread_entry;
 8003ae4: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8003b30 <arch_new_thread+0x60>
 8003ae6: 697b         	ldr	r3, [r7, #0x14]
 8003ae8: 619a         	str	r2, [r3, #0x18]
; 	iframe->pc &= 0xfffffffe;
 8003aea: 697b         	ldr	r3, [r7, #0x14]
 8003aec: 699b         	ldr	r3, [r3, #0x18]
 8003aee: f023 0201    	bic	r2, r3, #0x1
 8003af2: 697b         	ldr	r3, [r7, #0x14]
 8003af4: 619a         	str	r2, [r3, #0x18]
; 	iframe->a1 = (uint32_t)entry;
 8003af6: 683a         	ldr	r2, [r7]
 8003af8: 697b         	ldr	r3, [r7, #0x14]
 8003afa: 601a         	str	r2, [r3]
; 	iframe->a2 = (uint32_t)p1;
 8003afc: 6a3a         	ldr	r2, [r7, #0x20]
 8003afe: 697b         	ldr	r3, [r7, #0x14]
 8003b00: 605a         	str	r2, [r3, #0x4]
; 	iframe->a3 = (uint32_t)p2;
 8003b02: 6a7a         	ldr	r2, [r7, #0x24]
 8003b04: 697b         	ldr	r3, [r7, #0x14]
 8003b06: 609a         	str	r2, [r3, #0x8]
; 	iframe->a4 = (uint32_t)p3;
 8003b08: 6aba         	ldr	r2, [r7, #0x28]
 8003b0a: 697b         	ldr	r3, [r7, #0x14]
 8003b0c: 60da         	str	r2, [r3, #0xc]
; 	iframe->xpsr =
 8003b0e: 697b         	ldr	r3, [r7, #0x14]
 8003b10: f04f 7280    	mov.w	r2, #0x1000000
 8003b14: 61da         	str	r2, [r3, #0x1c]
; 	thread->callee_saved.psp = (uint32_t)iframe;
 8003b16: 697a         	ldr	r2, [r7, #0x14]
 8003b18: 68fb         	ldr	r3, [r7, #0xc]
 8003b1a: 661a         	str	r2, [r3, #0x60]
; 	thread->arch.basepri = 0;
 8003b1c: 68fb         	ldr	r3, [r7, #0xc]
 8003b1e: 2200         	movs	r2, #0x0
 8003b20: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; }
 8003b24: bf00         	nop
 8003b26: 371c         	adds	r7, #0x1c
 8003b28: 46bd         	mov	sp, r7
 8003b2a: bc80         	pop	{r7}
 8003b2c: 4770         	bx	lr
 8003b2e: bf00         	nop

08003b30 <$d>:
 8003b30: 19 1c 00 08  	.word	0x08001c19

08003b34 <arch_switch_to_main_thread>:
; {
 8003b34: b5f0         	push	{r4, r5, r6, r7, lr}
 8003b36: b085         	sub	sp, #0x14
 8003b38: af00         	add	r7, sp, #0x0
 8003b3a: 60f8         	str	r0, [r7, #0xc]
 8003b3c: 60b9         	str	r1, [r7, #0x8]
 8003b3e: 607a         	str	r2, [r7, #0x4]
; 	z_arm_prepare_switch_to_main();
 8003b40: f00d ffe1    	bl	0x8011b06 <z_arm_prepare_switch_to_main> @ imm = #0xdfc2
; 	_current = main_thread;
 8003b44: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8003b7c <arch_switch_to_main_thread+0x48>
 8003b46: 68fb         	ldr	r3, [r7, #0xc]
 8003b48: 6093         	str	r3, [r2, #0x8]
; 	z_arm_tls_ptr = main_thread->tls;
 8003b4a: 68fb         	ldr	r3, [r7, #0xc]
 8003b4c: f8d3 30c4    	ldr.w	r3, [r3, #0xc4]
 8003b50: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8003b80 <arch_switch_to_main_thread+0x4c>
 8003b52: 6013         	str	r3, [r2]
; 	z_thread_mark_switched_in();
 8003b54: f009 f972    	bl	0x800ce3c <z_thread_mark_switched_in> @ imm = #0x92e4
; 	__asm__ volatile (
 8003b58: 687d         	ldr	r5, [r7, #0x4]
 8003b5a: 68be         	ldr	r6, [r7, #0x8]
 8003b5c: 462c         	mov	r4, r5
 8003b5e: f386 8809    	msr	psp, r6
 8003b62: f04f 0000    	mov.w	r0, #0x0
 8003b66: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8003b84 <arch_switch_to_main_thread+0x50>
 8003b68: 4798         	blx	r3
 8003b6a: 4620         	mov	r0, r4
 8003b6c: f04f 0100    	mov.w	r1, #0x0
 8003b70: f04f 0200    	mov.w	r2, #0x0
 8003b74: f04f 0300    	mov.w	r3, #0x0
 8003b78: 4c03         	ldr	r4, [pc, #0xc]          @ 0x8003b88 <arch_switch_to_main_thread+0x54>
 8003b7a: 4720         	bx	r4

08003b7c <$d>:
 8003b7c: c8 06 00 20  	.word	0x200006c8
 8003b80: ec 0a 00 20  	.word	0x20000aec

08003b84 <$d>:
 8003b84: 13 1b 01 08  	.word	0x08011b13
 8003b88: 19 1c 00 08  	.word	0x08001c19

08003b8c <z_arm_cpu_idle_init>:
; {
 8003b8c: b480         	push	{r7}
 8003b8e: af00         	add	r7, sp, #0x0
; 	SCB->SCR = SCB_SCR_SEVONPEND_Msk;
 8003b90: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8003ba0 <z_arm_cpu_idle_init+0x14>
 8003b92: 2210         	movs	r2, #0x10
 8003b94: 611a         	str	r2, [r3, #0x10]
; }
 8003b96: bf00         	nop
 8003b98: 46bd         	mov	sp, r7
 8003b9a: bc80         	pop	{r7}
 8003b9c: 4770         	bx	lr
 8003b9e: bf00         	nop

08003ba0 <$d>:
 8003ba0: 00 ed 00 e0  	.word	0xe000ed00

08003ba4 <__NVIC_SetPriority>:
; {
 8003ba4: b480         	push	{r7}
 8003ba6: b083         	sub	sp, #0xc
 8003ba8: af00         	add	r7, sp, #0x0
 8003baa: 4603         	mov	r3, r0
 8003bac: 6039         	str	r1, [r7]
 8003bae: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8003bb0: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8003bb4: 2b00         	cmp	r3, #0x0
 8003bb6: db0a         	blt	0x8003bce <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003bb8: 683b         	ldr	r3, [r7]
 8003bba: b2da         	uxtb	r2, r3
 8003bbc: 490c         	ldr	r1, [pc, #0x30]         @ 0x8003bf0 <__NVIC_SetPriority+0x4c>
 8003bbe: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8003bc2: 0112         	lsls	r2, r2, #0x4
 8003bc4: b2d2         	uxtb	r2, r2
 8003bc6: 440b         	add	r3, r1
 8003bc8: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8003bcc: e00a         	b	0x8003be4 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003bce: 683b         	ldr	r3, [r7]
 8003bd0: b2da         	uxtb	r2, r3
 8003bd2: 4908         	ldr	r1, [pc, #0x20]         @ 0x8003bf4 <__NVIC_SetPriority+0x50>
 8003bd4: 79fb         	ldrb	r3, [r7, #0x7]
 8003bd6: f003 030f    	and	r3, r3, #0xf
 8003bda: 3b04         	subs	r3, #0x4
 8003bdc: 0112         	lsls	r2, r2, #0x4
 8003bde: b2d2         	uxtb	r2, r2
 8003be0: 440b         	add	r3, r1
 8003be2: 761a         	strb	r2, [r3, #0x18]
; }
 8003be4: bf00         	nop
 8003be6: 370c         	adds	r7, #0xc
 8003be8: 46bd         	mov	sp, r7
 8003bea: bc80         	pop	{r7}
 8003bec: 4770         	bx	lr
 8003bee: bf00         	nop

08003bf0 <$d>:
 8003bf0: 00 e1 00 e0  	.word	0xe000e100
 8003bf4: 00 ed 00 e0  	.word	0xe000ed00

08003bf8 <_isr_wrapper>:
; {
 8003bf8: b580         	push	{r7, lr}
 8003bfa: b084         	sub	sp, #0x10
 8003bfc: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8003bfe: f3ef 8305    	mrs	r3, ipsr
 8003c02: 607b         	str	r3, [r7, #0x4]
;   return(result);
 8003c04: 687b         	ldr	r3, [r7, #0x4]
; 	int32_t irq_number = __get_IPSR();
 8003c06: 60fb         	str	r3, [r7, #0xc]
; 	irq_number -= 16;
 8003c08: 68fb         	ldr	r3, [r7, #0xc]
 8003c0a: 3b10         	subs	r3, #0x10
 8003c0c: 60fb         	str	r3, [r7, #0xc]
; 	struct _isr_table_entry *entry = &_sw_isr_table[irq_number];
 8003c0e: 68fb         	ldr	r3, [r7, #0xc]
 8003c10: 00db         	lsls	r3, r3, #0x3
 8003c12: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8003c30 <_isr_wrapper+0x38>
 8003c14: 4413         	add	r3, r2
 8003c16: 60bb         	str	r3, [r7, #0x8]
; 	(entry->isr)(entry->arg);
 8003c18: 68bb         	ldr	r3, [r7, #0x8]
 8003c1a: 685b         	ldr	r3, [r3, #0x4]
 8003c1c: 68ba         	ldr	r2, [r7, #0x8]
 8003c1e: 6812         	ldr	r2, [r2]
 8003c20: 4610         	mov	r0, r2
 8003c22: 4798         	blx	r3
; 	z_arm_exc_exit();
 8003c24: f7fe ff94    	bl	0x8002b50 <z_arm_int_exit> @ imm = #-0x10d8
; }
 8003c28: bf00         	nop
 8003c2a: 3710         	adds	r7, #0x10
 8003c2c: 46bd         	mov	sp, r7
 8003c2e: bd80         	pop	{r7, pc}

08003c30 <$d>:
 8003c30: 38 94 01 08  	.word	0x08019438

08003c34 <z_impl_zephyr_fputc>:
; {
 8003c34: b580         	push	{r7, lr}
 8003c36: b082         	sub	sp, #0x8
 8003c38: af00         	add	r7, sp, #0x0
 8003c3a: 6078         	str	r0, [r7, #0x4]
 8003c3c: 6039         	str	r1, [r7]
; 	(*_stdout_hook)(a);
 8003c3e: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8003c50 <z_impl_zephyr_fputc+0x1c>
 8003c40: 681b         	ldr	r3, [r3]
 8003c42: 6878         	ldr	r0, [r7, #0x4]
 8003c44: 4798         	blx	r3
; 	return 0;
 8003c46: 2300         	movs	r3, #0x0
; }
 8003c48: 4618         	mov	r0, r3
 8003c4a: 3708         	adds	r7, #0x8
 8003c4c: 46bd         	mov	sp, r7
 8003c4e: bd80         	pop	{r7, pc}

08003c50 <$d>:
 8003c50: f0 0a 00 20  	.word	0x20000af0

08003c54 <__stdout_hook_install>:
; {
 8003c54: b480         	push	{r7}
 8003c56: b083         	sub	sp, #0xc
 8003c58: af00         	add	r7, sp, #0x0
 8003c5a: 6078         	str	r0, [r7, #0x4]
; 	_stdout_hook = hook;
 8003c5c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8003c7c <__stdout_hook_install+0x28>
 8003c5e: 687b         	ldr	r3, [r7, #0x4]
 8003c60: 6013         	str	r3, [r2]
; 	__stdout.flags |= _FDEV_SETUP_WRITE;
 8003c62: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8003c80 <__stdout_hook_install+0x2c>
 8003c64: 789b         	ldrb	r3, [r3, #0x2]
 8003c66: f043 0302    	orr	r3, r3, #0x2
 8003c6a: b2da         	uxtb	r2, r3
 8003c6c: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8003c80 <__stdout_hook_install+0x2c>
 8003c6e: 709a         	strb	r2, [r3, #0x2]
; }
 8003c70: bf00         	nop
 8003c72: 370c         	adds	r7, #0xc
 8003c74: 46bd         	mov	sp, r7
 8003c76: bc80         	pop	{r7}
 8003c78: 4770         	bx	lr
 8003c7a: bf00         	nop

08003c7c <$d>:
 8003c7c: f0 0a 00 20  	.word	0x20000af0
 8003c80: e4 02 00 20  	.word	0x200002e4

08003c84 <cbvprintf>:
; {
 8003c84: b580         	push	{r7, lr}
 8003c86: b08a         	sub	sp, #0x28
 8003c88: af00         	add	r7, sp, #0x0
 8003c8a: 60f8         	str	r0, [r7, #0xc]
 8003c8c: 60b9         	str	r1, [r7, #0x8]
 8003c8e: 607a         	str	r2, [r7, #0x4]
 8003c90: 603b         	str	r3, [r7]
; 	struct cb_bits	s = {
 8003c92: f107 0310    	add.w	r3, r7, #0x10
 8003c96: 2200         	movs	r2, #0x0
 8003c98: 601a         	str	r2, [r3]
 8003c9a: 605a         	str	r2, [r3, #0x4]
 8003c9c: 609a         	str	r2, [r3, #0x8]
 8003c9e: 60da         	str	r2, [r3, #0xc]
 8003ca0: 611a         	str	r2, [r3, #0x10]
 8003ca2: 615a         	str	r2, [r3, #0x14]
 8003ca4: 2302         	movs	r3, #0x2
 8003ca6: 74bb         	strb	r3, [r7, #0x12]
 8003ca8: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8003ccc <cbvprintf+0x48>
 8003caa: 617b         	str	r3, [r7, #0x14]
 8003cac: 68fb         	ldr	r3, [r7, #0xc]
 8003cae: 623b         	str	r3, [r7, #0x20]
 8003cb0: 68bb         	ldr	r3, [r7, #0x8]
 8003cb2: 627b         	str	r3, [r7, #0x24]
; 	return vfprintf(&s.f, fp, ap);
 8003cb4: f107 0310    	add.w	r3, r7, #0x10
 8003cb8: 683a         	ldr	r2, [r7]
 8003cba: 6879         	ldr	r1, [r7, #0x4]
 8003cbc: 4618         	mov	r0, r3
 8003cbe: f00b f9c7    	bl	0x800f050 <vfprintf>    @ imm = #0xb38e
 8003cc2: 4603         	mov	r3, r0
; }
 8003cc4: 4618         	mov	r0, r3
 8003cc6: 3728         	adds	r7, #0x28
 8003cc8: 46bd         	mov	sp, r7
 8003cca: bd80         	pop	{r7, pc}

08003ccc <$d>:
 8003ccc: e7 1b 01 08  	.word	0x08011be7

08003cd0 <malloc_prepare>:
; {
 8003cd0: b580         	push	{r7, lr}
 8003cd2: b082         	sub	sp, #0x8
 8003cd4: af00         	add	r7, sp, #0x0
; 	void *heap_base = NULL;
 8003cd6: 2300         	movs	r3, #0x0
 8003cd8: 607b         	str	r3, [r7, #0x4]
; 	heap_base = UINT_TO_POINTER(HEAP_BASE);
 8003cda: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8003d0c <malloc_prepare+0x3c>
 8003cdc: 3307         	adds	r3, #0x7
 8003cde: f023 0307    	bic	r3, r3, #0x7
 8003ce2: 607b         	str	r3, [r7, #0x4]
; 	heap_size = HEAP_SIZE;
 8003ce4: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8003d0c <malloc_prepare+0x3c>
 8003ce6: 3307         	adds	r3, #0x7
 8003ce8: f023 0307    	bic	r3, r3, #0x7
 8003cec: f1c3 5300    	rsb.w	r3, r3, #0x20000000
 8003cf0: f503 3300    	add.w	r3, r3, #0x20000
 8003cf4: 603b         	str	r3, [r7]
; 	sys_heap_init(&z_malloc_heap, heap_base, heap_size);
 8003cf6: 683a         	ldr	r2, [r7]
 8003cf8: 6879         	ldr	r1, [r7, #0x4]
 8003cfa: 4805         	ldr	r0, [pc, #0x14]         @ 0x8003d10 <malloc_prepare+0x40>
 8003cfc: f00c fe1d    	bl	0x801093a <sys_heap_init> @ imm = #0xcc3a
; 	return 0;
 8003d00: 2300         	movs	r3, #0x0
; }
 8003d02: 4618         	mov	r0, r3
 8003d04: 3708         	adds	r7, #0x8
 8003d06: 46bd         	mov	sp, r7
 8003d08: bd80         	pop	{r7, pc}
 8003d0a: bf00         	nop

08003d0c <$d>:
 8003d0c: 40 43 00 20  	.word	0x20004340
 8003d10: f4 0a 00 20  	.word	0x20000af4

08003d14 <LL_EXTI_EnableIT_0_31>:
; {
 8003d14: b480         	push	{r7}
 8003d16: b083         	sub	sp, #0xc
 8003d18: af00         	add	r7, sp, #0x0
 8003d1a: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->IMR, ExtiLine);
 8003d1c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8003d34 <LL_EXTI_EnableIT_0_31+0x20>
 8003d1e: 681a         	ldr	r2, [r3]
 8003d20: 4904         	ldr	r1, [pc, #0x10]         @ 0x8003d34 <LL_EXTI_EnableIT_0_31+0x20>
 8003d22: 687b         	ldr	r3, [r7, #0x4]
 8003d24: 4313         	orrs	r3, r2
 8003d26: 600b         	str	r3, [r1]
; }
 8003d28: bf00         	nop
 8003d2a: 370c         	adds	r7, #0xc
 8003d2c: 46bd         	mov	sp, r7
 8003d2e: bc80         	pop	{r7}
 8003d30: 4770         	bx	lr
 8003d32: bf00         	nop

08003d34 <$d>:
 8003d34: 00 3c 01 40  	.word	0x40013c00

08003d38 <LL_EXTI_DisableIT_0_31>:
; {
 8003d38: b480         	push	{r7}
 8003d3a: b083         	sub	sp, #0xc
 8003d3c: af00         	add	r7, sp, #0x0
 8003d3e: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->IMR, ExtiLine);
 8003d40: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8003d58 <LL_EXTI_DisableIT_0_31+0x20>
 8003d42: 681a         	ldr	r2, [r3]
 8003d44: 687b         	ldr	r3, [r7, #0x4]
 8003d46: 43db         	mvns	r3, r3
 8003d48: 4903         	ldr	r1, [pc, #0xc]          @ 0x8003d58 <LL_EXTI_DisableIT_0_31+0x20>
 8003d4a: 4013         	ands	r3, r2
 8003d4c: 600b         	str	r3, [r1]
; }
 8003d4e: bf00         	nop
 8003d50: 370c         	adds	r7, #0xc
 8003d52: 46bd         	mov	sp, r7
 8003d54: bc80         	pop	{r7}
 8003d56: 4770         	bx	lr

08003d58 <$d>:
 8003d58: 00 3c 01 40  	.word	0x40013c00

08003d5c <LL_EXTI_EnableRisingTrig_0_31>:
; {
 8003d5c: b480         	push	{r7}
 8003d5e: b083         	sub	sp, #0xc
 8003d60: af00         	add	r7, sp, #0x0
 8003d62: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->RTSR, ExtiLine);
 8003d64: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8003d7c <LL_EXTI_EnableRisingTrig_0_31+0x20>
 8003d66: 689a         	ldr	r2, [r3, #0x8]
 8003d68: 4904         	ldr	r1, [pc, #0x10]         @ 0x8003d7c <LL_EXTI_EnableRisingTrig_0_31+0x20>
 8003d6a: 687b         	ldr	r3, [r7, #0x4]
 8003d6c: 4313         	orrs	r3, r2
 8003d6e: 608b         	str	r3, [r1, #0x8]
; }
 8003d70: bf00         	nop
 8003d72: 370c         	adds	r7, #0xc
 8003d74: 46bd         	mov	sp, r7
 8003d76: bc80         	pop	{r7}
 8003d78: 4770         	bx	lr
 8003d7a: bf00         	nop

08003d7c <$d>:
 8003d7c: 00 3c 01 40  	.word	0x40013c00

08003d80 <LL_EXTI_DisableRisingTrig_0_31>:
; {
 8003d80: b480         	push	{r7}
 8003d82: b083         	sub	sp, #0xc
 8003d84: af00         	add	r7, sp, #0x0
 8003d86: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->RTSR, ExtiLine);
 8003d88: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8003da0 <LL_EXTI_DisableRisingTrig_0_31+0x20>
 8003d8a: 689a         	ldr	r2, [r3, #0x8]
 8003d8c: 687b         	ldr	r3, [r7, #0x4]
 8003d8e: 43db         	mvns	r3, r3
 8003d90: 4903         	ldr	r1, [pc, #0xc]          @ 0x8003da0 <LL_EXTI_DisableRisingTrig_0_31+0x20>
 8003d92: 4013         	ands	r3, r2
 8003d94: 608b         	str	r3, [r1, #0x8]
; }
 8003d96: bf00         	nop
 8003d98: 370c         	adds	r7, #0xc
 8003d9a: 46bd         	mov	sp, r7
 8003d9c: bc80         	pop	{r7}
 8003d9e: 4770         	bx	lr

08003da0 <$d>:
 8003da0: 00 3c 01 40  	.word	0x40013c00

08003da4 <LL_EXTI_EnableFallingTrig_0_31>:
; {
 8003da4: b480         	push	{r7}
 8003da6: b083         	sub	sp, #0xc
 8003da8: af00         	add	r7, sp, #0x0
 8003daa: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->FTSR, ExtiLine);
 8003dac: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8003dc4 <LL_EXTI_EnableFallingTrig_0_31+0x20>
 8003dae: 68da         	ldr	r2, [r3, #0xc]
 8003db0: 4904         	ldr	r1, [pc, #0x10]         @ 0x8003dc4 <LL_EXTI_EnableFallingTrig_0_31+0x20>
 8003db2: 687b         	ldr	r3, [r7, #0x4]
 8003db4: 4313         	orrs	r3, r2
 8003db6: 60cb         	str	r3, [r1, #0xc]
; }
 8003db8: bf00         	nop
 8003dba: 370c         	adds	r7, #0xc
 8003dbc: 46bd         	mov	sp, r7
 8003dbe: bc80         	pop	{r7}
 8003dc0: 4770         	bx	lr
 8003dc2: bf00         	nop

08003dc4 <$d>:
 8003dc4: 00 3c 01 40  	.word	0x40013c00

08003dc8 <LL_EXTI_DisableFallingTrig_0_31>:
; {
 8003dc8: b480         	push	{r7}
 8003dca: b083         	sub	sp, #0xc
 8003dcc: af00         	add	r7, sp, #0x0
 8003dce: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->FTSR, ExtiLine);
 8003dd0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8003de8 <LL_EXTI_DisableFallingTrig_0_31+0x20>
 8003dd2: 68da         	ldr	r2, [r3, #0xc]
 8003dd4: 687b         	ldr	r3, [r7, #0x4]
 8003dd6: 43db         	mvns	r3, r3
 8003dd8: 4903         	ldr	r1, [pc, #0xc]          @ 0x8003de8 <LL_EXTI_DisableFallingTrig_0_31+0x20>
 8003dda: 4013         	ands	r3, r2
 8003ddc: 60cb         	str	r3, [r1, #0xc]
; }
 8003dde: bf00         	nop
 8003de0: 370c         	adds	r7, #0xc
 8003de2: 46bd         	mov	sp, r7
 8003de4: bc80         	pop	{r7}
 8003de6: 4770         	bx	lr

08003de8 <$d>:
 8003de8: 00 3c 01 40  	.word	0x40013c00

08003dec <LL_EXTI_IsActiveFlag_0_31>:
; {
 8003dec: b480         	push	{r7}
 8003dee: b083         	sub	sp, #0xc
 8003df0: af00         	add	r7, sp, #0x0
 8003df2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(EXTI->PR, ExtiLine) == (ExtiLine));
 8003df4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8003e14 <LL_EXTI_IsActiveFlag_0_31+0x28>
 8003df6: 695a         	ldr	r2, [r3, #0x14]
 8003df8: 687b         	ldr	r3, [r7, #0x4]
 8003dfa: 4013         	ands	r3, r2
 8003dfc: 687a         	ldr	r2, [r7, #0x4]
 8003dfe: 429a         	cmp	r2, r3
 8003e00: bf0c         	ite	eq
 8003e02: 2301         	moveq	r3, #0x1
 8003e04: 2300         	movne	r3, #0x0
 8003e06: b2db         	uxtb	r3, r3
; }
 8003e08: 4618         	mov	r0, r3
 8003e0a: 370c         	adds	r7, #0xc
 8003e0c: 46bd         	mov	sp, r7
 8003e0e: bc80         	pop	{r7}
 8003e10: 4770         	bx	lr
 8003e12: bf00         	nop

08003e14 <$d>:
 8003e14: 00 3c 01 40  	.word	0x40013c00

08003e18 <LL_EXTI_ClearFlag_0_31>:
; {
 8003e18: b480         	push	{r7}
 8003e1a: b083         	sub	sp, #0xc
 8003e1c: af00         	add	r7, sp, #0x0
 8003e1e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(EXTI->PR, ExtiLine);
 8003e20: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8003e30 <LL_EXTI_ClearFlag_0_31+0x18>
 8003e22: 687b         	ldr	r3, [r7, #0x4]
 8003e24: 6153         	str	r3, [r2, #0x14]
; }
 8003e26: bf00         	nop
 8003e28: 370c         	adds	r7, #0xc
 8003e2a: 46bd         	mov	sp, r7
 8003e2c: bc80         	pop	{r7}
 8003e2e: 4770         	bx	lr

08003e30 <$d>:
 8003e30: 00 3c 01 40  	.word	0x40013c00

08003e34 <LL_SYSCFG_SetEXTISource>:
; {
 8003e34: b480         	push	{r7}
 8003e36: b087         	sub	sp, #0x1c
 8003e38: af00         	add	r7, sp, #0x0
 8003e3a: 6078         	str	r0, [r7, #0x4]
 8003e3c: 6039         	str	r1, [r7]
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16), Port << POSITION_VAL((Line >> 16)));
 8003e3e: 4a16         	ldr	r2, [pc, #0x58]         @ 0x8003e98 <LL_SYSCFG_SetEXTISource+0x64>
 8003e40: 683b         	ldr	r3, [r7]
 8003e42: b2db         	uxtb	r3, r3
 8003e44: 3302         	adds	r3, #0x2
 8003e46: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 8003e4a: 683b         	ldr	r3, [r7]
 8003e4c: 0c1b         	lsrs	r3, r3, #0x10
 8003e4e: 43db         	mvns	r3, r3
 8003e50: ea02 0103    	and.w	r1, r2, r3
 8003e54: 683b         	ldr	r3, [r7]
 8003e56: 0c1b         	lsrs	r3, r3, #0x10
 8003e58: 613b         	str	r3, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8003e5a: 693b         	ldr	r3, [r7, #0x10]
 8003e5c: fa93 f3a3    	rbit	r3, r3
 8003e60: 60fb         	str	r3, [r7, #0xc]
;   return result;
 8003e62: 68fb         	ldr	r3, [r7, #0xc]
 8003e64: 617b         	str	r3, [r7, #0x14]
;   if (value == 0U)
 8003e66: 697b         	ldr	r3, [r7, #0x14]
 8003e68: 2b00         	cmp	r3, #0x0
 8003e6a: d101         	bne	0x8003e70 <LL_SYSCFG_SetEXTISource+0x3c> @ imm = #0x2
;     return 32U;
 8003e6c: 2320         	movs	r3, #0x20
 8003e6e: e003         	b	0x8003e78 <LL_SYSCFG_SetEXTISource+0x44> @ imm = #0x6
;   return __builtin_clz(value);
 8003e70: 697b         	ldr	r3, [r7, #0x14]
 8003e72: fab3 f383    	clz	r3, r3
 8003e76: b2db         	uxtb	r3, r3
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16), Port << POSITION_VAL((Line >> 16)));
 8003e78: 461a         	mov	r2, r3
 8003e7a: 687b         	ldr	r3, [r7, #0x4]
 8003e7c: fa03 f202    	lsl.w	r2, r3, r2
 8003e80: 4805         	ldr	r0, [pc, #0x14]         @ 0x8003e98 <LL_SYSCFG_SetEXTISource+0x64>
 8003e82: 683b         	ldr	r3, [r7]
 8003e84: b2db         	uxtb	r3, r3
 8003e86: 430a         	orrs	r2, r1
 8003e88: 3302         	adds	r3, #0x2
 8003e8a: f840 2023    	str.w	r2, [r0, r3, lsl #2]
; }
 8003e8e: bf00         	nop
 8003e90: 371c         	adds	r7, #0x1c
 8003e92: 46bd         	mov	sp, r7
 8003e94: bc80         	pop	{r7}
 8003e96: 4770         	bx	lr

08003e98 <$d>:
 8003e98: 00 38 01 40  	.word	0x40013800

08003e9c <LL_SYSCFG_GetEXTISource>:
; {
 8003e9c: b480         	push	{r7}
 8003e9e: b087         	sub	sp, #0x1c
 8003ea0: af00         	add	r7, sp, #0x0
 8003ea2: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16)) >> POSITION_VAL(Line >> 16));
 8003ea4: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8003ee8 <LL_SYSCFG_GetEXTISource+0x4c>
 8003ea6: 687b         	ldr	r3, [r7, #0x4]
 8003ea8: b2db         	uxtb	r3, r3
 8003eaa: 3302         	adds	r3, #0x2
 8003eac: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 8003eb0: 687b         	ldr	r3, [r7, #0x4]
 8003eb2: 0c1b         	lsrs	r3, r3, #0x10
 8003eb4: 4013         	ands	r3, r2
 8003eb6: 687a         	ldr	r2, [r7, #0x4]
 8003eb8: 0c12         	lsrs	r2, r2, #0x10
 8003eba: 613a         	str	r2, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8003ebc: 693a         	ldr	r2, [r7, #0x10]
 8003ebe: fa92 f2a2    	rbit	r2, r2
 8003ec2: 60fa         	str	r2, [r7, #0xc]
;   return result;
 8003ec4: 68fa         	ldr	r2, [r7, #0xc]
 8003ec6: 617a         	str	r2, [r7, #0x14]
;   if (value == 0U)
 8003ec8: 697a         	ldr	r2, [r7, #0x14]
 8003eca: 2a00         	cmp	r2, #0x0
 8003ecc: d101         	bne	0x8003ed2 <LL_SYSCFG_GetEXTISource+0x36> @ imm = #0x2
;     return 32U;
 8003ece: 2220         	movs	r2, #0x20
 8003ed0: e003         	b	0x8003eda <LL_SYSCFG_GetEXTISource+0x3e> @ imm = #0x6
;   return __builtin_clz(value);
 8003ed2: 697a         	ldr	r2, [r7, #0x14]
 8003ed4: fab2 f282    	clz	r2, r2
 8003ed8: b2d2         	uxtb	r2, r2
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16)) >> POSITION_VAL(Line >> 16));
 8003eda: 40d3         	lsrs	r3, r2
; }
 8003edc: 4618         	mov	r0, r3
 8003ede: 371c         	adds	r7, #0x1c
 8003ee0: 46bd         	mov	sp, r7
 8003ee2: bc80         	pop	{r7}
 8003ee4: 4770         	bx	lr
 8003ee6: bf00         	nop

08003ee8 <$d>:
 8003ee8: 00 38 01 40  	.word	0x40013800

08003eec <stm32_exti_isr>:
; {
 8003eec: b580         	push	{r7, lr}
 8003eee: b088         	sub	sp, #0x20
 8003ef0: af00         	add	r7, sp, #0x0
 8003ef2: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = DEVICE_DT_GET(EXTI_NODE);
 8003ef4: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8003f74 <stm32_exti_isr+0x88>
 8003ef6: 61bb         	str	r3, [r7, #0x18]
; 	struct stm32_exti_data *data = dev->data;
 8003ef8: 69bb         	ldr	r3, [r7, #0x18]
 8003efa: 691b         	ldr	r3, [r3, #0x10]
 8003efc: 617b         	str	r3, [r7, #0x14]
; 	const struct stm32_exti_range *range = exti_range;
 8003efe: 687b         	ldr	r3, [r7, #0x4]
 8003f00: 613b         	str	r3, [r7, #0x10]
; 	for (uint8_t i = 0; i <= range->len; i++) {
 8003f02: 2300         	movs	r3, #0x0
 8003f04: 77fb         	strb	r3, [r7, #0x1f]
 8003f06: e02b         	b	0x8003f60 <stm32_exti_isr+0x74> @ imm = #0x56
; 		line_num = range->start + i;
 8003f08: 693b         	ldr	r3, [r7, #0x10]
 8003f0a: 781b         	ldrb	r3, [r3]
 8003f0c: 461a         	mov	r2, r3
 8003f0e: 7ffb         	ldrb	r3, [r7, #0x1f]
 8003f10: 4413         	add	r3, r2
 8003f12: 60fb         	str	r3, [r7, #0xc]
; 		line = linenum_to_ll_exti_line(line_num);
 8003f14: 68fb         	ldr	r3, [r7, #0xc]
 8003f16: b2db         	uxtb	r3, r3
 8003f18: 4618         	mov	r0, r3
 8003f1a: f00d feca    	bl	0x8011cb2 <linenum_to_ll_exti_line> @ imm = #0xdd94
 8003f1e: 60b8         	str	r0, [r7, #0x8]
; 		if (stm32_exti_is_pending(line) != 0) {
 8003f20: 68b8         	ldr	r0, [r7, #0x8]
 8003f22: f00d feaf    	bl	0x8011c84 <stm32_exti_is_pending> @ imm = #0xdd5e
 8003f26: 4603         	mov	r3, r0
 8003f28: 2b00         	cmp	r3, #0x0
 8003f2a: d016         	beq	0x8003f5a <stm32_exti_isr+0x6e> @ imm = #0x2c
; 			stm32_exti_clear_pending(line);
 8003f2c: 68b8         	ldr	r0, [r7, #0x8]
 8003f2e: f00d feb5    	bl	0x8011c9c <stm32_exti_clear_pending> @ imm = #0xdd6a
; 			if (!data->cb[line_num].cb) {
 8003f32: 697b         	ldr	r3, [r7, #0x14]
 8003f34: 68fa         	ldr	r2, [r7, #0xc]
 8003f36: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 8003f3a: 2b00         	cmp	r3, #0x0
 8003f3c: d00c         	beq	0x8003f58 <stm32_exti_isr+0x6c> @ imm = #0x18
; 			data->cb[line_num].cb(line, data->cb[line_num].data);
 8003f3e: 697b         	ldr	r3, [r7, #0x14]
 8003f40: 68fa         	ldr	r2, [r7, #0xc]
 8003f42: f853 2032    	ldr.w	r2, [r3, r2, lsl #3]
 8003f46: 6979         	ldr	r1, [r7, #0x14]
 8003f48: 68fb         	ldr	r3, [r7, #0xc]
 8003f4a: 00db         	lsls	r3, r3, #0x3
 8003f4c: 440b         	add	r3, r1
 8003f4e: 685b         	ldr	r3, [r3, #0x4]
 8003f50: 4619         	mov	r1, r3
 8003f52: 68b8         	ldr	r0, [r7, #0x8]
 8003f54: 4790         	blx	r2
 8003f56: e000         	b	0x8003f5a <stm32_exti_isr+0x6e> @ imm = #0x0
; 				continue;
 8003f58: bf00         	nop
; 	for (uint8_t i = 0; i <= range->len; i++) {
 8003f5a: 7ffb         	ldrb	r3, [r7, #0x1f]
 8003f5c: 3301         	adds	r3, #0x1
 8003f5e: 77fb         	strb	r3, [r7, #0x1f]
 8003f60: 693b         	ldr	r3, [r7, #0x10]
 8003f62: 785b         	ldrb	r3, [r3, #0x1]
 8003f64: 7ffa         	ldrb	r2, [r7, #0x1f]
 8003f66: 429a         	cmp	r2, r3
 8003f68: d9ce         	bls	0x8003f08 <stm32_exti_isr+0x1c> @ imm = #-0x64
; }
 8003f6a: bf00         	nop
 8003f6c: bf00         	nop
 8003f6e: 3720         	adds	r7, #0x20
 8003f70: 46bd         	mov	sp, r7
 8003f72: bd80         	pop	{r7, pc}

08003f74 <$d>:
 8003f74: 44 92 01 08  	.word	0x08019244

08003f78 <stm32_exti_enable_registers>:
; {
 8003f78: b580         	push	{r7, lr}
 8003f7a: b084         	sub	sp, #0x10
 8003f7c: af00         	add	r7, sp, #0x0
; 	int ret = 0;
 8003f7e: 2300         	movs	r3, #0x0
 8003f80: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8003f82: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8003fa8 <stm32_exti_enable_registers+0x30>
 8003f84: 60bb         	str	r3, [r7, #0x8]
; 	struct stm32_pclken pclken = {
 8003f86: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8003fac <stm32_exti_enable_registers+0x34>
 8003f88: 463b         	mov	r3, r7
 8003f8a: e892 0003    	ldm.w	r2, {r0, r1}
 8003f8e: e883 0003    	stm.w	r3, {r0, r1}
; 	ret = clock_control_on(clk, (clock_control_subsys_t) &pclken);
 8003f92: 463b         	mov	r3, r7
 8003f94: 4619         	mov	r1, r3
 8003f96: 68b8         	ldr	r0, [r7, #0x8]
 8003f98: f00d fe39    	bl	0x8011c0e <clock_control_on> @ imm = #0xdc72
 8003f9c: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 8003f9e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8003fa0: 4618         	mov	r0, r3
 8003fa2: 3710         	adds	r7, #0x10
 8003fa4: 46bd         	mov	sp, r7
 8003fa6: bd80         	pop	{r7, pc}

08003fa8 <$d>:
 8003fa8: 1c 92 01 08  	.word	0x0801921c
 8003fac: c4 9f 01 08  	.word	0x08019fc4

08003fb0 <stm32_fill_irq_table>:
; {
 8003fb0: b480         	push	{r7}
 8003fb2: b085         	sub	sp, #0x14
 8003fb4: af00         	add	r7, sp, #0x0
 8003fb6: 4603         	mov	r3, r0
 8003fb8: 603a         	str	r2, [r7]
 8003fba: 71fb         	strb	r3, [r7, #0x7]
 8003fbc: 460b         	mov	r3, r1
 8003fbe: 71bb         	strb	r3, [r7, #0x6]
; 	for (int i = 0; i < len; i++) {
 8003fc0: 2300         	movs	r3, #0x0
 8003fc2: 60fb         	str	r3, [r7, #0xc]
 8003fc4: e00a         	b	0x8003fdc <stm32_fill_irq_table+0x2c> @ imm = #0x14
; 		exti_irq_table[start + i] = irqn;
 8003fc6: f997 2007    	ldrsb.w	r2, [r7, #0x7]
 8003fca: 68fb         	ldr	r3, [r7, #0xc]
 8003fcc: 4413         	add	r3, r2
 8003fce: 683a         	ldr	r2, [r7]
 8003fd0: b251         	sxtb	r1, r2
 8003fd2: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8003ff4 <stm32_fill_irq_table+0x44>
 8003fd4: 54d1         	strb	r1, [r2, r3]
; 	for (int i = 0; i < len; i++) {
 8003fd6: 68fb         	ldr	r3, [r7, #0xc]
 8003fd8: 3301         	adds	r3, #0x1
 8003fda: 60fb         	str	r3, [r7, #0xc]
 8003fdc: f997 3006    	ldrsb.w	r3, [r7, #0x6]
 8003fe0: 68fa         	ldr	r2, [r7, #0xc]
 8003fe2: 429a         	cmp	r2, r3
 8003fe4: dbef         	blt	0x8003fc6 <stm32_fill_irq_table+0x16> @ imm = #-0x22
; }
 8003fe6: bf00         	nop
 8003fe8: bf00         	nop
 8003fea: 3714         	adds	r7, #0x14
 8003fec: 46bd         	mov	sp, r7
 8003fee: bc80         	pop	{r7}
 8003ff0: 4770         	bx	lr
 8003ff2: bf00         	nop

08003ff4 <$d>:
 8003ff4: f4 02 00 20  	.word	0x200002f4

08003ff8 <stm32_exti_init>:
; {
 8003ff8: b580         	push	{r7, lr}
 8003ffa: b082         	sub	sp, #0x8
 8003ffc: af00         	add	r7, sp, #0x0
 8003ffe: 6078         	str	r0, [r7, #0x4]
; 	DT_FOREACH_PROP_ELEM(DT_NODELABEL(exti),
 8004000: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x80040e0 <stm32_exti_init+0xe8>
 8004002: 781b         	ldrb	r3, [r3]
 8004004: b25b         	sxtb	r3, r3
 8004006: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x80040e0 <stm32_exti_init+0xe8>
 8004008: 7852         	ldrb	r2, [r2, #0x1]
 800400a: b251         	sxtb	r1, r2
 800400c: 2206         	movs	r2, #0x6
 800400e: 4618         	mov	r0, r3
 8004010: f7ff ffce    	bl	0x8003fb0 <stm32_fill_irq_table> @ imm = #-0x64
 8004014: 2200         	movs	r2, #0x0
 8004016: 2100         	movs	r1, #0x0
 8004018: 2006         	movs	r0, #0x6
 800401a: f00d fd47    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #0xda8e
 800401e: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80040e4 <stm32_exti_init+0xec>
 8004020: 781b         	ldrb	r3, [r3]
 8004022: b25b         	sxtb	r3, r3
 8004024: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x80040e4 <stm32_exti_init+0xec>
 8004026: 7852         	ldrb	r2, [r2, #0x1]
 8004028: b251         	sxtb	r1, r2
 800402a: 2207         	movs	r2, #0x7
 800402c: 4618         	mov	r0, r3
 800402e: f7ff ffbf    	bl	0x8003fb0 <stm32_fill_irq_table> @ imm = #-0x82
 8004032: 2200         	movs	r2, #0x0
 8004034: 2100         	movs	r1, #0x0
 8004036: 2007         	movs	r0, #0x7
 8004038: f00d fd38    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #0xda70
 800403c: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80040e8 <stm32_exti_init+0xf0>
 800403e: 781b         	ldrb	r3, [r3]
 8004040: b25b         	sxtb	r3, r3
 8004042: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x80040e8 <stm32_exti_init+0xf0>
 8004044: 7852         	ldrb	r2, [r2, #0x1]
 8004046: b251         	sxtb	r1, r2
 8004048: 2208         	movs	r2, #0x8
 800404a: 4618         	mov	r0, r3
 800404c: f7ff ffb0    	bl	0x8003fb0 <stm32_fill_irq_table> @ imm = #-0xa0
 8004050: 2200         	movs	r2, #0x0
 8004052: 2100         	movs	r1, #0x0
 8004054: 2008         	movs	r0, #0x8
 8004056: f00d fd29    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #0xda52
 800405a: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80040ec <stm32_exti_init+0xf4>
 800405c: 781b         	ldrb	r3, [r3]
 800405e: b25b         	sxtb	r3, r3
 8004060: 4a22         	ldr	r2, [pc, #0x88]         @ 0x80040ec <stm32_exti_init+0xf4>
 8004062: 7852         	ldrb	r2, [r2, #0x1]
 8004064: b251         	sxtb	r1, r2
 8004066: 2209         	movs	r2, #0x9
 8004068: 4618         	mov	r0, r3
 800406a: f7ff ffa1    	bl	0x8003fb0 <stm32_fill_irq_table> @ imm = #-0xbe
 800406e: 2200         	movs	r2, #0x0
 8004070: 2100         	movs	r1, #0x0
 8004072: 2009         	movs	r0, #0x9
 8004074: f00d fd1a    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #0xda34
 8004078: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x80040f0 <stm32_exti_init+0xf8>
 800407a: 781b         	ldrb	r3, [r3]
 800407c: b25b         	sxtb	r3, r3
 800407e: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x80040f0 <stm32_exti_init+0xf8>
 8004080: 7852         	ldrb	r2, [r2, #0x1]
 8004082: b251         	sxtb	r1, r2
 8004084: 220a         	movs	r2, #0xa
 8004086: 4618         	mov	r0, r3
 8004088: f7ff ff92    	bl	0x8003fb0 <stm32_fill_irq_table> @ imm = #-0xdc
 800408c: 2200         	movs	r2, #0x0
 800408e: 2100         	movs	r1, #0x0
 8004090: 200a         	movs	r0, #0xa
 8004092: f00d fd0b    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #0xda16
 8004096: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80040f4 <stm32_exti_init+0xfc>
 8004098: 781b         	ldrb	r3, [r3]
 800409a: b25b         	sxtb	r3, r3
 800409c: 4a15         	ldr	r2, [pc, #0x54]         @ 0x80040f4 <stm32_exti_init+0xfc>
 800409e: 7852         	ldrb	r2, [r2, #0x1]
 80040a0: b251         	sxtb	r1, r2
 80040a2: 2217         	movs	r2, #0x17
 80040a4: 4618         	mov	r0, r3
 80040a6: f7ff ff83    	bl	0x8003fb0 <stm32_fill_irq_table> @ imm = #-0xfa
 80040aa: 2200         	movs	r2, #0x0
 80040ac: 2100         	movs	r1, #0x0
 80040ae: 2017         	movs	r0, #0x17
 80040b0: f00d fcfc    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #0xd9f8
 80040b4: 4b10         	ldr	r3, [pc, #0x40]         @ 0x80040f8 <stm32_exti_init+0x100>
 80040b6: 781b         	ldrb	r3, [r3]
 80040b8: b25b         	sxtb	r3, r3
 80040ba: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x80040f8 <stm32_exti_init+0x100>
 80040bc: 7852         	ldrb	r2, [r2, #0x1]
 80040be: b251         	sxtb	r1, r2
 80040c0: 2228         	movs	r2, #0x28
 80040c2: 4618         	mov	r0, r3
 80040c4: f7ff ff74    	bl	0x8003fb0 <stm32_fill_irq_table> @ imm = #-0x118
 80040c8: 2200         	movs	r2, #0x0
 80040ca: 2100         	movs	r1, #0x0
 80040cc: 2028         	movs	r0, #0x28
 80040ce: f00d fced    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #0xd9da
; 	return stm32_exti_enable_registers();
 80040d2: f7ff ff51    	bl	0x8003f78 <stm32_exti_enable_registers> @ imm = #-0x15e
 80040d6: 4603         	mov	r3, r0
; }
 80040d8: 4618         	mov	r0, r3
 80040da: 3708         	adds	r7, #0x8
 80040dc: 46bd         	mov	sp, r7
 80040de: bd80         	pop	{r7, pc}

080040e0 <$d>:
 80040e0: 74 b4 01 08  	.word	0x0801b474
 80040e4: 78 b4 01 08  	.word	0x0801b478
 80040e8: 7c b4 01 08  	.word	0x0801b47c
 80040ec: 80 b4 01 08  	.word	0x0801b480
 80040f0: 84 b4 01 08  	.word	0x0801b484
 80040f4: 88 b4 01 08  	.word	0x0801b488
 80040f8: 8c b4 01 08  	.word	0x0801b48c

080040fc <stm32_gpio_intc_enable_line>:
; {
 80040fc: b580         	push	{r7, lr}
 80040fe: b084         	sub	sp, #0x10
 8004100: af00         	add	r7, sp, #0x0
 8004102: 6078         	str	r0, [r7, #0x4]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 8004104: 6878         	ldr	r0, [r7, #0x4]
 8004106: f00d fde2    	bl	0x8011cce <ll_exti_line_to_linenum> @ imm = #0xdbc4
 800410a: 4603         	mov	r3, r0
 800410c: 60fb         	str	r3, [r7, #0xc]
; 	irqnum = exti_irq_table[line_num];
 800410e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8004130 <stm32_gpio_intc_enable_line+0x34>
 8004110: 68fb         	ldr	r3, [r7, #0xc]
 8004112: 4413         	add	r3, r2
 8004114: f993 3000    	ldrsb.w	r3, [r3]
 8004118: 60bb         	str	r3, [r7, #0x8]
; 	LL_EXTI_EnableIT_0_31(line);
 800411a: 6878         	ldr	r0, [r7, #0x4]
 800411c: f7ff fdfa    	bl	0x8003d14 <LL_EXTI_EnableIT_0_31> @ imm = #-0x40c
; 	irq_enable(irqnum);
 8004120: 68b8         	ldr	r0, [r7, #0x8]
 8004122: f00d fcb6    	bl	0x8011a92 <arch_irq_enable> @ imm = #0xd96c
; }
 8004126: bf00         	nop
 8004128: 3710         	adds	r7, #0x10
 800412a: 46bd         	mov	sp, r7
 800412c: bd80         	pop	{r7, pc}
 800412e: bf00         	nop

08004130 <$d>:
 8004130: f4 02 00 20  	.word	0x200002f4

08004134 <stm32_gpio_intc_select_line_trigger>:
; {
 8004134: b580         	push	{r7, lr}
 8004136: b082         	sub	sp, #0x8
 8004138: af00         	add	r7, sp, #0x0
 800413a: 6078         	str	r0, [r7, #0x4]
 800413c: 6039         	str	r1, [r7]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 800413e: f44f 1180    	mov.w	r1, #0x100000
 8004142: 2000         	movs	r0, #0x0
 8004144: f00d fd75    	bl	0x8011c32 <z_stm32_hsem_lock> @ imm = #0xdaea
; 	switch (trg) {
 8004148: 683b         	ldr	r3, [r7]
 800414a: 2b03         	cmp	r3, #0x3
 800414c: d826         	bhi	0x800419c <stm32_gpio_intc_select_line_trigger+0x68> @ imm = #0x4c
 800414e: a201         	adr	r2, #4 <stm32_gpio_intc_select_line_trigger+0x1f>
 8004150: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08004154 <$d>:
 8004154: 65 41 00 08  	.word	0x08004165
 8004158: 73 41 00 08  	.word	0x08004173
 800415c: 81 41 00 08  	.word	0x08004181
 8004160: 8f 41 00 08  	.word	0x0800418f

08004164 <$t>:
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 8004164: 6878         	ldr	r0, [r7, #0x4]
 8004166: f7ff fe0b    	bl	0x8003d80 <LL_EXTI_DisableRisingTrig_0_31> @ imm = #-0x3ea
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 800416a: 6878         	ldr	r0, [r7, #0x4]
 800416c: f7ff fe2c    	bl	0x8003dc8 <LL_EXTI_DisableFallingTrig_0_31> @ imm = #-0x3a8
; 		break;
 8004170: e015         	b	0x800419e <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x2a
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 8004172: 6878         	ldr	r0, [r7, #0x4]
 8004174: f7ff fdf2    	bl	0x8003d5c <LL_EXTI_EnableRisingTrig_0_31> @ imm = #-0x41c
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 8004178: 6878         	ldr	r0, [r7, #0x4]
 800417a: f7ff fe25    	bl	0x8003dc8 <LL_EXTI_DisableFallingTrig_0_31> @ imm = #-0x3b6
; 		break;
 800417e: e00e         	b	0x800419e <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x1c
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 8004180: 6878         	ldr	r0, [r7, #0x4]
 8004182: f7ff fe0f    	bl	0x8003da4 <LL_EXTI_EnableFallingTrig_0_31> @ imm = #-0x3e2
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 8004186: 6878         	ldr	r0, [r7, #0x4]
 8004188: f7ff fdfa    	bl	0x8003d80 <LL_EXTI_DisableRisingTrig_0_31> @ imm = #-0x40c
; 		break;
 800418c: e007         	b	0x800419e <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0xe
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 800418e: 6878         	ldr	r0, [r7, #0x4]
 8004190: f7ff fde4    	bl	0x8003d5c <LL_EXTI_EnableRisingTrig_0_31> @ imm = #-0x438
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 8004194: 6878         	ldr	r0, [r7, #0x4]
 8004196: f7ff fe05    	bl	0x8003da4 <LL_EXTI_EnableFallingTrig_0_31> @ imm = #-0x3f6
; 		break;
 800419a: e000         	b	0x800419e <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x0
; 		break;
 800419c: bf00         	nop
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 800419e: 2000         	movs	r0, #0x0
 80041a0: f00d fd51    	bl	0x8011c46 <z_stm32_hsem_unlock> @ imm = #0xdaa2
; }
 80041a4: bf00         	nop
 80041a6: 3708         	adds	r7, #0x8
 80041a8: 46bd         	mov	sp, r7
 80041aa: bd80         	pop	{r7, pc}

080041ac <stm32_gpio_intc_set_irq_callback>:
; {
 80041ac: b580         	push	{r7, lr}
 80041ae: b088         	sub	sp, #0x20
 80041b0: af00         	add	r7, sp, #0x0
 80041b2: 60f8         	str	r0, [r7, #0xc]
 80041b4: 60b9         	str	r1, [r7, #0x8]
 80041b6: 607a         	str	r2, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 80041b8: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8004220 <stm32_gpio_intc_set_irq_callback+0x74>
 80041ba: 61fb         	str	r3, [r7, #0x1c]
; 	struct stm32_exti_data *data = dev->data;
 80041bc: 69fb         	ldr	r3, [r7, #0x1c]
 80041be: 691b         	ldr	r3, [r3, #0x10]
 80041c0: 61bb         	str	r3, [r7, #0x18]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 80041c2: 68f8         	ldr	r0, [r7, #0xc]
 80041c4: f00d fd83    	bl	0x8011cce <ll_exti_line_to_linenum> @ imm = #0xdb06
 80041c8: 4603         	mov	r3, r0
 80041ca: 617b         	str	r3, [r7, #0x14]
; 	if ((data->cb[line_num].cb == cb) && (data->cb[line_num].data == user)) {
 80041cc: 69bb         	ldr	r3, [r7, #0x18]
 80041ce: 697a         	ldr	r2, [r7, #0x14]
 80041d0: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 80041d4: 68ba         	ldr	r2, [r7, #0x8]
 80041d6: 429a         	cmp	r2, r3
 80041d8: d109         	bne	0x80041ee <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x12
 80041da: 69ba         	ldr	r2, [r7, #0x18]
 80041dc: 697b         	ldr	r3, [r7, #0x14]
 80041de: 00db         	lsls	r3, r3, #0x3
 80041e0: 4413         	add	r3, r2
 80041e2: 685b         	ldr	r3, [r3, #0x4]
 80041e4: 687a         	ldr	r2, [r7, #0x4]
 80041e6: 429a         	cmp	r2, r3
 80041e8: d101         	bne	0x80041ee <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x2
; 		return 0;
 80041ea: 2300         	movs	r3, #0x0
 80041ec: e014         	b	0x8004218 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x28
; 	if (data->cb[line_num].cb != NULL) {
 80041ee: 69bb         	ldr	r3, [r7, #0x18]
 80041f0: 697a         	ldr	r2, [r7, #0x14]
 80041f2: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 80041f6: 2b00         	cmp	r3, #0x0
 80041f8: d002         	beq	0x8004200 <stm32_gpio_intc_set_irq_callback+0x54> @ imm = #0x4
; 		return -EBUSY;
 80041fa: f06f 030f    	mvn	r3, #0xf
 80041fe: e00b         	b	0x8004218 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x16
; 	data->cb[line_num].cb = cb;
 8004200: 69bb         	ldr	r3, [r7, #0x18]
 8004202: 697a         	ldr	r2, [r7, #0x14]
 8004204: 68b9         	ldr	r1, [r7, #0x8]
 8004206: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = user;
 800420a: 69ba         	ldr	r2, [r7, #0x18]
 800420c: 697b         	ldr	r3, [r7, #0x14]
 800420e: 00db         	lsls	r3, r3, #0x3
 8004210: 4413         	add	r3, r2
 8004212: 687a         	ldr	r2, [r7, #0x4]
 8004214: 605a         	str	r2, [r3, #0x4]
; 	return 0;
 8004216: 2300         	movs	r3, #0x0
; }
 8004218: 4618         	mov	r0, r3
 800421a: 3720         	adds	r7, #0x20
 800421c: 46bd         	mov	sp, r7
 800421e: bd80         	pop	{r7, pc}

08004220 <$d>:
 8004220: 44 92 01 08  	.word	0x08019244

08004224 <stm32_gpio_intc_remove_irq_callback>:
; {
 8004224: b580         	push	{r7, lr}
 8004226: b086         	sub	sp, #0x18
 8004228: af00         	add	r7, sp, #0x0
 800422a: 6078         	str	r0, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 800422c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004260 <stm32_gpio_intc_remove_irq_callback+0x3c>
 800422e: 617b         	str	r3, [r7, #0x14]
; 	struct stm32_exti_data *data = dev->data;
 8004230: 697b         	ldr	r3, [r7, #0x14]
 8004232: 691b         	ldr	r3, [r3, #0x10]
 8004234: 613b         	str	r3, [r7, #0x10]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 8004236: 6878         	ldr	r0, [r7, #0x4]
 8004238: f00d fd49    	bl	0x8011cce <ll_exti_line_to_linenum> @ imm = #0xda92
 800423c: 4603         	mov	r3, r0
 800423e: 60fb         	str	r3, [r7, #0xc]
; 	data->cb[line_num].cb = NULL;
 8004240: 693b         	ldr	r3, [r7, #0x10]
 8004242: 68fa         	ldr	r2, [r7, #0xc]
 8004244: 2100         	movs	r1, #0x0
 8004246: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = NULL;
 800424a: 693a         	ldr	r2, [r7, #0x10]
 800424c: 68fb         	ldr	r3, [r7, #0xc]
 800424e: 00db         	lsls	r3, r3, #0x3
 8004250: 4413         	add	r3, r2
 8004252: 2200         	movs	r2, #0x0
 8004254: 605a         	str	r2, [r3, #0x4]
; }
 8004256: bf00         	nop
 8004258: 3718         	adds	r7, #0x18
 800425a: 46bd         	mov	sp, r7
 800425c: bd80         	pop	{r7, pc}
 800425e: bf00         	nop

08004260 <$d>:
 8004260: 44 92 01 08  	.word	0x08019244

08004264 <z_impl_can_send>:
; {
 8004264: b590         	push	{r4, r7, lr}
 8004266: b097         	sub	sp, #0x5c
 8004268: af08         	add	r7, sp, #0x20
 800426a: 60f8         	str	r0, [r7, #0xc]
 800426c: 60b9         	str	r1, [r7, #0x8]
 800426e: e9c7 2300    	strd	r2, r3, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8004272: 68fb         	ldr	r3, [r7, #0xc]
 8004274: 689b         	ldr	r3, [r3, #0x8]
 8004276: 62fb         	str	r3, [r7, #0x2c]
; 	CHECKIF(frame == NULL) {
 8004278: 68bb         	ldr	r3, [r7, #0x8]
 800427a: 2b00         	cmp	r3, #0x0
 800427c: d102         	bne	0x8004284 <z_impl_can_send+0x20> @ imm = #0x4
; 		return -EINVAL;
 800427e: f06f 0315    	mvn	r3, #0x15
 8004282: e089         	b	0x8004398 <z_impl_can_send+0x134> @ imm = #0x112
; 	if ((frame->flags & CAN_FRAME_IDE) != 0U) {
 8004284: 68bb         	ldr	r3, [r7, #0x8]
 8004286: 795b         	ldrb	r3, [r3, #0x5]
 8004288: f003 0301    	and	r3, r3, #0x1
 800428c: 2b00         	cmp	r3, #0x0
 800428e: d003         	beq	0x8004298 <z_impl_can_send+0x34> @ imm = #0x6
; 		id_mask = CAN_EXT_ID_MASK;
 8004290: f06f 4360    	mvn	r3, #0xe0000000
 8004294: 633b         	str	r3, [r7, #0x30]
 8004296: e002         	b	0x800429e <z_impl_can_send+0x3a> @ imm = #0x4
; 		id_mask = CAN_STD_ID_MASK;
 8004298: f240 73ff    	movw	r3, #0x7ff
 800429c: 633b         	str	r3, [r7, #0x30]
; 	CHECKIF((frame->id & ~(id_mask)) != 0U) {
 800429e: 68bb         	ldr	r3, [r7, #0x8]
 80042a0: 681a         	ldr	r2, [r3]
 80042a2: 6b3b         	ldr	r3, [r7, #0x30]
 80042a4: 43db         	mvns	r3, r3
 80042a6: 4013         	ands	r3, r2
 80042a8: 2b00         	cmp	r3, #0x0
 80042aa: d040         	beq	0x800432e <z_impl_can_send+0xca> @ imm = #0x80
; 		LOG_ERR("invalid frame with %s (%d-bit) CAN ID 0x%0*x",
 80042ac: 2303         	movs	r3, #0x3
 80042ae: 2b00         	cmp	r3, #0x0
 80042b0: d03a         	beq	0x8004328 <z_impl_can_send+0xc4> @ imm = #0x74
 80042b2: 2301         	movs	r3, #0x1
 80042b4: f887 302b    	strb.w	r3, [r7, #0x2b]
 80042b8: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80042bc: f083 0301    	eor	r3, r3, #0x1
 80042c0: b2db         	uxtb	r3, r3
 80042c2: 2b00         	cmp	r3, #0x0
 80042c4: d130         	bne	0x8004328 <z_impl_can_send+0xc4> @ imm = #0x60
 80042c6: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80043a0 <z_impl_can_send+0x13c>
 80042c8: 681c         	ldr	r4, [r3]
 80042ca: 68bb         	ldr	r3, [r7, #0x8]
 80042cc: 795b         	ldrb	r3, [r3, #0x5]
 80042ce: f003 0301    	and	r3, r3, #0x1
 80042d2: 2b00         	cmp	r3, #0x0
 80042d4: d001         	beq	0x80042da <z_impl_can_send+0x76> @ imm = #0x2
 80042d6: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80043a4 <z_impl_can_send+0x140>
 80042d8: e000         	b	0x80042dc <z_impl_can_send+0x78> @ imm = #0x0
 80042da: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80043a8 <z_impl_can_send+0x144>
 80042dc: 68ba         	ldr	r2, [r7, #0x8]
 80042de: 7952         	ldrb	r2, [r2, #0x5]
 80042e0: f002 0201    	and	r2, r2, #0x1
 80042e4: 2a00         	cmp	r2, #0x0
 80042e6: d001         	beq	0x80042ec <z_impl_can_send+0x88> @ imm = #0x2
 80042e8: 221d         	movs	r2, #0x1d
 80042ea: e000         	b	0x80042ee <z_impl_can_send+0x8a> @ imm = #0x0
 80042ec: 220b         	movs	r2, #0xb
 80042ee: 68b9         	ldr	r1, [r7, #0x8]
 80042f0: 7949         	ldrb	r1, [r1, #0x5]
 80042f2: f001 0101    	and	r1, r1, #0x1
 80042f6: 2900         	cmp	r1, #0x0
 80042f8: d001         	beq	0x80042fe <z_impl_can_send+0x9a> @ imm = #0x2
 80042fa: 2108         	movs	r1, #0x8
 80042fc: e000         	b	0x8004300 <z_impl_can_send+0x9c> @ imm = #0x0
 80042fe: 2103         	movs	r1, #0x3
 8004300: 68b8         	ldr	r0, [r7, #0x8]
 8004302: 6800         	ldr	r0, [r0]
 8004304: 9006         	str	r0, [sp, #0x18]
 8004306: 9105         	str	r1, [sp, #0x14]
 8004308: 9204         	str	r2, [sp, #0x10]
 800430a: 9303         	str	r3, [sp, #0xc]
 800430c: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x80043ac <z_impl_can_send+0x148>
 800430e: 9302         	str	r3, [sp, #0x8]
 8004310: 2300         	movs	r3, #0x0
 8004312: 9301         	str	r3, [sp, #0x4]
 8004314: 2300         	movs	r3, #0x0
 8004316: 9300         	str	r3, [sp]
 8004318: 2300         	movs	r3, #0x0
 800431a: 2201         	movs	r2, #0x1
 800431c: 4621         	mov	r1, r4
 800431e: 2000         	movs	r0, #0x0
 8004320: f00d fdb1    	bl	0x8011e86 <z_log_msg_runtime_create> @ imm = #0xdb62
 8004324: 2300         	movs	r3, #0x0
 8004326: 627b         	str	r3, [r7, #0x24]
; 		return -EINVAL;
 8004328: f06f 0315    	mvn	r3, #0x15
 800432c: e034         	b	0x8004398 <z_impl_can_send+0x134> @ imm = #0x68
; 	if (callback == NULL) {
 800432e: 6cbb         	ldr	r3, [r7, #0x48]
 8004330: 2b00         	cmp	r3, #0x0
 8004332: d125         	bne	0x8004380 <z_impl_can_send+0x11c> @ imm = #0x4a
; 		k_sem_init(&ctx.done, 0, 1);
 8004334: f107 0310    	add.w	r3, r7, #0x10
 8004338: 2201         	movs	r2, #0x1
 800433a: 2100         	movs	r1, #0x0
 800433c: 4618         	mov	r0, r3
 800433e: f00d fd23    	bl	0x8011d88 <k_sem_init>  @ imm = #0xda46
; 		err = api->send(dev, frame, timeout, can_tx_default_cb, &ctx);
 8004342: 6afb         	ldr	r3, [r7, #0x2c]
 8004344: 695c         	ldr	r4, [r3, #0x14]
 8004346: f107 0310    	add.w	r3, r7, #0x10
 800434a: 9301         	str	r3, [sp, #0x4]
 800434c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80043b0 <z_impl_can_send+0x14c>
 800434e: 9300         	str	r3, [sp]
 8004350: e9d7 2300    	ldrd	r2, r3, [r7]
 8004354: 68b9         	ldr	r1, [r7, #0x8]
 8004356: 68f8         	ldr	r0, [r7, #0xc]
 8004358: 47a0         	blx	r4
 800435a: 6378         	str	r0, [r7, #0x34]
; 		if (err != 0) {
 800435c: 6b7b         	ldr	r3, [r7, #0x34]
 800435e: 2b00         	cmp	r3, #0x0
 8004360: d001         	beq	0x8004366 <z_impl_can_send+0x102> @ imm = #0x2
; 			return err;
 8004362: 6b7b         	ldr	r3, [r7, #0x34]
 8004364: e018         	b	0x8004398 <z_impl_can_send+0x134> @ imm = #0x30
; 		k_sem_take(&ctx.done, K_FOREVER);
 8004366: f04f 30ff    	mov.w	r0, #0xffffffff
 800436a: f04f 31ff    	mov.w	r1, #0xffffffff
 800436e: f107 0410    	add.w	r4, r7, #0x10
 8004372: 4602         	mov	r2, r0
 8004374: 460b         	mov	r3, r1
 8004376: 4620         	mov	r0, r4
 8004378: f00d fd16    	bl	0x8011da8 <k_sem_take>  @ imm = #0xda2c
; 		return ctx.status;
 800437c: 6a3b         	ldr	r3, [r7, #0x20]
 800437e: e00b         	b	0x8004398 <z_impl_can_send+0x134> @ imm = #0x16
; 	return api->send(dev, frame, timeout, callback, user_data);
 8004380: 6afb         	ldr	r3, [r7, #0x2c]
 8004382: 695c         	ldr	r4, [r3, #0x14]
 8004384: 6cfb         	ldr	r3, [r7, #0x4c]
 8004386: 9301         	str	r3, [sp, #0x4]
 8004388: 6cbb         	ldr	r3, [r7, #0x48]
 800438a: 9300         	str	r3, [sp]
 800438c: e9d7 2300    	ldrd	r2, r3, [r7]
 8004390: 68b9         	ldr	r1, [r7, #0x8]
 8004392: 68f8         	ldr	r0, [r7, #0xc]
 8004394: 47a0         	blx	r4
 8004396: 4603         	mov	r3, r0
; }
 8004398: 4618         	mov	r0, r3
 800439a: 373c         	adds	r7, #0x3c
 800439c: 46bd         	mov	sp, r7
 800439e: bd90         	pop	{r4, r7, pc}

080043a0 <$d>:
 80043a0: 04 03 00 20  	.word	0x20000304
 80043a4: f8 9f 01 08  	.word	0x08019ff8
 80043a8: 04 a0 01 08  	.word	0x0801a004
 80043ac: 10 a0 01 08  	.word	0x0801a010
 80043b0: c3 1e 01 08  	.word	0x08011ec3

080043b4 <can_add_rx_filter>:
; {
 80043b4: b5f0         	push	{r4, r5, r6, r7, lr}
 80043b6: b093         	sub	sp, #0x4c
 80043b8: af0a         	add	r7, sp, #0x28
 80043ba: 60f8         	str	r0, [r7, #0xc]
 80043bc: 60b9         	str	r1, [r7, #0x8]
 80043be: 607a         	str	r2, [r7, #0x4]
 80043c0: 603b         	str	r3, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 80043c2: 68fb         	ldr	r3, [r7, #0xc]
 80043c4: 689b         	ldr	r3, [r3, #0x8]
 80043c6: 613b         	str	r3, [r7, #0x10]
; 	CHECKIF(callback == NULL || filter == NULL) {
 80043c8: 68bb         	ldr	r3, [r7, #0x8]
 80043ca: 2b00         	cmp	r3, #0x0
 80043cc: d002         	beq	0x80043d4 <can_add_rx_filter+0x20> @ imm = #0x4
 80043ce: 683b         	ldr	r3, [r7]
 80043d0: 2b00         	cmp	r3, #0x0
 80043d2: d102         	bne	0x80043da <can_add_rx_filter+0x26> @ imm = #0x4
; 		return -EINVAL;
 80043d4: f06f 0315    	mvn	r3, #0x15
 80043d8: e06e         	b	0x80044b8 <can_add_rx_filter+0x104> @ imm = #0xdc
; 	if ((filter->flags & CAN_FILTER_IDE) != 0U) {
 80043da: 683b         	ldr	r3, [r7]
 80043dc: 7a1b         	ldrb	r3, [r3, #0x8]
 80043de: f003 0301    	and	r3, r3, #0x1
 80043e2: 2b00         	cmp	r3, #0x0
 80043e4: d003         	beq	0x80043ee <can_add_rx_filter+0x3a> @ imm = #0x6
; 		id_mask = CAN_EXT_ID_MASK;
 80043e6: f06f 4360    	mvn	r3, #0xe0000000
 80043ea: 617b         	str	r3, [r7, #0x14]
 80043ec: e002         	b	0x80043f4 <can_add_rx_filter+0x40> @ imm = #0x4
; 		id_mask = CAN_STD_ID_MASK;
 80043ee: f240 73ff    	movw	r3, #0x7ff
 80043f2: 617b         	str	r3, [r7, #0x14]
; 	CHECKIF(((filter->id & ~(id_mask)) != 0U) || ((filter->mask & ~(id_mask)) != 0U)) {
 80043f4: 683b         	ldr	r3, [r7]
 80043f6: 681a         	ldr	r2, [r3]
 80043f8: 697b         	ldr	r3, [r7, #0x14]
 80043fa: 43db         	mvns	r3, r3
 80043fc: 4013         	ands	r3, r2
 80043fe: 2b00         	cmp	r3, #0x0
 8004400: d106         	bne	0x8004410 <can_add_rx_filter+0x5c> @ imm = #0xc
 8004402: 683b         	ldr	r3, [r7]
 8004404: 685a         	ldr	r2, [r3, #0x4]
 8004406: 697b         	ldr	r3, [r7, #0x14]
 8004408: 43db         	mvns	r3, r3
 800440a: 4013         	ands	r3, r2
 800440c: 2b00         	cmp	r3, #0x0
 800440e: d04b         	beq	0x80044a8 <can_add_rx_filter+0xf4> @ imm = #0x96
; 		LOG_ERR("invalid filter with %s (%d-bit) CAN ID 0x%0*x, CAN ID mask 0x%0*x",
 8004410: 2303         	movs	r3, #0x3
 8004412: 2b00         	cmp	r3, #0x0
 8004414: d045         	beq	0x80044a2 <can_add_rx_filter+0xee> @ imm = #0x8a
 8004416: 2301         	movs	r3, #0x1
 8004418: 76fb         	strb	r3, [r7, #0x1b]
 800441a: 7efb         	ldrb	r3, [r7, #0x1b]
 800441c: f083 0301    	eor	r3, r3, #0x1
 8004420: b2db         	uxtb	r3, r3
 8004422: 2b00         	cmp	r3, #0x0
 8004424: d13d         	bne	0x80044a2 <can_add_rx_filter+0xee> @ imm = #0x7a
 8004426: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80044c0 <can_add_rx_filter+0x10c>
 8004428: 681e         	ldr	r6, [r3]
 800442a: 683b         	ldr	r3, [r7]
 800442c: 7a1b         	ldrb	r3, [r3, #0x8]
 800442e: f003 0301    	and	r3, r3, #0x1
 8004432: 2b00         	cmp	r3, #0x0
 8004434: d001         	beq	0x800443a <can_add_rx_filter+0x86> @ imm = #0x2
 8004436: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80044c4 <can_add_rx_filter+0x110>
 8004438: e000         	b	0x800443c <can_add_rx_filter+0x88> @ imm = #0x0
 800443a: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80044c8 <can_add_rx_filter+0x114>
 800443c: 683a         	ldr	r2, [r7]
 800443e: 7a12         	ldrb	r2, [r2, #0x8]
 8004440: f002 0201    	and	r2, r2, #0x1
 8004444: 2a00         	cmp	r2, #0x0
 8004446: d001         	beq	0x800444c <can_add_rx_filter+0x98> @ imm = #0x2
 8004448: 221d         	movs	r2, #0x1d
 800444a: e000         	b	0x800444e <can_add_rx_filter+0x9a> @ imm = #0x0
 800444c: 220b         	movs	r2, #0xb
 800444e: 6839         	ldr	r1, [r7]
 8004450: 7a09         	ldrb	r1, [r1, #0x8]
 8004452: f001 0101    	and	r1, r1, #0x1
 8004456: 2900         	cmp	r1, #0x0
 8004458: d001         	beq	0x800445e <can_add_rx_filter+0xaa> @ imm = #0x2
 800445a: 2108         	movs	r1, #0x8
 800445c: e000         	b	0x8004460 <can_add_rx_filter+0xac> @ imm = #0x0
 800445e: 2103         	movs	r1, #0x3
 8004460: 6838         	ldr	r0, [r7]
 8004462: 6800         	ldr	r0, [r0]
 8004464: 683c         	ldr	r4, [r7]
 8004466: 7a24         	ldrb	r4, [r4, #0x8]
 8004468: f004 0401    	and	r4, r4, #0x1
 800446c: 2c00         	cmp	r4, #0x0
 800446e: d001         	beq	0x8004474 <can_add_rx_filter+0xc0> @ imm = #0x2
 8004470: 2408         	movs	r4, #0x8
 8004472: e000         	b	0x8004476 <can_add_rx_filter+0xc2> @ imm = #0x0
 8004474: 2403         	movs	r4, #0x3
 8004476: 683d         	ldr	r5, [r7]
 8004478: 686d         	ldr	r5, [r5, #0x4]
 800447a: 9508         	str	r5, [sp, #0x20]
 800447c: 9407         	str	r4, [sp, #0x1c]
 800447e: 9006         	str	r0, [sp, #0x18]
 8004480: 9105         	str	r1, [sp, #0x14]
 8004482: 9204         	str	r2, [sp, #0x10]
 8004484: 9303         	str	r3, [sp, #0xc]
 8004486: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80044cc <can_add_rx_filter+0x118>
 8004488: 9302         	str	r3, [sp, #0x8]
 800448a: 2300         	movs	r3, #0x0
 800448c: 9301         	str	r3, [sp, #0x4]
 800448e: 2300         	movs	r3, #0x0
 8004490: 9300         	str	r3, [sp]
 8004492: 2300         	movs	r3, #0x0
 8004494: 2201         	movs	r2, #0x1
 8004496: 4631         	mov	r1, r6
 8004498: 2000         	movs	r0, #0x0
 800449a: f00d fcf4    	bl	0x8011e86 <z_log_msg_runtime_create> @ imm = #0xd9e8
 800449e: 2300         	movs	r3, #0x0
 80044a0: 61fb         	str	r3, [r7, #0x1c]
; 		return -EINVAL;
 80044a2: f06f 0315    	mvn	r3, #0x15
 80044a6: e007         	b	0x80044b8 <can_add_rx_filter+0x104> @ imm = #0xe
; 	return api->add_rx_filter(dev, callback, user_data, filter);
 80044a8: 693b         	ldr	r3, [r7, #0x10]
 80044aa: 699c         	ldr	r4, [r3, #0x18]
 80044ac: 683b         	ldr	r3, [r7]
 80044ae: 687a         	ldr	r2, [r7, #0x4]
 80044b0: 68b9         	ldr	r1, [r7, #0x8]
 80044b2: 68f8         	ldr	r0, [r7, #0xc]
 80044b4: 47a0         	blx	r4
 80044b6: 4603         	mov	r3, r0
; }
 80044b8: 4618         	mov	r0, r3
 80044ba: 3724         	adds	r7, #0x24
 80044bc: 46bd         	mov	sp, r7
 80044be: bdf0         	pop	{r4, r5, r6, r7, pc}

080044c0 <$d>:
 80044c0: 04 03 00 20  	.word	0x20000304
 80044c4: f8 9f 01 08  	.word	0x08019ff8
 80044c8: 04 a0 01 08  	.word	0x0801a004
 80044cc: 40 a0 01 08  	.word	0x0801a040

080044d0 <update_sample_pnt>:
; {
 80044d0: b480         	push	{r7}
 80044d2: b089         	sub	sp, #0x24
 80044d4: af00         	add	r7, sp, #0x0
 80044d6: 60f8         	str	r0, [r7, #0xc]
 80044d8: 60b9         	str	r1, [r7, #0x8]
 80044da: 607a         	str	r2, [r7, #0x4]
 80044dc: 603b         	str	r3, [r7]
; 	uint16_t tseg1_max = max->phase_seg1 + max->prop_seg;
 80044de: 6abb         	ldr	r3, [r7, #0x28]
 80044e0: 889a         	ldrh	r2, [r3, #0x4]
 80044e2: 6abb         	ldr	r3, [r7, #0x28]
 80044e4: 885b         	ldrh	r3, [r3, #0x2]
 80044e6: 4413         	add	r3, r2
 80044e8: 837b         	strh	r3, [r7, #0x1a]
; 	uint16_t tseg1_min = min->phase_seg1 + min->prop_seg;
 80044ea: 683b         	ldr	r3, [r7]
 80044ec: 889a         	ldrh	r2, [r3, #0x4]
 80044ee: 683b         	ldr	r3, [r7]
 80044f0: 885b         	ldrh	r3, [r3, #0x2]
 80044f2: 4413         	add	r3, r2
 80044f4: 833b         	strh	r3, [r7, #0x18]
; 	tseg2 = total_tq - (total_tq * sample_pnt) / 1000;
 80044f6: 68fb         	ldr	r3, [r7, #0xc]
 80044f8: b29a         	uxth	r2, r3
 80044fa: 68fb         	ldr	r3, [r7, #0xc]
 80044fc: 68b9         	ldr	r1, [r7, #0x8]
 80044fe: fb01 f303    	mul	r3, r1, r3
 8004502: 4952         	ldr	r1, [pc, #0x148]        @ 0x800464c <update_sample_pnt+0x17c>
 8004504: fba1 1303    	umull	r1, r3, r1, r3
 8004508: 099b         	lsrs	r3, r3, #0x6
 800450a: b29b         	uxth	r3, r3
 800450c: 1ad3         	subs	r3, r2, r3
 800450e: 83bb         	strh	r3, [r7, #0x1c]
; 	tseg2 = CLAMP(tseg2, min->phase_seg2, max->phase_seg2);
 8004510: 683b         	ldr	r3, [r7]
 8004512: 88db         	ldrh	r3, [r3, #0x6]
 8004514: 8bba         	ldrh	r2, [r7, #0x1c]
 8004516: 429a         	cmp	r2, r3
 8004518: d802         	bhi	0x8004520 <update_sample_pnt+0x50> @ imm = #0x4
 800451a: 683b         	ldr	r3, [r7]
 800451c: 88db         	ldrh	r3, [r3, #0x6]
 800451e: e006         	b	0x800452e <update_sample_pnt+0x5e> @ imm = #0xc
 8004520: 6abb         	ldr	r3, [r7, #0x28]
 8004522: 88db         	ldrh	r3, [r3, #0x6]
 8004524: 8bba         	ldrh	r2, [r7, #0x1c]
 8004526: 4293         	cmp	r3, r2
 8004528: bf28         	it	hs
 800452a: 4613         	movhs	r3, r2
 800452c: b29b         	uxth	r3, r3
 800452e: 83bb         	strh	r3, [r7, #0x1c]
; 	tseg1 = total_tq - CAN_SYNC_SEG - tseg2;
 8004530: 68fb         	ldr	r3, [r7, #0xc]
 8004532: b29a         	uxth	r2, r3
 8004534: 8bbb         	ldrh	r3, [r7, #0x1c]
 8004536: 1ad3         	subs	r3, r2, r3
 8004538: b29b         	uxth	r3, r3
 800453a: 3b01         	subs	r3, #0x1
 800453c: 83fb         	strh	r3, [r7, #0x1e]
; 	if (tseg1 > tseg1_max) {
 800453e: 8bfa         	ldrh	r2, [r7, #0x1e]
 8004540: 8b7b         	ldrh	r3, [r7, #0x1a]
 8004542: 429a         	cmp	r2, r3
 8004544: d910         	bls	0x8004568 <update_sample_pnt+0x98> @ imm = #0x20
; 		tseg1 = tseg1_max;
 8004546: 8b7b         	ldrh	r3, [r7, #0x1a]
 8004548: 83fb         	strh	r3, [r7, #0x1e]
; 		tseg2 = total_tq - CAN_SYNC_SEG - tseg1;
 800454a: 68fb         	ldr	r3, [r7, #0xc]
 800454c: b29a         	uxth	r2, r3
 800454e: 8bfb         	ldrh	r3, [r7, #0x1e]
 8004550: 1ad3         	subs	r3, r2, r3
 8004552: b29b         	uxth	r3, r3
 8004554: 3b01         	subs	r3, #0x1
 8004556: 83bb         	strh	r3, [r7, #0x1c]
; 		if (tseg2 > max->phase_seg2) {
 8004558: 6abb         	ldr	r3, [r7, #0x28]
 800455a: 88db         	ldrh	r3, [r3, #0x6]
 800455c: 8bba         	ldrh	r2, [r7, #0x1c]
 800455e: 429a         	cmp	r2, r3
 8004560: d917         	bls	0x8004592 <update_sample_pnt+0xc2> @ imm = #0x2e
; 			return -ENOTSUP;
 8004562: f06f 0385    	mvn	r3, #0x85
 8004566: e06c         	b	0x8004642 <update_sample_pnt+0x172> @ imm = #0xd8
; 	} else if (tseg1 < tseg1_min) {
 8004568: 8bfa         	ldrh	r2, [r7, #0x1e]
 800456a: 8b3b         	ldrh	r3, [r7, #0x18]
 800456c: 429a         	cmp	r2, r3
 800456e: d210         	bhs	0x8004592 <update_sample_pnt+0xc2> @ imm = #0x20
; 		tseg1 = tseg1_min;
 8004570: 8b3b         	ldrh	r3, [r7, #0x18]
 8004572: 83fb         	strh	r3, [r7, #0x1e]
; 		tseg2 = total_tq - CAN_SYNC_SEG - tseg1;
 8004574: 68fb         	ldr	r3, [r7, #0xc]
 8004576: b29a         	uxth	r2, r3
 8004578: 8bfb         	ldrh	r3, [r7, #0x1e]
 800457a: 1ad3         	subs	r3, r2, r3
 800457c: b29b         	uxth	r3, r3
 800457e: 3b01         	subs	r3, #0x1
 8004580: 83bb         	strh	r3, [r7, #0x1c]
; 		if (tseg2 < min->phase_seg2) {
 8004582: 683b         	ldr	r3, [r7]
 8004584: 88db         	ldrh	r3, [r3, #0x6]
 8004586: 8bba         	ldrh	r2, [r7, #0x1c]
 8004588: 429a         	cmp	r2, r3
 800458a: d202         	bhs	0x8004592 <update_sample_pnt+0xc2> @ imm = #0x4
; 			return -ENOTSUP;
 800458c: f06f 0385    	mvn	r3, #0x85
 8004590: e057         	b	0x8004642 <update_sample_pnt+0x172> @ imm = #0xae
; 	res->phase_seg2 = tseg2;
 8004592: 687b         	ldr	r3, [r7, #0x4]
 8004594: 8bba         	ldrh	r2, [r7, #0x1c]
 8004596: 80da         	strh	r2, [r3, #0x6]
; 	res->prop_seg = CLAMP(tseg1 / 2, min->prop_seg, max->prop_seg);
 8004598: 8bfb         	ldrh	r3, [r7, #0x1e]
 800459a: 085b         	lsrs	r3, r3, #0x1
 800459c: b29a         	uxth	r2, r3
 800459e: 683b         	ldr	r3, [r7]
 80045a0: 885b         	ldrh	r3, [r3, #0x2]
 80045a2: 429a         	cmp	r2, r3
 80045a4: d802         	bhi	0x80045ac <update_sample_pnt+0xdc> @ imm = #0x4
 80045a6: 683b         	ldr	r3, [r7]
 80045a8: 885b         	ldrh	r3, [r3, #0x2]
 80045aa: e008         	b	0x80045be <update_sample_pnt+0xee> @ imm = #0x10
 80045ac: 6abb         	ldr	r3, [r7, #0x28]
 80045ae: 885a         	ldrh	r2, [r3, #0x2]
 80045b0: 8bfb         	ldrh	r3, [r7, #0x1e]
 80045b2: 085b         	lsrs	r3, r3, #0x1
 80045b4: b29b         	uxth	r3, r3
 80045b6: 4293         	cmp	r3, r2
 80045b8: bf28         	it	hs
 80045ba: 4613         	movhs	r3, r2
 80045bc: b29b         	uxth	r3, r3
 80045be: 687a         	ldr	r2, [r7, #0x4]
 80045c0: 8053         	strh	r3, [r2, #0x2]
; 	res->phase_seg1 = tseg1 - res->prop_seg;
 80045c2: 687b         	ldr	r3, [r7, #0x4]
 80045c4: 885b         	ldrh	r3, [r3, #0x2]
 80045c6: 8bfa         	ldrh	r2, [r7, #0x1e]
 80045c8: 1ad3         	subs	r3, r2, r3
 80045ca: b29a         	uxth	r2, r3
 80045cc: 687b         	ldr	r3, [r7, #0x4]
 80045ce: 809a         	strh	r2, [r3, #0x4]
; 	if (res->phase_seg1 > max->phase_seg1) {
 80045d0: 687b         	ldr	r3, [r7, #0x4]
 80045d2: 889a         	ldrh	r2, [r3, #0x4]
 80045d4: 6abb         	ldr	r3, [r7, #0x28]
 80045d6: 889b         	ldrh	r3, [r3, #0x4]
 80045d8: 429a         	cmp	r2, r3
 80045da: d90b         	bls	0x80045f4 <update_sample_pnt+0x124> @ imm = #0x16
; 		res->phase_seg1 = max->phase_seg1;
 80045dc: 6abb         	ldr	r3, [r7, #0x28]
 80045de: 889a         	ldrh	r2, [r3, #0x4]
 80045e0: 687b         	ldr	r3, [r7, #0x4]
 80045e2: 809a         	strh	r2, [r3, #0x4]
; 		res->prop_seg = tseg1 - res->phase_seg1;
 80045e4: 687b         	ldr	r3, [r7, #0x4]
 80045e6: 889b         	ldrh	r3, [r3, #0x4]
 80045e8: 8bfa         	ldrh	r2, [r7, #0x1e]
 80045ea: 1ad3         	subs	r3, r2, r3
 80045ec: b29a         	uxth	r2, r3
 80045ee: 687b         	ldr	r3, [r7, #0x4]
 80045f0: 805a         	strh	r2, [r3, #0x2]
 80045f2: e010         	b	0x8004616 <update_sample_pnt+0x146> @ imm = #0x20
; 	} else if (res->phase_seg1 < min->phase_seg1) {
 80045f4: 687b         	ldr	r3, [r7, #0x4]
 80045f6: 889a         	ldrh	r2, [r3, #0x4]
 80045f8: 683b         	ldr	r3, [r7]
 80045fa: 889b         	ldrh	r3, [r3, #0x4]
 80045fc: 429a         	cmp	r2, r3
 80045fe: d20a         	bhs	0x8004616 <update_sample_pnt+0x146> @ imm = #0x14
; 		res->phase_seg1 = min->phase_seg1;
 8004600: 683b         	ldr	r3, [r7]
 8004602: 889a         	ldrh	r2, [r3, #0x4]
 8004604: 687b         	ldr	r3, [r7, #0x4]
 8004606: 809a         	strh	r2, [r3, #0x4]
; 		res->prop_seg = tseg1 - res->phase_seg1;
 8004608: 687b         	ldr	r3, [r7, #0x4]
 800460a: 889b         	ldrh	r3, [r3, #0x4]
 800460c: 8bfa         	ldrh	r2, [r7, #0x1e]
 800460e: 1ad3         	subs	r3, r2, r3
 8004610: b29a         	uxth	r2, r3
 8004612: 687b         	ldr	r3, [r7, #0x4]
 8004614: 805a         	strh	r2, [r3, #0x2]
; 	sample_pnt_res = (CAN_SYNC_SEG + tseg1) * 1000 / total_tq;
 8004616: 8bfb         	ldrh	r3, [r7, #0x1e]
 8004618: 3301         	adds	r3, #0x1
 800461a: f44f 727a    	mov.w	r2, #0x3e8
 800461e: fb02 f303    	mul	r3, r2, r3
 8004622: 461a         	mov	r2, r3
 8004624: 68fb         	ldr	r3, [r7, #0xc]
 8004626: fbb2 f3f3    	udiv	r3, r2, r3
 800462a: 617b         	str	r3, [r7, #0x14]
; 		sample_pnt_res - sample_pnt :
 800462c: 697a         	ldr	r2, [r7, #0x14]
 800462e: 68bb         	ldr	r3, [r7, #0x8]
 8004630: 429a         	cmp	r2, r3
 8004632: d903         	bls	0x800463c <update_sample_pnt+0x16c> @ imm = #0x6
 8004634: 697a         	ldr	r2, [r7, #0x14]
 8004636: 68bb         	ldr	r3, [r7, #0x8]
 8004638: 1ad3         	subs	r3, r2, r3
 800463a: e002         	b	0x8004642 <update_sample_pnt+0x172> @ imm = #0x4
; 		sample_pnt - sample_pnt_res;
 800463c: 68ba         	ldr	r2, [r7, #0x8]
 800463e: 697b         	ldr	r3, [r7, #0x14]
 8004640: 1ad3         	subs	r3, r2, r3
; }
 8004642: 4618         	mov	r0, r3
 8004644: 3724         	adds	r7, #0x24
 8004646: 46bd         	mov	sp, r7
 8004648: bc80         	pop	{r7}
 800464a: 4770         	bx	lr

0800464c <$d>:
 800464c: d3 4d 62 10  	.word	0x10624dd3

08004650 <sample_point_for_bitrate>:
; {
 8004650: b480         	push	{r7}
 8004652: b085         	sub	sp, #0x14
 8004654: af00         	add	r7, sp, #0x0
 8004656: 6078         	str	r0, [r7, #0x4]
; 	if (bitrate > 800000) {
 8004658: 687b         	ldr	r3, [r7, #0x4]
 800465a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800468c <sample_point_for_bitrate+0x3c>
 800465c: 4293         	cmp	r3, r2
 800465e: d903         	bls	0x8004668 <sample_point_for_bitrate+0x18> @ imm = #0x6
; 		sample_pnt = 750;
 8004660: f240 23ee    	movw	r3, #0x2ee
 8004664: 81fb         	strh	r3, [r7, #0xe]
 8004666: e00a         	b	0x800467e <sample_point_for_bitrate+0x2e> @ imm = #0x14
; 	} else if (bitrate > 500000) {
 8004668: 687b         	ldr	r3, [r7, #0x4]
 800466a: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8004690 <sample_point_for_bitrate+0x40>
 800466c: 4293         	cmp	r3, r2
 800466e: d903         	bls	0x8004678 <sample_point_for_bitrate+0x28> @ imm = #0x6
; 		sample_pnt = 800;
 8004670: f44f 7348    	mov.w	r3, #0x320
 8004674: 81fb         	strh	r3, [r7, #0xe]
 8004676: e002         	b	0x800467e <sample_point_for_bitrate+0x2e> @ imm = #0x4
; 		sample_pnt = 875;
 8004678: f240 336b    	movw	r3, #0x36b
 800467c: 81fb         	strh	r3, [r7, #0xe]
; 	return sample_pnt;
 800467e: 89fb         	ldrh	r3, [r7, #0xe]
; }
 8004680: 4618         	mov	r0, r3
 8004682: 3714         	adds	r7, #0x14
 8004684: 46bd         	mov	sp, r7
 8004686: bc80         	pop	{r7}
 8004688: 4770         	bx	lr
 800468a: bf00         	nop

0800468c <$d>:
 800468c: 00 35 0c 00  	.word	0x000c3500
 8004690: 20 a1 07 00  	.word	0x0007a120

08004694 <can_calc_timing_internal>:
; {
 8004694: b580         	push	{r7, lr}
 8004696: b094         	sub	sp, #0x50
 8004698: af06         	add	r7, sp, #0x18
 800469a: 60f8         	str	r0, [r7, #0xc]
 800469c: 60b9         	str	r1, [r7, #0x8]
 800469e: 607a         	str	r2, [r7, #0x4]
 80046a0: 603b         	str	r3, [r7]
; 	uint32_t total_tq = CAN_SYNC_SEG + max->prop_seg + max->phase_seg1 + max->phase_seg2;
 80046a2: 683b         	ldr	r3, [r7]
 80046a4: 885b         	ldrh	r3, [r3, #0x2]
 80046a6: 3301         	adds	r3, #0x1
 80046a8: 683a         	ldr	r2, [r7]
 80046aa: 8892         	ldrh	r2, [r2, #0x4]
 80046ac: 4413         	add	r3, r2
 80046ae: 683a         	ldr	r2, [r7]
 80046b0: 88d2         	ldrh	r2, [r2, #0x6]
 80046b2: 4413         	add	r3, r2
 80046b4: 62fb         	str	r3, [r7, #0x2c]
; 	struct can_timing tmp_res = { 0 };
 80046b6: f107 0314    	add.w	r3, r7, #0x14
 80046ba: 2200         	movs	r2, #0x0
 80046bc: 601a         	str	r2, [r3]
 80046be: 605a         	str	r2, [r3, #0x4]
 80046c0: 811a         	strh	r2, [r3, #0x8]
; 	int err_min = INT_MAX;
 80046c2: f06f 4300    	mvn	r3, #0x80000000
 80046c6: 637b         	str	r3, [r7, #0x34]
; 	if (bitrate == 0 || sample_pnt >= 1000) {
 80046c8: 6c3b         	ldr	r3, [r7, #0x40]
 80046ca: 2b00         	cmp	r3, #0x0
 80046cc: d004         	beq	0x80046d8 <can_calc_timing_internal+0x44> @ imm = #0x8
 80046ce: f8b7 3044    	ldrh.w	r3, [r7, #0x44]
 80046d2: f5b3 7f7a    	cmp.w	r3, #0x3e8
 80046d6: d302         	blo	0x80046de <can_calc_timing_internal+0x4a> @ imm = #0x4
; 		return -EINVAL;
 80046d8: f06f 0315    	mvn	r3, #0x15
 80046dc: e0b7         	b	0x800484e <can_calc_timing_internal+0x1ba> @ imm = #0x16e
; 	err = can_get_core_clock(dev, &core_clock);
 80046de: f107 0310    	add.w	r3, r7, #0x10
 80046e2: 4619         	mov	r1, r3
 80046e4: 68f8         	ldr	r0, [r7, #0xc]
 80046e6: f00d fba8    	bl	0x8011e3a <can_get_core_clock> @ imm = #0xd750
 80046ea: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 80046ec: 6abb         	ldr	r3, [r7, #0x28]
 80046ee: 2b00         	cmp	r3, #0x0
 80046f0: d002         	beq	0x80046f8 <can_calc_timing_internal+0x64> @ imm = #0x4
; 		return -EIO;
 80046f2: f06f 0304    	mvn	r3, #0x4
 80046f6: e0aa         	b	0x800484e <can_calc_timing_internal+0x1ba> @ imm = #0x154
; 	if (sample_pnt == 0U) {
 80046f8: f8b7 3044    	ldrh.w	r3, [r7, #0x44]
 80046fc: 2b00         	cmp	r3, #0x0
 80046fe: d105         	bne	0x800470c <can_calc_timing_internal+0x78> @ imm = #0xa
; 		sample_pnt = sample_point_for_bitrate(bitrate);
 8004700: 6c38         	ldr	r0, [r7, #0x40]
 8004702: f7ff ffa5    	bl	0x8004650 <sample_point_for_bitrate> @ imm = #-0xb6
 8004706: 4603         	mov	r3, r0
 8004708: f8a7 3044    	strh.w	r3, [r7, #0x44]
; 	for (prescaler = MAX(core_clock / (total_tq * bitrate), min->prescaler);
 800470c: 687b         	ldr	r3, [r7, #0x4]
 800470e: 891b         	ldrh	r3, [r3, #0x8]
 8004710: 4618         	mov	r0, r3
 8004712: 693a         	ldr	r2, [r7, #0x10]
 8004714: 6afb         	ldr	r3, [r7, #0x2c]
 8004716: 6c39         	ldr	r1, [r7, #0x40]
 8004718: fb01 f303    	mul	r3, r1, r3
 800471c: fbb2 f3f3    	udiv	r3, r2, r3
 8004720: 4283         	cmp	r3, r0
 8004722: bf38         	it	lo
 8004724: 4603         	movlo	r3, r0
 8004726: 633b         	str	r3, [r7, #0x30]
 8004728: e03e         	b	0x80047a8 <can_calc_timing_internal+0x114> @ imm = #0x7c
; 		if (core_clock % (prescaler * bitrate)) {
 800472a: 693b         	ldr	r3, [r7, #0x10]
 800472c: 6b3a         	ldr	r2, [r7, #0x30]
 800472e: 6c39         	ldr	r1, [r7, #0x40]
 8004730: fb01 f202    	mul	r2, r1, r2
 8004734: fbb3 f1f2    	udiv	r1, r3, r2
 8004738: fb01 f202    	mul	r2, r1, r2
 800473c: 1a9b         	subs	r3, r3, r2
 800473e: 2b00         	cmp	r3, #0x0
 8004740: d12c         	bne	0x800479c <can_calc_timing_internal+0x108> @ imm = #0x58
; 		total_tq = core_clock / (prescaler * bitrate);
 8004742: 693a         	ldr	r2, [r7, #0x10]
 8004744: 6b3b         	ldr	r3, [r7, #0x30]
 8004746: 6c39         	ldr	r1, [r7, #0x40]
 8004748: fb01 f303    	mul	r3, r1, r3
 800474c: fbb2 f3f3    	udiv	r3, r2, r3
 8004750: 62fb         	str	r3, [r7, #0x2c]
; 		err = update_sample_pnt(total_tq, sample_pnt, &tmp_res, min, max);
 8004752: f8b7 1044    	ldrh.w	r1, [r7, #0x44]
 8004756: f107 0214    	add.w	r2, r7, #0x14
 800475a: 683b         	ldr	r3, [r7]
 800475c: 9300         	str	r3, [sp]
 800475e: 687b         	ldr	r3, [r7, #0x4]
 8004760: 6af8         	ldr	r0, [r7, #0x2c]
 8004762: f7ff feb5    	bl	0x80044d0 <update_sample_pnt> @ imm = #-0x296
 8004766: 62b8         	str	r0, [r7, #0x28]
; 		if (err < 0) {
 8004768: 6abb         	ldr	r3, [r7, #0x28]
 800476a: 2b00         	cmp	r3, #0x0
 800476c: db18         	blt	0x80047a0 <can_calc_timing_internal+0x10c> @ imm = #0x30
; 		if (err < err_min) {
 800476e: 6aba         	ldr	r2, [r7, #0x28]
 8004770: 6b7b         	ldr	r3, [r7, #0x34]
 8004772: 429a         	cmp	r2, r3
 8004774: da15         	bge	0x80047a2 <can_calc_timing_internal+0x10e> @ imm = #0x2a
; 			err_min = err;
 8004776: 6abb         	ldr	r3, [r7, #0x28]
 8004778: 637b         	str	r3, [r7, #0x34]
; 			res->prop_seg = tmp_res.prop_seg;
 800477a: 8afa         	ldrh	r2, [r7, #0x16]
 800477c: 68bb         	ldr	r3, [r7, #0x8]
 800477e: 805a         	strh	r2, [r3, #0x2]
; 			res->phase_seg1 = tmp_res.phase_seg1;
 8004780: 8b3a         	ldrh	r2, [r7, #0x18]
 8004782: 68bb         	ldr	r3, [r7, #0x8]
 8004784: 809a         	strh	r2, [r3, #0x4]
; 			res->phase_seg2 = tmp_res.phase_seg2;
 8004786: 8b7a         	ldrh	r2, [r7, #0x1a]
 8004788: 68bb         	ldr	r3, [r7, #0x8]
 800478a: 80da         	strh	r2, [r3, #0x6]
; 			res->prescaler = (uint16_t)prescaler;
 800478c: 6b3b         	ldr	r3, [r7, #0x30]
 800478e: b29a         	uxth	r2, r3
 8004790: 68bb         	ldr	r3, [r7, #0x8]
 8004792: 811a         	strh	r2, [r3, #0x8]
; 			if (err == 0) {
 8004794: 6abb         	ldr	r3, [r7, #0x28]
 8004796: 2b00         	cmp	r3, #0x0
 8004798: d00d         	beq	0x80047b6 <can_calc_timing_internal+0x122> @ imm = #0x1a
 800479a: e002         	b	0x80047a2 <can_calc_timing_internal+0x10e> @ imm = #0x4
; 			continue;
 800479c: bf00         	nop
 800479e: e000         	b	0x80047a2 <can_calc_timing_internal+0x10e> @ imm = #0x0
; 			continue;
 80047a0: bf00         	nop
; 	     prescaler++) {
 80047a2: 6b3b         	ldr	r3, [r7, #0x30]
 80047a4: 3301         	adds	r3, #0x1
 80047a6: 633b         	str	r3, [r7, #0x30]
; 	     prescaler <= max->prescaler;
 80047a8: 683b         	ldr	r3, [r7]
 80047aa: 891b         	ldrh	r3, [r3, #0x8]
 80047ac: 461a         	mov	r2, r3
 80047ae: 6b3b         	ldr	r3, [r7, #0x30]
 80047b0: 4293         	cmp	r3, r2
 80047b2: ddba         	ble	0x800472a <can_calc_timing_internal+0x96> @ imm = #-0x8c
 80047b4: e000         	b	0x80047b8 <can_calc_timing_internal+0x124> @ imm = #0x0
; 				break;
 80047b6: bf00         	nop
; 	if (err_min != 0U) {
 80047b8: 6b7b         	ldr	r3, [r7, #0x34]
 80047ba: 2b00         	cmp	r3, #0x0
 80047bc: d01f         	beq	0x80047fe <can_calc_timing_internal+0x16a> @ imm = #0x3e
; 		LOG_DBG("Sample point error: %d 1/1000", err_min);
 80047be: 2303         	movs	r3, #0x3
 80047c0: 2b03         	cmp	r3, #0x3
 80047c2: d91c         	bls	0x80047fe <can_calc_timing_internal+0x16a> @ imm = #0x38
 80047c4: 2301         	movs	r3, #0x1
 80047c6: f887 3027    	strb.w	r3, [r7, #0x27]
 80047ca: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80047ce: f083 0301    	eor	r3, r3, #0x1
 80047d2: b2db         	uxtb	r3, r3
 80047d4: 2b00         	cmp	r3, #0x0
 80047d6: d112         	bne	0x80047fe <can_calc_timing_internal+0x16a> @ imm = #0x24
 80047d8: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8004858 <can_calc_timing_internal+0x1c4>
 80047da: 6819         	ldr	r1, [r3]
 80047dc: 6b7b         	ldr	r3, [r7, #0x34]
 80047de: 9304         	str	r3, [sp, #0x10]
 80047e0: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800485c <can_calc_timing_internal+0x1c8>
 80047e2: 9303         	str	r3, [sp, #0xc]
 80047e4: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8004860 <can_calc_timing_internal+0x1cc>
 80047e6: 9302         	str	r3, [sp, #0x8]
 80047e8: 2308         	movs	r3, #0x8
 80047ea: 9301         	str	r3, [sp, #0x4]
 80047ec: 2300         	movs	r3, #0x0
 80047ee: 9300         	str	r3, [sp]
 80047f0: 2300         	movs	r3, #0x0
 80047f2: 2204         	movs	r2, #0x4
 80047f4: 2000         	movs	r0, #0x0
 80047f6: f00d fb46    	bl	0x8011e86 <z_log_msg_runtime_create> @ imm = #0xd68c
 80047fa: 2300         	movs	r3, #0x0
 80047fc: 623b         	str	r3, [r7, #0x20]
; 	res->sjw = MIN(res->phase_seg1, res->phase_seg2 / 2);
 80047fe: 68bb         	ldr	r3, [r7, #0x8]
 8004800: 88db         	ldrh	r3, [r3, #0x6]
 8004802: 085b         	lsrs	r3, r3, #0x1
 8004804: b29a         	uxth	r2, r3
 8004806: 68bb         	ldr	r3, [r7, #0x8]
 8004808: 889b         	ldrh	r3, [r3, #0x4]
 800480a: 4293         	cmp	r3, r2
 800480c: bf28         	it	hs
 800480e: 4613         	movhs	r3, r2
 8004810: b29a         	uxth	r2, r3
 8004812: 68bb         	ldr	r3, [r7, #0x8]
 8004814: 801a         	strh	r2, [r3]
; 	res->sjw = CLAMP(res->sjw, min->sjw, max->sjw);
 8004816: 68bb         	ldr	r3, [r7, #0x8]
 8004818: 881a         	ldrh	r2, [r3]
 800481a: 687b         	ldr	r3, [r7, #0x4]
 800481c: 881b         	ldrh	r3, [r3]
 800481e: 429a         	cmp	r2, r3
 8004820: d802         	bhi	0x8004828 <can_calc_timing_internal+0x194> @ imm = #0x4
 8004822: 687b         	ldr	r3, [r7, #0x4]
 8004824: 881b         	ldrh	r3, [r3]
 8004826: e007         	b	0x8004838 <can_calc_timing_internal+0x1a4> @ imm = #0xe
 8004828: 683b         	ldr	r3, [r7]
 800482a: 881a         	ldrh	r2, [r3]
 800482c: 68bb         	ldr	r3, [r7, #0x8]
 800482e: 881b         	ldrh	r3, [r3]
 8004830: 4293         	cmp	r3, r2
 8004832: bf28         	it	hs
 8004834: 4613         	movhs	r3, r2
 8004836: b29b         	uxth	r3, r3
 8004838: 68ba         	ldr	r2, [r7, #0x8]
 800483a: 8013         	strh	r3, [r2]
; 	return err_min == INT_MAX ? -ENOTSUP : err_min;
 800483c: 6b7b         	ldr	r3, [r7, #0x34]
 800483e: f06f 4200    	mvn	r2, #0x80000000
 8004842: 4293         	cmp	r3, r2
 8004844: d001         	beq	0x800484a <can_calc_timing_internal+0x1b6> @ imm = #0x2
 8004846: 6b7b         	ldr	r3, [r7, #0x34]
 8004848: e001         	b	0x800484e <can_calc_timing_internal+0x1ba> @ imm = #0x2
 800484a: f06f 0385    	mvn	r3, #0x85
; }
 800484e: 4618         	mov	r0, r3
 8004850: 3738         	adds	r7, #0x38
 8004852: 46bd         	mov	sp, r7
 8004854: bd80         	pop	{r7, pc}
 8004856: bf00         	nop

08004858 <$d>:
 8004858: 04 03 00 20  	.word	0x20000304
 800485c: 90 b4 01 08  	.word	0x0801b490
 8004860: a8 a0 01 08  	.word	0x0801a0a8

08004864 <z_impl_can_calc_timing>:
; {
 8004864: b580         	push	{r7, lr}
 8004866: b088         	sub	sp, #0x20
 8004868: af02         	add	r7, sp, #0x8
 800486a: 60f8         	str	r0, [r7, #0xc]
 800486c: 60b9         	str	r1, [r7, #0x8]
 800486e: 607a         	str	r2, [r7, #0x4]
 8004870: 807b         	strh	r3, [r7, #0x2]
; 	const struct can_timing *min = can_get_timing_min(dev);
 8004872: 68f8         	ldr	r0, [r7, #0xc]
 8004874: f00d faef    	bl	0x8011e56 <can_get_timing_min> @ imm = #0xd5de
 8004878: 6178         	str	r0, [r7, #0x14]
; 	const struct can_timing *max = can_get_timing_max(dev);
 800487a: 68f8         	ldr	r0, [r7, #0xc]
 800487c: f00d faf7    	bl	0x8011e6e <can_get_timing_max> @ imm = #0xd5ee
 8004880: 6138         	str	r0, [r7, #0x10]
; 	if (bitrate > 1000000) {
 8004882: 687b         	ldr	r3, [r7, #0x4]
 8004884: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80048b0 <z_impl_can_calc_timing+0x4c>
 8004886: 4293         	cmp	r3, r2
 8004888: d902         	bls	0x8004890 <z_impl_can_calc_timing+0x2c> @ imm = #0x4
; 		return -EINVAL;
 800488a: f06f 0315    	mvn	r3, #0x15
 800488e: e00a         	b	0x80048a6 <z_impl_can_calc_timing+0x42> @ imm = #0x14
; 	return can_calc_timing_internal(dev, res, min, max, bitrate, sample_pnt);
 8004890: 887b         	ldrh	r3, [r7, #0x2]
 8004892: 9301         	str	r3, [sp, #0x4]
 8004894: 687b         	ldr	r3, [r7, #0x4]
 8004896: 9300         	str	r3, [sp]
 8004898: 693b         	ldr	r3, [r7, #0x10]
 800489a: 697a         	ldr	r2, [r7, #0x14]
 800489c: 68b9         	ldr	r1, [r7, #0x8]
 800489e: 68f8         	ldr	r0, [r7, #0xc]
 80048a0: f7ff fef8    	bl	0x8004694 <can_calc_timing_internal> @ imm = #-0x210
 80048a4: 4603         	mov	r3, r0
; }
 80048a6: 4618         	mov	r0, r3
 80048a8: 3718         	adds	r7, #0x18
 80048aa: 46bd         	mov	sp, r7
 80048ac: bd80         	pop	{r7, pc}
 80048ae: bf00         	nop

080048b0 <$d>:
 80048b0: 40 42 0f 00  	.word	0x000f4240

080048b4 <can_stm32_rx_isr_handler>:
; {
 80048b4: b580         	push	{r7, lr}
 80048b6: b098         	sub	sp, #0x60
 80048b8: af06         	add	r7, sp, #0x18
 80048ba: 6078         	str	r0, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 80048bc: 687b         	ldr	r3, [r7, #0x4]
 80048be: 691b         	ldr	r3, [r3, #0x10]
 80048c0: 63fb         	str	r3, [r7, #0x3c]
; 	const struct can_stm32_config *cfg = dev->config;
 80048c2: 687b         	ldr	r3, [r7, #0x4]
 80048c4: 685b         	ldr	r3, [r3, #0x4]
 80048c6: 63bb         	str	r3, [r7, #0x38]
; 	CAN_TypeDef *can = cfg->can;
 80048c8: 6bbb         	ldr	r3, [r7, #0x38]
 80048ca: 695b         	ldr	r3, [r3, #0x14]
 80048cc: 637b         	str	r3, [r7, #0x34]
; 	can_rx_callback_t callback = NULL;
 80048ce: 2300         	movs	r3, #0x0
 80048d0: 643b         	str	r3, [r7, #0x40]
; 	while (can->RF0R & CAN_RF0R_FMP0) {
 80048d2: e061         	b	0x8004998 <can_stm32_rx_isr_handler+0xe4> @ imm = #0xc2
; 		mbox = &can->sFIFOMailBox[0];
 80048d4: 6b7b         	ldr	r3, [r7, #0x34]
 80048d6: f503 73d8    	add.w	r3, r3, #0x1b0
 80048da: 62bb         	str	r3, [r7, #0x28]
; 		filter_id = ((mbox->RDTR & CAN_RDT0R_FMI) >> CAN_RDT0R_FMI_Pos);
 80048dc: 6abb         	ldr	r3, [r7, #0x28]
 80048de: 685b         	ldr	r3, [r3, #0x4]
 80048e0: 0a1b         	lsrs	r3, r3, #0x8
 80048e2: b2db         	uxtb	r3, r3
 80048e4: 627b         	str	r3, [r7, #0x24]
; 		LOG_DBG("Message on filter_id %d", filter_id);
 80048e6: 2303         	movs	r3, #0x3
 80048e8: 2b03         	cmp	r3, #0x3
 80048ea: d91c         	bls	0x8004926 <can_stm32_rx_isr_handler+0x72> @ imm = #0x38
 80048ec: 2301         	movs	r3, #0x1
 80048ee: f887 3023    	strb.w	r3, [r7, #0x23]
 80048f2: f897 3023    	ldrb.w	r3, [r7, #0x23]
 80048f6: f083 0301    	eor	r3, r3, #0x1
 80048fa: b2db         	uxtb	r3, r3
 80048fc: 2b00         	cmp	r3, #0x0
 80048fe: d112         	bne	0x8004926 <can_stm32_rx_isr_handler+0x72> @ imm = #0x24
 8004900: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x80049f4 <can_stm32_rx_isr_handler+0x140>
 8004902: 6819         	ldr	r1, [r3]
 8004904: 6a7b         	ldr	r3, [r7, #0x24]
 8004906: 9304         	str	r3, [sp, #0x10]
 8004908: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x80049f8 <can_stm32_rx_isr_handler+0x144>
 800490a: 9303         	str	r3, [sp, #0xc]
 800490c: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x80049fc <can_stm32_rx_isr_handler+0x148>
 800490e: 9302         	str	r3, [sp, #0x8]
 8004910: 2308         	movs	r3, #0x8
 8004912: 9301         	str	r3, [sp, #0x4]
 8004914: 2300         	movs	r3, #0x0
 8004916: 9300         	str	r3, [sp]
 8004918: 2300         	movs	r3, #0x0
 800491a: 2204         	movs	r2, #0x4
 800491c: 2000         	movs	r0, #0x0
 800491e: f00d fc6f    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd8de
 8004922: 2300         	movs	r3, #0x0
 8004924: 61fb         	str	r3, [r7, #0x1c]
; 		can_stm32_rx_fifo_pop(mbox, &frame);
 8004926: f107 0308    	add.w	r3, r7, #0x8
 800492a: 4619         	mov	r1, r3
 800492c: 6ab8         	ldr	r0, [r7, #0x28]
 800492e: f00d fc9e    	bl	0x801226e <can_stm32_rx_fifo_pop> @ imm = #0xd93c
; 		if (filter_id < CONFIG_CAN_MAX_EXT_ID_FILTER) {
 8004932: 6a7b         	ldr	r3, [r7, #0x24]
 8004934: 2b06         	cmp	r3, #0x6
 8004936: dc0d         	bgt	0x8004954 <can_stm32_rx_isr_handler+0xa0> @ imm = #0x1a
; 			callback = data->rx_cb_ext[filter_id];
 8004938: 6bfa         	ldr	r2, [r7, #0x3c]
 800493a: 6a7b         	ldr	r3, [r7, #0x24]
 800493c: 3320         	adds	r3, #0x20
 800493e: 009b         	lsls	r3, r3, #0x2
 8004940: 4413         	add	r3, r2
 8004942: 685b         	ldr	r3, [r3, #0x4]
 8004944: 643b         	str	r3, [r7, #0x40]
; 			cb_arg = data->cb_arg_ext[filter_id];
 8004946: 6bfb         	ldr	r3, [r7, #0x3c]
 8004948: 6a7a         	ldr	r2, [r7, #0x24]
 800494a: 3236         	adds	r2, #0x36
 800494c: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8004950: 647b         	str	r3, [r7, #0x44]
 8004952: e012         	b	0x800497a <can_stm32_rx_isr_handler+0xc6> @ imm = #0x24
; 		} else if (filter_id < CAN_STM32_MAX_FILTER_ID) {
 8004954: 6a7b         	ldr	r3, [r7, #0x24]
 8004956: 2b22         	cmp	r3, #0x22
 8004958: dc0f         	bgt	0x800497a <can_stm32_rx_isr_handler+0xc6> @ imm = #0x1e
; 			index = filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER;
 800495a: 6a7b         	ldr	r3, [r7, #0x24]
 800495c: 3b07         	subs	r3, #0x7
 800495e: 61bb         	str	r3, [r7, #0x18]
; 			callback = data->rx_cb_std[index];
 8004960: 6bfa         	ldr	r2, [r7, #0x3c]
 8004962: 69bb         	ldr	r3, [r7, #0x18]
 8004964: 3312         	adds	r3, #0x12
 8004966: 009b         	lsls	r3, r3, #0x2
 8004968: 4413         	add	r3, r2
 800496a: 685b         	ldr	r3, [r3, #0x4]
 800496c: 643b         	str	r3, [r7, #0x40]
; 			cb_arg = data->cb_arg_std[index];
 800496e: 6bfb         	ldr	r3, [r7, #0x3c]
 8004970: 69ba         	ldr	r2, [r7, #0x18]
 8004972: 3228         	adds	r2, #0x28
 8004974: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8004978: 647b         	str	r3, [r7, #0x44]
; 		if (callback) {
 800497a: 6c3b         	ldr	r3, [r7, #0x40]
 800497c: 2b00         	cmp	r3, #0x0
 800497e: d005         	beq	0x800498c <can_stm32_rx_isr_handler+0xd8> @ imm = #0xa
; 			callback(dev, &frame, cb_arg);
 8004980: f107 0108    	add.w	r1, r7, #0x8
 8004984: 6c3b         	ldr	r3, [r7, #0x40]
 8004986: 6c7a         	ldr	r2, [r7, #0x44]
 8004988: 6878         	ldr	r0, [r7, #0x4]
 800498a: 4798         	blx	r3
; 		can->RF0R |= CAN_RF0R_RFOM0;
 800498c: 6b7b         	ldr	r3, [r7, #0x34]
 800498e: 68db         	ldr	r3, [r3, #0xc]
 8004990: f043 0220    	orr	r2, r3, #0x20
 8004994: 6b7b         	ldr	r3, [r7, #0x34]
 8004996: 60da         	str	r2, [r3, #0xc]
; 	while (can->RF0R & CAN_RF0R_FMP0) {
 8004998: 6b7b         	ldr	r3, [r7, #0x34]
 800499a: 68db         	ldr	r3, [r3, #0xc]
 800499c: f003 0303    	and	r3, r3, #0x3
 80049a0: 2b00         	cmp	r3, #0x0
 80049a2: d197         	bne	0x80048d4 <can_stm32_rx_isr_handler+0x20> @ imm = #-0xd2
; 	if (can->RF0R & CAN_RF0R_FOVR0) {
 80049a4: 6b7b         	ldr	r3, [r7, #0x34]
 80049a6: 68db         	ldr	r3, [r3, #0xc]
 80049a8: f003 0310    	and	r3, r3, #0x10
 80049ac: 2b00         	cmp	r3, #0x0
 80049ae: d01c         	beq	0x80049ea <can_stm32_rx_isr_handler+0x136> @ imm = #0x38
; 		LOG_ERR("RX FIFO Overflow");
 80049b0: 2303         	movs	r3, #0x3
 80049b2: 2b00         	cmp	r3, #0x0
 80049b4: d019         	beq	0x80049ea <can_stm32_rx_isr_handler+0x136> @ imm = #0x32
 80049b6: 2301         	movs	r3, #0x1
 80049b8: f887 3033    	strb.w	r3, [r7, #0x33]
 80049bc: f897 3033    	ldrb.w	r3, [r7, #0x33]
 80049c0: f083 0301    	eor	r3, r3, #0x1
 80049c4: b2db         	uxtb	r3, r3
 80049c6: 2b00         	cmp	r3, #0x0
 80049c8: d10f         	bne	0x80049ea <can_stm32_rx_isr_handler+0x136> @ imm = #0x1e
 80049ca: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80049f4 <can_stm32_rx_isr_handler+0x140>
 80049cc: 6819         	ldr	r1, [r3]
 80049ce: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004a00 <can_stm32_rx_isr_handler+0x14c>
 80049d0: 9302         	str	r3, [sp, #0x8]
 80049d2: 2300         	movs	r3, #0x0
 80049d4: 9301         	str	r3, [sp, #0x4]
 80049d6: 2300         	movs	r3, #0x0
 80049d8: 9300         	str	r3, [sp]
 80049da: 2300         	movs	r3, #0x0
 80049dc: 2201         	movs	r2, #0x1
 80049de: 2000         	movs	r0, #0x0
 80049e0: f00d fc0e    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd81c
 80049e4: 2300         	movs	r3, #0x0
 80049e6: 62fb         	str	r3, [r7, #0x2c]
; }
 80049e8: e7ff         	b	0x80049ea <can_stm32_rx_isr_handler+0x136> @ imm = #-0x2
 80049ea: bf00         	nop
 80049ec: 3748         	adds	r7, #0x48
 80049ee: 46bd         	mov	sp, r7
 80049f0: bd80         	pop	{r7, pc}
 80049f2: bf00         	nop

080049f4 <$d>:
 80049f4: 08 03 00 20  	.word	0x20000308
 80049f8: 88 b5 01 08  	.word	0x0801b588
 80049fc: d8 a0 01 08  	.word	0x0801a0d8
 8004a00: f4 a0 01 08  	.word	0x0801a0f4

08004a04 <can_stm32_enter_init_mode>:
; {
 8004a04: b580         	push	{r7, lr}
 8004a06: b084         	sub	sp, #0x10
 8004a08: af00         	add	r7, sp, #0x0
 8004a0a: 6078         	str	r0, [r7, #0x4]
; 	can->MCR |= CAN_MCR_INRQ;
 8004a0c: 687b         	ldr	r3, [r7, #0x4]
 8004a0e: 681b         	ldr	r3, [r3]
 8004a10: f043 0201    	orr	r2, r3, #0x1
 8004a14: 687b         	ldr	r3, [r7, #0x4]
 8004a16: 601a         	str	r2, [r3]
; 	start_time = k_cycle_get_32();
 8004a18: f00d faf8    	bl	0x801200c <k_cycle_get_32> @ imm = #0xd5f0
 8004a1c: 60f8         	str	r0, [r7, #0xc]
; 	while ((can->MSR & CAN_MSR_INAK) == 0U) {
 8004a1e: e010         	b	0x8004a42 <can_stm32_enter_init_mode+0x3e> @ imm = #0x20
; 		if (k_cycle_get_32() - start_time > CAN_INIT_TIMEOUT) {
 8004a20: f00d faf4    	bl	0x801200c <k_cycle_get_32> @ imm = #0xd5e8
 8004a24: 4602         	mov	r2, r0
 8004a26: 68fb         	ldr	r3, [r7, #0xc]
 8004a28: 1ad3         	subs	r3, r2, r3
 8004a2a: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8004a58 <can_stm32_enter_init_mode+0x54>
 8004a2c: 4293         	cmp	r3, r2
 8004a2e: d908         	bls	0x8004a42 <can_stm32_enter_init_mode+0x3e> @ imm = #0x10
; 			can->MCR &= ~CAN_MCR_INRQ;
 8004a30: 687b         	ldr	r3, [r7, #0x4]
 8004a32: 681b         	ldr	r3, [r3]
 8004a34: f023 0201    	bic	r2, r3, #0x1
 8004a38: 687b         	ldr	r3, [r7, #0x4]
 8004a3a: 601a         	str	r2, [r3]
; 			return -EAGAIN;
 8004a3c: f06f 030a    	mvn	r3, #0xa
 8004a40: e006         	b	0x8004a50 <can_stm32_enter_init_mode+0x4c> @ imm = #0xc
; 	while ((can->MSR & CAN_MSR_INAK) == 0U) {
 8004a42: 687b         	ldr	r3, [r7, #0x4]
 8004a44: 685b         	ldr	r3, [r3, #0x4]
 8004a46: f003 0301    	and	r3, r3, #0x1
 8004a4a: 2b00         	cmp	r3, #0x0
 8004a4c: d0e8         	beq	0x8004a20 <can_stm32_enter_init_mode+0x1c> @ imm = #-0x30
; 	return 0;
 8004a4e: 2300         	movs	r3, #0x0
; }
 8004a50: 4618         	mov	r0, r3
 8004a52: 3710         	adds	r7, #0x10
 8004a54: 46bd         	mov	sp, r7
 8004a56: bd80         	pop	{r7, pc}

08004a58 <$d>:
 8004a58: 80 a2 19 00  	.word	0x0019a280

08004a5c <can_stm32_leave_init_mode>:
; {
 8004a5c: b580         	push	{r7, lr}
 8004a5e: b084         	sub	sp, #0x10
 8004a60: af00         	add	r7, sp, #0x0
 8004a62: 6078         	str	r0, [r7, #0x4]
; 	can->MCR &= ~CAN_MCR_INRQ;
 8004a64: 687b         	ldr	r3, [r7, #0x4]
 8004a66: 681b         	ldr	r3, [r3]
 8004a68: f023 0201    	bic	r2, r3, #0x1
 8004a6c: 687b         	ldr	r3, [r7, #0x4]
 8004a6e: 601a         	str	r2, [r3]
; 	start_time = k_cycle_get_32();
 8004a70: f00d facc    	bl	0x801200c <k_cycle_get_32> @ imm = #0xd598
 8004a74: 60f8         	str	r0, [r7, #0xc]
; 	while ((can->MSR & CAN_MSR_INAK) != 0U) {
 8004a76: e00a         	b	0x8004a8e <can_stm32_leave_init_mode+0x32> @ imm = #0x14
; 		if (k_cycle_get_32() - start_time > CAN_INIT_TIMEOUT) {
 8004a78: f00d fac8    	bl	0x801200c <k_cycle_get_32> @ imm = #0xd590
 8004a7c: 4602         	mov	r2, r0
 8004a7e: 68fb         	ldr	r3, [r7, #0xc]
 8004a80: 1ad3         	subs	r3, r2, r3
 8004a82: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8004aa4 <can_stm32_leave_init_mode+0x48>
 8004a84: 4293         	cmp	r3, r2
 8004a86: d902         	bls	0x8004a8e <can_stm32_leave_init_mode+0x32> @ imm = #0x4
; 			return -EAGAIN;
 8004a88: f06f 030a    	mvn	r3, #0xa
 8004a8c: e006         	b	0x8004a9c <can_stm32_leave_init_mode+0x40> @ imm = #0xc
; 	while ((can->MSR & CAN_MSR_INAK) != 0U) {
 8004a8e: 687b         	ldr	r3, [r7, #0x4]
 8004a90: 685b         	ldr	r3, [r3, #0x4]
 8004a92: f003 0301    	and	r3, r3, #0x1
 8004a96: 2b00         	cmp	r3, #0x0
 8004a98: d1ee         	bne	0x8004a78 <can_stm32_leave_init_mode+0x1c> @ imm = #-0x24
; 	return 0;
 8004a9a: 2300         	movs	r3, #0x0
; }
 8004a9c: 4618         	mov	r0, r3
 8004a9e: 3710         	adds	r7, #0x10
 8004aa0: 46bd         	mov	sp, r7
 8004aa2: bd80         	pop	{r7, pc}

08004aa4 <$d>:
 8004aa4: 80 a2 19 00  	.word	0x0019a280

08004aa8 <can_stm32_leave_sleep_mode>:
; {
 8004aa8: b580         	push	{r7, lr}
 8004aaa: b084         	sub	sp, #0x10
 8004aac: af00         	add	r7, sp, #0x0
 8004aae: 6078         	str	r0, [r7, #0x4]
; 	can->MCR &= ~CAN_MCR_SLEEP;
 8004ab0: 687b         	ldr	r3, [r7, #0x4]
 8004ab2: 681b         	ldr	r3, [r3]
 8004ab4: f023 0202    	bic	r2, r3, #0x2
 8004ab8: 687b         	ldr	r3, [r7, #0x4]
 8004aba: 601a         	str	r2, [r3]
; 	start_time = k_cycle_get_32();
 8004abc: f00d faa6    	bl	0x801200c <k_cycle_get_32> @ imm = #0xd54c
 8004ac0: 60f8         	str	r0, [r7, #0xc]
; 	while ((can->MSR & CAN_MSR_SLAK) != 0) {
 8004ac2: e00a         	b	0x8004ada <can_stm32_leave_sleep_mode+0x32> @ imm = #0x14
; 		if (k_cycle_get_32() - start_time > CAN_INIT_TIMEOUT) {
 8004ac4: f00d faa2    	bl	0x801200c <k_cycle_get_32> @ imm = #0xd544
 8004ac8: 4602         	mov	r2, r0
 8004aca: 68fb         	ldr	r3, [r7, #0xc]
 8004acc: 1ad3         	subs	r3, r2, r3
 8004ace: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8004af0 <can_stm32_leave_sleep_mode+0x48>
 8004ad0: 4293         	cmp	r3, r2
 8004ad2: d902         	bls	0x8004ada <can_stm32_leave_sleep_mode+0x32> @ imm = #0x4
; 			return -EAGAIN;
 8004ad4: f06f 030a    	mvn	r3, #0xa
 8004ad8: e006         	b	0x8004ae8 <can_stm32_leave_sleep_mode+0x40> @ imm = #0xc
; 	while ((can->MSR & CAN_MSR_SLAK) != 0) {
 8004ada: 687b         	ldr	r3, [r7, #0x4]
 8004adc: 685b         	ldr	r3, [r3, #0x4]
 8004ade: f003 0302    	and	r3, r3, #0x2
 8004ae2: 2b00         	cmp	r3, #0x0
 8004ae4: d1ee         	bne	0x8004ac4 <can_stm32_leave_sleep_mode+0x1c> @ imm = #-0x24
; 	return 0;
 8004ae6: 2300         	movs	r3, #0x0
; }
 8004ae8: 4618         	mov	r0, r3
 8004aea: 3710         	adds	r7, #0x10
 8004aec: 46bd         	mov	sp, r7
 8004aee: bd80         	pop	{r7, pc}

08004af0 <$d>:
 8004af0: 80 a2 19 00  	.word	0x0019a280

08004af4 <can_stm32_start>:
; {
 8004af4: b580         	push	{r7, lr}
 8004af6: b08e         	sub	sp, #0x38
 8004af8: af04         	add	r7, sp, #0x10
 8004afa: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8004afc: 687b         	ldr	r3, [r7, #0x4]
 8004afe: 685b         	ldr	r3, [r3, #0x4]
 8004b00: 623b         	str	r3, [r7, #0x20]
; 	struct can_stm32_data *data = dev->data;
 8004b02: 687b         	ldr	r3, [r7, #0x4]
 8004b04: 691b         	ldr	r3, [r3, #0x10]
 8004b06: 61fb         	str	r3, [r7, #0x1c]
; 	CAN_TypeDef *can = cfg->can;
 8004b08: 6a3b         	ldr	r3, [r7, #0x20]
 8004b0a: 695b         	ldr	r3, [r3, #0x14]
 8004b0c: 61bb         	str	r3, [r7, #0x18]
; 	int ret = 0;
 8004b0e: 2300         	movs	r3, #0x0
 8004b10: 627b         	str	r3, [r7, #0x24]
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8004b12: 69fb         	ldr	r3, [r7, #0x1c]
 8004b14: f103 0110    	add.w	r1, r3, #0x10
 8004b18: f04f 32ff    	mov.w	r2, #0xffffffff
 8004b1c: f04f 33ff    	mov.w	r3, #0xffffffff
 8004b20: 4608         	mov	r0, r1
 8004b22: f00d fa86    	bl	0x8012032 <k_mutex_lock> @ imm = #0xd50c
; 	if (data->common.started) {
 8004b26: 69fb         	ldr	r3, [r7, #0x1c]
 8004b28: 791b         	ldrb	r3, [r3, #0x4]
 8004b2a: 2b00         	cmp	r3, #0x0
 8004b2c: d003         	beq	0x8004b36 <can_stm32_start+0x42> @ imm = #0x6
; 		ret = -EALREADY;
 8004b2e: f06f 0377    	mvn	r3, #0x77
 8004b32: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 8004b34: e05e         	b	0x8004bf4 <can_stm32_start+0x100> @ imm = #0xbc
; 	if (cfg->common.phy != NULL) {
 8004b36: 6a3b         	ldr	r3, [r7, #0x20]
 8004b38: 681b         	ldr	r3, [r3]
 8004b3a: 2b00         	cmp	r3, #0x0
 8004b3c: d029         	beq	0x8004b92 <can_stm32_start+0x9e> @ imm = #0x52
; 		ret = can_transceiver_enable(cfg->common.phy, data->common.mode);
 8004b3e: 6a3b         	ldr	r3, [r7, #0x20]
 8004b40: 681a         	ldr	r2, [r3]
 8004b42: 69fb         	ldr	r3, [r7, #0x1c]
 8004b44: 681b         	ldr	r3, [r3]
 8004b46: 4619         	mov	r1, r3
 8004b48: 4610         	mov	r0, r2
 8004b4a: f00d fad9    	bl	0x8012100 <can_transceiver_enable> @ imm = #0xd5b2
 8004b4e: 6278         	str	r0, [r7, #0x24]
; 		if (ret != 0) {
 8004b50: 6a7b         	ldr	r3, [r7, #0x24]
 8004b52: 2b00         	cmp	r3, #0x0
 8004b54: d01d         	beq	0x8004b92 <can_stm32_start+0x9e> @ imm = #0x3a
; 			LOG_ERR("failed to enable CAN transceiver (err %d)", ret);
 8004b56: 2303         	movs	r3, #0x3
 8004b58: 2b00         	cmp	r3, #0x0
 8004b5a: d019         	beq	0x8004b90 <can_stm32_start+0x9c> @ imm = #0x32
 8004b5c: 2301         	movs	r3, #0x1
 8004b5e: 75fb         	strb	r3, [r7, #0x17]
 8004b60: 7dfb         	ldrb	r3, [r7, #0x17]
 8004b62: f083 0301    	eor	r3, r3, #0x1
 8004b66: b2db         	uxtb	r3, r3
 8004b68: 2b00         	cmp	r3, #0x0
 8004b6a: d111         	bne	0x8004b90 <can_stm32_start+0x9c> @ imm = #0x22
 8004b6c: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8004c0c <can_stm32_start+0x118>
 8004b6e: 6819         	ldr	r1, [r3]
 8004b70: 6a7b         	ldr	r3, [r7, #0x24]
 8004b72: 9303         	str	r3, [sp, #0xc]
 8004b74: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8004c10 <can_stm32_start+0x11c>
 8004b76: 9302         	str	r3, [sp, #0x8]
 8004b78: 2300         	movs	r3, #0x0
 8004b7a: 9301         	str	r3, [sp, #0x4]
 8004b7c: 2300         	movs	r3, #0x0
 8004b7e: 9300         	str	r3, [sp]
 8004b80: 2300         	movs	r3, #0x0
 8004b82: 2201         	movs	r2, #0x1
 8004b84: 2000         	movs	r0, #0x0
 8004b86: f00d fb3b    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd676
 8004b8a: 2300         	movs	r3, #0x0
 8004b8c: 613b         	str	r3, [r7, #0x10]
; 			goto unlock;
 8004b8e: e031         	b	0x8004bf4 <can_stm32_start+0x100> @ imm = #0x62
 8004b90: e030         	b	0x8004bf4 <can_stm32_start+0x100> @ imm = #0x60
; 	ret = can_stm32_leave_init_mode(can);
 8004b92: 69b8         	ldr	r0, [r7, #0x18]
 8004b94: f7ff ff62    	bl	0x8004a5c <can_stm32_leave_init_mode> @ imm = #-0x13c
 8004b98: 6278         	str	r0, [r7, #0x24]
; 	if (ret < 0) {
 8004b9a: 6a7b         	ldr	r3, [r7, #0x24]
 8004b9c: 2b00         	cmp	r3, #0x0
 8004b9e: da26         	bge	0x8004bee <can_stm32_start+0xfa> @ imm = #0x4c
; 		LOG_ERR("Failed to leave init mode");
 8004ba0: 2303         	movs	r3, #0x3
 8004ba2: 2b00         	cmp	r3, #0x0
 8004ba4: d016         	beq	0x8004bd4 <can_stm32_start+0xe0> @ imm = #0x2c
 8004ba6: 2301         	movs	r3, #0x1
 8004ba8: 73fb         	strb	r3, [r7, #0xf]
 8004baa: 7bfb         	ldrb	r3, [r7, #0xf]
 8004bac: f083 0301    	eor	r3, r3, #0x1
 8004bb0: b2db         	uxtb	r3, r3
 8004bb2: 2b00         	cmp	r3, #0x0
 8004bb4: d10e         	bne	0x8004bd4 <can_stm32_start+0xe0> @ imm = #0x1c
 8004bb6: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8004c0c <can_stm32_start+0x118>
 8004bb8: 6819         	ldr	r1, [r3]
 8004bba: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8004c14 <can_stm32_start+0x120>
 8004bbc: 9302         	str	r3, [sp, #0x8]
 8004bbe: 2300         	movs	r3, #0x0
 8004bc0: 9301         	str	r3, [sp, #0x4]
 8004bc2: 2300         	movs	r3, #0x0
 8004bc4: 9300         	str	r3, [sp]
 8004bc6: 2300         	movs	r3, #0x0
 8004bc8: 2201         	movs	r2, #0x1
 8004bca: 2000         	movs	r0, #0x0
 8004bcc: f00d fb18    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd630
 8004bd0: 2300         	movs	r3, #0x0
 8004bd2: 60bb         	str	r3, [r7, #0x8]
; 		if (cfg->common.phy != NULL) {
 8004bd4: 6a3b         	ldr	r3, [r7, #0x20]
 8004bd6: 681b         	ldr	r3, [r3]
 8004bd8: 2b00         	cmp	r3, #0x0
 8004bda: d004         	beq	0x8004be6 <can_stm32_start+0xf2> @ imm = #0x8
; 			(void)can_transceiver_disable(cfg->common.phy);
 8004bdc: 6a3b         	ldr	r3, [r7, #0x20]
 8004bde: 681b         	ldr	r3, [r3]
 8004be0: 4618         	mov	r0, r3
 8004be2: f00d fa9f    	bl	0x8012124 <can_transceiver_disable> @ imm = #0xd53e
; 		ret = -EIO;
 8004be6: f06f 0304    	mvn	r3, #0x4
 8004bea: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 8004bec: e002         	b	0x8004bf4 <can_stm32_start+0x100> @ imm = #0x4
; 	data->common.started = true;
 8004bee: 69fb         	ldr	r3, [r7, #0x1c]
 8004bf0: 2201         	movs	r2, #0x1
 8004bf2: 711a         	strb	r2, [r3, #0x4]
; 	k_mutex_unlock(&data->inst_mutex);
 8004bf4: 69fb         	ldr	r3, [r7, #0x1c]
 8004bf6: 3310         	adds	r3, #0x10
 8004bf8: 4618         	mov	r0, r3
 8004bfa: f00d fa2a    	bl	0x8012052 <k_mutex_unlock> @ imm = #0xd454
; 	return ret;
 8004bfe: 6a79         	ldr	r1, [r7, #0x24]
 8004c00: 460b         	mov	r3, r1
; }
 8004c02: 4618         	mov	r0, r3
 8004c04: 3728         	adds	r7, #0x28
 8004c06: 46bd         	mov	sp, r7
 8004c08: bd80         	pop	{r7, pc}
 8004c0a: bf00         	nop

08004c0c <$d>:
 8004c0c: 08 03 00 20  	.word	0x20000308
 8004c10: 08 a1 01 08  	.word	0x0801a108
 8004c14: 34 a1 01 08  	.word	0x0801a134

08004c18 <can_stm32_stop>:
; {
 8004c18: b580         	push	{r7, lr}
 8004c1a: b08e         	sub	sp, #0x38
 8004c1c: af04         	add	r7, sp, #0x10
 8004c1e: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8004c20: 687b         	ldr	r3, [r7, #0x4]
 8004c22: 685b         	ldr	r3, [r3, #0x4]
 8004c24: 623b         	str	r3, [r7, #0x20]
; 	struct can_stm32_data *data = dev->data;
 8004c26: 687b         	ldr	r3, [r7, #0x4]
 8004c28: 691b         	ldr	r3, [r3, #0x10]
 8004c2a: 61fb         	str	r3, [r7, #0x1c]
; 	CAN_TypeDef *can = cfg->can;
 8004c2c: 6a3b         	ldr	r3, [r7, #0x20]
 8004c2e: 695b         	ldr	r3, [r3, #0x14]
 8004c30: 61bb         	str	r3, [r7, #0x18]
; 	int ret = 0;
 8004c32: 2300         	movs	r3, #0x0
 8004c34: 627b         	str	r3, [r7, #0x24]
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8004c36: 69fb         	ldr	r3, [r7, #0x1c]
 8004c38: f103 0110    	add.w	r1, r3, #0x10
 8004c3c: f04f 32ff    	mov.w	r2, #0xffffffff
 8004c40: f04f 33ff    	mov.w	r3, #0xffffffff
 8004c44: 4608         	mov	r0, r1
 8004c46: f00d f9f4    	bl	0x8012032 <k_mutex_lock> @ imm = #0xd3e8
; 	if (!data->common.started) {
 8004c4a: 69fb         	ldr	r3, [r7, #0x1c]
 8004c4c: 791b         	ldrb	r3, [r3, #0x4]
 8004c4e: f083 0301    	eor	r3, r3, #0x1
 8004c52: b2db         	uxtb	r3, r3
 8004c54: 2b00         	cmp	r3, #0x0
 8004c56: d003         	beq	0x8004c60 <can_stm32_stop+0x48> @ imm = #0x6
; 		ret = -EALREADY;
 8004c58: f06f 0377    	mvn	r3, #0x77
 8004c5c: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 8004c5e: e072         	b	0x8004d46 <can_stm32_stop+0x12e> @ imm = #0xe4
; 	ret = can_stm32_enter_init_mode(can);
 8004c60: 69b8         	ldr	r0, [r7, #0x18]
 8004c62: f7ff fecf    	bl	0x8004a04 <can_stm32_enter_init_mode> @ imm = #-0x262
 8004c66: 6278         	str	r0, [r7, #0x24]
; 	if (ret < 0) {
 8004c68: 6a7b         	ldr	r3, [r7, #0x24]
 8004c6a: 2b00         	cmp	r3, #0x0
 8004c6c: da1d         	bge	0x8004caa <can_stm32_stop+0x92> @ imm = #0x3a
; 		LOG_ERR("Failed to enter init mode");
 8004c6e: 2303         	movs	r3, #0x3
 8004c70: 2b00         	cmp	r3, #0x0
 8004c72: d016         	beq	0x8004ca2 <can_stm32_stop+0x8a> @ imm = #0x2c
 8004c74: 2301         	movs	r3, #0x1
 8004c76: 73fb         	strb	r3, [r7, #0xf]
 8004c78: 7bfb         	ldrb	r3, [r7, #0xf]
 8004c7a: f083 0301    	eor	r3, r3, #0x1
 8004c7e: b2db         	uxtb	r3, r3
 8004c80: 2b00         	cmp	r3, #0x0
 8004c82: d10e         	bne	0x8004ca2 <can_stm32_stop+0x8a> @ imm = #0x1c
 8004c84: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8004d5c <can_stm32_stop+0x144>
 8004c86: 6819         	ldr	r1, [r3]
 8004c88: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8004d60 <can_stm32_stop+0x148>
 8004c8a: 9302         	str	r3, [sp, #0x8]
 8004c8c: 2300         	movs	r3, #0x0
 8004c8e: 9301         	str	r3, [sp, #0x4]
 8004c90: 2300         	movs	r3, #0x0
 8004c92: 9300         	str	r3, [sp]
 8004c94: 2300         	movs	r3, #0x0
 8004c96: 2201         	movs	r2, #0x1
 8004c98: 2000         	movs	r0, #0x0
 8004c9a: f00d fab1    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd562
 8004c9e: 2300         	movs	r3, #0x0
 8004ca0: 60bb         	str	r3, [r7, #0x8]
; 		ret = -EIO;
 8004ca2: f06f 0304    	mvn	r3, #0x4
 8004ca6: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 8004ca8: e04d         	b	0x8004d46 <can_stm32_stop+0x12e> @ imm = #0x9a
; 	can_stm32_signal_tx_complete(dev, &data->mb0, -ENETDOWN);
 8004caa: 69fb         	ldr	r3, [r7, #0x1c]
 8004cac: 3334         	adds	r3, #0x34
 8004cae: f06f 0272    	mvn	r2, #0x72
 8004cb2: 4619         	mov	r1, r3
 8004cb4: 6878         	ldr	r0, [r7, #0x4]
 8004cb6: f00d fac1    	bl	0x801223c <can_stm32_signal_tx_complete> @ imm = #0xd582
; 	can_stm32_signal_tx_complete(dev, &data->mb1, -ENETDOWN);
 8004cba: 69fb         	ldr	r3, [r7, #0x1c]
 8004cbc: 333c         	adds	r3, #0x3c
 8004cbe: f06f 0272    	mvn	r2, #0x72
 8004cc2: 4619         	mov	r1, r3
 8004cc4: 6878         	ldr	r0, [r7, #0x4]
 8004cc6: f00d fab9    	bl	0x801223c <can_stm32_signal_tx_complete> @ imm = #0xd572
; 	can_stm32_signal_tx_complete(dev, &data->mb2, -ENETDOWN);
 8004cca: 69fb         	ldr	r3, [r7, #0x1c]
 8004ccc: 3344         	adds	r3, #0x44
 8004cce: f06f 0272    	mvn	r2, #0x72
 8004cd2: 4619         	mov	r1, r3
 8004cd4: 6878         	ldr	r0, [r7, #0x4]
 8004cd6: f00d fab1    	bl	0x801223c <can_stm32_signal_tx_complete> @ imm = #0xd562
; 	can->TSR |= CAN_TSR_ABRQ2 | CAN_TSR_ABRQ1 | CAN_TSR_ABRQ0;
 8004cda: 69bb         	ldr	r3, [r7, #0x18]
 8004cdc: 689b         	ldr	r3, [r3, #0x8]
 8004cde: f043 1380    	orr	r3, r3, #0x800080
 8004ce2: f443 4300    	orr	r3, r3, #0x8000
 8004ce6: 69ba         	ldr	r2, [r7, #0x18]
 8004ce8: 6093         	str	r3, [r2, #0x8]
; 	if (cfg->common.phy != NULL) {
 8004cea: 6a3b         	ldr	r3, [r7, #0x20]
 8004cec: 681b         	ldr	r3, [r3]
 8004cee: 2b00         	cmp	r3, #0x0
 8004cf0: d026         	beq	0x8004d40 <can_stm32_stop+0x128> @ imm = #0x4c
; 		ret = can_transceiver_disable(cfg->common.phy);
 8004cf2: 6a3b         	ldr	r3, [r7, #0x20]
 8004cf4: 681b         	ldr	r3, [r3]
 8004cf6: 4618         	mov	r0, r3
 8004cf8: f00d fa14    	bl	0x8012124 <can_transceiver_disable> @ imm = #0xd428
 8004cfc: 6278         	str	r0, [r7, #0x24]
; 		if (ret != 0) {
 8004cfe: 6a7b         	ldr	r3, [r7, #0x24]
 8004d00: 2b00         	cmp	r3, #0x0
 8004d02: d01d         	beq	0x8004d40 <can_stm32_stop+0x128> @ imm = #0x3a
; 			LOG_ERR("failed to enable CAN transceiver (err %d)", ret);
 8004d04: 2303         	movs	r3, #0x3
 8004d06: 2b00         	cmp	r3, #0x0
 8004d08: d019         	beq	0x8004d3e <can_stm32_stop+0x126> @ imm = #0x32
 8004d0a: 2301         	movs	r3, #0x1
 8004d0c: 75fb         	strb	r3, [r7, #0x17]
 8004d0e: 7dfb         	ldrb	r3, [r7, #0x17]
 8004d10: f083 0301    	eor	r3, r3, #0x1
 8004d14: b2db         	uxtb	r3, r3
 8004d16: 2b00         	cmp	r3, #0x0
 8004d18: d111         	bne	0x8004d3e <can_stm32_stop+0x126> @ imm = #0x22
 8004d1a: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8004d5c <can_stm32_stop+0x144>
 8004d1c: 6819         	ldr	r1, [r3]
 8004d1e: 6a7b         	ldr	r3, [r7, #0x24]
 8004d20: 9303         	str	r3, [sp, #0xc]
 8004d22: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8004d64 <can_stm32_stop+0x14c>
 8004d24: 9302         	str	r3, [sp, #0x8]
 8004d26: 2300         	movs	r3, #0x0
 8004d28: 9301         	str	r3, [sp, #0x4]
 8004d2a: 2300         	movs	r3, #0x0
 8004d2c: 9300         	str	r3, [sp]
 8004d2e: 2300         	movs	r3, #0x0
 8004d30: 2201         	movs	r2, #0x1
 8004d32: 2000         	movs	r0, #0x0
 8004d34: f00d fa64    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd4c8
 8004d38: 2300         	movs	r3, #0x0
 8004d3a: 613b         	str	r3, [r7, #0x10]
; 			goto unlock;
 8004d3c: e003         	b	0x8004d46 <can_stm32_stop+0x12e> @ imm = #0x6
 8004d3e: e002         	b	0x8004d46 <can_stm32_stop+0x12e> @ imm = #0x4
; 	data->common.started = false;
 8004d40: 69fb         	ldr	r3, [r7, #0x1c]
 8004d42: 2200         	movs	r2, #0x0
 8004d44: 711a         	strb	r2, [r3, #0x4]
; 	k_mutex_unlock(&data->inst_mutex);
 8004d46: 69fb         	ldr	r3, [r7, #0x1c]
 8004d48: 3310         	adds	r3, #0x10
 8004d4a: 4618         	mov	r0, r3
 8004d4c: f00d f981    	bl	0x8012052 <k_mutex_unlock> @ imm = #0xd302
; 	return ret;
 8004d50: 6a79         	ldr	r1, [r7, #0x24]
 8004d52: 460b         	mov	r3, r1
; }
 8004d54: 4618         	mov	r0, r3
 8004d56: 3728         	adds	r7, #0x28
 8004d58: 46bd         	mov	sp, r7
 8004d5a: bd80         	pop	{r7, pc}

08004d5c <$d>:
 8004d5c: 08 03 00 20  	.word	0x20000308
 8004d60: 50 a1 01 08  	.word	0x0801a150
 8004d64: 08 a1 01 08  	.word	0x0801a108

08004d68 <can_stm32_set_mode>:
; {
 8004d68: b580         	push	{r7, lr}
 8004d6a: b090         	sub	sp, #0x40
 8004d6c: af06         	add	r7, sp, #0x18
 8004d6e: 6078         	str	r0, [r7, #0x4]
 8004d70: 6039         	str	r1, [r7]
; 	can_mode_t supported = CAN_MODE_LOOPBACK | CAN_MODE_LISTENONLY | CAN_MODE_ONE_SHOT;
 8004d72: 230b         	movs	r3, #0xb
 8004d74: 627b         	str	r3, [r7, #0x24]
; 	const struct can_stm32_config *cfg = dev->config;
 8004d76: 687b         	ldr	r3, [r7, #0x4]
 8004d78: 685b         	ldr	r3, [r3, #0x4]
 8004d7a: 623b         	str	r3, [r7, #0x20]
; 	CAN_TypeDef *can = cfg->can;
 8004d7c: 6a3b         	ldr	r3, [r7, #0x20]
 8004d7e: 695b         	ldr	r3, [r3, #0x14]
 8004d80: 61fb         	str	r3, [r7, #0x1c]
; 	struct can_stm32_data *data = dev->data;
 8004d82: 687b         	ldr	r3, [r7, #0x4]
 8004d84: 691b         	ldr	r3, [r3, #0x10]
 8004d86: 61bb         	str	r3, [r7, #0x18]
; 	LOG_DBG("Set mode %d", mode);
 8004d88: 2303         	movs	r3, #0x3
 8004d8a: 2b03         	cmp	r3, #0x3
 8004d8c: d91a         	bls	0x8004dc4 <can_stm32_set_mode+0x5c> @ imm = #0x34
 8004d8e: 2301         	movs	r3, #0x1
 8004d90: 75fb         	strb	r3, [r7, #0x17]
 8004d92: 7dfb         	ldrb	r3, [r7, #0x17]
 8004d94: f083 0301    	eor	r3, r3, #0x1
 8004d98: b2db         	uxtb	r3, r3
 8004d9a: 2b00         	cmp	r3, #0x0
 8004d9c: d112         	bne	0x8004dc4 <can_stm32_set_mode+0x5c> @ imm = #0x24
 8004d9e: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8004eb8 <can_stm32_set_mode+0x150>
 8004da0: 6819         	ldr	r1, [r3]
 8004da2: 683b         	ldr	r3, [r7]
 8004da4: 9304         	str	r3, [sp, #0x10]
 8004da6: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8004ebc <can_stm32_set_mode+0x154>
 8004da8: 9303         	str	r3, [sp, #0xc]
 8004daa: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8004ec0 <can_stm32_set_mode+0x158>
 8004dac: 9302         	str	r3, [sp, #0x8]
 8004dae: 2308         	movs	r3, #0x8
 8004db0: 9301         	str	r3, [sp, #0x4]
 8004db2: 2300         	movs	r3, #0x0
 8004db4: 9300         	str	r3, [sp]
 8004db6: 2300         	movs	r3, #0x0
 8004db8: 2204         	movs	r2, #0x4
 8004dba: 2000         	movs	r0, #0x0
 8004dbc: f00d fa20    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd440
 8004dc0: 2300         	movs	r3, #0x0
 8004dc2: 613b         	str	r3, [r7, #0x10]
; 	if ((mode & ~(supported)) != 0) {
 8004dc4: 6a7b         	ldr	r3, [r7, #0x24]
 8004dc6: 43da         	mvns	r2, r3
 8004dc8: 683b         	ldr	r3, [r7]
 8004dca: 4013         	ands	r3, r2
 8004dcc: 2b00         	cmp	r3, #0x0
 8004dce: d01e         	beq	0x8004e0e <can_stm32_set_mode+0xa6> @ imm = #0x3c
; 		LOG_ERR("unsupported mode: 0x%08x", mode);
 8004dd0: 2303         	movs	r3, #0x3
 8004dd2: 2b00         	cmp	r3, #0x0
 8004dd4: d018         	beq	0x8004e08 <can_stm32_set_mode+0xa0> @ imm = #0x30
 8004dd6: 2301         	movs	r3, #0x1
 8004dd8: 73fb         	strb	r3, [r7, #0xf]
 8004dda: 7bfb         	ldrb	r3, [r7, #0xf]
 8004ddc: f083 0301    	eor	r3, r3, #0x1
 8004de0: b2db         	uxtb	r3, r3
 8004de2: 2b00         	cmp	r3, #0x0
 8004de4: d110         	bne	0x8004e08 <can_stm32_set_mode+0xa0> @ imm = #0x20
 8004de6: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8004eb8 <can_stm32_set_mode+0x150>
 8004de8: 6819         	ldr	r1, [r3]
 8004dea: 683b         	ldr	r3, [r7]
 8004dec: 9303         	str	r3, [sp, #0xc]
 8004dee: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8004ec4 <can_stm32_set_mode+0x15c>
 8004df0: 9302         	str	r3, [sp, #0x8]
 8004df2: 2300         	movs	r3, #0x0
 8004df4: 9301         	str	r3, [sp, #0x4]
 8004df6: 2300         	movs	r3, #0x0
 8004df8: 9300         	str	r3, [sp]
 8004dfa: 2300         	movs	r3, #0x0
 8004dfc: 2201         	movs	r2, #0x1
 8004dfe: 2000         	movs	r0, #0x0
 8004e00: f00d f9fe    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd3fc
 8004e04: 2300         	movs	r3, #0x0
 8004e06: 60bb         	str	r3, [r7, #0x8]
; 		return -ENOTSUP;
 8004e08: f06f 0185    	mvn	r1, #0x85
 8004e0c: e04f         	b	0x8004eae <can_stm32_set_mode+0x146> @ imm = #0x9e
; 	if (data->common.started) {
 8004e0e: 69bb         	ldr	r3, [r7, #0x18]
 8004e10: 791b         	ldrb	r3, [r3, #0x4]
 8004e12: 2b00         	cmp	r3, #0x0
 8004e14: d002         	beq	0x8004e1c <can_stm32_set_mode+0xb4> @ imm = #0x4
; 		return -EBUSY;
 8004e16: f06f 010f    	mvn	r1, #0xf
 8004e1a: e048         	b	0x8004eae <can_stm32_set_mode+0x146> @ imm = #0x90
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8004e1c: 69bb         	ldr	r3, [r7, #0x18]
 8004e1e: f103 0110    	add.w	r1, r3, #0x10
 8004e22: f04f 32ff    	mov.w	r2, #0xffffffff
 8004e26: f04f 33ff    	mov.w	r3, #0xffffffff
 8004e2a: 4608         	mov	r0, r1
 8004e2c: f00d f901    	bl	0x8012032 <k_mutex_lock> @ imm = #0xd202
; 	if ((mode & CAN_MODE_LOOPBACK) != 0) {
 8004e30: 683b         	ldr	r3, [r7]
 8004e32: f003 0301    	and	r3, r3, #0x1
 8004e36: 2b00         	cmp	r3, #0x0
 8004e38: d006         	beq	0x8004e48 <can_stm32_set_mode+0xe0> @ imm = #0xc
; 		can->BTR |= CAN_BTR_LBKM;
 8004e3a: 69fb         	ldr	r3, [r7, #0x1c]
 8004e3c: 69db         	ldr	r3, [r3, #0x1c]
 8004e3e: f043 4280    	orr	r2, r3, #0x40000000
 8004e42: 69fb         	ldr	r3, [r7, #0x1c]
 8004e44: 61da         	str	r2, [r3, #0x1c]
 8004e46: e005         	b	0x8004e54 <can_stm32_set_mode+0xec> @ imm = #0xa
; 		can->BTR &= ~CAN_BTR_LBKM;
 8004e48: 69fb         	ldr	r3, [r7, #0x1c]
 8004e4a: 69db         	ldr	r3, [r3, #0x1c]
 8004e4c: f023 4280    	bic	r2, r3, #0x40000000
 8004e50: 69fb         	ldr	r3, [r7, #0x1c]
 8004e52: 61da         	str	r2, [r3, #0x1c]
; 	if ((mode & CAN_MODE_LISTENONLY) != 0) {
 8004e54: 683b         	ldr	r3, [r7]
 8004e56: f003 0302    	and	r3, r3, #0x2
 8004e5a: 2b00         	cmp	r3, #0x0
 8004e5c: d006         	beq	0x8004e6c <can_stm32_set_mode+0x104> @ imm = #0xc
; 		can->BTR |= CAN_BTR_SILM;
 8004e5e: 69fb         	ldr	r3, [r7, #0x1c]
 8004e60: 69db         	ldr	r3, [r3, #0x1c]
 8004e62: f043 4200    	orr	r2, r3, #0x80000000
 8004e66: 69fb         	ldr	r3, [r7, #0x1c]
 8004e68: 61da         	str	r2, [r3, #0x1c]
 8004e6a: e005         	b	0x8004e78 <can_stm32_set_mode+0x110> @ imm = #0xa
; 		can->BTR &= ~CAN_BTR_SILM;
 8004e6c: 69fb         	ldr	r3, [r7, #0x1c]
 8004e6e: 69db         	ldr	r3, [r3, #0x1c]
 8004e70: f023 4200    	bic	r2, r3, #0x80000000
 8004e74: 69fb         	ldr	r3, [r7, #0x1c]
 8004e76: 61da         	str	r2, [r3, #0x1c]
; 	if ((mode & CAN_MODE_ONE_SHOT) != 0) {
 8004e78: 683b         	ldr	r3, [r7]
 8004e7a: f003 0308    	and	r3, r3, #0x8
 8004e7e: 2b00         	cmp	r3, #0x0
 8004e80: d006         	beq	0x8004e90 <can_stm32_set_mode+0x128> @ imm = #0xc
; 		can->MCR |= CAN_MCR_NART;
 8004e82: 69fb         	ldr	r3, [r7, #0x1c]
 8004e84: 681b         	ldr	r3, [r3]
 8004e86: f043 0210    	orr	r2, r3, #0x10
 8004e8a: 69fb         	ldr	r3, [r7, #0x1c]
 8004e8c: 601a         	str	r2, [r3]
 8004e8e: e005         	b	0x8004e9c <can_stm32_set_mode+0x134> @ imm = #0xa
; 		can->MCR &= ~CAN_MCR_NART;
 8004e90: 69fb         	ldr	r3, [r7, #0x1c]
 8004e92: 681b         	ldr	r3, [r3]
 8004e94: f023 0210    	bic	r2, r3, #0x10
 8004e98: 69fb         	ldr	r3, [r7, #0x1c]
 8004e9a: 601a         	str	r2, [r3]
; 	data->common.mode = mode;
 8004e9c: 69bb         	ldr	r3, [r7, #0x18]
 8004e9e: 683a         	ldr	r2, [r7]
 8004ea0: 601a         	str	r2, [r3]
; 	k_mutex_unlock(&data->inst_mutex);
 8004ea2: 69bb         	ldr	r3, [r7, #0x18]
 8004ea4: 3310         	adds	r3, #0x10
 8004ea6: 4618         	mov	r0, r3
 8004ea8: f00d f8d3    	bl	0x8012052 <k_mutex_unlock> @ imm = #0xd1a6
; 	return 0;
 8004eac: 2100         	movs	r1, #0x0
; }
 8004eae: 460b         	mov	r3, r1
 8004eb0: 4618         	mov	r0, r3
 8004eb2: 3728         	adds	r7, #0x28
 8004eb4: 46bd         	mov	sp, r7
 8004eb6: bd80         	pop	{r7, pc}

08004eb8 <$d>:
 8004eb8: 08 03 00 20  	.word	0x20000308
 8004ebc: a4 b5 01 08  	.word	0x0801b5a4
 8004ec0: 6c a1 01 08  	.word	0x0801a16c
 8004ec4: 7c a1 01 08  	.word	0x0801a17c

08004ec8 <can_stm32_set_timing>:
; {
 8004ec8: b580         	push	{r7, lr}
 8004eca: b086         	sub	sp, #0x18
 8004ecc: af00         	add	r7, sp, #0x0
 8004ece: 6078         	str	r0, [r7, #0x4]
 8004ed0: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8004ed2: 687b         	ldr	r3, [r7, #0x4]
 8004ed4: 685b         	ldr	r3, [r3, #0x4]
 8004ed6: 617b         	str	r3, [r7, #0x14]
; 	CAN_TypeDef *can = cfg->can;
 8004ed8: 697b         	ldr	r3, [r7, #0x14]
 8004eda: 695b         	ldr	r3, [r3, #0x14]
 8004edc: 613b         	str	r3, [r7, #0x10]
; 	struct can_stm32_data *data = dev->data;
 8004ede: 687b         	ldr	r3, [r7, #0x4]
 8004ee0: 691b         	ldr	r3, [r3, #0x10]
 8004ee2: 60fb         	str	r3, [r7, #0xc]
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8004ee4: 68fb         	ldr	r3, [r7, #0xc]
 8004ee6: f103 0110    	add.w	r1, r3, #0x10
 8004eea: f04f 32ff    	mov.w	r2, #0xffffffff
 8004eee: f04f 33ff    	mov.w	r3, #0xffffffff
 8004ef2: 4608         	mov	r0, r1
 8004ef4: f00d f89d    	bl	0x8012032 <k_mutex_lock> @ imm = #0xd13a
; 	if (data->common.started) {
 8004ef8: 68fb         	ldr	r3, [r7, #0xc]
 8004efa: 791b         	ldrb	r3, [r3, #0x4]
 8004efc: 2b00         	cmp	r3, #0x0
 8004efe: d007         	beq	0x8004f10 <can_stm32_set_timing+0x48> @ imm = #0xe
; 		k_mutex_unlock(&data->inst_mutex);
 8004f00: 68fb         	ldr	r3, [r7, #0xc]
 8004f02: 3310         	adds	r3, #0x10
 8004f04: 4618         	mov	r0, r3
 8004f06: f00d f8a4    	bl	0x8012052 <k_mutex_unlock> @ imm = #0xd148
; 		return -EBUSY;
 8004f0a: f06f 010f    	mvn	r1, #0xf
 8004f0e: e026         	b	0x8004f5e <can_stm32_set_timing+0x96> @ imm = #0x4c
; 	can->BTR = (can->BTR & ~(CAN_BTR_SJW_Msk | CAN_BTR_BRP_Msk |
 8004f10: 693b         	ldr	r3, [r7, #0x10]
 8004f12: 69da         	ldr	r2, [r3, #0x1c]
 8004f14: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8004f68 <can_stm32_set_timing+0xa0>
 8004f16: 4013         	ands	r3, r2
; 	     (((timing->sjw        - 1) << CAN_BTR_SJW_Pos) & CAN_BTR_SJW_Msk) |
 8004f18: 683a         	ldr	r2, [r7]
 8004f1a: 8812         	ldrh	r2, [r2]
 8004f1c: 3a01         	subs	r2, #0x1
 8004f1e: 0612         	lsls	r2, r2, #0x18
 8004f20: f002 7240    	and	r2, r2, #0x3000000
; 				 CAN_BTR_TS1_Msk | CAN_BTR_TS2_Msk)) |
 8004f24: 431a         	orrs	r2, r3
; 	     (((timing->phase_seg1 - 1) << CAN_BTR_TS1_Pos) & CAN_BTR_TS1_Msk) |
 8004f26: 683b         	ldr	r3, [r7]
 8004f28: 889b         	ldrh	r3, [r3, #0x4]
 8004f2a: 3b01         	subs	r3, #0x1
 8004f2c: 041b         	lsls	r3, r3, #0x10
 8004f2e: f403 2370    	and	r3, r3, #0xf0000
; 	     (((timing->sjw        - 1) << CAN_BTR_SJW_Pos) & CAN_BTR_SJW_Msk) |
 8004f32: 431a         	orrs	r2, r3
; 	     (((timing->phase_seg2 - 1) << CAN_BTR_TS2_Pos) & CAN_BTR_TS2_Msk) |
 8004f34: 683b         	ldr	r3, [r7]
 8004f36: 88db         	ldrh	r3, [r3, #0x6]
 8004f38: 3b01         	subs	r3, #0x1
 8004f3a: 051b         	lsls	r3, r3, #0x14
 8004f3c: f403 03e0    	and	r3, r3, #0x700000
; 	     (((timing->phase_seg1 - 1) << CAN_BTR_TS1_Pos) & CAN_BTR_TS1_Msk) |
 8004f40: 431a         	orrs	r2, r3
; 	     (((timing->prescaler  - 1) << CAN_BTR_BRP_Pos) & CAN_BTR_BRP_Msk);
 8004f42: 683b         	ldr	r3, [r7]
 8004f44: 891b         	ldrh	r3, [r3, #0x8]
 8004f46: 3b01         	subs	r3, #0x1
 8004f48: f3c3 0309    	ubfx	r3, r3, #0x0, #0xa
; 	     (((timing->phase_seg2 - 1) << CAN_BTR_TS2_Pos) & CAN_BTR_TS2_Msk) |
 8004f4c: 431a         	orrs	r2, r3
; 	can->BTR = (can->BTR & ~(CAN_BTR_SJW_Msk | CAN_BTR_BRP_Msk |
 8004f4e: 693b         	ldr	r3, [r7, #0x10]
 8004f50: 61da         	str	r2, [r3, #0x1c]
; 	k_mutex_unlock(&data->inst_mutex);
 8004f52: 68fb         	ldr	r3, [r7, #0xc]
 8004f54: 3310         	adds	r3, #0x10
 8004f56: 4618         	mov	r0, r3
 8004f58: f00d f87b    	bl	0x8012052 <k_mutex_unlock> @ imm = #0xd0f6
; 	return 0;
 8004f5c: 2100         	movs	r1, #0x0
; }
 8004f5e: 460b         	mov	r3, r1
 8004f60: 4618         	mov	r0, r3
 8004f62: 3718         	adds	r7, #0x18
 8004f64: 46bd         	mov	sp, r7
 8004f66: bd80         	pop	{r7, pc}

08004f68 <$d>:
 8004f68: 00 fc 80 fc  	.word	0xfc80fc00

08004f6c <can_stm32_get_core_clock>:
; {
 8004f6c: b580         	push	{r7, lr}
 8004f6e: b08c         	sub	sp, #0x30
 8004f70: af04         	add	r7, sp, #0x10
 8004f72: 6078         	str	r0, [r7, #0x4]
 8004f74: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8004f76: 687b         	ldr	r3, [r7, #0x4]
 8004f78: 685b         	ldr	r3, [r3, #0x4]
 8004f7a: 61fb         	str	r3, [r7, #0x1c]
; 	clock = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8004f7c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8004fe0 <can_stm32_get_core_clock+0x74>
 8004f7e: 61bb         	str	r3, [r7, #0x18]
; 				     (clock_control_subsys_t) &cfg->pclken,
 8004f80: 69fb         	ldr	r3, [r7, #0x1c]
 8004f82: 331c         	adds	r3, #0x1c
; 	ret = clock_control_get_rate(clock,
 8004f84: 683a         	ldr	r2, [r7]
 8004f86: 4619         	mov	r1, r3
 8004f88: 69b8         	ldr	r0, [r7, #0x18]
 8004f8a: f00d f8ed    	bl	0x8012168 <clock_control_get_rate> @ imm = #0xd1da
 8004f8e: 6178         	str	r0, [r7, #0x14]
; 	if (ret != 0) {
 8004f90: 697b         	ldr	r3, [r7, #0x14]
 8004f92: 2b00         	cmp	r3, #0x0
 8004f94: d01e         	beq	0x8004fd4 <can_stm32_get_core_clock+0x68> @ imm = #0x3c
; 		LOG_ERR("Failed call clock_control_get_rate: return [%d]", ret);
 8004f96: 2303         	movs	r3, #0x3
 8004f98: 2b00         	cmp	r3, #0x0
 8004f9a: d018         	beq	0x8004fce <can_stm32_get_core_clock+0x62> @ imm = #0x30
 8004f9c: 2301         	movs	r3, #0x1
 8004f9e: 74fb         	strb	r3, [r7, #0x13]
 8004fa0: 7cfb         	ldrb	r3, [r7, #0x13]
 8004fa2: f083 0301    	eor	r3, r3, #0x1
 8004fa6: b2db         	uxtb	r3, r3
 8004fa8: 2b00         	cmp	r3, #0x0
 8004faa: d110         	bne	0x8004fce <can_stm32_get_core_clock+0x62> @ imm = #0x20
 8004fac: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8004fe4 <can_stm32_get_core_clock+0x78>
 8004fae: 6819         	ldr	r1, [r3]
 8004fb0: 697b         	ldr	r3, [r7, #0x14]
 8004fb2: 9303         	str	r3, [sp, #0xc]
 8004fb4: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004fe8 <can_stm32_get_core_clock+0x7c>
 8004fb6: 9302         	str	r3, [sp, #0x8]
 8004fb8: 2300         	movs	r3, #0x0
 8004fba: 9301         	str	r3, [sp, #0x4]
 8004fbc: 2300         	movs	r3, #0x0
 8004fbe: 9300         	str	r3, [sp]
 8004fc0: 2300         	movs	r3, #0x0
 8004fc2: 2201         	movs	r2, #0x1
 8004fc4: 2000         	movs	r0, #0x0
 8004fc6: f00d f91b    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd236
 8004fca: 2300         	movs	r3, #0x0
 8004fcc: 60fb         	str	r3, [r7, #0xc]
; 		return -EIO;
 8004fce: f06f 0304    	mvn	r3, #0x4
 8004fd2: e000         	b	0x8004fd6 <can_stm32_get_core_clock+0x6a> @ imm = #0x0
; 	return 0;
 8004fd4: 2300         	movs	r3, #0x0
; }
 8004fd6: 4618         	mov	r0, r3
 8004fd8: 3720         	adds	r7, #0x20
 8004fda: 46bd         	mov	sp, r7
 8004fdc: bd80         	pop	{r7, pc}
 8004fde: bf00         	nop

08004fe0 <$d>:
 8004fe0: 1c 92 01 08  	.word	0x0801921c
 8004fe4: 08 03 00 20  	.word	0x20000308
 8004fe8: 98 a1 01 08  	.word	0x0801a198

08004fec <can_stm32_init>:
; {
 8004fec: b580         	push	{r7, lr}
 8004fee: b0a6         	sub	sp, #0x98
 8004ff0: af08         	add	r7, sp, #0x20
 8004ff2: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8004ff4: 687b         	ldr	r3, [r7, #0x4]
 8004ff6: 685b         	ldr	r3, [r3, #0x4]
 8004ff8: 663b         	str	r3, [r7, #0x60]
; 	struct can_stm32_data *data = dev->data;
 8004ffa: 687b         	ldr	r3, [r7, #0x4]
 8004ffc: 691b         	ldr	r3, [r3, #0x10]
 8004ffe: 66bb         	str	r3, [r7, #0x68]
; 	CAN_TypeDef *can = cfg->can;
 8005000: 6e3b         	ldr	r3, [r7, #0x60]
 8005002: 695b         	ldr	r3, [r3, #0x14]
 8005004: 667b         	str	r3, [r7, #0x64]
; 	struct can_timing timing = { 0 };
 8005006: f107 030c    	add.w	r3, r7, #0xc
 800500a: 2200         	movs	r2, #0x0
 800500c: 601a         	str	r2, [r3]
 800500e: 605a         	str	r2, [r3, #0x4]
 8005010: 811a         	strh	r2, [r3, #0x8]
; 	k_mutex_init(&filter_mutex);
 8005012: 4886         	ldr	r0, [pc, #0x218]        @ 0x800522c <can_stm32_init+0x240>
 8005014: f00d f801    	bl	0x801201a <k_mutex_init> @ imm = #0xd002
; 	k_mutex_init(&data->inst_mutex);
 8005018: 6ebb         	ldr	r3, [r7, #0x68]
 800501a: 3310         	adds	r3, #0x10
 800501c: 4618         	mov	r0, r3
 800501e: f00c fffc    	bl	0x801201a <k_mutex_init> @ imm = #0xcff8
; 	k_sem_init(&data->tx_int_sem, 0, 1);
 8005022: 6ebb         	ldr	r3, [r7, #0x68]
 8005024: 3324         	adds	r3, #0x24
 8005026: 2201         	movs	r2, #0x1
 8005028: 2100         	movs	r1, #0x0
 800502a: 4618         	mov	r0, r3
 800502c: f00d f81d    	bl	0x801206a <k_sem_init>  @ imm = #0xd03a
; 	if (cfg->common.phy != NULL) {
 8005030: 6e3b         	ldr	r3, [r7, #0x60]
 8005032: 681b         	ldr	r3, [r3]
 8005034: 2b00         	cmp	r3, #0x0
 8005036: d029         	beq	0x800508c <can_stm32_init+0xa0> @ imm = #0x52
; 		if (!device_is_ready(cfg->common.phy)) {
 8005038: 6e3b         	ldr	r3, [r7, #0x60]
 800503a: 681b         	ldr	r3, [r3]
 800503c: 4618         	mov	r0, r3
 800503e: f00c ffd2    	bl	0x8011fe6 <device_is_ready> @ imm = #0xcfa4
 8005042: 4603         	mov	r3, r0
 8005044: f083 0301    	eor	r3, r3, #0x1
 8005048: b2db         	uxtb	r3, r3
 800504a: 2b00         	cmp	r3, #0x0
 800504c: d01e         	beq	0x800508c <can_stm32_init+0xa0> @ imm = #0x3c
; 			LOG_ERR("CAN transceiver not ready");
 800504e: 2303         	movs	r3, #0x3
 8005050: 2b00         	cmp	r3, #0x0
 8005052: d018         	beq	0x8005086 <can_stm32_init+0x9a> @ imm = #0x30
 8005054: 2301         	movs	r3, #0x1
 8005056: f887 306f    	strb.w	r3, [r7, #0x6f]
 800505a: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800505e: f083 0301    	eor	r3, r3, #0x1
 8005062: b2db         	uxtb	r3, r3
 8005064: 2b00         	cmp	r3, #0x0
 8005066: d10e         	bne	0x8005086 <can_stm32_init+0x9a> @ imm = #0x1c
 8005068: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8005230 <can_stm32_init+0x244>
 800506a: 6819         	ldr	r1, [r3]
 800506c: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8005234 <can_stm32_init+0x248>
 800506e: 9302         	str	r3, [sp, #0x8]
 8005070: 2300         	movs	r3, #0x0
 8005072: 9301         	str	r3, [sp, #0x4]
 8005074: 2300         	movs	r3, #0x0
 8005076: 9300         	str	r3, [sp]
 8005078: 2300         	movs	r3, #0x0
 800507a: 2201         	movs	r2, #0x1
 800507c: 2000         	movs	r0, #0x0
 800507e: f00d f8bf    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd17e
 8005082: 2300         	movs	r3, #0x0
 8005084: 673b         	str	r3, [r7, #0x70]
; 			return -ENODEV;
 8005086: f06f 0312    	mvn	r3, #0x12
 800508a: e1a8         	b	0x80053de <can_stm32_init+0x3f2> @ imm = #0x350
; 	clock = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800508c: 4b6a         	ldr	r3, [pc, #0x1a8]        @ 0x8005238 <can_stm32_init+0x24c>
 800508e: 677b         	str	r3, [r7, #0x74]
; 	if (!device_is_ready(clock)) {
 8005090: 6f78         	ldr	r0, [r7, #0x74]
 8005092: f00c ffa8    	bl	0x8011fe6 <device_is_ready> @ imm = #0xcf50
 8005096: 4603         	mov	r3, r0
 8005098: f083 0301    	eor	r3, r3, #0x1
 800509c: b2db         	uxtb	r3, r3
 800509e: 2b00         	cmp	r3, #0x0
 80050a0: d01c         	beq	0x80050dc <can_stm32_init+0xf0> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 80050a2: 2303         	movs	r3, #0x3
 80050a4: 2b00         	cmp	r3, #0x0
 80050a6: d016         	beq	0x80050d6 <can_stm32_init+0xea> @ imm = #0x2c
 80050a8: 2301         	movs	r3, #0x1
 80050aa: 77fb         	strb	r3, [r7, #0x1f]
 80050ac: 7ffb         	ldrb	r3, [r7, #0x1f]
 80050ae: f083 0301    	eor	r3, r3, #0x1
 80050b2: b2db         	uxtb	r3, r3
 80050b4: 2b00         	cmp	r3, #0x0
 80050b6: d10e         	bne	0x80050d6 <can_stm32_init+0xea> @ imm = #0x1c
 80050b8: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8005230 <can_stm32_init+0x244>
 80050ba: 6819         	ldr	r1, [r3]
 80050bc: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x800523c <can_stm32_init+0x250>
 80050be: 9302         	str	r3, [sp, #0x8]
 80050c0: 2300         	movs	r3, #0x0
 80050c2: 9301         	str	r3, [sp, #0x4]
 80050c4: 2300         	movs	r3, #0x0
 80050c6: 9300         	str	r3, [sp]
 80050c8: 2300         	movs	r3, #0x0
 80050ca: 2201         	movs	r2, #0x1
 80050cc: 2000         	movs	r0, #0x0
 80050ce: f00d f897    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd12e
 80050d2: 2300         	movs	r3, #0x0
 80050d4: 61bb         	str	r3, [r7, #0x18]
; 		return -ENODEV;
 80050d6: f06f 0312    	mvn	r3, #0x12
 80050da: e180         	b	0x80053de <can_stm32_init+0x3f2> @ imm = #0x300
; 	ret = clock_control_on(clock, (clock_control_subsys_t) &cfg->pclken);
 80050dc: 6e3b         	ldr	r3, [r7, #0x60]
 80050de: 331c         	adds	r3, #0x1c
 80050e0: 4619         	mov	r1, r3
 80050e2: 6f78         	ldr	r0, [r7, #0x74]
 80050e4: f00d f82e    	bl	0x8012144 <clock_control_on> @ imm = #0xd05c
 80050e8: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret != 0) {
 80050ea: 6dfb         	ldr	r3, [r7, #0x5c]
 80050ec: 2b00         	cmp	r3, #0x0
 80050ee: d020         	beq	0x8005132 <can_stm32_init+0x146> @ imm = #0x40
; 		LOG_ERR("HAL_CAN_Init clock control on failed: %d", ret);
 80050f0: 2303         	movs	r3, #0x3
 80050f2: 2b00         	cmp	r3, #0x0
 80050f4: d01a         	beq	0x800512c <can_stm32_init+0x140> @ imm = #0x34
 80050f6: 2301         	movs	r3, #0x1
 80050f8: f887 3027    	strb.w	r3, [r7, #0x27]
 80050fc: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8005100: f083 0301    	eor	r3, r3, #0x1
 8005104: b2db         	uxtb	r3, r3
 8005106: 2b00         	cmp	r3, #0x0
 8005108: d110         	bne	0x800512c <can_stm32_init+0x140> @ imm = #0x20
 800510a: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8005230 <can_stm32_init+0x244>
 800510c: 6819         	ldr	r1, [r3]
 800510e: 6dfb         	ldr	r3, [r7, #0x5c]
 8005110: 9303         	str	r3, [sp, #0xc]
 8005112: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8005240 <can_stm32_init+0x254>
 8005114: 9302         	str	r3, [sp, #0x8]
 8005116: 2300         	movs	r3, #0x0
 8005118: 9301         	str	r3, [sp, #0x4]
 800511a: 2300         	movs	r3, #0x0
 800511c: 9300         	str	r3, [sp]
 800511e: 2300         	movs	r3, #0x0
 8005120: 2201         	movs	r2, #0x1
 8005122: 2000         	movs	r0, #0x0
 8005124: f00d f86c    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd0d8
 8005128: 2300         	movs	r3, #0x0
 800512a: 623b         	str	r3, [r7, #0x20]
; 		return -EIO;
 800512c: f06f 0304    	mvn	r3, #0x4
 8005130: e155         	b	0x80053de <can_stm32_init+0x3f2> @ imm = #0x2aa
; 	ret = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
 8005132: 6e3b         	ldr	r3, [r7, #0x60]
 8005134: 6a9b         	ldr	r3, [r3, #0x28]
 8005136: 2100         	movs	r1, #0x0
 8005138: 4618         	mov	r0, r3
 800513a: f00d f844    	bl	0x80121c6 <pinctrl_apply_state> @ imm = #0xd088
 800513e: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret < 0) {
 8005140: 6dfb         	ldr	r3, [r7, #0x5c]
 8005142: 2b00         	cmp	r3, #0x0
 8005144: da1f         	bge	0x8005186 <can_stm32_init+0x19a> @ imm = #0x3e
; 		LOG_ERR("CAN pinctrl setup failed (%d)", ret);
 8005146: 2303         	movs	r3, #0x3
 8005148: 2b00         	cmp	r3, #0x0
 800514a: d01a         	beq	0x8005182 <can_stm32_init+0x196> @ imm = #0x34
 800514c: 2301         	movs	r3, #0x1
 800514e: f887 302f    	strb.w	r3, [r7, #0x2f]
 8005152: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8005156: f083 0301    	eor	r3, r3, #0x1
 800515a: b2db         	uxtb	r3, r3
 800515c: 2b00         	cmp	r3, #0x0
 800515e: d110         	bne	0x8005182 <can_stm32_init+0x196> @ imm = #0x20
 8005160: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8005230 <can_stm32_init+0x244>
 8005162: 6819         	ldr	r1, [r3]
 8005164: 6dfb         	ldr	r3, [r7, #0x5c]
 8005166: 9303         	str	r3, [sp, #0xc]
 8005168: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8005244 <can_stm32_init+0x258>
 800516a: 9302         	str	r3, [sp, #0x8]
 800516c: 2300         	movs	r3, #0x0
 800516e: 9301         	str	r3, [sp, #0x4]
 8005170: 2300         	movs	r3, #0x0
 8005172: 9300         	str	r3, [sp]
 8005174: 2300         	movs	r3, #0x0
 8005176: 2201         	movs	r2, #0x1
 8005178: 2000         	movs	r0, #0x0
 800517a: f00d f841    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd082
 800517e: 2300         	movs	r3, #0x0
 8005180: 62bb         	str	r3, [r7, #0x28]
; 		return ret;
 8005182: 6dfb         	ldr	r3, [r7, #0x5c]
 8005184: e12b         	b	0x80053de <can_stm32_init+0x3f2> @ imm = #0x256
; 	ret = can_stm32_enter_init_mode(can);
 8005186: 6e78         	ldr	r0, [r7, #0x64]
 8005188: f7ff fc3c    	bl	0x8004a04 <can_stm32_enter_init_mode> @ imm = #-0x788
 800518c: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 800518e: 6dfb         	ldr	r3, [r7, #0x5c]
 8005190: 2b00         	cmp	r3, #0x0
 8005192: d01d         	beq	0x80051d0 <can_stm32_init+0x1e4> @ imm = #0x3a
; 		LOG_ERR("Failed to enter init mode");
 8005194: 2303         	movs	r3, #0x3
 8005196: 2b00         	cmp	r3, #0x0
 8005198: d018         	beq	0x80051cc <can_stm32_init+0x1e0> @ imm = #0x30
 800519a: 2301         	movs	r3, #0x1
 800519c: f887 3037    	strb.w	r3, [r7, #0x37]
 80051a0: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80051a4: f083 0301    	eor	r3, r3, #0x1
 80051a8: b2db         	uxtb	r3, r3
 80051aa: 2b00         	cmp	r3, #0x0
 80051ac: d10e         	bne	0x80051cc <can_stm32_init+0x1e0> @ imm = #0x1c
 80051ae: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8005230 <can_stm32_init+0x244>
 80051b0: 6819         	ldr	r1, [r3]
 80051b2: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8005248 <can_stm32_init+0x25c>
 80051b4: 9302         	str	r3, [sp, #0x8]
 80051b6: 2300         	movs	r3, #0x0
 80051b8: 9301         	str	r3, [sp, #0x4]
 80051ba: 2300         	movs	r3, #0x0
 80051bc: 9300         	str	r3, [sp]
 80051be: 2300         	movs	r3, #0x0
 80051c0: 2201         	movs	r2, #0x1
 80051c2: 2000         	movs	r0, #0x0
 80051c4: f00d f81c    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xd038
 80051c8: 2300         	movs	r3, #0x0
 80051ca: 633b         	str	r3, [r7, #0x30]
; 		return ret;
 80051cc: 6dfb         	ldr	r3, [r7, #0x5c]
 80051ce: e106         	b	0x80053de <can_stm32_init+0x3f2> @ imm = #0x20c
; 	ret = can_stm32_leave_sleep_mode(can);
 80051d0: 6e78         	ldr	r0, [r7, #0x64]
 80051d2: f7ff fc69    	bl	0x8004aa8 <can_stm32_leave_sleep_mode> @ imm = #-0x72e
 80051d6: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 80051d8: 6dfb         	ldr	r3, [r7, #0x5c]
 80051da: 2b00         	cmp	r3, #0x0
 80051dc: d01d         	beq	0x800521a <can_stm32_init+0x22e> @ imm = #0x3a
; 		LOG_ERR("Failed to exit sleep mode");
 80051de: 2303         	movs	r3, #0x3
 80051e0: 2b00         	cmp	r3, #0x0
 80051e2: d018         	beq	0x8005216 <can_stm32_init+0x22a> @ imm = #0x30
 80051e4: 2301         	movs	r3, #0x1
 80051e6: f887 303f    	strb.w	r3, [r7, #0x3f]
 80051ea: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 80051ee: f083 0301    	eor	r3, r3, #0x1
 80051f2: b2db         	uxtb	r3, r3
 80051f4: 2b00         	cmp	r3, #0x0
 80051f6: d10e         	bne	0x8005216 <can_stm32_init+0x22a> @ imm = #0x1c
 80051f8: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8005230 <can_stm32_init+0x244>
 80051fa: 6819         	ldr	r1, [r3]
 80051fc: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800524c <can_stm32_init+0x260>
 80051fe: 9302         	str	r3, [sp, #0x8]
 8005200: 2300         	movs	r3, #0x0
 8005202: 9301         	str	r3, [sp, #0x4]
 8005204: 2300         	movs	r3, #0x0
 8005206: 9300         	str	r3, [sp]
 8005208: 2300         	movs	r3, #0x0
 800520a: 2201         	movs	r2, #0x1
 800520c: 2000         	movs	r0, #0x0
 800520e: f00c fff7    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xcfee
 8005212: 2300         	movs	r3, #0x0
 8005214: 63bb         	str	r3, [r7, #0x38]
; 		return ret;
 8005216: 6dfb         	ldr	r3, [r7, #0x5c]
 8005218: e0e1         	b	0x80053de <can_stm32_init+0x3f2> @ imm = #0x1c2
; 	bank_offset = (cfg->can == cfg->master_can) ? 0 : CAN_STM32_NUM_FILTER_BANKS;
 800521a: 6e3b         	ldr	r3, [r7, #0x60]
 800521c: 695a         	ldr	r2, [r3, #0x14]
 800521e: 6e3b         	ldr	r3, [r7, #0x60]
 8005220: 699b         	ldr	r3, [r3, #0x18]
 8005222: 429a         	cmp	r2, r3
 8005224: d114         	bne	0x8005250 <can_stm32_init+0x264> @ imm = #0x28
 8005226: 2300         	movs	r3, #0x0
 8005228: e013         	b	0x8005252 <can_stm32_init+0x266> @ imm = #0x26
 800522a: bf00         	nop

0800522c <$d>:
 800522c: 80 0b 00 20  	.word	0x20000b80
 8005230: 08 03 00 20  	.word	0x20000308
 8005234: c8 a1 01 08  	.word	0x0801a1c8
 8005238: 1c 92 01 08  	.word	0x0801921c
 800523c: e4 a1 01 08  	.word	0x0801a1e4
 8005240: 04 a2 01 08  	.word	0x0801a204
 8005244: 30 a2 01 08  	.word	0x0801a230
 8005248: 50 a1 01 08  	.word	0x0801a150
 800524c: 50 a2 01 08  	.word	0x0801a250

08005250 <$t>:
 8005250: 230e         	movs	r3, #0xe
 8005252: 65bb         	str	r3, [r7, #0x58]
; 	cfg->master_can->FMR |= CAN_FMR_FINIT;
 8005254: 6e3b         	ldr	r3, [r7, #0x60]
 8005256: 699b         	ldr	r3, [r3, #0x18]
 8005258: f8d3 2200    	ldr.w	r2, [r3, #0x200]
 800525c: 6e3b         	ldr	r3, [r7, #0x60]
 800525e: 699b         	ldr	r3, [r3, #0x18]
 8005260: f042 0201    	orr	r2, r2, #0x1
 8005264: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	cfg->master_can->FS1R |= ((1U << CONFIG_CAN_MAX_EXT_ID_FILTER) - 1) << bank_offset;
 8005268: 6e3b         	ldr	r3, [r7, #0x60]
 800526a: 699b         	ldr	r3, [r3, #0x18]
 800526c: f8d3 120c    	ldr.w	r1, [r3, #0x20c]
 8005270: 227f         	movs	r2, #0x7f
 8005272: 6dbb         	ldr	r3, [r7, #0x58]
 8005274: 409a         	lsls	r2, r3
 8005276: 6e3b         	ldr	r3, [r7, #0x60]
 8005278: 699b         	ldr	r3, [r3, #0x18]
 800527a: 430a         	orrs	r2, r1
 800527c: f8c3 220c    	str.w	r2, [r3, #0x20c]
; 	cfg->master_can->FMR &= ~CAN_FMR_FINIT;
 8005280: 6e3b         	ldr	r3, [r7, #0x60]
 8005282: 699b         	ldr	r3, [r3, #0x18]
 8005284: f8d3 2200    	ldr.w	r2, [r3, #0x200]
 8005288: 6e3b         	ldr	r3, [r7, #0x60]
 800528a: 699b         	ldr	r3, [r3, #0x18]
 800528c: f022 0201    	bic	r2, r2, #0x1
 8005290: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	can->MCR &= ~CAN_MCR_TTCM & ~CAN_MCR_ABOM & ~CAN_MCR_AWUM &
 8005294: 6e7b         	ldr	r3, [r7, #0x64]
 8005296: 681b         	ldr	r3, [r3]
 8005298: f023 02fc    	bic	r2, r3, #0xfc
 800529c: 6e7b         	ldr	r3, [r7, #0x64]
 800529e: 601a         	str	r2, [r3]
; 	can->MCR |= CAN_MCR_ABOM;
 80052a0: 6e7b         	ldr	r3, [r7, #0x64]
 80052a2: 681b         	ldr	r3, [r3]
 80052a4: f043 0240    	orr	r2, r3, #0x40
 80052a8: 6e7b         	ldr	r3, [r7, #0x64]
 80052aa: 601a         	str	r2, [r3]
; 	ret = can_calc_timing(dev, &timing, cfg->common.bitrate,
 80052ac: 6e3b         	ldr	r3, [r7, #0x60]
 80052ae: 68da         	ldr	r2, [r3, #0xc]
; 			      cfg->common.sample_point);
 80052b0: 6e3b         	ldr	r3, [r7, #0x60]
 80052b2: 8a1b         	ldrh	r3, [r3, #0x10]
; 	ret = can_calc_timing(dev, &timing, cfg->common.bitrate,
 80052b4: f107 010c    	add.w	r1, r7, #0xc
 80052b8: 6878         	ldr	r0, [r7, #0x4]
 80052ba: f00c ff01    	bl	0x80120c0 <can_calc_timing> @ imm = #0xce02
 80052be: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret == -EINVAL) {
 80052c0: 6dfb         	ldr	r3, [r7, #0x5c]
 80052c2: f113 0f16    	cmn.w	r3, #0x16
 80052c6: d11e         	bne	0x8005306 <can_stm32_init+0x31a> @ imm = #0x3c
; 		LOG_ERR("Can't find timing for given param");
 80052c8: 2303         	movs	r3, #0x3
 80052ca: 2b00         	cmp	r3, #0x0
 80052cc: d018         	beq	0x8005300 <can_stm32_init+0x314> @ imm = #0x30
 80052ce: 2301         	movs	r3, #0x1
 80052d0: f887 3047    	strb.w	r3, [r7, #0x47]
 80052d4: f897 3047    	ldrb.w	r3, [r7, #0x47]
 80052d8: f083 0301    	eor	r3, r3, #0x1
 80052dc: b2db         	uxtb	r3, r3
 80052de: 2b00         	cmp	r3, #0x0
 80052e0: d10e         	bne	0x8005300 <can_stm32_init+0x314> @ imm = #0x1c
 80052e2: 4b41         	ldr	r3, [pc, #0x104]        @ 0x80053e8 <can_stm32_init+0x3fc>
 80052e4: 6819         	ldr	r1, [r3]
 80052e6: 4b41         	ldr	r3, [pc, #0x104]        @ 0x80053ec <can_stm32_init+0x400>
 80052e8: 9302         	str	r3, [sp, #0x8]
 80052ea: 2300         	movs	r3, #0x0
 80052ec: 9301         	str	r3, [sp, #0x4]
 80052ee: 2300         	movs	r3, #0x0
 80052f0: 9300         	str	r3, [sp]
 80052f2: 2300         	movs	r3, #0x0
 80052f4: 2201         	movs	r2, #0x1
 80052f6: 2000         	movs	r0, #0x0
 80052f8: f00c ff82    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xcf04
 80052fc: 2300         	movs	r3, #0x0
 80052fe: 643b         	str	r3, [r7, #0x40]
; 		return -EIO;
 8005300: f06f 0304    	mvn	r3, #0x4
 8005304: e06b         	b	0x80053de <can_stm32_init+0x3f2> @ imm = #0xd6
; 	LOG_DBG("Presc: %d, TS1: %d, TS2: %d",
 8005306: 2303         	movs	r3, #0x3
 8005308: 2b03         	cmp	r3, #0x3
 800530a: d920         	bls	0x800534e <can_stm32_init+0x362> @ imm = #0x40
 800530c: 2301         	movs	r3, #0x1
 800530e: f887 3057    	strb.w	r3, [r7, #0x57]
 8005312: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8005316: f083 0301    	eor	r3, r3, #0x1
 800531a: b2db         	uxtb	r3, r3
 800531c: 2b00         	cmp	r3, #0x0
 800531e: d116         	bne	0x800534e <can_stm32_init+0x362> @ imm = #0x2c
 8005320: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80053e8 <can_stm32_init+0x3fc>
 8005322: 6819         	ldr	r1, [r3]
 8005324: 8abb         	ldrh	r3, [r7, #0x14]
 8005326: 8a3a         	ldrh	r2, [r7, #0x10]
 8005328: 8a78         	ldrh	r0, [r7, #0x12]
 800532a: 9006         	str	r0, [sp, #0x18]
 800532c: 9205         	str	r2, [sp, #0x14]
 800532e: 9304         	str	r3, [sp, #0x10]
 8005330: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x80053f0 <can_stm32_init+0x404>
 8005332: 9303         	str	r3, [sp, #0xc]
 8005334: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x80053f4 <can_stm32_init+0x408>
 8005336: 9302         	str	r3, [sp, #0x8]
 8005338: 2308         	movs	r3, #0x8
 800533a: 9301         	str	r3, [sp, #0x4]
 800533c: 2300         	movs	r3, #0x0
 800533e: 9300         	str	r3, [sp]
 8005340: 2300         	movs	r3, #0x0
 8005342: 2204         	movs	r2, #0x4
 8005344: 2000         	movs	r0, #0x0
 8005346: f00c ff5b    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xceb6
 800534a: 2300         	movs	r3, #0x0
 800534c: 653b         	str	r3, [r7, #0x50]
; 	LOG_DBG("Sample-point err : %d", ret);
 800534e: 2303         	movs	r3, #0x3
 8005350: 2b03         	cmp	r3, #0x3
 8005352: d91c         	bls	0x800538e <can_stm32_init+0x3a2> @ imm = #0x38
 8005354: 2301         	movs	r3, #0x1
 8005356: f887 304f    	strb.w	r3, [r7, #0x4f]
 800535a: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 800535e: f083 0301    	eor	r3, r3, #0x1
 8005362: b2db         	uxtb	r3, r3
 8005364: 2b00         	cmp	r3, #0x0
 8005366: d112         	bne	0x800538e <can_stm32_init+0x3a2> @ imm = #0x24
 8005368: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80053e8 <can_stm32_init+0x3fc>
 800536a: 6819         	ldr	r1, [r3]
 800536c: 6dfb         	ldr	r3, [r7, #0x5c]
 800536e: 9304         	str	r3, [sp, #0x10]
 8005370: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80053f0 <can_stm32_init+0x404>
 8005372: 9303         	str	r3, [sp, #0xc]
 8005374: 4b20         	ldr	r3, [pc, #0x80]         @ 0x80053f8 <can_stm32_init+0x40c>
 8005376: 9302         	str	r3, [sp, #0x8]
 8005378: 2308         	movs	r3, #0x8
 800537a: 9301         	str	r3, [sp, #0x4]
 800537c: 2300         	movs	r3, #0x0
 800537e: 9300         	str	r3, [sp]
 8005380: 2300         	movs	r3, #0x0
 8005382: 2204         	movs	r2, #0x4
 8005384: 2000         	movs	r0, #0x0
 8005386: f00c ff3b    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xce76
 800538a: 2300         	movs	r3, #0x0
 800538c: 64bb         	str	r3, [r7, #0x48]
; 	ret = can_set_timing(dev, &timing);
 800538e: f107 030c    	add.w	r3, r7, #0xc
 8005392: 4619         	mov	r1, r3
 8005394: 6878         	ldr	r0, [r7, #0x4]
 8005396: f00c fea5    	bl	0x80120e4 <can_set_timing> @ imm = #0xcd4a
 800539a: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 800539c: 6dfb         	ldr	r3, [r7, #0x5c]
 800539e: 2b00         	cmp	r3, #0x0
 80053a0: d001         	beq	0x80053a6 <can_stm32_init+0x3ba> @ imm = #0x2
; 		return ret;
 80053a2: 6dfb         	ldr	r3, [r7, #0x5c]
 80053a4: e01b         	b	0x80053de <can_stm32_init+0x3f2> @ imm = #0x36
; 	ret = can_stm32_set_mode(dev, CAN_MODE_NORMAL);
 80053a6: 2100         	movs	r1, #0x0
 80053a8: 6878         	ldr	r0, [r7, #0x4]
 80053aa: f7ff fcdd    	bl	0x8004d68 <can_stm32_set_mode> @ imm = #-0x646
 80053ae: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 80053b0: 6dfb         	ldr	r3, [r7, #0x5c]
 80053b2: 2b00         	cmp	r3, #0x0
 80053b4: d001         	beq	0x80053ba <can_stm32_init+0x3ce> @ imm = #0x2
; 		return ret;
 80053b6: 6dfb         	ldr	r3, [r7, #0x5c]
 80053b8: e011         	b	0x80053de <can_stm32_init+0x3f2> @ imm = #0x22
; 	(void)can_stm32_get_state(dev, &data->state, NULL);
 80053ba: 6ebb         	ldr	r3, [r7, #0x68]
 80053bc: 33f4         	adds	r3, #0xf4
 80053be: 2200         	movs	r2, #0x0
 80053c0: 4619         	mov	r1, r3
 80053c2: 6878         	ldr	r0, [r7, #0x4]
 80053c4: f00c ff97    	bl	0x80122f6 <can_stm32_get_state> @ imm = #0xcf2e
; 	cfg->config_irq(can);
 80053c8: 6e3b         	ldr	r3, [r7, #0x60]
 80053ca: 6a5b         	ldr	r3, [r3, #0x24]
 80053cc: 6e78         	ldr	r0, [r7, #0x64]
 80053ce: 4798         	blx	r3
; 	can->IER |= CAN_IER_TMEIE;
 80053d0: 6e7b         	ldr	r3, [r7, #0x64]
 80053d2: 695b         	ldr	r3, [r3, #0x14]
 80053d4: f043 0201    	orr	r2, r3, #0x1
 80053d8: 6e7b         	ldr	r3, [r7, #0x64]
 80053da: 615a         	str	r2, [r3, #0x14]
; 	return 0;
 80053dc: 2300         	movs	r3, #0x0
; }
 80053de: 4618         	mov	r0, r3
 80053e0: 3778         	adds	r7, #0x78
 80053e2: 46bd         	mov	sp, r7
 80053e4: bd80         	pop	{r7, pc}
 80053e6: bf00         	nop

080053e8 <$d>:
 80053e8: 08 03 00 20  	.word	0x20000308
 80053ec: 6c a2 01 08  	.word	0x0801a26c
 80053f0: b8 b5 01 08  	.word	0x0801b5b8
 80053f4: 90 a2 01 08  	.word	0x0801a290
 80053f8: b0 a2 01 08  	.word	0x0801a2b0

080053fc <can_stm32_send>:
; {
 80053fc: b5b0         	push	{r4, r5, r7, lr}
 80053fe: b0a2         	sub	sp, #0x88
 8005400: af0a         	add	r7, sp, #0x28
 8005402: 60f8         	str	r0, [r7, #0xc]
 8005404: 60b9         	str	r1, [r7, #0x8]
 8005406: e9c7 2300    	strd	r2, r3, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 800540a: 68fb         	ldr	r3, [r7, #0xc]
 800540c: 685b         	ldr	r3, [r3, #0x4]
 800540e: 643b         	str	r3, [r7, #0x40]
; 	struct can_stm32_data *data = dev->data;
 8005410: 68fb         	ldr	r3, [r7, #0xc]
 8005412: 691b         	ldr	r3, [r3, #0x10]
 8005414: 63fb         	str	r3, [r7, #0x3c]
; 	CAN_TypeDef *can = cfg->can;
 8005416: 6c3b         	ldr	r3, [r7, #0x40]
 8005418: 695b         	ldr	r3, [r3, #0x14]
 800541a: 63bb         	str	r3, [r7, #0x38]
; 	uint32_t transmit_status_register = 0;
 800541c: 2300         	movs	r3, #0x0
 800541e: 65bb         	str	r3, [r7, #0x58]
; 	CAN_TxMailBox_TypeDef *mailbox = NULL;
 8005420: 2300         	movs	r3, #0x0
 8005422: 64fb         	str	r3, [r7, #0x4c]
; 	struct can_stm32_mailbox *mb = NULL;
 8005424: 2300         	movs	r3, #0x0
 8005426: 64bb         	str	r3, [r7, #0x48]
; 	LOG_DBG("Sending %d bytes on %s. "
 8005428: 2303         	movs	r3, #0x3
 800542a: 2b03         	cmp	r3, #0x3
 800542c: d939         	bls	0x80054a2 <can_stm32_send+0xa6> @ imm = #0x72
 800542e: 2301         	movs	r3, #0x1
 8005430: f887 3047    	strb.w	r3, [r7, #0x47]
 8005434: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8005438: f083 0301    	eor	r3, r3, #0x1
 800543c: b2db         	uxtb	r3, r3
 800543e: 2b00         	cmp	r3, #0x0
 8005440: d12f         	bne	0x80054a2 <can_stm32_send+0xa6> @ imm = #0x5e
 8005442: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x80056b4 <can_stm32_send+0x2b8>
 8005444: 681c         	ldr	r4, [r3]
 8005446: 68bb         	ldr	r3, [r7, #0x8]
 8005448: 791b         	ldrb	r3, [r3, #0x4]
 800544a: 461d         	mov	r5, r3
 800544c: 68fb         	ldr	r3, [r7, #0xc]
 800544e: 681b         	ldr	r3, [r3]
 8005450: 68ba         	ldr	r2, [r7, #0x8]
 8005452: 6812         	ldr	r2, [r2]
 8005454: 68b9         	ldr	r1, [r7, #0x8]
 8005456: 7949         	ldrb	r1, [r1, #0x5]
 8005458: f001 0101    	and	r1, r1, #0x1
 800545c: 2900         	cmp	r1, #0x0
 800545e: d001         	beq	0x8005464 <can_stm32_send+0x68> @ imm = #0x2
 8005460: 4995         	ldr	r1, [pc, #0x254]        @ 0x80056b8 <can_stm32_send+0x2bc>
 8005462: e000         	b	0x8005466 <can_stm32_send+0x6a> @ imm = #0x0
 8005464: 4995         	ldr	r1, [pc, #0x254]        @ 0x80056bc <can_stm32_send+0x2c0>
 8005466: 68b8         	ldr	r0, [r7, #0x8]
 8005468: 7940         	ldrb	r0, [r0, #0x5]
 800546a: f000 0002    	and	r0, r0, #0x2
 800546e: 2800         	cmp	r0, #0x0
 8005470: d001         	beq	0x8005476 <can_stm32_send+0x7a> @ imm = #0x2
 8005472: 4893         	ldr	r0, [pc, #0x24c]        @ 0x80056c0 <can_stm32_send+0x2c4>
 8005474: e000         	b	0x8005478 <can_stm32_send+0x7c> @ imm = #0x0
 8005476: 4893         	ldr	r0, [pc, #0x24c]        @ 0x80056c4 <can_stm32_send+0x2c8>
 8005478: 9008         	str	r0, [sp, #0x20]
 800547a: 9107         	str	r1, [sp, #0x1c]
 800547c: 9206         	str	r2, [sp, #0x18]
 800547e: 9305         	str	r3, [sp, #0x14]
 8005480: 9504         	str	r5, [sp, #0x10]
 8005482: 4b91         	ldr	r3, [pc, #0x244]        @ 0x80056c8 <can_stm32_send+0x2cc>
 8005484: 9303         	str	r3, [sp, #0xc]
 8005486: 4b91         	ldr	r3, [pc, #0x244]        @ 0x80056cc <can_stm32_send+0x2d0>
 8005488: 9302         	str	r3, [sp, #0x8]
 800548a: 2308         	movs	r3, #0x8
 800548c: 9301         	str	r3, [sp, #0x4]
 800548e: 2300         	movs	r3, #0x0
 8005490: 9300         	str	r3, [sp]
 8005492: 2300         	movs	r3, #0x0
 8005494: 2204         	movs	r2, #0x4
 8005496: 4621         	mov	r1, r4
 8005498: 2000         	movs	r0, #0x0
 800549a: f00c feb1    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xcd62
 800549e: 2300         	movs	r3, #0x0
 80054a0: 65fb         	str	r3, [r7, #0x5c]
; 	if (frame->dlc > CAN_MAX_DLC) {
 80054a2: 68bb         	ldr	r3, [r7, #0x8]
 80054a4: 791b         	ldrb	r3, [r3, #0x4]
 80054a6: 2b08         	cmp	r3, #0x8
 80054a8: d922         	bls	0x80054f0 <can_stm32_send+0xf4> @ imm = #0x44
; 		LOG_ERR("DLC of %d exceeds maximum (%d)", frame->dlc, CAN_MAX_DLC);
 80054aa: 2303         	movs	r3, #0x3
 80054ac: 2b00         	cmp	r3, #0x0
 80054ae: d01c         	beq	0x80054ea <can_stm32_send+0xee> @ imm = #0x38
 80054b0: 2301         	movs	r3, #0x1
 80054b2: 75fb         	strb	r3, [r7, #0x17]
 80054b4: 7dfb         	ldrb	r3, [r7, #0x17]
 80054b6: f083 0301    	eor	r3, r3, #0x1
 80054ba: b2db         	uxtb	r3, r3
 80054bc: 2b00         	cmp	r3, #0x0
 80054be: d114         	bne	0x80054ea <can_stm32_send+0xee> @ imm = #0x28
 80054c0: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x80056b4 <can_stm32_send+0x2b8>
 80054c2: 6819         	ldr	r1, [r3]
 80054c4: 68bb         	ldr	r3, [r7, #0x8]
 80054c6: 791b         	ldrb	r3, [r3, #0x4]
 80054c8: 461a         	mov	r2, r3
 80054ca: 2308         	movs	r3, #0x8
 80054cc: 9304         	str	r3, [sp, #0x10]
 80054ce: 9203         	str	r2, [sp, #0xc]
 80054d0: 4b7f         	ldr	r3, [pc, #0x1fc]        @ 0x80056d0 <can_stm32_send+0x2d4>
 80054d2: 9302         	str	r3, [sp, #0x8]
 80054d4: 2300         	movs	r3, #0x0
 80054d6: 9301         	str	r3, [sp, #0x4]
 80054d8: 2300         	movs	r3, #0x0
 80054da: 9300         	str	r3, [sp]
 80054dc: 2300         	movs	r3, #0x0
 80054de: 2201         	movs	r2, #0x1
 80054e0: 2000         	movs	r0, #0x0
 80054e2: f00c fe8d    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xcd1a
 80054e6: 2300         	movs	r3, #0x0
 80054e8: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 80054ea: f06f 0315    	mvn	r3, #0x15
 80054ee: e174         	b	0x80057da <can_stm32_send+0x3de> @ imm = #0x2e8
; 	if ((frame->flags & ~(CAN_FRAME_IDE | CAN_FRAME_RTR)) != 0) {
 80054f0: 68bb         	ldr	r3, [r7, #0x8]
 80054f2: 795b         	ldrb	r3, [r3, #0x5]
 80054f4: 2b03         	cmp	r3, #0x3
 80054f6: d91f         	bls	0x8005538 <can_stm32_send+0x13c> @ imm = #0x3e
; 		LOG_ERR("unsupported CAN frame flags 0x%02x", frame->flags);
 80054f8: 2303         	movs	r3, #0x3
 80054fa: 2b00         	cmp	r3, #0x0
 80054fc: d019         	beq	0x8005532 <can_stm32_send+0x136> @ imm = #0x32
 80054fe: 2301         	movs	r3, #0x1
 8005500: 77fb         	strb	r3, [r7, #0x1f]
 8005502: 7ffb         	ldrb	r3, [r7, #0x1f]
 8005504: f083 0301    	eor	r3, r3, #0x1
 8005508: b2db         	uxtb	r3, r3
 800550a: 2b00         	cmp	r3, #0x0
 800550c: d111         	bne	0x8005532 <can_stm32_send+0x136> @ imm = #0x22
 800550e: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x80056b4 <can_stm32_send+0x2b8>
 8005510: 6819         	ldr	r1, [r3]
 8005512: 68bb         	ldr	r3, [r7, #0x8]
 8005514: 795b         	ldrb	r3, [r3, #0x5]
 8005516: 9303         	str	r3, [sp, #0xc]
 8005518: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x80056d4 <can_stm32_send+0x2d8>
 800551a: 9302         	str	r3, [sp, #0x8]
 800551c: 2300         	movs	r3, #0x0
 800551e: 9301         	str	r3, [sp, #0x4]
 8005520: 2300         	movs	r3, #0x0
 8005522: 9300         	str	r3, [sp]
 8005524: 2300         	movs	r3, #0x0
 8005526: 2201         	movs	r2, #0x1
 8005528: 2000         	movs	r0, #0x0
 800552a: f00c fe69    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xccd2
 800552e: 2300         	movs	r3, #0x0
 8005530: 61bb         	str	r3, [r7, #0x18]
; 		return -ENOTSUP;
 8005532: f06f 0385    	mvn	r3, #0x85
 8005536: e150         	b	0x80057da <can_stm32_send+0x3de> @ imm = #0x2a0
; 	if (!data->common.started) {
 8005538: 6bfb         	ldr	r3, [r7, #0x3c]
 800553a: 791b         	ldrb	r3, [r3, #0x4]
 800553c: f083 0301    	eor	r3, r3, #0x1
 8005540: b2db         	uxtb	r3, r3
 8005542: 2b00         	cmp	r3, #0x0
 8005544: d002         	beq	0x800554c <can_stm32_send+0x150> @ imm = #0x4
; 		return -ENETDOWN;
 8005546: f06f 0372    	mvn	r3, #0x72
 800554a: e146         	b	0x80057da <can_stm32_send+0x3de> @ imm = #0x28c
; 	if (can->ESR & CAN_ESR_BOFF) {
 800554c: 6bbb         	ldr	r3, [r7, #0x38]
 800554e: 699b         	ldr	r3, [r3, #0x18]
 8005550: f003 0304    	and	r3, r3, #0x4
 8005554: 2b00         	cmp	r3, #0x0
 8005556: d002         	beq	0x800555e <can_stm32_send+0x162> @ imm = #0x4
; 		return -ENETUNREACH;
 8005558: f06f 0371    	mvn	r3, #0x71
 800555c: e13d         	b	0x80057da <can_stm32_send+0x3de> @ imm = #0x27a
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 800555e: 6bfb         	ldr	r3, [r7, #0x3c]
 8005560: f103 0410    	add.w	r4, r3, #0x10
 8005564: f04f 30ff    	mov.w	r0, #0xffffffff
 8005568: f04f 31ff    	mov.w	r1, #0xffffffff
 800556c: 4602         	mov	r2, r0
 800556e: 460b         	mov	r3, r1
 8005570: 4620         	mov	r0, r4
 8005572: f00c fd5e    	bl	0x8012032 <k_mutex_lock> @ imm = #0xcabc
; 	transmit_status_register = can->TSR;
 8005576: 6bbb         	ldr	r3, [r7, #0x38]
 8005578: 689b         	ldr	r3, [r3, #0x8]
 800557a: 65bb         	str	r3, [r7, #0x58]
; 	while (!(transmit_status_register & CAN_TSR_TME)) {
 800557c: e03f         	b	0x80055fe <can_stm32_send+0x202> @ imm = #0x7e
; 		k_mutex_unlock(&data->inst_mutex);
 800557e: 6bfb         	ldr	r3, [r7, #0x3c]
 8005580: 3310         	adds	r3, #0x10
 8005582: 4618         	mov	r0, r3
 8005584: f00c fd65    	bl	0x8012052 <k_mutex_unlock> @ imm = #0xcaca
; 		LOG_DBG("Transmit buffer full");
 8005588: 2303         	movs	r3, #0x3
 800558a: 2b03         	cmp	r3, #0x3
 800558c: d91a         	bls	0x80055c4 <can_stm32_send+0x1c8> @ imm = #0x34
 800558e: 2301         	movs	r3, #0x1
 8005590: f887 3027    	strb.w	r3, [r7, #0x27]
 8005594: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8005598: f083 0301    	eor	r3, r3, #0x1
 800559c: b2db         	uxtb	r3, r3
 800559e: 2b00         	cmp	r3, #0x0
 80055a0: d110         	bne	0x80055c4 <can_stm32_send+0x1c8> @ imm = #0x20
 80055a2: 4b44         	ldr	r3, [pc, #0x110]        @ 0x80056b4 <can_stm32_send+0x2b8>
 80055a4: 6819         	ldr	r1, [r3]
 80055a6: 4b48         	ldr	r3, [pc, #0x120]        @ 0x80056c8 <can_stm32_send+0x2cc>
 80055a8: 9303         	str	r3, [sp, #0xc]
 80055aa: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x80056d8 <can_stm32_send+0x2dc>
 80055ac: 9302         	str	r3, [sp, #0x8]
 80055ae: 2308         	movs	r3, #0x8
 80055b0: 9301         	str	r3, [sp, #0x4]
 80055b2: 2300         	movs	r3, #0x0
 80055b4: 9300         	str	r3, [sp]
 80055b6: 2300         	movs	r3, #0x0
 80055b8: 2204         	movs	r2, #0x4
 80055ba: 2000         	movs	r0, #0x0
 80055bc: f00c fe20    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xcc40
 80055c0: 2300         	movs	r3, #0x0
 80055c2: 623b         	str	r3, [r7, #0x20]
; 		if (k_sem_take(&data->tx_int_sem, timeout)) {
 80055c4: 6bfb         	ldr	r3, [r7, #0x3c]
 80055c6: f103 0124    	add.w	r1, r3, #0x24
 80055ca: e9d7 2300    	ldrd	r2, r3, [r7]
 80055ce: 4608         	mov	r0, r1
 80055d0: f00c fd5b    	bl	0x801208a <k_sem_take>  @ imm = #0xcab6
 80055d4: 4603         	mov	r3, r0
 80055d6: 2b00         	cmp	r3, #0x0
 80055d8: d002         	beq	0x80055e0 <can_stm32_send+0x1e4> @ imm = #0x4
; 			return -EAGAIN;
 80055da: f06f 030a    	mvn	r3, #0xa
 80055de: e0fc         	b	0x80057da <can_stm32_send+0x3de> @ imm = #0x1f8
; 		k_mutex_lock(&data->inst_mutex, K_FOREVER);
 80055e0: 6bfb         	ldr	r3, [r7, #0x3c]
 80055e2: f103 0410    	add.w	r4, r3, #0x10
 80055e6: f04f 30ff    	mov.w	r0, #0xffffffff
 80055ea: f04f 31ff    	mov.w	r1, #0xffffffff
 80055ee: 4602         	mov	r2, r0
 80055f0: 460b         	mov	r3, r1
 80055f2: 4620         	mov	r0, r4
 80055f4: f00c fd1d    	bl	0x8012032 <k_mutex_lock> @ imm = #0xca3a
; 		transmit_status_register = can->TSR;
 80055f8: 6bbb         	ldr	r3, [r7, #0x38]
 80055fa: 689b         	ldr	r3, [r3, #0x8]
 80055fc: 65bb         	str	r3, [r7, #0x58]
; 	while (!(transmit_status_register & CAN_TSR_TME)) {
 80055fe: 6dbb         	ldr	r3, [r7, #0x58]
 8005600: f003 53e0    	and	r3, r3, #0x1c000000
 8005604: 2b00         	cmp	r3, #0x0
 8005606: d0ba         	beq	0x800557e <can_stm32_send+0x182> @ imm = #-0x8c
; 	if (transmit_status_register & CAN_TSR_TME0) {
 8005608: 6dbb         	ldr	r3, [r7, #0x58]
 800560a: f003 6380    	and	r3, r3, #0x4000000
 800560e: 2b00         	cmp	r3, #0x0
 8005610: d025         	beq	0x800565e <can_stm32_send+0x262> @ imm = #0x4a
; 		LOG_DBG("Using TX mailbox 0");
 8005612: 2303         	movs	r3, #0x3
 8005614: 2b03         	cmp	r3, #0x3
 8005616: d91a         	bls	0x800564e <can_stm32_send+0x252> @ imm = #0x34
 8005618: 2301         	movs	r3, #0x1
 800561a: f887 302f    	strb.w	r3, [r7, #0x2f]
 800561e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8005622: f083 0301    	eor	r3, r3, #0x1
 8005626: b2db         	uxtb	r3, r3
 8005628: 2b00         	cmp	r3, #0x0
 800562a: d110         	bne	0x800564e <can_stm32_send+0x252> @ imm = #0x20
 800562c: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80056b4 <can_stm32_send+0x2b8>
 800562e: 6819         	ldr	r1, [r3]
 8005630: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80056c8 <can_stm32_send+0x2cc>
 8005632: 9303         	str	r3, [sp, #0xc]
 8005634: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x80056dc <can_stm32_send+0x2e0>
 8005636: 9302         	str	r3, [sp, #0x8]
 8005638: 2308         	movs	r3, #0x8
 800563a: 9301         	str	r3, [sp, #0x4]
 800563c: 2300         	movs	r3, #0x0
 800563e: 9300         	str	r3, [sp]
 8005640: 2300         	movs	r3, #0x0
 8005642: 2204         	movs	r2, #0x4
 8005644: 2000         	movs	r0, #0x0
 8005646: f00c fddb    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xcbb6
 800564a: 2300         	movs	r3, #0x0
 800564c: 62bb         	str	r3, [r7, #0x28]
; 		mailbox = &can->sTxMailBox[0];
 800564e: 6bbb         	ldr	r3, [r7, #0x38]
 8005650: f503 73c0    	add.w	r3, r3, #0x180
 8005654: 64fb         	str	r3, [r7, #0x4c]
; 		mb = &(data->mb0);
 8005656: 6bfb         	ldr	r3, [r7, #0x3c]
 8005658: 3334         	adds	r3, #0x34
 800565a: 64bb         	str	r3, [r7, #0x48]
 800565c: e06c         	b	0x8005738 <can_stm32_send+0x33c> @ imm = #0xd8
; 	} else if (transmit_status_register & CAN_TSR_TME1) {
 800565e: 6dbb         	ldr	r3, [r7, #0x58]
 8005660: f003 6300    	and	r3, r3, #0x8000000
 8005664: 2b00         	cmp	r3, #0x0
 8005666: d03d         	beq	0x80056e4 <can_stm32_send+0x2e8> @ imm = #0x7a
; 		LOG_DBG("Using TX mailbox 1");
 8005668: 2303         	movs	r3, #0x3
 800566a: 2b03         	cmp	r3, #0x3
 800566c: d91a         	bls	0x80056a4 <can_stm32_send+0x2a8> @ imm = #0x34
 800566e: 2301         	movs	r3, #0x1
 8005670: f887 3037    	strb.w	r3, [r7, #0x37]
 8005674: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8005678: f083 0301    	eor	r3, r3, #0x1
 800567c: b2db         	uxtb	r3, r3
 800567e: 2b00         	cmp	r3, #0x0
 8005680: d110         	bne	0x80056a4 <can_stm32_send+0x2a8> @ imm = #0x20
 8005682: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80056b4 <can_stm32_send+0x2b8>
 8005684: 6819         	ldr	r1, [r3]
 8005686: 4b10         	ldr	r3, [pc, #0x40]         @ 0x80056c8 <can_stm32_send+0x2cc>
 8005688: 9303         	str	r3, [sp, #0xc]
 800568a: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80056e0 <can_stm32_send+0x2e4>
 800568c: 9302         	str	r3, [sp, #0x8]
 800568e: 2308         	movs	r3, #0x8
 8005690: 9301         	str	r3, [sp, #0x4]
 8005692: 2300         	movs	r3, #0x0
 8005694: 9300         	str	r3, [sp]
 8005696: 2300         	movs	r3, #0x0
 8005698: 2204         	movs	r2, #0x4
 800569a: 2000         	movs	r0, #0x0
 800569c: f00c fdb0    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xcb60
 80056a0: 2300         	movs	r3, #0x0
 80056a2: 633b         	str	r3, [r7, #0x30]
; 		mailbox = &can->sTxMailBox[1];
 80056a4: 6bbb         	ldr	r3, [r7, #0x38]
 80056a6: f503 73c8    	add.w	r3, r3, #0x190
 80056aa: 64fb         	str	r3, [r7, #0x4c]
; 		mb = &data->mb1;
 80056ac: 6bfb         	ldr	r3, [r7, #0x3c]
 80056ae: 333c         	adds	r3, #0x3c
 80056b0: 64bb         	str	r3, [r7, #0x48]
 80056b2: e041         	b	0x8005738 <can_stm32_send+0x33c> @ imm = #0x82

080056b4 <$d>:
 80056b4: 08 03 00 20  	.word	0x20000308
 80056b8: cc a2 01 08  	.word	0x0801a2cc
 80056bc: d8 a2 01 08  	.word	0x0801a2d8
 80056c0: e4 a2 01 08  	.word	0x0801a2e4
 80056c4: e8 a2 01 08  	.word	0x0801a2e8
 80056c8: c8 b5 01 08  	.word	0x0801b5c8
 80056cc: ec a2 01 08  	.word	0x0801a2ec
 80056d0: 30 a3 01 08  	.word	0x0801a330
 80056d4: 50 a3 01 08  	.word	0x0801a350
 80056d8: 74 a3 01 08  	.word	0x0801a374
 80056dc: 90 a3 01 08  	.word	0x0801a390
 80056e0: a8 a3 01 08  	.word	0x0801a3a8

080056e4 <$t>:
; 	} else if (transmit_status_register & CAN_TSR_TME2) {
 80056e4: 6dbb         	ldr	r3, [r7, #0x58]
 80056e6: f003 5380    	and	r3, r3, #0x10000000
 80056ea: 2b00         	cmp	r3, #0x0
 80056ec: d024         	beq	0x8005738 <can_stm32_send+0x33c> @ imm = #0x48
; 		LOG_DBG("Using TX mailbox 2");
 80056ee: 2303         	movs	r3, #0x3
 80056f0: 2b03         	cmp	r3, #0x3
 80056f2: d91a         	bls	0x800572a <can_stm32_send+0x32e> @ imm = #0x34
 80056f4: 2301         	movs	r3, #0x1
 80056f6: f887 3057    	strb.w	r3, [r7, #0x57]
 80056fa: f897 3057    	ldrb.w	r3, [r7, #0x57]
 80056fe: f083 0301    	eor	r3, r3, #0x1
 8005702: b2db         	uxtb	r3, r3
 8005704: 2b00         	cmp	r3, #0x0
 8005706: d110         	bne	0x800572a <can_stm32_send+0x32e> @ imm = #0x20
 8005708: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80057e4 <can_stm32_send+0x3e8>
 800570a: 6819         	ldr	r1, [r3]
 800570c: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80057e8 <can_stm32_send+0x3ec>
 800570e: 9303         	str	r3, [sp, #0xc]
 8005710: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80057ec <can_stm32_send+0x3f0>
 8005712: 9302         	str	r3, [sp, #0x8]
 8005714: 2308         	movs	r3, #0x8
 8005716: 9301         	str	r3, [sp, #0x4]
 8005718: 2300         	movs	r3, #0x0
 800571a: 9300         	str	r3, [sp]
 800571c: 2300         	movs	r3, #0x0
 800571e: 2204         	movs	r2, #0x4
 8005720: 2000         	movs	r0, #0x0
 8005722: f00c fd6d    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xcada
 8005726: 2300         	movs	r3, #0x0
 8005728: 653b         	str	r3, [r7, #0x50]
; 		mailbox = &can->sTxMailBox[2];
 800572a: 6bbb         	ldr	r3, [r7, #0x38]
 800572c: f503 73d0    	add.w	r3, r3, #0x1a0
 8005730: 64fb         	str	r3, [r7, #0x4c]
; 		mb = &data->mb2;
 8005732: 6bfb         	ldr	r3, [r7, #0x3c]
 8005734: 3344         	adds	r3, #0x44
 8005736: 64bb         	str	r3, [r7, #0x48]
; 	mb->tx_callback = callback;
 8005738: 6cbb         	ldr	r3, [r7, #0x48]
 800573a: 6f3a         	ldr	r2, [r7, #0x70]
 800573c: 601a         	str	r2, [r3]
; 	mb->callback_arg = user_data;
 800573e: 6cbb         	ldr	r3, [r7, #0x48]
 8005740: 6f7a         	ldr	r2, [r7, #0x74]
 8005742: 605a         	str	r2, [r3, #0x4]
; 	mailbox->TIR &= CAN_TI0R_TXRQ;
 8005744: 6cfb         	ldr	r3, [r7, #0x4c]
 8005746: 681b         	ldr	r3, [r3]
 8005748: f003 0201    	and	r2, r3, #0x1
 800574c: 6cfb         	ldr	r3, [r7, #0x4c]
 800574e: 601a         	str	r2, [r3]
; 	if ((frame->flags & CAN_FRAME_IDE) != 0) {
 8005750: 68bb         	ldr	r3, [r7, #0x8]
 8005752: 795b         	ldrb	r3, [r3, #0x5]
 8005754: f003 0301    	and	r3, r3, #0x1
 8005758: 2b00         	cmp	r3, #0x0
 800575a: d00a         	beq	0x8005772 <can_stm32_send+0x376> @ imm = #0x14
; 		mailbox->TIR |= (frame->id << CAN_TI0R_EXID_Pos)
 800575c: 6cfb         	ldr	r3, [r7, #0x4c]
 800575e: 681a         	ldr	r2, [r3]
 8005760: 68bb         	ldr	r3, [r7, #0x8]
 8005762: 681b         	ldr	r3, [r3]
 8005764: 00db         	lsls	r3, r3, #0x3
 8005766: 4313         	orrs	r3, r2
 8005768: f043 0204    	orr	r2, r3, #0x4
 800576c: 6cfb         	ldr	r3, [r7, #0x4c]
 800576e: 601a         	str	r2, [r3]
 8005770: e007         	b	0x8005782 <can_stm32_send+0x386> @ imm = #0xe
; 		mailbox->TIR |= (frame->id << CAN_TI0R_STID_Pos);
 8005772: 6cfb         	ldr	r3, [r7, #0x4c]
 8005774: 681a         	ldr	r2, [r3]
 8005776: 68bb         	ldr	r3, [r7, #0x8]
 8005778: 681b         	ldr	r3, [r3]
 800577a: 055b         	lsls	r3, r3, #0x15
 800577c: 431a         	orrs	r2, r3
 800577e: 6cfb         	ldr	r3, [r7, #0x4c]
 8005780: 601a         	str	r2, [r3]
; 	if ((frame->flags & CAN_FRAME_RTR) != 0) {
 8005782: 68bb         	ldr	r3, [r7, #0x8]
 8005784: 795b         	ldrb	r3, [r3, #0x5]
 8005786: f003 0302    	and	r3, r3, #0x2
 800578a: 2b00         	cmp	r3, #0x0
 800578c: d006         	beq	0x800579c <can_stm32_send+0x3a0> @ imm = #0xc
; 		mailbox->TIR |= CAN_TI1R_RTR;
 800578e: 6cfb         	ldr	r3, [r7, #0x4c]
 8005790: 681b         	ldr	r3, [r3]
 8005792: f043 0202    	orr	r2, r3, #0x2
 8005796: 6cfb         	ldr	r3, [r7, #0x4c]
 8005798: 601a         	str	r2, [r3]
 800579a: e007         	b	0x80057ac <can_stm32_send+0x3b0> @ imm = #0xe
; 		mailbox->TDLR = frame->data_32[0];
 800579c: 68bb         	ldr	r3, [r7, #0x8]
 800579e: 689a         	ldr	r2, [r3, #0x8]
 80057a0: 6cfb         	ldr	r3, [r7, #0x4c]
 80057a2: 609a         	str	r2, [r3, #0x8]
; 		mailbox->TDHR = frame->data_32[1];
 80057a4: 68bb         	ldr	r3, [r7, #0x8]
 80057a6: 68da         	ldr	r2, [r3, #0xc]
 80057a8: 6cfb         	ldr	r3, [r7, #0x4c]
 80057aa: 60da         	str	r2, [r3, #0xc]
; 	mailbox->TDTR = (mailbox->TDTR & ~CAN_TDT1R_DLC) |
 80057ac: 6cfb         	ldr	r3, [r7, #0x4c]
 80057ae: 685b         	ldr	r3, [r3, #0x4]
 80057b0: f023 020f    	bic	r2, r3, #0xf
; 			((frame->dlc & 0xF) << CAN_TDT1R_DLC_Pos);
 80057b4: 68bb         	ldr	r3, [r7, #0x8]
 80057b6: 791b         	ldrb	r3, [r3, #0x4]
 80057b8: f003 030f    	and	r3, r3, #0xf
; 	mailbox->TDTR = (mailbox->TDTR & ~CAN_TDT1R_DLC) |
 80057bc: 431a         	orrs	r2, r3
 80057be: 6cfb         	ldr	r3, [r7, #0x4c]
 80057c0: 605a         	str	r2, [r3, #0x4]
; 	mailbox->TIR |= CAN_TI0R_TXRQ;
 80057c2: 6cfb         	ldr	r3, [r7, #0x4c]
 80057c4: 681b         	ldr	r3, [r3]
 80057c6: f043 0201    	orr	r2, r3, #0x1
 80057ca: 6cfb         	ldr	r3, [r7, #0x4c]
 80057cc: 601a         	str	r2, [r3]
; 	k_mutex_unlock(&data->inst_mutex);
 80057ce: 6bfb         	ldr	r3, [r7, #0x3c]
 80057d0: 3310         	adds	r3, #0x10
 80057d2: 4618         	mov	r0, r3
 80057d4: f00c fc3d    	bl	0x8012052 <k_mutex_unlock> @ imm = #0xc87a
; 	return 0;
 80057d8: 2300         	movs	r3, #0x0
; }
 80057da: 4618         	mov	r0, r3
 80057dc: 3760         	adds	r7, #0x60
 80057de: 46bd         	mov	sp, r7
 80057e0: bdb0         	pop	{r4, r5, r7, pc}
 80057e2: bf00         	nop

080057e4 <$d>:
 80057e4: 08 03 00 20  	.word	0x20000308
 80057e8: c8 b5 01 08  	.word	0x0801b5c8
 80057ec: c0 a3 01 08  	.word	0x0801a3c0

080057f0 <can_stm32_set_filter>:
; {
 80057f0: b580         	push	{r7, lr}
 80057f2: b098         	sub	sp, #0x60
 80057f4: af08         	add	r7, sp, #0x20
 80057f6: 6078         	str	r0, [r7, #0x4]
 80057f8: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 80057fa: 687b         	ldr	r3, [r7, #0x4]
 80057fc: 685b         	ldr	r3, [r3, #0x4]
 80057fe: 623b         	str	r3, [r7, #0x20]
; 	struct can_stm32_data *data = dev->data;
 8005800: 687b         	ldr	r3, [r7, #0x4]
 8005802: 691b         	ldr	r3, [r3, #0x10]
 8005804: 61fb         	str	r3, [r7, #0x1c]
; 	CAN_TypeDef *can = cfg->master_can;
 8005806: 6a3b         	ldr	r3, [r7, #0x20]
 8005808: 699b         	ldr	r3, [r3, #0x18]
 800580a: 61bb         	str	r3, [r7, #0x18]
; 	uint32_t mask = 0U;
 800580c: 2300         	movs	r3, #0x0
 800580e: 62fb         	str	r3, [r7, #0x2c]
; 	uint32_t id = 0U;
 8005810: 2300         	movs	r3, #0x0
 8005812: 633b         	str	r3, [r7, #0x30]
; 	int filter_id = -ENOSPC;
 8005814: f06f 031b    	mvn	r3, #0x1b
 8005818: 63fb         	str	r3, [r7, #0x3c]
; 	int bank_offset = 0;
 800581a: 2300         	movs	r3, #0x0
 800581c: 63bb         	str	r3, [r7, #0x38]
; 	if (cfg->can != cfg->master_can) {
 800581e: 6a3b         	ldr	r3, [r7, #0x20]
 8005820: 695a         	ldr	r2, [r3, #0x14]
 8005822: 6a3b         	ldr	r3, [r7, #0x20]
 8005824: 699b         	ldr	r3, [r3, #0x18]
 8005826: 429a         	cmp	r2, r3
 8005828: d001         	beq	0x800582e <can_stm32_set_filter+0x3e> @ imm = #0x2
; 		bank_offset = CAN_STM32_NUM_FILTER_BANKS;
 800582a: 230e         	movs	r3, #0xe
 800582c: 63bb         	str	r3, [r7, #0x38]
; 	if ((filter->flags & CAN_FILTER_IDE) != 0) {
 800582e: 683b         	ldr	r3, [r7]
 8005830: 7a1b         	ldrb	r3, [r3, #0x8]
 8005832: f003 0301    	and	r3, r3, #0x1
 8005836: 2b00         	cmp	r3, #0x0
 8005838: d020         	beq	0x800587c <can_stm32_set_filter+0x8c> @ imm = #0x40
; 		for (int i = 0; i < CONFIG_CAN_MAX_EXT_ID_FILTER; i++) {
 800583a: 2300         	movs	r3, #0x0
 800583c: 62bb         	str	r3, [r7, #0x28]
 800583e: e019         	b	0x8005874 <can_stm32_set_filter+0x84> @ imm = #0x32
; 			if (data->rx_cb_ext[i] == NULL) {
 8005840: 69fa         	ldr	r2, [r7, #0x1c]
 8005842: 6abb         	ldr	r3, [r7, #0x28]
 8005844: 3320         	adds	r3, #0x20
 8005846: 009b         	lsls	r3, r3, #0x2
 8005848: 4413         	add	r3, r2
 800584a: 685b         	ldr	r3, [r3, #0x4]
 800584c: 2b00         	cmp	r3, #0x0
 800584e: d10e         	bne	0x800586e <can_stm32_set_filter+0x7e> @ imm = #0x1c
; 				id = can_stm32_filter_to_ext_id(filter);
 8005850: 6838         	ldr	r0, [r7]
 8005852: f00c ff73    	bl	0x801273c <can_stm32_filter_to_ext_id> @ imm = #0xcee6
 8005856: 6338         	str	r0, [r7, #0x30]
; 				mask = can_stm32_filter_to_ext_mask(filter);
 8005858: 6838         	ldr	r0, [r7]
 800585a: f00c ff50    	bl	0x80126fe <can_stm32_filter_to_ext_mask> @ imm = #0xcea0
 800585e: 62f8         	str	r0, [r7, #0x2c]
; 				filter_id = i;
 8005860: 6abb         	ldr	r3, [r7, #0x28]
 8005862: 63fb         	str	r3, [r7, #0x3c]
; 				bank_num = bank_offset + i;
 8005864: 6bba         	ldr	r2, [r7, #0x38]
 8005866: 6abb         	ldr	r3, [r7, #0x28]
 8005868: 4413         	add	r3, r2
 800586a: 637b         	str	r3, [r7, #0x34]
; 				break;
 800586c: e02b         	b	0x80058c6 <can_stm32_set_filter+0xd6> @ imm = #0x56
; 		for (int i = 0; i < CONFIG_CAN_MAX_EXT_ID_FILTER; i++) {
 800586e: 6abb         	ldr	r3, [r7, #0x28]
 8005870: 3301         	adds	r3, #0x1
 8005872: 62bb         	str	r3, [r7, #0x28]
 8005874: 6abb         	ldr	r3, [r7, #0x28]
 8005876: 2b06         	cmp	r3, #0x6
 8005878: dde2         	ble	0x8005840 <can_stm32_set_filter+0x50> @ imm = #-0x3c
 800587a: e024         	b	0x80058c6 <can_stm32_set_filter+0xd6> @ imm = #0x48
; 		for (int i = 0; i < CONFIG_CAN_MAX_STD_ID_FILTER; i++) {
 800587c: 2300         	movs	r3, #0x0
 800587e: 627b         	str	r3, [r7, #0x24]
 8005880: e01e         	b	0x80058c0 <can_stm32_set_filter+0xd0> @ imm = #0x3c
; 			if (data->rx_cb_std[i] == NULL) {
 8005882: 69fa         	ldr	r2, [r7, #0x1c]
 8005884: 6a7b         	ldr	r3, [r7, #0x24]
 8005886: 3312         	adds	r3, #0x12
 8005888: 009b         	lsls	r3, r3, #0x2
 800588a: 4413         	add	r3, r2
 800588c: 685b         	ldr	r3, [r3, #0x4]
 800588e: 2b00         	cmp	r3, #0x0
 8005890: d113         	bne	0x80058ba <can_stm32_set_filter+0xca> @ imm = #0x26
; 				id = can_stm32_filter_to_std_id(filter);
 8005892: 6838         	ldr	r0, [r7]
 8005894: f00c ff46    	bl	0x8012724 <can_stm32_filter_to_std_id> @ imm = #0xce8c
 8005898: 6338         	str	r0, [r7, #0x30]
; 				mask = can_stm32_filter_to_std_mask(filter);
 800589a: 6838         	ldr	r0, [r7]
 800589c: f00c ff1c    	bl	0x80126d8 <can_stm32_filter_to_std_mask> @ imm = #0xce38
 80058a0: 62f8         	str	r0, [r7, #0x2c]
; 				filter_id = CONFIG_CAN_MAX_EXT_ID_FILTER + i;
 80058a2: 6a7b         	ldr	r3, [r7, #0x24]
 80058a4: 3307         	adds	r3, #0x7
 80058a6: 63fb         	str	r3, [r7, #0x3c]
; 				bank_num = bank_offset + CONFIG_CAN_MAX_EXT_ID_FILTER + i / 2;
 80058a8: 6bbb         	ldr	r3, [r7, #0x38]
 80058aa: 1dda         	adds	r2, r3, #0x7
 80058ac: 6a7b         	ldr	r3, [r7, #0x24]
 80058ae: 0fd9         	lsrs	r1, r3, #0x1f
 80058b0: 440b         	add	r3, r1
 80058b2: 105b         	asrs	r3, r3, #0x1
 80058b4: 4413         	add	r3, r2
 80058b6: 637b         	str	r3, [r7, #0x34]
; 				break;
 80058b8: e005         	b	0x80058c6 <can_stm32_set_filter+0xd6> @ imm = #0xa
; 		for (int i = 0; i < CONFIG_CAN_MAX_STD_ID_FILTER; i++) {
 80058ba: 6a7b         	ldr	r3, [r7, #0x24]
 80058bc: 3301         	adds	r3, #0x1
 80058be: 627b         	str	r3, [r7, #0x24]
 80058c0: 6a7b         	ldr	r3, [r7, #0x24]
 80058c2: 2b0d         	cmp	r3, #0xd
 80058c4: dddd         	ble	0x8005882 <can_stm32_set_filter+0x92> @ imm = #-0x46
; 	if (filter_id != -ENOSPC) {
 80058c6: 6bfb         	ldr	r3, [r7, #0x3c]
 80058c8: f113 0f1c    	cmn.w	r3, #0x1c
 80058cc: d053         	beq	0x8005976 <can_stm32_set_filter+0x186> @ imm = #0xa6
; 		LOG_DBG("Adding filter_id %d, CAN ID: 0x%x, mask: 0x%x",
 80058ce: 2303         	movs	r3, #0x3
 80058d0: 2b03         	cmp	r3, #0x3
 80058d2: d920         	bls	0x8005916 <can_stm32_set_filter+0x126> @ imm = #0x40
 80058d4: 2301         	movs	r3, #0x1
 80058d6: 73fb         	strb	r3, [r7, #0xf]
 80058d8: 7bfb         	ldrb	r3, [r7, #0xf]
 80058da: f083 0301    	eor	r3, r3, #0x1
 80058de: b2db         	uxtb	r3, r3
 80058e0: 2b00         	cmp	r3, #0x0
 80058e2: d118         	bne	0x8005916 <can_stm32_set_filter+0x126> @ imm = #0x30
 80058e4: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80059b4 <can_stm32_set_filter+0x1c4>
 80058e6: 6819         	ldr	r1, [r3]
 80058e8: 683b         	ldr	r3, [r7]
 80058ea: 681b         	ldr	r3, [r3]
 80058ec: 683a         	ldr	r2, [r7]
 80058ee: 6852         	ldr	r2, [r2, #0x4]
 80058f0: 9206         	str	r2, [sp, #0x18]
 80058f2: 9305         	str	r3, [sp, #0x14]
 80058f4: 6bfb         	ldr	r3, [r7, #0x3c]
 80058f6: 9304         	str	r3, [sp, #0x10]
 80058f8: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x80059b8 <can_stm32_set_filter+0x1c8>
 80058fa: 9303         	str	r3, [sp, #0xc]
 80058fc: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x80059bc <can_stm32_set_filter+0x1cc>
 80058fe: 9302         	str	r3, [sp, #0x8]
 8005900: 2308         	movs	r3, #0x8
 8005902: 9301         	str	r3, [sp, #0x4]
 8005904: 2300         	movs	r3, #0x0
 8005906: 9300         	str	r3, [sp]
 8005908: 2300         	movs	r3, #0x0
 800590a: 2204         	movs	r2, #0x4
 800590c: 2000         	movs	r0, #0x0
 800590e: f00c fc77    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xc8ee
 8005912: 2300         	movs	r3, #0x0
 8005914: 60bb         	str	r3, [r7, #0x8]
; 		can->FMR |= CAN_FMR_FINIT;
 8005916: 69bb         	ldr	r3, [r7, #0x18]
 8005918: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 800591c: f043 0201    	orr	r2, r3, #0x1
 8005920: 69bb         	ldr	r3, [r7, #0x18]
 8005922: f8c3 2200    	str.w	r2, [r3, #0x200]
; 		can_stm32_set_filter_bank(filter_id, &can->sFilterRegister[bank_num],
 8005926: 6b7b         	ldr	r3, [r7, #0x34]
 8005928: 3348         	adds	r3, #0x48
 800592a: 00db         	lsls	r3, r3, #0x3
 800592c: 69ba         	ldr	r2, [r7, #0x18]
 800592e: 18d1         	adds	r1, r2, r3
; 					  (filter->flags & CAN_FILTER_IDE) != 0,
 8005930: 683b         	ldr	r3, [r7]
 8005932: 7a1b         	ldrb	r3, [r3, #0x8]
 8005934: f003 0301    	and	r3, r3, #0x1
; 		can_stm32_set_filter_bank(filter_id, &can->sFilterRegister[bank_num],
 8005938: 2b00         	cmp	r3, #0x0
 800593a: bf14         	ite	ne
 800593c: 2301         	movne	r3, #0x1
 800593e: 2300         	moveq	r3, #0x0
 8005940: b2da         	uxtb	r2, r3
 8005942: 6afb         	ldr	r3, [r7, #0x2c]
 8005944: 9300         	str	r3, [sp]
 8005946: 6b3b         	ldr	r3, [r7, #0x30]
 8005948: 6bf8         	ldr	r0, [r7, #0x3c]
 800594a: f00c fe9b    	bl	0x8012684 <can_stm32_set_filter_bank> @ imm = #0xcd36
; 		can->FA1R |= 1U << bank_num;
 800594e: 69bb         	ldr	r3, [r7, #0x18]
 8005950: f8d3 221c    	ldr.w	r2, [r3, #0x21c]
 8005954: 2101         	movs	r1, #0x1
 8005956: 6b7b         	ldr	r3, [r7, #0x34]
 8005958: fa01 f303    	lsl.w	r3, r1, r3
 800595c: 431a         	orrs	r2, r3
 800595e: 69bb         	ldr	r3, [r7, #0x18]
 8005960: f8c3 221c    	str.w	r2, [r3, #0x21c]
; 		can->FMR &= ~(CAN_FMR_FINIT);
 8005964: 69bb         	ldr	r3, [r7, #0x18]
 8005966: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 800596a: f023 0201    	bic	r2, r3, #0x1
 800596e: 69bb         	ldr	r3, [r7, #0x18]
 8005970: f8c3 2200    	str.w	r2, [r3, #0x200]
 8005974: e019         	b	0x80059aa <can_stm32_set_filter+0x1ba> @ imm = #0x32
; 		LOG_WRN("No free filter left");
 8005976: 2303         	movs	r3, #0x3
 8005978: 2b01         	cmp	r3, #0x1
 800597a: d916         	bls	0x80059aa <can_stm32_set_filter+0x1ba> @ imm = #0x2c
 800597c: 2301         	movs	r3, #0x1
 800597e: 75fb         	strb	r3, [r7, #0x17]
 8005980: 7dfb         	ldrb	r3, [r7, #0x17]
 8005982: f083 0301    	eor	r3, r3, #0x1
 8005986: b2db         	uxtb	r3, r3
 8005988: 2b00         	cmp	r3, #0x0
 800598a: d10e         	bne	0x80059aa <can_stm32_set_filter+0x1ba> @ imm = #0x1c
 800598c: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80059b4 <can_stm32_set_filter+0x1c4>
 800598e: 6819         	ldr	r1, [r3]
 8005990: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80059c0 <can_stm32_set_filter+0x1d0>
 8005992: 9302         	str	r3, [sp, #0x8]
 8005994: 2300         	movs	r3, #0x0
 8005996: 9301         	str	r3, [sp, #0x4]
 8005998: 2300         	movs	r3, #0x0
 800599a: 9300         	str	r3, [sp]
 800599c: 2300         	movs	r3, #0x0
 800599e: 2202         	movs	r2, #0x2
 80059a0: 2000         	movs	r0, #0x0
 80059a2: f00c fc2d    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xc85a
 80059a6: 2300         	movs	r3, #0x0
 80059a8: 613b         	str	r3, [r7, #0x10]
; 	return filter_id;
 80059aa: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 80059ac: 4618         	mov	r0, r3
 80059ae: 3740         	adds	r7, #0x40
 80059b0: 46bd         	mov	sp, r7
 80059b2: bd80         	pop	{r7, pc}

080059b4 <$d>:
 80059b4: 08 03 00 20  	.word	0x20000308
 80059b8: d8 b5 01 08  	.word	0x0801b5d8
 80059bc: d8 a3 01 08  	.word	0x0801a3d8
 80059c0: 0c a4 01 08  	.word	0x0801a40c

080059c4 <can_stm32_add_rx_filter>:
; {
 80059c4: b580         	push	{r7, lr}
 80059c6: b08c         	sub	sp, #0x30
 80059c8: af04         	add	r7, sp, #0x10
 80059ca: 60f8         	str	r0, [r7, #0xc]
 80059cc: 60b9         	str	r1, [r7, #0x8]
 80059ce: 607a         	str	r2, [r7, #0x4]
 80059d0: 603b         	str	r3, [r7]
; 	struct can_stm32_data *data = dev->data;
 80059d2: 68fb         	ldr	r3, [r7, #0xc]
 80059d4: 691b         	ldr	r3, [r3, #0x10]
 80059d6: 61fb         	str	r3, [r7, #0x1c]
; 	if ((filter->flags & ~(CAN_FILTER_IDE)) != 0) {
 80059d8: 683b         	ldr	r3, [r7]
 80059da: 7a1b         	ldrb	r3, [r3, #0x8]
 80059dc: 2b01         	cmp	r3, #0x1
 80059de: d91f         	bls	0x8005a20 <can_stm32_add_rx_filter+0x5c> @ imm = #0x3e
; 		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
 80059e0: 2303         	movs	r3, #0x3
 80059e2: 2b00         	cmp	r3, #0x0
 80059e4: d019         	beq	0x8005a1a <can_stm32_add_rx_filter+0x56> @ imm = #0x32
 80059e6: 2301         	movs	r3, #0x1
 80059e8: 75fb         	strb	r3, [r7, #0x17]
 80059ea: 7dfb         	ldrb	r3, [r7, #0x17]
 80059ec: f083 0301    	eor	r3, r3, #0x1
 80059f0: b2db         	uxtb	r3, r3
 80059f2: 2b00         	cmp	r3, #0x0
 80059f4: d111         	bne	0x8005a1a <can_stm32_add_rx_filter+0x56> @ imm = #0x22
 80059f6: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8005ab4 <can_stm32_add_rx_filter+0xf0>
 80059f8: 6819         	ldr	r1, [r3]
 80059fa: 683b         	ldr	r3, [r7]
 80059fc: 7a1b         	ldrb	r3, [r3, #0x8]
 80059fe: 9303         	str	r3, [sp, #0xc]
 8005a00: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8005ab8 <can_stm32_add_rx_filter+0xf4>
 8005a02: 9302         	str	r3, [sp, #0x8]
 8005a04: 2300         	movs	r3, #0x0
 8005a06: 9301         	str	r3, [sp, #0x4]
 8005a08: 2300         	movs	r3, #0x0
 8005a0a: 9300         	str	r3, [sp]
 8005a0c: 2300         	movs	r3, #0x0
 8005a0e: 2201         	movs	r2, #0x1
 8005a10: 2000         	movs	r0, #0x0
 8005a12: f00c fbf5    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xc7ea
 8005a16: 2300         	movs	r3, #0x0
 8005a18: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 8005a1a: f06f 0185    	mvn	r1, #0x85
 8005a1e: e044         	b	0x8005aaa <can_stm32_add_rx_filter+0xe6> @ imm = #0x88
; 	k_mutex_lock(&filter_mutex, K_FOREVER);
 8005a20: f04f 32ff    	mov.w	r2, #0xffffffff
 8005a24: f04f 33ff    	mov.w	r3, #0xffffffff
 8005a28: 4824         	ldr	r0, [pc, #0x90]         @ 0x8005abc <can_stm32_add_rx_filter+0xf8>
 8005a2a: f00c fb02    	bl	0x8012032 <k_mutex_lock> @ imm = #0xc604
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8005a2e: 69fb         	ldr	r3, [r7, #0x1c]
 8005a30: f103 0110    	add.w	r1, r3, #0x10
 8005a34: f04f 32ff    	mov.w	r2, #0xffffffff
 8005a38: f04f 33ff    	mov.w	r3, #0xffffffff
 8005a3c: 4608         	mov	r0, r1
 8005a3e: f00c faf8    	bl	0x8012032 <k_mutex_lock> @ imm = #0xc5f0
; 	filter_id = can_stm32_set_filter(dev, filter);
 8005a42: 6839         	ldr	r1, [r7]
 8005a44: 68f8         	ldr	r0, [r7, #0xc]
 8005a46: f7ff fed3    	bl	0x80057f0 <can_stm32_set_filter> @ imm = #-0x25a
 8005a4a: 61b8         	str	r0, [r7, #0x18]
; 	if (filter_id >= 0) {
 8005a4c: 69bb         	ldr	r3, [r7, #0x18]
 8005a4e: 2b00         	cmp	r3, #0x0
 8005a50: db22         	blt	0x8005a98 <can_stm32_add_rx_filter+0xd4> @ imm = #0x44
; 		if ((filter->flags & CAN_FILTER_IDE) != 0) {
 8005a52: 683b         	ldr	r3, [r7]
 8005a54: 7a1b         	ldrb	r3, [r3, #0x8]
 8005a56: f003 0301    	and	r3, r3, #0x1
 8005a5a: 2b00         	cmp	r3, #0x0
 8005a5c: d00d         	beq	0x8005a7a <can_stm32_add_rx_filter+0xb6> @ imm = #0x1a
; 			data->rx_cb_ext[filter_id] = cb;
 8005a5e: 69fa         	ldr	r2, [r7, #0x1c]
 8005a60: 69bb         	ldr	r3, [r7, #0x18]
 8005a62: 3320         	adds	r3, #0x20
 8005a64: 009b         	lsls	r3, r3, #0x2
 8005a66: 4413         	add	r3, r2
 8005a68: 68ba         	ldr	r2, [r7, #0x8]
 8005a6a: 605a         	str	r2, [r3, #0x4]
; 			data->cb_arg_ext[filter_id] = cb_arg;
 8005a6c: 69fb         	ldr	r3, [r7, #0x1c]
 8005a6e: 69ba         	ldr	r2, [r7, #0x18]
 8005a70: 3236         	adds	r2, #0x36
 8005a72: 6879         	ldr	r1, [r7, #0x4]
 8005a74: f843 1022    	str.w	r1, [r3, r2, lsl #2]
 8005a78: e00e         	b	0x8005a98 <can_stm32_add_rx_filter+0xd4> @ imm = #0x1c
; 			data->rx_cb_std[filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER] = cb;
 8005a7a: 69bb         	ldr	r3, [r7, #0x18]
 8005a7c: 3b07         	subs	r3, #0x7
 8005a7e: 69fa         	ldr	r2, [r7, #0x1c]
 8005a80: 3312         	adds	r3, #0x12
 8005a82: 009b         	lsls	r3, r3, #0x2
 8005a84: 4413         	add	r3, r2
 8005a86: 68ba         	ldr	r2, [r7, #0x8]
 8005a88: 605a         	str	r2, [r3, #0x4]
; 			data->cb_arg_std[filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER] = cb_arg;
 8005a8a: 69bb         	ldr	r3, [r7, #0x18]
 8005a8c: 1fda         	subs	r2, r3, #0x7
 8005a8e: 69fb         	ldr	r3, [r7, #0x1c]
 8005a90: 3228         	adds	r2, #0x28
 8005a92: 6879         	ldr	r1, [r7, #0x4]
 8005a94: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 	k_mutex_unlock(&data->inst_mutex);
 8005a98: 69fb         	ldr	r3, [r7, #0x1c]
 8005a9a: 3310         	adds	r3, #0x10
 8005a9c: 4618         	mov	r0, r3
 8005a9e: f00c fad8    	bl	0x8012052 <k_mutex_unlock> @ imm = #0xc5b0
; 	k_mutex_unlock(&filter_mutex);
 8005aa2: 4806         	ldr	r0, [pc, #0x18]         @ 0x8005abc <can_stm32_add_rx_filter+0xf8>
 8005aa4: f00c fad5    	bl	0x8012052 <k_mutex_unlock> @ imm = #0xc5aa
; 	return filter_id;
 8005aa8: 69b9         	ldr	r1, [r7, #0x18]
; }
 8005aaa: 460b         	mov	r3, r1
 8005aac: 4618         	mov	r0, r3
 8005aae: 3720         	adds	r7, #0x20
 8005ab0: 46bd         	mov	sp, r7
 8005ab2: bd80         	pop	{r7, pc}

08005ab4 <$d>:
 8005ab4: 08 03 00 20  	.word	0x20000308
 8005ab8: 20 a4 01 08  	.word	0x0801a420
 8005abc: 80 0b 00 20  	.word	0x20000b80

08005ac0 <can_stm32_remove_rx_filter>:
; {
 8005ac0: b580         	push	{r7, lr}
 8005ac2: b096         	sub	sp, #0x58
 8005ac4: af06         	add	r7, sp, #0x18
 8005ac6: 6078         	str	r0, [r7, #0x4]
 8005ac8: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8005aca: 687b         	ldr	r3, [r7, #0x4]
 8005acc: 685b         	ldr	r3, [r3, #0x4]
 8005ace: 62fb         	str	r3, [r7, #0x2c]
; 	struct can_stm32_data *data = dev->data;
 8005ad0: 687b         	ldr	r3, [r7, #0x4]
 8005ad2: 691b         	ldr	r3, [r3, #0x10]
 8005ad4: 62bb         	str	r3, [r7, #0x28]
; 	CAN_TypeDef *can = cfg->master_can;
 8005ad6: 6afb         	ldr	r3, [r7, #0x2c]
 8005ad8: 699b         	ldr	r3, [r3, #0x18]
 8005ada: 627b         	str	r3, [r7, #0x24]
; 	int bank_offset = 0;
 8005adc: 2300         	movs	r3, #0x0
 8005ade: 633b         	str	r3, [r7, #0x30]
; 	if (filter_id < 0 || filter_id >= CAN_STM32_MAX_FILTER_ID) {
 8005ae0: 683b         	ldr	r3, [r7]
 8005ae2: 2b00         	cmp	r3, #0x0
 8005ae4: db02         	blt	0x8005aec <can_stm32_remove_rx_filter+0x2c> @ imm = #0x4
 8005ae6: 683b         	ldr	r3, [r7]
 8005ae8: 2b22         	cmp	r3, #0x22
 8005aea: dd1e         	ble	0x8005b2a <can_stm32_remove_rx_filter+0x6a> @ imm = #0x3c
; 		LOG_ERR("filter ID %d out of bounds", filter_id);
 8005aec: 2303         	movs	r3, #0x3
 8005aee: 2b00         	cmp	r3, #0x0
 8005af0: f000 810a    	beq.w	0x8005d08 <can_stm32_remove_rx_filter+0x248> @ imm = #0x214
 8005af4: 2301         	movs	r3, #0x1
 8005af6: 73fb         	strb	r3, [r7, #0xf]
 8005af8: 7bfb         	ldrb	r3, [r7, #0xf]
 8005afa: f083 0301    	eor	r3, r3, #0x1
 8005afe: b2db         	uxtb	r3, r3
 8005b00: 2b00         	cmp	r3, #0x0
 8005b02: f040 8101    	bne.w	0x8005d08 <can_stm32_remove_rx_filter+0x248> @ imm = #0x202
 8005b06: 4b82         	ldr	r3, [pc, #0x208]        @ 0x8005d10 <can_stm32_remove_rx_filter+0x250>
 8005b08: 6819         	ldr	r1, [r3]
 8005b0a: 683b         	ldr	r3, [r7]
 8005b0c: 9303         	str	r3, [sp, #0xc]
 8005b0e: 4b81         	ldr	r3, [pc, #0x204]        @ 0x8005d14 <can_stm32_remove_rx_filter+0x254>
 8005b10: 9302         	str	r3, [sp, #0x8]
 8005b12: 2300         	movs	r3, #0x0
 8005b14: 9301         	str	r3, [sp, #0x4]
 8005b16: 2300         	movs	r3, #0x0
 8005b18: 9300         	str	r3, [sp]
 8005b1a: 2300         	movs	r3, #0x0
 8005b1c: 2201         	movs	r2, #0x1
 8005b1e: 2000         	movs	r0, #0x0
 8005b20: f00c fb6e    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xc6dc
 8005b24: 2300         	movs	r3, #0x0
 8005b26: 60bb         	str	r3, [r7, #0x8]
 8005b28: e0ee         	b	0x8005d08 <can_stm32_remove_rx_filter+0x248> @ imm = #0x1dc
; 	k_mutex_lock(&filter_mutex, K_FOREVER);
 8005b2a: f04f 32ff    	mov.w	r2, #0xffffffff
 8005b2e: f04f 33ff    	mov.w	r3, #0xffffffff
 8005b32: 4879         	ldr	r0, [pc, #0x1e4]        @ 0x8005d18 <can_stm32_remove_rx_filter+0x258>
 8005b34: f00c fa7d    	bl	0x8012032 <k_mutex_lock> @ imm = #0xc4fa
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8005b38: 6abb         	ldr	r3, [r7, #0x28]
 8005b3a: f103 0110    	add.w	r1, r3, #0x10
 8005b3e: f04f 32ff    	mov.w	r2, #0xffffffff
 8005b42: f04f 33ff    	mov.w	r3, #0xffffffff
 8005b46: 4608         	mov	r0, r1
 8005b48: f00c fa73    	bl	0x8012032 <k_mutex_lock> @ imm = #0xc4e6
; 	if (cfg->can != cfg->master_can) {
 8005b4c: 6afb         	ldr	r3, [r7, #0x2c]
 8005b4e: 695a         	ldr	r2, [r3, #0x14]
 8005b50: 6afb         	ldr	r3, [r7, #0x2c]
 8005b52: 699b         	ldr	r3, [r3, #0x18]
 8005b54: 429a         	cmp	r2, r3
 8005b56: d001         	beq	0x8005b5c <can_stm32_remove_rx_filter+0x9c> @ imm = #0x2
; 		bank_offset = CAN_STM32_NUM_FILTER_BANKS;
 8005b58: 230e         	movs	r3, #0xe
 8005b5a: 633b         	str	r3, [r7, #0x30]
; 	if (filter_id < CONFIG_CAN_MAX_EXT_ID_FILTER) {
 8005b5c: 683b         	ldr	r3, [r7]
 8005b5e: 2b06         	cmp	r3, #0x6
 8005b60: dc17         	bgt	0x8005b92 <can_stm32_remove_rx_filter+0xd2> @ imm = #0x2e
; 		ide = true;
 8005b62: 2301         	movs	r3, #0x1
 8005b64: f887 3037    	strb.w	r3, [r7, #0x37]
; 		bank_num = bank_offset + filter_id;
 8005b68: 6b3a         	ldr	r2, [r7, #0x30]
 8005b6a: 683b         	ldr	r3, [r7]
 8005b6c: 4413         	add	r3, r2
 8005b6e: 63bb         	str	r3, [r7, #0x38]
; 		data->rx_cb_ext[filter_id] = NULL;
 8005b70: 6aba         	ldr	r2, [r7, #0x28]
 8005b72: 683b         	ldr	r3, [r7]
 8005b74: 3320         	adds	r3, #0x20
 8005b76: 009b         	lsls	r3, r3, #0x2
 8005b78: 4413         	add	r3, r2
 8005b7a: 2200         	movs	r2, #0x0
 8005b7c: 605a         	str	r2, [r3, #0x4]
; 		data->cb_arg_ext[filter_id] = NULL;
 8005b7e: 6abb         	ldr	r3, [r7, #0x28]
 8005b80: 683a         	ldr	r2, [r7]
 8005b82: 3236         	adds	r2, #0x36
 8005b84: 2100         	movs	r1, #0x0
 8005b86: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 		bank_unused = true;
 8005b8a: 2301         	movs	r3, #0x1
 8005b8c: f887 303f    	strb.w	r3, [r7, #0x3f]
 8005b90: e045         	b	0x8005c1e <can_stm32_remove_rx_filter+0x15e> @ imm = #0x8a
; 		int filter_index = filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER;
 8005b92: 683b         	ldr	r3, [r7]
 8005b94: 3b07         	subs	r3, #0x7
 8005b96: 623b         	str	r3, [r7, #0x20]
; 		ide = false;
 8005b98: 2300         	movs	r3, #0x0
 8005b9a: f887 3037    	strb.w	r3, [r7, #0x37]
; 		bank_num = bank_offset + CONFIG_CAN_MAX_EXT_ID_FILTER +
 8005b9e: 6b3b         	ldr	r3, [r7, #0x30]
 8005ba0: 1dda         	adds	r2, r3, #0x7
; 			  (filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER) / 2;
 8005ba2: 683b         	ldr	r3, [r7]
 8005ba4: 3b07         	subs	r3, #0x7
 8005ba6: 0fd9         	lsrs	r1, r3, #0x1f
 8005ba8: 440b         	add	r3, r1
 8005baa: 105b         	asrs	r3, r3, #0x1
; 		bank_num = bank_offset + CONFIG_CAN_MAX_EXT_ID_FILTER +
 8005bac: 4413         	add	r3, r2
 8005bae: 63bb         	str	r3, [r7, #0x38]
; 		data->rx_cb_std[filter_index] = NULL;
 8005bb0: 6aba         	ldr	r2, [r7, #0x28]
 8005bb2: 6a3b         	ldr	r3, [r7, #0x20]
 8005bb4: 3312         	adds	r3, #0x12
 8005bb6: 009b         	lsls	r3, r3, #0x2
 8005bb8: 4413         	add	r3, r2
 8005bba: 2200         	movs	r2, #0x0
 8005bbc: 605a         	str	r2, [r3, #0x4]
; 		data->cb_arg_std[filter_index] = NULL;
 8005bbe: 6abb         	ldr	r3, [r7, #0x28]
 8005bc0: 6a3a         	ldr	r2, [r7, #0x20]
 8005bc2: 3228         	adds	r2, #0x28
 8005bc4: 2100         	movs	r1, #0x0
 8005bc6: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 		if (filter_index % 2 == 1) {
 8005bca: 6a3b         	ldr	r3, [r7, #0x20]
 8005bcc: 2b00         	cmp	r3, #0x0
 8005bce: f003 0301    	and	r3, r3, #0x1
 8005bd2: bfb8         	it	lt
 8005bd4: 425b         	rsblt	r3, r3, #0
 8005bd6: 2b01         	cmp	r3, #0x1
 8005bd8: d10d         	bne	0x8005bf6 <can_stm32_remove_rx_filter+0x136> @ imm = #0x1a
; 			bank_unused = data->rx_cb_std[filter_index - 1] == NULL;
 8005bda: 6a3b         	ldr	r3, [r7, #0x20]
 8005bdc: 3b01         	subs	r3, #0x1
 8005bde: 6aba         	ldr	r2, [r7, #0x28]
 8005be0: 3312         	adds	r3, #0x12
 8005be2: 009b         	lsls	r3, r3, #0x2
 8005be4: 4413         	add	r3, r2
 8005be6: 685b         	ldr	r3, [r3, #0x4]
 8005be8: 2b00         	cmp	r3, #0x0
 8005bea: bf0c         	ite	eq
 8005bec: 2301         	moveq	r3, #0x1
 8005bee: 2300         	movne	r3, #0x0
 8005bf0: f887 303f    	strb.w	r3, [r7, #0x3f]
 8005bf4: e013         	b	0x8005c1e <can_stm32_remove_rx_filter+0x15e> @ imm = #0x26
; 		} else if (filter_index + 1 < CONFIG_CAN_MAX_STD_ID_FILTER) {
 8005bf6: 6a3b         	ldr	r3, [r7, #0x20]
 8005bf8: 2b0c         	cmp	r3, #0xc
 8005bfa: dc0d         	bgt	0x8005c18 <can_stm32_remove_rx_filter+0x158> @ imm = #0x1a
; 			bank_unused = data->rx_cb_std[filter_index + 1] == NULL;
 8005bfc: 6a3b         	ldr	r3, [r7, #0x20]
 8005bfe: 3301         	adds	r3, #0x1
 8005c00: 6aba         	ldr	r2, [r7, #0x28]
 8005c02: 3312         	adds	r3, #0x12
 8005c04: 009b         	lsls	r3, r3, #0x2
 8005c06: 4413         	add	r3, r2
 8005c08: 685b         	ldr	r3, [r3, #0x4]
 8005c0a: 2b00         	cmp	r3, #0x0
 8005c0c: bf0c         	ite	eq
 8005c0e: 2301         	moveq	r3, #0x1
 8005c10: 2300         	movne	r3, #0x0
 8005c12: f887 303f    	strb.w	r3, [r7, #0x3f]
 8005c16: e002         	b	0x8005c1e <can_stm32_remove_rx_filter+0x15e> @ imm = #0x4
; 			bank_unused = true;
 8005c18: 2301         	movs	r3, #0x1
 8005c1a: f887 303f    	strb.w	r3, [r7, #0x3f]
; 	LOG_DBG("Removing filter_id %d, ide %d", filter_id, ide);
 8005c1e: 2303         	movs	r3, #0x3
 8005c20: 2b03         	cmp	r3, #0x3
 8005c22: d91d         	bls	0x8005c60 <can_stm32_remove_rx_filter+0x1a0> @ imm = #0x3a
 8005c24: 2301         	movs	r3, #0x1
 8005c26: 77fb         	strb	r3, [r7, #0x1f]
 8005c28: 7ffb         	ldrb	r3, [r7, #0x1f]
 8005c2a: f083 0301    	eor	r3, r3, #0x1
 8005c2e: b2db         	uxtb	r3, r3
 8005c30: 2b00         	cmp	r3, #0x0
 8005c32: d115         	bne	0x8005c60 <can_stm32_remove_rx_filter+0x1a0> @ imm = #0x2a
 8005c34: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8005d10 <can_stm32_remove_rx_filter+0x250>
 8005c36: 6819         	ldr	r1, [r3]
 8005c38: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8005c3c: 9305         	str	r3, [sp, #0x14]
 8005c3e: 683b         	ldr	r3, [r7]
 8005c40: 9304         	str	r3, [sp, #0x10]
 8005c42: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8005d1c <can_stm32_remove_rx_filter+0x25c>
 8005c44: 9303         	str	r3, [sp, #0xc]
 8005c46: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8005d20 <can_stm32_remove_rx_filter+0x260>
 8005c48: 9302         	str	r3, [sp, #0x8]
 8005c4a: 2308         	movs	r3, #0x8
 8005c4c: 9301         	str	r3, [sp, #0x4]
 8005c4e: 2300         	movs	r3, #0x0
 8005c50: 9300         	str	r3, [sp]
 8005c52: 2300         	movs	r3, #0x0
 8005c54: 2204         	movs	r2, #0x4
 8005c56: 2000         	movs	r0, #0x0
 8005c58: f00c fad2    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xc5a4
 8005c5c: 2300         	movs	r3, #0x0
 8005c5e: 61bb         	str	r3, [r7, #0x18]
; 	can->FMR |= CAN_FMR_FINIT;
 8005c60: 6a7b         	ldr	r3, [r7, #0x24]
 8005c62: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 8005c66: f043 0201    	orr	r2, r3, #0x1
 8005c6a: 6a7b         	ldr	r3, [r7, #0x24]
 8005c6c: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	can_stm32_set_filter_bank(filter_id, &can->sFilterRegister[bank_num],
 8005c70: 6bbb         	ldr	r3, [r7, #0x38]
 8005c72: 3348         	adds	r3, #0x48
 8005c74: 00db         	lsls	r3, r3, #0x3
 8005c76: 6a7a         	ldr	r2, [r7, #0x24]
 8005c78: 18d1         	adds	r1, r2, r3
 8005c7a: f897 2037    	ldrb.w	r2, [r7, #0x37]
 8005c7e: f04f 33ff    	mov.w	r3, #0xffffffff
 8005c82: 9300         	str	r3, [sp]
 8005c84: 2300         	movs	r3, #0x0
 8005c86: 6838         	ldr	r0, [r7]
 8005c88: f00c fcfc    	bl	0x8012684 <can_stm32_set_filter_bank> @ imm = #0xc9f8
; 	if (bank_unused) {
 8005c8c: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8005c90: 2b00         	cmp	r3, #0x0
 8005c92: d029         	beq	0x8005ce8 <can_stm32_remove_rx_filter+0x228> @ imm = #0x52
; 		can->FA1R &= ~(1U << bank_num);
 8005c94: 6a7b         	ldr	r3, [r7, #0x24]
 8005c96: f8d3 221c    	ldr.w	r2, [r3, #0x21c]
 8005c9a: 2101         	movs	r1, #0x1
 8005c9c: 6bbb         	ldr	r3, [r7, #0x38]
 8005c9e: fa01 f303    	lsl.w	r3, r1, r3
 8005ca2: 43db         	mvns	r3, r3
 8005ca4: 401a         	ands	r2, r3
 8005ca6: 6a7b         	ldr	r3, [r7, #0x24]
 8005ca8: f8c3 221c    	str.w	r2, [r3, #0x21c]
; 		LOG_DBG("Filter bank %d is unused -> deactivate", bank_num);
 8005cac: 2303         	movs	r3, #0x3
 8005cae: 2b03         	cmp	r3, #0x3
 8005cb0: d91a         	bls	0x8005ce8 <can_stm32_remove_rx_filter+0x228> @ imm = #0x34
 8005cb2: 2301         	movs	r3, #0x1
 8005cb4: 75fb         	strb	r3, [r7, #0x17]
 8005cb6: 7dfb         	ldrb	r3, [r7, #0x17]
 8005cb8: f083 0301    	eor	r3, r3, #0x1
 8005cbc: b2db         	uxtb	r3, r3
 8005cbe: 2b00         	cmp	r3, #0x0
 8005cc0: d112         	bne	0x8005ce8 <can_stm32_remove_rx_filter+0x228> @ imm = #0x24
 8005cc2: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8005d10 <can_stm32_remove_rx_filter+0x250>
 8005cc4: 6819         	ldr	r1, [r3]
 8005cc6: 6bbb         	ldr	r3, [r7, #0x38]
 8005cc8: 9304         	str	r3, [sp, #0x10]
 8005cca: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8005d1c <can_stm32_remove_rx_filter+0x25c>
 8005ccc: 9303         	str	r3, [sp, #0xc]
 8005cce: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8005d24 <can_stm32_remove_rx_filter+0x264>
 8005cd0: 9302         	str	r3, [sp, #0x8]
 8005cd2: 2308         	movs	r3, #0x8
 8005cd4: 9301         	str	r3, [sp, #0x4]
 8005cd6: 2300         	movs	r3, #0x0
 8005cd8: 9300         	str	r3, [sp]
 8005cda: 2300         	movs	r3, #0x0
 8005cdc: 2204         	movs	r2, #0x4
 8005cde: 2000         	movs	r0, #0x0
 8005ce0: f00c fa8e    	bl	0x8012200 <z_log_msg_runtime_create> @ imm = #0xc51c
 8005ce4: 2300         	movs	r3, #0x0
 8005ce6: 613b         	str	r3, [r7, #0x10]
; 	can->FMR &= ~(CAN_FMR_FINIT);
 8005ce8: 6a7b         	ldr	r3, [r7, #0x24]
 8005cea: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 8005cee: f023 0201    	bic	r2, r3, #0x1
 8005cf2: 6a7b         	ldr	r3, [r7, #0x24]
 8005cf4: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	k_mutex_unlock(&data->inst_mutex);
 8005cf8: 6abb         	ldr	r3, [r7, #0x28]
 8005cfa: 3310         	adds	r3, #0x10
 8005cfc: 4618         	mov	r0, r3
 8005cfe: f00c f9a8    	bl	0x8012052 <k_mutex_unlock> @ imm = #0xc350
; 	k_mutex_unlock(&filter_mutex);
 8005d02: 4805         	ldr	r0, [pc, #0x14]         @ 0x8005d18 <can_stm32_remove_rx_filter+0x258>
 8005d04: f00c f9a5    	bl	0x8012052 <k_mutex_unlock> @ imm = #0xc34a
; }
 8005d08: 3740         	adds	r7, #0x40
 8005d0a: 46bd         	mov	sp, r7
 8005d0c: bd80         	pop	{r7, pc}
 8005d0e: bf00         	nop

08005d10 <$d>:
 8005d10: 08 03 00 20  	.word	0x20000308
 8005d14: 44 a4 01 08  	.word	0x0801a444
 8005d18: 80 0b 00 20  	.word	0x20000b80
 8005d1c: f0 b5 01 08  	.word	0x0801b5f0
 8005d20: 60 a4 01 08  	.word	0x0801a460
 8005d24: 84 a4 01 08  	.word	0x0801a484

08005d28 <LL_RCC_HSE_DisableBypass>:
; {
 8005d28: b480         	push	{r7}
 8005d2a: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 8005d2c: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005d40 <LL_RCC_HSE_DisableBypass+0x18>
 8005d2e: 681b         	ldr	r3, [r3]
 8005d30: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005d40 <LL_RCC_HSE_DisableBypass+0x18>
 8005d32: f423 2380    	bic	r3, r3, #0x40000
 8005d36: 6013         	str	r3, [r2]
; }
 8005d38: bf00         	nop
 8005d3a: 46bd         	mov	sp, r7
 8005d3c: bc80         	pop	{r7}
 8005d3e: 4770         	bx	lr

08005d40 <$d>:
 8005d40: 00 38 02 40  	.word	0x40023800

08005d44 <LL_RCC_HSE_Enable>:
; {
 8005d44: b480         	push	{r7}
 8005d46: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSEON);
 8005d48: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005d5c <LL_RCC_HSE_Enable+0x18>
 8005d4a: 681b         	ldr	r3, [r3]
 8005d4c: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005d5c <LL_RCC_HSE_Enable+0x18>
 8005d4e: f443 3380    	orr	r3, r3, #0x10000
 8005d52: 6013         	str	r3, [r2]
; }
 8005d54: bf00         	nop
 8005d56: 46bd         	mov	sp, r7
 8005d58: bc80         	pop	{r7}
 8005d5a: 4770         	bx	lr

08005d5c <$d>:
 8005d5c: 00 38 02 40  	.word	0x40023800

08005d60 <LL_RCC_HSE_IsReady>:
; {
 8005d60: b480         	push	{r7}
 8005d62: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
 8005d64: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005d80 <LL_RCC_HSE_IsReady+0x20>
 8005d66: 681b         	ldr	r3, [r3]
 8005d68: f403 3300    	and	r3, r3, #0x20000
 8005d6c: f5b3 3f00    	cmp.w	r3, #0x20000
 8005d70: bf0c         	ite	eq
 8005d72: 2301         	moveq	r3, #0x1
 8005d74: 2300         	movne	r3, #0x0
 8005d76: b2db         	uxtb	r3, r3
; }
 8005d78: 4618         	mov	r0, r3
 8005d7a: 46bd         	mov	sp, r7
 8005d7c: bc80         	pop	{r7}
 8005d7e: 4770         	bx	lr

08005d80 <$d>:
 8005d80: 00 38 02 40  	.word	0x40023800

08005d84 <LL_RCC_HSI_Enable>:
; {
 8005d84: b480         	push	{r7}
 8005d86: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSION);
 8005d88: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005d9c <LL_RCC_HSI_Enable+0x18>
 8005d8a: 681b         	ldr	r3, [r3]
 8005d8c: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005d9c <LL_RCC_HSI_Enable+0x18>
 8005d8e: f043 0301    	orr	r3, r3, #0x1
 8005d92: 6013         	str	r3, [r2]
; }
 8005d94: bf00         	nop
 8005d96: 46bd         	mov	sp, r7
 8005d98: bc80         	pop	{r7}
 8005d9a: 4770         	bx	lr

08005d9c <$d>:
 8005d9c: 00 38 02 40  	.word	0x40023800

08005da0 <LL_RCC_HSI_IsReady>:
; {
 8005da0: b480         	push	{r7}
 8005da2: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
 8005da4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005dc0 <LL_RCC_HSI_IsReady+0x20>
 8005da6: 681b         	ldr	r3, [r3]
 8005da8: f003 0302    	and	r3, r3, #0x2
 8005dac: 2b02         	cmp	r3, #0x2
 8005dae: bf0c         	ite	eq
 8005db0: 2301         	moveq	r3, #0x1
 8005db2: 2300         	movne	r3, #0x0
 8005db4: b2db         	uxtb	r3, r3
; }
 8005db6: 4618         	mov	r0, r3
 8005db8: 46bd         	mov	sp, r7
 8005dba: bc80         	pop	{r7}
 8005dbc: 4770         	bx	lr
 8005dbe: bf00         	nop

08005dc0 <$d>:
 8005dc0: 00 38 02 40  	.word	0x40023800

08005dc4 <LL_RCC_LSI_Enable>:
; {
 8005dc4: b480         	push	{r7}
 8005dc6: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CSR, RCC_CSR_LSION);
 8005dc8: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005ddc <LL_RCC_LSI_Enable+0x18>
 8005dca: 6f5b         	ldr	r3, [r3, #0x74]
 8005dcc: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005ddc <LL_RCC_LSI_Enable+0x18>
 8005dce: f043 0301    	orr	r3, r3, #0x1
 8005dd2: 6753         	str	r3, [r2, #0x74]
; }
 8005dd4: bf00         	nop
 8005dd6: 46bd         	mov	sp, r7
 8005dd8: bc80         	pop	{r7}
 8005dda: 4770         	bx	lr

08005ddc <$d>:
 8005ddc: 00 38 02 40  	.word	0x40023800

08005de0 <LL_RCC_LSI_IsReady>:
; {
 8005de0: b480         	push	{r7}
 8005de2: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY));
 8005de4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005e00 <LL_RCC_LSI_IsReady+0x20>
 8005de6: 6f5b         	ldr	r3, [r3, #0x74]
 8005de8: f003 0302    	and	r3, r3, #0x2
 8005dec: 2b02         	cmp	r3, #0x2
 8005dee: bf0c         	ite	eq
 8005df0: 2301         	moveq	r3, #0x1
 8005df2: 2300         	movne	r3, #0x0
 8005df4: b2db         	uxtb	r3, r3
; }
 8005df6: 4618         	mov	r0, r3
 8005df8: 46bd         	mov	sp, r7
 8005dfa: bc80         	pop	{r7}
 8005dfc: 4770         	bx	lr
 8005dfe: bf00         	nop

08005e00 <$d>:
 8005e00: 00 38 02 40  	.word	0x40023800

08005e04 <LL_RCC_SetSysClkSource>:
; {
 8005e04: b480         	push	{r7}
 8005e06: b083         	sub	sp, #0xc
 8005e08: af00         	add	r7, sp, #0x0
 8005e0a: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8005e0c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005e28 <LL_RCC_SetSysClkSource+0x24>
 8005e0e: 689b         	ldr	r3, [r3, #0x8]
 8005e10: f023 0203    	bic	r2, r3, #0x3
 8005e14: 4904         	ldr	r1, [pc, #0x10]         @ 0x8005e28 <LL_RCC_SetSysClkSource+0x24>
 8005e16: 687b         	ldr	r3, [r7, #0x4]
 8005e18: 4313         	orrs	r3, r2
 8005e1a: 608b         	str	r3, [r1, #0x8]
; }
 8005e1c: bf00         	nop
 8005e1e: 370c         	adds	r7, #0xc
 8005e20: 46bd         	mov	sp, r7
 8005e22: bc80         	pop	{r7}
 8005e24: 4770         	bx	lr
 8005e26: bf00         	nop

08005e28 <$d>:
 8005e28: 00 38 02 40  	.word	0x40023800

08005e2c <LL_RCC_GetSysClkSource>:
; {
 8005e2c: b480         	push	{r7}
 8005e2e: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8005e30: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8005e40 <LL_RCC_GetSysClkSource+0x14>
 8005e32: 689b         	ldr	r3, [r3, #0x8]
 8005e34: f003 030c    	and	r3, r3, #0xc
; }
 8005e38: 4618         	mov	r0, r3
 8005e3a: 46bd         	mov	sp, r7
 8005e3c: bc80         	pop	{r7}
 8005e3e: 4770         	bx	lr

08005e40 <$d>:
 8005e40: 00 38 02 40  	.word	0x40023800

08005e44 <LL_RCC_SetAHBPrescaler>:
; {
 8005e44: b480         	push	{r7}
 8005e46: b083         	sub	sp, #0xc
 8005e48: af00         	add	r7, sp, #0x0
 8005e4a: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8005e4c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005e68 <LL_RCC_SetAHBPrescaler+0x24>
 8005e4e: 689b         	ldr	r3, [r3, #0x8]
 8005e50: f023 02f0    	bic	r2, r3, #0xf0
 8005e54: 4904         	ldr	r1, [pc, #0x10]         @ 0x8005e68 <LL_RCC_SetAHBPrescaler+0x24>
 8005e56: 687b         	ldr	r3, [r7, #0x4]
 8005e58: 4313         	orrs	r3, r2
 8005e5a: 608b         	str	r3, [r1, #0x8]
; }
 8005e5c: bf00         	nop
 8005e5e: 370c         	adds	r7, #0xc
 8005e60: 46bd         	mov	sp, r7
 8005e62: bc80         	pop	{r7}
 8005e64: 4770         	bx	lr
 8005e66: bf00         	nop

08005e68 <$d>:
 8005e68: 00 38 02 40  	.word	0x40023800

08005e6c <LL_RCC_SetAPB1Prescaler>:
; {
 8005e6c: b480         	push	{r7}
 8005e6e: b083         	sub	sp, #0xc
 8005e70: af00         	add	r7, sp, #0x0
 8005e72: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 8005e74: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005e90 <LL_RCC_SetAPB1Prescaler+0x24>
 8005e76: 689b         	ldr	r3, [r3, #0x8]
 8005e78: f423 52e0    	bic	r2, r3, #0x1c00
 8005e7c: 4904         	ldr	r1, [pc, #0x10]         @ 0x8005e90 <LL_RCC_SetAPB1Prescaler+0x24>
 8005e7e: 687b         	ldr	r3, [r7, #0x4]
 8005e80: 4313         	orrs	r3, r2
 8005e82: 608b         	str	r3, [r1, #0x8]
; }
 8005e84: bf00         	nop
 8005e86: 370c         	adds	r7, #0xc
 8005e88: 46bd         	mov	sp, r7
 8005e8a: bc80         	pop	{r7}
 8005e8c: 4770         	bx	lr
 8005e8e: bf00         	nop

08005e90 <$d>:
 8005e90: 00 38 02 40  	.word	0x40023800

08005e94 <LL_RCC_SetAPB2Prescaler>:
; {
 8005e94: b480         	push	{r7}
 8005e96: b083         	sub	sp, #0xc
 8005e98: af00         	add	r7, sp, #0x0
 8005e9a: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 8005e9c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005eb8 <LL_RCC_SetAPB2Prescaler+0x24>
 8005e9e: 689b         	ldr	r3, [r3, #0x8]
 8005ea0: f423 4260    	bic	r2, r3, #0xe000
 8005ea4: 4904         	ldr	r1, [pc, #0x10]         @ 0x8005eb8 <LL_RCC_SetAPB2Prescaler+0x24>
 8005ea6: 687b         	ldr	r3, [r7, #0x4]
 8005ea8: 4313         	orrs	r3, r2
 8005eaa: 608b         	str	r3, [r1, #0x8]
; }
 8005eac: bf00         	nop
 8005eae: 370c         	adds	r7, #0xc
 8005eb0: 46bd         	mov	sp, r7
 8005eb2: bc80         	pop	{r7}
 8005eb4: 4770         	bx	lr
 8005eb6: bf00         	nop

08005eb8 <$d>:
 8005eb8: 00 38 02 40  	.word	0x40023800

08005ebc <LL_RCC_GetAHBPrescaler>:
; {
 8005ebc: b480         	push	{r7}
 8005ebe: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8005ec0: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8005ed0 <LL_RCC_GetAHBPrescaler+0x14>
 8005ec2: 689b         	ldr	r3, [r3, #0x8]
 8005ec4: f003 03f0    	and	r3, r3, #0xf0
; }
 8005ec8: 4618         	mov	r0, r3
 8005eca: 46bd         	mov	sp, r7
 8005ecc: bc80         	pop	{r7}
 8005ece: 4770         	bx	lr

08005ed0 <$d>:
 8005ed0: 00 38 02 40  	.word	0x40023800

08005ed4 <LL_RCC_PLL_Enable>:
; {
 8005ed4: b480         	push	{r7}
 8005ed6: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_PLLON);
 8005ed8: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005eec <LL_RCC_PLL_Enable+0x18>
 8005eda: 681b         	ldr	r3, [r3]
 8005edc: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005eec <LL_RCC_PLL_Enable+0x18>
 8005ede: f043 7380    	orr	r3, r3, #0x1000000
 8005ee2: 6013         	str	r3, [r2]
; }
 8005ee4: bf00         	nop
 8005ee6: 46bd         	mov	sp, r7
 8005ee8: bc80         	pop	{r7}
 8005eea: 4770         	bx	lr

08005eec <$d>:
 8005eec: 00 38 02 40  	.word	0x40023800

08005ef0 <LL_RCC_PLL_Disable>:
; {
 8005ef0: b480         	push	{r7}
 8005ef2: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8005ef4: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005f08 <LL_RCC_PLL_Disable+0x18>
 8005ef6: 681b         	ldr	r3, [r3]
 8005ef8: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005f08 <LL_RCC_PLL_Disable+0x18>
 8005efa: f023 7380    	bic	r3, r3, #0x1000000
 8005efe: 6013         	str	r3, [r2]
; }
 8005f00: bf00         	nop
 8005f02: 46bd         	mov	sp, r7
 8005f04: bc80         	pop	{r7}
 8005f06: 4770         	bx	lr

08005f08 <$d>:
 8005f08: 00 38 02 40  	.word	0x40023800

08005f0c <LL_RCC_PLL_IsReady>:
; {
 8005f0c: b480         	push	{r7}
 8005f0e: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 8005f10: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005f2c <LL_RCC_PLL_IsReady+0x20>
 8005f12: 681b         	ldr	r3, [r3]
 8005f14: f003 7300    	and	r3, r3, #0x2000000
 8005f18: f1b3 7f00    	cmp.w	r3, #0x2000000
 8005f1c: bf0c         	ite	eq
 8005f1e: 2301         	moveq	r3, #0x1
 8005f20: 2300         	movne	r3, #0x0
 8005f22: b2db         	uxtb	r3, r3
; }
 8005f24: 4618         	mov	r0, r3
 8005f26: 46bd         	mov	sp, r7
 8005f28: bc80         	pop	{r7}
 8005f2a: 4770         	bx	lr

08005f2c <$d>:
 8005f2c: 00 38 02 40  	.word	0x40023800

08005f30 <enabled_clock>:
; {
 8005f30: b480         	push	{r7}
 8005f32: b085         	sub	sp, #0x14
 8005f34: af00         	add	r7, sp, #0x0
 8005f36: 6078         	str	r0, [r7, #0x4]
; 	int r = 0;
 8005f38: 2300         	movs	r3, #0x0
 8005f3a: 60fb         	str	r3, [r7, #0xc]
; 	switch (src_clk) {
 8005f3c: 687b         	ldr	r3, [r7, #0x4]
 8005f3e: 3b01         	subs	r3, #0x1
 8005f40: 2b06         	cmp	r3, #0x6
 8005f42: d81d         	bhi	0x8005f80 <enabled_clock+0x50> @ imm = #0x3a
 8005f44: a201         	adr	r2, #4 <enabled_clock+0x19>
 8005f46: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8005f4a: bf00         	nop

08005f4c <$d>:
 8005f4c: 87 5f 00 08  	.word	0x08005f87
 8005f50: 69 5f 00 08  	.word	0x08005f69
 8005f54: 87 5f 00 08  	.word	0x08005f87
 8005f58: 87 5f 00 08  	.word	0x08005f87
 8005f5c: 87 5f 00 08  	.word	0x08005f87
 8005f60: 71 5f 00 08  	.word	0x08005f71
 8005f64: 79 5f 00 08  	.word	0x08005f79

08005f68 <$t>:
; 			r = -ENOTSUP;
 8005f68: f06f 0385    	mvn	r3, #0x85
 8005f6c: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8005f6e: e00b         	b	0x8005f88 <enabled_clock+0x58> @ imm = #0x16
; 			r = -ENOTSUP;
 8005f70: f06f 0385    	mvn	r3, #0x85
 8005f74: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8005f76: e007         	b	0x8005f88 <enabled_clock+0x58> @ imm = #0xe
; 			r = -ENOTSUP;
 8005f78: f06f 0385    	mvn	r3, #0x85
 8005f7c: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8005f7e: e003         	b	0x8005f88 <enabled_clock+0x58> @ imm = #0x6
; 		return -ENOTSUP;
 8005f80: f06f 0385    	mvn	r3, #0x85
 8005f84: e001         	b	0x8005f8a <enabled_clock+0x5a> @ imm = #0x2
; 		break;
 8005f86: bf00         	nop
; 	return r;
 8005f88: 68fb         	ldr	r3, [r7, #0xc]
; }
 8005f8a: 4618         	mov	r0, r3
 8005f8c: 3714         	adds	r7, #0x14
 8005f8e: 46bd         	mov	sp, r7
 8005f90: bc80         	pop	{r7}
 8005f92: 4770         	bx	lr

08005f94 <stm32_clock_control_get_subsys_rate>:
; {
 8005f94: b580         	push	{r7, lr}
 8005f96: b08a         	sub	sp, #0x28
 8005f98: af00         	add	r7, sp, #0x0
 8005f9a: 60f8         	str	r0, [r7, #0xc]
 8005f9c: 60b9         	str	r1, [r7, #0x8]
 8005f9e: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 8005fa0: 68bb         	ldr	r3, [r7, #0x8]
 8005fa2: 627b         	str	r3, [r7, #0x24]
; 	uint32_t ahb_clock = SystemCoreClock;
 8005fa4: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8006178 <stm32_clock_control_get_subsys_rate+0x1e4>
 8005fa6: 681b         	ldr	r3, [r3]
 8005fa8: 623b         	str	r3, [r7, #0x20]
; 	uint32_t apb1_clock = get_bus_clock(ahb_clock, STM32_APB1_PRESCALER);
 8005faa: 2104         	movs	r1, #0x4
 8005fac: 6a38         	ldr	r0, [r7, #0x20]
 8005fae: f00c fc3d    	bl	0x801282c <get_bus_clock> @ imm = #0xc87a
 8005fb2: 61f8         	str	r0, [r7, #0x1c]
; 	uint32_t apb2_clock = get_bus_clock(ahb_clock, STM32_APB2_PRESCALER);
 8005fb4: 2102         	movs	r1, #0x2
 8005fb6: 6a38         	ldr	r0, [r7, #0x20]
 8005fb8: f00c fc38    	bl	0x801282c <get_bus_clock> @ imm = #0xc870
 8005fbc: 61b8         	str	r0, [r7, #0x18]
; 	uint32_t ahb3_clock = ahb_clock;
 8005fbe: 6a3b         	ldr	r3, [r7, #0x20]
 8005fc0: 617b         	str	r3, [r7, #0x14]
; 	switch (pclken->bus) {
 8005fc2: 6a7b         	ldr	r3, [r7, #0x24]
 8005fc4: 681b         	ldr	r3, [r3]
 8005fc6: 2b44         	cmp	r3, #0x44
 8005fc8: f200 8092    	bhi.w	0x80060f0 <stm32_clock_control_get_subsys_rate+0x15c> @ imm = #0x124
 8005fcc: 2b00         	cmp	r3, #0x0
 8005fce: f000 80ca    	beq.w	0x8006166 <stm32_clock_control_get_subsys_rate+0x1d2> @ imm = #0x194
 8005fd2: 3b01         	subs	r3, #0x1
 8005fd4: 2b43         	cmp	r3, #0x43
 8005fd6: f200 80c6    	bhi.w	0x8006166 <stm32_clock_control_get_subsys_rate+0x1d2> @ imm = #0x18c
 8005fda: a201         	adr	r2, #4 <stm32_clock_control_get_subsys_rate+0x4b>
 8005fdc: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08005fe0 <$d>:
 8005fe0: 1f 61 00 08  	.word	0x0800611f
 8005fe4: 55 61 00 08  	.word	0x08006155
 8005fe8: 5d 61 00 08  	.word	0x0800615d
 8005fec: 29 61 00 08  	.word	0x08006129
 8005ff0: 3f 61 00 08  	.word	0x0800613f
 8005ff4: 67 61 00 08  	.word	0x08006167
 8005ff8: 67 61 00 08  	.word	0x08006167
 8005ffc: 67 61 00 08  	.word	0x08006167
 8006000: 67 61 00 08  	.word	0x08006167
 8006004: 67 61 00 08  	.word	0x08006167
 8006008: 67 61 00 08  	.word	0x08006167
 800600c: 67 61 00 08  	.word	0x08006167
 8006010: 67 61 00 08  	.word	0x08006167
 8006014: 67 61 00 08  	.word	0x08006167
 8006018: 67 61 00 08  	.word	0x08006167
 800601c: 67 61 00 08  	.word	0x08006167
 8006020: 67 61 00 08  	.word	0x08006167
 8006024: 67 61 00 08  	.word	0x08006167
 8006028: 67 61 00 08  	.word	0x08006167
 800602c: 67 61 00 08  	.word	0x08006167
 8006030: 67 61 00 08  	.word	0x08006167
 8006034: 67 61 00 08  	.word	0x08006167
 8006038: 67 61 00 08  	.word	0x08006167
 800603c: 67 61 00 08  	.word	0x08006167
 8006040: 67 61 00 08  	.word	0x08006167
 8006044: 67 61 00 08  	.word	0x08006167
 8006048: 67 61 00 08  	.word	0x08006167
 800604c: 67 61 00 08  	.word	0x08006167
 8006050: 67 61 00 08  	.word	0x08006167
 8006054: 67 61 00 08  	.word	0x08006167
 8006058: 67 61 00 08  	.word	0x08006167
 800605c: 67 61 00 08  	.word	0x08006167
 8006060: 67 61 00 08  	.word	0x08006167
 8006064: 67 61 00 08  	.word	0x08006167
 8006068: 67 61 00 08  	.word	0x08006167
 800606c: 67 61 00 08  	.word	0x08006167
 8006070: 67 61 00 08  	.word	0x08006167
 8006074: 67 61 00 08  	.word	0x08006167
 8006078: 67 61 00 08  	.word	0x08006167
 800607c: 67 61 00 08  	.word	0x08006167
 8006080: 67 61 00 08  	.word	0x08006167
 8006084: 67 61 00 08  	.word	0x08006167
 8006088: 67 61 00 08  	.word	0x08006167
 800608c: 67 61 00 08  	.word	0x08006167
 8006090: 67 61 00 08  	.word	0x08006167
 8006094: 67 61 00 08  	.word	0x08006167
 8006098: 67 61 00 08  	.word	0x08006167
 800609c: f7 60 00 08  	.word	0x080060f7
 80060a0: 67 61 00 08  	.word	0x08006167
 80060a4: 67 61 00 08  	.word	0x08006167
 80060a8: 67 61 00 08  	.word	0x08006167
 80060ac: f7 60 00 08  	.word	0x080060f7
 80060b0: 67 61 00 08  	.word	0x08006167
 80060b4: 67 61 00 08  	.word	0x08006167
 80060b8: 67 61 00 08  	.word	0x08006167
 80060bc: ff 60 00 08  	.word	0x080060ff
 80060c0: 67 61 00 08  	.word	0x08006167
 80060c4: 67 61 00 08  	.word	0x08006167
 80060c8: 67 61 00 08  	.word	0x08006167
 80060cc: 67 61 00 08  	.word	0x08006167
 80060d0: 67 61 00 08  	.word	0x08006167
 80060d4: 67 61 00 08  	.word	0x08006167
 80060d8: 67 61 00 08  	.word	0x08006167
 80060dc: 07 61 00 08  	.word	0x08006107
 80060e0: 67 61 00 08  	.word	0x08006167
 80060e4: 67 61 00 08  	.word	0x08006167
 80060e8: 67 61 00 08  	.word	0x08006167
 80060ec: 0f 61 00 08  	.word	0x0800610f

080060f0 <$t>:
 80060f0: 2ba8         	cmp	r3, #0xa8
 80060f2: d010         	beq	0x8006116 <stm32_clock_control_get_subsys_rate+0x182> @ imm = #0x20
 80060f4: e037         	b	0x8006166 <stm32_clock_control_get_subsys_rate+0x1d2> @ imm = #0x6e
; 		*rate = ahb_clock;
 80060f6: 687b         	ldr	r3, [r7, #0x4]
 80060f8: 6a3a         	ldr	r2, [r7, #0x20]
 80060fa: 601a         	str	r2, [r3]
; 		break;
 80060fc: e036         	b	0x800616c <stm32_clock_control_get_subsys_rate+0x1d8> @ imm = #0x6c
; 		*rate = ahb3_clock;
 80060fe: 687b         	ldr	r3, [r7, #0x4]
 8006100: 697a         	ldr	r2, [r7, #0x14]
 8006102: 601a         	str	r2, [r3]
; 		break;
 8006104: e032         	b	0x800616c <stm32_clock_control_get_subsys_rate+0x1d8> @ imm = #0x64
; 		*rate = apb1_clock;
 8006106: 687b         	ldr	r3, [r7, #0x4]
 8006108: 69fa         	ldr	r2, [r7, #0x1c]
 800610a: 601a         	str	r2, [r3]
; 		break;
 800610c: e02e         	b	0x800616c <stm32_clock_control_get_subsys_rate+0x1d8> @ imm = #0x5c
; 		*rate = apb2_clock;
 800610e: 687b         	ldr	r3, [r7, #0x4]
 8006110: 69ba         	ldr	r2, [r7, #0x18]
 8006112: 601a         	str	r2, [r3]
; 		break;
 8006114: e02a         	b	0x800616c <stm32_clock_control_get_subsys_rate+0x1d8> @ imm = #0x54
; 		*rate = ahb3_clock;
 8006116: 687b         	ldr	r3, [r7, #0x4]
 8006118: 697a         	ldr	r2, [r7, #0x14]
 800611a: 601a         	str	r2, [r3]
; 		break;
 800611c: e026         	b	0x800616c <stm32_clock_control_get_subsys_rate+0x1d8> @ imm = #0x4c
; 		*rate = SystemCoreClock * STM32_CORE_PRESCALER;
 800611e: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8006178 <stm32_clock_control_get_subsys_rate+0x1e4>
 8006120: 681a         	ldr	r2, [r3]
 8006122: 687b         	ldr	r3, [r7, #0x4]
 8006124: 601a         	str	r2, [r3]
; 		break;
 8006126: e021         	b	0x800616c <stm32_clock_control_get_subsys_rate+0x1d8> @ imm = #0x42
; 		*rate = get_pll_div_frequency(get_pllsrc_frequency(),
 8006128: f000 f8e6    	bl	0x80062f8 <get_pllsrc_frequency> @ imm = #0x1cc
 800612c: 2302         	movs	r3, #0x2
 800612e: 22a8         	movs	r2, #0xa8
 8006130: 2106         	movs	r1, #0x6
 8006132: f00c fb65    	bl	0x8012800 <get_pll_div_frequency> @ imm = #0xc6ca
 8006136: 4602         	mov	r2, r0
 8006138: 687b         	ldr	r3, [r7, #0x4]
 800613a: 601a         	str	r2, [r3]
; 		break;
 800613c: e016         	b	0x800616c <stm32_clock_control_get_subsys_rate+0x1d8> @ imm = #0x2c
; 		*rate = get_pll_div_frequency(get_pllsrc_frequency(),
 800613e: f000 f8db    	bl	0x80062f8 <get_pllsrc_frequency> @ imm = #0x1b6
 8006142: 2304         	movs	r3, #0x4
 8006144: 22a8         	movs	r2, #0xa8
 8006146: 2106         	movs	r1, #0x6
 8006148: f00c fb5a    	bl	0x8012800 <get_pll_div_frequency> @ imm = #0xc6b4
 800614c: 4602         	mov	r2, r0
 800614e: 687b         	ldr	r3, [r7, #0x4]
 8006150: 601a         	str	r2, [r3]
; 		break;
 8006152: e00b         	b	0x800616c <stm32_clock_control_get_subsys_rate+0x1d8> @ imm = #0x16
; 		*rate = STM32_LSE_FREQ;
 8006154: 687b         	ldr	r3, [r7, #0x4]
 8006156: 2200         	movs	r2, #0x0
 8006158: 601a         	str	r2, [r3]
; 		break;
 800615a: e007         	b	0x800616c <stm32_clock_control_get_subsys_rate+0x1d8> @ imm = #0xe
; 		*rate = STM32_LSI_FREQ;
 800615c: 687b         	ldr	r3, [r7, #0x4]
 800615e: f44f 42fa    	mov.w	r2, #0x7d00
 8006162: 601a         	str	r2, [r3]
; 		break;
 8006164: e002         	b	0x800616c <stm32_clock_control_get_subsys_rate+0x1d8> @ imm = #0x4
; 		return -ENOTSUP;
 8006166: f06f 0385    	mvn	r3, #0x85
 800616a: e000         	b	0x800616e <stm32_clock_control_get_subsys_rate+0x1da> @ imm = #0x0
; 	return 0;
 800616c: 2300         	movs	r3, #0x0
; }
 800616e: 4618         	mov	r0, r3
 8006170: 3728         	adds	r7, #0x28
 8006172: 46bd         	mov	sp, r7
 8006174: bd80         	pop	{r7, pc}
 8006176: bf00         	nop

08006178 <$d>:
 8006178: 24 05 00 20  	.word	0x20000524

0800617c <set_up_plls>:
; {
 800617c: b580         	push	{r7, lr}
 800617e: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_GetSysClkSource() == LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
 8006180: f7ff fe54    	bl	0x8005e2c <LL_RCC_GetSysClkSource> @ imm = #-0x358
 8006184: 4603         	mov	r3, r0
 8006186: 2b08         	cmp	r3, #0x8
 8006188: d104         	bne	0x8006194 <set_up_plls+0x18> @ imm = #0x8
; 		stm32_clock_switch_to_hsi();
 800618a: f00c fc5b    	bl	0x8012a44 <stm32_clock_switch_to_hsi> @ imm = #0xc8b6
; 		LL_RCC_SetAHBPrescaler(ahb_prescaler(1));
 800618e: 2000         	movs	r0, #0x0
 8006190: f7ff fe58    	bl	0x8005e44 <LL_RCC_SetAHBPrescaler> @ imm = #-0x350
; 	LL_RCC_PLL_Disable();
 8006194: f7ff feac    	bl	0x8005ef0 <LL_RCC_PLL_Disable> @ imm = #-0x2a8
; 	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, pllp(STM32_PLL_P_DIVISOR));
 8006198: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80061d0 <set_up_plls+0x54>
 800619a: 685b         	ldr	r3, [r3, #0x4]
 800619c: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80061d0 <set_up_plls+0x54>
 800619e: f423 3340    	bic	r3, r3, #0x30000
 80061a2: 6053         	str	r3, [r2, #0x4]
; 	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ, pllq(STM32_PLL_Q_DIVISOR));
 80061a4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80061d0 <set_up_plls+0x54>
 80061a6: 685b         	ldr	r3, [r3, #0x4]
 80061a8: f023 6370    	bic	r3, r3, #0xf000000
 80061ac: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80061d0 <set_up_plls+0x54>
 80061ae: f043 6380    	orr	r3, r3, #0x4000000
 80061b2: 6053         	str	r3, [r2, #0x4]
; 	config_pll_sysclock();
 80061b4: f00c fc89    	bl	0x8012aca <config_pll_sysclock> @ imm = #0xc912
; 	LL_RCC_PLL_Enable();
 80061b8: f7ff fe8c    	bl	0x8005ed4 <LL_RCC_PLL_Enable> @ imm = #-0x2e8
; 	while (LL_RCC_PLL_IsReady() != 1U) {
 80061bc: bf00         	nop
 80061be: f7ff fea5    	bl	0x8005f0c <LL_RCC_PLL_IsReady> @ imm = #-0x2b6
 80061c2: 4603         	mov	r3, r0
 80061c4: 2b01         	cmp	r3, #0x1
 80061c6: d1fa         	bne	0x80061be <set_up_plls+0x42> @ imm = #-0xc
; }
 80061c8: bf00         	nop
 80061ca: bf00         	nop
 80061cc: bd80         	pop	{r7, pc}
 80061ce: bf00         	nop

080061d0 <$d>:
 80061d0: 00 38 02 40  	.word	0x40023800

080061d4 <stm32_clock_control_init>:
; {
 80061d4: b590         	push	{r4, r7, lr}
 80061d6: b085         	sub	sp, #0x14
 80061d8: af00         	add	r7, sp, #0x0
 80061da: 6078         	str	r0, [r7, #0x4]
; 	config_enable_default_clocks();
 80061dc: f00c fc80    	bl	0x8012ae0 <config_enable_default_clocks> @ imm = #0xc900
; 	config_regulator_voltage(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC);
 80061e0: 4823         	ldr	r0, [pc, #0x8c]         @ 0x8006270 <stm32_clock_control_init+0x9c>
 80061e2: f00c fc61    	bl	0x8012aa8 <config_regulator_voltage> @ imm = #0xc8c2
; 	old_flash_freq = RCC_CALC_FLASH_FREQ(HAL_RCC_GetSysClockFreq(),
 80061e6: f004 fe41    	bl	0x800ae6c <HAL_RCC_GetSysClockFreq> @ imm = #0x4c82
 80061ea: 4604         	mov	r4, r0
 80061ec: f7ff fe66    	bl	0x8005ebc <LL_RCC_GetAHBPrescaler> @ imm = #-0x334
 80061f0: 4603         	mov	r3, r0
 80061f2: 091b         	lsrs	r3, r3, #0x4
 80061f4: f003 030f    	and	r3, r3, #0xf
 80061f8: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x8006274 <stm32_clock_control_init+0xa0>
 80061fa: 5cd3         	ldrb	r3, [r2, r3]
 80061fc: fa24 f303    	lsr.w	r3, r4, r3
 8006200: 60fb         	str	r3, [r7, #0xc]
; 	new_flash_freq = RCC_CALC_FLASH_FREQ(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC,
 8006202: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8006274 <stm32_clock_control_init+0xa0>
 8006204: 781b         	ldrb	r3, [r3]
 8006206: 461a         	mov	r2, r3
 8006208: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8006270 <stm32_clock_control_init+0x9c>
 800620a: 4113         	asrs	r3, r2
 800620c: 60bb         	str	r3, [r7, #0x8]
; 	if (old_flash_freq < new_flash_freq) {
 800620e: 68fa         	ldr	r2, [r7, #0xc]
 8006210: 68bb         	ldr	r3, [r7, #0x8]
 8006212: 429a         	cmp	r2, r3
 8006214: d202         	bhs	0x800621c <stm32_clock_control_init+0x48> @ imm = #0x4
; 		LL_SetFlashLatency(new_flash_freq);
 8006216: 68b8         	ldr	r0, [r7, #0x8]
 8006218: f005 f81a    	bl	0x800b250 <LL_SetFlashLatency> @ imm = #0x5034
; 	set_up_fixed_clock_sources();
 800621c: f00c fc2d    	bl	0x8012a7a <set_up_fixed_clock_sources> @ imm = #0xc85a
; 	set_up_plls();
 8006220: f7ff ffac    	bl	0x800617c <set_up_plls> @ imm = #-0xa8
; 		LL_RCC_SetAHBPrescaler(ahb_prescaler(STM32_CORE_PRESCALER));
 8006224: 2000         	movs	r0, #0x0
 8006226: f7ff fe0d    	bl	0x8005e44 <LL_RCC_SetAHBPrescaler> @ imm = #-0x3e6
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
 800622a: 2002         	movs	r0, #0x2
 800622c: f7ff fdea    	bl	0x8005e04 <LL_RCC_SetSysClkSource> @ imm = #-0x42c
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
 8006230: bf00         	nop
 8006232: f7ff fdfb    	bl	0x8005e2c <LL_RCC_GetSysClkSource> @ imm = #-0x40a
 8006236: 4603         	mov	r3, r0
 8006238: 2b08         	cmp	r3, #0x8
 800623a: d1fa         	bne	0x8006232 <stm32_clock_control_init+0x5e> @ imm = #-0xc
; 	if (old_flash_freq >= new_flash_freq) {
 800623c: 68fa         	ldr	r2, [r7, #0xc]
 800623e: 68bb         	ldr	r3, [r7, #0x8]
 8006240: 429a         	cmp	r2, r3
 8006242: d302         	blo	0x800624a <stm32_clock_control_init+0x76> @ imm = #0x4
; 		LL_SetFlashLatency(new_flash_freq);
 8006244: 68b8         	ldr	r0, [r7, #0x8]
 8006246: f005 f803    	bl	0x800b250 <LL_SetFlashLatency> @ imm = #0x5006
; 	SystemCoreClock = CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC;
 800624a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8006278 <stm32_clock_control_init+0xa4>
 800624c: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8006270 <stm32_clock_control_init+0x9c>
 800624e: 601a         	str	r2, [r3]
; 	LL_RCC_SetAPB1Prescaler(apb1_prescaler(STM32_APB1_PRESCALER));
 8006250: f44f 50a0    	mov.w	r0, #0x1400
 8006254: f7ff fe0a    	bl	0x8005e6c <LL_RCC_SetAPB1Prescaler> @ imm = #-0x3ec
; 	LL_RCC_SetAPB2Prescaler(apb2_prescaler(STM32_APB2_PRESCALER));
 8006258: f44f 4000    	mov.w	r0, #0x8000
 800625c: f7ff fe1a    	bl	0x8005e94 <LL_RCC_SetAPB2Prescaler> @ imm = #-0x3cc
; 	stm32_clock_control_mco_init();
 8006260: f00c fac8    	bl	0x80127f4 <stm32_clock_control_mco_init> @ imm = #0xc590
; 	return 0;
 8006264: 2300         	movs	r3, #0x0
; }
 8006266: 4618         	mov	r0, r3
 8006268: 3714         	adds	r7, #0x14
 800626a: 46bd         	mov	sp, r7
 800626c: bd90         	pop	{r4, r7, pc}
 800626e: bf00         	nop

08006270 <$d>:
 8006270: 00 7a 03 0a  	.word	0x0a037a00
 8006274: 4c bd 01 08  	.word	0x0801bd4c
 8006278: 24 05 00 20  	.word	0x20000524

0800627c <LL_APB1_GRP1_EnableClock>:
; {
 800627c: b480         	push	{r7}
 800627e: b085         	sub	sp, #0x14
 8006280: af00         	add	r7, sp, #0x0
 8006282: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(RCC->APB1ENR, Periphs);
 8006284: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80062a8 <LL_APB1_GRP1_EnableClock+0x2c>
 8006286: 6c1a         	ldr	r2, [r3, #0x40]
 8006288: 4907         	ldr	r1, [pc, #0x1c]         @ 0x80062a8 <LL_APB1_GRP1_EnableClock+0x2c>
 800628a: 687b         	ldr	r3, [r7, #0x4]
 800628c: 4313         	orrs	r3, r2
 800628e: 640b         	str	r3, [r1, #0x40]
;   tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 8006290: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80062a8 <LL_APB1_GRP1_EnableClock+0x2c>
 8006292: 6c1a         	ldr	r2, [r3, #0x40]
 8006294: 687b         	ldr	r3, [r7, #0x4]
 8006296: 4013         	ands	r3, r2
 8006298: 60fb         	str	r3, [r7, #0xc]
;   (void)tmpreg;
 800629a: 68fb         	ldr	r3, [r7, #0xc]
; }
 800629c: bf00         	nop
 800629e: 3714         	adds	r7, #0x14
 80062a0: 46bd         	mov	sp, r7
 80062a2: bc80         	pop	{r7}
 80062a4: 4770         	bx	lr
 80062a6: bf00         	nop

080062a8 <$d>:
 80062a8: 00 38 02 40  	.word	0x40023800

080062ac <LL_RCC_PLL_ConfigDomain_SYS>:
; {
 80062ac: b480         	push	{r7}
 80062ae: b085         	sub	sp, #0x14
 80062b0: af00         	add	r7, sp, #0x0
 80062b2: 60f8         	str	r0, [r7, #0xc]
 80062b4: 60b9         	str	r1, [r7, #0x8]
 80062b6: 607a         	str	r2, [r7, #0x4]
 80062b8: 603b         	str	r3, [r7]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN,
 80062ba: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80062f0 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 80062bc: 685a         	ldr	r2, [r3, #0x4]
 80062be: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80062f4 <LL_RCC_PLL_ConfigDomain_SYS+0x48>
 80062c0: 4013         	ands	r3, r2
 80062c2: 68f9         	ldr	r1, [r7, #0xc]
 80062c4: 68ba         	ldr	r2, [r7, #0x8]
 80062c6: 4311         	orrs	r1, r2
 80062c8: 687a         	ldr	r2, [r7, #0x4]
 80062ca: 0192         	lsls	r2, r2, #0x6
 80062cc: 430a         	orrs	r2, r1
 80062ce: 4908         	ldr	r1, [pc, #0x20]         @ 0x80062f0 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 80062d0: 4313         	orrs	r3, r2
 80062d2: 604b         	str	r3, [r1, #0x4]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, PLLP_R);
 80062d4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80062f0 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 80062d6: 685b         	ldr	r3, [r3, #0x4]
 80062d8: f423 3240    	bic	r2, r3, #0x30000
 80062dc: 4904         	ldr	r1, [pc, #0x10]         @ 0x80062f0 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 80062de: 683b         	ldr	r3, [r7]
 80062e0: 4313         	orrs	r3, r2
 80062e2: 604b         	str	r3, [r1, #0x4]
; }
 80062e4: bf00         	nop
 80062e6: 3714         	adds	r7, #0x14
 80062e8: 46bd         	mov	sp, r7
 80062ea: bc80         	pop	{r7}
 80062ec: 4770         	bx	lr
 80062ee: bf00         	nop

080062f0 <$d>:
 80062f0: 00 38 02 40  	.word	0x40023800
 80062f4: 00 80 bf ff  	.word	0xffbf8000

080062f8 <get_pllsrc_frequency>:
; {
 80062f8: b480         	push	{r7}
 80062fa: af00         	add	r7, sp, #0x0
; 		return STM32_HSE_FREQ;
 80062fc: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8006308 <get_pllsrc_frequency+0x10>
; }
 80062fe: 4618         	mov	r0, r3
 8006300: 46bd         	mov	sp, r7
 8006302: bc80         	pop	{r7}
 8006304: 4770         	bx	lr
 8006306: bf00         	nop

08006308 <$d>:
 8006308: 00 1b b7 00  	.word	0x00b71b00

0800630c <console_out>:
; {
 800630c: b580         	push	{r7, lr}
 800630e: b082         	sub	sp, #0x8
 8006310: af00         	add	r7, sp, #0x0
 8006312: 6078         	str	r0, [r7, #0x4]
; 	if (pm_device_runtime_get(uart_console_dev) < 0) {
 8006314: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8006360 <console_out+0x54>
 8006316: 4618         	mov	r0, r3
 8006318: f00c fc18    	bl	0x8012b4c <pm_device_runtime_get> @ imm = #0xc830
 800631c: 4603         	mov	r3, r0
 800631e: 2b00         	cmp	r3, #0x0
 8006320: da01         	bge	0x8006326 <console_out+0x1a> @ imm = #0x2
; 		return c;
 8006322: 6879         	ldr	r1, [r7, #0x4]
 8006324: e017         	b	0x8006356 <console_out+0x4a> @ imm = #0x2e
; 	if ('\n' == c) {
 8006326: 687b         	ldr	r3, [r7, #0x4]
 8006328: 2b0a         	cmp	r3, #0xa
 800632a: d104         	bne	0x8006336 <console_out+0x2a> @ imm = #0x8
; 		uart_poll_out(uart_console_dev, '\r');
 800632c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8006360 <console_out+0x54>
 800632e: 210d         	movs	r1, #0xd
 8006330: 4618         	mov	r0, r3
 8006332: f00c fbfc    	bl	0x8012b2e <uart_poll_out> @ imm = #0xc7f8
; 	uart_poll_out(uart_console_dev, c);
 8006336: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8006360 <console_out+0x54>
 8006338: 687b         	ldr	r3, [r7, #0x4]
 800633a: b2db         	uxtb	r3, r3
 800633c: 4619         	mov	r1, r3
 800633e: 4610         	mov	r0, r2
 8006340: f00c fbf5    	bl	0x8012b2e <uart_poll_out> @ imm = #0xc7ea
; 	(void)pm_device_runtime_put_async(uart_console_dev, K_MSEC(1));
 8006344: 4906         	ldr	r1, [pc, #0x18]         @ 0x8006360 <console_out+0x54>
 8006346: f04f 020a    	mov.w	r2, #0xa
 800634a: f04f 0300    	mov.w	r3, #0x0
 800634e: 4608         	mov	r0, r1
 8006350: f00c fc06    	bl	0x8012b60 <pm_device_runtime_put_async> @ imm = #0xc80c
; 	return c;
 8006354: 6879         	ldr	r1, [r7, #0x4]
; }
 8006356: 460b         	mov	r3, r1
 8006358: 4618         	mov	r0, r3
 800635a: 3708         	adds	r7, #0x8
 800635c: 46bd         	mov	sp, r7
 800635e: bd80         	pop	{r7, pc}

08006360 <$d>:
 8006360: 20 93 01 08  	.word	0x08019320

08006364 <uart_console_hook_install>:
; {
 8006364: b580         	push	{r7, lr}
 8006366: af00         	add	r7, sp, #0x0
; 	__stdout_hook_install(console_out);
 8006368: 4803         	ldr	r0, [pc, #0xc]          @ 0x8006378 <uart_console_hook_install+0x14>
 800636a: f7fd fc73    	bl	0x8003c54 <__stdout_hook_install> @ imm = #-0x271a
; 	__printk_hook_install(console_out);
 800636e: 4802         	ldr	r0, [pc, #0x8]          @ 0x8006378 <uart_console_hook_install+0x14>
 8006370: f7fb fc38    	bl	0x8001be4 <__printk_hook_install> @ imm = #-0x4790
; }
 8006374: bf00         	nop
 8006376: bd80         	pop	{r7, pc}

08006378 <$d>:
 8006378: 0d 63 00 08  	.word	0x0800630d

0800637c <uart_console_init>:
; {
 800637c: b580         	push	{r7, lr}
 800637e: af00         	add	r7, sp, #0x0
; 	if (!device_is_ready(uart_console_dev)) {
 8006380: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80063a4 <uart_console_init+0x28>
 8006382: 4618         	mov	r0, r3
 8006384: f00c fbb4    	bl	0x8012af0 <device_is_ready> @ imm = #0xc768
 8006388: 4603         	mov	r3, r0
 800638a: f083 0301    	eor	r3, r3, #0x1
 800638e: b2db         	uxtb	r3, r3
 8006390: 2b00         	cmp	r3, #0x0
 8006392: d002         	beq	0x800639a <uart_console_init+0x1e> @ imm = #0x4
; 		return -ENODEV;
 8006394: f06f 0312    	mvn	r3, #0x12
 8006398: e002         	b	0x80063a0 <uart_console_init+0x24> @ imm = #0x4
; 	uart_console_hook_install();
 800639a: f7ff ffe3    	bl	0x8006364 <uart_console_hook_install> @ imm = #-0x3a
; 	return 0;
 800639e: 2300         	movs	r3, #0x0
; }
 80063a0: 4618         	mov	r0, r3
 80063a2: bd80         	pop	{r7, pc}

080063a4 <$d>:
 80063a4: 20 93 01 08  	.word	0x08019320

080063a8 <LL_DMA_SetDataLength>:
; {
 80063a8: b480         	push	{r7}
 80063aa: b085         	sub	sp, #0x14
 80063ac: af00         	add	r7, sp, #0x0
 80063ae: 60f8         	str	r0, [r7, #0xc]
 80063b0: 60b9         	str	r1, [r7, #0x8]
 80063b2: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT, NbData);
 80063b4: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80063e8 <LL_DMA_SetDataLength+0x40>
 80063b6: 68bb         	ldr	r3, [r7, #0x8]
 80063b8: 4413         	add	r3, r2
 80063ba: 781b         	ldrb	r3, [r3]
 80063bc: 461a         	mov	r2, r3
 80063be: 68fb         	ldr	r3, [r7, #0xc]
 80063c0: 4413         	add	r3, r2
 80063c2: 685b         	ldr	r3, [r3, #0x4]
 80063c4: 0c1b         	lsrs	r3, r3, #0x10
 80063c6: 041b         	lsls	r3, r3, #0x10
 80063c8: 4907         	ldr	r1, [pc, #0x1c]         @ 0x80063e8 <LL_DMA_SetDataLength+0x40>
 80063ca: 68ba         	ldr	r2, [r7, #0x8]
 80063cc: 440a         	add	r2, r1
 80063ce: 7812         	ldrb	r2, [r2]
 80063d0: 4611         	mov	r1, r2
 80063d2: 68fa         	ldr	r2, [r7, #0xc]
 80063d4: 440a         	add	r2, r1
 80063d6: 4611         	mov	r1, r2
 80063d8: 687a         	ldr	r2, [r7, #0x4]
 80063da: 4313         	orrs	r3, r2
 80063dc: 604b         	str	r3, [r1, #0x4]
; }
 80063de: bf00         	nop
 80063e0: 3714         	adds	r7, #0x14
 80063e2: 46bd         	mov	sp, r7
 80063e4: bc80         	pop	{r7}
 80063e6: 4770         	bx	lr

080063e8 <$d>:
 80063e8: 28 b6 01 08  	.word	0x0801b628

080063ec <LL_DMA_GetDataLength>:
; {
 80063ec: b480         	push	{r7}
 80063ee: b083         	sub	sp, #0xc
 80063f0: af00         	add	r7, sp, #0x0
 80063f2: 6078         	str	r0, [r7, #0x4]
 80063f4: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT));
 80063f6: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8006414 <LL_DMA_GetDataLength+0x28>
 80063f8: 683b         	ldr	r3, [r7]
 80063fa: 4413         	add	r3, r2
 80063fc: 781b         	ldrb	r3, [r3]
 80063fe: 461a         	mov	r2, r3
 8006400: 687b         	ldr	r3, [r7, #0x4]
 8006402: 4413         	add	r3, r2
 8006404: 685b         	ldr	r3, [r3, #0x4]
 8006406: b29b         	uxth	r3, r3
; }
 8006408: 4618         	mov	r0, r3
 800640a: 370c         	adds	r7, #0xc
 800640c: 46bd         	mov	sp, r7
 800640e: bc80         	pop	{r7}
 8006410: 4770         	bx	lr
 8006412: bf00         	nop

08006414 <$d>:
 8006414: 28 b6 01 08  	.word	0x0801b628

08006418 <LL_DMA_DisableFifoMode>:
; {
 8006418: b480         	push	{r7}
 800641a: b083         	sub	sp, #0xc
 800641c: af00         	add	r7, sp, #0x0
 800641e: 6078         	str	r0, [r7, #0x4]
 8006420: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_DMDIS);
 8006422: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006450 <LL_DMA_DisableFifoMode+0x38>
 8006424: 683b         	ldr	r3, [r7]
 8006426: 4413         	add	r3, r2
 8006428: 781b         	ldrb	r3, [r3]
 800642a: 461a         	mov	r2, r3
 800642c: 687b         	ldr	r3, [r7, #0x4]
 800642e: 4413         	add	r3, r2
 8006430: 695b         	ldr	r3, [r3, #0x14]
 8006432: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006450 <LL_DMA_DisableFifoMode+0x38>
 8006434: 683a         	ldr	r2, [r7]
 8006436: 440a         	add	r2, r1
 8006438: 7812         	ldrb	r2, [r2]
 800643a: 4611         	mov	r1, r2
 800643c: 687a         	ldr	r2, [r7, #0x4]
 800643e: 440a         	add	r2, r1
 8006440: f023 0304    	bic	r3, r3, #0x4
 8006444: 6153         	str	r3, [r2, #0x14]
; }
 8006446: bf00         	nop
 8006448: 370c         	adds	r7, #0xc
 800644a: 46bd         	mov	sp, r7
 800644c: bc80         	pop	{r7}
 800644e: 4770         	bx	lr

08006450 <$d>:
 8006450: 28 b6 01 08  	.word	0x0801b628

08006454 <LL_DMA_EnableFifoMode>:
; {
 8006454: b480         	push	{r7}
 8006456: b083         	sub	sp, #0xc
 8006458: af00         	add	r7, sp, #0x0
 800645a: 6078         	str	r0, [r7, #0x4]
 800645c: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_DMDIS);
 800645e: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800648c <LL_DMA_EnableFifoMode+0x38>
 8006460: 683b         	ldr	r3, [r7]
 8006462: 4413         	add	r3, r2
 8006464: 781b         	ldrb	r3, [r3]
 8006466: 461a         	mov	r2, r3
 8006468: 687b         	ldr	r3, [r7, #0x4]
 800646a: 4413         	add	r3, r2
 800646c: 695b         	ldr	r3, [r3, #0x14]
 800646e: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800648c <LL_DMA_EnableFifoMode+0x38>
 8006470: 683a         	ldr	r2, [r7]
 8006472: 440a         	add	r2, r1
 8006474: 7812         	ldrb	r2, [r2]
 8006476: 4611         	mov	r1, r2
 8006478: 687a         	ldr	r2, [r7, #0x4]
 800647a: 440a         	add	r2, r1
 800647c: f043 0304    	orr	r3, r3, #0x4
 8006480: 6153         	str	r3, [r2, #0x14]
; }
 8006482: bf00         	nop
 8006484: 370c         	adds	r7, #0xc
 8006486: 46bd         	mov	sp, r7
 8006488: bc80         	pop	{r7}
 800648a: 4770         	bx	lr

0800648c <$d>:
 800648c: 28 b6 01 08  	.word	0x0801b628

08006490 <LL_DMA_SetMemoryAddress>:
; {
 8006490: b480         	push	{r7}
 8006492: b085         	sub	sp, #0x14
 8006494: af00         	add	r7, sp, #0x0
 8006496: 60f8         	str	r0, [r7, #0xc]
 8006498: 60b9         	str	r1, [r7, #0x8]
 800649a: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->M0AR, MemoryAddress);
 800649c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80064bc <LL_DMA_SetMemoryAddress+0x2c>
 800649e: 68bb         	ldr	r3, [r7, #0x8]
 80064a0: 4413         	add	r3, r2
 80064a2: 781b         	ldrb	r3, [r3]
 80064a4: 461a         	mov	r2, r3
 80064a6: 68fb         	ldr	r3, [r7, #0xc]
 80064a8: 4413         	add	r3, r2
 80064aa: 461a         	mov	r2, r3
 80064ac: 687b         	ldr	r3, [r7, #0x4]
 80064ae: 60d3         	str	r3, [r2, #0xc]
; }
 80064b0: bf00         	nop
 80064b2: 3714         	adds	r7, #0x14
 80064b4: 46bd         	mov	sp, r7
 80064b6: bc80         	pop	{r7}
 80064b8: 4770         	bx	lr
 80064ba: bf00         	nop

080064bc <$d>:
 80064bc: 28 b6 01 08  	.word	0x0801b628

080064c0 <LL_DMA_SetPeriphAddress>:
; {
 80064c0: b480         	push	{r7}
 80064c2: b085         	sub	sp, #0x14
 80064c4: af00         	add	r7, sp, #0x0
 80064c6: 60f8         	str	r0, [r7, #0xc]
 80064c8: 60b9         	str	r1, [r7, #0x8]
 80064ca: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->PAR, PeriphAddress);
 80064cc: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80064ec <LL_DMA_SetPeriphAddress+0x2c>
 80064ce: 68bb         	ldr	r3, [r7, #0x8]
 80064d0: 4413         	add	r3, r2
 80064d2: 781b         	ldrb	r3, [r3]
 80064d4: 461a         	mov	r2, r3
 80064d6: 68fb         	ldr	r3, [r7, #0xc]
 80064d8: 4413         	add	r3, r2
 80064da: 461a         	mov	r2, r3
 80064dc: 687b         	ldr	r3, [r7, #0x4]
 80064de: 6093         	str	r3, [r2, #0x8]
; }
 80064e0: bf00         	nop
 80064e2: 3714         	adds	r7, #0x14
 80064e4: 46bd         	mov	sp, r7
 80064e6: bc80         	pop	{r7}
 80064e8: 4770         	bx	lr
 80064ea: bf00         	nop

080064ec <$d>:
 80064ec: 28 b6 01 08  	.word	0x0801b628

080064f0 <LL_DMA_EnableIT_HT>:
; {
 80064f0: b480         	push	{r7}
 80064f2: b083         	sub	sp, #0xc
 80064f4: af00         	add	r7, sp, #0x0
 80064f6: 6078         	str	r0, [r7, #0x4]
 80064f8: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_HTIE);
 80064fa: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006528 <LL_DMA_EnableIT_HT+0x38>
 80064fc: 683b         	ldr	r3, [r7]
 80064fe: 4413         	add	r3, r2
 8006500: 781b         	ldrb	r3, [r3]
 8006502: 461a         	mov	r2, r3
 8006504: 687b         	ldr	r3, [r7, #0x4]
 8006506: 4413         	add	r3, r2
 8006508: 681b         	ldr	r3, [r3]
 800650a: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006528 <LL_DMA_EnableIT_HT+0x38>
 800650c: 683a         	ldr	r2, [r7]
 800650e: 440a         	add	r2, r1
 8006510: 7812         	ldrb	r2, [r2]
 8006512: 4611         	mov	r1, r2
 8006514: 687a         	ldr	r2, [r7, #0x4]
 8006516: 440a         	add	r2, r1
 8006518: f043 0308    	orr	r3, r3, #0x8
 800651c: 6013         	str	r3, [r2]
; }
 800651e: bf00         	nop
 8006520: 370c         	adds	r7, #0xc
 8006522: 46bd         	mov	sp, r7
 8006524: bc80         	pop	{r7}
 8006526: 4770         	bx	lr

08006528 <$d>:
 8006528: 28 b6 01 08  	.word	0x0801b628

0800652c <LL_DMA_EnableIT_TC>:
; {
 800652c: b480         	push	{r7}
 800652e: b083         	sub	sp, #0xc
 8006530: af00         	add	r7, sp, #0x0
 8006532: 6078         	str	r0, [r7, #0x4]
 8006534: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE);
 8006536: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006564 <LL_DMA_EnableIT_TC+0x38>
 8006538: 683b         	ldr	r3, [r7]
 800653a: 4413         	add	r3, r2
 800653c: 781b         	ldrb	r3, [r3]
 800653e: 461a         	mov	r2, r3
 8006540: 687b         	ldr	r3, [r7, #0x4]
 8006542: 4413         	add	r3, r2
 8006544: 681b         	ldr	r3, [r3]
 8006546: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006564 <LL_DMA_EnableIT_TC+0x38>
 8006548: 683a         	ldr	r2, [r7]
 800654a: 440a         	add	r2, r1
 800654c: 7812         	ldrb	r2, [r2]
 800654e: 4611         	mov	r1, r2
 8006550: 687a         	ldr	r2, [r7, #0x4]
 8006552: 440a         	add	r2, r1
 8006554: f043 0310    	orr	r3, r3, #0x10
 8006558: 6013         	str	r3, [r2]
; }
 800655a: bf00         	nop
 800655c: 370c         	adds	r7, #0xc
 800655e: 46bd         	mov	sp, r7
 8006560: bc80         	pop	{r7}
 8006562: 4770         	bx	lr

08006564 <$d>:
 8006564: 28 b6 01 08  	.word	0x0801b628

08006568 <LL_DMA_EnableIT_FE>:
; {
 8006568: b480         	push	{r7}
 800656a: b083         	sub	sp, #0xc
 800656c: af00         	add	r7, sp, #0x0
 800656e: 6078         	str	r0, [r7, #0x4]
 8006570: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 8006572: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80065a0 <LL_DMA_EnableIT_FE+0x38>
 8006574: 683b         	ldr	r3, [r7]
 8006576: 4413         	add	r3, r2
 8006578: 781b         	ldrb	r3, [r3]
 800657a: 461a         	mov	r2, r3
 800657c: 687b         	ldr	r3, [r7, #0x4]
 800657e: 4413         	add	r3, r2
 8006580: 695b         	ldr	r3, [r3, #0x14]
 8006582: 4907         	ldr	r1, [pc, #0x1c]         @ 0x80065a0 <LL_DMA_EnableIT_FE+0x38>
 8006584: 683a         	ldr	r2, [r7]
 8006586: 440a         	add	r2, r1
 8006588: 7812         	ldrb	r2, [r2]
 800658a: 4611         	mov	r1, r2
 800658c: 687a         	ldr	r2, [r7, #0x4]
 800658e: 440a         	add	r2, r1
 8006590: f043 0380    	orr	r3, r3, #0x80
 8006594: 6153         	str	r3, [r2, #0x14]
; }
 8006596: bf00         	nop
 8006598: 370c         	adds	r7, #0xc
 800659a: 46bd         	mov	sp, r7
 800659c: bc80         	pop	{r7}
 800659e: 4770         	bx	lr

080065a0 <$d>:
 80065a0: 28 b6 01 08  	.word	0x0801b628

080065a4 <LL_DMA_DisableIT_TC>:
; {
 80065a4: b480         	push	{r7}
 80065a6: b083         	sub	sp, #0xc
 80065a8: af00         	add	r7, sp, #0x0
 80065aa: 6078         	str	r0, [r7, #0x4]
 80065ac: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE);
 80065ae: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80065dc <LL_DMA_DisableIT_TC+0x38>
 80065b0: 683b         	ldr	r3, [r7]
 80065b2: 4413         	add	r3, r2
 80065b4: 781b         	ldrb	r3, [r3]
 80065b6: 461a         	mov	r2, r3
 80065b8: 687b         	ldr	r3, [r7, #0x4]
 80065ba: 4413         	add	r3, r2
 80065bc: 681b         	ldr	r3, [r3]
 80065be: 4907         	ldr	r1, [pc, #0x1c]         @ 0x80065dc <LL_DMA_DisableIT_TC+0x38>
 80065c0: 683a         	ldr	r2, [r7]
 80065c2: 440a         	add	r2, r1
 80065c4: 7812         	ldrb	r2, [r2]
 80065c6: 4611         	mov	r1, r2
 80065c8: 687a         	ldr	r2, [r7, #0x4]
 80065ca: 440a         	add	r2, r1
 80065cc: f023 0310    	bic	r3, r3, #0x10
 80065d0: 6013         	str	r3, [r2]
; }
 80065d2: bf00         	nop
 80065d4: 370c         	adds	r7, #0xc
 80065d6: 46bd         	mov	sp, r7
 80065d8: bc80         	pop	{r7}
 80065da: 4770         	bx	lr

080065dc <$d>:
 80065dc: 28 b6 01 08  	.word	0x0801b628

080065e0 <LL_DMA_DisableIT_FE>:
; {
 80065e0: b480         	push	{r7}
 80065e2: b083         	sub	sp, #0xc
 80065e4: af00         	add	r7, sp, #0x0
 80065e6: 6078         	str	r0, [r7, #0x4]
 80065e8: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 80065ea: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8006618 <LL_DMA_DisableIT_FE+0x38>
 80065ec: 683b         	ldr	r3, [r7]
 80065ee: 4413         	add	r3, r2
 80065f0: 781b         	ldrb	r3, [r3]
 80065f2: 461a         	mov	r2, r3
 80065f4: 687b         	ldr	r3, [r7, #0x4]
 80065f6: 4413         	add	r3, r2
 80065f8: 695b         	ldr	r3, [r3, #0x14]
 80065fa: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006618 <LL_DMA_DisableIT_FE+0x38>
 80065fc: 683a         	ldr	r2, [r7]
 80065fe: 440a         	add	r2, r1
 8006600: 7812         	ldrb	r2, [r2]
 8006602: 4611         	mov	r1, r2
 8006604: 687a         	ldr	r2, [r7, #0x4]
 8006606: 440a         	add	r2, r1
 8006608: f023 0380    	bic	r3, r3, #0x80
 800660c: 6153         	str	r3, [r2, #0x14]
; }
 800660e: bf00         	nop
 8006610: 370c         	adds	r7, #0xc
 8006612: 46bd         	mov	sp, r7
 8006614: bc80         	pop	{r7}
 8006616: 4770         	bx	lr

08006618 <$d>:
 8006618: 28 b6 01 08  	.word	0x0801b628

0800661c <dma_stm32_irq_handler>:
; {
 800661c: b590         	push	{r4, r7, lr}
 800661e: b08f         	sub	sp, #0x3c
 8006620: af04         	add	r7, sp, #0x10
 8006622: 6078         	str	r0, [r7, #0x4]
 8006624: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8006626: 687b         	ldr	r3, [r7, #0x4]
 8006628: 685b         	ldr	r3, [r3, #0x4]
 800662a: 627b         	str	r3, [r7, #0x24]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 800662c: 6a7b         	ldr	r3, [r7, #0x24]
 800662e: 691b         	ldr	r3, [r3, #0x10]
 8006630: 623b         	str	r3, [r7, #0x20]
; 	stream = &config->streams[id];
 8006632: 6a7b         	ldr	r3, [r7, #0x24]
 8006634: 6999         	ldr	r1, [r3, #0x18]
 8006636: 683a         	ldr	r2, [r7]
 8006638: 4613         	mov	r3, r2
 800663a: 00db         	lsls	r3, r3, #0x3
 800663c: 1a9b         	subs	r3, r3, r2
 800663e: 009b         	lsls	r3, r3, #0x2
 8006640: 440b         	add	r3, r1
 8006642: 61fb         	str	r3, [r7, #0x1c]
; 	if ((stream->hal_override != true) && (stream->busy == false)) {
 8006644: 69fb         	ldr	r3, [r7, #0x1c]
 8006646: 795b         	ldrb	r3, [r3, #0x5]
 8006648: f083 0301    	eor	r3, r3, #0x1
 800664c: b2db         	uxtb	r3, r3
 800664e: 2b00         	cmp	r3, #0x0
 8006650: d00c         	beq	0x800666c <dma_stm32_irq_handler+0x50> @ imm = #0x18
 8006652: 69fb         	ldr	r3, [r7, #0x1c]
 8006654: 799b         	ldrb	r3, [r3, #0x6]
 8006656: b2db         	uxtb	r3, r3
 8006658: f083 0301    	eor	r3, r3, #0x1
 800665c: b2db         	uxtb	r3, r3
 800665e: 2b00         	cmp	r3, #0x0
 8006660: d004         	beq	0x800666c <dma_stm32_irq_handler+0x50> @ imm = #0x8
; 		dma_stm32_clear_stream_irq(dev, id);
 8006662: 6839         	ldr	r1, [r7]
 8006664: 6878         	ldr	r0, [r7, #0x4]
 8006666: f00c fae4    	bl	0x8012c32 <dma_stm32_clear_stream_irq> @ imm = #0xc5c8
; 		return;
 800666a: e09a         	b	0x80067a2 <dma_stm32_irq_handler+0x186> @ imm = #0x134
; 	callback_arg = id + STM32_DMA_STREAM_OFFSET;
 800666c: 683b         	ldr	r3, [r7]
 800666e: 61bb         	str	r3, [r7, #0x18]
; 	if (stm32_dma_is_ht_irq_active(dma, id)) {
 8006670: 6839         	ldr	r1, [r7]
 8006672: 6a38         	ldr	r0, [r7, #0x20]
 8006674: f00d fa26    	bl	0x8013ac4 <stm32_dma_is_ht_irq_active> @ imm = #0xd44c
 8006678: 4603         	mov	r3, r0
 800667a: 2b00         	cmp	r3, #0x0
 800667c: d013         	beq	0x80066a6 <dma_stm32_irq_handler+0x8a> @ imm = #0x26
; 		if (!stream->hal_override) {
 800667e: 69fb         	ldr	r3, [r7, #0x1c]
 8006680: 795b         	ldrb	r3, [r3, #0x5]
 8006682: f083 0301    	eor	r3, r3, #0x1
 8006686: b2db         	uxtb	r3, r3
 8006688: 2b00         	cmp	r3, #0x0
 800668a: d003         	beq	0x8006694 <dma_stm32_irq_handler+0x78> @ imm = #0x6
; 			dma_stm32_clear_ht(dma, id);
 800668c: 6839         	ldr	r1, [r7]
 800668e: 6a38         	ldr	r0, [r7, #0x20]
 8006690: f000 ff86    	bl	0x80075a0 <dma_stm32_clear_ht> @ imm = #0xf0c
; 		stream->dma_callback(dev, stream->user_data, callback_arg, DMA_STATUS_BLOCK);
 8006694: 69fb         	ldr	r3, [r7, #0x1c]
 8006696: 695c         	ldr	r4, [r3, #0x14]
 8006698: 69fb         	ldr	r3, [r7, #0x1c]
 800669a: 6919         	ldr	r1, [r3, #0x10]
 800669c: 2301         	movs	r3, #0x1
 800669e: 69ba         	ldr	r2, [r7, #0x18]
 80066a0: 6878         	ldr	r0, [r7, #0x4]
 80066a2: 47a0         	blx	r4
 80066a4: e07d         	b	0x80067a2 <dma_stm32_irq_handler+0x186> @ imm = #0xfa
; 	} else if (stm32_dma_is_tc_irq_active(dma, id)) {
 80066a6: 6839         	ldr	r1, [r7]
 80066a8: 6a38         	ldr	r0, [r7, #0x20]
 80066aa: f00d f9ea    	bl	0x8013a82 <stm32_dma_is_tc_irq_active> @ imm = #0xd3d4
 80066ae: 4603         	mov	r3, r0
 80066b0: 2b00         	cmp	r3, #0x0
 80066b2: d01d         	beq	0x80066f0 <dma_stm32_irq_handler+0xd4> @ imm = #0x3a
; 		if (!stream->cyclic) {
 80066b4: 69fb         	ldr	r3, [r7, #0x1c]
 80066b6: 7e1b         	ldrb	r3, [r3, #0x18]
 80066b8: f083 0301    	eor	r3, r3, #0x1
 80066bc: b2db         	uxtb	r3, r3
 80066be: 2b00         	cmp	r3, #0x0
 80066c0: d002         	beq	0x80066c8 <dma_stm32_irq_handler+0xac> @ imm = #0x4
; 			stream->busy = false;
 80066c2: 69fb         	ldr	r3, [r7, #0x1c]
 80066c4: 2200         	movs	r2, #0x0
 80066c6: 719a         	strb	r2, [r3, #0x6]
; 		if (!stream->hal_override) {
 80066c8: 69fb         	ldr	r3, [r7, #0x1c]
 80066ca: 795b         	ldrb	r3, [r3, #0x5]
 80066cc: f083 0301    	eor	r3, r3, #0x1
 80066d0: b2db         	uxtb	r3, r3
 80066d2: 2b00         	cmp	r3, #0x0
 80066d4: d003         	beq	0x80066de <dma_stm32_irq_handler+0xc2> @ imm = #0x6
; 			dma_stm32_clear_tc(dma, id);
 80066d6: 6839         	ldr	r1, [r7]
 80066d8: 6a38         	ldr	r0, [r7, #0x20]
 80066da: f000 ff73    	bl	0x80075c4 <dma_stm32_clear_tc> @ imm = #0xee6
; 		stream->dma_callback(dev, stream->user_data, callback_arg, DMA_STATUS_COMPLETE);
 80066de: 69fb         	ldr	r3, [r7, #0x1c]
 80066e0: 695c         	ldr	r4, [r3, #0x14]
 80066e2: 69fb         	ldr	r3, [r7, #0x1c]
 80066e4: 6919         	ldr	r1, [r3, #0x10]
 80066e6: 2300         	movs	r3, #0x0
 80066e8: 69ba         	ldr	r2, [r7, #0x18]
 80066ea: 6878         	ldr	r0, [r7, #0x4]
 80066ec: 47a0         	blx	r4
 80066ee: e058         	b	0x80067a2 <dma_stm32_irq_handler+0x186> @ imm = #0xb0
; 	} else if (stm32_dma_is_unexpected_irq_happened(dma, id)) {
 80066f0: 6839         	ldr	r1, [r7]
 80066f2: 6a38         	ldr	r0, [r7, #0x20]
 80066f4: f001 f874    	bl	0x80077e0 <stm32_dma_is_unexpected_irq_happened> @ imm = #0x10e8
 80066f8: 4603         	mov	r3, r0
 80066fa: 2b00         	cmp	r3, #0x0
 80066fc: d023         	beq	0x8006746 <dma_stm32_irq_handler+0x12a> @ imm = #0x46
; 		LOG_ERR("Unexpected irq happened.");
 80066fe: 2303         	movs	r3, #0x3
 8006700: 2b00         	cmp	r3, #0x0
 8006702: d016         	beq	0x8006732 <dma_stm32_irq_handler+0x116> @ imm = #0x2c
 8006704: 2301         	movs	r3, #0x1
 8006706: 73fb         	strb	r3, [r7, #0xf]
 8006708: 7bfb         	ldrb	r3, [r7, #0xf]
 800670a: f083 0301    	eor	r3, r3, #0x1
 800670e: b2db         	uxtb	r3, r3
 8006710: 2b00         	cmp	r3, #0x0
 8006712: d10e         	bne	0x8006732 <dma_stm32_irq_handler+0x116> @ imm = #0x1c
 8006714: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80067a8 <dma_stm32_irq_handler+0x18c>
 8006716: 6819         	ldr	r1, [r3]
 8006718: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80067ac <dma_stm32_irq_handler+0x190>
 800671a: 9302         	str	r3, [sp, #0x8]
 800671c: 2300         	movs	r3, #0x0
 800671e: 9301         	str	r3, [sp, #0x4]
 8006720: 2300         	movs	r3, #0x0
 8006722: 9300         	str	r3, [sp]
 8006724: 2300         	movs	r3, #0x0
 8006726: 2201         	movs	r2, #0x1
 8006728: 2000         	movs	r0, #0x0
 800672a: f00c fa51    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xc4a2
 800672e: 2300         	movs	r3, #0x0
 8006730: 60bb         	str	r3, [r7, #0x8]
; 		stream->dma_callback(dev, stream->user_data,
 8006732: 69fb         	ldr	r3, [r7, #0x1c]
 8006734: 695c         	ldr	r4, [r3, #0x14]
 8006736: 69fb         	ldr	r3, [r7, #0x1c]
 8006738: 6919         	ldr	r1, [r3, #0x10]
 800673a: f06f 0304    	mvn	r3, #0x4
 800673e: 69ba         	ldr	r2, [r7, #0x18]
 8006740: 6878         	ldr	r0, [r7, #0x4]
 8006742: 47a0         	blx	r4
 8006744: e02d         	b	0x80067a2 <dma_stm32_irq_handler+0x186> @ imm = #0x5a
; 		LOG_ERR("Transfer Error.");
 8006746: 2303         	movs	r3, #0x3
 8006748: 2b00         	cmp	r3, #0x0
 800674a: d016         	beq	0x800677a <dma_stm32_irq_handler+0x15e> @ imm = #0x2c
 800674c: 2301         	movs	r3, #0x1
 800674e: 75fb         	strb	r3, [r7, #0x17]
 8006750: 7dfb         	ldrb	r3, [r7, #0x17]
 8006752: f083 0301    	eor	r3, r3, #0x1
 8006756: b2db         	uxtb	r3, r3
 8006758: 2b00         	cmp	r3, #0x0
 800675a: d10e         	bne	0x800677a <dma_stm32_irq_handler+0x15e> @ imm = #0x1c
 800675c: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80067a8 <dma_stm32_irq_handler+0x18c>
 800675e: 6819         	ldr	r1, [r3]
 8006760: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80067b0 <dma_stm32_irq_handler+0x194>
 8006762: 9302         	str	r3, [sp, #0x8]
 8006764: 2300         	movs	r3, #0x0
 8006766: 9301         	str	r3, [sp, #0x4]
 8006768: 2300         	movs	r3, #0x0
 800676a: 9300         	str	r3, [sp]
 800676c: 2300         	movs	r3, #0x0
 800676e: 2201         	movs	r2, #0x1
 8006770: 2000         	movs	r0, #0x0
 8006772: f00c fa2d    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xc45a
 8006776: 2300         	movs	r3, #0x0
 8006778: 613b         	str	r3, [r7, #0x10]
; 		stream->busy = false;
 800677a: 69fb         	ldr	r3, [r7, #0x1c]
 800677c: 2200         	movs	r2, #0x0
 800677e: 719a         	strb	r2, [r3, #0x6]
; 		dma_stm32_dump_stream_irq(dev, id);
 8006780: 6839         	ldr	r1, [r7]
 8006782: 6878         	ldr	r0, [r7, #0x4]
 8006784: f00c fa42    	bl	0x8012c0c <dma_stm32_dump_stream_irq> @ imm = #0xc484
; 		dma_stm32_clear_stream_irq(dev, id);
 8006788: 6839         	ldr	r1, [r7]
 800678a: 6878         	ldr	r0, [r7, #0x4]
 800678c: f00c fa51    	bl	0x8012c32 <dma_stm32_clear_stream_irq> @ imm = #0xc4a2
; 		stream->dma_callback(dev, stream->user_data,
 8006790: 69fb         	ldr	r3, [r7, #0x1c]
 8006792: 695c         	ldr	r4, [r3, #0x14]
 8006794: 69fb         	ldr	r3, [r7, #0x1c]
 8006796: 6919         	ldr	r1, [r3, #0x10]
 8006798: f06f 0304    	mvn	r3, #0x4
 800679c: 69ba         	ldr	r2, [r7, #0x18]
 800679e: 6878         	ldr	r0, [r7, #0x4]
 80067a0: 47a0         	blx	r4
; }
 80067a2: 372c         	adds	r7, #0x2c
 80067a4: 46bd         	mov	sp, r7
 80067a6: bd90         	pop	{r4, r7, pc}

080067a8 <$d>:
 80067a8: 0c 03 00 20  	.word	0x2000030c
 80067ac: ec a4 01 08  	.word	0x0801a4ec
 80067b0: 08 a5 01 08  	.word	0x0801a508

080067b4 <dma_stm32_get_priority>:
; {
 80067b4: b580         	push	{r7, lr}
 80067b6: b088         	sub	sp, #0x20
 80067b8: af04         	add	r7, sp, #0x10
 80067ba: 4603         	mov	r3, r0
 80067bc: 6039         	str	r1, [r7]
 80067be: 71fb         	strb	r3, [r7, #0x7]
; 	switch (priority) {
 80067c0: 79fb         	ldrb	r3, [r7, #0x7]
 80067c2: 2b03         	cmp	r3, #0x3
 80067c4: d81d         	bhi	0x8006802 <dma_stm32_get_priority+0x4e> @ imm = #0x3a
 80067c6: a201         	adr	r2, #4 <dma_stm32_get_priority+0x17>
 80067c8: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

080067cc <$d>:
 80067cc: dd 67 00 08  	.word	0x080067dd
 80067d0: e5 67 00 08  	.word	0x080067e5
 80067d4: ef 67 00 08  	.word	0x080067ef
 80067d8: f9 67 00 08  	.word	0x080067f9

080067dc <$t>:
; 		*ll_priority = LL_DMA_PRIORITY_LOW;
 80067dc: 683b         	ldr	r3, [r7]
 80067de: 2200         	movs	r2, #0x0
 80067e0: 601a         	str	r2, [r3]
; 		break;
 80067e2: e02d         	b	0x8006840 <dma_stm32_get_priority+0x8c> @ imm = #0x5a
; 		*ll_priority = LL_DMA_PRIORITY_MEDIUM;
 80067e4: 683b         	ldr	r3, [r7]
 80067e6: f44f 3280    	mov.w	r2, #0x10000
 80067ea: 601a         	str	r2, [r3]
; 		break;
 80067ec: e028         	b	0x8006840 <dma_stm32_get_priority+0x8c> @ imm = #0x50
; 		*ll_priority = LL_DMA_PRIORITY_HIGH;
 80067ee: 683b         	ldr	r3, [r7]
 80067f0: f44f 3200    	mov.w	r2, #0x20000
 80067f4: 601a         	str	r2, [r3]
; 		break;
 80067f6: e023         	b	0x8006840 <dma_stm32_get_priority+0x8c> @ imm = #0x46
; 		*ll_priority = LL_DMA_PRIORITY_VERYHIGH;
 80067f8: 683b         	ldr	r3, [r7]
 80067fa: f44f 3240    	mov.w	r2, #0x30000
 80067fe: 601a         	str	r2, [r3]
; 		break;
 8006800: e01e         	b	0x8006840 <dma_stm32_get_priority+0x8c> @ imm = #0x3c
; 		LOG_ERR("Priority error. %d", priority);
 8006802: 2303         	movs	r3, #0x3
 8006804: 2b00         	cmp	r3, #0x0
 8006806: d018         	beq	0x800683a <dma_stm32_get_priority+0x86> @ imm = #0x30
 8006808: 2301         	movs	r3, #0x1
 800680a: 73fb         	strb	r3, [r7, #0xf]
 800680c: 7bfb         	ldrb	r3, [r7, #0xf]
 800680e: f083 0301    	eor	r3, r3, #0x1
 8006812: b2db         	uxtb	r3, r3
 8006814: 2b00         	cmp	r3, #0x0
 8006816: d110         	bne	0x800683a <dma_stm32_get_priority+0x86> @ imm = #0x20
 8006818: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800684c <dma_stm32_get_priority+0x98>
 800681a: 6819         	ldr	r1, [r3]
 800681c: 79fb         	ldrb	r3, [r7, #0x7]
 800681e: 9303         	str	r3, [sp, #0xc]
 8006820: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8006850 <dma_stm32_get_priority+0x9c>
 8006822: 9302         	str	r3, [sp, #0x8]
 8006824: 2300         	movs	r3, #0x0
 8006826: 9301         	str	r3, [sp, #0x4]
 8006828: 2300         	movs	r3, #0x0
 800682a: 9300         	str	r3, [sp]
 800682c: 2300         	movs	r3, #0x0
 800682e: 2201         	movs	r2, #0x1
 8006830: 2000         	movs	r0, #0x0
 8006832: f00c f9cd    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xc39a
 8006836: 2300         	movs	r3, #0x0
 8006838: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 800683a: f06f 0315    	mvn	r3, #0x15
 800683e: e000         	b	0x8006842 <dma_stm32_get_priority+0x8e> @ imm = #0x0
; 	return 0;
 8006840: 2300         	movs	r3, #0x0
; }
 8006842: 4618         	mov	r0, r3
 8006844: 3710         	adds	r7, #0x10
 8006846: 46bd         	mov	sp, r7
 8006848: bd80         	pop	{r7, pc}
 800684a: bf00         	nop

0800684c <$d>:
 800684c: 0c 03 00 20  	.word	0x2000030c
 8006850: 18 a5 01 08  	.word	0x0801a518

08006854 <dma_stm32_get_direction>:
; {
 8006854: b580         	push	{r7, lr}
 8006856: b088         	sub	sp, #0x20
 8006858: af04         	add	r7, sp, #0x10
 800685a: 4603         	mov	r3, r0
 800685c: 6039         	str	r1, [r7]
 800685e: 71fb         	strb	r3, [r7, #0x7]
; 	switch (direction) {
 8006860: 79fb         	ldrb	r3, [r7, #0x7]
 8006862: 2b02         	cmp	r3, #0x2
 8006864: d00e         	beq	0x8006884 <dma_stm32_get_direction+0x30> @ imm = #0x1c
 8006866: 2b02         	cmp	r3, #0x2
 8006868: dc10         	bgt	0x800688c <dma_stm32_get_direction+0x38> @ imm = #0x20
 800686a: 2b00         	cmp	r3, #0x0
 800686c: d002         	beq	0x8006874 <dma_stm32_get_direction+0x20> @ imm = #0x4
 800686e: 2b01         	cmp	r3, #0x1
 8006870: d004         	beq	0x800687c <dma_stm32_get_direction+0x28> @ imm = #0x8
 8006872: e00b         	b	0x800688c <dma_stm32_get_direction+0x38> @ imm = #0x16
; 		*ll_direction = LL_DMA_DIRECTION_MEMORY_TO_MEMORY;
 8006874: 683b         	ldr	r3, [r7]
 8006876: 2280         	movs	r2, #0x80
 8006878: 601a         	str	r2, [r3]
; 		break;
 800687a: e026         	b	0x80068ca <dma_stm32_get_direction+0x76> @ imm = #0x4c
; 		*ll_direction = LL_DMA_DIRECTION_MEMORY_TO_PERIPH;
 800687c: 683b         	ldr	r3, [r7]
 800687e: 2240         	movs	r2, #0x40
 8006880: 601a         	str	r2, [r3]
; 		break;
 8006882: e022         	b	0x80068ca <dma_stm32_get_direction+0x76> @ imm = #0x44
; 		*ll_direction = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
 8006884: 683b         	ldr	r3, [r7]
 8006886: 2200         	movs	r2, #0x0
 8006888: 601a         	str	r2, [r3]
; 		break;
 800688a: e01e         	b	0x80068ca <dma_stm32_get_direction+0x76> @ imm = #0x3c
; 		LOG_ERR("Direction error. %d", direction);
 800688c: 2303         	movs	r3, #0x3
 800688e: 2b00         	cmp	r3, #0x0
 8006890: d018         	beq	0x80068c4 <dma_stm32_get_direction+0x70> @ imm = #0x30
 8006892: 2301         	movs	r3, #0x1
 8006894: 73fb         	strb	r3, [r7, #0xf]
 8006896: 7bfb         	ldrb	r3, [r7, #0xf]
 8006898: f083 0301    	eor	r3, r3, #0x1
 800689c: b2db         	uxtb	r3, r3
 800689e: 2b00         	cmp	r3, #0x0
 80068a0: d110         	bne	0x80068c4 <dma_stm32_get_direction+0x70> @ imm = #0x20
 80068a2: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80068d4 <dma_stm32_get_direction+0x80>
 80068a4: 6819         	ldr	r1, [r3]
 80068a6: 79fb         	ldrb	r3, [r7, #0x7]
 80068a8: 9303         	str	r3, [sp, #0xc]
 80068aa: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80068d8 <dma_stm32_get_direction+0x84>
 80068ac: 9302         	str	r3, [sp, #0x8]
 80068ae: 2300         	movs	r3, #0x0
 80068b0: 9301         	str	r3, [sp, #0x4]
 80068b2: 2300         	movs	r3, #0x0
 80068b4: 9300         	str	r3, [sp]
 80068b6: 2300         	movs	r3, #0x0
 80068b8: 2201         	movs	r2, #0x1
 80068ba: 2000         	movs	r0, #0x0
 80068bc: f00c f988    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xc310
 80068c0: 2300         	movs	r3, #0x0
 80068c2: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 80068c4: f06f 0315    	mvn	r3, #0x15
 80068c8: e000         	b	0x80068cc <dma_stm32_get_direction+0x78> @ imm = #0x0
; 	return 0;
 80068ca: 2300         	movs	r3, #0x0
; }
 80068cc: 4618         	mov	r0, r3
 80068ce: 3710         	adds	r7, #0x10
 80068d0: 46bd         	mov	sp, r7
 80068d2: bd80         	pop	{r7, pc}

080068d4 <$d>:
 80068d4: 0c 03 00 20  	.word	0x2000030c
 80068d8: 2c a5 01 08  	.word	0x0801a52c

080068dc <dma_stm32_get_memory_increment>:
; {
 80068dc: b580         	push	{r7, lr}
 80068de: b088         	sub	sp, #0x20
 80068e0: af04         	add	r7, sp, #0x10
 80068e2: 4603         	mov	r3, r0
 80068e4: 6039         	str	r1, [r7]
 80068e6: 71fb         	strb	r3, [r7, #0x7]
; 	switch (increment) {
 80068e8: 79fb         	ldrb	r3, [r7, #0x7]
 80068ea: 2b02         	cmp	r3, #0x2
 80068ec: d00b         	beq	0x8006906 <dma_stm32_get_memory_increment+0x2a> @ imm = #0x16
 80068ee: 2b02         	cmp	r3, #0x2
 80068f0: dc10         	bgt	0x8006914 <dma_stm32_get_memory_increment+0x38> @ imm = #0x20
 80068f2: 2b00         	cmp	r3, #0x0
 80068f4: d002         	beq	0x80068fc <dma_stm32_get_memory_increment+0x20> @ imm = #0x4
 80068f6: 2b01         	cmp	r3, #0x1
 80068f8: d009         	beq	0x800690e <dma_stm32_get_memory_increment+0x32> @ imm = #0x12
 80068fa: e00b         	b	0x8006914 <dma_stm32_get_memory_increment+0x38> @ imm = #0x16
; 		*ll_increment = LL_DMA_MEMORY_INCREMENT;
 80068fc: 683b         	ldr	r3, [r7]
 80068fe: f44f 6280    	mov.w	r2, #0x400
 8006902: 601a         	str	r2, [r3]
; 		break;
 8006904: e025         	b	0x8006952 <dma_stm32_get_memory_increment+0x76> @ imm = #0x4a
; 		*ll_increment = LL_DMA_MEMORY_NOINCREMENT;
 8006906: 683b         	ldr	r3, [r7]
 8006908: 2200         	movs	r2, #0x0
 800690a: 601a         	str	r2, [r3]
; 		break;
 800690c: e021         	b	0x8006952 <dma_stm32_get_memory_increment+0x76> @ imm = #0x42
; 		return -ENOTSUP;
 800690e: f06f 0385    	mvn	r3, #0x85
 8006912: e01f         	b	0x8006954 <dma_stm32_get_memory_increment+0x78> @ imm = #0x3e
; 		LOG_ERR("Memory increment error. %d", increment);
 8006914: 2303         	movs	r3, #0x3
 8006916: 2b00         	cmp	r3, #0x0
 8006918: d018         	beq	0x800694c <dma_stm32_get_memory_increment+0x70> @ imm = #0x30
 800691a: 2301         	movs	r3, #0x1
 800691c: 73fb         	strb	r3, [r7, #0xf]
 800691e: 7bfb         	ldrb	r3, [r7, #0xf]
 8006920: f083 0301    	eor	r3, r3, #0x1
 8006924: b2db         	uxtb	r3, r3
 8006926: 2b00         	cmp	r3, #0x0
 8006928: d110         	bne	0x800694c <dma_stm32_get_memory_increment+0x70> @ imm = #0x20
 800692a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800695c <dma_stm32_get_memory_increment+0x80>
 800692c: 6819         	ldr	r1, [r3]
 800692e: 79fb         	ldrb	r3, [r7, #0x7]
 8006930: 9303         	str	r3, [sp, #0xc]
 8006932: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8006960 <dma_stm32_get_memory_increment+0x84>
 8006934: 9302         	str	r3, [sp, #0x8]
 8006936: 2300         	movs	r3, #0x0
 8006938: 9301         	str	r3, [sp, #0x4]
 800693a: 2300         	movs	r3, #0x0
 800693c: 9300         	str	r3, [sp]
 800693e: 2300         	movs	r3, #0x0
 8006940: 2201         	movs	r2, #0x1
 8006942: 2000         	movs	r0, #0x0
 8006944: f00c f944    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xc288
 8006948: 2300         	movs	r3, #0x0
 800694a: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 800694c: f06f 0315    	mvn	r3, #0x15
 8006950: e000         	b	0x8006954 <dma_stm32_get_memory_increment+0x78> @ imm = #0x0
; 	return 0;
 8006952: 2300         	movs	r3, #0x0
; }
 8006954: 4618         	mov	r0, r3
 8006956: 3710         	adds	r7, #0x10
 8006958: 46bd         	mov	sp, r7
 800695a: bd80         	pop	{r7, pc}

0800695c <$d>:
 800695c: 0c 03 00 20  	.word	0x2000030c
 8006960: 40 a5 01 08  	.word	0x0801a540

08006964 <dma_stm32_get_periph_increment>:
; {
 8006964: b580         	push	{r7, lr}
 8006966: b088         	sub	sp, #0x20
 8006968: af04         	add	r7, sp, #0x10
 800696a: 4603         	mov	r3, r0
 800696c: 6039         	str	r1, [r7]
 800696e: 71fb         	strb	r3, [r7, #0x7]
; 	switch (increment) {
 8006970: 79fb         	ldrb	r3, [r7, #0x7]
 8006972: 2b02         	cmp	r3, #0x2
 8006974: d00b         	beq	0x800698e <dma_stm32_get_periph_increment+0x2a> @ imm = #0x16
 8006976: 2b02         	cmp	r3, #0x2
 8006978: dc10         	bgt	0x800699c <dma_stm32_get_periph_increment+0x38> @ imm = #0x20
 800697a: 2b00         	cmp	r3, #0x0
 800697c: d002         	beq	0x8006984 <dma_stm32_get_periph_increment+0x20> @ imm = #0x4
 800697e: 2b01         	cmp	r3, #0x1
 8006980: d009         	beq	0x8006996 <dma_stm32_get_periph_increment+0x32> @ imm = #0x12
 8006982: e00b         	b	0x800699c <dma_stm32_get_periph_increment+0x38> @ imm = #0x16
; 		*ll_increment = LL_DMA_PERIPH_INCREMENT;
 8006984: 683b         	ldr	r3, [r7]
 8006986: f44f 7200    	mov.w	r2, #0x200
 800698a: 601a         	str	r2, [r3]
; 		break;
 800698c: e025         	b	0x80069da <dma_stm32_get_periph_increment+0x76> @ imm = #0x4a
; 		*ll_increment = LL_DMA_PERIPH_NOINCREMENT;
 800698e: 683b         	ldr	r3, [r7]
 8006990: 2200         	movs	r2, #0x0
 8006992: 601a         	str	r2, [r3]
; 		break;
 8006994: e021         	b	0x80069da <dma_stm32_get_periph_increment+0x76> @ imm = #0x42
; 		return -ENOTSUP;
 8006996: f06f 0385    	mvn	r3, #0x85
 800699a: e01f         	b	0x80069dc <dma_stm32_get_periph_increment+0x78> @ imm = #0x3e
; 		LOG_ERR("Periph increment error. %d", increment);
 800699c: 2303         	movs	r3, #0x3
 800699e: 2b00         	cmp	r3, #0x0
 80069a0: d018         	beq	0x80069d4 <dma_stm32_get_periph_increment+0x70> @ imm = #0x30
 80069a2: 2301         	movs	r3, #0x1
 80069a4: 73fb         	strb	r3, [r7, #0xf]
 80069a6: 7bfb         	ldrb	r3, [r7, #0xf]
 80069a8: f083 0301    	eor	r3, r3, #0x1
 80069ac: b2db         	uxtb	r3, r3
 80069ae: 2b00         	cmp	r3, #0x0
 80069b0: d110         	bne	0x80069d4 <dma_stm32_get_periph_increment+0x70> @ imm = #0x20
 80069b2: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80069e4 <dma_stm32_get_periph_increment+0x80>
 80069b4: 6819         	ldr	r1, [r3]
 80069b6: 79fb         	ldrb	r3, [r7, #0x7]
 80069b8: 9303         	str	r3, [sp, #0xc]
 80069ba: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80069e8 <dma_stm32_get_periph_increment+0x84>
 80069bc: 9302         	str	r3, [sp, #0x8]
 80069be: 2300         	movs	r3, #0x0
 80069c0: 9301         	str	r3, [sp, #0x4]
 80069c2: 2300         	movs	r3, #0x0
 80069c4: 9300         	str	r3, [sp]
 80069c6: 2300         	movs	r3, #0x0
 80069c8: 2201         	movs	r2, #0x1
 80069ca: 2000         	movs	r0, #0x0
 80069cc: f00c f900    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xc200
 80069d0: 2300         	movs	r3, #0x0
 80069d2: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 80069d4: f06f 0315    	mvn	r3, #0x15
 80069d8: e000         	b	0x80069dc <dma_stm32_get_periph_increment+0x78> @ imm = #0x0
; 	return 0;
 80069da: 2300         	movs	r3, #0x0
; }
 80069dc: 4618         	mov	r0, r3
 80069de: 3710         	adds	r7, #0x10
 80069e0: 46bd         	mov	sp, r7
 80069e2: bd80         	pop	{r7, pc}

080069e4 <$d>:
 80069e4: 0c 03 00 20  	.word	0x2000030c
 80069e8: 5c a5 01 08  	.word	0x0801a55c

080069ec <dma_stm32_configure>:
; {
 80069ec: b580         	push	{r7, lr}
 80069ee: b0be         	sub	sp, #0xf8
 80069f0: af06         	add	r7, sp, #0x18
 80069f2: 60f8         	str	r0, [r7, #0xc]
 80069f4: 60b9         	str	r1, [r7, #0x8]
 80069f6: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_stm32_config *dev_config = dev->config;
 80069f8: 68fb         	ldr	r3, [r7, #0xc]
 80069fa: 685b         	ldr	r3, [r3, #0x4]
 80069fc: f8c7 30c8    	str.w	r3, [r7, #0xc8]
; 				&dev_config->streams[id - STM32_DMA_STREAM_OFFSET];
 8006a00: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8006a04: 6999         	ldr	r1, [r3, #0x18]
 8006a06: 68ba         	ldr	r2, [r7, #0x8]
 8006a08: 4613         	mov	r3, r2
 8006a0a: 00db         	lsls	r3, r3, #0x3
 8006a0c: 1a9b         	subs	r3, r3, r2
 8006a0e: 009b         	lsls	r3, r3, #0x2
; 	struct dma_stm32_stream *stream =
 8006a10: 440b         	add	r3, r1
 8006a12: f8c7 30d0    	str.w	r3, [r7, #0xd0]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)dev_config->base;
 8006a16: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8006a1a: 691b         	ldr	r3, [r3, #0x10]
 8006a1c: f8c7 30cc    	str.w	r3, [r7, #0xcc]
; 	LL_DMA_StructInit(&DMA_InitStruct);
 8006a20: f107 0310    	add.w	r3, r7, #0x10
 8006a24: 4618         	mov	r0, r3
 8006a26: f010 f999    	bl	0x8016d5c <LL_DMA_StructInit> @ imm = #0x10332
; 	if (id >= dev_config->max_streams) {
 8006a2a: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8006a2e: 695b         	ldr	r3, [r3, #0x14]
 8006a30: 68ba         	ldr	r2, [r7, #0x8]
 8006a32: 429a         	cmp	r2, r3
 8006a34: d321         	blo	0x8006a7a <dma_stm32_configure+0x8e> @ imm = #0x42
; 		LOG_ERR("cannot configure the dma stream %d.", id);
 8006a36: 2303         	movs	r3, #0x3
 8006a38: 2b00         	cmp	r3, #0x0
 8006a3a: d01a         	beq	0x8006a72 <dma_stm32_configure+0x86> @ imm = #0x34
 8006a3c: 2301         	movs	r3, #0x1
 8006a3e: f887 305b    	strb.w	r3, [r7, #0x5b]
 8006a42: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8006a46: f083 0301    	eor	r3, r3, #0x1
 8006a4a: b2db         	uxtb	r3, r3
 8006a4c: 2b00         	cmp	r3, #0x0
 8006a4e: d110         	bne	0x8006a72 <dma_stm32_configure+0x86> @ imm = #0x20
 8006a50: 4b9b         	ldr	r3, [pc, #0x26c]        @ 0x8006cc0 <dma_stm32_configure+0x2d4>
 8006a52: 6819         	ldr	r1, [r3]
 8006a54: 68bb         	ldr	r3, [r7, #0x8]
 8006a56: 9303         	str	r3, [sp, #0xc]
 8006a58: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x8006cc4 <dma_stm32_configure+0x2d8>
 8006a5a: 9302         	str	r3, [sp, #0x8]
 8006a5c: 2300         	movs	r3, #0x0
 8006a5e: 9301         	str	r3, [sp, #0x4]
 8006a60: 2300         	movs	r3, #0x0
 8006a62: 9300         	str	r3, [sp]
 8006a64: 2300         	movs	r3, #0x0
 8006a66: 2201         	movs	r2, #0x1
 8006a68: 2000         	movs	r0, #0x0
 8006a6a: f00c f8b1    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xc162
 8006a6e: 2300         	movs	r3, #0x0
 8006a70: 657b         	str	r3, [r7, #0x54]
; 		return -EINVAL;
 8006a72: f06f 0315    	mvn	r3, #0x15
 8006a76: f000 bc1f    	b.w	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x83e
; 	if (stream->busy) {
 8006a7a: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006a7e: 799b         	ldrb	r3, [r3, #0x6]
 8006a80: b2db         	uxtb	r3, r3
 8006a82: 2b00         	cmp	r3, #0x0
 8006a84: d020         	beq	0x8006ac8 <dma_stm32_configure+0xdc> @ imm = #0x40
; 		LOG_ERR("dma stream %d is busy.", id);
 8006a86: 2303         	movs	r3, #0x3
 8006a88: 2b00         	cmp	r3, #0x0
 8006a8a: d01a         	beq	0x8006ac2 <dma_stm32_configure+0xd6> @ imm = #0x34
 8006a8c: 2301         	movs	r3, #0x1
 8006a8e: f887 3063    	strb.w	r3, [r7, #0x63]
 8006a92: f897 3063    	ldrb.w	r3, [r7, #0x63]
 8006a96: f083 0301    	eor	r3, r3, #0x1
 8006a9a: b2db         	uxtb	r3, r3
 8006a9c: 2b00         	cmp	r3, #0x0
 8006a9e: d110         	bne	0x8006ac2 <dma_stm32_configure+0xd6> @ imm = #0x20
 8006aa0: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8006cc0 <dma_stm32_configure+0x2d4>
 8006aa2: 6819         	ldr	r1, [r3]
 8006aa4: 68bb         	ldr	r3, [r7, #0x8]
 8006aa6: 9303         	str	r3, [sp, #0xc]
 8006aa8: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8006cc8 <dma_stm32_configure+0x2dc>
 8006aaa: 9302         	str	r3, [sp, #0x8]
 8006aac: 2300         	movs	r3, #0x0
 8006aae: 9301         	str	r3, [sp, #0x4]
 8006ab0: 2300         	movs	r3, #0x0
 8006ab2: 9300         	str	r3, [sp]
 8006ab4: 2300         	movs	r3, #0x0
 8006ab6: 2201         	movs	r2, #0x1
 8006ab8: 2000         	movs	r0, #0x0
 8006aba: f00c f889    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xc112
 8006abe: 2300         	movs	r3, #0x0
 8006ac0: 65fb         	str	r3, [r7, #0x5c]
; 		return -EBUSY;
 8006ac2: f06f 030f    	mvn	r3, #0xf
 8006ac6: e3f7         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x7ee
; 	if (dma_stm32_disable_stream(dma, id) != 0) {
 8006ac8: 68b9         	ldr	r1, [r7, #0x8]
 8006aca: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8006ace: f00c f8cb    	bl	0x8012c68 <dma_stm32_disable_stream> @ imm = #0xc196
 8006ad2: 4603         	mov	r3, r0
 8006ad4: 2b00         	cmp	r3, #0x0
 8006ad6: d020         	beq	0x8006b1a <dma_stm32_configure+0x12e> @ imm = #0x40
; 		LOG_ERR("could not disable dma stream %d.", id);
 8006ad8: 2303         	movs	r3, #0x3
 8006ada: 2b00         	cmp	r3, #0x0
 8006adc: d01a         	beq	0x8006b14 <dma_stm32_configure+0x128> @ imm = #0x34
 8006ade: 2301         	movs	r3, #0x1
 8006ae0: f887 306b    	strb.w	r3, [r7, #0x6b]
 8006ae4: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 8006ae8: f083 0301    	eor	r3, r3, #0x1
 8006aec: b2db         	uxtb	r3, r3
 8006aee: 2b00         	cmp	r3, #0x0
 8006af0: d110         	bne	0x8006b14 <dma_stm32_configure+0x128> @ imm = #0x20
 8006af2: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8006cc0 <dma_stm32_configure+0x2d4>
 8006af4: 6819         	ldr	r1, [r3]
 8006af6: 68bb         	ldr	r3, [r7, #0x8]
 8006af8: 9303         	str	r3, [sp, #0xc]
 8006afa: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8006ccc <dma_stm32_configure+0x2e0>
 8006afc: 9302         	str	r3, [sp, #0x8]
 8006afe: 2300         	movs	r3, #0x0
 8006b00: 9301         	str	r3, [sp, #0x4]
 8006b02: 2300         	movs	r3, #0x0
 8006b04: 9300         	str	r3, [sp]
 8006b06: 2300         	movs	r3, #0x0
 8006b08: 2201         	movs	r2, #0x1
 8006b0a: 2000         	movs	r0, #0x0
 8006b0c: f00c f860    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xc0c0
 8006b10: 2300         	movs	r3, #0x0
 8006b12: 667b         	str	r3, [r7, #0x64]
; 		return -EBUSY;
 8006b14: f06f 030f    	mvn	r3, #0xf
 8006b18: e3ce         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x79c
; 	dma_stm32_clear_stream_irq(dev, id);
 8006b1a: 68b9         	ldr	r1, [r7, #0x8]
 8006b1c: 68f8         	ldr	r0, [r7, #0xc]
 8006b1e: f00c f888    	bl	0x8012c32 <dma_stm32_clear_stream_irq> @ imm = #0xc110
; 	if (config->linked_channel == STM32_DMA_HAL_OVERRIDE) {
 8006b22: 687b         	ldr	r3, [r7, #0x4]
 8006b24: 885b         	ldrh	r3, [r3, #0x2]
 8006b26: f403 637e    	and	r3, r3, #0xfe0
 8006b2a: b29b         	uxth	r3, r3
 8006b2c: f5b3 6f7e    	cmp.w	r3, #0xfe0
 8006b30: d117         	bne	0x8006b62 <dma_stm32_configure+0x176> @ imm = #0x2e
; 		stream->busy = true;
 8006b32: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006b36: 2201         	movs	r2, #0x1
 8006b38: 719a         	strb	r2, [r3, #0x6]
; 		stream->hal_override = true;
 8006b3a: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006b3e: 2201         	movs	r2, #0x1
 8006b40: 715a         	strb	r2, [r3, #0x5]
; 		stream->dma_callback = config->dma_callback;
 8006b42: 687b         	ldr	r3, [r7, #0x4]
 8006b44: 699a         	ldr	r2, [r3, #0x18]
 8006b46: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006b4a: 615a         	str	r2, [r3, #0x14]
; 		stream->user_data = config->user_data;
 8006b4c: 687b         	ldr	r3, [r7, #0x4]
 8006b4e: 695a         	ldr	r2, [r3, #0x14]
 8006b50: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006b54: 611a         	str	r2, [r3, #0x10]
; 		stream->cyclic = false;
 8006b56: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006b5a: 2200         	movs	r2, #0x0
 8006b5c: 761a         	strb	r2, [r3, #0x18]
; 		return 0;
 8006b5e: 2300         	movs	r3, #0x0
 8006b60: e3aa         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x754
; 	if (config->head_block->block_size > DMA_STM32_MAX_DATA_ITEMS) {
 8006b62: 687b         	ldr	r3, [r7, #0x4]
 8006b64: 691b         	ldr	r3, [r3, #0x10]
 8006b66: 695b         	ldr	r3, [r3, #0x14]
 8006b68: f5b3 3f80    	cmp.w	r3, #0x10000
 8006b6c: d322         	blo	0x8006bb4 <dma_stm32_configure+0x1c8> @ imm = #0x44
; 		LOG_ERR("Data size too big: %d\n",
 8006b6e: 2303         	movs	r3, #0x3
 8006b70: 2b00         	cmp	r3, #0x0
 8006b72: d01c         	beq	0x8006bae <dma_stm32_configure+0x1c2> @ imm = #0x38
 8006b74: 2301         	movs	r3, #0x1
 8006b76: f887 3073    	strb.w	r3, [r7, #0x73]
 8006b7a: f897 3073    	ldrb.w	r3, [r7, #0x73]
 8006b7e: f083 0301    	eor	r3, r3, #0x1
 8006b82: b2db         	uxtb	r3, r3
 8006b84: 2b00         	cmp	r3, #0x0
 8006b86: d112         	bne	0x8006bae <dma_stm32_configure+0x1c2> @ imm = #0x24
 8006b88: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x8006cc0 <dma_stm32_configure+0x2d4>
 8006b8a: 6819         	ldr	r1, [r3]
 8006b8c: 687b         	ldr	r3, [r7, #0x4]
 8006b8e: 691b         	ldr	r3, [r3, #0x10]
 8006b90: 695b         	ldr	r3, [r3, #0x14]
 8006b92: 9303         	str	r3, [sp, #0xc]
 8006b94: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8006cd0 <dma_stm32_configure+0x2e4>
 8006b96: 9302         	str	r3, [sp, #0x8]
 8006b98: 2300         	movs	r3, #0x0
 8006b9a: 9301         	str	r3, [sp, #0x4]
 8006b9c: 2300         	movs	r3, #0x0
 8006b9e: 9300         	str	r3, [sp]
 8006ba0: 2300         	movs	r3, #0x0
 8006ba2: 2201         	movs	r2, #0x1
 8006ba4: 2000         	movs	r0, #0x0
 8006ba6: f00c f813    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xc026
 8006baa: 2300         	movs	r3, #0x0
 8006bac: 66fb         	str	r3, [r7, #0x6c]
; 		return -EINVAL;
 8006bae: f06f 0315    	mvn	r3, #0x15
 8006bb2: e381         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x702
; 	if ((config->channel_direction == MEMORY_TO_MEMORY) &&
 8006bb4: 687b         	ldr	r3, [r7, #0x4]
 8006bb6: 785b         	ldrb	r3, [r3, #0x1]
 8006bb8: f003 0307    	and	r3, r3, #0x7
 8006bbc: b2db         	uxtb	r3, r3
 8006bbe: 2b00         	cmp	r3, #0x0
 8006bc0: d12a         	bne	0x8006c18 <dma_stm32_configure+0x22c> @ imm = #0x54
; 		(!dev_config->support_m2m)) {
 8006bc2: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8006bc6: 7b1b         	ldrb	r3, [r3, #0xc]
 8006bc8: f083 0301    	eor	r3, r3, #0x1
 8006bcc: b2db         	uxtb	r3, r3
; 	if ((config->channel_direction == MEMORY_TO_MEMORY) &&
 8006bce: 2b00         	cmp	r3, #0x0
 8006bd0: d022         	beq	0x8006c18 <dma_stm32_configure+0x22c> @ imm = #0x44
; 		LOG_ERR("Memcopy not supported for device %s",
 8006bd2: 2303         	movs	r3, #0x3
 8006bd4: 2b00         	cmp	r3, #0x0
 8006bd6: d01c         	beq	0x8006c12 <dma_stm32_configure+0x226> @ imm = #0x38
 8006bd8: 2301         	movs	r3, #0x1
 8006bda: f887 30d6    	strb.w	r3, [r7, #0xd6]
 8006bde: f897 30d6    	ldrb.w	r3, [r7, #0xd6]
 8006be2: f083 0301    	eor	r3, r3, #0x1
 8006be6: b2db         	uxtb	r3, r3
 8006be8: 2b00         	cmp	r3, #0x0
 8006bea: d112         	bne	0x8006c12 <dma_stm32_configure+0x226> @ imm = #0x24
 8006bec: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8006cc0 <dma_stm32_configure+0x2d4>
 8006bee: 6819         	ldr	r1, [r3]
 8006bf0: 68fb         	ldr	r3, [r7, #0xc]
 8006bf2: 681b         	ldr	r3, [r3]
 8006bf4: 9303         	str	r3, [sp, #0xc]
 8006bf6: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8006cd4 <dma_stm32_configure+0x2e8>
 8006bf8: 9302         	str	r3, [sp, #0x8]
 8006bfa: 2300         	movs	r3, #0x0
 8006bfc: 9301         	str	r3, [sp, #0x4]
 8006bfe: 2300         	movs	r3, #0x0
 8006c00: 9300         	str	r3, [sp]
 8006c02: 2300         	movs	r3, #0x0
 8006c04: 2201         	movs	r2, #0x1
 8006c06: 2000         	movs	r0, #0x0
 8006c08: f00b ffe2    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xbfc4
 8006c0c: 2300         	movs	r3, #0x0
 8006c0e: f8c7 30d8    	str.w	r3, [r7, #0xd8]
; 		return -ENOTSUP;
 8006c12: f06f 0385    	mvn	r3, #0x85
 8006c16: e34f         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x69e
; 	if ((config->dest_data_size != config->source_data_size)) {
 8006c18: 687b         	ldr	r3, [r7, #0x4]
 8006c1a: 88da         	ldrh	r2, [r3, #0x6]
 8006c1c: 687b         	ldr	r3, [r7, #0x4]
 8006c1e: 889b         	ldrh	r3, [r3, #0x4]
 8006c20: 429a         	cmp	r2, r3
 8006c22: d01e         	beq	0x8006c62 <dma_stm32_configure+0x276> @ imm = #0x3c
; 		LOG_ERR("source and dest data size differ.");
 8006c24: 2303         	movs	r3, #0x3
 8006c26: 2b00         	cmp	r3, #0x0
 8006c28: d018         	beq	0x8006c5c <dma_stm32_configure+0x270> @ imm = #0x30
 8006c2a: 2301         	movs	r3, #0x1
 8006c2c: f887 307b    	strb.w	r3, [r7, #0x7b]
 8006c30: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 8006c34: f083 0301    	eor	r3, r3, #0x1
 8006c38: b2db         	uxtb	r3, r3
 8006c3a: 2b00         	cmp	r3, #0x0
 8006c3c: d10e         	bne	0x8006c5c <dma_stm32_configure+0x270> @ imm = #0x1c
 8006c3e: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8006cc0 <dma_stm32_configure+0x2d4>
 8006c40: 6819         	ldr	r1, [r3]
 8006c42: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8006cd8 <dma_stm32_configure+0x2ec>
 8006c44: 9302         	str	r3, [sp, #0x8]
 8006c46: 2300         	movs	r3, #0x0
 8006c48: 9301         	str	r3, [sp, #0x4]
 8006c4a: 2300         	movs	r3, #0x0
 8006c4c: 9300         	str	r3, [sp]
 8006c4e: 2300         	movs	r3, #0x0
 8006c50: 2201         	movs	r2, #0x1
 8006c52: 2000         	movs	r0, #0x0
 8006c54: f00b ffbc    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xbf78
 8006c58: 2300         	movs	r3, #0x0
 8006c5a: 677b         	str	r3, [r7, #0x74]
; 		return -EINVAL;
 8006c5c: f06f 0315    	mvn	r3, #0x15
 8006c60: e32a         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x654
; 	if (config->source_data_size != 4U &&
 8006c62: 687b         	ldr	r3, [r7, #0x4]
 8006c64: 889b         	ldrh	r3, [r3, #0x4]
 8006c66: 2b04         	cmp	r3, #0x4
 8006c68: d03a         	beq	0x8006ce0 <dma_stm32_configure+0x2f4> @ imm = #0x74
; 	    config->source_data_size != 2U &&
 8006c6a: 687b         	ldr	r3, [r7, #0x4]
 8006c6c: 889b         	ldrh	r3, [r3, #0x4]
; 	if (config->source_data_size != 4U &&
 8006c6e: 2b02         	cmp	r3, #0x2
 8006c70: d036         	beq	0x8006ce0 <dma_stm32_configure+0x2f4> @ imm = #0x6c
; 	    config->source_data_size != 1U) {
 8006c72: 687b         	ldr	r3, [r7, #0x4]
 8006c74: 889b         	ldrh	r3, [r3, #0x4]
; 	    config->source_data_size != 2U &&
 8006c76: 2b01         	cmp	r3, #0x1
 8006c78: d032         	beq	0x8006ce0 <dma_stm32_configure+0x2f4> @ imm = #0x64
; 		LOG_ERR("source and dest unit size error, %d",
 8006c7a: 2303         	movs	r3, #0x3
 8006c7c: 2b00         	cmp	r3, #0x0
 8006c7e: d01c         	beq	0x8006cba <dma_stm32_configure+0x2ce> @ imm = #0x38
 8006c80: 2301         	movs	r3, #0x1
 8006c82: f887 30d7    	strb.w	r3, [r7, #0xd7]
 8006c86: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 8006c8a: f083 0301    	eor	r3, r3, #0x1
 8006c8e: b2db         	uxtb	r3, r3
 8006c90: 2b00         	cmp	r3, #0x0
 8006c92: d112         	bne	0x8006cba <dma_stm32_configure+0x2ce> @ imm = #0x24
 8006c94: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8006cc0 <dma_stm32_configure+0x2d4>
 8006c96: 6819         	ldr	r1, [r3]
 8006c98: 687b         	ldr	r3, [r7, #0x4]
 8006c9a: 889b         	ldrh	r3, [r3, #0x4]
 8006c9c: 9303         	str	r3, [sp, #0xc]
 8006c9e: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8006cdc <dma_stm32_configure+0x2f0>
 8006ca0: 9302         	str	r3, [sp, #0x8]
 8006ca2: 2300         	movs	r3, #0x0
 8006ca4: 9301         	str	r3, [sp, #0x4]
 8006ca6: 2300         	movs	r3, #0x0
 8006ca8: 9300         	str	r3, [sp]
 8006caa: 2300         	movs	r3, #0x0
 8006cac: 2201         	movs	r2, #0x1
 8006cae: 2000         	movs	r0, #0x0
 8006cb0: f00b ff8e    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xbf1c
 8006cb4: 2300         	movs	r3, #0x0
 8006cb6: f8c7 30dc    	str.w	r3, [r7, #0xdc]
; 		return -EINVAL;
 8006cba: f06f 0315    	mvn	r3, #0x15
 8006cbe: e2fb         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x5f6

08006cc0 <$d>:
 8006cc0: 0c 03 00 20  	.word	0x2000030c
 8006cc4: 78 a5 01 08  	.word	0x0801a578
 8006cc8: 9c a5 01 08  	.word	0x0801a59c
 8006ccc: b4 a5 01 08  	.word	0x0801a5b4
 8006cd0: d8 a5 01 08  	.word	0x0801a5d8
 8006cd4: f0 a5 01 08  	.word	0x0801a5f0
 8006cd8: 14 a6 01 08  	.word	0x0801a614
 8006cdc: 38 a6 01 08  	.word	0x0801a638

08006ce0 <$t>:
; 	if (config->head_block->source_reload_en !=
 8006ce0: 687b         	ldr	r3, [r7, #0x4]
 8006ce2: 691b         	ldr	r3, [r3, #0x10]
 8006ce4: 7f1b         	ldrb	r3, [r3, #0x1c]
 8006ce6: f3c3 1380    	ubfx	r3, r3, #0x6, #0x1
 8006cea: b2da         	uxtb	r2, r3
; 		config->head_block->dest_reload_en) {
 8006cec: 687b         	ldr	r3, [r7, #0x4]
 8006cee: 691b         	ldr	r3, [r3, #0x10]
 8006cf0: 7f1b         	ldrb	r3, [r3, #0x1c]
 8006cf2: f3c3 13c0    	ubfx	r3, r3, #0x7, #0x1
 8006cf6: b2db         	uxtb	r3, r3
; 	if (config->head_block->source_reload_en !=
 8006cf8: 429a         	cmp	r2, r3
 8006cfa: d01e         	beq	0x8006d3a <dma_stm32_configure+0x34e> @ imm = #0x3c
; 		LOG_ERR("source_reload_en and dest_reload_en must "
 8006cfc: 2303         	movs	r3, #0x3
 8006cfe: 2b00         	cmp	r3, #0x0
 8006d00: d018         	beq	0x8006d34 <dma_stm32_configure+0x348> @ imm = #0x30
 8006d02: 2301         	movs	r3, #0x1
 8006d04: f887 3083    	strb.w	r3, [r7, #0x83]
 8006d08: f897 3083    	ldrb.w	r3, [r7, #0x83]
 8006d0c: f083 0301    	eor	r3, r3, #0x1
 8006d10: b2db         	uxtb	r3, r3
 8006d12: 2b00         	cmp	r3, #0x0
 8006d14: d10e         	bne	0x8006d34 <dma_stm32_configure+0x348> @ imm = #0x1c
 8006d16: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8006f88 <dma_stm32_configure+0x59c>
 8006d18: 6819         	ldr	r1, [r3]
 8006d1a: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8006f8c <dma_stm32_configure+0x5a0>
 8006d1c: 9302         	str	r3, [sp, #0x8]
 8006d1e: 2300         	movs	r3, #0x0
 8006d20: 9301         	str	r3, [sp, #0x4]
 8006d22: 2300         	movs	r3, #0x0
 8006d24: 9300         	str	r3, [sp]
 8006d26: 2300         	movs	r3, #0x0
 8006d28: 2201         	movs	r2, #0x1
 8006d2a: 2000         	movs	r0, #0x0
 8006d2c: f00b ff50    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xbea0
 8006d30: 2300         	movs	r3, #0x0
 8006d32: 67fb         	str	r3, [r7, #0x7c]
; 		return -EINVAL;
 8006d34: f06f 0315    	mvn	r3, #0x15
 8006d38: e2be         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x57c
; 	stream->busy		= true;
 8006d3a: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006d3e: 2201         	movs	r2, #0x1
 8006d40: 719a         	strb	r2, [r3, #0x6]
; 	stream->dma_callback	= config->dma_callback;
 8006d42: 687b         	ldr	r3, [r7, #0x4]
 8006d44: 699a         	ldr	r2, [r3, #0x18]
 8006d46: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006d4a: 615a         	str	r2, [r3, #0x14]
; 	stream->direction	= config->channel_direction;
 8006d4c: 687b         	ldr	r3, [r7, #0x4]
 8006d4e: 785b         	ldrb	r3, [r3, #0x1]
 8006d50: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 8006d54: b2db         	uxtb	r3, r3
 8006d56: 461a         	mov	r2, r3
 8006d58: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006d5c: 601a         	str	r2, [r3]
; 	stream->user_data       = config->user_data;
 8006d5e: 687b         	ldr	r3, [r7, #0x4]
 8006d60: 695a         	ldr	r2, [r3, #0x14]
 8006d62: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006d66: 611a         	str	r2, [r3, #0x10]
; 	stream->src_size	= config->source_data_size;
 8006d68: 687b         	ldr	r3, [r7, #0x4]
 8006d6a: 889b         	ldrh	r3, [r3, #0x4]
 8006d6c: 461a         	mov	r2, r3
 8006d6e: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006d72: 609a         	str	r2, [r3, #0x8]
; 	stream->dst_size	= config->dest_data_size;
 8006d74: 687b         	ldr	r3, [r7, #0x4]
 8006d76: 88db         	ldrh	r3, [r3, #0x6]
 8006d78: 461a         	mov	r2, r3
 8006d7a: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006d7e: 60da         	str	r2, [r3, #0xc]
; 	stream->cyclic		= config->head_block->source_reload_en;
 8006d80: 687b         	ldr	r3, [r7, #0x4]
 8006d82: 691b         	ldr	r3, [r3, #0x10]
 8006d84: 7f1b         	ldrb	r3, [r3, #0x1c]
 8006d86: f3c3 1380    	ubfx	r3, r3, #0x6, #0x1
 8006d8a: b2db         	uxtb	r3, r3
 8006d8c: 2b00         	cmp	r3, #0x0
 8006d8e: bf14         	ite	ne
 8006d90: 2301         	movne	r3, #0x1
 8006d92: 2300         	moveq	r3, #0x0
 8006d94: b2da         	uxtb	r2, r3
 8006d96: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006d9a: 761a         	strb	r2, [r3, #0x18]
; 	if (config->head_block->source_address == 0) {
 8006d9c: 687b         	ldr	r3, [r7, #0x4]
 8006d9e: 691b         	ldr	r3, [r3, #0x10]
 8006da0: 681b         	ldr	r3, [r3]
 8006da2: 2b00         	cmp	r3, #0x0
 8006da4: d11c         	bne	0x8006de0 <dma_stm32_configure+0x3f4> @ imm = #0x38
; 		LOG_WRN("source_buffer address is null.");
 8006da6: 2303         	movs	r3, #0x3
 8006da8: 2b01         	cmp	r3, #0x1
 8006daa: d919         	bls	0x8006de0 <dma_stm32_configure+0x3f4> @ imm = #0x32
 8006dac: 2301         	movs	r3, #0x1
 8006dae: f887 30c3    	strb.w	r3, [r7, #0xc3]
 8006db2: f897 30c3    	ldrb.w	r3, [r7, #0xc3]
 8006db6: f083 0301    	eor	r3, r3, #0x1
 8006dba: b2db         	uxtb	r3, r3
 8006dbc: 2b00         	cmp	r3, #0x0
 8006dbe: d10f         	bne	0x8006de0 <dma_stm32_configure+0x3f4> @ imm = #0x1e
 8006dc0: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8006f88 <dma_stm32_configure+0x59c>
 8006dc2: 6819         	ldr	r1, [r3]
 8006dc4: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8006f90 <dma_stm32_configure+0x5a4>
 8006dc6: 9302         	str	r3, [sp, #0x8]
 8006dc8: 2300         	movs	r3, #0x0
 8006dca: 9301         	str	r3, [sp, #0x4]
 8006dcc: 2300         	movs	r3, #0x0
 8006dce: 9300         	str	r3, [sp]
 8006dd0: 2300         	movs	r3, #0x0
 8006dd2: 2202         	movs	r2, #0x2
 8006dd4: 2000         	movs	r0, #0x0
 8006dd6: f00b fefb    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xbdf6
 8006dda: 2300         	movs	r3, #0x0
 8006ddc: f8c7 30bc    	str.w	r3, [r7, #0xbc]
; 	if (config->head_block->dest_address == 0) {
 8006de0: 687b         	ldr	r3, [r7, #0x4]
 8006de2: 691b         	ldr	r3, [r3, #0x10]
 8006de4: 685b         	ldr	r3, [r3, #0x4]
 8006de6: 2b00         	cmp	r3, #0x0
 8006de8: d11c         	bne	0x8006e24 <dma_stm32_configure+0x438> @ imm = #0x38
; 		LOG_WRN("dest_buffer address is null.");
 8006dea: 2303         	movs	r3, #0x3
 8006dec: 2b01         	cmp	r3, #0x1
 8006dee: d919         	bls	0x8006e24 <dma_stm32_configure+0x438> @ imm = #0x32
 8006df0: 2301         	movs	r3, #0x1
 8006df2: f887 30bb    	strb.w	r3, [r7, #0xbb]
 8006df6: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 8006dfa: f083 0301    	eor	r3, r3, #0x1
 8006dfe: b2db         	uxtb	r3, r3
 8006e00: 2b00         	cmp	r3, #0x0
 8006e02: d10f         	bne	0x8006e24 <dma_stm32_configure+0x438> @ imm = #0x1e
 8006e04: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8006f88 <dma_stm32_configure+0x59c>
 8006e06: 6819         	ldr	r1, [r3]
 8006e08: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8006f94 <dma_stm32_configure+0x5a8>
 8006e0a: 9302         	str	r3, [sp, #0x8]
 8006e0c: 2300         	movs	r3, #0x0
 8006e0e: 9301         	str	r3, [sp, #0x4]
 8006e10: 2300         	movs	r3, #0x0
 8006e12: 9300         	str	r3, [sp]
 8006e14: 2300         	movs	r3, #0x0
 8006e16: 2202         	movs	r2, #0x2
 8006e18: 2000         	movs	r0, #0x0
 8006e1a: f00b fed9    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xbdb2
 8006e1e: 2300         	movs	r3, #0x0
 8006e20: f8c7 30b4    	str.w	r3, [r7, #0xb4]
; 	if (stream->direction == MEMORY_TO_PERIPHERAL) {
 8006e24: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8006e28: 681b         	ldr	r3, [r3]
 8006e2a: 2b01         	cmp	r3, #0x1
 8006e2c: d108         	bne	0x8006e40 <dma_stm32_configure+0x454> @ imm = #0x10
; 					config->head_block->source_address;
 8006e2e: 687b         	ldr	r3, [r7, #0x4]
 8006e30: 691b         	ldr	r3, [r3, #0x10]
 8006e32: 681b         	ldr	r3, [r3]
; 		DMA_InitStruct.MemoryOrM2MDstAddress =
 8006e34: 617b         	str	r3, [r7, #0x14]
; 					config->head_block->dest_address;
 8006e36: 687b         	ldr	r3, [r7, #0x4]
 8006e38: 691b         	ldr	r3, [r3, #0x10]
 8006e3a: 685b         	ldr	r3, [r3, #0x4]
; 		DMA_InitStruct.PeriphOrM2MSrcAddress =
 8006e3c: 613b         	str	r3, [r7, #0x10]
 8006e3e: e007         	b	0x8006e50 <dma_stm32_configure+0x464> @ imm = #0xe
; 					config->head_block->source_address;
 8006e40: 687b         	ldr	r3, [r7, #0x4]
 8006e42: 691b         	ldr	r3, [r3, #0x10]
 8006e44: 681b         	ldr	r3, [r3]
; 		DMA_InitStruct.PeriphOrM2MSrcAddress =
 8006e46: 613b         	str	r3, [r7, #0x10]
; 					config->head_block->dest_address;
 8006e48: 687b         	ldr	r3, [r7, #0x4]
 8006e4a: 691b         	ldr	r3, [r3, #0x10]
 8006e4c: 685b         	ldr	r3, [r3, #0x4]
; 		DMA_InitStruct.MemoryOrM2MDstAddress =
 8006e4e: 617b         	str	r3, [r7, #0x14]
; 	uint16_t memory_addr_adj = 0, periph_addr_adj = 0;
 8006e50: 2300         	movs	r3, #0x0
 8006e52: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
 8006e56: 2300         	movs	r3, #0x0
 8006e58: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 	ret = dma_stm32_get_priority(config->channel_priority,
 8006e5c: 687b         	ldr	r3, [r7, #0x4]
 8006e5e: 681b         	ldr	r3, [r3]
 8006e60: f3c3 33c3    	ubfx	r3, r3, #0xf, #0x4
 8006e64: b2db         	uxtb	r3, r3
 8006e66: 461a         	mov	r2, r3
 8006e68: f107 0310    	add.w	r3, r7, #0x10
 8006e6c: 3328         	adds	r3, #0x28
 8006e6e: 4619         	mov	r1, r3
 8006e70: 4610         	mov	r0, r2
 8006e72: f7ff fc9f    	bl	0x80067b4 <dma_stm32_get_priority> @ imm = #-0x6c2
 8006e76: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8006e7a: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006e7e: 2b00         	cmp	r3, #0x0
 8006e80: da02         	bge	0x8006e88 <dma_stm32_configure+0x49c> @ imm = #0x4
; 		return ret;
 8006e82: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006e86: e217         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x42e
; 	ret = dma_stm32_get_direction(config->channel_direction,
 8006e88: 687b         	ldr	r3, [r7, #0x4]
 8006e8a: 785b         	ldrb	r3, [r3, #0x1]
 8006e8c: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 8006e90: b2db         	uxtb	r3, r3
 8006e92: 461a         	mov	r2, r3
 8006e94: f107 0310    	add.w	r3, r7, #0x10
 8006e98: 3308         	adds	r3, #0x8
 8006e9a: 4619         	mov	r1, r3
 8006e9c: 4610         	mov	r0, r2
 8006e9e: f7ff fcd9    	bl	0x8006854 <dma_stm32_get_direction> @ imm = #-0x64e
 8006ea2: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8006ea6: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006eaa: 2b00         	cmp	r3, #0x0
 8006eac: da02         	bge	0x8006eb4 <dma_stm32_configure+0x4c8> @ imm = #0x4
; 		return ret;
 8006eae: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006eb2: e201         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x402
; 	switch (config->channel_direction) {
 8006eb4: 687b         	ldr	r3, [r7, #0x4]
 8006eb6: 785b         	ldrb	r3, [r3, #0x1]
 8006eb8: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 8006ebc: b2db         	uxtb	r3, r3
 8006ebe: 2b02         	cmp	r3, #0x2
 8006ec0: d006         	beq	0x8006ed0 <dma_stm32_configure+0x4e4> @ imm = #0xc
 8006ec2: 2b02         	cmp	r3, #0x2
 8006ec4: dc26         	bgt	0x8006f14 <dma_stm32_configure+0x528> @ imm = #0x4c
 8006ec6: 2b00         	cmp	r3, #0x0
 8006ec8: d002         	beq	0x8006ed0 <dma_stm32_configure+0x4e4> @ imm = #0x4
 8006eca: 2b01         	cmp	r3, #0x1
 8006ecc: d011         	beq	0x8006ef2 <dma_stm32_configure+0x506> @ imm = #0x22
 8006ece: e021         	b	0x8006f14 <dma_stm32_configure+0x528> @ imm = #0x42
; 		memory_addr_adj = config->head_block->dest_addr_adj;
 8006ed0: 687b         	ldr	r3, [r7, #0x4]
 8006ed2: 691b         	ldr	r3, [r3, #0x10]
 8006ed4: 7f1b         	ldrb	r3, [r3, #0x1c]
 8006ed6: f3c3 1301    	ubfx	r3, r3, #0x4, #0x2
 8006eda: b2db         	uxtb	r3, r3
 8006edc: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
; 		periph_addr_adj = config->head_block->source_addr_adj;
 8006ee0: 687b         	ldr	r3, [r7, #0x4]
 8006ee2: 691b         	ldr	r3, [r3, #0x10]
 8006ee4: 7f1b         	ldrb	r3, [r3, #0x1c]
 8006ee6: f3c3 0381    	ubfx	r3, r3, #0x2, #0x2
 8006eea: b2db         	uxtb	r3, r3
 8006eec: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 		break;
 8006ef0: e036         	b	0x8006f60 <dma_stm32_configure+0x574> @ imm = #0x6c
; 		memory_addr_adj = config->head_block->source_addr_adj;
 8006ef2: 687b         	ldr	r3, [r7, #0x4]
 8006ef4: 691b         	ldr	r3, [r3, #0x10]
 8006ef6: 7f1b         	ldrb	r3, [r3, #0x1c]
 8006ef8: f3c3 0381    	ubfx	r3, r3, #0x2, #0x2
 8006efc: b2db         	uxtb	r3, r3
 8006efe: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
; 		periph_addr_adj = config->head_block->dest_addr_adj;
 8006f02: 687b         	ldr	r3, [r7, #0x4]
 8006f04: 691b         	ldr	r3, [r3, #0x10]
 8006f06: 7f1b         	ldrb	r3, [r3, #0x1c]
 8006f08: f3c3 1301    	ubfx	r3, r3, #0x4, #0x2
 8006f0c: b2db         	uxtb	r3, r3
 8006f0e: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 		break;
 8006f12: e025         	b	0x8006f60 <dma_stm32_configure+0x574> @ imm = #0x4a
; 		LOG_ERR("Channel direction error (%d).",
 8006f14: 2303         	movs	r3, #0x3
 8006f16: 2b00         	cmp	r3, #0x0
 8006f18: d01f         	beq	0x8006f5a <dma_stm32_configure+0x56e> @ imm = #0x3e
 8006f1a: 2301         	movs	r3, #0x1
 8006f1c: f887 308b    	strb.w	r3, [r7, #0x8b]
 8006f20: f897 308b    	ldrb.w	r3, [r7, #0x8b]
 8006f24: f083 0301    	eor	r3, r3, #0x1
 8006f28: b2db         	uxtb	r3, r3
 8006f2a: 2b00         	cmp	r3, #0x0
 8006f2c: d115         	bne	0x8006f5a <dma_stm32_configure+0x56e> @ imm = #0x2a
 8006f2e: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8006f88 <dma_stm32_configure+0x59c>
 8006f30: 6819         	ldr	r1, [r3]
 8006f32: 687b         	ldr	r3, [r7, #0x4]
 8006f34: 785b         	ldrb	r3, [r3, #0x1]
 8006f36: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 8006f3a: b2db         	uxtb	r3, r3
 8006f3c: 9303         	str	r3, [sp, #0xc]
 8006f3e: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8006f98 <dma_stm32_configure+0x5ac>
 8006f40: 9302         	str	r3, [sp, #0x8]
 8006f42: 2300         	movs	r3, #0x0
 8006f44: 9301         	str	r3, [sp, #0x4]
 8006f46: 2300         	movs	r3, #0x0
 8006f48: 9300         	str	r3, [sp]
 8006f4a: 2300         	movs	r3, #0x0
 8006f4c: 2201         	movs	r2, #0x1
 8006f4e: 2000         	movs	r0, #0x0
 8006f50: f00b fe3e    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xbc7c
 8006f54: 2300         	movs	r3, #0x0
 8006f56: f8c7 3084    	str.w	r3, [r7, #0x84]
; 		return -EINVAL;
 8006f5a: f06f 0315    	mvn	r3, #0x15
 8006f5e: e1ab         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x356
; 	ret = dma_stm32_get_memory_increment(memory_addr_adj,
 8006f60: f8b7 30c6    	ldrh.w	r3, [r7, #0xc6]
 8006f64: b2da         	uxtb	r2, r3
 8006f66: f107 0310    	add.w	r3, r7, #0x10
 8006f6a: 3314         	adds	r3, #0x14
 8006f6c: 4619         	mov	r1, r3
 8006f6e: 4610         	mov	r0, r2
 8006f70: f7ff fcb4    	bl	0x80068dc <dma_stm32_get_memory_increment> @ imm = #-0x698
 8006f74: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8006f78: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006f7c: 2b00         	cmp	r3, #0x0
 8006f7e: da0d         	bge	0x8006f9c <dma_stm32_configure+0x5b0> @ imm = #0x1a
; 		return ret;
 8006f80: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006f84: e198         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x330
 8006f86: bf00         	nop

08006f88 <$d>:
 8006f88: 0c 03 00 20  	.word	0x2000030c
 8006f8c: 5c a6 01 08  	.word	0x0801a65c
 8006f90: 94 a6 01 08  	.word	0x0801a694
 8006f94: b4 a6 01 08  	.word	0x0801a6b4
 8006f98: d4 a6 01 08  	.word	0x0801a6d4

08006f9c <$t>:
; 	LOG_DBG("Channel (%d) memory inc (%x).",
 8006f9c: 2303         	movs	r3, #0x3
 8006f9e: 2b03         	cmp	r3, #0x3
 8006fa0: d91f         	bls	0x8006fe2 <dma_stm32_configure+0x5f6> @ imm = #0x3e
 8006fa2: 2301         	movs	r3, #0x1
 8006fa4: f887 30af    	strb.w	r3, [r7, #0xaf]
 8006fa8: f897 30af    	ldrb.w	r3, [r7, #0xaf]
 8006fac: f083 0301    	eor	r3, r3, #0x1
 8006fb0: b2db         	uxtb	r3, r3
 8006fb2: 2b00         	cmp	r3, #0x0
 8006fb4: d115         	bne	0x8006fe2 <dma_stm32_configure+0x5f6> @ imm = #0x2a
 8006fb6: 4bae         	ldr	r3, [pc, #0x2b8]        @ 0x8007270 <dma_stm32_configure+0x884>
 8006fb8: 6819         	ldr	r1, [r3]
 8006fba: 6a7b         	ldr	r3, [r7, #0x24]
 8006fbc: 9305         	str	r3, [sp, #0x14]
 8006fbe: 68bb         	ldr	r3, [r7, #0x8]
 8006fc0: 9304         	str	r3, [sp, #0x10]
 8006fc2: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8007274 <dma_stm32_configure+0x888>
 8006fc4: 9303         	str	r3, [sp, #0xc]
 8006fc6: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8007278 <dma_stm32_configure+0x88c>
 8006fc8: 9302         	str	r3, [sp, #0x8]
 8006fca: 2308         	movs	r3, #0x8
 8006fcc: 9301         	str	r3, [sp, #0x4]
 8006fce: 2300         	movs	r3, #0x0
 8006fd0: 9300         	str	r3, [sp]
 8006fd2: 2300         	movs	r3, #0x0
 8006fd4: 2204         	movs	r2, #0x4
 8006fd6: 2000         	movs	r0, #0x0
 8006fd8: f00b fdfa    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xbbf4
 8006fdc: 2300         	movs	r3, #0x0
 8006fde: f8c7 30a8    	str.w	r3, [r7, #0xa8]
; 	ret = dma_stm32_get_periph_increment(periph_addr_adj,
 8006fe2: f8b7 30c4    	ldrh.w	r3, [r7, #0xc4]
 8006fe6: b2da         	uxtb	r2, r3
 8006fe8: f107 0310    	add.w	r3, r7, #0x10
 8006fec: 3310         	adds	r3, #0x10
 8006fee: 4619         	mov	r1, r3
 8006ff0: 4610         	mov	r0, r2
 8006ff2: f7ff fcb7    	bl	0x8006964 <dma_stm32_get_periph_increment> @ imm = #-0x692
 8006ff6: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8006ffa: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8006ffe: 2b00         	cmp	r3, #0x0
 8007000: da02         	bge	0x8007008 <dma_stm32_configure+0x61c> @ imm = #0x4
; 		return ret;
 8007002: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8007006: e157         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x2ae
; 	LOG_DBG("Channel (%d) peripheral inc (%x).",
 8007008: 2303         	movs	r3, #0x3
 800700a: 2b03         	cmp	r3, #0x3
 800700c: d91f         	bls	0x800704e <dma_stm32_configure+0x662> @ imm = #0x3e
 800700e: 2301         	movs	r3, #0x1
 8007010: f887 30a7    	strb.w	r3, [r7, #0xa7]
 8007014: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 8007018: f083 0301    	eor	r3, r3, #0x1
 800701c: b2db         	uxtb	r3, r3
 800701e: 2b00         	cmp	r3, #0x0
 8007020: d115         	bne	0x800704e <dma_stm32_configure+0x662> @ imm = #0x2a
 8007022: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8007270 <dma_stm32_configure+0x884>
 8007024: 6819         	ldr	r1, [r3]
 8007026: 6a3b         	ldr	r3, [r7, #0x20]
 8007028: 9305         	str	r3, [sp, #0x14]
 800702a: 68bb         	ldr	r3, [r7, #0x8]
 800702c: 9304         	str	r3, [sp, #0x10]
 800702e: 4b91         	ldr	r3, [pc, #0x244]        @ 0x8007274 <dma_stm32_configure+0x888>
 8007030: 9303         	str	r3, [sp, #0xc]
 8007032: 4b92         	ldr	r3, [pc, #0x248]        @ 0x800727c <dma_stm32_configure+0x890>
 8007034: 9302         	str	r3, [sp, #0x8]
 8007036: 2308         	movs	r3, #0x8
 8007038: 9301         	str	r3, [sp, #0x4]
 800703a: 2300         	movs	r3, #0x0
 800703c: 9300         	str	r3, [sp]
 800703e: 2300         	movs	r3, #0x0
 8007040: 2204         	movs	r2, #0x4
 8007042: 2000         	movs	r0, #0x0
 8007044: f00b fdc4    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xbb88
 8007048: 2300         	movs	r3, #0x0
 800704a: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; 	if (stream->cyclic) {
 800704e: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007052: 7e1b         	ldrb	r3, [r3, #0x18]
 8007054: 2b00         	cmp	r3, #0x0
 8007056: d003         	beq	0x8007060 <dma_stm32_configure+0x674> @ imm = #0x6
; 		DMA_InitStruct.Mode = LL_DMA_MODE_CIRCULAR;
 8007058: f44f 7380    	mov.w	r3, #0x100
 800705c: 61fb         	str	r3, [r7, #0x1c]
 800705e: e001         	b	0x8007064 <dma_stm32_configure+0x678> @ imm = #0x2
; 		DMA_InitStruct.Mode = LL_DMA_MODE_NORMAL;
 8007060: 2300         	movs	r3, #0x0
 8007062: 61fb         	str	r3, [r7, #0x1c]
; 	stream->source_periph = (stream->direction == PERIPHERAL_TO_MEMORY);
 8007064: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007068: 681b         	ldr	r3, [r3]
 800706a: 2b02         	cmp	r3, #0x2
 800706c: bf0c         	ite	eq
 800706e: 2301         	moveq	r3, #0x1
 8007070: 2300         	movne	r3, #0x0
 8007072: b2da         	uxtb	r2, r3
 8007074: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8007078: 711a         	strb	r2, [r3, #0x4]
; 	int index = find_lsb_set(config->source_data_size) - 1;
 800707a: 687b         	ldr	r3, [r7, #0x4]
 800707c: 889b         	ldrh	r3, [r3, #0x4]
 800707e: 64fb         	str	r3, [r7, #0x4c]
; 	return __builtin_ffs(op);
 8007080: 6cfb         	ldr	r3, [r7, #0x4c]
 8007082: fa93 f2a3    	rbit	r2, r3
 8007086: fab2 f282    	clz	r2, r2
 800708a: 2b00         	cmp	r3, #0x0
 800708c: d101         	bne	0x8007092 <dma_stm32_configure+0x6a6> @ imm = #0x2
 800708e: f04f 32ff    	mov.w	r2, #0xffffffff
 8007092: 1c53         	adds	r3, r2, #0x1
; 	int index = find_lsb_set(config->source_data_size) - 1;
 8007094: 3b01         	subs	r3, #0x1
 8007096: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	DMA_InitStruct.PeriphOrM2MSrcDataSize = table_p_size[index];
 800709a: 4a79         	ldr	r2, [pc, #0x1e4]        @ 0x8007280 <dma_stm32_configure+0x894>
 800709c: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 80070a0: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80070a4: 62bb         	str	r3, [r7, #0x28]
; 	index = find_lsb_set(config->dest_data_size) - 1;
 80070a6: 687b         	ldr	r3, [r7, #0x4]
 80070a8: 88db         	ldrh	r3, [r3, #0x6]
 80070aa: 653b         	str	r3, [r7, #0x50]
; 	return __builtin_ffs(op);
 80070ac: 6d3b         	ldr	r3, [r7, #0x50]
 80070ae: fa93 f2a3    	rbit	r2, r3
 80070b2: fab2 f282    	clz	r2, r2
 80070b6: 2b00         	cmp	r3, #0x0
 80070b8: d101         	bne	0x80070be <dma_stm32_configure+0x6d2> @ imm = #0x2
 80070ba: f04f 32ff    	mov.w	r2, #0xffffffff
 80070be: 1c53         	adds	r3, r2, #0x1
; 	index = find_lsb_set(config->dest_data_size) - 1;
 80070c0: 3b01         	subs	r3, #0x1
 80070c2: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	DMA_InitStruct.MemoryOrM2MDstDataSize = table_m_size[index];
 80070c6: 4a6f         	ldr	r2, [pc, #0x1bc]        @ 0x8007284 <dma_stm32_configure+0x898>
 80070c8: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 80070cc: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80070d0: 62fb         	str	r3, [r7, #0x2c]
; 	DMA_InitStruct.MemBurst = stm32_dma_get_mburst(config,
 80070d2: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80070d6: 791b         	ldrb	r3, [r3, #0x4]
 80070d8: 4619         	mov	r1, r3
 80070da: 6878         	ldr	r0, [r7, #0x4]
 80070dc: f000 fbc4    	bl	0x8007868 <stm32_dma_get_mburst> @ imm = #0x788
 80070e0: 4603         	mov	r3, r0
 80070e2: 647b         	str	r3, [r7, #0x44]
; 	DMA_InitStruct.PeriphBurst = stm32_dma_get_pburst(config,
 80070e4: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80070e8: 791b         	ldrb	r3, [r3, #0x4]
 80070ea: 4619         	mov	r1, r3
 80070ec: 6878         	ldr	r0, [r7, #0x4]
 80070ee: f000 fc21    	bl	0x8007934 <stm32_dma_get_pburst> @ imm = #0x842
 80070f2: 4603         	mov	r3, r0
 80070f4: 64bb         	str	r3, [r7, #0x48]
; 	if (config->channel_direction != MEMORY_TO_MEMORY) {
 80070f6: 687b         	ldr	r3, [r7, #0x4]
 80070f8: 785b         	ldrb	r3, [r3, #0x1]
 80070fa: f003 0307    	and	r3, r3, #0x7
 80070fe: b2db         	uxtb	r3, r3
 8007100: 2b00         	cmp	r3, #0x0
 8007102: d023         	beq	0x800714c <dma_stm32_configure+0x760> @ imm = #0x46
; 		if (config->dma_slot >= 8) {
 8007104: 687b         	ldr	r3, [r7, #0x4]
 8007106: 781b         	ldrb	r3, [r3]
 8007108: 2b07         	cmp	r3, #0x7
 800710a: d943         	bls	0x8007194 <dma_stm32_configure+0x7a8> @ imm = #0x86
; 			LOG_ERR("dma slot error.");
 800710c: 2303         	movs	r3, #0x3
 800710e: 2b00         	cmp	r3, #0x0
 8007110: d019         	beq	0x8007146 <dma_stm32_configure+0x75a> @ imm = #0x32
 8007112: 2301         	movs	r3, #0x1
 8007114: f887 3093    	strb.w	r3, [r7, #0x93]
 8007118: f897 3093    	ldrb.w	r3, [r7, #0x93]
 800711c: f083 0301    	eor	r3, r3, #0x1
 8007120: b2db         	uxtb	r3, r3
 8007122: 2b00         	cmp	r3, #0x0
 8007124: d10f         	bne	0x8007146 <dma_stm32_configure+0x75a> @ imm = #0x1e
 8007126: 4b52         	ldr	r3, [pc, #0x148]        @ 0x8007270 <dma_stm32_configure+0x884>
 8007128: 6819         	ldr	r1, [r3]
 800712a: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8007288 <dma_stm32_configure+0x89c>
 800712c: 9302         	str	r3, [sp, #0x8]
 800712e: 2300         	movs	r3, #0x0
 8007130: 9301         	str	r3, [sp, #0x4]
 8007132: 2300         	movs	r3, #0x0
 8007134: 9300         	str	r3, [sp]
 8007136: 2300         	movs	r3, #0x0
 8007138: 2201         	movs	r2, #0x1
 800713a: 2000         	movs	r0, #0x0
 800713c: f00b fd48    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xba90
 8007140: 2300         	movs	r3, #0x0
 8007142: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 			return -EINVAL;
 8007146: f06f 0315    	mvn	r3, #0x15
 800714a: e0b5         	b	0x80072b8 <dma_stm32_configure+0x8cc> @ imm = #0x16a
; 		if (config->dma_slot >= 8) {
 800714c: 687b         	ldr	r3, [r7, #0x4]
 800714e: 781b         	ldrb	r3, [r3]
 8007150: 2b07         	cmp	r3, #0x7
 8007152: d91f         	bls	0x8007194 <dma_stm32_configure+0x7a8> @ imm = #0x3e
; 			LOG_ERR("dma slot is too big, using 0 as default.");
 8007154: 2303         	movs	r3, #0x3
 8007156: 2b00         	cmp	r3, #0x0
 8007158: d019         	beq	0x800718e <dma_stm32_configure+0x7a2> @ imm = #0x32
 800715a: 2301         	movs	r3, #0x1
 800715c: f887 309b    	strb.w	r3, [r7, #0x9b]
 8007160: f897 309b    	ldrb.w	r3, [r7, #0x9b]
 8007164: f083 0301    	eor	r3, r3, #0x1
 8007168: b2db         	uxtb	r3, r3
 800716a: 2b00         	cmp	r3, #0x0
 800716c: d10f         	bne	0x800718e <dma_stm32_configure+0x7a2> @ imm = #0x1e
 800716e: 4b40         	ldr	r3, [pc, #0x100]        @ 0x8007270 <dma_stm32_configure+0x884>
 8007170: 6819         	ldr	r1, [r3]
 8007172: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800728c <dma_stm32_configure+0x8a0>
 8007174: 9302         	str	r3, [sp, #0x8]
 8007176: 2300         	movs	r3, #0x0
 8007178: 9301         	str	r3, [sp, #0x4]
 800717a: 2300         	movs	r3, #0x0
 800717c: 9300         	str	r3, [sp]
 800717e: 2300         	movs	r3, #0x0
 8007180: 2201         	movs	r2, #0x1
 8007182: 2000         	movs	r0, #0x0
 8007184: f00b fd24    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xba48
 8007188: 2300         	movs	r3, #0x0
 800718a: f8c7 3094    	str.w	r3, [r7, #0x94]
; 			config->dma_slot = 0;
 800718e: 687b         	ldr	r3, [r7, #0x4]
 8007190: 2200         	movs	r2, #0x0
 8007192: 701a         	strb	r2, [r3]
; 	DMA_InitStruct.Channel = dma_stm32_slot_to_channel(config->dma_slot);
 8007194: 687b         	ldr	r3, [r7, #0x4]
 8007196: 781b         	ldrb	r3, [r3]
 8007198: 4618         	mov	r0, r3
 800719a: f000 f9f1    	bl	0x8007580 <dma_stm32_slot_to_channel> @ imm = #0x3e2
 800719e: 4603         	mov	r3, r0
 80071a0: 637b         	str	r3, [r7, #0x34]
; 					config->head_block->fifo_mode_control);
 80071a2: 687b         	ldr	r3, [r7, #0x4]
 80071a4: 691b         	ldr	r3, [r3, #0x10]
 80071a6: 7f5b         	ldrb	r3, [r3, #0x1d]
 80071a8: f3c3 0303    	ubfx	r3, r3, #0x0, #0x4
 80071ac: b2db         	uxtb	r3, r3
; 	DMA_InitStruct.FIFOThreshold = stm32_dma_get_fifo_threshold(
 80071ae: 4618         	mov	r0, r3
 80071b0: f000 fc26    	bl	0x8007a00 <stm32_dma_get_fifo_threshold> @ imm = #0x84c
 80071b4: 4603         	mov	r3, r0
 80071b6: 643b         	str	r3, [r7, #0x40]
; 	if (stm32_dma_check_fifo_mburst(&DMA_InitStruct)) {
 80071b8: f107 0310    	add.w	r3, r7, #0x10
 80071bc: 4618         	mov	r0, r3
 80071be: f00c fd0e    	bl	0x8013bde <stm32_dma_check_fifo_mburst> @ imm = #0xca1c
 80071c2: 4603         	mov	r3, r0
 80071c4: 2b00         	cmp	r3, #0x0
 80071c6: d002         	beq	0x80071ce <dma_stm32_configure+0x7e2> @ imm = #0x4
; 		DMA_InitStruct.FIFOMode = LL_DMA_FIFOMODE_ENABLE;
 80071c8: 2304         	movs	r3, #0x4
 80071ca: 63fb         	str	r3, [r7, #0x3c]
 80071cc: e001         	b	0x80071d2 <dma_stm32_configure+0x7e6> @ imm = #0x2
; 		DMA_InitStruct.FIFOMode = LL_DMA_FIFOMODE_DISABLE;
 80071ce: 2300         	movs	r3, #0x0
 80071d0: 63fb         	str	r3, [r7, #0x3c]
; 	if (stream->source_periph) {
 80071d2: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80071d6: 791b         	ldrb	r3, [r3, #0x4]
 80071d8: 2b00         	cmp	r3, #0x0
 80071da: d008         	beq	0x80071ee <dma_stm32_configure+0x802> @ imm = #0x10
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 80071dc: 687b         	ldr	r3, [r7, #0x4]
 80071de: 691b         	ldr	r3, [r3, #0x10]
 80071e0: 695b         	ldr	r3, [r3, #0x14]
; 					config->source_data_size;
 80071e2: 687a         	ldr	r2, [r7, #0x4]
 80071e4: 8892         	ldrh	r2, [r2, #0x4]
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 80071e6: fbb3 f3f2    	udiv	r3, r3, r2
 80071ea: 633b         	str	r3, [r7, #0x30]
 80071ec: e007         	b	0x80071fe <dma_stm32_configure+0x812> @ imm = #0xe
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 80071ee: 687b         	ldr	r3, [r7, #0x4]
 80071f0: 691b         	ldr	r3, [r3, #0x10]
 80071f2: 695b         	ldr	r3, [r3, #0x14]
; 					config->dest_data_size;
 80071f4: 687a         	ldr	r2, [r7, #0x4]
 80071f6: 88d2         	ldrh	r2, [r2, #0x6]
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 80071f8: fbb3 f3f2    	udiv	r3, r3, r2
 80071fc: 633b         	str	r3, [r7, #0x30]
; 	LL_DMA_Init(dma, dma_stm32_id_to_stream(id), &DMA_InitStruct);
 80071fe: 68b8         	ldr	r0, [r7, #0x8]
 8007200: f000 f9ae    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #0x35c
 8007204: 4601         	mov	r1, r0
 8007206: f107 0310    	add.w	r3, r7, #0x10
 800720a: 461a         	mov	r2, r3
 800720c: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8007210: f00f fd4a    	bl	0x8016ca8 <LL_DMA_Init> @ imm = #0xfa94
; 	LL_DMA_EnableIT_TC(dma, dma_stm32_id_to_stream(id));
 8007214: 68b8         	ldr	r0, [r7, #0x8]
 8007216: f000 f9a3    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #0x346
 800721a: 4603         	mov	r3, r0
 800721c: 4619         	mov	r1, r3
 800721e: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8007222: f7ff f983    	bl	0x800652c <LL_DMA_EnableIT_TC> @ imm = #-0xcfa
; 	if (stream->cyclic) {
 8007226: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800722a: 7e1b         	ldrb	r3, [r3, #0x18]
 800722c: 2b00         	cmp	r3, #0x0
 800722e: d008         	beq	0x8007242 <dma_stm32_configure+0x856> @ imm = #0x10
; 		LL_DMA_EnableIT_HT(dma, dma_stm32_id_to_stream(id));
 8007230: 68b8         	ldr	r0, [r7, #0x8]
 8007232: f000 f995    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #0x32a
 8007236: 4603         	mov	r3, r0
 8007238: 4619         	mov	r1, r3
 800723a: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 800723e: f7ff f957    	bl	0x80064f0 <LL_DMA_EnableIT_HT> @ imm = #-0xd52
; 	if (DMA_InitStruct.FIFOMode == LL_DMA_FIFOMODE_ENABLE) {
 8007242: 6bfb         	ldr	r3, [r7, #0x3c]
 8007244: 2b04         	cmp	r3, #0x4
 8007246: d123         	bne	0x8007290 <dma_stm32_configure+0x8a4> @ imm = #0x46
; 		LL_DMA_EnableFifoMode(dma, dma_stm32_id_to_stream(id));
 8007248: 68b8         	ldr	r0, [r7, #0x8]
 800724a: f000 f989    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #0x312
 800724e: 4603         	mov	r3, r0
 8007250: 4619         	mov	r1, r3
 8007252: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8007256: f7ff f8fd    	bl	0x8006454 <LL_DMA_EnableFifoMode> @ imm = #-0xe06
; 		LL_DMA_EnableIT_FE(dma, dma_stm32_id_to_stream(id));
 800725a: 68b8         	ldr	r0, [r7, #0x8]
 800725c: f000 f980    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #0x300
 8007260: 4603         	mov	r3, r0
 8007262: 4619         	mov	r1, r3
 8007264: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8007268: f7ff f97e    	bl	0x8006568 <LL_DMA_EnableIT_FE> @ imm = #-0xd04
 800726c: e022         	b	0x80072b4 <dma_stm32_configure+0x8c8> @ imm = #0x44
 800726e: bf00         	nop

08007270 <$d>:
 8007270: 0c 03 00 20  	.word	0x2000030c
 8007274: 88 b6 01 08  	.word	0x0801b688
 8007278: f4 a6 01 08  	.word	0x0801a6f4
 800727c: 18 a7 01 08  	.word	0x0801a718
 8007280: 3c b6 01 08  	.word	0x0801b63c
 8007284: 30 b6 01 08  	.word	0x0801b630
 8007288: 40 a7 01 08  	.word	0x0801a740
 800728c: 50 a7 01 08  	.word	0x0801a750

08007290 <$t>:
; 		LL_DMA_DisableFifoMode(dma, dma_stm32_id_to_stream(id));
 8007290: 68b8         	ldr	r0, [r7, #0x8]
 8007292: f000 f965    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #0x2ca
 8007296: 4603         	mov	r3, r0
 8007298: 4619         	mov	r1, r3
 800729a: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 800729e: f7ff f8bb    	bl	0x8006418 <LL_DMA_DisableFifoMode> @ imm = #-0xe8a
; 		LL_DMA_DisableIT_FE(dma, dma_stm32_id_to_stream(id));
 80072a2: 68b8         	ldr	r0, [r7, #0x8]
 80072a4: f000 f95c    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #0x2b8
 80072a8: 4603         	mov	r3, r0
 80072aa: 4619         	mov	r1, r3
 80072ac: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 80072b0: f7ff f996    	bl	0x80065e0 <LL_DMA_DisableIT_FE> @ imm = #-0xcd4
; 	return ret;
 80072b4: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
; }
 80072b8: 4618         	mov	r0, r3
 80072ba: 37e0         	adds	r7, #0xe0
 80072bc: 46bd         	mov	sp, r7
 80072be: bd80         	pop	{r7, pc}

080072c0 <dma_stm32_init>:
; {
 80072c0: b580         	push	{r7, lr}
 80072c2: b08e         	sub	sp, #0x38
 80072c4: af04         	add	r7, sp, #0x10
 80072c6: 6078         	str	r0, [r7, #0x4]
; 	const struct dma_stm32_config *config = dev->config;
 80072c8: 687b         	ldr	r3, [r7, #0x4]
 80072ca: 685b         	ldr	r3, [r3, #0x4]
 80072cc: 623b         	str	r3, [r7, #0x20]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 80072ce: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x80073bc <dma_stm32_init+0xfc>
 80072d0: 61fb         	str	r3, [r7, #0x1c]
; 	if (!device_is_ready(clk)) {
 80072d2: 69f8         	ldr	r0, [r7, #0x1c]
 80072d4: f00b fc50    	bl	0x8012b78 <device_is_ready> @ imm = #0xb8a0
 80072d8: 4603         	mov	r3, r0
 80072da: f083 0301    	eor	r3, r3, #0x1
 80072de: b2db         	uxtb	r3, r3
 80072e0: 2b00         	cmp	r3, #0x0
 80072e2: d01c         	beq	0x800731e <dma_stm32_init+0x5e> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 80072e4: 2303         	movs	r3, #0x3
 80072e6: 2b00         	cmp	r3, #0x0
 80072e8: d016         	beq	0x8007318 <dma_stm32_init+0x58> @ imm = #0x2c
 80072ea: 2301         	movs	r3, #0x1
 80072ec: 74fb         	strb	r3, [r7, #0x13]
 80072ee: 7cfb         	ldrb	r3, [r7, #0x13]
 80072f0: f083 0301    	eor	r3, r3, #0x1
 80072f4: b2db         	uxtb	r3, r3
 80072f6: 2b00         	cmp	r3, #0x0
 80072f8: d10e         	bne	0x8007318 <dma_stm32_init+0x58> @ imm = #0x1c
 80072fa: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80073c0 <dma_stm32_init+0x100>
 80072fc: 6819         	ldr	r1, [r3]
 80072fe: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80073c4 <dma_stm32_init+0x104>
 8007300: 9302         	str	r3, [sp, #0x8]
 8007302: 2300         	movs	r3, #0x0
 8007304: 9301         	str	r3, [sp, #0x4]
 8007306: 2300         	movs	r3, #0x0
 8007308: 9300         	str	r3, [sp]
 800730a: 2300         	movs	r3, #0x0
 800730c: 2201         	movs	r2, #0x1
 800730e: 2000         	movs	r0, #0x0
 8007310: f00b fc5e    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xb8bc
 8007314: 2300         	movs	r3, #0x0
 8007316: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 8007318: f06f 0312    	mvn	r3, #0x12
 800731c: e04a         	b	0x80073b4 <dma_stm32_init+0xf4> @ imm = #0x94
; 		(clock_control_subsys_t) &config->pclken) != 0) {
 800731e: 6a3b         	ldr	r3, [r7, #0x20]
; 	if (clock_control_on(clk,
 8007320: 4619         	mov	r1, r3
 8007322: 69f8         	ldr	r0, [r7, #0x1c]
 8007324: f00b fc42    	bl	0x8012bac <clock_control_on> @ imm = #0xb884
 8007328: 4603         	mov	r3, r0
 800732a: 2b00         	cmp	r3, #0x0
 800732c: d01c         	beq	0x8007368 <dma_stm32_init+0xa8> @ imm = #0x38
; 		LOG_ERR("clock op failed\n");
 800732e: 2303         	movs	r3, #0x3
 8007330: 2b00         	cmp	r3, #0x0
 8007332: d016         	beq	0x8007362 <dma_stm32_init+0xa2> @ imm = #0x2c
 8007334: 2301         	movs	r3, #0x1
 8007336: 76fb         	strb	r3, [r7, #0x1b]
 8007338: 7efb         	ldrb	r3, [r7, #0x1b]
 800733a: f083 0301    	eor	r3, r3, #0x1
 800733e: b2db         	uxtb	r3, r3
 8007340: 2b00         	cmp	r3, #0x0
 8007342: d10e         	bne	0x8007362 <dma_stm32_init+0xa2> @ imm = #0x1c
 8007344: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80073c0 <dma_stm32_init+0x100>
 8007346: 6819         	ldr	r1, [r3]
 8007348: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80073c8 <dma_stm32_init+0x108>
 800734a: 9302         	str	r3, [sp, #0x8]
 800734c: 2300         	movs	r3, #0x0
 800734e: 9301         	str	r3, [sp, #0x4]
 8007350: 2300         	movs	r3, #0x0
 8007352: 9300         	str	r3, [sp]
 8007354: 2300         	movs	r3, #0x0
 8007356: 2201         	movs	r2, #0x1
 8007358: 2000         	movs	r0, #0x0
 800735a: f00b fc39    	bl	0x8012bd0 <z_log_msg_runtime_create> @ imm = #0xb872
 800735e: 2300         	movs	r3, #0x0
 8007360: 617b         	str	r3, [r7, #0x14]
; 		return -EIO;
 8007362: f06f 0304    	mvn	r3, #0x4
 8007366: e025         	b	0x80073b4 <dma_stm32_init+0xf4> @ imm = #0x4a
; 	config->config_irq(dev);
 8007368: 6a3b         	ldr	r3, [r7, #0x20]
 800736a: 689b         	ldr	r3, [r3, #0x8]
 800736c: 6878         	ldr	r0, [r7, #0x4]
 800736e: 4798         	blx	r3
; 	for (uint32_t i = 0; i < config->max_streams; i++) {
 8007370: 2300         	movs	r3, #0x0
 8007372: 627b         	str	r3, [r7, #0x24]
 8007374: e00c         	b	0x8007390 <dma_stm32_init+0xd0> @ imm = #0x18
; 		config->streams[i].busy = false;
 8007376: 6a3b         	ldr	r3, [r7, #0x20]
 8007378: 6999         	ldr	r1, [r3, #0x18]
 800737a: 6a7a         	ldr	r2, [r7, #0x24]
 800737c: 4613         	mov	r3, r2
 800737e: 00db         	lsls	r3, r3, #0x3
 8007380: 1a9b         	subs	r3, r3, r2
 8007382: 009b         	lsls	r3, r3, #0x2
 8007384: 440b         	add	r3, r1
 8007386: 2200         	movs	r2, #0x0
 8007388: 719a         	strb	r2, [r3, #0x6]
; 	for (uint32_t i = 0; i < config->max_streams; i++) {
 800738a: 6a7b         	ldr	r3, [r7, #0x24]
 800738c: 3301         	adds	r3, #0x1
 800738e: 627b         	str	r3, [r7, #0x24]
 8007390: 6a3b         	ldr	r3, [r7, #0x20]
 8007392: 695b         	ldr	r3, [r3, #0x14]
 8007394: 6a7a         	ldr	r2, [r7, #0x24]
 8007396: 429a         	cmp	r2, r3
 8007398: d3ed         	blo	0x8007376 <dma_stm32_init+0xb6> @ imm = #-0x26
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.magic = 0;
 800739a: 687b         	ldr	r3, [r7, #0x4]
 800739c: 691b         	ldr	r3, [r3, #0x10]
 800739e: 2200         	movs	r2, #0x0
 80073a0: 601a         	str	r2, [r3]
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.dma_channels = 0;
 80073a2: 687b         	ldr	r3, [r7, #0x4]
 80073a4: 691b         	ldr	r3, [r3, #0x10]
 80073a6: 2200         	movs	r2, #0x0
 80073a8: 605a         	str	r2, [r3, #0x4]
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.atomic = 0;
 80073aa: 687b         	ldr	r3, [r7, #0x4]
 80073ac: 691b         	ldr	r3, [r3, #0x10]
 80073ae: 2200         	movs	r2, #0x0
 80073b0: 609a         	str	r2, [r3, #0x8]
; 	return 0;
 80073b2: 2300         	movs	r3, #0x0
; }
 80073b4: 4618         	mov	r0, r3
 80073b6: 3728         	adds	r7, #0x28
 80073b8: 46bd         	mov	sp, r7
 80073ba: bd80         	pop	{r7, pc}

080073bc <$d>:
 80073bc: 1c 92 01 08  	.word	0x0801921c
 80073c0: 0c 03 00 20  	.word	0x2000030c
 80073c4: 7c a7 01 08  	.word	0x0801a77c
 80073c8: 9c a7 01 08  	.word	0x0801a79c

080073cc <LL_DMA_EnableStream>:
; {
 80073cc: b480         	push	{r7}
 80073ce: b083         	sub	sp, #0xc
 80073d0: af00         	add	r7, sp, #0x0
 80073d2: 6078         	str	r0, [r7, #0x4]
 80073d4: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN);
 80073d6: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8007404 <LL_DMA_EnableStream+0x38>
 80073d8: 683b         	ldr	r3, [r7]
 80073da: 4413         	add	r3, r2
 80073dc: 781b         	ldrb	r3, [r3]
 80073de: 461a         	mov	r2, r3
 80073e0: 687b         	ldr	r3, [r7, #0x4]
 80073e2: 4413         	add	r3, r2
 80073e4: 681b         	ldr	r3, [r3]
 80073e6: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8007404 <LL_DMA_EnableStream+0x38>
 80073e8: 683a         	ldr	r2, [r7]
 80073ea: 440a         	add	r2, r1
 80073ec: 7812         	ldrb	r2, [r2]
 80073ee: 4611         	mov	r1, r2
 80073f0: 687a         	ldr	r2, [r7, #0x4]
 80073f2: 440a         	add	r2, r1
 80073f4: f043 0301    	orr	r3, r3, #0x1
 80073f8: 6013         	str	r3, [r2]
; }
 80073fa: bf00         	nop
 80073fc: 370c         	adds	r7, #0xc
 80073fe: 46bd         	mov	sp, r7
 8007400: bc80         	pop	{r7}
 8007402: 4770         	bx	lr

08007404 <$d>:
 8007404: 9c b6 01 08  	.word	0x0801b69c

08007408 <LL_DMA_DisableStream>:
; {
 8007408: b480         	push	{r7}
 800740a: b083         	sub	sp, #0xc
 800740c: af00         	add	r7, sp, #0x0
 800740e: 6078         	str	r0, [r7, #0x4]
 8007410: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN);
 8007412: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8007440 <LL_DMA_DisableStream+0x38>
 8007414: 683b         	ldr	r3, [r7]
 8007416: 4413         	add	r3, r2
 8007418: 781b         	ldrb	r3, [r3]
 800741a: 461a         	mov	r2, r3
 800741c: 687b         	ldr	r3, [r7, #0x4]
 800741e: 4413         	add	r3, r2
 8007420: 681b         	ldr	r3, [r3]
 8007422: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8007440 <LL_DMA_DisableStream+0x38>
 8007424: 683a         	ldr	r2, [r7]
 8007426: 440a         	add	r2, r1
 8007428: 7812         	ldrb	r2, [r2]
 800742a: 4611         	mov	r1, r2
 800742c: 687a         	ldr	r2, [r7, #0x4]
 800742e: 440a         	add	r2, r1
 8007430: f023 0301    	bic	r3, r3, #0x1
 8007434: 6013         	str	r3, [r2]
; }
 8007436: bf00         	nop
 8007438: 370c         	adds	r7, #0xc
 800743a: 46bd         	mov	sp, r7
 800743c: bc80         	pop	{r7}
 800743e: 4770         	bx	lr

08007440 <$d>:
 8007440: 9c b6 01 08  	.word	0x0801b69c

08007444 <LL_DMA_IsEnabledStream>:
; {
 8007444: b480         	push	{r7}
 8007446: b083         	sub	sp, #0xc
 8007448: af00         	add	r7, sp, #0x0
 800744a: 6078         	str	r0, [r7, #0x4]
 800744c: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN) == (DMA_SxCR_EN));
 800744e: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007478 <LL_DMA_IsEnabledStream+0x34>
 8007450: 683b         	ldr	r3, [r7]
 8007452: 4413         	add	r3, r2
 8007454: 781b         	ldrb	r3, [r3]
 8007456: 461a         	mov	r2, r3
 8007458: 687b         	ldr	r3, [r7, #0x4]
 800745a: 4413         	add	r3, r2
 800745c: 681b         	ldr	r3, [r3]
 800745e: f003 0301    	and	r3, r3, #0x1
 8007462: 2b01         	cmp	r3, #0x1
 8007464: bf0c         	ite	eq
 8007466: 2301         	moveq	r3, #0x1
 8007468: 2300         	movne	r3, #0x0
 800746a: b2db         	uxtb	r3, r3
; }
 800746c: 4618         	mov	r0, r3
 800746e: 370c         	adds	r7, #0xc
 8007470: 46bd         	mov	sp, r7
 8007472: bc80         	pop	{r7}
 8007474: 4770         	bx	lr
 8007476: bf00         	nop

08007478 <$d>:
 8007478: 9c b6 01 08  	.word	0x0801b69c

0800747c <LL_DMA_DisableIT_FE>:
; {
 800747c: b480         	push	{r7}
 800747e: b083         	sub	sp, #0xc
 8007480: af00         	add	r7, sp, #0x0
 8007482: 6078         	str	r0, [r7, #0x4]
 8007484: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 8007486: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80074b4 <LL_DMA_DisableIT_FE+0x38>
 8007488: 683b         	ldr	r3, [r7]
 800748a: 4413         	add	r3, r2
 800748c: 781b         	ldrb	r3, [r3]
 800748e: 461a         	mov	r2, r3
 8007490: 687b         	ldr	r3, [r7, #0x4]
 8007492: 4413         	add	r3, r2
 8007494: 695b         	ldr	r3, [r3, #0x14]
 8007496: 4907         	ldr	r1, [pc, #0x1c]         @ 0x80074b4 <LL_DMA_DisableIT_FE+0x38>
 8007498: 683a         	ldr	r2, [r7]
 800749a: 440a         	add	r2, r1
 800749c: 7812         	ldrb	r2, [r2]
 800749e: 4611         	mov	r1, r2
 80074a0: 687a         	ldr	r2, [r7, #0x4]
 80074a2: 440a         	add	r2, r1
 80074a4: f023 0380    	bic	r3, r3, #0x80
 80074a8: 6153         	str	r3, [r2, #0x14]
; }
 80074aa: bf00         	nop
 80074ac: 370c         	adds	r7, #0xc
 80074ae: 46bd         	mov	sp, r7
 80074b0: bc80         	pop	{r7}
 80074b2: 4770         	bx	lr

080074b4 <$d>:
 80074b4: 9c b6 01 08  	.word	0x0801b69c

080074b8 <LL_DMA_IsEnabledIT_HT>:
; {
 80074b8: b480         	push	{r7}
 80074ba: b083         	sub	sp, #0xc
 80074bc: af00         	add	r7, sp, #0x0
 80074be: 6078         	str	r0, [r7, #0x4]
 80074c0: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_HTIE) == DMA_SxCR_HTIE);
 80074c2: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80074ec <LL_DMA_IsEnabledIT_HT+0x34>
 80074c4: 683b         	ldr	r3, [r7]
 80074c6: 4413         	add	r3, r2
 80074c8: 781b         	ldrb	r3, [r3]
 80074ca: 461a         	mov	r2, r3
 80074cc: 687b         	ldr	r3, [r7, #0x4]
 80074ce: 4413         	add	r3, r2
 80074d0: 681b         	ldr	r3, [r3]
 80074d2: f003 0308    	and	r3, r3, #0x8
 80074d6: 2b08         	cmp	r3, #0x8
 80074d8: bf0c         	ite	eq
 80074da: 2301         	moveq	r3, #0x1
 80074dc: 2300         	movne	r3, #0x0
 80074de: b2db         	uxtb	r3, r3
; }
 80074e0: 4618         	mov	r0, r3
 80074e2: 370c         	adds	r7, #0xc
 80074e4: 46bd         	mov	sp, r7
 80074e6: bc80         	pop	{r7}
 80074e8: 4770         	bx	lr
 80074ea: bf00         	nop

080074ec <$d>:
 80074ec: 9c b6 01 08  	.word	0x0801b69c

080074f0 <LL_DMA_IsEnabledIT_TC>:
; {
 80074f0: b480         	push	{r7}
 80074f2: b083         	sub	sp, #0xc
 80074f4: af00         	add	r7, sp, #0x0
 80074f6: 6078         	str	r0, [r7, #0x4]
 80074f8: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE) == DMA_SxCR_TCIE);
 80074fa: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007524 <LL_DMA_IsEnabledIT_TC+0x34>
 80074fc: 683b         	ldr	r3, [r7]
 80074fe: 4413         	add	r3, r2
 8007500: 781b         	ldrb	r3, [r3]
 8007502: 461a         	mov	r2, r3
 8007504: 687b         	ldr	r3, [r7, #0x4]
 8007506: 4413         	add	r3, r2
 8007508: 681b         	ldr	r3, [r3]
 800750a: f003 0310    	and	r3, r3, #0x10
 800750e: 2b10         	cmp	r3, #0x10
 8007510: bf0c         	ite	eq
 8007512: 2301         	moveq	r3, #0x1
 8007514: 2300         	movne	r3, #0x0
 8007516: b2db         	uxtb	r3, r3
; }
 8007518: 4618         	mov	r0, r3
 800751a: 370c         	adds	r7, #0xc
 800751c: 46bd         	mov	sp, r7
 800751e: bc80         	pop	{r7}
 8007520: 4770         	bx	lr
 8007522: bf00         	nop

08007524 <$d>:
 8007524: 9c b6 01 08  	.word	0x0801b69c

08007528 <LL_DMA_IsEnabledIT_FE>:
; {
 8007528: b480         	push	{r7}
 800752a: b083         	sub	sp, #0xc
 800752c: af00         	add	r7, sp, #0x0
 800752e: 6078         	str	r0, [r7, #0x4]
 8007530: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE) == DMA_SxFCR_FEIE);
 8007532: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800755c <LL_DMA_IsEnabledIT_FE+0x34>
 8007534: 683b         	ldr	r3, [r7]
 8007536: 4413         	add	r3, r2
 8007538: 781b         	ldrb	r3, [r3]
 800753a: 461a         	mov	r2, r3
 800753c: 687b         	ldr	r3, [r7, #0x4]
 800753e: 4413         	add	r3, r2
 8007540: 695b         	ldr	r3, [r3, #0x14]
 8007542: f003 0380    	and	r3, r3, #0x80
 8007546: 2b80         	cmp	r3, #0x80
 8007548: bf0c         	ite	eq
 800754a: 2301         	moveq	r3, #0x1
 800754c: 2300         	movne	r3, #0x0
 800754e: b2db         	uxtb	r3, r3
; }
 8007550: 4618         	mov	r0, r3
 8007552: 370c         	adds	r7, #0xc
 8007554: 46bd         	mov	sp, r7
 8007556: bc80         	pop	{r7}
 8007558: 4770         	bx	lr
 800755a: bf00         	nop

0800755c <$d>:
 800755c: 9c b6 01 08  	.word	0x0801b69c

08007560 <dma_stm32_id_to_stream>:
; {
 8007560: b480         	push	{r7}
 8007562: b083         	sub	sp, #0xc
 8007564: af00         	add	r7, sp, #0x0
 8007566: 6078         	str	r0, [r7, #0x4]
; 	return stream_nr[id];
 8007568: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800757c <dma_stm32_id_to_stream+0x1c>
 800756a: 687b         	ldr	r3, [r7, #0x4]
 800756c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 8007570: 4618         	mov	r0, r3
 8007572: 370c         	adds	r7, #0xc
 8007574: 46bd         	mov	sp, r7
 8007576: bc80         	pop	{r7}
 8007578: 4770         	bx	lr
 800757a: bf00         	nop

0800757c <$d>:
 800757c: a4 b6 01 08  	.word	0x0801b6a4

08007580 <dma_stm32_slot_to_channel>:
; {
 8007580: b480         	push	{r7}
 8007582: b083         	sub	sp, #0xc
 8007584: af00         	add	r7, sp, #0x0
 8007586: 6078         	str	r0, [r7, #0x4]
; 	return channel_nr[slot];
 8007588: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800759c <dma_stm32_slot_to_channel+0x1c>
 800758a: 687b         	ldr	r3, [r7, #0x4]
 800758c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 8007590: 4618         	mov	r0, r3
 8007592: 370c         	adds	r7, #0xc
 8007594: 46bd         	mov	sp, r7
 8007596: bc80         	pop	{r7}
 8007598: 4770         	bx	lr
 800759a: bf00         	nop

0800759c <$d>:
 800759c: c4 b6 01 08  	.word	0x0801b6c4

080075a0 <dma_stm32_clear_ht>:
; {
 80075a0: b580         	push	{r7, lr}
 80075a2: b082         	sub	sp, #0x8
 80075a4: af00         	add	r7, sp, #0x0
 80075a6: 6078         	str	r0, [r7, #0x4]
 80075a8: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 80075aa: 4a05         	ldr	r2, [pc, #0x14]         @ 0x80075c0 <dma_stm32_clear_ht+0x20>
 80075ac: 683b         	ldr	r3, [r7]
 80075ae: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80075b2: 6878         	ldr	r0, [r7, #0x4]
 80075b4: 4798         	blx	r3
; }
 80075b6: bf00         	nop
 80075b8: 3708         	adds	r7, #0x8
 80075ba: 46bd         	mov	sp, r7
 80075bc: bd80         	pop	{r7, pc}
 80075be: bf00         	nop

080075c0 <$d>:
 80075c0: e4 b6 01 08  	.word	0x0801b6e4

080075c4 <dma_stm32_clear_tc>:
; {
 80075c4: b580         	push	{r7, lr}
 80075c6: b082         	sub	sp, #0x8
 80075c8: af00         	add	r7, sp, #0x0
 80075ca: 6078         	str	r0, [r7, #0x4]
 80075cc: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 80075ce: 4a05         	ldr	r2, [pc, #0x14]         @ 0x80075e4 <dma_stm32_clear_tc+0x20>
 80075d0: 683b         	ldr	r3, [r7]
 80075d2: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80075d6: 6878         	ldr	r0, [r7, #0x4]
 80075d8: 4798         	blx	r3
; }
 80075da: bf00         	nop
 80075dc: 3708         	adds	r7, #0x8
 80075de: 46bd         	mov	sp, r7
 80075e0: bd80         	pop	{r7, pc}
 80075e2: bf00         	nop

080075e4 <$d>:
 80075e4: 04 b7 01 08  	.word	0x0801b704

080075e8 <dma_stm32_is_ht_active>:
; {
 80075e8: b580         	push	{r7, lr}
 80075ea: b082         	sub	sp, #0x8
 80075ec: af00         	add	r7, sp, #0x0
 80075ee: 6078         	str	r0, [r7, #0x4]
 80075f0: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 80075f2: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8007614 <dma_stm32_is_ht_active+0x2c>
 80075f4: 683b         	ldr	r3, [r7]
 80075f6: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80075fa: 6878         	ldr	r0, [r7, #0x4]
 80075fc: 4798         	blx	r3
 80075fe: 4603         	mov	r3, r0
 8007600: 2b00         	cmp	r3, #0x0
 8007602: bf14         	ite	ne
 8007604: 2301         	movne	r3, #0x1
 8007606: 2300         	moveq	r3, #0x0
 8007608: b2db         	uxtb	r3, r3
; }
 800760a: 4618         	mov	r0, r3
 800760c: 3708         	adds	r7, #0x8
 800760e: 46bd         	mov	sp, r7
 8007610: bd80         	pop	{r7, pc}
 8007612: bf00         	nop

08007614 <$d>:
 8007614: 24 b7 01 08  	.word	0x0801b724

08007618 <dma_stm32_is_tc_active>:
; {
 8007618: b580         	push	{r7, lr}
 800761a: b082         	sub	sp, #0x8
 800761c: af00         	add	r7, sp, #0x0
 800761e: 6078         	str	r0, [r7, #0x4]
 8007620: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 8007622: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8007644 <dma_stm32_is_tc_active+0x2c>
 8007624: 683b         	ldr	r3, [r7]
 8007626: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800762a: 6878         	ldr	r0, [r7, #0x4]
 800762c: 4798         	blx	r3
 800762e: 4603         	mov	r3, r0
 8007630: 2b00         	cmp	r3, #0x0
 8007632: bf14         	ite	ne
 8007634: 2301         	movne	r3, #0x1
 8007636: 2300         	moveq	r3, #0x0
 8007638: b2db         	uxtb	r3, r3
; }
 800763a: 4618         	mov	r0, r3
 800763c: 3708         	adds	r7, #0x8
 800763e: 46bd         	mov	sp, r7
 8007640: bd80         	pop	{r7, pc}
 8007642: bf00         	nop

08007644 <$d>:
 8007644: 44 b7 01 08  	.word	0x0801b744

08007648 <dma_stm32_clear_te>:
; {
 8007648: b580         	push	{r7, lr}
 800764a: b082         	sub	sp, #0x8
 800764c: af00         	add	r7, sp, #0x0
 800764e: 6078         	str	r0, [r7, #0x4]
 8007650: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 8007652: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8007668 <dma_stm32_clear_te+0x20>
 8007654: 683b         	ldr	r3, [r7]
 8007656: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800765a: 6878         	ldr	r0, [r7, #0x4]
 800765c: 4798         	blx	r3
; }
 800765e: bf00         	nop
 8007660: 3708         	adds	r7, #0x8
 8007662: 46bd         	mov	sp, r7
 8007664: bd80         	pop	{r7, pc}
 8007666: bf00         	nop

08007668 <$d>:
 8007668: 64 b7 01 08  	.word	0x0801b764

0800766c <dma_stm32_clear_dme>:
; {
 800766c: b580         	push	{r7, lr}
 800766e: b082         	sub	sp, #0x8
 8007670: af00         	add	r7, sp, #0x0
 8007672: 6078         	str	r0, [r7, #0x4]
 8007674: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 8007676: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800768c <dma_stm32_clear_dme+0x20>
 8007678: 683b         	ldr	r3, [r7]
 800767a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800767e: 6878         	ldr	r0, [r7, #0x4]
 8007680: 4798         	blx	r3
; }
 8007682: bf00         	nop
 8007684: 3708         	adds	r7, #0x8
 8007686: 46bd         	mov	sp, r7
 8007688: bd80         	pop	{r7, pc}
 800768a: bf00         	nop

0800768c <$d>:
 800768c: 84 b7 01 08  	.word	0x0801b784

08007690 <dma_stm32_clear_fe>:
; {
 8007690: b580         	push	{r7, lr}
 8007692: b082         	sub	sp, #0x8
 8007694: af00         	add	r7, sp, #0x0
 8007696: 6078         	str	r0, [r7, #0x4]
 8007698: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800769a: 4a05         	ldr	r2, [pc, #0x14]         @ 0x80076b0 <dma_stm32_clear_fe+0x20>
 800769c: 683b         	ldr	r3, [r7]
 800769e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80076a2: 6878         	ldr	r0, [r7, #0x4]
 80076a4: 4798         	blx	r3
; }
 80076a6: bf00         	nop
 80076a8: 3708         	adds	r7, #0x8
 80076aa: 46bd         	mov	sp, r7
 80076ac: bd80         	pop	{r7, pc}
 80076ae: bf00         	nop

080076b0 <$d>:
 80076b0: a4 b7 01 08  	.word	0x0801b7a4

080076b4 <dma_stm32_is_te_active>:
; {
 80076b4: b580         	push	{r7, lr}
 80076b6: b082         	sub	sp, #0x8
 80076b8: af00         	add	r7, sp, #0x0
 80076ba: 6078         	str	r0, [r7, #0x4]
 80076bc: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 80076be: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80076e0 <dma_stm32_is_te_active+0x2c>
 80076c0: 683b         	ldr	r3, [r7]
 80076c2: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80076c6: 6878         	ldr	r0, [r7, #0x4]
 80076c8: 4798         	blx	r3
 80076ca: 4603         	mov	r3, r0
 80076cc: 2b00         	cmp	r3, #0x0
 80076ce: bf14         	ite	ne
 80076d0: 2301         	movne	r3, #0x1
 80076d2: 2300         	moveq	r3, #0x0
 80076d4: b2db         	uxtb	r3, r3
; }
 80076d6: 4618         	mov	r0, r3
 80076d8: 3708         	adds	r7, #0x8
 80076da: 46bd         	mov	sp, r7
 80076dc: bd80         	pop	{r7, pc}
 80076de: bf00         	nop

080076e0 <$d>:
 80076e0: c4 b7 01 08  	.word	0x0801b7c4

080076e4 <dma_stm32_is_dme_active>:
; {
 80076e4: b580         	push	{r7, lr}
 80076e6: b082         	sub	sp, #0x8
 80076e8: af00         	add	r7, sp, #0x0
 80076ea: 6078         	str	r0, [r7, #0x4]
 80076ec: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 80076ee: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8007710 <dma_stm32_is_dme_active+0x2c>
 80076f0: 683b         	ldr	r3, [r7]
 80076f2: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80076f6: 6878         	ldr	r0, [r7, #0x4]
 80076f8: 4798         	blx	r3
 80076fa: 4603         	mov	r3, r0
 80076fc: 2b00         	cmp	r3, #0x0
 80076fe: bf14         	ite	ne
 8007700: 2301         	movne	r3, #0x1
 8007702: 2300         	moveq	r3, #0x0
 8007704: b2db         	uxtb	r3, r3
; }
 8007706: 4618         	mov	r0, r3
 8007708: 3708         	adds	r7, #0x8
 800770a: 46bd         	mov	sp, r7
 800770c: bd80         	pop	{r7, pc}
 800770e: bf00         	nop

08007710 <$d>:
 8007710: e4 b7 01 08  	.word	0x0801b7e4

08007714 <dma_stm32_is_fe_active>:
; {
 8007714: b580         	push	{r7, lr}
 8007716: b082         	sub	sp, #0x8
 8007718: af00         	add	r7, sp, #0x0
 800771a: 6078         	str	r0, [r7, #0x4]
 800771c: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800771e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8007740 <dma_stm32_is_fe_active+0x2c>
 8007720: 683b         	ldr	r3, [r7]
 8007722: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8007726: 6878         	ldr	r0, [r7, #0x4]
 8007728: 4798         	blx	r3
 800772a: 4603         	mov	r3, r0
 800772c: 2b00         	cmp	r3, #0x0
 800772e: bf14         	ite	ne
 8007730: 2301         	movne	r3, #0x1
 8007732: 2300         	moveq	r3, #0x0
 8007734: b2db         	uxtb	r3, r3
; }
 8007736: 4618         	mov	r0, r3
 8007738: 3708         	adds	r7, #0x8
 800773a: 46bd         	mov	sp, r7
 800773c: bd80         	pop	{r7, pc}
 800773e: bf00         	nop

08007740 <$d>:
 8007740: 04 b8 01 08  	.word	0x0801b804

08007744 <stm32_dma_dump_stream_irq>:
; {
 8007744: b5f0         	push	{r4, r5, r6, r7, lr}
 8007746: b08f         	sub	sp, #0x3c
 8007748: af08         	add	r7, sp, #0x20
 800774a: 60f8         	str	r0, [r7, #0xc]
 800774c: 60b9         	str	r1, [r7, #0x8]
; 	LOG_INF("tc: %d, ht: %d, te: %d, dme: %d, fe: %d",
 800774e: 2303         	movs	r3, #0x3
 8007750: 2b02         	cmp	r3, #0x2
 8007752: d93c         	bls	0x80077ce <stm32_dma_dump_stream_irq+0x8a> @ imm = #0x78
 8007754: 2301         	movs	r3, #0x1
 8007756: 74fb         	strb	r3, [r7, #0x13]
 8007758: 7cfb         	ldrb	r3, [r7, #0x13]
 800775a: f083 0301    	eor	r3, r3, #0x1
 800775e: b2db         	uxtb	r3, r3
 8007760: 2b00         	cmp	r3, #0x0
 8007762: d134         	bne	0x80077ce <stm32_dma_dump_stream_irq+0x8a> @ imm = #0x68
 8007764: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80077d8 <stm32_dma_dump_stream_irq+0x94>
 8007766: 681c         	ldr	r4, [r3]
 8007768: 68b9         	ldr	r1, [r7, #0x8]
 800776a: 68f8         	ldr	r0, [r7, #0xc]
 800776c: f7ff ff54    	bl	0x8007618 <dma_stm32_is_tc_active> @ imm = #-0x158
 8007770: 4603         	mov	r3, r0
 8007772: 461d         	mov	r5, r3
 8007774: 68b9         	ldr	r1, [r7, #0x8]
 8007776: 68f8         	ldr	r0, [r7, #0xc]
 8007778: f7ff ff36    	bl	0x80075e8 <dma_stm32_is_ht_active> @ imm = #-0x194
 800777c: 4603         	mov	r3, r0
 800777e: 461e         	mov	r6, r3
 8007780: 68b9         	ldr	r1, [r7, #0x8]
 8007782: 68f8         	ldr	r0, [r7, #0xc]
 8007784: f7ff ff96    	bl	0x80076b4 <dma_stm32_is_te_active> @ imm = #-0xd4
 8007788: 4603         	mov	r3, r0
 800778a: 607b         	str	r3, [r7, #0x4]
 800778c: 68b9         	ldr	r1, [r7, #0x8]
 800778e: 68f8         	ldr	r0, [r7, #0xc]
 8007790: f7ff ffa8    	bl	0x80076e4 <dma_stm32_is_dme_active> @ imm = #-0xb0
 8007794: 4603         	mov	r3, r0
 8007796: 603b         	str	r3, [r7]
 8007798: 68b9         	ldr	r1, [r7, #0x8]
 800779a: 68f8         	ldr	r0, [r7, #0xc]
 800779c: f7ff ffba    	bl	0x8007714 <dma_stm32_is_fe_active> @ imm = #-0x8c
 80077a0: 4603         	mov	r3, r0
 80077a2: 9307         	str	r3, [sp, #0x1c]
 80077a4: 683a         	ldr	r2, [r7]
 80077a6: 9206         	str	r2, [sp, #0x18]
 80077a8: 687b         	ldr	r3, [r7, #0x4]
 80077aa: 9305         	str	r3, [sp, #0x14]
 80077ac: 9604         	str	r6, [sp, #0x10]
 80077ae: 9503         	str	r5, [sp, #0xc]
 80077b0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80077dc <stm32_dma_dump_stream_irq+0x98>
 80077b2: 9302         	str	r3, [sp, #0x8]
 80077b4: 2300         	movs	r3, #0x0
 80077b6: 9301         	str	r3, [sp, #0x4]
 80077b8: 2300         	movs	r3, #0x0
 80077ba: 9300         	str	r3, [sp]
 80077bc: 2300         	movs	r3, #0x0
 80077be: 2203         	movs	r2, #0x3
 80077c0: 4621         	mov	r1, r4
 80077c2: 2000         	movs	r0, #0x0
 80077c4: f00c f93f    	bl	0x8013a46 <z_log_msg_runtime_create> @ imm = #0xc27e
 80077c8: 2300         	movs	r3, #0x0
 80077ca: 617b         	str	r3, [r7, #0x14]
; }
 80077cc: bf00         	nop
 80077ce: bf00         	nop
 80077d0: 371c         	adds	r7, #0x1c
 80077d2: 46bd         	mov	sp, r7
 80077d4: bdf0         	pop	{r4, r5, r6, r7, pc}
 80077d6: bf00         	nop

080077d8 <$d>:
 80077d8: 10 03 00 20  	.word	0x20000310
 80077dc: d0 a7 01 08  	.word	0x0801a7d0

080077e0 <stm32_dma_is_unexpected_irq_happened>:
; {
 80077e0: b580         	push	{r7, lr}
 80077e2: b088         	sub	sp, #0x20
 80077e4: af04         	add	r7, sp, #0x10
 80077e6: 6078         	str	r0, [r7, #0x4]
 80077e8: 6039         	str	r1, [r7]
; 	if (LL_DMA_IsEnabledIT_FE(dma, dma_stm32_id_to_stream(id)) &&
 80077ea: 6838         	ldr	r0, [r7]
 80077ec: f7ff feb8    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0x290
 80077f0: 4603         	mov	r3, r0
 80077f2: 4619         	mov	r1, r3
 80077f4: 6878         	ldr	r0, [r7, #0x4]
 80077f6: f7ff fe97    	bl	0x8007528 <LL_DMA_IsEnabledIT_FE> @ imm = #-0x2d2
 80077fa: 4603         	mov	r3, r0
 80077fc: 2b00         	cmp	r3, #0x0
 80077fe: d02a         	beq	0x8007856 <stm32_dma_is_unexpected_irq_happened+0x76> @ imm = #0x54
; 	    dma_stm32_is_fe_active(dma, id)) {
 8007800: 6839         	ldr	r1, [r7]
 8007802: 6878         	ldr	r0, [r7, #0x4]
 8007804: f7ff ff86    	bl	0x8007714 <dma_stm32_is_fe_active> @ imm = #-0xf4
 8007808: 4603         	mov	r3, r0
; 	if (LL_DMA_IsEnabledIT_FE(dma, dma_stm32_id_to_stream(id)) &&
 800780a: 2b00         	cmp	r3, #0x0
 800780c: d023         	beq	0x8007856 <stm32_dma_is_unexpected_irq_happened+0x76> @ imm = #0x46
; 		LOG_ERR("FiFo error.");
 800780e: 2303         	movs	r3, #0x3
 8007810: 2b00         	cmp	r3, #0x0
 8007812: d016         	beq	0x8007842 <stm32_dma_is_unexpected_irq_happened+0x62> @ imm = #0x2c
 8007814: 2301         	movs	r3, #0x1
 8007816: 73fb         	strb	r3, [r7, #0xf]
 8007818: 7bfb         	ldrb	r3, [r7, #0xf]
 800781a: f083 0301    	eor	r3, r3, #0x1
 800781e: b2db         	uxtb	r3, r3
 8007820: 2b00         	cmp	r3, #0x0
 8007822: d10e         	bne	0x8007842 <stm32_dma_is_unexpected_irq_happened+0x62> @ imm = #0x1c
 8007824: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8007860 <stm32_dma_is_unexpected_irq_happened+0x80>
 8007826: 6819         	ldr	r1, [r3]
 8007828: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8007864 <stm32_dma_is_unexpected_irq_happened+0x84>
 800782a: 9302         	str	r3, [sp, #0x8]
 800782c: 2300         	movs	r3, #0x0
 800782e: 9301         	str	r3, [sp, #0x4]
 8007830: 2300         	movs	r3, #0x0
 8007832: 9300         	str	r3, [sp]
 8007834: 2300         	movs	r3, #0x0
 8007836: 2201         	movs	r2, #0x1
 8007838: 2000         	movs	r0, #0x0
 800783a: f00c f904    	bl	0x8013a46 <z_log_msg_runtime_create> @ imm = #0xc208
 800783e: 2300         	movs	r3, #0x0
 8007840: 60bb         	str	r3, [r7, #0x8]
; 		stm32_dma_dump_stream_irq(dma, id);
 8007842: 6839         	ldr	r1, [r7]
 8007844: 6878         	ldr	r0, [r7, #0x4]
 8007846: f7ff ff7d    	bl	0x8007744 <stm32_dma_dump_stream_irq> @ imm = #-0x106
; 		stm32_dma_clear_stream_irq(dma, id);
 800784a: 6839         	ldr	r1, [r7]
 800784c: 6878         	ldr	r0, [r7, #0x4]
 800784e: f00c f95a    	bl	0x8013b06 <stm32_dma_clear_stream_irq> @ imm = #0xc2b4
; 		return true;
 8007852: 2301         	movs	r3, #0x1
 8007854: e000         	b	0x8007858 <stm32_dma_is_unexpected_irq_happened+0x78> @ imm = #0x0
; 	return false;
 8007856: 2300         	movs	r3, #0x0
; }
 8007858: 4618         	mov	r0, r3
 800785a: 3710         	adds	r7, #0x10
 800785c: 46bd         	mov	sp, r7
 800785e: bd80         	pop	{r7, pc}

08007860 <$d>:
 8007860: 10 03 00 20  	.word	0x20000310
 8007864: f8 a7 01 08  	.word	0x0801a7f8

08007868 <stm32_dma_get_mburst>:
; {
 8007868: b580         	push	{r7, lr}
 800786a: b08a         	sub	sp, #0x28
 800786c: af04         	add	r7, sp, #0x10
 800786e: 6078         	str	r0, [r7, #0x4]
 8007870: 460b         	mov	r3, r1
 8007872: 70fb         	strb	r3, [r7, #0x3]
; 	if (source_periph) {
 8007874: 78fb         	ldrb	r3, [r7, #0x3]
 8007876: 2b00         	cmp	r3, #0x0
 8007878: d003         	beq	0x8007882 <stm32_dma_get_mburst+0x1a> @ imm = #0x6
; 		memory_burst = config->dest_burst_length;
 800787a: 687b         	ldr	r3, [r7, #0x4]
 800787c: 895b         	ldrh	r3, [r3, #0xa]
 800787e: 617b         	str	r3, [r7, #0x14]
 8007880: e002         	b	0x8007888 <stm32_dma_get_mburst+0x20> @ imm = #0x4
; 		memory_burst = config->source_burst_length;
 8007882: 687b         	ldr	r3, [r7, #0x4]
 8007884: 891b         	ldrh	r3, [r3, #0x8]
 8007886: 617b         	str	r3, [r7, #0x14]
; 	switch (memory_burst) {
 8007888: 697b         	ldr	r3, [r7, #0x14]
 800788a: 3b01         	subs	r3, #0x1
 800788c: 2b0f         	cmp	r3, #0xf
 800788e: d82e         	bhi	0x80078ee <stm32_dma_get_mburst+0x86> @ imm = #0x5c
 8007890: a201         	adr	r2, #4 <stm32_dma_get_mburst+0x2d>
 8007892: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8007896: bf00         	nop

08007898 <$d>:
 8007898: d9 78 00 08  	.word	0x080078d9
 800789c: ef 78 00 08  	.word	0x080078ef
 80078a0: ef 78 00 08  	.word	0x080078ef
 80078a4: dd 78 00 08  	.word	0x080078dd
 80078a8: ef 78 00 08  	.word	0x080078ef
 80078ac: ef 78 00 08  	.word	0x080078ef
 80078b0: ef 78 00 08  	.word	0x080078ef
 80078b4: e3 78 00 08  	.word	0x080078e3
 80078b8: ef 78 00 08  	.word	0x080078ef
 80078bc: ef 78 00 08  	.word	0x080078ef
 80078c0: ef 78 00 08  	.word	0x080078ef
 80078c4: ef 78 00 08  	.word	0x080078ef
 80078c8: ef 78 00 08  	.word	0x080078ef
 80078cc: ef 78 00 08  	.word	0x080078ef
 80078d0: ef 78 00 08  	.word	0x080078ef
 80078d4: e9 78 00 08  	.word	0x080078e9

080078d8 <$t>:
; 		return LL_DMA_MBURST_SINGLE;
 80078d8: 2300         	movs	r3, #0x0
 80078da: e023         	b	0x8007924 <stm32_dma_get_mburst+0xbc> @ imm = #0x46
; 		return LL_DMA_MBURST_INC4;
 80078dc: f44f 0300    	mov.w	r3, #0x800000
 80078e0: e020         	b	0x8007924 <stm32_dma_get_mburst+0xbc> @ imm = #0x40
; 		return LL_DMA_MBURST_INC8;
 80078e2: f04f 7380    	mov.w	r3, #0x1000000
 80078e6: e01d         	b	0x8007924 <stm32_dma_get_mburst+0xbc> @ imm = #0x3a
; 		return LL_DMA_MBURST_INC16;
 80078e8: f04f 73c0    	mov.w	r3, #0x1800000
 80078ec: e01a         	b	0x8007924 <stm32_dma_get_mburst+0xbc> @ imm = #0x34
; 		LOG_ERR("Memory burst size error,"
 80078ee: 2303         	movs	r3, #0x3
 80078f0: 2b00         	cmp	r3, #0x0
 80078f2: d016         	beq	0x8007922 <stm32_dma_get_mburst+0xba> @ imm = #0x2c
 80078f4: 2301         	movs	r3, #0x1
 80078f6: 74fb         	strb	r3, [r7, #0x13]
 80078f8: 7cfb         	ldrb	r3, [r7, #0x13]
 80078fa: f083 0301    	eor	r3, r3, #0x1
 80078fe: b2db         	uxtb	r3, r3
 8007900: 2b00         	cmp	r3, #0x0
 8007902: d10e         	bne	0x8007922 <stm32_dma_get_mburst+0xba> @ imm = #0x1c
 8007904: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800792c <stm32_dma_get_mburst+0xc4>
 8007906: 6819         	ldr	r1, [r3]
 8007908: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8007930 <stm32_dma_get_mburst+0xc8>
 800790a: 9302         	str	r3, [sp, #0x8]
 800790c: 2300         	movs	r3, #0x0
 800790e: 9301         	str	r3, [sp, #0x4]
 8007910: 2300         	movs	r3, #0x0
 8007912: 9300         	str	r3, [sp]
 8007914: 2300         	movs	r3, #0x0
 8007916: 2201         	movs	r2, #0x1
 8007918: 2000         	movs	r0, #0x0
 800791a: f00c f894    	bl	0x8013a46 <z_log_msg_runtime_create> @ imm = #0xc128
 800791e: 2300         	movs	r3, #0x0
 8007920: 60fb         	str	r3, [r7, #0xc]
; 		return LL_DMA_MBURST_SINGLE;
 8007922: 2300         	movs	r3, #0x0
; }
 8007924: 4618         	mov	r0, r3
 8007926: 3718         	adds	r7, #0x18
 8007928: 46bd         	mov	sp, r7
 800792a: bd80         	pop	{r7, pc}

0800792c <$d>:
 800792c: 10 03 00 20  	.word	0x20000310
 8007930: 04 a8 01 08  	.word	0x0801a804

08007934 <stm32_dma_get_pburst>:
; {
 8007934: b580         	push	{r7, lr}
 8007936: b08a         	sub	sp, #0x28
 8007938: af04         	add	r7, sp, #0x10
 800793a: 6078         	str	r0, [r7, #0x4]
 800793c: 460b         	mov	r3, r1
 800793e: 70fb         	strb	r3, [r7, #0x3]
; 	if (source_periph) {
 8007940: 78fb         	ldrb	r3, [r7, #0x3]
 8007942: 2b00         	cmp	r3, #0x0
 8007944: d003         	beq	0x800794e <stm32_dma_get_pburst+0x1a> @ imm = #0x6
; 		periph_burst = config->source_burst_length;
 8007946: 687b         	ldr	r3, [r7, #0x4]
 8007948: 891b         	ldrh	r3, [r3, #0x8]
 800794a: 617b         	str	r3, [r7, #0x14]
 800794c: e002         	b	0x8007954 <stm32_dma_get_pburst+0x20> @ imm = #0x4
; 		periph_burst = config->dest_burst_length;
 800794e: 687b         	ldr	r3, [r7, #0x4]
 8007950: 895b         	ldrh	r3, [r3, #0xa]
 8007952: 617b         	str	r3, [r7, #0x14]
; 	switch (periph_burst) {
 8007954: 697b         	ldr	r3, [r7, #0x14]
 8007956: 3b01         	subs	r3, #0x1
 8007958: 2b0f         	cmp	r3, #0xf
 800795a: d82e         	bhi	0x80079ba <stm32_dma_get_pburst+0x86> @ imm = #0x5c
 800795c: a201         	adr	r2, #4 <stm32_dma_get_pburst+0x2d>
 800795e: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8007962: bf00         	nop

08007964 <$d>:
 8007964: a5 79 00 08  	.word	0x080079a5
 8007968: bb 79 00 08  	.word	0x080079bb
 800796c: bb 79 00 08  	.word	0x080079bb
 8007970: a9 79 00 08  	.word	0x080079a9
 8007974: bb 79 00 08  	.word	0x080079bb
 8007978: bb 79 00 08  	.word	0x080079bb
 800797c: bb 79 00 08  	.word	0x080079bb
 8007980: af 79 00 08  	.word	0x080079af
 8007984: bb 79 00 08  	.word	0x080079bb
 8007988: bb 79 00 08  	.word	0x080079bb
 800798c: bb 79 00 08  	.word	0x080079bb
 8007990: bb 79 00 08  	.word	0x080079bb
 8007994: bb 79 00 08  	.word	0x080079bb
 8007998: bb 79 00 08  	.word	0x080079bb
 800799c: bb 79 00 08  	.word	0x080079bb
 80079a0: b5 79 00 08  	.word	0x080079b5

080079a4 <$t>:
; 		return LL_DMA_PBURST_SINGLE;
 80079a4: 2300         	movs	r3, #0x0
 80079a6: e023         	b	0x80079f0 <stm32_dma_get_pburst+0xbc> @ imm = #0x46
; 		return LL_DMA_PBURST_INC4;
 80079a8: f44f 1300    	mov.w	r3, #0x200000
 80079ac: e020         	b	0x80079f0 <stm32_dma_get_pburst+0xbc> @ imm = #0x40
; 		return LL_DMA_PBURST_INC8;
 80079ae: f44f 0380    	mov.w	r3, #0x400000
 80079b2: e01d         	b	0x80079f0 <stm32_dma_get_pburst+0xbc> @ imm = #0x3a
; 		return LL_DMA_PBURST_INC16;
 80079b4: f44f 03c0    	mov.w	r3, #0x600000
 80079b8: e01a         	b	0x80079f0 <stm32_dma_get_pburst+0xbc> @ imm = #0x34
; 		LOG_ERR("Peripheral burst size error,"
 80079ba: 2303         	movs	r3, #0x3
 80079bc: 2b00         	cmp	r3, #0x0
 80079be: d016         	beq	0x80079ee <stm32_dma_get_pburst+0xba> @ imm = #0x2c
 80079c0: 2301         	movs	r3, #0x1
 80079c2: 74fb         	strb	r3, [r7, #0x13]
 80079c4: 7cfb         	ldrb	r3, [r7, #0x13]
 80079c6: f083 0301    	eor	r3, r3, #0x1
 80079ca: b2db         	uxtb	r3, r3
 80079cc: 2b00         	cmp	r3, #0x0
 80079ce: d10e         	bne	0x80079ee <stm32_dma_get_pburst+0xba> @ imm = #0x1c
 80079d0: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80079f8 <stm32_dma_get_pburst+0xc4>
 80079d2: 6819         	ldr	r1, [r3]
 80079d4: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80079fc <stm32_dma_get_pburst+0xc8>
 80079d6: 9302         	str	r3, [sp, #0x8]
 80079d8: 2300         	movs	r3, #0x0
 80079da: 9301         	str	r3, [sp, #0x4]
 80079dc: 2300         	movs	r3, #0x0
 80079de: 9300         	str	r3, [sp]
 80079e0: 2300         	movs	r3, #0x0
 80079e2: 2201         	movs	r2, #0x1
 80079e4: 2000         	movs	r0, #0x0
 80079e6: f00c f82e    	bl	0x8013a46 <z_log_msg_runtime_create> @ imm = #0xc05c
 80079ea: 2300         	movs	r3, #0x0
 80079ec: 60fb         	str	r3, [r7, #0xc]
; 		return LL_DMA_PBURST_SINGLE;
 80079ee: 2300         	movs	r3, #0x0
; }
 80079f0: 4618         	mov	r0, r3
 80079f2: 3718         	adds	r7, #0x18
 80079f4: 46bd         	mov	sp, r7
 80079f6: bd80         	pop	{r7, pc}

080079f8 <$d>:
 80079f8: 10 03 00 20  	.word	0x20000310
 80079fc: 3c a8 01 08  	.word	0x0801a83c

08007a00 <stm32_dma_get_fifo_threshold>:
; {
 8007a00: b580         	push	{r7, lr}
 8007a02: b088         	sub	sp, #0x20
 8007a04: af04         	add	r7, sp, #0x10
 8007a06: 4603         	mov	r3, r0
 8007a08: 80fb         	strh	r3, [r7, #0x6]
; 	switch (fifo_mode_control) {
 8007a0a: 88fb         	ldrh	r3, [r7, #0x6]
 8007a0c: 2b03         	cmp	r3, #0x3
 8007a0e: d813         	bhi	0x8007a38 <stm32_dma_get_fifo_threshold+0x38> @ imm = #0x26
 8007a10: a201         	adr	r2, #4 <stm32_dma_get_fifo_threshold+0x15>
 8007a12: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8007a16: bf00         	nop

08007a18 <$d>:
 8007a18: 29 7a 00 08  	.word	0x08007a29
 8007a1c: 2d 7a 00 08  	.word	0x08007a2d
 8007a20: 31 7a 00 08  	.word	0x08007a31
 8007a24: 35 7a 00 08  	.word	0x08007a35

08007a28 <$t>:
; 		return LL_DMA_FIFOTHRESHOLD_1_4;
 8007a28: 2300         	movs	r3, #0x0
 8007a2a: e020         	b	0x8007a6e <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x40
; 		return LL_DMA_FIFOTHRESHOLD_1_2;
 8007a2c: 2301         	movs	r3, #0x1
 8007a2e: e01e         	b	0x8007a6e <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x3c
; 		return LL_DMA_FIFOTHRESHOLD_3_4;
 8007a30: 2302         	movs	r3, #0x2
 8007a32: e01c         	b	0x8007a6e <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x38
; 		return LL_DMA_FIFOTHRESHOLD_FULL;
 8007a34: 2303         	movs	r3, #0x3
 8007a36: e01a         	b	0x8007a6e <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x34
; 		LOG_WRN("FIFO threshold parameter error, reset to 1/4");
 8007a38: 2303         	movs	r3, #0x3
 8007a3a: 2b01         	cmp	r3, #0x1
 8007a3c: d916         	bls	0x8007a6c <stm32_dma_get_fifo_threshold+0x6c> @ imm = #0x2c
 8007a3e: 2301         	movs	r3, #0x1
 8007a40: 73fb         	strb	r3, [r7, #0xf]
 8007a42: 7bfb         	ldrb	r3, [r7, #0xf]
 8007a44: f083 0301    	eor	r3, r3, #0x1
 8007a48: b2db         	uxtb	r3, r3
 8007a4a: 2b00         	cmp	r3, #0x0
 8007a4c: d10e         	bne	0x8007a6c <stm32_dma_get_fifo_threshold+0x6c> @ imm = #0x1c
 8007a4e: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8007a78 <stm32_dma_get_fifo_threshold+0x78>
 8007a50: 6819         	ldr	r1, [r3]
 8007a52: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8007a7c <stm32_dma_get_fifo_threshold+0x7c>
 8007a54: 9302         	str	r3, [sp, #0x8]
 8007a56: 2300         	movs	r3, #0x0
 8007a58: 9301         	str	r3, [sp, #0x4]
 8007a5a: 2300         	movs	r3, #0x0
 8007a5c: 9300         	str	r3, [sp]
 8007a5e: 2300         	movs	r3, #0x0
 8007a60: 2202         	movs	r2, #0x2
 8007a62: 2000         	movs	r0, #0x0
 8007a64: f00b ffef    	bl	0x8013a46 <z_log_msg_runtime_create> @ imm = #0xbfde
 8007a68: 2300         	movs	r3, #0x0
 8007a6a: 60bb         	str	r3, [r7, #0x8]
; 		return LL_DMA_FIFOTHRESHOLD_1_4;
 8007a6c: 2300         	movs	r3, #0x0
; }
 8007a6e: 4618         	mov	r0, r3
 8007a70: 3710         	adds	r7, #0x10
 8007a72: 46bd         	mov	sp, r7
 8007a74: bd80         	pop	{r7, pc}
 8007a76: bf00         	nop

08007a78 <$d>:
 8007a78: 10 03 00 20  	.word	0x20000310
 8007a7c: 78 a8 01 08  	.word	0x0801a878

08007a80 <gpio_stm32_clock_request>:
; {
 8007a80: b580         	push	{r7, lr}
 8007a82: b086         	sub	sp, #0x18
 8007a84: af00         	add	r7, sp, #0x0
 8007a86: 6078         	str	r0, [r7, #0x4]
 8007a88: 460b         	mov	r3, r1
 8007a8a: 70fb         	strb	r3, [r7, #0x3]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8007a8c: 687b         	ldr	r3, [r7, #0x4]
 8007a8e: 685b         	ldr	r3, [r3, #0x4]
 8007a90: 613b         	str	r3, [r7, #0x10]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8007a92: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007ac4 <gpio_stm32_clock_request+0x44>
 8007a94: 60fb         	str	r3, [r7, #0xc]
; 	if (on) {
 8007a96: 78fb         	ldrb	r3, [r7, #0x3]
 8007a98: 2b00         	cmp	r3, #0x0
 8007a9a: d007         	beq	0x8007aac <gpio_stm32_clock_request+0x2c> @ imm = #0xe
; 					(clock_control_subsys_t)&cfg->pclken);
 8007a9c: 693b         	ldr	r3, [r7, #0x10]
 8007a9e: 330c         	adds	r3, #0xc
; 		ret = clock_control_on(clk,
 8007aa0: 4619         	mov	r1, r3
 8007aa2: 68f8         	ldr	r0, [r7, #0xc]
 8007aa4: f00c fb80    	bl	0x80141a8 <clock_control_on> @ imm = #0xc700
 8007aa8: 6178         	str	r0, [r7, #0x14]
 8007aaa: e006         	b	0x8007aba <gpio_stm32_clock_request+0x3a> @ imm = #0xc
; 					(clock_control_subsys_t)&cfg->pclken);
 8007aac: 693b         	ldr	r3, [r7, #0x10]
 8007aae: 330c         	adds	r3, #0xc
; 		ret = clock_control_off(clk,
 8007ab0: 4619         	mov	r1, r3
 8007ab2: 68f8         	ldr	r0, [r7, #0xc]
 8007ab4: f00c fb8a    	bl	0x80141cc <clock_control_off> @ imm = #0xc714
 8007ab8: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 8007aba: 697b         	ldr	r3, [r7, #0x14]
; }
 8007abc: 4618         	mov	r0, r3
 8007abe: 3718         	adds	r7, #0x18
 8007ac0: 46bd         	mov	sp, r7
 8007ac2: bd80         	pop	{r7, pc}

08007ac4 <$d>:
 8007ac4: 1c 92 01 08  	.word	0x0801921c

08007ac8 <gpio_stm32_pin_interrupt_configure>:
; {
 8007ac8: b580         	push	{r7, lr}
 8007aca: b08a         	sub	sp, #0x28
 8007acc: af00         	add	r7, sp, #0x0
 8007ace: 60f8         	str	r0, [r7, #0xc]
 8007ad0: 607a         	str	r2, [r7, #0x4]
 8007ad2: 603b         	str	r3, [r7]
 8007ad4: 460b         	mov	r3, r1
 8007ad6: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8007ad8: 68fb         	ldr	r3, [r7, #0xc]
 8007ada: 685b         	ldr	r3, [r3, #0x4]
 8007adc: 61fb         	str	r3, [r7, #0x1c]
; 	struct gpio_stm32_data *data = dev->data;
 8007ade: 68fb         	ldr	r3, [r7, #0xc]
 8007ae0: 691b         	ldr	r3, [r3, #0x10]
 8007ae2: 61bb         	str	r3, [r7, #0x18]
; 	const stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(cfg->port, pin);
 8007ae4: 69fb         	ldr	r3, [r7, #0x1c]
 8007ae6: 689b         	ldr	r3, [r3, #0x8]
 8007ae8: 461a         	mov	r2, r3
 8007aea: 7afb         	ldrb	r3, [r7, #0xb]
 8007aec: 4619         	mov	r1, r3
 8007aee: 4610         	mov	r0, r2
 8007af0: f00a f902    	bl	0x8011cf8 <stm32_gpio_intc_get_pin_irq_line> @ imm = #0xa204
 8007af4: 6178         	str	r0, [r7, #0x14]
; 	uint32_t irq_trigger = 0;
 8007af6: 2300         	movs	r3, #0x0
 8007af8: 627b         	str	r3, [r7, #0x24]
; 	int err = 0;
 8007afa: 2300         	movs	r3, #0x0
 8007afc: 623b         	str	r3, [r7, #0x20]
; 	if (mode == GPIO_INT_MODE_DISABLED) {
 8007afe: 687b         	ldr	r3, [r7, #0x4]
 8007b00: f5b3 1f00    	cmp.w	r3, #0x200000
 8007b04: d108         	bne	0x8007b18 <gpio_stm32_pin_interrupt_configure+0x50> @ imm = #0x10
; 		gpio_stm32_disable_pin_irqs(cfg->port, pin);
 8007b06: 69fb         	ldr	r3, [r7, #0x1c]
 8007b08: 689b         	ldr	r3, [r3, #0x8]
 8007b0a: 461a         	mov	r2, r3
 8007b0c: 7afb         	ldrb	r3, [r7, #0xb]
 8007b0e: 4619         	mov	r1, r3
 8007b10: 4610         	mov	r0, r2
 8007b12: f00c fccb    	bl	0x80144ac <gpio_stm32_disable_pin_irqs> @ imm = #0xc996
; 		goto exit;
 8007b16: e040         	b	0x8007b9a <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x80
; 	if (mode == GPIO_INT_MODE_LEVEL) {
 8007b18: 687b         	ldr	r3, [r7, #0x4]
 8007b1a: f5b3 0f80    	cmp.w	r3, #0x400000
 8007b1e: d103         	bne	0x8007b28 <gpio_stm32_pin_interrupt_configure+0x60> @ imm = #0x6
; 			err = -ENOTSUP;
 8007b20: f06f 0385    	mvn	r3, #0x85
 8007b24: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 8007b26: e038         	b	0x8007b9a <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x70
; 		switch (trig) {
 8007b28: 683b         	ldr	r3, [r7]
 8007b2a: f1b3 6fc0    	cmp.w	r3, #0x6000000
 8007b2e: d012         	beq	0x8007b56 <gpio_stm32_pin_interrupt_configure+0x8e> @ imm = #0x24
 8007b30: 683b         	ldr	r3, [r7]
 8007b32: f1b3 6fc0    	cmp.w	r3, #0x6000000
 8007b36: d811         	bhi	0x8007b5c <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x22
 8007b38: 683b         	ldr	r3, [r7]
 8007b3a: f1b3 7f00    	cmp.w	r3, #0x2000000
 8007b3e: d004         	beq	0x8007b4a <gpio_stm32_pin_interrupt_configure+0x82> @ imm = #0x8
 8007b40: 683b         	ldr	r3, [r7]
 8007b42: f1b3 6f80    	cmp.w	r3, #0x4000000
 8007b46: d003         	beq	0x8007b50 <gpio_stm32_pin_interrupt_configure+0x88> @ imm = #0x6
 8007b48: e008         	b	0x8007b5c <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x10
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_FALLING;
 8007b4a: 2302         	movs	r3, #0x2
 8007b4c: 627b         	str	r3, [r7, #0x24]
; 			break;
 8007b4e: e009         	b	0x8007b64 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x12
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_RISING;
 8007b50: 2301         	movs	r3, #0x1
 8007b52: 627b         	str	r3, [r7, #0x24]
; 			break;
 8007b54: e006         	b	0x8007b64 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0xc
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_BOTH;
 8007b56: 2303         	movs	r3, #0x3
 8007b58: 627b         	str	r3, [r7, #0x24]
; 			break;
 8007b5a: e003         	b	0x8007b64 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x6
; 			err = -EINVAL;
 8007b5c: f06f 0315    	mvn	r3, #0x15
 8007b60: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 8007b62: e01a         	b	0x8007b9a <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x34
; 	if (stm32_gpio_intc_set_irq_callback(irq_line, gpio_stm32_isr, data) != 0) {
 8007b64: 69ba         	ldr	r2, [r7, #0x18]
 8007b66: 490f         	ldr	r1, [pc, #0x3c]         @ 0x8007ba4 <gpio_stm32_pin_interrupt_configure+0xdc>
 8007b68: 6978         	ldr	r0, [r7, #0x14]
 8007b6a: f7fc fb1f    	bl	0x80041ac <stm32_gpio_intc_set_irq_callback> @ imm = #-0x39c2
 8007b6e: 4603         	mov	r3, r0
 8007b70: 2b00         	cmp	r3, #0x0
 8007b72: d003         	beq	0x8007b7c <gpio_stm32_pin_interrupt_configure+0xb4> @ imm = #0x6
; 		err = -EBUSY;
 8007b74: f06f 030f    	mvn	r3, #0xf
 8007b78: 623b         	str	r3, [r7, #0x20]
; 		goto exit;
 8007b7a: e00e         	b	0x8007b9a <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x1c
; 	stm32_exti_set_line_src_port(pin, cfg->port);
 8007b7c: 69fb         	ldr	r3, [r7, #0x1c]
 8007b7e: 689b         	ldr	r3, [r3, #0x8]
 8007b80: 461a         	mov	r2, r3
 8007b82: 7afb         	ldrb	r3, [r7, #0xb]
 8007b84: 4611         	mov	r1, r2
 8007b86: 4618         	mov	r0, r3
 8007b88: f00a f8d0    	bl	0x8011d2c <stm32_exti_set_line_src_port> @ imm = #0xa1a0
; 	stm32_gpio_intc_select_line_trigger(irq_line, irq_trigger);
 8007b8c: 6a79         	ldr	r1, [r7, #0x24]
 8007b8e: 6978         	ldr	r0, [r7, #0x14]
 8007b90: f7fc fad0    	bl	0x8004134 <stm32_gpio_intc_select_line_trigger> @ imm = #-0x3a60
; 	stm32_gpio_intc_enable_line(irq_line);
 8007b94: 6978         	ldr	r0, [r7, #0x14]
 8007b96: f7fc fab1    	bl	0x80040fc <stm32_gpio_intc_enable_line> @ imm = #-0x3a9e
; 	return err;
 8007b9a: 6a3b         	ldr	r3, [r7, #0x20]
; }
 8007b9c: 4618         	mov	r0, r3
 8007b9e: 3728         	adds	r7, #0x28
 8007ba0: 46bd         	mov	sp, r7
 8007ba2: bd80         	pop	{r7, pc}

08007ba4 <$d>:
 8007ba4: 71 43 01 08  	.word	0x08014371

08007ba8 <gpio_stm32_init>:
; {
 8007ba8: b580         	push	{r7, lr}
 8007baa: b084         	sub	sp, #0x10
 8007bac: af00         	add	r7, sp, #0x0
 8007bae: 6078         	str	r0, [r7, #0x4]
; 	struct gpio_stm32_data *data = dev->data;
 8007bb0: 687b         	ldr	r3, [r7, #0x4]
 8007bb2: 691b         	ldr	r3, [r3, #0x10]
 8007bb4: 60fb         	str	r3, [r7, #0xc]
; 	data->dev = dev;
 8007bb6: 68fb         	ldr	r3, [r7, #0xc]
 8007bb8: 687a         	ldr	r2, [r7, #0x4]
 8007bba: 605a         	str	r2, [r3, #0x4]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 8007bbc: 480e         	ldr	r0, [pc, #0x38]         @ 0x8007bf8 <gpio_stm32_init+0x50>
 8007bbe: f00c f971    	bl	0x8013ea4 <device_is_ready> @ imm = #0xc2e2
 8007bc2: 4603         	mov	r3, r0
 8007bc4: f083 0301    	eor	r3, r3, #0x1
 8007bc8: b2db         	uxtb	r3, r3
 8007bca: 2b00         	cmp	r3, #0x0
 8007bcc: d002         	beq	0x8007bd4 <gpio_stm32_init+0x2c> @ imm = #0x4
; 		return -ENODEV;
 8007bce: f06f 0312    	mvn	r3, #0x12
 8007bd2: e00d         	b	0x8007bf0 <gpio_stm32_init+0x48> @ imm = #0x1a
; 	ret = gpio_stm32_clock_request(dev, !IS_ENABLED(CONFIG_PM_DEVICE_RUNTIME));
 8007bd4: 2101         	movs	r1, #0x1
 8007bd6: 6878         	ldr	r0, [r7, #0x4]
 8007bd8: f7ff ff52    	bl	0x8007a80 <gpio_stm32_clock_request> @ imm = #-0x15c
 8007bdc: 60b8         	str	r0, [r7, #0x8]
; 	if (ret < 0) {
 8007bde: 68bb         	ldr	r3, [r7, #0x8]
 8007be0: 2b00         	cmp	r3, #0x0
 8007be2: da01         	bge	0x8007be8 <gpio_stm32_init+0x40> @ imm = #0x2
; 		return ret;
 8007be4: 68bb         	ldr	r3, [r7, #0x8]
 8007be6: e003         	b	0x8007bf0 <gpio_stm32_init+0x48> @ imm = #0x6
; 	(void)pm_device_runtime_enable(dev);
 8007be8: 6878         	ldr	r0, [r7, #0x4]
 8007bea: f00c fb01    	bl	0x80141f0 <pm_device_runtime_enable> @ imm = #0xc602
; 	return 0;
 8007bee: 2300         	movs	r3, #0x0
; }
 8007bf0: 4618         	mov	r0, r3
 8007bf2: 3710         	adds	r7, #0x10
 8007bf4: 46bd         	mov	sp, r7
 8007bf6: bd80         	pop	{r7, pc}

08007bf8 <$d>:
 8007bf8: 1c 92 01 08  	.word	0x0801921c

08007bfc <stm32_pin_configure>:
; {
 8007bfc: b580         	push	{r7, lr}
 8007bfe: b086         	sub	sp, #0x18
 8007c00: af00         	add	r7, sp, #0x0
 8007c02: 60f8         	str	r0, [r7, #0xc]
 8007c04: 60b9         	str	r1, [r7, #0x8]
 8007c06: 607a         	str	r2, [r7, #0x4]
; 	if (STM32_PORT(pin) >= gpio_ports_cnt) {
 8007c08: 68fb         	ldr	r3, [r7, #0xc]
 8007c0a: 091b         	lsrs	r3, r3, #0x4
 8007c0c: 2210         	movs	r2, #0x10
 8007c0e: 4293         	cmp	r3, r2
 8007c10: d302         	blo	0x8007c18 <stm32_pin_configure+0x1c> @ imm = #0x4
; 		return -EINVAL;
 8007c12: f06f 0315    	mvn	r3, #0x15
 8007c16: e01f         	b	0x8007c58 <stm32_pin_configure+0x5c> @ imm = #0x3e
; 	port_device = gpio_ports[STM32_PORT(pin)];
 8007c18: 68fb         	ldr	r3, [r7, #0xc]
 8007c1a: 091b         	lsrs	r3, r3, #0x4
 8007c1c: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8007c60 <stm32_pin_configure+0x64>
 8007c1e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8007c22: 617b         	str	r3, [r7, #0x14]
; 	if ((port_device == NULL) || (!device_is_ready(port_device))) {
 8007c24: 697b         	ldr	r3, [r7, #0x14]
 8007c26: 2b00         	cmp	r3, #0x0
 8007c28: d008         	beq	0x8007c3c <stm32_pin_configure+0x40> @ imm = #0x10
 8007c2a: 6978         	ldr	r0, [r7, #0x14]
 8007c2c: f00c fe4d    	bl	0x80148ca <device_is_ready> @ imm = #0xcc9a
 8007c30: 4603         	mov	r3, r0
 8007c32: f083 0301    	eor	r3, r3, #0x1
 8007c36: b2db         	uxtb	r3, r3
 8007c38: 2b00         	cmp	r3, #0x0
 8007c3a: d002         	beq	0x8007c42 <stm32_pin_configure+0x46> @ imm = #0x4
; 		return -ENODEV;
 8007c3c: f06f 0312    	mvn	r3, #0x12
 8007c40: e00a         	b	0x8007c58 <stm32_pin_configure+0x5c> @ imm = #0x14
; 	return gpio_stm32_configure(port_device, STM32_PIN(pin), pin_cgf, pin_func);
 8007c42: 68fb         	ldr	r3, [r7, #0xc]
 8007c44: b2db         	uxtb	r3, r3
 8007c46: f003 030f    	and	r3, r3, #0xf
 8007c4a: b2d9         	uxtb	r1, r3
 8007c4c: 687b         	ldr	r3, [r7, #0x4]
 8007c4e: 68ba         	ldr	r2, [r7, #0x8]
 8007c50: 6978         	ldr	r0, [r7, #0x14]
 8007c52: f00c fd2f    	bl	0x80146b4 <gpio_stm32_configure> @ imm = #0xca5e
 8007c56: 4603         	mov	r3, r0
; }
 8007c58: 4618         	mov	r0, r3
 8007c5a: 3718         	adds	r7, #0x18
 8007c5c: 46bd         	mov	sp, r7
 8007c5e: bd80         	pop	{r7, pc}

08007c60 <$d>:
 8007c60: fc b8 01 08  	.word	0x0801b8fc

08007c64 <LL_USART_SetBaudRate>:
; {
 8007c64: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8007c68: b0c0         	sub	sp, #0x100
 8007c6a: af00         	add	r7, sp, #0x0
 8007c6c: f8c7 00fc    	str.w	r0, [r7, #0xfc]
 8007c70: f8c7 10f8    	str.w	r1, [r7, #0xf8]
 8007c74: f8c7 20f4    	str.w	r2, [r7, #0xf4]
 8007c78: f8c7 30f0    	str.w	r3, [r7, #0xf0]
;   if (OverSampling == LL_USART_OVERSAMPLING_8)
 8007c7c: f8d7 30f4    	ldr.w	r3, [r7, #0xf4]
 8007c80: f5b3 4f00    	cmp.w	r3, #0x8000
 8007c84: f040 810e    	bne.w	0x8007ea4 <LL_USART_SetBaudRate+0x240> @ imm = #0x21c
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
 8007c88: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8007c8c: 2200         	movs	r2, #0x0
 8007c8e: f8c7 30e8    	str.w	r3, [r7, #0xe8]
 8007c92: f8c7 20ec    	str.w	r2, [r7, #0xec]
 8007c96: e9d7 453a    	ldrd	r4, r5, [r7, #232]
 8007c9a: 4622         	mov	r2, r4
 8007c9c: 462b         	mov	r3, r5
 8007c9e: 1891         	adds	r1, r2, r2
 8007ca0: 6639         	str	r1, [r7, #0x60]
 8007ca2: 415b         	adcs	r3, r3
 8007ca4: 667b         	str	r3, [r7, #0x64]
 8007ca6: e9d7 2318    	ldrd	r2, r3, [r7, #96]
 8007caa: 4620         	mov	r0, r4
 8007cac: 4629         	mov	r1, r5
 8007cae: 4604         	mov	r4, r0
 8007cb0: eb12 0804    	adds.w	r8, r2, r4
 8007cb4: 460c         	mov	r4, r1
 8007cb6: eb43 0904    	adc.w	r9, r3, r4
 8007cba: f04f 0200    	mov.w	r2, #0x0
 8007cbe: f04f 0300    	mov.w	r3, #0x0
 8007cc2: ea4f 03c9    	lsl.w	r3, r9, #0x3
 8007cc6: ea43 7358    	orr.w	r3, r3, r8, lsr #29
 8007cca: ea4f 02c8    	lsl.w	r2, r8, #0x3
 8007cce: 4690         	mov	r8, r2
 8007cd0: 4699         	mov	r9, r3
 8007cd2: 4603         	mov	r3, r0
 8007cd4: eb18 0303    	adds.w	r3, r8, r3
 8007cd8: f8c7 30e0    	str.w	r3, [r7, #0xe0]
 8007cdc: 460b         	mov	r3, r1
 8007cde: eb49 0303    	adc.w	r3, r9, r3
 8007ce2: f8c7 30e4    	str.w	r3, [r7, #0xe4]
 8007ce6: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8007cea: 2200         	movs	r2, #0x0
 8007cec: 469a         	mov	r10, r3
 8007cee: 4693         	mov	r11, r2
 8007cf0: eb1a 030a    	adds.w	r3, r10, r10
 8007cf4: 65bb         	str	r3, [r7, #0x58]
 8007cf6: eb4b 030b    	adc.w	r3, r11, r11
 8007cfa: 65fb         	str	r3, [r7, #0x5c]
 8007cfc: e9d7 2316    	ldrd	r2, r3, [r7, #88]
 8007d00: e9d7 0138    	ldrd	r0, r1, [r7, #224]
 8007d04: f7f8 fef6    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x7214
 8007d08: 4602         	mov	r2, r0
 8007d0a: 460b         	mov	r3, r1
 8007d0c: 4b64         	ldr	r3, [pc, #0x190]        @ 0x8007ea0 <LL_USART_SetBaudRate+0x23c>
 8007d0e: fba3 2302    	umull	r2, r3, r3, r2
 8007d12: 095b         	lsrs	r3, r3, #0x5
 8007d14: b29b         	uxth	r3, r3
 8007d16: 011b         	lsls	r3, r3, #0x4
 8007d18: b29c         	uxth	r4, r3
 8007d1a: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8007d1e: 2200         	movs	r2, #0x0
 8007d20: f8c7 30d8    	str.w	r3, [r7, #0xd8]
 8007d24: f8c7 20dc    	str.w	r2, [r7, #0xdc]
 8007d28: e9d7 8936    	ldrd	r8, r9, [r7, #216]
 8007d2c: 4642         	mov	r2, r8
 8007d2e: 464b         	mov	r3, r9
 8007d30: 1891         	adds	r1, r2, r2
 8007d32: 6539         	str	r1, [r7, #0x50]
 8007d34: 415b         	adcs	r3, r3
 8007d36: 657b         	str	r3, [r7, #0x54]
 8007d38: e9d7 2314    	ldrd	r2, r3, [r7, #80]
 8007d3c: 4641         	mov	r1, r8
 8007d3e: 1851         	adds	r1, r2, r1
 8007d40: 64b9         	str	r1, [r7, #0x48]
 8007d42: 4649         	mov	r1, r9
 8007d44: 414b         	adcs	r3, r1
 8007d46: 64fb         	str	r3, [r7, #0x4c]
 8007d48: f04f 0200    	mov.w	r2, #0x0
 8007d4c: f04f 0300    	mov.w	r3, #0x0
 8007d50: e9d7 ab12    	ldrd	r10, r11, [r7, #72]
 8007d54: 4659         	mov	r1, r11
 8007d56: 00cb         	lsls	r3, r1, #0x3
 8007d58: 4655         	mov	r5, r10
 8007d5a: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8007d5e: 4651         	mov	r1, r10
 8007d60: 00ca         	lsls	r2, r1, #0x3
 8007d62: 4610         	mov	r0, r2
 8007d64: 4619         	mov	r1, r3
 8007d66: 4603         	mov	r3, r0
 8007d68: 4642         	mov	r2, r8
 8007d6a: 189b         	adds	r3, r3, r2
 8007d6c: f8c7 30d0    	str.w	r3, [r7, #0xd0]
 8007d70: 464b         	mov	r3, r9
 8007d72: 460a         	mov	r2, r1
 8007d74: eb42 0303    	adc.w	r3, r2, r3
 8007d78: f8c7 30d4    	str.w	r3, [r7, #0xd4]
 8007d7c: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8007d80: 2200         	movs	r2, #0x0
 8007d82: f8c7 30c8    	str.w	r3, [r7, #0xc8]
 8007d86: f8c7 20cc    	str.w	r2, [r7, #0xcc]
 8007d8a: e9d7 1232    	ldrd	r1, r2, [r7, #200]
 8007d8e: 460b         	mov	r3, r1
 8007d90: 18db         	adds	r3, r3, r3
 8007d92: 643b         	str	r3, [r7, #0x40]
 8007d94: 4613         	mov	r3, r2
 8007d96: eb42 0303    	adc.w	r3, r2, r3
 8007d9a: 647b         	str	r3, [r7, #0x44]
 8007d9c: e9d7 2310    	ldrd	r2, r3, [r7, #64]
 8007da0: e9d7 0134    	ldrd	r0, r1, [r7, #208]
 8007da4: f7f8 fea6    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x72b4
 8007da8: 4602         	mov	r2, r0
 8007daa: 460b         	mov	r3, r1
 8007dac: 4611         	mov	r1, r2
 8007dae: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8007ea0 <LL_USART_SetBaudRate+0x23c>
 8007db0: fba3 2301    	umull	r2, r3, r3, r1
 8007db4: 095b         	lsrs	r3, r3, #0x5
 8007db6: 2264         	movs	r2, #0x64
 8007db8: fb02 f303    	mul	r3, r2, r3
 8007dbc: 1acb         	subs	r3, r1, r3
 8007dbe: 00db         	lsls	r3, r3, #0x3
 8007dc0: f103 0232    	add.w	r2, r3, #0x32
 8007dc4: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8007ea0 <LL_USART_SetBaudRate+0x23c>
 8007dc6: fba3 2302    	umull	r2, r3, r3, r2
 8007dca: 095b         	lsrs	r3, r3, #0x5
 8007dcc: b29b         	uxth	r3, r3
 8007dce: 005b         	lsls	r3, r3, #0x1
 8007dd0: b29b         	uxth	r3, r3
 8007dd2: f403 73f8    	and	r3, r3, #0x1f0
 8007dd6: b29b         	uxth	r3, r3
 8007dd8: 4423         	add	r3, r4
 8007dda: b29c         	uxth	r4, r3
 8007ddc: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8007de0: 2200         	movs	r2, #0x0
 8007de2: f8c7 30c0    	str.w	r3, [r7, #0xc0]
 8007de6: f8c7 20c4    	str.w	r2, [r7, #0xc4]
 8007dea: e9d7 8930    	ldrd	r8, r9, [r7, #192]
 8007dee: 4642         	mov	r2, r8
 8007df0: 464b         	mov	r3, r9
 8007df2: 1891         	adds	r1, r2, r2
 8007df4: 63b9         	str	r1, [r7, #0x38]
 8007df6: 415b         	adcs	r3, r3
 8007df8: 63fb         	str	r3, [r7, #0x3c]
 8007dfa: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 8007dfe: 4641         	mov	r1, r8
 8007e00: 1851         	adds	r1, r2, r1
 8007e02: 6339         	str	r1, [r7, #0x30]
 8007e04: 4649         	mov	r1, r9
 8007e06: 414b         	adcs	r3, r1
 8007e08: 637b         	str	r3, [r7, #0x34]
 8007e0a: f04f 0200    	mov.w	r2, #0x0
 8007e0e: f04f 0300    	mov.w	r3, #0x0
 8007e12: e9d7 ab0c    	ldrd	r10, r11, [r7, #48]
 8007e16: 4659         	mov	r1, r11
 8007e18: 00cb         	lsls	r3, r1, #0x3
 8007e1a: 4655         	mov	r5, r10
 8007e1c: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8007e20: 4651         	mov	r1, r10
 8007e22: 00ca         	lsls	r2, r1, #0x3
 8007e24: 4610         	mov	r0, r2
 8007e26: 4619         	mov	r1, r3
 8007e28: 4603         	mov	r3, r0
 8007e2a: 4642         	mov	r2, r8
 8007e2c: 189b         	adds	r3, r3, r2
 8007e2e: f8c7 30b8    	str.w	r3, [r7, #0xb8]
 8007e32: 464b         	mov	r3, r9
 8007e34: 460a         	mov	r2, r1
 8007e36: eb42 0303    	adc.w	r3, r2, r3
 8007e3a: f8c7 30bc    	str.w	r3, [r7, #0xbc]
 8007e3e: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8007e42: 2200         	movs	r2, #0x0
 8007e44: f8c7 30b0    	str.w	r3, [r7, #0xb0]
 8007e48: f8c7 20b4    	str.w	r2, [r7, #0xb4]
 8007e4c: e9d7 122c    	ldrd	r1, r2, [r7, #176]
 8007e50: 460b         	mov	r3, r1
 8007e52: 18db         	adds	r3, r3, r3
 8007e54: 62bb         	str	r3, [r7, #0x28]
 8007e56: 4613         	mov	r3, r2
 8007e58: eb42 0303    	adc.w	r3, r2, r3
 8007e5c: 62fb         	str	r3, [r7, #0x2c]
 8007e5e: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8007e62: e9d7 012e    	ldrd	r0, r1, [r7, #184]
 8007e66: f7f8 fe45    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x7376
 8007e6a: 4602         	mov	r2, r0
 8007e6c: 460b         	mov	r3, r1
 8007e6e: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007ea0 <LL_USART_SetBaudRate+0x23c>
 8007e70: fba3 1302    	umull	r1, r3, r3, r2
 8007e74: 095b         	lsrs	r3, r3, #0x5
 8007e76: 2164         	movs	r1, #0x64
 8007e78: fb01 f303    	mul	r3, r1, r3
 8007e7c: 1ad3         	subs	r3, r2, r3
 8007e7e: 00db         	lsls	r3, r3, #0x3
 8007e80: 3332         	adds	r3, #0x32
 8007e82: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8007ea0 <LL_USART_SetBaudRate+0x23c>
 8007e84: fba2 2303    	umull	r2, r3, r2, r3
 8007e88: 095b         	lsrs	r3, r3, #0x5
 8007e8a: b29b         	uxth	r3, r3
 8007e8c: f003 0307    	and	r3, r3, #0x7
 8007e90: b29b         	uxth	r3, r3
 8007e92: 4423         	add	r3, r4
 8007e94: b29b         	uxth	r3, r3
 8007e96: 461a         	mov	r2, r3
 8007e98: f8d7 30fc    	ldr.w	r3, [r7, #0xfc]
 8007e9c: 609a         	str	r2, [r3, #0x8]
; }
 8007e9e: e10c         	b	0x80080ba <LL_USART_SetBaudRate+0x456> @ imm = #0x218

08007ea0 <$d>:
 8007ea0: 1f 85 eb 51  	.word	0x51eb851f

08007ea4 <$t>:
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 8007ea4: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8007ea8: 2200         	movs	r2, #0x0
 8007eaa: f8c7 30a8    	str.w	r3, [r7, #0xa8]
 8007eae: f8c7 20ac    	str.w	r2, [r7, #0xac]
 8007eb2: e9d7 892a    	ldrd	r8, r9, [r7, #168]
 8007eb6: 4642         	mov	r2, r8
 8007eb8: 464b         	mov	r3, r9
 8007eba: 1891         	adds	r1, r2, r2
 8007ebc: 6239         	str	r1, [r7, #0x20]
 8007ebe: 415b         	adcs	r3, r3
 8007ec0: 627b         	str	r3, [r7, #0x24]
 8007ec2: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 8007ec6: 4641         	mov	r1, r8
 8007ec8: 1854         	adds	r4, r2, r1
 8007eca: 46cc         	mov	r12, r9
 8007ecc: eb43 050c    	adc.w	r5, r3, r12
 8007ed0: f04f 0200    	mov.w	r2, #0x0
 8007ed4: f04f 0300    	mov.w	r3, #0x0
 8007ed8: 00eb         	lsls	r3, r5, #0x3
 8007eda: ea43 7354    	orr.w	r3, r3, r4, lsr #29
 8007ede: 00e2         	lsls	r2, r4, #0x3
 8007ee0: 4614         	mov	r4, r2
 8007ee2: 461d         	mov	r5, r3
 8007ee4: 4640         	mov	r0, r8
 8007ee6: 4649         	mov	r1, r9
 8007ee8: 4603         	mov	r3, r0
 8007eea: 18e3         	adds	r3, r4, r3
 8007eec: f8c7 30a0    	str.w	r3, [r7, #0xa0]
 8007ef0: 460b         	mov	r3, r1
 8007ef2: eb45 0303    	adc.w	r3, r5, r3
 8007ef6: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 8007efa: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8007efe: 2200         	movs	r2, #0x0
 8007f00: f8c7 3098    	str.w	r3, [r7, #0x98]
 8007f04: f8c7 209c    	str.w	r2, [r7, #0x9c]
 8007f08: f04f 0200    	mov.w	r2, #0x0
 8007f0c: f04f 0300    	mov.w	r3, #0x0
 8007f10: e9d7 4526    	ldrd	r4, r5, [r7, #152]
 8007f14: 4629         	mov	r1, r5
 8007f16: 008b         	lsls	r3, r1, #0x2
 8007f18: 4620         	mov	r0, r4
 8007f1a: 4629         	mov	r1, r5
 8007f1c: 4604         	mov	r4, r0
 8007f1e: ea43 7394    	orr.w	r3, r3, r4, lsr #30
 8007f22: 4601         	mov	r1, r0
 8007f24: 008a         	lsls	r2, r1, #0x2
 8007f26: e9d7 0128    	ldrd	r0, r1, [r7, #160]
 8007f2a: f7f8 fde3    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x743a
 8007f2e: 4602         	mov	r2, r0
 8007f30: 460b         	mov	r3, r1
 8007f32: 4b65         	ldr	r3, [pc, #0x194]        @ 0x80080c8 <LL_USART_SetBaudRate+0x464>
 8007f34: fba3 2302    	umull	r2, r3, r3, r2
 8007f38: 095b         	lsrs	r3, r3, #0x5
 8007f3a: b29b         	uxth	r3, r3
 8007f3c: 011b         	lsls	r3, r3, #0x4
 8007f3e: b29c         	uxth	r4, r3
 8007f40: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8007f44: 2200         	movs	r2, #0x0
 8007f46: f8c7 3090    	str.w	r3, [r7, #0x90]
 8007f4a: f8c7 2094    	str.w	r2, [r7, #0x94]
 8007f4e: e9d7 8924    	ldrd	r8, r9, [r7, #144]
 8007f52: 4642         	mov	r2, r8
 8007f54: 464b         	mov	r3, r9
 8007f56: 1891         	adds	r1, r2, r2
 8007f58: 61b9         	str	r1, [r7, #0x18]
 8007f5a: 415b         	adcs	r3, r3
 8007f5c: 61fb         	str	r3, [r7, #0x1c]
 8007f5e: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8007f62: 4641         	mov	r1, r8
 8007f64: 1851         	adds	r1, r2, r1
 8007f66: 6139         	str	r1, [r7, #0x10]
 8007f68: 4649         	mov	r1, r9
 8007f6a: 414b         	adcs	r3, r1
 8007f6c: 617b         	str	r3, [r7, #0x14]
 8007f6e: f04f 0200    	mov.w	r2, #0x0
 8007f72: f04f 0300    	mov.w	r3, #0x0
 8007f76: e9d7 ab04    	ldrd	r10, r11, [r7, #16]
 8007f7a: 4659         	mov	r1, r11
 8007f7c: 00cb         	lsls	r3, r1, #0x3
 8007f7e: 4655         	mov	r5, r10
 8007f80: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8007f84: 4651         	mov	r1, r10
 8007f86: 00ca         	lsls	r2, r1, #0x3
 8007f88: 4610         	mov	r0, r2
 8007f8a: 4619         	mov	r1, r3
 8007f8c: 4603         	mov	r3, r0
 8007f8e: 4642         	mov	r2, r8
 8007f90: 189b         	adds	r3, r3, r2
 8007f92: f8c7 3088    	str.w	r3, [r7, #0x88]
 8007f96: 464b         	mov	r3, r9
 8007f98: 460a         	mov	r2, r1
 8007f9a: eb42 0303    	adc.w	r3, r2, r3
 8007f9e: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8007fa2: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8007fa6: 2200         	movs	r2, #0x0
 8007fa8: f8c7 3080    	str.w	r3, [r7, #0x80]
 8007fac: f8c7 2084    	str.w	r2, [r7, #0x84]
 8007fb0: f04f 0200    	mov.w	r2, #0x0
 8007fb4: f04f 0300    	mov.w	r3, #0x0
 8007fb8: e9d7 8920    	ldrd	r8, r9, [r7, #128]
 8007fbc: 4649         	mov	r1, r9
 8007fbe: 008b         	lsls	r3, r1, #0x2
 8007fc0: 4645         	mov	r5, r8
 8007fc2: ea43 7395    	orr.w	r3, r3, r5, lsr #30
 8007fc6: 4641         	mov	r1, r8
 8007fc8: 008a         	lsls	r2, r1, #0x2
 8007fca: e9d7 0122    	ldrd	r0, r1, [r7, #136]
 8007fce: f7f8 fd91    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x74de
 8007fd2: 4602         	mov	r2, r0
 8007fd4: 460b         	mov	r3, r1
 8007fd6: 4611         	mov	r1, r2
 8007fd8: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x80080c8 <LL_USART_SetBaudRate+0x464>
 8007fda: fba3 2301    	umull	r2, r3, r3, r1
 8007fde: 095b         	lsrs	r3, r3, #0x5
 8007fe0: 2264         	movs	r2, #0x64
 8007fe2: fb02 f303    	mul	r3, r2, r3
 8007fe6: 1acb         	subs	r3, r1, r3
 8007fe8: 011b         	lsls	r3, r3, #0x4
 8007fea: 3332         	adds	r3, #0x32
 8007fec: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x80080c8 <LL_USART_SetBaudRate+0x464>
 8007fee: fba2 2303    	umull	r2, r3, r2, r3
 8007ff2: 095b         	lsrs	r3, r3, #0x5
 8007ff4: b29b         	uxth	r3, r3
 8007ff6: f003 03f0    	and	r3, r3, #0xf0
 8007ffa: b29b         	uxth	r3, r3
 8007ffc: 4423         	add	r3, r4
 8007ffe: b29c         	uxth	r4, r3
 8008000: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8008004: 2200         	movs	r2, #0x0
 8008006: 67bb         	str	r3, [r7, #0x78]
 8008008: 67fa         	str	r2, [r7, #0x7c]
 800800a: e9d7 891e    	ldrd	r8, r9, [r7, #120]
 800800e: 4642         	mov	r2, r8
 8008010: 464b         	mov	r3, r9
 8008012: 1891         	adds	r1, r2, r2
 8008014: 60b9         	str	r1, [r7, #0x8]
 8008016: 415b         	adcs	r3, r3
 8008018: 60fb         	str	r3, [r7, #0xc]
 800801a: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800801e: 4641         	mov	r1, r8
 8008020: 1851         	adds	r1, r2, r1
 8008022: 6039         	str	r1, [r7]
 8008024: 4649         	mov	r1, r9
 8008026: 414b         	adcs	r3, r1
 8008028: 607b         	str	r3, [r7, #0x4]
 800802a: f04f 0200    	mov.w	r2, #0x0
 800802e: f04f 0300    	mov.w	r3, #0x0
 8008032: e9d7 ab00    	ldrd	r10, r11, [r7]
 8008036: 4659         	mov	r1, r11
 8008038: 00cb         	lsls	r3, r1, #0x3
 800803a: 4655         	mov	r5, r10
 800803c: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8008040: 4651         	mov	r1, r10
 8008042: 00ca         	lsls	r2, r1, #0x3
 8008044: 4610         	mov	r0, r2
 8008046: 4619         	mov	r1, r3
 8008048: 4603         	mov	r3, r0
 800804a: 4642         	mov	r2, r8
 800804c: 189b         	adds	r3, r3, r2
 800804e: 673b         	str	r3, [r7, #0x70]
 8008050: 464b         	mov	r3, r9
 8008052: 460a         	mov	r2, r1
 8008054: eb42 0303    	adc.w	r3, r2, r3
 8008058: 677b         	str	r3, [r7, #0x74]
 800805a: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800805e: 2200         	movs	r2, #0x0
 8008060: 66bb         	str	r3, [r7, #0x68]
 8008062: 66fa         	str	r2, [r7, #0x6c]
 8008064: f04f 0200    	mov.w	r2, #0x0
 8008068: f04f 0300    	mov.w	r3, #0x0
 800806c: e9d7 891a    	ldrd	r8, r9, [r7, #104]
 8008070: 4649         	mov	r1, r9
 8008072: 008b         	lsls	r3, r1, #0x2
 8008074: 4645         	mov	r5, r8
 8008076: ea43 7395    	orr.w	r3, r3, r5, lsr #30
 800807a: 4641         	mov	r1, r8
 800807c: 008a         	lsls	r2, r1, #0x2
 800807e: e9d7 011c    	ldrd	r0, r1, [r7, #112]
 8008082: f7f8 fd37    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x7592
 8008086: 4602         	mov	r2, r0
 8008088: 460b         	mov	r3, r1
 800808a: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80080c8 <LL_USART_SetBaudRate+0x464>
 800808c: fba3 1302    	umull	r1, r3, r3, r2
 8008090: 095b         	lsrs	r3, r3, #0x5
 8008092: 2164         	movs	r1, #0x64
 8008094: fb01 f303    	mul	r3, r1, r3
 8008098: 1ad3         	subs	r3, r2, r3
 800809a: 011b         	lsls	r3, r3, #0x4
 800809c: 3332         	adds	r3, #0x32
 800809e: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80080c8 <LL_USART_SetBaudRate+0x464>
 80080a0: fba2 2303    	umull	r2, r3, r2, r3
 80080a4: 095b         	lsrs	r3, r3, #0x5
 80080a6: b29b         	uxth	r3, r3
 80080a8: f003 030f    	and	r3, r3, #0xf
 80080ac: b29b         	uxth	r3, r3
 80080ae: 4423         	add	r3, r4
 80080b0: b29b         	uxth	r3, r3
 80080b2: 461a         	mov	r2, r3
 80080b4: f8d7 30fc    	ldr.w	r3, [r7, #0xfc]
 80080b8: 609a         	str	r2, [r3, #0x8]
; }
 80080ba: bf00         	nop
 80080bc: f507 7780    	add.w	r7, r7, #0x100
 80080c0: 46bd         	mov	sp, r7
 80080c2: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 80080c6: bf00         	nop

080080c8 <$d>:
 80080c8: 1f 85 eb 51  	.word	0x51eb851f

080080cc <uart_stm32_set_baudrate>:
; {
 80080cc: b580         	push	{r7, lr}
 80080ce: b08c         	sub	sp, #0x30
 80080d0: af04         	add	r7, sp, #0x10
 80080d2: 6078         	str	r0, [r7, #0x4]
 80080d4: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 80080d6: 687b         	ldr	r3, [r7, #0x4]
 80080d8: 685b         	ldr	r3, [r3, #0x4]
 80080da: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 80080dc: 69bb         	ldr	r3, [r7, #0x18]
 80080de: 681b         	ldr	r3, [r3]
 80080e0: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = dev->data;
 80080e2: 687b         	ldr	r3, [r7, #0x4]
 80080e4: 691b         	ldr	r3, [r3, #0x10]
 80080e6: 61fb         	str	r3, [r7, #0x1c]
; 		if (clock_control_get_rate(data->clock,
 80080e8: 69fb         	ldr	r3, [r7, #0x1c]
 80080ea: 6818         	ldr	r0, [r3]
; 					   (clock_control_subsys_t)&config->pclken[0],
 80080ec: 69bb         	ldr	r3, [r7, #0x18]
 80080ee: 68db         	ldr	r3, [r3, #0xc]
; 		if (clock_control_get_rate(data->clock,
 80080f0: f107 0208    	add.w	r2, r7, #0x8
 80080f4: 4619         	mov	r1, r3
 80080f6: f00c fd0b    	bl	0x8014b10 <clock_control_get_rate> @ imm = #0xca16
 80080fa: 4603         	mov	r3, r0
 80080fc: 2b00         	cmp	r3, #0x0
 80080fe: da1a         	bge	0x8008136 <uart_stm32_set_baudrate+0x6a> @ imm = #0x34
; 			LOG_ERR("Failed call clock_control_get_rate(pclken[0])");
 8008100: 2303         	movs	r3, #0x3
 8008102: 2b00         	cmp	r3, #0x0
 8008104: d021         	beq	0x800814a <uart_stm32_set_baudrate+0x7e> @ imm = #0x42
 8008106: 2301         	movs	r3, #0x1
 8008108: 74fb         	strb	r3, [r7, #0x13]
 800810a: 7cfb         	ldrb	r3, [r7, #0x13]
 800810c: f083 0301    	eor	r3, r3, #0x1
 8008110: b2db         	uxtb	r3, r3
 8008112: 2b00         	cmp	r3, #0x0
 8008114: d119         	bne	0x800814a <uart_stm32_set_baudrate+0x7e> @ imm = #0x32
 8008116: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8008150 <uart_stm32_set_baudrate+0x84>
 8008118: 6819         	ldr	r1, [r3]
 800811a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8008154 <uart_stm32_set_baudrate+0x88>
 800811c: 9302         	str	r3, [sp, #0x8]
 800811e: 2300         	movs	r3, #0x0
 8008120: 9301         	str	r3, [sp, #0x4]
 8008122: 2300         	movs	r3, #0x0
 8008124: 9300         	str	r3, [sp]
 8008126: 2300         	movs	r3, #0x0
 8008128: 2201         	movs	r2, #0x1
 800812a: 2000         	movs	r0, #0x0
 800812c: f00d fa52    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xd4a4
 8008130: 2300         	movs	r3, #0x0
 8008132: 60fb         	str	r3, [r7, #0xc]
; 			return;
 8008134: e009         	b	0x800814a <uart_stm32_set_baudrate+0x7e> @ imm = #0x12
; 		LL_USART_SetOverSampling(usart,
 8008136: 2100         	movs	r1, #0x0
 8008138: 6978         	ldr	r0, [r7, #0x14]
 800813a: f00c fe7c    	bl	0x8014e36 <LL_USART_SetOverSampling> @ imm = #0xccf8
; 		LL_USART_SetBaudRate(usart,
 800813e: 68b9         	ldr	r1, [r7, #0x8]
 8008140: 683b         	ldr	r3, [r7]
 8008142: 2200         	movs	r2, #0x0
 8008144: 6978         	ldr	r0, [r7, #0x14]
 8008146: f7ff fd8d    	bl	0x8007c64 <LL_USART_SetBaudRate> @ imm = #-0x4e6
; }
 800814a: 3720         	adds	r7, #0x20
 800814c: 46bd         	mov	sp, r7
 800814e: bd80         	pop	{r7, pc}

08008150 <$d>:
 8008150: 14 03 00 20  	.word	0x20000314
 8008154: 60 a9 01 08  	.word	0x0801a960

08008158 <uart_stm32_configure>:
; {
 8008158: b580         	push	{r7, lr}
 800815a: b08a         	sub	sp, #0x28
 800815c: af00         	add	r7, sp, #0x0
 800815e: 6078         	str	r0, [r7, #0x4]
 8008160: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8008162: 687b         	ldr	r3, [r7, #0x4]
 8008164: 685b         	ldr	r3, [r3, #0x4]
 8008166: 627b         	str	r3, [r7, #0x24]
; 	USART_TypeDef *usart = config->usart;
 8008168: 6a7b         	ldr	r3, [r7, #0x24]
 800816a: 681b         	ldr	r3, [r3]
 800816c: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 800816e: 687b         	ldr	r3, [r7, #0x4]
 8008170: 691b         	ldr	r3, [r3, #0x10]
 8008172: 61fb         	str	r3, [r7, #0x1c]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 8008174: 69fb         	ldr	r3, [r7, #0x1c]
 8008176: 685b         	ldr	r3, [r3, #0x4]
 8008178: 61bb         	str	r3, [r7, #0x18]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 800817a: 683b         	ldr	r3, [r7]
 800817c: 791b         	ldrb	r3, [r3, #0x4]
 800817e: 4618         	mov	r0, r3
 8008180: f00d fad2    	bl	0x8015728 <uart_stm32_cfg2ll_parity> @ imm = #0xd5a4
 8008184: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 8008186: 683b         	ldr	r3, [r7]
 8008188: 795b         	ldrb	r3, [r3, #0x5]
 800818a: 4619         	mov	r1, r3
 800818c: 6a78         	ldr	r0, [r7, #0x24]
 800818e: f00d faf8    	bl	0x8015782 <uart_stm32_cfg2ll_stopbits> @ imm = #0xd5f0
 8008192: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 8008194: 683b         	ldr	r3, [r7]
 8008196: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 8008198: 683b         	ldr	r3, [r7]
 800819a: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 800819c: 4619         	mov	r1, r3
 800819e: 4610         	mov	r0, r2
 80081a0: f00d fb2d    	bl	0x80157fe <uart_stm32_cfg2ll_databits> @ imm = #0xd65a
 80081a4: 60f8         	str	r0, [r7, #0xc]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 80081a6: 683b         	ldr	r3, [r7]
 80081a8: 791b         	ldrb	r3, [r3, #0x4]
 80081aa: 2b03         	cmp	r3, #0x3
 80081ac: d003         	beq	0x80081b6 <uart_stm32_configure+0x5e> @ imm = #0x6
; 	    (cfg->parity == UART_CFG_PARITY_SPACE)) {
 80081ae: 683b         	ldr	r3, [r7]
 80081b0: 791b         	ldrb	r3, [r3, #0x4]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 80081b2: 2b04         	cmp	r3, #0x4
 80081b4: d102         	bne	0x80081bc <uart_stm32_configure+0x64> @ imm = #0x4
; 		return -ENOTSUP;
 80081b6: f06f 0385    	mvn	r3, #0x85
 80081ba: e04f         	b	0x800825c <uart_stm32_configure+0x104> @ imm = #0x9e
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 80081bc: 683b         	ldr	r3, [r7]
 80081be: 791b         	ldrb	r3, [r3, #0x4]
 80081c0: 2b00         	cmp	r3, #0x0
 80081c2: d006         	beq	0x80081d2 <uart_stm32_configure+0x7a> @ imm = #0xc
; 	    (cfg->data_bits == UART_CFG_DATA_BITS_9)) {
 80081c4: 683b         	ldr	r3, [r7]
 80081c6: 799b         	ldrb	r3, [r3, #0x6]
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 80081c8: 2b04         	cmp	r3, #0x4
 80081ca: d102         	bne	0x80081d2 <uart_stm32_configure+0x7a> @ imm = #0x4
; 		return -ENOTSUP;
 80081cc: f06f 0385    	mvn	r3, #0x85
 80081d0: e044         	b	0x800825c <uart_stm32_configure+0x104> @ imm = #0x88
; 	if (uart_stm32_ll2cfg_stopbits(stopbits) != cfg->stop_bits) {
 80081d2: 6938         	ldr	r0, [r7, #0x10]
 80081d4: f00d faf4    	bl	0x80157c0 <uart_stm32_ll2cfg_stopbits> @ imm = #0xd5e8
 80081d8: 4603         	mov	r3, r0
 80081da: 461a         	mov	r2, r3
 80081dc: 683b         	ldr	r3, [r7]
 80081de: 795b         	ldrb	r3, [r3, #0x5]
 80081e0: 429a         	cmp	r2, r3
 80081e2: d002         	beq	0x80081ea <uart_stm32_configure+0x92> @ imm = #0x4
; 		return -ENOTSUP;
 80081e4: f06f 0385    	mvn	r3, #0x85
 80081e8: e038         	b	0x800825c <uart_stm32_configure+0x104> @ imm = #0x70
; 	if (uart_stm32_ll2cfg_databits(databits, parity) != cfg->data_bits) {
 80081ea: 6979         	ldr	r1, [r7, #0x14]
 80081ec: 68f8         	ldr	r0, [r7, #0xc]
 80081ee: f00d fb20    	bl	0x8015832 <uart_stm32_ll2cfg_databits> @ imm = #0xd640
 80081f2: 4603         	mov	r3, r0
 80081f4: 461a         	mov	r2, r3
 80081f6: 683b         	ldr	r3, [r7]
 80081f8: 799b         	ldrb	r3, [r3, #0x6]
 80081fa: 429a         	cmp	r2, r3
 80081fc: d002         	beq	0x8008204 <uart_stm32_configure+0xac> @ imm = #0x4
; 		return -ENOTSUP;
 80081fe: f06f 0385    	mvn	r3, #0x85
 8008202: e02b         	b	0x800825c <uart_stm32_configure+0x104> @ imm = #0x56
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 8008204: 683b         	ldr	r3, [r7]
 8008206: 79db         	ldrb	r3, [r3, #0x7]
 8008208: 2b00         	cmp	r3, #0x0
 800820a: d016         	beq	0x800823a <uart_stm32_configure+0xe2> @ imm = #0x2c
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 800820c: 683b         	ldr	r3, [r7]
 800820e: 79db         	ldrb	r3, [r3, #0x7]
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 8008210: 2b01         	cmp	r3, #0x1
 8008212: d10f         	bne	0x8008234 <uart_stm32_configure+0xdc> @ imm = #0x1e
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 8008214: 6a3b         	ldr	r3, [r7, #0x20]
 8008216: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x8008264 <uart_stm32_configure+0x10c>
 8008218: 4293         	cmp	r3, r2
 800821a: d00e         	beq	0x800823a <uart_stm32_configure+0xe2> @ imm = #0x1c
; 			IS_UART_HWFLOW_INSTANCE(usart))
 800821c: 6a3b         	ldr	r3, [r7, #0x20]
 800821e: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8008268 <uart_stm32_configure+0x110>
 8008220: 4293         	cmp	r3, r2
 8008222: d00a         	beq	0x800823a <uart_stm32_configure+0xe2> @ imm = #0x14
 8008224: 6a3b         	ldr	r3, [r7, #0x20]
 8008226: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800826c <uart_stm32_configure+0x114>
 8008228: 4293         	cmp	r3, r2
 800822a: d006         	beq	0x800823a <uart_stm32_configure+0xe2> @ imm = #0xc
 800822c: 6a3b         	ldr	r3, [r7, #0x20]
 800822e: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8008270 <uart_stm32_configure+0x118>
 8008230: 4293         	cmp	r3, r2
 8008232: d002         	beq	0x800823a <uart_stm32_configure+0xe2> @ imm = #0x4
; 		return -ENOTSUP;
 8008234: f06f 0385    	mvn	r3, #0x85
 8008238: e010         	b	0x800825c <uart_stm32_configure+0x104> @ imm = #0x20
; 	LL_USART_Disable(usart);
 800823a: 6a38         	ldr	r0, [r7, #0x20]
 800823c: f00c fd89    	bl	0x8014d52 <LL_USART_Disable> @ imm = #0xcb12
; 	uart_stm32_parameters_set(dev, cfg);
 8008240: 6839         	ldr	r1, [r7]
 8008242: 6878         	ldr	r0, [r7, #0x4]
 8008244: f00d fb36    	bl	0x80158b4 <uart_stm32_parameters_set> @ imm = #0xd66c
; 	LL_USART_Enable(usart);
 8008248: 6a38         	ldr	r0, [r7, #0x20]
 800824a: f00c fd73    	bl	0x8014d34 <LL_USART_Enable> @ imm = #0xcae6
; 	*uart_cfg = *cfg;
 800824e: 69bb         	ldr	r3, [r7, #0x18]
 8008250: 683a         	ldr	r2, [r7]
 8008252: e892 0003    	ldm.w	r2, {r0, r1}
 8008256: e883 0003    	stm.w	r3, {r0, r1}
; 	return 0;
 800825a: 2300         	movs	r3, #0x0
; };
 800825c: 4618         	mov	r0, r3
 800825e: 3728         	adds	r7, #0x28
 8008260: 46bd         	mov	sp, r7
 8008262: bd80         	pop	{r7, pc}

08008264 <$d>:
 8008264: 00 10 01 40  	.word	0x40011000
 8008268: 00 44 00 40  	.word	0x40004400
 800826c: 00 48 00 40  	.word	0x40004800
 8008270: 00 14 01 40  	.word	0x40011400

08008274 <uart_stm32_poll_in>:
; {
 8008274: b580         	push	{r7, lr}
 8008276: b082         	sub	sp, #0x8
 8008278: af00         	add	r7, sp, #0x0
 800827a: 6078         	str	r0, [r7, #0x4]
 800827c: 6039         	str	r1, [r7]
; 	return uart_stm32_poll_in_visitor(dev, (void *)c, poll_in_u8);
 800827e: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8008294 <uart_stm32_poll_in+0x20>
 8008280: 6839         	ldr	r1, [r7]
 8008282: 6878         	ldr	r0, [r7, #0x4]
 8008284: f00d fbdb    	bl	0x8015a3e <uart_stm32_poll_in_visitor> @ imm = #0xd7b6
 8008288: 4603         	mov	r3, r0
; }
 800828a: 4618         	mov	r0, r3
 800828c: 3708         	adds	r7, #0x8
 800828e: 46bd         	mov	sp, r7
 8008290: bd80         	pop	{r7, pc}
 8008292: bf00         	nop

08008294 <$d>:
 8008294: 21 5b 01 08  	.word	0x08015b21

08008298 <uart_stm32_poll_out>:
; {
 8008298: b580         	push	{r7, lr}
 800829a: b082         	sub	sp, #0x8
 800829c: af00         	add	r7, sp, #0x0
 800829e: 6078         	str	r0, [r7, #0x4]
 80082a0: 460b         	mov	r3, r1
 80082a2: 70fb         	strb	r3, [r7, #0x3]
; 	uart_stm32_poll_out_visitor(dev, (void *)&c, poll_out_u8);
 80082a4: 1cfb         	adds	r3, r7, #0x3
 80082a6: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80082b8 <uart_stm32_poll_out+0x20>
 80082a8: 4619         	mov	r1, r3
 80082aa: 6878         	ldr	r0, [r7, #0x4]
 80082ac: f00d fbee    	bl	0x8015a8c <uart_stm32_poll_out_visitor> @ imm = #0xd7dc
; }
 80082b0: bf00         	nop
 80082b2: 3708         	adds	r7, #0x8
 80082b4: 46bd         	mov	sp, r7
 80082b6: bd80         	pop	{r7, pc}

080082b8 <$d>:
 80082b8: 41 5b 01 08  	.word	0x08015b41

080082bc <__uart_stm32_get_clock>:
; {
 80082bc: b480         	push	{r7}
 80082be: b085         	sub	sp, #0x14
 80082c0: af00         	add	r7, sp, #0x0
 80082c2: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 80082c4: 687b         	ldr	r3, [r7, #0x4]
 80082c6: 691b         	ldr	r3, [r3, #0x10]
 80082c8: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 80082ca: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80082e0 <__uart_stm32_get_clock+0x24>
 80082cc: 60bb         	str	r3, [r7, #0x8]
; 	data->clock = clk;
 80082ce: 68fb         	ldr	r3, [r7, #0xc]
 80082d0: 68ba         	ldr	r2, [r7, #0x8]
 80082d2: 601a         	str	r2, [r3]
; }
 80082d4: bf00         	nop
 80082d6: 3714         	adds	r7, #0x14
 80082d8: 46bd         	mov	sp, r7
 80082da: bc80         	pop	{r7}
 80082dc: 4770         	bx	lr
 80082de: bf00         	nop

080082e0 <$d>:
 80082e0: 1c 92 01 08  	.word	0x0801921c

080082e4 <uart_stm32_fifo_fill>:
; {
 80082e4: b590         	push	{r4, r7, lr}
 80082e6: b085         	sub	sp, #0x14
 80082e8: af00         	add	r7, sp, #0x0
 80082ea: 60f8         	str	r0, [r7, #0xc]
 80082ec: 60b9         	str	r1, [r7, #0x8]
 80082ee: 607a         	str	r2, [r7, #0x4]
; 	if (uart_stm32_ll2cfg_databits(uart_stm32_get_databits(dev), uart_stm32_get_parity(dev)) ==
 80082f0: 68f8         	ldr	r0, [r7, #0xc]
 80082f2: f00d f9e5    	bl	0x80156c0 <uart_stm32_get_databits> @ imm = #0xd3ca
 80082f6: 4604         	mov	r4, r0
 80082f8: 68f8         	ldr	r0, [r7, #0xc]
 80082fa: f00d f99b    	bl	0x8015634 <uart_stm32_get_parity> @ imm = #0xd336
 80082fe: 4603         	mov	r3, r0
 8008300: 4619         	mov	r1, r3
 8008302: 4620         	mov	r0, r4
 8008304: f00d fa95    	bl	0x8015832 <uart_stm32_ll2cfg_databits> @ imm = #0xd52a
 8008308: 4603         	mov	r3, r0
 800830a: 2b04         	cmp	r3, #0x4
 800830c: d102         	bne	0x8008314 <uart_stm32_fifo_fill+0x30> @ imm = #0x4
; 		return -ENOTSUP;
 800830e: f06f 0385    	mvn	r3, #0x85
 8008312: e006         	b	0x8008322 <uart_stm32_fifo_fill+0x3e> @ imm = #0xc
; 	return uart_stm32_fifo_fill_visitor(dev, (const void *)tx_data, size,
 8008314: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800832c <uart_stm32_fifo_fill+0x48>
 8008316: 687a         	ldr	r2, [r7, #0x4]
 8008318: 68b9         	ldr	r1, [r7, #0x8]
 800831a: 68f8         	ldr	r0, [r7, #0xc]
 800831c: f00d fc8a    	bl	0x8015c34 <uart_stm32_fifo_fill_visitor> @ imm = #0xd914
 8008320: 4603         	mov	r3, r0
; }
 8008322: 4618         	mov	r0, r3
 8008324: 3714         	adds	r7, #0x14
 8008326: 46bd         	mov	sp, r7
 8008328: bd90         	pop	{r4, r7, pc}
 800832a: bf00         	nop

0800832c <$d>:
 800832c: cd 5c 01 08  	.word	0x08015ccd

08008330 <uart_stm32_fifo_read>:
; {
 8008330: b590         	push	{r4, r7, lr}
 8008332: b085         	sub	sp, #0x14
 8008334: af00         	add	r7, sp, #0x0
 8008336: 60f8         	str	r0, [r7, #0xc]
 8008338: 60b9         	str	r1, [r7, #0x8]
 800833a: 607a         	str	r2, [r7, #0x4]
; 	if (uart_stm32_ll2cfg_databits(uart_stm32_get_databits(dev), uart_stm32_get_parity(dev)) ==
 800833c: 68f8         	ldr	r0, [r7, #0xc]
 800833e: f00d f9bf    	bl	0x80156c0 <uart_stm32_get_databits> @ imm = #0xd37e
 8008342: 4604         	mov	r4, r0
 8008344: 68f8         	ldr	r0, [r7, #0xc]
 8008346: f00d f975    	bl	0x8015634 <uart_stm32_get_parity> @ imm = #0xd2ea
 800834a: 4603         	mov	r3, r0
 800834c: 4619         	mov	r1, r3
 800834e: 4620         	mov	r0, r4
 8008350: f00d fa6f    	bl	0x8015832 <uart_stm32_ll2cfg_databits> @ imm = #0xd4de
 8008354: 4603         	mov	r3, r0
 8008356: 2b04         	cmp	r3, #0x4
 8008358: d102         	bne	0x8008360 <uart_stm32_fifo_read+0x30> @ imm = #0x4
; 		return -ENOTSUP;
 800835a: f06f 0385    	mvn	r3, #0x85
 800835e: e006         	b	0x800836e <uart_stm32_fifo_read+0x3e> @ imm = #0xc
; 	return uart_stm32_fifo_read_visitor(dev, (void *)rx_data, size,
 8008360: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8008378 <uart_stm32_fifo_read+0x48>
 8008362: 687a         	ldr	r2, [r7, #0x4]
 8008364: 68b9         	ldr	r1, [r7, #0x8]
 8008366: 68f8         	ldr	r0, [r7, #0xc]
 8008368: f00d fcc4    	bl	0x8015cf4 <uart_stm32_fifo_read_visitor> @ imm = #0xd988
 800836c: 4603         	mov	r3, r0
; }
 800836e: 4618         	mov	r0, r3
 8008370: 3714         	adds	r7, #0x14
 8008372: 46bd         	mov	sp, r7
 8008374: bd90         	pop	{r4, r7, pc}
 8008376: bf00         	nop

08008378 <$d>:
 8008378: 57 5d 01 08  	.word	0x08015d57

0800837c <uart_stm32_irq_err_enable>:
; {
 800837c: b580         	push	{r7, lr}
 800837e: b084         	sub	sp, #0x10
 8008380: af00         	add	r7, sp, #0x0
 8008382: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8008384: 687b         	ldr	r3, [r7, #0x4]
 8008386: 685b         	ldr	r3, [r3, #0x4]
 8008388: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 800838a: 68fb         	ldr	r3, [r7, #0xc]
 800838c: 681b         	ldr	r3, [r3]
 800838e: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_EnableIT_ERROR(usart);
 8008390: 68b8         	ldr	r0, [r7, #0x8]
 8008392: f00c ff83    	bl	0x801529c <LL_USART_EnableIT_ERROR> @ imm = #0xcf06
; 	if (IS_UART_LIN_INSTANCE(usart)) {
 8008396: 68bb         	ldr	r3, [r7, #0x8]
 8008398: 4a10         	ldr	r2, [pc, #0x40]         @ 0x80083dc <uart_stm32_irq_err_enable+0x60>
 800839a: 4293         	cmp	r3, r2
 800839c: d013         	beq	0x80083c6 <uart_stm32_irq_err_enable+0x4a> @ imm = #0x26
 800839e: 68bb         	ldr	r3, [r7, #0x8]
 80083a0: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x80083e0 <uart_stm32_irq_err_enable+0x64>
 80083a2: 4293         	cmp	r3, r2
 80083a4: d00f         	beq	0x80083c6 <uart_stm32_irq_err_enable+0x4a> @ imm = #0x1e
 80083a6: 68bb         	ldr	r3, [r7, #0x8]
 80083a8: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x80083e4 <uart_stm32_irq_err_enable+0x68>
 80083aa: 4293         	cmp	r3, r2
 80083ac: d00b         	beq	0x80083c6 <uart_stm32_irq_err_enable+0x4a> @ imm = #0x16
 80083ae: 68bb         	ldr	r3, [r7, #0x8]
 80083b0: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x80083e8 <uart_stm32_irq_err_enable+0x6c>
 80083b2: 4293         	cmp	r3, r2
 80083b4: d007         	beq	0x80083c6 <uart_stm32_irq_err_enable+0x4a> @ imm = #0xe
 80083b6: 68bb         	ldr	r3, [r7, #0x8]
 80083b8: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80083ec <uart_stm32_irq_err_enable+0x70>
 80083ba: 4293         	cmp	r3, r2
 80083bc: d003         	beq	0x80083c6 <uart_stm32_irq_err_enable+0x4a> @ imm = #0x6
 80083be: 68bb         	ldr	r3, [r7, #0x8]
 80083c0: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80083f0 <uart_stm32_irq_err_enable+0x74>
 80083c2: 4293         	cmp	r3, r2
 80083c4: d102         	bne	0x80083cc <uart_stm32_irq_err_enable+0x50> @ imm = #0x4
; 		LL_USART_EnableIT_LBD(usart);
 80083c6: 68b8         	ldr	r0, [r7, #0x8]
 80083c8: f00c ff59    	bl	0x801527e <LL_USART_EnableIT_LBD> @ imm = #0xceb2
; 	LL_USART_EnableIT_PE(usart);
 80083cc: 68b8         	ldr	r0, [r7, #0x8]
 80083ce: f00c ff34    	bl	0x801523a <LL_USART_EnableIT_PE> @ imm = #0xce68
; }
 80083d2: bf00         	nop
 80083d4: 3710         	adds	r7, #0x10
 80083d6: 46bd         	mov	sp, r7
 80083d8: bd80         	pop	{r7, pc}
 80083da: bf00         	nop

080083dc <$d>:
 80083dc: 00 10 01 40  	.word	0x40011000
 80083e0: 00 44 00 40  	.word	0x40004400
 80083e4: 00 48 00 40  	.word	0x40004800
 80083e8: 00 4c 00 40  	.word	0x40004c00
 80083ec: 00 50 00 40  	.word	0x40005000
 80083f0: 00 14 01 40  	.word	0x40011400

080083f4 <uart_stm32_irq_err_disable>:
; {
 80083f4: b580         	push	{r7, lr}
 80083f6: b084         	sub	sp, #0x10
 80083f8: af00         	add	r7, sp, #0x0
 80083fa: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80083fc: 687b         	ldr	r3, [r7, #0x4]
 80083fe: 685b         	ldr	r3, [r3, #0x4]
 8008400: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 8008402: 68fb         	ldr	r3, [r7, #0xc]
 8008404: 681b         	ldr	r3, [r3]
 8008406: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_DisableIT_ERROR(usart);
 8008408: 68b8         	ldr	r0, [r7, #0x8]
 800840a: f00d f800    	bl	0x801540e <LL_USART_DisableIT_ERROR> @ imm = #0xd000
; 	if (IS_UART_LIN_INSTANCE(usart)) {
 800840e: 68bb         	ldr	r3, [r7, #0x8]
 8008410: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8008454 <uart_stm32_irq_err_disable+0x60>
 8008412: 4293         	cmp	r3, r2
 8008414: d013         	beq	0x800843e <uart_stm32_irq_err_disable+0x4a> @ imm = #0x26
 8008416: 68bb         	ldr	r3, [r7, #0x8]
 8008418: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8008458 <uart_stm32_irq_err_disable+0x64>
 800841a: 4293         	cmp	r3, r2
 800841c: d00f         	beq	0x800843e <uart_stm32_irq_err_disable+0x4a> @ imm = #0x1e
 800841e: 68bb         	ldr	r3, [r7, #0x8]
 8008420: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800845c <uart_stm32_irq_err_disable+0x68>
 8008422: 4293         	cmp	r3, r2
 8008424: d00b         	beq	0x800843e <uart_stm32_irq_err_disable+0x4a> @ imm = #0x16
 8008426: 68bb         	ldr	r3, [r7, #0x8]
 8008428: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8008460 <uart_stm32_irq_err_disable+0x6c>
 800842a: 4293         	cmp	r3, r2
 800842c: d007         	beq	0x800843e <uart_stm32_irq_err_disable+0x4a> @ imm = #0xe
 800842e: 68bb         	ldr	r3, [r7, #0x8]
 8008430: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8008464 <uart_stm32_irq_err_disable+0x70>
 8008432: 4293         	cmp	r3, r2
 8008434: d003         	beq	0x800843e <uart_stm32_irq_err_disable+0x4a> @ imm = #0x6
 8008436: 68bb         	ldr	r3, [r7, #0x8]
 8008438: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8008468 <uart_stm32_irq_err_disable+0x74>
 800843a: 4293         	cmp	r3, r2
 800843c: d102         	bne	0x8008444 <uart_stm32_irq_err_disable+0x50> @ imm = #0x4
; 		LL_USART_DisableIT_LBD(usart);
 800843e: 68b8         	ldr	r0, [r7, #0x8]
 8008440: f00c ffd6    	bl	0x80153f0 <LL_USART_DisableIT_LBD> @ imm = #0xcfac
; 	LL_USART_DisableIT_PE(usart);
 8008444: 68b8         	ldr	r0, [r7, #0x8]
 8008446: f00c ffb1    	bl	0x80153ac <LL_USART_DisableIT_PE> @ imm = #0xcf62
; }
 800844a: bf00         	nop
 800844c: 3710         	adds	r7, #0x10
 800844e: 46bd         	mov	sp, r7
 8008450: bd80         	pop	{r7, pc}
 8008452: bf00         	nop

08008454 <$d>:
 8008454: 00 10 01 40  	.word	0x40011000
 8008458: 00 44 00 40  	.word	0x40004400
 800845c: 00 48 00 40  	.word	0x40004800
 8008460: 00 4c 00 40  	.word	0x40004c00
 8008464: 00 50 00 40  	.word	0x40005000
 8008468: 00 14 01 40  	.word	0x40011400

0800846c <async_evt_rx_rdy>:
; {
 800846c: b580         	push	{r7, lr}
 800846e: b090         	sub	sp, #0x40
 8008470: af06         	add	r7, sp, #0x18
 8008472: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("rx_rdy: (%d %d)", data->dma_rx.offset, data->dma_rx.counter);
 8008474: 2303         	movs	r3, #0x3
 8008476: 2b03         	cmp	r3, #0x3
 8008478: d920         	bls	0x80084bc <async_evt_rx_rdy+0x50> @ imm = #0x40
 800847a: 2301         	movs	r3, #0x1
 800847c: f887 3027    	strb.w	r3, [r7, #0x27]
 8008480: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8008484: f083 0301    	eor	r3, r3, #0x1
 8008488: b2db         	uxtb	r3, r3
 800848a: 2b00         	cmp	r3, #0x0
 800848c: d116         	bne	0x80084bc <async_evt_rx_rdy+0x50> @ imm = #0x2c
 800848e: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800850c <async_evt_rx_rdy+0xa0>
 8008490: 6819         	ldr	r1, [r3]
 8008492: 687b         	ldr	r3, [r7, #0x4]
 8008494: 6f5b         	ldr	r3, [r3, #0x74]
 8008496: 687a         	ldr	r2, [r7, #0x4]
 8008498: 6f92         	ldr	r2, [r2, #0x78]
 800849a: 9205         	str	r2, [sp, #0x14]
 800849c: 9304         	str	r3, [sp, #0x10]
 800849e: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8008510 <async_evt_rx_rdy+0xa4>
 80084a0: 9303         	str	r3, [sp, #0xc]
 80084a2: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8008514 <async_evt_rx_rdy+0xa8>
 80084a4: 9302         	str	r3, [sp, #0x8]
 80084a6: 2308         	movs	r3, #0x8
 80084a8: 9301         	str	r3, [sp, #0x4]
 80084aa: 2300         	movs	r3, #0x0
 80084ac: 9300         	str	r3, [sp]
 80084ae: 2300         	movs	r3, #0x0
 80084b0: 2204         	movs	r2, #0x4
 80084b2: 2000         	movs	r0, #0x0
 80084b4: f00d f88e    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xd11c
 80084b8: 2300         	movs	r3, #0x0
 80084ba: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 80084bc: f107 030c    	add.w	r3, r7, #0xc
 80084c0: 2200         	movs	r2, #0x0
 80084c2: 601a         	str	r2, [r3]
 80084c4: 605a         	str	r2, [r3, #0x4]
 80084c6: 609a         	str	r2, [r3, #0x8]
 80084c8: 60da         	str	r2, [r3, #0xc]
 80084ca: 611a         	str	r2, [r3, #0x10]
 80084cc: 2302         	movs	r3, #0x2
 80084ce: 733b         	strb	r3, [r7, #0xc]
; 		.data.rx.buf = data->dma_rx.buffer,
 80084d0: 687b         	ldr	r3, [r7, #0x4]
 80084d2: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event event = {
 80084d4: 613b         	str	r3, [r7, #0x10]
; 		.data.rx.offset = data->dma_rx.offset
 80084d6: 687b         	ldr	r3, [r7, #0x4]
 80084d8: 6f5b         	ldr	r3, [r3, #0x74]
; 	struct uart_event event = {
 80084da: 617b         	str	r3, [r7, #0x14]
; 		.data.rx.len = data->dma_rx.counter - data->dma_rx.offset,
 80084dc: 687b         	ldr	r3, [r7, #0x4]
 80084de: 6f9a         	ldr	r2, [r3, #0x78]
 80084e0: 687b         	ldr	r3, [r7, #0x4]
 80084e2: 6f5b         	ldr	r3, [r3, #0x74]
 80084e4: 1ad3         	subs	r3, r2, r3
; 	struct uart_event event = {
 80084e6: 61bb         	str	r3, [r7, #0x18]
; 	data->dma_rx.offset = data->dma_rx.counter;
 80084e8: 687b         	ldr	r3, [r7, #0x4]
 80084ea: 6f9a         	ldr	r2, [r3, #0x78]
 80084ec: 687b         	ldr	r3, [r7, #0x4]
 80084ee: 675a         	str	r2, [r3, #0x74]
; 	if (event.data.rx.len > 0) {
 80084f0: 69bb         	ldr	r3, [r7, #0x18]
 80084f2: 2b00         	cmp	r3, #0x0
 80084f4: d005         	beq	0x8008502 <async_evt_rx_rdy+0x96> @ imm = #0xa
; 		async_user_callback(data, &event);
 80084f6: f107 030c    	add.w	r3, r7, #0xc
 80084fa: 4619         	mov	r1, r3
 80084fc: 6878         	ldr	r0, [r7, #0x4]
 80084fe: f00d fd0b    	bl	0x8015f18 <async_user_callback> @ imm = #0xda16
; }
 8008502: bf00         	nop
 8008504: 3728         	adds	r7, #0x28
 8008506: 46bd         	mov	sp, r7
 8008508: bd80         	pop	{r7, pc}
 800850a: bf00         	nop

0800850c <$d>:
 800850c: 14 03 00 20  	.word	0x20000314
 8008510: 54 ba 01 08  	.word	0x0801ba54
 8008514: 90 a9 01 08  	.word	0x0801a990

08008518 <async_evt_rx_err>:
; {
 8008518: b580         	push	{r7, lr}
 800851a: b090         	sub	sp, #0x40
 800851c: af06         	add	r7, sp, #0x18
 800851e: 6078         	str	r0, [r7, #0x4]
 8008520: 6039         	str	r1, [r7]
; 	LOG_DBG("rx error: %d", err_code);
 8008522: 2303         	movs	r3, #0x3
 8008524: 2b03         	cmp	r3, #0x3
 8008526: d91c         	bls	0x8008562 <async_evt_rx_err+0x4a> @ imm = #0x38
 8008528: 2301         	movs	r3, #0x1
 800852a: f887 3027    	strb.w	r3, [r7, #0x27]
 800852e: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8008532: f083 0301    	eor	r3, r3, #0x1
 8008536: b2db         	uxtb	r3, r3
 8008538: 2b00         	cmp	r3, #0x0
 800853a: d112         	bne	0x8008562 <async_evt_rx_err+0x4a> @ imm = #0x24
 800853c: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8008590 <async_evt_rx_err+0x78>
 800853e: 6819         	ldr	r1, [r3]
 8008540: 683b         	ldr	r3, [r7]
 8008542: 9304         	str	r3, [sp, #0x10]
 8008544: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8008594 <async_evt_rx_err+0x7c>
 8008546: 9303         	str	r3, [sp, #0xc]
 8008548: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8008598 <async_evt_rx_err+0x80>
 800854a: 9302         	str	r3, [sp, #0x8]
 800854c: 2308         	movs	r3, #0x8
 800854e: 9301         	str	r3, [sp, #0x4]
 8008550: 2300         	movs	r3, #0x0
 8008552: 9300         	str	r3, [sp]
 8008554: 2300         	movs	r3, #0x0
 8008556: 2204         	movs	r2, #0x4
 8008558: 2000         	movs	r0, #0x0
 800855a: f00d f83b    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xd076
 800855e: 2300         	movs	r3, #0x0
 8008560: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 8008562: 2306         	movs	r3, #0x6
 8008564: 733b         	strb	r3, [r7, #0xc]
 8008566: 683b         	ldr	r3, [r7]
 8008568: b2db         	uxtb	r3, r3
 800856a: 743b         	strb	r3, [r7, #0x10]
; 		.data.rx_stop.data.buf = data->dma_rx.buffer
 800856c: 687b         	ldr	r3, [r7, #0x4]
 800856e: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event event = {
 8008570: 617b         	str	r3, [r7, #0x14]
 8008572: 2300         	movs	r3, #0x0
 8008574: 61bb         	str	r3, [r7, #0x18]
; 		.data.rx_stop.data.len = data->dma_rx.counter,
 8008576: 687b         	ldr	r3, [r7, #0x4]
 8008578: 6f9b         	ldr	r3, [r3, #0x78]
; 	struct uart_event event = {
 800857a: 61fb         	str	r3, [r7, #0x1c]
; 	async_user_callback(data, &event);
 800857c: f107 030c    	add.w	r3, r7, #0xc
 8008580: 4619         	mov	r1, r3
 8008582: 6878         	ldr	r0, [r7, #0x4]
 8008584: f00d fcc8    	bl	0x8015f18 <async_user_callback> @ imm = #0xd990
; }
 8008588: bf00         	nop
 800858a: 3728         	adds	r7, #0x28
 800858c: 46bd         	mov	sp, r7
 800858e: bd80         	pop	{r7, pc}

08008590 <$d>:
 8008590: 14 03 00 20  	.word	0x20000314
 8008594: dc ba 01 08  	.word	0x0801badc
 8008598: a4 a9 01 08  	.word	0x0801a9a4

0800859c <async_evt_tx_done>:
; {
 800859c: b580         	push	{r7, lr}
 800859e: b090         	sub	sp, #0x40
 80085a0: af06         	add	r7, sp, #0x18
 80085a2: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("tx done: %d", data->dma_tx.counter);
 80085a4: 2303         	movs	r3, #0x3
 80085a6: 2b03         	cmp	r3, #0x3
 80085a8: d91e         	bls	0x80085e8 <async_evt_tx_done+0x4c> @ imm = #0x3c
 80085aa: 2301         	movs	r3, #0x1
 80085ac: f887 3027    	strb.w	r3, [r7, #0x27]
 80085b0: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80085b4: f083 0301    	eor	r3, r3, #0x1
 80085b8: b2db         	uxtb	r3, r3
 80085ba: 2b00         	cmp	r3, #0x0
 80085bc: d114         	bne	0x80085e8 <async_evt_tx_done+0x4c> @ imm = #0x28
 80085be: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800862c <async_evt_tx_done+0x90>
 80085c0: 6819         	ldr	r1, [r3]
 80085c2: 687b         	ldr	r3, [r7, #0x4]
 80085c4: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 80085c8: 9304         	str	r3, [sp, #0x10]
 80085ca: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8008630 <async_evt_tx_done+0x94>
 80085cc: 9303         	str	r3, [sp, #0xc]
 80085ce: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8008634 <async_evt_tx_done+0x98>
 80085d0: 9302         	str	r3, [sp, #0x8]
 80085d2: 2308         	movs	r3, #0x8
 80085d4: 9301         	str	r3, [sp, #0x4]
 80085d6: 2300         	movs	r3, #0x0
 80085d8: 9300         	str	r3, [sp]
 80085da: 2300         	movs	r3, #0x0
 80085dc: 2204         	movs	r2, #0x4
 80085de: 2000         	movs	r0, #0x0
 80085e0: f00c fff8    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xcff0
 80085e4: 2300         	movs	r3, #0x0
 80085e6: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 80085e8: f107 030c    	add.w	r3, r7, #0xc
 80085ec: 2200         	movs	r2, #0x0
 80085ee: 601a         	str	r2, [r3]
 80085f0: 605a         	str	r2, [r3, #0x4]
 80085f2: 609a         	str	r2, [r3, #0x8]
 80085f4: 60da         	str	r2, [r3, #0xc]
 80085f6: 611a         	str	r2, [r3, #0x10]
; 		.data.tx.buf = data->dma_tx.buffer,
 80085f8: 687b         	ldr	r3, [r7, #0x4]
 80085fa: f8d3 3104    	ldr.w	r3, [r3, #0x104]
; 	struct uart_event event = {
 80085fe: 613b         	str	r3, [r7, #0x10]
; 		.data.tx.len = data->dma_tx.counter
 8008600: 687b         	ldr	r3, [r7, #0x4]
 8008602: f8d3 3110    	ldr.w	r3, [r3, #0x110]
; 	struct uart_event event = {
 8008606: 617b         	str	r3, [r7, #0x14]
; 	data->dma_tx.buffer_length = 0;
 8008608: 687b         	ldr	r3, [r7, #0x4]
 800860a: 2200         	movs	r2, #0x0
 800860c: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.counter = 0;
 8008610: 687b         	ldr	r3, [r7, #0x4]
 8008612: 2200         	movs	r2, #0x0
 8008614: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	async_user_callback(data, &event);
 8008618: f107 030c    	add.w	r3, r7, #0xc
 800861c: 4619         	mov	r1, r3
 800861e: 6878         	ldr	r0, [r7, #0x4]
 8008620: f00d fc7a    	bl	0x8015f18 <async_user_callback> @ imm = #0xd8f4
; }
 8008624: bf00         	nop
 8008626: 3728         	adds	r7, #0x28
 8008628: 46bd         	mov	sp, r7
 800862a: bd80         	pop	{r7, pc}

0800862c <$d>:
 800862c: 14 03 00 20  	.word	0x20000314
 8008630: 8c ba 01 08  	.word	0x0801ba8c
 8008634: b8 a9 01 08  	.word	0x0801a9b8

08008638 <async_evt_tx_abort>:
; {
 8008638: b580         	push	{r7, lr}
 800863a: b090         	sub	sp, #0x40
 800863c: af06         	add	r7, sp, #0x18
 800863e: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("tx abort: %d", data->dma_tx.counter);
 8008640: 2303         	movs	r3, #0x3
 8008642: 2b03         	cmp	r3, #0x3
 8008644: d91e         	bls	0x8008684 <async_evt_tx_abort+0x4c> @ imm = #0x3c
 8008646: 2301         	movs	r3, #0x1
 8008648: f887 3027    	strb.w	r3, [r7, #0x27]
 800864c: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8008650: f083 0301    	eor	r3, r3, #0x1
 8008654: b2db         	uxtb	r3, r3
 8008656: 2b00         	cmp	r3, #0x0
 8008658: d114         	bne	0x8008684 <async_evt_tx_abort+0x4c> @ imm = #0x28
 800865a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80086cc <async_evt_tx_abort+0x94>
 800865c: 6819         	ldr	r1, [r3]
 800865e: 687b         	ldr	r3, [r7, #0x4]
 8008660: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 8008664: 9304         	str	r3, [sp, #0x10]
 8008666: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x80086d0 <async_evt_tx_abort+0x98>
 8008668: 9303         	str	r3, [sp, #0xc]
 800866a: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x80086d4 <async_evt_tx_abort+0x9c>
 800866c: 9302         	str	r3, [sp, #0x8]
 800866e: 2308         	movs	r3, #0x8
 8008670: 9301         	str	r3, [sp, #0x4]
 8008672: 2300         	movs	r3, #0x0
 8008674: 9300         	str	r3, [sp]
 8008676: 2300         	movs	r3, #0x0
 8008678: 2204         	movs	r2, #0x4
 800867a: 2000         	movs	r0, #0x0
 800867c: f00c ffaa    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xcf54
 8008680: 2300         	movs	r3, #0x0
 8008682: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 8008684: f107 030c    	add.w	r3, r7, #0xc
 8008688: 2200         	movs	r2, #0x0
 800868a: 601a         	str	r2, [r3]
 800868c: 605a         	str	r2, [r3, #0x4]
 800868e: 609a         	str	r2, [r3, #0x8]
 8008690: 60da         	str	r2, [r3, #0xc]
 8008692: 611a         	str	r2, [r3, #0x10]
 8008694: 2301         	movs	r3, #0x1
 8008696: 733b         	strb	r3, [r7, #0xc]
; 		.data.tx.buf = data->dma_tx.buffer,
 8008698: 687b         	ldr	r3, [r7, #0x4]
 800869a: f8d3 3104    	ldr.w	r3, [r3, #0x104]
; 	struct uart_event event = {
 800869e: 613b         	str	r3, [r7, #0x10]
; 		.data.tx.len = data->dma_tx.counter
 80086a0: 687b         	ldr	r3, [r7, #0x4]
 80086a2: f8d3 3110    	ldr.w	r3, [r3, #0x110]
; 	struct uart_event event = {
 80086a6: 617b         	str	r3, [r7, #0x14]
; 	data->dma_tx.buffer_length = 0;
 80086a8: 687b         	ldr	r3, [r7, #0x4]
 80086aa: 2200         	movs	r2, #0x0
 80086ac: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.counter = 0;
 80086b0: 687b         	ldr	r3, [r7, #0x4]
 80086b2: 2200         	movs	r2, #0x0
 80086b4: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	async_user_callback(data, &event);
 80086b8: f107 030c    	add.w	r3, r7, #0xc
 80086bc: 4619         	mov	r1, r3
 80086be: 6878         	ldr	r0, [r7, #0x4]
 80086c0: f00d fc2a    	bl	0x8015f18 <async_user_callback> @ imm = #0xd854
; }
 80086c4: bf00         	nop
 80086c6: 3728         	adds	r7, #0x28
 80086c8: 46bd         	mov	sp, r7
 80086ca: bd80         	pop	{r7, pc}

080086cc <$d>:
 80086cc: 14 03 00 20  	.word	0x20000314
 80086d0: 20 bb 01 08  	.word	0x0801bb20
 80086d4: c8 a9 01 08  	.word	0x0801a9c8

080086d8 <async_timer_start>:
; {
 80086d8: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 80086dc: b08a         	sub	sp, #0x28
 80086de: af06         	add	r7, sp, #0x18
 80086e0: 6078         	str	r0, [r7, #0x4]
 80086e2: 6039         	str	r1, [r7]
; 	if ((timeout != SYS_FOREVER_US) && (timeout != 0)) {
 80086e4: 683b         	ldr	r3, [r7]
 80086e6: f1b3 3fff    	cmp.w	r3, #0xffffffff
 80086ea: d037         	beq	0x800875c <async_timer_start+0x84> @ imm = #0x6e
 80086ec: 683b         	ldr	r3, [r7]
 80086ee: 2b00         	cmp	r3, #0x0
 80086f0: d034         	beq	0x800875c <async_timer_start+0x84> @ imm = #0x68
; 		LOG_DBG("async timer started for %d us", timeout);
 80086f2: 2303         	movs	r3, #0x3
 80086f4: 2b03         	cmp	r3, #0x3
 80086f6: d91a         	bls	0x800872e <async_timer_start+0x56> @ imm = #0x34
 80086f8: 2301         	movs	r3, #0x1
 80086fa: 73fb         	strb	r3, [r7, #0xf]
 80086fc: 7bfb         	ldrb	r3, [r7, #0xf]
 80086fe: f083 0301    	eor	r3, r3, #0x1
 8008702: b2db         	uxtb	r3, r3
 8008704: 2b00         	cmp	r3, #0x0
 8008706: d112         	bne	0x800872e <async_timer_start+0x56> @ imm = #0x24
 8008708: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8008768 <async_timer_start+0x90>
 800870a: 6819         	ldr	r1, [r3]
 800870c: 683b         	ldr	r3, [r7]
 800870e: 9304         	str	r3, [sp, #0x10]
 8008710: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800876c <async_timer_start+0x94>
 8008712: 9303         	str	r3, [sp, #0xc]
 8008714: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8008770 <async_timer_start+0x98>
 8008716: 9302         	str	r3, [sp, #0x8]
 8008718: 2308         	movs	r3, #0x8
 800871a: 9301         	str	r3, [sp, #0x4]
 800871c: 2300         	movs	r3, #0x0
 800871e: 9300         	str	r3, [sp]
 8008720: 2300         	movs	r3, #0x0
 8008722: 2204         	movs	r2, #0x4
 8008724: 2000         	movs	r0, #0x0
 8008726: f00c ff55    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xceaa
 800872a: 2300         	movs	r3, #0x0
 800872c: 60bb         	str	r3, [r7, #0x8]
; 		k_work_reschedule(work, K_USEC(timeout));
 800872e: 683b         	ldr	r3, [r7]
 8008730: ea23 73e3    	bic.w	r3, r3, r3, asr #31
 8008734: 17da         	asrs	r2, r3, #0x1f
 8008736: 461c         	mov	r4, r3
 8008738: 4615         	mov	r5, r2
 800873a: f114 0863    	adds.w	r8, r4, #0x63
 800873e: f145 0900    	adc	r9, r5, #0x0
 8008742: f04f 0264    	mov.w	r2, #0x64
 8008746: f04f 0300    	mov.w	r3, #0x0
 800874a: 4640         	mov	r0, r8
 800874c: 4649         	mov	r1, r9
 800874e: f7f8 f9d1    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x7c5e
 8008752: 4602         	mov	r2, r0
 8008754: 460b         	mov	r3, r1
 8008756: 6878         	ldr	r0, [r7, #0x4]
 8008758: f004 f9da    	bl	0x800cb10 <k_work_reschedule> @ imm = #0x43b4
; }
 800875c: bf00         	nop
 800875e: 3710         	adds	r7, #0x10
 8008760: 46bd         	mov	sp, r7
 8008762: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 8008766: bf00         	nop

08008768 <$d>:
 8008768: 14 03 00 20  	.word	0x20000314
 800876c: 78 ba 01 08  	.word	0x0801ba78
 8008770: dc a9 01 08  	.word	0x0801a9dc

08008774 <uart_stm32_isr>:
; {
 8008774: b580         	push	{r7, lr}
 8008776: b08c         	sub	sp, #0x30
 8008778: af04         	add	r7, sp, #0x10
 800877a: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800877c: 687b         	ldr	r3, [r7, #0x4]
 800877e: 691b         	ldr	r3, [r3, #0x10]
 8008780: 61fb         	str	r3, [r7, #0x1c]
; 	const struct uart_stm32_config *config = dev->config;
 8008782: 687b         	ldr	r3, [r7, #0x4]
 8008784: 685b         	ldr	r3, [r3, #0x4]
 8008786: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 8008788: 69bb         	ldr	r3, [r7, #0x18]
 800878a: 681b         	ldr	r3, [r3]
 800878c: 617b         	str	r3, [r7, #0x14]
; 	if (data->user_cb) {
 800878e: 69fb         	ldr	r3, [r7, #0x1c]
 8008790: 689b         	ldr	r3, [r3, #0x8]
 8008792: 2b00         	cmp	r3, #0x0
 8008794: d006         	beq	0x80087a4 <uart_stm32_isr+0x30> @ imm = #0xc
; 		data->user_cb(dev, data->user_data);
 8008796: 69fb         	ldr	r3, [r7, #0x1c]
 8008798: 689b         	ldr	r3, [r3, #0x8]
 800879a: 69fa         	ldr	r2, [r7, #0x1c]
 800879c: 68d2         	ldr	r2, [r2, #0xc]
 800879e: 4611         	mov	r1, r2
 80087a0: 6878         	ldr	r0, [r7, #0x4]
 80087a2: 4798         	blx	r3
; 	if (LL_USART_IsEnabledIT_IDLE(usart) &&
 80087a4: 6978         	ldr	r0, [r7, #0x14]
 80087a6: f00c fe54    	bl	0x8015452 <LL_USART_IsEnabledIT_IDLE> @ imm = #0xcca8
 80087aa: 4603         	mov	r3, r0
 80087ac: 2b00         	cmp	r3, #0x0
 80087ae: d036         	beq	0x800881e <uart_stm32_isr+0xaa> @ imm = #0x6c
; 			LL_USART_IsActiveFlag_IDLE(usart)) {
 80087b0: 6978         	ldr	r0, [r7, #0x14]
 80087b2: f00c fc05    	bl	0x8014fc0 <LL_USART_IsActiveFlag_IDLE> @ imm = #0xc80a
 80087b6: 4603         	mov	r3, r0
; 	if (LL_USART_IsEnabledIT_IDLE(usart) &&
 80087b8: 2b00         	cmp	r3, #0x0
 80087ba: d030         	beq	0x800881e <uart_stm32_isr+0xaa> @ imm = #0x60
; 		LL_USART_ClearFlag_IDLE(usart);
 80087bc: 6978         	ldr	r0, [r7, #0x14]
 80087be: f00c fc9e    	bl	0x80150fe <LL_USART_ClearFlag_IDLE> @ imm = #0xc93c
; 		LOG_DBG("idle interrupt occurred");
 80087c2: 2303         	movs	r3, #0x3
 80087c4: 2b03         	cmp	r3, #0x3
 80087c6: d918         	bls	0x80087fa <uart_stm32_isr+0x86> @ imm = #0x30
 80087c8: 2301         	movs	r3, #0x1
 80087ca: 74fb         	strb	r3, [r7, #0x13]
 80087cc: 7cfb         	ldrb	r3, [r7, #0x13]
 80087ce: f083 0301    	eor	r3, r3, #0x1
 80087d2: b2db         	uxtb	r3, r3
 80087d4: 2b00         	cmp	r3, #0x0
 80087d6: d110         	bne	0x80087fa <uart_stm32_isr+0x86> @ imm = #0x20
 80087d8: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8008870 <uart_stm32_isr+0xfc>
 80087da: 6819         	ldr	r1, [r3]
 80087dc: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8008874 <uart_stm32_isr+0x100>
 80087de: 9303         	str	r3, [sp, #0xc]
 80087e0: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8008878 <uart_stm32_isr+0x104>
 80087e2: 9302         	str	r3, [sp, #0x8]
 80087e4: 2308         	movs	r3, #0x8
 80087e6: 9301         	str	r3, [sp, #0x4]
 80087e8: 2300         	movs	r3, #0x0
 80087ea: 9300         	str	r3, [sp]
 80087ec: 2300         	movs	r3, #0x0
 80087ee: 2204         	movs	r2, #0x4
 80087f0: 2000         	movs	r0, #0x0
 80087f2: f00c feef    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xcdde
 80087f6: 2300         	movs	r3, #0x0
 80087f8: 60fb         	str	r3, [r7, #0xc]
; 		if (data->dma_rx.timeout == 0) {
 80087fa: 69fb         	ldr	r3, [r7, #0x1c]
 80087fc: 6fdb         	ldr	r3, [r3, #0x7c]
 80087fe: 2b00         	cmp	r3, #0x0
 8008800: d103         	bne	0x800880a <uart_stm32_isr+0x96> @ imm = #0x6
; 			uart_stm32_dma_rx_flush(dev);
 8008802: 6878         	ldr	r0, [r7, #0x4]
 8008804: f00d fbd0    	bl	0x8015fa8 <uart_stm32_dma_rx_flush> @ imm = #0xd7a0
; 		if (data->dma_rx.timeout == 0) {
 8008808: e02b         	b	0x8008862 <uart_stm32_isr+0xee> @ imm = #0x56
; 			async_timer_start(&data->dma_rx.timeout_work,
 800880a: 69fb         	ldr	r3, [r7, #0x1c]
 800880c: f103 0280    	add.w	r2, r3, #0x80
 8008810: 69fb         	ldr	r3, [r7, #0x1c]
 8008812: 6fdb         	ldr	r3, [r3, #0x7c]
 8008814: 4619         	mov	r1, r3
 8008816: 4610         	mov	r0, r2
 8008818: f7ff ff5e    	bl	0x80086d8 <async_timer_start> @ imm = #-0x144
; 		if (data->dma_rx.timeout == 0) {
 800881c: e021         	b	0x8008862 <uart_stm32_isr+0xee> @ imm = #0x42
; 	} else if (LL_USART_IsEnabledIT_TC(usart) &&
 800881e: 6978         	ldr	r0, [r7, #0x14]
 8008820: f00c fe3b    	bl	0x801549a <LL_USART_IsEnabledIT_TC> @ imm = #0xcc76
 8008824: 4603         	mov	r3, r0
 8008826: 2b00         	cmp	r3, #0x0
 8008828: d00c         	beq	0x8008844 <uart_stm32_isr+0xd0> @ imm = #0x18
; 			LL_USART_IsActiveFlag_TC(usart)) {
 800882a: 6978         	ldr	r0, [r7, #0x14]
 800882c: f00c fbec    	bl	0x8015008 <LL_USART_IsActiveFlag_TC> @ imm = #0xc7d8
 8008830: 4603         	mov	r3, r0
; 	} else if (LL_USART_IsEnabledIT_TC(usart) &&
 8008832: 2b00         	cmp	r3, #0x0
 8008834: d006         	beq	0x8008844 <uart_stm32_isr+0xd0> @ imm = #0xc
; 		LL_USART_DisableIT_TC(usart);
 8008836: 6978         	ldr	r0, [r7, #0x14]
 8008838: f00c fd96    	bl	0x8015368 <LL_USART_DisableIT_TC> @ imm = #0xcb2c
; 		async_evt_tx_done(data);
 800883c: 69f8         	ldr	r0, [r7, #0x1c]
 800883e: f7ff fead    	bl	0x800859c <async_evt_tx_done> @ imm = #-0x2a6
 8008842: e00e         	b	0x8008862 <uart_stm32_isr+0xee> @ imm = #0x1c
; 	} else if (LL_USART_IsEnabledIT_RXNE(usart) &&
 8008844: 6978         	ldr	r0, [r7, #0x14]
 8008846: f00c fe16    	bl	0x8015476 <LL_USART_IsEnabledIT_RXNE> @ imm = #0xcc2c
 800884a: 4603         	mov	r3, r0
 800884c: 2b00         	cmp	r3, #0x0
 800884e: d008         	beq	0x8008862 <uart_stm32_isr+0xee> @ imm = #0x10
; 			LL_USART_IsActiveFlag_RXNE(usart)) {
 8008850: 6978         	ldr	r0, [r7, #0x14]
 8008852: f00c fbc7    	bl	0x8014fe4 <LL_USART_IsActiveFlag_RXNE> @ imm = #0xc78e
 8008856: 4603         	mov	r3, r0
; 	} else if (LL_USART_IsEnabledIT_RXNE(usart) &&
 8008858: 2b00         	cmp	r3, #0x0
 800885a: d002         	beq	0x8008862 <uart_stm32_isr+0xee> @ imm = #0x4
; 		LL_USART_ClearFlag_RXNE(usart);
 800885c: 6978         	ldr	r0, [r7, #0x14]
 800885e: f00c fc6c    	bl	0x801513a <LL_USART_ClearFlag_RXNE> @ imm = #0xc8d8
; 	uart_stm32_err_check(dev);
 8008862: 6878         	ldr	r0, [r7, #0x4]
 8008864: f00d f97b    	bl	0x8015b5e <uart_stm32_err_check> @ imm = #0xd2f6
; }
 8008868: bf00         	nop
 800886a: 3720         	adds	r7, #0x20
 800886c: 46bd         	mov	sp, r7
 800886e: bd80         	pop	{r7, pc}

08008870 <$d>:
 8008870: 14 03 00 20  	.word	0x20000314
 8008874: 68 ba 01 08  	.word	0x0801ba68
 8008878: 00 aa 01 08  	.word	0x0801aa00

0800887c <uart_stm32_async_rx_disable>:
; {
 800887c: b580         	push	{r7, lr}
 800887e: b096         	sub	sp, #0x58
 8008880: af04         	add	r7, sp, #0x10
 8008882: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8008884: 687b         	ldr	r3, [r7, #0x4]
 8008886: 685b         	ldr	r3, [r3, #0x4]
 8008888: 647b         	str	r3, [r7, #0x44]
; 	USART_TypeDef *usart = config->usart;
 800888a: 6c7b         	ldr	r3, [r7, #0x44]
 800888c: 681b         	ldr	r3, [r3]
 800888e: 643b         	str	r3, [r7, #0x40]
; 	struct uart_stm32_data *data = dev->data;
 8008890: 687b         	ldr	r3, [r7, #0x4]
 8008892: 691b         	ldr	r3, [r3, #0x10]
 8008894: 63fb         	str	r3, [r7, #0x3c]
; 	struct uart_event disabled_event = {
 8008896: f107 0320    	add.w	r3, r7, #0x20
 800889a: 2200         	movs	r2, #0x0
 800889c: 601a         	str	r2, [r3]
 800889e: 605a         	str	r2, [r3, #0x4]
 80088a0: 609a         	str	r2, [r3, #0x8]
 80088a2: 60da         	str	r2, [r3, #0xc]
 80088a4: 611a         	str	r2, [r3, #0x10]
 80088a6: 2305         	movs	r3, #0x5
 80088a8: f887 3020    	strb.w	r3, [r7, #0x20]
; 	if (!data->dma_rx.enabled) {
 80088ac: 6bfb         	ldr	r3, [r7, #0x3c]
 80088ae: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 80088b2: f083 0301    	eor	r3, r3, #0x1
 80088b6: b2db         	uxtb	r3, r3
 80088b8: 2b00         	cmp	r3, #0x0
 80088ba: d008         	beq	0x80088ce <uart_stm32_async_rx_disable+0x52> @ imm = #0x10
; 		async_user_callback(data, &disabled_event);
 80088bc: f107 0320    	add.w	r3, r7, #0x20
 80088c0: 4619         	mov	r1, r3
 80088c2: 6bf8         	ldr	r0, [r7, #0x3c]
 80088c4: f00d fb28    	bl	0x8015f18 <async_user_callback> @ imm = #0xd650
; 		return -EFAULT;
 80088c8: f06f 030d    	mvn	r3, #0xd
 80088cc: e061         	b	0x8008992 <uart_stm32_async_rx_disable+0x116> @ imm = #0xc2
; 	LL_USART_DisableIT_IDLE(usart);
 80088ce: 6c38         	ldr	r0, [r7, #0x40]
 80088d0: f00c fd06    	bl	0x80152e0 <LL_USART_DisableIT_IDLE> @ imm = #0xca0c
; 	uart_stm32_dma_rx_flush(dev);
 80088d4: 6878         	ldr	r0, [r7, #0x4]
 80088d6: f00d fb67    	bl	0x8015fa8 <uart_stm32_dma_rx_flush> @ imm = #0xd6ce
; 	async_evt_rx_buf_release(data);
 80088da: 6bf8         	ldr	r0, [r7, #0x3c]
 80088dc: f00d fb49    	bl	0x8015f72 <async_evt_rx_buf_release> @ imm = #0xd692
; 	uart_stm32_dma_rx_disable(dev);
 80088e0: 6878         	ldr	r0, [r7, #0x4]
 80088e2: f00d fbda    	bl	0x801609a <uart_stm32_dma_rx_disable> @ imm = #0xd7b4
; 	(void)k_work_cancel_delayable(&data->dma_rx.timeout_work);
 80088e6: 6bfb         	ldr	r3, [r7, #0x3c]
 80088e8: 3380         	adds	r3, #0x80
 80088ea: 4618         	mov	r0, r3
 80088ec: f004 f924    	bl	0x800cb38 <k_work_cancel_delayable> @ imm = #0x4248
; 	dma_stop(data->dma_rx.dma_dev, data->dma_rx.dma_channel);
 80088f0: 6bfb         	ldr	r3, [r7, #0x3c]
 80088f2: 6a1a         	ldr	r2, [r3, #0x20]
 80088f4: 6bfb         	ldr	r3, [r7, #0x3c]
 80088f6: 6a5b         	ldr	r3, [r3, #0x24]
 80088f8: 4619         	mov	r1, r3
 80088fa: 4610         	mov	r0, r2
 80088fc: f00c f9a3    	bl	0x8014c46 <dma_stop>    @ imm = #0xc346
; 	if (data->rx_next_buffer) {
 8008900: 6bfb         	ldr	r3, [r7, #0x3c]
 8008902: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 8008906: 2b00         	cmp	r3, #0x0
 8008908: d013         	beq	0x8008932 <uart_stm32_async_rx_disable+0xb6> @ imm = #0x26
; 		struct uart_event rx_next_buf_release_evt = {
 800890a: f107 030c    	add.w	r3, r7, #0xc
 800890e: 2200         	movs	r2, #0x0
 8008910: 601a         	str	r2, [r3]
 8008912: 605a         	str	r2, [r3, #0x4]
 8008914: 609a         	str	r2, [r3, #0x8]
 8008916: 60da         	str	r2, [r3, #0xc]
 8008918: 611a         	str	r2, [r3, #0x10]
 800891a: 2304         	movs	r3, #0x4
 800891c: 733b         	strb	r3, [r7, #0xc]
; 			.data.rx_buf.buf = data->rx_next_buffer,
 800891e: 6bfb         	ldr	r3, [r7, #0x3c]
 8008920: f8d3 3150    	ldr.w	r3, [r3, #0x150]
; 		struct uart_event rx_next_buf_release_evt = {
 8008924: 613b         	str	r3, [r7, #0x10]
; 		async_user_callback(data, &rx_next_buf_release_evt);
 8008926: f107 030c    	add.w	r3, r7, #0xc
 800892a: 4619         	mov	r1, r3
 800892c: 6bf8         	ldr	r0, [r7, #0x3c]
 800892e: f00d faf3    	bl	0x8015f18 <async_user_callback> @ imm = #0xd5e6
; 	data->rx_next_buffer = NULL;
 8008932: 6bfb         	ldr	r3, [r7, #0x3c]
 8008934: 2200         	movs	r2, #0x0
 8008936: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800893a: 6bfb         	ldr	r3, [r7, #0x3c]
 800893c: 2200         	movs	r2, #0x0
 800893e: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	LL_USART_EnableIT_RXNE(usart);
 8008942: 6c38         	ldr	r0, [r7, #0x40]
 8008944: f00c fc35    	bl	0x80151b2 <LL_USART_EnableIT_RXNE> @ imm = #0xc86a
; 	LOG_DBG("rx: disabled");
 8008948: 2303         	movs	r3, #0x3
 800894a: 2b03         	cmp	r3, #0x3
 800894c: d91a         	bls	0x8008984 <uart_stm32_async_rx_disable+0x108> @ imm = #0x34
 800894e: 2301         	movs	r3, #0x1
 8008950: f887 303b    	strb.w	r3, [r7, #0x3b]
 8008954: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8008958: f083 0301    	eor	r3, r3, #0x1
 800895c: b2db         	uxtb	r3, r3
 800895e: 2b00         	cmp	r3, #0x0
 8008960: d110         	bne	0x8008984 <uart_stm32_async_rx_disable+0x108> @ imm = #0x20
 8008962: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800899c <uart_stm32_async_rx_disable+0x120>
 8008964: 6819         	ldr	r1, [r3]
 8008966: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80089a0 <uart_stm32_async_rx_disable+0x124>
 8008968: 9303         	str	r3, [sp, #0xc]
 800896a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80089a4 <uart_stm32_async_rx_disable+0x128>
 800896c: 9302         	str	r3, [sp, #0x8]
 800896e: 2308         	movs	r3, #0x8
 8008970: 9301         	str	r3, [sp, #0x4]
 8008972: 2300         	movs	r3, #0x0
 8008974: 9300         	str	r3, [sp]
 8008976: 2300         	movs	r3, #0x0
 8008978: 2204         	movs	r2, #0x4
 800897a: 2000         	movs	r0, #0x0
 800897c: f00c fe2a    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xcc54
 8008980: 2300         	movs	r3, #0x0
 8008982: 637b         	str	r3, [r7, #0x34]
; 	async_user_callback(data, &disabled_event);
 8008984: f107 0320    	add.w	r3, r7, #0x20
 8008988: 4619         	mov	r1, r3
 800898a: 6bf8         	ldr	r0, [r7, #0x3c]
 800898c: f00d fac4    	bl	0x8015f18 <async_user_callback> @ imm = #0xd588
; 	return 0;
 8008990: 2300         	movs	r3, #0x0
; }
 8008992: 4618         	mov	r0, r3
 8008994: 3748         	adds	r7, #0x48
 8008996: 46bd         	mov	sp, r7
 8008998: bd80         	pop	{r7, pc}
 800899a: bf00         	nop

0800899c <$d>:
 800899c: 14 03 00 20  	.word	0x20000314
 80089a0: a0 ba 01 08  	.word	0x0801baa0
 80089a4: 1c aa 01 08  	.word	0x0801aa1c

080089a8 <uart_stm32_dma_replace_buffer>:
; {
 80089a8: b590         	push	{r4, r7, lr}
 80089aa: b08f         	sub	sp, #0x3c
 80089ac: af06         	add	r7, sp, #0x18
 80089ae: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80089b0: 687b         	ldr	r3, [r7, #0x4]
 80089b2: 685b         	ldr	r3, [r3, #0x4]
 80089b4: 61fb         	str	r3, [r7, #0x1c]
; 	USART_TypeDef *usart = config->usart;
 80089b6: 69fb         	ldr	r3, [r7, #0x1c]
 80089b8: 681b         	ldr	r3, [r3]
 80089ba: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = dev->data;
 80089bc: 687b         	ldr	r3, [r7, #0x4]
 80089be: 691b         	ldr	r3, [r3, #0x10]
 80089c0: 617b         	str	r3, [r7, #0x14]
; 	LOG_DBG("Replacing RX buffer: %d", data->rx_next_buffer_len);
 80089c2: 2303         	movs	r3, #0x3
 80089c4: 2b03         	cmp	r3, #0x3
 80089c6: d91c         	bls	0x8008a02 <uart_stm32_dma_replace_buffer+0x5a> @ imm = #0x38
 80089c8: 2301         	movs	r3, #0x1
 80089ca: 74fb         	strb	r3, [r7, #0x13]
 80089cc: 7cfb         	ldrb	r3, [r7, #0x13]
 80089ce: f083 0301    	eor	r3, r3, #0x1
 80089d2: b2db         	uxtb	r3, r3
 80089d4: 2b00         	cmp	r3, #0x0
 80089d6: d114         	bne	0x8008a02 <uart_stm32_dma_replace_buffer+0x5a> @ imm = #0x28
 80089d8: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8008a84 <uart_stm32_dma_replace_buffer+0xdc>
 80089da: 6819         	ldr	r1, [r3]
 80089dc: 697b         	ldr	r3, [r7, #0x14]
 80089de: f8d3 3154    	ldr.w	r3, [r3, #0x154]
 80089e2: 9304         	str	r3, [sp, #0x10]
 80089e4: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8008a88 <uart_stm32_dma_replace_buffer+0xe0>
 80089e6: 9303         	str	r3, [sp, #0xc]
 80089e8: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8008a8c <uart_stm32_dma_replace_buffer+0xe4>
 80089ea: 9302         	str	r3, [sp, #0x8]
 80089ec: 2308         	movs	r3, #0x8
 80089ee: 9301         	str	r3, [sp, #0x4]
 80089f0: 2300         	movs	r3, #0x0
 80089f2: 9300         	str	r3, [sp]
 80089f4: 2300         	movs	r3, #0x0
 80089f6: 2204         	movs	r2, #0x4
 80089f8: 2000         	movs	r0, #0x0
 80089fa: f00c fdeb    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xcbd6
 80089fe: 2300         	movs	r3, #0x0
 8008a00: 60fb         	str	r3, [r7, #0xc]
; 	data->dma_rx.offset = 0;
 8008a02: 697b         	ldr	r3, [r7, #0x14]
 8008a04: 2200         	movs	r2, #0x0
 8008a06: 675a         	str	r2, [r3, #0x74]
; 	data->dma_rx.counter = 0;
 8008a08: 697b         	ldr	r3, [r7, #0x14]
 8008a0a: 2200         	movs	r2, #0x0
 8008a0c: 679a         	str	r2, [r3, #0x78]
; 	data->dma_rx.buffer = data->rx_next_buffer;
 8008a0e: 697b         	ldr	r3, [r7, #0x14]
 8008a10: f8d3 2150    	ldr.w	r2, [r3, #0x150]
 8008a14: 697b         	ldr	r3, [r7, #0x14]
 8008a16: 66da         	str	r2, [r3, #0x6c]
; 	data->dma_rx.buffer_length = data->rx_next_buffer_len;
 8008a18: 697b         	ldr	r3, [r7, #0x14]
 8008a1a: f8d3 2154    	ldr.w	r2, [r3, #0x154]
 8008a1e: 697b         	ldr	r3, [r7, #0x14]
 8008a20: 671a         	str	r2, [r3, #0x70]
; 	data->dma_rx.blk_cfg.block_size = data->dma_rx.buffer_length;
 8008a22: 697b         	ldr	r3, [r7, #0x14]
 8008a24: 6f1a         	ldr	r2, [r3, #0x70]
 8008a26: 697b         	ldr	r3, [r7, #0x14]
 8008a28: 661a         	str	r2, [r3, #0x60]
; 	data->dma_rx.blk_cfg.dest_address = (uint32_t)data->dma_rx.buffer;
 8008a2a: 697b         	ldr	r3, [r7, #0x14]
 8008a2c: 6edb         	ldr	r3, [r3, #0x6c]
 8008a2e: 461a         	mov	r2, r3
 8008a30: 697b         	ldr	r3, [r7, #0x14]
 8008a32: 651a         	str	r2, [r3, #0x50]
; 	data->rx_next_buffer = NULL;
 8008a34: 697b         	ldr	r3, [r7, #0x14]
 8008a36: 2200         	movs	r2, #0x0
 8008a38: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 8008a3c: 697b         	ldr	r3, [r7, #0x14]
 8008a3e: 2200         	movs	r2, #0x0
 8008a40: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	dma_reload(data->dma_rx.dma_dev, data->dma_rx.dma_channel,
 8008a44: 697b         	ldr	r3, [r7, #0x14]
 8008a46: 6a18         	ldr	r0, [r3, #0x20]
 8008a48: 697b         	ldr	r3, [r7, #0x14]
 8008a4a: 6a59         	ldr	r1, [r3, #0x24]
 8008a4c: 697b         	ldr	r3, [r7, #0x14]
 8008a4e: 6cda         	ldr	r2, [r3, #0x4c]
 8008a50: 697b         	ldr	r3, [r7, #0x14]
 8008a52: 6d1c         	ldr	r4, [r3, #0x50]
 8008a54: 697b         	ldr	r3, [r7, #0x14]
 8008a56: 6e1b         	ldr	r3, [r3, #0x60]
 8008a58: 9300         	str	r3, [sp]
 8008a5a: 4623         	mov	r3, r4
 8008a5c: f00c f887    	bl	0x8014b6e <dma_reload>  @ imm = #0xc10e
; 	dma_start(data->dma_rx.dma_dev, data->dma_rx.dma_channel);
 8008a60: 697b         	ldr	r3, [r7, #0x14]
 8008a62: 6a1a         	ldr	r2, [r3, #0x20]
 8008a64: 697b         	ldr	r3, [r7, #0x14]
 8008a66: 6a5b         	ldr	r3, [r3, #0x24]
 8008a68: 4619         	mov	r1, r3
 8008a6a: 4610         	mov	r0, r2
 8008a6c: f00c f8dd    	bl	0x8014c2a <dma_start>   @ imm = #0xc1ba
; 	LL_USART_ClearFlag_IDLE(usart);
 8008a70: 69b8         	ldr	r0, [r7, #0x18]
 8008a72: f00c fb44    	bl	0x80150fe <LL_USART_ClearFlag_IDLE> @ imm = #0xc688
; 	async_evt_rx_buf_request(data);
 8008a76: 6978         	ldr	r0, [r7, #0x14]
 8008a78: f00d fa63    	bl	0x8015f42 <async_evt_rx_buf_request> @ imm = #0xd4c6
; }
 8008a7c: bf00         	nop
 8008a7e: 3724         	adds	r7, #0x24
 8008a80: 46bd         	mov	sp, r7
 8008a82: bd90         	pop	{r4, r7, pc}

08008a84 <$d>:
 8008a84: 14 03 00 20  	.word	0x20000314
 8008a88: bc ba 01 08  	.word	0x0801babc
 8008a8c: 30 aa 01 08  	.word	0x0801aa30

08008a90 <uart_stm32_async_tx>:
; {
 8008a90: b580         	push	{r7, lr}
 8008a92: b094         	sub	sp, #0x50
 8008a94: af06         	add	r7, sp, #0x18
 8008a96: 60f8         	str	r0, [r7, #0xc]
 8008a98: 60b9         	str	r1, [r7, #0x8]
 8008a9a: 607a         	str	r2, [r7, #0x4]
 8008a9c: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8008a9e: 68fb         	ldr	r3, [r7, #0xc]
 8008aa0: 685b         	ldr	r3, [r3, #0x4]
 8008aa2: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 8008aa4: 6b7b         	ldr	r3, [r7, #0x34]
 8008aa6: 681b         	ldr	r3, [r3]
 8008aa8: 633b         	str	r3, [r7, #0x30]
; 	struct uart_stm32_data *data = dev->data;
 8008aaa: 68fb         	ldr	r3, [r7, #0xc]
 8008aac: 691b         	ldr	r3, [r3, #0x10]
 8008aae: 62fb         	str	r3, [r7, #0x2c]
; 	if (data->dma_tx.dma_dev == NULL) {
 8008ab0: 6afb         	ldr	r3, [r7, #0x2c]
 8008ab2: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 8008ab6: 2b00         	cmp	r3, #0x0
 8008ab8: d102         	bne	0x8008ac0 <uart_stm32_async_tx+0x30> @ imm = #0x4
; 		return -ENODEV;
 8008aba: f06f 0312    	mvn	r3, #0x12
 8008abe: e0ac         	b	0x8008c1a <uart_stm32_async_tx+0x18a> @ imm = #0x158
; 	if (data->dma_tx.buffer_length != 0) {
 8008ac0: 6afb         	ldr	r3, [r7, #0x2c]
 8008ac2: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 8008ac6: 2b00         	cmp	r3, #0x0
 8008ac8: d002         	beq	0x8008ad0 <uart_stm32_async_tx+0x40> @ imm = #0x4
; 		return -EBUSY;
 8008aca: f06f 030f    	mvn	r3, #0xf
 8008ace: e0a4         	b	0x8008c1a <uart_stm32_async_tx+0x18a> @ imm = #0x148
; 	data->dma_tx.buffer = (uint8_t *)tx_data;
 8008ad0: 6afb         	ldr	r3, [r7, #0x2c]
 8008ad2: 68ba         	ldr	r2, [r7, #0x8]
 8008ad4: f8c3 2104    	str.w	r2, [r3, #0x104]
; 	data->dma_tx.buffer_length = buf_size;
 8008ad8: 6afb         	ldr	r3, [r7, #0x2c]
 8008ada: 687a         	ldr	r2, [r7, #0x4]
 8008adc: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.timeout = timeout;
 8008ae0: 6afb         	ldr	r3, [r7, #0x2c]
 8008ae2: 683a         	ldr	r2, [r7]
 8008ae4: f8c3 2114    	str.w	r2, [r3, #0x114]
; 	LOG_DBG("tx: l=%d", data->dma_tx.buffer_length);
 8008ae8: 2303         	movs	r3, #0x3
 8008aea: 2b03         	cmp	r3, #0x3
 8008aec: d91e         	bls	0x8008b2c <uart_stm32_async_tx+0x9c> @ imm = #0x3c
 8008aee: 2301         	movs	r3, #0x1
 8008af0: f887 302b    	strb.w	r3, [r7, #0x2b]
 8008af4: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8008af8: f083 0301    	eor	r3, r3, #0x1
 8008afc: b2db         	uxtb	r3, r3
 8008afe: 2b00         	cmp	r3, #0x0
 8008b00: d114         	bne	0x8008b2c <uart_stm32_async_tx+0x9c> @ imm = #0x28
 8008b02: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8008c24 <uart_stm32_async_tx+0x194>
 8008b04: 6819         	ldr	r1, [r3]
 8008b06: 6afb         	ldr	r3, [r7, #0x2c]
 8008b08: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 8008b0c: 9304         	str	r3, [sp, #0x10]
 8008b0e: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8008c28 <uart_stm32_async_tx+0x198>
 8008b10: 9303         	str	r3, [sp, #0xc]
 8008b12: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8008c2c <uart_stm32_async_tx+0x19c>
 8008b14: 9302         	str	r3, [sp, #0x8]
 8008b16: 2308         	movs	r3, #0x8
 8008b18: 9301         	str	r3, [sp, #0x4]
 8008b1a: 2300         	movs	r3, #0x0
 8008b1c: 9300         	str	r3, [sp]
 8008b1e: 2300         	movs	r3, #0x0
 8008b20: 2204         	movs	r2, #0x4
 8008b22: 2000         	movs	r0, #0x0
 8008b24: f00c fd56    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xcaac
 8008b28: 2300         	movs	r3, #0x0
 8008b2a: 627b         	str	r3, [r7, #0x24]
; 	LL_USART_ClearFlag_TC(usart);
 8008b2c: 6b38         	ldr	r0, [r7, #0x30]
 8008b2e: f00c faf7    	bl	0x8015120 <LL_USART_ClearFlag_TC> @ imm = #0xc5ee
; 	LL_USART_EnableIT_TC(usart);
 8008b32: 6b38         	ldr	r0, [r7, #0x30]
 8008b34: f00c fb5f    	bl	0x80151f6 <LL_USART_EnableIT_TC> @ imm = #0xc6be
; 	data->dma_tx.blk_cfg.source_address = (uint32_t)data->dma_tx.buffer;
 8008b38: 6afb         	ldr	r3, [r7, #0x2c]
 8008b3a: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8008b3e: 461a         	mov	r2, r3
 8008b40: 6afb         	ldr	r3, [r7, #0x2c]
 8008b42: f8c3 20e4    	str.w	r2, [r3, #0xe4]
; 	data->dma_tx.blk_cfg.block_size = data->dma_tx.buffer_length;
 8008b46: 6afb         	ldr	r3, [r7, #0x2c]
 8008b48: f8d3 2108    	ldr.w	r2, [r3, #0x108]
 8008b4c: 6afb         	ldr	r3, [r7, #0x2c]
 8008b4e: f8c3 20f8    	str.w	r2, [r3, #0xf8]
; 	ret = dma_config(data->dma_tx.dma_dev, data->dma_tx.dma_channel,
 8008b52: 6afb         	ldr	r3, [r7, #0x2c]
 8008b54: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 8008b58: 6afb         	ldr	r3, [r7, #0x2c]
 8008b5a: f8d3 10bc    	ldr.w	r1, [r3, #0xbc]
 8008b5e: 6afb         	ldr	r3, [r7, #0x2c]
 8008b60: 33c0         	adds	r3, #0xc0
 8008b62: 461a         	mov	r2, r3
 8008b64: f00b ffef    	bl	0x8014b46 <dma_config>  @ imm = #0xbfde
 8008b68: 6238         	str	r0, [r7, #0x20]
; 	if (ret != 0) {
 8008b6a: 6a3b         	ldr	r3, [r7, #0x20]
 8008b6c: 2b00         	cmp	r3, #0x0
 8008b6e: d01c         	beq	0x8008baa <uart_stm32_async_tx+0x11a> @ imm = #0x38
; 		LOG_ERR("dma tx config error!");
 8008b70: 2303         	movs	r3, #0x3
 8008b72: 2b00         	cmp	r3, #0x0
 8008b74: d016         	beq	0x8008ba4 <uart_stm32_async_tx+0x114> @ imm = #0x2c
 8008b76: 2301         	movs	r3, #0x1
 8008b78: 75fb         	strb	r3, [r7, #0x17]
 8008b7a: 7dfb         	ldrb	r3, [r7, #0x17]
 8008b7c: f083 0301    	eor	r3, r3, #0x1
 8008b80: b2db         	uxtb	r3, r3
 8008b82: 2b00         	cmp	r3, #0x0
 8008b84: d10e         	bne	0x8008ba4 <uart_stm32_async_tx+0x114> @ imm = #0x1c
 8008b86: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8008c24 <uart_stm32_async_tx+0x194>
 8008b88: 6819         	ldr	r1, [r3]
 8008b8a: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8008c30 <uart_stm32_async_tx+0x1a0>
 8008b8c: 9302         	str	r3, [sp, #0x8]
 8008b8e: 2300         	movs	r3, #0x0
 8008b90: 9301         	str	r3, [sp, #0x4]
 8008b92: 2300         	movs	r3, #0x0
 8008b94: 9300         	str	r3, [sp]
 8008b96: 2300         	movs	r3, #0x0
 8008b98: 2201         	movs	r2, #0x1
 8008b9a: 2000         	movs	r0, #0x0
 8008b9c: f00c fd1a    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xca34
 8008ba0: 2300         	movs	r3, #0x0
 8008ba2: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 8008ba4: f06f 0315    	mvn	r3, #0x15
 8008ba8: e037         	b	0x8008c1a <uart_stm32_async_tx+0x18a> @ imm = #0x6e
; 	if (dma_start(data->dma_tx.dma_dev, data->dma_tx.dma_channel)) {
 8008baa: 6afb         	ldr	r3, [r7, #0x2c]
 8008bac: f8d3 20b8    	ldr.w	r2, [r3, #0xb8]
 8008bb0: 6afb         	ldr	r3, [r7, #0x2c]
 8008bb2: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 8008bb6: 4619         	mov	r1, r3
 8008bb8: 4610         	mov	r0, r2
 8008bba: f00c f836    	bl	0x8014c2a <dma_start>   @ imm = #0xc06c
 8008bbe: 4603         	mov	r3, r0
 8008bc0: 2b00         	cmp	r3, #0x0
 8008bc2: d01c         	beq	0x8008bfe <uart_stm32_async_tx+0x16e> @ imm = #0x38
; 		LOG_ERR("UART err: TX DMA start failed!");
 8008bc4: 2303         	movs	r3, #0x3
 8008bc6: 2b00         	cmp	r3, #0x0
 8008bc8: d016         	beq	0x8008bf8 <uart_stm32_async_tx+0x168> @ imm = #0x2c
 8008bca: 2301         	movs	r3, #0x1
 8008bcc: 77fb         	strb	r3, [r7, #0x1f]
 8008bce: 7ffb         	ldrb	r3, [r7, #0x1f]
 8008bd0: f083 0301    	eor	r3, r3, #0x1
 8008bd4: b2db         	uxtb	r3, r3
 8008bd6: 2b00         	cmp	r3, #0x0
 8008bd8: d10e         	bne	0x8008bf8 <uart_stm32_async_tx+0x168> @ imm = #0x1c
 8008bda: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8008c24 <uart_stm32_async_tx+0x194>
 8008bdc: 6819         	ldr	r1, [r3]
 8008bde: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8008c34 <uart_stm32_async_tx+0x1a4>
 8008be0: 9302         	str	r3, [sp, #0x8]
 8008be2: 2300         	movs	r3, #0x0
 8008be4: 9301         	str	r3, [sp, #0x4]
 8008be6: 2300         	movs	r3, #0x0
 8008be8: 9300         	str	r3, [sp]
 8008bea: 2300         	movs	r3, #0x0
 8008bec: 2201         	movs	r2, #0x1
 8008bee: 2000         	movs	r0, #0x0
 8008bf0: f00c fcf0    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xc9e0
 8008bf4: 2300         	movs	r3, #0x0
 8008bf6: 61bb         	str	r3, [r7, #0x18]
; 		return -EFAULT;
 8008bf8: f06f 030d    	mvn	r3, #0xd
 8008bfc: e00d         	b	0x8008c1a <uart_stm32_async_tx+0x18a> @ imm = #0x1a
; 	async_timer_start(&data->dma_tx.timeout_work, data->dma_tx.timeout);
 8008bfe: 6afb         	ldr	r3, [r7, #0x2c]
 8008c00: f503 728c    	add.w	r2, r3, #0x118
 8008c04: 6afb         	ldr	r3, [r7, #0x2c]
 8008c06: f8d3 3114    	ldr.w	r3, [r3, #0x114]
 8008c0a: 4619         	mov	r1, r3
 8008c0c: 4610         	mov	r0, r2
 8008c0e: f7ff fd63    	bl	0x80086d8 <async_timer_start> @ imm = #-0x53a
; 	uart_stm32_dma_tx_enable(dev);
 8008c12: 68f8         	ldr	r0, [r7, #0xc]
 8008c14: f00d fa0a    	bl	0x801602c <uart_stm32_dma_tx_enable> @ imm = #0xd414
; 	return 0;
 8008c18: 2300         	movs	r3, #0x0
; }
 8008c1a: 4618         	mov	r0, r3
 8008c1c: 3738         	adds	r7, #0x38
 8008c1e: 46bd         	mov	sp, r7
 8008c20: bd80         	pop	{r7, pc}
 8008c22: bf00         	nop

08008c24 <$d>:
 8008c24: 14 03 00 20  	.word	0x20000314
 8008c28: f0 ba 01 08  	.word	0x0801baf0
 8008c2c: 4c aa 01 08  	.word	0x0801aa4c
 8008c30: 5c aa 01 08  	.word	0x0801aa5c
 8008c34: 74 aa 01 08  	.word	0x0801aa74

08008c38 <uart_stm32_async_rx_enable>:
; {
 8008c38: b580         	push	{r7, lr}
 8008c3a: b094         	sub	sp, #0x50
 8008c3c: af04         	add	r7, sp, #0x10
 8008c3e: 60f8         	str	r0, [r7, #0xc]
 8008c40: 60b9         	str	r1, [r7, #0x8]
 8008c42: 607a         	str	r2, [r7, #0x4]
 8008c44: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8008c46: 68fb         	ldr	r3, [r7, #0xc]
 8008c48: 685b         	ldr	r3, [r3, #0x4]
 8008c4a: 63fb         	str	r3, [r7, #0x3c]
; 	USART_TypeDef *usart = config->usart;
 8008c4c: 6bfb         	ldr	r3, [r7, #0x3c]
 8008c4e: 681b         	ldr	r3, [r3]
 8008c50: 63bb         	str	r3, [r7, #0x38]
; 	struct uart_stm32_data *data = dev->data;
 8008c52: 68fb         	ldr	r3, [r7, #0xc]
 8008c54: 691b         	ldr	r3, [r3, #0x10]
 8008c56: 637b         	str	r3, [r7, #0x34]
; 	if (data->dma_rx.dma_dev == NULL) {
 8008c58: 6b7b         	ldr	r3, [r7, #0x34]
 8008c5a: 6a1b         	ldr	r3, [r3, #0x20]
 8008c5c: 2b00         	cmp	r3, #0x0
 8008c5e: d102         	bne	0x8008c66 <uart_stm32_async_rx_enable+0x2e> @ imm = #0x4
; 		return -ENODEV;
 8008c60: f06f 0312    	mvn	r3, #0x12
 8008c64: e0c0         	b	0x8008de8 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x180
; 	if (data->dma_rx.enabled) {
 8008c66: 6b7b         	ldr	r3, [r7, #0x34]
 8008c68: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 8008c6c: 2b00         	cmp	r3, #0x0
 8008c6e: d01c         	beq	0x8008caa <uart_stm32_async_rx_enable+0x72> @ imm = #0x38
; 		LOG_WRN("RX was already enabled");
 8008c70: 2303         	movs	r3, #0x3
 8008c72: 2b01         	cmp	r3, #0x1
 8008c74: d916         	bls	0x8008ca4 <uart_stm32_async_rx_enable+0x6c> @ imm = #0x2c
 8008c76: 2301         	movs	r3, #0x1
 8008c78: 75fb         	strb	r3, [r7, #0x17]
 8008c7a: 7dfb         	ldrb	r3, [r7, #0x17]
 8008c7c: f083 0301    	eor	r3, r3, #0x1
 8008c80: b2db         	uxtb	r3, r3
 8008c82: 2b00         	cmp	r3, #0x0
 8008c84: d10e         	bne	0x8008ca4 <uart_stm32_async_rx_enable+0x6c> @ imm = #0x1c
 8008c86: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x8008df0 <uart_stm32_async_rx_enable+0x1b8>
 8008c88: 6819         	ldr	r1, [r3]
 8008c8a: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x8008df4 <uart_stm32_async_rx_enable+0x1bc>
 8008c8c: 9302         	str	r3, [sp, #0x8]
 8008c8e: 2300         	movs	r3, #0x0
 8008c90: 9301         	str	r3, [sp, #0x4]
 8008c92: 2300         	movs	r3, #0x0
 8008c94: 9300         	str	r3, [sp]
 8008c96: 2300         	movs	r3, #0x0
 8008c98: 2202         	movs	r2, #0x2
 8008c9a: 2000         	movs	r0, #0x0
 8008c9c: f00c fc9a    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xc934
 8008ca0: 2300         	movs	r3, #0x0
 8008ca2: 613b         	str	r3, [r7, #0x10]
; 		return -EBUSY;
 8008ca4: f06f 030f    	mvn	r3, #0xf
 8008ca8: e09e         	b	0x8008de8 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x13c
; 	data->dma_rx.offset = 0;
 8008caa: 6b7b         	ldr	r3, [r7, #0x34]
 8008cac: 2200         	movs	r2, #0x0
 8008cae: 675a         	str	r2, [r3, #0x74]
; 	data->dma_rx.buffer = rx_buf;
 8008cb0: 6b7b         	ldr	r3, [r7, #0x34]
 8008cb2: 68ba         	ldr	r2, [r7, #0x8]
 8008cb4: 66da         	str	r2, [r3, #0x6c]
; 	data->dma_rx.buffer_length = buf_size;
 8008cb6: 6b7b         	ldr	r3, [r7, #0x34]
 8008cb8: 687a         	ldr	r2, [r7, #0x4]
 8008cba: 671a         	str	r2, [r3, #0x70]
; 	data->dma_rx.counter = 0;
 8008cbc: 6b7b         	ldr	r3, [r7, #0x34]
 8008cbe: 2200         	movs	r2, #0x0
 8008cc0: 679a         	str	r2, [r3, #0x78]
; 	data->dma_rx.timeout = timeout;
 8008cc2: 6b7b         	ldr	r3, [r7, #0x34]
 8008cc4: 683a         	ldr	r2, [r7]
 8008cc6: 67da         	str	r2, [r3, #0x7c]
; 	LL_USART_DisableIT_RXNE(usart);
 8008cc8: 6bb8         	ldr	r0, [r7, #0x38]
 8008cca: f00c fb2b    	bl	0x8015324 <LL_USART_DisableIT_RXNE> @ imm = #0xc656
; 	data->dma_rx.blk_cfg.block_size = buf_size;
 8008cce: 6b7b         	ldr	r3, [r7, #0x34]
 8008cd0: 687a         	ldr	r2, [r7, #0x4]
 8008cd2: 661a         	str	r2, [r3, #0x60]
; 	data->dma_rx.blk_cfg.dest_address = (uint32_t)data->dma_rx.buffer;
 8008cd4: 6b7b         	ldr	r3, [r7, #0x34]
 8008cd6: 6edb         	ldr	r3, [r3, #0x6c]
 8008cd8: 461a         	mov	r2, r3
 8008cda: 6b7b         	ldr	r3, [r7, #0x34]
 8008cdc: 651a         	str	r2, [r3, #0x50]
; 	ret = dma_config(data->dma_rx.dma_dev, data->dma_rx.dma_channel,
 8008cde: 6b7b         	ldr	r3, [r7, #0x34]
 8008ce0: 6a18         	ldr	r0, [r3, #0x20]
 8008ce2: 6b7b         	ldr	r3, [r7, #0x34]
 8008ce4: 6a59         	ldr	r1, [r3, #0x24]
 8008ce6: 6b7b         	ldr	r3, [r7, #0x34]
 8008ce8: 3328         	adds	r3, #0x28
 8008cea: 461a         	mov	r2, r3
 8008cec: f00b ff2b    	bl	0x8014b46 <dma_config>  @ imm = #0xbe56
 8008cf0: 6338         	str	r0, [r7, #0x30]
; 	if (ret != 0) {
 8008cf2: 6b3b         	ldr	r3, [r7, #0x30]
 8008cf4: 2b00         	cmp	r3, #0x0
 8008cf6: d01c         	beq	0x8008d32 <uart_stm32_async_rx_enable+0xfa> @ imm = #0x38
; 		LOG_ERR("UART ERR: RX DMA config failed!");
 8008cf8: 2303         	movs	r3, #0x3
 8008cfa: 2b00         	cmp	r3, #0x0
 8008cfc: d016         	beq	0x8008d2c <uart_stm32_async_rx_enable+0xf4> @ imm = #0x2c
 8008cfe: 2301         	movs	r3, #0x1
 8008d00: 77fb         	strb	r3, [r7, #0x1f]
 8008d02: 7ffb         	ldrb	r3, [r7, #0x1f]
 8008d04: f083 0301    	eor	r3, r3, #0x1
 8008d08: b2db         	uxtb	r3, r3
 8008d0a: 2b00         	cmp	r3, #0x0
 8008d0c: d10e         	bne	0x8008d2c <uart_stm32_async_rx_enable+0xf4> @ imm = #0x1c
 8008d0e: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8008df0 <uart_stm32_async_rx_enable+0x1b8>
 8008d10: 6819         	ldr	r1, [r3]
 8008d12: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8008df8 <uart_stm32_async_rx_enable+0x1c0>
 8008d14: 9302         	str	r3, [sp, #0x8]
 8008d16: 2300         	movs	r3, #0x0
 8008d18: 9301         	str	r3, [sp, #0x4]
 8008d1a: 2300         	movs	r3, #0x0
 8008d1c: 9300         	str	r3, [sp]
 8008d1e: 2300         	movs	r3, #0x0
 8008d20: 2201         	movs	r2, #0x1
 8008d22: 2000         	movs	r0, #0x0
 8008d24: f00c fc56    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xc8ac
 8008d28: 2300         	movs	r3, #0x0
 8008d2a: 61bb         	str	r3, [r7, #0x18]
; 		return -EINVAL;
 8008d2c: f06f 0315    	mvn	r3, #0x15
 8008d30: e05a         	b	0x8008de8 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0xb4
; 	if (dma_start(data->dma_rx.dma_dev, data->dma_rx.dma_channel)) {
 8008d32: 6b7b         	ldr	r3, [r7, #0x34]
 8008d34: 6a1a         	ldr	r2, [r3, #0x20]
 8008d36: 6b7b         	ldr	r3, [r7, #0x34]
 8008d38: 6a5b         	ldr	r3, [r3, #0x24]
 8008d3a: 4619         	mov	r1, r3
 8008d3c: 4610         	mov	r0, r2
 8008d3e: f00b ff74    	bl	0x8014c2a <dma_start>   @ imm = #0xbee8
 8008d42: 4603         	mov	r3, r0
 8008d44: 2b00         	cmp	r3, #0x0
 8008d46: d01e         	beq	0x8008d86 <uart_stm32_async_rx_enable+0x14e> @ imm = #0x3c
; 		LOG_ERR("UART ERR: RX DMA start failed!");
 8008d48: 2303         	movs	r3, #0x3
 8008d4a: 2b00         	cmp	r3, #0x0
 8008d4c: d018         	beq	0x8008d80 <uart_stm32_async_rx_enable+0x148> @ imm = #0x30
 8008d4e: 2301         	movs	r3, #0x1
 8008d50: f887 3027    	strb.w	r3, [r7, #0x27]
 8008d54: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8008d58: f083 0301    	eor	r3, r3, #0x1
 8008d5c: b2db         	uxtb	r3, r3
 8008d5e: 2b00         	cmp	r3, #0x0
 8008d60: d10e         	bne	0x8008d80 <uart_stm32_async_rx_enable+0x148> @ imm = #0x1c
 8008d62: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8008df0 <uart_stm32_async_rx_enable+0x1b8>
 8008d64: 6819         	ldr	r1, [r3]
 8008d66: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8008dfc <uart_stm32_async_rx_enable+0x1c4>
 8008d68: 9302         	str	r3, [sp, #0x8]
 8008d6a: 2300         	movs	r3, #0x0
 8008d6c: 9301         	str	r3, [sp, #0x4]
 8008d6e: 2300         	movs	r3, #0x0
 8008d70: 9300         	str	r3, [sp]
 8008d72: 2300         	movs	r3, #0x0
 8008d74: 2201         	movs	r2, #0x1
 8008d76: 2000         	movs	r0, #0x0
 8008d78: f00c fc2c    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xc858
 8008d7c: 2300         	movs	r3, #0x0
 8008d7e: 623b         	str	r3, [r7, #0x20]
; 		return -EFAULT;
 8008d80: f06f 030d    	mvn	r3, #0xd
 8008d84: e030         	b	0x8008de8 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x60
; 	LL_USART_ClearFlag_RXNE(usart);
 8008d86: 6bb8         	ldr	r0, [r7, #0x38]
 8008d88: f00c f9d7    	bl	0x801513a <LL_USART_ClearFlag_RXNE> @ imm = #0xc3ae
; 	uart_stm32_dma_rx_enable(dev);
 8008d8c: 68f8         	ldr	r0, [r7, #0xc]
 8008d8e: f00d f96d    	bl	0x801606c <uart_stm32_dma_rx_enable> @ imm = #0xd2da
; 	LL_USART_ClearFlag_IDLE(usart);
 8008d92: 6bb8         	ldr	r0, [r7, #0x38]
 8008d94: f00c f9b3    	bl	0x80150fe <LL_USART_ClearFlag_IDLE> @ imm = #0xc366
; 	LL_USART_EnableIT_IDLE(usart);
 8008d98: 6bb8         	ldr	r0, [r7, #0x38]
 8008d9a: f00c f9e8    	bl	0x801516e <LL_USART_EnableIT_IDLE> @ imm = #0xc3d0
; 	LL_USART_EnableIT_ERROR(usart);
 8008d9e: 6bb8         	ldr	r0, [r7, #0x38]
 8008da0: f00c fa7c    	bl	0x801529c <LL_USART_EnableIT_ERROR> @ imm = #0xc4f8
; 	async_evt_rx_buf_request(data);
 8008da4: 6b78         	ldr	r0, [r7, #0x34]
 8008da6: f00d f8cc    	bl	0x8015f42 <async_evt_rx_buf_request> @ imm = #0xd198
; 	LOG_DBG("async rx enabled");
 8008daa: 2303         	movs	r3, #0x3
 8008dac: 2b03         	cmp	r3, #0x3
 8008dae: d91a         	bls	0x8008de6 <uart_stm32_async_rx_enable+0x1ae> @ imm = #0x34
 8008db0: 2301         	movs	r3, #0x1
 8008db2: f887 302f    	strb.w	r3, [r7, #0x2f]
 8008db6: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8008dba: f083 0301    	eor	r3, r3, #0x1
 8008dbe: b2db         	uxtb	r3, r3
 8008dc0: 2b00         	cmp	r3, #0x0
 8008dc2: d110         	bne	0x8008de6 <uart_stm32_async_rx_enable+0x1ae> @ imm = #0x20
 8008dc4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8008df0 <uart_stm32_async_rx_enable+0x1b8>
 8008dc6: 6819         	ldr	r1, [r3]
 8008dc8: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8008e00 <uart_stm32_async_rx_enable+0x1c8>
 8008dca: 9303         	str	r3, [sp, #0xc]
 8008dcc: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8008e04 <uart_stm32_async_rx_enable+0x1cc>
 8008dce: 9302         	str	r3, [sp, #0x8]
 8008dd0: 2308         	movs	r3, #0x8
 8008dd2: 9301         	str	r3, [sp, #0x4]
 8008dd4: 2300         	movs	r3, #0x0
 8008dd6: 9300         	str	r3, [sp]
 8008dd8: 2300         	movs	r3, #0x0
 8008dda: 2204         	movs	r2, #0x4
 8008ddc: 2000         	movs	r0, #0x0
 8008dde: f00c fbf9    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xc7f2
 8008de2: 2300         	movs	r3, #0x0
 8008de4: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8008de6: 6b3b         	ldr	r3, [r7, #0x30]
; }
 8008de8: 4618         	mov	r0, r3
 8008dea: 3740         	adds	r7, #0x40
 8008dec: 46bd         	mov	sp, r7
 8008dee: bd80         	pop	{r7, pc}

08008df0 <$d>:
 8008df0: 14 03 00 20  	.word	0x20000314
 8008df4: 94 aa 01 08  	.word	0x0801aa94
 8008df8: ac aa 01 08  	.word	0x0801aaac
 8008dfc: cc aa 01 08  	.word	0x0801aacc
 8008e00: 04 bb 01 08  	.word	0x0801bb04
 8008e04: ec aa 01 08  	.word	0x0801aaec

08008e08 <uart_stm32_async_rx_timeout>:
; {
 8008e08: b580         	push	{r7, lr}
 8008e0a: b08c         	sub	sp, #0x30
 8008e0c: af04         	add	r7, sp, #0x10
 8008e0e: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 8008e10: 6878         	ldr	r0, [r7, #0x4]
 8008e12: f00b fe61    	bl	0x8014ad8 <k_work_delayable_from_work> @ imm = #0xbcc2
 8008e16: 61f8         	str	r0, [r7, #0x1c]
; 	struct uart_dma_stream *rx_stream = CONTAINER_OF(dwork,
 8008e18: 69fb         	ldr	r3, [r7, #0x1c]
 8008e1a: 3b60         	subs	r3, #0x60
 8008e1c: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = CONTAINER_OF(rx_stream,
 8008e1e: 69bb         	ldr	r3, [r7, #0x18]
 8008e20: 3b20         	subs	r3, #0x20
 8008e22: 617b         	str	r3, [r7, #0x14]
; 	const struct device *dev = data->uart_dev;
 8008e24: 697b         	ldr	r3, [r7, #0x14]
 8008e26: 691b         	ldr	r3, [r3, #0x10]
 8008e28: 613b         	str	r3, [r7, #0x10]
; 	LOG_DBG("rx timeout");
 8008e2a: 2303         	movs	r3, #0x3
 8008e2c: 2b03         	cmp	r3, #0x3
 8008e2e: d918         	bls	0x8008e62 <uart_stm32_async_rx_timeout+0x5a> @ imm = #0x30
 8008e30: 2301         	movs	r3, #0x1
 8008e32: 73fb         	strb	r3, [r7, #0xf]
 8008e34: 7bfb         	ldrb	r3, [r7, #0xf]
 8008e36: f083 0301    	eor	r3, r3, #0x1
 8008e3a: b2db         	uxtb	r3, r3
 8008e3c: 2b00         	cmp	r3, #0x0
 8008e3e: d110         	bne	0x8008e62 <uart_stm32_async_rx_timeout+0x5a> @ imm = #0x20
 8008e40: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8008e84 <uart_stm32_async_rx_timeout+0x7c>
 8008e42: 6819         	ldr	r1, [r3]
 8008e44: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8008e88 <uart_stm32_async_rx_timeout+0x80>
 8008e46: 9303         	str	r3, [sp, #0xc]
 8008e48: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8008e8c <uart_stm32_async_rx_timeout+0x84>
 8008e4a: 9302         	str	r3, [sp, #0x8]
 8008e4c: 2308         	movs	r3, #0x8
 8008e4e: 9301         	str	r3, [sp, #0x4]
 8008e50: 2300         	movs	r3, #0x0
 8008e52: 9300         	str	r3, [sp]
 8008e54: 2300         	movs	r3, #0x0
 8008e56: 2204         	movs	r2, #0x4
 8008e58: 2000         	movs	r0, #0x0
 8008e5a: f00c fbbb    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xc776
 8008e5e: 2300         	movs	r3, #0x0
 8008e60: 60bb         	str	r3, [r7, #0x8]
; 	if (data->dma_rx.counter == data->dma_rx.buffer_length) {
 8008e62: 697b         	ldr	r3, [r7, #0x14]
 8008e64: 6f9a         	ldr	r2, [r3, #0x78]
 8008e66: 697b         	ldr	r3, [r7, #0x14]
 8008e68: 6f1b         	ldr	r3, [r3, #0x70]
 8008e6a: 429a         	cmp	r2, r3
 8008e6c: d103         	bne	0x8008e76 <uart_stm32_async_rx_timeout+0x6e> @ imm = #0x6
; 		uart_stm32_async_rx_disable(dev);
 8008e6e: 6938         	ldr	r0, [r7, #0x10]
 8008e70: f7ff fd04    	bl	0x800887c <uart_stm32_async_rx_disable> @ imm = #-0x5f8
; }
 8008e74: e002         	b	0x8008e7c <uart_stm32_async_rx_timeout+0x74> @ imm = #0x4
; 		uart_stm32_dma_rx_flush(dev);
 8008e76: 6938         	ldr	r0, [r7, #0x10]
 8008e78: f00d f896    	bl	0x8015fa8 <uart_stm32_dma_rx_flush> @ imm = #0xd12c
; }
 8008e7c: bf00         	nop
 8008e7e: 3720         	adds	r7, #0x20
 8008e80: 46bd         	mov	sp, r7
 8008e82: bd80         	pop	{r7, pc}

08008e84 <$d>:
 8008e84: 14 03 00 20  	.word	0x20000314
 8008e88: 34 bb 01 08  	.word	0x0801bb34
 8008e8c: 04 ab 01 08  	.word	0x0801ab04

08008e90 <uart_stm32_async_tx_timeout>:
; {
 8008e90: b580         	push	{r7, lr}
 8008e92: b08c         	sub	sp, #0x30
 8008e94: af04         	add	r7, sp, #0x10
 8008e96: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 8008e98: 6878         	ldr	r0, [r7, #0x4]
 8008e9a: f00b fe1d    	bl	0x8014ad8 <k_work_delayable_from_work> @ imm = #0xbc3a
 8008e9e: 61f8         	str	r0, [r7, #0x1c]
; 	struct uart_dma_stream *tx_stream = CONTAINER_OF(dwork,
 8008ea0: 69fb         	ldr	r3, [r7, #0x1c]
 8008ea2: 3b60         	subs	r3, #0x60
 8008ea4: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = CONTAINER_OF(tx_stream,
 8008ea6: 69bb         	ldr	r3, [r7, #0x18]
 8008ea8: 3bb8         	subs	r3, #0xb8
 8008eaa: 617b         	str	r3, [r7, #0x14]
; 	const struct device *dev = data->uart_dev;
 8008eac: 697b         	ldr	r3, [r7, #0x14]
 8008eae: 691b         	ldr	r3, [r3, #0x10]
 8008eb0: 613b         	str	r3, [r7, #0x10]
; 	uart_stm32_async_tx_abort(dev);
 8008eb2: 6938         	ldr	r0, [r7, #0x10]
 8008eb4: f00d f989    	bl	0x80161ca <uart_stm32_async_tx_abort> @ imm = #0xd312
; 	LOG_DBG("tx: async timeout");
 8008eb8: 2303         	movs	r3, #0x3
 8008eba: 2b03         	cmp	r3, #0x3
 8008ebc: d919         	bls	0x8008ef2 <uart_stm32_async_tx_timeout+0x62> @ imm = #0x32
 8008ebe: 2301         	movs	r3, #0x1
 8008ec0: 73fb         	strb	r3, [r7, #0xf]
 8008ec2: 7bfb         	ldrb	r3, [r7, #0xf]
 8008ec4: f083 0301    	eor	r3, r3, #0x1
 8008ec8: b2db         	uxtb	r3, r3
 8008eca: 2b00         	cmp	r3, #0x0
 8008ecc: d111         	bne	0x8008ef2 <uart_stm32_async_tx_timeout+0x62> @ imm = #0x22
 8008ece: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008efc <uart_stm32_async_tx_timeout+0x6c>
 8008ed0: 6819         	ldr	r1, [r3]
 8008ed2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008f00 <uart_stm32_async_tx_timeout+0x70>
 8008ed4: 9303         	str	r3, [sp, #0xc]
 8008ed6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008f04 <uart_stm32_async_tx_timeout+0x74>
 8008ed8: 9302         	str	r3, [sp, #0x8]
 8008eda: 2308         	movs	r3, #0x8
 8008edc: 9301         	str	r3, [sp, #0x4]
 8008ede: 2300         	movs	r3, #0x0
 8008ee0: 9300         	str	r3, [sp]
 8008ee2: 2300         	movs	r3, #0x0
 8008ee4: 2204         	movs	r2, #0x4
 8008ee6: 2000         	movs	r0, #0x0
 8008ee8: f00c fb74    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xc6e8
 8008eec: 2300         	movs	r3, #0x0
 8008eee: 60bb         	str	r3, [r7, #0x8]
; }
 8008ef0: bf00         	nop
 8008ef2: bf00         	nop
 8008ef4: 3720         	adds	r7, #0x20
 8008ef6: 46bd         	mov	sp, r7
 8008ef8: bd80         	pop	{r7, pc}
 8008efa: bf00         	nop

08008efc <$d>:
 8008efc: 14 03 00 20  	.word	0x20000314
 8008f00: 50 bb 01 08  	.word	0x0801bb50
 8008f04: 14 ab 01 08  	.word	0x0801ab14

08008f08 <uart_stm32_async_rx_buf_rsp>:
; {
 8008f08: b580         	push	{r7, lr}
 8008f0a: b094         	sub	sp, #0x50
 8008f0c: af06         	add	r7, sp, #0x18
 8008f0e: 60f8         	str	r0, [r7, #0xc]
 8008f10: 60b9         	str	r1, [r7, #0x8]
 8008f12: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 8008f14: 68fb         	ldr	r3, [r7, #0xc]
 8008f16: 691b         	ldr	r3, [r3, #0x10]
 8008f18: 633b         	str	r3, [r7, #0x30]
; 	int err = 0;
 8008f1a: 2300         	movs	r3, #0x0
 8008f1c: 637b         	str	r3, [r7, #0x34]
; 	LOG_DBG("replace buffer (%d)", len);
 8008f1e: 2303         	movs	r3, #0x3
 8008f20: 2b03         	cmp	r3, #0x3
 8008f22: d91c         	bls	0x8008f5e <uart_stm32_async_rx_buf_rsp+0x56> @ imm = #0x38
 8008f24: 2301         	movs	r3, #0x1
 8008f26: f887 302f    	strb.w	r3, [r7, #0x2f]
 8008f2a: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8008f2e: f083 0301    	eor	r3, r3, #0x1
 8008f32: b2db         	uxtb	r3, r3
 8008f34: 2b00         	cmp	r3, #0x0
 8008f36: d112         	bne	0x8008f5e <uart_stm32_async_rx_buf_rsp+0x56> @ imm = #0x24
 8008f38: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8008fdc <uart_stm32_async_rx_buf_rsp+0xd4>
 8008f3a: 6819         	ldr	r1, [r3]
 8008f3c: 687b         	ldr	r3, [r7, #0x4]
 8008f3e: 9304         	str	r3, [sp, #0x10]
 8008f40: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8008fe0 <uart_stm32_async_rx_buf_rsp+0xd8>
 8008f42: 9303         	str	r3, [sp, #0xc]
 8008f44: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8008fe4 <uart_stm32_async_rx_buf_rsp+0xdc>
 8008f46: 9302         	str	r3, [sp, #0x8]
 8008f48: 2308         	movs	r3, #0x8
 8008f4a: 9301         	str	r3, [sp, #0x4]
 8008f4c: 2300         	movs	r3, #0x0
 8008f4e: 9300         	str	r3, [sp]
 8008f50: 2300         	movs	r3, #0x0
 8008f52: 2204         	movs	r2, #0x4
 8008f54: 2000         	movs	r0, #0x0
 8008f56: f00c fb3d    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xc67a
 8008f5a: 2300         	movs	r3, #0x0
 8008f5c: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8008f5e: f3ef 8311    	mrs	r3, basepri
 8008f62: 623b         	str	r3, [r7, #0x20]
;   return(result);
 8008f64: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 8008f66: 61fb         	str	r3, [r7, #0x1c]
 8008f68: 2310         	movs	r3, #0x10
 8008f6a: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8008f6c: 69bb         	ldr	r3, [r7, #0x18]
 8008f6e: f383 8812    	msr	basepri_max, r3
; }
 8008f72: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8008f74: f3bf 8f6f    	isb	sy
; }
 8008f78: bf00         	nop
; 	return key;
 8008f7a: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = irq_lock();
 8008f7c: 627b         	str	r3, [r7, #0x24]
; 	if (data->rx_next_buffer != NULL) {
 8008f7e: 6b3b         	ldr	r3, [r7, #0x30]
 8008f80: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 8008f84: 2b00         	cmp	r3, #0x0
 8008f86: d003         	beq	0x8008f90 <uart_stm32_async_rx_buf_rsp+0x88> @ imm = #0x6
; 		err = -EBUSY;
 8008f88: f06f 030f    	mvn	r3, #0xf
 8008f8c: 637b         	str	r3, [r7, #0x34]
 8008f8e: e013         	b	0x8008fb8 <uart_stm32_async_rx_buf_rsp+0xb0> @ imm = #0x26
; 	} else if (!data->dma_rx.enabled) {
 8008f90: 6b3b         	ldr	r3, [r7, #0x30]
 8008f92: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 8008f96: f083 0301    	eor	r3, r3, #0x1
 8008f9a: b2db         	uxtb	r3, r3
 8008f9c: 2b00         	cmp	r3, #0x0
 8008f9e: d003         	beq	0x8008fa8 <uart_stm32_async_rx_buf_rsp+0xa0> @ imm = #0x6
; 		err = -EACCES;
 8008fa0: f06f 030c    	mvn	r3, #0xc
 8008fa4: 637b         	str	r3, [r7, #0x34]
 8008fa6: e007         	b	0x8008fb8 <uart_stm32_async_rx_buf_rsp+0xb0> @ imm = #0xe
; 		data->rx_next_buffer = buf;
 8008fa8: 6b3b         	ldr	r3, [r7, #0x30]
 8008faa: 68ba         	ldr	r2, [r7, #0x8]
 8008fac: f8c3 2150    	str.w	r2, [r3, #0x150]
; 		data->rx_next_buffer_len = len;
 8008fb0: 6b3b         	ldr	r3, [r7, #0x30]
 8008fb2: 687a         	ldr	r2, [r7, #0x4]
 8008fb4: f8c3 2154    	str.w	r2, [r3, #0x154]
 8008fb8: 6a7b         	ldr	r3, [r7, #0x24]
 8008fba: 617b         	str	r3, [r7, #0x14]
 8008fbc: 697b         	ldr	r3, [r7, #0x14]
 8008fbe: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008fc0: 693b         	ldr	r3, [r7, #0x10]
 8008fc2: f383 8811    	msr	basepri, r3
; }
 8008fc6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8008fc8: f3bf 8f6f    	isb	sy
; }
 8008fcc: bf00         	nop
; }
 8008fce: bf00         	nop
; 	return err;
 8008fd0: 6b7b         	ldr	r3, [r7, #0x34]
; }
 8008fd2: 4618         	mov	r0, r3
 8008fd4: 3738         	adds	r7, #0x38
 8008fd6: 46bd         	mov	sp, r7
 8008fd8: bd80         	pop	{r7, pc}
 8008fda: bf00         	nop

08008fdc <$d>:
 8008fdc: 14 03 00 20  	.word	0x20000314
 8008fe0: 6c bb 01 08  	.word	0x0801bb6c
 8008fe4: 2c ab 01 08  	.word	0x0801ab2c

08008fe8 <uart_stm32_async_init>:
; {
 8008fe8: b580         	push	{r7, lr}
 8008fea: b086         	sub	sp, #0x18
 8008fec: af00         	add	r7, sp, #0x0
 8008fee: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8008ff0: 687b         	ldr	r3, [r7, #0x4]
 8008ff2: 685b         	ldr	r3, [r3, #0x4]
 8008ff4: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 8008ff6: 697b         	ldr	r3, [r7, #0x14]
 8008ff8: 681b         	ldr	r3, [r3]
 8008ffa: 613b         	str	r3, [r7, #0x10]
; 	struct uart_stm32_data *data = dev->data;
 8008ffc: 687b         	ldr	r3, [r7, #0x4]
 8008ffe: 691b         	ldr	r3, [r3, #0x10]
 8009000: 60fb         	str	r3, [r7, #0xc]
; 	data->uart_dev = dev;
 8009002: 68fb         	ldr	r3, [r7, #0xc]
 8009004: 687a         	ldr	r2, [r7, #0x4]
 8009006: 611a         	str	r2, [r3, #0x10]
; 	if (data->dma_rx.dma_dev != NULL) {
 8009008: 68fb         	ldr	r3, [r7, #0xc]
 800900a: 6a1b         	ldr	r3, [r3, #0x20]
 800900c: 2b00         	cmp	r3, #0x0
 800900e: d00d         	beq	0x800902c <uart_stm32_async_init+0x44> @ imm = #0x1a
; 		if (!device_is_ready(data->dma_rx.dma_dev)) {
 8009010: 68fb         	ldr	r3, [r7, #0xc]
 8009012: 6a1b         	ldr	r3, [r3, #0x20]
 8009014: 4618         	mov	r0, r3
 8009016: f00b fd53    	bl	0x8014ac0 <device_is_ready> @ imm = #0xbaa6
 800901a: 4603         	mov	r3, r0
 800901c: f083 0301    	eor	r3, r3, #0x1
 8009020: b2db         	uxtb	r3, r3
 8009022: 2b00         	cmp	r3, #0x0
 8009024: d002         	beq	0x800902c <uart_stm32_async_init+0x44> @ imm = #0x4
; 			return -ENODEV;
 8009026: f06f 0312    	mvn	r3, #0x12
 800902a: e0de         	b	0x80091ea <uart_stm32_async_init+0x202> @ imm = #0x1bc
; 	if (data->dma_tx.dma_dev != NULL) {
 800902c: 68fb         	ldr	r3, [r7, #0xc]
 800902e: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 8009032: 2b00         	cmp	r3, #0x0
 8009034: d00e         	beq	0x8009054 <uart_stm32_async_init+0x6c> @ imm = #0x1c
; 		if (!device_is_ready(data->dma_tx.dma_dev)) {
 8009036: 68fb         	ldr	r3, [r7, #0xc]
 8009038: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800903c: 4618         	mov	r0, r3
 800903e: f00b fd3f    	bl	0x8014ac0 <device_is_ready> @ imm = #0xba7e
 8009042: 4603         	mov	r3, r0
 8009044: f083 0301    	eor	r3, r3, #0x1
 8009048: b2db         	uxtb	r3, r3
 800904a: 2b00         	cmp	r3, #0x0
 800904c: d002         	beq	0x8009054 <uart_stm32_async_init+0x6c> @ imm = #0x4
; 			return -ENODEV;
 800904e: f06f 0312    	mvn	r3, #0x12
 8009052: e0ca         	b	0x80091ea <uart_stm32_async_init+0x202> @ imm = #0x194
; 	uart_stm32_dma_rx_disable(dev);
 8009054: 6878         	ldr	r0, [r7, #0x4]
 8009056: f00d f820    	bl	0x801609a <uart_stm32_dma_rx_disable> @ imm = #0xd040
; 	uart_stm32_dma_tx_disable(dev);
 800905a: 6878         	ldr	r0, [r7, #0x4]
 800905c: f00c fff6    	bl	0x801604c <uart_stm32_dma_tx_disable> @ imm = #0xcfec
; 	k_work_init_delayable(&data->dma_rx.timeout_work,
 8009060: 68fb         	ldr	r3, [r7, #0xc]
 8009062: 3380         	adds	r3, #0x80
 8009064: 4963         	ldr	r1, [pc, #0x18c]        @ 0x80091f4 <uart_stm32_async_init+0x20c>
 8009066: 4618         	mov	r0, r3
 8009068: f00e feff    	bl	0x8017e6a <k_work_init_delayable> @ imm = #0xedfe
; 	k_work_init_delayable(&data->dma_tx.timeout_work,
 800906c: 68fb         	ldr	r3, [r7, #0xc]
 800906e: f503 738c    	add.w	r3, r3, #0x118
 8009072: 4961         	ldr	r1, [pc, #0x184]        @ 0x80091f8 <uart_stm32_async_init+0x210>
 8009074: 4618         	mov	r0, r3
 8009076: f00e fef8    	bl	0x8017e6a <k_work_init_delayable> @ imm = #0xedf0
; 	memset(&data->dma_rx.blk_cfg, 0, sizeof(data->dma_rx.blk_cfg));
 800907a: 68fb         	ldr	r3, [r7, #0xc]
 800907c: 334c         	adds	r3, #0x4c
 800907e: 2220         	movs	r2, #0x20
 8009080: 2100         	movs	r1, #0x0
 8009082: 4618         	mov	r0, r3
 8009084: f00f fe5f    	bl	0x8018d46 <memset>      @ imm = #0xfcbe
; 				LL_USART_DMA_GetRegAddr(usart);
 8009088: 6938         	ldr	r0, [r7, #0x10]
 800908a: f00c fa7e    	bl	0x801558a <LL_USART_DMA_GetRegAddr> @ imm = #0xc4fc
 800908e: 4602         	mov	r2, r0
; 	data->dma_rx.blk_cfg.source_address =
 8009090: 68fb         	ldr	r3, [r7, #0xc]
 8009092: 64da         	str	r2, [r3, #0x4c]
; 	data->dma_rx.blk_cfg.dest_address = 0; /* dest not ready */
 8009094: 68fb         	ldr	r3, [r7, #0xc]
 8009096: 2200         	movs	r2, #0x0
 8009098: 651a         	str	r2, [r3, #0x50]
; 	if (data->dma_rx.src_addr_increment) {
 800909a: 68fb         	ldr	r3, [r7, #0xc]
 800909c: f893 3045    	ldrb.w	r3, [r3, #0x45]
 80090a0: 2b00         	cmp	r3, #0x0
 80090a2: d007         	beq	0x80090b4 <uart_stm32_async_init+0xcc> @ imm = #0xe
; 		data->dma_rx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 80090a4: 68fa         	ldr	r2, [r7, #0xc]
 80090a6: f892 3068    	ldrb.w	r3, [r2, #0x68]
 80090aa: f36f 0383    	bfc	r3, #2, #2
 80090ae: f882 3068    	strb.w	r3, [r2, #0x68]
 80090b2: e007         	b	0x80090c4 <uart_stm32_async_init+0xdc> @ imm = #0xe
; 		data->dma_rx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 80090b4: 68fa         	ldr	r2, [r7, #0xc]
 80090b6: f892 3068    	ldrb.w	r3, [r2, #0x68]
 80090ba: 2102         	movs	r1, #0x2
 80090bc: f361 0383    	bfi	r3, r1, #2, #2
 80090c0: f882 3068    	strb.w	r3, [r2, #0x68]
; 	if (data->dma_rx.dst_addr_increment) {
 80090c4: 68fb         	ldr	r3, [r7, #0xc]
 80090c6: f893 3046    	ldrb.w	r3, [r3, #0x46]
 80090ca: 2b00         	cmp	r3, #0x0
 80090cc: d007         	beq	0x80090de <uart_stm32_async_init+0xf6> @ imm = #0xe
; 		data->dma_rx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 80090ce: 68fa         	ldr	r2, [r7, #0xc]
 80090d0: f892 3068    	ldrb.w	r3, [r2, #0x68]
 80090d4: f36f 1305    	bfc	r3, #4, #2
 80090d8: f882 3068    	strb.w	r3, [r2, #0x68]
 80090dc: e007         	b	0x80090ee <uart_stm32_async_init+0x106> @ imm = #0xe
; 		data->dma_rx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 80090de: 68fa         	ldr	r2, [r7, #0xc]
 80090e0: f892 3068    	ldrb.w	r3, [r2, #0x68]
 80090e4: 2102         	movs	r1, #0x2
 80090e6: f361 1305    	bfi	r3, r1, #4, #2
 80090ea: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.source_reload_en  = 0;
 80090ee: 68fa         	ldr	r2, [r7, #0xc]
 80090f0: f892 3068    	ldrb.w	r3, [r2, #0x68]
 80090f4: f36f 1386    	bfc	r3, #6, #1
 80090f8: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.dest_reload_en = 0;
 80090fc: 68fa         	ldr	r2, [r7, #0xc]
 80090fe: f892 3068    	ldrb.w	r3, [r2, #0x68]
 8009102: f36f 13c7    	bfc	r3, #7, #1
 8009106: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.fifo_mode_control = data->dma_rx.fifo_threshold;
 800910a: 68fb         	ldr	r3, [r7, #0xc]
 800910c: 6c9b         	ldr	r3, [r3, #0x48]
 800910e: f003 030f    	and	r3, r3, #0xf
 8009112: b2d9         	uxtb	r1, r3
 8009114: 68fa         	ldr	r2, [r7, #0xc]
 8009116: f892 3069    	ldrb.w	r3, [r2, #0x69]
 800911a: f361 0303    	bfi	r3, r1, #0, #4
 800911e: f882 3069    	strb.w	r3, [r2, #0x69]
; 	data->dma_rx.dma_cfg.head_block = &data->dma_rx.blk_cfg;
 8009122: 68fb         	ldr	r3, [r7, #0xc]
 8009124: f103 024c    	add.w	r2, r3, #0x4c
 8009128: 68fb         	ldr	r3, [r7, #0xc]
 800912a: 639a         	str	r2, [r3, #0x38]
; 	data->dma_rx.dma_cfg.user_data = (void *)dev;
 800912c: 68fb         	ldr	r3, [r7, #0xc]
 800912e: 687a         	ldr	r2, [r7, #0x4]
 8009130: 63da         	str	r2, [r3, #0x3c]
; 	data->rx_next_buffer = NULL;
 8009132: 68fb         	ldr	r3, [r7, #0xc]
 8009134: 2200         	movs	r2, #0x0
 8009136: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800913a: 68fb         	ldr	r3, [r7, #0xc]
 800913c: 2200         	movs	r2, #0x0
 800913e: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	memset(&data->dma_tx.blk_cfg, 0, sizeof(data->dma_tx.blk_cfg));
 8009142: 68fb         	ldr	r3, [r7, #0xc]
 8009144: 33e4         	adds	r3, #0xe4
 8009146: 2220         	movs	r2, #0x20
 8009148: 2100         	movs	r1, #0x0
 800914a: 4618         	mov	r0, r3
 800914c: f00f fdfb    	bl	0x8018d46 <memset>      @ imm = #0xfbf6
; 			LL_USART_DMA_GetRegAddr(usart);
 8009150: 6938         	ldr	r0, [r7, #0x10]
 8009152: f00c fa1a    	bl	0x801558a <LL_USART_DMA_GetRegAddr> @ imm = #0xc434
 8009156: 4602         	mov	r2, r0
; 	data->dma_tx.blk_cfg.dest_address =
 8009158: 68fb         	ldr	r3, [r7, #0xc]
 800915a: f8c3 20e8    	str.w	r2, [r3, #0xe8]
; 	data->dma_tx.blk_cfg.source_address = 0; /* not ready */
 800915e: 68fb         	ldr	r3, [r7, #0xc]
 8009160: 2200         	movs	r2, #0x0
 8009162: f8c3 20e4    	str.w	r2, [r3, #0xe4]
; 	if (data->dma_tx.src_addr_increment) {
 8009166: 68fb         	ldr	r3, [r7, #0xc]
 8009168: f893 30dd    	ldrb.w	r3, [r3, #0xdd]
 800916c: 2b00         	cmp	r3, #0x0
 800916e: d007         	beq	0x8009180 <uart_stm32_async_init+0x198> @ imm = #0xe
; 		data->dma_tx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 8009170: 68fa         	ldr	r2, [r7, #0xc]
 8009172: f892 3100    	ldrb.w	r3, [r2, #0x100]
 8009176: f36f 0383    	bfc	r3, #2, #2
 800917a: f882 3100    	strb.w	r3, [r2, #0x100]
 800917e: e007         	b	0x8009190 <uart_stm32_async_init+0x1a8> @ imm = #0xe
; 		data->dma_tx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 8009180: 68fa         	ldr	r2, [r7, #0xc]
 8009182: f892 3100    	ldrb.w	r3, [r2, #0x100]
 8009186: 2102         	movs	r1, #0x2
 8009188: f361 0383    	bfi	r3, r1, #2, #2
 800918c: f882 3100    	strb.w	r3, [r2, #0x100]
; 	if (data->dma_tx.dst_addr_increment) {
 8009190: 68fb         	ldr	r3, [r7, #0xc]
 8009192: f893 30de    	ldrb.w	r3, [r3, #0xde]
 8009196: 2b00         	cmp	r3, #0x0
 8009198: d007         	beq	0x80091aa <uart_stm32_async_init+0x1c2> @ imm = #0xe
; 		data->dma_tx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800919a: 68fa         	ldr	r2, [r7, #0xc]
 800919c: f892 3100    	ldrb.w	r3, [r2, #0x100]
 80091a0: f36f 1305    	bfc	r3, #4, #2
 80091a4: f882 3100    	strb.w	r3, [r2, #0x100]
 80091a8: e007         	b	0x80091ba <uart_stm32_async_init+0x1d2> @ imm = #0xe
; 		data->dma_tx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 80091aa: 68fa         	ldr	r2, [r7, #0xc]
 80091ac: f892 3100    	ldrb.w	r3, [r2, #0x100]
 80091b0: 2102         	movs	r1, #0x2
 80091b2: f361 1305    	bfi	r3, r1, #4, #2
 80091b6: f882 3100    	strb.w	r3, [r2, #0x100]
; 	data->dma_tx.blk_cfg.fifo_mode_control = data->dma_tx.fifo_threshold;
 80091ba: 68fb         	ldr	r3, [r7, #0xc]
 80091bc: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 80091c0: f003 030f    	and	r3, r3, #0xf
 80091c4: b2d9         	uxtb	r1, r3
 80091c6: 68fa         	ldr	r2, [r7, #0xc]
 80091c8: f892 3101    	ldrb.w	r3, [r2, #0x101]
 80091cc: f361 0303    	bfi	r3, r1, #0, #4
 80091d0: f882 3101    	strb.w	r3, [r2, #0x101]
; 	data->dma_tx.dma_cfg.head_block = &data->dma_tx.blk_cfg;
 80091d4: 68fb         	ldr	r3, [r7, #0xc]
 80091d6: f103 02e4    	add.w	r2, r3, #0xe4
 80091da: 68fb         	ldr	r3, [r7, #0xc]
 80091dc: f8c3 20d0    	str.w	r2, [r3, #0xd0]
; 	data->dma_tx.dma_cfg.user_data = (void *)dev;
 80091e0: 68fb         	ldr	r3, [r7, #0xc]
 80091e2: 687a         	ldr	r2, [r7, #0x4]
 80091e4: f8c3 20d4    	str.w	r2, [r3, #0xd4]
; 	return 0;
 80091e8: 2300         	movs	r3, #0x0
; }
 80091ea: 4618         	mov	r0, r3
 80091ec: 3718         	adds	r7, #0x18
 80091ee: 46bd         	mov	sp, r7
 80091f0: bd80         	pop	{r7, pc}
 80091f2: bf00         	nop

080091f4 <$d>:
 80091f4: 09 8e 00 08  	.word	0x08008e09
 80091f8: 91 8e 00 08  	.word	0x08008e91

080091fc <uart_stm32_clocks_enable>:
; {
 80091fc: b580         	push	{r7, lr}
 80091fe: b08e         	sub	sp, #0x38
 8009200: af04         	add	r7, sp, #0x10
 8009202: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8009204: 687b         	ldr	r3, [r7, #0x4]
 8009206: 685b         	ldr	r3, [r3, #0x4]
 8009208: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 800920a: 687b         	ldr	r3, [r7, #0x4]
 800920c: 691b         	ldr	r3, [r3, #0x10]
 800920e: 627b         	str	r3, [r7, #0x24]
; 	__uart_stm32_get_clock(dev);
 8009210: 6878         	ldr	r0, [r7, #0x4]
 8009212: f7ff f853    	bl	0x80082bc <__uart_stm32_get_clock> @ imm = #-0xf5a
; 	if (!device_is_ready(data->clock)) {
 8009216: 6a7b         	ldr	r3, [r7, #0x24]
 8009218: 681b         	ldr	r3, [r3]
 800921a: 4618         	mov	r0, r3
 800921c: f00b fc50    	bl	0x8014ac0 <device_is_ready> @ imm = #0xb8a0
 8009220: 4603         	mov	r3, r0
 8009222: f083 0301    	eor	r3, r3, #0x1
 8009226: b2db         	uxtb	r3, r3
 8009228: 2b00         	cmp	r3, #0x0
 800922a: d01c         	beq	0x8009266 <uart_stm32_clocks_enable+0x6a> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 800922c: 2303         	movs	r3, #0x3
 800922e: 2b00         	cmp	r3, #0x0
 8009230: d016         	beq	0x8009260 <uart_stm32_clocks_enable+0x64> @ imm = #0x2c
 8009232: 2301         	movs	r3, #0x1
 8009234: 74fb         	strb	r3, [r7, #0x13]
 8009236: 7cfb         	ldrb	r3, [r7, #0x13]
 8009238: f083 0301    	eor	r3, r3, #0x1
 800923c: b2db         	uxtb	r3, r3
 800923e: 2b00         	cmp	r3, #0x0
 8009240: d10e         	bne	0x8009260 <uart_stm32_clocks_enable+0x64> @ imm = #0x1c
 8009242: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80092c0 <uart_stm32_clocks_enable+0xc4>
 8009244: 6819         	ldr	r1, [r3]
 8009246: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80092c4 <uart_stm32_clocks_enable+0xc8>
 8009248: 9302         	str	r3, [sp, #0x8]
 800924a: 2300         	movs	r3, #0x0
 800924c: 9301         	str	r3, [sp, #0x4]
 800924e: 2300         	movs	r3, #0x0
 8009250: 9300         	str	r3, [sp]
 8009252: 2300         	movs	r3, #0x0
 8009254: 2201         	movs	r2, #0x1
 8009256: 2000         	movs	r0, #0x0
 8009258: f00c f9bc    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xc378
 800925c: 2300         	movs	r3, #0x0
 800925e: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 8009260: f06f 0312    	mvn	r3, #0x12
 8009264: e028         	b	0x80092b8 <uart_stm32_clocks_enable+0xbc> @ imm = #0x50
; 	err = clock_control_on(data->clock, (clock_control_subsys_t)&config->pclken[0]);
 8009266: 6a7b         	ldr	r3, [r7, #0x24]
 8009268: 681a         	ldr	r2, [r3]
 800926a: 6a3b         	ldr	r3, [r7, #0x20]
 800926c: 68db         	ldr	r3, [r3, #0xc]
 800926e: 4619         	mov	r1, r3
 8009270: 4610         	mov	r0, r2
 8009272: f00b fc3b    	bl	0x8014aec <clock_control_on> @ imm = #0xb876
 8009276: 61f8         	str	r0, [r7, #0x1c]
; 	if (err != 0) {
 8009278: 69fb         	ldr	r3, [r7, #0x1c]
 800927a: 2b00         	cmp	r3, #0x0
 800927c: d01b         	beq	0x80092b6 <uart_stm32_clocks_enable+0xba> @ imm = #0x36
; 		LOG_ERR("Could not enable (LP)UART clock");
 800927e: 2303         	movs	r3, #0x3
 8009280: 2b00         	cmp	r3, #0x0
 8009282: d016         	beq	0x80092b2 <uart_stm32_clocks_enable+0xb6> @ imm = #0x2c
 8009284: 2301         	movs	r3, #0x1
 8009286: 76fb         	strb	r3, [r7, #0x1b]
 8009288: 7efb         	ldrb	r3, [r7, #0x1b]
 800928a: f083 0301    	eor	r3, r3, #0x1
 800928e: b2db         	uxtb	r3, r3
 8009290: 2b00         	cmp	r3, #0x0
 8009292: d10e         	bne	0x80092b2 <uart_stm32_clocks_enable+0xb6> @ imm = #0x1c
 8009294: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80092c0 <uart_stm32_clocks_enable+0xc4>
 8009296: 6819         	ldr	r1, [r3]
 8009298: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80092c8 <uart_stm32_clocks_enable+0xcc>
 800929a: 9302         	str	r3, [sp, #0x8]
 800929c: 2300         	movs	r3, #0x0
 800929e: 9301         	str	r3, [sp, #0x4]
 80092a0: 2300         	movs	r3, #0x0
 80092a2: 9300         	str	r3, [sp]
 80092a4: 2300         	movs	r3, #0x0
 80092a6: 2201         	movs	r2, #0x1
 80092a8: 2000         	movs	r0, #0x0
 80092aa: f00c f993    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xc326
 80092ae: 2300         	movs	r3, #0x0
 80092b0: 617b         	str	r3, [r7, #0x14]
; 		return err;
 80092b2: 69fb         	ldr	r3, [r7, #0x1c]
 80092b4: e000         	b	0x80092b8 <uart_stm32_clocks_enable+0xbc> @ imm = #0x0
; 	return 0;
 80092b6: 2300         	movs	r3, #0x0
; }
 80092b8: 4618         	mov	r0, r3
 80092ba: 3728         	adds	r7, #0x28
 80092bc: 46bd         	mov	sp, r7
 80092be: bd80         	pop	{r7, pc}

080092c0 <$d>:
 80092c0: 14 03 00 20  	.word	0x20000314
 80092c4: 44 ab 01 08  	.word	0x0801ab44
 80092c8: 64 ab 01 08  	.word	0x0801ab64

080092cc <uart_stm32_registers_configure>:
; {
 80092cc: b580         	push	{r7, lr}
 80092ce: b08c         	sub	sp, #0x30
 80092d0: af04         	add	r7, sp, #0x10
 80092d2: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80092d4: 687b         	ldr	r3, [r7, #0x4]
 80092d6: 685b         	ldr	r3, [r3, #0x4]
 80092d8: 61fb         	str	r3, [r7, #0x1c]
; 	USART_TypeDef *usart = config->usart;
 80092da: 69fb         	ldr	r3, [r7, #0x1c]
 80092dc: 681b         	ldr	r3, [r3]
 80092de: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = dev->data;
 80092e0: 687b         	ldr	r3, [r7, #0x4]
 80092e2: 691b         	ldr	r3, [r3, #0x10]
 80092e4: 617b         	str	r3, [r7, #0x14]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 80092e6: 697b         	ldr	r3, [r7, #0x14]
 80092e8: 685b         	ldr	r3, [r3, #0x4]
 80092ea: 613b         	str	r3, [r7, #0x10]
; 	LL_USART_Disable(usart);
 80092ec: 69b8         	ldr	r0, [r7, #0x18]
 80092ee: f00b fd30    	bl	0x8014d52 <LL_USART_Disable> @ imm = #0xba60
; 	if (!device_is_ready(config->reset.dev)) {
 80092f2: 69fb         	ldr	r3, [r7, #0x1c]
 80092f4: 685b         	ldr	r3, [r3, #0x4]
 80092f6: 4618         	mov	r0, r3
 80092f8: f00b fbe2    	bl	0x8014ac0 <device_is_ready> @ imm = #0xb7c4
 80092fc: 4603         	mov	r3, r0
 80092fe: f083 0301    	eor	r3, r3, #0x1
 8009302: b2db         	uxtb	r3, r3
 8009304: 2b00         	cmp	r3, #0x0
 8009306: d01c         	beq	0x8009342 <uart_stm32_registers_configure+0x76> @ imm = #0x38
; 		LOG_ERR("reset controller not ready");
 8009308: 2303         	movs	r3, #0x3
 800930a: 2b00         	cmp	r3, #0x0
 800930c: d016         	beq	0x800933c <uart_stm32_registers_configure+0x70> @ imm = #0x2c
 800930e: 2301         	movs	r3, #0x1
 8009310: 73fb         	strb	r3, [r7, #0xf]
 8009312: 7bfb         	ldrb	r3, [r7, #0xf]
 8009314: f083 0301    	eor	r3, r3, #0x1
 8009318: b2db         	uxtb	r3, r3
 800931a: 2b00         	cmp	r3, #0x0
 800931c: d10e         	bne	0x800933c <uart_stm32_registers_configure+0x70> @ imm = #0x1c
 800931e: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800937c <uart_stm32_registers_configure+0xb0>
 8009320: 6819         	ldr	r1, [r3]
 8009322: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8009380 <uart_stm32_registers_configure+0xb4>
 8009324: 9302         	str	r3, [sp, #0x8]
 8009326: 2300         	movs	r3, #0x0
 8009328: 9301         	str	r3, [sp, #0x4]
 800932a: 2300         	movs	r3, #0x0
 800932c: 9300         	str	r3, [sp]
 800932e: 2300         	movs	r3, #0x0
 8009330: 2201         	movs	r2, #0x1
 8009332: 2000         	movs	r0, #0x0
 8009334: f00c f94e    	bl	0x80155d4 <z_log_msg_runtime_create> @ imm = #0xc29c
 8009338: 2300         	movs	r3, #0x0
 800933a: 60bb         	str	r3, [r7, #0x8]
; 		return -ENODEV;
 800933c: f06f 0312    	mvn	r3, #0x12
 8009340: e017         	b	0x8009372 <uart_stm32_registers_configure+0xa6> @ imm = #0x2e
; 	(void)reset_line_toggle_dt(&config->reset);
 8009342: 69fb         	ldr	r3, [r7, #0x1c]
 8009344: 3304         	adds	r3, #0x4
 8009346: 4618         	mov	r0, r3
 8009348: f00b fcd5    	bl	0x8014cf6 <reset_line_toggle_dt> @ imm = #0xb9aa
; 	LL_USART_SetTransferDirection(usart, LL_USART_DIRECTION_TX_RX);
 800934c: 210c         	movs	r1, #0xc
 800934e: 69b8         	ldr	r0, [r7, #0x18]
 8009350: f00b fd0e    	bl	0x8014d70 <LL_USART_SetTransferDirection> @ imm = #0xba1c
; 	uart_stm32_parameters_set(dev, uart_cfg);
 8009354: 6939         	ldr	r1, [r7, #0x10]
 8009356: 6878         	ldr	r0, [r7, #0x4]
 8009358: f00c faac    	bl	0x80158b4 <uart_stm32_parameters_set> @ imm = #0xc558
; 	if (config->single_wire) {
 800935c: 69fb         	ldr	r3, [r7, #0x1c]
 800935e: 7d1b         	ldrb	r3, [r3, #0x14]
 8009360: 2b00         	cmp	r3, #0x0
 8009362: d002         	beq	0x800936a <uart_stm32_registers_configure+0x9e> @ imm = #0x4
; 		LL_USART_EnableHalfDuplex(usart);
 8009364: 69b8         	ldr	r0, [r7, #0x18]
 8009366: f00b fdd4    	bl	0x8014f12 <LL_USART_EnableHalfDuplex> @ imm = #0xbba8
; 	LL_USART_Enable(usart);
 800936a: 69b8         	ldr	r0, [r7, #0x18]
 800936c: f00b fce2    	bl	0x8014d34 <LL_USART_Enable> @ imm = #0xb9c4
; 	return 0;
 8009370: 2300         	movs	r3, #0x0
; }
 8009372: 4618         	mov	r0, r3
 8009374: 3720         	adds	r7, #0x20
 8009376: 46bd         	mov	sp, r7
 8009378: bd80         	pop	{r7, pc}
 800937a: bf00         	nop

0800937c <$d>:
 800937c: 14 03 00 20  	.word	0x20000314
 8009380: 84 ab 01 08  	.word	0x0801ab84

08009384 <__NVIC_SetPriority>:
; {
 8009384: b480         	push	{r7}
 8009386: b083         	sub	sp, #0xc
 8009388: af00         	add	r7, sp, #0x0
 800938a: 4603         	mov	r3, r0
 800938c: 6039         	str	r1, [r7]
 800938e: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8009390: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8009394: 2b00         	cmp	r3, #0x0
 8009396: db0a         	blt	0x80093ae <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8009398: 683b         	ldr	r3, [r7]
 800939a: b2da         	uxtb	r2, r3
 800939c: 490c         	ldr	r1, [pc, #0x30]         @ 0x80093d0 <__NVIC_SetPriority+0x4c>
 800939e: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80093a2: 0112         	lsls	r2, r2, #0x4
 80093a4: b2d2         	uxtb	r2, r2
 80093a6: 440b         	add	r3, r1
 80093a8: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 80093ac: e00a         	b	0x80093c4 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80093ae: 683b         	ldr	r3, [r7]
 80093b0: b2da         	uxtb	r2, r3
 80093b2: 4908         	ldr	r1, [pc, #0x20]         @ 0x80093d4 <__NVIC_SetPriority+0x50>
 80093b4: 79fb         	ldrb	r3, [r7, #0x7]
 80093b6: f003 030f    	and	r3, r3, #0xf
 80093ba: 3b04         	subs	r3, #0x4
 80093bc: 0112         	lsls	r2, r2, #0x4
 80093be: b2d2         	uxtb	r2, r2
 80093c0: 440b         	add	r3, r1
 80093c2: 761a         	strb	r2, [r3, #0x18]
; }
 80093c4: bf00         	nop
 80093c6: 370c         	adds	r7, #0xc
 80093c8: 46bd         	mov	sp, r7
 80093ca: bc80         	pop	{r7}
 80093cc: 4770         	bx	lr
 80093ce: bf00         	nop

080093d0 <$d>:
 80093d0: 00 e1 00 e0  	.word	0xe000e100
 80093d4: 00 ed 00 e0  	.word	0xe000ed00

080093d8 <elapsed>:
; {
 80093d8: b480         	push	{r7}
 80093da: b085         	sub	sp, #0x14
 80093dc: af00         	add	r7, sp, #0x0
; 	uint32_t val1 = SysTick->VAL;	/* A */
 80093de: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8009444 <elapsed+0x6c>
 80093e0: 689b         	ldr	r3, [r3, #0x8]
 80093e2: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ctrl = SysTick->CTRL;	/* B */
 80093e4: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8009444 <elapsed+0x6c>
 80093e6: 681b         	ldr	r3, [r3]
 80093e8: 607b         	str	r3, [r7, #0x4]
; 	uint32_t val2 = SysTick->VAL;	/* C */
 80093ea: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8009444 <elapsed+0x6c>
 80093ec: 689b         	ldr	r3, [r3, #0x8]
 80093ee: 60bb         	str	r3, [r7, #0x8]
; 	if (val1 == 0) {
 80093f0: 68fb         	ldr	r3, [r7, #0xc]
 80093f2: 2b00         	cmp	r3, #0x0
 80093f4: d102         	bne	0x80093fc <elapsed+0x24> @ imm = #0x4
; 		val1 = last_load;
 80093f6: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8009448 <elapsed+0x70>
 80093f8: 681b         	ldr	r3, [r3]
 80093fa: 60fb         	str	r3, [r7, #0xc]
; 	if (val2 == 0) {
 80093fc: 68bb         	ldr	r3, [r7, #0x8]
 80093fe: 2b00         	cmp	r3, #0x0
 8009400: d102         	bne	0x8009408 <elapsed+0x30> @ imm = #0x4
; 		val2 = last_load;
 8009402: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8009448 <elapsed+0x70>
 8009404: 681b         	ldr	r3, [r3]
 8009406: 60bb         	str	r3, [r7, #0x8]
; 	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
 8009408: 687b         	ldr	r3, [r7, #0x4]
 800940a: f403 3380    	and	r3, r3, #0x10000
 800940e: 2b00         	cmp	r3, #0x0
 8009410: d103         	bne	0x800941a <elapsed+0x42> @ imm = #0x6
; 	    || (val1 < val2)) {
 8009412: 68fa         	ldr	r2, [r7, #0xc]
 8009414: 68bb         	ldr	r3, [r7, #0x8]
 8009416: 429a         	cmp	r2, r3
 8009418: d208         	bhs	0x800942c <elapsed+0x54> @ imm = #0x10
; 		overflow_cyc += last_load;
 800941a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800944c <elapsed+0x74>
 800941c: 681a         	ldr	r2, [r3]
 800941e: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8009448 <elapsed+0x70>
 8009420: 681b         	ldr	r3, [r3]
 8009422: 4413         	add	r3, r2
 8009424: 4a09         	ldr	r2, [pc, #0x24]         @ 0x800944c <elapsed+0x74>
 8009426: 6013         	str	r3, [r2]
; 		(void)SysTick->CTRL;
 8009428: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8009444 <elapsed+0x6c>
 800942a: 681b         	ldr	r3, [r3]
; 	return (last_load - val2) + overflow_cyc;
 800942c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8009448 <elapsed+0x70>
 800942e: 681a         	ldr	r2, [r3]
 8009430: 68bb         	ldr	r3, [r7, #0x8]
 8009432: 1ad2         	subs	r2, r2, r3
 8009434: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800944c <elapsed+0x74>
 8009436: 681b         	ldr	r3, [r3]
 8009438: 4413         	add	r3, r2
; }
 800943a: 4618         	mov	r0, r3
 800943c: 3714         	adds	r7, #0x14
 800943e: 46bd         	mov	sp, r7
 8009440: bc80         	pop	{r7}
 8009442: 4770         	bx	lr

08009444 <$d>:
 8009444: 10 e0 00 e0  	.word	0xe000e010
 8009448: 24 0f 00 20  	.word	0x20000f24
 800944c: 28 0f 00 20  	.word	0x20000f28

08009450 <sys_clock_isr>:
; {
 8009450: 4668         	mov	r0, sp
 8009452: f020 0107    	bic	r1, r0, #0x7
 8009456: 468d         	mov	sp, r1
 8009458: e92d 4fb1    	push.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 800945c: b085         	sub	sp, #0x14
 800945e: af00         	add	r7, sp, #0x0
; 	elapsed();
 8009460: f7ff ffba    	bl	0x80093d8 <elapsed>     @ imm = #-0x8c
; 	cycle_count += overflow_cyc;
 8009464: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80094f0 <sys_clock_isr+0xa0>
 8009466: 681b         	ldr	r3, [r3]
 8009468: 2200         	movs	r2, #0x0
 800946a: 4698         	mov	r8, r3
 800946c: 4691         	mov	r9, r2
 800946e: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80094f4 <sys_clock_isr+0xa4>
 8009470: e9d3 2300    	ldrd	r2, r3, [r3]
 8009474: eb18 0102    	adds.w	r1, r8, r2
 8009478: 6039         	str	r1, [r7]
 800947a: eb49 0303    	adc.w	r3, r9, r3
 800947e: 607b         	str	r3, [r7, #0x4]
 8009480: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80094f4 <sys_clock_isr+0xa4>
 8009482: e9d7 1200    	ldrd	r1, r2, [r7]
 8009486: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0;
 800948a: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80094f0 <sys_clock_isr+0xa0>
 800948c: 2200         	movs	r2, #0x0
 800948e: 601a         	str	r2, [r3]
; 		dcycles = cycle_count - announced_cycles;
 8009490: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80094f4 <sys_clock_isr+0xa4>
 8009492: e9d3 2300    	ldrd	r2, r3, [r3]
 8009496: 4611         	mov	r1, r2
 8009498: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80094f8 <sys_clock_isr+0xa8>
 800949a: e9d3 2300    	ldrd	r2, r3, [r3]
 800949e: 4613         	mov	r3, r2
 80094a0: 1acb         	subs	r3, r1, r3
 80094a2: 60fb         	str	r3, [r7, #0xc]
; 		dticks = dcycles / CYC_PER_TICK;
 80094a4: 68fb         	ldr	r3, [r7, #0xc]
 80094a6: 4a15         	ldr	r2, [pc, #0x54]         @ 0x80094fc <sys_clock_isr+0xac>
 80094a8: fba2 2303    	umull	r2, r3, r2, r3
 80094ac: 0b9b         	lsrs	r3, r3, #0xe
 80094ae: 60bb         	str	r3, [r7, #0x8]
; 		announced_cycles += dticks * CYC_PER_TICK;
 80094b0: 68bb         	ldr	r3, [r7, #0x8]
 80094b2: f244 12a0    	movw	r2, #0x41a0
 80094b6: fb02 f303    	mul	r3, r2, r3
 80094ba: 2200         	movs	r2, #0x0
 80094bc: 461c         	mov	r4, r3
 80094be: 4615         	mov	r5, r2
 80094c0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80094f8 <sys_clock_isr+0xa8>
 80094c2: e9d3 2300    	ldrd	r2, r3, [r3]
 80094c6: eb14 0a02    	adds.w	r10, r4, r2
 80094ca: eb45 0b03    	adc.w	r11, r5, r3
 80094ce: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80094f8 <sys_clock_isr+0xa8>
 80094d0: e9c3 ab00    	strd	r10, r11, [r3]
; 		sys_clock_announce(dticks);
 80094d4: 68bb         	ldr	r3, [r7, #0x8]
 80094d6: 4618         	mov	r0, r3
 80094d8: f005 fb1e    	bl	0x800eb18 <sys_clock_announce> @ imm = #0x563c
; 	z_arm_int_exit();
 80094dc: f7f9 fb38    	bl	0x8002b50 <z_arm_int_exit> @ imm = #-0x6990
; }
 80094e0: bf00         	nop
 80094e2: 3714         	adds	r7, #0x14
 80094e4: 46bd         	mov	sp, r7
 80094e6: e8bd 4fb1    	pop.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 80094ea: 4685         	mov	sp, r0
 80094ec: 4770         	bx	lr
 80094ee: bf00         	nop

080094f0 <$d>:
 80094f0: 28 0f 00 20  	.word	0x20000f28
 80094f4: e8 05 00 20  	.word	0x200005e8
 80094f8: f0 05 00 20  	.word	0x200005f0
 80094fc: 2d 34 a9 f9  	.word	0xf9a9342d

08009500 <sys_clock_set_timeout>:
; {
 8009500: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8009504: b09a         	sub	sp, #0x68
 8009506: af00         	add	r7, sp, #0x0
 8009508: 61f8         	str	r0, [r7, #0x1c]
 800950a: 460b         	mov	r3, r1
 800950c: 76fb         	strb	r3, [r7, #0x1b]
; 	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
 800950e: 7efb         	ldrb	r3, [r7, #0x1b]
 8009510: 2b00         	cmp	r3, #0x0
 8009512: d00e         	beq	0x8009532 <sys_clock_set_timeout+0x32> @ imm = #0x1c
 8009514: 69fb         	ldr	r3, [r7, #0x1c]
 8009516: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800951a: d10a         	bne	0x8009532 <sys_clock_set_timeout+0x32> @ imm = #0x14
; 		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
 800951c: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x80096e8 <sys_clock_set_timeout+0x1e8>
 800951e: 681b         	ldr	r3, [r3]
 8009520: 4a71         	ldr	r2, [pc, #0x1c4]        @ 0x80096e8 <sys_clock_set_timeout+0x1e8>
 8009522: f023 0301    	bic	r3, r3, #0x1
 8009526: 6013         	str	r3, [r2]
; 		last_load = TIMER_STOPPED;
 8009528: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x80096ec <sys_clock_set_timeout+0x1ec>
 800952a: f04f 427f    	mov.w	r2, #0xff000000
 800952e: 601a         	str	r2, [r3]
 8009530: e0d6         	b	0x80096e0 <sys_clock_set_timeout+0x1e0> @ imm = #0x1ac
; 	uint32_t last_load_ = last_load;
 8009532: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x80096ec <sys_clock_set_timeout+0x1ec>
 8009534: 681b         	ldr	r3, [r3]
 8009536: 667b         	str	r3, [r7, #0x64]
; 	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 8009538: 69fb         	ldr	r3, [r7, #0x1c]
 800953a: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800953e: d001         	beq	0x8009544 <sys_clock_set_timeout+0x44> @ imm = #0x2
 8009540: 69fb         	ldr	r3, [r7, #0x1c]
 8009542: e001         	b	0x8009548 <sys_clock_set_timeout+0x48> @ imm = #0x2
 8009544: f240 33e5    	movw	r3, #0x3e5
 8009548: 61fb         	str	r3, [r7, #0x1c]
; 	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
 800954a: 69fb         	ldr	r3, [r7, #0x1c]
 800954c: 2b01         	cmp	r3, #0x1
 800954e: dd07         	ble	0x8009560 <sys_clock_set_timeout+0x60> @ imm = #0xe
 8009550: 69fb         	ldr	r3, [r7, #0x1c]
 8009552: f240 32e6    	movw	r2, #0x3e6
 8009556: 4293         	cmp	r3, r2
 8009558: bfa8         	it	ge
 800955a: 4613         	movge	r3, r2
 800955c: 3b01         	subs	r3, #0x1
 800955e: e000         	b	0x8009562 <sys_clock_set_timeout+0x62> @ imm = #0x0
 8009560: 2300         	movs	r3, #0x0
 8009562: 61fb         	str	r3, [r7, #0x1c]
 8009564: 4b62         	ldr	r3, [pc, #0x188]        @ 0x80096f0 <sys_clock_set_timeout+0x1f0>
 8009566: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8009568: f3ef 8311    	mrs	r3, basepri
 800956c: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800956e: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 8009570: 647b         	str	r3, [r7, #0x44]
 8009572: 2310         	movs	r3, #0x10
 8009574: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8009576: 6c3b         	ldr	r3, [r7, #0x40]
 8009578: f383 8812    	msr	basepri_max, r3
; }
 800957c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800957e: f3bf 8f6f    	isb	sy
; }
 8009582: bf00         	nop
; 	return key;
 8009584: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 8009586: 623b         	str	r3, [r7, #0x20]
 8009588: 6cfb         	ldr	r3, [r7, #0x4c]
 800958a: 63fb         	str	r3, [r7, #0x3c]
; }
 800958c: bf00         	nop
 800958e: 6cfb         	ldr	r3, [r7, #0x4c]
 8009590: 63bb         	str	r3, [r7, #0x38]
; }
 8009592: bf00         	nop
; 	return k;
 8009594: 6a3b         	ldr	r3, [r7, #0x20]
 8009596: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pending = elapsed();
 8009598: f7ff ff1e    	bl	0x80093d8 <elapsed>     @ imm = #-0x1c4
 800959c: 6638         	str	r0, [r7, #0x60]
; 	val1 = SysTick->VAL;
 800959e: 4b52         	ldr	r3, [pc, #0x148]        @ 0x80096e8 <sys_clock_set_timeout+0x1e8>
 80095a0: 689b         	ldr	r3, [r3, #0x8]
 80095a2: 65fb         	str	r3, [r7, #0x5c]
; 	cycle_count += pending;
 80095a4: 6e3b         	ldr	r3, [r7, #0x60]
 80095a6: 2200         	movs	r2, #0x0
 80095a8: 469a         	mov	r10, r3
 80095aa: 4693         	mov	r11, r2
 80095ac: 4b51         	ldr	r3, [pc, #0x144]        @ 0x80096f4 <sys_clock_set_timeout+0x1f4>
 80095ae: e9d3 2300    	ldrd	r2, r3, [r3]
 80095b2: eb1a 0102    	adds.w	r1, r10, r2
 80095b6: 6139         	str	r1, [r7, #0x10]
 80095b8: eb4b 0303    	adc.w	r3, r11, r3
 80095bc: 617b         	str	r3, [r7, #0x14]
 80095be: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x80096f4 <sys_clock_set_timeout+0x1f4>
 80095c0: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 80095c4: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0U;
 80095c8: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x80096f8 <sys_clock_set_timeout+0x1f8>
 80095ca: 2200         	movs	r2, #0x0
 80095cc: 601a         	str	r2, [r3]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 80095ce: 4b49         	ldr	r3, [pc, #0x124]        @ 0x80096f4 <sys_clock_set_timeout+0x1f4>
 80095d0: e9d3 2300    	ldrd	r2, r3, [r3]
 80095d4: 4611         	mov	r1, r2
 80095d6: 4b49         	ldr	r3, [pc, #0x124]        @ 0x80096fc <sys_clock_set_timeout+0x1fc>
 80095d8: e9d3 2300    	ldrd	r2, r3, [r3]
 80095dc: 4613         	mov	r3, r2
 80095de: 1acb         	subs	r3, r1, r3
 80095e0: 65bb         	str	r3, [r7, #0x58]
; 	if ((int32_t)unannounced < 0) {
 80095e2: 6dbb         	ldr	r3, [r7, #0x58]
 80095e4: 2b00         	cmp	r3, #0x0
 80095e6: da04         	bge	0x80095f2 <sys_clock_set_timeout+0xf2> @ imm = #0x8
; 		last_load = MIN_DELAY;
 80095e8: 4b40         	ldr	r3, [pc, #0x100]        @ 0x80096ec <sys_clock_set_timeout+0x1ec>
 80095ea: f240 421a    	movw	r2, #0x41a
 80095ee: 601a         	str	r2, [r3]
 80095f0: e02c         	b	0x800964c <sys_clock_set_timeout+0x14c> @ imm = #0x58
; 		delay = ticks * CYC_PER_TICK;
 80095f2: 69fb         	ldr	r3, [r7, #0x1c]
 80095f4: f244 12a0    	movw	r2, #0x41a0
 80095f8: fb02 f303    	mul	r3, r2, r3
 80095fc: 657b         	str	r3, [r7, #0x54]
; 		delay += unannounced;
 80095fe: 6d7a         	ldr	r2, [r7, #0x54]
 8009600: 6dbb         	ldr	r3, [r7, #0x58]
 8009602: 4413         	add	r3, r2
 8009604: 657b         	str	r3, [r7, #0x54]
; 		delay = DIV_ROUND_UP(delay, CYC_PER_TICK) * CYC_PER_TICK;
 8009606: 6d7b         	ldr	r3, [r7, #0x54]
 8009608: f503 4383    	add.w	r3, r3, #0x4180
 800960c: 331f         	adds	r3, #0x1f
 800960e: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x8009700 <sys_clock_set_timeout+0x200>
 8009610: fba2 2303    	umull	r2, r3, r2, r3
 8009614: 0b9b         	lsrs	r3, r3, #0xe
 8009616: f244 12a0    	movw	r2, #0x41a0
 800961a: fb02 f303    	mul	r3, r2, r3
 800961e: 657b         	str	r3, [r7, #0x54]
; 		delay -= unannounced;
 8009620: 6d7a         	ldr	r2, [r7, #0x54]
 8009622: 6dbb         	ldr	r3, [r7, #0x58]
 8009624: 1ad3         	subs	r3, r2, r3
 8009626: 657b         	str	r3, [r7, #0x54]
; 		delay = MAX(delay, MIN_DELAY);
 8009628: 6d7b         	ldr	r3, [r7, #0x54]
 800962a: f240 421a    	movw	r2, #0x41a
 800962e: 4293         	cmp	r3, r2
 8009630: bf38         	it	lo
 8009632: 4613         	movlo	r3, r2
 8009634: 657b         	str	r3, [r7, #0x54]
; 		if (delay > MAX_CYCLES) {
 8009636: 6d7b         	ldr	r3, [r7, #0x54]
 8009638: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x8009704 <sys_clock_set_timeout+0x204>
 800963a: 4293         	cmp	r3, r2
 800963c: d903         	bls	0x8009646 <sys_clock_set_timeout+0x146> @ imm = #0x6
; 			last_load = MAX_CYCLES;
 800963e: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x80096ec <sys_clock_set_timeout+0x1ec>
 8009640: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x8009704 <sys_clock_set_timeout+0x204>
 8009642: 601a         	str	r2, [r3]
 8009644: e002         	b	0x800964c <sys_clock_set_timeout+0x14c> @ imm = #0x4
; 			last_load = delay;
 8009646: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x80096ec <sys_clock_set_timeout+0x1ec>
 8009648: 6d7b         	ldr	r3, [r7, #0x54]
 800964a: 6013         	str	r3, [r2]
; 	val2 = SysTick->VAL;
 800964c: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80096e8 <sys_clock_set_timeout+0x1e8>
 800964e: 689b         	ldr	r3, [r3, #0x8]
 8009650: 653b         	str	r3, [r7, #0x50]
; 	SysTick->LOAD = last_load - 1;
 8009652: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80096ec <sys_clock_set_timeout+0x1ec>
 8009654: 681b         	ldr	r3, [r3]
 8009656: 4a24         	ldr	r2, [pc, #0x90]         @ 0x80096e8 <sys_clock_set_timeout+0x1e8>
 8009658: 3b01         	subs	r3, #0x1
 800965a: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 800965c: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80096e8 <sys_clock_set_timeout+0x1e8>
 800965e: 2200         	movs	r2, #0x0
 8009660: 609a         	str	r2, [r3, #0x8]
; 	if (val1 < val2) {
 8009662: 6dfa         	ldr	r2, [r7, #0x5c]
 8009664: 6d3b         	ldr	r3, [r7, #0x50]
 8009666: 429a         	cmp	r2, r3
 8009668: d216         	bhs	0x8009698 <sys_clock_set_timeout+0x198> @ imm = #0x2c
; 		cycle_count += (val1 + (last_load_ - val2));
 800966a: 6e7a         	ldr	r2, [r7, #0x64]
 800966c: 6d3b         	ldr	r3, [r7, #0x50]
 800966e: 1ad2         	subs	r2, r2, r3
 8009670: 6dfb         	ldr	r3, [r7, #0x5c]
 8009672: 4413         	add	r3, r2
 8009674: 2200         	movs	r2, #0x0
 8009676: 4698         	mov	r8, r3
 8009678: 4691         	mov	r9, r2
 800967a: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80096f4 <sys_clock_set_timeout+0x1f4>
 800967c: e9d3 2300    	ldrd	r2, r3, [r3]
 8009680: eb18 0102    	adds.w	r1, r8, r2
 8009684: 60b9         	str	r1, [r7, #0x8]
 8009686: eb49 0303    	adc.w	r3, r9, r3
 800968a: 60fb         	str	r3, [r7, #0xc]
 800968c: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80096f4 <sys_clock_set_timeout+0x1f4>
 800968e: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 8009692: e9c3 1200    	strd	r1, r2, [r3]
 8009696: e012         	b	0x80096be <sys_clock_set_timeout+0x1be> @ imm = #0x24
; 		cycle_count += (val1 - val2);
 8009698: 6dfa         	ldr	r2, [r7, #0x5c]
 800969a: 6d3b         	ldr	r3, [r7, #0x50]
 800969c: 1ad3         	subs	r3, r2, r3
 800969e: 2200         	movs	r2, #0x0
 80096a0: 461c         	mov	r4, r3
 80096a2: 4615         	mov	r5, r2
 80096a4: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80096f4 <sys_clock_set_timeout+0x1f4>
 80096a6: e9d3 2300    	ldrd	r2, r3, [r3]
 80096aa: 18a1         	adds	r1, r4, r2
 80096ac: 6039         	str	r1, [r7]
 80096ae: eb45 0303    	adc.w	r3, r5, r3
 80096b2: 607b         	str	r3, [r7, #0x4]
 80096b4: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80096f4 <sys_clock_set_timeout+0x1f4>
 80096b6: e9d7 1200    	ldrd	r1, r2, [r7]
 80096ba: e9c3 1200    	strd	r1, r2, [r3]
 80096be: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80096f0 <sys_clock_set_timeout+0x1f0>
 80096c0: 637b         	str	r3, [r7, #0x34]
 80096c2: 6abb         	ldr	r3, [r7, #0x28]
 80096c4: 627b         	str	r3, [r7, #0x24]
; 	arch_irq_unlock(key.key);
 80096c6: 6a7b         	ldr	r3, [r7, #0x24]
 80096c8: 633b         	str	r3, [r7, #0x30]
 80096ca: 6b3b         	ldr	r3, [r7, #0x30]
 80096cc: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80096ce: 6afb         	ldr	r3, [r7, #0x2c]
 80096d0: f383 8811    	msr	basepri, r3
; }
 80096d4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80096d6: f3bf 8f6f    	isb	sy
; }
 80096da: bf00         	nop
; }
 80096dc: bf00         	nop
; }
 80096de: bf00         	nop
; }
 80096e0: 3768         	adds	r7, #0x68
 80096e2: 46bd         	mov	sp, r7
 80096e4: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

080096e8 <$d>:
 80096e8: 10 e0 00 e0  	.word	0xe000e010
 80096ec: 24 0f 00 20  	.word	0x20000f24
 80096f0: 24 0f 00 20  	.word	0x20000f24
 80096f4: e8 05 00 20  	.word	0x200005e8
 80096f8: 28 0f 00 20  	.word	0x20000f28
 80096fc: f0 05 00 20  	.word	0x200005f0
 8009700: 2d 34 a9 f9  	.word	0xf9a9342d
 8009704: 20 94 ff 00  	.word	0x00ff9420

08009708 <sys_clock_elapsed>:
; {
 8009708: b580         	push	{r7, lr}
 800970a: b08e         	sub	sp, #0x38
 800970c: af00         	add	r7, sp, #0x0
 800970e: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8009798 <sys_clock_elapsed+0x90>
 8009710: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8009712: f3ef 8311    	mrs	r3, basepri
 8009716: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 8009718: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 800971a: 61bb         	str	r3, [r7, #0x18]
 800971c: 2310         	movs	r3, #0x10
 800971e: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8009720: 697b         	ldr	r3, [r7, #0x14]
 8009722: f383 8812    	msr	basepri_max, r3
; }
 8009726: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8009728: f3bf 8f6f    	isb	sy
; }
 800972c: bf00         	nop
; 	return key;
 800972e: 69bb         	ldr	r3, [r7, #0x18]
; 	k.key = arch_irq_lock();
 8009730: 607b         	str	r3, [r7, #0x4]
 8009732: 6a3b         	ldr	r3, [r7, #0x20]
 8009734: 613b         	str	r3, [r7, #0x10]
; }
 8009736: bf00         	nop
 8009738: 6a3b         	ldr	r3, [r7, #0x20]
 800973a: 60fb         	str	r3, [r7, #0xc]
; }
 800973c: bf00         	nop
; 	return k;
 800973e: 687b         	ldr	r3, [r7, #0x4]
 8009740: 60bb         	str	r3, [r7, #0x8]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 8009742: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800979c <sys_clock_elapsed+0x94>
 8009744: e9d3 2300    	ldrd	r2, r3, [r3]
 8009748: 4611         	mov	r1, r2
 800974a: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80097a0 <sys_clock_elapsed+0x98>
 800974c: e9d3 2300    	ldrd	r2, r3, [r3]
 8009750: 4613         	mov	r3, r2
 8009752: 1acb         	subs	r3, r1, r3
 8009754: 637b         	str	r3, [r7, #0x34]
; 	uint32_t cyc = elapsed() + unannounced;
 8009756: f7ff fe3f    	bl	0x80093d8 <elapsed>     @ imm = #-0x382
 800975a: 4602         	mov	r2, r0
 800975c: 6b7b         	ldr	r3, [r7, #0x34]
 800975e: 4413         	add	r3, r2
 8009760: 633b         	str	r3, [r7, #0x30]
 8009762: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8009798 <sys_clock_elapsed+0x90>
 8009764: 62fb         	str	r3, [r7, #0x2c]
 8009766: 68bb         	ldr	r3, [r7, #0x8]
 8009768: 603b         	str	r3, [r7]
; 	arch_irq_unlock(key.key);
 800976a: 683b         	ldr	r3, [r7]
 800976c: 62bb         	str	r3, [r7, #0x28]
 800976e: 6abb         	ldr	r3, [r7, #0x28]
 8009770: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009772: 6a7b         	ldr	r3, [r7, #0x24]
 8009774: f383 8811    	msr	basepri, r3
; }
 8009778: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800977a: f3bf 8f6f    	isb	sy
; }
 800977e: bf00         	nop
; }
 8009780: bf00         	nop
; }
 8009782: bf00         	nop
; 	return cyc / CYC_PER_TICK;
 8009784: 6b3b         	ldr	r3, [r7, #0x30]
 8009786: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80097a4 <sys_clock_elapsed+0x9c>
 8009788: fba2 2303    	umull	r2, r3, r2, r3
 800978c: 0b9b         	lsrs	r3, r3, #0xe
; }
 800978e: 4618         	mov	r0, r3
 8009790: 3738         	adds	r7, #0x38
 8009792: 46bd         	mov	sp, r7
 8009794: bd80         	pop	{r7, pc}
 8009796: bf00         	nop

08009798 <$d>:
 8009798: 24 0f 00 20  	.word	0x20000f24
 800979c: e8 05 00 20  	.word	0x200005e8
 80097a0: f0 05 00 20  	.word	0x200005f0
 80097a4: 2d 34 a9 f9  	.word	0xf9a9342d

080097a8 <sys_clock_cycle_get_32>:
; {
 80097a8: b580         	push	{r7, lr}
 80097aa: b08e         	sub	sp, #0x38
 80097ac: af00         	add	r7, sp, #0x0
 80097ae: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8009824 <sys_clock_cycle_get_32+0x7c>
 80097b0: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80097b2: f3ef 8311    	mrs	r3, basepri
 80097b6: 623b         	str	r3, [r7, #0x20]
;   return(result);
 80097b8: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 80097ba: 61fb         	str	r3, [r7, #0x1c]
 80097bc: 2310         	movs	r3, #0x10
 80097be: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80097c0: 69bb         	ldr	r3, [r7, #0x18]
 80097c2: f383 8812    	msr	basepri_max, r3
; }
 80097c6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80097c8: f3bf 8f6f    	isb	sy
; }
 80097cc: bf00         	nop
; 	return key;
 80097ce: 69fb         	ldr	r3, [r7, #0x1c]
; 	k.key = arch_irq_lock();
 80097d0: 60bb         	str	r3, [r7, #0x8]
 80097d2: 6a7b         	ldr	r3, [r7, #0x24]
 80097d4: 617b         	str	r3, [r7, #0x14]
; }
 80097d6: bf00         	nop
 80097d8: 6a7b         	ldr	r3, [r7, #0x24]
 80097da: 613b         	str	r3, [r7, #0x10]
; }
 80097dc: bf00         	nop
; 	return k;
 80097de: 68bb         	ldr	r3, [r7, #0x8]
 80097e0: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ret = cycle_count;
 80097e2: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8009828 <sys_clock_cycle_get_32+0x80>
 80097e4: e9d3 2300    	ldrd	r2, r3, [r3]
 80097e8: 4613         	mov	r3, r2
 80097ea: 637b         	str	r3, [r7, #0x34]
; 	ret += elapsed();
 80097ec: f7ff fdf4    	bl	0x80093d8 <elapsed>     @ imm = #-0x418
 80097f0: 4602         	mov	r2, r0
 80097f2: 6b7b         	ldr	r3, [r7, #0x34]
 80097f4: 4413         	add	r3, r2
 80097f6: 637b         	str	r3, [r7, #0x34]
 80097f8: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8009824 <sys_clock_cycle_get_32+0x7c>
 80097fa: 633b         	str	r3, [r7, #0x30]
 80097fc: 68fb         	ldr	r3, [r7, #0xc]
 80097fe: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 8009800: 687b         	ldr	r3, [r7, #0x4]
 8009802: 62fb         	str	r3, [r7, #0x2c]
 8009804: 6afb         	ldr	r3, [r7, #0x2c]
 8009806: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009808: 6abb         	ldr	r3, [r7, #0x28]
 800980a: f383 8811    	msr	basepri, r3
; }
 800980e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8009810: f3bf 8f6f    	isb	sy
; }
 8009814: bf00         	nop
; }
 8009816: bf00         	nop
; }
 8009818: bf00         	nop
; 	return ret;
 800981a: 6b7b         	ldr	r3, [r7, #0x34]
; }
 800981c: 4618         	mov	r0, r3
 800981e: 3738         	adds	r7, #0x38
 8009820: 46bd         	mov	sp, r7
 8009822: bd80         	pop	{r7, pc}

08009824 <$d>:
 8009824: 24 0f 00 20  	.word	0x20000f24
 8009828: e8 05 00 20  	.word	0x200005e8

0800982c <sys_clock_driver_init>:
; {
 800982c: b580         	push	{r7, lr}
 800982e: af00         	add	r7, sp, #0x0
; 	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
 8009830: 2101         	movs	r1, #0x1
 8009832: f04f 30ff    	mov.w	r0, #0xffffffff
 8009836: f7ff fda5    	bl	0x8009384 <__NVIC_SetPriority> @ imm = #-0x4b6
; 	last_load = CYC_PER_TICK;
 800983a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800986c <sys_clock_driver_init+0x40>
 800983c: f244 12a0    	movw	r2, #0x41a0
 8009840: 601a         	str	r2, [r3]
; 	overflow_cyc = 0U;
 8009842: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8009870 <sys_clock_driver_init+0x44>
 8009844: 2200         	movs	r2, #0x0
 8009846: 601a         	str	r2, [r3]
; 	SysTick->LOAD = last_load - 1;
 8009848: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800986c <sys_clock_driver_init+0x40>
 800984a: 681b         	ldr	r3, [r3]
 800984c: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8009874 <sys_clock_driver_init+0x48>
 800984e: 3b01         	subs	r3, #0x1
 8009850: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 8009852: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8009874 <sys_clock_driver_init+0x48>
 8009854: 2200         	movs	r2, #0x0
 8009856: 609a         	str	r2, [r3, #0x8]
; 	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
 8009858: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8009874 <sys_clock_driver_init+0x48>
 800985a: 681b         	ldr	r3, [r3]
 800985c: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8009874 <sys_clock_driver_init+0x48>
 800985e: f043 0307    	orr	r3, r3, #0x7
 8009862: 6013         	str	r3, [r2]
; 	return 0;
 8009864: 2300         	movs	r3, #0x0
; }
 8009866: 4618         	mov	r0, r3
 8009868: bd80         	pop	{r7, pc}
 800986a: bf00         	nop

0800986c <$d>:
 800986c: 24 0f 00 20  	.word	0x20000f24
 8009870: 28 0f 00 20  	.word	0x20000f28
 8009874: 10 e0 00 e0  	.word	0xe000e010

08009878 <to16t>:
; static int16_t to16t(float value) {
 8009878: b580         	push	{r7, lr}
 800987a: b082         	sub	sp, #0x8
 800987c: af00         	add	r7, sp, #0x0
 800987e: 6078         	str	r0, [r7, #0x4]
;     if (value > INT16_MAX) {
 8009880: 490e         	ldr	r1, [pc, #0x38]         @ 0x80098bc <to16t+0x44>
 8009882: 6878         	ldr	r0, [r7, #0x4]
 8009884: f7f7 f906    	bl	0x8000a94 <__aeabi_fcmpgt> @ imm = #-0x8df4
 8009888: 4603         	mov	r3, r0
 800988a: 2b00         	cmp	r3, #0x0
 800988c: d002         	beq	0x8009894 <to16t+0x1c>  @ imm = #0x4
;         return INT16_MAX;
 800988e: f647 73ff    	movw	r3, #0x7fff
 8009892: e00e         	b	0x80098b2 <to16t+0x3a>  @ imm = #0x1c
;     } else if (value < INT16_MIN) {
 8009894: f04f 4147    	mov.w	r1, #0xc7000000
 8009898: 6878         	ldr	r0, [r7, #0x4]
 800989a: f7f7 f8dd    	bl	0x8000a58 <__aeabi_fcmplt> @ imm = #-0x8e46
 800989e: 4603         	mov	r3, r0
 80098a0: 2b00         	cmp	r3, #0x0
 80098a2: d001         	beq	0x80098a8 <to16t+0x30>  @ imm = #0x2
;         return INT16_MIN;
 80098a4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80098c0 <to16t+0x48>
 80098a6: e004         	b	0x80098b2 <to16t+0x3a>  @ imm = #0x8
;         return (int16_t)value;
 80098a8: 6878         	ldr	r0, [r7, #0x4]
 80098aa: f7f7 f8fd    	bl	0x8000aa8 <__fixsfsi>   @ imm = #-0x8e06
 80098ae: 4603         	mov	r3, r0
 80098b0: b21b         	sxth	r3, r3
; }
 80098b2: 4618         	mov	r0, r3
 80098b4: 3708         	adds	r7, #0x8
 80098b6: 46bd         	mov	sp, r7
 80098b8: bd80         	pop	{r7, pc}
 80098ba: bf00         	nop

080098bc <$d>:
 80098bc: 00 fe ff 46  	.word	0x46fffe00
 80098c0: 00 80 ff ff  	.word	0xffff8000

080098c4 <canbus_id>:
; static inline motor_id_t canbus_id(const struct device *dev) {
 80098c4: b480         	push	{r7}
 80098c6: b085         	sub	sp, #0x14
 80098c8: af00         	add	r7, sp, #0x0
 80098ca: 6078         	str	r0, [r7, #0x4]
;     for (int i = 0; i < MOTOR_COUNT; i++) {
 80098cc: 2300         	movs	r3, #0x0
 80098ce: 60fb         	str	r3, [r7, #0xc]
 80098d0: e00c         	b	0x80098ec <canbus_id+0x28> @ imm = #0x18
;         if (motor_devices[i] == dev) {
 80098d2: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8009900 <canbus_id+0x3c>
 80098d4: 68fb         	ldr	r3, [r7, #0xc]
 80098d6: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80098da: 687a         	ldr	r2, [r7, #0x4]
 80098dc: 429a         	cmp	r2, r3
 80098de: d102         	bne	0x80098e6 <canbus_id+0x22> @ imm = #0x4
;             return i;
 80098e0: 68fb         	ldr	r3, [r7, #0xc]
 80098e2: b29b         	uxth	r3, r3
 80098e4: e006         	b	0x80098f4 <canbus_id+0x30> @ imm = #0xc
;     for (int i = 0; i < MOTOR_COUNT; i++) {
 80098e6: 68fb         	ldr	r3, [r7, #0xc]
 80098e8: 3301         	adds	r3, #0x1
 80098ea: 60fb         	str	r3, [r7, #0xc]
 80098ec: 68fb         	ldr	r3, [r7, #0xc]
 80098ee: 2b02         	cmp	r3, #0x2
 80098f0: d9ef         	bls	0x80098d2 <canbus_id+0xe> @ imm = #-0x22
;     return 0;
 80098f2: 2300         	movs	r3, #0x0
; }
 80098f4: 4618         	mov	r0, r3
 80098f6: 3714         	adds	r7, #0x14
 80098f8: 46bd         	mov	sp, r7
 80098fa: bc80         	pop	{r7}
 80098fc: 4770         	bx	lr
 80098fe: bf00         	nop

08009900 <$d>:
 8009900: 2c 03 00 20  	.word	0x2000032c

08009904 <dji_set_speed>:
; int8_t dji_set_speed(const struct device *dev, float speed_rpm) {
 8009904: b580         	push	{r7, lr}
 8009906: b086         	sub	sp, #0x18
 8009908: af00         	add	r7, sp, #0x0
 800990a: 6078         	str	r0, [r7, #0x4]
 800990c: 6039         	str	r1, [r7]
;     struct dji_motor_data         *data = dev->data;
 800990e: 687b         	ldr	r3, [r7, #0x4]
 8009910: 691b         	ldr	r3, [r3, #0x10]
 8009912: 613b         	str	r3, [r7, #0x10]
;     const struct dji_motor_config *cfg  = dev->config;
 8009914: 687b         	ldr	r3, [r7, #0x4]
 8009916: 685b         	ldr	r3, [r3, #0x4]
 8009918: 60fb         	str	r3, [r7, #0xc]
;     data->target_rpm = speed_rpm;
 800991a: 693b         	ldr	r3, [r7, #0x10]
 800991c: 683a         	ldr	r2, [r7]
 800991e: 63da         	str	r2, [r3, #0x3c]
;     for (int i = 0; i < sizeof(cfg->common.controller) / sizeof(cfg->common.controller[0]); i++) {
 8009920: 2300         	movs	r3, #0x0
 8009922: 617b         	str	r3, [r7, #0x14]
 8009924: e024         	b	0x8009970 <dji_set_speed+0x6c> @ imm = #0x48
;         if (cfg->common.controller[i] == NULL)
 8009926: 68fb         	ldr	r3, [r7, #0xc]
 8009928: 697a         	ldr	r2, [r7, #0x14]
 800992a: 3204         	adds	r2, #0x4
 800992c: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8009930: 2b00         	cmp	r3, #0x0
 8009932: d021         	beq	0x8009978 <dji_set_speed+0x74> @ imm = #0x42
;         if (strcmp(cfg->common.capabilities[i], "speed") == 0) {
 8009934: 697a         	ldr	r2, [r7, #0x14]
 8009936: 4613         	mov	r3, r2
 8009938: 005b         	lsls	r3, r3, #0x1
 800993a: 4413         	add	r3, r2
 800993c: 009b         	lsls	r3, r3, #0x2
 800993e: 3320         	adds	r3, #0x20
 8009940: 68fa         	ldr	r2, [r7, #0xc]
 8009942: 4413         	add	r3, r2
 8009944: 490f         	ldr	r1, [pc, #0x3c]         @ 0x8009984 <dji_set_speed+0x80>
 8009946: 4618         	mov	r0, r3
 8009948: f7f7 f8ee    	bl	0x8000b28 <strcmp>      @ imm = #-0x8e24
 800994c: 4603         	mov	r3, r0
 800994e: 2b00         	cmp	r3, #0x0
 8009950: d10b         	bne	0x800996a <dji_set_speed+0x66> @ imm = #0x16
;             pid_calc(cfg->common.controller[i]);
 8009952: 68fb         	ldr	r3, [r7, #0xc]
 8009954: 697a         	ldr	r2, [r7, #0x14]
 8009956: 3204         	adds	r2, #0x4
 8009958: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800995c: 4618         	mov	r0, r3
 800995e: f00c fdc4    	bl	0x80164ea <pid_calc>    @ imm = #0xcb88
;             data->current_mode_index = i;
 8009962: 697b         	ldr	r3, [r7, #0x14]
 8009964: b25a         	sxtb	r2, r3
 8009966: 693b         	ldr	r3, [r7, #0x10]
 8009968: 769a         	strb	r2, [r3, #0x1a]
;     for (int i = 0; i < sizeof(cfg->common.controller) / sizeof(cfg->common.controller[0]); i++) {
 800996a: 697b         	ldr	r3, [r7, #0x14]
 800996c: 3301         	adds	r3, #0x1
 800996e: 617b         	str	r3, [r7, #0x14]
 8009970: 697b         	ldr	r3, [r7, #0x14]
 8009972: 2b03         	cmp	r3, #0x3
 8009974: d9d7         	bls	0x8009926 <dji_set_speed+0x22> @ imm = #-0x52
 8009976: e000         	b	0x800997a <dji_set_speed+0x76> @ imm = #0x0
;             break;
 8009978: bf00         	nop
;     return 0;
 800997a: 2300         	movs	r3, #0x0
; }
 800997c: 4618         	mov	r0, r3
 800997e: 3718         	adds	r7, #0x18
 8009980: 46bd         	mov	sp, r7
 8009982: bd80         	pop	{r7, pc}

08009984 <$d>:
 8009984: e4 ab 01 08  	.word	0x0801abe4

08009988 <dji_set_angle>:
; int8_t dji_set_angle(const struct device *dev, float angle) {
 8009988: b580         	push	{r7, lr}
 800998a: b086         	sub	sp, #0x18
 800998c: af00         	add	r7, sp, #0x0
 800998e: 6078         	str	r0, [r7, #0x4]
 8009990: 6039         	str	r1, [r7]
;     struct dji_motor_data         *data = dev->data;
 8009992: 687b         	ldr	r3, [r7, #0x4]
 8009994: 691b         	ldr	r3, [r3, #0x10]
 8009996: 613b         	str	r3, [r7, #0x10]
;     const struct dji_motor_config *cfg  = dev->config;
 8009998: 687b         	ldr	r3, [r7, #0x4]
 800999a: 685b         	ldr	r3, [r3, #0x4]
 800999c: 60fb         	str	r3, [r7, #0xc]
;     data->target_angle = angle;
 800999e: 693b         	ldr	r3, [r7, #0x10]
 80099a0: 683a         	ldr	r2, [r7]
 80099a2: 639a         	str	r2, [r3, #0x38]
;     for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.controller); i++) {
 80099a4: 2300         	movs	r3, #0x0
 80099a6: 617b         	str	r3, [r7, #0x14]
 80099a8: e024         	b	0x80099f4 <dji_set_angle+0x6c> @ imm = #0x48
;         if (cfg->common.controller[i] == NULL)
 80099aa: 68fb         	ldr	r3, [r7, #0xc]
 80099ac: 697a         	ldr	r2, [r7, #0x14]
 80099ae: 3204         	adds	r2, #0x4
 80099b0: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 80099b4: 2b00         	cmp	r3, #0x0
 80099b6: d021         	beq	0x80099fc <dji_set_angle+0x74> @ imm = #0x42
;         if (strcmp(cfg->common.capabilities[i], "angle") == 0) {
 80099b8: 697a         	ldr	r2, [r7, #0x14]
 80099ba: 4613         	mov	r3, r2
 80099bc: 005b         	lsls	r3, r3, #0x1
 80099be: 4413         	add	r3, r2
 80099c0: 009b         	lsls	r3, r3, #0x2
 80099c2: 3320         	adds	r3, #0x20
 80099c4: 68fa         	ldr	r2, [r7, #0xc]
 80099c6: 4413         	add	r3, r2
 80099c8: 490f         	ldr	r1, [pc, #0x3c]         @ 0x8009a08 <dji_set_angle+0x80>
 80099ca: 4618         	mov	r0, r3
 80099cc: f7f7 f8ac    	bl	0x8000b28 <strcmp>      @ imm = #-0x8ea8
 80099d0: 4603         	mov	r3, r0
 80099d2: 2b00         	cmp	r3, #0x0
 80099d4: d10b         	bne	0x80099ee <dji_set_angle+0x66> @ imm = #0x16
;             pid_calc(cfg->common.controller[i]);
 80099d6: 68fb         	ldr	r3, [r7, #0xc]
 80099d8: 697a         	ldr	r2, [r7, #0x14]
 80099da: 3204         	adds	r2, #0x4
 80099dc: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 80099e0: 4618         	mov	r0, r3
 80099e2: f00c fd82    	bl	0x80164ea <pid_calc>    @ imm = #0xcb04
;             data->current_mode_index = i;
 80099e6: 697b         	ldr	r3, [r7, #0x14]
 80099e8: b25a         	sxtb	r2, r3
 80099ea: 693b         	ldr	r3, [r7, #0x10]
 80099ec: 769a         	strb	r2, [r3, #0x1a]
;     for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.controller); i++) {
 80099ee: 697b         	ldr	r3, [r7, #0x14]
 80099f0: 3301         	adds	r3, #0x1
 80099f2: 617b         	str	r3, [r7, #0x14]
 80099f4: 697b         	ldr	r3, [r7, #0x14]
 80099f6: 2b03         	cmp	r3, #0x3
 80099f8: d9d7         	bls	0x80099aa <dji_set_angle+0x22> @ imm = #-0x52
 80099fa: e000         	b	0x80099fe <dji_set_angle+0x76> @ imm = #0x0
;             break;
 80099fc: bf00         	nop
;     return 0;
 80099fe: 2300         	movs	r3, #0x0
; }
 8009a00: 4618         	mov	r0, r3
 8009a02: 3718         	adds	r7, #0x18
 8009a04: 46bd         	mov	sp, r7
 8009a06: bd80         	pop	{r7, pc}

08009a08 <$d>:
 8009a08: ec ab 01 08  	.word	0x0801abec

08009a0c <dji_set_torque>:
; int8_t dji_set_torque(const struct device *dev, float torque) {
 8009a0c: b580         	push	{r7, lr}
 8009a0e: b086         	sub	sp, #0x18
 8009a10: af00         	add	r7, sp, #0x0
 8009a12: 6078         	str	r0, [r7, #0x4]
 8009a14: 6039         	str	r1, [r7]
;     struct dji_motor_data         *data = dev->data;
 8009a16: 687b         	ldr	r3, [r7, #0x4]
 8009a18: 691b         	ldr	r3, [r3, #0x10]
 8009a1a: 613b         	str	r3, [r7, #0x10]
;     const struct dji_motor_config *cfg  = dev->config;
 8009a1c: 687b         	ldr	r3, [r7, #0x4]
 8009a1e: 685b         	ldr	r3, [r3, #0x4]
 8009a20: 60fb         	str	r3, [r7, #0xc]
;     data->target_torque = torque;
 8009a22: 693b         	ldr	r3, [r7, #0x10]
 8009a24: 683a         	ldr	r2, [r7]
 8009a26: 641a         	str	r2, [r3, #0x40]
;     for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.controller); i++) {
 8009a28: 2300         	movs	r3, #0x0
 8009a2a: 617b         	str	r3, [r7, #0x14]
 8009a2c: e024         	b	0x8009a78 <dji_set_torque+0x6c> @ imm = #0x48
;         if (cfg->common.controller[i] == NULL)
 8009a2e: 68fb         	ldr	r3, [r7, #0xc]
 8009a30: 697a         	ldr	r2, [r7, #0x14]
 8009a32: 3204         	adds	r2, #0x4
 8009a34: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8009a38: 2b00         	cmp	r3, #0x0
 8009a3a: d021         	beq	0x8009a80 <dji_set_torque+0x74> @ imm = #0x42
;         if (strcmp(cfg->common.capabilities[i], "torque") == 0) {
 8009a3c: 697a         	ldr	r2, [r7, #0x14]
 8009a3e: 4613         	mov	r3, r2
 8009a40: 005b         	lsls	r3, r3, #0x1
 8009a42: 4413         	add	r3, r2
 8009a44: 009b         	lsls	r3, r3, #0x2
 8009a46: 3320         	adds	r3, #0x20
 8009a48: 68fa         	ldr	r2, [r7, #0xc]
 8009a4a: 4413         	add	r3, r2
 8009a4c: 490f         	ldr	r1, [pc, #0x3c]         @ 0x8009a8c <dji_set_torque+0x80>
 8009a4e: 4618         	mov	r0, r3
 8009a50: f7f7 f86a    	bl	0x8000b28 <strcmp>      @ imm = #-0x8f2c
 8009a54: 4603         	mov	r3, r0
 8009a56: 2b00         	cmp	r3, #0x0
 8009a58: d10b         	bne	0x8009a72 <dji_set_torque+0x66> @ imm = #0x16
;             pid_calc(cfg->common.controller[i]);
 8009a5a: 68fb         	ldr	r3, [r7, #0xc]
 8009a5c: 697a         	ldr	r2, [r7, #0x14]
 8009a5e: 3204         	adds	r2, #0x4
 8009a60: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8009a64: 4618         	mov	r0, r3
 8009a66: f00c fd40    	bl	0x80164ea <pid_calc>    @ imm = #0xca80
;             data->current_mode_index = i;
 8009a6a: 697b         	ldr	r3, [r7, #0x14]
 8009a6c: b25a         	sxtb	r2, r3
 8009a6e: 693b         	ldr	r3, [r7, #0x10]
 8009a70: 769a         	strb	r2, [r3, #0x1a]
;     for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.controller); i++) {
 8009a72: 697b         	ldr	r3, [r7, #0x14]
 8009a74: 3301         	adds	r3, #0x1
 8009a76: 617b         	str	r3, [r7, #0x14]
 8009a78: 697b         	ldr	r3, [r7, #0x14]
 8009a7a: 2b03         	cmp	r3, #0x3
 8009a7c: d9d7         	bls	0x8009a2e <dji_set_torque+0x22> @ imm = #-0x52
 8009a7e: e000         	b	0x8009a82 <dji_set_torque+0x76> @ imm = #0x0
;             break;
 8009a80: bf00         	nop
;     return 0;
 8009a82: 2300         	movs	r3, #0x0
; }
 8009a84: 4618         	mov	r0, r3
 8009a86: 3718         	adds	r7, #0x18
 8009a88: 46bd         	mov	sp, r7
 8009a8a: bd80         	pop	{r7, pc}

08009a8c <$d>:
 8009a8c: f4 ab 01 08  	.word	0x0801abf4

08009a90 <dji_init>:
; int dji_init(const struct device *dev) {
 8009a90: b580         	push	{r7, lr}
 8009a92: b08e         	sub	sp, #0x38
 8009a94: af04         	add	r7, sp, #0x10
 8009a96: 6078         	str	r0, [r7, #0x4]
;     if (dev) {
 8009a98: 687b         	ldr	r3, [r7, #0x4]
 8009a9a: 2b00         	cmp	r3, #0x0
 8009a9c: f000 8170    	beq.w	0x8009d80 <dji_init+0x2f0> @ imm = #0x2e0
;         const struct dji_motor_config *cfg      = dev->config;
 8009aa0: 687b         	ldr	r3, [r7, #0x4]
 8009aa2: 685b         	ldr	r3, [r3, #0x4]
 8009aa4: 623b         	str	r3, [r7, #0x20]
;         struct dji_motor_data         *data     = (struct dji_motor_data *)dev->data;
 8009aa6: 687b         	ldr	r3, [r7, #0x4]
 8009aa8: 691b         	ldr	r3, [r3, #0x10]
 8009aaa: 61fb         	str	r3, [r7, #0x1c]
;         uint8_t                        frame_id = frames_id(cfg->common.tx_id);
 8009aac: 6a3b         	ldr	r3, [r7, #0x20]
 8009aae: 689b         	ldr	r3, [r3, #0x8]
 8009ab0: 4618         	mov	r0, r3
 8009ab2: f00c fd50    	bl	0x8016556 <frames_id>   @ imm = #0xcaa0
 8009ab6: 4603         	mov	r3, r0
 8009ab8: 76fb         	strb	r3, [r7, #0x1b]
;         uint8_t                        id       = motor_id(dev);
 8009aba: 6878         	ldr	r0, [r7, #0x4]
 8009abc: f00c fda0    	bl	0x8016600 <motor_id>    @ imm = #0xcb40
 8009ac0: 4603         	mov	r3, r0
 8009ac2: 76bb         	strb	r3, [r7, #0x1a]
;         data->ctrl_struct->mask[frame_id] |= id >= 4 ? 0xF0 : 0x0F;
 8009ac4: 69fb         	ldr	r3, [r7, #0x1c]
 8009ac6: 695a         	ldr	r2, [r3, #0x14]
 8009ac8: 7efb         	ldrb	r3, [r7, #0x1b]
 8009aca: 4413         	add	r3, r2
 8009acc: f893 303e    	ldrb.w	r3, [r3, #0x3e]
 8009ad0: b25b         	sxtb	r3, r3
 8009ad2: 7eba         	ldrb	r2, [r7, #0x1a]
 8009ad4: 2a03         	cmp	r2, #0x3
 8009ad6: d902         	bls	0x8009ade <dji_init+0x4e> @ imm = #0x4
 8009ad8: f06f 020f    	mvn	r2, #0xf
 8009adc: e000         	b	0x8009ae0 <dji_init+0x50> @ imm = #0x0
 8009ade: 220f         	movs	r2, #0xf
 8009ae0: 4313         	orrs	r3, r2
 8009ae2: b259         	sxtb	r1, r3
 8009ae4: 69fb         	ldr	r3, [r7, #0x1c]
 8009ae6: 695a         	ldr	r2, [r3, #0x14]
 8009ae8: 7efb         	ldrb	r3, [r7, #0x1b]
 8009aea: b2c9         	uxtb	r1, r1
 8009aec: 4413         	add	r3, r2
 8009aee: 460a         	mov	r2, r1
 8009af0: f883 203e    	strb.w	r2, [r3, #0x3e]
;         data->ctrl_struct->mask[frame_id] ^= 1 << id;
 8009af4: 69fb         	ldr	r3, [r7, #0x1c]
 8009af6: 695a         	ldr	r2, [r3, #0x14]
 8009af8: 7efb         	ldrb	r3, [r7, #0x1b]
 8009afa: 4413         	add	r3, r2
 8009afc: f893 303e    	ldrb.w	r3, [r3, #0x3e]
 8009b00: b25a         	sxtb	r2, r3
 8009b02: 7ebb         	ldrb	r3, [r7, #0x1a]
 8009b04: 2101         	movs	r1, #0x1
 8009b06: fa01 f303    	lsl.w	r3, r1, r3
 8009b0a: b25b         	sxtb	r3, r3
 8009b0c: 4053         	eors	r3, r2
 8009b0e: b259         	sxtb	r1, r3
 8009b10: 69fb         	ldr	r3, [r7, #0x1c]
 8009b12: 695a         	ldr	r2, [r3, #0x14]
 8009b14: 7efb         	ldrb	r3, [r7, #0x1b]
 8009b16: b2c9         	uxtb	r1, r1
 8009b18: 4413         	add	r3, r2
 8009b1a: 460a         	mov	r2, r1
 8009b1c: f883 203e    	strb.w	r2, [r3, #0x3e]
;         data->ctrl_struct->rx_ids[id] = cfg->common.rx_id;
 8009b20: 69fb         	ldr	r3, [r7, #0x1c]
 8009b22: 6959         	ldr	r1, [r3, #0x14]
 8009b24: 7ebb         	ldrb	r3, [r7, #0x1a]
 8009b26: 6a3a         	ldr	r2, [r7, #0x20]
 8009b28: 68d2         	ldr	r2, [r2, #0xc]
 8009b2a: 009b         	lsls	r3, r3, #0x2
 8009b2c: 440b         	add	r3, r1
 8009b2e: 605a         	str	r2, [r3, #0x4]
;         data->online                  = true;
 8009b30: 69fb         	ldr	r3, [r7, #0x1c]
 8009b32: 2201         	movs	r2, #0x1
 8009b34: 761a         	strb	r2, [r3, #0x18]
;         for (int i = 0; i < sizeof(cfg->common.controller) / sizeof(cfg->common.controller[0]);
 8009b36: 2300         	movs	r3, #0x0
 8009b38: 627b         	str	r3, [r7, #0x24]
 8009b3a: e0a9         	b	0x8009c90 <dji_init+0x200> @ imm = #0x152
;             if (cfg->common.controller[i] == NULL)
 8009b3c: 6a3b         	ldr	r3, [r7, #0x20]
 8009b3e: 6a7a         	ldr	r2, [r7, #0x24]
 8009b40: 3204         	adds	r2, #0x4
 8009b42: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8009b46: 2b00         	cmp	r3, #0x0
 8009b48: f000 80a7    	beq.w	0x8009c9a <dji_init+0x20a> @ imm = #0x14e
;             if (strcmp(cfg->common.capabilities[i], "speed") == 0) {
 8009b4c: 6a7a         	ldr	r2, [r7, #0x24]
 8009b4e: 4613         	mov	r3, r2
 8009b50: 005b         	lsls	r3, r3, #0x1
 8009b52: 4413         	add	r3, r2
 8009b54: 009b         	lsls	r3, r3, #0x2
 8009b56: 3320         	adds	r3, #0x20
 8009b58: 6a3a         	ldr	r2, [r7, #0x20]
 8009b5a: 4413         	add	r3, r2
 8009b5c: 498b         	ldr	r1, [pc, #0x22c]        @ 0x8009d8c <dji_init+0x2fc>
 8009b5e: 4618         	mov	r0, r3
 8009b60: f7f6 ffe2    	bl	0x8000b28 <strcmp>      @ imm = #-0x903c
 8009b64: 4603         	mov	r3, r0
 8009b66: 2b00         	cmp	r3, #0x0
 8009b68: d117         	bne	0x8009b9a <dji_init+0x10a> @ imm = #0x2e
;                 pid_reg_input(cfg->common.controller[i], &data->common.rpm, &data->target_rpm);
 8009b6a: 6a3b         	ldr	r3, [r7, #0x20]
 8009b6c: 6a7a         	ldr	r2, [r7, #0x24]
 8009b6e: 3204         	adds	r2, #0x4
 8009b70: f853 0022    	ldr.w	r0, [r3, r2, lsl #2]
 8009b74: 69fb         	ldr	r3, [r7, #0x1c]
 8009b76: 1d19         	adds	r1, r3, #0x4
 8009b78: 69fb         	ldr	r3, [r7, #0x1c]
 8009b7a: 333c         	adds	r3, #0x3c
 8009b7c: 461a         	mov	r2, r3
 8009b7e: f00c fcbf    	bl	0x8016500 <pid_reg_input> @ imm = #0xc97e
;                 pid_reg_output(cfg->common.controller[i], &data->target_torque);
 8009b82: 6a3b         	ldr	r3, [r7, #0x20]
 8009b84: 6a7a         	ldr	r2, [r7, #0x24]
 8009b86: 3204         	adds	r2, #0x4
 8009b88: f853 2022    	ldr.w	r2, [r3, r2, lsl #2]
 8009b8c: 69fb         	ldr	r3, [r7, #0x1c]
 8009b8e: 3340         	adds	r3, #0x40
 8009b90: 4619         	mov	r1, r3
 8009b92: 4610         	mov	r0, r2
 8009b94: f00c fcd2    	bl	0x801653c <pid_reg_output> @ imm = #0xc9a4
 8009b98: e06a         	b	0x8009c70 <dji_init+0x1e0> @ imm = #0xd4
;             } else if (strcmp(cfg->common.capabilities[i], "angle") == 0) {
 8009b9a: 6a7a         	ldr	r2, [r7, #0x24]
 8009b9c: 4613         	mov	r3, r2
 8009b9e: 005b         	lsls	r3, r3, #0x1
 8009ba0: 4413         	add	r3, r2
 8009ba2: 009b         	lsls	r3, r3, #0x2
 8009ba4: 3320         	adds	r3, #0x20
 8009ba6: 6a3a         	ldr	r2, [r7, #0x20]
 8009ba8: 4413         	add	r3, r2
 8009baa: 4979         	ldr	r1, [pc, #0x1e4]        @ 0x8009d90 <dji_init+0x300>
 8009bac: 4618         	mov	r0, r3
 8009bae: f7f6 ffbb    	bl	0x8000b28 <strcmp>      @ imm = #-0x908a
 8009bb2: 4603         	mov	r3, r0
 8009bb4: 2b00         	cmp	r3, #0x0
 8009bb6: d116         	bne	0x8009be6 <dji_init+0x156> @ imm = #0x2c
;                 pid_reg_input(cfg->common.controller[i], &data->common.angle, &data->target_angle);
 8009bb8: 6a3b         	ldr	r3, [r7, #0x20]
 8009bba: 6a7a         	ldr	r2, [r7, #0x24]
 8009bbc: 3204         	adds	r2, #0x4
 8009bbe: f853 0022    	ldr.w	r0, [r3, r2, lsl #2]
 8009bc2: 69f9         	ldr	r1, [r7, #0x1c]
 8009bc4: 69fb         	ldr	r3, [r7, #0x1c]
 8009bc6: 3338         	adds	r3, #0x38
 8009bc8: 461a         	mov	r2, r3
 8009bca: f00c fc99    	bl	0x8016500 <pid_reg_input> @ imm = #0xc932
;                 pid_reg_output(cfg->common.controller[i], &data->target_rpm);
 8009bce: 6a3b         	ldr	r3, [r7, #0x20]
 8009bd0: 6a7a         	ldr	r2, [r7, #0x24]
 8009bd2: 3204         	adds	r2, #0x4
 8009bd4: f853 2022    	ldr.w	r2, [r3, r2, lsl #2]
 8009bd8: 69fb         	ldr	r3, [r7, #0x1c]
 8009bda: 333c         	adds	r3, #0x3c
 8009bdc: 4619         	mov	r1, r3
 8009bde: 4610         	mov	r0, r2
 8009be0: f00c fcac    	bl	0x801653c <pid_reg_output> @ imm = #0xc958
 8009be4: e044         	b	0x8009c70 <dji_init+0x1e0> @ imm = #0x88
;             } else if (strcmp(cfg->common.capabilities[i], "torque") == 0) {
 8009be6: 6a7a         	ldr	r2, [r7, #0x24]
 8009be8: 4613         	mov	r3, r2
 8009bea: 005b         	lsls	r3, r3, #0x1
 8009bec: 4413         	add	r3, r2
 8009bee: 009b         	lsls	r3, r3, #0x2
 8009bf0: 3320         	adds	r3, #0x20
 8009bf2: 6a3a         	ldr	r2, [r7, #0x20]
 8009bf4: 4413         	add	r3, r2
 8009bf6: 4967         	ldr	r1, [pc, #0x19c]        @ 0x8009d94 <dji_init+0x304>
 8009bf8: 4618         	mov	r0, r3
 8009bfa: f7f6 ff95    	bl	0x8000b28 <strcmp>      @ imm = #-0x90d6
 8009bfe: 4603         	mov	r3, r0
 8009c00: 2b00         	cmp	r3, #0x0
 8009c02: d118         	bne	0x8009c36 <dji_init+0x1a6> @ imm = #0x30
;                 pid_reg_input(cfg->common.controller[i], &data->common.torque,
 8009c04: 6a3b         	ldr	r3, [r7, #0x20]
 8009c06: 6a7a         	ldr	r2, [r7, #0x24]
 8009c08: 3204         	adds	r2, #0x4
 8009c0a: f853 0022    	ldr.w	r0, [r3, r2, lsl #2]
 8009c0e: 69fb         	ldr	r3, [r7, #0x1c]
 8009c10: f103 0108    	add.w	r1, r3, #0x8
 8009c14: 69fb         	ldr	r3, [r7, #0x1c]
 8009c16: 3340         	adds	r3, #0x40
 8009c18: 461a         	mov	r2, r3
 8009c1a: f00c fc71    	bl	0x8016500 <pid_reg_input> @ imm = #0xc8e2
;                 pid_reg_output(cfg->common.controller[i], &data->target_current);
 8009c1e: 6a3b         	ldr	r3, [r7, #0x20]
 8009c20: 6a7a         	ldr	r2, [r7, #0x24]
 8009c22: 3204         	adds	r2, #0x4
 8009c24: f853 2022    	ldr.w	r2, [r3, r2, lsl #2]
 8009c28: 69fb         	ldr	r3, [r7, #0x1c]
 8009c2a: 3344         	adds	r3, #0x44
 8009c2c: 4619         	mov	r1, r3
 8009c2e: 4610         	mov	r0, r2
 8009c30: f00c fc84    	bl	0x801653c <pid_reg_output> @ imm = #0xc908
 8009c34: e01c         	b	0x8009c70 <dji_init+0x1e0> @ imm = #0x38
;                 LOG_ERR("Unsupported motor mode");
 8009c36: 2304         	movs	r3, #0x4
 8009c38: 2b00         	cmp	r3, #0x0
 8009c3a: d016         	beq	0x8009c6a <dji_init+0x1da> @ imm = #0x2c
 8009c3c: 2301         	movs	r3, #0x1
 8009c3e: 767b         	strb	r3, [r7, #0x19]
 8009c40: 7e7b         	ldrb	r3, [r7, #0x19]
 8009c42: f083 0301    	eor	r3, r3, #0x1
 8009c46: b2db         	uxtb	r3, r3
 8009c48: 2b00         	cmp	r3, #0x0
 8009c4a: d10e         	bne	0x8009c6a <dji_init+0x1da> @ imm = #0x1c
 8009c4c: 4b52         	ldr	r3, [pc, #0x148]        @ 0x8009d98 <dji_init+0x308>
 8009c4e: 6819         	ldr	r1, [r3]
 8009c50: 4b52         	ldr	r3, [pc, #0x148]        @ 0x8009d9c <dji_init+0x30c>
 8009c52: 9302         	str	r3, [sp, #0x8]
 8009c54: 2300         	movs	r3, #0x0
 8009c56: 9301         	str	r3, [sp, #0x4]
 8009c58: 2300         	movs	r3, #0x0
 8009c5a: 9300         	str	r3, [sp]
 8009c5c: 2300         	movs	r3, #0x0
 8009c5e: 2201         	movs	r2, #0x1
 8009c60: 2000         	movs	r0, #0x0
 8009c62: f00c fb9c    	bl	0x801639e <z_log_msg_runtime_create> @ imm = #0xc738
 8009c66: 2300         	movs	r3, #0x0
 8009c68: 617b         	str	r3, [r7, #0x14]
;                 return -1;
 8009c6a: f04f 33ff    	mov.w	r3, #0xffffffff
 8009c6e: e088         	b	0x8009d82 <dji_init+0x2f2> @ imm = #0x110
;             pid_reg_time(cfg->common.controller[i], &(data->curr_time), &(data->prev_time));
 8009c70: 6a3b         	ldr	r3, [r7, #0x20]
 8009c72: 6a7a         	ldr	r2, [r7, #0x24]
 8009c74: 3204         	adds	r2, #0x4
 8009c76: f853 0022    	ldr.w	r0, [r3, r2, lsl #2]
 8009c7a: 69fb         	ldr	r3, [r7, #0x1c]
 8009c7c: f103 0128    	add.w	r1, r3, #0x28
 8009c80: 69fb         	ldr	r3, [r7, #0x1c]
 8009c82: 332c         	adds	r3, #0x2c
 8009c84: 461a         	mov	r2, r3
 8009c86: f00c fc4a    	bl	0x801651e <pid_reg_time> @ imm = #0xc894
;              i++) {
 8009c8a: 6a7b         	ldr	r3, [r7, #0x24]
 8009c8c: 3301         	adds	r3, #0x1
 8009c8e: 627b         	str	r3, [r7, #0x24]
;         for (int i = 0; i < sizeof(cfg->common.controller) / sizeof(cfg->common.controller[0]);
 8009c90: 6a7b         	ldr	r3, [r7, #0x24]
 8009c92: 2b03         	cmp	r3, #0x3
 8009c94: f67f af52    	bls.w	0x8009b3c <dji_init+0xac> @ imm = #-0x15c
 8009c98: e000         	b	0x8009c9c <dji_init+0x20c> @ imm = #0x0
;                 break;
 8009c9a: bf00         	nop
;         data->current_mode_index          = 0;
 8009c9c: 69fb         	ldr	r3, [r7, #0x1c]
 8009c9e: 2200         	movs	r2, #0x0
 8009ca0: 769a         	strb	r2, [r3, #0x1a]
;         data->ctrl_struct->motor_devs[id] = (struct device *)dev;
 8009ca2: 69fb         	ldr	r3, [r7, #0x1c]
 8009ca4: 695a         	ldr	r2, [r3, #0x14]
 8009ca6: 7ebb         	ldrb	r3, [r7, #0x1a]
 8009ca8: 3310         	adds	r3, #0x10
 8009caa: 009b         	lsls	r3, r3, #0x2
 8009cac: 4413         	add	r3, r2
 8009cae: 687a         	ldr	r2, [r7, #0x4]
 8009cb0: 605a         	str	r2, [r3, #0x4]
;         data->prev_time                   = 0;
 8009cb2: 69fb         	ldr	r3, [r7, #0x1c]
 8009cb4: 2200         	movs	r2, #0x0
 8009cb6: 62da         	str	r2, [r3, #0x2c]
;         data->ctrl_struct->flags |= 1 << id;
 8009cb8: 69fb         	ldr	r3, [r7, #0x1c]
 8009cba: 695b         	ldr	r3, [r3, #0x14]
 8009cbc: f893 303d    	ldrb.w	r3, [r3, #0x3d]
 8009cc0: b25a         	sxtb	r2, r3
 8009cc2: 7ebb         	ldrb	r3, [r7, #0x1a]
 8009cc4: 2101         	movs	r1, #0x1
 8009cc6: fa01 f303    	lsl.w	r3, r1, r3
 8009cca: b25b         	sxtb	r3, r3
 8009ccc: 4313         	orrs	r3, r2
 8009cce: b25a         	sxtb	r2, r3
 8009cd0: 69fb         	ldr	r3, [r7, #0x1c]
 8009cd2: 695b         	ldr	r3, [r3, #0x14]
 8009cd4: b2d2         	uxtb	r2, r2
 8009cd6: f883 203d    	strb.w	r2, [r3, #0x3d]
;         data->ctrl_struct->mapping[frame_id][id % 4] = id;
 8009cda: 69fb         	ldr	r3, [r7, #0x1c]
 8009cdc: 6959         	ldr	r1, [r3, #0x14]
 8009cde: 7efa         	ldrb	r2, [r7, #0x1b]
 8009ce0: 7ebb         	ldrb	r3, [r7, #0x1a]
 8009ce2: f003 0303    	and	r3, r3, #0x3
 8009ce6: 0092         	lsls	r2, r2, #0x2
 8009ce8: 440a         	add	r2, r1
 8009cea: 4413         	add	r3, r2
 8009cec: 3329         	adds	r3, #0x29
 8009cee: 7eba         	ldrb	r2, [r7, #0x1a]
 8009cf0: 701a         	strb	r2, [r3]
;         if (cfg->is_gm6020) {
 8009cf2: 6a3b         	ldr	r3, [r7, #0x20]
 8009cf4: f893 3054    	ldrb.w	r3, [r3, #0x54]
 8009cf8: 2b00         	cmp	r3, #0x0
 8009cfa: d003         	beq	0x8009d04 <dji_init+0x274> @ imm = #0x6
;             data->convert_num = GM6020_CONVERT_NUM;
 8009cfc: 69fb         	ldr	r3, [r7, #0x1c]
 8009cfe: 2201         	movs	r2, #0x1
 8009d00: 765a         	strb	r2, [r3, #0x19]
 8009d02: e02b         	b	0x8009d5c <dji_init+0x2cc> @ imm = #0x56
;         } else if (cfg->is_m3508) {
 8009d04: 6a3b         	ldr	r3, [r7, #0x20]
 8009d06: f893 3055    	ldrb.w	r3, [r3, #0x55]
 8009d0a: 2b00         	cmp	r3, #0x0
 8009d0c: d003         	beq	0x8009d16 <dji_init+0x286> @ imm = #0x6
;             data->convert_num = M3508_CONVERT_NUM;
 8009d0e: 69fb         	ldr	r3, [r7, #0x1c]
 8009d10: 2200         	movs	r2, #0x0
 8009d12: 765a         	strb	r2, [r3, #0x19]
 8009d14: e022         	b	0x8009d5c <dji_init+0x2cc> @ imm = #0x44
;         } else if (cfg->is_m2006) {
 8009d16: 6a3b         	ldr	r3, [r7, #0x20]
 8009d18: f893 3056    	ldrb.w	r3, [r3, #0x56]
 8009d1c: 2b00         	cmp	r3, #0x0
 8009d1e: d003         	beq	0x8009d28 <dji_init+0x298> @ imm = #0x6
;             data->convert_num = M2006_CONVERT_NUM;
 8009d20: 69fb         	ldr	r3, [r7, #0x1c]
 8009d22: 2202         	movs	r2, #0x2
 8009d24: 765a         	strb	r2, [r3, #0x19]
 8009d26: e019         	b	0x8009d5c <dji_init+0x2cc> @ imm = #0x32
;             LOG_ERR("Unsupported motor type");
 8009d28: 2304         	movs	r3, #0x4
 8009d2a: 2b00         	cmp	r3, #0x0
 8009d2c: d016         	beq	0x8009d5c <dji_init+0x2cc> @ imm = #0x2c
 8009d2e: 2301         	movs	r3, #0x1
 8009d30: 74fb         	strb	r3, [r7, #0x13]
 8009d32: 7cfb         	ldrb	r3, [r7, #0x13]
 8009d34: f083 0301    	eor	r3, r3, #0x1
 8009d38: b2db         	uxtb	r3, r3
 8009d3a: 2b00         	cmp	r3, #0x0
 8009d3c: d10e         	bne	0x8009d5c <dji_init+0x2cc> @ imm = #0x1c
 8009d3e: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8009d98 <dji_init+0x308>
 8009d40: 6819         	ldr	r1, [r3]
 8009d42: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8009da0 <dji_init+0x310>
 8009d44: 9302         	str	r3, [sp, #0x8]
 8009d46: 2300         	movs	r3, #0x0
 8009d48: 9301         	str	r3, [sp, #0x4]
 8009d4a: 2300         	movs	r3, #0x0
 8009d4c: 9300         	str	r3, [sp]
 8009d4e: 2300         	movs	r3, #0x0
 8009d50: 2201         	movs	r2, #0x1
 8009d52: 2000         	movs	r0, #0x0
 8009d54: f00c fb23    	bl	0x801639e <z_log_msg_runtime_create> @ imm = #0xc646
 8009d58: 2300         	movs	r3, #0x0
 8009d5a: 60fb         	str	r3, [r7, #0xc]
;         if (!device_is_ready(cfg->common.phy))
 8009d5c: 6a3b         	ldr	r3, [r7, #0x20]
 8009d5e: 681b         	ldr	r3, [r3]
 8009d60: 4618         	mov	r0, r3
 8009d62: f00c fabe    	bl	0x80162e2 <device_is_ready> @ imm = #0xc57c
 8009d66: 4603         	mov	r3, r0
 8009d68: f083 0301    	eor	r3, r3, #0x1
 8009d6c: b2db         	uxtb	r3, r3
 8009d6e: 2b00         	cmp	r3, #0x0
 8009d70: d002         	beq	0x8009d78 <dji_init+0x2e8> @ imm = #0x4
;             return -1;
 8009d72: f04f 33ff    	mov.w	r3, #0xffffffff
 8009d76: e004         	b	0x8009d82 <dji_init+0x2f2> @ imm = #0x8
;         k_thread_start(dji_motor_ctrl_thread);
 8009d78: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8009da4 <dji_init+0x314>
 8009d7a: 4618         	mov	r0, r3
 8009d7c: f00c fad9    	bl	0x8016332 <k_thread_start> @ imm = #0xc5b2
;     return 0;
 8009d80: 2300         	movs	r3, #0x0
; }
 8009d82: 4618         	mov	r0, r3
 8009d84: 3728         	adds	r7, #0x28
 8009d86: 46bd         	mov	sp, r7
 8009d88: bd80         	pop	{r7, pc}
 8009d8a: bf00         	nop

08009d8c <$d>:
 8009d8c: e4 ab 01 08  	.word	0x0801abe4
 8009d90: ec ab 01 08  	.word	0x0801abec
 8009d94: f4 ab 01 08  	.word	0x0801abf4
 8009d98: 28 03 00 20  	.word	0x20000328
 8009d9c: fc ab 01 08  	.word	0x0801abfc
 8009da0: 14 ac 01 08  	.word	0x0801ac14
 8009da4: f8 05 00 20  	.word	0x200005f8

08009da8 <can_rx_callback>:
; void can_rx_callback(const struct device *can_dev, struct can_frame *frame, void *user_data) {
 8009da8: b590         	push	{r4, r7, lr}
 8009daa: b09d         	sub	sp, #0x74
 8009dac: af06         	add	r7, sp, #0x18
 8009dae: 60f8         	str	r0, [r7, #0xc]
 8009db0: 60b9         	str	r1, [r7, #0x8]
 8009db2: 607a         	str	r2, [r7, #0x4]
;     uint32_t                 curr_time   = k_cycle_get_32();
 8009db4: f00c faa8    	bl	0x8016308 <k_cycle_get_32> @ imm = #0xc550
 8009db8: 6578         	str	r0, [r7, #0x54]
;     struct motor_controller *ctrl_struct = (struct motor_controller *)user_data;
 8009dba: 687b         	ldr	r3, [r7, #0x4]
 8009dbc: 647b         	str	r3, [r7, #0x44]
;     struct can_frame         rx_frame    = *frame;
 8009dbe: 68bb         	ldr	r3, [r7, #0x8]
 8009dc0: f107 0414    	add.w	r4, r7, #0x14
 8009dc4: cb0f         	ldm	r3, {r0, r1, r2, r3}
 8009dc6: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
;     uint8_t id = (rx_frame.id & 0xF) - 1;
 8009dca: 697b         	ldr	r3, [r7, #0x14]
 8009dcc: b2db         	uxtb	r3, r3
 8009dce: f003 030f    	and	r3, r3, #0xf
 8009dd2: b2db         	uxtb	r3, r3
 8009dd4: 3b01         	subs	r3, #0x1
 8009dd6: f887 304b    	strb.w	r3, [r7, #0x4b]
;     if (ctrl_struct->rx_ids[id] != rx_frame.id && id > 4)
 8009dda: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8009dde: 6c7a         	ldr	r2, [r7, #0x44]
 8009de0: 009b         	lsls	r3, r3, #0x2
 8009de2: 4413         	add	r3, r2
 8009de4: 685b         	ldr	r3, [r3, #0x4]
 8009de6: 461a         	mov	r2, r3
 8009de8: 697b         	ldr	r3, [r7, #0x14]
 8009dea: 429a         	cmp	r2, r3
 8009dec: d008         	beq	0x8009e00 <can_rx_callback+0x58> @ imm = #0x10
 8009dee: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8009df2: 2b04         	cmp	r3, #0x4
 8009df4: d904         	bls	0x8009e00 <can_rx_callback+0x58> @ imm = #0x8
;         id -= 4;
 8009df6: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8009dfa: 3b04         	subs	r3, #0x4
 8009dfc: f887 304b    	strb.w	r3, [r7, #0x4b]
;     if (ctrl_struct->rx_ids[id] != rx_frame.id) {
 8009e00: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8009e04: 6c7a         	ldr	r2, [r7, #0x44]
 8009e06: 009b         	lsls	r3, r3, #0x2
 8009e08: 4413         	add	r3, r2
 8009e0a: 685b         	ldr	r3, [r3, #0x4]
 8009e0c: 461a         	mov	r2, r3
 8009e0e: 697b         	ldr	r3, [r7, #0x14]
 8009e10: 429a         	cmp	r2, r3
 8009e12: d02a         	beq	0x8009e6a <can_rx_callback+0xc2> @ imm = #0x54
;         LOG_ERR("Unknown motor ID: %d, database: %d, received: %d", id, ctrl_struct->rx_ids[id],
 8009e14: 2304         	movs	r3, #0x4
 8009e16: 2b00         	cmp	r3, #0x0
 8009e18: d026         	beq	0x8009e68 <can_rx_callback+0xc0> @ imm = #0x4c
 8009e1a: 2301         	movs	r3, #0x1
 8009e1c: f887 302a    	strb.w	r3, [r7, #0x2a]
 8009e20: f897 302a    	ldrb.w	r3, [r7, #0x2a]
 8009e24: f083 0301    	eor	r3, r3, #0x1
 8009e28: b2db         	uxtb	r3, r3
 8009e2a: 2b00         	cmp	r3, #0x0
 8009e2c: d11c         	bne	0x8009e68 <can_rx_callback+0xc0> @ imm = #0x38
 8009e2e: 4b99         	ldr	r3, [pc, #0x264]        @ 0x800a094 <can_rx_callback+0x2ec>
 8009e30: 6818         	ldr	r0, [r3]
 8009e32: f897 204b    	ldrb.w	r2, [r7, #0x4b]
 8009e36: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8009e3a: 6c79         	ldr	r1, [r7, #0x44]
 8009e3c: 009b         	lsls	r3, r3, #0x2
 8009e3e: 440b         	add	r3, r1
 8009e40: 685b         	ldr	r3, [r3, #0x4]
 8009e42: 6979         	ldr	r1, [r7, #0x14]
 8009e44: 9105         	str	r1, [sp, #0x14]
 8009e46: 9304         	str	r3, [sp, #0x10]
 8009e48: 9203         	str	r2, [sp, #0xc]
 8009e4a: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x800a098 <can_rx_callback+0x2f0>
 8009e4c: 9302         	str	r3, [sp, #0x8]
 8009e4e: 2300         	movs	r3, #0x0
 8009e50: 9301         	str	r3, [sp, #0x4]
 8009e52: 2300         	movs	r3, #0x0
 8009e54: 9300         	str	r3, [sp]
 8009e56: 2300         	movs	r3, #0x0
 8009e58: 2201         	movs	r2, #0x1
 8009e5a: 4601         	mov	r1, r0
 8009e5c: 2000         	movs	r0, #0x0
 8009e5e: f00c fa9e    	bl	0x801639e <z_log_msg_runtime_create> @ imm = #0xc53c
 8009e62: 2300         	movs	r3, #0x0
 8009e64: 627b         	str	r3, [r7, #0x24]
;         return;
 8009e66: e111         	b	0x800a08c <can_rx_callback+0x2e4> @ imm = #0x222
 8009e68: e110         	b	0x800a08c <can_rx_callback+0x2e4> @ imm = #0x220
;     int8_t bus_id = canbus_id(can_dev);
 8009e6a: 68f8         	ldr	r0, [r7, #0xc]
 8009e6c: f7ff fd2a    	bl	0x80098c4 <canbus_id>   @ imm = #-0x5ac
 8009e70: 4603         	mov	r3, r0
 8009e72: f887 3043    	strb.w	r3, [r7, #0x43]
;     if (!ctrl_struct)
 8009e76: 6c7b         	ldr	r3, [r7, #0x44]
 8009e78: 2b00         	cmp	r3, #0x0
 8009e7a: f000 8102    	beq.w	0x800a082 <can_rx_callback+0x2da> @ imm = #0x204
;     struct dji_motor_data *motor_data = ctrl_struct->motor_devs[id]->data;
 8009e7e: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8009e82: 6c7a         	ldr	r2, [r7, #0x44]
 8009e84: 3310         	adds	r3, #0x10
 8009e86: 009b         	lsls	r3, r3, #0x2
 8009e88: 4413         	add	r3, r2
 8009e8a: 685b         	ldr	r3, [r3, #0x4]
 8009e8c: 691b         	ldr	r3, [r3, #0x10]
 8009e8e: 63fb         	str	r3, [r7, #0x3c]
;     uint32_t               prev_time  = motor_data->curr_time;
 8009e90: 6bfb         	ldr	r3, [r7, #0x3c]
 8009e92: 6a9b         	ldr	r3, [r3, #0x28]
 8009e94: 63bb         	str	r3, [r7, #0x38]
;     if (!motor_data)
 8009e96: 6bfb         	ldr	r3, [r7, #0x3c]
 8009e98: 2b00         	cmp	r3, #0x0
 8009e9a: f000 80f4    	beq.w	0x800a086 <can_rx_callback+0x2de> @ imm = #0x1e8
;     if (motor_data->missed_times > 3) {
 8009e9e: 6bfb         	ldr	r3, [r7, #0x3c]
 8009ea0: f993 3034    	ldrsb.w	r3, [r3, #0x34]
 8009ea4: 2b03         	cmp	r3, #0x3
 8009ea6: dd54         	ble	0x8009f52 <can_rx_callback+0x1aa> @ imm = #0xa8
;         LOG_ERR("Motor %d is responding again, resuming...", id);
 8009ea8: 2304         	movs	r3, #0x4
 8009eaa: 2b00         	cmp	r3, #0x0
 8009eac: d01b         	beq	0x8009ee6 <can_rx_callback+0x13e> @ imm = #0x36
 8009eae: 2301         	movs	r3, #0x1
 8009eb0: f887 3037    	strb.w	r3, [r7, #0x37]
 8009eb4: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8009eb8: f083 0301    	eor	r3, r3, #0x1
 8009ebc: b2db         	uxtb	r3, r3
 8009ebe: 2b00         	cmp	r3, #0x0
 8009ec0: d111         	bne	0x8009ee6 <can_rx_callback+0x13e> @ imm = #0x22
 8009ec2: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800a094 <can_rx_callback+0x2ec>
 8009ec4: 6819         	ldr	r1, [r3]
 8009ec6: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8009eca: 9303         	str	r3, [sp, #0xc]
 8009ecc: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x800a09c <can_rx_callback+0x2f4>
 8009ece: 9302         	str	r3, [sp, #0x8]
 8009ed0: 2300         	movs	r3, #0x0
 8009ed2: 9301         	str	r3, [sp, #0x4]
 8009ed4: 2300         	movs	r3, #0x0
 8009ed6: 9300         	str	r3, [sp]
 8009ed8: 2300         	movs	r3, #0x0
 8009eda: 2201         	movs	r2, #0x1
 8009edc: 2000         	movs	r0, #0x0
 8009ede: f00c fa5e    	bl	0x801639e <z_log_msg_runtime_create> @ imm = #0xc4bc
 8009ee2: 2300         	movs	r3, #0x0
 8009ee4: 633b         	str	r3, [r7, #0x30]
;         motor_data->missed_times = 0;
 8009ee6: 6bfb         	ldr	r3, [r7, #0x3c]
 8009ee8: 2200         	movs	r2, #0x0
 8009eea: f883 2034    	strb.w	r2, [r3, #0x34]
;         motor_data->online       = true;
 8009eee: 6bfb         	ldr	r3, [r7, #0x3c]
 8009ef0: 2201         	movs	r2, #0x1
 8009ef2: 761a         	strb	r2, [r3, #0x18]
;             (const struct dji_motor_config *)ctrl_struct->motor_devs[id]->config;
 8009ef4: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8009ef8: 6c7a         	ldr	r2, [r7, #0x44]
 8009efa: 3310         	adds	r3, #0x10
 8009efc: 009b         	lsls	r3, r3, #0x2
 8009efe: 4413         	add	r3, r2
 8009f00: 685b         	ldr	r3, [r3, #0x4]
;         const struct dji_motor_config *motor_cfg =
 8009f02: 685b         	ldr	r3, [r3, #0x4]
 8009f04: 62fb         	str	r3, [r7, #0x2c]
;         ctrl_struct[bus_id].mask[frames_id(motor_cfg->common.tx_id)] ^= 1 << id;
 8009f06: f997 3043    	ldrsb.w	r3, [r7, #0x43]
 8009f0a: 2274         	movs	r2, #0x74
 8009f0c: fb02 f303    	mul	r3, r2, r3
 8009f10: 6c7a         	ldr	r2, [r7, #0x44]
 8009f12: 18d4         	adds	r4, r2, r3
 8009f14: 6afb         	ldr	r3, [r7, #0x2c]
 8009f16: 689b         	ldr	r3, [r3, #0x8]
 8009f18: 4618         	mov	r0, r3
 8009f1a: f00c fb1c    	bl	0x8016556 <frames_id>   @ imm = #0xc638
 8009f1e: 4603         	mov	r3, r0
 8009f20: 18e2         	adds	r2, r4, r3
 8009f22: f892 203e    	ldrb.w	r2, [r2, #0x3e]
 8009f26: b251         	sxtb	r1, r2
 8009f28: f897 204b    	ldrb.w	r2, [r7, #0x4b]
 8009f2c: 2001         	movs	r0, #0x1
 8009f2e: fa00 f202    	lsl.w	r2, r0, r2
 8009f32: b252         	sxtb	r2, r2
 8009f34: 404a         	eors	r2, r1
 8009f36: b250         	sxtb	r0, r2
 8009f38: f997 2043    	ldrsb.w	r2, [r7, #0x43]
 8009f3c: 2174         	movs	r1, #0x74
 8009f3e: fb01 f202    	mul	r2, r1, r2
 8009f42: 6c79         	ldr	r1, [r7, #0x44]
 8009f44: 440a         	add	r2, r1
 8009f46: b2c1         	uxtb	r1, r0
 8009f48: 4413         	add	r3, r2
 8009f4a: 460a         	mov	r2, r1
 8009f4c: f883 203e    	strb.w	r2, [r3, #0x3e]
 8009f50: e00e         	b	0x8009f70 <can_rx_callback+0x1c8> @ imm = #0x1c
;     } else if (motor_data->missed_times > 0) {
 8009f52: 6bfb         	ldr	r3, [r7, #0x3c]
 8009f54: f993 3034    	ldrsb.w	r3, [r3, #0x34]
 8009f58: 2b00         	cmp	r3, #0x0
 8009f5a: dd09         	ble	0x8009f70 <can_rx_callback+0x1c8> @ imm = #0x12
;         motor_data->missed_times--;
 8009f5c: 6bfb         	ldr	r3, [r7, #0x3c]
 8009f5e: f993 3034    	ldrsb.w	r3, [r3, #0x34]
 8009f62: b2db         	uxtb	r3, r3
 8009f64: 3b01         	subs	r3, #0x1
 8009f66: b2db         	uxtb	r3, r3
 8009f68: b25a         	sxtb	r2, r3
 8009f6a: 6bfb         	ldr	r3, [r7, #0x3c]
 8009f6c: f883 2034    	strb.w	r2, [r3, #0x34]
;     motor_data->RAWprev_angle = motor_data->RAWangle;
 8009f70: 6bfb         	ldr	r3, [r7, #0x3c]
 8009f72: 8b9a         	ldrh	r2, [r3, #0x1c]
 8009f74: 6bfb         	ldr	r3, [r7, #0x3c]
 8009f76: 83da         	strh	r2, [r3, #0x1e]
;     motor_data->RAWangle      = COMBINE_HL8(rx_frame.data[0], rx_frame.data[1]);
 8009f78: 7f3b         	ldrb	r3, [r7, #0x1c]
 8009f7a: 021b         	lsls	r3, r3, #0x8
 8009f7c: b29b         	uxth	r3, r3
 8009f7e: 7f7a         	ldrb	r2, [r7, #0x1d]
 8009f80: 4413         	add	r3, r2
 8009f82: b29a         	uxth	r2, r3
 8009f84: 6bfb         	ldr	r3, [r7, #0x3c]
 8009f86: 839a         	strh	r2, [r3, #0x1c]
;     motor_data->RAWrpm        = COMBINE_HL8(rx_frame.data[2], rx_frame.data[3]);
 8009f88: 7fbb         	ldrb	r3, [r7, #0x1e]
 8009f8a: 021b         	lsls	r3, r3, #0x8
 8009f8c: b29b         	uxth	r3, r3
 8009f8e: 7ffa         	ldrb	r2, [r7, #0x1f]
 8009f90: 4413         	add	r3, r2
 8009f92: b29b         	uxth	r3, r3
 8009f94: b21a         	sxth	r2, r3
 8009f96: 6bfb         	ldr	r3, [r7, #0x3c]
 8009f98: 849a         	strh	r2, [r3, #0x24]
;     motor_data->RAWcurrent    = COMBINE_HL8(rx_frame.data[4], rx_frame.data[5]);
 8009f9a: f897 3020    	ldrb.w	r3, [r7, #0x20]
 8009f9e: 021b         	lsls	r3, r3, #0x8
 8009fa0: f897 2021    	ldrb.w	r2, [r7, #0x21]
 8009fa4: 441a         	add	r2, r3
 8009fa6: 6bfb         	ldr	r3, [r7, #0x3c]
 8009fa8: 621a         	str	r2, [r3, #0x20]
;     motor_data->RAWtemp       = rx_frame.data[6];
 8009faa: f897 3022    	ldrb.w	r3, [r7, #0x22]
 8009fae: b25a         	sxtb	r2, r3
 8009fb0: 6bfb         	ldr	r3, [r7, #0x3c]
 8009fb2: f883 2026    	strb.w	r2, [r3, #0x26]
;     ctrl_struct[bus_id].flags |= 1 << id;
 8009fb6: f997 3043    	ldrsb.w	r3, [r7, #0x43]
 8009fba: 2274         	movs	r2, #0x74
 8009fbc: fb02 f303    	mul	r3, r2, r3
 8009fc0: 6c7a         	ldr	r2, [r7, #0x44]
 8009fc2: 4413         	add	r3, r2
 8009fc4: f893 303d    	ldrb.w	r3, [r3, #0x3d]
 8009fc8: b25a         	sxtb	r2, r3
 8009fca: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8009fce: 2101         	movs	r1, #0x1
 8009fd0: fa01 f303    	lsl.w	r3, r1, r3
 8009fd4: b25b         	sxtb	r3, r3
 8009fd6: 4313         	orrs	r3, r2
 8009fd8: b259         	sxtb	r1, r3
 8009fda: f997 3043    	ldrsb.w	r3, [r7, #0x43]
 8009fde: 2274         	movs	r2, #0x74
 8009fe0: fb02 f303    	mul	r3, r2, r3
 8009fe4: 6c7a         	ldr	r2, [r7, #0x44]
 8009fe6: 4413         	add	r3, r2
 8009fe8: b2ca         	uxtb	r2, r1
 8009fea: f883 203d    	strb.w	r2, [r3, #0x3d]
;     motor_data->curr_time = curr_time;
 8009fee: 6bfb         	ldr	r3, [r7, #0x3c]
 8009ff0: 6d7a         	ldr	r2, [r7, #0x54]
 8009ff2: 629a         	str	r2, [r3, #0x28]
;     motor_data->prev_time = prev_time;
 8009ff4: 6bfb         	ldr	r3, [r7, #0x3c]
 8009ff6: 6bba         	ldr	r2, [r7, #0x38]
 8009ff8: 62da         	str	r2, [r3, #0x2c]
;     bool full             = false;
 8009ffa: 2300         	movs	r3, #0x0
 8009ffc: f887 3053    	strb.w	r3, [r7, #0x53]
;     for (int i = 0; i < 5; i++) {
 800a000: 2300         	movs	r3, #0x0
 800a002: 64fb         	str	r3, [r7, #0x4c]
 800a004: e030         	b	0x800a068 <can_rx_callback+0x2c0> @ imm = #0x60
;         uint8_t combined = ctrl_struct[bus_id].mask[i] | ctrl_struct[bus_id].flags;
 800a006: f997 3043    	ldrsb.w	r3, [r7, #0x43]
 800a00a: 2274         	movs	r2, #0x74
 800a00c: fb02 f303    	mul	r3, r2, r3
 800a010: 6c7a         	ldr	r2, [r7, #0x44]
 800a012: 441a         	add	r2, r3
 800a014: 6cfb         	ldr	r3, [r7, #0x4c]
 800a016: 4413         	add	r3, r2
 800a018: 333e         	adds	r3, #0x3e
 800a01a: 781a         	ldrb	r2, [r3]
 800a01c: f997 3043    	ldrsb.w	r3, [r7, #0x43]
 800a020: 2174         	movs	r1, #0x74
 800a022: fb01 f303    	mul	r3, r1, r3
 800a026: 6c79         	ldr	r1, [r7, #0x44]
 800a028: 440b         	add	r3, r1
 800a02a: f893 303d    	ldrb.w	r3, [r3, #0x3d]
 800a02e: 4313         	orrs	r3, r2
 800a030: f887 302b    	strb.w	r3, [r7, #0x2b]
;         if (combined == 0xF0 || combined == 0x0F) {
 800a034: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800a038: 2bf0         	cmp	r3, #0xf0
 800a03a: d003         	beq	0x800a044 <can_rx_callback+0x29c> @ imm = #0x6
 800a03c: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800a040: 2b0f         	cmp	r3, #0xf
 800a042: d10e         	bne	0x800a062 <can_rx_callback+0x2ba> @ imm = #0x1c
;             ctrl_struct[bus_id].full[i] = true;
 800a044: f997 3043    	ldrsb.w	r3, [r7, #0x43]
 800a048: 2274         	movs	r2, #0x74
 800a04a: fb02 f303    	mul	r3, r2, r3
 800a04e: 6c7a         	ldr	r2, [r7, #0x44]
 800a050: 441a         	add	r2, r3
 800a052: 6cfb         	ldr	r3, [r7, #0x4c]
 800a054: 4413         	add	r3, r2
 800a056: 3324         	adds	r3, #0x24
 800a058: 2201         	movs	r2, #0x1
 800a05a: 701a         	strb	r2, [r3]
;             full                        = true;
 800a05c: 2301         	movs	r3, #0x1
 800a05e: f887 3053    	strb.w	r3, [r7, #0x53]
;     for (int i = 0; i < 5; i++) {
 800a062: 6cfb         	ldr	r3, [r7, #0x4c]
 800a064: 3301         	adds	r3, #0x1
 800a066: 64fb         	str	r3, [r7, #0x4c]
 800a068: 6cfb         	ldr	r3, [r7, #0x4c]
 800a06a: 2b04         	cmp	r3, #0x4
 800a06c: ddcb         	ble	0x800a006 <can_rx_callback+0x25e> @ imm = #-0x6a
;     if (full)
 800a06e: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800a072: 2b00         	cmp	r3, #0x0
 800a074: d009         	beq	0x800a08a <can_rx_callback+0x2e2> @ imm = #0x12
;         k_sem_give(&ctrl_struct->thread_sem);
 800a076: 6c7b         	ldr	r3, [r7, #0x44]
 800a078: 3364         	adds	r3, #0x64
 800a07a: 4618         	mov	r0, r3
 800a07c: f00c f984    	bl	0x8016388 <k_sem_give>  @ imm = #0xc308
;     return;
 800a080: e003         	b	0x800a08a <can_rx_callback+0x2e2> @ imm = #0x6
;         return;
 800a082: bf00         	nop
 800a084: e002         	b	0x800a08c <can_rx_callback+0x2e4> @ imm = #0x4
;         return;
 800a086: bf00         	nop
 800a088: e000         	b	0x800a08c <can_rx_callback+0x2e4> @ imm = #0x0
;     return;
 800a08a: bf00         	nop
; }
 800a08c: 375c         	adds	r7, #0x5c
 800a08e: 46bd         	mov	sp, r7
 800a090: bd90         	pop	{r4, r7, pc}
 800a092: bf00         	nop

0800a094 <$d>:
 800a094: 28 03 00 20  	.word	0x20000328
 800a098: 2c ac 01 08  	.word	0x0801ac2c
 800a09c: 60 ac 01 08  	.word	0x0801ac60

0800a0a0 <dji_timeout_handle>:
;                                struct motor_controller *ctrl_struct) {
 800a0a0: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800a0a4: b08e         	sub	sp, #0x38
 800a0a6: af04         	add	r7, sp, #0x10
 800a0a8: 60f8         	str	r0, [r7, #0xc]
 800a0aa: 60b9         	str	r1, [r7, #0x8]
 800a0ac: 607a         	str	r2, [r7, #0x4]
;     struct dji_motor_data         *motor_data = (struct dji_motor_data *)dev->data;
 800a0ae: 68fb         	ldr	r3, [r7, #0xc]
 800a0b0: 691b         	ldr	r3, [r3, #0x10]
 800a0b2: 627b         	str	r3, [r7, #0x24]
;     const struct dji_motor_config *motor_cfg  = (const struct dji_motor_config *)dev->config;
 800a0b4: 68fb         	ldr	r3, [r7, #0xc]
 800a0b6: 685b         	ldr	r3, [r3, #0x4]
 800a0b8: 623b         	str	r3, [r7, #0x20]
;     if (motor_data->online == false)
 800a0ba: 6a7b         	ldr	r3, [r7, #0x24]
 800a0bc: 7e1b         	ldrb	r3, [r3, #0x18]
 800a0be: f083 0301    	eor	r3, r3, #0x1
 800a0c2: b2db         	uxtb	r3, r3
 800a0c4: 2b00         	cmp	r3, #0x0
 800a0c6: f040 8089    	bne.w	0x800a1dc <dji_timeout_handle+0x13c> @ imm = #0x112
;     uint32_t prev_time = motor_data->curr_time;
 800a0ca: 6a7b         	ldr	r3, [r7, #0x24]
 800a0cc: 6a9b         	ldr	r3, [r3, #0x28]
 800a0ce: 61fb         	str	r3, [r7, #0x1c]
;     if (k_cyc_to_us_near32(curr_time - prev_time) > 2000) {
 800a0d0: 68ba         	ldr	r2, [r7, #0x8]
 800a0d2: 69fb         	ldr	r3, [r7, #0x1c]
 800a0d4: 1ad3         	subs	r3, r2, r3
 800a0d6: f113 0f55    	cmn.w	r3, #0x55
 800a0da: d80a         	bhi	0x800a0f2 <dji_timeout_handle+0x52> @ imm = #0x14
 800a0dc: 68ba         	ldr	r2, [r7, #0x8]
 800a0de: 69fb         	ldr	r3, [r7, #0x1c]
 800a0e0: 1ad3         	subs	r3, r2, r3
 800a0e2: 3354         	adds	r3, #0x54
 800a0e4: 4a40         	ldr	r2, [pc, #0x100]        @ 0x800a1e8 <dji_timeout_handle+0x148>
 800a0e6: 4293         	cmp	r3, r2
 800a0e8: bf8c         	ite	hi
 800a0ea: 2301         	movhi	r3, #0x1
 800a0ec: 2300         	movls	r3, #0x0
 800a0ee: b2db         	uxtb	r3, r3
 800a0f0: e01a         	b	0x800a128 <dji_timeout_handle+0x88> @ imm = #0x34
 800a0f2: 68ba         	ldr	r2, [r7, #0x8]
 800a0f4: 69fb         	ldr	r3, [r7, #0x1c]
 800a0f6: 1ad3         	subs	r3, r2, r3
 800a0f8: 2200         	movs	r2, #0x0
 800a0fa: 461c         	mov	r4, r3
 800a0fc: 4615         	mov	r5, r2
 800a0fe: f114 0854    	adds.w	r8, r4, #0x54
 800a102: f145 0900    	adc	r9, r5, #0x0
 800a106: f04f 02a8    	mov.w	r2, #0xa8
 800a10a: f04f 0300    	mov.w	r3, #0x0
 800a10e: 4640         	mov	r0, r8
 800a110: 4649         	mov	r1, r9
 800a112: f7f6 fcef    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x9622
 800a116: 4602         	mov	r2, r0
 800a118: 460b         	mov	r3, r1
 800a11a: 4613         	mov	r3, r2
 800a11c: f5b3 6ffa    	cmp.w	r3, #0x7d0
 800a120: bf8c         	ite	hi
 800a122: 2301         	movhi	r3, #0x1
 800a124: 2300         	movls	r3, #0x0
 800a126: b2db         	uxtb	r3, r3
 800a128: 2b00         	cmp	r3, #0x0
 800a12a: d058         	beq	0x800a1de <dji_timeout_handle+0x13e> @ imm = #0xb0
;         motor_data->missed_times++;
 800a12c: 6a7b         	ldr	r3, [r7, #0x24]
 800a12e: f993 3034    	ldrsb.w	r3, [r3, #0x34]
 800a132: b2db         	uxtb	r3, r3
 800a134: 3301         	adds	r3, #0x1
 800a136: b2db         	uxtb	r3, r3
 800a138: b25a         	sxtb	r2, r3
 800a13a: 6a7b         	ldr	r3, [r7, #0x24]
 800a13c: f883 2034    	strb.w	r2, [r3, #0x34]
;         if (motor_data->missed_times > 3) {
 800a140: 6a7b         	ldr	r3, [r7, #0x24]
 800a142: f993 3034    	ldrsb.w	r3, [r3, #0x34]
 800a146: 2b03         	cmp	r3, #0x3
 800a148: dd49         	ble	0x800a1de <dji_timeout_handle+0x13e> @ imm = #0x92
;             LOG_ERR("Motor %d is not responding", motor_cfg->common.id);
 800a14a: 2304         	movs	r3, #0x4
 800a14c: 2b00         	cmp	r3, #0x0
 800a14e: d019         	beq	0x800a184 <dji_timeout_handle+0xe4> @ imm = #0x32
 800a150: 2301         	movs	r3, #0x1
 800a152: 76fb         	strb	r3, [r7, #0x1b]
 800a154: 7efb         	ldrb	r3, [r7, #0x1b]
 800a156: f083 0301    	eor	r3, r3, #0x1
 800a15a: b2db         	uxtb	r3, r3
 800a15c: 2b00         	cmp	r3, #0x0
 800a15e: d111         	bne	0x800a184 <dji_timeout_handle+0xe4> @ imm = #0x22
 800a160: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800a1ec <dji_timeout_handle+0x14c>
 800a162: 6819         	ldr	r1, [r3]
 800a164: 6a3b         	ldr	r3, [r7, #0x20]
 800a166: 791b         	ldrb	r3, [r3, #0x4]
 800a168: 9303         	str	r3, [sp, #0xc]
 800a16a: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800a1f0 <dji_timeout_handle+0x150>
 800a16c: 9302         	str	r3, [sp, #0x8]
 800a16e: 2300         	movs	r3, #0x0
 800a170: 9301         	str	r3, [sp, #0x4]
 800a172: 2300         	movs	r3, #0x0
 800a174: 9300         	str	r3, [sp]
 800a176: 2300         	movs	r3, #0x0
 800a178: 2201         	movs	r2, #0x1
 800a17a: 2000         	movs	r0, #0x0
 800a17c: f00c f90f    	bl	0x801639e <z_log_msg_runtime_create> @ imm = #0xc21e
 800a180: 2300         	movs	r3, #0x0
 800a182: 617b         	str	r3, [r7, #0x14]
;             ctrl_struct[motor_data->canbus_id].mask[frames_id(motor_cfg->common.tx_id)] ^=
 800a184: 6a7b         	ldr	r3, [r7, #0x24]
 800a186: 7c1b         	ldrb	r3, [r3, #0x10]
 800a188: 461a         	mov	r2, r3
 800a18a: 2374         	movs	r3, #0x74
 800a18c: fb02 f303    	mul	r3, r2, r3
 800a190: 687a         	ldr	r2, [r7, #0x4]
 800a192: 18d4         	adds	r4, r2, r3
 800a194: 6a3b         	ldr	r3, [r7, #0x20]
 800a196: 689b         	ldr	r3, [r3, #0x8]
 800a198: 4618         	mov	r0, r3
 800a19a: f00c f9dc    	bl	0x8016556 <frames_id>   @ imm = #0xc3b8
 800a19e: 4603         	mov	r3, r0
 800a1a0: 18e2         	adds	r2, r4, r3
 800a1a2: f892 203e    	ldrb.w	r2, [r2, #0x3e]
 800a1a6: b251         	sxtb	r1, r2
;                 1 << (motor_cfg->common.id - 1);
 800a1a8: 6a3a         	ldr	r2, [r7, #0x20]
 800a1aa: 7912         	ldrb	r2, [r2, #0x4]
 800a1ac: 3a01         	subs	r2, #0x1
 800a1ae: 2001         	movs	r0, #0x1
 800a1b0: fa00 f202    	lsl.w	r2, r0, r2
;             ctrl_struct[motor_data->canbus_id].mask[frames_id(motor_cfg->common.tx_id)] ^=
 800a1b4: b252         	sxtb	r2, r2
 800a1b6: 404a         	eors	r2, r1
 800a1b8: b250         	sxtb	r0, r2
 800a1ba: 6a7a         	ldr	r2, [r7, #0x24]
 800a1bc: 7c12         	ldrb	r2, [r2, #0x10]
 800a1be: 4611         	mov	r1, r2
 800a1c0: 2274         	movs	r2, #0x74
 800a1c2: fb01 f202    	mul	r2, r1, r2
 800a1c6: 6879         	ldr	r1, [r7, #0x4]
 800a1c8: 440a         	add	r2, r1
 800a1ca: b2c1         	uxtb	r1, r0
 800a1cc: 4413         	add	r3, r2
 800a1ce: 460a         	mov	r2, r1
 800a1d0: f883 203e    	strb.w	r2, [r3, #0x3e]
;             motor_data->online = false;
 800a1d4: 6a7b         	ldr	r3, [r7, #0x24]
 800a1d6: 2200         	movs	r2, #0x0
 800a1d8: 761a         	strb	r2, [r3, #0x18]
 800a1da: e000         	b	0x800a1de <dji_timeout_handle+0x13e> @ imm = #0x0
;         return;
 800a1dc: bf00         	nop
; }
 800a1de: 3728         	adds	r7, #0x28
 800a1e0: 46bd         	mov	sp, r7
 800a1e2: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 800a1e6: bf00         	nop

0800a1e8 <$d>:
 800a1e8: 27 21 05 00  	.word	0x00052127
 800a1ec: 28 03 00 20  	.word	0x20000328
 800a1f0: 8c ac 01 08  	.word	0x0801ac8c

0800a1f4 <motor_calc>:
; static void motor_calc(const struct device *dev) {
 800a1f4: b590         	push	{r4, r7, lr}
 800a1f6: b089         	sub	sp, #0x24
 800a1f8: af00         	add	r7, sp, #0x0
 800a1fa: 6078         	str	r0, [r7, #0x4]
;     const struct device           *dev_temp    = dev;
 800a1fc: 687b         	ldr	r3, [r7, #0x4]
 800a1fe: 617b         	str	r3, [r7, #0x14]
;     struct dji_motor_data         *data_temp   = dev_temp->data;
 800a200: 697b         	ldr	r3, [r7, #0x14]
 800a202: 691b         	ldr	r3, [r3, #0x10]
 800a204: 613b         	str	r3, [r7, #0x10]
;     const struct dji_motor_config *config_temp = dev_temp->config;
 800a206: 697b         	ldr	r3, [r7, #0x14]
 800a208: 685b         	ldr	r3, [r3, #0x4]
 800a20a: 60fb         	str	r3, [r7, #0xc]
;     data_temp->RAWangle_add += delta_degree(data_temp->RAWangle, data_temp->RAWprev_angle);
 800a20c: 693b         	ldr	r3, [r7, #0x10]
 800a20e: 8b9a         	ldrh	r2, [r3, #0x1c]
 800a210: 693b         	ldr	r3, [r7, #0x10]
 800a212: 8bdb         	ldrh	r3, [r3, #0x1e]
 800a214: 4619         	mov	r1, r3
 800a216: 4610         	mov	r0, r2
 800a218: f00c fa4e    	bl	0x80166b8 <delta_degree> @ imm = #0xc49c
 800a21c: 4602         	mov	r2, r0
 800a21e: 693b         	ldr	r3, [r7, #0x10]
 800a220: 6b1b         	ldr	r3, [r3, #0x30]
 800a222: 441a         	add	r2, r3
 800a224: 693b         	ldr	r3, [r7, #0x10]
 800a226: 631a         	str	r2, [r3, #0x30]
;     data_temp->RAWangle_add %= (int)(8192 * config_temp->gear_ratio * 100);
 800a228: 693b         	ldr	r3, [r7, #0x10]
 800a22a: 6b1c         	ldr	r4, [r3, #0x30]
 800a22c: 68fb         	ldr	r3, [r7, #0xc]
 800a22e: 6d1b         	ldr	r3, [r3, #0x50]
 800a230: f04f 418c    	mov.w	r1, #0x46000000
 800a234: 4618         	mov	r0, r3
 800a236: f7f6 fa71    	bl	0x800071c <__mulsf3>    @ imm = #-0x9b1e
 800a23a: 4603         	mov	r3, r0
 800a23c: 4970         	ldr	r1, [pc, #0x1c0]        @ 0x800a400 <motor_calc+0x20c>
 800a23e: 4618         	mov	r0, r3
 800a240: f7f6 fa6c    	bl	0x800071c <__mulsf3>    @ imm = #-0x9b28
 800a244: 4603         	mov	r3, r0
 800a246: 4618         	mov	r0, r3
 800a248: f7f6 fc2e    	bl	0x8000aa8 <__fixsfsi>   @ imm = #-0x97a4
 800a24c: 4603         	mov	r3, r0
 800a24e: fb94 f2f3    	sdiv	r2, r4, r3
 800a252: fb02 f303    	mul	r3, r2, r3
 800a256: 1ae2         	subs	r2, r4, r3
 800a258: 693b         	ldr	r3, [r7, #0x10]
 800a25a: 631a         	str	r2, [r3, #0x30]
;         fmodf((float)(data_temp->RAWangle_add) * convert[data_temp->convert_num][ANGLE2DEGREE] /
 800a25c: 693b         	ldr	r3, [r7, #0x10]
 800a25e: 6b1b         	ldr	r3, [r3, #0x30]
 800a260: 4618         	mov	r0, r3
 800a262: f7f6 fa07    	bl	0x8000674 <__floatsisf> @ imm = #-0x9bf2
 800a266: 4602         	mov	r2, r0
 800a268: 693b         	ldr	r3, [r7, #0x10]
 800a26a: 7e5b         	ldrb	r3, [r3, #0x19]
 800a26c: 4618         	mov	r0, r3
 800a26e: 4965         	ldr	r1, [pc, #0x194]        @ 0x800a404 <motor_calc+0x210>
 800a270: 4603         	mov	r3, r0
 800a272: 005b         	lsls	r3, r3, #0x1
 800a274: 4403         	add	r3, r0
 800a276: 00db         	lsls	r3, r3, #0x3
 800a278: 440b         	add	r3, r1
 800a27a: 3310         	adds	r3, #0x10
 800a27c: 681b         	ldr	r3, [r3]
 800a27e: 4619         	mov	r1, r3
 800a280: 4610         	mov	r0, r2
 800a282: f7f6 fa4b    	bl	0x800071c <__mulsf3>    @ imm = #-0x9b6a
 800a286: 4603         	mov	r3, r0
 800a288: 461c         	mov	r4, r3
;                   (4 * config_temp->gear_ratio),
 800a28a: 68fb         	ldr	r3, [r7, #0xc]
 800a28c: 6d1b         	ldr	r3, [r3, #0x50]
 800a28e: f04f 4181    	mov.w	r1, #0x40800000
 800a292: 4618         	mov	r0, r3
 800a294: f7f6 fa42    	bl	0x800071c <__mulsf3>    @ imm = #-0x9b7c
 800a298: 4603         	mov	r3, r0
;         fmodf((float)(data_temp->RAWangle_add) * convert[data_temp->convert_num][ANGLE2DEGREE] /
 800a29a: 4619         	mov	r1, r3
 800a29c: 4620         	mov	r0, r4
 800a29e: f7f6 faf1    	bl	0x8000884 <__divsf3>    @ imm = #-0x9a1e
 800a2a2: 4603         	mov	r3, r0
 800a2a4: 4958         	ldr	r1, [pc, #0x160]        @ 0x800a408 <motor_calc+0x214>
 800a2a6: 4618         	mov	r0, r3
 800a2a8: f005 ff32    	bl	0x8010110 <fmodf>       @ imm = #0x5e64
 800a2ac: 4602         	mov	r2, r0
;     data_temp->common.angle =
 800a2ae: 693b         	ldr	r3, [r7, #0x10]
 800a2b0: 601a         	str	r2, [r3]
;         data_temp->RAWrpm * convert[data_temp->convert_num][SPEED2RPM] / config_temp->gear_ratio;
 800a2b2: 693b         	ldr	r3, [r7, #0x10]
 800a2b4: f9b3 3024    	ldrsh.w	r3, [r3, #0x24]
 800a2b8: 4618         	mov	r0, r3
 800a2ba: f7f6 f9db    	bl	0x8000674 <__floatsisf> @ imm = #-0x9c4a
 800a2be: 4602         	mov	r2, r0
 800a2c0: 693b         	ldr	r3, [r7, #0x10]
 800a2c2: 7e5b         	ldrb	r3, [r3, #0x19]
 800a2c4: 4618         	mov	r0, r3
 800a2c6: 494f         	ldr	r1, [pc, #0x13c]        @ 0x800a404 <motor_calc+0x210>
 800a2c8: 4603         	mov	r3, r0
 800a2ca: 005b         	lsls	r3, r3, #0x1
 800a2cc: 4403         	add	r3, r0
 800a2ce: 00db         	lsls	r3, r3, #0x3
 800a2d0: 440b         	add	r3, r1
 800a2d2: 3308         	adds	r3, #0x8
 800a2d4: 681b         	ldr	r3, [r3]
 800a2d6: 4619         	mov	r1, r3
 800a2d8: 4610         	mov	r0, r2
 800a2da: f7f6 fa1f    	bl	0x800071c <__mulsf3>    @ imm = #-0x9bc2
 800a2de: 4603         	mov	r3, r0
 800a2e0: 461a         	mov	r2, r3
 800a2e2: 68fb         	ldr	r3, [r7, #0xc]
 800a2e4: 6d1b         	ldr	r3, [r3, #0x50]
 800a2e6: 4619         	mov	r1, r3
 800a2e8: 4610         	mov	r0, r2
 800a2ea: f7f6 facb    	bl	0x8000884 <__divsf3>    @ imm = #-0x9a6a
 800a2ee: 4603         	mov	r3, r0
 800a2f0: 461a         	mov	r2, r3
;     data_temp->common.rpm =
 800a2f2: 693b         	ldr	r3, [r7, #0x10]
 800a2f4: 605a         	str	r2, [r3, #0x4]
;     data_temp->common.torque = data_temp->RAWcurrent *
 800a2f6: 693b         	ldr	r3, [r7, #0x10]
 800a2f8: 6a1b         	ldr	r3, [r3, #0x20]
 800a2fa: 4618         	mov	r0, r3
 800a2fc: f7f6 f9ba    	bl	0x8000674 <__floatsisf> @ imm = #-0x9c8c
 800a300: 4602         	mov	r2, r0
;                                convert[data_temp->convert_num][CURRENT2TORQUE] *
 800a302: 693b         	ldr	r3, [r7, #0x10]
 800a304: 7e5b         	ldrb	r3, [r3, #0x19]
 800a306: 4618         	mov	r0, r3
 800a308: 493e         	ldr	r1, [pc, #0xf8]         @ 0x800a404 <motor_calc+0x210>
 800a30a: 4603         	mov	r3, r0
 800a30c: 005b         	lsls	r3, r3, #0x1
 800a30e: 4403         	add	r3, r0
 800a310: 00db         	lsls	r3, r3, #0x3
 800a312: 440b         	add	r3, r1
 800a314: 681b         	ldr	r3, [r3]
;     data_temp->common.torque = data_temp->RAWcurrent *
 800a316: 4619         	mov	r1, r3
 800a318: 4610         	mov	r0, r2
 800a31a: f7f6 f9ff    	bl	0x800071c <__mulsf3>    @ imm = #-0x9c02
 800a31e: 4603         	mov	r3, r0
 800a320: 461a         	mov	r2, r3
;                                config_temp->gear_ratio;
 800a322: 68fb         	ldr	r3, [r7, #0xc]
 800a324: 6d1b         	ldr	r3, [r3, #0x50]
;                                convert[data_temp->convert_num][CURRENT2TORQUE] *
 800a326: 4619         	mov	r1, r3
 800a328: 4610         	mov	r0, r2
 800a32a: f7f6 f9f7    	bl	0x800071c <__mulsf3>    @ imm = #-0x9c12
 800a32e: 4603         	mov	r3, r0
 800a330: 461a         	mov	r2, r3
;     data_temp->common.torque = data_temp->RAWcurrent *
 800a332: 693b         	ldr	r3, [r7, #0x10]
 800a334: 609a         	str	r2, [r3, #0x8]
;     bool torque_proceeded = false;
 800a336: 2300         	movs	r3, #0x0
 800a338: 77fb         	strb	r3, [r7, #0x1f]
;     for (int i = data_temp->current_mode_index; i < SIZE_OF_ARRAY(config_temp->common.controller);
 800a33a: 693b         	ldr	r3, [r7, #0x10]
 800a33c: f993 301a    	ldrsb.w	r3, [r3, #0x1a]
 800a340: 61bb         	str	r3, [r7, #0x18]
 800a342: e052         	b	0x800a3ea <motor_calc+0x1f6> @ imm = #0xa4
;         if (config_temp->common.controller[i] == NULL) {
 800a344: 68fb         	ldr	r3, [r7, #0xc]
 800a346: 69ba         	ldr	r2, [r7, #0x18]
 800a348: 3204         	adds	r2, #0x4
 800a34a: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800a34e: 2b00         	cmp	r3, #0x0
 800a350: d11f         	bne	0x800a392 <motor_calc+0x19e> @ imm = #0x3e
;             if (torque_proceeded)
 800a352: 7ffb         	ldrb	r3, [r7, #0x1f]
 800a354: 2b00         	cmp	r3, #0x0
 800a356: d14c         	bne	0x800a3f2 <motor_calc+0x1fe> @ imm = #0x98
;             data_temp->target_current = data_temp->target_torque / config_temp->gear_ratio *
 800a358: 693b         	ldr	r3, [r7, #0x10]
 800a35a: 6c1a         	ldr	r2, [r3, #0x40]
 800a35c: 68fb         	ldr	r3, [r7, #0xc]
 800a35e: 6d1b         	ldr	r3, [r3, #0x50]
 800a360: 4619         	mov	r1, r3
 800a362: 4610         	mov	r0, r2
 800a364: f7f6 fa8e    	bl	0x8000884 <__divsf3>    @ imm = #-0x9ae4
 800a368: 4603         	mov	r3, r0
 800a36a: 4618         	mov	r0, r3
;                                         convert[data_temp->convert_num][TORQUE2CURRENT];
 800a36c: 693b         	ldr	r3, [r7, #0x10]
 800a36e: 7e5b         	ldrb	r3, [r3, #0x19]
 800a370: 4619         	mov	r1, r3
 800a372: 4a24         	ldr	r2, [pc, #0x90]         @ 0x800a404 <motor_calc+0x210>
 800a374: 460b         	mov	r3, r1
 800a376: 005b         	lsls	r3, r3, #0x1
 800a378: 440b         	add	r3, r1
 800a37a: 00db         	lsls	r3, r3, #0x3
 800a37c: 4413         	add	r3, r2
 800a37e: 3304         	adds	r3, #0x4
 800a380: 681b         	ldr	r3, [r3]
;             data_temp->target_current = data_temp->target_torque / config_temp->gear_ratio *
 800a382: 4619         	mov	r1, r3
 800a384: f7f6 f9ca    	bl	0x800071c <__mulsf3>    @ imm = #-0x9c6c
 800a388: 4603         	mov	r3, r0
 800a38a: 461a         	mov	r2, r3
 800a38c: 693b         	ldr	r3, [r7, #0x10]
 800a38e: 645a         	str	r2, [r3, #0x44]
;             break;
 800a390: e032         	b	0x800a3f8 <motor_calc+0x204> @ imm = #0x64
;         pid_calc(config_temp->common.controller[i]);
 800a392: 68fb         	ldr	r3, [r7, #0xc]
 800a394: 69ba         	ldr	r2, [r7, #0x18]
 800a396: 3204         	adds	r2, #0x4
 800a398: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800a39c: 4618         	mov	r0, r3
 800a39e: f00c f8a4    	bl	0x80164ea <pid_calc>    @ imm = #0xc148
;         if (strcmp(config_temp->common.capabilities[i], "torque") == 0)
 800a3a2: 69ba         	ldr	r2, [r7, #0x18]
 800a3a4: 4613         	mov	r3, r2
 800a3a6: 005b         	lsls	r3, r3, #0x1
 800a3a8: 4413         	add	r3, r2
 800a3aa: 009b         	lsls	r3, r3, #0x2
 800a3ac: 3320         	adds	r3, #0x20
 800a3ae: 68fa         	ldr	r2, [r7, #0xc]
 800a3b0: 4413         	add	r3, r2
 800a3b2: 4916         	ldr	r1, [pc, #0x58]         @ 0x800a40c <motor_calc+0x218>
 800a3b4: 4618         	mov	r0, r3
 800a3b6: f7f6 fbb7    	bl	0x8000b28 <strcmp>      @ imm = #-0x9892
 800a3ba: 4603         	mov	r3, r0
 800a3bc: 2b00         	cmp	r3, #0x0
 800a3be: d102         	bne	0x800a3c6 <motor_calc+0x1d2> @ imm = #0x4
;             torque_proceeded = true;
 800a3c0: 2301         	movs	r3, #0x1
 800a3c2: 77fb         	strb	r3, [r7, #0x1f]
 800a3c4: e00e         	b	0x800a3e4 <motor_calc+0x1f0> @ imm = #0x1c
;         else if (strcmp(config_temp->common.capabilities[i], "mit") == 0)
 800a3c6: 69ba         	ldr	r2, [r7, #0x18]
 800a3c8: 4613         	mov	r3, r2
 800a3ca: 005b         	lsls	r3, r3, #0x1
 800a3cc: 4413         	add	r3, r2
 800a3ce: 009b         	lsls	r3, r3, #0x2
 800a3d0: 3320         	adds	r3, #0x20
 800a3d2: 68fa         	ldr	r2, [r7, #0xc]
 800a3d4: 4413         	add	r3, r2
 800a3d6: 490e         	ldr	r1, [pc, #0x38]         @ 0x800a410 <motor_calc+0x21c>
 800a3d8: 4618         	mov	r0, r3
 800a3da: f7f6 fba5    	bl	0x8000b28 <strcmp>      @ imm = #-0x98b6
 800a3de: 4603         	mov	r3, r0
 800a3e0: 2b00         	cmp	r3, #0x0
 800a3e2: d008         	beq	0x800a3f6 <motor_calc+0x202> @ imm = #0x10
;          i++) {
 800a3e4: 69bb         	ldr	r3, [r7, #0x18]
 800a3e6: 3301         	adds	r3, #0x1
 800a3e8: 61bb         	str	r3, [r7, #0x18]
;     for (int i = data_temp->current_mode_index; i < SIZE_OF_ARRAY(config_temp->common.controller);
 800a3ea: 69bb         	ldr	r3, [r7, #0x18]
 800a3ec: 2b03         	cmp	r3, #0x3
 800a3ee: d9a9         	bls	0x800a344 <motor_calc+0x150> @ imm = #-0xae
; }
 800a3f0: e002         	b	0x800a3f8 <motor_calc+0x204> @ imm = #0x4
;                 break;
 800a3f2: bf00         	nop
 800a3f4: e000         	b	0x800a3f8 <motor_calc+0x204> @ imm = #0x0
;             break;
 800a3f6: bf00         	nop
; }
 800a3f8: bf00         	nop
 800a3fa: 3724         	adds	r7, #0x24
 800a3fc: 46bd         	mov	sp, r7
 800a3fe: bd90         	pop	{r4, r7, pc}

0800a400 <$d>:
 800a400: 00 00 c8 42  	.word	0x42c80000
 800a404: 88 bb 01 08  	.word	0x0801bb88
 800a408: 00 00 b4 43  	.word	0x43b40000
 800a40c: f4 ab 01 08  	.word	0x0801abf4
 800a410: a8 ac 01 08  	.word	0x0801aca8

0800a414 <can_send_entry>:
; static void can_send_entry(struct motor_controller *ctrl_struct, void *arg2, void *arg3) {
 800a414: b590         	push	{r4, r7, lr}
 800a416: b09b         	sub	sp, #0x6c
 800a418: af04         	add	r7, sp, #0x10
 800a41a: 60f8         	str	r0, [r7, #0xc]
 800a41c: 60b9         	str	r1, [r7, #0x8]
 800a41e: 607a         	str	r2, [r7, #0x4]
;     k_sem_init(&tx_queue_sem, 24, 24); // 初始化信号量
 800a420: 2218         	movs	r2, #0x18
 800a422: 2118         	movs	r1, #0x18
 800a424: 4848         	ldr	r0, [pc, #0x120]        @ 0x800a548 <can_send_entry+0x134>
 800a426: f00b ff8f    	bl	0x8016348 <k_sem_init>  @ imm = #0xbf1e
;     k_sem_init(&(ctrl_struct[0].thread_sem), 0, 2);
 800a42a: 68fb         	ldr	r3, [r7, #0xc]
 800a42c: 3364         	adds	r3, #0x64
 800a42e: 2202         	movs	r2, #0x2
 800a430: 2100         	movs	r1, #0x0
 800a432: 4618         	mov	r0, r3
 800a434: f00b ff88    	bl	0x8016348 <k_sem_init>  @ imm = #0xbf10
;     struct device *can_dev = NULL;
 800a438: 2300         	movs	r3, #0x0
 800a43a: 637b         	str	r3, [r7, #0x34]
;     for (int i = 0; i < CAN_COUNT; i++) {
 800a43c: 2300         	movs	r3, #0x0
 800a43e: 64fb         	str	r3, [r7, #0x4c]
 800a440: e04a         	b	0x800a4d8 <can_send_entry+0xc4> @ imm = #0x94
;         can_dev = (struct device *)ctrl_struct[i].can_dev;
 800a442: 6cfb         	ldr	r3, [r7, #0x4c]
 800a444: 2274         	movs	r2, #0x74
 800a446: fb02 f303    	mul	r3, r2, r3
 800a44a: 68fa         	ldr	r2, [r7, #0xc]
 800a44c: 4413         	add	r3, r2
 800a44e: 681b         	ldr	r3, [r3]
 800a450: 637b         	str	r3, [r7, #0x34]
;         can_start(can_dev);
 800a452: 6b78         	ldr	r0, [r7, #0x34]
 800a454: f00b ffd1    	bl	0x80163fa <can_start>   @ imm = #0xbfa2
;         if (i != 0) {
 800a458: 6cfb         	ldr	r3, [r7, #0x4c]
 800a45a: 2b00         	cmp	r3, #0x0
 800a45c: d00c         	beq	0x800a478 <can_send_entry+0x64> @ imm = #0x18
;             ctrl_struct[i].thread_sem = ctrl_struct[0].thread_sem;
 800a45e: 6cfb         	ldr	r3, [r7, #0x4c]
 800a460: 2274         	movs	r2, #0x74
 800a462: fb02 f303    	mul	r3, r2, r3
 800a466: 68fa         	ldr	r2, [r7, #0xc]
 800a468: 441a         	add	r2, r3
 800a46a: 68fb         	ldr	r3, [r7, #0xc]
 800a46c: f102 0464    	add.w	r4, r2, #0x64
 800a470: 3364         	adds	r3, #0x64
 800a472: cb0f         	ldm	r3, {r0, r1, r2, r3}
 800a474: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
;         int err = can_add_rx_filter(can_dev, can_rx_callback, &ctrl_struct[i], &filter20x);
 800a478: 6cfb         	ldr	r3, [r7, #0x4c]
 800a47a: 2274         	movs	r2, #0x74
 800a47c: fb02 f303    	mul	r3, r2, r3
 800a480: 68fa         	ldr	r2, [r7, #0xc]
 800a482: 441a         	add	r2, r3
 800a484: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800a54c <can_send_entry+0x138>
 800a486: 4932         	ldr	r1, [pc, #0xc8]         @ 0x800a550 <can_send_entry+0x13c>
 800a488: 6b78         	ldr	r0, [r7, #0x34]
 800a48a: f7f9 ff93    	bl	0x80043b4 <can_add_rx_filter> @ imm = #-0x60da
 800a48e: 6278         	str	r0, [r7, #0x24]
;         if (err != 0)
 800a490: 6a7b         	ldr	r3, [r7, #0x24]
 800a492: 2b00         	cmp	r3, #0x0
 800a494: d01d         	beq	0x800a4d2 <can_send_entry+0xbe> @ imm = #0x3a
;             LOG_ERR("Error adding CAN filter (err %d)", err);
 800a496: 2304         	movs	r3, #0x4
 800a498: 2b00         	cmp	r3, #0x0
 800a49a: d01a         	beq	0x800a4d2 <can_send_entry+0xbe> @ imm = #0x34
 800a49c: 2301         	movs	r3, #0x1
 800a49e: f887 3023    	strb.w	r3, [r7, #0x23]
 800a4a2: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800a4a6: f083 0301    	eor	r3, r3, #0x1
 800a4aa: b2db         	uxtb	r3, r3
 800a4ac: 2b00         	cmp	r3, #0x0
 800a4ae: d110         	bne	0x800a4d2 <can_send_entry+0xbe> @ imm = #0x20
 800a4b0: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800a554 <can_send_entry+0x140>
 800a4b2: 6819         	ldr	r1, [r3]
 800a4b4: 6a7b         	ldr	r3, [r7, #0x24]
 800a4b6: 9303         	str	r3, [sp, #0xc]
 800a4b8: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800a558 <can_send_entry+0x144>
 800a4ba: 9302         	str	r3, [sp, #0x8]
 800a4bc: 2300         	movs	r3, #0x0
 800a4be: 9301         	str	r3, [sp, #0x4]
 800a4c0: 2300         	movs	r3, #0x0
 800a4c2: 9300         	str	r3, [sp]
 800a4c4: 2300         	movs	r3, #0x0
 800a4c6: 2201         	movs	r2, #0x1
 800a4c8: 2000         	movs	r0, #0x0
 800a4ca: f00b ff68    	bl	0x801639e <z_log_msg_runtime_create> @ imm = #0xbed0
 800a4ce: 2300         	movs	r3, #0x0
 800a4d0: 61fb         	str	r3, [r7, #0x1c]
;     for (int i = 0; i < CAN_COUNT; i++) {
 800a4d2: 6cfb         	ldr	r3, [r7, #0x4c]
 800a4d4: 3301         	adds	r3, #0x1
 800a4d6: 64fb         	str	r3, [r7, #0x4c]
 800a4d8: 6cfb         	ldr	r3, [r7, #0x4c]
 800a4da: 2b01         	cmp	r3, #0x1
 800a4dc: ddb1         	ble	0x800a442 <can_send_entry+0x2e> @ imm = #-0x9e
;     int err = 0;
 800a4de: 2300         	movs	r3, #0x0
 800a4e0: 64bb         	str	r3, [r7, #0x48]
;     k_sleep(K_MSEC(60));
 800a4e2: f44f 7216    	mov.w	r2, #0x258
 800a4e6: f04f 0300    	mov.w	r3, #0x0
 800a4ea: 4610         	mov	r0, r2
 800a4ec: 4619         	mov	r1, r3
 800a4ee: f00b ff12    	bl	0x8016316 <k_sleep>     @ imm = #0xbe24
;         for (int8_t i = 0; i < CAN_COUNT; i++) {
 800a4f2: 2300         	movs	r3, #0x0
 800a4f4: f887 3057    	strb.w	r3, [r7, #0x57]
 800a4f8: e140         	b	0x800a77c <can_send_entry+0x368> @ imm = #0x280
;             for (int j = 0; j < 5; j++) {
 800a4fa: 2300         	movs	r3, #0x0
 800a4fc: 653b         	str	r3, [r7, #0x50]
 800a4fe: e132         	b	0x800a766 <can_send_entry+0x352> @ imm = #0x264
;                 if (ctrl_struct[i].full[j] == 1) {
 800a500: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 800a504: 2274         	movs	r2, #0x74
 800a506: fb02 f303    	mul	r3, r2, r3
 800a50a: 68fa         	ldr	r2, [r7, #0xc]
 800a50c: 441a         	add	r2, r3
 800a50e: 6d3b         	ldr	r3, [r7, #0x50]
 800a510: 4413         	add	r3, r2
 800a512: 3324         	adds	r3, #0x24
 800a514: 781b         	ldrb	r3, [r3]
 800a516: 2b00         	cmp	r3, #0x0
 800a518: f000 8122    	beq.w	0x800a760 <can_send_entry+0x34c> @ imm = #0x244
;                     uint8_t id_temp = ctrl_struct[i].mapping[0][0];
 800a51c: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 800a520: 2274         	movs	r2, #0x74
 800a522: fb02 f303    	mul	r3, r2, r3
 800a526: 68fa         	ldr	r2, [r7, #0xc]
 800a528: 4413         	add	r3, r2
 800a52a: f893 3029    	ldrb.w	r3, [r3, #0x29]
 800a52e: f887 302f    	strb.w	r3, [r7, #0x2f]
;                     uint8_t data[8] = {0};
 800a532: 2300         	movs	r3, #0x0
 800a534: 617b         	str	r3, [r7, #0x14]
 800a536: 2300         	movs	r3, #0x0
 800a538: 61bb         	str	r3, [r7, #0x18]
;                     bool    packed  = false;
 800a53a: 2300         	movs	r3, #0x0
 800a53c: f887 3047    	strb.w	r3, [r7, #0x47]
;                     for (int k = 0; k < 4; k++) {
 800a540: 2300         	movs	r3, #0x0
 800a542: 643b         	str	r3, [r7, #0x40]
 800a544: e076         	b	0x800a634 <can_send_entry+0x220> @ imm = #0xec
 800a546: bf00         	nop

0800a548 <$d>:
 800a548: 2c 0f 00 20  	.word	0x20000f2c
 800a54c: ec bb 01 08  	.word	0x0801bbec
 800a550: a9 9d 00 08  	.word	0x08009da9
 800a554: 28 03 00 20  	.word	0x20000328
 800a558: ac ac 01 08  	.word	0x0801acac

0800a55c <$t>:
;                         id_temp = ctrl_struct[i].mapping[j][k];
 800a55c: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 800a560: 2274         	movs	r2, #0x74
 800a562: fb02 f303    	mul	r3, r2, r3
 800a566: 68fa         	ldr	r2, [r7, #0xc]
 800a568: 441a         	add	r2, r3
 800a56a: 6d3b         	ldr	r3, [r7, #0x50]
 800a56c: 009b         	lsls	r3, r3, #0x2
 800a56e: 441a         	add	r2, r3
 800a570: 6c3b         	ldr	r3, [r7, #0x40]
 800a572: 4413         	add	r3, r2
 800a574: 3329         	adds	r3, #0x29
 800a576: 781b         	ldrb	r3, [r3]
 800a578: f887 302f    	strb.w	r3, [r7, #0x2f]
;                         if (id_temp < 8 && (ctrl_struct[i].flags & (1 << id_temp))) {
 800a57c: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800a580: 2b07         	cmp	r3, #0x7
 800a582: d854         	bhi	0x800a62e <can_send_entry+0x21a> @ imm = #0xa8
 800a584: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 800a588: 2274         	movs	r2, #0x74
 800a58a: fb02 f303    	mul	r3, r2, r3
 800a58e: 68fa         	ldr	r2, [r7, #0xc]
 800a590: 4413         	add	r3, r2
 800a592: f893 303d    	ldrb.w	r3, [r3, #0x3d]
 800a596: 461a         	mov	r2, r3
 800a598: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800a59c: fa42 f303    	asr.w	r3, r2, r3
 800a5a0: f003 0301    	and	r3, r3, #0x1
 800a5a4: 2b00         	cmp	r3, #0x0
 800a5a6: d042         	beq	0x800a62e <can_send_entry+0x21a> @ imm = #0x84
;                             motor_calc(ctrl_struct[i].motor_devs[id_temp]);
 800a5a8: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 800a5ac: 2274         	movs	r2, #0x74
 800a5ae: fb02 f303    	mul	r3, r2, r3
 800a5b2: 68fa         	ldr	r2, [r7, #0xc]
 800a5b4: 441a         	add	r2, r3
 800a5b6: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800a5ba: 3310         	adds	r3, #0x10
 800a5bc: 009b         	lsls	r3, r3, #0x2
 800a5be: 4413         	add	r3, r2
 800a5c0: 685b         	ldr	r3, [r3, #0x4]
 800a5c2: 4618         	mov	r0, r3
 800a5c4: f7ff fe16    	bl	0x800a1f4 <motor_calc>  @ imm = #-0x3d4
;                             can_pack_add(data, ctrl_struct[i].motor_devs[id_temp], k);
 800a5c8: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 800a5cc: 2274         	movs	r2, #0x74
 800a5ce: fb02 f303    	mul	r3, r2, r3
 800a5d2: 68fa         	ldr	r2, [r7, #0xc]
 800a5d4: 441a         	add	r2, r3
 800a5d6: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800a5da: 3310         	adds	r3, #0x10
 800a5dc: 009b         	lsls	r3, r3, #0x2
 800a5de: 4413         	add	r3, r2
 800a5e0: 6859         	ldr	r1, [r3, #0x4]
 800a5e2: 6c3b         	ldr	r3, [r7, #0x40]
 800a5e4: b2da         	uxtb	r2, r3
 800a5e6: f107 0314    	add.w	r3, r7, #0x14
 800a5ea: 4618         	mov	r0, r3
 800a5ec: f00c f88f    	bl	0x801670e <can_pack_add> @ imm = #0xc11e
;                             ctrl_struct[i].flags ^= 1 << id_temp;
 800a5f0: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 800a5f4: 2274         	movs	r2, #0x74
 800a5f6: fb02 f303    	mul	r3, r2, r3
 800a5fa: 68fa         	ldr	r2, [r7, #0xc]
 800a5fc: 4413         	add	r3, r2
 800a5fe: f893 303d    	ldrb.w	r3, [r3, #0x3d]
 800a602: b25a         	sxtb	r2, r3
 800a604: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800a608: 2101         	movs	r1, #0x1
 800a60a: fa01 f303    	lsl.w	r3, r1, r3
 800a60e: b25b         	sxtb	r3, r3
 800a610: 4053         	eors	r3, r2
 800a612: b259         	sxtb	r1, r3
 800a614: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 800a618: 2274         	movs	r2, #0x74
 800a61a: fb02 f303    	mul	r3, r2, r3
 800a61e: 68fa         	ldr	r2, [r7, #0xc]
 800a620: 4413         	add	r3, r2
 800a622: b2ca         	uxtb	r2, r1
 800a624: f883 203d    	strb.w	r2, [r3, #0x3d]
;                             packed = true;
 800a628: 2301         	movs	r3, #0x1
 800a62a: f887 3047    	strb.w	r3, [r7, #0x47]
;                     for (int k = 0; k < 4; k++) {
 800a62e: 6c3b         	ldr	r3, [r7, #0x40]
 800a630: 3301         	adds	r3, #0x1
 800a632: 643b         	str	r3, [r7, #0x40]
 800a634: 6c3b         	ldr	r3, [r7, #0x40]
 800a636: 2b03         	cmp	r3, #0x3
 800a638: dd90         	ble	0x800a55c <can_send_entry+0x148> @ imm = #-0xe0
;                     if (packed) {
 800a63a: f897 3047    	ldrb.w	r3, [r7, #0x47]
 800a63e: 2b00         	cmp	r3, #0x0
 800a640: f000 808e    	beq.w	0x800a760 <can_send_entry+0x34c> @ imm = #0x11c
;                         txframe[i][j].id    = txframe_id(j);
 800a644: 6d38         	ldr	r0, [r7, #0x50]
 800a646: f00b ffb2    	bl	0x80165ae <txframe_id>  @ imm = #0xbf64
 800a64a: 4603         	mov	r3, r0
 800a64c: f997 2057    	ldrsb.w	r2, [r7, #0x57]
 800a650: 4618         	mov	r0, r3
 800a652: 496e         	ldr	r1, [pc, #0x1b8]        @ 0x800a80c <can_send_entry+0x3f8>
 800a654: 4613         	mov	r3, r2
 800a656: 009b         	lsls	r3, r3, #0x2
 800a658: 4413         	add	r3, r2
 800a65a: 6d3a         	ldr	r2, [r7, #0x50]
 800a65c: 4413         	add	r3, r2
 800a65e: 011b         	lsls	r3, r3, #0x4
 800a660: 440b         	add	r3, r1
 800a662: 6018         	str	r0, [r3]
;                         txframe[i][j].dlc   = 8;
 800a664: f997 2057    	ldrsb.w	r2, [r7, #0x57]
 800a668: 4968         	ldr	r1, [pc, #0x1a0]        @ 0x800a80c <can_send_entry+0x3f8>
 800a66a: 4613         	mov	r3, r2
 800a66c: 009b         	lsls	r3, r3, #0x2
 800a66e: 4413         	add	r3, r2
 800a670: 6d3a         	ldr	r2, [r7, #0x50]
 800a672: 4413         	add	r3, r2
 800a674: 011b         	lsls	r3, r3, #0x4
 800a676: 440b         	add	r3, r1
 800a678: 3304         	adds	r3, #0x4
 800a67a: 2208         	movs	r2, #0x8
 800a67c: 701a         	strb	r2, [r3]
;                         txframe[i][j].flags = 0;
 800a67e: f997 2057    	ldrsb.w	r2, [r7, #0x57]
 800a682: 4962         	ldr	r1, [pc, #0x188]        @ 0x800a80c <can_send_entry+0x3f8>
 800a684: 4613         	mov	r3, r2
 800a686: 009b         	lsls	r3, r3, #0x2
 800a688: 4413         	add	r3, r2
 800a68a: 6d3a         	ldr	r2, [r7, #0x50]
 800a68c: 4413         	add	r3, r2
 800a68e: 011b         	lsls	r3, r3, #0x4
 800a690: 440b         	add	r3, r1
 800a692: 3305         	adds	r3, #0x5
 800a694: 2200         	movs	r2, #0x0
 800a696: 701a         	strb	r2, [r3]
;                         memcpy(txframe[i][j].data, data, sizeof(data));
 800a698: f997 2057    	ldrsb.w	r2, [r7, #0x57]
 800a69c: 4613         	mov	r3, r2
 800a69e: 009b         	lsls	r3, r3, #0x2
 800a6a0: 4413         	add	r3, r2
 800a6a2: 6d3a         	ldr	r2, [r7, #0x50]
 800a6a4: 4413         	add	r3, r2
 800a6a6: 011b         	lsls	r3, r3, #0x4
 800a6a8: 3308         	adds	r3, #0x8
 800a6aa: 4a58         	ldr	r2, [pc, #0x160]        @ 0x800a80c <can_send_entry+0x3f8>
 800a6ac: 4413         	add	r3, r2
 800a6ae: 461a         	mov	r2, r3
 800a6b0: f107 0314    	add.w	r3, r7, #0x14
 800a6b4: cb03         	ldm	r3!, {r0, r1}
 800a6b6: 6010         	str	r0, [r2]
 800a6b8: 6051         	str	r1, [r2, #0x4]
;                         can_dev = (struct device *)ctrl_struct[i].can_dev;
 800a6ba: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 800a6be: 2274         	movs	r2, #0x74
 800a6c0: fb02 f303    	mul	r3, r2, r3
 800a6c4: 68fa         	ldr	r2, [r7, #0xc]
 800a6c6: 4413         	add	r3, r2
 800a6c8: 681b         	ldr	r3, [r3]
 800a6ca: 637b         	str	r3, [r7, #0x34]
;                         err     = k_sem_take(&tx_queue_sem, K_NO_WAIT);
 800a6cc: f04f 0200    	mov.w	r2, #0x0
 800a6d0: f04f 0300    	mov.w	r3, #0x0
 800a6d4: 484e         	ldr	r0, [pc, #0x138]        @ 0x800a810 <can_send_entry+0x3fc>
 800a6d6: f00b fe47    	bl	0x8016368 <k_sem_take>  @ imm = #0xbc8e
 800a6da: 64b8         	str	r0, [r7, #0x48]
;                         if (err == 0)
 800a6dc: 6cbb         	ldr	r3, [r7, #0x48]
 800a6de: 2b00         	cmp	r3, #0x0
 800a6e0: d115         	bne	0x800a70e <can_send_entry+0x2fa> @ imm = #0x2a
;                             err = can_send(can_dev, &txframe[i][j], K_NO_WAIT, can_tx_callback,
 800a6e2: f997 2057    	ldrsb.w	r2, [r7, #0x57]
 800a6e6: 4613         	mov	r3, r2
 800a6e8: 009b         	lsls	r3, r3, #0x2
 800a6ea: 4413         	add	r3, r2
 800a6ec: 6d3a         	ldr	r2, [r7, #0x50]
 800a6ee: 4413         	add	r3, r2
 800a6f0: 011b         	lsls	r3, r3, #0x4
 800a6f2: 4a46         	ldr	r2, [pc, #0x118]        @ 0x800a80c <can_send_entry+0x3f8>
 800a6f4: 1899         	adds	r1, r3, r2
 800a6f6: f04f 0200    	mov.w	r2, #0x0
 800a6fa: f04f 0300    	mov.w	r3, #0x0
 800a6fe: 4844         	ldr	r0, [pc, #0x110]        @ 0x800a810 <can_send_entry+0x3fc>
 800a700: 9001         	str	r0, [sp, #0x4]
 800a702: 4844         	ldr	r0, [pc, #0x110]        @ 0x800a814 <can_send_entry+0x400>
 800a704: 9000         	str	r0, [sp]
 800a706: 6b78         	ldr	r0, [r7, #0x34]
 800a708: f00b fe83    	bl	0x8016412 <can_send>    @ imm = #0xbd06
 800a70c: 64b8         	str	r0, [r7, #0x48]
;                         if (err != 0 && err != -EAGAIN && err != -EBUSY)
 800a70e: 6cbb         	ldr	r3, [r7, #0x48]
 800a710: 2b00         	cmp	r3, #0x0
 800a712: d025         	beq	0x800a760 <can_send_entry+0x34c> @ imm = #0x4a
 800a714: 6cbb         	ldr	r3, [r7, #0x48]
 800a716: f113 0f0b    	cmn.w	r3, #0xb
 800a71a: d021         	beq	0x800a760 <can_send_entry+0x34c> @ imm = #0x42
 800a71c: 6cbb         	ldr	r3, [r7, #0x48]
 800a71e: f113 0f10    	cmn.w	r3, #0x10
 800a722: d01d         	beq	0x800a760 <can_send_entry+0x34c> @ imm = #0x3a
;                             LOG_ERR("Error sending CAN frame (err %d)", err);
 800a724: 2304         	movs	r3, #0x4
 800a726: 2b00         	cmp	r3, #0x0
 800a728: d01a         	beq	0x800a760 <can_send_entry+0x34c> @ imm = #0x34
 800a72a: 2301         	movs	r3, #0x1
 800a72c: f887 302e    	strb.w	r3, [r7, #0x2e]
 800a730: f897 302e    	ldrb.w	r3, [r7, #0x2e]
 800a734: f083 0301    	eor	r3, r3, #0x1
 800a738: b2db         	uxtb	r3, r3
 800a73a: 2b00         	cmp	r3, #0x0
 800a73c: d110         	bne	0x800a760 <can_send_entry+0x34c> @ imm = #0x20
 800a73e: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800a818 <can_send_entry+0x404>
 800a740: 6819         	ldr	r1, [r3]
 800a742: 6cbb         	ldr	r3, [r7, #0x48]
 800a744: 9303         	str	r3, [sp, #0xc]
 800a746: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800a81c <can_send_entry+0x408>
 800a748: 9302         	str	r3, [sp, #0x8]
 800a74a: 2300         	movs	r3, #0x0
 800a74c: 9301         	str	r3, [sp, #0x4]
 800a74e: 2300         	movs	r3, #0x0
 800a750: 9300         	str	r3, [sp]
 800a752: 2300         	movs	r3, #0x0
 800a754: 2201         	movs	r2, #0x1
 800a756: 2000         	movs	r0, #0x0
 800a758: f00b fe21    	bl	0x801639e <z_log_msg_runtime_create> @ imm = #0xbc42
 800a75c: 2300         	movs	r3, #0x0
 800a75e: 62bb         	str	r3, [r7, #0x28]
;             for (int j = 0; j < 5; j++) {
 800a760: 6d3b         	ldr	r3, [r7, #0x50]
 800a762: 3301         	adds	r3, #0x1
 800a764: 653b         	str	r3, [r7, #0x50]
 800a766: 6d3b         	ldr	r3, [r7, #0x50]
 800a768: 2b04         	cmp	r3, #0x4
 800a76a: f77f aec9    	ble.w	0x800a500 <can_send_entry+0xec> @ imm = #-0x26e
;         for (int8_t i = 0; i < CAN_COUNT; i++) {
 800a76e: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 800a772: b2db         	uxtb	r3, r3
 800a774: 3301         	adds	r3, #0x1
 800a776: b2db         	uxtb	r3, r3
 800a778: f887 3057    	strb.w	r3, [r7, #0x57]
 800a77c: f997 3057    	ldrsb.w	r3, [r7, #0x57]
 800a780: 2b01         	cmp	r3, #0x1
 800a782: f77f aeba    	ble.w	0x800a4fa <can_send_entry+0xe6> @ imm = #-0x28c
;         k_sem_take(&(ctrl_struct[0].thread_sem), K_MSEC(2));
 800a786: 68fb         	ldr	r3, [r7, #0xc]
 800a788: f103 0164    	add.w	r1, r3, #0x64
 800a78c: f04f 0214    	mov.w	r2, #0x14
 800a790: f04f 0300    	mov.w	r3, #0x0
 800a794: 4608         	mov	r0, r1
 800a796: f00b fde7    	bl	0x8016368 <k_sem_take>  @ imm = #0xbbce
;         int curr_time = k_cycle_get_32();
 800a79a: f00b fdb5    	bl	0x8016308 <k_cycle_get_32> @ imm = #0xbb6a
 800a79e: 4603         	mov	r3, r0
 800a7a0: 633b         	str	r3, [r7, #0x30]
;         for (int i = 0; i < 2; i++) {
 800a7a2: 2300         	movs	r3, #0x0
 800a7a4: 63fb         	str	r3, [r7, #0x3c]
 800a7a6: e02d         	b	0x800a804 <can_send_entry+0x3f0> @ imm = #0x5a
;             for (int j = 0; j < 8; j++) {
 800a7a8: 2300         	movs	r3, #0x0
 800a7aa: 63bb         	str	r3, [r7, #0x38]
 800a7ac: e024         	b	0x800a7f8 <can_send_entry+0x3e4> @ imm = #0x48
;                 if (ctrl_struct[i].motor_devs[j]) {
 800a7ae: 6bfb         	ldr	r3, [r7, #0x3c]
 800a7b0: 2274         	movs	r2, #0x74
 800a7b2: fb02 f303    	mul	r3, r2, r3
 800a7b6: 68fa         	ldr	r2, [r7, #0xc]
 800a7b8: 441a         	add	r2, r3
 800a7ba: 6bbb         	ldr	r3, [r7, #0x38]
 800a7bc: 3310         	adds	r3, #0x10
 800a7be: 009b         	lsls	r3, r3, #0x2
 800a7c0: 4413         	add	r3, r2
 800a7c2: 685b         	ldr	r3, [r3, #0x4]
 800a7c4: 2b00         	cmp	r3, #0x0
 800a7c6: d014         	beq	0x800a7f2 <can_send_entry+0x3de> @ imm = #0x28
;                     dji_timeout_handle(ctrl_struct[i].motor_devs[i], curr_time, &ctrl_struct[i]);
 800a7c8: 6bfb         	ldr	r3, [r7, #0x3c]
 800a7ca: 2274         	movs	r2, #0x74
 800a7cc: fb02 f303    	mul	r3, r2, r3
 800a7d0: 68fa         	ldr	r2, [r7, #0xc]
 800a7d2: 441a         	add	r2, r3
 800a7d4: 6bfb         	ldr	r3, [r7, #0x3c]
 800a7d6: 3310         	adds	r3, #0x10
 800a7d8: 009b         	lsls	r3, r3, #0x2
 800a7da: 4413         	add	r3, r2
 800a7dc: 6858         	ldr	r0, [r3, #0x4]
 800a7de: 6b39         	ldr	r1, [r7, #0x30]
 800a7e0: 6bfb         	ldr	r3, [r7, #0x3c]
 800a7e2: 2274         	movs	r2, #0x74
 800a7e4: fb02 f303    	mul	r3, r2, r3
 800a7e8: 68fa         	ldr	r2, [r7, #0xc]
 800a7ea: 4413         	add	r3, r2
 800a7ec: 461a         	mov	r2, r3
 800a7ee: f7ff fc57    	bl	0x800a0a0 <dji_timeout_handle> @ imm = #-0x752
;             for (int j = 0; j < 8; j++) {
 800a7f2: 6bbb         	ldr	r3, [r7, #0x38]
 800a7f4: 3301         	adds	r3, #0x1
 800a7f6: 63bb         	str	r3, [r7, #0x38]
 800a7f8: 6bbb         	ldr	r3, [r7, #0x38]
 800a7fa: 2b07         	cmp	r3, #0x7
 800a7fc: ddd7         	ble	0x800a7ae <can_send_entry+0x39a> @ imm = #-0x52
;         for (int i = 0; i < 2; i++) {
 800a7fe: 6bfb         	ldr	r3, [r7, #0x3c]
 800a800: 3301         	adds	r3, #0x1
 800a802: 63fb         	str	r3, [r7, #0x3c]
 800a804: 6bfb         	ldr	r3, [r7, #0x3c]
 800a806: 2b01         	cmp	r3, #0x1
 800a808: ddce         	ble	0x800a7a8 <can_send_entry+0x394> @ imm = #-0x64
;     while (1) {
 800a80a: e672         	b	0x800a4f2 <can_send_entry+0xde> @ imm = #-0x31c

0800a80c <$d>:
 800a80c: 3c 0f 00 20  	.word	0x20000f3c
 800a810: 2c 0f 00 20  	.word	0x20000f2c
 800a814: 9b 66 01 08  	.word	0x0801669b
 800a818: 28 03 00 20  	.word	0x20000328
 800a81c: d0 ac 01 08  	.word	0x0801acd0

0800a820 <float_equal>:
; static bool float_equal(float a, float b) { return fabsf(a - b) < 0.0001f; }
 800a820: b590         	push	{r4, r7, lr}
 800a822: b083         	sub	sp, #0xc
 800a824: af00         	add	r7, sp, #0x0
 800a826: 6078         	str	r0, [r7, #0x4]
 800a828: 6039         	str	r1, [r7]
 800a82a: 6839         	ldr	r1, [r7]
 800a82c: 6878         	ldr	r0, [r7, #0x4]
 800a82e: f7f5 fe6b    	bl	0x8000508 <__subsf3>    @ imm = #-0xa32a
 800a832: 4603         	mov	r3, r0
 800a834: f023 4300    	bic	r3, r3, #0x80000000
 800a838: 2201         	movs	r2, #0x1
 800a83a: 4614         	mov	r4, r2
 800a83c: 4906         	ldr	r1, [pc, #0x18]         @ 0x800a858 <float_equal+0x38>
 800a83e: 4618         	mov	r0, r3
 800a840: f7f6 f90a    	bl	0x8000a58 <__aeabi_fcmplt> @ imm = #-0x9dec
 800a844: 4603         	mov	r3, r0
 800a846: 2b00         	cmp	r3, #0x0
 800a848: d101         	bne	0x800a84e <float_equal+0x2e> @ imm = #0x2
 800a84a: 2300         	movs	r3, #0x0
 800a84c: 461c         	mov	r4, r3
 800a84e: b2e3         	uxtb	r3, r4
 800a850: 4618         	mov	r0, r3
 800a852: 370c         	adds	r7, #0xc
 800a854: 46bd         	mov	sp, r7
 800a856: bd90         	pop	{r4, r7, pc}

0800a858 <$d>:
 800a858: 17 b7 d1 38  	.word	0x38d1b717

0800a85c <single_pid_calc>:
; static void single_pid_calc(const struct device *pid_dev) {
 800a85c: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800a860: b08a         	sub	sp, #0x28
 800a862: af00         	add	r7, sp, #0x0
 800a864: 6078         	str	r0, [r7, #0x4]
;     const struct pid_single_config *pid_para = pid_dev->config;
 800a866: 687b         	ldr	r3, [r7, #0x4]
 800a868: 685b         	ldr	r3, [r3, #0x4]
 800a86a: 627b         	str	r3, [r7, #0x24]
;     struct pid_single_data         *pid_data = pid_dev->data;
 800a86c: 687b         	ldr	r3, [r7, #0x4]
 800a86e: 691b         	ldr	r3, [r3, #0x10]
 800a870: 623b         	str	r3, [r7, #0x20]
;     if (pid_data->curr == NULL) {
 800a872: 6a3b         	ldr	r3, [r7, #0x20]
 800a874: 685b         	ldr	r3, [r3, #0x4]
 800a876: 2b00         	cmp	r3, #0x0
 800a878: f000 80a4    	beq.w	0x800a9c4 <single_pid_calc+0x168> @ imm = #0x148
;     float kp     = pid_para->k_p;
 800a87c: 6a7b         	ldr	r3, [r7, #0x24]
 800a87e: 681b         	ldr	r3, [r3]
 800a880: 61fb         	str	r3, [r7, #0x1c]
;     float ki     = pid_para->k_i;
 800a882: 6a7b         	ldr	r3, [r7, #0x24]
 800a884: 685b         	ldr	r3, [r3, #0x4]
 800a886: 61bb         	str	r3, [r7, #0x18]
;     float kd     = pid_para->k_d;
 800a888: 6a7b         	ldr	r3, [r7, #0x24]
 800a88a: 689b         	ldr	r3, [r3, #0x8]
 800a88c: 617b         	str	r3, [r7, #0x14]
;     float err    = *(pid_data->ref) - *(pid_data->curr);
 800a88e: 6a3b         	ldr	r3, [r7, #0x20]
 800a890: 681b         	ldr	r3, [r3]
 800a892: 681a         	ldr	r2, [r3]
 800a894: 6a3b         	ldr	r3, [r7, #0x20]
 800a896: 685b         	ldr	r3, [r3, #0x4]
 800a898: 681b         	ldr	r3, [r3]
 800a89a: 4619         	mov	r1, r3
 800a89c: 4610         	mov	r0, r2
 800a89e: f7f5 fe33    	bl	0x8000508 <__subsf3>    @ imm = #-0xa39a
 800a8a2: 4603         	mov	r3, r0
 800a8a4: 613b         	str	r3, [r7, #0x10]
;     float deltaT = k_cyc_to_us_near32(*(pid_data->curr_time) - *(pid_data->prev_time));
 800a8a6: 6a3b         	ldr	r3, [r7, #0x20]
 800a8a8: 695b         	ldr	r3, [r3, #0x14]
 800a8aa: 681a         	ldr	r2, [r3]
 800a8ac: 6a3b         	ldr	r3, [r7, #0x20]
 800a8ae: 699b         	ldr	r3, [r3, #0x18]
 800a8b0: 681b         	ldr	r3, [r3]
 800a8b2: 1ad3         	subs	r3, r2, r3
 800a8b4: 2b00         	cmp	r3, #0x0
 800a8b6: db11         	blt	0x800a8dc <single_pid_calc+0x80> @ imm = #0x22
 800a8b8: 6a3b         	ldr	r3, [r7, #0x20]
 800a8ba: 695b         	ldr	r3, [r3, #0x14]
 800a8bc: 681a         	ldr	r2, [r3]
 800a8be: 6a3b         	ldr	r3, [r7, #0x20]
 800a8c0: 699b         	ldr	r3, [r3, #0x18]
 800a8c2: 681b         	ldr	r3, [r3]
 800a8c4: 1ad3         	subs	r3, r2, r3
 800a8c6: 3354         	adds	r3, #0x54
 800a8c8: 08db         	lsrs	r3, r3, #0x3
 800a8ca: 4a41         	ldr	r2, [pc, #0x104]        @ 0x800a9d0 <single_pid_calc+0x174>
 800a8cc: fba2 2303    	umull	r2, r3, r2, r3
 800a8d0: 085b         	lsrs	r3, r3, #0x1
 800a8d2: 4618         	mov	r0, r3
 800a8d4: f7f5 feca    	bl	0x800066c <__floatunsisf> @ imm = #-0xa26c
 800a8d8: 4603         	mov	r3, r0
 800a8da: e01c         	b	0x800a916 <single_pid_calc+0xba> @ imm = #0x38
 800a8dc: 6a3b         	ldr	r3, [r7, #0x20]
 800a8de: 695b         	ldr	r3, [r3, #0x14]
 800a8e0: 681a         	ldr	r2, [r3]
 800a8e2: 6a3b         	ldr	r3, [r7, #0x20]
 800a8e4: 699b         	ldr	r3, [r3, #0x18]
 800a8e6: 681b         	ldr	r3, [r3]
 800a8e8: 1ad3         	subs	r3, r2, r3
 800a8ea: 17da         	asrs	r2, r3, #0x1f
 800a8ec: 461c         	mov	r4, r3
 800a8ee: 4615         	mov	r5, r2
 800a8f0: f114 0854    	adds.w	r8, r4, #0x54
 800a8f4: f145 0900    	adc	r9, r5, #0x0
 800a8f8: f04f 02a8    	mov.w	r2, #0xa8
 800a8fc: f04f 0300    	mov.w	r3, #0x0
 800a900: 4640         	mov	r0, r8
 800a902: 4649         	mov	r1, r9
 800a904: f7f6 f8f6    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x9e14
 800a908: 4602         	mov	r2, r0
 800a90a: 460b         	mov	r3, r1
 800a90c: 4613         	mov	r3, r2
 800a90e: 4618         	mov	r0, r3
 800a910: f7f5 feac    	bl	0x800066c <__floatunsisf> @ imm = #-0xa2a8
 800a914: 4603         	mov	r3, r0
 800a916: 60fb         	str	r3, [r7, #0xc]
;     if (!float_equal(ki, 0))
 800a918: f04f 0100    	mov.w	r1, #0x0
 800a91c: 69b8         	ldr	r0, [r7, #0x18]
 800a91e: f7ff ff7f    	bl	0x800a820 <float_equal> @ imm = #-0x102
 800a922: 4603         	mov	r3, r0
 800a924: f083 0301    	eor	r3, r3, #0x1
 800a928: b2db         	uxtb	r3, r3
 800a92a: 2b00         	cmp	r3, #0x0
 800a92c: d019         	beq	0x800a962 <single_pid_calc+0x106> @ imm = #0x32
;         pid_data->err_integral += (err * deltaT) / (1000000 * ki);
 800a92e: 6a3b         	ldr	r3, [r7, #0x20]
 800a930: 689c         	ldr	r4, [r3, #0x8]
 800a932: 68f9         	ldr	r1, [r7, #0xc]
 800a934: 6938         	ldr	r0, [r7, #0x10]
 800a936: f7f5 fef1    	bl	0x800071c <__mulsf3>    @ imm = #-0xa21e
 800a93a: 4603         	mov	r3, r0
 800a93c: 461d         	mov	r5, r3
 800a93e: 4925         	ldr	r1, [pc, #0x94]         @ 0x800a9d4 <single_pid_calc+0x178>
 800a940: 69b8         	ldr	r0, [r7, #0x18]
 800a942: f7f5 feeb    	bl	0x800071c <__mulsf3>    @ imm = #-0xa22a
 800a946: 4603         	mov	r3, r0
 800a948: 4619         	mov	r1, r3
 800a94a: 4628         	mov	r0, r5
 800a94c: f7f5 ff9a    	bl	0x8000884 <__divsf3>    @ imm = #-0xa0cc
 800a950: 4603         	mov	r3, r0
 800a952: 4619         	mov	r1, r3
 800a954: 4620         	mov	r0, r4
 800a956: f7f5 fdd9    	bl	0x800050c <__aeabi_fadd> @ imm = #-0xa44e
 800a95a: 4603         	mov	r3, r0
 800a95c: 461a         	mov	r2, r3
 800a95e: 6a3b         	ldr	r3, [r7, #0x20]
 800a960: 609a         	str	r2, [r3, #0x8]
;     if (!float_equal(kd, 0)) {
 800a962: f04f 0100    	mov.w	r1, #0x0
 800a966: 6978         	ldr	r0, [r7, #0x14]
 800a968: f7ff ff5a    	bl	0x800a820 <float_equal> @ imm = #-0x14c
 800a96c: 4603         	mov	r3, r0
 800a96e: f083 0301    	eor	r3, r3, #0x1
 800a972: b2db         	uxtb	r3, r3
 800a974: 2b00         	cmp	r3, #0x0
 800a976: d00c         	beq	0x800a992 <single_pid_calc+0x136> @ imm = #0x18
;         pid_data->err_derivate = kd * err / deltaT;
 800a978: 6939         	ldr	r1, [r7, #0x10]
 800a97a: 6978         	ldr	r0, [r7, #0x14]
 800a97c: f7f5 fece    	bl	0x800071c <__mulsf3>    @ imm = #-0xa264
 800a980: 4603         	mov	r3, r0
 800a982: 68f9         	ldr	r1, [r7, #0xc]
 800a984: 4618         	mov	r0, r3
 800a986: f7f5 ff7d    	bl	0x8000884 <__divsf3>    @ imm = #-0xa106
 800a98a: 4603         	mov	r3, r0
 800a98c: 461a         	mov	r2, r3
 800a98e: 6a3b         	ldr	r3, [r7, #0x20]
 800a990: 60da         	str	r2, [r3, #0xc]
;     *(pid_data->output) = kp * (err + pid_data->err_integral + pid_data->err_derivate);
 800a992: 6a3b         	ldr	r3, [r7, #0x20]
 800a994: 689b         	ldr	r3, [r3, #0x8]
 800a996: 6939         	ldr	r1, [r7, #0x10]
 800a998: 4618         	mov	r0, r3
 800a99a: f7f5 fdb7    	bl	0x800050c <__aeabi_fadd> @ imm = #-0xa492
 800a99e: 4603         	mov	r3, r0
 800a9a0: 461a         	mov	r2, r3
 800a9a2: 6a3b         	ldr	r3, [r7, #0x20]
 800a9a4: 68db         	ldr	r3, [r3, #0xc]
 800a9a6: 4619         	mov	r1, r3
 800a9a8: 4610         	mov	r0, r2
 800a9aa: f7f5 fdaf    	bl	0x800050c <__aeabi_fadd> @ imm = #-0xa4a2
 800a9ae: 4603         	mov	r3, r0
 800a9b0: 461a         	mov	r2, r3
 800a9b2: 6a3b         	ldr	r3, [r7, #0x20]
 800a9b4: 69dc         	ldr	r4, [r3, #0x1c]
 800a9b6: 69f9         	ldr	r1, [r7, #0x1c]
 800a9b8: 4610         	mov	r0, r2
 800a9ba: f7f5 feaf    	bl	0x800071c <__mulsf3>    @ imm = #-0xa2a2
 800a9be: 4603         	mov	r3, r0
 800a9c0: 6023         	str	r3, [r4]
;     return;
 800a9c2: e000         	b	0x800a9c6 <single_pid_calc+0x16a> @ imm = #0x0
;         return;
 800a9c4: bf00         	nop
; }
 800a9c6: 3728         	adds	r7, #0x28
 800a9c8: 46bd         	mov	sp, r7
 800a9ca: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 800a9ce: bf00         	nop

0800a9d0 <$d>:
 800a9d0: 19 86 61 18  	.word	0x18618619
 800a9d4: 00 24 74 49  	.word	0x49742400

0800a9d8 <uart_callback>:
; static void uart_callback(const struct device *dev, struct uart_event *evt, void *user_data) {
 800a9d8: b580         	push	{r7, lr}
 800a9da: b096         	sub	sp, #0x58
 800a9dc: af04         	add	r7, sp, #0x10
 800a9de: 60f8         	str	r0, [r7, #0xc]
 800a9e0: 60b9         	str	r1, [r7, #0x8]
 800a9e2: 607a         	str	r2, [r7, #0x4]
;     struct device           *sbus_dev = (struct device *)user_data;
 800a9e4: 687b         	ldr	r3, [r7, #0x4]
 800a9e6: 647b         	str	r3, [r7, #0x44]
;     struct sbus_driver_data *data     = sbus_dev->data;
 800a9e8: 6c7b         	ldr	r3, [r7, #0x44]
 800a9ea: 691b         	ldr	r3, [r3, #0x10]
 800a9ec: 643b         	str	r3, [r7, #0x40]
;     switch (evt->type) {
 800a9ee: 68bb         	ldr	r3, [r7, #0x8]
 800a9f0: 781b         	ldrb	r3, [r3]
 800a9f2: 3b02         	subs	r3, #0x2
 800a9f4: 2b04         	cmp	r3, #0x4
 800a9f6: f200 80e9    	bhi.w	0x800abcc <uart_callback+0x1f4> @ imm = #0x1d2
 800a9fa: a201         	adr	r2, #4 <uart_callback+0x27>
 800a9fc: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800aa00 <$d>:
 800aa00: 15 aa 00 08  	.word	0x0800aa15
 800aa04: a1 aa 00 08  	.word	0x0800aaa1
 800aa08: df aa 00 08  	.word	0x0800aadf
 800aa0c: cd ab 00 08  	.word	0x0800abcd
 800aa10: f5 aa 00 08  	.word	0x0800aaf5

0800aa14 <$t>:
;         uint8_t *p   = &(evt->data.rx.buf[evt->data.rx.offset]);
 800aa14: 68bb         	ldr	r3, [r7, #0x8]
 800aa16: 685a         	ldr	r2, [r3, #0x4]
 800aa18: 68bb         	ldr	r3, [r7, #0x8]
 800aa1a: 689b         	ldr	r3, [r3, #0x8]
 800aa1c: 4413         	add	r3, r2
 800aa1e: 627b         	str	r3, [r7, #0x24]
;         uint16_t len = evt->data.rx.len;
 800aa20: 68bb         	ldr	r3, [r7, #0x8]
 800aa22: 68db         	ldr	r3, [r3, #0xc]
 800aa24: 847b         	strh	r3, [r7, #0x22]
;         uint8_t *ptr_offset = p + find_begin(p, len);
 800aa26: 8c7b         	ldrh	r3, [r7, #0x22]
 800aa28: 4619         	mov	r1, r3
 800aa2a: 6a78         	ldr	r0, [r7, #0x24]
 800aa2c: f00c f8f6    	bl	0x8016c1c <find_begin>  @ imm = #0xc1ec
 800aa30: 4603         	mov	r3, r0
 800aa32: 461a         	mov	r2, r3
 800aa34: 6a7b         	ldr	r3, [r7, #0x24]
 800aa36: 4413         	add	r3, r2
 800aa38: 61fb         	str	r3, [r7, #0x1c]
;         if (ptr_offset >= p && len >= 25 && ptr_offset < p + len) {
 800aa3a: 69fa         	ldr	r2, [r7, #0x1c]
 800aa3c: 6a7b         	ldr	r3, [r7, #0x24]
 800aa3e: 429a         	cmp	r2, r3
 800aa40: d30e         	blo	0x800aa60 <uart_callback+0x88> @ imm = #0x1c
 800aa42: 8c7b         	ldrh	r3, [r7, #0x22]
 800aa44: 2b18         	cmp	r3, #0x18
 800aa46: d90b         	bls	0x800aa60 <uart_callback+0x88> @ imm = #0x16
 800aa48: 8c7b         	ldrh	r3, [r7, #0x22]
 800aa4a: 6a7a         	ldr	r2, [r7, #0x24]
 800aa4c: 4413         	add	r3, r2
 800aa4e: 69fa         	ldr	r2, [r7, #0x1c]
 800aa50: 429a         	cmp	r2, r3
 800aa52: d205         	bhs	0x800aa60 <uart_callback+0x88> @ imm = #0xa
;             memcpy(data->data, ptr_offset, 25);
 800aa54: 6c3b         	ldr	r3, [r7, #0x40]
 800aa56: 2219         	movs	r2, #0x19
 800aa58: 69f9         	ldr	r1, [r7, #0x1c]
 800aa5a: 4618         	mov	r0, r3
 800aa5c: f00e f965    	bl	0x8018d2a <memcpy>      @ imm = #0xe2ca
;         void *new_buf = NULL;
 800aa60: 2300         	movs	r3, #0x0
 800aa62: 61bb         	str	r3, [r7, #0x18]
;         err           = k_mem_slab_alloc(&uart_slab, &new_buf, K_NO_WAIT);
 800aa64: f04f 0200    	mov.w	r2, #0x0
 800aa68: f04f 0300    	mov.w	r3, #0x0
 800aa6c: f107 0118    	add.w	r1, r7, #0x18
 800aa70: 485a         	ldr	r0, [pc, #0x168]        @ 0x800abdc <uart_callback+0x204>
 800aa72: f001 f86b    	bl	0x800bb4c <k_mem_slab_alloc> @ imm = #0x10d6
 800aa76: 63f8         	str	r0, [r7, #0x3c]
;         if (err == 0 && new_buf != NULL && ((uintptr_t)new_buf & 0x3) == 0) {
 800aa78: 6bfb         	ldr	r3, [r7, #0x3c]
 800aa7a: 2b00         	cmp	r3, #0x0
 800aa7c: d10e         	bne	0x800aa9c <uart_callback+0xc4> @ imm = #0x1c
 800aa7e: 69bb         	ldr	r3, [r7, #0x18]
 800aa80: 2b00         	cmp	r3, #0x0
 800aa82: d00b         	beq	0x800aa9c <uart_callback+0xc4> @ imm = #0x16
 800aa84: 69bb         	ldr	r3, [r7, #0x18]
 800aa86: f003 0303    	and	r3, r3, #0x3
 800aa8a: 2b00         	cmp	r3, #0x0
 800aa8c: d106         	bne	0x800aa9c <uart_callback+0xc4> @ imm = #0xc
;             err = uart_rx_buf_rsp(dev, new_buf, BUF_SIZE);
 800aa8e: 69bb         	ldr	r3, [r7, #0x18]
 800aa90: 2240         	movs	r2, #0x40
 800aa92: 4619         	mov	r1, r3
 800aa94: 68f8         	ldr	r0, [r7, #0xc]
 800aa96: f00b fef0    	bl	0x801687a <uart_rx_buf_rsp> @ imm = #0xbde0
 800aa9a: 63f8         	str	r0, [r7, #0x3c]
;         break;
 800aa9c: bf00         	nop
; }
 800aa9e: e098         	b	0x800abd2 <uart_callback+0x1fa> @ imm = #0x130
;         uint8_t *buf = NULL; // 使用 void* 类型
 800aaa0: 2300         	movs	r3, #0x0
 800aaa2: 617b         	str	r3, [r7, #0x14]
;         err = k_mem_slab_alloc(&uart_slab, (void **)&buf, K_NO_WAIT);
 800aaa4: f04f 0200    	mov.w	r2, #0x0
 800aaa8: f04f 0300    	mov.w	r3, #0x0
 800aaac: f107 0114    	add.w	r1, r7, #0x14
 800aab0: 484a         	ldr	r0, [pc, #0x128]        @ 0x800abdc <uart_callback+0x204>
 800aab2: f001 f84b    	bl	0x800bb4c <k_mem_slab_alloc> @ imm = #0x1096
 800aab6: 63f8         	str	r0, [r7, #0x3c]
;         if (err == 0 && ((uintptr_t)buf & 0x3) == 0 && buf != NULL) {
 800aab8: 6bfb         	ldr	r3, [r7, #0x3c]
 800aaba: 2b00         	cmp	r3, #0x0
 800aabc: d10d         	bne	0x800aada <uart_callback+0x102> @ imm = #0x1a
 800aabe: 697b         	ldr	r3, [r7, #0x14]
 800aac0: f003 0303    	and	r3, r3, #0x3
 800aac4: 2b00         	cmp	r3, #0x0
 800aac6: d108         	bne	0x800aada <uart_callback+0x102> @ imm = #0x10
 800aac8: 697b         	ldr	r3, [r7, #0x14]
 800aaca: 2b00         	cmp	r3, #0x0
 800aacc: d005         	beq	0x800aada <uart_callback+0x102> @ imm = #0xa
;             uart_rx_buf_rsp(dev, buf, BUF_SIZE);
 800aace: 697b         	ldr	r3, [r7, #0x14]
 800aad0: 2240         	movs	r2, #0x40
 800aad2: 4619         	mov	r1, r3
 800aad4: 68f8         	ldr	r0, [r7, #0xc]
 800aad6: f00b fed0    	bl	0x801687a <uart_rx_buf_rsp> @ imm = #0xbda0
;         break;
 800aada: bf00         	nop
; }
 800aadc: e079         	b	0x800abd2 <uart_callback+0x1fa> @ imm = #0xf2
;         void *buf = evt->data.rx_buf.buf;
 800aade: 68bb         	ldr	r3, [r7, #0x8]
 800aae0: 685b         	ldr	r3, [r3, #0x4]
 800aae2: 62bb         	str	r3, [r7, #0x28]
;         if (buf != NULL) {
 800aae4: 6abb         	ldr	r3, [r7, #0x28]
 800aae6: 2b00         	cmp	r3, #0x0
 800aae8: d072         	beq	0x800abd0 <uart_callback+0x1f8> @ imm = #0xe4
;             k_mem_slab_free(&uart_slab, buf);
 800aaea: 6ab9         	ldr	r1, [r7, #0x28]
 800aaec: 483b         	ldr	r0, [pc, #0xec]         @ 0x800abdc <uart_callback+0x204>
 800aaee: f00c fb60    	bl	0x80171b2 <k_mem_slab_free> @ imm = #0xc6c0
;         break;
 800aaf2: e06d         	b	0x800abd0 <uart_callback+0x1f8> @ imm = #0xda
;         uint8_t *buf = NULL;
 800aaf4: 2300         	movs	r3, #0x0
 800aaf6: 613b         	str	r3, [r7, #0x10]
;         err          = k_mem_slab_alloc(&uart_slab, (void **)&buf, K_NO_WAIT);
 800aaf8: f04f 0200    	mov.w	r2, #0x0
 800aafc: f04f 0300    	mov.w	r3, #0x0
 800ab00: f107 0110    	add.w	r1, r7, #0x10
 800ab04: 4835         	ldr	r0, [pc, #0xd4]         @ 0x800abdc <uart_callback+0x204>
 800ab06: f001 f821    	bl	0x800bb4c <k_mem_slab_alloc> @ imm = #0x1042
 800ab0a: 63f8         	str	r0, [r7, #0x3c]
;         if (err == 0 && buf != NULL && ((uintptr_t)buf & 0x3) == 0) {
 800ab0c: 6bfb         	ldr	r3, [r7, #0x3c]
 800ab0e: 2b00         	cmp	r3, #0x0
 800ab10: d13c         	bne	0x800ab8c <uart_callback+0x1b4> @ imm = #0x78
 800ab12: 693b         	ldr	r3, [r7, #0x10]
 800ab14: 2b00         	cmp	r3, #0x0
 800ab16: d039         	beq	0x800ab8c <uart_callback+0x1b4> @ imm = #0x72
 800ab18: 693b         	ldr	r3, [r7, #0x10]
 800ab1a: f003 0303    	and	r3, r3, #0x3
 800ab1e: 2b00         	cmp	r3, #0x0
 800ab20: d134         	bne	0x800ab8c <uart_callback+0x1b4> @ imm = #0x68
;             memset(buf, 0, BUF_SIZE);
 800ab22: 693b         	ldr	r3, [r7, #0x10]
 800ab24: 2240         	movs	r2, #0x40
 800ab26: 2100         	movs	r1, #0x0
 800ab28: 4618         	mov	r0, r3
 800ab2a: f00e f90c    	bl	0x8018d46 <memset>      @ imm = #0xe218
;             err = uart_rx_enable(dev, buf, BUF_SIZE, 100);
 800ab2e: 6939         	ldr	r1, [r7, #0x10]
 800ab30: 2364         	movs	r3, #0x64
 800ab32: 2240         	movs	r2, #0x40
 800ab34: 68f8         	ldr	r0, [r7, #0xc]
 800ab36: f00b fed2    	bl	0x80168de <uart_rx_enable> @ imm = #0xbda4
 800ab3a: 63f8         	str	r0, [r7, #0x3c]
;             if (err) {
 800ab3c: 6bfb         	ldr	r3, [r7, #0x3c]
 800ab3e: 2b00         	cmp	r3, #0x0
 800ab40: d042         	beq	0x800abc8 <uart_callback+0x1f0> @ imm = #0x84
;                 LOG_ERR("Failed to enable RX: %d", err);
 800ab42: 233c         	movs	r3, #0x3c
 800ab44: 2b00         	cmp	r3, #0x0
 800ab46: d01a         	beq	0x800ab7e <uart_callback+0x1a6> @ imm = #0x34
 800ab48: 2301         	movs	r3, #0x1
 800ab4a: f887 303b    	strb.w	r3, [r7, #0x3b]
 800ab4e: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800ab52: f083 0301    	eor	r3, r3, #0x1
 800ab56: b2db         	uxtb	r3, r3
 800ab58: 2b00         	cmp	r3, #0x0
 800ab5a: d110         	bne	0x800ab7e <uart_callback+0x1a6> @ imm = #0x20
 800ab5c: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800abe0 <uart_callback+0x208>
 800ab5e: 6819         	ldr	r1, [r3]
 800ab60: 6bfb         	ldr	r3, [r7, #0x3c]
 800ab62: 9303         	str	r3, [sp, #0xc]
 800ab64: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800abe4 <uart_callback+0x20c>
 800ab66: 9302         	str	r3, [sp, #0x8]
 800ab68: 2300         	movs	r3, #0x0
 800ab6a: 9301         	str	r3, [sp, #0x4]
 800ab6c: 2300         	movs	r3, #0x0
 800ab6e: 9300         	str	r3, [sp]
 800ab70: 2300         	movs	r3, #0x0
 800ab72: 2201         	movs	r2, #0x1
 800ab74: 2000         	movs	r0, #0x0
 800ab76: f00b fed0    	bl	0x801691a <z_log_msg_runtime_create> @ imm = #0xbda0
 800ab7a: 2300         	movs	r3, #0x0
 800ab7c: 637b         	str	r3, [r7, #0x34]
;                 k_mem_slab_free(&uart_slab, (void **)&buf);
 800ab7e: f107 0310    	add.w	r3, r7, #0x10
 800ab82: 4619         	mov	r1, r3
 800ab84: 4815         	ldr	r0, [pc, #0x54]         @ 0x800abdc <uart_callback+0x204>
 800ab86: f00c fb14    	bl	0x80171b2 <k_mem_slab_free> @ imm = #0xc628
;             if (err) {
 800ab8a: e01d         	b	0x800abc8 <uart_callback+0x1f0> @ imm = #0x3a
;             LOG_ERR("Failed to allocate memory: %d", err);
 800ab8c: 233c         	movs	r3, #0x3c
 800ab8e: 2b00         	cmp	r3, #0x0
 800ab90: d01a         	beq	0x800abc8 <uart_callback+0x1f0> @ imm = #0x34
 800ab92: 2301         	movs	r3, #0x1
 800ab94: f887 3033    	strb.w	r3, [r7, #0x33]
 800ab98: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800ab9c: f083 0301    	eor	r3, r3, #0x1
 800aba0: b2db         	uxtb	r3, r3
 800aba2: 2b00         	cmp	r3, #0x0
 800aba4: d110         	bne	0x800abc8 <uart_callback+0x1f0> @ imm = #0x20
 800aba6: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800abe0 <uart_callback+0x208>
 800aba8: 6819         	ldr	r1, [r3]
 800abaa: 6bfb         	ldr	r3, [r7, #0x3c]
 800abac: 9303         	str	r3, [sp, #0xc]
 800abae: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800abe8 <uart_callback+0x210>
 800abb0: 9302         	str	r3, [sp, #0x8]
 800abb2: 2300         	movs	r3, #0x0
 800abb4: 9301         	str	r3, [sp, #0x4]
 800abb6: 2300         	movs	r3, #0x0
 800abb8: 9300         	str	r3, [sp]
 800abba: 2300         	movs	r3, #0x0
 800abbc: 2201         	movs	r2, #0x1
 800abbe: 2000         	movs	r0, #0x0
 800abc0: f00b feab    	bl	0x801691a <z_log_msg_runtime_create> @ imm = #0xbd56
 800abc4: 2300         	movs	r3, #0x0
 800abc6: 62fb         	str	r3, [r7, #0x2c]
;         break;
 800abc8: bf00         	nop
; }
 800abca: e002         	b	0x800abd2 <uart_callback+0x1fa> @ imm = #0x4
;     default: break;
 800abcc: bf00         	nop
 800abce: e000         	b	0x800abd2 <uart_callback+0x1fa> @ imm = #0x0
;         break;
 800abd0: bf00         	nop
; }
 800abd2: bf00         	nop
 800abd4: 3748         	adds	r7, #0x48
 800abd6: 46bd         	mov	sp, r7
 800abd8: bd80         	pop	{r7, pc}
 800abda: bf00         	nop

0800abdc <$d>:
 800abdc: cc 05 00 20  	.word	0x200005cc
 800abe0: 9c 10 00 20  	.word	0x2000109c
 800abe4: 60 ad 01 08  	.word	0x0801ad60
 800abe8: 78 ad 01 08  	.word	0x0801ad78

0800abec <sbus_init>:
; static int sbus_init(const struct device *dev) {
 800abec: b590         	push	{r4, r7, lr}
 800abee: b095         	sub	sp, #0x54
 800abf0: af04         	add	r7, sp, #0x10
 800abf2: 6078         	str	r0, [r7, #0x4]
;     if (!device_is_ready(uart_dev)) {
 800abf4: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x800adf0 <sbus_init+0x204>
 800abf6: 681b         	ldr	r3, [r3]
 800abf8: 4618         	mov	r0, r3
 800abfa: f00b fde8    	bl	0x80167ce <device_is_ready> @ imm = #0xbbd0
 800abfe: 4603         	mov	r3, r0
 800ac00: f083 0301    	eor	r3, r3, #0x1
 800ac04: b2db         	uxtb	r3, r3
 800ac06: 2b00         	cmp	r3, #0x0
 800ac08: d01c         	beq	0x800ac44 <sbus_init+0x58> @ imm = #0x38
;         LOG_ERR("UART device not ready");
 800ac0a: 233c         	movs	r3, #0x3c
 800ac0c: 2b00         	cmp	r3, #0x0
 800ac0e: d016         	beq	0x800ac3e <sbus_init+0x52> @ imm = #0x2c
 800ac10: 2301         	movs	r3, #0x1
 800ac12: 76fb         	strb	r3, [r7, #0x1b]
 800ac14: 7efb         	ldrb	r3, [r7, #0x1b]
 800ac16: f083 0301    	eor	r3, r3, #0x1
 800ac1a: b2db         	uxtb	r3, r3
 800ac1c: 2b00         	cmp	r3, #0x0
 800ac1e: d10e         	bne	0x800ac3e <sbus_init+0x52> @ imm = #0x1c
 800ac20: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800adf4 <sbus_init+0x208>
 800ac22: 6819         	ldr	r1, [r3]
 800ac24: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800adf8 <sbus_init+0x20c>
 800ac26: 9302         	str	r3, [sp, #0x8]
 800ac28: 2300         	movs	r3, #0x0
 800ac2a: 9301         	str	r3, [sp, #0x4]
 800ac2c: 2300         	movs	r3, #0x0
 800ac2e: 9300         	str	r3, [sp]
 800ac30: 2300         	movs	r3, #0x0
 800ac32: 2201         	movs	r2, #0x1
 800ac34: 2000         	movs	r0, #0x0
 800ac36: f00b fe70    	bl	0x801691a <z_log_msg_runtime_create> @ imm = #0xbce0
 800ac3a: 2300         	movs	r3, #0x0
 800ac3c: 617b         	str	r3, [r7, #0x14]
;         return -ENODEV;
 800ac3e: f06f 0312    	mvn	r3, #0x12
 800ac42: e0d0         	b	0x800ade6 <sbus_init+0x1fa> @ imm = #0x1a0
;     err = uart_callback_set(uart_dev, uart_callback, (void *)dev);
 800ac44: 4b6a         	ldr	r3, [pc, #0x1a8]        @ 0x800adf0 <sbus_init+0x204>
 800ac46: 681b         	ldr	r3, [r3]
 800ac48: 687a         	ldr	r2, [r7, #0x4]
 800ac4a: 496c         	ldr	r1, [pc, #0x1b0]        @ 0x800adfc <sbus_init+0x210>
 800ac4c: 4618         	mov	r0, r3
 800ac4e: f00b fde3    	bl	0x8016818 <uart_callback_set> @ imm = #0xbbc6
 800ac52: 63f8         	str	r0, [r7, #0x3c]
;     if (err) {
 800ac54: 6bfb         	ldr	r3, [r7, #0x3c]
 800ac56: 2b00         	cmp	r3, #0x0
 800ac58: d01f         	beq	0x800ac9a <sbus_init+0xae> @ imm = #0x3e
;         LOG_ERR("Failed to set callback: %d", err);
 800ac5a: 233c         	movs	r3, #0x3c
 800ac5c: 2b00         	cmp	r3, #0x0
 800ac5e: d01a         	beq	0x800ac96 <sbus_init+0xaa> @ imm = #0x34
 800ac60: 2301         	movs	r3, #0x1
 800ac62: f887 3023    	strb.w	r3, [r7, #0x23]
 800ac66: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800ac6a: f083 0301    	eor	r3, r3, #0x1
 800ac6e: b2db         	uxtb	r3, r3
 800ac70: 2b00         	cmp	r3, #0x0
 800ac72: d110         	bne	0x800ac96 <sbus_init+0xaa> @ imm = #0x20
 800ac74: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x800adf4 <sbus_init+0x208>
 800ac76: 6819         	ldr	r1, [r3]
 800ac78: 6bfb         	ldr	r3, [r7, #0x3c]
 800ac7a: 9303         	str	r3, [sp, #0xc]
 800ac7c: 4b60         	ldr	r3, [pc, #0x180]        @ 0x800ae00 <sbus_init+0x214>
 800ac7e: 9302         	str	r3, [sp, #0x8]
 800ac80: 2300         	movs	r3, #0x0
 800ac82: 9301         	str	r3, [sp, #0x4]
 800ac84: 2300         	movs	r3, #0x0
 800ac86: 9300         	str	r3, [sp]
 800ac88: 2300         	movs	r3, #0x0
 800ac8a: 2201         	movs	r2, #0x1
 800ac8c: 2000         	movs	r0, #0x0
 800ac8e: f00b fe44    	bl	0x801691a <z_log_msg_runtime_create> @ imm = #0xbc88
 800ac92: 2300         	movs	r3, #0x0
 800ac94: 61fb         	str	r3, [r7, #0x1c]
;         return err;
 800ac96: 6bfb         	ldr	r3, [r7, #0x3c]
 800ac98: e0a5         	b	0x800ade6 <sbus_init+0x1fa> @ imm = #0x14a
;     err = k_mem_slab_alloc(&uart_slab, (void **)&buf, K_NO_WAIT);
 800ac9a: f04f 0000    	mov.w	r0, #0x0
 800ac9e: f04f 0100    	mov.w	r1, #0x0
 800aca2: f107 0410    	add.w	r4, r7, #0x10
 800aca6: 4602         	mov	r2, r0
 800aca8: 460b         	mov	r3, r1
 800acaa: 4621         	mov	r1, r4
 800acac: 4855         	ldr	r0, [pc, #0x154]        @ 0x800ae04 <sbus_init+0x218>
 800acae: f000 ff4d    	bl	0x800bb4c <k_mem_slab_alloc> @ imm = #0xe9a
 800acb2: 63f8         	str	r0, [r7, #0x3c]
;     memset(buf, 0, BUF_SIZE);
 800acb4: 693b         	ldr	r3, [r7, #0x10]
 800acb6: 2240         	movs	r2, #0x40
 800acb8: 2100         	movs	r1, #0x0
 800acba: 4618         	mov	r0, r3
 800acbc: f00e f843    	bl	0x8018d46 <memset>      @ imm = #0xe086
;     if (err) {
 800acc0: 6bfb         	ldr	r3, [r7, #0x3c]
 800acc2: 2b00         	cmp	r3, #0x0
 800acc4: d01f         	beq	0x800ad06 <sbus_init+0x11a> @ imm = #0x3e
;         LOG_ERR("Failed to allocate memory: %d", err);
 800acc6: 233c         	movs	r3, #0x3c
 800acc8: 2b00         	cmp	r3, #0x0
 800acca: d01a         	beq	0x800ad02 <sbus_init+0x116> @ imm = #0x34
 800accc: 2301         	movs	r3, #0x1
 800acce: f887 302b    	strb.w	r3, [r7, #0x2b]
 800acd2: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800acd6: f083 0301    	eor	r3, r3, #0x1
 800acda: b2db         	uxtb	r3, r3
 800acdc: 2b00         	cmp	r3, #0x0
 800acde: d110         	bne	0x800ad02 <sbus_init+0x116> @ imm = #0x20
 800ace0: 4b44         	ldr	r3, [pc, #0x110]        @ 0x800adf4 <sbus_init+0x208>
 800ace2: 6819         	ldr	r1, [r3]
 800ace4: 6bfb         	ldr	r3, [r7, #0x3c]
 800ace6: 9303         	str	r3, [sp, #0xc]
 800ace8: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x800ae08 <sbus_init+0x21c>
 800acea: 9302         	str	r3, [sp, #0x8]
 800acec: 2300         	movs	r3, #0x0
 800acee: 9301         	str	r3, [sp, #0x4]
 800acf0: 2300         	movs	r3, #0x0
 800acf2: 9300         	str	r3, [sp]
 800acf4: 2300         	movs	r3, #0x0
 800acf6: 2201         	movs	r2, #0x1
 800acf8: 2000         	movs	r0, #0x0
 800acfa: f00b fe0e    	bl	0x801691a <z_log_msg_runtime_create> @ imm = #0xbc1c
 800acfe: 2300         	movs	r3, #0x0
 800ad00: 627b         	str	r3, [r7, #0x24]
;         return err;
 800ad02: 6bfb         	ldr	r3, [r7, #0x3c]
 800ad04: e06f         	b	0x800ade6 <sbus_init+0x1fa> @ imm = #0xde
;     const struct uart_config config = {.baudrate  = 100000,
 800ad06: 4a41         	ldr	r2, [pc, #0x104]        @ 0x800ae0c <sbus_init+0x220>
 800ad08: f107 0308    	add.w	r3, r7, #0x8
 800ad0c: e892 0003    	ldm.w	r2, {r0, r1}
 800ad10: e883 0003    	stm.w	r3, {r0, r1}
;     err = uart_configure(uart_dev, &config);
 800ad14: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800adf0 <sbus_init+0x204>
 800ad16: 681b         	ldr	r3, [r3]
 800ad18: f107 0208    	add.w	r2, r7, #0x8
 800ad1c: 4611         	mov	r1, r2
 800ad1e: 4618         	mov	r0, r3
 800ad20: f00b fdcf    	bl	0x80168c2 <uart_configure> @ imm = #0xbb9e
 800ad24: 63f8         	str	r0, [r7, #0x3c]
;     if (err) {
 800ad26: 6bfb         	ldr	r3, [r7, #0x3c]
 800ad28: 2b00         	cmp	r3, #0x0
 800ad2a: d025         	beq	0x800ad78 <sbus_init+0x18c> @ imm = #0x4a
;         LOG_ERR("Failed to configure UART: %d", err);
 800ad2c: 233c         	movs	r3, #0x3c
 800ad2e: 2b00         	cmp	r3, #0x0
 800ad30: d01a         	beq	0x800ad68 <sbus_init+0x17c> @ imm = #0x34
 800ad32: 2301         	movs	r3, #0x1
 800ad34: f887 3033    	strb.w	r3, [r7, #0x33]
 800ad38: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800ad3c: f083 0301    	eor	r3, r3, #0x1
 800ad40: b2db         	uxtb	r3, r3
 800ad42: 2b00         	cmp	r3, #0x0
 800ad44: d110         	bne	0x800ad68 <sbus_init+0x17c> @ imm = #0x20
 800ad46: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800adf4 <sbus_init+0x208>
 800ad48: 6819         	ldr	r1, [r3]
 800ad4a: 6bfb         	ldr	r3, [r7, #0x3c]
 800ad4c: 9303         	str	r3, [sp, #0xc]
 800ad4e: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x800ae10 <sbus_init+0x224>
 800ad50: 9302         	str	r3, [sp, #0x8]
 800ad52: 2300         	movs	r3, #0x0
 800ad54: 9301         	str	r3, [sp, #0x4]
 800ad56: 2300         	movs	r3, #0x0
 800ad58: 9300         	str	r3, [sp]
 800ad5a: 2300         	movs	r3, #0x0
 800ad5c: 2201         	movs	r2, #0x1
 800ad5e: 2000         	movs	r0, #0x0
 800ad60: f00b fddb    	bl	0x801691a <z_log_msg_runtime_create> @ imm = #0xbbb6
 800ad64: 2300         	movs	r3, #0x0
 800ad66: 62fb         	str	r3, [r7, #0x2c]
;         k_mem_slab_free(&uart_slab, (void **)&buf);
 800ad68: f107 0310    	add.w	r3, r7, #0x10
 800ad6c: 4619         	mov	r1, r3
 800ad6e: 4825         	ldr	r0, [pc, #0x94]         @ 0x800ae04 <sbus_init+0x218>
 800ad70: f00c fa1f    	bl	0x80171b2 <k_mem_slab_free> @ imm = #0xc43e
;         return err;
 800ad74: 6bfb         	ldr	r3, [r7, #0x3c]
 800ad76: e036         	b	0x800ade6 <sbus_init+0x1fa> @ imm = #0x6c
;     uart_rx_disable(uart_dev);
 800ad78: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800adf0 <sbus_init+0x204>
 800ad7a: 681b         	ldr	r3, [r3]
 800ad7c: 4618         	mov	r0, r3
 800ad7e: f00b fdc0    	bl	0x8016902 <uart_rx_disable> @ imm = #0xbb80
;     err = uart_rx_enable(uart_dev, buf, BUF_SIZE, 100);
 800ad82: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800adf0 <sbus_init+0x204>
 800ad84: 6818         	ldr	r0, [r3]
 800ad86: 6939         	ldr	r1, [r7, #0x10]
 800ad88: 2364         	movs	r3, #0x64
 800ad8a: 2240         	movs	r2, #0x40
 800ad8c: f00b fda7    	bl	0x80168de <uart_rx_enable> @ imm = #0xbb4e
 800ad90: 63f8         	str	r0, [r7, #0x3c]
;     if (err) {
 800ad92: 6bfb         	ldr	r3, [r7, #0x3c]
 800ad94: 2b00         	cmp	r3, #0x0
 800ad96: d025         	beq	0x800ade4 <sbus_init+0x1f8> @ imm = #0x4a
;         LOG_ERR("Failed to enable RX: %d", err);
 800ad98: 233c         	movs	r3, #0x3c
 800ad9a: 2b00         	cmp	r3, #0x0
 800ad9c: d01a         	beq	0x800add4 <sbus_init+0x1e8> @ imm = #0x34
 800ad9e: 2301         	movs	r3, #0x1
 800ada0: f887 303b    	strb.w	r3, [r7, #0x3b]
 800ada4: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800ada8: f083 0301    	eor	r3, r3, #0x1
 800adac: b2db         	uxtb	r3, r3
 800adae: 2b00         	cmp	r3, #0x0
 800adb0: d110         	bne	0x800add4 <sbus_init+0x1e8> @ imm = #0x20
 800adb2: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800adf4 <sbus_init+0x208>
 800adb4: 6819         	ldr	r1, [r3]
 800adb6: 6bfb         	ldr	r3, [r7, #0x3c]
 800adb8: 9303         	str	r3, [sp, #0xc]
 800adba: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800ae14 <sbus_init+0x228>
 800adbc: 9302         	str	r3, [sp, #0x8]
 800adbe: 2300         	movs	r3, #0x0
 800adc0: 9301         	str	r3, [sp, #0x4]
 800adc2: 2300         	movs	r3, #0x0
 800adc4: 9300         	str	r3, [sp]
 800adc6: 2300         	movs	r3, #0x0
 800adc8: 2201         	movs	r2, #0x1
 800adca: 2000         	movs	r0, #0x0
 800adcc: f00b fda5    	bl	0x801691a <z_log_msg_runtime_create> @ imm = #0xbb4a
 800add0: 2300         	movs	r3, #0x0
 800add2: 637b         	str	r3, [r7, #0x34]
;         k_mem_slab_free(&uart_slab, (void **)&buf);
 800add4: f107 0310    	add.w	r3, r7, #0x10
 800add8: 4619         	mov	r1, r3
 800adda: 480a         	ldr	r0, [pc, #0x28]         @ 0x800ae04 <sbus_init+0x218>
 800addc: f00c f9e9    	bl	0x80171b2 <k_mem_slab_free> @ imm = #0xc3d2
;         return err;
 800ade0: 6bfb         	ldr	r3, [r7, #0x3c]
 800ade2: e000         	b	0x800ade6 <sbus_init+0x1fa> @ imm = #0x0
;     return 0;
 800ade4: 2300         	movs	r3, #0x0
; }
 800ade6: 4618         	mov	r0, r3
 800ade8: 3744         	adds	r7, #0x44
 800adea: 46bd         	mov	sp, r7
 800adec: bd90         	pop	{r4, r7, pc}
 800adee: bf00         	nop

0800adf0 <$d>:
 800adf0: 18 05 00 20  	.word	0x20000518
 800adf4: 9c 10 00 20  	.word	0x2000109c
 800adf8: 98 ad 01 08  	.word	0x0801ad98
 800adfc: d9 a9 00 08  	.word	0x0800a9d9
 800ae00: b0 ad 01 08  	.word	0x0801adb0
 800ae04: cc 05 00 20  	.word	0x200005cc
 800ae08: 78 ad 01 08  	.word	0x0801ad78
 800ae0c: ec ad 01 08  	.word	0x0801adec
 800ae10: cc ad 01 08  	.word	0x0801adcc
 800ae14: 60 ad 01 08  	.word	0x0801ad60

0800ae18 <sbus_getchannel_percentage>:
; float sbus_getchannel_percentage(const struct device *dev, uint8_t channelid) {
 800ae18: b580         	push	{r7, lr}
 800ae1a: b086         	sub	sp, #0x18
 800ae1c: af00         	add	r7, sp, #0x0
 800ae1e: 6078         	str	r0, [r7, #0x4]
 800ae20: 460b         	mov	r3, r1
 800ae22: 70fb         	strb	r3, [r7, #0x3]
;     struct sbus_driver_data *data = dev->data;
 800ae24: 687b         	ldr	r3, [r7, #0x4]
 800ae26: 691b         	ldr	r3, [r3, #0x10]
 800ae28: 617b         	str	r3, [r7, #0x14]
;     sbus_parseframe(dev);
 800ae2a: 6878         	ldr	r0, [r7, #0x4]
 800ae2c: f00b fd93    	bl	0x8016956 <sbus_parseframe> @ imm = #0xbb26
;     float scale = 2.0f / (SBUS_MAX - SBUS_MIN);
 800ae30: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800ae68 <sbus_getchannel_percentage+0x50>
 800ae32: 613b         	str	r3, [r7, #0x10]
;     float out   = (int16_t)(data->channels[channelid] - 1024) * scale;
 800ae34: 78fb         	ldrb	r3, [r7, #0x3]
 800ae36: 697a         	ldr	r2, [r7, #0x14]
 800ae38: 330c         	adds	r3, #0xc
 800ae3a: 005b         	lsls	r3, r3, #0x1
 800ae3c: 4413         	add	r3, r2
 800ae3e: 885b         	ldrh	r3, [r3, #0x2]
 800ae40: f5a3 6380    	sub.w	r3, r3, #0x400
 800ae44: b29b         	uxth	r3, r3
 800ae46: b21b         	sxth	r3, r3
 800ae48: 4618         	mov	r0, r3
 800ae4a: f7f5 fc13    	bl	0x8000674 <__floatsisf> @ imm = #-0xa7da
 800ae4e: 4603         	mov	r3, r0
 800ae50: 4619         	mov	r1, r3
 800ae52: 6938         	ldr	r0, [r7, #0x10]
 800ae54: f7f5 fc62    	bl	0x800071c <__mulsf3>    @ imm = #-0xa73c
 800ae58: 4603         	mov	r3, r0
 800ae5a: 60fb         	str	r3, [r7, #0xc]
;     return out;
 800ae5c: 68fb         	ldr	r3, [r7, #0xc]
; }
 800ae5e: 4618         	mov	r0, r3
 800ae60: 3718         	adds	r7, #0x18
 800ae62: 46bd         	mov	sp, r7
 800ae64: bd80         	pop	{r7, pc}
 800ae66: bf00         	nop

0800ae68 <$d>:
 800ae68: 9b 56 c3 3a  	.word	0x3ac3569b

0800ae6c <HAL_RCC_GetSysClockFreq>:
; {
 800ae6c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800ae70: b090         	sub	sp, #0x40
 800ae72: af00         	add	r7, sp, #0x0
;   uint32_t pllm = 0U;
 800ae74: 2300         	movs	r3, #0x0
 800ae76: 637b         	str	r3, [r7, #0x34]
;   uint32_t pllvco = 0U;
 800ae78: 2300         	movs	r3, #0x0
 800ae7a: 63fb         	str	r3, [r7, #0x3c]
;   uint32_t pllp = 0U;
 800ae7c: 2300         	movs	r3, #0x0
 800ae7e: 633b         	str	r3, [r7, #0x30]
;   uint32_t sysclockfreq = 0U;
 800ae80: 2300         	movs	r3, #0x0
 800ae82: 63bb         	str	r3, [r7, #0x38]
;   switch (RCC->CFGR & RCC_CFGR_SWS)
 800ae84: 4b59         	ldr	r3, [pc, #0x164]        @ 0x800afec <HAL_RCC_GetSysClockFreq+0x180>
 800ae86: 689b         	ldr	r3, [r3, #0x8]
 800ae88: f003 030c    	and	r3, r3, #0xc
 800ae8c: 2b08         	cmp	r3, #0x8
 800ae8e: d00d         	beq	0x800aeac <HAL_RCC_GetSysClockFreq+0x40> @ imm = #0x1a
 800ae90: 2b08         	cmp	r3, #0x8
 800ae92: f200 80a2    	bhi.w	0x800afda <HAL_RCC_GetSysClockFreq+0x16e> @ imm = #0x144
 800ae96: 2b00         	cmp	r3, #0x0
 800ae98: d002         	beq	0x800aea0 <HAL_RCC_GetSysClockFreq+0x34> @ imm = #0x4
 800ae9a: 2b04         	cmp	r3, #0x4
 800ae9c: d003         	beq	0x800aea6 <HAL_RCC_GetSysClockFreq+0x3a> @ imm = #0x6
 800ae9e: e09c         	b	0x800afda <HAL_RCC_GetSysClockFreq+0x16e> @ imm = #0x138
;       sysclockfreq = HSI_VALUE;
 800aea0: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800aff0 <HAL_RCC_GetSysClockFreq+0x184>
 800aea2: 63bb         	str	r3, [r7, #0x38]
;       break;
 800aea4: e09c         	b	0x800afe0 <HAL_RCC_GetSysClockFreq+0x174> @ imm = #0x138
;       sysclockfreq = HSE_VALUE;
 800aea6: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800aff4 <HAL_RCC_GetSysClockFreq+0x188>
 800aea8: 63bb         	str	r3, [r7, #0x38]
;       break;
 800aeaa: e099         	b	0x800afe0 <HAL_RCC_GetSysClockFreq+0x174> @ imm = #0x132
;       pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800aeac: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x800afec <HAL_RCC_GetSysClockFreq+0x180>
 800aeae: 685b         	ldr	r3, [r3, #0x4]
 800aeb0: f003 033f    	and	r3, r3, #0x3f
 800aeb4: 637b         	str	r3, [r7, #0x34]
;       if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800aeb6: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800afec <HAL_RCC_GetSysClockFreq+0x180>
 800aeb8: 685b         	ldr	r3, [r3, #0x4]
 800aeba: f403 0380    	and	r3, r3, #0x400000
 800aebe: 2b00         	cmp	r3, #0x0
 800aec0: d027         	beq	0x800af12 <HAL_RCC_GetSysClockFreq+0xa6> @ imm = #0x4e
;         pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800aec2: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x800afec <HAL_RCC_GetSysClockFreq+0x180>
 800aec4: 685b         	ldr	r3, [r3, #0x4]
 800aec6: 099b         	lsrs	r3, r3, #0x6
 800aec8: 2200         	movs	r2, #0x0
 800aeca: 623b         	str	r3, [r7, #0x20]
 800aecc: 627a         	str	r2, [r7, #0x24]
 800aece: 6a3b         	ldr	r3, [r7, #0x20]
 800aed0: f3c3 0008    	ubfx	r0, r3, #0x0, #0x9
 800aed4: 2100         	movs	r1, #0x0
 800aed6: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x800aff4 <HAL_RCC_GetSysClockFreq+0x188>
 800aed8: fb03 f201    	mul	r2, r3, r1
 800aedc: 2300         	movs	r3, #0x0
 800aede: fb00 f303    	mul	r3, r0, r3
 800aee2: 4413         	add	r3, r2
 800aee4: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x800aff4 <HAL_RCC_GetSysClockFreq+0x188>
 800aee6: fba0 2102    	umull	r2, r1, r0, r2
 800aeea: 62f9         	str	r1, [r7, #0x2c]
 800aeec: 62ba         	str	r2, [r7, #0x28]
 800aeee: 6afa         	ldr	r2, [r7, #0x2c]
 800aef0: 4413         	add	r3, r2
 800aef2: 62fb         	str	r3, [r7, #0x2c]
 800aef4: 6b7b         	ldr	r3, [r7, #0x34]
 800aef6: 2200         	movs	r2, #0x0
 800aef8: 61bb         	str	r3, [r7, #0x18]
 800aefa: 61fa         	str	r2, [r7, #0x1c]
 800aefc: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 800af00: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 800af04: f7f5 fdf6    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0xa414
 800af08: 4602         	mov	r2, r0
 800af0a: 460b         	mov	r3, r1
 800af0c: 4613         	mov	r3, r2
 800af0e: 63fb         	str	r3, [r7, #0x3c]
 800af10: e055         	b	0x800afbe <HAL_RCC_GetSysClockFreq+0x152> @ imm = #0xaa
;         pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800af12: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800afec <HAL_RCC_GetSysClockFreq+0x180>
 800af14: 685b         	ldr	r3, [r3, #0x4]
 800af16: 099b         	lsrs	r3, r3, #0x6
 800af18: 2200         	movs	r2, #0x0
 800af1a: 613b         	str	r3, [r7, #0x10]
 800af1c: 617a         	str	r2, [r7, #0x14]
 800af1e: 693b         	ldr	r3, [r7, #0x10]
 800af20: f3c3 0a08    	ubfx	r10, r3, #0x0, #0x9
 800af24: f04f 0b00    	mov.w	r11, #0x0
 800af28: 4652         	mov	r2, r10
 800af2a: 465b         	mov	r3, r11
 800af2c: f04f 0000    	mov.w	r0, #0x0
 800af30: f04f 0100    	mov.w	r1, #0x0
 800af34: 0159         	lsls	r1, r3, #0x5
 800af36: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 800af3a: 0150         	lsls	r0, r2, #0x5
 800af3c: 4602         	mov	r2, r0
 800af3e: 460b         	mov	r3, r1
 800af40: ebb2 080a    	subs.w	r8, r2, r10
 800af44: eb63 090b    	sbc.w	r9, r3, r11
 800af48: f04f 0200    	mov.w	r2, #0x0
 800af4c: f04f 0300    	mov.w	r3, #0x0
 800af50: ea4f 1389    	lsl.w	r3, r9, #0x6
 800af54: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 800af58: ea4f 1288    	lsl.w	r2, r8, #0x6
 800af5c: ebb2 0408    	subs.w	r4, r2, r8
 800af60: eb63 0509    	sbc.w	r5, r3, r9
 800af64: f04f 0200    	mov.w	r2, #0x0
 800af68: f04f 0300    	mov.w	r3, #0x0
 800af6c: 00eb         	lsls	r3, r5, #0x3
 800af6e: ea43 7354    	orr.w	r3, r3, r4, lsr #29
 800af72: 00e2         	lsls	r2, r4, #0x3
 800af74: 4614         	mov	r4, r2
 800af76: 461d         	mov	r5, r3
 800af78: eb14 030a    	adds.w	r3, r4, r10
 800af7c: 603b         	str	r3, [r7]
 800af7e: eb45 030b    	adc.w	r3, r5, r11
 800af82: 607b         	str	r3, [r7, #0x4]
 800af84: f04f 0200    	mov.w	r2, #0x0
 800af88: f04f 0300    	mov.w	r3, #0x0
 800af8c: e9d7 4500    	ldrd	r4, r5, [r7]
 800af90: 4629         	mov	r1, r5
 800af92: 028b         	lsls	r3, r1, #0xa
 800af94: 4620         	mov	r0, r4
 800af96: 4629         	mov	r1, r5
 800af98: 4604         	mov	r4, r0
 800af9a: ea43 5394    	orr.w	r3, r3, r4, lsr #22
 800af9e: 4601         	mov	r1, r0
 800afa0: 028a         	lsls	r2, r1, #0xa
 800afa2: 4610         	mov	r0, r2
 800afa4: 4619         	mov	r1, r3
 800afa6: 6b7b         	ldr	r3, [r7, #0x34]
 800afa8: 2200         	movs	r2, #0x0
 800afaa: 60bb         	str	r3, [r7, #0x8]
 800afac: 60fa         	str	r2, [r7, #0xc]
 800afae: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800afb2: f7f5 fd9f    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0xa4c2
 800afb6: 4602         	mov	r2, r0
 800afb8: 460b         	mov	r3, r1
 800afba: 4613         	mov	r3, r2
 800afbc: 63fb         	str	r3, [r7, #0x3c]
;       pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) * 2U);
 800afbe: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800afec <HAL_RCC_GetSysClockFreq+0x180>
 800afc0: 685b         	ldr	r3, [r3, #0x4]
 800afc2: 0c1b         	lsrs	r3, r3, #0x10
 800afc4: f003 0303    	and	r3, r3, #0x3
 800afc8: 3301         	adds	r3, #0x1
 800afca: 005b         	lsls	r3, r3, #0x1
 800afcc: 633b         	str	r3, [r7, #0x30]
;       sysclockfreq = pllvco / pllp;
 800afce: 6bfa         	ldr	r2, [r7, #0x3c]
 800afd0: 6b3b         	ldr	r3, [r7, #0x30]
 800afd2: fbb2 f3f3    	udiv	r3, r2, r3
 800afd6: 63bb         	str	r3, [r7, #0x38]
;       break;
 800afd8: e002         	b	0x800afe0 <HAL_RCC_GetSysClockFreq+0x174> @ imm = #0x4
;       sysclockfreq = HSI_VALUE;
 800afda: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800aff0 <HAL_RCC_GetSysClockFreq+0x184>
 800afdc: 63bb         	str	r3, [r7, #0x38]
;       break;
 800afde: bf00         	nop
;   return sysclockfreq;
 800afe0: 6bbb         	ldr	r3, [r7, #0x38]
; }
 800afe2: 4618         	mov	r0, r3
 800afe4: 3740         	adds	r7, #0x40
 800afe6: 46bd         	mov	sp, r7
 800afe8: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800afec <$d>:
 800afec: 00 38 02 40  	.word	0x40023800
 800aff0: 00 24 f4 00  	.word	0x00f42400
 800aff4: 00 1b b7 00  	.word	0x00b71b00

0800aff8 <LL_DMA_ConfigTransfer>:
; {
 800aff8: b480         	push	{r7}
 800affa: b085         	sub	sp, #0x14
 800affc: af00         	add	r7, sp, #0x0
 800affe: 60f8         	str	r0, [r7, #0xc]
 800b000: 60b9         	str	r1, [r7, #0x8]
 800b002: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR,
 800b004: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800b03c <LL_DMA_ConfigTransfer+0x44>
 800b006: 68bb         	ldr	r3, [r7, #0x8]
 800b008: 4413         	add	r3, r2
 800b00a: 781b         	ldrb	r3, [r3]
 800b00c: 461a         	mov	r2, r3
 800b00e: 68fb         	ldr	r3, [r7, #0xc]
 800b010: 4413         	add	r3, r2
 800b012: 681b         	ldr	r3, [r3]
 800b014: f423 335f    	bic	r3, r3, #0x37c00
 800b018: f423 7378    	bic	r3, r3, #0x3e0
 800b01c: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800b03c <LL_DMA_ConfigTransfer+0x44>
 800b01e: 68ba         	ldr	r2, [r7, #0x8]
 800b020: 440a         	add	r2, r1
 800b022: 7812         	ldrb	r2, [r2]
 800b024: 4611         	mov	r1, r2
 800b026: 68fa         	ldr	r2, [r7, #0xc]
 800b028: 440a         	add	r2, r1
 800b02a: 4611         	mov	r1, r2
 800b02c: 687a         	ldr	r2, [r7, #0x4]
 800b02e: 4313         	orrs	r3, r2
 800b030: 600b         	str	r3, [r1]
; }
 800b032: bf00         	nop
 800b034: 3714         	adds	r7, #0x14
 800b036: 46bd         	mov	sp, r7
 800b038: bc80         	pop	{r7}
 800b03a: 4770         	bx	lr

0800b03c <$d>:
 800b03c: 5c bd 01 08  	.word	0x0801bd5c

0800b040 <LL_DMA_SetDataLength>:
; {
 800b040: b480         	push	{r7}
 800b042: b085         	sub	sp, #0x14
 800b044: af00         	add	r7, sp, #0x0
 800b046: 60f8         	str	r0, [r7, #0xc]
 800b048: 60b9         	str	r1, [r7, #0x8]
 800b04a: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT, NbData);
 800b04c: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b080 <LL_DMA_SetDataLength+0x40>
 800b04e: 68bb         	ldr	r3, [r7, #0x8]
 800b050: 4413         	add	r3, r2
 800b052: 781b         	ldrb	r3, [r3]
 800b054: 461a         	mov	r2, r3
 800b056: 68fb         	ldr	r3, [r7, #0xc]
 800b058: 4413         	add	r3, r2
 800b05a: 685b         	ldr	r3, [r3, #0x4]
 800b05c: 0c1b         	lsrs	r3, r3, #0x10
 800b05e: 041b         	lsls	r3, r3, #0x10
 800b060: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800b080 <LL_DMA_SetDataLength+0x40>
 800b062: 68ba         	ldr	r2, [r7, #0x8]
 800b064: 440a         	add	r2, r1
 800b066: 7812         	ldrb	r2, [r2]
 800b068: 4611         	mov	r1, r2
 800b06a: 68fa         	ldr	r2, [r7, #0xc]
 800b06c: 440a         	add	r2, r1
 800b06e: 4611         	mov	r1, r2
 800b070: 687a         	ldr	r2, [r7, #0x4]
 800b072: 4313         	orrs	r3, r2
 800b074: 604b         	str	r3, [r1, #0x4]
; }
 800b076: bf00         	nop
 800b078: 3714         	adds	r7, #0x14
 800b07a: 46bd         	mov	sp, r7
 800b07c: bc80         	pop	{r7}
 800b07e: 4770         	bx	lr

0800b080 <$d>:
 800b080: 5c bd 01 08  	.word	0x0801bd5c

0800b084 <LL_DMA_SetChannelSelection>:
; {
 800b084: b480         	push	{r7}
 800b086: b085         	sub	sp, #0x14
 800b088: af00         	add	r7, sp, #0x0
 800b08a: 60f8         	str	r0, [r7, #0xc]
 800b08c: 60b9         	str	r1, [r7, #0x8]
 800b08e: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_CHSEL, Channel);
 800b090: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b0c4 <LL_DMA_SetChannelSelection+0x40>
 800b092: 68bb         	ldr	r3, [r7, #0x8]
 800b094: 4413         	add	r3, r2
 800b096: 781b         	ldrb	r3, [r3]
 800b098: 461a         	mov	r2, r3
 800b09a: 68fb         	ldr	r3, [r7, #0xc]
 800b09c: 4413         	add	r3, r2
 800b09e: 681b         	ldr	r3, [r3]
 800b0a0: f023 6260    	bic	r2, r3, #0xe000000
 800b0a4: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800b0c4 <LL_DMA_SetChannelSelection+0x40>
 800b0a6: 68bb         	ldr	r3, [r7, #0x8]
 800b0a8: 440b         	add	r3, r1
 800b0aa: 781b         	ldrb	r3, [r3]
 800b0ac: 4619         	mov	r1, r3
 800b0ae: 68fb         	ldr	r3, [r7, #0xc]
 800b0b0: 440b         	add	r3, r1
 800b0b2: 4619         	mov	r1, r3
 800b0b4: 687b         	ldr	r3, [r7, #0x4]
 800b0b6: 4313         	orrs	r3, r2
 800b0b8: 600b         	str	r3, [r1]
; }
 800b0ba: bf00         	nop
 800b0bc: 3714         	adds	r7, #0x14
 800b0be: 46bd         	mov	sp, r7
 800b0c0: bc80         	pop	{r7}
 800b0c2: 4770         	bx	lr

0800b0c4 <$d>:
 800b0c4: 5c bd 01 08  	.word	0x0801bd5c

0800b0c8 <LL_DMA_SetMemoryBurstxfer>:
; {
 800b0c8: b480         	push	{r7}
 800b0ca: b085         	sub	sp, #0x14
 800b0cc: af00         	add	r7, sp, #0x0
 800b0ce: 60f8         	str	r0, [r7, #0xc]
 800b0d0: 60b9         	str	r1, [r7, #0x8]
 800b0d2: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_MBURST, Mburst);
 800b0d4: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b108 <LL_DMA_SetMemoryBurstxfer+0x40>
 800b0d6: 68bb         	ldr	r3, [r7, #0x8]
 800b0d8: 4413         	add	r3, r2
 800b0da: 781b         	ldrb	r3, [r3]
 800b0dc: 461a         	mov	r2, r3
 800b0de: 68fb         	ldr	r3, [r7, #0xc]
 800b0e0: 4413         	add	r3, r2
 800b0e2: 681b         	ldr	r3, [r3]
 800b0e4: f023 72c0    	bic	r2, r3, #0x1800000
 800b0e8: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800b108 <LL_DMA_SetMemoryBurstxfer+0x40>
 800b0ea: 68bb         	ldr	r3, [r7, #0x8]
 800b0ec: 440b         	add	r3, r1
 800b0ee: 781b         	ldrb	r3, [r3]
 800b0f0: 4619         	mov	r1, r3
 800b0f2: 68fb         	ldr	r3, [r7, #0xc]
 800b0f4: 440b         	add	r3, r1
 800b0f6: 4619         	mov	r1, r3
 800b0f8: 687b         	ldr	r3, [r7, #0x4]
 800b0fa: 4313         	orrs	r3, r2
 800b0fc: 600b         	str	r3, [r1]
; }
 800b0fe: bf00         	nop
 800b100: 3714         	adds	r7, #0x14
 800b102: 46bd         	mov	sp, r7
 800b104: bc80         	pop	{r7}
 800b106: 4770         	bx	lr

0800b108 <$d>:
 800b108: 5c bd 01 08  	.word	0x0801bd5c

0800b10c <LL_DMA_SetPeriphBurstxfer>:
; {
 800b10c: b480         	push	{r7}
 800b10e: b085         	sub	sp, #0x14
 800b110: af00         	add	r7, sp, #0x0
 800b112: 60f8         	str	r0, [r7, #0xc]
 800b114: 60b9         	str	r1, [r7, #0x8]
 800b116: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_PBURST, Pburst);
 800b118: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b14c <LL_DMA_SetPeriphBurstxfer+0x40>
 800b11a: 68bb         	ldr	r3, [r7, #0x8]
 800b11c: 4413         	add	r3, r2
 800b11e: 781b         	ldrb	r3, [r3]
 800b120: 461a         	mov	r2, r3
 800b122: 68fb         	ldr	r3, [r7, #0xc]
 800b124: 4413         	add	r3, r2
 800b126: 681b         	ldr	r3, [r3]
 800b128: f423 02c0    	bic	r2, r3, #0x600000
 800b12c: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800b14c <LL_DMA_SetPeriphBurstxfer+0x40>
 800b12e: 68bb         	ldr	r3, [r7, #0x8]
 800b130: 440b         	add	r3, r1
 800b132: 781b         	ldrb	r3, [r3]
 800b134: 4619         	mov	r1, r3
 800b136: 68fb         	ldr	r3, [r7, #0xc]
 800b138: 440b         	add	r3, r1
 800b13a: 4619         	mov	r1, r3
 800b13c: 687b         	ldr	r3, [r7, #0x4]
 800b13e: 4313         	orrs	r3, r2
 800b140: 600b         	str	r3, [r1]
; }
 800b142: bf00         	nop
 800b144: 3714         	adds	r7, #0x14
 800b146: 46bd         	mov	sp, r7
 800b148: bc80         	pop	{r7}
 800b14a: 4770         	bx	lr

0800b14c <$d>:
 800b14c: 5c bd 01 08  	.word	0x0801bd5c

0800b150 <LL_DMA_ConfigFifo>:
; {
 800b150: b480         	push	{r7}
 800b152: b085         	sub	sp, #0x14
 800b154: af00         	add	r7, sp, #0x0
 800b156: 60f8         	str	r0, [r7, #0xc]
 800b158: 60b9         	str	r1, [r7, #0x8]
 800b15a: 607a         	str	r2, [r7, #0x4]
 800b15c: 603b         	str	r3, [r7]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FTH|DMA_SxFCR_DMDIS, FifoMode|FifoThreshold);
 800b15e: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800b194 <LL_DMA_ConfigFifo+0x44>
 800b160: 68bb         	ldr	r3, [r7, #0x8]
 800b162: 4413         	add	r3, r2
 800b164: 781b         	ldrb	r3, [r3]
 800b166: 461a         	mov	r2, r3
 800b168: 68fb         	ldr	r3, [r7, #0xc]
 800b16a: 4413         	add	r3, r2
 800b16c: 695b         	ldr	r3, [r3, #0x14]
 800b16e: f023 0207    	bic	r2, r3, #0x7
 800b172: 6879         	ldr	r1, [r7, #0x4]
 800b174: 683b         	ldr	r3, [r7]
 800b176: 430b         	orrs	r3, r1
 800b178: 4806         	ldr	r0, [pc, #0x18]         @ 0x800b194 <LL_DMA_ConfigFifo+0x44>
 800b17a: 68b9         	ldr	r1, [r7, #0x8]
 800b17c: 4401         	add	r1, r0
 800b17e: 7809         	ldrb	r1, [r1]
 800b180: 4608         	mov	r0, r1
 800b182: 68f9         	ldr	r1, [r7, #0xc]
 800b184: 4401         	add	r1, r0
 800b186: 4313         	orrs	r3, r2
 800b188: 614b         	str	r3, [r1, #0x14]
; }
 800b18a: bf00         	nop
 800b18c: 3714         	adds	r7, #0x14
 800b18e: 46bd         	mov	sp, r7
 800b190: bc80         	pop	{r7}
 800b192: 4770         	bx	lr

0800b194 <$d>:
 800b194: 5c bd 01 08  	.word	0x0801bd5c

0800b198 <LL_DMA_SetMemoryAddress>:
; {
 800b198: b480         	push	{r7}
 800b19a: b085         	sub	sp, #0x14
 800b19c: af00         	add	r7, sp, #0x0
 800b19e: 60f8         	str	r0, [r7, #0xc]
 800b1a0: 60b9         	str	r1, [r7, #0x8]
 800b1a2: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->M0AR, MemoryAddress);
 800b1a4: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800b1c4 <LL_DMA_SetMemoryAddress+0x2c>
 800b1a6: 68bb         	ldr	r3, [r7, #0x8]
 800b1a8: 4413         	add	r3, r2
 800b1aa: 781b         	ldrb	r3, [r3]
 800b1ac: 461a         	mov	r2, r3
 800b1ae: 68fb         	ldr	r3, [r7, #0xc]
 800b1b0: 4413         	add	r3, r2
 800b1b2: 461a         	mov	r2, r3
 800b1b4: 687b         	ldr	r3, [r7, #0x4]
 800b1b6: 60d3         	str	r3, [r2, #0xc]
; }
 800b1b8: bf00         	nop
 800b1ba: 3714         	adds	r7, #0x14
 800b1bc: 46bd         	mov	sp, r7
 800b1be: bc80         	pop	{r7}
 800b1c0: 4770         	bx	lr
 800b1c2: bf00         	nop

0800b1c4 <$d>:
 800b1c4: 5c bd 01 08  	.word	0x0801bd5c

0800b1c8 <LL_DMA_SetPeriphAddress>:
; {
 800b1c8: b480         	push	{r7}
 800b1ca: b085         	sub	sp, #0x14
 800b1cc: af00         	add	r7, sp, #0x0
 800b1ce: 60f8         	str	r0, [r7, #0xc]
 800b1d0: 60b9         	str	r1, [r7, #0x8]
 800b1d2: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->PAR, PeriphAddress);
 800b1d4: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800b1f4 <LL_DMA_SetPeriphAddress+0x2c>
 800b1d6: 68bb         	ldr	r3, [r7, #0x8]
 800b1d8: 4413         	add	r3, r2
 800b1da: 781b         	ldrb	r3, [r3]
 800b1dc: 461a         	mov	r2, r3
 800b1de: 68fb         	ldr	r3, [r7, #0xc]
 800b1e0: 4413         	add	r3, r2
 800b1e2: 461a         	mov	r2, r3
 800b1e4: 687b         	ldr	r3, [r7, #0x4]
 800b1e6: 6093         	str	r3, [r2, #0x8]
; }
 800b1e8: bf00         	nop
 800b1ea: 3714         	adds	r7, #0x14
 800b1ec: 46bd         	mov	sp, r7
 800b1ee: bc80         	pop	{r7}
 800b1f0: 4770         	bx	lr
 800b1f2: bf00         	nop

0800b1f4 <$d>:
 800b1f4: 5c bd 01 08  	.word	0x0801bd5c

0800b1f8 <LL_FLASH_SetLatency>:
; {
 800b1f8: b480         	push	{r7}
 800b1fa: b083         	sub	sp, #0xc
 800b1fc: af00         	add	r7, sp, #0x0
 800b1fe: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 800b200: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800b21c <LL_FLASH_SetLatency+0x24>
 800b202: 681b         	ldr	r3, [r3]
 800b204: f023 0207    	bic	r2, r3, #0x7
 800b208: 4904         	ldr	r1, [pc, #0x10]         @ 0x800b21c <LL_FLASH_SetLatency+0x24>
 800b20a: 687b         	ldr	r3, [r7, #0x4]
 800b20c: 4313         	orrs	r3, r2
 800b20e: 600b         	str	r3, [r1]
; }
 800b210: bf00         	nop
 800b212: 370c         	adds	r7, #0xc
 800b214: 46bd         	mov	sp, r7
 800b216: bc80         	pop	{r7}
 800b218: 4770         	bx	lr
 800b21a: bf00         	nop

0800b21c <$d>:
 800b21c: 00 3c 02 40  	.word	0x40023c00

0800b220 <LL_FLASH_GetLatency>:
; {
 800b220: b480         	push	{r7}
 800b222: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
 800b224: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800b234 <LL_FLASH_GetLatency+0x14>
 800b226: 681b         	ldr	r3, [r3]
 800b228: f003 0307    	and	r3, r3, #0x7
; }
 800b22c: 4618         	mov	r0, r3
 800b22e: 46bd         	mov	sp, r7
 800b230: bc80         	pop	{r7}
 800b232: 4770         	bx	lr

0800b234 <$d>:
 800b234: 00 3c 02 40  	.word	0x40023c00

0800b238 <LL_PWR_GetRegulVoltageScaling>:
; {
 800b238: b480         	push	{r7}
 800b23a: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(PWR->CR, PWR_CR_VOS));
 800b23c: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800b24c <LL_PWR_GetRegulVoltageScaling+0x14>
 800b23e: 681b         	ldr	r3, [r3]
 800b240: f403 4380    	and	r3, r3, #0x4000
; }
 800b244: 4618         	mov	r0, r3
 800b246: 46bd         	mov	sp, r7
 800b248: bc80         	pop	{r7}
 800b24a: 4770         	bx	lr

0800b24c <$d>:
 800b24c: 00 70 00 40  	.word	0x40007000

0800b250 <LL_SetFlashLatency>:
; {
 800b250: b580         	push	{r7, lr}
 800b252: b086         	sub	sp, #0x18
 800b254: af00         	add	r7, sp, #0x0
 800b256: 6078         	str	r0, [r7, #0x4]
;   uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */
 800b258: 2300         	movs	r3, #0x0
 800b25a: 613b         	str	r3, [r7, #0x10]
;   ErrorStatus status = SUCCESS;
 800b25c: 2300         	movs	r3, #0x0
 800b25e: 73fb         	strb	r3, [r7, #0xf]
;   if(HCLK_Frequency == 0U)
 800b260: 687b         	ldr	r3, [r7, #0x4]
 800b262: 2b00         	cmp	r3, #0x0
 800b264: d102         	bne	0x800b26c <LL_SetFlashLatency+0x1c> @ imm = #0x4
;     status = ERROR;
 800b266: 2301         	movs	r3, #0x1
 800b268: 73fb         	strb	r3, [r7, #0xf]
 800b26a: e078         	b	0x800b35e <LL_SetFlashLatency+0x10e> @ imm = #0xf0
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)
 800b26c: f7ff ffe4    	bl	0x800b238 <LL_PWR_GetRegulVoltageScaling> @ imm = #-0x38
 800b270: 4603         	mov	r3, r0
 800b272: f5b3 4f80    	cmp.w	r3, #0x4000
 800b276: d12d         	bne	0x800b2d4 <LL_SetFlashLatency+0x84> @ imm = #0x5a
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY5_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800b278: 687b         	ldr	r3, [r7, #0x4]
 800b27a: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x800b368 <LL_SetFlashLatency+0x118>
 800b27c: 4293         	cmp	r3, r2
 800b27e: d904         	bls	0x800b28a <LL_SetFlashLatency+0x3a> @ imm = #0x8
 800b280: 693b         	ldr	r3, [r7, #0x10]
 800b282: 2b00         	cmp	r3, #0x0
 800b284: d101         	bne	0x800b28a <LL_SetFlashLatency+0x3a> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_5;
 800b286: 2305         	movs	r3, #0x5
 800b288: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800b28a: 687b         	ldr	r3, [r7, #0x4]
 800b28c: 4a37         	ldr	r2, [pc, #0xdc]         @ 0x800b36c <LL_SetFlashLatency+0x11c>
 800b28e: 4293         	cmp	r3, r2
 800b290: d904         	bls	0x800b29c <LL_SetFlashLatency+0x4c> @ imm = #0x8
 800b292: 693b         	ldr	r3, [r7, #0x10]
 800b294: 2b00         	cmp	r3, #0x0
 800b296: d101         	bne	0x800b29c <LL_SetFlashLatency+0x4c> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_4;
 800b298: 2304         	movs	r3, #0x4
 800b29a: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800b29c: 687b         	ldr	r3, [r7, #0x4]
 800b29e: 4a34         	ldr	r2, [pc, #0xd0]         @ 0x800b370 <LL_SetFlashLatency+0x120>
 800b2a0: 4293         	cmp	r3, r2
 800b2a2: d904         	bls	0x800b2ae <LL_SetFlashLatency+0x5e> @ imm = #0x8
 800b2a4: 693b         	ldr	r3, [r7, #0x10]
 800b2a6: 2b00         	cmp	r3, #0x0
 800b2a8: d101         	bne	0x800b2ae <LL_SetFlashLatency+0x5e> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_3;
 800b2aa: 2303         	movs	r3, #0x3
 800b2ac: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800b2ae: 687b         	ldr	r3, [r7, #0x4]
 800b2b0: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x800b374 <LL_SetFlashLatency+0x124>
 800b2b2: 4293         	cmp	r3, r2
 800b2b4: d905         	bls	0x800b2c2 <LL_SetFlashLatency+0x72> @ imm = #0xa
 800b2b6: 693b         	ldr	r3, [r7, #0x10]
 800b2b8: 2b00         	cmp	r3, #0x0
 800b2ba: d102         	bne	0x800b2c2 <LL_SetFlashLatency+0x72> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 800b2bc: 2302         	movs	r3, #0x2
 800b2be: 613b         	str	r3, [r7, #0x10]
 800b2c0: e008         	b	0x800b2d4 <LL_SetFlashLatency+0x84> @ imm = #0x10
;         if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800b2c2: 687b         	ldr	r3, [r7, #0x4]
 800b2c4: 4a2c         	ldr	r2, [pc, #0xb0]         @ 0x800b378 <LL_SetFlashLatency+0x128>
 800b2c6: 4293         	cmp	r3, r2
 800b2c8: d904         	bls	0x800b2d4 <LL_SetFlashLatency+0x84> @ imm = #0x8
 800b2ca: 693b         	ldr	r3, [r7, #0x10]
 800b2cc: 2b00         	cmp	r3, #0x0
 800b2ce: d101         	bne	0x800b2d4 <LL_SetFlashLatency+0x84> @ imm = #0x2
;           latency = LL_FLASH_LATENCY_1;
 800b2d0: 2301         	movs	r3, #0x1
 800b2d2: 613b         	str	r3, [r7, #0x10]
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2)
 800b2d4: f7ff ffb0    	bl	0x800b238 <LL_PWR_GetRegulVoltageScaling> @ imm = #-0xa0
 800b2d8: 4603         	mov	r3, r0
 800b2da: 2b00         	cmp	r3, #0x0
 800b2dc: d124         	bne	0x800b328 <LL_SetFlashLatency+0xd8> @ imm = #0x48
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800b2de: 687b         	ldr	r3, [r7, #0x4]
 800b2e0: 4a22         	ldr	r2, [pc, #0x88]         @ 0x800b36c <LL_SetFlashLatency+0x11c>
 800b2e2: 4293         	cmp	r3, r2
 800b2e4: d904         	bls	0x800b2f0 <LL_SetFlashLatency+0xa0> @ imm = #0x8
 800b2e6: 693b         	ldr	r3, [r7, #0x10]
 800b2e8: 2b00         	cmp	r3, #0x0
 800b2ea: d101         	bne	0x800b2f0 <LL_SetFlashLatency+0xa0> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_4;
 800b2ec: 2304         	movs	r3, #0x4
 800b2ee: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800b2f0: 687b         	ldr	r3, [r7, #0x4]
 800b2f2: 4a1f         	ldr	r2, [pc, #0x7c]         @ 0x800b370 <LL_SetFlashLatency+0x120>
 800b2f4: 4293         	cmp	r3, r2
 800b2f6: d904         	bls	0x800b302 <LL_SetFlashLatency+0xb2> @ imm = #0x8
 800b2f8: 693b         	ldr	r3, [r7, #0x10]
 800b2fa: 2b00         	cmp	r3, #0x0
 800b2fc: d101         	bne	0x800b302 <LL_SetFlashLatency+0xb2> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_3;
 800b2fe: 2303         	movs	r3, #0x3
 800b300: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800b302: 687b         	ldr	r3, [r7, #0x4]
 800b304: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800b374 <LL_SetFlashLatency+0x124>
 800b306: 4293         	cmp	r3, r2
 800b308: d905         	bls	0x800b316 <LL_SetFlashLatency+0xc6> @ imm = #0xa
 800b30a: 693b         	ldr	r3, [r7, #0x10]
 800b30c: 2b00         	cmp	r3, #0x0
 800b30e: d102         	bne	0x800b316 <LL_SetFlashLatency+0xc6> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 800b310: 2302         	movs	r3, #0x2
 800b312: 613b         	str	r3, [r7, #0x10]
 800b314: e008         	b	0x800b328 <LL_SetFlashLatency+0xd8> @ imm = #0x10
;         if((HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800b316: 687b         	ldr	r3, [r7, #0x4]
 800b318: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800b378 <LL_SetFlashLatency+0x128>
 800b31a: 4293         	cmp	r3, r2
 800b31c: d904         	bls	0x800b328 <LL_SetFlashLatency+0xd8> @ imm = #0x8
 800b31e: 693b         	ldr	r3, [r7, #0x10]
 800b320: 2b00         	cmp	r3, #0x0
 800b322: d101         	bne	0x800b328 <LL_SetFlashLatency+0xd8> @ imm = #0x2
;           latency = LL_FLASH_LATENCY_1;
 800b324: 2301         	movs	r3, #0x1
 800b326: 613b         	str	r3, [r7, #0x10]
;     LL_FLASH_SetLatency(latency);
 800b328: 6938         	ldr	r0, [r7, #0x10]
 800b32a: f7ff ff65    	bl	0x800b1f8 <LL_FLASH_SetLatency> @ imm = #-0x136
;     timeout = 2;
 800b32e: 2302         	movs	r3, #0x2
 800b330: 617b         	str	r3, [r7, #0x14]
;     getlatency = LL_FLASH_GetLatency();
 800b332: f7ff ff75    	bl	0x800b220 <LL_FLASH_GetLatency> @ imm = #-0x116
 800b336: 60b8         	str	r0, [r7, #0x8]
;     timeout--;
 800b338: 697b         	ldr	r3, [r7, #0x14]
 800b33a: 3b01         	subs	r3, #0x1
 800b33c: 617b         	str	r3, [r7, #0x14]
;     } while ((getlatency != latency) && (timeout > 0));
 800b33e: 68ba         	ldr	r2, [r7, #0x8]
 800b340: 693b         	ldr	r3, [r7, #0x10]
 800b342: 429a         	cmp	r2, r3
 800b344: d002         	beq	0x800b34c <LL_SetFlashLatency+0xfc> @ imm = #0x4
 800b346: 697b         	ldr	r3, [r7, #0x14]
 800b348: 2b00         	cmp	r3, #0x0
 800b34a: d1f2         	bne	0x800b332 <LL_SetFlashLatency+0xe2> @ imm = #-0x1c
;     if(getlatency != latency)
 800b34c: 68ba         	ldr	r2, [r7, #0x8]
 800b34e: 693b         	ldr	r3, [r7, #0x10]
 800b350: 429a         	cmp	r2, r3
 800b352: d002         	beq	0x800b35a <LL_SetFlashLatency+0x10a> @ imm = #0x4
;       status = ERROR;
 800b354: 2301         	movs	r3, #0x1
 800b356: 73fb         	strb	r3, [r7, #0xf]
 800b358: e001         	b	0x800b35e <LL_SetFlashLatency+0x10e> @ imm = #0x2
;       status = SUCCESS;
 800b35a: 2300         	movs	r3, #0x0
 800b35c: 73fb         	strb	r3, [r7, #0xf]
;   return status;
 800b35e: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 800b360: 4618         	mov	r0, r3
 800b362: 3718         	adds	r7, #0x18
 800b364: 46bd         	mov	sp, r7
 800b366: bd80         	pop	{r7, pc}

0800b368 <$d>:
 800b368: 80 d1 f0 08  	.word	0x08f0d180
 800b36c: 00 0e 27 07  	.word	0x07270e00
 800b370: 80 4a 5d 05  	.word	0x055d4a80
 800b374: 00 87 93 03  	.word	0x03938700
 800b378: 80 c3 c9 01  	.word	0x01c9c380

0800b37c <z_device_state_init>:
; {
 800b37c: b580         	push	{r7, lr}
 800b37e: b082         	sub	sp, #0x8
 800b380: af00         	add	r7, sp, #0x0
; 	STRUCT_SECTION_FOREACH(device, dev) {
 800b382: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b3b0 <z_device_state_init+0x34>
 800b384: 607b         	str	r3, [r7, #0x4]
 800b386: e005         	b	0x800b394 <z_device_state_init+0x18> @ imm = #0xa
; 		k_object_init(dev);
 800b388: 6878         	ldr	r0, [r7, #0x4]
 800b38a: f00b fd1d    	bl	0x8016dc8 <k_object_init> @ imm = #0xba3a
; 	STRUCT_SECTION_FOREACH(device, dev) {
 800b38e: 687b         	ldr	r3, [r7, #0x4]
 800b390: 3314         	adds	r3, #0x14
 800b392: 607b         	str	r3, [r7, #0x4]
 800b394: 687b         	ldr	r3, [r7, #0x4]
 800b396: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800b3b4 <z_device_state_init+0x38>
 800b398: 4293         	cmp	r3, r2
 800b39a: bf34         	ite	lo
 800b39c: 2301         	movlo	r3, #0x1
 800b39e: 2300         	movhs	r3, #0x0
 800b3a0: b2db         	uxtb	r3, r3
 800b3a2: 2b00         	cmp	r3, #0x0
 800b3a4: d1f0         	bne	0x800b388 <z_device_state_init+0xc> @ imm = #-0x20
; }
 800b3a6: bf00         	nop
 800b3a8: bf00         	nop
 800b3aa: 3708         	adds	r7, #0x8
 800b3ac: 46bd         	mov	sp, r7
 800b3ae: bd80         	pop	{r7, pc}

0800b3b0 <$d>:
 800b3b0: 1c 92 01 08  	.word	0x0801921c
 800b3b4: 38 94 01 08  	.word	0x08019438

0800b3b8 <k_sys_fatal_error_handler>:
; {
 800b3b8: b580         	push	{r7, lr}
 800b3ba: b088         	sub	sp, #0x20
 800b3bc: af04         	add	r7, sp, #0x10
 800b3be: 6078         	str	r0, [r7, #0x4]
 800b3c0: 6039         	str	r1, [r7]
; 	LOG_PANIC();
 800b3c2: f00b fd54    	bl	0x8016e6e <log_panic>   @ imm = #0xbaa8
; 	LOG_ERR("Halting system");
 800b3c6: 2303         	movs	r3, #0x3
 800b3c8: 2b00         	cmp	r3, #0x0
 800b3ca: d016         	beq	0x800b3fa <k_sys_fatal_error_handler+0x42> @ imm = #0x2c
 800b3cc: 2301         	movs	r3, #0x1
 800b3ce: 73fb         	strb	r3, [r7, #0xf]
 800b3d0: 7bfb         	ldrb	r3, [r7, #0xf]
 800b3d2: f083 0301    	eor	r3, r3, #0x1
 800b3d6: b2db         	uxtb	r3, r3
 800b3d8: 2b00         	cmp	r3, #0x0
 800b3da: d10e         	bne	0x800b3fa <k_sys_fatal_error_handler+0x42> @ imm = #0x1c
 800b3dc: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800b400 <k_sys_fatal_error_handler+0x48>
 800b3de: 6819         	ldr	r1, [r3]
 800b3e0: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800b404 <k_sys_fatal_error_handler+0x4c>
 800b3e2: 9302         	str	r3, [sp, #0x8]
 800b3e4: 2300         	movs	r3, #0x0
 800b3e6: 9301         	str	r3, [sp, #0x4]
 800b3e8: 2300         	movs	r3, #0x0
 800b3ea: 9300         	str	r3, [sp]
 800b3ec: 2300         	movs	r3, #0x0
 800b3ee: 2201         	movs	r2, #0x1
 800b3f0: 2000         	movs	r0, #0x0
 800b3f2: f00b fd1e    	bl	0x8016e32 <z_log_msg_runtime_create> @ imm = #0xba3c
 800b3f6: 2300         	movs	r3, #0x0
 800b3f8: 60bb         	str	r3, [r7, #0x8]
; 	arch_system_halt(reason);
 800b3fa: 6878         	ldr	r0, [r7, #0x4]
 800b3fc: f00b fd48    	bl	0x8016e90 <arch_system_halt> @ imm = #0xba90

0800b400 <$d>:
 800b400: 28 05 00 20  	.word	0x20000528
 800b404: fc ad 01 08  	.word	0x0801adfc

0800b408 <thread_name_get>:
; {
 800b408: b580         	push	{r7, lr}
 800b40a: b084         	sub	sp, #0x10
 800b40c: af00         	add	r7, sp, #0x0
 800b40e: 6078         	str	r0, [r7, #0x4]
; 	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
 800b410: 687b         	ldr	r3, [r7, #0x4]
 800b412: 2b00         	cmp	r3, #0x0
 800b414: d004         	beq	0x800b420 <thread_name_get+0x18> @ imm = #0x8
 800b416: 6878         	ldr	r0, [r7, #0x4]
 800b418: f00c fe18    	bl	0x801804c <k_thread_name_get> @ imm = #0xcc30
 800b41c: 4603         	mov	r3, r0
 800b41e: e000         	b	0x800b422 <thread_name_get+0x1a> @ imm = #0x0
 800b420: 2300         	movs	r3, #0x0
 800b422: 60fb         	str	r3, [r7, #0xc]
; 	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
 800b424: 68fb         	ldr	r3, [r7, #0xc]
 800b426: 2b00         	cmp	r3, #0x0
 800b428: d003         	beq	0x800b432 <thread_name_get+0x2a> @ imm = #0x6
 800b42a: 68fb         	ldr	r3, [r7, #0xc]
 800b42c: 781b         	ldrb	r3, [r3]
 800b42e: 2b00         	cmp	r3, #0x0
 800b430: d101         	bne	0x800b436 <thread_name_get+0x2e> @ imm = #0x2
; 		thread_name = "unknown";
 800b432: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800b440 <thread_name_get+0x38>
 800b434: 60fb         	str	r3, [r7, #0xc]
; 	return thread_name;
 800b436: 68fb         	ldr	r3, [r7, #0xc]
; }
 800b438: 4618         	mov	r0, r3
 800b43a: 3710         	adds	r7, #0x10
 800b43c: 46bd         	mov	sp, r7
 800b43e: bd80         	pop	{r7, pc}

0800b440 <$d>:
 800b440: 0c ae 01 08  	.word	0x0801ae0c

0800b444 <reason_to_str>:
; {
 800b444: b480         	push	{r7}
 800b446: b083         	sub	sp, #0xc
 800b448: af00         	add	r7, sp, #0x0
 800b44a: 6078         	str	r0, [r7, #0x4]
; 	switch (reason) {
 800b44c: 687b         	ldr	r3, [r7, #0x4]
 800b44e: 2b04         	cmp	r3, #0x4
 800b450: d816         	bhi	0x800b480 <reason_to_str+0x3c> @ imm = #0x2c
 800b452: a201         	adr	r2, #4 <reason_to_str+0x13>
 800b454: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800b458 <$d>:
 800b458: 6d b4 00 08  	.word	0x0800b46d
 800b45c: 71 b4 00 08  	.word	0x0800b471
 800b460: 75 b4 00 08  	.word	0x0800b475
 800b464: 79 b4 00 08  	.word	0x0800b479
 800b468: 7d b4 00 08  	.word	0x0800b47d

0800b46c <$t>:
; 		return "CPU exception";
 800b46c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800b48c <reason_to_str+0x48>
 800b46e: e008         	b	0x800b482 <reason_to_str+0x3e> @ imm = #0x10
; 		return "Unhandled interrupt";
 800b470: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800b490 <reason_to_str+0x4c>
 800b472: e006         	b	0x800b482 <reason_to_str+0x3e> @ imm = #0xc
; 		return "Stack overflow";
 800b474: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800b494 <reason_to_str+0x50>
 800b476: e004         	b	0x800b482 <reason_to_str+0x3e> @ imm = #0x8
; 		return "Kernel oops";
 800b478: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800b498 <reason_to_str+0x54>
 800b47a: e002         	b	0x800b482 <reason_to_str+0x3e> @ imm = #0x4
; 		return "Kernel panic";
 800b47c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800b49c <reason_to_str+0x58>
 800b47e: e000         	b	0x800b482 <reason_to_str+0x3e> @ imm = #0x0
; 		return "Unknown error";
 800b480: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800b4a0 <reason_to_str+0x5c>
; }
 800b482: 4618         	mov	r0, r3
 800b484: 370c         	adds	r7, #0xc
 800b486: 46bd         	mov	sp, r7
 800b488: bc80         	pop	{r7}
 800b48a: 4770         	bx	lr

0800b48c <$d>:
 800b48c: 14 ae 01 08  	.word	0x0801ae14
 800b490: 24 ae 01 08  	.word	0x0801ae24
 800b494: 38 ae 01 08  	.word	0x0801ae38
 800b498: 48 ae 01 08  	.word	0x0801ae48
 800b49c: 54 ae 01 08  	.word	0x0801ae54
 800b4a0: 64 ae 01 08  	.word	0x0801ae64

0800b4a4 <z_fatal_error>:
; {
 800b4a4: b590         	push	{r4, r7, lr}
 800b4a6: b099         	sub	sp, #0x64
 800b4a8: af06         	add	r7, sp, #0x18
 800b4aa: 6078         	str	r0, [r7, #0x4]
 800b4ac: 6039         	str	r1, [r7]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b4ae: f3ef 8311    	mrs	r3, basepri
 800b4b2: 627b         	str	r3, [r7, #0x24]
;   return(result);
 800b4b4: 6a7b         	ldr	r3, [r7, #0x24]
; 	key = __get_BASEPRI();
 800b4b6: 623b         	str	r3, [r7, #0x20]
 800b4b8: 2310         	movs	r3, #0x10
 800b4ba: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800b4bc: 69fb         	ldr	r3, [r7, #0x1c]
 800b4be: f383 8812    	msr	basepri_max, r3
; }
 800b4c2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800b4c4: f3bf 8f6f    	isb	sy
; }
 800b4c8: bf00         	nop
; 	return key;
 800b4ca: 6a3b         	ldr	r3, [r7, #0x20]
; 	unsigned int key = arch_irq_lock();
 800b4cc: 63bb         	str	r3, [r7, #0x38]
; 	struct k_thread *thread = IS_ENABLED(CONFIG_MULTITHREADING) ?
 800b4ce: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x800b60c <z_fatal_error+0x168>
 800b4d0: 689b         	ldr	r3, [r3, #0x8]
 800b4d2: 643b         	str	r3, [r7, #0x40]
; 	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
 800b4d4: 2303         	movs	r3, #0x3
 800b4d6: 2b00         	cmp	r3, #0x0
 800b4d8: d023         	beq	0x800b522 <z_fatal_error+0x7e> @ imm = #0x46
 800b4da: 2301         	movs	r3, #0x1
 800b4dc: f887 303f    	strb.w	r3, [r7, #0x3f]
 800b4e0: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800b4e4: f083 0301    	eor	r3, r3, #0x1
 800b4e8: b2db         	uxtb	r3, r3
 800b4ea: 2b00         	cmp	r3, #0x0
 800b4ec: d119         	bne	0x800b522 <z_fatal_error+0x7e> @ imm = #0x32
 800b4ee: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800b610 <z_fatal_error+0x16c>
 800b4f0: 681c         	ldr	r4, [r3]
 800b4f2: 6878         	ldr	r0, [r7, #0x4]
 800b4f4: f7ff ffa6    	bl	0x800b444 <reason_to_str> @ imm = #-0xb4
 800b4f8: 4603         	mov	r3, r0
 800b4fa: 4a44         	ldr	r2, [pc, #0x110]        @ 0x800b60c <z_fatal_error+0x168>
 800b4fc: 7c12         	ldrb	r2, [r2, #0x10]
 800b4fe: 9205         	str	r2, [sp, #0x14]
 800b500: 9304         	str	r3, [sp, #0x10]
 800b502: 687b         	ldr	r3, [r7, #0x4]
 800b504: 9303         	str	r3, [sp, #0xc]
 800b506: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800b614 <z_fatal_error+0x170>
 800b508: 9302         	str	r3, [sp, #0x8]
 800b50a: 2300         	movs	r3, #0x0
 800b50c: 9301         	str	r3, [sp, #0x4]
 800b50e: 2300         	movs	r3, #0x0
 800b510: 9300         	str	r3, [sp]
 800b512: 2300         	movs	r3, #0x0
 800b514: 2201         	movs	r2, #0x1
 800b516: 4621         	mov	r1, r4
 800b518: 2000         	movs	r0, #0x0
 800b51a: f00b fc8a    	bl	0x8016e32 <z_log_msg_runtime_create> @ imm = #0xb914
 800b51e: 2300         	movs	r3, #0x0
 800b520: 647b         	str	r3, [r7, #0x44]
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 800b522: 683b         	ldr	r3, [r7]
 800b524: 2b00         	cmp	r3, #0x0
 800b526: d028         	beq	0x800b57a <z_fatal_error+0xd6> @ imm = #0x50
 800b528: 683b         	ldr	r3, [r7]
 800b52a: 61bb         	str	r3, [r7, #0x18]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 800b52c: 69bb         	ldr	r3, [r7, #0x18]
 800b52e: 69db         	ldr	r3, [r3, #0x1c]
 800b530: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 800b534: 2b00         	cmp	r3, #0x0
 800b536: bf14         	ite	ne
 800b538: 2301         	movne	r3, #0x1
 800b53a: 2300         	moveq	r3, #0x0
 800b53c: b2db         	uxtb	r3, r3
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 800b53e: 2b00         	cmp	r3, #0x0
 800b540: d01b         	beq	0x800b57a <z_fatal_error+0xd6> @ imm = #0x36
; 		LOG_ERR("Fault during interrupt handling\n");
 800b542: 2303         	movs	r3, #0x3
 800b544: 2b00         	cmp	r3, #0x0
 800b546: d018         	beq	0x800b57a <z_fatal_error+0xd6> @ imm = #0x30
 800b548: 2301         	movs	r3, #0x1
 800b54a: f887 3037    	strb.w	r3, [r7, #0x37]
 800b54e: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800b552: f083 0301    	eor	r3, r3, #0x1
 800b556: b2db         	uxtb	r3, r3
 800b558: 2b00         	cmp	r3, #0x0
 800b55a: d10e         	bne	0x800b57a <z_fatal_error+0xd6> @ imm = #0x1c
 800b55c: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800b610 <z_fatal_error+0x16c>
 800b55e: 6819         	ldr	r1, [r3]
 800b560: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x800b618 <z_fatal_error+0x174>
 800b562: 9302         	str	r3, [sp, #0x8]
 800b564: 2300         	movs	r3, #0x0
 800b566: 9301         	str	r3, [sp, #0x4]
 800b568: 2300         	movs	r3, #0x0
 800b56a: 9300         	str	r3, [sp]
 800b56c: 2300         	movs	r3, #0x0
 800b56e: 2201         	movs	r2, #0x1
 800b570: 2000         	movs	r0, #0x0
 800b572: f00b fc5e    	bl	0x8016e32 <z_log_msg_runtime_create> @ imm = #0xb8bc
 800b576: 2300         	movs	r3, #0x0
 800b578: 633b         	str	r3, [r7, #0x30]
; 		LOG_ERR("Current thread: %p (%s)", thread, thread_name_get(thread));
 800b57a: 2303         	movs	r3, #0x3
 800b57c: 2b00         	cmp	r3, #0x0
 800b57e: d020         	beq	0x800b5c2 <z_fatal_error+0x11e> @ imm = #0x40
 800b580: 2301         	movs	r3, #0x1
 800b582: f887 302f    	strb.w	r3, [r7, #0x2f]
 800b586: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800b58a: f083 0301    	eor	r3, r3, #0x1
 800b58e: b2db         	uxtb	r3, r3
 800b590: 2b00         	cmp	r3, #0x0
 800b592: d116         	bne	0x800b5c2 <z_fatal_error+0x11e> @ imm = #0x2c
 800b594: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800b610 <z_fatal_error+0x16c>
 800b596: 681c         	ldr	r4, [r3]
 800b598: 6c38         	ldr	r0, [r7, #0x40]
 800b59a: f7ff ff35    	bl	0x800b408 <thread_name_get> @ imm = #-0x196
 800b59e: 4603         	mov	r3, r0
 800b5a0: 9304         	str	r3, [sp, #0x10]
 800b5a2: 6c3b         	ldr	r3, [r7, #0x40]
 800b5a4: 9303         	str	r3, [sp, #0xc]
 800b5a6: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800b61c <z_fatal_error+0x178>
 800b5a8: 9302         	str	r3, [sp, #0x8]
 800b5aa: 2300         	movs	r3, #0x0
 800b5ac: 9301         	str	r3, [sp, #0x4]
 800b5ae: 2300         	movs	r3, #0x0
 800b5b0: 9300         	str	r3, [sp]
 800b5b2: 2300         	movs	r3, #0x0
 800b5b4: 2201         	movs	r2, #0x1
 800b5b6: 4621         	mov	r1, r4
 800b5b8: 2000         	movs	r0, #0x0
 800b5ba: f00b fc3a    	bl	0x8016e32 <z_log_msg_runtime_create> @ imm = #0xb874
 800b5be: 2300         	movs	r3, #0x0
 800b5c0: 62bb         	str	r3, [r7, #0x28]
; 	coredump(reason, esf, thread);
 800b5c2: 6c3a         	ldr	r2, [r7, #0x40]
 800b5c4: 6839         	ldr	r1, [r7]
 800b5c6: 6878         	ldr	r0, [r7, #0x4]
 800b5c8: f00b fc57    	bl	0x8016e7a <coredump>    @ imm = #0xb8ae
; 	k_sys_fatal_error_handler(reason, esf);
 800b5cc: 6839         	ldr	r1, [r7]
 800b5ce: 6878         	ldr	r0, [r7, #0x4]
 800b5d0: f7ff fef2    	bl	0x800b3b8 <k_sys_fatal_error_handler> @ imm = #-0x21c
; 		if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 800b5d4: 683b         	ldr	r3, [r7]
 800b5d6: 2b00         	cmp	r3, #0x0
 800b5d8: d006         	beq	0x800b5e8 <z_fatal_error+0x144> @ imm = #0xc
 800b5da: 683b         	ldr	r3, [r7]
 800b5dc: 617b         	str	r3, [r7, #0x14]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 800b5de: 697b         	ldr	r3, [r7, #0x14]
 800b5e0: 69db         	ldr	r3, [r3, #0x1c]
 800b5e2: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 800b5e6: 2b00         	cmp	r3, #0x0
 800b5e8: 6bbb         	ldr	r3, [r7, #0x38]
 800b5ea: 613b         	str	r3, [r7, #0x10]
 800b5ec: 693b         	ldr	r3, [r7, #0x10]
 800b5ee: 60fb         	str	r3, [r7, #0xc]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800b5f0: 68fb         	ldr	r3, [r7, #0xc]
 800b5f2: f383 8811    	msr	basepri, r3
; }
 800b5f6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800b5f8: f3bf 8f6f    	isb	sy
; }
 800b5fc: bf00         	nop
; }
 800b5fe: bf00         	nop
; 		k_thread_abort(thread);
 800b600: 6c38         	ldr	r0, [r7, #0x40]
 800b602: f00b fc0b    	bl	0x8016e1c <k_thread_abort> @ imm = #0xb816
; }
 800b606: 374c         	adds	r7, #0x4c
 800b608: 46bd         	mov	sp, r7
 800b60a: bd90         	pop	{r4, r7, pc}

0800b60c <$d>:
 800b60c: c8 06 00 20  	.word	0x200006c8
 800b610: 28 05 00 20  	.word	0x20000528
 800b614: 74 ae 01 08  	.word	0x0801ae74
 800b618: 9c ae 01 08  	.word	0x0801ae9c
 800b61c: c0 ae 01 08  	.word	0x0801aec0

0800b620 <__NVIC_SetPriority>:
; {
 800b620: b480         	push	{r7}
 800b622: b083         	sub	sp, #0xc
 800b624: af00         	add	r7, sp, #0x0
 800b626: 4603         	mov	r3, r0
 800b628: 6039         	str	r1, [r7]
 800b62a: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 800b62c: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800b630: 2b00         	cmp	r3, #0x0
 800b632: db0a         	blt	0x800b64a <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b634: 683b         	ldr	r3, [r7]
 800b636: b2da         	uxtb	r2, r3
 800b638: 490c         	ldr	r1, [pc, #0x30]         @ 0x800b66c <__NVIC_SetPriority+0x4c>
 800b63a: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800b63e: 0112         	lsls	r2, r2, #0x4
 800b640: b2d2         	uxtb	r2, r2
 800b642: 440b         	add	r3, r1
 800b644: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 800b648: e00a         	b	0x800b660 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b64a: 683b         	ldr	r3, [r7]
 800b64c: b2da         	uxtb	r2, r3
 800b64e: 4908         	ldr	r1, [pc, #0x20]         @ 0x800b670 <__NVIC_SetPriority+0x50>
 800b650: 79fb         	ldrb	r3, [r7, #0x7]
 800b652: f003 030f    	and	r3, r3, #0xf
 800b656: 3b04         	subs	r3, #0x4
 800b658: 0112         	lsls	r2, r2, #0x4
 800b65a: b2d2         	uxtb	r2, r2
 800b65c: 440b         	add	r3, r1
 800b65e: 761a         	strb	r2, [r3, #0x18]
; }
 800b660: bf00         	nop
 800b662: 370c         	adds	r7, #0xc
 800b664: 46bd         	mov	sp, r7
 800b666: bc80         	pop	{r7}
 800b668: 4770         	bx	lr
 800b66a: bf00         	nop

0800b66c <$d>:
 800b66c: 00 e1 00 e0  	.word	0xe000e100
 800b670: 00 ed 00 e0  	.word	0xe000ed00

0800b674 <z_add_thread_timeout>:
; {
 800b674: b580         	push	{r7, lr}
 800b676: b084         	sub	sp, #0x10
 800b678: af00         	add	r7, sp, #0x0
 800b67a: 60f8         	str	r0, [r7, #0xc]
 800b67c: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 800b680: 68fb         	ldr	r3, [r7, #0xc]
 800b682: f103 0018    	add.w	r0, r3, #0x18
 800b686: e9d7 2300    	ldrd	r2, r3, [r7]
 800b68a: 4903         	ldr	r1, [pc, #0xc]          @ 0x800b698 <z_add_thread_timeout+0x24>
 800b68c: f003 f8fe    	bl	0x800e88c <z_add_timeout> @ imm = #0x31fc
; }
 800b690: bf00         	nop
 800b692: 3710         	adds	r7, #0x10
 800b694: 46bd         	mov	sp, r7
 800b696: bd80         	pop	{r7, pc}

0800b698 <$d>:
 800b698: bf 87 01 08  	.word	0x080187bf

0800b69c <z_dummy_thread_init>:
; {
 800b69c: b480         	push	{r7}
 800b69e: b083         	sub	sp, #0xc
 800b6a0: af00         	add	r7, sp, #0x0
 800b6a2: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 800b6a4: 687b         	ldr	r3, [r7, #0x4]
 800b6a6: 2201         	movs	r2, #0x1
 800b6a8: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 800b6aa: 687b         	ldr	r3, [r7, #0x4]
 800b6ac: 2201         	movs	r2, #0x1
 800b6ae: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 800b6b0: 687b         	ldr	r3, [r7, #0x4]
 800b6b2: 2200         	movs	r2, #0x0
 800b6b4: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 800b6b8: 687b         	ldr	r3, [r7, #0x4]
 800b6ba: 2200         	movs	r2, #0x0
 800b6bc: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	dummy_thread->resource_pool = NULL;
 800b6c0: 687b         	ldr	r3, [r7, #0x4]
 800b6c2: 2200         	movs	r2, #0x0
 800b6c4: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 	_current_cpu->current = dummy_thread;
 800b6c8: 4a03         	ldr	r2, [pc, #0xc]          @ 0x800b6d8 <z_dummy_thread_init+0x3c>
 800b6ca: 687b         	ldr	r3, [r7, #0x4]
 800b6cc: 6093         	str	r3, [r2, #0x8]
; }
 800b6ce: bf00         	nop
 800b6d0: 370c         	adds	r7, #0xc
 800b6d2: 46bd         	mov	sp, r7
 800b6d4: bc80         	pop	{r7}
 800b6d6: 4770         	bx	lr

0800b6d8 <$d>:
 800b6d8: c8 06 00 20  	.word	0x200006c8

0800b6dc <z_init_static_threads>:
; {
 800b6dc: b5f0         	push	{r4, r5, r6, r7, lr}
 800b6de: b08f         	sub	sp, #0x3c
 800b6e0: af06         	add	r7, sp, #0x18
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800b6e2: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800b7a8 <z_init_static_threads+0xcc>
 800b6e4: 61fb         	str	r3, [r7, #0x1c]
 800b6e6: e029         	b	0x800b73c <z_init_static_threads+0x60> @ imm = #0x52
; 		z_setup_new_thread(
 800b6e8: 69fb         	ldr	r3, [r7, #0x1c]
 800b6ea: 681e         	ldr	r6, [r3]
 800b6ec: 69fb         	ldr	r3, [r7, #0x1c]
 800b6ee: 685b         	ldr	r3, [r3, #0x4]
 800b6f0: 60fb         	str	r3, [r7, #0xc]
 800b6f2: 69fb         	ldr	r3, [r7, #0x1c]
 800b6f4: 689a         	ldr	r2, [r3, #0x8]
 800b6f6: 60ba         	str	r2, [r7, #0x8]
 800b6f8: 69fb         	ldr	r3, [r7, #0x1c]
 800b6fa: 68d8         	ldr	r0, [r3, #0xc]
 800b6fc: 6078         	str	r0, [r7, #0x4]
 800b6fe: 69fb         	ldr	r3, [r7, #0x1c]
 800b700: 691b         	ldr	r3, [r3, #0x10]
 800b702: 69fa         	ldr	r2, [r7, #0x1c]
 800b704: 6952         	ldr	r2, [r2, #0x14]
 800b706: 69f9         	ldr	r1, [r7, #0x1c]
 800b708: 6989         	ldr	r1, [r1, #0x18]
 800b70a: 69f8         	ldr	r0, [r7, #0x1c]
 800b70c: 69c0         	ldr	r0, [r0, #0x1c]
 800b70e: 69fc         	ldr	r4, [r7, #0x1c]
 800b710: 6a24         	ldr	r4, [r4, #0x20]
 800b712: 69fd         	ldr	r5, [r7, #0x1c]
 800b714: 6a6d         	ldr	r5, [r5, #0x24]
 800b716: 9505         	str	r5, [sp, #0x14]
 800b718: 9404         	str	r4, [sp, #0x10]
 800b71a: 9003         	str	r0, [sp, #0xc]
 800b71c: 9102         	str	r1, [sp, #0x8]
 800b71e: 9201         	str	r2, [sp, #0x4]
 800b720: 9300         	str	r3, [sp]
 800b722: 687b         	ldr	r3, [r7, #0x4]
 800b724: 68ba         	ldr	r2, [r7, #0x8]
 800b726: 68f9         	ldr	r1, [r7, #0xc]
 800b728: 4630         	mov	r0, r6
 800b72a: f001 fae1    	bl	0x800ccf0 <z_setup_new_thread> @ imm = #0x15c2
; 		thread_data->init_thread->init_data = thread_data;
 800b72e: 69fb         	ldr	r3, [r7, #0x1c]
 800b730: 681b         	ldr	r3, [r3]
 800b732: 69fa         	ldr	r2, [r7, #0x1c]
 800b734: 665a         	str	r2, [r3, #0x64]
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800b736: 69fb         	ldr	r3, [r7, #0x1c]
 800b738: 3330         	adds	r3, #0x30
 800b73a: 61fb         	str	r3, [r7, #0x1c]
 800b73c: 69fb         	ldr	r3, [r7, #0x1c]
 800b73e: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800b7ac <z_init_static_threads+0xd0>
 800b740: 4293         	cmp	r3, r2
 800b742: bf34         	ite	lo
 800b744: 2301         	movlo	r3, #0x1
 800b746: 2300         	movhs	r3, #0x0
 800b748: b2db         	uxtb	r3, r3
 800b74a: 2b00         	cmp	r3, #0x0
 800b74c: d1cc         	bne	0x800b6e8 <z_init_static_threads+0xc> @ imm = #-0x68
; 	k_sched_lock();
 800b74e: f002 f9c3    	bl	0x800dad8 <k_sched_lock> @ imm = #0x2386
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800b752: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800b7a8 <z_init_static_threads+0xcc>
 800b754: 61bb         	str	r3, [r7, #0x18]
 800b756: e018         	b	0x800b78a <z_init_static_threads+0xae> @ imm = #0x30
; 		k_timeout_t init_delay = Z_THREAD_INIT_DELAY(thread_data);
 800b758: 69bb         	ldr	r3, [r7, #0x18]
 800b75a: e9d3 230a    	ldrd	r2, r3, [r3, #40]
 800b75e: e9c7 2304    	strd	r2, r3, [r7, #16]
; 		if (!K_TIMEOUT_EQ(init_delay, K_FOREVER)) {
 800b762: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800b766: f04f 30ff    	mov.w	r0, #0xffffffff
 800b76a: f04f 31ff    	mov.w	r1, #0xffffffff
 800b76e: 428b         	cmp	r3, r1
 800b770: bf08         	it	eq
 800b772: 4282         	cmpeq	r2, r0
 800b774: d006         	beq	0x800b784 <z_init_static_threads+0xa8> @ imm = #0xc
; 			thread_schedule_new(thread_data->init_thread,
 800b776: 69bb         	ldr	r3, [r7, #0x18]
 800b778: 6819         	ldr	r1, [r3]
 800b77a: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800b77e: 4608         	mov	r0, r1
 800b780: f00b fbaf    	bl	0x8016ee2 <thread_schedule_new> @ imm = #0xb75e
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800b784: 69bb         	ldr	r3, [r7, #0x18]
 800b786: 3330         	adds	r3, #0x30
 800b788: 61bb         	str	r3, [r7, #0x18]
 800b78a: 69bb         	ldr	r3, [r7, #0x18]
 800b78c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800b7ac <z_init_static_threads+0xd0>
 800b78e: 4293         	cmp	r3, r2
 800b790: bf34         	ite	lo
 800b792: 2301         	movlo	r3, #0x1
 800b794: 2300         	movhs	r3, #0x0
 800b796: b2db         	uxtb	r3, r3
 800b798: 2b00         	cmp	r3, #0x0
 800b79a: d1dd         	bne	0x800b758 <z_init_static_threads+0x7c> @ imm = #-0x46
; 	k_sched_unlock();
 800b79c: f002 f9dc    	bl	0x800db58 <k_sched_unlock> @ imm = #0x23b8
; }
 800b7a0: bf00         	nop
 800b7a2: 3724         	adds	r7, #0x24
 800b7a4: 46bd         	mov	sp, r7
 800b7a6: bdf0         	pop	{r4, r5, r6, r7, pc}

0800b7a8 <$d>:
 800b7a8: c8 96 01 08  	.word	0x080196c8
 800b7ac: f8 96 01 08  	.word	0x080196f8

0800b7b0 <z_bss_zero>:
; {
 800b7b0: b580         	push	{r7, lr}
 800b7b2: af00         	add	r7, sp, #0x0
; 	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
 800b7b4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800b7c8 <z_bss_zero+0x18>
 800b7b6: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800b7cc <z_bss_zero+0x1c>
 800b7b8: 1ad3         	subs	r3, r2, r3
 800b7ba: 461a         	mov	r2, r3
 800b7bc: 2100         	movs	r1, #0x0
 800b7be: 4803         	ldr	r0, [pc, #0xc]          @ 0x800b7cc <z_bss_zero+0x1c>
 800b7c0: f00b fbdc    	bl	0x8016f7c <z_early_memset> @ imm = #0xb7b8
; }
 800b7c4: bd80         	pop	{r7, pc}
 800b7c6: bf00         	nop

0800b7c8 <$d>:
 800b7c8: 00 11 00 20  	.word	0x20001100
 800b7cc: e8 05 00 20  	.word	0x200005e8

0800b7d0 <z_sys_init_run_level>:
; {
 800b7d0: b580         	push	{r7, lr}
 800b7d2: b086         	sub	sp, #0x18
 800b7d4: af00         	add	r7, sp, #0x0
 800b7d6: 4603         	mov	r3, r0
 800b7d8: 71fb         	strb	r3, [r7, #0x7]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 800b7da: 79fb         	ldrb	r3, [r7, #0x7]
 800b7dc: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800b824 <z_sys_init_run_level+0x54>
 800b7de: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800b7e2: 617b         	str	r3, [r7, #0x14]
 800b7e4: e011         	b	0x800b80a <z_sys_init_run_level+0x3a> @ imm = #0x22
; 		const struct device *dev = entry->dev;
 800b7e6: 697b         	ldr	r3, [r7, #0x14]
 800b7e8: 685b         	ldr	r3, [r3, #0x4]
 800b7ea: 613b         	str	r3, [r7, #0x10]
; 		if (dev != NULL) {
 800b7ec: 693b         	ldr	r3, [r7, #0x10]
 800b7ee: 2b00         	cmp	r3, #0x0
 800b7f0: d004         	beq	0x800b7fc <z_sys_init_run_level+0x2c> @ imm = #0x8
; 			result = do_device_init(entry);
 800b7f2: 6978         	ldr	r0, [r7, #0x14]
 800b7f4: f00b fbe0    	bl	0x8016fb8 <do_device_init> @ imm = #0xb7c0
 800b7f8: 60f8         	str	r0, [r7, #0xc]
 800b7fa: e003         	b	0x800b804 <z_sys_init_run_level+0x34> @ imm = #0x6
; 			result = entry->init_fn.sys();
 800b7fc: 697b         	ldr	r3, [r7, #0x14]
 800b7fe: 681b         	ldr	r3, [r3]
 800b800: 4798         	blx	r3
 800b802: 60f8         	str	r0, [r7, #0xc]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 800b804: 697b         	ldr	r3, [r7, #0x14]
 800b806: 3308         	adds	r3, #0x8
 800b808: 617b         	str	r3, [r7, #0x14]
 800b80a: 79fb         	ldrb	r3, [r7, #0x7]
 800b80c: 3301         	adds	r3, #0x1
 800b80e: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800b824 <z_sys_init_run_level+0x54>
 800b810: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800b814: 697a         	ldr	r2, [r7, #0x14]
 800b816: 429a         	cmp	r2, r3
 800b818: d3e5         	blo	0x800b7e6 <z_sys_init_run_level+0x16> @ imm = #-0x36
; }
 800b81a: bf00         	nop
 800b81c: bf00         	nop
 800b81e: 3718         	adds	r7, #0x18
 800b820: 46bd         	mov	sp, r7
 800b822: bd80         	pop	{r7, pc}

0800b824 <$d>:
 800b824: 2c 05 00 20  	.word	0x2000052c

0800b828 <bg_thread_main>:
; {
 800b828: b580         	push	{r7, lr}
 800b82a: b084         	sub	sp, #0x10
 800b82c: af00         	add	r7, sp, #0x0
 800b82e: 60f8         	str	r0, [r7, #0xc]
 800b830: 60b9         	str	r1, [r7, #0x8]
 800b832: 607a         	str	r2, [r7, #0x4]
; 	z_sys_post_kernel = true;
 800b834: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b864 <bg_thread_main+0x3c>
 800b836: 2201         	movs	r2, #0x1
 800b838: 701a         	strb	r2, [r3]
; 	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 800b83a: 2003         	movs	r0, #0x3
 800b83c: f7ff ffc8    	bl	0x800b7d0 <z_sys_init_run_level> @ imm = #-0x70
; 	boot_banner();
 800b840: f003 fb1e    	bl	0x800ee80 <boot_banner> @ imm = #0x363c
; 	z_init_static();
 800b844: f00b fbee    	bl	0x8017024 <z_init_static> @ imm = #0xb7dc
; 	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
 800b848: 2004         	movs	r0, #0x4
 800b84a: f7ff ffc1    	bl	0x800b7d0 <z_sys_init_run_level> @ imm = #-0x7e
; 	z_init_static_threads();
 800b84e: f7ff ff45    	bl	0x800b6dc <z_init_static_threads> @ imm = #-0x176
; 	(void)main();
 800b852: f7f5 fd67    	bl	0x8001324 <main>        @ imm = #-0xa532
; 	z_thread_essential_clear(&z_main_thread);
 800b856: 4804         	ldr	r0, [pc, #0x10]         @ 0x800b868 <bg_thread_main+0x40>
 800b858: f00b fb70    	bl	0x8016f3c <z_thread_essential_clear> @ imm = #0xb6e0
; } /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 800b85c: bf00         	nop
 800b85e: 3710         	adds	r7, #0x10
 800b860: 46bd         	mov	sp, r7
 800b862: bd80         	pop	{r7, pc}

0800b864 <$d>:
 800b864: fe 10 00 20  	.word	0x200010fe
 800b868: 08 07 00 20  	.word	0x20000708

0800b86c <init_idle_thread>:
; {
 800b86c: b580         	push	{r7, lr}
 800b86e: b08c         	sub	sp, #0x30
 800b870: af06         	add	r7, sp, #0x18
 800b872: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = &z_idle_threads[i];
 800b874: 687b         	ldr	r3, [r7, #0x4]
 800b876: 22d0         	movs	r2, #0xd0
 800b878: fb02 f303    	mul	r3, r2, r3
 800b87c: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800b8dc <init_idle_thread+0x70>
 800b87e: 4413         	add	r3, r2
 800b880: 617b         	str	r3, [r7, #0x14]
; 	k_thread_stack_t *stack = z_idle_stacks[i];
 800b882: 687a         	ldr	r2, [r7, #0x4]
 800b884: 4613         	mov	r3, r2
 800b886: 009b         	lsls	r3, r3, #0x2
 800b888: 4413         	add	r3, r2
 800b88a: 019b         	lsls	r3, r3, #0x6
 800b88c: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800b8e0 <init_idle_thread+0x74>
 800b88e: 4413         	add	r3, r2
 800b890: 613b         	str	r3, [r7, #0x10]
; 	size_t stack_size = K_KERNEL_STACK_SIZEOF(z_idle_stacks[i]);
 800b892: f44f 73a0    	mov.w	r3, #0x140
 800b896: 60fb         	str	r3, [r7, #0xc]
; 	char *tname = "idle";
 800b898: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800b8e4 <init_idle_thread+0x78>
 800b89a: 60bb         	str	r3, [r7, #0x8]
; 			  stack_size, idle, &_kernel.cpus[i],
 800b89c: 687a         	ldr	r2, [r7, #0x4]
 800b89e: 4613         	mov	r3, r2
 800b8a0: 00db         	lsls	r3, r3, #0x3
 800b8a2: 1a9b         	subs	r3, r3, r2
 800b8a4: 009b         	lsls	r3, r3, #0x2
 800b8a6: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800b8e8 <init_idle_thread+0x7c>
 800b8a8: 4413         	add	r3, r2
; 	z_setup_new_thread(thread, stack,
 800b8aa: 68ba         	ldr	r2, [r7, #0x8]
 800b8ac: 9205         	str	r2, [sp, #0x14]
 800b8ae: 2201         	movs	r2, #0x1
 800b8b0: 9204         	str	r2, [sp, #0x10]
 800b8b2: 220f         	movs	r2, #0xf
 800b8b4: 9203         	str	r2, [sp, #0xc]
 800b8b6: 2200         	movs	r2, #0x0
 800b8b8: 9202         	str	r2, [sp, #0x8]
 800b8ba: 2200         	movs	r2, #0x0
 800b8bc: 9201         	str	r2, [sp, #0x4]
 800b8be: 9300         	str	r3, [sp]
 800b8c0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800b8ec <init_idle_thread+0x80>
 800b8c2: 68fa         	ldr	r2, [r7, #0xc]
 800b8c4: 6939         	ldr	r1, [r7, #0x10]
 800b8c6: 6978         	ldr	r0, [r7, #0x14]
 800b8c8: f001 fa12    	bl	0x800ccf0 <z_setup_new_thread> @ imm = #0x1424
; 	z_mark_thread_as_started(thread);
 800b8cc: 6978         	ldr	r0, [r7, #0x14]
 800b8ce: f00b fb25    	bl	0x8016f1c <z_mark_thread_as_started> @ imm = #0xb64a
; }
 800b8d2: bf00         	nop
 800b8d4: 3718         	adds	r7, #0x18
 800b8d6: 46bd         	mov	sp, r7
 800b8d8: bd80         	pop	{r7, pc}
 800b8da: bf00         	nop

0800b8dc <$d>:
 800b8dc: d8 07 00 20  	.word	0x200007d8
 800b8e0: 00 35 00 20  	.word	0x20003500
 800b8e4: dc ae 01 08  	.word	0x0801aedc
 800b8e8: c8 06 00 20  	.word	0x200006c8
 800b8ec: d9 72 01 08  	.word	0x080172d9

0800b8f0 <z_init_cpu>:
; {
 800b8f0: b580         	push	{r7, lr}
 800b8f2: b082         	sub	sp, #0x8
 800b8f4: af00         	add	r7, sp, #0x0
 800b8f6: 6078         	str	r0, [r7, #0x4]
; 	init_idle_thread(id);
 800b8f8: 6878         	ldr	r0, [r7, #0x4]
 800b8fa: f7ff ffb7    	bl	0x800b86c <init_idle_thread> @ imm = #-0x92
; 	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 800b8fe: 687b         	ldr	r3, [r7, #0x4]
 800b900: 22d0         	movs	r2, #0xd0
 800b902: fb02 f303    	mul	r3, r2, r3
 800b906: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x800b994 <z_init_cpu+0xa4>
 800b908: 1899         	adds	r1, r3, r2
 800b90a: 4823         	ldr	r0, [pc, #0x8c]         @ 0x800b998 <z_init_cpu+0xa8>
 800b90c: 687a         	ldr	r2, [r7, #0x4]
 800b90e: 4613         	mov	r3, r2
 800b910: 00db         	lsls	r3, r3, #0x3
 800b912: 1a9b         	subs	r3, r3, r2
 800b914: 009b         	lsls	r3, r3, #0x2
 800b916: 4403         	add	r3, r0
 800b918: 330c         	adds	r3, #0xc
 800b91a: 6019         	str	r1, [r3]
; 	_kernel.cpus[id].id = id;
 800b91c: 687b         	ldr	r3, [r7, #0x4]
 800b91e: b2d8         	uxtb	r0, r3
 800b920: 491d         	ldr	r1, [pc, #0x74]         @ 0x800b998 <z_init_cpu+0xa8>
 800b922: 687a         	ldr	r2, [r7, #0x4]
 800b924: 4613         	mov	r3, r2
 800b926: 00db         	lsls	r3, r3, #0x3
 800b928: 1a9b         	subs	r3, r3, r2
 800b92a: 009b         	lsls	r3, r3, #0x2
 800b92c: 440b         	add	r3, r1
 800b92e: 3310         	adds	r3, #0x10
 800b930: 4602         	mov	r2, r0
 800b932: 701a         	strb	r2, [r3]
; 		(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 800b934: 687b         	ldr	r3, [r7, #0x4]
 800b936: 02db         	lsls	r3, r3, #0xb
 800b938: 4a18         	ldr	r2, [pc, #0x60]         @ 0x800b99c <z_init_cpu+0xac>
 800b93a: 4413         	add	r3, r2
 800b93c: 4618         	mov	r0, r3
 800b93e: f00b fabb    	bl	0x8016eb8 <K_KERNEL_STACK_BUFFER> @ imm = #0xb576
 800b942: 4603         	mov	r3, r0
 800b944: f503 6100    	add.w	r1, r3, #0x800
; 	_kernel.cpus[id].irq_stack =
 800b948: 4813         	ldr	r0, [pc, #0x4c]         @ 0x800b998 <z_init_cpu+0xa8>
 800b94a: 687a         	ldr	r2, [r7, #0x4]
 800b94c: 4613         	mov	r3, r2
 800b94e: 00db         	lsls	r3, r3, #0x3
 800b950: 1a9b         	subs	r3, r3, r2
 800b952: 009b         	lsls	r3, r3, #0x2
 800b954: 4403         	add	r3, r0
 800b956: 3304         	adds	r3, #0x4
 800b958: 6019         	str	r1, [r3]
; 	_kernel.cpus[id].usage = &_kernel.usage[id];
 800b95a: 687b         	ldr	r3, [r7, #0x4]
 800b95c: 3303         	adds	r3, #0x3
 800b95e: 011b         	lsls	r3, r3, #0x4
 800b960: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800b998 <z_init_cpu+0xa8>
 800b962: 1899         	adds	r1, r3, r2
 800b964: 480c         	ldr	r0, [pc, #0x30]         @ 0x800b998 <z_init_cpu+0xa8>
 800b966: 687a         	ldr	r2, [r7, #0x4]
 800b968: 4613         	mov	r3, r2
 800b96a: 00db         	lsls	r3, r3, #0x3
 800b96c: 1a9b         	subs	r3, r3, r2
 800b96e: 009b         	lsls	r3, r3, #0x2
 800b970: 4403         	add	r3, r0
 800b972: 3318         	adds	r3, #0x18
 800b974: 6019         	str	r1, [r3]
; 	_kernel.cpus[id].usage->track_usage =
 800b976: 4908         	ldr	r1, [pc, #0x20]         @ 0x800b998 <z_init_cpu+0xa8>
 800b978: 687a         	ldr	r2, [r7, #0x4]
 800b97a: 4613         	mov	r3, r2
 800b97c: 00db         	lsls	r3, r3, #0x3
 800b97e: 1a9b         	subs	r3, r3, r2
 800b980: 009b         	lsls	r3, r3, #0x2
 800b982: 440b         	add	r3, r1
 800b984: 3318         	adds	r3, #0x18
 800b986: 681b         	ldr	r3, [r3]
 800b988: 2201         	movs	r2, #0x1
 800b98a: 721a         	strb	r2, [r3, #0x8]
; }
 800b98c: bf00         	nop
 800b98e: 3708         	adds	r7, #0x8
 800b990: 46bd         	mov	sp, r7
 800b992: bd80         	pop	{r7, pc}

0800b994 <$d>:
 800b994: d8 07 00 20  	.word	0x200007d8
 800b998: c8 06 00 20  	.word	0x200006c8
 800b99c: 40 36 00 20  	.word	0x20003640

0800b9a0 <prepare_multithreading>:
; {
 800b9a0: b580         	push	{r7, lr}
 800b9a2: b088         	sub	sp, #0x20
 800b9a4: af06         	add	r7, sp, #0x18
; 	z_sched_init();
 800b9a6: f002 f9a7    	bl	0x800dcf8 <z_sched_init> @ imm = #0x234e
; 	_kernel.ready_q.cache = &z_main_thread;
 800b9aa: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800b9f4 <prepare_multithreading+0x54>
 800b9ac: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800b9f8 <prepare_multithreading+0x58>
 800b9ae: 61da         	str	r2, [r3, #0x1c]
; 	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 800b9b0: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800b9fc <prepare_multithreading+0x5c>
 800b9b2: 9305         	str	r3, [sp, #0x14]
 800b9b4: 2301         	movs	r3, #0x1
 800b9b6: 9304         	str	r3, [sp, #0x10]
 800b9b8: 2300         	movs	r3, #0x0
 800b9ba: 9303         	str	r3, [sp, #0xc]
 800b9bc: 2300         	movs	r3, #0x0
 800b9be: 9302         	str	r3, [sp, #0x8]
 800b9c0: 2300         	movs	r3, #0x0
 800b9c2: 9301         	str	r3, [sp, #0x4]
 800b9c4: 2300         	movs	r3, #0x0
 800b9c6: 9300         	str	r3, [sp]
 800b9c8: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800ba00 <prepare_multithreading+0x60>
 800b9ca: f44f 6280    	mov.w	r2, #0x400
 800b9ce: 490d         	ldr	r1, [pc, #0x34]         @ 0x800ba04 <prepare_multithreading+0x64>
 800b9d0: 4809         	ldr	r0, [pc, #0x24]         @ 0x800b9f8 <prepare_multithreading+0x58>
 800b9d2: f001 f98d    	bl	0x800ccf0 <z_setup_new_thread> @ imm = #0x131a
 800b9d6: 6078         	str	r0, [r7, #0x4]
; 	z_mark_thread_as_started(&z_main_thread);
 800b9d8: 4807         	ldr	r0, [pc, #0x1c]         @ 0x800b9f8 <prepare_multithreading+0x58>
 800b9da: f00b fa9f    	bl	0x8016f1c <z_mark_thread_as_started> @ imm = #0xb53e
; 	z_ready_thread(&z_main_thread);
 800b9de: 4806         	ldr	r0, [pc, #0x18]         @ 0x800b9f8 <prepare_multithreading+0x58>
 800b9e0: f001 fc2c    	bl	0x800d23c <z_ready_thread> @ imm = #0x1858
; 	z_init_cpu(0);
 800b9e4: 2000         	movs	r0, #0x0
 800b9e6: f7ff ff83    	bl	0x800b8f0 <z_init_cpu>  @ imm = #-0xfa
; 	return stack_ptr;
 800b9ea: 687b         	ldr	r3, [r7, #0x4]
; }
 800b9ec: 4618         	mov	r0, r3
 800b9ee: 3708         	adds	r7, #0x8
 800b9f0: 46bd         	mov	sp, r7
 800b9f2: bd80         	pop	{r7, pc}

0800b9f4 <$d>:
 800b9f4: c8 06 00 20  	.word	0x200006c8
 800b9f8: 08 07 00 20  	.word	0x20000708
 800b9fc: e4 ae 01 08  	.word	0x0801aee4
 800ba00: 29 b8 00 08  	.word	0x0800b829
 800ba04: 00 31 00 20  	.word	0x20003100

0800ba08 <switch_to_main_thread>:
; {
 800ba08: b580         	push	{r7, lr}
 800ba0a: b082         	sub	sp, #0x8
 800ba0c: af00         	add	r7, sp, #0x0
 800ba0e: 6078         	str	r0, [r7, #0x4]
; 	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 800ba10: 4a02         	ldr	r2, [pc, #0x8]          @ 0x800ba1c <switch_to_main_thread+0x14>
 800ba12: 6879         	ldr	r1, [r7, #0x4]
 800ba14: 4802         	ldr	r0, [pc, #0x8]          @ 0x800ba20 <switch_to_main_thread+0x18>
 800ba16: f7f8 f88d    	bl	0x8003b34 <arch_switch_to_main_thread> @ imm = #-0x7ee6
 800ba1a: bf00         	nop

0800ba1c <$d>:
 800ba1c: 29 b8 00 08  	.word	0x0800b829
 800ba20: 08 07 00 20  	.word	0x20000708

0800ba24 <z_cstart>:
; {
 800ba24: b580         	push	{r7, lr}
 800ba26: b082         	sub	sp, #0x8
 800ba28: af00         	add	r7, sp, #0x0
; 	gcov_static_init();
 800ba2a: f00b fa97    	bl	0x8016f5c <gcov_static_init> @ imm = #0xb52e
; 	z_sys_init_run_level(INIT_LEVEL_EARLY);
 800ba2e: 2000         	movs	r0, #0x0
 800ba30: f7ff fece    	bl	0x800b7d0 <z_sys_init_run_level> @ imm = #-0x264
; 		(uint32_t)(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
 800ba34: 482d         	ldr	r0, [pc, #0xb4]         @ 0x800baec <z_cstart+0xc8>
 800ba36: f00b fa3f    	bl	0x8016eb8 <K_KERNEL_STACK_BUFFER> @ imm = #0xb47e
 800ba3a: 4603         	mov	r3, r0
; 	uint32_t msp =
 800ba3c: f503 6300    	add.w	r3, r3, #0x800
 800ba40: 607b         	str	r3, [r7, #0x4]
 800ba42: 687b         	ldr	r3, [r7, #0x4]
 800ba44: 603b         	str	r3, [r7]
;   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 800ba46: 683b         	ldr	r3, [r7]
 800ba48: f383 8808    	msr	msp, r3
; }
 800ba4c: bf00         	nop
; 	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
 800ba4e: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800baf0 <z_cstart+0xcc>
 800ba50: 695b         	ldr	r3, [r3, #0x14]
 800ba52: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x800baf0 <z_cstart+0xcc>
 800ba54: f443 7300    	orr	r3, r3, #0x200
 800ba58: 6153         	str	r3, [r2, #0x14]
; }
 800ba5a: bf00         	nop
; 	NVIC_SetPriority(PendSV_IRQn, _EXC_PENDSV_PRIO);
 800ba5c: 21ff         	movs	r1, #0xff
 800ba5e: f06f 0001    	mvn	r0, #0x1
 800ba62: f7ff fddd    	bl	0x800b620 <__NVIC_SetPriority> @ imm = #-0x446
; 	NVIC_SetPriority(SVCall_IRQn, _EXC_SVC_PRIO);
 800ba66: 2100         	movs	r1, #0x0
 800ba68: f06f 0004    	mvn	r0, #0x4
 800ba6c: f7ff fdd8    	bl	0x800b620 <__NVIC_SetPriority> @ imm = #-0x450
; 	NVIC_SetPriority(MemoryManagement_IRQn, _EXC_FAULT_PRIO);
 800ba70: 2100         	movs	r1, #0x0
 800ba72: f06f 000b    	mvn	r0, #0xb
 800ba76: f7ff fdd3    	bl	0x800b620 <__NVIC_SetPriority> @ imm = #-0x45a
; 	NVIC_SetPriority(BusFault_IRQn, _EXC_FAULT_PRIO);
 800ba7a: 2100         	movs	r1, #0x0
 800ba7c: f06f 000a    	mvn	r0, #0xa
 800ba80: f7ff fdce    	bl	0x800b620 <__NVIC_SetPriority> @ imm = #-0x464
; 	NVIC_SetPriority(UsageFault_IRQn, _EXC_FAULT_PRIO);
 800ba84: 2100         	movs	r1, #0x0
 800ba86: f06f 0009    	mvn	r0, #0x9
 800ba8a: f7ff fdc9    	bl	0x800b620 <__NVIC_SetPriority> @ imm = #-0x46e
; 	NVIC_SetPriority(DebugMonitor_IRQn, _EXC_FAULT_PRIO);
 800ba8e: 2100         	movs	r1, #0x0
 800ba90: f06f 0003    	mvn	r0, #0x3
 800ba94: f7ff fdc4    	bl	0x800b620 <__NVIC_SetPriority> @ imm = #-0x478
; 	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 800ba98: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800baf0 <z_cstart+0xcc>
 800ba9a: 6a5b         	ldr	r3, [r3, #0x24]
 800ba9c: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800baf0 <z_cstart+0xcc>
 800ba9e: f443 23e0    	orr	r3, r3, #0x70000
 800baa2: 6253         	str	r3, [r2, #0x24]
; }
 800baa4: bf00         	nop
; 	z_arm_fault_init();
 800baa6: f7f7 feb5    	bl	0x8003814 <z_arm_fault_init> @ imm = #-0x8296
; 	z_arm_cpu_idle_init();
 800baaa: f7f8 f86f    	bl	0x8003b8c <z_arm_cpu_idle_init> @ imm = #-0x7f22
; 	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 800baae: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800baf0 <z_cstart+0xcc>
 800bab0: f04f 32ff    	mov.w	r2, #0xffffffff
 800bab4: 629a         	str	r2, [r3, #0x28]
; 	SCB->HFSR = 0xffffffff;
 800bab6: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800baf0 <z_cstart+0xcc>
 800bab8: f04f 32ff    	mov.w	r2, #0xffffffff
 800babc: 62da         	str	r2, [r3, #0x2c]
; }
 800babe: bf00         	nop
; }
 800bac0: bf00         	nop
; 	LOG_CORE_INIT();
 800bac2: f7f6 f931    	bl	0x8001d28 <log_core_init> @ imm = #-0x9d9e
; 	z_dummy_thread_init(&_thread_dummy);
 800bac6: 480b         	ldr	r0, [pc, #0x2c]         @ 0x800baf4 <z_cstart+0xd0>
 800bac8: f7ff fde8    	bl	0x800b69c <z_dummy_thread_init> @ imm = #-0x430
; 	z_device_state_init();
 800bacc: f7ff fc56    	bl	0x800b37c <z_device_state_init> @ imm = #-0x754
; 	soc_early_init_hook();
 800bad0: f7f6 f8f6    	bl	0x8001cc0 <soc_early_init_hook> @ imm = #-0x9e14
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
 800bad4: 2001         	movs	r0, #0x1
 800bad6: f7ff fe7b    	bl	0x800b7d0 <z_sys_init_run_level> @ imm = #-0x30a
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 800bada: 2002         	movs	r0, #0x2
 800badc: f7ff fe78    	bl	0x800b7d0 <z_sys_init_run_level> @ imm = #-0x310
; 	switch_to_main_thread(prepare_multithreading());
 800bae0: f7ff ff5e    	bl	0x800b9a0 <prepare_multithreading> @ imm = #-0x144
 800bae4: 4603         	mov	r3, r0
 800bae6: 4618         	mov	r0, r3
 800bae8: f7ff ff8e    	bl	0x800ba08 <switch_to_main_thread> @ imm = #-0xe4

0800baec <$d>:
 800baec: 40 36 00 20  	.word	0x20003640
 800baf0: 00 ed 00 e0  	.word	0xe000ed00
 800baf4: a8 08 00 20  	.word	0x200008a8

0800baf8 <init_mem_slab_obj_core_list>:
; {
 800baf8: b580         	push	{r7, lr}
 800bafa: b082         	sub	sp, #0x8
 800bafc: af00         	add	r7, sp, #0x0
; 	int rc = 0;
 800bafe: 2300         	movs	r3, #0x0
 800bb00: 607b         	str	r3, [r7, #0x4]
; 	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 800bb02: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800bb44 <init_mem_slab_obj_core_list+0x4c>
 800bb04: 603b         	str	r3, [r7]
 800bb06: e00c         	b	0x800bb22 <init_mem_slab_obj_core_list+0x2a> @ imm = #0x18
; 		rc = create_free_list(slab);
 800bb08: 6838         	ldr	r0, [r7]
 800bb0a: f00b fb1b    	bl	0x8017144 <create_free_list> @ imm = #0xb636
 800bb0e: 6078         	str	r0, [r7, #0x4]
; 		if (rc < 0) {
 800bb10: 687b         	ldr	r3, [r7, #0x4]
 800bb12: 2b00         	cmp	r3, #0x0
 800bb14: db0f         	blt	0x800bb36 <init_mem_slab_obj_core_list+0x3e> @ imm = #0x1e
; 		k_object_init(slab);
 800bb16: 6838         	ldr	r0, [r7]
 800bb18: f00b fad3    	bl	0x80170c2 <k_object_init> @ imm = #0xb5a6
; 	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 800bb1c: 683b         	ldr	r3, [r7]
 800bb1e: 331c         	adds	r3, #0x1c
 800bb20: 603b         	str	r3, [r7]
 800bb22: 683b         	ldr	r3, [r7]
 800bb24: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800bb48 <init_mem_slab_obj_core_list+0x50>
 800bb26: 4293         	cmp	r3, r2
 800bb28: bf34         	ite	lo
 800bb2a: 2301         	movlo	r3, #0x1
 800bb2c: 2300         	movhs	r3, #0x0
 800bb2e: b2db         	uxtb	r3, r3
 800bb30: 2b00         	cmp	r3, #0x0
 800bb32: d1e9         	bne	0x800bb08 <init_mem_slab_obj_core_list+0x10> @ imm = #-0x2e
; out:
 800bb34: e000         	b	0x800bb38 <init_mem_slab_obj_core_list+0x40> @ imm = #0x0
; 			goto out;
 800bb36: bf00         	nop
; 	return rc;
 800bb38: 687b         	ldr	r3, [r7, #0x4]
; }
 800bb3a: 4618         	mov	r0, r3
 800bb3c: 3708         	adds	r7, #0x8
 800bb3e: 46bd         	mov	sp, r7
 800bb40: bd80         	pop	{r7, pc}
 800bb42: bf00         	nop

0800bb44 <$d>:
 800bb44: cc 05 00 20  	.word	0x200005cc
 800bb48: e8 05 00 20  	.word	0x200005e8

0800bb4c <k_mem_slab_alloc>:
; {
 800bb4c: b580         	push	{r7, lr}
 800bb4e: b094         	sub	sp, #0x50
 800bb50: af02         	add	r7, sp, #0x8
 800bb52: 60f8         	str	r0, [r7, #0xc]
 800bb54: 60b9         	str	r1, [r7, #0x8]
 800bb56: e9c7 2300    	strd	r2, r3, [r7]
; 	k_spinlock_key_t key = k_spin_lock(&slab->lock);
 800bb5a: 68fb         	ldr	r3, [r7, #0xc]
 800bb5c: 3308         	adds	r3, #0x8
 800bb5e: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bb60: f3ef 8311    	mrs	r3, basepri
 800bb64: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800bb66: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 800bb68: 63bb         	str	r3, [r7, #0x38]
 800bb6a: 2310         	movs	r3, #0x10
 800bb6c: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800bb6e: 6b7b         	ldr	r3, [r7, #0x34]
 800bb70: f383 8812    	msr	basepri_max, r3
; }
 800bb74: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800bb76: f3bf 8f6f    	isb	sy
; }
 800bb7a: bf00         	nop
; 	return key;
 800bb7c: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 800bb7e: 617b         	str	r3, [r7, #0x14]
 800bb80: 6c3b         	ldr	r3, [r7, #0x40]
 800bb82: 633b         	str	r3, [r7, #0x30]
; }
 800bb84: bf00         	nop
 800bb86: 6c3b         	ldr	r3, [r7, #0x40]
 800bb88: 62fb         	str	r3, [r7, #0x2c]
; }
 800bb8a: bf00         	nop
; 	return k;
 800bb8c: 697b         	ldr	r3, [r7, #0x14]
 800bb8e: 61fb         	str	r3, [r7, #0x1c]
; 	if (slab->free_list != NULL) {
 800bb90: 68fb         	ldr	r3, [r7, #0xc]
 800bb92: 68db         	ldr	r3, [r3, #0xc]
 800bb94: 2b00         	cmp	r3, #0x0
 800bb96: d010         	beq	0x800bbba <k_mem_slab_alloc+0x6e> @ imm = #0x20
; 		*mem = slab->free_list;
 800bb98: 68fb         	ldr	r3, [r7, #0xc]
 800bb9a: 68da         	ldr	r2, [r3, #0xc]
 800bb9c: 68bb         	ldr	r3, [r7, #0x8]
 800bb9e: 601a         	str	r2, [r3]
; 		slab->free_list = *(char **)(slab->free_list);
 800bba0: 68fb         	ldr	r3, [r7, #0xc]
 800bba2: 68db         	ldr	r3, [r3, #0xc]
 800bba4: 681a         	ldr	r2, [r3]
 800bba6: 68fb         	ldr	r3, [r7, #0xc]
 800bba8: 60da         	str	r2, [r3, #0xc]
; 		slab->info.num_used++;
 800bbaa: 68fb         	ldr	r3, [r7, #0xc]
 800bbac: 699b         	ldr	r3, [r3, #0x18]
 800bbae: 1c5a         	adds	r2, r3, #0x1
 800bbb0: 68fb         	ldr	r3, [r7, #0xc]
 800bbb2: 619a         	str	r2, [r3, #0x18]
; 		result = 0;
 800bbb4: 2300         	movs	r3, #0x0
 800bbb6: 647b         	str	r3, [r7, #0x44]
 800bbb8: e027         	b	0x800bc0a <k_mem_slab_alloc+0xbe> @ imm = #0x4e
; 	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
 800bbba: e9d7 2300    	ldrd	r2, r3, [r7]
 800bbbe: f04f 0000    	mov.w	r0, #0x0
 800bbc2: f04f 0100    	mov.w	r1, #0x0
 800bbc6: 428b         	cmp	r3, r1
 800bbc8: bf08         	it	eq
 800bbca: 4282         	cmpeq	r2, r0
 800bbcc: d106         	bne	0x800bbdc <k_mem_slab_alloc+0x90> @ imm = #0xc
; 		*mem = NULL;
 800bbce: 68bb         	ldr	r3, [r7, #0x8]
 800bbd0: 2200         	movs	r2, #0x0
 800bbd2: 601a         	str	r2, [r3]
; 		result = -ENOMEM;
 800bbd4: f06f 030b    	mvn	r3, #0xb
 800bbd8: 647b         	str	r3, [r7, #0x44]
 800bbda: e016         	b	0x800bc0a <k_mem_slab_alloc+0xbe> @ imm = #0x2c
; 		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
 800bbdc: 68fb         	ldr	r3, [r7, #0xc]
 800bbde: f103 0008    	add.w	r0, r3, #0x8
 800bbe2: 68f9         	ldr	r1, [r7, #0xc]
 800bbe4: e9d7 2300    	ldrd	r2, r3, [r7]
 800bbe8: e9cd 2300    	strd	r2, r3, [sp]
 800bbec: 460a         	mov	r2, r1
 800bbee: 69f9         	ldr	r1, [r7, #0x1c]
 800bbf0: f001 fde8    	bl	0x800d7c4 <z_pend_curr> @ imm = #0x1bd0
 800bbf4: 6478         	str	r0, [r7, #0x44]
; 		if (result == 0) {
 800bbf6: 6c7b         	ldr	r3, [r7, #0x44]
 800bbf8: 2b00         	cmp	r3, #0x0
 800bbfa: d104         	bne	0x800bc06 <k_mem_slab_alloc+0xba> @ imm = #0x8
; 			*mem = _current->base.swap_data;
 800bbfc: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800bc38 <k_mem_slab_alloc+0xec>
 800bbfe: 689b         	ldr	r3, [r3, #0x8]
 800bc00: 695a         	ldr	r2, [r3, #0x14]
 800bc02: 68bb         	ldr	r3, [r7, #0x8]
 800bc04: 601a         	str	r2, [r3]
; 		return result;
 800bc06: 6c7b         	ldr	r3, [r7, #0x44]
 800bc08: e012         	b	0x800bc30 <k_mem_slab_alloc+0xe4> @ imm = #0x24
; 	k_spin_unlock(&slab->lock, key);
 800bc0a: 68fb         	ldr	r3, [r7, #0xc]
 800bc0c: 3308         	adds	r3, #0x8
 800bc0e: 62bb         	str	r3, [r7, #0x28]
 800bc10: 69fb         	ldr	r3, [r7, #0x1c]
 800bc12: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800bc14: 69bb         	ldr	r3, [r7, #0x18]
 800bc16: 627b         	str	r3, [r7, #0x24]
 800bc18: 6a7b         	ldr	r3, [r7, #0x24]
 800bc1a: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800bc1c: 6a3b         	ldr	r3, [r7, #0x20]
 800bc1e: f383 8811    	msr	basepri, r3
; }
 800bc22: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800bc24: f3bf 8f6f    	isb	sy
; }
 800bc28: bf00         	nop
; }
 800bc2a: bf00         	nop
; }
 800bc2c: bf00         	nop
; 	return result;
 800bc2e: 6c7b         	ldr	r3, [r7, #0x44]
; }
 800bc30: 4618         	mov	r0, r3
 800bc32: 3748         	adds	r7, #0x48
 800bc34: 46bd         	mov	sp, r7
 800bc36: bd80         	pop	{r7, pc}

0800bc38 <$d>:
 800bc38: c8 06 00 20  	.word	0x200006c8

0800bc3c <adjust_owner_prio>:
; {
 800bc3c: b5b0         	push	{r4, r5, r7, lr}
 800bc3e: b08c         	sub	sp, #0x30
 800bc40: af08         	add	r7, sp, #0x20
 800bc42: 6078         	str	r0, [r7, #0x4]
 800bc44: 6039         	str	r1, [r7]
; 	if (mutex->owner->base.prio != new_prio) {
 800bc46: 687b         	ldr	r3, [r7, #0x4]
 800bc48: 689b         	ldr	r3, [r3, #0x8]
 800bc4a: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800bc4e: 461a         	mov	r2, r3
 800bc50: 683b         	ldr	r3, [r7]
 800bc52: 4293         	cmp	r3, r2
 800bc54: d03a         	beq	0x800bccc <adjust_owner_prio+0x90> @ imm = #0x74
; 		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
 800bc56: 2303         	movs	r3, #0x3
 800bc58: 2b03         	cmp	r3, #0x3
 800bc5a: d92f         	bls	0x800bcbc <adjust_owner_prio+0x80> @ imm = #0x5e
 800bc5c: 2301         	movs	r3, #0x1
 800bc5e: 72fb         	strb	r3, [r7, #0xb]
 800bc60: 7afb         	ldrb	r3, [r7, #0xb]
 800bc62: f083 0301    	eor	r3, r3, #0x1
 800bc66: b2db         	uxtb	r3, r3
 800bc68: 2b00         	cmp	r3, #0x0
 800bc6a: d127         	bne	0x800bcbc <adjust_owner_prio+0x80> @ imm = #0x4e
 800bc6c: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800bcd8 <adjust_owner_prio+0x9c>
 800bc6e: 681d         	ldr	r5, [r3]
 800bc70: 687b         	ldr	r3, [r7, #0x4]
 800bc72: 689c         	ldr	r4, [r3, #0x8]
 800bc74: 687b         	ldr	r3, [r7, #0x4]
 800bc76: 689b         	ldr	r3, [r3, #0x8]
 800bc78: 4618         	mov	r0, r3
 800bc7a: f00b fc11    	bl	0x80174a0 <z_is_thread_ready> @ imm = #0xb822
 800bc7e: 4603         	mov	r3, r0
 800bc80: 2b00         	cmp	r3, #0x0
 800bc82: d001         	beq	0x800bc88 <adjust_owner_prio+0x4c> @ imm = #0x2
 800bc84: 2379         	movs	r3, #0x79
 800bc86: e000         	b	0x800bc8a <adjust_owner_prio+0x4e> @ imm = #0x0
 800bc88: 236e         	movs	r3, #0x6e
 800bc8a: 687a         	ldr	r2, [r7, #0x4]
 800bc8c: 6892         	ldr	r2, [r2, #0x8]
 800bc8e: f992 200e    	ldrsb.w	r2, [r2, #0xe]
 800bc92: 9207         	str	r2, [sp, #0x1c]
 800bc94: 683a         	ldr	r2, [r7]
 800bc96: 9206         	str	r2, [sp, #0x18]
 800bc98: 9305         	str	r3, [sp, #0x14]
 800bc9a: 9404         	str	r4, [sp, #0x10]
 800bc9c: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800bcdc <adjust_owner_prio+0xa0>
 800bc9e: 9303         	str	r3, [sp, #0xc]
 800bca0: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800bce0 <adjust_owner_prio+0xa4>
 800bca2: 9302         	str	r3, [sp, #0x8]
 800bca4: 2308         	movs	r3, #0x8
 800bca6: 9301         	str	r3, [sp, #0x4]
 800bca8: 2300         	movs	r3, #0x0
 800bcaa: 9300         	str	r3, [sp]
 800bcac: 2300         	movs	r3, #0x0
 800bcae: 2204         	movs	r2, #0x4
 800bcb0: 4629         	mov	r1, r5
 800bcb2: 2000         	movs	r0, #0x0
 800bcb4: f00b fc98    	bl	0x80175e8 <z_log_msg_runtime_create> @ imm = #0xb930
 800bcb8: 2300         	movs	r3, #0x0
 800bcba: 60fb         	str	r3, [r7, #0xc]
; 		return z_thread_prio_set(mutex->owner, new_prio);
 800bcbc: 687b         	ldr	r3, [r7, #0x4]
 800bcbe: 689b         	ldr	r3, [r3, #0x8]
 800bcc0: 6839         	ldr	r1, [r7]
 800bcc2: 4618         	mov	r0, r3
 800bcc4: f001 fdc0    	bl	0x800d848 <z_thread_prio_set> @ imm = #0x1b80
 800bcc8: 4603         	mov	r3, r0
 800bcca: e000         	b	0x800bcce <adjust_owner_prio+0x92> @ imm = #0x0
; 	return false;
 800bccc: 2300         	movs	r3, #0x0
; }
 800bcce: 4618         	mov	r0, r3
 800bcd0: 3710         	adds	r7, #0x10
 800bcd2: 46bd         	mov	sp, r7
 800bcd4: bdb0         	pop	{r4, r5, r7, pc}
 800bcd6: bf00         	nop

0800bcd8 <$d>:
 800bcd8: 44 05 00 20  	.word	0x20000544
 800bcdc: 64 bd 01 08  	.word	0x0801bd64
 800bce0: ec ae 01 08  	.word	0x0801aeec

0800bce4 <z_impl_k_mutex_lock>:
; {
 800bce4: b580         	push	{r7, lr}
 800bce6: b0b8         	sub	sp, #0xe0
 800bce8: af08         	add	r7, sp, #0x20
 800bcea: 60f8         	str	r0, [r7, #0xc]
 800bcec: e9c7 2300    	strd	r2, r3, [r7]
; 	bool resched = false;
 800bcf0: 2300         	movs	r3, #0x0
 800bcf2: f887 30bf    	strb.w	r3, [r7, #0xbf]
 800bcf6: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x800bf60 <z_impl_k_mutex_lock+0x27c>
 800bcf8: 67fb         	str	r3, [r7, #0x7c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bcfa: f3ef 8311    	mrs	r3, basepri
 800bcfe: 67bb         	str	r3, [r7, #0x78]
;   return(result);
 800bd00: 6fbb         	ldr	r3, [r7, #0x78]
; 	key = __get_BASEPRI();
 800bd02: 677b         	str	r3, [r7, #0x74]
 800bd04: 2310         	movs	r3, #0x10
 800bd06: 673b         	str	r3, [r7, #0x70]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800bd08: 6f3b         	ldr	r3, [r7, #0x70]
 800bd0a: f383 8812    	msr	basepri_max, r3
; }
 800bd0e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800bd10: f3bf 8f6f    	isb	sy
; }
 800bd14: bf00         	nop
; 	return key;
 800bd16: 6f7b         	ldr	r3, [r7, #0x74]
; 	k.key = arch_irq_lock();
 800bd18: 61bb         	str	r3, [r7, #0x18]
 800bd1a: 6ffb         	ldr	r3, [r7, #0x7c]
 800bd1c: 66fb         	str	r3, [r7, #0x6c]
; }
 800bd1e: bf00         	nop
 800bd20: 6ffb         	ldr	r3, [r7, #0x7c]
 800bd22: 66bb         	str	r3, [r7, #0x68]
; }
 800bd24: bf00         	nop
; 	return k;
 800bd26: 69bb         	ldr	r3, [r7, #0x18]
 800bd28: 62bb         	str	r3, [r7, #0x28]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
 800bd2a: 68fb         	ldr	r3, [r7, #0xc]
 800bd2c: 68db         	ldr	r3, [r3, #0xc]
 800bd2e: 2b00         	cmp	r3, #0x0
 800bd30: bf0c         	ite	eq
 800bd32: 2301         	moveq	r3, #0x1
 800bd34: 2300         	movne	r3, #0x0
 800bd36: b2db         	uxtb	r3, r3
 800bd38: 2b00         	cmp	r3, #0x0
 800bd3a: d10a         	bne	0x800bd52 <z_impl_k_mutex_lock+0x6e> @ imm = #0x14
 800bd3c: 68fb         	ldr	r3, [r7, #0xc]
 800bd3e: 689a         	ldr	r2, [r3, #0x8]
 800bd40: 4b88         	ldr	r3, [pc, #0x220]        @ 0x800bf64 <z_impl_k_mutex_lock+0x280>
 800bd42: 689b         	ldr	r3, [r3, #0x8]
 800bd44: 429a         	cmp	r2, r3
 800bd46: bf0c         	ite	eq
 800bd48: 2301         	moveq	r3, #0x1
 800bd4a: 2300         	movne	r3, #0x0
 800bd4c: b2db         	uxtb	r3, r3
 800bd4e: 2b00         	cmp	r3, #0x0
 800bd50: d001         	beq	0x800bd56 <z_impl_k_mutex_lock+0x72> @ imm = #0x2
 800bd52: 2301         	movs	r3, #0x1
 800bd54: e000         	b	0x800bd58 <z_impl_k_mutex_lock+0x74> @ imm = #0x0
 800bd56: 2300         	movs	r3, #0x0
 800bd58: 2b00         	cmp	r3, #0x0
 800bd5a: d053         	beq	0x800be04 <z_impl_k_mutex_lock+0x120> @ imm = #0xa6
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 800bd5c: 68fb         	ldr	r3, [r7, #0xc]
 800bd5e: 68db         	ldr	r3, [r3, #0xc]
; 					_current->base.prio :
 800bd60: 2b00         	cmp	r3, #0x0
 800bd62: d104         	bne	0x800bd6e <z_impl_k_mutex_lock+0x8a> @ imm = #0x8
 800bd64: 4b7f         	ldr	r3, [pc, #0x1fc]        @ 0x800bf64 <z_impl_k_mutex_lock+0x280>
 800bd66: 689b         	ldr	r3, [r3, #0x8]
 800bd68: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800bd6c: e001         	b	0x800bd72 <z_impl_k_mutex_lock+0x8e> @ imm = #0x2
 800bd6e: 68fb         	ldr	r3, [r7, #0xc]
 800bd70: 691b         	ldr	r3, [r3, #0x10]
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 800bd72: 68fa         	ldr	r2, [r7, #0xc]
 800bd74: 6113         	str	r3, [r2, #0x10]
; 		mutex->lock_count++;
 800bd76: 68fb         	ldr	r3, [r7, #0xc]
 800bd78: 68db         	ldr	r3, [r3, #0xc]
 800bd7a: 1c5a         	adds	r2, r3, #0x1
 800bd7c: 68fb         	ldr	r3, [r7, #0xc]
 800bd7e: 60da         	str	r2, [r3, #0xc]
; 		mutex->owner = _current;
 800bd80: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x800bf64 <z_impl_k_mutex_lock+0x280>
 800bd82: 689a         	ldr	r2, [r3, #0x8]
 800bd84: 68fb         	ldr	r3, [r7, #0xc]
 800bd86: 609a         	str	r2, [r3, #0x8]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 800bd88: 2303         	movs	r3, #0x3
 800bd8a: 2b03         	cmp	r3, #0x3
 800bd8c: d927         	bls	0x800bdde <z_impl_k_mutex_lock+0xfa> @ imm = #0x4e
 800bd8e: 2301         	movs	r3, #0x1
 800bd90: f887 3087    	strb.w	r3, [r7, #0x87]
 800bd94: f897 3087    	ldrb.w	r3, [r7, #0x87]
 800bd98: f083 0301    	eor	r3, r3, #0x1
 800bd9c: b2db         	uxtb	r3, r3
 800bd9e: 2b00         	cmp	r3, #0x0
 800bda0: d11d         	bne	0x800bdde <z_impl_k_mutex_lock+0xfa> @ imm = #0x3a
 800bda2: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x800bf68 <z_impl_k_mutex_lock+0x284>
 800bda4: 6818         	ldr	r0, [r3]
 800bda6: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x800bf64 <z_impl_k_mutex_lock+0x280>
 800bda8: 689b         	ldr	r3, [r3, #0x8]
 800bdaa: 68fa         	ldr	r2, [r7, #0xc]
 800bdac: 68d2         	ldr	r2, [r2, #0xc]
 800bdae: 68f9         	ldr	r1, [r7, #0xc]
 800bdb0: 6909         	ldr	r1, [r1, #0x10]
 800bdb2: 9107         	str	r1, [sp, #0x1c]
 800bdb4: 9206         	str	r2, [sp, #0x18]
 800bdb6: 68fa         	ldr	r2, [r7, #0xc]
 800bdb8: 9205         	str	r2, [sp, #0x14]
 800bdba: 9304         	str	r3, [sp, #0x10]
 800bdbc: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x800bf6c <z_impl_k_mutex_lock+0x288>
 800bdbe: 9303         	str	r3, [sp, #0xc]
 800bdc0: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x800bf70 <z_impl_k_mutex_lock+0x28c>
 800bdc2: 9302         	str	r3, [sp, #0x8]
 800bdc4: 2308         	movs	r3, #0x8
 800bdc6: 9301         	str	r3, [sp, #0x4]
 800bdc8: 2300         	movs	r3, #0x0
 800bdca: 9300         	str	r3, [sp]
 800bdcc: 2300         	movs	r3, #0x0
 800bdce: 2204         	movs	r2, #0x4
 800bdd0: 4601         	mov	r1, r0
 800bdd2: 2000         	movs	r0, #0x0
 800bdd4: f00b fc08    	bl	0x80175e8 <z_log_msg_runtime_create> @ imm = #0xb810
 800bdd8: 2300         	movs	r3, #0x0
 800bdda: f8c7 3080    	str.w	r3, [r7, #0x80]
 800bdde: 4b60         	ldr	r3, [pc, #0x180]        @ 0x800bf60 <z_impl_k_mutex_lock+0x27c>
 800bde0: 667b         	str	r3, [r7, #0x64]
 800bde2: 6abb         	ldr	r3, [r7, #0x28]
 800bde4: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 800bde6: 69fb         	ldr	r3, [r7, #0x1c]
 800bde8: 663b         	str	r3, [r7, #0x60]
 800bdea: 6e3b         	ldr	r3, [r7, #0x60]
 800bdec: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800bdee: 6dfb         	ldr	r3, [r7, #0x5c]
 800bdf0: f383 8811    	msr	basepri, r3
; }
 800bdf4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800bdf6: f3bf 8f6f    	isb	sy
; }
 800bdfa: bf00         	nop
; }
 800bdfc: bf00         	nop
; }
 800bdfe: bf00         	nop
; 		return 0;
 800be00: 2300         	movs	r3, #0x0
 800be02: e18c         	b	0x800c11e <z_impl_k_mutex_lock+0x43a> @ imm = #0x318
; 	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
 800be04: e9d7 2300    	ldrd	r2, r3, [r7]
 800be08: f04f 0000    	mov.w	r0, #0x0
 800be0c: f04f 0100    	mov.w	r1, #0x0
 800be10: 428b         	cmp	r3, r1
 800be12: bf08         	it	eq
 800be14: 4282         	cmpeq	r2, r0
 800be16: bf0c         	ite	eq
 800be18: 2301         	moveq	r3, #0x1
 800be1a: 2300         	movne	r3, #0x0
 800be1c: b2db         	uxtb	r3, r3
 800be1e: 2b00         	cmp	r3, #0x0
 800be20: d013         	beq	0x800be4a <z_impl_k_mutex_lock+0x166> @ imm = #0x26
 800be22: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x800bf60 <z_impl_k_mutex_lock+0x27c>
 800be24: 65bb         	str	r3, [r7, #0x58]
 800be26: 6abb         	ldr	r3, [r7, #0x28]
 800be28: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 800be2a: 697b         	ldr	r3, [r7, #0x14]
 800be2c: 657b         	str	r3, [r7, #0x54]
 800be2e: 6d7b         	ldr	r3, [r7, #0x54]
 800be30: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800be32: 6d3b         	ldr	r3, [r7, #0x50]
 800be34: f383 8811    	msr	basepri, r3
; }
 800be38: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800be3a: f3bf 8f6f    	isb	sy
; }
 800be3e: bf00         	nop
; }
 800be40: bf00         	nop
; }
 800be42: bf00         	nop
; 		return -EBUSY;
 800be44: f06f 030f    	mvn	r3, #0xf
 800be48: e169         	b	0x800c11e <z_impl_k_mutex_lock+0x43a> @ imm = #0x2d2
; 	new_prio = new_prio_for_inheritance(_current->base.prio,
 800be4a: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800bf64 <z_impl_k_mutex_lock+0x280>
 800be4c: 689b         	ldr	r3, [r3, #0x8]
 800be4e: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800be52: 461a         	mov	r2, r3
; 					    mutex->owner->base.prio);
 800be54: 68fb         	ldr	r3, [r7, #0xc]
 800be56: 689b         	ldr	r3, [r3, #0x8]
 800be58: f993 300e    	ldrsb.w	r3, [r3, #0xe]
; 	new_prio = new_prio_for_inheritance(_current->base.prio,
 800be5c: 4619         	mov	r1, r3
 800be5e: 4610         	mov	r0, r2
 800be60: f00b fbf6    	bl	0x8017650 <new_prio_for_inheritance> @ imm = #0xb7ec
 800be64: f8c7 00b8    	str.w	r0, [r7, #0xb8]
; 	LOG_DBG("adjusting prio up on mutex %p", mutex);
 800be68: 2303         	movs	r3, #0x3
 800be6a: 2b03         	cmp	r3, #0x3
 800be6c: d91d         	bls	0x800beaa <z_impl_k_mutex_lock+0x1c6> @ imm = #0x3a
 800be6e: 2301         	movs	r3, #0x1
 800be70: f887 30b7    	strb.w	r3, [r7, #0xb7]
 800be74: f897 30b7    	ldrb.w	r3, [r7, #0xb7]
 800be78: f083 0301    	eor	r3, r3, #0x1
 800be7c: b2db         	uxtb	r3, r3
 800be7e: 2b00         	cmp	r3, #0x0
 800be80: d113         	bne	0x800beaa <z_impl_k_mutex_lock+0x1c6> @ imm = #0x26
 800be82: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800bf68 <z_impl_k_mutex_lock+0x284>
 800be84: 6819         	ldr	r1, [r3]
 800be86: 68fb         	ldr	r3, [r7, #0xc]
 800be88: 9304         	str	r3, [sp, #0x10]
 800be8a: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x800bf6c <z_impl_k_mutex_lock+0x288>
 800be8c: 9303         	str	r3, [sp, #0xc]
 800be8e: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800bf74 <z_impl_k_mutex_lock+0x290>
 800be90: 9302         	str	r3, [sp, #0x8]
 800be92: 2308         	movs	r3, #0x8
 800be94: 9301         	str	r3, [sp, #0x4]
 800be96: 2300         	movs	r3, #0x0
 800be98: 9300         	str	r3, [sp]
 800be9a: 2300         	movs	r3, #0x0
 800be9c: 2204         	movs	r2, #0x4
 800be9e: 2000         	movs	r0, #0x0
 800bea0: f00b fba2    	bl	0x80175e8 <z_log_msg_runtime_create> @ imm = #0xb744
 800bea4: 2300         	movs	r3, #0x0
 800bea6: f8c7 30b0    	str.w	r3, [r7, #0xb0]
; 	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
 800beaa: 68fb         	ldr	r3, [r7, #0xc]
 800beac: 689b         	ldr	r3, [r3, #0x8]
 800beae: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800beb2: 4619         	mov	r1, r3
 800beb4: f8d7 00b8    	ldr.w	r0, [r7, #0xb8]
 800beb8: f00b fb55    	bl	0x8017566 <z_is_prio_higher> @ imm = #0xb6aa
 800bebc: 4603         	mov	r3, r0
 800bebe: 2b00         	cmp	r3, #0x0
 800bec0: d007         	beq	0x800bed2 <z_impl_k_mutex_lock+0x1ee> @ imm = #0xe
; 		resched = adjust_owner_prio(mutex, new_prio);
 800bec2: f8d7 10b8    	ldr.w	r1, [r7, #0xb8]
 800bec6: 68f8         	ldr	r0, [r7, #0xc]
 800bec8: f7ff feb8    	bl	0x800bc3c <adjust_owner_prio> @ imm = #-0x290
 800becc: 4603         	mov	r3, r0
 800bece: f887 30bf    	strb.w	r3, [r7, #0xbf]
; 	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
 800bed2: 68f9         	ldr	r1, [r7, #0xc]
 800bed4: e9d7 2300    	ldrd	r2, r3, [r7]
 800bed8: e9cd 2300    	strd	r2, r3, [sp]
 800bedc: 460a         	mov	r2, r1
 800bede: 6ab9         	ldr	r1, [r7, #0x28]
 800bee0: 481f         	ldr	r0, [pc, #0x7c]         @ 0x800bf60 <z_impl_k_mutex_lock+0x27c>
 800bee2: f001 fc6f    	bl	0x800d7c4 <z_pend_curr> @ imm = #0x18de
 800bee6: f8c7 00ac    	str.w	r0, [r7, #0xac]
; 	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);
 800beea: 2303         	movs	r3, #0x3
 800beec: 2b03         	cmp	r3, #0x3
 800beee: d920         	bls	0x800bf32 <z_impl_k_mutex_lock+0x24e> @ imm = #0x40
 800bef0: 2301         	movs	r3, #0x1
 800bef2: f887 30ab    	strb.w	r3, [r7, #0xab]
 800bef6: f897 30ab    	ldrb.w	r3, [r7, #0xab]
 800befa: f083 0301    	eor	r3, r3, #0x1
 800befe: b2db         	uxtb	r3, r3
 800bf00: 2b00         	cmp	r3, #0x0
 800bf02: d116         	bne	0x800bf32 <z_impl_k_mutex_lock+0x24e> @ imm = #0x2c
 800bf04: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800bf68 <z_impl_k_mutex_lock+0x284>
 800bf06: 6819         	ldr	r1, [r3]
 800bf08: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 800bf0c: 9305         	str	r3, [sp, #0x14]
 800bf0e: 68fb         	ldr	r3, [r7, #0xc]
 800bf10: 9304         	str	r3, [sp, #0x10]
 800bf12: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800bf6c <z_impl_k_mutex_lock+0x288>
 800bf14: 9303         	str	r3, [sp, #0xc]
 800bf16: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800bf78 <z_impl_k_mutex_lock+0x294>
 800bf18: 9302         	str	r3, [sp, #0x8]
 800bf1a: 2308         	movs	r3, #0x8
 800bf1c: 9301         	str	r3, [sp, #0x4]
 800bf1e: 2300         	movs	r3, #0x0
 800bf20: 9300         	str	r3, [sp]
 800bf22: 2300         	movs	r3, #0x0
 800bf24: 2204         	movs	r2, #0x4
 800bf26: 2000         	movs	r0, #0x0
 800bf28: f00b fb5e    	bl	0x80175e8 <z_log_msg_runtime_create> @ imm = #0xb6bc
 800bf2c: 2300         	movs	r3, #0x0
 800bf2e: f8c7 30a4    	str.w	r3, [r7, #0xa4]
; 	LOG_DBG("%p got mutex %p (y/n): %c", _current, mutex,
 800bf32: 2303         	movs	r3, #0x3
 800bf34: 2b03         	cmp	r3, #0x3
 800bf36: d936         	bls	0x800bfa6 <z_impl_k_mutex_lock+0x2c2> @ imm = #0x6c
 800bf38: 2301         	movs	r3, #0x1
 800bf3a: f887 30a3    	strb.w	r3, [r7, #0xa3]
 800bf3e: f897 30a3    	ldrb.w	r3, [r7, #0xa3]
 800bf42: f083 0301    	eor	r3, r3, #0x1
 800bf46: b2db         	uxtb	r3, r3
 800bf48: 2b00         	cmp	r3, #0x0
 800bf4a: d12c         	bne	0x800bfa6 <z_impl_k_mutex_lock+0x2c2> @ imm = #0x58
 800bf4c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800bf68 <z_impl_k_mutex_lock+0x284>
 800bf4e: 6819         	ldr	r1, [r3]
 800bf50: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800bf64 <z_impl_k_mutex_lock+0x280>
 800bf52: 689b         	ldr	r3, [r3, #0x8]
 800bf54: f8d7 20ac    	ldr.w	r2, [r7, #0xac]
 800bf58: 2a00         	cmp	r2, #0x0
 800bf5a: d00f         	beq	0x800bf7c <z_impl_k_mutex_lock+0x298> @ imm = #0x1e
 800bf5c: 2279         	movs	r2, #0x79
 800bf5e: e00e         	b	0x800bf7e <z_impl_k_mutex_lock+0x29a> @ imm = #0x1c

0800bf60 <$d>:
 800bf60: e0 10 00 20  	.word	0x200010e0
 800bf64: c8 06 00 20  	.word	0x200006c8
 800bf68: 44 05 00 20  	.word	0x20000544
 800bf6c: 78 bd 01 08  	.word	0x0801bd78
 800bf70: 24 af 01 08  	.word	0x0801af24
 800bf74: 54 af 01 08  	.word	0x0801af54
 800bf78: 78 af 01 08  	.word	0x0801af78

0800bf7c <$t>:
 800bf7c: 226e         	movs	r2, #0x6e
 800bf7e: 9206         	str	r2, [sp, #0x18]
 800bf80: 68fa         	ldr	r2, [r7, #0xc]
 800bf82: 9205         	str	r2, [sp, #0x14]
 800bf84: 9304         	str	r3, [sp, #0x10]
 800bf86: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x800c128 <z_impl_k_mutex_lock+0x444>
 800bf88: 9303         	str	r3, [sp, #0xc]
 800bf8a: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x800c12c <z_impl_k_mutex_lock+0x448>
 800bf8c: 9302         	str	r3, [sp, #0x8]
 800bf8e: 2308         	movs	r3, #0x8
 800bf90: 9301         	str	r3, [sp, #0x4]
 800bf92: 2300         	movs	r3, #0x0
 800bf94: 9300         	str	r3, [sp]
 800bf96: 2300         	movs	r3, #0x0
 800bf98: 2204         	movs	r2, #0x4
 800bf9a: 2000         	movs	r0, #0x0
 800bf9c: f00b fb24    	bl	0x80175e8 <z_log_msg_runtime_create> @ imm = #0xb648
 800bfa0: 2300         	movs	r3, #0x0
 800bfa2: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	if (got_mutex == 0) {
 800bfa6: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 800bfaa: 2b00         	cmp	r3, #0x0
 800bfac: d101         	bne	0x800bfb2 <z_impl_k_mutex_lock+0x2ce> @ imm = #0x2
; 		return 0;
 800bfae: 2300         	movs	r3, #0x0
 800bfb0: e0b5         	b	0x800c11e <z_impl_k_mutex_lock+0x43a> @ imm = #0x16a
; 	LOG_DBG("%p timeout on mutex %p", _current, mutex);
 800bfb2: 2303         	movs	r3, #0x3
 800bfb4: 2b03         	cmp	r3, #0x3
 800bfb6: d920         	bls	0x800bffa <z_impl_k_mutex_lock+0x316> @ imm = #0x40
 800bfb8: 2301         	movs	r3, #0x1
 800bfba: f887 309b    	strb.w	r3, [r7, #0x9b]
 800bfbe: f897 309b    	ldrb.w	r3, [r7, #0x9b]
 800bfc2: f083 0301    	eor	r3, r3, #0x1
 800bfc6: b2db         	uxtb	r3, r3
 800bfc8: 2b00         	cmp	r3, #0x0
 800bfca: d116         	bne	0x800bffa <z_impl_k_mutex_lock+0x316> @ imm = #0x2c
 800bfcc: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800c130 <z_impl_k_mutex_lock+0x44c>
 800bfce: 6819         	ldr	r1, [r3]
 800bfd0: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800c134 <z_impl_k_mutex_lock+0x450>
 800bfd2: 689b         	ldr	r3, [r3, #0x8]
 800bfd4: 68fa         	ldr	r2, [r7, #0xc]
 800bfd6: 9205         	str	r2, [sp, #0x14]
 800bfd8: 9304         	str	r3, [sp, #0x10]
 800bfda: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800c128 <z_impl_k_mutex_lock+0x444>
 800bfdc: 9303         	str	r3, [sp, #0xc]
 800bfde: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800c138 <z_impl_k_mutex_lock+0x454>
 800bfe0: 9302         	str	r3, [sp, #0x8]
 800bfe2: 2308         	movs	r3, #0x8
 800bfe4: 9301         	str	r3, [sp, #0x4]
 800bfe6: 2300         	movs	r3, #0x0
 800bfe8: 9300         	str	r3, [sp]
 800bfea: 2300         	movs	r3, #0x0
 800bfec: 2204         	movs	r2, #0x4
 800bfee: 2000         	movs	r0, #0x0
 800bff0: f00b fafa    	bl	0x80175e8 <z_log_msg_runtime_create> @ imm = #0xb5f4
 800bff4: 2300         	movs	r3, #0x0
 800bff6: f8c7 3094    	str.w	r3, [r7, #0x94]
 800bffa: 4b50         	ldr	r3, [pc, #0x140]        @ 0x800c13c <z_impl_k_mutex_lock+0x458>
 800bffc: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bffe: f3ef 8311    	mrs	r3, basepri
 800c002: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800c004: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 800c006: 647b         	str	r3, [r7, #0x44]
 800c008: 2310         	movs	r3, #0x10
 800c00a: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c00c: 6c3b         	ldr	r3, [r7, #0x40]
 800c00e: f383 8812    	msr	basepri_max, r3
; }
 800c012: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c014: f3bf 8f6f    	isb	sy
; }
 800c018: bf00         	nop
; 	return key;
 800c01a: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 800c01c: 623b         	str	r3, [r7, #0x20]
 800c01e: 6cfb         	ldr	r3, [r7, #0x4c]
 800c020: 63fb         	str	r3, [r7, #0x3c]
; }
 800c022: bf00         	nop
 800c024: 6cfb         	ldr	r3, [r7, #0x4c]
 800c026: 63bb         	str	r3, [r7, #0x38]
; }
 800c028: bf00         	nop
; 	return k;
 800c02a: 6a3b         	ldr	r3, [r7, #0x20]
 800c02c: 62bb         	str	r3, [r7, #0x28]
; 	if (likely(mutex->owner != NULL)) {
 800c02e: 68fb         	ldr	r3, [r7, #0xc]
 800c030: 689b         	ldr	r3, [r3, #0x8]
 800c032: 2b00         	cmp	r3, #0x0
 800c034: bf14         	ite	ne
 800c036: 2301         	movne	r3, #0x1
 800c038: 2300         	moveq	r3, #0x0
 800c03a: b2db         	uxtb	r3, r3
 800c03c: 2b00         	cmp	r3, #0x0
 800c03e: d052         	beq	0x800c0e6 <z_impl_k_mutex_lock+0x402> @ imm = #0xa4
; 		struct k_thread *waiter = z_waitq_head(&mutex->wait_q);
 800c040: 68fb         	ldr	r3, [r7, #0xc]
 800c042: 4618         	mov	r0, r3
 800c044: f00b fac3    	bl	0x80175ce <z_waitq_head> @ imm = #0xb586
 800c048: f8c7 0090    	str.w	r0, [r7, #0x90]
; 			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
 800c04c: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 800c050: 2b00         	cmp	r3, #0x0
 800c052: d00c         	beq	0x800c06e <z_impl_k_mutex_lock+0x38a> @ imm = #0x18
 800c054: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 800c058: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800c05c: 461a         	mov	r2, r3
 800c05e: 68fb         	ldr	r3, [r7, #0xc]
 800c060: 691b         	ldr	r3, [r3, #0x10]
 800c062: 4619         	mov	r1, r3
 800c064: 4610         	mov	r0, r2
 800c066: f00b faf3    	bl	0x8017650 <new_prio_for_inheritance> @ imm = #0xb5e6
 800c06a: 4603         	mov	r3, r0
 800c06c: e001         	b	0x800c072 <z_impl_k_mutex_lock+0x38e> @ imm = #0x2
 800c06e: 68fb         	ldr	r3, [r7, #0xc]
 800c070: 691b         	ldr	r3, [r3, #0x10]
; 		new_prio = (waiter != NULL) ?
 800c072: f8c7 30b8    	str.w	r3, [r7, #0xb8]
; 		LOG_DBG("adjusting prio down on mutex %p", mutex);
 800c076: 2303         	movs	r3, #0x3
 800c078: 2b03         	cmp	r3, #0x3
 800c07a: d91d         	bls	0x800c0b8 <z_impl_k_mutex_lock+0x3d4> @ imm = #0x3a
 800c07c: 2301         	movs	r3, #0x1
 800c07e: f887 308f    	strb.w	r3, [r7, #0x8f]
 800c082: f897 308f    	ldrb.w	r3, [r7, #0x8f]
 800c086: f083 0301    	eor	r3, r3, #0x1
 800c08a: b2db         	uxtb	r3, r3
 800c08c: 2b00         	cmp	r3, #0x0
 800c08e: d113         	bne	0x800c0b8 <z_impl_k_mutex_lock+0x3d4> @ imm = #0x26
 800c090: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800c130 <z_impl_k_mutex_lock+0x44c>
 800c092: 6819         	ldr	r1, [r3]
 800c094: 68fb         	ldr	r3, [r7, #0xc]
 800c096: 9304         	str	r3, [sp, #0x10]
 800c098: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800c128 <z_impl_k_mutex_lock+0x444>
 800c09a: 9303         	str	r3, [sp, #0xc]
 800c09c: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800c140 <z_impl_k_mutex_lock+0x45c>
 800c09e: 9302         	str	r3, [sp, #0x8]
 800c0a0: 2308         	movs	r3, #0x8
 800c0a2: 9301         	str	r3, [sp, #0x4]
 800c0a4: 2300         	movs	r3, #0x0
 800c0a6: 9300         	str	r3, [sp]
 800c0a8: 2300         	movs	r3, #0x0
 800c0aa: 2204         	movs	r2, #0x4
 800c0ac: 2000         	movs	r0, #0x0
 800c0ae: f00b fa9b    	bl	0x80175e8 <z_log_msg_runtime_create> @ imm = #0xb536
 800c0b2: 2300         	movs	r3, #0x0
 800c0b4: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		resched = adjust_owner_prio(mutex, new_prio) || resched;
 800c0b8: f8d7 10b8    	ldr.w	r1, [r7, #0xb8]
 800c0bc: 68f8         	ldr	r0, [r7, #0xc]
 800c0be: f7ff fdbd    	bl	0x800bc3c <adjust_owner_prio> @ imm = #-0x486
 800c0c2: 4603         	mov	r3, r0
 800c0c4: 2b00         	cmp	r3, #0x0
 800c0c6: d103         	bne	0x800c0d0 <z_impl_k_mutex_lock+0x3ec> @ imm = #0x6
 800c0c8: f897 30bf    	ldrb.w	r3, [r7, #0xbf]
 800c0cc: 2b00         	cmp	r3, #0x0
 800c0ce: d001         	beq	0x800c0d4 <z_impl_k_mutex_lock+0x3f0> @ imm = #0x2
 800c0d0: 2301         	movs	r3, #0x1
 800c0d2: e000         	b	0x800c0d6 <z_impl_k_mutex_lock+0x3f2> @ imm = #0x0
 800c0d4: 2300         	movs	r3, #0x0
 800c0d6: f887 30bf    	strb.w	r3, [r7, #0xbf]
 800c0da: f897 30bf    	ldrb.w	r3, [r7, #0xbf]
 800c0de: f003 0301    	and	r3, r3, #0x1
 800c0e2: f887 30bf    	strb.w	r3, [r7, #0xbf]
; 	if (resched) {
 800c0e6: f897 30bf    	ldrb.w	r3, [r7, #0xbf]
 800c0ea: 2b00         	cmp	r3, #0x0
 800c0ec: d004         	beq	0x800c0f8 <z_impl_k_mutex_lock+0x414> @ imm = #0x8
; 		z_reschedule(&lock, key);
 800c0ee: 6ab9         	ldr	r1, [r7, #0x28]
 800c0f0: 4812         	ldr	r0, [pc, #0x48]         @ 0x800c13c <z_impl_k_mutex_lock+0x458>
 800c0f2: f00c fb9a    	bl	0x801882a <z_reschedule> @ imm = #0xc734
 800c0f6: e010         	b	0x800c11a <z_impl_k_mutex_lock+0x436> @ imm = #0x20
 800c0f8: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800c13c <z_impl_k_mutex_lock+0x458>
 800c0fa: 637b         	str	r3, [r7, #0x34]
 800c0fc: 6abb         	ldr	r3, [r7, #0x28]
 800c0fe: 627b         	str	r3, [r7, #0x24]
; 	arch_irq_unlock(key.key);
 800c100: 6a7b         	ldr	r3, [r7, #0x24]
 800c102: 633b         	str	r3, [r7, #0x30]
 800c104: 6b3b         	ldr	r3, [r7, #0x30]
 800c106: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c108: 6afb         	ldr	r3, [r7, #0x2c]
 800c10a: f383 8811    	msr	basepri, r3
; }
 800c10e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c110: f3bf 8f6f    	isb	sy
; }
 800c114: bf00         	nop
; }
 800c116: bf00         	nop
; }
 800c118: bf00         	nop
; 	return -EAGAIN;
 800c11a: f06f 030a    	mvn	r3, #0xa
; }
 800c11e: 4618         	mov	r0, r3
 800c120: 37c0         	adds	r7, #0xc0
 800c122: 46bd         	mov	sp, r7
 800c124: bd80         	pop	{r7, pc}
 800c126: bf00         	nop

0800c128 <$d>:
 800c128: 78 bd 01 08  	.word	0x0801bd78
 800c12c: 9c af 01 08  	.word	0x0801af9c
 800c130: 44 05 00 20  	.word	0x20000544
 800c134: c8 06 00 20  	.word	0x200006c8
 800c138: bc af 01 08  	.word	0x0801afbc
 800c13c: e0 10 00 20  	.word	0x200010e0
 800c140: d8 af 01 08  	.word	0x0801afd8

0800c144 <z_impl_k_mutex_unlock>:
; {
 800c144: b580         	push	{r7, lr}
 800c146: b0a2         	sub	sp, #0x88
 800c148: af08         	add	r7, sp, #0x20
 800c14a: 6078         	str	r0, [r7, #0x4]
; 	CHECKIF(mutex->owner == NULL) {
 800c14c: 687b         	ldr	r3, [r7, #0x4]
 800c14e: 689b         	ldr	r3, [r3, #0x8]
 800c150: 2b00         	cmp	r3, #0x0
 800c152: d102         	bne	0x800c15a <z_impl_k_mutex_unlock+0x16> @ imm = #0x4
; 		return -EINVAL;
 800c154: f06f 0315    	mvn	r3, #0x15
 800c158: e0da         	b	0x800c310 <z_impl_k_mutex_unlock+0x1cc> @ imm = #0x1b4
; 	CHECKIF(mutex->owner != _current) {
 800c15a: 687b         	ldr	r3, [r7, #0x4]
 800c15c: 689a         	ldr	r2, [r3, #0x8]
 800c15e: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x800c318 <z_impl_k_mutex_unlock+0x1d4>
 800c160: 689b         	ldr	r3, [r3, #0x8]
 800c162: 429a         	cmp	r2, r3
 800c164: d002         	beq	0x800c16c <z_impl_k_mutex_unlock+0x28> @ imm = #0x4
; 		return -EPERM;
 800c166: f04f 33ff    	mov.w	r3, #0xffffffff
 800c16a: e0d1         	b	0x800c310 <z_impl_k_mutex_unlock+0x1cc> @ imm = #0x1a2
; 	LOG_DBG("mutex %p lock_count: %d", mutex, mutex->lock_count);
 800c16c: 2303         	movs	r3, #0x3
 800c16e: 2b03         	cmp	r3, #0x3
 800c170: d91f         	bls	0x800c1b2 <z_impl_k_mutex_unlock+0x6e> @ imm = #0x3e
 800c172: 2301         	movs	r3, #0x1
 800c174: f887 3067    	strb.w	r3, [r7, #0x67]
 800c178: f897 3067    	ldrb.w	r3, [r7, #0x67]
 800c17c: f083 0301    	eor	r3, r3, #0x1
 800c180: b2db         	uxtb	r3, r3
 800c182: 2b00         	cmp	r3, #0x0
 800c184: d115         	bne	0x800c1b2 <z_impl_k_mutex_unlock+0x6e> @ imm = #0x2a
 800c186: 4b65         	ldr	r3, [pc, #0x194]        @ 0x800c31c <z_impl_k_mutex_unlock+0x1d8>
 800c188: 6819         	ldr	r1, [r3]
 800c18a: 687b         	ldr	r3, [r7, #0x4]
 800c18c: 68db         	ldr	r3, [r3, #0xc]
 800c18e: 9305         	str	r3, [sp, #0x14]
 800c190: 687b         	ldr	r3, [r7, #0x4]
 800c192: 9304         	str	r3, [sp, #0x10]
 800c194: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800c320 <z_impl_k_mutex_unlock+0x1dc>
 800c196: 9303         	str	r3, [sp, #0xc]
 800c198: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800c324 <z_impl_k_mutex_unlock+0x1e0>
 800c19a: 9302         	str	r3, [sp, #0x8]
 800c19c: 2308         	movs	r3, #0x8
 800c19e: 9301         	str	r3, [sp, #0x4]
 800c1a0: 2300         	movs	r3, #0x0
 800c1a2: 9300         	str	r3, [sp]
 800c1a4: 2300         	movs	r3, #0x0
 800c1a6: 2204         	movs	r2, #0x4
 800c1a8: 2000         	movs	r0, #0x0
 800c1aa: f00b fa1d    	bl	0x80175e8 <z_log_msg_runtime_create> @ imm = #0xb43a
 800c1ae: 2300         	movs	r3, #0x0
 800c1b0: 663b         	str	r3, [r7, #0x60]
; 	if (mutex->lock_count > 1U) {
 800c1b2: 687b         	ldr	r3, [r7, #0x4]
 800c1b4: 68db         	ldr	r3, [r3, #0xc]
 800c1b6: 2b01         	cmp	r3, #0x1
 800c1b8: d905         	bls	0x800c1c6 <z_impl_k_mutex_unlock+0x82> @ imm = #0xa
; 		mutex->lock_count--;
 800c1ba: 687b         	ldr	r3, [r7, #0x4]
 800c1bc: 68db         	ldr	r3, [r3, #0xc]
 800c1be: 1e5a         	subs	r2, r3, #0x1
 800c1c0: 687b         	ldr	r3, [r7, #0x4]
 800c1c2: 60da         	str	r2, [r3, #0xc]
; 		goto k_mutex_unlock_return;
 800c1c4: e0a3         	b	0x800c30e <z_impl_k_mutex_unlock+0x1ca> @ imm = #0x146
 800c1c6: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800c328 <z_impl_k_mutex_unlock+0x1e4>
 800c1c8: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c1ca: f3ef 8311    	mrs	r3, basepri
 800c1ce: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800c1d0: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 800c1d2: 637b         	str	r3, [r7, #0x34]
 800c1d4: 2310         	movs	r3, #0x10
 800c1d6: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c1d8: 6b3b         	ldr	r3, [r7, #0x30]
 800c1da: f383 8812    	msr	basepri_max, r3
; }
 800c1de: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c1e0: f3bf 8f6f    	isb	sy
; }
 800c1e4: bf00         	nop
; 	return key;
 800c1e6: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 800c1e8: 60bb         	str	r3, [r7, #0x8]
 800c1ea: 6bfb         	ldr	r3, [r7, #0x3c]
 800c1ec: 62fb         	str	r3, [r7, #0x2c]
; }
 800c1ee: bf00         	nop
 800c1f0: 6bfb         	ldr	r3, [r7, #0x3c]
 800c1f2: 62bb         	str	r3, [r7, #0x28]
; }
 800c1f4: bf00         	nop
; 	return k;
 800c1f6: 68bb         	ldr	r3, [r7, #0x8]
 800c1f8: 613b         	str	r3, [r7, #0x10]
; 	adjust_owner_prio(mutex, mutex->owner_orig_prio);
 800c1fa: 687b         	ldr	r3, [r7, #0x4]
 800c1fc: 691b         	ldr	r3, [r3, #0x10]
 800c1fe: 4619         	mov	r1, r3
 800c200: 6878         	ldr	r0, [r7, #0x4]
 800c202: f7ff fd1b    	bl	0x800bc3c <adjust_owner_prio> @ imm = #-0x5ca
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 800c206: 687b         	ldr	r3, [r7, #0x4]
 800c208: 653b         	str	r3, [r7, #0x50]
; 	struct k_thread *thread = NULL;
 800c20a: 2300         	movs	r3, #0x0
 800c20c: 64fb         	str	r3, [r7, #0x4c]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800c20e: 6d3b         	ldr	r3, [r7, #0x50]
 800c210: 64bb         	str	r3, [r7, #0x48]
; 	struct k_thread *thread = NULL;
 800c212: 2300         	movs	r3, #0x0
 800c214: 647b         	str	r3, [r7, #0x44]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800c216: 6cb8         	ldr	r0, [r7, #0x48]
 800c218: f00b f8bd    	bl	0x8017396 <sys_dlist_peek_head> @ imm = #0xb17a
 800c21c: 6438         	str	r0, [r7, #0x40]
; 	if (n != NULL) {
 800c21e: 6c3b         	ldr	r3, [r7, #0x40]
 800c220: 2b00         	cmp	r3, #0x0
 800c222: d001         	beq	0x800c228 <z_impl_k_mutex_unlock+0xe4> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800c224: 6c3b         	ldr	r3, [r7, #0x40]
 800c226: 647b         	str	r3, [r7, #0x44]
; 	return thread;
 800c228: 6c7b         	ldr	r3, [r7, #0x44]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800c22a: 64fb         	str	r3, [r7, #0x4c]
; 		if (unlikely(thread != NULL)) {
 800c22c: 6cfb         	ldr	r3, [r7, #0x4c]
 800c22e: 2b00         	cmp	r3, #0x0
 800c230: bf14         	ite	ne
 800c232: 2301         	movne	r3, #0x1
 800c234: 2300         	moveq	r3, #0x0
 800c236: b2db         	uxtb	r3, r3
 800c238: 2b00         	cmp	r3, #0x0
 800c23a: d005         	beq	0x800c248 <z_impl_k_mutex_unlock+0x104> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 800c23c: 6cf8         	ldr	r0, [r7, #0x4c]
 800c23e: f00b f9a0    	bl	0x8017582 <unpend_thread_no_timeout> @ imm = #0xb340
; 			(void)z_abort_thread_timeout(thread);
 800c242: 6cf8         	ldr	r0, [r7, #0x4c]
 800c244: f00b f8f1    	bl	0x801742a <z_abort_thread_timeout> @ imm = #0xb1e2
; 	return thread;
 800c248: 6cfb         	ldr	r3, [r7, #0x4c]
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 800c24a: 65fb         	str	r3, [r7, #0x5c]
; 	mutex->owner = new_owner;
 800c24c: 687b         	ldr	r3, [r7, #0x4]
 800c24e: 6dfa         	ldr	r2, [r7, #0x5c]
 800c250: 609a         	str	r2, [r3, #0x8]
; 	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
 800c252: 2303         	movs	r3, #0x3
 800c254: 2b03         	cmp	r3, #0x3
 800c256: d927         	bls	0x800c2a8 <z_impl_k_mutex_unlock+0x164> @ imm = #0x4e
 800c258: 2301         	movs	r3, #0x1
 800c25a: f887 305b    	strb.w	r3, [r7, #0x5b]
 800c25e: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 800c262: f083 0301    	eor	r3, r3, #0x1
 800c266: b2db         	uxtb	r3, r3
 800c268: 2b00         	cmp	r3, #0x0
 800c26a: d11d         	bne	0x800c2a8 <z_impl_k_mutex_unlock+0x164> @ imm = #0x3a
 800c26c: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800c31c <z_impl_k_mutex_unlock+0x1d8>
 800c26e: 6819         	ldr	r1, [r3]
 800c270: 6dfb         	ldr	r3, [r7, #0x5c]
 800c272: 2b00         	cmp	r3, #0x0
 800c274: d003         	beq	0x800c27e <z_impl_k_mutex_unlock+0x13a> @ imm = #0x6
 800c276: 6dfb         	ldr	r3, [r7, #0x5c]
 800c278: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800c27c: e000         	b	0x800c280 <z_impl_k_mutex_unlock+0x13c> @ imm = #0x0
 800c27e: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800c32c <z_impl_k_mutex_unlock+0x1e8>
 800c280: 9306         	str	r3, [sp, #0x18]
 800c282: 6dfb         	ldr	r3, [r7, #0x5c]
 800c284: 9305         	str	r3, [sp, #0x14]
 800c286: 687b         	ldr	r3, [r7, #0x4]
 800c288: 9304         	str	r3, [sp, #0x10]
 800c28a: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800c320 <z_impl_k_mutex_unlock+0x1dc>
 800c28c: 9303         	str	r3, [sp, #0xc]
 800c28e: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800c330 <z_impl_k_mutex_unlock+0x1ec>
 800c290: 9302         	str	r3, [sp, #0x8]
 800c292: 2308         	movs	r3, #0x8
 800c294: 9301         	str	r3, [sp, #0x4]
 800c296: 2300         	movs	r3, #0x0
 800c298: 9300         	str	r3, [sp]
 800c29a: 2300         	movs	r3, #0x0
 800c29c: 2204         	movs	r2, #0x4
 800c29e: 2000         	movs	r0, #0x0
 800c2a0: f00b f9a2    	bl	0x80175e8 <z_log_msg_runtime_create> @ imm = #0xb344
 800c2a4: 2300         	movs	r3, #0x0
 800c2a6: 657b         	str	r3, [r7, #0x54]
; 	if (unlikely(new_owner != NULL)) {
 800c2a8: 6dfb         	ldr	r3, [r7, #0x5c]
 800c2aa: 2b00         	cmp	r3, #0x0
 800c2ac: bf14         	ite	ne
 800c2ae: 2301         	movne	r3, #0x1
 800c2b0: 2300         	moveq	r3, #0x0
 800c2b2: b2db         	uxtb	r3, r3
 800c2b4: 2b00         	cmp	r3, #0x0
 800c2b6: d016         	beq	0x800c2e6 <z_impl_k_mutex_unlock+0x1a2> @ imm = #0x2c
; 		mutex->owner_orig_prio = new_owner->base.prio;
 800c2b8: 6dfb         	ldr	r3, [r7, #0x5c]
 800c2ba: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800c2be: 461a         	mov	r2, r3
 800c2c0: 687b         	ldr	r3, [r7, #0x4]
 800c2c2: 611a         	str	r2, [r3, #0x10]
 800c2c4: 6dfb         	ldr	r3, [r7, #0x5c]
 800c2c6: 627b         	str	r3, [r7, #0x24]
 800c2c8: 2300         	movs	r3, #0x0
 800c2ca: 623b         	str	r3, [r7, #0x20]
; 	thread->arch.swap_return_value = value;
 800c2cc: 6a7b         	ldr	r3, [r7, #0x24]
 800c2ce: 6a3a         	ldr	r2, [r7, #0x20]
 800c2d0: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800c2d4: bf00         	nop
; 		z_ready_thread(new_owner);
 800c2d6: 6df8         	ldr	r0, [r7, #0x5c]
 800c2d8: f000 ffb0    	bl	0x800d23c <z_ready_thread> @ imm = #0xf60
; 		z_reschedule(&lock, key);
 800c2dc: 6939         	ldr	r1, [r7, #0x10]
 800c2de: 4812         	ldr	r0, [pc, #0x48]         @ 0x800c328 <z_impl_k_mutex_unlock+0x1e4>
 800c2e0: f00c faa3    	bl	0x801882a <z_reschedule> @ imm = #0xc546
 800c2e4: e013         	b	0x800c30e <z_impl_k_mutex_unlock+0x1ca> @ imm = #0x26
; 		mutex->lock_count = 0U;
 800c2e6: 687b         	ldr	r3, [r7, #0x4]
 800c2e8: 2200         	movs	r2, #0x0
 800c2ea: 60da         	str	r2, [r3, #0xc]
 800c2ec: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800c328 <z_impl_k_mutex_unlock+0x1e4>
 800c2ee: 61fb         	str	r3, [r7, #0x1c]
 800c2f0: 693b         	ldr	r3, [r7, #0x10]
 800c2f2: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800c2f4: 68fb         	ldr	r3, [r7, #0xc]
 800c2f6: 61bb         	str	r3, [r7, #0x18]
 800c2f8: 69bb         	ldr	r3, [r7, #0x18]
 800c2fa: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c2fc: 697b         	ldr	r3, [r7, #0x14]
 800c2fe: f383 8811    	msr	basepri, r3
; }
 800c302: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c304: f3bf 8f6f    	isb	sy
; }
 800c308: bf00         	nop
; }
 800c30a: bf00         	nop
; }
 800c30c: bf00         	nop
; 	return 0;
 800c30e: 2300         	movs	r3, #0x0
; }
 800c310: 4618         	mov	r0, r3
 800c312: 3768         	adds	r7, #0x68
 800c314: 46bd         	mov	sp, r7
 800c316: bd80         	pop	{r7, pc}

0800c318 <$d>:
 800c318: c8 06 00 20  	.word	0x200006c8
 800c31c: 44 05 00 20  	.word	0x20000544
 800c320: 8c bd 01 08  	.word	0x0801bd8c
 800c324: fc af 01 08  	.word	0x0801affc
 800c328: e0 10 00 20  	.word	0x200010e0
 800c32c: 18 fc ff ff  	.word	0xfffffc18
 800c330: 18 b0 01 08  	.word	0x0801b018

0800c334 <z_impl_k_sem_give>:
; {
 800c334: b580         	push	{r7, lr}
 800c336: b098         	sub	sp, #0x60
 800c338: af00         	add	r7, sp, #0x0
 800c33a: 6078         	str	r0, [r7, #0x4]
 800c33c: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800c44c <z_impl_k_sem_give+0x118>
 800c33e: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c340: f3ef 8311    	mrs	r3, basepri
 800c344: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800c346: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 800c348: 63bb         	str	r3, [r7, #0x38]
 800c34a: 2310         	movs	r3, #0x10
 800c34c: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c34e: 6b7b         	ldr	r3, [r7, #0x34]
 800c350: f383 8812    	msr	basepri_max, r3
; }
 800c354: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c356: f3bf 8f6f    	isb	sy
; }
 800c35a: bf00         	nop
; 	return key;
 800c35c: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 800c35e: 60fb         	str	r3, [r7, #0xc]
 800c360: 6c3b         	ldr	r3, [r7, #0x40]
 800c362: 633b         	str	r3, [r7, #0x30]
; }
 800c364: bf00         	nop
 800c366: 6c3b         	ldr	r3, [r7, #0x40]
 800c368: 62fb         	str	r3, [r7, #0x2c]
; }
 800c36a: bf00         	nop
; 	return k;
 800c36c: 68fb         	ldr	r3, [r7, #0xc]
 800c36e: 617b         	str	r3, [r7, #0x14]
; 	bool resched = true;
 800c370: 2301         	movs	r3, #0x1
 800c372: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 800c376: 687b         	ldr	r3, [r7, #0x4]
 800c378: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 800c37a: 2300         	movs	r3, #0x0
 800c37c: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800c37e: 6d7b         	ldr	r3, [r7, #0x54]
 800c380: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800c382: 2300         	movs	r3, #0x0
 800c384: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800c386: 6cf8         	ldr	r0, [r7, #0x4c]
 800c388: f00b f9aa    	bl	0x80176e0 <sys_dlist_peek_head> @ imm = #0xb354
 800c38c: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800c38e: 6c7b         	ldr	r3, [r7, #0x44]
 800c390: 2b00         	cmp	r3, #0x0
 800c392: d001         	beq	0x800c398 <z_impl_k_sem_give+0x64> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800c394: 6c7b         	ldr	r3, [r7, #0x44]
 800c396: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800c398: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800c39a: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 800c39c: 6d3b         	ldr	r3, [r7, #0x50]
 800c39e: 2b00         	cmp	r3, #0x0
 800c3a0: bf14         	ite	ne
 800c3a2: 2301         	movne	r3, #0x1
 800c3a4: 2300         	moveq	r3, #0x0
 800c3a6: b2db         	uxtb	r3, r3
 800c3a8: 2b00         	cmp	r3, #0x0
 800c3aa: d005         	beq	0x800c3b8 <z_impl_k_sem_give+0x84> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 800c3ac: 6d38         	ldr	r0, [r7, #0x50]
 800c3ae: f00b f9f3    	bl	0x8017798 <unpend_thread_no_timeout> @ imm = #0xb3e6
; 			(void)z_abort_thread_timeout(thread);
 800c3b2: 6d38         	ldr	r0, [r7, #0x50]
 800c3b4: f00b f9c6    	bl	0x8017744 <z_abort_thread_timeout> @ imm = #0xb38c
; 	return thread;
 800c3b8: 6d3b         	ldr	r3, [r7, #0x50]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 800c3ba: 65bb         	str	r3, [r7, #0x58]
; 	if (unlikely(thread != NULL)) {
 800c3bc: 6dbb         	ldr	r3, [r7, #0x58]
 800c3be: 2b00         	cmp	r3, #0x0
 800c3c0: bf14         	ite	ne
 800c3c2: 2301         	movne	r3, #0x1
 800c3c4: 2300         	moveq	r3, #0x0
 800c3c6: b2db         	uxtb	r3, r3
 800c3c8: 2b00         	cmp	r3, #0x0
 800c3ca: d00c         	beq	0x800c3e6 <z_impl_k_sem_give+0xb2> @ imm = #0x18
 800c3cc: 6dbb         	ldr	r3, [r7, #0x58]
 800c3ce: 62bb         	str	r3, [r7, #0x28]
 800c3d0: 2300         	movs	r3, #0x0
 800c3d2: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 800c3d4: 6abb         	ldr	r3, [r7, #0x28]
 800c3d6: 6a7a         	ldr	r2, [r7, #0x24]
 800c3d8: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800c3dc: bf00         	nop
; 		z_ready_thread(thread);
 800c3de: 6db8         	ldr	r0, [r7, #0x58]
 800c3e0: f000 ff2c    	bl	0x800d23c <z_ready_thread> @ imm = #0xe58
 800c3e4: e013         	b	0x800c40e <z_impl_k_sem_give+0xda> @ imm = #0x26
; 		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 800c3e6: 687b         	ldr	r3, [r7, #0x4]
 800c3e8: 689b         	ldr	r3, [r3, #0x8]
 800c3ea: 687a         	ldr	r2, [r7, #0x4]
 800c3ec: 6891         	ldr	r1, [r2, #0x8]
 800c3ee: 687a         	ldr	r2, [r7, #0x4]
 800c3f0: 68d2         	ldr	r2, [r2, #0xc]
 800c3f2: 4291         	cmp	r1, r2
 800c3f4: d001         	beq	0x800c3fa <z_impl_k_sem_give+0xc6> @ imm = #0x2
 800c3f6: 2201         	movs	r2, #0x1
 800c3f8: e000         	b	0x800c3fc <z_impl_k_sem_give+0xc8> @ imm = #0x0
 800c3fa: 2200         	movs	r2, #0x0
 800c3fc: 441a         	add	r2, r3
 800c3fe: 687b         	ldr	r3, [r7, #0x4]
 800c400: 609a         	str	r2, [r3, #0x8]
; 		resched = handle_poll_events(sem);
 800c402: 6878         	ldr	r0, [r7, #0x4]
 800c404: f00b fa04    	bl	0x8017810 <handle_poll_events> @ imm = #0xb408
 800c408: 4603         	mov	r3, r0
 800c40a: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	if (unlikely(resched)) {
 800c40e: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 800c412: 2b00         	cmp	r3, #0x0
 800c414: d004         	beq	0x800c420 <z_impl_k_sem_give+0xec> @ imm = #0x8
; 		z_reschedule(&lock, key);
 800c416: 6979         	ldr	r1, [r7, #0x14]
 800c418: 480c         	ldr	r0, [pc, #0x30]         @ 0x800c44c <z_impl_k_sem_give+0x118>
 800c41a: f00c fa06    	bl	0x801882a <z_reschedule> @ imm = #0xc40c
; }
 800c41e: e010         	b	0x800c442 <z_impl_k_sem_give+0x10e> @ imm = #0x20
 800c420: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800c44c <z_impl_k_sem_give+0x118>
 800c422: 623b         	str	r3, [r7, #0x20]
 800c424: 697b         	ldr	r3, [r7, #0x14]
 800c426: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800c428: 693b         	ldr	r3, [r7, #0x10]
 800c42a: 61fb         	str	r3, [r7, #0x1c]
 800c42c: 69fb         	ldr	r3, [r7, #0x1c]
 800c42e: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c430: 69bb         	ldr	r3, [r7, #0x18]
 800c432: f383 8811    	msr	basepri, r3
; }
 800c436: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c438: f3bf 8f6f    	isb	sy
; }
 800c43c: bf00         	nop
; }
 800c43e: bf00         	nop
; }
 800c440: bf00         	nop
; }
 800c442: bf00         	nop
 800c444: 3760         	adds	r7, #0x60
 800c446: 46bd         	mov	sp, r7
 800c448: bd80         	pop	{r7, pc}
 800c44a: bf00         	nop

0800c44c <$d>:
 800c44c: e0 10 00 20  	.word	0x200010e0

0800c450 <z_impl_k_sem_take>:
; {
 800c450: b580         	push	{r7, lr}
 800c452: b098         	sub	sp, #0x60
 800c454: af02         	add	r7, sp, #0x8
 800c456: 60f8         	str	r0, [r7, #0xc]
 800c458: e9c7 2300    	strd	r2, r3, [r7]
 800c45c: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800c534 <z_impl_k_sem_take+0xe4>
 800c45e: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c460: f3ef 8311    	mrs	r3, basepri
 800c464: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 800c466: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 800c468: 64bb         	str	r3, [r7, #0x48]
 800c46a: 2310         	movs	r3, #0x10
 800c46c: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c46e: 6c7b         	ldr	r3, [r7, #0x44]
 800c470: f383 8812    	msr	basepri_max, r3
; }
 800c474: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c476: f3bf 8f6f    	isb	sy
; }
 800c47a: bf00         	nop
; 	return key;
 800c47c: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 800c47e: 61bb         	str	r3, [r7, #0x18]
 800c480: 6d3b         	ldr	r3, [r7, #0x50]
 800c482: 643b         	str	r3, [r7, #0x40]
; }
 800c484: bf00         	nop
 800c486: 6d3b         	ldr	r3, [r7, #0x50]
 800c488: 63fb         	str	r3, [r7, #0x3c]
; }
 800c48a: bf00         	nop
; 	return k;
 800c48c: 69bb         	ldr	r3, [r7, #0x18]
 800c48e: 623b         	str	r3, [r7, #0x20]
; 	if (likely(sem->count > 0U)) {
 800c490: 68fb         	ldr	r3, [r7, #0xc]
 800c492: 689b         	ldr	r3, [r3, #0x8]
 800c494: 2b00         	cmp	r3, #0x0
 800c496: bf14         	ite	ne
 800c498: 2301         	movne	r3, #0x1
 800c49a: 2300         	moveq	r3, #0x0
 800c49c: b2db         	uxtb	r3, r3
 800c49e: 2b00         	cmp	r3, #0x0
 800c4a0: d018         	beq	0x800c4d4 <z_impl_k_sem_take+0x84> @ imm = #0x30
; 		sem->count--;
 800c4a2: 68fb         	ldr	r3, [r7, #0xc]
 800c4a4: 689b         	ldr	r3, [r3, #0x8]
 800c4a6: 1e5a         	subs	r2, r3, #0x1
 800c4a8: 68fb         	ldr	r3, [r7, #0xc]
 800c4aa: 609a         	str	r2, [r3, #0x8]
 800c4ac: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800c534 <z_impl_k_sem_take+0xe4>
 800c4ae: 63bb         	str	r3, [r7, #0x38]
 800c4b0: 6a3b         	ldr	r3, [r7, #0x20]
 800c4b2: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 800c4b4: 69fb         	ldr	r3, [r7, #0x1c]
 800c4b6: 637b         	str	r3, [r7, #0x34]
 800c4b8: 6b7b         	ldr	r3, [r7, #0x34]
 800c4ba: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c4bc: 6b3b         	ldr	r3, [r7, #0x30]
 800c4be: f383 8811    	msr	basepri, r3
; }
 800c4c2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c4c4: f3bf 8f6f    	isb	sy
; }
 800c4c8: bf00         	nop
; }
 800c4ca: bf00         	nop
; }
 800c4cc: bf00         	nop
; 		ret = 0;
 800c4ce: 2300         	movs	r3, #0x0
 800c4d0: 657b         	str	r3, [r7, #0x54]
; 		goto out;
 800c4d2: e029         	b	0x800c528 <z_impl_k_sem_take+0xd8> @ imm = #0x52
; 	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 800c4d4: e9d7 2300    	ldrd	r2, r3, [r7]
 800c4d8: f04f 0000    	mov.w	r0, #0x0
 800c4dc: f04f 0100    	mov.w	r1, #0x0
 800c4e0: 428b         	cmp	r3, r1
 800c4e2: bf08         	it	eq
 800c4e4: 4282         	cmpeq	r2, r0
 800c4e6: d114         	bne	0x800c512 <z_impl_k_sem_take+0xc2> @ imm = #0x28
 800c4e8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800c534 <z_impl_k_sem_take+0xe4>
 800c4ea: 62fb         	str	r3, [r7, #0x2c]
 800c4ec: 6a3b         	ldr	r3, [r7, #0x20]
 800c4ee: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 800c4f0: 697b         	ldr	r3, [r7, #0x14]
 800c4f2: 62bb         	str	r3, [r7, #0x28]
 800c4f4: 6abb         	ldr	r3, [r7, #0x28]
 800c4f6: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c4f8: 6a7b         	ldr	r3, [r7, #0x24]
 800c4fa: f383 8811    	msr	basepri, r3
; }
 800c4fe: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c500: f3bf 8f6f    	isb	sy
; }
 800c504: bf00         	nop
; }
 800c506: bf00         	nop
; }
 800c508: bf00         	nop
; 		ret = -EBUSY;
 800c50a: f06f 030f    	mvn	r3, #0xf
 800c50e: 657b         	str	r3, [r7, #0x54]
 800c510: e00a         	b	0x800c528 <z_impl_k_sem_take+0xd8> @ imm = #0x14
; 	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 800c512: 68f9         	ldr	r1, [r7, #0xc]
 800c514: e9d7 2300    	ldrd	r2, r3, [r7]
 800c518: e9cd 2300    	strd	r2, r3, [sp]
 800c51c: 460a         	mov	r2, r1
 800c51e: 6a39         	ldr	r1, [r7, #0x20]
 800c520: 4804         	ldr	r0, [pc, #0x10]         @ 0x800c534 <z_impl_k_sem_take+0xe4>
 800c522: f001 f94f    	bl	0x800d7c4 <z_pend_curr> @ imm = #0x129e
 800c526: 6578         	str	r0, [r7, #0x54]
; 	return ret;
 800c528: 6d7b         	ldr	r3, [r7, #0x54]
; }
 800c52a: 4618         	mov	r0, r3
 800c52c: 3758         	adds	r7, #0x58
 800c52e: 46bd         	mov	sp, r7
 800c530: bd80         	pop	{r7, pc}
 800c532: bf00         	nop

0800c534 <$d>:
 800c534: e0 10 00 20  	.word	0x200010e0

0800c538 <finalize_cancel_locked>:
; {
 800c538: b580         	push	{r7, lr}
 800c53a: b086         	sub	sp, #0x18
 800c53c: af00         	add	r7, sp, #0x0
 800c53e: 6078         	str	r0, [r7, #0x4]
; 	sys_snode_t *prev = NULL;
 800c540: 2300         	movs	r3, #0x0
 800c542: 60fb         	str	r3, [r7, #0xc]
; 	flag_clear(&work->flags, K_WORK_CANCELING_BIT);
 800c544: 687b         	ldr	r3, [r7, #0x4]
 800c546: 330c         	adds	r3, #0xc
 800c548: 2101         	movs	r1, #0x1
 800c54a: 4618         	mov	r0, r3
 800c54c: f00b fb46    	bl	0x8017bdc <flag_clear>  @ imm = #0xb68c
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 800c550: 4829         	ldr	r0, [pc, #0xa4]         @ 0x800c5f8 <finalize_cancel_locked+0xc0>
 800c552: f00b f9c6    	bl	0x80178e2 <sys_slist_peek_head> @ imm = #0xb38c
 800c556: 4603         	mov	r3, r0
 800c558: 2b00         	cmp	r3, #0x0
 800c55a: d004         	beq	0x800c566 <finalize_cancel_locked+0x2e> @ imm = #0x8
 800c55c: 4826         	ldr	r0, [pc, #0x98]         @ 0x800c5f8 <finalize_cancel_locked+0xc0>
 800c55e: f00b f9c0    	bl	0x80178e2 <sys_slist_peek_head> @ imm = #0xb380
 800c562: 4603         	mov	r3, r0
 800c564: e000         	b	0x800c568 <finalize_cancel_locked+0x30> @ imm = #0x0
 800c566: 2300         	movs	r3, #0x0
 800c568: 617b         	str	r3, [r7, #0x14]
 800c56a: 697b         	ldr	r3, [r7, #0x14]
 800c56c: 2b00         	cmp	r3, #0x0
 800c56e: d00e         	beq	0x800c58e <finalize_cancel_locked+0x56> @ imm = #0x1c
 800c570: 697b         	ldr	r3, [r7, #0x14]
 800c572: 4618         	mov	r0, r3
 800c574: f00b f9e8    	bl	0x8017948 <sys_slist_peek_next> @ imm = #0xb3d0
 800c578: 4603         	mov	r3, r0
 800c57a: 2b00         	cmp	r3, #0x0
 800c57c: d005         	beq	0x800c58a <finalize_cancel_locked+0x52> @ imm = #0xa
 800c57e: 697b         	ldr	r3, [r7, #0x14]
 800c580: 4618         	mov	r0, r3
 800c582: f00b f9e1    	bl	0x8017948 <sys_slist_peek_next> @ imm = #0xb3c2
 800c586: 4603         	mov	r3, r0
 800c588: e002         	b	0x800c590 <finalize_cancel_locked+0x58> @ imm = #0x4
 800c58a: 2300         	movs	r3, #0x0
 800c58c: e000         	b	0x800c590 <finalize_cancel_locked+0x58> @ imm = #0x0
 800c58e: 2300         	movs	r3, #0x0
 800c590: 613b         	str	r3, [r7, #0x10]
 800c592: e028         	b	0x800c5e6 <finalize_cancel_locked+0xae> @ imm = #0x50
; 		if (wc->work == work) {
 800c594: 697b         	ldr	r3, [r7, #0x14]
 800c596: 685b         	ldr	r3, [r3, #0x4]
 800c598: 687a         	ldr	r2, [r7, #0x4]
 800c59a: 429a         	cmp	r2, r3
 800c59c: d10b         	bne	0x800c5b6 <finalize_cancel_locked+0x7e> @ imm = #0x16
; 			sys_slist_remove(&pending_cancels, prev, &wc->node);
 800c59e: 697b         	ldr	r3, [r7, #0x14]
 800c5a0: 461a         	mov	r2, r3
 800c5a2: 68f9         	ldr	r1, [r7, #0xc]
 800c5a4: 4814         	ldr	r0, [pc, #0x50]         @ 0x800c5f8 <finalize_cancel_locked+0xc0>
 800c5a6: f00b fa3f    	bl	0x8017a28 <sys_slist_remove> @ imm = #0xb47e
; 			k_sem_give(&wc->sem);
 800c5aa: 697b         	ldr	r3, [r7, #0x14]
 800c5ac: 3308         	adds	r3, #0x8
 800c5ae: 4618         	mov	r0, r3
 800c5b0: f00b fad9    	bl	0x8017b66 <k_sem_give>  @ imm = #0xb5b2
; 			break;
 800c5b4: e01b         	b	0x800c5ee <finalize_cancel_locked+0xb6> @ imm = #0x36
; 		prev = &wc->node;
 800c5b6: 697b         	ldr	r3, [r7, #0x14]
 800c5b8: 60fb         	str	r3, [r7, #0xc]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 800c5ba: 693b         	ldr	r3, [r7, #0x10]
 800c5bc: 617b         	str	r3, [r7, #0x14]
 800c5be: 697b         	ldr	r3, [r7, #0x14]
 800c5c0: 2b00         	cmp	r3, #0x0
 800c5c2: d00e         	beq	0x800c5e2 <finalize_cancel_locked+0xaa> @ imm = #0x1c
 800c5c4: 697b         	ldr	r3, [r7, #0x14]
 800c5c6: 4618         	mov	r0, r3
 800c5c8: f00b f9be    	bl	0x8017948 <sys_slist_peek_next> @ imm = #0xb37c
 800c5cc: 4603         	mov	r3, r0
 800c5ce: 2b00         	cmp	r3, #0x0
 800c5d0: d005         	beq	0x800c5de <finalize_cancel_locked+0xa6> @ imm = #0xa
 800c5d2: 697b         	ldr	r3, [r7, #0x14]
 800c5d4: 4618         	mov	r0, r3
 800c5d6: f00b f9b7    	bl	0x8017948 <sys_slist_peek_next> @ imm = #0xb36e
 800c5da: 4603         	mov	r3, r0
 800c5dc: e002         	b	0x800c5e4 <finalize_cancel_locked+0xac> @ imm = #0x4
 800c5de: 2300         	movs	r3, #0x0
 800c5e0: e000         	b	0x800c5e4 <finalize_cancel_locked+0xac> @ imm = #0x0
 800c5e2: 2300         	movs	r3, #0x0
 800c5e4: 613b         	str	r3, [r7, #0x10]
 800c5e6: 697b         	ldr	r3, [r7, #0x14]
 800c5e8: 2b00         	cmp	r3, #0x0
 800c5ea: d1d3         	bne	0x800c594 <finalize_cancel_locked+0x5c> @ imm = #-0x5a
; }
 800c5ec: bf00         	nop
 800c5ee: bf00         	nop
 800c5f0: 3718         	adds	r7, #0x18
 800c5f2: 46bd         	mov	sp, r7
 800c5f4: bd80         	pop	{r7, pc}
 800c5f6: bf00         	nop

0800c5f8 <$d>:
 800c5f8: e0 10 00 20  	.word	0x200010e0

0800c5fc <queue_submit_locked>:
; {
 800c5fc: b580         	push	{r7, lr}
 800c5fe: b084         	sub	sp, #0x10
 800c600: af00         	add	r7, sp, #0x0
 800c602: 6078         	str	r0, [r7, #0x4]
 800c604: 6039         	str	r1, [r7]
; 	if (queue == NULL) {
 800c606: 687b         	ldr	r3, [r7, #0x4]
 800c608: 2b00         	cmp	r3, #0x0
 800c60a: d102         	bne	0x800c612 <queue_submit_locked+0x16> @ imm = #0x4
; 		return -EINVAL;
 800c60c: f06f 0315    	mvn	r3, #0x15
 800c610: e05b         	b	0x800c6ca <queue_submit_locked+0xce> @ imm = #0xb6
; 	bool chained = (_current == &queue->thread) && !k_is_in_isr();
 800c612: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x800c6d4 <queue_submit_locked+0xd8>
 800c614: 689a         	ldr	r2, [r3, #0x8]
 800c616: 687b         	ldr	r3, [r7, #0x4]
 800c618: 429a         	cmp	r2, r3
 800c61a: d109         	bne	0x800c630 <queue_submit_locked+0x34> @ imm = #0x12
 800c61c: f00b fd05    	bl	0x801802a <k_is_in_isr> @ imm = #0xba0a
 800c620: 4603         	mov	r3, r0
 800c622: f083 0301    	eor	r3, r3, #0x1
 800c626: b2db         	uxtb	r3, r3
 800c628: 2b00         	cmp	r3, #0x0
 800c62a: d001         	beq	0x800c630 <queue_submit_locked+0x34> @ imm = #0x2
 800c62c: 2301         	movs	r3, #0x1
 800c62e: e000         	b	0x800c632 <queue_submit_locked+0x36> @ imm = #0x0
 800c630: 2300         	movs	r3, #0x0
 800c632: 72fb         	strb	r3, [r7, #0xb]
 800c634: 7afb         	ldrb	r3, [r7, #0xb]
 800c636: f003 0301    	and	r3, r3, #0x1
 800c63a: 72fb         	strb	r3, [r7, #0xb]
; 	bool draining = flag_test(&queue->flags, K_WORK_QUEUE_DRAIN_BIT);
 800c63c: 687b         	ldr	r3, [r7, #0x4]
 800c63e: 33e8         	adds	r3, #0xe8
 800c640: 2102         	movs	r1, #0x2
 800c642: 4618         	mov	r0, r3
 800c644: f00b faf1    	bl	0x8017c2a <flag_test>   @ imm = #0xb5e2
 800c648: 4603         	mov	r3, r0
 800c64a: 72bb         	strb	r3, [r7, #0xa]
; 	bool plugged = flag_test(&queue->flags, K_WORK_QUEUE_PLUGGED_BIT);
 800c64c: 687b         	ldr	r3, [r7, #0x4]
 800c64e: 33e8         	adds	r3, #0xe8
 800c650: 2103         	movs	r1, #0x3
 800c652: 4618         	mov	r0, r3
 800c654: f00b fae9    	bl	0x8017c2a <flag_test>   @ imm = #0xb5d2
 800c658: 4603         	mov	r3, r0
 800c65a: 727b         	strb	r3, [r7, #0x9]
; 	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
 800c65c: 687b         	ldr	r3, [r7, #0x4]
 800c65e: 33e8         	adds	r3, #0xe8
 800c660: 2100         	movs	r1, #0x0
 800c662: 4618         	mov	r0, r3
 800c664: f00b fae1    	bl	0x8017c2a <flag_test>   @ imm = #0xb5c2
 800c668: 4603         	mov	r3, r0
 800c66a: f083 0301    	eor	r3, r3, #0x1
 800c66e: b2db         	uxtb	r3, r3
 800c670: 2b00         	cmp	r3, #0x0
 800c672: d003         	beq	0x800c67c <queue_submit_locked+0x80> @ imm = #0x6
; 		ret = -ENODEV;
 800c674: f06f 0312    	mvn	r3, #0x12
 800c678: 60fb         	str	r3, [r7, #0xc]
 800c67a: e025         	b	0x800c6c8 <queue_submit_locked+0xcc> @ imm = #0x4a
; 	} else if (draining && !chained) {
 800c67c: 7abb         	ldrb	r3, [r7, #0xa]
 800c67e: 2b00         	cmp	r3, #0x0
 800c680: d009         	beq	0x800c696 <queue_submit_locked+0x9a> @ imm = #0x12
 800c682: 7afb         	ldrb	r3, [r7, #0xb]
 800c684: f083 0301    	eor	r3, r3, #0x1
 800c688: b2db         	uxtb	r3, r3
 800c68a: 2b00         	cmp	r3, #0x0
 800c68c: d003         	beq	0x800c696 <queue_submit_locked+0x9a> @ imm = #0x6
; 		ret = -EBUSY;
 800c68e: f06f 030f    	mvn	r3, #0xf
 800c692: 60fb         	str	r3, [r7, #0xc]
 800c694: e018         	b	0x800c6c8 <queue_submit_locked+0xcc> @ imm = #0x30
; 	} else if (plugged && !draining) {
 800c696: 7a7b         	ldrb	r3, [r7, #0x9]
 800c698: 2b00         	cmp	r3, #0x0
 800c69a: d009         	beq	0x800c6b0 <queue_submit_locked+0xb4> @ imm = #0x12
 800c69c: 7abb         	ldrb	r3, [r7, #0xa]
 800c69e: f083 0301    	eor	r3, r3, #0x1
 800c6a2: b2db         	uxtb	r3, r3
 800c6a4: 2b00         	cmp	r3, #0x0
 800c6a6: d003         	beq	0x800c6b0 <queue_submit_locked+0xb4> @ imm = #0x6
; 		ret = -EBUSY;
 800c6a8: f06f 030f    	mvn	r3, #0xf
 800c6ac: 60fb         	str	r3, [r7, #0xc]
 800c6ae: e00b         	b	0x800c6c8 <queue_submit_locked+0xcc> @ imm = #0x16
; 		sys_slist_append(&queue->pending, &work->node);
 800c6b0: 687b         	ldr	r3, [r7, #0x4]
 800c6b2: 33d0         	adds	r3, #0xd0
 800c6b4: 683a         	ldr	r2, [r7]
 800c6b6: 4611         	mov	r1, r2
 800c6b8: 4618         	mov	r0, r3
 800c6ba: f00b f956    	bl	0x801796a <sys_slist_append> @ imm = #0xb2ac
; 		ret = 1;
 800c6be: 2301         	movs	r3, #0x1
 800c6c0: 60fb         	str	r3, [r7, #0xc]
; 		(void)notify_queue_locked(queue);
 800c6c2: 6878         	ldr	r0, [r7, #0x4]
 800c6c4: f00b fb33    	bl	0x8017d2e <notify_queue_locked> @ imm = #0xb666
; 	return ret;
 800c6c8: 68fb         	ldr	r3, [r7, #0xc]
; }
 800c6ca: 4618         	mov	r0, r3
 800c6cc: 3710         	adds	r7, #0x10
 800c6ce: 46bd         	mov	sp, r7
 800c6d0: bd80         	pop	{r7, pc}
 800c6d2: bf00         	nop

0800c6d4 <$d>:
 800c6d4: c8 06 00 20  	.word	0x200006c8

0800c6d8 <work_queue_main>:
; {
 800c6d8: b580         	push	{r7, lr}
 800c6da: b0a4         	sub	sp, #0x90
 800c6dc: af04         	add	r7, sp, #0x10
 800c6de: 60f8         	str	r0, [r7, #0xc]
 800c6e0: 60b9         	str	r1, [r7, #0x8]
 800c6e2: 607a         	str	r2, [r7, #0x4]
; 	struct k_work_q *queue = (struct k_work_q *)workq_ptr;
 800c6e4: 68fb         	ldr	r3, [r7, #0xc]
 800c6e6: 677b         	str	r3, [r7, #0x74]
; 		struct k_work *work = NULL;
 800c6e8: 2300         	movs	r3, #0x0
 800c6ea: 67fb         	str	r3, [r7, #0x7c]
; 		k_work_handler_t handler = NULL;
 800c6ec: 2300         	movs	r3, #0x0
 800c6ee: 67bb         	str	r3, [r7, #0x78]
 800c6f0: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x800c8b4 <work_queue_main+0x1dc>
 800c6f2: 66bb         	str	r3, [r7, #0x68]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c6f4: f3ef 8311    	mrs	r3, basepri
 800c6f8: 667b         	str	r3, [r7, #0x64]
;   return(result);
 800c6fa: 6e7b         	ldr	r3, [r7, #0x64]
; 	key = __get_BASEPRI();
 800c6fc: 663b         	str	r3, [r7, #0x60]
 800c6fe: 2310         	movs	r3, #0x10
 800c700: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c702: 6dfb         	ldr	r3, [r7, #0x5c]
 800c704: f383 8812    	msr	basepri_max, r3
; }
 800c708: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c70a: f3bf 8f6f    	isb	sy
; }
 800c70e: bf00         	nop
; 	return key;
 800c710: 6e3b         	ldr	r3, [r7, #0x60]
; 	k.key = arch_irq_lock();
 800c712: 613b         	str	r3, [r7, #0x10]
 800c714: 6ebb         	ldr	r3, [r7, #0x68]
 800c716: 65bb         	str	r3, [r7, #0x58]
; }
 800c718: bf00         	nop
 800c71a: 6ebb         	ldr	r3, [r7, #0x68]
 800c71c: 657b         	str	r3, [r7, #0x54]
; }
 800c71e: bf00         	nop
; 	return k;
 800c720: 693b         	ldr	r3, [r7, #0x10]
 800c722: 623b         	str	r3, [r7, #0x20]
; 		node = sys_slist_get(&queue->pending);
 800c724: 6f7b         	ldr	r3, [r7, #0x74]
 800c726: 33d0         	adds	r3, #0xd0
 800c728: 4618         	mov	r0, r3
 800c72a: f00b f969    	bl	0x8017a00 <sys_slist_get> @ imm = #0xb2d2
 800c72e: 6738         	str	r0, [r7, #0x70]
; 		if (node != NULL) {
 800c730: 6f3b         	ldr	r3, [r7, #0x70]
 800c732: 2b00         	cmp	r3, #0x0
 800c734: d017         	beq	0x800c766 <work_queue_main+0x8e> @ imm = #0x2e
; 			flag_set(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
 800c736: 6f7b         	ldr	r3, [r7, #0x74]
 800c738: 33e8         	adds	r3, #0xe8
 800c73a: 2101         	movs	r1, #0x1
 800c73c: 4618         	mov	r0, r3
 800c73e: f00b fa61    	bl	0x8017c04 <flag_set>    @ imm = #0xb4c2
; 			work = CONTAINER_OF(node, struct k_work, node);
 800c742: 6f3b         	ldr	r3, [r7, #0x70]
 800c744: 67fb         	str	r3, [r7, #0x7c]
; 			flag_set(&work->flags, K_WORK_RUNNING_BIT);
 800c746: 6ffb         	ldr	r3, [r7, #0x7c]
 800c748: 330c         	adds	r3, #0xc
 800c74a: 2100         	movs	r1, #0x0
 800c74c: 4618         	mov	r0, r3
 800c74e: f00b fa59    	bl	0x8017c04 <flag_set>    @ imm = #0xb4b2
; 			flag_clear(&work->flags, K_WORK_QUEUED_BIT);
 800c752: 6ffb         	ldr	r3, [r7, #0x7c]
 800c754: 330c         	adds	r3, #0xc
 800c756: 2102         	movs	r1, #0x2
 800c758: 4618         	mov	r0, r3
 800c75a: f00b fa3f    	bl	0x8017bdc <flag_clear>  @ imm = #0xb47e
; 			handler = work->handler;
 800c75e: 6ffb         	ldr	r3, [r7, #0x7c]
 800c760: 685b         	ldr	r3, [r3, #0x4]
 800c762: 67bb         	str	r3, [r7, #0x78]
 800c764: e00f         	b	0x800c786 <work_queue_main+0xae> @ imm = #0x1e
; 		} else if (flag_test_and_clear(&queue->flags,
 800c766: 6f7b         	ldr	r3, [r7, #0x74]
 800c768: 33e8         	adds	r3, #0xe8
 800c76a: 2102         	movs	r1, #0x2
 800c76c: 4618         	mov	r0, r3
 800c76e: f00b fa72    	bl	0x8017c56 <flag_test_and_clear> @ imm = #0xb4e4
 800c772: 4603         	mov	r3, r0
 800c774: 2b00         	cmp	r3, #0x0
 800c776: d006         	beq	0x800c786 <work_queue_main+0xae> @ imm = #0xc
; 			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
 800c778: 6f7b         	ldr	r3, [r7, #0x74]
 800c77a: 33e0         	adds	r3, #0xe0
 800c77c: 2200         	movs	r2, #0x0
 800c77e: 2101         	movs	r1, #0x1
 800c780: 4618         	mov	r0, r3
 800c782: f00b fa13    	bl	0x8017bac <z_sched_wake_all> @ imm = #0xb426
; 		if (work == NULL) {
 800c786: 6ffb         	ldr	r3, [r7, #0x7c]
 800c788: 2b00         	cmp	r3, #0x0
 800c78a: d111         	bne	0x800c7b0 <work_queue_main+0xd8> @ imm = #0x22
; 			(void)z_sched_wait(&lock, key, &queue->notifyq,
 800c78c: 6f7b         	ldr	r3, [r7, #0x74]
 800c78e: f103 01d8    	add.w	r1, r3, #0xd8
; 					   K_FOREVER, NULL);
 800c792: f04f 32ff    	mov.w	r2, #0xffffffff
 800c796: f04f 33ff    	mov.w	r3, #0xffffffff
; 			(void)z_sched_wait(&lock, key, &queue->notifyq,
 800c79a: 2000         	movs	r0, #0x0
 800c79c: 9002         	str	r0, [sp, #0x8]
 800c79e: e9cd 2300    	strd	r2, r3, [sp]
 800c7a2: 460a         	mov	r2, r1
 800c7a4: 6a39         	ldr	r1, [r7, #0x20]
 800c7a6: 4843         	ldr	r0, [pc, #0x10c]        @ 0x800c8b4 <work_queue_main+0x1dc>
 800c7a8: f001 fe6e    	bl	0x800e488 <z_sched_wait> @ imm = #0x1cdc
; 			continue;
 800c7ac: bf00         	nop
 800c7ae: e79b         	b	0x800c6e8 <work_queue_main+0x10> @ imm = #-0xca
 800c7b0: 4b40         	ldr	r3, [pc, #0x100]        @ 0x800c8b4 <work_queue_main+0x1dc>
 800c7b2: 63bb         	str	r3, [r7, #0x38]
 800c7b4: 6a3b         	ldr	r3, [r7, #0x20]
 800c7b6: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800c7b8: 69bb         	ldr	r3, [r7, #0x18]
 800c7ba: 637b         	str	r3, [r7, #0x34]
 800c7bc: 6b7b         	ldr	r3, [r7, #0x34]
 800c7be: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c7c0: 6b3b         	ldr	r3, [r7, #0x30]
 800c7c2: f383 8811    	msr	basepri, r3
; }
 800c7c6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c7c8: f3bf 8f6f    	isb	sy
; }
 800c7cc: bf00         	nop
; }
 800c7ce: bf00         	nop
; }
 800c7d0: bf00         	nop
; 		handler(work);
 800c7d2: 6fbb         	ldr	r3, [r7, #0x78]
 800c7d4: 6ff8         	ldr	r0, [r7, #0x7c]
 800c7d6: 4798         	blx	r3
 800c7d8: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800c8b4 <work_queue_main+0x1dc>
 800c7da: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c7dc: f3ef 8311    	mrs	r3, basepri
 800c7e0: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 800c7e2: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 800c7e4: 64bb         	str	r3, [r7, #0x48]
 800c7e6: 2310         	movs	r3, #0x10
 800c7e8: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c7ea: 6c7b         	ldr	r3, [r7, #0x44]
 800c7ec: f383 8812    	msr	basepri_max, r3
; }
 800c7f0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c7f2: f3bf 8f6f    	isb	sy
; }
 800c7f6: bf00         	nop
; 	return key;
 800c7f8: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 800c7fa: 617b         	str	r3, [r7, #0x14]
 800c7fc: 6d3b         	ldr	r3, [r7, #0x50]
 800c7fe: 643b         	str	r3, [r7, #0x40]
; }
 800c800: bf00         	nop
 800c802: 6d3b         	ldr	r3, [r7, #0x50]
 800c804: 63fb         	str	r3, [r7, #0x3c]
; }
 800c806: bf00         	nop
; 	return k;
 800c808: 697b         	ldr	r3, [r7, #0x14]
 800c80a: 623b         	str	r3, [r7, #0x20]
; 		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
 800c80c: 6ffb         	ldr	r3, [r7, #0x7c]
 800c80e: 330c         	adds	r3, #0xc
 800c810: 2100         	movs	r1, #0x0
 800c812: 4618         	mov	r0, r3
 800c814: f00b f9e2    	bl	0x8017bdc <flag_clear>  @ imm = #0xb3c4
; 		if (flag_test(&work->flags, K_WORK_FLUSHING_BIT)) {
 800c818: 6ffb         	ldr	r3, [r7, #0x7c]
 800c81a: 330c         	adds	r3, #0xc
 800c81c: 2104         	movs	r1, #0x4
 800c81e: 4618         	mov	r0, r3
 800c820: f00b fa03    	bl	0x8017c2a <flag_test>   @ imm = #0xb406
 800c824: 4603         	mov	r3, r0
 800c826: 2b00         	cmp	r3, #0x0
 800c828: d002         	beq	0x800c830 <work_queue_main+0x158> @ imm = #0x4
; 			finalize_flush_locked(work);
 800c82a: 6ff8         	ldr	r0, [r7, #0x7c]
 800c82c: f00b fa41    	bl	0x8017cb2 <finalize_flush_locked> @ imm = #0xb482
; 		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 800c830: 6ffb         	ldr	r3, [r7, #0x7c]
 800c832: 330c         	adds	r3, #0xc
 800c834: 2101         	movs	r1, #0x1
 800c836: 4618         	mov	r0, r3
 800c838: f00b f9f7    	bl	0x8017c2a <flag_test>   @ imm = #0xb3ee
 800c83c: 4603         	mov	r3, r0
 800c83e: 2b00         	cmp	r3, #0x0
 800c840: d002         	beq	0x800c848 <work_queue_main+0x170> @ imm = #0x4
; 			finalize_cancel_locked(work);
 800c842: 6ff8         	ldr	r0, [r7, #0x7c]
 800c844: f7ff fe78    	bl	0x800c538 <finalize_cancel_locked> @ imm = #-0x310
; 		flag_clear(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
 800c848: 6f7b         	ldr	r3, [r7, #0x74]
 800c84a: 33e8         	adds	r3, #0xe8
 800c84c: 2101         	movs	r1, #0x1
 800c84e: 4618         	mov	r0, r3
 800c850: f00b f9c4    	bl	0x8017bdc <flag_clear>  @ imm = #0xb388
; 		yield = !flag_test(&queue->flags, K_WORK_QUEUE_NO_YIELD_BIT);
 800c854: 6f7b         	ldr	r3, [r7, #0x74]
 800c856: 33e8         	adds	r3, #0xe8
 800c858: 2108         	movs	r1, #0x8
 800c85a: 4618         	mov	r0, r3
 800c85c: f00b f9e5    	bl	0x8017c2a <flag_test>   @ imm = #0xb3ca
 800c860: 4603         	mov	r3, r0
 800c862: 2b00         	cmp	r3, #0x0
 800c864: bf14         	ite	ne
 800c866: 2301         	movne	r3, #0x1
 800c868: 2300         	moveq	r3, #0x0
 800c86a: b2db         	uxtb	r3, r3
 800c86c: f083 0301    	eor	r3, r3, #0x1
 800c870: b2db         	uxtb	r3, r3
 800c872: f887 306f    	strb.w	r3, [r7, #0x6f]
 800c876: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800c87a: f003 0301    	and	r3, r3, #0x1
 800c87e: f887 306f    	strb.w	r3, [r7, #0x6f]
 800c882: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800c8b4 <work_queue_main+0x1dc>
 800c884: 62fb         	str	r3, [r7, #0x2c]
 800c886: 6a3b         	ldr	r3, [r7, #0x20]
 800c888: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 800c88a: 69fb         	ldr	r3, [r7, #0x1c]
 800c88c: 62bb         	str	r3, [r7, #0x28]
 800c88e: 6abb         	ldr	r3, [r7, #0x28]
 800c890: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c892: 6a7b         	ldr	r3, [r7, #0x24]
 800c894: f383 8811    	msr	basepri, r3
; }
 800c898: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c89a: f3bf 8f6f    	isb	sy
; }
 800c89e: bf00         	nop
; }
 800c8a0: bf00         	nop
; }
 800c8a2: bf00         	nop
; 		if (yield) {
 800c8a4: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800c8a8: 2b00         	cmp	r3, #0x0
 800c8aa: f43f af1d    	beq.w	0x800c6e8 <work_queue_main+0x10> @ imm = #-0x1c6
; 			k_yield();
 800c8ae: f00b f93b    	bl	0x8017b28 <k_yield>     @ imm = #0xb276
; 	while (true) {
 800c8b2: e719         	b	0x800c6e8 <work_queue_main+0x10> @ imm = #-0x1ce

0800c8b4 <$d>:
 800c8b4: e0 10 00 20  	.word	0x200010e0

0800c8b8 <k_work_queue_start>:
; {
 800c8b8: b580         	push	{r7, lr}
 800c8ba: b08e         	sub	sp, #0x38
 800c8bc: af08         	add	r7, sp, #0x20
 800c8be: 60f8         	str	r0, [r7, #0xc]
 800c8c0: 60b9         	str	r1, [r7, #0x8]
 800c8c2: 607a         	str	r2, [r7, #0x4]
 800c8c4: 603b         	str	r3, [r7]
; 	uint32_t flags = K_WORK_QUEUE_STARTED;
 800c8c6: 2301         	movs	r3, #0x1
 800c8c8: 617b         	str	r3, [r7, #0x14]
; 	sys_slist_init(&queue->pending);
 800c8ca: 68fb         	ldr	r3, [r7, #0xc]
 800c8cc: 33d0         	adds	r3, #0xd0
 800c8ce: 4618         	mov	r0, r3
 800c8d0: f00a ffc6    	bl	0x8017860 <sys_slist_init> @ imm = #0xaf8c
; 	z_waitq_init(&queue->notifyq);
 800c8d4: 68fb         	ldr	r3, [r7, #0xc]
 800c8d6: 33d8         	adds	r3, #0xd8
 800c8d8: 4618         	mov	r0, r3
 800c8da: f00b f95b    	bl	0x8017b94 <z_waitq_init> @ imm = #0xb2b6
; 	z_waitq_init(&queue->drainq);
 800c8de: 68fb         	ldr	r3, [r7, #0xc]
 800c8e0: 33e0         	adds	r3, #0xe0
 800c8e2: 4618         	mov	r0, r3
 800c8e4: f00b f956    	bl	0x8017b94 <z_waitq_init> @ imm = #0xb2ac
; 	if ((cfg != NULL) && cfg->no_yield) {
 800c8e8: 6a3b         	ldr	r3, [r7, #0x20]
 800c8ea: 2b00         	cmp	r3, #0x0
 800c8ec: d007         	beq	0x800c8fe <k_work_queue_start+0x46> @ imm = #0xe
 800c8ee: 6a3b         	ldr	r3, [r7, #0x20]
 800c8f0: 791b         	ldrb	r3, [r3, #0x4]
 800c8f2: 2b00         	cmp	r3, #0x0
 800c8f4: d003         	beq	0x800c8fe <k_work_queue_start+0x46> @ imm = #0x6
; 		flags |= K_WORK_QUEUE_NO_YIELD;
 800c8f6: 697b         	ldr	r3, [r7, #0x14]
 800c8f8: f443 7380    	orr	r3, r3, #0x100
 800c8fc: 617b         	str	r3, [r7, #0x14]
; 	flags_set(&queue->flags, flags);
 800c8fe: 68fb         	ldr	r3, [r7, #0xc]
 800c900: 33e8         	adds	r3, #0xe8
 800c902: 6979         	ldr	r1, [r7, #0x14]
 800c904: 4618         	mov	r0, r3
 800c906: f00b f9bc    	bl	0x8017c82 <flags_set>   @ imm = #0xb378
; 	(void)k_thread_create(&queue->thread, stack, stack_size,
 800c90a: 68f8         	ldr	r0, [r7, #0xc]
; 			      prio, 0, K_FOREVER);
 800c90c: f04f 32ff    	mov.w	r2, #0xffffffff
 800c910: f04f 33ff    	mov.w	r3, #0xffffffff
; 	(void)k_thread_create(&queue->thread, stack, stack_size,
 800c914: e9cd 2306    	strd	r2, r3, [sp, #24]
 800c918: 2300         	movs	r3, #0x0
 800c91a: 9304         	str	r3, [sp, #0x10]
 800c91c: 683b         	ldr	r3, [r7]
 800c91e: 9303         	str	r3, [sp, #0xc]
 800c920: 2300         	movs	r3, #0x0
 800c922: 9302         	str	r3, [sp, #0x8]
 800c924: 2300         	movs	r3, #0x0
 800c926: 9301         	str	r3, [sp, #0x4]
 800c928: 68fb         	ldr	r3, [r7, #0xc]
 800c92a: 9300         	str	r3, [sp]
 800c92c: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800c980 <k_work_queue_start+0xc8>
 800c92e: 687a         	ldr	r2, [r7, #0x4]
 800c930: 68b9         	ldr	r1, [r7, #0x8]
 800c932: f00b f8d9    	bl	0x8017ae8 <k_thread_create> @ imm = #0xb1b2
; 	if ((cfg != NULL) && (cfg->name != NULL)) {
 800c936: 6a3b         	ldr	r3, [r7, #0x20]
 800c938: 2b00         	cmp	r3, #0x0
 800c93a: d00a         	beq	0x800c952 <k_work_queue_start+0x9a> @ imm = #0x14
 800c93c: 6a3b         	ldr	r3, [r7, #0x20]
 800c93e: 681b         	ldr	r3, [r3]
 800c940: 2b00         	cmp	r3, #0x0
 800c942: d006         	beq	0x800c952 <k_work_queue_start+0x9a> @ imm = #0xc
; 		k_thread_name_set(&queue->thread, cfg->name);
 800c944: 68fa         	ldr	r2, [r7, #0xc]
 800c946: 6a3b         	ldr	r3, [r7, #0x20]
 800c948: 681b         	ldr	r3, [r3]
 800c94a: 4619         	mov	r1, r3
 800c94c: 4610         	mov	r0, r2
 800c94e: f00b f8fc    	bl	0x8017b4a <k_thread_name_set> @ imm = #0xb1f8
; 	if ((cfg != NULL) && (cfg->essential)) {
 800c952: 6a3b         	ldr	r3, [r7, #0x20]
 800c954: 2b00         	cmp	r3, #0x0
 800c956: d00a         	beq	0x800c96e <k_work_queue_start+0xb6> @ imm = #0x14
 800c958: 6a3b         	ldr	r3, [r7, #0x20]
 800c95a: 795b         	ldrb	r3, [r3, #0x5]
 800c95c: 2b00         	cmp	r3, #0x0
 800c95e: d006         	beq	0x800c96e <k_work_queue_start+0xb6> @ imm = #0xc
; 		queue->thread.base.user_options |= K_ESSENTIAL;
 800c960: 68fb         	ldr	r3, [r7, #0xc]
 800c962: 7b1b         	ldrb	r3, [r3, #0xc]
 800c964: f043 0301    	orr	r3, r3, #0x1
 800c968: b2da         	uxtb	r2, r3
 800c96a: 68fb         	ldr	r3, [r7, #0xc]
 800c96c: 731a         	strb	r2, [r3, #0xc]
; 	k_thread_start(&queue->thread);
 800c96e: 68fb         	ldr	r3, [r7, #0xc]
 800c970: 4618         	mov	r0, r3
 800c972: f00b f8df    	bl	0x8017b34 <k_thread_start> @ imm = #0xb1be
; }
 800c976: bf00         	nop
 800c978: 3718         	adds	r7, #0x18
 800c97a: 46bd         	mov	sp, r7
 800c97c: bd80         	pop	{r7, pc}
 800c97e: bf00         	nop

0800c980 <$d>:
 800c980: d9 c6 00 08  	.word	0x0800c6d9

0800c984 <work_timeout>:
; {
 800c984: b580         	push	{r7, lr}
 800c986: b092         	sub	sp, #0x48
 800c988: af00         	add	r7, sp, #0x0
 800c98a: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dw
 800c98c: 687b         	ldr	r3, [r7, #0x4]
 800c98e: 3b10         	subs	r3, #0x10
 800c990: 647b         	str	r3, [r7, #0x44]
; 	struct k_work *wp = &dw->work;
 800c992: 6c7b         	ldr	r3, [r7, #0x44]
 800c994: 643b         	str	r3, [r7, #0x40]
 800c996: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800ca1c <work_timeout+0x98>
 800c998: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c99a: f3ef 8311    	mrs	r3, basepri
 800c99e: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800c9a0: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 800c9a2: 637b         	str	r3, [r7, #0x34]
 800c9a4: 2310         	movs	r3, #0x10
 800c9a6: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c9a8: 6b3b         	ldr	r3, [r7, #0x30]
 800c9aa: f383 8812    	msr	basepri_max, r3
; }
 800c9ae: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c9b0: f3bf 8f6f    	isb	sy
; }
 800c9b4: bf00         	nop
; 	return key;
 800c9b6: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 800c9b8: 60fb         	str	r3, [r7, #0xc]
 800c9ba: 6bfb         	ldr	r3, [r7, #0x3c]
 800c9bc: 62fb         	str	r3, [r7, #0x2c]
; }
 800c9be: bf00         	nop
 800c9c0: 6bfb         	ldr	r3, [r7, #0x3c]
 800c9c2: 62bb         	str	r3, [r7, #0x28]
; }
 800c9c4: bf00         	nop
; 	return k;
 800c9c6: 68fb         	ldr	r3, [r7, #0xc]
 800c9c8: 61bb         	str	r3, [r7, #0x18]
; 	struct k_work_q *queue = NULL;
 800c9ca: 2300         	movs	r3, #0x0
 800c9cc: 617b         	str	r3, [r7, #0x14]
; 	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
 800c9ce: 6c3b         	ldr	r3, [r7, #0x40]
 800c9d0: 330c         	adds	r3, #0xc
 800c9d2: 2103         	movs	r1, #0x3
 800c9d4: 4618         	mov	r0, r3
 800c9d6: f00b f93e    	bl	0x8017c56 <flag_test_and_clear> @ imm = #0xb27c
 800c9da: 4603         	mov	r3, r0
 800c9dc: 2b00         	cmp	r3, #0x0
 800c9de: d008         	beq	0x800c9f2 <work_timeout+0x6e> @ imm = #0x10
; 		queue = dw->queue;
 800c9e0: 6c7b         	ldr	r3, [r7, #0x44]
 800c9e2: 6a9b         	ldr	r3, [r3, #0x28]
 800c9e4: 617b         	str	r3, [r7, #0x14]
; 		(void)submit_to_queue_locked(wp, &queue);
 800c9e6: f107 0314    	add.w	r3, r7, #0x14
 800c9ea: 4619         	mov	r1, r3
 800c9ec: 6c38         	ldr	r0, [r7, #0x40]
 800c9ee: f00b f9b5    	bl	0x8017d5c <submit_to_queue_locked> @ imm = #0xb36a
 800c9f2: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800ca1c <work_timeout+0x98>
 800c9f4: 627b         	str	r3, [r7, #0x24]
 800c9f6: 69bb         	ldr	r3, [r7, #0x18]
 800c9f8: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800c9fa: 693b         	ldr	r3, [r7, #0x10]
 800c9fc: 623b         	str	r3, [r7, #0x20]
 800c9fe: 6a3b         	ldr	r3, [r7, #0x20]
 800ca00: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ca02: 69fb         	ldr	r3, [r7, #0x1c]
 800ca04: f383 8811    	msr	basepri, r3
; }
 800ca08: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ca0a: f3bf 8f6f    	isb	sy
; }
 800ca0e: bf00         	nop
; }
 800ca10: bf00         	nop
; }
 800ca12: bf00         	nop
; }
 800ca14: bf00         	nop
 800ca16: 3748         	adds	r7, #0x48
 800ca18: 46bd         	mov	sp, r7
 800ca1a: bd80         	pop	{r7, pc}

0800ca1c <$d>:
 800ca1c: e0 10 00 20  	.word	0x200010e0

0800ca20 <schedule_for_queue_locked>:
; {
 800ca20: b580         	push	{r7, lr}
 800ca22: b086         	sub	sp, #0x18
 800ca24: af00         	add	r7, sp, #0x0
 800ca26: 60f8         	str	r0, [r7, #0xc]
 800ca28: 60b9         	str	r1, [r7, #0x8]
 800ca2a: e9c7 2300    	strd	r2, r3, [r7]
; 	int ret = 1;
 800ca2e: 2301         	movs	r3, #0x1
 800ca30: 617b         	str	r3, [r7, #0x14]
; 	struct k_work *work = &dwork->work;
 800ca32: 68bb         	ldr	r3, [r7, #0x8]
 800ca34: 613b         	str	r3, [r7, #0x10]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 800ca36: e9d7 2300    	ldrd	r2, r3, [r7]
 800ca3a: f04f 0000    	mov.w	r0, #0x0
 800ca3e: f04f 0100    	mov.w	r1, #0x0
 800ca42: 428b         	cmp	r3, r1
 800ca44: bf08         	it	eq
 800ca46: 4282         	cmpeq	r2, r0
 800ca48: d105         	bne	0x800ca56 <schedule_for_queue_locked+0x36> @ imm = #0xa
; 		return submit_to_queue_locked(work, queuep);
 800ca4a: 68f9         	ldr	r1, [r7, #0xc]
 800ca4c: 6938         	ldr	r0, [r7, #0x10]
 800ca4e: f00b f985    	bl	0x8017d5c <submit_to_queue_locked> @ imm = #0xb30a
 800ca52: 4603         	mov	r3, r0
 800ca54: e012         	b	0x800ca7c <schedule_for_queue_locked+0x5c> @ imm = #0x24
; 	flag_set(&work->flags, K_WORK_DELAYED_BIT);
 800ca56: 693b         	ldr	r3, [r7, #0x10]
 800ca58: 330c         	adds	r3, #0xc
 800ca5a: 2103         	movs	r1, #0x3
 800ca5c: 4618         	mov	r0, r3
 800ca5e: f00b f8d1    	bl	0x8017c04 <flag_set>    @ imm = #0xb1a2
; 	dwork->queue = *queuep;
 800ca62: 68fb         	ldr	r3, [r7, #0xc]
 800ca64: 681a         	ldr	r2, [r3]
 800ca66: 68bb         	ldr	r3, [r7, #0x8]
 800ca68: 629a         	str	r2, [r3, #0x28]
; 	z_add_timeout(&dwork->timeout, work_timeout, delay);
 800ca6a: 68bb         	ldr	r3, [r7, #0x8]
 800ca6c: f103 0010    	add.w	r0, r3, #0x10
 800ca70: e9d7 2300    	ldrd	r2, r3, [r7]
 800ca74: 4903         	ldr	r1, [pc, #0xc]          @ 0x800ca84 <schedule_for_queue_locked+0x64>
 800ca76: f001 ff09    	bl	0x800e88c <z_add_timeout> @ imm = #0x1e12
; 	return ret;
 800ca7a: 697b         	ldr	r3, [r7, #0x14]
; }
 800ca7c: 4618         	mov	r0, r3
 800ca7e: 3718         	adds	r7, #0x18
 800ca80: 46bd         	mov	sp, r7
 800ca82: bd80         	pop	{r7, pc}

0800ca84 <$d>:
 800ca84: 85 c9 00 08  	.word	0x0800c985

0800ca88 <k_work_reschedule_for_queue>:
; {
 800ca88: b580         	push	{r7, lr}
 800ca8a: b092         	sub	sp, #0x48
 800ca8c: af00         	add	r7, sp, #0x0
 800ca8e: 60f8         	str	r0, [r7, #0xc]
 800ca90: 60b9         	str	r1, [r7, #0x8]
 800ca92: e9c7 2300    	strd	r2, r3, [r7]
 800ca96: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800cb0c <k_work_reschedule_for_queue+0x84>
 800ca98: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ca9a: f3ef 8311    	mrs	r3, basepri
 800ca9e: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800caa0: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800caa2: 62fb         	str	r3, [r7, #0x2c]
 800caa4: 2310         	movs	r3, #0x10
 800caa6: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800caa8: 6abb         	ldr	r3, [r7, #0x28]
 800caaa: f383 8812    	msr	basepri_max, r3
; }
 800caae: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cab0: f3bf 8f6f    	isb	sy
; }
 800cab4: bf00         	nop
; 	return key;
 800cab6: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800cab8: 61bb         	str	r3, [r7, #0x18]
 800caba: 6b7b         	ldr	r3, [r7, #0x34]
 800cabc: 627b         	str	r3, [r7, #0x24]
; }
 800cabe: bf00         	nop
 800cac0: 6b7b         	ldr	r3, [r7, #0x34]
 800cac2: 623b         	str	r3, [r7, #0x20]
; }
 800cac4: bf00         	nop
; 	return k;
 800cac6: 69bb         	ldr	r3, [r7, #0x18]
 800cac8: 61fb         	str	r3, [r7, #0x1c]
; 	(void)unschedule_locked(dwork);
 800caca: 68b8         	ldr	r0, [r7, #0x8]
 800cacc: f00b f9e9    	bl	0x8017ea2 <unschedule_locked> @ imm = #0xb3d2
; 	ret = schedule_for_queue_locked(&queue, dwork, delay);
 800cad0: f107 000c    	add.w	r0, r7, #0xc
 800cad4: e9d7 2300    	ldrd	r2, r3, [r7]
 800cad8: 68b9         	ldr	r1, [r7, #0x8]
 800cada: f7ff ffa1    	bl	0x800ca20 <schedule_for_queue_locked> @ imm = #-0xbe
 800cade: 6478         	str	r0, [r7, #0x44]
 800cae0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800cb0c <k_work_reschedule_for_queue+0x84>
 800cae2: 643b         	str	r3, [r7, #0x40]
 800cae4: 69fb         	ldr	r3, [r7, #0x1c]
 800cae6: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 800cae8: 697b         	ldr	r3, [r7, #0x14]
 800caea: 63fb         	str	r3, [r7, #0x3c]
 800caec: 6bfb         	ldr	r3, [r7, #0x3c]
 800caee: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800caf0: 6bbb         	ldr	r3, [r7, #0x38]
 800caf2: f383 8811    	msr	basepri, r3
; }
 800caf6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800caf8: f3bf 8f6f    	isb	sy
; }
 800cafc: bf00         	nop
; }
 800cafe: bf00         	nop
; }
 800cb00: bf00         	nop
; 	return ret;
 800cb02: 6c7b         	ldr	r3, [r7, #0x44]
; }
 800cb04: 4618         	mov	r0, r3
 800cb06: 3748         	adds	r7, #0x48
 800cb08: 46bd         	mov	sp, r7
 800cb0a: bd80         	pop	{r7, pc}

0800cb0c <$d>:
 800cb0c: e0 10 00 20  	.word	0x200010e0

0800cb10 <k_work_reschedule>:
; {
 800cb10: b580         	push	{r7, lr}
 800cb12: b086         	sub	sp, #0x18
 800cb14: af00         	add	r7, sp, #0x0
 800cb16: 60f8         	str	r0, [r7, #0xc]
 800cb18: e9c7 2300    	strd	r2, r3, [r7]
; 	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
 800cb1c: e9d7 2300    	ldrd	r2, r3, [r7]
 800cb20: 68f9         	ldr	r1, [r7, #0xc]
 800cb22: 4804         	ldr	r0, [pc, #0x10]         @ 0x800cb34 <k_work_reschedule+0x24>
 800cb24: f7ff ffb0    	bl	0x800ca88 <k_work_reschedule_for_queue> @ imm = #-0xa0
 800cb28: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 800cb2a: 697b         	ldr	r3, [r7, #0x14]
; }
 800cb2c: 4618         	mov	r0, r3
 800cb2e: 3718         	adds	r7, #0x18
 800cb30: 46bd         	mov	sp, r7
 800cb32: bd80         	pop	{r7, pc}

0800cb34 <$d>:
 800cb34: 98 09 00 20  	.word	0x20000998

0800cb38 <k_work_cancel_delayable>:
; {
 800cb38: b580         	push	{r7, lr}
 800cb3a: b090         	sub	sp, #0x40
 800cb3c: af00         	add	r7, sp, #0x0
 800cb3e: 6078         	str	r0, [r7, #0x4]
 800cb40: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800cba8 <k_work_cancel_delayable+0x70>
 800cb42: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800cb44: f3ef 8311    	mrs	r3, basepri
 800cb48: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 800cb4a: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 800cb4c: 627b         	str	r3, [r7, #0x24]
 800cb4e: 2310         	movs	r3, #0x10
 800cb50: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800cb52: 6a3b         	ldr	r3, [r7, #0x20]
 800cb54: f383 8812    	msr	basepri_max, r3
; }
 800cb58: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cb5a: f3bf 8f6f    	isb	sy
; }
 800cb5e: bf00         	nop
; 	return key;
 800cb60: 6a7b         	ldr	r3, [r7, #0x24]
; 	k.key = arch_irq_lock();
 800cb62: 613b         	str	r3, [r7, #0x10]
 800cb64: 6afb         	ldr	r3, [r7, #0x2c]
 800cb66: 61fb         	str	r3, [r7, #0x1c]
; }
 800cb68: bf00         	nop
 800cb6a: 6afb         	ldr	r3, [r7, #0x2c]
 800cb6c: 61bb         	str	r3, [r7, #0x18]
; }
 800cb6e: bf00         	nop
; 	return k;
 800cb70: 693b         	ldr	r3, [r7, #0x10]
 800cb72: 617b         	str	r3, [r7, #0x14]
; 	int ret = cancel_delayable_async_locked(dwork);
 800cb74: 6878         	ldr	r0, [r7, #0x4]
 800cb76: f00b f9b5    	bl	0x8017ee4 <cancel_delayable_async_locked> @ imm = #0xb36a
 800cb7a: 63f8         	str	r0, [r7, #0x3c]
 800cb7c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800cba8 <k_work_cancel_delayable+0x70>
 800cb7e: 63bb         	str	r3, [r7, #0x38]
 800cb80: 697b         	ldr	r3, [r7, #0x14]
 800cb82: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800cb84: 68fb         	ldr	r3, [r7, #0xc]
 800cb86: 637b         	str	r3, [r7, #0x34]
 800cb88: 6b7b         	ldr	r3, [r7, #0x34]
 800cb8a: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800cb8c: 6b3b         	ldr	r3, [r7, #0x30]
 800cb8e: f383 8811    	msr	basepri, r3
; }
 800cb92: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cb94: f3bf 8f6f    	isb	sy
; }
 800cb98: bf00         	nop
; }
 800cb9a: bf00         	nop
; }
 800cb9c: bf00         	nop
; 	return ret;
 800cb9e: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 800cba0: 4618         	mov	r0, r3
 800cba2: 3740         	adds	r7, #0x40
 800cba4: 46bd         	mov	sp, r7
 800cba6: bd80         	pop	{r7, pc}

0800cba8 <$d>:
 800cba8: e0 10 00 20  	.word	0x200010e0

0800cbac <z_add_thread_timeout>:
; {
 800cbac: b580         	push	{r7, lr}
 800cbae: b084         	sub	sp, #0x10
 800cbb0: af00         	add	r7, sp, #0x0
 800cbb2: 60f8         	str	r0, [r7, #0xc]
 800cbb4: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 800cbb8: 68fb         	ldr	r3, [r7, #0xc]
 800cbba: f103 0018    	add.w	r0, r3, #0x18
 800cbbe: e9d7 2300    	ldrd	r2, r3, [r7]
 800cbc2: 4903         	ldr	r1, [pc, #0xc]          @ 0x800cbd0 <z_add_thread_timeout+0x24>
 800cbc4: f001 fe62    	bl	0x800e88c <z_add_timeout> @ imm = #0x1cc4
; }
 800cbc8: bf00         	nop
 800cbca: 3710         	adds	r7, #0x10
 800cbcc: 46bd         	mov	sp, r7
 800cbce: bd80         	pop	{r7, pc}

0800cbd0 <$d>:
 800cbd0: bf 87 01 08  	.word	0x080187bf

0800cbd4 <z_impl_k_thread_name_set>:
; {
 800cbd4: b580         	push	{r7, lr}
 800cbd6: b082         	sub	sp, #0x8
 800cbd8: af00         	add	r7, sp, #0x0
 800cbda: 6078         	str	r0, [r7, #0x4]
 800cbdc: 6039         	str	r1, [r7]
; 	if (thread == NULL) {
 800cbde: 687b         	ldr	r3, [r7, #0x4]
 800cbe0: 2b00         	cmp	r3, #0x0
 800cbe2: d102         	bne	0x800cbea <z_impl_k_thread_name_set+0x16> @ imm = #0x4
; 		thread = _current;
 800cbe4: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800cc0c <z_impl_k_thread_name_set+0x38>
 800cbe6: 689b         	ldr	r3, [r3, #0x8]
 800cbe8: 607b         	str	r3, [r7, #0x4]
; 	strncpy(thread->name, str, CONFIG_THREAD_MAX_NAME_LEN - 1);
 800cbea: 687b         	ldr	r3, [r7, #0x4]
 800cbec: 3394         	adds	r3, #0x94
 800cbee: 221f         	movs	r2, #0x1f
 800cbf0: 6839         	ldr	r1, [r7]
 800cbf2: 4618         	mov	r0, r3
 800cbf4: f00c f8af    	bl	0x8018d56 <strncpy>     @ imm = #0xc15e
; 	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 800cbf8: 687b         	ldr	r3, [r7, #0x4]
 800cbfa: 2200         	movs	r2, #0x0
 800cbfc: f883 20b3    	strb.w	r2, [r3, #0xb3]
; 	return 0;
 800cc00: 2300         	movs	r3, #0x0
; }
 800cc02: 4618         	mov	r0, r3
 800cc04: 3708         	adds	r7, #0x8
 800cc06: 46bd         	mov	sp, r7
 800cc08: bd80         	pop	{r7, pc}
 800cc0a: bf00         	nop

0800cc0c <$d>:
 800cc0c: c8 06 00 20  	.word	0x200006c8

0800cc10 <setup_thread_stack>:
; {
 800cc10: b580         	push	{r7, lr}
 800cc12: b096         	sub	sp, #0x58
 800cc14: af0a         	add	r7, sp, #0x28
 800cc16: 60f8         	str	r0, [r7, #0xc]
 800cc18: 60b9         	str	r1, [r7, #0x8]
 800cc1a: 607a         	str	r2, [r7, #0x4]
; 	size_t delta = 0;
 800cc1c: 2300         	movs	r3, #0x0
 800cc1e: 62fb         	str	r3, [r7, #0x2c]
; 		stack_obj_size = K_KERNEL_STACK_LEN(stack_size);
 800cc20: 687b         	ldr	r3, [r7, #0x4]
 800cc22: 3307         	adds	r3, #0x7
 800cc24: f023 0307    	bic	r3, r3, #0x7
 800cc28: 3307         	adds	r3, #0x7
 800cc2a: f023 0307    	bic	r3, r3, #0x7
 800cc2e: 62bb         	str	r3, [r7, #0x28]
; 		stack_buf_start = K_KERNEL_STACK_BUFFER(stack);
 800cc30: 68b8         	ldr	r0, [r7, #0x8]
 800cc32: f00b f985    	bl	0x8017f40 <K_KERNEL_STACK_BUFFER> @ imm = #0xb30a
 800cc36: 6278         	str	r0, [r7, #0x24]
; 		stack_buf_size = stack_obj_size - K_KERNEL_STACK_RESERVED;
 800cc38: 6abb         	ldr	r3, [r7, #0x28]
 800cc3a: 623b         	str	r3, [r7, #0x20]
; 	stack_ptr = (char *)stack + stack_obj_size;
 800cc3c: 68ba         	ldr	r2, [r7, #0x8]
 800cc3e: 6abb         	ldr	r3, [r7, #0x28]
 800cc40: 4413         	add	r3, r2
 800cc42: 61fb         	str	r3, [r7, #0x1c]
; 	LOG_DBG("stack %p for thread %p: obj_size=%zu buf_start=%p "
 800cc44: 2303         	movs	r3, #0x3
 800cc46: 2b03         	cmp	r3, #0x3
 800cc48: d924         	bls	0x800cc94 <setup_thread_stack+0x84> @ imm = #0x48
 800cc4a: 2301         	movs	r3, #0x1
 800cc4c: 76fb         	strb	r3, [r7, #0x1b]
 800cc4e: 7efb         	ldrb	r3, [r7, #0x1b]
 800cc50: f083 0301    	eor	r3, r3, #0x1
 800cc54: b2db         	uxtb	r3, r3
 800cc56: 2b00         	cmp	r3, #0x0
 800cc58: d11c         	bne	0x800cc94 <setup_thread_stack+0x84> @ imm = #0x38
 800cc5a: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800cce4 <setup_thread_stack+0xd4>
 800cc5c: 6819         	ldr	r1, [r3]
 800cc5e: 69fb         	ldr	r3, [r7, #0x1c]
 800cc60: 9309         	str	r3, [sp, #0x24]
 800cc62: 6a3b         	ldr	r3, [r7, #0x20]
 800cc64: 9308         	str	r3, [sp, #0x20]
 800cc66: 6a7b         	ldr	r3, [r7, #0x24]
 800cc68: 9307         	str	r3, [sp, #0x1c]
 800cc6a: 6abb         	ldr	r3, [r7, #0x28]
 800cc6c: 9306         	str	r3, [sp, #0x18]
 800cc6e: 68fb         	ldr	r3, [r7, #0xc]
 800cc70: 9305         	str	r3, [sp, #0x14]
 800cc72: 68bb         	ldr	r3, [r7, #0x8]
 800cc74: 9304         	str	r3, [sp, #0x10]
 800cc76: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800cce8 <setup_thread_stack+0xd8>
 800cc78: 9303         	str	r3, [sp, #0xc]
 800cc7a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800ccec <setup_thread_stack+0xdc>
 800cc7c: 9302         	str	r3, [sp, #0x8]
 800cc7e: 2308         	movs	r3, #0x8
 800cc80: 9301         	str	r3, [sp, #0x4]
 800cc82: 2300         	movs	r3, #0x0
 800cc84: 9300         	str	r3, [sp]
 800cc86: 2300         	movs	r3, #0x0
 800cc88: 2204         	movs	r2, #0x4
 800cc8a: 2000         	movs	r0, #0x0
 800cc8c: f00b f9af    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xb35e
 800cc90: 2300         	movs	r3, #0x0
 800cc92: 617b         	str	r3, [r7, #0x14]
; 	memset(stack_buf_start, 0xaa, stack_buf_size);
 800cc94: 6a3a         	ldr	r2, [r7, #0x20]
 800cc96: 21aa         	movs	r1, #0xaa
 800cc98: 6a78         	ldr	r0, [r7, #0x24]
 800cc9a: f00c f854    	bl	0x8018d46 <memset>      @ imm = #0xc0a8
; 	delta += arch_tls_stack_setup(new_thread, stack_ptr);
 800cc9e: 69f9         	ldr	r1, [r7, #0x1c]
 800cca0: 68f8         	ldr	r0, [r7, #0xc]
 800cca2: f004 fea4    	bl	0x80119ee <arch_tls_stack_setup> @ imm = #0x4d48
 800cca6: 4602         	mov	r2, r0
 800cca8: 6afb         	ldr	r3, [r7, #0x2c]
 800ccaa: 4413         	add	r3, r2
 800ccac: 62fb         	str	r3, [r7, #0x2c]
; 	delta = ROUND_UP(delta, ARCH_STACK_PTR_ALIGN);
 800ccae: 6afb         	ldr	r3, [r7, #0x2c]
 800ccb0: 3307         	adds	r3, #0x7
 800ccb2: f023 0307    	bic	r3, r3, #0x7
 800ccb6: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
 800ccb8: 6a7a         	ldr	r2, [r7, #0x24]
 800ccba: 68fb         	ldr	r3, [r7, #0xc]
 800ccbc: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	new_thread->stack_info.size = stack_buf_size;
 800ccc0: 68fb         	ldr	r3, [r7, #0xc]
 800ccc2: 6a3a         	ldr	r2, [r7, #0x20]
 800ccc4: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	new_thread->stack_info.delta = delta;
 800ccc8: 68fb         	ldr	r3, [r7, #0xc]
 800ccca: 6afa         	ldr	r2, [r7, #0x2c]
 800cccc: f8c3 20bc    	str.w	r2, [r3, #0xbc]
; 	stack_ptr -= delta;
 800ccd0: 6afb         	ldr	r3, [r7, #0x2c]
 800ccd2: 425b         	rsbs	r3, r3, #0
 800ccd4: 69fa         	ldr	r2, [r7, #0x1c]
 800ccd6: 4413         	add	r3, r2
 800ccd8: 61fb         	str	r3, [r7, #0x1c]
; 	return stack_ptr;
 800ccda: 69fb         	ldr	r3, [r7, #0x1c]
; }
 800ccdc: 4618         	mov	r0, r3
 800ccde: 3730         	adds	r7, #0x30
 800cce0: 46bd         	mov	sp, r7
 800cce2: bd80         	pop	{r7, pc}

0800cce4 <$d>:
 800cce4: 48 05 00 20  	.word	0x20000548
 800cce8: a4 bd 01 08  	.word	0x0801bda4
 800ccec: 4c b0 01 08  	.word	0x0801b04c

0800ccf0 <z_setup_new_thread>:
; {
 800ccf0: b580         	push	{r7, lr}
 800ccf2: b09a         	sub	sp, #0x68
 800ccf4: af04         	add	r7, sp, #0x10
 800ccf6: 60f8         	str	r0, [r7, #0xc]
 800ccf8: 60b9         	str	r1, [r7, #0x8]
 800ccfa: 607a         	str	r2, [r7, #0x4]
 800ccfc: 603b         	str	r3, [r7]
; 	z_waitq_init(&new_thread->join_queue);
 800ccfe: 68fb         	ldr	r3, [r7, #0xc]
 800cd00: 3368         	adds	r3, #0x68
 800cd02: 4618         	mov	r0, r3
 800cd04: f00b f967    	bl	0x8017fd6 <z_waitq_init> @ imm = #0xb2ce
; 	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
 800cd08: 68f8         	ldr	r0, [r7, #0xc]
 800cd0a: 6f3b         	ldr	r3, [r7, #0x70]
 800cd0c: 2204         	movs	r2, #0x4
 800cd0e: 6ef9         	ldr	r1, [r7, #0x6c]
 800cd10: f00b f9df    	bl	0x80180d2 <z_init_thread_base> @ imm = #0xb3be
; 	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
 800cd14: 687a         	ldr	r2, [r7, #0x4]
 800cd16: 68b9         	ldr	r1, [r7, #0x8]
 800cd18: 68f8         	ldr	r0, [r7, #0xc]
 800cd1a: f7ff ff79    	bl	0x800cc10 <setup_thread_stack> @ imm = #-0x10e
 800cd1e: 6578         	str	r0, [r7, #0x54]
; 	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 800cd20: 6ebb         	ldr	r3, [r7, #0x68]
 800cd22: 9302         	str	r3, [sp, #0x8]
 800cd24: 6e7b         	ldr	r3, [r7, #0x64]
 800cd26: 9301         	str	r3, [sp, #0x4]
 800cd28: 6e3b         	ldr	r3, [r7, #0x60]
 800cd2a: 9300         	str	r3, [sp]
 800cd2c: 683b         	ldr	r3, [r7]
 800cd2e: 6d7a         	ldr	r2, [r7, #0x54]
 800cd30: 68b9         	ldr	r1, [r7, #0x8]
 800cd32: 68f8         	ldr	r0, [r7, #0xc]
 800cd34: f7f6 fecc    	bl	0x8003ad0 <arch_new_thread> @ imm = #-0x9268
; 	new_thread->init_data = NULL;
 800cd38: 68fb         	ldr	r3, [r7, #0xc]
 800cd3a: 2200         	movs	r2, #0x0
 800cd3c: 665a         	str	r2, [r3, #0x64]
; 	new_thread->no_wake_on_timeout = false;
 800cd3e: 68fb         	ldr	r3, [r7, #0xc]
 800cd40: 2200         	movs	r2, #0x0
 800cd42: f883 207c    	strb.w	r2, [r3, #0x7c]
; 	new_thread->entry.pEntry = entry;
 800cd46: 68fb         	ldr	r3, [r7, #0xc]
 800cd48: 683a         	ldr	r2, [r7]
 800cd4a: f8c3 2080    	str.w	r2, [r3, #0x80]
; 	new_thread->entry.parameter1 = p1;
 800cd4e: 68fb         	ldr	r3, [r7, #0xc]
 800cd50: 6e3a         	ldr	r2, [r7, #0x60]
 800cd52: f8c3 2084    	str.w	r2, [r3, #0x84]
; 	new_thread->entry.parameter2 = p2;
 800cd56: 68fb         	ldr	r3, [r7, #0xc]
 800cd58: 6e7a         	ldr	r2, [r7, #0x64]
 800cd5a: f8c3 2088    	str.w	r2, [r3, #0x88]
; 	new_thread->entry.parameter3 = p3;
 800cd5e: 68fb         	ldr	r3, [r7, #0xc]
 800cd60: 6eba         	ldr	r2, [r7, #0x68]
 800cd62: f8c3 208c    	str.w	r2, [r3, #0x8c]
 800cd66: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800ce34 <z_setup_new_thread+0x144>
 800cd68: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800cd6a: f3ef 8311    	mrs	r3, basepri
 800cd6e: 643b         	str	r3, [r7, #0x40]
;   return(result);
 800cd70: 6c3b         	ldr	r3, [r7, #0x40]
; 	key = __get_BASEPRI();
 800cd72: 63fb         	str	r3, [r7, #0x3c]
 800cd74: 2310         	movs	r3, #0x10
 800cd76: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800cd78: 6bbb         	ldr	r3, [r7, #0x38]
 800cd7a: f383 8812    	msr	basepri_max, r3
; }
 800cd7e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cd80: f3bf 8f6f    	isb	sy
; }
 800cd84: bf00         	nop
; 	return key;
 800cd86: 6bfb         	ldr	r3, [r7, #0x3c]
; 	k.key = arch_irq_lock();
 800cd88: 617b         	str	r3, [r7, #0x14]
 800cd8a: 6c7b         	ldr	r3, [r7, #0x44]
 800cd8c: 637b         	str	r3, [r7, #0x34]
; }
 800cd8e: bf00         	nop
 800cd90: 6c7b         	ldr	r3, [r7, #0x44]
 800cd92: 633b         	str	r3, [r7, #0x30]
; }
 800cd94: bf00         	nop
; 	return k;
 800cd96: 697b         	ldr	r3, [r7, #0x14]
 800cd98: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->next_thread = _kernel.threads;
 800cd9a: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800ce38 <z_setup_new_thread+0x148>
 800cd9c: 6a9a         	ldr	r2, [r3, #0x28]
 800cd9e: 68fb         	ldr	r3, [r7, #0xc]
 800cda0: f8c3 2090    	str.w	r2, [r3, #0x90]
; 	_kernel.threads = new_thread;
 800cda4: 4a24         	ldr	r2, [pc, #0x90]         @ 0x800ce38 <z_setup_new_thread+0x148>
 800cda6: 68fb         	ldr	r3, [r7, #0xc]
 800cda8: 6293         	str	r3, [r2, #0x28]
 800cdaa: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800ce34 <z_setup_new_thread+0x144>
 800cdac: 653b         	str	r3, [r7, #0x50]
 800cdae: 6afb         	ldr	r3, [r7, #0x2c]
 800cdb0: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800cdb2: 693b         	ldr	r3, [r7, #0x10]
 800cdb4: 64fb         	str	r3, [r7, #0x4c]
 800cdb6: 6cfb         	ldr	r3, [r7, #0x4c]
 800cdb8: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800cdba: 6cbb         	ldr	r3, [r7, #0x48]
 800cdbc: f383 8811    	msr	basepri, r3
; }
 800cdc0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800cdc2: f3bf 8f6f    	isb	sy
; }
 800cdc6: bf00         	nop
; }
 800cdc8: bf00         	nop
; }
 800cdca: bf00         	nop
; 	if (name != NULL) {
 800cdcc: 6f7b         	ldr	r3, [r7, #0x74]
 800cdce: 2b00         	cmp	r3, #0x0
 800cdd0: d00b         	beq	0x800cdea <z_setup_new_thread+0xfa> @ imm = #0x16
; 		strncpy(new_thread->name, name,
 800cdd2: 68fb         	ldr	r3, [r7, #0xc]
 800cdd4: 3394         	adds	r3, #0x94
 800cdd6: 221f         	movs	r2, #0x1f
 800cdd8: 6f79         	ldr	r1, [r7, #0x74]
 800cdda: 4618         	mov	r0, r3
 800cddc: f00b ffbb    	bl	0x8018d56 <strncpy>     @ imm = #0xbf76
; 		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 800cde0: 68fb         	ldr	r3, [r7, #0xc]
 800cde2: 2200         	movs	r2, #0x0
 800cde4: f883 20b3    	strb.w	r2, [r3, #0xb3]
 800cde8: e003         	b	0x800cdf2 <z_setup_new_thread+0x102> @ imm = #0x6
; 		new_thread->name[0] = '\0';
 800cdea: 68fb         	ldr	r3, [r7, #0xc]
 800cdec: 2200         	movs	r2, #0x0
 800cdee: f883 2094    	strb.w	r2, [r3, #0x94]
; 	if (!_current) {
 800cdf2: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800ce38 <z_setup_new_thread+0x148>
 800cdf4: 689b         	ldr	r3, [r3, #0x8]
 800cdf6: 2b00         	cmp	r3, #0x0
 800cdf8: d105         	bne	0x800ce06 <z_setup_new_thread+0x116> @ imm = #0xa
; 		new_thread->resource_pool = NULL;
 800cdfa: 68fb         	ldr	r3, [r7, #0xc]
 800cdfc: 2200         	movs	r2, #0x0
 800cdfe: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 		return stack_ptr;
 800ce02: 6d7b         	ldr	r3, [r7, #0x54]
 800ce04: e012         	b	0x800ce2c <z_setup_new_thread+0x13c> @ imm = #0x24
; 	new_thread->resource_pool = _current->resource_pool;
 800ce06: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800ce38 <z_setup_new_thread+0x148>
 800ce08: 689b         	ldr	r3, [r3, #0x8]
 800ce0a: f8d3 20c0    	ldr.w	r2, [r3, #0xc0]
 800ce0e: 68fb         	ldr	r3, [r7, #0xc]
 800ce10: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 	new_thread->base.usage = (struct k_cycle_stats) {};
 800ce14: 68fb         	ldr	r3, [r7, #0xc]
 800ce16: 3330         	adds	r3, #0x30
 800ce18: 2200         	movs	r2, #0x0
 800ce1a: 601a         	str	r2, [r3]
 800ce1c: 605a         	str	r2, [r3, #0x4]
 800ce1e: 609a         	str	r2, [r3, #0x8]
 800ce20: 60da         	str	r2, [r3, #0xc]
; 	new_thread->base.usage.track_usage =
 800ce22: 68fb         	ldr	r3, [r7, #0xc]
 800ce24: 2201         	movs	r2, #0x1
 800ce26: f883 2038    	strb.w	r2, [r3, #0x38]
; 	return stack_ptr;
 800ce2a: 6d7b         	ldr	r3, [r7, #0x54]
; }
 800ce2c: 4618         	mov	r0, r3
 800ce2e: 3758         	adds	r7, #0x58
 800ce30: 46bd         	mov	sp, r7
 800ce32: bd80         	pop	{r7, pc}

0800ce34 <$d>:
 800ce34: f8 10 00 20  	.word	0x200010f8
 800ce38: c8 06 00 20  	.word	0x200006c8

0800ce3c <z_thread_mark_switched_in>:
; {
 800ce3c: b580         	push	{r7, lr}
 800ce3e: af00         	add	r7, sp, #0x0
; 	z_sched_usage_start(_current);
 800ce40: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800ce50 <z_thread_mark_switched_in+0x14>
 800ce42: 689b         	ldr	r3, [r3, #0x8]
 800ce44: 4618         	mov	r0, r3
 800ce46: f001 ffb3    	bl	0x800edb0 <z_sched_usage_start> @ imm = #0x1f66
; }
 800ce4a: bf00         	nop
 800ce4c: bd80         	pop	{r7, pc}
 800ce4e: bf00         	nop

0800ce50 <$d>:
 800ce50: c8 06 00 20  	.word	0x200006c8

0800ce54 <z_add_thread_timeout>:
; {
 800ce54: b580         	push	{r7, lr}
 800ce56: b084         	sub	sp, #0x10
 800ce58: af00         	add	r7, sp, #0x0
 800ce5a: 60f8         	str	r0, [r7, #0xc]
 800ce5c: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 800ce60: 68fb         	ldr	r3, [r7, #0xc]
 800ce62: f103 0018    	add.w	r0, r3, #0x18
 800ce66: e9d7 2300    	ldrd	r2, r3, [r7]
 800ce6a: 4903         	ldr	r1, [pc, #0xc]          @ 0x800ce78 <z_add_thread_timeout+0x24>
 800ce6c: f001 fd0e    	bl	0x800e88c <z_add_timeout> @ imm = #0x1a1c
; }
 800ce70: bf00         	nop
 800ce72: 3710         	adds	r7, #0x10
 800ce74: 46bd         	mov	sp, r7
 800ce76: bd80         	pop	{r7, pc}

0800ce78 <$d>:
 800ce78: bf 87 01 08  	.word	0x080187bf

0800ce7c <z_sched_lock>:
; {
 800ce7c: b480         	push	{r7}
 800ce7e: af00         	add	r7, sp, #0x0
; 	--_current->base.sched_locked;
 800ce80: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800ce94 <z_sched_lock+0x18>
 800ce82: 689b         	ldr	r3, [r3, #0x8]
 800ce84: 7bda         	ldrb	r2, [r3, #0xf]
 800ce86: 3a01         	subs	r2, #0x1
 800ce88: b2d2         	uxtb	r2, r2
 800ce8a: 73da         	strb	r2, [r3, #0xf]
; }
 800ce8c: bf00         	nop
 800ce8e: 46bd         	mov	sp, r7
 800ce90: bc80         	pop	{r7}
 800ce92: 4770         	bx	lr

0800ce94 <$d>:
 800ce94: c8 06 00 20  	.word	0x200006c8

0800ce98 <z_dummy_thread_init>:
; {
 800ce98: b480         	push	{r7}
 800ce9a: b083         	sub	sp, #0xc
 800ce9c: af00         	add	r7, sp, #0x0
 800ce9e: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 800cea0: 687b         	ldr	r3, [r7, #0x4]
 800cea2: 2201         	movs	r2, #0x1
 800cea4: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 800cea6: 687b         	ldr	r3, [r7, #0x4]
 800cea8: 2201         	movs	r2, #0x1
 800ceaa: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 800ceac: 687b         	ldr	r3, [r7, #0x4]
 800ceae: 2200         	movs	r2, #0x0
 800ceb0: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 800ceb4: 687b         	ldr	r3, [r7, #0x4]
 800ceb6: 2200         	movs	r2, #0x0
 800ceb8: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	dummy_thread->resource_pool = NULL;
 800cebc: 687b         	ldr	r3, [r7, #0x4]
 800cebe: 2200         	movs	r2, #0x0
 800cec0: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 	_current_cpu->current = dummy_thread;
 800cec4: 4a03         	ldr	r2, [pc, #0xc]          @ 0x800ced4 <z_dummy_thread_init+0x3c>
 800cec6: 687b         	ldr	r3, [r7, #0x4]
 800cec8: 6093         	str	r3, [r2, #0x8]
; }
 800ceca: bf00         	nop
 800cecc: 370c         	adds	r7, #0xc
 800cece: 46bd         	mov	sp, r7
 800ced0: bc80         	pop	{r7}
 800ced2: 4770         	bx	lr

0800ced4 <$d>:
 800ced4: c8 06 00 20  	.word	0x200006c8

0800ced8 <move_thread_to_end_of_prio_q>:
; {
 800ced8: b580         	push	{r7, lr}
 800ceda: b096         	sub	sp, #0x58
 800cedc: af00         	add	r7, sp, #0x0
 800cede: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 800cee0: 6878         	ldr	r0, [r7, #0x4]
 800cee2: f00b faa0    	bl	0x8018426 <z_is_thread_queued> @ imm = #0xb540
 800cee6: 4603         	mov	r3, r0
 800cee8: 2b00         	cmp	r3, #0x0
 800ceea: d01d         	beq	0x800cf28 <move_thread_to_end_of_prio_q+0x50> @ imm = #0x3a
 800ceec: 687b         	ldr	r3, [r7, #0x4]
 800ceee: 657b         	str	r3, [r7, #0x54]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800cef0: 6d7b         	ldr	r3, [r7, #0x54]
 800cef2: 7b5b         	ldrb	r3, [r3, #0xd]
 800cef4: f003 037f    	and	r3, r3, #0x7f
 800cef8: b2da         	uxtb	r2, r3
 800cefa: 6d7b         	ldr	r3, [r7, #0x54]
 800cefc: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800cefe: 6d78         	ldr	r0, [r7, #0x54]
 800cf00: f00b fb86    	bl	0x8018610 <should_queue_thread> @ imm = #0xb70c
 800cf04: 4603         	mov	r3, r0
 800cf06: 2b00         	cmp	r3, #0x0
 800cf08: d00d         	beq	0x800cf26 <move_thread_to_end_of_prio_q+0x4e> @ imm = #0x1a
 800cf0a: 6d7b         	ldr	r3, [r7, #0x54]
 800cf0c: 653b         	str	r3, [r7, #0x50]
 800cf0e: 6d3b         	ldr	r3, [r7, #0x50]
 800cf10: 64fb         	str	r3, [r7, #0x4c]
; 	return &_kernel.ready_q.runq;
 800cf12: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800d09c <move_thread_to_end_of_prio_q+0x1c4>
 800cf14: 64bb         	str	r3, [r7, #0x48]
 800cf16: 6d3b         	ldr	r3, [r7, #0x50]
 800cf18: 647b         	str	r3, [r7, #0x44]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800cf1a: 6c7b         	ldr	r3, [r7, #0x44]
 800cf1c: 4618         	mov	r0, r3
 800cf1e: f00b f9a7    	bl	0x8018270 <sys_dlist_remove> @ imm = #0xb34e
; }
 800cf22: bf00         	nop
; }
 800cf24: bf00         	nop
; }
 800cf26: bf00         	nop
 800cf28: 687b         	ldr	r3, [r7, #0x4]
 800cf2a: 623b         	str	r3, [r7, #0x20]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800cf2c: 6a3b         	ldr	r3, [r7, #0x20]
 800cf2e: 7b5b         	ldrb	r3, [r3, #0xd]
 800cf30: f063 037f    	orn	r3, r3, #0x7f
 800cf34: b2da         	uxtb	r2, r3
 800cf36: 6a3b         	ldr	r3, [r7, #0x20]
 800cf38: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800cf3a: 6a38         	ldr	r0, [r7, #0x20]
 800cf3c: f00b fb68    	bl	0x8018610 <should_queue_thread> @ imm = #0xb6d0
 800cf40: 4603         	mov	r3, r0
 800cf42: 2b00         	cmp	r3, #0x0
 800cf44: d042         	beq	0x800cfcc <move_thread_to_end_of_prio_q+0xf4> @ imm = #0x84
 800cf46: 6a3b         	ldr	r3, [r7, #0x20]
 800cf48: 61fb         	str	r3, [r7, #0x1c]
 800cf4a: 69fb         	ldr	r3, [r7, #0x1c]
 800cf4c: 61bb         	str	r3, [r7, #0x18]
; 	return &_kernel.ready_q.runq;
 800cf4e: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800d09c <move_thread_to_end_of_prio_q+0x1c4>
 800cf50: 617b         	str	r3, [r7, #0x14]
 800cf52: 69fb         	ldr	r3, [r7, #0x1c]
 800cf54: 613b         	str	r3, [r7, #0x10]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800cf56: 6978         	ldr	r0, [r7, #0x14]
 800cf58: f00b f920    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xb240
 800cf5c: 4603         	mov	r3, r0
 800cf5e: 2b00         	cmp	r3, #0x0
 800cf60: d004         	beq	0x800cf6c <move_thread_to_end_of_prio_q+0x94> @ imm = #0x8
 800cf62: 6978         	ldr	r0, [r7, #0x14]
 800cf64: f00b f91a    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xb234
 800cf68: 4603         	mov	r3, r0
 800cf6a: e000         	b	0x800cf6e <move_thread_to_end_of_prio_q+0x96> @ imm = #0x0
 800cf6c: 2300         	movs	r3, #0x0
 800cf6e: 60fb         	str	r3, [r7, #0xc]
 800cf70: e023         	b	0x800cfba <move_thread_to_end_of_prio_q+0xe2> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800cf72: 68f9         	ldr	r1, [r7, #0xc]
 800cf74: 6938         	ldr	r0, [r7, #0x10]
 800cf76: f00b fb30    	bl	0x80185da <z_sched_prio_cmp> @ imm = #0xb660
 800cf7a: 4603         	mov	r3, r0
 800cf7c: 2b00         	cmp	r3, #0x0
 800cf7e: dd06         	ble	0x800cf8e <move_thread_to_end_of_prio_q+0xb6> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800cf80: 68fb         	ldr	r3, [r7, #0xc]
 800cf82: 693a         	ldr	r2, [r7, #0x10]
 800cf84: 4611         	mov	r1, r2
 800cf86: 4618         	mov	r0, r3
 800cf88: f00b f959    	bl	0x801823e <sys_dlist_insert> @ imm = #0xb2b2
; 			return;
 800cf8c: e01d         	b	0x800cfca <move_thread_to_end_of_prio_q+0xf2> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800cf8e: 68fb         	ldr	r3, [r7, #0xc]
 800cf90: 2b00         	cmp	r3, #0x0
 800cf92: d010         	beq	0x800cfb6 <move_thread_to_end_of_prio_q+0xde> @ imm = #0x20
 800cf94: 68fb         	ldr	r3, [r7, #0xc]
 800cf96: 4619         	mov	r1, r3
 800cf98: 6978         	ldr	r0, [r7, #0x14]
 800cf9a: f00b f924    	bl	0x80181e6 <sys_dlist_peek_next> @ imm = #0xb248
 800cf9e: 4603         	mov	r3, r0
 800cfa0: 2b00         	cmp	r3, #0x0
 800cfa2: d006         	beq	0x800cfb2 <move_thread_to_end_of_prio_q+0xda> @ imm = #0xc
 800cfa4: 68fb         	ldr	r3, [r7, #0xc]
 800cfa6: 4619         	mov	r1, r3
 800cfa8: 6978         	ldr	r0, [r7, #0x14]
 800cfaa: f00b f91c    	bl	0x80181e6 <sys_dlist_peek_next> @ imm = #0xb238
 800cfae: 4603         	mov	r3, r0
 800cfb0: e002         	b	0x800cfb8 <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x4
 800cfb2: 2300         	movs	r3, #0x0
 800cfb4: e000         	b	0x800cfb8 <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x0
 800cfb6: 2300         	movs	r3, #0x0
 800cfb8: 60fb         	str	r3, [r7, #0xc]
 800cfba: 68fb         	ldr	r3, [r7, #0xc]
 800cfbc: 2b00         	cmp	r3, #0x0
 800cfbe: d1d8         	bne	0x800cf72 <move_thread_to_end_of_prio_q+0x9a> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800cfc0: 693b         	ldr	r3, [r7, #0x10]
 800cfc2: 4619         	mov	r1, r3
 800cfc4: 6978         	ldr	r0, [r7, #0x14]
 800cfc6: f00b f921    	bl	0x801820c <sys_dlist_append> @ imm = #0xb242
; }
 800cfca: bf00         	nop
; }
 800cfcc: bf00         	nop
; 	update_cache(thread == _current);
 800cfce: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x800d0a0 <move_thread_to_end_of_prio_q+0x1c8>
 800cfd0: 689b         	ldr	r3, [r3, #0x8]
 800cfd2: 687a         	ldr	r2, [r7, #0x4]
 800cfd4: 429a         	cmp	r2, r3
 800cfd6: bf0c         	ite	eq
 800cfd8: 2301         	moveq	r3, #0x1
 800cfda: 2300         	movne	r3, #0x0
 800cfdc: b2db         	uxtb	r3, r3
 800cfde: 643b         	str	r3, [r7, #0x40]
; 	return &_kernel.ready_q.runq;
 800cfe0: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x800d09c <move_thread_to_end_of_prio_q+0x1c4>
 800cfe2: 63fb         	str	r3, [r7, #0x3c]
; 	struct k_thread *thread = NULL;
 800cfe4: 2300         	movs	r3, #0x0
 800cfe6: 63bb         	str	r3, [r7, #0x38]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800cfe8: 6bf8         	ldr	r0, [r7, #0x3c]
 800cfea: f00b f8d7    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xb1ae
 800cfee: 6378         	str	r0, [r7, #0x34]
; 	if (n != NULL) {
 800cff0: 6b7b         	ldr	r3, [r7, #0x34]
 800cff2: 2b00         	cmp	r3, #0x0
 800cff4: d001         	beq	0x800cffa <move_thread_to_end_of_prio_q+0x122> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800cff6: 6b7b         	ldr	r3, [r7, #0x34]
 800cff8: 63bb         	str	r3, [r7, #0x38]
; 	return thread;
 800cffa: 6bbb         	ldr	r3, [r7, #0x38]
; 	return _priq_run_best(curr_cpu_runq());
 800cffc: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800cffe: 633b         	str	r3, [r7, #0x30]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800d000: 6b3b         	ldr	r3, [r7, #0x30]
 800d002: 2b00         	cmp	r3, #0x0
 800d004: d102         	bne	0x800d00c <move_thread_to_end_of_prio_q+0x134> @ imm = #0x4
 800d006: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800d0a0 <move_thread_to_end_of_prio_q+0x1c8>
 800d008: 68db         	ldr	r3, [r3, #0xc]
 800d00a: e000         	b	0x800d00e <move_thread_to_end_of_prio_q+0x136> @ imm = #0x0
 800d00c: 6b3b         	ldr	r3, [r7, #0x30]
; 	struct k_thread *thread = next_up();
 800d00e: 62fb         	str	r3, [r7, #0x2c]
 800d010: 6afb         	ldr	r3, [r7, #0x2c]
 800d012: 62bb         	str	r3, [r7, #0x28]
 800d014: 6c3b         	ldr	r3, [r7, #0x40]
 800d016: 627b         	str	r3, [r7, #0x24]
; 	if (preempt_ok != 0) {
 800d018: 6a7b         	ldr	r3, [r7, #0x24]
 800d01a: 2b00         	cmp	r3, #0x0
 800d01c: d001         	beq	0x800d022 <move_thread_to_end_of_prio_q+0x14a> @ imm = #0x2
; 		return true;
 800d01e: 2301         	movs	r3, #0x1
 800d020: e022         	b	0x800d068 <move_thread_to_end_of_prio_q+0x190> @ imm = #0x44
; 	if (z_is_thread_prevented_from_running(_current)) {
 800d022: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800d0a0 <move_thread_to_end_of_prio_q+0x1c8>
 800d024: 689b         	ldr	r3, [r3, #0x8]
 800d026: 4618         	mov	r0, r3
 800d028: f00b f98a    	bl	0x8018340 <z_is_thread_prevented_from_running> @ imm = #0xb314
 800d02c: 4603         	mov	r3, r0
 800d02e: 2b00         	cmp	r3, #0x0
 800d030: d001         	beq	0x800d036 <move_thread_to_end_of_prio_q+0x15e> @ imm = #0x2
; 		return true;
 800d032: 2301         	movs	r3, #0x1
 800d034: e018         	b	0x800d068 <move_thread_to_end_of_prio_q+0x190> @ imm = #0x30
; 	if (thread_is_preemptible(_current) || thread_is_metairq(thread)) {
 800d036: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800d0a0 <move_thread_to_end_of_prio_q+0x1c8>
 800d038: 689b         	ldr	r3, [r3, #0x8]
 800d03a: 4618         	mov	r0, r3
 800d03c: f00b f966    	bl	0x801830c <thread_is_preemptible> @ imm = #0xb2cc
 800d040: 4603         	mov	r3, r0
 800d042: 2b00         	cmp	r3, #0x0
 800d044: d105         	bne	0x800d052 <move_thread_to_end_of_prio_q+0x17a> @ imm = #0xa
 800d046: 6ab8         	ldr	r0, [r7, #0x28]
 800d048: f00b f970    	bl	0x801832c <thread_is_metairq> @ imm = #0xb2e0
 800d04c: 4603         	mov	r3, r0
 800d04e: 2b00         	cmp	r3, #0x0
 800d050: d001         	beq	0x800d056 <move_thread_to_end_of_prio_q+0x17e> @ imm = #0x2
; 		return true;
 800d052: 2301         	movs	r3, #0x1
 800d054: e008         	b	0x800d068 <move_thread_to_end_of_prio_q+0x190> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800d056: 6ab8         	ldr	r0, [r7, #0x28]
 800d058: f00b f986    	bl	0x8018368 <z_is_thread_timeout_active> @ imm = #0xb30c
 800d05c: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800d05e: 2b00         	cmp	r3, #0x0
 800d060: d001         	beq	0x800d066 <move_thread_to_end_of_prio_q+0x18e> @ imm = #0x2
; 		return true;
 800d062: 2301         	movs	r3, #0x1
 800d064: e000         	b	0x800d068 <move_thread_to_end_of_prio_q+0x190> @ imm = #0x0
; 	return false;
 800d066: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800d068: 2b00         	cmp	r3, #0x0
 800d06a: d00e         	beq	0x800d08a <move_thread_to_end_of_prio_q+0x1b2> @ imm = #0x1c
; 		if (thread != _current) {
 800d06c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800d0a0 <move_thread_to_end_of_prio_q+0x1c8>
 800d06e: 689b         	ldr	r3, [r3, #0x8]
 800d070: 6afa         	ldr	r2, [r7, #0x2c]
 800d072: 429a         	cmp	r2, r3
 800d074: d002         	beq	0x800d07c <move_thread_to_end_of_prio_q+0x1a4> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800d076: 6af8         	ldr	r0, [r7, #0x2c]
 800d078: f001 faa6    	bl	0x800e5c8 <z_reset_time_slice> @ imm = #0x154c
; 		update_metairq_preempt(thread);
 800d07c: 6af8         	ldr	r0, [r7, #0x2c]
 800d07e: f00b fb0a    	bl	0x8018696 <update_metairq_preempt> @ imm = #0xb614
; 		_kernel.ready_q.cache = thread;
 800d082: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800d0a0 <move_thread_to_end_of_prio_q+0x1c8>
 800d084: 6afb         	ldr	r3, [r7, #0x2c]
 800d086: 61d3         	str	r3, [r2, #0x1c]
; }
 800d088: e003         	b	0x800d092 <move_thread_to_end_of_prio_q+0x1ba> @ imm = #0x6
; 		_kernel.ready_q.cache = _current;
 800d08a: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800d0a0 <move_thread_to_end_of_prio_q+0x1c8>
 800d08c: 689b         	ldr	r3, [r3, #0x8]
 800d08e: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800d0a0 <move_thread_to_end_of_prio_q+0x1c8>
 800d090: 61d3         	str	r3, [r2, #0x1c]
; }
 800d092: bf00         	nop
; }
 800d094: bf00         	nop
 800d096: 3758         	adds	r7, #0x58
 800d098: 46bd         	mov	sp, r7
 800d09a: bd80         	pop	{r7, pc}

0800d09c <$d>:
 800d09c: e8 06 00 20  	.word	0x200006e8
 800d0a0: c8 06 00 20  	.word	0x200006c8

0800d0a4 <ready_thread>:
; {
 800d0a4: b580         	push	{r7, lr}
 800d0a6: b090         	sub	sp, #0x40
 800d0a8: af00         	add	r7, sp, #0x0
 800d0aa: 6078         	str	r0, [r7, #0x4]
; 	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 800d0ac: 6878         	ldr	r0, [r7, #0x4]
 800d0ae: f00b f9ba    	bl	0x8018426 <z_is_thread_queued> @ imm = #0xb374
 800d0b2: 4603         	mov	r3, r0
 800d0b4: f083 0301    	eor	r3, r3, #0x1
 800d0b8: b2db         	uxtb	r3, r3
 800d0ba: 2b00         	cmp	r3, #0x0
 800d0bc: f000 80b6    	beq.w	0x800d22c <ready_thread+0x188> @ imm = #0x16c
 800d0c0: 6878         	ldr	r0, [r7, #0x4]
 800d0c2: f00b f96a    	bl	0x801839a <z_is_thread_ready> @ imm = #0xb2d4
 800d0c6: 4603         	mov	r3, r0
 800d0c8: 2b00         	cmp	r3, #0x0
 800d0ca: f000 80af    	beq.w	0x800d22c <ready_thread+0x188> @ imm = #0x15e
 800d0ce: 687b         	ldr	r3, [r7, #0x4]
 800d0d0: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800d0d2: 69fb         	ldr	r3, [r7, #0x1c]
 800d0d4: 7b5b         	ldrb	r3, [r3, #0xd]
 800d0d6: f063 037f    	orn	r3, r3, #0x7f
 800d0da: b2da         	uxtb	r2, r3
 800d0dc: 69fb         	ldr	r3, [r7, #0x1c]
 800d0de: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800d0e0: 69f8         	ldr	r0, [r7, #0x1c]
 800d0e2: f00b fa95    	bl	0x8018610 <should_queue_thread> @ imm = #0xb52a
 800d0e6: 4603         	mov	r3, r0
 800d0e8: 2b00         	cmp	r3, #0x0
 800d0ea: d042         	beq	0x800d172 <ready_thread+0xce> @ imm = #0x84
 800d0ec: 69fb         	ldr	r3, [r7, #0x1c]
 800d0ee: 61bb         	str	r3, [r7, #0x18]
 800d0f0: 69bb         	ldr	r3, [r7, #0x18]
 800d0f2: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 800d0f4: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x800d234 <ready_thread+0x190>
 800d0f6: 613b         	str	r3, [r7, #0x10]
 800d0f8: 69bb         	ldr	r3, [r7, #0x18]
 800d0fa: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800d0fc: 6938         	ldr	r0, [r7, #0x10]
 800d0fe: f00b f84d    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xb09a
 800d102: 4603         	mov	r3, r0
 800d104: 2b00         	cmp	r3, #0x0
 800d106: d004         	beq	0x800d112 <ready_thread+0x6e> @ imm = #0x8
 800d108: 6938         	ldr	r0, [r7, #0x10]
 800d10a: f00b f847    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xb08e
 800d10e: 4603         	mov	r3, r0
 800d110: e000         	b	0x800d114 <ready_thread+0x70> @ imm = #0x0
 800d112: 2300         	movs	r3, #0x0
 800d114: 60bb         	str	r3, [r7, #0x8]
 800d116: e023         	b	0x800d160 <ready_thread+0xbc> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800d118: 68b9         	ldr	r1, [r7, #0x8]
 800d11a: 68f8         	ldr	r0, [r7, #0xc]
 800d11c: f00b fa5d    	bl	0x80185da <z_sched_prio_cmp> @ imm = #0xb4ba
 800d120: 4603         	mov	r3, r0
 800d122: 2b00         	cmp	r3, #0x0
 800d124: dd06         	ble	0x800d134 <ready_thread+0x90> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800d126: 68bb         	ldr	r3, [r7, #0x8]
 800d128: 68fa         	ldr	r2, [r7, #0xc]
 800d12a: 4611         	mov	r1, r2
 800d12c: 4618         	mov	r0, r3
 800d12e: f00b f886    	bl	0x801823e <sys_dlist_insert> @ imm = #0xb10c
; 			return;
 800d132: e01d         	b	0x800d170 <ready_thread+0xcc> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800d134: 68bb         	ldr	r3, [r7, #0x8]
 800d136: 2b00         	cmp	r3, #0x0
 800d138: d010         	beq	0x800d15c <ready_thread+0xb8> @ imm = #0x20
 800d13a: 68bb         	ldr	r3, [r7, #0x8]
 800d13c: 4619         	mov	r1, r3
 800d13e: 6938         	ldr	r0, [r7, #0x10]
 800d140: f00b f851    	bl	0x80181e6 <sys_dlist_peek_next> @ imm = #0xb0a2
 800d144: 4603         	mov	r3, r0
 800d146: 2b00         	cmp	r3, #0x0
 800d148: d006         	beq	0x800d158 <ready_thread+0xb4> @ imm = #0xc
 800d14a: 68bb         	ldr	r3, [r7, #0x8]
 800d14c: 4619         	mov	r1, r3
 800d14e: 6938         	ldr	r0, [r7, #0x10]
 800d150: f00b f849    	bl	0x80181e6 <sys_dlist_peek_next> @ imm = #0xb092
 800d154: 4603         	mov	r3, r0
 800d156: e002         	b	0x800d15e <ready_thread+0xba> @ imm = #0x4
 800d158: 2300         	movs	r3, #0x0
 800d15a: e000         	b	0x800d15e <ready_thread+0xba> @ imm = #0x0
 800d15c: 2300         	movs	r3, #0x0
 800d15e: 60bb         	str	r3, [r7, #0x8]
 800d160: 68bb         	ldr	r3, [r7, #0x8]
 800d162: 2b00         	cmp	r3, #0x0
 800d164: d1d8         	bne	0x800d118 <ready_thread+0x74> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800d166: 68fb         	ldr	r3, [r7, #0xc]
 800d168: 4619         	mov	r1, r3
 800d16a: 6938         	ldr	r0, [r7, #0x10]
 800d16c: f00b f84e    	bl	0x801820c <sys_dlist_append> @ imm = #0xb09c
; }
 800d170: bf00         	nop
; }
 800d172: bf00         	nop
 800d174: 2300         	movs	r3, #0x0
 800d176: 63fb         	str	r3, [r7, #0x3c]
; 	return &_kernel.ready_q.runq;
 800d178: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x800d234 <ready_thread+0x190>
 800d17a: 63bb         	str	r3, [r7, #0x38]
; 	struct k_thread *thread = NULL;
 800d17c: 2300         	movs	r3, #0x0
 800d17e: 637b         	str	r3, [r7, #0x34]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800d180: 6bb8         	ldr	r0, [r7, #0x38]
 800d182: f00b f80b    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xb016
 800d186: 6338         	str	r0, [r7, #0x30]
; 	if (n != NULL) {
 800d188: 6b3b         	ldr	r3, [r7, #0x30]
 800d18a: 2b00         	cmp	r3, #0x0
 800d18c: d001         	beq	0x800d192 <ready_thread+0xee> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800d18e: 6b3b         	ldr	r3, [r7, #0x30]
 800d190: 637b         	str	r3, [r7, #0x34]
; 	return thread;
 800d192: 6b7b         	ldr	r3, [r7, #0x34]
; 	return _priq_run_best(curr_cpu_runq());
 800d194: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800d196: 62fb         	str	r3, [r7, #0x2c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800d198: 6afb         	ldr	r3, [r7, #0x2c]
 800d19a: 2b00         	cmp	r3, #0x0
 800d19c: d102         	bne	0x800d1a4 <ready_thread+0x100> @ imm = #0x4
 800d19e: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800d238 <ready_thread+0x194>
 800d1a0: 68db         	ldr	r3, [r3, #0xc]
 800d1a2: e000         	b	0x800d1a6 <ready_thread+0x102> @ imm = #0x0
 800d1a4: 6afb         	ldr	r3, [r7, #0x2c]
; 	struct k_thread *thread = next_up();
 800d1a6: 62bb         	str	r3, [r7, #0x28]
 800d1a8: 6abb         	ldr	r3, [r7, #0x28]
 800d1aa: 627b         	str	r3, [r7, #0x24]
 800d1ac: 6bfb         	ldr	r3, [r7, #0x3c]
 800d1ae: 623b         	str	r3, [r7, #0x20]
; 	if (preempt_ok != 0) {
 800d1b0: 6a3b         	ldr	r3, [r7, #0x20]
 800d1b2: 2b00         	cmp	r3, #0x0
 800d1b4: d001         	beq	0x800d1ba <ready_thread+0x116> @ imm = #0x2
; 		return true;
 800d1b6: 2301         	movs	r3, #0x1
 800d1b8: e022         	b	0x800d200 <ready_thread+0x15c> @ imm = #0x44
; 	if (z_is_thread_prevented_from_running(_current)) {
 800d1ba: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800d238 <ready_thread+0x194>
 800d1bc: 689b         	ldr	r3, [r3, #0x8]
 800d1be: 4618         	mov	r0, r3
 800d1c0: f00b f8be    	bl	0x8018340 <z_is_thread_prevented_from_running> @ imm = #0xb17c
 800d1c4: 4603         	mov	r3, r0
 800d1c6: 2b00         	cmp	r3, #0x0
 800d1c8: d001         	beq	0x800d1ce <ready_thread+0x12a> @ imm = #0x2
; 		return true;
 800d1ca: 2301         	movs	r3, #0x1
 800d1cc: e018         	b	0x800d200 <ready_thread+0x15c> @ imm = #0x30
; 	if (thread_is_preemptible(_current) || thread_is_metairq(thread)) {
 800d1ce: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800d238 <ready_thread+0x194>
 800d1d0: 689b         	ldr	r3, [r3, #0x8]
 800d1d2: 4618         	mov	r0, r3
 800d1d4: f00b f89a    	bl	0x801830c <thread_is_preemptible> @ imm = #0xb134
 800d1d8: 4603         	mov	r3, r0
 800d1da: 2b00         	cmp	r3, #0x0
 800d1dc: d105         	bne	0x800d1ea <ready_thread+0x146> @ imm = #0xa
 800d1de: 6a78         	ldr	r0, [r7, #0x24]
 800d1e0: f00b f8a4    	bl	0x801832c <thread_is_metairq> @ imm = #0xb148
 800d1e4: 4603         	mov	r3, r0
 800d1e6: 2b00         	cmp	r3, #0x0
 800d1e8: d001         	beq	0x800d1ee <ready_thread+0x14a> @ imm = #0x2
; 		return true;
 800d1ea: 2301         	movs	r3, #0x1
 800d1ec: e008         	b	0x800d200 <ready_thread+0x15c> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800d1ee: 6a78         	ldr	r0, [r7, #0x24]
 800d1f0: f00b f8ba    	bl	0x8018368 <z_is_thread_timeout_active> @ imm = #0xb174
 800d1f4: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800d1f6: 2b00         	cmp	r3, #0x0
 800d1f8: d001         	beq	0x800d1fe <ready_thread+0x15a> @ imm = #0x2
; 		return true;
 800d1fa: 2301         	movs	r3, #0x1
 800d1fc: e000         	b	0x800d200 <ready_thread+0x15c> @ imm = #0x0
; 	return false;
 800d1fe: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800d200: 2b00         	cmp	r3, #0x0
 800d202: d00e         	beq	0x800d222 <ready_thread+0x17e> @ imm = #0x1c
; 		if (thread != _current) {
 800d204: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800d238 <ready_thread+0x194>
 800d206: 689b         	ldr	r3, [r3, #0x8]
 800d208: 6aba         	ldr	r2, [r7, #0x28]
 800d20a: 429a         	cmp	r2, r3
 800d20c: d002         	beq	0x800d214 <ready_thread+0x170> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800d20e: 6ab8         	ldr	r0, [r7, #0x28]
 800d210: f001 f9da    	bl	0x800e5c8 <z_reset_time_slice> @ imm = #0x13b4
; 		update_metairq_preempt(thread);
 800d214: 6ab8         	ldr	r0, [r7, #0x28]
 800d216: f00b fa3e    	bl	0x8018696 <update_metairq_preempt> @ imm = #0xb47c
; 		_kernel.ready_q.cache = thread;
 800d21a: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800d238 <ready_thread+0x194>
 800d21c: 6abb         	ldr	r3, [r7, #0x28]
 800d21e: 61d3         	str	r3, [r2, #0x1c]
; }
 800d220: e003         	b	0x800d22a <ready_thread+0x186> @ imm = #0x6
; 		_kernel.ready_q.cache = _current;
 800d222: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800d238 <ready_thread+0x194>
 800d224: 689b         	ldr	r3, [r3, #0x8]
 800d226: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800d238 <ready_thread+0x194>
 800d228: 61d3         	str	r3, [r2, #0x1c]
; }
 800d22a: bf00         	nop
; }
 800d22c: bf00         	nop
 800d22e: 3740         	adds	r7, #0x40
 800d230: 46bd         	mov	sp, r7
 800d232: bd80         	pop	{r7, pc}

0800d234 <$d>:
 800d234: e8 06 00 20  	.word	0x200006e8
 800d238: c8 06 00 20  	.word	0x200006c8

0800d23c <z_ready_thread>:
; {
 800d23c: b580         	push	{r7, lr}
 800d23e: b090         	sub	sp, #0x40
 800d240: af00         	add	r7, sp, #0x0
 800d242: 6078         	str	r0, [r7, #0x4]
; 	K_SPINLOCK(&_sched_spinlock) {
 800d244: 2300         	movs	r3, #0x0
 800d246: 61bb         	str	r3, [r7, #0x18]
 800d248: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800d2c8 <z_ready_thread+0x8c>
 800d24a: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d24c: f3ef 8311    	mrs	r3, basepri
 800d250: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800d252: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 800d254: 637b         	str	r3, [r7, #0x34]
 800d256: 2310         	movs	r3, #0x10
 800d258: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d25a: 6b3b         	ldr	r3, [r7, #0x30]
 800d25c: f383 8812    	msr	basepri_max, r3
; }
 800d260: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d262: f3bf 8f6f    	isb	sy
; }
 800d266: bf00         	nop
; 	return key;
 800d268: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 800d26a: 60fb         	str	r3, [r7, #0xc]
 800d26c: 6bfb         	ldr	r3, [r7, #0x3c]
 800d26e: 62fb         	str	r3, [r7, #0x2c]
; }
 800d270: bf00         	nop
 800d272: 6bfb         	ldr	r3, [r7, #0x3c]
 800d274: 62bb         	str	r3, [r7, #0x28]
; }
 800d276: bf00         	nop
; 	return k;
 800d278: 68fb         	ldr	r3, [r7, #0xc]
 800d27a: 617b         	str	r3, [r7, #0x14]
; 	K_SPINLOCK(&_sched_spinlock) {
 800d27c: e01b         	b	0x800d2b6 <z_ready_thread+0x7a> @ imm = #0x36
; 		if (thread_active_elsewhere(thread) == NULL) {
 800d27e: 6878         	ldr	r0, [r7, #0x4]
 800d280: f00b fa12    	bl	0x80186a8 <thread_active_elsewhere> @ imm = #0xb424
 800d284: 4603         	mov	r3, r0
 800d286: 2b00         	cmp	r3, #0x0
 800d288: d102         	bne	0x800d290 <z_ready_thread+0x54> @ imm = #0x4
; 			ready_thread(thread);
 800d28a: 6878         	ldr	r0, [r7, #0x4]
 800d28c: f7ff ff0a    	bl	0x800d0a4 <ready_thread> @ imm = #-0x1ec
 800d290: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800d2c8 <z_ready_thread+0x8c>
 800d292: 627b         	str	r3, [r7, #0x24]
 800d294: 697b         	ldr	r3, [r7, #0x14]
 800d296: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800d298: 693b         	ldr	r3, [r7, #0x10]
 800d29a: 623b         	str	r3, [r7, #0x20]
 800d29c: 6a3b         	ldr	r3, [r7, #0x20]
 800d29e: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d2a0: 69fb         	ldr	r3, [r7, #0x1c]
 800d2a2: f383 8811    	msr	basepri, r3
; }
 800d2a6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d2a8: f3bf 8f6f    	isb	sy
; }
 800d2ac: bf00         	nop
; }
 800d2ae: bf00         	nop
; }
 800d2b0: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800d2b2: 2301         	movs	r3, #0x1
 800d2b4: 61bb         	str	r3, [r7, #0x18]
 800d2b6: 69bb         	ldr	r3, [r7, #0x18]
 800d2b8: 2b00         	cmp	r3, #0x0
 800d2ba: d0e0         	beq	0x800d27e <z_ready_thread+0x42> @ imm = #-0x40
; }
 800d2bc: bf00         	nop
 800d2be: bf00         	nop
 800d2c0: 3740         	adds	r7, #0x40
 800d2c2: 46bd         	mov	sp, r7
 800d2c4: bd80         	pop	{r7, pc}
 800d2c6: bf00         	nop

0800d2c8 <$d>:
 800d2c8: e8 10 00 20  	.word	0x200010e8

0800d2cc <z_sched_start>:
; {
 800d2cc: b580         	push	{r7, lr}
 800d2ce: b08e         	sub	sp, #0x38
 800d2d0: af00         	add	r7, sp, #0x0
 800d2d2: 6078         	str	r0, [r7, #0x4]
 800d2d4: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800d350 <z_sched_start+0x84>
 800d2d6: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d2d8: f3ef 8311    	mrs	r3, basepri
 800d2dc: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800d2de: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800d2e0: 62fb         	str	r3, [r7, #0x2c]
 800d2e2: 2310         	movs	r3, #0x10
 800d2e4: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d2e6: 6abb         	ldr	r3, [r7, #0x28]
 800d2e8: f383 8812    	msr	basepri_max, r3
; }
 800d2ec: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d2ee: f3bf 8f6f    	isb	sy
; }
 800d2f2: bf00         	nop
; 	return key;
 800d2f4: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800d2f6: 60bb         	str	r3, [r7, #0x8]
 800d2f8: 6b7b         	ldr	r3, [r7, #0x34]
 800d2fa: 627b         	str	r3, [r7, #0x24]
; }
 800d2fc: bf00         	nop
 800d2fe: 6b7b         	ldr	r3, [r7, #0x34]
 800d300: 623b         	str	r3, [r7, #0x20]
; }
 800d302: bf00         	nop
; 	return k;
 800d304: 68bb         	ldr	r3, [r7, #0x8]
 800d306: 613b         	str	r3, [r7, #0x10]
; 	if (z_has_thread_started(thread)) {
 800d308: 6878         	ldr	r0, [r7, #0x4]
 800d30a: f00b f866    	bl	0x80183da <z_has_thread_started> @ imm = #0xb0cc
 800d30e: 4603         	mov	r3, r0
 800d310: 2b00         	cmp	r3, #0x0
 800d312: d010         	beq	0x800d336 <z_sched_start+0x6a> @ imm = #0x20
 800d314: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800d350 <z_sched_start+0x84>
 800d316: 61fb         	str	r3, [r7, #0x1c]
 800d318: 693b         	ldr	r3, [r7, #0x10]
 800d31a: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800d31c: 68fb         	ldr	r3, [r7, #0xc]
 800d31e: 61bb         	str	r3, [r7, #0x18]
 800d320: 69bb         	ldr	r3, [r7, #0x18]
 800d322: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d324: 697b         	ldr	r3, [r7, #0x14]
 800d326: f383 8811    	msr	basepri, r3
; }
 800d32a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d32c: f3bf 8f6f    	isb	sy
; }
 800d330: bf00         	nop
; }
 800d332: bf00         	nop
; }
 800d334: e009         	b	0x800d34a <z_sched_start+0x7e> @ imm = #0x12
; 	z_mark_thread_as_started(thread);
 800d336: 6878         	ldr	r0, [r7, #0x4]
 800d338: f00b f8a2    	bl	0x8018480 <z_mark_thread_as_started> @ imm = #0xb144
; 	ready_thread(thread);
 800d33c: 6878         	ldr	r0, [r7, #0x4]
 800d33e: f7ff feb1    	bl	0x800d0a4 <ready_thread> @ imm = #-0x29e
; 	z_reschedule(&_sched_spinlock, key);
 800d342: 6939         	ldr	r1, [r7, #0x10]
 800d344: 4802         	ldr	r0, [pc, #0x8]          @ 0x800d350 <z_sched_start+0x84>
 800d346: f00b fa70    	bl	0x801882a <z_reschedule> @ imm = #0xb4e0
; }
 800d34a: 3738         	adds	r7, #0x38
 800d34c: 46bd         	mov	sp, r7
 800d34e: bd80         	pop	{r7, pc}

0800d350 <$d>:
 800d350: e8 10 00 20  	.word	0x200010e8

0800d354 <thread_halt_spin>:
; {
 800d354: b590         	push	{r4, r7, lr}
 800d356: b08d         	sub	sp, #0x34
 800d358: af00         	add	r7, sp, #0x0
 800d35a: 6078         	str	r0, [r7, #0x4]
 800d35c: 6039         	str	r1, [r7]
; 	if (is_halting(_current)) {
 800d35e: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800d408 <thread_halt_spin+0xb4>
 800d360: 689b         	ldr	r3, [r3, #0x8]
 800d362: 4618         	mov	r0, r3
 800d364: f00b f970    	bl	0x8018648 <is_halting>  @ imm = #0xb2e0
 800d368: 4603         	mov	r3, r0
 800d36a: 2b00         	cmp	r3, #0x0
 800d36c: d010         	beq	0x800d390 <thread_halt_spin+0x3c> @ imm = #0x20
; 		halt_thread(_current,
 800d36e: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800d408 <thread_halt_spin+0xb4>
 800d370: 689c         	ldr	r4, [r3, #0x8]
; 			    is_aborting(_current) ? _THREAD_DEAD : _THREAD_SUSPENDED);
 800d372: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800d408 <thread_halt_spin+0xb4>
 800d374: 689b         	ldr	r3, [r3, #0x8]
 800d376: 4618         	mov	r0, r3
 800d378: f00b f954    	bl	0x8018624 <is_aborting> @ imm = #0xb2a8
 800d37c: 4603         	mov	r3, r0
; 		halt_thread(_current,
 800d37e: 2b00         	cmp	r3, #0x0
 800d380: d001         	beq	0x800d386 <thread_halt_spin+0x32> @ imm = #0x2
 800d382: 2308         	movs	r3, #0x8
 800d384: e000         	b	0x800d388 <thread_halt_spin+0x34> @ imm = #0x0
 800d386: 2310         	movs	r3, #0x10
 800d388: 4619         	mov	r1, r3
 800d38a: 4620         	mov	r0, r4
 800d38c: f000 fec4    	bl	0x800e118 <halt_thread> @ imm = #0xd88
 800d390: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800d40c <thread_halt_spin+0xb8>
 800d392: 62bb         	str	r3, [r7, #0x28]
 800d394: 683b         	ldr	r3, [r7]
 800d396: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800d398: 68bb         	ldr	r3, [r7, #0x8]
 800d39a: 627b         	str	r3, [r7, #0x24]
 800d39c: 6a7b         	ldr	r3, [r7, #0x24]
 800d39e: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d3a0: 6a3b         	ldr	r3, [r7, #0x20]
 800d3a2: f383 8811    	msr	basepri, r3
; }
 800d3a6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d3a8: f3bf 8f6f    	isb	sy
; }
 800d3ac: bf00         	nop
; }
 800d3ae: bf00         	nop
; }
 800d3b0: bf00         	nop
; 	while (is_halting(thread)) {
 800d3b2: e01d         	b	0x800d3f0 <thread_halt_spin+0x9c> @ imm = #0x3a
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d3b4: f3ef 8311    	mrs	r3, basepri
 800d3b8: 617b         	str	r3, [r7, #0x14]
;   return(result);
 800d3ba: 697b         	ldr	r3, [r7, #0x14]
; 	key = __get_BASEPRI();
 800d3bc: 613b         	str	r3, [r7, #0x10]
 800d3be: 2310         	movs	r3, #0x10
 800d3c0: 60fb         	str	r3, [r7, #0xc]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d3c2: 68fb         	ldr	r3, [r7, #0xc]
 800d3c4: f383 8812    	msr	basepri_max, r3
; }
 800d3c8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d3ca: f3bf 8f6f    	isb	sy
; }
 800d3ce: bf00         	nop
; 	return key;
 800d3d0: 693b         	ldr	r3, [r7, #0x10]
; 		unsigned int k = arch_irq_lock();
 800d3d2: 62fb         	str	r3, [r7, #0x2c]
; 		arch_spin_relax(); /* Requires interrupts be masked */
 800d3d4: f009 ff98    	bl	0x8017308 <arch_spin_relax> @ imm = #0x9f30
 800d3d8: 6afb         	ldr	r3, [r7, #0x2c]
 800d3da: 61fb         	str	r3, [r7, #0x1c]
 800d3dc: 69fb         	ldr	r3, [r7, #0x1c]
 800d3de: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d3e0: 69bb         	ldr	r3, [r7, #0x18]
 800d3e2: f383 8811    	msr	basepri, r3
; }
 800d3e6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d3e8: f3bf 8f6f    	isb	sy
; }
 800d3ec: bf00         	nop
; }
 800d3ee: bf00         	nop
; 	while (is_halting(thread)) {
 800d3f0: 6878         	ldr	r0, [r7, #0x4]
 800d3f2: f00b f929    	bl	0x8018648 <is_halting>  @ imm = #0xb252
 800d3f6: 4603         	mov	r3, r0
 800d3f8: 2b00         	cmp	r3, #0x0
 800d3fa: d1db         	bne	0x800d3b4 <thread_halt_spin+0x60> @ imm = #-0x4a
; }
 800d3fc: bf00         	nop
 800d3fe: bf00         	nop
 800d400: 3734         	adds	r7, #0x34
 800d402: 46bd         	mov	sp, r7
 800d404: bd90         	pop	{r4, r7, pc}
 800d406: bf00         	nop

0800d408 <$d>:
 800d408: c8 06 00 20  	.word	0x200006c8
 800d40c: e8 10 00 20  	.word	0x200010e8

0800d410 <z_thread_halt>:
; {
 800d410: b580         	push	{r7, lr}
 800d412: b092         	sub	sp, #0x48
 800d414: af00         	add	r7, sp, #0x0
 800d416: 60f8         	str	r0, [r7, #0xc]
 800d418: 60b9         	str	r1, [r7, #0x8]
 800d41a: 4613         	mov	r3, r2
 800d41c: 71fb         	strb	r3, [r7, #0x7]
; 	_wait_q_t *wq = &thread->join_queue;
 800d41e: 68fb         	ldr	r3, [r7, #0xc]
 800d420: 3368         	adds	r3, #0x68
 800d422: 647b         	str	r3, [r7, #0x44]
; 	struct _cpu *cpu = thread_active_elsewhere(thread);
 800d424: 68f8         	ldr	r0, [r7, #0xc]
 800d426: f00b f93f    	bl	0x80186a8 <thread_active_elsewhere> @ imm = #0xb27e
 800d42a: 6438         	str	r0, [r7, #0x40]
; 	if (cpu != NULL) {
 800d42c: 6c3b         	ldr	r3, [r7, #0x40]
 800d42e: 2b00         	cmp	r3, #0x0
 800d430: d02d         	beq	0x800d48e <z_thread_halt+0x7e> @ imm = #0x5a
; 		thread->base.thread_state |= (terminate ? _THREAD_ABORTING
 800d432: 68fb         	ldr	r3, [r7, #0xc]
 800d434: 7b5b         	ldrb	r3, [r3, #0xd]
 800d436: 79fa         	ldrb	r2, [r7, #0x7]
 800d438: 2a00         	cmp	r2, #0x0
 800d43a: d001         	beq	0x800d440 <z_thread_halt+0x30> @ imm = #0x2
 800d43c: 2220         	movs	r2, #0x20
 800d43e: e000         	b	0x800d442 <z_thread_halt+0x32> @ imm = #0x0
 800d440: 2240         	movs	r2, #0x40
 800d442: 4313         	orrs	r3, r2
 800d444: b2da         	uxtb	r2, r3
 800d446: 68fb         	ldr	r3, [r7, #0xc]
 800d448: 735a         	strb	r2, [r3, #0xd]
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800d44a: f3ef 8305    	mrs	r3, ipsr
 800d44e: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800d450: 6bfb         	ldr	r3, [r7, #0x3c]
; 	return (__get_IPSR()) ? (true) : (false);
 800d452: 2b00         	cmp	r3, #0x0
 800d454: bf14         	ite	ne
 800d456: 2301         	movne	r3, #0x1
 800d458: 2300         	moveq	r3, #0x0
 800d45a: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 800d45c: 2b00         	cmp	r3, #0x0
 800d45e: d004         	beq	0x800d46a <z_thread_halt+0x5a> @ imm = #0x8
; 			thread_halt_spin(thread, key);
 800d460: 68b9         	ldr	r1, [r7, #0x8]
 800d462: 68f8         	ldr	r0, [r7, #0xc]
 800d464: f7ff ff76    	bl	0x800d354 <thread_halt_spin> @ imm = #-0x114
; }
 800d468: e04b         	b	0x800d502 <z_thread_halt+0xf2> @ imm = #0x96
; 			add_to_waitq_locked(_current, wq);
 800d46a: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800d50c <z_thread_halt+0xfc>
 800d46c: 689b         	ldr	r3, [r3, #0x8]
 800d46e: 6c79         	ldr	r1, [r7, #0x44]
 800d470: 4618         	mov	r0, r3
 800d472: f00b f923    	bl	0x80186bc <add_to_waitq_locked> @ imm = #0xb246
 800d476: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800d510 <z_thread_halt+0x100>
 800d478: 63bb         	str	r3, [r7, #0x38]
 800d47a: 68bb         	ldr	r3, [r7, #0x8]
 800d47c: 613b         	str	r3, [r7, #0x10]
 800d47e: 6bbb         	ldr	r3, [r7, #0x38]
 800d480: 637b         	str	r3, [r7, #0x34]
; }
 800d482: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800d484: 693b         	ldr	r3, [r7, #0x10]
 800d486: 4618         	mov	r0, r3
 800d488: f00b f87c    	bl	0x8018584 <z_swap_irqlock> @ imm = #0xb0f8
 800d48c: e039         	b	0x800d502 <z_thread_halt+0xf2> @ imm = #0x72
; 		halt_thread(thread, terminate ? _THREAD_DEAD : _THREAD_SUSPENDED);
 800d48e: 79fb         	ldrb	r3, [r7, #0x7]
 800d490: 2b00         	cmp	r3, #0x0
 800d492: d001         	beq	0x800d498 <z_thread_halt+0x88> @ imm = #0x2
 800d494: 2308         	movs	r3, #0x8
 800d496: e000         	b	0x800d49a <z_thread_halt+0x8a> @ imm = #0x0
 800d498: 2310         	movs	r3, #0x10
 800d49a: 4619         	mov	r1, r3
 800d49c: 68f8         	ldr	r0, [r7, #0xc]
 800d49e: f000 fe3b    	bl	0x800e118 <halt_thread> @ imm = #0xc76
; 		if ((thread == _current) && !arch_is_in_isr()) {
 800d4a2: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800d50c <z_thread_halt+0xfc>
 800d4a4: 689b         	ldr	r3, [r3, #0x8]
 800d4a6: 68fa         	ldr	r2, [r7, #0xc]
 800d4a8: 429a         	cmp	r2, r3
 800d4aa: d119         	bne	0x800d4e0 <z_thread_halt+0xd0> @ imm = #0x32
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800d4ac: f3ef 8305    	mrs	r3, ipsr
 800d4b0: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800d4b2: 6b3b         	ldr	r3, [r7, #0x30]
; 	return (__get_IPSR()) ? (true) : (false);
 800d4b4: 2b00         	cmp	r3, #0x0
 800d4b6: bf14         	ite	ne
 800d4b8: 2301         	movne	r3, #0x1
 800d4ba: 2300         	moveq	r3, #0x0
 800d4bc: b2db         	uxtb	r3, r3
; 		if ((thread == _current) && !arch_is_in_isr()) {
 800d4be: f083 0301    	eor	r3, r3, #0x1
 800d4c2: b2db         	uxtb	r3, r3
 800d4c4: 2b00         	cmp	r3, #0x0
 800d4c6: d00b         	beq	0x800d4e0 <z_thread_halt+0xd0> @ imm = #0x16
 800d4c8: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800d510 <z_thread_halt+0x100>
 800d4ca: 62fb         	str	r3, [r7, #0x2c]
 800d4cc: 68bb         	ldr	r3, [r7, #0x8]
 800d4ce: 617b         	str	r3, [r7, #0x14]
 800d4d0: 6afb         	ldr	r3, [r7, #0x2c]
 800d4d2: 62bb         	str	r3, [r7, #0x28]
; }
 800d4d4: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800d4d6: 697b         	ldr	r3, [r7, #0x14]
 800d4d8: 4618         	mov	r0, r3
 800d4da: f00b f853    	bl	0x8018584 <z_swap_irqlock> @ imm = #0xb0a6
; 			z_swap(&_sched_spinlock, key);
 800d4de: e010         	b	0x800d502 <z_thread_halt+0xf2> @ imm = #0x20
 800d4e0: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800d510 <z_thread_halt+0x100>
 800d4e2: 627b         	str	r3, [r7, #0x24]
 800d4e4: 68bb         	ldr	r3, [r7, #0x8]
 800d4e6: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800d4e8: 69bb         	ldr	r3, [r7, #0x18]
 800d4ea: 623b         	str	r3, [r7, #0x20]
 800d4ec: 6a3b         	ldr	r3, [r7, #0x20]
 800d4ee: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d4f0: 69fb         	ldr	r3, [r7, #0x1c]
 800d4f2: f383 8811    	msr	basepri, r3
; }
 800d4f6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d4f8: f3bf 8f6f    	isb	sy
; }
 800d4fc: bf00         	nop
; }
 800d4fe: bf00         	nop
; }
 800d500: bf00         	nop
; }
 800d502: bf00         	nop
 800d504: 3748         	adds	r7, #0x48
 800d506: 46bd         	mov	sp, r7
 800d508: bd80         	pop	{r7, pc}
 800d50a: bf00         	nop

0800d50c <$d>:
 800d50c: c8 06 00 20  	.word	0x200006c8
 800d510: e8 10 00 20  	.word	0x200010e8

0800d514 <z_impl_k_thread_suspend>:
; {
 800d514: b580         	push	{r7, lr}
 800d516: b08e         	sub	sp, #0x38
 800d518: af00         	add	r7, sp, #0x0
 800d51a: 6078         	str	r0, [r7, #0x4]
; 	(void)z_abort_thread_timeout(thread);
 800d51c: 6878         	ldr	r0, [r7, #0x4]
 800d51e: f00a fee7    	bl	0x80182f0 <z_abort_thread_timeout> @ imm = #0xadce
 800d522: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800d594 <z_impl_k_thread_suspend+0x80>
 800d524: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d526: f3ef 8311    	mrs	r3, basepri
 800d52a: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800d52c: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800d52e: 62fb         	str	r3, [r7, #0x2c]
 800d530: 2310         	movs	r3, #0x10
 800d532: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d534: 6abb         	ldr	r3, [r7, #0x28]
 800d536: f383 8812    	msr	basepri_max, r3
; }
 800d53a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d53c: f3bf 8f6f    	isb	sy
; }
 800d540: bf00         	nop
; 	return key;
 800d542: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800d544: 60bb         	str	r3, [r7, #0x8]
 800d546: 6b7b         	ldr	r3, [r7, #0x34]
 800d548: 627b         	str	r3, [r7, #0x24]
; }
 800d54a: bf00         	nop
 800d54c: 6b7b         	ldr	r3, [r7, #0x34]
 800d54e: 623b         	str	r3, [r7, #0x20]
; }
 800d550: bf00         	nop
; 	return k;
 800d552: 68bb         	ldr	r3, [r7, #0x8]
 800d554: 613b         	str	r3, [r7, #0x10]
; 	if ((thread->base.thread_state & _THREAD_SUSPENDED) != 0U) {
 800d556: 687b         	ldr	r3, [r7, #0x4]
 800d558: 7b5b         	ldrb	r3, [r3, #0xd]
 800d55a: f003 0310    	and	r3, r3, #0x10
 800d55e: 2b00         	cmp	r3, #0x0
 800d560: d010         	beq	0x800d584 <z_impl_k_thread_suspend+0x70> @ imm = #0x20
 800d562: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800d594 <z_impl_k_thread_suspend+0x80>
 800d564: 61fb         	str	r3, [r7, #0x1c]
 800d566: 693b         	ldr	r3, [r7, #0x10]
 800d568: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800d56a: 68fb         	ldr	r3, [r7, #0xc]
 800d56c: 61bb         	str	r3, [r7, #0x18]
 800d56e: 69bb         	ldr	r3, [r7, #0x18]
 800d570: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d572: 697b         	ldr	r3, [r7, #0x14]
 800d574: f383 8811    	msr	basepri, r3
; }
 800d578: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d57a: f3bf 8f6f    	isb	sy
; }
 800d57e: bf00         	nop
; }
 800d580: bf00         	nop
; }
 800d582: e004         	b	0x800d58e <z_impl_k_thread_suspend+0x7a> @ imm = #0x8
; 	z_thread_halt(thread, key, false);
 800d584: 2200         	movs	r2, #0x0
 800d586: 6939         	ldr	r1, [r7, #0x10]
 800d588: 6878         	ldr	r0, [r7, #0x4]
 800d58a: f7ff ff41    	bl	0x800d410 <z_thread_halt> @ imm = #-0x17e
; }
 800d58e: 3738         	adds	r7, #0x38
 800d590: 46bd         	mov	sp, r7
 800d592: bd80         	pop	{r7, pc}

0800d594 <$d>:
 800d594: e8 10 00 20  	.word	0x200010e8

0800d598 <unready_thread>:
; {
 800d598: b580         	push	{r7, lr}
 800d59a: b090         	sub	sp, #0x40
 800d59c: af00         	add	r7, sp, #0x0
 800d59e: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 800d5a0: 6878         	ldr	r0, [r7, #0x4]
 800d5a2: f00a ff40    	bl	0x8018426 <z_is_thread_queued> @ imm = #0xae80
 800d5a6: 4603         	mov	r3, r0
 800d5a8: 2b00         	cmp	r3, #0x0
 800d5aa: d01d         	beq	0x800d5e8 <unready_thread+0x50> @ imm = #0x3a
 800d5ac: 687b         	ldr	r3, [r7, #0x4]
 800d5ae: 63fb         	str	r3, [r7, #0x3c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800d5b0: 6bfb         	ldr	r3, [r7, #0x3c]
 800d5b2: 7b5b         	ldrb	r3, [r3, #0xd]
 800d5b4: f003 037f    	and	r3, r3, #0x7f
 800d5b8: b2da         	uxtb	r2, r3
 800d5ba: 6bfb         	ldr	r3, [r7, #0x3c]
 800d5bc: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800d5be: 6bf8         	ldr	r0, [r7, #0x3c]
 800d5c0: f00b f826    	bl	0x8018610 <should_queue_thread> @ imm = #0xb04c
 800d5c4: 4603         	mov	r3, r0
 800d5c6: 2b00         	cmp	r3, #0x0
 800d5c8: d00d         	beq	0x800d5e6 <unready_thread+0x4e> @ imm = #0x1a
 800d5ca: 6bfb         	ldr	r3, [r7, #0x3c]
 800d5cc: 63bb         	str	r3, [r7, #0x38]
 800d5ce: 6bbb         	ldr	r3, [r7, #0x38]
 800d5d0: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 800d5d2: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800d6b8 <unready_thread+0x120>
 800d5d4: 633b         	str	r3, [r7, #0x30]
 800d5d6: 6bbb         	ldr	r3, [r7, #0x38]
 800d5d8: 62fb         	str	r3, [r7, #0x2c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800d5da: 6afb         	ldr	r3, [r7, #0x2c]
 800d5dc: 4618         	mov	r0, r3
 800d5de: f00a fe47    	bl	0x8018270 <sys_dlist_remove> @ imm = #0xac8e
; }
 800d5e2: bf00         	nop
; }
 800d5e4: bf00         	nop
; }
 800d5e6: bf00         	nop
; 	update_cache(thread == _current);
 800d5e8: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x800d6bc <unready_thread+0x124>
 800d5ea: 689b         	ldr	r3, [r3, #0x8]
 800d5ec: 687a         	ldr	r2, [r7, #0x4]
 800d5ee: 429a         	cmp	r2, r3
 800d5f0: bf0c         	ite	eq
 800d5f2: 2301         	moveq	r3, #0x1
 800d5f4: 2300         	movne	r3, #0x0
 800d5f6: b2db         	uxtb	r3, r3
 800d5f8: 62bb         	str	r3, [r7, #0x28]
; 	return &_kernel.ready_q.runq;
 800d5fa: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800d6b8 <unready_thread+0x120>
 800d5fc: 627b         	str	r3, [r7, #0x24]
; 	struct k_thread *thread = NULL;
 800d5fe: 2300         	movs	r3, #0x0
 800d600: 623b         	str	r3, [r7, #0x20]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800d602: 6a78         	ldr	r0, [r7, #0x24]
 800d604: f00a fdca    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xab94
 800d608: 61f8         	str	r0, [r7, #0x1c]
; 	if (n != NULL) {
 800d60a: 69fb         	ldr	r3, [r7, #0x1c]
 800d60c: 2b00         	cmp	r3, #0x0
 800d60e: d001         	beq	0x800d614 <unready_thread+0x7c> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800d610: 69fb         	ldr	r3, [r7, #0x1c]
 800d612: 623b         	str	r3, [r7, #0x20]
; 	return thread;
 800d614: 6a3b         	ldr	r3, [r7, #0x20]
; 	return _priq_run_best(curr_cpu_runq());
 800d616: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800d618: 61bb         	str	r3, [r7, #0x18]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800d61a: 69bb         	ldr	r3, [r7, #0x18]
 800d61c: 2b00         	cmp	r3, #0x0
 800d61e: d102         	bne	0x800d626 <unready_thread+0x8e> @ imm = #0x4
 800d620: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800d6bc <unready_thread+0x124>
 800d622: 68db         	ldr	r3, [r3, #0xc]
 800d624: e000         	b	0x800d628 <unready_thread+0x90> @ imm = #0x0
 800d626: 69bb         	ldr	r3, [r7, #0x18]
; 	struct k_thread *thread = next_up();
 800d628: 617b         	str	r3, [r7, #0x14]
 800d62a: 697b         	ldr	r3, [r7, #0x14]
 800d62c: 613b         	str	r3, [r7, #0x10]
 800d62e: 6abb         	ldr	r3, [r7, #0x28]
 800d630: 60fb         	str	r3, [r7, #0xc]
; 	if (preempt_ok != 0) {
 800d632: 68fb         	ldr	r3, [r7, #0xc]
 800d634: 2b00         	cmp	r3, #0x0
 800d636: d001         	beq	0x800d63c <unready_thread+0xa4> @ imm = #0x2
; 		return true;
 800d638: 2301         	movs	r3, #0x1
 800d63a: e022         	b	0x800d682 <unready_thread+0xea> @ imm = #0x44
; 	if (z_is_thread_prevented_from_running(_current)) {
 800d63c: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800d6bc <unready_thread+0x124>
 800d63e: 689b         	ldr	r3, [r3, #0x8]
 800d640: 4618         	mov	r0, r3
 800d642: f00a fe7d    	bl	0x8018340 <z_is_thread_prevented_from_running> @ imm = #0xacfa
 800d646: 4603         	mov	r3, r0
 800d648: 2b00         	cmp	r3, #0x0
 800d64a: d001         	beq	0x800d650 <unready_thread+0xb8> @ imm = #0x2
; 		return true;
 800d64c: 2301         	movs	r3, #0x1
 800d64e: e018         	b	0x800d682 <unready_thread+0xea> @ imm = #0x30
; 	if (thread_is_preemptible(_current) || thread_is_metairq(thread)) {
 800d650: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800d6bc <unready_thread+0x124>
 800d652: 689b         	ldr	r3, [r3, #0x8]
 800d654: 4618         	mov	r0, r3
 800d656: f00a fe59    	bl	0x801830c <thread_is_preemptible> @ imm = #0xacb2
 800d65a: 4603         	mov	r3, r0
 800d65c: 2b00         	cmp	r3, #0x0
 800d65e: d105         	bne	0x800d66c <unready_thread+0xd4> @ imm = #0xa
 800d660: 6938         	ldr	r0, [r7, #0x10]
 800d662: f00a fe63    	bl	0x801832c <thread_is_metairq> @ imm = #0xacc6
 800d666: 4603         	mov	r3, r0
 800d668: 2b00         	cmp	r3, #0x0
 800d66a: d001         	beq	0x800d670 <unready_thread+0xd8> @ imm = #0x2
; 		return true;
 800d66c: 2301         	movs	r3, #0x1
 800d66e: e008         	b	0x800d682 <unready_thread+0xea> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800d670: 6938         	ldr	r0, [r7, #0x10]
 800d672: f00a fe79    	bl	0x8018368 <z_is_thread_timeout_active> @ imm = #0xacf2
 800d676: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800d678: 2b00         	cmp	r3, #0x0
 800d67a: d001         	beq	0x800d680 <unready_thread+0xe8> @ imm = #0x2
; 		return true;
 800d67c: 2301         	movs	r3, #0x1
 800d67e: e000         	b	0x800d682 <unready_thread+0xea> @ imm = #0x0
; 	return false;
 800d680: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800d682: 2b00         	cmp	r3, #0x0
 800d684: d00e         	beq	0x800d6a4 <unready_thread+0x10c> @ imm = #0x1c
; 		if (thread != _current) {
 800d686: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800d6bc <unready_thread+0x124>
 800d688: 689b         	ldr	r3, [r3, #0x8]
 800d68a: 697a         	ldr	r2, [r7, #0x14]
 800d68c: 429a         	cmp	r2, r3
 800d68e: d002         	beq	0x800d696 <unready_thread+0xfe> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800d690: 6978         	ldr	r0, [r7, #0x14]
 800d692: f000 ff99    	bl	0x800e5c8 <z_reset_time_slice> @ imm = #0xf32
; 		update_metairq_preempt(thread);
 800d696: 6978         	ldr	r0, [r7, #0x14]
 800d698: f00a fffd    	bl	0x8018696 <update_metairq_preempt> @ imm = #0xaffa
; 		_kernel.ready_q.cache = thread;
 800d69c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800d6bc <unready_thread+0x124>
 800d69e: 697b         	ldr	r3, [r7, #0x14]
 800d6a0: 61d3         	str	r3, [r2, #0x1c]
; }
 800d6a2: e003         	b	0x800d6ac <unready_thread+0x114> @ imm = #0x6
; 		_kernel.ready_q.cache = _current;
 800d6a4: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800d6bc <unready_thread+0x124>
 800d6a6: 689b         	ldr	r3, [r3, #0x8]
 800d6a8: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800d6bc <unready_thread+0x124>
 800d6aa: 61d3         	str	r3, [r2, #0x1c]
; }
 800d6ac: bf00         	nop
; }
 800d6ae: bf00         	nop
 800d6b0: 3740         	adds	r7, #0x40
 800d6b2: 46bd         	mov	sp, r7
 800d6b4: bd80         	pop	{r7, pc}
 800d6b6: bf00         	nop

0800d6b8 <$d>:
 800d6b8: e8 06 00 20  	.word	0x200006e8
 800d6bc: c8 06 00 20  	.word	0x200006c8

0800d6c0 <z_sched_wake_thread>:
; {
 800d6c0: b580         	push	{r7, lr}
 800d6c2: b090         	sub	sp, #0x40
 800d6c4: af00         	add	r7, sp, #0x0
 800d6c6: 6078         	str	r0, [r7, #0x4]
 800d6c8: 460b         	mov	r3, r1
 800d6ca: 70fb         	strb	r3, [r7, #0x3]
; 	K_SPINLOCK(&_sched_spinlock) {
 800d6cc: 2300         	movs	r3, #0x0
 800d6ce: 617b         	str	r3, [r7, #0x14]
 800d6d0: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x800d7c0 <z_sched_wake_thread+0x100>
 800d6d2: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d6d4: f3ef 8311    	mrs	r3, basepri
 800d6d8: 637b         	str	r3, [r7, #0x34]
;   return(result);
 800d6da: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 800d6dc: 633b         	str	r3, [r7, #0x30]
 800d6de: 2310         	movs	r3, #0x10
 800d6e0: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d6e2: 6afb         	ldr	r3, [r7, #0x2c]
 800d6e4: f383 8812    	msr	basepri_max, r3
; }
 800d6e8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d6ea: f3bf 8f6f    	isb	sy
; }
 800d6ee: bf00         	nop
; 	return key;
 800d6f0: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 800d6f2: 60bb         	str	r3, [r7, #0x8]
 800d6f4: 6bbb         	ldr	r3, [r7, #0x38]
 800d6f6: 62bb         	str	r3, [r7, #0x28]
; }
 800d6f8: bf00         	nop
 800d6fa: 6bbb         	ldr	r3, [r7, #0x38]
 800d6fc: 627b         	str	r3, [r7, #0x24]
; }
 800d6fe: bf00         	nop
; 	return k;
 800d700: 68bb         	ldr	r3, [r7, #0x8]
 800d702: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 800d704: e053         	b	0x800d7ae <z_sched_wake_thread+0xee> @ imm = #0xa6
; 		bool killed = (thread->base.thread_state &
 800d706: 687b         	ldr	r3, [r7, #0x4]
 800d708: 7b5b         	ldrb	r3, [r3, #0xd]
 800d70a: f003 0328    	and	r3, r3, #0x28
 800d70e: 2b00         	cmp	r3, #0x0
 800d710: bf14         	ite	ne
 800d712: 2301         	movne	r3, #0x1
 800d714: 2300         	moveq	r3, #0x0
 800d716: f887 303f    	strb.w	r3, [r7, #0x3f]
; 		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
 800d71a: 687b         	ldr	r3, [r7, #0x4]
 800d71c: f893 307c    	ldrb.w	r3, [r3, #0x7c]
 800d720: 2b00         	cmp	r3, #0x0
 800d722: d004         	beq	0x800d72e <z_sched_wake_thread+0x6e> @ imm = #0x8
 800d724: 78fb         	ldrb	r3, [r7, #0x3]
 800d726: 2b00         	cmp	r3, #0x0
 800d728: d001         	beq	0x800d72e <z_sched_wake_thread+0x6e> @ imm = #0x2
 800d72a: 2301         	movs	r3, #0x1
 800d72c: e000         	b	0x800d730 <z_sched_wake_thread+0x70> @ imm = #0x0
 800d72e: 2300         	movs	r3, #0x0
 800d730: f887 303e    	strb.w	r3, [r7, #0x3e]
 800d734: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 800d738: f003 0301    	and	r3, r3, #0x1
 800d73c: f887 303e    	strb.w	r3, [r7, #0x3e]
; 		thread->no_wake_on_timeout = false;
 800d740: 687b         	ldr	r3, [r7, #0x4]
 800d742: 2200         	movs	r2, #0x0
 800d744: f883 207c    	strb.w	r2, [r3, #0x7c]
; 		if (do_nothing) {
 800d748: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 800d74c: 2b00         	cmp	r3, #0x0
 800d74e: d11a         	bne	0x800d786 <z_sched_wake_thread+0xc6> @ imm = #0x34
; 		if (!killed) {
 800d750: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800d754: f083 0301    	eor	r3, r3, #0x1
 800d758: b2db         	uxtb	r3, r3
 800d75a: 2b00         	cmp	r3, #0x0
 800d75c: d014         	beq	0x800d788 <z_sched_wake_thread+0xc8> @ imm = #0x28
; 			if (thread->base.pended_on != NULL) {
 800d75e: 687b         	ldr	r3, [r7, #0x4]
 800d760: 689b         	ldr	r3, [r3, #0x8]
 800d762: 2b00         	cmp	r3, #0x0
 800d764: d002         	beq	0x800d76c <z_sched_wake_thread+0xac> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 800d766: 6878         	ldr	r0, [r7, #0x4]
 800d768: f00a fee5    	bl	0x8018536 <unpend_thread_no_timeout> @ imm = #0xadca
; 			z_mark_thread_as_started(thread);
 800d76c: 6878         	ldr	r0, [r7, #0x4]
 800d76e: f00a fe87    	bl	0x8018480 <z_mark_thread_as_started> @ imm = #0xad0e
; 			if (is_timeout) {
 800d772: 78fb         	ldrb	r3, [r7, #0x3]
 800d774: 2b00         	cmp	r3, #0x0
 800d776: d002         	beq	0x800d77e <z_sched_wake_thread+0xbe> @ imm = #0x4
; 				z_mark_thread_as_not_suspended(thread);
 800d778: 6878         	ldr	r0, [r7, #0x4]
 800d77a: f00a fe71    	bl	0x8018460 <z_mark_thread_as_not_suspended> @ imm = #0xace2
; 			ready_thread(thread);
 800d77e: 6878         	ldr	r0, [r7, #0x4]
 800d780: f7ff fc90    	bl	0x800d0a4 <ready_thread> @ imm = #-0x6e0
 800d784: e000         	b	0x800d788 <z_sched_wake_thread+0xc8> @ imm = #0x0
; 			continue;
 800d786: bf00         	nop
 800d788: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800d7c0 <z_sched_wake_thread+0x100>
 800d78a: 623b         	str	r3, [r7, #0x20]
 800d78c: 693b         	ldr	r3, [r7, #0x10]
 800d78e: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800d790: 68fb         	ldr	r3, [r7, #0xc]
 800d792: 61fb         	str	r3, [r7, #0x1c]
 800d794: 69fb         	ldr	r3, [r7, #0x1c]
 800d796: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d798: 69bb         	ldr	r3, [r7, #0x18]
 800d79a: f383 8811    	msr	basepri, r3
; }
 800d79e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d7a0: f3bf 8f6f    	isb	sy
; }
 800d7a4: bf00         	nop
; }
 800d7a6: bf00         	nop
; }
 800d7a8: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800d7aa: 2301         	movs	r3, #0x1
 800d7ac: 617b         	str	r3, [r7, #0x14]
 800d7ae: 697b         	ldr	r3, [r7, #0x14]
 800d7b0: 2b00         	cmp	r3, #0x0
 800d7b2: d0a8         	beq	0x800d706 <z_sched_wake_thread+0x46> @ imm = #-0xb0
; }
 800d7b4: bf00         	nop
 800d7b6: bf00         	nop
 800d7b8: 3740         	adds	r7, #0x40
 800d7ba: 46bd         	mov	sp, r7
 800d7bc: bd80         	pop	{r7, pc}
 800d7be: bf00         	nop

0800d7c0 <$d>:
 800d7c0: e8 10 00 20  	.word	0x200010e8

0800d7c4 <z_pend_curr>:
; {
 800d7c4: b580         	push	{r7, lr}
 800d7c6: b090         	sub	sp, #0x40
 800d7c8: af00         	add	r7, sp, #0x0
 800d7ca: 60f8         	str	r0, [r7, #0xc]
 800d7cc: 60b9         	str	r1, [r7, #0x8]
 800d7ce: 607a         	str	r2, [r7, #0x4]
; 	pending_current = _current;
 800d7d0: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800d83c <z_pend_curr+0x78>
 800d7d2: 689b         	ldr	r3, [r3, #0x8]
 800d7d4: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x800d840 <z_pend_curr+0x7c>
 800d7d6: 6013         	str	r3, [r2]
 800d7d8: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800d844 <z_pend_curr+0x80>
 800d7da: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d7dc: f3ef 8311    	mrs	r3, basepri
 800d7e0: 62fb         	str	r3, [r7, #0x2c]
;   return(result);
 800d7e2: 6afb         	ldr	r3, [r7, #0x2c]
; 	key = __get_BASEPRI();
 800d7e4: 62bb         	str	r3, [r7, #0x28]
 800d7e6: 2310         	movs	r3, #0x10
 800d7e8: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d7ea: 6a7b         	ldr	r3, [r7, #0x24]
 800d7ec: f383 8812    	msr	basepri_max, r3
; }
 800d7f0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d7f2: f3bf 8f6f    	isb	sy
; }
 800d7f6: bf00         	nop
; 	return key;
 800d7f8: 6abb         	ldr	r3, [r7, #0x28]
; 	k.key = arch_irq_lock();
 800d7fa: 61bb         	str	r3, [r7, #0x18]
 800d7fc: 6b3b         	ldr	r3, [r7, #0x30]
 800d7fe: 623b         	str	r3, [r7, #0x20]
; }
 800d800: bf00         	nop
 800d802: 6b3b         	ldr	r3, [r7, #0x30]
 800d804: 61fb         	str	r3, [r7, #0x1c]
; }
 800d806: bf00         	nop
; 	pend_locked(_current, wait_q, timeout);
 800d808: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800d83c <z_pend_curr+0x78>
 800d80a: 6898         	ldr	r0, [r3, #0x8]
 800d80c: e9d7 2312    	ldrd	r2, r3, [r7, #72]
 800d810: 6879         	ldr	r1, [r7, #0x4]
 800d812: f00a ffc0    	bl	0x8018796 <pend_locked> @ imm = #0xaf80
 800d816: 68fb         	ldr	r3, [r7, #0xc]
 800d818: 637b         	str	r3, [r7, #0x34]
; }
 800d81a: bf00         	nop
 800d81c: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800d844 <z_pend_curr+0x80>
 800d81e: 63fb         	str	r3, [r7, #0x3c]
 800d820: 68bb         	ldr	r3, [r7, #0x8]
 800d822: 617b         	str	r3, [r7, #0x14]
 800d824: 6bfb         	ldr	r3, [r7, #0x3c]
 800d826: 63bb         	str	r3, [r7, #0x38]
 800d828: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800d82a: 697b         	ldr	r3, [r7, #0x14]
 800d82c: 4618         	mov	r0, r3
 800d82e: f00a fea9    	bl	0x8018584 <z_swap_irqlock> @ imm = #0xad52
 800d832: 4603         	mov	r3, r0
; }
 800d834: 4618         	mov	r0, r3
 800d836: 3740         	adds	r7, #0x40
 800d838: 46bd         	mov	sp, r7
 800d83a: bd80         	pop	{r7, pc}

0800d83c <$d>:
 800d83c: c8 06 00 20  	.word	0x200006c8
 800d840: f4 10 00 20  	.word	0x200010f4
 800d844: e8 10 00 20  	.word	0x200010e8

0800d848 <z_thread_prio_set>:
; {
 800d848: b580         	push	{r7, lr}
 800d84a: b0a4         	sub	sp, #0x90
 800d84c: af00         	add	r7, sp, #0x0
 800d84e: 6078         	str	r0, [r7, #0x4]
 800d850: 6039         	str	r1, [r7]
; 	bool need_sched = 0;
 800d852: 2300         	movs	r3, #0x0
 800d854: f887 308f    	strb.w	r3, [r7, #0x8f]
; 	int old_prio = thread->base.prio;
 800d858: 687b         	ldr	r3, [r7, #0x4]
 800d85a: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800d85e: f8c7 3088    	str.w	r3, [r7, #0x88]
; 	K_SPINLOCK(&_sched_spinlock) {
 800d862: 2300         	movs	r3, #0x0
 800d864: 617b         	str	r3, [r7, #0x14]
 800d866: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x800daa0 <z_thread_prio_set+0x258>
 800d868: f8c7 3084    	str.w	r3, [r7, #0x84]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d86c: f3ef 8311    	mrs	r3, basepri
 800d870: f8c7 3080    	str.w	r3, [r7, #0x80]
;   return(result);
 800d874: f8d7 3080    	ldr.w	r3, [r7, #0x80]
; 	key = __get_BASEPRI();
 800d878: 67fb         	str	r3, [r7, #0x7c]
 800d87a: 2310         	movs	r3, #0x10
 800d87c: 67bb         	str	r3, [r7, #0x78]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800d87e: 6fbb         	ldr	r3, [r7, #0x78]
 800d880: f383 8812    	msr	basepri_max, r3
; }
 800d884: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800d886: f3bf 8f6f    	isb	sy
; }
 800d88a: bf00         	nop
; 	return key;
 800d88c: 6ffb         	ldr	r3, [r7, #0x7c]
; 	k.key = arch_irq_lock();
 800d88e: 60bb         	str	r3, [r7, #0x8]
 800d890: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800d894: 677b         	str	r3, [r7, #0x74]
; }
 800d896: bf00         	nop
 800d898: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800d89c: 673b         	str	r3, [r7, #0x70]
; }
 800d89e: bf00         	nop
; 	return k;
 800d8a0: 68bb         	ldr	r3, [r7, #0x8]
 800d8a2: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 800d8a4: e0f2         	b	0x800da8c <z_thread_prio_set+0x244> @ imm = #0x1e4
; 		need_sched = z_is_thread_ready(thread);
 800d8a6: 6878         	ldr	r0, [r7, #0x4]
 800d8a8: f00a fd77    	bl	0x801839a <z_is_thread_ready> @ imm = #0xaaee
 800d8ac: 4603         	mov	r3, r0
 800d8ae: f887 308f    	strb.w	r3, [r7, #0x8f]
; 		if (need_sched) {
 800d8b2: f897 308f    	ldrb.w	r3, [r7, #0x8f]
 800d8b6: 2b00         	cmp	r3, #0x0
 800d8b8: f000 80d1    	beq.w	0x800da5e <z_thread_prio_set+0x216> @ imm = #0x1a2
 800d8bc: 687b         	ldr	r3, [r7, #0x4]
 800d8be: 657b         	str	r3, [r7, #0x54]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800d8c0: 6d7b         	ldr	r3, [r7, #0x54]
 800d8c2: 7b5b         	ldrb	r3, [r3, #0xd]
 800d8c4: f003 037f    	and	r3, r3, #0x7f
 800d8c8: b2da         	uxtb	r2, r3
 800d8ca: 6d7b         	ldr	r3, [r7, #0x54]
 800d8cc: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800d8ce: 6d78         	ldr	r0, [r7, #0x54]
 800d8d0: f00a fe9e    	bl	0x8018610 <should_queue_thread> @ imm = #0xad3c
 800d8d4: 4603         	mov	r3, r0
 800d8d6: 2b00         	cmp	r3, #0x0
 800d8d8: d00d         	beq	0x800d8f6 <z_thread_prio_set+0xae> @ imm = #0x1a
 800d8da: 6d7b         	ldr	r3, [r7, #0x54]
 800d8dc: 653b         	str	r3, [r7, #0x50]
 800d8de: 6d3b         	ldr	r3, [r7, #0x50]
 800d8e0: 64fb         	str	r3, [r7, #0x4c]
; 	return &_kernel.ready_q.runq;
 800d8e2: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x800daa4 <z_thread_prio_set+0x25c>
 800d8e4: 64bb         	str	r3, [r7, #0x48]
 800d8e6: 6d3b         	ldr	r3, [r7, #0x50]
 800d8e8: 647b         	str	r3, [r7, #0x44]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800d8ea: 6c7b         	ldr	r3, [r7, #0x44]
 800d8ec: 4618         	mov	r0, r3
 800d8ee: f00a fcbf    	bl	0x8018270 <sys_dlist_remove> @ imm = #0xa97e
; }
 800d8f2: bf00         	nop
; }
 800d8f4: bf00         	nop
; }
 800d8f6: bf00         	nop
; 				thread->base.prio = prio;
 800d8f8: 683b         	ldr	r3, [r7]
 800d8fa: b25a         	sxtb	r2, r3
 800d8fc: 687b         	ldr	r3, [r7, #0x4]
 800d8fe: 739a         	strb	r2, [r3, #0xe]
 800d900: 687b         	ldr	r3, [r7, #0x4]
 800d902: 66fb         	str	r3, [r7, #0x6c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800d904: 6efb         	ldr	r3, [r7, #0x6c]
 800d906: 7b5b         	ldrb	r3, [r3, #0xd]
 800d908: f063 037f    	orn	r3, r3, #0x7f
 800d90c: b2da         	uxtb	r2, r3
 800d90e: 6efb         	ldr	r3, [r7, #0x6c]
 800d910: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800d912: 6ef8         	ldr	r0, [r7, #0x6c]
 800d914: f00a fe7c    	bl	0x8018610 <should_queue_thread> @ imm = #0xacf8
 800d918: 4603         	mov	r3, r0
 800d91a: 2b00         	cmp	r3, #0x0
 800d91c: d042         	beq	0x800d9a4 <z_thread_prio_set+0x15c> @ imm = #0x84
 800d91e: 6efb         	ldr	r3, [r7, #0x6c]
 800d920: 66bb         	str	r3, [r7, #0x68]
 800d922: 6ebb         	ldr	r3, [r7, #0x68]
 800d924: 667b         	str	r3, [r7, #0x64]
; 	return &_kernel.ready_q.runq;
 800d926: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x800daa4 <z_thread_prio_set+0x25c>
 800d928: 663b         	str	r3, [r7, #0x60]
 800d92a: 6ebb         	ldr	r3, [r7, #0x68]
 800d92c: 65fb         	str	r3, [r7, #0x5c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800d92e: 6e38         	ldr	r0, [r7, #0x60]
 800d930: f00a fc34    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xa868
 800d934: 4603         	mov	r3, r0
 800d936: 2b00         	cmp	r3, #0x0
 800d938: d004         	beq	0x800d944 <z_thread_prio_set+0xfc> @ imm = #0x8
 800d93a: 6e38         	ldr	r0, [r7, #0x60]
 800d93c: f00a fc2e    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xa85c
 800d940: 4603         	mov	r3, r0
 800d942: e000         	b	0x800d946 <z_thread_prio_set+0xfe> @ imm = #0x0
 800d944: 2300         	movs	r3, #0x0
 800d946: 65bb         	str	r3, [r7, #0x58]
 800d948: e023         	b	0x800d992 <z_thread_prio_set+0x14a> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800d94a: 6db9         	ldr	r1, [r7, #0x58]
 800d94c: 6df8         	ldr	r0, [r7, #0x5c]
 800d94e: f00a fe44    	bl	0x80185da <z_sched_prio_cmp> @ imm = #0xac88
 800d952: 4603         	mov	r3, r0
 800d954: 2b00         	cmp	r3, #0x0
 800d956: dd06         	ble	0x800d966 <z_thread_prio_set+0x11e> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800d958: 6dbb         	ldr	r3, [r7, #0x58]
 800d95a: 6dfa         	ldr	r2, [r7, #0x5c]
 800d95c: 4611         	mov	r1, r2
 800d95e: 4618         	mov	r0, r3
 800d960: f00a fc6d    	bl	0x801823e <sys_dlist_insert> @ imm = #0xa8da
; 			return;
 800d964: e01d         	b	0x800d9a2 <z_thread_prio_set+0x15a> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800d966: 6dbb         	ldr	r3, [r7, #0x58]
 800d968: 2b00         	cmp	r3, #0x0
 800d96a: d010         	beq	0x800d98e <z_thread_prio_set+0x146> @ imm = #0x20
 800d96c: 6dbb         	ldr	r3, [r7, #0x58]
 800d96e: 4619         	mov	r1, r3
 800d970: 6e38         	ldr	r0, [r7, #0x60]
 800d972: f00a fc38    	bl	0x80181e6 <sys_dlist_peek_next> @ imm = #0xa870
 800d976: 4603         	mov	r3, r0
 800d978: 2b00         	cmp	r3, #0x0
 800d97a: d006         	beq	0x800d98a <z_thread_prio_set+0x142> @ imm = #0xc
 800d97c: 6dbb         	ldr	r3, [r7, #0x58]
 800d97e: 4619         	mov	r1, r3
 800d980: 6e38         	ldr	r0, [r7, #0x60]
 800d982: f00a fc30    	bl	0x80181e6 <sys_dlist_peek_next> @ imm = #0xa860
 800d986: 4603         	mov	r3, r0
 800d988: e002         	b	0x800d990 <z_thread_prio_set+0x148> @ imm = #0x4
 800d98a: 2300         	movs	r3, #0x0
 800d98c: e000         	b	0x800d990 <z_thread_prio_set+0x148> @ imm = #0x0
 800d98e: 2300         	movs	r3, #0x0
 800d990: 65bb         	str	r3, [r7, #0x58]
 800d992: 6dbb         	ldr	r3, [r7, #0x58]
 800d994: 2b00         	cmp	r3, #0x0
 800d996: d1d8         	bne	0x800d94a <z_thread_prio_set+0x102> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800d998: 6dfb         	ldr	r3, [r7, #0x5c]
 800d99a: 4619         	mov	r1, r3
 800d99c: 6e38         	ldr	r0, [r7, #0x60]
 800d99e: f00a fc35    	bl	0x801820c <sys_dlist_append> @ imm = #0xa86a
; }
 800d9a2: bf00         	nop
; }
 800d9a4: bf00         	nop
 800d9a6: 2301         	movs	r3, #0x1
 800d9a8: 643b         	str	r3, [r7, #0x40]
; 	return &_kernel.ready_q.runq;
 800d9aa: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800daa4 <z_thread_prio_set+0x25c>
 800d9ac: 63fb         	str	r3, [r7, #0x3c]
; 	struct k_thread *thread = NULL;
 800d9ae: 2300         	movs	r3, #0x0
 800d9b0: 63bb         	str	r3, [r7, #0x38]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800d9b2: 6bf8         	ldr	r0, [r7, #0x3c]
 800d9b4: f00a fbf2    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xa7e4
 800d9b8: 6378         	str	r0, [r7, #0x34]
; 	if (n != NULL) {
 800d9ba: 6b7b         	ldr	r3, [r7, #0x34]
 800d9bc: 2b00         	cmp	r3, #0x0
 800d9be: d001         	beq	0x800d9c4 <z_thread_prio_set+0x17c> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800d9c0: 6b7b         	ldr	r3, [r7, #0x34]
 800d9c2: 63bb         	str	r3, [r7, #0x38]
; 	return thread;
 800d9c4: 6bbb         	ldr	r3, [r7, #0x38]
; 	return _priq_run_best(curr_cpu_runq());
 800d9c6: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800d9c8: 633b         	str	r3, [r7, #0x30]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800d9ca: 6b3b         	ldr	r3, [r7, #0x30]
 800d9cc: 2b00         	cmp	r3, #0x0
 800d9ce: d102         	bne	0x800d9d6 <z_thread_prio_set+0x18e> @ imm = #0x4
 800d9d0: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800daa8 <z_thread_prio_set+0x260>
 800d9d2: 68db         	ldr	r3, [r3, #0xc]
 800d9d4: e000         	b	0x800d9d8 <z_thread_prio_set+0x190> @ imm = #0x0
 800d9d6: 6b3b         	ldr	r3, [r7, #0x30]
; 	struct k_thread *thread = next_up();
 800d9d8: 62fb         	str	r3, [r7, #0x2c]
 800d9da: 6afb         	ldr	r3, [r7, #0x2c]
 800d9dc: 62bb         	str	r3, [r7, #0x28]
 800d9de: 6c3b         	ldr	r3, [r7, #0x40]
 800d9e0: 627b         	str	r3, [r7, #0x24]
; 	if (preempt_ok != 0) {
 800d9e2: 6a7b         	ldr	r3, [r7, #0x24]
 800d9e4: 2b00         	cmp	r3, #0x0
 800d9e6: d001         	beq	0x800d9ec <z_thread_prio_set+0x1a4> @ imm = #0x2
; 		return true;
 800d9e8: 2301         	movs	r3, #0x1
 800d9ea: e022         	b	0x800da32 <z_thread_prio_set+0x1ea> @ imm = #0x44
; 	if (z_is_thread_prevented_from_running(_current)) {
 800d9ec: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x800daa8 <z_thread_prio_set+0x260>
 800d9ee: 689b         	ldr	r3, [r3, #0x8]
 800d9f0: 4618         	mov	r0, r3
 800d9f2: f00a fca5    	bl	0x8018340 <z_is_thread_prevented_from_running> @ imm = #0xa94a
 800d9f6: 4603         	mov	r3, r0
 800d9f8: 2b00         	cmp	r3, #0x0
 800d9fa: d001         	beq	0x800da00 <z_thread_prio_set+0x1b8> @ imm = #0x2
; 		return true;
 800d9fc: 2301         	movs	r3, #0x1
 800d9fe: e018         	b	0x800da32 <z_thread_prio_set+0x1ea> @ imm = #0x30
; 	if (thread_is_preemptible(_current) || thread_is_metairq(thread)) {
 800da00: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800daa8 <z_thread_prio_set+0x260>
 800da02: 689b         	ldr	r3, [r3, #0x8]
 800da04: 4618         	mov	r0, r3
 800da06: f00a fc81    	bl	0x801830c <thread_is_preemptible> @ imm = #0xa902
 800da0a: 4603         	mov	r3, r0
 800da0c: 2b00         	cmp	r3, #0x0
 800da0e: d105         	bne	0x800da1c <z_thread_prio_set+0x1d4> @ imm = #0xa
 800da10: 6ab8         	ldr	r0, [r7, #0x28]
 800da12: f00a fc8b    	bl	0x801832c <thread_is_metairq> @ imm = #0xa916
 800da16: 4603         	mov	r3, r0
 800da18: 2b00         	cmp	r3, #0x0
 800da1a: d001         	beq	0x800da20 <z_thread_prio_set+0x1d8> @ imm = #0x2
; 		return true;
 800da1c: 2301         	movs	r3, #0x1
 800da1e: e008         	b	0x800da32 <z_thread_prio_set+0x1ea> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800da20: 6ab8         	ldr	r0, [r7, #0x28]
 800da22: f00a fca1    	bl	0x8018368 <z_is_thread_timeout_active> @ imm = #0xa942
 800da26: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800da28: 2b00         	cmp	r3, #0x0
 800da2a: d001         	beq	0x800da30 <z_thread_prio_set+0x1e8> @ imm = #0x2
; 		return true;
 800da2c: 2301         	movs	r3, #0x1
 800da2e: e000         	b	0x800da32 <z_thread_prio_set+0x1ea> @ imm = #0x0
; 	return false;
 800da30: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800da32: 2b00         	cmp	r3, #0x0
 800da34: d00e         	beq	0x800da54 <z_thread_prio_set+0x20c> @ imm = #0x1c
; 		if (thread != _current) {
 800da36: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800daa8 <z_thread_prio_set+0x260>
 800da38: 689b         	ldr	r3, [r3, #0x8]
 800da3a: 6afa         	ldr	r2, [r7, #0x2c]
 800da3c: 429a         	cmp	r2, r3
 800da3e: d002         	beq	0x800da46 <z_thread_prio_set+0x1fe> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800da40: 6af8         	ldr	r0, [r7, #0x2c]
 800da42: f000 fdc1    	bl	0x800e5c8 <z_reset_time_slice> @ imm = #0xb82
; 		update_metairq_preempt(thread);
 800da46: 6af8         	ldr	r0, [r7, #0x2c]
 800da48: f00a fe25    	bl	0x8018696 <update_metairq_preempt> @ imm = #0xac4a
; 		_kernel.ready_q.cache = thread;
 800da4c: 4a16         	ldr	r2, [pc, #0x58]         @ 0x800daa8 <z_thread_prio_set+0x260>
 800da4e: 6afb         	ldr	r3, [r7, #0x2c]
 800da50: 61d3         	str	r3, [r2, #0x1c]
; }
 800da52: e008         	b	0x800da66 <z_thread_prio_set+0x21e> @ imm = #0x10
; 		_kernel.ready_q.cache = _current;
 800da54: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800daa8 <z_thread_prio_set+0x260>
 800da56: 689b         	ldr	r3, [r3, #0x8]
 800da58: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800daa8 <z_thread_prio_set+0x260>
 800da5a: 61d3         	str	r3, [r2, #0x1c]
; }
 800da5c: e003         	b	0x800da66 <z_thread_prio_set+0x21e> @ imm = #0x6
; 			thread->base.prio = prio;
 800da5e: 683b         	ldr	r3, [r7]
 800da60: b25a         	sxtb	r2, r3
 800da62: 687b         	ldr	r3, [r7, #0x4]
 800da64: 739a         	strb	r2, [r3, #0xe]
 800da66: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800daa0 <z_thread_prio_set+0x258>
 800da68: 623b         	str	r3, [r7, #0x20]
 800da6a: 693b         	ldr	r3, [r7, #0x10]
 800da6c: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800da6e: 68fb         	ldr	r3, [r7, #0xc]
 800da70: 61fb         	str	r3, [r7, #0x1c]
 800da72: 69fb         	ldr	r3, [r7, #0x1c]
 800da74: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800da76: 69bb         	ldr	r3, [r7, #0x18]
 800da78: f383 8811    	msr	basepri, r3
; }
 800da7c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800da7e: f3bf 8f6f    	isb	sy
; }
 800da82: bf00         	nop
; }
 800da84: bf00         	nop
; }
 800da86: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800da88: 2301         	movs	r3, #0x1
 800da8a: 617b         	str	r3, [r7, #0x14]
 800da8c: 697b         	ldr	r3, [r7, #0x14]
 800da8e: 2b00         	cmp	r3, #0x0
 800da90: f43f af09    	beq.w	0x800d8a6 <z_thread_prio_set+0x5e> @ imm = #-0x1ee
; 	return need_sched;
 800da94: f897 308f    	ldrb.w	r3, [r7, #0x8f]
; }
 800da98: 4618         	mov	r0, r3
 800da9a: 3790         	adds	r7, #0x90
 800da9c: 46bd         	mov	sp, r7
 800da9e: bd80         	pop	{r7, pc}

0800daa0 <$d>:
 800daa0: e8 10 00 20  	.word	0x200010e8
 800daa4: e8 06 00 20  	.word	0x200006e8
 800daa8: c8 06 00 20  	.word	0x200006c8

0800daac <need_swap>:
; {
 800daac: b480         	push	{r7}
 800daae: b083         	sub	sp, #0xc
 800dab0: af00         	add	r7, sp, #0x0
; 	new_thread = _kernel.ready_q.cache;
 800dab2: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800dad4 <need_swap+0x28>
 800dab4: 69db         	ldr	r3, [r3, #0x1c]
 800dab6: 607b         	str	r3, [r7, #0x4]
; 	return new_thread != _current;
 800dab8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800dad4 <need_swap+0x28>
 800daba: 689b         	ldr	r3, [r3, #0x8]
 800dabc: 687a         	ldr	r2, [r7, #0x4]
 800dabe: 429a         	cmp	r2, r3
 800dac0: bf14         	ite	ne
 800dac2: 2301         	movne	r3, #0x1
 800dac4: 2300         	moveq	r3, #0x0
 800dac6: b2db         	uxtb	r3, r3
; }
 800dac8: 4618         	mov	r0, r3
 800daca: 370c         	adds	r7, #0xc
 800dacc: 46bd         	mov	sp, r7
 800dace: bc80         	pop	{r7}
 800dad0: 4770         	bx	lr
 800dad2: bf00         	nop

0800dad4 <$d>:
 800dad4: c8 06 00 20  	.word	0x200006c8

0800dad8 <k_sched_lock>:
; {
 800dad8: b580         	push	{r7, lr}
 800dada: b08e         	sub	sp, #0x38
 800dadc: af00         	add	r7, sp, #0x0
; 	K_SPINLOCK(&_sched_spinlock) {
 800dade: 2300         	movs	r3, #0x0
 800dae0: 613b         	str	r3, [r7, #0x10]
 800dae2: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800db54 <k_sched_lock+0x7c>
 800dae4: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800dae6: f3ef 8311    	mrs	r3, basepri
 800daea: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800daec: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800daee: 62fb         	str	r3, [r7, #0x2c]
 800daf0: 2310         	movs	r3, #0x10
 800daf2: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800daf4: 6abb         	ldr	r3, [r7, #0x28]
 800daf6: f383 8812    	msr	basepri_max, r3
; }
 800dafa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800dafc: f3bf 8f6f    	isb	sy
; }
 800db00: bf00         	nop
; 	return key;
 800db02: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800db04: 607b         	str	r3, [r7, #0x4]
 800db06: 6b7b         	ldr	r3, [r7, #0x34]
 800db08: 627b         	str	r3, [r7, #0x24]
; }
 800db0a: bf00         	nop
 800db0c: 6b7b         	ldr	r3, [r7, #0x34]
 800db0e: 623b         	str	r3, [r7, #0x20]
; }
 800db10: bf00         	nop
; 	return k;
 800db12: 687b         	ldr	r3, [r7, #0x4]
 800db14: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&_sched_spinlock) {
 800db16: e014         	b	0x800db42 <k_sched_lock+0x6a> @ imm = #0x28
; 		z_sched_lock();
 800db18: f7ff f9b0    	bl	0x800ce7c <z_sched_lock> @ imm = #-0xca0
 800db1c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800db54 <k_sched_lock+0x7c>
 800db1e: 61fb         	str	r3, [r7, #0x1c]
 800db20: 68fb         	ldr	r3, [r7, #0xc]
 800db22: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800db24: 68bb         	ldr	r3, [r7, #0x8]
 800db26: 61bb         	str	r3, [r7, #0x18]
 800db28: 69bb         	ldr	r3, [r7, #0x18]
 800db2a: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800db2c: 697b         	ldr	r3, [r7, #0x14]
 800db2e: f383 8811    	msr	basepri, r3
; }
 800db32: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800db34: f3bf 8f6f    	isb	sy
; }
 800db38: bf00         	nop
; }
 800db3a: bf00         	nop
; }
 800db3c: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800db3e: 2301         	movs	r3, #0x1
 800db40: 613b         	str	r3, [r7, #0x10]
 800db42: 693b         	ldr	r3, [r7, #0x10]
 800db44: 2b00         	cmp	r3, #0x0
 800db46: d0e7         	beq	0x800db18 <k_sched_lock+0x40> @ imm = #-0x32
; }
 800db48: bf00         	nop
 800db4a: bf00         	nop
 800db4c: 3738         	adds	r7, #0x38
 800db4e: 46bd         	mov	sp, r7
 800db50: bd80         	pop	{r7, pc}
 800db52: bf00         	nop

0800db54 <$d>:
 800db54: e8 10 00 20  	.word	0x200010e8

0800db58 <k_sched_unlock>:
; {
 800db58: b580         	push	{r7, lr}
 800db5a: b09e         	sub	sp, #0x78
 800db5c: af06         	add	r7, sp, #0x18
; 	K_SPINLOCK(&_sched_spinlock) {
 800db5e: 2300         	movs	r3, #0x0
 800db60: 613b         	str	r3, [r7, #0x10]
 800db62: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x800dce0 <k_sched_unlock+0x188>
 800db64: 657b         	str	r3, [r7, #0x54]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800db66: f3ef 8311    	mrs	r3, basepri
 800db6a: 653b         	str	r3, [r7, #0x50]
;   return(result);
 800db6c: 6d3b         	ldr	r3, [r7, #0x50]
; 	key = __get_BASEPRI();
 800db6e: 64fb         	str	r3, [r7, #0x4c]
 800db70: 2310         	movs	r3, #0x10
 800db72: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800db74: 6cbb         	ldr	r3, [r7, #0x48]
 800db76: f383 8812    	msr	basepri_max, r3
; }
 800db7a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800db7c: f3bf 8f6f    	isb	sy
; }
 800db80: bf00         	nop
; 	return key;
 800db82: 6cfb         	ldr	r3, [r7, #0x4c]
; 	k.key = arch_irq_lock();
 800db84: 607b         	str	r3, [r7, #0x4]
 800db86: 6d7b         	ldr	r3, [r7, #0x54]
 800db88: 647b         	str	r3, [r7, #0x44]
; }
 800db8a: bf00         	nop
 800db8c: 6d7b         	ldr	r3, [r7, #0x54]
 800db8e: 643b         	str	r3, [r7, #0x40]
; }
 800db90: bf00         	nop
; 	return k;
 800db92: 687b         	ldr	r3, [r7, #0x4]
 800db94: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&_sched_spinlock) {
 800db96: e074         	b	0x800dc82 <k_sched_unlock+0x12a> @ imm = #0xe8
; 		++_current->base.sched_locked;
 800db98: 4b52         	ldr	r3, [pc, #0x148]        @ 0x800dce4 <k_sched_unlock+0x18c>
 800db9a: 689b         	ldr	r3, [r3, #0x8]
 800db9c: 7bda         	ldrb	r2, [r3, #0xf]
 800db9e: 3201         	adds	r2, #0x1
 800dba0: b2d2         	uxtb	r2, r2
 800dba2: 73da         	strb	r2, [r3, #0xf]
 800dba4: 2300         	movs	r3, #0x0
 800dba6: 633b         	str	r3, [r7, #0x30]
; 	return &_kernel.ready_q.runq;
 800dba8: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x800dce8 <k_sched_unlock+0x190>
 800dbaa: 62fb         	str	r3, [r7, #0x2c]
; 	struct k_thread *thread = NULL;
 800dbac: 2300         	movs	r3, #0x0
 800dbae: 62bb         	str	r3, [r7, #0x28]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800dbb0: 6af8         	ldr	r0, [r7, #0x2c]
 800dbb2: f00a faf3    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xa5e6
 800dbb6: 6278         	str	r0, [r7, #0x24]
; 	if (n != NULL) {
 800dbb8: 6a7b         	ldr	r3, [r7, #0x24]
 800dbba: 2b00         	cmp	r3, #0x0
 800dbbc: d001         	beq	0x800dbc2 <k_sched_unlock+0x6a> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800dbbe: 6a7b         	ldr	r3, [r7, #0x24]
 800dbc0: 62bb         	str	r3, [r7, #0x28]
; 	return thread;
 800dbc2: 6abb         	ldr	r3, [r7, #0x28]
; 	return _priq_run_best(curr_cpu_runq());
 800dbc4: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800dbc6: 623b         	str	r3, [r7, #0x20]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800dbc8: 6a3b         	ldr	r3, [r7, #0x20]
 800dbca: 2b00         	cmp	r3, #0x0
 800dbcc: d102         	bne	0x800dbd4 <k_sched_unlock+0x7c> @ imm = #0x4
 800dbce: 4b45         	ldr	r3, [pc, #0x114]        @ 0x800dce4 <k_sched_unlock+0x18c>
 800dbd0: 68db         	ldr	r3, [r3, #0xc]
 800dbd2: e000         	b	0x800dbd6 <k_sched_unlock+0x7e> @ imm = #0x0
 800dbd4: 6a3b         	ldr	r3, [r7, #0x20]
; 	struct k_thread *thread = next_up();
 800dbd6: 61fb         	str	r3, [r7, #0x1c]
 800dbd8: 69fb         	ldr	r3, [r7, #0x1c]
 800dbda: 61bb         	str	r3, [r7, #0x18]
 800dbdc: 6b3b         	ldr	r3, [r7, #0x30]
 800dbde: 617b         	str	r3, [r7, #0x14]
; 	if (preempt_ok != 0) {
 800dbe0: 697b         	ldr	r3, [r7, #0x14]
 800dbe2: 2b00         	cmp	r3, #0x0
 800dbe4: d001         	beq	0x800dbea <k_sched_unlock+0x92> @ imm = #0x2
; 		return true;
 800dbe6: 2301         	movs	r3, #0x1
 800dbe8: e022         	b	0x800dc30 <k_sched_unlock+0xd8> @ imm = #0x44
; 	if (z_is_thread_prevented_from_running(_current)) {
 800dbea: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800dce4 <k_sched_unlock+0x18c>
 800dbec: 689b         	ldr	r3, [r3, #0x8]
 800dbee: 4618         	mov	r0, r3
 800dbf0: f00a fba6    	bl	0x8018340 <z_is_thread_prevented_from_running> @ imm = #0xa74c
 800dbf4: 4603         	mov	r3, r0
 800dbf6: 2b00         	cmp	r3, #0x0
 800dbf8: d001         	beq	0x800dbfe <k_sched_unlock+0xa6> @ imm = #0x2
; 		return true;
 800dbfa: 2301         	movs	r3, #0x1
 800dbfc: e018         	b	0x800dc30 <k_sched_unlock+0xd8> @ imm = #0x30
; 	if (thread_is_preemptible(_current) || thread_is_metairq(thread)) {
 800dbfe: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800dce4 <k_sched_unlock+0x18c>
 800dc00: 689b         	ldr	r3, [r3, #0x8]
 800dc02: 4618         	mov	r0, r3
 800dc04: f00a fb82    	bl	0x801830c <thread_is_preemptible> @ imm = #0xa704
 800dc08: 4603         	mov	r3, r0
 800dc0a: 2b00         	cmp	r3, #0x0
 800dc0c: d105         	bne	0x800dc1a <k_sched_unlock+0xc2> @ imm = #0xa
 800dc0e: 69b8         	ldr	r0, [r7, #0x18]
 800dc10: f00a fb8c    	bl	0x801832c <thread_is_metairq> @ imm = #0xa718
 800dc14: 4603         	mov	r3, r0
 800dc16: 2b00         	cmp	r3, #0x0
 800dc18: d001         	beq	0x800dc1e <k_sched_unlock+0xc6> @ imm = #0x2
; 		return true;
 800dc1a: 2301         	movs	r3, #0x1
 800dc1c: e008         	b	0x800dc30 <k_sched_unlock+0xd8> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800dc1e: 69b8         	ldr	r0, [r7, #0x18]
 800dc20: f00a fba2    	bl	0x8018368 <z_is_thread_timeout_active> @ imm = #0xa744
 800dc24: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800dc26: 2b00         	cmp	r3, #0x0
 800dc28: d001         	beq	0x800dc2e <k_sched_unlock+0xd6> @ imm = #0x2
; 		return true;
 800dc2a: 2301         	movs	r3, #0x1
 800dc2c: e000         	b	0x800dc30 <k_sched_unlock+0xd8> @ imm = #0x0
; 	return false;
 800dc2e: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800dc30: 2b00         	cmp	r3, #0x0
 800dc32: d00e         	beq	0x800dc52 <k_sched_unlock+0xfa> @ imm = #0x1c
; 		if (thread != _current) {
 800dc34: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800dce4 <k_sched_unlock+0x18c>
 800dc36: 689b         	ldr	r3, [r3, #0x8]
 800dc38: 69fa         	ldr	r2, [r7, #0x1c]
 800dc3a: 429a         	cmp	r2, r3
 800dc3c: d002         	beq	0x800dc44 <k_sched_unlock+0xec> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800dc3e: 69f8         	ldr	r0, [r7, #0x1c]
 800dc40: f000 fcc2    	bl	0x800e5c8 <z_reset_time_slice> @ imm = #0x984
; 		update_metairq_preempt(thread);
 800dc44: 69f8         	ldr	r0, [r7, #0x1c]
 800dc46: f00a fd26    	bl	0x8018696 <update_metairq_preempt> @ imm = #0xaa4c
; 		_kernel.ready_q.cache = thread;
 800dc4a: 4a26         	ldr	r2, [pc, #0x98]         @ 0x800dce4 <k_sched_unlock+0x18c>
 800dc4c: 69fb         	ldr	r3, [r7, #0x1c]
 800dc4e: 61d3         	str	r3, [r2, #0x1c]
; }
 800dc50: e003         	b	0x800dc5a <k_sched_unlock+0x102> @ imm = #0x6
; 		_kernel.ready_q.cache = _current;
 800dc52: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800dce4 <k_sched_unlock+0x18c>
 800dc54: 689b         	ldr	r3, [r3, #0x8]
 800dc56: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x800dce4 <k_sched_unlock+0x18c>
 800dc58: 61d3         	str	r3, [r2, #0x1c]
; }
 800dc5a: bf00         	nop
 800dc5c: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800dce0 <k_sched_unlock+0x188>
 800dc5e: 63fb         	str	r3, [r7, #0x3c]
 800dc60: 68fb         	ldr	r3, [r7, #0xc]
 800dc62: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800dc64: 68bb         	ldr	r3, [r7, #0x8]
 800dc66: 63bb         	str	r3, [r7, #0x38]
 800dc68: 6bbb         	ldr	r3, [r7, #0x38]
 800dc6a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800dc6c: 6b7b         	ldr	r3, [r7, #0x34]
 800dc6e: f383 8811    	msr	basepri, r3
; }
 800dc72: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800dc74: f3bf 8f6f    	isb	sy
; }
 800dc78: bf00         	nop
; }
 800dc7a: bf00         	nop
; }
 800dc7c: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800dc7e: 2301         	movs	r3, #0x1
 800dc80: 613b         	str	r3, [r7, #0x10]
 800dc82: 693b         	ldr	r3, [r7, #0x10]
 800dc84: 2b00         	cmp	r3, #0x0
 800dc86: d087         	beq	0x800db98 <k_sched_unlock+0x40> @ imm = #-0xf2
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 800dc88: 2303         	movs	r3, #0x3
 800dc8a: 2b03         	cmp	r3, #0x3
 800dc8c: d921         	bls	0x800dcd2 <k_sched_unlock+0x17a> @ imm = #0x42
 800dc8e: 2301         	movs	r3, #0x1
 800dc90: f887 305f    	strb.w	r3, [r7, #0x5f]
 800dc94: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 800dc98: f083 0301    	eor	r3, r3, #0x1
 800dc9c: b2db         	uxtb	r3, r3
 800dc9e: 2b00         	cmp	r3, #0x0
 800dca0: d117         	bne	0x800dcd2 <k_sched_unlock+0x17a> @ imm = #0x2e
 800dca2: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800dcec <k_sched_unlock+0x194>
 800dca4: 6819         	ldr	r1, [r3]
 800dca6: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800dce4 <k_sched_unlock+0x18c>
 800dca8: 689b         	ldr	r3, [r3, #0x8]
 800dcaa: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800dce4 <k_sched_unlock+0x18c>
 800dcac: 6892         	ldr	r2, [r2, #0x8]
 800dcae: 7bd2         	ldrb	r2, [r2, #0xf]
 800dcb0: 9205         	str	r2, [sp, #0x14]
 800dcb2: 9304         	str	r3, [sp, #0x10]
 800dcb4: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800dcf0 <k_sched_unlock+0x198>
 800dcb6: 9303         	str	r3, [sp, #0xc]
 800dcb8: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800dcf4 <k_sched_unlock+0x19c>
 800dcba: 9302         	str	r3, [sp, #0x8]
 800dcbc: 2308         	movs	r3, #0x8
 800dcbe: 9301         	str	r3, [sp, #0x4]
 800dcc0: 2300         	movs	r3, #0x0
 800dcc2: 9300         	str	r3, [sp]
 800dcc4: 2300         	movs	r3, #0x0
 800dcc6: 2204         	movs	r2, #0x4
 800dcc8: 2000         	movs	r0, #0x0
 800dcca: f00a fc68    	bl	0x801859e <z_log_msg_runtime_create> @ imm = #0xa8d0
 800dcce: 2300         	movs	r3, #0x0
 800dcd0: 65bb         	str	r3, [r7, #0x58]
; 	z_reschedule_unlocked();
 800dcd2: f00a fc17    	bl	0x8018504 <z_reschedule_unlocked> @ imm = #0xa82e
; }
 800dcd6: bf00         	nop
 800dcd8: 3760         	adds	r7, #0x60
 800dcda: 46bd         	mov	sp, r7
 800dcdc: bd80         	pop	{r7, pc}
 800dcde: bf00         	nop

0800dce0 <$d>:
 800dce0: e8 10 00 20  	.word	0x200010e8
 800dce4: c8 06 00 20  	.word	0x200006c8
 800dce8: e8 06 00 20  	.word	0x200006e8
 800dcec: 4c 05 00 20  	.word	0x2000054c
 800dcf0: b8 bd 01 08  	.word	0x0801bdb8
 800dcf4: f0 b0 01 08  	.word	0x0801b0f0

0800dcf8 <z_sched_init>:
; {
 800dcf8: b580         	push	{r7, lr}
 800dcfa: af00         	add	r7, sp, #0x0
; 	init_ready_q(&_kernel.ready_q);
 800dcfc: 4802         	ldr	r0, [pc, #0x8]          @ 0x800dd08 <z_sched_init+0x10>
 800dcfe: f00a fde9    	bl	0x80188d4 <init_ready_q> @ imm = #0xabd2
; }
 800dd02: bf00         	nop
 800dd04: bd80         	pop	{r7, pc}
 800dd06: bf00         	nop

0800dd08 <$d>:
 800dd08: e4 06 00 20  	.word	0x200006e4

0800dd0c <z_impl_k_yield>:
; {
 800dd0c: b580         	push	{r7, lr}
 800dd0e: b09e         	sub	sp, #0x78
 800dd10: af00         	add	r7, sp, #0x0
 800dd12: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x800df04 <z_impl_k_yield+0x1f8>
 800dd14: 677b         	str	r3, [r7, #0x74]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800dd16: f3ef 8311    	mrs	r3, basepri
 800dd1a: 673b         	str	r3, [r7, #0x70]
;   return(result);
 800dd1c: 6f3b         	ldr	r3, [r7, #0x70]
; 	key = __get_BASEPRI();
 800dd1e: 66fb         	str	r3, [r7, #0x6c]
 800dd20: 2310         	movs	r3, #0x10
 800dd22: 66bb         	str	r3, [r7, #0x68]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800dd24: 6ebb         	ldr	r3, [r7, #0x68]
 800dd26: f383 8812    	msr	basepri_max, r3
; }
 800dd2a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800dd2c: f3bf 8f6f    	isb	sy
; }
 800dd30: bf00         	nop
; 	return key;
 800dd32: 6efb         	ldr	r3, [r7, #0x6c]
; 	k.key = arch_irq_lock();
 800dd34: 603b         	str	r3, [r7]
 800dd36: 6f7b         	ldr	r3, [r7, #0x74]
 800dd38: 667b         	str	r3, [r7, #0x64]
; }
 800dd3a: bf00         	nop
 800dd3c: 6f7b         	ldr	r3, [r7, #0x74]
 800dd3e: 663b         	str	r3, [r7, #0x60]
; }
 800dd40: bf00         	nop
; 	return k;
 800dd42: 683b         	ldr	r3, [r7]
 800dd44: 60bb         	str	r3, [r7, #0x8]
; 		dequeue_thread(_current);
 800dd46: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x800df08 <z_impl_k_yield+0x1fc>
 800dd48: 689b         	ldr	r3, [r3, #0x8]
 800dd4a: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800dd4c: 69fb         	ldr	r3, [r7, #0x1c]
 800dd4e: 7b5b         	ldrb	r3, [r3, #0xd]
 800dd50: f003 037f    	and	r3, r3, #0x7f
 800dd54: b2da         	uxtb	r2, r3
 800dd56: 69fb         	ldr	r3, [r7, #0x1c]
 800dd58: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800dd5a: 69f8         	ldr	r0, [r7, #0x1c]
 800dd5c: f00a fc58    	bl	0x8018610 <should_queue_thread> @ imm = #0xa8b0
 800dd60: 4603         	mov	r3, r0
 800dd62: 2b00         	cmp	r3, #0x0
 800dd64: d00d         	beq	0x800dd82 <z_impl_k_yield+0x76> @ imm = #0x1a
 800dd66: 69fb         	ldr	r3, [r7, #0x1c]
 800dd68: 61bb         	str	r3, [r7, #0x18]
 800dd6a: 69bb         	ldr	r3, [r7, #0x18]
 800dd6c: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 800dd6e: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x800df0c <z_impl_k_yield+0x200>
 800dd70: 613b         	str	r3, [r7, #0x10]
 800dd72: 69bb         	ldr	r3, [r7, #0x18]
 800dd74: 60fb         	str	r3, [r7, #0xc]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800dd76: 68fb         	ldr	r3, [r7, #0xc]
 800dd78: 4618         	mov	r0, r3
 800dd7a: f00a fa79    	bl	0x8018270 <sys_dlist_remove> @ imm = #0xa4f2
; }
 800dd7e: bf00         	nop
; }
 800dd80: bf00         	nop
; }
 800dd82: bf00         	nop
; 	queue_thread(_current);
 800dd84: 4b60         	ldr	r3, [pc, #0x180]        @ 0x800df08 <z_impl_k_yield+0x1fc>
 800dd86: 689b         	ldr	r3, [r3, #0x8]
 800dd88: 637b         	str	r3, [r7, #0x34]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800dd8a: 6b7b         	ldr	r3, [r7, #0x34]
 800dd8c: 7b5b         	ldrb	r3, [r3, #0xd]
 800dd8e: f063 037f    	orn	r3, r3, #0x7f
 800dd92: b2da         	uxtb	r2, r3
 800dd94: 6b7b         	ldr	r3, [r7, #0x34]
 800dd96: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800dd98: 6b78         	ldr	r0, [r7, #0x34]
 800dd9a: f00a fc39    	bl	0x8018610 <should_queue_thread> @ imm = #0xa872
 800dd9e: 4603         	mov	r3, r0
 800dda0: 2b00         	cmp	r3, #0x0
 800dda2: d042         	beq	0x800de2a <z_impl_k_yield+0x11e> @ imm = #0x84
 800dda4: 6b7b         	ldr	r3, [r7, #0x34]
 800dda6: 633b         	str	r3, [r7, #0x30]
 800dda8: 6b3b         	ldr	r3, [r7, #0x30]
 800ddaa: 62fb         	str	r3, [r7, #0x2c]
; 	return &_kernel.ready_q.runq;
 800ddac: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x800df0c <z_impl_k_yield+0x200>
 800ddae: 62bb         	str	r3, [r7, #0x28]
 800ddb0: 6b3b         	ldr	r3, [r7, #0x30]
 800ddb2: 627b         	str	r3, [r7, #0x24]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800ddb4: 6ab8         	ldr	r0, [r7, #0x28]
 800ddb6: f00a f9f1    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xa3e2
 800ddba: 4603         	mov	r3, r0
 800ddbc: 2b00         	cmp	r3, #0x0
 800ddbe: d004         	beq	0x800ddca <z_impl_k_yield+0xbe> @ imm = #0x8
 800ddc0: 6ab8         	ldr	r0, [r7, #0x28]
 800ddc2: f00a f9eb    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xa3d6
 800ddc6: 4603         	mov	r3, r0
 800ddc8: e000         	b	0x800ddcc <z_impl_k_yield+0xc0> @ imm = #0x0
 800ddca: 2300         	movs	r3, #0x0
 800ddcc: 623b         	str	r3, [r7, #0x20]
 800ddce: e023         	b	0x800de18 <z_impl_k_yield+0x10c> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800ddd0: 6a39         	ldr	r1, [r7, #0x20]
 800ddd2: 6a78         	ldr	r0, [r7, #0x24]
 800ddd4: f00a fc01    	bl	0x80185da <z_sched_prio_cmp> @ imm = #0xa802
 800ddd8: 4603         	mov	r3, r0
 800ddda: 2b00         	cmp	r3, #0x0
 800dddc: dd06         	ble	0x800ddec <z_impl_k_yield+0xe0> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800ddde: 6a3b         	ldr	r3, [r7, #0x20]
 800dde0: 6a7a         	ldr	r2, [r7, #0x24]
 800dde2: 4611         	mov	r1, r2
 800dde4: 4618         	mov	r0, r3
 800dde6: f00a fa2a    	bl	0x801823e <sys_dlist_insert> @ imm = #0xa454
; 			return;
 800ddea: e01d         	b	0x800de28 <z_impl_k_yield+0x11c> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800ddec: 6a3b         	ldr	r3, [r7, #0x20]
 800ddee: 2b00         	cmp	r3, #0x0
 800ddf0: d010         	beq	0x800de14 <z_impl_k_yield+0x108> @ imm = #0x20
 800ddf2: 6a3b         	ldr	r3, [r7, #0x20]
 800ddf4: 4619         	mov	r1, r3
 800ddf6: 6ab8         	ldr	r0, [r7, #0x28]
 800ddf8: f00a f9f5    	bl	0x80181e6 <sys_dlist_peek_next> @ imm = #0xa3ea
 800ddfc: 4603         	mov	r3, r0
 800ddfe: 2b00         	cmp	r3, #0x0
 800de00: d006         	beq	0x800de10 <z_impl_k_yield+0x104> @ imm = #0xc
 800de02: 6a3b         	ldr	r3, [r7, #0x20]
 800de04: 4619         	mov	r1, r3
 800de06: 6ab8         	ldr	r0, [r7, #0x28]
 800de08: f00a f9ed    	bl	0x80181e6 <sys_dlist_peek_next> @ imm = #0xa3da
 800de0c: 4603         	mov	r3, r0
 800de0e: e002         	b	0x800de16 <z_impl_k_yield+0x10a> @ imm = #0x4
 800de10: 2300         	movs	r3, #0x0
 800de12: e000         	b	0x800de16 <z_impl_k_yield+0x10a> @ imm = #0x0
 800de14: 2300         	movs	r3, #0x0
 800de16: 623b         	str	r3, [r7, #0x20]
 800de18: 6a3b         	ldr	r3, [r7, #0x20]
 800de1a: 2b00         	cmp	r3, #0x0
 800de1c: d1d8         	bne	0x800ddd0 <z_impl_k_yield+0xc4> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800de1e: 6a7b         	ldr	r3, [r7, #0x24]
 800de20: 4619         	mov	r1, r3
 800de22: 6ab8         	ldr	r0, [r7, #0x28]
 800de24: f00a f9f2    	bl	0x801820c <sys_dlist_append> @ imm = #0xa3e4
; }
 800de28: bf00         	nop
; }
 800de2a: bf00         	nop
 800de2c: 2301         	movs	r3, #0x1
 800de2e: 657b         	str	r3, [r7, #0x54]
; 	return &_kernel.ready_q.runq;
 800de30: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800df0c <z_impl_k_yield+0x200>
 800de32: 653b         	str	r3, [r7, #0x50]
; 	struct k_thread *thread = NULL;
 800de34: 2300         	movs	r3, #0x0
 800de36: 64fb         	str	r3, [r7, #0x4c]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800de38: 6d38         	ldr	r0, [r7, #0x50]
 800de3a: f00a f9af    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0xa35e
 800de3e: 64b8         	str	r0, [r7, #0x48]
; 	if (n != NULL) {
 800de40: 6cbb         	ldr	r3, [r7, #0x48]
 800de42: 2b00         	cmp	r3, #0x0
 800de44: d001         	beq	0x800de4a <z_impl_k_yield+0x13e> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800de46: 6cbb         	ldr	r3, [r7, #0x48]
 800de48: 64fb         	str	r3, [r7, #0x4c]
; 	return thread;
 800de4a: 6cfb         	ldr	r3, [r7, #0x4c]
; 	return _priq_run_best(curr_cpu_runq());
 800de4c: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800de4e: 647b         	str	r3, [r7, #0x44]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800de50: 6c7b         	ldr	r3, [r7, #0x44]
 800de52: 2b00         	cmp	r3, #0x0
 800de54: d102         	bne	0x800de5c <z_impl_k_yield+0x150> @ imm = #0x4
 800de56: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800df08 <z_impl_k_yield+0x1fc>
 800de58: 68db         	ldr	r3, [r3, #0xc]
 800de5a: e000         	b	0x800de5e <z_impl_k_yield+0x152> @ imm = #0x0
 800de5c: 6c7b         	ldr	r3, [r7, #0x44]
; 	struct k_thread *thread = next_up();
 800de5e: 643b         	str	r3, [r7, #0x40]
 800de60: 6c3b         	ldr	r3, [r7, #0x40]
 800de62: 63fb         	str	r3, [r7, #0x3c]
 800de64: 6d7b         	ldr	r3, [r7, #0x54]
 800de66: 63bb         	str	r3, [r7, #0x38]
; 	if (preempt_ok != 0) {
 800de68: 6bbb         	ldr	r3, [r7, #0x38]
 800de6a: 2b00         	cmp	r3, #0x0
 800de6c: d001         	beq	0x800de72 <z_impl_k_yield+0x166> @ imm = #0x2
; 		return true;
 800de6e: 2301         	movs	r3, #0x1
 800de70: e022         	b	0x800deb8 <z_impl_k_yield+0x1ac> @ imm = #0x44
; 	if (z_is_thread_prevented_from_running(_current)) {
 800de72: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800df08 <z_impl_k_yield+0x1fc>
 800de74: 689b         	ldr	r3, [r3, #0x8]
 800de76: 4618         	mov	r0, r3
 800de78: f00a fa62    	bl	0x8018340 <z_is_thread_prevented_from_running> @ imm = #0xa4c4
 800de7c: 4603         	mov	r3, r0
 800de7e: 2b00         	cmp	r3, #0x0
 800de80: d001         	beq	0x800de86 <z_impl_k_yield+0x17a> @ imm = #0x2
; 		return true;
 800de82: 2301         	movs	r3, #0x1
 800de84: e018         	b	0x800deb8 <z_impl_k_yield+0x1ac> @ imm = #0x30
; 	if (thread_is_preemptible(_current) || thread_is_metairq(thread)) {
 800de86: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800df08 <z_impl_k_yield+0x1fc>
 800de88: 689b         	ldr	r3, [r3, #0x8]
 800de8a: 4618         	mov	r0, r3
 800de8c: f00a fa3e    	bl	0x801830c <thread_is_preemptible> @ imm = #0xa47c
 800de90: 4603         	mov	r3, r0
 800de92: 2b00         	cmp	r3, #0x0
 800de94: d105         	bne	0x800dea2 <z_impl_k_yield+0x196> @ imm = #0xa
 800de96: 6bf8         	ldr	r0, [r7, #0x3c]
 800de98: f00a fa48    	bl	0x801832c <thread_is_metairq> @ imm = #0xa490
 800de9c: 4603         	mov	r3, r0
 800de9e: 2b00         	cmp	r3, #0x0
 800dea0: d001         	beq	0x800dea6 <z_impl_k_yield+0x19a> @ imm = #0x2
; 		return true;
 800dea2: 2301         	movs	r3, #0x1
 800dea4: e008         	b	0x800deb8 <z_impl_k_yield+0x1ac> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800dea6: 6bf8         	ldr	r0, [r7, #0x3c]
 800dea8: f00a fa5e    	bl	0x8018368 <z_is_thread_timeout_active> @ imm = #0xa4bc
 800deac: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800deae: 2b00         	cmp	r3, #0x0
 800deb0: d001         	beq	0x800deb6 <z_impl_k_yield+0x1aa> @ imm = #0x2
; 		return true;
 800deb2: 2301         	movs	r3, #0x1
 800deb4: e000         	b	0x800deb8 <z_impl_k_yield+0x1ac> @ imm = #0x0
; 	return false;
 800deb6: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800deb8: 2b00         	cmp	r3, #0x0
 800deba: d00e         	beq	0x800deda <z_impl_k_yield+0x1ce> @ imm = #0x1c
; 		if (thread != _current) {
 800debc: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800df08 <z_impl_k_yield+0x1fc>
 800debe: 689b         	ldr	r3, [r3, #0x8]
 800dec0: 6c3a         	ldr	r2, [r7, #0x40]
 800dec2: 429a         	cmp	r2, r3
 800dec4: d002         	beq	0x800decc <z_impl_k_yield+0x1c0> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800dec6: 6c38         	ldr	r0, [r7, #0x40]
 800dec8: f000 fb7e    	bl	0x800e5c8 <z_reset_time_slice> @ imm = #0x6fc
; 		update_metairq_preempt(thread);
 800decc: 6c38         	ldr	r0, [r7, #0x40]
 800dece: f00a fbe2    	bl	0x8018696 <update_metairq_preempt> @ imm = #0xa7c4
; 		_kernel.ready_q.cache = thread;
 800ded2: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800df08 <z_impl_k_yield+0x1fc>
 800ded4: 6c3b         	ldr	r3, [r7, #0x40]
 800ded6: 61d3         	str	r3, [r2, #0x1c]
; }
 800ded8: e003         	b	0x800dee2 <z_impl_k_yield+0x1d6> @ imm = #0x6
; 		_kernel.ready_q.cache = _current;
 800deda: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800df08 <z_impl_k_yield+0x1fc>
 800dedc: 689b         	ldr	r3, [r3, #0x8]
 800dede: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800df08 <z_impl_k_yield+0x1fc>
 800dee0: 61d3         	str	r3, [r2, #0x1c]
; }
 800dee2: bf00         	nop
 800dee4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800df04 <z_impl_k_yield+0x1f8>
 800dee6: 65fb         	str	r3, [r7, #0x5c]
 800dee8: 68bb         	ldr	r3, [r7, #0x8]
 800deea: 607b         	str	r3, [r7, #0x4]
 800deec: 6dfb         	ldr	r3, [r7, #0x5c]
 800deee: 65bb         	str	r3, [r7, #0x58]
; }
 800def0: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800def2: 687b         	ldr	r3, [r7, #0x4]
 800def4: 4618         	mov	r0, r3
 800def6: f00a fb45    	bl	0x8018584 <z_swap_irqlock> @ imm = #0xa68a
; }
 800defa: bf00         	nop
 800defc: 3778         	adds	r7, #0x78
 800defe: 46bd         	mov	sp, r7
 800df00: bd80         	pop	{r7, pc}
 800df02: bf00         	nop

0800df04 <$d>:
 800df04: e8 10 00 20  	.word	0x200010e8
 800df08: c8 06 00 20  	.word	0x200006c8
 800df0c: e8 06 00 20  	.word	0x200006e8

0800df10 <z_tick_sleep>:
; {
 800df10: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800df14: b09c         	sub	sp, #0x70
 800df16: af06         	add	r7, sp, #0x18
 800df18: e9c7 0102    	strd	r0, r1, [r7, #8]
; 	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);
 800df1c: 2303         	movs	r3, #0x3
 800df1e: 2b03         	cmp	r3, #0x3
 800df20: d91f         	bls	0x800df62 <z_tick_sleep+0x52> @ imm = #0x3e
 800df22: 2301         	movs	r3, #0x1
 800df24: f887 3057    	strb.w	r3, [r7, #0x57]
 800df28: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800df2c: f083 0301    	eor	r3, r3, #0x1
 800df30: b2db         	uxtb	r3, r3
 800df32: 2b00         	cmp	r3, #0x0
 800df34: d115         	bne	0x800df62 <z_tick_sleep+0x52> @ imm = #0x2a
 800df36: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800e064 <z_tick_sleep+0x154>
 800df38: 6819         	ldr	r1, [r3]
 800df3a: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800e068 <z_tick_sleep+0x158>
 800df3c: 689b         	ldr	r3, [r3, #0x8]
 800df3e: 68ba         	ldr	r2, [r7, #0x8]
 800df40: 9205         	str	r2, [sp, #0x14]
 800df42: 9304         	str	r3, [sp, #0x10]
 800df44: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800e06c <z_tick_sleep+0x15c>
 800df46: 9303         	str	r3, [sp, #0xc]
 800df48: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800e070 <z_tick_sleep+0x160>
 800df4a: 9302         	str	r3, [sp, #0x8]
 800df4c: 2308         	movs	r3, #0x8
 800df4e: 9301         	str	r3, [sp, #0x4]
 800df50: 2300         	movs	r3, #0x0
 800df52: 9300         	str	r3, [sp]
 800df54: 2300         	movs	r3, #0x0
 800df56: 2204         	movs	r2, #0x4
 800df58: 2000         	movs	r0, #0x0
 800df5a: f00a fb20    	bl	0x801859e <z_log_msg_runtime_create> @ imm = #0xa640
 800df5e: 2300         	movs	r3, #0x0
 800df60: 64fb         	str	r3, [r7, #0x4c]
; 	if (ticks == 0) {
 800df62: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800df66: 4313         	orrs	r3, r2
 800df68: d103         	bne	0x800df72 <z_tick_sleep+0x62> @ imm = #0x6
; 		k_yield();
 800df6a: f00a f998    	bl	0x801829e <k_yield>     @ imm = #0xa330
; 		return 0;
 800df6e: 2300         	movs	r3, #0x0
 800df70: e073         	b	0x800e05a <z_tick_sleep+0x14a> @ imm = #0xe6
; 	if (Z_TICK_ABS(ticks) <= 0) {
 800df72: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800df76: f06f 0001    	mvn	r0, #0x1
 800df7a: f04f 31ff    	mov.w	r1, #0xffffffff
 800df7e: 1a84         	subs	r4, r0, r2
 800df80: eb61 0503    	sbc.w	r5, r1, r3
 800df84: 2c01         	cmp	r4, #0x1
 800df86: f175 0300    	sbcs	r3, r5, #0x0
 800df8a: da06         	bge	0x800df9a <z_tick_sleep+0x8a> @ imm = #0xc
; 		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
 800df8c: f00a fe28    	bl	0x8018be0 <sys_clock_tick_get_32> @ imm = #0xac50
 800df90: 4602         	mov	r2, r0
 800df92: 68bb         	ldr	r3, [r7, #0x8]
 800df94: 4413         	add	r3, r2
 800df96: 653b         	str	r3, [r7, #0x50]
 800df98: e004         	b	0x800dfa4 <z_tick_sleep+0x94> @ imm = #0x8
; 		expected_wakeup_ticks = Z_TICK_ABS(ticks);
 800df9a: 68ba         	ldr	r2, [r7, #0x8]
 800df9c: f06f 0301    	mvn	r3, #0x1
 800dfa0: 1a9b         	subs	r3, r3, r2
 800dfa2: 653b         	str	r3, [r7, #0x50]
; 	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
 800dfa4: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800dfa8: e9c7 2308    	strd	r2, r3, [r7, #32]
 800dfac: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800e074 <z_tick_sleep+0x164>
 800dfae: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800dfb0: f3ef 8311    	mrs	r3, basepri
 800dfb4: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800dfb6: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 800dfb8: 63bb         	str	r3, [r7, #0x38]
 800dfba: 2310         	movs	r3, #0x10
 800dfbc: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800dfbe: 6b7b         	ldr	r3, [r7, #0x34]
 800dfc0: f383 8812    	msr	basepri_max, r3
; }
 800dfc4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800dfc6: f3bf 8f6f    	isb	sy
; }
 800dfca: bf00         	nop
; 	return key;
 800dfcc: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 800dfce: 61bb         	str	r3, [r7, #0x18]
 800dfd0: 6c3b         	ldr	r3, [r7, #0x40]
 800dfd2: 633b         	str	r3, [r7, #0x30]
; }
 800dfd4: bf00         	nop
 800dfd6: 6c3b         	ldr	r3, [r7, #0x40]
 800dfd8: 62fb         	str	r3, [r7, #0x2c]
; }
 800dfda: bf00         	nop
; 	return k;
 800dfdc: 69bb         	ldr	r3, [r7, #0x18]
 800dfde: 61fb         	str	r3, [r7, #0x1c]
; 	pending_current = _current;
 800dfe0: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800e068 <z_tick_sleep+0x158>
 800dfe2: 689b         	ldr	r3, [r3, #0x8]
 800dfe4: 4a24         	ldr	r2, [pc, #0x90]         @ 0x800e078 <z_tick_sleep+0x168>
 800dfe6: 6013         	str	r3, [r2]
; 	unready_thread(_current);
 800dfe8: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800e068 <z_tick_sleep+0x158>
 800dfea: 689b         	ldr	r3, [r3, #0x8]
 800dfec: 4618         	mov	r0, r3
 800dfee: f7ff fad3    	bl	0x800d598 <unready_thread> @ imm = #-0xa5a
; 	z_add_thread_timeout(_current, timeout);
 800dff2: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800e068 <z_tick_sleep+0x158>
 800dff4: 6899         	ldr	r1, [r3, #0x8]
 800dff6: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 800dffa: 4608         	mov	r0, r1
 800dffc: f7fe ff2a    	bl	0x800ce54 <z_add_thread_timeout> @ imm = #-0x11ac
; 	z_mark_thread_as_suspended(_current);
 800e000: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800e068 <z_tick_sleep+0x158>
 800e002: 689b         	ldr	r3, [r3, #0x8]
 800e004: 4618         	mov	r0, r3
 800e006: f00a fa1b    	bl	0x8018440 <z_mark_thread_as_suspended> @ imm = #0xa436
 800e00a: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800e074 <z_tick_sleep+0x164>
 800e00c: 64bb         	str	r3, [r7, #0x48]
 800e00e: 69fb         	ldr	r3, [r7, #0x1c]
 800e010: 617b         	str	r3, [r7, #0x14]
 800e012: 6cbb         	ldr	r3, [r7, #0x48]
 800e014: 647b         	str	r3, [r7, #0x44]
; }
 800e016: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800e018: 697b         	ldr	r3, [r7, #0x14]
 800e01a: 4618         	mov	r0, r3
 800e01c: f00a fab2    	bl	0x8018584 <z_swap_irqlock> @ imm = #0xa564
; 	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
 800e020: 6d3b         	ldr	r3, [r7, #0x50]
 800e022: 2200         	movs	r2, #0x0
 800e024: 469a         	mov	r10, r3
 800e026: 4693         	mov	r11, r2
 800e028: f00a fdda    	bl	0x8018be0 <sys_clock_tick_get_32> @ imm = #0xabb4
 800e02c: 4603         	mov	r3, r0
 800e02e: 2200         	movs	r2, #0x0
 800e030: 4698         	mov	r8, r3
 800e032: 4691         	mov	r9, r2
 800e034: ebba 0308    	subs.w	r3, r10, r8
 800e038: 603b         	str	r3, [r7]
 800e03a: eb6b 0309    	sbc.w	r3, r11, r9
 800e03e: 607b         	str	r3, [r7, #0x4]
 800e040: e9d7 3400    	ldrd	r3, r4, [r7]
 800e044: e9c7 3402    	strd	r3, r4, [r7, #8]
; 	if (ticks > 0) {
 800e048: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800e04c: 2a01         	cmp	r2, #0x1
 800e04e: f173 0300    	sbcs	r3, r3, #0x0
 800e052: db01         	blt	0x800e058 <z_tick_sleep+0x148> @ imm = #0x2
; 		return ticks;
 800e054: 68bb         	ldr	r3, [r7, #0x8]
 800e056: e000         	b	0x800e05a <z_tick_sleep+0x14a> @ imm = #0x0
; 	return 0;
 800e058: 2300         	movs	r3, #0x0
; }
 800e05a: 4618         	mov	r0, r3
 800e05c: 3758         	adds	r7, #0x58
 800e05e: 46bd         	mov	sp, r7
 800e060: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800e064 <$d>:
 800e064: 4c 05 00 20  	.word	0x2000054c
 800e068: c8 06 00 20  	.word	0x200006c8
 800e06c: c8 bd 01 08  	.word	0x0801bdc8
 800e070: 10 b1 01 08  	.word	0x0801b110
 800e074: e8 10 00 20  	.word	0x200010e8
 800e078: f4 10 00 20  	.word	0x200010f4

0800e07c <z_impl_k_sleep>:
; {
 800e07c: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800e080: b086         	sub	sp, #0x18
 800e082: af00         	add	r7, sp, #0x0
 800e084: e9c7 0100    	strd	r0, r1, [r7]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 800e088: e9d7 2300    	ldrd	r2, r3, [r7]
 800e08c: f04f 30ff    	mov.w	r0, #0xffffffff
 800e090: f04f 31ff    	mov.w	r1, #0xffffffff
 800e094: 428b         	cmp	r3, r1
 800e096: bf08         	it	eq
 800e098: 4282         	cmpeq	r2, r0
 800e09a: d107         	bne	0x800e0ac <z_impl_k_sleep+0x30> @ imm = #0xe
; 		k_thread_suspend(_current);
 800e09c: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800e0f8 <z_impl_k_sleep+0x7c>
 800e09e: 689b         	ldr	r3, [r3, #0x8]
 800e0a0: 4618         	mov	r0, r3
 800e0a2: f00a f902    	bl	0x80182aa <k_thread_suspend> @ imm = #0xa204
; 		return (int32_t) K_TICKS_FOREVER;
 800e0a6: f04f 33ff    	mov.w	r3, #0xffffffff
 800e0aa: e020         	b	0x800e0ee <z_impl_k_sleep+0x72> @ imm = #0x40
; 	ticks = timeout.ticks;
 800e0ac: e9d7 2300    	ldrd	r2, r3, [r7]
 800e0b0: e9c7 2304    	strd	r2, r3, [r7, #16]
; 	ticks = z_tick_sleep(ticks);
 800e0b4: e9d7 0104    	ldrd	r0, r1, [r7, #16]
 800e0b8: f7ff ff2a    	bl	0x800df10 <z_tick_sleep> @ imm = #-0x1ac
 800e0bc: 4603         	mov	r3, r0
 800e0be: 17da         	asrs	r2, r3, #0x1f
 800e0c0: 4698         	mov	r8, r3
 800e0c2: 4691         	mov	r9, r2
 800e0c4: e9c7 8904    	strd	r8, r9, [r7, #16]
; 	int32_t ret = k_ticks_to_ms_ceil64(ticks);
 800e0c8: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800e0cc: f112 0409    	adds.w	r4, r2, #0x9
 800e0d0: f143 0500    	adc	r5, r3, #0x0
 800e0d4: f04f 020a    	mov.w	r2, #0xa
 800e0d8: f04f 0300    	mov.w	r3, #0x0
 800e0dc: 4620         	mov	r0, r4
 800e0de: 4629         	mov	r1, r5
 800e0e0: f7f2 fd08    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0xd5f0
 800e0e4: 4602         	mov	r2, r0
 800e0e6: 460b         	mov	r3, r1
 800e0e8: 4613         	mov	r3, r2
 800e0ea: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800e0ec: 68fb         	ldr	r3, [r7, #0xc]
; }
 800e0ee: 4618         	mov	r0, r3
 800e0f0: 3718         	adds	r7, #0x18
 800e0f2: 46bd         	mov	sp, r7
 800e0f4: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

0800e0f8 <$d>:
 800e0f8: c8 06 00 20  	.word	0x200006c8

0800e0fc <z_impl_k_sched_current_thread_query>:
; {
 800e0fc: b480         	push	{r7}
 800e0fe: b083         	sub	sp, #0xc
 800e100: af00         	add	r7, sp, #0x0
; 	k_tid_t ret = _current_cpu->current;
 800e102: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800e114 <z_impl_k_sched_current_thread_query+0x18>
 800e104: 689b         	ldr	r3, [r3, #0x8]
 800e106: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 800e108: 687b         	ldr	r3, [r7, #0x4]
; }
 800e10a: 4618         	mov	r0, r3
 800e10c: 370c         	adds	r7, #0xc
 800e10e: 46bd         	mov	sp, r7
 800e110: bc80         	pop	{r7}
 800e112: 4770         	bx	lr

0800e114 <$d>:
 800e114: c8 06 00 20  	.word	0x200006c8

0800e118 <halt_thread>:
; {
 800e118: b580         	push	{r7, lr}
 800e11a: b092         	sub	sp, #0x48
 800e11c: af00         	add	r7, sp, #0x0
 800e11e: 6078         	str	r0, [r7, #0x4]
 800e120: 460b         	mov	r3, r1
 800e122: 70fb         	strb	r3, [r7, #0x3]
; 	bool dummify = false;
 800e124: 2300         	movs	r3, #0x0
 800e126: f887 3047    	strb.w	r3, [r7, #0x47]
; 	if ((thread->base.thread_state & new_state) == 0U) {
 800e12a: 687b         	ldr	r3, [r7, #0x4]
 800e12c: 7b5a         	ldrb	r2, [r3, #0xd]
 800e12e: 78fb         	ldrb	r3, [r7, #0x3]
 800e130: 4013         	ands	r3, r2
 800e132: b2db         	uxtb	r3, r3
 800e134: 2b00         	cmp	r3, #0x0
 800e136: f040 80c0    	bne.w	0x800e2ba <halt_thread+0x1a2> @ imm = #0x180
; 		thread->base.thread_state |= new_state;
 800e13a: 687b         	ldr	r3, [r7, #0x4]
 800e13c: 7b5a         	ldrb	r2, [r3, #0xd]
 800e13e: 78fb         	ldrb	r3, [r7, #0x3]
 800e140: 4313         	orrs	r3, r2
 800e142: b2da         	uxtb	r2, r3
 800e144: 687b         	ldr	r3, [r7, #0x4]
 800e146: 735a         	strb	r2, [r3, #0xd]
; 		if (z_is_thread_queued(thread)) {
 800e148: 6878         	ldr	r0, [r7, #0x4]
 800e14a: f00a f96c    	bl	0x8018426 <z_is_thread_queued> @ imm = #0xa2d8
 800e14e: 4603         	mov	r3, r0
 800e150: 2b00         	cmp	r3, #0x0
 800e152: d01d         	beq	0x800e190 <halt_thread+0x78> @ imm = #0x3a
 800e154: 687b         	ldr	r3, [r7, #0x4]
 800e156: 643b         	str	r3, [r7, #0x40]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800e158: 6c3b         	ldr	r3, [r7, #0x40]
 800e15a: 7b5b         	ldrb	r3, [r3, #0xd]
 800e15c: f003 037f    	and	r3, r3, #0x7f
 800e160: b2da         	uxtb	r2, r3
 800e162: 6c3b         	ldr	r3, [r7, #0x40]
 800e164: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800e166: 6c38         	ldr	r0, [r7, #0x40]
 800e168: f00a fa52    	bl	0x8018610 <should_queue_thread> @ imm = #0xa4a4
 800e16c: 4603         	mov	r3, r0
 800e16e: 2b00         	cmp	r3, #0x0
 800e170: d00d         	beq	0x800e18e <halt_thread+0x76> @ imm = #0x1a
 800e172: 6c3b         	ldr	r3, [r7, #0x40]
 800e174: 63fb         	str	r3, [r7, #0x3c]
 800e176: 6bfb         	ldr	r3, [r7, #0x3c]
 800e178: 63bb         	str	r3, [r7, #0x38]
; 	return &_kernel.ready_q.runq;
 800e17a: 4b51         	ldr	r3, [pc, #0x144]        @ 0x800e2c0 <halt_thread+0x1a8>
 800e17c: 637b         	str	r3, [r7, #0x34]
 800e17e: 6bfb         	ldr	r3, [r7, #0x3c]
 800e180: 633b         	str	r3, [r7, #0x30]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800e182: 6b3b         	ldr	r3, [r7, #0x30]
 800e184: 4618         	mov	r0, r3
 800e186: f00a f873    	bl	0x8018270 <sys_dlist_remove> @ imm = #0xa0e6
; }
 800e18a: bf00         	nop
; }
 800e18c: bf00         	nop
; }
 800e18e: bf00         	nop
; 		if (new_state == _THREAD_DEAD) {
 800e190: 78fb         	ldrb	r3, [r7, #0x3]
 800e192: 2b08         	cmp	r3, #0x8
 800e194: d121         	bne	0x800e1da <halt_thread+0xc2> @ imm = #0x42
; 			if (thread->base.pended_on != NULL) {
 800e196: 687b         	ldr	r3, [r7, #0x4]
 800e198: 689b         	ldr	r3, [r3, #0x8]
 800e19a: 2b00         	cmp	r3, #0x0
 800e19c: d002         	beq	0x800e1a4 <halt_thread+0x8c> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 800e19e: 6878         	ldr	r0, [r7, #0x4]
 800e1a0: f00a f9c9    	bl	0x8018536 <unpend_thread_no_timeout> @ imm = #0xa392
; 			(void)z_abort_thread_timeout(thread);
 800e1a4: 6878         	ldr	r0, [r7, #0x4]
 800e1a6: f00a f8a3    	bl	0x80182f0 <z_abort_thread_timeout> @ imm = #0xa146
; 			unpend_all(&thread->join_queue);
 800e1aa: 687b         	ldr	r3, [r7, #0x4]
 800e1ac: 3368         	adds	r3, #0x68
 800e1ae: 4618         	mov	r0, r3
 800e1b0: f00a fb9d    	bl	0x80188ee <unpend_all>  @ imm = #0xa73a
; 			if (thread == _current && arch_is_in_isr()) {
 800e1b4: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800e2c4 <halt_thread+0x1ac>
 800e1b6: 689b         	ldr	r3, [r3, #0x8]
 800e1b8: 687a         	ldr	r2, [r7, #0x4]
 800e1ba: 429a         	cmp	r2, r3
 800e1bc: d10d         	bne	0x800e1da <halt_thread+0xc2> @ imm = #0x1a
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800e1be: f3ef 8305    	mrs	r3, ipsr
 800e1c2: 62fb         	str	r3, [r7, #0x2c]
;   return(result);
 800e1c4: 6afb         	ldr	r3, [r7, #0x2c]
; 	return (__get_IPSR()) ? (true) : (false);
 800e1c6: 2b00         	cmp	r3, #0x0
 800e1c8: bf14         	ite	ne
 800e1ca: 2301         	movne	r3, #0x1
 800e1cc: 2300         	moveq	r3, #0x0
 800e1ce: b2db         	uxtb	r3, r3
; 			if (thread == _current && arch_is_in_isr()) {
 800e1d0: 2b00         	cmp	r3, #0x0
 800e1d2: d002         	beq	0x800e1da <halt_thread+0xc2> @ imm = #0x4
; 				dummify = true;
 800e1d4: 2301         	movs	r3, #0x1
 800e1d6: f887 3047    	strb.w	r3, [r7, #0x47]
 800e1da: 2301         	movs	r3, #0x1
 800e1dc: 62bb         	str	r3, [r7, #0x28]
; 	return &_kernel.ready_q.runq;
 800e1de: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x800e2c0 <halt_thread+0x1a8>
 800e1e0: 627b         	str	r3, [r7, #0x24]
; 	struct k_thread *thread = NULL;
 800e1e2: 2300         	movs	r3, #0x0
 800e1e4: 623b         	str	r3, [r7, #0x20]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800e1e6: 6a78         	ldr	r0, [r7, #0x24]
 800e1e8: f009 ffd8    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0x9fb0
 800e1ec: 61f8         	str	r0, [r7, #0x1c]
; 	if (n != NULL) {
 800e1ee: 69fb         	ldr	r3, [r7, #0x1c]
 800e1f0: 2b00         	cmp	r3, #0x0
 800e1f2: d001         	beq	0x800e1f8 <halt_thread+0xe0> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800e1f4: 69fb         	ldr	r3, [r7, #0x1c]
 800e1f6: 623b         	str	r3, [r7, #0x20]
; 	return thread;
 800e1f8: 6a3b         	ldr	r3, [r7, #0x20]
; 	return _priq_run_best(curr_cpu_runq());
 800e1fa: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800e1fc: 61bb         	str	r3, [r7, #0x18]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800e1fe: 69bb         	ldr	r3, [r7, #0x18]
 800e200: 2b00         	cmp	r3, #0x0
 800e202: d102         	bne	0x800e20a <halt_thread+0xf2> @ imm = #0x4
 800e204: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800e2c4 <halt_thread+0x1ac>
 800e206: 68db         	ldr	r3, [r3, #0xc]
 800e208: e000         	b	0x800e20c <halt_thread+0xf4> @ imm = #0x0
 800e20a: 69bb         	ldr	r3, [r7, #0x18]
; 	struct k_thread *thread = next_up();
 800e20c: 617b         	str	r3, [r7, #0x14]
 800e20e: 697b         	ldr	r3, [r7, #0x14]
 800e210: 613b         	str	r3, [r7, #0x10]
 800e212: 6abb         	ldr	r3, [r7, #0x28]
 800e214: 60fb         	str	r3, [r7, #0xc]
; 	if (preempt_ok != 0) {
 800e216: 68fb         	ldr	r3, [r7, #0xc]
 800e218: 2b00         	cmp	r3, #0x0
 800e21a: d001         	beq	0x800e220 <halt_thread+0x108> @ imm = #0x2
; 		return true;
 800e21c: 2301         	movs	r3, #0x1
 800e21e: e022         	b	0x800e266 <halt_thread+0x14e> @ imm = #0x44
; 	if (z_is_thread_prevented_from_running(_current)) {
 800e220: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800e2c4 <halt_thread+0x1ac>
 800e222: 689b         	ldr	r3, [r3, #0x8]
 800e224: 4618         	mov	r0, r3
 800e226: f00a f88b    	bl	0x8018340 <z_is_thread_prevented_from_running> @ imm = #0xa116
 800e22a: 4603         	mov	r3, r0
 800e22c: 2b00         	cmp	r3, #0x0
 800e22e: d001         	beq	0x800e234 <halt_thread+0x11c> @ imm = #0x2
; 		return true;
 800e230: 2301         	movs	r3, #0x1
 800e232: e018         	b	0x800e266 <halt_thread+0x14e> @ imm = #0x30
; 	if (thread_is_preemptible(_current) || thread_is_metairq(thread)) {
 800e234: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800e2c4 <halt_thread+0x1ac>
 800e236: 689b         	ldr	r3, [r3, #0x8]
 800e238: 4618         	mov	r0, r3
 800e23a: f00a f867    	bl	0x801830c <thread_is_preemptible> @ imm = #0xa0ce
 800e23e: 4603         	mov	r3, r0
 800e240: 2b00         	cmp	r3, #0x0
 800e242: d105         	bne	0x800e250 <halt_thread+0x138> @ imm = #0xa
 800e244: 6938         	ldr	r0, [r7, #0x10]
 800e246: f00a f871    	bl	0x801832c <thread_is_metairq> @ imm = #0xa0e2
 800e24a: 4603         	mov	r3, r0
 800e24c: 2b00         	cmp	r3, #0x0
 800e24e: d001         	beq	0x800e254 <halt_thread+0x13c> @ imm = #0x2
; 		return true;
 800e250: 2301         	movs	r3, #0x1
 800e252: e008         	b	0x800e266 <halt_thread+0x14e> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800e254: 6938         	ldr	r0, [r7, #0x10]
 800e256: f00a f887    	bl	0x8018368 <z_is_thread_timeout_active> @ imm = #0xa10e
 800e25a: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800e25c: 2b00         	cmp	r3, #0x0
 800e25e: d001         	beq	0x800e264 <halt_thread+0x14c> @ imm = #0x2
; 		return true;
 800e260: 2301         	movs	r3, #0x1
 800e262: e000         	b	0x800e266 <halt_thread+0x14e> @ imm = #0x0
; 	return false;
 800e264: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800e266: 2b00         	cmp	r3, #0x0
 800e268: d00e         	beq	0x800e288 <halt_thread+0x170> @ imm = #0x1c
; 		if (thread != _current) {
 800e26a: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800e2c4 <halt_thread+0x1ac>
 800e26c: 689b         	ldr	r3, [r3, #0x8]
 800e26e: 697a         	ldr	r2, [r7, #0x14]
 800e270: 429a         	cmp	r2, r3
 800e272: d002         	beq	0x800e27a <halt_thread+0x162> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800e274: 6978         	ldr	r0, [r7, #0x14]
 800e276: f000 f9a7    	bl	0x800e5c8 <z_reset_time_slice> @ imm = #0x34e
; 		update_metairq_preempt(thread);
 800e27a: 6978         	ldr	r0, [r7, #0x14]
 800e27c: f00a fa0b    	bl	0x8018696 <update_metairq_preempt> @ imm = #0xa416
; 		_kernel.ready_q.cache = thread;
 800e280: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800e2c4 <halt_thread+0x1ac>
 800e282: 697b         	ldr	r3, [r7, #0x14]
 800e284: 61d3         	str	r3, [r2, #0x1c]
; }
 800e286: e003         	b	0x800e290 <halt_thread+0x178> @ imm = #0x6
; 		_kernel.ready_q.cache = _current;
 800e288: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800e2c4 <halt_thread+0x1ac>
 800e28a: 689b         	ldr	r3, [r3, #0x8]
 800e28c: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800e2c4 <halt_thread+0x1ac>
 800e28e: 61d3         	str	r3, [r2, #0x1c]
; }
 800e290: bf00         	nop
; 		if (new_state == _THREAD_SUSPENDED) {
 800e292: 78fb         	ldrb	r3, [r7, #0x3]
 800e294: 2b10         	cmp	r3, #0x10
 800e296: d103         	bne	0x800e2a0 <halt_thread+0x188> @ imm = #0x6
; 			clear_halting(thread);
 800e298: 6878         	ldr	r0, [r7, #0x4]
 800e29a: f00a f9e7    	bl	0x801866c <clear_halting> @ imm = #0xa3ce
; 			return;
 800e29e: e00c         	b	0x800e2ba <halt_thread+0x1a2> @ imm = #0x18
; 		z_thread_monitor_exit(thread);
 800e2a0: 6878         	ldr	r0, [r7, #0x4]
 800e2a2: f000 fa45    	bl	0x800e730 <z_thread_monitor_exit> @ imm = #0x48a
; 		if (dummify && !IS_ENABLED(CONFIG_ARCH_POSIX)) {
 800e2a6: f897 3047    	ldrb.w	r3, [r7, #0x47]
 800e2aa: 2b00         	cmp	r3, #0x0
 800e2ac: d002         	beq	0x800e2b4 <halt_thread+0x19c> @ imm = #0x4
; 			z_dummy_thread_init(&_thread_dummy);
 800e2ae: 4806         	ldr	r0, [pc, #0x18]         @ 0x800e2c8 <halt_thread+0x1b0>
 800e2b0: f7fe fdf2    	bl	0x800ce98 <z_dummy_thread_init> @ imm = #-0x141c
; 		clear_halting(thread);
 800e2b4: 6878         	ldr	r0, [r7, #0x4]
 800e2b6: f00a f9d9    	bl	0x801866c <clear_halting> @ imm = #0xa3b2
; }
 800e2ba: 3748         	adds	r7, #0x48
 800e2bc: 46bd         	mov	sp, r7
 800e2be: bd80         	pop	{r7, pc}

0800e2c0 <$d>:
 800e2c0: e8 06 00 20  	.word	0x200006e8
 800e2c4: c8 06 00 20  	.word	0x200006c8
 800e2c8: a8 08 00 20  	.word	0x200008a8

0800e2cc <z_thread_abort>:
; {
 800e2cc: b580         	push	{r7, lr}
 800e2ce: b094         	sub	sp, #0x50
 800e2d0: af00         	add	r7, sp, #0x0
 800e2d2: 6078         	str	r0, [r7, #0x4]
 800e2d4: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x800e398 <z_thread_abort+0xcc>
 800e2d6: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e2d8: f3ef 8311    	mrs	r3, basepri
 800e2dc: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800e2de: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 800e2e0: 647b         	str	r3, [r7, #0x44]
 800e2e2: 2310         	movs	r3, #0x10
 800e2e4: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e2e6: 6c3b         	ldr	r3, [r7, #0x40]
 800e2e8: f383 8812    	msr	basepri_max, r3
; }
 800e2ec: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e2ee: f3bf 8f6f    	isb	sy
; }
 800e2f2: bf00         	nop
; 	return key;
 800e2f4: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 800e2f6: 60bb         	str	r3, [r7, #0x8]
 800e2f8: 6cfb         	ldr	r3, [r7, #0x4c]
 800e2fa: 63fb         	str	r3, [r7, #0x3c]
; }
 800e2fc: bf00         	nop
 800e2fe: 6cfb         	ldr	r3, [r7, #0x4c]
 800e300: 63bb         	str	r3, [r7, #0x38]
; }
 800e302: bf00         	nop
; 	return k;
 800e304: 68bb         	ldr	r3, [r7, #0x8]
 800e306: 617b         	str	r3, [r7, #0x14]
; 	if (z_is_thread_essential(thread)) {
 800e308: 6878         	ldr	r0, [r7, #0x4]
 800e30a: f00a f8e9    	bl	0x80184e0 <z_is_thread_essential> @ imm = #0xa1d2
 800e30e: 4603         	mov	r3, r0
 800e310: 2b00         	cmp	r3, #0x0
 800e312: d020         	beq	0x800e356 <z_thread_abort+0x8a> @ imm = #0x40
 800e314: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800e398 <z_thread_abort+0xcc>
 800e316: 62fb         	str	r3, [r7, #0x2c]
 800e318: 697b         	ldr	r3, [r7, #0x14]
 800e31a: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800e31c: 68fb         	ldr	r3, [r7, #0xc]
 800e31e: 62bb         	str	r3, [r7, #0x28]
 800e320: 6abb         	ldr	r3, [r7, #0x28]
 800e322: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e324: 6a7b         	ldr	r3, [r7, #0x24]
 800e326: f383 8811    	msr	basepri, r3
; }
 800e32a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e32c: f3bf 8f6f    	isb	sy
; }
 800e330: bf00         	nop
; }
 800e332: bf00         	nop
; }
 800e334: bf00         	nop
 800e336: 2300         	movs	r3, #0x0
 800e338: 637b         	str	r3, [r7, #0x34]
 800e33a: 6b7b         	ldr	r3, [r7, #0x34]
 800e33c: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e33e: 6b3b         	ldr	r3, [r7, #0x30]
 800e340: f383 8811    	msr	basepri, r3
; }
 800e344: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e346: f3bf 8f6f    	isb	sy
; }
 800e34a: bf00         	nop
; }
 800e34c: bf00         	nop
; 		k_panic();
 800e34e: 2304         	movs	r3, #0x4
 800e350: 4618         	mov	r0, r3
 800e352: df02         	svc	#0x2
; 		return;
 800e354: e01c         	b	0x800e390 <z_thread_abort+0xc4> @ imm = #0x38
; 	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 800e356: 687b         	ldr	r3, [r7, #0x4]
 800e358: 7b5b         	ldrb	r3, [r3, #0xd]
 800e35a: f003 0308    	and	r3, r3, #0x8
 800e35e: 2b00         	cmp	r3, #0x0
 800e360: d011         	beq	0x800e386 <z_thread_abort+0xba> @ imm = #0x22
 800e362: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e398 <z_thread_abort+0xcc>
 800e364: 623b         	str	r3, [r7, #0x20]
 800e366: 697b         	ldr	r3, [r7, #0x14]
 800e368: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800e36a: 693b         	ldr	r3, [r7, #0x10]
 800e36c: 61fb         	str	r3, [r7, #0x1c]
 800e36e: 69fb         	ldr	r3, [r7, #0x1c]
 800e370: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e372: 69bb         	ldr	r3, [r7, #0x18]
 800e374: f383 8811    	msr	basepri, r3
; }
 800e378: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e37a: f3bf 8f6f    	isb	sy
; }
 800e37e: bf00         	nop
; }
 800e380: bf00         	nop
; }
 800e382: bf00         	nop
; 		return;
 800e384: e004         	b	0x800e390 <z_thread_abort+0xc4> @ imm = #0x8
; 	z_thread_halt(thread, key, true);
 800e386: 2201         	movs	r2, #0x1
 800e388: 6979         	ldr	r1, [r7, #0x14]
 800e38a: 6878         	ldr	r0, [r7, #0x4]
 800e38c: f7ff f840    	bl	0x800d410 <z_thread_halt> @ imm = #-0xf80
; }
 800e390: 3750         	adds	r7, #0x50
 800e392: 46bd         	mov	sp, r7
 800e394: bd80         	pop	{r7, pc}
 800e396: bf00         	nop

0800e398 <$d>:
 800e398: e8 10 00 20  	.word	0x200010e8

0800e39c <z_sched_wake>:
; {
 800e39c: b580         	push	{r7, lr}
 800e39e: b09c         	sub	sp, #0x70
 800e3a0: af00         	add	r7, sp, #0x0
 800e3a2: 60f8         	str	r0, [r7, #0xc]
 800e3a4: 60b9         	str	r1, [r7, #0x8]
 800e3a6: 607a         	str	r2, [r7, #0x4]
; 	bool ret = false;
 800e3a8: 2300         	movs	r3, #0x0
 800e3aa: f887 306f    	strb.w	r3, [r7, #0x6f]
; 	K_SPINLOCK(&_sched_spinlock) {
 800e3ae: 2300         	movs	r3, #0x0
 800e3b0: 623b         	str	r3, [r7, #0x20]
 800e3b2: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x800e484 <z_sched_wake+0xe8>
 800e3b4: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e3b6: f3ef 8311    	mrs	r3, basepri
 800e3ba: 663b         	str	r3, [r7, #0x60]
;   return(result);
 800e3bc: 6e3b         	ldr	r3, [r7, #0x60]
; 	key = __get_BASEPRI();
 800e3be: 65fb         	str	r3, [r7, #0x5c]
 800e3c0: 2310         	movs	r3, #0x10
 800e3c2: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e3c4: 6dbb         	ldr	r3, [r7, #0x58]
 800e3c6: f383 8812    	msr	basepri_max, r3
; }
 800e3ca: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e3cc: f3bf 8f6f    	isb	sy
; }
 800e3d0: bf00         	nop
; 	return key;
 800e3d2: 6dfb         	ldr	r3, [r7, #0x5c]
; 	k.key = arch_irq_lock();
 800e3d4: 617b         	str	r3, [r7, #0x14]
 800e3d6: 6e7b         	ldr	r3, [r7, #0x64]
 800e3d8: 657b         	str	r3, [r7, #0x54]
; }
 800e3da: bf00         	nop
 800e3dc: 6e7b         	ldr	r3, [r7, #0x64]
 800e3de: 653b         	str	r3, [r7, #0x50]
; }
 800e3e0: bf00         	nop
; 	return k;
 800e3e2: 697b         	ldr	r3, [r7, #0x14]
 800e3e4: 61fb         	str	r3, [r7, #0x1c]
; 	K_SPINLOCK(&_sched_spinlock) {
 800e3e6: e043         	b	0x800e470 <z_sched_wake+0xd4> @ imm = #0x86
; 		thread = _priq_wait_best(&wait_q->waitq);
 800e3e8: 68fb         	ldr	r3, [r7, #0xc]
 800e3ea: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800e3ec: 2300         	movs	r3, #0x0
 800e3ee: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800e3f0: 6cf8         	ldr	r0, [r7, #0x4c]
 800e3f2: f009 fed3    	bl	0x801819c <sys_dlist_peek_head> @ imm = #0x9da6
 800e3f6: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800e3f8: 6c7b         	ldr	r3, [r7, #0x44]
 800e3fa: 2b00         	cmp	r3, #0x0
 800e3fc: d001         	beq	0x800e402 <z_sched_wake+0x66> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800e3fe: 6c7b         	ldr	r3, [r7, #0x44]
 800e400: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800e402: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800e404: 66bb         	str	r3, [r7, #0x68]
; 		if (thread != NULL) {
 800e406: 6ebb         	ldr	r3, [r7, #0x68]
 800e408: 2b00         	cmp	r3, #0x0
 800e40a: d01e         	beq	0x800e44a <z_sched_wake+0xae> @ imm = #0x3c
; 			z_thread_return_value_set_with_data(thread,
 800e40c: 68bb         	ldr	r3, [r7, #0x8]
 800e40e: 6eba         	ldr	r2, [r7, #0x68]
 800e410: 643a         	str	r2, [r7, #0x40]
 800e412: 63fb         	str	r3, [r7, #0x3c]
 800e414: 687b         	ldr	r3, [r7, #0x4]
 800e416: 63bb         	str	r3, [r7, #0x38]
 800e418: 6c3b         	ldr	r3, [r7, #0x40]
 800e41a: 637b         	str	r3, [r7, #0x34]
 800e41c: 6bfb         	ldr	r3, [r7, #0x3c]
 800e41e: 633b         	str	r3, [r7, #0x30]
; 	thread->arch.swap_return_value = value;
 800e420: 6b7b         	ldr	r3, [r7, #0x34]
 800e422: 6b3a         	ldr	r2, [r7, #0x30]
 800e424: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800e428: bf00         	nop
; 	thread->base.swap_data = data;
 800e42a: 6c3b         	ldr	r3, [r7, #0x40]
 800e42c: 6bba         	ldr	r2, [r7, #0x38]
 800e42e: 615a         	str	r2, [r3, #0x14]
; }
 800e430: bf00         	nop
; 			unpend_thread_no_timeout(thread);
 800e432: 6eb8         	ldr	r0, [r7, #0x68]
 800e434: f00a f87f    	bl	0x8018536 <unpend_thread_no_timeout> @ imm = #0xa0fe
; 			(void)z_abort_thread_timeout(thread);
 800e438: 6eb8         	ldr	r0, [r7, #0x68]
 800e43a: f009 ff59    	bl	0x80182f0 <z_abort_thread_timeout> @ imm = #0x9eb2
; 			ready_thread(thread);
 800e43e: 6eb8         	ldr	r0, [r7, #0x68]
 800e440: f7fe fe30    	bl	0x800d0a4 <ready_thread> @ imm = #-0x13a0
; 			ret = true;
 800e444: 2301         	movs	r3, #0x1
 800e446: f887 306f    	strb.w	r3, [r7, #0x6f]
 800e44a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800e484 <z_sched_wake+0xe8>
 800e44c: 62fb         	str	r3, [r7, #0x2c]
 800e44e: 69fb         	ldr	r3, [r7, #0x1c]
 800e450: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800e452: 69bb         	ldr	r3, [r7, #0x18]
 800e454: 62bb         	str	r3, [r7, #0x28]
 800e456: 6abb         	ldr	r3, [r7, #0x28]
 800e458: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e45a: 6a7b         	ldr	r3, [r7, #0x24]
 800e45c: f383 8811    	msr	basepri, r3
; }
 800e460: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e462: f3bf 8f6f    	isb	sy
; }
 800e466: bf00         	nop
; }
 800e468: bf00         	nop
; }
 800e46a: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800e46c: 2301         	movs	r3, #0x1
 800e46e: 623b         	str	r3, [r7, #0x20]
 800e470: 6a3b         	ldr	r3, [r7, #0x20]
 800e472: 2b00         	cmp	r3, #0x0
 800e474: d0b8         	beq	0x800e3e8 <z_sched_wake+0x4c> @ imm = #-0x90
; 	return ret;
 800e476: f897 306f    	ldrb.w	r3, [r7, #0x6f]
; }
 800e47a: 4618         	mov	r0, r3
 800e47c: 3770         	adds	r7, #0x70
 800e47e: 46bd         	mov	sp, r7
 800e480: bd80         	pop	{r7, pc}
 800e482: bf00         	nop

0800e484 <$d>:
 800e484: e8 10 00 20  	.word	0x200010e8

0800e488 <z_sched_wait>:
; {
 800e488: b580         	push	{r7, lr}
 800e48a: b088         	sub	sp, #0x20
 800e48c: af02         	add	r7, sp, #0x8
 800e48e: 60f8         	str	r0, [r7, #0xc]
 800e490: 60b9         	str	r1, [r7, #0x8]
 800e492: 607a         	str	r2, [r7, #0x4]
; 	int ret = z_pend_curr(lock, key, wait_q, timeout);
 800e494: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 800e498: e9cd 2300    	strd	r2, r3, [sp]
 800e49c: 687a         	ldr	r2, [r7, #0x4]
 800e49e: 68b9         	ldr	r1, [r7, #0x8]
 800e4a0: 68f8         	ldr	r0, [r7, #0xc]
 800e4a2: f7ff f98f    	bl	0x800d7c4 <z_pend_curr> @ imm = #-0xce2
 800e4a6: 6178         	str	r0, [r7, #0x14]
; 	if (data != NULL) {
 800e4a8: 6abb         	ldr	r3, [r7, #0x28]
 800e4aa: 2b00         	cmp	r3, #0x0
 800e4ac: d004         	beq	0x800e4b8 <z_sched_wait+0x30> @ imm = #0x8
; 		*data = _current->base.swap_data;
 800e4ae: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800e4c4 <z_sched_wait+0x3c>
 800e4b0: 689b         	ldr	r3, [r3, #0x8]
 800e4b2: 695a         	ldr	r2, [r3, #0x14]
 800e4b4: 6abb         	ldr	r3, [r7, #0x28]
 800e4b6: 601a         	str	r2, [r3]
; 	return ret;
 800e4b8: 697b         	ldr	r3, [r7, #0x14]
; }
 800e4ba: 4618         	mov	r0, r3
 800e4bc: 3718         	adds	r7, #0x18
 800e4be: 46bd         	mov	sp, r7
 800e4c0: bd80         	pop	{r7, pc}
 800e4c2: bf00         	nop

0800e4c4 <$d>:
 800e4c4: c8 06 00 20  	.word	0x200006c8

0800e4c8 <z_is_idle_thread_object>:
; {
 800e4c8: b480         	push	{r7}
 800e4ca: b083         	sub	sp, #0xc
 800e4cc: af00         	add	r7, sp, #0x0
 800e4ce: 6078         	str	r0, [r7, #0x4]
; 	return thread == &z_idle_threads[0];
 800e4d0: 687b         	ldr	r3, [r7, #0x4]
 800e4d2: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800e4e8 <z_is_idle_thread_object+0x20>
 800e4d4: 4293         	cmp	r3, r2
 800e4d6: bf0c         	ite	eq
 800e4d8: 2301         	moveq	r3, #0x1
 800e4da: 2300         	movne	r3, #0x0
 800e4dc: b2db         	uxtb	r3, r3
; }
 800e4de: 4618         	mov	r0, r3
 800e4e0: 370c         	adds	r7, #0xc
 800e4e2: 46bd         	mov	sp, r7
 800e4e4: bc80         	pop	{r7}
 800e4e6: 4770         	bx	lr

0800e4e8 <$d>:
 800e4e8: d8 07 00 20  	.word	0x200007d8

0800e4ec <slice_time>:
; {
 800e4ec: b480         	push	{r7}
 800e4ee: b085         	sub	sp, #0x14
 800e4f0: af00         	add	r7, sp, #0x0
 800e4f2: 6078         	str	r0, [r7, #0x4]
; 	int ret = slice_ticks;
 800e4f4: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800e508 <slice_time+0x1c>
 800e4f6: 681b         	ldr	r3, [r3]
 800e4f8: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800e4fa: 68fb         	ldr	r3, [r7, #0xc]
; }
 800e4fc: 4618         	mov	r0, r3
 800e4fe: 3714         	adds	r7, #0x14
 800e500: 46bd         	mov	sp, r7
 800e502: bc80         	pop	{r7}
 800e504: 4770         	bx	lr
 800e506: bf00         	nop

0800e508 <$d>:
 800e508: e8 10 00 20  	.word	0x200010e8

0800e50c <thread_is_sliceable>:
; {
 800e50c: b580         	push	{r7, lr}
 800e50e: b084         	sub	sp, #0x10
 800e510: af00         	add	r7, sp, #0x0
 800e512: 6078         	str	r0, [r7, #0x4]
; 	bool ret = thread_is_preemptible(thread)
 800e514: 6878         	ldr	r0, [r7, #0x4]
 800e516: f00a fa11    	bl	0x801893c <thread_is_preemptible> @ imm = #0xa422
 800e51a: 4603         	mov	r3, r0
; 		&& !z_is_idle_thread_object(thread);
 800e51c: 2b00         	cmp	r3, #0x0
 800e51e: d029         	beq	0x800e574 <thread_is_sliceable+0x68> @ imm = #0x52
; 		&& slice_time(thread) != 0
 800e520: 6878         	ldr	r0, [r7, #0x4]
 800e522: f7ff ffe3    	bl	0x800e4ec <slice_time>  @ imm = #-0x3a
 800e526: 4603         	mov	r3, r0
 800e528: 2b00         	cmp	r3, #0x0
 800e52a: d023         	beq	0x800e574 <thread_is_sliceable+0x68> @ imm = #0x46
; 		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 800e52c: 687b         	ldr	r3, [r7, #0x4]
 800e52e: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800e532: 461a         	mov	r2, r3
 800e534: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800e58c <thread_is_sliceable+0x80>
 800e536: 681b         	ldr	r3, [r3]
 800e538: 4619         	mov	r1, r3
 800e53a: 4610         	mov	r0, r2
 800e53c: f00a fa33    	bl	0x80189a6 <z_is_prio_higher> @ imm = #0xa466
 800e540: 4603         	mov	r3, r0
 800e542: f083 0301    	eor	r3, r3, #0x1
 800e546: b2db         	uxtb	r3, r3
 800e548: 2b00         	cmp	r3, #0x0
 800e54a: d013         	beq	0x800e574 <thread_is_sliceable+0x68> @ imm = #0x26
; 		&& !z_is_thread_prevented_from_running(thread)
 800e54c: 6878         	ldr	r0, [r7, #0x4]
 800e54e: f00a fa05    	bl	0x801895c <z_is_thread_prevented_from_running> @ imm = #0xa40a
 800e552: 4603         	mov	r3, r0
 800e554: f083 0301    	eor	r3, r3, #0x1
 800e558: b2db         	uxtb	r3, r3
 800e55a: 2b00         	cmp	r3, #0x0
 800e55c: d00a         	beq	0x800e574 <thread_is_sliceable+0x68> @ imm = #0x14
; 		&& !z_is_idle_thread_object(thread);
 800e55e: 6878         	ldr	r0, [r7, #0x4]
 800e560: f7ff ffb2    	bl	0x800e4c8 <z_is_idle_thread_object> @ imm = #-0x9c
 800e564: 4603         	mov	r3, r0
 800e566: f083 0301    	eor	r3, r3, #0x1
 800e56a: b2db         	uxtb	r3, r3
 800e56c: 2b00         	cmp	r3, #0x0
 800e56e: d001         	beq	0x800e574 <thread_is_sliceable+0x68> @ imm = #0x2
 800e570: 2301         	movs	r3, #0x1
 800e572: e000         	b	0x800e576 <thread_is_sliceable+0x6a> @ imm = #0x0
 800e574: 2300         	movs	r3, #0x0
; 	bool ret = thread_is_preemptible(thread)
 800e576: 73fb         	strb	r3, [r7, #0xf]
 800e578: 7bfb         	ldrb	r3, [r7, #0xf]
 800e57a: f003 0301    	and	r3, r3, #0x1
 800e57e: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 800e580: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 800e582: 4618         	mov	r0, r3
 800e584: 3710         	adds	r7, #0x10
 800e586: 46bd         	mov	sp, r7
 800e588: bd80         	pop	{r7, pc}
 800e58a: bf00         	nop

0800e58c <$d>:
 800e58c: ec 10 00 20  	.word	0x200010ec

0800e590 <slice_timeout>:
; {
 800e590: b480         	push	{r7}
 800e592: b085         	sub	sp, #0x14
 800e594: af00         	add	r7, sp, #0x0
 800e596: 6078         	str	r0, [r7, #0x4]
; 	int cpu = ARRAY_INDEX(slice_timeouts, timeout);
 800e598: 687b         	ldr	r3, [r7, #0x4]
 800e59a: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800e5bc <slice_timeout+0x2c>
 800e59c: 1a9b         	subs	r3, r3, r2
 800e59e: 10db         	asrs	r3, r3, #0x3
 800e5a0: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800e5c0 <slice_timeout+0x30>
 800e5a2: fb02 f303    	mul	r3, r2, r3
 800e5a6: 60fb         	str	r3, [r7, #0xc]
; 	slice_expired[cpu] = true;
 800e5a8: 4a06         	ldr	r2, [pc, #0x18]         @ 0x800e5c4 <slice_timeout+0x34>
 800e5aa: 68fb         	ldr	r3, [r7, #0xc]
 800e5ac: 4413         	add	r3, r2
 800e5ae: 2201         	movs	r2, #0x1
 800e5b0: 701a         	strb	r2, [r3]
; }
 800e5b2: bf00         	nop
 800e5b4: 3714         	adds	r7, #0x14
 800e5b6: 46bd         	mov	sp, r7
 800e5b8: bc80         	pop	{r7}
 800e5ba: 4770         	bx	lr

0800e5bc <$d>:
 800e5bc: 78 09 00 20  	.word	0x20000978
 800e5c0: ab aa aa aa  	.word	0xaaaaaaab
 800e5c4: f0 10 00 20  	.word	0x200010f0

0800e5c8 <z_reset_time_slice>:
; {
 800e5c8: e92d 4390    	push.w	{r4, r7, r8, r9, lr}
 800e5cc: b085         	sub	sp, #0x14
 800e5ce: af00         	add	r7, sp, #0x0
 800e5d0: 6078         	str	r0, [r7, #0x4]
; 	int cpu = _current_cpu->id;
 800e5d2: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800e638 <z_reset_time_slice+0x70>
 800e5d4: 7c1b         	ldrb	r3, [r3, #0x10]
 800e5d6: 60fb         	str	r3, [r7, #0xc]
; 	z_abort_timeout(&slice_timeouts[cpu]);
 800e5d8: 68fa         	ldr	r2, [r7, #0xc]
 800e5da: 4613         	mov	r3, r2
 800e5dc: 005b         	lsls	r3, r3, #0x1
 800e5de: 4413         	add	r3, r2
 800e5e0: 00db         	lsls	r3, r3, #0x3
 800e5e2: 4a16         	ldr	r2, [pc, #0x58]         @ 0x800e63c <z_reset_time_slice+0x74>
 800e5e4: 4413         	add	r3, r2
 800e5e6: 4618         	mov	r0, r3
 800e5e8: f000 fa48    	bl	0x800ea7c <z_abort_timeout> @ imm = #0x490
; 	slice_expired[cpu] = false;
 800e5ec: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800e640 <z_reset_time_slice+0x78>
 800e5ee: 68fb         	ldr	r3, [r7, #0xc]
 800e5f0: 4413         	add	r3, r2
 800e5f2: 2200         	movs	r2, #0x0
 800e5f4: 701a         	strb	r2, [r3]
; 	if (thread_is_sliceable(thread)) {
 800e5f6: 6878         	ldr	r0, [r7, #0x4]
 800e5f8: f7ff ff88    	bl	0x800e50c <thread_is_sliceable> @ imm = #-0xf0
 800e5fc: 4603         	mov	r3, r0
 800e5fe: 2b00         	cmp	r3, #0x0
 800e600: d014         	beq	0x800e62c <z_reset_time_slice+0x64> @ imm = #0x28
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 800e602: 68fa         	ldr	r2, [r7, #0xc]
 800e604: 4613         	mov	r3, r2
 800e606: 005b         	lsls	r3, r3, #0x1
 800e608: 4413         	add	r3, r2
 800e60a: 00db         	lsls	r3, r3, #0x3
 800e60c: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800e63c <z_reset_time_slice+0x74>
 800e60e: 189c         	adds	r4, r3, r2
; 			      K_TICKS(slice_time(thread) - 1));
 800e610: 6878         	ldr	r0, [r7, #0x4]
 800e612: f7ff ff6b    	bl	0x800e4ec <slice_time>  @ imm = #-0x12a
 800e616: 4603         	mov	r3, r0
 800e618: 3b01         	subs	r3, #0x1
 800e61a: 17da         	asrs	r2, r3, #0x1f
 800e61c: 4698         	mov	r8, r3
 800e61e: 4691         	mov	r9, r2
 800e620: 4642         	mov	r2, r8
 800e622: 464b         	mov	r3, r9
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 800e624: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800e644 <z_reset_time_slice+0x7c>
 800e626: 4620         	mov	r0, r4
 800e628: f000 f930    	bl	0x800e88c <z_add_timeout> @ imm = #0x260
; }
 800e62c: bf00         	nop
 800e62e: 3714         	adds	r7, #0x14
 800e630: 46bd         	mov	sp, r7
 800e632: e8bd 8390    	pop.w	{r4, r7, r8, r9, pc}
 800e636: bf00         	nop

0800e638 <$d>:
 800e638: c8 06 00 20  	.word	0x200006c8
 800e63c: 78 09 00 20  	.word	0x20000978
 800e640: f0 10 00 20  	.word	0x200010f0
 800e644: 91 e5 00 08  	.word	0x0800e591

0800e648 <z_time_slice>:
; {
 800e648: b580         	push	{r7, lr}
 800e64a: b092         	sub	sp, #0x48
 800e64c: af00         	add	r7, sp, #0x0
 800e64e: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x800e720 <z_time_slice+0xd8>
 800e650: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e652: f3ef 8311    	mrs	r3, basepri
 800e656: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800e658: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 800e65a: 63bb         	str	r3, [r7, #0x38]
 800e65c: 2310         	movs	r3, #0x10
 800e65e: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e660: 6b7b         	ldr	r3, [r7, #0x34]
 800e662: f383 8812    	msr	basepri_max, r3
; }
 800e666: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e668: f3bf 8f6f    	isb	sy
; }
 800e66c: bf00         	nop
; 	return key;
 800e66e: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 800e670: 607b         	str	r3, [r7, #0x4]
 800e672: 6c3b         	ldr	r3, [r7, #0x40]
 800e674: 633b         	str	r3, [r7, #0x30]
; }
 800e676: bf00         	nop
 800e678: 6c3b         	ldr	r3, [r7, #0x40]
 800e67a: 62fb         	str	r3, [r7, #0x2c]
; }
 800e67c: bf00         	nop
; 	return k;
 800e67e: 687b         	ldr	r3, [r7, #0x4]
 800e680: 613b         	str	r3, [r7, #0x10]
; 	struct k_thread *curr = _current;
 800e682: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800e724 <z_time_slice+0xdc>
 800e684: 689b         	ldr	r3, [r3, #0x8]
 800e686: 647b         	str	r3, [r7, #0x44]
; 	if (pending_current == curr) {
 800e688: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800e728 <z_time_slice+0xe0>
 800e68a: 681b         	ldr	r3, [r3]
 800e68c: 6c7a         	ldr	r2, [r7, #0x44]
 800e68e: 429a         	cmp	r2, r3
 800e690: d113         	bne	0x800e6ba <z_time_slice+0x72> @ imm = #0x26
; 		z_reset_time_slice(curr);
 800e692: 6c78         	ldr	r0, [r7, #0x44]
 800e694: f7ff ff98    	bl	0x800e5c8 <z_reset_time_slice> @ imm = #-0xd0
 800e698: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800e720 <z_time_slice+0xd8>
 800e69a: 62bb         	str	r3, [r7, #0x28]
 800e69c: 693b         	ldr	r3, [r7, #0x10]
 800e69e: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800e6a0: 68bb         	ldr	r3, [r7, #0x8]
 800e6a2: 627b         	str	r3, [r7, #0x24]
 800e6a4: 6a7b         	ldr	r3, [r7, #0x24]
 800e6a6: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e6a8: 6a3b         	ldr	r3, [r7, #0x20]
 800e6aa: f383 8811    	msr	basepri, r3
; }
 800e6ae: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e6b0: f3bf 8f6f    	isb	sy
; }
 800e6b4: bf00         	nop
; }
 800e6b6: bf00         	nop
; }
 800e6b8: e02f         	b	0x800e71a <z_time_slice+0xd2> @ imm = #0x5e
; 	pending_current = NULL;
 800e6ba: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800e728 <z_time_slice+0xe0>
 800e6bc: 2200         	movs	r2, #0x0
 800e6be: 601a         	str	r2, [r3]
; 	if (slice_expired[_current_cpu->id] && thread_is_sliceable(curr)) {
 800e6c0: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800e724 <z_time_slice+0xdc>
 800e6c2: 7c1b         	ldrb	r3, [r3, #0x10]
 800e6c4: 461a         	mov	r2, r3
 800e6c6: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800e72c <z_time_slice+0xe4>
 800e6c8: 5c9b         	ldrb	r3, [r3, r2]
 800e6ca: 2b00         	cmp	r3, #0x0
 800e6cc: d014         	beq	0x800e6f8 <z_time_slice+0xb0> @ imm = #0x28
 800e6ce: 6c78         	ldr	r0, [r7, #0x44]
 800e6d0: f7ff ff1c    	bl	0x800e50c <thread_is_sliceable> @ imm = #-0x1c8
 800e6d4: 4603         	mov	r3, r0
 800e6d6: 2b00         	cmp	r3, #0x0
 800e6d8: d00e         	beq	0x800e6f8 <z_time_slice+0xb0> @ imm = #0x1c
; 		if (!z_is_thread_prevented_from_running(curr)) {
 800e6da: 6c78         	ldr	r0, [r7, #0x44]
 800e6dc: f00a f93e    	bl	0x801895c <z_is_thread_prevented_from_running> @ imm = #0xa27c
 800e6e0: 4603         	mov	r3, r0
 800e6e2: f083 0301    	eor	r3, r3, #0x1
 800e6e6: b2db         	uxtb	r3, r3
 800e6e8: 2b00         	cmp	r3, #0x0
 800e6ea: d002         	beq	0x800e6f2 <z_time_slice+0xaa> @ imm = #0x4
; 			move_thread_to_end_of_prio_q(curr);
 800e6ec: 6c78         	ldr	r0, [r7, #0x44]
 800e6ee: f7fe fbf3    	bl	0x800ced8 <move_thread_to_end_of_prio_q> @ imm = #-0x181a
; 		z_reset_time_slice(curr);
 800e6f2: 6c78         	ldr	r0, [r7, #0x44]
 800e6f4: f7ff ff68    	bl	0x800e5c8 <z_reset_time_slice> @ imm = #-0x130
 800e6f8: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800e720 <z_time_slice+0xd8>
 800e6fa: 61fb         	str	r3, [r7, #0x1c]
 800e6fc: 693b         	ldr	r3, [r7, #0x10]
 800e6fe: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800e700: 68fb         	ldr	r3, [r7, #0xc]
 800e702: 61bb         	str	r3, [r7, #0x18]
 800e704: 69bb         	ldr	r3, [r7, #0x18]
 800e706: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e708: 697b         	ldr	r3, [r7, #0x14]
 800e70a: f383 8811    	msr	basepri, r3
; }
 800e70e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e710: f3bf 8f6f    	isb	sy
; }
 800e714: bf00         	nop
; }
 800e716: bf00         	nop
; }
 800e718: bf00         	nop
; }
 800e71a: 3748         	adds	r7, #0x48
 800e71c: 46bd         	mov	sp, r7
 800e71e: bd80         	pop	{r7, pc}

0800e720 <$d>:
 800e720: e8 10 00 20  	.word	0x200010e8
 800e724: c8 06 00 20  	.word	0x200006c8
 800e728: f4 10 00 20  	.word	0x200010f4
 800e72c: f0 10 00 20  	.word	0x200010f0

0800e730 <z_thread_monitor_exit>:
; {
 800e730: b480         	push	{r7}
 800e732: b091         	sub	sp, #0x44
 800e734: af00         	add	r7, sp, #0x0
 800e736: 6078         	str	r0, [r7, #0x4]
 800e738: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800e7e4 <z_thread_monitor_exit+0xb4>
 800e73a: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e73c: f3ef 8311    	mrs	r3, basepri
 800e740: 637b         	str	r3, [r7, #0x34]
;   return(result);
 800e742: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 800e744: 633b         	str	r3, [r7, #0x30]
 800e746: 2310         	movs	r3, #0x10
 800e748: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e74a: 6afb         	ldr	r3, [r7, #0x2c]
 800e74c: f383 8812    	msr	basepri_max, r3
; }
 800e750: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e752: f3bf 8f6f    	isb	sy
; }
 800e756: bf00         	nop
; 	return key;
 800e758: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 800e75a: 60fb         	str	r3, [r7, #0xc]
 800e75c: 6bbb         	ldr	r3, [r7, #0x38]
 800e75e: 62bb         	str	r3, [r7, #0x28]
; }
 800e760: bf00         	nop
 800e762: 6bbb         	ldr	r3, [r7, #0x38]
 800e764: 627b         	str	r3, [r7, #0x24]
; }
 800e766: bf00         	nop
; 	return k;
 800e768: 68fb         	ldr	r3, [r7, #0xc]
 800e76a: 617b         	str	r3, [r7, #0x14]
; 	if (thread == _kernel.threads) {
 800e76c: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800e7e8 <z_thread_monitor_exit+0xb8>
 800e76e: 6a9b         	ldr	r3, [r3, #0x28]
 800e770: 687a         	ldr	r2, [r7, #0x4]
 800e772: 429a         	cmp	r2, r3
 800e774: d106         	bne	0x800e784 <z_thread_monitor_exit+0x54> @ imm = #0xc
; 		_kernel.threads = _kernel.threads->next_thread;
 800e776: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800e7e8 <z_thread_monitor_exit+0xb8>
 800e778: 6a9b         	ldr	r3, [r3, #0x28]
 800e77a: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 800e77e: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x800e7e8 <z_thread_monitor_exit+0xb8>
 800e780: 6293         	str	r3, [r2, #0x28]
 800e782: e019         	b	0x800e7b8 <z_thread_monitor_exit+0x88> @ imm = #0x32
; 		prev_thread = _kernel.threads;
 800e784: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800e7e8 <z_thread_monitor_exit+0xb8>
 800e786: 6a9b         	ldr	r3, [r3, #0x28]
 800e788: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 800e78a: e003         	b	0x800e794 <z_thread_monitor_exit+0x64> @ imm = #0x6
; 			prev_thread = prev_thread->next_thread;
 800e78c: 6bfb         	ldr	r3, [r7, #0x3c]
 800e78e: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 800e792: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 800e794: 6bfb         	ldr	r3, [r7, #0x3c]
 800e796: 2b00         	cmp	r3, #0x0
 800e798: d005         	beq	0x800e7a6 <z_thread_monitor_exit+0x76> @ imm = #0xa
; 			(thread != prev_thread->next_thread)) {
 800e79a: 6bfb         	ldr	r3, [r7, #0x3c]
 800e79c: f8d3 3090    	ldr.w	r3, [r3, #0x90]
; 		while ((prev_thread != NULL) &&
 800e7a0: 687a         	ldr	r2, [r7, #0x4]
 800e7a2: 429a         	cmp	r2, r3
 800e7a4: d1f2         	bne	0x800e78c <z_thread_monitor_exit+0x5c> @ imm = #-0x1c
; 		if (prev_thread != NULL) {
 800e7a6: 6bfb         	ldr	r3, [r7, #0x3c]
 800e7a8: 2b00         	cmp	r3, #0x0
 800e7aa: d005         	beq	0x800e7b8 <z_thread_monitor_exit+0x88> @ imm = #0xa
; 			prev_thread->next_thread = thread->next_thread;
 800e7ac: 687b         	ldr	r3, [r7, #0x4]
 800e7ae: f8d3 2090    	ldr.w	r2, [r3, #0x90]
 800e7b2: 6bfb         	ldr	r3, [r7, #0x3c]
 800e7b4: f8c3 2090    	str.w	r2, [r3, #0x90]
 800e7b8: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800e7e4 <z_thread_monitor_exit+0xb4>
 800e7ba: 623b         	str	r3, [r7, #0x20]
 800e7bc: 697b         	ldr	r3, [r7, #0x14]
 800e7be: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800e7c0: 693b         	ldr	r3, [r7, #0x10]
 800e7c2: 61fb         	str	r3, [r7, #0x1c]
 800e7c4: 69fb         	ldr	r3, [r7, #0x1c]
 800e7c6: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e7c8: 69bb         	ldr	r3, [r7, #0x18]
 800e7ca: f383 8811    	msr	basepri, r3
; }
 800e7ce: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e7d0: f3bf 8f6f    	isb	sy
; }
 800e7d4: bf00         	nop
; }
 800e7d6: bf00         	nop
; }
 800e7d8: bf00         	nop
; }
 800e7da: bf00         	nop
 800e7dc: 3744         	adds	r7, #0x44
 800e7de: 46bd         	mov	sp, r7
 800e7e0: bc80         	pop	{r7}
 800e7e2: 4770         	bx	lr

0800e7e4 <$d>:
 800e7e4: f8 10 00 20  	.word	0x200010f8
 800e7e8: c8 06 00 20  	.word	0x200006c8

0800e7ec <z_data_copy>:
; {
 800e7ec: b580         	push	{r7, lr}
 800e7ee: af00         	add	r7, sp, #0x0
; 		       __data_region_end - __data_region_start);
 800e7f0: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800e814 <z_data_copy+0x28>
 800e7f2: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800e818 <z_data_copy+0x2c>
 800e7f4: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__data_region_start, &__data_region_load_start,
 800e7f6: 461a         	mov	r2, r3
 800e7f8: 4908         	ldr	r1, [pc, #0x20]         @ 0x800e81c <z_data_copy+0x30>
 800e7fa: 4807         	ldr	r0, [pc, #0x1c]         @ 0x800e818 <z_data_copy+0x2c>
 800e7fc: f008 fbcd    	bl	0x8016f9a <z_early_memcpy> @ imm = #0x879a
; 		       __ramfunc_end - __ramfunc_region_start);
 800e800: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800e820 <z_data_copy+0x34>
 800e802: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800e824 <z_data_copy+0x38>
 800e804: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__ramfunc_region_start, &__ramfunc_load_start,
 800e806: 461a         	mov	r2, r3
 800e808: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800e828 <z_data_copy+0x3c>
 800e80a: 4806         	ldr	r0, [pc, #0x18]         @ 0x800e824 <z_data_copy+0x38>
 800e80c: f008 fbc5    	bl	0x8016f9a <z_early_memcpy> @ imm = #0x878a
; }
 800e810: bf00         	nop
 800e812: bd80         	pop	{r7, pc}

0800e814 <$d>:
 800e814: e8 05 00 20  	.word	0x200005e8
 800e818: 00 00 00 20  	.word	0x20000000
 800e81c: 98 bf 01 08  	.word	0x0801bf98
 800e820: 00 00 00 20  	.word	0x20000000
 800e824: 00 00 00 20  	.word	0x20000000
 800e828: 98 bf 01 08  	.word	0x0801bf98

0800e82c <first>:
; {
 800e82c: b580         	push	{r7, lr}
 800e82e: b082         	sub	sp, #0x8
 800e830: af00         	add	r7, sp, #0x0
; 	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);
 800e832: 4804         	ldr	r0, [pc, #0x10]         @ 0x800e844 <first+0x18>
 800e834: f00a f8f5    	bl	0x8018a22 <sys_dlist_peek_head> @ imm = #0xa1ea
 800e838: 6078         	str	r0, [r7, #0x4]
; 	return (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);
 800e83a: 687b         	ldr	r3, [r7, #0x4]
; }
 800e83c: 4618         	mov	r0, r3
 800e83e: 3708         	adds	r7, #0x8
 800e840: 46bd         	mov	sp, r7
 800e842: bd80         	pop	{r7, pc}

0800e844 <$d>:
 800e844: 50 05 00 20  	.word	0x20000550

0800e848 <next>:
; {
 800e848: b580         	push	{r7, lr}
 800e84a: b084         	sub	sp, #0x10
 800e84c: af00         	add	r7, sp, #0x0
 800e84e: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);
 800e850: 687b         	ldr	r3, [r7, #0x4]
 800e852: 4619         	mov	r1, r3
 800e854: 4804         	ldr	r0, [pc, #0x10]         @ 0x800e868 <next+0x20>
 800e856: f00a f909    	bl	0x8018a6c <sys_dlist_peek_next> @ imm = #0xa212
 800e85a: 60f8         	str	r0, [r7, #0xc]
; 	return (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);
 800e85c: 68fb         	ldr	r3, [r7, #0xc]
; }
 800e85e: 4618         	mov	r0, r3
 800e860: 3710         	adds	r7, #0x10
 800e862: 46bd         	mov	sp, r7
 800e864: bd80         	pop	{r7, pc}
 800e866: bf00         	nop

0800e868 <$d>:
 800e868: 50 05 00 20  	.word	0x20000550

0800e86c <elapsed>:
; {
 800e86c: b580         	push	{r7, lr}
 800e86e: af00         	add	r7, sp, #0x0
; 	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 800e870: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800e888 <elapsed+0x1c>
 800e872: 681b         	ldr	r3, [r3]
 800e874: 2b00         	cmp	r3, #0x0
 800e876: d103         	bne	0x800e880 <elapsed+0x14> @ imm = #0x6
 800e878: f7fa ff46    	bl	0x8009708 <sys_clock_elapsed> @ imm = #-0x5174
 800e87c: 4603         	mov	r3, r0
 800e87e: e000         	b	0x800e882 <elapsed+0x16> @ imm = #0x0
 800e880: 2300         	movs	r3, #0x0
; }
 800e882: 4618         	mov	r0, r3
 800e884: bd80         	pop	{r7, pc}
 800e886: bf00         	nop

0800e888 <$d>:
 800e888: f8 10 00 20  	.word	0x200010f8

0800e88c <z_add_timeout>:
; {
 800e88c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800e890: b0a0         	sub	sp, #0x80
 800e892: af00         	add	r7, sp, #0x0
 800e894: 6378         	str	r0, [r7, #0x34]
 800e896: 6339         	str	r1, [r7, #0x30]
 800e898: e9c7 230a    	strd	r2, r3, [r7, #40]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 800e89c: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 800e8a0: f04f 32ff    	mov.w	r2, #0xffffffff
 800e8a4: f04f 33ff    	mov.w	r3, #0xffffffff
 800e8a8: 4299         	cmp	r1, r3
 800e8aa: bf08         	it	eq
 800e8ac: 4290         	cmpeq	r0, r2
 800e8ae: d100         	bne	0x800e8b2 <z_add_timeout+0x26> @ imm = #0x0
 800e8b0: e0d8         	b	0x800ea64 <z_add_timeout+0x1d8> @ imm = #0x1b0
; 	to->fn = fn;
 800e8b2: 6b7a         	ldr	r2, [r7, #0x34]
 800e8b4: 6b3b         	ldr	r3, [r7, #0x30]
 800e8b6: 6093         	str	r3, [r2, #0x8]
; 	K_SPINLOCK(&timeout_lock) {
 800e8b8: 2300         	movs	r3, #0x0
 800e8ba: 64bb         	str	r3, [r7, #0x48]
 800e8bc: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x800ea6c <z_add_timeout+0x1e0>
 800e8be: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e8c0: f3ef 8311    	mrs	r3, basepri
 800e8c4: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 800e8c6: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 800e8c8: 667b         	str	r3, [r7, #0x64]
 800e8ca: 2310         	movs	r3, #0x10
 800e8cc: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e8ce: 6e3b         	ldr	r3, [r7, #0x60]
 800e8d0: f383 8812    	msr	basepri_max, r3
; }
 800e8d4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e8d6: f3bf 8f6f    	isb	sy
; }
 800e8da: bf00         	nop
; 	return key;
 800e8dc: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 800e8de: 63fb         	str	r3, [r7, #0x3c]
 800e8e0: 6efb         	ldr	r3, [r7, #0x6c]
 800e8e2: 65fb         	str	r3, [r7, #0x5c]
; }
 800e8e4: bf00         	nop
 800e8e6: 6efb         	ldr	r3, [r7, #0x6c]
 800e8e8: 65bb         	str	r3, [r7, #0x58]
; }
 800e8ea: bf00         	nop
; 	return k;
 800e8ec: 6bfb         	ldr	r3, [r7, #0x3c]
 800e8ee: 647b         	str	r3, [r7, #0x44]
; 	K_SPINLOCK(&timeout_lock) {
 800e8f0: e0b4         	b	0x800ea5c <z_add_timeout+0x1d0> @ imm = #0x168
; 		    (Z_TICK_ABS(timeout.ticks) >= 0)) {
 800e8f2: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 800e8f6: f06f 0001    	mvn	r0, #0x1
 800e8fa: f04f 31ff    	mov.w	r1, #0xffffffff
 800e8fe: 1a80         	subs	r0, r0, r2
 800e900: 6238         	str	r0, [r7, #0x20]
 800e902: eb61 0303    	sbc.w	r3, r1, r3
 800e906: 627b         	str	r3, [r7, #0x24]
; 		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 800e908: 6a7b         	ldr	r3, [r7, #0x24]
 800e90a: 2b00         	cmp	r3, #0x0
 800e90c: db24         	blt	0x800e958 <z_add_timeout+0xcc> @ imm = #0x48
; 			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 800e90e: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 800e912: 4610         	mov	r0, r2
 800e914: 4619         	mov	r1, r3
 800e916: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800ea70 <z_add_timeout+0x1e4>
 800e918: e9d3 2300    	ldrd	r2, r3, [r3]
 800e91c: 1884         	adds	r4, r0, r2
 800e91e: eb41 0503    	adc.w	r5, r1, r3
 800e922: f06f 0201    	mvn	r2, #0x1
 800e926: f04f 33ff    	mov.w	r3, #0xffffffff
 800e92a: 1b12         	subs	r2, r2, r4
 800e92c: 61ba         	str	r2, [r7, #0x18]
 800e92e: eb63 0305    	sbc.w	r3, r3, r5
 800e932: 61fb         	str	r3, [r7, #0x1c]
 800e934: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 800e938: e9c7 231c    	strd	r2, r3, [r7, #112]
; 			to->dticks = MAX(1, ticks);
 800e93c: e9d7 231c    	ldrd	r2, r3, [r7, #112]
 800e940: 2a01         	cmp	r2, #0x1
 800e942: f173 0100    	sbcs	r1, r3, #0x0
 800e946: da03         	bge	0x800e950 <z_add_timeout+0xc4> @ imm = #0x6
 800e948: f04f 0201    	mov.w	r2, #0x1
 800e94c: f04f 0300    	mov.w	r3, #0x0
 800e950: 6b79         	ldr	r1, [r7, #0x34]
 800e952: e9c1 2304    	strd	r2, r3, [r1, #16]
 800e956: e016         	b	0x800e986 <z_add_timeout+0xfa> @ imm = #0x2c
; 			to->dticks = timeout.ticks + 1 + elapsed();
 800e958: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 800e95c: f112 0801    	adds.w	r8, r2, #0x1
 800e960: f143 0900    	adc	r9, r3, #0x0
 800e964: f7ff ff82    	bl	0x800e86c <elapsed>     @ imm = #-0xfc
 800e968: 4603         	mov	r3, r0
 800e96a: 17da         	asrs	r2, r3, #0x1f
 800e96c: 469a         	mov	r10, r3
 800e96e: 4693         	mov	r11, r2
 800e970: eb18 030a    	adds.w	r3, r8, r10
 800e974: 613b         	str	r3, [r7, #0x10]
 800e976: eb49 030b    	adc.w	r3, r9, r11
 800e97a: 617b         	str	r3, [r7, #0x14]
 800e97c: 6b7b         	ldr	r3, [r7, #0x34]
 800e97e: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 800e982: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 800e986: f7ff ff51    	bl	0x800e82c <first>       @ imm = #-0x15e
 800e98a: 67f8         	str	r0, [r7, #0x7c]
 800e98c: e037         	b	0x800e9fe <z_add_timeout+0x172> @ imm = #0x6e
; 			if (t->dticks > to->dticks) {
 800e98e: 6ffb         	ldr	r3, [r7, #0x7c]
 800e990: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 800e994: 6b7b         	ldr	r3, [r7, #0x34]
 800e996: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800e99a: 4282         	cmp	r2, r0
 800e99c: 418b         	sbcs	r3, r1
 800e99e: da18         	bge	0x800e9d2 <z_add_timeout+0x146> @ imm = #0x30
; 				t->dticks -= to->dticks;
 800e9a0: 6ffb         	ldr	r3, [r7, #0x7c]
 800e9a2: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 800e9a6: 6b7b         	ldr	r3, [r7, #0x34]
 800e9a8: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800e9ac: ebb0 0c02    	subs.w	r12, r0, r2
 800e9b0: f8c7 c008    	str.w	r12, [r7, #0x8]
 800e9b4: eb61 0303    	sbc.w	r3, r1, r3
 800e9b8: 60fb         	str	r3, [r7, #0xc]
 800e9ba: 6ffb         	ldr	r3, [r7, #0x7c]
 800e9bc: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 800e9c0: e9c3 1204    	strd	r1, r2, [r3, #16]
; 				sys_dlist_insert(&t->node, &to->node);
 800e9c4: 6ffa         	ldr	r2, [r7, #0x7c]
 800e9c6: 6b7b         	ldr	r3, [r7, #0x34]
 800e9c8: 4619         	mov	r1, r3
 800e9ca: 4610         	mov	r0, r2
 800e9cc: f00a f87a    	bl	0x8018ac4 <sys_dlist_insert> @ imm = #0xa0f4
; 				break;
 800e9d0: e018         	b	0x800ea04 <z_add_timeout+0x178> @ imm = #0x30
; 			to->dticks -= t->dticks;
 800e9d2: 6b7b         	ldr	r3, [r7, #0x34]
 800e9d4: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 800e9d8: 6ffb         	ldr	r3, [r7, #0x7c]
 800e9da: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800e9de: ebb0 0c02    	subs.w	r12, r0, r2
 800e9e2: f8c7 c000    	str.w	r12, [r7]
 800e9e6: eb61 0303    	sbc.w	r3, r1, r3
 800e9ea: 607b         	str	r3, [r7, #0x4]
 800e9ec: 6b7b         	ldr	r3, [r7, #0x34]
 800e9ee: e9d7 1200    	ldrd	r1, r2, [r7]
 800e9f2: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 800e9f6: 6ff8         	ldr	r0, [r7, #0x7c]
 800e9f8: f7ff ff26    	bl	0x800e848 <next>        @ imm = #-0x1b4
 800e9fc: 67f8         	str	r0, [r7, #0x7c]
 800e9fe: 6ffb         	ldr	r3, [r7, #0x7c]
 800ea00: 2b00         	cmp	r3, #0x0
 800ea02: d1c4         	bne	0x800e98e <z_add_timeout+0x102> @ imm = #-0x78
; 		if (t == NULL) {
 800ea04: 6ffb         	ldr	r3, [r7, #0x7c]
 800ea06: 2b00         	cmp	r3, #0x0
 800ea08: d104         	bne	0x800ea14 <z_add_timeout+0x188> @ imm = #0x8
; 			sys_dlist_append(&timeout_list, &to->node);
 800ea0a: 6b7b         	ldr	r3, [r7, #0x34]
 800ea0c: 4619         	mov	r1, r3
 800ea0e: 4819         	ldr	r0, [pc, #0x64]         @ 0x800ea74 <z_add_timeout+0x1e8>
 800ea10: f00a f83f    	bl	0x8018a92 <sys_dlist_append> @ imm = #0xa07e
; 		if (to == first() && announce_remaining == 0) {
 800ea14: f7ff ff0a    	bl	0x800e82c <first>       @ imm = #-0x1ec
 800ea18: 4602         	mov	r2, r0
 800ea1a: 6b7b         	ldr	r3, [r7, #0x34]
 800ea1c: 4293         	cmp	r3, r2
 800ea1e: d10a         	bne	0x800ea36 <z_add_timeout+0x1aa> @ imm = #0x14
 800ea20: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800ea78 <z_add_timeout+0x1ec>
 800ea22: 681b         	ldr	r3, [r3]
 800ea24: 2b00         	cmp	r3, #0x0
 800ea26: d106         	bne	0x800ea36 <z_add_timeout+0x1aa> @ imm = #0xc
; 			sys_clock_set_timeout(next_timeout(), false);
 800ea28: f00a f89c    	bl	0x8018b64 <next_timeout> @ imm = #0xa138
 800ea2c: 4603         	mov	r3, r0
 800ea2e: 2100         	movs	r1, #0x0
 800ea30: 4618         	mov	r0, r3
 800ea32: f7fa fd65    	bl	0x8009500 <sys_clock_set_timeout> @ imm = #-0x5536
 800ea36: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800ea6c <z_add_timeout+0x1e0>
 800ea38: 657b         	str	r3, [r7, #0x54]
 800ea3a: 6c7b         	ldr	r3, [r7, #0x44]
 800ea3c: 643b         	str	r3, [r7, #0x40]
; 	arch_irq_unlock(key.key);
 800ea3e: 6c3b         	ldr	r3, [r7, #0x40]
 800ea40: 653b         	str	r3, [r7, #0x50]
 800ea42: 6d3b         	ldr	r3, [r7, #0x50]
 800ea44: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ea46: 6cfb         	ldr	r3, [r7, #0x4c]
 800ea48: f383 8811    	msr	basepri, r3
; }
 800ea4c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ea4e: f3bf 8f6f    	isb	sy
; }
 800ea52: bf00         	nop
; }
 800ea54: bf00         	nop
; }
 800ea56: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 800ea58: 2301         	movs	r3, #0x1
 800ea5a: 64bb         	str	r3, [r7, #0x48]
 800ea5c: 6cbb         	ldr	r3, [r7, #0x48]
 800ea5e: 2b00         	cmp	r3, #0x0
 800ea60: f43f af47    	beq.w	0x800e8f2 <z_add_timeout+0x66> @ imm = #-0x172
; }
 800ea64: 3780         	adds	r7, #0x80
 800ea66: 46bd         	mov	sp, r7
 800ea68: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800ea6c <$d>:
 800ea6c: f8 10 00 20  	.word	0x200010f8
 800ea70: 90 09 00 20  	.word	0x20000990
 800ea74: 50 05 00 20  	.word	0x20000550
 800ea78: f8 10 00 20  	.word	0x200010f8

0800ea7c <z_abort_timeout>:
; {
 800ea7c: b580         	push	{r7, lr}
 800ea7e: b090         	sub	sp, #0x40
 800ea80: af00         	add	r7, sp, #0x0
 800ea82: 6078         	str	r0, [r7, #0x4]
; 	int ret = -EINVAL;
 800ea84: f06f 0315    	mvn	r3, #0x15
 800ea88: 63fb         	str	r3, [r7, #0x3c]
; 	K_SPINLOCK(&timeout_lock) {
 800ea8a: 2300         	movs	r3, #0x0
 800ea8c: 617b         	str	r3, [r7, #0x14]
 800ea8e: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800eb14 <z_abort_timeout+0x98>
 800ea90: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ea92: f3ef 8311    	mrs	r3, basepri
 800ea96: 637b         	str	r3, [r7, #0x34]
;   return(result);
 800ea98: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 800ea9a: 633b         	str	r3, [r7, #0x30]
 800ea9c: 2310         	movs	r3, #0x10
 800ea9e: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800eaa0: 6afb         	ldr	r3, [r7, #0x2c]
 800eaa2: f383 8812    	msr	basepri_max, r3
; }
 800eaa6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800eaa8: f3bf 8f6f    	isb	sy
; }
 800eaac: bf00         	nop
; 	return key;
 800eaae: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 800eab0: 60bb         	str	r3, [r7, #0x8]
 800eab2: 6bbb         	ldr	r3, [r7, #0x38]
 800eab4: 62bb         	str	r3, [r7, #0x28]
; }
 800eab6: bf00         	nop
 800eab8: 6bbb         	ldr	r3, [r7, #0x38]
 800eaba: 627b         	str	r3, [r7, #0x24]
; }
 800eabc: bf00         	nop
; 	return k;
 800eabe: 68bb         	ldr	r3, [r7, #0x8]
 800eac0: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&timeout_lock) {
 800eac2: e01e         	b	0x800eb02 <z_abort_timeout+0x86> @ imm = #0x3c
; 		if (sys_dnode_is_linked(&to->node)) {
 800eac4: 687b         	ldr	r3, [r7, #0x4]
 800eac6: 4618         	mov	r0, r3
 800eac8: f009 ff8a    	bl	0x80189e0 <sys_dnode_is_linked> @ imm = #0x9f14
 800eacc: 4603         	mov	r3, r0
 800eace: 2b00         	cmp	r3, #0x0
 800ead0: d004         	beq	0x800eadc <z_abort_timeout+0x60> @ imm = #0x8
; 			remove_timeout(to);
 800ead2: 6878         	ldr	r0, [r7, #0x4]
 800ead4: f00a f826    	bl	0x8018b24 <remove_timeout> @ imm = #0xa04c
; 			ret = 0;
 800ead8: 2300         	movs	r3, #0x0
 800eada: 63fb         	str	r3, [r7, #0x3c]
 800eadc: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800eb14 <z_abort_timeout+0x98>
 800eade: 623b         	str	r3, [r7, #0x20]
 800eae0: 693b         	ldr	r3, [r7, #0x10]
 800eae2: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800eae4: 68fb         	ldr	r3, [r7, #0xc]
 800eae6: 61fb         	str	r3, [r7, #0x1c]
 800eae8: 69fb         	ldr	r3, [r7, #0x1c]
 800eaea: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800eaec: 69bb         	ldr	r3, [r7, #0x18]
 800eaee: f383 8811    	msr	basepri, r3
; }
 800eaf2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800eaf4: f3bf 8f6f    	isb	sy
; }
 800eaf8: bf00         	nop
; }
 800eafa: bf00         	nop
; }
 800eafc: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 800eafe: 2301         	movs	r3, #0x1
 800eb00: 617b         	str	r3, [r7, #0x14]
 800eb02: 697b         	ldr	r3, [r7, #0x14]
 800eb04: 2b00         	cmp	r3, #0x0
 800eb06: d0dd         	beq	0x800eac4 <z_abort_timeout+0x48> @ imm = #-0x46
; 	return ret;
 800eb08: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 800eb0a: 4618         	mov	r0, r3
 800eb0c: 3740         	adds	r7, #0x40
 800eb0e: 46bd         	mov	sp, r7
 800eb10: bd80         	pop	{r7, pc}
 800eb12: bf00         	nop

0800eb14 <$d>:
 800eb14: f8 10 00 20  	.word	0x200010f8

0800eb18 <sys_clock_announce>:
; {
 800eb18: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800eb1c: b0a4         	sub	sp, #0x90
 800eb1e: af00         	add	r7, sp, #0x0
 800eb20: 6278         	str	r0, [r7, #0x24]
 800eb22: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800ecf4 <sys_clock_announce+0x1dc>
 800eb24: f8c7 3084    	str.w	r3, [r7, #0x84]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800eb28: f3ef 8311    	mrs	r3, basepri
 800eb2c: f8c7 3080    	str.w	r3, [r7, #0x80]
;   return(result);
 800eb30: f8d7 3080    	ldr.w	r3, [r7, #0x80]
; 	key = __get_BASEPRI();
 800eb34: 67fb         	str	r3, [r7, #0x7c]
 800eb36: 2310         	movs	r3, #0x10
 800eb38: 67bb         	str	r3, [r7, #0x78]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800eb3a: 6fbb         	ldr	r3, [r7, #0x78]
 800eb3c: f383 8812    	msr	basepri_max, r3
; }
 800eb40: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800eb42: f3bf 8f6f    	isb	sy
; }
 800eb46: bf00         	nop
; 	return key;
 800eb48: 6ffb         	ldr	r3, [r7, #0x7c]
; 	k.key = arch_irq_lock();
 800eb4a: 637b         	str	r3, [r7, #0x34]
 800eb4c: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800eb50: 677b         	str	r3, [r7, #0x74]
; }
 800eb52: bf00         	nop
 800eb54: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800eb58: 673b         	str	r3, [r7, #0x70]
; }
 800eb5a: bf00         	nop
; 	return k;
 800eb5c: 6b7b         	ldr	r3, [r7, #0x34]
 800eb5e: 63fb         	str	r3, [r7, #0x3c]
; 	announce_remaining = ticks;
 800eb60: 4a65         	ldr	r2, [pc, #0x194]        @ 0x800ecf8 <sys_clock_announce+0x1e0>
 800eb62: 6a7b         	ldr	r3, [r7, #0x24]
 800eb64: 6013         	str	r3, [r2]
; 	for (t = first();
 800eb66: f7ff fe61    	bl	0x800e82c <first>       @ imm = #-0x33e
 800eb6a: f8c7 008c    	str.w	r0, [r7, #0x8c]
 800eb6e: e061         	b	0x800ec34 <sys_clock_announce+0x11c> @ imm = #0xc2
; 		int dt = t->dticks;
 800eb70: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800eb74: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800eb78: 4613         	mov	r3, r2
 800eb7a: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		curr_tick += dt;
 800eb7e: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800eb82: 17da         	asrs	r2, r3, #0x1f
 800eb84: 469a         	mov	r10, r3
 800eb86: 4693         	mov	r11, r2
 800eb88: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800ecfc <sys_clock_announce+0x1e4>
 800eb8a: e9d3 2300    	ldrd	r2, r3, [r3]
 800eb8e: eb1a 0102    	adds.w	r1, r10, r2
 800eb92: 61b9         	str	r1, [r7, #0x18]
 800eb94: eb4b 0303    	adc.w	r3, r11, r3
 800eb98: 61fb         	str	r3, [r7, #0x1c]
 800eb9a: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800ecfc <sys_clock_announce+0x1e4>
 800eb9c: e9d7 1206    	ldrd	r1, r2, [r7, #24]
 800eba0: e9c3 1200    	strd	r1, r2, [r3]
; 		t->dticks = 0;
 800eba4: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 800eba8: f04f 0200    	mov.w	r2, #0x0
 800ebac: f04f 0300    	mov.w	r3, #0x0
 800ebb0: e9c1 2304    	strd	r2, r3, [r1, #16]
; 		remove_timeout(t);
 800ebb4: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 800ebb8: f009 ffb4    	bl	0x8018b24 <remove_timeout> @ imm = #0x9f68
 800ebbc: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800ecf4 <sys_clock_announce+0x1dc>
 800ebbe: 657b         	str	r3, [r7, #0x54]
 800ebc0: 6bfb         	ldr	r3, [r7, #0x3c]
 800ebc2: 633b         	str	r3, [r7, #0x30]
; 	arch_irq_unlock(key.key);
 800ebc4: 6b3b         	ldr	r3, [r7, #0x30]
 800ebc6: 653b         	str	r3, [r7, #0x50]
 800ebc8: 6d3b         	ldr	r3, [r7, #0x50]
 800ebca: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ebcc: 6cfb         	ldr	r3, [r7, #0x4c]
 800ebce: f383 8811    	msr	basepri, r3
; }
 800ebd2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ebd4: f3bf 8f6f    	isb	sy
; }
 800ebd8: bf00         	nop
; }
 800ebda: bf00         	nop
; }
 800ebdc: bf00         	nop
; 		t->fn(t);
 800ebde: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800ebe2: 689b         	ldr	r3, [r3, #0x8]
 800ebe4: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 800ebe8: 4798         	blx	r3
 800ebea: 4b42         	ldr	r3, [pc, #0x108]        @ 0x800ecf4 <sys_clock_announce+0x1dc>
 800ebec: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ebee: f3ef 8311    	mrs	r3, basepri
 800ebf2: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 800ebf4: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 800ebf6: 667b         	str	r3, [r7, #0x64]
 800ebf8: 2310         	movs	r3, #0x10
 800ebfa: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ebfc: 6e3b         	ldr	r3, [r7, #0x60]
 800ebfe: f383 8812    	msr	basepri_max, r3
; }
 800ec02: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ec04: f3bf 8f6f    	isb	sy
; }
 800ec08: bf00         	nop
; 	return key;
 800ec0a: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 800ec0c: 62fb         	str	r3, [r7, #0x2c]
 800ec0e: 6efb         	ldr	r3, [r7, #0x6c]
 800ec10: 65fb         	str	r3, [r7, #0x5c]
; }
 800ec12: bf00         	nop
 800ec14: 6efb         	ldr	r3, [r7, #0x6c]
 800ec16: 65bb         	str	r3, [r7, #0x58]
; }
 800ec18: bf00         	nop
; 	return k;
 800ec1a: 6afb         	ldr	r3, [r7, #0x2c]
 800ec1c: 63fb         	str	r3, [r7, #0x3c]
; 		announce_remaining -= dt;
 800ec1e: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800ecf8 <sys_clock_announce+0x1e0>
 800ec20: 681a         	ldr	r2, [r3]
 800ec22: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800ec26: 1ad2         	subs	r2, r2, r3
 800ec28: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800ecf8 <sys_clock_announce+0x1e0>
 800ec2a: 601a         	str	r2, [r3]
; 	     t = first()) {
 800ec2c: f7ff fdfe    	bl	0x800e82c <first>       @ imm = #-0x404
 800ec30: f8c7 008c    	str.w	r0, [r7, #0x8c]
; 	     (t != NULL) && (t->dticks <= announce_remaining);
 800ec34: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800ec38: 2b00         	cmp	r3, #0x0
 800ec3a: d00e         	beq	0x800ec5a <sys_clock_announce+0x142> @ imm = #0x1c
 800ec3c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800ec40: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 800ec44: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800ecf8 <sys_clock_announce+0x1e0>
 800ec46: 681b         	ldr	r3, [r3]
 800ec48: 17da         	asrs	r2, r3, #0x1f
 800ec4a: 613b         	str	r3, [r7, #0x10]
 800ec4c: 617a         	str	r2, [r7, #0x14]
 800ec4e: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800ec52: 4694         	mov	r12, r2
 800ec54: 4584         	cmp	r12, r0
 800ec56: 418b         	sbcs	r3, r1
 800ec58: da8a         	bge	0x800eb70 <sys_clock_announce+0x58> @ imm = #-0xec
; 	if (t != NULL) {
 800ec5a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800ec5e: 2b00         	cmp	r3, #0x0
 800ec60: d014         	beq	0x800ec8c <sys_clock_announce+0x174> @ imm = #0x28
; 		t->dticks -= announce_remaining;
 800ec62: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800ec66: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800ec6a: 4923         	ldr	r1, [pc, #0x8c]         @ 0x800ecf8 <sys_clock_announce+0x1e0>
 800ec6c: 6809         	ldr	r1, [r1]
 800ec6e: 17c8         	asrs	r0, r1, #0x1f
 800ec70: 4688         	mov	r8, r1
 800ec72: 4681         	mov	r9, r0
 800ec74: ebb2 0108    	subs.w	r1, r2, r8
 800ec78: 60b9         	str	r1, [r7, #0x8]
 800ec7a: eb63 0309    	sbc.w	r3, r3, r9
 800ec7e: 60fb         	str	r3, [r7, #0xc]
 800ec80: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800ec84: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 800ec88: e9c3 1204    	strd	r1, r2, [r3, #16]
; 	curr_tick += announce_remaining;
 800ec8c: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800ecf8 <sys_clock_announce+0x1e0>
 800ec8e: 681b         	ldr	r3, [r3]
 800ec90: 17da         	asrs	r2, r3, #0x1f
 800ec92: 461c         	mov	r4, r3
 800ec94: 4615         	mov	r5, r2
 800ec96: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800ecfc <sys_clock_announce+0x1e4>
 800ec98: e9d3 2300    	ldrd	r2, r3, [r3]
 800ec9c: 18a1         	adds	r1, r4, r2
 800ec9e: 6039         	str	r1, [r7]
 800eca0: eb45 0303    	adc.w	r3, r5, r3
 800eca4: 607b         	str	r3, [r7, #0x4]
 800eca6: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800ecfc <sys_clock_announce+0x1e4>
 800eca8: e9d7 1200    	ldrd	r1, r2, [r7]
 800ecac: e9c3 1200    	strd	r1, r2, [r3]
; 	announce_remaining = 0;
 800ecb0: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800ecf8 <sys_clock_announce+0x1e0>
 800ecb2: 2200         	movs	r2, #0x0
 800ecb4: 601a         	str	r2, [r3]
; 	sys_clock_set_timeout(next_timeout(), false);
 800ecb6: f009 ff55    	bl	0x8018b64 <next_timeout> @ imm = #0x9eaa
 800ecba: 4603         	mov	r3, r0
 800ecbc: 2100         	movs	r1, #0x0
 800ecbe: 4618         	mov	r0, r3
 800ecc0: f7fa fc1e    	bl	0x8009500 <sys_clock_set_timeout> @ imm = #-0x57c4
 800ecc4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800ecf4 <sys_clock_announce+0x1dc>
 800ecc6: 64bb         	str	r3, [r7, #0x48]
 800ecc8: 6bfb         	ldr	r3, [r7, #0x3c]
 800ecca: 63bb         	str	r3, [r7, #0x38]
; 	arch_irq_unlock(key.key);
 800eccc: 6bbb         	ldr	r3, [r7, #0x38]
 800ecce: 647b         	str	r3, [r7, #0x44]
 800ecd0: 6c7b         	ldr	r3, [r7, #0x44]
 800ecd2: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ecd4: 6c3b         	ldr	r3, [r7, #0x40]
 800ecd6: f383 8811    	msr	basepri, r3
; }
 800ecda: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ecdc: f3bf 8f6f    	isb	sy
; }
 800ece0: bf00         	nop
; }
 800ece2: bf00         	nop
; }
 800ece4: bf00         	nop
; 	z_time_slice();
 800ece6: f7ff fcaf    	bl	0x800e648 <z_time_slice> @ imm = #-0x6a2
; }
 800ecea: 3790         	adds	r7, #0x90
 800ecec: 46bd         	mov	sp, r7
 800ecee: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 800ecf2: bf00         	nop

0800ecf4 <$d>:
 800ecf4: f8 10 00 20  	.word	0x200010f8
 800ecf8: f8 10 00 20  	.word	0x200010f8
 800ecfc: 90 09 00 20  	.word	0x20000990

0800ed00 <sys_clock_tick_get>:
; {
 800ed00: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800ed04: b090         	sub	sp, #0x40
 800ed06: af00         	add	r7, sp, #0x0
; 	uint64_t t = 0U;
 800ed08: f04f 0200    	mov.w	r2, #0x0
 800ed0c: f04f 0300    	mov.w	r3, #0x0
 800ed10: e9c7 230e    	strd	r2, r3, [r7, #56]
; 	K_SPINLOCK(&timeout_lock) {
 800ed14: 2300         	movs	r3, #0x0
 800ed16: 613b         	str	r3, [r7, #0x10]
 800ed18: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800eda8 <sys_clock_tick_get+0xa8>
 800ed1a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ed1c: f3ef 8311    	mrs	r3, basepri
 800ed20: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800ed22: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800ed24: 62fb         	str	r3, [r7, #0x2c]
 800ed26: 2310         	movs	r3, #0x10
 800ed28: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ed2a: 6abb         	ldr	r3, [r7, #0x28]
 800ed2c: f383 8812    	msr	basepri_max, r3
; }
 800ed30: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ed32: f3bf 8f6f    	isb	sy
; }
 800ed36: bf00         	nop
; 	return key;
 800ed38: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800ed3a: 607b         	str	r3, [r7, #0x4]
 800ed3c: 6b7b         	ldr	r3, [r7, #0x34]
 800ed3e: 627b         	str	r3, [r7, #0x24]
; }
 800ed40: bf00         	nop
 800ed42: 6b7b         	ldr	r3, [r7, #0x34]
 800ed44: 623b         	str	r3, [r7, #0x20]
; }
 800ed46: bf00         	nop
; 	return k;
 800ed48: 687b         	ldr	r3, [r7, #0x4]
 800ed4a: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&timeout_lock) {
 800ed4c: e021         	b	0x800ed92 <sys_clock_tick_get+0x92> @ imm = #0x42
; 		t = curr_tick + elapsed();
 800ed4e: f7ff fd8d    	bl	0x800e86c <elapsed>     @ imm = #-0x4e6
 800ed52: 4603         	mov	r3, r0
 800ed54: 17da         	asrs	r2, r3, #0x1f
 800ed56: 461c         	mov	r4, r3
 800ed58: 4615         	mov	r5, r2
 800ed5a: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800edac <sys_clock_tick_get+0xac>
 800ed5c: e9d3 2300    	ldrd	r2, r3, [r3]
 800ed60: eb14 0802    	adds.w	r8, r4, r2
 800ed64: eb45 0903    	adc.w	r9, r5, r3
 800ed68: e9c7 890e    	strd	r8, r9, [r7, #56]
 800ed6c: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800eda8 <sys_clock_tick_get+0xa8>
 800ed6e: 61fb         	str	r3, [r7, #0x1c]
 800ed70: 68fb         	ldr	r3, [r7, #0xc]
 800ed72: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800ed74: 68bb         	ldr	r3, [r7, #0x8]
 800ed76: 61bb         	str	r3, [r7, #0x18]
 800ed78: 69bb         	ldr	r3, [r7, #0x18]
 800ed7a: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ed7c: 697b         	ldr	r3, [r7, #0x14]
 800ed7e: f383 8811    	msr	basepri, r3
; }
 800ed82: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ed84: f3bf 8f6f    	isb	sy
; }
 800ed88: bf00         	nop
; }
 800ed8a: bf00         	nop
; }
 800ed8c: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 800ed8e: 2301         	movs	r3, #0x1
 800ed90: 613b         	str	r3, [r7, #0x10]
 800ed92: 693b         	ldr	r3, [r7, #0x10]
 800ed94: 2b00         	cmp	r3, #0x0
 800ed96: d0da         	beq	0x800ed4e <sys_clock_tick_get+0x4e> @ imm = #-0x4c
; 	return t;
 800ed98: e9d7 230e    	ldrd	r2, r3, [r7, #56]
; }
 800ed9c: 4610         	mov	r0, r2
 800ed9e: 4619         	mov	r1, r3
 800eda0: 3740         	adds	r7, #0x40
 800eda2: 46bd         	mov	sp, r7
 800eda4: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

0800eda8 <$d>:
 800eda8: f8 10 00 20  	.word	0x200010f8
 800edac: 90 09 00 20  	.word	0x20000990

0800edb0 <z_sched_usage_start>:
; {
 800edb0: b580         	push	{r7, lr}
 800edb2: b082         	sub	sp, #0x8
 800edb4: af00         	add	r7, sp, #0x0
 800edb6: 6078         	str	r0, [r7, #0x4]
; 	_current_cpu->usage0 = usage_now();
 800edb8: f009 ff32    	bl	0x8018c20 <usage_now>   @ imm = #0x9e64
 800edbc: 4603         	mov	r3, r0
 800edbe: 4a03         	ldr	r2, [pc, #0xc]          @ 0x800edcc <z_sched_usage_start+0x1c>
 800edc0: 6153         	str	r3, [r2, #0x14]
; }
 800edc2: bf00         	nop
 800edc4: 3708         	adds	r7, #0x8
 800edc6: 46bd         	mov	sp, r7
 800edc8: bd80         	pop	{r7, pc}
 800edca: bf00         	nop

0800edcc <$d>:
 800edcc: c8 06 00 20  	.word	0x200006c8

0800edd0 <z_sched_usage_stop>:
; {
 800edd0: b580         	push	{r7, lr}
 800edd2: b090         	sub	sp, #0x40
 800edd4: af00         	add	r7, sp, #0x0
 800edd6: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800ee78 <z_sched_usage_stop+0xa8>
 800edd8: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800edda: f3ef 8311    	mrs	r3, basepri
 800edde: 62fb         	str	r3, [r7, #0x2c]
;   return(result);
 800ede0: 6afb         	ldr	r3, [r7, #0x2c]
; 	key = __get_BASEPRI();
 800ede2: 62bb         	str	r3, [r7, #0x28]
 800ede4: 2310         	movs	r3, #0x10
 800ede6: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ede8: 6a7b         	ldr	r3, [r7, #0x24]
 800edea: f383 8812    	msr	basepri_max, r3
; }
 800edee: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800edf0: f3bf 8f6f    	isb	sy
; }
 800edf4: bf00         	nop
; 	return key;
 800edf6: 6abb         	ldr	r3, [r7, #0x28]
; 	k.key = arch_irq_lock();
 800edf8: 607b         	str	r3, [r7, #0x4]
 800edfa: 6b3b         	ldr	r3, [r7, #0x30]
 800edfc: 623b         	str	r3, [r7, #0x20]
; }
 800edfe: bf00         	nop
 800ee00: 6b3b         	ldr	r3, [r7, #0x30]
 800ee02: 61fb         	str	r3, [r7, #0x1c]
; }
 800ee04: bf00         	nop
; 	return k;
 800ee06: 687b         	ldr	r3, [r7, #0x4]
 800ee08: 60fb         	str	r3, [r7, #0xc]
; 	struct _cpu     *cpu = _current_cpu;
 800ee0a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800ee7c <z_sched_usage_stop+0xac>
 800ee0c: 63fb         	str	r3, [r7, #0x3c]
; 	uint32_t u0 = cpu->usage0;
 800ee0e: 6bfb         	ldr	r3, [r7, #0x3c]
 800ee10: 695b         	ldr	r3, [r3, #0x14]
 800ee12: 63bb         	str	r3, [r7, #0x38]
; 	if (u0 != 0) {
 800ee14: 6bbb         	ldr	r3, [r7, #0x38]
 800ee16: 2b00         	cmp	r3, #0x0
 800ee18: d015         	beq	0x800ee46 <z_sched_usage_stop+0x76> @ imm = #0x2a
; 		uint32_t cycles = usage_now() - u0;
 800ee1a: f009 ff01    	bl	0x8018c20 <usage_now>   @ imm = #0x9e02
 800ee1e: 4602         	mov	r2, r0
 800ee20: 6bbb         	ldr	r3, [r7, #0x38]
 800ee22: 1ad3         	subs	r3, r2, r3
 800ee24: 637b         	str	r3, [r7, #0x34]
; 		if (cpu->current->base.usage.track_usage) {
 800ee26: 6bfb         	ldr	r3, [r7, #0x3c]
 800ee28: 689b         	ldr	r3, [r3, #0x8]
 800ee2a: f893 3038    	ldrb.w	r3, [r3, #0x38]
 800ee2e: 2b00         	cmp	r3, #0x0
 800ee30: d005         	beq	0x800ee3e <z_sched_usage_stop+0x6e> @ imm = #0xa
; 			sched_thread_update_usage(cpu->current, cycles);
 800ee32: 6bfb         	ldr	r3, [r7, #0x3c]
 800ee34: 689b         	ldr	r3, [r3, #0x8]
 800ee36: 6b79         	ldr	r1, [r7, #0x34]
 800ee38: 4618         	mov	r0, r3
 800ee3a: f009 ff2c    	bl	0x8018c96 <sched_thread_update_usage> @ imm = #0x9e58
; 		sched_cpu_update_usage(cpu, cycles);
 800ee3e: 6b79         	ldr	r1, [r7, #0x34]
 800ee40: 6bf8         	ldr	r0, [r7, #0x3c]
 800ee42: f009 fefd    	bl	0x8018c40 <sched_cpu_update_usage> @ imm = #0x9dfa
; 	cpu->usage0 = 0;
 800ee46: 6bfb         	ldr	r3, [r7, #0x3c]
 800ee48: 2200         	movs	r2, #0x0
 800ee4a: 615a         	str	r2, [r3, #0x14]
 800ee4c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800ee78 <z_sched_usage_stop+0xa8>
 800ee4e: 61bb         	str	r3, [r7, #0x18]
 800ee50: 68fb         	ldr	r3, [r7, #0xc]
 800ee52: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800ee54: 68bb         	ldr	r3, [r7, #0x8]
 800ee56: 617b         	str	r3, [r7, #0x14]
 800ee58: 697b         	ldr	r3, [r7, #0x14]
 800ee5a: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ee5c: 693b         	ldr	r3, [r7, #0x10]
 800ee5e: f383 8811    	msr	basepri, r3
; }
 800ee62: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ee64: f3bf 8f6f    	isb	sy
; }
 800ee68: bf00         	nop
; }
 800ee6a: bf00         	nop
; }
 800ee6c: bf00         	nop
; }
 800ee6e: bf00         	nop
 800ee70: 3740         	adds	r7, #0x40
 800ee72: 46bd         	mov	sp, r7
 800ee74: bd80         	pop	{r7, pc}
 800ee76: bf00         	nop

0800ee78 <$d>:
 800ee78: fc 10 00 20  	.word	0x200010fc
 800ee7c: c8 06 00 20  	.word	0x200006c8

0800ee80 <boot_banner>:
; {
 800ee80: b580         	push	{r7, lr}
 800ee82: af00         	add	r7, sp, #0x0
; 	printk("*** " CONFIG_BOOT_BANNER_STRING " " BANNER_VERSION BANNER_POSTFIX " ***\n");
 800ee84: 4802         	ldr	r0, [pc, #0x8]          @ 0x800ee90 <boot_banner+0x10>
 800ee86: f001 fe64    	bl	0x8010b52 <printk>      @ imm = #0x1cc8
; }
 800ee8a: bf00         	nop
 800ee8c: bd80         	pop	{r7, pc}
 800ee8e: bf00         	nop

0800ee90 <$d>:
 800ee90: 2c b1 01 08  	.word	0x0801b12c

0800ee94 <statics_init>:
; {
 800ee94: b580         	push	{r7, lr}
 800ee96: b082         	sub	sp, #0x8
 800ee98: af00         	add	r7, sp, #0x0
; 	STRUCT_SECTION_FOREACH(k_heap, heap) {
 800ee9a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800eed4 <statics_init+0x40>
 800ee9c: 607b         	str	r3, [r7, #0x4]
 800ee9e: e00a         	b	0x800eeb6 <statics_init+0x22> @ imm = #0x14
; 			k_heap_init(heap, heap->heap.init_mem, heap->heap.init_bytes);
 800eea0: 687b         	ldr	r3, [r7, #0x4]
 800eea2: 6859         	ldr	r1, [r3, #0x4]
 800eea4: 687b         	ldr	r3, [r7, #0x4]
 800eea6: 689b         	ldr	r3, [r3, #0x8]
 800eea8: 461a         	mov	r2, r3
 800eeaa: 6878         	ldr	r0, [r7, #0x4]
 800eeac: f009 ff28    	bl	0x8018d00 <k_heap_init> @ imm = #0x9e50
; 	STRUCT_SECTION_FOREACH(k_heap, heap) {
 800eeb0: 687b         	ldr	r3, [r7, #0x4]
 800eeb2: 3314         	adds	r3, #0x14
 800eeb4: 607b         	str	r3, [r7, #0x4]
 800eeb6: 687b         	ldr	r3, [r7, #0x4]
 800eeb8: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800eed8 <statics_init+0x44>
 800eeba: 4293         	cmp	r3, r2
 800eebc: bf34         	ite	lo
 800eebe: 2301         	movlo	r3, #0x1
 800eec0: 2300         	movhs	r3, #0x0
 800eec2: b2db         	uxtb	r3, r3
 800eec4: 2b00         	cmp	r3, #0x0
 800eec6: d1eb         	bne	0x800eea0 <statics_init+0xc> @ imm = #-0x2a
; 	return 0;
 800eec8: 2300         	movs	r3, #0x0
; }
 800eeca: 4618         	mov	r0, r3
 800eecc: 3708         	adds	r7, #0x8
 800eece: 46bd         	mov	sp, r7
 800eed0: bd80         	pop	{r7, pc}
 800eed2: bf00         	nop

0800eed4 <$d>:
 800eed4: e8 05 00 20  	.word	0x200005e8
 800eed8: e8 05 00 20  	.word	0x200005e8

0800eedc <k_sys_work_q_init>:
; {
 800eedc: b580         	push	{r7, lr}
 800eede: b084         	sub	sp, #0x10
 800eee0: af02         	add	r7, sp, #0x8
; 	struct k_work_queue_config cfg = {
 800eee2: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800ef0c <k_sys_work_q_init+0x30>
 800eee4: 463b         	mov	r3, r7
 800eee6: e892 0003    	ldm.w	r2, {r0, r1}
 800eeea: e883 0003    	stm.w	r3, {r0, r1}
; 	k_work_queue_start(&k_sys_work_q,
 800eeee: 463b         	mov	r3, r7
 800eef0: 9300         	str	r3, [sp]
 800eef2: f04f 33ff    	mov.w	r3, #0xffffffff
 800eef6: f44f 6280    	mov.w	r2, #0x400
 800eefa: 4905         	ldr	r1, [pc, #0x14]         @ 0x800ef10 <k_sys_work_q_init+0x34>
 800eefc: 4805         	ldr	r0, [pc, #0x14]         @ 0x800ef14 <k_sys_work_q_init+0x38>
 800eefe: f7fd fcdb    	bl	0x800c8b8 <k_work_queue_start> @ imm = #-0x264a
; 	return 0;
 800ef02: 2300         	movs	r3, #0x0
; }
 800ef04: 4618         	mov	r0, r3
 800ef06: 3708         	adds	r7, #0x8
 800ef08: 46bd         	mov	sp, r7
 800ef0a: bd80         	pop	{r7, pc}

0800ef0c <$d>:
 800ef0c: 70 b1 01 08  	.word	0x0801b170
 800ef10: 40 3e 00 20  	.word	0x20003e40
 800ef14: 98 09 00 20  	.word	0x20000998

0800ef18 <skip_to_arg>:
 800ef18: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 800ef1c: 2601         	movs	r6, #0x1
 800ef1e: 4607         	mov	r7, r0
 800ef20: 42b2         	cmp	r2, r6
 800ef22: dc01         	bgt	0x800ef28 <skip_to_arg+0x10> @ imm = #0x2
 800ef24: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 800ef28: 463b         	mov	r3, r7
 800ef2a: 461f         	mov	r7, r3
 800ef2c: f813 4b01    	ldrb	r4, [r3], #1
 800ef30: 2c00         	cmp	r4, #0x0
 800ef32: d0f7         	beq	0x800ef24 <skip_to_arg+0xc> @ imm = #-0x12
 800ef34: 2c25         	cmp	r4, #0x25
 800ef36: d1f8         	bne	0x800ef2a <skip_to_arg+0x12> @ imm = #-0x10
 800ef38: 781c         	ldrb	r4, [r3]
 800ef3a: 2c25         	cmp	r4, #0x25
 800ef3c: f107 0702    	add.w	r7, r7, #0x2
 800ef40: d0f2         	beq	0x800ef28 <skip_to_arg+0x10> @ imm = #-0x1c
 800ef42: 2300         	movs	r3, #0x0
 800ef44: f8df 8104    	ldr.w	r8, [pc, #0x104]        @ 0x800f04c <skip_to_arg+0x134>
 800ef48: 469c         	mov	r12, r3
 800ef4a: 461d         	mov	r5, r3
 800ef4c: 2d1f         	cmp	r5, #0x1f
 800ef4e: d818         	bhi	0x800ef82 <skip_to_arg+0x6a> @ imm = #0x30
 800ef50: f1a4 0e20    	sub.w	lr, r4, #0x20
 800ef54: f1be 0f10    	cmp.w	lr, #0x10
 800ef58: d909         	bls	0x800ef6e <skip_to_arg+0x56> @ imm = #0x12
 800ef5a: f1a4 0e30    	sub.w	lr, r4, #0x30
 800ef5e: f1be 0f09    	cmp.w	lr, #0x9
 800ef62: d81e         	bhi	0x800efa2 <skip_to_arg+0x8a> @ imm = #0x3c
 800ef64: 240a         	movs	r4, #0xa
 800ef66: fb04 e303    	mla	r3, r4, r3, lr
 800ef6a: 2520         	movs	r5, #0x20
 800ef6c: e004         	b	0x800ef78 <skip_to_arg+0x60> @ imm = #0x8
 800ef6e: fa28 fe0e    	lsr.w	lr, r8, lr
 800ef72: f01e 0f01    	tst.w	lr, #0x1
 800ef76: d006         	beq	0x800ef86 <skip_to_arg+0x6e> @ imm = #0xc
 800ef78: f817 4b01    	ldrb	r4, [r7], #1
 800ef7c: 2c00         	cmp	r4, #0x0
 800ef7e: d1e5         	bne	0x800ef4c <skip_to_arg+0x34> @ imm = #-0x36
 800ef80: e028         	b	0x800efd4 <skip_to_arg+0xbc> @ imm = #0x50
 800ef82: 2d7f         	cmp	r5, #0x7f
 800ef84: d81c         	bhi	0x800efc0 <skip_to_arg+0xa8> @ imm = #0x38
 800ef86: f1a4 0e30    	sub.w	lr, r4, #0x30
 800ef8a: f1be 0f09    	cmp.w	lr, #0x9
 800ef8e: d9e9         	bls	0x800ef64 <skip_to_arg+0x4c> @ imm = #-0x2e
 800ef90: 2c24         	cmp	r4, #0x24
 800ef92: d110         	bne	0x800efb6 <skip_to_arg+0x9e> @ imm = #0x20
 800ef94: f1bc 0f00    	cmp.w	r12, #0x0
 800ef98: d046         	beq	0x800f028 <skip_to_arg+0x110> @ imm = #0x8c
 800ef9a: 42b3         	cmp	r3, r6
 800ef9c: d046         	beq	0x800f02c <skip_to_arg+0x114> @ imm = #0x8c
 800ef9e: 2300         	movs	r3, #0x0
 800efa0: e7ea         	b	0x800ef78 <skip_to_arg+0x60> @ imm = #-0x2c
 800efa2: f024 0e04    	bic	lr, r4, #0x4
 800efa6: f1be 0f2a    	cmp.w	lr, #0x2a
 800efaa: d0f8         	beq	0x800ef9e <skip_to_arg+0x86> @ imm = #-0x10
 800efac: 2c6c         	cmp	r4, #0x6c
 800efae: d109         	bne	0x800efc4 <skip_to_arg+0xac> @ imm = #0x12
 800efb0: f045 0580    	orr	r5, r5, #0x80
 800efb4: e7e0         	b	0x800ef78 <skip_to_arg+0x60> @ imm = #-0x40
 800efb6: f024 0e04    	bic	lr, r4, #0x4
 800efba: f1be 0f2a    	cmp.w	lr, #0x2a
 800efbe: d0ee         	beq	0x800ef9e <skip_to_arg+0x86> @ imm = #-0x24
 800efc0: 2c6c         	cmp	r4, #0x6c
 800efc2: d022         	beq	0x800f00a <skip_to_arg+0xf2> @ imm = #0x44
 800efc4: 2c6c         	cmp	r4, #0x6c
 800efc6: d81b         	bhi	0x800f000 <skip_to_arg+0xe8> @ imm = #0x36
 800efc8: 2c68         	cmp	r4, #0x68
 800efca: d023         	beq	0x800f014 <skip_to_arg+0xfc> @ imm = #0x46
 800efcc: 2c6a         	cmp	r4, #0x6a
 800efce: d028         	beq	0x800f022 <skip_to_arg+0x10a> @ imm = #0x50
 800efd0: 2c4c         	cmp	r4, #0x4c
 800efd2: d026         	beq	0x800f022 <skip_to_arg+0x10a> @ imm = #0x4c
 800efd4: f1bc 0f00    	cmp.w	r12, #0x0
 800efd8: d0a4         	beq	0x800ef24 <skip_to_arg+0xc> @ imm = #-0xb8
 800efda: 45b4         	cmp	r12, r6
 800efdc: d1a0         	bne	0x800ef20 <skip_to_arg+0x8> @ imm = #-0xc0
 800efde: f044 0720    	orr	r7, r4, #0x20
 800efe2: f1a7 0c65    	sub.w	r12, r7, #0x65
 800efe6: f1bc 0f02    	cmp.w	r12, #0x2
 800efea: 680b         	ldr	r3, [r1]
 800efec: d901         	bls	0x800eff2 <skip_to_arg+0xda> @ imm = #0x2
 800efee: 2f61         	cmp	r7, #0x61
 800eff0: d11e         	bne	0x800f030 <skip_to_arg+0x118> @ imm = #0x3c
 800eff2: 3307         	adds	r3, #0x7
 800eff4: f023 0307    	bic	r3, r3, #0x7
 800eff8: 3308         	adds	r3, #0x8
 800effa: 600b         	str	r3, [r1]
 800effc: 3601         	adds	r6, #0x1
 800effe: e78e         	b	0x800ef1e <skip_to_arg+0x6> @ imm = #-0xe4
 800f000: 2c74         	cmp	r4, #0x74
 800f002: d0b9         	beq	0x800ef78 <skip_to_arg+0x60> @ imm = #-0x8e
 800f004: 2c7a         	cmp	r4, #0x7a
 800f006: d0b7         	beq	0x800ef78 <skip_to_arg+0x60> @ imm = #-0x92
 800f008: e7e4         	b	0x800efd4 <skip_to_arg+0xbc> @ imm = #-0x38
 800f00a: 062c         	lsls	r4, r5, #0x18
 800f00c: bf48         	it	mi
 800f00e: f445 7500    	orrmi	r5, r5, #0x200
 800f012: e7cd         	b	0x800efb0 <skip_to_arg+0x98> @ imm = #-0x66
 800f014: 05ec         	lsls	r4, r5, #0x17
 800f016: bf48         	it	mi
 800f018: f445 7500    	orrmi	r5, r5, #0x200
 800f01c: f445 7580    	orr	r5, r5, #0x100
 800f020: e7aa         	b	0x800ef78 <skip_to_arg+0x60> @ imm = #-0xac
 800f022: f445 7520    	orr	r5, r5, #0x280
 800f026: e7a7         	b	0x800ef78 <skip_to_arg+0x60> @ imm = #-0xb2
 800f028: 469c         	mov	r12, r3
 800f02a: e7b8         	b	0x800ef9e <skip_to_arg+0x86> @ imm = #-0x90
 800f02c: 2463         	movs	r4, #0x63
 800f02e: e7d6         	b	0x800efde <skip_to_arg+0xc6> @ imm = #-0x54
 800f030: 2c69         	cmp	r4, #0x69
 800f032: d002         	beq	0x800f03a <skip_to_arg+0x122> @ imm = #0x4
 800f034: d807         	bhi	0x800f046 <skip_to_arg+0x12e> @ imm = #0xe
 800f036: 2c63         	cmp	r4, #0x63
 800f038: d003         	beq	0x800f042 <skip_to_arg+0x12a> @ imm = #0x6
 800f03a: 062f         	lsls	r7, r5, #0x18
 800f03c: d501         	bpl	0x800f042 <skip_to_arg+0x12a> @ imm = #0x2
 800f03e: 05ac         	lsls	r4, r5, #0x16
 800f040: d4d7         	bmi	0x800eff2 <skip_to_arg+0xda> @ imm = #-0x52
 800f042: 3304         	adds	r3, #0x4
 800f044: e7d9         	b	0x800effa <skip_to_arg+0xe2> @ imm = #-0x4e
 800f046: 2c73         	cmp	r4, #0x73
 800f048: e7f6         	b	0x800f038 <skip_to_arg+0x120> @ imm = #-0x14
 800f04a: bf00         	nop

0800f04c <$d>:
 800f04c: 89 28 01 00  	.word	0x00012889

0800f050 <vfprintf>:
 800f050: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800f054: b095         	sub	sp, #0x54
 800f056: 6843         	ldr	r3, [r0, #0x4]
 800f058: 9303         	str	r3, [sp, #0xc]
 800f05a: 7883         	ldrb	r3, [r0, #0x2]
 800f05c: 4680         	mov	r8, r0
 800f05e: 0798         	lsls	r0, r3, #0x1e
 800f060: e9cd 1208    	strd	r1, r2, [sp, #32]
 800f064: d517         	bpl	0x800f096 <vfprintf+0x46> @ imm = #0x2e
 800f066: 920d         	str	r2, [sp, #0x34]
 800f068: 460b         	mov	r3, r1
 800f06a: 2500         	movs	r5, #0x0
 800f06c: 781f         	ldrb	r7, [r3]
 800f06e: b1a7         	cbz	r7, 0x800f09a <vfprintf+0x4a> @ imm = #0x28
 800f070: 2f25         	cmp	r7, #0x25
 800f072: d016         	beq	0x800f0a2 <vfprintf+0x52> @ imm = #0x2c
 800f074: 3301         	adds	r3, #0x1
 800f076: 9307         	str	r3, [sp, #0x1c]
 800f078: 9b03         	ldr	r3, [sp, #0xc]
 800f07a: 4641         	mov	r1, r8
 800f07c: 4638         	mov	r0, r7
 800f07e: 4798         	blx	r3
 800f080: 2800         	cmp	r0, #0x0
 800f082: f105 0501    	add.w	r5, r5, #0x1
 800f086: f280 8439    	bge.w	0x800f8fc <vfprintf+0x8ac> @ imm = #0x872
 800f08a: f898 3002    	ldrb.w	r3, [r8, #0x2]
 800f08e: f043 0304    	orr	r3, r3, #0x4
 800f092: f888 3002    	strb.w	r3, [r8, #0x2]
 800f096: f04f 35ff    	mov.w	r5, #0xffffffff
 800f09a: 4628         	mov	r0, r5
 800f09c: b015         	add	sp, #0x54
 800f09e: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800f0a2: 785f         	ldrb	r7, [r3, #0x1]
 800f0a4: 1c9a         	adds	r2, r3, #0x2
 800f0a6: 2f25         	cmp	r7, #0x25
 800f0a8: 9207         	str	r2, [sp, #0x1c]
 800f0aa: d0e5         	beq	0x800f078 <vfprintf+0x28> @ imm = #-0x36
 800f0ac: 2400         	movs	r4, #0x0
 800f0ae: 4626         	mov	r6, r4
 800f0b0: 46a2         	mov	r10, r4
 800f0b2: 46a3         	mov	r11, r4
 800f0b4: f1bb 0f1f    	cmp.w	r11, #0x1f
 800f0b8: d832         	bhi	0x800f120 <vfprintf+0xd0> @ imm = #0x64
 800f0ba: f1a7 0320    	sub.w	r3, r7, #0x20
 800f0be: 2b10         	cmp	r3, #0x10
 800f0c0: d80a         	bhi	0x800f0d8 <vfprintf+0x88> @ imm = #0x14
 800f0c2: e8df f003    	tbb	[pc, r3]

0800f0c6 <$d>:
 800f0c6: 24 09 09 2a  	.word	0x2a090924
 800f0ca: 09 09 09 1b  	.word	0x1b090909
 800f0ce: 09 09 09 22  	.word	0x22090909
 800f0d2: 09 27 09 09  	.word	0x09092709
 800f0d6: 19           	.byte	0x19

0800f0d7 <$d>:
 800f0d7: 00           	.byte	0x00

0800f0d8 <$t>:
 800f0d8: f1a7 0330    	sub.w	r3, r7, #0x30
 800f0dc: 2b09         	cmp	r3, #0x9
 800f0de: d92d         	bls	0x800f13c <vfprintf+0xec> @ imm = #0x5a
 800f0e0: 2f2a         	cmp	r7, #0x2a
 800f0e2: d139         	bne	0x800f158 <vfprintf+0x108> @ imm = #0x72
 800f0e4: b954         	cbnz	r4, 0x800f0fc <vfprintf+0xac> @ imm = #0x14
 800f0e6: 9b0d         	ldr	r3, [sp, #0x34]
 800f0e8: f01b 0f40    	tst.w	r11, #0x40
 800f0ec: f853 2b04    	ldr	r2, [r3], #4
 800f0f0: 930d         	str	r3, [sp, #0x34]
 800f0f2: d029         	beq	0x800f148 <vfprintf+0xf8> @ imm = #0x52
 800f0f4: 4616         	mov	r6, r2
 800f0f6: e001         	b	0x800f0fc <vfprintf+0xac> @ imm = #0x2
 800f0f8: f04b 0b01    	orr	r11, r11, #0x1
 800f0fc: 9b07         	ldr	r3, [sp, #0x1c]
 800f0fe: f813 7b01    	ldrb	r7, [r3], #1
 800f102: 9307         	str	r3, [sp, #0x1c]
 800f104: 2f00         	cmp	r7, #0x0
 800f106: d1d5         	bne	0x800f0b4 <vfprintf+0x64> @ imm = #-0x56
 800f108: e05b         	b	0x800f1c2 <vfprintf+0x172> @ imm = #0xb6
 800f10a: f04b 0b02    	orr	r11, r11, #0x2
 800f10e: f04b 0b04    	orr	r11, r11, #0x4
 800f112: e7f3         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0x1a
 800f114: f04b 0b08    	orr	r11, r11, #0x8
 800f118: e7f0         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0x20
 800f11a: f04b 0b10    	orr	r11, r11, #0x10
 800f11e: e7ed         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0x26
 800f120: f1bb 0f7f    	cmp.w	r11, #0x7f
 800f124: d83f         	bhi	0x800f1a6 <vfprintf+0x156> @ imm = #0x7e
 800f126: f1a7 0330    	sub.w	r3, r7, #0x30
 800f12a: 2b09         	cmp	r3, #0x9
 800f12c: d8d8         	bhi	0x800f0e0 <vfprintf+0x90> @ imm = #-0x50
 800f12e: f01b 0f40    	tst.w	r11, #0x40
 800f132: d003         	beq	0x800f13c <vfprintf+0xec> @ imm = #0x6
 800f134: 220a         	movs	r2, #0xa
 800f136: fb02 3606    	mla	r6, r2, r6, r3
 800f13a: e7df         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0x42
 800f13c: 220a         	movs	r2, #0xa
 800f13e: fb02 3a0a    	mla	r10, r2, r10, r3
 800f142: f04b 0b20    	orr	r11, r11, #0x20
 800f146: e7d9         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0x4e
 800f148: f1b2 0a00    	subs.w	r10, r2, #0x0
 800f14c: daf9         	bge	0x800f142 <vfprintf+0xf2> @ imm = #-0xe
 800f14e: f1ca 0a00    	rsb.w	r10, r10, #0x0
 800f152: f04b 0b28    	orr	r11, r11, #0x28
 800f156: e7d1         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0x5e
 800f158: 2f2e         	cmp	r7, #0x2e
 800f15a: d105         	bne	0x800f168 <vfprintf+0x118> @ imm = #0xa
 800f15c: f01b 0f40    	tst.w	r11, #0x40
 800f160: d19b         	bne	0x800f09a <vfprintf+0x4a> @ imm = #-0xca
 800f162: f04b 0b40    	orr	r11, r11, #0x40
 800f166: e7c9         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0x6e
 800f168: 2f24         	cmp	r7, #0x24
 800f16a: d11c         	bne	0x800f1a6 <vfprintf+0x156> @ imm = #0x38
 800f16c: 2c00         	cmp	r4, #0x0
 800f16e: f000 8142    	beq.w	0x800f3f6 <vfprintf+0x3a6> @ imm = #0x284
 800f172: 9b09         	ldr	r3, [sp, #0x24]
 800f174: 930d         	str	r3, [sp, #0x34]
 800f176: f01b 0f40    	tst.w	r11, #0x40
 800f17a: d10a         	bne	0x800f192 <vfprintf+0x142> @ imm = #0x14
 800f17c: 4652         	mov	r2, r10
 800f17e: 9808         	ldr	r0, [sp, #0x20]
 800f180: a90d         	add	r1, sp, #0x34
 800f182: f7ff fec9    	bl	0x800ef18 <skip_to_arg> @ imm = #-0x26e
 800f186: 9b0d         	ldr	r3, [sp, #0x34]
 800f188: 1d1a         	adds	r2, r3, #0x4
 800f18a: f8d3 a000    	ldr.w	r10, [r3]
 800f18e: 920d         	str	r2, [sp, #0x34]
 800f190: e7b4         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0x98
 800f192: 4632         	mov	r2, r6
 800f194: 9808         	ldr	r0, [sp, #0x20]
 800f196: a90d         	add	r1, sp, #0x34
 800f198: f7ff febe    	bl	0x800ef18 <skip_to_arg> @ imm = #-0x284
 800f19c: 9b0d         	ldr	r3, [sp, #0x34]
 800f19e: 1d1a         	adds	r2, r3, #0x4
 800f1a0: 681e         	ldr	r6, [r3]
 800f1a2: 920d         	str	r2, [sp, #0x34]
 800f1a4: e7aa         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0xac
 800f1a6: 2f6c         	cmp	r7, #0x6c
 800f1a8: f000 8112    	beq.w	0x800f3d0 <vfprintf+0x380> @ imm = #0x224
 800f1ac: f200 8109    	bhi.w	0x800f3c2 <vfprintf+0x372> @ imm = #0x212
 800f1b0: 2f68         	cmp	r7, #0x68
 800f1b2: f000 8115    	beq.w	0x800f3e0 <vfprintf+0x390> @ imm = #0x22a
 800f1b6: 2f6a         	cmp	r7, #0x6a
 800f1b8: f000 811a    	beq.w	0x800f3f0 <vfprintf+0x3a0> @ imm = #0x234
 800f1bc: 2f4c         	cmp	r7, #0x4c
 800f1be: f000 8117    	beq.w	0x800f3f0 <vfprintf+0x3a0> @ imm = #0x22e
 800f1c2: b134         	cbz	r4, 0x800f1d2 <vfprintf+0x182> @ imm = #0xc
 800f1c4: 9b09         	ldr	r3, [sp, #0x24]
 800f1c6: 9808         	ldr	r0, [sp, #0x20]
 800f1c8: 930d         	str	r3, [sp, #0x34]
 800f1ca: 4622         	mov	r2, r4
 800f1cc: a90d         	add	r1, sp, #0x34
 800f1ce: f7ff fea3    	bl	0x800ef18 <skip_to_arg> @ imm = #-0x2ba
 800f1d2: 2e00         	cmp	r6, #0x0
 800f1d4: f047 0920    	orr	r9, r7, #0x20
 800f1d8: bfb8         	it	lt
 800f1da: f02b 0b40    	biclt	r11, r11, #0x40
 800f1de: f1a9 0365    	sub.w	r3, r9, #0x65
 800f1e2: bfbc         	itt	lt
 800f1e4: fa1f fb8b    	uxthlt.w	r11, r11
 800f1e8: 2600         	movlt	r6, #0x0
 800f1ea: 2b02         	cmp	r3, #0x2
 800f1ec: f240 8108    	bls.w	0x800f400 <vfprintf+0x3b0> @ imm = #0x210
 800f1f0: f1b9 0f61    	cmp.w	r9, #0x61
 800f1f4: f040 8267    	bne.w	0x800f6c6 <vfprintf+0x676> @ imm = #0x4ce
 800f1f8: 43ff         	mvns	r7, r7
 800f1fa: f007 0320    	and	r3, r7, #0x20
 800f1fe: 9306         	str	r3, [sp, #0x18]
 800f200: 9b0d         	ldr	r3, [sp, #0x34]
 800f202: 3307         	adds	r3, #0x7
 800f204: f023 0307    	bic	r3, r3, #0x7
 800f208: f01b 0f40    	tst.w	r11, #0x40
 800f20c: e9d3 0100    	ldrd	r0, r1, [r3]
 800f210: f103 0208    	add.w	r2, r3, #0x8
 800f214: bf08         	it	eq
 800f216: f04f 36ff    	moveq.w	r6, #0xffffffff
 800f21a: 9b06         	ldr	r3, [sp, #0x18]
 800f21c: 920d         	str	r2, [sp, #0x34]
 800f21e: 9300         	str	r3, [sp]
 800f220: aa0e         	add	r2, sp, #0x38
 800f222: 4633         	mov	r3, r6
 800f224: f009 fed0    	bl	0x8018fc8 <__dtox_engine> @ imm = #0x9da0
 800f228: 3001         	adds	r0, #0x1
 800f22a: b2c3         	uxtb	r3, r0
 800f22c: 42b3         	cmp	r3, r6
 800f22e: f44b 54c0    	orr	r4, r11, #0x1800
 800f232: 9304         	str	r3, [sp, #0x10]
 800f234: db01         	blt	0x800f23a <vfprintf+0x1ea> @ imm = #0x2
 800f236: 9b04         	ldr	r3, [sp, #0x10]
 800f238: 1e5e         	subs	r6, r3, #0x1
 800f23a: 2301         	movs	r3, #0x1
 800f23c: 9f0e         	ldr	r7, [sp, #0x38]
 800f23e: 9305         	str	r3, [sp, #0x14]
 800f240: 46a3         	mov	r11, r4
 800f242: f04f 0970    	mov.w	r9, #0x70
 800f246: f107 0309    	add.w	r3, r7, #0x9
 800f24a: 2b12         	cmp	r3, #0x12
 800f24c: d90d         	bls	0x800f26a <vfprintf+0x21a> @ imm = #0x1a
 800f24e: f107 0363    	add.w	r3, r7, #0x63
 800f252: 2bc6         	cmp	r3, #0xc6
 800f254: f240 810f    	bls.w	0x800f476 <vfprintf+0x426> @ imm = #0x21e
 800f258: f207 33e7    	addw	r3, r7, #0x3e7
 800f25c: f240 72ce    	movw	r2, #0x7ce
 800f260: 4293         	cmp	r3, r2
 800f262: bf94         	ite	ls
 800f264: 2303         	movls	r3, #0x3
 800f266: 2304         	movhi	r3, #0x4
 800f268: 9305         	str	r3, [sp, #0x14]
 800f26a: f89d 203c    	ldrb.w	r2, [sp, #0x3c]
 800f26e: f002 030c    	and	r3, r2, #0xc
 800f272: f012 0201    	ands	r2, r2, #0x1
 800f276: f040 8119    	bne.w	0x800f4ac <vfprintf+0x45c> @ imm = #0x232
 800f27a: f01b 0f02    	tst.w	r11, #0x2
 800f27e: f040 8112    	bne.w	0x800f4a6 <vfprintf+0x456> @ imm = #0x224
 800f282: f01b 0404    	ands	r4, r11, #0x4
 800f286: f000 80f8    	beq.w	0x800f47a <vfprintf+0x42a> @ imm = #0x1f0
 800f28a: 2b00         	cmp	r3, #0x0
 800f28c: f040 8111    	bne.w	0x800f4b2 <vfprintf+0x462> @ imm = #0x222
 800f290: 2320         	movs	r3, #0x20
 800f292: f41b 5f40    	tst.w	r11, #0x3000
 800f296: d11f         	bne	0x800f2d8 <vfprintf+0x288> @ imm = #0x3e
 800f298: 9a04         	ldr	r2, [sp, #0x10]
 800f29a: 3250         	adds	r2, #0x50
 800f29c: 2e00         	cmp	r6, #0x0
 800f29e: 446a         	add	r2, sp, r2
 800f2a0: bf08         	it	eq
 800f2a2: 2601         	moveq	r6, #0x1
 800f2a4: 3a13         	subs	r2, #0x13
 800f2a6: 9904         	ldr	r1, [sp, #0x10]
 800f2a8: b121         	cbz	r1, 0x800f2b4 <vfprintf+0x264> @ imm = #0x8
 800f2aa: f812 1d01    	ldrb	r1, [r2, #-1]!
 800f2ae: 2930         	cmp	r1, #0x30
 800f2b0: f000 8136    	beq.w	0x800f520 <vfprintf+0x4d0> @ imm = #0x26c
 800f2b4: f01b 0f10    	tst.w	r11, #0x10
 800f2b8: 9a04         	ldr	r2, [sp, #0x10]
 800f2ba: bf18         	it	ne
 800f2bc: 4632         	movne	r2, r6
 800f2be: 1d39         	adds	r1, r7, #0x4
 800f2c0: f2c0 8133    	blt.w	0x800f52a <vfprintf+0x4da> @ imm = #0x266
 800f2c4: 42b7         	cmp	r7, r6
 800f2c6: f280 8130    	bge.w	0x800f52a <vfprintf+0x4da> @ imm = #0x260
 800f2ca: 42ba         	cmp	r2, r7
 800f2cc: f44b 5b00    	orr	r11, r11, #0x2000
 800f2d0: f340 812d    	ble.w	0x800f52e <vfprintf+0x4de> @ imm = #0x25a
 800f2d4: 1c7e         	adds	r6, r7, #0x1
 800f2d6: 1b96         	subs	r6, r2, r6
 800f2d8: f41b 5200    	ands	r2, r11, #0x2000
 800f2dc: 920a         	str	r2, [sp, #0x28]
 800f2de: f000 8128    	beq.w	0x800f532 <vfprintf+0x4e2> @ imm = #0x250
 800f2e2: ea27 74e7    	bic.w	r4, r7, r7, asr #31
 800f2e6: 3401         	adds	r4, #0x1
 800f2e8: b103         	cbz	r3, 0x800f2ec <vfprintf+0x29c> @ imm = #0x0
 800f2ea: 3401         	adds	r4, #0x1
 800f2ec: 2e00         	cmp	r6, #0x0
 800f2ee: f000 8128    	beq.w	0x800f542 <vfprintf+0x4f2> @ imm = #0x250
 800f2f2: 1c72         	adds	r2, r6, #0x1
 800f2f4: 4414         	add	r4, r2
 800f2f6: 45a2         	cmp	r10, r4
 800f2f8: bfcc         	ite	gt
 800f2fa: ebaa 0404    	subgt.w	r4, r10, r4
 800f2fe: 2400         	movle	r4, #0x0
 800f300: f01b 0f09    	tst.w	r11, #0x9
 800f304: d104         	bne	0x800f310 <vfprintf+0x2c0> @ imm = #0x8
 800f306: 442c         	add	r4, r5
 800f308: 42a5         	cmp	r5, r4
 800f30a: f040 811f    	bne.w	0x800f54c <vfprintf+0x4fc> @ imm = #0x23e
 800f30e: 2400         	movs	r4, #0x0
 800f310: b143         	cbz	r3, 0x800f324 <vfprintf+0x2d4> @ imm = #0x10
 800f312: 4618         	mov	r0, r3
 800f314: 4641         	mov	r1, r8
 800f316: 9b03         	ldr	r3, [sp, #0xc]
 800f318: 4798         	blx	r3
 800f31a: 2800         	cmp	r0, #0x0
 800f31c: f105 0501    	add.w	r5, r5, #0x1
 800f320: f6ff aeb3    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x29a
 800f324: f41b 6f00    	tst.w	r11, #0x800
 800f328: d013         	beq	0x800f352 <vfprintf+0x302> @ imm = #0x26
 800f32a: 9b03         	ldr	r3, [sp, #0xc]
 800f32c: 4641         	mov	r1, r8
 800f32e: 2030         	movs	r0, #0x30
 800f330: 4798         	blx	r3
 800f332: 2800         	cmp	r0, #0x0
 800f334: f6ff aea9    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x2ae
 800f338: 9b06         	ldr	r3, [sp, #0x18]
 800f33a: f1c3 0078    	rsb.w	r0, r3, #0x78
 800f33e: 4641         	mov	r1, r8
 800f340: 9b03         	ldr	r3, [sp, #0xc]
 800f342: f000 00f8    	and	r0, r0, #0xf8
 800f346: 4798         	blx	r3
 800f348: 2800         	cmp	r0, #0x0
 800f34a: f105 0502    	add.w	r5, r5, #0x2
 800f34e: f6ff ae9c    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x2c8
 800f352: f01b 0f08    	tst.w	r11, #0x8
 800f356: d105         	bne	0x800f364 <vfprintf+0x314> @ imm = #0xa
 800f358: 442c         	add	r4, r5
 800f35a: 42ac         	cmp	r4, r5
 800f35c: f040 8102    	bne.w	0x800f564 <vfprintf+0x514> @ imm = #0x204
 800f360: 4625         	mov	r5, r4
 800f362: 2400         	movs	r4, #0x0
 800f364: 9b0a         	ldr	r3, [sp, #0x28]
 800f366: 2b00         	cmp	r3, #0x0
 800f368: f000 811c    	beq.w	0x800f5a4 <vfprintf+0x554> @ imm = #0x238
 800f36c: ea27 7ae7    	bic.w	r10, r7, r7, asr #31
 800f370: eba7 070a    	sub.w	r7, r7, r10
 800f374: 4276         	rsbs	r6, r6, #0
 800f376: 9b04         	ldr	r3, [sp, #0x10]
 800f378: 42bb         	cmp	r3, r7
 800f37a: bf84         	itt	hi
 800f37c: ab0e         	addhi	r3, sp, #0x38
 800f37e: 18fb         	addhi	r3, r7, r3
 800f380: f10a 3aff    	add.w	r10, r10, #0xffffffff
 800f384: bf88         	it	hi
 800f386: 7958         	ldrbhi	r0, [r3, #0x5]
 800f388: 9b03         	ldr	r3, [sp, #0xc]
 800f38a: bf98         	it	ls
 800f38c: 2030         	movls	r0, #0x30
 800f38e: 4556         	cmp	r6, r10
 800f390: f105 0901    	add.w	r9, r5, #0x1
 800f394: 4641         	mov	r1, r8
 800f396: f300 80ef    	bgt.w	0x800f578 <vfprintf+0x528> @ imm = #0x1de
 800f39a: 4798         	blx	r3
 800f39c: 2800         	cmp	r0, #0x0
 800f39e: f107 0701    	add.w	r7, r7, #0x1
 800f3a2: f6ff ae72    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x31c
 800f3a6: f1ba 3fff    	cmp.w	r10, #0xffffffff
 800f3aa: d108         	bne	0x800f3be <vfprintf+0x36e> @ imm = #0x10
 800f3ac: 9b03         	ldr	r3, [sp, #0xc]
 800f3ae: 4641         	mov	r1, r8
 800f3b0: 202e         	movs	r0, #0x2e
 800f3b2: 4798         	blx	r3
 800f3b4: 2800         	cmp	r0, #0x0
 800f3b6: f6ff ae68    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x330
 800f3ba: f105 0902    	add.w	r9, r5, #0x2
 800f3be: 464d         	mov	r5, r9
 800f3c0: e7d9         	b	0x800f376 <vfprintf+0x326> @ imm = #-0x4e
 800f3c2: 2f74         	cmp	r7, #0x74
 800f3c4: f43f ae9a    	beq.w	0x800f0fc <vfprintf+0xac> @ imm = #-0x2cc
 800f3c8: 2f7a         	cmp	r7, #0x7a
 800f3ca: f43f ae97    	beq.w	0x800f0fc <vfprintf+0xac> @ imm = #-0x2d2
 800f3ce: e6f8         	b	0x800f1c2 <vfprintf+0x172> @ imm = #-0x210
 800f3d0: f01b 0f80    	tst.w	r11, #0x80
 800f3d4: bf18         	it	ne
 800f3d6: f44b 7b00    	orrne	r11, r11, #0x200
 800f3da: f04b 0b80    	orr	r11, r11, #0x80
 800f3de: e68d         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0x2e6
 800f3e0: f41b 7f80    	tst.w	r11, #0x100
 800f3e4: bf18         	it	ne
 800f3e6: f44b 7b00    	orrne	r11, r11, #0x200
 800f3ea: f44b 7b80    	orr	r11, r11, #0x100
 800f3ee: e685         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0x2f6
 800f3f0: f44b 7b20    	orr	r11, r11, #0x280
 800f3f4: e682         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0x2fc
 800f3f6: 4626         	mov	r6, r4
 800f3f8: 46b3         	mov	r11, r6
 800f3fa: 4654         	mov	r4, r10
 800f3fc: 46b2         	mov	r10, r6
 800f3fe: e67d         	b	0x800f0fc <vfprintf+0xac> @ imm = #-0x306
 800f400: 43ff         	mvns	r7, r7
 800f402: f007 0320    	and	r3, r7, #0x20
 800f406: 9306         	str	r3, [sp, #0x18]
 800f408: 9b0d         	ldr	r3, [sp, #0x34]
 800f40a: 3307         	adds	r3, #0x7
 800f40c: f023 0307    	bic	r3, r3, #0x7
 800f410: f01b 0f40    	tst.w	r11, #0x40
 800f414: f103 0208    	add.w	r2, r3, #0x8
 800f418: bf08         	it	eq
 800f41a: 2606         	moveq	r6, #0x6
 800f41c: f1b9 0f65    	cmp.w	r9, #0x65
 800f420: e9d3 0100    	ldrd	r0, r1, [r3]
 800f424: 920d         	str	r2, [sp, #0x34]
 800f426: d113         	bne	0x800f450 <vfprintf+0x400> @ imm = #0x26
 800f428: 1c73         	adds	r3, r6, #0x1
 800f42a: 2200         	movs	r2, #0x0
 800f42c: b2db         	uxtb	r3, r3
 800f42e: f44b 5b80    	orr	r11, r11, #0x1000
 800f432: 4614         	mov	r4, r2
 800f434: 2b11         	cmp	r3, #0x11
 800f436: e9cd 2400    	strd	r2, r4, [sp]
 800f43a: bf28         	it	hs
 800f43c: 2311         	movhs	r3, #0x11
 800f43e: aa0e         	add	r2, sp, #0x38
 800f440: f000 fafc    	bl	0x800fa3c <__dtoa_engine> @ imm = #0x5f8
 800f444: b2c3         	uxtb	r3, r0
 800f446: 9304         	str	r3, [sp, #0x10]
 800f448: 2302         	movs	r3, #0x2
 800f44a: 9f0e         	ldr	r7, [sp, #0x38]
 800f44c: 9305         	str	r3, [sp, #0x14]
 800f44e: e6fa         	b	0x800f246 <vfprintf+0x1f6> @ imm = #-0x20c
 800f450: f1b9 0f66    	cmp.w	r9, #0x66
 800f454: d105         	bne	0x800f462 <vfprintf+0x412> @ imm = #0xa
 800f456: f44b 5b00    	orr	r11, r11, #0x2000
 800f45a: 4634         	mov	r4, r6
 800f45c: 2201         	movs	r2, #0x1
 800f45e: 2311         	movs	r3, #0x11
 800f460: e7e8         	b	0x800f434 <vfprintf+0x3e4> @ imm = #-0x30
 800f462: b2f3         	uxtb	r3, r6
 800f464: 2b01         	cmp	r3, #0x1
 800f466: f04f 0200    	mov.w	r2, #0x0
 800f46a: bf38         	it	lo
 800f46c: 2301         	movlo	r3, #0x1
 800f46e: 4614         	mov	r4, r2
 800f470: f04f 0965    	mov.w	r9, #0x65
 800f474: e7de         	b	0x800f434 <vfprintf+0x3e4> @ imm = #-0x44
 800f476: 2302         	movs	r3, #0x2
 800f478: e6f6         	b	0x800f268 <vfprintf+0x218> @ imm = #-0x214
 800f47a: 2b00         	cmp	r3, #0x0
 800f47c: f43f af09    	beq.w	0x800f292 <vfprintf+0x242> @ imm = #-0x1ee
 800f480: f1ba 0f03    	cmp.w	r10, #0x3
 800f484: dc3b         	bgt	0x800f4fe <vfprintf+0x4ae> @ imm = #0x76
 800f486: f89d 303c    	ldrb.w	r3, [sp, #0x3c]
 800f48a: 4ea6         	ldr	r6, [pc, #0x298]        @ 0x800f724 <vfprintf+0x6d4>
 800f48c: f013 0f08    	tst.w	r3, #0x8
 800f490: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x800f728 <vfprintf+0x6d8>
 800f492: bf08         	it	eq
 800f494: 461e         	moveq	r6, r3
 800f496: 4637         	mov	r7, r6
 800f498: 46b9         	mov	r9, r7
 800f49a: f817 0b01    	ldrb	r0, [r7], #1
 800f49e: bbb0         	cbnz	r0, 0x800f50e <vfprintf+0x4be> @ imm = #0x6c
 800f4a0: 1bae         	subs	r6, r5, r6
 800f4a2: 44b1         	add	r9, r6
 800f4a4: e07b         	b	0x800f59e <vfprintf+0x54e> @ imm = #0xf6
 800f4a6: bb33         	cbnz	r3, 0x800f4f6 <vfprintf+0x4a6> @ imm = #0x4c
 800f4a8: 232b         	movs	r3, #0x2b
 800f4aa: e6f2         	b	0x800f292 <vfprintf+0x242> @ imm = #-0x21c
 800f4ac: bb2b         	cbnz	r3, 0x800f4fa <vfprintf+0x4aa> @ imm = #0x4a
 800f4ae: 232d         	movs	r3, #0x2d
 800f4b0: e6ef         	b	0x800f292 <vfprintf+0x242> @ imm = #-0x222
 800f4b2: 2220         	movs	r2, #0x20
 800f4b4: f1ba 0f04    	cmp.w	r10, #0x4
 800f4b8: dd13         	ble	0x800f4e2 <vfprintf+0x492> @ imm = #0x26
 800f4ba: f01b 0f08    	tst.w	r11, #0x8
 800f4be: f1aa 0404    	sub.w	r4, r10, #0x4
 800f4c2: d10f         	bne	0x800f4e4 <vfprintf+0x494> @ imm = #0x1e
 800f4c4: 442c         	add	r4, r5
 800f4c6: 9b03         	ldr	r3, [sp, #0xc]
 800f4c8: 9204         	str	r2, [sp, #0x10]
 800f4ca: 4641         	mov	r1, r8
 800f4cc: 2020         	movs	r0, #0x20
 800f4ce: 4798         	blx	r3
 800f4d0: 2800         	cmp	r0, #0x0
 800f4d2: f105 0501    	add.w	r5, r5, #0x1
 800f4d6: f6ff add8    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x450
 800f4da: 42a5         	cmp	r5, r4
 800f4dc: 9a04         	ldr	r2, [sp, #0x10]
 800f4de: d1f2         	bne	0x800f4c6 <vfprintf+0x476> @ imm = #-0x1c
 800f4e0: b19a         	cbz	r2, 0x800f50a <vfprintf+0x4ba> @ imm = #0x26
 800f4e2: 2400         	movs	r4, #0x0
 800f4e4: 9b03         	ldr	r3, [sp, #0xc]
 800f4e6: 4641         	mov	r1, r8
 800f4e8: 4610         	mov	r0, r2
 800f4ea: 4798         	blx	r3
 800f4ec: 2800         	cmp	r0, #0x0
 800f4ee: f105 0501    	add.w	r5, r5, #0x1
 800f4f2: dac8         	bge	0x800f486 <vfprintf+0x436> @ imm = #-0x70
 800f4f4: e5c9         	b	0x800f08a <vfprintf+0x3a> @ imm = #-0x46e
 800f4f6: 222b         	movs	r2, #0x2b
 800f4f8: e7dc         	b	0x800f4b4 <vfprintf+0x464> @ imm = #-0x48
 800f4fa: 222d         	movs	r2, #0x2d
 800f4fc: e7da         	b	0x800f4b4 <vfprintf+0x464> @ imm = #-0x4c
 800f4fe: f01b 0f08    	tst.w	r11, #0x8
 800f502: f1aa 0403    	sub.w	r4, r10, #0x3
 800f506: d1be         	bne	0x800f486 <vfprintf+0x436> @ imm = #-0x84
 800f508: e7dc         	b	0x800f4c4 <vfprintf+0x474> @ imm = #-0x48
 800f50a: 4614         	mov	r4, r2
 800f50c: e7bb         	b	0x800f486 <vfprintf+0x436> @ imm = #-0x8a
 800f50e: 9b06         	ldr	r3, [sp, #0x18]
 800f510: 1ac0         	subs	r0, r0, r3
 800f512: 4641         	mov	r1, r8
 800f514: 9b03         	ldr	r3, [sp, #0xc]
 800f516: b2c0         	uxtb	r0, r0
 800f518: 4798         	blx	r3
 800f51a: 2800         	cmp	r0, #0x0
 800f51c: dabc         	bge	0x800f498 <vfprintf+0x448> @ imm = #-0x88
 800f51e: e5b4         	b	0x800f08a <vfprintf+0x3a> @ imm = #-0x498
 800f520: 9904         	ldr	r1, [sp, #0x10]
 800f522: 3901         	subs	r1, #0x1
 800f524: b2c9         	uxtb	r1, r1
 800f526: 9104         	str	r1, [sp, #0x10]
 800f528: e6bd         	b	0x800f2a6 <vfprintf+0x256> @ imm = #-0x286
 800f52a: 1e56         	subs	r6, r2, #0x1
 800f52c: e6d4         	b	0x800f2d8 <vfprintf+0x288> @ imm = #-0x258
 800f52e: 2600         	movs	r6, #0x0
 800f530: e6d2         	b	0x800f2d8 <vfprintf+0x288> @ imm = #-0x25c
 800f532: f41b 6f00    	tst.w	r11, #0x800
 800f536: 9a05         	ldr	r2, [sp, #0x14]
 800f538: bf0c         	ite	eq
 800f53a: 2403         	moveq	r4, #0x3
 800f53c: 2405         	movne	r4, #0x5
 800f53e: 4414         	add	r4, r2
 800f540: e6d2         	b	0x800f2e8 <vfprintf+0x298> @ imm = #-0x25c
 800f542: f01b 0f10    	tst.w	r11, #0x10
 800f546: bf18         	it	ne
 800f548: 3401         	addne	r4, #0x1
 800f54a: e6d4         	b	0x800f2f6 <vfprintf+0x2a6> @ imm = #-0x258
 800f54c: 930b         	str	r3, [sp, #0x2c]
 800f54e: 4641         	mov	r1, r8
 800f550: 9b03         	ldr	r3, [sp, #0xc]
 800f552: 2020         	movs	r0, #0x20
 800f554: 4798         	blx	r3
 800f556: 2800         	cmp	r0, #0x0
 800f558: 9b0b         	ldr	r3, [sp, #0x2c]
 800f55a: f105 0501    	add.w	r5, r5, #0x1
 800f55e: f6bf aed3    	bge.w	0x800f308 <vfprintf+0x2b8> @ imm = #-0x25a
 800f562: e592         	b	0x800f08a <vfprintf+0x3a> @ imm = #-0x4dc
 800f564: 9b03         	ldr	r3, [sp, #0xc]
 800f566: 4641         	mov	r1, r8
 800f568: 2030         	movs	r0, #0x30
 800f56a: 4798         	blx	r3
 800f56c: 2800         	cmp	r0, #0x0
 800f56e: f105 0501    	add.w	r5, r5, #0x1
 800f572: f6bf aef2    	bge.w	0x800f35a <vfprintf+0x30a> @ imm = #-0x21c
 800f576: e588         	b	0x800f08a <vfprintf+0x3a> @ imm = #-0x4f0
 800f578: 4798         	blx	r3
 800f57a: 2800         	cmp	r0, #0x0
 800f57c: f6ff ad85    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x4f6
 800f580: f01b 0f10    	tst.w	r11, #0x10
 800f584: d00b         	beq	0x800f59e <vfprintf+0x54e> @ imm = #0x16
 800f586: f1ba 3fff    	cmp.w	r10, #0xffffffff
 800f58a: d108         	bne	0x800f59e <vfprintf+0x54e> @ imm = #0x10
 800f58c: f105 0902    	add.w	r9, r5, #0x2
 800f590: 4641         	mov	r1, r8
 800f592: 202e         	movs	r0, #0x2e
 800f594: 9b03         	ldr	r3, [sp, #0xc]
 800f596: 4798         	blx	r3
 800f598: 2800         	cmp	r0, #0x0
 800f59a: f6ff ad76    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x514
 800f59e: 464d         	mov	r5, r9
 800f5a0: 444c         	add	r4, r9
 800f5a2: e233         	b	0x800fa0c <vfprintf+0x9bc> @ imm = #0x466
 800f5a4: f89d 003d    	ldrb.w	r0, [sp, #0x3d]
 800f5a8: 9b03         	ldr	r3, [sp, #0xc]
 800f5aa: 4641         	mov	r1, r8
 800f5ac: 4798         	blx	r3
 800f5ae: 2800         	cmp	r0, #0x0
 800f5b0: f6ff ad6b    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x52a
 800f5b4: 2e00         	cmp	r6, #0x0
 800f5b6: dd69         	ble	0x800f68c <vfprintf+0x63c> @ imm = #0xd2
 800f5b8: 9b03         	ldr	r3, [sp, #0xc]
 800f5ba: 4641         	mov	r1, r8
 800f5bc: 202e         	movs	r0, #0x2e
 800f5be: 4798         	blx	r3
 800f5c0: 2800         	cmp	r0, #0x0
 800f5c2: f6ff ad62    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x53c
 800f5c6: f04f 0a01    	mov.w	r10, #0x1
 800f5ca: 9b04         	ldr	r3, [sp, #0x10]
 800f5cc: 459a         	cmp	r10, r3
 800f5ce: bfbb         	ittet	lt
 800f5d0: ab0e         	addlt	r3, sp, #0x38
 800f5d2: 4453         	addlt	r3, r10
 800f5d4: 2030         	movge	r0, #0x30
 800f5d6: 7958         	ldrblt	r0, [r3, #0x5]
 800f5d8: 9b03         	ldr	r3, [sp, #0xc]
 800f5da: 4641         	mov	r1, r8
 800f5dc: 4798         	blx	r3
 800f5de: 2800         	cmp	r0, #0x0
 800f5e0: 46d3         	mov	r11, r10
 800f5e2: f6ff ad52    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x55c
 800f5e6: f10a 0a01    	add.w	r10, r10, #0x1
 800f5ea: 4556         	cmp	r6, r10
 800f5ec: daed         	bge	0x800f5ca <vfprintf+0x57a> @ imm = #-0x26
 800f5ee: 3502         	adds	r5, #0x2
 800f5f0: 445d         	add	r5, r11
 800f5f2: 9b06         	ldr	r3, [sp, #0x18]
 800f5f4: eba9 0003    	sub.w	r0, r9, r3
 800f5f8: 4641         	mov	r1, r8
 800f5fa: 9b03         	ldr	r3, [sp, #0xc]
 800f5fc: b2c0         	uxtb	r0, r0
 800f5fe: 4798         	blx	r3
 800f600: 2800         	cmp	r0, #0x0
 800f602: f6ff ad42    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x57c
 800f606: 2f00         	cmp	r7, #0x0
 800f608: bfb4         	ite	lt
 800f60a: 202d         	movlt	r0, #0x2d
 800f60c: 202b         	movge	r0, #0x2b
 800f60e: 9b03         	ldr	r3, [sp, #0xc]
 800f610: 4641         	mov	r1, r8
 800f612: bfb8         	it	lt
 800f614: 427f         	rsblt	r7, r7, #0
 800f616: 4798         	blx	r3
 800f618: 2800         	cmp	r0, #0x0
 800f61a: f6ff ad36    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x594
 800f61e: 9b05         	ldr	r3, [sp, #0x14]
 800f620: 2b04         	cmp	r3, #0x4
 800f622: d141         	bne	0x800f6a8 <vfprintf+0x658> @ imm = #0x82
 800f624: f44f 797a    	mov.w	r9, #0x3e8
 800f628: fbb7 f6f9    	udiv	r6, r7, r9
 800f62c: f106 0030    	add.w	r0, r6, #0x30
 800f630: 9b03         	ldr	r3, [sp, #0xc]
 800f632: 4641         	mov	r1, r8
 800f634: b2c0         	uxtb	r0, r0
 800f636: 4798         	blx	r3
 800f638: 2800         	cmp	r0, #0x0
 800f63a: f105 0503    	add.w	r5, r5, #0x3
 800f63e: f6ff ad24    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x5b8
 800f642: fb09 7716    	mls	r7, r9, r6, r7
 800f646: f04f 0964    	mov.w	r9, #0x64
 800f64a: fbb7 f6f9    	udiv	r6, r7, r9
 800f64e: f106 0030    	add.w	r0, r6, #0x30
 800f652: 9b03         	ldr	r3, [sp, #0xc]
 800f654: 4641         	mov	r1, r8
 800f656: b2c0         	uxtb	r0, r0
 800f658: 4798         	blx	r3
 800f65a: 2800         	cmp	r0, #0x0
 800f65c: f105 0501    	add.w	r5, r5, #0x1
 800f660: f6ff ad13    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x5da
 800f664: fb09 7716    	mls	r7, r9, r6, r7
 800f668: f04f 090a    	mov.w	r9, #0xa
 800f66c: fbb7 f6f9    	udiv	r6, r7, r9
 800f670: f106 0030    	add.w	r0, r6, #0x30
 800f674: 9b03         	ldr	r3, [sp, #0xc]
 800f676: 4641         	mov	r1, r8
 800f678: b2c0         	uxtb	r0, r0
 800f67a: 4798         	blx	r3
 800f67c: 2800         	cmp	r0, #0x0
 800f67e: f105 0501    	add.w	r5, r5, #0x1
 800f682: f6ff ad02    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x5fc
 800f686: fb09 7716    	mls	r7, r9, r6, r7
 800f68a: e015         	b	0x800f6b8 <vfprintf+0x668> @ imm = #0x2a
 800f68c: f01b 0f10    	tst.w	r11, #0x10
 800f690: d101         	bne	0x800f696 <vfprintf+0x646> @ imm = #0x2
 800f692: 3501         	adds	r5, #0x1
 800f694: e7ad         	b	0x800f5f2 <vfprintf+0x5a2> @ imm = #-0xa6
 800f696: 9b03         	ldr	r3, [sp, #0xc]
 800f698: 4641         	mov	r1, r8
 800f69a: 202e         	movs	r0, #0x2e
 800f69c: 4798         	blx	r3
 800f69e: 2800         	cmp	r0, #0x0
 800f6a0: f105 0502    	add.w	r5, r5, #0x2
 800f6a4: daa5         	bge	0x800f5f2 <vfprintf+0x5a2> @ imm = #-0xb6
 800f6a6: e4f0         	b	0x800f08a <vfprintf+0x3a> @ imm = #-0x620
 800f6a8: 9b05         	ldr	r3, [sp, #0x14]
 800f6aa: 2b03         	cmp	r3, #0x3
 800f6ac: f105 0502    	add.w	r5, r5, #0x2
 800f6b0: d0c9         	beq	0x800f646 <vfprintf+0x5f6> @ imm = #-0x6e
 800f6b2: 9b05         	ldr	r3, [sp, #0x14]
 800f6b4: 2b01         	cmp	r3, #0x1
 800f6b6: d1d7         	bne	0x800f668 <vfprintf+0x618> @ imm = #-0x52
 800f6b8: f107 0030    	add.w	r0, r7, #0x30
 800f6bc: f105 0901    	add.w	r9, r5, #0x1
 800f6c0: 4641         	mov	r1, r8
 800f6c2: b2c0         	uxtb	r0, r0
 800f6c4: e766         	b	0x800f594 <vfprintf+0x544> @ imm = #-0x134
 800f6c6: f1a7 0363    	sub.w	r3, r7, #0x63
 800f6ca: 2b12         	cmp	r3, #0x12
 800f6cc: f200 80ff    	bhi.w	0x800f8ce <vfprintf+0x87e> @ imm = #0x1fe
 800f6d0: e8df f013    	tbh	[pc, r3, lsl #1]

0800f6d4 <$d>:
 800f6d4: 13 00 57 00  	.word	0x00570013
 800f6d8: fd 00 fd 00  	.word	0x00fd00fd
 800f6dc: fd 00 fd 00  	.word	0x00fd00fd
 800f6e0: 57 00 fd 00  	.word	0x00fd0057
 800f6e4: fd 00 fd 00  	.word	0x00fd00fd
 800f6e8: fd 00 fd 00  	.word	0x00fd00fd
 800f6ec: 17 01 f8 00  	.word	0x00f80117
 800f6f0: fd 00 fd 00  	.word	0x00fd00fd
 800f6f4: 2c 00 fd 00  	.word	0x00fd002c
 800f6f8: b9 00        	.short	0x00b9

0800f6fa <$t>:
 800f6fa: 9b0d         	ldr	r3, [sp, #0x34]
 800f6fc: 1d1a         	adds	r2, r3, #0x4
 800f6fe: 681b         	ldr	r3, [r3]
 800f700: 920d         	str	r2, [sp, #0x34]
 800f702: f88d 3038    	strb.w	r3, [sp, #0x38]
 800f706: 2401         	movs	r4, #0x1
 800f708: af0e         	add	r7, sp, #0x38
 800f70a: f01b 0f08    	tst.w	r11, #0x8
 800f70e: d02e         	beq	0x800f76e <vfprintf+0x71e> @ imm = #0x5c
 800f710: 193e         	adds	r6, r7, r4
 800f712: 46b9         	mov	r9, r7
 800f714: 45b1         	cmp	r9, r6
 800f716: d12c         	bne	0x800f772 <vfprintf+0x722> @ imm = #0x58
 800f718: 1bef         	subs	r7, r5, r7
 800f71a: 44b9         	add	r9, r7
 800f71c: ebaa 0404    	sub.w	r4, r10, r4
 800f720: e73d         	b	0x800f59e <vfprintf+0x54e> @ imm = #-0x186
 800f722: bf00         	nop

0800f724 <$d>:
 800f724: 8d bf 01 08  	.word	0x0801bf8d
 800f728: 89 bf 01 08  	.word	0x0801bf89

0800f72c <$t>:
 800f72c: 9b0d         	ldr	r3, [sp, #0x34]
 800f72e: 1d1a         	adds	r2, r3, #0x4
 800f730: 920d         	str	r2, [sp, #0x34]
 800f732: 681f         	ldr	r7, [r3]
 800f734: 4bab         	ldr	r3, [pc, #0x2ac]        @ 0x800f9e4 <vfprintf+0x994>
 800f736: 2f00         	cmp	r7, #0x0
 800f738: bf08         	it	eq
 800f73a: 461f         	moveq	r7, r3
 800f73c: f01b 0f40    	tst.w	r11, #0x40
 800f740: bf14         	ite	ne
 800f742: 4631         	movne	r1, r6
 800f744: f04f 31ff    	moveq.w	r1, #0xffffffff
 800f748: 4638         	mov	r0, r7
 800f74a: f009 fb14    	bl	0x8018d76 <strnlen>     @ imm = #0x9628
 800f74e: 4604         	mov	r4, r0
 800f750: e7db         	b	0x800f70a <vfprintf+0x6ba> @ imm = #-0x4a
 800f752: 9b03         	ldr	r3, [sp, #0xc]
 800f754: 4641         	mov	r1, r8
 800f756: 2020         	movs	r0, #0x20
 800f758: 4798         	blx	r3
 800f75a: 2800         	cmp	r0, #0x0
 800f75c: f6ff ac95    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x6d6
 800f760: 3e01         	subs	r6, #0x1
 800f762: 42b4         	cmp	r4, r6
 800f764: d3f5         	blo	0x800f752 <vfprintf+0x702> @ imm = #-0x16
 800f766: 4455         	add	r5, r10
 800f768: 1bad         	subs	r5, r5, r6
 800f76a: 46b2         	mov	r10, r6
 800f76c: e7d0         	b	0x800f710 <vfprintf+0x6c0> @ imm = #-0x60
 800f76e: 4656         	mov	r6, r10
 800f770: e7f7         	b	0x800f762 <vfprintf+0x712> @ imm = #-0x12
 800f772: f819 0b01    	ldrb	r0, [r9], #1
 800f776: 9b03         	ldr	r3, [sp, #0xc]
 800f778: 4641         	mov	r1, r8
 800f77a: 4798         	blx	r3
 800f77c: 2800         	cmp	r0, #0x0
 800f77e: dac9         	bge	0x800f714 <vfprintf+0x6c4> @ imm = #-0x6e
 800f780: e483         	b	0x800f08a <vfprintf+0x3a> @ imm = #-0x6fa
 800f782: f01b 0f80    	tst.w	r11, #0x80
 800f786: 9b0d         	ldr	r3, [sp, #0x34]
 800f788: d035         	beq	0x800f7f6 <vfprintf+0x7a6> @ imm = #0x6a
 800f78a: f41b 7f00    	tst.w	r11, #0x200
 800f78e: d02d         	beq	0x800f7ec <vfprintf+0x79c> @ imm = #0x5a
 800f790: 3307         	adds	r3, #0x7
 800f792: f023 0307    	bic	r3, r3, #0x7
 800f796: e9d3 0100    	ldrd	r0, r1, [r3]
 800f79a: f103 0208    	add.w	r2, r3, #0x8
 800f79e: 920d         	str	r2, [sp, #0x34]
 800f7a0: f02b 0910    	bic	r9, r11, #0x10
 800f7a4: 2900         	cmp	r1, #0x0
 800f7a6: fa1f f989    	uxth.w	r9, r9
 800f7aa: da36         	bge	0x800f81a <vfprintf+0x7ca> @ imm = #0x6c
 800f7ac: 4240         	rsbs	r0, r0, #0
 800f7ae: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 800f7b2: f449 6980    	orr	r9, r9, #0x400
 800f7b6: f10d 0b38    	add.w	r11, sp, #0x38
 800f7ba: 230a         	movs	r3, #0xa
 800f7bc: 465a         	mov	r2, r11
 800f7be: f009 fae6    	bl	0x8018d8e <__ultoa_invert> @ imm = #0x95cc
 800f7c2: f019 0f40    	tst.w	r9, #0x40
 800f7c6: eba0 0b0b    	sub.w	r11, r0, r11
 800f7ca: d065         	beq	0x800f898 <vfprintf+0x848> @ imm = #0xca
 800f7cc: f029 0201    	bic	r2, r9, #0x1
 800f7d0: 455e         	cmp	r6, r11
 800f7d2: b292         	uxth	r2, r2
 800f7d4: f340 80b2    	ble.w	0x800f93c <vfprintf+0x8ec> @ imm = #0x164
 800f7d8: 2f00         	cmp	r7, #0x0
 800f7da: f000 80a9    	beq.w	0x800f930 <vfprintf+0x8e0> @ imm = #0x152
 800f7de: f019 0310    	ands	r3, r9, #0x10
 800f7e2: 4634         	mov	r4, r6
 800f7e4: 4691         	mov	r9, r2
 800f7e6: d026         	beq	0x800f836 <vfprintf+0x7e6> @ imm = #0x4c
 800f7e8: 3402         	adds	r4, #0x2
 800f7ea: e05c         	b	0x800f8a6 <vfprintf+0x856> @ imm = #0xb8
 800f7ec: 1d1a         	adds	r2, r3, #0x4
 800f7ee: 6818         	ldr	r0, [r3]
 800f7f0: 920d         	str	r2, [sp, #0x34]
 800f7f2: 17c1         	asrs	r1, r0, #0x1f
 800f7f4: e7d4         	b	0x800f7a0 <vfprintf+0x750> @ imm = #-0x58
 800f7f6: 1d1a         	adds	r2, r3, #0x4
 800f7f8: f41b 7f80    	tst.w	r11, #0x100
 800f7fc: 6819         	ldr	r1, [r3]
 800f7fe: 920d         	str	r2, [sp, #0x34]
 800f800: d101         	bne	0x800f806 <vfprintf+0x7b6> @ imm = #0x2
 800f802: 4608         	mov	r0, r1
 800f804: e7f5         	b	0x800f7f2 <vfprintf+0x7a2> @ imm = #-0x16
 800f806: f41b 7f00    	tst.w	r11, #0x200
 800f80a: bf15         	itete	ne
 800f80c: b248         	sxtbne	r0, r1
 800f80e: b208         	sxtheq	r0, r1
 800f810: f341 11c0    	sbfxne	r1, r1, #0x7, #0x1
 800f814: f341 31c0    	sbfxeq	r1, r1, #0xf, #0x1
 800f818: e7c2         	b	0x800f7a0 <vfprintf+0x750> @ imm = #-0x7c
 800f81a: ea50 0301    	orrs.w	r3, r0, r1
 800f81e: d1ca         	bne	0x800f7b6 <vfprintf+0x766> @ imm = #-0x6c
 800f820: f01b 0f40    	tst.w	r11, #0x40
 800f824: d0c7         	beq	0x800f7b6 <vfprintf+0x766> @ imm = #-0x72
 800f826: 2e00         	cmp	r6, #0x0
 800f828: d1c5         	bne	0x800f7b6 <vfprintf+0x766> @ imm = #-0x76
 800f82a: f02b 0b11    	bic	r11, r11, #0x11
 800f82e: fa1f f98b    	uxth.w	r9, r11
 800f832: 4634         	mov	r4, r6
 800f834: 46b3         	mov	r11, r6
 800f836: f240 4306    	movw	r3, #0x406
 800f83a: ea19 0303    	ands.w	r3, r9, r3
 800f83e: bf1c         	itt	ne
 800f840: 3401         	addne	r4, #0x1
 800f842: 2300         	movne	r3, #0x0
 800f844: e02f         	b	0x800f8a6 <vfprintf+0x856> @ imm = #0x5e
 800f846: f02b 0b10    	bic	r11, r11, #0x10
 800f84a: fa1f fb8b    	uxth.w	r11, r11
 800f84e: 230a         	movs	r3, #0xa
 800f850: f01b 0480    	ands	r4, r11, #0x80
 800f854: 9a0d         	ldr	r2, [sp, #0x34]
 800f856: d057         	beq	0x800f908 <vfprintf+0x8b8> @ imm = #0xae
 800f858: f41b 7100    	ands	r1, r11, #0x200
 800f85c: bf1d         	ittte	ne
 800f85e: 3207         	addne	r2, #0x7
 800f860: f022 0207    	bicne	r2, r2, #0x7
 800f864: f102 0108    	addne.w	r1, r2, #0x8
 800f868: 1d10         	addeq	r0, r2, #0x4
 800f86a: bf19         	ittee	ne
 800f86c: 910d         	strne	r1, [sp, #0x34]
 800f86e: e9d2 0100    	ldrdne	r0, r1, [r2]
 800f872: 900d         	streq	r0, [sp, #0x34]
 800f874: 6810         	ldreq	r0, [r2]
 800f876: ea50 0201    	orrs.w	r2, r0, r1
 800f87a: d152         	bne	0x800f922 <vfprintf+0x8d2> @ imm = #0xa4
 800f87c: f02b 0916    	bic	r9, r11, #0x16
 800f880: f01b 0f40    	tst.w	r11, #0x40
 800f884: fa1f f989    	uxth.w	r9, r9
 800f888: d04f         	beq	0x800f92a <vfprintf+0x8da> @ imm = #0x9e
 800f88a: 2e00         	cmp	r6, #0x0
 800f88c: d14d         	bne	0x800f92a <vfprintf+0x8da> @ imm = #0x9a
 800f88e: f02b 0b17    	bic	r11, r11, #0x17
 800f892: fa1f f98b    	uxth.w	r9, r11
 800f896: 46b3         	mov	r11, r6
 800f898: f019 0310    	ands	r3, r9, #0x10
 800f89c: d052         	beq	0x800f944 <vfprintf+0x8f4> @ imm = #0xa4
 800f89e: 2f00         	cmp	r7, #0x0
 800f8a0: d14e         	bne	0x800f940 <vfprintf+0x8f0> @ imm = #0x9c
 800f8a2: f10b 0401    	add.w	r4, r11, #0x1
 800f8a6: f019 0f08    	tst.w	r9, #0x8
 800f8aa: d15e         	bne	0x800f96a <vfprintf+0x91a> @ imm = #0xbc
 800f8ac: f019 0f01    	tst.w	r9, #0x1
 800f8b0: d006         	beq	0x800f8c0 <vfprintf+0x870> @ imm = #0xc
 800f8b2: 45a2         	cmp	r10, r4
 800f8b4: dd6e         	ble	0x800f994 <vfprintf+0x944> @ imm = #0xdc
 800f8b6: ebaa 0404    	sub.w	r4, r10, r4
 800f8ba: eb04 060b    	add.w	r6, r4, r11
 800f8be: 4654         	mov	r4, r10
 800f8c0: 4622         	mov	r2, r4
 800f8c2: e04d         	b	0x800f960 <vfprintf+0x910> @ imm = #0x9a
 800f8c4: f04b 0b10    	orr	r11, r11, #0x10
 800f8c8: 2310         	movs	r3, #0x10
 800f8ca: 2778         	movs	r7, #0x78
 800f8cc: e7c0         	b	0x800f850 <vfprintf+0x800> @ imm = #-0x80
 800f8ce: f1b9 0f78    	cmp.w	r9, #0x78
 800f8d2: d104         	bne	0x800f8de <vfprintf+0x88e> @ imm = #0x8
 800f8d4: f1c7 0378    	rsb.w	r3, r7, #0x78
 800f8d8: f043 0310    	orr	r3, r3, #0x10
 800f8dc: e7b8         	b	0x800f850 <vfprintf+0x800> @ imm = #-0x90
 800f8de: 9b03         	ldr	r3, [sp, #0xc]
 800f8e0: 4641         	mov	r1, r8
 800f8e2: 2025         	movs	r0, #0x25
 800f8e4: 4798         	blx	r3
 800f8e6: 2800         	cmp	r0, #0x0
 800f8e8: f6ff abcf    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x862
 800f8ec: 9b03         	ldr	r3, [sp, #0xc]
 800f8ee: 4641         	mov	r1, r8
 800f8f0: 4638         	mov	r0, r7
 800f8f2: 4798         	blx	r3
 800f8f4: 2800         	cmp	r0, #0x0
 800f8f6: f6ff abc8    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x870
 800f8fa: 3502         	adds	r5, #0x2
 800f8fc: 9b07         	ldr	r3, [sp, #0x1c]
 800f8fe: f7ff bbb5    	b.w	0x800f06c <vfprintf+0x1c> @ imm = #-0x896
 800f902: 2308         	movs	r3, #0x8
 800f904: 2700         	movs	r7, #0x0
 800f906: e7a3         	b	0x800f850 <vfprintf+0x800> @ imm = #-0xba
 800f908: 1d11         	adds	r1, r2, #0x4
 800f90a: 910d         	str	r1, [sp, #0x34]
 800f90c: f41b 7180    	ands	r1, r11, #0x100
 800f910: 6810         	ldr	r0, [r2]
 800f912: d0b0         	beq	0x800f876 <vfprintf+0x826> @ imm = #-0xa0
 800f914: f41b 7100    	ands	r1, r11, #0x200
 800f918: bf1a         	itte	ne
 800f91a: b2c0         	uxtbne	r0, r0
 800f91c: 4621         	movne	r1, r4
 800f91e: b280         	uxtheq	r0, r0
 800f920: e7a9         	b	0x800f876 <vfprintf+0x826> @ imm = #-0xae
 800f922: f02b 0b06    	bic	r11, r11, #0x6
 800f926: fa1f f98b    	uxth.w	r9, r11
 800f92a: f10d 0b38    	add.w	r11, sp, #0x38
 800f92e: e745         	b	0x800f7bc <vfprintf+0x76c> @ imm = #-0x176
 800f930: f029 0911    	bic	r9, r9, #0x11
 800f934: fa1f f989    	uxth.w	r9, r9
 800f938: 4634         	mov	r4, r6
 800f93a: e77c         	b	0x800f836 <vfprintf+0x7e6> @ imm = #-0x108
 800f93c: 4691         	mov	r9, r2
 800f93e: e7ab         	b	0x800f898 <vfprintf+0x848> @ imm = #-0xaa
 800f940: 465c         	mov	r4, r11
 800f942: e751         	b	0x800f7e8 <vfprintf+0x798> @ imm = #-0x15e
 800f944: 465c         	mov	r4, r11
 800f946: e776         	b	0x800f836 <vfprintf+0x7e6> @ imm = #-0x114
 800f948: e9cd 2304    	strd	r2, r3, [sp, #16]
 800f94c: 4641         	mov	r1, r8
 800f94e: 9b03         	ldr	r3, [sp, #0xc]
 800f950: 2020         	movs	r0, #0x20
 800f952: 4798         	blx	r3
 800f954: 2800         	cmp	r0, #0x0
 800f956: f6ff ab98    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x8d0
 800f95a: 9a04         	ldr	r2, [sp, #0x10]
 800f95c: 9b05         	ldr	r3, [sp, #0x14]
 800f95e: 3201         	adds	r2, #0x1
 800f960: 4592         	cmp	r10, r2
 800f962: dcf1         	bgt	0x800f948 <vfprintf+0x8f8> @ imm = #-0x1e
 800f964: 1b2c         	subs	r4, r5, r4
 800f966: 18a5         	adds	r5, r4, r2
 800f968: 4614         	mov	r4, r2
 800f96a: b1f3         	cbz	r3, 0x800f9aa <vfprintf+0x95a> @ imm = #0x3c
 800f96c: 9b03         	ldr	r3, [sp, #0xc]
 800f96e: 4641         	mov	r1, r8
 800f970: 2030         	movs	r0, #0x30
 800f972: 4798         	blx	r3
 800f974: 2800         	cmp	r0, #0x0
 800f976: f6ff ab88    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x8f0
 800f97a: b96f         	cbnz	r7, 0x800f998 <vfprintf+0x948> @ imm = #0x1a
 800f97c: 3501         	adds	r5, #0x1
 800f97e: 46a9         	mov	r9, r5
 800f980: 442e         	add	r6, r5
 800f982: eba6 0309    	sub.w	r3, r6, r9
 800f986: 455b         	cmp	r3, r11
 800f988: dc21         	bgt	0x800f9ce <vfprintf+0x97e> @ imm = #0x42
 800f98a: 465d         	mov	r5, r11
 800f98c: ae0e         	add	r6, sp, #0x38
 800f98e: bb5d         	cbnz	r5, 0x800f9e8 <vfprintf+0x998> @ imm = #0x56
 800f990: 44d9         	add	r9, r11
 800f992: e6c3         	b	0x800f71c <vfprintf+0x6cc> @ imm = #-0x27a
 800f994: 465e         	mov	r6, r11
 800f996: e793         	b	0x800f8c0 <vfprintf+0x870> @ imm = #-0xda
 800f998: 3502         	adds	r5, #0x2
 800f99a: 4641         	mov	r1, r8
 800f99c: 4638         	mov	r0, r7
 800f99e: 9b03         	ldr	r3, [sp, #0xc]
 800f9a0: 4798         	blx	r3
 800f9a2: 2800         	cmp	r0, #0x0
 800f9a4: daeb         	bge	0x800f97e <vfprintf+0x92e> @ imm = #-0x2a
 800f9a6: f7ff bb70    	b.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x920
 800f9aa: f240 4306    	movw	r3, #0x406
 800f9ae: ea19 0f03    	tst.w	r9, r3
 800f9b2: d0e4         	beq	0x800f97e <vfprintf+0x92e> @ imm = #-0x38
 800f9b4: f019 0f02    	tst.w	r9, #0x2
 800f9b8: bf14         	ite	ne
 800f9ba: 202b         	movne	r0, #0x2b
 800f9bc: 2020         	moveq	r0, #0x20
 800f9be: f419 6f80    	tst.w	r9, #0x400
 800f9c2: f105 0501    	add.w	r5, r5, #0x1
 800f9c6: 4641         	mov	r1, r8
 800f9c8: bf18         	it	ne
 800f9ca: 202d         	movne	r0, #0x2d
 800f9cc: e7e7         	b	0x800f99e <vfprintf+0x94e> @ imm = #-0x32
 800f9ce: 9b03         	ldr	r3, [sp, #0xc]
 800f9d0: 4641         	mov	r1, r8
 800f9d2: 2030         	movs	r0, #0x30
 800f9d4: 4798         	blx	r3
 800f9d6: 2800         	cmp	r0, #0x0
 800f9d8: f109 0901    	add.w	r9, r9, #0x1
 800f9dc: dad1         	bge	0x800f982 <vfprintf+0x932> @ imm = #-0x5e
 800f9de: f7ff bb54    	b.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x958
 800f9e2: bf00         	nop

0800f9e4 <$d>:
 800f9e4: 91 bf 01 08  	.word	0x0801bf91

0800f9e8 <$t>:
 800f9e8: 3d01         	subs	r5, #0x1
 800f9ea: 9b03         	ldr	r3, [sp, #0xc]
 800f9ec: 5d70         	ldrb	r0, [r6, r5]
 800f9ee: 4641         	mov	r1, r8
 800f9f0: 4798         	blx	r3
 800f9f2: 2800         	cmp	r0, #0x0
 800f9f4: dacb         	bge	0x800f98e <vfprintf+0x93e> @ imm = #-0x6a
 800f9f6: f7ff bb48    	b.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x970
 800f9fa: 9b03         	ldr	r3, [sp, #0xc]
 800f9fc: 4641         	mov	r1, r8
 800f9fe: 2020         	movs	r0, #0x20
 800fa00: 4798         	blx	r3
 800fa02: 2800         	cmp	r0, #0x0
 800fa04: f105 0501    	add.w	r5, r5, #0x1
 800fa08: f6ff ab3f    	blt.w	0x800f08a <vfprintf+0x3a> @ imm = #-0x982
 800fa0c: 1b63         	subs	r3, r4, r5
 800fa0e: 2b00         	cmp	r3, #0x0
 800fa10: dcf3         	bgt	0x800f9fa <vfprintf+0x9aa> @ imm = #-0x1a
 800fa12: e773         	b	0x800f8fc <vfprintf+0x8ac> @ imm = #-0x11a

0800fa14 <div10>:
 800fa14: b51f         	push	{r0, r1, r2, r3, r4, lr}
 800fa16: ab02         	add	r3, sp, #0x8
 800fa18: 9300         	str	r3, [sp]
 800fa1a: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800fa38 <div10+0x24>
 800fa1c: f04f 33cc    	mov.w	r3, #0xcccccccc
 800fa20: f009 fa98    	bl	0x8018f54 <__umul128>   @ imm = #0x9530
 800fa24: e9dd 0102    	ldrd	r0, r1, [sp, #8]
 800fa28: 08c0         	lsrs	r0, r0, #0x3
 800fa2a: ea40 7041    	orr.w	r0, r0, r1, lsl #29
 800fa2e: 08c9         	lsrs	r1, r1, #0x3
 800fa30: b005         	add	sp, #0x14
 800fa32: f85d fb04    	ldr	pc, [sp], #4
 800fa36: bf00         	nop

0800fa38 <$d>:
 800fa38: cd cc cc cc  	.word	0xcccccccd

0800fa3c <__dtoa_engine>:
 800fa3c: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800fa40: b09b         	sub	sp, #0x6c
 800fa42: 4604         	mov	r4, r0
 800fa44: 9205         	str	r2, [sp, #0x14]
 800fa46: 460a         	mov	r2, r1
 800fa48: 930a         	str	r3, [sp, #0x28]
 800fa4a: f3c2 550a    	ubfx	r5, r2, #0x14, #0xb
 800fa4e: f89d 3090    	ldrb.w	r3, [sp, #0x90]
 800fa52: 930b         	str	r3, [sp, #0x2c]
 800fa54: 0fd2         	lsrs	r2, r2, #0x1f
 800fa56: f3c1 0313    	ubfx	r3, r1, #0x0, #0x14
 800fa5a: 9209         	str	r2, [sp, #0x24]
 800fa5c: 0d09         	lsrs	r1, r1, #0x14
 800fa5e: b97d         	cbnz	r5, 0x800fa80 <__dtoa_engine+0x44> @ imm = #0x1e
 800fa60: ea50 0203    	orrs.w	r2, r0, r3
 800fa64: d11b         	bne	0x800fa9e <__dtoa_engine+0x62> @ imm = #0x36
 800fa66: 9a05         	ldr	r2, [sp, #0x14]
 800fa68: 2330         	movs	r3, #0x30
 800fa6a: 7153         	strb	r3, [r2, #0x5]
 800fa6c: 9b09         	ldr	r3, [sp, #0x24]
 800fa6e: 6015         	str	r5, [r2]
 800fa70: f043 0302    	orr	r3, r3, #0x2
 800fa74: 7113         	strb	r3, [r2, #0x4]
 800fa76: 2701         	movs	r7, #0x1
 800fa78: 4638         	mov	r0, r7
 800fa7a: b01b         	add	sp, #0x6c
 800fa7c: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800fa80: f240 72ff    	movw	r2, #0x7ff
 800fa84: 4295         	cmp	r5, r2
 800fa86: d14a         	bne	0x800fb1e <__dtoa_engine+0xe2> @ imm = #0x94
 800fa88: 4303         	orrs	r3, r0
 800fa8a: 9b09         	ldr	r3, [sp, #0x24]
 800fa8c: 9a05         	ldr	r2, [sp, #0x14]
 800fa8e: bf14         	ite	ne
 800fa90: f043 0308    	orrne	r3, r3, #0x8
 800fa94: f043 0304    	orreq	r3, r3, #0x4
 800fa98: 7113         	strb	r3, [r2, #0x4]
 800fa9a: 2700         	movs	r7, #0x0
 800fa9c: e7ec         	b	0x800fa78 <__dtoa_engine+0x3c> @ imm = #-0x28
 800fa9e: f000 0201    	and	r2, r0, #0x1
 800faa2: 9208         	str	r2, [sp, #0x20]
 800faa4: ea4f 0883    	lsl.w	r8, r3, #0x2
 800faa8: 2201         	movs	r2, #0x1
 800faaa: 4dac         	ldr	r5, [pc, #0x2b0]        @ 0x800fd5c <__dtoa_engine+0x320>
 800faac: ea48 7890    	orr.w	r8, r8, r0, lsr #30
 800fab0: 0087         	lsls	r7, r0, #0x2
 800fab2: 469a         	mov	r10, r3
 800fab4: 4616         	mov	r6, r2
 800fab6: f1c5 0b00    	rsb.w	r11, r5, #0x0
 800faba: 4658         	mov	r0, r11
 800fabc: 9206         	str	r2, [sp, #0x18]
 800fabe: f000 fa11    	bl	0x800fee4 <__log10Pow5> @ imm = #0x422
 800fac2: f1b5 3fff    	cmp.w	r5, #0xffffffff
 800fac6: bfac         	ite	ge
 800fac8: 4681         	movge	r9, r0
 800faca: f1a0 0901    	sublt.w	r9, r0, #0x1
 800face: ebab 0b09    	sub.w	r11, r11, r9
 800fad2: eb09 0305    	add.w	r3, r9, r5
 800fad6: 4658         	mov	r0, r11
 800fad8: 9304         	str	r3, [sp, #0x10]
 800fada: f000 fa09    	bl	0x800fef0 <__pow5bits>  @ imm = #0x412
 800fade: a916         	add	r1, sp, #0x58
 800fae0: f1a0 057d    	sub.w	r5, r0, #0x7d
 800fae4: 4658         	mov	r0, r11
 800fae6: f000 fa23    	bl	0x800ff30 <__double_computePow5> @ imm = #0x446
 800faea: ab12         	add	r3, sp, #0x48
 800faec: 9a06         	ldr	r2, [sp, #0x18]
 800faee: 9301         	str	r3, [sp, #0x4]
 800faf0: eba9 0505    	sub.w	r5, r9, r5
 800faf4: ab10         	add	r3, sp, #0x40
 800faf6: 9202         	str	r2, [sp, #0x8]
 800faf8: 9300         	str	r3, [sp]
 800fafa: 4620         	mov	r0, r4
 800fafc: 462b         	mov	r3, r5
 800fafe: aa16         	add	r2, sp, #0x58
 800fb00: 4651         	mov	r1, r10
 800fb02: f009 f96c    	bl	0x8018dde <mulShiftAll64> @ imm = #0x92d8
 800fb06: f1b9 0f01    	cmp.w	r9, #0x1
 800fb0a: 4604         	mov	r4, r0
 800fb0c: 460d         	mov	r5, r1
 800fb0e: f200 80d2    	bhi.w	0x800fcb6 <__dtoa_engine+0x27a> @ imm = #0x1a4
 800fb12: 9b08         	ldr	r3, [sp, #0x20]
 800fb14: 2b00         	cmp	r3, #0x0
 800fb16: f040 80c5    	bne.w	0x800fca4 <__dtoa_engine+0x268> @ imm = #0x18a
 800fb1a: 2701         	movs	r7, #0x1
 800fb1c: e06b         	b	0x800fbf6 <__dtoa_engine+0x1ba> @ imm = #0xd6
 800fb1e: f443 1a80    	orr	r10, r3, #0x100000
 800fb22: f000 0201    	and	r2, r0, #0x1
 800fb26: ea4f 088a    	lsl.w	r8, r10, #0x2
 800fb2a: 4303         	orrs	r3, r0
 800fb2c: f2a5 4535    	subw	r5, r5, #0x435
 800fb30: 9208         	str	r2, [sp, #0x20]
 800fb32: ea48 7890    	orr.w	r8, r8, r0, lsr #30
 800fb36: ea4f 0780    	lsl.w	r7, r0, #0x2
 800fb3a: d149         	bne	0x800fbd0 <__dtoa_engine+0x194> @ imm = #0x92
 800fb3c: f240 73fe    	movw	r3, #0x7fe
 800fb40: 4219         	tst	r1, r3
 800fb42: bf0c         	ite	eq
 800fb44: 2601         	moveq	r6, #0x1
 800fb46: 2600         	movne	r6, #0x0
 800fb48: 2d00         	cmp	r5, #0x0
 800fb4a: 4632         	mov	r2, r6
 800fb4c: dbb3         	blt	0x800fab6 <__dtoa_engine+0x7a> @ imm = #-0x9a
 800fb4e: 4628         	mov	r0, r5
 800fb50: f000 f9c2    	bl	0x800fed8 <__log10Pow2> @ imm = #0x384
 800fb54: 2d03         	cmp	r5, #0x3
 800fb56: bfc8         	it	gt
 800fb58: 3801         	subgt	r0, #0x1
 800fb5a: 9004         	str	r0, [sp, #0x10]
 800fb5c: f000 f9c8    	bl	0x800fef0 <__pow5bits>  @ imm = #0x390
 800fb60: 9b04         	ldr	r3, [sp, #0x10]
 800fb62: 307c         	adds	r0, #0x7c
 800fb64: 1b5d         	subs	r5, r3, r5
 800fb66: 4405         	add	r5, r0
 800fb68: a916         	add	r1, sp, #0x58
 800fb6a: 4618         	mov	r0, r3
 800fb6c: f000 fa54    	bl	0x8010018 <__double_computeInvPow5> @ imm = #0x4a8
 800fb70: ab12         	add	r3, sp, #0x48
 800fb72: 9301         	str	r3, [sp, #0x4]
 800fb74: ab10         	add	r3, sp, #0x40
 800fb76: 9300         	str	r3, [sp]
 800fb78: 4620         	mov	r0, r4
 800fb7a: 462b         	mov	r3, r5
 800fb7c: 9602         	str	r6, [sp, #0x8]
 800fb7e: aa16         	add	r2, sp, #0x58
 800fb80: 4651         	mov	r1, r10
 800fb82: f009 f92c    	bl	0x8018dde <mulShiftAll64> @ imm = #0x9258
 800fb86: 9b04         	ldr	r3, [sp, #0x10]
 800fb88: 2b15         	cmp	r3, #0x15
 800fb8a: 4604         	mov	r4, r0
 800fb8c: 460d         	mov	r5, r1
 800fb8e: f200 8086    	bhi.w	0x800fc9e <__dtoa_engine+0x262> @ imm = #0x10c
 800fb92: ab14         	add	r3, sp, #0x50
 800fb94: 4a72         	ldr	r2, [pc, #0x1c8]        @ 0x800fd60 <__dtoa_engine+0x324>
 800fb96: 9300         	str	r3, [sp]
 800fb98: 4638         	mov	r0, r7
 800fb9a: f04f 33cc    	mov.w	r3, #0xcccccccc
 800fb9e: 4641         	mov	r1, r8
 800fba0: f009 f9d8    	bl	0x8018f54 <__umul128>   @ imm = #0x93b0
 800fba4: 9b14         	ldr	r3, [sp, #0x50]
 800fba6: 9a15         	ldr	r2, [sp, #0x54]
 800fba8: 089b         	lsrs	r3, r3, #0x2
 800fbaa: ea43 7382    	orr.w	r3, r3, r2, lsl #30
 800fbae: eb03 0383    	add.w	r3, r3, r3, lsl #2
 800fbb2: 42bb         	cmp	r3, r7
 800fbb4: e9dd 9a10    	ldrd	r9, r10, [sp, #64]
 800fbb8: d10c         	bne	0x800fbd4 <__dtoa_engine+0x198> @ imm = #0x18
 800fbba: 4638         	mov	r0, r7
 800fbbc: 4641         	mov	r1, r8
 800fbbe: f000 f99f    	bl	0x800ff00 <__pow5Factor> @ imm = #0x33e
 800fbc2: 9b04         	ldr	r3, [sp, #0x10]
 800fbc4: 4283         	cmp	r3, r0
 800fbc6: bf8c         	ite	hi
 800fbc8: 2700         	movhi	r7, #0x0
 800fbca: 2701         	movls	r7, #0x1
 800fbcc: 2600         	movs	r6, #0x0
 800fbce: e012         	b	0x800fbf6 <__dtoa_engine+0x1ba> @ imm = #0x24
 800fbd0: 2601         	movs	r6, #0x1
 800fbd2: e7b9         	b	0x800fb48 <__dtoa_engine+0x10c> @ imm = #-0x8e
 800fbd4: 9b08         	ldr	r3, [sp, #0x20]
 800fbd6: 2b00         	cmp	r3, #0x0
 800fbd8: d151         	bne	0x800fc7e <__dtoa_engine+0x242> @ imm = #0xa2
 800fbda: 3f01         	subs	r7, #0x1
 800fbdc: f148 31ff    	adc	r1, r8, #0xffffffff
 800fbe0: 1bb8         	subs	r0, r7, r6
 800fbe2: f161 0100    	sbc	r1, r1, #0x0
 800fbe6: f000 f98b    	bl	0x800ff00 <__pow5Factor> @ imm = #0x316
 800fbea: 9b04         	ldr	r3, [sp, #0x10]
 800fbec: 9f08         	ldr	r7, [sp, #0x20]
 800fbee: 4283         	cmp	r3, r0
 800fbf0: bf8c         	ite	hi
 800fbf2: 2600         	movhi	r6, #0x0
 800fbf4: 2601         	movls	r6, #0x1
 800fbf6: 9b0b         	ldr	r3, [sp, #0x2c]
 800fbf8: 2b00         	cmp	r3, #0x0
 800fbfa: f040 8091    	bne.w	0x800fd20 <__dtoa_engine+0x2e4> @ imm = #0x122
 800fbfe: f8dd b028    	ldr.w	r11, [sp, #0x28]
 800fc02: f04f 0800    	mov.w	r8, #0x0
 800fc06: e9cd 8806    	strd	r8, r8, [sp, #24]
 800fc0a: f04f 0a0a    	mov.w	r10, #0xa
 800fc0e: e9dd 0110    	ldrd	r0, r1, [sp, #64]
 800fc12: f7ff feff    	bl	0x800fa14 <div10>       @ imm = #-0x202
 800fc16: 9b12         	ldr	r3, [sp, #0x48]
 800fc18: 930e         	str	r3, [sp, #0x38]
 800fc1a: e9cd 010c    	strd	r0, r1, [sp, #48]
 800fc1e: 4618         	mov	r0, r3
 800fc20: 9913         	ldr	r1, [sp, #0x4c]
 800fc22: f7ff fef7    	bl	0x800fa14 <div10>       @ imm = #-0x212
 800fc26: 9b0c         	ldr	r3, [sp, #0x30]
 800fc28: 9a0d         	ldr	r2, [sp, #0x34]
 800fc2a: 910f         	str	r1, [sp, #0x3c]
 800fc2c: 4298         	cmp	r0, r3
 800fc2e: 460b         	mov	r3, r1
 800fc30: 4193         	sbcs	r3, r2
 800fc32: 4681         	mov	r9, r0
 800fc34: f080 808e    	bhs.w	0x800fd54 <__dtoa_engine+0x318> @ imm = #0x11c
 800fc38: 4620         	mov	r0, r4
 800fc3a: 4629         	mov	r1, r5
 800fc3c: f7ff feea    	bl	0x800fa14 <div10>       @ imm = #-0x22c
 800fc40: 9a0e         	ldr	r2, [sp, #0x38]
 800fc42: fb0a f309    	mul	r3, r10, r9
 800fc46: 4293         	cmp	r3, r2
 800fc48: bf14         	ite	ne
 800fc4a: 2600         	movne	r6, #0x0
 800fc4c: f006 0601    	andeq	r6, r6, #0x1
 800fc50: 9b0c         	ldr	r3, [sp, #0x30]
 800fc52: 9310         	str	r3, [sp, #0x40]
 800fc54: 9b0d         	ldr	r3, [sp, #0x34]
 800fc56: e9cd 3911    	strd	r3, r9, [sp, #68]
 800fc5a: 9b0f         	ldr	r3, [sp, #0x3c]
 800fc5c: 9313         	str	r3, [sp, #0x4c]
 800fc5e: 9b07         	ldr	r3, [sp, #0x1c]
 800fc60: f1b8 0f00    	cmp.w	r8, #0x0
 800fc64: bf14         	ite	ne
 800fc66: 2700         	movne	r7, #0x0
 800fc68: f007 0701    	andeq	r7, r7, #0x1
 800fc6c: 3301         	adds	r3, #0x1
 800fc6e: fb0a 4810    	mls	r8, r10, r0, r4
 800fc72: fa5f f888    	uxtb.w	r8, r8
 800fc76: 9307         	str	r3, [sp, #0x1c]
 800fc78: 4604         	mov	r4, r0
 800fc7a: 460d         	mov	r5, r1
 800fc7c: e7c7         	b	0x800fc0e <__dtoa_engine+0x1d2> @ imm = #-0x72
 800fc7e: 1cb8         	adds	r0, r7, #0x2
 800fc80: f148 0100    	adc	r1, r8, #0x0
 800fc84: f000 f93c    	bl	0x800ff00 <__pow5Factor> @ imm = #0x278
 800fc88: 9b04         	ldr	r3, [sp, #0x10]
 800fc8a: 4283         	cmp	r3, r0
 800fc8c: bf8c         	ite	hi
 800fc8e: 2000         	movhi	r0, #0x0
 800fc90: 2001         	movls	r0, #0x1
 800fc92: ebb9 0000    	subs.w	r0, r9, r0
 800fc96: f16a 0200    	sbc	r2, r10, #0x0
 800fc9a: e9cd 0210    	strd	r0, r2, [sp, #64]
 800fc9e: 2700         	movs	r7, #0x0
 800fca0: 463e         	mov	r6, r7
 800fca2: e7a8         	b	0x800fbf6 <__dtoa_engine+0x1ba> @ imm = #-0xb0
 800fca4: 9b10         	ldr	r3, [sp, #0x40]
 800fca6: 9a11         	ldr	r2, [sp, #0x44]
 800fca8: 3b01         	subs	r3, #0x1
 800fcaa: f142 32ff    	adc	r2, r2, #0xffffffff
 800fcae: e9cd 3210    	strd	r3, r2, [sp, #64]
 800fcb2: 2701         	movs	r7, #0x1
 800fcb4: e78a         	b	0x800fbcc <__dtoa_engine+0x190> @ imm = #-0xec
 800fcb6: f1b9 0f3e    	cmp.w	r9, #0x3e
 800fcba: d8f0         	bhi	0x800fc9e <__dtoa_engine+0x262> @ imm = #-0x20
 800fcbc: f04f 33ff    	mov.w	r3, #0xffffffff
 800fcc0: f1a9 0020    	sub.w	r0, r9, #0x20
 800fcc4: fa03 f209    	lsl.w	r2, r3, r9
 800fcc8: fa03 f000    	lsl.w	r0, r3, r0
 800fccc: f1c9 0120    	rsb.w	r1, r9, #0x20
 800fcd0: fa23 f101    	lsr.w	r1, r3, r1
 800fcd4: 4302         	orrs	r2, r0
 800fcd6: 430a         	orrs	r2, r1
 800fcd8: fa03 f309    	lsl.w	r3, r3, r9
 800fcdc: ea27 0703    	bic.w	r7, r7, r3
 800fce0: ea28 0802    	bic.w	r8, r8, r2
 800fce4: ea57 0708    	orrs.w	r7, r7, r8
 800fce8: bf0c         	ite	eq
 800fcea: 2701         	moveq	r7, #0x1
 800fcec: 2700         	movne	r7, #0x0
 800fcee: e76d         	b	0x800fbcc <__dtoa_engine+0x190> @ imm = #-0x126
 800fcf0: fb00 fc02    	mul	r12, r0, r2
 800fcf4: fba1 1200    	umull	r1, r2, r1, r0
 800fcf8: 3301         	adds	r3, #0x1
 800fcfa: 4462         	add	r2, r12
 800fcfc: 428c         	cmp	r4, r1
 800fcfe: eb75 0c02    	sbcs.w	r12, r5, r2
 800fd02: d2f5         	bhs	0x800fcf0 <__dtoa_engine+0x2b4> @ imm = #-0x16
 800fd04: 9a04         	ldr	r2, [sp, #0x10]
 800fd06: f8dd b028    	ldr.w	r11, [sp, #0x28]
 800fd0a: 4413         	add	r3, r2
 800fd0c: 9a25         	ldr	r2, [sp, #0x94]
 800fd0e: 4413         	add	r3, r2
 800fd10: 0fd2         	lsrs	r2, r2, #0x1f
 800fd12: 4293         	cmp	r3, r2
 800fd14: bfb8         	it	lt
 800fd16: 4613         	movlt	r3, r2
 800fd18: 459b         	cmp	r11, r3
 800fd1a: bfa8         	it	ge
 800fd1c: 469b         	movge	r11, r3
 800fd1e: e770         	b	0x800fc02 <__dtoa_engine+0x1c6> @ imm = #-0x120
 800fd20: 210a         	movs	r1, #0xa
 800fd22: 2200         	movs	r2, #0x0
 800fd24: 2301         	movs	r3, #0x1
 800fd26: 4608         	mov	r0, r1
 800fd28: e7e8         	b	0x800fcfc <__dtoa_engine+0x2c0> @ imm = #-0x30
 800fd2a: fb0a f003    	mul	r0, r10, r3
 800fd2e: fba2 230a    	umull	r2, r3, r2, r10
 800fd32: 3101         	adds	r1, #0x1
 800fd34: 4403         	add	r3, r0
 800fd36: 4294         	cmp	r4, r2
 800fd38: eb75 0003    	sbcs.w	r0, r5, r3
 800fd3c: d2f5         	bhs	0x800fd2a <__dtoa_engine+0x2ee> @ imm = #-0x16
 800fd3e: 4559         	cmp	r1, r11
 800fd40: dd10         	ble	0x800fd64 <__dtoa_engine+0x328> @ imm = #0x20
 800fd42: f1bb 0f00    	cmp.w	r11, #0x0
 800fd46: d102         	bne	0x800fd4e <__dtoa_engine+0x312> @ imm = #0x4
 800fd48: ea54 0305    	orrs.w	r3, r4, r5
 800fd4c: d00a         	beq	0x800fd64 <__dtoa_engine+0x328> @ imm = #0x14
 800fd4e: 2301         	movs	r3, #0x1
 800fd50: 9306         	str	r3, [sp, #0x18]
 800fd52: e771         	b	0x800fc38 <__dtoa_engine+0x1fc> @ imm = #-0x11e
 800fd54: 220a         	movs	r2, #0xa
 800fd56: 2300         	movs	r3, #0x0
 800fd58: 2101         	movs	r1, #0x1
 800fd5a: e7ec         	b	0x800fd36 <__dtoa_engine+0x2fa> @ imm = #-0x28

0800fd5c <$d>:
 800fd5c: cc fb ff ff  	.word	0xfffffbcc
 800fd60: cd cc cc cc  	.word	0xcccccccd

0800fd64 <$t>:
 800fd64: 2e00         	cmp	r6, #0x0
 800fd66: d02f         	beq	0x800fdc8 <__dtoa_engine+0x38c> @ imm = #0x5e
 800fd68: f04f 0a0a    	mov.w	r10, #0xa
 800fd6c: 9b12         	ldr	r3, [sp, #0x48]
 800fd6e: 9913         	ldr	r1, [sp, #0x4c]
 800fd70: 930d         	str	r3, [sp, #0x34]
 800fd72: 4618         	mov	r0, r3
 800fd74: f7ff fe4e    	bl	0x800fa14 <div10>       @ imm = #-0x364
 800fd78: 9b0d         	ldr	r3, [sp, #0x34]
 800fd7a: 910c         	str	r1, [sp, #0x30]
 800fd7c: fb0a f200    	mul	r2, r10, r0
 800fd80: 429a         	cmp	r2, r3
 800fd82: 4681         	mov	r9, r0
 800fd84: d120         	bne	0x800fdc8 <__dtoa_engine+0x38c> @ imm = #0x40
 800fd86: e9dd 0110    	ldrd	r0, r1, [sp, #64]
 800fd8a: f7ff fe43    	bl	0x800fa14 <div10>       @ imm = #-0x37a
 800fd8e: 900e         	str	r0, [sp, #0x38]
 800fd90: 910d         	str	r1, [sp, #0x34]
 800fd92: 4620         	mov	r0, r4
 800fd94: 4629         	mov	r1, r5
 800fd96: f7ff fe3d    	bl	0x800fa14 <div10>       @ imm = #-0x386
 800fd9a: 9b0d         	ldr	r3, [sp, #0x34]
 800fd9c: 9a0e         	ldr	r2, [sp, #0x38]
 800fd9e: 9210         	str	r2, [sp, #0x40]
 800fda0: e9cd 3911    	strd	r3, r9, [sp, #68]
 800fda4: 9b0c         	ldr	r3, [sp, #0x30]
 800fda6: 9313         	str	r3, [sp, #0x4c]
 800fda8: 9b07         	ldr	r3, [sp, #0x1c]
 800fdaa: f1b8 0f00    	cmp.w	r8, #0x0
 800fdae: bf14         	ite	ne
 800fdb0: 2700         	movne	r7, #0x0
 800fdb2: f007 0701    	andeq	r7, r7, #0x1
 800fdb6: 3301         	adds	r3, #0x1
 800fdb8: fb0a 4810    	mls	r8, r10, r0, r4
 800fdbc: fa5f f888    	uxtb.w	r8, r8
 800fdc0: 9307         	str	r3, [sp, #0x1c]
 800fdc2: 4604         	mov	r4, r0
 800fdc4: 460d         	mov	r5, r1
 800fdc6: e7d1         	b	0x800fd6c <__dtoa_engine+0x330> @ imm = #-0x5e
 800fdc8: f8dd 9010    	ldr.w	r9, [sp, #0x10]
 800fdcc: 9b07         	ldr	r3, [sp, #0x1c]
 800fdce: 4499         	add	r9, r3
 800fdd0: 2f00         	cmp	r7, #0x0
 800fdd2: d05a         	beq	0x800fe8a <__dtoa_engine+0x44e> @ imm = #0xb4
 800fdd4: f1b8 0f05    	cmp.w	r8, #0x5
 800fdd8: d157         	bne	0x800fe8a <__dtoa_engine+0x44e> @ imm = #0xae
 800fdda: f014 0301    	ands	r3, r4, #0x1
 800fdde: d14a         	bne	0x800fe76 <__dtoa_engine+0x43a> @ imm = #0x94
 800fde0: 9a06         	ldr	r2, [sp, #0x18]
 800fde2: b932         	cbnz	r2, 0x800fdf2 <__dtoa_engine+0x3b6> @ imm = #0xc
 800fde4: e9dd 2312    	ldrd	r2, r3, [sp, #72]
 800fde8: 429d         	cmp	r5, r3
 800fdea: bf08         	it	eq
 800fdec: 4294         	cmpeq	r4, r2
 800fdee: d05f         	beq	0x800feb0 <__dtoa_engine+0x474> @ imm = #0xbe
 800fdf0: 9b06         	ldr	r3, [sp, #0x18]
 800fdf2: 1918         	adds	r0, r3, r4
 800fdf4: f04f 040a    	mov.w	r4, #0xa
 800fdf8: f145 0100    	adc	r1, r5, #0x0
 800fdfc: 2200         	movs	r2, #0x0
 800fdfe: 2601         	movs	r6, #0x1
 800fe00: 4625         	mov	r5, r4
 800fe02: 42a0         	cmp	r0, r4
 800fe04: eb71 0702    	sbcs.w	r7, r1, r2
 800fe08: d255         	bhs	0x800feb6 <__dtoa_engine+0x47a> @ imm = #0xaa
 800fe0a: b1eb         	cbz	r3, 0x800fe48 <__dtoa_engine+0x40c> @ imm = #0x3a
 800fe0c: 45b3         	cmp	r11, r6
 800fe0e: da1b         	bge	0x800fe48 <__dtoa_engine+0x40c> @ imm = #0x36
 800fe10: 9b0b         	ldr	r3, [sp, #0x2c]
 800fe12: b16b         	cbz	r3, 0x800fe30 <__dtoa_engine+0x3f4> @ imm = #0x1a
 800fe14: 9a25         	ldr	r2, [sp, #0x94]
 800fe16: f8dd b028    	ldr.w	r11, [sp, #0x28]
 800fe1a: eb06 0309    	add.w	r3, r6, r9
 800fe1e: 4413         	add	r3, r2
 800fe20: 2b01         	cmp	r3, #0x1
 800fe22: bfb8         	it	lt
 800fe24: 2301         	movlt	r3, #0x1
 800fe26: 459b         	cmp	r11, r3
 800fe28: bfa8         	it	ge
 800fe2a: 469b         	movge	r11, r3
 800fe2c: 455e         	cmp	r6, r11
 800fe2e: dd0b         	ble	0x800fe48 <__dtoa_engine+0x40c> @ imm = #0x16
 800fe30: 3005         	adds	r0, #0x5
 800fe32: f04f 020a    	mov.w	r2, #0xa
 800fe36: f04f 0300    	mov.w	r3, #0x0
 800fe3a: f141 0100    	adc	r1, r1, #0x0
 800fe3e: f7f0 fe59    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0xf34e
 800fe42: f109 0901    	add.w	r9, r9, #0x1
 800fe46: 3e01         	subs	r6, #0x1
 800fe48: 455e         	cmp	r6, r11
 800fe4a: bfa8         	it	ge
 800fe4c: 465e         	movge	r6, r11
 800fe4e: b237         	sxth	r7, r6
 800fe50: fa0f f989    	sxth.w	r9, r9
 800fe54: 9b05         	ldr	r3, [sp, #0x14]
 800fe56: fa09 f686    	sxtah	r6, r9, r6
 800fe5a: f107 0805    	add.w	r8, r7, #0x5
 800fe5e: 3e01         	subs	r6, #0x1
 800fe60: 4498         	add	r8, r3
 800fe62: f04f 0900    	mov.w	r9, #0x0
 800fe66: 45b9         	cmp	r9, r7
 800fe68: db2c         	blt	0x800fec4 <__dtoa_engine+0x488> @ imm = #0x58
 800fe6a: 9b05         	ldr	r3, [sp, #0x14]
 800fe6c: 461a         	mov	r2, r3
 800fe6e: 601e         	str	r6, [r3]
 800fe70: 9b09         	ldr	r3, [sp, #0x24]
 800fe72: 7113         	strb	r3, [r2, #0x4]
 800fe74: e600         	b	0x800fa78 <__dtoa_engine+0x3c> @ imm = #-0x400
 800fe76: 9b06         	ldr	r3, [sp, #0x18]
 800fe78: b92b         	cbnz	r3, 0x800fe86 <__dtoa_engine+0x44a> @ imm = #0xa
 800fe7a: e9dd 2312    	ldrd	r2, r3, [sp, #72]
 800fe7e: 429d         	cmp	r5, r3
 800fe80: bf08         	it	eq
 800fe82: 4294         	cmpeq	r4, r2
 800fe84: d009         	beq	0x800fe9a <__dtoa_engine+0x45e> @ imm = #0x12
 800fe86: 2301         	movs	r3, #0x1
 800fe88: e7b3         	b	0x800fdf2 <__dtoa_engine+0x3b6> @ imm = #-0x9a
 800fe8a: 9b06         	ldr	r3, [sp, #0x18]
 800fe8c: b953         	cbnz	r3, 0x800fea4 <__dtoa_engine+0x468> @ imm = #0x14
 800fe8e: e9dd 2312    	ldrd	r2, r3, [sp, #72]
 800fe92: 429d         	cmp	r5, r3
 800fe94: bf08         	it	eq
 800fe96: 4294         	cmpeq	r4, r2
 800fe98: d104         	bne	0x800fea4 <__dtoa_engine+0x468> @ imm = #0x8
 800fe9a: 9b08         	ldr	r3, [sp, #0x20]
 800fe9c: 2b00         	cmp	r3, #0x0
 800fe9e: d1f2         	bne	0x800fe86 <__dtoa_engine+0x44a> @ imm = #-0x1c
 800fea0: 2e00         	cmp	r6, #0x0
 800fea2: d0f0         	beq	0x800fe86 <__dtoa_engine+0x44a> @ imm = #-0x20
 800fea4: f1b8 0f04    	cmp.w	r8, #0x4
 800fea8: bf94         	ite	ls
 800feaa: 2300         	movls	r3, #0x0
 800feac: 2301         	movhi	r3, #0x1
 800feae: e7a0         	b	0x800fdf2 <__dtoa_engine+0x3b6> @ imm = #-0xc0
 800feb0: f04f 0804    	mov.w	r8, #0x4
 800feb4: e7f1         	b	0x800fe9a <__dtoa_engine+0x45e> @ imm = #-0x1e
 800feb6: fb05 f702    	mul	r7, r5, r2
 800feba: fba4 4205    	umull	r4, r2, r4, r5
 800febe: 3601         	adds	r6, #0x1
 800fec0: 443a         	add	r2, r7
 800fec2: e79e         	b	0x800fe02 <__dtoa_engine+0x3c6> @ imm = #-0xc4
 800fec4: 220a         	movs	r2, #0xa
 800fec6: 2300         	movs	r3, #0x0
 800fec8: f7f0 fe14    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0xf3d8
 800fecc: 3230         	adds	r2, #0x30
 800fece: f808 2d01    	strb	r2, [r8, #-1]!
 800fed2: f109 0901    	add.w	r9, r9, #0x1
 800fed6: e7c6         	b	0x800fe66 <__dtoa_engine+0x42a> @ imm = #-0x74

0800fed8 <__log10Pow2>:
 800fed8: 4b01         	ldr	r3, [pc, #0x4]          @ 0x800fee0 <__log10Pow2+0x8>
 800feda: 4358         	muls	r0, r3, r0
 800fedc: 0c80         	lsrs	r0, r0, #0x12
 800fede: 4770         	bx	lr

0800fee0 <$d>:
 800fee0: 41 34 01 00  	.word	0x00013441

0800fee4 <__log10Pow5>:
 800fee4: 4b01         	ldr	r3, [pc, #0x4]          @ 0x800feec <__log10Pow5+0x8>
 800fee6: 4358         	muls	r0, r3, r0
 800fee8: 0d00         	lsrs	r0, r0, #0x14
 800feea: 4770         	bx	lr

0800feec <$d>:
 800feec: fb 2e 0b 00  	.word	0x000b2efb

0800fef0 <__pow5bits>:
 800fef0: 4b02         	ldr	r3, [pc, #0x8]          @ 0x800fefc <__pow5bits+0xc>
 800fef2: 4358         	muls	r0, r3, r0
 800fef4: 0cc0         	lsrs	r0, r0, #0x13
 800fef6: 3001         	adds	r0, #0x1
 800fef8: 4770         	bx	lr
 800fefa: bf00         	nop

0800fefc <$d>:
 800fefc: 4f 93 12 00  	.word	0x0012934f

0800ff00 <__pow5Factor>:
 800ff00: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800ff2c <__pow5Factor+0x2c>
 800ff02: b570         	push	{r4, r5, r6, lr}
 800ff04: 4603         	mov	r3, r0
 800ff06: f04f 36cc    	mov.w	r6, #0xcccccccc
 800ff0a: 2000         	movs	r0, #0x0
 800ff0c: f04f 3533    	mov.w	r5, #0x33333333
 800ff10: fb06 f403    	mul	r4, r6, r3
 800ff14: fb02 4401    	mla	r4, r2, r1, r4
 800ff18: fba3 3102    	umull	r3, r1, r3, r2
 800ff1c: 4421         	add	r1, r4
 800ff1e: 429d         	cmp	r5, r3
 800ff20: eb75 0401    	sbcs.w	r4, r5, r1
 800ff24: d301         	blo	0x800ff2a <__pow5Factor+0x2a> @ imm = #0x2
 800ff26: 3001         	adds	r0, #0x1
 800ff28: e7f2         	b	0x800ff10 <__pow5Factor+0x10> @ imm = #-0x1c
 800ff2a: bd70         	pop	{r4, r5, r6, pc}

0800ff2c <$d>:
 800ff2c: cd cc cc cc  	.word	0xcccccccd

0800ff30 <__double_computePow5>:
 800ff30: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800ff34: 231a         	movs	r3, #0x1a
 800ff36: 4e35         	ldr	r6, [pc, #0xd4]         @ 0x801000c <__double_computePow5+0xdc>
 800ff38: fbb0 faf3    	udiv	r10, r0, r3
 800ff3c: fb03 031a    	mls	r3, r3, r10, r0
 800ff40: b089         	sub	sp, #0x24
 800ff42: 4604         	mov	r4, r0
 800ff44: 460d         	mov	r5, r1
 800ff46: eb06 160a    	add.w	r6, r6, r10, lsl #4
 800ff4a: b953         	cbnz	r3, 0x800ff62 <__double_computePow5+0x32> @ imm = #0x14
 800ff4c: e9d6 2300    	ldrd	r2, r3, [r6]
 800ff50: e9c1 2300    	strd	r2, r3, [r1]
 800ff54: e9d6 0102    	ldrd	r0, r1, [r6, #8]
 800ff58: e9c5 0102    	strd	r0, r1, [r5, #8]
 800ff5c: b009         	add	sp, #0x24
 800ff5e: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800ff62: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x8010010 <__double_computePow5+0xe0>
 800ff64: eb02 03c3    	add.w	r3, r2, r3, lsl #3
 800ff68: e9d3 8900    	ldrd	r8, r9, [r3]
 800ff6c: ab04         	add	r3, sp, #0x10
 800ff6e: 9300         	str	r3, [sp]
 800ff70: e9d6 2302    	ldrd	r2, r3, [r6, #8]
 800ff74: 4640         	mov	r0, r8
 800ff76: 4649         	mov	r1, r9
 800ff78: f008 ffec    	bl	0x8018f54 <__umul128>   @ imm = #0x8fd8
 800ff7c: ab06         	add	r3, sp, #0x18
 800ff7e: 9300         	str	r3, [sp]
 800ff80: e9d6 2300    	ldrd	r2, r3, [r6]
 800ff84: 4683         	mov	r11, r0
 800ff86: 460f         	mov	r7, r1
 800ff88: 4640         	mov	r0, r8
 800ff8a: 4649         	mov	r1, r9
 800ff8c: f008 ffe2    	bl	0x8018f54 <__umul128>   @ imm = #0x8fc4
 800ff90: e9dd 6206    	ldrd	r6, r2, [sp, #24]
 800ff94: eb16 060b    	adds.w	r6, r6, r11
 800ff98: eb52 0807    	adcs.w	r8, r2, r7
 800ff9c: f04f 0300    	mov.w	r3, #0x0
 800ffa0: bf28         	it	hs
 800ffa2: 2301         	movhs	r3, #0x1
 800ffa4: 4681         	mov	r9, r0
 800ffa6: b133         	cbz	r3, 0x800ffb6 <__double_computePow5+0x86> @ imm = #0xc
 800ffa8: 9b04         	ldr	r3, [sp, #0x10]
 800ffaa: 9a05         	ldr	r2, [sp, #0x14]
 800ffac: 3301         	adds	r3, #0x1
 800ffae: f142 0200    	adc	r2, r2, #0x0
 800ffb2: e9cd 3204    	strd	r3, r2, [sp, #16]
 800ffb6: 4620         	mov	r0, r4
 800ffb8: 9103         	str	r1, [sp, #0xc]
 800ffba: f7ff ff99    	bl	0x800fef0 <__pow5bits>  @ imm = #-0xce
 800ffbe: 4607         	mov	r7, r0
 800ffc0: 201a         	movs	r0, #0x1a
 800ffc2: fb00 f00a    	mul	r0, r0, r10
 800ffc6: f7ff ff93    	bl	0x800fef0 <__pow5bits>  @ imm = #-0xda
 800ffca: 1a3f         	subs	r7, r7, r0
 800ffcc: 4632         	mov	r2, r6
 800ffce: 4643         	mov	r3, r8
 800ffd0: 9903         	ldr	r1, [sp, #0xc]
 800ffd2: 9700         	str	r7, [sp]
 800ffd4: 4648         	mov	r0, r9
 800ffd6: f008 ffd8    	bl	0x8018f8a <__shiftright128> @ imm = #0x8fb0
 800ffda: ea4f 1c14    	lsr.w	r12, r4, #0x4
 800ffde: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8010014 <__double_computePow5+0xe4>
 800ffe0: 0064         	lsls	r4, r4, #0x1
 800ffe2: f004 031e    	and	r3, r4, #0x1e
 800ffe6: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 800ffea: 40dc         	lsrs	r4, r3
 800ffec: f004 0403    	and	r4, r4, #0x3
 800fff0: 1824         	adds	r4, r4, r0
 800fff2: f141 0100    	adc	r1, r1, #0x0
 800fff6: e9c5 4100    	strd	r4, r1, [r5]
 800fffa: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 800fffe: 9700         	str	r7, [sp]
 8010000: 4630         	mov	r0, r6
 8010002: 4641         	mov	r1, r8
 8010004: f008 ffc1    	bl	0x8018f8a <__shiftright128> @ imm = #0x8f82
 8010008: e7a6         	b	0x800ff58 <__double_computePow5+0x28> @ imm = #-0xb4
 801000a: bf00         	nop

0801000c <$d>:
 801000c: 48 b2 01 08  	.word	0x0801b248
 8010010: 78 b1 01 08  	.word	0x0801b178
 8010014: d8 bd 01 08  	.word	0x0801bdd8

08010018 <__double_computeInvPow5>:
 8010018: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 801001c: 271a         	movs	r7, #0x1a
 801001e: f8df a0e4    	ldr.w	r10, [pc, #0xe4]        @ 0x8010104 <__double_computeInvPow5+0xec>
 8010022: f100 0519    	add.w	r5, r0, #0x19
 8010026: fbb5 f5f7    	udiv	r5, r5, r7
 801002a: 436f         	muls	r7, r5, r7
 801002c: 1a3a         	subs	r2, r7, r0
 801002e: ea4f 1b05    	lsl.w	r11, r5, #0x4
 8010032: b089         	sub	sp, #0x24
 8010034: 4604         	mov	r4, r0
 8010036: 460e         	mov	r6, r1
 8010038: eb0a 1505    	add.w	r5, r10, r5, lsl #4
 801003c: d10a         	bne	0x8010054 <__double_computeInvPow5+0x3c> @ imm = #0x14
 801003e: e9d5 2300    	ldrd	r2, r3, [r5]
 8010042: e9c1 2300    	strd	r2, r3, [r1]
 8010046: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 801004a: e9c6 0102    	strd	r0, r1, [r6, #8]
 801004e: b009         	add	sp, #0x24
 8010050: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8010054: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8010108 <__double_computeInvPow5+0xf0>
 8010056: eb03 03c2    	add.w	r3, r3, r2, lsl #3
 801005a: e9d3 8900    	ldrd	r8, r9, [r3]
 801005e: ab04         	add	r3, sp, #0x10
 8010060: 9300         	str	r3, [sp]
 8010062: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 8010066: 4640         	mov	r0, r8
 8010068: 4649         	mov	r1, r9
 801006a: f008 ff73    	bl	0x8018f54 <__umul128>   @ imm = #0x8ee6
 801006e: f85a 200b    	ldr.w	r2, [r10, r11]
 8010072: 686b         	ldr	r3, [r5, #0x4]
 8010074: 3a01         	subs	r2, #0x1
 8010076: e9cd 0102    	strd	r0, r1, [sp, #8]
 801007a: a906         	add	r1, sp, #0x18
 801007c: f163 0300    	sbc	r3, r3, #0x0
 8010080: 9100         	str	r1, [sp]
 8010082: 4640         	mov	r0, r8
 8010084: 4649         	mov	r1, r9
 8010086: f008 ff65    	bl	0x8018f54 <__umul128>   @ imm = #0x8eca
 801008a: e9dd 5206    	ldrd	r5, r2, [sp, #24]
 801008e: 468a         	mov	r10, r1
 8010090: 9902         	ldr	r1, [sp, #0x8]
 8010092: 186d         	adds	r5, r5, r1
 8010094: 9903         	ldr	r1, [sp, #0xc]
 8010096: eb52 0801    	adcs.w	r8, r2, r1
 801009a: f04f 0300    	mov.w	r3, #0x0
 801009e: bf28         	it	hs
 80100a0: 2301         	movhs	r3, #0x1
 80100a2: 4681         	mov	r9, r0
 80100a4: b133         	cbz	r3, 0x80100b4 <__double_computeInvPow5+0x9c> @ imm = #0xc
 80100a6: 9b04         	ldr	r3, [sp, #0x10]
 80100a8: 9a05         	ldr	r2, [sp, #0x14]
 80100aa: 3301         	adds	r3, #0x1
 80100ac: f142 0200    	adc	r2, r2, #0x0
 80100b0: e9cd 3204    	strd	r3, r2, [sp, #16]
 80100b4: 4638         	mov	r0, r7
 80100b6: f7ff ff1b    	bl	0x800fef0 <__pow5bits>  @ imm = #-0x1ca
 80100ba: 4607         	mov	r7, r0
 80100bc: 4620         	mov	r0, r4
 80100be: f7ff ff17    	bl	0x800fef0 <__pow5bits>  @ imm = #-0x1d2
 80100c2: 1a3f         	subs	r7, r7, r0
 80100c4: 462a         	mov	r2, r5
 80100c6: 4643         	mov	r3, r8
 80100c8: 9700         	str	r7, [sp]
 80100ca: 4648         	mov	r0, r9
 80100cc: 4651         	mov	r1, r10
 80100ce: f008 ff5c    	bl	0x8018f8a <__shiftright128> @ imm = #0x8eb8
 80100d2: ea4f 1c14    	lsr.w	r12, r4, #0x4
 80100d6: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x801010c <__double_computeInvPow5+0xf4>
 80100d8: 0064         	lsls	r4, r4, #0x1
 80100da: f004 031e    	and	r3, r4, #0x1e
 80100de: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 80100e2: 40dc         	lsrs	r4, r3
 80100e4: f004 0403    	and	r4, r4, #0x3
 80100e8: 3401         	adds	r4, #0x1
 80100ea: 1824         	adds	r4, r4, r0
 80100ec: f141 0100    	adc	r1, r1, #0x0
 80100f0: e9c6 4100    	strd	r4, r1, [r6]
 80100f4: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 80100f8: 9700         	str	r7, [sp]
 80100fa: 4628         	mov	r0, r5
 80100fc: 4641         	mov	r1, r8
 80100fe: f008 ff44    	bl	0x8018f8a <__shiftright128> @ imm = #0x8e88
 8010102: e7a2         	b	0x801004a <__double_computeInvPow5+0x32> @ imm = #-0xbc

08010104 <$d>:
 8010104: 18 b3 01 08  	.word	0x0801b318
 8010108: 78 b1 01 08  	.word	0x0801b178
 801010c: 2c be 01 08  	.word	0x0801be2c

08010110 <fmodf>:
 8010110: b5f8         	push	{r3, r4, r5, r6, r7, lr}
 8010112: 4604         	mov	r4, r0
 8010114: 460f         	mov	r7, r1
 8010116: f000 f88f    	bl	0x8010238 <__fpclassifyf> @ imm = #0x11e
 801011a: b928         	cbnz	r0, 0x8010128 <fmodf+0x18> @ imm = #0xa
 801011c: 4639         	mov	r1, r7
 801011e: 4620         	mov	r0, r4
 8010120: f7f0 f9f4    	bl	0x800050c <__aeabi_fadd> @ imm = #-0xfc18
 8010124: 4604         	mov	r4, r0
 8010126: e020         	b	0x801016a <fmodf+0x5a>  @ imm = #0x40
 8010128: 4638         	mov	r0, r7
 801012a: f000 f885    	bl	0x8010238 <__fpclassifyf> @ imm = #0x10a
 801012e: 2800         	cmp	r0, #0x0
 8010130: d0f4         	beq	0x801011c <fmodf+0xc>   @ imm = #-0x18
 8010132: 4620         	mov	r0, r4
 8010134: f000 f880    	bl	0x8010238 <__fpclassifyf> @ imm = #0x100
 8010138: 2801         	cmp	r0, #0x1
 801013a: d104         	bne	0x8010146 <fmodf+0x36>  @ imm = #0x8
 801013c: 4620         	mov	r0, r4
 801013e: e8bd 40f8    	pop.w	{r3, r4, r5, r6, r7, lr}
 8010142: f000 b893    	b.w	0x801026c <__math_invalidf> @ imm = #0x126
 8010146: f037 4500    	bics	r5, r7, #0x80000000
 801014a: 463e         	mov	r6, r7
 801014c: d101         	bne	0x8010152 <fmodf+0x42>  @ imm = #0x2
 801014e: 4638         	mov	r0, r7
 8010150: e7f5         	b	0x801013e <fmodf+0x2e>  @ imm = #-0x16
 8010152: f024 4700    	bic	r7, r4, #0x80000000
 8010156: 42af         	cmp	r7, r5
 8010158: 4623         	mov	r3, r4
 801015a: db06         	blt	0x801016a <fmodf+0x5a>  @ imm = #0xc
 801015c: f004 4000    	and	r0, r4, #0x80000000
 8010160: d105         	bne	0x801016e <fmodf+0x5e>  @ imm = #0xa
 8010162: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8010234 <fmodf+0x124>
 8010164: 0fc0         	lsrs	r0, r0, #0x1f
 8010166: f853 4020    	ldr.w	r4, [r3, r0, lsl #2]
 801016a: 4620         	mov	r0, r4
 801016c: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
 801016e: f014 4fff    	tst.w	r4, #0x7f800000
 8010172: d13e         	bne	0x80101f2 <fmodf+0xe2>  @ imm = #0x7c
 8010174: 023a         	lsls	r2, r7, #0x8
 8010176: f06f 017d    	mvn	r1, #0x7d
 801017a: 2a00         	cmp	r2, #0x0
 801017c: dc36         	bgt	0x80101ec <fmodf+0xdc>  @ imm = #0x6c
 801017e: f016 4fff    	tst.w	r6, #0x7f800000
 8010182: d13c         	bne	0x80101fe <fmodf+0xee>  @ imm = #0x78
 8010184: 022c         	lsls	r4, r5, #0x8
 8010186: f06f 027d    	mvn	r2, #0x7d
 801018a: 2c00         	cmp	r4, #0x0
 801018c: da34         	bge	0x80101f8 <fmodf+0xe8>  @ imm = #0x68
 801018e: f111 0f7e    	cmn.w	r1, #0x7e
 8010192: bfb9         	ittee	lt
 8010194: f06f 037d    	mvnlt	r3, #0x7d
 8010198: 1a5b         	sublt	r3, r3, r1
 801019a: f3c3 0316    	ubfxge	r3, r3, #0x0, #0x17
 801019e: f443 0300    	orrge	r3, r3, #0x800000
 80101a2: bfb8         	it	lt
 80101a4: fa07 f303    	lsllt.w	r3, r7, r3
 80101a8: f112 0f7e    	cmn.w	r2, #0x7e
 80101ac: bfb5         	itete	lt
 80101ae: f06f 047d    	mvnlt	r4, #0x7d
 80101b2: f3c6 0616    	ubfxge	r6, r6, #0x0, #0x17
 80101b6: 1aa4         	sublt	r4, r4, r2
 80101b8: f446 0500    	orrge	r5, r6, #0x800000
 80101bc: bfb8         	it	lt
 80101be: 40a5         	lsllt	r5, r4
 80101c0: 1a89         	subs	r1, r1, r2
 80101c2: 1b5c         	subs	r4, r3, r5
 80101c4: b9f1         	cbnz	r1, 0x8010204 <fmodf+0xf4> @ imm = #0x3c
 80101c6: ea13 0324    	ands.w	r3, r3, r4, asr #32
 80101ca: bf38         	it	lo
 80101cc: 4623         	movlo	r3, r4
 80101ce: 2b00         	cmp	r3, #0x0
 80101d0: d0c7         	beq	0x8010162 <fmodf+0x52>  @ imm = #-0x72
 80101d2: f5b3 0f00    	cmp.w	r3, #0x800000
 80101d6: db1d         	blt	0x8010214 <fmodf+0x104> @ imm = #0x3a
 80101d8: f112 0f7e    	cmn.w	r2, #0x7e
 80101dc: db1d         	blt	0x801021a <fmodf+0x10a> @ imm = #0x3a
 80101de: f5a3 0300    	sub.w	r3, r3, #0x800000
 80101e2: 4303         	orrs	r3, r0
 80101e4: 327f         	adds	r2, #0x7f
 80101e6: ea43 54c2    	orr.w	r4, r3, r2, lsl #23
 80101ea: e7be         	b	0x801016a <fmodf+0x5a>  @ imm = #-0x84
 80101ec: 3901         	subs	r1, #0x1
 80101ee: 0052         	lsls	r2, r2, #0x1
 80101f0: e7c3         	b	0x801017a <fmodf+0x6a>  @ imm = #-0x7a
 80101f2: 15f9         	asrs	r1, r7, #0x17
 80101f4: 397f         	subs	r1, #0x7f
 80101f6: e7c2         	b	0x801017e <fmodf+0x6e>  @ imm = #-0x7c
 80101f8: 3a01         	subs	r2, #0x1
 80101fa: 0064         	lsls	r4, r4, #0x1
 80101fc: e7c5         	b	0x801018a <fmodf+0x7a>  @ imm = #-0x76
 80101fe: 15ea         	asrs	r2, r5, #0x17
 8010200: 3a7f         	subs	r2, #0x7f
 8010202: e7c4         	b	0x801018e <fmodf+0x7e>  @ imm = #-0x78
 8010204: 2c00         	cmp	r4, #0x0
 8010206: da02         	bge	0x801020e <fmodf+0xfe>  @ imm = #0x4
 8010208: 005b         	lsls	r3, r3, #0x1
 801020a: 3901         	subs	r1, #0x1
 801020c: e7d9         	b	0x80101c2 <fmodf+0xb2>  @ imm = #-0x4e
 801020e: d0a8         	beq	0x8010162 <fmodf+0x52>  @ imm = #-0xb0
 8010210: 0063         	lsls	r3, r4, #0x1
 8010212: e7fa         	b	0x801020a <fmodf+0xfa>  @ imm = #-0xc
 8010214: 005b         	lsls	r3, r3, #0x1
 8010216: 3a01         	subs	r2, #0x1
 8010218: e7db         	b	0x80101d2 <fmodf+0xc2>  @ imm = #-0x4a
 801021a: f1c2 22ff    	rsb.w	r2, r2, #0xff00ff00
 801021e: f502 027f    	add.w	r2, r2, #0xff0000
 8010222: 3282         	adds	r2, #0x82
 8010224: 4113         	asrs	r3, r2
 8010226: f04f 517e    	mov.w	r1, #0x3f800000
 801022a: 4318         	orrs	r0, r3
 801022c: f7f0 fa76    	bl	0x800071c <__mulsf3>    @ imm = #-0xfb14
 8010230: e778         	b	0x8010124 <fmodf+0x14>  @ imm = #-0x110
 8010232: bf00         	nop

08010234 <$d>:
 8010234: 80 be 01 08  	.word	0x0801be80

08010238 <__fpclassifyf>:
 8010238: f030 4000    	bics	r0, r0, #0x80000000
 801023c: d00d         	beq	0x801025a <__fpclassifyf+0x22> @ imm = #0x1a
 801023e: f5a0 0300    	sub.w	r3, r0, #0x800000
 8010242: f1b3 4ffe    	cmp.w	r3, #0x7f000000
 8010246: d30a         	blo	0x801025e <__fpclassifyf+0x26> @ imm = #0x14
 8010248: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8010268 <__fpclassifyf+0x30>
 801024a: 1e42         	subs	r2, r0, #0x1
 801024c: 429a         	cmp	r2, r3
 801024e: d908         	bls	0x8010262 <__fpclassifyf+0x2a> @ imm = #0x10
 8010250: f1a0 43ff    	sub.w	r3, r0, #0x7f800000
 8010254: 4258         	rsbs	r0, r3, #0
 8010256: 4158         	adcs	r0, r3
 8010258: 4770         	bx	lr
 801025a: 2002         	movs	r0, #0x2
 801025c: 4770         	bx	lr
 801025e: 2004         	movs	r0, #0x4
 8010260: 4770         	bx	lr
 8010262: 2003         	movs	r0, #0x3
 8010264: 4770         	bx	lr
 8010266: bf00         	nop

08010268 <$d>:
 8010268: fe ff 7f 00  	.word	0x007ffffe

0801026c <__math_invalidf>:
 801026c: b508         	push	{r3, lr}
 801026e: f7ff ffe3    	bl	0x8010238 <__fpclassifyf> @ imm = #-0x3a
 8010272: 4801         	ldr	r0, [pc, #0x4]          @ 0x8010278 <__math_invalidf+0xc>
 8010274: bd08         	pop	{r3, pc}
 8010276: bf00         	nop

08010278 <$d>:
 8010278: 00 00 c0 7f  	.word	0x7fc00000

0801027c <_OffsetAbsSyms>:
; GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
 801027c: b480         	push	{r7}
 801027e: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 8010280: bf00         	nop
 8010282: 46bd         	mov	sp, r7
 8010284: bc80         	pop	{r7}
 8010286: 4770         	bx	lr

08010288 <z_log_msg_runtime_create>:
; {
 8010288: b580         	push	{r7, lr}
 801028a: b08a         	sub	sp, #0x28
 801028c: af04         	add	r7, sp, #0x10
 801028e: 60b9         	str	r1, [r7, #0x8]
 8010290: 607b         	str	r3, [r7, #0x4]
 8010292: 4603         	mov	r3, r0
 8010294: 73fb         	strb	r3, [r7, #0xf]
 8010296: 4613         	mov	r3, r2
 8010298: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801029a: f107 032c    	add.w	r3, r7, #0x2c
 801029e: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80102a0: 7bba         	ldrb	r2, [r7, #0xe]
 80102a2: 7bf8         	ldrb	r0, [r7, #0xf]
 80102a4: 697b         	ldr	r3, [r7, #0x14]
 80102a6: 9303         	str	r3, [sp, #0xc]
 80102a8: 6abb         	ldr	r3, [r7, #0x28]
 80102aa: 9302         	str	r3, [sp, #0x8]
 80102ac: 6a7b         	ldr	r3, [r7, #0x24]
 80102ae: 9301         	str	r3, [sp, #0x4]
 80102b0: 6a3b         	ldr	r3, [r7, #0x20]
 80102b2: 9300         	str	r3, [sp]
 80102b4: 687b         	ldr	r3, [r7, #0x4]
 80102b6: 68b9         	ldr	r1, [r7, #0x8]
 80102b8: f7f1 ff48    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0xe170
; }
 80102bc: bf00         	nop
 80102be: 3718         	adds	r7, #0x18
 80102c0: 46bd         	mov	sp, r7
 80102c2: bd80         	pop	{r7, pc}

080102c4 <k_msleep>:
; {
 80102c4: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 80102c8: b082         	sub	sp, #0x8
 80102ca: af00         	add	r7, sp, #0x0
 80102cc: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 80102ce: 6879         	ldr	r1, [r7, #0x4]
 80102d0: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 80102d4: 17c8         	asrs	r0, r1, #0x1f
 80102d6: 4688         	mov	r8, r1
 80102d8: 4681         	mov	r9, r0
 80102da: 4640         	mov	r0, r8
 80102dc: 4649         	mov	r1, r9
 80102de: f04f 0400    	mov.w	r4, #0x0
 80102e2: f04f 0500    	mov.w	r5, #0x0
 80102e6: 008d         	lsls	r5, r1, #0x2
 80102e8: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 80102ec: 0084         	lsls	r4, r0, #0x2
 80102ee: 4620         	mov	r0, r4
 80102f0: 4629         	mov	r1, r5
 80102f2: eb10 0208    	adds.w	r2, r0, r8
 80102f6: eb41 0309    	adc.w	r3, r1, r9
 80102fa: eb12 0a02    	adds.w	r10, r2, r2
 80102fe: eb43 0b03    	adc.w	r11, r3, r3
 8010302: 4652         	mov	r2, r10
 8010304: 465b         	mov	r3, r11
 8010306: 4610         	mov	r0, r2
 8010308: 4619         	mov	r1, r3
 801030a: f000 f827    	bl	0x801035c <k_sleep>     @ imm = #0x4e
 801030e: 4601         	mov	r1, r0
 8010310: 460b         	mov	r3, r1
; }
 8010312: 4618         	mov	r0, r3
 8010314: 3708         	adds	r7, #0x8
 8010316: 46bd         	mov	sp, r7
 8010318: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0801031c <k_thread_create>:
; {
 801031c: b580         	push	{r7, lr}
 801031e: b08c         	sub	sp, #0x30
 8010320: af08         	add	r7, sp, #0x20
 8010322: 60f8         	str	r0, [r7, #0xc]
 8010324: 60b9         	str	r1, [r7, #0x8]
 8010326: 607a         	str	r2, [r7, #0x4]
 8010328: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 801032a: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 801032e: e9cd 2306    	strd	r2, r3, [sp, #24]
 8010332: 6abb         	ldr	r3, [r7, #0x28]
 8010334: 9304         	str	r3, [sp, #0x10]
 8010336: 6a7b         	ldr	r3, [r7, #0x24]
 8010338: 9303         	str	r3, [sp, #0xc]
 801033a: 6a3b         	ldr	r3, [r7, #0x20]
 801033c: 9302         	str	r3, [sp, #0x8]
 801033e: 69fb         	ldr	r3, [r7, #0x1c]
 8010340: 9301         	str	r3, [sp, #0x4]
 8010342: 69bb         	ldr	r3, [r7, #0x18]
 8010344: 9300         	str	r3, [sp]
 8010346: 683b         	ldr	r3, [r7]
 8010348: 687a         	ldr	r2, [r7, #0x4]
 801034a: 68b9         	ldr	r1, [r7, #0x8]
 801034c: 68f8         	ldr	r0, [r7, #0xc]
 801034e: f007 fe93    	bl	0x8018078 <z_impl_k_thread_create> @ imm = #0x7d26
 8010352: 4603         	mov	r3, r0
; }
 8010354: 4618         	mov	r0, r3
 8010356: 3710         	adds	r7, #0x10
 8010358: 46bd         	mov	sp, r7
 801035a: bd80         	pop	{r7, pc}

0801035c <k_sleep>:
; {
 801035c: b580         	push	{r7, lr}
 801035e: b082         	sub	sp, #0x8
 8010360: af00         	add	r7, sp, #0x0
 8010362: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8010366: e9d7 0100    	ldrd	r0, r1, [r7]
 801036a: f7fd fe87    	bl	0x800e07c <z_impl_k_sleep> @ imm = #-0x22f2
 801036e: 4603         	mov	r3, r0
; }
 8010370: 4618         	mov	r0, r3
 8010372: 3708         	adds	r7, #0x8
 8010374: 46bd         	mov	sp, r7
 8010376: bd80         	pop	{r7, pc}

08010378 <z_impl_motor_set_speed>:
; static inline int8_t z_impl_motor_set_speed(const struct device *dev, float speed_rpm) {
 8010378: b580         	push	{r7, lr}
 801037a: b084         	sub	sp, #0x10
 801037c: af00         	add	r7, sp, #0x0
 801037e: 6078         	str	r0, [r7, #0x4]
 8010380: 6039         	str	r1, [r7]
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 8010382: 687b         	ldr	r3, [r7, #0x4]
 8010384: 689b         	ldr	r3, [r3, #0x8]
 8010386: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_set_speed == NULL) {
 8010388: 68fb         	ldr	r3, [r7, #0xc]
 801038a: 68db         	ldr	r3, [r3, #0xc]
 801038c: 2b00         	cmp	r3, #0x0
 801038e: d102         	bne	0x8010396 <z_impl_motor_set_speed+0x1e> @ imm = #0x4
;         return -ENOSYS;
 8010390: f06f 0357    	mvn	r3, #0x57
 8010394: e005         	b	0x80103a2 <z_impl_motor_set_speed+0x2a> @ imm = #0xa
;     return api->motor_set_speed(dev, speed_rpm);
 8010396: 68fb         	ldr	r3, [r7, #0xc]
 8010398: 68db         	ldr	r3, [r3, #0xc]
 801039a: 6839         	ldr	r1, [r7]
 801039c: 6878         	ldr	r0, [r7, #0x4]
 801039e: 4798         	blx	r3
 80103a0: 4603         	mov	r3, r0
; }
 80103a2: 4618         	mov	r0, r3
 80103a4: 3710         	adds	r7, #0x10
 80103a6: 46bd         	mov	sp, r7
 80103a8: bd80         	pop	{r7, pc}

080103aa <z_impl_motor_set_angle>:
; static inline int8_t z_impl_motor_set_angle(const struct device *dev, float angle) {
 80103aa: b580         	push	{r7, lr}
 80103ac: b084         	sub	sp, #0x10
 80103ae: af00         	add	r7, sp, #0x0
 80103b0: 6078         	str	r0, [r7, #0x4]
 80103b2: 6039         	str	r1, [r7]
;     const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 80103b4: 687b         	ldr	r3, [r7, #0x4]
 80103b6: 689b         	ldr	r3, [r3, #0x8]
 80103b8: 60fb         	str	r3, [r7, #0xc]
;     if (api->motor_set_angle == NULL) {
 80103ba: 68fb         	ldr	r3, [r7, #0xc]
 80103bc: 695b         	ldr	r3, [r3, #0x14]
 80103be: 2b00         	cmp	r3, #0x0
 80103c0: d102         	bne	0x80103c8 <z_impl_motor_set_angle+0x1e> @ imm = #0x4
;         return -ENOSYS;
 80103c2: f06f 0357    	mvn	r3, #0x57
 80103c6: e005         	b	0x80103d4 <z_impl_motor_set_angle+0x2a> @ imm = #0xa
;     return api->motor_set_angle(dev, angle);
 80103c8: 68fb         	ldr	r3, [r7, #0xc]
 80103ca: 695b         	ldr	r3, [r3, #0x14]
 80103cc: 6839         	ldr	r1, [r7]
 80103ce: 6878         	ldr	r0, [r7, #0x4]
 80103d0: 4798         	blx	r3
 80103d2: 4603         	mov	r3, r0
; }
 80103d4: 4618         	mov	r0, r3
 80103d6: 3710         	adds	r7, #0x10
 80103d8: 46bd         	mov	sp, r7
 80103da: bd80         	pop	{r7, pc}

080103dc <motor_get_torque>:
; {
 80103dc: b580         	push	{r7, lr}
 80103de: b082         	sub	sp, #0x8
 80103e0: af00         	add	r7, sp, #0x0
 80103e2: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_motor_get_torque(dev);
 80103e4: 6878         	ldr	r0, [r7, #0x4]
 80103e6: f7f0 fd01    	bl	0x8000dec <z_impl_motor_get_torque> @ imm = #-0xf5fe
 80103ea: 4603         	mov	r3, r0
; }
 80103ec: 4618         	mov	r0, r3
 80103ee: 3708         	adds	r7, #0x8
 80103f0: 46bd         	mov	sp, r7
 80103f2: bd80         	pop	{r7, pc}

080103f4 <motor_get_speed>:
; {
 80103f4: b580         	push	{r7, lr}
 80103f6: b082         	sub	sp, #0x8
 80103f8: af00         	add	r7, sp, #0x0
 80103fa: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_motor_get_speed(dev);
 80103fc: 6878         	ldr	r0, [r7, #0x4]
 80103fe: f7f0 fd0d    	bl	0x8000e1c <z_impl_motor_get_speed> @ imm = #-0xf5e6
 8010402: 4603         	mov	r3, r0
; }
 8010404: 4618         	mov	r0, r3
 8010406: 3708         	adds	r7, #0x8
 8010408: 46bd         	mov	sp, r7
 801040a: bd80         	pop	{r7, pc}

0801040c <motor_get_angle>:
; {
 801040c: b580         	push	{r7, lr}
 801040e: b082         	sub	sp, #0x8
 8010410: af00         	add	r7, sp, #0x0
 8010412: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_motor_get_angle(dev);
 8010414: 6878         	ldr	r0, [r7, #0x4]
 8010416: f7f0 fd19    	bl	0x8000e4c <z_impl_motor_get_angle> @ imm = #-0xf5ce
 801041a: 4603         	mov	r3, r0
; }
 801041c: 4618         	mov	r0, r3
 801041e: 3708         	adds	r7, #0x8
 8010420: 46bd         	mov	sp, r7
 8010422: bd80         	pop	{r7, pc}

08010424 <motor_set_speed>:
; {
 8010424: b580         	push	{r7, lr}
 8010426: b082         	sub	sp, #0x8
 8010428: af00         	add	r7, sp, #0x0
 801042a: 6078         	str	r0, [r7, #0x4]
 801042c: 6039         	str	r1, [r7]
; 	return z_impl_motor_set_speed(dev, speed_rpm);
 801042e: 6839         	ldr	r1, [r7]
 8010430: 6878         	ldr	r0, [r7, #0x4]
 8010432: f7ff ffa1    	bl	0x8010378 <z_impl_motor_set_speed> @ imm = #-0xbe
 8010436: 4603         	mov	r3, r0
; }
 8010438: 4618         	mov	r0, r3
 801043a: 3708         	adds	r7, #0x8
 801043c: 46bd         	mov	sp, r7
 801043e: bd80         	pop	{r7, pc}

08010440 <motor_set_angle>:
; {
 8010440: b580         	push	{r7, lr}
 8010442: b082         	sub	sp, #0x8
 8010444: af00         	add	r7, sp, #0x0
 8010446: 6078         	str	r0, [r7, #0x4]
 8010448: 6039         	str	r1, [r7]
; 	return z_impl_motor_set_angle(dev, angle);
 801044a: 6839         	ldr	r1, [r7]
 801044c: 6878         	ldr	r0, [r7, #0x4]
 801044e: f7ff ffac    	bl	0x80103aa <z_impl_motor_set_angle> @ imm = #-0xa8
 8010452: 4603         	mov	r3, r0
; }
 8010454: 4618         	mov	r0, r3
 8010456: 3708         	adds	r7, #0x8
 8010458: 46bd         	mov	sp, r7
 801045a: bd80         	pop	{r7, pc}

0801045c <motor_set_zero>:
; {
 801045c: b580         	push	{r7, lr}
 801045e: b082         	sub	sp, #0x8
 8010460: af00         	add	r7, sp, #0x0
 8010462: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_motor_set_zero(dev);
 8010464: 6878         	ldr	r0, [r7, #0x4]
 8010466: f7f0 fd09    	bl	0x8000e7c <z_impl_motor_set_zero> @ imm = #-0xf5ee
 801046a: 4603         	mov	r3, r0
; }
 801046c: 4618         	mov	r0, r3
 801046e: 3708         	adds	r7, #0x8
 8010470: 46bd         	mov	sp, r7
 8010472: bd80         	pop	{r7, pc}

08010474 <z_impl_sbus_get_percent>:
; static inline float z_impl_sbus_get_percent(const struct device *dev, uint8_t channelid) {
 8010474: b580         	push	{r7, lr}
 8010476: b084         	sub	sp, #0x10
 8010478: af00         	add	r7, sp, #0x0
 801047a: 6078         	str	r0, [r7, #0x4]
 801047c: 460b         	mov	r3, r1
 801047e: 70fb         	strb	r3, [r7, #0x3]
;     const struct sbus_driver_api *api = (const struct sbus_driver_api *)dev->api;
 8010480: 687b         	ldr	r3, [r7, #0x4]
 8010482: 689b         	ldr	r3, [r3, #0x8]
 8010484: 60fb         	str	r3, [r7, #0xc]
;     if (api->getchannel_percentage) {
 8010486: 68fb         	ldr	r3, [r7, #0xc]
 8010488: 681b         	ldr	r3, [r3]
 801048a: 2b00         	cmp	r3, #0x0
 801048c: d008         	beq	0x80104a0 <z_impl_sbus_get_percent+0x2c> @ imm = #0x10
;         float temp = api->getchannel_percentage(dev, channelid);
 801048e: 68fb         	ldr	r3, [r7, #0xc]
 8010490: 681b         	ldr	r3, [r3]
 8010492: 78fa         	ldrb	r2, [r7, #0x3]
 8010494: 4611         	mov	r1, r2
 8010496: 6878         	ldr	r0, [r7, #0x4]
 8010498: 4798         	blx	r3
 801049a: 60b8         	str	r0, [r7, #0x8]
;         return temp;
 801049c: 68bb         	ldr	r3, [r7, #0x8]
 801049e: e001         	b	0x80104a4 <z_impl_sbus_get_percent+0x30> @ imm = #0x2
;     return 0.0f;
 80104a0: f04f 0300    	mov.w	r3, #0x0
; }
 80104a4: 4618         	mov	r0, r3
 80104a6: 3710         	adds	r7, #0x10
 80104a8: 46bd         	mov	sp, r7
 80104aa: bd80         	pop	{r7, pc}

080104ac <z_impl_sbus_get_digit>:
; static inline int z_impl_sbus_get_digit(const struct device *dev, uint8_t channelid) {
 80104ac: b580         	push	{r7, lr}
 80104ae: b084         	sub	sp, #0x10
 80104b0: af00         	add	r7, sp, #0x0
 80104b2: 6078         	str	r0, [r7, #0x4]
 80104b4: 460b         	mov	r3, r1
 80104b6: 70fb         	strb	r3, [r7, #0x3]
;     const struct sbus_driver_api *api = (const struct sbus_driver_api *)dev->api;
 80104b8: 687b         	ldr	r3, [r7, #0x4]
 80104ba: 689b         	ldr	r3, [r3, #0x8]
 80104bc: 60fb         	str	r3, [r7, #0xc]
;     if (api->getchannel_digital) {
 80104be: 68fb         	ldr	r3, [r7, #0xc]
 80104c0: 685b         	ldr	r3, [r3, #0x4]
 80104c2: 2b00         	cmp	r3, #0x0
 80104c4: d007         	beq	0x80104d6 <z_impl_sbus_get_digit+0x2a> @ imm = #0xe
;         return api->getchannel_digital(dev, channelid);
 80104c6: 68fb         	ldr	r3, [r7, #0xc]
 80104c8: 685b         	ldr	r3, [r3, #0x4]
 80104ca: 78fa         	ldrb	r2, [r7, #0x3]
 80104cc: 4611         	mov	r1, r2
 80104ce: 6878         	ldr	r0, [r7, #0x4]
 80104d0: 4798         	blx	r3
 80104d2: 4603         	mov	r3, r0
 80104d4: e001         	b	0x80104da <z_impl_sbus_get_digit+0x2e> @ imm = #0x2
;     return -1;
 80104d6: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 80104da: 4618         	mov	r0, r3
 80104dc: 3710         	adds	r7, #0x10
 80104de: 46bd         	mov	sp, r7
 80104e0: bd80         	pop	{r7, pc}

080104e2 <sbus_get_percent>:
; {
 80104e2: b580         	push	{r7, lr}
 80104e4: b082         	sub	sp, #0x8
 80104e6: af00         	add	r7, sp, #0x0
 80104e8: 6078         	str	r0, [r7, #0x4]
 80104ea: 460b         	mov	r3, r1
 80104ec: 70fb         	strb	r3, [r7, #0x3]
; 	return z_impl_sbus_get_percent(dev, channelid);
 80104ee: 78fb         	ldrb	r3, [r7, #0x3]
 80104f0: 4619         	mov	r1, r3
 80104f2: 6878         	ldr	r0, [r7, #0x4]
 80104f4: f7ff ffbe    	bl	0x8010474 <z_impl_sbus_get_percent> @ imm = #-0x84
 80104f8: 4603         	mov	r3, r0
; }
 80104fa: 4618         	mov	r0, r3
 80104fc: 3708         	adds	r7, #0x8
 80104fe: 46bd         	mov	sp, r7
 8010500: bd80         	pop	{r7, pc}

08010502 <sbus_get_digit>:
; {
 8010502: b580         	push	{r7, lr}
 8010504: b082         	sub	sp, #0x8
 8010506: af00         	add	r7, sp, #0x0
 8010508: 6078         	str	r0, [r7, #0x4]
 801050a: 460b         	mov	r3, r1
 801050c: 70fb         	strb	r3, [r7, #0x3]
; 	return z_impl_sbus_get_digit(dev, channelid);
 801050e: 78fb         	ldrb	r3, [r7, #0x3]
 8010510: 4619         	mov	r1, r3
 8010512: 6878         	ldr	r0, [r7, #0x4]
 8010514: f7ff ffca    	bl	0x80104ac <z_impl_sbus_get_digit> @ imm = #-0x6c
 8010518: 4603         	mov	r3, r0
; }
 801051a: 4618         	mov	r0, r3
 801051c: 3708         	adds	r7, #0x8
 801051e: 46bd         	mov	sp, r7
 8010520: bd80         	pop	{r7, pc}

08010522 <big_heap_chunks>:
; {
 8010522: b480         	push	{r7}
 8010524: b083         	sub	sp, #0xc
 8010526: af00         	add	r7, sp, #0x0
 8010528: 6078         	str	r0, [r7, #0x4]
; 		return false;
 801052a: 2300         	movs	r3, #0x0
; }
 801052c: 4618         	mov	r0, r3
 801052e: 370c         	adds	r7, #0xc
 8010530: 46bd         	mov	sp, r7
 8010532: bc80         	pop	{r7}
 8010534: 4770         	bx	lr

08010536 <big_heap_bytes>:
; {
 8010536: b580         	push	{r7, lr}
 8010538: b082         	sub	sp, #0x8
 801053a: af00         	add	r7, sp, #0x0
 801053c: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(bytes / CHUNK_UNIT);
 801053e: 687b         	ldr	r3, [r7, #0x4]
 8010540: 08db         	lsrs	r3, r3, #0x3
 8010542: 4618         	mov	r0, r3
 8010544: f7ff ffed    	bl	0x8010522 <big_heap_chunks> @ imm = #-0x26
 8010548: 4603         	mov	r3, r0
; }
 801054a: 4618         	mov	r0, r3
 801054c: 3708         	adds	r7, #0x8
 801054e: 46bd         	mov	sp, r7
 8010550: bd80         	pop	{r7, pc}

08010552 <big_heap>:
; {
 8010552: b580         	push	{r7, lr}
 8010554: b082         	sub	sp, #0x8
 8010556: af00         	add	r7, sp, #0x0
 8010558: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(h->end_chunk);
 801055a: 687b         	ldr	r3, [r7, #0x4]
 801055c: 689b         	ldr	r3, [r3, #0x8]
 801055e: 4618         	mov	r0, r3
 8010560: f7ff ffdf    	bl	0x8010522 <big_heap_chunks> @ imm = #-0x42
 8010564: 4603         	mov	r3, r0
; }
 8010566: 4618         	mov	r0, r3
 8010568: 3708         	adds	r7, #0x8
 801056a: 46bd         	mov	sp, r7
 801056c: bd80         	pop	{r7, pc}

0801056e <chunk_buf>:
; {
 801056e: b480         	push	{r7}
 8010570: b083         	sub	sp, #0xc
 8010572: af00         	add	r7, sp, #0x0
 8010574: 6078         	str	r0, [r7, #0x4]
; 	return (chunk_unit_t *)h;
 8010576: 687b         	ldr	r3, [r7, #0x4]
; }
 8010578: 4618         	mov	r0, r3
 801057a: 370c         	adds	r7, #0xc
 801057c: 46bd         	mov	sp, r7
 801057e: bc80         	pop	{r7}
 8010580: 4770         	bx	lr

08010582 <chunk_field>:
; {
 8010582: b580         	push	{r7, lr}
 8010584: b086         	sub	sp, #0x18
 8010586: af00         	add	r7, sp, #0x0
 8010588: 60f8         	str	r0, [r7, #0xc]
 801058a: 60b9         	str	r1, [r7, #0x8]
 801058c: 4613         	mov	r3, r2
 801058e: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 8010590: 68f8         	ldr	r0, [r7, #0xc]
 8010592: f7ff ffec    	bl	0x801056e <chunk_buf>   @ imm = #-0x28
 8010596: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 8010598: 68bb         	ldr	r3, [r7, #0x8]
 801059a: 00db         	lsls	r3, r3, #0x3
 801059c: 697a         	ldr	r2, [r7, #0x14]
 801059e: 4413         	add	r3, r2
 80105a0: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 80105a2: 68f8         	ldr	r0, [r7, #0xc]
 80105a4: f7ff ffd5    	bl	0x8010552 <big_heap>    @ imm = #-0x56
 80105a8: 4603         	mov	r3, r0
 80105aa: 2b00         	cmp	r3, #0x0
 80105ac: d005         	beq	0x80105ba <chunk_field+0x38> @ imm = #0xa
; 		return ((uint32_t *)cmem)[f];
 80105ae: 79fb         	ldrb	r3, [r7, #0x7]
 80105b0: 009b         	lsls	r3, r3, #0x2
 80105b2: 693a         	ldr	r2, [r7, #0x10]
 80105b4: 4413         	add	r3, r2
 80105b6: 681b         	ldr	r3, [r3]
 80105b8: e004         	b	0x80105c4 <chunk_field+0x42> @ imm = #0x8
; 		return ((uint16_t *)cmem)[f];
 80105ba: 79fb         	ldrb	r3, [r7, #0x7]
 80105bc: 005b         	lsls	r3, r3, #0x1
 80105be: 693a         	ldr	r2, [r7, #0x10]
 80105c0: 4413         	add	r3, r2
 80105c2: 881b         	ldrh	r3, [r3]
; }
 80105c4: 4618         	mov	r0, r3
 80105c6: 3718         	adds	r7, #0x18
 80105c8: 46bd         	mov	sp, r7
 80105ca: bd80         	pop	{r7, pc}

080105cc <chunk_set>:
; {
 80105cc: b580         	push	{r7, lr}
 80105ce: b086         	sub	sp, #0x18
 80105d0: af00         	add	r7, sp, #0x0
 80105d2: 60f8         	str	r0, [r7, #0xc]
 80105d4: 60b9         	str	r1, [r7, #0x8]
 80105d6: 603b         	str	r3, [r7]
 80105d8: 4613         	mov	r3, r2
 80105da: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 80105dc: 68f8         	ldr	r0, [r7, #0xc]
 80105de: f7ff ffc6    	bl	0x801056e <chunk_buf>   @ imm = #-0x74
 80105e2: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 80105e4: 68bb         	ldr	r3, [r7, #0x8]
 80105e6: 00db         	lsls	r3, r3, #0x3
 80105e8: 697a         	ldr	r2, [r7, #0x14]
 80105ea: 4413         	add	r3, r2
 80105ec: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 80105ee: 68f8         	ldr	r0, [r7, #0xc]
 80105f0: f7ff ffaf    	bl	0x8010552 <big_heap>    @ imm = #-0xa2
 80105f4: 4603         	mov	r3, r0
 80105f6: 2b00         	cmp	r3, #0x0
 80105f8: d006         	beq	0x8010608 <chunk_set+0x3c> @ imm = #0xc
; 		((uint32_t *)cmem)[f] = val;
 80105fa: 79fb         	ldrb	r3, [r7, #0x7]
 80105fc: 009b         	lsls	r3, r3, #0x2
 80105fe: 693a         	ldr	r2, [r7, #0x10]
 8010600: 4413         	add	r3, r2
 8010602: 683a         	ldr	r2, [r7]
 8010604: 601a         	str	r2, [r3]
; }
 8010606: e006         	b	0x8010616 <chunk_set+0x4a> @ imm = #0xc
; 		((uint16_t *)cmem)[f] = val;
 8010608: 79fb         	ldrb	r3, [r7, #0x7]
 801060a: 005b         	lsls	r3, r3, #0x1
 801060c: 693a         	ldr	r2, [r7, #0x10]
 801060e: 4413         	add	r3, r2
 8010610: 683a         	ldr	r2, [r7]
 8010612: b292         	uxth	r2, r2
 8010614: 801a         	strh	r2, [r3]
; }
 8010616: bf00         	nop
 8010618: 3718         	adds	r7, #0x18
 801061a: 46bd         	mov	sp, r7
 801061c: bd80         	pop	{r7, pc}

0801061e <chunk_size>:
; {
 801061e: b580         	push	{r7, lr}
 8010620: b082         	sub	sp, #0x8
 8010622: af00         	add	r7, sp, #0x0
 8010624: 6078         	str	r0, [r7, #0x4]
 8010626: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, SIZE_AND_USED) >> 1;
 8010628: 2201         	movs	r2, #0x1
 801062a: 6839         	ldr	r1, [r7]
 801062c: 6878         	ldr	r0, [r7, #0x4]
 801062e: f7ff ffa8    	bl	0x8010582 <chunk_field> @ imm = #-0xb0
 8010632: 4603         	mov	r3, r0
 8010634: 085b         	lsrs	r3, r3, #0x1
; }
 8010636: 4618         	mov	r0, r3
 8010638: 3708         	adds	r7, #0x8
 801063a: 46bd         	mov	sp, r7
 801063c: bd80         	pop	{r7, pc}

0801063e <set_chunk_used>:
; {
 801063e: b580         	push	{r7, lr}
 8010640: b086         	sub	sp, #0x18
 8010642: af00         	add	r7, sp, #0x0
 8010644: 60f8         	str	r0, [r7, #0xc]
 8010646: 60b9         	str	r1, [r7, #0x8]
 8010648: 4613         	mov	r3, r2
 801064a: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 801064c: 68f8         	ldr	r0, [r7, #0xc]
 801064e: f7ff ff8e    	bl	0x801056e <chunk_buf>   @ imm = #-0xe4
 8010652: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 8010654: 68bb         	ldr	r3, [r7, #0x8]
 8010656: 00db         	lsls	r3, r3, #0x3
 8010658: 697a         	ldr	r2, [r7, #0x14]
 801065a: 4413         	add	r3, r2
 801065c: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 801065e: 68f8         	ldr	r0, [r7, #0xc]
 8010660: f7ff ff77    	bl	0x8010552 <big_heap>    @ imm = #-0x112
 8010664: 4603         	mov	r3, r0
 8010666: 2b00         	cmp	r3, #0x0
 8010668: d014         	beq	0x8010694 <set_chunk_used+0x56> @ imm = #0x28
; 		if (used) {
 801066a: 79fb         	ldrb	r3, [r7, #0x7]
 801066c: 2b00         	cmp	r3, #0x0
 801066e: d008         	beq	0x8010682 <set_chunk_used+0x44> @ imm = #0x10
; 			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
 8010670: 693b         	ldr	r3, [r7, #0x10]
 8010672: 3304         	adds	r3, #0x4
 8010674: 681a         	ldr	r2, [r3]
 8010676: 693b         	ldr	r3, [r7, #0x10]
 8010678: 3304         	adds	r3, #0x4
 801067a: f042 0201    	orr	r2, r2, #0x1
 801067e: 601a         	str	r2, [r3]
; }
 8010680: e01e         	b	0x80106c0 <set_chunk_used+0x82> @ imm = #0x3c
; 			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
 8010682: 693b         	ldr	r3, [r7, #0x10]
 8010684: 3304         	adds	r3, #0x4
 8010686: 681a         	ldr	r2, [r3]
 8010688: 693b         	ldr	r3, [r7, #0x10]
 801068a: 3304         	adds	r3, #0x4
 801068c: f022 0201    	bic	r2, r2, #0x1
 8010690: 601a         	str	r2, [r3]
; }
 8010692: e015         	b	0x80106c0 <set_chunk_used+0x82> @ imm = #0x2a
; 		if (used) {
 8010694: 79fb         	ldrb	r3, [r7, #0x7]
 8010696: 2b00         	cmp	r3, #0x0
 8010698: d009         	beq	0x80106ae <set_chunk_used+0x70> @ imm = #0x12
; 			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 801069a: 693b         	ldr	r3, [r7, #0x10]
 801069c: 3302         	adds	r3, #0x2
 801069e: 881a         	ldrh	r2, [r3]
 80106a0: 693b         	ldr	r3, [r7, #0x10]
 80106a2: 3302         	adds	r3, #0x2
 80106a4: f042 0201    	orr	r2, r2, #0x1
 80106a8: b292         	uxth	r2, r2
 80106aa: 801a         	strh	r2, [r3]
; }
 80106ac: e008         	b	0x80106c0 <set_chunk_used+0x82> @ imm = #0x10
; 			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
 80106ae: 693b         	ldr	r3, [r7, #0x10]
 80106b0: 3302         	adds	r3, #0x2
 80106b2: 881a         	ldrh	r2, [r3]
 80106b4: 693b         	ldr	r3, [r7, #0x10]
 80106b6: 3302         	adds	r3, #0x2
 80106b8: f022 0201    	bic	r2, r2, #0x1
 80106bc: b292         	uxth	r2, r2
 80106be: 801a         	strh	r2, [r3]
; }
 80106c0: bf00         	nop
 80106c2: 3718         	adds	r7, #0x18
 80106c4: 46bd         	mov	sp, r7
 80106c6: bd80         	pop	{r7, pc}

080106c8 <set_chunk_size>:
; {
 80106c8: b580         	push	{r7, lr}
 80106ca: b084         	sub	sp, #0x10
 80106cc: af00         	add	r7, sp, #0x0
 80106ce: 60f8         	str	r0, [r7, #0xc]
 80106d0: 60b9         	str	r1, [r7, #0x8]
 80106d2: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, SIZE_AND_USED, size << 1);
 80106d4: 687b         	ldr	r3, [r7, #0x4]
 80106d6: 005b         	lsls	r3, r3, #0x1
 80106d8: 2201         	movs	r2, #0x1
 80106da: 68b9         	ldr	r1, [r7, #0x8]
 80106dc: 68f8         	ldr	r0, [r7, #0xc]
 80106de: f7ff ff75    	bl	0x80105cc <chunk_set>   @ imm = #-0x116
; }
 80106e2: bf00         	nop
 80106e4: 3710         	adds	r7, #0x10
 80106e6: 46bd         	mov	sp, r7
 80106e8: bd80         	pop	{r7, pc}

080106ea <prev_free_chunk>:
; {
 80106ea: b580         	push	{r7, lr}
 80106ec: b082         	sub	sp, #0x8
 80106ee: af00         	add	r7, sp, #0x0
 80106f0: 6078         	str	r0, [r7, #0x4]
 80106f2: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, FREE_PREV);
 80106f4: 2202         	movs	r2, #0x2
 80106f6: 6839         	ldr	r1, [r7]
 80106f8: 6878         	ldr	r0, [r7, #0x4]
 80106fa: f7ff ff42    	bl	0x8010582 <chunk_field> @ imm = #-0x17c
 80106fe: 4603         	mov	r3, r0
; }
 8010700: 4618         	mov	r0, r3
 8010702: 3708         	adds	r7, #0x8
 8010704: 46bd         	mov	sp, r7
 8010706: bd80         	pop	{r7, pc}

08010708 <set_prev_free_chunk>:
; {
 8010708: b580         	push	{r7, lr}
 801070a: b084         	sub	sp, #0x10
 801070c: af00         	add	r7, sp, #0x0
 801070e: 60f8         	str	r0, [r7, #0xc]
 8010710: 60b9         	str	r1, [r7, #0x8]
 8010712: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_PREV, prev);
 8010714: 687b         	ldr	r3, [r7, #0x4]
 8010716: 2202         	movs	r2, #0x2
 8010718: 68b9         	ldr	r1, [r7, #0x8]
 801071a: 68f8         	ldr	r0, [r7, #0xc]
 801071c: f7ff ff56    	bl	0x80105cc <chunk_set>   @ imm = #-0x154
; }
 8010720: bf00         	nop
 8010722: 3710         	adds	r7, #0x10
 8010724: 46bd         	mov	sp, r7
 8010726: bd80         	pop	{r7, pc}

08010728 <set_next_free_chunk>:
; {
 8010728: b580         	push	{r7, lr}
 801072a: b084         	sub	sp, #0x10
 801072c: af00         	add	r7, sp, #0x0
 801072e: 60f8         	str	r0, [r7, #0xc]
 8010730: 60b9         	str	r1, [r7, #0x8]
 8010732: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_NEXT, next);
 8010734: 687b         	ldr	r3, [r7, #0x4]
 8010736: 2203         	movs	r2, #0x3
 8010738: 68b9         	ldr	r1, [r7, #0x8]
 801073a: 68f8         	ldr	r0, [r7, #0xc]
 801073c: f7ff ff46    	bl	0x80105cc <chunk_set>   @ imm = #-0x174
; }
 8010740: bf00         	nop
 8010742: 3710         	adds	r7, #0x10
 8010744: 46bd         	mov	sp, r7
 8010746: bd80         	pop	{r7, pc}

08010748 <set_left_chunk_size>:
; {
 8010748: b580         	push	{r7, lr}
 801074a: b084         	sub	sp, #0x10
 801074c: af00         	add	r7, sp, #0x0
 801074e: 60f8         	str	r0, [r7, #0xc]
 8010750: 60b9         	str	r1, [r7, #0x8]
 8010752: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, LEFT_SIZE, size);
 8010754: 687b         	ldr	r3, [r7, #0x4]
 8010756: 2200         	movs	r2, #0x0
 8010758: 68b9         	ldr	r1, [r7, #0x8]
 801075a: 68f8         	ldr	r0, [r7, #0xc]
 801075c: f7ff ff36    	bl	0x80105cc <chunk_set>   @ imm = #-0x194
; }
 8010760: bf00         	nop
 8010762: 3710         	adds	r7, #0x10
 8010764: 46bd         	mov	sp, r7
 8010766: bd80         	pop	{r7, pc}

08010768 <solo_free_header>:
; {
 8010768: b580         	push	{r7, lr}
 801076a: b082         	sub	sp, #0x8
 801076c: af00         	add	r7, sp, #0x0
 801076e: 6078         	str	r0, [r7, #0x4]
 8010770: 6039         	str	r1, [r7]
; 	return big_heap(h) && (chunk_size(h, c) == 1U);
 8010772: 6878         	ldr	r0, [r7, #0x4]
 8010774: f7ff feed    	bl	0x8010552 <big_heap>    @ imm = #-0x226
 8010778: 4603         	mov	r3, r0
 801077a: 2b00         	cmp	r3, #0x0
 801077c: d008         	beq	0x8010790 <solo_free_header+0x28> @ imm = #0x10
 801077e: 6839         	ldr	r1, [r7]
 8010780: 6878         	ldr	r0, [r7, #0x4]
 8010782: f7ff ff4c    	bl	0x801061e <chunk_size>  @ imm = #-0x168
 8010786: 4603         	mov	r3, r0
 8010788: 2b01         	cmp	r3, #0x1
 801078a: d101         	bne	0x8010790 <solo_free_header+0x28> @ imm = #0x2
 801078c: 2301         	movs	r3, #0x1
 801078e: e000         	b	0x8010792 <solo_free_header+0x2a> @ imm = #0x0
 8010790: 2300         	movs	r3, #0x0
 8010792: f003 0301    	and	r3, r3, #0x1
 8010796: b2db         	uxtb	r3, r3
; }
 8010798: 4618         	mov	r0, r3
 801079a: 3708         	adds	r7, #0x8
 801079c: 46bd         	mov	sp, r7
 801079e: bd80         	pop	{r7, pc}

080107a0 <chunk_header_bytes>:
; {
 80107a0: b580         	push	{r7, lr}
 80107a2: b082         	sub	sp, #0x8
 80107a4: af00         	add	r7, sp, #0x0
 80107a6: 6078         	str	r0, [r7, #0x4]
; 	return big_heap(h) ? 8 : 4;
 80107a8: 6878         	ldr	r0, [r7, #0x4]
 80107aa: f7ff fed2    	bl	0x8010552 <big_heap>    @ imm = #-0x25c
 80107ae: 4603         	mov	r3, r0
 80107b0: 2b00         	cmp	r3, #0x0
 80107b2: d001         	beq	0x80107b8 <chunk_header_bytes+0x18> @ imm = #0x2
 80107b4: 2308         	movs	r3, #0x8
 80107b6: e000         	b	0x80107ba <chunk_header_bytes+0x1a> @ imm = #0x0
 80107b8: 2304         	movs	r3, #0x4
; }
 80107ba: 4618         	mov	r0, r3
 80107bc: 3708         	adds	r7, #0x8
 80107be: 46bd         	mov	sp, r7
 80107c0: bd80         	pop	{r7, pc}

080107c2 <heap_footer_bytes>:
; {
 80107c2: b580         	push	{r7, lr}
 80107c4: b082         	sub	sp, #0x8
 80107c6: af00         	add	r7, sp, #0x0
 80107c8: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_bytes(size) ? 8 : 4;
 80107ca: 6878         	ldr	r0, [r7, #0x4]
 80107cc: f7ff feb3    	bl	0x8010536 <big_heap_bytes> @ imm = #-0x29a
 80107d0: 4603         	mov	r3, r0
 80107d2: 2b00         	cmp	r3, #0x0
 80107d4: d001         	beq	0x80107da <heap_footer_bytes+0x18> @ imm = #0x2
 80107d6: 2308         	movs	r3, #0x8
 80107d8: e000         	b	0x80107dc <heap_footer_bytes+0x1a> @ imm = #0x0
 80107da: 2304         	movs	r3, #0x4
; }
 80107dc: 4618         	mov	r0, r3
 80107de: 3708         	adds	r7, #0x8
 80107e0: 46bd         	mov	sp, r7
 80107e2: bd80         	pop	{r7, pc}

080107e4 <chunksz>:
; {
 80107e4: b480         	push	{r7}
 80107e6: b083         	sub	sp, #0xc
 80107e8: af00         	add	r7, sp, #0x0
 80107ea: 6078         	str	r0, [r7, #0x4]
; 	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 80107ec: 687b         	ldr	r3, [r7, #0x4]
 80107ee: 3307         	adds	r3, #0x7
 80107f0: 08db         	lsrs	r3, r3, #0x3
; }
 80107f2: 4618         	mov	r0, r3
 80107f4: 370c         	adds	r7, #0xc
 80107f6: 46bd         	mov	sp, r7
 80107f8: bc80         	pop	{r7}
 80107fa: 4770         	bx	lr

080107fc <bytes_to_chunksz>:
; {
 80107fc: b580         	push	{r7, lr}
 80107fe: b082         	sub	sp, #0x8
 8010800: af00         	add	r7, sp, #0x0
 8010802: 6078         	str	r0, [r7, #0x4]
 8010804: 6039         	str	r1, [r7]
; 	return chunksz(chunk_header_bytes(h) + bytes);
 8010806: 6878         	ldr	r0, [r7, #0x4]
 8010808: f7ff ffca    	bl	0x80107a0 <chunk_header_bytes> @ imm = #-0x6c
 801080c: 4602         	mov	r2, r0
 801080e: 683b         	ldr	r3, [r7]
 8010810: 4413         	add	r3, r2
 8010812: 4618         	mov	r0, r3
 8010814: f7ff ffe6    	bl	0x80107e4 <chunksz>     @ imm = #-0x34
 8010818: 4603         	mov	r3, r0
; }
 801081a: 4618         	mov	r0, r3
 801081c: 3708         	adds	r7, #0x8
 801081e: 46bd         	mov	sp, r7
 8010820: bd80         	pop	{r7, pc}

08010822 <min_chunk_size>:
; {
 8010822: b580         	push	{r7, lr}
 8010824: b082         	sub	sp, #0x8
 8010826: af00         	add	r7, sp, #0x0
 8010828: 6078         	str	r0, [r7, #0x4]
; 	return bytes_to_chunksz(h, 1);
 801082a: 2101         	movs	r1, #0x1
 801082c: 6878         	ldr	r0, [r7, #0x4]
 801082e: f7ff ffe5    	bl	0x80107fc <bytes_to_chunksz> @ imm = #-0x36
 8010832: 4603         	mov	r3, r0
; }
 8010834: 4618         	mov	r0, r3
 8010836: 3708         	adds	r7, #0x8
 8010838: 46bd         	mov	sp, r7
 801083a: bd80         	pop	{r7, pc}

0801083c <bucket_idx>:
; {
 801083c: b580         	push	{r7, lr}
 801083e: b084         	sub	sp, #0x10
 8010840: af00         	add	r7, sp, #0x0
 8010842: 6078         	str	r0, [r7, #0x4]
 8010844: 6039         	str	r1, [r7]
; 	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
 8010846: 6878         	ldr	r0, [r7, #0x4]
 8010848: f7ff ffeb    	bl	0x8010822 <min_chunk_size> @ imm = #-0x2a
 801084c: 4602         	mov	r2, r0
 801084e: 683b         	ldr	r3, [r7]
 8010850: 1a9b         	subs	r3, r3, r2
 8010852: 3301         	adds	r3, #0x1
 8010854: 60fb         	str	r3, [r7, #0xc]
; 	return 31 - __builtin_clz(usable_sz);
 8010856: 68fb         	ldr	r3, [r7, #0xc]
 8010858: fab3 f383    	clz	r3, r3
 801085c: f1c3 031f    	rsb.w	r3, r3, #0x1f
; }
 8010860: 4618         	mov	r0, r3
 8010862: 3710         	adds	r7, #0x10
 8010864: 46bd         	mov	sp, r7
 8010866: bd80         	pop	{r7, pc}

08010868 <free_list_add_bidx>:
; {
 8010868: b580         	push	{r7, lr}
 801086a: b088         	sub	sp, #0x20
 801086c: af00         	add	r7, sp, #0x0
 801086e: 60f8         	str	r0, [r7, #0xc]
 8010870: 60b9         	str	r1, [r7, #0x8]
 8010872: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap_bucket *b = &h->buckets[bidx];
 8010874: 687b         	ldr	r3, [r7, #0x4]
 8010876: 3304         	adds	r3, #0x4
 8010878: 009b         	lsls	r3, r3, #0x2
 801087a: 68fa         	ldr	r2, [r7, #0xc]
 801087c: 4413         	add	r3, r2
 801087e: 61fb         	str	r3, [r7, #0x1c]
; 	if (b->next == 0U) {
 8010880: 69fb         	ldr	r3, [r7, #0x1c]
 8010882: 681b         	ldr	r3, [r3]
 8010884: 2b00         	cmp	r3, #0x0
 8010886: d116         	bne	0x80108b6 <free_list_add_bidx+0x4e> @ imm = #0x2c
; 		h->avail_buckets |= BIT(bidx);
 8010888: 68fb         	ldr	r3, [r7, #0xc]
 801088a: 68da         	ldr	r2, [r3, #0xc]
 801088c: 2101         	movs	r1, #0x1
 801088e: 687b         	ldr	r3, [r7, #0x4]
 8010890: fa01 f303    	lsl.w	r3, r1, r3
 8010894: 431a         	orrs	r2, r3
 8010896: 68fb         	ldr	r3, [r7, #0xc]
 8010898: 60da         	str	r2, [r3, #0xc]
; 		b->next = c;
 801089a: 69fb         	ldr	r3, [r7, #0x1c]
 801089c: 68ba         	ldr	r2, [r7, #0x8]
 801089e: 601a         	str	r2, [r3]
; 		set_prev_free_chunk(h, c, c);
 80108a0: 68ba         	ldr	r2, [r7, #0x8]
 80108a2: 68b9         	ldr	r1, [r7, #0x8]
 80108a4: 68f8         	ldr	r0, [r7, #0xc]
 80108a6: f7ff ff2f    	bl	0x8010708 <set_prev_free_chunk> @ imm = #-0x1a2
; 		set_next_free_chunk(h, c, c);
 80108aa: 68ba         	ldr	r2, [r7, #0x8]
 80108ac: 68b9         	ldr	r1, [r7, #0x8]
 80108ae: 68f8         	ldr	r0, [r7, #0xc]
 80108b0: f7ff ff3a    	bl	0x8010728 <set_next_free_chunk> @ imm = #-0x18c
; }
 80108b4: e01b         	b	0x80108ee <free_list_add_bidx+0x86> @ imm = #0x36
; 		chunkid_t second = b->next;
 80108b6: 69fb         	ldr	r3, [r7, #0x1c]
 80108b8: 681b         	ldr	r3, [r3]
 80108ba: 61bb         	str	r3, [r7, #0x18]
; 		chunkid_t first = prev_free_chunk(h, second);
 80108bc: 69b9         	ldr	r1, [r7, #0x18]
 80108be: 68f8         	ldr	r0, [r7, #0xc]
 80108c0: f7ff ff13    	bl	0x80106ea <prev_free_chunk> @ imm = #-0x1da
 80108c4: 6178         	str	r0, [r7, #0x14]
; 		set_prev_free_chunk(h, c, first);
 80108c6: 697a         	ldr	r2, [r7, #0x14]
 80108c8: 68b9         	ldr	r1, [r7, #0x8]
 80108ca: 68f8         	ldr	r0, [r7, #0xc]
 80108cc: f7ff ff1c    	bl	0x8010708 <set_prev_free_chunk> @ imm = #-0x1c8
; 		set_next_free_chunk(h, c, second);
 80108d0: 69ba         	ldr	r2, [r7, #0x18]
 80108d2: 68b9         	ldr	r1, [r7, #0x8]
 80108d4: 68f8         	ldr	r0, [r7, #0xc]
 80108d6: f7ff ff27    	bl	0x8010728 <set_next_free_chunk> @ imm = #-0x1b2
; 		set_next_free_chunk(h, first, c);
 80108da: 68ba         	ldr	r2, [r7, #0x8]
 80108dc: 6979         	ldr	r1, [r7, #0x14]
 80108de: 68f8         	ldr	r0, [r7, #0xc]
 80108e0: f7ff ff22    	bl	0x8010728 <set_next_free_chunk> @ imm = #-0x1bc
; 		set_prev_free_chunk(h, second, c);
 80108e4: 68ba         	ldr	r2, [r7, #0x8]
 80108e6: 69b9         	ldr	r1, [r7, #0x18]
 80108e8: 68f8         	ldr	r0, [r7, #0xc]
 80108ea: f7ff ff0d    	bl	0x8010708 <set_prev_free_chunk> @ imm = #-0x1e6
; }
 80108ee: bf00         	nop
 80108f0: 3720         	adds	r7, #0x20
 80108f2: 46bd         	mov	sp, r7
 80108f4: bd80         	pop	{r7, pc}

080108f6 <free_list_add>:
; {
 80108f6: b580         	push	{r7, lr}
 80108f8: b084         	sub	sp, #0x10
 80108fa: af00         	add	r7, sp, #0x0
 80108fc: 6078         	str	r0, [r7, #0x4]
 80108fe: 6039         	str	r1, [r7]
; 	if (!solo_free_header(h, c)) {
 8010900: 6839         	ldr	r1, [r7]
 8010902: 6878         	ldr	r0, [r7, #0x4]
 8010904: f7ff ff30    	bl	0x8010768 <solo_free_header> @ imm = #-0x1a0
 8010908: 4603         	mov	r3, r0
 801090a: f083 0301    	eor	r3, r3, #0x1
 801090e: b2db         	uxtb	r3, r3
 8010910: 2b00         	cmp	r3, #0x0
 8010912: d00e         	beq	0x8010932 <free_list_add+0x3c> @ imm = #0x1c
; 		int bidx = bucket_idx(h, chunk_size(h, c));
 8010914: 6839         	ldr	r1, [r7]
 8010916: 6878         	ldr	r0, [r7, #0x4]
 8010918: f7ff fe81    	bl	0x801061e <chunk_size>  @ imm = #-0x2fe
 801091c: 4603         	mov	r3, r0
 801091e: 4619         	mov	r1, r3
 8010920: 6878         	ldr	r0, [r7, #0x4]
 8010922: f7ff ff8b    	bl	0x801083c <bucket_idx>  @ imm = #-0xea
 8010926: 60f8         	str	r0, [r7, #0xc]
; 		free_list_add_bidx(h, c, bidx);
 8010928: 68fa         	ldr	r2, [r7, #0xc]
 801092a: 6839         	ldr	r1, [r7]
 801092c: 6878         	ldr	r0, [r7, #0x4]
 801092e: f7ff ff9b    	bl	0x8010868 <free_list_add_bidx> @ imm = #-0xca
; }
 8010932: bf00         	nop
 8010934: 3710         	adds	r7, #0x10
 8010936: 46bd         	mov	sp, r7
 8010938: bd80         	pop	{r7, pc}

0801093a <sys_heap_init>:
; {
 801093a: b580         	push	{r7, lr}
 801093c: b08c         	sub	sp, #0x30
 801093e: af00         	add	r7, sp, #0x0
 8010940: 60f8         	str	r0, [r7, #0xc]
 8010942: 60b9         	str	r1, [r7, #0x8]
 8010944: 607a         	str	r2, [r7, #0x4]
; 	bytes -= heap_footer_bytes(bytes);
 8010946: 6878         	ldr	r0, [r7, #0x4]
 8010948: f7ff ff3b    	bl	0x80107c2 <heap_footer_bytes> @ imm = #-0x18a
 801094c: 4602         	mov	r2, r0
 801094e: 687b         	ldr	r3, [r7, #0x4]
 8010950: 1a9b         	subs	r3, r3, r2
 8010952: 607b         	str	r3, [r7, #0x4]
; 	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 8010954: 68bb         	ldr	r3, [r7, #0x8]
 8010956: 3307         	adds	r3, #0x7
 8010958: f023 0307    	bic	r3, r3, #0x7
 801095c: 62bb         	str	r3, [r7, #0x28]
; 	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 801095e: 68ba         	ldr	r2, [r7, #0x8]
 8010960: 687b         	ldr	r3, [r7, #0x4]
 8010962: 4413         	add	r3, r2
 8010964: f023 0307    	bic	r3, r3, #0x7
 8010968: 627b         	str	r3, [r7, #0x24]
; 	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
 801096a: 6a7a         	ldr	r2, [r7, #0x24]
 801096c: 6abb         	ldr	r3, [r7, #0x28]
 801096e: 1ad3         	subs	r3, r2, r3
 8010970: 08db         	lsrs	r3, r3, #0x3
 8010972: 623b         	str	r3, [r7, #0x20]
; 	struct z_heap *h = (struct z_heap *)addr;
 8010974: 6abb         	ldr	r3, [r7, #0x28]
 8010976: 61fb         	str	r3, [r7, #0x1c]
; 	heap->heap = h;
 8010978: 68fb         	ldr	r3, [r7, #0xc]
 801097a: 69fa         	ldr	r2, [r7, #0x1c]
 801097c: 601a         	str	r2, [r3]
; 	h->end_chunk = heap_sz;
 801097e: 69fb         	ldr	r3, [r7, #0x1c]
 8010980: 6a3a         	ldr	r2, [r7, #0x20]
 8010982: 609a         	str	r2, [r3, #0x8]
; 	h->avail_buckets = 0;
 8010984: 69fb         	ldr	r3, [r7, #0x1c]
 8010986: 2200         	movs	r2, #0x0
 8010988: 60da         	str	r2, [r3, #0xc]
; 	int nb_buckets = bucket_idx(h, heap_sz) + 1;
 801098a: 6a39         	ldr	r1, [r7, #0x20]
 801098c: 69f8         	ldr	r0, [r7, #0x1c]
 801098e: f7ff ff55    	bl	0x801083c <bucket_idx>  @ imm = #-0x156
 8010992: 4603         	mov	r3, r0
 8010994: 3301         	adds	r3, #0x1
 8010996: 61bb         	str	r3, [r7, #0x18]
; 	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
 8010998: 69bb         	ldr	r3, [r7, #0x18]
 801099a: 3304         	adds	r3, #0x4
 801099c: 009b         	lsls	r3, r3, #0x2
 801099e: 4618         	mov	r0, r3
 80109a0: f7ff ff20    	bl	0x80107e4 <chunksz>     @ imm = #-0x1c0
 80109a4: 6178         	str	r0, [r7, #0x14]
; 	for (int i = 0; i < nb_buckets; i++) {
 80109a6: 2300         	movs	r3, #0x0
 80109a8: 62fb         	str	r3, [r7, #0x2c]
 80109aa: e008         	b	0x80109be <sys_heap_init+0x84> @ imm = #0x10
; 		h->buckets[i].next = 0;
 80109ac: 69fb         	ldr	r3, [r7, #0x1c]
 80109ae: 6afa         	ldr	r2, [r7, #0x2c]
 80109b0: 3204         	adds	r2, #0x4
 80109b2: 2100         	movs	r1, #0x0
 80109b4: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 	for (int i = 0; i < nb_buckets; i++) {
 80109b8: 6afb         	ldr	r3, [r7, #0x2c]
 80109ba: 3301         	adds	r3, #0x1
 80109bc: 62fb         	str	r3, [r7, #0x2c]
 80109be: 6afa         	ldr	r2, [r7, #0x2c]
 80109c0: 69bb         	ldr	r3, [r7, #0x18]
 80109c2: 429a         	cmp	r2, r3
 80109c4: dbf2         	blt	0x80109ac <sys_heap_init+0x72> @ imm = #-0x1c
; 	set_chunk_size(h, 0, chunk0_size);
 80109c6: 697a         	ldr	r2, [r7, #0x14]
 80109c8: 2100         	movs	r1, #0x0
 80109ca: 69f8         	ldr	r0, [r7, #0x1c]
 80109cc: f7ff fe7c    	bl	0x80106c8 <set_chunk_size> @ imm = #-0x308
; 	set_left_chunk_size(h, 0, 0);
 80109d0: 2200         	movs	r2, #0x0
 80109d2: 2100         	movs	r1, #0x0
 80109d4: 69f8         	ldr	r0, [r7, #0x1c]
 80109d6: f7ff feb7    	bl	0x8010748 <set_left_chunk_size> @ imm = #-0x292
; 	set_chunk_used(h, 0, true);
 80109da: 2201         	movs	r2, #0x1
 80109dc: 2100         	movs	r1, #0x0
 80109de: 69f8         	ldr	r0, [r7, #0x1c]
 80109e0: f7ff fe2d    	bl	0x801063e <set_chunk_used> @ imm = #-0x3a6
; 	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
 80109e4: 6a3a         	ldr	r2, [r7, #0x20]
 80109e6: 697b         	ldr	r3, [r7, #0x14]
 80109e8: 1ad3         	subs	r3, r2, r3
 80109ea: 461a         	mov	r2, r3
 80109ec: 6979         	ldr	r1, [r7, #0x14]
 80109ee: 69f8         	ldr	r0, [r7, #0x1c]
 80109f0: f7ff fe6a    	bl	0x80106c8 <set_chunk_size> @ imm = #-0x32c
; 	set_left_chunk_size(h, chunk0_size, chunk0_size);
 80109f4: 697a         	ldr	r2, [r7, #0x14]
 80109f6: 6979         	ldr	r1, [r7, #0x14]
 80109f8: 69f8         	ldr	r0, [r7, #0x1c]
 80109fa: f7ff fea5    	bl	0x8010748 <set_left_chunk_size> @ imm = #-0x2b6
; 	set_chunk_size(h, heap_sz, 0);
 80109fe: 2200         	movs	r2, #0x0
 8010a00: 6a39         	ldr	r1, [r7, #0x20]
 8010a02: 69f8         	ldr	r0, [r7, #0x1c]
 8010a04: f7ff fe60    	bl	0x80106c8 <set_chunk_size> @ imm = #-0x340
; 	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
 8010a08: 6a3a         	ldr	r2, [r7, #0x20]
 8010a0a: 697b         	ldr	r3, [r7, #0x14]
 8010a0c: 1ad3         	subs	r3, r2, r3
 8010a0e: 461a         	mov	r2, r3
 8010a10: 6a39         	ldr	r1, [r7, #0x20]
 8010a12: 69f8         	ldr	r0, [r7, #0x1c]
 8010a14: f7ff fe98    	bl	0x8010748 <set_left_chunk_size> @ imm = #-0x2d0
; 	set_chunk_used(h, heap_sz, true);
 8010a18: 2201         	movs	r2, #0x1
 8010a1a: 6a39         	ldr	r1, [r7, #0x20]
 8010a1c: 69f8         	ldr	r0, [r7, #0x1c]
 8010a1e: f7ff fe0e    	bl	0x801063e <set_chunk_used> @ imm = #-0x3e4
; 	free_list_add(h, chunk0_size);
 8010a22: 6979         	ldr	r1, [r7, #0x14]
 8010a24: 69f8         	ldr	r0, [r7, #0x1c]
 8010a26: f7ff ff66    	bl	0x80108f6 <free_list_add> @ imm = #-0x134
; }
 8010a2a: bf00         	nop
 8010a2c: 3730         	adds	r7, #0x30
 8010a2e: 46bd         	mov	sp, r7
 8010a30: bd80         	pop	{r7, pc}

08010a32 <ptr_in_rodata>:
; {
 8010a32: b580         	push	{r7, lr}
 8010a34: b082         	sub	sp, #0x8
 8010a36: af00         	add	r7, sp, #0x0
 8010a38: 6078         	str	r0, [r7, #0x4]
; 	return linker_is_in_rodata(addr);
 8010a3a: 6878         	ldr	r0, [r7, #0x4]
 8010a3c: f7f0 fcda    	bl	0x80013f4 <linker_is_in_rodata> @ imm = #-0xf64c
 8010a40: 4603         	mov	r3, r0
; }
 8010a42: 4618         	mov	r0, r3
 8010a44: 3708         	adds	r7, #0x8
 8010a46: 46bd         	mov	sp, r7
 8010a48: bd80         	pop	{r7, pc}

08010a4a <cbprintf_via_va_list>:
; {
 8010a4a: b590         	push	{r4, r7, lr}
 8010a4c: b087         	sub	sp, #0x1c
 8010a4e: af00         	add	r7, sp, #0x0
 8010a50: 60f8         	str	r0, [r7, #0xc]
 8010a52: 60b9         	str	r1, [r7, #0x8]
 8010a54: 607a         	str	r2, [r7, #0x4]
 8010a56: 603b         	str	r3, [r7]
; 	u.ptr = buf;
 8010a58: 6abb         	ldr	r3, [r7, #0x28]
 8010a5a: 617b         	str	r3, [r7, #0x14]
; 	return formatter(out, ctx, fmt, u.ap);
 8010a5c: 68bc         	ldr	r4, [r7, #0x8]
 8010a5e: 697b         	ldr	r3, [r7, #0x14]
 8010a60: 683a         	ldr	r2, [r7]
 8010a62: 6879         	ldr	r1, [r7, #0x4]
 8010a64: 68f8         	ldr	r0, [r7, #0xc]
 8010a66: 47a0         	blx	r4
 8010a68: 4603         	mov	r3, r0
; }
 8010a6a: 4618         	mov	r0, r3
 8010a6c: 371c         	adds	r7, #0x1c
 8010a6e: 46bd         	mov	sp, r7
 8010a70: bd90         	pop	{r4, r7, pc}

08010a72 <cbpprintf_external>:
; {
 8010a72: b580         	push	{r7, lr}
 8010a74: b090         	sub	sp, #0x40
 8010a76: af02         	add	r7, sp, #0x8
 8010a78: 60f8         	str	r0, [r7, #0xc]
 8010a7a: 60b9         	str	r1, [r7, #0x8]
 8010a7c: 607a         	str	r2, [r7, #0x4]
 8010a7e: 603b         	str	r3, [r7]
; 	uint8_t *buf = packaged;
 8010a80: 683b         	ldr	r3, [r7]
 8010a82: 62fb         	str	r3, [r7, #0x2c]
; 	struct cbprintf_package_hdr_ext *hdr = packaged;
 8010a84: 683b         	ldr	r3, [r7]
 8010a86: 62bb         	str	r3, [r7, #0x28]
; 	if (buf == NULL) {
 8010a88: 6afb         	ldr	r3, [r7, #0x2c]
 8010a8a: 2b00         	cmp	r3, #0x0
 8010a8c: d102         	bne	0x8010a94 <cbpprintf_external+0x22> @ imm = #0x4
; 		return -EINVAL;
 8010a8e: f06f 0315    	mvn	r3, #0x15
 8010a92: e043         	b	0x8010b1c <cbpprintf_external+0xaa> @ imm = #0x86
; 	args_size = hdr->hdr.desc.len * sizeof(int);
 8010a94: 6abb         	ldr	r3, [r7, #0x28]
 8010a96: 781b         	ldrb	r3, [r3]
 8010a98: 009b         	lsls	r3, r3, #0x2
 8010a9a: 627b         	str	r3, [r7, #0x24]
; 	s_nbr     = hdr->hdr.desc.str_cnt;
 8010a9c: 6abb         	ldr	r3, [r7, #0x28]
 8010a9e: 785b         	ldrb	r3, [r3, #0x1]
 8010aa0: 623b         	str	r3, [r7, #0x20]
; 	ros_nbr   = hdr->hdr.desc.ro_str_cnt;
 8010aa2: 6abb         	ldr	r3, [r7, #0x28]
 8010aa4: 789b         	ldrb	r3, [r3, #0x2]
 8010aa6: 61fb         	str	r3, [r7, #0x1c]
; 	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
 8010aa8: 6abb         	ldr	r3, [r7, #0x28]
 8010aaa: 78db         	ldrb	r3, [r3, #0x3]
 8010aac: 61bb         	str	r3, [r7, #0x18]
; 	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
 8010aae: 6a7a         	ldr	r2, [r7, #0x24]
 8010ab0: 69fb         	ldr	r3, [r7, #0x1c]
 8010ab2: 441a         	add	r2, r3
 8010ab4: 69bb         	ldr	r3, [r7, #0x18]
 8010ab6: 005b         	lsls	r3, r3, #0x1
 8010ab8: 4413         	add	r3, r2
 8010aba: 6afa         	ldr	r2, [r7, #0x2c]
 8010abc: 4413         	add	r3, r2
 8010abe: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 8010ac0: 2300         	movs	r3, #0x0
 8010ac2: 633b         	str	r3, [r7, #0x30]
 8010ac4: e018         	b	0x8010af8 <cbpprintf_external+0x86> @ imm = #0x30
; 		s_idx = *(uint8_t *)s;
 8010ac6: 6b7b         	ldr	r3, [r7, #0x34]
 8010ac8: 781b         	ldrb	r3, [r3]
 8010aca: 617b         	str	r3, [r7, #0x14]
; 		++s;
 8010acc: 6b7b         	ldr	r3, [r7, #0x34]
 8010ace: 3301         	adds	r3, #0x1
 8010ad0: 637b         	str	r3, [r7, #0x34]
; 		ps = (char **)(buf + s_idx * sizeof(int));
 8010ad2: 697b         	ldr	r3, [r7, #0x14]
 8010ad4: 009b         	lsls	r3, r3, #0x2
 8010ad6: 6afa         	ldr	r2, [r7, #0x2c]
 8010ad8: 4413         	add	r3, r2
 8010ada: 613b         	str	r3, [r7, #0x10]
; 		*ps = s;
 8010adc: 693b         	ldr	r3, [r7, #0x10]
 8010ade: 6b7a         	ldr	r2, [r7, #0x34]
 8010ae0: 601a         	str	r2, [r3]
; 		s += strlen(s) + 1;
 8010ae2: 6b78         	ldr	r0, [r7, #0x34]
 8010ae4: f7f0 f82a    	bl	0x8000b3c <strlen>      @ imm = #-0xffac
 8010ae8: 4603         	mov	r3, r0
 8010aea: 3301         	adds	r3, #0x1
 8010aec: 6b7a         	ldr	r2, [r7, #0x34]
 8010aee: 4413         	add	r3, r2
 8010af0: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 8010af2: 6b3b         	ldr	r3, [r7, #0x30]
 8010af4: 3301         	adds	r3, #0x1
 8010af6: 633b         	str	r3, [r7, #0x30]
 8010af8: 6b3a         	ldr	r2, [r7, #0x30]
 8010afa: 6a3b         	ldr	r3, [r7, #0x20]
 8010afc: 429a         	cmp	r2, r3
 8010afe: d3e2         	blo	0x8010ac6 <cbpprintf_external+0x54> @ imm = #-0x3c
; 	buf += sizeof(*hdr);
 8010b00: 6afb         	ldr	r3, [r7, #0x2c]
 8010b02: 3308         	adds	r3, #0x8
 8010b04: 62fb         	str	r3, [r7, #0x2c]
; 	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
 8010b06: 6abb         	ldr	r3, [r7, #0x28]
 8010b08: 685a         	ldr	r2, [r3, #0x4]
 8010b0a: 6afb         	ldr	r3, [r7, #0x2c]
 8010b0c: 9300         	str	r3, [sp]
 8010b0e: 4613         	mov	r3, r2
 8010b10: 687a         	ldr	r2, [r7, #0x4]
 8010b12: 68b9         	ldr	r1, [r7, #0x8]
 8010b14: 68f8         	ldr	r0, [r7, #0xc]
 8010b16: f7ff ff98    	bl	0x8010a4a <cbprintf_via_va_list> @ imm = #-0xd0
 8010b1a: 4603         	mov	r3, r0
; }
 8010b1c: 4618         	mov	r0, r3
 8010b1e: 3738         	adds	r7, #0x38
 8010b20: 46bd         	mov	sp, r7
 8010b22: bd80         	pop	{r7, pc}

08010b24 <arch_printk_char_out>:
; {
 8010b24: b480         	push	{r7}
 8010b26: b083         	sub	sp, #0xc
 8010b28: af00         	add	r7, sp, #0x0
 8010b2a: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8010b2c: 2300         	movs	r3, #0x0
; }
 8010b2e: 4618         	mov	r0, r3
 8010b30: 370c         	adds	r7, #0xc
 8010b32: 46bd         	mov	sp, r7
 8010b34: bc80         	pop	{r7}
 8010b36: 4770         	bx	lr

08010b38 <vprintk>:
; {
 8010b38: b580         	push	{r7, lr}
 8010b3a: b08c         	sub	sp, #0x30
 8010b3c: af00         	add	r7, sp, #0x0
 8010b3e: 6078         	str	r0, [r7, #0x4]
 8010b40: 6039         	str	r1, [r7]
; 		z_log_vprintk(fmt, ap);
 8010b42: 6839         	ldr	r1, [r7]
 8010b44: 6878         	ldr	r0, [r7, #0x4]
 8010b46: f000 f949    	bl	0x8010ddc <z_log_vprintk> @ imm = #0x292
; 		return;
 8010b4a: bf00         	nop
; }
 8010b4c: 3730         	adds	r7, #0x30
 8010b4e: 46bd         	mov	sp, r7
 8010b50: bd80         	pop	{r7, pc}

08010b52 <printk>:
; {
 8010b52: b40f         	push	{r0, r1, r2, r3}
 8010b54: b580         	push	{r7, lr}
 8010b56: b082         	sub	sp, #0x8
 8010b58: af00         	add	r7, sp, #0x0
; 	va_start(ap, fmt);
 8010b5a: f107 0314    	add.w	r3, r7, #0x14
 8010b5e: 607b         	str	r3, [r7, #0x4]
; 	vprintk(fmt, ap);
 8010b60: 6879         	ldr	r1, [r7, #0x4]
 8010b62: 6938         	ldr	r0, [r7, #0x10]
 8010b64: f7ff ffe8    	bl	0x8010b38 <vprintk>     @ imm = #-0x30
; }
 8010b68: bf00         	nop
 8010b6a: 3708         	adds	r7, #0x8
 8010b6c: 46bd         	mov	sp, r7
 8010b6e: e8bd 4080    	pop.w	{r7, lr}
 8010b72: b004         	add	sp, #0x10
 8010b74: 4770         	bx	lr

08010b76 <k_sched_current_thread_query>:
; {
 8010b76: b580         	push	{r7, lr}
 8010b78: af00         	add	r7, sp, #0x0
; 	return z_impl_k_sched_current_thread_query();
 8010b7a: f7fd fabf    	bl	0x800e0fc <z_impl_k_sched_current_thread_query> @ imm = #-0x2a82
 8010b7e: 4603         	mov	r3, r0
; }
 8010b80: 4618         	mov	r0, r3
 8010b82: bd80         	pop	{r7, pc}

08010b84 <k_thread_abort>:
; {
 8010b84: b580         	push	{r7, lr}
 8010b86: b082         	sub	sp, #0x8
 8010b88: af00         	add	r7, sp, #0x0
 8010b8a: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 8010b8c: 6878         	ldr	r0, [r7, #0x4]
 8010b8e: f7f2 fe7b    	bl	0x8003888 <z_impl_k_thread_abort> @ imm = #-0xd30a
; }
 8010b92: bf00         	nop
 8010b94: 3708         	adds	r7, #0x8
 8010b96: 46bd         	mov	sp, r7
 8010b98: bd80         	pop	{r7, pc}

08010b9a <_ConfigAbsSyms>:
; GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
 8010b9a: b480         	push	{r7}
 8010b9c: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 8010b9e: bf00         	nop
 8010ba0: 46bd         	mov	sp, r7
 8010ba2: bc80         	pop	{r7}
 8010ba4: 4770         	bx	lr

08010ba6 <st_stm32_common_config>:
; {
 8010ba6: b580         	push	{r7, lr}
 8010ba8: af00         	add	r7, sp, #0x0
; 	LL_DBGMCU_DisableDBGStopMode();
 8010baa: f7f1 f851    	bl	0x8001c50 <LL_DBGMCU_DisableDBGStopMode> @ imm = #-0xef5e
; 	return 0;
 8010bae: 2300         	movs	r3, #0x0
; }
 8010bb0: 4618         	mov	r0, r3
 8010bb2: bd80         	pop	{r7, pc}

08010bb4 <atomic_add>:
; {
 8010bb4: b490         	push	{r4, r7}
 8010bb6: b082         	sub	sp, #0x8
 8010bb8: af00         	add	r7, sp, #0x0
 8010bba: 6078         	str	r0, [r7, #0x4]
 8010bbc: 6039         	str	r1, [r7]
; 	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 8010bbe: 683a         	ldr	r2, [r7]
 8010bc0: 687b         	ldr	r3, [r7, #0x4]
 8010bc2: f3bf 8f5b    	dmb	ish
 8010bc6: e853 1f00    	ldrex	r1, [r3]
 8010bca: eb01 0002    	add.w	r0, r1, r2
 8010bce: e843 0400    	strex	r4, r0, [r3]
 8010bd2: 2c00         	cmp	r4, #0x0
 8010bd4: d1f7         	bne	0x8010bc6 <atomic_add+0x12> @ imm = #-0x12
 8010bd6: f3bf 8f5b    	dmb	ish
 8010bda: 460b         	mov	r3, r1
; }
 8010bdc: 4618         	mov	r0, r3
 8010bde: 3708         	adds	r7, #0x8
 8010be0: 46bd         	mov	sp, r7
 8010be2: bc90         	pop	{r4, r7}
 8010be4: 4770         	bx	lr

08010be6 <atomic_sub>:
; {
 8010be6: b490         	push	{r4, r7}
 8010be8: b082         	sub	sp, #0x8
 8010bea: af00         	add	r7, sp, #0x0
 8010bec: 6078         	str	r0, [r7, #0x4]
 8010bee: 6039         	str	r1, [r7]
; 	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 8010bf0: 683a         	ldr	r2, [r7]
 8010bf2: 687b         	ldr	r3, [r7, #0x4]
 8010bf4: f3bf 8f5b    	dmb	ish
 8010bf8: e853 1f00    	ldrex	r1, [r3]
 8010bfc: eba1 0002    	sub.w	r0, r1, r2
 8010c00: e843 0400    	strex	r4, r0, [r3]
 8010c04: 2c00         	cmp	r4, #0x0
 8010c06: d1f7         	bne	0x8010bf8 <atomic_sub+0x12> @ imm = #-0x12
 8010c08: f3bf 8f5b    	dmb	ish
 8010c0c: 460b         	mov	r3, r1
; }
 8010c0e: 4618         	mov	r0, r3
 8010c10: 3708         	adds	r7, #0x8
 8010c12: 46bd         	mov	sp, r7
 8010c14: bc90         	pop	{r4, r7}
 8010c16: 4770         	bx	lr

08010c18 <atomic_inc>:
; {
 8010c18: b580         	push	{r7, lr}
 8010c1a: b082         	sub	sp, #0x8
 8010c1c: af00         	add	r7, sp, #0x0
 8010c1e: 6078         	str	r0, [r7, #0x4]
; 	return atomic_add(target, 1);
 8010c20: 2101         	movs	r1, #0x1
 8010c22: 6878         	ldr	r0, [r7, #0x4]
 8010c24: f7ff ffc6    	bl	0x8010bb4 <atomic_add>  @ imm = #-0x74
 8010c28: 4603         	mov	r3, r0
; }
 8010c2a: 4618         	mov	r0, r3
 8010c2c: 3708         	adds	r7, #0x8
 8010c2e: 46bd         	mov	sp, r7
 8010c30: bd80         	pop	{r7, pc}

08010c32 <atomic_dec>:
; {
 8010c32: b580         	push	{r7, lr}
 8010c34: b082         	sub	sp, #0x8
 8010c36: af00         	add	r7, sp, #0x0
 8010c38: 6078         	str	r0, [r7, #0x4]
; 	return atomic_sub(target, 1);
 8010c3a: 2101         	movs	r1, #0x1
 8010c3c: 6878         	ldr	r0, [r7, #0x4]
 8010c3e: f7ff ffd2    	bl	0x8010be6 <atomic_sub>  @ imm = #-0x5c
 8010c42: 4603         	mov	r3, r0
; }
 8010c44: 4618         	mov	r0, r3
 8010c46: 3708         	adds	r7, #0x8
 8010c48: 46bd         	mov	sp, r7
 8010c4a: bd80         	pop	{r7, pc}

08010c4c <z_log_item_is_msg>:
; {
 8010c4c: b480         	push	{r7}
 8010c4e: b083         	sub	sp, #0xc
 8010c50: af00         	add	r7, sp, #0x0
 8010c52: 6078         	str	r0, [r7, #0x4]
; 	return msg->generic.type == Z_LOG_MSG_LOG;
 8010c54: 687b         	ldr	r3, [r7, #0x4]
 8010c56: 781b         	ldrb	r3, [r3]
 8010c58: f003 0304    	and	r3, r3, #0x4
 8010c5c: b2db         	uxtb	r3, r3
 8010c5e: 2b00         	cmp	r3, #0x0
 8010c60: bf0c         	ite	eq
 8010c62: 2301         	moveq	r3, #0x1
 8010c64: 2300         	movne	r3, #0x0
 8010c66: b2db         	uxtb	r3, r3
; }
 8010c68: 4618         	mov	r0, r3
 8010c6a: 370c         	adds	r7, #0xc
 8010c6c: 46bd         	mov	sp, r7
 8010c6e: bc80         	pop	{r7}
 8010c70: 4770         	bx	lr

08010c72 <k_msleep>:
; {
 8010c72: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8010c76: b082         	sub	sp, #0x8
 8010c78: af00         	add	r7, sp, #0x0
 8010c7a: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 8010c7c: 6879         	ldr	r1, [r7, #0x4]
 8010c7e: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 8010c82: 17c8         	asrs	r0, r1, #0x1f
 8010c84: 4688         	mov	r8, r1
 8010c86: 4681         	mov	r9, r0
 8010c88: 4640         	mov	r0, r8
 8010c8a: 4649         	mov	r1, r9
 8010c8c: f04f 0400    	mov.w	r4, #0x0
 8010c90: f04f 0500    	mov.w	r5, #0x0
 8010c94: 008d         	lsls	r5, r1, #0x2
 8010c96: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 8010c9a: 0084         	lsls	r4, r0, #0x2
 8010c9c: 4620         	mov	r0, r4
 8010c9e: 4629         	mov	r1, r5
 8010ca0: eb10 0208    	adds.w	r2, r0, r8
 8010ca4: eb41 0309    	adc.w	r3, r1, r9
 8010ca8: eb12 0a02    	adds.w	r10, r2, r2
 8010cac: eb43 0b03    	adc.w	r11, r3, r3
 8010cb0: 4652         	mov	r2, r10
 8010cb2: 465b         	mov	r3, r11
 8010cb4: 4610         	mov	r0, r2
 8010cb6: 4619         	mov	r1, r3
 8010cb8: f000 f823    	bl	0x8010d02 <k_sleep>     @ imm = #0x46
 8010cbc: 4601         	mov	r1, r0
 8010cbe: 460b         	mov	r3, r1
; }
 8010cc0: 4618         	mov	r0, r3
 8010cc2: 3708         	adds	r7, #0x8
 8010cc4: 46bd         	mov	sp, r7
 8010cc6: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08010cca <k_uptime_get>:
; {
 8010cca: b580         	push	{r7, lr}
 8010ccc: af00         	add	r7, sp, #0x0
; 	return k_ticks_to_ms_floor64(k_uptime_ticks());
 8010cce: f000 f826    	bl	0x8010d1e <k_uptime_ticks> @ imm = #0x4c
 8010cd2: 4602         	mov	r2, r0
 8010cd4: 460b         	mov	r3, r1
 8010cd6: 4610         	mov	r0, r2
 8010cd8: 4619         	mov	r1, r3
 8010cda: f04f 020a    	mov.w	r2, #0xa
 8010cde: f04f 0300    	mov.w	r3, #0x0
 8010ce2: f7ef ff07    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x101f2
 8010ce6: 4602         	mov	r2, r0
 8010ce8: 460b         	mov	r3, r1
; }
 8010cea: 4610         	mov	r0, r2
 8010cec: 4619         	mov	r1, r3
 8010cee: bd80         	pop	{r7, pc}

08010cf0 <k_uptime_get_32>:
; {
 8010cf0: b580         	push	{r7, lr}
 8010cf2: af00         	add	r7, sp, #0x0
; 	return (uint32_t)k_uptime_get();
 8010cf4: f7ff ffe9    	bl	0x8010cca <k_uptime_get> @ imm = #-0x2e
 8010cf8: 4602         	mov	r2, r0
 8010cfa: 460b         	mov	r3, r1
 8010cfc: 4613         	mov	r3, r2
; }
 8010cfe: 4618         	mov	r0, r3
 8010d00: bd80         	pop	{r7, pc}

08010d02 <k_sleep>:
; {
 8010d02: b580         	push	{r7, lr}
 8010d04: b082         	sub	sp, #0x8
 8010d06: af00         	add	r7, sp, #0x0
 8010d08: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8010d0c: e9d7 0100    	ldrd	r0, r1, [r7]
 8010d10: f7fd f9b4    	bl	0x800e07c <z_impl_k_sleep> @ imm = #-0x2c98
 8010d14: 4603         	mov	r3, r0
; }
 8010d16: 4618         	mov	r0, r3
 8010d18: 3708         	adds	r7, #0x8
 8010d1a: 46bd         	mov	sp, r7
 8010d1c: bd80         	pop	{r7, pc}

08010d1e <k_uptime_ticks>:
; {
 8010d1e: b580         	push	{r7, lr}
 8010d20: af00         	add	r7, sp, #0x0
; 	return z_impl_k_uptime_ticks();
 8010d22: f007 ff66    	bl	0x8018bf2 <z_impl_k_uptime_ticks> @ imm = #0x7ecc
 8010d26: 4602         	mov	r2, r0
 8010d28: 460b         	mov	r3, r1
; }
 8010d2a: 4610         	mov	r0, r2
 8010d2c: 4619         	mov	r1, r3
 8010d2e: bd80         	pop	{r7, pc}

08010d30 <log_backend_init>:
; {
 8010d30: b580         	push	{r7, lr}
 8010d32: b082         	sub	sp, #0x8
 8010d34: af00         	add	r7, sp, #0x0
 8010d36: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->init) {
 8010d38: 687b         	ldr	r3, [r7, #0x4]
 8010d3a: 681b         	ldr	r3, [r3]
 8010d3c: 68db         	ldr	r3, [r3, #0xc]
 8010d3e: 2b00         	cmp	r3, #0x0
 8010d40: d004         	beq	0x8010d4c <log_backend_init+0x1c> @ imm = #0x8
; 		backend->api->init(backend);
 8010d42: 687b         	ldr	r3, [r7, #0x4]
 8010d44: 681b         	ldr	r3, [r3]
 8010d46: 68db         	ldr	r3, [r3, #0xc]
 8010d48: 6878         	ldr	r0, [r7, #0x4]
 8010d4a: 4798         	blx	r3
; }
 8010d4c: bf00         	nop
 8010d4e: 3708         	adds	r7, #0x8
 8010d50: 46bd         	mov	sp, r7
 8010d52: bd80         	pop	{r7, pc}

08010d54 <log_backend_is_ready>:
; {
 8010d54: b580         	push	{r7, lr}
 8010d56: b082         	sub	sp, #0x8
 8010d58: af00         	add	r7, sp, #0x0
 8010d5a: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->is_ready != NULL) {
 8010d5c: 687b         	ldr	r3, [r7, #0x4]
 8010d5e: 681b         	ldr	r3, [r3]
 8010d60: 691b         	ldr	r3, [r3, #0x10]
 8010d62: 2b00         	cmp	r3, #0x0
 8010d64: d006         	beq	0x8010d74 <log_backend_is_ready+0x20> @ imm = #0xc
; 		return backend->api->is_ready(backend);
 8010d66: 687b         	ldr	r3, [r7, #0x4]
 8010d68: 681b         	ldr	r3, [r3]
 8010d6a: 691b         	ldr	r3, [r3, #0x10]
 8010d6c: 6878         	ldr	r0, [r7, #0x4]
 8010d6e: 4798         	blx	r3
 8010d70: 4603         	mov	r3, r0
 8010d72: e000         	b	0x8010d76 <log_backend_is_ready+0x22> @ imm = #0x0
; 	return 0;
 8010d74: 2300         	movs	r3, #0x0
; }
 8010d76: 4618         	mov	r0, r3
 8010d78: 3708         	adds	r7, #0x8
 8010d7a: 46bd         	mov	sp, r7
 8010d7c: bd80         	pop	{r7, pc}

08010d7e <log_backend_msg_process>:
; {
 8010d7e: b580         	push	{r7, lr}
 8010d80: b082         	sub	sp, #0x8
 8010d82: af00         	add	r7, sp, #0x0
 8010d84: 6078         	str	r0, [r7, #0x4]
 8010d86: 6039         	str	r1, [r7]
; 	backend->api->process(backend, msg);
 8010d88: 687b         	ldr	r3, [r7, #0x4]
 8010d8a: 681b         	ldr	r3, [r3]
 8010d8c: 681b         	ldr	r3, [r3]
 8010d8e: 6839         	ldr	r1, [r7]
 8010d90: 6878         	ldr	r0, [r7, #0x4]
 8010d92: 4798         	blx	r3
; }
 8010d94: bf00         	nop
 8010d96: 3708         	adds	r7, #0x8
 8010d98: 46bd         	mov	sp, r7
 8010d9a: bd80         	pop	{r7, pc}

08010d9c <log_backend_panic>:
; {
 8010d9c: b580         	push	{r7, lr}
 8010d9e: b082         	sub	sp, #0x8
 8010da0: af00         	add	r7, sp, #0x0
 8010da2: 6078         	str	r0, [r7, #0x4]
; 	backend->api->panic(backend);
 8010da4: 687b         	ldr	r3, [r7, #0x4]
 8010da6: 681b         	ldr	r3, [r3]
 8010da8: 689b         	ldr	r3, [r3, #0x8]
 8010daa: 6878         	ldr	r0, [r7, #0x4]
 8010dac: 4798         	blx	r3
; }
 8010dae: bf00         	nop
 8010db0: 3708         	adds	r7, #0x8
 8010db2: 46bd         	mov	sp, r7
 8010db4: bd80         	pop	{r7, pc}

08010db6 <log_backend_is_active>:
; {
 8010db6: b480         	push	{r7}
 8010db8: b083         	sub	sp, #0xc
 8010dba: af00         	add	r7, sp, #0x0
 8010dbc: 6078         	str	r0, [r7, #0x4]
; 	return backend->cb->active;
 8010dbe: 687b         	ldr	r3, [r7, #0x4]
 8010dc0: 685b         	ldr	r3, [r3, #0x4]
 8010dc2: 795b         	ldrb	r3, [r3, #0x5]
; }
 8010dc4: 4618         	mov	r0, r3
 8010dc6: 370c         	adds	r7, #0xc
 8010dc8: 46bd         	mov	sp, r7
 8010dca: bc80         	pop	{r7}
 8010dcc: 4770         	bx	lr

08010dce <dummy_timestamp>:
; {
 8010dce: b480         	push	{r7}
 8010dd0: af00         	add	r7, sp, #0x0
; 	return 0;
 8010dd2: 2300         	movs	r3, #0x0
; }
 8010dd4: 4618         	mov	r0, r3
 8010dd6: 46bd         	mov	sp, r7
 8010dd8: bc80         	pop	{r7}
 8010dda: 4770         	bx	lr

08010ddc <z_log_vprintk>:
; {
 8010ddc: b580         	push	{r7, lr}
 8010dde: b086         	sub	sp, #0x18
 8010de0: af04         	add	r7, sp, #0x10
 8010de2: 6078         	str	r0, [r7, #0x4]
 8010de4: 6039         	str	r1, [r7]
; 	z_log_msg_runtime_vcreate(Z_LOG_LOCAL_DOMAIN_ID, NULL,
 8010de6: 683b         	ldr	r3, [r7]
 8010de8: 9303         	str	r3, [sp, #0xc]
 8010dea: 687b         	ldr	r3, [r7, #0x4]
 8010dec: 9302         	str	r3, [sp, #0x8]
 8010dee: 2300         	movs	r3, #0x0
 8010df0: 9301         	str	r3, [sp, #0x4]
 8010df2: 2300         	movs	r3, #0x0
 8010df4: 9300         	str	r3, [sp]
 8010df6: 2300         	movs	r3, #0x0
 8010df8: 2200         	movs	r2, #0x0
 8010dfa: 2100         	movs	r1, #0x0
 8010dfc: 2000         	movs	r0, #0x0
 8010dfe: f7f1 f9a5    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0xecb6
; }
 8010e02: 3708         	adds	r7, #0x8
 8010e04: 46bd         	mov	sp, r7
 8010e06: bd80         	pop	{r7, pc}

08010e08 <default_lf_get_timestamp>:
; {
 8010e08: b580         	push	{r7, lr}
 8010e0a: af00         	add	r7, sp, #0x0
; 		k_uptime_get() : k_uptime_get_32();
 8010e0c: f7ff ff70    	bl	0x8010cf0 <k_uptime_get_32> @ imm = #-0x120
 8010e10: 4603         	mov	r3, r0
; }
 8010e12: 4618         	mov	r0, r3
 8010e14: bd80         	pop	{r7, pc}

08010e16 <activate_foreach_backend>:
; {
 8010e16: b580         	push	{r7, lr}
 8010e18: b086         	sub	sp, #0x18
 8010e1a: af00         	add	r7, sp, #0x0
 8010e1c: 6078         	str	r0, [r7, #0x4]
; 	uint32_t mask_cpy = mask;
 8010e1e: 687b         	ldr	r3, [r7, #0x4]
 8010e20: 617b         	str	r3, [r7, #0x14]
; 	while (mask_cpy) {
 8010e22: e02b         	b	0x8010e7c <activate_foreach_backend+0x66> @ imm = #0x56
; 		uint32_t i = __builtin_ctz(mask_cpy);
 8010e24: 697b         	ldr	r3, [r7, #0x14]
 8010e26: fa93 f3a3    	rbit	r3, r3
 8010e2a: fab3 f383    	clz	r3, r3
 8010e2e: 613b         	str	r3, [r7, #0x10]
; 		const struct log_backend *backend = log_backend_get(i);
 8010e30: 6938         	ldr	r0, [r7, #0x10]
 8010e32: f7f0 ff57    	bl	0x8001ce4 <log_backend_get> @ imm = #-0xf152
 8010e36: 60f8         	str	r0, [r7, #0xc]
; 		mask_cpy &= ~BIT(i);
 8010e38: 2201         	movs	r2, #0x1
 8010e3a: 693b         	ldr	r3, [r7, #0x10]
 8010e3c: fa02 f303    	lsl.w	r3, r2, r3
 8010e40: 43db         	mvns	r3, r3
 8010e42: 697a         	ldr	r2, [r7, #0x14]
 8010e44: 4013         	ands	r3, r2
 8010e46: 617b         	str	r3, [r7, #0x14]
; 		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
 8010e48: 68fb         	ldr	r3, [r7, #0xc]
 8010e4a: 7b1b         	ldrb	r3, [r3, #0xc]
 8010e4c: 2b00         	cmp	r3, #0x0
 8010e4e: d015         	beq	0x8010e7c <activate_foreach_backend+0x66> @ imm = #0x2a
 8010e50: 68f8         	ldr	r0, [r7, #0xc]
 8010e52: f7ff ff7f    	bl	0x8010d54 <log_backend_is_ready> @ imm = #-0x102
 8010e56: 4603         	mov	r3, r0
 8010e58: 2b00         	cmp	r3, #0x0
 8010e5a: d10f         	bne	0x8010e7c <activate_foreach_backend+0x66> @ imm = #0x1e
; 			mask &= ~BIT(i);
 8010e5c: 2201         	movs	r2, #0x1
 8010e5e: 693b         	ldr	r3, [r7, #0x10]
 8010e60: fa02 f303    	lsl.w	r3, r2, r3
 8010e64: 43db         	mvns	r3, r3
 8010e66: 687a         	ldr	r2, [r7, #0x4]
 8010e68: 4013         	ands	r3, r2
 8010e6a: 607b         	str	r3, [r7, #0x4]
; 					   backend->cb->ctx,
 8010e6c: 68fb         	ldr	r3, [r7, #0xc]
 8010e6e: 685b         	ldr	r3, [r3, #0x4]
; 			log_backend_enable(backend,
 8010e70: 681b         	ldr	r3, [r3]
 8010e72: 2204         	movs	r2, #0x4
 8010e74: 4619         	mov	r1, r3
 8010e76: 68f8         	ldr	r0, [r7, #0xc]
 8010e78: f000 f8c8    	bl	0x801100c <log_backend_enable> @ imm = #0x190
; 	while (mask_cpy) {
 8010e7c: 697b         	ldr	r3, [r7, #0x14]
 8010e7e: 2b00         	cmp	r3, #0x0
 8010e80: d1d0         	bne	0x8010e24 <activate_foreach_backend+0xe> @ imm = #-0x60
; 	return mask;
 8010e82: 687b         	ldr	r3, [r7, #0x4]
; }
 8010e84: 4618         	mov	r0, r3
 8010e86: 3718         	adds	r7, #0x18
 8010e88: 46bd         	mov	sp, r7
 8010e8a: bd80         	pop	{r7, pc}

08010e8c <msg_filter_check>:
; {
 8010e8c: b580         	push	{r7, lr}
 8010e8e: b082         	sub	sp, #0x8
 8010e90: af00         	add	r7, sp, #0x0
 8010e92: 6078         	str	r0, [r7, #0x4]
 8010e94: 6039         	str	r1, [r7]
; 	if (!z_log_item_is_msg(msg)) {
 8010e96: 6838         	ldr	r0, [r7]
 8010e98: f7ff fed8    	bl	0x8010c4c <z_log_item_is_msg> @ imm = #-0x250
 8010e9c: 4603         	mov	r3, r0
 8010e9e: f083 0301    	eor	r3, r3, #0x1
 8010ea2: b2db         	uxtb	r3, r3
 8010ea4: 2b00         	cmp	r3, #0x0
 8010ea6: d001         	beq	0x8010eac <msg_filter_check+0x20> @ imm = #0x2
; 		return true;
 8010ea8: 2301         	movs	r3, #0x1
 8010eaa: e000         	b	0x8010eae <msg_filter_check+0x22> @ imm = #0x0
; 		return true;
 8010eac: 2301         	movs	r3, #0x1
; }
 8010eae: 4618         	mov	r0, r3
 8010eb0: 3708         	adds	r7, #0x8
 8010eb2: 46bd         	mov	sp, r7
 8010eb4: bd80         	pop	{r7, pc}

08010eb6 <msg_commit>:
; {
 8010eb6: b580         	push	{r7, lr}
 8010eb8: b084         	sub	sp, #0x10
 8010eba: af00         	add	r7, sp, #0x0
 8010ebc: 6078         	str	r0, [r7, #0x4]
 8010ebe: 6039         	str	r1, [r7]
; 	union log_msg_generic *m = (union log_msg_generic *)msg;
 8010ec0: 683b         	ldr	r3, [r7]
 8010ec2: 60fb         	str	r3, [r7, #0xc]
; 		msg_process(m);
 8010ec4: 68f8         	ldr	r0, [r7, #0xc]
 8010ec6: f7f0 fff9    	bl	0x8001ebc <msg_process> @ imm = #-0xf00e
; }
 8010eca: 3710         	adds	r7, #0x10
 8010ecc: 46bd         	mov	sp, r7
 8010ece: bd80         	pop	{r7, pc}

08010ed0 <z_log_get_tag>:
; {
 8010ed0: b480         	push	{r7}
 8010ed2: af00         	add	r7, sp, #0x0
; 	return CONFIG_LOG_TAG_MAX_LEN > 0 ? tag : NULL;
 8010ed4: 2300         	movs	r3, #0x0
; }
 8010ed6: 4618         	mov	r0, r3
 8010ed8: 46bd         	mov	sp, r7
 8010eda: bc80         	pop	{r7}
 8010edc: 4770         	bx	lr

08010ede <enable_logger>:
; {
 8010ede: b580         	push	{r7, lr}
 8010ee0: af00         	add	r7, sp, #0x0
; 		(void)z_log_init(false, false);
 8010ee2: 2100         	movs	r1, #0x0
 8010ee4: 2000         	movs	r0, #0x0
 8010ee6: f7f0 ff39    	bl	0x8001d5c <z_log_init>  @ imm = #-0xf18e
; 	return 0;
 8010eea: 2300         	movs	r3, #0x0
; }
 8010eec: 4618         	mov	r0, r3
 8010eee: bd80         	pop	{r7, pc}

08010ef0 <z_log_is_local_domain>:
; {
 8010ef0: b480         	push	{r7}
 8010ef2: b083         	sub	sp, #0xc
 8010ef4: af00         	add	r7, sp, #0x0
 8010ef6: 4603         	mov	r3, r0
 8010ef8: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 8010efa: 2301         	movs	r3, #0x1
; }
 8010efc: 4618         	mov	r0, r3
 8010efe: 370c         	adds	r7, #0xc
 8010f00: 46bd         	mov	sp, r7
 8010f02: bc80         	pop	{r7}
 8010f04: 4770         	bx	lr

08010f06 <log_backend_id_set>:
; {
 8010f06: b480         	push	{r7}
 8010f08: b083         	sub	sp, #0xc
 8010f0a: af00         	add	r7, sp, #0x0
 8010f0c: 6078         	str	r0, [r7, #0x4]
 8010f0e: 460b         	mov	r3, r1
 8010f10: 70fb         	strb	r3, [r7, #0x3]
; 	backend->cb->id = id;
 8010f12: 687b         	ldr	r3, [r7, #0x4]
 8010f14: 685b         	ldr	r3, [r3, #0x4]
 8010f16: 78fa         	ldrb	r2, [r7, #0x3]
 8010f18: 711a         	strb	r2, [r3, #0x4]
; }
 8010f1a: bf00         	nop
 8010f1c: 370c         	adds	r7, #0xc
 8010f1e: 46bd         	mov	sp, r7
 8010f20: bc80         	pop	{r7}
 8010f22: 4770         	bx	lr

08010f24 <log_backend_activate>:
; {
 8010f24: b480         	push	{r7}
 8010f26: b083         	sub	sp, #0xc
 8010f28: af00         	add	r7, sp, #0x0
 8010f2a: 6078         	str	r0, [r7, #0x4]
 8010f2c: 6039         	str	r1, [r7]
; 	backend->cb->ctx = ctx;
 8010f2e: 687b         	ldr	r3, [r7, #0x4]
 8010f30: 685b         	ldr	r3, [r3, #0x4]
 8010f32: 683a         	ldr	r2, [r7]
 8010f34: 601a         	str	r2, [r3]
; 	backend->cb->active = true;
 8010f36: 687b         	ldr	r3, [r7, #0x4]
 8010f38: 685b         	ldr	r3, [r3, #0x4]
 8010f3a: 2201         	movs	r2, #0x1
 8010f3c: 715a         	strb	r2, [r3, #0x5]
; }
 8010f3e: bf00         	nop
 8010f40: 370c         	adds	r7, #0xc
 8010f42: 46bd         	mov	sp, r7
 8010f44: bc80         	pop	{r7}
 8010f46: 4770         	bx	lr

08010f48 <log_link_sources_count>:
; {
 8010f48: b480         	push	{r7}
 8010f4a: b083         	sub	sp, #0xc
 8010f4c: af00         	add	r7, sp, #0x0
 8010f4e: 6078         	str	r0, [r7, #0x4]
 8010f50: 6039         	str	r1, [r7]
; 	return link->ctrl_blk->source_cnt[domain_id];
 8010f52: 687b         	ldr	r3, [r7, #0x4]
 8010f54: 689a         	ldr	r2, [r3, #0x8]
 8010f56: 683b         	ldr	r3, [r7]
 8010f58: 005b         	lsls	r3, r3, #0x1
 8010f5a: 4413         	add	r3, r2
 8010f5c: 889b         	ldrh	r3, [r3, #0x4]
; }
 8010f5e: 4618         	mov	r0, r3
 8010f60: 370c         	adds	r7, #0xc
 8010f62: 46bd         	mov	sp, r7
 8010f64: bc80         	pop	{r7}
 8010f66: 4770         	bx	lr

08010f68 <log_link_get_source_name>:
; {
 8010f68: b590         	push	{r4, r7, lr}
 8010f6a: b087         	sub	sp, #0x1c
 8010f6c: af02         	add	r7, sp, #0x8
 8010f6e: 60f8         	str	r0, [r7, #0xc]
 8010f70: 60b9         	str	r1, [r7, #0x8]
 8010f72: 603b         	str	r3, [r7]
 8010f74: 4613         	mov	r3, r2
 8010f76: 80fb         	strh	r3, [r7, #0x6]
; 	return link->api->get_source_name(link, domain_id, source_id,
 8010f78: 68fb         	ldr	r3, [r7, #0xc]
 8010f7a: 681b         	ldr	r3, [r3]
 8010f7c: 68dc         	ldr	r4, [r3, #0xc]
 8010f7e: 88fa         	ldrh	r2, [r7, #0x6]
 8010f80: 6a3b         	ldr	r3, [r7, #0x20]
 8010f82: 9300         	str	r3, [sp]
 8010f84: 683b         	ldr	r3, [r7]
 8010f86: 68b9         	ldr	r1, [r7, #0x8]
 8010f88: 68f8         	ldr	r0, [r7, #0xc]
 8010f8a: 47a0         	blx	r4
 8010f8c: 4603         	mov	r3, r0
; }
 8010f8e: 4618         	mov	r0, r3
 8010f90: 3714         	adds	r7, #0x14
 8010f92: 46bd         	mov	sp, r7
 8010f94: bd90         	pop	{r4, r7, pc}

08010f96 <link_source_count>:
; {
 8010f96: b580         	push	{r7, lr}
 8010f98: b084         	sub	sp, #0x10
 8010f9a: af00         	add	r7, sp, #0x0
 8010f9c: 4603         	mov	r3, r0
 8010f9e: 71fb         	strb	r3, [r7, #0x7]
; 	const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 8010fa0: f107 020b    	add.w	r2, r7, #0xb
 8010fa4: 79fb         	ldrb	r3, [r7, #0x7]
 8010fa6: 4611         	mov	r1, r2
 8010fa8: 4618         	mov	r0, r3
 8010faa: f7f1 f819    	bl	0x8001fe0 <get_link_domain> @ imm = #-0xefce
 8010fae: 60f8         	str	r0, [r7, #0xc]
; 	return log_link_sources_count(link, rel_domain_id);
 8010fb0: 7afb         	ldrb	r3, [r7, #0xb]
 8010fb2: 4619         	mov	r1, r3
 8010fb4: 68f8         	ldr	r0, [r7, #0xc]
 8010fb6: f7ff ffc7    	bl	0x8010f48 <log_link_sources_count> @ imm = #-0x72
 8010fba: 4603         	mov	r3, r0
; }
 8010fbc: 4618         	mov	r0, r3
 8010fbe: 3710         	adds	r7, #0x10
 8010fc0: 46bd         	mov	sp, r7
 8010fc2: bd80         	pop	{r7, pc}

08010fc4 <log_src_cnt_get>:
; {
 8010fc4: b580         	push	{r7, lr}
 8010fc6: b082         	sub	sp, #0x8
 8010fc8: af00         	add	r7, sp, #0x0
 8010fca: 6078         	str	r0, [r7, #0x4]
; 	if (z_log_is_local_domain(domain_id)) {
 8010fcc: 687b         	ldr	r3, [r7, #0x4]
 8010fce: b2db         	uxtb	r3, r3
 8010fd0: 4618         	mov	r0, r3
 8010fd2: f7ff ff8d    	bl	0x8010ef0 <z_log_is_local_domain> @ imm = #-0xe6
 8010fd6: 4603         	mov	r3, r0
 8010fd8: 2b00         	cmp	r3, #0x0
 8010fda: d003         	beq	0x8010fe4 <log_src_cnt_get+0x20> @ imm = #0x6
; 		return z_log_sources_count();
 8010fdc: f7f0 ffe4    	bl	0x8001fa8 <z_log_sources_count> @ imm = #-0xf038
 8010fe0: 4603         	mov	r3, r0
 8010fe2: e005         	b	0x8010ff0 <log_src_cnt_get+0x2c> @ imm = #0xa
; 	return link_source_count(domain_id);
 8010fe4: 687b         	ldr	r3, [r7, #0x4]
 8010fe6: b2db         	uxtb	r3, r3
 8010fe8: 4618         	mov	r0, r3
 8010fea: f7ff ffd4    	bl	0x8010f96 <link_source_count> @ imm = #-0x58
 8010fee: 4603         	mov	r3, r0
; }
 8010ff0: 4618         	mov	r0, r3
 8010ff2: 3708         	adds	r7, #0x8
 8010ff4: 46bd         	mov	sp, r7
 8010ff6: bd80         	pop	{r7, pc}

08010ff8 <backend_filter_set>:
; {
 8010ff8: b480         	push	{r7}
 8010ffa: b083         	sub	sp, #0xc
 8010ffc: af00         	add	r7, sp, #0x0
 8010ffe: 6078         	str	r0, [r7, #0x4]
 8011000: 6039         	str	r1, [r7]
; 		return;
 8011002: bf00         	nop
; }
 8011004: 370c         	adds	r7, #0xc
 8011006: 46bd         	mov	sp, r7
 8011008: bc80         	pop	{r7}
 801100a: 4770         	bx	lr

0801100c <log_backend_enable>:
; {
 801100c: b580         	push	{r7, lr}
 801100e: b086         	sub	sp, #0x18
 8011010: af00         	add	r7, sp, #0x0
 8011012: 60f8         	str	r0, [r7, #0xc]
 8011014: 60b9         	str	r1, [r7, #0x8]
 8011016: 607a         	str	r2, [r7, #0x4]
; 	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;
 8011018: 2301         	movs	r3, #0x1
 801101a: 617b         	str	r3, [r7, #0x14]
; 	id += backend - log_backend_get(0);
 801101c: 2000         	movs	r0, #0x0
 801101e: f7f0 ffcd    	bl	0x8001fbc <log_backend_get> @ imm = #-0xf066
 8011022: 4602         	mov	r2, r0
 8011024: 68fb         	ldr	r3, [r7, #0xc]
 8011026: 1a9b         	subs	r3, r3, r2
 8011028: 111b         	asrs	r3, r3, #0x4
 801102a: 461a         	mov	r2, r3
 801102c: 697b         	ldr	r3, [r7, #0x14]
 801102e: 4413         	add	r3, r2
 8011030: 617b         	str	r3, [r7, #0x14]
; 	log_backend_id_set(backend, id);
 8011032: 697b         	ldr	r3, [r7, #0x14]
 8011034: b2db         	uxtb	r3, r3
 8011036: 4619         	mov	r1, r3
 8011038: 68f8         	ldr	r0, [r7, #0xc]
 801103a: f7ff ff64    	bl	0x8010f06 <log_backend_id_set> @ imm = #-0x138
; 	backend->cb->level = level;
 801103e: 68fb         	ldr	r3, [r7, #0xc]
 8011040: 685b         	ldr	r3, [r3, #0x4]
 8011042: 687a         	ldr	r2, [r7, #0x4]
 8011044: b2d2         	uxtb	r2, r2
 8011046: 719a         	strb	r2, [r3, #0x6]
; 	backend_filter_set(backend, level);
 8011048: 6879         	ldr	r1, [r7, #0x4]
 801104a: 68f8         	ldr	r0, [r7, #0xc]
 801104c: f7ff ffd4    	bl	0x8010ff8 <backend_filter_set> @ imm = #-0x58
; 	log_backend_activate(backend, ctx);
 8011050: 68b9         	ldr	r1, [r7, #0x8]
 8011052: 68f8         	ldr	r0, [r7, #0xc]
 8011054: f7ff ff66    	bl	0x8010f24 <log_backend_activate> @ imm = #-0x134
; 	z_log_notify_backend_enabled();
 8011058: f7f0 ff5e    	bl	0x8001f18 <z_log_notify_backend_enabled> @ imm = #-0xf144
; }
 801105c: bf00         	nop
 801105e: 3718         	adds	r7, #0x18
 8011060: 46bd         	mov	sp, r7
 8011062: bd80         	pop	{r7, pc}

08011064 <z_snode_next_peek>:
; {
 8011064: b480         	push	{r7}
 8011066: b083         	sub	sp, #0xc
 8011068: af00         	add	r7, sp, #0x0
 801106a: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 801106c: 687b         	ldr	r3, [r7, #0x4]
 801106e: 681b         	ldr	r3, [r3]
; }
 8011070: 4618         	mov	r0, r3
 8011072: 370c         	adds	r7, #0xc
 8011074: 46bd         	mov	sp, r7
 8011076: bc80         	pop	{r7}
 8011078: 4770         	bx	lr

0801107a <z_snode_next_set>:
; {
 801107a: b480         	push	{r7}
 801107c: b083         	sub	sp, #0xc
 801107e: af00         	add	r7, sp, #0x0
 8011080: 6078         	str	r0, [r7, #0x4]
 8011082: 6039         	str	r1, [r7]
; 	parent->next = child;
 8011084: 687b         	ldr	r3, [r7, #0x4]
 8011086: 683a         	ldr	r2, [r7]
 8011088: 601a         	str	r2, [r3]
; }
 801108a: bf00         	nop
 801108c: 370c         	adds	r7, #0xc
 801108e: 46bd         	mov	sp, r7
 8011090: bc80         	pop	{r7}
 8011092: 4770         	bx	lr

08011094 <z_slist_head_set>:
; {
 8011094: b480         	push	{r7}
 8011096: b083         	sub	sp, #0xc
 8011098: af00         	add	r7, sp, #0x0
 801109a: 6078         	str	r0, [r7, #0x4]
 801109c: 6039         	str	r1, [r7]
; 	list->head = node;
 801109e: 687b         	ldr	r3, [r7, #0x4]
 80110a0: 683a         	ldr	r2, [r7]
 80110a2: 601a         	str	r2, [r3]
; }
 80110a4: bf00         	nop
 80110a6: 370c         	adds	r7, #0xc
 80110a8: 46bd         	mov	sp, r7
 80110aa: bc80         	pop	{r7}
 80110ac: 4770         	bx	lr

080110ae <z_slist_tail_set>:
; {
 80110ae: b480         	push	{r7}
 80110b0: b083         	sub	sp, #0xc
 80110b2: af00         	add	r7, sp, #0x0
 80110b4: 6078         	str	r0, [r7, #0x4]
 80110b6: 6039         	str	r1, [r7]
; 	list->tail = node;
 80110b8: 687b         	ldr	r3, [r7, #0x4]
 80110ba: 683a         	ldr	r2, [r7]
 80110bc: 605a         	str	r2, [r3, #0x4]
; }
 80110be: bf00         	nop
 80110c0: 370c         	adds	r7, #0xc
 80110c2: 46bd         	mov	sp, r7
 80110c4: bc80         	pop	{r7}
 80110c6: 4770         	bx	lr

080110c8 <sys_slist_peek_head>:
; {
 80110c8: b480         	push	{r7}
 80110ca: b083         	sub	sp, #0xc
 80110cc: af00         	add	r7, sp, #0x0
 80110ce: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 80110d0: 687b         	ldr	r3, [r7, #0x4]
 80110d2: 681b         	ldr	r3, [r3]
; }
 80110d4: 4618         	mov	r0, r3
 80110d6: 370c         	adds	r7, #0xc
 80110d8: 46bd         	mov	sp, r7
 80110da: bc80         	pop	{r7}
 80110dc: 4770         	bx	lr

080110de <sys_slist_peek_tail>:
; {
 80110de: b480         	push	{r7}
 80110e0: b083         	sub	sp, #0xc
 80110e2: af00         	add	r7, sp, #0x0
 80110e4: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 80110e6: 687b         	ldr	r3, [r7, #0x4]
 80110e8: 685b         	ldr	r3, [r3, #0x4]
; }
 80110ea: 4618         	mov	r0, r3
 80110ec: 370c         	adds	r7, #0xc
 80110ee: 46bd         	mov	sp, r7
 80110f0: bc80         	pop	{r7}
 80110f2: 4770         	bx	lr

080110f4 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 80110f4: b580         	push	{r7, lr}
 80110f6: b082         	sub	sp, #0x8
 80110f8: af00         	add	r7, sp, #0x0
 80110fa: 6078         	str	r0, [r7, #0x4]
 80110fc: 6878         	ldr	r0, [r7, #0x4]
 80110fe: f7ff ffe3    	bl	0x80110c8 <sys_slist_peek_head> @ imm = #-0x3a
 8011102: 4603         	mov	r3, r0
 8011104: 2b00         	cmp	r3, #0x0
 8011106: bf0c         	ite	eq
 8011108: 2301         	moveq	r3, #0x1
 801110a: 2300         	movne	r3, #0x0
 801110c: b2db         	uxtb	r3, r3
 801110e: 4618         	mov	r0, r3
 8011110: 3708         	adds	r7, #0x8
 8011112: 46bd         	mov	sp, r7
 8011114: bd80         	pop	{r7, pc}

08011116 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8011116: b580         	push	{r7, lr}
 8011118: b082         	sub	sp, #0x8
 801111a: af00         	add	r7, sp, #0x0
 801111c: 6078         	str	r0, [r7, #0x4]
 801111e: 6878         	ldr	r0, [r7, #0x4]
 8011120: f7ff ffa0    	bl	0x8011064 <z_snode_next_peek> @ imm = #-0xc0
 8011124: 4603         	mov	r3, r0
 8011126: 4618         	mov	r0, r3
 8011128: 3708         	adds	r7, #0x8
 801112a: 46bd         	mov	sp, r7
 801112c: bd80         	pop	{r7, pc}

0801112e <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 801112e: b580         	push	{r7, lr}
 8011130: b082         	sub	sp, #0x8
 8011132: af00         	add	r7, sp, #0x0
 8011134: 6078         	str	r0, [r7, #0x4]
 8011136: 687b         	ldr	r3, [r7, #0x4]
 8011138: 2b00         	cmp	r3, #0x0
 801113a: d004         	beq	0x8011146 <sys_slist_peek_next+0x18> @ imm = #0x8
 801113c: 6878         	ldr	r0, [r7, #0x4]
 801113e: f7ff ffea    	bl	0x8011116 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 8011142: 4603         	mov	r3, r0
 8011144: e000         	b	0x8011148 <sys_slist_peek_next+0x1a> @ imm = #0x0
 8011146: 2300         	movs	r3, #0x0
 8011148: 4618         	mov	r0, r3
 801114a: 3708         	adds	r7, #0x8
 801114c: 46bd         	mov	sp, r7
 801114e: bd80         	pop	{r7, pc}

08011150 <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 8011150: b580         	push	{r7, lr}
 8011152: b082         	sub	sp, #0x8
 8011154: af00         	add	r7, sp, #0x0
 8011156: 6078         	str	r0, [r7, #0x4]
 8011158: 6039         	str	r1, [r7]
 801115a: 6878         	ldr	r0, [r7, #0x4]
 801115c: f7ff ffb4    	bl	0x80110c8 <sys_slist_peek_head> @ imm = #-0x98
 8011160: 4603         	mov	r3, r0
 8011162: 4619         	mov	r1, r3
 8011164: 6838         	ldr	r0, [r7]
 8011166: f7ff ff88    	bl	0x801107a <z_snode_next_set> @ imm = #-0xf0
 801116a: 6839         	ldr	r1, [r7]
 801116c: 6878         	ldr	r0, [r7, #0x4]
 801116e: f7ff ff91    	bl	0x8011094 <z_slist_head_set> @ imm = #-0xde
 8011172: 6878         	ldr	r0, [r7, #0x4]
 8011174: f7ff ffb3    	bl	0x80110de <sys_slist_peek_tail> @ imm = #-0x9a
 8011178: 4603         	mov	r3, r0
 801117a: 2b00         	cmp	r3, #0x0
 801117c: d107         	bne	0x801118e <sys_slist_prepend+0x3e> @ imm = #0xe
 801117e: 6878         	ldr	r0, [r7, #0x4]
 8011180: f7ff ffa2    	bl	0x80110c8 <sys_slist_peek_head> @ imm = #-0xbc
 8011184: 4603         	mov	r3, r0
 8011186: 4619         	mov	r1, r3
 8011188: 6878         	ldr	r0, [r7, #0x4]
 801118a: f7ff ff90    	bl	0x80110ae <z_slist_tail_set> @ imm = #-0xe0
 801118e: 3708         	adds	r7, #0x8
 8011190: 46bd         	mov	sp, r7
 8011192: bd80         	pop	{r7, pc}

08011194 <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 8011194: b580         	push	{r7, lr}
 8011196: b084         	sub	sp, #0x10
 8011198: af00         	add	r7, sp, #0x0
 801119a: 6078         	str	r0, [r7, #0x4]
 801119c: 6878         	ldr	r0, [r7, #0x4]
 801119e: f7ff ff93    	bl	0x80110c8 <sys_slist_peek_head> @ imm = #-0xda
 80111a2: 60f8         	str	r0, [r7, #0xc]
 80111a4: 68f8         	ldr	r0, [r7, #0xc]
 80111a6: f7ff ff5d    	bl	0x8011064 <z_snode_next_peek> @ imm = #-0x146
 80111aa: 4603         	mov	r3, r0
 80111ac: 4619         	mov	r1, r3
 80111ae: 6878         	ldr	r0, [r7, #0x4]
 80111b0: f7ff ff70    	bl	0x8011094 <z_slist_head_set> @ imm = #-0x120
 80111b4: 6878         	ldr	r0, [r7, #0x4]
 80111b6: f7ff ff92    	bl	0x80110de <sys_slist_peek_tail> @ imm = #-0xdc
 80111ba: 4602         	mov	r2, r0
 80111bc: 68fb         	ldr	r3, [r7, #0xc]
 80111be: 4293         	cmp	r3, r2
 80111c0: d107         	bne	0x80111d2 <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 80111c2: 6878         	ldr	r0, [r7, #0x4]
 80111c4: f7ff ff80    	bl	0x80110c8 <sys_slist_peek_head> @ imm = #-0x100
 80111c8: 4603         	mov	r3, r0
 80111ca: 4619         	mov	r1, r3
 80111cc: 6878         	ldr	r0, [r7, #0x4]
 80111ce: f7ff ff6e    	bl	0x80110ae <z_slist_tail_set> @ imm = #-0x124
 80111d2: 68fb         	ldr	r3, [r7, #0xc]
 80111d4: 4618         	mov	r0, r3
 80111d6: 3710         	adds	r7, #0x10
 80111d8: 46bd         	mov	sp, r7
 80111da: bd80         	pop	{r7, pc}

080111dc <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 80111dc: b580         	push	{r7, lr}
 80111de: b082         	sub	sp, #0x8
 80111e0: af00         	add	r7, sp, #0x0
 80111e2: 6078         	str	r0, [r7, #0x4]
 80111e4: 6878         	ldr	r0, [r7, #0x4]
 80111e6: f7ff ff85    	bl	0x80110f4 <sys_slist_is_empty> @ imm = #-0xf6
 80111ea: 4603         	mov	r3, r0
 80111ec: 2b00         	cmp	r3, #0x0
 80111ee: d104         	bne	0x80111fa <sys_slist_get+0x1e> @ imm = #0x8
 80111f0: 6878         	ldr	r0, [r7, #0x4]
 80111f2: f7ff ffcf    	bl	0x8011194 <sys_slist_get_not_empty> @ imm = #-0x62
 80111f6: 4603         	mov	r3, r0
 80111f8: e000         	b	0x80111fc <sys_slist_get+0x20> @ imm = #0x0
 80111fa: 2300         	movs	r3, #0x0
 80111fc: 4618         	mov	r0, r3
 80111fe: 3708         	adds	r7, #0x8
 8011200: 46bd         	mov	sp, r7
 8011202: bd80         	pop	{r7, pc}

08011204 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 8011204: b580         	push	{r7, lr}
 8011206: b084         	sub	sp, #0x10
 8011208: af00         	add	r7, sp, #0x0
 801120a: 60f8         	str	r0, [r7, #0xc]
 801120c: 60b9         	str	r1, [r7, #0x8]
 801120e: 607a         	str	r2, [r7, #0x4]
 8011210: 68bb         	ldr	r3, [r7, #0x8]
 8011212: 2b00         	cmp	r3, #0x0
 8011214: d117         	bne	0x8011246 <sys_slist_remove+0x42> @ imm = #0x2e
 8011216: 6878         	ldr	r0, [r7, #0x4]
 8011218: f7ff ff24    	bl	0x8011064 <z_snode_next_peek> @ imm = #-0x1b8
 801121c: 4603         	mov	r3, r0
 801121e: 4619         	mov	r1, r3
 8011220: 68f8         	ldr	r0, [r7, #0xc]
 8011222: f7ff ff37    	bl	0x8011094 <z_slist_head_set> @ imm = #-0x192
 8011226: 68f8         	ldr	r0, [r7, #0xc]
 8011228: f7ff ff59    	bl	0x80110de <sys_slist_peek_tail> @ imm = #-0x14e
 801122c: 4602         	mov	r2, r0
 801122e: 687b         	ldr	r3, [r7, #0x4]
 8011230: 4293         	cmp	r3, r2
 8011232: d11b         	bne	0x801126c <sys_slist_remove+0x68> @ imm = #0x36
 8011234: 68f8         	ldr	r0, [r7, #0xc]
 8011236: f7ff ff47    	bl	0x80110c8 <sys_slist_peek_head> @ imm = #-0x172
 801123a: 4603         	mov	r3, r0
 801123c: 4619         	mov	r1, r3
 801123e: 68f8         	ldr	r0, [r7, #0xc]
 8011240: f7ff ff35    	bl	0x80110ae <z_slist_tail_set> @ imm = #-0x196
 8011244: e012         	b	0x801126c <sys_slist_remove+0x68> @ imm = #0x24
 8011246: 6878         	ldr	r0, [r7, #0x4]
 8011248: f7ff ff0c    	bl	0x8011064 <z_snode_next_peek> @ imm = #-0x1e8
 801124c: 4603         	mov	r3, r0
 801124e: 4619         	mov	r1, r3
 8011250: 68b8         	ldr	r0, [r7, #0x8]
 8011252: f7ff ff12    	bl	0x801107a <z_snode_next_set> @ imm = #-0x1dc
 8011256: 68f8         	ldr	r0, [r7, #0xc]
 8011258: f7ff ff41    	bl	0x80110de <sys_slist_peek_tail> @ imm = #-0x17e
 801125c: 4602         	mov	r2, r0
 801125e: 687b         	ldr	r3, [r7, #0x4]
 8011260: 4293         	cmp	r3, r2
 8011262: d103         	bne	0x801126c <sys_slist_remove+0x68> @ imm = #0x6
 8011264: 68b9         	ldr	r1, [r7, #0x8]
 8011266: 68f8         	ldr	r0, [r7, #0xc]
 8011268: f7ff ff21    	bl	0x80110ae <z_slist_tail_set> @ imm = #-0x1be
 801126c: 2100         	movs	r1, #0x0
 801126e: 6878         	ldr	r0, [r7, #0x4]
 8011270: f7ff ff03    	bl	0x801107a <z_snode_next_set> @ imm = #-0x1fa
 8011274: 3710         	adds	r7, #0x10
 8011276: 46bd         	mov	sp, r7
 8011278: bd80         	pop	{r7, pc}

0801127a <log_cache_get>:
; {
 801127a: b590         	push	{r4, r7, lr}
 801127c: b089         	sub	sp, #0x24
 801127e: af00         	add	r7, sp, #0x0
 8011280: 60f8         	str	r0, [r7, #0xc]
 8011282: 60b9         	str	r1, [r7, #0x8]
 8011284: 607a         	str	r2, [r7, #0x4]
; 	sys_snode_t *prev_node = NULL;
 8011286: 2300         	movs	r3, #0x0
 8011288: 61fb         	str	r3, [r7, #0x1c]
; 	bool hit = false;
 801128a: 2300         	movs	r3, #0x0
 801128c: 75fb         	strb	r3, [r7, #0x17]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 801128e: 68fb         	ldr	r3, [r7, #0xc]
 8011290: 4618         	mov	r0, r3
 8011292: f7ff ff19    	bl	0x80110c8 <sys_slist_peek_head> @ imm = #-0x1ce
 8011296: 4603         	mov	r3, r0
 8011298: 2b00         	cmp	r3, #0x0
 801129a: d005         	beq	0x80112a8 <log_cache_get+0x2e> @ imm = #0xa
 801129c: 68fb         	ldr	r3, [r7, #0xc]
 801129e: 4618         	mov	r0, r3
 80112a0: f7ff ff12    	bl	0x80110c8 <sys_slist_peek_head> @ imm = #-0x1dc
 80112a4: 4603         	mov	r3, r0
 80112a6: e000         	b	0x80112aa <log_cache_get+0x30> @ imm = #0x0
 80112a8: 2300         	movs	r3, #0x0
 80112aa: 61bb         	str	r3, [r7, #0x18]
 80112ac: e02f         	b	0x801130e <log_cache_get+0x94> @ imm = #0x5e
; 		if (cache->cmp(entry->id, id)) {
 80112ae: 68fb         	ldr	r3, [r7, #0xc]
 80112b0: 691b         	ldr	r3, [r3, #0x10]
 80112b2: 69ba         	ldr	r2, [r7, #0x18]
 80112b4: 6852         	ldr	r2, [r2, #0x4]
 80112b6: 68b9         	ldr	r1, [r7, #0x8]
 80112b8: 4610         	mov	r0, r2
 80112ba: 4798         	blx	r3
 80112bc: 4603         	mov	r3, r0
 80112be: 2b00         	cmp	r3, #0x0
 80112c0: d007         	beq	0x80112d2 <log_cache_get+0x58> @ imm = #0xe
; 			cache->hit++;
 80112c2: 68fb         	ldr	r3, [r7, #0xc]
 80112c4: 695b         	ldr	r3, [r3, #0x14]
 80112c6: 1c5a         	adds	r2, r3, #0x1
 80112c8: 68fb         	ldr	r3, [r7, #0xc]
 80112ca: 615a         	str	r2, [r3, #0x14]
; 			hit = true;
 80112cc: 2301         	movs	r3, #0x1
 80112ce: 75fb         	strb	r3, [r7, #0x17]
; 			break;
 80112d0: e022         	b	0x8011318 <log_cache_get+0x9e> @ imm = #0x44
; 		if (&entry->node == sys_slist_peek_tail(&cache->active)) {
 80112d2: 69bc         	ldr	r4, [r7, #0x18]
 80112d4: 68fb         	ldr	r3, [r7, #0xc]
 80112d6: 4618         	mov	r0, r3
 80112d8: f7ff ff01    	bl	0x80110de <sys_slist_peek_tail> @ imm = #-0x1fe
 80112dc: 4603         	mov	r3, r0
 80112de: 429c         	cmp	r4, r3
 80112e0: d019         	beq	0x8011316 <log_cache_get+0x9c> @ imm = #0x32
; 		prev_node = &entry->node;
 80112e2: 69bb         	ldr	r3, [r7, #0x18]
 80112e4: 61fb         	str	r3, [r7, #0x1c]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 80112e6: 69bb         	ldr	r3, [r7, #0x18]
 80112e8: 2b00         	cmp	r3, #0x0
 80112ea: d00e         	beq	0x801130a <log_cache_get+0x90> @ imm = #0x1c
 80112ec: 69bb         	ldr	r3, [r7, #0x18]
 80112ee: 4618         	mov	r0, r3
 80112f0: f7ff ff1d    	bl	0x801112e <sys_slist_peek_next> @ imm = #-0x1c6
 80112f4: 4603         	mov	r3, r0
 80112f6: 2b00         	cmp	r3, #0x0
 80112f8: d005         	beq	0x8011306 <log_cache_get+0x8c> @ imm = #0xa
 80112fa: 69bb         	ldr	r3, [r7, #0x18]
 80112fc: 4618         	mov	r0, r3
 80112fe: f7ff ff16    	bl	0x801112e <sys_slist_peek_next> @ imm = #-0x1d4
 8011302: 4603         	mov	r3, r0
 8011304: e002         	b	0x801130c <log_cache_get+0x92> @ imm = #0x4
 8011306: 2300         	movs	r3, #0x0
 8011308: e000         	b	0x801130c <log_cache_get+0x92> @ imm = #0x0
 801130a: 2300         	movs	r3, #0x0
 801130c: 61bb         	str	r3, [r7, #0x18]
 801130e: 69bb         	ldr	r3, [r7, #0x18]
 8011310: 2b00         	cmp	r3, #0x0
 8011312: d1cc         	bne	0x80112ae <log_cache_get+0x34> @ imm = #-0x68
 8011314: e000         	b	0x8011318 <log_cache_get+0x9e> @ imm = #0x0
; 			break;
 8011316: bf00         	nop
; 	if (hit) {
 8011318: 7dfb         	ldrb	r3, [r7, #0x17]
 801131a: 2b00         	cmp	r3, #0x0
 801131c: d00c         	beq	0x8011338 <log_cache_get+0xbe> @ imm = #0x18
; 		sys_slist_remove(&cache->active, prev_node, &entry->node);
 801131e: 68fb         	ldr	r3, [r7, #0xc]
 8011320: 69ba         	ldr	r2, [r7, #0x18]
 8011322: 69f9         	ldr	r1, [r7, #0x1c]
 8011324: 4618         	mov	r0, r3
 8011326: f7ff ff6d    	bl	0x8011204 <sys_slist_remove> @ imm = #-0x126
; 		sys_slist_prepend(&cache->active, &entry->node);
 801132a: 68fb         	ldr	r3, [r7, #0xc]
 801132c: 69ba         	ldr	r2, [r7, #0x18]
 801132e: 4611         	mov	r1, r2
 8011330: 4618         	mov	r0, r3
 8011332: f7ff ff0d    	bl	0x8011150 <sys_slist_prepend> @ imm = #-0x1e6
 8011336: e016         	b	0x8011366 <log_cache_get+0xec> @ imm = #0x2c
; 		cache->miss++;
 8011338: 68fb         	ldr	r3, [r7, #0xc]
 801133a: 699b         	ldr	r3, [r3, #0x18]
 801133c: 1c5a         	adds	r2, r3, #0x1
 801133e: 68fb         	ldr	r3, [r7, #0xc]
 8011340: 619a         	str	r2, [r3, #0x18]
; 		sys_snode_t *from_idle = sys_slist_get(&cache->idle);
 8011342: 68fb         	ldr	r3, [r7, #0xc]
 8011344: 3308         	adds	r3, #0x8
 8011346: 4618         	mov	r0, r3
 8011348: f7ff ff48    	bl	0x80111dc <sys_slist_get> @ imm = #-0x170
 801134c: 6138         	str	r0, [r7, #0x10]
; 		if (from_idle) {
 801134e: 693b         	ldr	r3, [r7, #0x10]
 8011350: 2b00         	cmp	r3, #0x0
 8011352: d002         	beq	0x801135a <log_cache_get+0xe0> @ imm = #0x4
; 			entry = CONTAINER_OF(from_idle, struct log_cache_entry, node);
 8011354: 693b         	ldr	r3, [r7, #0x10]
 8011356: 61bb         	str	r3, [r7, #0x18]
 8011358: e005         	b	0x8011366 <log_cache_get+0xec> @ imm = #0xa
; 			sys_slist_remove(&cache->active, prev_node, &entry->node);
 801135a: 68fb         	ldr	r3, [r7, #0xc]
 801135c: 69ba         	ldr	r2, [r7, #0x18]
 801135e: 69f9         	ldr	r1, [r7, #0x1c]
 8011360: 4618         	mov	r0, r3
 8011362: f7ff ff4f    	bl	0x8011204 <sys_slist_remove> @ imm = #-0x162
; 	*data = entry->data;
 8011366: 69bb         	ldr	r3, [r7, #0x18]
 8011368: f103 0208    	add.w	r2, r3, #0x8
 801136c: 687b         	ldr	r3, [r7, #0x4]
 801136e: 601a         	str	r2, [r3]
; 	entry->id = id;
 8011370: 69bb         	ldr	r3, [r7, #0x18]
 8011372: 68ba         	ldr	r2, [r7, #0x8]
 8011374: 605a         	str	r2, [r3, #0x4]
; 	return hit;
 8011376: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 8011378: 4618         	mov	r0, r3
 801137a: 3724         	adds	r7, #0x24
 801137c: 46bd         	mov	sp, r7
 801137e: bd90         	pop	{r4, r7, pc}

08011380 <log_cache_put>:
; {
 8011380: b580         	push	{r7, lr}
 8011382: b084         	sub	sp, #0x10
 8011384: af00         	add	r7, sp, #0x0
 8011386: 6078         	str	r0, [r7, #0x4]
 8011388: 6039         	str	r1, [r7]
; 	struct log_cache_entry *entry = CONTAINER_OF(data, struct log_cache_entry, data[0]);
 801138a: 683b         	ldr	r3, [r7]
 801138c: 3b08         	subs	r3, #0x8
 801138e: 60fb         	str	r3, [r7, #0xc]
; 	sys_slist_prepend(&cache->active, &entry->node);
 8011390: 687b         	ldr	r3, [r7, #0x4]
 8011392: 68fa         	ldr	r2, [r7, #0xc]
 8011394: 4611         	mov	r1, r2
 8011396: 4618         	mov	r0, r3
 8011398: f7ff feda    	bl	0x8011150 <sys_slist_prepend> @ imm = #-0x24c
; }
 801139c: bf00         	nop
 801139e: 3710         	adds	r7, #0x10
 80113a0: 46bd         	mov	sp, r7
 80113a2: bd80         	pop	{r7, pc}

080113a4 <z_log_msg_runtime_create>:
; {
 80113a4: b580         	push	{r7, lr}
 80113a6: b08a         	sub	sp, #0x28
 80113a8: af04         	add	r7, sp, #0x10
 80113aa: 60b9         	str	r1, [r7, #0x8]
 80113ac: 607b         	str	r3, [r7, #0x4]
 80113ae: 4603         	mov	r3, r0
 80113b0: 73fb         	strb	r3, [r7, #0xf]
 80113b2: 4613         	mov	r3, r2
 80113b4: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80113b6: f107 032c    	add.w	r3, r7, #0x2c
 80113ba: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80113bc: 7bba         	ldrb	r2, [r7, #0xe]
 80113be: 7bf8         	ldrb	r0, [r7, #0xf]
 80113c0: 697b         	ldr	r3, [r7, #0x14]
 80113c2: 9303         	str	r3, [sp, #0xc]
 80113c4: 6abb         	ldr	r3, [r7, #0x28]
 80113c6: 9302         	str	r3, [sp, #0x8]
 80113c8: 6a7b         	ldr	r3, [r7, #0x24]
 80113ca: 9301         	str	r3, [sp, #0x4]
 80113cc: 6a3b         	ldr	r3, [r7, #0x20]
 80113ce: 9300         	str	r3, [sp]
 80113d0: 687b         	ldr	r3, [r7, #0x4]
 80113d2: 68b9         	ldr	r1, [r7, #0x8]
 80113d4: f7f0 feba    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0xf28c
; }
 80113d8: bf00         	nop
 80113da: 3718         	adds	r7, #0x18
 80113dc: 46bd         	mov	sp, r7
 80113de: bd80         	pop	{r7, pc}

080113e0 <log_msg_get_domain>:
; {
 80113e0: b480         	push	{r7}
 80113e2: b083         	sub	sp, #0xc
 80113e4: af00         	add	r7, sp, #0x0
 80113e6: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 80113e8: 687b         	ldr	r3, [r7, #0x4]
 80113ea: 781b         	ldrb	r3, [r3]
 80113ec: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 80113f0: b2db         	uxtb	r3, r3
; }
 80113f2: 4618         	mov	r0, r3
 80113f4: 370c         	adds	r7, #0xc
 80113f6: 46bd         	mov	sp, r7
 80113f8: bc80         	pop	{r7}
 80113fa: 4770         	bx	lr

080113fc <log_msg_get_source>:
; {
 80113fc: b480         	push	{r7}
 80113fe: b083         	sub	sp, #0xc
 8011400: af00         	add	r7, sp, #0x0
 8011402: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.source;
 8011404: 687b         	ldr	r3, [r7, #0x4]
 8011406: 685b         	ldr	r3, [r3, #0x4]
; }
 8011408: 4618         	mov	r0, r3
 801140a: 370c         	adds	r7, #0xc
 801140c: 46bd         	mov	sp, r7
 801140e: bc80         	pop	{r7}
 8011410: 4770         	bx	lr

08011412 <log_source_id>:
; {
 8011412: b580         	push	{r7, lr}
 8011414: b082         	sub	sp, #0x8
 8011416: af00         	add	r7, sp, #0x0
 8011418: 6078         	str	r0, [r7, #0x4]
; 		log_dynamic_source_id((struct log_source_dynamic_data *)source) :
 801141a: 6878         	ldr	r0, [r7, #0x4]
 801141c: f7f0 fe86    	bl	0x800212c <log_const_source_id> @ imm = #-0xf2f4
 8011420: 4603         	mov	r3, r0
; }
 8011422: 4618         	mov	r0, r3
 8011424: 3708         	adds	r7, #0x8
 8011426: 46bd         	mov	sp, r7
 8011428: bd80         	pop	{r7, pc}

0801142a <z_log_is_local_domain>:
; {
 801142a: b480         	push	{r7}
 801142c: b083         	sub	sp, #0xc
 801142e: af00         	add	r7, sp, #0x0
 8011430: 4603         	mov	r3, r0
 8011432: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 8011434: 2301         	movs	r3, #0x1
; }
 8011436: 4618         	mov	r0, r3
 8011438: 370c         	adds	r7, #0xc
 801143a: 46bd         	mov	sp, r7
 801143c: bc80         	pop	{r7}
 801143e: 4770         	bx	lr

08011440 <z_log_msg_finalize>:
; {
 8011440: b580         	push	{r7, lr}
 8011442: b086         	sub	sp, #0x18
 8011444: af00         	add	r7, sp, #0x0
 8011446: 60f8         	str	r0, [r7, #0xc]
 8011448: 60b9         	str	r1, [r7, #0x8]
 801144a: 607a         	str	r2, [r7, #0x4]
 801144c: 603b         	str	r3, [r7]
; 	if (!msg) {
 801144e: 68fb         	ldr	r3, [r7, #0xc]
 8011450: 2b00         	cmp	r3, #0x0
 8011452: d103         	bne	0x801145c <z_log_msg_finalize+0x1c> @ imm = #0x6
; 		z_log_dropped(false);
 8011454: 2000         	movs	r0, #0x0
 8011456: f7f0 fd6b    	bl	0x8001f30 <z_log_dropped> @ imm = #-0xf52a
; 		return;
 801145a: e01c         	b	0x8011496 <z_log_msg_finalize+0x56> @ imm = #0x38
; 	if (data) {
 801145c: 683b         	ldr	r3, [r7]
 801145e: 2b00         	cmp	r3, #0x0
 8011460: d010         	beq	0x8011484 <z_log_msg_finalize+0x44> @ imm = #0x20
; 		uint8_t *d = msg->data + desc.package_len;
 8011462: 68fb         	ldr	r3, [r7, #0xc]
 8011464: 3310         	adds	r3, #0x10
 8011466: 687a         	ldr	r2, [r7, #0x4]
 8011468: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 801146c: b292         	uxth	r2, r2
 801146e: 4413         	add	r3, r2
 8011470: 617b         	str	r3, [r7, #0x14]
; 		memcpy(d, data, desc.data_len);
 8011472: 88fb         	ldrh	r3, [r7, #0x6]
 8011474: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 8011478: b29b         	uxth	r3, r3
 801147a: 461a         	mov	r2, r3
 801147c: 6839         	ldr	r1, [r7]
 801147e: 6978         	ldr	r0, [r7, #0x14]
 8011480: f007 fc53    	bl	0x8018d2a <memcpy>      @ imm = #0x78a6
; 	msg->hdr.desc = desc;
 8011484: 68fb         	ldr	r3, [r7, #0xc]
 8011486: 687a         	ldr	r2, [r7, #0x4]
 8011488: 601a         	str	r2, [r3]
; 	msg->hdr.source = source;
 801148a: 68fb         	ldr	r3, [r7, #0xc]
 801148c: 68ba         	ldr	r2, [r7, #0x8]
 801148e: 605a         	str	r2, [r3, #0x4]
; 	z_log_msg_commit(msg);
 8011490: 68f8         	ldr	r0, [r7, #0xc]
 8011492: f7f0 fd63    	bl	0x8001f5c <z_log_msg_commit> @ imm = #-0xf53a
; }
 8011496: 3718         	adds	r7, #0x18
 8011498: 46bd         	mov	sp, r7
 801149a: bd80         	pop	{r7, pc}

0801149c <log_msg_get_source_id>:
; {
 801149c: b580         	push	{r7, lr}
 801149e: b084         	sub	sp, #0x10
 80114a0: af00         	add	r7, sp, #0x0
 80114a2: 6078         	str	r0, [r7, #0x4]
; 	if (!z_log_is_local_domain(log_msg_get_domain(msg))) {
 80114a4: 6878         	ldr	r0, [r7, #0x4]
 80114a6: f7ff ff9b    	bl	0x80113e0 <log_msg_get_domain> @ imm = #-0xca
 80114aa: 4603         	mov	r3, r0
 80114ac: 4618         	mov	r0, r3
 80114ae: f7ff ffbc    	bl	0x801142a <z_log_is_local_domain> @ imm = #-0x88
 80114b2: 4603         	mov	r3, r0
 80114b4: f083 0301    	eor	r3, r3, #0x1
 80114b8: b2db         	uxtb	r3, r3
 80114ba: 2b00         	cmp	r3, #0x0
 80114bc: d005         	beq	0x80114ca <log_msg_get_source_id+0x2e> @ imm = #0xa
; 		return (int16_t)(uintptr_t)log_msg_get_source(msg);
 80114be: 6878         	ldr	r0, [r7, #0x4]
 80114c0: f7ff ff9c    	bl	0x80113fc <log_msg_get_source> @ imm = #-0xc8
 80114c4: 4603         	mov	r3, r0
 80114c6: b21b         	sxth	r3, r3
 80114c8: e00e         	b	0x80114e8 <log_msg_get_source_id+0x4c> @ imm = #0x1c
; 	void *source = (void *)log_msg_get_source(msg);
 80114ca: 6878         	ldr	r0, [r7, #0x4]
 80114cc: f7ff ff96    	bl	0x80113fc <log_msg_get_source> @ imm = #-0xd4
 80114d0: 60f8         	str	r0, [r7, #0xc]
; 	if (source != NULL) {
 80114d2: 68fb         	ldr	r3, [r7, #0xc]
 80114d4: 2b00         	cmp	r3, #0x0
 80114d6: d005         	beq	0x80114e4 <log_msg_get_source_id+0x48> @ imm = #0xa
; 		return log_source_id(source);
 80114d8: 68f8         	ldr	r0, [r7, #0xc]
 80114da: f7ff ff9a    	bl	0x8011412 <log_source_id> @ imm = #-0xcc
 80114de: 4603         	mov	r3, r0
 80114e0: b21b         	sxth	r3, r3
 80114e2: e001         	b	0x80114e8 <log_msg_get_source_id+0x4c> @ imm = #0x2
; 	return -1;
 80114e4: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 80114e8: 4618         	mov	r0, r3
 80114ea: 3710         	adds	r7, #0x10
 80114ec: 46bd         	mov	sp, r7
 80114ee: bd80         	pop	{r7, pc}

080114f0 <log_msg_get_domain>:
; {
 80114f0: b480         	push	{r7}
 80114f2: b083         	sub	sp, #0xc
 80114f4: af00         	add	r7, sp, #0x0
 80114f6: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 80114f8: 687b         	ldr	r3, [r7, #0x4]
 80114fa: 781b         	ldrb	r3, [r3]
 80114fc: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 8011500: b2db         	uxtb	r3, r3
; }
 8011502: 4618         	mov	r0, r3
 8011504: 370c         	adds	r7, #0xc
 8011506: 46bd         	mov	sp, r7
 8011508: bc80         	pop	{r7}
 801150a: 4770         	bx	lr

0801150c <log_msg_get_level>:
; {
 801150c: b480         	push	{r7}
 801150e: b083         	sub	sp, #0xc
 8011510: af00         	add	r7, sp, #0x0
 8011512: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.level;
 8011514: 687b         	ldr	r3, [r7, #0x4]
 8011516: 881b         	ldrh	r3, [r3]
 8011518: f3c3 1382    	ubfx	r3, r3, #0x6, #0x3
 801151c: b2db         	uxtb	r3, r3
; }
 801151e: 4618         	mov	r0, r3
 8011520: 370c         	adds	r7, #0xc
 8011522: 46bd         	mov	sp, r7
 8011524: bc80         	pop	{r7}
 8011526: 4770         	bx	lr

08011528 <log_msg_get_timestamp>:
; {
 8011528: b480         	push	{r7}
 801152a: b083         	sub	sp, #0xc
 801152c: af00         	add	r7, sp, #0x0
 801152e: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.timestamp;
 8011530: 687b         	ldr	r3, [r7, #0x4]
 8011532: 689b         	ldr	r3, [r3, #0x8]
; }
 8011534: 4618         	mov	r0, r3
 8011536: 370c         	adds	r7, #0xc
 8011538: 46bd         	mov	sp, r7
 801153a: bc80         	pop	{r7}
 801153c: 4770         	bx	lr

0801153e <log_msg_get_tid>:
; {
 801153e: b480         	push	{r7}
 8011540: b083         	sub	sp, #0xc
 8011542: af00         	add	r7, sp, #0x0
 8011544: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 8011546: 2300         	movs	r3, #0x0
; }
 8011548: 4618         	mov	r0, r3
 801154a: 370c         	adds	r7, #0xc
 801154c: 46bd         	mov	sp, r7
 801154e: bc80         	pop	{r7}
 8011550: 4770         	bx	lr

08011552 <log_msg_get_data>:
; {
 8011552: b480         	push	{r7}
 8011554: b083         	sub	sp, #0xc
 8011556: af00         	add	r7, sp, #0x0
 8011558: 6078         	str	r0, [r7, #0x4]
 801155a: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.data_len;
 801155c: 687b         	ldr	r3, [r7, #0x4]
 801155e: 885b         	ldrh	r3, [r3, #0x2]
 8011560: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 8011564: b29b         	uxth	r3, r3
 8011566: 461a         	mov	r2, r3
 8011568: 683b         	ldr	r3, [r7]
 801156a: 601a         	str	r2, [r3]
; 	return msg->data + msg->hdr.desc.package_len;
 801156c: 687b         	ldr	r3, [r7, #0x4]
 801156e: 3310         	adds	r3, #0x10
 8011570: 687a         	ldr	r2, [r7, #0x4]
 8011572: 6812         	ldr	r2, [r2]
 8011574: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 8011578: b292         	uxth	r2, r2
 801157a: 4413         	add	r3, r2
; }
 801157c: 4618         	mov	r0, r3
 801157e: 370c         	adds	r7, #0xc
 8011580: 46bd         	mov	sp, r7
 8011582: bc80         	pop	{r7}
 8011584: 4770         	bx	lr

08011586 <log_msg_get_package>:
; {
 8011586: b480         	push	{r7}
 8011588: b083         	sub	sp, #0xc
 801158a: af00         	add	r7, sp, #0x0
 801158c: 6078         	str	r0, [r7, #0x4]
 801158e: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.package_len;
 8011590: 687b         	ldr	r3, [r7, #0x4]
 8011592: 681b         	ldr	r3, [r3]
 8011594: f3c3 234a    	ubfx	r3, r3, #0x9, #0xb
 8011598: b29b         	uxth	r3, r3
 801159a: 461a         	mov	r2, r3
 801159c: 683b         	ldr	r3, [r7]
 801159e: 601a         	str	r2, [r3]
; 	return msg->data;
 80115a0: 687b         	ldr	r3, [r7, #0x4]
 80115a2: 3310         	adds	r3, #0x10
; }
 80115a4: 4618         	mov	r0, r3
 80115a6: 370c         	adds	r7, #0xc
 80115a8: 46bd         	mov	sp, r7
 80115aa: bc80         	pop	{r7}
 80115ac: 4770         	bx	lr

080115ae <log_output_write>:
; {
 80115ae: b580         	push	{r7, lr}
 80115b0: b086         	sub	sp, #0x18
 80115b2: af00         	add	r7, sp, #0x0
 80115b4: 60f8         	str	r0, [r7, #0xc]
 80115b6: 60b9         	str	r1, [r7, #0x8]
 80115b8: 607a         	str	r2, [r7, #0x4]
 80115ba: 603b         	str	r3, [r7]
; 	while (len != 0) {
 80115bc: e00d         	b	0x80115da <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 80115be: 68fb         	ldr	r3, [r7, #0xc]
 80115c0: 683a         	ldr	r2, [r7]
 80115c2: 6879         	ldr	r1, [r7, #0x4]
 80115c4: 68b8         	ldr	r0, [r7, #0x8]
 80115c6: 4798         	blx	r3
 80115c8: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 80115ca: 697b         	ldr	r3, [r7, #0x14]
 80115cc: 687a         	ldr	r2, [r7, #0x4]
 80115ce: 1ad3         	subs	r3, r2, r3
 80115d0: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 80115d2: 697b         	ldr	r3, [r7, #0x14]
 80115d4: 68ba         	ldr	r2, [r7, #0x8]
 80115d6: 4413         	add	r3, r2
 80115d8: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 80115da: 687b         	ldr	r3, [r7, #0x4]
 80115dc: 2b00         	cmp	r3, #0x0
 80115de: d1ee         	bne	0x80115be <log_output_write+0x10> @ imm = #-0x24
; }
 80115e0: bf00         	nop
 80115e2: bf00         	nop
 80115e4: 3718         	adds	r7, #0x18
 80115e6: 46bd         	mov	sp, r7
 80115e8: bd80         	pop	{r7, pc}

080115ea <log_output_flush>:
; {
 80115ea: b580         	push	{r7, lr}
 80115ec: b082         	sub	sp, #0x8
 80115ee: af00         	add	r7, sp, #0x0
 80115f0: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 80115f2: 687b         	ldr	r3, [r7, #0x4]
 80115f4: 6818         	ldr	r0, [r3]
 80115f6: 687b         	ldr	r3, [r7, #0x4]
 80115f8: 6899         	ldr	r1, [r3, #0x8]
 80115fa: 687b         	ldr	r3, [r7, #0x4]
 80115fc: 685b         	ldr	r3, [r3, #0x4]
 80115fe: 681b         	ldr	r3, [r3]
 8011600: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 8011602: 687b         	ldr	r3, [r7, #0x4]
 8011604: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 8011606: 685b         	ldr	r3, [r3, #0x4]
 8011608: f7ff ffd1    	bl	0x80115ae <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 801160c: 687b         	ldr	r3, [r7, #0x4]
 801160e: 685b         	ldr	r3, [r3, #0x4]
 8011610: 2200         	movs	r2, #0x0
 8011612: 601a         	str	r2, [r3]
; }
 8011614: bf00         	nop
 8011616: 3708         	adds	r7, #0x8
 8011618: 46bd         	mov	sp, r7
 801161a: bd80         	pop	{r7, pc}

0801161c <out_func>:
; {
 801161c: b580         	push	{r7, lr}
 801161e: b084         	sub	sp, #0x10
 8011620: af00         	add	r7, sp, #0x0
 8011622: 6078         	str	r0, [r7, #0x4]
 8011624: 6039         	str	r1, [r7]
; 	const struct log_output *out_ctx = (const struct log_output *)ctx;
 8011626: 683b         	ldr	r3, [r7]
 8011628: 60fb         	str	r3, [r7, #0xc]
; 		char x = (char)c;
 801162a: 687b         	ldr	r3, [r7, #0x4]
 801162c: b2db         	uxtb	r3, r3
 801162e: 72fb         	strb	r3, [r7, #0xb]
; 		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
 8011630: 68fb         	ldr	r3, [r7, #0xc]
 8011632: 681b         	ldr	r3, [r3]
 8011634: 68fa         	ldr	r2, [r7, #0xc]
 8011636: 6852         	ldr	r2, [r2, #0x4]
 8011638: 6852         	ldr	r2, [r2, #0x4]
 801163a: f107 000b    	add.w	r0, r7, #0xb
 801163e: 2101         	movs	r1, #0x1
 8011640: 4798         	blx	r3
; 		return 0;
 8011642: 2300         	movs	r3, #0x0
; }
 8011644: 4618         	mov	r0, r3
 8011646: 3710         	adds	r7, #0x10
 8011648: 46bd         	mov	sp, r7
 801164a: bd80         	pop	{r7, pc}

0801164c <cr_out_func>:
; {
 801164c: b580         	push	{r7, lr}
 801164e: b082         	sub	sp, #0x8
 8011650: af00         	add	r7, sp, #0x0
 8011652: 6078         	str	r0, [r7, #0x4]
 8011654: 6039         	str	r1, [r7]
; 	if (c == '\n') {
 8011656: 687b         	ldr	r3, [r7, #0x4]
 8011658: 2b0a         	cmp	r3, #0xa
 801165a: d103         	bne	0x8011664 <cr_out_func+0x18> @ imm = #0x6
; 		out_func((int)'\r', ctx);
 801165c: 6839         	ldr	r1, [r7]
 801165e: 200d         	movs	r0, #0xd
 8011660: f7ff ffdc    	bl	0x801161c <out_func>    @ imm = #-0x48
; 	out_func(c, ctx);
 8011664: 6839         	ldr	r1, [r7]
 8011666: 6878         	ldr	r0, [r7, #0x4]
 8011668: f7ff ffd8    	bl	0x801161c <out_func>    @ imm = #-0x50
; 	return 0;
 801166c: 2300         	movs	r3, #0x0
; }
 801166e: 4618         	mov	r0, r3
 8011670: 3708         	adds	r7, #0x8
 8011672: 46bd         	mov	sp, r7
 8011674: bd80         	pop	{r7, pc}

08011676 <color_prefix>:
; {
 8011676: b580         	push	{r7, lr}
 8011678: b084         	sub	sp, #0x10
 801167a: af00         	add	r7, sp, #0x0
 801167c: 60f8         	str	r0, [r7, #0xc]
 801167e: 460b         	mov	r3, r1
 8011680: 607a         	str	r2, [r7, #0x4]
 8011682: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, true, level);
 8011684: 7af9         	ldrb	r1, [r7, #0xb]
 8011686: 687b         	ldr	r3, [r7, #0x4]
 8011688: 2201         	movs	r2, #0x1
 801168a: 68f8         	ldr	r0, [r7, #0xc]
 801168c: f7f0 fece    	bl	0x800242c <color_print> @ imm = #-0xf264
; }
 8011690: bf00         	nop
 8011692: 3710         	adds	r7, #0x10
 8011694: 46bd         	mov	sp, r7
 8011696: bd80         	pop	{r7, pc}

08011698 <color_postfix>:
; {
 8011698: b580         	push	{r7, lr}
 801169a: b084         	sub	sp, #0x10
 801169c: af00         	add	r7, sp, #0x0
 801169e: 60f8         	str	r0, [r7, #0xc]
 80116a0: 460b         	mov	r3, r1
 80116a2: 607a         	str	r2, [r7, #0x4]
 80116a4: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, false, level);
 80116a6: 7af9         	ldrb	r1, [r7, #0xb]
 80116a8: 687b         	ldr	r3, [r7, #0x4]
 80116aa: 2200         	movs	r2, #0x0
 80116ac: 68f8         	ldr	r0, [r7, #0xc]
 80116ae: f7f0 febd    	bl	0x800242c <color_print> @ imm = #-0xf286
; }
 80116b2: bf00         	nop
 80116b4: 3710         	adds	r7, #0x10
 80116b6: 46bd         	mov	sp, r7
 80116b8: bd80         	pop	{r7, pc}

080116ba <log_msg_hexdump>:
; {
 80116ba: b580         	push	{r7, lr}
 80116bc: b088         	sub	sp, #0x20
 80116be: af02         	add	r7, sp, #0x8
 80116c0: 60f8         	str	r0, [r7, #0xc]
 80116c2: 60b9         	str	r1, [r7, #0x8]
 80116c4: 607a         	str	r2, [r7, #0x4]
 80116c6: 603b         	str	r3, [r7]
; 		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
 80116c8: 687b         	ldr	r3, [r7, #0x4]
 80116ca: 2b10         	cmp	r3, #0x10
 80116cc: bf28         	it	hs
 80116ce: 2310         	movhs	r3, #0x10
 80116d0: 617b         	str	r3, [r7, #0x14]
; 		hexdump_line_print(output, data, length,
 80116d2: 6a3b         	ldr	r3, [r7, #0x20]
 80116d4: 9300         	str	r3, [sp]
 80116d6: 683b         	ldr	r3, [r7]
 80116d8: 697a         	ldr	r2, [r7, #0x14]
 80116da: 68b9         	ldr	r1, [r7, #0x8]
 80116dc: 68f8         	ldr	r0, [r7, #0xc]
 80116de: f7f0 ff43    	bl	0x8002568 <hexdump_line_print> @ imm = #-0xf17a
; 		data += length;
 80116e2: 68ba         	ldr	r2, [r7, #0x8]
 80116e4: 697b         	ldr	r3, [r7, #0x14]
 80116e6: 4413         	add	r3, r2
 80116e8: 60bb         	str	r3, [r7, #0x8]
; 		len -= length;
 80116ea: 687a         	ldr	r2, [r7, #0x4]
 80116ec: 697b         	ldr	r3, [r7, #0x14]
 80116ee: 1ad3         	subs	r3, r2, r3
 80116f0: 607b         	str	r3, [r7, #0x4]
; 	} while (len);
 80116f2: 687b         	ldr	r3, [r7, #0x4]
 80116f4: 2b00         	cmp	r3, #0x0
 80116f6: d1e7         	bne	0x80116c8 <log_msg_hexdump+0xe> @ imm = #-0x32
; }
 80116f8: bf00         	nop
 80116fa: bf00         	nop
 80116fc: 3718         	adds	r7, #0x18
 80116fe: 46bd         	mov	sp, r7
 8011700: bd80         	pop	{r7, pc}

08011702 <postfix_print>:
; {
 8011702: b580         	push	{r7, lr}
 8011704: b084         	sub	sp, #0x10
 8011706: af00         	add	r7, sp, #0x0
 8011708: 60f8         	str	r0, [r7, #0xc]
 801170a: 60b9         	str	r1, [r7, #0x8]
 801170c: 4613         	mov	r3, r2
 801170e: 71fb         	strb	r3, [r7, #0x7]
; 	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
 8011710: 68bb         	ldr	r3, [r7, #0x8]
 8011712: f003 0301    	and	r3, r3, #0x1
 8011716: 2b00         	cmp	r3, #0x0
 8011718: bf14         	ite	ne
 801171a: 2301         	movne	r3, #0x1
 801171c: 2300         	moveq	r3, #0x0
 801171e: b2db         	uxtb	r3, r3
 8011720: 79fa         	ldrb	r2, [r7, #0x7]
 8011722: 4619         	mov	r1, r3
 8011724: 68f8         	ldr	r0, [r7, #0xc]
 8011726: f7ff ffb7    	bl	0x8011698 <color_postfix> @ imm = #-0x92
; 	newline_print(output, flags);
 801172a: 68b9         	ldr	r1, [r7, #0x8]
 801172c: 68f8         	ldr	r0, [r7, #0xc]
 801172e: f7f0 fef9    	bl	0x8002524 <newline_print> @ imm = #-0xf20e
; }
 8011732: bf00         	nop
 8011734: 3710         	adds	r7, #0x10
 8011736: 46bd         	mov	sp, r7
 8011738: bd80         	pop	{r7, pc}

0801173a <log_output_msg_process>:
; {
 801173a: b580         	push	{r7, lr}
 801173c: b092         	sub	sp, #0x48
 801173e: af06         	add	r7, sp, #0x18
 8011740: 60f8         	str	r0, [r7, #0xc]
 8011742: 60b9         	str	r1, [r7, #0x8]
 8011744: 607a         	str	r2, [r7, #0x4]
; 	log_timestamp_t timestamp = log_msg_get_timestamp(msg);
 8011746: 68b8         	ldr	r0, [r7, #0x8]
 8011748: f7ff feee    	bl	0x8011528 <log_msg_get_timestamp> @ imm = #-0x224
 801174c: 62f8         	str	r0, [r7, #0x2c]
; 	uint8_t level = log_msg_get_level(msg);
 801174e: 68b8         	ldr	r0, [r7, #0x8]
 8011750: f7ff fedc    	bl	0x801150c <log_msg_get_level> @ imm = #-0x248
 8011754: 4603         	mov	r3, r0
 8011756: f887 302b    	strb.w	r3, [r7, #0x2b]
; 	uint8_t domain_id = log_msg_get_domain(msg);
 801175a: 68b8         	ldr	r0, [r7, #0x8]
 801175c: f7ff fec8    	bl	0x80114f0 <log_msg_get_domain> @ imm = #-0x270
 8011760: 4603         	mov	r3, r0
 8011762: f887 302a    	strb.w	r3, [r7, #0x2a]
; 	int16_t source_id = log_msg_get_source_id(msg);
 8011766: 68b8         	ldr	r0, [r7, #0x8]
 8011768: f7ff fe98    	bl	0x801149c <log_msg_get_source_id> @ imm = #-0x2d0
 801176c: 4603         	mov	r3, r0
 801176e: 853b         	strh	r3, [r7, #0x28]
; 	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
 8011770: f9b7 3028    	ldrsh.w	r3, [r7, #0x28]
 8011774: 2b00         	cmp	r3, #0x0
 8011776: db09         	blt	0x801178c <log_output_msg_process+0x52> @ imm = #0x12
 8011778: f897 302a    	ldrb.w	r3, [r7, #0x2a]
 801177c: f9b7 2028    	ldrsh.w	r2, [r7, #0x28]
 8011780: 4611         	mov	r1, r2
 8011782: 4618         	mov	r0, r3
 8011784: f7f0 fcaa    	bl	0x80020dc <log_source_name_get> @ imm = #-0xf6ac
 8011788: 4603         	mov	r3, r0
 801178a: e000         	b	0x801178e <log_output_msg_process+0x54> @ imm = #0x0
 801178c: 2300         	movs	r3, #0x0
 801178e: 627b         	str	r3, [r7, #0x24]
; 	uint8_t *package = log_msg_get_package(msg, &plen);
 8011790: f107 0318    	add.w	r3, r7, #0x18
 8011794: 4619         	mov	r1, r3
 8011796: 68b8         	ldr	r0, [r7, #0x8]
 8011798: f7ff fef5    	bl	0x8011586 <log_msg_get_package> @ imm = #-0x216
 801179c: 6238         	str	r0, [r7, #0x20]
; 	uint8_t *data = log_msg_get_data(msg, &dlen);
 801179e: f107 0314    	add.w	r3, r7, #0x14
 80117a2: 4619         	mov	r1, r3
 80117a4: 68b8         	ldr	r0, [r7, #0x8]
 80117a6: f7ff fed4    	bl	0x8011552 <log_msg_get_data> @ imm = #-0x258
 80117aa: 61f8         	str	r0, [r7, #0x1c]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 80117ac: 68b8         	ldr	r0, [r7, #0x8]
 80117ae: f7ff fec6    	bl	0x801153e <log_msg_get_tid> @ imm = #-0x274
; 			   plen > 0 ? package : NULL, data, dlen, flags);
 80117b2: 69bb         	ldr	r3, [r7, #0x18]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 80117b4: 2b00         	cmp	r3, #0x0
 80117b6: d001         	beq	0x80117bc <log_output_msg_process+0x82> @ imm = #0x2
 80117b8: 6a3b         	ldr	r3, [r7, #0x20]
 80117ba: e000         	b	0x80117be <log_output_msg_process+0x84> @ imm = #0x0
 80117bc: 2300         	movs	r3, #0x0
 80117be: 697a         	ldr	r2, [r7, #0x14]
 80117c0: 6879         	ldr	r1, [r7, #0x4]
 80117c2: 9105         	str	r1, [sp, #0x14]
 80117c4: 9204         	str	r2, [sp, #0x10]
 80117c6: 69fa         	ldr	r2, [r7, #0x1c]
 80117c8: 9203         	str	r2, [sp, #0xc]
 80117ca: 9302         	str	r3, [sp, #0x8]
 80117cc: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80117d0: 9301         	str	r3, [sp, #0x4]
 80117d2: 9000         	str	r0, [sp]
 80117d4: 6a7b         	ldr	r3, [r7, #0x24]
 80117d6: 2200         	movs	r2, #0x0
 80117d8: 6af9         	ldr	r1, [r7, #0x2c]
 80117da: 68f8         	ldr	r0, [r7, #0xc]
 80117dc: f7f0 ffbe    	bl	0x800275c <log_output_process> @ imm = #-0xf084
; }
 80117e0: bf00         	nop
 80117e2: 3730         	adds	r7, #0x30
 80117e4: 46bd         	mov	sp, r7
 80117e6: bd80         	pop	{r7, pc}

080117e8 <log_output_write>:
; {
 80117e8: b580         	push	{r7, lr}
 80117ea: b086         	sub	sp, #0x18
 80117ec: af00         	add	r7, sp, #0x0
 80117ee: 60f8         	str	r0, [r7, #0xc]
 80117f0: 60b9         	str	r1, [r7, #0x8]
 80117f2: 607a         	str	r2, [r7, #0x4]
 80117f4: 603b         	str	r3, [r7]
; 	while (len != 0) {
 80117f6: e00d         	b	0x8011814 <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 80117f8: 68fb         	ldr	r3, [r7, #0xc]
 80117fa: 683a         	ldr	r2, [r7]
 80117fc: 6879         	ldr	r1, [r7, #0x4]
 80117fe: 68b8         	ldr	r0, [r7, #0x8]
 8011800: 4798         	blx	r3
 8011802: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 8011804: 697b         	ldr	r3, [r7, #0x14]
 8011806: 687a         	ldr	r2, [r7, #0x4]
 8011808: 1ad3         	subs	r3, r2, r3
 801180a: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 801180c: 697b         	ldr	r3, [r7, #0x14]
 801180e: 68ba         	ldr	r2, [r7, #0x8]
 8011810: 4413         	add	r3, r2
 8011812: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 8011814: 687b         	ldr	r3, [r7, #0x4]
 8011816: 2b00         	cmp	r3, #0x0
 8011818: d1ee         	bne	0x80117f8 <log_output_write+0x10> @ imm = #-0x24
; }
 801181a: bf00         	nop
 801181c: bf00         	nop
 801181e: 3718         	adds	r7, #0x18
 8011820: 46bd         	mov	sp, r7
 8011822: bd80         	pop	{r7, pc}

08011824 <log_output_flush>:
; {
 8011824: b580         	push	{r7, lr}
 8011826: b082         	sub	sp, #0x8
 8011828: af00         	add	r7, sp, #0x0
 801182a: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 801182c: 687b         	ldr	r3, [r7, #0x4]
 801182e: 6818         	ldr	r0, [r3]
 8011830: 687b         	ldr	r3, [r7, #0x4]
 8011832: 6899         	ldr	r1, [r3, #0x8]
 8011834: 687b         	ldr	r3, [r7, #0x4]
 8011836: 685b         	ldr	r3, [r3, #0x4]
 8011838: 681b         	ldr	r3, [r3]
 801183a: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 801183c: 687b         	ldr	r3, [r7, #0x4]
 801183e: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 8011840: 685b         	ldr	r3, [r3, #0x4]
 8011842: f7ff ffd1    	bl	0x80117e8 <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 8011846: 687b         	ldr	r3, [r7, #0x4]
 8011848: 685b         	ldr	r3, [r3, #0x4]
 801184a: 2200         	movs	r2, #0x0
 801184c: 601a         	str	r2, [r3]
; }
 801184e: bf00         	nop
 8011850: 3708         	adds	r7, #0x8
 8011852: 46bd         	mov	sp, r7
 8011854: bd80         	pop	{r7, pc}

08011856 <log_output_ctx_set>:
; {
 8011856: b480         	push	{r7}
 8011858: b083         	sub	sp, #0xc
 801185a: af00         	add	r7, sp, #0x0
 801185c: 6078         	str	r0, [r7, #0x4]
 801185e: 6039         	str	r1, [r7]
; 	output->control_block->ctx = ctx;
 8011860: 687b         	ldr	r3, [r7, #0x4]
 8011862: 685b         	ldr	r3, [r3, #0x4]
 8011864: 683a         	ldr	r2, [r7]
 8011866: 605a         	str	r2, [r3, #0x4]
; }
 8011868: bf00         	nop
 801186a: 370c         	adds	r7, #0xc
 801186c: 46bd         	mov	sp, r7
 801186e: bc80         	pop	{r7}
 8011870: 4770         	bx	lr

08011872 <log_backend_std_get_flags>:
; {
 8011872: b480         	push	{r7}
 8011874: b083         	sub	sp, #0xc
 8011876: af00         	add	r7, sp, #0x0
; 	uint32_t flags = (LOG_OUTPUT_FLAG_LEVEL | LOG_OUTPUT_FLAG_TIMESTAMP);
 8011878: 230a         	movs	r3, #0xa
 801187a: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_COLORS;
 801187c: 687b         	ldr	r3, [r7, #0x4]
 801187e: f043 0301    	orr	r3, r3, #0x1
 8011882: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP;
 8011884: 687b         	ldr	r3, [r7, #0x4]
 8011886: f043 0304    	orr	r3, r3, #0x4
 801188a: 607b         	str	r3, [r7, #0x4]
; 	return flags;
 801188c: 687b         	ldr	r3, [r7, #0x4]
; }
 801188e: 4618         	mov	r0, r3
 8011890: 370c         	adds	r7, #0xc
 8011892: 46bd         	mov	sp, r7
 8011894: bc80         	pop	{r7}
 8011896: 4770         	bx	lr

08011898 <log_backend_std_panic>:
; {
 8011898: b580         	push	{r7, lr}
 801189a: b082         	sub	sp, #0x8
 801189c: af00         	add	r7, sp, #0x0
 801189e: 6078         	str	r0, [r7, #0x4]
; 	log_output_flush(output);
 80118a0: 6878         	ldr	r0, [r7, #0x4]
 80118a2: f7ff ffbf    	bl	0x8011824 <log_output_flush> @ imm = #-0x82
; }
 80118a6: bf00         	nop
 80118a8: 3708         	adds	r7, #0x8
 80118aa: 46bd         	mov	sp, r7
 80118ac: bd80         	pop	{r7, pc}

080118ae <z_impl_uart_poll_out>:
; {
 80118ae: b580         	push	{r7, lr}
 80118b0: b084         	sub	sp, #0x10
 80118b2: af00         	add	r7, sp, #0x0
 80118b4: 6078         	str	r0, [r7, #0x4]
 80118b6: 460b         	mov	r3, r1
 80118b8: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api =
 80118ba: 687b         	ldr	r3, [r7, #0x4]
 80118bc: 689b         	ldr	r3, [r3, #0x8]
 80118be: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 80118c0: 68fb         	ldr	r3, [r7, #0xc]
 80118c2: 69db         	ldr	r3, [r3, #0x1c]
 80118c4: 78fa         	ldrb	r2, [r7, #0x3]
 80118c6: 4611         	mov	r1, r2
 80118c8: 6878         	ldr	r0, [r7, #0x4]
 80118ca: 4798         	blx	r3
; }
 80118cc: bf00         	nop
 80118ce: 3710         	adds	r7, #0x10
 80118d0: 46bd         	mov	sp, r7
 80118d2: bd80         	pop	{r7, pc}

080118d4 <uart_poll_out>:
; {
 80118d4: b580         	push	{r7, lr}
 80118d6: b082         	sub	sp, #0x8
 80118d8: af00         	add	r7, sp, #0x0
 80118da: 6078         	str	r0, [r7, #0x4]
 80118dc: 460b         	mov	r3, r1
 80118de: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 80118e0: 78fb         	ldrb	r3, [r7, #0x3]
 80118e2: 4619         	mov	r1, r3
 80118e4: 6878         	ldr	r0, [r7, #0x4]
 80118e6: f7ff ffe2    	bl	0x80118ae <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 80118ea: bf00         	nop
 80118ec: 3708         	adds	r7, #0x8
 80118ee: 46bd         	mov	sp, r7
 80118f0: bd80         	pop	{r7, pc}

080118f2 <pm_device_runtime_get>:
; {
 80118f2: b480         	push	{r7}
 80118f4: b083         	sub	sp, #0xc
 80118f6: af00         	add	r7, sp, #0x0
 80118f8: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 80118fa: 2300         	movs	r3, #0x0
; }
 80118fc: 4618         	mov	r0, r3
 80118fe: 370c         	adds	r7, #0xc
 8011900: 46bd         	mov	sp, r7
 8011902: bc80         	pop	{r7}
 8011904: 4770         	bx	lr

08011906 <pm_device_runtime_put_async>:
; {
 8011906: b480         	push	{r7}
 8011908: b085         	sub	sp, #0x14
 801190a: af00         	add	r7, sp, #0x0
 801190c: 60f8         	str	r0, [r7, #0xc]
 801190e: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 8011912: 2300         	movs	r3, #0x0
; }
 8011914: 4618         	mov	r0, r3
 8011916: 3714         	adds	r7, #0x14
 8011918: 46bd         	mov	sp, r7
 801191a: bc80         	pop	{r7}
 801191c: 4770         	bx	lr

0801191e <process>:
; {
 801191e: b580         	push	{r7, lr}
 8011920: b086         	sub	sp, #0x18
 8011922: af00         	add	r7, sp, #0x0
 8011924: 6078         	str	r0, [r7, #0x4]
 8011926: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8011928: 687b         	ldr	r3, [r7, #0x4]
 801192a: 685b         	ldr	r3, [r3, #0x4]
 801192c: 681b         	ldr	r3, [r3]
 801192e: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 8011930: 697b         	ldr	r3, [r7, #0x14]
 8011932: 685b         	ldr	r3, [r3, #0x4]
 8011934: 613b         	str	r3, [r7, #0x10]
; 	uint32_t flags = log_backend_std_get_flags();
 8011936: f7ff ff9c    	bl	0x8011872 <log_backend_std_get_flags> @ imm = #-0xc8
 801193a: 60f8         	str	r0, [r7, #0xc]
; 	log_format_func_t log_output_func = log_format_func_t_get(data->log_format_current);
 801193c: 693b         	ldr	r3, [r7, #0x10]
 801193e: 691b         	ldr	r3, [r3, #0x10]
 8011940: 4618         	mov	r0, r3
 8011942: f7f0 f9e1    	bl	0x8001d08 <log_format_func_t_get> @ imm = #-0xfc3e
 8011946: 60b8         	str	r0, [r7, #0x8]
; 	log_output_func(ctx->output, &msg->log, flags);
 8011948: 697b         	ldr	r3, [r7, #0x14]
 801194a: 6818         	ldr	r0, [r3]
 801194c: 6839         	ldr	r1, [r7]
 801194e: 68bb         	ldr	r3, [r7, #0x8]
 8011950: 68fa         	ldr	r2, [r7, #0xc]
 8011952: 4798         	blx	r3
; }
 8011954: bf00         	nop
 8011956: 3718         	adds	r7, #0x18
 8011958: 46bd         	mov	sp, r7
 801195a: bd80         	pop	{r7, pc}

0801195c <format_set>:
; {
 801195c: b480         	push	{r7}
 801195e: b085         	sub	sp, #0x14
 8011960: af00         	add	r7, sp, #0x0
 8011962: 6078         	str	r0, [r7, #0x4]
 8011964: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8011966: 687b         	ldr	r3, [r7, #0x4]
 8011968: 685b         	ldr	r3, [r3, #0x4]
 801196a: 681b         	ldr	r3, [r3]
 801196c: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 801196e: 68fb         	ldr	r3, [r7, #0xc]
 8011970: 685b         	ldr	r3, [r3, #0x4]
 8011972: 60bb         	str	r3, [r7, #0x8]
; 	data->log_format_current = log_type;
 8011974: 68bb         	ldr	r3, [r7, #0x8]
 8011976: 683a         	ldr	r2, [r7]
 8011978: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 801197a: 2300         	movs	r3, #0x0
; }
 801197c: 4618         	mov	r0, r3
 801197e: 3714         	adds	r7, #0x14
 8011980: 46bd         	mov	sp, r7
 8011982: bc80         	pop	{r7}
 8011984: 4770         	bx	lr

08011986 <z_log_msg_runtime_create>:
; {
 8011986: b580         	push	{r7, lr}
 8011988: b08a         	sub	sp, #0x28
 801198a: af04         	add	r7, sp, #0x10
 801198c: 60b9         	str	r1, [r7, #0x8]
 801198e: 607b         	str	r3, [r7, #0x4]
 8011990: 4603         	mov	r3, r0
 8011992: 73fb         	strb	r3, [r7, #0xf]
 8011994: 4613         	mov	r3, r2
 8011996: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8011998: f107 032c    	add.w	r3, r7, #0x2c
 801199c: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801199e: 7bba         	ldrb	r2, [r7, #0xe]
 80119a0: 7bf8         	ldrb	r0, [r7, #0xf]
 80119a2: 697b         	ldr	r3, [r7, #0x14]
 80119a4: 9303         	str	r3, [sp, #0xc]
 80119a6: 6abb         	ldr	r3, [r7, #0x28]
 80119a8: 9302         	str	r3, [sp, #0x8]
 80119aa: 6a7b         	ldr	r3, [r7, #0x24]
 80119ac: 9301         	str	r3, [sp, #0x4]
 80119ae: 6a3b         	ldr	r3, [r7, #0x20]
 80119b0: 9300         	str	r3, [sp]
 80119b2: 687b         	ldr	r3, [r7, #0x4]
 80119b4: 68b9         	ldr	r1, [r7, #0x8]
 80119b6: f7f0 fbc9    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0xf86e
; }
 80119ba: bf00         	nop
 80119bc: 3718         	adds	r7, #0x18
 80119be: 46bd         	mov	sp, r7
 80119c0: bd80         	pop	{r7, pc}

080119c2 <z_do_kernel_oops>:
; {
 80119c2: b580         	push	{r7, lr}
 80119c4: b088         	sub	sp, #0x20
 80119c6: af00         	add	r7, sp, #0x0
 80119c8: 60f8         	str	r0, [r7, #0xc]
 80119ca: 60b9         	str	r1, [r7, #0x8]
 80119cc: 607a         	str	r2, [r7, #0x4]
; 	unsigned int reason = esf->basic.r0;
 80119ce: 68fb         	ldr	r3, [r7, #0xc]
 80119d0: 681b         	ldr	r3, [r3]
 80119d2: 61fb         	str	r3, [r7, #0x1c]
 80119d4: 68fb         	ldr	r3, [r7, #0xc]
 80119d6: 61bb         	str	r3, [r7, #0x18]
 80119d8: 687b         	ldr	r3, [r7, #0x4]
 80119da: 617b         	str	r3, [r7, #0x14]
; }
 80119dc: bf00         	nop
; 	z_arm_fatal_error(reason, esf);
 80119de: 68f9         	ldr	r1, [r7, #0xc]
 80119e0: 69f8         	ldr	r0, [r7, #0x1c]
 80119e2: f7f1 f83d    	bl	0x8002a60 <z_arm_fatal_error> @ imm = #-0xef86
; }
 80119e6: bf00         	nop
 80119e8: 3720         	adds	r7, #0x20
 80119ea: 46bd         	mov	sp, r7
 80119ec: bd80         	pop	{r7, pc}

080119ee <arch_tls_stack_setup>:
; {
 80119ee: b580         	push	{r7, lr}
 80119f0: b082         	sub	sp, #0x8
 80119f2: af00         	add	r7, sp, #0x0
 80119f4: 6078         	str	r0, [r7, #0x4]
 80119f6: 6039         	str	r1, [r7]
; 	stack_ptr -= z_tls_data_size();
 80119f8: f7f1 f87e    	bl	0x8002af8 <z_tls_data_size> @ imm = #-0xef04
 80119fc: 4603         	mov	r3, r0
 80119fe: 425b         	rsbs	r3, r3, #0
 8011a00: 683a         	ldr	r2, [r7]
 8011a02: 4413         	add	r3, r2
 8011a04: 603b         	str	r3, [r7]
; 	z_tls_copy(stack_ptr);
 8011a06: 6838         	ldr	r0, [r7]
 8011a08: f7f1 f884    	bl	0x8002b14 <z_tls_copy>  @ imm = #-0xeef8
; 	stack_ptr -= sizeof(uintptr_t) * 2;
 8011a0c: 683b         	ldr	r3, [r7]
 8011a0e: 3b08         	subs	r3, #0x8
 8011a10: 603b         	str	r3, [r7]
; 	new_thread->tls = POINTER_TO_UINT(stack_ptr);
 8011a12: 683a         	ldr	r2, [r7]
 8011a14: 687b         	ldr	r3, [r7, #0x4]
 8011a16: f8c3 20c4    	str.w	r2, [r3, #0xc4]
; 	return (z_tls_data_size() + (sizeof(uintptr_t) * 2));
 8011a1a: f7f1 f86d    	bl	0x8002af8 <z_tls_data_size> @ imm = #-0xef26
 8011a1e: 4603         	mov	r3, r0
 8011a20: 3308         	adds	r3, #0x8
; }
 8011a22: 4618         	mov	r0, r3
 8011a24: 3708         	adds	r7, #0x8
 8011a26: 46bd         	mov	sp, r7
 8011a28: bd80         	pop	{r7, pc}

08011a2a <z_log_msg_runtime_create>:
; {
 8011a2a: b580         	push	{r7, lr}
 8011a2c: b08a         	sub	sp, #0x28
 8011a2e: af04         	add	r7, sp, #0x10
 8011a30: 60b9         	str	r1, [r7, #0x8]
 8011a32: 607b         	str	r3, [r7, #0x4]
 8011a34: 4603         	mov	r3, r0
 8011a36: 73fb         	strb	r3, [r7, #0xf]
 8011a38: 4613         	mov	r3, r2
 8011a3a: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8011a3c: f107 032c    	add.w	r3, r7, #0x2c
 8011a40: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8011a42: 7bba         	ldrb	r2, [r7, #0xe]
 8011a44: 7bf8         	ldrb	r0, [r7, #0xf]
 8011a46: 697b         	ldr	r3, [r7, #0x14]
 8011a48: 9303         	str	r3, [sp, #0xc]
 8011a4a: 6abb         	ldr	r3, [r7, #0x28]
 8011a4c: 9302         	str	r3, [sp, #0x8]
 8011a4e: 6a7b         	ldr	r3, [r7, #0x24]
 8011a50: 9301         	str	r3, [sp, #0x4]
 8011a52: 6a3b         	ldr	r3, [r7, #0x20]
 8011a54: 9300         	str	r3, [sp]
 8011a56: 687b         	ldr	r3, [r7, #0x4]
 8011a58: 68b9         	ldr	r1, [r7, #0x8]
 8011a5a: f7f0 fb77    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0xf912
; }
 8011a5e: bf00         	nop
 8011a60: 3718         	adds	r7, #0x18
 8011a62: 46bd         	mov	sp, r7
 8011a64: bd80         	pop	{r7, pc}

08011a66 <fault_show>:
; {
 8011a66: b480         	push	{r7}
 8011a68: b083         	sub	sp, #0xc
 8011a6a: af00         	add	r7, sp, #0x0
 8011a6c: 6078         	str	r0, [r7, #0x4]
 8011a6e: 6039         	str	r1, [r7]
; }
 8011a70: bf00         	nop
 8011a72: 370c         	adds	r7, #0xc
 8011a74: 46bd         	mov	sp, r7
 8011a76: bc80         	pop	{r7}
 8011a78: 4770         	bx	lr

08011a7a <memory_fault_recoverable>:
; {
 8011a7a: b480         	push	{r7}
 8011a7c: b083         	sub	sp, #0xc
 8011a7e: af00         	add	r7, sp, #0x0
 8011a80: 6078         	str	r0, [r7, #0x4]
 8011a82: 460b         	mov	r3, r1
 8011a84: 70fb         	strb	r3, [r7, #0x3]
; 	return false;
 8011a86: 2300         	movs	r3, #0x0
; }
 8011a88: 4618         	mov	r0, r3
 8011a8a: 370c         	adds	r7, #0xc
 8011a8c: 46bd         	mov	sp, r7
 8011a8e: bc80         	pop	{r7}
 8011a90: 4770         	bx	lr

08011a92 <arch_irq_enable>:
; {
 8011a92: b580         	push	{r7, lr}
 8011a94: b082         	sub	sp, #0x8
 8011a96: af00         	add	r7, sp, #0x0
 8011a98: 6078         	str	r0, [r7, #0x4]
; 	NVIC_EnableIRQ((IRQn_Type)irq);
 8011a9a: 687b         	ldr	r3, [r7, #0x4]
 8011a9c: b25b         	sxtb	r3, r3
 8011a9e: 4618         	mov	r0, r3
 8011aa0: f7f1 ff96    	bl	0x80039d0 <__NVIC_EnableIRQ> @ imm = #-0xe0d4
; }
 8011aa4: bf00         	nop
 8011aa6: 3708         	adds	r7, #0x8
 8011aa8: 46bd         	mov	sp, r7
 8011aaa: bd80         	pop	{r7, pc}

08011aac <z_arm_irq_priority_set>:
; {
 8011aac: b580         	push	{r7, lr}
 8011aae: b084         	sub	sp, #0x10
 8011ab0: af00         	add	r7, sp, #0x0
 8011ab2: 60f8         	str	r0, [r7, #0xc]
 8011ab4: 60b9         	str	r1, [r7, #0x8]
 8011ab6: 607a         	str	r2, [r7, #0x4]
; 		prio += _IRQ_PRIO_OFFSET;
 8011ab8: 68bb         	ldr	r3, [r7, #0x8]
 8011aba: 3301         	adds	r3, #0x1
 8011abc: 60bb         	str	r3, [r7, #0x8]
; 	NVIC_SetPriority((IRQn_Type)irq, prio);
 8011abe: 68fb         	ldr	r3, [r7, #0xc]
 8011ac0: b25b         	sxtb	r3, r3
 8011ac2: 68b9         	ldr	r1, [r7, #0x8]
 8011ac4: 4618         	mov	r0, r3
 8011ac6: f7f1 ff9f    	bl	0x8003a08 <__NVIC_SetPriority> @ imm = #-0xe0c2
; }
 8011aca: bf00         	nop
 8011acc: 3710         	adds	r7, #0x10
 8011ace: 46bd         	mov	sp, r7
 8011ad0: bd80         	pop	{r7, pc}

08011ad2 <z_irq_spurious>:
; {
 8011ad2: b580         	push	{r7, lr}
 8011ad4: b082         	sub	sp, #0x8
 8011ad6: af00         	add	r7, sp, #0x0
 8011ad8: 6078         	str	r0, [r7, #0x4]
; 	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 8011ada: 2100         	movs	r1, #0x0
 8011adc: 2001         	movs	r0, #0x1
 8011ade: f7f0 ffbf    	bl	0x8002a60 <z_arm_fatal_error> @ imm = #-0xf082
; }
 8011ae2: bf00         	nop
 8011ae4: 3708         	adds	r7, #0x8
 8011ae6: 46bd         	mov	sp, r7
 8011ae8: bd80         	pop	{r7, pc}

08011aea <z_prep_c>:
; {
 8011aea: b580         	push	{r7, lr}
 8011aec: af00         	add	r7, sp, #0x0
; 	relocate_vector_table();
 8011aee: f7f1 ffb5    	bl	0x8003a5c <relocate_vector_table> @ imm = #-0xe096
; 	z_arm_floating_point_init();
 8011af2: f7f1 ffcd    	bl	0x8003a90 <z_arm_floating_point_init> @ imm = #-0xe066
; 	z_bss_zero();
 8011af6: f7f9 fe5b    	bl	0x800b7b0 <z_bss_zero>  @ imm = #-0x634a
; 	z_data_copy();
 8011afa: f7fc fe77    	bl	0x800e7ec <z_data_copy> @ imm = #-0x3312
; 	z_arm_interrupt_init();
 8011afe: f000 f83d    	bl	0x8011b7c <z_arm_interrupt_init> @ imm = #0x7a
; 	z_cstart();
 8011b02: f7f9 ff8f    	bl	0x800ba24 <z_cstart>    @ imm = #-0x60e2

08011b06 <z_arm_prepare_switch_to_main>:
; {
 8011b06: b480         	push	{r7}
 8011b08: af00         	add	r7, sp, #0x0
; }
 8011b0a: bf00         	nop
 8011b0c: 46bd         	mov	sp, r7
 8011b0e: bc80         	pop	{r7}
 8011b10: 4770         	bx	lr

08011b12 <arch_irq_unlock_outlined>:
; {
 8011b12: b480         	push	{r7}
 8011b14: b085         	sub	sp, #0x14
 8011b16: af00         	add	r7, sp, #0x0
 8011b18: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("cpsie f" : : : "memory");
 8011b1a: b661         	cpsie f
; }
 8011b1c: bf00         	nop
;   __ASM volatile ("cpsie i" : : : "memory");
 8011b1e: b662         	cpsie i
; }
 8011b20: bf00         	nop
 8011b22: 687b         	ldr	r3, [r7, #0x4]
 8011b24: 60fb         	str	r3, [r7, #0xc]
 8011b26: 68fb         	ldr	r3, [r7, #0xc]
 8011b28: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8011b2a: 68bb         	ldr	r3, [r7, #0x8]
 8011b2c: f383 8811    	msr	basepri, r3
; }
 8011b30: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011b32: f3bf 8f6f    	isb	sy
; }
 8011b36: bf00         	nop
; }
 8011b38: bf00         	nop
; }
 8011b3a: bf00         	nop
 8011b3c: 3714         	adds	r7, #0x14
 8011b3e: 46bd         	mov	sp, r7
 8011b40: bc80         	pop	{r7}
 8011b42: 4770         	bx	lr

08011b44 <arch_cpu_idle>:
; {
 8011b44: b480         	push	{r7}
 8011b46: b083         	sub	sp, #0xc
 8011b48: af00         	add	r7, sp, #0x0
;   __ASM volatile ("cpsid i" : : : "memory");
 8011b4a: b672         	cpsid i
; }
 8011b4c: bf00         	nop
 8011b4e: 2300         	movs	r3, #0x0
 8011b50: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8011b52: 687b         	ldr	r3, [r7, #0x4]
 8011b54: f383 8811    	msr	basepri, r3
; }
 8011b58: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011b5a: f3bf 8f6f    	isb	sy
; }
 8011b5e: bf00         	nop
;   __ASM volatile ("dsb 0xF":::"memory");
 8011b60: f3bf 8f4f    	dsb	sy
; }
 8011b64: bf00         	nop
; 	SLEEP_IF_ALLOWED(__WFI);
 8011b66: bf30         	wfi
;   __ASM volatile ("cpsie i" : : : "memory");
 8011b68: b662         	cpsie i
; }
 8011b6a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011b6c: f3bf 8f6f    	isb	sy
; }
 8011b70: bf00         	nop
; }
 8011b72: bf00         	nop
 8011b74: 370c         	adds	r7, #0xc
 8011b76: 46bd         	mov	sp, r7
 8011b78: bc80         	pop	{r7}
 8011b7a: 4770         	bx	lr

08011b7c <z_arm_interrupt_init>:
; {
 8011b7c: b580         	push	{r7, lr}
 8011b7e: b082         	sub	sp, #0x8
 8011b80: af00         	add	r7, sp, #0x0
; 	int irq = 0;
 8011b82: 2300         	movs	r3, #0x0
 8011b84: 607b         	str	r3, [r7, #0x4]
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 8011b86: e008         	b	0x8011b9a <z_arm_interrupt_init+0x1e> @ imm = #0x10
; 		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
 8011b88: 687b         	ldr	r3, [r7, #0x4]
 8011b8a: b25b         	sxtb	r3, r3
 8011b8c: 2101         	movs	r1, #0x1
 8011b8e: 4618         	mov	r0, r3
 8011b90: f7f2 f808    	bl	0x8003ba4 <__NVIC_SetPriority> @ imm = #-0xdff0
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 8011b94: 687b         	ldr	r3, [r7, #0x4]
 8011b96: 3301         	adds	r3, #0x1
 8011b98: 607b         	str	r3, [r7, #0x4]
 8011b9a: 687b         	ldr	r3, [r7, #0x4]
 8011b9c: 2b51         	cmp	r3, #0x51
 8011b9e: ddf3         	ble	0x8011b88 <z_arm_interrupt_init+0xc> @ imm = #-0x1a
; }
 8011ba0: bf00         	nop
 8011ba2: bf00         	nop
 8011ba4: 3708         	adds	r7, #0x8
 8011ba6: 46bd         	mov	sp, r7
 8011ba8: bd80         	pop	{r7, pc}

08011baa <zephyr_fputc>:
; {
 8011baa: b580         	push	{r7, lr}
 8011bac: b082         	sub	sp, #0x8
 8011bae: af00         	add	r7, sp, #0x0
 8011bb0: 6078         	str	r0, [r7, #0x4]
 8011bb2: 6039         	str	r1, [r7]
; 	return z_impl_zephyr_fputc(c, stream);
 8011bb4: 6839         	ldr	r1, [r7]
 8011bb6: 6878         	ldr	r0, [r7, #0x4]
 8011bb8: f7f2 f83c    	bl	0x8003c34 <z_impl_zephyr_fputc> @ imm = #-0xdf88
 8011bbc: 4603         	mov	r3, r0
; }
 8011bbe: 4618         	mov	r0, r3
 8011bc0: 3708         	adds	r7, #0x8
 8011bc2: 46bd         	mov	sp, r7
 8011bc4: bd80         	pop	{r7, pc}

08011bc6 <picolibc_put>:
; {
 8011bc6: b580         	push	{r7, lr}
 8011bc8: b082         	sub	sp, #0x8
 8011bca: af00         	add	r7, sp, #0x0
 8011bcc: 4603         	mov	r3, r0
 8011bce: 6039         	str	r1, [r7]
 8011bd0: 71fb         	strb	r3, [r7, #0x7]
; 	zephyr_fputc(a, f);
 8011bd2: 79fb         	ldrb	r3, [r7, #0x7]
 8011bd4: 6839         	ldr	r1, [r7]
 8011bd6: 4618         	mov	r0, r3
 8011bd8: f7ff ffe7    	bl	0x8011baa <zephyr_fputc> @ imm = #-0x32
; 	return 0;
 8011bdc: 2300         	movs	r3, #0x0
; }
 8011bde: 4618         	mov	r0, r3
 8011be0: 3708         	adds	r7, #0x8
 8011be2: 46bd         	mov	sp, r7
 8011be4: bd80         	pop	{r7, pc}

08011be6 <cbputc>:
; {
 8011be6: b580         	push	{r7, lr}
 8011be8: b084         	sub	sp, #0x10
 8011bea: af00         	add	r7, sp, #0x0
 8011bec: 4603         	mov	r3, r0
 8011bee: 6039         	str	r1, [r7]
 8011bf0: 71fb         	strb	r3, [r7, #0x7]
; 	struct cb_bits *s = (struct cb_bits *) _s;
 8011bf2: 683b         	ldr	r3, [r7]
 8011bf4: 60fb         	str	r3, [r7, #0xc]
; 	(*s->out) (c, s->ctx);
 8011bf6: 68fb         	ldr	r3, [r7, #0xc]
 8011bf8: 691b         	ldr	r3, [r3, #0x10]
 8011bfa: 79f8         	ldrb	r0, [r7, #0x7]
 8011bfc: 68fa         	ldr	r2, [r7, #0xc]
 8011bfe: 6952         	ldr	r2, [r2, #0x14]
 8011c00: 4611         	mov	r1, r2
 8011c02: 4798         	blx	r3
; 	return 0;
 8011c04: 2300         	movs	r3, #0x0
; }
 8011c06: 4618         	mov	r0, r3
 8011c08: 3710         	adds	r7, #0x10
 8011c0a: 46bd         	mov	sp, r7
 8011c0c: bd80         	pop	{r7, pc}

08011c0e <clock_control_on>:
; {
 8011c0e: b580         	push	{r7, lr}
 8011c10: b084         	sub	sp, #0x10
 8011c12: af00         	add	r7, sp, #0x0
 8011c14: 6078         	str	r0, [r7, #0x4]
 8011c16: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8011c18: 687b         	ldr	r3, [r7, #0x4]
 8011c1a: 689b         	ldr	r3, [r3, #0x8]
 8011c1c: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8011c1e: 68fb         	ldr	r3, [r7, #0xc]
 8011c20: 681b         	ldr	r3, [r3]
 8011c22: 6839         	ldr	r1, [r7]
 8011c24: 6878         	ldr	r0, [r7, #0x4]
 8011c26: 4798         	blx	r3
 8011c28: 4603         	mov	r3, r0
; }
 8011c2a: 4618         	mov	r0, r3
 8011c2c: 3710         	adds	r7, #0x10
 8011c2e: 46bd         	mov	sp, r7
 8011c30: bd80         	pop	{r7, pc}

08011c32 <z_stm32_hsem_lock>:
; {
 8011c32: b480         	push	{r7}
 8011c34: b083         	sub	sp, #0xc
 8011c36: af00         	add	r7, sp, #0x0
 8011c38: 6078         	str	r0, [r7, #0x4]
 8011c3a: 6039         	str	r1, [r7]
; }
 8011c3c: bf00         	nop
 8011c3e: 370c         	adds	r7, #0xc
 8011c40: 46bd         	mov	sp, r7
 8011c42: bc80         	pop	{r7}
 8011c44: 4770         	bx	lr

08011c46 <z_stm32_hsem_unlock>:
; {
 8011c46: b480         	push	{r7}
 8011c48: b083         	sub	sp, #0xc
 8011c4a: af00         	add	r7, sp, #0x0
 8011c4c: 6078         	str	r0, [r7, #0x4]
; }
 8011c4e: bf00         	nop
 8011c50: 370c         	adds	r7, #0xc
 8011c52: 46bd         	mov	sp, r7
 8011c54: bc80         	pop	{r7}
 8011c56: 4770         	bx	lr

08011c58 <stm32_exti_linenum_to_src_cfg_line>:
; {
 8011c58: b480         	push	{r7}
 8011c5a: b083         	sub	sp, #0xc
 8011c5c: af00         	add	r7, sp, #0x0
 8011c5e: 4603         	mov	r3, r0
 8011c60: 71fb         	strb	r3, [r7, #0x7]
; 	return (0xF << ((linenum % 4 * 4) + 16)) | (linenum / 4);
 8011c62: 79fb         	ldrb	r3, [r7, #0x7]
 8011c64: f003 0303    	and	r3, r3, #0x3
 8011c68: 3304         	adds	r3, #0x4
 8011c6a: 009b         	lsls	r3, r3, #0x2
 8011c6c: 220f         	movs	r2, #0xf
 8011c6e: fa02 f303    	lsl.w	r3, r2, r3
 8011c72: 79fa         	ldrb	r2, [r7, #0x7]
 8011c74: 0892         	lsrs	r2, r2, #0x2
 8011c76: b2d2         	uxtb	r2, r2
 8011c78: 4313         	orrs	r3, r2
; }
 8011c7a: 4618         	mov	r0, r3
 8011c7c: 370c         	adds	r7, #0xc
 8011c7e: 46bd         	mov	sp, r7
 8011c80: bc80         	pop	{r7}
 8011c82: 4770         	bx	lr

08011c84 <stm32_exti_is_pending>:
; {
 8011c84: b580         	push	{r7, lr}
 8011c86: b082         	sub	sp, #0x8
 8011c88: af00         	add	r7, sp, #0x0
 8011c8a: 6078         	str	r0, [r7, #0x4]
; 	return LL_EXTI_IsActiveFlag_0_31(line);
 8011c8c: 6878         	ldr	r0, [r7, #0x4]
 8011c8e: f7f2 f8ad    	bl	0x8003dec <LL_EXTI_IsActiveFlag_0_31> @ imm = #-0xdea6
 8011c92: 4603         	mov	r3, r0
; }
 8011c94: 4618         	mov	r0, r3
 8011c96: 3708         	adds	r7, #0x8
 8011c98: 46bd         	mov	sp, r7
 8011c9a: bd80         	pop	{r7, pc}

08011c9c <stm32_exti_clear_pending>:
; {
 8011c9c: b580         	push	{r7, lr}
 8011c9e: b082         	sub	sp, #0x8
 8011ca0: af00         	add	r7, sp, #0x0
 8011ca2: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_ClearFlag_0_31(line);
 8011ca4: 6878         	ldr	r0, [r7, #0x4]
 8011ca6: f7f2 f8b7    	bl	0x8003e18 <LL_EXTI_ClearFlag_0_31> @ imm = #-0xde92
; }
 8011caa: bf00         	nop
 8011cac: 3708         	adds	r7, #0x8
 8011cae: 46bd         	mov	sp, r7
 8011cb0: bd80         	pop	{r7, pc}

08011cb2 <linenum_to_ll_exti_line>:
; {
 8011cb2: b480         	push	{r7}
 8011cb4: b083         	sub	sp, #0xc
 8011cb6: af00         	add	r7, sp, #0x0
 8011cb8: 4603         	mov	r3, r0
 8011cba: 71fb         	strb	r3, [r7, #0x7]
; 	return BIT(linenum);
 8011cbc: 79fb         	ldrb	r3, [r7, #0x7]
 8011cbe: 2201         	movs	r2, #0x1
 8011cc0: fa02 f303    	lsl.w	r3, r2, r3
; }
 8011cc4: 4618         	mov	r0, r3
 8011cc6: 370c         	adds	r7, #0xc
 8011cc8: 46bd         	mov	sp, r7
 8011cca: bc80         	pop	{r7}
 8011ccc: 4770         	bx	lr

08011cce <ll_exti_line_to_linenum>:
; {
 8011cce: b480         	push	{r7}
 8011cd0: b083         	sub	sp, #0xc
 8011cd2: af00         	add	r7, sp, #0x0
 8011cd4: 6078         	str	r0, [r7, #0x4]
; 	return LOG2(line);
 8011cd6: 687b         	ldr	r3, [r7, #0x4]
 8011cd8: 2b00         	cmp	r3, #0x0
 8011cda: d007         	beq	0x8011cec <ll_exti_line_to_linenum+0x1e> @ imm = #0xe
 8011cdc: 687b         	ldr	r3, [r7, #0x4]
 8011cde: fab3 f383    	clz	r3, r3
 8011ce2: b2db         	uxtb	r3, r3
 8011ce4: f1c3 031f    	rsb.w	r3, r3, #0x1f
 8011ce8: b2db         	uxtb	r3, r3
 8011cea: e000         	b	0x8011cee <ll_exti_line_to_linenum+0x20> @ imm = #0x0
 8011cec: 23ff         	movs	r3, #0xff
; }
 8011cee: 4618         	mov	r0, r3
 8011cf0: 370c         	adds	r7, #0xc
 8011cf2: 46bd         	mov	sp, r7
 8011cf4: bc80         	pop	{r7}
 8011cf6: 4770         	bx	lr

08011cf8 <stm32_gpio_intc_get_pin_irq_line>:
; {
 8011cf8: b580         	push	{r7, lr}
 8011cfa: b082         	sub	sp, #0x8
 8011cfc: af00         	add	r7, sp, #0x0
 8011cfe: 6078         	str	r0, [r7, #0x4]
 8011d00: 460b         	mov	r3, r1
 8011d02: 70fb         	strb	r3, [r7, #0x3]
; 	return linenum_to_ll_exti_line(pin);
 8011d04: 78fb         	ldrb	r3, [r7, #0x3]
 8011d06: 4618         	mov	r0, r3
 8011d08: f7ff ffd3    	bl	0x8011cb2 <linenum_to_ll_exti_line> @ imm = #-0x5a
 8011d0c: 4603         	mov	r3, r0
; }
 8011d0e: 4618         	mov	r0, r3
 8011d10: 3708         	adds	r7, #0x8
 8011d12: 46bd         	mov	sp, r7
 8011d14: bd80         	pop	{r7, pc}

08011d16 <stm32_gpio_intc_disable_line>:
; {
 8011d16: b580         	push	{r7, lr}
 8011d18: b082         	sub	sp, #0x8
 8011d1a: af00         	add	r7, sp, #0x0
 8011d1c: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_DisableIT_0_31(line);
 8011d1e: 6878         	ldr	r0, [r7, #0x4]
 8011d20: f7f2 f80a    	bl	0x8003d38 <LL_EXTI_DisableIT_0_31> @ imm = #-0xdfec
; }
 8011d24: bf00         	nop
 8011d26: 3708         	adds	r7, #0x8
 8011d28: 46bd         	mov	sp, r7
 8011d2a: bd80         	pop	{r7, pc}

08011d2c <stm32_exti_set_line_src_port>:
; {
 8011d2c: b580         	push	{r7, lr}
 8011d2e: b084         	sub	sp, #0x10
 8011d30: af00         	add	r7, sp, #0x0
 8011d32: 4603         	mov	r3, r0
 8011d34: 6039         	str	r1, [r7]
 8011d36: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 8011d38: 79fb         	ldrb	r3, [r7, #0x7]
 8011d3a: 4618         	mov	r0, r3
 8011d3c: f7ff ff8c    	bl	0x8011c58 <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0xe8
 8011d40: 60f8         	str	r0, [r7, #0xc]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8011d42: f44f 1180    	mov.w	r1, #0x100000
 8011d46: 2000         	movs	r0, #0x0
 8011d48: f7ff ff73    	bl	0x8011c32 <z_stm32_hsem_lock> @ imm = #-0x11a
; 	LL_SYSCFG_SetEXTISource(port, ll_line);
 8011d4c: 68f9         	ldr	r1, [r7, #0xc]
 8011d4e: 6838         	ldr	r0, [r7]
 8011d50: f7f2 f870    	bl	0x8003e34 <LL_SYSCFG_SetEXTISource> @ imm = #-0xdf20
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 8011d54: 2000         	movs	r0, #0x0
 8011d56: f7ff ff76    	bl	0x8011c46 <z_stm32_hsem_unlock> @ imm = #-0x114
; }
 8011d5a: bf00         	nop
 8011d5c: 3710         	adds	r7, #0x10
 8011d5e: 46bd         	mov	sp, r7
 8011d60: bd80         	pop	{r7, pc}

08011d62 <stm32_exti_get_line_src_port>:
; {
 8011d62: b580         	push	{r7, lr}
 8011d64: b084         	sub	sp, #0x10
 8011d66: af00         	add	r7, sp, #0x0
 8011d68: 4603         	mov	r3, r0
 8011d6a: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 8011d6c: 79fb         	ldrb	r3, [r7, #0x7]
 8011d6e: 4618         	mov	r0, r3
 8011d70: f7ff ff72    	bl	0x8011c58 <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0x11c
 8011d74: 60f8         	str	r0, [r7, #0xc]
; 	port = LL_SYSCFG_GetEXTISource(ll_line);
 8011d76: 68f8         	ldr	r0, [r7, #0xc]
 8011d78: f7f2 f890    	bl	0x8003e9c <LL_SYSCFG_GetEXTISource> @ imm = #-0xdee0
 8011d7c: 60b8         	str	r0, [r7, #0x8]
; 	return port;
 8011d7e: 68bb         	ldr	r3, [r7, #0x8]
; }
 8011d80: 4618         	mov	r0, r3
 8011d82: 3710         	adds	r7, #0x10
 8011d84: 46bd         	mov	sp, r7
 8011d86: bd80         	pop	{r7, pc}

08011d88 <k_sem_init>:
; {
 8011d88: b580         	push	{r7, lr}
 8011d8a: b084         	sub	sp, #0x10
 8011d8c: af00         	add	r7, sp, #0x0
 8011d8e: 60f8         	str	r0, [r7, #0xc]
 8011d90: 60b9         	str	r1, [r7, #0x8]
 8011d92: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 8011d94: 687a         	ldr	r2, [r7, #0x4]
 8011d96: 68b9         	ldr	r1, [r7, #0x8]
 8011d98: 68f8         	ldr	r0, [r7, #0xc]
 8011d9a: f005 fd17    	bl	0x80177cc <z_impl_k_sem_init> @ imm = #0x5a2e
 8011d9e: 4603         	mov	r3, r0
; }
 8011da0: 4618         	mov	r0, r3
 8011da2: 3710         	adds	r7, #0x10
 8011da4: 46bd         	mov	sp, r7
 8011da6: bd80         	pop	{r7, pc}

08011da8 <k_sem_take>:
; {
 8011da8: b580         	push	{r7, lr}
 8011daa: b084         	sub	sp, #0x10
 8011dac: af00         	add	r7, sp, #0x0
 8011dae: 60f8         	str	r0, [r7, #0xc]
 8011db0: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 8011db4: e9d7 2300    	ldrd	r2, r3, [r7]
 8011db8: 68f8         	ldr	r0, [r7, #0xc]
 8011dba: f7fa fb49    	bl	0x800c450 <z_impl_k_sem_take> @ imm = #-0x596e
 8011dbe: 4603         	mov	r3, r0
; }
 8011dc0: 4618         	mov	r0, r3
 8011dc2: 3710         	adds	r7, #0x10
 8011dc4: 46bd         	mov	sp, r7
 8011dc6: bd80         	pop	{r7, pc}

08011dc8 <k_sem_give>:
; {
 8011dc8: b580         	push	{r7, lr}
 8011dca: b082         	sub	sp, #0x8
 8011dcc: af00         	add	r7, sp, #0x0
 8011dce: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 8011dd0: 6878         	ldr	r0, [r7, #0x4]
 8011dd2: f7fa faaf    	bl	0x800c334 <z_impl_k_sem_give> @ imm = #-0x5aa2
; }
 8011dd6: bf00         	nop
 8011dd8: 3708         	adds	r7, #0x8
 8011dda: 46bd         	mov	sp, r7
 8011ddc: bd80         	pop	{r7, pc}

08011dde <z_impl_can_get_core_clock>:
; {
 8011dde: b580         	push	{r7, lr}
 8011de0: b084         	sub	sp, #0x10
 8011de2: af00         	add	r7, sp, #0x0
 8011de4: 6078         	str	r0, [r7, #0x4]
 8011de6: 6039         	str	r1, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8011de8: 687b         	ldr	r3, [r7, #0x4]
 8011dea: 689b         	ldr	r3, [r3, #0x8]
 8011dec: 60fb         	str	r3, [r7, #0xc]
; 	return api->get_core_clock(dev, rate);
 8011dee: 68fb         	ldr	r3, [r7, #0xc]
 8011df0: 6a9b         	ldr	r3, [r3, #0x28]
 8011df2: 6839         	ldr	r1, [r7]
 8011df4: 6878         	ldr	r0, [r7, #0x4]
 8011df6: 4798         	blx	r3
 8011df8: 4603         	mov	r3, r0
; }
 8011dfa: 4618         	mov	r0, r3
 8011dfc: 3710         	adds	r7, #0x10
 8011dfe: 46bd         	mov	sp, r7
 8011e00: bd80         	pop	{r7, pc}

08011e02 <z_impl_can_get_timing_min>:
; {
 8011e02: b480         	push	{r7}
 8011e04: b085         	sub	sp, #0x14
 8011e06: af00         	add	r7, sp, #0x0
 8011e08: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8011e0a: 687b         	ldr	r3, [r7, #0x4]
 8011e0c: 689b         	ldr	r3, [r3, #0x8]
 8011e0e: 60fb         	str	r3, [r7, #0xc]
; 	return &api->timing_min;
 8011e10: 68fb         	ldr	r3, [r7, #0xc]
 8011e12: 3330         	adds	r3, #0x30
; }
 8011e14: 4618         	mov	r0, r3
 8011e16: 3714         	adds	r7, #0x14
 8011e18: 46bd         	mov	sp, r7
 8011e1a: bc80         	pop	{r7}
 8011e1c: 4770         	bx	lr

08011e1e <z_impl_can_get_timing_max>:
; {
 8011e1e: b480         	push	{r7}
 8011e20: b085         	sub	sp, #0x14
 8011e22: af00         	add	r7, sp, #0x0
 8011e24: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8011e26: 687b         	ldr	r3, [r7, #0x4]
 8011e28: 689b         	ldr	r3, [r3, #0x8]
 8011e2a: 60fb         	str	r3, [r7, #0xc]
; 	return &api->timing_max;
 8011e2c: 68fb         	ldr	r3, [r7, #0xc]
 8011e2e: 333a         	adds	r3, #0x3a
; }
 8011e30: 4618         	mov	r0, r3
 8011e32: 3714         	adds	r7, #0x14
 8011e34: 46bd         	mov	sp, r7
 8011e36: bc80         	pop	{r7}
 8011e38: 4770         	bx	lr

08011e3a <can_get_core_clock>:
; {
 8011e3a: b580         	push	{r7, lr}
 8011e3c: b082         	sub	sp, #0x8
 8011e3e: af00         	add	r7, sp, #0x0
 8011e40: 6078         	str	r0, [r7, #0x4]
 8011e42: 6039         	str	r1, [r7]
; 	return z_impl_can_get_core_clock(dev, rate);
 8011e44: 6839         	ldr	r1, [r7]
 8011e46: 6878         	ldr	r0, [r7, #0x4]
 8011e48: f7ff ffc9    	bl	0x8011dde <z_impl_can_get_core_clock> @ imm = #-0x6e
 8011e4c: 4603         	mov	r3, r0
; }
 8011e4e: 4618         	mov	r0, r3
 8011e50: 3708         	adds	r7, #0x8
 8011e52: 46bd         	mov	sp, r7
 8011e54: bd80         	pop	{r7, pc}

08011e56 <can_get_timing_min>:
; {
 8011e56: b580         	push	{r7, lr}
 8011e58: b082         	sub	sp, #0x8
 8011e5a: af00         	add	r7, sp, #0x0
 8011e5c: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_get_timing_min(dev);
 8011e5e: 6878         	ldr	r0, [r7, #0x4]
 8011e60: f7ff ffcf    	bl	0x8011e02 <z_impl_can_get_timing_min> @ imm = #-0x62
 8011e64: 4603         	mov	r3, r0
; }
 8011e66: 4618         	mov	r0, r3
 8011e68: 3708         	adds	r7, #0x8
 8011e6a: 46bd         	mov	sp, r7
 8011e6c: bd80         	pop	{r7, pc}

08011e6e <can_get_timing_max>:
; {
 8011e6e: b580         	push	{r7, lr}
 8011e70: b082         	sub	sp, #0x8
 8011e72: af00         	add	r7, sp, #0x0
 8011e74: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_get_timing_max(dev);
 8011e76: 6878         	ldr	r0, [r7, #0x4]
 8011e78: f7ff ffd1    	bl	0x8011e1e <z_impl_can_get_timing_max> @ imm = #-0x5e
 8011e7c: 4603         	mov	r3, r0
; }
 8011e7e: 4618         	mov	r0, r3
 8011e80: 3708         	adds	r7, #0x8
 8011e82: 46bd         	mov	sp, r7
 8011e84: bd80         	pop	{r7, pc}

08011e86 <z_log_msg_runtime_create>:
; {
 8011e86: b580         	push	{r7, lr}
 8011e88: b08a         	sub	sp, #0x28
 8011e8a: af04         	add	r7, sp, #0x10
 8011e8c: 60b9         	str	r1, [r7, #0x8]
 8011e8e: 607b         	str	r3, [r7, #0x4]
 8011e90: 4603         	mov	r3, r0
 8011e92: 73fb         	strb	r3, [r7, #0xf]
 8011e94: 4613         	mov	r3, r2
 8011e96: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8011e98: f107 032c    	add.w	r3, r7, #0x2c
 8011e9c: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8011e9e: 7bba         	ldrb	r2, [r7, #0xe]
 8011ea0: 7bf8         	ldrb	r0, [r7, #0xf]
 8011ea2: 697b         	ldr	r3, [r7, #0x14]
 8011ea4: 9303         	str	r3, [sp, #0xc]
 8011ea6: 6abb         	ldr	r3, [r7, #0x28]
 8011ea8: 9302         	str	r3, [sp, #0x8]
 8011eaa: 6a7b         	ldr	r3, [r7, #0x24]
 8011eac: 9301         	str	r3, [sp, #0x4]
 8011eae: 6a3b         	ldr	r3, [r7, #0x20]
 8011eb0: 9300         	str	r3, [sp]
 8011eb2: 687b         	ldr	r3, [r7, #0x4]
 8011eb4: 68b9         	ldr	r1, [r7, #0x8]
 8011eb6: f7f0 f949    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0xfd6e
; }
 8011eba: bf00         	nop
 8011ebc: 3718         	adds	r7, #0x18
 8011ebe: 46bd         	mov	sp, r7
 8011ec0: bd80         	pop	{r7, pc}

08011ec2 <can_tx_default_cb>:
; {
 8011ec2: b580         	push	{r7, lr}
 8011ec4: b086         	sub	sp, #0x18
 8011ec6: af00         	add	r7, sp, #0x0
 8011ec8: 60f8         	str	r0, [r7, #0xc]
 8011eca: 60b9         	str	r1, [r7, #0x8]
 8011ecc: 607a         	str	r2, [r7, #0x4]
; 	struct can_tx_default_cb_ctx *ctx = user_data;
 8011ece: 687b         	ldr	r3, [r7, #0x4]
 8011ed0: 617b         	str	r3, [r7, #0x14]
; 	ctx->status = error;
 8011ed2: 697b         	ldr	r3, [r7, #0x14]
 8011ed4: 68ba         	ldr	r2, [r7, #0x8]
 8011ed6: 611a         	str	r2, [r3, #0x10]
; 	k_sem_give(&ctx->done);
 8011ed8: 697b         	ldr	r3, [r7, #0x14]
 8011eda: 4618         	mov	r0, r3
 8011edc: f7ff ff74    	bl	0x8011dc8 <k_sem_give>  @ imm = #-0x118
; }
 8011ee0: bf00         	nop
 8011ee2: 3718         	adds	r7, #0x18
 8011ee4: 46bd         	mov	sp, r7
 8011ee6: bd80         	pop	{r7, pc}

08011ee8 <check_timing_in_range>:
; {
 8011ee8: b480         	push	{r7}
 8011eea: b085         	sub	sp, #0x14
 8011eec: af00         	add	r7, sp, #0x0
 8011eee: 60f8         	str	r0, [r7, #0xc]
 8011ef0: 60b9         	str	r1, [r7, #0x8]
 8011ef2: 607a         	str	r2, [r7, #0x4]
; 	if (!IN_RANGE(timing->sjw, min->sjw, max->sjw) ||
 8011ef4: 68fb         	ldr	r3, [r7, #0xc]
 8011ef6: 881a         	ldrh	r2, [r3]
 8011ef8: 68bb         	ldr	r3, [r7, #0x8]
 8011efa: 881b         	ldrh	r3, [r3]
 8011efc: 429a         	cmp	r2, r3
 8011efe: d335         	blo	0x8011f6c <check_timing_in_range+0x84> @ imm = #0x6a
 8011f00: 68fb         	ldr	r3, [r7, #0xc]
 8011f02: 881a         	ldrh	r2, [r3]
 8011f04: 687b         	ldr	r3, [r7, #0x4]
 8011f06: 881b         	ldrh	r3, [r3]
 8011f08: 429a         	cmp	r2, r3
 8011f0a: d82f         	bhi	0x8011f6c <check_timing_in_range+0x84> @ imm = #0x5e
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 8011f0c: 68fb         	ldr	r3, [r7, #0xc]
 8011f0e: 885a         	ldrh	r2, [r3, #0x2]
 8011f10: 68bb         	ldr	r3, [r7, #0x8]
 8011f12: 885b         	ldrh	r3, [r3, #0x2]
; 	if (!IN_RANGE(timing->sjw, min->sjw, max->sjw) ||
 8011f14: 429a         	cmp	r2, r3
 8011f16: d329         	blo	0x8011f6c <check_timing_in_range+0x84> @ imm = #0x52
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 8011f18: 68fb         	ldr	r3, [r7, #0xc]
 8011f1a: 885a         	ldrh	r2, [r3, #0x2]
 8011f1c: 687b         	ldr	r3, [r7, #0x4]
 8011f1e: 885b         	ldrh	r3, [r3, #0x2]
 8011f20: 429a         	cmp	r2, r3
 8011f22: d823         	bhi	0x8011f6c <check_timing_in_range+0x84> @ imm = #0x46
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 8011f24: 68fb         	ldr	r3, [r7, #0xc]
 8011f26: 889a         	ldrh	r2, [r3, #0x4]
 8011f28: 68bb         	ldr	r3, [r7, #0x8]
 8011f2a: 889b         	ldrh	r3, [r3, #0x4]
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 8011f2c: 429a         	cmp	r2, r3
 8011f2e: d31d         	blo	0x8011f6c <check_timing_in_range+0x84> @ imm = #0x3a
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 8011f30: 68fb         	ldr	r3, [r7, #0xc]
 8011f32: 889a         	ldrh	r2, [r3, #0x4]
 8011f34: 687b         	ldr	r3, [r7, #0x4]
 8011f36: 889b         	ldrh	r3, [r3, #0x4]
 8011f38: 429a         	cmp	r2, r3
 8011f3a: d817         	bhi	0x8011f6c <check_timing_in_range+0x84> @ imm = #0x2e
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 8011f3c: 68fb         	ldr	r3, [r7, #0xc]
 8011f3e: 88da         	ldrh	r2, [r3, #0x6]
 8011f40: 68bb         	ldr	r3, [r7, #0x8]
 8011f42: 88db         	ldrh	r3, [r3, #0x6]
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 8011f44: 429a         	cmp	r2, r3
 8011f46: d311         	blo	0x8011f6c <check_timing_in_range+0x84> @ imm = #0x22
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 8011f48: 68fb         	ldr	r3, [r7, #0xc]
 8011f4a: 88da         	ldrh	r2, [r3, #0x6]
 8011f4c: 687b         	ldr	r3, [r7, #0x4]
 8011f4e: 88db         	ldrh	r3, [r3, #0x6]
 8011f50: 429a         	cmp	r2, r3
 8011f52: d80b         	bhi	0x8011f6c <check_timing_in_range+0x84> @ imm = #0x16
; 	    !IN_RANGE(timing->prescaler, min->prescaler, max->prescaler)) {
 8011f54: 68fb         	ldr	r3, [r7, #0xc]
 8011f56: 891a         	ldrh	r2, [r3, #0x8]
 8011f58: 68bb         	ldr	r3, [r7, #0x8]
 8011f5a: 891b         	ldrh	r3, [r3, #0x8]
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 8011f5c: 429a         	cmp	r2, r3
 8011f5e: d305         	blo	0x8011f6c <check_timing_in_range+0x84> @ imm = #0xa
; 	    !IN_RANGE(timing->prescaler, min->prescaler, max->prescaler)) {
 8011f60: 68fb         	ldr	r3, [r7, #0xc]
 8011f62: 891a         	ldrh	r2, [r3, #0x8]
 8011f64: 687b         	ldr	r3, [r7, #0x4]
 8011f66: 891b         	ldrh	r3, [r3, #0x8]
 8011f68: 429a         	cmp	r2, r3
 8011f6a: d902         	bls	0x8011f72 <check_timing_in_range+0x8a> @ imm = #0x4
; 		return -ENOTSUP;
 8011f6c: f06f 0385    	mvn	r3, #0x85
 8011f70: e00f         	b	0x8011f92 <check_timing_in_range+0xaa> @ imm = #0x1e
; 	if ((timing->sjw > timing->phase_seg1) || (timing->sjw > timing->phase_seg2)) {
 8011f72: 68fb         	ldr	r3, [r7, #0xc]
 8011f74: 881a         	ldrh	r2, [r3]
 8011f76: 68fb         	ldr	r3, [r7, #0xc]
 8011f78: 889b         	ldrh	r3, [r3, #0x4]
 8011f7a: 429a         	cmp	r2, r3
 8011f7c: d805         	bhi	0x8011f8a <check_timing_in_range+0xa2> @ imm = #0xa
 8011f7e: 68fb         	ldr	r3, [r7, #0xc]
 8011f80: 881a         	ldrh	r2, [r3]
 8011f82: 68fb         	ldr	r3, [r7, #0xc]
 8011f84: 88db         	ldrh	r3, [r3, #0x6]
 8011f86: 429a         	cmp	r2, r3
 8011f88: d902         	bls	0x8011f90 <check_timing_in_range+0xa8> @ imm = #0x4
; 		return -ENOTSUP;
 8011f8a: f06f 0385    	mvn	r3, #0x85
 8011f8e: e000         	b	0x8011f92 <check_timing_in_range+0xaa> @ imm = #0x0
; 	return 0;
 8011f90: 2300         	movs	r3, #0x0
; }
 8011f92: 4618         	mov	r0, r3
 8011f94: 3714         	adds	r7, #0x14
 8011f96: 46bd         	mov	sp, r7
 8011f98: bc80         	pop	{r7}
 8011f9a: 4770         	bx	lr

08011f9c <z_impl_can_set_timing>:
; {
 8011f9c: b580         	push	{r7, lr}
 8011f9e: b086         	sub	sp, #0x18
 8011fa0: af00         	add	r7, sp, #0x0
 8011fa2: 6078         	str	r0, [r7, #0x4]
 8011fa4: 6039         	str	r1, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8011fa6: 687b         	ldr	r3, [r7, #0x4]
 8011fa8: 689b         	ldr	r3, [r3, #0x8]
 8011faa: 617b         	str	r3, [r7, #0x14]
; 	const struct can_timing *min = can_get_timing_min(dev);
 8011fac: 6878         	ldr	r0, [r7, #0x4]
 8011fae: f7ff ff52    	bl	0x8011e56 <can_get_timing_min> @ imm = #-0x15c
 8011fb2: 6138         	str	r0, [r7, #0x10]
; 	const struct can_timing *max = can_get_timing_max(dev);
 8011fb4: 6878         	ldr	r0, [r7, #0x4]
 8011fb6: f7ff ff5a    	bl	0x8011e6e <can_get_timing_max> @ imm = #-0x14c
 8011fba: 60f8         	str	r0, [r7, #0xc]
; 	err = check_timing_in_range(timing, min, max);
 8011fbc: 68fa         	ldr	r2, [r7, #0xc]
 8011fbe: 6939         	ldr	r1, [r7, #0x10]
 8011fc0: 6838         	ldr	r0, [r7]
 8011fc2: f7ff ff91    	bl	0x8011ee8 <check_timing_in_range> @ imm = #-0xde
 8011fc6: 60b8         	str	r0, [r7, #0x8]
; 	if (err != 0) {
 8011fc8: 68bb         	ldr	r3, [r7, #0x8]
 8011fca: 2b00         	cmp	r3, #0x0
 8011fcc: d001         	beq	0x8011fd2 <z_impl_can_set_timing+0x36> @ imm = #0x2
; 		return err;
 8011fce: 68bb         	ldr	r3, [r7, #0x8]
 8011fd0: e005         	b	0x8011fde <z_impl_can_set_timing+0x42> @ imm = #0xa
; 	return api->set_timing(dev, timing);
 8011fd2: 697b         	ldr	r3, [r7, #0x14]
 8011fd4: 691b         	ldr	r3, [r3, #0x10]
 8011fd6: 6839         	ldr	r1, [r7]
 8011fd8: 6878         	ldr	r0, [r7, #0x4]
 8011fda: 4798         	blx	r3
 8011fdc: 4603         	mov	r3, r0
; }
 8011fde: 4618         	mov	r0, r3
 8011fe0: 3718         	adds	r7, #0x18
 8011fe2: 46bd         	mov	sp, r7
 8011fe4: bd80         	pop	{r7, pc}

08011fe6 <device_is_ready>:
; {
 8011fe6: b580         	push	{r7, lr}
 8011fe8: b082         	sub	sp, #0x8
 8011fea: af00         	add	r7, sp, #0x0
 8011fec: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8011fee: 6878         	ldr	r0, [r7, #0x4]
 8011ff0: f004 fef3    	bl	0x8016dda <z_impl_device_is_ready> @ imm = #0x4de6
 8011ff4: 4603         	mov	r3, r0
; }
 8011ff6: 4618         	mov	r0, r3
 8011ff8: 3708         	adds	r7, #0x8
 8011ffa: 46bd         	mov	sp, r7
 8011ffc: bd80         	pop	{r7, pc}

08011ffe <arch_k_cycle_get_32>:
; {
 8011ffe: b580         	push	{r7, lr}
 8012000: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 8012002: f7f7 fbd1    	bl	0x80097a8 <sys_clock_cycle_get_32> @ imm = #-0x885e
 8012006: 4603         	mov	r3, r0
; }
 8012008: 4618         	mov	r0, r3
 801200a: bd80         	pop	{r7, pc}

0801200c <k_cycle_get_32>:
; {
 801200c: b580         	push	{r7, lr}
 801200e: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 8012010: f7ff fff5    	bl	0x8011ffe <arch_k_cycle_get_32> @ imm = #-0x16
 8012014: 4603         	mov	r3, r0
; }
 8012016: 4618         	mov	r0, r3
 8012018: bd80         	pop	{r7, pc}

0801201a <k_mutex_init>:
; {
 801201a: b580         	push	{r7, lr}
 801201c: b082         	sub	sp, #0x8
 801201e: af00         	add	r7, sp, #0x0
 8012020: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_init(mutex);
 8012022: 6878         	ldr	r0, [r7, #0x4]
 8012024: f005 fafe    	bl	0x8017624 <z_impl_k_mutex_init> @ imm = #0x55fc
 8012028: 4603         	mov	r3, r0
; }
 801202a: 4618         	mov	r0, r3
 801202c: 3708         	adds	r7, #0x8
 801202e: 46bd         	mov	sp, r7
 8012030: bd80         	pop	{r7, pc}

08012032 <k_mutex_lock>:
; {
 8012032: b580         	push	{r7, lr}
 8012034: b084         	sub	sp, #0x10
 8012036: af00         	add	r7, sp, #0x0
 8012038: 60f8         	str	r0, [r7, #0xc]
 801203a: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_mutex_lock(mutex, timeout);
 801203e: e9d7 2300    	ldrd	r2, r3, [r7]
 8012042: 68f8         	ldr	r0, [r7, #0xc]
 8012044: f7f9 fe4e    	bl	0x800bce4 <z_impl_k_mutex_lock> @ imm = #-0x6364
 8012048: 4603         	mov	r3, r0
; }
 801204a: 4618         	mov	r0, r3
 801204c: 3710         	adds	r7, #0x10
 801204e: 46bd         	mov	sp, r7
 8012050: bd80         	pop	{r7, pc}

08012052 <k_mutex_unlock>:
; {
 8012052: b580         	push	{r7, lr}
 8012054: b082         	sub	sp, #0x8
 8012056: af00         	add	r7, sp, #0x0
 8012058: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_unlock(mutex);
 801205a: 6878         	ldr	r0, [r7, #0x4]
 801205c: f7fa f872    	bl	0x800c144 <z_impl_k_mutex_unlock> @ imm = #-0x5f1c
 8012060: 4603         	mov	r3, r0
; }
 8012062: 4618         	mov	r0, r3
 8012064: 3708         	adds	r7, #0x8
 8012066: 46bd         	mov	sp, r7
 8012068: bd80         	pop	{r7, pc}

0801206a <k_sem_init>:
; {
 801206a: b580         	push	{r7, lr}
 801206c: b084         	sub	sp, #0x10
 801206e: af00         	add	r7, sp, #0x0
 8012070: 60f8         	str	r0, [r7, #0xc]
 8012072: 60b9         	str	r1, [r7, #0x8]
 8012074: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 8012076: 687a         	ldr	r2, [r7, #0x4]
 8012078: 68b9         	ldr	r1, [r7, #0x8]
 801207a: 68f8         	ldr	r0, [r7, #0xc]
 801207c: f005 fba6    	bl	0x80177cc <z_impl_k_sem_init> @ imm = #0x574c
 8012080: 4603         	mov	r3, r0
; }
 8012082: 4618         	mov	r0, r3
 8012084: 3710         	adds	r7, #0x10
 8012086: 46bd         	mov	sp, r7
 8012088: bd80         	pop	{r7, pc}

0801208a <k_sem_take>:
; {
 801208a: b580         	push	{r7, lr}
 801208c: b084         	sub	sp, #0x10
 801208e: af00         	add	r7, sp, #0x0
 8012090: 60f8         	str	r0, [r7, #0xc]
 8012092: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 8012096: e9d7 2300    	ldrd	r2, r3, [r7]
 801209a: 68f8         	ldr	r0, [r7, #0xc]
 801209c: f7fa f9d8    	bl	0x800c450 <z_impl_k_sem_take> @ imm = #-0x5c50
 80120a0: 4603         	mov	r3, r0
; }
 80120a2: 4618         	mov	r0, r3
 80120a4: 3710         	adds	r7, #0x10
 80120a6: 46bd         	mov	sp, r7
 80120a8: bd80         	pop	{r7, pc}

080120aa <k_sem_give>:
; {
 80120aa: b580         	push	{r7, lr}
 80120ac: b082         	sub	sp, #0x8
 80120ae: af00         	add	r7, sp, #0x0
 80120b0: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 80120b2: 6878         	ldr	r0, [r7, #0x4]
 80120b4: f7fa f93e    	bl	0x800c334 <z_impl_k_sem_give> @ imm = #-0x5d84
; }
 80120b8: bf00         	nop
 80120ba: 3708         	adds	r7, #0x8
 80120bc: 46bd         	mov	sp, r7
 80120be: bd80         	pop	{r7, pc}

080120c0 <can_calc_timing>:
; {
 80120c0: b580         	push	{r7, lr}
 80120c2: b084         	sub	sp, #0x10
 80120c4: af00         	add	r7, sp, #0x0
 80120c6: 60f8         	str	r0, [r7, #0xc]
 80120c8: 60b9         	str	r1, [r7, #0x8]
 80120ca: 607a         	str	r2, [r7, #0x4]
 80120cc: 807b         	strh	r3, [r7, #0x2]
; 	return z_impl_can_calc_timing(dev, res, bitrate, sample_pnt);
 80120ce: 887b         	ldrh	r3, [r7, #0x2]
 80120d0: 687a         	ldr	r2, [r7, #0x4]
 80120d2: 68b9         	ldr	r1, [r7, #0x8]
 80120d4: 68f8         	ldr	r0, [r7, #0xc]
 80120d6: f7f2 fbc5    	bl	0x8004864 <z_impl_can_calc_timing> @ imm = #-0xd876
 80120da: 4603         	mov	r3, r0
; }
 80120dc: 4618         	mov	r0, r3
 80120de: 3710         	adds	r7, #0x10
 80120e0: 46bd         	mov	sp, r7
 80120e2: bd80         	pop	{r7, pc}

080120e4 <can_set_timing>:
; {
 80120e4: b580         	push	{r7, lr}
 80120e6: b082         	sub	sp, #0x8
 80120e8: af00         	add	r7, sp, #0x0
 80120ea: 6078         	str	r0, [r7, #0x4]
 80120ec: 6039         	str	r1, [r7]
; 	return z_impl_can_set_timing(dev, timing);
 80120ee: 6839         	ldr	r1, [r7]
 80120f0: 6878         	ldr	r0, [r7, #0x4]
 80120f2: f7ff ff53    	bl	0x8011f9c <z_impl_can_set_timing> @ imm = #-0x15a
 80120f6: 4603         	mov	r3, r0
; }
 80120f8: 4618         	mov	r0, r3
 80120fa: 3708         	adds	r7, #0x8
 80120fc: 46bd         	mov	sp, r7
 80120fe: bd80         	pop	{r7, pc}

08012100 <can_transceiver_enable>:
; {
 8012100: b580         	push	{r7, lr}
 8012102: b084         	sub	sp, #0x10
 8012104: af00         	add	r7, sp, #0x0
 8012106: 6078         	str	r0, [r7, #0x4]
 8012108: 6039         	str	r1, [r7]
; 	const struct can_transceiver_driver_api *api =
 801210a: 687b         	ldr	r3, [r7, #0x4]
 801210c: 689b         	ldr	r3, [r3, #0x8]
 801210e: 60fb         	str	r3, [r7, #0xc]
; 	return api->enable(dev, mode);
 8012110: 68fb         	ldr	r3, [r7, #0xc]
 8012112: 681b         	ldr	r3, [r3]
 8012114: 6839         	ldr	r1, [r7]
 8012116: 6878         	ldr	r0, [r7, #0x4]
 8012118: 4798         	blx	r3
 801211a: 4603         	mov	r3, r0
; }
 801211c: 4618         	mov	r0, r3
 801211e: 3710         	adds	r7, #0x10
 8012120: 46bd         	mov	sp, r7
 8012122: bd80         	pop	{r7, pc}

08012124 <can_transceiver_disable>:
; {
 8012124: b580         	push	{r7, lr}
 8012126: b084         	sub	sp, #0x10
 8012128: af00         	add	r7, sp, #0x0
 801212a: 6078         	str	r0, [r7, #0x4]
; 	const struct can_transceiver_driver_api *api =
 801212c: 687b         	ldr	r3, [r7, #0x4]
 801212e: 689b         	ldr	r3, [r3, #0x8]
 8012130: 60fb         	str	r3, [r7, #0xc]
; 	return api->disable(dev);
 8012132: 68fb         	ldr	r3, [r7, #0xc]
 8012134: 685b         	ldr	r3, [r3, #0x4]
 8012136: 6878         	ldr	r0, [r7, #0x4]
 8012138: 4798         	blx	r3
 801213a: 4603         	mov	r3, r0
; }
 801213c: 4618         	mov	r0, r3
 801213e: 3710         	adds	r7, #0x10
 8012140: 46bd         	mov	sp, r7
 8012142: bd80         	pop	{r7, pc}

08012144 <clock_control_on>:
; {
 8012144: b580         	push	{r7, lr}
 8012146: b084         	sub	sp, #0x10
 8012148: af00         	add	r7, sp, #0x0
 801214a: 6078         	str	r0, [r7, #0x4]
 801214c: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801214e: 687b         	ldr	r3, [r7, #0x4]
 8012150: 689b         	ldr	r3, [r3, #0x8]
 8012152: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8012154: 68fb         	ldr	r3, [r7, #0xc]
 8012156: 681b         	ldr	r3, [r3]
 8012158: 6839         	ldr	r1, [r7]
 801215a: 6878         	ldr	r0, [r7, #0x4]
 801215c: 4798         	blx	r3
 801215e: 4603         	mov	r3, r0
; }
 8012160: 4618         	mov	r0, r3
 8012162: 3710         	adds	r7, #0x10
 8012164: 46bd         	mov	sp, r7
 8012166: bd80         	pop	{r7, pc}

08012168 <clock_control_get_rate>:
; {
 8012168: b580         	push	{r7, lr}
 801216a: b086         	sub	sp, #0x18
 801216c: af00         	add	r7, sp, #0x0
 801216e: 60f8         	str	r0, [r7, #0xc]
 8012170: 60b9         	str	r1, [r7, #0x8]
 8012172: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 8012174: 68fb         	ldr	r3, [r7, #0xc]
 8012176: 689b         	ldr	r3, [r3, #0x8]
 8012178: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 801217a: 697b         	ldr	r3, [r7, #0x14]
 801217c: 68db         	ldr	r3, [r3, #0xc]
 801217e: 2b00         	cmp	r3, #0x0
 8012180: d102         	bne	0x8012188 <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8012182: f06f 0357    	mvn	r3, #0x57
 8012186: e006         	b	0x8012196 <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 8012188: 697b         	ldr	r3, [r7, #0x14]
 801218a: 68db         	ldr	r3, [r3, #0xc]
 801218c: 687a         	ldr	r2, [r7, #0x4]
 801218e: 68b9         	ldr	r1, [r7, #0x8]
 8012190: 68f8         	ldr	r0, [r7, #0xc]
 8012192: 4798         	blx	r3
 8012194: 4603         	mov	r3, r0
; }
 8012196: 4618         	mov	r0, r3
 8012198: 3718         	adds	r7, #0x18
 801219a: 46bd         	mov	sp, r7
 801219c: bd80         	pop	{r7, pc}

0801219e <pinctrl_apply_state_direct>:
; {
 801219e: b580         	push	{r7, lr}
 80121a0: b084         	sub	sp, #0x10
 80121a2: af00         	add	r7, sp, #0x0
 80121a4: 6078         	str	r0, [r7, #0x4]
 80121a6: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 80121a8: 2300         	movs	r3, #0x0
 80121aa: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 80121ac: 683b         	ldr	r3, [r7]
 80121ae: 6818         	ldr	r0, [r3]
 80121b0: 683b         	ldr	r3, [r7]
 80121b2: 791b         	ldrb	r3, [r3, #0x4]
 80121b4: 68fa         	ldr	r2, [r7, #0xc]
 80121b6: 4619         	mov	r1, r3
 80121b8: f002 fb93    	bl	0x80148e2 <pinctrl_configure_pins> @ imm = #0x2726
 80121bc: 4603         	mov	r3, r0
; }
 80121be: 4618         	mov	r0, r3
 80121c0: 3710         	adds	r7, #0x10
 80121c2: 46bd         	mov	sp, r7
 80121c4: bd80         	pop	{r7, pc}

080121c6 <pinctrl_apply_state>:
; {
 80121c6: b580         	push	{r7, lr}
 80121c8: b084         	sub	sp, #0x10
 80121ca: af00         	add	r7, sp, #0x0
 80121cc: 6078         	str	r0, [r7, #0x4]
 80121ce: 460b         	mov	r3, r1
 80121d0: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 80121d2: f107 0208    	add.w	r2, r7, #0x8
 80121d6: 78fb         	ldrb	r3, [r7, #0x3]
 80121d8: 4619         	mov	r1, r3
 80121da: 6878         	ldr	r0, [r7, #0x4]
 80121dc: f002 fb4a    	bl	0x8014874 <pinctrl_lookup_state> @ imm = #0x2694
 80121e0: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 80121e2: 68fb         	ldr	r3, [r7, #0xc]
 80121e4: 2b00         	cmp	r3, #0x0
 80121e6: da01         	bge	0x80121ec <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 80121e8: 68fb         	ldr	r3, [r7, #0xc]
 80121ea: e005         	b	0x80121f8 <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 80121ec: 68bb         	ldr	r3, [r7, #0x8]
 80121ee: 4619         	mov	r1, r3
 80121f0: 6878         	ldr	r0, [r7, #0x4]
 80121f2: f7ff ffd4    	bl	0x801219e <pinctrl_apply_state_direct> @ imm = #-0x58
 80121f6: 4603         	mov	r3, r0
; }
 80121f8: 4618         	mov	r0, r3
 80121fa: 3710         	adds	r7, #0x10
 80121fc: 46bd         	mov	sp, r7
 80121fe: bd80         	pop	{r7, pc}

08012200 <z_log_msg_runtime_create>:
; {
 8012200: b580         	push	{r7, lr}
 8012202: b08a         	sub	sp, #0x28
 8012204: af04         	add	r7, sp, #0x10
 8012206: 60b9         	str	r1, [r7, #0x8]
 8012208: 607b         	str	r3, [r7, #0x4]
 801220a: 4603         	mov	r3, r0
 801220c: 73fb         	strb	r3, [r7, #0xf]
 801220e: 4613         	mov	r3, r2
 8012210: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8012212: f107 032c    	add.w	r3, r7, #0x2c
 8012216: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8012218: 7bba         	ldrb	r2, [r7, #0xe]
 801221a: 7bf8         	ldrb	r0, [r7, #0xf]
 801221c: 697b         	ldr	r3, [r7, #0x14]
 801221e: 9303         	str	r3, [sp, #0xc]
 8012220: 6abb         	ldr	r3, [r7, #0x28]
 8012222: 9302         	str	r3, [sp, #0x8]
 8012224: 6a7b         	ldr	r3, [r7, #0x24]
 8012226: 9301         	str	r3, [sp, #0x4]
 8012228: 6a3b         	ldr	r3, [r7, #0x20]
 801222a: 9300         	str	r3, [sp]
 801222c: 687b         	ldr	r3, [r7, #0x4]
 801222e: 68b9         	ldr	r1, [r7, #0x8]
 8012230: f7ef ff8c    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0x100e8
; }
 8012234: bf00         	nop
 8012236: 3718         	adds	r7, #0x18
 8012238: 46bd         	mov	sp, r7
 801223a: bd80         	pop	{r7, pc}

0801223c <can_stm32_signal_tx_complete>:
; {
 801223c: b580         	push	{r7, lr}
 801223e: b086         	sub	sp, #0x18
 8012240: af00         	add	r7, sp, #0x0
 8012242: 60f8         	str	r0, [r7, #0xc]
 8012244: 60b9         	str	r1, [r7, #0x8]
 8012246: 607a         	str	r2, [r7, #0x4]
; 	can_tx_callback_t callback = mb->tx_callback;
 8012248: 68bb         	ldr	r3, [r7, #0x8]
 801224a: 681b         	ldr	r3, [r3]
 801224c: 617b         	str	r3, [r7, #0x14]
; 	if (callback != NULL) {
 801224e: 697b         	ldr	r3, [r7, #0x14]
 8012250: 2b00         	cmp	r3, #0x0
 8012252: d008         	beq	0x8012266 <can_stm32_signal_tx_complete+0x2a> @ imm = #0x10
; 		callback(dev, status, mb->callback_arg);
 8012254: 68bb         	ldr	r3, [r7, #0x8]
 8012256: 685a         	ldr	r2, [r3, #0x4]
 8012258: 697b         	ldr	r3, [r7, #0x14]
 801225a: 6879         	ldr	r1, [r7, #0x4]
 801225c: 68f8         	ldr	r0, [r7, #0xc]
 801225e: 4798         	blx	r3
; 		mb->tx_callback = NULL;
 8012260: 68bb         	ldr	r3, [r7, #0x8]
 8012262: 2200         	movs	r2, #0x0
 8012264: 601a         	str	r2, [r3]
; }
 8012266: bf00         	nop
 8012268: 3718         	adds	r7, #0x18
 801226a: 46bd         	mov	sp, r7
 801226c: bd80         	pop	{r7, pc}

0801226e <can_stm32_rx_fifo_pop>:
; {
 801226e: b580         	push	{r7, lr}
 8012270: b082         	sub	sp, #0x8
 8012272: af00         	add	r7, sp, #0x0
 8012274: 6078         	str	r0, [r7, #0x4]
 8012276: 6039         	str	r1, [r7]
; 	memset(frame, 0, sizeof(*frame));
 8012278: 2210         	movs	r2, #0x10
 801227a: 2100         	movs	r1, #0x0
 801227c: 6838         	ldr	r0, [r7]
 801227e: f006 fd62    	bl	0x8018d46 <memset>      @ imm = #0x6ac4
; 	if (mbox->RIR & CAN_RI0R_IDE) {
 8012282: 687b         	ldr	r3, [r7, #0x4]
 8012284: 681b         	ldr	r3, [r3]
 8012286: f003 0304    	and	r3, r3, #0x4
 801228a: 2b00         	cmp	r3, #0x0
 801228c: d00c         	beq	0x80122a8 <can_stm32_rx_fifo_pop+0x3a> @ imm = #0x18
; 		frame->id = mbox->RIR >> CAN_RI0R_EXID_Pos;
 801228e: 687b         	ldr	r3, [r7, #0x4]
 8012290: 681b         	ldr	r3, [r3]
 8012292: 08da         	lsrs	r2, r3, #0x3
 8012294: 683b         	ldr	r3, [r7]
 8012296: 601a         	str	r2, [r3]
; 		frame->flags |= CAN_FRAME_IDE;
 8012298: 683b         	ldr	r3, [r7]
 801229a: 795b         	ldrb	r3, [r3, #0x5]
 801229c: f043 0301    	orr	r3, r3, #0x1
 80122a0: b2da         	uxtb	r2, r3
 80122a2: 683b         	ldr	r3, [r7]
 80122a4: 715a         	strb	r2, [r3, #0x5]
 80122a6: e004         	b	0x80122b2 <can_stm32_rx_fifo_pop+0x44> @ imm = #0x8
; 		frame->id = mbox->RIR >> CAN_RI0R_STID_Pos;
 80122a8: 687b         	ldr	r3, [r7, #0x4]
 80122aa: 681b         	ldr	r3, [r3]
 80122ac: 0d5a         	lsrs	r2, r3, #0x15
 80122ae: 683b         	ldr	r3, [r7]
 80122b0: 601a         	str	r2, [r3]
; 	if ((mbox->RIR & CAN_RI0R_RTR) != 0) {
 80122b2: 687b         	ldr	r3, [r7, #0x4]
 80122b4: 681b         	ldr	r3, [r3]
 80122b6: f003 0302    	and	r3, r3, #0x2
 80122ba: 2b00         	cmp	r3, #0x0
 80122bc: d007         	beq	0x80122ce <can_stm32_rx_fifo_pop+0x60> @ imm = #0xe
; 		frame->flags |= CAN_FRAME_RTR;
 80122be: 683b         	ldr	r3, [r7]
 80122c0: 795b         	ldrb	r3, [r3, #0x5]
 80122c2: f043 0302    	orr	r3, r3, #0x2
 80122c6: b2da         	uxtb	r2, r3
 80122c8: 683b         	ldr	r3, [r7]
 80122ca: 715a         	strb	r2, [r3, #0x5]
 80122cc: e007         	b	0x80122de <can_stm32_rx_fifo_pop+0x70> @ imm = #0xe
; 		frame->data_32[0] = mbox->RDLR;
 80122ce: 687b         	ldr	r3, [r7, #0x4]
 80122d0: 689a         	ldr	r2, [r3, #0x8]
 80122d2: 683b         	ldr	r3, [r7]
 80122d4: 609a         	str	r2, [r3, #0x8]
; 		frame->data_32[1] = mbox->RDHR;
 80122d6: 687b         	ldr	r3, [r7, #0x4]
 80122d8: 68da         	ldr	r2, [r3, #0xc]
 80122da: 683b         	ldr	r3, [r7]
 80122dc: 60da         	str	r2, [r3, #0xc]
; 	frame->dlc = mbox->RDTR & (CAN_RDT0R_DLC >> CAN_RDT0R_DLC_Pos);
 80122de: 687b         	ldr	r3, [r7, #0x4]
 80122e0: 685b         	ldr	r3, [r3, #0x4]
 80122e2: b2db         	uxtb	r3, r3
 80122e4: f003 030f    	and	r3, r3, #0xf
 80122e8: b2da         	uxtb	r2, r3
 80122ea: 683b         	ldr	r3, [r7]
 80122ec: 711a         	strb	r2, [r3, #0x4]
; }
 80122ee: bf00         	nop
 80122f0: 3708         	adds	r7, #0x8
 80122f2: 46bd         	mov	sp, r7
 80122f4: bd80         	pop	{r7, pc}

080122f6 <can_stm32_get_state>:
; {
 80122f6: b480         	push	{r7}
 80122f8: b089         	sub	sp, #0x24
 80122fa: af00         	add	r7, sp, #0x0
 80122fc: 60f8         	str	r0, [r7, #0xc]
 80122fe: 60b9         	str	r1, [r7, #0x8]
 8012300: 607a         	str	r2, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8012302: 68fb         	ldr	r3, [r7, #0xc]
 8012304: 685b         	ldr	r3, [r3, #0x4]
 8012306: 61fb         	str	r3, [r7, #0x1c]
; 	struct can_stm32_data *data = dev->data;
 8012308: 68fb         	ldr	r3, [r7, #0xc]
 801230a: 691b         	ldr	r3, [r3, #0x10]
 801230c: 61bb         	str	r3, [r7, #0x18]
; 	CAN_TypeDef *can = cfg->can;
 801230e: 69fb         	ldr	r3, [r7, #0x1c]
 8012310: 695b         	ldr	r3, [r3, #0x14]
 8012312: 617b         	str	r3, [r7, #0x14]
; 	if (state != NULL) {
 8012314: 68bb         	ldr	r3, [r7, #0x8]
 8012316: 2b00         	cmp	r3, #0x0
 8012318: d02b         	beq	0x8012372 <can_stm32_get_state+0x7c> @ imm = #0x56
; 		if (!data->common.started) {
 801231a: 69bb         	ldr	r3, [r7, #0x18]
 801231c: 791b         	ldrb	r3, [r3, #0x4]
 801231e: f083 0301    	eor	r3, r3, #0x1
 8012322: b2db         	uxtb	r3, r3
 8012324: 2b00         	cmp	r3, #0x0
 8012326: d003         	beq	0x8012330 <can_stm32_get_state+0x3a> @ imm = #0x6
; 			*state = CAN_STATE_STOPPED;
 8012328: 68bb         	ldr	r3, [r7, #0x8]
 801232a: 2204         	movs	r2, #0x4
 801232c: 701a         	strb	r2, [r3]
 801232e: e020         	b	0x8012372 <can_stm32_get_state+0x7c> @ imm = #0x40
; 		} else if (can->ESR & CAN_ESR_BOFF) {
 8012330: 697b         	ldr	r3, [r7, #0x14]
 8012332: 699b         	ldr	r3, [r3, #0x18]
 8012334: f003 0304    	and	r3, r3, #0x4
 8012338: 2b00         	cmp	r3, #0x0
 801233a: d003         	beq	0x8012344 <can_stm32_get_state+0x4e> @ imm = #0x6
; 			*state = CAN_STATE_BUS_OFF;
 801233c: 68bb         	ldr	r3, [r7, #0x8]
 801233e: 2203         	movs	r2, #0x3
 8012340: 701a         	strb	r2, [r3]
 8012342: e016         	b	0x8012372 <can_stm32_get_state+0x7c> @ imm = #0x2c
; 		} else if (can->ESR & CAN_ESR_EPVF) {
 8012344: 697b         	ldr	r3, [r7, #0x14]
 8012346: 699b         	ldr	r3, [r3, #0x18]
 8012348: f003 0302    	and	r3, r3, #0x2
 801234c: 2b00         	cmp	r3, #0x0
 801234e: d003         	beq	0x8012358 <can_stm32_get_state+0x62> @ imm = #0x6
; 			*state = CAN_STATE_ERROR_PASSIVE;
 8012350: 68bb         	ldr	r3, [r7, #0x8]
 8012352: 2202         	movs	r2, #0x2
 8012354: 701a         	strb	r2, [r3]
 8012356: e00c         	b	0x8012372 <can_stm32_get_state+0x7c> @ imm = #0x18
; 		} else if (can->ESR & CAN_ESR_EWGF) {
 8012358: 697b         	ldr	r3, [r7, #0x14]
 801235a: 699b         	ldr	r3, [r3, #0x18]
 801235c: f003 0301    	and	r3, r3, #0x1
 8012360: 2b00         	cmp	r3, #0x0
 8012362: d003         	beq	0x801236c <can_stm32_get_state+0x76> @ imm = #0x6
; 			*state = CAN_STATE_ERROR_WARNING;
 8012364: 68bb         	ldr	r3, [r7, #0x8]
 8012366: 2201         	movs	r2, #0x1
 8012368: 701a         	strb	r2, [r3]
 801236a: e002         	b	0x8012372 <can_stm32_get_state+0x7c> @ imm = #0x4
; 			*state = CAN_STATE_ERROR_ACTIVE;
 801236c: 68bb         	ldr	r3, [r7, #0x8]
 801236e: 2200         	movs	r2, #0x0
 8012370: 701a         	strb	r2, [r3]
; 	if (err_cnt != NULL) {
 8012372: 687b         	ldr	r3, [r7, #0x4]
 8012374: 2b00         	cmp	r3, #0x0
 8012376: d00b         	beq	0x8012390 <can_stm32_get_state+0x9a> @ imm = #0x16
; 			((can->ESR & CAN_ESR_TEC) >> CAN_ESR_TEC_Pos);
 8012378: 697b         	ldr	r3, [r7, #0x14]
 801237a: 699b         	ldr	r3, [r3, #0x18]
 801237c: 0c1b         	lsrs	r3, r3, #0x10
; 		err_cnt->tx_err_cnt =
 801237e: b2da         	uxtb	r2, r3
 8012380: 687b         	ldr	r3, [r7, #0x4]
 8012382: 701a         	strb	r2, [r3]
; 			((can->ESR & CAN_ESR_REC) >> CAN_ESR_REC_Pos);
 8012384: 697b         	ldr	r3, [r7, #0x14]
 8012386: 699b         	ldr	r3, [r3, #0x18]
 8012388: 0e1b         	lsrs	r3, r3, #0x18
; 		err_cnt->rx_err_cnt =
 801238a: b2da         	uxtb	r2, r3
 801238c: 687b         	ldr	r3, [r7, #0x4]
 801238e: 705a         	strb	r2, [r3, #0x1]
; 	return 0;
 8012390: 2300         	movs	r3, #0x0
; }
 8012392: 4618         	mov	r0, r3
 8012394: 3724         	adds	r7, #0x24
 8012396: 46bd         	mov	sp, r7
 8012398: bc80         	pop	{r7}
 801239a: 4770         	bx	lr

0801239c <can_stm32_bus_state_change_isr>:
; {
 801239c: b590         	push	{r4, r7, lr}
 801239e: b089         	sub	sp, #0x24
 80123a0: af00         	add	r7, sp, #0x0
 80123a2: 6078         	str	r0, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 80123a4: 687b         	ldr	r3, [r7, #0x4]
 80123a6: 691b         	ldr	r3, [r3, #0x10]
 80123a8: 61fb         	str	r3, [r7, #0x1c]
; 	const can_state_change_callback_t cb = data->common.state_change_cb;
 80123aa: 69fb         	ldr	r3, [r7, #0x1c]
 80123ac: 689b         	ldr	r3, [r3, #0x8]
 80123ae: 61bb         	str	r3, [r7, #0x18]
; 	void *state_change_cb_data = data->common.state_change_cb_user_data;
 80123b0: 69fb         	ldr	r3, [r7, #0x1c]
 80123b2: 68db         	ldr	r3, [r3, #0xc]
 80123b4: 617b         	str	r3, [r7, #0x14]
; 	(void)can_stm32_get_state(dev, &state, &err_cnt);
 80123b6: f107 0210    	add.w	r2, r7, #0x10
 80123ba: f107 030f    	add.w	r3, r7, #0xf
 80123be: 4619         	mov	r1, r3
 80123c0: 6878         	ldr	r0, [r7, #0x4]
 80123c2: f7ff ff98    	bl	0x80122f6 <can_stm32_get_state> @ imm = #-0xd0
; 	if (state != data->state) {
 80123c6: 69fb         	ldr	r3, [r7, #0x1c]
 80123c8: f893 20f4    	ldrb.w	r2, [r3, #0xf4]
 80123cc: 7bfb         	ldrb	r3, [r7, #0xf]
 80123ce: 429a         	cmp	r2, r3
 80123d0: d00c         	beq	0x80123ec <can_stm32_bus_state_change_isr+0x50> @ imm = #0x18
; 		data->state = state;
 80123d2: 7bfa         	ldrb	r2, [r7, #0xf]
 80123d4: 69fb         	ldr	r3, [r7, #0x1c]
 80123d6: f883 20f4    	strb.w	r2, [r3, #0xf4]
; 		if (cb != NULL) {
 80123da: 69bb         	ldr	r3, [r7, #0x18]
 80123dc: 2b00         	cmp	r3, #0x0
 80123de: d005         	beq	0x80123ec <can_stm32_bus_state_change_isr+0x50> @ imm = #0xa
; 			cb(dev, state, err_cnt, state_change_cb_data);
 80123e0: 7bf9         	ldrb	r1, [r7, #0xf]
 80123e2: 69bc         	ldr	r4, [r7, #0x18]
 80123e4: 697b         	ldr	r3, [r7, #0x14]
 80123e6: 693a         	ldr	r2, [r7, #0x10]
 80123e8: 6878         	ldr	r0, [r7, #0x4]
 80123ea: 47a0         	blx	r4
; }
 80123ec: bf00         	nop
 80123ee: 3724         	adds	r7, #0x24
 80123f0: 46bd         	mov	sp, r7
 80123f2: bd90         	pop	{r4, r7, pc}

080123f4 <can_stm32_tx_isr_handler>:
; {
 80123f4: b580         	push	{r7, lr}
 80123f6: b088         	sub	sp, #0x20
 80123f8: af00         	add	r7, sp, #0x0
 80123fa: 6078         	str	r0, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 80123fc: 687b         	ldr	r3, [r7, #0x4]
 80123fe: 691b         	ldr	r3, [r3, #0x10]
 8012400: 61fb         	str	r3, [r7, #0x1c]
; 	const struct can_stm32_config *cfg = dev->config;
 8012402: 687b         	ldr	r3, [r7, #0x4]
 8012404: 685b         	ldr	r3, [r3, #0x4]
 8012406: 61bb         	str	r3, [r7, #0x18]
; 	CAN_TypeDef *can = cfg->can;
 8012408: 69bb         	ldr	r3, [r7, #0x18]
 801240a: 695b         	ldr	r3, [r3, #0x14]
 801240c: 617b         	str	r3, [r7, #0x14]
; 	bus_off = can->ESR & CAN_ESR_BOFF;
 801240e: 697b         	ldr	r3, [r7, #0x14]
 8012410: 699b         	ldr	r3, [r3, #0x18]
 8012412: f003 0304    	and	r3, r3, #0x4
 8012416: 613b         	str	r3, [r7, #0x10]
; 	if ((can->TSR & CAN_TSR_RQCP0) | bus_off) {
 8012418: 697b         	ldr	r3, [r7, #0x14]
 801241a: 689b         	ldr	r3, [r3, #0x8]
 801241c: f003 0201    	and	r2, r3, #0x1
 8012420: 693b         	ldr	r3, [r7, #0x10]
 8012422: 4313         	orrs	r3, r2
 8012424: 2b00         	cmp	r3, #0x0
 8012426: d02f         	beq	0x8012488 <can_stm32_tx_isr_handler+0x94> @ imm = #0x5e
; 		status = can->TSR & CAN_TSR_TXOK0 ? 0  :
 8012428: 697b         	ldr	r3, [r7, #0x14]
 801242a: 689b         	ldr	r3, [r3, #0x8]
 801242c: f003 0302    	and	r3, r3, #0x2
 8012430: 2b00         	cmp	r3, #0x0
 8012432: d11a         	bne	0x801246a <can_stm32_tx_isr_handler+0x76> @ imm = #0x34
; 			 can->TSR & CAN_TSR_TERR0 ? -EIO :
 8012434: 697b         	ldr	r3, [r7, #0x14]
 8012436: 689b         	ldr	r3, [r3, #0x8]
 8012438: f003 0308    	and	r3, r3, #0x8
 801243c: 2b00         	cmp	r3, #0x0
 801243e: d111         	bne	0x8012464 <can_stm32_tx_isr_handler+0x70> @ imm = #0x22
; 			 can->TSR & CAN_TSR_ALST0 ? -EBUSY :
 8012440: 697b         	ldr	r3, [r7, #0x14]
 8012442: 689b         	ldr	r3, [r3, #0x8]
 8012444: f003 0304    	and	r3, r3, #0x4
 8012448: 2b00         	cmp	r3, #0x0
 801244a: d108         	bne	0x801245e <can_stm32_tx_isr_handler+0x6a> @ imm = #0x10
; 					  bus_off ? -ENETUNREACH :
 801244c: 693b         	ldr	r3, [r7, #0x10]
 801244e: 2b00         	cmp	r3, #0x0
 8012450: d002         	beq	0x8012458 <can_stm32_tx_isr_handler+0x64> @ imm = #0x4
 8012452: f06f 0371    	mvn	r3, #0x71
 8012456: e009         	b	0x801246c <can_stm32_tx_isr_handler+0x78> @ imm = #0x12
 8012458: f06f 0304    	mvn	r3, #0x4
 801245c: e006         	b	0x801246c <can_stm32_tx_isr_handler+0x78> @ imm = #0xc
; 			 can->TSR & CAN_TSR_ALST0 ? -EBUSY :
 801245e: f06f 030f    	mvn	r3, #0xf
 8012462: e003         	b	0x801246c <can_stm32_tx_isr_handler+0x78> @ imm = #0x6
; 			 can->TSR & CAN_TSR_TERR0 ? -EIO :
 8012464: f06f 0304    	mvn	r3, #0x4
 8012468: e000         	b	0x801246c <can_stm32_tx_isr_handler+0x78> @ imm = #0x0
; 		status = can->TSR & CAN_TSR_TXOK0 ? 0  :
 801246a: 2300         	movs	r3, #0x0
 801246c: 60fb         	str	r3, [r7, #0xc]
; 		can->TSR |= CAN_TSR_RQCP0;
 801246e: 697b         	ldr	r3, [r7, #0x14]
 8012470: 689b         	ldr	r3, [r3, #0x8]
 8012472: f043 0201    	orr	r2, r3, #0x1
 8012476: 697b         	ldr	r3, [r7, #0x14]
 8012478: 609a         	str	r2, [r3, #0x8]
; 		can_stm32_signal_tx_complete(dev, &data->mb0, status);
 801247a: 69fb         	ldr	r3, [r7, #0x1c]
 801247c: 3334         	adds	r3, #0x34
 801247e: 68fa         	ldr	r2, [r7, #0xc]
 8012480: 4619         	mov	r1, r3
 8012482: 6878         	ldr	r0, [r7, #0x4]
 8012484: f7ff feda    	bl	0x801223c <can_stm32_signal_tx_complete> @ imm = #-0x24c
; 	if ((can->TSR & CAN_TSR_RQCP1) | bus_off) {
 8012488: 697b         	ldr	r3, [r7, #0x14]
 801248a: 689b         	ldr	r3, [r3, #0x8]
 801248c: f403 7280    	and	r2, r3, #0x100
 8012490: 693b         	ldr	r3, [r7, #0x10]
 8012492: 4313         	orrs	r3, r2
 8012494: 2b00         	cmp	r3, #0x0
 8012496: d02f         	beq	0x80124f8 <can_stm32_tx_isr_handler+0x104> @ imm = #0x5e
; 		status = can->TSR & CAN_TSR_TXOK1 ? 0  :
 8012498: 697b         	ldr	r3, [r7, #0x14]
 801249a: 689b         	ldr	r3, [r3, #0x8]
 801249c: f403 7300    	and	r3, r3, #0x200
 80124a0: 2b00         	cmp	r3, #0x0
 80124a2: d11a         	bne	0x80124da <can_stm32_tx_isr_handler+0xe6> @ imm = #0x34
; 			 can->TSR & CAN_TSR_TERR1 ? -EIO :
 80124a4: 697b         	ldr	r3, [r7, #0x14]
 80124a6: 689b         	ldr	r3, [r3, #0x8]
 80124a8: f403 6300    	and	r3, r3, #0x800
 80124ac: 2b00         	cmp	r3, #0x0
 80124ae: d111         	bne	0x80124d4 <can_stm32_tx_isr_handler+0xe0> @ imm = #0x22
; 			 can->TSR & CAN_TSR_ALST1 ? -EBUSY :
 80124b0: 697b         	ldr	r3, [r7, #0x14]
 80124b2: 689b         	ldr	r3, [r3, #0x8]
 80124b4: f403 6380    	and	r3, r3, #0x400
 80124b8: 2b00         	cmp	r3, #0x0
 80124ba: d108         	bne	0x80124ce <can_stm32_tx_isr_handler+0xda> @ imm = #0x10
; 			 bus_off                  ? -ENETUNREACH :
 80124bc: 693b         	ldr	r3, [r7, #0x10]
 80124be: 2b00         	cmp	r3, #0x0
 80124c0: d002         	beq	0x80124c8 <can_stm32_tx_isr_handler+0xd4> @ imm = #0x4
 80124c2: f06f 0371    	mvn	r3, #0x71
 80124c6: e009         	b	0x80124dc <can_stm32_tx_isr_handler+0xe8> @ imm = #0x12
 80124c8: f06f 0304    	mvn	r3, #0x4
 80124cc: e006         	b	0x80124dc <can_stm32_tx_isr_handler+0xe8> @ imm = #0xc
; 			 can->TSR & CAN_TSR_ALST1 ? -EBUSY :
 80124ce: f06f 030f    	mvn	r3, #0xf
 80124d2: e003         	b	0x80124dc <can_stm32_tx_isr_handler+0xe8> @ imm = #0x6
; 			 can->TSR & CAN_TSR_TERR1 ? -EIO :
 80124d4: f06f 0304    	mvn	r3, #0x4
 80124d8: e000         	b	0x80124dc <can_stm32_tx_isr_handler+0xe8> @ imm = #0x0
; 		status = can->TSR & CAN_TSR_TXOK1 ? 0  :
 80124da: 2300         	movs	r3, #0x0
 80124dc: 60fb         	str	r3, [r7, #0xc]
; 		can->TSR |= CAN_TSR_RQCP1;
 80124de: 697b         	ldr	r3, [r7, #0x14]
 80124e0: 689b         	ldr	r3, [r3, #0x8]
 80124e2: f443 7280    	orr	r2, r3, #0x100
 80124e6: 697b         	ldr	r3, [r7, #0x14]
 80124e8: 609a         	str	r2, [r3, #0x8]
; 		can_stm32_signal_tx_complete(dev, &data->mb1, status);
 80124ea: 69fb         	ldr	r3, [r7, #0x1c]
 80124ec: 333c         	adds	r3, #0x3c
 80124ee: 68fa         	ldr	r2, [r7, #0xc]
 80124f0: 4619         	mov	r1, r3
 80124f2: 6878         	ldr	r0, [r7, #0x4]
 80124f4: f7ff fea2    	bl	0x801223c <can_stm32_signal_tx_complete> @ imm = #-0x2bc
; 	if ((can->TSR & CAN_TSR_RQCP2) | bus_off) {
 80124f8: 697b         	ldr	r3, [r7, #0x14]
 80124fa: 689b         	ldr	r3, [r3, #0x8]
 80124fc: f403 3280    	and	r2, r3, #0x10000
 8012500: 693b         	ldr	r3, [r7, #0x10]
 8012502: 4313         	orrs	r3, r2
 8012504: 2b00         	cmp	r3, #0x0
 8012506: d02f         	beq	0x8012568 <can_stm32_tx_isr_handler+0x174> @ imm = #0x5e
; 		status = can->TSR & CAN_TSR_TXOK2 ? 0  :
 8012508: 697b         	ldr	r3, [r7, #0x14]
 801250a: 689b         	ldr	r3, [r3, #0x8]
 801250c: f403 3300    	and	r3, r3, #0x20000
 8012510: 2b00         	cmp	r3, #0x0
 8012512: d11a         	bne	0x801254a <can_stm32_tx_isr_handler+0x156> @ imm = #0x34
; 			 can->TSR & CAN_TSR_TERR2 ? -EIO :
 8012514: 697b         	ldr	r3, [r7, #0x14]
 8012516: 689b         	ldr	r3, [r3, #0x8]
 8012518: f403 2300    	and	r3, r3, #0x80000
 801251c: 2b00         	cmp	r3, #0x0
 801251e: d111         	bne	0x8012544 <can_stm32_tx_isr_handler+0x150> @ imm = #0x22
; 			 can->TSR & CAN_TSR_ALST2 ? -EBUSY :
 8012520: 697b         	ldr	r3, [r7, #0x14]
 8012522: 689b         	ldr	r3, [r3, #0x8]
 8012524: f403 2380    	and	r3, r3, #0x40000
 8012528: 2b00         	cmp	r3, #0x0
 801252a: d108         	bne	0x801253e <can_stm32_tx_isr_handler+0x14a> @ imm = #0x10
; 			 bus_off                  ? -ENETUNREACH :
 801252c: 693b         	ldr	r3, [r7, #0x10]
 801252e: 2b00         	cmp	r3, #0x0
 8012530: d002         	beq	0x8012538 <can_stm32_tx_isr_handler+0x144> @ imm = #0x4
 8012532: f06f 0371    	mvn	r3, #0x71
 8012536: e009         	b	0x801254c <can_stm32_tx_isr_handler+0x158> @ imm = #0x12
 8012538: f06f 0304    	mvn	r3, #0x4
 801253c: e006         	b	0x801254c <can_stm32_tx_isr_handler+0x158> @ imm = #0xc
; 			 can->TSR & CAN_TSR_ALST2 ? -EBUSY :
 801253e: f06f 030f    	mvn	r3, #0xf
 8012542: e003         	b	0x801254c <can_stm32_tx_isr_handler+0x158> @ imm = #0x6
; 			 can->TSR & CAN_TSR_TERR2 ? -EIO :
 8012544: f06f 0304    	mvn	r3, #0x4
 8012548: e000         	b	0x801254c <can_stm32_tx_isr_handler+0x158> @ imm = #0x0
; 		status = can->TSR & CAN_TSR_TXOK2 ? 0  :
 801254a: 2300         	movs	r3, #0x0
 801254c: 60fb         	str	r3, [r7, #0xc]
; 		can->TSR |= CAN_TSR_RQCP2;
 801254e: 697b         	ldr	r3, [r7, #0x14]
 8012550: 689b         	ldr	r3, [r3, #0x8]
 8012552: f443 3280    	orr	r2, r3, #0x10000
 8012556: 697b         	ldr	r3, [r7, #0x14]
 8012558: 609a         	str	r2, [r3, #0x8]
; 		can_stm32_signal_tx_complete(dev, &data->mb2, status);
 801255a: 69fb         	ldr	r3, [r7, #0x1c]
 801255c: 3344         	adds	r3, #0x44
 801255e: 68fa         	ldr	r2, [r7, #0xc]
 8012560: 4619         	mov	r1, r3
 8012562: 6878         	ldr	r0, [r7, #0x4]
 8012564: f7ff fe6a    	bl	0x801223c <can_stm32_signal_tx_complete> @ imm = #-0x32c
; 	if (can->TSR & CAN_TSR_TME) {
 8012568: 697b         	ldr	r3, [r7, #0x14]
 801256a: 689b         	ldr	r3, [r3, #0x8]
 801256c: f003 53e0    	and	r3, r3, #0x1c000000
 8012570: 2b00         	cmp	r3, #0x0
 8012572: d004         	beq	0x801257e <can_stm32_tx_isr_handler+0x18a> @ imm = #0x8
; 		k_sem_give(&data->tx_int_sem);
 8012574: 69fb         	ldr	r3, [r7, #0x1c]
 8012576: 3324         	adds	r3, #0x24
 8012578: 4618         	mov	r0, r3
 801257a: f7ff fd96    	bl	0x80120aa <k_sem_give>  @ imm = #-0x4d4
; }
 801257e: bf00         	nop
 8012580: 3720         	adds	r7, #0x20
 8012582: 46bd         	mov	sp, r7
 8012584: bd80         	pop	{r7, pc}

08012586 <can_stm32_rx_isr>:
; {
 8012586: b580         	push	{r7, lr}
 8012588: b082         	sub	sp, #0x8
 801258a: af00         	add	r7, sp, #0x0
 801258c: 6078         	str	r0, [r7, #0x4]
; 	can_stm32_rx_isr_handler(dev);
 801258e: 6878         	ldr	r0, [r7, #0x4]
 8012590: f7f2 f990    	bl	0x80048b4 <can_stm32_rx_isr_handler> @ imm = #-0xdce0
; }
 8012594: bf00         	nop
 8012596: 3708         	adds	r7, #0x8
 8012598: 46bd         	mov	sp, r7
 801259a: bd80         	pop	{r7, pc}

0801259c <can_stm32_tx_isr>:
; {
 801259c: b580         	push	{r7, lr}
 801259e: b082         	sub	sp, #0x8
 80125a0: af00         	add	r7, sp, #0x0
 80125a2: 6078         	str	r0, [r7, #0x4]
; 	can_stm32_tx_isr_handler(dev);
 80125a4: 6878         	ldr	r0, [r7, #0x4]
 80125a6: f7ff ff25    	bl	0x80123f4 <can_stm32_tx_isr_handler> @ imm = #-0x1b6
; }
 80125aa: bf00         	nop
 80125ac: 3708         	adds	r7, #0x8
 80125ae: 46bd         	mov	sp, r7
 80125b0: bd80         	pop	{r7, pc}

080125b2 <can_stm32_state_change_isr>:
; {
 80125b2: b580         	push	{r7, lr}
 80125b4: b084         	sub	sp, #0x10
 80125b6: af00         	add	r7, sp, #0x0
 80125b8: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 80125ba: 687b         	ldr	r3, [r7, #0x4]
 80125bc: 685b         	ldr	r3, [r3, #0x4]
 80125be: 60fb         	str	r3, [r7, #0xc]
; 	CAN_TypeDef *can = cfg->can;
 80125c0: 68fb         	ldr	r3, [r7, #0xc]
 80125c2: 695b         	ldr	r3, [r3, #0x14]
 80125c4: 60bb         	str	r3, [r7, #0x8]
; 	if (can->MSR & CAN_MSR_ERRI) {
 80125c6: 68bb         	ldr	r3, [r7, #0x8]
 80125c8: 685b         	ldr	r3, [r3, #0x4]
 80125ca: f003 0304    	and	r3, r3, #0x4
 80125ce: 2b00         	cmp	r3, #0x0
 80125d0: d00b         	beq	0x80125ea <can_stm32_state_change_isr+0x38> @ imm = #0x16
; 		can_stm32_tx_isr_handler(dev);
 80125d2: 6878         	ldr	r0, [r7, #0x4]
 80125d4: f7ff ff0e    	bl	0x80123f4 <can_stm32_tx_isr_handler> @ imm = #-0x1e4
; 		can_stm32_bus_state_change_isr(dev);
 80125d8: 6878         	ldr	r0, [r7, #0x4]
 80125da: f7ff fedf    	bl	0x801239c <can_stm32_bus_state_change_isr> @ imm = #-0x242
; 		can->MSR |= CAN_MSR_ERRI;
 80125de: 68bb         	ldr	r3, [r7, #0x8]
 80125e0: 685b         	ldr	r3, [r3, #0x4]
 80125e2: f043 0204    	orr	r2, r3, #0x4
 80125e6: 68bb         	ldr	r3, [r7, #0x8]
 80125e8: 605a         	str	r2, [r3, #0x4]
; }
 80125ea: bf00         	nop
 80125ec: 3710         	adds	r7, #0x10
 80125ee: 46bd         	mov	sp, r7
 80125f0: bd80         	pop	{r7, pc}

080125f2 <can_stm32_get_capabilities>:
; {
 80125f2: b480         	push	{r7}
 80125f4: b083         	sub	sp, #0xc
 80125f6: af00         	add	r7, sp, #0x0
 80125f8: 6078         	str	r0, [r7, #0x4]
 80125fa: 6039         	str	r1, [r7]
; 	*cap = CAN_MODE_NORMAL | CAN_MODE_LOOPBACK | CAN_MODE_LISTENONLY | CAN_MODE_ONE_SHOT;
 80125fc: 683b         	ldr	r3, [r7]
 80125fe: 220b         	movs	r2, #0xb
 8012600: 601a         	str	r2, [r3]
; 	return 0;
 8012602: 2300         	movs	r3, #0x0
; }
 8012604: 4618         	mov	r0, r3
 8012606: 370c         	adds	r7, #0xc
 8012608: 46bd         	mov	sp, r7
 801260a: bc80         	pop	{r7}
 801260c: 4770         	bx	lr

0801260e <can_stm32_get_max_filters>:
; {
 801260e: b480         	push	{r7}
 8012610: b083         	sub	sp, #0xc
 8012612: af00         	add	r7, sp, #0x0
 8012614: 6078         	str	r0, [r7, #0x4]
 8012616: 460b         	mov	r3, r1
 8012618: 70fb         	strb	r3, [r7, #0x3]
; 	if (ide) {
 801261a: 78fb         	ldrb	r3, [r7, #0x3]
 801261c: 2b00         	cmp	r3, #0x0
 801261e: d001         	beq	0x8012624 <can_stm32_get_max_filters+0x16> @ imm = #0x2
; 		return CONFIG_CAN_MAX_EXT_ID_FILTER;
 8012620: 2307         	movs	r3, #0x7
 8012622: e000         	b	0x8012626 <can_stm32_get_max_filters+0x18> @ imm = #0x0
; 		return CONFIG_CAN_MAX_STD_ID_FILTER;
 8012624: 230e         	movs	r3, #0xe
; }
 8012626: 4618         	mov	r0, r3
 8012628: 370c         	adds	r7, #0xc
 801262a: 46bd         	mov	sp, r7
 801262c: bc80         	pop	{r7}
 801262e: 4770         	bx	lr

08012630 <can_stm32_set_state_change_callback>:
; {
 8012630: b480         	push	{r7}
 8012632: b089         	sub	sp, #0x24
 8012634: af00         	add	r7, sp, #0x0
 8012636: 60f8         	str	r0, [r7, #0xc]
 8012638: 60b9         	str	r1, [r7, #0x8]
 801263a: 607a         	str	r2, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 801263c: 68fb         	ldr	r3, [r7, #0xc]
 801263e: 691b         	ldr	r3, [r3, #0x10]
 8012640: 61fb         	str	r3, [r7, #0x1c]
; 	const struct can_stm32_config *cfg = dev->config;
 8012642: 68fb         	ldr	r3, [r7, #0xc]
 8012644: 685b         	ldr	r3, [r3, #0x4]
 8012646: 61bb         	str	r3, [r7, #0x18]
; 	CAN_TypeDef *can = cfg->can;
 8012648: 69bb         	ldr	r3, [r7, #0x18]
 801264a: 695b         	ldr	r3, [r3, #0x14]
 801264c: 617b         	str	r3, [r7, #0x14]
; 	data->common.state_change_cb = cb;
 801264e: 69fb         	ldr	r3, [r7, #0x1c]
 8012650: 68ba         	ldr	r2, [r7, #0x8]
 8012652: 609a         	str	r2, [r3, #0x8]
; 	data->common.state_change_cb_user_data = user_data;
 8012654: 69fb         	ldr	r3, [r7, #0x1c]
 8012656: 687a         	ldr	r2, [r7, #0x4]
 8012658: 60da         	str	r2, [r3, #0xc]
; 	if (cb == NULL) {
 801265a: 68bb         	ldr	r3, [r7, #0x8]
 801265c: 2b00         	cmp	r3, #0x0
 801265e: d106         	bne	0x801266e <can_stm32_set_state_change_callback+0x3e> @ imm = #0xc
; 		can->IER &= ~(CAN_IER_BOFIE | CAN_IER_EPVIE | CAN_IER_EWGIE);
 8012660: 697b         	ldr	r3, [r7, #0x14]
 8012662: 695b         	ldr	r3, [r3, #0x14]
 8012664: f423 62e0    	bic	r2, r3, #0x700
 8012668: 697b         	ldr	r3, [r7, #0x14]
 801266a: 615a         	str	r2, [r3, #0x14]
; }
 801266c: e005         	b	0x801267a <can_stm32_set_state_change_callback+0x4a> @ imm = #0xa
; 		can->IER |= CAN_IER_BOFIE | CAN_IER_EPVIE | CAN_IER_EWGIE;
 801266e: 697b         	ldr	r3, [r7, #0x14]
 8012670: 695b         	ldr	r3, [r3, #0x14]
 8012672: f443 62e0    	orr	r2, r3, #0x700
 8012676: 697b         	ldr	r3, [r7, #0x14]
 8012678: 615a         	str	r2, [r3, #0x14]
; }
 801267a: bf00         	nop
 801267c: 3724         	adds	r7, #0x24
 801267e: 46bd         	mov	sp, r7
 8012680: bc80         	pop	{r7}
 8012682: 4770         	bx	lr

08012684 <can_stm32_set_filter_bank>:
; {
 8012684: b480         	push	{r7}
 8012686: b085         	sub	sp, #0x14
 8012688: af00         	add	r7, sp, #0x0
 801268a: 60f8         	str	r0, [r7, #0xc]
 801268c: 60b9         	str	r1, [r7, #0x8]
 801268e: 603b         	str	r3, [r7]
 8012690: 4613         	mov	r3, r2
 8012692: 71fb         	strb	r3, [r7, #0x7]
; 	if (ide) {
 8012694: 79fb         	ldrb	r3, [r7, #0x7]
 8012696: 2b00         	cmp	r3, #0x0
 8012698: d006         	beq	0x80126a8 <can_stm32_set_filter_bank+0x24> @ imm = #0xc
; 		filter_reg->FR1 = id;
 801269a: 68bb         	ldr	r3, [r7, #0x8]
 801269c: 683a         	ldr	r2, [r7]
 801269e: 601a         	str	r2, [r3]
; 		filter_reg->FR2 = mask;
 80126a0: 68bb         	ldr	r3, [r7, #0x8]
 80126a2: 69ba         	ldr	r2, [r7, #0x18]
 80126a4: 605a         	str	r2, [r3, #0x4]
; }
 80126a6: e012         	b	0x80126ce <can_stm32_set_filter_bank+0x4a> @ imm = #0x24
; 		if ((filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER) % 2 == 0) {
 80126a8: 68fb         	ldr	r3, [r7, #0xc]
 80126aa: 3b07         	subs	r3, #0x7
 80126ac: f003 0301    	and	r3, r3, #0x1
 80126b0: 2b00         	cmp	r3, #0x0
 80126b2: d106         	bne	0x80126c2 <can_stm32_set_filter_bank+0x3e> @ imm = #0xc
; 			filter_reg->FR1 = id | (mask << 16);
 80126b4: 69bb         	ldr	r3, [r7, #0x18]
 80126b6: 041a         	lsls	r2, r3, #0x10
 80126b8: 683b         	ldr	r3, [r7]
 80126ba: 431a         	orrs	r2, r3
 80126bc: 68bb         	ldr	r3, [r7, #0x8]
 80126be: 601a         	str	r2, [r3]
; }
 80126c0: e005         	b	0x80126ce <can_stm32_set_filter_bank+0x4a> @ imm = #0xa
; 			filter_reg->FR2 = id | (mask << 16);
 80126c2: 69bb         	ldr	r3, [r7, #0x18]
 80126c4: 041a         	lsls	r2, r3, #0x10
 80126c6: 683b         	ldr	r3, [r7]
 80126c8: 431a         	orrs	r2, r3
 80126ca: 68bb         	ldr	r3, [r7, #0x8]
 80126cc: 605a         	str	r2, [r3, #0x4]
; }
 80126ce: bf00         	nop
 80126d0: 3714         	adds	r7, #0x14
 80126d2: 46bd         	mov	sp, r7
 80126d4: bc80         	pop	{r7}
 80126d6: 4770         	bx	lr

080126d8 <can_stm32_filter_to_std_mask>:
; {
 80126d8: b480         	push	{r7}
 80126da: b085         	sub	sp, #0x14
 80126dc: af00         	add	r7, sp, #0x0
 80126de: 6078         	str	r0, [r7, #0x4]
; 	uint32_t rtr_mask = !IS_ENABLED(CONFIG_CAN_ACCEPT_RTR);
 80126e0: 2301         	movs	r3, #0x1
 80126e2: 60fb         	str	r3, [r7, #0xc]
; 	return  (filter->mask << CAN_STM32_FIRX_STD_ID_POS) |
 80126e4: 687b         	ldr	r3, [r7, #0x4]
 80126e6: 685b         	ldr	r3, [r3, #0x4]
 80126e8: 015a         	lsls	r2, r3, #0x5
; 		(rtr_mask << CAN_STM32_FIRX_STD_RTR_POS) |
 80126ea: 68fb         	ldr	r3, [r7, #0xc]
 80126ec: 011b         	lsls	r3, r3, #0x4
; 	return  (filter->mask << CAN_STM32_FIRX_STD_ID_POS) |
 80126ee: 4313         	orrs	r3, r2
; 		(rtr_mask << CAN_STM32_FIRX_STD_RTR_POS) |
 80126f0: f043 0308    	orr	r3, r3, #0x8
; }
 80126f4: 4618         	mov	r0, r3
 80126f6: 3714         	adds	r7, #0x14
 80126f8: 46bd         	mov	sp, r7
 80126fa: bc80         	pop	{r7}
 80126fc: 4770         	bx	lr

080126fe <can_stm32_filter_to_ext_mask>:
; {
 80126fe: b480         	push	{r7}
 8012700: b085         	sub	sp, #0x14
 8012702: af00         	add	r7, sp, #0x0
 8012704: 6078         	str	r0, [r7, #0x4]
; 	uint32_t rtr_mask = !IS_ENABLED(CONFIG_CAN_ACCEPT_RTR);
 8012706: 2301         	movs	r3, #0x1
 8012708: 60fb         	str	r3, [r7, #0xc]
; 	return  (filter->mask << CAN_STM32_FIRX_EXT_EXT_ID_POS) |
 801270a: 687b         	ldr	r3, [r7, #0x4]
 801270c: 685b         	ldr	r3, [r3, #0x4]
 801270e: 00da         	lsls	r2, r3, #0x3
; 		(rtr_mask << CAN_STM32_FIRX_EXT_RTR_POS) |
 8012710: 68fb         	ldr	r3, [r7, #0xc]
 8012712: 005b         	lsls	r3, r3, #0x1
; 	return  (filter->mask << CAN_STM32_FIRX_EXT_EXT_ID_POS) |
 8012714: 4313         	orrs	r3, r2
; 		(rtr_mask << CAN_STM32_FIRX_EXT_RTR_POS) |
 8012716: f043 0304    	orr	r3, r3, #0x4
; }
 801271a: 4618         	mov	r0, r3
 801271c: 3714         	adds	r7, #0x14
 801271e: 46bd         	mov	sp, r7
 8012720: bc80         	pop	{r7}
 8012722: 4770         	bx	lr

08012724 <can_stm32_filter_to_std_id>:
; {
 8012724: b480         	push	{r7}
 8012726: b083         	sub	sp, #0xc
 8012728: af00         	add	r7, sp, #0x0
 801272a: 6078         	str	r0, [r7, #0x4]
; 	return  (filter->id  << CAN_STM32_FIRX_STD_ID_POS);
 801272c: 687b         	ldr	r3, [r7, #0x4]
 801272e: 681b         	ldr	r3, [r3]
 8012730: 015b         	lsls	r3, r3, #0x5
; }
 8012732: 4618         	mov	r0, r3
 8012734: 370c         	adds	r7, #0xc
 8012736: 46bd         	mov	sp, r7
 8012738: bc80         	pop	{r7}
 801273a: 4770         	bx	lr

0801273c <can_stm32_filter_to_ext_id>:
; {
 801273c: b480         	push	{r7}
 801273e: b083         	sub	sp, #0xc
 8012740: af00         	add	r7, sp, #0x0
 8012742: 6078         	str	r0, [r7, #0x4]
; 	return  (filter->id << CAN_STM32_FIRX_EXT_EXT_ID_POS) |
 8012744: 687b         	ldr	r3, [r7, #0x4]
 8012746: 681b         	ldr	r3, [r3]
 8012748: 00db         	lsls	r3, r3, #0x3
 801274a: f043 0304    	orr	r3, r3, #0x4
; }
 801274e: 4618         	mov	r0, r3
 8012750: 370c         	adds	r7, #0xc
 8012752: 46bd         	mov	sp, r7
 8012754: bc80         	pop	{r7}
 8012756: 4770         	bx	lr

08012758 <config_can_0_irq>:
; DT_INST_FOREACH_STATUS_OKAY(CAN_STM32_INST)
 8012758: b580         	push	{r7, lr}
 801275a: b082         	sub	sp, #0x8
 801275c: af00         	add	r7, sp, #0x0
 801275e: 6078         	str	r0, [r7, #0x4]
 8012760: 2200         	movs	r2, #0x0
 8012762: 2100         	movs	r1, #0x0
 8012764: 2014         	movs	r0, #0x14
 8012766: f7ff f9a1    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0xcbe
 801276a: 2014         	movs	r0, #0x14
 801276c: f7ff f991    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0xcde
 8012770: 2200         	movs	r2, #0x0
 8012772: 2100         	movs	r1, #0x0
 8012774: 2013         	movs	r0, #0x13
 8012776: f7ff f999    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0xcce
 801277a: 2013         	movs	r0, #0x13
 801277c: f7ff f989    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0xcee
 8012780: 2200         	movs	r2, #0x0
 8012782: 2100         	movs	r1, #0x0
 8012784: 2016         	movs	r0, #0x16
 8012786: f7ff f991    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0xcde
 801278a: 2016         	movs	r0, #0x16
 801278c: f7ff f981    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0xcfe
 8012790: 687b         	ldr	r3, [r7, #0x4]
 8012792: 695b         	ldr	r3, [r3, #0x14]
 8012794: f443 4304    	orr	r3, r3, #0x8400
 8012798: f043 0313    	orr	r3, r3, #0x13
 801279c: 687a         	ldr	r2, [r7, #0x4]
 801279e: 6153         	str	r3, [r2, #0x14]
 80127a0: 3708         	adds	r7, #0x8
 80127a2: 46bd         	mov	sp, r7
 80127a4: bd80         	pop	{r7, pc}

080127a6 <config_can_1_irq>:
 80127a6: b580         	push	{r7, lr}
 80127a8: b082         	sub	sp, #0x8
 80127aa: af00         	add	r7, sp, #0x0
 80127ac: 6078         	str	r0, [r7, #0x4]
 80127ae: 2200         	movs	r2, #0x0
 80127b0: 2100         	movs	r1, #0x0
 80127b2: 2040         	movs	r0, #0x40
 80127b4: f7ff f97a    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0xd0c
 80127b8: 2040         	movs	r0, #0x40
 80127ba: f7ff f96a    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0xd2c
 80127be: 2200         	movs	r2, #0x0
 80127c0: 2100         	movs	r1, #0x0
 80127c2: 203f         	movs	r0, #0x3f
 80127c4: f7ff f972    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0xd1c
 80127c8: 203f         	movs	r0, #0x3f
 80127ca: f7ff f962    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0xd3c
 80127ce: 2200         	movs	r2, #0x0
 80127d0: 2100         	movs	r1, #0x0
 80127d2: 2042         	movs	r0, #0x42
 80127d4: f7ff f96a    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0xd2c
 80127d8: 2042         	movs	r0, #0x42
 80127da: f7ff f95a    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0xd4c
 80127de: 687b         	ldr	r3, [r7, #0x4]
 80127e0: 695b         	ldr	r3, [r3, #0x14]
 80127e2: f443 4304    	orr	r3, r3, #0x8400
 80127e6: f043 0313    	orr	r3, r3, #0x13
 80127ea: 687a         	ldr	r2, [r7, #0x4]
 80127ec: 6153         	str	r3, [r2, #0x14]
 80127ee: 3708         	adds	r7, #0x8
 80127f0: 46bd         	mov	sp, r7
 80127f2: bd80         	pop	{r7, pc}

080127f4 <stm32_clock_control_mco_init>:
; {
 80127f4: b480         	push	{r7}
 80127f6: af00         	add	r7, sp, #0x0
; }
 80127f8: bf00         	nop
 80127fa: 46bd         	mov	sp, r7
 80127fc: bc80         	pop	{r7}
 80127fe: 4770         	bx	lr

08012800 <get_pll_div_frequency>:
; {
 8012800: b480         	push	{r7}
 8012802: b085         	sub	sp, #0x14
 8012804: af00         	add	r7, sp, #0x0
 8012806: 60f8         	str	r0, [r7, #0xc]
 8012808: 60b9         	str	r1, [r7, #0x8]
 801280a: 607a         	str	r2, [r7, #0x4]
 801280c: 603b         	str	r3, [r7]
; 	return pllsrc_freq / pllm_div * plln_mul / pllout_div;
 801280e: 68bb         	ldr	r3, [r7, #0x8]
 8012810: 68fa         	ldr	r2, [r7, #0xc]
 8012812: fbb2 f3f3    	udiv	r3, r2, r3
 8012816: 687a         	ldr	r2, [r7, #0x4]
 8012818: fb03 f202    	mul	r2, r3, r2
 801281c: 683b         	ldr	r3, [r7]
 801281e: fbb2 f3f3    	udiv	r3, r2, r3
; }
 8012822: 4618         	mov	r0, r3
 8012824: 3714         	adds	r7, #0x14
 8012826: 46bd         	mov	sp, r7
 8012828: bc80         	pop	{r7}
 801282a: 4770         	bx	lr

0801282c <get_bus_clock>:
; {
 801282c: b480         	push	{r7}
 801282e: b083         	sub	sp, #0xc
 8012830: af00         	add	r7, sp, #0x0
 8012832: 6078         	str	r0, [r7, #0x4]
 8012834: 6039         	str	r1, [r7]
; 	return clock / prescaler;
 8012836: 687a         	ldr	r2, [r7, #0x4]
 8012838: 683b         	ldr	r3, [r7]
 801283a: fbb2 f3f3    	udiv	r3, r2, r3
; }
 801283e: 4618         	mov	r0, r3
 8012840: 370c         	adds	r7, #0xc
 8012842: 46bd         	mov	sp, r7
 8012844: bc80         	pop	{r7}
 8012846: 4770         	bx	lr

08012848 <stm32_clock_control_on>:
; {
 8012848: b480         	push	{r7}
 801284a: b089         	sub	sp, #0x24
 801284c: af00         	add	r7, sp, #0x0
 801284e: 6078         	str	r0, [r7, #0x4]
 8012850: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 8012852: 683b         	ldr	r3, [r7]
 8012854: 61fb         	str	r3, [r7, #0x1c]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 8012856: 69fb         	ldr	r3, [r7, #0x1c]
 8012858: 681b         	ldr	r3, [r3]
 801285a: 2b2f         	cmp	r3, #0x2f
 801285c: d905         	bls	0x801286a <stm32_clock_control_on+0x22> @ imm = #0xa
 801285e: 69fb         	ldr	r3, [r7, #0x1c]
 8012860: 681b         	ldr	r3, [r3]
 8012862: 2ba8         	cmp	r3, #0xa8
 8012864: d801         	bhi	0x801286a <stm32_clock_control_on+0x22> @ imm = #0x2
 8012866: 2301         	movs	r3, #0x1
 8012868: e000         	b	0x801286c <stm32_clock_control_on+0x24> @ imm = #0x0
 801286a: 2300         	movs	r3, #0x0
 801286c: 2b00         	cmp	r3, #0x0
 801286e: d102         	bne	0x8012876 <stm32_clock_control_on+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 8012870: f06f 0385    	mvn	r3, #0x85
 8012874: e01e         	b	0x80128b4 <stm32_clock_control_on+0x6c> @ imm = #0x3c
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus,
 8012876: 69fb         	ldr	r3, [r7, #0x1c]
 8012878: 681b         	ldr	r3, [r3]
 801287a: f103 4380    	add.w	r3, r3, #0x40000000
 801287e: f503 330e    	add.w	r3, r3, #0x23800
 8012882: 69fa         	ldr	r2, [r7, #0x1c]
 8012884: 6852         	ldr	r2, [r2, #0x4]
 8012886: 617b         	str	r3, [r7, #0x14]
 8012888: 613a         	str	r2, [r7, #0x10]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801288a: 697b         	ldr	r3, [r7, #0x14]
 801288c: 681b         	ldr	r3, [r3]
 801288e: 60fb         	str	r3, [r7, #0xc]
; 	*(volatile uint32_t *)addr = temp | mask;
 8012890: 697b         	ldr	r3, [r7, #0x14]
 8012892: 6939         	ldr	r1, [r7, #0x10]
 8012894: 68fa         	ldr	r2, [r7, #0xc]
 8012896: 430a         	orrs	r2, r1
 8012898: 601a         	str	r2, [r3]
; }
 801289a: bf00         	nop
; 	temp = sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus);
 801289c: 69fb         	ldr	r3, [r7, #0x1c]
 801289e: 681b         	ldr	r3, [r3]
 80128a0: f103 4380    	add.w	r3, r3, #0x40000000
 80128a4: f503 330e    	add.w	r3, r3, #0x23800
 80128a8: 61bb         	str	r3, [r7, #0x18]
; 	return *(volatile uint32_t *)addr;
 80128aa: 69bb         	ldr	r3, [r7, #0x18]
 80128ac: 681b         	ldr	r3, [r3]
; 	temp = sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus);
 80128ae: 60bb         	str	r3, [r7, #0x8]
; 	UNUSED(temp);
 80128b0: 68bb         	ldr	r3, [r7, #0x8]
; 	return 0;
 80128b2: 2300         	movs	r3, #0x0
; }
 80128b4: 4618         	mov	r0, r3
 80128b6: 3724         	adds	r7, #0x24
 80128b8: 46bd         	mov	sp, r7
 80128ba: bc80         	pop	{r7}
 80128bc: 4770         	bx	lr

080128be <stm32_clock_control_off>:
; {
 80128be: b480         	push	{r7}
 80128c0: b087         	sub	sp, #0x1c
 80128c2: af00         	add	r7, sp, #0x0
 80128c4: 6078         	str	r0, [r7, #0x4]
 80128c6: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 80128c8: 683b         	ldr	r3, [r7]
 80128ca: 617b         	str	r3, [r7, #0x14]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 80128cc: 697b         	ldr	r3, [r7, #0x14]
 80128ce: 681b         	ldr	r3, [r3]
 80128d0: 2b2f         	cmp	r3, #0x2f
 80128d2: d905         	bls	0x80128e0 <stm32_clock_control_off+0x22> @ imm = #0xa
 80128d4: 697b         	ldr	r3, [r7, #0x14]
 80128d6: 681b         	ldr	r3, [r3]
 80128d8: 2ba8         	cmp	r3, #0xa8
 80128da: d801         	bhi	0x80128e0 <stm32_clock_control_off+0x22> @ imm = #0x2
 80128dc: 2301         	movs	r3, #0x1
 80128de: e000         	b	0x80128e2 <stm32_clock_control_off+0x24> @ imm = #0x0
 80128e0: 2300         	movs	r3, #0x0
 80128e2: 2b00         	cmp	r3, #0x0
 80128e4: d102         	bne	0x80128ec <stm32_clock_control_off+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 80128e6: f06f 0385    	mvn	r3, #0x85
 80128ea: e014         	b	0x8012916 <stm32_clock_control_off+0x58> @ imm = #0x28
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus,
 80128ec: 697b         	ldr	r3, [r7, #0x14]
 80128ee: 681b         	ldr	r3, [r3]
 80128f0: f103 4380    	add.w	r3, r3, #0x40000000
 80128f4: f503 330e    	add.w	r3, r3, #0x23800
 80128f8: 697a         	ldr	r2, [r7, #0x14]
 80128fa: 6852         	ldr	r2, [r2, #0x4]
 80128fc: 613b         	str	r3, [r7, #0x10]
 80128fe: 60fa         	str	r2, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8012900: 693b         	ldr	r3, [r7, #0x10]
 8012902: 681b         	ldr	r3, [r3]
 8012904: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 8012906: 68fb         	ldr	r3, [r7, #0xc]
 8012908: 43d9         	mvns	r1, r3
 801290a: 693b         	ldr	r3, [r7, #0x10]
 801290c: 68ba         	ldr	r2, [r7, #0x8]
 801290e: 400a         	ands	r2, r1
 8012910: 601a         	str	r2, [r3]
; }
 8012912: bf00         	nop
; 	return 0;
 8012914: 2300         	movs	r3, #0x0
; }
 8012916: 4618         	mov	r0, r3
 8012918: 371c         	adds	r7, #0x1c
 801291a: 46bd         	mov	sp, r7
 801291c: bc80         	pop	{r7}
 801291e: 4770         	bx	lr

08012920 <stm32_clock_control_configure>:
; {
 8012920: b580         	push	{r7, lr}
 8012922: b08c         	sub	sp, #0x30
 8012924: af00         	add	r7, sp, #0x0
 8012926: 60f8         	str	r0, [r7, #0xc]
 8012928: 60b9         	str	r1, [r7, #0x8]
 801292a: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 801292c: 68bb         	ldr	r3, [r7, #0x8]
 801292e: 62fb         	str	r3, [r7, #0x2c]
; 	err = enabled_clock(pclken->bus);
 8012930: 6afb         	ldr	r3, [r7, #0x2c]
 8012932: 681b         	ldr	r3, [r3]
 8012934: 4618         	mov	r0, r3
 8012936: f7f3 fafb    	bl	0x8005f30 <enabled_clock> @ imm = #-0xca0a
 801293a: 62b8         	str	r0, [r7, #0x28]
; 	if (err < 0) {
 801293c: 6abb         	ldr	r3, [r7, #0x28]
 801293e: 2b00         	cmp	r3, #0x0
 8012940: da01         	bge	0x8012946 <stm32_clock_control_configure+0x26> @ imm = #0x2
; 		return err;
 8012942: 6abb         	ldr	r3, [r7, #0x28]
 8012944: e043         	b	0x80129ce <stm32_clock_control_configure+0xae> @ imm = #0x86
; 	if (pclken->enr == NO_SEL) {
 8012946: 6afb         	ldr	r3, [r7, #0x2c]
 8012948: 685b         	ldr	r3, [r3, #0x4]
 801294a: 2bff         	cmp	r3, #0xff
 801294c: d101         	bne	0x8012952 <stm32_clock_control_configure+0x32> @ imm = #0x2
; 		return 0;
 801294e: 2300         	movs	r3, #0x0
 8012950: e03d         	b	0x80129ce <stm32_clock_control_configure+0xae> @ imm = #0x7a
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 8012952: 6afb         	ldr	r3, [r7, #0x2c]
 8012954: 685b         	ldr	r3, [r3, #0x4]
 8012956: b2db         	uxtb	r3, r3
 8012958: f103 4380    	add.w	r3, r3, #0x40000000
 801295c: f503 330e    	add.w	r3, r3, #0x23800
; 		       STM32_CLOCK_MASK_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 8012960: 6afa         	ldr	r2, [r7, #0x2c]
 8012962: 6852         	ldr	r2, [r2, #0x4]
 8012964: 0b52         	lsrs	r2, r2, #0xd
 8012966: f002 0107    	and	r1, r2, #0x7
 801296a: 6afa         	ldr	r2, [r7, #0x2c]
 801296c: 6852         	ldr	r2, [r2, #0x4]
 801296e: 0a12         	lsrs	r2, r2, #0x8
 8012970: f002 021f    	and	r2, r2, #0x1f
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 8012974: fa01 f202    	lsl.w	r2, r1, r2
 8012978: 61bb         	str	r3, [r7, #0x18]
 801297a: 617a         	str	r2, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801297c: 69bb         	ldr	r3, [r7, #0x18]
 801297e: 681b         	ldr	r3, [r3]
 8012980: 613b         	str	r3, [r7, #0x10]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 8012982: 697b         	ldr	r3, [r7, #0x14]
 8012984: 43d9         	mvns	r1, r3
 8012986: 69bb         	ldr	r3, [r7, #0x18]
 8012988: 693a         	ldr	r2, [r7, #0x10]
 801298a: 400a         	ands	r2, r1
 801298c: 601a         	str	r2, [r3]
; }
 801298e: bf00         	nop
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 8012990: 6afb         	ldr	r3, [r7, #0x2c]
 8012992: 685b         	ldr	r3, [r3, #0x4]
 8012994: b2db         	uxtb	r3, r3
 8012996: f103 4380    	add.w	r3, r3, #0x40000000
 801299a: f503 330e    	add.w	r3, r3, #0x23800
; 		     STM32_CLOCK_VAL_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 801299e: 6afa         	ldr	r2, [r7, #0x2c]
 80129a0: 6852         	ldr	r2, [r2, #0x4]
 80129a2: 0c12         	lsrs	r2, r2, #0x10
 80129a4: f002 0107    	and	r1, r2, #0x7
 80129a8: 6afa         	ldr	r2, [r7, #0x2c]
 80129aa: 6852         	ldr	r2, [r2, #0x4]
 80129ac: 0a12         	lsrs	r2, r2, #0x8
 80129ae: f002 021f    	and	r2, r2, #0x1f
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 80129b2: fa01 f202    	lsl.w	r2, r1, r2
 80129b6: 627b         	str	r3, [r7, #0x24]
 80129b8: 623a         	str	r2, [r7, #0x20]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 80129ba: 6a7b         	ldr	r3, [r7, #0x24]
 80129bc: 681b         	ldr	r3, [r3]
 80129be: 61fb         	str	r3, [r7, #0x1c]
; 	*(volatile uint32_t *)addr = temp | mask;
 80129c0: 6a7b         	ldr	r3, [r7, #0x24]
 80129c2: 6a39         	ldr	r1, [r7, #0x20]
 80129c4: 69fa         	ldr	r2, [r7, #0x1c]
 80129c6: 430a         	orrs	r2, r1
 80129c8: 601a         	str	r2, [r3]
; }
 80129ca: bf00         	nop
; 	return 0;
 80129cc: 2300         	movs	r3, #0x0
; }
 80129ce: 4618         	mov	r0, r3
 80129d0: 3730         	adds	r7, #0x30
 80129d2: 46bd         	mov	sp, r7
 80129d4: bd80         	pop	{r7, pc}

080129d6 <stm32_clock_control_get_status>:
; {
 80129d6: b580         	push	{r7, lr}
 80129d8: b084         	sub	sp, #0x10
 80129da: af00         	add	r7, sp, #0x0
 80129dc: 6078         	str	r0, [r7, #0x4]
 80129de: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)sub_system;
 80129e0: 683b         	ldr	r3, [r7]
 80129e2: 60fb         	str	r3, [r7, #0xc]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == true) {
 80129e4: 68fb         	ldr	r3, [r7, #0xc]
 80129e6: 681b         	ldr	r3, [r3]
 80129e8: 2b2f         	cmp	r3, #0x2f
 80129ea: d905         	bls	0x80129f8 <stm32_clock_control_get_status+0x22> @ imm = #0xa
 80129ec: 68fb         	ldr	r3, [r7, #0xc]
 80129ee: 681b         	ldr	r3, [r3]
 80129f0: 2ba8         	cmp	r3, #0xa8
 80129f2: d801         	bhi	0x80129f8 <stm32_clock_control_get_status+0x22> @ imm = #0x2
 80129f4: 2301         	movs	r3, #0x1
 80129f6: e000         	b	0x80129fa <stm32_clock_control_get_status+0x24> @ imm = #0x0
 80129f8: 2300         	movs	r3, #0x0
 80129fa: 2b01         	cmp	r3, #0x1
 80129fc: d113         	bne	0x8012a26 <stm32_clock_control_get_status+0x50> @ imm = #0x26
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 80129fe: 68fb         	ldr	r3, [r7, #0xc]
 8012a00: 681b         	ldr	r3, [r3]
 8012a02: f103 4380    	add.w	r3, r3, #0x40000000
 8012a06: f503 330e    	add.w	r3, r3, #0x23800
 8012a0a: 60bb         	str	r3, [r7, #0x8]
; 	return *(volatile uint32_t *)addr;
 8012a0c: 68bb         	ldr	r3, [r7, #0x8]
 8012a0e: 681a         	ldr	r2, [r3]
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 8012a10: 68fb         	ldr	r3, [r7, #0xc]
 8012a12: 685b         	ldr	r3, [r3, #0x4]
 8012a14: 401a         	ands	r2, r3
; 		    == pclken->enr) {
 8012a16: 68fb         	ldr	r3, [r7, #0xc]
 8012a18: 685b         	ldr	r3, [r3, #0x4]
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 8012a1a: 429a         	cmp	r2, r3
 8012a1c: d101         	bne	0x8012a22 <stm32_clock_control_get_status+0x4c> @ imm = #0x2
; 			return CLOCK_CONTROL_STATUS_ON;
 8012a1e: 2302         	movs	r3, #0x2
 8012a20: e00c         	b	0x8012a3c <stm32_clock_control_get_status+0x66> @ imm = #0x18
; 			return CLOCK_CONTROL_STATUS_OFF;
 8012a22: 2301         	movs	r3, #0x1
 8012a24: e00a         	b	0x8012a3c <stm32_clock_control_get_status+0x66> @ imm = #0x14
; 		if (enabled_clock(pclken->bus) == 0) {
 8012a26: 68fb         	ldr	r3, [r7, #0xc]
 8012a28: 681b         	ldr	r3, [r3]
 8012a2a: 4618         	mov	r0, r3
 8012a2c: f7f3 fa80    	bl	0x8005f30 <enabled_clock> @ imm = #-0xcb00
 8012a30: 4603         	mov	r3, r0
 8012a32: 2b00         	cmp	r3, #0x0
 8012a34: d101         	bne	0x8012a3a <stm32_clock_control_get_status+0x64> @ imm = #0x2
; 			return CLOCK_CONTROL_STATUS_ON;
 8012a36: 2302         	movs	r3, #0x2
 8012a38: e000         	b	0x8012a3c <stm32_clock_control_get_status+0x66> @ imm = #0x0
; 			return CLOCK_CONTROL_STATUS_OFF;
 8012a3a: 2301         	movs	r3, #0x1
; }
 8012a3c: 4618         	mov	r0, r3
 8012a3e: 3710         	adds	r7, #0x10
 8012a40: 46bd         	mov	sp, r7
 8012a42: bd80         	pop	{r7, pc}

08012a44 <stm32_clock_switch_to_hsi>:
; {
 8012a44: b580         	push	{r7, lr}
 8012a46: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_HSI_IsReady() != 1) {
 8012a48: f7f3 f9aa    	bl	0x8005da0 <LL_RCC_HSI_IsReady> @ imm = #-0xccac
 8012a4c: 4603         	mov	r3, r0
 8012a4e: 2b01         	cmp	r3, #0x1
 8012a50: d007         	beq	0x8012a62 <stm32_clock_switch_to_hsi+0x1e> @ imm = #0xe
; 		LL_RCC_HSI_Enable();
 8012a52: f7f3 f997    	bl	0x8005d84 <LL_RCC_HSI_Enable> @ imm = #-0xccd2
; 		while (LL_RCC_HSI_IsReady() != 1) {
 8012a56: bf00         	nop
 8012a58: f7f3 f9a2    	bl	0x8005da0 <LL_RCC_HSI_IsReady> @ imm = #-0xccbc
 8012a5c: 4603         	mov	r3, r0
 8012a5e: 2b01         	cmp	r3, #0x1
 8012a60: d1fa         	bne	0x8012a58 <stm32_clock_switch_to_hsi+0x14> @ imm = #-0xc
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI);
 8012a62: 2000         	movs	r0, #0x0
 8012a64: f7f3 f9ce    	bl	0x8005e04 <LL_RCC_SetSysClkSource> @ imm = #-0xcc64
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI) {
 8012a68: bf00         	nop
 8012a6a: f7f3 f9df    	bl	0x8005e2c <LL_RCC_GetSysClkSource> @ imm = #-0xcc42
 8012a6e: 4603         	mov	r3, r0
 8012a70: 2b00         	cmp	r3, #0x0
 8012a72: d1fa         	bne	0x8012a6a <stm32_clock_switch_to_hsi+0x26> @ imm = #-0xc
; }
 8012a74: bf00         	nop
 8012a76: bf00         	nop
 8012a78: bd80         	pop	{r7, pc}

08012a7a <set_up_fixed_clock_sources>:
; {
 8012a7a: b580         	push	{r7, lr}
 8012a7c: af00         	add	r7, sp, #0x0
; 			LL_RCC_HSE_DisableBypass();
 8012a7e: f7f3 f953    	bl	0x8005d28 <LL_RCC_HSE_DisableBypass> @ imm = #-0xcd5a
; 		LL_RCC_HSE_Enable();
 8012a82: f7f3 f95f    	bl	0x8005d44 <LL_RCC_HSE_Enable> @ imm = #-0xcd42
; 		while (LL_RCC_HSE_IsReady() != 1) {
 8012a86: bf00         	nop
 8012a88: f7f3 f96a    	bl	0x8005d60 <LL_RCC_HSE_IsReady> @ imm = #-0xcd2c
 8012a8c: 4603         	mov	r3, r0
 8012a8e: 2b01         	cmp	r3, #0x1
 8012a90: d1fa         	bne	0x8012a88 <set_up_fixed_clock_sources+0xe> @ imm = #-0xc
; 		LL_RCC_LSI_Enable();
 8012a92: f7f3 f997    	bl	0x8005dc4 <LL_RCC_LSI_Enable> @ imm = #-0xccd2
; 		while (LL_RCC_LSI_IsReady() != 1) {
 8012a96: bf00         	nop
 8012a98: f7f3 f9a2    	bl	0x8005de0 <LL_RCC_LSI_IsReady> @ imm = #-0xccbc
 8012a9c: 4603         	mov	r3, r0
 8012a9e: 2b01         	cmp	r3, #0x1
 8012aa0: d1fa         	bne	0x8012a98 <set_up_fixed_clock_sources+0x1e> @ imm = #-0xc
; }
 8012aa2: bf00         	nop
 8012aa4: bf00         	nop
 8012aa6: bd80         	pop	{r7, pc}

08012aa8 <config_regulator_voltage>:
; void __weak config_regulator_voltage(uint32_t hclk_freq) {}
 8012aa8: b480         	push	{r7}
 8012aaa: b083         	sub	sp, #0xc
 8012aac: af00         	add	r7, sp, #0x0
 8012aae: 6078         	str	r0, [r7, #0x4]
 8012ab0: bf00         	nop
 8012ab2: 370c         	adds	r7, #0xc
 8012ab4: 46bd         	mov	sp, r7
 8012ab6: bc80         	pop	{r7}
 8012ab8: 4770         	bx	lr

08012aba <get_pll_source>:
; {
 8012aba: b480         	push	{r7}
 8012abc: af00         	add	r7, sp, #0x0
; 		return LL_RCC_PLLSOURCE_HSE;
 8012abe: f44f 0380    	mov.w	r3, #0x400000
; }
 8012ac2: 4618         	mov	r0, r3
 8012ac4: 46bd         	mov	sp, r7
 8012ac6: bc80         	pop	{r7}
 8012ac8: 4770         	bx	lr

08012aca <config_pll_sysclock>:
; {
 8012aca: b580         	push	{r7, lr}
 8012acc: af00         	add	r7, sp, #0x0
; 	LL_RCC_PLL_ConfigDomain_SYS(get_pll_source(),
 8012ace: f7ff fff4    	bl	0x8012aba <get_pll_source> @ imm = #-0x18
 8012ad2: 2300         	movs	r3, #0x0
 8012ad4: 22a8         	movs	r2, #0xa8
 8012ad6: 2106         	movs	r1, #0x6
 8012ad8: f7f3 fbe8    	bl	0x80062ac <LL_RCC_PLL_ConfigDomain_SYS> @ imm = #-0xc830
; }
 8012adc: bf00         	nop
 8012ade: bd80         	pop	{r7, pc}

08012ae0 <config_enable_default_clocks>:
; {
 8012ae0: b580         	push	{r7, lr}
 8012ae2: af00         	add	r7, sp, #0x0
; 	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
 8012ae4: f04f 5080    	mov.w	r0, #0x10000000
 8012ae8: f7f3 fbc8    	bl	0x800627c <LL_APB1_GRP1_EnableClock> @ imm = #-0xc870
; }
 8012aec: bf00         	nop
 8012aee: bd80         	pop	{r7, pc}

08012af0 <device_is_ready>:
; {
 8012af0: b580         	push	{r7, lr}
 8012af2: b082         	sub	sp, #0x8
 8012af4: af00         	add	r7, sp, #0x0
 8012af6: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8012af8: 6878         	ldr	r0, [r7, #0x4]
 8012afa: f004 f96e    	bl	0x8016dda <z_impl_device_is_ready> @ imm = #0x42dc
 8012afe: 4603         	mov	r3, r0
; }
 8012b00: 4618         	mov	r0, r3
 8012b02: 3708         	adds	r7, #0x8
 8012b04: 46bd         	mov	sp, r7
 8012b06: bd80         	pop	{r7, pc}

08012b08 <z_impl_uart_poll_out>:
; {
 8012b08: b580         	push	{r7, lr}
 8012b0a: b084         	sub	sp, #0x10
 8012b0c: af00         	add	r7, sp, #0x0
 8012b0e: 6078         	str	r0, [r7, #0x4]
 8012b10: 460b         	mov	r3, r1
 8012b12: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api =
 8012b14: 687b         	ldr	r3, [r7, #0x4]
 8012b16: 689b         	ldr	r3, [r3, #0x8]
 8012b18: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 8012b1a: 68fb         	ldr	r3, [r7, #0xc]
 8012b1c: 69db         	ldr	r3, [r3, #0x1c]
 8012b1e: 78fa         	ldrb	r2, [r7, #0x3]
 8012b20: 4611         	mov	r1, r2
 8012b22: 6878         	ldr	r0, [r7, #0x4]
 8012b24: 4798         	blx	r3
; }
 8012b26: bf00         	nop
 8012b28: 3710         	adds	r7, #0x10
 8012b2a: 46bd         	mov	sp, r7
 8012b2c: bd80         	pop	{r7, pc}

08012b2e <uart_poll_out>:
; {
 8012b2e: b580         	push	{r7, lr}
 8012b30: b082         	sub	sp, #0x8
 8012b32: af00         	add	r7, sp, #0x0
 8012b34: 6078         	str	r0, [r7, #0x4]
 8012b36: 460b         	mov	r3, r1
 8012b38: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 8012b3a: 78fb         	ldrb	r3, [r7, #0x3]
 8012b3c: 4619         	mov	r1, r3
 8012b3e: 6878         	ldr	r0, [r7, #0x4]
 8012b40: f7ff ffe2    	bl	0x8012b08 <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 8012b44: bf00         	nop
 8012b46: 3708         	adds	r7, #0x8
 8012b48: 46bd         	mov	sp, r7
 8012b4a: bd80         	pop	{r7, pc}

08012b4c <pm_device_runtime_get>:
; {
 8012b4c: b480         	push	{r7}
 8012b4e: b083         	sub	sp, #0xc
 8012b50: af00         	add	r7, sp, #0x0
 8012b52: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8012b54: 2300         	movs	r3, #0x0
; }
 8012b56: 4618         	mov	r0, r3
 8012b58: 370c         	adds	r7, #0xc
 8012b5a: 46bd         	mov	sp, r7
 8012b5c: bc80         	pop	{r7}
 8012b5e: 4770         	bx	lr

08012b60 <pm_device_runtime_put_async>:
; {
 8012b60: b480         	push	{r7}
 8012b62: b085         	sub	sp, #0x14
 8012b64: af00         	add	r7, sp, #0x0
 8012b66: 60f8         	str	r0, [r7, #0xc]
 8012b68: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 8012b6c: 2300         	movs	r3, #0x0
; }
 8012b6e: 4618         	mov	r0, r3
 8012b70: 3714         	adds	r7, #0x14
 8012b72: 46bd         	mov	sp, r7
 8012b74: bc80         	pop	{r7}
 8012b76: 4770         	bx	lr

08012b78 <device_is_ready>:
; {
 8012b78: b580         	push	{r7, lr}
 8012b7a: b082         	sub	sp, #0x8
 8012b7c: af00         	add	r7, sp, #0x0
 8012b7e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8012b80: 6878         	ldr	r0, [r7, #0x4]
 8012b82: f004 f92a    	bl	0x8016dda <z_impl_device_is_ready> @ imm = #0x4254
 8012b86: 4603         	mov	r3, r0
; }
 8012b88: 4618         	mov	r0, r3
 8012b8a: 3708         	adds	r7, #0x8
 8012b8c: 46bd         	mov	sp, r7
 8012b8e: bd80         	pop	{r7, pc}

08012b90 <k_sleep>:
; {
 8012b90: b580         	push	{r7, lr}
 8012b92: b082         	sub	sp, #0x8
 8012b94: af00         	add	r7, sp, #0x0
 8012b96: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8012b9a: e9d7 0100    	ldrd	r0, r1, [r7]
 8012b9e: f7fb fa6d    	bl	0x800e07c <z_impl_k_sleep> @ imm = #-0x4b26
 8012ba2: 4603         	mov	r3, r0
; }
 8012ba4: 4618         	mov	r0, r3
 8012ba6: 3708         	adds	r7, #0x8
 8012ba8: 46bd         	mov	sp, r7
 8012baa: bd80         	pop	{r7, pc}

08012bac <clock_control_on>:
; {
 8012bac: b580         	push	{r7, lr}
 8012bae: b084         	sub	sp, #0x10
 8012bb0: af00         	add	r7, sp, #0x0
 8012bb2: 6078         	str	r0, [r7, #0x4]
 8012bb4: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8012bb6: 687b         	ldr	r3, [r7, #0x4]
 8012bb8: 689b         	ldr	r3, [r3, #0x8]
 8012bba: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8012bbc: 68fb         	ldr	r3, [r7, #0xc]
 8012bbe: 681b         	ldr	r3, [r3]
 8012bc0: 6839         	ldr	r1, [r7]
 8012bc2: 6878         	ldr	r0, [r7, #0x4]
 8012bc4: 4798         	blx	r3
 8012bc6: 4603         	mov	r3, r0
; }
 8012bc8: 4618         	mov	r0, r3
 8012bca: 3710         	adds	r7, #0x10
 8012bcc: 46bd         	mov	sp, r7
 8012bce: bd80         	pop	{r7, pc}

08012bd0 <z_log_msg_runtime_create>:
; {
 8012bd0: b580         	push	{r7, lr}
 8012bd2: b08a         	sub	sp, #0x28
 8012bd4: af04         	add	r7, sp, #0x10
 8012bd6: 60b9         	str	r1, [r7, #0x8]
 8012bd8: 607b         	str	r3, [r7, #0x4]
 8012bda: 4603         	mov	r3, r0
 8012bdc: 73fb         	strb	r3, [r7, #0xf]
 8012bde: 4613         	mov	r3, r2
 8012be0: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8012be2: f107 032c    	add.w	r3, r7, #0x2c
 8012be6: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8012be8: 7bba         	ldrb	r2, [r7, #0xe]
 8012bea: 7bf8         	ldrb	r0, [r7, #0xf]
 8012bec: 697b         	ldr	r3, [r7, #0x14]
 8012bee: 9303         	str	r3, [sp, #0xc]
 8012bf0: 6abb         	ldr	r3, [r7, #0x28]
 8012bf2: 9302         	str	r3, [sp, #0x8]
 8012bf4: 6a7b         	ldr	r3, [r7, #0x24]
 8012bf6: 9301         	str	r3, [sp, #0x4]
 8012bf8: 6a3b         	ldr	r3, [r7, #0x20]
 8012bfa: 9300         	str	r3, [sp]
 8012bfc: 687b         	ldr	r3, [r7, #0x4]
 8012bfe: 68b9         	ldr	r1, [r7, #0x8]
 8012c00: f7ef faa4    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0x10ab8
; }
 8012c04: bf00         	nop
 8012c06: 3718         	adds	r7, #0x18
 8012c08: 46bd         	mov	sp, r7
 8012c0a: bd80         	pop	{r7, pc}

08012c0c <dma_stm32_dump_stream_irq>:
; {
 8012c0c: b580         	push	{r7, lr}
 8012c0e: b084         	sub	sp, #0x10
 8012c10: af00         	add	r7, sp, #0x0
 8012c12: 6078         	str	r0, [r7, #0x4]
 8012c14: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8012c16: 687b         	ldr	r3, [r7, #0x4]
 8012c18: 685b         	ldr	r3, [r3, #0x4]
 8012c1a: 60fb         	str	r3, [r7, #0xc]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8012c1c: 68fb         	ldr	r3, [r7, #0xc]
 8012c1e: 691b         	ldr	r3, [r3, #0x10]
 8012c20: 60bb         	str	r3, [r7, #0x8]
; 	stm32_dma_dump_stream_irq(dma, id);
 8012c22: 6839         	ldr	r1, [r7]
 8012c24: 68b8         	ldr	r0, [r7, #0x8]
 8012c26: f7f4 fd8d    	bl	0x8007744 <stm32_dma_dump_stream_irq> @ imm = #-0xb4e6
; }
 8012c2a: bf00         	nop
 8012c2c: 3710         	adds	r7, #0x10
 8012c2e: 46bd         	mov	sp, r7
 8012c30: bd80         	pop	{r7, pc}

08012c32 <dma_stm32_clear_stream_irq>:
; {
 8012c32: b580         	push	{r7, lr}
 8012c34: b084         	sub	sp, #0x10
 8012c36: af00         	add	r7, sp, #0x0
 8012c38: 6078         	str	r0, [r7, #0x4]
 8012c3a: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8012c3c: 687b         	ldr	r3, [r7, #0x4]
 8012c3e: 685b         	ldr	r3, [r3, #0x4]
 8012c40: 60fb         	str	r3, [r7, #0xc]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8012c42: 68fb         	ldr	r3, [r7, #0xc]
 8012c44: 691b         	ldr	r3, [r3, #0x10]
 8012c46: 60bb         	str	r3, [r7, #0x8]
; 	dma_stm32_clear_tc(dma, id);
 8012c48: 6839         	ldr	r1, [r7]
 8012c4a: 68b8         	ldr	r0, [r7, #0x8]
 8012c4c: f7f4 fcba    	bl	0x80075c4 <dma_stm32_clear_tc> @ imm = #-0xb68c
; 	dma_stm32_clear_ht(dma, id);
 8012c50: 6839         	ldr	r1, [r7]
 8012c52: 68b8         	ldr	r0, [r7, #0x8]
 8012c54: f7f4 fca4    	bl	0x80075a0 <dma_stm32_clear_ht> @ imm = #-0xb6b8
; 	stm32_dma_clear_stream_irq(dma, id);
 8012c58: 6839         	ldr	r1, [r7]
 8012c5a: 68b8         	ldr	r0, [r7, #0x8]
 8012c5c: f000 ff53    	bl	0x8013b06 <stm32_dma_clear_stream_irq> @ imm = #0xea6
; }
 8012c60: bf00         	nop
 8012c62: 3710         	adds	r7, #0x10
 8012c64: 46bd         	mov	sp, r7
 8012c66: bd80         	pop	{r7, pc}

08012c68 <dma_stm32_disable_stream>:
; {
 8012c68: b580         	push	{r7, lr}
 8012c6a: b084         	sub	sp, #0x10
 8012c6c: af00         	add	r7, sp, #0x0
 8012c6e: 6078         	str	r0, [r7, #0x4]
 8012c70: 6039         	str	r1, [r7]
; 	int count = 0;
 8012c72: 2300         	movs	r3, #0x0
 8012c74: 60fb         	str	r3, [r7, #0xc]
; 		if (stm32_dma_disable_stream(dma, id) == 0) {
 8012c76: 6839         	ldr	r1, [r7]
 8012c78: 6878         	ldr	r0, [r7, #0x4]
 8012c7a: f000 ff81    	bl	0x8013b80 <stm32_dma_disable_stream> @ imm = #0xf02
 8012c7e: 4603         	mov	r3, r0
 8012c80: 2b00         	cmp	r3, #0x0
 8012c82: d101         	bne	0x8012c88 <dma_stm32_disable_stream+0x20> @ imm = #0x2
; 			return 0;
 8012c84: 2100         	movs	r1, #0x0
 8012c86: e012         	b	0x8012cae <dma_stm32_disable_stream+0x46> @ imm = #0x24
; 		if (count++ > (5 * 1000)) {
 8012c88: 68fb         	ldr	r3, [r7, #0xc]
 8012c8a: 1c5a         	adds	r2, r3, #0x1
 8012c8c: 60fa         	str	r2, [r7, #0xc]
 8012c8e: f241 3288    	movw	r2, #0x1388
 8012c92: 4293         	cmp	r3, r2
 8012c94: dd02         	ble	0x8012c9c <dma_stm32_disable_stream+0x34> @ imm = #0x4
; 			return -EBUSY;
 8012c96: f06f 010f    	mvn	r1, #0xf
 8012c9a: e008         	b	0x8012cae <dma_stm32_disable_stream+0x46> @ imm = #0x10
; 		k_sleep(K_MSEC(1));
 8012c9c: f04f 020a    	mov.w	r2, #0xa
 8012ca0: f04f 0300    	mov.w	r3, #0x0
 8012ca4: 4610         	mov	r0, r2
 8012ca6: 4619         	mov	r1, r3
 8012ca8: f7ff ff72    	bl	0x8012b90 <k_sleep>     @ imm = #-0x11c
; 	for (;;) {
 8012cac: e7e3         	b	0x8012c76 <dma_stm32_disable_stream+0xe> @ imm = #-0x3a
; }
 8012cae: 460b         	mov	r3, r1
 8012cb0: 4618         	mov	r0, r3
 8012cb2: 3710         	adds	r7, #0x10
 8012cb4: 46bd         	mov	sp, r7
 8012cb6: bd80         	pop	{r7, pc}

08012cb8 <dma_stm32_reload>:
; {
 8012cb8: b580         	push	{r7, lr}
 8012cba: b088         	sub	sp, #0x20
 8012cbc: af00         	add	r7, sp, #0x0
 8012cbe: 60f8         	str	r0, [r7, #0xc]
 8012cc0: 60b9         	str	r1, [r7, #0x8]
 8012cc2: 607a         	str	r2, [r7, #0x4]
 8012cc4: 603b         	str	r3, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8012cc6: 68fb         	ldr	r3, [r7, #0xc]
 8012cc8: 685b         	ldr	r3, [r3, #0x4]
 8012cca: 61fb         	str	r3, [r7, #0x1c]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8012ccc: 69fb         	ldr	r3, [r7, #0x1c]
 8012cce: 691b         	ldr	r3, [r3, #0x10]
 8012cd0: 61bb         	str	r3, [r7, #0x18]
; 	if (id >= config->max_streams) {
 8012cd2: 69fb         	ldr	r3, [r7, #0x1c]
 8012cd4: 695b         	ldr	r3, [r3, #0x14]
 8012cd6: 68ba         	ldr	r2, [r7, #0x8]
 8012cd8: 429a         	cmp	r2, r3
 8012cda: d302         	blo	0x8012ce2 <dma_stm32_reload+0x2a> @ imm = #0x4
; 		return -EINVAL;
 8012cdc: f06f 0315    	mvn	r3, #0x15
 8012ce0: e06c         	b	0x8012dbc <dma_stm32_reload+0x104> @ imm = #0xd8
; 	stream = &config->streams[id];
 8012ce2: 69fb         	ldr	r3, [r7, #0x1c]
 8012ce4: 6999         	ldr	r1, [r3, #0x18]
 8012ce6: 68ba         	ldr	r2, [r7, #0x8]
 8012ce8: 4613         	mov	r3, r2
 8012cea: 00db         	lsls	r3, r3, #0x3
 8012cec: 1a9b         	subs	r3, r3, r2
 8012cee: 009b         	lsls	r3, r3, #0x2
 8012cf0: 440b         	add	r3, r1
 8012cf2: 617b         	str	r3, [r7, #0x14]
; 	if (dma_stm32_disable_stream(dma, id) != 0) {
 8012cf4: 68b9         	ldr	r1, [r7, #0x8]
 8012cf6: 69b8         	ldr	r0, [r7, #0x18]
 8012cf8: f7ff ffb6    	bl	0x8012c68 <dma_stm32_disable_stream> @ imm = #-0x94
 8012cfc: 4603         	mov	r3, r0
 8012cfe: 2b00         	cmp	r3, #0x0
 8012d00: d002         	beq	0x8012d08 <dma_stm32_reload+0x50> @ imm = #0x4
; 		return -EBUSY;
 8012d02: f06f 030f    	mvn	r3, #0xf
 8012d06: e059         	b	0x8012dbc <dma_stm32_reload+0x104> @ imm = #0xb2
; 	switch (stream->direction) {
 8012d08: 697b         	ldr	r3, [r7, #0x14]
 8012d0a: 681b         	ldr	r3, [r3]
 8012d0c: 2b02         	cmp	r3, #0x2
 8012d0e: d018         	beq	0x8012d42 <dma_stm32_reload+0x8a> @ imm = #0x30
 8012d10: 2b02         	cmp	r3, #0x2
 8012d12: d829         	bhi	0x8012d68 <dma_stm32_reload+0xb0> @ imm = #0x52
 8012d14: 2b00         	cmp	r3, #0x0
 8012d16: d014         	beq	0x8012d42 <dma_stm32_reload+0x8a> @ imm = #0x28
 8012d18: 2b01         	cmp	r3, #0x1
 8012d1a: d125         	bne	0x8012d68 <dma_stm32_reload+0xb0> @ imm = #0x4a
; 		LL_DMA_SetMemoryAddress(dma, dma_stm32_id_to_stream(id), src);
 8012d1c: 68b8         	ldr	r0, [r7, #0x8]
 8012d1e: f7f4 fc1f    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xb7c2
 8012d22: 4603         	mov	r3, r0
 8012d24: 687a         	ldr	r2, [r7, #0x4]
 8012d26: 4619         	mov	r1, r3
 8012d28: 69b8         	ldr	r0, [r7, #0x18]
 8012d2a: f7f3 fbb1    	bl	0x8006490 <LL_DMA_SetMemoryAddress> @ imm = #-0xc89e
; 		LL_DMA_SetPeriphAddress(dma, dma_stm32_id_to_stream(id), dst);
 8012d2e: 68b8         	ldr	r0, [r7, #0x8]
 8012d30: f7f4 fc16    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xb7d4
 8012d34: 4603         	mov	r3, r0
 8012d36: 683a         	ldr	r2, [r7]
 8012d38: 4619         	mov	r1, r3
 8012d3a: 69b8         	ldr	r0, [r7, #0x18]
 8012d3c: f7f3 fbc0    	bl	0x80064c0 <LL_DMA_SetPeriphAddress> @ imm = #-0xc880
; 		break;
 8012d40: e015         	b	0x8012d6e <dma_stm32_reload+0xb6> @ imm = #0x2a
; 		LL_DMA_SetPeriphAddress(dma, dma_stm32_id_to_stream(id), src);
 8012d42: 68b8         	ldr	r0, [r7, #0x8]
 8012d44: f7f4 fc0c    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xb7e8
 8012d48: 4603         	mov	r3, r0
 8012d4a: 687a         	ldr	r2, [r7, #0x4]
 8012d4c: 4619         	mov	r1, r3
 8012d4e: 69b8         	ldr	r0, [r7, #0x18]
 8012d50: f7f3 fbb6    	bl	0x80064c0 <LL_DMA_SetPeriphAddress> @ imm = #-0xc894
; 		LL_DMA_SetMemoryAddress(dma, dma_stm32_id_to_stream(id), dst);
 8012d54: 68b8         	ldr	r0, [r7, #0x8]
 8012d56: f7f4 fc03    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xb7fa
 8012d5a: 4603         	mov	r3, r0
 8012d5c: 683a         	ldr	r2, [r7]
 8012d5e: 4619         	mov	r1, r3
 8012d60: 69b8         	ldr	r0, [r7, #0x18]
 8012d62: f7f3 fb95    	bl	0x8006490 <LL_DMA_SetMemoryAddress> @ imm = #-0xc8d6
; 		break;
 8012d66: e002         	b	0x8012d6e <dma_stm32_reload+0xb6> @ imm = #0x4
; 		return -EINVAL;
 8012d68: f06f 0315    	mvn	r3, #0x15
 8012d6c: e026         	b	0x8012dbc <dma_stm32_reload+0x104> @ imm = #0x4c
; 	if (stream->source_periph) {
 8012d6e: 697b         	ldr	r3, [r7, #0x14]
 8012d70: 791b         	ldrb	r3, [r3, #0x4]
 8012d72: 2b00         	cmp	r3, #0x0
 8012d74: d00d         	beq	0x8012d92 <dma_stm32_reload+0xda> @ imm = #0x1a
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8012d76: 68b8         	ldr	r0, [r7, #0x8]
 8012d78: f7f4 fbf2    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xb81c
 8012d7c: 4601         	mov	r1, r0
; 				     size / stream->src_size);
 8012d7e: 697b         	ldr	r3, [r7, #0x14]
 8012d80: 689b         	ldr	r3, [r3, #0x8]
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8012d82: 6aba         	ldr	r2, [r7, #0x28]
 8012d84: fbb2 f3f3    	udiv	r3, r2, r3
 8012d88: 461a         	mov	r2, r3
 8012d8a: 69b8         	ldr	r0, [r7, #0x18]
 8012d8c: f7f3 fb0c    	bl	0x80063a8 <LL_DMA_SetDataLength> @ imm = #-0xc9e8
 8012d90: e00c         	b	0x8012dac <dma_stm32_reload+0xf4> @ imm = #0x18
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8012d92: 68b8         	ldr	r0, [r7, #0x8]
 8012d94: f7f4 fbe4    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xb838
 8012d98: 4601         	mov	r1, r0
; 				     size / stream->dst_size);
 8012d9a: 697b         	ldr	r3, [r7, #0x14]
 8012d9c: 68db         	ldr	r3, [r3, #0xc]
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8012d9e: 6aba         	ldr	r2, [r7, #0x28]
 8012da0: fbb2 f3f3    	udiv	r3, r2, r3
 8012da4: 461a         	mov	r2, r3
 8012da6: 69b8         	ldr	r0, [r7, #0x18]
 8012da8: f7f3 fafe    	bl	0x80063a8 <LL_DMA_SetDataLength> @ imm = #-0xca04
; 	stream->busy = true;
 8012dac: 697b         	ldr	r3, [r7, #0x14]
 8012dae: 2201         	movs	r2, #0x1
 8012db0: 719a         	strb	r2, [r3, #0x6]
; 	stm32_dma_enable_stream(dma, id);
 8012db2: 68b9         	ldr	r1, [r7, #0x8]
 8012db4: 69b8         	ldr	r0, [r7, #0x18]
 8012db6: f000 febb    	bl	0x8013b30 <stm32_dma_enable_stream> @ imm = #0xd76
; 	return 0;
 8012dba: 2300         	movs	r3, #0x0
; }
 8012dbc: 4618         	mov	r0, r3
 8012dbe: 3720         	adds	r7, #0x20
 8012dc0: 46bd         	mov	sp, r7
 8012dc2: bd80         	pop	{r7, pc}

08012dc4 <dma_stm32_start>:
; {
 8012dc4: b580         	push	{r7, lr}
 8012dc6: b086         	sub	sp, #0x18
 8012dc8: af00         	add	r7, sp, #0x0
 8012dca: 6078         	str	r0, [r7, #0x4]
 8012dcc: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8012dce: 687b         	ldr	r3, [r7, #0x4]
 8012dd0: 685b         	ldr	r3, [r3, #0x4]
 8012dd2: 617b         	str	r3, [r7, #0x14]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8012dd4: 697b         	ldr	r3, [r7, #0x14]
 8012dd6: 691b         	ldr	r3, [r3, #0x10]
 8012dd8: 613b         	str	r3, [r7, #0x10]
; 	if (id >= config->max_streams) {
 8012dda: 697b         	ldr	r3, [r7, #0x14]
 8012ddc: 695b         	ldr	r3, [r3, #0x14]
 8012dde: 683a         	ldr	r2, [r7]
 8012de0: 429a         	cmp	r2, r3
 8012de2: d302         	blo	0x8012dea <dma_stm32_start+0x26> @ imm = #0x4
; 		return -EINVAL;
 8012de4: f06f 0315    	mvn	r3, #0x15
 8012de8: e01d         	b	0x8012e26 <dma_stm32_start+0x62> @ imm = #0x3a
; 	if (stm32_dma_is_enabled_stream(dma, id)) {
 8012dea: 6839         	ldr	r1, [r7]
 8012dec: 6938         	ldr	r0, [r7, #0x10]
 8012dee: f000 feb0    	bl	0x8013b52 <stm32_dma_is_enabled_stream> @ imm = #0xd60
 8012df2: 4603         	mov	r3, r0
 8012df4: 2b00         	cmp	r3, #0x0
 8012df6: d001         	beq	0x8012dfc <dma_stm32_start+0x38> @ imm = #0x2
; 		return 0;
 8012df8: 2300         	movs	r3, #0x0
 8012dfa: e014         	b	0x8012e26 <dma_stm32_start+0x62> @ imm = #0x28
; 	stream = &config->streams[id];
 8012dfc: 697b         	ldr	r3, [r7, #0x14]
 8012dfe: 6999         	ldr	r1, [r3, #0x18]
 8012e00: 683a         	ldr	r2, [r7]
 8012e02: 4613         	mov	r3, r2
 8012e04: 00db         	lsls	r3, r3, #0x3
 8012e06: 1a9b         	subs	r3, r3, r2
 8012e08: 009b         	lsls	r3, r3, #0x2
 8012e0a: 440b         	add	r3, r1
 8012e0c: 60fb         	str	r3, [r7, #0xc]
; 	stream->busy = true;
 8012e0e: 68fb         	ldr	r3, [r7, #0xc]
 8012e10: 2201         	movs	r2, #0x1
 8012e12: 719a         	strb	r2, [r3, #0x6]
; 	dma_stm32_clear_stream_irq(dev, id);
 8012e14: 6839         	ldr	r1, [r7]
 8012e16: 6878         	ldr	r0, [r7, #0x4]
 8012e18: f7ff ff0b    	bl	0x8012c32 <dma_stm32_clear_stream_irq> @ imm = #-0x1ea
; 	stm32_dma_enable_stream(dma, id);
 8012e1c: 6839         	ldr	r1, [r7]
 8012e1e: 6938         	ldr	r0, [r7, #0x10]
 8012e20: f000 fe86    	bl	0x8013b30 <stm32_dma_enable_stream> @ imm = #0xd0c
; 	return 0;
 8012e24: 2300         	movs	r3, #0x0
; }
 8012e26: 4618         	mov	r0, r3
 8012e28: 3718         	adds	r7, #0x18
 8012e2a: 46bd         	mov	sp, r7
 8012e2c: bd80         	pop	{r7, pc}

08012e2e <dma_stm32_stop>:
; {
 8012e2e: b580         	push	{r7, lr}
 8012e30: b086         	sub	sp, #0x18
 8012e32: af00         	add	r7, sp, #0x0
 8012e34: 6078         	str	r0, [r7, #0x4]
 8012e36: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8012e38: 687b         	ldr	r3, [r7, #0x4]
 8012e3a: 685b         	ldr	r3, [r3, #0x4]
 8012e3c: 617b         	str	r3, [r7, #0x14]
; 	struct dma_stm32_stream *stream = &config->streams[id - STM32_DMA_STREAM_OFFSET];
 8012e3e: 697b         	ldr	r3, [r7, #0x14]
 8012e40: 6999         	ldr	r1, [r3, #0x18]
 8012e42: 683a         	ldr	r2, [r7]
 8012e44: 4613         	mov	r3, r2
 8012e46: 00db         	lsls	r3, r3, #0x3
 8012e48: 1a9b         	subs	r3, r3, r2
 8012e4a: 009b         	lsls	r3, r3, #0x2
 8012e4c: 440b         	add	r3, r1
 8012e4e: 613b         	str	r3, [r7, #0x10]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8012e50: 697b         	ldr	r3, [r7, #0x14]
 8012e52: 691b         	ldr	r3, [r3, #0x10]
 8012e54: 60fb         	str	r3, [r7, #0xc]
; 	if (id >= config->max_streams) {
 8012e56: 697b         	ldr	r3, [r7, #0x14]
 8012e58: 695b         	ldr	r3, [r3, #0x14]
 8012e5a: 683a         	ldr	r2, [r7]
 8012e5c: 429a         	cmp	r2, r3
 8012e5e: d302         	blo	0x8012e66 <dma_stm32_stop+0x38> @ imm = #0x4
; 		return -EINVAL;
 8012e60: f06f 0315    	mvn	r3, #0x15
 8012e64: e02c         	b	0x8012ec0 <dma_stm32_stop+0x92> @ imm = #0x58
; 	if (stream->hal_override) {
 8012e66: 693b         	ldr	r3, [r7, #0x10]
 8012e68: 795b         	ldrb	r3, [r3, #0x5]
 8012e6a: 2b00         	cmp	r3, #0x0
 8012e6c: d004         	beq	0x8012e78 <dma_stm32_stop+0x4a> @ imm = #0x8
; 		stream->busy = false;
 8012e6e: 693b         	ldr	r3, [r7, #0x10]
 8012e70: 2200         	movs	r2, #0x0
 8012e72: 719a         	strb	r2, [r3, #0x6]
; 		return 0;
 8012e74: 2300         	movs	r3, #0x0
 8012e76: e023         	b	0x8012ec0 <dma_stm32_stop+0x92> @ imm = #0x46
; 	if (!stm32_dma_is_enabled_stream(dma, id)) {
 8012e78: 6839         	ldr	r1, [r7]
 8012e7a: 68f8         	ldr	r0, [r7, #0xc]
 8012e7c: f000 fe69    	bl	0x8013b52 <stm32_dma_is_enabled_stream> @ imm = #0xcd2
 8012e80: 4603         	mov	r3, r0
 8012e82: f083 0301    	eor	r3, r3, #0x1
 8012e86: b2db         	uxtb	r3, r3
 8012e88: 2b00         	cmp	r3, #0x0
 8012e8a: d001         	beq	0x8012e90 <dma_stm32_stop+0x62> @ imm = #0x2
; 		return 0;
 8012e8c: 2300         	movs	r3, #0x0
 8012e8e: e017         	b	0x8012ec0 <dma_stm32_stop+0x92> @ imm = #0x2e
; 	LL_DMA_DisableIT_TC(dma, dma_stm32_id_to_stream(id));
 8012e90: 6838         	ldr	r0, [r7]
 8012e92: f7f4 fb65    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xb936
 8012e96: 4603         	mov	r3, r0
 8012e98: 4619         	mov	r1, r3
 8012e9a: 68f8         	ldr	r0, [r7, #0xc]
 8012e9c: f7f3 fb82    	bl	0x80065a4 <LL_DMA_DisableIT_TC> @ imm = #-0xc8fc
; 	stm32_dma_disable_fifo_irq(dma, id);
 8012ea0: 6839         	ldr	r1, [r7]
 8012ea2: 68f8         	ldr	r0, [r7, #0xc]
 8012ea4: f000 fe8a    	bl	0x8013bbc <stm32_dma_disable_fifo_irq> @ imm = #0xd14
; 	dma_stm32_clear_stream_irq(dev, id);
 8012ea8: 6839         	ldr	r1, [r7]
 8012eaa: 6878         	ldr	r0, [r7, #0x4]
 8012eac: f7ff fec1    	bl	0x8012c32 <dma_stm32_clear_stream_irq> @ imm = #-0x27e
; 	dma_stm32_disable_stream(dma, id);
 8012eb0: 6839         	ldr	r1, [r7]
 8012eb2: 68f8         	ldr	r0, [r7, #0xc]
 8012eb4: f7ff fed8    	bl	0x8012c68 <dma_stm32_disable_stream> @ imm = #-0x250
; 	stream->busy = false;
 8012eb8: 693b         	ldr	r3, [r7, #0x10]
 8012eba: 2200         	movs	r2, #0x0
 8012ebc: 719a         	strb	r2, [r3, #0x6]
; 	return 0;
 8012ebe: 2300         	movs	r3, #0x0
; }
 8012ec0: 4618         	mov	r0, r3
 8012ec2: 3718         	adds	r7, #0x18
 8012ec4: 46bd         	mov	sp, r7
 8012ec6: bd80         	pop	{r7, pc}

08012ec8 <dma_stm32_get_status>:
; {
 8012ec8: b580         	push	{r7, lr}
 8012eca: b088         	sub	sp, #0x20
 8012ecc: af00         	add	r7, sp, #0x0
 8012ece: 60f8         	str	r0, [r7, #0xc]
 8012ed0: 60b9         	str	r1, [r7, #0x8]
 8012ed2: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_stm32_config *config = dev->config;
 8012ed4: 68fb         	ldr	r3, [r7, #0xc]
 8012ed6: 685b         	ldr	r3, [r3, #0x4]
 8012ed8: 61fb         	str	r3, [r7, #0x1c]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8012eda: 69fb         	ldr	r3, [r7, #0x1c]
 8012edc: 691b         	ldr	r3, [r3, #0x10]
 8012ede: 61bb         	str	r3, [r7, #0x18]
; 	if (id >= config->max_streams) {
 8012ee0: 69fb         	ldr	r3, [r7, #0x1c]
 8012ee2: 695b         	ldr	r3, [r3, #0x14]
 8012ee4: 68ba         	ldr	r2, [r7, #0x8]
 8012ee6: 429a         	cmp	r2, r3
 8012ee8: d302         	blo	0x8012ef0 <dma_stm32_get_status+0x28> @ imm = #0x4
; 		return -EINVAL;
 8012eea: f06f 0315    	mvn	r3, #0x15
 8012eee: e01e         	b	0x8012f2e <dma_stm32_get_status+0x66> @ imm = #0x3c
; 	stream = &config->streams[id];
 8012ef0: 69fb         	ldr	r3, [r7, #0x1c]
 8012ef2: 6999         	ldr	r1, [r3, #0x18]
 8012ef4: 68ba         	ldr	r2, [r7, #0x8]
 8012ef6: 4613         	mov	r3, r2
 8012ef8: 00db         	lsls	r3, r3, #0x3
 8012efa: 1a9b         	subs	r3, r3, r2
 8012efc: 009b         	lsls	r3, r3, #0x2
 8012efe: 440b         	add	r3, r1
 8012f00: 617b         	str	r3, [r7, #0x14]
; 	stat->pending_length = LL_DMA_GetDataLength(dma, dma_stm32_id_to_stream(id));
 8012f02: 68b8         	ldr	r0, [r7, #0x8]
 8012f04: f7f4 fb2c    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xb9a8
 8012f08: 4603         	mov	r3, r0
 8012f0a: 4619         	mov	r1, r3
 8012f0c: 69b8         	ldr	r0, [r7, #0x18]
 8012f0e: f7f3 fa6d    	bl	0x80063ec <LL_DMA_GetDataLength> @ imm = #-0xcb26
 8012f12: 4602         	mov	r2, r0
 8012f14: 687b         	ldr	r3, [r7, #0x4]
 8012f16: 605a         	str	r2, [r3, #0x4]
; 	stat->dir = stream->direction;
 8012f18: 697b         	ldr	r3, [r7, #0x14]
 8012f1a: 681b         	ldr	r3, [r3]
 8012f1c: b2da         	uxtb	r2, r3
 8012f1e: 687b         	ldr	r3, [r7, #0x4]
 8012f20: 705a         	strb	r2, [r3, #0x1]
; 	stat->busy = stream->busy;
 8012f22: 697b         	ldr	r3, [r7, #0x14]
 8012f24: 799b         	ldrb	r3, [r3, #0x6]
 8012f26: b2da         	uxtb	r2, r3
 8012f28: 687b         	ldr	r3, [r7, #0x4]
 8012f2a: 701a         	strb	r2, [r3]
; 	return 0;
 8012f2c: 2300         	movs	r3, #0x0
; }
 8012f2e: 4618         	mov	r0, r3
 8012f30: 3720         	adds	r7, #0x20
 8012f32: 46bd         	mov	sp, r7
 8012f34: bd80         	pop	{r7, pc}

08012f36 <dma_stm32_irq_0_0>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 0);
 8012f36: b580         	push	{r7, lr}
 8012f38: b082         	sub	sp, #0x8
 8012f3a: af00         	add	r7, sp, #0x0
 8012f3c: 6078         	str	r0, [r7, #0x4]
 8012f3e: 2100         	movs	r1, #0x0
 8012f40: 6878         	ldr	r0, [r7, #0x4]
 8012f42: f7f3 fb6b    	bl	0x800661c <dma_stm32_irq_handler> @ imm = #-0xc92a
 8012f46: 3708         	adds	r7, #0x8
 8012f48: 46bd         	mov	sp, r7
 8012f4a: bd80         	pop	{r7, pc}

08012f4c <dma_stm32_irq_0_1>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 1);
 8012f4c: b580         	push	{r7, lr}
 8012f4e: b082         	sub	sp, #0x8
 8012f50: af00         	add	r7, sp, #0x0
 8012f52: 6078         	str	r0, [r7, #0x4]
 8012f54: 2101         	movs	r1, #0x1
 8012f56: 6878         	ldr	r0, [r7, #0x4]
 8012f58: f7f3 fb60    	bl	0x800661c <dma_stm32_irq_handler> @ imm = #-0xc940
 8012f5c: 3708         	adds	r7, #0x8
 8012f5e: 46bd         	mov	sp, r7
 8012f60: bd80         	pop	{r7, pc}

08012f62 <dma_stm32_irq_0_2>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 2);
 8012f62: b580         	push	{r7, lr}
 8012f64: b082         	sub	sp, #0x8
 8012f66: af00         	add	r7, sp, #0x0
 8012f68: 6078         	str	r0, [r7, #0x4]
 8012f6a: 2102         	movs	r1, #0x2
 8012f6c: 6878         	ldr	r0, [r7, #0x4]
 8012f6e: f7f3 fb55    	bl	0x800661c <dma_stm32_irq_handler> @ imm = #-0xc956
 8012f72: 3708         	adds	r7, #0x8
 8012f74: 46bd         	mov	sp, r7
 8012f76: bd80         	pop	{r7, pc}

08012f78 <dma_stm32_irq_0_3>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 3);
 8012f78: b580         	push	{r7, lr}
 8012f7a: b082         	sub	sp, #0x8
 8012f7c: af00         	add	r7, sp, #0x0
 8012f7e: 6078         	str	r0, [r7, #0x4]
 8012f80: 2103         	movs	r1, #0x3
 8012f82: 6878         	ldr	r0, [r7, #0x4]
 8012f84: f7f3 fb4a    	bl	0x800661c <dma_stm32_irq_handler> @ imm = #-0xc96c
 8012f88: 3708         	adds	r7, #0x8
 8012f8a: 46bd         	mov	sp, r7
 8012f8c: bd80         	pop	{r7, pc}

08012f8e <dma_stm32_irq_0_4>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 4);
 8012f8e: b580         	push	{r7, lr}
 8012f90: b082         	sub	sp, #0x8
 8012f92: af00         	add	r7, sp, #0x0
 8012f94: 6078         	str	r0, [r7, #0x4]
 8012f96: 2104         	movs	r1, #0x4
 8012f98: 6878         	ldr	r0, [r7, #0x4]
 8012f9a: f7f3 fb3f    	bl	0x800661c <dma_stm32_irq_handler> @ imm = #-0xc982
 8012f9e: 3708         	adds	r7, #0x8
 8012fa0: 46bd         	mov	sp, r7
 8012fa2: bd80         	pop	{r7, pc}

08012fa4 <dma_stm32_irq_0_5>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 5);
 8012fa4: b580         	push	{r7, lr}
 8012fa6: b082         	sub	sp, #0x8
 8012fa8: af00         	add	r7, sp, #0x0
 8012faa: 6078         	str	r0, [r7, #0x4]
 8012fac: 2105         	movs	r1, #0x5
 8012fae: 6878         	ldr	r0, [r7, #0x4]
 8012fb0: f7f3 fb34    	bl	0x800661c <dma_stm32_irq_handler> @ imm = #-0xc998
 8012fb4: 3708         	adds	r7, #0x8
 8012fb6: 46bd         	mov	sp, r7
 8012fb8: bd80         	pop	{r7, pc}

08012fba <dma_stm32_irq_0_6>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 6);
 8012fba: b580         	push	{r7, lr}
 8012fbc: b082         	sub	sp, #0x8
 8012fbe: af00         	add	r7, sp, #0x0
 8012fc0: 6078         	str	r0, [r7, #0x4]
 8012fc2: 2106         	movs	r1, #0x6
 8012fc4: 6878         	ldr	r0, [r7, #0x4]
 8012fc6: f7f3 fb29    	bl	0x800661c <dma_stm32_irq_handler> @ imm = #-0xc9ae
 8012fca: 3708         	adds	r7, #0x8
 8012fcc: 46bd         	mov	sp, r7
 8012fce: bd80         	pop	{r7, pc}

08012fd0 <dma_stm32_irq_0_7>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 7);
 8012fd0: b580         	push	{r7, lr}
 8012fd2: b082         	sub	sp, #0x8
 8012fd4: af00         	add	r7, sp, #0x0
 8012fd6: 6078         	str	r0, [r7, #0x4]
 8012fd8: 2107         	movs	r1, #0x7
 8012fda: 6878         	ldr	r0, [r7, #0x4]
 8012fdc: f7f3 fb1e    	bl	0x800661c <dma_stm32_irq_handler> @ imm = #-0xc9c4
 8012fe0: 3708         	adds	r7, #0x8
 8012fe2: 46bd         	mov	sp, r7
 8012fe4: bd80         	pop	{r7, pc}

08012fe6 <dma_stm32_config_irq_0>:
; {
 8012fe6: b580         	push	{r7, lr}
 8012fe8: b082         	sub	sp, #0x8
 8012fea: af00         	add	r7, sp, #0x0
 8012fec: 6078         	str	r0, [r7, #0x4]
; 	LISTIFY(
 8012fee: 2200         	movs	r2, #0x0
 8012ff0: 2100         	movs	r1, #0x0
 8012ff2: 200b         	movs	r0, #0xb
 8012ff4: f7fe fd5a    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0x154c
 8012ff8: 200b         	movs	r0, #0xb
 8012ffa: f7fe fd4a    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0x156c
 8012ffe: 2200         	movs	r2, #0x0
 8013000: 2100         	movs	r1, #0x0
 8013002: 200c         	movs	r0, #0xc
 8013004: f7fe fd52    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0x155c
 8013008: 200c         	movs	r0, #0xc
 801300a: f7fe fd42    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0x157c
 801300e: 2200         	movs	r2, #0x0
 8013010: 2100         	movs	r1, #0x0
 8013012: 200d         	movs	r0, #0xd
 8013014: f7fe fd4a    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0x156c
 8013018: 200d         	movs	r0, #0xd
 801301a: f7fe fd3a    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0x158c
 801301e: 2200         	movs	r2, #0x0
 8013020: 2100         	movs	r1, #0x0
 8013022: 200e         	movs	r0, #0xe
 8013024: f7fe fd42    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0x157c
 8013028: 200e         	movs	r0, #0xe
 801302a: f7fe fd32    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0x159c
 801302e: 2200         	movs	r2, #0x0
 8013030: 2100         	movs	r1, #0x0
 8013032: 200f         	movs	r0, #0xf
 8013034: f7fe fd3a    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0x158c
 8013038: 200f         	movs	r0, #0xf
 801303a: f7fe fd2a    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0x15ac
 801303e: 2200         	movs	r2, #0x0
 8013040: 2100         	movs	r1, #0x0
 8013042: 2010         	movs	r0, #0x10
 8013044: f7fe fd32    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0x159c
 8013048: 2010         	movs	r0, #0x10
 801304a: f7fe fd22    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0x15bc
 801304e: 2200         	movs	r2, #0x0
 8013050: 2100         	movs	r1, #0x0
 8013052: 2011         	movs	r0, #0x11
 8013054: f7fe fd2a    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0x15ac
 8013058: 2011         	movs	r0, #0x11
 801305a: f7fe fd1a    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0x15cc
 801305e: 2200         	movs	r2, #0x0
 8013060: 2100         	movs	r1, #0x0
 8013062: 202f         	movs	r0, #0x2f
 8013064: f7fe fd22    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0x15bc
 8013068: 202f         	movs	r0, #0x2f
 801306a: f7fe fd12    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0x15dc
; }
 801306e: bf00         	nop
 8013070: 3708         	adds	r7, #0x8
 8013072: 46bd         	mov	sp, r7
 8013074: bd80         	pop	{r7, pc}

08013076 <LL_DMA_IsActiveFlag_HT0>:
; {
 8013076: b480         	push	{r7}
 8013078: b083         	sub	sp, #0xc
 801307a: af00         	add	r7, sp, #0x0
 801307c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF0)==(DMA_LISR_HTIF0));
 801307e: 687b         	ldr	r3, [r7, #0x4]
 8013080: 681b         	ldr	r3, [r3]
 8013082: f003 0310    	and	r3, r3, #0x10
 8013086: 2b10         	cmp	r3, #0x10
 8013088: bf0c         	ite	eq
 801308a: 2301         	moveq	r3, #0x1
 801308c: 2300         	movne	r3, #0x0
 801308e: b2db         	uxtb	r3, r3
; }
 8013090: 4618         	mov	r0, r3
 8013092: 370c         	adds	r7, #0xc
 8013094: 46bd         	mov	sp, r7
 8013096: bc80         	pop	{r7}
 8013098: 4770         	bx	lr

0801309a <LL_DMA_IsActiveFlag_HT1>:
; {
 801309a: b480         	push	{r7}
 801309c: b083         	sub	sp, #0xc
 801309e: af00         	add	r7, sp, #0x0
 80130a0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF1)==(DMA_LISR_HTIF1));
 80130a2: 687b         	ldr	r3, [r7, #0x4]
 80130a4: 681b         	ldr	r3, [r3]
 80130a6: f403 6380    	and	r3, r3, #0x400
 80130aa: f5b3 6f80    	cmp.w	r3, #0x400
 80130ae: bf0c         	ite	eq
 80130b0: 2301         	moveq	r3, #0x1
 80130b2: 2300         	movne	r3, #0x0
 80130b4: b2db         	uxtb	r3, r3
; }
 80130b6: 4618         	mov	r0, r3
 80130b8: 370c         	adds	r7, #0xc
 80130ba: 46bd         	mov	sp, r7
 80130bc: bc80         	pop	{r7}
 80130be: 4770         	bx	lr

080130c0 <LL_DMA_IsActiveFlag_HT2>:
; {
 80130c0: b480         	push	{r7}
 80130c2: b083         	sub	sp, #0xc
 80130c4: af00         	add	r7, sp, #0x0
 80130c6: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF2)==(DMA_LISR_HTIF2));
 80130c8: 687b         	ldr	r3, [r7, #0x4]
 80130ca: 681b         	ldr	r3, [r3]
 80130cc: f403 1380    	and	r3, r3, #0x100000
 80130d0: f5b3 1f80    	cmp.w	r3, #0x100000
 80130d4: bf0c         	ite	eq
 80130d6: 2301         	moveq	r3, #0x1
 80130d8: 2300         	movne	r3, #0x0
 80130da: b2db         	uxtb	r3, r3
; }
 80130dc: 4618         	mov	r0, r3
 80130de: 370c         	adds	r7, #0xc
 80130e0: 46bd         	mov	sp, r7
 80130e2: bc80         	pop	{r7}
 80130e4: 4770         	bx	lr

080130e6 <LL_DMA_IsActiveFlag_HT3>:
; {
 80130e6: b480         	push	{r7}
 80130e8: b083         	sub	sp, #0xc
 80130ea: af00         	add	r7, sp, #0x0
 80130ec: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF3)==(DMA_LISR_HTIF3));
 80130ee: 687b         	ldr	r3, [r7, #0x4]
 80130f0: 681b         	ldr	r3, [r3]
 80130f2: f003 6380    	and	r3, r3, #0x4000000
 80130f6: f1b3 6f80    	cmp.w	r3, #0x4000000
 80130fa: bf0c         	ite	eq
 80130fc: 2301         	moveq	r3, #0x1
 80130fe: 2300         	movne	r3, #0x0
 8013100: b2db         	uxtb	r3, r3
; }
 8013102: 4618         	mov	r0, r3
 8013104: 370c         	adds	r7, #0xc
 8013106: 46bd         	mov	sp, r7
 8013108: bc80         	pop	{r7}
 801310a: 4770         	bx	lr

0801310c <LL_DMA_IsActiveFlag_HT4>:
; {
 801310c: b480         	push	{r7}
 801310e: b083         	sub	sp, #0xc
 8013110: af00         	add	r7, sp, #0x0
 8013112: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF4)==(DMA_HISR_HTIF4));
 8013114: 687b         	ldr	r3, [r7, #0x4]
 8013116: 685b         	ldr	r3, [r3, #0x4]
 8013118: f003 0310    	and	r3, r3, #0x10
 801311c: 2b10         	cmp	r3, #0x10
 801311e: bf0c         	ite	eq
 8013120: 2301         	moveq	r3, #0x1
 8013122: 2300         	movne	r3, #0x0
 8013124: b2db         	uxtb	r3, r3
; }
 8013126: 4618         	mov	r0, r3
 8013128: 370c         	adds	r7, #0xc
 801312a: 46bd         	mov	sp, r7
 801312c: bc80         	pop	{r7}
 801312e: 4770         	bx	lr

08013130 <LL_DMA_IsActiveFlag_HT5>:
; {
 8013130: b480         	push	{r7}
 8013132: b083         	sub	sp, #0xc
 8013134: af00         	add	r7, sp, #0x0
 8013136: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF5)==(DMA_HISR_HTIF5));
 8013138: 687b         	ldr	r3, [r7, #0x4]
 801313a: 685b         	ldr	r3, [r3, #0x4]
 801313c: f403 6380    	and	r3, r3, #0x400
 8013140: f5b3 6f80    	cmp.w	r3, #0x400
 8013144: bf0c         	ite	eq
 8013146: 2301         	moveq	r3, #0x1
 8013148: 2300         	movne	r3, #0x0
 801314a: b2db         	uxtb	r3, r3
; }
 801314c: 4618         	mov	r0, r3
 801314e: 370c         	adds	r7, #0xc
 8013150: 46bd         	mov	sp, r7
 8013152: bc80         	pop	{r7}
 8013154: 4770         	bx	lr

08013156 <LL_DMA_IsActiveFlag_HT6>:
; {
 8013156: b480         	push	{r7}
 8013158: b083         	sub	sp, #0xc
 801315a: af00         	add	r7, sp, #0x0
 801315c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF6)==(DMA_HISR_HTIF6));
 801315e: 687b         	ldr	r3, [r7, #0x4]
 8013160: 685b         	ldr	r3, [r3, #0x4]
 8013162: f403 1380    	and	r3, r3, #0x100000
 8013166: f5b3 1f80    	cmp.w	r3, #0x100000
 801316a: bf0c         	ite	eq
 801316c: 2301         	moveq	r3, #0x1
 801316e: 2300         	movne	r3, #0x0
 8013170: b2db         	uxtb	r3, r3
; }
 8013172: 4618         	mov	r0, r3
 8013174: 370c         	adds	r7, #0xc
 8013176: 46bd         	mov	sp, r7
 8013178: bc80         	pop	{r7}
 801317a: 4770         	bx	lr

0801317c <LL_DMA_IsActiveFlag_HT7>:
; {
 801317c: b480         	push	{r7}
 801317e: b083         	sub	sp, #0xc
 8013180: af00         	add	r7, sp, #0x0
 8013182: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF7)==(DMA_HISR_HTIF7));
 8013184: 687b         	ldr	r3, [r7, #0x4]
 8013186: 685b         	ldr	r3, [r3, #0x4]
 8013188: f003 6380    	and	r3, r3, #0x4000000
 801318c: f1b3 6f80    	cmp.w	r3, #0x4000000
 8013190: bf0c         	ite	eq
 8013192: 2301         	moveq	r3, #0x1
 8013194: 2300         	movne	r3, #0x0
 8013196: b2db         	uxtb	r3, r3
; }
 8013198: 4618         	mov	r0, r3
 801319a: 370c         	adds	r7, #0xc
 801319c: 46bd         	mov	sp, r7
 801319e: bc80         	pop	{r7}
 80131a0: 4770         	bx	lr

080131a2 <LL_DMA_IsActiveFlag_TC0>:
; {
 80131a2: b480         	push	{r7}
 80131a4: b083         	sub	sp, #0xc
 80131a6: af00         	add	r7, sp, #0x0
 80131a8: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF0)==(DMA_LISR_TCIF0));
 80131aa: 687b         	ldr	r3, [r7, #0x4]
 80131ac: 681b         	ldr	r3, [r3]
 80131ae: f003 0320    	and	r3, r3, #0x20
 80131b2: 2b20         	cmp	r3, #0x20
 80131b4: bf0c         	ite	eq
 80131b6: 2301         	moveq	r3, #0x1
 80131b8: 2300         	movne	r3, #0x0
 80131ba: b2db         	uxtb	r3, r3
; }
 80131bc: 4618         	mov	r0, r3
 80131be: 370c         	adds	r7, #0xc
 80131c0: 46bd         	mov	sp, r7
 80131c2: bc80         	pop	{r7}
 80131c4: 4770         	bx	lr

080131c6 <LL_DMA_IsActiveFlag_TC1>:
; {
 80131c6: b480         	push	{r7}
 80131c8: b083         	sub	sp, #0xc
 80131ca: af00         	add	r7, sp, #0x0
 80131cc: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF1)==(DMA_LISR_TCIF1));
 80131ce: 687b         	ldr	r3, [r7, #0x4]
 80131d0: 681b         	ldr	r3, [r3]
 80131d2: f403 6300    	and	r3, r3, #0x800
 80131d6: f5b3 6f00    	cmp.w	r3, #0x800
 80131da: bf0c         	ite	eq
 80131dc: 2301         	moveq	r3, #0x1
 80131de: 2300         	movne	r3, #0x0
 80131e0: b2db         	uxtb	r3, r3
; }
 80131e2: 4618         	mov	r0, r3
 80131e4: 370c         	adds	r7, #0xc
 80131e6: 46bd         	mov	sp, r7
 80131e8: bc80         	pop	{r7}
 80131ea: 4770         	bx	lr

080131ec <LL_DMA_IsActiveFlag_TC2>:
; {
 80131ec: b480         	push	{r7}
 80131ee: b083         	sub	sp, #0xc
 80131f0: af00         	add	r7, sp, #0x0
 80131f2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF2)==(DMA_LISR_TCIF2));
 80131f4: 687b         	ldr	r3, [r7, #0x4]
 80131f6: 681b         	ldr	r3, [r3]
 80131f8: f403 1300    	and	r3, r3, #0x200000
 80131fc: f5b3 1f00    	cmp.w	r3, #0x200000
 8013200: bf0c         	ite	eq
 8013202: 2301         	moveq	r3, #0x1
 8013204: 2300         	movne	r3, #0x0
 8013206: b2db         	uxtb	r3, r3
; }
 8013208: 4618         	mov	r0, r3
 801320a: 370c         	adds	r7, #0xc
 801320c: 46bd         	mov	sp, r7
 801320e: bc80         	pop	{r7}
 8013210: 4770         	bx	lr

08013212 <LL_DMA_IsActiveFlag_TC3>:
; {
 8013212: b480         	push	{r7}
 8013214: b083         	sub	sp, #0xc
 8013216: af00         	add	r7, sp, #0x0
 8013218: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF3)==(DMA_LISR_TCIF3));
 801321a: 687b         	ldr	r3, [r7, #0x4]
 801321c: 681b         	ldr	r3, [r3]
 801321e: f003 6300    	and	r3, r3, #0x8000000
 8013222: f1b3 6f00    	cmp.w	r3, #0x8000000
 8013226: bf0c         	ite	eq
 8013228: 2301         	moveq	r3, #0x1
 801322a: 2300         	movne	r3, #0x0
 801322c: b2db         	uxtb	r3, r3
; }
 801322e: 4618         	mov	r0, r3
 8013230: 370c         	adds	r7, #0xc
 8013232: 46bd         	mov	sp, r7
 8013234: bc80         	pop	{r7}
 8013236: 4770         	bx	lr

08013238 <LL_DMA_IsActiveFlag_TC4>:
; {
 8013238: b480         	push	{r7}
 801323a: b083         	sub	sp, #0xc
 801323c: af00         	add	r7, sp, #0x0
 801323e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF4)==(DMA_HISR_TCIF4));
 8013240: 687b         	ldr	r3, [r7, #0x4]
 8013242: 685b         	ldr	r3, [r3, #0x4]
 8013244: f003 0320    	and	r3, r3, #0x20
 8013248: 2b20         	cmp	r3, #0x20
 801324a: bf0c         	ite	eq
 801324c: 2301         	moveq	r3, #0x1
 801324e: 2300         	movne	r3, #0x0
 8013250: b2db         	uxtb	r3, r3
; }
 8013252: 4618         	mov	r0, r3
 8013254: 370c         	adds	r7, #0xc
 8013256: 46bd         	mov	sp, r7
 8013258: bc80         	pop	{r7}
 801325a: 4770         	bx	lr

0801325c <LL_DMA_IsActiveFlag_TC5>:
; {
 801325c: b480         	push	{r7}
 801325e: b083         	sub	sp, #0xc
 8013260: af00         	add	r7, sp, #0x0
 8013262: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF5)==(DMA_HISR_TCIF5));
 8013264: 687b         	ldr	r3, [r7, #0x4]
 8013266: 685b         	ldr	r3, [r3, #0x4]
 8013268: f403 6300    	and	r3, r3, #0x800
 801326c: f5b3 6f00    	cmp.w	r3, #0x800
 8013270: bf0c         	ite	eq
 8013272: 2301         	moveq	r3, #0x1
 8013274: 2300         	movne	r3, #0x0
 8013276: b2db         	uxtb	r3, r3
; }
 8013278: 4618         	mov	r0, r3
 801327a: 370c         	adds	r7, #0xc
 801327c: 46bd         	mov	sp, r7
 801327e: bc80         	pop	{r7}
 8013280: 4770         	bx	lr

08013282 <LL_DMA_IsActiveFlag_TC6>:
; {
 8013282: b480         	push	{r7}
 8013284: b083         	sub	sp, #0xc
 8013286: af00         	add	r7, sp, #0x0
 8013288: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF6)==(DMA_HISR_TCIF6));
 801328a: 687b         	ldr	r3, [r7, #0x4]
 801328c: 685b         	ldr	r3, [r3, #0x4]
 801328e: f403 1300    	and	r3, r3, #0x200000
 8013292: f5b3 1f00    	cmp.w	r3, #0x200000
 8013296: bf0c         	ite	eq
 8013298: 2301         	moveq	r3, #0x1
 801329a: 2300         	movne	r3, #0x0
 801329c: b2db         	uxtb	r3, r3
; }
 801329e: 4618         	mov	r0, r3
 80132a0: 370c         	adds	r7, #0xc
 80132a2: 46bd         	mov	sp, r7
 80132a4: bc80         	pop	{r7}
 80132a6: 4770         	bx	lr

080132a8 <LL_DMA_IsActiveFlag_TC7>:
; {
 80132a8: b480         	push	{r7}
 80132aa: b083         	sub	sp, #0xc
 80132ac: af00         	add	r7, sp, #0x0
 80132ae: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF7)==(DMA_HISR_TCIF7));
 80132b0: 687b         	ldr	r3, [r7, #0x4]
 80132b2: 685b         	ldr	r3, [r3, #0x4]
 80132b4: f003 6300    	and	r3, r3, #0x8000000
 80132b8: f1b3 6f00    	cmp.w	r3, #0x8000000
 80132bc: bf0c         	ite	eq
 80132be: 2301         	moveq	r3, #0x1
 80132c0: 2300         	movne	r3, #0x0
 80132c2: b2db         	uxtb	r3, r3
; }
 80132c4: 4618         	mov	r0, r3
 80132c6: 370c         	adds	r7, #0xc
 80132c8: 46bd         	mov	sp, r7
 80132ca: bc80         	pop	{r7}
 80132cc: 4770         	bx	lr

080132ce <LL_DMA_IsActiveFlag_TE0>:
; {
 80132ce: b480         	push	{r7}
 80132d0: b083         	sub	sp, #0xc
 80132d2: af00         	add	r7, sp, #0x0
 80132d4: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF0)==(DMA_LISR_TEIF0));
 80132d6: 687b         	ldr	r3, [r7, #0x4]
 80132d8: 681b         	ldr	r3, [r3]
 80132da: f003 0308    	and	r3, r3, #0x8
 80132de: 2b08         	cmp	r3, #0x8
 80132e0: bf0c         	ite	eq
 80132e2: 2301         	moveq	r3, #0x1
 80132e4: 2300         	movne	r3, #0x0
 80132e6: b2db         	uxtb	r3, r3
; }
 80132e8: 4618         	mov	r0, r3
 80132ea: 370c         	adds	r7, #0xc
 80132ec: 46bd         	mov	sp, r7
 80132ee: bc80         	pop	{r7}
 80132f0: 4770         	bx	lr

080132f2 <LL_DMA_IsActiveFlag_TE1>:
; {
 80132f2: b480         	push	{r7}
 80132f4: b083         	sub	sp, #0xc
 80132f6: af00         	add	r7, sp, #0x0
 80132f8: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF1)==(DMA_LISR_TEIF1));
 80132fa: 687b         	ldr	r3, [r7, #0x4]
 80132fc: 681b         	ldr	r3, [r3]
 80132fe: f403 7300    	and	r3, r3, #0x200
 8013302: f5b3 7f00    	cmp.w	r3, #0x200
 8013306: bf0c         	ite	eq
 8013308: 2301         	moveq	r3, #0x1
 801330a: 2300         	movne	r3, #0x0
 801330c: b2db         	uxtb	r3, r3
; }
 801330e: 4618         	mov	r0, r3
 8013310: 370c         	adds	r7, #0xc
 8013312: 46bd         	mov	sp, r7
 8013314: bc80         	pop	{r7}
 8013316: 4770         	bx	lr

08013318 <LL_DMA_IsActiveFlag_TE2>:
; {
 8013318: b480         	push	{r7}
 801331a: b083         	sub	sp, #0xc
 801331c: af00         	add	r7, sp, #0x0
 801331e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF2)==(DMA_LISR_TEIF2));
 8013320: 687b         	ldr	r3, [r7, #0x4]
 8013322: 681b         	ldr	r3, [r3]
 8013324: f403 2300    	and	r3, r3, #0x80000
 8013328: f5b3 2f00    	cmp.w	r3, #0x80000
 801332c: bf0c         	ite	eq
 801332e: 2301         	moveq	r3, #0x1
 8013330: 2300         	movne	r3, #0x0
 8013332: b2db         	uxtb	r3, r3
; }
 8013334: 4618         	mov	r0, r3
 8013336: 370c         	adds	r7, #0xc
 8013338: 46bd         	mov	sp, r7
 801333a: bc80         	pop	{r7}
 801333c: 4770         	bx	lr

0801333e <LL_DMA_IsActiveFlag_TE3>:
; {
 801333e: b480         	push	{r7}
 8013340: b083         	sub	sp, #0xc
 8013342: af00         	add	r7, sp, #0x0
 8013344: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF3)==(DMA_LISR_TEIF3));
 8013346: 687b         	ldr	r3, [r7, #0x4]
 8013348: 681b         	ldr	r3, [r3]
 801334a: f003 7300    	and	r3, r3, #0x2000000
 801334e: f1b3 7f00    	cmp.w	r3, #0x2000000
 8013352: bf0c         	ite	eq
 8013354: 2301         	moveq	r3, #0x1
 8013356: 2300         	movne	r3, #0x0
 8013358: b2db         	uxtb	r3, r3
; }
 801335a: 4618         	mov	r0, r3
 801335c: 370c         	adds	r7, #0xc
 801335e: 46bd         	mov	sp, r7
 8013360: bc80         	pop	{r7}
 8013362: 4770         	bx	lr

08013364 <LL_DMA_IsActiveFlag_TE4>:
; {
 8013364: b480         	push	{r7}
 8013366: b083         	sub	sp, #0xc
 8013368: af00         	add	r7, sp, #0x0
 801336a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF4)==(DMA_HISR_TEIF4));
 801336c: 687b         	ldr	r3, [r7, #0x4]
 801336e: 685b         	ldr	r3, [r3, #0x4]
 8013370: f003 0308    	and	r3, r3, #0x8
 8013374: 2b08         	cmp	r3, #0x8
 8013376: bf0c         	ite	eq
 8013378: 2301         	moveq	r3, #0x1
 801337a: 2300         	movne	r3, #0x0
 801337c: b2db         	uxtb	r3, r3
; }
 801337e: 4618         	mov	r0, r3
 8013380: 370c         	adds	r7, #0xc
 8013382: 46bd         	mov	sp, r7
 8013384: bc80         	pop	{r7}
 8013386: 4770         	bx	lr

08013388 <LL_DMA_IsActiveFlag_TE5>:
; {
 8013388: b480         	push	{r7}
 801338a: b083         	sub	sp, #0xc
 801338c: af00         	add	r7, sp, #0x0
 801338e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF5)==(DMA_HISR_TEIF5));
 8013390: 687b         	ldr	r3, [r7, #0x4]
 8013392: 685b         	ldr	r3, [r3, #0x4]
 8013394: f403 7300    	and	r3, r3, #0x200
 8013398: f5b3 7f00    	cmp.w	r3, #0x200
 801339c: bf0c         	ite	eq
 801339e: 2301         	moveq	r3, #0x1
 80133a0: 2300         	movne	r3, #0x0
 80133a2: b2db         	uxtb	r3, r3
; }
 80133a4: 4618         	mov	r0, r3
 80133a6: 370c         	adds	r7, #0xc
 80133a8: 46bd         	mov	sp, r7
 80133aa: bc80         	pop	{r7}
 80133ac: 4770         	bx	lr

080133ae <LL_DMA_IsActiveFlag_TE6>:
; {
 80133ae: b480         	push	{r7}
 80133b0: b083         	sub	sp, #0xc
 80133b2: af00         	add	r7, sp, #0x0
 80133b4: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF6)==(DMA_HISR_TEIF6));
 80133b6: 687b         	ldr	r3, [r7, #0x4]
 80133b8: 685b         	ldr	r3, [r3, #0x4]
 80133ba: f403 2300    	and	r3, r3, #0x80000
 80133be: f5b3 2f00    	cmp.w	r3, #0x80000
 80133c2: bf0c         	ite	eq
 80133c4: 2301         	moveq	r3, #0x1
 80133c6: 2300         	movne	r3, #0x0
 80133c8: b2db         	uxtb	r3, r3
; }
 80133ca: 4618         	mov	r0, r3
 80133cc: 370c         	adds	r7, #0xc
 80133ce: 46bd         	mov	sp, r7
 80133d0: bc80         	pop	{r7}
 80133d2: 4770         	bx	lr

080133d4 <LL_DMA_IsActiveFlag_TE7>:
; {
 80133d4: b480         	push	{r7}
 80133d6: b083         	sub	sp, #0xc
 80133d8: af00         	add	r7, sp, #0x0
 80133da: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF7)==(DMA_HISR_TEIF7));
 80133dc: 687b         	ldr	r3, [r7, #0x4]
 80133de: 685b         	ldr	r3, [r3, #0x4]
 80133e0: f003 7300    	and	r3, r3, #0x2000000
 80133e4: f1b3 7f00    	cmp.w	r3, #0x2000000
 80133e8: bf0c         	ite	eq
 80133ea: 2301         	moveq	r3, #0x1
 80133ec: 2300         	movne	r3, #0x0
 80133ee: b2db         	uxtb	r3, r3
; }
 80133f0: 4618         	mov	r0, r3
 80133f2: 370c         	adds	r7, #0xc
 80133f4: 46bd         	mov	sp, r7
 80133f6: bc80         	pop	{r7}
 80133f8: 4770         	bx	lr

080133fa <LL_DMA_IsActiveFlag_DME0>:
; {
 80133fa: b480         	push	{r7}
 80133fc: b083         	sub	sp, #0xc
 80133fe: af00         	add	r7, sp, #0x0
 8013400: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF0)==(DMA_LISR_DMEIF0));
 8013402: 687b         	ldr	r3, [r7, #0x4]
 8013404: 681b         	ldr	r3, [r3]
 8013406: f003 0304    	and	r3, r3, #0x4
 801340a: 2b04         	cmp	r3, #0x4
 801340c: bf0c         	ite	eq
 801340e: 2301         	moveq	r3, #0x1
 8013410: 2300         	movne	r3, #0x0
 8013412: b2db         	uxtb	r3, r3
; }
 8013414: 4618         	mov	r0, r3
 8013416: 370c         	adds	r7, #0xc
 8013418: 46bd         	mov	sp, r7
 801341a: bc80         	pop	{r7}
 801341c: 4770         	bx	lr

0801341e <LL_DMA_IsActiveFlag_DME1>:
; {
 801341e: b480         	push	{r7}
 8013420: b083         	sub	sp, #0xc
 8013422: af00         	add	r7, sp, #0x0
 8013424: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF1)==(DMA_LISR_DMEIF1));
 8013426: 687b         	ldr	r3, [r7, #0x4]
 8013428: 681b         	ldr	r3, [r3]
 801342a: f403 7380    	and	r3, r3, #0x100
 801342e: f5b3 7f80    	cmp.w	r3, #0x100
 8013432: bf0c         	ite	eq
 8013434: 2301         	moveq	r3, #0x1
 8013436: 2300         	movne	r3, #0x0
 8013438: b2db         	uxtb	r3, r3
; }
 801343a: 4618         	mov	r0, r3
 801343c: 370c         	adds	r7, #0xc
 801343e: 46bd         	mov	sp, r7
 8013440: bc80         	pop	{r7}
 8013442: 4770         	bx	lr

08013444 <LL_DMA_IsActiveFlag_DME2>:
; {
 8013444: b480         	push	{r7}
 8013446: b083         	sub	sp, #0xc
 8013448: af00         	add	r7, sp, #0x0
 801344a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF2)==(DMA_LISR_DMEIF2));
 801344c: 687b         	ldr	r3, [r7, #0x4]
 801344e: 681b         	ldr	r3, [r3]
 8013450: f403 2380    	and	r3, r3, #0x40000
 8013454: f5b3 2f80    	cmp.w	r3, #0x40000
 8013458: bf0c         	ite	eq
 801345a: 2301         	moveq	r3, #0x1
 801345c: 2300         	movne	r3, #0x0
 801345e: b2db         	uxtb	r3, r3
; }
 8013460: 4618         	mov	r0, r3
 8013462: 370c         	adds	r7, #0xc
 8013464: 46bd         	mov	sp, r7
 8013466: bc80         	pop	{r7}
 8013468: 4770         	bx	lr

0801346a <LL_DMA_IsActiveFlag_DME3>:
; {
 801346a: b480         	push	{r7}
 801346c: b083         	sub	sp, #0xc
 801346e: af00         	add	r7, sp, #0x0
 8013470: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF3)==(DMA_LISR_DMEIF3));
 8013472: 687b         	ldr	r3, [r7, #0x4]
 8013474: 681b         	ldr	r3, [r3]
 8013476: f003 7380    	and	r3, r3, #0x1000000
 801347a: f1b3 7f80    	cmp.w	r3, #0x1000000
 801347e: bf0c         	ite	eq
 8013480: 2301         	moveq	r3, #0x1
 8013482: 2300         	movne	r3, #0x0
 8013484: b2db         	uxtb	r3, r3
; }
 8013486: 4618         	mov	r0, r3
 8013488: 370c         	adds	r7, #0xc
 801348a: 46bd         	mov	sp, r7
 801348c: bc80         	pop	{r7}
 801348e: 4770         	bx	lr

08013490 <LL_DMA_IsActiveFlag_DME4>:
; {
 8013490: b480         	push	{r7}
 8013492: b083         	sub	sp, #0xc
 8013494: af00         	add	r7, sp, #0x0
 8013496: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF4)==(DMA_HISR_DMEIF4));
 8013498: 687b         	ldr	r3, [r7, #0x4]
 801349a: 685b         	ldr	r3, [r3, #0x4]
 801349c: f003 0304    	and	r3, r3, #0x4
 80134a0: 2b04         	cmp	r3, #0x4
 80134a2: bf0c         	ite	eq
 80134a4: 2301         	moveq	r3, #0x1
 80134a6: 2300         	movne	r3, #0x0
 80134a8: b2db         	uxtb	r3, r3
; }
 80134aa: 4618         	mov	r0, r3
 80134ac: 370c         	adds	r7, #0xc
 80134ae: 46bd         	mov	sp, r7
 80134b0: bc80         	pop	{r7}
 80134b2: 4770         	bx	lr

080134b4 <LL_DMA_IsActiveFlag_DME5>:
; {
 80134b4: b480         	push	{r7}
 80134b6: b083         	sub	sp, #0xc
 80134b8: af00         	add	r7, sp, #0x0
 80134ba: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF5)==(DMA_HISR_DMEIF5));
 80134bc: 687b         	ldr	r3, [r7, #0x4]
 80134be: 685b         	ldr	r3, [r3, #0x4]
 80134c0: f403 7380    	and	r3, r3, #0x100
 80134c4: f5b3 7f80    	cmp.w	r3, #0x100
 80134c8: bf0c         	ite	eq
 80134ca: 2301         	moveq	r3, #0x1
 80134cc: 2300         	movne	r3, #0x0
 80134ce: b2db         	uxtb	r3, r3
; }
 80134d0: 4618         	mov	r0, r3
 80134d2: 370c         	adds	r7, #0xc
 80134d4: 46bd         	mov	sp, r7
 80134d6: bc80         	pop	{r7}
 80134d8: 4770         	bx	lr

080134da <LL_DMA_IsActiveFlag_DME6>:
; {
 80134da: b480         	push	{r7}
 80134dc: b083         	sub	sp, #0xc
 80134de: af00         	add	r7, sp, #0x0
 80134e0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF6)==(DMA_HISR_DMEIF6));
 80134e2: 687b         	ldr	r3, [r7, #0x4]
 80134e4: 685b         	ldr	r3, [r3, #0x4]
 80134e6: f403 2380    	and	r3, r3, #0x40000
 80134ea: f5b3 2f80    	cmp.w	r3, #0x40000
 80134ee: bf0c         	ite	eq
 80134f0: 2301         	moveq	r3, #0x1
 80134f2: 2300         	movne	r3, #0x0
 80134f4: b2db         	uxtb	r3, r3
; }
 80134f6: 4618         	mov	r0, r3
 80134f8: 370c         	adds	r7, #0xc
 80134fa: 46bd         	mov	sp, r7
 80134fc: bc80         	pop	{r7}
 80134fe: 4770         	bx	lr

08013500 <LL_DMA_IsActiveFlag_DME7>:
; {
 8013500: b480         	push	{r7}
 8013502: b083         	sub	sp, #0xc
 8013504: af00         	add	r7, sp, #0x0
 8013506: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF7)==(DMA_HISR_DMEIF7));
 8013508: 687b         	ldr	r3, [r7, #0x4]
 801350a: 685b         	ldr	r3, [r3, #0x4]
 801350c: f003 7380    	and	r3, r3, #0x1000000
 8013510: f1b3 7f80    	cmp.w	r3, #0x1000000
 8013514: bf0c         	ite	eq
 8013516: 2301         	moveq	r3, #0x1
 8013518: 2300         	movne	r3, #0x0
 801351a: b2db         	uxtb	r3, r3
; }
 801351c: 4618         	mov	r0, r3
 801351e: 370c         	adds	r7, #0xc
 8013520: 46bd         	mov	sp, r7
 8013522: bc80         	pop	{r7}
 8013524: 4770         	bx	lr

08013526 <LL_DMA_IsActiveFlag_FE0>:
; {
 8013526: b480         	push	{r7}
 8013528: b083         	sub	sp, #0xc
 801352a: af00         	add	r7, sp, #0x0
 801352c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF0)==(DMA_LISR_FEIF0));
 801352e: 687b         	ldr	r3, [r7, #0x4]
 8013530: 681b         	ldr	r3, [r3]
 8013532: f003 0301    	and	r3, r3, #0x1
 8013536: 2b01         	cmp	r3, #0x1
 8013538: bf0c         	ite	eq
 801353a: 2301         	moveq	r3, #0x1
 801353c: 2300         	movne	r3, #0x0
 801353e: b2db         	uxtb	r3, r3
; }
 8013540: 4618         	mov	r0, r3
 8013542: 370c         	adds	r7, #0xc
 8013544: 46bd         	mov	sp, r7
 8013546: bc80         	pop	{r7}
 8013548: 4770         	bx	lr

0801354a <LL_DMA_IsActiveFlag_FE1>:
; {
 801354a: b480         	push	{r7}
 801354c: b083         	sub	sp, #0xc
 801354e: af00         	add	r7, sp, #0x0
 8013550: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF1)==(DMA_LISR_FEIF1));
 8013552: 687b         	ldr	r3, [r7, #0x4]
 8013554: 681b         	ldr	r3, [r3]
 8013556: f003 0340    	and	r3, r3, #0x40
 801355a: 2b40         	cmp	r3, #0x40
 801355c: bf0c         	ite	eq
 801355e: 2301         	moveq	r3, #0x1
 8013560: 2300         	movne	r3, #0x0
 8013562: b2db         	uxtb	r3, r3
; }
 8013564: 4618         	mov	r0, r3
 8013566: 370c         	adds	r7, #0xc
 8013568: 46bd         	mov	sp, r7
 801356a: bc80         	pop	{r7}
 801356c: 4770         	bx	lr

0801356e <LL_DMA_IsActiveFlag_FE2>:
; {
 801356e: b480         	push	{r7}
 8013570: b083         	sub	sp, #0xc
 8013572: af00         	add	r7, sp, #0x0
 8013574: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF2)==(DMA_LISR_FEIF2));
 8013576: 687b         	ldr	r3, [r7, #0x4]
 8013578: 681b         	ldr	r3, [r3]
 801357a: f403 3380    	and	r3, r3, #0x10000
 801357e: f5b3 3f80    	cmp.w	r3, #0x10000
 8013582: bf0c         	ite	eq
 8013584: 2301         	moveq	r3, #0x1
 8013586: 2300         	movne	r3, #0x0
 8013588: b2db         	uxtb	r3, r3
; }
 801358a: 4618         	mov	r0, r3
 801358c: 370c         	adds	r7, #0xc
 801358e: 46bd         	mov	sp, r7
 8013590: bc80         	pop	{r7}
 8013592: 4770         	bx	lr

08013594 <LL_DMA_IsActiveFlag_FE3>:
; {
 8013594: b480         	push	{r7}
 8013596: b083         	sub	sp, #0xc
 8013598: af00         	add	r7, sp, #0x0
 801359a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF3)==(DMA_LISR_FEIF3));
 801359c: 687b         	ldr	r3, [r7, #0x4]
 801359e: 681b         	ldr	r3, [r3]
 80135a0: f403 0380    	and	r3, r3, #0x400000
 80135a4: f5b3 0f80    	cmp.w	r3, #0x400000
 80135a8: bf0c         	ite	eq
 80135aa: 2301         	moveq	r3, #0x1
 80135ac: 2300         	movne	r3, #0x0
 80135ae: b2db         	uxtb	r3, r3
; }
 80135b0: 4618         	mov	r0, r3
 80135b2: 370c         	adds	r7, #0xc
 80135b4: 46bd         	mov	sp, r7
 80135b6: bc80         	pop	{r7}
 80135b8: 4770         	bx	lr

080135ba <LL_DMA_IsActiveFlag_FE4>:
; {
 80135ba: b480         	push	{r7}
 80135bc: b083         	sub	sp, #0xc
 80135be: af00         	add	r7, sp, #0x0
 80135c0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF4)==(DMA_HISR_FEIF4));
 80135c2: 687b         	ldr	r3, [r7, #0x4]
 80135c4: 685b         	ldr	r3, [r3, #0x4]
 80135c6: f003 0301    	and	r3, r3, #0x1
 80135ca: 2b01         	cmp	r3, #0x1
 80135cc: bf0c         	ite	eq
 80135ce: 2301         	moveq	r3, #0x1
 80135d0: 2300         	movne	r3, #0x0
 80135d2: b2db         	uxtb	r3, r3
; }
 80135d4: 4618         	mov	r0, r3
 80135d6: 370c         	adds	r7, #0xc
 80135d8: 46bd         	mov	sp, r7
 80135da: bc80         	pop	{r7}
 80135dc: 4770         	bx	lr

080135de <LL_DMA_IsActiveFlag_FE5>:
; {
 80135de: b480         	push	{r7}
 80135e0: b083         	sub	sp, #0xc
 80135e2: af00         	add	r7, sp, #0x0
 80135e4: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF5)==(DMA_HISR_FEIF5));
 80135e6: 687b         	ldr	r3, [r7, #0x4]
 80135e8: 685b         	ldr	r3, [r3, #0x4]
 80135ea: f003 0340    	and	r3, r3, #0x40
 80135ee: 2b40         	cmp	r3, #0x40
 80135f0: bf0c         	ite	eq
 80135f2: 2301         	moveq	r3, #0x1
 80135f4: 2300         	movne	r3, #0x0
 80135f6: b2db         	uxtb	r3, r3
; }
 80135f8: 4618         	mov	r0, r3
 80135fa: 370c         	adds	r7, #0xc
 80135fc: 46bd         	mov	sp, r7
 80135fe: bc80         	pop	{r7}
 8013600: 4770         	bx	lr

08013602 <LL_DMA_IsActiveFlag_FE6>:
; {
 8013602: b480         	push	{r7}
 8013604: b083         	sub	sp, #0xc
 8013606: af00         	add	r7, sp, #0x0
 8013608: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF6)==(DMA_HISR_FEIF6));
 801360a: 687b         	ldr	r3, [r7, #0x4]
 801360c: 685b         	ldr	r3, [r3, #0x4]
 801360e: f403 3380    	and	r3, r3, #0x10000
 8013612: f5b3 3f80    	cmp.w	r3, #0x10000
 8013616: bf0c         	ite	eq
 8013618: 2301         	moveq	r3, #0x1
 801361a: 2300         	movne	r3, #0x0
 801361c: b2db         	uxtb	r3, r3
; }
 801361e: 4618         	mov	r0, r3
 8013620: 370c         	adds	r7, #0xc
 8013622: 46bd         	mov	sp, r7
 8013624: bc80         	pop	{r7}
 8013626: 4770         	bx	lr

08013628 <LL_DMA_IsActiveFlag_FE7>:
; {
 8013628: b480         	push	{r7}
 801362a: b083         	sub	sp, #0xc
 801362c: af00         	add	r7, sp, #0x0
 801362e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF7)==(DMA_HISR_FEIF7));
 8013630: 687b         	ldr	r3, [r7, #0x4]
 8013632: 685b         	ldr	r3, [r3, #0x4]
 8013634: f403 0380    	and	r3, r3, #0x400000
 8013638: f5b3 0f80    	cmp.w	r3, #0x400000
 801363c: bf0c         	ite	eq
 801363e: 2301         	moveq	r3, #0x1
 8013640: 2300         	movne	r3, #0x0
 8013642: b2db         	uxtb	r3, r3
; }
 8013644: 4618         	mov	r0, r3
 8013646: 370c         	adds	r7, #0xc
 8013648: 46bd         	mov	sp, r7
 801364a: bc80         	pop	{r7}
 801364c: 4770         	bx	lr

0801364e <LL_DMA_ClearFlag_HT0>:
; {
 801364e: b480         	push	{r7}
 8013650: b083         	sub	sp, #0xc
 8013652: af00         	add	r7, sp, #0x0
 8013654: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF0);
 8013656: 687b         	ldr	r3, [r7, #0x4]
 8013658: 2210         	movs	r2, #0x10
 801365a: 609a         	str	r2, [r3, #0x8]
; }
 801365c: bf00         	nop
 801365e: 370c         	adds	r7, #0xc
 8013660: 46bd         	mov	sp, r7
 8013662: bc80         	pop	{r7}
 8013664: 4770         	bx	lr

08013666 <LL_DMA_ClearFlag_HT1>:
; {
 8013666: b480         	push	{r7}
 8013668: b083         	sub	sp, #0xc
 801366a: af00         	add	r7, sp, #0x0
 801366c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF1);
 801366e: 687b         	ldr	r3, [r7, #0x4]
 8013670: f44f 6280    	mov.w	r2, #0x400
 8013674: 609a         	str	r2, [r3, #0x8]
; }
 8013676: bf00         	nop
 8013678: 370c         	adds	r7, #0xc
 801367a: 46bd         	mov	sp, r7
 801367c: bc80         	pop	{r7}
 801367e: 4770         	bx	lr

08013680 <LL_DMA_ClearFlag_HT2>:
; {
 8013680: b480         	push	{r7}
 8013682: b083         	sub	sp, #0xc
 8013684: af00         	add	r7, sp, #0x0
 8013686: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF2);
 8013688: 687b         	ldr	r3, [r7, #0x4]
 801368a: f44f 1280    	mov.w	r2, #0x100000
 801368e: 609a         	str	r2, [r3, #0x8]
; }
 8013690: bf00         	nop
 8013692: 370c         	adds	r7, #0xc
 8013694: 46bd         	mov	sp, r7
 8013696: bc80         	pop	{r7}
 8013698: 4770         	bx	lr

0801369a <LL_DMA_ClearFlag_HT3>:
; {
 801369a: b480         	push	{r7}
 801369c: b083         	sub	sp, #0xc
 801369e: af00         	add	r7, sp, #0x0
 80136a0: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF3);
 80136a2: 687b         	ldr	r3, [r7, #0x4]
 80136a4: f04f 6280    	mov.w	r2, #0x4000000
 80136a8: 609a         	str	r2, [r3, #0x8]
; }
 80136aa: bf00         	nop
 80136ac: 370c         	adds	r7, #0xc
 80136ae: 46bd         	mov	sp, r7
 80136b0: bc80         	pop	{r7}
 80136b2: 4770         	bx	lr

080136b4 <LL_DMA_ClearFlag_HT4>:
; {
 80136b4: b480         	push	{r7}
 80136b6: b083         	sub	sp, #0xc
 80136b8: af00         	add	r7, sp, #0x0
 80136ba: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF4);
 80136bc: 687b         	ldr	r3, [r7, #0x4]
 80136be: 2210         	movs	r2, #0x10
 80136c0: 60da         	str	r2, [r3, #0xc]
; }
 80136c2: bf00         	nop
 80136c4: 370c         	adds	r7, #0xc
 80136c6: 46bd         	mov	sp, r7
 80136c8: bc80         	pop	{r7}
 80136ca: 4770         	bx	lr

080136cc <LL_DMA_ClearFlag_HT5>:
; {
 80136cc: b480         	push	{r7}
 80136ce: b083         	sub	sp, #0xc
 80136d0: af00         	add	r7, sp, #0x0
 80136d2: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF5);
 80136d4: 687b         	ldr	r3, [r7, #0x4]
 80136d6: f44f 6280    	mov.w	r2, #0x400
 80136da: 60da         	str	r2, [r3, #0xc]
; }
 80136dc: bf00         	nop
 80136de: 370c         	adds	r7, #0xc
 80136e0: 46bd         	mov	sp, r7
 80136e2: bc80         	pop	{r7}
 80136e4: 4770         	bx	lr

080136e6 <LL_DMA_ClearFlag_HT6>:
; {
 80136e6: b480         	push	{r7}
 80136e8: b083         	sub	sp, #0xc
 80136ea: af00         	add	r7, sp, #0x0
 80136ec: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF6);
 80136ee: 687b         	ldr	r3, [r7, #0x4]
 80136f0: f44f 1280    	mov.w	r2, #0x100000
 80136f4: 60da         	str	r2, [r3, #0xc]
; }
 80136f6: bf00         	nop
 80136f8: 370c         	adds	r7, #0xc
 80136fa: 46bd         	mov	sp, r7
 80136fc: bc80         	pop	{r7}
 80136fe: 4770         	bx	lr

08013700 <LL_DMA_ClearFlag_HT7>:
; {
 8013700: b480         	push	{r7}
 8013702: b083         	sub	sp, #0xc
 8013704: af00         	add	r7, sp, #0x0
 8013706: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF7);
 8013708: 687b         	ldr	r3, [r7, #0x4]
 801370a: f04f 6280    	mov.w	r2, #0x4000000
 801370e: 60da         	str	r2, [r3, #0xc]
; }
 8013710: bf00         	nop
 8013712: 370c         	adds	r7, #0xc
 8013714: 46bd         	mov	sp, r7
 8013716: bc80         	pop	{r7}
 8013718: 4770         	bx	lr

0801371a <LL_DMA_ClearFlag_TC0>:
; {
 801371a: b480         	push	{r7}
 801371c: b083         	sub	sp, #0xc
 801371e: af00         	add	r7, sp, #0x0
 8013720: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF0);
 8013722: 687b         	ldr	r3, [r7, #0x4]
 8013724: 2220         	movs	r2, #0x20
 8013726: 609a         	str	r2, [r3, #0x8]
; }
 8013728: bf00         	nop
 801372a: 370c         	adds	r7, #0xc
 801372c: 46bd         	mov	sp, r7
 801372e: bc80         	pop	{r7}
 8013730: 4770         	bx	lr

08013732 <LL_DMA_ClearFlag_TC1>:
; {
 8013732: b480         	push	{r7}
 8013734: b083         	sub	sp, #0xc
 8013736: af00         	add	r7, sp, #0x0
 8013738: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF1);
 801373a: 687b         	ldr	r3, [r7, #0x4]
 801373c: f44f 6200    	mov.w	r2, #0x800
 8013740: 609a         	str	r2, [r3, #0x8]
; }
 8013742: bf00         	nop
 8013744: 370c         	adds	r7, #0xc
 8013746: 46bd         	mov	sp, r7
 8013748: bc80         	pop	{r7}
 801374a: 4770         	bx	lr

0801374c <LL_DMA_ClearFlag_TC2>:
; {
 801374c: b480         	push	{r7}
 801374e: b083         	sub	sp, #0xc
 8013750: af00         	add	r7, sp, #0x0
 8013752: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF2);
 8013754: 687b         	ldr	r3, [r7, #0x4]
 8013756: f44f 1200    	mov.w	r2, #0x200000
 801375a: 609a         	str	r2, [r3, #0x8]
; }
 801375c: bf00         	nop
 801375e: 370c         	adds	r7, #0xc
 8013760: 46bd         	mov	sp, r7
 8013762: bc80         	pop	{r7}
 8013764: 4770         	bx	lr

08013766 <LL_DMA_ClearFlag_TC3>:
; {
 8013766: b480         	push	{r7}
 8013768: b083         	sub	sp, #0xc
 801376a: af00         	add	r7, sp, #0x0
 801376c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF3);
 801376e: 687b         	ldr	r3, [r7, #0x4]
 8013770: f04f 6200    	mov.w	r2, #0x8000000
 8013774: 609a         	str	r2, [r3, #0x8]
; }
 8013776: bf00         	nop
 8013778: 370c         	adds	r7, #0xc
 801377a: 46bd         	mov	sp, r7
 801377c: bc80         	pop	{r7}
 801377e: 4770         	bx	lr

08013780 <LL_DMA_ClearFlag_TC4>:
; {
 8013780: b480         	push	{r7}
 8013782: b083         	sub	sp, #0xc
 8013784: af00         	add	r7, sp, #0x0
 8013786: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF4);
 8013788: 687b         	ldr	r3, [r7, #0x4]
 801378a: 2220         	movs	r2, #0x20
 801378c: 60da         	str	r2, [r3, #0xc]
; }
 801378e: bf00         	nop
 8013790: 370c         	adds	r7, #0xc
 8013792: 46bd         	mov	sp, r7
 8013794: bc80         	pop	{r7}
 8013796: 4770         	bx	lr

08013798 <LL_DMA_ClearFlag_TC5>:
; {
 8013798: b480         	push	{r7}
 801379a: b083         	sub	sp, #0xc
 801379c: af00         	add	r7, sp, #0x0
 801379e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF5);
 80137a0: 687b         	ldr	r3, [r7, #0x4]
 80137a2: f44f 6200    	mov.w	r2, #0x800
 80137a6: 60da         	str	r2, [r3, #0xc]
; }
 80137a8: bf00         	nop
 80137aa: 370c         	adds	r7, #0xc
 80137ac: 46bd         	mov	sp, r7
 80137ae: bc80         	pop	{r7}
 80137b0: 4770         	bx	lr

080137b2 <LL_DMA_ClearFlag_TC6>:
; {
 80137b2: b480         	push	{r7}
 80137b4: b083         	sub	sp, #0xc
 80137b6: af00         	add	r7, sp, #0x0
 80137b8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF6);
 80137ba: 687b         	ldr	r3, [r7, #0x4]
 80137bc: f44f 1200    	mov.w	r2, #0x200000
 80137c0: 60da         	str	r2, [r3, #0xc]
; }
 80137c2: bf00         	nop
 80137c4: 370c         	adds	r7, #0xc
 80137c6: 46bd         	mov	sp, r7
 80137c8: bc80         	pop	{r7}
 80137ca: 4770         	bx	lr

080137cc <LL_DMA_ClearFlag_TC7>:
; {
 80137cc: b480         	push	{r7}
 80137ce: b083         	sub	sp, #0xc
 80137d0: af00         	add	r7, sp, #0x0
 80137d2: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF7);
 80137d4: 687b         	ldr	r3, [r7, #0x4]
 80137d6: f04f 6200    	mov.w	r2, #0x8000000
 80137da: 60da         	str	r2, [r3, #0xc]
; }
 80137dc: bf00         	nop
 80137de: 370c         	adds	r7, #0xc
 80137e0: 46bd         	mov	sp, r7
 80137e2: bc80         	pop	{r7}
 80137e4: 4770         	bx	lr

080137e6 <LL_DMA_ClearFlag_TE0>:
; {
 80137e6: b480         	push	{r7}
 80137e8: b083         	sub	sp, #0xc
 80137ea: af00         	add	r7, sp, #0x0
 80137ec: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF0);
 80137ee: 687b         	ldr	r3, [r7, #0x4]
 80137f0: 2208         	movs	r2, #0x8
 80137f2: 609a         	str	r2, [r3, #0x8]
; }
 80137f4: bf00         	nop
 80137f6: 370c         	adds	r7, #0xc
 80137f8: 46bd         	mov	sp, r7
 80137fa: bc80         	pop	{r7}
 80137fc: 4770         	bx	lr

080137fe <LL_DMA_ClearFlag_TE1>:
; {
 80137fe: b480         	push	{r7}
 8013800: b083         	sub	sp, #0xc
 8013802: af00         	add	r7, sp, #0x0
 8013804: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF1);
 8013806: 687b         	ldr	r3, [r7, #0x4]
 8013808: f44f 7200    	mov.w	r2, #0x200
 801380c: 609a         	str	r2, [r3, #0x8]
; }
 801380e: bf00         	nop
 8013810: 370c         	adds	r7, #0xc
 8013812: 46bd         	mov	sp, r7
 8013814: bc80         	pop	{r7}
 8013816: 4770         	bx	lr

08013818 <LL_DMA_ClearFlag_TE2>:
; {
 8013818: b480         	push	{r7}
 801381a: b083         	sub	sp, #0xc
 801381c: af00         	add	r7, sp, #0x0
 801381e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF2);
 8013820: 687b         	ldr	r3, [r7, #0x4]
 8013822: f44f 2200    	mov.w	r2, #0x80000
 8013826: 609a         	str	r2, [r3, #0x8]
; }
 8013828: bf00         	nop
 801382a: 370c         	adds	r7, #0xc
 801382c: 46bd         	mov	sp, r7
 801382e: bc80         	pop	{r7}
 8013830: 4770         	bx	lr

08013832 <LL_DMA_ClearFlag_TE3>:
; {
 8013832: b480         	push	{r7}
 8013834: b083         	sub	sp, #0xc
 8013836: af00         	add	r7, sp, #0x0
 8013838: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF3);
 801383a: 687b         	ldr	r3, [r7, #0x4]
 801383c: f04f 7200    	mov.w	r2, #0x2000000
 8013840: 609a         	str	r2, [r3, #0x8]
; }
 8013842: bf00         	nop
 8013844: 370c         	adds	r7, #0xc
 8013846: 46bd         	mov	sp, r7
 8013848: bc80         	pop	{r7}
 801384a: 4770         	bx	lr

0801384c <LL_DMA_ClearFlag_TE4>:
; {
 801384c: b480         	push	{r7}
 801384e: b083         	sub	sp, #0xc
 8013850: af00         	add	r7, sp, #0x0
 8013852: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF4);
 8013854: 687b         	ldr	r3, [r7, #0x4]
 8013856: 2208         	movs	r2, #0x8
 8013858: 60da         	str	r2, [r3, #0xc]
; }
 801385a: bf00         	nop
 801385c: 370c         	adds	r7, #0xc
 801385e: 46bd         	mov	sp, r7
 8013860: bc80         	pop	{r7}
 8013862: 4770         	bx	lr

08013864 <LL_DMA_ClearFlag_TE5>:
; {
 8013864: b480         	push	{r7}
 8013866: b083         	sub	sp, #0xc
 8013868: af00         	add	r7, sp, #0x0
 801386a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF5);
 801386c: 687b         	ldr	r3, [r7, #0x4]
 801386e: f44f 7200    	mov.w	r2, #0x200
 8013872: 60da         	str	r2, [r3, #0xc]
; }
 8013874: bf00         	nop
 8013876: 370c         	adds	r7, #0xc
 8013878: 46bd         	mov	sp, r7
 801387a: bc80         	pop	{r7}
 801387c: 4770         	bx	lr

0801387e <LL_DMA_ClearFlag_TE6>:
; {
 801387e: b480         	push	{r7}
 8013880: b083         	sub	sp, #0xc
 8013882: af00         	add	r7, sp, #0x0
 8013884: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF6);
 8013886: 687b         	ldr	r3, [r7, #0x4]
 8013888: f44f 2200    	mov.w	r2, #0x80000
 801388c: 60da         	str	r2, [r3, #0xc]
; }
 801388e: bf00         	nop
 8013890: 370c         	adds	r7, #0xc
 8013892: 46bd         	mov	sp, r7
 8013894: bc80         	pop	{r7}
 8013896: 4770         	bx	lr

08013898 <LL_DMA_ClearFlag_TE7>:
; {
 8013898: b480         	push	{r7}
 801389a: b083         	sub	sp, #0xc
 801389c: af00         	add	r7, sp, #0x0
 801389e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF7);
 80138a0: 687b         	ldr	r3, [r7, #0x4]
 80138a2: f04f 7200    	mov.w	r2, #0x2000000
 80138a6: 60da         	str	r2, [r3, #0xc]
; }
 80138a8: bf00         	nop
 80138aa: 370c         	adds	r7, #0xc
 80138ac: 46bd         	mov	sp, r7
 80138ae: bc80         	pop	{r7}
 80138b0: 4770         	bx	lr

080138b2 <LL_DMA_ClearFlag_DME0>:
; {
 80138b2: b480         	push	{r7}
 80138b4: b083         	sub	sp, #0xc
 80138b6: af00         	add	r7, sp, #0x0
 80138b8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF0);
 80138ba: 687b         	ldr	r3, [r7, #0x4]
 80138bc: 2204         	movs	r2, #0x4
 80138be: 609a         	str	r2, [r3, #0x8]
; }
 80138c0: bf00         	nop
 80138c2: 370c         	adds	r7, #0xc
 80138c4: 46bd         	mov	sp, r7
 80138c6: bc80         	pop	{r7}
 80138c8: 4770         	bx	lr

080138ca <LL_DMA_ClearFlag_DME1>:
; {
 80138ca: b480         	push	{r7}
 80138cc: b083         	sub	sp, #0xc
 80138ce: af00         	add	r7, sp, #0x0
 80138d0: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF1);
 80138d2: 687b         	ldr	r3, [r7, #0x4]
 80138d4: f44f 7280    	mov.w	r2, #0x100
 80138d8: 609a         	str	r2, [r3, #0x8]
; }
 80138da: bf00         	nop
 80138dc: 370c         	adds	r7, #0xc
 80138de: 46bd         	mov	sp, r7
 80138e0: bc80         	pop	{r7}
 80138e2: 4770         	bx	lr

080138e4 <LL_DMA_ClearFlag_DME2>:
; {
 80138e4: b480         	push	{r7}
 80138e6: b083         	sub	sp, #0xc
 80138e8: af00         	add	r7, sp, #0x0
 80138ea: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF2);
 80138ec: 687b         	ldr	r3, [r7, #0x4]
 80138ee: f44f 2280    	mov.w	r2, #0x40000
 80138f2: 609a         	str	r2, [r3, #0x8]
; }
 80138f4: bf00         	nop
 80138f6: 370c         	adds	r7, #0xc
 80138f8: 46bd         	mov	sp, r7
 80138fa: bc80         	pop	{r7}
 80138fc: 4770         	bx	lr

080138fe <LL_DMA_ClearFlag_DME3>:
; {
 80138fe: b480         	push	{r7}
 8013900: b083         	sub	sp, #0xc
 8013902: af00         	add	r7, sp, #0x0
 8013904: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF3);
 8013906: 687b         	ldr	r3, [r7, #0x4]
 8013908: f04f 7280    	mov.w	r2, #0x1000000
 801390c: 609a         	str	r2, [r3, #0x8]
; }
 801390e: bf00         	nop
 8013910: 370c         	adds	r7, #0xc
 8013912: 46bd         	mov	sp, r7
 8013914: bc80         	pop	{r7}
 8013916: 4770         	bx	lr

08013918 <LL_DMA_ClearFlag_DME4>:
; {
 8013918: b480         	push	{r7}
 801391a: b083         	sub	sp, #0xc
 801391c: af00         	add	r7, sp, #0x0
 801391e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF4);
 8013920: 687b         	ldr	r3, [r7, #0x4]
 8013922: 2204         	movs	r2, #0x4
 8013924: 60da         	str	r2, [r3, #0xc]
; }
 8013926: bf00         	nop
 8013928: 370c         	adds	r7, #0xc
 801392a: 46bd         	mov	sp, r7
 801392c: bc80         	pop	{r7}
 801392e: 4770         	bx	lr

08013930 <LL_DMA_ClearFlag_DME5>:
; {
 8013930: b480         	push	{r7}
 8013932: b083         	sub	sp, #0xc
 8013934: af00         	add	r7, sp, #0x0
 8013936: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF5);
 8013938: 687b         	ldr	r3, [r7, #0x4]
 801393a: f44f 7280    	mov.w	r2, #0x100
 801393e: 60da         	str	r2, [r3, #0xc]
; }
 8013940: bf00         	nop
 8013942: 370c         	adds	r7, #0xc
 8013944: 46bd         	mov	sp, r7
 8013946: bc80         	pop	{r7}
 8013948: 4770         	bx	lr

0801394a <LL_DMA_ClearFlag_DME6>:
; {
 801394a: b480         	push	{r7}
 801394c: b083         	sub	sp, #0xc
 801394e: af00         	add	r7, sp, #0x0
 8013950: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF6);
 8013952: 687b         	ldr	r3, [r7, #0x4]
 8013954: f44f 2280    	mov.w	r2, #0x40000
 8013958: 60da         	str	r2, [r3, #0xc]
; }
 801395a: bf00         	nop
 801395c: 370c         	adds	r7, #0xc
 801395e: 46bd         	mov	sp, r7
 8013960: bc80         	pop	{r7}
 8013962: 4770         	bx	lr

08013964 <LL_DMA_ClearFlag_DME7>:
; {
 8013964: b480         	push	{r7}
 8013966: b083         	sub	sp, #0xc
 8013968: af00         	add	r7, sp, #0x0
 801396a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF7);
 801396c: 687b         	ldr	r3, [r7, #0x4]
 801396e: f04f 7280    	mov.w	r2, #0x1000000
 8013972: 60da         	str	r2, [r3, #0xc]
; }
 8013974: bf00         	nop
 8013976: 370c         	adds	r7, #0xc
 8013978: 46bd         	mov	sp, r7
 801397a: bc80         	pop	{r7}
 801397c: 4770         	bx	lr

0801397e <LL_DMA_ClearFlag_FE0>:
; {
 801397e: b480         	push	{r7}
 8013980: b083         	sub	sp, #0xc
 8013982: af00         	add	r7, sp, #0x0
 8013984: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF0);
 8013986: 687b         	ldr	r3, [r7, #0x4]
 8013988: 2201         	movs	r2, #0x1
 801398a: 609a         	str	r2, [r3, #0x8]
; }
 801398c: bf00         	nop
 801398e: 370c         	adds	r7, #0xc
 8013990: 46bd         	mov	sp, r7
 8013992: bc80         	pop	{r7}
 8013994: 4770         	bx	lr

08013996 <LL_DMA_ClearFlag_FE1>:
; {
 8013996: b480         	push	{r7}
 8013998: b083         	sub	sp, #0xc
 801399a: af00         	add	r7, sp, #0x0
 801399c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF1);
 801399e: 687b         	ldr	r3, [r7, #0x4]
 80139a0: 2240         	movs	r2, #0x40
 80139a2: 609a         	str	r2, [r3, #0x8]
; }
 80139a4: bf00         	nop
 80139a6: 370c         	adds	r7, #0xc
 80139a8: 46bd         	mov	sp, r7
 80139aa: bc80         	pop	{r7}
 80139ac: 4770         	bx	lr

080139ae <LL_DMA_ClearFlag_FE2>:
; {
 80139ae: b480         	push	{r7}
 80139b0: b083         	sub	sp, #0xc
 80139b2: af00         	add	r7, sp, #0x0
 80139b4: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF2);
 80139b6: 687b         	ldr	r3, [r7, #0x4]
 80139b8: f44f 3280    	mov.w	r2, #0x10000
 80139bc: 609a         	str	r2, [r3, #0x8]
; }
 80139be: bf00         	nop
 80139c0: 370c         	adds	r7, #0xc
 80139c2: 46bd         	mov	sp, r7
 80139c4: bc80         	pop	{r7}
 80139c6: 4770         	bx	lr

080139c8 <LL_DMA_ClearFlag_FE3>:
; {
 80139c8: b480         	push	{r7}
 80139ca: b083         	sub	sp, #0xc
 80139cc: af00         	add	r7, sp, #0x0
 80139ce: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF3);
 80139d0: 687b         	ldr	r3, [r7, #0x4]
 80139d2: f44f 0280    	mov.w	r2, #0x400000
 80139d6: 609a         	str	r2, [r3, #0x8]
; }
 80139d8: bf00         	nop
 80139da: 370c         	adds	r7, #0xc
 80139dc: 46bd         	mov	sp, r7
 80139de: bc80         	pop	{r7}
 80139e0: 4770         	bx	lr

080139e2 <LL_DMA_ClearFlag_FE4>:
; {
 80139e2: b480         	push	{r7}
 80139e4: b083         	sub	sp, #0xc
 80139e6: af00         	add	r7, sp, #0x0
 80139e8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF4);
 80139ea: 687b         	ldr	r3, [r7, #0x4]
 80139ec: 2201         	movs	r2, #0x1
 80139ee: 60da         	str	r2, [r3, #0xc]
; }
 80139f0: bf00         	nop
 80139f2: 370c         	adds	r7, #0xc
 80139f4: 46bd         	mov	sp, r7
 80139f6: bc80         	pop	{r7}
 80139f8: 4770         	bx	lr

080139fa <LL_DMA_ClearFlag_FE5>:
; {
 80139fa: b480         	push	{r7}
 80139fc: b083         	sub	sp, #0xc
 80139fe: af00         	add	r7, sp, #0x0
 8013a00: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF5);
 8013a02: 687b         	ldr	r3, [r7, #0x4]
 8013a04: 2240         	movs	r2, #0x40
 8013a06: 60da         	str	r2, [r3, #0xc]
; }
 8013a08: bf00         	nop
 8013a0a: 370c         	adds	r7, #0xc
 8013a0c: 46bd         	mov	sp, r7
 8013a0e: bc80         	pop	{r7}
 8013a10: 4770         	bx	lr

08013a12 <LL_DMA_ClearFlag_FE6>:
; {
 8013a12: b480         	push	{r7}
 8013a14: b083         	sub	sp, #0xc
 8013a16: af00         	add	r7, sp, #0x0
 8013a18: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF6);
 8013a1a: 687b         	ldr	r3, [r7, #0x4]
 8013a1c: f44f 3280    	mov.w	r2, #0x10000
 8013a20: 60da         	str	r2, [r3, #0xc]
; }
 8013a22: bf00         	nop
 8013a24: 370c         	adds	r7, #0xc
 8013a26: 46bd         	mov	sp, r7
 8013a28: bc80         	pop	{r7}
 8013a2a: 4770         	bx	lr

08013a2c <LL_DMA_ClearFlag_FE7>:
; {
 8013a2c: b480         	push	{r7}
 8013a2e: b083         	sub	sp, #0xc
 8013a30: af00         	add	r7, sp, #0x0
 8013a32: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF7);
 8013a34: 687b         	ldr	r3, [r7, #0x4]
 8013a36: f44f 0280    	mov.w	r2, #0x400000
 8013a3a: 60da         	str	r2, [r3, #0xc]
; }
 8013a3c: bf00         	nop
 8013a3e: 370c         	adds	r7, #0xc
 8013a40: 46bd         	mov	sp, r7
 8013a42: bc80         	pop	{r7}
 8013a44: 4770         	bx	lr

08013a46 <z_log_msg_runtime_create>:
; {
 8013a46: b580         	push	{r7, lr}
 8013a48: b08a         	sub	sp, #0x28
 8013a4a: af04         	add	r7, sp, #0x10
 8013a4c: 60b9         	str	r1, [r7, #0x8]
 8013a4e: 607b         	str	r3, [r7, #0x4]
 8013a50: 4603         	mov	r3, r0
 8013a52: 73fb         	strb	r3, [r7, #0xf]
 8013a54: 4613         	mov	r3, r2
 8013a56: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8013a58: f107 032c    	add.w	r3, r7, #0x2c
 8013a5c: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8013a5e: 7bba         	ldrb	r2, [r7, #0xe]
 8013a60: 7bf8         	ldrb	r0, [r7, #0xf]
 8013a62: 697b         	ldr	r3, [r7, #0x14]
 8013a64: 9303         	str	r3, [sp, #0xc]
 8013a66: 6abb         	ldr	r3, [r7, #0x28]
 8013a68: 9302         	str	r3, [sp, #0x8]
 8013a6a: 6a7b         	ldr	r3, [r7, #0x24]
 8013a6c: 9301         	str	r3, [sp, #0x4]
 8013a6e: 6a3b         	ldr	r3, [r7, #0x20]
 8013a70: 9300         	str	r3, [sp]
 8013a72: 687b         	ldr	r3, [r7, #0x4]
 8013a74: 68b9         	ldr	r1, [r7, #0x8]
 8013a76: f7ee fb69    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0x1192e
; }
 8013a7a: bf00         	nop
 8013a7c: 3718         	adds	r7, #0x18
 8013a7e: 46bd         	mov	sp, r7
 8013a80: bd80         	pop	{r7, pc}

08013a82 <stm32_dma_is_tc_irq_active>:
; {
 8013a82: b580         	push	{r7, lr}
 8013a84: b082         	sub	sp, #0x8
 8013a86: af00         	add	r7, sp, #0x0
 8013a88: 6078         	str	r0, [r7, #0x4]
 8013a8a: 6039         	str	r1, [r7]
; 	return LL_DMA_IsEnabledIT_TC(dma, dma_stm32_id_to_stream(id)) &&
 8013a8c: 6838         	ldr	r0, [r7]
 8013a8e: f7f3 fd67    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xc532
 8013a92: 4603         	mov	r3, r0
 8013a94: 4619         	mov	r1, r3
 8013a96: 6878         	ldr	r0, [r7, #0x4]
 8013a98: f7f3 fd2a    	bl	0x80074f0 <LL_DMA_IsEnabledIT_TC> @ imm = #-0xc5ac
 8013a9c: 4603         	mov	r3, r0
 8013a9e: 2b00         	cmp	r3, #0x0
 8013aa0: d008         	beq	0x8013ab4 <stm32_dma_is_tc_irq_active+0x32> @ imm = #0x10
; 	       dma_stm32_is_tc_active(dma, id);
 8013aa2: 6839         	ldr	r1, [r7]
 8013aa4: 6878         	ldr	r0, [r7, #0x4]
 8013aa6: f7f3 fdb7    	bl	0x8007618 <dma_stm32_is_tc_active> @ imm = #-0xc492
 8013aaa: 4603         	mov	r3, r0
; 	return LL_DMA_IsEnabledIT_TC(dma, dma_stm32_id_to_stream(id)) &&
 8013aac: 2b00         	cmp	r3, #0x0
 8013aae: d001         	beq	0x8013ab4 <stm32_dma_is_tc_irq_active+0x32> @ imm = #0x2
 8013ab0: 2301         	movs	r3, #0x1
 8013ab2: e000         	b	0x8013ab6 <stm32_dma_is_tc_irq_active+0x34> @ imm = #0x0
 8013ab4: 2300         	movs	r3, #0x0
 8013ab6: f003 0301    	and	r3, r3, #0x1
 8013aba: b2db         	uxtb	r3, r3
; }
 8013abc: 4618         	mov	r0, r3
 8013abe: 3708         	adds	r7, #0x8
 8013ac0: 46bd         	mov	sp, r7
 8013ac2: bd80         	pop	{r7, pc}

08013ac4 <stm32_dma_is_ht_irq_active>:
; {
 8013ac4: b580         	push	{r7, lr}
 8013ac6: b082         	sub	sp, #0x8
 8013ac8: af00         	add	r7, sp, #0x0
 8013aca: 6078         	str	r0, [r7, #0x4]
 8013acc: 6039         	str	r1, [r7]
; 	return LL_DMA_IsEnabledIT_HT(dma, dma_stm32_id_to_stream(id)) &&
 8013ace: 6838         	ldr	r0, [r7]
 8013ad0: f7f3 fd46    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xc574
 8013ad4: 4603         	mov	r3, r0
 8013ad6: 4619         	mov	r1, r3
 8013ad8: 6878         	ldr	r0, [r7, #0x4]
 8013ada: f7f3 fced    	bl	0x80074b8 <LL_DMA_IsEnabledIT_HT> @ imm = #-0xc626
 8013ade: 4603         	mov	r3, r0
 8013ae0: 2b00         	cmp	r3, #0x0
 8013ae2: d008         	beq	0x8013af6 <stm32_dma_is_ht_irq_active+0x32> @ imm = #0x10
; 	       dma_stm32_is_ht_active(dma, id);
 8013ae4: 6839         	ldr	r1, [r7]
 8013ae6: 6878         	ldr	r0, [r7, #0x4]
 8013ae8: f7f3 fd7e    	bl	0x80075e8 <dma_stm32_is_ht_active> @ imm = #-0xc504
 8013aec: 4603         	mov	r3, r0
; 	return LL_DMA_IsEnabledIT_HT(dma, dma_stm32_id_to_stream(id)) &&
 8013aee: 2b00         	cmp	r3, #0x0
 8013af0: d001         	beq	0x8013af6 <stm32_dma_is_ht_irq_active+0x32> @ imm = #0x2
 8013af2: 2301         	movs	r3, #0x1
 8013af4: e000         	b	0x8013af8 <stm32_dma_is_ht_irq_active+0x34> @ imm = #0x0
 8013af6: 2300         	movs	r3, #0x0
 8013af8: f003 0301    	and	r3, r3, #0x1
 8013afc: b2db         	uxtb	r3, r3
; }
 8013afe: 4618         	mov	r0, r3
 8013b00: 3708         	adds	r7, #0x8
 8013b02: 46bd         	mov	sp, r7
 8013b04: bd80         	pop	{r7, pc}

08013b06 <stm32_dma_clear_stream_irq>:
; {
 8013b06: b580         	push	{r7, lr}
 8013b08: b082         	sub	sp, #0x8
 8013b0a: af00         	add	r7, sp, #0x0
 8013b0c: 6078         	str	r0, [r7, #0x4]
 8013b0e: 6039         	str	r1, [r7]
; 	dma_stm32_clear_te(dma, id);
 8013b10: 6839         	ldr	r1, [r7]
 8013b12: 6878         	ldr	r0, [r7, #0x4]
 8013b14: f7f3 fd98    	bl	0x8007648 <dma_stm32_clear_te> @ imm = #-0xc4d0
; 	dma_stm32_clear_dme(dma, id);
 8013b18: 6839         	ldr	r1, [r7]
 8013b1a: 6878         	ldr	r0, [r7, #0x4]
 8013b1c: f7f3 fda6    	bl	0x800766c <dma_stm32_clear_dme> @ imm = #-0xc4b4
; 	dma_stm32_clear_fe(dma, id);
 8013b20: 6839         	ldr	r1, [r7]
 8013b22: 6878         	ldr	r0, [r7, #0x4]
 8013b24: f7f3 fdb4    	bl	0x8007690 <dma_stm32_clear_fe> @ imm = #-0xc498
; }
 8013b28: bf00         	nop
 8013b2a: 3708         	adds	r7, #0x8
 8013b2c: 46bd         	mov	sp, r7
 8013b2e: bd80         	pop	{r7, pc}

08013b30 <stm32_dma_enable_stream>:
; {
 8013b30: b580         	push	{r7, lr}
 8013b32: b082         	sub	sp, #0x8
 8013b34: af00         	add	r7, sp, #0x0
 8013b36: 6078         	str	r0, [r7, #0x4]
 8013b38: 6039         	str	r1, [r7]
; 	LL_DMA_EnableStream(dma, dma_stm32_id_to_stream(id));
 8013b3a: 6838         	ldr	r0, [r7]
 8013b3c: f7f3 fd10    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xc5e0
 8013b40: 4603         	mov	r3, r0
 8013b42: 4619         	mov	r1, r3
 8013b44: 6878         	ldr	r0, [r7, #0x4]
 8013b46: f7f3 fc41    	bl	0x80073cc <LL_DMA_EnableStream> @ imm = #-0xc77e
; }
 8013b4a: bf00         	nop
 8013b4c: 3708         	adds	r7, #0x8
 8013b4e: 46bd         	mov	sp, r7
 8013b50: bd80         	pop	{r7, pc}

08013b52 <stm32_dma_is_enabled_stream>:
; {
 8013b52: b580         	push	{r7, lr}
 8013b54: b082         	sub	sp, #0x8
 8013b56: af00         	add	r7, sp, #0x0
 8013b58: 6078         	str	r0, [r7, #0x4]
 8013b5a: 6039         	str	r1, [r7]
; 	if (LL_DMA_IsEnabledStream(dma, dma_stm32_id_to_stream(id)) == 1) {
 8013b5c: 6838         	ldr	r0, [r7]
 8013b5e: f7f3 fcff    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xc602
 8013b62: 4603         	mov	r3, r0
 8013b64: 4619         	mov	r1, r3
 8013b66: 6878         	ldr	r0, [r7, #0x4]
 8013b68: f7f3 fc6c    	bl	0x8007444 <LL_DMA_IsEnabledStream> @ imm = #-0xc728
 8013b6c: 4603         	mov	r3, r0
 8013b6e: 2b01         	cmp	r3, #0x1
 8013b70: d101         	bne	0x8013b76 <stm32_dma_is_enabled_stream+0x24> @ imm = #0x2
; 		return true;
 8013b72: 2301         	movs	r3, #0x1
 8013b74: e000         	b	0x8013b78 <stm32_dma_is_enabled_stream+0x26> @ imm = #0x0
; 	return false;
 8013b76: 2300         	movs	r3, #0x0
; }
 8013b78: 4618         	mov	r0, r3
 8013b7a: 3708         	adds	r7, #0x8
 8013b7c: 46bd         	mov	sp, r7
 8013b7e: bd80         	pop	{r7, pc}

08013b80 <stm32_dma_disable_stream>:
; {
 8013b80: b580         	push	{r7, lr}
 8013b82: b082         	sub	sp, #0x8
 8013b84: af00         	add	r7, sp, #0x0
 8013b86: 6078         	str	r0, [r7, #0x4]
 8013b88: 6039         	str	r1, [r7]
; 	LL_DMA_DisableStream(dma, dma_stm32_id_to_stream(id));
 8013b8a: 6838         	ldr	r0, [r7]
 8013b8c: f7f3 fce8    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xc630
 8013b90: 4603         	mov	r3, r0
 8013b92: 4619         	mov	r1, r3
 8013b94: 6878         	ldr	r0, [r7, #0x4]
 8013b96: f7f3 fc37    	bl	0x8007408 <LL_DMA_DisableStream> @ imm = #-0xc792
; 	while (stm32_dma_is_enabled_stream(dma, id)) {
 8013b9a: bf00         	nop
 8013b9c: 6839         	ldr	r1, [r7]
 8013b9e: 6878         	ldr	r0, [r7, #0x4]
 8013ba0: f7ff ffd7    	bl	0x8013b52 <stm32_dma_is_enabled_stream> @ imm = #-0x52
 8013ba4: 4603         	mov	r3, r0
 8013ba6: 2b00         	cmp	r3, #0x0
 8013ba8: d1f8         	bne	0x8013b9c <stm32_dma_disable_stream+0x1c> @ imm = #-0x10
; 	dma_stm32_clear_tc(dma, id);
 8013baa: 6839         	ldr	r1, [r7]
 8013bac: 6878         	ldr	r0, [r7, #0x4]
 8013bae: f7f3 fd09    	bl	0x80075c4 <dma_stm32_clear_tc> @ imm = #-0xc5ee
; 	return 0;
 8013bb2: 2300         	movs	r3, #0x0
; }
 8013bb4: 4618         	mov	r0, r3
 8013bb6: 3708         	adds	r7, #0x8
 8013bb8: 46bd         	mov	sp, r7
 8013bba: bd80         	pop	{r7, pc}

08013bbc <stm32_dma_disable_fifo_irq>:
; {
 8013bbc: b580         	push	{r7, lr}
 8013bbe: b082         	sub	sp, #0x8
 8013bc0: af00         	add	r7, sp, #0x0
 8013bc2: 6078         	str	r0, [r7, #0x4]
 8013bc4: 6039         	str	r1, [r7]
; 	LL_DMA_DisableIT_FE(dma, dma_stm32_id_to_stream(id));
 8013bc6: 6838         	ldr	r0, [r7]
 8013bc8: f7f3 fcca    	bl	0x8007560 <dma_stm32_id_to_stream> @ imm = #-0xc66c
 8013bcc: 4603         	mov	r3, r0
 8013bce: 4619         	mov	r1, r3
 8013bd0: 6878         	ldr	r0, [r7, #0x4]
 8013bd2: f7f3 fc53    	bl	0x800747c <LL_DMA_DisableIT_FE> @ imm = #-0xc75a
; }
 8013bd6: bf00         	nop
 8013bd8: 3708         	adds	r7, #0x8
 8013bda: 46bd         	mov	sp, r7
 8013bdc: bd80         	pop	{r7, pc}

08013bde <stm32_dma_check_fifo_mburst>:
; {
 8013bde: b480         	push	{r7}
 8013be0: b087         	sub	sp, #0x1c
 8013be2: af00         	add	r7, sp, #0x0
 8013be4: 6078         	str	r0, [r7, #0x4]
; 	uint32_t msize = DMAx->MemoryOrM2MDstDataSize;
 8013be6: 687b         	ldr	r3, [r7, #0x4]
 8013be8: 69db         	ldr	r3, [r3, #0x1c]
 8013bea: 617b         	str	r3, [r7, #0x14]
; 	uint32_t fifo_level = DMAx->FIFOThreshold;
 8013bec: 687b         	ldr	r3, [r7, #0x4]
 8013bee: 6b1b         	ldr	r3, [r3, #0x30]
 8013bf0: 613b         	str	r3, [r7, #0x10]
; 	uint32_t mburst = DMAx->MemBurst;
 8013bf2: 687b         	ldr	r3, [r7, #0x4]
 8013bf4: 6b5b         	ldr	r3, [r3, #0x34]
 8013bf6: 60fb         	str	r3, [r7, #0xc]
; 	switch (msize) {
 8013bf8: 697b         	ldr	r3, [r7, #0x14]
 8013bfa: f5b3 4f80    	cmp.w	r3, #0x4000
 8013bfe: d049         	beq	0x8013c94 <stm32_dma_check_fifo_mburst+0xb6> @ imm = #0x92
 8013c00: 697b         	ldr	r3, [r7, #0x14]
 8013c02: f5b3 4f80    	cmp.w	r3, #0x4000
 8013c06: d84f         	bhi	0x8013ca8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x9e
 8013c08: 697b         	ldr	r3, [r7, #0x14]
 8013c0a: 2b00         	cmp	r3, #0x0
 8013c0c: d004         	beq	0x8013c18 <stm32_dma_check_fifo_mburst+0x3a> @ imm = #0x8
 8013c0e: 697b         	ldr	r3, [r7, #0x14]
 8013c10: f5b3 5f00    	cmp.w	r3, #0x2000
 8013c14: d024         	beq	0x8013c60 <stm32_dma_check_fifo_mburst+0x82> @ imm = #0x48
 8013c16: e047         	b	0x8013ca8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x8e
 8013c18: 68fb         	ldr	r3, [r7, #0xc]
 8013c1a: f1b3 7fc0    	cmp.w	r3, #0x1800000
 8013c1e: d016         	beq	0x8013c4e <stm32_dma_check_fifo_mburst+0x70> @ imm = #0x2c
 8013c20: 68fb         	ldr	r3, [r7, #0xc]
 8013c22: f1b3 7fc0    	cmp.w	r3, #0x1800000
 8013c26: d83e         	bhi	0x8013ca6 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x7c
 8013c28: 68fb         	ldr	r3, [r7, #0xc]
 8013c2a: f5b3 0f00    	cmp.w	r3, #0x800000
 8013c2e: d004         	beq	0x8013c3a <stm32_dma_check_fifo_mburst+0x5c> @ imm = #0x8
 8013c30: 68fb         	ldr	r3, [r7, #0xc]
 8013c32: f1b3 7f80    	cmp.w	r3, #0x1000000
 8013c36: d002         	beq	0x8013c3e <stm32_dma_check_fifo_mburst+0x60> @ imm = #0x4
; 		break;
 8013c38: e035         	b	0x8013ca6 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x6a
; 			return true;
 8013c3a: 2301         	movs	r3, #0x1
 8013c3c: e035         	b	0x8013caa <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x6a
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_1_2 ||
 8013c3e: 693b         	ldr	r3, [r7, #0x10]
 8013c40: 2b01         	cmp	r3, #0x1
 8013c42: d002         	beq	0x8013c4a <stm32_dma_check_fifo_mburst+0x6c> @ imm = #0x4
 8013c44: 693b         	ldr	r3, [r7, #0x10]
 8013c46: 2b03         	cmp	r3, #0x3
 8013c48: d106         	bne	0x8013c58 <stm32_dma_check_fifo_mburst+0x7a> @ imm = #0xc
; 				return true;
 8013c4a: 2301         	movs	r3, #0x1
 8013c4c: e02d         	b	0x8013caa <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x5a
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_FULL) {
 8013c4e: 693b         	ldr	r3, [r7, #0x10]
 8013c50: 2b03         	cmp	r3, #0x3
 8013c52: d103         	bne	0x8013c5c <stm32_dma_check_fifo_mburst+0x7e> @ imm = #0x6
; 				return true;
 8013c54: 2301         	movs	r3, #0x1
 8013c56: e028         	b	0x8013caa <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x50
; 			break;
 8013c58: bf00         	nop
 8013c5a: e024         	b	0x8013ca6 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x48
; 			break;
 8013c5c: bf00         	nop
; 		break;
 8013c5e: e022         	b	0x8013ca6 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x44
 8013c60: 68fb         	ldr	r3, [r7, #0xc]
 8013c62: f5b3 0f00    	cmp.w	r3, #0x800000
 8013c66: d004         	beq	0x8013c72 <stm32_dma_check_fifo_mburst+0x94> @ imm = #0x8
 8013c68: 68fb         	ldr	r3, [r7, #0xc]
 8013c6a: f1b3 7f80    	cmp.w	r3, #0x1000000
 8013c6e: d008         	beq	0x8013c82 <stm32_dma_check_fifo_mburst+0xa4> @ imm = #0x10
; 		break;
 8013c70: e01a         	b	0x8013ca8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x34
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_1_2 ||
 8013c72: 693b         	ldr	r3, [r7, #0x10]
 8013c74: 2b01         	cmp	r3, #0x1
 8013c76: d002         	beq	0x8013c7e <stm32_dma_check_fifo_mburst+0xa0> @ imm = #0x4
 8013c78: 693b         	ldr	r3, [r7, #0x10]
 8013c7a: 2b03         	cmp	r3, #0x3
 8013c7c: d106         	bne	0x8013c8c <stm32_dma_check_fifo_mburst+0xae> @ imm = #0xc
; 				return true;
 8013c7e: 2301         	movs	r3, #0x1
 8013c80: e013         	b	0x8013caa <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x26
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_FULL) {
 8013c82: 693b         	ldr	r3, [r7, #0x10]
 8013c84: 2b03         	cmp	r3, #0x3
 8013c86: d103         	bne	0x8013c90 <stm32_dma_check_fifo_mburst+0xb2> @ imm = #0x6
; 				return true;
 8013c88: 2301         	movs	r3, #0x1
 8013c8a: e00e         	b	0x8013caa <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x1c
; 			break;
 8013c8c: bf00         	nop
 8013c8e: e00b         	b	0x8013ca8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x16
; 			break;
 8013c90: bf00         	nop
; 		break;
 8013c92: e009         	b	0x8013ca8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x12
; 		if (mburst == LL_DMA_MBURST_INC4 &&
 8013c94: 68fb         	ldr	r3, [r7, #0xc]
 8013c96: f5b3 0f00    	cmp.w	r3, #0x800000
 8013c9a: d105         	bne	0x8013ca8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0xa
 8013c9c: 693b         	ldr	r3, [r7, #0x10]
 8013c9e: 2b03         	cmp	r3, #0x3
 8013ca0: d102         	bne	0x8013ca8 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x4
; 			return true;
 8013ca2: 2301         	movs	r3, #0x1
 8013ca4: e001         	b	0x8013caa <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x2
; 		break;
 8013ca6: bf00         	nop
; 	return false;
 8013ca8: 2300         	movs	r3, #0x0
; }
 8013caa: 4618         	mov	r0, r3
 8013cac: 371c         	adds	r7, #0x1c
 8013cae: 46bd         	mov	sp, r7
 8013cb0: bc80         	pop	{r7}
 8013cb2: 4770         	bx	lr

08013cb4 <z_snode_next_peek>:
; {
 8013cb4: b480         	push	{r7}
 8013cb6: b083         	sub	sp, #0xc
 8013cb8: af00         	add	r7, sp, #0x0
 8013cba: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 8013cbc: 687b         	ldr	r3, [r7, #0x4]
 8013cbe: 681b         	ldr	r3, [r3]
; }
 8013cc0: 4618         	mov	r0, r3
 8013cc2: 370c         	adds	r7, #0xc
 8013cc4: 46bd         	mov	sp, r7
 8013cc6: bc80         	pop	{r7}
 8013cc8: 4770         	bx	lr

08013cca <z_snode_next_set>:
; {
 8013cca: b480         	push	{r7}
 8013ccc: b083         	sub	sp, #0xc
 8013cce: af00         	add	r7, sp, #0x0
 8013cd0: 6078         	str	r0, [r7, #0x4]
 8013cd2: 6039         	str	r1, [r7]
; 	parent->next = child;
 8013cd4: 687b         	ldr	r3, [r7, #0x4]
 8013cd6: 683a         	ldr	r2, [r7]
 8013cd8: 601a         	str	r2, [r3]
; }
 8013cda: bf00         	nop
 8013cdc: 370c         	adds	r7, #0xc
 8013cde: 46bd         	mov	sp, r7
 8013ce0: bc80         	pop	{r7}
 8013ce2: 4770         	bx	lr

08013ce4 <z_slist_head_set>:
; {
 8013ce4: b480         	push	{r7}
 8013ce6: b083         	sub	sp, #0xc
 8013ce8: af00         	add	r7, sp, #0x0
 8013cea: 6078         	str	r0, [r7, #0x4]
 8013cec: 6039         	str	r1, [r7]
; 	list->head = node;
 8013cee: 687b         	ldr	r3, [r7, #0x4]
 8013cf0: 683a         	ldr	r2, [r7]
 8013cf2: 601a         	str	r2, [r3]
; }
 8013cf4: bf00         	nop
 8013cf6: 370c         	adds	r7, #0xc
 8013cf8: 46bd         	mov	sp, r7
 8013cfa: bc80         	pop	{r7}
 8013cfc: 4770         	bx	lr

08013cfe <z_slist_tail_set>:
; {
 8013cfe: b480         	push	{r7}
 8013d00: b083         	sub	sp, #0xc
 8013d02: af00         	add	r7, sp, #0x0
 8013d04: 6078         	str	r0, [r7, #0x4]
 8013d06: 6039         	str	r1, [r7]
; 	list->tail = node;
 8013d08: 687b         	ldr	r3, [r7, #0x4]
 8013d0a: 683a         	ldr	r2, [r7]
 8013d0c: 605a         	str	r2, [r3, #0x4]
; }
 8013d0e: bf00         	nop
 8013d10: 370c         	adds	r7, #0xc
 8013d12: 46bd         	mov	sp, r7
 8013d14: bc80         	pop	{r7}
 8013d16: 4770         	bx	lr

08013d18 <sys_slist_peek_head>:
; {
 8013d18: b480         	push	{r7}
 8013d1a: b083         	sub	sp, #0xc
 8013d1c: af00         	add	r7, sp, #0x0
 8013d1e: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 8013d20: 687b         	ldr	r3, [r7, #0x4]
 8013d22: 681b         	ldr	r3, [r3]
; }
 8013d24: 4618         	mov	r0, r3
 8013d26: 370c         	adds	r7, #0xc
 8013d28: 46bd         	mov	sp, r7
 8013d2a: bc80         	pop	{r7}
 8013d2c: 4770         	bx	lr

08013d2e <sys_slist_peek_tail>:
; {
 8013d2e: b480         	push	{r7}
 8013d30: b083         	sub	sp, #0xc
 8013d32: af00         	add	r7, sp, #0x0
 8013d34: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 8013d36: 687b         	ldr	r3, [r7, #0x4]
 8013d38: 685b         	ldr	r3, [r3, #0x4]
; }
 8013d3a: 4618         	mov	r0, r3
 8013d3c: 370c         	adds	r7, #0xc
 8013d3e: 46bd         	mov	sp, r7
 8013d40: bc80         	pop	{r7}
 8013d42: 4770         	bx	lr

08013d44 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 8013d44: b580         	push	{r7, lr}
 8013d46: b082         	sub	sp, #0x8
 8013d48: af00         	add	r7, sp, #0x0
 8013d4a: 6078         	str	r0, [r7, #0x4]
 8013d4c: 6878         	ldr	r0, [r7, #0x4]
 8013d4e: f7ff ffe3    	bl	0x8013d18 <sys_slist_peek_head> @ imm = #-0x3a
 8013d52: 4603         	mov	r3, r0
 8013d54: 2b00         	cmp	r3, #0x0
 8013d56: bf0c         	ite	eq
 8013d58: 2301         	moveq	r3, #0x1
 8013d5a: 2300         	movne	r3, #0x0
 8013d5c: b2db         	uxtb	r3, r3
 8013d5e: 4618         	mov	r0, r3
 8013d60: 3708         	adds	r7, #0x8
 8013d62: 46bd         	mov	sp, r7
 8013d64: bd80         	pop	{r7, pc}

08013d66 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8013d66: b580         	push	{r7, lr}
 8013d68: b082         	sub	sp, #0x8
 8013d6a: af00         	add	r7, sp, #0x0
 8013d6c: 6078         	str	r0, [r7, #0x4]
 8013d6e: 6878         	ldr	r0, [r7, #0x4]
 8013d70: f7ff ffa0    	bl	0x8013cb4 <z_snode_next_peek> @ imm = #-0xc0
 8013d74: 4603         	mov	r3, r0
 8013d76: 4618         	mov	r0, r3
 8013d78: 3708         	adds	r7, #0x8
 8013d7a: 46bd         	mov	sp, r7
 8013d7c: bd80         	pop	{r7, pc}

08013d7e <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 8013d7e: b580         	push	{r7, lr}
 8013d80: b082         	sub	sp, #0x8
 8013d82: af00         	add	r7, sp, #0x0
 8013d84: 6078         	str	r0, [r7, #0x4]
 8013d86: 687b         	ldr	r3, [r7, #0x4]
 8013d88: 2b00         	cmp	r3, #0x0
 8013d8a: d004         	beq	0x8013d96 <sys_slist_peek_next+0x18> @ imm = #0x8
 8013d8c: 6878         	ldr	r0, [r7, #0x4]
 8013d8e: f7ff ffea    	bl	0x8013d66 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 8013d92: 4603         	mov	r3, r0
 8013d94: e000         	b	0x8013d98 <sys_slist_peek_next+0x1a> @ imm = #0x0
 8013d96: 2300         	movs	r3, #0x0
 8013d98: 4618         	mov	r0, r3
 8013d9a: 3708         	adds	r7, #0x8
 8013d9c: 46bd         	mov	sp, r7
 8013d9e: bd80         	pop	{r7, pc}

08013da0 <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 8013da0: b580         	push	{r7, lr}
 8013da2: b082         	sub	sp, #0x8
 8013da4: af00         	add	r7, sp, #0x0
 8013da6: 6078         	str	r0, [r7, #0x4]
 8013da8: 6039         	str	r1, [r7]
 8013daa: 6878         	ldr	r0, [r7, #0x4]
 8013dac: f7ff ffb4    	bl	0x8013d18 <sys_slist_peek_head> @ imm = #-0x98
 8013db0: 4603         	mov	r3, r0
 8013db2: 4619         	mov	r1, r3
 8013db4: 6838         	ldr	r0, [r7]
 8013db6: f7ff ff88    	bl	0x8013cca <z_snode_next_set> @ imm = #-0xf0
 8013dba: 6839         	ldr	r1, [r7]
 8013dbc: 6878         	ldr	r0, [r7, #0x4]
 8013dbe: f7ff ff91    	bl	0x8013ce4 <z_slist_head_set> @ imm = #-0xde
 8013dc2: 6878         	ldr	r0, [r7, #0x4]
 8013dc4: f7ff ffb3    	bl	0x8013d2e <sys_slist_peek_tail> @ imm = #-0x9a
 8013dc8: 4603         	mov	r3, r0
 8013dca: 2b00         	cmp	r3, #0x0
 8013dcc: d107         	bne	0x8013dde <sys_slist_prepend+0x3e> @ imm = #0xe
 8013dce: 6878         	ldr	r0, [r7, #0x4]
 8013dd0: f7ff ffa2    	bl	0x8013d18 <sys_slist_peek_head> @ imm = #-0xbc
 8013dd4: 4603         	mov	r3, r0
 8013dd6: 4619         	mov	r1, r3
 8013dd8: 6878         	ldr	r0, [r7, #0x4]
 8013dda: f7ff ff90    	bl	0x8013cfe <z_slist_tail_set> @ imm = #-0xe0
 8013dde: 3708         	adds	r7, #0x8
 8013de0: 46bd         	mov	sp, r7
 8013de2: bd80         	pop	{r7, pc}

08013de4 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 8013de4: b580         	push	{r7, lr}
 8013de6: b084         	sub	sp, #0x10
 8013de8: af00         	add	r7, sp, #0x0
 8013dea: 60f8         	str	r0, [r7, #0xc]
 8013dec: 60b9         	str	r1, [r7, #0x8]
 8013dee: 607a         	str	r2, [r7, #0x4]
 8013df0: 68bb         	ldr	r3, [r7, #0x8]
 8013df2: 2b00         	cmp	r3, #0x0
 8013df4: d117         	bne	0x8013e26 <sys_slist_remove+0x42> @ imm = #0x2e
 8013df6: 6878         	ldr	r0, [r7, #0x4]
 8013df8: f7ff ff5c    	bl	0x8013cb4 <z_snode_next_peek> @ imm = #-0x148
 8013dfc: 4603         	mov	r3, r0
 8013dfe: 4619         	mov	r1, r3
 8013e00: 68f8         	ldr	r0, [r7, #0xc]
 8013e02: f7ff ff6f    	bl	0x8013ce4 <z_slist_head_set> @ imm = #-0x122
 8013e06: 68f8         	ldr	r0, [r7, #0xc]
 8013e08: f7ff ff91    	bl	0x8013d2e <sys_slist_peek_tail> @ imm = #-0xde
 8013e0c: 4602         	mov	r2, r0
 8013e0e: 687b         	ldr	r3, [r7, #0x4]
 8013e10: 4293         	cmp	r3, r2
 8013e12: d11b         	bne	0x8013e4c <sys_slist_remove+0x68> @ imm = #0x36
 8013e14: 68f8         	ldr	r0, [r7, #0xc]
 8013e16: f7ff ff7f    	bl	0x8013d18 <sys_slist_peek_head> @ imm = #-0x102
 8013e1a: 4603         	mov	r3, r0
 8013e1c: 4619         	mov	r1, r3
 8013e1e: 68f8         	ldr	r0, [r7, #0xc]
 8013e20: f7ff ff6d    	bl	0x8013cfe <z_slist_tail_set> @ imm = #-0x126
 8013e24: e012         	b	0x8013e4c <sys_slist_remove+0x68> @ imm = #0x24
 8013e26: 6878         	ldr	r0, [r7, #0x4]
 8013e28: f7ff ff44    	bl	0x8013cb4 <z_snode_next_peek> @ imm = #-0x178
 8013e2c: 4603         	mov	r3, r0
 8013e2e: 4619         	mov	r1, r3
 8013e30: 68b8         	ldr	r0, [r7, #0x8]
 8013e32: f7ff ff4a    	bl	0x8013cca <z_snode_next_set> @ imm = #-0x16c
 8013e36: 68f8         	ldr	r0, [r7, #0xc]
 8013e38: f7ff ff79    	bl	0x8013d2e <sys_slist_peek_tail> @ imm = #-0x10e
 8013e3c: 4602         	mov	r2, r0
 8013e3e: 687b         	ldr	r3, [r7, #0x4]
 8013e40: 4293         	cmp	r3, r2
 8013e42: d103         	bne	0x8013e4c <sys_slist_remove+0x68> @ imm = #0x6
 8013e44: 68b9         	ldr	r1, [r7, #0x8]
 8013e46: 68f8         	ldr	r0, [r7, #0xc]
 8013e48: f7ff ff59    	bl	0x8013cfe <z_slist_tail_set> @ imm = #-0x14e
 8013e4c: 2100         	movs	r1, #0x0
 8013e4e: 6878         	ldr	r0, [r7, #0x4]
 8013e50: f7ff ff3b    	bl	0x8013cca <z_snode_next_set> @ imm = #-0x18a
 8013e54: 3710         	adds	r7, #0x10
 8013e56: 46bd         	mov	sp, r7
 8013e58: bd80         	pop	{r7, pc}

08013e5a <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8013e5a: b580         	push	{r7, lr}
 8013e5c: b084         	sub	sp, #0x10
 8013e5e: af00         	add	r7, sp, #0x0
 8013e60: 6078         	str	r0, [r7, #0x4]
 8013e62: 6039         	str	r1, [r7]
 8013e64: 2300         	movs	r3, #0x0
 8013e66: 60fb         	str	r3, [r7, #0xc]
 8013e68: 6878         	ldr	r0, [r7, #0x4]
 8013e6a: f7ff ff55    	bl	0x8013d18 <sys_slist_peek_head> @ imm = #-0x156
 8013e6e: 60b8         	str	r0, [r7, #0x8]
 8013e70: e010         	b	0x8013e94 <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 8013e72: 68ba         	ldr	r2, [r7, #0x8]
 8013e74: 683b         	ldr	r3, [r7]
 8013e76: 429a         	cmp	r2, r3
 8013e78: d106         	bne	0x8013e88 <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 8013e7a: 683a         	ldr	r2, [r7]
 8013e7c: 68f9         	ldr	r1, [r7, #0xc]
 8013e7e: 6878         	ldr	r0, [r7, #0x4]
 8013e80: f7ff ffb0    	bl	0x8013de4 <sys_slist_remove> @ imm = #-0xa0
 8013e84: 2301         	movs	r3, #0x1
 8013e86: e009         	b	0x8013e9c <sys_slist_find_and_remove+0x42> @ imm = #0x12
 8013e88: 68bb         	ldr	r3, [r7, #0x8]
 8013e8a: 60fb         	str	r3, [r7, #0xc]
 8013e8c: 68b8         	ldr	r0, [r7, #0x8]
 8013e8e: f7ff ff76    	bl	0x8013d7e <sys_slist_peek_next> @ imm = #-0x114
 8013e92: 60b8         	str	r0, [r7, #0x8]
 8013e94: 68bb         	ldr	r3, [r7, #0x8]
 8013e96: 2b00         	cmp	r3, #0x0
 8013e98: d1eb         	bne	0x8013e72 <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 8013e9a: 2300         	movs	r3, #0x0
 8013e9c: 4618         	mov	r0, r3
 8013e9e: 3710         	adds	r7, #0x10
 8013ea0: 46bd         	mov	sp, r7
 8013ea2: bd80         	pop	{r7, pc}

08013ea4 <device_is_ready>:
; {
 8013ea4: b580         	push	{r7, lr}
 8013ea6: b082         	sub	sp, #0x8
 8013ea8: af00         	add	r7, sp, #0x0
 8013eaa: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8013eac: 6878         	ldr	r0, [r7, #0x4]
 8013eae: f002 ff94    	bl	0x8016dda <z_impl_device_is_ready> @ imm = #0x2f28
 8013eb2: 4603         	mov	r3, r0
; }
 8013eb4: 4618         	mov	r0, r3
 8013eb6: 3708         	adds	r7, #0x8
 8013eb8: 46bd         	mov	sp, r7
 8013eba: bd80         	pop	{r7, pc}

08013ebc <LL_GPIO_SetPinMode>:
; {
 8013ebc: b480         	push	{r7}
 8013ebe: b08b         	sub	sp, #0x2c
 8013ec0: af00         	add	r7, sp, #0x0
 8013ec2: 60f8         	str	r0, [r7, #0xc]
 8013ec4: 60b9         	str	r1, [r7, #0x8]
 8013ec6: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8013ec8: 68fb         	ldr	r3, [r7, #0xc]
 8013eca: 681a         	ldr	r2, [r3]
 8013ecc: 68bb         	ldr	r3, [r7, #0x8]
 8013ece: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8013ed0: 697b         	ldr	r3, [r7, #0x14]
 8013ed2: fa93 f3a3    	rbit	r3, r3
 8013ed6: 613b         	str	r3, [r7, #0x10]
;   return result;
 8013ed8: 693b         	ldr	r3, [r7, #0x10]
 8013eda: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8013edc: 69bb         	ldr	r3, [r7, #0x18]
 8013ede: 2b00         	cmp	r3, #0x0
 8013ee0: d101         	bne	0x8013ee6 <LL_GPIO_SetPinMode+0x2a> @ imm = #0x2
;     return 32U;
 8013ee2: 2320         	movs	r3, #0x20
 8013ee4: e003         	b	0x8013eee <LL_GPIO_SetPinMode+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 8013ee6: 69bb         	ldr	r3, [r7, #0x18]
 8013ee8: fab3 f383    	clz	r3, r3
 8013eec: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8013eee: 005b         	lsls	r3, r3, #0x1
 8013ef0: 2103         	movs	r1, #0x3
 8013ef2: fa01 f303    	lsl.w	r3, r1, r3
 8013ef6: 43db         	mvns	r3, r3
 8013ef8: 401a         	ands	r2, r3
 8013efa: 68bb         	ldr	r3, [r7, #0x8]
 8013efc: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8013efe: 6a3b         	ldr	r3, [r7, #0x20]
 8013f00: fa93 f3a3    	rbit	r3, r3
 8013f04: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 8013f06: 69fb         	ldr	r3, [r7, #0x1c]
 8013f08: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 8013f0a: 6a7b         	ldr	r3, [r7, #0x24]
 8013f0c: 2b00         	cmp	r3, #0x0
 8013f0e: d101         	bne	0x8013f14 <LL_GPIO_SetPinMode+0x58> @ imm = #0x2
;     return 32U;
 8013f10: 2320         	movs	r3, #0x20
 8013f12: e003         	b	0x8013f1c <LL_GPIO_SetPinMode+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 8013f14: 6a7b         	ldr	r3, [r7, #0x24]
 8013f16: fab3 f383    	clz	r3, r3
 8013f1a: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8013f1c: 005b         	lsls	r3, r3, #0x1
 8013f1e: 6879         	ldr	r1, [r7, #0x4]
 8013f20: fa01 f303    	lsl.w	r3, r1, r3
 8013f24: 431a         	orrs	r2, r3
 8013f26: 68fb         	ldr	r3, [r7, #0xc]
 8013f28: 601a         	str	r2, [r3]
; }
 8013f2a: bf00         	nop
 8013f2c: 372c         	adds	r7, #0x2c
 8013f2e: 46bd         	mov	sp, r7
 8013f30: bc80         	pop	{r7}
 8013f32: 4770         	bx	lr

08013f34 <LL_GPIO_SetPinOutputType>:
; {
 8013f34: b480         	push	{r7}
 8013f36: b085         	sub	sp, #0x14
 8013f38: af00         	add	r7, sp, #0x0
 8013f3a: 60f8         	str	r0, [r7, #0xc]
 8013f3c: 60b9         	str	r1, [r7, #0x8]
 8013f3e: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8013f40: 68fb         	ldr	r3, [r7, #0xc]
 8013f42: 685a         	ldr	r2, [r3, #0x4]
 8013f44: 68bb         	ldr	r3, [r7, #0x8]
 8013f46: 43db         	mvns	r3, r3
 8013f48: 401a         	ands	r2, r3
 8013f4a: 68bb         	ldr	r3, [r7, #0x8]
 8013f4c: 6879         	ldr	r1, [r7, #0x4]
 8013f4e: fb01 f303    	mul	r3, r1, r3
 8013f52: 431a         	orrs	r2, r3
 8013f54: 68fb         	ldr	r3, [r7, #0xc]
 8013f56: 605a         	str	r2, [r3, #0x4]
; }
 8013f58: bf00         	nop
 8013f5a: 3714         	adds	r7, #0x14
 8013f5c: 46bd         	mov	sp, r7
 8013f5e: bc80         	pop	{r7}
 8013f60: 4770         	bx	lr

08013f62 <LL_GPIO_SetPinSpeed>:
; {
 8013f62: b480         	push	{r7}
 8013f64: b08b         	sub	sp, #0x2c
 8013f66: af00         	add	r7, sp, #0x0
 8013f68: 60f8         	str	r0, [r7, #0xc]
 8013f6a: 60b9         	str	r1, [r7, #0x8]
 8013f6c: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8013f6e: 68fb         	ldr	r3, [r7, #0xc]
 8013f70: 689a         	ldr	r2, [r3, #0x8]
 8013f72: 68bb         	ldr	r3, [r7, #0x8]
 8013f74: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8013f76: 697b         	ldr	r3, [r7, #0x14]
 8013f78: fa93 f3a3    	rbit	r3, r3
 8013f7c: 613b         	str	r3, [r7, #0x10]
;   return result;
 8013f7e: 693b         	ldr	r3, [r7, #0x10]
 8013f80: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8013f82: 69bb         	ldr	r3, [r7, #0x18]
 8013f84: 2b00         	cmp	r3, #0x0
 8013f86: d101         	bne	0x8013f8c <LL_GPIO_SetPinSpeed+0x2a> @ imm = #0x2
;     return 32U;
 8013f88: 2320         	movs	r3, #0x20
 8013f8a: e003         	b	0x8013f94 <LL_GPIO_SetPinSpeed+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 8013f8c: 69bb         	ldr	r3, [r7, #0x18]
 8013f8e: fab3 f383    	clz	r3, r3
 8013f92: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8013f94: 005b         	lsls	r3, r3, #0x1
 8013f96: 2103         	movs	r1, #0x3
 8013f98: fa01 f303    	lsl.w	r3, r1, r3
 8013f9c: 43db         	mvns	r3, r3
 8013f9e: 401a         	ands	r2, r3
 8013fa0: 68bb         	ldr	r3, [r7, #0x8]
 8013fa2: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8013fa4: 6a3b         	ldr	r3, [r7, #0x20]
 8013fa6: fa93 f3a3    	rbit	r3, r3
 8013faa: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 8013fac: 69fb         	ldr	r3, [r7, #0x1c]
 8013fae: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 8013fb0: 6a7b         	ldr	r3, [r7, #0x24]
 8013fb2: 2b00         	cmp	r3, #0x0
 8013fb4: d101         	bne	0x8013fba <LL_GPIO_SetPinSpeed+0x58> @ imm = #0x2
;     return 32U;
 8013fb6: 2320         	movs	r3, #0x20
 8013fb8: e003         	b	0x8013fc2 <LL_GPIO_SetPinSpeed+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 8013fba: 6a7b         	ldr	r3, [r7, #0x24]
 8013fbc: fab3 f383    	clz	r3, r3
 8013fc0: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8013fc2: 005b         	lsls	r3, r3, #0x1
 8013fc4: 6879         	ldr	r1, [r7, #0x4]
 8013fc6: fa01 f303    	lsl.w	r3, r1, r3
 8013fca: 431a         	orrs	r2, r3
 8013fcc: 68fb         	ldr	r3, [r7, #0xc]
 8013fce: 609a         	str	r2, [r3, #0x8]
; }
 8013fd0: bf00         	nop
 8013fd2: 372c         	adds	r7, #0x2c
 8013fd4: 46bd         	mov	sp, r7
 8013fd6: bc80         	pop	{r7}
 8013fd8: 4770         	bx	lr

08013fda <LL_GPIO_SetPinPull>:
; {
 8013fda: b480         	push	{r7}
 8013fdc: b08b         	sub	sp, #0x2c
 8013fde: af00         	add	r7, sp, #0x0
 8013fe0: 60f8         	str	r0, [r7, #0xc]
 8013fe2: 60b9         	str	r1, [r7, #0x8]
 8013fe4: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 8013fe6: 68fb         	ldr	r3, [r7, #0xc]
 8013fe8: 68da         	ldr	r2, [r3, #0xc]
 8013fea: 68bb         	ldr	r3, [r7, #0x8]
 8013fec: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8013fee: 697b         	ldr	r3, [r7, #0x14]
 8013ff0: fa93 f3a3    	rbit	r3, r3
 8013ff4: 613b         	str	r3, [r7, #0x10]
;   return result;
 8013ff6: 693b         	ldr	r3, [r7, #0x10]
 8013ff8: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8013ffa: 69bb         	ldr	r3, [r7, #0x18]
 8013ffc: 2b00         	cmp	r3, #0x0
 8013ffe: d101         	bne	0x8014004 <LL_GPIO_SetPinPull+0x2a> @ imm = #0x2
;     return 32U;
 8014000: 2320         	movs	r3, #0x20
 8014002: e003         	b	0x801400c <LL_GPIO_SetPinPull+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 8014004: 69bb         	ldr	r3, [r7, #0x18]
 8014006: fab3 f383    	clz	r3, r3
 801400a: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 801400c: 005b         	lsls	r3, r3, #0x1
 801400e: 2103         	movs	r1, #0x3
 8014010: fa01 f303    	lsl.w	r3, r1, r3
 8014014: 43db         	mvns	r3, r3
 8014016: 401a         	ands	r2, r3
 8014018: 68bb         	ldr	r3, [r7, #0x8]
 801401a: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801401c: 6a3b         	ldr	r3, [r7, #0x20]
 801401e: fa93 f3a3    	rbit	r3, r3
 8014022: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 8014024: 69fb         	ldr	r3, [r7, #0x1c]
 8014026: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 8014028: 6a7b         	ldr	r3, [r7, #0x24]
 801402a: 2b00         	cmp	r3, #0x0
 801402c: d101         	bne	0x8014032 <LL_GPIO_SetPinPull+0x58> @ imm = #0x2
;     return 32U;
 801402e: 2320         	movs	r3, #0x20
 8014030: e003         	b	0x801403a <LL_GPIO_SetPinPull+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 8014032: 6a7b         	ldr	r3, [r7, #0x24]
 8014034: fab3 f383    	clz	r3, r3
 8014038: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 801403a: 005b         	lsls	r3, r3, #0x1
 801403c: 6879         	ldr	r1, [r7, #0x4]
 801403e: fa01 f303    	lsl.w	r3, r1, r3
 8014042: 431a         	orrs	r2, r3
 8014044: 68fb         	ldr	r3, [r7, #0xc]
 8014046: 60da         	str	r2, [r3, #0xc]
; }
 8014048: bf00         	nop
 801404a: 372c         	adds	r7, #0x2c
 801404c: 46bd         	mov	sp, r7
 801404e: bc80         	pop	{r7}
 8014050: 4770         	bx	lr

08014052 <LL_GPIO_SetAFPin_0_7>:
; {
 8014052: b480         	push	{r7}
 8014054: b08b         	sub	sp, #0x2c
 8014056: af00         	add	r7, sp, #0x0
 8014058: 60f8         	str	r0, [r7, #0xc]
 801405a: 60b9         	str	r1, [r7, #0x8]
 801405c: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 801405e: 68fb         	ldr	r3, [r7, #0xc]
 8014060: 6a1a         	ldr	r2, [r3, #0x20]
 8014062: 68bb         	ldr	r3, [r7, #0x8]
 8014064: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8014066: 697b         	ldr	r3, [r7, #0x14]
 8014068: fa93 f3a3    	rbit	r3, r3
 801406c: 613b         	str	r3, [r7, #0x10]
;   return result;
 801406e: 693b         	ldr	r3, [r7, #0x10]
 8014070: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8014072: 69bb         	ldr	r3, [r7, #0x18]
 8014074: 2b00         	cmp	r3, #0x0
 8014076: d101         	bne	0x801407c <LL_GPIO_SetAFPin_0_7+0x2a> @ imm = #0x2
;     return 32U;
 8014078: 2320         	movs	r3, #0x20
 801407a: e003         	b	0x8014084 <LL_GPIO_SetAFPin_0_7+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 801407c: 69bb         	ldr	r3, [r7, #0x18]
 801407e: fab3 f383    	clz	r3, r3
 8014082: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8014084: 009b         	lsls	r3, r3, #0x2
 8014086: 210f         	movs	r1, #0xf
 8014088: fa01 f303    	lsl.w	r3, r1, r3
 801408c: 43db         	mvns	r3, r3
 801408e: 401a         	ands	r2, r3
 8014090: 68bb         	ldr	r3, [r7, #0x8]
 8014092: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8014094: 6a3b         	ldr	r3, [r7, #0x20]
 8014096: fa93 f3a3    	rbit	r3, r3
 801409a: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 801409c: 69fb         	ldr	r3, [r7, #0x1c]
 801409e: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 80140a0: 6a7b         	ldr	r3, [r7, #0x24]
 80140a2: 2b00         	cmp	r3, #0x0
 80140a4: d101         	bne	0x80140aa <LL_GPIO_SetAFPin_0_7+0x58> @ imm = #0x2
;     return 32U;
 80140a6: 2320         	movs	r3, #0x20
 80140a8: e003         	b	0x80140b2 <LL_GPIO_SetAFPin_0_7+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 80140aa: 6a7b         	ldr	r3, [r7, #0x24]
 80140ac: fab3 f383    	clz	r3, r3
 80140b0: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 80140b2: 009b         	lsls	r3, r3, #0x2
 80140b4: 6879         	ldr	r1, [r7, #0x4]
 80140b6: fa01 f303    	lsl.w	r3, r1, r3
 80140ba: 431a         	orrs	r2, r3
 80140bc: 68fb         	ldr	r3, [r7, #0xc]
 80140be: 621a         	str	r2, [r3, #0x20]
; }
 80140c0: bf00         	nop
 80140c2: 372c         	adds	r7, #0x2c
 80140c4: 46bd         	mov	sp, r7
 80140c6: bc80         	pop	{r7}
 80140c8: 4770         	bx	lr

080140ca <LL_GPIO_SetAFPin_8_15>:
; {
 80140ca: b480         	push	{r7}
 80140cc: b08b         	sub	sp, #0x2c
 80140ce: af00         	add	r7, sp, #0x0
 80140d0: 60f8         	str	r0, [r7, #0xc]
 80140d2: 60b9         	str	r1, [r7, #0x8]
 80140d4: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 80140d6: 68fb         	ldr	r3, [r7, #0xc]
 80140d8: 6a5a         	ldr	r2, [r3, #0x24]
 80140da: 68bb         	ldr	r3, [r7, #0x8]
 80140dc: 0a1b         	lsrs	r3, r3, #0x8
 80140de: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80140e0: 697b         	ldr	r3, [r7, #0x14]
 80140e2: fa93 f3a3    	rbit	r3, r3
 80140e6: 613b         	str	r3, [r7, #0x10]
;   return result;
 80140e8: 693b         	ldr	r3, [r7, #0x10]
 80140ea: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 80140ec: 69bb         	ldr	r3, [r7, #0x18]
 80140ee: 2b00         	cmp	r3, #0x0
 80140f0: d101         	bne	0x80140f6 <LL_GPIO_SetAFPin_8_15+0x2c> @ imm = #0x2
;     return 32U;
 80140f2: 2320         	movs	r3, #0x20
 80140f4: e003         	b	0x80140fe <LL_GPIO_SetAFPin_8_15+0x34> @ imm = #0x6
;   return __builtin_clz(value);
 80140f6: 69bb         	ldr	r3, [r7, #0x18]
 80140f8: fab3 f383    	clz	r3, r3
 80140fc: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 80140fe: 009b         	lsls	r3, r3, #0x2
 8014100: 210f         	movs	r1, #0xf
 8014102: fa01 f303    	lsl.w	r3, r1, r3
 8014106: 43db         	mvns	r3, r3
 8014108: 401a         	ands	r2, r3
 801410a: 68bb         	ldr	r3, [r7, #0x8]
 801410c: 0a1b         	lsrs	r3, r3, #0x8
 801410e: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8014110: 6a3b         	ldr	r3, [r7, #0x20]
 8014112: fa93 f3a3    	rbit	r3, r3
 8014116: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 8014118: 69fb         	ldr	r3, [r7, #0x1c]
 801411a: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 801411c: 6a7b         	ldr	r3, [r7, #0x24]
 801411e: 2b00         	cmp	r3, #0x0
 8014120: d101         	bne	0x8014126 <LL_GPIO_SetAFPin_8_15+0x5c> @ imm = #0x2
;     return 32U;
 8014122: 2320         	movs	r3, #0x20
 8014124: e003         	b	0x801412e <LL_GPIO_SetAFPin_8_15+0x64> @ imm = #0x6
;   return __builtin_clz(value);
 8014126: 6a7b         	ldr	r3, [r7, #0x24]
 8014128: fab3 f383    	clz	r3, r3
 801412c: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 801412e: 009b         	lsls	r3, r3, #0x2
 8014130: 6879         	ldr	r1, [r7, #0x4]
 8014132: fa01 f303    	lsl.w	r3, r1, r3
 8014136: 431a         	orrs	r2, r3
 8014138: 68fb         	ldr	r3, [r7, #0xc]
 801413a: 625a         	str	r2, [r3, #0x24]
; }
 801413c: bf00         	nop
 801413e: 372c         	adds	r7, #0x2c
 8014140: 46bd         	mov	sp, r7
 8014142: bc80         	pop	{r7}
 8014144: 4770         	bx	lr

08014146 <LL_GPIO_ReadInputPort>:
; {
 8014146: b480         	push	{r7}
 8014148: b083         	sub	sp, #0xc
 801414a: af00         	add	r7, sp, #0x0
 801414c: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->IDR));
 801414e: 687b         	ldr	r3, [r7, #0x4]
 8014150: 691b         	ldr	r3, [r3, #0x10]
; }
 8014152: 4618         	mov	r0, r3
 8014154: 370c         	adds	r7, #0xc
 8014156: 46bd         	mov	sp, r7
 8014158: bc80         	pop	{r7}
 801415a: 4770         	bx	lr

0801415c <LL_GPIO_WriteOutputPort>:
; {
 801415c: b480         	push	{r7}
 801415e: b083         	sub	sp, #0xc
 8014160: af00         	add	r7, sp, #0x0
 8014162: 6078         	str	r0, [r7, #0x4]
 8014164: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->ODR, PortValue);
 8014166: 687b         	ldr	r3, [r7, #0x4]
 8014168: 683a         	ldr	r2, [r7]
 801416a: 615a         	str	r2, [r3, #0x14]
; }
 801416c: bf00         	nop
 801416e: 370c         	adds	r7, #0xc
 8014170: 46bd         	mov	sp, r7
 8014172: bc80         	pop	{r7}
 8014174: 4770         	bx	lr

08014176 <LL_GPIO_ReadOutputPort>:
; {
 8014176: b480         	push	{r7}
 8014178: b083         	sub	sp, #0xc
 801417a: af00         	add	r7, sp, #0x0
 801417c: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->ODR));
 801417e: 687b         	ldr	r3, [r7, #0x4]
 8014180: 695b         	ldr	r3, [r3, #0x14]
; }
 8014182: 4618         	mov	r0, r3
 8014184: 370c         	adds	r7, #0xc
 8014186: 46bd         	mov	sp, r7
 8014188: bc80         	pop	{r7}
 801418a: 4770         	bx	lr

0801418c <LL_GPIO_ResetOutputPin>:
; {
 801418c: b480         	push	{r7}
 801418e: b083         	sub	sp, #0xc
 8014190: af00         	add	r7, sp, #0x0
 8014192: 6078         	str	r0, [r7, #0x4]
 8014194: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->BSRR, (PinMask << 16));
 8014196: 683b         	ldr	r3, [r7]
 8014198: 041a         	lsls	r2, r3, #0x10
 801419a: 687b         	ldr	r3, [r7, #0x4]
 801419c: 619a         	str	r2, [r3, #0x18]
; }
 801419e: bf00         	nop
 80141a0: 370c         	adds	r7, #0xc
 80141a2: 46bd         	mov	sp, r7
 80141a4: bc80         	pop	{r7}
 80141a6: 4770         	bx	lr

080141a8 <clock_control_on>:
; {
 80141a8: b580         	push	{r7, lr}
 80141aa: b084         	sub	sp, #0x10
 80141ac: af00         	add	r7, sp, #0x0
 80141ae: 6078         	str	r0, [r7, #0x4]
 80141b0: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 80141b2: 687b         	ldr	r3, [r7, #0x4]
 80141b4: 689b         	ldr	r3, [r3, #0x8]
 80141b6: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 80141b8: 68fb         	ldr	r3, [r7, #0xc]
 80141ba: 681b         	ldr	r3, [r3]
 80141bc: 6839         	ldr	r1, [r7]
 80141be: 6878         	ldr	r0, [r7, #0x4]
 80141c0: 4798         	blx	r3
 80141c2: 4603         	mov	r3, r0
; }
 80141c4: 4618         	mov	r0, r3
 80141c6: 3710         	adds	r7, #0x10
 80141c8: 46bd         	mov	sp, r7
 80141ca: bd80         	pop	{r7, pc}

080141cc <clock_control_off>:
; {
 80141cc: b580         	push	{r7, lr}
 80141ce: b084         	sub	sp, #0x10
 80141d0: af00         	add	r7, sp, #0x0
 80141d2: 6078         	str	r0, [r7, #0x4]
 80141d4: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 80141d6: 687b         	ldr	r3, [r7, #0x4]
 80141d8: 689b         	ldr	r3, [r3, #0x8]
 80141da: 60fb         	str	r3, [r7, #0xc]
; 	return api->off(dev, sys);
 80141dc: 68fb         	ldr	r3, [r7, #0xc]
 80141de: 685b         	ldr	r3, [r3, #0x4]
 80141e0: 6839         	ldr	r1, [r7]
 80141e2: 6878         	ldr	r0, [r7, #0x4]
 80141e4: 4798         	blx	r3
 80141e6: 4603         	mov	r3, r0
; }
 80141e8: 4618         	mov	r0, r3
 80141ea: 3710         	adds	r7, #0x10
 80141ec: 46bd         	mov	sp, r7
 80141ee: bd80         	pop	{r7, pc}

080141f0 <pm_device_runtime_enable>:
; {
 80141f0: b480         	push	{r7}
 80141f2: b083         	sub	sp, #0xc
 80141f4: af00         	add	r7, sp, #0x0
 80141f6: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 80141f8: 2300         	movs	r3, #0x0
; }
 80141fa: 4618         	mov	r0, r3
 80141fc: 370c         	adds	r7, #0xc
 80141fe: 46bd         	mov	sp, r7
 8014200: bc80         	pop	{r7}
 8014202: 4770         	bx	lr

08014204 <pm_device_runtime_get>:
; {
 8014204: b480         	push	{r7}
 8014206: b083         	sub	sp, #0xc
 8014208: af00         	add	r7, sp, #0x0
 801420a: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801420c: 2300         	movs	r3, #0x0
; }
 801420e: 4618         	mov	r0, r3
 8014210: 370c         	adds	r7, #0xc
 8014212: 46bd         	mov	sp, r7
 8014214: bc80         	pop	{r7}
 8014216: 4770         	bx	lr

08014218 <pm_device_runtime_put>:
; {
 8014218: b480         	push	{r7}
 801421a: b083         	sub	sp, #0xc
 801421c: af00         	add	r7, sp, #0x0
 801421e: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8014220: 2300         	movs	r3, #0x0
; }
 8014222: 4618         	mov	r0, r3
 8014224: 370c         	adds	r7, #0xc
 8014226: 46bd         	mov	sp, r7
 8014228: bc80         	pop	{r7}
 801422a: 4770         	bx	lr

0801422c <z_stm32_hsem_lock>:
; {
 801422c: b480         	push	{r7}
 801422e: b083         	sub	sp, #0xc
 8014230: af00         	add	r7, sp, #0x0
 8014232: 6078         	str	r0, [r7, #0x4]
 8014234: 6039         	str	r1, [r7]
; }
 8014236: bf00         	nop
 8014238: 370c         	adds	r7, #0xc
 801423a: 46bd         	mov	sp, r7
 801423c: bc80         	pop	{r7}
 801423e: 4770         	bx	lr

08014240 <z_stm32_hsem_unlock>:
; {
 8014240: b480         	push	{r7}
 8014242: b083         	sub	sp, #0xc
 8014244: af00         	add	r7, sp, #0x0
 8014246: 6078         	str	r0, [r7, #0x4]
; }
 8014248: bf00         	nop
 801424a: 370c         	adds	r7, #0xc
 801424c: 46bd         	mov	sp, r7
 801424e: bc80         	pop	{r7}
 8014250: 4770         	bx	lr

08014252 <gpio_manage_callback>:
; {
 8014252: b580         	push	{r7, lr}
 8014254: b084         	sub	sp, #0x10
 8014256: af00         	add	r7, sp, #0x0
 8014258: 60f8         	str	r0, [r7, #0xc]
 801425a: 60b9         	str	r1, [r7, #0x8]
 801425c: 4613         	mov	r3, r2
 801425e: 71fb         	strb	r3, [r7, #0x7]
; 	if (!sys_slist_is_empty(callbacks)) {
 8014260: 68f8         	ldr	r0, [r7, #0xc]
 8014262: f7ff fd6f    	bl	0x8013d44 <sys_slist_is_empty> @ imm = #-0x522
 8014266: 4603         	mov	r3, r0
 8014268: f083 0301    	eor	r3, r3, #0x1
 801426c: b2db         	uxtb	r3, r3
 801426e: 2b00         	cmp	r3, #0x0
 8014270: d013         	beq	0x801429a <gpio_manage_callback+0x48> @ imm = #0x26
; 		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
 8014272: 68bb         	ldr	r3, [r7, #0x8]
 8014274: 4619         	mov	r1, r3
 8014276: 68f8         	ldr	r0, [r7, #0xc]
 8014278: f7ff fdef    	bl	0x8013e5a <sys_slist_find_and_remove> @ imm = #-0x422
 801427c: 4603         	mov	r3, r0
 801427e: f083 0301    	eor	r3, r3, #0x1
 8014282: b2db         	uxtb	r3, r3
 8014284: 2b00         	cmp	r3, #0x0
 8014286: d011         	beq	0x80142ac <gpio_manage_callback+0x5a> @ imm = #0x22
; 			if (!set) {
 8014288: 79fb         	ldrb	r3, [r7, #0x7]
 801428a: f083 0301    	eor	r3, r3, #0x1
 801428e: b2db         	uxtb	r3, r3
 8014290: 2b00         	cmp	r3, #0x0
 8014292: d00b         	beq	0x80142ac <gpio_manage_callback+0x5a> @ imm = #0x16
; 				return -EINVAL;
 8014294: f06f 0315    	mvn	r3, #0x15
 8014298: e011         	b	0x80142be <gpio_manage_callback+0x6c> @ imm = #0x22
; 	} else if (!set) {
 801429a: 79fb         	ldrb	r3, [r7, #0x7]
 801429c: f083 0301    	eor	r3, r3, #0x1
 80142a0: b2db         	uxtb	r3, r3
 80142a2: 2b00         	cmp	r3, #0x0
 80142a4: d002         	beq	0x80142ac <gpio_manage_callback+0x5a> @ imm = #0x4
; 		return -EINVAL;
 80142a6: f06f 0315    	mvn	r3, #0x15
 80142aa: e008         	b	0x80142be <gpio_manage_callback+0x6c> @ imm = #0x10
; 	if (set) {
 80142ac: 79fb         	ldrb	r3, [r7, #0x7]
 80142ae: 2b00         	cmp	r3, #0x0
 80142b0: d004         	beq	0x80142bc <gpio_manage_callback+0x6a> @ imm = #0x8
; 		sys_slist_prepend(callbacks, &callback->node);
 80142b2: 68bb         	ldr	r3, [r7, #0x8]
 80142b4: 4619         	mov	r1, r3
 80142b6: 68f8         	ldr	r0, [r7, #0xc]
 80142b8: f7ff fd72    	bl	0x8013da0 <sys_slist_prepend> @ imm = #-0x51c
; 	return 0;
 80142bc: 2300         	movs	r3, #0x0
; }
 80142be: 4618         	mov	r0, r3
 80142c0: 3710         	adds	r7, #0x10
 80142c2: 46bd         	mov	sp, r7
 80142c4: bd80         	pop	{r7, pc}

080142c6 <gpio_fire_callbacks>:
; {
 80142c6: b580         	push	{r7, lr}
 80142c8: b086         	sub	sp, #0x18
 80142ca: af00         	add	r7, sp, #0x0
 80142cc: 60f8         	str	r0, [r7, #0xc]
 80142ce: 60b9         	str	r1, [r7, #0x8]
 80142d0: 607a         	str	r2, [r7, #0x4]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 80142d2: 68f8         	ldr	r0, [r7, #0xc]
 80142d4: f7ff fd20    	bl	0x8013d18 <sys_slist_peek_head> @ imm = #-0x5c0
 80142d8: 4603         	mov	r3, r0
 80142da: 2b00         	cmp	r3, #0x0
 80142dc: d004         	beq	0x80142e8 <gpio_fire_callbacks+0x22> @ imm = #0x8
 80142de: 68f8         	ldr	r0, [r7, #0xc]
 80142e0: f7ff fd1a    	bl	0x8013d18 <sys_slist_peek_head> @ imm = #-0x5cc
 80142e4: 4603         	mov	r3, r0
 80142e6: e000         	b	0x80142ea <gpio_fire_callbacks+0x24> @ imm = #0x0
 80142e8: 2300         	movs	r3, #0x0
 80142ea: 617b         	str	r3, [r7, #0x14]
 80142ec: 697b         	ldr	r3, [r7, #0x14]
 80142ee: 2b00         	cmp	r3, #0x0
 80142f0: d00e         	beq	0x8014310 <gpio_fire_callbacks+0x4a> @ imm = #0x1c
 80142f2: 697b         	ldr	r3, [r7, #0x14]
 80142f4: 4618         	mov	r0, r3
 80142f6: f7ff fd42    	bl	0x8013d7e <sys_slist_peek_next> @ imm = #-0x57c
 80142fa: 4603         	mov	r3, r0
 80142fc: 2b00         	cmp	r3, #0x0
 80142fe: d005         	beq	0x801430c <gpio_fire_callbacks+0x46> @ imm = #0xa
 8014300: 697b         	ldr	r3, [r7, #0x14]
 8014302: 4618         	mov	r0, r3
 8014304: f7ff fd3b    	bl	0x8013d7e <sys_slist_peek_next> @ imm = #-0x58a
 8014308: 4603         	mov	r3, r0
 801430a: e002         	b	0x8014312 <gpio_fire_callbacks+0x4c> @ imm = #0x4
 801430c: 2300         	movs	r3, #0x0
 801430e: e000         	b	0x8014312 <gpio_fire_callbacks+0x4c> @ imm = #0x0
 8014310: 2300         	movs	r3, #0x0
 8014312: 613b         	str	r3, [r7, #0x10]
 8014314: e024         	b	0x8014360 <gpio_fire_callbacks+0x9a> @ imm = #0x48
; 		if (cb->pin_mask & pins) {
 8014316: 697b         	ldr	r3, [r7, #0x14]
 8014318: 689a         	ldr	r2, [r3, #0x8]
 801431a: 687b         	ldr	r3, [r7, #0x4]
 801431c: 4013         	ands	r3, r2
 801431e: 2b00         	cmp	r3, #0x0
 8014320: d008         	beq	0x8014334 <gpio_fire_callbacks+0x6e> @ imm = #0x10
; 			cb->handler(port, cb, cb->pin_mask & pins);
 8014322: 697b         	ldr	r3, [r7, #0x14]
 8014324: 685b         	ldr	r3, [r3, #0x4]
 8014326: 697a         	ldr	r2, [r7, #0x14]
 8014328: 6891         	ldr	r1, [r2, #0x8]
 801432a: 687a         	ldr	r2, [r7, #0x4]
 801432c: 400a         	ands	r2, r1
 801432e: 6979         	ldr	r1, [r7, #0x14]
 8014330: 68b8         	ldr	r0, [r7, #0x8]
 8014332: 4798         	blx	r3
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 8014334: 693b         	ldr	r3, [r7, #0x10]
 8014336: 617b         	str	r3, [r7, #0x14]
 8014338: 697b         	ldr	r3, [r7, #0x14]
 801433a: 2b00         	cmp	r3, #0x0
 801433c: d00e         	beq	0x801435c <gpio_fire_callbacks+0x96> @ imm = #0x1c
 801433e: 697b         	ldr	r3, [r7, #0x14]
 8014340: 4618         	mov	r0, r3
 8014342: f7ff fd1c    	bl	0x8013d7e <sys_slist_peek_next> @ imm = #-0x5c8
 8014346: 4603         	mov	r3, r0
 8014348: 2b00         	cmp	r3, #0x0
 801434a: d005         	beq	0x8014358 <gpio_fire_callbacks+0x92> @ imm = #0xa
 801434c: 697b         	ldr	r3, [r7, #0x14]
 801434e: 4618         	mov	r0, r3
 8014350: f7ff fd15    	bl	0x8013d7e <sys_slist_peek_next> @ imm = #-0x5d6
 8014354: 4603         	mov	r3, r0
 8014356: e002         	b	0x801435e <gpio_fire_callbacks+0x98> @ imm = #0x4
 8014358: 2300         	movs	r3, #0x0
 801435a: e000         	b	0x801435e <gpio_fire_callbacks+0x98> @ imm = #0x0
 801435c: 2300         	movs	r3, #0x0
 801435e: 613b         	str	r3, [r7, #0x10]
 8014360: 697b         	ldr	r3, [r7, #0x14]
 8014362: 2b00         	cmp	r3, #0x0
 8014364: d1d7         	bne	0x8014316 <gpio_fire_callbacks+0x50> @ imm = #-0x52
; }
 8014366: bf00         	nop
 8014368: bf00         	nop
 801436a: 3718         	adds	r7, #0x18
 801436c: 46bd         	mov	sp, r7
 801436e: bd80         	pop	{r7, pc}

08014370 <gpio_stm32_isr>:
; {
 8014370: b580         	push	{r7, lr}
 8014372: b084         	sub	sp, #0x10
 8014374: af00         	add	r7, sp, #0x0
 8014376: 6078         	str	r0, [r7, #0x4]
 8014378: 6039         	str	r1, [r7]
; 	struct gpio_stm32_data *data = arg;
 801437a: 683b         	ldr	r3, [r7]
 801437c: 60fb         	str	r3, [r7, #0xc]
; 	gpio_fire_callbacks(&data->cb, data->dev, pin);
 801437e: 68fb         	ldr	r3, [r7, #0xc]
 8014380: f103 0008    	add.w	r0, r3, #0x8
 8014384: 68fb         	ldr	r3, [r7, #0xc]
 8014386: 685b         	ldr	r3, [r3, #0x4]
 8014388: 687a         	ldr	r2, [r7, #0x4]
 801438a: 4619         	mov	r1, r3
 801438c: f7ff ff9b    	bl	0x80142c6 <gpio_fire_callbacks> @ imm = #-0xca
; }
 8014390: bf00         	nop
 8014392: 3710         	adds	r7, #0x10
 8014394: 46bd         	mov	sp, r7
 8014396: bd80         	pop	{r7, pc}

08014398 <gpio_stm32_flags_to_conf>:
; {
 8014398: b480         	push	{r7}
 801439a: b083         	sub	sp, #0xc
 801439c: af00         	add	r7, sp, #0x0
 801439e: 6078         	str	r0, [r7, #0x4]
 80143a0: 6039         	str	r1, [r7]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 80143a2: 687b         	ldr	r3, [r7, #0x4]
 80143a4: f403 3300    	and	r3, r3, #0x20000
 80143a8: 2b00         	cmp	r3, #0x0
 80143aa: d032         	beq	0x8014412 <gpio_stm32_flags_to_conf+0x7a> @ imm = #0x64
; 		*pincfg = STM32_PINCFG_MODE_OUTPUT;
 80143ac: 683b         	ldr	r3, [r7]
 80143ae: 2210         	movs	r2, #0x10
 80143b0: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_SINGLE_ENDED) != 0) {
 80143b2: 687b         	ldr	r3, [r7, #0x4]
 80143b4: f003 0302    	and	r3, r3, #0x2
 80143b8: 2b00         	cmp	r3, #0x0
 80143ba: d00e         	beq	0x80143da <gpio_stm32_flags_to_conf+0x42> @ imm = #0x1c
; 			if (flags & GPIO_LINE_OPEN_DRAIN) {
 80143bc: 687b         	ldr	r3, [r7, #0x4]
 80143be: f003 0304    	and	r3, r3, #0x4
 80143c2: 2b00         	cmp	r3, #0x0
 80143c4: d006         	beq	0x80143d4 <gpio_stm32_flags_to_conf+0x3c> @ imm = #0xc
; 				*pincfg |= STM32_PINCFG_OPEN_DRAIN;
 80143c6: 683b         	ldr	r3, [r7]
 80143c8: 681b         	ldr	r3, [r3]
 80143ca: f043 0240    	orr	r2, r3, #0x40
 80143ce: 683b         	ldr	r3, [r7]
 80143d0: 601a         	str	r2, [r3]
 80143d2: e006         	b	0x80143e2 <gpio_stm32_flags_to_conf+0x4a> @ imm = #0xc
; 				return -ENOTSUP;
 80143d4: f06f 0385    	mvn	r3, #0x85
 80143d8: e044         	b	0x8014464 <gpio_stm32_flags_to_conf+0xcc> @ imm = #0x88
; 			*pincfg |= STM32_PINCFG_PUSH_PULL;
 80143da: 683b         	ldr	r3, [r7]
 80143dc: 681a         	ldr	r2, [r3]
 80143de: 683b         	ldr	r3, [r7]
 80143e0: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 80143e2: 687b         	ldr	r3, [r7, #0x4]
 80143e4: f003 0310    	and	r3, r3, #0x10
 80143e8: 2b00         	cmp	r3, #0x0
 80143ea: d006         	beq	0x80143fa <gpio_stm32_flags_to_conf+0x62> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 80143ec: 683b         	ldr	r3, [r7]
 80143ee: 681b         	ldr	r3, [r3]
 80143f0: f443 7200    	orr	r2, r3, #0x200
 80143f4: 683b         	ldr	r3, [r7]
 80143f6: 601a         	str	r2, [r3]
 80143f8: e033         	b	0x8014462 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x66
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 80143fa: 687b         	ldr	r3, [r7, #0x4]
 80143fc: f003 0320    	and	r3, r3, #0x20
 8014400: 2b00         	cmp	r3, #0x0
 8014402: d02e         	beq	0x8014462 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x5c
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 8014404: 683b         	ldr	r3, [r7]
 8014406: 681b         	ldr	r3, [r3]
 8014408: f443 6280    	orr	r2, r3, #0x400
 801440c: 683b         	ldr	r3, [r7]
 801440e: 601a         	str	r2, [r3]
 8014410: e027         	b	0x8014462 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4e
; 	} else if  ((flags & GPIO_INPUT) != 0) {
 8014412: 687b         	ldr	r3, [r7, #0x4]
 8014414: f403 3380    	and	r3, r3, #0x10000
 8014418: 2b00         	cmp	r3, #0x0
 801441a: d01f         	beq	0x801445c <gpio_stm32_flags_to_conf+0xc4> @ imm = #0x3e
; 		*pincfg = STM32_PINCFG_MODE_INPUT;
 801441c: 683b         	ldr	r3, [r7]
 801441e: 2200         	movs	r2, #0x0
 8014420: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 8014422: 687b         	ldr	r3, [r7, #0x4]
 8014424: f003 0310    	and	r3, r3, #0x10
 8014428: 2b00         	cmp	r3, #0x0
 801442a: d006         	beq	0x801443a <gpio_stm32_flags_to_conf+0xa2> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 801442c: 683b         	ldr	r3, [r7]
 801442e: 681b         	ldr	r3, [r3]
 8014430: f443 7200    	orr	r2, r3, #0x200
 8014434: 683b         	ldr	r3, [r7]
 8014436: 601a         	str	r2, [r3]
 8014438: e013         	b	0x8014462 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x26
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 801443a: 687b         	ldr	r3, [r7, #0x4]
 801443c: f003 0320    	and	r3, r3, #0x20
 8014440: 2b00         	cmp	r3, #0x0
 8014442: d006         	beq	0x8014452 <gpio_stm32_flags_to_conf+0xba> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 8014444: 683b         	ldr	r3, [r7]
 8014446: 681b         	ldr	r3, [r3]
 8014448: f443 6280    	orr	r2, r3, #0x400
 801444c: 683b         	ldr	r3, [r7]
 801444e: 601a         	str	r2, [r3]
 8014450: e007         	b	0x8014462 <gpio_stm32_flags_to_conf+0xca> @ imm = #0xe
; 			*pincfg |= STM32_PINCFG_FLOATING;
 8014452: 683b         	ldr	r3, [r7]
 8014454: 681a         	ldr	r2, [r3]
 8014456: 683b         	ldr	r3, [r7]
 8014458: 601a         	str	r2, [r3]
 801445a: e002         	b	0x8014462 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4
; 		*pincfg = STM32_PINCFG_MODE_ANALOG;
 801445c: 683b         	ldr	r3, [r7]
 801445e: 2230         	movs	r2, #0x30
 8014460: 601a         	str	r2, [r3]
; 	return 0;
 8014462: 2300         	movs	r3, #0x0
; }
 8014464: 4618         	mov	r0, r3
 8014466: 370c         	adds	r7, #0xc
 8014468: 46bd         	mov	sp, r7
 801446a: bc80         	pop	{r7}
 801446c: 4770         	bx	lr

0801446e <stm32_pinval_get>:
; {
 801446e: b480         	push	{r7}
 8014470: b085         	sub	sp, #0x14
 8014472: af00         	add	r7, sp, #0x0
 8014474: 4603         	mov	r3, r0
 8014476: 71fb         	strb	r3, [r7, #0x7]
; 	pinval = 1 << pin;
 8014478: 79fb         	ldrb	r3, [r7, #0x7]
 801447a: 2201         	movs	r2, #0x1
 801447c: fa02 f303    	lsl.w	r3, r2, r3
 8014480: 60fb         	str	r3, [r7, #0xc]
; 	return pinval;
 8014482: 68fb         	ldr	r3, [r7, #0xc]
; }
 8014484: 4618         	mov	r0, r3
 8014486: 3714         	adds	r7, #0x14
 8014488: 46bd         	mov	sp, r7
 801448a: bc80         	pop	{r7}
 801448c: 4770         	bx	lr

0801448e <ll_gpio_set_pin_pull>:
; {
 801448e: b580         	push	{r7, lr}
 8014490: b084         	sub	sp, #0x10
 8014492: af00         	add	r7, sp, #0x0
 8014494: 60f8         	str	r0, [r7, #0xc]
 8014496: 60b9         	str	r1, [r7, #0x8]
 8014498: 607a         	str	r2, [r7, #0x4]
; 	LL_GPIO_SetPinPull(GPIOx, Pin, Pull);
 801449a: 687a         	ldr	r2, [r7, #0x4]
 801449c: 68b9         	ldr	r1, [r7, #0x8]
 801449e: 68f8         	ldr	r0, [r7, #0xc]
 80144a0: f7ff fd9b    	bl	0x8013fda <LL_GPIO_SetPinPull> @ imm = #-0x4ca
; }
 80144a4: bf00         	nop
 80144a6: 3710         	adds	r7, #0x10
 80144a8: 46bd         	mov	sp, r7
 80144aa: bd80         	pop	{r7, pc}

080144ac <gpio_stm32_disable_pin_irqs>:
; {
 80144ac: b580         	push	{r7, lr}
 80144ae: b084         	sub	sp, #0x10
 80144b0: af00         	add	r7, sp, #0x0
 80144b2: 6078         	str	r0, [r7, #0x4]
 80144b4: 460b         	mov	r3, r1
 80144b6: 70fb         	strb	r3, [r7, #0x3]
; 	if (port != stm32_exti_get_line_src_port(pin)) {
 80144b8: 78fb         	ldrb	r3, [r7, #0x3]
 80144ba: 4618         	mov	r0, r3
 80144bc: f7fd fc51    	bl	0x8011d62 <stm32_exti_get_line_src_port> @ imm = #-0x275e
 80144c0: 4602         	mov	r2, r0
 80144c2: 687b         	ldr	r3, [r7, #0x4]
 80144c4: 4293         	cmp	r3, r2
 80144c6: d110         	bne	0x80144ea <gpio_stm32_disable_pin_irqs+0x3e> @ imm = #0x20
; 	stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(port, pin);
 80144c8: 78fb         	ldrb	r3, [r7, #0x3]
 80144ca: 4619         	mov	r1, r3
 80144cc: 6878         	ldr	r0, [r7, #0x4]
 80144ce: f7fd fc13    	bl	0x8011cf8 <stm32_gpio_intc_get_pin_irq_line> @ imm = #-0x27da
 80144d2: 60f8         	str	r0, [r7, #0xc]
; 	stm32_gpio_intc_disable_line(irq_line);
 80144d4: 68f8         	ldr	r0, [r7, #0xc]
 80144d6: f7fd fc1e    	bl	0x8011d16 <stm32_gpio_intc_disable_line> @ imm = #-0x27c4
; 	stm32_gpio_intc_remove_irq_callback(irq_line);
 80144da: 68f8         	ldr	r0, [r7, #0xc]
 80144dc: f7ef fea2    	bl	0x8004224 <stm32_gpio_intc_remove_irq_callback> @ imm = #-0x102bc
; 	stm32_gpio_intc_select_line_trigger(irq_line, STM32_GPIO_IRQ_TRIG_NONE);
 80144e0: 2100         	movs	r1, #0x0
 80144e2: 68f8         	ldr	r0, [r7, #0xc]
 80144e4: f7ef fe26    	bl	0x8004134 <stm32_gpio_intc_select_line_trigger> @ imm = #-0x103b4
 80144e8: e000         	b	0x80144ec <gpio_stm32_disable_pin_irqs+0x40> @ imm = #0x0
; 		return;
 80144ea: bf00         	nop
; }
 80144ec: 3710         	adds	r7, #0x10
 80144ee: 46bd         	mov	sp, r7
 80144f0: bd80         	pop	{r7, pc}

080144f2 <gpio_stm32_configure_raw>:
; {
 80144f2: b580         	push	{r7, lr}
 80144f4: b08c         	sub	sp, #0x30
 80144f6: af00         	add	r7, sp, #0x0
 80144f8: 60f8         	str	r0, [r7, #0xc]
 80144fa: 607a         	str	r2, [r7, #0x4]
 80144fc: 603b         	str	r3, [r7]
 80144fe: 460b         	mov	r3, r1
 8014500: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8014502: 68fb         	ldr	r3, [r7, #0xc]
 8014504: 685b         	ldr	r3, [r3, #0x4]
 8014506: 62fb         	str	r3, [r7, #0x2c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8014508: 6afb         	ldr	r3, [r7, #0x2c]
 801450a: 685b         	ldr	r3, [r3, #0x4]
 801450c: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pin_ll = stm32_pinval_get(pin);
 801450e: 7afb         	ldrb	r3, [r7, #0xb]
 8014510: 4618         	mov	r0, r3
 8014512: f7ff ffac    	bl	0x801446e <stm32_pinval_get> @ imm = #-0xa8
 8014516: 6278         	str	r0, [r7, #0x24]
; 	mode = conf & (STM32_MODER_MASK << STM32_MODER_SHIFT);
 8014518: 687b         	ldr	r3, [r7, #0x4]
 801451a: f003 0330    	and	r3, r3, #0x30
 801451e: 623b         	str	r3, [r7, #0x20]
; 	otype = conf & (STM32_OTYPER_MASK << STM32_OTYPER_SHIFT);
 8014520: 687b         	ldr	r3, [r7, #0x4]
 8014522: f003 0340    	and	r3, r3, #0x40
 8014526: 61fb         	str	r3, [r7, #0x1c]
; 	ospeed = conf & (STM32_OSPEEDR_MASK << STM32_OSPEEDR_SHIFT);
 8014528: 687b         	ldr	r3, [r7, #0x4]
 801452a: f403 73c0    	and	r3, r3, #0x180
 801452e: 61bb         	str	r3, [r7, #0x18]
; 	pupd = conf & (STM32_PUPDR_MASK << STM32_PUPDR_SHIFT);
 8014530: 687b         	ldr	r3, [r7, #0x4]
 8014532: f403 63c0    	and	r3, r3, #0x600
 8014536: 617b         	str	r3, [r7, #0x14]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8014538: f44f 1180    	mov.w	r1, #0x100000
 801453c: 2000         	movs	r0, #0x0
 801453e: f7ff fe75    	bl	0x801422c <z_stm32_hsem_lock> @ imm = #-0x316
; 	LL_GPIO_SetPinOutputType(gpio, pin_ll, otype >> STM32_OTYPER_SHIFT);
 8014542: 69fb         	ldr	r3, [r7, #0x1c]
 8014544: 099b         	lsrs	r3, r3, #0x6
 8014546: 461a         	mov	r2, r3
 8014548: 6a79         	ldr	r1, [r7, #0x24]
 801454a: 6ab8         	ldr	r0, [r7, #0x28]
 801454c: f7ff fcf2    	bl	0x8013f34 <LL_GPIO_SetPinOutputType> @ imm = #-0x61c
; 	LL_GPIO_SetPinSpeed(gpio, pin_ll, ospeed >> STM32_OSPEEDR_SHIFT);
 8014550: 69bb         	ldr	r3, [r7, #0x18]
 8014552: 09db         	lsrs	r3, r3, #0x7
 8014554: 461a         	mov	r2, r3
 8014556: 6a79         	ldr	r1, [r7, #0x24]
 8014558: 6ab8         	ldr	r0, [r7, #0x28]
 801455a: f7ff fd02    	bl	0x8013f62 <LL_GPIO_SetPinSpeed> @ imm = #-0x5fc
; 	ll_gpio_set_pin_pull(gpio, pin_ll, pupd >> STM32_PUPDR_SHIFT);
 801455e: 697b         	ldr	r3, [r7, #0x14]
 8014560: 0a5b         	lsrs	r3, r3, #0x9
 8014562: 461a         	mov	r2, r3
 8014564: 6a79         	ldr	r1, [r7, #0x24]
 8014566: 6ab8         	ldr	r0, [r7, #0x28]
 8014568: f7ff ff91    	bl	0x801448e <ll_gpio_set_pin_pull> @ imm = #-0xde
; 	if (mode == STM32_MODER_ALT_MODE) {
 801456c: 6a3b         	ldr	r3, [r7, #0x20]
 801456e: 2b20         	cmp	r3, #0x20
 8014570: d10d         	bne	0x801458e <gpio_stm32_configure_raw+0x9c> @ imm = #0x1a
; 		if (pin < 8) {
 8014572: 7afb         	ldrb	r3, [r7, #0xb]
 8014574: 2b07         	cmp	r3, #0x7
 8014576: d805         	bhi	0x8014584 <gpio_stm32_configure_raw+0x92> @ imm = #0xa
; 			LL_GPIO_SetAFPin_0_7(gpio, pin_ll, func);
 8014578: 683a         	ldr	r2, [r7]
 801457a: 6a79         	ldr	r1, [r7, #0x24]
 801457c: 6ab8         	ldr	r0, [r7, #0x28]
 801457e: f7ff fd68    	bl	0x8014052 <LL_GPIO_SetAFPin_0_7> @ imm = #-0x530
 8014582: e004         	b	0x801458e <gpio_stm32_configure_raw+0x9c> @ imm = #0x8
; 			LL_GPIO_SetAFPin_8_15(gpio, pin_ll, func);
 8014584: 683a         	ldr	r2, [r7]
 8014586: 6a79         	ldr	r1, [r7, #0x24]
 8014588: 6ab8         	ldr	r0, [r7, #0x28]
 801458a: f7ff fd9e    	bl	0x80140ca <LL_GPIO_SetAFPin_8_15> @ imm = #-0x4c4
; 	LL_GPIO_SetPinMode(gpio, pin_ll, mode >> STM32_MODER_SHIFT);
 801458e: 6a3b         	ldr	r3, [r7, #0x20]
 8014590: 091b         	lsrs	r3, r3, #0x4
 8014592: 461a         	mov	r2, r3
 8014594: 6a79         	ldr	r1, [r7, #0x24]
 8014596: 6ab8         	ldr	r0, [r7, #0x28]
 8014598: f7ff fc90    	bl	0x8013ebc <LL_GPIO_SetPinMode> @ imm = #-0x6e0
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 801459c: 2000         	movs	r0, #0x0
 801459e: f7ff fe4f    	bl	0x8014240 <z_stm32_hsem_unlock> @ imm = #-0x362
; }
 80145a2: bf00         	nop
 80145a4: 3730         	adds	r7, #0x30
 80145a6: 46bd         	mov	sp, r7
 80145a8: bd80         	pop	{r7, pc}

080145aa <gpio_stm32_port_get_raw>:
; {
 80145aa: b580         	push	{r7, lr}
 80145ac: b084         	sub	sp, #0x10
 80145ae: af00         	add	r7, sp, #0x0
 80145b0: 6078         	str	r0, [r7, #0x4]
 80145b2: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 80145b4: 687b         	ldr	r3, [r7, #0x4]
 80145b6: 685b         	ldr	r3, [r3, #0x4]
 80145b8: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 80145ba: 68fb         	ldr	r3, [r7, #0xc]
 80145bc: 685b         	ldr	r3, [r3, #0x4]
 80145be: 60bb         	str	r3, [r7, #0x8]
; 	*value = LL_GPIO_ReadInputPort(gpio);
 80145c0: 68b8         	ldr	r0, [r7, #0x8]
 80145c2: f7ff fdc0    	bl	0x8014146 <LL_GPIO_ReadInputPort> @ imm = #-0x480
 80145c6: 4602         	mov	r2, r0
 80145c8: 683b         	ldr	r3, [r7]
 80145ca: 601a         	str	r2, [r3]
; 	return 0;
 80145cc: 2300         	movs	r3, #0x0
; }
 80145ce: 4618         	mov	r0, r3
 80145d0: 3710         	adds	r7, #0x10
 80145d2: 46bd         	mov	sp, r7
 80145d4: bd80         	pop	{r7, pc}

080145d6 <gpio_stm32_port_set_masked_raw>:
; {
 80145d6: b580         	push	{r7, lr}
 80145d8: b088         	sub	sp, #0x20
 80145da: af00         	add	r7, sp, #0x0
 80145dc: 60f8         	str	r0, [r7, #0xc]
 80145de: 60b9         	str	r1, [r7, #0x8]
 80145e0: 607a         	str	r2, [r7, #0x4]
; 	const struct gpio_stm32_config *cfg = dev->config;
 80145e2: 68fb         	ldr	r3, [r7, #0xc]
 80145e4: 685b         	ldr	r3, [r3, #0x4]
 80145e6: 61fb         	str	r3, [r7, #0x1c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 80145e8: 69fb         	ldr	r3, [r7, #0x1c]
 80145ea: 685b         	ldr	r3, [r3, #0x4]
 80145ec: 61bb         	str	r3, [r7, #0x18]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 80145ee: f44f 1180    	mov.w	r1, #0x100000
 80145f2: 2000         	movs	r0, #0x0
 80145f4: f7ff fe1a    	bl	0x801422c <z_stm32_hsem_lock> @ imm = #-0x3cc
; 	port_value = LL_GPIO_ReadOutputPort(gpio);
 80145f8: 69b8         	ldr	r0, [r7, #0x18]
 80145fa: f7ff fdbc    	bl	0x8014176 <LL_GPIO_ReadOutputPort> @ imm = #-0x488
 80145fe: 6178         	str	r0, [r7, #0x14]
; 	LL_GPIO_WriteOutputPort(gpio, (port_value & ~mask) | (mask & value));
 8014600: 68bb         	ldr	r3, [r7, #0x8]
 8014602: 43da         	mvns	r2, r3
 8014604: 697b         	ldr	r3, [r7, #0x14]
 8014606: 401a         	ands	r2, r3
 8014608: 68b9         	ldr	r1, [r7, #0x8]
 801460a: 687b         	ldr	r3, [r7, #0x4]
 801460c: 400b         	ands	r3, r1
 801460e: 4313         	orrs	r3, r2
 8014610: 4619         	mov	r1, r3
 8014612: 69b8         	ldr	r0, [r7, #0x18]
 8014614: f7ff fda2    	bl	0x801415c <LL_GPIO_WriteOutputPort> @ imm = #-0x4bc
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 8014618: 2000         	movs	r0, #0x0
 801461a: f7ff fe11    	bl	0x8014240 <z_stm32_hsem_unlock> @ imm = #-0x3de
; 	return 0;
 801461e: 2300         	movs	r3, #0x0
; }
 8014620: 4618         	mov	r0, r3
 8014622: 3720         	adds	r7, #0x20
 8014624: 46bd         	mov	sp, r7
 8014626: bd80         	pop	{r7, pc}

08014628 <gpio_stm32_port_set_bits_raw>:
; {
 8014628: b480         	push	{r7}
 801462a: b085         	sub	sp, #0x14
 801462c: af00         	add	r7, sp, #0x0
 801462e: 6078         	str	r0, [r7, #0x4]
 8014630: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8014632: 687b         	ldr	r3, [r7, #0x4]
 8014634: 685b         	ldr	r3, [r3, #0x4]
 8014636: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8014638: 68fb         	ldr	r3, [r7, #0xc]
 801463a: 685b         	ldr	r3, [r3, #0x4]
 801463c: 60bb         	str	r3, [r7, #0x8]
; 	WRITE_REG(gpio->BSRR, pins);
 801463e: 68bb         	ldr	r3, [r7, #0x8]
 8014640: 683a         	ldr	r2, [r7]
 8014642: 619a         	str	r2, [r3, #0x18]
; 	return 0;
 8014644: 2300         	movs	r3, #0x0
; }
 8014646: 4618         	mov	r0, r3
 8014648: 3714         	adds	r7, #0x14
 801464a: 46bd         	mov	sp, r7
 801464c: bc80         	pop	{r7}
 801464e: 4770         	bx	lr

08014650 <gpio_stm32_port_clear_bits_raw>:
; {
 8014650: b580         	push	{r7, lr}
 8014652: b084         	sub	sp, #0x10
 8014654: af00         	add	r7, sp, #0x0
 8014656: 6078         	str	r0, [r7, #0x4]
 8014658: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 801465a: 687b         	ldr	r3, [r7, #0x4]
 801465c: 685b         	ldr	r3, [r3, #0x4]
 801465e: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8014660: 68fb         	ldr	r3, [r7, #0xc]
 8014662: 685b         	ldr	r3, [r3, #0x4]
 8014664: 60bb         	str	r3, [r7, #0x8]
; 	LL_GPIO_ResetOutputPin(gpio, pins);
 8014666: 6839         	ldr	r1, [r7]
 8014668: 68b8         	ldr	r0, [r7, #0x8]
 801466a: f7ff fd8f    	bl	0x801418c <LL_GPIO_ResetOutputPin> @ imm = #-0x4e2
; 	return 0;
 801466e: 2300         	movs	r3, #0x0
; }
 8014670: 4618         	mov	r0, r3
 8014672: 3710         	adds	r7, #0x10
 8014674: 46bd         	mov	sp, r7
 8014676: bd80         	pop	{r7, pc}

08014678 <gpio_stm32_port_toggle_bits>:
; {
 8014678: b580         	push	{r7, lr}
 801467a: b084         	sub	sp, #0x10
 801467c: af00         	add	r7, sp, #0x0
 801467e: 6078         	str	r0, [r7, #0x4]
 8014680: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8014682: 687b         	ldr	r3, [r7, #0x4]
 8014684: 685b         	ldr	r3, [r3, #0x4]
 8014686: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8014688: 68fb         	ldr	r3, [r7, #0xc]
 801468a: 685b         	ldr	r3, [r3, #0x4]
 801468c: 60bb         	str	r3, [r7, #0x8]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 801468e: f44f 1180    	mov.w	r1, #0x100000
 8014692: 2000         	movs	r0, #0x0
 8014694: f7ff fdca    	bl	0x801422c <z_stm32_hsem_lock> @ imm = #-0x46c
; 	WRITE_REG(gpio->ODR, READ_REG(gpio->ODR) ^ pins);
 8014698: 68bb         	ldr	r3, [r7, #0x8]
 801469a: 695a         	ldr	r2, [r3, #0x14]
 801469c: 683b         	ldr	r3, [r7]
 801469e: 405a         	eors	r2, r3
 80146a0: 68bb         	ldr	r3, [r7, #0x8]
 80146a2: 615a         	str	r2, [r3, #0x14]
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 80146a4: 2000         	movs	r0, #0x0
 80146a6: f7ff fdcb    	bl	0x8014240 <z_stm32_hsem_unlock> @ imm = #-0x46a
; 	return 0;
 80146aa: 2300         	movs	r3, #0x0
; }
 80146ac: 4618         	mov	r0, r3
 80146ae: 3710         	adds	r7, #0x10
 80146b0: 46bd         	mov	sp, r7
 80146b2: bd80         	pop	{r7, pc}

080146b4 <gpio_stm32_configure>:
; {
 80146b4: b580         	push	{r7, lr}
 80146b6: b086         	sub	sp, #0x18
 80146b8: af00         	add	r7, sp, #0x0
 80146ba: 60f8         	str	r0, [r7, #0xc]
 80146bc: 607a         	str	r2, [r7, #0x4]
 80146be: 603b         	str	r3, [r7]
 80146c0: 460b         	mov	r3, r1
 80146c2: 72fb         	strb	r3, [r7, #0xb]
; 	ret = pm_device_runtime_get(dev);
 80146c4: 68f8         	ldr	r0, [r7, #0xc]
 80146c6: f7ff fd9d    	bl	0x8014204 <pm_device_runtime_get> @ imm = #-0x4c6
 80146ca: 6178         	str	r0, [r7, #0x14]
; 	if (ret < 0) {
 80146cc: 697b         	ldr	r3, [r7, #0x14]
 80146ce: 2b00         	cmp	r3, #0x0
 80146d0: da01         	bge	0x80146d6 <gpio_stm32_configure+0x22> @ imm = #0x2
; 		return ret;
 80146d2: 697b         	ldr	r3, [r7, #0x14]
 80146d4: e028         	b	0x8014728 <gpio_stm32_configure+0x74> @ imm = #0x50
; 	gpio_stm32_configure_raw(dev, pin, conf, func);
 80146d6: 7af9         	ldrb	r1, [r7, #0xb]
 80146d8: 683b         	ldr	r3, [r7]
 80146da: 687a         	ldr	r2, [r7, #0x4]
 80146dc: 68f8         	ldr	r0, [r7, #0xc]
 80146de: f7ff ff08    	bl	0x80144f2 <gpio_stm32_configure_raw> @ imm = #-0x1f0
; 	if (func == IS_GPIO_OUT) {
 80146e2: 683b         	ldr	r3, [r7]
 80146e4: 2b11         	cmp	r3, #0x11
 80146e6: d11b         	bne	0x8014720 <gpio_stm32_configure+0x6c> @ imm = #0x36
; 		uint32_t gpio_out = conf & (STM32_ODR_MASK << STM32_ODR_SHIFT);
 80146e8: 687b         	ldr	r3, [r7, #0x4]
 80146ea: f403 6300    	and	r3, r3, #0x800
 80146ee: 613b         	str	r3, [r7, #0x10]
; 		if (gpio_out == STM32_ODR_1) {
 80146f0: 693b         	ldr	r3, [r7, #0x10]
 80146f2: f5b3 6f00    	cmp.w	r3, #0x800
 80146f6: d108         	bne	0x801470a <gpio_stm32_configure+0x56> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 80146f8: 7afb         	ldrb	r3, [r7, #0xb]
 80146fa: 2201         	movs	r2, #0x1
 80146fc: fa02 f303    	lsl.w	r3, r2, r3
 8014700: 4619         	mov	r1, r3
 8014702: 68f8         	ldr	r0, [r7, #0xc]
 8014704: f7ff ff90    	bl	0x8014628 <gpio_stm32_port_set_bits_raw> @ imm = #-0xe0
 8014708: e00a         	b	0x8014720 <gpio_stm32_configure+0x6c> @ imm = #0x14
; 		} else if (gpio_out == STM32_ODR_0) {
 801470a: 693b         	ldr	r3, [r7, #0x10]
 801470c: 2b00         	cmp	r3, #0x0
 801470e: d107         	bne	0x8014720 <gpio_stm32_configure+0x6c> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 8014710: 7afb         	ldrb	r3, [r7, #0xb]
 8014712: 2201         	movs	r2, #0x1
 8014714: fa02 f303    	lsl.w	r3, r2, r3
 8014718: 4619         	mov	r1, r3
 801471a: 68f8         	ldr	r0, [r7, #0xc]
 801471c: f7ff ff98    	bl	0x8014650 <gpio_stm32_port_clear_bits_raw> @ imm = #-0xd0
; 	return pm_device_runtime_put(dev);
 8014720: 68f8         	ldr	r0, [r7, #0xc]
 8014722: f7ff fd79    	bl	0x8014218 <pm_device_runtime_put> @ imm = #-0x50e
 8014726: 4603         	mov	r3, r0
; }
 8014728: 4618         	mov	r0, r3
 801472a: 3718         	adds	r7, #0x18
 801472c: 46bd         	mov	sp, r7
 801472e: bd80         	pop	{r7, pc}

08014730 <gpio_stm32_config>:
; {
 8014730: b580         	push	{r7, lr}
 8014732: b088         	sub	sp, #0x20
 8014734: af00         	add	r7, sp, #0x0
 8014736: 60f8         	str	r0, [r7, #0xc]
 8014738: 460b         	mov	r3, r1
 801473a: 607a         	str	r2, [r7, #0x4]
 801473c: 72fb         	strb	r3, [r7, #0xb]
; 	struct gpio_stm32_data *data = dev->data;
 801473e: 68fb         	ldr	r3, [r7, #0xc]
 8014740: 691b         	ldr	r3, [r3, #0x10]
 8014742: 61fb         	str	r3, [r7, #0x1c]
; 	err = gpio_stm32_flags_to_conf(flags, &pincfg);
 8014744: f107 0314    	add.w	r3, r7, #0x14
 8014748: 4619         	mov	r1, r3
 801474a: 6878         	ldr	r0, [r7, #0x4]
 801474c: f7ff fe24    	bl	0x8014398 <gpio_stm32_flags_to_conf> @ imm = #-0x3b8
 8014750: 61b8         	str	r0, [r7, #0x18]
; 	if (err != 0) {
 8014752: 69bb         	ldr	r3, [r7, #0x18]
 8014754: 2b00         	cmp	r3, #0x0
 8014756: d001         	beq	0x801475c <gpio_stm32_config+0x2c> @ imm = #0x2
; 		return err;
 8014758: 69bb         	ldr	r3, [r7, #0x18]
 801475a: e071         	b	0x8014840 <gpio_stm32_config+0x110> @ imm = #0xe2
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 801475c: 687b         	ldr	r3, [r7, #0x4]
 801475e: f403 3300    	and	r3, r3, #0x20000
 8014762: 2b00         	cmp	r3, #0x0
 8014764: d104         	bne	0x8014770 <gpio_stm32_config+0x40> @ imm = #0x8
 8014766: 687b         	ldr	r3, [r7, #0x4]
 8014768: f403 3380    	and	r3, r3, #0x10000
 801476c: 2b00         	cmp	r3, #0x0
 801476e: d01a         	beq	0x80147a6 <gpio_stm32_config+0x76> @ imm = #0x34
; 	    !(data->pin_has_clock_enabled & BIT(pin))) {
 8014770: 69fb         	ldr	r3, [r7, #0x1c]
 8014772: 691a         	ldr	r2, [r3, #0x10]
 8014774: 7afb         	ldrb	r3, [r7, #0xb]
 8014776: fa22 f303    	lsr.w	r3, r2, r3
 801477a: f003 0301    	and	r3, r3, #0x1
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 801477e: 2b00         	cmp	r3, #0x0
 8014780: d111         	bne	0x80147a6 <gpio_stm32_config+0x76> @ imm = #0x22
; 		err = pm_device_runtime_get(dev);
 8014782: 68f8         	ldr	r0, [r7, #0xc]
 8014784: f7ff fd3e    	bl	0x8014204 <pm_device_runtime_get> @ imm = #-0x584
 8014788: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 801478a: 69bb         	ldr	r3, [r7, #0x18]
 801478c: 2b00         	cmp	r3, #0x0
 801478e: da01         	bge	0x8014794 <gpio_stm32_config+0x64> @ imm = #0x2
; 			return err;
 8014790: 69bb         	ldr	r3, [r7, #0x18]
 8014792: e055         	b	0x8014840 <gpio_stm32_config+0x110> @ imm = #0xaa
; 		data->pin_has_clock_enabled |= BIT(pin);
 8014794: 69fb         	ldr	r3, [r7, #0x1c]
 8014796: 691a         	ldr	r2, [r3, #0x10]
 8014798: 7afb         	ldrb	r3, [r7, #0xb]
 801479a: 2101         	movs	r1, #0x1
 801479c: fa01 f303    	lsl.w	r3, r1, r3
 80147a0: 431a         	orrs	r2, r3
 80147a2: 69fb         	ldr	r3, [r7, #0x1c]
 80147a4: 611a         	str	r2, [r3, #0x10]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 80147a6: 687b         	ldr	r3, [r7, #0x4]
 80147a8: f403 3300    	and	r3, r3, #0x20000
 80147ac: 2b00         	cmp	r3, #0x0
 80147ae: d01a         	beq	0x80147e6 <gpio_stm32_config+0xb6> @ imm = #0x34
; 		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
 80147b0: 687b         	ldr	r3, [r7, #0x4]
 80147b2: f403 2300    	and	r3, r3, #0x80000
 80147b6: 2b00         	cmp	r3, #0x0
 80147b8: d008         	beq	0x80147cc <gpio_stm32_config+0x9c> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 80147ba: 7afb         	ldrb	r3, [r7, #0xb]
 80147bc: 2201         	movs	r2, #0x1
 80147be: fa02 f303    	lsl.w	r3, r2, r3
 80147c2: 4619         	mov	r1, r3
 80147c4: 68f8         	ldr	r0, [r7, #0xc]
 80147c6: f7ff ff2f    	bl	0x8014628 <gpio_stm32_port_set_bits_raw> @ imm = #-0x1a2
 80147ca: e00c         	b	0x80147e6 <gpio_stm32_config+0xb6> @ imm = #0x18
; 		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
 80147cc: 687b         	ldr	r3, [r7, #0x4]
 80147ce: f403 2380    	and	r3, r3, #0x40000
 80147d2: 2b00         	cmp	r3, #0x0
 80147d4: d007         	beq	0x80147e6 <gpio_stm32_config+0xb6> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 80147d6: 7afb         	ldrb	r3, [r7, #0xb]
 80147d8: 2201         	movs	r2, #0x1
 80147da: fa02 f303    	lsl.w	r3, r2, r3
 80147de: 4619         	mov	r1, r3
 80147e0: 68f8         	ldr	r0, [r7, #0xc]
 80147e2: f7ff ff35    	bl	0x8014650 <gpio_stm32_port_clear_bits_raw> @ imm = #-0x196
; 	gpio_stm32_configure_raw(dev, pin, pincfg, 0);
 80147e6: 697a         	ldr	r2, [r7, #0x14]
 80147e8: 7af9         	ldrb	r1, [r7, #0xb]
 80147ea: 2300         	movs	r3, #0x0
 80147ec: 68f8         	ldr	r0, [r7, #0xc]
 80147ee: f7ff fe80    	bl	0x80144f2 <gpio_stm32_configure_raw> @ imm = #-0x300
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 80147f2: 687b         	ldr	r3, [r7, #0x4]
 80147f4: f403 3300    	and	r3, r3, #0x20000
 80147f8: 2b00         	cmp	r3, #0x0
 80147fa: d120         	bne	0x801483e <gpio_stm32_config+0x10e> @ imm = #0x40
 80147fc: 687b         	ldr	r3, [r7, #0x4]
 80147fe: f403 3380    	and	r3, r3, #0x10000
 8014802: 2b00         	cmp	r3, #0x0
 8014804: d11b         	bne	0x801483e <gpio_stm32_config+0x10e> @ imm = #0x36
; 	    (data->pin_has_clock_enabled & BIT(pin))) {
 8014806: 69fb         	ldr	r3, [r7, #0x1c]
 8014808: 691a         	ldr	r2, [r3, #0x10]
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 801480a: 7afb         	ldrb	r3, [r7, #0xb]
 801480c: fa22 f303    	lsr.w	r3, r2, r3
 8014810: f003 0301    	and	r3, r3, #0x1
 8014814: 2b00         	cmp	r3, #0x0
 8014816: d012         	beq	0x801483e <gpio_stm32_config+0x10e> @ imm = #0x24
; 		err = pm_device_runtime_put(dev);
 8014818: 68f8         	ldr	r0, [r7, #0xc]
 801481a: f7ff fcfd    	bl	0x8014218 <pm_device_runtime_put> @ imm = #-0x606
 801481e: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 8014820: 69bb         	ldr	r3, [r7, #0x18]
 8014822: 2b00         	cmp	r3, #0x0
 8014824: da01         	bge	0x801482a <gpio_stm32_config+0xfa> @ imm = #0x2
; 			return err;
 8014826: 69bb         	ldr	r3, [r7, #0x18]
 8014828: e00a         	b	0x8014840 <gpio_stm32_config+0x110> @ imm = #0x14
; 		data->pin_has_clock_enabled &= ~BIT(pin);
 801482a: 69fb         	ldr	r3, [r7, #0x1c]
 801482c: 691a         	ldr	r2, [r3, #0x10]
 801482e: 7afb         	ldrb	r3, [r7, #0xb]
 8014830: 2101         	movs	r1, #0x1
 8014832: fa01 f303    	lsl.w	r3, r1, r3
 8014836: 43db         	mvns	r3, r3
 8014838: 401a         	ands	r2, r3
 801483a: 69fb         	ldr	r3, [r7, #0x1c]
 801483c: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 801483e: 2300         	movs	r3, #0x0
; }
 8014840: 4618         	mov	r0, r3
 8014842: 3720         	adds	r7, #0x20
 8014844: 46bd         	mov	sp, r7
 8014846: bd80         	pop	{r7, pc}

08014848 <gpio_stm32_manage_callback>:
; {
 8014848: b580         	push	{r7, lr}
 801484a: b086         	sub	sp, #0x18
 801484c: af00         	add	r7, sp, #0x0
 801484e: 60f8         	str	r0, [r7, #0xc]
 8014850: 60b9         	str	r1, [r7, #0x8]
 8014852: 4613         	mov	r3, r2
 8014854: 71fb         	strb	r3, [r7, #0x7]
; 	struct gpio_stm32_data *data = dev->data;
 8014856: 68fb         	ldr	r3, [r7, #0xc]
 8014858: 691b         	ldr	r3, [r3, #0x10]
 801485a: 617b         	str	r3, [r7, #0x14]
; 	return gpio_manage_callback(&data->cb, callback, set);
 801485c: 697b         	ldr	r3, [r7, #0x14]
 801485e: 3308         	adds	r3, #0x8
 8014860: 79fa         	ldrb	r2, [r7, #0x7]
 8014862: 68b9         	ldr	r1, [r7, #0x8]
 8014864: 4618         	mov	r0, r3
 8014866: f7ff fcf4    	bl	0x8014252 <gpio_manage_callback> @ imm = #-0x618
 801486a: 4603         	mov	r3, r0
; }
 801486c: 4618         	mov	r0, r3
 801486e: 3718         	adds	r7, #0x18
 8014870: 46bd         	mov	sp, r7
 8014872: bd80         	pop	{r7, pc}

08014874 <pinctrl_lookup_state>:
; {
 8014874: b480         	push	{r7}
 8014876: b085         	sub	sp, #0x14
 8014878: af00         	add	r7, sp, #0x0
 801487a: 60f8         	str	r0, [r7, #0xc]
 801487c: 460b         	mov	r3, r1
 801487e: 607a         	str	r2, [r7, #0x4]
 8014880: 72fb         	strb	r3, [r7, #0xb]
; 	*state = &config->states[0];
 8014882: 68fb         	ldr	r3, [r7, #0xc]
 8014884: 681a         	ldr	r2, [r3]
 8014886: 687b         	ldr	r3, [r7, #0x4]
 8014888: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 801488a: e00d         	b	0x80148a8 <pinctrl_lookup_state+0x34> @ imm = #0x1a
; 		if (id == (*state)->id) {
 801488c: 687b         	ldr	r3, [r7, #0x4]
 801488e: 681b         	ldr	r3, [r3]
 8014890: 795b         	ldrb	r3, [r3, #0x5]
 8014892: 7afa         	ldrb	r2, [r7, #0xb]
 8014894: 429a         	cmp	r2, r3
 8014896: d101         	bne	0x801489c <pinctrl_lookup_state+0x28> @ imm = #0x2
; 			return 0;
 8014898: 2300         	movs	r3, #0x0
 801489a: e011         	b	0x80148c0 <pinctrl_lookup_state+0x4c> @ imm = #0x22
; 		(*state)++;
 801489c: 687b         	ldr	r3, [r7, #0x4]
 801489e: 681b         	ldr	r3, [r3]
 80148a0: f103 0208    	add.w	r2, r3, #0x8
 80148a4: 687b         	ldr	r3, [r7, #0x4]
 80148a6: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 80148a8: 687b         	ldr	r3, [r7, #0x4]
 80148aa: 681a         	ldr	r2, [r3]
 80148ac: 68fb         	ldr	r3, [r7, #0xc]
 80148ae: 6819         	ldr	r1, [r3]
 80148b0: 68fb         	ldr	r3, [r7, #0xc]
 80148b2: 791b         	ldrb	r3, [r3, #0x4]
 80148b4: 00db         	lsls	r3, r3, #0x3
 80148b6: 440b         	add	r3, r1
 80148b8: 429a         	cmp	r2, r3
 80148ba: d3e7         	blo	0x801488c <pinctrl_lookup_state+0x18> @ imm = #-0x32
; 	return -ENOENT;
 80148bc: f06f 0301    	mvn	r3, #0x1
; }
 80148c0: 4618         	mov	r0, r3
 80148c2: 3714         	adds	r7, #0x14
 80148c4: 46bd         	mov	sp, r7
 80148c6: bc80         	pop	{r7}
 80148c8: 4770         	bx	lr

080148ca <device_is_ready>:
; {
 80148ca: b580         	push	{r7, lr}
 80148cc: b082         	sub	sp, #0x8
 80148ce: af00         	add	r7, sp, #0x0
 80148d0: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80148d2: 6878         	ldr	r0, [r7, #0x4]
 80148d4: f002 fa81    	bl	0x8016dda <z_impl_device_is_ready> @ imm = #0x2502
 80148d8: 4603         	mov	r3, r0
; }
 80148da: 4618         	mov	r0, r3
 80148dc: 3708         	adds	r7, #0x8
 80148de: 46bd         	mov	sp, r7
 80148e0: bd80         	pop	{r7, pc}

080148e2 <pinctrl_configure_pins>:
; {
 80148e2: b580         	push	{r7, lr}
 80148e4: b08a         	sub	sp, #0x28
 80148e6: af00         	add	r7, sp, #0x0
 80148e8: 60f8         	str	r0, [r7, #0xc]
 80148ea: 460b         	mov	r3, r1
 80148ec: 607a         	str	r2, [r7, #0x4]
 80148ee: 72fb         	strb	r3, [r7, #0xb]
; 	uint32_t pin_cgf = 0;
 80148f0: 2300         	movs	r3, #0x0
 80148f2: 627b         	str	r3, [r7, #0x24]
; 	int ret = 0;
 80148f4: 2300         	movs	r3, #0x0
 80148f6: 61fb         	str	r3, [r7, #0x1c]
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 80148f8: 2300         	movs	r3, #0x0
 80148fa: f887 3023    	strb.w	r3, [r7, #0x23]
 80148fe: e047         	b	0x8014990 <pinctrl_configure_pins+0xae> @ imm = #0x8e
; 		mux = pins[i].pinmux;
 8014900: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8014904: 00db         	lsls	r3, r3, #0x3
 8014906: 68fa         	ldr	r2, [r7, #0xc]
 8014908: 4413         	add	r3, r2
 801490a: 681b         	ldr	r3, [r3]
 801490c: 61bb         	str	r3, [r7, #0x18]
; 		if (STM32_DT_PINMUX_FUNC(mux) < STM32_ANALOG) {
 801490e: 69bb         	ldr	r3, [r7, #0x18]
 8014910: f003 0310    	and	r3, r3, #0x10
 8014914: 2b00         	cmp	r3, #0x0
 8014916: d109         	bne	0x801492c <pinctrl_configure_pins+0x4a> @ imm = #0x12
; 			pin_cgf = pins[i].pincfg | STM32_MODER_ALT_MODE;
 8014918: f897 3023    	ldrb.w	r3, [r7, #0x23]
 801491c: 00db         	lsls	r3, r3, #0x3
 801491e: 68fa         	ldr	r2, [r7, #0xc]
 8014920: 4413         	add	r3, r2
 8014922: 685b         	ldr	r3, [r3, #0x4]
 8014924: f043 0320    	orr	r3, r3, #0x20
 8014928: 627b         	str	r3, [r7, #0x24]
 801492a: e013         	b	0x8014954 <pinctrl_configure_pins+0x72> @ imm = #0x26
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_ANALOG) {
 801492c: 69bb         	ldr	r3, [r7, #0x18]
 801492e: f003 031f    	and	r3, r3, #0x1f
 8014932: 2b10         	cmp	r3, #0x10
 8014934: d102         	bne	0x801493c <pinctrl_configure_pins+0x5a> @ imm = #0x4
; 			pin_cgf = STM32_MODER_ANALOG_MODE;
 8014936: 2330         	movs	r3, #0x30
 8014938: 627b         	str	r3, [r7, #0x24]
 801493a: e00b         	b	0x8014954 <pinctrl_configure_pins+0x72> @ imm = #0x16
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_GPIO) {
 801493c: 69bb         	ldr	r3, [r7, #0x18]
 801493e: f003 031f    	and	r3, r3, #0x1f
 8014942: 2b11         	cmp	r3, #0x11
 8014944: d106         	bne	0x8014954 <pinctrl_configure_pins+0x72> @ imm = #0xc
; 			pin_cgf = pins[i].pincfg;
 8014946: f897 3023    	ldrb.w	r3, [r7, #0x23]
 801494a: 00db         	lsls	r3, r3, #0x3
 801494c: 68fa         	ldr	r2, [r7, #0xc]
 801494e: 4413         	add	r3, r2
 8014950: 685b         	ldr	r3, [r3, #0x4]
 8014952: 627b         	str	r3, [r7, #0x24]
; 		pin = STM32PIN(STM32_DT_PINMUX_PORT(mux),
 8014954: 69bb         	ldr	r3, [r7, #0x18]
 8014956: 0a5b         	lsrs	r3, r3, #0x9
 8014958: 011b         	lsls	r3, r3, #0x4
 801495a: f403 72f8    	and	r2, r3, #0x1f0
 801495e: 69bb         	ldr	r3, [r7, #0x18]
 8014960: 095b         	lsrs	r3, r3, #0x5
 8014962: f003 030f    	and	r3, r3, #0xf
 8014966: 4313         	orrs	r3, r2
 8014968: 617b         	str	r3, [r7, #0x14]
; 		ret = stm32_pin_configure(pin, pin_cgf, STM32_DT_PINMUX_FUNC(mux));
 801496a: 69bb         	ldr	r3, [r7, #0x18]
 801496c: f003 031f    	and	r3, r3, #0x1f
 8014970: 461a         	mov	r2, r3
 8014972: 6a79         	ldr	r1, [r7, #0x24]
 8014974: 6978         	ldr	r0, [r7, #0x14]
 8014976: f7f3 f941    	bl	0x8007bfc <stm32_pin_configure> @ imm = #-0xcd7e
 801497a: 61f8         	str	r0, [r7, #0x1c]
; 		if (ret < 0) {
 801497c: 69fb         	ldr	r3, [r7, #0x1c]
 801497e: 2b00         	cmp	r3, #0x0
 8014980: da01         	bge	0x8014986 <pinctrl_configure_pins+0xa4> @ imm = #0x2
; 			return ret;
 8014982: 69fb         	ldr	r3, [r7, #0x1c]
 8014984: e00a         	b	0x801499c <pinctrl_configure_pins+0xba> @ imm = #0x14
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 8014986: f897 3023    	ldrb.w	r3, [r7, #0x23]
 801498a: 3301         	adds	r3, #0x1
 801498c: f887 3023    	strb.w	r3, [r7, #0x23]
 8014990: f897 2023    	ldrb.w	r2, [r7, #0x23]
 8014994: 7afb         	ldrb	r3, [r7, #0xb]
 8014996: 429a         	cmp	r2, r3
 8014998: d3b2         	blo	0x8014900 <pinctrl_configure_pins+0x1e> @ imm = #-0x9c
; 	return 0;
 801499a: 2300         	movs	r3, #0x0
; }
 801499c: 4618         	mov	r0, r3
 801499e: 3728         	adds	r7, #0x28
 80149a0: 46bd         	mov	sp, r7
 80149a2: bd80         	pop	{r7, pc}

080149a4 <reset_stm32_status>:
; {
 80149a4: b480         	push	{r7}
 80149a6: b089         	sub	sp, #0x24
 80149a8: af00         	add	r7, sp, #0x0
 80149aa: 60f8         	str	r0, [r7, #0xc]
 80149ac: 60b9         	str	r1, [r7, #0x8]
 80149ae: 607a         	str	r2, [r7, #0x4]
; 	const struct reset_stm32_config *config = dev->config;
 80149b0: 68fb         	ldr	r3, [r7, #0xc]
 80149b2: 685b         	ldr	r3, [r3, #0x4]
 80149b4: 61fb         	str	r3, [r7, #0x1c]
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 80149b6: 69fb         	ldr	r3, [r7, #0x1c]
 80149b8: 681a         	ldr	r2, [r3]
 80149ba: 68bb         	ldr	r3, [r7, #0x8]
 80149bc: 095b         	lsrs	r3, r3, #0x5
 80149be: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 80149c2: 441a         	add	r2, r3
 80149c4: 68bb         	ldr	r3, [r7, #0x8]
 80149c6: f003 031f    	and	r3, r3, #0x1f
 80149ca: 61ba         	str	r2, [r7, #0x18]
 80149cc: 617b         	str	r3, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 80149ce: 69bb         	ldr	r3, [r7, #0x18]
 80149d0: 681b         	ldr	r3, [r3]
 80149d2: 613b         	str	r3, [r7, #0x10]
; 	return temp & (1 << bit);
 80149d4: 2201         	movs	r2, #0x1
 80149d6: 697b         	ldr	r3, [r7, #0x14]
 80149d8: fa02 f303    	lsl.w	r3, r2, r3
 80149dc: 461a         	mov	r2, r3
 80149de: 693b         	ldr	r3, [r7, #0x10]
 80149e0: 4013         	ands	r3, r2
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 80149e2: 2b00         	cmp	r3, #0x0
 80149e4: bf14         	ite	ne
 80149e6: 2301         	movne	r3, #0x1
 80149e8: 2300         	moveq	r3, #0x0
 80149ea: b2db         	uxtb	r3, r3
 80149ec: 461a         	mov	r2, r3
 80149ee: 687b         	ldr	r3, [r7, #0x4]
 80149f0: 701a         	strb	r2, [r3]
; 	return 0;
 80149f2: 2300         	movs	r3, #0x0
; }
 80149f4: 4618         	mov	r0, r3
 80149f6: 3724         	adds	r7, #0x24
 80149f8: 46bd         	mov	sp, r7
 80149fa: bc80         	pop	{r7}
 80149fc: 4770         	bx	lr

080149fe <reset_stm32_line_assert>:
; {
 80149fe: b480         	push	{r7}
 8014a00: b087         	sub	sp, #0x1c
 8014a02: af00         	add	r7, sp, #0x0
 8014a04: 6078         	str	r0, [r7, #0x4]
 8014a06: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 8014a08: 687b         	ldr	r3, [r7, #0x4]
 8014a0a: 685b         	ldr	r3, [r3, #0x4]
 8014a0c: 617b         	str	r3, [r7, #0x14]
; 	sys_set_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8014a0e: 697b         	ldr	r3, [r7, #0x14]
 8014a10: 681a         	ldr	r2, [r3]
 8014a12: 683b         	ldr	r3, [r7]
 8014a14: 095b         	lsrs	r3, r3, #0x5
 8014a16: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8014a1a: 441a         	add	r2, r3
 8014a1c: 683b         	ldr	r3, [r7]
 8014a1e: f003 031f    	and	r3, r3, #0x1f
 8014a22: 613a         	str	r2, [r7, #0x10]
 8014a24: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8014a26: 693b         	ldr	r3, [r7, #0x10]
 8014a28: 681b         	ldr	r3, [r3]
 8014a2a: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp | (1 << bit);
 8014a2c: 2201         	movs	r2, #0x1
 8014a2e: 68fb         	ldr	r3, [r7, #0xc]
 8014a30: fa02 f303    	lsl.w	r3, r2, r3
 8014a34: 4619         	mov	r1, r3
 8014a36: 693b         	ldr	r3, [r7, #0x10]
 8014a38: 68ba         	ldr	r2, [r7, #0x8]
 8014a3a: 430a         	orrs	r2, r1
 8014a3c: 601a         	str	r2, [r3]
; }
 8014a3e: bf00         	nop
; 	return 0;
 8014a40: 2300         	movs	r3, #0x0
; }
 8014a42: 4618         	mov	r0, r3
 8014a44: 371c         	adds	r7, #0x1c
 8014a46: 46bd         	mov	sp, r7
 8014a48: bc80         	pop	{r7}
 8014a4a: 4770         	bx	lr

08014a4c <reset_stm32_line_deassert>:
; {
 8014a4c: b480         	push	{r7}
 8014a4e: b087         	sub	sp, #0x1c
 8014a50: af00         	add	r7, sp, #0x0
 8014a52: 6078         	str	r0, [r7, #0x4]
 8014a54: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 8014a56: 687b         	ldr	r3, [r7, #0x4]
 8014a58: 685b         	ldr	r3, [r3, #0x4]
 8014a5a: 617b         	str	r3, [r7, #0x14]
; 	sys_clear_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8014a5c: 697b         	ldr	r3, [r7, #0x14]
 8014a5e: 681a         	ldr	r2, [r3]
 8014a60: 683b         	ldr	r3, [r7]
 8014a62: 095b         	lsrs	r3, r3, #0x5
 8014a64: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8014a68: 441a         	add	r2, r3
 8014a6a: 683b         	ldr	r3, [r7]
 8014a6c: f003 031f    	and	r3, r3, #0x1f
 8014a70: 613a         	str	r2, [r7, #0x10]
 8014a72: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8014a74: 693b         	ldr	r3, [r7, #0x10]
 8014a76: 681b         	ldr	r3, [r3]
 8014a78: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~(1 << bit);
 8014a7a: 2201         	movs	r2, #0x1
 8014a7c: 68fb         	ldr	r3, [r7, #0xc]
 8014a7e: fa02 f303    	lsl.w	r3, r2, r3
 8014a82: 43db         	mvns	r3, r3
 8014a84: 4619         	mov	r1, r3
 8014a86: 693b         	ldr	r3, [r7, #0x10]
 8014a88: 68ba         	ldr	r2, [r7, #0x8]
 8014a8a: 400a         	ands	r2, r1
 8014a8c: 601a         	str	r2, [r3]
; }
 8014a8e: bf00         	nop
; 	return 0;
 8014a90: 2300         	movs	r3, #0x0
; }
 8014a92: 4618         	mov	r0, r3
 8014a94: 371c         	adds	r7, #0x1c
 8014a96: 46bd         	mov	sp, r7
 8014a98: bc80         	pop	{r7}
 8014a9a: 4770         	bx	lr

08014a9c <reset_stm32_line_toggle>:
; {
 8014a9c: b580         	push	{r7, lr}
 8014a9e: b082         	sub	sp, #0x8
 8014aa0: af00         	add	r7, sp, #0x0
 8014aa2: 6078         	str	r0, [r7, #0x4]
 8014aa4: 6039         	str	r1, [r7]
; 	reset_stm32_line_assert(dev, id);
 8014aa6: 6839         	ldr	r1, [r7]
 8014aa8: 6878         	ldr	r0, [r7, #0x4]
 8014aaa: f7ff ffa8    	bl	0x80149fe <reset_stm32_line_assert> @ imm = #-0xb0
; 	reset_stm32_line_deassert(dev, id);
 8014aae: 6839         	ldr	r1, [r7]
 8014ab0: 6878         	ldr	r0, [r7, #0x4]
 8014ab2: f7ff ffcb    	bl	0x8014a4c <reset_stm32_line_deassert> @ imm = #-0x6a
; 	return 0;
 8014ab6: 2300         	movs	r3, #0x0
; }
 8014ab8: 4618         	mov	r0, r3
 8014aba: 3708         	adds	r7, #0x8
 8014abc: 46bd         	mov	sp, r7
 8014abe: bd80         	pop	{r7, pc}

08014ac0 <device_is_ready>:
; {
 8014ac0: b580         	push	{r7, lr}
 8014ac2: b082         	sub	sp, #0x8
 8014ac4: af00         	add	r7, sp, #0x0
 8014ac6: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8014ac8: 6878         	ldr	r0, [r7, #0x4]
 8014aca: f002 f986    	bl	0x8016dda <z_impl_device_is_ready> @ imm = #0x230c
 8014ace: 4603         	mov	r3, r0
; }
 8014ad0: 4618         	mov	r0, r3
 8014ad2: 3708         	adds	r7, #0x8
 8014ad4: 46bd         	mov	sp, r7
 8014ad6: bd80         	pop	{r7, pc}

08014ad8 <k_work_delayable_from_work>:
; {
 8014ad8: b480         	push	{r7}
 8014ada: b083         	sub	sp, #0xc
 8014adc: af00         	add	r7, sp, #0x0
 8014ade: 6078         	str	r0, [r7, #0x4]
; 	return CONTAINER_OF(work, struct k_work_delayable, work);
 8014ae0: 687b         	ldr	r3, [r7, #0x4]
; }
 8014ae2: 4618         	mov	r0, r3
 8014ae4: 370c         	adds	r7, #0xc
 8014ae6: 46bd         	mov	sp, r7
 8014ae8: bc80         	pop	{r7}
 8014aea: 4770         	bx	lr

08014aec <clock_control_on>:
; {
 8014aec: b580         	push	{r7, lr}
 8014aee: b084         	sub	sp, #0x10
 8014af0: af00         	add	r7, sp, #0x0
 8014af2: 6078         	str	r0, [r7, #0x4]
 8014af4: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8014af6: 687b         	ldr	r3, [r7, #0x4]
 8014af8: 689b         	ldr	r3, [r3, #0x8]
 8014afa: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8014afc: 68fb         	ldr	r3, [r7, #0xc]
 8014afe: 681b         	ldr	r3, [r3]
 8014b00: 6839         	ldr	r1, [r7]
 8014b02: 6878         	ldr	r0, [r7, #0x4]
 8014b04: 4798         	blx	r3
 8014b06: 4603         	mov	r3, r0
; }
 8014b08: 4618         	mov	r0, r3
 8014b0a: 3710         	adds	r7, #0x10
 8014b0c: 46bd         	mov	sp, r7
 8014b0e: bd80         	pop	{r7, pc}

08014b10 <clock_control_get_rate>:
; {
 8014b10: b580         	push	{r7, lr}
 8014b12: b086         	sub	sp, #0x18
 8014b14: af00         	add	r7, sp, #0x0
 8014b16: 60f8         	str	r0, [r7, #0xc]
 8014b18: 60b9         	str	r1, [r7, #0x8]
 8014b1a: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 8014b1c: 68fb         	ldr	r3, [r7, #0xc]
 8014b1e: 689b         	ldr	r3, [r3, #0x8]
 8014b20: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 8014b22: 697b         	ldr	r3, [r7, #0x14]
 8014b24: 68db         	ldr	r3, [r3, #0xc]
 8014b26: 2b00         	cmp	r3, #0x0
 8014b28: d102         	bne	0x8014b30 <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8014b2a: f06f 0357    	mvn	r3, #0x57
 8014b2e: e006         	b	0x8014b3e <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 8014b30: 697b         	ldr	r3, [r7, #0x14]
 8014b32: 68db         	ldr	r3, [r3, #0xc]
 8014b34: 687a         	ldr	r2, [r7, #0x4]
 8014b36: 68b9         	ldr	r1, [r7, #0x8]
 8014b38: 68f8         	ldr	r0, [r7, #0xc]
 8014b3a: 4798         	blx	r3
 8014b3c: 4603         	mov	r3, r0
; }
 8014b3e: 4618         	mov	r0, r3
 8014b40: 3718         	adds	r7, #0x18
 8014b42: 46bd         	mov	sp, r7
 8014b44: bd80         	pop	{r7, pc}

08014b46 <dma_config>:
; {
 8014b46: b580         	push	{r7, lr}
 8014b48: b086         	sub	sp, #0x18
 8014b4a: af00         	add	r7, sp, #0x0
 8014b4c: 60f8         	str	r0, [r7, #0xc]
 8014b4e: 60b9         	str	r1, [r7, #0x8]
 8014b50: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_driver_api *api =
 8014b52: 68fb         	ldr	r3, [r7, #0xc]
 8014b54: 689b         	ldr	r3, [r3, #0x8]
 8014b56: 617b         	str	r3, [r7, #0x14]
; 	return api->config(dev, channel, config);
 8014b58: 697b         	ldr	r3, [r7, #0x14]
 8014b5a: 681b         	ldr	r3, [r3]
 8014b5c: 687a         	ldr	r2, [r7, #0x4]
 8014b5e: 68b9         	ldr	r1, [r7, #0x8]
 8014b60: 68f8         	ldr	r0, [r7, #0xc]
 8014b62: 4798         	blx	r3
 8014b64: 4603         	mov	r3, r0
; }
 8014b66: 4618         	mov	r0, r3
 8014b68: 3718         	adds	r7, #0x18
 8014b6a: 46bd         	mov	sp, r7
 8014b6c: bd80         	pop	{r7, pc}

08014b6e <dma_reload>:
; {
 8014b6e: b590         	push	{r4, r7, lr}
 8014b70: b089         	sub	sp, #0x24
 8014b72: af02         	add	r7, sp, #0x8
 8014b74: 60f8         	str	r0, [r7, #0xc]
 8014b76: 60b9         	str	r1, [r7, #0x8]
 8014b78: 607a         	str	r2, [r7, #0x4]
 8014b7a: 603b         	str	r3, [r7]
; 	const struct dma_driver_api *api =
 8014b7c: 68fb         	ldr	r3, [r7, #0xc]
 8014b7e: 689b         	ldr	r3, [r3, #0x8]
 8014b80: 617b         	str	r3, [r7, #0x14]
; 	if (api->reload) {
 8014b82: 697b         	ldr	r3, [r7, #0x14]
 8014b84: 685b         	ldr	r3, [r3, #0x4]
 8014b86: 2b00         	cmp	r3, #0x0
 8014b88: d00a         	beq	0x8014ba0 <dma_reload+0x32> @ imm = #0x14
; 		return api->reload(dev, channel, src, dst, size);
 8014b8a: 697b         	ldr	r3, [r7, #0x14]
 8014b8c: 685c         	ldr	r4, [r3, #0x4]
 8014b8e: 6abb         	ldr	r3, [r7, #0x28]
 8014b90: 9300         	str	r3, [sp]
 8014b92: 683b         	ldr	r3, [r7]
 8014b94: 687a         	ldr	r2, [r7, #0x4]
 8014b96: 68b9         	ldr	r1, [r7, #0x8]
 8014b98: 68f8         	ldr	r0, [r7, #0xc]
 8014b9a: 47a0         	blx	r4
 8014b9c: 4603         	mov	r3, r0
 8014b9e: e001         	b	0x8014ba4 <dma_reload+0x36> @ imm = #0x2
; 	return -ENOSYS;
 8014ba0: f06f 0357    	mvn	r3, #0x57
; }
 8014ba4: 4618         	mov	r0, r3
 8014ba6: 371c         	adds	r7, #0x1c
 8014ba8: 46bd         	mov	sp, r7
 8014baa: bd90         	pop	{r4, r7, pc}

08014bac <z_impl_dma_start>:
; {
 8014bac: b580         	push	{r7, lr}
 8014bae: b084         	sub	sp, #0x10
 8014bb0: af00         	add	r7, sp, #0x0
 8014bb2: 6078         	str	r0, [r7, #0x4]
 8014bb4: 6039         	str	r1, [r7]
; 	const struct dma_driver_api *api =
 8014bb6: 687b         	ldr	r3, [r7, #0x4]
 8014bb8: 689b         	ldr	r3, [r3, #0x8]
 8014bba: 60fb         	str	r3, [r7, #0xc]
; 	return api->start(dev, channel);
 8014bbc: 68fb         	ldr	r3, [r7, #0xc]
 8014bbe: 689b         	ldr	r3, [r3, #0x8]
 8014bc0: 6839         	ldr	r1, [r7]
 8014bc2: 6878         	ldr	r0, [r7, #0x4]
 8014bc4: 4798         	blx	r3
 8014bc6: 4603         	mov	r3, r0
; }
 8014bc8: 4618         	mov	r0, r3
 8014bca: 3710         	adds	r7, #0x10
 8014bcc: 46bd         	mov	sp, r7
 8014bce: bd80         	pop	{r7, pc}

08014bd0 <z_impl_dma_stop>:
; {
 8014bd0: b580         	push	{r7, lr}
 8014bd2: b084         	sub	sp, #0x10
 8014bd4: af00         	add	r7, sp, #0x0
 8014bd6: 6078         	str	r0, [r7, #0x4]
 8014bd8: 6039         	str	r1, [r7]
; 	const struct dma_driver_api *api =
 8014bda: 687b         	ldr	r3, [r7, #0x4]
 8014bdc: 689b         	ldr	r3, [r3, #0x8]
 8014bde: 60fb         	str	r3, [r7, #0xc]
; 	return api->stop(dev, channel);
 8014be0: 68fb         	ldr	r3, [r7, #0xc]
 8014be2: 68db         	ldr	r3, [r3, #0xc]
 8014be4: 6839         	ldr	r1, [r7]
 8014be6: 6878         	ldr	r0, [r7, #0x4]
 8014be8: 4798         	blx	r3
 8014bea: 4603         	mov	r3, r0
; }
 8014bec: 4618         	mov	r0, r3
 8014bee: 3710         	adds	r7, #0x10
 8014bf0: 46bd         	mov	sp, r7
 8014bf2: bd80         	pop	{r7, pc}

08014bf4 <dma_get_status>:
; {
 8014bf4: b580         	push	{r7, lr}
 8014bf6: b086         	sub	sp, #0x18
 8014bf8: af00         	add	r7, sp, #0x0
 8014bfa: 60f8         	str	r0, [r7, #0xc]
 8014bfc: 60b9         	str	r1, [r7, #0x8]
 8014bfe: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_driver_api *api =
 8014c00: 68fb         	ldr	r3, [r7, #0xc]
 8014c02: 689b         	ldr	r3, [r3, #0x8]
 8014c04: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_status) {
 8014c06: 697b         	ldr	r3, [r7, #0x14]
 8014c08: 699b         	ldr	r3, [r3, #0x18]
 8014c0a: 2b00         	cmp	r3, #0x0
 8014c0c: d007         	beq	0x8014c1e <dma_get_status+0x2a> @ imm = #0xe
; 		return api->get_status(dev, channel, stat);
 8014c0e: 697b         	ldr	r3, [r7, #0x14]
 8014c10: 699b         	ldr	r3, [r3, #0x18]
 8014c12: 687a         	ldr	r2, [r7, #0x4]
 8014c14: 68b9         	ldr	r1, [r7, #0x8]
 8014c16: 68f8         	ldr	r0, [r7, #0xc]
 8014c18: 4798         	blx	r3
 8014c1a: 4603         	mov	r3, r0
 8014c1c: e001         	b	0x8014c22 <dma_get_status+0x2e> @ imm = #0x2
; 	return -ENOSYS;
 8014c1e: f06f 0357    	mvn	r3, #0x57
; }
 8014c22: 4618         	mov	r0, r3
 8014c24: 3718         	adds	r7, #0x18
 8014c26: 46bd         	mov	sp, r7
 8014c28: bd80         	pop	{r7, pc}

08014c2a <dma_start>:
; {
 8014c2a: b580         	push	{r7, lr}
 8014c2c: b082         	sub	sp, #0x8
 8014c2e: af00         	add	r7, sp, #0x0
 8014c30: 6078         	str	r0, [r7, #0x4]
 8014c32: 6039         	str	r1, [r7]
; 	return z_impl_dma_start(dev, channel);
 8014c34: 6839         	ldr	r1, [r7]
 8014c36: 6878         	ldr	r0, [r7, #0x4]
 8014c38: f7ff ffb8    	bl	0x8014bac <z_impl_dma_start> @ imm = #-0x90
 8014c3c: 4603         	mov	r3, r0
; }
 8014c3e: 4618         	mov	r0, r3
 8014c40: 3708         	adds	r7, #0x8
 8014c42: 46bd         	mov	sp, r7
 8014c44: bd80         	pop	{r7, pc}

08014c46 <dma_stop>:
; {
 8014c46: b580         	push	{r7, lr}
 8014c48: b082         	sub	sp, #0x8
 8014c4a: af00         	add	r7, sp, #0x0
 8014c4c: 6078         	str	r0, [r7, #0x4]
 8014c4e: 6039         	str	r1, [r7]
; 	return z_impl_dma_stop(dev, channel);
 8014c50: 6839         	ldr	r1, [r7]
 8014c52: 6878         	ldr	r0, [r7, #0x4]
 8014c54: f7ff ffbc    	bl	0x8014bd0 <z_impl_dma_stop> @ imm = #-0x88
 8014c58: 4603         	mov	r3, r0
; }
 8014c5a: 4618         	mov	r0, r3
 8014c5c: 3708         	adds	r7, #0x8
 8014c5e: 46bd         	mov	sp, r7
 8014c60: bd80         	pop	{r7, pc}

08014c62 <pinctrl_apply_state_direct>:
; {
 8014c62: b580         	push	{r7, lr}
 8014c64: b084         	sub	sp, #0x10
 8014c66: af00         	add	r7, sp, #0x0
 8014c68: 6078         	str	r0, [r7, #0x4]
 8014c6a: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 8014c6c: 2300         	movs	r3, #0x0
 8014c6e: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 8014c70: 683b         	ldr	r3, [r7]
 8014c72: 6818         	ldr	r0, [r3]
 8014c74: 683b         	ldr	r3, [r7]
 8014c76: 791b         	ldrb	r3, [r3, #0x4]
 8014c78: 68fa         	ldr	r2, [r7, #0xc]
 8014c7a: 4619         	mov	r1, r3
 8014c7c: f7ff fe31    	bl	0x80148e2 <pinctrl_configure_pins> @ imm = #-0x39e
 8014c80: 4603         	mov	r3, r0
; }
 8014c82: 4618         	mov	r0, r3
 8014c84: 3710         	adds	r7, #0x10
 8014c86: 46bd         	mov	sp, r7
 8014c88: bd80         	pop	{r7, pc}

08014c8a <pinctrl_apply_state>:
; {
 8014c8a: b580         	push	{r7, lr}
 8014c8c: b084         	sub	sp, #0x10
 8014c8e: af00         	add	r7, sp, #0x0
 8014c90: 6078         	str	r0, [r7, #0x4]
 8014c92: 460b         	mov	r3, r1
 8014c94: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 8014c96: f107 0208    	add.w	r2, r7, #0x8
 8014c9a: 78fb         	ldrb	r3, [r7, #0x3]
 8014c9c: 4619         	mov	r1, r3
 8014c9e: 6878         	ldr	r0, [r7, #0x4]
 8014ca0: f7ff fde8    	bl	0x8014874 <pinctrl_lookup_state> @ imm = #-0x430
 8014ca4: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8014ca6: 68fb         	ldr	r3, [r7, #0xc]
 8014ca8: 2b00         	cmp	r3, #0x0
 8014caa: da01         	bge	0x8014cb0 <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 8014cac: 68fb         	ldr	r3, [r7, #0xc]
 8014cae: e005         	b	0x8014cbc <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 8014cb0: 68bb         	ldr	r3, [r7, #0x8]
 8014cb2: 4619         	mov	r1, r3
 8014cb4: 6878         	ldr	r0, [r7, #0x4]
 8014cb6: f7ff ffd4    	bl	0x8014c62 <pinctrl_apply_state_direct> @ imm = #-0x58
 8014cba: 4603         	mov	r3, r0
; }
 8014cbc: 4618         	mov	r0, r3
 8014cbe: 3710         	adds	r7, #0x10
 8014cc0: 46bd         	mov	sp, r7
 8014cc2: bd80         	pop	{r7, pc}

08014cc4 <z_impl_reset_line_toggle>:
; {
 8014cc4: b580         	push	{r7, lr}
 8014cc6: b084         	sub	sp, #0x10
 8014cc8: af00         	add	r7, sp, #0x0
 8014cca: 6078         	str	r0, [r7, #0x4]
 8014ccc: 6039         	str	r1, [r7]
; 	const struct reset_driver_api *api = (const struct reset_driver_api *)dev->api;
 8014cce: 687b         	ldr	r3, [r7, #0x4]
 8014cd0: 689b         	ldr	r3, [r3, #0x8]
 8014cd2: 60fb         	str	r3, [r7, #0xc]
; 	if (api->line_toggle == NULL) {
 8014cd4: 68fb         	ldr	r3, [r7, #0xc]
 8014cd6: 68db         	ldr	r3, [r3, #0xc]
 8014cd8: 2b00         	cmp	r3, #0x0
 8014cda: d102         	bne	0x8014ce2 <z_impl_reset_line_toggle+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 8014cdc: f06f 0357    	mvn	r3, #0x57
 8014ce0: e005         	b	0x8014cee <z_impl_reset_line_toggle+0x2a> @ imm = #0xa
; 	return api->line_toggle(dev, id);
 8014ce2: 68fb         	ldr	r3, [r7, #0xc]
 8014ce4: 68db         	ldr	r3, [r3, #0xc]
 8014ce6: 6839         	ldr	r1, [r7]
 8014ce8: 6878         	ldr	r0, [r7, #0x4]
 8014cea: 4798         	blx	r3
 8014cec: 4603         	mov	r3, r0
; }
 8014cee: 4618         	mov	r0, r3
 8014cf0: 3710         	adds	r7, #0x10
 8014cf2: 46bd         	mov	sp, r7
 8014cf4: bd80         	pop	{r7, pc}

08014cf6 <reset_line_toggle_dt>:
; {
 8014cf6: b580         	push	{r7, lr}
 8014cf8: b082         	sub	sp, #0x8
 8014cfa: af00         	add	r7, sp, #0x0
 8014cfc: 6078         	str	r0, [r7, #0x4]
; 	return reset_line_toggle(spec->dev, spec->id);
 8014cfe: 687b         	ldr	r3, [r7, #0x4]
 8014d00: 681a         	ldr	r2, [r3]
 8014d02: 687b         	ldr	r3, [r7, #0x4]
 8014d04: 685b         	ldr	r3, [r3, #0x4]
 8014d06: 4619         	mov	r1, r3
 8014d08: 4610         	mov	r0, r2
 8014d0a: f000 f805    	bl	0x8014d18 <reset_line_toggle> @ imm = #0xa
 8014d0e: 4603         	mov	r3, r0
; }
 8014d10: 4618         	mov	r0, r3
 8014d12: 3708         	adds	r7, #0x8
 8014d14: 46bd         	mov	sp, r7
 8014d16: bd80         	pop	{r7, pc}

08014d18 <reset_line_toggle>:
; {
 8014d18: b580         	push	{r7, lr}
 8014d1a: b082         	sub	sp, #0x8
 8014d1c: af00         	add	r7, sp, #0x0
 8014d1e: 6078         	str	r0, [r7, #0x4]
 8014d20: 6039         	str	r1, [r7]
; 	return z_impl_reset_line_toggle(dev, id);
 8014d22: 6839         	ldr	r1, [r7]
 8014d24: 6878         	ldr	r0, [r7, #0x4]
 8014d26: f7ff ffcd    	bl	0x8014cc4 <z_impl_reset_line_toggle> @ imm = #-0x66
 8014d2a: 4603         	mov	r3, r0
; }
 8014d2c: 4618         	mov	r0, r3
 8014d2e: 3708         	adds	r7, #0x8
 8014d30: 46bd         	mov	sp, r7
 8014d32: bd80         	pop	{r7, pc}

08014d34 <LL_USART_Enable>:
; {
 8014d34: b480         	push	{r7}
 8014d36: b083         	sub	sp, #0xc
 8014d38: af00         	add	r7, sp, #0x0
 8014d3a: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR1, USART_CR1_UE);
 8014d3c: 687b         	ldr	r3, [r7, #0x4]
 8014d3e: 68db         	ldr	r3, [r3, #0xc]
 8014d40: f443 5200    	orr	r2, r3, #0x2000
 8014d44: 687b         	ldr	r3, [r7, #0x4]
 8014d46: 60da         	str	r2, [r3, #0xc]
; }
 8014d48: bf00         	nop
 8014d4a: 370c         	adds	r7, #0xc
 8014d4c: 46bd         	mov	sp, r7
 8014d4e: bc80         	pop	{r7}
 8014d50: 4770         	bx	lr

08014d52 <LL_USART_Disable>:
; {
 8014d52: b480         	push	{r7}
 8014d54: b083         	sub	sp, #0xc
 8014d56: af00         	add	r7, sp, #0x0
 8014d58: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
 8014d5a: 687b         	ldr	r3, [r7, #0x4]
 8014d5c: 68db         	ldr	r3, [r3, #0xc]
 8014d5e: f423 5200    	bic	r2, r3, #0x2000
 8014d62: 687b         	ldr	r3, [r7, #0x4]
 8014d64: 60da         	str	r2, [r3, #0xc]
; }
 8014d66: bf00         	nop
 8014d68: 370c         	adds	r7, #0xc
 8014d6a: 46bd         	mov	sp, r7
 8014d6c: bc80         	pop	{r7}
 8014d6e: 4770         	bx	lr

08014d70 <LL_USART_SetTransferDirection>:
; {
 8014d70: b480         	push	{r7}
 8014d72: b089         	sub	sp, #0x24
 8014d74: af00         	add	r7, sp, #0x0
 8014d76: 6078         	str	r0, [r7, #0x4]
 8014d78: 6039         	str	r1, [r7]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8014d7a: 687b         	ldr	r3, [r7, #0x4]
 8014d7c: 330c         	adds	r3, #0xc
 8014d7e: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8014d80: 68fb         	ldr	r3, [r7, #0xc]
 8014d82: e853 3f00    	ldrex	r3, [r3]
 8014d86: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8014d88: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8014d8a: f023 030c    	bic	r3, r3, #0xc
 8014d8e: 683a         	ldr	r2, [r7]
 8014d90: 4313         	orrs	r3, r2
 8014d92: 61fb         	str	r3, [r7, #0x1c]
 8014d94: 687b         	ldr	r3, [r7, #0x4]
 8014d96: 330c         	adds	r3, #0xc
 8014d98: 69fa         	ldr	r2, [r7, #0x1c]
 8014d9a: 61ba         	str	r2, [r7, #0x18]
 8014d9c: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8014d9e: 6979         	ldr	r1, [r7, #0x14]
 8014da0: 69ba         	ldr	r2, [r7, #0x18]
 8014da2: e841 2300    	strex	r3, r2, [r1]
 8014da6: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8014da8: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8014daa: 2b00         	cmp	r3, #0x0
 8014dac: d1e5         	bne	0x8014d7a <LL_USART_SetTransferDirection+0xa> @ imm = #-0x36
; }
 8014dae: bf00         	nop
 8014db0: bf00         	nop
 8014db2: 3724         	adds	r7, #0x24
 8014db4: 46bd         	mov	sp, r7
 8014db6: bc80         	pop	{r7}
 8014db8: 4770         	bx	lr

08014dba <LL_USART_SetParity>:
; {
 8014dba: b480         	push	{r7}
 8014dbc: b083         	sub	sp, #0xc
 8014dbe: af00         	add	r7, sp, #0x0
 8014dc0: 6078         	str	r0, [r7, #0x4]
 8014dc2: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
 8014dc4: 687b         	ldr	r3, [r7, #0x4]
 8014dc6: 68db         	ldr	r3, [r3, #0xc]
 8014dc8: f423 62c0    	bic	r2, r3, #0x600
 8014dcc: 683b         	ldr	r3, [r7]
 8014dce: 431a         	orrs	r2, r3
 8014dd0: 687b         	ldr	r3, [r7, #0x4]
 8014dd2: 60da         	str	r2, [r3, #0xc]
; }
 8014dd4: bf00         	nop
 8014dd6: 370c         	adds	r7, #0xc
 8014dd8: 46bd         	mov	sp, r7
 8014dda: bc80         	pop	{r7}
 8014ddc: 4770         	bx	lr

08014dde <LL_USART_GetParity>:
; {
 8014dde: b480         	push	{r7}
 8014de0: b083         	sub	sp, #0xc
 8014de2: af00         	add	r7, sp, #0x0
 8014de4: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
 8014de6: 687b         	ldr	r3, [r7, #0x4]
 8014de8: 68db         	ldr	r3, [r3, #0xc]
 8014dea: f403 63c0    	and	r3, r3, #0x600
; }
 8014dee: 4618         	mov	r0, r3
 8014df0: 370c         	adds	r7, #0xc
 8014df2: 46bd         	mov	sp, r7
 8014df4: bc80         	pop	{r7}
 8014df6: 4770         	bx	lr

08014df8 <LL_USART_SetDataWidth>:
; {
 8014df8: b480         	push	{r7}
 8014dfa: b083         	sub	sp, #0xc
 8014dfc: af00         	add	r7, sp, #0x0
 8014dfe: 6078         	str	r0, [r7, #0x4]
 8014e00: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
 8014e02: 687b         	ldr	r3, [r7, #0x4]
 8014e04: 68db         	ldr	r3, [r3, #0xc]
 8014e06: f423 5280    	bic	r2, r3, #0x1000
 8014e0a: 683b         	ldr	r3, [r7]
 8014e0c: 431a         	orrs	r2, r3
 8014e0e: 687b         	ldr	r3, [r7, #0x4]
 8014e10: 60da         	str	r2, [r3, #0xc]
; }
 8014e12: bf00         	nop
 8014e14: 370c         	adds	r7, #0xc
 8014e16: 46bd         	mov	sp, r7
 8014e18: bc80         	pop	{r7}
 8014e1a: 4770         	bx	lr

08014e1c <LL_USART_GetDataWidth>:
; {
 8014e1c: b480         	push	{r7}
 8014e1e: b083         	sub	sp, #0xc
 8014e20: af00         	add	r7, sp, #0x0
 8014e22: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
 8014e24: 687b         	ldr	r3, [r7, #0x4]
 8014e26: 68db         	ldr	r3, [r3, #0xc]
 8014e28: f403 5380    	and	r3, r3, #0x1000
; }
 8014e2c: 4618         	mov	r0, r3
 8014e2e: 370c         	adds	r7, #0xc
 8014e30: 46bd         	mov	sp, r7
 8014e32: bc80         	pop	{r7}
 8014e34: 4770         	bx	lr

08014e36 <LL_USART_SetOverSampling>:
; {
 8014e36: b480         	push	{r7}
 8014e38: b083         	sub	sp, #0xc
 8014e3a: af00         	add	r7, sp, #0x0
 8014e3c: 6078         	str	r0, [r7, #0x4]
 8014e3e: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_OVER8, OverSampling);
 8014e40: 687b         	ldr	r3, [r7, #0x4]
 8014e42: 68db         	ldr	r3, [r3, #0xc]
 8014e44: f423 4200    	bic	r2, r3, #0x8000
 8014e48: 683b         	ldr	r3, [r7]
 8014e4a: 431a         	orrs	r2, r3
 8014e4c: 687b         	ldr	r3, [r7, #0x4]
 8014e4e: 60da         	str	r2, [r3, #0xc]
; }
 8014e50: bf00         	nop
 8014e52: 370c         	adds	r7, #0xc
 8014e54: 46bd         	mov	sp, r7
 8014e56: bc80         	pop	{r7}
 8014e58: 4770         	bx	lr

08014e5a <LL_USART_SetStopBitsLength>:
; {
 8014e5a: b480         	push	{r7}
 8014e5c: b083         	sub	sp, #0xc
 8014e5e: af00         	add	r7, sp, #0x0
 8014e60: 6078         	str	r0, [r7, #0x4]
 8014e62: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8014e64: 687b         	ldr	r3, [r7, #0x4]
 8014e66: 691b         	ldr	r3, [r3, #0x10]
 8014e68: f423 5240    	bic	r2, r3, #0x3000
 8014e6c: 683b         	ldr	r3, [r7]
 8014e6e: 431a         	orrs	r2, r3
 8014e70: 687b         	ldr	r3, [r7, #0x4]
 8014e72: 611a         	str	r2, [r3, #0x10]
; }
 8014e74: bf00         	nop
 8014e76: 370c         	adds	r7, #0xc
 8014e78: 46bd         	mov	sp, r7
 8014e7a: bc80         	pop	{r7}
 8014e7c: 4770         	bx	lr

08014e7e <LL_USART_GetStopBitsLength>:
; {
 8014e7e: b480         	push	{r7}
 8014e80: b083         	sub	sp, #0xc
 8014e82: af00         	add	r7, sp, #0x0
 8014e84: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
 8014e86: 687b         	ldr	r3, [r7, #0x4]
 8014e88: 691b         	ldr	r3, [r3, #0x10]
 8014e8a: f403 5340    	and	r3, r3, #0x3000
; }
 8014e8e: 4618         	mov	r0, r3
 8014e90: 370c         	adds	r7, #0xc
 8014e92: 46bd         	mov	sp, r7
 8014e94: bc80         	pop	{r7}
 8014e96: 4770         	bx	lr

08014e98 <LL_USART_ConfigCharacter>:
; {
 8014e98: b480         	push	{r7}
 8014e9a: b085         	sub	sp, #0x14
 8014e9c: af00         	add	r7, sp, #0x0
 8014e9e: 60f8         	str	r0, [r7, #0xc]
 8014ea0: 60b9         	str	r1, [r7, #0x8]
 8014ea2: 607a         	str	r2, [r7, #0x4]
 8014ea4: 603b         	str	r3, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
 8014ea6: 68fb         	ldr	r3, [r7, #0xc]
 8014ea8: 68db         	ldr	r3, [r3, #0xc]
 8014eaa: f423 52b0    	bic	r2, r3, #0x1600
 8014eae: 6879         	ldr	r1, [r7, #0x4]
 8014eb0: 68bb         	ldr	r3, [r7, #0x8]
 8014eb2: 430b         	orrs	r3, r1
 8014eb4: 431a         	orrs	r2, r3
 8014eb6: 68fb         	ldr	r3, [r7, #0xc]
 8014eb8: 60da         	str	r2, [r3, #0xc]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8014eba: 68fb         	ldr	r3, [r7, #0xc]
 8014ebc: 691b         	ldr	r3, [r3, #0x10]
 8014ebe: f423 5240    	bic	r2, r3, #0x3000
 8014ec2: 683b         	ldr	r3, [r7]
 8014ec4: 431a         	orrs	r2, r3
 8014ec6: 68fb         	ldr	r3, [r7, #0xc]
 8014ec8: 611a         	str	r2, [r3, #0x10]
; }
 8014eca: bf00         	nop
 8014ecc: 3714         	adds	r7, #0x14
 8014ece: 46bd         	mov	sp, r7
 8014ed0: bc80         	pop	{r7}
 8014ed2: 4770         	bx	lr

08014ed4 <LL_USART_SetHWFlowCtrl>:
; {
 8014ed4: b480         	push	{r7}
 8014ed6: b083         	sub	sp, #0xc
 8014ed8: af00         	add	r7, sp, #0x0
 8014eda: 6078         	str	r0, [r7, #0x4]
 8014edc: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 8014ede: 687b         	ldr	r3, [r7, #0x4]
 8014ee0: 695b         	ldr	r3, [r3, #0x14]
 8014ee2: f423 7240    	bic	r2, r3, #0x300
 8014ee6: 683b         	ldr	r3, [r7]
 8014ee8: 431a         	orrs	r2, r3
 8014eea: 687b         	ldr	r3, [r7, #0x4]
 8014eec: 615a         	str	r2, [r3, #0x14]
; }
 8014eee: bf00         	nop
 8014ef0: 370c         	adds	r7, #0xc
 8014ef2: 46bd         	mov	sp, r7
 8014ef4: bc80         	pop	{r7}
 8014ef6: 4770         	bx	lr

08014ef8 <LL_USART_GetHWFlowCtrl>:
; {
 8014ef8: b480         	push	{r7}
 8014efa: b083         	sub	sp, #0xc
 8014efc: af00         	add	r7, sp, #0x0
 8014efe: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
 8014f00: 687b         	ldr	r3, [r7, #0x4]
 8014f02: 695b         	ldr	r3, [r3, #0x14]
 8014f04: f403 7340    	and	r3, r3, #0x300
; }
 8014f08: 4618         	mov	r0, r3
 8014f0a: 370c         	adds	r7, #0xc
 8014f0c: 46bd         	mov	sp, r7
 8014f0e: bc80         	pop	{r7}
 8014f10: 4770         	bx	lr

08014f12 <LL_USART_EnableHalfDuplex>:
; {
 8014f12: b480         	push	{r7}
 8014f14: b083         	sub	sp, #0xc
 8014f16: af00         	add	r7, sp, #0x0
 8014f18: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
 8014f1a: 687b         	ldr	r3, [r7, #0x4]
 8014f1c: 695b         	ldr	r3, [r3, #0x14]
 8014f1e: f043 0208    	orr	r2, r3, #0x8
 8014f22: 687b         	ldr	r3, [r7, #0x4]
 8014f24: 615a         	str	r2, [r3, #0x14]
; }
 8014f26: bf00         	nop
 8014f28: 370c         	adds	r7, #0xc
 8014f2a: 46bd         	mov	sp, r7
 8014f2c: bc80         	pop	{r7}
 8014f2e: 4770         	bx	lr

08014f30 <LL_USART_IsActiveFlag_PE>:
; {
 8014f30: b480         	push	{r7}
 8014f32: b083         	sub	sp, #0xc
 8014f34: af00         	add	r7, sp, #0x0
 8014f36: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_PE) == (USART_SR_PE));
 8014f38: 687b         	ldr	r3, [r7, #0x4]
 8014f3a: 681b         	ldr	r3, [r3]
 8014f3c: f003 0301    	and	r3, r3, #0x1
 8014f40: 2b01         	cmp	r3, #0x1
 8014f42: bf0c         	ite	eq
 8014f44: 2301         	moveq	r3, #0x1
 8014f46: 2300         	movne	r3, #0x0
 8014f48: b2db         	uxtb	r3, r3
; }
 8014f4a: 4618         	mov	r0, r3
 8014f4c: 370c         	adds	r7, #0xc
 8014f4e: 46bd         	mov	sp, r7
 8014f50: bc80         	pop	{r7}
 8014f52: 4770         	bx	lr

08014f54 <LL_USART_IsActiveFlag_FE>:
; {
 8014f54: b480         	push	{r7}
 8014f56: b083         	sub	sp, #0xc
 8014f58: af00         	add	r7, sp, #0x0
 8014f5a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_FE) == (USART_SR_FE));
 8014f5c: 687b         	ldr	r3, [r7, #0x4]
 8014f5e: 681b         	ldr	r3, [r3]
 8014f60: f003 0302    	and	r3, r3, #0x2
 8014f64: 2b02         	cmp	r3, #0x2
 8014f66: bf0c         	ite	eq
 8014f68: 2301         	moveq	r3, #0x1
 8014f6a: 2300         	movne	r3, #0x0
 8014f6c: b2db         	uxtb	r3, r3
; }
 8014f6e: 4618         	mov	r0, r3
 8014f70: 370c         	adds	r7, #0xc
 8014f72: 46bd         	mov	sp, r7
 8014f74: bc80         	pop	{r7}
 8014f76: 4770         	bx	lr

08014f78 <LL_USART_IsActiveFlag_NE>:
; {
 8014f78: b480         	push	{r7}
 8014f7a: b083         	sub	sp, #0xc
 8014f7c: af00         	add	r7, sp, #0x0
 8014f7e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_NE) == (USART_SR_NE));
 8014f80: 687b         	ldr	r3, [r7, #0x4]
 8014f82: 681b         	ldr	r3, [r3]
 8014f84: f003 0304    	and	r3, r3, #0x4
 8014f88: 2b04         	cmp	r3, #0x4
 8014f8a: bf0c         	ite	eq
 8014f8c: 2301         	moveq	r3, #0x1
 8014f8e: 2300         	movne	r3, #0x0
 8014f90: b2db         	uxtb	r3, r3
; }
 8014f92: 4618         	mov	r0, r3
 8014f94: 370c         	adds	r7, #0xc
 8014f96: 46bd         	mov	sp, r7
 8014f98: bc80         	pop	{r7}
 8014f9a: 4770         	bx	lr

08014f9c <LL_USART_IsActiveFlag_ORE>:
; {
 8014f9c: b480         	push	{r7}
 8014f9e: b083         	sub	sp, #0xc
 8014fa0: af00         	add	r7, sp, #0x0
 8014fa2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_ORE) == (USART_SR_ORE));
 8014fa4: 687b         	ldr	r3, [r7, #0x4]
 8014fa6: 681b         	ldr	r3, [r3]
 8014fa8: f003 0308    	and	r3, r3, #0x8
 8014fac: 2b08         	cmp	r3, #0x8
 8014fae: bf0c         	ite	eq
 8014fb0: 2301         	moveq	r3, #0x1
 8014fb2: 2300         	movne	r3, #0x0
 8014fb4: b2db         	uxtb	r3, r3
; }
 8014fb6: 4618         	mov	r0, r3
 8014fb8: 370c         	adds	r7, #0xc
 8014fba: 46bd         	mov	sp, r7
 8014fbc: bc80         	pop	{r7}
 8014fbe: 4770         	bx	lr

08014fc0 <LL_USART_IsActiveFlag_IDLE>:
; {
 8014fc0: b480         	push	{r7}
 8014fc2: b083         	sub	sp, #0xc
 8014fc4: af00         	add	r7, sp, #0x0
 8014fc6: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_IDLE) == (USART_SR_IDLE));
 8014fc8: 687b         	ldr	r3, [r7, #0x4]
 8014fca: 681b         	ldr	r3, [r3]
 8014fcc: f003 0310    	and	r3, r3, #0x10
 8014fd0: 2b10         	cmp	r3, #0x10
 8014fd2: bf0c         	ite	eq
 8014fd4: 2301         	moveq	r3, #0x1
 8014fd6: 2300         	movne	r3, #0x0
 8014fd8: b2db         	uxtb	r3, r3
; }
 8014fda: 4618         	mov	r0, r3
 8014fdc: 370c         	adds	r7, #0xc
 8014fde: 46bd         	mov	sp, r7
 8014fe0: bc80         	pop	{r7}
 8014fe2: 4770         	bx	lr

08014fe4 <LL_USART_IsActiveFlag_RXNE>:
; {
 8014fe4: b480         	push	{r7}
 8014fe6: b083         	sub	sp, #0xc
 8014fe8: af00         	add	r7, sp, #0x0
 8014fea: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
 8014fec: 687b         	ldr	r3, [r7, #0x4]
 8014fee: 681b         	ldr	r3, [r3]
 8014ff0: f003 0320    	and	r3, r3, #0x20
 8014ff4: 2b20         	cmp	r3, #0x20
 8014ff6: bf0c         	ite	eq
 8014ff8: 2301         	moveq	r3, #0x1
 8014ffa: 2300         	movne	r3, #0x0
 8014ffc: b2db         	uxtb	r3, r3
; }
 8014ffe: 4618         	mov	r0, r3
 8015000: 370c         	adds	r7, #0xc
 8015002: 46bd         	mov	sp, r7
 8015004: bc80         	pop	{r7}
 8015006: 4770         	bx	lr

08015008 <LL_USART_IsActiveFlag_TC>:
; {
 8015008: b480         	push	{r7}
 801500a: b083         	sub	sp, #0xc
 801500c: af00         	add	r7, sp, #0x0
 801500e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_TC) == (USART_SR_TC));
 8015010: 687b         	ldr	r3, [r7, #0x4]
 8015012: 681b         	ldr	r3, [r3]
 8015014: f003 0340    	and	r3, r3, #0x40
 8015018: 2b40         	cmp	r3, #0x40
 801501a: bf0c         	ite	eq
 801501c: 2301         	moveq	r3, #0x1
 801501e: 2300         	movne	r3, #0x0
 8015020: b2db         	uxtb	r3, r3
; }
 8015022: 4618         	mov	r0, r3
 8015024: 370c         	adds	r7, #0xc
 8015026: 46bd         	mov	sp, r7
 8015028: bc80         	pop	{r7}
 801502a: 4770         	bx	lr

0801502c <LL_USART_IsActiveFlag_TXE>:
; {
 801502c: b480         	push	{r7}
 801502e: b083         	sub	sp, #0xc
 8015030: af00         	add	r7, sp, #0x0
 8015032: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_TXE) == (USART_SR_TXE));
 8015034: 687b         	ldr	r3, [r7, #0x4]
 8015036: 681b         	ldr	r3, [r3]
 8015038: f003 0380    	and	r3, r3, #0x80
 801503c: 2b80         	cmp	r3, #0x80
 801503e: bf0c         	ite	eq
 8015040: 2301         	moveq	r3, #0x1
 8015042: 2300         	movne	r3, #0x0
 8015044: b2db         	uxtb	r3, r3
; }
 8015046: 4618         	mov	r0, r3
 8015048: 370c         	adds	r7, #0xc
 801504a: 46bd         	mov	sp, r7
 801504c: bc80         	pop	{r7}
 801504e: 4770         	bx	lr

08015050 <LL_USART_IsActiveFlag_LBD>:
; {
 8015050: b480         	push	{r7}
 8015052: b083         	sub	sp, #0xc
 8015054: af00         	add	r7, sp, #0x0
 8015056: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_LBD) == (USART_SR_LBD));
 8015058: 687b         	ldr	r3, [r7, #0x4]
 801505a: 681b         	ldr	r3, [r3]
 801505c: f403 7380    	and	r3, r3, #0x100
 8015060: f5b3 7f80    	cmp.w	r3, #0x100
 8015064: bf0c         	ite	eq
 8015066: 2301         	moveq	r3, #0x1
 8015068: 2300         	movne	r3, #0x0
 801506a: b2db         	uxtb	r3, r3
; }
 801506c: 4618         	mov	r0, r3
 801506e: 370c         	adds	r7, #0xc
 8015070: 46bd         	mov	sp, r7
 8015072: bc80         	pop	{r7}
 8015074: 4770         	bx	lr

08015076 <LL_USART_ClearFlag_PE>:
; {
 8015076: b480         	push	{r7}
 8015078: b085         	sub	sp, #0x14
 801507a: af00         	add	r7, sp, #0x0
 801507c: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 801507e: 687b         	ldr	r3, [r7, #0x4]
 8015080: 681b         	ldr	r3, [r3]
 8015082: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8015084: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 8015086: 687b         	ldr	r3, [r7, #0x4]
 8015088: 685b         	ldr	r3, [r3, #0x4]
 801508a: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801508c: 68fb         	ldr	r3, [r7, #0xc]
; }
 801508e: bf00         	nop
 8015090: 3714         	adds	r7, #0x14
 8015092: 46bd         	mov	sp, r7
 8015094: bc80         	pop	{r7}
 8015096: 4770         	bx	lr

08015098 <LL_USART_ClearFlag_FE>:
; {
 8015098: b480         	push	{r7}
 801509a: b085         	sub	sp, #0x14
 801509c: af00         	add	r7, sp, #0x0
 801509e: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 80150a0: 687b         	ldr	r3, [r7, #0x4]
 80150a2: 681b         	ldr	r3, [r3]
 80150a4: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80150a6: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 80150a8: 687b         	ldr	r3, [r7, #0x4]
 80150aa: 685b         	ldr	r3, [r3, #0x4]
 80150ac: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80150ae: 68fb         	ldr	r3, [r7, #0xc]
; }
 80150b0: bf00         	nop
 80150b2: 3714         	adds	r7, #0x14
 80150b4: 46bd         	mov	sp, r7
 80150b6: bc80         	pop	{r7}
 80150b8: 4770         	bx	lr

080150ba <LL_USART_ClearFlag_NE>:
; {
 80150ba: b480         	push	{r7}
 80150bc: b085         	sub	sp, #0x14
 80150be: af00         	add	r7, sp, #0x0
 80150c0: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 80150c2: 687b         	ldr	r3, [r7, #0x4]
 80150c4: 681b         	ldr	r3, [r3]
 80150c6: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80150c8: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 80150ca: 687b         	ldr	r3, [r7, #0x4]
 80150cc: 685b         	ldr	r3, [r3, #0x4]
 80150ce: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80150d0: 68fb         	ldr	r3, [r7, #0xc]
; }
 80150d2: bf00         	nop
 80150d4: 3714         	adds	r7, #0x14
 80150d6: 46bd         	mov	sp, r7
 80150d8: bc80         	pop	{r7}
 80150da: 4770         	bx	lr

080150dc <LL_USART_ClearFlag_ORE>:
; {
 80150dc: b480         	push	{r7}
 80150de: b085         	sub	sp, #0x14
 80150e0: af00         	add	r7, sp, #0x0
 80150e2: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 80150e4: 687b         	ldr	r3, [r7, #0x4]
 80150e6: 681b         	ldr	r3, [r3]
 80150e8: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80150ea: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 80150ec: 687b         	ldr	r3, [r7, #0x4]
 80150ee: 685b         	ldr	r3, [r3, #0x4]
 80150f0: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80150f2: 68fb         	ldr	r3, [r7, #0xc]
; }
 80150f4: bf00         	nop
 80150f6: 3714         	adds	r7, #0x14
 80150f8: 46bd         	mov	sp, r7
 80150fa: bc80         	pop	{r7}
 80150fc: 4770         	bx	lr

080150fe <LL_USART_ClearFlag_IDLE>:
; {
 80150fe: b480         	push	{r7}
 8015100: b085         	sub	sp, #0x14
 8015102: af00         	add	r7, sp, #0x0
 8015104: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 8015106: 687b         	ldr	r3, [r7, #0x4]
 8015108: 681b         	ldr	r3, [r3]
 801510a: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801510c: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 801510e: 687b         	ldr	r3, [r7, #0x4]
 8015110: 685b         	ldr	r3, [r3, #0x4]
 8015112: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8015114: 68fb         	ldr	r3, [r7, #0xc]
; }
 8015116: bf00         	nop
 8015118: 3714         	adds	r7, #0x14
 801511a: 46bd         	mov	sp, r7
 801511c: bc80         	pop	{r7}
 801511e: 4770         	bx	lr

08015120 <LL_USART_ClearFlag_TC>:
; {
 8015120: b480         	push	{r7}
 8015122: b083         	sub	sp, #0xc
 8015124: af00         	add	r7, sp, #0x0
 8015126: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_TC));
 8015128: 687b         	ldr	r3, [r7, #0x4]
 801512a: f06f 0240    	mvn	r2, #0x40
 801512e: 601a         	str	r2, [r3]
; }
 8015130: bf00         	nop
 8015132: 370c         	adds	r7, #0xc
 8015134: 46bd         	mov	sp, r7
 8015136: bc80         	pop	{r7}
 8015138: 4770         	bx	lr

0801513a <LL_USART_ClearFlag_RXNE>:
; {
 801513a: b480         	push	{r7}
 801513c: b083         	sub	sp, #0xc
 801513e: af00         	add	r7, sp, #0x0
 8015140: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_RXNE));
 8015142: 687b         	ldr	r3, [r7, #0x4]
 8015144: f06f 0220    	mvn	r2, #0x20
 8015148: 601a         	str	r2, [r3]
; }
 801514a: bf00         	nop
 801514c: 370c         	adds	r7, #0xc
 801514e: 46bd         	mov	sp, r7
 8015150: bc80         	pop	{r7}
 8015152: 4770         	bx	lr

08015154 <LL_USART_ClearFlag_LBD>:
; {
 8015154: b480         	push	{r7}
 8015156: b083         	sub	sp, #0xc
 8015158: af00         	add	r7, sp, #0x0
 801515a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_LBD));
 801515c: 687b         	ldr	r3, [r7, #0x4]
 801515e: f46f 7280    	mvn	r2, #0x100
 8015162: 601a         	str	r2, [r3]
; }
 8015164: bf00         	nop
 8015166: 370c         	adds	r7, #0xc
 8015168: 46bd         	mov	sp, r7
 801516a: bc80         	pop	{r7}
 801516c: 4770         	bx	lr

0801516e <LL_USART_EnableIT_IDLE>:
; {
 801516e: b480         	push	{r7}
 8015170: b089         	sub	sp, #0x24
 8015172: af00         	add	r7, sp, #0x0
 8015174: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8015176: 687b         	ldr	r3, [r7, #0x4]
 8015178: 330c         	adds	r3, #0xc
 801517a: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801517c: 68fb         	ldr	r3, [r7, #0xc]
 801517e: e853 3f00    	ldrex	r3, [r3]
 8015182: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8015184: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8015186: f043 0310    	orr	r3, r3, #0x10
 801518a: 61fb         	str	r3, [r7, #0x1c]
 801518c: 687b         	ldr	r3, [r7, #0x4]
 801518e: 330c         	adds	r3, #0xc
 8015190: 69fa         	ldr	r2, [r7, #0x1c]
 8015192: 61ba         	str	r2, [r7, #0x18]
 8015194: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8015196: 6979         	ldr	r1, [r7, #0x14]
 8015198: 69ba         	ldr	r2, [r7, #0x18]
 801519a: e841 2300    	strex	r3, r2, [r1]
 801519e: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80151a0: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 80151a2: 2b00         	cmp	r3, #0x0
 80151a4: d1e7         	bne	0x8015176 <LL_USART_EnableIT_IDLE+0x8> @ imm = #-0x32
; }
 80151a6: bf00         	nop
 80151a8: bf00         	nop
 80151aa: 3724         	adds	r7, #0x24
 80151ac: 46bd         	mov	sp, r7
 80151ae: bc80         	pop	{r7}
 80151b0: 4770         	bx	lr

080151b2 <LL_USART_EnableIT_RXNE>:
; {
 80151b2: b480         	push	{r7}
 80151b4: b089         	sub	sp, #0x24
 80151b6: af00         	add	r7, sp, #0x0
 80151b8: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 80151ba: 687b         	ldr	r3, [r7, #0x4]
 80151bc: 330c         	adds	r3, #0xc
 80151be: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80151c0: 68fb         	ldr	r3, [r7, #0xc]
 80151c2: e853 3f00    	ldrex	r3, [r3]
 80151c6: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80151c8: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 80151ca: f043 0320    	orr	r3, r3, #0x20
 80151ce: 61fb         	str	r3, [r7, #0x1c]
 80151d0: 687b         	ldr	r3, [r7, #0x4]
 80151d2: 330c         	adds	r3, #0xc
 80151d4: 69fa         	ldr	r2, [r7, #0x1c]
 80151d6: 61ba         	str	r2, [r7, #0x18]
 80151d8: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80151da: 6979         	ldr	r1, [r7, #0x14]
 80151dc: 69ba         	ldr	r2, [r7, #0x18]
 80151de: e841 2300    	strex	r3, r2, [r1]
 80151e2: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80151e4: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 80151e6: 2b00         	cmp	r3, #0x0
 80151e8: d1e7         	bne	0x80151ba <LL_USART_EnableIT_RXNE+0x8> @ imm = #-0x32
; }
 80151ea: bf00         	nop
 80151ec: bf00         	nop
 80151ee: 3724         	adds	r7, #0x24
 80151f0: 46bd         	mov	sp, r7
 80151f2: bc80         	pop	{r7}
 80151f4: 4770         	bx	lr

080151f6 <LL_USART_EnableIT_TC>:
; {
 80151f6: b480         	push	{r7}
 80151f8: b089         	sub	sp, #0x24
 80151fa: af00         	add	r7, sp, #0x0
 80151fc: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 80151fe: 687b         	ldr	r3, [r7, #0x4]
 8015200: 330c         	adds	r3, #0xc
 8015202: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8015204: 68fb         	ldr	r3, [r7, #0xc]
 8015206: e853 3f00    	ldrex	r3, [r3]
 801520a: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801520c: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 801520e: f043 0340    	orr	r3, r3, #0x40
 8015212: 61fb         	str	r3, [r7, #0x1c]
 8015214: 687b         	ldr	r3, [r7, #0x4]
 8015216: 330c         	adds	r3, #0xc
 8015218: 69fa         	ldr	r2, [r7, #0x1c]
 801521a: 61ba         	str	r2, [r7, #0x18]
 801521c: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801521e: 6979         	ldr	r1, [r7, #0x14]
 8015220: 69ba         	ldr	r2, [r7, #0x18]
 8015222: e841 2300    	strex	r3, r2, [r1]
 8015226: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8015228: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 801522a: 2b00         	cmp	r3, #0x0
 801522c: d1e7         	bne	0x80151fe <LL_USART_EnableIT_TC+0x8> @ imm = #-0x32
; }
 801522e: bf00         	nop
 8015230: bf00         	nop
 8015232: 3724         	adds	r7, #0x24
 8015234: 46bd         	mov	sp, r7
 8015236: bc80         	pop	{r7}
 8015238: 4770         	bx	lr

0801523a <LL_USART_EnableIT_PE>:
; {
 801523a: b480         	push	{r7}
 801523c: b089         	sub	sp, #0x24
 801523e: af00         	add	r7, sp, #0x0
 8015240: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 8015242: 687b         	ldr	r3, [r7, #0x4]
 8015244: 330c         	adds	r3, #0xc
 8015246: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8015248: 68fb         	ldr	r3, [r7, #0xc]
 801524a: e853 3f00    	ldrex	r3, [r3]
 801524e: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8015250: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 8015252: f443 7380    	orr	r3, r3, #0x100
 8015256: 61fb         	str	r3, [r7, #0x1c]
 8015258: 687b         	ldr	r3, [r7, #0x4]
 801525a: 330c         	adds	r3, #0xc
 801525c: 69fa         	ldr	r2, [r7, #0x1c]
 801525e: 61ba         	str	r2, [r7, #0x18]
 8015260: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8015262: 6979         	ldr	r1, [r7, #0x14]
 8015264: 69ba         	ldr	r2, [r7, #0x18]
 8015266: e841 2300    	strex	r3, r2, [r1]
 801526a: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801526c: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 801526e: 2b00         	cmp	r3, #0x0
 8015270: d1e7         	bne	0x8015242 <LL_USART_EnableIT_PE+0x8> @ imm = #-0x32
; }
 8015272: bf00         	nop
 8015274: bf00         	nop
 8015276: 3724         	adds	r7, #0x24
 8015278: 46bd         	mov	sp, r7
 801527a: bc80         	pop	{r7}
 801527c: 4770         	bx	lr

0801527e <LL_USART_EnableIT_LBD>:
; {
 801527e: b480         	push	{r7}
 8015280: b083         	sub	sp, #0xc
 8015282: af00         	add	r7, sp, #0x0
 8015284: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR2, USART_CR2_LBDIE);
 8015286: 687b         	ldr	r3, [r7, #0x4]
 8015288: 691b         	ldr	r3, [r3, #0x10]
 801528a: f043 0240    	orr	r2, r3, #0x40
 801528e: 687b         	ldr	r3, [r7, #0x4]
 8015290: 611a         	str	r2, [r3, #0x10]
; }
 8015292: bf00         	nop
 8015294: 370c         	adds	r7, #0xc
 8015296: 46bd         	mov	sp, r7
 8015298: bc80         	pop	{r7}
 801529a: 4770         	bx	lr

0801529c <LL_USART_EnableIT_ERROR>:
; {
 801529c: b480         	push	{r7}
 801529e: b089         	sub	sp, #0x24
 80152a0: af00         	add	r7, sp, #0x0
 80152a2: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 80152a4: 687b         	ldr	r3, [r7, #0x4]
 80152a6: 3314         	adds	r3, #0x14
 80152a8: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80152aa: 68fb         	ldr	r3, [r7, #0xc]
 80152ac: e853 3f00    	ldrex	r3, [r3]
 80152b0: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80152b2: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 80152b4: f043 0301    	orr	r3, r3, #0x1
 80152b8: 61fb         	str	r3, [r7, #0x1c]
 80152ba: 687b         	ldr	r3, [r7, #0x4]
 80152bc: 3314         	adds	r3, #0x14
 80152be: 69fa         	ldr	r2, [r7, #0x1c]
 80152c0: 61ba         	str	r2, [r7, #0x18]
 80152c2: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80152c4: 6979         	ldr	r1, [r7, #0x14]
 80152c6: 69ba         	ldr	r2, [r7, #0x18]
 80152c8: e841 2300    	strex	r3, r2, [r1]
 80152cc: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80152ce: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 80152d0: 2b00         	cmp	r3, #0x0
 80152d2: d1e7         	bne	0x80152a4 <LL_USART_EnableIT_ERROR+0x8> @ imm = #-0x32
; }
 80152d4: bf00         	nop
 80152d6: bf00         	nop
 80152d8: 3724         	adds	r7, #0x24
 80152da: 46bd         	mov	sp, r7
 80152dc: bc80         	pop	{r7}
 80152de: 4770         	bx	lr

080152e0 <LL_USART_DisableIT_IDLE>:
; {
 80152e0: b480         	push	{r7}
 80152e2: b089         	sub	sp, #0x24
 80152e4: af00         	add	r7, sp, #0x0
 80152e6: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 80152e8: 687b         	ldr	r3, [r7, #0x4]
 80152ea: 330c         	adds	r3, #0xc
 80152ec: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80152ee: 68fb         	ldr	r3, [r7, #0xc]
 80152f0: e853 3f00    	ldrex	r3, [r3]
 80152f4: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80152f6: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 80152f8: f023 0310    	bic	r3, r3, #0x10
 80152fc: 61fb         	str	r3, [r7, #0x1c]
 80152fe: 687b         	ldr	r3, [r7, #0x4]
 8015300: 330c         	adds	r3, #0xc
 8015302: 69fa         	ldr	r2, [r7, #0x1c]
 8015304: 61ba         	str	r2, [r7, #0x18]
 8015306: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8015308: 6979         	ldr	r1, [r7, #0x14]
 801530a: 69ba         	ldr	r2, [r7, #0x18]
 801530c: e841 2300    	strex	r3, r2, [r1]
 8015310: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8015312: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8015314: 2b00         	cmp	r3, #0x0
 8015316: d1e7         	bne	0x80152e8 <LL_USART_DisableIT_IDLE+0x8> @ imm = #-0x32
; }
 8015318: bf00         	nop
 801531a: bf00         	nop
 801531c: 3724         	adds	r7, #0x24
 801531e: 46bd         	mov	sp, r7
 8015320: bc80         	pop	{r7}
 8015322: 4770         	bx	lr

08015324 <LL_USART_DisableIT_RXNE>:
; {
 8015324: b480         	push	{r7}
 8015326: b089         	sub	sp, #0x24
 8015328: af00         	add	r7, sp, #0x0
 801532a: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 801532c: 687b         	ldr	r3, [r7, #0x4]
 801532e: 330c         	adds	r3, #0xc
 8015330: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8015332: 68fb         	ldr	r3, [r7, #0xc]
 8015334: e853 3f00    	ldrex	r3, [r3]
 8015338: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801533a: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 801533c: f023 0320    	bic	r3, r3, #0x20
 8015340: 61fb         	str	r3, [r7, #0x1c]
 8015342: 687b         	ldr	r3, [r7, #0x4]
 8015344: 330c         	adds	r3, #0xc
 8015346: 69fa         	ldr	r2, [r7, #0x1c]
 8015348: 61ba         	str	r2, [r7, #0x18]
 801534a: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801534c: 6979         	ldr	r1, [r7, #0x14]
 801534e: 69ba         	ldr	r2, [r7, #0x18]
 8015350: e841 2300    	strex	r3, r2, [r1]
 8015354: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8015356: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8015358: 2b00         	cmp	r3, #0x0
 801535a: d1e7         	bne	0x801532c <LL_USART_DisableIT_RXNE+0x8> @ imm = #-0x32
; }
 801535c: bf00         	nop
 801535e: bf00         	nop
 8015360: 3724         	adds	r7, #0x24
 8015362: 46bd         	mov	sp, r7
 8015364: bc80         	pop	{r7}
 8015366: 4770         	bx	lr

08015368 <LL_USART_DisableIT_TC>:
; {
 8015368: b480         	push	{r7}
 801536a: b089         	sub	sp, #0x24
 801536c: af00         	add	r7, sp, #0x0
 801536e: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 8015370: 687b         	ldr	r3, [r7, #0x4]
 8015372: 330c         	adds	r3, #0xc
 8015374: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8015376: 68fb         	ldr	r3, [r7, #0xc]
 8015378: e853 3f00    	ldrex	r3, [r3]
 801537c: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801537e: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 8015380: f023 0340    	bic	r3, r3, #0x40
 8015384: 61fb         	str	r3, [r7, #0x1c]
 8015386: 687b         	ldr	r3, [r7, #0x4]
 8015388: 330c         	adds	r3, #0xc
 801538a: 69fa         	ldr	r2, [r7, #0x1c]
 801538c: 61ba         	str	r2, [r7, #0x18]
 801538e: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8015390: 6979         	ldr	r1, [r7, #0x14]
 8015392: 69ba         	ldr	r2, [r7, #0x18]
 8015394: e841 2300    	strex	r3, r2, [r1]
 8015398: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801539a: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 801539c: 2b00         	cmp	r3, #0x0
 801539e: d1e7         	bne	0x8015370 <LL_USART_DisableIT_TC+0x8> @ imm = #-0x32
; }
 80153a0: bf00         	nop
 80153a2: bf00         	nop
 80153a4: 3724         	adds	r7, #0x24
 80153a6: 46bd         	mov	sp, r7
 80153a8: bc80         	pop	{r7}
 80153aa: 4770         	bx	lr

080153ac <LL_USART_DisableIT_PE>:
; {
 80153ac: b480         	push	{r7}
 80153ae: b089         	sub	sp, #0x24
 80153b0: af00         	add	r7, sp, #0x0
 80153b2: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 80153b4: 687b         	ldr	r3, [r7, #0x4]
 80153b6: 330c         	adds	r3, #0xc
 80153b8: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80153ba: 68fb         	ldr	r3, [r7, #0xc]
 80153bc: e853 3f00    	ldrex	r3, [r3]
 80153c0: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80153c2: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 80153c4: f423 7380    	bic	r3, r3, #0x100
 80153c8: 61fb         	str	r3, [r7, #0x1c]
 80153ca: 687b         	ldr	r3, [r7, #0x4]
 80153cc: 330c         	adds	r3, #0xc
 80153ce: 69fa         	ldr	r2, [r7, #0x1c]
 80153d0: 61ba         	str	r2, [r7, #0x18]
 80153d2: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80153d4: 6979         	ldr	r1, [r7, #0x14]
 80153d6: 69ba         	ldr	r2, [r7, #0x18]
 80153d8: e841 2300    	strex	r3, r2, [r1]
 80153dc: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80153de: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 80153e0: 2b00         	cmp	r3, #0x0
 80153e2: d1e7         	bne	0x80153b4 <LL_USART_DisableIT_PE+0x8> @ imm = #-0x32
; }
 80153e4: bf00         	nop
 80153e6: bf00         	nop
 80153e8: 3724         	adds	r7, #0x24
 80153ea: 46bd         	mov	sp, r7
 80153ec: bc80         	pop	{r7}
 80153ee: 4770         	bx	lr

080153f0 <LL_USART_DisableIT_LBD>:
; {
 80153f0: b480         	push	{r7}
 80153f2: b083         	sub	sp, #0xc
 80153f4: af00         	add	r7, sp, #0x0
 80153f6: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR2, USART_CR2_LBDIE);
 80153f8: 687b         	ldr	r3, [r7, #0x4]
 80153fa: 691b         	ldr	r3, [r3, #0x10]
 80153fc: f023 0240    	bic	r2, r3, #0x40
 8015400: 687b         	ldr	r3, [r7, #0x4]
 8015402: 611a         	str	r2, [r3, #0x10]
; }
 8015404: bf00         	nop
 8015406: 370c         	adds	r7, #0xc
 8015408: 46bd         	mov	sp, r7
 801540a: bc80         	pop	{r7}
 801540c: 4770         	bx	lr

0801540e <LL_USART_DisableIT_ERROR>:
; {
 801540e: b480         	push	{r7}
 8015410: b089         	sub	sp, #0x24
 8015412: af00         	add	r7, sp, #0x0
 8015414: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8015416: 687b         	ldr	r3, [r7, #0x4]
 8015418: 3314         	adds	r3, #0x14
 801541a: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801541c: 68fb         	ldr	r3, [r7, #0xc]
 801541e: e853 3f00    	ldrex	r3, [r3]
 8015422: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8015424: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8015426: f023 0301    	bic	r3, r3, #0x1
 801542a: 61fb         	str	r3, [r7, #0x1c]
 801542c: 687b         	ldr	r3, [r7, #0x4]
 801542e: 3314         	adds	r3, #0x14
 8015430: 69fa         	ldr	r2, [r7, #0x1c]
 8015432: 61ba         	str	r2, [r7, #0x18]
 8015434: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8015436: 6979         	ldr	r1, [r7, #0x14]
 8015438: 69ba         	ldr	r2, [r7, #0x18]
 801543a: e841 2300    	strex	r3, r2, [r1]
 801543e: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8015440: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8015442: 2b00         	cmp	r3, #0x0
 8015444: d1e7         	bne	0x8015416 <LL_USART_DisableIT_ERROR+0x8> @ imm = #-0x32
; }
 8015446: bf00         	nop
 8015448: bf00         	nop
 801544a: 3724         	adds	r7, #0x24
 801544c: 46bd         	mov	sp, r7
 801544e: bc80         	pop	{r7}
 8015450: 4770         	bx	lr

08015452 <LL_USART_IsEnabledIT_IDLE>:
; {
 8015452: b480         	push	{r7}
 8015454: b083         	sub	sp, #0xc
 8015456: af00         	add	r7, sp, #0x0
 8015458: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE));
 801545a: 687b         	ldr	r3, [r7, #0x4]
 801545c: 68db         	ldr	r3, [r3, #0xc]
 801545e: f003 0310    	and	r3, r3, #0x10
 8015462: 2b10         	cmp	r3, #0x10
 8015464: bf0c         	ite	eq
 8015466: 2301         	moveq	r3, #0x1
 8015468: 2300         	movne	r3, #0x0
 801546a: b2db         	uxtb	r3, r3
; }
 801546c: 4618         	mov	r0, r3
 801546e: 370c         	adds	r7, #0xc
 8015470: 46bd         	mov	sp, r7
 8015472: bc80         	pop	{r7}
 8015474: 4770         	bx	lr

08015476 <LL_USART_IsEnabledIT_RXNE>:
; {
 8015476: b480         	push	{r7}
 8015478: b083         	sub	sp, #0xc
 801547a: af00         	add	r7, sp, #0x0
 801547c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE));
 801547e: 687b         	ldr	r3, [r7, #0x4]
 8015480: 68db         	ldr	r3, [r3, #0xc]
 8015482: f003 0320    	and	r3, r3, #0x20
 8015486: 2b20         	cmp	r3, #0x20
 8015488: bf0c         	ite	eq
 801548a: 2301         	moveq	r3, #0x1
 801548c: 2300         	movne	r3, #0x0
 801548e: b2db         	uxtb	r3, r3
; }
 8015490: 4618         	mov	r0, r3
 8015492: 370c         	adds	r7, #0xc
 8015494: 46bd         	mov	sp, r7
 8015496: bc80         	pop	{r7}
 8015498: 4770         	bx	lr

0801549a <LL_USART_IsEnabledIT_TC>:
; {
 801549a: b480         	push	{r7}
 801549c: b083         	sub	sp, #0xc
 801549e: af00         	add	r7, sp, #0x0
 80154a0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_TCIE) == (USART_CR1_TCIE));
 80154a2: 687b         	ldr	r3, [r7, #0x4]
 80154a4: 68db         	ldr	r3, [r3, #0xc]
 80154a6: f003 0340    	and	r3, r3, #0x40
 80154aa: 2b40         	cmp	r3, #0x40
 80154ac: bf0c         	ite	eq
 80154ae: 2301         	moveq	r3, #0x1
 80154b0: 2300         	movne	r3, #0x0
 80154b2: b2db         	uxtb	r3, r3
; }
 80154b4: 4618         	mov	r0, r3
 80154b6: 370c         	adds	r7, #0xc
 80154b8: 46bd         	mov	sp, r7
 80154ba: bc80         	pop	{r7}
 80154bc: 4770         	bx	lr

080154be <LL_USART_EnableDMAReq_RX>:
; {
 80154be: b480         	push	{r7}
 80154c0: b089         	sub	sp, #0x24
 80154c2: af00         	add	r7, sp, #0x0
 80154c4: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 80154c6: 687b         	ldr	r3, [r7, #0x4]
 80154c8: 3314         	adds	r3, #0x14
 80154ca: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80154cc: 68fb         	ldr	r3, [r7, #0xc]
 80154ce: e853 3f00    	ldrex	r3, [r3]
 80154d2: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80154d4: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 80154d6: f043 0340    	orr	r3, r3, #0x40
 80154da: 61fb         	str	r3, [r7, #0x1c]
 80154dc: 687b         	ldr	r3, [r7, #0x4]
 80154de: 3314         	adds	r3, #0x14
 80154e0: 69fa         	ldr	r2, [r7, #0x1c]
 80154e2: 61ba         	str	r2, [r7, #0x18]
 80154e4: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80154e6: 6979         	ldr	r1, [r7, #0x14]
 80154e8: 69ba         	ldr	r2, [r7, #0x18]
 80154ea: e841 2300    	strex	r3, r2, [r1]
 80154ee: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80154f0: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 80154f2: 2b00         	cmp	r3, #0x0
 80154f4: d1e7         	bne	0x80154c6 <LL_USART_EnableDMAReq_RX+0x8> @ imm = #-0x32
; }
 80154f6: bf00         	nop
 80154f8: bf00         	nop
 80154fa: 3724         	adds	r7, #0x24
 80154fc: 46bd         	mov	sp, r7
 80154fe: bc80         	pop	{r7}
 8015500: 4770         	bx	lr

08015502 <LL_USART_EnableDMAReq_TX>:
; {
 8015502: b480         	push	{r7}
 8015504: b089         	sub	sp, #0x24
 8015506: af00         	add	r7, sp, #0x0
 8015508: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 801550a: 687b         	ldr	r3, [r7, #0x4]
 801550c: 3314         	adds	r3, #0x14
 801550e: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8015510: 68fb         	ldr	r3, [r7, #0xc]
 8015512: e853 3f00    	ldrex	r3, [r3]
 8015516: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8015518: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 801551a: f043 0380    	orr	r3, r3, #0x80
 801551e: 61fb         	str	r3, [r7, #0x1c]
 8015520: 687b         	ldr	r3, [r7, #0x4]
 8015522: 3314         	adds	r3, #0x14
 8015524: 69fa         	ldr	r2, [r7, #0x1c]
 8015526: 61ba         	str	r2, [r7, #0x18]
 8015528: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801552a: 6979         	ldr	r1, [r7, #0x14]
 801552c: 69ba         	ldr	r2, [r7, #0x18]
 801552e: e841 2300    	strex	r3, r2, [r1]
 8015532: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8015534: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 8015536: 2b00         	cmp	r3, #0x0
 8015538: d1e7         	bne	0x801550a <LL_USART_EnableDMAReq_TX+0x8> @ imm = #-0x32
; }
 801553a: bf00         	nop
 801553c: bf00         	nop
 801553e: 3724         	adds	r7, #0x24
 8015540: 46bd         	mov	sp, r7
 8015542: bc80         	pop	{r7}
 8015544: 4770         	bx	lr

08015546 <LL_USART_DisableDMAReq_TX>:
; {
 8015546: b480         	push	{r7}
 8015548: b089         	sub	sp, #0x24
 801554a: af00         	add	r7, sp, #0x0
 801554c: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 801554e: 687b         	ldr	r3, [r7, #0x4]
 8015550: 3314         	adds	r3, #0x14
 8015552: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8015554: 68fb         	ldr	r3, [r7, #0xc]
 8015556: e853 3f00    	ldrex	r3, [r3]
 801555a: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801555c: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 801555e: f023 0380    	bic	r3, r3, #0x80
 8015562: 61fb         	str	r3, [r7, #0x1c]
 8015564: 687b         	ldr	r3, [r7, #0x4]
 8015566: 3314         	adds	r3, #0x14
 8015568: 69fa         	ldr	r2, [r7, #0x1c]
 801556a: 61ba         	str	r2, [r7, #0x18]
 801556c: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801556e: 6979         	ldr	r1, [r7, #0x14]
 8015570: 69ba         	ldr	r2, [r7, #0x18]
 8015572: e841 2300    	strex	r3, r2, [r1]
 8015576: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8015578: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 801557a: 2b00         	cmp	r3, #0x0
 801557c: d1e7         	bne	0x801554e <LL_USART_DisableDMAReq_TX+0x8> @ imm = #-0x32
; }
 801557e: bf00         	nop
 8015580: bf00         	nop
 8015582: 3724         	adds	r7, #0x24
 8015584: 46bd         	mov	sp, r7
 8015586: bc80         	pop	{r7}
 8015588: 4770         	bx	lr

0801558a <LL_USART_DMA_GetRegAddr>:
; {
 801558a: b480         	push	{r7}
 801558c: b083         	sub	sp, #0xc
 801558e: af00         	add	r7, sp, #0x0
 8015590: 6078         	str	r0, [r7, #0x4]
;   return ((uint32_t) &(USARTx->DR));
 8015592: 687b         	ldr	r3, [r7, #0x4]
 8015594: 3304         	adds	r3, #0x4
; }
 8015596: 4618         	mov	r0, r3
 8015598: 370c         	adds	r7, #0xc
 801559a: 46bd         	mov	sp, r7
 801559c: bc80         	pop	{r7}
 801559e: 4770         	bx	lr

080155a0 <LL_USART_ReceiveData8>:
; {
 80155a0: b480         	push	{r7}
 80155a2: b083         	sub	sp, #0xc
 80155a4: af00         	add	r7, sp, #0x0
 80155a6: 6078         	str	r0, [r7, #0x4]
;   return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
 80155a8: 687b         	ldr	r3, [r7, #0x4]
 80155aa: 685b         	ldr	r3, [r3, #0x4]
 80155ac: b2db         	uxtb	r3, r3
; }
 80155ae: 4618         	mov	r0, r3
 80155b0: 370c         	adds	r7, #0xc
 80155b2: 46bd         	mov	sp, r7
 80155b4: bc80         	pop	{r7}
 80155b6: 4770         	bx	lr

080155b8 <LL_USART_TransmitData8>:
; {
 80155b8: b480         	push	{r7}
 80155ba: b083         	sub	sp, #0xc
 80155bc: af00         	add	r7, sp, #0x0
 80155be: 6078         	str	r0, [r7, #0x4]
 80155c0: 460b         	mov	r3, r1
 80155c2: 70fb         	strb	r3, [r7, #0x3]
;   USARTx->DR = Value;
 80155c4: 78fa         	ldrb	r2, [r7, #0x3]
 80155c6: 687b         	ldr	r3, [r7, #0x4]
 80155c8: 605a         	str	r2, [r3, #0x4]
; }
 80155ca: bf00         	nop
 80155cc: 370c         	adds	r7, #0xc
 80155ce: 46bd         	mov	sp, r7
 80155d0: bc80         	pop	{r7}
 80155d2: 4770         	bx	lr

080155d4 <z_log_msg_runtime_create>:
; {
 80155d4: b580         	push	{r7, lr}
 80155d6: b08a         	sub	sp, #0x28
 80155d8: af04         	add	r7, sp, #0x10
 80155da: 60b9         	str	r1, [r7, #0x8]
 80155dc: 607b         	str	r3, [r7, #0x4]
 80155de: 4603         	mov	r3, r0
 80155e0: 73fb         	strb	r3, [r7, #0xf]
 80155e2: 4613         	mov	r3, r2
 80155e4: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80155e6: f107 032c    	add.w	r3, r7, #0x2c
 80155ea: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80155ec: 7bba         	ldrb	r2, [r7, #0xe]
 80155ee: 7bf8         	ldrb	r0, [r7, #0xf]
 80155f0: 697b         	ldr	r3, [r7, #0x14]
 80155f2: 9303         	str	r3, [sp, #0xc]
 80155f4: 6abb         	ldr	r3, [r7, #0x28]
 80155f6: 9302         	str	r3, [sp, #0x8]
 80155f8: 6a7b         	ldr	r3, [r7, #0x24]
 80155fa: 9301         	str	r3, [sp, #0x4]
 80155fc: 6a3b         	ldr	r3, [r7, #0x20]
 80155fe: 9300         	str	r3, [sp]
 8015600: 687b         	ldr	r3, [r7, #0x4]
 8015602: 68b9         	ldr	r1, [r7, #0x8]
 8015604: f7ec fda2    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0x134bc
; }
 8015608: bf00         	nop
 801560a: 3718         	adds	r7, #0x18
 801560c: 46bd         	mov	sp, r7
 801560e: bd80         	pop	{r7, pc}

08015610 <uart_stm32_set_parity>:
; {
 8015610: b580         	push	{r7, lr}
 8015612: b084         	sub	sp, #0x10
 8015614: af00         	add	r7, sp, #0x0
 8015616: 6078         	str	r0, [r7, #0x4]
 8015618: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801561a: 687b         	ldr	r3, [r7, #0x4]
 801561c: 685b         	ldr	r3, [r3, #0x4]
 801561e: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetParity(config->usart, parity);
 8015620: 68fb         	ldr	r3, [r7, #0xc]
 8015622: 681b         	ldr	r3, [r3]
 8015624: 6839         	ldr	r1, [r7]
 8015626: 4618         	mov	r0, r3
 8015628: f7ff fbc7    	bl	0x8014dba <LL_USART_SetParity> @ imm = #-0x872
; }
 801562c: bf00         	nop
 801562e: 3710         	adds	r7, #0x10
 8015630: 46bd         	mov	sp, r7
 8015632: bd80         	pop	{r7, pc}

08015634 <uart_stm32_get_parity>:
; {
 8015634: b580         	push	{r7, lr}
 8015636: b084         	sub	sp, #0x10
 8015638: af00         	add	r7, sp, #0x0
 801563a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801563c: 687b         	ldr	r3, [r7, #0x4]
 801563e: 685b         	ldr	r3, [r3, #0x4]
 8015640: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetParity(config->usart);
 8015642: 68fb         	ldr	r3, [r7, #0xc]
 8015644: 681b         	ldr	r3, [r3]
 8015646: 4618         	mov	r0, r3
 8015648: f7ff fbc9    	bl	0x8014dde <LL_USART_GetParity> @ imm = #-0x86e
 801564c: 4603         	mov	r3, r0
; }
 801564e: 4618         	mov	r0, r3
 8015650: 3710         	adds	r7, #0x10
 8015652: 46bd         	mov	sp, r7
 8015654: bd80         	pop	{r7, pc}

08015656 <uart_stm32_set_stopbits>:
; {
 8015656: b580         	push	{r7, lr}
 8015658: b084         	sub	sp, #0x10
 801565a: af00         	add	r7, sp, #0x0
 801565c: 6078         	str	r0, [r7, #0x4]
 801565e: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8015660: 687b         	ldr	r3, [r7, #0x4]
 8015662: 685b         	ldr	r3, [r3, #0x4]
 8015664: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetStopBitsLength(config->usart, stopbits);
 8015666: 68fb         	ldr	r3, [r7, #0xc]
 8015668: 681b         	ldr	r3, [r3]
 801566a: 6839         	ldr	r1, [r7]
 801566c: 4618         	mov	r0, r3
 801566e: f7ff fbf4    	bl	0x8014e5a <LL_USART_SetStopBitsLength> @ imm = #-0x818
; }
 8015672: bf00         	nop
 8015674: 3710         	adds	r7, #0x10
 8015676: 46bd         	mov	sp, r7
 8015678: bd80         	pop	{r7, pc}

0801567a <uart_stm32_get_stopbits>:
; {
 801567a: b580         	push	{r7, lr}
 801567c: b084         	sub	sp, #0x10
 801567e: af00         	add	r7, sp, #0x0
 8015680: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8015682: 687b         	ldr	r3, [r7, #0x4]
 8015684: 685b         	ldr	r3, [r3, #0x4]
 8015686: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetStopBitsLength(config->usart);
 8015688: 68fb         	ldr	r3, [r7, #0xc]
 801568a: 681b         	ldr	r3, [r3]
 801568c: 4618         	mov	r0, r3
 801568e: f7ff fbf6    	bl	0x8014e7e <LL_USART_GetStopBitsLength> @ imm = #-0x814
 8015692: 4603         	mov	r3, r0
; }
 8015694: 4618         	mov	r0, r3
 8015696: 3710         	adds	r7, #0x10
 8015698: 46bd         	mov	sp, r7
 801569a: bd80         	pop	{r7, pc}

0801569c <uart_stm32_set_databits>:
; {
 801569c: b580         	push	{r7, lr}
 801569e: b084         	sub	sp, #0x10
 80156a0: af00         	add	r7, sp, #0x0
 80156a2: 6078         	str	r0, [r7, #0x4]
 80156a4: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 80156a6: 687b         	ldr	r3, [r7, #0x4]
 80156a8: 685b         	ldr	r3, [r3, #0x4]
 80156aa: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetDataWidth(config->usart, databits);
 80156ac: 68fb         	ldr	r3, [r7, #0xc]
 80156ae: 681b         	ldr	r3, [r3]
 80156b0: 6839         	ldr	r1, [r7]
 80156b2: 4618         	mov	r0, r3
 80156b4: f7ff fba0    	bl	0x8014df8 <LL_USART_SetDataWidth> @ imm = #-0x8c0
; }
 80156b8: bf00         	nop
 80156ba: 3710         	adds	r7, #0x10
 80156bc: 46bd         	mov	sp, r7
 80156be: bd80         	pop	{r7, pc}

080156c0 <uart_stm32_get_databits>:
; {
 80156c0: b580         	push	{r7, lr}
 80156c2: b084         	sub	sp, #0x10
 80156c4: af00         	add	r7, sp, #0x0
 80156c6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80156c8: 687b         	ldr	r3, [r7, #0x4]
 80156ca: 685b         	ldr	r3, [r3, #0x4]
 80156cc: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetDataWidth(config->usart);
 80156ce: 68fb         	ldr	r3, [r7, #0xc]
 80156d0: 681b         	ldr	r3, [r3]
 80156d2: 4618         	mov	r0, r3
 80156d4: f7ff fba2    	bl	0x8014e1c <LL_USART_GetDataWidth> @ imm = #-0x8bc
 80156d8: 4603         	mov	r3, r0
; }
 80156da: 4618         	mov	r0, r3
 80156dc: 3710         	adds	r7, #0x10
 80156de: 46bd         	mov	sp, r7
 80156e0: bd80         	pop	{r7, pc}

080156e2 <uart_stm32_set_hwctrl>:
; {
 80156e2: b580         	push	{r7, lr}
 80156e4: b084         	sub	sp, #0x10
 80156e6: af00         	add	r7, sp, #0x0
 80156e8: 6078         	str	r0, [r7, #0x4]
 80156ea: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 80156ec: 687b         	ldr	r3, [r7, #0x4]
 80156ee: 685b         	ldr	r3, [r3, #0x4]
 80156f0: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetHWFlowCtrl(config->usart, hwctrl);
 80156f2: 68fb         	ldr	r3, [r7, #0xc]
 80156f4: 681b         	ldr	r3, [r3]
 80156f6: 6839         	ldr	r1, [r7]
 80156f8: 4618         	mov	r0, r3
 80156fa: f7ff fbeb    	bl	0x8014ed4 <LL_USART_SetHWFlowCtrl> @ imm = #-0x82a
; }
 80156fe: bf00         	nop
 8015700: 3710         	adds	r7, #0x10
 8015702: 46bd         	mov	sp, r7
 8015704: bd80         	pop	{r7, pc}

08015706 <uart_stm32_get_hwctrl>:
; {
 8015706: b580         	push	{r7, lr}
 8015708: b084         	sub	sp, #0x10
 801570a: af00         	add	r7, sp, #0x0
 801570c: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801570e: 687b         	ldr	r3, [r7, #0x4]
 8015710: 685b         	ldr	r3, [r3, #0x4]
 8015712: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetHWFlowCtrl(config->usart);
 8015714: 68fb         	ldr	r3, [r7, #0xc]
 8015716: 681b         	ldr	r3, [r3]
 8015718: 4618         	mov	r0, r3
 801571a: f7ff fbed    	bl	0x8014ef8 <LL_USART_GetHWFlowCtrl> @ imm = #-0x826
 801571e: 4603         	mov	r3, r0
; }
 8015720: 4618         	mov	r0, r3
 8015722: 3710         	adds	r7, #0x10
 8015724: 46bd         	mov	sp, r7
 8015726: bd80         	pop	{r7, pc}

08015728 <uart_stm32_cfg2ll_parity>:
; {
 8015728: b480         	push	{r7}
 801572a: b083         	sub	sp, #0xc
 801572c: af00         	add	r7, sp, #0x0
 801572e: 4603         	mov	r3, r0
 8015730: 71fb         	strb	r3, [r7, #0x7]
; 	switch (parity) {
 8015732: 79fb         	ldrb	r3, [r7, #0x7]
 8015734: 2b01         	cmp	r3, #0x1
 8015736: d002         	beq	0x801573e <uart_stm32_cfg2ll_parity+0x16> @ imm = #0x4
 8015738: 2b02         	cmp	r3, #0x2
 801573a: d003         	beq	0x8015744 <uart_stm32_cfg2ll_parity+0x1c> @ imm = #0x6
 801573c: e005         	b	0x801574a <uart_stm32_cfg2ll_parity+0x22> @ imm = #0xa
; 		return LL_USART_PARITY_ODD;
 801573e: f44f 63c0    	mov.w	r3, #0x600
 8015742: e003         	b	0x801574c <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x6
; 		return LL_USART_PARITY_EVEN;
 8015744: f44f 6380    	mov.w	r3, #0x400
 8015748: e000         	b	0x801574c <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x0
; 		return LL_USART_PARITY_NONE;
 801574a: 2300         	movs	r3, #0x0
; }
 801574c: 4618         	mov	r0, r3
 801574e: 370c         	adds	r7, #0xc
 8015750: 46bd         	mov	sp, r7
 8015752: bc80         	pop	{r7}
 8015754: 4770         	bx	lr

08015756 <uart_stm32_ll2cfg_parity>:
; {
 8015756: b480         	push	{r7}
 8015758: b083         	sub	sp, #0xc
 801575a: af00         	add	r7, sp, #0x0
 801575c: 6078         	str	r0, [r7, #0x4]
; 	switch (parity) {
 801575e: 687b         	ldr	r3, [r7, #0x4]
 8015760: f5b3 6f80    	cmp.w	r3, #0x400
 8015764: d005         	beq	0x8015772 <uart_stm32_ll2cfg_parity+0x1c> @ imm = #0xa
 8015766: 687b         	ldr	r3, [r7, #0x4]
 8015768: f5b3 6fc0    	cmp.w	r3, #0x600
 801576c: d103         	bne	0x8015776 <uart_stm32_ll2cfg_parity+0x20> @ imm = #0x6
; 		return UART_CFG_PARITY_ODD;
 801576e: 2301         	movs	r3, #0x1
 8015770: e002         	b	0x8015778 <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x4
; 		return UART_CFG_PARITY_EVEN;
 8015772: 2302         	movs	r3, #0x2
 8015774: e000         	b	0x8015778 <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x0
; 		return UART_CFG_PARITY_NONE;
 8015776: 2300         	movs	r3, #0x0
; }
 8015778: 4618         	mov	r0, r3
 801577a: 370c         	adds	r7, #0xc
 801577c: 46bd         	mov	sp, r7
 801577e: bc80         	pop	{r7}
 8015780: 4770         	bx	lr

08015782 <uart_stm32_cfg2ll_stopbits>:
; {
 8015782: b480         	push	{r7}
 8015784: b083         	sub	sp, #0xc
 8015786: af00         	add	r7, sp, #0x0
 8015788: 6078         	str	r0, [r7, #0x4]
 801578a: 460b         	mov	r3, r1
 801578c: 70fb         	strb	r3, [r7, #0x3]
; 	switch (sb) {
 801578e: 78fb         	ldrb	r3, [r7, #0x3]
 8015790: 2b02         	cmp	r3, #0x2
 8015792: d00b         	beq	0x80157ac <uart_stm32_cfg2ll_stopbits+0x2a> @ imm = #0x16
 8015794: 2b02         	cmp	r3, #0x2
 8015796: dc0c         	bgt	0x80157b2 <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0x18
 8015798: 2b00         	cmp	r3, #0x0
 801579a: d002         	beq	0x80157a2 <uart_stm32_cfg2ll_stopbits+0x20> @ imm = #0x4
 801579c: 2b01         	cmp	r3, #0x1
 801579e: d003         	beq	0x80157a8 <uart_stm32_cfg2ll_stopbits+0x26> @ imm = #0x6
 80157a0: e007         	b	0x80157b2 <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0xe
; 		return LL_USART_STOPBITS_0_5;
 80157a2: f44f 5380    	mov.w	r3, #0x1000
 80157a6: e006         	b	0x80157b6 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0xc
; 		return LL_USART_STOPBITS_1;
 80157a8: 2300         	movs	r3, #0x0
 80157aa: e004         	b	0x80157b6 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x8
; 		return LL_USART_STOPBITS_1_5;
 80157ac: f44f 5340    	mov.w	r3, #0x3000
 80157b0: e001         	b	0x80157b6 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x2
; 		return LL_USART_STOPBITS_2;
 80157b2: f44f 5300    	mov.w	r3, #0x2000
; }
 80157b6: 4618         	mov	r0, r3
 80157b8: 370c         	adds	r7, #0xc
 80157ba: 46bd         	mov	sp, r7
 80157bc: bc80         	pop	{r7}
 80157be: 4770         	bx	lr

080157c0 <uart_stm32_ll2cfg_stopbits>:
; {
 80157c0: b480         	push	{r7}
 80157c2: b083         	sub	sp, #0xc
 80157c4: af00         	add	r7, sp, #0x0
 80157c6: 6078         	str	r0, [r7, #0x4]
; 	switch (sb) {
 80157c8: 687b         	ldr	r3, [r7, #0x4]
 80157ca: f5b3 5f40    	cmp.w	r3, #0x3000
 80157ce: d00e         	beq	0x80157ee <uart_stm32_ll2cfg_stopbits+0x2e> @ imm = #0x1c
 80157d0: 687b         	ldr	r3, [r7, #0x4]
 80157d2: f5b3 5f40    	cmp.w	r3, #0x3000
 80157d6: d80c         	bhi	0x80157f2 <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0x18
 80157d8: 687b         	ldr	r3, [r7, #0x4]
 80157da: 2b00         	cmp	r3, #0x0
 80157dc: d005         	beq	0x80157ea <uart_stm32_ll2cfg_stopbits+0x2a> @ imm = #0xa
 80157de: 687b         	ldr	r3, [r7, #0x4]
 80157e0: f5b3 5f80    	cmp.w	r3, #0x1000
 80157e4: d105         	bne	0x80157f2 <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0xa
; 		return UART_CFG_STOP_BITS_0_5;
 80157e6: 2300         	movs	r3, #0x0
 80157e8: e004         	b	0x80157f4 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x8
; 		return UART_CFG_STOP_BITS_1;
 80157ea: 2301         	movs	r3, #0x1
 80157ec: e002         	b	0x80157f4 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x4
; 		return UART_CFG_STOP_BITS_1_5;
 80157ee: 2302         	movs	r3, #0x2
 80157f0: e000         	b	0x80157f4 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x0
; 		return UART_CFG_STOP_BITS_2;
 80157f2: 2303         	movs	r3, #0x3
; }
 80157f4: 4618         	mov	r0, r3
 80157f6: 370c         	adds	r7, #0xc
 80157f8: 46bd         	mov	sp, r7
 80157fa: bc80         	pop	{r7}
 80157fc: 4770         	bx	lr

080157fe <uart_stm32_cfg2ll_databits>:
; {
 80157fe: b480         	push	{r7}
 8015800: b083         	sub	sp, #0xc
 8015802: af00         	add	r7, sp, #0x0
 8015804: 4603         	mov	r3, r0
 8015806: 460a         	mov	r2, r1
 8015808: 71fb         	strb	r3, [r7, #0x7]
 801580a: 4613         	mov	r3, r2
 801580c: 71bb         	strb	r3, [r7, #0x6]
; 	switch (db) {
 801580e: 79fb         	ldrb	r3, [r7, #0x7]
 8015810: 2b04         	cmp	r3, #0x4
 8015812: d102         	bne	0x801581a <uart_stm32_cfg2ll_databits+0x1c> @ imm = #0x4
; 		return LL_USART_DATAWIDTH_9B;
 8015814: f44f 5380    	mov.w	r3, #0x1000
 8015818: e006         	b	0x8015828 <uart_stm32_cfg2ll_databits+0x2a> @ imm = #0xc
; 		if (p == UART_CFG_PARITY_NONE) {
 801581a: 79bb         	ldrb	r3, [r7, #0x6]
 801581c: 2b00         	cmp	r3, #0x0
 801581e: d101         	bne	0x8015824 <uart_stm32_cfg2ll_databits+0x26> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_8B;
 8015820: 2300         	movs	r3, #0x0
 8015822: e001         	b	0x8015828 <uart_stm32_cfg2ll_databits+0x2a> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_9B;
 8015824: f44f 5380    	mov.w	r3, #0x1000
; }
 8015828: 4618         	mov	r0, r3
 801582a: 370c         	adds	r7, #0xc
 801582c: 46bd         	mov	sp, r7
 801582e: bc80         	pop	{r7}
 8015830: 4770         	bx	lr

08015832 <uart_stm32_ll2cfg_databits>:
; {
 8015832: b480         	push	{r7}
 8015834: b083         	sub	sp, #0xc
 8015836: af00         	add	r7, sp, #0x0
 8015838: 6078         	str	r0, [r7, #0x4]
 801583a: 6039         	str	r1, [r7]
; 	switch (db) {
 801583c: 687b         	ldr	r3, [r7, #0x4]
 801583e: f5b3 5f80    	cmp.w	r3, #0x1000
 8015842: d106         	bne	0x8015852 <uart_stm32_ll2cfg_databits+0x20> @ imm = #0xc
; 		if (p == LL_USART_PARITY_NONE) {
 8015844: 683b         	ldr	r3, [r7]
 8015846: 2b00         	cmp	r3, #0x0
 8015848: d101         	bne	0x801584e <uart_stm32_ll2cfg_databits+0x1c> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_9;
 801584a: 2304         	movs	r3, #0x4
 801584c: e007         	b	0x801585e <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0xe
; 			return UART_CFG_DATA_BITS_8;
 801584e: 2303         	movs	r3, #0x3
 8015850: e005         	b	0x801585e <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0xa
; 		if (p == LL_USART_PARITY_NONE) {
 8015852: 683b         	ldr	r3, [r7]
 8015854: 2b00         	cmp	r3, #0x0
 8015856: d101         	bne	0x801585c <uart_stm32_ll2cfg_databits+0x2a> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_8;
 8015858: 2303         	movs	r3, #0x3
 801585a: e000         	b	0x801585e <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0x0
; 			return UART_CFG_DATA_BITS_7;
 801585c: 2302         	movs	r3, #0x2
; }
 801585e: 4618         	mov	r0, r3
 8015860: 370c         	adds	r7, #0xc
 8015862: 46bd         	mov	sp, r7
 8015864: bc80         	pop	{r7}
 8015866: 4770         	bx	lr

08015868 <uart_stm32_cfg2ll_hwctrl>:
; {
 8015868: b480         	push	{r7}
 801586a: b083         	sub	sp, #0xc
 801586c: af00         	add	r7, sp, #0x0
 801586e: 4603         	mov	r3, r0
 8015870: 71fb         	strb	r3, [r7, #0x7]
; 	if (fc == UART_CFG_FLOW_CTRL_RTS_CTS) {
 8015872: 79fb         	ldrb	r3, [r7, #0x7]
 8015874: 2b01         	cmp	r3, #0x1
 8015876: d102         	bne	0x801587e <uart_stm32_cfg2ll_hwctrl+0x16> @ imm = #0x4
; 		return LL_USART_HWCONTROL_RTS_CTS;
 8015878: f44f 7340    	mov.w	r3, #0x300
 801587c: e005         	b	0x801588a <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0xa
; 	} else if (fc == UART_CFG_FLOW_CTRL_RS485) {
 801587e: 79fb         	ldrb	r3, [r7, #0x7]
 8015880: 2b03         	cmp	r3, #0x3
 8015882: d101         	bne	0x8015888 <uart_stm32_cfg2ll_hwctrl+0x20> @ imm = #0x2
; 		return LL_USART_HWCONTROL_NONE;
 8015884: 2300         	movs	r3, #0x0
 8015886: e000         	b	0x801588a <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0x0
; 	return LL_USART_HWCONTROL_NONE;
 8015888: 2300         	movs	r3, #0x0
; }
 801588a: 4618         	mov	r0, r3
 801588c: 370c         	adds	r7, #0xc
 801588e: 46bd         	mov	sp, r7
 8015890: bc80         	pop	{r7}
 8015892: 4770         	bx	lr

08015894 <uart_stm32_ll2cfg_hwctrl>:
; {
 8015894: b480         	push	{r7}
 8015896: b083         	sub	sp, #0xc
 8015898: af00         	add	r7, sp, #0x0
 801589a: 6078         	str	r0, [r7, #0x4]
; 	if (fc == LL_USART_HWCONTROL_RTS_CTS) {
 801589c: 687b         	ldr	r3, [r7, #0x4]
 801589e: f5b3 7f40    	cmp.w	r3, #0x300
 80158a2: d101         	bne	0x80158a8 <uart_stm32_ll2cfg_hwctrl+0x14> @ imm = #0x2
; 		return UART_CFG_FLOW_CTRL_RTS_CTS;
 80158a4: 2301         	movs	r3, #0x1
 80158a6: e000         	b	0x80158aa <uart_stm32_ll2cfg_hwctrl+0x16> @ imm = #0x0
; 	return UART_CFG_FLOW_CTRL_NONE;
 80158a8: 2300         	movs	r3, #0x0
; }
 80158aa: 4618         	mov	r0, r3
 80158ac: 370c         	adds	r7, #0xc
 80158ae: 46bd         	mov	sp, r7
 80158b0: bc80         	pop	{r7}
 80158b2: 4770         	bx	lr

080158b4 <uart_stm32_parameters_set>:
; {
 80158b4: b580         	push	{r7, lr}
 80158b6: b08a         	sub	sp, #0x28
 80158b8: af00         	add	r7, sp, #0x0
 80158ba: 6078         	str	r0, [r7, #0x4]
 80158bc: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 80158be: 687b         	ldr	r3, [r7, #0x4]
 80158c0: 685b         	ldr	r3, [r3, #0x4]
 80158c2: 627b         	str	r3, [r7, #0x24]
; 	struct uart_stm32_data *data = dev->data;
 80158c4: 687b         	ldr	r3, [r7, #0x4]
 80158c6: 691b         	ldr	r3, [r3, #0x10]
 80158c8: 623b         	str	r3, [r7, #0x20]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 80158ca: 6a3b         	ldr	r3, [r7, #0x20]
 80158cc: 685b         	ldr	r3, [r3, #0x4]
 80158ce: 61fb         	str	r3, [r7, #0x1c]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 80158d0: 683b         	ldr	r3, [r7]
 80158d2: 791b         	ldrb	r3, [r3, #0x4]
 80158d4: 4618         	mov	r0, r3
 80158d6: f7ff ff27    	bl	0x8015728 <uart_stm32_cfg2ll_parity> @ imm = #-0x1b2
 80158da: 61b8         	str	r0, [r7, #0x18]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 80158dc: 683b         	ldr	r3, [r7]
 80158de: 795b         	ldrb	r3, [r3, #0x5]
 80158e0: 4619         	mov	r1, r3
 80158e2: 6a78         	ldr	r0, [r7, #0x24]
 80158e4: f7ff ff4d    	bl	0x8015782 <uart_stm32_cfg2ll_stopbits> @ imm = #-0x166
 80158e8: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 80158ea: 683b         	ldr	r3, [r7]
 80158ec: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 80158ee: 683b         	ldr	r3, [r7]
 80158f0: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 80158f2: 4619         	mov	r1, r3
 80158f4: 4610         	mov	r0, r2
 80158f6: f7ff ff82    	bl	0x80157fe <uart_stm32_cfg2ll_databits> @ imm = #-0xfc
 80158fa: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t flowctrl = uart_stm32_cfg2ll_hwctrl(cfg->flow_ctrl);
 80158fc: 683b         	ldr	r3, [r7]
 80158fe: 79db         	ldrb	r3, [r3, #0x7]
 8015900: 4618         	mov	r0, r3
 8015902: f7ff ffb1    	bl	0x8015868 <uart_stm32_cfg2ll_hwctrl> @ imm = #-0x9e
 8015906: 60f8         	str	r0, [r7, #0xc]
; 	if (cfg == uart_cfg) {
 8015908: 683a         	ldr	r2, [r7]
 801590a: 69fb         	ldr	r3, [r7, #0x1c]
 801590c: 429a         	cmp	r2, r3
 801590e: d111         	bne	0x8015934 <uart_stm32_parameters_set+0x80> @ imm = #0x22
; 		LL_USART_ConfigCharacter(config->usart,
 8015910: 6a7b         	ldr	r3, [r7, #0x24]
 8015912: 6818         	ldr	r0, [r3]
 8015914: 697b         	ldr	r3, [r7, #0x14]
 8015916: 69ba         	ldr	r2, [r7, #0x18]
 8015918: 6939         	ldr	r1, [r7, #0x10]
 801591a: f7ff fabd    	bl	0x8014e98 <LL_USART_ConfigCharacter> @ imm = #-0xa86
; 		uart_stm32_set_hwctrl(dev, flowctrl);
 801591e: 68f9         	ldr	r1, [r7, #0xc]
 8015920: 6878         	ldr	r0, [r7, #0x4]
 8015922: f7ff fede    	bl	0x80156e2 <uart_stm32_set_hwctrl> @ imm = #-0x244
; 		uart_stm32_set_baudrate(dev, cfg->baudrate);
 8015926: 683b         	ldr	r3, [r7]
 8015928: 681b         	ldr	r3, [r3]
 801592a: 4619         	mov	r1, r3
 801592c: 6878         	ldr	r0, [r7, #0x4]
 801592e: f7f2 fbcd    	bl	0x80080cc <uart_stm32_set_baudrate> @ imm = #-0xd866
; }
 8015932: e03b         	b	0x80159ac <uart_stm32_parameters_set+0xf8> @ imm = #0x76
; 		if (parity != uart_stm32_get_parity(dev)) {
 8015934: 6878         	ldr	r0, [r7, #0x4]
 8015936: f7ff fe7d    	bl	0x8015634 <uart_stm32_get_parity> @ imm = #-0x306
 801593a: 4602         	mov	r2, r0
 801593c: 69bb         	ldr	r3, [r7, #0x18]
 801593e: 4293         	cmp	r3, r2
 8015940: d003         	beq	0x801594a <uart_stm32_parameters_set+0x96> @ imm = #0x6
; 			uart_stm32_set_parity(dev, parity);
 8015942: 69b9         	ldr	r1, [r7, #0x18]
 8015944: 6878         	ldr	r0, [r7, #0x4]
 8015946: f7ff fe63    	bl	0x8015610 <uart_stm32_set_parity> @ imm = #-0x33a
; 		if (stopbits != uart_stm32_get_stopbits(dev)) {
 801594a: 6878         	ldr	r0, [r7, #0x4]
 801594c: f7ff fe95    	bl	0x801567a <uart_stm32_get_stopbits> @ imm = #-0x2d6
 8015950: 4602         	mov	r2, r0
 8015952: 697b         	ldr	r3, [r7, #0x14]
 8015954: 4293         	cmp	r3, r2
 8015956: d003         	beq	0x8015960 <uart_stm32_parameters_set+0xac> @ imm = #0x6
; 			uart_stm32_set_stopbits(dev, stopbits);
 8015958: 6979         	ldr	r1, [r7, #0x14]
 801595a: 6878         	ldr	r0, [r7, #0x4]
 801595c: f7ff fe7b    	bl	0x8015656 <uart_stm32_set_stopbits> @ imm = #-0x30a
; 		if (databits != uart_stm32_get_databits(dev)) {
 8015960: 6878         	ldr	r0, [r7, #0x4]
 8015962: f7ff fead    	bl	0x80156c0 <uart_stm32_get_databits> @ imm = #-0x2a6
 8015966: 4602         	mov	r2, r0
 8015968: 693b         	ldr	r3, [r7, #0x10]
 801596a: 4293         	cmp	r3, r2
 801596c: d003         	beq	0x8015976 <uart_stm32_parameters_set+0xc2> @ imm = #0x6
; 			uart_stm32_set_databits(dev, databits);
 801596e: 6939         	ldr	r1, [r7, #0x10]
 8015970: 6878         	ldr	r0, [r7, #0x4]
 8015972: f7ff fe93    	bl	0x801569c <uart_stm32_set_databits> @ imm = #-0x2da
; 		if (flowctrl != uart_stm32_get_hwctrl(dev)) {
 8015976: 6878         	ldr	r0, [r7, #0x4]
 8015978: f7ff fec5    	bl	0x8015706 <uart_stm32_get_hwctrl> @ imm = #-0x276
 801597c: 4602         	mov	r2, r0
 801597e: 68fb         	ldr	r3, [r7, #0xc]
 8015980: 4293         	cmp	r3, r2
 8015982: d003         	beq	0x801598c <uart_stm32_parameters_set+0xd8> @ imm = #0x6
; 			uart_stm32_set_hwctrl(dev, flowctrl);
 8015984: 68f9         	ldr	r1, [r7, #0xc]
 8015986: 6878         	ldr	r0, [r7, #0x4]
 8015988: f7ff feab    	bl	0x80156e2 <uart_stm32_set_hwctrl> @ imm = #-0x2aa
; 		if (cfg->baudrate != uart_cfg->baudrate) {
 801598c: 683b         	ldr	r3, [r7]
 801598e: 681a         	ldr	r2, [r3]
 8015990: 69fb         	ldr	r3, [r7, #0x1c]
 8015992: 681b         	ldr	r3, [r3]
 8015994: 429a         	cmp	r2, r3
 8015996: d009         	beq	0x80159ac <uart_stm32_parameters_set+0xf8> @ imm = #0x12
; 			uart_stm32_set_baudrate(dev, cfg->baudrate);
 8015998: 683b         	ldr	r3, [r7]
 801599a: 681b         	ldr	r3, [r3]
 801599c: 4619         	mov	r1, r3
 801599e: 6878         	ldr	r0, [r7, #0x4]
 80159a0: f7f2 fb94    	bl	0x80080cc <uart_stm32_set_baudrate> @ imm = #-0xd8d8
; 			uart_cfg->baudrate = cfg->baudrate;
 80159a4: 683b         	ldr	r3, [r7]
 80159a6: 681a         	ldr	r2, [r3]
 80159a8: 69fb         	ldr	r3, [r7, #0x1c]
 80159aa: 601a         	str	r2, [r3]
; }
 80159ac: bf00         	nop
 80159ae: 3728         	adds	r7, #0x28
 80159b0: 46bd         	mov	sp, r7
 80159b2: bd80         	pop	{r7, pc}

080159b4 <uart_stm32_config_get>:
; {
 80159b4: b590         	push	{r4, r7, lr}
 80159b6: b085         	sub	sp, #0x14
 80159b8: af00         	add	r7, sp, #0x0
 80159ba: 6078         	str	r0, [r7, #0x4]
 80159bc: 6039         	str	r1, [r7]
; 	struct uart_stm32_data *data = dev->data;
 80159be: 687b         	ldr	r3, [r7, #0x4]
 80159c0: 691b         	ldr	r3, [r3, #0x10]
 80159c2: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 80159c4: 68fb         	ldr	r3, [r7, #0xc]
 80159c6: 685b         	ldr	r3, [r3, #0x4]
 80159c8: 60bb         	str	r3, [r7, #0x8]
; 	cfg->baudrate = uart_cfg->baudrate;
 80159ca: 68bb         	ldr	r3, [r7, #0x8]
 80159cc: 681a         	ldr	r2, [r3]
 80159ce: 683b         	ldr	r3, [r7]
 80159d0: 601a         	str	r2, [r3]
; 	cfg->parity = uart_stm32_ll2cfg_parity(uart_stm32_get_parity(dev));
 80159d2: 6878         	ldr	r0, [r7, #0x4]
 80159d4: f7ff fe2e    	bl	0x8015634 <uart_stm32_get_parity> @ imm = #-0x3a4
 80159d8: 4603         	mov	r3, r0
 80159da: 4618         	mov	r0, r3
 80159dc: f7ff febb    	bl	0x8015756 <uart_stm32_ll2cfg_parity> @ imm = #-0x28a
 80159e0: 4603         	mov	r3, r0
 80159e2: 461a         	mov	r2, r3
 80159e4: 683b         	ldr	r3, [r7]
 80159e6: 711a         	strb	r2, [r3, #0x4]
; 	cfg->stop_bits = uart_stm32_ll2cfg_stopbits(
 80159e8: 6878         	ldr	r0, [r7, #0x4]
 80159ea: f7ff fe46    	bl	0x801567a <uart_stm32_get_stopbits> @ imm = #-0x374
 80159ee: 4603         	mov	r3, r0
 80159f0: 4618         	mov	r0, r3
 80159f2: f7ff fee5    	bl	0x80157c0 <uart_stm32_ll2cfg_stopbits> @ imm = #-0x236
 80159f6: 4603         	mov	r3, r0
 80159f8: 461a         	mov	r2, r3
 80159fa: 683b         	ldr	r3, [r7]
 80159fc: 715a         	strb	r2, [r3, #0x5]
; 	cfg->data_bits = uart_stm32_ll2cfg_databits(
 80159fe: 6878         	ldr	r0, [r7, #0x4]
 8015a00: f7ff fe5e    	bl	0x80156c0 <uart_stm32_get_databits> @ imm = #-0x344
 8015a04: 4604         	mov	r4, r0
 8015a06: 6878         	ldr	r0, [r7, #0x4]
 8015a08: f7ff fe14    	bl	0x8015634 <uart_stm32_get_parity> @ imm = #-0x3d8
 8015a0c: 4603         	mov	r3, r0
 8015a0e: 4619         	mov	r1, r3
 8015a10: 4620         	mov	r0, r4
 8015a12: f7ff ff0e    	bl	0x8015832 <uart_stm32_ll2cfg_databits> @ imm = #-0x1e4
 8015a16: 4603         	mov	r3, r0
 8015a18: 461a         	mov	r2, r3
 8015a1a: 683b         	ldr	r3, [r7]
 8015a1c: 719a         	strb	r2, [r3, #0x6]
; 	cfg->flow_ctrl = uart_stm32_ll2cfg_hwctrl(
 8015a1e: 6878         	ldr	r0, [r7, #0x4]
 8015a20: f7ff fe71    	bl	0x8015706 <uart_stm32_get_hwctrl> @ imm = #-0x31e
 8015a24: 4603         	mov	r3, r0
 8015a26: 4618         	mov	r0, r3
 8015a28: f7ff ff34    	bl	0x8015894 <uart_stm32_ll2cfg_hwctrl> @ imm = #-0x198
 8015a2c: 4603         	mov	r3, r0
 8015a2e: 461a         	mov	r2, r3
 8015a30: 683b         	ldr	r3, [r7]
 8015a32: 71da         	strb	r2, [r3, #0x7]
; 	return 0;
 8015a34: 2300         	movs	r3, #0x0
; }
 8015a36: 4618         	mov	r0, r3
 8015a38: 3714         	adds	r7, #0x14
 8015a3a: 46bd         	mov	sp, r7
 8015a3c: bd90         	pop	{r4, r7, pc}

08015a3e <uart_stm32_poll_in_visitor>:
; {
 8015a3e: b580         	push	{r7, lr}
 8015a40: b086         	sub	sp, #0x18
 8015a42: af00         	add	r7, sp, #0x0
 8015a44: 60f8         	str	r0, [r7, #0xc]
 8015a46: 60b9         	str	r1, [r7, #0x8]
 8015a48: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8015a4a: 68fb         	ldr	r3, [r7, #0xc]
 8015a4c: 685b         	ldr	r3, [r3, #0x4]
 8015a4e: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 8015a50: 697b         	ldr	r3, [r7, #0x14]
 8015a52: 681b         	ldr	r3, [r3]
 8015a54: 613b         	str	r3, [r7, #0x10]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 8015a56: 6938         	ldr	r0, [r7, #0x10]
 8015a58: f7ff faa0    	bl	0x8014f9c <LL_USART_IsActiveFlag_ORE> @ imm = #-0xac0
 8015a5c: 4603         	mov	r3, r0
 8015a5e: 2b00         	cmp	r3, #0x0
 8015a60: d002         	beq	0x8015a68 <uart_stm32_poll_in_visitor+0x2a> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 8015a62: 6938         	ldr	r0, [r7, #0x10]
 8015a64: f7ff fb3a    	bl	0x80150dc <LL_USART_ClearFlag_ORE> @ imm = #-0x98c
; 	if (!LL_USART_IsActiveFlag_RXNE(usart)) {
 8015a68: 6938         	ldr	r0, [r7, #0x10]
 8015a6a: f7ff fabb    	bl	0x8014fe4 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xa8a
 8015a6e: 4603         	mov	r3, r0
 8015a70: 2b00         	cmp	r3, #0x0
 8015a72: d102         	bne	0x8015a7a <uart_stm32_poll_in_visitor+0x3c> @ imm = #0x4
; 		return -1;
 8015a74: f04f 33ff    	mov.w	r3, #0xffffffff
 8015a78: e004         	b	0x8015a84 <uart_stm32_poll_in_visitor+0x46> @ imm = #0x8
; 	get_fn(usart, in);
 8015a7a: 687b         	ldr	r3, [r7, #0x4]
 8015a7c: 68b9         	ldr	r1, [r7, #0x8]
 8015a7e: 6938         	ldr	r0, [r7, #0x10]
 8015a80: 4798         	blx	r3
; 	return 0;
 8015a82: 2300         	movs	r3, #0x0
; }
 8015a84: 4618         	mov	r0, r3
 8015a86: 3718         	adds	r7, #0x18
 8015a88: 46bd         	mov	sp, r7
 8015a8a: bd80         	pop	{r7, pc}

08015a8c <uart_stm32_poll_out_visitor>:
; {
 8015a8c: b580         	push	{r7, lr}
 8015a8e: b08e         	sub	sp, #0x38
 8015a90: af00         	add	r7, sp, #0x0
 8015a92: 60f8         	str	r0, [r7, #0xc]
 8015a94: 60b9         	str	r1, [r7, #0x8]
 8015a96: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8015a98: 68fb         	ldr	r3, [r7, #0xc]
 8015a9a: 685b         	ldr	r3, [r3, #0x4]
 8015a9c: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 8015a9e: 6b7b         	ldr	r3, [r7, #0x34]
 8015aa0: 681b         	ldr	r3, [r3]
 8015aa2: 633b         	str	r3, [r7, #0x30]
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 8015aa4: 6b38         	ldr	r0, [r7, #0x30]
 8015aa6: f7ff fac1    	bl	0x801502c <LL_USART_IsActiveFlag_TXE> @ imm = #-0xa7e
 8015aaa: 4603         	mov	r3, r0
 8015aac: 2b00         	cmp	r3, #0x0
 8015aae: d0f9         	beq	0x8015aa4 <uart_stm32_poll_out_visitor+0x18> @ imm = #-0xe
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015ab0: f3ef 8311    	mrs	r3, basepri
 8015ab4: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 8015ab6: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 8015ab8: 627b         	str	r3, [r7, #0x24]
 8015aba: 2310         	movs	r3, #0x10
 8015abc: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015abe: 6a3b         	ldr	r3, [r7, #0x20]
 8015ac0: f383 8812    	msr	basepri_max, r3
; }
 8015ac4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015ac6: f3bf 8f6f    	isb	sy
; }
 8015aca: bf00         	nop
; 	return key;
 8015acc: 6a7b         	ldr	r3, [r7, #0x24]
; 			key = irq_lock();
 8015ace: 62fb         	str	r3, [r7, #0x2c]
; 			if (LL_USART_IsActiveFlag_TXE(usart)) {
 8015ad0: 6b38         	ldr	r0, [r7, #0x30]
 8015ad2: f7ff faab    	bl	0x801502c <LL_USART_IsActiveFlag_TXE> @ imm = #-0xaaa
 8015ad6: 4603         	mov	r3, r0
 8015ad8: 2b00         	cmp	r3, #0x0
 8015ada: d10c         	bne	0x8015af6 <uart_stm32_poll_out_visitor+0x6a> @ imm = #0x18
 8015adc: 6afb         	ldr	r3, [r7, #0x2c]
 8015ade: 61fb         	str	r3, [r7, #0x1c]
 8015ae0: 69fb         	ldr	r3, [r7, #0x1c]
 8015ae2: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015ae4: 69bb         	ldr	r3, [r7, #0x18]
 8015ae6: f383 8811    	msr	basepri, r3
; }
 8015aea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015aec: f3bf 8f6f    	isb	sy
; }
 8015af0: bf00         	nop
; }
 8015af2: bf00         	nop
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 8015af4: e7d6         	b	0x8015aa4 <uart_stm32_poll_out_visitor+0x18> @ imm = #-0x54
; 				break;
 8015af6: bf00         	nop
; 	set_fn(usart, out);
 8015af8: 687b         	ldr	r3, [r7, #0x4]
 8015afa: 68b9         	ldr	r1, [r7, #0x8]
 8015afc: 6b38         	ldr	r0, [r7, #0x30]
 8015afe: 4798         	blx	r3
 8015b00: 6afb         	ldr	r3, [r7, #0x2c]
 8015b02: 617b         	str	r3, [r7, #0x14]
 8015b04: 697b         	ldr	r3, [r7, #0x14]
 8015b06: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015b08: 693b         	ldr	r3, [r7, #0x10]
 8015b0a: f383 8811    	msr	basepri, r3
; }
 8015b0e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015b10: f3bf 8f6f    	isb	sy
; }
 8015b14: bf00         	nop
; }
 8015b16: bf00         	nop
; }
 8015b18: bf00         	nop
 8015b1a: 3738         	adds	r7, #0x38
 8015b1c: 46bd         	mov	sp, r7
 8015b1e: bd80         	pop	{r7, pc}

08015b20 <poll_in_u8>:
; {
 8015b20: b580         	push	{r7, lr}
 8015b22: b082         	sub	sp, #0x8
 8015b24: af00         	add	r7, sp, #0x0
 8015b26: 6078         	str	r0, [r7, #0x4]
 8015b28: 6039         	str	r1, [r7]
; 	*((unsigned char *)in) = (unsigned char)LL_USART_ReceiveData8(usart);
 8015b2a: 6878         	ldr	r0, [r7, #0x4]
 8015b2c: f7ff fd38    	bl	0x80155a0 <LL_USART_ReceiveData8> @ imm = #-0x590
 8015b30: 4603         	mov	r3, r0
 8015b32: 461a         	mov	r2, r3
 8015b34: 683b         	ldr	r3, [r7]
 8015b36: 701a         	strb	r2, [r3]
; }
 8015b38: bf00         	nop
 8015b3a: 3708         	adds	r7, #0x8
 8015b3c: 46bd         	mov	sp, r7
 8015b3e: bd80         	pop	{r7, pc}

08015b40 <poll_out_u8>:
; {
 8015b40: b580         	push	{r7, lr}
 8015b42: b082         	sub	sp, #0x8
 8015b44: af00         	add	r7, sp, #0x0
 8015b46: 6078         	str	r0, [r7, #0x4]
 8015b48: 6039         	str	r1, [r7]
; 	LL_USART_TransmitData8(usart, *((uint8_t *)out));
 8015b4a: 683b         	ldr	r3, [r7]
 8015b4c: 781b         	ldrb	r3, [r3]
 8015b4e: 4619         	mov	r1, r3
 8015b50: 6878         	ldr	r0, [r7, #0x4]
 8015b52: f7ff fd31    	bl	0x80155b8 <LL_USART_TransmitData8> @ imm = #-0x59e
; }
 8015b56: bf00         	nop
 8015b58: 3708         	adds	r7, #0x8
 8015b5a: 46bd         	mov	sp, r7
 8015b5c: bd80         	pop	{r7, pc}

08015b5e <uart_stm32_err_check>:
; {
 8015b5e: b580         	push	{r7, lr}
 8015b60: b086         	sub	sp, #0x18
 8015b62: af00         	add	r7, sp, #0x0
 8015b64: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8015b66: 687b         	ldr	r3, [r7, #0x4]
 8015b68: 685b         	ldr	r3, [r3, #0x4]
 8015b6a: 613b         	str	r3, [r7, #0x10]
; 	USART_TypeDef *usart = config->usart;
 8015b6c: 693b         	ldr	r3, [r7, #0x10]
 8015b6e: 681b         	ldr	r3, [r3]
 8015b70: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t err = 0U;
 8015b72: 2300         	movs	r3, #0x0
 8015b74: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 8015b76: 68f8         	ldr	r0, [r7, #0xc]
 8015b78: f7ff fa10    	bl	0x8014f9c <LL_USART_IsActiveFlag_ORE> @ imm = #-0xbe0
 8015b7c: 4603         	mov	r3, r0
 8015b7e: 2b00         	cmp	r3, #0x0
 8015b80: d003         	beq	0x8015b8a <uart_stm32_err_check+0x2c> @ imm = #0x6
; 		err |= UART_ERROR_OVERRUN;
 8015b82: 697b         	ldr	r3, [r7, #0x14]
 8015b84: f043 0301    	orr	r3, r3, #0x1
 8015b88: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_PE(usart)) {
 8015b8a: 68f8         	ldr	r0, [r7, #0xc]
 8015b8c: f7ff f9d0    	bl	0x8014f30 <LL_USART_IsActiveFlag_PE> @ imm = #-0xc60
 8015b90: 4603         	mov	r3, r0
 8015b92: 2b00         	cmp	r3, #0x0
 8015b94: d003         	beq	0x8015b9e <uart_stm32_err_check+0x40> @ imm = #0x6
; 		err |= UART_ERROR_PARITY;
 8015b96: 697b         	ldr	r3, [r7, #0x14]
 8015b98: f043 0302    	orr	r3, r3, #0x2
 8015b9c: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_FE(usart)) {
 8015b9e: 68f8         	ldr	r0, [r7, #0xc]
 8015ba0: f7ff f9d8    	bl	0x8014f54 <LL_USART_IsActiveFlag_FE> @ imm = #-0xc50
 8015ba4: 4603         	mov	r3, r0
 8015ba6: 2b00         	cmp	r3, #0x0
 8015ba8: d003         	beq	0x8015bb2 <uart_stm32_err_check+0x54> @ imm = #0x6
; 		err |= UART_ERROR_FRAMING;
 8015baa: 697b         	ldr	r3, [r7, #0x14]
 8015bac: f043 0304    	orr	r3, r3, #0x4
 8015bb0: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_NE(usart)) {
 8015bb2: 68f8         	ldr	r0, [r7, #0xc]
 8015bb4: f7ff f9e0    	bl	0x8014f78 <LL_USART_IsActiveFlag_NE> @ imm = #-0xc40
 8015bb8: 4603         	mov	r3, r0
 8015bba: 2b00         	cmp	r3, #0x0
 8015bbc: d003         	beq	0x8015bc6 <uart_stm32_err_check+0x68> @ imm = #0x6
; 		err |= UART_ERROR_NOISE;
 8015bbe: 697b         	ldr	r3, [r7, #0x14]
 8015bc0: f043 0320    	orr	r3, r3, #0x20
 8015bc4: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_LBD(usart)) {
 8015bc6: 68f8         	ldr	r0, [r7, #0xc]
 8015bc8: f7ff fa42    	bl	0x8015050 <LL_USART_IsActiveFlag_LBD> @ imm = #-0xb7c
 8015bcc: 4603         	mov	r3, r0
 8015bce: 2b00         	cmp	r3, #0x0
 8015bd0: d003         	beq	0x8015bda <uart_stm32_err_check+0x7c> @ imm = #0x6
; 		err |= UART_BREAK;
 8015bd2: 697b         	ldr	r3, [r7, #0x14]
 8015bd4: f043 0308    	orr	r3, r3, #0x8
 8015bd8: 617b         	str	r3, [r7, #0x14]
; 	if (err & UART_BREAK) {
 8015bda: 697b         	ldr	r3, [r7, #0x14]
 8015bdc: f003 0308    	and	r3, r3, #0x8
 8015be0: 2b00         	cmp	r3, #0x0
 8015be2: d002         	beq	0x8015bea <uart_stm32_err_check+0x8c> @ imm = #0x4
; 		LL_USART_ClearFlag_LBD(usart);
 8015be4: 68f8         	ldr	r0, [r7, #0xc]
 8015be6: f7ff fab5    	bl	0x8015154 <LL_USART_ClearFlag_LBD> @ imm = #-0xa96
; 	if (err & UART_ERROR_OVERRUN) {
 8015bea: 697b         	ldr	r3, [r7, #0x14]
 8015bec: f003 0301    	and	r3, r3, #0x1
 8015bf0: 2b00         	cmp	r3, #0x0
 8015bf2: d002         	beq	0x8015bfa <uart_stm32_err_check+0x9c> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 8015bf4: 68f8         	ldr	r0, [r7, #0xc]
 8015bf6: f7ff fa71    	bl	0x80150dc <LL_USART_ClearFlag_ORE> @ imm = #-0xb1e
; 	if (err & UART_ERROR_PARITY) {
 8015bfa: 697b         	ldr	r3, [r7, #0x14]
 8015bfc: f003 0302    	and	r3, r3, #0x2
 8015c00: 2b00         	cmp	r3, #0x0
 8015c02: d002         	beq	0x8015c0a <uart_stm32_err_check+0xac> @ imm = #0x4
; 		LL_USART_ClearFlag_PE(usart);
 8015c04: 68f8         	ldr	r0, [r7, #0xc]
 8015c06: f7ff fa36    	bl	0x8015076 <LL_USART_ClearFlag_PE> @ imm = #-0xb94
; 	if (err & UART_ERROR_FRAMING) {
 8015c0a: 697b         	ldr	r3, [r7, #0x14]
 8015c0c: f003 0304    	and	r3, r3, #0x4
 8015c10: 2b00         	cmp	r3, #0x0
 8015c12: d002         	beq	0x8015c1a <uart_stm32_err_check+0xbc> @ imm = #0x4
; 		LL_USART_ClearFlag_FE(usart);
 8015c14: 68f8         	ldr	r0, [r7, #0xc]
 8015c16: f7ff fa3f    	bl	0x8015098 <LL_USART_ClearFlag_FE> @ imm = #-0xb82
; 	if (err & UART_ERROR_NOISE) {
 8015c1a: 697b         	ldr	r3, [r7, #0x14]
 8015c1c: f003 0320    	and	r3, r3, #0x20
 8015c20: 2b00         	cmp	r3, #0x0
 8015c22: d002         	beq	0x8015c2a <uart_stm32_err_check+0xcc> @ imm = #0x4
; 		LL_USART_ClearFlag_NE(usart);
 8015c24: 68f8         	ldr	r0, [r7, #0xc]
 8015c26: f7ff fa48    	bl	0x80150ba <LL_USART_ClearFlag_NE> @ imm = #-0xb70
; 	return err;
 8015c2a: 697b         	ldr	r3, [r7, #0x14]
; }
 8015c2c: 4618         	mov	r0, r3
 8015c2e: 3718         	adds	r7, #0x18
 8015c30: 46bd         	mov	sp, r7
 8015c32: bd80         	pop	{r7, pc}

08015c34 <uart_stm32_fifo_fill_visitor>:
; {
 8015c34: b580         	push	{r7, lr}
 8015c36: b08e         	sub	sp, #0x38
 8015c38: af00         	add	r7, sp, #0x0
 8015c3a: 60f8         	str	r0, [r7, #0xc]
 8015c3c: 60b9         	str	r1, [r7, #0x8]
 8015c3e: 607a         	str	r2, [r7, #0x4]
 8015c40: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8015c42: 68fb         	ldr	r3, [r7, #0xc]
 8015c44: 685b         	ldr	r3, [r3, #0x4]
 8015c46: 633b         	str	r3, [r7, #0x30]
; 	USART_TypeDef *usart = config->usart;
 8015c48: 6b3b         	ldr	r3, [r7, #0x30]
 8015c4a: 681b         	ldr	r3, [r3]
 8015c4c: 62fb         	str	r3, [r7, #0x2c]
; 	int num_tx = 0U;
 8015c4e: 2300         	movs	r3, #0x0
 8015c50: 637b         	str	r3, [r7, #0x34]
; 	if (!LL_USART_IsActiveFlag_TXE(usart)) {
 8015c52: 6af8         	ldr	r0, [r7, #0x2c]
 8015c54: f7ff f9ea    	bl	0x801502c <LL_USART_IsActiveFlag_TXE> @ imm = #-0xc2c
 8015c58: 4603         	mov	r3, r0
 8015c5a: 2b00         	cmp	r3, #0x0
 8015c5c: d101         	bne	0x8015c62 <uart_stm32_fifo_fill_visitor+0x2e> @ imm = #0x2
; 		return num_tx;
 8015c5e: 6b7b         	ldr	r3, [r7, #0x34]
 8015c60: e030         	b	0x8015cc4 <uart_stm32_fifo_fill_visitor+0x90> @ imm = #0x60
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015c62: f3ef 8311    	mrs	r3, basepri
 8015c66: 627b         	str	r3, [r7, #0x24]
;   return(result);
 8015c68: 6a7b         	ldr	r3, [r7, #0x24]
; 	key = __get_BASEPRI();
 8015c6a: 623b         	str	r3, [r7, #0x20]
 8015c6c: 2310         	movs	r3, #0x10
 8015c6e: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015c70: 69fb         	ldr	r3, [r7, #0x1c]
 8015c72: f383 8812    	msr	basepri_max, r3
; }
 8015c76: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015c78: f3bf 8f6f    	isb	sy
; }
 8015c7c: bf00         	nop
; 	return key;
 8015c7e: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = irq_lock();
 8015c80: 62bb         	str	r3, [r7, #0x28]
; 	while ((size - num_tx > 0) && LL_USART_IsActiveFlag_TXE(usart)) {
 8015c82: e007         	b	0x8015c94 <uart_stm32_fifo_fill_visitor+0x60> @ imm = #0xe
; 		fill_fn(usart, tx_data, num_tx);
 8015c84: 683b         	ldr	r3, [r7]
 8015c86: 6b7a         	ldr	r2, [r7, #0x34]
 8015c88: 68b9         	ldr	r1, [r7, #0x8]
 8015c8a: 6af8         	ldr	r0, [r7, #0x2c]
 8015c8c: 4798         	blx	r3
; 		num_tx++;
 8015c8e: 6b7b         	ldr	r3, [r7, #0x34]
 8015c90: 3301         	adds	r3, #0x1
 8015c92: 637b         	str	r3, [r7, #0x34]
; 	while ((size - num_tx > 0) && LL_USART_IsActiveFlag_TXE(usart)) {
 8015c94: 687a         	ldr	r2, [r7, #0x4]
 8015c96: 6b7b         	ldr	r3, [r7, #0x34]
 8015c98: 1ad3         	subs	r3, r2, r3
 8015c9a: 2b00         	cmp	r3, #0x0
 8015c9c: dd05         	ble	0x8015caa <uart_stm32_fifo_fill_visitor+0x76> @ imm = #0xa
 8015c9e: 6af8         	ldr	r0, [r7, #0x2c]
 8015ca0: f7ff f9c4    	bl	0x801502c <LL_USART_IsActiveFlag_TXE> @ imm = #-0xc78
 8015ca4: 4603         	mov	r3, r0
 8015ca6: 2b00         	cmp	r3, #0x0
 8015ca8: d1ec         	bne	0x8015c84 <uart_stm32_fifo_fill_visitor+0x50> @ imm = #-0x28
 8015caa: 6abb         	ldr	r3, [r7, #0x28]
 8015cac: 61bb         	str	r3, [r7, #0x18]
 8015cae: 69bb         	ldr	r3, [r7, #0x18]
 8015cb0: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015cb2: 697b         	ldr	r3, [r7, #0x14]
 8015cb4: f383 8811    	msr	basepri, r3
; }
 8015cb8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015cba: f3bf 8f6f    	isb	sy
; }
 8015cbe: bf00         	nop
; }
 8015cc0: bf00         	nop
; 	return num_tx;
 8015cc2: 6b7b         	ldr	r3, [r7, #0x34]
; }
 8015cc4: 4618         	mov	r0, r3
 8015cc6: 3738         	adds	r7, #0x38
 8015cc8: 46bd         	mov	sp, r7
 8015cca: bd80         	pop	{r7, pc}

08015ccc <fifo_fill_with_u8>:
; {
 8015ccc: b580         	push	{r7, lr}
 8015cce: b086         	sub	sp, #0x18
 8015cd0: af00         	add	r7, sp, #0x0
 8015cd2: 60f8         	str	r0, [r7, #0xc]
 8015cd4: 60b9         	str	r1, [r7, #0x8]
 8015cd6: 607a         	str	r2, [r7, #0x4]
; 	const uint8_t *data = (const uint8_t *)tx_data;
 8015cd8: 68bb         	ldr	r3, [r7, #0x8]
 8015cda: 617b         	str	r3, [r7, #0x14]
; 	LL_USART_TransmitData8(usart, data[offset]);
 8015cdc: 687b         	ldr	r3, [r7, #0x4]
 8015cde: 697a         	ldr	r2, [r7, #0x14]
 8015ce0: 4413         	add	r3, r2
 8015ce2: 781b         	ldrb	r3, [r3]
 8015ce4: 4619         	mov	r1, r3
 8015ce6: 68f8         	ldr	r0, [r7, #0xc]
 8015ce8: f7ff fc66    	bl	0x80155b8 <LL_USART_TransmitData8> @ imm = #-0x734
; }
 8015cec: bf00         	nop
 8015cee: 3718         	adds	r7, #0x18
 8015cf0: 46bd         	mov	sp, r7
 8015cf2: bd80         	pop	{r7, pc}

08015cf4 <uart_stm32_fifo_read_visitor>:
; {
 8015cf4: b580         	push	{r7, lr}
 8015cf6: b088         	sub	sp, #0x20
 8015cf8: af00         	add	r7, sp, #0x0
 8015cfa: 60f8         	str	r0, [r7, #0xc]
 8015cfc: 60b9         	str	r1, [r7, #0x8]
 8015cfe: 607a         	str	r2, [r7, #0x4]
 8015d00: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8015d02: 68fb         	ldr	r3, [r7, #0xc]
 8015d04: 685b         	ldr	r3, [r3, #0x4]
 8015d06: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 8015d08: 69bb         	ldr	r3, [r7, #0x18]
 8015d0a: 681b         	ldr	r3, [r3]
 8015d0c: 617b         	str	r3, [r7, #0x14]
; 	int num_rx = 0U;
 8015d0e: 2300         	movs	r3, #0x0
 8015d10: 61fb         	str	r3, [r7, #0x1c]
; 	while ((size - num_rx > 0) && LL_USART_IsActiveFlag_RXNE(usart)) {
 8015d12: e010         	b	0x8015d36 <uart_stm32_fifo_read_visitor+0x42> @ imm = #0x20
; 		read_fn(usart, rx_data, num_rx);
 8015d14: 683b         	ldr	r3, [r7]
 8015d16: 69fa         	ldr	r2, [r7, #0x1c]
 8015d18: 68b9         	ldr	r1, [r7, #0x8]
 8015d1a: 6978         	ldr	r0, [r7, #0x14]
 8015d1c: 4798         	blx	r3
; 		num_rx++;
 8015d1e: 69fb         	ldr	r3, [r7, #0x1c]
 8015d20: 3301         	adds	r3, #0x1
 8015d22: 61fb         	str	r3, [r7, #0x1c]
; 		if (LL_USART_IsActiveFlag_ORE(usart)) {
 8015d24: 6978         	ldr	r0, [r7, #0x14]
 8015d26: f7ff f939    	bl	0x8014f9c <LL_USART_IsActiveFlag_ORE> @ imm = #-0xd8e
 8015d2a: 4603         	mov	r3, r0
 8015d2c: 2b00         	cmp	r3, #0x0
 8015d2e: d002         	beq	0x8015d36 <uart_stm32_fifo_read_visitor+0x42> @ imm = #0x4
; 			LL_USART_ClearFlag_ORE(usart);
 8015d30: 6978         	ldr	r0, [r7, #0x14]
 8015d32: f7ff f9d3    	bl	0x80150dc <LL_USART_ClearFlag_ORE> @ imm = #-0xc5a
; 	while ((size - num_rx > 0) && LL_USART_IsActiveFlag_RXNE(usart)) {
 8015d36: 687a         	ldr	r2, [r7, #0x4]
 8015d38: 69fb         	ldr	r3, [r7, #0x1c]
 8015d3a: 1ad3         	subs	r3, r2, r3
 8015d3c: 2b00         	cmp	r3, #0x0
 8015d3e: dd05         	ble	0x8015d4c <uart_stm32_fifo_read_visitor+0x58> @ imm = #0xa
 8015d40: 6978         	ldr	r0, [r7, #0x14]
 8015d42: f7ff f94f    	bl	0x8014fe4 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xd62
 8015d46: 4603         	mov	r3, r0
 8015d48: 2b00         	cmp	r3, #0x0
 8015d4a: d1e3         	bne	0x8015d14 <uart_stm32_fifo_read_visitor+0x20> @ imm = #-0x3a
; 	return num_rx;
 8015d4c: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8015d4e: 4618         	mov	r0, r3
 8015d50: 3720         	adds	r7, #0x20
 8015d52: 46bd         	mov	sp, r7
 8015d54: bd80         	pop	{r7, pc}

08015d56 <fifo_read_with_u8>:
; {
 8015d56: b590         	push	{r4, r7, lr}
 8015d58: b087         	sub	sp, #0x1c
 8015d5a: af00         	add	r7, sp, #0x0
 8015d5c: 60f8         	str	r0, [r7, #0xc]
 8015d5e: 60b9         	str	r1, [r7, #0x8]
 8015d60: 607a         	str	r2, [r7, #0x4]
; 	uint8_t *data = (uint8_t *)rx_data;
 8015d62: 68bb         	ldr	r3, [r7, #0x8]
 8015d64: 617b         	str	r3, [r7, #0x14]
; 	data[offset] = LL_USART_ReceiveData8(usart);
 8015d66: 687b         	ldr	r3, [r7, #0x4]
 8015d68: 697a         	ldr	r2, [r7, #0x14]
 8015d6a: 18d4         	adds	r4, r2, r3
 8015d6c: 68f8         	ldr	r0, [r7, #0xc]
 8015d6e: f7ff fc17    	bl	0x80155a0 <LL_USART_ReceiveData8> @ imm = #-0x7d2
 8015d72: 4603         	mov	r3, r0
 8015d74: 7023         	strb	r3, [r4]
; }
 8015d76: bf00         	nop
 8015d78: 371c         	adds	r7, #0x1c
 8015d7a: 46bd         	mov	sp, r7
 8015d7c: bd90         	pop	{r4, r7, pc}

08015d7e <uart_stm32_irq_tx_enable>:
; {
 8015d7e: b580         	push	{r7, lr}
 8015d80: b084         	sub	sp, #0x10
 8015d82: af00         	add	r7, sp, #0x0
 8015d84: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8015d86: 687b         	ldr	r3, [r7, #0x4]
 8015d88: 685b         	ldr	r3, [r3, #0x4]
 8015d8a: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableIT_TC(config->usart);
 8015d8c: 68fb         	ldr	r3, [r7, #0xc]
 8015d8e: 681b         	ldr	r3, [r3]
 8015d90: 4618         	mov	r0, r3
 8015d92: f7ff fa30    	bl	0x80151f6 <LL_USART_EnableIT_TC> @ imm = #-0xba0
; }
 8015d96: bf00         	nop
 8015d98: 3710         	adds	r7, #0x10
 8015d9a: 46bd         	mov	sp, r7
 8015d9c: bd80         	pop	{r7, pc}

08015d9e <uart_stm32_irq_tx_disable>:
; {
 8015d9e: b580         	push	{r7, lr}
 8015da0: b084         	sub	sp, #0x10
 8015da2: af00         	add	r7, sp, #0x0
 8015da4: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8015da6: 687b         	ldr	r3, [r7, #0x4]
 8015da8: 685b         	ldr	r3, [r3, #0x4]
 8015daa: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableIT_TC(config->usart);
 8015dac: 68fb         	ldr	r3, [r7, #0xc]
 8015dae: 681b         	ldr	r3, [r3]
 8015db0: 4618         	mov	r0, r3
 8015db2: f7ff fad9    	bl	0x8015368 <LL_USART_DisableIT_TC> @ imm = #-0xa4e
; }
 8015db6: bf00         	nop
 8015db8: 3710         	adds	r7, #0x10
 8015dba: 46bd         	mov	sp, r7
 8015dbc: bd80         	pop	{r7, pc}

08015dbe <uart_stm32_irq_tx_ready>:
; {
 8015dbe: b580         	push	{r7, lr}
 8015dc0: b084         	sub	sp, #0x10
 8015dc2: af00         	add	r7, sp, #0x0
 8015dc4: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8015dc6: 687b         	ldr	r3, [r7, #0x4]
 8015dc8: 685b         	ldr	r3, [r3, #0x4]
 8015dca: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_TXE(config->usart) &&
 8015dcc: 68fb         	ldr	r3, [r7, #0xc]
 8015dce: 681b         	ldr	r3, [r3]
 8015dd0: 4618         	mov	r0, r3
 8015dd2: f7ff f92b    	bl	0x801502c <LL_USART_IsActiveFlag_TXE> @ imm = #-0xdaa
 8015dd6: 4603         	mov	r3, r0
 8015dd8: 2b00         	cmp	r3, #0x0
 8015dda: d009         	beq	0x8015df0 <uart_stm32_irq_tx_ready+0x32> @ imm = #0x12
; 		LL_USART_IsEnabledIT_TC(config->usart);
 8015ddc: 68fb         	ldr	r3, [r7, #0xc]
 8015dde: 681b         	ldr	r3, [r3]
 8015de0: 4618         	mov	r0, r3
 8015de2: f7ff fb5a    	bl	0x801549a <LL_USART_IsEnabledIT_TC> @ imm = #-0x94c
 8015de6: 4603         	mov	r3, r0
; 	return LL_USART_IsActiveFlag_TXE(config->usart) &&
 8015de8: 2b00         	cmp	r3, #0x0
 8015dea: d001         	beq	0x8015df0 <uart_stm32_irq_tx_ready+0x32> @ imm = #0x2
 8015dec: 2301         	movs	r3, #0x1
 8015dee: e000         	b	0x8015df2 <uart_stm32_irq_tx_ready+0x34> @ imm = #0x0
 8015df0: 2300         	movs	r3, #0x0
; }
 8015df2: 4618         	mov	r0, r3
 8015df4: 3710         	adds	r7, #0x10
 8015df6: 46bd         	mov	sp, r7
 8015df8: bd80         	pop	{r7, pc}

08015dfa <uart_stm32_irq_tx_complete>:
; {
 8015dfa: b580         	push	{r7, lr}
 8015dfc: b084         	sub	sp, #0x10
 8015dfe: af00         	add	r7, sp, #0x0
 8015e00: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8015e02: 687b         	ldr	r3, [r7, #0x4]
 8015e04: 685b         	ldr	r3, [r3, #0x4]
 8015e06: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_TC(config->usart);
 8015e08: 68fb         	ldr	r3, [r7, #0xc]
 8015e0a: 681b         	ldr	r3, [r3]
 8015e0c: 4618         	mov	r0, r3
 8015e0e: f7ff f8fb    	bl	0x8015008 <LL_USART_IsActiveFlag_TC> @ imm = #-0xe0a
 8015e12: 4603         	mov	r3, r0
; }
 8015e14: 4618         	mov	r0, r3
 8015e16: 3710         	adds	r7, #0x10
 8015e18: 46bd         	mov	sp, r7
 8015e1a: bd80         	pop	{r7, pc}

08015e1c <uart_stm32_irq_rx_enable>:
; {
 8015e1c: b580         	push	{r7, lr}
 8015e1e: b084         	sub	sp, #0x10
 8015e20: af00         	add	r7, sp, #0x0
 8015e22: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8015e24: 687b         	ldr	r3, [r7, #0x4]
 8015e26: 685b         	ldr	r3, [r3, #0x4]
 8015e28: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableIT_RXNE(config->usart);
 8015e2a: 68fb         	ldr	r3, [r7, #0xc]
 8015e2c: 681b         	ldr	r3, [r3]
 8015e2e: 4618         	mov	r0, r3
 8015e30: f7ff f9bf    	bl	0x80151b2 <LL_USART_EnableIT_RXNE> @ imm = #-0xc82
; }
 8015e34: bf00         	nop
 8015e36: 3710         	adds	r7, #0x10
 8015e38: 46bd         	mov	sp, r7
 8015e3a: bd80         	pop	{r7, pc}

08015e3c <uart_stm32_irq_rx_disable>:
; {
 8015e3c: b580         	push	{r7, lr}
 8015e3e: b084         	sub	sp, #0x10
 8015e40: af00         	add	r7, sp, #0x0
 8015e42: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8015e44: 687b         	ldr	r3, [r7, #0x4]
 8015e46: 685b         	ldr	r3, [r3, #0x4]
 8015e48: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableIT_RXNE(config->usart);
 8015e4a: 68fb         	ldr	r3, [r7, #0xc]
 8015e4c: 681b         	ldr	r3, [r3]
 8015e4e: 4618         	mov	r0, r3
 8015e50: f7ff fa68    	bl	0x8015324 <LL_USART_DisableIT_RXNE> @ imm = #-0xb30
; }
 8015e54: bf00         	nop
 8015e56: 3710         	adds	r7, #0x10
 8015e58: 46bd         	mov	sp, r7
 8015e5a: bd80         	pop	{r7, pc}

08015e5c <uart_stm32_irq_rx_ready>:
; {
 8015e5c: b580         	push	{r7, lr}
 8015e5e: b084         	sub	sp, #0x10
 8015e60: af00         	add	r7, sp, #0x0
 8015e62: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8015e64: 687b         	ldr	r3, [r7, #0x4]
 8015e66: 685b         	ldr	r3, [r3, #0x4]
 8015e68: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_RXNE(config->usart);
 8015e6a: 68fb         	ldr	r3, [r7, #0xc]
 8015e6c: 681b         	ldr	r3, [r3]
 8015e6e: 4618         	mov	r0, r3
 8015e70: f7ff f8b8    	bl	0x8014fe4 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xe90
 8015e74: 4603         	mov	r3, r0
; }
 8015e76: 4618         	mov	r0, r3
 8015e78: 3710         	adds	r7, #0x10
 8015e7a: 46bd         	mov	sp, r7
 8015e7c: bd80         	pop	{r7, pc}

08015e7e <uart_stm32_irq_is_pending>:
; {
 8015e7e: b580         	push	{r7, lr}
 8015e80: b084         	sub	sp, #0x10
 8015e82: af00         	add	r7, sp, #0x0
 8015e84: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8015e86: 687b         	ldr	r3, [r7, #0x4]
 8015e88: 685b         	ldr	r3, [r3, #0x4]
 8015e8a: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 8015e8c: 68fb         	ldr	r3, [r7, #0xc]
 8015e8e: 681b         	ldr	r3, [r3]
 8015e90: 60bb         	str	r3, [r7, #0x8]
; 	return ((LL_USART_IsActiveFlag_RXNE(usart) &&
 8015e92: 68b8         	ldr	r0, [r7, #0x8]
 8015e94: f7ff f8a6    	bl	0x8014fe4 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xeb4
 8015e98: 4603         	mov	r3, r0
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 8015e9a: 2b00         	cmp	r3, #0x0
 8015e9c: d005         	beq	0x8015eaa <uart_stm32_irq_is_pending+0x2c> @ imm = #0xa
 8015e9e: 68b8         	ldr	r0, [r7, #0x8]
 8015ea0: f7ff fae9    	bl	0x8015476 <LL_USART_IsEnabledIT_RXNE> @ imm = #-0xa2e
 8015ea4: 4603         	mov	r3, r0
; 	return ((LL_USART_IsActiveFlag_RXNE(usart) &&
 8015ea6: 2b00         	cmp	r3, #0x0
 8015ea8: d10b         	bne	0x8015ec2 <uart_stm32_irq_is_pending+0x44> @ imm = #0x16
; 		(LL_USART_IsActiveFlag_TC(usart) &&
 8015eaa: 68b8         	ldr	r0, [r7, #0x8]
 8015eac: f7ff f8ac    	bl	0x8015008 <LL_USART_IsActiveFlag_TC> @ imm = #-0xea8
 8015eb0: 4603         	mov	r3, r0
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 8015eb2: 2b00         	cmp	r3, #0x0
 8015eb4: d007         	beq	0x8015ec6 <uart_stm32_irq_is_pending+0x48> @ imm = #0xe
; 		 LL_USART_IsEnabledIT_TC(usart)));
 8015eb6: 68b8         	ldr	r0, [r7, #0x8]
 8015eb8: f7ff faef    	bl	0x801549a <LL_USART_IsEnabledIT_TC> @ imm = #-0xa22
 8015ebc: 4603         	mov	r3, r0
; 		(LL_USART_IsActiveFlag_TC(usart) &&
 8015ebe: 2b00         	cmp	r3, #0x0
 8015ec0: d001         	beq	0x8015ec6 <uart_stm32_irq_is_pending+0x48> @ imm = #0x2
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 8015ec2: 2301         	movs	r3, #0x1
 8015ec4: e000         	b	0x8015ec8 <uart_stm32_irq_is_pending+0x4a> @ imm = #0x0
 8015ec6: 2300         	movs	r3, #0x0
; }
 8015ec8: 4618         	mov	r0, r3
 8015eca: 3710         	adds	r7, #0x10
 8015ecc: 46bd         	mov	sp, r7
 8015ece: bd80         	pop	{r7, pc}

08015ed0 <uart_stm32_irq_update>:
; {
 8015ed0: b480         	push	{r7}
 8015ed2: b083         	sub	sp, #0xc
 8015ed4: af00         	add	r7, sp, #0x0
 8015ed6: 6078         	str	r0, [r7, #0x4]
; 	return 1;
 8015ed8: 2301         	movs	r3, #0x1
; }
 8015eda: 4618         	mov	r0, r3
 8015edc: 370c         	adds	r7, #0xc
 8015ede: 46bd         	mov	sp, r7
 8015ee0: bc80         	pop	{r7}
 8015ee2: 4770         	bx	lr

08015ee4 <uart_stm32_irq_callback_set>:
; {
 8015ee4: b480         	push	{r7}
 8015ee6: b087         	sub	sp, #0x1c
 8015ee8: af00         	add	r7, sp, #0x0
 8015eea: 60f8         	str	r0, [r7, #0xc]
 8015eec: 60b9         	str	r1, [r7, #0x8]
 8015eee: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 8015ef0: 68fb         	ldr	r3, [r7, #0xc]
 8015ef2: 691b         	ldr	r3, [r3, #0x10]
 8015ef4: 617b         	str	r3, [r7, #0x14]
; 	data->user_cb = cb;
 8015ef6: 697b         	ldr	r3, [r7, #0x14]
 8015ef8: 68ba         	ldr	r2, [r7, #0x8]
 8015efa: 609a         	str	r2, [r3, #0x8]
; 	data->user_data = cb_data;
 8015efc: 697b         	ldr	r3, [r7, #0x14]
 8015efe: 687a         	ldr	r2, [r7, #0x4]
 8015f00: 60da         	str	r2, [r3, #0xc]
; 	data->async_cb = NULL;
 8015f02: 697b         	ldr	r3, [r7, #0x14]
 8015f04: 2200         	movs	r2, #0x0
 8015f06: 615a         	str	r2, [r3, #0x14]
; 	data->async_user_data = NULL;
 8015f08: 697b         	ldr	r3, [r7, #0x14]
 8015f0a: 2200         	movs	r2, #0x0
 8015f0c: 619a         	str	r2, [r3, #0x18]
; }
 8015f0e: bf00         	nop
 8015f10: 371c         	adds	r7, #0x1c
 8015f12: 46bd         	mov	sp, r7
 8015f14: bc80         	pop	{r7}
 8015f16: 4770         	bx	lr

08015f18 <async_user_callback>:
; {
 8015f18: b580         	push	{r7, lr}
 8015f1a: b082         	sub	sp, #0x8
 8015f1c: af00         	add	r7, sp, #0x0
 8015f1e: 6078         	str	r0, [r7, #0x4]
 8015f20: 6039         	str	r1, [r7]
; 	if (data->async_cb) {
 8015f22: 687b         	ldr	r3, [r7, #0x4]
 8015f24: 695b         	ldr	r3, [r3, #0x14]
 8015f26: 2b00         	cmp	r3, #0x0
 8015f28: d007         	beq	0x8015f3a <async_user_callback+0x22> @ imm = #0xe
; 		data->async_cb(data->uart_dev, event, data->async_user_data);
 8015f2a: 687b         	ldr	r3, [r7, #0x4]
 8015f2c: 695b         	ldr	r3, [r3, #0x14]
 8015f2e: 687a         	ldr	r2, [r7, #0x4]
 8015f30: 6910         	ldr	r0, [r2, #0x10]
 8015f32: 687a         	ldr	r2, [r7, #0x4]
 8015f34: 6992         	ldr	r2, [r2, #0x18]
 8015f36: 6839         	ldr	r1, [r7]
 8015f38: 4798         	blx	r3
; }
 8015f3a: bf00         	nop
 8015f3c: 3708         	adds	r7, #0x8
 8015f3e: 46bd         	mov	sp, r7
 8015f40: bd80         	pop	{r7, pc}

08015f42 <async_evt_rx_buf_request>:
; {
 8015f42: b580         	push	{r7, lr}
 8015f44: b088         	sub	sp, #0x20
 8015f46: af00         	add	r7, sp, #0x0
 8015f48: 6078         	str	r0, [r7, #0x4]
; 	struct uart_event evt = {
 8015f4a: f107 030c    	add.w	r3, r7, #0xc
 8015f4e: 2200         	movs	r2, #0x0
 8015f50: 601a         	str	r2, [r3]
 8015f52: 605a         	str	r2, [r3, #0x4]
 8015f54: 609a         	str	r2, [r3, #0x8]
 8015f56: 60da         	str	r2, [r3, #0xc]
 8015f58: 611a         	str	r2, [r3, #0x10]
 8015f5a: 2303         	movs	r3, #0x3
 8015f5c: 733b         	strb	r3, [r7, #0xc]
; 	async_user_callback(data, &evt);
 8015f5e: f107 030c    	add.w	r3, r7, #0xc
 8015f62: 4619         	mov	r1, r3
 8015f64: 6878         	ldr	r0, [r7, #0x4]
 8015f66: f7ff ffd7    	bl	0x8015f18 <async_user_callback> @ imm = #-0x52
; }
 8015f6a: bf00         	nop
 8015f6c: 3720         	adds	r7, #0x20
 8015f6e: 46bd         	mov	sp, r7
 8015f70: bd80         	pop	{r7, pc}

08015f72 <async_evt_rx_buf_release>:
; {
 8015f72: b580         	push	{r7, lr}
 8015f74: b088         	sub	sp, #0x20
 8015f76: af00         	add	r7, sp, #0x0
 8015f78: 6078         	str	r0, [r7, #0x4]
; 	struct uart_event evt = {
 8015f7a: f107 030c    	add.w	r3, r7, #0xc
 8015f7e: 2200         	movs	r2, #0x0
 8015f80: 601a         	str	r2, [r3]
 8015f82: 605a         	str	r2, [r3, #0x4]
 8015f84: 609a         	str	r2, [r3, #0x8]
 8015f86: 60da         	str	r2, [r3, #0xc]
 8015f88: 611a         	str	r2, [r3, #0x10]
 8015f8a: 2304         	movs	r3, #0x4
 8015f8c: 733b         	strb	r3, [r7, #0xc]
; 		.data.rx_buf.buf = data->dma_rx.buffer,
 8015f8e: 687b         	ldr	r3, [r7, #0x4]
 8015f90: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event evt = {
 8015f92: 613b         	str	r3, [r7, #0x10]
; 	async_user_callback(data, &evt);
 8015f94: f107 030c    	add.w	r3, r7, #0xc
 8015f98: 4619         	mov	r1, r3
 8015f9a: 6878         	ldr	r0, [r7, #0x4]
 8015f9c: f7ff ffbc    	bl	0x8015f18 <async_user_callback> @ imm = #-0x88
; }
 8015fa0: bf00         	nop
 8015fa2: 3720         	adds	r7, #0x20
 8015fa4: 46bd         	mov	sp, r7
 8015fa6: bd80         	pop	{r7, pc}

08015fa8 <uart_stm32_dma_rx_flush>:
; {
 8015fa8: b580         	push	{r7, lr}
 8015faa: b08c         	sub	sp, #0x30
 8015fac: af00         	add	r7, sp, #0x0
 8015fae: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 8015fb0: 687b         	ldr	r3, [r7, #0x4]
 8015fb2: 691b         	ldr	r3, [r3, #0x10]
 8015fb4: 62fb         	str	r3, [r7, #0x2c]
; 	if (dma_get_status(data->dma_rx.dma_dev,
 8015fb6: 6afb         	ldr	r3, [r7, #0x2c]
 8015fb8: 6a18         	ldr	r0, [r3, #0x20]
 8015fba: 6afb         	ldr	r3, [r7, #0x2c]
 8015fbc: 6a5b         	ldr	r3, [r3, #0x24]
 8015fbe: f107 0208    	add.w	r2, r7, #0x8
 8015fc2: 4619         	mov	r1, r3
 8015fc4: f7fe fe16    	bl	0x8014bf4 <dma_get_status> @ imm = #-0x13d4
 8015fc8: 4603         	mov	r3, r0
 8015fca: 2b00         	cmp	r3, #0x0
 8015fcc: d10f         	bne	0x8015fee <uart_stm32_dma_rx_flush+0x46> @ imm = #0x1e
; 		size_t rx_rcv_len = data->dma_rx.buffer_length -
 8015fce: 6afb         	ldr	r3, [r7, #0x2c]
 8015fd0: 6f1a         	ldr	r2, [r3, #0x70]
; 					stat.pending_length;
 8015fd2: 68fb         	ldr	r3, [r7, #0xc]
; 		size_t rx_rcv_len = data->dma_rx.buffer_length -
 8015fd4: 1ad3         	subs	r3, r2, r3
 8015fd6: 62bb         	str	r3, [r7, #0x28]
; 		if (rx_rcv_len > data->dma_rx.offset) {
 8015fd8: 6afb         	ldr	r3, [r7, #0x2c]
 8015fda: 6f5b         	ldr	r3, [r3, #0x74]
 8015fdc: 6aba         	ldr	r2, [r7, #0x28]
 8015fde: 429a         	cmp	r2, r3
 8015fe0: d905         	bls	0x8015fee <uart_stm32_dma_rx_flush+0x46> @ imm = #0xa
; 			data->dma_rx.counter = rx_rcv_len;
 8015fe2: 6afb         	ldr	r3, [r7, #0x2c]
 8015fe4: 6aba         	ldr	r2, [r7, #0x28]
 8015fe6: 679a         	str	r2, [r3, #0x78]
; 			async_evt_rx_rdy(data);
 8015fe8: 6af8         	ldr	r0, [r7, #0x2c]
 8015fea: f7f2 fa3f    	bl	0x800846c <async_evt_rx_rdy> @ imm = #-0xdb82
; }
 8015fee: bf00         	nop
 8015ff0: 3730         	adds	r7, #0x30
 8015ff2: 46bd         	mov	sp, r7
 8015ff4: bd80         	pop	{r7, pc}

08015ff6 <uart_stm32_async_callback_set>:
; {
 8015ff6: b480         	push	{r7}
 8015ff8: b087         	sub	sp, #0x1c
 8015ffa: af00         	add	r7, sp, #0x0
 8015ffc: 60f8         	str	r0, [r7, #0xc]
 8015ffe: 60b9         	str	r1, [r7, #0x8]
 8016000: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 8016002: 68fb         	ldr	r3, [r7, #0xc]
 8016004: 691b         	ldr	r3, [r3, #0x10]
 8016006: 617b         	str	r3, [r7, #0x14]
; 	data->async_cb = callback;
 8016008: 697b         	ldr	r3, [r7, #0x14]
 801600a: 68ba         	ldr	r2, [r7, #0x8]
 801600c: 615a         	str	r2, [r3, #0x14]
; 	data->async_user_data = user_data;
 801600e: 697b         	ldr	r3, [r7, #0x14]
 8016010: 687a         	ldr	r2, [r7, #0x4]
 8016012: 619a         	str	r2, [r3, #0x18]
; 	data->user_cb = NULL;
 8016014: 697b         	ldr	r3, [r7, #0x14]
 8016016: 2200         	movs	r2, #0x0
 8016018: 609a         	str	r2, [r3, #0x8]
; 	data->user_data = NULL;
 801601a: 697b         	ldr	r3, [r7, #0x14]
 801601c: 2200         	movs	r2, #0x0
 801601e: 60da         	str	r2, [r3, #0xc]
; 	return 0;
 8016020: 2300         	movs	r3, #0x0
; }
 8016022: 4618         	mov	r0, r3
 8016024: 371c         	adds	r7, #0x1c
 8016026: 46bd         	mov	sp, r7
 8016028: bc80         	pop	{r7}
 801602a: 4770         	bx	lr

0801602c <uart_stm32_dma_tx_enable>:
; {
 801602c: b580         	push	{r7, lr}
 801602e: b084         	sub	sp, #0x10
 8016030: af00         	add	r7, sp, #0x0
 8016032: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8016034: 687b         	ldr	r3, [r7, #0x4]
 8016036: 685b         	ldr	r3, [r3, #0x4]
 8016038: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableDMAReq_TX(config->usart);
 801603a: 68fb         	ldr	r3, [r7, #0xc]
 801603c: 681b         	ldr	r3, [r3]
 801603e: 4618         	mov	r0, r3
 8016040: f7ff fa5f    	bl	0x8015502 <LL_USART_EnableDMAReq_TX> @ imm = #-0xb42
; }
 8016044: bf00         	nop
 8016046: 3710         	adds	r7, #0x10
 8016048: 46bd         	mov	sp, r7
 801604a: bd80         	pop	{r7, pc}

0801604c <uart_stm32_dma_tx_disable>:
; {
 801604c: b580         	push	{r7, lr}
 801604e: b084         	sub	sp, #0x10
 8016050: af00         	add	r7, sp, #0x0
 8016052: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8016054: 687b         	ldr	r3, [r7, #0x4]
 8016056: 685b         	ldr	r3, [r3, #0x4]
 8016058: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableDMAReq_TX(config->usart);
 801605a: 68fb         	ldr	r3, [r7, #0xc]
 801605c: 681b         	ldr	r3, [r3]
 801605e: 4618         	mov	r0, r3
 8016060: f7ff fa71    	bl	0x8015546 <LL_USART_DisableDMAReq_TX> @ imm = #-0xb1e
; }
 8016064: bf00         	nop
 8016066: 3710         	adds	r7, #0x10
 8016068: 46bd         	mov	sp, r7
 801606a: bd80         	pop	{r7, pc}

0801606c <uart_stm32_dma_rx_enable>:
; {
 801606c: b580         	push	{r7, lr}
 801606e: b084         	sub	sp, #0x10
 8016070: af00         	add	r7, sp, #0x0
 8016072: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8016074: 687b         	ldr	r3, [r7, #0x4]
 8016076: 685b         	ldr	r3, [r3, #0x4]
 8016078: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_stm32_data *data = dev->data;
 801607a: 687b         	ldr	r3, [r7, #0x4]
 801607c: 691b         	ldr	r3, [r3, #0x10]
 801607e: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_EnableDMAReq_RX(config->usart);
 8016080: 68fb         	ldr	r3, [r7, #0xc]
 8016082: 681b         	ldr	r3, [r3]
 8016084: 4618         	mov	r0, r3
 8016086: f7ff fa1a    	bl	0x80154be <LL_USART_EnableDMAReq_RX> @ imm = #-0xbcc
; 	data->dma_rx.enabled = true;
 801608a: 68bb         	ldr	r3, [r7, #0x8]
 801608c: 2201         	movs	r2, #0x1
 801608e: f883 20b0    	strb.w	r2, [r3, #0xb0]
; }
 8016092: bf00         	nop
 8016094: 3710         	adds	r7, #0x10
 8016096: 46bd         	mov	sp, r7
 8016098: bd80         	pop	{r7, pc}

0801609a <uart_stm32_dma_rx_disable>:
; {
 801609a: b480         	push	{r7}
 801609c: b085         	sub	sp, #0x14
 801609e: af00         	add	r7, sp, #0x0
 80160a0: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 80160a2: 687b         	ldr	r3, [r7, #0x4]
 80160a4: 691b         	ldr	r3, [r3, #0x10]
 80160a6: 60fb         	str	r3, [r7, #0xc]
; 	data->dma_rx.enabled = false;
 80160a8: 68fb         	ldr	r3, [r7, #0xc]
 80160aa: 2200         	movs	r2, #0x0
 80160ac: f883 20b0    	strb.w	r2, [r3, #0xb0]
; }
 80160b0: bf00         	nop
 80160b2: 3714         	adds	r7, #0x14
 80160b4: 46bd         	mov	sp, r7
 80160b6: bc80         	pop	{r7}
 80160b8: 4770         	bx	lr

080160ba <uart_stm32_dma_tx_cb>:
; {
 80160ba: b580         	push	{r7, lr}
 80160bc: b094         	sub	sp, #0x50
 80160be: af00         	add	r7, sp, #0x0
 80160c0: 60f8         	str	r0, [r7, #0xc]
 80160c2: 60b9         	str	r1, [r7, #0x8]
 80160c4: 607a         	str	r2, [r7, #0x4]
 80160c6: 603b         	str	r3, [r7]
; 	const struct device *uart_dev = user_data;
 80160c8: 68bb         	ldr	r3, [r7, #0x8]
 80160ca: 64fb         	str	r3, [r7, #0x4c]
; 	struct uart_stm32_data *data = uart_dev->data;
 80160cc: 6cfb         	ldr	r3, [r7, #0x4c]
 80160ce: 691b         	ldr	r3, [r3, #0x10]
 80160d0: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80160d2: f3ef 8311    	mrs	r3, basepri
 80160d6: 643b         	str	r3, [r7, #0x40]
;   return(result);
 80160d8: 6c3b         	ldr	r3, [r7, #0x40]
; 	key = __get_BASEPRI();
 80160da: 63fb         	str	r3, [r7, #0x3c]
 80160dc: 2310         	movs	r3, #0x10
 80160de: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80160e0: 6bbb         	ldr	r3, [r7, #0x38]
 80160e2: f383 8812    	msr	basepri_max, r3
; }
 80160e6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80160e8: f3bf 8f6f    	isb	sy
; }
 80160ec: bf00         	nop
; 	return key;
 80160ee: 6bfb         	ldr	r3, [r7, #0x3c]
; 	unsigned int key = irq_lock();
 80160f0: 647b         	str	r3, [r7, #0x44]
; 	uart_stm32_dma_tx_disable(uart_dev);
 80160f2: 6cf8         	ldr	r0, [r7, #0x4c]
 80160f4: f7ff ffaa    	bl	0x801604c <uart_stm32_dma_tx_disable> @ imm = #-0xac
; 	(void)k_work_cancel_delayable(&data->dma_tx.timeout_work);
 80160f8: 6cbb         	ldr	r3, [r7, #0x48]
 80160fa: f503 738c    	add.w	r3, r3, #0x118
 80160fe: 4618         	mov	r0, r3
 8016100: f7f6 fd1a    	bl	0x800cb38 <k_work_cancel_delayable> @ imm = #-0x95cc
; 	if (!dma_get_status(data->dma_tx.dma_dev,
 8016104: 6cbb         	ldr	r3, [r7, #0x48]
 8016106: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 801610a: 6cbb         	ldr	r3, [r7, #0x48]
 801610c: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 8016110: f107 0210    	add.w	r2, r7, #0x10
 8016114: 4619         	mov	r1, r3
 8016116: f7fe fd6d    	bl	0x8014bf4 <dma_get_status> @ imm = #-0x1526
 801611a: 4603         	mov	r3, r0
 801611c: 2b00         	cmp	r3, #0x0
 801611e: d107         	bne	0x8016130 <uart_stm32_dma_tx_cb+0x76> @ imm = #0xe
; 		data->dma_tx.counter = data->dma_tx.buffer_length -
 8016120: 6cbb         	ldr	r3, [r7, #0x48]
 8016122: f8d3 2108    	ldr.w	r2, [r3, #0x108]
; 					stat.pending_length;
 8016126: 697b         	ldr	r3, [r7, #0x14]
; 		data->dma_tx.counter = data->dma_tx.buffer_length -
 8016128: 1ad2         	subs	r2, r2, r3
 801612a: 6cbb         	ldr	r3, [r7, #0x48]
 801612c: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	data->dma_tx.buffer_length = 0;
 8016130: 6cbb         	ldr	r3, [r7, #0x48]
 8016132: 2200         	movs	r2, #0x0
 8016134: f8c3 2108    	str.w	r2, [r3, #0x108]
 8016138: 6c7b         	ldr	r3, [r7, #0x44]
 801613a: 637b         	str	r3, [r7, #0x34]
 801613c: 6b7b         	ldr	r3, [r7, #0x34]
 801613e: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016140: 6b3b         	ldr	r3, [r7, #0x30]
 8016142: f383 8811    	msr	basepri, r3
; }
 8016146: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016148: f3bf 8f6f    	isb	sy
; }
 801614c: bf00         	nop
; }
 801614e: bf00         	nop
; }
 8016150: bf00         	nop
 8016152: 3750         	adds	r7, #0x50
 8016154: 46bd         	mov	sp, r7
 8016156: bd80         	pop	{r7, pc}

08016158 <uart_stm32_dma_rx_cb>:
; {
 8016158: b580         	push	{r7, lr}
 801615a: b086         	sub	sp, #0x18
 801615c: af00         	add	r7, sp, #0x0
 801615e: 60f8         	str	r0, [r7, #0xc]
 8016160: 60b9         	str	r1, [r7, #0x8]
 8016162: 607a         	str	r2, [r7, #0x4]
 8016164: 603b         	str	r3, [r7]
; 	const struct device *uart_dev = user_data;
 8016166: 68bb         	ldr	r3, [r7, #0x8]
 8016168: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = uart_dev->data;
 801616a: 697b         	ldr	r3, [r7, #0x14]
 801616c: 691b         	ldr	r3, [r3, #0x10]
 801616e: 613b         	str	r3, [r7, #0x10]
; 	if (status < 0) {
 8016170: 683b         	ldr	r3, [r7]
 8016172: 2b00         	cmp	r3, #0x0
 8016174: da04         	bge	0x8016180 <uart_stm32_dma_rx_cb+0x28> @ imm = #0x8
; 		async_evt_rx_err(data, status);
 8016176: 6839         	ldr	r1, [r7]
 8016178: 6938         	ldr	r0, [r7, #0x10]
 801617a: f7f2 f9cd    	bl	0x8008518 <async_evt_rx_err> @ imm = #-0xdc66
; 		return;
 801617e: e021         	b	0x80161c4 <uart_stm32_dma_rx_cb+0x6c> @ imm = #0x42
; 	(void)k_work_cancel_delayable(&data->dma_rx.timeout_work);
 8016180: 693b         	ldr	r3, [r7, #0x10]
 8016182: 3380         	adds	r3, #0x80
 8016184: 4618         	mov	r0, r3
 8016186: f7f6 fcd7    	bl	0x800cb38 <k_work_cancel_delayable> @ imm = #-0x9652
; 	data->dma_rx.counter = data->dma_rx.buffer_length;
 801618a: 693b         	ldr	r3, [r7, #0x10]
 801618c: 6f1a         	ldr	r2, [r3, #0x70]
 801618e: 693b         	ldr	r3, [r7, #0x10]
 8016190: 679a         	str	r2, [r3, #0x78]
; 	async_evt_rx_rdy(data);
 8016192: 6938         	ldr	r0, [r7, #0x10]
 8016194: f7f2 f96a    	bl	0x800846c <async_evt_rx_rdy> @ imm = #-0xdd2c
; 	if (data->rx_next_buffer != NULL) {
 8016198: 693b         	ldr	r3, [r7, #0x10]
 801619a: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 801619e: 2b00         	cmp	r3, #0x0
 80161a0: d006         	beq	0x80161b0 <uart_stm32_dma_rx_cb+0x58> @ imm = #0xc
; 		async_evt_rx_buf_release(data);
 80161a2: 6938         	ldr	r0, [r7, #0x10]
 80161a4: f7ff fee5    	bl	0x8015f72 <async_evt_rx_buf_release> @ imm = #-0x236
; 		uart_stm32_dma_replace_buffer(uart_dev);
 80161a8: 6978         	ldr	r0, [r7, #0x14]
 80161aa: f7f2 fbfd    	bl	0x80089a8 <uart_stm32_dma_replace_buffer> @ imm = #-0xd806
 80161ae: e009         	b	0x80161c4 <uart_stm32_dma_rx_cb+0x6c> @ imm = #0x12
; 		k_work_reschedule(&data->dma_rx.timeout_work, K_TICKS(1));
 80161b0: 693b         	ldr	r3, [r7, #0x10]
 80161b2: f103 0180    	add.w	r1, r3, #0x80
 80161b6: f04f 0201    	mov.w	r2, #0x1
 80161ba: f04f 0300    	mov.w	r3, #0x0
 80161be: 4608         	mov	r0, r1
 80161c0: f7f6 fca6    	bl	0x800cb10 <k_work_reschedule> @ imm = #-0x96b4
; }
 80161c4: 3718         	adds	r7, #0x18
 80161c6: 46bd         	mov	sp, r7
 80161c8: bd80         	pop	{r7, pc}

080161ca <uart_stm32_async_tx_abort>:
; {
 80161ca: b580         	push	{r7, lr}
 80161cc: b08c         	sub	sp, #0x30
 80161ce: af00         	add	r7, sp, #0x0
 80161d0: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 80161d2: 687b         	ldr	r3, [r7, #0x4]
 80161d4: 691b         	ldr	r3, [r3, #0x10]
 80161d6: 62fb         	str	r3, [r7, #0x2c]
; 	size_t tx_buffer_length = data->dma_tx.buffer_length;
 80161d8: 6afb         	ldr	r3, [r7, #0x2c]
 80161da: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 80161de: 62bb         	str	r3, [r7, #0x28]
; 	if (tx_buffer_length == 0) {
 80161e0: 6abb         	ldr	r3, [r7, #0x28]
 80161e2: 2b00         	cmp	r3, #0x0
 80161e4: d102         	bne	0x80161ec <uart_stm32_async_tx_abort+0x22> @ imm = #0x4
; 		return -EFAULT;
 80161e6: f06f 030d    	mvn	r3, #0xd
 80161ea: e027         	b	0x801623c <uart_stm32_async_tx_abort+0x72> @ imm = #0x4e
; 	(void)k_work_cancel_delayable(&data->dma_tx.timeout_work);
 80161ec: 6afb         	ldr	r3, [r7, #0x2c]
 80161ee: f503 738c    	add.w	r3, r3, #0x118
 80161f2: 4618         	mov	r0, r3
 80161f4: f7f6 fca0    	bl	0x800cb38 <k_work_cancel_delayable> @ imm = #-0x96c0
; 	if (!dma_get_status(data->dma_tx.dma_dev,
 80161f8: 6afb         	ldr	r3, [r7, #0x2c]
 80161fa: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 80161fe: 6afb         	ldr	r3, [r7, #0x2c]
 8016200: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 8016204: f107 0208    	add.w	r2, r7, #0x8
 8016208: 4619         	mov	r1, r3
 801620a: f7fe fcf3    	bl	0x8014bf4 <dma_get_status> @ imm = #-0x161a
 801620e: 4603         	mov	r3, r0
 8016210: 2b00         	cmp	r3, #0x0
 8016212: d105         	bne	0x8016220 <uart_stm32_async_tx_abort+0x56> @ imm = #0xa
; 		data->dma_tx.counter = tx_buffer_length - stat.pending_length;
 8016214: 68fb         	ldr	r3, [r7, #0xc]
 8016216: 6aba         	ldr	r2, [r7, #0x28]
 8016218: 1ad2         	subs	r2, r2, r3
 801621a: 6afb         	ldr	r3, [r7, #0x2c]
 801621c: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	dma_stop(data->dma_tx.dma_dev, data->dma_tx.dma_channel);
 8016220: 6afb         	ldr	r3, [r7, #0x2c]
 8016222: f8d3 20b8    	ldr.w	r2, [r3, #0xb8]
 8016226: 6afb         	ldr	r3, [r7, #0x2c]
 8016228: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 801622c: 4619         	mov	r1, r3
 801622e: 4610         	mov	r0, r2
 8016230: f7fe fd09    	bl	0x8014c46 <dma_stop>    @ imm = #-0x15ee
; 	async_evt_tx_abort(data);
 8016234: 6af8         	ldr	r0, [r7, #0x2c]
 8016236: f7f2 f9ff    	bl	0x8008638 <async_evt_tx_abort> @ imm = #-0xdc02
; 	return 0;
 801623a: 2300         	movs	r3, #0x0
; }
 801623c: 4618         	mov	r0, r3
 801623e: 3730         	adds	r7, #0x30
 8016240: 46bd         	mov	sp, r7
 8016242: bd80         	pop	{r7, pc}

08016244 <uart_stm32_init>:
; {
 8016244: b580         	push	{r7, lr}
 8016246: b084         	sub	sp, #0x10
 8016248: af00         	add	r7, sp, #0x0
 801624a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801624c: 687b         	ldr	r3, [r7, #0x4]
 801624e: 685b         	ldr	r3, [r3, #0x4]
 8016250: 60fb         	str	r3, [r7, #0xc]
; 	err = uart_stm32_clocks_enable(dev);
 8016252: 6878         	ldr	r0, [r7, #0x4]
 8016254: f7f2 ffd2    	bl	0x80091fc <uart_stm32_clocks_enable> @ imm = #-0xd05c
 8016258: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 801625a: 68bb         	ldr	r3, [r7, #0x8]
 801625c: 2b00         	cmp	r3, #0x0
 801625e: da01         	bge	0x8016264 <uart_stm32_init+0x20> @ imm = #0x2
; 		return err;
 8016260: 68bb         	ldr	r3, [r7, #0x8]
 8016262: e01c         	b	0x801629e <uart_stm32_init+0x5a> @ imm = #0x38
; 	err = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
 8016264: 68fb         	ldr	r3, [r7, #0xc]
 8016266: 6a1b         	ldr	r3, [r3, #0x20]
 8016268: 2100         	movs	r1, #0x0
 801626a: 4618         	mov	r0, r3
 801626c: f7fe fd0d    	bl	0x8014c8a <pinctrl_apply_state> @ imm = #-0x15e6
 8016270: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 8016272: 68bb         	ldr	r3, [r7, #0x8]
 8016274: 2b00         	cmp	r3, #0x0
 8016276: da01         	bge	0x801627c <uart_stm32_init+0x38> @ imm = #0x2
; 		return err;
 8016278: 68bb         	ldr	r3, [r7, #0x8]
 801627a: e010         	b	0x801629e <uart_stm32_init+0x5a> @ imm = #0x20
; 	err = uart_stm32_registers_configure(dev);
 801627c: 6878         	ldr	r0, [r7, #0x4]
 801627e: f7f3 f825    	bl	0x80092cc <uart_stm32_registers_configure> @ imm = #-0xcfb6
 8016282: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 8016284: 68bb         	ldr	r3, [r7, #0x8]
 8016286: 2b00         	cmp	r3, #0x0
 8016288: da01         	bge	0x801628e <uart_stm32_init+0x4a> @ imm = #0x2
; 		return err;
 801628a: 68bb         	ldr	r3, [r7, #0x8]
 801628c: e007         	b	0x801629e <uart_stm32_init+0x5a> @ imm = #0xe
; 	config->irq_config_func(dev);
 801628e: 68fb         	ldr	r3, [r7, #0xc]
 8016290: 6a5b         	ldr	r3, [r3, #0x24]
 8016292: 6878         	ldr	r0, [r7, #0x4]
 8016294: 4798         	blx	r3
; 	return uart_stm32_async_init(dev);
 8016296: 6878         	ldr	r0, [r7, #0x4]
 8016298: f7f2 fea6    	bl	0x8008fe8 <uart_stm32_async_init> @ imm = #-0xd2b4
 801629c: 4603         	mov	r3, r0
; }
 801629e: 4618         	mov	r0, r3
 80162a0: 3710         	adds	r7, #0x10
 80162a2: 46bd         	mov	sp, r7
 80162a4: bd80         	pop	{r7, pc}

080162a6 <uart_stm32_irq_config_func_0>:
; DT_INST_FOREACH_STATUS_OKAY(STM32_UART_INIT)
 80162a6: b580         	push	{r7, lr}
 80162a8: b082         	sub	sp, #0x8
 80162aa: af00         	add	r7, sp, #0x0
 80162ac: 6078         	str	r0, [r7, #0x4]
 80162ae: 2200         	movs	r2, #0x0
 80162b0: 2100         	movs	r1, #0x0
 80162b2: 2047         	movs	r0, #0x47
 80162b4: f7fb fbfa    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0x480c
 80162b8: 2047         	movs	r0, #0x47
 80162ba: f7fb fbea    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0x482c
 80162be: 3708         	adds	r7, #0x8
 80162c0: 46bd         	mov	sp, r7
 80162c2: bd80         	pop	{r7, pc}

080162c4 <uart_stm32_irq_config_func_1>:
 80162c4: b580         	push	{r7, lr}
 80162c6: b082         	sub	sp, #0x8
 80162c8: af00         	add	r7, sp, #0x0
 80162ca: 6078         	str	r0, [r7, #0x4]
 80162cc: 2200         	movs	r2, #0x0
 80162ce: 2100         	movs	r1, #0x0
 80162d0: 2027         	movs	r0, #0x27
 80162d2: f7fb fbeb    	bl	0x8011aac <z_arm_irq_priority_set> @ imm = #-0x482a
 80162d6: 2027         	movs	r0, #0x27
 80162d8: f7fb fbdb    	bl	0x8011a92 <arch_irq_enable> @ imm = #-0x484a
 80162dc: 3708         	adds	r7, #0x8
 80162de: 46bd         	mov	sp, r7
 80162e0: bd80         	pop	{r7, pc}

080162e2 <device_is_ready>:
; {
 80162e2: b580         	push	{r7, lr}
 80162e4: b082         	sub	sp, #0x8
 80162e6: af00         	add	r7, sp, #0x0
 80162e8: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80162ea: 6878         	ldr	r0, [r7, #0x4]
 80162ec: f000 fd75    	bl	0x8016dda <z_impl_device_is_ready> @ imm = #0xaea
 80162f0: 4603         	mov	r3, r0
; }
 80162f2: 4618         	mov	r0, r3
 80162f4: 3708         	adds	r7, #0x8
 80162f6: 46bd         	mov	sp, r7
 80162f8: bd80         	pop	{r7, pc}

080162fa <arch_k_cycle_get_32>:
; {
 80162fa: b580         	push	{r7, lr}
 80162fc: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 80162fe: f7f3 fa53    	bl	0x80097a8 <sys_clock_cycle_get_32> @ imm = #-0xcb5a
 8016302: 4603         	mov	r3, r0
; }
 8016304: 4618         	mov	r0, r3
 8016306: bd80         	pop	{r7, pc}

08016308 <k_cycle_get_32>:
; {
 8016308: b580         	push	{r7, lr}
 801630a: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 801630c: f7ff fff5    	bl	0x80162fa <arch_k_cycle_get_32> @ imm = #-0x16
 8016310: 4603         	mov	r3, r0
; }
 8016312: 4618         	mov	r0, r3
 8016314: bd80         	pop	{r7, pc}

08016316 <k_sleep>:
; {
 8016316: b580         	push	{r7, lr}
 8016318: b082         	sub	sp, #0x8
 801631a: af00         	add	r7, sp, #0x0
 801631c: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8016320: e9d7 0100    	ldrd	r0, r1, [r7]
 8016324: f7f7 feaa    	bl	0x800e07c <z_impl_k_sleep> @ imm = #-0x82ac
 8016328: 4603         	mov	r3, r0
; }
 801632a: 4618         	mov	r0, r3
 801632c: 3708         	adds	r7, #0x8
 801632e: 46bd         	mov	sp, r7
 8016330: bd80         	pop	{r7, pc}

08016332 <k_thread_start>:
; {
 8016332: b580         	push	{r7, lr}
 8016334: b082         	sub	sp, #0x8
 8016336: af00         	add	r7, sp, #0x0
 8016338: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_start(thread);
 801633a: 6878         	ldr	r0, [r7, #0x4]
 801633c: f001 fe91    	bl	0x8018062 <z_impl_k_thread_start> @ imm = #0x1d22
; }
 8016340: bf00         	nop
 8016342: 3708         	adds	r7, #0x8
 8016344: 46bd         	mov	sp, r7
 8016346: bd80         	pop	{r7, pc}

08016348 <k_sem_init>:
; {
 8016348: b580         	push	{r7, lr}
 801634a: b084         	sub	sp, #0x10
 801634c: af00         	add	r7, sp, #0x0
 801634e: 60f8         	str	r0, [r7, #0xc]
 8016350: 60b9         	str	r1, [r7, #0x8]
 8016352: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 8016354: 687a         	ldr	r2, [r7, #0x4]
 8016356: 68b9         	ldr	r1, [r7, #0x8]
 8016358: 68f8         	ldr	r0, [r7, #0xc]
 801635a: f001 fa37    	bl	0x80177cc <z_impl_k_sem_init> @ imm = #0x146e
 801635e: 4603         	mov	r3, r0
; }
 8016360: 4618         	mov	r0, r3
 8016362: 3710         	adds	r7, #0x10
 8016364: 46bd         	mov	sp, r7
 8016366: bd80         	pop	{r7, pc}

08016368 <k_sem_take>:
; {
 8016368: b580         	push	{r7, lr}
 801636a: b084         	sub	sp, #0x10
 801636c: af00         	add	r7, sp, #0x0
 801636e: 60f8         	str	r0, [r7, #0xc]
 8016370: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 8016374: e9d7 2300    	ldrd	r2, r3, [r7]
 8016378: 68f8         	ldr	r0, [r7, #0xc]
 801637a: f7f6 f869    	bl	0x800c450 <z_impl_k_sem_take> @ imm = #-0x9f2e
 801637e: 4603         	mov	r3, r0
; }
 8016380: 4618         	mov	r0, r3
 8016382: 3710         	adds	r7, #0x10
 8016384: 46bd         	mov	sp, r7
 8016386: bd80         	pop	{r7, pc}

08016388 <k_sem_give>:
; {
 8016388: b580         	push	{r7, lr}
 801638a: b082         	sub	sp, #0x8
 801638c: af00         	add	r7, sp, #0x0
 801638e: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 8016390: 6878         	ldr	r0, [r7, #0x4]
 8016392: f7f5 ffcf    	bl	0x800c334 <z_impl_k_sem_give> @ imm = #-0xa062
; }
 8016396: bf00         	nop
 8016398: 3708         	adds	r7, #0x8
 801639a: 46bd         	mov	sp, r7
 801639c: bd80         	pop	{r7, pc}

0801639e <z_log_msg_runtime_create>:
; {
 801639e: b580         	push	{r7, lr}
 80163a0: b08a         	sub	sp, #0x28
 80163a2: af04         	add	r7, sp, #0x10
 80163a4: 60b9         	str	r1, [r7, #0x8]
 80163a6: 607b         	str	r3, [r7, #0x4]
 80163a8: 4603         	mov	r3, r0
 80163aa: 73fb         	strb	r3, [r7, #0xf]
 80163ac: 4613         	mov	r3, r2
 80163ae: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80163b0: f107 032c    	add.w	r3, r7, #0x2c
 80163b4: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80163b6: 7bba         	ldrb	r2, [r7, #0xe]
 80163b8: 7bf8         	ldrb	r0, [r7, #0xf]
 80163ba: 697b         	ldr	r3, [r7, #0x14]
 80163bc: 9303         	str	r3, [sp, #0xc]
 80163be: 6abb         	ldr	r3, [r7, #0x28]
 80163c0: 9302         	str	r3, [sp, #0x8]
 80163c2: 6a7b         	ldr	r3, [r7, #0x24]
 80163c4: 9301         	str	r3, [sp, #0x4]
 80163c6: 6a3b         	ldr	r3, [r7, #0x20]
 80163c8: 9300         	str	r3, [sp]
 80163ca: 687b         	ldr	r3, [r7, #0x4]
 80163cc: 68b9         	ldr	r1, [r7, #0x8]
 80163ce: f7eb febd    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0x14286
; }
 80163d2: bf00         	nop
 80163d4: 3718         	adds	r7, #0x18
 80163d6: 46bd         	mov	sp, r7
 80163d8: bd80         	pop	{r7, pc}

080163da <z_impl_can_start>:
; {
 80163da: b580         	push	{r7, lr}
 80163dc: b084         	sub	sp, #0x10
 80163de: af00         	add	r7, sp, #0x0
 80163e0: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 80163e2: 687b         	ldr	r3, [r7, #0x4]
 80163e4: 689b         	ldr	r3, [r3, #0x8]
 80163e6: 60fb         	str	r3, [r7, #0xc]
; 	return api->start(dev);
 80163e8: 68fb         	ldr	r3, [r7, #0xc]
 80163ea: 685b         	ldr	r3, [r3, #0x4]
 80163ec: 6878         	ldr	r0, [r7, #0x4]
 80163ee: 4798         	blx	r3
 80163f0: 4603         	mov	r3, r0
; }
 80163f2: 4618         	mov	r0, r3
 80163f4: 3710         	adds	r7, #0x10
 80163f6: 46bd         	mov	sp, r7
 80163f8: bd80         	pop	{r7, pc}

080163fa <can_start>:
; {
 80163fa: b580         	push	{r7, lr}
 80163fc: b082         	sub	sp, #0x8
 80163fe: af00         	add	r7, sp, #0x0
 8016400: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_start(dev);
 8016402: 6878         	ldr	r0, [r7, #0x4]
 8016404: f7ff ffe9    	bl	0x80163da <z_impl_can_start> @ imm = #-0x2e
 8016408: 4603         	mov	r3, r0
; }
 801640a: 4618         	mov	r0, r3
 801640c: 3708         	adds	r7, #0x8
 801640e: 46bd         	mov	sp, r7
 8016410: bd80         	pop	{r7, pc}

08016412 <can_send>:
; {
 8016412: b580         	push	{r7, lr}
 8016414: b086         	sub	sp, #0x18
 8016416: af02         	add	r7, sp, #0x8
 8016418: 60f8         	str	r0, [r7, #0xc]
 801641a: 60b9         	str	r1, [r7, #0x8]
 801641c: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_can_send(dev, frame, timeout, callback, user_data);
 8016420: 69fb         	ldr	r3, [r7, #0x1c]
 8016422: 9301         	str	r3, [sp, #0x4]
 8016424: 69bb         	ldr	r3, [r7, #0x18]
 8016426: 9300         	str	r3, [sp]
 8016428: e9d7 2300    	ldrd	r2, r3, [r7]
 801642c: 68b9         	ldr	r1, [r7, #0x8]
 801642e: 68f8         	ldr	r0, [r7, #0xc]
 8016430: f7ed ff18    	bl	0x8004264 <z_impl_can_send> @ imm = #-0x121d0
 8016434: 4603         	mov	r3, r0
; }
 8016436: 4618         	mov	r0, r3
 8016438: 3710         	adds	r7, #0x10
 801643a: 46bd         	mov	sp, r7
 801643c: bd80         	pop	{r7, pc}

0801643e <z_impl_pid_calc>:
; static inline void z_impl_pid_calc(const struct device *dev) {
 801643e: b580         	push	{r7, lr}
 8016440: b084         	sub	sp, #0x10
 8016442: af00         	add	r7, sp, #0x0
 8016444: 6078         	str	r0, [r7, #0x4]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 8016446: 687b         	ldr	r3, [r7, #0x4]
 8016448: 689b         	ldr	r3, [r3, #0x8]
 801644a: 60fb         	str	r3, [r7, #0xc]
;     if (api->pid_calc != NULL) {
 801644c: 68fb         	ldr	r3, [r7, #0xc]
 801644e: 681b         	ldr	r3, [r3]
 8016450: 2b00         	cmp	r3, #0x0
 8016452: d003         	beq	0x801645c <z_impl_pid_calc+0x1e> @ imm = #0x6
;         api->pid_calc(dev);
 8016454: 68fb         	ldr	r3, [r7, #0xc]
 8016456: 681b         	ldr	r3, [r3]
 8016458: 6878         	ldr	r0, [r7, #0x4]
 801645a: 4798         	blx	r3
; }
 801645c: bf00         	nop
 801645e: 3710         	adds	r7, #0x10
 8016460: 46bd         	mov	sp, r7
 8016462: bd80         	pop	{r7, pc}

08016464 <z_impl_pid_reg_input>:
; static inline void z_impl_pid_reg_input(const struct device *dev, float *curr, float *ref) {
 8016464: b580         	push	{r7, lr}
 8016466: b086         	sub	sp, #0x18
 8016468: af00         	add	r7, sp, #0x0
 801646a: 60f8         	str	r0, [r7, #0xc]
 801646c: 60b9         	str	r1, [r7, #0x8]
 801646e: 607a         	str	r2, [r7, #0x4]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 8016470: 68fb         	ldr	r3, [r7, #0xc]
 8016472: 689b         	ldr	r3, [r3, #0x8]
 8016474: 617b         	str	r3, [r7, #0x14]
;     if (api->pid_reg_input != NULL) {
 8016476: 697b         	ldr	r3, [r7, #0x14]
 8016478: 685b         	ldr	r3, [r3, #0x4]
 801647a: 2b00         	cmp	r3, #0x0
 801647c: d005         	beq	0x801648a <z_impl_pid_reg_input+0x26> @ imm = #0xa
;         api->pid_reg_input(dev, curr, ref);
 801647e: 697b         	ldr	r3, [r7, #0x14]
 8016480: 685b         	ldr	r3, [r3, #0x4]
 8016482: 687a         	ldr	r2, [r7, #0x4]
 8016484: 68b9         	ldr	r1, [r7, #0x8]
 8016486: 68f8         	ldr	r0, [r7, #0xc]
 8016488: 4798         	blx	r3
; }
 801648a: bf00         	nop
 801648c: 3718         	adds	r7, #0x18
 801648e: 46bd         	mov	sp, r7
 8016490: bd80         	pop	{r7, pc}

08016492 <z_impl_pid_reg_time>:
;                                        uint32_t *prev_time) {
 8016492: b580         	push	{r7, lr}
 8016494: b086         	sub	sp, #0x18
 8016496: af00         	add	r7, sp, #0x0
 8016498: 60f8         	str	r0, [r7, #0xc]
 801649a: 60b9         	str	r1, [r7, #0x8]
 801649c: 607a         	str	r2, [r7, #0x4]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 801649e: 68fb         	ldr	r3, [r7, #0xc]
 80164a0: 689b         	ldr	r3, [r3, #0x8]
 80164a2: 617b         	str	r3, [r7, #0x14]
;     if (api->pid_reg_time != NULL) {
 80164a4: 697b         	ldr	r3, [r7, #0x14]
 80164a6: 68db         	ldr	r3, [r3, #0xc]
 80164a8: 2b00         	cmp	r3, #0x0
 80164aa: d005         	beq	0x80164b8 <z_impl_pid_reg_time+0x26> @ imm = #0xa
;         api->pid_reg_time(dev, curr_time, prev_time);
 80164ac: 697b         	ldr	r3, [r7, #0x14]
 80164ae: 68db         	ldr	r3, [r3, #0xc]
 80164b0: 687a         	ldr	r2, [r7, #0x4]
 80164b2: 68b9         	ldr	r1, [r7, #0x8]
 80164b4: 68f8         	ldr	r0, [r7, #0xc]
 80164b6: 4798         	blx	r3
; }
 80164b8: bf00         	nop
 80164ba: 3718         	adds	r7, #0x18
 80164bc: 46bd         	mov	sp, r7
 80164be: bd80         	pop	{r7, pc}

080164c0 <z_impl_pid_reg_output>:
; static inline void z_impl_pid_reg_output(const struct device *dev, float *output) {
 80164c0: b580         	push	{r7, lr}
 80164c2: b084         	sub	sp, #0x10
 80164c4: af00         	add	r7, sp, #0x0
 80164c6: 6078         	str	r0, [r7, #0x4]
 80164c8: 6039         	str	r1, [r7]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 80164ca: 687b         	ldr	r3, [r7, #0x4]
 80164cc: 689b         	ldr	r3, [r3, #0x8]
 80164ce: 60fb         	str	r3, [r7, #0xc]
;     if (api->pid_reg_output != NULL) {
 80164d0: 68fb         	ldr	r3, [r7, #0xc]
 80164d2: 691b         	ldr	r3, [r3, #0x10]
 80164d4: 2b00         	cmp	r3, #0x0
 80164d6: d004         	beq	0x80164e2 <z_impl_pid_reg_output+0x22> @ imm = #0x8
;         api->pid_reg_output(dev, output);
 80164d8: 68fb         	ldr	r3, [r7, #0xc]
 80164da: 691b         	ldr	r3, [r3, #0x10]
 80164dc: 6839         	ldr	r1, [r7]
 80164de: 6878         	ldr	r0, [r7, #0x4]
 80164e0: 4798         	blx	r3
; }
 80164e2: bf00         	nop
 80164e4: 3710         	adds	r7, #0x10
 80164e6: 46bd         	mov	sp, r7
 80164e8: bd80         	pop	{r7, pc}

080164ea <pid_calc>:
; {
 80164ea: b580         	push	{r7, lr}
 80164ec: b082         	sub	sp, #0x8
 80164ee: af00         	add	r7, sp, #0x0
 80164f0: 6078         	str	r0, [r7, #0x4]
; 	z_impl_pid_calc(dev);
 80164f2: 6878         	ldr	r0, [r7, #0x4]
 80164f4: f7ff ffa3    	bl	0x801643e <z_impl_pid_calc> @ imm = #-0xba
; }
 80164f8: bf00         	nop
 80164fa: 3708         	adds	r7, #0x8
 80164fc: 46bd         	mov	sp, r7
 80164fe: bd80         	pop	{r7, pc}

08016500 <pid_reg_input>:
; {
 8016500: b580         	push	{r7, lr}
 8016502: b084         	sub	sp, #0x10
 8016504: af00         	add	r7, sp, #0x0
 8016506: 60f8         	str	r0, [r7, #0xc]
 8016508: 60b9         	str	r1, [r7, #0x8]
 801650a: 607a         	str	r2, [r7, #0x4]
; 	z_impl_pid_reg_input(dev, curr, ref);
 801650c: 687a         	ldr	r2, [r7, #0x4]
 801650e: 68b9         	ldr	r1, [r7, #0x8]
 8016510: 68f8         	ldr	r0, [r7, #0xc]
 8016512: f7ff ffa7    	bl	0x8016464 <z_impl_pid_reg_input> @ imm = #-0xb2
; }
 8016516: bf00         	nop
 8016518: 3710         	adds	r7, #0x10
 801651a: 46bd         	mov	sp, r7
 801651c: bd80         	pop	{r7, pc}

0801651e <pid_reg_time>:
; {
 801651e: b580         	push	{r7, lr}
 8016520: b084         	sub	sp, #0x10
 8016522: af00         	add	r7, sp, #0x0
 8016524: 60f8         	str	r0, [r7, #0xc]
 8016526: 60b9         	str	r1, [r7, #0x8]
 8016528: 607a         	str	r2, [r7, #0x4]
; 	z_impl_pid_reg_time(dev, curr_time, prev_time);
 801652a: 687a         	ldr	r2, [r7, #0x4]
 801652c: 68b9         	ldr	r1, [r7, #0x8]
 801652e: 68f8         	ldr	r0, [r7, #0xc]
 8016530: f7ff ffaf    	bl	0x8016492 <z_impl_pid_reg_time> @ imm = #-0xa2
; }
 8016534: bf00         	nop
 8016536: 3710         	adds	r7, #0x10
 8016538: 46bd         	mov	sp, r7
 801653a: bd80         	pop	{r7, pc}

0801653c <pid_reg_output>:
; {
 801653c: b580         	push	{r7, lr}
 801653e: b082         	sub	sp, #0x8
 8016540: af00         	add	r7, sp, #0x0
 8016542: 6078         	str	r0, [r7, #0x4]
 8016544: 6039         	str	r1, [r7]
; 	z_impl_pid_reg_output(dev, output);
 8016546: 6839         	ldr	r1, [r7]
 8016548: 6878         	ldr	r0, [r7, #0x4]
 801654a: f7ff ffb9    	bl	0x80164c0 <z_impl_pid_reg_output> @ imm = #-0x8e
; }
 801654e: bf00         	nop
 8016550: 3708         	adds	r7, #0x8
 8016552: 46bd         	mov	sp, r7
 8016554: bd80         	pop	{r7, pc}

08016556 <frames_id>:
; static int frames_id(int tx_id) {
 8016556: b480         	push	{r7}
 8016558: b083         	sub	sp, #0xc
 801655a: af00         	add	r7, sp, #0x0
 801655c: 6078         	str	r0, [r7, #0x4]
;     if (tx_id == 0x200) {
 801655e: 687b         	ldr	r3, [r7, #0x4]
 8016560: f5b3 7f00    	cmp.w	r3, #0x200
 8016564: d101         	bne	0x801656a <frames_id+0x14> @ imm = #0x2
;         return 0;
 8016566: 2300         	movs	r3, #0x0
 8016568: e01c         	b	0x80165a4 <frames_id+0x4e> @ imm = #0x38
;     } else if (tx_id == 0x1FF) {
 801656a: 687b         	ldr	r3, [r7, #0x4]
 801656c: f240 12ff    	movw	r2, #0x1ff
 8016570: 4293         	cmp	r3, r2
 8016572: d101         	bne	0x8016578 <frames_id+0x22> @ imm = #0x2
;         return 1;
 8016574: 2301         	movs	r3, #0x1
 8016576: e015         	b	0x80165a4 <frames_id+0x4e> @ imm = #0x2a
;     } else if (tx_id == 0x1FE) {
 8016578: 687b         	ldr	r3, [r7, #0x4]
 801657a: f5b3 7fff    	cmp.w	r3, #0x1fe
 801657e: d101         	bne	0x8016584 <frames_id+0x2e> @ imm = #0x2
;         return 2;
 8016580: 2302         	movs	r3, #0x2
 8016582: e00f         	b	0x80165a4 <frames_id+0x4e> @ imm = #0x1e
;     } else if (tx_id == 0x2FE) {
 8016584: 687b         	ldr	r3, [r7, #0x4]
 8016586: f240 22fe    	movw	r2, #0x2fe
 801658a: 4293         	cmp	r3, r2
 801658c: d101         	bne	0x8016592 <frames_id+0x3c> @ imm = #0x2
;         return 3;
 801658e: 2303         	movs	r3, #0x3
 8016590: e008         	b	0x80165a4 <frames_id+0x4e> @ imm = #0x10
;     } else if (tx_id == 0x2FF) {
 8016592: 687b         	ldr	r3, [r7, #0x4]
 8016594: f240 22ff    	movw	r2, #0x2ff
 8016598: 4293         	cmp	r3, r2
 801659a: d101         	bne	0x80165a0 <frames_id+0x4a> @ imm = #0x2
;         return 4;
 801659c: 2304         	movs	r3, #0x4
 801659e: e001         	b	0x80165a4 <frames_id+0x4e> @ imm = #0x2
;     return -1; // Return a default value if no match is found
 80165a0: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 80165a4: 4618         	mov	r0, r3
 80165a6: 370c         	adds	r7, #0xc
 80165a8: 46bd         	mov	sp, r7
 80165aa: bc80         	pop	{r7}
 80165ac: 4770         	bx	lr

080165ae <txframe_id>:
; static int txframe_id(int frames_id) {
 80165ae: b480         	push	{r7}
 80165b0: b083         	sub	sp, #0xc
 80165b2: af00         	add	r7, sp, #0x0
 80165b4: 6078         	str	r0, [r7, #0x4]
;     if (frames_id == 0) {
 80165b6: 687b         	ldr	r3, [r7, #0x4]
 80165b8: 2b00         	cmp	r3, #0x0
 80165ba: d102         	bne	0x80165c2 <txframe_id+0x14> @ imm = #0x4
;         return 0x200;
 80165bc: f44f 7300    	mov.w	r3, #0x200
 80165c0: e019         	b	0x80165f6 <txframe_id+0x48> @ imm = #0x32
;     } else if (frames_id == 1) {
 80165c2: 687b         	ldr	r3, [r7, #0x4]
 80165c4: 2b01         	cmp	r3, #0x1
 80165c6: d102         	bne	0x80165ce <txframe_id+0x20> @ imm = #0x4
;         return 0x1FF;
 80165c8: f240 13ff    	movw	r3, #0x1ff
 80165cc: e013         	b	0x80165f6 <txframe_id+0x48> @ imm = #0x26
;     } else if (frames_id == 2) {
 80165ce: 687b         	ldr	r3, [r7, #0x4]
 80165d0: 2b02         	cmp	r3, #0x2
 80165d2: d102         	bne	0x80165da <txframe_id+0x2c> @ imm = #0x4
;         return 0x1FE;
 80165d4: f44f 73ff    	mov.w	r3, #0x1fe
 80165d8: e00d         	b	0x80165f6 <txframe_id+0x48> @ imm = #0x1a
;     } else if (frames_id == 3) {
 80165da: 687b         	ldr	r3, [r7, #0x4]
 80165dc: 2b03         	cmp	r3, #0x3
 80165de: d102         	bne	0x80165e6 <txframe_id+0x38> @ imm = #0x4
;         return 0x2FE;
 80165e0: f240 23fe    	movw	r3, #0x2fe
 80165e4: e007         	b	0x80165f6 <txframe_id+0x48> @ imm = #0xe
;     } else if (frames_id == 4) {
 80165e6: 687b         	ldr	r3, [r7, #0x4]
 80165e8: 2b04         	cmp	r3, #0x4
 80165ea: d102         	bne	0x80165f2 <txframe_id+0x44> @ imm = #0x4
;         return 0x2FF;
 80165ec: f240 23ff    	movw	r3, #0x2ff
 80165f0: e001         	b	0x80165f6 <txframe_id+0x48> @ imm = #0x2
;     return -1;
 80165f2: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 80165f6: 4618         	mov	r0, r3
 80165f8: 370c         	adds	r7, #0xc
 80165fa: 46bd         	mov	sp, r7
 80165fc: bc80         	pop	{r7}
 80165fe: 4770         	bx	lr

08016600 <motor_id>:
; static inline motor_id_t motor_id(const struct device *dev) {
 8016600: b480         	push	{r7}
 8016602: b085         	sub	sp, #0x14
 8016604: af00         	add	r7, sp, #0x0
 8016606: 6078         	str	r0, [r7, #0x4]
;     const struct dji_motor_config *cfg = dev->config;
 8016608: 687b         	ldr	r3, [r7, #0x4]
 801660a: 685b         	ldr	r3, [r3, #0x4]
 801660c: 60fb         	str	r3, [r7, #0xc]
;     return cfg->common.id - 1;
 801660e: 68fb         	ldr	r3, [r7, #0xc]
 8016610: 791b         	ldrb	r3, [r3, #0x4]
 8016612: 3b01         	subs	r3, #0x1
 8016614: b29b         	uxth	r3, r3
; }
 8016616: 4618         	mov	r0, r3
 8016618: 3714         	adds	r7, #0x14
 801661a: 46bd         	mov	sp, r7
 801661c: bc80         	pop	{r7}
 801661e: 4770         	bx	lr

08016620 <dji_set_zero>:
; float dji_set_zero(const struct device *dev) {
 8016620: b580         	push	{r7, lr}
 8016622: b084         	sub	sp, #0x10
 8016624: af00         	add	r7, sp, #0x0
 8016626: 6078         	str	r0, [r7, #0x4]
;     float                  curr_angle = dji_get_angle(dev);
 8016628: 6878         	ldr	r0, [r7, #0x4]
 801662a: f000 f80c    	bl	0x8016646 <dji_get_angle> @ imm = #0x18
 801662e: 60f8         	str	r0, [r7, #0xc]
;     struct dji_motor_data *data       = dev->data;
 8016630: 687b         	ldr	r3, [r7, #0x4]
 8016632: 691b         	ldr	r3, [r3, #0x10]
 8016634: 60bb         	str	r3, [r7, #0x8]
;     data->RAWangle_add                = 0;
 8016636: 68bb         	ldr	r3, [r7, #0x8]
 8016638: 2200         	movs	r2, #0x0
 801663a: 631a         	str	r2, [r3, #0x30]
;     return curr_angle;
 801663c: 68fb         	ldr	r3, [r7, #0xc]
; }
 801663e: 4618         	mov	r0, r3
 8016640: 3710         	adds	r7, #0x10
 8016642: 46bd         	mov	sp, r7
 8016644: bd80         	pop	{r7, pc}

08016646 <dji_get_angle>:
; float dji_get_angle(const struct device *dev) {
 8016646: b480         	push	{r7}
 8016648: b085         	sub	sp, #0x14
 801664a: af00         	add	r7, sp, #0x0
 801664c: 6078         	str	r0, [r7, #0x4]
;     struct dji_motor_data *data = dev->data;
 801664e: 687b         	ldr	r3, [r7, #0x4]
 8016650: 691b         	ldr	r3, [r3, #0x10]
 8016652: 60fb         	str	r3, [r7, #0xc]
;     return data->common.angle;
 8016654: 68fb         	ldr	r3, [r7, #0xc]
 8016656: 681b         	ldr	r3, [r3]
; }
 8016658: 4618         	mov	r0, r3
 801665a: 3714         	adds	r7, #0x14
 801665c: 46bd         	mov	sp, r7
 801665e: bc80         	pop	{r7}
 8016660: 4770         	bx	lr

08016662 <dji_get_speed>:
; float dji_get_speed(const struct device *dev) {
 8016662: b480         	push	{r7}
 8016664: b085         	sub	sp, #0x14
 8016666: af00         	add	r7, sp, #0x0
 8016668: 6078         	str	r0, [r7, #0x4]
;     struct dji_motor_data *data = dev->data;
 801666a: 687b         	ldr	r3, [r7, #0x4]
 801666c: 691b         	ldr	r3, [r3, #0x10]
 801666e: 60fb         	str	r3, [r7, #0xc]
;     return data->common.rpm;
 8016670: 68fb         	ldr	r3, [r7, #0xc]
 8016672: 685b         	ldr	r3, [r3, #0x4]
; }
 8016674: 4618         	mov	r0, r3
 8016676: 3714         	adds	r7, #0x14
 8016678: 46bd         	mov	sp, r7
 801667a: bc80         	pop	{r7}
 801667c: 4770         	bx	lr

0801667e <dji_get_torque>:
; float dji_get_torque(const struct device *dev) {
 801667e: b480         	push	{r7}
 8016680: b085         	sub	sp, #0x14
 8016682: af00         	add	r7, sp, #0x0
 8016684: 6078         	str	r0, [r7, #0x4]
;     struct dji_motor_data *data = dev->data;
 8016686: 687b         	ldr	r3, [r7, #0x4]
 8016688: 691b         	ldr	r3, [r3, #0x10]
 801668a: 60fb         	str	r3, [r7, #0xc]
;     return data->common.torque;
 801668c: 68fb         	ldr	r3, [r7, #0xc]
 801668e: 689b         	ldr	r3, [r3, #0x8]
; }
 8016690: 4618         	mov	r0, r3
 8016692: 3714         	adds	r7, #0x14
 8016694: 46bd         	mov	sp, r7
 8016696: bc80         	pop	{r7}
 8016698: 4770         	bx	lr

0801669a <can_tx_callback>:
; static void can_tx_callback(const struct device *can_dev, int error, void *user_data) {
 801669a: b580         	push	{r7, lr}
 801669c: b086         	sub	sp, #0x18
 801669e: af00         	add	r7, sp, #0x0
 80166a0: 60f8         	str	r0, [r7, #0xc]
 80166a2: 60b9         	str	r1, [r7, #0x8]
 80166a4: 607a         	str	r2, [r7, #0x4]
;     struct k_sem *queue_sem = user_data;
 80166a6: 687b         	ldr	r3, [r7, #0x4]
 80166a8: 617b         	str	r3, [r7, #0x14]
;     k_sem_give(queue_sem);
 80166aa: 6978         	ldr	r0, [r7, #0x14]
 80166ac: f7ff fe6c    	bl	0x8016388 <k_sem_give>  @ imm = #-0x328
; }
 80166b0: bf00         	nop
 80166b2: 3718         	adds	r7, #0x18
 80166b4: 46bd         	mov	sp, r7
 80166b6: bd80         	pop	{r7, pc}

080166b8 <delta_degree>:
; static int delta_degree(uint16_t angle, uint16_t prev_angle) {
 80166b8: b480         	push	{r7}
 80166ba: b085         	sub	sp, #0x14
 80166bc: af00         	add	r7, sp, #0x0
 80166be: 4603         	mov	r3, r0
 80166c0: 460a         	mov	r2, r1
 80166c2: 80fb         	strh	r3, [r7, #0x6]
 80166c4: 4613         	mov	r3, r2
 80166c6: 80bb         	strh	r3, [r7, #0x4]
;     int delta = angle - prev_angle;
 80166c8: 88fa         	ldrh	r2, [r7, #0x6]
 80166ca: 88bb         	ldrh	r3, [r7, #0x4]
 80166cc: 1ad3         	subs	r3, r2, r3
 80166ce: 60fb         	str	r3, [r7, #0xc]
;     if (angle < 2048 && prev_angle > 6144)
 80166d0: 88fb         	ldrh	r3, [r7, #0x6]
 80166d2: f5b3 6f00    	cmp.w	r3, #0x800
 80166d6: d208         	bhs	0x80166ea <delta_degree+0x32> @ imm = #0x10
 80166d8: 88bb         	ldrh	r3, [r7, #0x4]
 80166da: f5b3 5fc0    	cmp.w	r3, #0x1800
 80166de: d904         	bls	0x80166ea <delta_degree+0x32> @ imm = #0x8
;         delta += 8192;
 80166e0: 68fb         	ldr	r3, [r7, #0xc]
 80166e2: f503 5300    	add.w	r3, r3, #0x2000
 80166e6: 60fb         	str	r3, [r7, #0xc]
 80166e8: e00b         	b	0x8016702 <delta_degree+0x4a> @ imm = #0x16
;     else if (angle > 6144 && prev_angle < 2048)
 80166ea: 88fb         	ldrh	r3, [r7, #0x6]
 80166ec: f5b3 5fc0    	cmp.w	r3, #0x1800
 80166f0: d907         	bls	0x8016702 <delta_degree+0x4a> @ imm = #0xe
 80166f2: 88bb         	ldrh	r3, [r7, #0x4]
 80166f4: f5b3 6f00    	cmp.w	r3, #0x800
 80166f8: d203         	bhs	0x8016702 <delta_degree+0x4a> @ imm = #0x6
;         delta -= 8192;
 80166fa: 68fb         	ldr	r3, [r7, #0xc]
 80166fc: f5a3 5300    	sub.w	r3, r3, #0x2000
 8016700: 60fb         	str	r3, [r7, #0xc]
;     return delta;
 8016702: 68fb         	ldr	r3, [r7, #0xc]
; }
 8016704: 4618         	mov	r0, r3
 8016706: 3714         	adds	r7, #0x14
 8016708: 46bd         	mov	sp, r7
 801670a: bc80         	pop	{r7}
 801670c: 4770         	bx	lr

0801670e <can_pack_add>:
; static void can_pack_add(uint8_t *data, struct device *motor_dev, uint8_t num) {
 801670e: b580         	push	{r7, lr}
 8016710: b086         	sub	sp, #0x18
 8016712: af00         	add	r7, sp, #0x0
 8016714: 60f8         	str	r0, [r7, #0xc]
 8016716: 60b9         	str	r1, [r7, #0x8]
 8016718: 4613         	mov	r3, r2
 801671a: 71fb         	strb	r3, [r7, #0x7]
;     struct dji_motor_data *data_temp = motor_dev->data;
 801671c: 68bb         	ldr	r3, [r7, #0x8]
 801671e: 691b         	ldr	r3, [r3, #0x10]
 8016720: 617b         	str	r3, [r7, #0x14]
;     int16_t value = to16t(data_temp->target_current);
 8016722: 697b         	ldr	r3, [r7, #0x14]
 8016724: 6c5b         	ldr	r3, [r3, #0x44]
 8016726: 4618         	mov	r0, r3
 8016728: f7f3 f8a6    	bl	0x8009878 <to16t>       @ imm = #-0xceb4
 801672c: 4603         	mov	r3, r0
 801672e: 827b         	strh	r3, [r7, #0x12]
;     data[num * 2]     = HIGH_BYTE(value);
 8016730: f9b7 3012    	ldrsh.w	r3, [r7, #0x12]
 8016734: 121b         	asrs	r3, r3, #0x8
 8016736: b21a         	sxth	r2, r3
 8016738: 79fb         	ldrb	r3, [r7, #0x7]
 801673a: 005b         	lsls	r3, r3, #0x1
 801673c: 4619         	mov	r1, r3
 801673e: 68fb         	ldr	r3, [r7, #0xc]
 8016740: 440b         	add	r3, r1
 8016742: b2d2         	uxtb	r2, r2
 8016744: 701a         	strb	r2, [r3]
;     data[num * 2 + 1] = LOW_BYTE(value);
 8016746: 79fb         	ldrb	r3, [r7, #0x7]
 8016748: 005b         	lsls	r3, r3, #0x1
 801674a: 3301         	adds	r3, #0x1
 801674c: 68fa         	ldr	r2, [r7, #0xc]
 801674e: 4413         	add	r3, r2
 8016750: 8a7a         	ldrh	r2, [r7, #0x12]
 8016752: b2d2         	uxtb	r2, r2
 8016754: 701a         	strb	r2, [r3]
; }
 8016756: bf00         	nop
 8016758: 3718         	adds	r7, #0x18
 801675a: 46bd         	mov	sp, r7
 801675c: bd80         	pop	{r7, pc}

0801675e <single_pid_reg_input>:
; static void single_pid_reg_input(const struct device *pid_dev, float *curr, float *ref) {
 801675e: b480         	push	{r7}
 8016760: b087         	sub	sp, #0x1c
 8016762: af00         	add	r7, sp, #0x0
 8016764: 60f8         	str	r0, [r7, #0xc]
 8016766: 60b9         	str	r1, [r7, #0x8]
 8016768: 607a         	str	r2, [r7, #0x4]
;     struct pid_single_data *pid_data = pid_dev->data;
 801676a: 68fb         	ldr	r3, [r7, #0xc]
 801676c: 691b         	ldr	r3, [r3, #0x10]
 801676e: 617b         	str	r3, [r7, #0x14]
;     pid_data->curr                   = curr;
 8016770: 697b         	ldr	r3, [r7, #0x14]
 8016772: 68ba         	ldr	r2, [r7, #0x8]
 8016774: 605a         	str	r2, [r3, #0x4]
;     pid_data->ref                    = ref;
 8016776: 697b         	ldr	r3, [r7, #0x14]
 8016778: 687a         	ldr	r2, [r7, #0x4]
 801677a: 601a         	str	r2, [r3]
;     return;
 801677c: bf00         	nop
; }
 801677e: 371c         	adds	r7, #0x1c
 8016780: 46bd         	mov	sp, r7
 8016782: bc80         	pop	{r7}
 8016784: 4770         	bx	lr

08016786 <single_pid_reg_time>:
;                                 uint32_t *prev_time) {
 8016786: b480         	push	{r7}
 8016788: b087         	sub	sp, #0x1c
 801678a: af00         	add	r7, sp, #0x0
 801678c: 60f8         	str	r0, [r7, #0xc]
 801678e: 60b9         	str	r1, [r7, #0x8]
 8016790: 607a         	str	r2, [r7, #0x4]
;     struct pid_single_data *pid_data = pid_dev->data;
 8016792: 68fb         	ldr	r3, [r7, #0xc]
 8016794: 691b         	ldr	r3, [r3, #0x10]
 8016796: 617b         	str	r3, [r7, #0x14]
;     pid_data->curr_time              = curr_time;
 8016798: 697b         	ldr	r3, [r7, #0x14]
 801679a: 68ba         	ldr	r2, [r7, #0x8]
 801679c: 615a         	str	r2, [r3, #0x14]
;     pid_data->prev_time              = prev_time;
 801679e: 697b         	ldr	r3, [r7, #0x14]
 80167a0: 687a         	ldr	r2, [r7, #0x4]
 80167a2: 619a         	str	r2, [r3, #0x18]
;     return;
 80167a4: bf00         	nop
; }
 80167a6: 371c         	adds	r7, #0x1c
 80167a8: 46bd         	mov	sp, r7
 80167aa: bc80         	pop	{r7}
 80167ac: 4770         	bx	lr

080167ae <single_pid_reg_output>:
; static void single_pid_reg_output(const struct device *pid_dev, float *output) {
 80167ae: b480         	push	{r7}
 80167b0: b085         	sub	sp, #0x14
 80167b2: af00         	add	r7, sp, #0x0
 80167b4: 6078         	str	r0, [r7, #0x4]
 80167b6: 6039         	str	r1, [r7]
;     struct pid_single_data *pid_data = pid_dev->data;
 80167b8: 687b         	ldr	r3, [r7, #0x4]
 80167ba: 691b         	ldr	r3, [r3, #0x10]
 80167bc: 60fb         	str	r3, [r7, #0xc]
;     pid_data->output                 = output;
 80167be: 68fb         	ldr	r3, [r7, #0xc]
 80167c0: 683a         	ldr	r2, [r7]
 80167c2: 61da         	str	r2, [r3, #0x1c]
;     return;
 80167c4: bf00         	nop
; }
 80167c6: 3714         	adds	r7, #0x14
 80167c8: 46bd         	mov	sp, r7
 80167ca: bc80         	pop	{r7}
 80167cc: 4770         	bx	lr

080167ce <device_is_ready>:
; {
 80167ce: b580         	push	{r7, lr}
 80167d0: b082         	sub	sp, #0x8
 80167d2: af00         	add	r7, sp, #0x0
 80167d4: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80167d6: 6878         	ldr	r0, [r7, #0x4]
 80167d8: f000 faff    	bl	0x8016dda <z_impl_device_is_ready> @ imm = #0x5fe
 80167dc: 4603         	mov	r3, r0
; }
 80167de: 4618         	mov	r0, r3
 80167e0: 3708         	adds	r7, #0x8
 80167e2: 46bd         	mov	sp, r7
 80167e4: bd80         	pop	{r7, pc}

080167e6 <z_impl_uart_configure>:
; {
 80167e6: b580         	push	{r7, lr}
 80167e8: b084         	sub	sp, #0x10
 80167ea: af00         	add	r7, sp, #0x0
 80167ec: 6078         	str	r0, [r7, #0x4]
 80167ee: 6039         	str	r1, [r7]
; 	const struct uart_driver_api *api =
 80167f0: 687b         	ldr	r3, [r7, #0x4]
 80167f2: 689b         	ldr	r3, [r3, #0x8]
 80167f4: 60fb         	str	r3, [r7, #0xc]
; 	if (api->configure == NULL) {
 80167f6: 68fb         	ldr	r3, [r7, #0xc]
 80167f8: 6a5b         	ldr	r3, [r3, #0x24]
 80167fa: 2b00         	cmp	r3, #0x0
 80167fc: d102         	bne	0x8016804 <z_impl_uart_configure+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 80167fe: f06f 0357    	mvn	r3, #0x57
 8016802: e005         	b	0x8016810 <z_impl_uart_configure+0x2a> @ imm = #0xa
; 	return api->configure(dev, cfg);
 8016804: 68fb         	ldr	r3, [r7, #0xc]
 8016806: 6a5b         	ldr	r3, [r3, #0x24]
 8016808: 6839         	ldr	r1, [r7]
 801680a: 6878         	ldr	r0, [r7, #0x4]
 801680c: 4798         	blx	r3
 801680e: 4603         	mov	r3, r0
; }
 8016810: 4618         	mov	r0, r3
 8016812: 3710         	adds	r7, #0x10
 8016814: 46bd         	mov	sp, r7
 8016816: bd80         	pop	{r7, pc}

08016818 <uart_callback_set>:
; {
 8016818: b580         	push	{r7, lr}
 801681a: b086         	sub	sp, #0x18
 801681c: af00         	add	r7, sp, #0x0
 801681e: 60f8         	str	r0, [r7, #0xc]
 8016820: 60b9         	str	r1, [r7, #0x8]
 8016822: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_driver_api *api =
 8016824: 68fb         	ldr	r3, [r7, #0xc]
 8016826: 689b         	ldr	r3, [r3, #0x8]
 8016828: 617b         	str	r3, [r7, #0x14]
; 	if (api->callback_set == NULL) {
 801682a: 697b         	ldr	r3, [r7, #0x14]
 801682c: 681b         	ldr	r3, [r3]
 801682e: 2b00         	cmp	r3, #0x0
 8016830: d102         	bne	0x8016838 <uart_callback_set+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8016832: f06f 0357    	mvn	r3, #0x57
 8016836: e006         	b	0x8016846 <uart_callback_set+0x2e> @ imm = #0xc
; 	return api->callback_set(dev, callback, user_data);
 8016838: 697b         	ldr	r3, [r7, #0x14]
 801683a: 681b         	ldr	r3, [r3]
 801683c: 687a         	ldr	r2, [r7, #0x4]
 801683e: 68b9         	ldr	r1, [r7, #0x8]
 8016840: 68f8         	ldr	r0, [r7, #0xc]
 8016842: 4798         	blx	r3
 8016844: 4603         	mov	r3, r0
; }
 8016846: 4618         	mov	r0, r3
 8016848: 3718         	adds	r7, #0x18
 801684a: 46bd         	mov	sp, r7
 801684c: bd80         	pop	{r7, pc}

0801684e <z_impl_uart_rx_enable>:
; {
 801684e: b590         	push	{r4, r7, lr}
 8016850: b087         	sub	sp, #0x1c
 8016852: af00         	add	r7, sp, #0x0
 8016854: 60f8         	str	r0, [r7, #0xc]
 8016856: 60b9         	str	r1, [r7, #0x8]
 8016858: 607a         	str	r2, [r7, #0x4]
 801685a: 603b         	str	r3, [r7]
; 	const struct uart_driver_api *api =
 801685c: 68fb         	ldr	r3, [r7, #0xc]
 801685e: 689b         	ldr	r3, [r3, #0x8]
 8016860: 617b         	str	r3, [r7, #0x14]
; 	return api->rx_enable(dev, buf, len, timeout);
 8016862: 697b         	ldr	r3, [r7, #0x14]
 8016864: 68dc         	ldr	r4, [r3, #0xc]
 8016866: 683b         	ldr	r3, [r7]
 8016868: 687a         	ldr	r2, [r7, #0x4]
 801686a: 68b9         	ldr	r1, [r7, #0x8]
 801686c: 68f8         	ldr	r0, [r7, #0xc]
 801686e: 47a0         	blx	r4
 8016870: 4603         	mov	r3, r0
; }
 8016872: 4618         	mov	r0, r3
 8016874: 371c         	adds	r7, #0x1c
 8016876: 46bd         	mov	sp, r7
 8016878: bd90         	pop	{r4, r7, pc}

0801687a <uart_rx_buf_rsp>:
; {
 801687a: b580         	push	{r7, lr}
 801687c: b086         	sub	sp, #0x18
 801687e: af00         	add	r7, sp, #0x0
 8016880: 60f8         	str	r0, [r7, #0xc]
 8016882: 60b9         	str	r1, [r7, #0x8]
 8016884: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_driver_api *api =
 8016886: 68fb         	ldr	r3, [r7, #0xc]
 8016888: 689b         	ldr	r3, [r3, #0x8]
 801688a: 617b         	str	r3, [r7, #0x14]
; 	return api->rx_buf_rsp(dev, buf, len);
 801688c: 697b         	ldr	r3, [r7, #0x14]
 801688e: 691b         	ldr	r3, [r3, #0x10]
 8016890: 687a         	ldr	r2, [r7, #0x4]
 8016892: 68b9         	ldr	r1, [r7, #0x8]
 8016894: 68f8         	ldr	r0, [r7, #0xc]
 8016896: 4798         	blx	r3
 8016898: 4603         	mov	r3, r0
; }
 801689a: 4618         	mov	r0, r3
 801689c: 3718         	adds	r7, #0x18
 801689e: 46bd         	mov	sp, r7
 80168a0: bd80         	pop	{r7, pc}

080168a2 <z_impl_uart_rx_disable>:
; {
 80168a2: b580         	push	{r7, lr}
 80168a4: b084         	sub	sp, #0x10
 80168a6: af00         	add	r7, sp, #0x0
 80168a8: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_driver_api *api =
 80168aa: 687b         	ldr	r3, [r7, #0x4]
 80168ac: 689b         	ldr	r3, [r3, #0x8]
 80168ae: 60fb         	str	r3, [r7, #0xc]
; 	return api->rx_disable(dev);
 80168b0: 68fb         	ldr	r3, [r7, #0xc]
 80168b2: 695b         	ldr	r3, [r3, #0x14]
 80168b4: 6878         	ldr	r0, [r7, #0x4]
 80168b6: 4798         	blx	r3
 80168b8: 4603         	mov	r3, r0
; }
 80168ba: 4618         	mov	r0, r3
 80168bc: 3710         	adds	r7, #0x10
 80168be: 46bd         	mov	sp, r7
 80168c0: bd80         	pop	{r7, pc}

080168c2 <uart_configure>:
; {
 80168c2: b580         	push	{r7, lr}
 80168c4: b082         	sub	sp, #0x8
 80168c6: af00         	add	r7, sp, #0x0
 80168c8: 6078         	str	r0, [r7, #0x4]
 80168ca: 6039         	str	r1, [r7]
; 	return z_impl_uart_configure(dev, cfg);
 80168cc: 6839         	ldr	r1, [r7]
 80168ce: 6878         	ldr	r0, [r7, #0x4]
 80168d0: f7ff ff89    	bl	0x80167e6 <z_impl_uart_configure> @ imm = #-0xee
 80168d4: 4603         	mov	r3, r0
; }
 80168d6: 4618         	mov	r0, r3
 80168d8: 3708         	adds	r7, #0x8
 80168da: 46bd         	mov	sp, r7
 80168dc: bd80         	pop	{r7, pc}

080168de <uart_rx_enable>:
; {
 80168de: b580         	push	{r7, lr}
 80168e0: b084         	sub	sp, #0x10
 80168e2: af00         	add	r7, sp, #0x0
 80168e4: 60f8         	str	r0, [r7, #0xc]
 80168e6: 60b9         	str	r1, [r7, #0x8]
 80168e8: 607a         	str	r2, [r7, #0x4]
 80168ea: 603b         	str	r3, [r7]
; 	return z_impl_uart_rx_enable(dev, buf, len, timeout);
 80168ec: 683b         	ldr	r3, [r7]
 80168ee: 687a         	ldr	r2, [r7, #0x4]
 80168f0: 68b9         	ldr	r1, [r7, #0x8]
 80168f2: 68f8         	ldr	r0, [r7, #0xc]
 80168f4: f7ff ffab    	bl	0x801684e <z_impl_uart_rx_enable> @ imm = #-0xaa
 80168f8: 4603         	mov	r3, r0
; }
 80168fa: 4618         	mov	r0, r3
 80168fc: 3710         	adds	r7, #0x10
 80168fe: 46bd         	mov	sp, r7
 8016900: bd80         	pop	{r7, pc}

08016902 <uart_rx_disable>:
; {
 8016902: b580         	push	{r7, lr}
 8016904: b082         	sub	sp, #0x8
 8016906: af00         	add	r7, sp, #0x0
 8016908: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_uart_rx_disable(dev);
 801690a: 6878         	ldr	r0, [r7, #0x4]
 801690c: f7ff ffc9    	bl	0x80168a2 <z_impl_uart_rx_disable> @ imm = #-0x6e
 8016910: 4603         	mov	r3, r0
; }
 8016912: 4618         	mov	r0, r3
 8016914: 3708         	adds	r7, #0x8
 8016916: 46bd         	mov	sp, r7
 8016918: bd80         	pop	{r7, pc}

0801691a <z_log_msg_runtime_create>:
; {
 801691a: b580         	push	{r7, lr}
 801691c: b08a         	sub	sp, #0x28
 801691e: af04         	add	r7, sp, #0x10
 8016920: 60b9         	str	r1, [r7, #0x8]
 8016922: 607b         	str	r3, [r7, #0x4]
 8016924: 4603         	mov	r3, r0
 8016926: 73fb         	strb	r3, [r7, #0xf]
 8016928: 4613         	mov	r3, r2
 801692a: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801692c: f107 032c    	add.w	r3, r7, #0x2c
 8016930: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8016932: 7bba         	ldrb	r2, [r7, #0xe]
 8016934: 7bf8         	ldrb	r0, [r7, #0xf]
 8016936: 697b         	ldr	r3, [r7, #0x14]
 8016938: 9303         	str	r3, [sp, #0xc]
 801693a: 6abb         	ldr	r3, [r7, #0x28]
 801693c: 9302         	str	r3, [sp, #0x8]
 801693e: 6a7b         	ldr	r3, [r7, #0x24]
 8016940: 9301         	str	r3, [sp, #0x4]
 8016942: 6a3b         	ldr	r3, [r7, #0x20]
 8016944: 9300         	str	r3, [sp]
 8016946: 687b         	ldr	r3, [r7, #0x4]
 8016948: 68b9         	ldr	r1, [r7, #0x8]
 801694a: f7eb fbff    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0x14802
; }
 801694e: bf00         	nop
 8016950: 3718         	adds	r7, #0x18
 8016952: 46bd         	mov	sp, r7
 8016954: bd80         	pop	{r7, pc}

08016956 <sbus_parseframe>:
; void sbus_parseframe(const struct device *dev) { // 检查帧是否为空
 8016956: b480         	push	{r7}
 8016958: b085         	sub	sp, #0x14
 801695a: af00         	add	r7, sp, #0x0
 801695c: 6078         	str	r0, [r7, #0x4]
;     struct sbus_driver_data *data = dev->data;
 801695e: 687b         	ldr	r3, [r7, #0x4]
 8016960: 691b         	ldr	r3, [r3, #0x10]
 8016962: 60fb         	str	r3, [r7, #0xc]
;     data->channels[0] = (data->data[1] >> 0 | (data->data[2] << 8)) & 0x07FF;
 8016964: 68fb         	ldr	r3, [r7, #0xc]
 8016966: 785b         	ldrb	r3, [r3, #0x1]
 8016968: b21a         	sxth	r2, r3
 801696a: 68fb         	ldr	r3, [r7, #0xc]
 801696c: 789b         	ldrb	r3, [r3, #0x2]
 801696e: 021b         	lsls	r3, r3, #0x8
 8016970: b21b         	sxth	r3, r3
 8016972: 4313         	orrs	r3, r2
 8016974: b21b         	sxth	r3, r3
 8016976: b29b         	uxth	r3, r3
 8016978: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 801697c: b29a         	uxth	r2, r3
 801697e: 68fb         	ldr	r3, [r7, #0xc]
 8016980: 835a         	strh	r2, [r3, #0x1a]
;     data->channels[1] = (data->data[2] >> 3 | (data->data[3] << 5)) & 0x07FF;
 8016982: 68fb         	ldr	r3, [r7, #0xc]
 8016984: 789b         	ldrb	r3, [r3, #0x2]
 8016986: 08db         	lsrs	r3, r3, #0x3
 8016988: b2db         	uxtb	r3, r3
 801698a: b21a         	sxth	r2, r3
 801698c: 68fb         	ldr	r3, [r7, #0xc]
 801698e: 78db         	ldrb	r3, [r3, #0x3]
 8016990: 015b         	lsls	r3, r3, #0x5
 8016992: b21b         	sxth	r3, r3
 8016994: 4313         	orrs	r3, r2
 8016996: b21b         	sxth	r3, r3
 8016998: b29b         	uxth	r3, r3
 801699a: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 801699e: b29a         	uxth	r2, r3
 80169a0: 68fb         	ldr	r3, [r7, #0xc]
 80169a2: 839a         	strh	r2, [r3, #0x1c]
;     data->channels[2] = (data->data[3] >> 6 | (data->data[4] << 2) | data->data[5] << 10) & 0x07FF;
 80169a4: 68fb         	ldr	r3, [r7, #0xc]
 80169a6: 78db         	ldrb	r3, [r3, #0x3]
 80169a8: 099b         	lsrs	r3, r3, #0x6
 80169aa: b2db         	uxtb	r3, r3
 80169ac: b21a         	sxth	r2, r3
 80169ae: 68fb         	ldr	r3, [r7, #0xc]
 80169b0: 791b         	ldrb	r3, [r3, #0x4]
 80169b2: 009b         	lsls	r3, r3, #0x2
 80169b4: b21b         	sxth	r3, r3
 80169b6: 4313         	orrs	r3, r2
 80169b8: b21a         	sxth	r2, r3
 80169ba: 68fb         	ldr	r3, [r7, #0xc]
 80169bc: 795b         	ldrb	r3, [r3, #0x5]
 80169be: 029b         	lsls	r3, r3, #0xa
 80169c0: b21b         	sxth	r3, r3
 80169c2: 4313         	orrs	r3, r2
 80169c4: b21b         	sxth	r3, r3
 80169c6: b29b         	uxth	r3, r3
 80169c8: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 80169cc: b29a         	uxth	r2, r3
 80169ce: 68fb         	ldr	r3, [r7, #0xc]
 80169d0: 83da         	strh	r2, [r3, #0x1e]
;     data->channels[3] = (data->data[5] >> 1 | (data->data[6] << 7)) & 0x07FF;
 80169d2: 68fb         	ldr	r3, [r7, #0xc]
 80169d4: 795b         	ldrb	r3, [r3, #0x5]
 80169d6: 085b         	lsrs	r3, r3, #0x1
 80169d8: b2db         	uxtb	r3, r3
 80169da: b21a         	sxth	r2, r3
 80169dc: 68fb         	ldr	r3, [r7, #0xc]
 80169de: 799b         	ldrb	r3, [r3, #0x6]
 80169e0: 01db         	lsls	r3, r3, #0x7
 80169e2: b21b         	sxth	r3, r3
 80169e4: 4313         	orrs	r3, r2
 80169e6: b21b         	sxth	r3, r3
 80169e8: b29b         	uxth	r3, r3
 80169ea: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 80169ee: b29a         	uxth	r2, r3
 80169f0: 68fb         	ldr	r3, [r7, #0xc]
 80169f2: 841a         	strh	r2, [r3, #0x20]
;     data->channels[4] = (data->data[6] >> 4 | (data->data[7] << 4)) & 0x07FF;
 80169f4: 68fb         	ldr	r3, [r7, #0xc]
 80169f6: 799b         	ldrb	r3, [r3, #0x6]
 80169f8: 091b         	lsrs	r3, r3, #0x4
 80169fa: b2db         	uxtb	r3, r3
 80169fc: b21a         	sxth	r2, r3
 80169fe: 68fb         	ldr	r3, [r7, #0xc]
 8016a00: 79db         	ldrb	r3, [r3, #0x7]
 8016a02: 011b         	lsls	r3, r3, #0x4
 8016a04: b21b         	sxth	r3, r3
 8016a06: 4313         	orrs	r3, r2
 8016a08: b21b         	sxth	r3, r3
 8016a0a: b29b         	uxth	r3, r3
 8016a0c: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8016a10: b29a         	uxth	r2, r3
 8016a12: 68fb         	ldr	r3, [r7, #0xc]
 8016a14: 845a         	strh	r2, [r3, #0x22]
;     data->channels[5] = (data->data[7] >> 7 | (data->data[8] << 1) | data->data[9] << 9) & 0x07FF;
 8016a16: 68fb         	ldr	r3, [r7, #0xc]
 8016a18: 79db         	ldrb	r3, [r3, #0x7]
 8016a1a: 09db         	lsrs	r3, r3, #0x7
 8016a1c: b2db         	uxtb	r3, r3
 8016a1e: b21a         	sxth	r2, r3
 8016a20: 68fb         	ldr	r3, [r7, #0xc]
 8016a22: 7a1b         	ldrb	r3, [r3, #0x8]
 8016a24: 005b         	lsls	r3, r3, #0x1
 8016a26: b21b         	sxth	r3, r3
 8016a28: 4313         	orrs	r3, r2
 8016a2a: b21a         	sxth	r2, r3
 8016a2c: 68fb         	ldr	r3, [r7, #0xc]
 8016a2e: 7a5b         	ldrb	r3, [r3, #0x9]
 8016a30: 025b         	lsls	r3, r3, #0x9
 8016a32: b21b         	sxth	r3, r3
 8016a34: 4313         	orrs	r3, r2
 8016a36: b21b         	sxth	r3, r3
 8016a38: b29b         	uxth	r3, r3
 8016a3a: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8016a3e: b29a         	uxth	r2, r3
 8016a40: 68fb         	ldr	r3, [r7, #0xc]
 8016a42: 849a         	strh	r2, [r3, #0x24]
;     data->channels[6] = (data->data[9] >> 2 | (data->data[10] << 6)) & 0x07FF;
 8016a44: 68fb         	ldr	r3, [r7, #0xc]
 8016a46: 7a5b         	ldrb	r3, [r3, #0x9]
 8016a48: 089b         	lsrs	r3, r3, #0x2
 8016a4a: b2db         	uxtb	r3, r3
 8016a4c: b21a         	sxth	r2, r3
 8016a4e: 68fb         	ldr	r3, [r7, #0xc]
 8016a50: 7a9b         	ldrb	r3, [r3, #0xa]
 8016a52: 019b         	lsls	r3, r3, #0x6
 8016a54: b21b         	sxth	r3, r3
 8016a56: 4313         	orrs	r3, r2
 8016a58: b21b         	sxth	r3, r3
 8016a5a: b29b         	uxth	r3, r3
 8016a5c: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8016a60: b29a         	uxth	r2, r3
 8016a62: 68fb         	ldr	r3, [r7, #0xc]
 8016a64: 84da         	strh	r2, [r3, #0x26]
;     data->channels[7] = (data->data[10] >> 5 | (data->data[11] << 3)) & 0x07FF;
 8016a66: 68fb         	ldr	r3, [r7, #0xc]
 8016a68: 7a9b         	ldrb	r3, [r3, #0xa]
 8016a6a: 095b         	lsrs	r3, r3, #0x5
 8016a6c: b2db         	uxtb	r3, r3
 8016a6e: b21a         	sxth	r2, r3
 8016a70: 68fb         	ldr	r3, [r7, #0xc]
 8016a72: 7adb         	ldrb	r3, [r3, #0xb]
 8016a74: 00db         	lsls	r3, r3, #0x3
 8016a76: b21b         	sxth	r3, r3
 8016a78: 4313         	orrs	r3, r2
 8016a7a: b21b         	sxth	r3, r3
 8016a7c: b29b         	uxth	r3, r3
 8016a7e: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8016a82: b29a         	uxth	r2, r3
 8016a84: 68fb         	ldr	r3, [r7, #0xc]
 8016a86: 851a         	strh	r2, [r3, #0x28]
;     data->channels[8] = (data->data[12] << 0 | (data->data[13] << 8)) & 0x07FF;
 8016a88: 68fb         	ldr	r3, [r7, #0xc]
 8016a8a: 7b1b         	ldrb	r3, [r3, #0xc]
 8016a8c: b21a         	sxth	r2, r3
 8016a8e: 68fb         	ldr	r3, [r7, #0xc]
 8016a90: 7b5b         	ldrb	r3, [r3, #0xd]
 8016a92: 021b         	lsls	r3, r3, #0x8
 8016a94: b21b         	sxth	r3, r3
 8016a96: 4313         	orrs	r3, r2
 8016a98: b21b         	sxth	r3, r3
 8016a9a: b29b         	uxth	r3, r3
 8016a9c: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8016aa0: b29a         	uxth	r2, r3
 8016aa2: 68fb         	ldr	r3, [r7, #0xc]
 8016aa4: 855a         	strh	r2, [r3, #0x2a]
;     data->channels[9] = (data->data[13] >> 3 | (data->data[14] << 5)) & 0x07FF;
 8016aa6: 68fb         	ldr	r3, [r7, #0xc]
 8016aa8: 7b5b         	ldrb	r3, [r3, #0xd]
 8016aaa: 08db         	lsrs	r3, r3, #0x3
 8016aac: b2db         	uxtb	r3, r3
 8016aae: b21a         	sxth	r2, r3
 8016ab0: 68fb         	ldr	r3, [r7, #0xc]
 8016ab2: 7b9b         	ldrb	r3, [r3, #0xe]
 8016ab4: 015b         	lsls	r3, r3, #0x5
 8016ab6: b21b         	sxth	r3, r3
 8016ab8: 4313         	orrs	r3, r2
 8016aba: b21b         	sxth	r3, r3
 8016abc: b29b         	uxth	r3, r3
 8016abe: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8016ac2: b29a         	uxth	r2, r3
 8016ac4: 68fb         	ldr	r3, [r7, #0xc]
 8016ac6: 859a         	strh	r2, [r3, #0x2c]
;         (data->data[14] >> 6 | (data->data[16] << 2) | data->data[15] << 10) & 0x07FF;
 8016ac8: 68fb         	ldr	r3, [r7, #0xc]
 8016aca: 7b9b         	ldrb	r3, [r3, #0xe]
 8016acc: 099b         	lsrs	r3, r3, #0x6
 8016ace: b2db         	uxtb	r3, r3
 8016ad0: b21a         	sxth	r2, r3
 8016ad2: 68fb         	ldr	r3, [r7, #0xc]
 8016ad4: 7c1b         	ldrb	r3, [r3, #0x10]
 8016ad6: 009b         	lsls	r3, r3, #0x2
 8016ad8: b21b         	sxth	r3, r3
 8016ada: 4313         	orrs	r3, r2
 8016adc: b21a         	sxth	r2, r3
 8016ade: 68fb         	ldr	r3, [r7, #0xc]
 8016ae0: 7bdb         	ldrb	r3, [r3, #0xf]
 8016ae2: 029b         	lsls	r3, r3, #0xa
 8016ae4: b21b         	sxth	r3, r3
 8016ae6: 4313         	orrs	r3, r2
 8016ae8: b21b         	sxth	r3, r3
 8016aea: b29b         	uxth	r3, r3
 8016aec: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8016af0: b29a         	uxth	r2, r3
;     data->channels[10] =
 8016af2: 68fb         	ldr	r3, [r7, #0xc]
 8016af4: 85da         	strh	r2, [r3, #0x2e]
;     data->channels[11] = (data->data[16] >> 1 | (data->data[17] << 7)) & 0x07FF;
 8016af6: 68fb         	ldr	r3, [r7, #0xc]
 8016af8: 7c1b         	ldrb	r3, [r3, #0x10]
 8016afa: 085b         	lsrs	r3, r3, #0x1
 8016afc: b2db         	uxtb	r3, r3
 8016afe: b21a         	sxth	r2, r3
 8016b00: 68fb         	ldr	r3, [r7, #0xc]
 8016b02: 7c5b         	ldrb	r3, [r3, #0x11]
 8016b04: 01db         	lsls	r3, r3, #0x7
 8016b06: b21b         	sxth	r3, r3
 8016b08: 4313         	orrs	r3, r2
 8016b0a: b21b         	sxth	r3, r3
 8016b0c: b29b         	uxth	r3, r3
 8016b0e: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8016b12: b29a         	uxth	r2, r3
 8016b14: 68fb         	ldr	r3, [r7, #0xc]
 8016b16: 861a         	strh	r2, [r3, #0x30]
;     data->channels[12] = (data->data[17] >> 4 | (data->data[18] << 4)) & 0x07FF;
 8016b18: 68fb         	ldr	r3, [r7, #0xc]
 8016b1a: 7c5b         	ldrb	r3, [r3, #0x11]
 8016b1c: 091b         	lsrs	r3, r3, #0x4
 8016b1e: b2db         	uxtb	r3, r3
 8016b20: b21a         	sxth	r2, r3
 8016b22: 68fb         	ldr	r3, [r7, #0xc]
 8016b24: 7c9b         	ldrb	r3, [r3, #0x12]
 8016b26: 011b         	lsls	r3, r3, #0x4
 8016b28: b21b         	sxth	r3, r3
 8016b2a: 4313         	orrs	r3, r2
 8016b2c: b21b         	sxth	r3, r3
 8016b2e: b29b         	uxth	r3, r3
 8016b30: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8016b34: b29a         	uxth	r2, r3
 8016b36: 68fb         	ldr	r3, [r7, #0xc]
 8016b38: 865a         	strh	r2, [r3, #0x32]
;         (data->data[18] >> 7 | (data->data[19] << 1) | data->data[20] << 9) & 0x07FF;
 8016b3a: 68fb         	ldr	r3, [r7, #0xc]
 8016b3c: 7c9b         	ldrb	r3, [r3, #0x12]
 8016b3e: 09db         	lsrs	r3, r3, #0x7
 8016b40: b2db         	uxtb	r3, r3
 8016b42: b21a         	sxth	r2, r3
 8016b44: 68fb         	ldr	r3, [r7, #0xc]
 8016b46: 7cdb         	ldrb	r3, [r3, #0x13]
 8016b48: 005b         	lsls	r3, r3, #0x1
 8016b4a: b21b         	sxth	r3, r3
 8016b4c: 4313         	orrs	r3, r2
 8016b4e: b21a         	sxth	r2, r3
 8016b50: 68fb         	ldr	r3, [r7, #0xc]
 8016b52: 7d1b         	ldrb	r3, [r3, #0x14]
 8016b54: 025b         	lsls	r3, r3, #0x9
 8016b56: b21b         	sxth	r3, r3
 8016b58: 4313         	orrs	r3, r2
 8016b5a: b21b         	sxth	r3, r3
 8016b5c: b29b         	uxth	r3, r3
 8016b5e: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8016b62: b29a         	uxth	r2, r3
;     data->channels[13] =
 8016b64: 68fb         	ldr	r3, [r7, #0xc]
 8016b66: 869a         	strh	r2, [r3, #0x34]
;     data->channels[14] = (data->data[20] >> 2 | (data->data[21] << 6)) & 0x07FF;
 8016b68: 68fb         	ldr	r3, [r7, #0xc]
 8016b6a: 7d1b         	ldrb	r3, [r3, #0x14]
 8016b6c: 089b         	lsrs	r3, r3, #0x2
 8016b6e: b2db         	uxtb	r3, r3
 8016b70: b21a         	sxth	r2, r3
 8016b72: 68fb         	ldr	r3, [r7, #0xc]
 8016b74: 7d5b         	ldrb	r3, [r3, #0x15]
 8016b76: 019b         	lsls	r3, r3, #0x6
 8016b78: b21b         	sxth	r3, r3
 8016b7a: 4313         	orrs	r3, r2
 8016b7c: b21b         	sxth	r3, r3
 8016b7e: b29b         	uxth	r3, r3
 8016b80: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8016b84: b29a         	uxth	r2, r3
 8016b86: 68fb         	ldr	r3, [r7, #0xc]
 8016b88: 86da         	strh	r2, [r3, #0x36]
;     data->channels[15] = (data->data[21] >> 5 | (data->data[22] << 3)) & 0x07FF;
 8016b8a: 68fb         	ldr	r3, [r7, #0xc]
 8016b8c: 7d5b         	ldrb	r3, [r3, #0x15]
 8016b8e: 095b         	lsrs	r3, r3, #0x5
 8016b90: b2db         	uxtb	r3, r3
 8016b92: b21a         	sxth	r2, r3
 8016b94: 68fb         	ldr	r3, [r7, #0xc]
 8016b96: 7d9b         	ldrb	r3, [r3, #0x16]
 8016b98: 00db         	lsls	r3, r3, #0x3
 8016b9a: b21b         	sxth	r3, r3
 8016b9c: 4313         	orrs	r3, r2
 8016b9e: b21b         	sxth	r3, r3
 8016ba0: b29b         	uxth	r3, r3
 8016ba2: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8016ba6: b29a         	uxth	r2, r3
 8016ba8: 68fb         	ldr	r3, [r7, #0xc]
 8016baa: 871a         	strh	r2, [r3, #0x38]
;     data->frameLost          = (data->data[23] & 0x04) >> 2;
 8016bac: 68fb         	ldr	r3, [r7, #0xc]
 8016bae: 7ddb         	ldrb	r3, [r3, #0x17]
 8016bb0: 109b         	asrs	r3, r3, #0x2
 8016bb2: f003 0301    	and	r3, r3, #0x1
 8016bb6: 2b00         	cmp	r3, #0x0
 8016bb8: bf14         	ite	ne
 8016bba: 2301         	movne	r3, #0x1
 8016bbc: 2300         	moveq	r3, #0x0
 8016bbe: b2da         	uxtb	r2, r3
 8016bc0: 68fb         	ldr	r3, [r7, #0xc]
 8016bc2: f883 203a    	strb.w	r2, [r3, #0x3a]
;     data->failSafe           = (data->data[23] & 0x08) >> 3;
 8016bc6: 68fb         	ldr	r3, [r7, #0xc]
 8016bc8: 7ddb         	ldrb	r3, [r3, #0x17]
 8016bca: 10db         	asrs	r3, r3, #0x3
 8016bcc: f003 0301    	and	r3, r3, #0x1
 8016bd0: 2b00         	cmp	r3, #0x0
 8016bd2: bf14         	ite	ne
 8016bd4: 2301         	movne	r3, #0x1
 8016bd6: 2300         	moveq	r3, #0x0
 8016bd8: b2da         	uxtb	r2, r3
 8016bda: 68fb         	ldr	r3, [r7, #0xc]
 8016bdc: f883 203b    	strb.w	r2, [r3, #0x3b]
;     data->digitalChannels[0] = (data->data[23] & 0x01);
 8016be0: 68fb         	ldr	r3, [r7, #0xc]
 8016be2: 7ddb         	ldrb	r3, [r3, #0x17]
 8016be4: f003 0301    	and	r3, r3, #0x1
 8016be8: 2b00         	cmp	r3, #0x0
 8016bea: bf14         	ite	ne
 8016bec: 2301         	movne	r3, #0x1
 8016bee: 2300         	moveq	r3, #0x0
 8016bf0: b2da         	uxtb	r2, r3
 8016bf2: 68fb         	ldr	r3, [r7, #0xc]
 8016bf4: f883 203c    	strb.w	r2, [r3, #0x3c]
;     data->digitalChannels[1] = (data->data[23] & 0x02) >> 1;
 8016bf8: 68fb         	ldr	r3, [r7, #0xc]
 8016bfa: 7ddb         	ldrb	r3, [r3, #0x17]
 8016bfc: 105b         	asrs	r3, r3, #0x1
 8016bfe: f003 0301    	and	r3, r3, #0x1
 8016c02: 2b00         	cmp	r3, #0x0
 8016c04: bf14         	ite	ne
 8016c06: 2301         	movne	r3, #0x1
 8016c08: 2300         	moveq	r3, #0x0
 8016c0a: b2da         	uxtb	r2, r3
 8016c0c: 68fb         	ldr	r3, [r7, #0xc]
 8016c0e: f883 203d    	strb.w	r2, [r3, #0x3d]
; }
 8016c12: bf00         	nop
 8016c14: 3714         	adds	r7, #0x14
 8016c16: 46bd         	mov	sp, r7
 8016c18: bc80         	pop	{r7}
 8016c1a: 4770         	bx	lr

08016c1c <find_begin>:
; static int16_t find_begin(const uint8_t *data, uint16_t len) {
 8016c1c: b480         	push	{r7}
 8016c1e: b085         	sub	sp, #0x14
 8016c20: af00         	add	r7, sp, #0x0
 8016c22: 6078         	str	r0, [r7, #0x4]
 8016c24: 460b         	mov	r3, r1
 8016c26: 807b         	strh	r3, [r7, #0x2]
;     if (len < 25) {
 8016c28: 887b         	ldrh	r3, [r7, #0x2]
 8016c2a: 2b18         	cmp	r3, #0x18
 8016c2c: d802         	bhi	0x8016c34 <find_begin+0x18> @ imm = #0x4
;         return -1;
 8016c2e: f04f 33ff    	mov.w	r3, #0xffffffff
 8016c32: e01e         	b	0x8016c72 <find_begin+0x56> @ imm = #0x3c
;     for (int i = len - 1; i >= 24; i--) {
 8016c34: 887b         	ldrh	r3, [r7, #0x2]
 8016c36: 3b01         	subs	r3, #0x1
 8016c38: 60fb         	str	r3, [r7, #0xc]
 8016c3a: e015         	b	0x8016c68 <find_begin+0x4c> @ imm = #0x2a
;         if (data[i - 24] == 0x0F && data[i] == 0x00) {
 8016c3c: 68fb         	ldr	r3, [r7, #0xc]
 8016c3e: 3b18         	subs	r3, #0x18
 8016c40: 687a         	ldr	r2, [r7, #0x4]
 8016c42: 4413         	add	r3, r2
 8016c44: 781b         	ldrb	r3, [r3]
 8016c46: 2b0f         	cmp	r3, #0xf
 8016c48: d10b         	bne	0x8016c62 <find_begin+0x46> @ imm = #0x16
 8016c4a: 68fb         	ldr	r3, [r7, #0xc]
 8016c4c: 687a         	ldr	r2, [r7, #0x4]
 8016c4e: 4413         	add	r3, r2
 8016c50: 781b         	ldrb	r3, [r3]
 8016c52: 2b00         	cmp	r3, #0x0
 8016c54: d105         	bne	0x8016c62 <find_begin+0x46> @ imm = #0xa
;             return i - 24;
 8016c56: 68fb         	ldr	r3, [r7, #0xc]
 8016c58: b29b         	uxth	r3, r3
 8016c5a: 3b18         	subs	r3, #0x18
 8016c5c: b29b         	uxth	r3, r3
 8016c5e: b21b         	sxth	r3, r3
 8016c60: e007         	b	0x8016c72 <find_begin+0x56> @ imm = #0xe
;     for (int i = len - 1; i >= 24; i--) {
 8016c62: 68fb         	ldr	r3, [r7, #0xc]
 8016c64: 3b01         	subs	r3, #0x1
 8016c66: 60fb         	str	r3, [r7, #0xc]
 8016c68: 68fb         	ldr	r3, [r7, #0xc]
 8016c6a: 2b17         	cmp	r3, #0x17
 8016c6c: dce6         	bgt	0x8016c3c <find_begin+0x20> @ imm = #-0x34
;     return -1;
 8016c6e: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 8016c72: 4618         	mov	r0, r3
 8016c74: 3714         	adds	r7, #0x14
 8016c76: 46bd         	mov	sp, r7
 8016c78: bc80         	pop	{r7}
 8016c7a: 4770         	bx	lr

08016c7c <sbus_getchannel_digital>:
; int sbus_getchannel_digital(const struct device *dev, uint8_t channelid) {
 8016c7c: b580         	push	{r7, lr}
 8016c7e: b084         	sub	sp, #0x10
 8016c80: af00         	add	r7, sp, #0x0
 8016c82: 6078         	str	r0, [r7, #0x4]
 8016c84: 460b         	mov	r3, r1
 8016c86: 70fb         	strb	r3, [r7, #0x3]
;     struct sbus_driver_data *data = dev->data;
 8016c88: 687b         	ldr	r3, [r7, #0x4]
 8016c8a: 691b         	ldr	r3, [r3, #0x10]
 8016c8c: 60fb         	str	r3, [r7, #0xc]
;     sbus_parseframe(dev);
 8016c8e: 6878         	ldr	r0, [r7, #0x4]
 8016c90: f7ff fe61    	bl	0x8016956 <sbus_parseframe> @ imm = #-0x33e
;     return data->channels[channelid];
 8016c94: 78fb         	ldrb	r3, [r7, #0x3]
 8016c96: 68fa         	ldr	r2, [r7, #0xc]
 8016c98: 330c         	adds	r3, #0xc
 8016c9a: 005b         	lsls	r3, r3, #0x1
 8016c9c: 4413         	add	r3, r2
 8016c9e: 885b         	ldrh	r3, [r3, #0x2]
; }
 8016ca0: 4618         	mov	r0, r3
 8016ca2: 3710         	adds	r7, #0x10
 8016ca4: 46bd         	mov	sp, r7
 8016ca6: bd80         	pop	{r7, pc}

08016ca8 <LL_DMA_Init>:
; {
 8016ca8: b580         	push	{r7, lr}
 8016caa: b084         	sub	sp, #0x10
 8016cac: af00         	add	r7, sp, #0x0
 8016cae: 60f8         	str	r0, [r7, #0xc]
 8016cb0: 60b9         	str	r1, [r7, #0x8]
 8016cb2: 607a         	str	r2, [r7, #0x4]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 8016cb4: 687b         	ldr	r3, [r7, #0x4]
 8016cb6: 689a         	ldr	r2, [r3, #0x8]
;                         DMA_InitStruct->Mode                    | \
 8016cb8: 687b         	ldr	r3, [r7, #0x4]
 8016cba: 68db         	ldr	r3, [r3, #0xc]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 8016cbc: 431a         	orrs	r2, r3
;                         DMA_InitStruct->PeriphOrM2MSrcIncMode   | \
 8016cbe: 687b         	ldr	r3, [r7, #0x4]
 8016cc0: 691b         	ldr	r3, [r3, #0x10]
;                         DMA_InitStruct->Mode                    | \
 8016cc2: 431a         	orrs	r2, r3
;                         DMA_InitStruct->MemoryOrM2MDstIncMode   | \
 8016cc4: 687b         	ldr	r3, [r7, #0x4]
 8016cc6: 695b         	ldr	r3, [r3, #0x14]
;                         DMA_InitStruct->PeriphOrM2MSrcIncMode   | \
 8016cc8: 431a         	orrs	r2, r3
;                         DMA_InitStruct->PeriphOrM2MSrcDataSize  | \
 8016cca: 687b         	ldr	r3, [r7, #0x4]
 8016ccc: 699b         	ldr	r3, [r3, #0x18]
;                         DMA_InitStruct->MemoryOrM2MDstIncMode   | \
 8016cce: 431a         	orrs	r2, r3
;                         DMA_InitStruct->MemoryOrM2MDstDataSize  | \
 8016cd0: 687b         	ldr	r3, [r7, #0x4]
 8016cd2: 69db         	ldr	r3, [r3, #0x1c]
;                         DMA_InitStruct->PeriphOrM2MSrcDataSize  | \
 8016cd4: 431a         	orrs	r2, r3
;                         DMA_InitStruct->Priority
 8016cd6: 687b         	ldr	r3, [r7, #0x4]
 8016cd8: 6a9b         	ldr	r3, [r3, #0x28]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 8016cda: 4313         	orrs	r3, r2
 8016cdc: 461a         	mov	r2, r3
 8016cde: 68b9         	ldr	r1, [r7, #0x8]
 8016ce0: 68f8         	ldr	r0, [r7, #0xc]
 8016ce2: f7f4 f989    	bl	0x800aff8 <LL_DMA_ConfigTransfer> @ imm = #-0xbcee
;   if(DMA_InitStruct->FIFOMode != LL_DMA_FIFOMODE_DISABLE)
 8016ce6: 687b         	ldr	r3, [r7, #0x4]
 8016ce8: 6adb         	ldr	r3, [r3, #0x2c]
 8016cea: 2b00         	cmp	r3, #0x0
 8016cec: d015         	beq	0x8016d1a <LL_DMA_Init+0x72> @ imm = #0x2a
;     LL_DMA_ConfigFifo(DMAx, Stream, DMA_InitStruct->FIFOMode, DMA_InitStruct->FIFOThreshold);
 8016cee: 687b         	ldr	r3, [r7, #0x4]
 8016cf0: 6ada         	ldr	r2, [r3, #0x2c]
 8016cf2: 687b         	ldr	r3, [r7, #0x4]
 8016cf4: 6b1b         	ldr	r3, [r3, #0x30]
 8016cf6: 68b9         	ldr	r1, [r7, #0x8]
 8016cf8: 68f8         	ldr	r0, [r7, #0xc]
 8016cfa: f7f4 fa29    	bl	0x800b150 <LL_DMA_ConfigFifo> @ imm = #-0xbbae
;     LL_DMA_SetMemoryBurstxfer(DMAx,Stream,DMA_InitStruct->MemBurst);
 8016cfe: 687b         	ldr	r3, [r7, #0x4]
 8016d00: 6b5b         	ldr	r3, [r3, #0x34]
 8016d02: 461a         	mov	r2, r3
 8016d04: 68b9         	ldr	r1, [r7, #0x8]
 8016d06: 68f8         	ldr	r0, [r7, #0xc]
 8016d08: f7f4 f9de    	bl	0x800b0c8 <LL_DMA_SetMemoryBurstxfer> @ imm = #-0xbc44
;     LL_DMA_SetPeriphBurstxfer(DMAx,Stream,DMA_InitStruct->PeriphBurst);
 8016d0c: 687b         	ldr	r3, [r7, #0x4]
 8016d0e: 6b9b         	ldr	r3, [r3, #0x38]
 8016d10: 461a         	mov	r2, r3
 8016d12: 68b9         	ldr	r1, [r7, #0x8]
 8016d14: 68f8         	ldr	r0, [r7, #0xc]
 8016d16: f7f4 f9f9    	bl	0x800b10c <LL_DMA_SetPeriphBurstxfer> @ imm = #-0xbc0e
;   LL_DMA_SetMemoryAddress(DMAx, Stream, DMA_InitStruct->MemoryOrM2MDstAddress);
 8016d1a: 687b         	ldr	r3, [r7, #0x4]
 8016d1c: 685b         	ldr	r3, [r3, #0x4]
 8016d1e: 461a         	mov	r2, r3
 8016d20: 68b9         	ldr	r1, [r7, #0x8]
 8016d22: 68f8         	ldr	r0, [r7, #0xc]
 8016d24: f7f4 fa38    	bl	0x800b198 <LL_DMA_SetMemoryAddress> @ imm = #-0xbb90
;   LL_DMA_SetPeriphAddress(DMAx, Stream, DMA_InitStruct->PeriphOrM2MSrcAddress);
 8016d28: 687b         	ldr	r3, [r7, #0x4]
 8016d2a: 681b         	ldr	r3, [r3]
 8016d2c: 461a         	mov	r2, r3
 8016d2e: 68b9         	ldr	r1, [r7, #0x8]
 8016d30: 68f8         	ldr	r0, [r7, #0xc]
 8016d32: f7f4 fa49    	bl	0x800b1c8 <LL_DMA_SetPeriphAddress> @ imm = #-0xbb6e
;   LL_DMA_SetDataLength(DMAx, Stream, DMA_InitStruct->NbData);
 8016d36: 687b         	ldr	r3, [r7, #0x4]
 8016d38: 6a1b         	ldr	r3, [r3, #0x20]
 8016d3a: 461a         	mov	r2, r3
 8016d3c: 68b9         	ldr	r1, [r7, #0x8]
 8016d3e: 68f8         	ldr	r0, [r7, #0xc]
 8016d40: f7f4 f97e    	bl	0x800b040 <LL_DMA_SetDataLength> @ imm = #-0xbd04
;   LL_DMA_SetChannelSelection(DMAx, Stream, DMA_InitStruct->Channel);
 8016d44: 687b         	ldr	r3, [r7, #0x4]
 8016d46: 6a5b         	ldr	r3, [r3, #0x24]
 8016d48: 461a         	mov	r2, r3
 8016d4a: 68b9         	ldr	r1, [r7, #0x8]
 8016d4c: 68f8         	ldr	r0, [r7, #0xc]
 8016d4e: f7f4 f999    	bl	0x800b084 <LL_DMA_SetChannelSelection> @ imm = #-0xbcce
;   return SUCCESS;
 8016d52: 2300         	movs	r3, #0x0
; }
 8016d54: 4618         	mov	r0, r3
 8016d56: 3710         	adds	r7, #0x10
 8016d58: 46bd         	mov	sp, r7
 8016d5a: bd80         	pop	{r7, pc}

08016d5c <LL_DMA_StructInit>:
; {
 8016d5c: b480         	push	{r7}
 8016d5e: b083         	sub	sp, #0xc
 8016d60: af00         	add	r7, sp, #0x0
 8016d62: 6078         	str	r0, [r7, #0x4]
;   DMA_InitStruct->PeriphOrM2MSrcAddress  = 0x00000000U;
 8016d64: 687b         	ldr	r3, [r7, #0x4]
 8016d66: 2200         	movs	r2, #0x0
 8016d68: 601a         	str	r2, [r3]
;   DMA_InitStruct->MemoryOrM2MDstAddress  = 0x00000000U;
 8016d6a: 687b         	ldr	r3, [r7, #0x4]
 8016d6c: 2200         	movs	r2, #0x0
 8016d6e: 605a         	str	r2, [r3, #0x4]
;   DMA_InitStruct->Direction              = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
 8016d70: 687b         	ldr	r3, [r7, #0x4]
 8016d72: 2200         	movs	r2, #0x0
 8016d74: 609a         	str	r2, [r3, #0x8]
;   DMA_InitStruct->Mode                   = LL_DMA_MODE_NORMAL;
 8016d76: 687b         	ldr	r3, [r7, #0x4]
 8016d78: 2200         	movs	r2, #0x0
 8016d7a: 60da         	str	r2, [r3, #0xc]
;   DMA_InitStruct->PeriphOrM2MSrcIncMode  = LL_DMA_PERIPH_NOINCREMENT;
 8016d7c: 687b         	ldr	r3, [r7, #0x4]
 8016d7e: 2200         	movs	r2, #0x0
 8016d80: 611a         	str	r2, [r3, #0x10]
;   DMA_InitStruct->MemoryOrM2MDstIncMode  = LL_DMA_MEMORY_NOINCREMENT;
 8016d82: 687b         	ldr	r3, [r7, #0x4]
 8016d84: 2200         	movs	r2, #0x0
 8016d86: 615a         	str	r2, [r3, #0x14]
;   DMA_InitStruct->PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;
 8016d88: 687b         	ldr	r3, [r7, #0x4]
 8016d8a: 2200         	movs	r2, #0x0
 8016d8c: 619a         	str	r2, [r3, #0x18]
;   DMA_InitStruct->MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;
 8016d8e: 687b         	ldr	r3, [r7, #0x4]
 8016d90: 2200         	movs	r2, #0x0
 8016d92: 61da         	str	r2, [r3, #0x1c]
;   DMA_InitStruct->NbData                 = 0x00000000U;
 8016d94: 687b         	ldr	r3, [r7, #0x4]
 8016d96: 2200         	movs	r2, #0x0
 8016d98: 621a         	str	r2, [r3, #0x20]
;   DMA_InitStruct->Channel                = LL_DMA_CHANNEL_0;
 8016d9a: 687b         	ldr	r3, [r7, #0x4]
 8016d9c: 2200         	movs	r2, #0x0
 8016d9e: 625a         	str	r2, [r3, #0x24]
;   DMA_InitStruct->Priority               = LL_DMA_PRIORITY_LOW;
 8016da0: 687b         	ldr	r3, [r7, #0x4]
 8016da2: 2200         	movs	r2, #0x0
 8016da4: 629a         	str	r2, [r3, #0x28]
;   DMA_InitStruct->FIFOMode               = LL_DMA_FIFOMODE_DISABLE;
 8016da6: 687b         	ldr	r3, [r7, #0x4]
 8016da8: 2200         	movs	r2, #0x0
 8016daa: 62da         	str	r2, [r3, #0x2c]
;   DMA_InitStruct->FIFOThreshold          = LL_DMA_FIFOTHRESHOLD_1_4;
 8016dac: 687b         	ldr	r3, [r7, #0x4]
 8016dae: 2200         	movs	r2, #0x0
 8016db0: 631a         	str	r2, [r3, #0x30]
;   DMA_InitStruct->MemBurst               = LL_DMA_MBURST_SINGLE;
 8016db2: 687b         	ldr	r3, [r7, #0x4]
 8016db4: 2200         	movs	r2, #0x0
 8016db6: 635a         	str	r2, [r3, #0x34]
;   DMA_InitStruct->PeriphBurst            = LL_DMA_PBURST_SINGLE;
 8016db8: 687b         	ldr	r3, [r7, #0x4]
 8016dba: 2200         	movs	r2, #0x0
 8016dbc: 639a         	str	r2, [r3, #0x38]
; }
 8016dbe: bf00         	nop
 8016dc0: 370c         	adds	r7, #0xc
 8016dc2: 46bd         	mov	sp, r7
 8016dc4: bc80         	pop	{r7}
 8016dc6: 4770         	bx	lr

08016dc8 <k_object_init>:
; {
 8016dc8: b480         	push	{r7}
 8016dca: b083         	sub	sp, #0xc
 8016dcc: af00         	add	r7, sp, #0x0
 8016dce: 6078         	str	r0, [r7, #0x4]
; }
 8016dd0: bf00         	nop
 8016dd2: 370c         	adds	r7, #0xc
 8016dd4: 46bd         	mov	sp, r7
 8016dd6: bc80         	pop	{r7}
 8016dd8: 4770         	bx	lr

08016dda <z_impl_device_is_ready>:
; {
 8016dda: b480         	push	{r7}
 8016ddc: b083         	sub	sp, #0xc
 8016dde: af00         	add	r7, sp, #0x0
 8016de0: 6078         	str	r0, [r7, #0x4]
; 	if (dev == NULL) {
 8016de2: 687b         	ldr	r3, [r7, #0x4]
 8016de4: 2b00         	cmp	r3, #0x0
 8016de6: d101         	bne	0x8016dec <z_impl_device_is_ready+0x12> @ imm = #0x2
; 		return false;
 8016de8: 2300         	movs	r3, #0x0
 8016dea: e012         	b	0x8016e12 <z_impl_device_is_ready+0x38> @ imm = #0x24
; 	return dev->state->initialized && (dev->state->init_res == 0U);
 8016dec: 687b         	ldr	r3, [r7, #0x4]
 8016dee: 68db         	ldr	r3, [r3, #0xc]
 8016df0: 785b         	ldrb	r3, [r3, #0x1]
 8016df2: f003 0301    	and	r3, r3, #0x1
 8016df6: b2db         	uxtb	r3, r3
 8016df8: 2b00         	cmp	r3, #0x0
 8016dfa: d006         	beq	0x8016e0a <z_impl_device_is_ready+0x30> @ imm = #0xc
 8016dfc: 687b         	ldr	r3, [r7, #0x4]
 8016dfe: 68db         	ldr	r3, [r3, #0xc]
 8016e00: 781b         	ldrb	r3, [r3]
 8016e02: 2b00         	cmp	r3, #0x0
 8016e04: d101         	bne	0x8016e0a <z_impl_device_is_ready+0x30> @ imm = #0x2
 8016e06: 2301         	movs	r3, #0x1
 8016e08: e000         	b	0x8016e0c <z_impl_device_is_ready+0x32> @ imm = #0x0
 8016e0a: 2300         	movs	r3, #0x0
 8016e0c: f003 0301    	and	r3, r3, #0x1
 8016e10: b2db         	uxtb	r3, r3
; }
 8016e12: 4618         	mov	r0, r3
 8016e14: 370c         	adds	r7, #0xc
 8016e16: 46bd         	mov	sp, r7
 8016e18: bc80         	pop	{r7}
 8016e1a: 4770         	bx	lr

08016e1c <k_thread_abort>:
; {
 8016e1c: b580         	push	{r7, lr}
 8016e1e: b082         	sub	sp, #0x8
 8016e20: af00         	add	r7, sp, #0x0
 8016e22: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 8016e24: 6878         	ldr	r0, [r7, #0x4]
 8016e26: f7ec fd2f    	bl	0x8003888 <z_impl_k_thread_abort> @ imm = #-0x135a2
; }
 8016e2a: bf00         	nop
 8016e2c: 3708         	adds	r7, #0x8
 8016e2e: 46bd         	mov	sp, r7
 8016e30: bd80         	pop	{r7, pc}

08016e32 <z_log_msg_runtime_create>:
; {
 8016e32: b580         	push	{r7, lr}
 8016e34: b08a         	sub	sp, #0x28
 8016e36: af04         	add	r7, sp, #0x10
 8016e38: 60b9         	str	r1, [r7, #0x8]
 8016e3a: 607b         	str	r3, [r7, #0x4]
 8016e3c: 4603         	mov	r3, r0
 8016e3e: 73fb         	strb	r3, [r7, #0xf]
 8016e40: 4613         	mov	r3, r2
 8016e42: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8016e44: f107 032c    	add.w	r3, r7, #0x2c
 8016e48: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8016e4a: 7bba         	ldrb	r2, [r7, #0xe]
 8016e4c: 7bf8         	ldrb	r0, [r7, #0xf]
 8016e4e: 697b         	ldr	r3, [r7, #0x14]
 8016e50: 9303         	str	r3, [sp, #0xc]
 8016e52: 6abb         	ldr	r3, [r7, #0x28]
 8016e54: 9302         	str	r3, [sp, #0x8]
 8016e56: 6a7b         	ldr	r3, [r7, #0x24]
 8016e58: 9301         	str	r3, [sp, #0x4]
 8016e5a: 6a3b         	ldr	r3, [r7, #0x20]
 8016e5c: 9300         	str	r3, [sp]
 8016e5e: 687b         	ldr	r3, [r7, #0x4]
 8016e60: 68b9         	ldr	r1, [r7, #0x8]
 8016e62: f7eb f973    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0x14d1a
; }
 8016e66: bf00         	nop
 8016e68: 3718         	adds	r7, #0x18
 8016e6a: 46bd         	mov	sp, r7
 8016e6c: bd80         	pop	{r7, pc}

08016e6e <log_panic>:
; {
 8016e6e: b580         	push	{r7, lr}
 8016e70: af00         	add	r7, sp, #0x0
; 	z_impl_log_panic();
 8016e72: f7ea fff1    	bl	0x8001e58 <z_impl_log_panic> @ imm = #-0x1501e
; }
 8016e76: bf00         	nop
 8016e78: bd80         	pop	{r7, pc}

08016e7a <coredump>:
; {
 8016e7a: b480         	push	{r7}
 8016e7c: b085         	sub	sp, #0x14
 8016e7e: af00         	add	r7, sp, #0x0
 8016e80: 60f8         	str	r0, [r7, #0xc]
 8016e82: 60b9         	str	r1, [r7, #0x8]
 8016e84: 607a         	str	r2, [r7, #0x4]
; }
 8016e86: bf00         	nop
 8016e88: 3714         	adds	r7, #0x14
 8016e8a: 46bd         	mov	sp, r7
 8016e8c: bc80         	pop	{r7}
 8016e8e: 4770         	bx	lr

08016e90 <arch_system_halt>:
; {
 8016e90: b480         	push	{r7}
 8016e92: b087         	sub	sp, #0x1c
 8016e94: af00         	add	r7, sp, #0x0
 8016e96: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016e98: f3ef 8311    	mrs	r3, basepri
 8016e9c: 617b         	str	r3, [r7, #0x14]
;   return(result);
 8016e9e: 697b         	ldr	r3, [r7, #0x14]
; 	key = __get_BASEPRI();
 8016ea0: 613b         	str	r3, [r7, #0x10]
 8016ea2: 2310         	movs	r3, #0x10
 8016ea4: 60fb         	str	r3, [r7, #0xc]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016ea6: 68fb         	ldr	r3, [r7, #0xc]
 8016ea8: f383 8812    	msr	basepri_max, r3
; }
 8016eac: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016eae: f3bf 8f6f    	isb	sy
; }
 8016eb2: bf00         	nop
; 	for (;;) {
 8016eb4: bf00         	nop
 8016eb6: e7fd         	b	0x8016eb4 <arch_system_halt+0x24> @ imm = #-0x6

08016eb8 <K_KERNEL_STACK_BUFFER>:
; {
 8016eb8: b480         	push	{r7}
 8016eba: b083         	sub	sp, #0xc
 8016ebc: af00         	add	r7, sp, #0x0
 8016ebe: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 8016ec0: 687b         	ldr	r3, [r7, #0x4]
; }
 8016ec2: 4618         	mov	r0, r3
 8016ec4: 370c         	adds	r7, #0xc
 8016ec6: 46bd         	mov	sp, r7
 8016ec8: bc80         	pop	{r7}
 8016eca: 4770         	bx	lr

08016ecc <k_thread_start>:
; {
 8016ecc: b580         	push	{r7, lr}
 8016ece: b082         	sub	sp, #0x8
 8016ed0: af00         	add	r7, sp, #0x0
 8016ed2: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_start(thread);
 8016ed4: 6878         	ldr	r0, [r7, #0x4]
 8016ed6: f001 f8c4    	bl	0x8018062 <z_impl_k_thread_start> @ imm = #0x1188
; }
 8016eda: bf00         	nop
 8016edc: 3708         	adds	r7, #0x8
 8016ede: 46bd         	mov	sp, r7
 8016ee0: bd80         	pop	{r7, pc}

08016ee2 <thread_schedule_new>:
; {
 8016ee2: b580         	push	{r7, lr}
 8016ee4: b084         	sub	sp, #0x10
 8016ee6: af00         	add	r7, sp, #0x0
 8016ee8: 60f8         	str	r0, [r7, #0xc]
 8016eea: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 8016eee: e9d7 2300    	ldrd	r2, r3, [r7]
 8016ef2: f04f 0000    	mov.w	r0, #0x0
 8016ef6: f04f 0100    	mov.w	r1, #0x0
 8016efa: 428b         	cmp	r3, r1
 8016efc: bf08         	it	eq
 8016efe: 4282         	cmpeq	r2, r0
 8016f00: d103         	bne	0x8016f0a <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 8016f02: 68f8         	ldr	r0, [r7, #0xc]
 8016f04: f7ff ffe2    	bl	0x8016ecc <k_thread_start> @ imm = #-0x3c
 8016f08: e004         	b	0x8016f14 <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 8016f0a: e9d7 2300    	ldrd	r2, r3, [r7]
 8016f0e: 68f8         	ldr	r0, [r7, #0xc]
 8016f10: f7f4 fbb0    	bl	0x800b674 <z_add_thread_timeout> @ imm = #-0xb8a0
; }
 8016f14: bf00         	nop
 8016f16: 3710         	adds	r7, #0x10
 8016f18: 46bd         	mov	sp, r7
 8016f1a: bd80         	pop	{r7, pc}

08016f1c <z_mark_thread_as_started>:
; {
 8016f1c: b480         	push	{r7}
 8016f1e: b083         	sub	sp, #0xc
 8016f20: af00         	add	r7, sp, #0x0
 8016f22: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PRESTART;
 8016f24: 687b         	ldr	r3, [r7, #0x4]
 8016f26: 7b5b         	ldrb	r3, [r3, #0xd]
 8016f28: f023 0304    	bic	r3, r3, #0x4
 8016f2c: b2da         	uxtb	r2, r3
 8016f2e: 687b         	ldr	r3, [r7, #0x4]
 8016f30: 735a         	strb	r2, [r3, #0xd]
; }
 8016f32: bf00         	nop
 8016f34: 370c         	adds	r7, #0xc
 8016f36: 46bd         	mov	sp, r7
 8016f38: bc80         	pop	{r7}
 8016f3a: 4770         	bx	lr

08016f3c <z_thread_essential_clear>:
; {
 8016f3c: b480         	push	{r7}
 8016f3e: b083         	sub	sp, #0xc
 8016f40: af00         	add	r7, sp, #0x0
 8016f42: 6078         	str	r0, [r7, #0x4]
; 	thread->base.user_options &= ~K_ESSENTIAL;
 8016f44: 687b         	ldr	r3, [r7, #0x4]
 8016f46: 7b1b         	ldrb	r3, [r3, #0xc]
 8016f48: f023 0301    	bic	r3, r3, #0x1
 8016f4c: b2da         	uxtb	r2, r3
 8016f4e: 687b         	ldr	r3, [r7, #0x4]
 8016f50: 731a         	strb	r2, [r3, #0xc]
; }
 8016f52: bf00         	nop
 8016f54: 370c         	adds	r7, #0xc
 8016f56: 46bd         	mov	sp, r7
 8016f58: bc80         	pop	{r7}
 8016f5a: 4770         	bx	lr

08016f5c <gcov_static_init>:
; static inline void gcov_static_init(void) { }
 8016f5c: b480         	push	{r7}
 8016f5e: af00         	add	r7, sp, #0x0
 8016f60: bf00         	nop
 8016f62: 46bd         	mov	sp, r7
 8016f64: bc80         	pop	{r7}
 8016f66: 4770         	bx	lr

08016f68 <pm_device_runtime_auto_enable>:
; {
 8016f68: b480         	push	{r7}
 8016f6a: b083         	sub	sp, #0xc
 8016f6c: af00         	add	r7, sp, #0x0
 8016f6e: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8016f70: 2300         	movs	r3, #0x0
; }
 8016f72: 4618         	mov	r0, r3
 8016f74: 370c         	adds	r7, #0xc
 8016f76: 46bd         	mov	sp, r7
 8016f78: bc80         	pop	{r7}
 8016f7a: 4770         	bx	lr

08016f7c <z_early_memset>:
; {
 8016f7c: b580         	push	{r7, lr}
 8016f7e: b084         	sub	sp, #0x10
 8016f80: af00         	add	r7, sp, #0x0
 8016f82: 60f8         	str	r0, [r7, #0xc]
 8016f84: 60b9         	str	r1, [r7, #0x8]
 8016f86: 607a         	str	r2, [r7, #0x4]
; 	(void) memset(dst, c, n);
 8016f88: 687a         	ldr	r2, [r7, #0x4]
 8016f8a: 68b9         	ldr	r1, [r7, #0x8]
 8016f8c: 68f8         	ldr	r0, [r7, #0xc]
 8016f8e: f001 feda    	bl	0x8018d46 <memset>      @ imm = #0x1db4
; }
 8016f92: bf00         	nop
 8016f94: 3710         	adds	r7, #0x10
 8016f96: 46bd         	mov	sp, r7
 8016f98: bd80         	pop	{r7, pc}

08016f9a <z_early_memcpy>:
; {
 8016f9a: b580         	push	{r7, lr}
 8016f9c: b084         	sub	sp, #0x10
 8016f9e: af00         	add	r7, sp, #0x0
 8016fa0: 60f8         	str	r0, [r7, #0xc]
 8016fa2: 60b9         	str	r1, [r7, #0x8]
 8016fa4: 607a         	str	r2, [r7, #0x4]
; 	(void) memcpy(dst, src, n);
 8016fa6: 687a         	ldr	r2, [r7, #0x4]
 8016fa8: 68b9         	ldr	r1, [r7, #0x8]
 8016faa: 68f8         	ldr	r0, [r7, #0xc]
 8016fac: f001 febd    	bl	0x8018d2a <memcpy>      @ imm = #0x1d7a
; }
 8016fb0: bf00         	nop
 8016fb2: 3710         	adds	r7, #0x10
 8016fb4: 46bd         	mov	sp, r7
 8016fb6: bd80         	pop	{r7, pc}

08016fb8 <do_device_init>:
; {
 8016fb8: b580         	push	{r7, lr}
 8016fba: b084         	sub	sp, #0x10
 8016fbc: af00         	add	r7, sp, #0x0
 8016fbe: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = entry->dev;
 8016fc0: 687b         	ldr	r3, [r7, #0x4]
 8016fc2: 685b         	ldr	r3, [r3, #0x4]
 8016fc4: 60bb         	str	r3, [r7, #0x8]
; 	int rc = 0;
 8016fc6: 2300         	movs	r3, #0x0
 8016fc8: 60fb         	str	r3, [r7, #0xc]
; 	if (entry->init_fn.dev != NULL) {
 8016fca: 687b         	ldr	r3, [r7, #0x4]
 8016fcc: 681b         	ldr	r3, [r3]
 8016fce: 2b00         	cmp	r3, #0x0
 8016fd0: d017         	beq	0x8017002 <do_device_init+0x4a> @ imm = #0x2e
; 		rc = entry->init_fn.dev(dev);
 8016fd2: 687b         	ldr	r3, [r7, #0x4]
 8016fd4: 681b         	ldr	r3, [r3]
 8016fd6: 68b8         	ldr	r0, [r7, #0x8]
 8016fd8: 4798         	blx	r3
 8016fda: 60f8         	str	r0, [r7, #0xc]
; 		if (rc != 0) {
 8016fdc: 68fb         	ldr	r3, [r7, #0xc]
 8016fde: 2b00         	cmp	r3, #0x0
 8016fe0: d00f         	beq	0x8017002 <do_device_init+0x4a> @ imm = #0x1e
; 			if (rc < 0) {
 8016fe2: 68fb         	ldr	r3, [r7, #0xc]
 8016fe4: 2b00         	cmp	r3, #0x0
 8016fe6: da02         	bge	0x8016fee <do_device_init+0x36> @ imm = #0x4
; 				rc = -rc;
 8016fe8: 68fb         	ldr	r3, [r7, #0xc]
 8016fea: 425b         	rsbs	r3, r3, #0
 8016fec: 60fb         	str	r3, [r7, #0xc]
; 			if (rc > UINT8_MAX) {
 8016fee: 68fb         	ldr	r3, [r7, #0xc]
 8016ff0: 2bff         	cmp	r3, #0xff
 8016ff2: dd01         	ble	0x8016ff8 <do_device_init+0x40> @ imm = #0x2
; 				rc = UINT8_MAX;
 8016ff4: 23ff         	movs	r3, #0xff
 8016ff6: 60fb         	str	r3, [r7, #0xc]
; 			dev->state->init_res = rc;
 8016ff8: 68bb         	ldr	r3, [r7, #0x8]
 8016ffa: 68db         	ldr	r3, [r3, #0xc]
 8016ffc: 68fa         	ldr	r2, [r7, #0xc]
 8016ffe: b2d2         	uxtb	r2, r2
 8017000: 701a         	strb	r2, [r3]
; 	dev->state->initialized = true;
 8017002: 68bb         	ldr	r3, [r7, #0x8]
 8017004: 68da         	ldr	r2, [r3, #0xc]
 8017006: 7853         	ldrb	r3, [r2, #0x1]
 8017008: f043 0301    	orr	r3, r3, #0x1
 801700c: 7053         	strb	r3, [r2, #0x1]
; 	if (rc == 0) {
 801700e: 68fb         	ldr	r3, [r7, #0xc]
 8017010: 2b00         	cmp	r3, #0x0
 8017012: d102         	bne	0x801701a <do_device_init+0x62> @ imm = #0x4
; 		(void)pm_device_runtime_auto_enable(dev);
 8017014: 68b8         	ldr	r0, [r7, #0x8]
 8017016: f7ff ffa7    	bl	0x8016f68 <pm_device_runtime_auto_enable> @ imm = #-0xb2
; 	return rc;
 801701a: 68fb         	ldr	r3, [r7, #0xc]
; }
 801701c: 4618         	mov	r0, r3
 801701e: 3710         	adds	r7, #0x10
 8017020: 46bd         	mov	sp, r7
 8017022: bd80         	pop	{r7, pc}

08017024 <z_init_static>:
; {
 8017024: b480         	push	{r7}
 8017026: af00         	add	r7, sp, #0x0
; }
 8017028: bf00         	nop
 801702a: 46bd         	mov	sp, r7
 801702c: bc80         	pop	{r7}
 801702e: 4770         	bx	lr

08017030 <sys_dnode_init>:
; {
 8017030: b480         	push	{r7}
 8017032: b083         	sub	sp, #0xc
 8017034: af00         	add	r7, sp, #0x0
 8017036: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8017038: 687b         	ldr	r3, [r7, #0x4]
 801703a: 2200         	movs	r2, #0x0
 801703c: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801703e: 687b         	ldr	r3, [r7, #0x4]
 8017040: 2200         	movs	r2, #0x0
 8017042: 605a         	str	r2, [r3, #0x4]
; }
 8017044: bf00         	nop
 8017046: 370c         	adds	r7, #0xc
 8017048: 46bd         	mov	sp, r7
 801704a: bc80         	pop	{r7}
 801704c: 4770         	bx	lr

0801704e <sys_dlist_is_empty>:
; {
 801704e: b480         	push	{r7}
 8017050: b083         	sub	sp, #0xc
 8017052: af00         	add	r7, sp, #0x0
 8017054: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8017056: 687b         	ldr	r3, [r7, #0x4]
 8017058: 681b         	ldr	r3, [r3]
 801705a: 687a         	ldr	r2, [r7, #0x4]
 801705c: 429a         	cmp	r2, r3
 801705e: bf0c         	ite	eq
 8017060: 2301         	moveq	r3, #0x1
 8017062: 2300         	movne	r3, #0x0
 8017064: b2db         	uxtb	r3, r3
; }
 8017066: 4618         	mov	r0, r3
 8017068: 370c         	adds	r7, #0xc
 801706a: 46bd         	mov	sp, r7
 801706c: bc80         	pop	{r7}
 801706e: 4770         	bx	lr

08017070 <sys_dlist_peek_head>:
; {
 8017070: b580         	push	{r7, lr}
 8017072: b082         	sub	sp, #0x8
 8017074: af00         	add	r7, sp, #0x0
 8017076: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8017078: 6878         	ldr	r0, [r7, #0x4]
 801707a: f7ff ffe8    	bl	0x801704e <sys_dlist_is_empty> @ imm = #-0x30
 801707e: 4603         	mov	r3, r0
 8017080: 2b00         	cmp	r3, #0x0
 8017082: d102         	bne	0x801708a <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8017084: 687b         	ldr	r3, [r7, #0x4]
 8017086: 681b         	ldr	r3, [r3]
 8017088: e000         	b	0x801708c <sys_dlist_peek_head+0x1c> @ imm = #0x0
 801708a: 2300         	movs	r3, #0x0
; }
 801708c: 4618         	mov	r0, r3
 801708e: 3708         	adds	r7, #0x8
 8017090: 46bd         	mov	sp, r7
 8017092: bd80         	pop	{r7, pc}

08017094 <sys_dlist_remove>:
; {
 8017094: b580         	push	{r7, lr}
 8017096: b084         	sub	sp, #0x10
 8017098: af00         	add	r7, sp, #0x0
 801709a: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 801709c: 687b         	ldr	r3, [r7, #0x4]
 801709e: 685b         	ldr	r3, [r3, #0x4]
 80170a0: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 80170a2: 687b         	ldr	r3, [r7, #0x4]
 80170a4: 681b         	ldr	r3, [r3]
 80170a6: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 80170a8: 68fb         	ldr	r3, [r7, #0xc]
 80170aa: 68ba         	ldr	r2, [r7, #0x8]
 80170ac: 601a         	str	r2, [r3]
; 	next->prev = prev;
 80170ae: 68bb         	ldr	r3, [r7, #0x8]
 80170b0: 68fa         	ldr	r2, [r7, #0xc]
 80170b2: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 80170b4: 6878         	ldr	r0, [r7, #0x4]
 80170b6: f7ff ffbb    	bl	0x8017030 <sys_dnode_init> @ imm = #-0x8a
; }
 80170ba: bf00         	nop
 80170bc: 3710         	adds	r7, #0x10
 80170be: 46bd         	mov	sp, r7
 80170c0: bd80         	pop	{r7, pc}

080170c2 <k_object_init>:
; {
 80170c2: b480         	push	{r7}
 80170c4: b083         	sub	sp, #0xc
 80170c6: af00         	add	r7, sp, #0x0
 80170c8: 6078         	str	r0, [r7, #0x4]
; }
 80170ca: bf00         	nop
 80170cc: 370c         	adds	r7, #0xc
 80170ce: 46bd         	mov	sp, r7
 80170d0: bc80         	pop	{r7}
 80170d2: 4770         	bx	lr

080170d4 <z_abort_thread_timeout>:
; {
 80170d4: b580         	push	{r7, lr}
 80170d6: b082         	sub	sp, #0x8
 80170d8: af00         	add	r7, sp, #0x0
 80170da: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 80170dc: 687b         	ldr	r3, [r7, #0x4]
 80170de: 3318         	adds	r3, #0x18
 80170e0: 4618         	mov	r0, r3
 80170e2: f7f7 fccb    	bl	0x800ea7c <z_abort_timeout> @ imm = #-0x866a
 80170e6: 4603         	mov	r3, r0
; }
 80170e8: 4618         	mov	r0, r3
 80170ea: 3708         	adds	r7, #0x8
 80170ec: 46bd         	mov	sp, r7
 80170ee: bd80         	pop	{r7, pc}

080170f0 <z_mark_thread_as_not_pending>:
; {
 80170f0: b480         	push	{r7}
 80170f2: b083         	sub	sp, #0xc
 80170f4: af00         	add	r7, sp, #0x0
 80170f6: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 80170f8: 687b         	ldr	r3, [r7, #0x4]
 80170fa: 7b5b         	ldrb	r3, [r3, #0xd]
 80170fc: f023 0302    	bic	r3, r3, #0x2
 8017100: b2da         	uxtb	r2, r3
 8017102: 687b         	ldr	r3, [r7, #0x4]
 8017104: 735a         	strb	r2, [r3, #0xd]
; }
 8017106: bf00         	nop
 8017108: 370c         	adds	r7, #0xc
 801710a: 46bd         	mov	sp, r7
 801710c: bc80         	pop	{r7}
 801710e: 4770         	bx	lr

08017110 <unpend_thread_no_timeout>:
; {
 8017110: b580         	push	{r7, lr}
 8017112: b086         	sub	sp, #0x18
 8017114: af00         	add	r7, sp, #0x0
 8017116: 6078         	str	r0, [r7, #0x4]
 8017118: 687b         	ldr	r3, [r7, #0x4]
 801711a: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 801711c: 68fb         	ldr	r3, [r7, #0xc]
 801711e: 689b         	ldr	r3, [r3, #0x8]
 8017120: 617b         	str	r3, [r7, #0x14]
 8017122: 687b         	ldr	r3, [r7, #0x4]
 8017124: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8017126: 693b         	ldr	r3, [r7, #0x10]
 8017128: 4618         	mov	r0, r3
 801712a: f7ff ffb3    	bl	0x8017094 <sys_dlist_remove> @ imm = #-0x9a
; }
 801712e: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8017130: 6878         	ldr	r0, [r7, #0x4]
 8017132: f7ff ffdd    	bl	0x80170f0 <z_mark_thread_as_not_pending> @ imm = #-0x46
; 	thread->base.pended_on = NULL;
 8017136: 687b         	ldr	r3, [r7, #0x4]
 8017138: 2200         	movs	r2, #0x0
 801713a: 609a         	str	r2, [r3, #0x8]
; }
 801713c: bf00         	nop
 801713e: 3718         	adds	r7, #0x18
 8017140: 46bd         	mov	sp, r7
 8017142: bd80         	pop	{r7, pc}

08017144 <create_free_list>:
; {
 8017144: b480         	push	{r7}
 8017146: b085         	sub	sp, #0x14
 8017148: af00         	add	r7, sp, #0x0
 801714a: 6078         	str	r0, [r7, #0x4]
; 	CHECKIF(((slab->info.block_size | (uintptr_t)slab->buffer) &
 801714c: 687b         	ldr	r3, [r7, #0x4]
 801714e: 695b         	ldr	r3, [r3, #0x14]
 8017150: 687a         	ldr	r2, [r7, #0x4]
 8017152: 6892         	ldr	r2, [r2, #0x8]
 8017154: 4313         	orrs	r3, r2
 8017156: f003 0303    	and	r3, r3, #0x3
 801715a: 2b00         	cmp	r3, #0x0
 801715c: d002         	beq	0x8017164 <create_free_list+0x20> @ imm = #0x4
; 		return -EINVAL;
 801715e: f06f 0315    	mvn	r3, #0x15
 8017162: e021         	b	0x80171a8 <create_free_list+0x64> @ imm = #0x42
; 	slab->free_list = NULL;
 8017164: 687b         	ldr	r3, [r7, #0x4]
 8017166: 2200         	movs	r2, #0x0
 8017168: 60da         	str	r2, [r3, #0xc]
; 	p = slab->buffer + slab->info.block_size * (slab->info.num_blocks - 1);
 801716a: 687b         	ldr	r3, [r7, #0x4]
 801716c: 689a         	ldr	r2, [r3, #0x8]
 801716e: 687b         	ldr	r3, [r7, #0x4]
 8017170: 695b         	ldr	r3, [r3, #0x14]
 8017172: 6879         	ldr	r1, [r7, #0x4]
 8017174: 6909         	ldr	r1, [r1, #0x10]
 8017176: 3901         	subs	r1, #0x1
 8017178: fb01 f303    	mul	r3, r1, r3
 801717c: 4413         	add	r3, r2
 801717e: 60fb         	str	r3, [r7, #0xc]
; 	while (p >= slab->buffer) {
 8017180: e00c         	b	0x801719c <create_free_list+0x58> @ imm = #0x18
; 		*(char **)p = slab->free_list;
 8017182: 687b         	ldr	r3, [r7, #0x4]
 8017184: 68da         	ldr	r2, [r3, #0xc]
 8017186: 68fb         	ldr	r3, [r7, #0xc]
 8017188: 601a         	str	r2, [r3]
; 		slab->free_list = p;
 801718a: 687b         	ldr	r3, [r7, #0x4]
 801718c: 68fa         	ldr	r2, [r7, #0xc]
 801718e: 60da         	str	r2, [r3, #0xc]
; 		p -= slab->info.block_size;
 8017190: 687b         	ldr	r3, [r7, #0x4]
 8017192: 695b         	ldr	r3, [r3, #0x14]
 8017194: 425b         	rsbs	r3, r3, #0
 8017196: 68fa         	ldr	r2, [r7, #0xc]
 8017198: 4413         	add	r3, r2
 801719a: 60fb         	str	r3, [r7, #0xc]
; 	while (p >= slab->buffer) {
 801719c: 687b         	ldr	r3, [r7, #0x4]
 801719e: 689b         	ldr	r3, [r3, #0x8]
 80171a0: 68fa         	ldr	r2, [r7, #0xc]
 80171a2: 429a         	cmp	r2, r3
 80171a4: d2ed         	bhs	0x8017182 <create_free_list+0x3e> @ imm = #-0x26
; 	return 0;
 80171a6: 2300         	movs	r3, #0x0
; }
 80171a8: 4618         	mov	r0, r3
 80171aa: 3714         	adds	r7, #0x14
 80171ac: 46bd         	mov	sp, r7
 80171ae: bc80         	pop	{r7}
 80171b0: 4770         	bx	lr

080171b2 <k_mem_slab_free>:
; {
 80171b2: b580         	push	{r7, lr}
 80171b4: b09a         	sub	sp, #0x68
 80171b6: af00         	add	r7, sp, #0x0
 80171b8: 6078         	str	r0, [r7, #0x4]
 80171ba: 6039         	str	r1, [r7]
; 	k_spinlock_key_t key = k_spin_lock(&slab->lock);
 80171bc: 687b         	ldr	r3, [r7, #0x4]
 80171be: 3308         	adds	r3, #0x8
 80171c0: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80171c2: f3ef 8311    	mrs	r3, basepri
 80171c6: 65fb         	str	r3, [r7, #0x5c]
;   return(result);
 80171c8: 6dfb         	ldr	r3, [r7, #0x5c]
; 	key = __get_BASEPRI();
 80171ca: 65bb         	str	r3, [r7, #0x58]
 80171cc: 2310         	movs	r3, #0x10
 80171ce: 657b         	str	r3, [r7, #0x54]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80171d0: 6d7b         	ldr	r3, [r7, #0x54]
 80171d2: f383 8812    	msr	basepri_max, r3
; }
 80171d6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80171d8: f3bf 8f6f    	isb	sy
; }
 80171dc: bf00         	nop
; 	return key;
 80171de: 6dbb         	ldr	r3, [r7, #0x58]
; 	k.key = arch_irq_lock();
 80171e0: 60fb         	str	r3, [r7, #0xc]
 80171e2: 6e3b         	ldr	r3, [r7, #0x60]
 80171e4: 653b         	str	r3, [r7, #0x50]
; }
 80171e6: bf00         	nop
 80171e8: 6e3b         	ldr	r3, [r7, #0x60]
 80171ea: 64fb         	str	r3, [r7, #0x4c]
; }
 80171ec: bf00         	nop
; 	return k;
 80171ee: 68fb         	ldr	r3, [r7, #0xc]
 80171f0: 617b         	str	r3, [r7, #0x14]
; 	if ((slab->free_list == NULL) && IS_ENABLED(CONFIG_MULTITHREADING)) {
 80171f2: 687b         	ldr	r3, [r7, #0x4]
 80171f4: 68db         	ldr	r3, [r3, #0xc]
 80171f6: 2b00         	cmp	r3, #0x0
 80171f8: d147         	bne	0x801728a <k_mem_slab_free+0xd8> @ imm = #0x8e
; 		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
 80171fa: 687b         	ldr	r3, [r7, #0x4]
 80171fc: 64bb         	str	r3, [r7, #0x48]
; 	struct k_thread *thread = NULL;
 80171fe: 2300         	movs	r3, #0x0
 8017200: 647b         	str	r3, [r7, #0x44]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8017202: 6cbb         	ldr	r3, [r7, #0x48]
 8017204: 643b         	str	r3, [r7, #0x40]
; 	struct k_thread *thread = NULL;
 8017206: 2300         	movs	r3, #0x0
 8017208: 63fb         	str	r3, [r7, #0x3c]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 801720a: 6c38         	ldr	r0, [r7, #0x40]
 801720c: f7ff ff30    	bl	0x8017070 <sys_dlist_peek_head> @ imm = #-0x1a0
 8017210: 63b8         	str	r0, [r7, #0x38]
; 	if (n != NULL) {
 8017212: 6bbb         	ldr	r3, [r7, #0x38]
 8017214: 2b00         	cmp	r3, #0x0
 8017216: d001         	beq	0x801721c <k_mem_slab_free+0x6a> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8017218: 6bbb         	ldr	r3, [r7, #0x38]
 801721a: 63fb         	str	r3, [r7, #0x3c]
; 	return thread;
 801721c: 6bfb         	ldr	r3, [r7, #0x3c]
; 		thread = _priq_wait_best(&wait_q->waitq);
 801721e: 647b         	str	r3, [r7, #0x44]
; 		if (unlikely(thread != NULL)) {
 8017220: 6c7b         	ldr	r3, [r7, #0x44]
 8017222: 2b00         	cmp	r3, #0x0
 8017224: bf14         	ite	ne
 8017226: 2301         	movne	r3, #0x1
 8017228: 2300         	moveq	r3, #0x0
 801722a: b2db         	uxtb	r3, r3
 801722c: 2b00         	cmp	r3, #0x0
 801722e: d005         	beq	0x801723c <k_mem_slab_free+0x8a> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 8017230: 6c78         	ldr	r0, [r7, #0x44]
 8017232: f7ff ff6d    	bl	0x8017110 <unpend_thread_no_timeout> @ imm = #-0x126
; 			(void)z_abort_thread_timeout(thread);
 8017236: 6c78         	ldr	r0, [r7, #0x44]
 8017238: f7ff ff4c    	bl	0x80170d4 <z_abort_thread_timeout> @ imm = #-0x168
; 	return thread;
 801723c: 6c7b         	ldr	r3, [r7, #0x44]
; 		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
 801723e: 667b         	str	r3, [r7, #0x64]
; 		if (unlikely(pending_thread != NULL)) {
 8017240: 6e7b         	ldr	r3, [r7, #0x64]
 8017242: 2b00         	cmp	r3, #0x0
 8017244: bf14         	ite	ne
 8017246: 2301         	movne	r3, #0x1
 8017248: 2300         	moveq	r3, #0x0
 801724a: b2db         	uxtb	r3, r3
 801724c: 2b00         	cmp	r3, #0x0
 801724e: d01c         	beq	0x801728a <k_mem_slab_free+0xd8> @ imm = #0x38
 8017250: 6e7b         	ldr	r3, [r7, #0x64]
 8017252: 637b         	str	r3, [r7, #0x34]
 8017254: 2300         	movs	r3, #0x0
 8017256: 633b         	str	r3, [r7, #0x30]
 8017258: 683b         	ldr	r3, [r7]
 801725a: 62fb         	str	r3, [r7, #0x2c]
 801725c: 6b7b         	ldr	r3, [r7, #0x34]
 801725e: 62bb         	str	r3, [r7, #0x28]
 8017260: 6b3b         	ldr	r3, [r7, #0x30]
 8017262: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 8017264: 6abb         	ldr	r3, [r7, #0x28]
 8017266: 6a7a         	ldr	r2, [r7, #0x24]
 8017268: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 801726c: bf00         	nop
; 	thread->base.swap_data = data;
 801726e: 6b7b         	ldr	r3, [r7, #0x34]
 8017270: 6afa         	ldr	r2, [r7, #0x2c]
 8017272: 615a         	str	r2, [r3, #0x14]
; }
 8017274: bf00         	nop
; 			z_ready_thread(pending_thread);
 8017276: 6e78         	ldr	r0, [r7, #0x64]
 8017278: f7f5 ffe0    	bl	0x800d23c <z_ready_thread> @ imm = #-0xa040
; 			z_reschedule(&slab->lock, key);
 801727c: 687b         	ldr	r3, [r7, #0x4]
 801727e: 3308         	adds	r3, #0x8
 8017280: 6979         	ldr	r1, [r7, #0x14]
 8017282: 4618         	mov	r0, r3
 8017284: f001 fad1    	bl	0x801882a <z_reschedule> @ imm = #0x15a2
 8017288: e01d         	b	0x80172c6 <k_mem_slab_free+0x114> @ imm = #0x3a
; 	*(char **) mem = slab->free_list;
 801728a: 687b         	ldr	r3, [r7, #0x4]
 801728c: 68da         	ldr	r2, [r3, #0xc]
 801728e: 683b         	ldr	r3, [r7]
 8017290: 601a         	str	r2, [r3]
; 	slab->free_list = (char *) mem;
 8017292: 687b         	ldr	r3, [r7, #0x4]
 8017294: 683a         	ldr	r2, [r7]
 8017296: 60da         	str	r2, [r3, #0xc]
; 	slab->info.num_used--;
 8017298: 687b         	ldr	r3, [r7, #0x4]
 801729a: 699b         	ldr	r3, [r3, #0x18]
 801729c: 1e5a         	subs	r2, r3, #0x1
 801729e: 687b         	ldr	r3, [r7, #0x4]
 80172a0: 619a         	str	r2, [r3, #0x18]
; 	k_spin_unlock(&slab->lock, key);
 80172a2: 687b         	ldr	r3, [r7, #0x4]
 80172a4: 3308         	adds	r3, #0x8
 80172a6: 623b         	str	r3, [r7, #0x20]
 80172a8: 697b         	ldr	r3, [r7, #0x14]
 80172aa: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 80172ac: 693b         	ldr	r3, [r7, #0x10]
 80172ae: 61fb         	str	r3, [r7, #0x1c]
 80172b0: 69fb         	ldr	r3, [r7, #0x1c]
 80172b2: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80172b4: 69bb         	ldr	r3, [r7, #0x18]
 80172b6: f383 8811    	msr	basepri, r3
; }
 80172ba: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80172bc: f3bf 8f6f    	isb	sy
; }
 80172c0: bf00         	nop
; }
 80172c2: bf00         	nop
; }
 80172c4: bf00         	nop
; }
 80172c6: 3768         	adds	r7, #0x68
 80172c8: 46bd         	mov	sp, r7
 80172ca: bd80         	pop	{r7, pc}

080172cc <k_cpu_idle>:
; {
 80172cc: b580         	push	{r7, lr}
 80172ce: af00         	add	r7, sp, #0x0
; 	arch_cpu_idle();
 80172d0: f7fa fc38    	bl	0x8011b44 <arch_cpu_idle> @ imm = #-0x5790
; }
 80172d4: bf00         	nop
 80172d6: bd80         	pop	{r7, pc}

080172d8 <idle>:
; {
 80172d8: b580         	push	{r7, lr}
 80172da: b088         	sub	sp, #0x20
 80172dc: af00         	add	r7, sp, #0x0
 80172de: 60f8         	str	r0, [r7, #0xc]
 80172e0: 60b9         	str	r1, [r7, #0x8]
 80172e2: 607a         	str	r2, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80172e4: f3ef 8311    	mrs	r3, basepri
 80172e8: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 80172ea: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 80172ec: 61bb         	str	r3, [r7, #0x18]
 80172ee: 2310         	movs	r3, #0x10
 80172f0: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80172f2: 697b         	ldr	r3, [r7, #0x14]
 80172f4: f383 8812    	msr	basepri_max, r3
; }
 80172f8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80172fa: f3bf 8f6f    	isb	sy
; }
 80172fe: bf00         	nop
; 	return key;
 8017300: bf00         	nop
; 		k_cpu_idle();
 8017302: f7ff ffe3    	bl	0x80172cc <k_cpu_idle>  @ imm = #-0x3a
; 		if (IS_ENABLED(CONFIG_SMP) && !IS_ENABLED(CONFIG_SCHED_IPI_SUPPORTED)) {
 8017306: e7ed         	b	0x80172e4 <idle+0xc>    @ imm = #-0x26

08017308 <arch_spin_relax>:
; {
 8017308: b480         	push	{r7}
 801730a: af00         	add	r7, sp, #0x0
; 	__asm__ volatile("nop");
 801730c: bf00         	nop
; }
 801730e: bf00         	nop
; }
 8017310: bf00         	nop
 8017312: 46bd         	mov	sp, r7
 8017314: bc80         	pop	{r7}
 8017316: 4770         	bx	lr

08017318 <sys_dlist_init>:
; {
 8017318: b480         	push	{r7}
 801731a: b083         	sub	sp, #0xc
 801731c: af00         	add	r7, sp, #0x0
 801731e: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8017320: 687b         	ldr	r3, [r7, #0x4]
 8017322: 687a         	ldr	r2, [r7, #0x4]
 8017324: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8017326: 687b         	ldr	r3, [r7, #0x4]
 8017328: 687a         	ldr	r2, [r7, #0x4]
 801732a: 605a         	str	r2, [r3, #0x4]
; }
 801732c: bf00         	nop
 801732e: 370c         	adds	r7, #0xc
 8017330: 46bd         	mov	sp, r7
 8017332: bc80         	pop	{r7}
 8017334: 4770         	bx	lr

08017336 <sys_dnode_init>:
; {
 8017336: b480         	push	{r7}
 8017338: b083         	sub	sp, #0xc
 801733a: af00         	add	r7, sp, #0x0
 801733c: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801733e: 687b         	ldr	r3, [r7, #0x4]
 8017340: 2200         	movs	r2, #0x0
 8017342: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8017344: 687b         	ldr	r3, [r7, #0x4]
 8017346: 2200         	movs	r2, #0x0
 8017348: 605a         	str	r2, [r3, #0x4]
; }
 801734a: bf00         	nop
 801734c: 370c         	adds	r7, #0xc
 801734e: 46bd         	mov	sp, r7
 8017350: bc80         	pop	{r7}
 8017352: 4770         	bx	lr

08017354 <sys_dnode_is_linked>:
; {
 8017354: b480         	push	{r7}
 8017356: b083         	sub	sp, #0xc
 8017358: af00         	add	r7, sp, #0x0
 801735a: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 801735c: 687b         	ldr	r3, [r7, #0x4]
 801735e: 681b         	ldr	r3, [r3]
 8017360: 2b00         	cmp	r3, #0x0
 8017362: bf14         	ite	ne
 8017364: 2301         	movne	r3, #0x1
 8017366: 2300         	moveq	r3, #0x0
 8017368: b2db         	uxtb	r3, r3
; }
 801736a: 4618         	mov	r0, r3
 801736c: 370c         	adds	r7, #0xc
 801736e: 46bd         	mov	sp, r7
 8017370: bc80         	pop	{r7}
 8017372: 4770         	bx	lr

08017374 <sys_dlist_is_empty>:
; {
 8017374: b480         	push	{r7}
 8017376: b083         	sub	sp, #0xc
 8017378: af00         	add	r7, sp, #0x0
 801737a: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 801737c: 687b         	ldr	r3, [r7, #0x4]
 801737e: 681b         	ldr	r3, [r3]
 8017380: 687a         	ldr	r2, [r7, #0x4]
 8017382: 429a         	cmp	r2, r3
 8017384: bf0c         	ite	eq
 8017386: 2301         	moveq	r3, #0x1
 8017388: 2300         	movne	r3, #0x0
 801738a: b2db         	uxtb	r3, r3
; }
 801738c: 4618         	mov	r0, r3
 801738e: 370c         	adds	r7, #0xc
 8017390: 46bd         	mov	sp, r7
 8017392: bc80         	pop	{r7}
 8017394: 4770         	bx	lr

08017396 <sys_dlist_peek_head>:
; {
 8017396: b580         	push	{r7, lr}
 8017398: b082         	sub	sp, #0x8
 801739a: af00         	add	r7, sp, #0x0
 801739c: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 801739e: 6878         	ldr	r0, [r7, #0x4]
 80173a0: f7ff ffe8    	bl	0x8017374 <sys_dlist_is_empty> @ imm = #-0x30
 80173a4: 4603         	mov	r3, r0
 80173a6: 2b00         	cmp	r3, #0x0
 80173a8: d102         	bne	0x80173b0 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 80173aa: 687b         	ldr	r3, [r7, #0x4]
 80173ac: 681b         	ldr	r3, [r3]
 80173ae: e000         	b	0x80173b2 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 80173b0: 2300         	movs	r3, #0x0
; }
 80173b2: 4618         	mov	r0, r3
 80173b4: 3708         	adds	r7, #0x8
 80173b6: 46bd         	mov	sp, r7
 80173b8: bd80         	pop	{r7, pc}

080173ba <sys_dlist_remove>:
; {
 80173ba: b580         	push	{r7, lr}
 80173bc: b084         	sub	sp, #0x10
 80173be: af00         	add	r7, sp, #0x0
 80173c0: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 80173c2: 687b         	ldr	r3, [r7, #0x4]
 80173c4: 685b         	ldr	r3, [r3, #0x4]
 80173c6: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 80173c8: 687b         	ldr	r3, [r7, #0x4]
 80173ca: 681b         	ldr	r3, [r3]
 80173cc: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 80173ce: 68fb         	ldr	r3, [r7, #0xc]
 80173d0: 68ba         	ldr	r2, [r7, #0x8]
 80173d2: 601a         	str	r2, [r3]
; 	next->prev = prev;
 80173d4: 68bb         	ldr	r3, [r7, #0x8]
 80173d6: 68fa         	ldr	r2, [r7, #0xc]
 80173d8: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 80173da: 6878         	ldr	r0, [r7, #0x4]
 80173dc: f7ff ffab    	bl	0x8017336 <sys_dnode_init> @ imm = #-0xaa
; }
 80173e0: bf00         	nop
 80173e2: 3710         	adds	r7, #0x10
 80173e4: 46bd         	mov	sp, r7
 80173e6: bd80         	pop	{r7, pc}

080173e8 <k_object_init>:
; {
 80173e8: b480         	push	{r7}
 80173ea: b083         	sub	sp, #0xc
 80173ec: af00         	add	r7, sp, #0x0
 80173ee: 6078         	str	r0, [r7, #0x4]
; }
 80173f0: bf00         	nop
 80173f2: 370c         	adds	r7, #0xc
 80173f4: 46bd         	mov	sp, r7
 80173f6: bc80         	pop	{r7}
 80173f8: 4770         	bx	lr

080173fa <z_is_inactive_timeout>:
; {
 80173fa: b580         	push	{r7, lr}
 80173fc: b082         	sub	sp, #0x8
 80173fe: af00         	add	r7, sp, #0x0
 8017400: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 8017402: 687b         	ldr	r3, [r7, #0x4]
 8017404: 4618         	mov	r0, r3
 8017406: f7ff ffa5    	bl	0x8017354 <sys_dnode_is_linked> @ imm = #-0xb6
 801740a: 4603         	mov	r3, r0
 801740c: 2b00         	cmp	r3, #0x0
 801740e: bf14         	ite	ne
 8017410: 2301         	movne	r3, #0x1
 8017412: 2300         	moveq	r3, #0x0
 8017414: b2db         	uxtb	r3, r3
 8017416: f083 0301    	eor	r3, r3, #0x1
 801741a: b2db         	uxtb	r3, r3
 801741c: f003 0301    	and	r3, r3, #0x1
 8017420: b2db         	uxtb	r3, r3
; }
 8017422: 4618         	mov	r0, r3
 8017424: 3708         	adds	r7, #0x8
 8017426: 46bd         	mov	sp, r7
 8017428: bd80         	pop	{r7, pc}

0801742a <z_abort_thread_timeout>:
; {
 801742a: b580         	push	{r7, lr}
 801742c: b082         	sub	sp, #0x8
 801742e: af00         	add	r7, sp, #0x0
 8017430: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8017432: 687b         	ldr	r3, [r7, #0x4]
 8017434: 3318         	adds	r3, #0x18
 8017436: 4618         	mov	r0, r3
 8017438: f7f7 fb20    	bl	0x800ea7c <z_abort_timeout> @ imm = #-0x89c0
 801743c: 4603         	mov	r3, r0
; }
 801743e: 4618         	mov	r0, r3
 8017440: 3708         	adds	r7, #0x8
 8017442: 46bd         	mov	sp, r7
 8017444: bd80         	pop	{r7, pc}

08017446 <z_is_thread_prevented_from_running>:
; {
 8017446: b480         	push	{r7}
 8017448: b085         	sub	sp, #0x14
 801744a: af00         	add	r7, sp, #0x0
 801744c: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 801744e: 687b         	ldr	r3, [r7, #0x4]
 8017450: 7b5b         	ldrb	r3, [r3, #0xd]
 8017452: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
 8017454: 7bfb         	ldrb	r3, [r7, #0xf]
 8017456: f003 031f    	and	r3, r3, #0x1f
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 801745a: 2b00         	cmp	r3, #0x0
 801745c: bf14         	ite	ne
 801745e: 2301         	movne	r3, #0x1
 8017460: 2300         	moveq	r3, #0x0
 8017462: b2db         	uxtb	r3, r3
; }
 8017464: 4618         	mov	r0, r3
 8017466: 3714         	adds	r7, #0x14
 8017468: 46bd         	mov	sp, r7
 801746a: bc80         	pop	{r7}
 801746c: 4770         	bx	lr

0801746e <z_is_thread_timeout_active>:
; {
 801746e: b580         	push	{r7, lr}
 8017470: b082         	sub	sp, #0x8
 8017472: af00         	add	r7, sp, #0x0
 8017474: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 8017476: 687b         	ldr	r3, [r7, #0x4]
 8017478: 3318         	adds	r3, #0x18
 801747a: 4618         	mov	r0, r3
 801747c: f7ff ffbd    	bl	0x80173fa <z_is_inactive_timeout> @ imm = #-0x86
 8017480: 4603         	mov	r3, r0
 8017482: 2b00         	cmp	r3, #0x0
 8017484: bf14         	ite	ne
 8017486: 2301         	movne	r3, #0x1
 8017488: 2300         	moveq	r3, #0x0
 801748a: b2db         	uxtb	r3, r3
 801748c: f083 0301    	eor	r3, r3, #0x1
 8017490: b2db         	uxtb	r3, r3
 8017492: f003 0301    	and	r3, r3, #0x1
 8017496: b2db         	uxtb	r3, r3
; }
 8017498: 4618         	mov	r0, r3
 801749a: 3708         	adds	r7, #0x8
 801749c: 46bd         	mov	sp, r7
 801749e: bd80         	pop	{r7, pc}

080174a0 <z_is_thread_ready>:
; {
 80174a0: b580         	push	{r7, lr}
 80174a2: b082         	sub	sp, #0x8
 80174a4: af00         	add	r7, sp, #0x0
 80174a6: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 80174a8: 6878         	ldr	r0, [r7, #0x4]
 80174aa: f7ff ffcc    	bl	0x8017446 <z_is_thread_prevented_from_running> @ imm = #-0x68
 80174ae: 4603         	mov	r3, r0
 80174b0: f083 0301    	eor	r3, r3, #0x1
 80174b4: b2db         	uxtb	r3, r3
 80174b6: 2b00         	cmp	r3, #0x0
 80174b8: d00a         	beq	0x80174d0 <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 80174ba: 6878         	ldr	r0, [r7, #0x4]
 80174bc: f7ff ffd7    	bl	0x801746e <z_is_thread_timeout_active> @ imm = #-0x52
 80174c0: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 80174c2: f083 0301    	eor	r3, r3, #0x1
 80174c6: b2db         	uxtb	r3, r3
 80174c8: 2b00         	cmp	r3, #0x0
 80174ca: d001         	beq	0x80174d0 <z_is_thread_ready+0x30> @ imm = #0x2
 80174cc: 2301         	movs	r3, #0x1
 80174ce: e000         	b	0x80174d2 <z_is_thread_ready+0x32> @ imm = #0x0
 80174d0: 2300         	movs	r3, #0x0
 80174d2: f003 0301    	and	r3, r3, #0x1
 80174d6: b2db         	uxtb	r3, r3
; }
 80174d8: 4618         	mov	r0, r3
 80174da: 3708         	adds	r7, #0x8
 80174dc: 46bd         	mov	sp, r7
 80174de: bd80         	pop	{r7, pc}

080174e0 <z_mark_thread_as_not_pending>:
; {
 80174e0: b480         	push	{r7}
 80174e2: b083         	sub	sp, #0xc
 80174e4: af00         	add	r7, sp, #0x0
 80174e6: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 80174e8: 687b         	ldr	r3, [r7, #0x4]
 80174ea: 7b5b         	ldrb	r3, [r3, #0xd]
 80174ec: f023 0302    	bic	r3, r3, #0x2
 80174f0: b2da         	uxtb	r2, r3
 80174f2: 687b         	ldr	r3, [r7, #0x4]
 80174f4: 735a         	strb	r2, [r3, #0xd]
; }
 80174f6: bf00         	nop
 80174f8: 370c         	adds	r7, #0xc
 80174fa: 46bd         	mov	sp, r7
 80174fc: bc80         	pop	{r7}
 80174fe: 4770         	bx	lr

08017500 <z_is_under_prio_ceiling>:
; {
 8017500: b480         	push	{r7}
 8017502: b083         	sub	sp, #0xc
 8017504: af00         	add	r7, sp, #0x0
 8017506: 6078         	str	r0, [r7, #0x4]
; 	return prio >= CONFIG_PRIORITY_CEILING;
 8017508: 687b         	ldr	r3, [r7, #0x4]
 801750a: f113 0f7f    	cmn.w	r3, #0x7f
 801750e: bfac         	ite	ge
 8017510: 2301         	movge	r3, #0x1
 8017512: 2300         	movlt	r3, #0x0
 8017514: b2db         	uxtb	r3, r3
; }
 8017516: 4618         	mov	r0, r3
 8017518: 370c         	adds	r7, #0xc
 801751a: 46bd         	mov	sp, r7
 801751c: bc80         	pop	{r7}
 801751e: 4770         	bx	lr

08017520 <z_get_new_prio_with_ceiling>:
; {
 8017520: b580         	push	{r7, lr}
 8017522: b082         	sub	sp, #0x8
 8017524: af00         	add	r7, sp, #0x0
 8017526: 6078         	str	r0, [r7, #0x4]
; 	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
 8017528: 6878         	ldr	r0, [r7, #0x4]
 801752a: f7ff ffe9    	bl	0x8017500 <z_is_under_prio_ceiling> @ imm = #-0x2e
 801752e: 4603         	mov	r3, r0
 8017530: 2b00         	cmp	r3, #0x0
 8017532: d001         	beq	0x8017538 <z_get_new_prio_with_ceiling+0x18> @ imm = #0x2
 8017534: 687b         	ldr	r3, [r7, #0x4]
 8017536: e001         	b	0x801753c <z_get_new_prio_with_ceiling+0x1c> @ imm = #0x2
 8017538: f06f 037e    	mvn	r3, #0x7e
; }
 801753c: 4618         	mov	r0, r3
 801753e: 3708         	adds	r7, #0x8
 8017540: 46bd         	mov	sp, r7
 8017542: bd80         	pop	{r7, pc}

08017544 <z_is_prio1_higher_than_prio2>:
; {
 8017544: b480         	push	{r7}
 8017546: b083         	sub	sp, #0xc
 8017548: af00         	add	r7, sp, #0x0
 801754a: 6078         	str	r0, [r7, #0x4]
 801754c: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 801754e: 687a         	ldr	r2, [r7, #0x4]
 8017550: 683b         	ldr	r3, [r7]
 8017552: 429a         	cmp	r2, r3
 8017554: bfb4         	ite	lt
 8017556: 2301         	movlt	r3, #0x1
 8017558: 2300         	movge	r3, #0x0
 801755a: b2db         	uxtb	r3, r3
; }
 801755c: 4618         	mov	r0, r3
 801755e: 370c         	adds	r7, #0xc
 8017560: 46bd         	mov	sp, r7
 8017562: bc80         	pop	{r7}
 8017564: 4770         	bx	lr

08017566 <z_is_prio_higher>:
; {
 8017566: b580         	push	{r7, lr}
 8017568: b082         	sub	sp, #0x8
 801756a: af00         	add	r7, sp, #0x0
 801756c: 6078         	str	r0, [r7, #0x4]
 801756e: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 8017570: 6839         	ldr	r1, [r7]
 8017572: 6878         	ldr	r0, [r7, #0x4]
 8017574: f7ff ffe6    	bl	0x8017544 <z_is_prio1_higher_than_prio2> @ imm = #-0x34
 8017578: 4603         	mov	r3, r0
; }
 801757a: 4618         	mov	r0, r3
 801757c: 3708         	adds	r7, #0x8
 801757e: 46bd         	mov	sp, r7
 8017580: bd80         	pop	{r7, pc}

08017582 <unpend_thread_no_timeout>:
; {
 8017582: b580         	push	{r7, lr}
 8017584: b086         	sub	sp, #0x18
 8017586: af00         	add	r7, sp, #0x0
 8017588: 6078         	str	r0, [r7, #0x4]
 801758a: 687b         	ldr	r3, [r7, #0x4]
 801758c: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 801758e: 68fb         	ldr	r3, [r7, #0xc]
 8017590: 689b         	ldr	r3, [r3, #0x8]
 8017592: 617b         	str	r3, [r7, #0x14]
 8017594: 687b         	ldr	r3, [r7, #0x4]
 8017596: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8017598: 693b         	ldr	r3, [r7, #0x10]
 801759a: 4618         	mov	r0, r3
 801759c: f7ff ff0d    	bl	0x80173ba <sys_dlist_remove> @ imm = #-0x1e6
; }
 80175a0: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 80175a2: 6878         	ldr	r0, [r7, #0x4]
 80175a4: f7ff ff9c    	bl	0x80174e0 <z_mark_thread_as_not_pending> @ imm = #-0xc8
; 	thread->base.pended_on = NULL;
 80175a8: 687b         	ldr	r3, [r7, #0x4]
 80175aa: 2200         	movs	r2, #0x0
 80175ac: 609a         	str	r2, [r3, #0x8]
; }
 80175ae: bf00         	nop
 80175b0: 3718         	adds	r7, #0x18
 80175b2: 46bd         	mov	sp, r7
 80175b4: bd80         	pop	{r7, pc}

080175b6 <z_waitq_init>:
; {
 80175b6: b580         	push	{r7, lr}
 80175b8: b082         	sub	sp, #0x8
 80175ba: af00         	add	r7, sp, #0x0
 80175bc: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 80175be: 687b         	ldr	r3, [r7, #0x4]
 80175c0: 4618         	mov	r0, r3
 80175c2: f7ff fea9    	bl	0x8017318 <sys_dlist_init> @ imm = #-0x2ae
; }
 80175c6: bf00         	nop
 80175c8: 3708         	adds	r7, #0x8
 80175ca: 46bd         	mov	sp, r7
 80175cc: bd80         	pop	{r7, pc}

080175ce <z_waitq_head>:
; {
 80175ce: b580         	push	{r7, lr}
 80175d0: b082         	sub	sp, #0x8
 80175d2: af00         	add	r7, sp, #0x0
 80175d4: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 80175d6: 687b         	ldr	r3, [r7, #0x4]
 80175d8: 4618         	mov	r0, r3
 80175da: f7ff fedc    	bl	0x8017396 <sys_dlist_peek_head> @ imm = #-0x248
 80175de: 4603         	mov	r3, r0
; }
 80175e0: 4618         	mov	r0, r3
 80175e2: 3708         	adds	r7, #0x8
 80175e4: 46bd         	mov	sp, r7
 80175e6: bd80         	pop	{r7, pc}

080175e8 <z_log_msg_runtime_create>:
; {
 80175e8: b580         	push	{r7, lr}
 80175ea: b08a         	sub	sp, #0x28
 80175ec: af04         	add	r7, sp, #0x10
 80175ee: 60b9         	str	r1, [r7, #0x8]
 80175f0: 607b         	str	r3, [r7, #0x4]
 80175f2: 4603         	mov	r3, r0
 80175f4: 73fb         	strb	r3, [r7, #0xf]
 80175f6: 4613         	mov	r3, r2
 80175f8: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80175fa: f107 032c    	add.w	r3, r7, #0x2c
 80175fe: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8017600: 7bba         	ldrb	r2, [r7, #0xe]
 8017602: 7bf8         	ldrb	r0, [r7, #0xf]
 8017604: 697b         	ldr	r3, [r7, #0x14]
 8017606: 9303         	str	r3, [sp, #0xc]
 8017608: 6abb         	ldr	r3, [r7, #0x28]
 801760a: 9302         	str	r3, [sp, #0x8]
 801760c: 6a7b         	ldr	r3, [r7, #0x24]
 801760e: 9301         	str	r3, [sp, #0x4]
 8017610: 6a3b         	ldr	r3, [r7, #0x20]
 8017612: 9300         	str	r3, [sp]
 8017614: 687b         	ldr	r3, [r7, #0x4]
 8017616: 68b9         	ldr	r1, [r7, #0x8]
 8017618: f7ea fd98    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0x154d0
; }
 801761c: bf00         	nop
 801761e: 3718         	adds	r7, #0x18
 8017620: 46bd         	mov	sp, r7
 8017622: bd80         	pop	{r7, pc}

08017624 <z_impl_k_mutex_init>:
; {
 8017624: b580         	push	{r7, lr}
 8017626: b082         	sub	sp, #0x8
 8017628: af00         	add	r7, sp, #0x0
 801762a: 6078         	str	r0, [r7, #0x4]
; 	mutex->owner = NULL;
 801762c: 687b         	ldr	r3, [r7, #0x4]
 801762e: 2200         	movs	r2, #0x0
 8017630: 609a         	str	r2, [r3, #0x8]
; 	mutex->lock_count = 0U;
 8017632: 687b         	ldr	r3, [r7, #0x4]
 8017634: 2200         	movs	r2, #0x0
 8017636: 60da         	str	r2, [r3, #0xc]
; 	z_waitq_init(&mutex->wait_q);
 8017638: 687b         	ldr	r3, [r7, #0x4]
 801763a: 4618         	mov	r0, r3
 801763c: f7ff ffbb    	bl	0x80175b6 <z_waitq_init> @ imm = #-0x8a
; 	k_object_init(mutex);
 8017640: 6878         	ldr	r0, [r7, #0x4]
 8017642: f7ff fed1    	bl	0x80173e8 <k_object_init> @ imm = #-0x25e
; 	return 0;
 8017646: 2300         	movs	r3, #0x0
; }
 8017648: 4618         	mov	r0, r3
 801764a: 3708         	adds	r7, #0x8
 801764c: 46bd         	mov	sp, r7
 801764e: bd80         	pop	{r7, pc}

08017650 <new_prio_for_inheritance>:
; {
 8017650: b580         	push	{r7, lr}
 8017652: b084         	sub	sp, #0x10
 8017654: af00         	add	r7, sp, #0x0
 8017656: 6078         	str	r0, [r7, #0x4]
 8017658: 6039         	str	r1, [r7]
; 	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
 801765a: 6839         	ldr	r1, [r7]
 801765c: 6878         	ldr	r0, [r7, #0x4]
 801765e: f7ff ff82    	bl	0x8017566 <z_is_prio_higher> @ imm = #-0xfc
 8017662: 4603         	mov	r3, r0
 8017664: 2b00         	cmp	r3, #0x0
 8017666: d001         	beq	0x801766c <new_prio_for_inheritance+0x1c> @ imm = #0x2
 8017668: 687b         	ldr	r3, [r7, #0x4]
 801766a: e000         	b	0x801766e <new_prio_for_inheritance+0x1e> @ imm = #0x0
 801766c: 683b         	ldr	r3, [r7]
 801766e: 60fb         	str	r3, [r7, #0xc]
; 	new_prio = z_get_new_prio_with_ceiling(new_prio);
 8017670: 68f8         	ldr	r0, [r7, #0xc]
 8017672: f7ff ff55    	bl	0x8017520 <z_get_new_prio_with_ceiling> @ imm = #-0x156
 8017676: 60f8         	str	r0, [r7, #0xc]
; 	return new_prio;
 8017678: 68fb         	ldr	r3, [r7, #0xc]
; }
 801767a: 4618         	mov	r0, r3
 801767c: 3710         	adds	r7, #0x10
 801767e: 46bd         	mov	sp, r7
 8017680: bd80         	pop	{r7, pc}

08017682 <sys_dlist_init>:
; {
 8017682: b480         	push	{r7}
 8017684: b083         	sub	sp, #0xc
 8017686: af00         	add	r7, sp, #0x0
 8017688: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 801768a: 687b         	ldr	r3, [r7, #0x4]
 801768c: 687a         	ldr	r2, [r7, #0x4]
 801768e: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8017690: 687b         	ldr	r3, [r7, #0x4]
 8017692: 687a         	ldr	r2, [r7, #0x4]
 8017694: 605a         	str	r2, [r3, #0x4]
; }
 8017696: bf00         	nop
 8017698: 370c         	adds	r7, #0xc
 801769a: 46bd         	mov	sp, r7
 801769c: bc80         	pop	{r7}
 801769e: 4770         	bx	lr

080176a0 <sys_dnode_init>:
; {
 80176a0: b480         	push	{r7}
 80176a2: b083         	sub	sp, #0xc
 80176a4: af00         	add	r7, sp, #0x0
 80176a6: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 80176a8: 687b         	ldr	r3, [r7, #0x4]
 80176aa: 2200         	movs	r2, #0x0
 80176ac: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 80176ae: 687b         	ldr	r3, [r7, #0x4]
 80176b0: 2200         	movs	r2, #0x0
 80176b2: 605a         	str	r2, [r3, #0x4]
; }
 80176b4: bf00         	nop
 80176b6: 370c         	adds	r7, #0xc
 80176b8: 46bd         	mov	sp, r7
 80176ba: bc80         	pop	{r7}
 80176bc: 4770         	bx	lr

080176be <sys_dlist_is_empty>:
; {
 80176be: b480         	push	{r7}
 80176c0: b083         	sub	sp, #0xc
 80176c2: af00         	add	r7, sp, #0x0
 80176c4: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 80176c6: 687b         	ldr	r3, [r7, #0x4]
 80176c8: 681b         	ldr	r3, [r3]
 80176ca: 687a         	ldr	r2, [r7, #0x4]
 80176cc: 429a         	cmp	r2, r3
 80176ce: bf0c         	ite	eq
 80176d0: 2301         	moveq	r3, #0x1
 80176d2: 2300         	movne	r3, #0x0
 80176d4: b2db         	uxtb	r3, r3
; }
 80176d6: 4618         	mov	r0, r3
 80176d8: 370c         	adds	r7, #0xc
 80176da: 46bd         	mov	sp, r7
 80176dc: bc80         	pop	{r7}
 80176de: 4770         	bx	lr

080176e0 <sys_dlist_peek_head>:
; {
 80176e0: b580         	push	{r7, lr}
 80176e2: b082         	sub	sp, #0x8
 80176e4: af00         	add	r7, sp, #0x0
 80176e6: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 80176e8: 6878         	ldr	r0, [r7, #0x4]
 80176ea: f7ff ffe8    	bl	0x80176be <sys_dlist_is_empty> @ imm = #-0x30
 80176ee: 4603         	mov	r3, r0
 80176f0: 2b00         	cmp	r3, #0x0
 80176f2: d102         	bne	0x80176fa <sys_dlist_peek_head+0x1a> @ imm = #0x4
 80176f4: 687b         	ldr	r3, [r7, #0x4]
 80176f6: 681b         	ldr	r3, [r3]
 80176f8: e000         	b	0x80176fc <sys_dlist_peek_head+0x1c> @ imm = #0x0
 80176fa: 2300         	movs	r3, #0x0
; }
 80176fc: 4618         	mov	r0, r3
 80176fe: 3708         	adds	r7, #0x8
 8017700: 46bd         	mov	sp, r7
 8017702: bd80         	pop	{r7, pc}

08017704 <sys_dlist_remove>:
; {
 8017704: b580         	push	{r7, lr}
 8017706: b084         	sub	sp, #0x10
 8017708: af00         	add	r7, sp, #0x0
 801770a: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 801770c: 687b         	ldr	r3, [r7, #0x4]
 801770e: 685b         	ldr	r3, [r3, #0x4]
 8017710: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8017712: 687b         	ldr	r3, [r7, #0x4]
 8017714: 681b         	ldr	r3, [r3]
 8017716: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8017718: 68fb         	ldr	r3, [r7, #0xc]
 801771a: 68ba         	ldr	r2, [r7, #0x8]
 801771c: 601a         	str	r2, [r3]
; 	next->prev = prev;
 801771e: 68bb         	ldr	r3, [r7, #0x8]
 8017720: 68fa         	ldr	r2, [r7, #0xc]
 8017722: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8017724: 6878         	ldr	r0, [r7, #0x4]
 8017726: f7ff ffbb    	bl	0x80176a0 <sys_dnode_init> @ imm = #-0x8a
; }
 801772a: bf00         	nop
 801772c: 3710         	adds	r7, #0x10
 801772e: 46bd         	mov	sp, r7
 8017730: bd80         	pop	{r7, pc}

08017732 <k_object_init>:
; {
 8017732: b480         	push	{r7}
 8017734: b083         	sub	sp, #0xc
 8017736: af00         	add	r7, sp, #0x0
 8017738: 6078         	str	r0, [r7, #0x4]
; }
 801773a: bf00         	nop
 801773c: 370c         	adds	r7, #0xc
 801773e: 46bd         	mov	sp, r7
 8017740: bc80         	pop	{r7}
 8017742: 4770         	bx	lr

08017744 <z_abort_thread_timeout>:
; {
 8017744: b580         	push	{r7, lr}
 8017746: b082         	sub	sp, #0x8
 8017748: af00         	add	r7, sp, #0x0
 801774a: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 801774c: 687b         	ldr	r3, [r7, #0x4]
 801774e: 3318         	adds	r3, #0x18
 8017750: 4618         	mov	r0, r3
 8017752: f7f7 f993    	bl	0x800ea7c <z_abort_timeout> @ imm = #-0x8cda
 8017756: 4603         	mov	r3, r0
; }
 8017758: 4618         	mov	r0, r3
 801775a: 3708         	adds	r7, #0x8
 801775c: 46bd         	mov	sp, r7
 801775e: bd80         	pop	{r7, pc}

08017760 <z_waitq_init>:
; {
 8017760: b580         	push	{r7, lr}
 8017762: b082         	sub	sp, #0x8
 8017764: af00         	add	r7, sp, #0x0
 8017766: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8017768: 687b         	ldr	r3, [r7, #0x4]
 801776a: 4618         	mov	r0, r3
 801776c: f7ff ff89    	bl	0x8017682 <sys_dlist_init> @ imm = #-0xee
; }
 8017770: bf00         	nop
 8017772: 3708         	adds	r7, #0x8
 8017774: 46bd         	mov	sp, r7
 8017776: bd80         	pop	{r7, pc}

08017778 <z_mark_thread_as_not_pending>:
; {
 8017778: b480         	push	{r7}
 801777a: b083         	sub	sp, #0xc
 801777c: af00         	add	r7, sp, #0x0
 801777e: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8017780: 687b         	ldr	r3, [r7, #0x4]
 8017782: 7b5b         	ldrb	r3, [r3, #0xd]
 8017784: f023 0302    	bic	r3, r3, #0x2
 8017788: b2da         	uxtb	r2, r3
 801778a: 687b         	ldr	r3, [r7, #0x4]
 801778c: 735a         	strb	r2, [r3, #0xd]
; }
 801778e: bf00         	nop
 8017790: 370c         	adds	r7, #0xc
 8017792: 46bd         	mov	sp, r7
 8017794: bc80         	pop	{r7}
 8017796: 4770         	bx	lr

08017798 <unpend_thread_no_timeout>:
; {
 8017798: b580         	push	{r7, lr}
 801779a: b086         	sub	sp, #0x18
 801779c: af00         	add	r7, sp, #0x0
 801779e: 6078         	str	r0, [r7, #0x4]
 80177a0: 687b         	ldr	r3, [r7, #0x4]
 80177a2: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 80177a4: 68fb         	ldr	r3, [r7, #0xc]
 80177a6: 689b         	ldr	r3, [r3, #0x8]
 80177a8: 617b         	str	r3, [r7, #0x14]
 80177aa: 687b         	ldr	r3, [r7, #0x4]
 80177ac: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 80177ae: 693b         	ldr	r3, [r7, #0x10]
 80177b0: 4618         	mov	r0, r3
 80177b2: f7ff ffa7    	bl	0x8017704 <sys_dlist_remove> @ imm = #-0xb2
; }
 80177b6: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 80177b8: 6878         	ldr	r0, [r7, #0x4]
 80177ba: f7ff ffdd    	bl	0x8017778 <z_mark_thread_as_not_pending> @ imm = #-0x46
; 	thread->base.pended_on = NULL;
 80177be: 687b         	ldr	r3, [r7, #0x4]
 80177c0: 2200         	movs	r2, #0x0
 80177c2: 609a         	str	r2, [r3, #0x8]
; }
 80177c4: bf00         	nop
 80177c6: 3718         	adds	r7, #0x18
 80177c8: 46bd         	mov	sp, r7
 80177ca: bd80         	pop	{r7, pc}

080177cc <z_impl_k_sem_init>:
; {
 80177cc: b580         	push	{r7, lr}
 80177ce: b084         	sub	sp, #0x10
 80177d0: af00         	add	r7, sp, #0x0
 80177d2: 60f8         	str	r0, [r7, #0xc]
 80177d4: 60b9         	str	r1, [r7, #0x8]
 80177d6: 607a         	str	r2, [r7, #0x4]
; 	CHECKIF(limit == 0U || initial_count > limit) {
 80177d8: 687b         	ldr	r3, [r7, #0x4]
 80177da: 2b00         	cmp	r3, #0x0
 80177dc: d003         	beq	0x80177e6 <z_impl_k_sem_init+0x1a> @ imm = #0x6
 80177de: 68ba         	ldr	r2, [r7, #0x8]
 80177e0: 687b         	ldr	r3, [r7, #0x4]
 80177e2: 429a         	cmp	r2, r3
 80177e4: d902         	bls	0x80177ec <z_impl_k_sem_init+0x20> @ imm = #0x4
; 		return -EINVAL;
 80177e6: f06f 0315    	mvn	r3, #0x15
 80177ea: e00d         	b	0x8017808 <z_impl_k_sem_init+0x3c> @ imm = #0x1a
; 	sem->count = initial_count;
 80177ec: 68fb         	ldr	r3, [r7, #0xc]
 80177ee: 68ba         	ldr	r2, [r7, #0x8]
 80177f0: 609a         	str	r2, [r3, #0x8]
; 	sem->limit = limit;
 80177f2: 68fb         	ldr	r3, [r7, #0xc]
 80177f4: 687a         	ldr	r2, [r7, #0x4]
 80177f6: 60da         	str	r2, [r3, #0xc]
; 	z_waitq_init(&sem->wait_q);
 80177f8: 68fb         	ldr	r3, [r7, #0xc]
 80177fa: 4618         	mov	r0, r3
 80177fc: f7ff ffb0    	bl	0x8017760 <z_waitq_init> @ imm = #-0xa0
; 	k_object_init(sem);
 8017800: 68f8         	ldr	r0, [r7, #0xc]
 8017802: f7ff ff96    	bl	0x8017732 <k_object_init> @ imm = #-0xd4
; 	return 0;
 8017806: 2300         	movs	r3, #0x0
; }
 8017808: 4618         	mov	r0, r3
 801780a: 3710         	adds	r7, #0x10
 801780c: 46bd         	mov	sp, r7
 801780e: bd80         	pop	{r7, pc}

08017810 <handle_poll_events>:
; {
 8017810: b480         	push	{r7}
 8017812: b083         	sub	sp, #0xc
 8017814: af00         	add	r7, sp, #0x0
 8017816: 6078         	str	r0, [r7, #0x4]
; 	return false;
 8017818: 2300         	movs	r3, #0x0
; }
 801781a: 4618         	mov	r0, r3
 801781c: 370c         	adds	r7, #0xc
 801781e: 46bd         	mov	sp, r7
 8017820: bc80         	pop	{r7}
 8017822: 4770         	bx	lr

08017824 <sys_dlist_init>:
; {
 8017824: b480         	push	{r7}
 8017826: b083         	sub	sp, #0xc
 8017828: af00         	add	r7, sp, #0x0
 801782a: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 801782c: 687b         	ldr	r3, [r7, #0x4]
 801782e: 687a         	ldr	r2, [r7, #0x4]
 8017830: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8017832: 687b         	ldr	r3, [r7, #0x4]
 8017834: 687a         	ldr	r2, [r7, #0x4]
 8017836: 605a         	str	r2, [r3, #0x4]
; }
 8017838: bf00         	nop
 801783a: 370c         	adds	r7, #0xc
 801783c: 46bd         	mov	sp, r7
 801783e: bc80         	pop	{r7}
 8017840: 4770         	bx	lr

08017842 <sys_dnode_init>:
; {
 8017842: b480         	push	{r7}
 8017844: b083         	sub	sp, #0xc
 8017846: af00         	add	r7, sp, #0x0
 8017848: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801784a: 687b         	ldr	r3, [r7, #0x4]
 801784c: 2200         	movs	r2, #0x0
 801784e: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8017850: 687b         	ldr	r3, [r7, #0x4]
 8017852: 2200         	movs	r2, #0x0
 8017854: 605a         	str	r2, [r3, #0x4]
; }
 8017856: bf00         	nop
 8017858: 370c         	adds	r7, #0xc
 801785a: 46bd         	mov	sp, r7
 801785c: bc80         	pop	{r7}
 801785e: 4770         	bx	lr

08017860 <sys_slist_init>:
; {
 8017860: b480         	push	{r7}
 8017862: b083         	sub	sp, #0xc
 8017864: af00         	add	r7, sp, #0x0
 8017866: 6078         	str	r0, [r7, #0x4]
; 	list->head = NULL;
 8017868: 687b         	ldr	r3, [r7, #0x4]
 801786a: 2200         	movs	r2, #0x0
 801786c: 601a         	str	r2, [r3]
; 	list->tail = NULL;
 801786e: 687b         	ldr	r3, [r7, #0x4]
 8017870: 2200         	movs	r2, #0x0
 8017872: 605a         	str	r2, [r3, #0x4]
; }
 8017874: bf00         	nop
 8017876: 370c         	adds	r7, #0xc
 8017878: 46bd         	mov	sp, r7
 801787a: bc80         	pop	{r7}
 801787c: 4770         	bx	lr

0801787e <z_snode_next_peek>:
; {
 801787e: b480         	push	{r7}
 8017880: b083         	sub	sp, #0xc
 8017882: af00         	add	r7, sp, #0x0
 8017884: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 8017886: 687b         	ldr	r3, [r7, #0x4]
 8017888: 681b         	ldr	r3, [r3]
; }
 801788a: 4618         	mov	r0, r3
 801788c: 370c         	adds	r7, #0xc
 801788e: 46bd         	mov	sp, r7
 8017890: bc80         	pop	{r7}
 8017892: 4770         	bx	lr

08017894 <z_snode_next_set>:
; {
 8017894: b480         	push	{r7}
 8017896: b083         	sub	sp, #0xc
 8017898: af00         	add	r7, sp, #0x0
 801789a: 6078         	str	r0, [r7, #0x4]
 801789c: 6039         	str	r1, [r7]
; 	parent->next = child;
 801789e: 687b         	ldr	r3, [r7, #0x4]
 80178a0: 683a         	ldr	r2, [r7]
 80178a2: 601a         	str	r2, [r3]
; }
 80178a4: bf00         	nop
 80178a6: 370c         	adds	r7, #0xc
 80178a8: 46bd         	mov	sp, r7
 80178aa: bc80         	pop	{r7}
 80178ac: 4770         	bx	lr

080178ae <z_slist_head_set>:
; {
 80178ae: b480         	push	{r7}
 80178b0: b083         	sub	sp, #0xc
 80178b2: af00         	add	r7, sp, #0x0
 80178b4: 6078         	str	r0, [r7, #0x4]
 80178b6: 6039         	str	r1, [r7]
; 	list->head = node;
 80178b8: 687b         	ldr	r3, [r7, #0x4]
 80178ba: 683a         	ldr	r2, [r7]
 80178bc: 601a         	str	r2, [r3]
; }
 80178be: bf00         	nop
 80178c0: 370c         	adds	r7, #0xc
 80178c2: 46bd         	mov	sp, r7
 80178c4: bc80         	pop	{r7}
 80178c6: 4770         	bx	lr

080178c8 <z_slist_tail_set>:
; {
 80178c8: b480         	push	{r7}
 80178ca: b083         	sub	sp, #0xc
 80178cc: af00         	add	r7, sp, #0x0
 80178ce: 6078         	str	r0, [r7, #0x4]
 80178d0: 6039         	str	r1, [r7]
; 	list->tail = node;
 80178d2: 687b         	ldr	r3, [r7, #0x4]
 80178d4: 683a         	ldr	r2, [r7]
 80178d6: 605a         	str	r2, [r3, #0x4]
; }
 80178d8: bf00         	nop
 80178da: 370c         	adds	r7, #0xc
 80178dc: 46bd         	mov	sp, r7
 80178de: bc80         	pop	{r7}
 80178e0: 4770         	bx	lr

080178e2 <sys_slist_peek_head>:
; {
 80178e2: b480         	push	{r7}
 80178e4: b083         	sub	sp, #0xc
 80178e6: af00         	add	r7, sp, #0x0
 80178e8: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 80178ea: 687b         	ldr	r3, [r7, #0x4]
 80178ec: 681b         	ldr	r3, [r3]
; }
 80178ee: 4618         	mov	r0, r3
 80178f0: 370c         	adds	r7, #0xc
 80178f2: 46bd         	mov	sp, r7
 80178f4: bc80         	pop	{r7}
 80178f6: 4770         	bx	lr

080178f8 <sys_slist_peek_tail>:
; {
 80178f8: b480         	push	{r7}
 80178fa: b083         	sub	sp, #0xc
 80178fc: af00         	add	r7, sp, #0x0
 80178fe: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 8017900: 687b         	ldr	r3, [r7, #0x4]
 8017902: 685b         	ldr	r3, [r3, #0x4]
; }
 8017904: 4618         	mov	r0, r3
 8017906: 370c         	adds	r7, #0xc
 8017908: 46bd         	mov	sp, r7
 801790a: bc80         	pop	{r7}
 801790c: 4770         	bx	lr

0801790e <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 801790e: b580         	push	{r7, lr}
 8017910: b082         	sub	sp, #0x8
 8017912: af00         	add	r7, sp, #0x0
 8017914: 6078         	str	r0, [r7, #0x4]
 8017916: 6878         	ldr	r0, [r7, #0x4]
 8017918: f7ff ffe3    	bl	0x80178e2 <sys_slist_peek_head> @ imm = #-0x3a
 801791c: 4603         	mov	r3, r0
 801791e: 2b00         	cmp	r3, #0x0
 8017920: bf0c         	ite	eq
 8017922: 2301         	moveq	r3, #0x1
 8017924: 2300         	movne	r3, #0x0
 8017926: b2db         	uxtb	r3, r3
 8017928: 4618         	mov	r0, r3
 801792a: 3708         	adds	r7, #0x8
 801792c: 46bd         	mov	sp, r7
 801792e: bd80         	pop	{r7, pc}

08017930 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8017930: b580         	push	{r7, lr}
 8017932: b082         	sub	sp, #0x8
 8017934: af00         	add	r7, sp, #0x0
 8017936: 6078         	str	r0, [r7, #0x4]
 8017938: 6878         	ldr	r0, [r7, #0x4]
 801793a: f7ff ffa0    	bl	0x801787e <z_snode_next_peek> @ imm = #-0xc0
 801793e: 4603         	mov	r3, r0
 8017940: 4618         	mov	r0, r3
 8017942: 3708         	adds	r7, #0x8
 8017944: 46bd         	mov	sp, r7
 8017946: bd80         	pop	{r7, pc}

08017948 <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 8017948: b580         	push	{r7, lr}
 801794a: b082         	sub	sp, #0x8
 801794c: af00         	add	r7, sp, #0x0
 801794e: 6078         	str	r0, [r7, #0x4]
 8017950: 687b         	ldr	r3, [r7, #0x4]
 8017952: 2b00         	cmp	r3, #0x0
 8017954: d004         	beq	0x8017960 <sys_slist_peek_next+0x18> @ imm = #0x8
 8017956: 6878         	ldr	r0, [r7, #0x4]
 8017958: f7ff ffea    	bl	0x8017930 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 801795c: 4603         	mov	r3, r0
 801795e: e000         	b	0x8017962 <sys_slist_peek_next+0x1a> @ imm = #0x0
 8017960: 2300         	movs	r3, #0x0
 8017962: 4618         	mov	r0, r3
 8017964: 3708         	adds	r7, #0x8
 8017966: 46bd         	mov	sp, r7
 8017968: bd80         	pop	{r7, pc}

0801796a <sys_slist_append>:
; Z_GENLIST_APPEND(slist, snode)
 801796a: b580         	push	{r7, lr}
 801796c: b082         	sub	sp, #0x8
 801796e: af00         	add	r7, sp, #0x0
 8017970: 6078         	str	r0, [r7, #0x4]
 8017972: 6039         	str	r1, [r7]
 8017974: 2100         	movs	r1, #0x0
 8017976: 6838         	ldr	r0, [r7]
 8017978: f7ff ff8c    	bl	0x8017894 <z_snode_next_set> @ imm = #-0xe8
 801797c: 6878         	ldr	r0, [r7, #0x4]
 801797e: f7ff ffbb    	bl	0x80178f8 <sys_slist_peek_tail> @ imm = #-0x8a
 8017982: 4603         	mov	r3, r0
 8017984: 2b00         	cmp	r3, #0x0
 8017986: d108         	bne	0x801799a <sys_slist_append+0x30> @ imm = #0x10
 8017988: 6839         	ldr	r1, [r7]
 801798a: 6878         	ldr	r0, [r7, #0x4]
 801798c: f7ff ff9c    	bl	0x80178c8 <z_slist_tail_set> @ imm = #-0xc8
 8017990: 6839         	ldr	r1, [r7]
 8017992: 6878         	ldr	r0, [r7, #0x4]
 8017994: f7ff ff8b    	bl	0x80178ae <z_slist_head_set> @ imm = #-0xea
 8017998: e00b         	b	0x80179b2 <sys_slist_append+0x48> @ imm = #0x16
 801799a: 6878         	ldr	r0, [r7, #0x4]
 801799c: f7ff ffac    	bl	0x80178f8 <sys_slist_peek_tail> @ imm = #-0xa8
 80179a0: 4603         	mov	r3, r0
 80179a2: 6839         	ldr	r1, [r7]
 80179a4: 4618         	mov	r0, r3
 80179a6: f7ff ff75    	bl	0x8017894 <z_snode_next_set> @ imm = #-0x116
 80179aa: 6839         	ldr	r1, [r7]
 80179ac: 6878         	ldr	r0, [r7, #0x4]
 80179ae: f7ff ff8b    	bl	0x80178c8 <z_slist_tail_set> @ imm = #-0xea
 80179b2: 3708         	adds	r7, #0x8
 80179b4: 46bd         	mov	sp, r7
 80179b6: bd80         	pop	{r7, pc}

080179b8 <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 80179b8: b580         	push	{r7, lr}
 80179ba: b084         	sub	sp, #0x10
 80179bc: af00         	add	r7, sp, #0x0
 80179be: 6078         	str	r0, [r7, #0x4]
 80179c0: 6878         	ldr	r0, [r7, #0x4]
 80179c2: f7ff ff8e    	bl	0x80178e2 <sys_slist_peek_head> @ imm = #-0xe4
 80179c6: 60f8         	str	r0, [r7, #0xc]
 80179c8: 68f8         	ldr	r0, [r7, #0xc]
 80179ca: f7ff ff58    	bl	0x801787e <z_snode_next_peek> @ imm = #-0x150
 80179ce: 4603         	mov	r3, r0
 80179d0: 4619         	mov	r1, r3
 80179d2: 6878         	ldr	r0, [r7, #0x4]
 80179d4: f7ff ff6b    	bl	0x80178ae <z_slist_head_set> @ imm = #-0x12a
 80179d8: 6878         	ldr	r0, [r7, #0x4]
 80179da: f7ff ff8d    	bl	0x80178f8 <sys_slist_peek_tail> @ imm = #-0xe6
 80179de: 4602         	mov	r2, r0
 80179e0: 68fb         	ldr	r3, [r7, #0xc]
 80179e2: 4293         	cmp	r3, r2
 80179e4: d107         	bne	0x80179f6 <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 80179e6: 6878         	ldr	r0, [r7, #0x4]
 80179e8: f7ff ff7b    	bl	0x80178e2 <sys_slist_peek_head> @ imm = #-0x10a
 80179ec: 4603         	mov	r3, r0
 80179ee: 4619         	mov	r1, r3
 80179f0: 6878         	ldr	r0, [r7, #0x4]
 80179f2: f7ff ff69    	bl	0x80178c8 <z_slist_tail_set> @ imm = #-0x12e
 80179f6: 68fb         	ldr	r3, [r7, #0xc]
 80179f8: 4618         	mov	r0, r3
 80179fa: 3710         	adds	r7, #0x10
 80179fc: 46bd         	mov	sp, r7
 80179fe: bd80         	pop	{r7, pc}

08017a00 <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 8017a00: b580         	push	{r7, lr}
 8017a02: b082         	sub	sp, #0x8
 8017a04: af00         	add	r7, sp, #0x0
 8017a06: 6078         	str	r0, [r7, #0x4]
 8017a08: 6878         	ldr	r0, [r7, #0x4]
 8017a0a: f7ff ff80    	bl	0x801790e <sys_slist_is_empty> @ imm = #-0x100
 8017a0e: 4603         	mov	r3, r0
 8017a10: 2b00         	cmp	r3, #0x0
 8017a12: d104         	bne	0x8017a1e <sys_slist_get+0x1e> @ imm = #0x8
 8017a14: 6878         	ldr	r0, [r7, #0x4]
 8017a16: f7ff ffcf    	bl	0x80179b8 <sys_slist_get_not_empty> @ imm = #-0x62
 8017a1a: 4603         	mov	r3, r0
 8017a1c: e000         	b	0x8017a20 <sys_slist_get+0x20> @ imm = #0x0
 8017a1e: 2300         	movs	r3, #0x0
 8017a20: 4618         	mov	r0, r3
 8017a22: 3708         	adds	r7, #0x8
 8017a24: 46bd         	mov	sp, r7
 8017a26: bd80         	pop	{r7, pc}

08017a28 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 8017a28: b580         	push	{r7, lr}
 8017a2a: b084         	sub	sp, #0x10
 8017a2c: af00         	add	r7, sp, #0x0
 8017a2e: 60f8         	str	r0, [r7, #0xc]
 8017a30: 60b9         	str	r1, [r7, #0x8]
 8017a32: 607a         	str	r2, [r7, #0x4]
 8017a34: 68bb         	ldr	r3, [r7, #0x8]
 8017a36: 2b00         	cmp	r3, #0x0
 8017a38: d117         	bne	0x8017a6a <sys_slist_remove+0x42> @ imm = #0x2e
 8017a3a: 6878         	ldr	r0, [r7, #0x4]
 8017a3c: f7ff ff1f    	bl	0x801787e <z_snode_next_peek> @ imm = #-0x1c2
 8017a40: 4603         	mov	r3, r0
 8017a42: 4619         	mov	r1, r3
 8017a44: 68f8         	ldr	r0, [r7, #0xc]
 8017a46: f7ff ff32    	bl	0x80178ae <z_slist_head_set> @ imm = #-0x19c
 8017a4a: 68f8         	ldr	r0, [r7, #0xc]
 8017a4c: f7ff ff54    	bl	0x80178f8 <sys_slist_peek_tail> @ imm = #-0x158
 8017a50: 4602         	mov	r2, r0
 8017a52: 687b         	ldr	r3, [r7, #0x4]
 8017a54: 4293         	cmp	r3, r2
 8017a56: d11b         	bne	0x8017a90 <sys_slist_remove+0x68> @ imm = #0x36
 8017a58: 68f8         	ldr	r0, [r7, #0xc]
 8017a5a: f7ff ff42    	bl	0x80178e2 <sys_slist_peek_head> @ imm = #-0x17c
 8017a5e: 4603         	mov	r3, r0
 8017a60: 4619         	mov	r1, r3
 8017a62: 68f8         	ldr	r0, [r7, #0xc]
 8017a64: f7ff ff30    	bl	0x80178c8 <z_slist_tail_set> @ imm = #-0x1a0
 8017a68: e012         	b	0x8017a90 <sys_slist_remove+0x68> @ imm = #0x24
 8017a6a: 6878         	ldr	r0, [r7, #0x4]
 8017a6c: f7ff ff07    	bl	0x801787e <z_snode_next_peek> @ imm = #-0x1f2
 8017a70: 4603         	mov	r3, r0
 8017a72: 4619         	mov	r1, r3
 8017a74: 68b8         	ldr	r0, [r7, #0x8]
 8017a76: f7ff ff0d    	bl	0x8017894 <z_snode_next_set> @ imm = #-0x1e6
 8017a7a: 68f8         	ldr	r0, [r7, #0xc]
 8017a7c: f7ff ff3c    	bl	0x80178f8 <sys_slist_peek_tail> @ imm = #-0x188
 8017a80: 4602         	mov	r2, r0
 8017a82: 687b         	ldr	r3, [r7, #0x4]
 8017a84: 4293         	cmp	r3, r2
 8017a86: d103         	bne	0x8017a90 <sys_slist_remove+0x68> @ imm = #0x6
 8017a88: 68b9         	ldr	r1, [r7, #0x8]
 8017a8a: 68f8         	ldr	r0, [r7, #0xc]
 8017a8c: f7ff ff1c    	bl	0x80178c8 <z_slist_tail_set> @ imm = #-0x1c8
 8017a90: 2100         	movs	r1, #0x0
 8017a92: 6878         	ldr	r0, [r7, #0x4]
 8017a94: f7ff fefe    	bl	0x8017894 <z_snode_next_set> @ imm = #-0x204
 8017a98: 3710         	adds	r7, #0x10
 8017a9a: 46bd         	mov	sp, r7
 8017a9c: bd80         	pop	{r7, pc}

08017a9e <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8017a9e: b580         	push	{r7, lr}
 8017aa0: b084         	sub	sp, #0x10
 8017aa2: af00         	add	r7, sp, #0x0
 8017aa4: 6078         	str	r0, [r7, #0x4]
 8017aa6: 6039         	str	r1, [r7]
 8017aa8: 2300         	movs	r3, #0x0
 8017aaa: 60fb         	str	r3, [r7, #0xc]
 8017aac: 6878         	ldr	r0, [r7, #0x4]
 8017aae: f7ff ff18    	bl	0x80178e2 <sys_slist_peek_head> @ imm = #-0x1d0
 8017ab2: 60b8         	str	r0, [r7, #0x8]
 8017ab4: e010         	b	0x8017ad8 <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 8017ab6: 68ba         	ldr	r2, [r7, #0x8]
 8017ab8: 683b         	ldr	r3, [r7]
 8017aba: 429a         	cmp	r2, r3
 8017abc: d106         	bne	0x8017acc <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 8017abe: 683a         	ldr	r2, [r7]
 8017ac0: 68f9         	ldr	r1, [r7, #0xc]
 8017ac2: 6878         	ldr	r0, [r7, #0x4]
 8017ac4: f7ff ffb0    	bl	0x8017a28 <sys_slist_remove> @ imm = #-0xa0
 8017ac8: 2301         	movs	r3, #0x1
 8017aca: e009         	b	0x8017ae0 <sys_slist_find_and_remove+0x42> @ imm = #0x12
 8017acc: 68bb         	ldr	r3, [r7, #0x8]
 8017ace: 60fb         	str	r3, [r7, #0xc]
 8017ad0: 68b8         	ldr	r0, [r7, #0x8]
 8017ad2: f7ff ff39    	bl	0x8017948 <sys_slist_peek_next> @ imm = #-0x18e
 8017ad6: 60b8         	str	r0, [r7, #0x8]
 8017ad8: 68bb         	ldr	r3, [r7, #0x8]
 8017ada: 2b00         	cmp	r3, #0x0
 8017adc: d1eb         	bne	0x8017ab6 <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 8017ade: 2300         	movs	r3, #0x0
 8017ae0: 4618         	mov	r0, r3
 8017ae2: 3710         	adds	r7, #0x10
 8017ae4: 46bd         	mov	sp, r7
 8017ae6: bd80         	pop	{r7, pc}

08017ae8 <k_thread_create>:
; {
 8017ae8: b580         	push	{r7, lr}
 8017aea: b08c         	sub	sp, #0x30
 8017aec: af08         	add	r7, sp, #0x20
 8017aee: 60f8         	str	r0, [r7, #0xc]
 8017af0: 60b9         	str	r1, [r7, #0x8]
 8017af2: 607a         	str	r2, [r7, #0x4]
 8017af4: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 8017af6: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8017afa: e9cd 2306    	strd	r2, r3, [sp, #24]
 8017afe: 6abb         	ldr	r3, [r7, #0x28]
 8017b00: 9304         	str	r3, [sp, #0x10]
 8017b02: 6a7b         	ldr	r3, [r7, #0x24]
 8017b04: 9303         	str	r3, [sp, #0xc]
 8017b06: 6a3b         	ldr	r3, [r7, #0x20]
 8017b08: 9302         	str	r3, [sp, #0x8]
 8017b0a: 69fb         	ldr	r3, [r7, #0x1c]
 8017b0c: 9301         	str	r3, [sp, #0x4]
 8017b0e: 69bb         	ldr	r3, [r7, #0x18]
 8017b10: 9300         	str	r3, [sp]
 8017b12: 683b         	ldr	r3, [r7]
 8017b14: 687a         	ldr	r2, [r7, #0x4]
 8017b16: 68b9         	ldr	r1, [r7, #0x8]
 8017b18: 68f8         	ldr	r0, [r7, #0xc]
 8017b1a: f000 faad    	bl	0x8018078 <z_impl_k_thread_create> @ imm = #0x55a
 8017b1e: 4603         	mov	r3, r0
; }
 8017b20: 4618         	mov	r0, r3
 8017b22: 3710         	adds	r7, #0x10
 8017b24: 46bd         	mov	sp, r7
 8017b26: bd80         	pop	{r7, pc}

08017b28 <k_yield>:
; {
 8017b28: b580         	push	{r7, lr}
 8017b2a: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 8017b2c: f7f6 f8ee    	bl	0x800dd0c <z_impl_k_yield> @ imm = #-0x9e24
; }
 8017b30: bf00         	nop
 8017b32: bd80         	pop	{r7, pc}

08017b34 <k_thread_start>:
; {
 8017b34: b580         	push	{r7, lr}
 8017b36: b082         	sub	sp, #0x8
 8017b38: af00         	add	r7, sp, #0x0
 8017b3a: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_start(thread);
 8017b3c: 6878         	ldr	r0, [r7, #0x4]
 8017b3e: f000 fa90    	bl	0x8018062 <z_impl_k_thread_start> @ imm = #0x520
; }
 8017b42: bf00         	nop
 8017b44: 3708         	adds	r7, #0x8
 8017b46: 46bd         	mov	sp, r7
 8017b48: bd80         	pop	{r7, pc}

08017b4a <k_thread_name_set>:
; {
 8017b4a: b580         	push	{r7, lr}
 8017b4c: b082         	sub	sp, #0x8
 8017b4e: af00         	add	r7, sp, #0x0
 8017b50: 6078         	str	r0, [r7, #0x4]
 8017b52: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 8017b54: 6839         	ldr	r1, [r7]
 8017b56: 6878         	ldr	r0, [r7, #0x4]
 8017b58: f7f5 f83c    	bl	0x800cbd4 <z_impl_k_thread_name_set> @ imm = #-0xaf88
 8017b5c: 4603         	mov	r3, r0
; }
 8017b5e: 4618         	mov	r0, r3
 8017b60: 3708         	adds	r7, #0x8
 8017b62: 46bd         	mov	sp, r7
 8017b64: bd80         	pop	{r7, pc}

08017b66 <k_sem_give>:
; {
 8017b66: b580         	push	{r7, lr}
 8017b68: b082         	sub	sp, #0x8
 8017b6a: af00         	add	r7, sp, #0x0
 8017b6c: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 8017b6e: 6878         	ldr	r0, [r7, #0x4]
 8017b70: f7f4 fbe0    	bl	0x800c334 <z_impl_k_sem_give> @ imm = #-0xb840
; }
 8017b74: bf00         	nop
 8017b76: 3708         	adds	r7, #0x8
 8017b78: 46bd         	mov	sp, r7
 8017b7a: bd80         	pop	{r7, pc}

08017b7c <z_init_timeout>:
; {
 8017b7c: b580         	push	{r7, lr}
 8017b7e: b082         	sub	sp, #0x8
 8017b80: af00         	add	r7, sp, #0x0
 8017b82: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 8017b84: 687b         	ldr	r3, [r7, #0x4]
 8017b86: 4618         	mov	r0, r3
 8017b88: f7ff fe5b    	bl	0x8017842 <sys_dnode_init> @ imm = #-0x34a
; }
 8017b8c: bf00         	nop
 8017b8e: 3708         	adds	r7, #0x8
 8017b90: 46bd         	mov	sp, r7
 8017b92: bd80         	pop	{r7, pc}

08017b94 <z_waitq_init>:
; {
 8017b94: b580         	push	{r7, lr}
 8017b96: b082         	sub	sp, #0x8
 8017b98: af00         	add	r7, sp, #0x0
 8017b9a: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8017b9c: 687b         	ldr	r3, [r7, #0x4]
 8017b9e: 4618         	mov	r0, r3
 8017ba0: f7ff fe40    	bl	0x8017824 <sys_dlist_init> @ imm = #-0x380
; }
 8017ba4: bf00         	nop
 8017ba6: 3708         	adds	r7, #0x8
 8017ba8: 46bd         	mov	sp, r7
 8017baa: bd80         	pop	{r7, pc}

08017bac <z_sched_wake_all>:
; {
 8017bac: b580         	push	{r7, lr}
 8017bae: b086         	sub	sp, #0x18
 8017bb0: af00         	add	r7, sp, #0x0
 8017bb2: 60f8         	str	r0, [r7, #0xc]
 8017bb4: 60b9         	str	r1, [r7, #0x8]
 8017bb6: 607a         	str	r2, [r7, #0x4]
; 	bool woken = false;
 8017bb8: 2300         	movs	r3, #0x0
 8017bba: 75fb         	strb	r3, [r7, #0x17]
; 	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 8017bbc: e001         	b	0x8017bc2 <z_sched_wake_all+0x16> @ imm = #0x2
; 		woken = true;
 8017bbe: 2301         	movs	r3, #0x1
 8017bc0: 75fb         	strb	r3, [r7, #0x17]
; 	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 8017bc2: 687a         	ldr	r2, [r7, #0x4]
 8017bc4: 68b9         	ldr	r1, [r7, #0x8]
 8017bc6: 68f8         	ldr	r0, [r7, #0xc]
 8017bc8: f7f6 fbe8    	bl	0x800e39c <z_sched_wake> @ imm = #-0x9830
 8017bcc: 4603         	mov	r3, r0
 8017bce: 2b00         	cmp	r3, #0x0
 8017bd0: d1f5         	bne	0x8017bbe <z_sched_wake_all+0x12> @ imm = #-0x16
; 	return woken;
 8017bd2: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 8017bd4: 4618         	mov	r0, r3
 8017bd6: 3718         	adds	r7, #0x18
 8017bd8: 46bd         	mov	sp, r7
 8017bda: bd80         	pop	{r7, pc}

08017bdc <flag_clear>:
; {
 8017bdc: b480         	push	{r7}
 8017bde: b083         	sub	sp, #0xc
 8017be0: af00         	add	r7, sp, #0x0
 8017be2: 6078         	str	r0, [r7, #0x4]
 8017be4: 6039         	str	r1, [r7]
; 	*flagp &= ~BIT(bit);
 8017be6: 687b         	ldr	r3, [r7, #0x4]
 8017be8: 681a         	ldr	r2, [r3]
 8017bea: 2101         	movs	r1, #0x1
 8017bec: 683b         	ldr	r3, [r7]
 8017bee: fa01 f303    	lsl.w	r3, r1, r3
 8017bf2: 43db         	mvns	r3, r3
 8017bf4: 401a         	ands	r2, r3
 8017bf6: 687b         	ldr	r3, [r7, #0x4]
 8017bf8: 601a         	str	r2, [r3]
; }
 8017bfa: bf00         	nop
 8017bfc: 370c         	adds	r7, #0xc
 8017bfe: 46bd         	mov	sp, r7
 8017c00: bc80         	pop	{r7}
 8017c02: 4770         	bx	lr

08017c04 <flag_set>:
; {
 8017c04: b480         	push	{r7}
 8017c06: b083         	sub	sp, #0xc
 8017c08: af00         	add	r7, sp, #0x0
 8017c0a: 6078         	str	r0, [r7, #0x4]
 8017c0c: 6039         	str	r1, [r7]
; 	*flagp |= BIT(bit);
 8017c0e: 687b         	ldr	r3, [r7, #0x4]
 8017c10: 681a         	ldr	r2, [r3]
 8017c12: 2101         	movs	r1, #0x1
 8017c14: 683b         	ldr	r3, [r7]
 8017c16: fa01 f303    	lsl.w	r3, r1, r3
 8017c1a: 431a         	orrs	r2, r3
 8017c1c: 687b         	ldr	r3, [r7, #0x4]
 8017c1e: 601a         	str	r2, [r3]
; }
 8017c20: bf00         	nop
 8017c22: 370c         	adds	r7, #0xc
 8017c24: 46bd         	mov	sp, r7
 8017c26: bc80         	pop	{r7}
 8017c28: 4770         	bx	lr

08017c2a <flag_test>:
; {
 8017c2a: b480         	push	{r7}
 8017c2c: b083         	sub	sp, #0xc
 8017c2e: af00         	add	r7, sp, #0x0
 8017c30: 6078         	str	r0, [r7, #0x4]
 8017c32: 6039         	str	r1, [r7]
; 	return (*flagp & BIT(bit)) != 0U;
 8017c34: 687b         	ldr	r3, [r7, #0x4]
 8017c36: 681a         	ldr	r2, [r3]
 8017c38: 683b         	ldr	r3, [r7]
 8017c3a: fa22 f303    	lsr.w	r3, r2, r3
 8017c3e: f003 0301    	and	r3, r3, #0x1
 8017c42: 2b00         	cmp	r3, #0x0
 8017c44: bf14         	ite	ne
 8017c46: 2301         	movne	r3, #0x1
 8017c48: 2300         	moveq	r3, #0x0
 8017c4a: b2db         	uxtb	r3, r3
; }
 8017c4c: 4618         	mov	r0, r3
 8017c4e: 370c         	adds	r7, #0xc
 8017c50: 46bd         	mov	sp, r7
 8017c52: bc80         	pop	{r7}
 8017c54: 4770         	bx	lr

08017c56 <flag_test_and_clear>:
; {
 8017c56: b580         	push	{r7, lr}
 8017c58: b084         	sub	sp, #0x10
 8017c5a: af00         	add	r7, sp, #0x0
 8017c5c: 6078         	str	r0, [r7, #0x4]
 8017c5e: 6039         	str	r1, [r7]
; 	bool ret = flag_test(flagp, bit);
 8017c60: 683b         	ldr	r3, [r7]
 8017c62: 4619         	mov	r1, r3
 8017c64: 6878         	ldr	r0, [r7, #0x4]
 8017c66: f7ff ffe0    	bl	0x8017c2a <flag_test>   @ imm = #-0x40
 8017c6a: 4603         	mov	r3, r0
 8017c6c: 73fb         	strb	r3, [r7, #0xf]
; 	flag_clear(flagp, bit);
 8017c6e: 683b         	ldr	r3, [r7]
 8017c70: 4619         	mov	r1, r3
 8017c72: 6878         	ldr	r0, [r7, #0x4]
 8017c74: f7ff ffb2    	bl	0x8017bdc <flag_clear>  @ imm = #-0x9c
; 	return ret;
 8017c78: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8017c7a: 4618         	mov	r0, r3
 8017c7c: 3710         	adds	r7, #0x10
 8017c7e: 46bd         	mov	sp, r7
 8017c80: bd80         	pop	{r7, pc}

08017c82 <flags_set>:
; {
 8017c82: b480         	push	{r7}
 8017c84: b083         	sub	sp, #0xc
 8017c86: af00         	add	r7, sp, #0x0
 8017c88: 6078         	str	r0, [r7, #0x4]
 8017c8a: 6039         	str	r1, [r7]
; 	*flagp = flags;
 8017c8c: 687b         	ldr	r3, [r7, #0x4]
 8017c8e: 683a         	ldr	r2, [r7]
 8017c90: 601a         	str	r2, [r3]
; }
 8017c92: bf00         	nop
 8017c94: 370c         	adds	r7, #0xc
 8017c96: 46bd         	mov	sp, r7
 8017c98: bc80         	pop	{r7}
 8017c9a: 4770         	bx	lr

08017c9c <flags_get>:
; {
 8017c9c: b480         	push	{r7}
 8017c9e: b083         	sub	sp, #0xc
 8017ca0: af00         	add	r7, sp, #0x0
 8017ca2: 6078         	str	r0, [r7, #0x4]
; 	return *flagp;
 8017ca4: 687b         	ldr	r3, [r7, #0x4]
 8017ca6: 681b         	ldr	r3, [r3]
; }
 8017ca8: 4618         	mov	r0, r3
 8017caa: 370c         	adds	r7, #0xc
 8017cac: 46bd         	mov	sp, r7
 8017cae: bc80         	pop	{r7}
 8017cb0: 4770         	bx	lr

08017cb2 <finalize_flush_locked>:
; {
 8017cb2: b580         	push	{r7, lr}
 8017cb4: b084         	sub	sp, #0x10
 8017cb6: af00         	add	r7, sp, #0x0
 8017cb8: 6078         	str	r0, [r7, #0x4]
; 	struct z_work_flusher *flusher
 8017cba: 687b         	ldr	r3, [r7, #0x4]
 8017cbc: 60fb         	str	r3, [r7, #0xc]
; 	flag_clear(&work->flags, K_WORK_FLUSHING_BIT);
 8017cbe: 687b         	ldr	r3, [r7, #0x4]
 8017cc0: 330c         	adds	r3, #0xc
 8017cc2: 2104         	movs	r1, #0x4
 8017cc4: 4618         	mov	r0, r3
 8017cc6: f7ff ff89    	bl	0x8017bdc <flag_clear>  @ imm = #-0xee
; 	k_sem_give(&flusher->sem);
 8017cca: 68fb         	ldr	r3, [r7, #0xc]
 8017ccc: 3310         	adds	r3, #0x10
 8017cce: 4618         	mov	r0, r3
 8017cd0: f7ff ff49    	bl	0x8017b66 <k_sem_give>  @ imm = #-0x16e
; };
 8017cd4: bf00         	nop
 8017cd6: 3710         	adds	r7, #0x10
 8017cd8: 46bd         	mov	sp, r7
 8017cda: bd80         	pop	{r7, pc}

08017cdc <work_busy_get_locked>:
; {
 8017cdc: b580         	push	{r7, lr}
 8017cde: b082         	sub	sp, #0x8
 8017ce0: af00         	add	r7, sp, #0x0
 8017ce2: 6078         	str	r0, [r7, #0x4]
; 	return flags_get(&work->flags) & K_WORK_MASK;
 8017ce4: 687b         	ldr	r3, [r7, #0x4]
 8017ce6: 330c         	adds	r3, #0xc
 8017ce8: 4618         	mov	r0, r3
 8017cea: f7ff ffd7    	bl	0x8017c9c <flags_get>   @ imm = #-0x52
 8017cee: 4603         	mov	r3, r0
 8017cf0: f003 031f    	and	r3, r3, #0x1f
; }
 8017cf4: 4618         	mov	r0, r3
 8017cf6: 3708         	adds	r7, #0x8
 8017cf8: 46bd         	mov	sp, r7
 8017cfa: bd80         	pop	{r7, pc}

08017cfc <queue_remove_locked>:
; {
 8017cfc: b580         	push	{r7, lr}
 8017cfe: b082         	sub	sp, #0x8
 8017d00: af00         	add	r7, sp, #0x0
 8017d02: 6078         	str	r0, [r7, #0x4]
 8017d04: 6039         	str	r1, [r7]
; 	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
 8017d06: 683b         	ldr	r3, [r7]
 8017d08: 330c         	adds	r3, #0xc
 8017d0a: 2102         	movs	r1, #0x2
 8017d0c: 4618         	mov	r0, r3
 8017d0e: f7ff ffa2    	bl	0x8017c56 <flag_test_and_clear> @ imm = #-0xbc
 8017d12: 4603         	mov	r3, r0
 8017d14: 2b00         	cmp	r3, #0x0
 8017d16: d006         	beq	0x8017d26 <queue_remove_locked+0x2a> @ imm = #0xc
; 		(void)sys_slist_find_and_remove(&queue->pending, &work->node);
 8017d18: 687b         	ldr	r3, [r7, #0x4]
 8017d1a: 33d0         	adds	r3, #0xd0
 8017d1c: 683a         	ldr	r2, [r7]
 8017d1e: 4611         	mov	r1, r2
 8017d20: 4618         	mov	r0, r3
 8017d22: f7ff febc    	bl	0x8017a9e <sys_slist_find_and_remove> @ imm = #-0x288
; }
 8017d26: bf00         	nop
 8017d28: 3708         	adds	r7, #0x8
 8017d2a: 46bd         	mov	sp, r7
 8017d2c: bd80         	pop	{r7, pc}

08017d2e <notify_queue_locked>:
; {
 8017d2e: b580         	push	{r7, lr}
 8017d30: b084         	sub	sp, #0x10
 8017d32: af00         	add	r7, sp, #0x0
 8017d34: 6078         	str	r0, [r7, #0x4]
; 	bool rv = false;
 8017d36: 2300         	movs	r3, #0x0
 8017d38: 73fb         	strb	r3, [r7, #0xf]
; 	if (queue != NULL) {
 8017d3a: 687b         	ldr	r3, [r7, #0x4]
 8017d3c: 2b00         	cmp	r3, #0x0
 8017d3e: d008         	beq	0x8017d52 <notify_queue_locked+0x24> @ imm = #0x10
; 		rv = z_sched_wake(&queue->notifyq, 0, NULL);
 8017d40: 687b         	ldr	r3, [r7, #0x4]
 8017d42: 33d8         	adds	r3, #0xd8
 8017d44: 2200         	movs	r2, #0x0
 8017d46: 2100         	movs	r1, #0x0
 8017d48: 4618         	mov	r0, r3
 8017d4a: f7f6 fb27    	bl	0x800e39c <z_sched_wake> @ imm = #-0x99b2
 8017d4e: 4603         	mov	r3, r0
 8017d50: 73fb         	strb	r3, [r7, #0xf]
; 	return rv;
 8017d52: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8017d54: 4618         	mov	r0, r3
 8017d56: 3710         	adds	r7, #0x10
 8017d58: 46bd         	mov	sp, r7
 8017d5a: bd80         	pop	{r7, pc}

08017d5c <submit_to_queue_locked>:
; {
 8017d5c: b580         	push	{r7, lr}
 8017d5e: b084         	sub	sp, #0x10
 8017d60: af00         	add	r7, sp, #0x0
 8017d62: 6078         	str	r0, [r7, #0x4]
 8017d64: 6039         	str	r1, [r7]
; 	int ret = 0;
 8017d66: 2300         	movs	r3, #0x0
 8017d68: 60fb         	str	r3, [r7, #0xc]
; 	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 8017d6a: 687b         	ldr	r3, [r7, #0x4]
 8017d6c: 330c         	adds	r3, #0xc
 8017d6e: 2101         	movs	r1, #0x1
 8017d70: 4618         	mov	r0, r3
 8017d72: f7ff ff5a    	bl	0x8017c2a <flag_test>   @ imm = #-0x14c
 8017d76: 4603         	mov	r3, r0
 8017d78: 2b00         	cmp	r3, #0x0
 8017d7a: d003         	beq	0x8017d84 <submit_to_queue_locked+0x28> @ imm = #0x6
; 		ret = -EBUSY;
 8017d7c: f06f 030f    	mvn	r3, #0xf
 8017d80: 60fb         	str	r3, [r7, #0xc]
 8017d82: e03b         	b	0x8017dfc <submit_to_queue_locked+0xa0> @ imm = #0x76
; 	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
 8017d84: 687b         	ldr	r3, [r7, #0x4]
 8017d86: 330c         	adds	r3, #0xc
 8017d88: 2102         	movs	r1, #0x2
 8017d8a: 4618         	mov	r0, r3
 8017d8c: f7ff ff4d    	bl	0x8017c2a <flag_test>   @ imm = #-0x166
 8017d90: 4603         	mov	r3, r0
 8017d92: f083 0301    	eor	r3, r3, #0x1
 8017d96: b2db         	uxtb	r3, r3
 8017d98: 2b00         	cmp	r3, #0x0
 8017d9a: d02f         	beq	0x8017dfc <submit_to_queue_locked+0xa0> @ imm = #0x5e
; 		ret = 1;
 8017d9c: 2301         	movs	r3, #0x1
 8017d9e: 60fb         	str	r3, [r7, #0xc]
; 		if (*queuep == NULL) {
 8017da0: 683b         	ldr	r3, [r7]
 8017da2: 681b         	ldr	r3, [r3]
 8017da4: 2b00         	cmp	r3, #0x0
 8017da6: d103         	bne	0x8017db0 <submit_to_queue_locked+0x54> @ imm = #0x6
; 			*queuep = work->queue;
 8017da8: 687b         	ldr	r3, [r7, #0x4]
 8017daa: 689a         	ldr	r2, [r3, #0x8]
 8017dac: 683b         	ldr	r3, [r7]
 8017dae: 601a         	str	r2, [r3]
; 		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
 8017db0: 687b         	ldr	r3, [r7, #0x4]
 8017db2: 330c         	adds	r3, #0xc
 8017db4: 2100         	movs	r1, #0x0
 8017db6: 4618         	mov	r0, r3
 8017db8: f7ff ff37    	bl	0x8017c2a <flag_test>   @ imm = #-0x192
 8017dbc: 4603         	mov	r3, r0
 8017dbe: 2b00         	cmp	r3, #0x0
 8017dc0: d005         	beq	0x8017dce <submit_to_queue_locked+0x72> @ imm = #0xa
; 			*queuep = work->queue;
 8017dc2: 687b         	ldr	r3, [r7, #0x4]
 8017dc4: 689a         	ldr	r2, [r3, #0x8]
 8017dc6: 683b         	ldr	r3, [r7]
 8017dc8: 601a         	str	r2, [r3]
; 			ret = 2;
 8017dca: 2302         	movs	r3, #0x2
 8017dcc: 60fb         	str	r3, [r7, #0xc]
; 		int rc = queue_submit_locked(*queuep, work);
 8017dce: 683b         	ldr	r3, [r7]
 8017dd0: 681b         	ldr	r3, [r3]
 8017dd2: 6879         	ldr	r1, [r7, #0x4]
 8017dd4: 4618         	mov	r0, r3
 8017dd6: f7f4 fc11    	bl	0x800c5fc <queue_submit_locked> @ imm = #-0xb7de
 8017dda: 60b8         	str	r0, [r7, #0x8]
; 		if (rc < 0) {
 8017ddc: 68bb         	ldr	r3, [r7, #0x8]
 8017dde: 2b00         	cmp	r3, #0x0
 8017de0: da02         	bge	0x8017de8 <submit_to_queue_locked+0x8c> @ imm = #0x4
; 			ret = rc;
 8017de2: 68bb         	ldr	r3, [r7, #0x8]
 8017de4: 60fb         	str	r3, [r7, #0xc]
 8017de6: e009         	b	0x8017dfc <submit_to_queue_locked+0xa0> @ imm = #0x12
; 			flag_set(&work->flags, K_WORK_QUEUED_BIT);
 8017de8: 687b         	ldr	r3, [r7, #0x4]
 8017dea: 330c         	adds	r3, #0xc
 8017dec: 2102         	movs	r1, #0x2
 8017dee: 4618         	mov	r0, r3
 8017df0: f7ff ff08    	bl	0x8017c04 <flag_set>    @ imm = #-0x1f0
; 			work->queue = *queuep;
 8017df4: 683b         	ldr	r3, [r7]
 8017df6: 681a         	ldr	r2, [r3]
 8017df8: 687b         	ldr	r3, [r7, #0x4]
 8017dfa: 609a         	str	r2, [r3, #0x8]
; 	if (ret <= 0) {
 8017dfc: 68fb         	ldr	r3, [r7, #0xc]
 8017dfe: 2b00         	cmp	r3, #0x0
 8017e00: dc02         	bgt	0x8017e08 <submit_to_queue_locked+0xac> @ imm = #0x4
; 		*queuep = NULL;
 8017e02: 683b         	ldr	r3, [r7]
 8017e04: 2200         	movs	r2, #0x0
 8017e06: 601a         	str	r2, [r3]
; 	return ret;
 8017e08: 68fb         	ldr	r3, [r7, #0xc]
; }
 8017e0a: 4618         	mov	r0, r3
 8017e0c: 3710         	adds	r7, #0x10
 8017e0e: 46bd         	mov	sp, r7
 8017e10: bd80         	pop	{r7, pc}

08017e12 <cancel_async_locked>:
; {
 8017e12: b580         	push	{r7, lr}
 8017e14: b084         	sub	sp, #0x10
 8017e16: af00         	add	r7, sp, #0x0
 8017e18: 6078         	str	r0, [r7, #0x4]
; 	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 8017e1a: 687b         	ldr	r3, [r7, #0x4]
 8017e1c: 330c         	adds	r3, #0xc
 8017e1e: 2101         	movs	r1, #0x1
 8017e20: 4618         	mov	r0, r3
 8017e22: f7ff ff02    	bl	0x8017c2a <flag_test>   @ imm = #-0x1fc
 8017e26: 4603         	mov	r3, r0
 8017e28: f083 0301    	eor	r3, r3, #0x1
 8017e2c: b2db         	uxtb	r3, r3
 8017e2e: 2b00         	cmp	r3, #0x0
 8017e30: d005         	beq	0x8017e3e <cancel_async_locked+0x2c> @ imm = #0xa
; 		queue_remove_locked(work->queue, work);
 8017e32: 687b         	ldr	r3, [r7, #0x4]
 8017e34: 689b         	ldr	r3, [r3, #0x8]
 8017e36: 6879         	ldr	r1, [r7, #0x4]
 8017e38: 4618         	mov	r0, r3
 8017e3a: f7ff ff5f    	bl	0x8017cfc <queue_remove_locked> @ imm = #-0x142
; 	int ret = work_busy_get_locked(work);
 8017e3e: 6878         	ldr	r0, [r7, #0x4]
 8017e40: f7ff ff4c    	bl	0x8017cdc <work_busy_get_locked> @ imm = #-0x168
 8017e44: 60f8         	str	r0, [r7, #0xc]
; 	if (ret != 0) {
 8017e46: 68fb         	ldr	r3, [r7, #0xc]
 8017e48: 2b00         	cmp	r3, #0x0
 8017e4a: d009         	beq	0x8017e60 <cancel_async_locked+0x4e> @ imm = #0x12
; 		flag_set(&work->flags, K_WORK_CANCELING_BIT);
 8017e4c: 687b         	ldr	r3, [r7, #0x4]
 8017e4e: 330c         	adds	r3, #0xc
 8017e50: 2101         	movs	r1, #0x1
 8017e52: 4618         	mov	r0, r3
 8017e54: f7ff fed6    	bl	0x8017c04 <flag_set>    @ imm = #-0x254
; 		ret = work_busy_get_locked(work);
 8017e58: 6878         	ldr	r0, [r7, #0x4]
 8017e5a: f7ff ff3f    	bl	0x8017cdc <work_busy_get_locked> @ imm = #-0x182
 8017e5e: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 8017e60: 68fb         	ldr	r3, [r7, #0xc]
; }
 8017e62: 4618         	mov	r0, r3
 8017e64: 3710         	adds	r7, #0x10
 8017e66: 46bd         	mov	sp, r7
 8017e68: bd80         	pop	{r7, pc}

08017e6a <k_work_init_delayable>:
; {
 8017e6a: b580         	push	{r7, lr}
 8017e6c: b08e         	sub	sp, #0x38
 8017e6e: af00         	add	r7, sp, #0x0
 8017e70: 6078         	str	r0, [r7, #0x4]
 8017e72: 6039         	str	r1, [r7]
; 	*dwork = (struct k_work_delayable){
 8017e74: 687b         	ldr	r3, [r7, #0x4]
 8017e76: 4618         	mov	r0, r3
 8017e78: 2330         	movs	r3, #0x30
 8017e7a: 461a         	mov	r2, r3
 8017e7c: 2100         	movs	r1, #0x0
 8017e7e: f000 ff62    	bl	0x8018d46 <memset>      @ imm = #0xec4
 8017e82: 687b         	ldr	r3, [r7, #0x4]
 8017e84: 683a         	ldr	r2, [r7]
 8017e86: 605a         	str	r2, [r3, #0x4]
 8017e88: 687b         	ldr	r3, [r7, #0x4]
 8017e8a: f44f 7280    	mov.w	r2, #0x100
 8017e8e: 60da         	str	r2, [r3, #0xc]
; 	z_init_timeout(&dwork->timeout);
 8017e90: 687b         	ldr	r3, [r7, #0x4]
 8017e92: 3310         	adds	r3, #0x10
 8017e94: 4618         	mov	r0, r3
 8017e96: f7ff fe71    	bl	0x8017b7c <z_init_timeout> @ imm = #-0x31e
; }
 8017e9a: bf00         	nop
 8017e9c: 3738         	adds	r7, #0x38
 8017e9e: 46bd         	mov	sp, r7
 8017ea0: bd80         	pop	{r7, pc}

08017ea2 <unschedule_locked>:
; {
 8017ea2: b580         	push	{r7, lr}
 8017ea4: b084         	sub	sp, #0x10
 8017ea6: af00         	add	r7, sp, #0x0
 8017ea8: 6078         	str	r0, [r7, #0x4]
; 	bool ret = false;
 8017eaa: 2300         	movs	r3, #0x0
 8017eac: 73fb         	strb	r3, [r7, #0xf]
; 	struct k_work *work = &dwork->work;
 8017eae: 687b         	ldr	r3, [r7, #0x4]
 8017eb0: 60bb         	str	r3, [r7, #0x8]
; 	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
 8017eb2: 68bb         	ldr	r3, [r7, #0x8]
 8017eb4: 330c         	adds	r3, #0xc
 8017eb6: 2103         	movs	r1, #0x3
 8017eb8: 4618         	mov	r0, r3
 8017eba: f7ff fecc    	bl	0x8017c56 <flag_test_and_clear> @ imm = #-0x268
 8017ebe: 4603         	mov	r3, r0
 8017ec0: 2b00         	cmp	r3, #0x0
 8017ec2: d00a         	beq	0x8017eda <unschedule_locked+0x38> @ imm = #0x14
; 		ret = z_abort_timeout(&dwork->timeout) == 0;
 8017ec4: 687b         	ldr	r3, [r7, #0x4]
 8017ec6: 3310         	adds	r3, #0x10
 8017ec8: 4618         	mov	r0, r3
 8017eca: f7f6 fdd7    	bl	0x800ea7c <z_abort_timeout> @ imm = #-0x9452
 8017ece: 4603         	mov	r3, r0
 8017ed0: 2b00         	cmp	r3, #0x0
 8017ed2: bf0c         	ite	eq
 8017ed4: 2301         	moveq	r3, #0x1
 8017ed6: 2300         	movne	r3, #0x0
 8017ed8: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 8017eda: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8017edc: 4618         	mov	r0, r3
 8017ede: 3710         	adds	r7, #0x10
 8017ee0: 46bd         	mov	sp, r7
 8017ee2: bd80         	pop	{r7, pc}

08017ee4 <cancel_delayable_async_locked>:
; {
 8017ee4: b580         	push	{r7, lr}
 8017ee6: b082         	sub	sp, #0x8
 8017ee8: af00         	add	r7, sp, #0x0
 8017eea: 6078         	str	r0, [r7, #0x4]
; 	(void)unschedule_locked(dwork);
 8017eec: 6878         	ldr	r0, [r7, #0x4]
 8017eee: f7ff ffd8    	bl	0x8017ea2 <unschedule_locked> @ imm = #-0x50
; 	return cancel_async_locked(&dwork->work);
 8017ef2: 687b         	ldr	r3, [r7, #0x4]
 8017ef4: 4618         	mov	r0, r3
 8017ef6: f7ff ff8c    	bl	0x8017e12 <cancel_async_locked> @ imm = #-0xe8
 8017efa: 4603         	mov	r3, r0
; }
 8017efc: 4618         	mov	r0, r3
 8017efe: 3708         	adds	r7, #0x8
 8017f00: 46bd         	mov	sp, r7
 8017f02: bd80         	pop	{r7, pc}

08017f04 <sys_dlist_init>:
; {
 8017f04: b480         	push	{r7}
 8017f06: b083         	sub	sp, #0xc
 8017f08: af00         	add	r7, sp, #0x0
 8017f0a: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8017f0c: 687b         	ldr	r3, [r7, #0x4]
 8017f0e: 687a         	ldr	r2, [r7, #0x4]
 8017f10: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8017f12: 687b         	ldr	r3, [r7, #0x4]
 8017f14: 687a         	ldr	r2, [r7, #0x4]
 8017f16: 605a         	str	r2, [r3, #0x4]
; }
 8017f18: bf00         	nop
 8017f1a: 370c         	adds	r7, #0xc
 8017f1c: 46bd         	mov	sp, r7
 8017f1e: bc80         	pop	{r7}
 8017f20: 4770         	bx	lr

08017f22 <sys_dnode_init>:
; {
 8017f22: b480         	push	{r7}
 8017f24: b083         	sub	sp, #0xc
 8017f26: af00         	add	r7, sp, #0x0
 8017f28: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8017f2a: 687b         	ldr	r3, [r7, #0x4]
 8017f2c: 2200         	movs	r2, #0x0
 8017f2e: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8017f30: 687b         	ldr	r3, [r7, #0x4]
 8017f32: 2200         	movs	r2, #0x0
 8017f34: 605a         	str	r2, [r3, #0x4]
; }
 8017f36: bf00         	nop
 8017f38: 370c         	adds	r7, #0xc
 8017f3a: 46bd         	mov	sp, r7
 8017f3c: bc80         	pop	{r7}
 8017f3e: 4770         	bx	lr

08017f40 <K_KERNEL_STACK_BUFFER>:
; {
 8017f40: b480         	push	{r7}
 8017f42: b083         	sub	sp, #0xc
 8017f44: af00         	add	r7, sp, #0x0
 8017f46: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 8017f48: 687b         	ldr	r3, [r7, #0x4]
; }
 8017f4a: 4618         	mov	r0, r3
 8017f4c: 370c         	adds	r7, #0xc
 8017f4e: 46bd         	mov	sp, r7
 8017f50: bc80         	pop	{r7}
 8017f52: 4770         	bx	lr

08017f54 <k_thread_start>:
; {
 8017f54: b580         	push	{r7, lr}
 8017f56: b082         	sub	sp, #0x8
 8017f58: af00         	add	r7, sp, #0x0
 8017f5a: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_start(thread);
 8017f5c: 6878         	ldr	r0, [r7, #0x4]
 8017f5e: f000 f880    	bl	0x8018062 <z_impl_k_thread_start> @ imm = #0x100
; }
 8017f62: bf00         	nop
 8017f64: 3708         	adds	r7, #0x8
 8017f66: 46bd         	mov	sp, r7
 8017f68: bd80         	pop	{r7, pc}

08017f6a <z_init_timeout>:
; {
 8017f6a: b580         	push	{r7, lr}
 8017f6c: b082         	sub	sp, #0x8
 8017f6e: af00         	add	r7, sp, #0x0
 8017f70: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 8017f72: 687b         	ldr	r3, [r7, #0x4]
 8017f74: 4618         	mov	r0, r3
 8017f76: f7ff ffd4    	bl	0x8017f22 <sys_dnode_init> @ imm = #-0x58
; }
 8017f7a: bf00         	nop
 8017f7c: 3708         	adds	r7, #0x8
 8017f7e: 46bd         	mov	sp, r7
 8017f80: bd80         	pop	{r7, pc}

08017f82 <z_init_thread_timeout>:
; {
 8017f82: b580         	push	{r7, lr}
 8017f84: b082         	sub	sp, #0x8
 8017f86: af00         	add	r7, sp, #0x0
 8017f88: 6078         	str	r0, [r7, #0x4]
; 	z_init_timeout(&thread_base->timeout);
 8017f8a: 687b         	ldr	r3, [r7, #0x4]
 8017f8c: 3318         	adds	r3, #0x18
 8017f8e: 4618         	mov	r0, r3
 8017f90: f7ff ffeb    	bl	0x8017f6a <z_init_timeout> @ imm = #-0x2a
; }
 8017f94: bf00         	nop
 8017f96: 3708         	adds	r7, #0x8
 8017f98: 46bd         	mov	sp, r7
 8017f9a: bd80         	pop	{r7, pc}

08017f9c <thread_schedule_new>:
; {
 8017f9c: b580         	push	{r7, lr}
 8017f9e: b084         	sub	sp, #0x10
 8017fa0: af00         	add	r7, sp, #0x0
 8017fa2: 60f8         	str	r0, [r7, #0xc]
 8017fa4: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 8017fa8: e9d7 2300    	ldrd	r2, r3, [r7]
 8017fac: f04f 0000    	mov.w	r0, #0x0
 8017fb0: f04f 0100    	mov.w	r1, #0x0
 8017fb4: 428b         	cmp	r3, r1
 8017fb6: bf08         	it	eq
 8017fb8: 4282         	cmpeq	r2, r0
 8017fba: d103         	bne	0x8017fc4 <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 8017fbc: 68f8         	ldr	r0, [r7, #0xc]
 8017fbe: f7ff ffc9    	bl	0x8017f54 <k_thread_start> @ imm = #-0x6e
 8017fc2: e004         	b	0x8017fce <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 8017fc4: e9d7 2300    	ldrd	r2, r3, [r7]
 8017fc8: 68f8         	ldr	r0, [r7, #0xc]
 8017fca: f7f4 fdef    	bl	0x800cbac <z_add_thread_timeout> @ imm = #-0xb422
; }
 8017fce: bf00         	nop
 8017fd0: 3710         	adds	r7, #0x10
 8017fd2: 46bd         	mov	sp, r7
 8017fd4: bd80         	pop	{r7, pc}

08017fd6 <z_waitq_init>:
; {
 8017fd6: b580         	push	{r7, lr}
 8017fd8: b082         	sub	sp, #0x8
 8017fda: af00         	add	r7, sp, #0x0
 8017fdc: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8017fde: 687b         	ldr	r3, [r7, #0x4]
 8017fe0: 4618         	mov	r0, r3
 8017fe2: f7ff ff8f    	bl	0x8017f04 <sys_dlist_init> @ imm = #-0xe2
; }
 8017fe6: bf00         	nop
 8017fe8: 3708         	adds	r7, #0x8
 8017fea: 46bd         	mov	sp, r7
 8017fec: bd80         	pop	{r7, pc}

08017fee <z_log_msg_runtime_create>:
; {
 8017fee: b580         	push	{r7, lr}
 8017ff0: b08a         	sub	sp, #0x28
 8017ff2: af04         	add	r7, sp, #0x10
 8017ff4: 60b9         	str	r1, [r7, #0x8]
 8017ff6: 607b         	str	r3, [r7, #0x4]
 8017ff8: 4603         	mov	r3, r0
 8017ffa: 73fb         	strb	r3, [r7, #0xf]
 8017ffc: 4613         	mov	r3, r2
 8017ffe: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8018000: f107 032c    	add.w	r3, r7, #0x2c
 8018004: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8018006: 7bba         	ldrb	r2, [r7, #0xe]
 8018008: 7bf8         	ldrb	r0, [r7, #0xf]
 801800a: 697b         	ldr	r3, [r7, #0x14]
 801800c: 9303         	str	r3, [sp, #0xc]
 801800e: 6abb         	ldr	r3, [r7, #0x28]
 8018010: 9302         	str	r3, [sp, #0x8]
 8018012: 6a7b         	ldr	r3, [r7, #0x24]
 8018014: 9301         	str	r3, [sp, #0x4]
 8018016: 6a3b         	ldr	r3, [r7, #0x20]
 8018018: 9300         	str	r3, [sp]
 801801a: 687b         	ldr	r3, [r7, #0x4]
 801801c: 68b9         	ldr	r1, [r7, #0x8]
 801801e: f7ea f895    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0x15ed6
; }
 8018022: bf00         	nop
 8018024: 3718         	adds	r7, #0x18
 8018026: 46bd         	mov	sp, r7
 8018028: bd80         	pop	{r7, pc}

0801802a <k_is_in_isr>:
; {
 801802a: b480         	push	{r7}
 801802c: b083         	sub	sp, #0xc
 801802e: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8018030: f3ef 8305    	mrs	r3, ipsr
 8018034: 607b         	str	r3, [r7, #0x4]
;   return(result);
 8018036: 687b         	ldr	r3, [r7, #0x4]
; 	return (__get_IPSR()) ? (true) : (false);
 8018038: 2b00         	cmp	r3, #0x0
 801803a: bf14         	ite	ne
 801803c: 2301         	movne	r3, #0x1
 801803e: 2300         	moveq	r3, #0x0
 8018040: b2db         	uxtb	r3, r3
; }
 8018042: 4618         	mov	r0, r3
 8018044: 370c         	adds	r7, #0xc
 8018046: 46bd         	mov	sp, r7
 8018048: bc80         	pop	{r7}
 801804a: 4770         	bx	lr

0801804c <k_thread_name_get>:
; {
 801804c: b480         	push	{r7}
 801804e: b083         	sub	sp, #0xc
 8018050: af00         	add	r7, sp, #0x0
 8018052: 6078         	str	r0, [r7, #0x4]
; 	return (const char *)thread->name;
 8018054: 687b         	ldr	r3, [r7, #0x4]
 8018056: 3394         	adds	r3, #0x94
; }
 8018058: 4618         	mov	r0, r3
 801805a: 370c         	adds	r7, #0xc
 801805c: 46bd         	mov	sp, r7
 801805e: bc80         	pop	{r7}
 8018060: 4770         	bx	lr

08018062 <z_impl_k_thread_start>:
; {
 8018062: b580         	push	{r7, lr}
 8018064: b082         	sub	sp, #0x8
 8018066: af00         	add	r7, sp, #0x0
 8018068: 6078         	str	r0, [r7, #0x4]
; 	z_sched_start(thread);
 801806a: 6878         	ldr	r0, [r7, #0x4]
 801806c: f7f5 f92e    	bl	0x800d2cc <z_sched_start> @ imm = #-0xada4
; }
 8018070: bf00         	nop
 8018072: 3708         	adds	r7, #0x8
 8018074: 46bd         	mov	sp, r7
 8018076: bd80         	pop	{r7, pc}

08018078 <z_impl_k_thread_create>:
; {
 8018078: b580         	push	{r7, lr}
 801807a: b08a         	sub	sp, #0x28
 801807c: af06         	add	r7, sp, #0x18
 801807e: 60f8         	str	r0, [r7, #0xc]
 8018080: 60b9         	str	r1, [r7, #0x8]
 8018082: 607a         	str	r2, [r7, #0x4]
 8018084: 603b         	str	r3, [r7]
; 	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 8018086: 2300         	movs	r3, #0x0
 8018088: 9305         	str	r3, [sp, #0x14]
 801808a: 6abb         	ldr	r3, [r7, #0x28]
 801808c: 9304         	str	r3, [sp, #0x10]
 801808e: 6a7b         	ldr	r3, [r7, #0x24]
 8018090: 9303         	str	r3, [sp, #0xc]
 8018092: 6a3b         	ldr	r3, [r7, #0x20]
 8018094: 9302         	str	r3, [sp, #0x8]
 8018096: 69fb         	ldr	r3, [r7, #0x1c]
 8018098: 9301         	str	r3, [sp, #0x4]
 801809a: 69bb         	ldr	r3, [r7, #0x18]
 801809c: 9300         	str	r3, [sp]
 801809e: 683b         	ldr	r3, [r7]
 80180a0: 687a         	ldr	r2, [r7, #0x4]
 80180a2: 68b9         	ldr	r1, [r7, #0x8]
 80180a4: 68f8         	ldr	r0, [r7, #0xc]
 80180a6: f7f4 fe23    	bl	0x800ccf0 <z_setup_new_thread> @ imm = #-0xb3ba
; 	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
 80180aa: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 80180ae: f04f 30ff    	mov.w	r0, #0xffffffff
 80180b2: f04f 31ff    	mov.w	r1, #0xffffffff
 80180b6: 428b         	cmp	r3, r1
 80180b8: bf08         	it	eq
 80180ba: 4282         	cmpeq	r2, r0
 80180bc: d004         	beq	0x80180c8 <z_impl_k_thread_create+0x50> @ imm = #0x8
; 		thread_schedule_new(new_thread, delay);
 80180be: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 80180c2: 68f8         	ldr	r0, [r7, #0xc]
 80180c4: f7ff ff6a    	bl	0x8017f9c <thread_schedule_new> @ imm = #-0x12c
; 	return new_thread;
 80180c8: 68fb         	ldr	r3, [r7, #0xc]
; }
 80180ca: 4618         	mov	r0, r3
 80180cc: 3710         	adds	r7, #0x10
 80180ce: 46bd         	mov	sp, r7
 80180d0: bd80         	pop	{r7, pc}

080180d2 <z_init_thread_base>:
; {
 80180d2: b580         	push	{r7, lr}
 80180d4: b084         	sub	sp, #0x10
 80180d6: af00         	add	r7, sp, #0x0
 80180d8: 60f8         	str	r0, [r7, #0xc]
 80180da: 60b9         	str	r1, [r7, #0x8]
 80180dc: 607a         	str	r2, [r7, #0x4]
 80180de: 603b         	str	r3, [r7]
; 	thread_base->pended_on = NULL;
 80180e0: 68fb         	ldr	r3, [r7, #0xc]
 80180e2: 2200         	movs	r2, #0x0
 80180e4: 609a         	str	r2, [r3, #0x8]
; 	thread_base->user_options = (uint8_t)options;
 80180e6: 683b         	ldr	r3, [r7]
 80180e8: b2da         	uxtb	r2, r3
 80180ea: 68fb         	ldr	r3, [r7, #0xc]
 80180ec: 731a         	strb	r2, [r3, #0xc]
; 	thread_base->thread_state = (uint8_t)initial_state;
 80180ee: 687b         	ldr	r3, [r7, #0x4]
 80180f0: b2da         	uxtb	r2, r3
 80180f2: 68fb         	ldr	r3, [r7, #0xc]
 80180f4: 735a         	strb	r2, [r3, #0xd]
; 	thread_base->prio = priority;
 80180f6: 68bb         	ldr	r3, [r7, #0x8]
 80180f8: b25a         	sxtb	r2, r3
 80180fa: 68fb         	ldr	r3, [r7, #0xc]
 80180fc: 739a         	strb	r2, [r3, #0xe]
; 	thread_base->sched_locked = 0U;
 80180fe: 68fb         	ldr	r3, [r7, #0xc]
 8018100: 2200         	movs	r2, #0x0
 8018102: 73da         	strb	r2, [r3, #0xf]
; 	z_init_thread_timeout(thread_base);
 8018104: 68f8         	ldr	r0, [r7, #0xc]
 8018106: f7ff ff3c    	bl	0x8017f82 <z_init_thread_timeout> @ imm = #-0x188
; }
 801810a: bf00         	nop
 801810c: 3710         	adds	r7, #0x10
 801810e: 46bd         	mov	sp, r7
 8018110: bd80         	pop	{r7, pc}

08018112 <z_thread_mark_switched_out>:
; {
 8018112: b580         	push	{r7, lr}
 8018114: af00         	add	r7, sp, #0x0
; 	z_sched_usage_stop();
 8018116: f7f6 fe5b    	bl	0x800edd0 <z_sched_usage_stop> @ imm = #-0x934a
; }
 801811a: bf00         	nop
 801811c: bd80         	pop	{r7, pc}

0801811e <sys_dlist_init>:
; {
 801811e: b480         	push	{r7}
 8018120: b083         	sub	sp, #0xc
 8018122: af00         	add	r7, sp, #0x0
 8018124: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8018126: 687b         	ldr	r3, [r7, #0x4]
 8018128: 687a         	ldr	r2, [r7, #0x4]
 801812a: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 801812c: 687b         	ldr	r3, [r7, #0x4]
 801812e: 687a         	ldr	r2, [r7, #0x4]
 8018130: 605a         	str	r2, [r3, #0x4]
; }
 8018132: bf00         	nop
 8018134: 370c         	adds	r7, #0xc
 8018136: 46bd         	mov	sp, r7
 8018138: bc80         	pop	{r7}
 801813a: 4770         	bx	lr

0801813c <sys_dnode_init>:
; {
 801813c: b480         	push	{r7}
 801813e: b083         	sub	sp, #0xc
 8018140: af00         	add	r7, sp, #0x0
 8018142: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8018144: 687b         	ldr	r3, [r7, #0x4]
 8018146: 2200         	movs	r2, #0x0
 8018148: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801814a: 687b         	ldr	r3, [r7, #0x4]
 801814c: 2200         	movs	r2, #0x0
 801814e: 605a         	str	r2, [r3, #0x4]
; }
 8018150: bf00         	nop
 8018152: 370c         	adds	r7, #0xc
 8018154: 46bd         	mov	sp, r7
 8018156: bc80         	pop	{r7}
 8018158: 4770         	bx	lr

0801815a <sys_dnode_is_linked>:
; {
 801815a: b480         	push	{r7}
 801815c: b083         	sub	sp, #0xc
 801815e: af00         	add	r7, sp, #0x0
 8018160: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 8018162: 687b         	ldr	r3, [r7, #0x4]
 8018164: 681b         	ldr	r3, [r3]
 8018166: 2b00         	cmp	r3, #0x0
 8018168: bf14         	ite	ne
 801816a: 2301         	movne	r3, #0x1
 801816c: 2300         	moveq	r3, #0x0
 801816e: b2db         	uxtb	r3, r3
; }
 8018170: 4618         	mov	r0, r3
 8018172: 370c         	adds	r7, #0xc
 8018174: 46bd         	mov	sp, r7
 8018176: bc80         	pop	{r7}
 8018178: 4770         	bx	lr

0801817a <sys_dlist_is_empty>:
; {
 801817a: b480         	push	{r7}
 801817c: b083         	sub	sp, #0xc
 801817e: af00         	add	r7, sp, #0x0
 8018180: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8018182: 687b         	ldr	r3, [r7, #0x4]
 8018184: 681b         	ldr	r3, [r3]
 8018186: 687a         	ldr	r2, [r7, #0x4]
 8018188: 429a         	cmp	r2, r3
 801818a: bf0c         	ite	eq
 801818c: 2301         	moveq	r3, #0x1
 801818e: 2300         	movne	r3, #0x0
 8018190: b2db         	uxtb	r3, r3
; }
 8018192: 4618         	mov	r0, r3
 8018194: 370c         	adds	r7, #0xc
 8018196: 46bd         	mov	sp, r7
 8018198: bc80         	pop	{r7}
 801819a: 4770         	bx	lr

0801819c <sys_dlist_peek_head>:
; {
 801819c: b580         	push	{r7, lr}
 801819e: b082         	sub	sp, #0x8
 80181a0: af00         	add	r7, sp, #0x0
 80181a2: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 80181a4: 6878         	ldr	r0, [r7, #0x4]
 80181a6: f7ff ffe8    	bl	0x801817a <sys_dlist_is_empty> @ imm = #-0x30
 80181aa: 4603         	mov	r3, r0
 80181ac: 2b00         	cmp	r3, #0x0
 80181ae: d102         	bne	0x80181b6 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 80181b0: 687b         	ldr	r3, [r7, #0x4]
 80181b2: 681b         	ldr	r3, [r3]
 80181b4: e000         	b	0x80181b8 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 80181b6: 2300         	movs	r3, #0x0
; }
 80181b8: 4618         	mov	r0, r3
 80181ba: 3708         	adds	r7, #0x8
 80181bc: 46bd         	mov	sp, r7
 80181be: bd80         	pop	{r7, pc}

080181c0 <sys_dlist_peek_next_no_check>:
; {
 80181c0: b480         	push	{r7}
 80181c2: b083         	sub	sp, #0xc
 80181c4: af00         	add	r7, sp, #0x0
 80181c6: 6078         	str	r0, [r7, #0x4]
 80181c8: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 80181ca: 687b         	ldr	r3, [r7, #0x4]
 80181cc: 685b         	ldr	r3, [r3, #0x4]
 80181ce: 683a         	ldr	r2, [r7]
 80181d0: 429a         	cmp	r2, r3
 80181d2: d002         	beq	0x80181da <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 80181d4: 683b         	ldr	r3, [r7]
 80181d6: 681b         	ldr	r3, [r3]
 80181d8: e000         	b	0x80181dc <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 80181da: 2300         	movs	r3, #0x0
; }
 80181dc: 4618         	mov	r0, r3
 80181de: 370c         	adds	r7, #0xc
 80181e0: 46bd         	mov	sp, r7
 80181e2: bc80         	pop	{r7}
 80181e4: 4770         	bx	lr

080181e6 <sys_dlist_peek_next>:
; {
 80181e6: b580         	push	{r7, lr}
 80181e8: b082         	sub	sp, #0x8
 80181ea: af00         	add	r7, sp, #0x0
 80181ec: 6078         	str	r0, [r7, #0x4]
 80181ee: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 80181f0: 683b         	ldr	r3, [r7]
 80181f2: 2b00         	cmp	r3, #0x0
 80181f4: d005         	beq	0x8018202 <sys_dlist_peek_next+0x1c> @ imm = #0xa
 80181f6: 6839         	ldr	r1, [r7]
 80181f8: 6878         	ldr	r0, [r7, #0x4]
 80181fa: f7ff ffe1    	bl	0x80181c0 <sys_dlist_peek_next_no_check> @ imm = #-0x3e
 80181fe: 4603         	mov	r3, r0
 8018200: e000         	b	0x8018204 <sys_dlist_peek_next+0x1e> @ imm = #0x0
 8018202: 2300         	movs	r3, #0x0
; }
 8018204: 4618         	mov	r0, r3
 8018206: 3708         	adds	r7, #0x8
 8018208: 46bd         	mov	sp, r7
 801820a: bd80         	pop	{r7, pc}

0801820c <sys_dlist_append>:
; {
 801820c: b480         	push	{r7}
 801820e: b085         	sub	sp, #0x14
 8018210: af00         	add	r7, sp, #0x0
 8018212: 6078         	str	r0, [r7, #0x4]
 8018214: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 8018216: 687b         	ldr	r3, [r7, #0x4]
 8018218: 685b         	ldr	r3, [r3, #0x4]
 801821a: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 801821c: 683b         	ldr	r3, [r7]
 801821e: 687a         	ldr	r2, [r7, #0x4]
 8018220: 601a         	str	r2, [r3]
; 	node->prev = tail;
 8018222: 683b         	ldr	r3, [r7]
 8018224: 68fa         	ldr	r2, [r7, #0xc]
 8018226: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 8018228: 68fb         	ldr	r3, [r7, #0xc]
 801822a: 683a         	ldr	r2, [r7]
 801822c: 601a         	str	r2, [r3]
; 	list->tail = node;
 801822e: 687b         	ldr	r3, [r7, #0x4]
 8018230: 683a         	ldr	r2, [r7]
 8018232: 605a         	str	r2, [r3, #0x4]
; }
 8018234: bf00         	nop
 8018236: 3714         	adds	r7, #0x14
 8018238: 46bd         	mov	sp, r7
 801823a: bc80         	pop	{r7}
 801823c: 4770         	bx	lr

0801823e <sys_dlist_insert>:
; {
 801823e: b480         	push	{r7}
 8018240: b085         	sub	sp, #0x14
 8018242: af00         	add	r7, sp, #0x0
 8018244: 6078         	str	r0, [r7, #0x4]
 8018246: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 8018248: 687b         	ldr	r3, [r7, #0x4]
 801824a: 685b         	ldr	r3, [r3, #0x4]
 801824c: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 801824e: 683b         	ldr	r3, [r7]
 8018250: 68fa         	ldr	r2, [r7, #0xc]
 8018252: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 8018254: 683b         	ldr	r3, [r7]
 8018256: 687a         	ldr	r2, [r7, #0x4]
 8018258: 601a         	str	r2, [r3]
; 	prev->next = node;
 801825a: 68fb         	ldr	r3, [r7, #0xc]
 801825c: 683a         	ldr	r2, [r7]
 801825e: 601a         	str	r2, [r3]
; 	successor->prev = node;
 8018260: 687b         	ldr	r3, [r7, #0x4]
 8018262: 683a         	ldr	r2, [r7]
 8018264: 605a         	str	r2, [r3, #0x4]
; }
 8018266: bf00         	nop
 8018268: 3714         	adds	r7, #0x14
 801826a: 46bd         	mov	sp, r7
 801826c: bc80         	pop	{r7}
 801826e: 4770         	bx	lr

08018270 <sys_dlist_remove>:
; {
 8018270: b580         	push	{r7, lr}
 8018272: b084         	sub	sp, #0x10
 8018274: af00         	add	r7, sp, #0x0
 8018276: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8018278: 687b         	ldr	r3, [r7, #0x4]
 801827a: 685b         	ldr	r3, [r3, #0x4]
 801827c: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 801827e: 687b         	ldr	r3, [r7, #0x4]
 8018280: 681b         	ldr	r3, [r3]
 8018282: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8018284: 68fb         	ldr	r3, [r7, #0xc]
 8018286: 68ba         	ldr	r2, [r7, #0x8]
 8018288: 601a         	str	r2, [r3]
; 	next->prev = prev;
 801828a: 68bb         	ldr	r3, [r7, #0x8]
 801828c: 68fa         	ldr	r2, [r7, #0xc]
 801828e: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8018290: 6878         	ldr	r0, [r7, #0x4]
 8018292: f7ff ff53    	bl	0x801813c <sys_dnode_init> @ imm = #-0x15a
; }
 8018296: bf00         	nop
 8018298: 3710         	adds	r7, #0x10
 801829a: 46bd         	mov	sp, r7
 801829c: bd80         	pop	{r7, pc}

0801829e <k_yield>:
; {
 801829e: b580         	push	{r7, lr}
 80182a0: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 80182a2: f7f5 fd33    	bl	0x800dd0c <z_impl_k_yield> @ imm = #-0xa59a
; }
 80182a6: bf00         	nop
 80182a8: bd80         	pop	{r7, pc}

080182aa <k_thread_suspend>:
; {
 80182aa: b580         	push	{r7, lr}
 80182ac: b082         	sub	sp, #0x8
 80182ae: af00         	add	r7, sp, #0x0
 80182b0: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_suspend(thread);
 80182b2: 6878         	ldr	r0, [r7, #0x4]
 80182b4: f7f5 f92e    	bl	0x800d514 <z_impl_k_thread_suspend> @ imm = #-0xada4
; }
 80182b8: bf00         	nop
 80182ba: 3708         	adds	r7, #0x8
 80182bc: 46bd         	mov	sp, r7
 80182be: bd80         	pop	{r7, pc}

080182c0 <z_is_inactive_timeout>:
; {
 80182c0: b580         	push	{r7, lr}
 80182c2: b082         	sub	sp, #0x8
 80182c4: af00         	add	r7, sp, #0x0
 80182c6: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 80182c8: 687b         	ldr	r3, [r7, #0x4]
 80182ca: 4618         	mov	r0, r3
 80182cc: f7ff ff45    	bl	0x801815a <sys_dnode_is_linked> @ imm = #-0x176
 80182d0: 4603         	mov	r3, r0
 80182d2: 2b00         	cmp	r3, #0x0
 80182d4: bf14         	ite	ne
 80182d6: 2301         	movne	r3, #0x1
 80182d8: 2300         	moveq	r3, #0x0
 80182da: b2db         	uxtb	r3, r3
 80182dc: f083 0301    	eor	r3, r3, #0x1
 80182e0: b2db         	uxtb	r3, r3
 80182e2: f003 0301    	and	r3, r3, #0x1
 80182e6: b2db         	uxtb	r3, r3
; }
 80182e8: 4618         	mov	r0, r3
 80182ea: 3708         	adds	r7, #0x8
 80182ec: 46bd         	mov	sp, r7
 80182ee: bd80         	pop	{r7, pc}

080182f0 <z_abort_thread_timeout>:
; {
 80182f0: b580         	push	{r7, lr}
 80182f2: b082         	sub	sp, #0x8
 80182f4: af00         	add	r7, sp, #0x0
 80182f6: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 80182f8: 687b         	ldr	r3, [r7, #0x4]
 80182fa: 3318         	adds	r3, #0x18
 80182fc: 4618         	mov	r0, r3
 80182fe: f7f6 fbbd    	bl	0x800ea7c <z_abort_timeout> @ imm = #-0x9886
 8018302: 4603         	mov	r3, r0
; }
 8018304: 4618         	mov	r0, r3
 8018306: 3708         	adds	r7, #0x8
 8018308: 46bd         	mov	sp, r7
 801830a: bd80         	pop	{r7, pc}

0801830c <thread_is_preemptible>:
; {
 801830c: b480         	push	{r7}
 801830e: b083         	sub	sp, #0xc
 8018310: af00         	add	r7, sp, #0x0
 8018312: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 8018314: 687b         	ldr	r3, [r7, #0x4]
 8018316: 89db         	ldrh	r3, [r3, #0xe]
 8018318: 2b7f         	cmp	r3, #0x7f
 801831a: bf94         	ite	ls
 801831c: 2301         	movls	r3, #0x1
 801831e: 2300         	movhi	r3, #0x0
 8018320: b2db         	uxtb	r3, r3
; }
 8018322: 4618         	mov	r0, r3
 8018324: 370c         	adds	r7, #0xc
 8018326: 46bd         	mov	sp, r7
 8018328: bc80         	pop	{r7}
 801832a: 4770         	bx	lr

0801832c <thread_is_metairq>:
; {
 801832c: b480         	push	{r7}
 801832e: b083         	sub	sp, #0xc
 8018330: af00         	add	r7, sp, #0x0
 8018332: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8018334: 2300         	movs	r3, #0x0
; }
 8018336: 4618         	mov	r0, r3
 8018338: 370c         	adds	r7, #0xc
 801833a: 46bd         	mov	sp, r7
 801833c: bc80         	pop	{r7}
 801833e: 4770         	bx	lr

08018340 <z_is_thread_prevented_from_running>:
; {
 8018340: b480         	push	{r7}
 8018342: b085         	sub	sp, #0x14
 8018344: af00         	add	r7, sp, #0x0
 8018346: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 8018348: 687b         	ldr	r3, [r7, #0x4]
 801834a: 7b5b         	ldrb	r3, [r3, #0xd]
 801834c: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
 801834e: 7bfb         	ldrb	r3, [r7, #0xf]
 8018350: f003 031f    	and	r3, r3, #0x1f
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 8018354: 2b00         	cmp	r3, #0x0
 8018356: bf14         	ite	ne
 8018358: 2301         	movne	r3, #0x1
 801835a: 2300         	moveq	r3, #0x0
 801835c: b2db         	uxtb	r3, r3
; }
 801835e: 4618         	mov	r0, r3
 8018360: 3714         	adds	r7, #0x14
 8018362: 46bd         	mov	sp, r7
 8018364: bc80         	pop	{r7}
 8018366: 4770         	bx	lr

08018368 <z_is_thread_timeout_active>:
; {
 8018368: b580         	push	{r7, lr}
 801836a: b082         	sub	sp, #0x8
 801836c: af00         	add	r7, sp, #0x0
 801836e: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 8018370: 687b         	ldr	r3, [r7, #0x4]
 8018372: 3318         	adds	r3, #0x18
 8018374: 4618         	mov	r0, r3
 8018376: f7ff ffa3    	bl	0x80182c0 <z_is_inactive_timeout> @ imm = #-0xba
 801837a: 4603         	mov	r3, r0
 801837c: 2b00         	cmp	r3, #0x0
 801837e: bf14         	ite	ne
 8018380: 2301         	movne	r3, #0x1
 8018382: 2300         	moveq	r3, #0x0
 8018384: b2db         	uxtb	r3, r3
 8018386: f083 0301    	eor	r3, r3, #0x1
 801838a: b2db         	uxtb	r3, r3
 801838c: f003 0301    	and	r3, r3, #0x1
 8018390: b2db         	uxtb	r3, r3
; }
 8018392: 4618         	mov	r0, r3
 8018394: 3708         	adds	r7, #0x8
 8018396: 46bd         	mov	sp, r7
 8018398: bd80         	pop	{r7, pc}

0801839a <z_is_thread_ready>:
; {
 801839a: b580         	push	{r7, lr}
 801839c: b082         	sub	sp, #0x8
 801839e: af00         	add	r7, sp, #0x0
 80183a0: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 80183a2: 6878         	ldr	r0, [r7, #0x4]
 80183a4: f7ff ffcc    	bl	0x8018340 <z_is_thread_prevented_from_running> @ imm = #-0x68
 80183a8: 4603         	mov	r3, r0
 80183aa: f083 0301    	eor	r3, r3, #0x1
 80183ae: b2db         	uxtb	r3, r3
 80183b0: 2b00         	cmp	r3, #0x0
 80183b2: d00a         	beq	0x80183ca <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 80183b4: 6878         	ldr	r0, [r7, #0x4]
 80183b6: f7ff ffd7    	bl	0x8018368 <z_is_thread_timeout_active> @ imm = #-0x52
 80183ba: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 80183bc: f083 0301    	eor	r3, r3, #0x1
 80183c0: b2db         	uxtb	r3, r3
 80183c2: 2b00         	cmp	r3, #0x0
 80183c4: d001         	beq	0x80183ca <z_is_thread_ready+0x30> @ imm = #0x2
 80183c6: 2301         	movs	r3, #0x1
 80183c8: e000         	b	0x80183cc <z_is_thread_ready+0x32> @ imm = #0x0
 80183ca: 2300         	movs	r3, #0x0
 80183cc: f003 0301    	and	r3, r3, #0x1
 80183d0: b2db         	uxtb	r3, r3
; }
 80183d2: 4618         	mov	r0, r3
 80183d4: 3708         	adds	r7, #0x8
 80183d6: 46bd         	mov	sp, r7
 80183d8: bd80         	pop	{r7, pc}

080183da <z_has_thread_started>:
; {
 80183da: b480         	push	{r7}
 80183dc: b083         	sub	sp, #0xc
 80183de: af00         	add	r7, sp, #0x0
 80183e0: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
 80183e2: 687b         	ldr	r3, [r7, #0x4]
 80183e4: 7b5b         	ldrb	r3, [r3, #0xd]
 80183e6: f003 0304    	and	r3, r3, #0x4
 80183ea: 2b00         	cmp	r3, #0x0
 80183ec: bf0c         	ite	eq
 80183ee: 2301         	moveq	r3, #0x1
 80183f0: 2300         	movne	r3, #0x0
 80183f2: b2db         	uxtb	r3, r3
; }
 80183f4: 4618         	mov	r0, r3
 80183f6: 370c         	adds	r7, #0xc
 80183f8: 46bd         	mov	sp, r7
 80183fa: bc80         	pop	{r7}
 80183fc: 4770         	bx	lr

080183fe <z_is_thread_state_set>:
; {
 80183fe: b480         	push	{r7}
 8018400: b083         	sub	sp, #0xc
 8018402: af00         	add	r7, sp, #0x0
 8018404: 6078         	str	r0, [r7, #0x4]
 8018406: 6039         	str	r1, [r7]
; 	return (thread->base.thread_state & state) != 0U;
 8018408: 687b         	ldr	r3, [r7, #0x4]
 801840a: 7b5b         	ldrb	r3, [r3, #0xd]
 801840c: 461a         	mov	r2, r3
 801840e: 683b         	ldr	r3, [r7]
 8018410: 4013         	ands	r3, r2
 8018412: 2b00         	cmp	r3, #0x0
 8018414: bf14         	ite	ne
 8018416: 2301         	movne	r3, #0x1
 8018418: 2300         	moveq	r3, #0x0
 801841a: b2db         	uxtb	r3, r3
; }
 801841c: 4618         	mov	r0, r3
 801841e: 370c         	adds	r7, #0xc
 8018420: 46bd         	mov	sp, r7
 8018422: bc80         	pop	{r7}
 8018424: 4770         	bx	lr

08018426 <z_is_thread_queued>:
; {
 8018426: b580         	push	{r7, lr}
 8018428: b082         	sub	sp, #0x8
 801842a: af00         	add	r7, sp, #0x0
 801842c: 6078         	str	r0, [r7, #0x4]
; 	return z_is_thread_state_set(thread, _THREAD_QUEUED);
 801842e: 2180         	movs	r1, #0x80
 8018430: 6878         	ldr	r0, [r7, #0x4]
 8018432: f7ff ffe4    	bl	0x80183fe <z_is_thread_state_set> @ imm = #-0x38
 8018436: 4603         	mov	r3, r0
; }
 8018438: 4618         	mov	r0, r3
 801843a: 3708         	adds	r7, #0x8
 801843c: 46bd         	mov	sp, r7
 801843e: bd80         	pop	{r7, pc}

08018440 <z_mark_thread_as_suspended>:
; {
 8018440: b480         	push	{r7}
 8018442: b083         	sub	sp, #0xc
 8018444: af00         	add	r7, sp, #0x0
 8018446: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_SUSPENDED;
 8018448: 687b         	ldr	r3, [r7, #0x4]
 801844a: 7b5b         	ldrb	r3, [r3, #0xd]
 801844c: f043 0310    	orr	r3, r3, #0x10
 8018450: b2da         	uxtb	r2, r3
 8018452: 687b         	ldr	r3, [r7, #0x4]
 8018454: 735a         	strb	r2, [r3, #0xd]
; }
 8018456: bf00         	nop
 8018458: 370c         	adds	r7, #0xc
 801845a: 46bd         	mov	sp, r7
 801845c: bc80         	pop	{r7}
 801845e: 4770         	bx	lr

08018460 <z_mark_thread_as_not_suspended>:
; {
 8018460: b480         	push	{r7}
 8018462: b083         	sub	sp, #0xc
 8018464: af00         	add	r7, sp, #0x0
 8018466: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 8018468: 687b         	ldr	r3, [r7, #0x4]
 801846a: 7b5b         	ldrb	r3, [r3, #0xd]
 801846c: f023 0310    	bic	r3, r3, #0x10
 8018470: b2da         	uxtb	r2, r3
 8018472: 687b         	ldr	r3, [r7, #0x4]
 8018474: 735a         	strb	r2, [r3, #0xd]
; }
 8018476: bf00         	nop
 8018478: 370c         	adds	r7, #0xc
 801847a: 46bd         	mov	sp, r7
 801847c: bc80         	pop	{r7}
 801847e: 4770         	bx	lr

08018480 <z_mark_thread_as_started>:
; {
 8018480: b480         	push	{r7}
 8018482: b083         	sub	sp, #0xc
 8018484: af00         	add	r7, sp, #0x0
 8018486: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PRESTART;
 8018488: 687b         	ldr	r3, [r7, #0x4]
 801848a: 7b5b         	ldrb	r3, [r3, #0xd]
 801848c: f023 0304    	bic	r3, r3, #0x4
 8018490: b2da         	uxtb	r2, r3
 8018492: 687b         	ldr	r3, [r7, #0x4]
 8018494: 735a         	strb	r2, [r3, #0xd]
; }
 8018496: bf00         	nop
 8018498: 370c         	adds	r7, #0xc
 801849a: 46bd         	mov	sp, r7
 801849c: bc80         	pop	{r7}
 801849e: 4770         	bx	lr

080184a0 <z_mark_thread_as_pending>:
; {
 80184a0: b480         	push	{r7}
 80184a2: b083         	sub	sp, #0xc
 80184a4: af00         	add	r7, sp, #0x0
 80184a6: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_PENDING;
 80184a8: 687b         	ldr	r3, [r7, #0x4]
 80184aa: 7b5b         	ldrb	r3, [r3, #0xd]
 80184ac: f043 0302    	orr	r3, r3, #0x2
 80184b0: b2da         	uxtb	r2, r3
 80184b2: 687b         	ldr	r3, [r7, #0x4]
 80184b4: 735a         	strb	r2, [r3, #0xd]
; }
 80184b6: bf00         	nop
 80184b8: 370c         	adds	r7, #0xc
 80184ba: 46bd         	mov	sp, r7
 80184bc: bc80         	pop	{r7}
 80184be: 4770         	bx	lr

080184c0 <z_mark_thread_as_not_pending>:
; {
 80184c0: b480         	push	{r7}
 80184c2: b083         	sub	sp, #0xc
 80184c4: af00         	add	r7, sp, #0x0
 80184c6: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 80184c8: 687b         	ldr	r3, [r7, #0x4]
 80184ca: 7b5b         	ldrb	r3, [r3, #0xd]
 80184cc: f023 0302    	bic	r3, r3, #0x2
 80184d0: b2da         	uxtb	r2, r3
 80184d2: 687b         	ldr	r3, [r7, #0x4]
 80184d4: 735a         	strb	r2, [r3, #0xd]
; }
 80184d6: bf00         	nop
 80184d8: 370c         	adds	r7, #0xc
 80184da: 46bd         	mov	sp, r7
 80184dc: bc80         	pop	{r7}
 80184de: 4770         	bx	lr

080184e0 <z_is_thread_essential>:
; {
 80184e0: b480         	push	{r7}
 80184e2: b083         	sub	sp, #0xc
 80184e4: af00         	add	r7, sp, #0x0
 80184e6: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
 80184e8: 687b         	ldr	r3, [r7, #0x4]
 80184ea: 7b1b         	ldrb	r3, [r3, #0xc]
 80184ec: f003 0301    	and	r3, r3, #0x1
 80184f0: 2b00         	cmp	r3, #0x0
 80184f2: bf14         	ite	ne
 80184f4: 2301         	movne	r3, #0x1
 80184f6: 2300         	moveq	r3, #0x0
 80184f8: b2db         	uxtb	r3, r3
; }
 80184fa: 4618         	mov	r0, r3
 80184fc: 370c         	adds	r7, #0xc
 80184fe: 46bd         	mov	sp, r7
 8018500: bc80         	pop	{r7}
 8018502: 4770         	bx	lr

08018504 <z_reschedule_unlocked>:
; {
 8018504: b580         	push	{r7, lr}
 8018506: b084         	sub	sp, #0x10
 8018508: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801850a: f3ef 8311    	mrs	r3, basepri
 801850e: 60fb         	str	r3, [r7, #0xc]
;   return(result);
 8018510: 68fb         	ldr	r3, [r7, #0xc]
; 	key = __get_BASEPRI();
 8018512: 60bb         	str	r3, [r7, #0x8]
 8018514: 2310         	movs	r3, #0x10
 8018516: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8018518: 687b         	ldr	r3, [r7, #0x4]
 801851a: f383 8812    	msr	basepri_max, r3
; }
 801851e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8018520: f3bf 8f6f    	isb	sy
; }
 8018524: bf00         	nop
; 	return key;
 8018526: 68bb         	ldr	r3, [r7, #0x8]
; 	(void) z_reschedule_irqlock(arch_irq_lock());
 8018528: 4618         	mov	r0, r3
 801852a: f000 f9b0    	bl	0x801888e <z_reschedule_irqlock> @ imm = #0x360
; }
 801852e: bf00         	nop
 8018530: 3710         	adds	r7, #0x10
 8018532: 46bd         	mov	sp, r7
 8018534: bd80         	pop	{r7, pc}

08018536 <unpend_thread_no_timeout>:
; {
 8018536: b580         	push	{r7, lr}
 8018538: b086         	sub	sp, #0x18
 801853a: af00         	add	r7, sp, #0x0
 801853c: 6078         	str	r0, [r7, #0x4]
 801853e: 687b         	ldr	r3, [r7, #0x4]
 8018540: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8018542: 68fb         	ldr	r3, [r7, #0xc]
 8018544: 689b         	ldr	r3, [r3, #0x8]
 8018546: 617b         	str	r3, [r7, #0x14]
 8018548: 687b         	ldr	r3, [r7, #0x4]
 801854a: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 801854c: 693b         	ldr	r3, [r7, #0x10]
 801854e: 4618         	mov	r0, r3
 8018550: f7ff fe8e    	bl	0x8018270 <sys_dlist_remove> @ imm = #-0x2e4
; }
 8018554: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8018556: 6878         	ldr	r0, [r7, #0x4]
 8018558: f7ff ffb2    	bl	0x80184c0 <z_mark_thread_as_not_pending> @ imm = #-0x9c
; 	thread->base.pended_on = NULL;
 801855c: 687b         	ldr	r3, [r7, #0x4]
 801855e: 2200         	movs	r2, #0x0
 8018560: 609a         	str	r2, [r3, #0x8]
; }
 8018562: bf00         	nop
 8018564: 3718         	adds	r7, #0x18
 8018566: 46bd         	mov	sp, r7
 8018568: bd80         	pop	{r7, pc}

0801856a <z_waitq_head>:
; {
 801856a: b580         	push	{r7, lr}
 801856c: b082         	sub	sp, #0x8
 801856e: af00         	add	r7, sp, #0x0
 8018570: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 8018572: 687b         	ldr	r3, [r7, #0x4]
 8018574: 4618         	mov	r0, r3
 8018576: f7ff fe11    	bl	0x801819c <sys_dlist_peek_head> @ imm = #-0x3de
 801857a: 4603         	mov	r3, r0
; }
 801857c: 4618         	mov	r0, r3
 801857e: 3708         	adds	r7, #0x8
 8018580: 46bd         	mov	sp, r7
 8018582: bd80         	pop	{r7, pc}

08018584 <z_swap_irqlock>:
; {
 8018584: b580         	push	{r7, lr}
 8018586: b084         	sub	sp, #0x10
 8018588: af00         	add	r7, sp, #0x0
 801858a: 6078         	str	r0, [r7, #0x4]
; 	ret = arch_swap(key);
 801858c: 6878         	ldr	r0, [r7, #0x4]
 801858e: f7eb f9a7    	bl	0x80038e0 <arch_swap>   @ imm = #-0x14cb2
 8018592: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 8018594: 68fb         	ldr	r3, [r7, #0xc]
; }
 8018596: 4618         	mov	r0, r3
 8018598: 3710         	adds	r7, #0x10
 801859a: 46bd         	mov	sp, r7
 801859c: bd80         	pop	{r7, pc}

0801859e <z_log_msg_runtime_create>:
; {
 801859e: b580         	push	{r7, lr}
 80185a0: b08a         	sub	sp, #0x28
 80185a2: af04         	add	r7, sp, #0x10
 80185a4: 60b9         	str	r1, [r7, #0x8]
 80185a6: 607b         	str	r3, [r7, #0x4]
 80185a8: 4603         	mov	r3, r0
 80185aa: 73fb         	strb	r3, [r7, #0xf]
 80185ac: 4613         	mov	r3, r2
 80185ae: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80185b0: f107 032c    	add.w	r3, r7, #0x2c
 80185b4: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80185b6: 7bba         	ldrb	r2, [r7, #0xe]
 80185b8: 7bf8         	ldrb	r0, [r7, #0xf]
 80185ba: 697b         	ldr	r3, [r7, #0x14]
 80185bc: 9303         	str	r3, [sp, #0xc]
 80185be: 6abb         	ldr	r3, [r7, #0x28]
 80185c0: 9302         	str	r3, [sp, #0x8]
 80185c2: 6a7b         	ldr	r3, [r7, #0x24]
 80185c4: 9301         	str	r3, [sp, #0x4]
 80185c6: 6a3b         	ldr	r3, [r7, #0x20]
 80185c8: 9300         	str	r3, [sp]
 80185ca: 687b         	ldr	r3, [r7, #0x4]
 80185cc: 68b9         	ldr	r1, [r7, #0x8]
 80185ce: f7e9 fdbd    	bl	0x800214c <z_log_msg_runtime_vcreate> @ imm = #-0x16486
; }
 80185d2: bf00         	nop
 80185d4: 3718         	adds	r7, #0x18
 80185d6: 46bd         	mov	sp, r7
 80185d8: bd80         	pop	{r7, pc}

080185da <z_sched_prio_cmp>:
; {
 80185da: b480         	push	{r7}
 80185dc: b085         	sub	sp, #0x14
 80185de: af00         	add	r7, sp, #0x0
 80185e0: 6078         	str	r0, [r7, #0x4]
 80185e2: 6039         	str	r1, [r7]
; 	int32_t b1 = thread_1->base.prio;
 80185e4: 687b         	ldr	r3, [r7, #0x4]
 80185e6: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 80185ea: 60fb         	str	r3, [r7, #0xc]
; 	int32_t b2 = thread_2->base.prio;
 80185ec: 683b         	ldr	r3, [r7]
 80185ee: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 80185f2: 60bb         	str	r3, [r7, #0x8]
; 	if (b1 != b2) {
 80185f4: 68fa         	ldr	r2, [r7, #0xc]
 80185f6: 68bb         	ldr	r3, [r7, #0x8]
 80185f8: 429a         	cmp	r2, r3
 80185fa: d003         	beq	0x8018604 <z_sched_prio_cmp+0x2a> @ imm = #0x6
; 		return b2 - b1;
 80185fc: 68ba         	ldr	r2, [r7, #0x8]
 80185fe: 68fb         	ldr	r3, [r7, #0xc]
 8018600: 1ad3         	subs	r3, r2, r3
 8018602: e000         	b	0x8018606 <z_sched_prio_cmp+0x2c> @ imm = #0x0
; 	return 0;
 8018604: 2300         	movs	r3, #0x0
; }
 8018606: 4618         	mov	r0, r3
 8018608: 3714         	adds	r7, #0x14
 801860a: 46bd         	mov	sp, r7
 801860c: bc80         	pop	{r7}
 801860e: 4770         	bx	lr

08018610 <should_queue_thread>:
; {
 8018610: b480         	push	{r7}
 8018612: b083         	sub	sp, #0xc
 8018614: af00         	add	r7, sp, #0x0
 8018616: 6078         	str	r0, [r7, #0x4]
; 	return !IS_ENABLED(CONFIG_SMP) || (thread != _current);
 8018618: 2301         	movs	r3, #0x1
; }
 801861a: 4618         	mov	r0, r3
 801861c: 370c         	adds	r7, #0xc
 801861e: 46bd         	mov	sp, r7
 8018620: bc80         	pop	{r7}
 8018622: 4770         	bx	lr

08018624 <is_aborting>:
; {
 8018624: b480         	push	{r7}
 8018626: b083         	sub	sp, #0xc
 8018628: af00         	add	r7, sp, #0x0
 801862a: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_ABORTING) != 0U;
 801862c: 687b         	ldr	r3, [r7, #0x4]
 801862e: 7b5b         	ldrb	r3, [r3, #0xd]
 8018630: f003 0320    	and	r3, r3, #0x20
 8018634: 2b00         	cmp	r3, #0x0
 8018636: bf14         	ite	ne
 8018638: 2301         	movne	r3, #0x1
 801863a: 2300         	moveq	r3, #0x0
 801863c: b2db         	uxtb	r3, r3
; }
 801863e: 4618         	mov	r0, r3
 8018640: 370c         	adds	r7, #0xc
 8018642: 46bd         	mov	sp, r7
 8018644: bc80         	pop	{r7}
 8018646: 4770         	bx	lr

08018648 <is_halting>:
; {
 8018648: b480         	push	{r7}
 801864a: b083         	sub	sp, #0xc
 801864c: af00         	add	r7, sp, #0x0
 801864e: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state &
 8018650: 687b         	ldr	r3, [r7, #0x4]
 8018652: 7b5b         	ldrb	r3, [r3, #0xd]
 8018654: f003 0360    	and	r3, r3, #0x60
; 		(_THREAD_ABORTING | _THREAD_SUSPENDING)) != 0U;
 8018658: 2b00         	cmp	r3, #0x0
 801865a: bf14         	ite	ne
 801865c: 2301         	movne	r3, #0x1
 801865e: 2300         	moveq	r3, #0x0
 8018660: b2db         	uxtb	r3, r3
; }
 8018662: 4618         	mov	r0, r3
 8018664: 370c         	adds	r7, #0xc
 8018666: 46bd         	mov	sp, r7
 8018668: bc80         	pop	{r7}
 801866a: 4770         	bx	lr

0801866c <clear_halting>:
; {
 801866c: b480         	push	{r7}
 801866e: b083         	sub	sp, #0xc
 8018670: af00         	add	r7, sp, #0x0
 8018672: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("dmb 0xF":::"memory");
 8018674: f3bf 8f5f    	dmb	sy
; }
 8018678: bf00         	nop
; }
 801867a: bf00         	nop
; }
 801867c: bf00         	nop
; 	thread->base.thread_state &= ~(_THREAD_ABORTING | _THREAD_SUSPENDING);
 801867e: 687b         	ldr	r3, [r7, #0x4]
 8018680: 7b5b         	ldrb	r3, [r3, #0xd]
 8018682: f023 0360    	bic	r3, r3, #0x60
 8018686: b2da         	uxtb	r2, r3
 8018688: 687b         	ldr	r3, [r7, #0x4]
 801868a: 735a         	strb	r2, [r3, #0xd]
; }
 801868c: bf00         	nop
 801868e: 370c         	adds	r7, #0xc
 8018690: 46bd         	mov	sp, r7
 8018692: bc80         	pop	{r7}
 8018694: 4770         	bx	lr

08018696 <update_metairq_preempt>:
; {
 8018696: b480         	push	{r7}
 8018698: b083         	sub	sp, #0xc
 801869a: af00         	add	r7, sp, #0x0
 801869c: 6078         	str	r0, [r7, #0x4]
; }
 801869e: bf00         	nop
 80186a0: 370c         	adds	r7, #0xc
 80186a2: 46bd         	mov	sp, r7
 80186a4: bc80         	pop	{r7}
 80186a6: 4770         	bx	lr

080186a8 <thread_active_elsewhere>:
; {
 80186a8: b480         	push	{r7}
 80186aa: b083         	sub	sp, #0xc
 80186ac: af00         	add	r7, sp, #0x0
 80186ae: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 80186b0: 2300         	movs	r3, #0x0
; }
 80186b2: 4618         	mov	r0, r3
 80186b4: 370c         	adds	r7, #0xc
 80186b6: 46bd         	mov	sp, r7
 80186b8: bc80         	pop	{r7}
 80186ba: 4770         	bx	lr

080186bc <add_to_waitq_locked>:
; {
 80186bc: b580         	push	{r7, lr}
 80186be: b086         	sub	sp, #0x18
 80186c0: af00         	add	r7, sp, #0x0
 80186c2: 6078         	str	r0, [r7, #0x4]
 80186c4: 6039         	str	r1, [r7]
; 	unready_thread(thread);
 80186c6: 6878         	ldr	r0, [r7, #0x4]
 80186c8: f7f4 ff66    	bl	0x800d598 <unready_thread> @ imm = #-0xb134
; 	z_mark_thread_as_pending(thread);
 80186cc: 6878         	ldr	r0, [r7, #0x4]
 80186ce: f7ff fee7    	bl	0x80184a0 <z_mark_thread_as_pending> @ imm = #-0x232
; 	if (wait_q != NULL) {
 80186d2: 683b         	ldr	r3, [r7]
 80186d4: 2b00         	cmp	r3, #0x0
 80186d6: d041         	beq	0x801875c <add_to_waitq_locked+0xa0> @ imm = #0x82
; 		thread->base.pended_on = wait_q;
 80186d8: 687b         	ldr	r3, [r7, #0x4]
 80186da: 683a         	ldr	r2, [r7]
 80186dc: 609a         	str	r2, [r3, #0x8]
; 		_priq_wait_add(&wait_q->waitq, thread);
 80186de: 683b         	ldr	r3, [r7]
 80186e0: 617b         	str	r3, [r7, #0x14]
 80186e2: 687b         	ldr	r3, [r7, #0x4]
 80186e4: 613b         	str	r3, [r7, #0x10]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 80186e6: 6978         	ldr	r0, [r7, #0x14]
 80186e8: f7ff fd58    	bl	0x801819c <sys_dlist_peek_head> @ imm = #-0x550
 80186ec: 4603         	mov	r3, r0
 80186ee: 2b00         	cmp	r3, #0x0
 80186f0: d004         	beq	0x80186fc <add_to_waitq_locked+0x40> @ imm = #0x8
 80186f2: 6978         	ldr	r0, [r7, #0x14]
 80186f4: f7ff fd52    	bl	0x801819c <sys_dlist_peek_head> @ imm = #-0x55c
 80186f8: 4603         	mov	r3, r0
 80186fa: e000         	b	0x80186fe <add_to_waitq_locked+0x42> @ imm = #0x0
 80186fc: 2300         	movs	r3, #0x0
 80186fe: 60fb         	str	r3, [r7, #0xc]
 8018700: e024         	b	0x801874c <add_to_waitq_locked+0x90> @ imm = #0x48
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8018702: 68f9         	ldr	r1, [r7, #0xc]
 8018704: 6938         	ldr	r0, [r7, #0x10]
 8018706: f7ff ff68    	bl	0x80185da <z_sched_prio_cmp> @ imm = #-0x130
 801870a: 4603         	mov	r3, r0
 801870c: 2b00         	cmp	r3, #0x0
 801870e: dd07         	ble	0x8018720 <add_to_waitq_locked+0x64> @ imm = #0xe
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8018710: 68fb         	ldr	r3, [r7, #0xc]
 8018712: 693a         	ldr	r2, [r7, #0x10]
 8018714: 4611         	mov	r1, r2
 8018716: 4618         	mov	r0, r3
 8018718: f7ff fd91    	bl	0x801823e <sys_dlist_insert> @ imm = #-0x4de
; 			return;
 801871c: bf00         	nop
; }
 801871e: e01d         	b	0x801875c <add_to_waitq_locked+0xa0> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8018720: 68fb         	ldr	r3, [r7, #0xc]
 8018722: 2b00         	cmp	r3, #0x0
 8018724: d010         	beq	0x8018748 <add_to_waitq_locked+0x8c> @ imm = #0x20
 8018726: 68fb         	ldr	r3, [r7, #0xc]
 8018728: 4619         	mov	r1, r3
 801872a: 6978         	ldr	r0, [r7, #0x14]
 801872c: f7ff fd5b    	bl	0x80181e6 <sys_dlist_peek_next> @ imm = #-0x54a
 8018730: 4603         	mov	r3, r0
 8018732: 2b00         	cmp	r3, #0x0
 8018734: d006         	beq	0x8018744 <add_to_waitq_locked+0x88> @ imm = #0xc
 8018736: 68fb         	ldr	r3, [r7, #0xc]
 8018738: 4619         	mov	r1, r3
 801873a: 6978         	ldr	r0, [r7, #0x14]
 801873c: f7ff fd53    	bl	0x80181e6 <sys_dlist_peek_next> @ imm = #-0x55a
 8018740: 4603         	mov	r3, r0
 8018742: e002         	b	0x801874a <add_to_waitq_locked+0x8e> @ imm = #0x4
 8018744: 2300         	movs	r3, #0x0
 8018746: e000         	b	0x801874a <add_to_waitq_locked+0x8e> @ imm = #0x0
 8018748: 2300         	movs	r3, #0x0
 801874a: 60fb         	str	r3, [r7, #0xc]
 801874c: 68fb         	ldr	r3, [r7, #0xc]
 801874e: 2b00         	cmp	r3, #0x0
 8018750: d1d7         	bne	0x8018702 <add_to_waitq_locked+0x46> @ imm = #-0x52
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8018752: 693b         	ldr	r3, [r7, #0x10]
 8018754: 4619         	mov	r1, r3
 8018756: 6978         	ldr	r0, [r7, #0x14]
 8018758: f7ff fd58    	bl	0x801820c <sys_dlist_append> @ imm = #-0x550
; }
 801875c: bf00         	nop
 801875e: 3718         	adds	r7, #0x18
 8018760: 46bd         	mov	sp, r7
 8018762: bd80         	pop	{r7, pc}

08018764 <add_thread_timeout>:
; {
 8018764: b580         	push	{r7, lr}
 8018766: b084         	sub	sp, #0x10
 8018768: af00         	add	r7, sp, #0x0
 801876a: 60f8         	str	r0, [r7, #0xc]
 801876c: e9c7 2300    	strd	r2, r3, [r7]
; 	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8018770: e9d7 2300    	ldrd	r2, r3, [r7]
 8018774: f04f 30ff    	mov.w	r0, #0xffffffff
 8018778: f04f 31ff    	mov.w	r1, #0xffffffff
 801877c: 428b         	cmp	r3, r1
 801877e: bf08         	it	eq
 8018780: 4282         	cmpeq	r2, r0
 8018782: d004         	beq	0x801878e <add_thread_timeout+0x2a> @ imm = #0x8
; 		z_add_thread_timeout(thread, timeout);
 8018784: e9d7 2300    	ldrd	r2, r3, [r7]
 8018788: 68f8         	ldr	r0, [r7, #0xc]
 801878a: f7f4 fb63    	bl	0x800ce54 <z_add_thread_timeout> @ imm = #-0xb93a
; }
 801878e: bf00         	nop
 8018790: 3710         	adds	r7, #0x10
 8018792: 46bd         	mov	sp, r7
 8018794: bd80         	pop	{r7, pc}

08018796 <pend_locked>:
; {
 8018796: b580         	push	{r7, lr}
 8018798: b084         	sub	sp, #0x10
 801879a: af00         	add	r7, sp, #0x0
 801879c: 60f8         	str	r0, [r7, #0xc]
 801879e: 60b9         	str	r1, [r7, #0x8]
 80187a0: e9c7 2300    	strd	r2, r3, [r7]
; 	add_to_waitq_locked(thread, wait_q);
 80187a4: 68b9         	ldr	r1, [r7, #0x8]
 80187a6: 68f8         	ldr	r0, [r7, #0xc]
 80187a8: f7ff ff88    	bl	0x80186bc <add_to_waitq_locked> @ imm = #-0xf0
; 	add_thread_timeout(thread, timeout);
 80187ac: e9d7 2300    	ldrd	r2, r3, [r7]
 80187b0: 68f8         	ldr	r0, [r7, #0xc]
 80187b2: f7ff ffd7    	bl	0x8018764 <add_thread_timeout> @ imm = #-0x52
; }
 80187b6: bf00         	nop
 80187b8: 3710         	adds	r7, #0x10
 80187ba: 46bd         	mov	sp, r7
 80187bc: bd80         	pop	{r7, pc}

080187be <z_thread_timeout>:
; {
 80187be: b580         	push	{r7, lr}
 80187c0: b084         	sub	sp, #0x10
 80187c2: af00         	add	r7, sp, #0x0
 80187c4: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = CONTAINER_OF(timeout,
 80187c6: 687b         	ldr	r3, [r7, #0x4]
 80187c8: 3b18         	subs	r3, #0x18
 80187ca: 60fb         	str	r3, [r7, #0xc]
; 	z_sched_wake_thread(thread, true);
 80187cc: 2101         	movs	r1, #0x1
 80187ce: 68f8         	ldr	r0, [r7, #0xc]
 80187d0: f7f4 ff76    	bl	0x800d6c0 <z_sched_wake_thread> @ imm = #-0xb114
; }
 80187d4: bf00         	nop
 80187d6: 3710         	adds	r7, #0x10
 80187d8: 46bd         	mov	sp, r7
 80187da: bd80         	pop	{r7, pc}

080187dc <resched>:
; {
 80187dc: b480         	push	{r7}
 80187de: b085         	sub	sp, #0x14
 80187e0: af00         	add	r7, sp, #0x0
 80187e2: 6078         	str	r0, [r7, #0x4]
 80187e4: 687b         	ldr	r3, [r7, #0x4]
 80187e6: 60fb         	str	r3, [r7, #0xc]
; 	return key == 0U;
 80187e8: 68fb         	ldr	r3, [r7, #0xc]
 80187ea: 2b00         	cmp	r3, #0x0
 80187ec: bf0c         	ite	eq
 80187ee: 2301         	moveq	r3, #0x1
 80187f0: 2300         	movne	r3, #0x0
 80187f2: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 80187f4: 2b00         	cmp	r3, #0x0
 80187f6: d00f         	beq	0x8018818 <resched+0x3c> @ imm = #0x1e
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80187f8: f3ef 8305    	mrs	r3, ipsr
 80187fc: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 80187fe: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 8018800: 2b00         	cmp	r3, #0x0
 8018802: bf14         	ite	ne
 8018804: 2301         	movne	r3, #0x1
 8018806: 2300         	moveq	r3, #0x0
 8018808: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 801880a: f083 0301    	eor	r3, r3, #0x1
 801880e: b2db         	uxtb	r3, r3
 8018810: 2b00         	cmp	r3, #0x0
 8018812: d001         	beq	0x8018818 <resched+0x3c> @ imm = #0x2
 8018814: 2301         	movs	r3, #0x1
 8018816: e000         	b	0x801881a <resched+0x3e> @ imm = #0x0
 8018818: 2300         	movs	r3, #0x0
 801881a: f003 0301    	and	r3, r3, #0x1
 801881e: b2db         	uxtb	r3, r3
; }
 8018820: 4618         	mov	r0, r3
 8018822: 3714         	adds	r7, #0x14
 8018824: 46bd         	mov	sp, r7
 8018826: bc80         	pop	{r7}
 8018828: 4770         	bx	lr

0801882a <z_reschedule>:
; {
 801882a: b580         	push	{r7, lr}
 801882c: b08a         	sub	sp, #0x28
 801882e: af00         	add	r7, sp, #0x0
 8018830: 6078         	str	r0, [r7, #0x4]
 8018832: 6039         	str	r1, [r7]
; 	if (resched(key.key) && need_swap()) {
 8018834: 683b         	ldr	r3, [r7]
 8018836: 4618         	mov	r0, r3
 8018838: f7ff ffd0    	bl	0x80187dc <resched>     @ imm = #-0x60
 801883c: 4603         	mov	r3, r0
 801883e: 2b00         	cmp	r3, #0x0
 8018840: d010         	beq	0x8018864 <z_reschedule+0x3a> @ imm = #0x20
 8018842: f7f5 f933    	bl	0x800daac <need_swap>   @ imm = #-0xad9a
 8018846: 4603         	mov	r3, r0
 8018848: 2b00         	cmp	r3, #0x0
 801884a: d00b         	beq	0x8018864 <z_reschedule+0x3a> @ imm = #0x16
 801884c: 687b         	ldr	r3, [r7, #0x4]
 801884e: 627b         	str	r3, [r7, #0x24]
 8018850: 683b         	ldr	r3, [r7]
 8018852: 60fb         	str	r3, [r7, #0xc]
 8018854: 6a7b         	ldr	r3, [r7, #0x24]
 8018856: 623b         	str	r3, [r7, #0x20]
; }
 8018858: bf00         	nop
; 	return z_swap_irqlock(key.key);
 801885a: 68fb         	ldr	r3, [r7, #0xc]
 801885c: 4618         	mov	r0, r3
 801885e: f7ff fe91    	bl	0x8018584 <z_swap_irqlock> @ imm = #-0x2de
; 		z_swap(lock, key);
 8018862: e010         	b	0x8018886 <z_reschedule+0x5c> @ imm = #0x20
 8018864: 687b         	ldr	r3, [r7, #0x4]
 8018866: 61fb         	str	r3, [r7, #0x1c]
 8018868: 683b         	ldr	r3, [r7]
 801886a: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 801886c: 693b         	ldr	r3, [r7, #0x10]
 801886e: 61bb         	str	r3, [r7, #0x18]
 8018870: 69bb         	ldr	r3, [r7, #0x18]
 8018872: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8018874: 697b         	ldr	r3, [r7, #0x14]
 8018876: f383 8811    	msr	basepri, r3
; }
 801887a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801887c: f3bf 8f6f    	isb	sy
; }
 8018880: bf00         	nop
; }
 8018882: bf00         	nop
; }
 8018884: bf00         	nop
; }
 8018886: bf00         	nop
 8018888: 3728         	adds	r7, #0x28
 801888a: 46bd         	mov	sp, r7
 801888c: bd80         	pop	{r7, pc}

0801888e <z_reschedule_irqlock>:
; {
 801888e: b580         	push	{r7, lr}
 8018890: b084         	sub	sp, #0x10
 8018892: af00         	add	r7, sp, #0x0
 8018894: 6078         	str	r0, [r7, #0x4]
; 	if (resched(key) && need_swap()) {
 8018896: 6878         	ldr	r0, [r7, #0x4]
 8018898: f7ff ffa0    	bl	0x80187dc <resched>     @ imm = #-0xc0
 801889c: 4603         	mov	r3, r0
 801889e: 2b00         	cmp	r3, #0x0
 80188a0: d008         	beq	0x80188b4 <z_reschedule_irqlock+0x26> @ imm = #0x10
 80188a2: f7f5 f903    	bl	0x800daac <need_swap>   @ imm = #-0xadfa
 80188a6: 4603         	mov	r3, r0
 80188a8: 2b00         	cmp	r3, #0x0
 80188aa: d003         	beq	0x80188b4 <z_reschedule_irqlock+0x26> @ imm = #0x6
; 		z_swap_irqlock(key);
 80188ac: 6878         	ldr	r0, [r7, #0x4]
 80188ae: f7ff fe69    	bl	0x8018584 <z_swap_irqlock> @ imm = #-0x32e
 80188b2: e00b         	b	0x80188cc <z_reschedule_irqlock+0x3e> @ imm = #0x16
 80188b4: 687b         	ldr	r3, [r7, #0x4]
 80188b6: 60fb         	str	r3, [r7, #0xc]
 80188b8: 68fb         	ldr	r3, [r7, #0xc]
 80188ba: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80188bc: 68bb         	ldr	r3, [r7, #0x8]
 80188be: f383 8811    	msr	basepri, r3
; }
 80188c2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80188c4: f3bf 8f6f    	isb	sy
; }
 80188c8: bf00         	nop
; }
 80188ca: bf00         	nop
; }
 80188cc: bf00         	nop
 80188ce: 3710         	adds	r7, #0x10
 80188d0: 46bd         	mov	sp, r7
 80188d2: bd80         	pop	{r7, pc}

080188d4 <init_ready_q>:
; {
 80188d4: b580         	push	{r7, lr}
 80188d6: b082         	sub	sp, #0x8
 80188d8: af00         	add	r7, sp, #0x0
 80188da: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&ready_q->runq);
 80188dc: 687b         	ldr	r3, [r7, #0x4]
 80188de: 3304         	adds	r3, #0x4
 80188e0: 4618         	mov	r0, r3
 80188e2: f7ff fc1c    	bl	0x801811e <sys_dlist_init> @ imm = #-0x7c8
; }
 80188e6: bf00         	nop
 80188e8: 3708         	adds	r7, #0x8
 80188ea: 46bd         	mov	sp, r7
 80188ec: bd80         	pop	{r7, pc}

080188ee <unpend_all>:
; {
 80188ee: b580         	push	{r7, lr}
 80188f0: b086         	sub	sp, #0x18
 80188f2: af00         	add	r7, sp, #0x0
 80188f4: 6078         	str	r0, [r7, #0x4]
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 80188f6: 6878         	ldr	r0, [r7, #0x4]
 80188f8: f7ff fe37    	bl	0x801856a <z_waitq_head> @ imm = #-0x392
 80188fc: 6178         	str	r0, [r7, #0x14]
 80188fe: e015         	b	0x801892c <unpend_all+0x3e> @ imm = #0x2a
; 		unpend_thread_no_timeout(thread);
 8018900: 6978         	ldr	r0, [r7, #0x14]
 8018902: f7ff fe18    	bl	0x8018536 <unpend_thread_no_timeout> @ imm = #-0x3d0
; 		(void)z_abort_thread_timeout(thread);
 8018906: 6978         	ldr	r0, [r7, #0x14]
 8018908: f7ff fcf2    	bl	0x80182f0 <z_abort_thread_timeout> @ imm = #-0x61c
 801890c: 697b         	ldr	r3, [r7, #0x14]
 801890e: 613b         	str	r3, [r7, #0x10]
 8018910: 2300         	movs	r3, #0x0
 8018912: 60fb         	str	r3, [r7, #0xc]
; 	thread->arch.swap_return_value = value;
 8018914: 693b         	ldr	r3, [r7, #0x10]
 8018916: 68fa         	ldr	r2, [r7, #0xc]
 8018918: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 801891c: bf00         	nop
; 		ready_thread(thread);
 801891e: 6978         	ldr	r0, [r7, #0x14]
 8018920: f7f4 fbc0    	bl	0x800d0a4 <ready_thread> @ imm = #-0xb880
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 8018924: 6878         	ldr	r0, [r7, #0x4]
 8018926: f7ff fe20    	bl	0x801856a <z_waitq_head> @ imm = #-0x3c0
 801892a: 6178         	str	r0, [r7, #0x14]
 801892c: 697b         	ldr	r3, [r7, #0x14]
 801892e: 2b00         	cmp	r3, #0x0
 8018930: d1e6         	bne	0x8018900 <unpend_all+0x12> @ imm = #-0x34
; }
 8018932: bf00         	nop
 8018934: bf00         	nop
 8018936: 3718         	adds	r7, #0x18
 8018938: 46bd         	mov	sp, r7
 801893a: bd80         	pop	{r7, pc}

0801893c <thread_is_preemptible>:
; {
 801893c: b480         	push	{r7}
 801893e: b083         	sub	sp, #0xc
 8018940: af00         	add	r7, sp, #0x0
 8018942: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 8018944: 687b         	ldr	r3, [r7, #0x4]
 8018946: 89db         	ldrh	r3, [r3, #0xe]
 8018948: 2b7f         	cmp	r3, #0x7f
 801894a: bf94         	ite	ls
 801894c: 2301         	movls	r3, #0x1
 801894e: 2300         	movhi	r3, #0x0
 8018950: b2db         	uxtb	r3, r3
; }
 8018952: 4618         	mov	r0, r3
 8018954: 370c         	adds	r7, #0xc
 8018956: 46bd         	mov	sp, r7
 8018958: bc80         	pop	{r7}
 801895a: 4770         	bx	lr

0801895c <z_is_thread_prevented_from_running>:
; {
 801895c: b480         	push	{r7}
 801895e: b085         	sub	sp, #0x14
 8018960: af00         	add	r7, sp, #0x0
 8018962: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 8018964: 687b         	ldr	r3, [r7, #0x4]
 8018966: 7b5b         	ldrb	r3, [r3, #0xd]
 8018968: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
 801896a: 7bfb         	ldrb	r3, [r7, #0xf]
 801896c: f003 031f    	and	r3, r3, #0x1f
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 8018970: 2b00         	cmp	r3, #0x0
 8018972: bf14         	ite	ne
 8018974: 2301         	movne	r3, #0x1
 8018976: 2300         	moveq	r3, #0x0
 8018978: b2db         	uxtb	r3, r3
; }
 801897a: 4618         	mov	r0, r3
 801897c: 3714         	adds	r7, #0x14
 801897e: 46bd         	mov	sp, r7
 8018980: bc80         	pop	{r7}
 8018982: 4770         	bx	lr

08018984 <z_is_prio1_higher_than_prio2>:
; {
 8018984: b480         	push	{r7}
 8018986: b083         	sub	sp, #0xc
 8018988: af00         	add	r7, sp, #0x0
 801898a: 6078         	str	r0, [r7, #0x4]
 801898c: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 801898e: 687a         	ldr	r2, [r7, #0x4]
 8018990: 683b         	ldr	r3, [r7]
 8018992: 429a         	cmp	r2, r3
 8018994: bfb4         	ite	lt
 8018996: 2301         	movlt	r3, #0x1
 8018998: 2300         	movge	r3, #0x0
 801899a: b2db         	uxtb	r3, r3
; }
 801899c: 4618         	mov	r0, r3
 801899e: 370c         	adds	r7, #0xc
 80189a0: 46bd         	mov	sp, r7
 80189a2: bc80         	pop	{r7}
 80189a4: 4770         	bx	lr

080189a6 <z_is_prio_higher>:
; {
 80189a6: b580         	push	{r7, lr}
 80189a8: b082         	sub	sp, #0x8
 80189aa: af00         	add	r7, sp, #0x0
 80189ac: 6078         	str	r0, [r7, #0x4]
 80189ae: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 80189b0: 6839         	ldr	r1, [r7]
 80189b2: 6878         	ldr	r0, [r7, #0x4]
 80189b4: f7ff ffe6    	bl	0x8018984 <z_is_prio1_higher_than_prio2> @ imm = #-0x34
 80189b8: 4603         	mov	r3, r0
; }
 80189ba: 4618         	mov	r0, r3
 80189bc: 3708         	adds	r7, #0x8
 80189be: 46bd         	mov	sp, r7
 80189c0: bd80         	pop	{r7, pc}

080189c2 <sys_dnode_init>:
; {
 80189c2: b480         	push	{r7}
 80189c4: b083         	sub	sp, #0xc
 80189c6: af00         	add	r7, sp, #0x0
 80189c8: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 80189ca: 687b         	ldr	r3, [r7, #0x4]
 80189cc: 2200         	movs	r2, #0x0
 80189ce: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 80189d0: 687b         	ldr	r3, [r7, #0x4]
 80189d2: 2200         	movs	r2, #0x0
 80189d4: 605a         	str	r2, [r3, #0x4]
; }
 80189d6: bf00         	nop
 80189d8: 370c         	adds	r7, #0xc
 80189da: 46bd         	mov	sp, r7
 80189dc: bc80         	pop	{r7}
 80189de: 4770         	bx	lr

080189e0 <sys_dnode_is_linked>:
; {
 80189e0: b480         	push	{r7}
 80189e2: b083         	sub	sp, #0xc
 80189e4: af00         	add	r7, sp, #0x0
 80189e6: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 80189e8: 687b         	ldr	r3, [r7, #0x4]
 80189ea: 681b         	ldr	r3, [r3]
 80189ec: 2b00         	cmp	r3, #0x0
 80189ee: bf14         	ite	ne
 80189f0: 2301         	movne	r3, #0x1
 80189f2: 2300         	moveq	r3, #0x0
 80189f4: b2db         	uxtb	r3, r3
; }
 80189f6: 4618         	mov	r0, r3
 80189f8: 370c         	adds	r7, #0xc
 80189fa: 46bd         	mov	sp, r7
 80189fc: bc80         	pop	{r7}
 80189fe: 4770         	bx	lr

08018a00 <sys_dlist_is_empty>:
; {
 8018a00: b480         	push	{r7}
 8018a02: b083         	sub	sp, #0xc
 8018a04: af00         	add	r7, sp, #0x0
 8018a06: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8018a08: 687b         	ldr	r3, [r7, #0x4]
 8018a0a: 681b         	ldr	r3, [r3]
 8018a0c: 687a         	ldr	r2, [r7, #0x4]
 8018a0e: 429a         	cmp	r2, r3
 8018a10: bf0c         	ite	eq
 8018a12: 2301         	moveq	r3, #0x1
 8018a14: 2300         	movne	r3, #0x0
 8018a16: b2db         	uxtb	r3, r3
; }
 8018a18: 4618         	mov	r0, r3
 8018a1a: 370c         	adds	r7, #0xc
 8018a1c: 46bd         	mov	sp, r7
 8018a1e: bc80         	pop	{r7}
 8018a20: 4770         	bx	lr

08018a22 <sys_dlist_peek_head>:
; {
 8018a22: b580         	push	{r7, lr}
 8018a24: b082         	sub	sp, #0x8
 8018a26: af00         	add	r7, sp, #0x0
 8018a28: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8018a2a: 6878         	ldr	r0, [r7, #0x4]
 8018a2c: f7ff ffe8    	bl	0x8018a00 <sys_dlist_is_empty> @ imm = #-0x30
 8018a30: 4603         	mov	r3, r0
 8018a32: 2b00         	cmp	r3, #0x0
 8018a34: d102         	bne	0x8018a3c <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8018a36: 687b         	ldr	r3, [r7, #0x4]
 8018a38: 681b         	ldr	r3, [r3]
 8018a3a: e000         	b	0x8018a3e <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8018a3c: 2300         	movs	r3, #0x0
; }
 8018a3e: 4618         	mov	r0, r3
 8018a40: 3708         	adds	r7, #0x8
 8018a42: 46bd         	mov	sp, r7
 8018a44: bd80         	pop	{r7, pc}

08018a46 <sys_dlist_peek_next_no_check>:
; {
 8018a46: b480         	push	{r7}
 8018a48: b083         	sub	sp, #0xc
 8018a4a: af00         	add	r7, sp, #0x0
 8018a4c: 6078         	str	r0, [r7, #0x4]
 8018a4e: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 8018a50: 687b         	ldr	r3, [r7, #0x4]
 8018a52: 685b         	ldr	r3, [r3, #0x4]
 8018a54: 683a         	ldr	r2, [r7]
 8018a56: 429a         	cmp	r2, r3
 8018a58: d002         	beq	0x8018a60 <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 8018a5a: 683b         	ldr	r3, [r7]
 8018a5c: 681b         	ldr	r3, [r3]
 8018a5e: e000         	b	0x8018a62 <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 8018a60: 2300         	movs	r3, #0x0
; }
 8018a62: 4618         	mov	r0, r3
 8018a64: 370c         	adds	r7, #0xc
 8018a66: 46bd         	mov	sp, r7
 8018a68: bc80         	pop	{r7}
 8018a6a: 4770         	bx	lr

08018a6c <sys_dlist_peek_next>:
; {
 8018a6c: b580         	push	{r7, lr}
 8018a6e: b082         	sub	sp, #0x8
 8018a70: af00         	add	r7, sp, #0x0
 8018a72: 6078         	str	r0, [r7, #0x4]
 8018a74: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 8018a76: 683b         	ldr	r3, [r7]
 8018a78: 2b00         	cmp	r3, #0x0
 8018a7a: d005         	beq	0x8018a88 <sys_dlist_peek_next+0x1c> @ imm = #0xa
 8018a7c: 6839         	ldr	r1, [r7]
 8018a7e: 6878         	ldr	r0, [r7, #0x4]
 8018a80: f7ff ffe1    	bl	0x8018a46 <sys_dlist_peek_next_no_check> @ imm = #-0x3e
 8018a84: 4603         	mov	r3, r0
 8018a86: e000         	b	0x8018a8a <sys_dlist_peek_next+0x1e> @ imm = #0x0
 8018a88: 2300         	movs	r3, #0x0
; }
 8018a8a: 4618         	mov	r0, r3
 8018a8c: 3708         	adds	r7, #0x8
 8018a8e: 46bd         	mov	sp, r7
 8018a90: bd80         	pop	{r7, pc}

08018a92 <sys_dlist_append>:
; {
 8018a92: b480         	push	{r7}
 8018a94: b085         	sub	sp, #0x14
 8018a96: af00         	add	r7, sp, #0x0
 8018a98: 6078         	str	r0, [r7, #0x4]
 8018a9a: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 8018a9c: 687b         	ldr	r3, [r7, #0x4]
 8018a9e: 685b         	ldr	r3, [r3, #0x4]
 8018aa0: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 8018aa2: 683b         	ldr	r3, [r7]
 8018aa4: 687a         	ldr	r2, [r7, #0x4]
 8018aa6: 601a         	str	r2, [r3]
; 	node->prev = tail;
 8018aa8: 683b         	ldr	r3, [r7]
 8018aaa: 68fa         	ldr	r2, [r7, #0xc]
 8018aac: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 8018aae: 68fb         	ldr	r3, [r7, #0xc]
 8018ab0: 683a         	ldr	r2, [r7]
 8018ab2: 601a         	str	r2, [r3]
; 	list->tail = node;
 8018ab4: 687b         	ldr	r3, [r7, #0x4]
 8018ab6: 683a         	ldr	r2, [r7]
 8018ab8: 605a         	str	r2, [r3, #0x4]
; }
 8018aba: bf00         	nop
 8018abc: 3714         	adds	r7, #0x14
 8018abe: 46bd         	mov	sp, r7
 8018ac0: bc80         	pop	{r7}
 8018ac2: 4770         	bx	lr

08018ac4 <sys_dlist_insert>:
; {
 8018ac4: b480         	push	{r7}
 8018ac6: b085         	sub	sp, #0x14
 8018ac8: af00         	add	r7, sp, #0x0
 8018aca: 6078         	str	r0, [r7, #0x4]
 8018acc: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 8018ace: 687b         	ldr	r3, [r7, #0x4]
 8018ad0: 685b         	ldr	r3, [r3, #0x4]
 8018ad2: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 8018ad4: 683b         	ldr	r3, [r7]
 8018ad6: 68fa         	ldr	r2, [r7, #0xc]
 8018ad8: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 8018ada: 683b         	ldr	r3, [r7]
 8018adc: 687a         	ldr	r2, [r7, #0x4]
 8018ade: 601a         	str	r2, [r3]
; 	prev->next = node;
 8018ae0: 68fb         	ldr	r3, [r7, #0xc]
 8018ae2: 683a         	ldr	r2, [r7]
 8018ae4: 601a         	str	r2, [r3]
; 	successor->prev = node;
 8018ae6: 687b         	ldr	r3, [r7, #0x4]
 8018ae8: 683a         	ldr	r2, [r7]
 8018aea: 605a         	str	r2, [r3, #0x4]
; }
 8018aec: bf00         	nop
 8018aee: 3714         	adds	r7, #0x14
 8018af0: 46bd         	mov	sp, r7
 8018af2: bc80         	pop	{r7}
 8018af4: 4770         	bx	lr

08018af6 <sys_dlist_remove>:
; {
 8018af6: b580         	push	{r7, lr}
 8018af8: b084         	sub	sp, #0x10
 8018afa: af00         	add	r7, sp, #0x0
 8018afc: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8018afe: 687b         	ldr	r3, [r7, #0x4]
 8018b00: 685b         	ldr	r3, [r3, #0x4]
 8018b02: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8018b04: 687b         	ldr	r3, [r7, #0x4]
 8018b06: 681b         	ldr	r3, [r3]
 8018b08: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8018b0a: 68fb         	ldr	r3, [r7, #0xc]
 8018b0c: 68ba         	ldr	r2, [r7, #0x8]
 8018b0e: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8018b10: 68bb         	ldr	r3, [r7, #0x8]
 8018b12: 68fa         	ldr	r2, [r7, #0xc]
 8018b14: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8018b16: 6878         	ldr	r0, [r7, #0x4]
 8018b18: f7ff ff53    	bl	0x80189c2 <sys_dnode_init> @ imm = #-0x15a
; }
 8018b1c: bf00         	nop
 8018b1e: 3710         	adds	r7, #0x10
 8018b20: 46bd         	mov	sp, r7
 8018b22: bd80         	pop	{r7, pc}

08018b24 <remove_timeout>:
; {
 8018b24: b5f0         	push	{r4, r5, r6, r7, lr}
 8018b26: b083         	sub	sp, #0xc
 8018b28: af00         	add	r7, sp, #0x0
 8018b2a: 6078         	str	r0, [r7, #0x4]
; 	if (next(t) != NULL) {
 8018b2c: 6878         	ldr	r0, [r7, #0x4]
 8018b2e: f7f5 fe8b    	bl	0x800e848 <next>        @ imm = #-0xa2ea
 8018b32: 4603         	mov	r3, r0
 8018b34: 2b00         	cmp	r3, #0x0
 8018b36: d00d         	beq	0x8018b54 <remove_timeout+0x30> @ imm = #0x1a
; 		next(t)->dticks += t->dticks;
 8018b38: 6878         	ldr	r0, [r7, #0x4]
 8018b3a: f7f5 fe85    	bl	0x800e848 <next>        @ imm = #-0xa2f6
 8018b3e: 4606         	mov	r6, r0
 8018b40: e9d6 0104    	ldrd	r0, r1, [r6, #16]
 8018b44: 687b         	ldr	r3, [r7, #0x4]
 8018b46: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8018b4a: 1884         	adds	r4, r0, r2
 8018b4c: eb41 0503    	adc.w	r5, r1, r3
 8018b50: e9c6 4504    	strd	r4, r5, [r6, #16]
; 	sys_dlist_remove(&t->node);
 8018b54: 687b         	ldr	r3, [r7, #0x4]
 8018b56: 4618         	mov	r0, r3
 8018b58: f7ff ffcd    	bl	0x8018af6 <sys_dlist_remove> @ imm = #-0x66
; }
 8018b5c: bf00         	nop
 8018b5e: 370c         	adds	r7, #0xc
 8018b60: 46bd         	mov	sp, r7
 8018b62: bdf0         	pop	{r4, r5, r6, r7, pc}

08018b64 <next_timeout>:
; {
 8018b64: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8018b68: b086         	sub	sp, #0x18
 8018b6a: af00         	add	r7, sp, #0x0
; 	struct _timeout *to = first();
 8018b6c: f7f5 fe5e    	bl	0x800e82c <first>       @ imm = #-0xa344
 8018b70: 6138         	str	r0, [r7, #0x10]
; 	int32_t ticks_elapsed = elapsed();
 8018b72: f7f5 fe7b    	bl	0x800e86c <elapsed>     @ imm = #-0xa30a
 8018b76: 60f8         	str	r0, [r7, #0xc]
; 	if ((to == NULL) ||
 8018b78: 693b         	ldr	r3, [r7, #0x10]
 8018b7a: 2b00         	cmp	r3, #0x0
 8018b7c: d00f         	beq	0x8018b9e <next_timeout+0x3a> @ imm = #0x1e
; 	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 8018b7e: 693b         	ldr	r3, [r7, #0x10]
 8018b80: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8018b84: 68f9         	ldr	r1, [r7, #0xc]
 8018b86: 17c8         	asrs	r0, r1, #0x1f
 8018b88: 468a         	mov	r10, r1
 8018b8a: 4683         	mov	r11, r0
 8018b8c: ebb2 040a    	subs.w	r4, r2, r10
 8018b90: eb63 050b    	sbc.w	r5, r3, r11
; 	if ((to == NULL) ||
 8018b94: f1b4 4f00    	cmp.w	r4, #0x80000000
 8018b98: f175 0300    	sbcs	r3, r5, #0x0
 8018b9c: db03         	blt	0x8018ba6 <next_timeout+0x42> @ imm = #0x6
; 		ret = MAX_WAIT;
 8018b9e: f06f 4300    	mvn	r3, #0x80000000
 8018ba2: 617b         	str	r3, [r7, #0x14]
 8018ba4: e016         	b	0x8018bd4 <next_timeout+0x70> @ imm = #0x2c
; 		ret = MAX(0, to->dticks - ticks_elapsed);
 8018ba6: 693b         	ldr	r3, [r7, #0x10]
 8018ba8: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8018bac: 68f9         	ldr	r1, [r7, #0xc]
 8018bae: 17c8         	asrs	r0, r1, #0x1f
 8018bb0: 4688         	mov	r8, r1
 8018bb2: 4681         	mov	r9, r0
 8018bb4: ebb2 0108    	subs.w	r1, r2, r8
 8018bb8: 6039         	str	r1, [r7]
 8018bba: eb63 0309    	sbc.w	r3, r3, r9
 8018bbe: 607b         	str	r3, [r7, #0x4]
 8018bc0: e9d7 2300    	ldrd	r2, r3, [r7]
 8018bc4: 2b00         	cmp	r3, #0x0
 8018bc6: da03         	bge	0x8018bd0 <next_timeout+0x6c> @ imm = #0x6
 8018bc8: f04f 0200    	mov.w	r2, #0x0
 8018bcc: f04f 0300    	mov.w	r3, #0x0
 8018bd0: 4613         	mov	r3, r2
 8018bd2: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 8018bd4: 697b         	ldr	r3, [r7, #0x14]
; }
 8018bd6: 4618         	mov	r0, r3
 8018bd8: 3718         	adds	r7, #0x18
 8018bda: 46bd         	mov	sp, r7
 8018bdc: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08018be0 <sys_clock_tick_get_32>:
; {
 8018be0: b580         	push	{r7, lr}
 8018be2: af00         	add	r7, sp, #0x0
; 	return (uint32_t)sys_clock_tick_get();
 8018be4: f7f6 f88c    	bl	0x800ed00 <sys_clock_tick_get> @ imm = #-0x9ee8
 8018be8: 4602         	mov	r2, r0
 8018bea: 460b         	mov	r3, r1
 8018bec: 4613         	mov	r3, r2
; }
 8018bee: 4618         	mov	r0, r3
 8018bf0: bd80         	pop	{r7, pc}

08018bf2 <z_impl_k_uptime_ticks>:
; {
 8018bf2: b580         	push	{r7, lr}
 8018bf4: af00         	add	r7, sp, #0x0
; 	return sys_clock_tick_get();
 8018bf6: f7f6 f883    	bl	0x800ed00 <sys_clock_tick_get> @ imm = #-0x9efa
 8018bfa: 4602         	mov	r2, r0
 8018bfc: 460b         	mov	r3, r1
; }
 8018bfe: 4610         	mov	r0, r2
 8018c00: 4619         	mov	r1, r3
 8018c02: bd80         	pop	{r7, pc}

08018c04 <arch_k_cycle_get_32>:
; {
 8018c04: b580         	push	{r7, lr}
 8018c06: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 8018c08: f7f0 fdce    	bl	0x80097a8 <sys_clock_cycle_get_32> @ imm = #-0xf464
 8018c0c: 4603         	mov	r3, r0
; }
 8018c0e: 4618         	mov	r0, r3
 8018c10: bd80         	pop	{r7, pc}

08018c12 <k_cycle_get_32>:
; {
 8018c12: b580         	push	{r7, lr}
 8018c14: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 8018c16: f7ff fff5    	bl	0x8018c04 <arch_k_cycle_get_32> @ imm = #-0x16
 8018c1a: 4603         	mov	r3, r0
; }
 8018c1c: 4618         	mov	r0, r3
 8018c1e: bd80         	pop	{r7, pc}

08018c20 <usage_now>:
; {
 8018c20: b580         	push	{r7, lr}
 8018c22: b082         	sub	sp, #0x8
 8018c24: af00         	add	r7, sp, #0x0
; 	now = k_cycle_get_32();
 8018c26: f7ff fff4    	bl	0x8018c12 <k_cycle_get_32> @ imm = #-0x18
 8018c2a: 6078         	str	r0, [r7, #0x4]
; 	return (now == 0) ? 1 : now;
 8018c2c: 687b         	ldr	r3, [r7, #0x4]
 8018c2e: 2b00         	cmp	r3, #0x0
 8018c30: d001         	beq	0x8018c36 <usage_now+0x16> @ imm = #0x2
 8018c32: 687b         	ldr	r3, [r7, #0x4]
 8018c34: e000         	b	0x8018c38 <usage_now+0x18> @ imm = #0x0
 8018c36: 2301         	movs	r3, #0x1
; }
 8018c38: 4618         	mov	r0, r3
 8018c3a: 3708         	adds	r7, #0x8
 8018c3c: 46bd         	mov	sp, r7
 8018c3e: bd80         	pop	{r7, pc}

08018c40 <sched_cpu_update_usage>:
; {
 8018c40: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 8018c44: b083         	sub	sp, #0xc
 8018c46: af00         	add	r7, sp, #0x0
 8018c48: 6078         	str	r0, [r7, #0x4]
 8018c4a: 6039         	str	r1, [r7]
; 	if (!cpu->usage->track_usage) {
 8018c4c: 687b         	ldr	r3, [r7, #0x4]
 8018c4e: 699b         	ldr	r3, [r3, #0x18]
 8018c50: 7a1b         	ldrb	r3, [r3, #0x8]
 8018c52: f083 0301    	eor	r3, r3, #0x1
 8018c56: b2db         	uxtb	r3, r3
 8018c58: 2b00         	cmp	r3, #0x0
 8018c5a: d116         	bne	0x8018c8a <sched_cpu_update_usage+0x4a> @ imm = #0x2c
; 	if (cpu->current != cpu->idle_thread) {
 8018c5c: 687b         	ldr	r3, [r7, #0x4]
 8018c5e: 689a         	ldr	r2, [r3, #0x8]
 8018c60: 687b         	ldr	r3, [r7, #0x4]
 8018c62: 68db         	ldr	r3, [r3, #0xc]
 8018c64: 429a         	cmp	r2, r3
 8018c66: d011         	beq	0x8018c8c <sched_cpu_update_usage+0x4c> @ imm = #0x22
; 		cpu->usage->total += cycles;
 8018c68: 687b         	ldr	r3, [r7, #0x4]
 8018c6a: 699b         	ldr	r3, [r3, #0x18]
 8018c6c: e9d3 2300    	ldrd	r2, r3, [r3]
 8018c70: 6839         	ldr	r1, [r7]
 8018c72: 2000         	movs	r0, #0x0
 8018c74: 460c         	mov	r4, r1
 8018c76: 4605         	mov	r5, r0
 8018c78: 6879         	ldr	r1, [r7, #0x4]
 8018c7a: 6989         	ldr	r1, [r1, #0x18]
 8018c7c: eb12 0804    	adds.w	r8, r2, r4
 8018c80: eb43 0905    	adc.w	r9, r3, r5
 8018c84: e9c1 8900    	strd	r8, r9, [r1]
 8018c88: e000         	b	0x8018c8c <sched_cpu_update_usage+0x4c> @ imm = #0x0
; 		return;
 8018c8a: bf00         	nop
; }
 8018c8c: 370c         	adds	r7, #0xc
 8018c8e: 46bd         	mov	sp, r7
 8018c90: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 8018c94: 4770         	bx	lr

08018c96 <sched_thread_update_usage>:
; {
 8018c96: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 8018c9a: b083         	sub	sp, #0xc
 8018c9c: af00         	add	r7, sp, #0x0
 8018c9e: 6078         	str	r0, [r7, #0x4]
 8018ca0: 6039         	str	r1, [r7]
; 	thread->base.usage.total += cycles;
 8018ca2: 687b         	ldr	r3, [r7, #0x4]
 8018ca4: e9d3 230c    	ldrd	r2, r3, [r3, #48]
 8018ca8: 6839         	ldr	r1, [r7]
 8018caa: 2000         	movs	r0, #0x0
 8018cac: 460c         	mov	r4, r1
 8018cae: 4605         	mov	r5, r0
 8018cb0: eb12 0804    	adds.w	r8, r2, r4
 8018cb4: eb43 0905    	adc.w	r9, r3, r5
 8018cb8: 687b         	ldr	r3, [r7, #0x4]
 8018cba: e9c3 890c    	strd	r8, r9, [r3, #48]
; }
 8018cbe: bf00         	nop
 8018cc0: 370c         	adds	r7, #0xc
 8018cc2: 46bd         	mov	sp, r7
 8018cc4: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 8018cc8: 4770         	bx	lr

08018cca <sys_dlist_init>:
; {
 8018cca: b480         	push	{r7}
 8018ccc: b083         	sub	sp, #0xc
 8018cce: af00         	add	r7, sp, #0x0
 8018cd0: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8018cd2: 687b         	ldr	r3, [r7, #0x4]
 8018cd4: 687a         	ldr	r2, [r7, #0x4]
 8018cd6: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8018cd8: 687b         	ldr	r3, [r7, #0x4]
 8018cda: 687a         	ldr	r2, [r7, #0x4]
 8018cdc: 605a         	str	r2, [r3, #0x4]
; }
 8018cde: bf00         	nop
 8018ce0: 370c         	adds	r7, #0xc
 8018ce2: 46bd         	mov	sp, r7
 8018ce4: bc80         	pop	{r7}
 8018ce6: 4770         	bx	lr

08018ce8 <z_waitq_init>:
; {
 8018ce8: b580         	push	{r7, lr}
 8018cea: b082         	sub	sp, #0x8
 8018cec: af00         	add	r7, sp, #0x0
 8018cee: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8018cf0: 687b         	ldr	r3, [r7, #0x4]
 8018cf2: 4618         	mov	r0, r3
 8018cf4: f7ff ffe9    	bl	0x8018cca <sys_dlist_init> @ imm = #-0x2e
; }
 8018cf8: bf00         	nop
 8018cfa: 3708         	adds	r7, #0x8
 8018cfc: 46bd         	mov	sp, r7
 8018cfe: bd80         	pop	{r7, pc}

08018d00 <k_heap_init>:
; {
 8018d00: b580         	push	{r7, lr}
 8018d02: b084         	sub	sp, #0x10
 8018d04: af00         	add	r7, sp, #0x0
 8018d06: 60f8         	str	r0, [r7, #0xc]
 8018d08: 60b9         	str	r1, [r7, #0x8]
 8018d0a: 607a         	str	r2, [r7, #0x4]
; 	z_waitq_init(&heap->wait_q);
 8018d0c: 68fb         	ldr	r3, [r7, #0xc]
 8018d0e: 330c         	adds	r3, #0xc
 8018d10: 4618         	mov	r0, r3
 8018d12: f7ff ffe9    	bl	0x8018ce8 <z_waitq_init> @ imm = #-0x2e
; 	sys_heap_init(&heap->heap, mem, bytes);
 8018d16: 68fb         	ldr	r3, [r7, #0xc]
 8018d18: 687a         	ldr	r2, [r7, #0x4]
 8018d1a: 68b9         	ldr	r1, [r7, #0x8]
 8018d1c: 4618         	mov	r0, r3
 8018d1e: f7f7 fe0c    	bl	0x801093a <sys_heap_init> @ imm = #-0x83e8
; }
 8018d22: bf00         	nop
 8018d24: 3710         	adds	r7, #0x10
 8018d26: 46bd         	mov	sp, r7
 8018d28: bd80         	pop	{r7, pc}

08018d2a <memcpy>:
 8018d2a: 440a         	add	r2, r1
 8018d2c: 4291         	cmp	r1, r2
 8018d2e: f100 33ff    	add.w	r3, r0, #0xffffffff
 8018d32: d100         	bne	0x8018d36 <memcpy+0xc>  @ imm = #0x0
 8018d34: 4770         	bx	lr
 8018d36: b510         	push	{r4, lr}
 8018d38: f811 4b01    	ldrb	r4, [r1], #1
 8018d3c: f803 4f01    	strb	r4, [r3, #1]!
 8018d40: 4291         	cmp	r1, r2
 8018d42: d1f9         	bne	0x8018d38 <memcpy+0xe>  @ imm = #-0xe
 8018d44: bd10         	pop	{r4, pc}

08018d46 <memset>:
 8018d46: 4402         	add	r2, r0
 8018d48: 4603         	mov	r3, r0
 8018d4a: 4293         	cmp	r3, r2
 8018d4c: d100         	bne	0x8018d50 <memset+0xa>  @ imm = #0x0
 8018d4e: 4770         	bx	lr
 8018d50: f803 1b01    	strb	r1, [r3], #1
 8018d54: e7f9         	b	0x8018d4a <memset+0x4>  @ imm = #-0xe

08018d56 <strncpy>:
 8018d56: b510         	push	{r4, lr}
 8018d58: 3901         	subs	r1, #0x1
 8018d5a: 4604         	mov	r4, r0
 8018d5c: b132         	cbz	r2, 0x8018d6c <strncpy+0x16> @ imm = #0xc
 8018d5e: f811 3f01    	ldrb	r3, [r1, #1]!
 8018d62: f800 3b01    	strb	r3, [r0], #1
 8018d66: 3a01         	subs	r2, #0x1
 8018d68: 2b00         	cmp	r3, #0x0
 8018d6a: d1f7         	bne	0x8018d5c <strncpy+0x6> @ imm = #-0x12
 8018d6c: 2100         	movs	r1, #0x0
 8018d6e: f7ff ffea    	bl	0x8018d46 <memset>      @ imm = #-0x2c
 8018d72: 4620         	mov	r0, r4
 8018d74: bd10         	pop	{r4, pc}

08018d76 <strnlen>:
 8018d76: b510         	push	{r4, lr}
 8018d78: 4602         	mov	r2, r0
 8018d7a: 4401         	add	r1, r0
 8018d7c: 428a         	cmp	r2, r1
 8018d7e: 4613         	mov	r3, r2
 8018d80: d003         	beq	0x8018d8a <strnlen+0x14> @ imm = #0x6
 8018d82: 781c         	ldrb	r4, [r3]
 8018d84: 3201         	adds	r2, #0x1
 8018d86: 2c00         	cmp	r4, #0x0
 8018d88: d1f8         	bne	0x8018d7c <strnlen+0x6> @ imm = #-0x10
 8018d8a: 1a18         	subs	r0, r3, r0
 8018d8c: bd10         	pop	{r4, pc}

08018d8e <__ultoa_invert>:
 8018d8e: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 8018d92: f1c3 0937    	rsb.w	r9, r3, #0x37
 8018d96: 4607         	mov	r7, r0
 8018d98: 4688         	mov	r8, r1
 8018d9a: fa5f f989    	uxtb.w	r9, r9
 8018d9e: f003 051f    	and	r5, r3, #0x1f
 8018da2: 4616         	mov	r6, r2
 8018da4: f04f 0a00    	mov.w	r10, #0x0
 8018da8: 4638         	mov	r0, r7
 8018daa: 4641         	mov	r1, r8
 8018dac: 462a         	mov	r2, r5
 8018dae: 4653         	mov	r3, r10
 8018db0: f7e7 fea0    	bl	0x8000af4 <__aeabi_uldivmod> @ imm = #-0x182c0
 8018db4: b2d4         	uxtb	r4, r2
 8018db6: 2c09         	cmp	r4, #0x9
 8018db8: bf88         	it	hi
 8018dba: 444c         	addhi	r4, r9
 8018dbc: 463a         	mov	r2, r7
 8018dbe: 4643         	mov	r3, r8
 8018dc0: bf88         	it	hi
 8018dc2: b2e4         	uxtbhi	r4, r4
 8018dc4: 42aa         	cmp	r2, r5
 8018dc6: f104 0430    	add.w	r4, r4, #0x30
 8018dca: eb73 030a    	sbcs.w	r3, r3, r10
 8018dce: f806 4b01    	strb	r4, [r6], #1
 8018dd2: 4607         	mov	r7, r0
 8018dd4: 4688         	mov	r8, r1
 8018dd6: d2e7         	bhs	0x8018da8 <__ultoa_invert+0x1a> @ imm = #-0x32
 8018dd8: 4630         	mov	r0, r6
 8018dda: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}

08018dde <mulShiftAll64>:
 8018dde: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8018de2: b087         	sub	sp, #0x1c
 8018de4: 1806         	adds	r6, r0, r0
 8018de6: 4699         	mov	r9, r3
 8018de8: ab02         	add	r3, sp, #0x8
 8018dea: eb41 0401    	adc.w	r4, r1, r1
 8018dee: 9300         	str	r3, [sp]
 8018df0: 4615         	mov	r5, r2
 8018df2: 4630         	mov	r0, r6
 8018df4: e9d2 2300    	ldrd	r2, r3, [r2]
 8018df8: 4621         	mov	r1, r4
 8018dfa: f8dd b044    	ldr.w	r11, [sp, #0x44]
 8018dfe: f000 f8a9    	bl	0x8018f54 <__umul128>   @ imm = #0x152
 8018e02: ab04         	add	r3, sp, #0x10
 8018e04: 9300         	str	r3, [sp]
 8018e06: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 8018e0a: 4607         	mov	r7, r0
 8018e0c: 4688         	mov	r8, r1
 8018e0e: 4630         	mov	r0, r6
 8018e10: 4621         	mov	r1, r4
 8018e12: f000 f89f    	bl	0x8018f54 <__umul128>   @ imm = #0x13e
 8018e16: e9dd 6302    	ldrd	r6, r3, [sp, #8]
 8018e1a: 1984         	adds	r4, r0, r6
 8018e1c: eb51 0603    	adcs.w	r6, r1, r3
 8018e20: 9b04         	ldr	r3, [sp, #0x10]
 8018e22: e9d5 0100    	ldrd	r0, r1, [r5]
 8018e26: f04f 0200    	mov.w	r2, #0x0
 8018e2a: bf28         	it	hs
 8018e2c: 2201         	movhs	r2, #0x1
 8018e2e: 18d2         	adds	r2, r2, r3
 8018e30: 9b05         	ldr	r3, [sp, #0x14]
 8018e32: f143 0300    	adc	r3, r3, #0x0
 8018e36: 1838         	adds	r0, r7, r0
 8018e38: eb48 0101    	adc.w	r1, r8, r1
 8018e3c: 42b8         	cmp	r0, r7
 8018e3e: eb71 0108    	sbcs.w	r1, r1, r8
 8018e42: e9d5 c102    	ldrd	r12, r1, [r5, #8]
 8018e46: bf34         	ite	lo
 8018e48: 2001         	movlo	r0, #0x1
 8018e4a: 2000         	movhs	r0, #0x0
 8018e4c: eb14 0c0c    	adds.w	r12, r4, r12
 8018e50: eb46 0101    	adc.w	r1, r6, r1
 8018e54: eb10 000c    	adds.w	r0, r0, r12
 8018e58: f141 0100    	adc	r1, r1, #0x0
 8018e5c: 42a0         	cmp	r0, r4
 8018e5e: eb71 0c06    	sbcs.w	r12, r1, r6
 8018e62: bf34         	ite	lo
 8018e64: f04f 0c01    	movlo.w	r12, #0x1
 8018e68: f04f 0c00    	movhs.w	r12, #0x0
 8018e6c: e9cd 2304    	strd	r2, r3, [sp, #16]
 8018e70: f1a9 0a41    	sub.w	r10, r9, #0x41
 8018e74: eb1c 0202    	adds.w	r2, r12, r2
 8018e78: f143 0300    	adc	r3, r3, #0x0
 8018e7c: f8cd a000    	str.w	r10, [sp]
 8018e80: f000 f883    	bl	0x8018f8a <__shiftright128> @ imm = #0x106
 8018e84: 9b10         	ldr	r3, [sp, #0x40]
 8018e86: e9c3 0100    	strd	r0, r1, [r3]
 8018e8a: 9b12         	ldr	r3, [sp, #0x48]
 8018e8c: 2b01         	cmp	r3, #0x1
 8018e8e: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 8018e92: d129         	bne	0x8018ee8 <mulShiftAll64+0x10a> @ imm = #0x52
 8018e94: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 8018e98: e9d5 c500    	ldrd	r12, r5, [r5]
 8018e9c: 1a20         	subs	r0, r4, r0
 8018e9e: eb66 0101    	sbc.w	r1, r6, r1
 8018ea2: 4567         	cmp	r7, r12
 8018ea4: eb78 0505    	sbcs.w	r5, r8, r5
 8018ea8: bf34         	ite	lo
 8018eaa: 2501         	movlo	r5, #0x1
 8018eac: 2500         	movhs	r5, #0x0
 8018eae: 1b40         	subs	r0, r0, r5
 8018eb0: f161 0100    	sbc	r1, r1, #0x0
 8018eb4: 4284         	cmp	r4, r0
 8018eb6: eb76 0501    	sbcs.w	r5, r6, r1
 8018eba: bf34         	ite	lo
 8018ebc: 2501         	movlo	r5, #0x1
 8018ebe: 2500         	movhs	r5, #0x0
 8018ec0: 1b52         	subs	r2, r2, r5
 8018ec2: f8cd a000    	str.w	r10, [sp]
 8018ec6: f163 0300    	sbc	r3, r3, #0x0
 8018eca: f000 f85e    	bl	0x8018f8a <__shiftright128> @ imm = #0xbc
 8018ece: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 8018ed2: e9cb 0100    	strd	r0, r1, [r11]
 8018ed6: f8cd a000    	str.w	r10, [sp]
 8018eda: 4620         	mov	r0, r4
 8018edc: 4631         	mov	r1, r6
 8018ede: f000 f854    	bl	0x8018f8a <__shiftright128> @ imm = #0xa8
 8018ee2: b007         	add	sp, #0x1c
 8018ee4: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8018ee8: eb17 0e07    	adds.w	lr, r7, r7
 8018eec: eb48 0c08    	adc.w	r12, r8, r8
 8018ef0: 1920         	adds	r0, r4, r4
 8018ef2: eb46 0106    	adc.w	r1, r6, r6
 8018ef6: 45be         	cmp	lr, r7
 8018ef8: eb7c 0808    	sbcs.w	r8, r12, r8
 8018efc: bf34         	ite	lo
 8018efe: 2701         	movlo	r7, #0x1
 8018f00: 2700         	movhs	r7, #0x0
 8018f02: 19c7         	adds	r7, r0, r7
 8018f04: f141 0800    	adc	r8, r1, #0x0
 8018f08: e9d5 0100    	ldrd	r0, r1, [r5]
 8018f0c: 4586         	cmp	lr, r0
 8018f0e: eb7c 0c01    	sbcs.w	r12, r12, r1
 8018f12: e9d5 1502    	ldrd	r1, r5, [r5, #8]
 8018f16: bf34         	ite	lo
 8018f18: 2001         	movlo	r0, #0x1
 8018f1a: 2000         	movhs	r0, #0x0
 8018f1c: 1a38         	subs	r0, r7, r0
 8018f1e: f168 0c00    	sbc	r12, r8, #0x0
 8018f22: 1a40         	subs	r0, r0, r1
 8018f24: eb6c 0105    	sbc.w	r1, r12, r5
 8018f28: 1892         	adds	r2, r2, r2
 8018f2a: 415b         	adcs	r3, r3
 8018f2c: 42a7         	cmp	r7, r4
 8018f2e: eb78 0506    	sbcs.w	r5, r8, r6
 8018f32: bf34         	ite	lo
 8018f34: 2501         	movlo	r5, #0x1
 8018f36: 2500         	movhs	r5, #0x0
 8018f38: 1952         	adds	r2, r2, r5
 8018f3a: f143 0300    	adc	r3, r3, #0x0
 8018f3e: 4287         	cmp	r7, r0
 8018f40: eb78 0801    	sbcs.w	r8, r8, r1
 8018f44: bf34         	ite	lo
 8018f46: 2501         	movlo	r5, #0x1
 8018f48: 2500         	movhs	r5, #0x0
 8018f4a: 1b52         	subs	r2, r2, r5
 8018f4c: f1a9 0540    	sub.w	r5, r9, #0x40
 8018f50: 9500         	str	r5, [sp]
 8018f52: e7b8         	b	0x8018ec6 <mulShiftAll64+0xe8> @ imm = #-0x90

08018f54 <__umul128>:
 8018f54: b5f0         	push	{r4, r5, r6, r7, lr}
 8018f56: 460f         	mov	r7, r1
 8018f58: 4604         	mov	r4, r0
 8018f5a: fba0 0102    	umull	r0, r1, r0, r2
 8018f5e: fba7 5202    	umull	r5, r2, r7, r2
 8018f62: 1949         	adds	r1, r1, r5
 8018f64: fba3 4504    	umull	r4, r5, r3, r4
 8018f68: f142 0200    	adc	r2, r2, #0x0
 8018f6c: fba7 7303    	umull	r7, r3, r7, r3
 8018f70: 1861         	adds	r1, r4, r1
 8018f72: f145 0400    	adc	r4, r5, #0x0
 8018f76: 19d2         	adds	r2, r2, r7
 8018f78: 9e05         	ldr	r6, [sp, #0x14]
 8018f7a: f143 0300    	adc	r3, r3, #0x0
 8018f7e: 1912         	adds	r2, r2, r4
 8018f80: f143 0300    	adc	r3, r3, #0x0
 8018f84: e9c6 2300    	strd	r2, r3, [r6]
 8018f88: bdf0         	pop	{r4, r5, r6, r7, pc}

08018f8a <__shiftright128>:
 8018f8a: b5f0         	push	{r4, r5, r6, r7, lr}
 8018f8c: 9c05         	ldr	r4, [sp, #0x14]
 8018f8e: f1c4 0740    	rsb.w	r7, r4, #0x40
 8018f92: f1c4 0620    	rsb.w	r6, r4, #0x20
 8018f96: fa02 f606    	lsl.w	r6, r2, r6
 8018f9a: f1a4 0520    	sub.w	r5, r4, #0x20
 8018f9e: 40bb         	lsls	r3, r7
 8018fa0: fa22 f505    	lsr.w	r5, r2, r5
 8018fa4: 4333         	orrs	r3, r6
 8018fa6: f1c4 0620    	rsb.w	r6, r4, #0x20
 8018faa: 432b         	orrs	r3, r5
 8018fac: fa01 f606    	lsl.w	r6, r1, r6
 8018fb0: f1a4 0520    	sub.w	r5, r4, #0x20
 8018fb4: 40e0         	lsrs	r0, r4
 8018fb6: fa21 f505    	lsr.w	r5, r1, r5
 8018fba: 4330         	orrs	r0, r6
 8018fbc: 40ba         	lsls	r2, r7
 8018fbe: 4328         	orrs	r0, r5
 8018fc0: 40e1         	lsrs	r1, r4
 8018fc2: 4310         	orrs	r0, r2
 8018fc4: 4319         	orrs	r1, r3
 8018fc6: bdf0         	pop	{r4, r5, r6, r7, pc}

08018fc8 <__dtox_engine>:
 8018fc8: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 8018fcc: 4604         	mov	r4, r0
 8018fce: 0fcd         	lsrs	r5, r1, #0x1f
 8018fd0: f3c1 500a    	ubfx	r0, r1, #0x14, #0xb
 8018fd4: f3c1 0113    	ubfx	r1, r1, #0x0, #0x14
 8018fd8: ea54 0701    	orrs.w	r7, r4, r1
 8018fdc: 7115         	strb	r5, [r2, #0x4]
 8018fde: f240 76ff    	movw	r6, #0x7ff
 8018fe2: d007         	beq	0x8018ff4 <__dtox_engine+0x2c> @ imm = #0xe
 8018fe4: 42b0         	cmp	r0, r6
 8018fe6: d10c         	bne	0x8019002 <__dtox_engine+0x3a> @ imm = #0x18
 8018fe8: f045 0508    	orr	r5, r5, #0x8
 8018fec: 7115         	strb	r5, [r2, #0x4]
 8018fee: 2000         	movs	r0, #0x0
 8018ff0: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 8018ff4: 2800         	cmp	r0, #0x0
 8018ff6: d063         	beq	0x80190c0 <__dtox_engine+0xf8> @ imm = #0xc6
 8018ff8: 42b0         	cmp	r0, r6
 8018ffa: d15e         	bne	0x80190ba <__dtox_engine+0xf2> @ imm = #0xbc
 8018ffc: f045 0504    	orr	r5, r5, #0x4
 8019000: e7f4         	b	0x8018fec <__dtox_engine+0x24> @ imm = #-0x18
 8019002: 2800         	cmp	r0, #0x0
 8019004: d159         	bne	0x80190ba <__dtox_engine+0xf2> @ imm = #0xb2
 8019006: 2001         	movs	r0, #0x1
 8019008: f2a0 30ff    	subw	r0, r0, #0x3ff
 801900c: 2b00         	cmp	r3, #0x0
 801900e: 6010         	str	r0, [r2]
 8019010: db59         	blt	0x80190c6 <__dtox_engine+0xfe> @ imm = #0xb2
 8019012: 2b0c         	cmp	r3, #0xc
 8019014: dc59         	bgt	0x80190ca <__dtox_engine+0x102> @ imm = #0xb2
 8019016: f1c3 050d    	rsb.w	r5, r3, #0xd
 801901a: 00ad         	lsls	r5, r5, #0x2
 801901c: 2001         	movs	r0, #0x1
 801901e: f105 3cff    	add.w	r12, r5, #0xffffffff
 8019022: f1a5 0721    	sub.w	r7, r5, #0x21
 8019026: f1c5 0621    	rsb.w	r6, r5, #0x21
 801902a: fa20 f606    	lsr.w	r6, r0, r6
 801902e: fa00 f707    	lsl.w	r7, r0, r7
 8019032: fa00 f00c    	lsl.w	r0, r0, r12
 8019036: 4337         	orrs	r7, r6
 8019038: 1806         	adds	r6, r0, r0
 801903a: eb47 0807    	adc.w	r8, r7, r7
 801903e: f1d6 0e00    	rsbs.w	lr, r6, #0x0
 8019042: eb68 0c48    	sbc.w	r12, r8, r8, lsl #1
 8019046: 3e01         	subs	r6, #0x1
 8019048: f148 38ff    	adc	r8, r8, #0xffffffff
 801904c: 4026         	ands	r6, r4
 801904e: ea08 0801    	and.w	r8, r8, r1
 8019052: 42b0         	cmp	r0, r6
 8019054: eb77 0808    	sbcs.w	r8, r7, r8
 8019058: db0f         	blt	0x801907a <__dtox_engine+0xb2> @ imm = #0x1e
 801905a: f1c5 0820    	rsb.w	r8, r5, #0x20
 801905e: f1b5 0620    	subs.w	r6, r5, #0x20
 8019062: fa01 f808    	lsl.w	r8, r1, r8
 8019066: fa24 f505    	lsr.w	r5, r4, r5
 801906a: ea45 0508    	orr.w	r5, r5, r8
 801906e: bf5c         	itt	pl
 8019070: fa41 f606    	asrpl.w	r6, r1, r6
 8019074: 4335         	orrpl	r5, r6
 8019076: 07ed         	lsls	r5, r5, #0x1f
 8019078: d503         	bpl	0x8019082 <__dtox_engine+0xba> @ imm = #0x6
 801907a: 1820         	adds	r0, r4, r0
 801907c: 4604         	mov	r4, r0
 801907e: eb41 0107    	adc.w	r1, r1, r7
 8019082: ea04 040e    	and.w	r4, r4, lr
 8019086: ea01 010c    	and.w	r1, r1, r12
 801908a: f89d 6018    	ldrb.w	r6, [sp, #0x18]
 801908e: 3212         	adds	r2, #0x12
 8019090: 4618         	mov	r0, r3
 8019092: 250d         	movs	r5, #0xd
 8019094: f1c6 0627    	rsb.w	r6, r6, #0x27
 8019098: f04f 0e30    	mov.w	lr, #0x30
 801909c: f004 030f    	and	r3, r4, #0xf
 80190a0: 0924         	lsrs	r4, r4, #0x4
 80190a2: ea44 7401    	orr.w	r4, r4, r1, lsl #28
 80190a6: f105 3cff    	add.w	r12, r5, #0xffffffff
 80190aa: 1109         	asrs	r1, r1, #0x4
 80190ac: 1e57         	subs	r7, r2, #0x1
 80190ae: b9b3         	cbnz	r3, 0x80190de <__dtox_engine+0x116> @ imm = #0x2c
 80190b0: 42a8         	cmp	r0, r5
 80190b2: da0c         	bge	0x80190ce <__dtox_engine+0x106> @ imm = #0x18
 80190b4: 4665         	mov	r5, r12
 80190b6: 463a         	mov	r2, r7
 80190b8: e7f0         	b	0x801909c <__dtox_engine+0xd4> @ imm = #-0x20
 80190ba: f441 1180    	orr	r1, r1, #0x100000
 80190be: e7a3         	b	0x8019008 <__dtox_engine+0x40> @ imm = #-0xba
 80190c0: 4604         	mov	r4, r0
 80190c2: 4601         	mov	r1, r0
 80190c4: e7a2         	b	0x801900c <__dtox_engine+0x44> @ imm = #-0xbc
 80190c6: 2300         	movs	r3, #0x0
 80190c8: e7df         	b	0x801908a <__dtox_engine+0xc2> @ imm = #-0x42
 80190ca: 230d         	movs	r3, #0xd
 80190cc: e7dd         	b	0x801908a <__dtox_engine+0xc2> @ imm = #-0x46
 80190ce: f882 e000    	strb.w	lr, [r2]
 80190d2: f11c 0301    	adds.w	r3, r12, #0x1
 80190d6: 4665         	mov	r5, r12
 80190d8: 463a         	mov	r2, r7
 80190da: d1df         	bne	0x801909c <__dtox_engine+0xd4> @ imm = #-0x42
 80190dc: e788         	b	0x8018ff0 <__dtox_engine+0x28> @ imm = #-0xf0
 80190de: 2b09         	cmp	r3, #0x9
 80190e0: bfc8         	it	gt
 80190e2: 199b         	addgt	r3, r3, r6
 80190e4: 3330         	adds	r3, #0x30
 80190e6: 42a8         	cmp	r0, r5
 80190e8: 7013         	strb	r3, [r2]
 80190ea: bfb8         	it	lt
 80190ec: 4628         	movlt	r0, r5
 80190ee: e7f0         	b	0x80190d2 <__dtox_engine+0x10a> @ imm = #-0x20

080190f0 <__aeabi_read_tp>:
; 	ldr r0, =z_arm_tls_ptr
 80190f0: 4801         	ldr	r0, [pc, #0x4]          @ 0x80190f8 <__aeabi_read_tp+0x8>
; 	ldr r0, [r0]
 80190f2: 6800         	ldr	r0, [r0]
; 	bx lr
 80190f4: 4770         	bx	lr

080190f6 <$d>:
 80190f6: 00 00        	.short	0x0000

080190f8 <$d>:
 80190f8: ec 0a 00 20  	.word	0x20000aec
